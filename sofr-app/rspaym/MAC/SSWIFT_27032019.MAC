/*****T:\payments_security\payments_test\MAC\SSWIFT.MAC*************************************************************************
 Отправка и прием документов в Swift формате

Настройка:
Изменения: 06.02.2013 voikin Добавлен поиск признаков дубликатов (PDM, PDE) в
                              блоках 4 и 5
*******************************************************************************/
import uf_general, delzero,"empty.cls", bankinfo, utils, mtconsts/*, pcre_dlm*/, Fields,TransFld, ips_utils, utils_scr, "HMACSHA.d32";

/* Загрузка SWIFT/Telex */
var inpstr = "",
    MesForm = "",
    MsgBeginMarker = "";


var PayObj = NULL;
var MTRec = NULL;

var NameFile="",
   OutNameFile="",
   Dest="" ,
   ErrTrnMsg = "",   /* Описание ошибки, произошедшей внутри транзакции */
   formstr = "";

var st = null;
var gst = null;

const ClientDepoAcc = 45660;

macro AddErrTrnMsg(_msg:string)
  if(strlen(_msg))
    ErrTrnMsg = ErrTrnMsg + _msg + "\n";
  end;
end;

macro LeadZero (str:string, FullLen)
  if(strlen(str) < FullLen)
    return MkStr("0", FullLen - strlen(str)) + str;
  else
    return Substr(str, 1, FullLen);
  end;
end;


macro FindCodeBank(Dest)
  Dest = trim(Dest);
  if(Dest == "")
    return false;
  end;
  if (not FindBank (Dest))
    AddPtk("В справочнике банков ОДБ отсутствует банк с БИК " + Dest);
    return false;
  end;
  return true;
end;

macro RewriteFile(OpName:string, NameFile:string)
  var NameFile2 = NameFile;
  if(ExistFile (NameFile2))
    if(not DeleteFile(NameFile))
      CommentStr =  "невозможно удалить файл " + NameFile + " для создания нового файла ";
      return false;
    end;
    AddPtk(OpName + "Существующий файл " + NameFile + " удалён");
  end;
  return true;
end;

/*----------------------------------------------------------------------------*/
macro FindCur(str)
  if (str == "RUR")
    str = "RUB";
  end;
  return GetColByCol ("sfi","id_sfi","strcode", str);
end;
/*----------------------------------------------------------------------------*/
macro AddCommentStr(str)
  CommentStr=CommentStr+str;
end;
/*----------------------------------------------------------------------------*/
/*выводит строку в текстовый файл*/
/*----------------------------------------------------------------------------*/
macro printstr(str1,str2)
  if(trim(str2)!="")
    return str1+str2;
  end;
end;
/*----------------------------------------------------------------------------
печатает первую строку сообщения, принимает строку формы , референс и SWIFT БИК
получателя
----------------------------------------------------------------------------*/
macro prheader(form, ID_NKS, bicRecv)

  var tag3="";

  if(StrLen(bicRecv) == 8)
    bicRecv = bicRecv + "XXXX";
  elif(StrLen(bicRecv) == 11)
    bicRecv = SubStr(bicRecv,1,8) + "X" + SubStr(bicRecv,9);
  end;

//  if(substr(ref,1,1)=="+")
  if  (ID_NKS == ID_NKS_RUR6)
       tag3="{3:{113:RUR6}}";
  elif(ID_NKS == ID_NKS_RUS9)
       tag3="{3:{113:RUS9}}";
  end;
  return "{1:F01"+MySWIFTBic+"AXXX0000000000}{2:I"+form +bicRecv+"N}"+tag3+"{4:";
end;
/*----------------------------------------------------------------------------
печатаетпоследнюю строку сообщения
----------------------------------------------------------------------------*/
macro prend()
  return "-}";
end;
/*----------------------------------------------------------------------------*/
/* формирование имени файла для отправляемого SWIFT сообщения */
MACRO GetNewNameFile (paymObj)
  var NameFile = "", id, s;
  id  = string(toid(paymObj.paym.id_paym));
  NameFile = id ;
  if(StrLen(NameFile)<8)
     s = "c" + MkStr("0", 7-StrLen(NameFile));
     NameFile=s+NameFile;
  else
     NameFile= "c" + SubStr(NameFile,strlen(NameFile)-6);
  end;
  NameFile=NameFile+ SwiftOutExt;
  return NameFile;
END;
/*----------------------------------------------------------------------------*/
/*Получить ID шлюза*/
/*MACRO GetFrnSys(ID_NKS)
  var qtext, qry, res = "";

  if(ValType(ID_NKS) != V_Undef)
    qtext = "select t.frnsys as frnsys \n" +
             "from nks t\n"+
             "where \n"+
             "t.id_nks = :p1 \n";

    qry = ExecQuery (qtext, ID_NKS);
    if (not TstObj (qry))
        RunError (toansi("Отправка в SWIFT: ошибка в запросе выборки ID шлюза"));
    end;

    res = qry.rec.frnsys;
  end;
  return res;
END;
*/
/*----------------------------------------------------------------------------*/
/*MACRO TranslitStr(Str, dir, ID_NKS)
  var RetStr = "";
  if    (ID_NKS == ID_NKS_RUR6)
    RetStr = TransStringRur6(Str,dir);
  elif  (ID_NKS == ID_NKS_RUS9)
    RetStr = TransStringRur6(Str,dir,True);
  elif(ID_NKS == ID_NKS_CLEAR)
    RetStr = TransStringCLEAR(Str, dir);
  else
    RetStr = Str;
  end;
  return RetStr;
END;
*/
/*----------------------------------------------------------------------------*/
MACRO ClearSubFields(Fld,StartIndex)
  var i = StartIndex;
  while(i < Fld.SubFields.size)
    Fld.Clear(i);/*чистим подполе*/
    i = i + 1;
  end;
END;
/*----------------------------------------------------------------------------*/
/*Транслитерирует строку и разбивает на сегменты заданной длины, которые помещает в массив.
Возвращает транслитерированную строку*/
/*  _StrForTranslit - строка для танслитерации,
    dir - направление транслитерации,
    ID_NKS - идентификатор шлюза, по которому определяется способ транслитерации RUR6/CLEAR,
    TranslitedArr - массив, в который будут помещены сегменты,
    SplitLen - длина сегмента
*/
MACRO TranslitStrAndSplit(_StrForTranslit,_dir,_ID_NKS,_TranslitedArr,_SplitLen,_ChRN)
  var StrForTranslit = "", dir = 0, ID_NKS = "", SplitLen = 35, ChRN = "";
  var cnt=1, ch;

  if(ValType(_StrForTranslit) == V_UNDEF)
    return _StrForTranslit;
  end;
  StrForTranslit = _StrForTranslit;

  if(ValType(_dir) != V_UNDEF)
    dir = _dir;
  end;

  if(ValType(_ID_NKS) != V_UNDEF)
    ID_NKS = _ID_NKS;
  end;

  if(ValType(_ChRN) != V_UNDEF)
    ChRN = _ChRN;
  end;

  StrForTranslit = ChSubStr(StrForTranslit,"\r\n",ChRN);/*замена переноса строки*/
  StrForTranslit = TranslitStr(StrForTranslit,dir,ID_NKS);

  if(ValType(_TranslitedArr) == V_UNDEF)
    return StrForTranslit;
  end;

  if(ValType(_SplitLen) != V_UNDEF)
    SplitLen = _SplitLen;
  end;

  While(cnt<=strlen(StrForTranslit))
     ch= substr(StrForTranslit,cnt,1);
     if((ch==":")OR(ch=="-"))
       StrForTranslit=Trim(substr(StrForTranslit,1,cnt-1)+" "+substr(StrForTranslit,cnt));
     end;
     cnt=cnt+SplitLen;
  end;

  MyStrSplit(StrForTranslit,_TranslitedArr,SplitLen);/*Разобьем полученную строку на сегменты по 35 символам*/

  return StrForTranslit;
END;
/*----------------------------------------------------------------------------*/
/*Копирует массив Arr в подстроки поля Fld, начиная с подполя с индексом StartIndex(по умолчанию 0)*/
MACRO CopyArrToSubfields(Fld,Arr,StartIndex)
  var i = 0, TextStart = 0;

  if(ValType(StartIndex) != V_UNDEF)
    TextStart = StartIndex;
  end;

  while(i < ASize(Arr))
    Fld.SetSubField(TextStart, Arr(i));
    i = i + 1;
    TextStart = TextStart + 1;
  end;

  if(Fld.SubFields.Size > TextStart)
    Fld.SubFields.Size = TextStart;
  end;

END;
/*----------------------------------------------------------------------------*/
MACRO UnloadDocTrn(paymObj)
   var SentReference = "", NameFile, ArcPath = "", OutPath="", paym, mtrec, hdrform = "", tmp, strmsg;
   var ID_NKS = "";
   var fldIdxArr;
   var CurFld, CurFldNum, StrForTranslit;
   var i;
   var TextStart;
   var PrefixStr;
   Array TranslitedArr;

   paym  = paymObj.paym;
   if(paym.id_nform == Type_Doc_MTn9X)
     mtrec = paymObj.mtn9x;
   else
     mtrec = paymObj.mtrec;
   end;

   /* определение имени файла */
   NameFile = GetNewNameFile(paymObj);
   ArcPath = SwiftArcDir + NameFile;
   OutPath = SwiftOutDir + NameFile;

   if(mtrec.type == 540)
     hdrform = "540";
   elif(mtrec.type == 541)
     hdrform = "541";
   elif(mtrec.type == 542)
     hdrform = "542";
   elif(mtrec.type == 543)
     hdrform = "543";
   elif(mtrec.type == 535)
     hdrform = "535";
   elif(mtrec.type == 536)
     hdrform = "536";
   elif(mtrec.type == 518)
     hdrform = "518";
   elif(mtrec.type == 599)
     hdrform = "599";
   elif(mtrec.type == 305)
     hdrform = "305";
   elif(mtrec.type == 360)
     hdrform = "360";
   elif(mtrec.type == 361)
     hdrform = "361";
   elif(mtrec.type == 362)
     hdrform = "362";
   elif(mtrec.type == 600)
     hdrform = "600";
   end;

   /* подготовка строки сообщения для записи в файл */
   ID_NKS = GetFrnSys(paym.ID_NKSOUTPUT);
/*
   if((ID_NKS == ID_NKS_RUR6)or(ID_NKS == ID_NKS_RUS9))
     SentReference = "+";/*признак наличия в сообщение 3-го блока*/
   end;
*/
   if(hdrform == 599)
     strmsg = mtrec.text;
   else
     strmsg = mtrec.str;
   end;

   fldIdxArr = Re_SearchStr(RN+strmsg, "(?m)\\xd\\xa:\\d{2}[A-Z]?.*:", 1, 1);

   if (not fldIdxArr.size OR mod (fldIdxArr, 2))
     CommentStr = "Ошибка при разборе полей сообщения ";
     return false;
   end;


   if (not ParceFields2 (RN+strmsg, fldIdxArr))
     CommentStr = ErrMsg;
     return false;
   end;

   CurFldNum = 0;
   while(CurFldNum < CurMsgFields.Size)

     CurFld = CurMsgFields[CurFldNum];
     StrForTranslit = "";

     if(ValType(CurFld) != V_UNDEF)
       if(CurFld.Num == "35")
         var TransName = false;
         i = 0;
         while(i < CurFld.SubFields.size)
           if(   (not index(CurFld.GetSubField(i),"ISIN"))
              and(not index(CurFld.GetSubField(i),"/RU/"))
//              and(not index(CurFld.GetSubField(i),"/XX/CORP/")))/*если пошла информация о ФИ в текстовом виде*/
              and(not index(CurFld.GetSubField(i),"/XX/")))/*если пошла информация о ФИ в текстовом виде*/
              if(StrForTranslit == "")/*если еще не взяли поле*/
                StrForTranslit = Trim(CurFld.GetFldString(i,false,false));
                TextStart = i;/*Запомним, с какой подстроки начинается текст*/
              end;
              CurFld.Clear(i);/*чистим подполе*/
              TransName = true;
           end;
           i = i + 1;
         end;

         if(TransName)
            TranslitStrAndSplit(StrForTranslit,0,ID_NKS,TranslitedArr,35);
            CopyArrToSubfields(CurFld,TranslitedArr,TextStart);
         end;

       elif(   (CurFld.Num == "70")
            or((CurFld.Num == "95")and(CurFld.Option == "Q")))

         StrForTranslit = Trim(CurFld.GetFldString(0,false,false));

         TextStart = 0;
         ClearSubFields(CurFld,TextStart);
         TranslitStrAndSplit(StrForTranslit,0,ID_NKS,TranslitedArr,35);

         CopyArrToSubfields(CurFld,TranslitedArr,TextStart);
       elif   (CurFld.Num == "36")

         StrForTranslit = Trim(CurFld.GetFldString(0,false,false));

         TextStart = 0;
         ClearSubFields(CurFld,TextStart);
         TranslitStrAndSplit(StrForTranslit,0,ID_NKS,TranslitedArr,35);

         CopyArrToSubfields(CurFld,TranslitedArr,TextStart);
       elif    (CurFld.Num == "97")
         StrForTranslit = Trim(CurFld.GetFldString(0,false,false));
         PrefixStr = SubStr(StrForTranslit,1,7);/*первые 5 символов + 2 слеша - не транслитерируем*/
         StrForTranslit = "12345//"+SubStr(StrForTranslit,8);

         TextStart = 0;
         ClearSubFields(CurFld,TextStart);
         TranslitStrAndSplit(StrForTranslit,0,ID_NKS,TranslitedArr,35);
         TranslitedArr(0) = PrefixStr + SubStr(TranslitedArr(0),8);

         CopyArrToSubfields(CurFld,TranslitedArr,TextStart);
       elif   (CurFld.Num == "79")

         StrForTranslit = Trim(CurFld.GetFldString(0,false,false));

         TextStart = 0;
         ClearSubFields(CurFld,TextStart);
         TranslitStrAndSplit(StrForTranslit,0,ID_NKS,TranslitedArr,35," ");

         CopyArrToSubfields(CurFld,TranslitedArr,TextStart);
       end;
     end;


     CurFldNum = CurFldNum + 1;
   end;

   tmp = prheader(hdrform, /*SentReference*/ID_NKS, paym.ReceiverBankID) + RN;
   i = 0;
   while(i < CurMsgFields.Size)
     CurFld = CurMsgFields[i];
     if(ValType(CurFld) != V_UNDEF)
       tmp = tmp + CurFld.GetFldString(Null, False, True);
     end;
     i = i + 1;
   end;

//   tmp = tmp + RN + mtrec.str + RN;
   tmp = tmp + prend();
/*
   println("----------------------");
   println(tmp);
   return false;
*/

   if (not SaveExp (paymObj, Tmp, Type_Exp_Origin, "Отправленное сообщение", CommentStr))
      return false;
   end;

   /* Сохранение исходящего референса */
   var qText = "begin RSP_PAYM_API.CRT_PAYMASSOCIATE (:p1,:p2,:p3); end;";
   var qry = ExecQuery (qText, paym.NUMREFERDOC, paym.ID_PAYM, ASS_SENT_REF);
   if (not TstObj (qry))
     CommentStr = "Ошибка при cохранении исходящего референса ";
     return false;
   end;

   CommentStr = "";

   if(not paymObj.ChangeState(StateSent2SWIFT, 0,"сформирован файл "+NameFile))
     CommentStr = "ошибка " + paymObj.Error + " при изменении состояния платежа " /*+ ToId(paymObj.id_paym)*/;
     return false;
   end;

   var key = GetKey, hash = "";//, ver;

   if(MDG == 1)
     if(hmacsha(trim(tmp), key, hash/*, ver*/) == 0)
       tmp = tmp + "{S:{MDG:"+hash+"}}";
     else
       CommentStr = "Ошибка вычисляния значения Хэша ";
       return false;
     end;
   end;

   return (WriteStrToFile(tmp, ArcPath) AND CloseAndCopy("Отправка в SWIFT:", ArcPath, OutPath));

END;

/****************************************************************************************
Отправка СВИФТа
*******************************************************************************************/
MACRO SENDSwift ()

  var qtext, qry, PaymObj;

  qtext = "select p.id_paym as id, p.id_nform as Idform, p.id_sstate as state, p.versionrec as vr \n" +
           "from paym p\n"+
           "where \n"+
           "p.id_sstate = :p1 \n";

 qry = ExecQuery (qtext, StateToSWIFT);
 if (not TstObj (qry))
     RunError (toansi("Отправка в SWIFT: ошибка в запросе выборки платежей для отправки"));
 end;
 while (not qry.eof)
  PaymObj = TRslPayDoc (ToId(qry.rec.Idform), ToId(qry.rec.id), ToId(qry.rec.vr));
  if (not TstObj (PaymObj))
     MakeErrorMsg("Отправка в SWIFT: ошибка при поиске платежа " + qry.rec.id + "/" + qry.rec.vr + ", id формы " + qry.rec.Idform);
     return ;
  end;
  AddPtk("Отправка в SWIFT: обрабатывается платеж " + ToId(qry.rec.id));
  if(Not UnloadDocTrn(PaymObj))
     OraTrnRollback();
     if(not strlen(CommentStr))
        CommentStr = "произошла неизвестная ошибка";
     end;
     MakeErrorMsg("Отправка в SWIFT: "+CommentStr);

     if (not PaymObj.ChangeState(ErrorStateSendSWIFT,0,CommentStr))
       MakeErrorMsg("Отправка в SWIFT: ошибка "+PaymObj.Error + " при изменении состояния платежа " +ToId(PaymObj.paym.id_paym));
       OraTrnRollback();
     end;
     OraTrnCommit();

  else
    OraTrnCommit();
    AddPtk("Отправка в SWIFT: отправлен платеж " + ToId(PaymObj.paym.id_paym) );
  end;
  qry.next();
 end; /* while */

END;

/*--------------------------------------------------*/
/*        InpStr - вторая секция сообщения          */
/*возвращает тип МТ-сообщения - 100, 200, 202 и т.д.*/
/*--------------------------------------------------*/
Macro MTMessageType(InpStr)
   Return SubStr(InpStr, 2, 3);
End;
/*--------------------------------------------------*/
Macro MTSection1Import(InpStr, MTRec)
Var Party;
   MTRec.Receiver = SubStr(InpStr, 4, 8);
   Party = SubStr(InpStr, 13, 3);
   If (Party != "XXX")
      MTRec.Receiver = MTRec.Receiver + Party;
   End;
   Return 0;
End;
/*--------------------------------------------------*/
Macro MTSection2Import(InpStr, MTRec)
Var Party, YY;
   MTRec.Sender = SubStr(InpStr, 15, 8);
   Party = SubStr(InpStr, 24, 3);
   If (Party != "XXX")
      MTRec.Sender = MTRec.Sender + Party;
   End;
   YY = Int(SubStr(InpStr, 9, 2));
   If (YY < 80)
      YY = 2000 + YY;
   Else
      YY = 1900 + YY;
   End;
   Return 0;
End;
/*--------------------------------------------------*/
/*voikin 05.02.2013 проверка наличия ассоциаций*/
macro CheckAssociate(_Pay, _associate:String, _id_sass:Integer):Bool
  var ret, qry, qtext ;

  qtext = "select p.id_paym as id\n"+
          "from paym p, payass ass \n"+
          "where p.id_sfi = :p1 and ass.id_paym = p.id_paym and ass.associate = :p2 and ass.id_sass =  :p3 and p.Amount = :p4 and p.ValueDate = :p5";

  qry = ExecQuery (qtext, _Pay.id_sFI, _associate, _id_sass, _Pay.Amount, _Pay.ValueDate);

  if (not TstObj (qry))
    RunError(ToANSI("ошибка в запросе проверки наличия ассоциаций"));
  end;
  ret = not qry.Eof;
  return ret;
end;

/*----------------------------------------------------------------------------*/
/*Поиск контрагента*/
/*----------------------------------------------------------------------------*/
macro GetKorrByBIC(_BIC,_ID_STBIC)
  var ID_STBIC = _ID_STBIC;

  if(ValType(_ID_STBIC)==V_UNDEF)
    ID_STBIC = BICRus_ID;
  end;

  if(ValType(_BIC)==V_UNDEF)
    return 0;
  end;

  var q = TRslOraQuery();
  q.SqlText = "select nvl(t.id_nkorr,-1) as id_nkorr "+
              "from NROUTE t "+
              "where t.id_stbic = :id_stbic "+
              "and t.bic = :BIC "+
              "order by t.prio ";
  q.DeclareAndSet("id_stbic",ID_STBIC,"bic",_BIC);

  if(not q.Execute())
    RunError(toansi("GetKorrByBIC:"+q.Error));
  end;

  if (q.RowCount == 0)
    AddPtk ("Контрагент с БИК =" + _Bic + " вида " + _ID_STBIC + " не найден");
    return 0;
  end;

  return q.GetByName("id_nkorr").AsInteger;

end;

macro CheckSign(Str, Sign)
  var key = GetKey, hash = "";//, ver;

  if(hmacsha(Str, key, hash/*, ver*/) == 0)
    if(hash != Sign)
      CommentStr = " Неверная подпись сообщения ";
      return true;
    end;
  else
    CommentStr = "Ошибка вычисляния значения Хэша ";
    return false;
  end;

end;

Macro LoadMultiMsgFileTrn(Str, IDED, PaymID:@integer)
  Var TmpStr, BlockLen, TmpStr1, TmpStr2, TmpStr3, TmpStr4, MTFieldAr, TmpStr5, TmpStrSign,
      PosIndex, MsgLoaded=0, Pos4, i,  newDocKind, newState, Fld32Str;
  const Block1Len = 29, Block2Len = 51, BlockSLen = 64;
  Var SerialStr = "", MT103SerialStr = "", MESSAGE_COUNT, Msg_Duplicated = FALSE;
  Var newmtreccls, mtrec, SwtPaym, Ref20 = "", Ref98 = "", pay;
  var Pos5Beg, Pos5End, PosSignBeg, PosSignEnd;
  var CurFld, fldIdxArr, CurFldNum, CurSeq, OldSeq, idx, StrForTranslit, TextStart, CommStr;
  var ID_NKS = ID_NKS_CLEAR;
  var PrefixStr;
  Array TranslitedArr;

  if(IDED)
    InpStr = Str;
    MsgBeginMarker = BLOCK1_HEAD;
  end;

  macro LoadOneMessage(PaymID:@integer)

    TmpStr1 = TmpStr2 = TmpStr3 = TmpStr4 = TmpStr5 = TmpStrSign = "";
    CommentStr = "";
    Msg_Duplicated = FALSE;
    var DuplComment = "";
    var SignComment = "";
    var DepoAcc;

   /* Разбор первого блока */
   TmpStr1 = SubStr(InpStr, index(InpStr, BLOCK1_HEAD + "F01"), Block1Len);
   InpStr = SubStr(InpStr, index(InpStr, BLOCK1_HEAD + "F01") + Block1Len);
   If (SubStr(TmpStr1, Block1Len, 1) != "}")
     MakeErrorMsg("Шлюз SWIFT: Неверная длина первого блока "+SwiftArcDir+NameFile);
     Return FALSE;
   End;
   /* Разбор второго блока */
   TmpStr2 = Index(InpStr, BLOCK2_HEAD);
   InpStr = SubStr(InpStr, TmpStr2);

   TmpStr2 = SubStr(InpStr, 1, Block2Len);
   InpStr = SubStr(InpStr, Block2Len+1);
   If (SubStr(TmpStr2, Block2Len, 1) != "}")
     MakeErrorMsg("Шлюз SWIFT: Неверная длина второго блока "+SwiftArcDir+NameFile);
     Return FALSE;
   End;
   /* Разбор _необязательного_ третьего блока */
    If(Index(InpStr, BLOCK3_HEAD) == 1)
     Pos4 = index(InpStr, BLOCK4_HEAD);
     TmpStr3 = SubStr(InpStr, 1, Pos4 - 1);
     InpStr  = SubStr(InpStr, Pos4);
     If(SubStr(TmpStr3, strlen(TmpStr3), 1) != "}")
       MakeErrorMsg("Шлюз SWIFT: Неверный формат третьего блока "+SwiftArcDir+NameFile);
       Return FALSE;
     End;
    End;
    TmpStr1 = substr(TmpStr1, strlen(BLOCK1_HEAD) + 1);
    TmpStr2 = substr(TmpStr2,   strlen(BLOCK2_HEAD) +1 );

    MesForm = MTMessageType(TmpStr2);
    if(not index("535, 536, 544, 545, 546, 547, 548, 599, 518, 600", MesForm))
      AddPtk("Шлюз SWIFT: Пропущена незагружаемая форма "+ MesForm+" файл "+NameFile);
      InpStr = trim (SubStr (InpStr,  Index(InpStr, BLOCK1_HEAD + "F01")));
      return true;
    end;
    /* Разбор четвертого блока */
    If ((BlockLen = Index(InpStr, BLOCK4_TAIL)) == 0)
      MakeErrorMsg("Шлюз SWIFT: Неверное окончание четвертого блока "+SwiftArcDir+NameFile);
      Return FALSE;
    End;
    /*Выделили блок (без символов начала и окончания блока)
    и оставшуюся часть входной строки */
    TmpStr4 = SubStr(InpStr, strlen(BLOCK4_HEAD)-1, BlockLen - strlen(BLOCK4_TAIL));
    InpStr = SubStr(InpStr, BlockLen + StrLen(BLOCK4_TAIL));

/*
 AB 07.12.09
 В 4-м блоке сообщения может попадаться :PDE:,как признак дублирования сообщения
 В этом случае :PDE: и все,  что после него вырезаем  и взводим признак дублирования
*/
    PosIndex = Index (TmpStr4, RN + ":"+DOUBLE_MSG2);
    if (PosIndex)
      TmpStr4 = Substr (TmpStr4, 1, PosIndex - 1) + Substr (TmpStr4, index(TmpStr4, "-}"));
      Msg_Duplicated = TRUE;
    end;

    /*voikin Разбор 5-го блока*/
    Pos5Beg = Index(InpStr, BLOCK5_HEAD);

    if(Index(InpStr, BLOCK_S_HEAD))
      Pos5End = Index(InpStr, BLOCK_S_HEAD);
    else
      Pos5End = Index(InpStr, BLOCK1_HEAD);
    end;

    if(Pos5Beg and Pos5End)
      TmpStr5 = Trim(SubStr(InpStr, Pos5Beg, Pos5End - Pos5Beg));
      InpStr = SubStr(InpStr, Pos5End);
    elif(Pos5Beg)
      TmpStr5 = Trim(InpStr);
      InpStr = SubStr(InpStr, Pos5End);
    end;

    Msg_Duplicated = Msg_Duplicated OR (Index(TmpStr5, "{"+DOUBLE_MSG) > 0) OR (Index(TmpStr5, "{"+DOUBLE_MSG2) > 0);

    /*Разбор S-блока*/
    PosSignBeg = Index(InpStr, BLOCK_S_HEAD);
    PosSignEnd = Index(InpStr, BLOCK1_HEAD);

    if(PosSignBeg and PosSignEnd)
      TmpStrSign = Trim(SubStr(InpStr, PosSignBeg, PosSignEnd - PosSignBeg));
      InpStr = SubStr(InpStr, PosSignEnd);
    elif(PosSignBeg)
      TmpStrSign = Trim(InpStr);
      InpStr = SubStr(InpStr, PosSignEnd);
    end;

    SerialStr = TmpStr4;

    fldIdxArr = Re_SearchStr(SerialStr, "(?m)\\xd\\xa:\\d{2}[A-Z]?.*:", 1, 1);
    if (not fldIdxArr.size OR mod (fldIdxArr, 2))
      MakeErrorMsg("Шлюз SWIFT: Ошибка при разборе полей сообщения ");
      return false;
    end;

    if (not ParceFields2 (SerialStr, fldIdxArr))
      MakeErrorMsg("Шлюз SWIFT: "+ErrMsg);
      return false;
    end;

    if(MesForm == 518)
      SwtPaym = TRslPayDoc (Type_Doc_MT518, 0);
      mtrec = SwtPaym.mtrec;
    elif(MesForm == 599)
      SwtPaym = TRslPayDoc (Type_Doc_MTn9X, 0);
      mtrec = SwtPaym.mtn9x;
    elif(MesForm == 535)
      SwtPaym = TRslPayDoc (Type_Doc_MT53X, 0);
      mtrec = SwtPaym.mtrec;
    elif(MesForm == 600)
      SwtPaym = TRslPayDoc (Type_Doc_MT6XX, 0);
      mtrec = SwtPaym.mtrec;
    else
      SwtPaym = TRslPayDoc (Type_Doc_MT54X, 0);
      mtrec = SwtPaym.mtrec;
    end;
    if (not TstObj(SwtPaym))
      MakeErrorMsg("Шлюз SWIFT: ошибка при создании объекта типа " + newDocKind);
      Return FALSE;
    end;

    mtrec.type = MesForm;

    If (MTSection1Import(TmpStr1, mtrec) != 0)
      MakeErrorMsg("Шлюз SWIFT: ошибка при разборе первого блока сообщения");
      Return FALSE;
    End;

    If (MTSection2Import(TmpStr2, mtrec) != 0)
      MakeErrorMsg("Шлюз SWIFT: ошибка при разборе второго блока сообщения");
      Return FALSE;
    End;

    if(TmpStr3 != "")
      if  (index(TmpStr3,"RUR6"))
        ID_NKS = ID_NKS_RUR6;
      elif(index(TmpStr3,"RUS9"))
        ID_NKS = ID_NKS_RUS9;
      end;
    end;

    pay = SwtPaym.paym;

    if(IDED)
      pay.id_spClass = Class_Doc_MCI;
    else
      pay.id_spClass = Class_Doc_SWIFT;
    end;
/*
    Ref20 = MTRecCls.GetField("20").GetSubField("Reference").Value;
    Pay.id_sFI = FindCur(MTRecCls.GetField("32", "A").GetSubField("Code_Currency").Value);
    Pay.ValueDate = MTRecCls.GetField("32", "A").GetSubField("ValueDate").Value;
    Pay.Amount = MTRecCls.GetField("32", "A").GetSubField("Amount").Value;
    if (newDocKind == TYPE_DOC_MT900)
     pay.DC = 1;
    else
     pay.DC = 0;
    end;
*/

    CurFldNum = 0;
    CurSeq = "";
    OldSeq = "";
    while(CurFldNum < CurMsgFields.Size)
     // debugbreak;
      CurFld = CurMsgFields[CurFldNum];
      if  ((CurFld.Num == "16")and(CurFld.Option == "R"))/*признак начала секции*/
        if(CurSeq != "")/*если уже находимся в како-то секции*/
          OldSeq = CurSeq;/*сохраним ее*/
        end;
        CurSeq = CurFld.GetSubField(0);/*установим новую секцию*/
      elif((CurFld.Num == "16")and(CurFld.Option == "S"))/*признак конца секции*/
        if(OldSeq != "")
          CurSeq = OldSeq;
        else
          CurSeq = "";
        end;
      elif((CurFld.Num == "20")and(CurSeq == "GENL"))/*из секции "А Общая информация"*/
        //debugbreak;
        Ref20 = SubStr(CurFld.GetSubField(0),8);
      elif((MesForm == 535) and (CurSeq == "GENL") and (CurFld.Num == "97") and (CurFld.Option == "A"))
        //debugbreak;
        DepoAcc = SubStr(CurFld.GetSubField(0),8);


      elif((CurFld.Num == "20")and(MesForm == 599))/*из секции "А Общая информация"*/
        //debugbreak;
        Ref20 = SubStr(CurFld.GetSubField(0),8);
      elif((CurFld.Num == "20")and(MesForm == 600))/*из секции "А Общая информация"*/
        Ref20 = CurFld.GetSubField(0);
      elif((CurFld.Num == "98")and(CurSeq == "GENL"))/*из секции "А Общая информация"*/
        Ref98 = stringToDtTm(SubStr(CurFld.GetSubField(0),8), "yyyymmddHHMMSS");

      elif(CurFld.Num == "35")
        var TransName = false;
        i = 0;
        StrForTranslit = "";
        while(i < CurFld.SubFields.size)
          if(   (not index(CurFld.GetSubField(i),"ISIN"))
             and(not index(CurFld.GetSubField(i),"/RU/"))
             and(not index(CurFld.GetSubField(i),"/XX/")))/*если пошла информация о ФИ в текстовом виде*/

             if(StrForTranslit == "")/*если еще не взяли поле*/
               StrForTranslit = Trim(CurFld.GetFldString(i,false,false));
               TextStart = i;/*Запомним, с какой подстроки начинается текст*/
             end;
             CurFld.Clear(i);/*чистим подполе*/
             TransName = true;
          end;
          i = i + 1;
        end;

        if(TransName)
           TranslitStrAndSplit(StrForTranslit,1,ID_NKS,TranslitedArr);
           CopyArrToSubfields(CurFld,TranslitedArr,TextStart);
        end;

      elif(   (CurFld.Num == "70")
           or((CurFld.Num == "95")and(CurFld.Option == "Q")))

        StrForTranslit = Trim(CurFld.GetFldString(0,false,false));

        TextStart = 0;
        ClearSubFields(CurFld,TextStart);
        TranslitStrAndSplit(StrForTranslit,1,ID_NKS,TranslitedArr,35);
        CopyArrToSubfields(CurFld,TranslitedArr,TextStart);

      elif   (CurFld.Num == "36")

        StrForTranslit = Trim(CurFld.GetFldString(0,false,false));

        TextStart = 0;
        ClearSubFields(CurFld,TextStart);
        TranslitStrAndSplit(StrForTranslit,1,ID_NKS,TranslitedArr,35);
        CopyArrToSubfields(CurFld,TranslitedArr,TextStart);

      elif   (CurFld.Num == "79")

        StrForTranslit = Trim(CurFld.GetFldString(0,false,false));

        TextStart = 0;
        ClearSubFields(CurFld,TextStart);
        TranslitStrAndSplit(StrForTranslit,1,ID_NKS,TranslitedArr,35);
        CopyArrToSubfields(CurFld,TranslitedArr,TextStart);

      elif    (CurFld.Num == "97")
         StrForTranslit = Trim(CurFld.GetFldString(0,false,false));
         PrefixStr = SubStr(StrForTranslit,1,7);/*первые 5 символов + 2 слеша - не транслитерируем*/
         StrForTranslit = "12345//"+SubStr(StrForTranslit,8);

         TextStart = 0;
         ClearSubFields(CurFld,TextStart);
         TranslitStrAndSplit(StrForTranslit,1,ID_NKS,TranslitedArr,35);
         TranslitedArr(0) = PrefixStr + SubStr(TranslitedArr(0),8);

         CopyArrToSubfields(CurFld,TranslitedArr,TextStart);

      elif((CurFld.Num == "98")and(CurSeq == "TRADDET")and index(CurFld.GetSubField(0),"ESET//"))/*из секции "В Детали сделки"*/
        Pay.ValueDate = ClrStr2Date(SubStr(CurFld.GetSubField(0),8));
        pay.DateReferDoc = pay.ValueDate;

      elif((MesForm == "548")and(CurFld.Num == "98")and(CurSeq == "GENL"))
        Pay.ValueDate = ClrStr2Date(SubStr(CurFld.GetSubField(0),8));
        pay.DateReferDoc = pay.ValueDate;

      elif((MesForm == "535")and(CurSeq == "GENL")and(CurFld.Num == "98")and index(CurFld.GetSubField(0),"STAT//"))
        Pay.ValueDate = ClrStr2Date(SubStr(CurFld.GetSubField(0),8));

      elif((MesForm == "535")and(CurSeq == "GENL")and index(CurFld.GetSubField(0),"PREP//"))
        Pay.DateReferDoc = ClrStr2Date(SubStr(CurFld.GetSubField(0),8));

      elif((MesForm == "599")or(MesForm == "535"))
        Pay.ValueDate = {curdate};
      end;

      CurFldNum = CurFldNum + 1;
    end;

    var msgstr;

    msgstr = "";
    i = 0;
    while(i < CurMsgFields.Size)
      CurFld = CurMsgFields[i];
      if(ValType(CurFld) != V_UNDEF)
        msgstr = msgstr + CurFld.GetFldString(Null, False, True);
      end;
      i = i + 1;
    end;

    if(MesForm == "518")
      mtrec.Str = msgstr;
    elif(MesForm == "599")
      mtrec.text = msgstr;
    else
      mtrec.Str = msgstr;
    end;

    pay.PAYERBANKID    = mtrec.Sender;
    pay.RECEIVERBANKID = mtrec.RECEIVER;

    //Pay.id_sFI    = 1;
    //Pay.Amount    = 0;
    //pay.DC = 0;

    pay.NumReferDoc  = Ref20;
    if((MesForm == "599") or (MesForm == "600"))
      pay.DateReferDoc = pay.ValueDate;
    else
      pay.DateReferDoc  = Ref98;
    end;
    pay.NodeId = {NumNode};
    pay.DateInput = {curdate};
    if(ValType(pay.id_sFI) != V_UNDEF)
      pay.id_sFIOutput   = pay.id_sFIInput = pay.id_sFICurrAmount = pay.id_sFI;
    end;

    pay.Priority     = 6;
    pay.InputDate    = DtTm(date(), time());
    pay.IsInf = 0;

    //mtrec.Str = TmpStr4;

    TmpStr= BLOCK1_HEAD + TmpStr1 +
            BLOCK2_HEAD + TmpStr2 +
            TmpStr3 + "{4:" + TmpStr4 +
            FIELD_STRING_SPLITTER + "-}"+TmpStr5;

    if(TmpStrSign)
       CheckSign(TmpStr, GetSubStr(TmpStrSign, BLOCK_S_MDG, "}"));
    end;

    TmpStr = Trim(TmpStr + TmpStrSign);

    If (Msg_Duplicated)
      if(CheckAssociate(Pay, Ref20, ASS_RECV_REF))
        newState = StateYesDubl;
        DuplComment = " Обнаружен признак дубликата ";
      else
        newState = StateSwiftLoaded;
      end;
    else
      if(IDED)
         newState = UFStateFromCOS;
      elif(CommentStr)
         newState = StateSwiftNotLoaded;
      else
         newState = StateSwiftLoaded;
      end;
    end;
    if (DepoAcc == ClientDepoAcc)
      newState   = State_VIPReady;
      CommentStr = " Клиентская выписка ";
    end;

    if(IDED)
      CommStr = "Загружен из ED503 ID="+int(IDEd);
    else
      CommStr = "Загружен из "+ NameFile + CommentStr + DuplComment;
    end;

    if(not SwtPaym.ChangeState(newState, 0, CommStr))
       CommentStr=" Ошибка " + SwtPaym.Error+ " при сохранении платежа ";
       return false;
    end;

    if (not SaveExp (SwtPaym, TmpStr, Type_Exp_Origin, "Оригинальное сообщение", CommentStr))
       return false;
    end;

    /*входящий контрагент*/
    var id_nKorr = GetKorrByBIC(MTRec.Sender,BicSWIFT_ID);

    if(not AddAss(SwtPaym, id_nKorr, ASS_RECV_REF, Ref20, {curdate}, CommentStr))
      return false;
    end;

    PaymID = int(SwtPaym.Paym.id_paym);
    Return true;
  END;

  /*
     Тело функции
  */

  while(index(InpStr, MsgBeginMarker))
    if(LoadOneMessage(@PaymID))
      MsgLoaded = MsgLoaded + 1;
    else
     if (trim (CommentStr) != "")
      MakeErrorMsg ("Шлюз SWIFT: " + CommentStr);
     end;
     return false;
    end;
    InpStr = Trim(InpStr);
  end;

  if(not IDED)
     AddPtk("Шлюз SWIFT: загружено " + MsgLoaded + " сообщений из " + NameFile);
  end;

  return true;
OnError (e)
  MakeErrorMsg( "Шлюз SWIFT: загрузка файла " + NameFile + ", ошибка выполнения, модуль " + e.module + ", cтрока " + e.line + ", " + WintoDos (e.Message));
  return false;
End;

macro LoadMultiMsgFile(NameFile)
  InpStr = LoadFileString(NameFile);

  MsgBeginMarker = BLOCK1_HEAD;
  if(index(InpStr, MsgBeginMarker)) /* Есть хотя бы одно сообщение */
    if(not LoadMultiMsgFileTrn)
      OraTrnRollback();
      return false;
    end;
    OraTrnCommit();
  end;
  return true;
end;


Macro ImpFiles(GateId, ImpDir, ArcDir, ImpFileNameMask)
  NameFile = ImpDir + ImpFileNameMask;
  Var OnceMoreFile = FindFirst(NameFile), newNameFile;

  While(OnceMoreFile)
    newNameFile  = ArcDir+NameFile;
    OrigNameFile = ImpDir+NameFile;
    If (ExistFile (newNameFile) and DeleteFile(newNameFile))
      AddPtk(GateId+":Удалён файл "+newNameFile);
    End;

    If (MoveFile( OrigNameFile, newNameFile))
      AddPtk(GateId+":Перемещен файл "+NameFile+ " из "+ImpDir+" в "+ArcDir);
      If(not LoadMultiMsgFile(newNameFile))
        /* нужно попытаться перенести файл обратно */
        If (MoveFile(newNameFile, OrigNameFile))
           AddPtk(GateId+":Возвращён файл "+NameFile+" из "+ArcDir+" в "+ImpDir);
        Else
           MakeErrorMsg (GateId+":Ошибка при возврате файла "+NameFile+" из "+ArcDir+" в "+ImpDir);
        End;
      End;
    Else
      MakeErrorMsg (GateId+":Ошибка переноса файла "+NameFile+" из "+ImpDir+" в "+ArcDir);
    End;
    OnceMoreFile = FindNext(NameFile);
  End;
End;

macro LoadSwift()
   ImpFiles(SwiftIdGate, SwiftInDir, SwiftArcDir, SwiftImpFileNameMask);
end;

macro Kvit(p)
  var PayObj, paym, mtRec;
  var ID_Paym_ret;/*ID ответного*/
  var Refer = "", f23bStr = "", IDAss;
  var NewState = StateSwiftProc;
  var mtrec_str, fldIdxArr, CurFld, CurFldNum, CurSeq, OldSeq;
  var WasError = false;/*Признак того, что при квитовке была ошибка*/
  var MesError = "";

  var Bind = TRslOraQuery();
  var Kwit = TRslOraQuery();
  PayObj = p;
  paym   = PayObj.paym;
//debugbreak;

  if(paym.id_nform == Type_Doc_MT518)
    mtrec = p.mtrec;
    mtrec_str = mtRec.Str;
  elif(paym.id_nform == Type_Doc_MTn9X)
    mtrec = p.mtn9x;
    mtrec_str = mtRec.Text;
  else
    mtrec = p.mtrec;
    mtrec_str = mtRec.Str;
  end;


  Bind.SQLText = "begin :ID_Paym_ret:=RSP_PAYM_API.PAYMBINDING(:P_IDPAYM,:P_REFER,:P_IDASS,:P_IDNKORR); end;";

  /*Здесь должен быть разбор поля 20 с референсами начальных документов*/
  fldIdxArr = Re_SearchStr(mtrec_str, "(?m)\\xd\\xa:\\d{2}[A-Z]?.*:", 1, 1);
  if (not fldIdxArr.size OR mod (fldIdxArr, 2))
    MakeErrorMsg("Квитовка SWIFT: Ошибка при разборе полей сообщения ");
    return false;
  end;

  if (not ParceFields2 (mtrec_str, fldIdxArr))
    MakeErrorMsg("Квитовка SWIFT: "+ErrMsg);
    return false;
  end;

  CurFldNum = 0;
  CurSeq = "";
  OldSeq = "";
  ID_Paym_ret = 0;

  while(CurFldNum < CurMsgFields.Size)

    CurFld = CurMsgFields[CurFldNum];
    if  ((CurFld.Num == "16")and(CurFld.Option == "R"))/*признак начала секции*/
      if(CurSeq != "")/*если уже находимся в какой-то секции*/
        OldSeq = CurSeq;/*сохраним ее*/
      end;
      CurSeq = CurFld.GetSubField(0);/*установим новую секцию*/
    elif((CurFld.Num == "16")and(CurFld.Option == "S"))/*признак конца секции*/
      if(OldSeq != "")
        CurSeq = OldSeq;
      else
        CurSeq = "";
      end;
      break;/*Дальше нам не интересно*/
    elif((CurFld.Num == "23")and(CurFld.Option == "G"))/**/
      f23bStr = SubStr(CurFld.GetSubField(0),1);
    elif(CurFld.Num == "21")/*из секции "А1 Связки"*/
      Refer = SubStr(CurFld.GetSubField(0),1);
      IDAss = ASS_SENT_REF;/*исходящий*/

      Bind.DeclareAndSet("ID_Paym_ret",ID_Paym_ret,"P_IDPAYM",paym.ID_PAYM,"P_REFER",Refer,"P_IDASS",IDAss,"P_IDNKORR",0);
      if(not Bind.Execute)
        MakeErrorMsg("Квитовка SWIFT: "+"PAYMBINDING: "+Bind.Error);
        return false;
      end;

      ID_Paym_ret = Bind.GetVariable("ID_Paym_ret");
      if(ID_Paym_ret == 0)
        WasError = true;
        MesError = MesError+" '"+Refer+"'";
      end;
    elif((CurFld.Num == "20")and(CurSeq == "LINK"))/*из секции "А1 Связки"*/
      Refer = SubStr(CurFld.GetSubField(0),8);
      if((f23bStr == "NEWM") or (f23bStr == "INST"))
        IDAss = ASS_SENT_REF;/*исходящий*/
      else
        IDAss = ASS_RECV_REF;/*входящий*/
      end;

      Bind.DeclareAndSet("ID_Paym_ret",ID_Paym_ret,"P_IDPAYM",paym.ID_PAYM,"P_REFER",Refer,"P_IDASS",IDAss,"P_IDNKORR",0);
      if(not Bind.Execute)
        MakeErrorMsg("Квитовка SWIFT: "+"PAYMBINDING: "+Bind.Error);
        return false;
      end;

      ID_Paym_ret = Bind.GetVariable("ID_Paym_ret");
      if(ID_Paym_ret == 0)
        WasError = true;
        MesError = MesError+" '"+Refer+"'";
      end;

    end;

    CurFldNum = CurFldNum + 1;
  end;

  if((WasError) or (not ID_Paym_ret))
    PaySetNextState(StateSwiftProcErr, 0,"Не найдены референсы "+MesError);
  end;

  return true;
end;


/*Шаг типа "макрос"*/
macro ProcSwiftPaym(p)

  if(in(p.paym.ID_NFORM,Type_Doc_MT54X)or(in(p.paym.ID_NFORM,Type_Doc_MT518))or(in(p.paym.ID_NFORM,Type_Doc_MTn9X)))
    if(not Kvit(p))
      AddPtk(" Ошибка квитовки по ответному документу "+ ToId(p.paym.ID_Paym));
      return false;
    end;
  end;

  return true;
end;

macro ProcKvitSwiftPaym
  var KwitCB = TRslOraQuery();
  var KwitFIS = TRslOraQuery();

  KwitCB.SQLText = "begin RSP_PAYM_API.KvitSWIFT_CB; end;";
//  KwitCB.DeclareAndSet("P_IDPAYM",paym.ID_PAYM);
  if(not KwitCB.Execute)
    MakeErrorMsg("Квитовка SWIFT: "+"KvitSWIFT_CB: "+KwitCB.Error);
    return false;
  end;

  KwitFIS.SQLText = "begin RSP_PAYM_API.KvitSWIFT_FIS; end;";
//  KwitFIS.DeclareAndSet("P_IDPAYM",paym.ID_PAYM);
  if(not KwitFIS.Execute)
    MakeErrorMsg("Квитовка SWIFT: "+"KvitSWIFT_FIS: "+KwitFIS.Error);
    return false;
  end;

  OraTrnCommit();

  return true;
end;

/*
Macro FindAssociateByValue(AssType, Value)
   keynum(ass, 2);
   ass.Associate = Value;
   ass.Id = 2000000;
   notEOF = GetGE(ass);
   While (NotEOF AND (ass.Associate == Value))
      If (Ass.AssType == AssType)
         Return TRUE;
      End;
      NotEOF = Next(Ass);
   End;
   Return FALSE;
End;
*/
Macro GetRefFromFile(FileToRead, Ref, Type)
   var Pos;
   var OnceMore = TRUE;
   While (Next(FileToRead) AND OnceMore)
      If (Index(FileToRead.Str, "Network Delivery Status") > 0)
         Pos = Index(FileToRead.Str, ":");
         Type = Trim(SubStr(FileToRead.Str, Pos + 1));
         If (Type == "Network Ack")
            SetParm(2, "ACK");
         Else
            SetParm(2, "NACK");
         End;
      Elif (Index(FileToRead.Str, "20: Transaction Reference Number") > 0)
         Next(FileToRead);
         SetParm(1, Trim(FileToRead.Str));
         OnceMore = FALSE;
      Elif (Index(FileToRead.Str, "20: Sender's Reference") > 0)
         Next(FileToRead);
         SetParm(1, Trim(FileToRead.Str));
         OnceMore = FALSE;
      End;
   End;

   Return (NOT OnceMore);
End;

macro IsKorespondent(ID_NKORR, ID_NKS, ID_SFI)
  var q = ExecQuery("select k.*, ks.* "+
                    "from nkorr k, nks ks "+
                    "where k.id_nkorr = ks.id_nkorr "+
                    "and k.id_node is null "+
                    "and nvl(ks.isloro,0) = 0 "+
                    "and k.id_nkorr = :p1 "+
                    "and ks.id_nks = :p2 "+
                    "and ks.id_sfi = :p3",ID_NKORR, ID_NKS, ID_SFI);


  if(q.RowCount)
    return true;
  end;

  return false;
end;

Macro KvitSWIFTWithTerm()

   if((SwiftKvitDir == "")or(SwiftArcDir == ""))
     AddPtk("Шлюз SWIFT:Заданы не все каталоги. Загрузка отменена");
     return;
   end;

   File FileToRead() TXT;

   var FileMask = SwiftKvitDir + "*.prt";
   var OnceMore = FindFirst(FileMask);

   var qAss, qPaym, PaymObj;
   var KvitRef, KvitType;

   var newSt = StateSWIFTTERMGOOD;

   While (OnceMore)
      If (Not Open(FileToRead, SwiftKvitDir + FileMask))
         AddPtk("Шлюз SWIFT: Не могу открыть файл " + SwiftKvitDir + FileMask);
         Return;
      End;

      While (GetRefFromFile(FileToRead, KvitRef, KvitType))
         qAss = ExecQuery ("select t.* from PAYASS t where t.id_sass = :p1 and t.associate = :p2",ASS_SENT_REF/*ASS_SWIFT_REF*/, KvitRef);
         If (qAss.RowCount)
            qPaym = ExecQuery ("select t.* from PAYM t where t.id_paym = :p1", qAss.GetByName("id_paym").AsInteger);
            if(qPaym.RowCount)
                PaymObj = TRslPayDoc (ToId(qPaym.GetByName("ID_NFORM").AsInteger), ToId(qPaym.GetByName("ID_PAYM").AsInteger), ToId(qPaym.GetByName("VERSIONREC").AsInteger));
                if (not TstObj (PaymObj))
                   AddPtk("Отправка в SWIFT: ошибка при поиске платежа " + ToId(qPaym.GetByName("ID_PAYM").AsInteger) + ", id формы " + ToId(qPaym.GetByName("ID_NFORM").AsInteger));
                   return ;
                end;

                if(qPaym.GetByName("ID_SSTATE").AsInteger==StateSent2SWIFT)
                  If (KvitType == "ACK")
                     newSt = StateSWIFTTERMGOOD;
                     PaymObj.ChangeState(newSt, 0,"");
                     AddPtk("Шлюз SWIFT: Платеж " + ToId(PaymObj.paym.ID_PAYM) + " принят терминалом SWIFT");
                  Else
                     newSt = StateSWIFTTERMREJE;
                     PaymObj.ChangeState(newSt, 120,"Не принят SWIFT-терминалом");
                     AddPtk("Шлюз SWIFT: Платеж " + ToId(PaymObj.paym.ID_PAYM) + " отказан терминалом SWIFT");

                  End;
                else
                      AddPtk("Шлюз SWIFT: Платеж " + ToId(PaymObj.paym.ID_PAYM) + " уже был принят терминалом SWIFT");
                end;
            else
               AddPtk("Шлюз SWIFT: Ошибка приема квитанции терминала платеж " + ToId(qPaym.GetByName("ID_PAYM").AsInteger));
            end;
         End;
      End;
      If (NOT Close(FileToRead))
         AddPtk("Шлюз SWIFT: Не могу закрыть файл " + SwiftKvitDir + FileMask);
         Return;
      End;
      If (DeleteFile(SwiftArcDir+FileMask))
          AddPtk("Шлюз SWIFT: Удалён файл "+SwiftArcDir+FileMask);
      End;
      If (NOT MoveFile(SwiftKvitDir+FileMask, SwiftArcDir+FileMask))
         AddPtk("Шлюз SWIFT:Ошибка переноса файла "+SwiftKvitDir+FileMask+" в "+SwiftArcDir+FileMask);
      End;
      OnceMore = FindNext(FileMask);
   End;

   OraTrnCommit();
End;


Macro LoadRmain(p)
  var PayRec;
  var id_nKorr;

  PayObj = p;
  PayRec = PayObj.paym;

  if(PayRec.id_nform == Type_Doc_MT518)
    mtrec = p.mtrec;
  elif(PayRec.id_nform == Type_Doc_MTn9X)
    mtrec = p.mtn9x;
  elif(PayRec.id_nform == Type_Doc_MT54X)
    mtrec = p.mtrec;
  elif(PayRec.id_nform == Type_Doc_MT53X)
    mtrec = p.mtrec;
  elif(PayRec.id_nform == Type_Doc_MT6XX)
    mtrec = p.mtrec;
  end;

  mtrec.receiver = GetSWIFTCode(mtrec.Receiver);
  mtrec.Sender =  GetSWIFTCode(mtrec.Sender);

  /*входящий контрагент*/
  id_nKorr = GetKorrByBIC(MTRec.Sender,BicSWIFT_ID);
  if(id_nKorr > 0)
    PayRec.ID_NKORRINPUT = id_nKorr;
  else
    PaySetNextState(/*payrec.id_sstate*/StateNoKorr, 0,"Не определен контрагент по БИК = '"+MTRec.Sender+"'");
    return false;
  end;

  if(PayRec.ReceiverBankId == "")
    PayRec.ReceiverBankId = MyBic;
  end;

  return true;
end;
