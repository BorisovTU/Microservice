/*voikin 28.07.2014*/

import ips_general, utils, /*Fields, TransFld*/"mtserial.cls", calendar;

macro GetRef(P_FORM, P_TYPE)
  var SQLtext;
  var q;
  var NewRef = "";

  SQLtext = " begin :p1 := RSP_REF.MAKEREFER(:p2, :p3); "+
            " end;";
  q = ExecQuery (SQLtext, NewRef, P_FORM, P_TYPE);

  if (not TstObj (q))
    RunError (toansi("Функция генерации референса MAKEREFER: ошибка при вызове функции"));
  end;

  NewRef = q.GetVariable("p1");

  return NewRef;

end;

/*Получение счета валюты*/
/*SFI - ИД валюты, TypeAcc - ИД типа счета*/
macro GetSFIAcc(SFI, TypeAcc)
  var SQLtext;
  var q;

  SQLtext = " select t.ACCNUM as ACCNUM"+
            " from NFAC t "+
            " where t.ID_SFI = :p1 and t.ID_SFAC = :p2";
  q = ExecQuery (SQLtext, SFI, TypeAcc);

  if (not TstObj (q))
    RunError (toansi("Запрос выборки счета валюты: ошибка в запросе"));
  end;

  if(q.eof)
    return "";
  end;

  return q.rec.ACCNUM;
end;

/*Функция создания кейса и привязки к кейсу начального документа*/
/*
P_IDPAYM - ID документа,
p_Refer - референс кейса,
P_IDSTATE - ID состояния кейса,
p_IDKart - ID картотеки,
p_Varlen - комментарий к кейсу,
p_Specific - описание кейса,
p_Amount - сумма,
p_OutAmount - неурегулируемая сумма,
p_Acc - счет невыясненных сумм,
p_ValueDate - дата значения,
P_UserNick - номер ответственного исполнителя,
P_IDKorrIN - идентификатор контрагента-инициатора,
P_IDKorrAW - идентификатор контрагента-ответчика,
p_IDPack - ID кейса.
возвращает ИД кейса
*/
macro PACKCREATION(P_IDPAYM, p_Refer, P_IDSTATE, p_IDKart, p_Varlen, p_Specific, p_Amount, p_OutAmount, p_Acc, p_ValueDate, P_UserNick, P_IDKorrIN, P_IDKorrAW)
  var SQLtext;
  var q = TRslOraQuery();
  var IDPack = 0;

  if (q == NULL)
     RunError (toansi("ExecQuery: не создан класс"));
     return NULL;
  end;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.PACKCREATION(";

q.DeclareAndSet("p1", IDPack);

  if(ValType(P_IDPAYM) == V_UNDEF)
    SQLtext = SQLtext + "NULL";
  else
    SQLtext = SQLtext + ":P_IDPAYM";
    q.DeclareAndSet("P_IDPAYM", int(P_IDPAYM));
  end;

  SQLtext = SQLtext + ",:p_Refer,:P_IDSTATE";
  q.DeclareAndSet("p_Refer", p_Refer);
  q.DeclareAndSet("P_IDSTATE", int(P_IDSTATE));


  if(ValType(p_IDKart) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_IDKart";
    q.DeclareAndSet("p_IDKart", int(p_IDKart));
  end;

  if(ValType(p_Varlen) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_Varlen";
    q.DeclareAndSet("p_Varlen", p_Varlen);
  end;

  if(ValType(p_Specific) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_Specific";
    q.DeclareAndSet("p_Specific", p_Specific);
  end;

  if(ValType(p_Amount) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_Amount";
    q.DeclareAndSet("p_Amount", p_Amount);
  end;

  if(ValType(p_OutAmount) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_OutAmount";
    q.DeclareAndSet("p_OutAmount", p_OutAmount);
  end;

  if(ValType(p_Acc) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_Acc";
    q.DeclareAndSet("p_Acc", p_Acc);
  end;

  if(ValType(p_ValueDate) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:p_ValueDate";
    q.DeclareAndSet("p_ValueDate", p_ValueDate);
  end;

  if(ValType(P_UserNick) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:P_UserNick";
    q.DeclareAndSet("P_UserNick", P_UserNick);
  end;

  if(ValType(P_IDKorrIN) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:P_IDKorrIN";
    q.DeclareAndSet("P_IDKorrIN", int(P_IDKorrIN));
  end;

  if(ValType(P_IDKorrAW) == V_UNDEF)
    SQLtext = SQLtext + ",NULL";
  else
    SQLtext = SQLtext + ",:P_IDKorrAW";
    q.DeclareAndSet("P_IDKorrAW", int(P_IDKorrAW));
  end;

  SQLtext = SQLtext + "); "+ " end;";
  q.SqlText = SQLtext;
  if (not q.Execute())
    RunError (toansi("Функция создания кейса PACKCREATION: ошибка при вызове функции: "+q.Error));
  end;

  IDPack = q.GetVariable("p1");

  return IDPack;
end;


/*Функция помещения документа в кейс

p_IDPack - ID кейса,
p_VR - версия записи кейса,
P_IDPAYM - ID документа,
P_IDSTATE - ID состояния кейса,
p_Varlen - комментарий к кейсу.

возвращае 1 в случае успеха

*/

macro PACKADDPAYM(p_IDPack, p_VR, p_IDState, P_IDPAYM, p_Varlen)
  var SQLtext;
  var q;
  var ret = 0;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.PACKADDPAYM(:p2, :p3, :p4, :p5, :p6); "+
            " end;";
  q = ExecQuery (SQLtext, ret, p_IDPack, p_VR, P_IDPAYM, p_IDState, p_Varlen);

  if (not TstObj (q))
    RunError (toansi("Функция добавления платежа в кейс PACKADDPAYM: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  return ret;
end;

macro PACKADDPAYM2(p_IDPack, p_VR, p_IDState, P_IDPAYM, p_Varlen)
  var SQLtext;
  var q;
  var ret = 0;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.PACKADDPAYM(:p2, :p3, :p4); "+
            " end;";
  q = ExecQuery (SQLtext, ret, p_IDPack, p_VR, P_IDPAYM);

  if (not TstObj (q))
    RunError (toansi("Функция добавления платежа в кейс PACKADDPAYM2: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  return ret;
end;


/*Функция изменения состояния кейса

P_IDPACK - ID кейса,
p_VR - версия записи кейса,
P_IDSTATE - состояние, в которое переходит кейс,
p_Varlen - комментарий к кейсу.

возвращае 1 в случае успеха
*/

macro PACKCHANGESTATE(P_IDPACK, p_VR, p_IDState, p_Varlen)
  var SQLtext;
  var q;
  var ret = 0;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.PACKCHANGESTATE(:p2, :p3, :p4, :p5); "+
            " end;";
  q = ExecQuery (SQLtext, ret, p_IDPack, p_VR, p_IDState, p_Varlen);

  if (not TstObj (q))
    RunError (toansi("Функция изменения состояния кейса PACKCHANGESTATE: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  return ret;
end;

/*Определение сообщения как "Стандартный запрос/ответ"*/
/*
p_Form - формат сообщения,
p_Typ - тип сообщения: 0 - запрос, 1 - ответ,
p_IDForm - ID стандартной формы (выходной параметр),
p_Kind - вид сообщения

возвращает: 0 - <Стандартный запрос> найден, 1 - <Стандартный запрос> не найден.
*/

macro FINDSTANDARTMSG(P_FORM, P_TYP, P_IDFORM /*out*/, P_KIND)
  var SQLtext;
  var q;
  var ret = 0;
  var IDFORM = 0;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.FINDSTANDARTMSG(:p2, :p3, :p4, :p5); "+
            " end;";
  q = ExecQuery (SQLtext, ret, P_FORM, P_TYP, IDFORM, P_KIND);

  if (not TstObj (q))
    RunError (toansi("Функция определения сообщения FINDSTANDARTMSG: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  if(ret == 0)
    IDFORM = q.GetVariable("p4");
    SetParm(2,IDFORM);
  end;

  return ret;
end;


/*Проверка допустимых сообщений для респондента*/
/*
p_IDForm - ID стандартной формы,
p_IDKorr - ID респондента,

возвращает: 0 - допустимый запрос для респондента, 1 - недопустимый запрос для респондента.
*/

macro CHECKMSGRESPOND(P_IDFORM, P_IDKORR)
  var SQLtext;
  var q;
  var ret = 0;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.CHECKMSGRESPOND(:p2, :p3); "+
            " end;";
  q = ExecQuery (SQLtext, ret, P_IDFORM, P_IDKORR);

  if (not TstObj (q))
    RunError (toansi("Функция проверки допустимых сообщений для респондента CHECKMSGRESPOND: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  return ret;
end;


/*Функция получения шаблона сообщения <Стандартный запрос/ответ>*/
/*
p_Template - шаблон стандартной формы,
p_IDForm - ID стандартной формы, если NULL, то <Стандартный запрос/ответ> определяется параметрами:
       p_Form - формат сообщения (обязателен, если p_IDForm = NULL),
       p_Typ - тип сообщения: 0 - запрос, 1 - ответ (обязателен, если p_IDForm = NULL),
       p_Kind - вид сообщения,
p_Fi - валюта счета,
p_AccBal - балансовый счет,
p_Conn - вид связи,
p_DC - тип транзакции: 0 - дебит, 1 - кредит,
возвращает: 0 - шаблон найден, 1 - шаблон не найден, 2 - форма сообщения не найдена.
*/
macro GETTEMPLATEMSG(P_TEMPLATE/*out*/, P_IDFORM, P_FORM, P_TYP, P_KIND, P_FI, P_ACCBAL, P_CONN, P_DC)
  var SQLtext;
  var q;
  var ret = 0;

  if(ValType(P_IDFORM) == V_UNDEF)
    RunError (toansi("Функция получения шаблона сообщения GETTEMPLATEMSG: не задан второй параметр"));
  end;

  SQLtext = " begin "+
            "  :p1 := RSP_PAYM_API.GETTEMPLATEMSG(:p2,:p3";

  if(ValType(P_FORM) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+ P_FORM;
  end;
  if(ValType(P_TYP) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+P_TYP;
  end;
  if(ValType(P_KIND) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+P_KIND;
  end;
  if(ValType(P_FI) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+P_FI;
  end;
  if(ValType(P_ACCBAL) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+P_ACCBAL;
  end;
  if(ValType(P_CONN) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+P_CONN;
  end;
  if(ValType(P_DC) == V_UNDEF)
    SQLtext = SQLtext +",Null";
  else
    SQLtext = SQLtext +","+P_DC;
  end;

  SQLtext = SQLtext +"); end;";

  q = ExecQuery (SQLtext, ret, P_TEMPLATE, P_IDFORM);

  if (not TstObj (q))
    RunError (toansi("Функция получения шаблона сообщения GETTEMPLATEMSG: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  if(ret == 0)
    P_TEMPLATE = q.GetVariable("p2");
    SetParm(0,P_TEMPLATE);
  end;

  return ret;
end;
/*
//перенесено в calendar.mac
/*
Функция возвращает дату через p_Days рабочих дней в пределах базового календаря от даты p_CurDate в <направлении> p_StepFromDT.
Если искомая дата находится вне календаря, то возвращается NULL.

p_CalTyp - ИД типа календаря из справочника SCLNDR;
p_CurDate - дата;
p_StepFromDT - направление выбора даты (1 - следующая, 0 - предыдущая);
p_Days - количество рабочих дней.
*/
macro GETWORKDAY(P_CALTYP, P_CURDATE, P_STEPFROMDT, P_DAYS)

  var SQLtext;
  var q;
  var ret = Date(0,0,0);

  SQLtext = " begin "+
            "  :p1 := RSP_CALENDAR.GETWORKDAY(:p2, :p3, :p4, :p5); "+
            " end;";
  q = ExecQuery (SQLtext, ret, P_CALTYP, P_CURDATE, P_STEPFROMDT, P_DAYS);

  if (not TstObj (q))
    RunError (toansi("Функция получения даты GETWORKDAY: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  return ret;

end;
*/

macro create_ipspck(PayObj, _Specific, _Varlen, _IDKart, _IDKorrAW)
  var P_IDPAYM = "";
  var p_Refer   = "";
  var P_IDSTATE = ST_IPSPCK_NEW;
  var p_IDKart  = IDKART_UNCL;/*по умолчанию*/
  var p_Varlen  = "";
  var p_Specific = "";
  var p_Amount = 0;
  var p_OutAmount = 0;
  var p_Acc = "";
  var P_UserNick = "";
  var P_IDKorrIN;
  var P_IDKorrAW;

  if(ValType(PayObj) != V_UNDEF)
    P_IDPAYM = PayObj.paym.id_paym;
    p_Refer   = GetRef(int(PayObj.paym.ID_NFORM),1);
//    p_Amount = PayObj.paym.AMOUNT;
//    p_OutAmount = PayObj.paym.AMOUNT;

    if((ValType(_IDKart) == V_UNDEF)or(_IDKart == IDKART_UNCL))
      if(PayObj.paym.DC)
        p_Acc = GetSFIAcc(int(PayObj.paym.ID_SFI), ID_SFAC_UNCL_D);
      else
        p_Acc = GetSFIAcc(int(PayObj.paym.ID_SFI), ID_SFAC_UNCL_K);
      end;

      PayObj.paym.AccCurrAmount = p_Acc;
    end;

    if(ValType(PayObj.paym.AMOUNT) != V_UNDEF)
      p_Amount    = PayObj.paym.AMOUNT;
    end;

    if(ValType(_IDKorrAW) != V_UNDEF)
      P_IDKorrAW = _IDKorrAW;
    else
      if(Index(Classes_Doc_Out,"|"+PayObj.paym.id_spClass+"|"))/*платеж исходящий*/
        /*ответчик - исх.контрагент основного платежа кейса, инициатор - мы*/
        P_IDKorrAW = PayObj.paym.ID_NKORROUTPUT;
      else                                                         /*входящий*/
        /*ответчик - вх.контрагент основного платежа кейса, инициатор - мы*/
        P_IDKorrAW = PayObj.paym.ID_NKORRINPUT;
      end;
    end;

  else
    p_Refer   = GetRef(1,1);
  end;

  if(ValType(_IDKart) != V_UNDEF)
    p_IDKart = _IDKart;
  end;

  if(_IDKart == IDKART_UNCL)
    p_OutAmount = p_Amount;
  end;

  if(ValType(_Specific) != V_UNDEF)
    p_Specific = _Specific;
  end;

  if(ValType(_Varlen) != V_UNDEF)
    p_Varlen = _Varlen;
  end;


  /*var p_ValueDate = Date();*/
  var ChkTime = GetIdByCode("NKART","CHKTIME",p_IDKart);/*Контрольный срок нахождения в картотеке невыясненных*/
  var p_ValueDate = GETWORKDAY(IDCLNDR, {CurDate}, 1, ChkTime);
  var IDPack;
  IDPack = PACKCREATION(P_IDPAYM, p_Refer, P_IDSTATE, p_IDKart, p_Varlen, p_Specific, p_Amount, p_OutAmount, p_Acc, p_ValueDate, P_UserNick, P_IDKorrIN, P_IDKorrAW);

  return IDPack;
end;

/*возвращает объект (TRslPayDoc) "кейс", найденный по ID_PAYM в PCKPAY*/
macro GetIPSPCKbyPAYM(ID_PAYM)
  var SQLtext;
  var q;
  if(ValType(ID_PAYM) == V_UNDEF)
    return;
  end;

  /*ищем кейс, с которым связан платеж*/
  SQLtext = " select t.ID_IPSPCK as ID_IPSPCK"+
            " from PCKPAY t "+
            " where t.id_paym = :p1"+
            " order by t.id_ipspck desc";
  q = ExecQuery (SQLtext, ID_PAYM);

  if (not TstObj (q))
    RunError (toansi("Запрос выборки кейса(PCKPAY): ошибка в запросе"));
  end;

  if(q.eof)
    return null;
  end;

  var PckObj = TRslPayDoc(Type_Doc_IPSPCK,int(q.rec.ID_IPSPCK));

  if(ValType(PckObj) != V_GENOBJ)
    RunError(toansi("Не удалось создать объект"));
  end;

  return PckObj;
end;

/*возвращает объект (TRslPayDoc) "запрос-платеж" (форма Type_Doc), найденный по ID_EDQUERY*/
macro GetQueryByID_EDQUERY(ID_EDQUERY,Type_Doc)
  var SQLtext;
  var q;

  SQLtext = " select t.ID_PAYM as ID_PAYM"+
            " from EDQUERY t "+
            " where t.ID_EDQUERY = :p1";
  q = ExecQuery (SQLtext, int(ID_EDQUERY));

  if (not TstObj (q))
    RunError (toansi("Запрос выборки ЭСИС(EDQUERY): ошибка в запросе"));
  end;

  if(q.eof or (ValType(q.rec.ID_PAYM)==V_UNDEF))
    return null;
  end;

  var QueObj = TRslPayDoc(Type_Doc,int(q.rec.ID_PAYM));

  if(ValType(QueObj) != V_GENOBJ)
    RunError(toansi("Не удалось создать объект"));
  end;

  return QueObj;
end;

/*возвращает объект (TRslPayDoc) "ответ-платеж" (форма Type_Doc), найденный по ID_EDQUERY*/
macro GetAnswerByID_EDANSWER(ID_ANSWER,Type_Doc)
  var SQLtext;
  var q;

  SQLtext = " select t.ID_PAYM as ID_PAYM"+
            " from EDANSWER t "+
            " where t.ID_EDANSWER = :p1";
  q = ExecQuery (SQLtext, int(ID_ANSWER));

  if (not TstObj (q))
    RunError (toansi("Запрос выборки ЭСИС(EDANSWER): ошибка в запросе"));
  end;

  if(q.eof or (ValType(q.rec.ID_PAYM)==V_UNDEF))
    return null;
  end;

  var AnsObj = TRslPayDoc(Type_Doc,int(q.rec.ID_PAYM));

  if(ValType(AnsObj) != V_GENOBJ)
    RunError(toansi("Не удалось создать объект"));
  end;

  return AnsObj;
end;

/*возвращает объект (TRslPayDoc) "платеж" формы Type_Doc, последний привязанный к кейсу ID_IPSPCK*/
macro GetPaymFromPck(ID_IPSPCK, Type_Doc)
  var SQLtext;
  var q;
  var ESIDObj;

  SQLtext = " select t.id_paym, p.id_nform "+
            " from PCKPAY t, PAYM p        "+
            " where t.id_paym = p.id_paym  "+
            " and t.id_ipspck = :p1        ";
  if(ValType(Type_Doc) != V_UNDEF)
    SQLtext = SQLtext + " and p.id_nform = :p2 ";
  end;

  SQLtext = SQLtext + " order by t.id_pckpay desc";

  if(ValType(Type_Doc) != V_UNDEF)
    q = ExecQuery (SQLtext, int(ID_IPSPCK), int(Type_Doc));
  else
    q = ExecQuery (SQLtext, int(ID_IPSPCK));
  end;

  if (not TstObj (q))
    RunError (toansi("Запрос выборки платежа кейса: ошибка в запросе"));
  end;

  if(q.eof or (ValType(q.rec.ID_PAYM)==V_UNDEF))
    return null;
  end;

  if(ValType(Type_Doc) != V_UNDEF)
    ESIDObj = TRslPayDoc(Type_Doc,int(q.rec.ID_PAYM));
  else
    ESIDObj = TRslPayDoc(Type_Doc_Paym,int(q.rec.ID_PAYM));
  end;

  if(ValType(ESIDObj) != V_GENOBJ)
    RunError(toansi("Не удалось создать объект"));
  end;

  return ESIDObj;
end;

/*----------------------------------------------------------------------------*/
MACRO TranslitStr(Str, dir, ID_NKS)
  var RetStr = "";
  if    (ID_NKS == ID_NKS_RUR6)
    RetStr = TransStringRur6(Str,dir);
  elif  (ID_NKS == ID_NKS_RUS9)
    RetStr = TransStringRur6(Str,dir,True);
  elif(ID_NKS == ID_NKS_CLEAR)
    RetStr = TransStringCLEAR(Str, dir);
  else
    RetStr = Str;
  end;
  return RetStr;
END;


/*
 найти платеж с ассоциацией типа type
*/
MACRO GetPayByAss (associate, type)
  var q, qtext;
  associate = Trim(associate);
  qtext ="select pa.id_paym as id_paym from\n" +
        "payass pa\n" +
        "where\n" +
        "pa.associate = :p1\n" +
        "and pa.id_sass = :p2\n"+
        "order by id_sass desc";
 q = ExecQuery (qtext, associate, type);
 if (not TstObj (q))
    RunError (toansi("ошибка в запросе получения платежа по ассоциации '" + associate+"'"));
 end;
 if (not q.Eof)
   return int(q.rec.id_paym);
 end;
 return 0;
END;

/*Получить кода запросов/ответов из строки*/
/*Во второй параметр возвращается массив кодов запросов/ответов*/
macro GetQuAwCodes(_Str,_ArrCodes)
  var Str = _Str;
  var StrCode;
  Array ArrCodes;

  while(StrLen(Str))
    if(SubStr(Str,Index(Str,"/"),2)=="//")/*имеем дело с двойным слешом*/
      Str = SubStr(Str,MyIndex (Str, "/",Index(Str,"/")+2));
    else
      StrCode = SubStr(Str,Index(Str,"/"),MyIndex (Str, "/", Index(Str,"/")+1));
      Str = SubStr(Str,MyIndex (Str, "/", MyIndex (Str, "/", Index(Str,"/")+1)+1));
      ArrCodes(ASize(ArrCodes)) = StrCode;
    end;
  end;

  SetParm(1,ArrCodes);
  return ASize(ArrCodes);
end;

/*Получить ИД выходной стандартной формы по ИД входной*/
macro GetStdFrmOut(IDFrmIn, code, format, kindmsg, nameform, id_nkart, typmsg)
  var q, qtext;

  qtext = " select f.id_frmout as frmout, t.code as code, t.format as format, t.kindmsg as kindmsg, t.nameform as nameform, t.id_nkart as id_nkart, t.typmsg as typmsg\n"+
          " from frmmsg f, frmtyp t\n"+
          " where f.id_frmin = :p1\n"+
          " and f.id_frmout = t.id_frmtyp";

  q = ExecQuery (qtext, IDFrmIn);

  if (not TstObj (q))
     RunError (toansi("ошибка в запросе ИД выходной стандартной формы по ИД входной " + IDFrmIn));
  end;

  if (not q.Eof)
    SetParm(1,int(q.rec.code));
    SetParm(2,q.rec.format);
    SetParm(3,q.rec.kindmsg);
    SetParm(4,q.rec.nameform);
    SetParm(5,int(q.rec.id_nkart));
    SetParm(6,q.rec.typmsg);
    return int(q.rec.frmout);
  end;

  return 0;
end;

/*Получить ID шлюза*/
MACRO GetFrnSys(ID_NKS)
  var qtext, qry, res = "";

  if(ValType(ID_NKS) != V_Undef)
    qtext = "select t.frnsys as frnsys \n" +
             "from nks t\n"+
             "where \n"+
             "t.id_nks = :p1 \n";

    qry = ExecQuery (qtext, ID_NKS);
    if (not TstObj (qry))
        RunError (toansi("Отправка в SWIFT: ошибка в запросе выборки ID шлюза"));
    end;

    res = qry.rec.frnsys;
  end;
  return res;
END;


macro MsgIsAnswer(MsgObj)
  if(   ((MsgObj.MTn9X.TYPE == 199)or(MsgObj.MTn9X.TYPE == 299))
     and(not Index(MsgObj.MTn9X.TEXT,":79:BL")))

    return true;
  end;

  return false;
end;

macro GetOfficeCode(_id_nkorr, _korr_code, _name, _mail)
  var qtext, qry, name = "", mail = "";

  if((ValType(_id_nkorr) != V_Undef)and(ValType(_korr_code) != V_Undef))
    qtext = " select t.TEXT as tx, t.EMAIL as MAIL \n" +
            " from noffic t\n"+
            " where t.ID_NKORR = :p1 \n"+
            " and t.CODE = :p2";

    qry = ExecQuery (qtext, _id_nkorr, _korr_code);
    if (not TstObj (qry))
        RunError (toansi("Функция GetOfficeCode: ошибка в запросе выборки доп.офиса"));
    end;

    name = qry.rec.tx;
    mail = qry.rec.mail;

  end;

  SetParm(2,name);
  SetParm(3,mail);

  return true;
end;

macro CREATJRNMAIL (P_EVENT, P_TRANS, P_ADRESS)
  var SQLtext;
  var q;
  var ret = 0;

  SQLtext = " begin "+
            "  :p1 := RSP_ALERTS.CREATJRNMAIL (:p2, :p3, :p4); "+
            " end;";
  q = ExecQuery (SQLtext, ret, P_EVENT, P_TRANS, P_ADRESS);

  if (not TstObj (q))
    RunError (toansi("Функция CREATJRNMAIL: ошибка при вызове функции"));
  end;

  ret = q.GetVariable("p1");

  return ret;
end;
