/*
 макрофайл транслитерации поля
*/
import "MTSERIAL.cls";
//File SerialFtr5("trans_s5.usr","swift.def");
//Const TRANS_DIRECTION_TO_LAT = 0;
//Const TRANS_DIRECTION_TO_CYR = 1;
//Const ASIS_DELIM_RUR5 = "'";

//const LAT_UPPER_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
//const LAT_UPPER_ALPHA_CLEAR = strfor(32)+ "()+,-./:?\n\r0123456789" + LAT_UPPER_ALPHA;
const TransTypeCLEAR = 0, /* тип транслитерации CLEAR*/
      TransTypeRUR6  = 2  /* тип транслитерации RUR6 */;
/* заполнение по умолчанию строк, по которым будет выполняться транслитерация CLEAR */
//var CLEAR_RUS_SW   = "\" А Б В Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я ",
//    CLEAR_LAT_SW   =  "' A B V G D E E J Z I Y K L M N O P R S T U F H TSCHSHCH' Y ' E YUYA";
/* заполнение по умолчанию строк, по которым будет выполняться транслитерация RUR6
   версия стандарта от 03.06.2010
   здесь приведено как эатлон.
*/
//var RUR6_RUS_SW="!\"$%&'*;=_АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯЁ№#@^`~",
//    RUR6_LAT_SW="bmspdjfvrzABVGDEJZIiKLMNOPRSTUFHCcQqxYXeuaonnffjf",
//    RUR6_RUS_NONE_SW  = strfor(32)+ "()+,-./0123456789:?<>[\]{|}\n\r",
//    RUR6_LAT_NONE_SW  = strfor(32)+ "()+,-./0123456789:?)((/)(/)\n\r",
//    SW_RUS  = "",
//    SW_LAT    = "",
//    NONE_SW_RUS = "",
//    NONE_SW_LAT   = "",
//    TempDirPath = GetInit("TempDir") + "\\";

/*
MACRO LoadTransStringsFromTable (tbl)

 SW_RUS  = RUR6_RUS_SW;
 SW_LAT  = RUR6_LAT_SW;
 NONE_SW_RUS = RUR6_RUS_NONE_SW;
 NONE_SW_LAT = RUR6_LAT_NONE_SW;

 return true;

/*
 SW_RUS  = "";
 SW_LAT  = "";
 NONE_SW_RUS = "";
 NONE_SW_LAT = "";

 open (tbl, null, null, true);

 keynum(tbl, 2);

 while (next(tbl))
   if (tbl.IsKbdSw)
    if ((tbl.Rus!="") AND (tbl.Lat != ""))
     SW_RUS = SW_RUS  + tbl.Rus;
     SW_LAT   = SW_LAT  + tbl.Lat;
    end;
   else
    if ((tbl.Rus!="") AND (tbl.Lat != ""))
     NONE_SW_RUS = NONE_SW_RUS + tbl.Rus;
     NONE_SW_LAT = NONE_SW_LAT + tbl.Lat;
    end;
   end;
 end;
 close(tbl);
 /*
 println ("=============== after load from table ===================");
 println("RUR6_RUS_SW="+ SW_RUS);
 println("RUR6_LAT_SW="+ SW_LAT);
 println("RUR6_RUS_NONE_SW="+ NONE_SW_RUS);
 println("RUR6_LAT_NONE_SW="+ NONE_SW_LAT);
*/
 /*длины строк *_from и *_to должны совпадать иначе нет взаимного соответствия Rus <=> Lat*/
 if ((strlen(SW_RUS) == 0) OR
     (strlen(SW_LAT) != strlen(SW_RUS)) OR
     (strlen(NONE_SW_RUS) == 0) OR
     (strlen(NONE_SW_RUS) != strlen(NONE_SW_LAT)))
   RunError ("Ошибка при чтении таблицы транслитерации " + filename(tbl));
 end;
*/
END;
*/
/* формирование строк соответствия для транслитерации RUR6 */
LoadTransStringsFromTable (SerialFtr5);

/* новая функция транслитерации RUR6
   str - входящая строка
   dir - направление транслитерации
         0 - Rus->Lat
         1 - Lat->Rus
*/
/*
MACRO TransStringRur6_old (str, dir)
  var TmpStr = str, RetStr ="",  curChr = "", NewStr = "",KbdSwitchFlag = false, idx, idx1;

  If (ValType(dir) == V_UNDEF)
     Return TmpStr;
  End;
  /* кириллица */
  if   (dir == TRANS_DIRECTION_TO_CYR)
    While (StrLen(TmpStr) > 0)
      curChr  = SubStr(TmpStr, 1, 1);
      TmpStr  = Substr(TmpStr, 2);
      if (curChr == ASIS_DELIM_RUR5)
        KbdSwitchFlag = not KbdSwitchFlag;
        NewStr ="";
      else
         idx = index(NONE_SW_LAT, curChr);
         if (idx)
           /* обратное преобразованием может быть "много к одному".
              эта проверка на случай если символ есть и в SW_LAT и в NONE_SW_LAT
              тогда приоритет за SW_LAT.
           */
           idx1 = index(SW_LAT, curChr);
           if (idx1)
             NewStr = Substr (SW_RUS, idx1,1);
           else
             NewStr = Substr (NONE_SW_RUS, idx,1);
           end;
         else
           if (KbdSwitchFlag)
             NewStr = curChr;
           else
             idx = index(SW_LAT, curChr);
             if (idx)
               NewStr = Substr (SW_RUS, idx, 1);
             else
               NewStr = "";
             end;
           end;
         end;
      end;
      retstr = retstr + NewStr;
    end;
  /* латынь */
  elif (dir == TRANS_DIRECTION_TO_LAT)
    TmpStr = WinToDos(StrUpr(DosToWin(Str)));
    While (StrLen(TmpStr) > 0)
      curChr  = SubStr(TmpStr, 1, 1);
      TmpStr  = Substr(TmpStr, 2);
      /*не надо транслитерить */
      if (index(LAT_UPPER_ALPHA, curChr))
         if (KbdSwitchFlag)
           NewStr = curChr;
         else
           NewStr = ASIS_DELIM_RUR5 + curChr;
           KbdSwitchFlag = true;
         end;
      /* надо транслитерить и символ "не буква"*/
      elif (idx = index(NONE_SW_RUS, curChr))
        NewStr = substr(NONE_SW_LAT, idx, 1);
      /* надо транслитерить и символ "буква"*/
      elif (idx = index(SW_RUS, curChr))
        NewStr = substr(SW_LAT, idx, 1);
        if (KbdSwitchFlag)
          NewStr = ASIS_DELIM_RUR5 + NewStr;
          KbdSwitchFlag = false;
        end;
      else
        NewStr = "";
      end;
      retstr = retstr + NewStr;
    end;
    /* строка кончилась, а клавиатуру обратно не переключили */
    if (KbdSwitchFlag and strlen(retstr))
      retstr = retstr + "'";
    end;
  end;
  return retStr;
END;
*/
/* новая функция транслитерации RUR6
   str - входящая строка
   dir - направление транслитерации
         0 - Rus->Lat
         1 - Lat->Rus
   _RusInQuotes - признак взятия транслитерированной кириллицы в кавычки
*/
/*
MACRO TransStringRur6(str, dir, _RusInQuotes)
  var TmpStr = str, RetStr ="",  curChr = "", NewStr = "",KbdSwitchFlag = false, idx, idx1;
  var RusInQuotes;

  If (ValType(dir) == V_UNDEF)
     Return TmpStr;
  End;

  If (ValType(_RusInQuotes) == V_UNDEF)
     RusInQuotes = false;
  else
     RusInQuotes = _RusInQuotes;
  End;

  /*По умолчанию клавиатура в режиме RUS*/
  if(RusInQuotes)/*если брать в кавычки транслитерированную кириллицу*/
    KbdSwitchFlag = true;/*будем считать, что клавиатура изначально в режиме LAT*/
  end;

  /* кириллица *//*По умолчанию клавиатура в режиме LAT*/
  if   (dir == TRANS_DIRECTION_TO_CYR)/*LAT->RUS*/
    While (StrLen(TmpStr) > 0)
      curChr  = SubStr(TmpStr, 1, 1);
      TmpStr  = Substr(TmpStr, 2);
      if (curChr == ASIS_DELIM_RUR5)/*встретили '*/
        KbdSwitchFlag = not KbdSwitchFlag;/*переключаем клавиатуру*/
        NewStr ="";                       /*саму ' не печатаем*/
      else                          /*не кавычка*/
         idx = index(NONE_SW_LAT, curChr);

         if (idx)
           /* обратное преобразованием может быть "много к одному".
              эта проверка на случай если символ есть и в SW_LAT и в NONE_SW_LAT
              тогда приоритет за SW_LAT.
           */
           idx1 = index(SW_LAT, curChr);
           if (idx1)
             NewStr = Substr (SW_RUS, idx1,1);
           else
             NewStr = Substr (NONE_SW_RUS, idx,1);
           end;
         else
           if (KbdSwitchFlag)/*клавиатура в режиме RUS*/
             NewStr = curChr;/*символ не транслитерируем*/
           else              /*клавиатура в режиме LAT*/
             idx = index(SW_LAT, curChr);
             if (idx)                    /*нашли символ в латинской таблице*/
               NewStr = Substr (SW_RUS, idx, 1);/*заменяем на символ из киреллической таблицы*/
             else                        /*не нашли символ в латинской таблице*/
               NewStr = "";                     /*символ не печатаем*/
             end;
           end;
         end;
      end;
      retstr = retstr + NewStr;
    end;
  /* латынь */
  elif (dir == TRANS_DIRECTION_TO_LAT)/*RUS->LAT*/
    TmpStr = WinToDos(StrUpr(DosToWin(Str)));
    While (StrLen(TmpStr) > 0)
      curChr  = SubStr(TmpStr, 1, 1);
      TmpStr  = Substr(TmpStr, 2);
      /*не надо транслитерить */
      if (index(LAT_UPPER_ALPHA, curChr)or(curChr == "/"))/*встретили латинский символ*/
         if (KbdSwitchFlag)/*клавиатура в режиме LAT*/
           NewStr = curChr;/*символ не транслитерируем*/
         else              /*клавиатура в режиме RUS*/
           NewStr = ASIS_DELIM_RUR5 + curChr;/*добавляем кавычку перед символом*/
           KbdSwitchFlag = true;/*переводим клавиатуру в режим LAT*/
         end;
      /* надо транслитерить и символ "не буква"*/
      elif (idx = index(NONE_SW_RUS, curChr))
        NewStr = substr(NONE_SW_LAT, idx, 1);
/*
        if (not KbdSwitchFlag and RusInQuotes and (curChr == "/"))/*если клавиатура в режиме RUS и нужно брать в кавычки транслитерированный кириллический текст*/
          NewStr = ASIS_DELIM_RUR5 + NewStr;/*добавляем кавычку перед символом*/
          KbdSwitchFlag = true;        /*переводим клавиатуру в режим LAT*/
        end;
*/
      /* надо транслитерить и символ "буква"*/
      elif (idx = index(SW_RUS, curChr))/*нашли символ в киреллической таблице*/
        NewStr = substr(SW_LAT, idx, 1);/*заменим символ из латинской таблицы*/
        if (KbdSwitchFlag)              /*если клавиатура в режиме LAT*/
          NewStr = ASIS_DELIM_RUR5 + NewStr;/*добавляем кавычку перед символом*/
          KbdSwitchFlag = false;        /*переводим клавиатуру в режим RUS*/
        end;
      else
        NewStr = "";
      end;
      retstr = retstr + NewStr;
    end;

    /* строка кончилась, а клавиатуру обратно не переключили */
    if (strlen(retstr) and ((KbdSwitchFlag and not RusInQuotes)or(not KbdSwitchFlag and RusInQuotes)))
      retstr = retstr + "'";
    end;
  end;
  return retStr;
END;
*/

/* новая функция транслитерации CLEAR
   str - входящая строка
   dir - направление транслитерации
         0 - Rus->Lat
         1 - Lat->Rus
*/
/*
MACRO TransStringCLEAR (str, dir)
  var TmpStr = str, RetStr ="",  curChr = "", NewStr = "",idx;

  If (ValType(dir) == V_UNDEF)
     Return TmpStr;
  End;
  if (dir == TRANS_DIRECTION_TO_LAT)
    TmpStr = WinToDos(StrUpr(DosToWin(Str)));
    While (StrLen(TmpStr) > 0)
      curChr  = SubStr(TmpStr, 1, 1);
      TmpStr  = Substr(TmpStr, 2);
      /*не надо транслитерить */
      if (index(LAT_UPPER_ALPHA_CLEAR, curChr))
         NewStr = curChr;
      /* надо транслитерить и символ "буква"*/
      elif (idx = index(CLEAR_RUS_SW, curChr + " "))
        NewStr = trim(substr(CLEAR_LAT_SW, idx, 2));
      else
        NewStr = "";
      end;
      retstr = retstr + NewStr;
    end;
  else
    retStr = TmpStr;
  end;
  return retStr;
END;
*/
/* Добавлена возможность работы в RUR5
   Абдуллаев А.А.           03.04.2001
   s - входная строка
   d - направление транслитерации
   TypeTrans = 0- CLEAR, 2 - RUR6 )
*/
MACRO trans(s,d,TypeTrans)

  if (TypeTrans == TransTypeRUR6 )
   return TransStringRur6 (s, d);
  elif (TypeTrans == TransTypeCLEAR)
   return TransStringCLEAR (s, d);
  else
   return s;
  end;
END/*Trans*/;
/*----------------------------------------------------------------------------*/
/*Разбивает строку str на i сегментов, длинной len, результат помещает в SS
  длинна первого сегмента y*/
/*----------------------------------------------------------------------------*/
/*
macro mystrsplit(str,SS,len,i,y)
 var ind=0;
 var poz=1;
 while((ind<i)AND(poz<=strlen(str)))
   if(ind)
     SS(ind)=substr(str,poz,len);
     poz=poz+len;
   else
     SS(ind)=substr(str,poz,y);
     poz=poz+y;
   end;
   ind=ind+1;
 end;
end;
*/
/*----------------------------------------------------------------------------*/
/* Возвращает строку из принятых строк разделенных последовательностью "\r\n"*/
/*----------------------------------------------------------------------------*/
macro GetOneStr()
   var Str="";
   var TmpStr;
   var i=0;
   while(getparm(i,TmpStr))
     if((valtype(TmpStr) == V_STRING) AND (Trim(TmpStr)!=""))
       if(Str!="")
         Str=Str+RN;
       end;
       Str=Str+TmpStr;
     end;
     i=i+1;
   end;
   return Str;
end;

/*----------------------------------------------------------------------------*/
/* Принимает в качестве первого параметра строку в которой присутствуют "\r\n"
   возвращает в последующих параметрах подстроки из первого параметра
   разделенные последовательностью "\r\n"*/
/*----------------------------------------------------------------------------*/
macro GetManyStr()
   var Str="";
   var TmpStr="";
   var Pos=0;
   var i=0;

   if(getparm(i,Str))
      i=i+1;
      while(getparm(i,TmpStr))
        Pos = Index(Str, RN);
        If (Pos != 0)
           TmpStr = SubStr(Str, 1, Pos - 1);
           Str = SubStr(Str, Pos + 2);
        Else
           TmpStr=Str;
           Str="";
        End;
        if(TmpStr!="")
            SetParm(i,TmpStr);
        end;
        i=i+1;
      end;
   end;
end;

array fld77Values;

/**************************************************************************/
MACRO GetTaxParm (str, parm)
 var tmpstr, i;
 i = index (str, parm);
 if (not i)
  return "";
 end;
 tmpstr =substr (str, i + strlen(parm));
 i = index(tmpstr, "/N");
 if (i)
  tmpstr = substr (tmpstr, 1, i - 1);
 end;
 if (tmpstr == "0")
   tmpstr= "";
 end;
 return trim(tmpstr);
END;

/* транслитерация налоговых параметров РУР6 */
MACRO TransF77 (val, dir)
 var tmp, idx, ret = val ;

 macro ChSubStr(Str,SStr,CStr)
   var TmpStr="";
   var Pos=0;

   Pos = Index(Str,SStr);
   while(Pos)
         TmpStr = TmpStr+SubStr(Str, 1, Pos - 1)+CStr;
         Str = SubStr(Str, Pos + StrLen(SStr));
         Pos = Index(Str,SStr);
   end;
   return Trim(TmpStr+Str);
 end;


  if (Index(val, "/N10/"))
        asize (fld77Values, 0);
        idx = 4;
        val = chsubstr (val, RN, "");
        while (idx < 11)
         tmp = GetTaxParm(val, "/N" + string(idx)+ "/");
         if (tmp != "")
          fld77Values(idx) =  "/N" + string(idx) + "/" + TransStringRur6 (tmp, dir);
         else
          fld77Values(idx) = "/N" + string(idx) + "/0";
         end;
         idx = idx + 1;
        end;
        ret = fld77Values(10) + fld77Values(4) + RN +
              fld77Values(5) + fld77Values(6) + fld77Values(7)+ RN +
              fld77Values(8) + fld77Values(9);
  end;
  return ret;
END;
/*----------------------------------------------------------------------------*/
/*транслитерация поля
  принимает имя поля, значение, направление транслитерации,
  таблица транслитерации
*/
macro transfield(nfld,value,d,tr)
  array a, f, kword;
  var i, tmpstr, retstr,y, sl2, nametable, TypeTrans;

  TypeTrans=TransTypeCLEAR;             /*0- клер 1-RUR4 2-RUR5 */
  nametable=strupr(FileName(tr));
  if(Index(nametable,"TRANS_S5.USR"))
   TypeTrans=TransTypeRUR6;
  end;
  asize(a,0);
  asize(f,0);
  asize(kword,0);

        if((nfld=="Reference")OR(nfld=="F21")OR(Substr(nfld,1,3)=="F71")OR
          (Substr(nfld,1,3)=="F32")OR(Substr(nfld,4,4)=="Type")OR
          (Substr(nfld,4,2)=="PI")OR(nfld=="F59Account")OR(nfld=="Sender")OR
          (nfld=="Receiver"))
          return value;
        elif((Substr(nfld,4,2)=="NA")OR(nfld=="F70"))
         if (not d)
           GetManyStr(value,a(0),a(1),a(2),a(3));
           i=0;
           tmpstr="";
           while(i<asize(a))
             if((valtype(a(i)) != V_UNDEF) AND
                (a(i) != ""))
               a(i)=trans(a(i),d,TypeTrans);
               a(i)=tmpstr+a(i);
               if(strlen(a(i))>35)
                 tmpstr=Substr(a(i),36);
                 a(i)=Substr(a(i),1,35);
               else
                tmpstr="";
               end;
             end;
             i=i+1;
           end;
           while(strlen(tmpstr))
             a(i) = tmpstr;
               if(strlen(a(i))>35)
                 tmpstr=Substr(a(i),36);
                 a(i)=Substr(a(i),1,35);
               else
                tmpstr="";
               end;
             i=i+1;
           end;
           i=0;
           while(i<asize(a))
             if((Substr(a(i),1,1)=="-")OR(Substr(a(i),1,1)==":"))
               a(i)=" "+Substr(a(i),2);
             end;
             i=i+1;
           end;
           /* 70-е поле: если всё не влезло - засунуть в 5-й параметр */
           if((valtype(a(4))==V_STRING) AND (strlen(a(4))))
             SetParm(4, a(4));
           end;
           return GetOneStr(a(0),a(1),a(2),a(3));
         else
           return trans(value,d,TypeTrans);
         end;
        elif(nfld=="F72")
           retstr="";
           GetManyStr(value,a(0),a(1),a(2),a(3),a(4),a(5));
           i=0;
           y=-1;

           while(i<asize(a))
              if(SubStr(a(i),1,2)=="//")
                if(asize(f) == 0)
                  f(0) = SubStr(a(i),3) + " ";
                  kword(0) = "";
                else
                  f(asize(f)-1) = f(asize(f)-1) + SubStr(a(i),3);
                end;
              elif(SubStr(a(i),1,1)=="/")
                y=y+1;
                sl2 = index(substr(a(i),2), "/") + 1; /* начало данных за кл.словом */
                f(asize(f))= substr(a(i), sl2);
                kword(asize(f)-1) = WintoDos(StrUpr(DostoWin(substr(a(i), 1, sl2-1))));
              else
                if(valtype(a(i)) == V_UNDEF)
                  a(i) = "";
                end;
                if(asize(f) == 0)
                  f(0) = kword(0) = "";
                end;
                f(asize(f)-1) = f(asize(f)-1) + a(i);
/*
                kword(asize(f)) = "";
                f(asize(f)) = a(i);*/
              end;

              i=i+1;
           end;
           i=0;
           while(i<asize(f))
              asize(a,0);
               /* f - массив строк в разрезе ключевых слов 72-го поля  */
               f(i) = trans(trim(f(i)),d,TypeTrans);
               f(i) = kword(i) + f(i);
               mystrsplit(f(i),a,33,6,35);
               y=1;
               while(y<asize(a))
                if(a(y)!="")
                  a(y)="//"+a(y);
                end;
                y=y+1;
               end;
               if(retstr=="")
                  retstr=GetOneStr(a(0),a(1),a(2),a(3),a(4),a(5));
               else
                  retstr=retstr+RN+GetOneStr(a(0),a(1),a(2),a(3),a(4),a(5));
               end;
               i=i+1;
           end;
           return retstr;
        elif ((nfld == "F77B") AND (typeTrans == TransTypeRUR6 ))
           return TransF77(value, d);
        else
         return trans(value,d,TypeTrans);
        end;
end;
