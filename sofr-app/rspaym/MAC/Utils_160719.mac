/*********************************************************************
 Macro  : Utils.mac
 Created: 05-07-2002 02:06 PM
 Вспомогательные функции
**********************************************************************/
import general;

/*----------------------------------------------------------------------------*/
/* Ищет в первой строке  подстроки принятые во втором параметре и заменяет их
   на подстроку принятую в третьем параметре */
/*----------------------------------------------------------------------------*/
macro ChSubStr(Str,SStr,CStr)
   return trim(strsubst(Str,SStr,CStr));
end;

macro SplitMultiStr(str, ar)
  var i=0, ch;
  asize(ar, 1);
  ar(0) = "";
  while(i<=strlen(str))
    ch = substr(str,i,1);
    if(ch == "\r")
      i=i+1;
      ar(asize(ar)) = "";
    else
      ar(asize(ar)-1) = ar(asize(ar)-1) + ch;
    end;
    i=i+1;
  end;
  i = asize(ar);
  while(i<4)
    ar(i) = "";
    i=i+1;
  end;
end;

macro MStrSplit(Val, Len)
  var tmpstr = "";
  while(StrLen(val) > Len)
    tmpstr = tmpstr + substr(val, 1, Len) + RN;
    val    = substr(val, Len+1);
  end;
  tmpstr = tmpstr + val + RN;
  return tmpstr;
end;

/*
  Найти и возвратить подстроку, начинающуюся с INS_CODE, и вырезать её из str
*/
macro CutSubField(str, INS_CODE)
  array at;

  if(not index(str, INS_CODE))
    return "";
  end;

  splitMultiStr(str, at);
  i=0;ati=0;
  while((i < asize(at)) AND
        ((ati = index(at(i), INS_CODE)) == 0))
    i=i+1;
  end;
  retval = substr(at(i), ati);
  inext = true;
  while((i<asize(at)) AND
        (inext))
    i=i+1;
    if(substr(at(i), 1, 2) == "//")
      retval = retval + RN + at(i);
    else
      inext = false;
    end;
  end;

  Pos = index(str, retval);
  if(substr(str, Pos-2,2) == RN)
    rn1 = 2;
  else
    rn1 = 0;
  end;

  if(substr(str, Pos+strlen(retval),2) == RN)
    rn2 = 2;
  else
    rn2 = 0;
  end;

  if(rn1 AND rn2)
    rn1=0;
  end;

  SetParm(0, substr(str, 1, Pos-1-rn1) + substr(str, Pos+strlen(retval)+rn2));
  return retval;
end;
/**********************************************
  Удаляет все нецифровые символы из строки.
  Если в ней нет ни одного цифрового символа
  возвращает "1".
***********************************************/
macro FilterDigit(NumReferDoc)
  var i, slen, retval, ch;
  i=1;
  slen = strlen(NumReferDoc);
  retval = ch = "";
  while(i <= slen)
    ch = substr(NumReferDoc, i, 1);
    if((ch >= "0") AND (ch <= "9"))
      retval = retval + ch;
    end;
    i=i+1;
  end;
  if((not strlen(retval)) OR
     (not int(retval)))
    retval  = "1";
  end;
  return retval;

end;

/***************************************************************************/
/********** преобразование даты из строки формата ГГГГММДД в тип V_DATE ****/
macro ClrStr2Date(dateStr)
   var yy, mm, dd;
   yy = Int(SubStr(dateStr, 1, 4));
   mm = Int(SubStr(dateStr, 5, 2));
   dd = Int(SubStr(DateStr, 7, 2));

   return date(dd,mm,yy);
onerror (e)
  addptk ("ClrStr2Date: ошибка при преобразовании даты =" + dateStr);
  runerror (e.Message);
end;

/***************************************************************************/
macro Swift2Date(dateStr)
   var yy, mm, dd;
   yy = Int(SubStr(dateStr, 1, 2));
   mm = Int(SubStr(dateStr, 3, 2));
   dd = Int(SubStr(DateStr, 5, 2));
   If (yy > 80)
      yy = yy + 1900;
   Else
      yy = yy + 2000;
   End;

   return date(dd,mm,yy);
onerror (e)
  addptk ("Swift2Date: ошибка при преобразовании даты =" + dateStr);
  runerror (e.Message);
end;

/* формирование даты в формате SWIFT */
MACRO Date2Swift (dat)
  var DD, MM, YY;

  if(VALTYPE(dat)==V_DTTM)
    dat = date(dat);
  end;

  DateSplit(dat, DD, MM, YY);
  YY = String(10000 + YY);
  DD = String(100 + DD);
  MM = String(100 + MM);
  return SubStr(YY, 4, 2) + SubStr(MM, 2, 2) + SubStr(DD, 2, 2);
END;
/*************************************************************************
 Убивает нехорошие символы типа "'" из свифтовой части валютных документов
**************************************************************************/
MACRO KillSymb (PRec, mmtt)
 var i = 0, total = 0;
 if (not int(PRec.FIID))
   return ;
 end;
 total = FldNumber(mmtt);
 while (i < total)
   if ((ValType(mmtt(i))==V_STRING) AND Index (mmtt(i), StrFor(39)))
      mmtt(i) = ChSubStr(mmtt(i) , StrFor(39), StrFor(96));
   end;
   i = i + 1;
 end;
END;
/************************************************************************************
*************************************************************************************/
macro GetSWIFTCode(bic)
  if((StrLen(bic)==11)AND(SubStr(bic,9,3)=="XXX"))
    bic=SubStr(bic,1,8);
  end;
  return bic;
end;
/******************************************************************************
*Дополняет строку src слева символами paddsymbol до длины len
* where = 0 (default) - дополнять слева, 1 - справа
*******************************************************************************/
MACRO Padd (src, paddsymbol, len:integer, where)
var dst = "";
var src_len;

 src = string(src);
 src_len = Strlen (src);
 if (src_len >= len )
   dst = src;
 else
  if   ((ValType(where) == V_UNDEF) OR (where == 0))
   dst = mkstr(paddsymbol, (len - src_len)) + src;
  elif (where == 1)
   dst = src + mkstr(paddsymbol, (len - src_len));
  end;
 end;
 return dst;
END;

/****************************************************************************/
/*          Формирование строки из даты             */
/****************************************************************************/
Macro ToDate( Dat )
  var dd, mm, yy;

  if(VALTYPE(dat)==V_DTTM)
    dat = date(dat);
  end;

  DateSplit(Dat, dd, mm, yy);
  yy = string(yy);
  While( strlen(yy) < 4 )
   yy = "0" + yy;
  End;
   mm = string(mm);
    While( strlen(mm) < 2 )
  mm = "0" + mm;
  End;
    dd = string(dd);
    While( strlen(dd) < 2 )
  dd = "0" + dd;
  End;
    Return( yy + mm + dd );
End;

/* Убирает из строки лидирующие нули */
MACRO CutNulls (str)
  str = trim(str);
  while (Substr (str, 1,1) == "0")
   str =  Substr(str,2);
  end;
  return str;
END;

/*************************************************************************/
MACRO PrintStruct (struc, toScr)
 var i = 0, retval = "";
 var total = FldNumber(struc);
 var isClass;

 if (valtype(toScr) == V_UNDEF)
  toScr = false;
 end;

 if (valtype(struc) == V_GENOBJ)
  isClass = true;
  total = struc.fldnumber();
 end;

 while (i < total)
    if (not toScr)
     AddPtk (FldName(struc, i) + " = " + String(struc(i)));
    else
     retval = retval + RN + (struc.fldname(i) + " = " + String(struc.item(i)));
    end;
    i = i + 1;
 end;
 return retval;
END;

/* инициализация глобальных сериалайзеров для СВИФТ*/
MACRO InitSerial (Sr, ClassName, SrArray, SrName)
 var j, nm = "TSwiftFormSerializerString";

 if (valtype (SrName) == V_STRING)
  nm = SrName;
 end;
 if (valtype (sr) == V_UNDEF)
   sr = GenObject (ClassName, NULL, 1, 1, nm);
   j = 0;
   While (j < sr.ArrayValue.Size)
     sr.ArrayValue.Value(j).RegisterSerializer(SrArray(j));
     j = j + 1;
   End;
   sr.ErrorStream = GenObject ("TMTErrorStreamPtk");
   sr.UpdateSerializers();
 else
   sr.Clear();
 end;
 return sr;
END;

/* добавление змыкающего слеша к строке str*/
MACRO AddSlash (str)
  str = trim(str);
  if (substr (str, strlen(str), 1) != "\\")
    str = str + "\\";
  end;
  return str;
END;

/*
   взять значение от tag до nextTag в строке str и вырезать его из строки
   если tag в строке не найден, то возвращаемое значение = "", str = ""
   если NextTag в строке не найден, то возвращается остаток строки
*/
MACRO GetValue (str, tag, nextTag)
  var idx, ret = "", tmpstr, nxt = nextTag, num  = tag;

  idx = index (str, num);
  if (idx)
    tmpstr = substr (str, idx + strlen(num));
    if (valtype (nxt) != V_UNDEF)
     idx = index (tmpstr, nxt);
     if (idx)
      ret = substr (tmpstr, 1, idx - 1);
     else
      ret = tmpstr;
     end;
    else
     ret = tmpstr;
    end;
  end;

  idx = index (str, num + ret);
  if (idx)
    str = Substr (str, 1,  idx - 1) + Substr (str, idx + strlen(num + ret));
    SetParm (0, str);
  else
    str = "";
  end;
  SetParm (0, str);
  /* AB 19.07.08 в связи с пробелами в референсах
   ret = trim(ret);
  */
  return ret;
END;
/* вырезать из строки SWIFT значение поля
   возвращает строку вида "<номер поля><опция>:<значение поля>"
   или пустую строку,  если поля кончились.
*/
MACRO GetSWIFTField(str)
  var ret = "", idx = 0, tag = "\r\n:" , tmp ;
  idx = index (str, tag);
  /* последнее поле ? */
  if (idx)
    tmp = substr (str, idx + strlen(tag));
    idx  = index (tmp, tag);
    if (idx)
      ret = GetValue (str, tag, tag);
    else
      ret = tmp;
      str = "";
    end;
  else
   str = "";
  end;
  setparm(0, str);
  return ret;
END;

/* проверка наличия поля в SWIFTовке
str - строка сообщения
num - номер поля
opt - опция (необязательный)
*/
MACRO FldExist (str, num, opt)
  var _opt = "";
  if (valtype(opt) == V_STRING)
    _opt = opt;
  end;
  return (index(str, "\r\n:" + string(num) + _opt + ":") > 0)
END;
/* проверка наличия поля в SWIFTовке
str - строка сообщения
num - номер поля
opt - опция (необязательный)
*/
MACRO NextFldIs (str, num, opt)
  var _opt = "";
  if (valtype(opt) == V_STRING)
    _opt = opt;
  end;
  str = trim(str);
  return (index(str, ":" + string(num) + _opt + ":") == 1)
END;


/* Преобразование даты из 31.12.1899 в 00.00.00 */
MACRO BCB2NullDate (dt)
  if (dt == date(31,12,1899))
    dt = date(0,0,0);
  end;
  return dt;
END;

/* преобразование свифтовой суммы в money*/
MACRO Swift2Money ( str)
  if (substr(str, strlen(str),1) == ",")
    str = str + "00";
  end;
  str = chsubstr (str, ",", ".");
  return double(str);
END;

/****************************************************************************/
/*          Репарсинг строки -- по count(по умолчанию 35) символов через \r\n            */
/****************************************************************************/
Macro Reparce( Str, count )
 var outstr,tmpstr="";

    if (valtype(count) == V_UNDEF)
     count = 35;
    end;
    OutStr = "";
    Str = trim(string(Str));
    While( Str != "" )
      if (index(Str, ":") == 1 )
        Str = " " + Str;
      end;
      TmpStr = SubStr(Str, 1, count);
      Str = SubStr(Str, count+1);
      if( OutStr != "" )
          OutStr = OutStr + "\r\n";
      End;
      OutStr = OutStr + TmpStr;
    End;
    Return(OutStr);
End;

/* Index с возможностью указать стартовую позицию поиска */
MACRO MyIndex (str, strtofind, startpos)
  var tmpStr, Offset = 0, retval = 0;

  tmpStr = str;
  if ((valtype(startpos) == V_INTEGER) and (startpos > 1))
     tmpStr = Substr (str, startpos);
     Offset = startpos - 1;
  end;
  retval = Index(tmpStr, strtofind);
  if (retval > 0)
    retval = offset + retval;
  end;
  return retval;
END;

/*
 сравнение v со следующими аргументами функции.
 возвращает true при первом совпадении
*/
MACRO In (v)
  var i = 1, tmp, cnt;
  cnt = parmcount () ;
  while ( i < cnt)
    getparm(i,tmp);
    if (v == tmp)
      return true;
    end;
    i = i + 1;
  end;
  return false;
END;

/* преобразование строки в формат понятный ораклу */
MACRO Str2SQL (str)
  var ret = "''", i = 0, len = 0, tmpcode = 0;
  str = string(str);
  if(strlen(str) == 0)
   return ret;
  end;
  ret =  strsubst(str, "'", "''");
  str = ret;
  return "'" + str + "'";
END;


MACRO TstObj(v)
  return (valtype(v) == V_GENOBJ);
END;

/* обертка для преобразования идентификаторов. */
MACRO ToId (id)
  return int(id);
END;


/*Создает TRslOraQuery и возвращает его при успешном создании*/
/*В параметр передается текст ошибки*/
/*
MACRO CrQuery()
  var qry = TRslOraQuery();
  var ErrStr;

  if (qry == NULL)
    ErrStr = "Ошибка: не создан класс";
    SetParm(0, ErrStr);
    return NULL;
  end;
  return qry;
END;
*/
/*Выполняет запрос объекта qry, при успешном выполнении возвращается true, иначе false*/
/*Во второй параметр передается текст ошибки*/
/*
MACRO ExQuery(qry)
  var dt;
  var ErrStr;

  if (not qry.Execute())
    dt = dttm (date(), time());
    ErrStr = dt + " ошибка ExQuery: " + qry.Error + "\nтекст запроса: "+ qry.SqlText;
    SetParm(1, ErrStr);
    return NULL;
  end;
  return true;
END;
*/
/* выполнение запроса с параметрами
   первый аргумент - текст запроса,
   если есть следующие аргументы, то будет выполнена попытка связать каждый с параметрами запроса
   имена параметров -  p<номер>, неумерация начинается с 1.
*/
MACRO ExecQuery (qtxt)
  var qry = TRslOraQuery(), p, i = 1, savep = Tarray (10,10), dt;
  if (qry == NULL)
     AddPtk ("ExecQuery: не создан класс");
     return NULL;
  end;
  qry.SqlText = qtxt;
  while (getparm (i, p))
    savep (i-1) = p;
    qry.DeclareAndSet("p"+i, p);
    i = i + 1;
  end;
  if (not qry.Execute())
    AddPtk ("ExecQuery: ошибка " + qry.Error);
    SetOutput ("rslsql.trace", true);
    dt = dttm (date(), time());
    println(dt + " ошибка ExecQuery: " + qry.Error);
    println("текст запроса: " + qtxt);
    println();
    println("параметры: ");
    i = 0;
    while (i < savep.size )
      println("p"+ (i + 1) + " = "+ savep(i));
      i = i + 1;
    end;
    SetOutput (NULL, true);
    return NULL;
  end;
  return qry;
END;

/*
MACRO ExecQuery (qtxt)
  var ErrStr;
  var qry = CrQuery(ErrStr), p, i = 1, savep = Tarray (10,10), dt;
  if (qry == NULL)
     AddPtk ("ExecQuery: "+ErrStr);
     return NULL;
  end;
  qry.SqlText = qtxt;
  while (getparm (i, p))
    savep (i-1) = p;
    qry.DeclareAndSet("p"+i, p);
    i = i + 1;
  end;
  if (not qry.Execute())
    AddPtk ("ExecQuery: ошибка " + qry.Error);
    SetOutput ("rslsql.trace", true);
    dt = dttm (date(), time());
    println(dt + " ошибка ExecQuery: " + qry.Error);
    println("текст запроса: " + qtxt);
    println();
    println("параметры: ");
    i = 0;
    while (i < savep.size )
      println("p"+ (i + 1) + " = "+ savep(i));
      i = i + 1;
    end;
    SetOutput (NULL, true);
    return NULL;
  end;
  return qry;
END;
*/

/* обработка сообщений об ошибках в макросах beforearm, afterarm, durarm*/
MACRO MakeErrorMsg (str)
 AddPtk (str);
END;


/*
  сохранение сообщения в расширении платежа
  p       - ссылка на TRslPayDoc
  str     - сообщение
  kind    - номер формы расширения
  comment - комментарий
  errorDesc - возвращаемое сообщение об ошибке
*/
MACRO SaveExp (p, str, kind, comment, errorDesc)
  var Ext, paym, extrec, orig, msg = "";

  Ext = TRslPayDoc(kind, 0);
  if(not TstObj(Ext))
    msg = "ошибка создания класса расширения ";
    SetParm (4, msg);
    return false;
  end;
  extrec = Ext.pexp;
  orig   = Ext.origin;
  paym   = P.paym;

  extrec.ID_PAYM = paym.ID_PAYM;
  extrec.text = Comment;
  if(ValType(paym.ID_SFI) != V_UNDEF)
    extrec.ID_SFI = paym.ID_SFI;
  end;
  if(ValType(paym.Amount) != V_UNDEF)
    extrec.Amount= paym.Amount;
  end;
  orig.STR = Str;

  if(not Ext.Save())
    msg = "ошибка " + Ext.Error + " при сохранении расширения платежа " + paym.ID_PAYM;
    SetParm (4, msg);
    return false;
  end;
  SetParm (4, msg);
  return true;
END;


/*
  сохранение ассоциации платежа
  p       - ссылка на TRslPayDoc
  str     - ассоциация
  type    - тип ассоциации
  KorrId  - id контрагента
  dt      - дата
  errorDesc - возвращаемое сообщение об ошибке
*/
MACRO AddAss (P, KorrId,type, str, dt, errorDesc)
  var AssObj, paym,  msg = "", payass;

  AssObj= TRslPayDoc(Type_Ass,0);

  if(not TstObj(AssObj))
    msg = "ошибка создания класса расширения ";
    SetParm (4, msg);
    return false;
  end;
  payass = AssObj.payass;
  paym   = P.paym;

  payass.ID_PAYM = paym.ID_PAYM;
  if (KorrId)
    payass.KorrId = KorrId;
  end;
  payass.ID_SASS= type;
  payass.Associate = str;
  payass.dateass = dt;

  if(not AssObj.Save())
    msg = "ошибка " + AssObj.Error + " при сохранении ассоциации " + str + " типа " + type + " платежа " + paym.ID_PAYM;
    SetParm (5, msg);
    return false;
  end;
  SetParm (5, msg);
  return true;
END;


MACRO IsDigitStr (str)

  var i = 1, len = strlen (str), digits = "0123456789";
  while (i <= str)
   if (not index (digits, substr (str,i,1)))
     return false;
   end;
   i = i+ 1;
  end;
  return true;
END;

macro MergeFields(Fld)
  var i = 1, retval = "", parm;
  while(GetParm(i, parm))
    if(not Fld.GetSubField(Parm).IsEmpty())
      retval = retval + string(Fld.GetSubField(Parm).Value) + " ";
    end;
    i= i + 1;
  end;
  return trim(retval);
end;

/* преобразование времени в формат понятный ораклу */
MACRO Time2SQL ( tm)
 var h, m, s, ret = "";
 timesplit (tm, h,m,s);

 h = string(h);
 m = string(m);
 s = string(s);
 if (strlen(h) < 2)
  h = "0" + h;
 end;
 if (strlen(m) < 2)
  m = "0" + m;
 end;
 ret ="to_date('01.01.0001 " + h + ":" + m + "', 'DD.MM.YYYY HH24:MI')" ;
 return ret;
END;


MACRO Date2Sql(dt)
 var d,m,y;
 datesplit (dt, d,m,y);
 return  "to_date('" + string(d:2:o) + "."+ string(m:2:o) + "." + string(y) + "', 'dd.mm.yyyy')";
END;

MACRO Date2SqlStr(dt)
 var d,m,y;
 datesplit (dt, d,m,y);
 return  "'" + string(d:2:o) + "."+ string(m:2:o) + "." + string(y) + "'";
END;

/* получить следующий порядковый номер из таблицы genref для генерации референса
   type - тип референса
   msgForm - тип сообщения
*/
MACRO GetNextRefNum (type, msgForm)
  var qtext = "begin\n" +
              "  insert into genref\n" +
              "    (typeref, form, num)\n" +
              "  values\n" +
              "    (:p1, :p2, (select nvl(max(num), 0) from genref where form = :p2) + 1)\n" +
              "  returning num into :p3;\n" +
              "end;";
  var qry, retVal = 0;

  qry = ExecQuery (qtext, type, msgForm, RetVal);
  if (not TstObj (qry))
RunError (toansi("Генерация референса: ошибка в запросе получения номера "));
  end;
  return int(qry.GetVariable("p3"));
END;


/* получение строчного поля из рекордсета
*/
MACRO CheckStrField ( str )
  var Ret = str;

  if ((valtype (ret) == V_UNDEF) OR (Ret == strfor(1)))
   Ret = "";
  end;
  Return Ret;
END;

/*********************************************************************************
 найти ассоциацию типа type для платежа с id=id_paym.
*/
MACRO GetPayAss (id_paym, type)
  var q, qtext;
  id_paym = TOID(id_paym);
  qtext ="select associate as Text from\n" +
        "payass pa\n" +
        "where\n" +
        "pa.id_paym = :p1\n" +
        "and pa.id_sass = :p2\n"+
        "order by id_sass desc";
 q = ExecQuery (qtext, id_paym, type);
 if (not TstObj (q))
    RunError (toansi("ошибка в запросе получения ассоциации платежа " + id_paym ));
 end;
 if (not q.Eof)
   return trim(q.rec.Text);
 end;
 return "";
END;

MACRO GetTempFilename ()
  var h,m,s,ms, nm="";
  timesplit (time(), h,m,s,ms);
  nm = AddSlash (GetInit("TempDir")) +  todate(date())+ string(h:2:o) + string(m:2:o) + string(s:2:o) + string(ms:2:o) + "." + {oper};
  return nm;
END;

/*----------------------------------------------------------------------------*/
/*Разбивает строку str на i сегментов, длинной len, результат помещает в SS
  длинна первого сегмента y*/
/*----------------------------------------------------------------------------*/
macro MyStrSplit(str,SS,len,y, cnt)
  var ind=0;
  var poz=1, j = 0 ;
  asize(ss, 0);
  if(ValType(y) != V_INTEGER)
    y = len;
  end;
  if(ValType(cnt) != V_INTEGER)
    cnt = 0;
  end;

  while(poz<=strlen(str))
    if(ind)
      SS(ind)=substr(str,poz,len);
      poz=poz+len;
    else
      SS(ind)=substr(str,poz,y);
      poz=poz+y;
    end;
    ind=ind+1;
  end;
  while (ind < cnt)
    ss(ind) = "";
    ind = ind + 1;
  end;
end;

/*----------------------------------------------------------------------------*/
/* Генерирует уникальный референс                                             */
/*----------------------------------------------------------------------------*/
MACRO GetSWIFTRef (prefix,form)
  var strNum = 0, strd="";

  strNum = GetNextRefNum (1, Form);
  /* паранойа моде он  */
  if (not strNum)
RunError (toansi("Генерация референса: номер равен 0"));
  end;
  /* паранойа моде офф */
  strnum = string(strnum);
  /* такая длина маловероятна, но на всякий пожарный оставляем 5 последних символов */
  if(Strlen(strnum)>5)
   strnum = Substr(strnum,Strlen(strnum)-4);
  else
   strnum = string(int(strnum):5:o);
  end;
  strd=Date2Swift({curdate});
  return (prefix + strd + string(Form) + strNum);
END;

macro Sum2SWIFT(Sum, FIID)
  var retval = string(Sum);
  strset(retval, index(retval, "."), ",");
  if(substr(retval, strlen(retval), 1) == "0")
    retval  = substr(retval, 1, strlen(retval)-1);
  end;
  if(substr(retval, strlen(retval), 1) == "0")
    retval  = substr(retval, 1, strlen(retval)-1);
  end;
  return FIID + retval;
end;

/*----------------------------------------------------------------------------
печатает первую строку сообщения, принимает строку формы , референс и SWIFT БИК
получателя
----------------------------------------------------------------------------*/
macro swiftheader(form, ref, bicRecv)

  var tag3="";

  if(StrLen(bicRecv) == 8)
    bicRecv = bicRecv + "XXXX";
  elif(StrLen(bicRecv) == 11)
    bicRecv = SubStr(bicRecv,1,8) + "X" + SubStr(bicRecv,9);
  end;
  if(substr(ref,1,1)=="+")
      tag3="{3:{113:RUR6}}";
  end;
  return mkstr(" ", 4)+ "{1:F01"+MySWIFTBic+"AXXX0000000000}{2:I"+form +bicRecv+"N}"+tag3+"{4:";
end;

/***************************************************************************************/
MACRO GetStrFi(id_fi)
 var qtext, q, ret = "";
 qtext = "select strcode\n" +
         "from sfi\n" +
         "where\n" +
         "id_sfi = :p1\n";

 q = ExecQuery (qtext, id_fi);
 if (not TstObj (q))
     RunError (toansi("Ошибка в запросе поиска строчного кода валюты"));
 end;
 if (not q.Eof)
   ret = q.rec.strcode;
 end;
 return ret;
END;

/***************************************************************************************/
MACRO GetCodeFi(id_fi)
 if(ValType(id_fi) == V_UNDEF)
   return "";
 end;

 var qtext, q, ret = "";
 qtext = "select code\n" +
         "from sfi\n" +
         "where\n" +
         "id_sfi = :p1\n";

 q = ExecQuery (qtext, id_fi);
 if (not TstObj (q))
     RunError (toansi("Ошибка в запросе поиска строчного кода валюты"));
 end;
 if (not q.Eof)
   ret = q.rec.code;
 end;
 return ret;
END;


/*Возвращает код контрагента по ID_NKORR, во второй параметр передается название контрагента*/
MACRO GetKorrCode(id_nkorr, korr_name)
  if(ValType(id_nkorr) == V_UNDEF)
    return "";
  end;


  var GetKor = TRslOraQuery();
  var Code, Name;

  GetKor.SqlText = " select t.Code as Code, t.Text as Text "+
                          " from nkorr t "+
                          " where t.ID_nkorr = :ID ";

  GetKor.DeclareAndSet("ID",id_nkorr);

  if(not GetKor.Execute())
    RunError(toansi("макрофункция GetKorrCode:\r\n"+ToANSi(GetKor.Error)));
  end;

  if(not GetKor.Eof)
    Code = GetKor.GetByName("Code").AsString;
    Name = GetKor.GetByName("Text").AsString;
  end;

  SetParm(1,Name);
  return Code;

END;

/*Возвращает название контрагента по ID_NKORR, во второй параметр передается код контрагента*/
MACRO GetKorrName(id_nkorr, korr_code)
  if(ValType(id_nkorr) == V_UNDEF)
    return "";
  end;

  var GetKor = TRslOraQuery();
  var Code, Name;

  GetKor.SqlText = " select t.Code as Code, t.Text as Text "+
                          " from nkorr t "+
                          " where t.ID_nkorr = :ID ";

  GetKor.DeclareAndSet("ID",id_nkorr);

  if(not GetKor.Execute())
    RunError(toansi("макрофункция GetKorrCode:\r\n"+ToANSi(GetKor.Error)));
  end;

  if(not GetKor.Eof)
    Code = GetKor.GetByName("Code").AsString;
    Name = GetKor.GetByName("Text").AsString;
  end;

  SetParm(1,Code);
  return Name;

END;

/*Возвращает код корр.схемы по id_nkorr, id_nks, id_sfi, во четвертый параметр передается название, в пятый - название шлюза*/
MACRO GetKSCode(id_nkorr, id_nks, id_sfi, KS_name, FrnSys)
  if((ValType(id_nkorr) == V_UNDEF)or(ValType(id_nks) == V_UNDEF)or(ValType(id_sfi) == V_UNDEF))
    return "";
  end;

  var GetKS = TRslOraQuery();
  var Code, Name, FrnS;

  GetKS.SqlText = " select t.Code as Code, t.Text as Text, t.FrnSys as FrnSys "+
                          " from nks t "+
                          " where t.ID_nks   = :ID_NKS "+
                          "   and t.ID_nkorr = :ID_NKORR "+
                          "   and t.ID_sfi   = :ID_SFI ";

  GetKS.DeclareAndSet("ID_nks",id_nks,"ID_nkorr",id_nkorr,"ID_sfi",id_sfi);

  if(not GetKS.Execute())
    RunError(toansi("макрофункция GetKSCode:\r\n"+ToOEM(GetKS.Error)));
  end;

  if(not GetKS.Eof)
    Code = GetKS.GetByName("Code").AsString;
    Name = GetKS.GetByName("Text").AsString;
    FrnS = GetKS.GetByName("FrnSys").AsString;
  end;

  SetParm(3,Name);
  SetParm(4,FrnS);
  return Code;

END;

macro MakeSwiftRef(Form)
  var num ;
  num = GetNextRefNum (1, Form);

  if (num == 0)
    RunError (toansi("Генерация референса SWIFT: сгенерированный номер = 0"));
  end;
  num=string(Num);
  if(Strlen(num)>=5)
    num = substr(num,strlen(num)-4);
  else
    num = mkstr ("0", 5 - strlen(num))+num;
  end;

  return ( Date2Swift({curdate}) +string(Form)+ num);
end;

macro FindKSA(id_nks, id_sacc, AccNum)

  if((ValType(id_nks)==V_UNDEF)or(ValType(ID_SACC)==V_UNDEF))
    return false;
  end;

  var q = TRslOraQuery();
  q.SqlText = "select a.accnum "+
              "from NKSA a "+
              "where a.id_nks = :id_nks "+
              "and a.id_sacc = :id_sacc ";

  q.DeclareAndSet("id_nks",id_nks,"id_sacc",id_sacc);

  if(not q.Execute())
    RunError(toansi("FindKSA:"+q.Error));
  end;

  if (q.RowCount == 0)
    return false;
  end;

  SetParm(2,q.GetByName("accnum").AsString);
  return true;
end;

private macro getElementByPattern(s: String,
                                  pattern: String,
                                  element: String,
                                  length: Integer)
    var pos = StrBrk(pattern, element);
    return int(SubStr(s, pos, length));
end;

ReplaceMacro("StrSplit","MyStrSplit");
/*Меняем на свою функцию, т.к., StrSplit при разбивке строки выполняет перенос по словам.*/

macro stringToDtTm(s: String, pattern: String)
    return DtTm(
            Date(
                    getElementByPattern(s, pattern, "d", 2),
                    getElementByPattern(s, pattern, "m", 2),
                    getElementByPattern(s, pattern, "y", 4)
            ),
            Time(
                    getElementByPattern(s, pattern, "HH", 2),
                    getElementByPattern(s, pattern, "MM", 2),
                    getElementByPattern(s, pattern, "SS", 2)
            )
    );
OnError
    return DtTm(Date(0,0,0), Time(0,0,0));
end;

MACRO SaveToFile(fname, ArcPath, OutPath, str)

  if(ExistFile(ArcPath+fname))
    if(not DeleteFile(ArcPath+fname))
      RunError(toansi("Не могу удалить файл "+ArcPath+fname));
    end;
  end;

  if(not WriteStrToFile(toansi(str), ArcPath+fname))
    RunError(toansi("Ошибка при записи в файл "+ArcPath+fname));
  end;

  if(ExistFile(OutPath+fname))
    if(not DeleteFile(OutPath+fname))
      RunError(toansi("Не могу удалить файл "+OutPath+fname));
    end;
  end;

  if(not Copyfile(ArcPath+fname, OutPath+fname))
    RunError(toansi("Не могу скопировать "+ArcPath+fname+" в "+OutPath+fname));
  end;
END;

/* формирование имени файла для отправляемого XML сообщения */
MACRO GetNewNameFileXML (paymObj)
  var NameFile = "", id, s;
  id  = string(toid(paymObj.paym.id_paym));
  NameFile = id ;
  if(StrLen(NameFile)<8)
     s = "c" + MkStr("0", 7-StrLen(NameFile));
     NameFile=s+NameFile;
  else
     NameFile= "c" + SubStr(NameFile,strlen(NameFile)-6);
  end;
  NameFile=NameFile+ RepoOutExt;
  return NameFile;
END;

/* Смена состояния платежа в АБС */
Macro ChangeStatePaymInABS (ID, State)
   var qTextABS = "begin RSB_PAYMENTS_API.SetStatusSRS (:p1,:p2); end;";
   var qry = ExecQuery (qTextABS, ID, State);
   if (not TstObj (qry))
     Addptk("Ошибка изменения состояния СРС с референсом "+ID);
     return false;
   end;
   Addptk("Изменено состояние СРС с референсом "+ID);
end;

/*возвращает id_nform по id_paym*/
macro GetIDNformPaym(id_paym)
  var SQLtext;
  var q;

  SQLtext = " select t.id_nform as id_nform"+
            " from paym t "+
            " where t.id_paym = :p1";
  q = ExecQuery (SQLtext, id_paym);

  if (not TstObj (q))
    RunError (toansi("Запрос выборки платежа: ошибка в запросе"));
  end;

  if(q.eof)
    return 0;
  end;

  return int(q.rec.id_nform);
end;

/*возвращает объект (TRslPayDoc) "платеж", найденный по ID_PAYM*/
macro GetPaymByID(ID_PAYM)

  var Type_Doc = GetIDNformPaym(int(ID_PAYM));
  var PayObj = TRslPayDoc(Type_Doc,int(ID_PAYM));

  if(ValType(PayObj) != V_GENOBJ)
    RunError(toansi("Не удалось создать объект"));
  end;

  return PayObj;

end;

/*Возвращает ID_NKORR контрагента по коду*/
MACRO GetKorrIDKorr(Code)
  if(ValType(Code) == V_UNDEF)
    return "";
  end;

  var GetKor = TRslOraQuery();
  var ID_nkorr;

  GetKor.SqlText = " select t.ID_nkorr as ID_nkorr "+
                          " from nkorr t "+
                          " where t.Code = :Code ";

  GetKor.DeclareAndSet("Code",Code);

  if(not GetKor.Execute())
    RunError(toansi("макрофункция GetKorrCode:\r\n"+ToANSi(GetKor.Error)));
  end;

  if(not GetKor.Eof)
    ID_nkorr = GetKor.GetByName("ID_nkorr").AsString;
  end;

  return ID_nkorr;

END;

macro CloseAndCopy(OpName, NameFile, OutNameFile)

  if(not(CopyFile(NameFile, OutNameFile)))
     CommentStr = "не удалось скопировать " + NameFile+" в "+OutNameFile;
     return false;
  else
    AddPtk(OpName+ NameFile+" скопирован в " + OutNameFile);
  end;
  return true;
end;

macro GetKey()
  var q = TRslOraQuery();

  if(Valtype(q)==V_UNDEF)
      runerror(ToAnsi("Ошибка GetColByCol: Не создан класс TRslOraQuery"));
      return 0;
  end;

  if(MDG == 1)
    q.SqlText = " SELECT RSP_ENCODE.Decrypt(k.keyleft)||   "+
                "       RSP_ENCODE.Decrypt(k.keyright) key "+
                "  FROM keys k                             "+
                " WHERE k.keydate >= sysdate               "+
                "   AND rownum = 1                         "+
                " ORDER BY k.id_keys desc";

    if(NOT q.Execute())
       runerror(ToAnsi("Ошибка GetKeyForSWIFT: "+q.Error + "."));
    end;

    return q.GetByName("key").AsString;
  else
    return "";
  end;
end;

/*
   Возвращает подстроку строки str, находящуюся между подстроками bMarker и eMarker
*/
Macro GetSubStr(str, bMarker, eMarker)
  var idx1 = index(str, bMarker);
  var idx2= 0;
  var retval = "";

  if( idx1)
   retval = substr(str, idx1 + strlen(bMarker));
   if (valtype (eMarker) != V_UNDEF)
    idx2 = index(retval, eMarker) - 1;
   else
    idx2 = strlen (retval);
   end;
  end;
  if (idx2)
    retval = trim(substr(retval, 1, idx2));
    return retval;
  end;
  return "";
end;
