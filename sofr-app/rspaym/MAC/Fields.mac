/*12.05.2014 voikin*/
import pcre_dlm;

//var CurMsgFields = TAscArray();
var CurMsgFields = TArray;
var ErrMsg = "";

/* нясяльнике */
CLASS TField (str)
 var Num = "", name = "", option = "", SubFields = null;


 MACRO ParceField (str)
   var i = 0, tmpNum;

   tmpNum = GetValue (str, RN + ":", ":");
   /* отделяем номер поля */
   i = 1;
   while ( (i <= strlen(tmpNum)) AND
           (codefor(Substr(tmpNum, i, 1)) > 47) AND(codefor(Substr(tmpNum, i, 1)) < 58))
    i = i + 1;
   end;
   this.Num    = trim(Substr (tmpNum, 1, i - 1));
   this.Option = trim(Substr (tmpNum, i));
   i = 0;
   SubFields.Value(i) = GetValue (str, ":", RN);
   i = i + 1;
   while (strlen (trim(str)) >0 )
     SubFields.Value(i) = GetValue (str, RN, RN);
     i = i + 1;
   end;
 END;

 /* палучить значение подполя по проядковому нумберу idx*/
 MACRO GetSubField (idx)
   idx = int(idx);
   if ((idx > SubFields.size) OR (idx < 0))
     return "";
   end;
   return SubFields.Value(idx);
 END;

 /*
   записать значение val в подполе с проядковым нумбером idx
   если подполя с индексом idx в массиве нет , то оно добавляется
 */
 MACRO SetSubField (idx, val)
   idx = int(idx);
   if (/*(idx > SubFields.size) OR */(idx < 0))
     return;
   end;
   SubFields.Value(idx) = val;
   return;
 END;

 /*
    добавить в конец поля подполе
    и заполнить его значением val
 */
 MACRO AddSubField (val)
   var sz = SubFields.size;
   SubFields.Value(sz) = val;
   return;
 END;
 /*
    удалить подполе idx
    если idx = -1, то чистить все поля
  */
 MACRO Clear (idx)
   if (idx == -1)
     SubFields.size = 0;
   elif ((idx >=0) AND (idx < SubFields.size))
     SubFields.Value(idx) = "";
   end;
 END;

 /* копирование поля невзирая на лица
    Src      - Tfield источник
    copyNum  - если true - копируем номер и опцию
 */
 MACRO FldCopy (Src, copyNum)
   var szSrc, i = 0;
   if (VALTYPE(Src) != V_GENOBJ)
    return;
   end;
   if (VALTYPE(copyNum) == V_UNDEF)
    copyNum = false;
   end;
   szSrc = Src.SubFields.Size;
   /* чыстим */
   this.Clear(-1);
   if (copyNum)
    this.Option = Src.Option;
    this.Num = Src.Num;
   end;
   while  (i < szSrc)
     this.SubFields.Value(i) = src.SubFields.Value(i);
     i = i + 1;
   end;
 END;

   /* печать поля, для отладки
     ToScr = 0 или В_УНДЕФ - в протокол
     ToScr = 1 - на экран
  */
  MACRO PrintField (ToScr)
     var i = 0, sz = SubFields.size, tmp = "";
     if (valtype (toscr) == V_UNDEF)
       toscr = false;
     end;
     while ( i < sz)
       tmp = SubFields.Value(i);
       if (i == 0 ) /* номер и опция */
         tmp = ":" + this.Num + this.Option + ":" + tmp;
       end;
       if (toScr)
         println (tmp);
       else
         addptk (tmp);
       end;
       i = i + 1;
     end;
  END;

  /*
    получение собранного SWIFT поля
    idx     - необязательный номер подполя с которого начинаем собирать
    withNum - добавлять ли номер и опцию поля к собранной строке
    Trm     - true - тримить подполя
  */
  MACRO GetFldString ( idx, Trm, withNum )
     var i = 0, sz = SubFields.size, tmp = "", fl = "";


     if (valtype (idx) == V_UNDEF)
       idx = 0;
     end;
     if (valtype (withNum) == V_UNDEF)
       withNum = false;
     end;
     if (valtype (Trm) == V_UNDEF)
       Trm = false;
     end;
     i = idx;
     while ( i < sz)
       /* AB 19.07.08 в связи с пробелами в референсах
        fl = trim(SubFields.Value(i));
       */
       fl = SubFields.Value(i);
       if (Trm)
         fl = trim(fl);
       end;
       tmp = tmp + fl + RN;
       i = i + 1;
     end;

     /* если собираем все поле - добавить номер и опцию */
     if ((idx == 0) AND withNum)
      if (trim(chsubstr(tmp, RN, "")) != "")
       tmp = ":" + this.Num + this.Option + ":" + tmp;
      else
       tmp = ":" + this.Num + this.Option + ":" + RN;
//       tmp = "";
      end;
     end;
     /* AB 19.07.08 в связи с пробелами в референсах
        return trim(tmp);
     */
     return tmp;
  END;


  /* деструктивный деструктор */
  MACRO Destructor ()
    /*AddPtk ("FLD Destructor : " + this.Num + "/" + this.Option);*/
    this.Clear (-1);
  END;

  SubFields = TArray (10,20);

  if (str != "")
   ParceField (str);
  end;

END;


/*заполнение массива CurMsgFields - объекты, соответствующие полям загружаемого сообщения
  !!!в случае повторяющихся полей следующее поле затирает предыдущее с таким же именем
*/
MACRO ParceFields (msg, fldAr)
  var curstr, fld, i = 0;

  //CurMsgFields.Clear();
  CurMsgFields.Size = 0;
  while (i < fldAr.size)
     if (i < (fldAr.size - 2))
       curstr = substr (msg, fldAr.value(i), fldAr.value(i+2) - fldAr.value(i));
     else /* последняя строка */
       curstr = substr (msg, fldAr.value(i));
       i = fldAr.size;
     end;
     fld = TField (curstr);
     if (fld.Num != "")
//        CurMsgFields.value(fld.Num) = fld;
        CurMsgFields[fld.Num] = fld;
     else
       ErrMsg  = "Ошибка при разборе поля  \"" + curstr + "\"";
       return false;
     end;
     i = i + 2;
  end;
  return true;
END;

MACRO ParceFields2 (msg, fldAr)
  var curstr, fld, i = 0;

  //CurMsgFields.Clear();
  CurMsgFields.Size = 0;
  while (i < fldAr.size)
     if (i < (fldAr.size - 2))
       curstr = substr (msg, fldAr.value(i), fldAr.value(i+2) - fldAr.value(i));
     else /* последняя строка */
       curstr = substr (msg, fldAr.value(i));
       i = fldAr.size;
     end;
     fld = TField (curstr);
     if (fld.Num != "")
        CurMsgFields[CurMsgFields.Size] = fld;
     else
       ErrMsg  = "Ошибка при разборе поля  \"" + curstr + "\"";
       return false;
     end;
     i = i + 2;
  end;
  return true;
END;
