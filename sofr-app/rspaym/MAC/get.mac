
/*
Принимает имя таблицы, имя колонки,значение которой нужно вернуть (только типа INT),
имя колонки и ее значение по которой нужно найти запись
*/
macro GetColByCol(table, ret_colum, find_colum, find_value)
  var q = TRslOraQuery();
  if(Valtype(q)==V_UNDEF)
      runerror("Ошибка GetColByCol: Не создан класс TRslOraQuery");
      return 0;
  end;

  q.SqlText = "select "+ret_colum+" from "+table+" where "+ find_colum+" = :find_value";
  q.DeclareAndSet("find_value",find_value);
  if(NOT q.Execute())
      runerror("Ошибка GetColByCol: "+ToAnsi(q.Error) + ". Параметры: " + table + "," + ret_colum + "," +
               find_colum + "," +  find_value);
  end;
  if(Not q.Eof)
      return q.GetByName(ret_colum).AsInteger;
  else
      return 0;
  end;
end;

/*
Принимает имя таблицы, имя колонки,значение которой нужно вернуть (только типа String),
имя колонки и ее значение по которой нужно найти запись
*/
macro GetColByColStr(table, ret_colum, find_colum, find_value)
  var q = TRslOraQuery();
  if(Valtype(q)==V_UNDEF)
      runerror("Ошибка GetColByCol: Не создан класс TRslOraQuery");
      return 0;
  end;

  q.SqlText = "select "+ret_colum+" from "+table+" where "+ find_colum+" = :find_value";
  q.DeclareAndSet("find_value",find_value);
  if(NOT q.Execute())
      runerror("Ошибка GetColByCol: "+ToAnsi(q.Error) + ". Параметры: " + table + "," + ret_colum + "," +
               find_colum + "," +  find_value);
  end;
  if(Not q.Eof)
      return q.GetByName(ret_colum).AsString;
  else
      return 0;
  end;
end;

/*
Принимает имя таблицы, имя колонки,значение которой нужно вернуть, и значение колонки CODE
*/
macro GetIdByCode(table, id_colum, code)
  return  GetColByCol(table,id_colum,"CODE",code);
end;


macro GetSetupValue(Path)
/*возвращает значение настройки Path*/

  var q = TRslOraQuery();
  var val = "";

  if(Valtype(q)==V_UNDEF)
      runerror(ToAnsi("Ошибка GetSetupValue: Не создан класс TRslOraQuery"));
      return 0;
  end;

  q.SqlText = "begin :val := RSP_Setup.Get_Value(:Path); end;";
  q.DeclareAndSet("val",val,"Path",Path);
  if(NOT q.Execute())
      runerror("Ошибка GetSetupValue: "+ToAnsi(q.Error) + ". Параметры: " + Path);
  end;

  val = q.GetVariable("val");

  return val;
end;

macro GetSetupValuesString(Path,Separator)
/*возвращает строку значений (разделенных Separator) настройки Path*/

  var q = TRslOraQuery();
  var val = "";

  if((ValType(Separator) == V_UNDEF)or(Separator == ""))
    Separator = ",";
  end;

  if(Valtype(q)==V_UNDEF)
      runerror(ToAnsi("Ошибка GetSetupValues: Не создан класс TRslOraQuery"));
      return 0;
  end;

  q.SqlText = " declare                                        \n"+
              "   v_name setup.name%type;                      \n"+
              "   v_value setup.value%type;                    \n"+
              "   RC SYS_REFCURSOR;                            \n"+
              "   refval VARCHAR2(4000);                       \n"+
              " begin                                          \n"+
              "   RC := RSP_Setup.Get_Values(:Path);           \n"+
              "   loop                                         \n"+
              "     fetch RC into v_name, v_value;             \n"+
              "     if v_value = '1' then                      \n"+
              "       refval := refval||:Separator||v_name;    \n"+
              "     end if;                                    \n"+
              "     exit when RC%notfound;                     \n"+
              "   end loop;                                    \n"+
              "   close RC;                                    \n"+
              "   :val := refval;                              \n"+
              " end;";
  q.DeclareAndSet("Path",Path,"Separator",Separator,"val",val);

  if(NOT q.Execute())
      runerror("Ошибка GetSetupValuesString: "+ToAnsi(q.Error) + ". Параметры: " + Path + "," + Separator);
  end;

  val = q.GetVariable("val");

  return val;
end;
