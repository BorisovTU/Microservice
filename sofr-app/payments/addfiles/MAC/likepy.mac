/*
 $Name: likepy.mac
 $Module: Ядро
 $Description: Работа с массивами, строками и прочим 
*/

/************************************************************************/
/*         Автоматизированная банковская система RS-Bank                */
/*            Copyright (c) R-Style Software Lab 2003                   */
/*                                                                      */
/*  Имя файла      : likepy.mac                                         */
/*                                                                      */
/*  Описание       : PYTHON-подобные (отдаленно похожие) функции        */
/*                                                                      */
/*  Программист    : Смирнов С.В.                                       */
/*                                                                      */
/*  Создан         : 30.04.03                                           */
/************************************************************************/

/*

***  РАБОТА СО СТРОКАМИ 

split( source, delim ) - разделить строку по заданному разделителю
join ( parts,  delim ) - объединить строки, вставив между ними delim

*** РАБОТА С МАССИВАМИ

foreach( arr, fun )           - применить fun к каждому элементу arr
map    ( arr, fun )           - применить fun к каждому элементу arr (возвращает массив результатов)
filter ( arr, fun )           - фильтрация массива функцией fun
reduce ( arr, fun, startval ) - свертка массива arr функцией fun
find   ( arr, whatToFind )    - найти элемент или массив в массиве

subArray ( arr, from, to )- выделить подмассив
makeArray( ... )          - сформировать массив из переменного числа параметров

arrMin( arr ) - найти минимальный элемент массива
arrMax( arr ) - найти максимальный элемент массива
arrSum( arr ) - найти сумму элементов массива
arrAvg( arr ) - найти среднее значение элементов массива

*** ПРОЧЕЕ

pyOR      (op1, op2) - логическое ИЛИ в стиле PYTHON
pyAND     (op1, op2) - логическое И в стиле PYTHON
IfThenElse(condition, ifTrue, ifFalse) - аналог конструкции ... ? ... : ... языка Си

*/

/************************************************************************/
/* РАБОТА СО СТРОКАМИ                                                   */
/************************************************************************/

/* разделить строку по заданному разделителю */
/*  source - разделяемая строка              */
/*  delim  - разделитель                     */
/*  возвращает массив подстрок               */
MACRO split( source:string, delim:string ):TArray
  var parts    :TArray = TArray(),
      pos      :integer,
      delim_len:integer;
  if(not source)
    parts.Value(parts.Size) = "";
  elif(not delim)
    parts.Value(parts.Size) = source;
  else
    delim_len = StrLen(delim);
    while(source)
      pos = Index(source, delim);
      if(pos > 0)
        parts.Value(parts.Size) = SubStr(source, 1, pos-1);
        source = SubStr(source, pos+delim_len);
        if(not source)
          parts.Value(parts.Size) = "";
        end;
      else
        parts.Value(parts.Size) = source;
        source = "";
      end;
    end;
  end;
  return parts;
END;

/* объединить строки, вставив между ними delim         */
/*  parts - массив объединяемых строк                  */
/*  delim - разделитель                                */
/*  возвращает строку, состоящую из переданных частей, */
/*  между которыми вставлен delim                      */
MACRO join( parts:TArray, delim:string ):string
  var result:string="", i:integer=0;
  while(i<parts.Size)
    if( i )
      result = result + delim + String(parts.Value(i));
    else
      result = String(parts.Value(i));
    end;
    i=i+1;
  end;
  return result;
END;

/* заменить символы в строке                                       */
/*  source - исходная строка                                       */
/*  from   - заменяемая подстрока                                  */
/*  to     - заменяющая подстрока                                  */
/*  возвращает строку, в которой все подстроки from заменены на to */
MACRO replace( source:string, from:string, to:string ):string
  // Оказывается уже есть StrSubst :)
  // return join(split(source, from), to);
  return StrSubst( source, from, to );
END;

/************************************************************************/
/* РАБОТА С МАССИВАМИ                                                   */
/************************************************************************/

/* применить fun к каждому элементу arr */
/*  arr - массив                        */
/*  fun - функция одного аргумента      */
/*  ничего не возвращает                */
MACRO foreach( arr:TArray, fun )
  var i:integer = 0;
  while( i < arr.Size )
    ExecMacro2( @fun, arr.value(i) );
    i = i + 1;
  end;
END;

/* применить fun к каждому элементу arr                   */
/*  arr - массив                                          */
/*  fun - функция одного аргумента                        */
/*  возвращает массив значений, возвращенных функцией fun */
MACRO map( arr:TArray, fun ):TArray
  var result:TArray = TArray(), i:integer = 0;
  while( i < arr.Size )
    result.Value( result.Size ) = ExecMacro2( @fun, arr.Value(i) );
    i = i + 1;
  end;
  return result;
END;

/* фильтрация массива функцией fun                           */
/*  arr - массив                                             */
/*  fun - функция одного аргумента                           */
/*  возвращает массив элементов, на которые fun вернула TRUE */
MACRO filter( arr:TArray, fun ):TArray
  var result:TArray = TArray(), i:integer = 0;
  while( i < arr.Size )
    if( ValType(fun) != V_UNDEF )
      if( ExecMacro2( @fun, arr.Value(i) ) )
        result.value(result.Size) = arr.value(i);
      end;
    else
      if( arr.value(i) )
        result.value(result.Size) = arr.value(i);
      end;
    end;
    i = i + 1;
  end;
  return result;
END;

/* свертка массива arr функцией fun                                */
/*  arr - массив                                                   */
/*  fun - функция двух аргументов                                  */
/*        (первый - результат, который вернула fun в прошлый вызов */
/*         второй - очередной аргумент)                            */
/*  startval - начальное значение                                  */
/* возвращает результат последнего вызова fun                      */
MACRO reduce( arr:TArray, fun, startval:variant ):variant
  var result:variant = startval, i:integer = 0;
  while( i < arr.Size )
    result = ExecMacro2( @fun, result, arr.value(i) );
    i = i + 1;
  end;
  return result;
END;


/* найти массив в массиве                               */
/*  arr - массив, в котором ведется поиск               */
/*  whatToFind - элемент или массив, который надо найти */
/* возвращает индекс первого элемента или -1            */
MACRO find( arr:TArray, whatToFind:variant ):integer
  var i:integer = 0;
  var j:integer;

  MACRO _compare( v1:variant, v2:variant ):bool
    if( ValType( v1 ) == ValType( v2 ) )
      return v1 == v2;
    end;
    return false;
  END;

  if( IsEqClass( "TArray", whatToFind ) )
    //поиск массива
    while( i < (arr.size - whatToFind.size + 1) )
      j = 0;
      while( (j < whatToFind.size) and _compare( arr.value(i+j), whatToFind.value(j) ) )
        j = j + 1;
      end;
      if( j == whatToFind.size )
        return i;
      end;
      i = i + 1;
    end;
  else
    //поиск элемента
    while( i < arr.size )
      if( _compare( arr.value(i), whatToFind ) )
        return i;
      end;
      i = i + 1;
    end;
  end;

  return -1;
END;


/* сформировать массив из переменного числа параметров */
/*  возвращает сформированный массив                   */
MACRO makeArray():TArray
  var parm:variant, i:integer = 0, result:TArray = TArray( ParmCount(), ParmCount() );
  while( GetParm(i, parm) )
    result.value(i) = parm;
    i = i + 1;
  end;
  return result;
END;

/* выделить подмассив                                     */
/*  arr  - массив, в котором ведется поиск                */
/*  from - индекс первого элемента                        */
/*  to   - индекс последнего элемента (можно не задавать) */
/*  возвращает массив, в который входят элементы          */
/*  переданного массива от from до to включительно        */
MACRO subArray(arr:TArray, from:integer, to:integer):TArray
  var result:TArray = TArray(), i:integer;
  if( (from == NULL) or (from < 0) )
    from = 0;
  end;
  if( to == NULL )
    to = arr.Size;
  end;
  i = from;
  while( (i < arr.Size) and (i <= to) )
    result.value(result.Size) = arr.value(i);
    i = i + 1;
  end;
  return result;
END;

/* объединить массивы */
MACRO joinArrays():TArray
  var parm:TArray,
      i:integer = 0,
      j:integer,
      result:TArray = TArray();
  while( GetParm(i, parm) )
    j = 0;
    while( j < parm.size )
      result[result.size] = parm[j];
      j = j + 1;
    end;
    i = i + 1;
  end;
  return result;
END;

/* служебные алгоритмы для реализации функций на основе reduce          */

/* минимум */
private macro minAlg( result:variant, val:variant ):variant
  if( (result == NULL) or (result > val) )
    return val;
  else
    return result;
  end;
end;

/* максимум */
private macro maxAlg( result:variant, val:variant ):variant
  if( (result == NULL) or (result < val) )
    return val;
  else
    return result;
  end;
end;

/* сумма */
private macro sumAlg( result:variant, val:variant ):variant
  if( result == NULL )
    return val;
  elif( val != NULL )
    return result + val;
  else
    return result;
  end;
end;

/* найти минимальный элемент массива                  */
/*  arr - массив                                      */
/*  возвращает значение минимального элемента массива */
MACRO arrMin( arr:TArray ):variant
  return reduce( arr, @minAlg );
END;

/* найти максимальный элемент массива                  */
/*  arr - массив                                       */
/*  возвращает значение максимального элемента массива */
MACRO arrMax( arr:TArray ):variant
  return reduce( arr, @maxAlg );
END;

/* найти сумму элементов массива                */
/*  arr - массив                                */
/*  возвращает сумму значений элементов массива */
MACRO arrSum( arr:TArray ):variant
  return reduce( arr, @sumAlg );
END;

/* найти среднее значение элементов массива           */
/*  arr - массив                                      */
/*  возвращает среднее значение элементов массива     */
/*  для пустого массива возвращается NULL             */
/*  содержимое массива при этом не анализируется,     */
/*  так что, среднюю из строк само собой не вычислишь */
MACRO arrAvg( arr:TArray ):variant
  var sum:variant = NULL;
  if( arr.size )
    sum = arrSum( arr );
    if( sum != NULL )
      return sum / arr.size;
    end;
  end;
  return NULL;
OnError(x)
  return NULL;
END;

/************************************************************************/
/* ПРОЧЕЕ                                                               */
/************************************************************************/

/* логическое ИЛИ в стиле PYTHON */
/*  возвращает:                  */
/*   если op1 - op1              */
/*   иначе    - op2              */
MACRO pyOR(op1:variant, op2:variant):variant
  if(op1)
    return op1;
  else
    return op2;
  end;
END;

/* логическое И в стиле PYTHON */
/*  возвращает:                */
/*   если не op1 - op1         */
/*   иначе       - op2         */
MACRO pyAND(op1:variant, op2:variant):variant
  if(not op1)
    return op1;
  else
    return op2;
  end;
END;

/* аналог конструкции ... ? ... : ... языка Си */
/*  возвращает:                                */
/*   если condition - ifTrue                   */
/*   иначе          - ifFalse                  */
MACRO IfThenElse(condition:variant, ifTrue:variant, ifFalse:variant):variant
  if(condition)
    return ifTrue;
  else
    return ifFalse;
  end;
END;

macro IsDigitalNumber( Number )
  var stat = 0, i = 1, ch, DigitString = "0123456789";

      while( (not stat) and (i <= strlen(Number)) )
        ch = SubStr( Number, i, 1 );
        if( not Index( DigitString, ch ))
          stat = 1;
        end;
        i = i + 1;
      end;
  return stat;
end;

// Аналог конструкции In в SQL
/*
macro InList(val)
  
  var parm, i = 1; 
  
  while(GetParm(i, parm))
    if(val == parm)
      return true;
    end;                             
    i = i + 1;
  end;
  return false;
end;
*/
// Перевод строки из 45, 752, 458 в  '45','752','458'
//то есть в формат конструкции in для SQL
macro ConvertStrToSQLInFormat( strVal )
  return "'" + join( map( split( strVal, "," ), @trim ), "','" ) + "'";
end;
