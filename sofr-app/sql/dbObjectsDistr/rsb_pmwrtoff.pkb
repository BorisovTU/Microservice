CREATE OR REPLACE PACKAGE BODY RSB_PMWRTOFF IS

   LastErrorMessage VARCHAR2(1024) := '';
   ContextDealID  NUMBER(10) := 0;
   ContextFIID  NUMBER(10) := 0;

   --Дата начала действия кризисной переоценки
   g_BegCrizDate DATE := TO_DATE('18.02.2022','DD.MM.YYYY');

   --Дата окончания действия кризисной переоценки
   g_EndCrizDate DATE := TO_DATE('31.12.2022','DD.MM.YYYY');

   --Дата курса для кризисной переоценки
   g_CrizCourseDate DATE := TO_DATE('17.02.2022','DD.MM.YYYY');

   --Максимальная точность (округление) Глобальной операции
   g_MaxSumPrecision NUMBER(10) := 12;  

   PROCEDURE InitContextFIID
   AS
   BEGIN
      ContextFIID := 0;
   END;

   PROCEDURE SetContextFIID( Fiid IN NUMBER )
   AS
   BEGIN
      ContextFIID := Fiid;
   END;

   FUNCTION GetContextAvoirisName RETURN VARCHAR2
   AS
      v_Name DFININSTR_DBT.T_NAME%TYPE;
   BEGIN

      v_Name := CHR(1);

      IF ( ContextFIID > 0 ) THEN
        BEGIN

          SELECT T_NAME INTO v_Name
            FROM DFININSTR_DBT
           WHERE T_FIID = ContextFIID;
          EXCEPTION
            WHEN OTHERS THEN RETURN CHR(1);
        END;
      END IF;

      RETURN v_Name;
   END;

   PROCEDURE InitContextDeal
   AS
   BEGIN
      ContextDealID := 0;
   END;

   PROCEDURE SetContextDeal( DealID IN NUMBER )
   AS
   BEGIN
      ContextDealID := DealID;
   END;

   PROCEDURE InitError
   AS
   BEGIN
      LastErrorMessage := '';
   END;

   PROCEDURE SetError( ErrNum IN INTEGER, ErrMes IN VARCHAR2 DEFAULT NULL )
   AS
   BEGIN
      IF( ErrMes IS NULL ) THEN
         LastErrorMessage := '';
      ELSE
         LastErrorMessage := ErrMes;
      END IF;
      RAISE_APPLICATION_ERROR( ErrNum,'' );
   END;

   PROCEDURE GetLastErrorMessage( ErrMes OUT VARCHAR2 )
   AS
   BEGIN
      ErrMes := LastErrorMessage;
   END;

   FUNCTION GetContextDealCode RETURN VARCHAR2
   AS
      v_DealCode DDL_TICK_DBT.T_DEALCODE%TYPE;
   BEGIN

      v_DealCode := CHR(1);

      IF ContextDealID > 0 THEN
        BEGIN

          SELECT T_DEALCODE INTO v_DealCode
            FROM DDL_TICK_DBT
           WHERE T_DEALID = ContextDealID;

          EXCEPTION
            WHEN OTHERS THEN RETURN CHR(1);

        END;
      END IF;

      RETURN v_DealCode;
   END;

   FUNCTION CHARGE_BONUS RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.CHARGE_BONUS IS NULL ) then
         if( Rsb_Common.GetRegBoolValue('SECUR\CHARGE_BONUS', 0) = TRUE ) then
            ReestrValue.CHARGE_BONUS := CHARGE_BONUS_YES;
         else
            ReestrValue.CHARGE_BONUS := CHARGE_BONUS_NO;
         end if;
      end if;
      return ReestrValue.CHARGE_BONUS;
   end; --GetSettings

   FUNCTION CALC_DISCOUNT_WITHOUT_PARTLY RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.CALC_DISCOUNT_WITHOUT_PARTLY IS NULL ) then
         if( Rsb_Common.GetRegBoolValue('SECUR\CALC_DISCOUNT_WITHOUT_PARTLY', 0) = TRUE ) then
            ReestrValue.CALC_DISCOUNT_WITHOUT_PARTLY := DISCOUNT_WITHOUT_PARTLY_YES;
         else
            ReestrValue.CALC_DISCOUNT_WITHOUT_PARTLY := DISCOUNT_WITHOUT_PARTLY_NO;
         end if;
      end if;
      return ReestrValue.CALC_DISCOUNT_WITHOUT_PARTLY;
   end; --GetSettings

 FUNCTION CALC_BONUS_WITHOUT_PARTLY RETURN NUMBER DETERMINISTIC
 is
 begin
   if( ReestrValue.CALC_BONUS_WITHOUT_PARTLY IS NULL ) then
     if( Rsb_Common.GetRegBoolValue('SECUR\МСФО\НАЧИСЛЕНИЕ ПРЕМИИ БЕЗ УЧЕТА ЧП', 0) = TRUE ) then
       ReestrValue.CALC_BONUS_WITHOUT_PARTLY := BONUS_WITHOUT_PARTLY_YES;
     else
       ReestrValue.CALC_BONUS_WITHOUT_PARTLY := BONUS_WITHOUT_PARTLY_NO;
     end if;
   end if;
   return ReestrValue.CALC_BONUS_WITHOUT_PARTLY;
 end; --GetSettings

   FUNCTION WriteOffOnlySetPortofolio RETURN NUMBER DETERMINISTIC
    is
    v_Flag BOOLEAN;
   begin
      if( ReestrValue.WriteOffOnlySetPortofolio IS NULL ) then
         ReestrValue.WriteOffOnlySetPortofolio := 0;
         v_Flag := Rsb_Common.GetRegBoolValue('SECUR\WRITEOFFONLYSETPORTOFOLIO', 0);
         IF v_Flag = TRUE THEN
           ReestrValue.WriteOffOnlySetPortofolio := 1;
         END IF;
      end if;
      return ReestrValue.WriteOffOnlySetPortofolio;
   end; --GetSettings

   FUNCTION NewRepoDate RETURN DATE DETERMINISTIC
    is
      v_Str VARCHAR2(10);
   begin
      if( ReestrValue.NewRepoDate IS NULL ) then
         v_Str := trim(rsb_common.GetRegStrValue('SECUR\ДАТА НАЧАЛА НОВОГО БУ РЕПО', 0));
         IF v_Str <> CHR(1) THEN
           ReestrValue.NewRepoDate := TO_DATE(v_Str, 'DD.MM.YYYY');
         END IF;
      end if;
      return ReestrValue.NewRepoDate;
   end; --GetSettings

   FUNCTION OnlyPriceInDiscountOrBonus RETURN NUMBER DETERMINISTIC
    is
    v_Flag BOOLEAN;
   begin
      if( ReestrValue.OnlyPriceInDiscountOrBonus IS NULL ) then
         ReestrValue.OnlyPriceInDiscountOrBonus := 0;
         v_Flag := Rsb_Common.GetRegBoolValue('SECUR\ONLY_PRICE_IN_DISCOUNT_OR_BONUS', 0);
         IF v_Flag = TRUE THEN
           ReestrValue.OnlyPriceInDiscountOrBonus := 1;
         END IF;
      end if;
      return ReestrValue.OnlyPriceInDiscountOrBonus;
   end; --GetSettings

   FUNCTION SortingLotsCode RETURN NUMBER DETERMINISTIC
   IS
      v_SortType NUMBER;
   BEGIN
      IF( ReestrValue.SortingLotsCode IS NULL ) THEN
        ReestrValue.SortingLotsCode := Rsb_Common.GetRegIntValue('SECUR\SORTING_LOTS_CODE', 0);
      END IF;
      RETURN ReestrValue.SortingLotsCode;
   END; --GetSettings

   FUNCTION SortingLotsAmount RETURN NUMBER DETERMINISTIC
   IS
      v_SortType NUMBER;
   BEGIN
      IF( ReestrValue.SortingLotsAmount IS NULL ) THEN
        ReestrValue.SortingLotsAmount := Rsb_Common.GetRegIntValue('SECUR\SORTING_LOTS_AMOUNT', 0);
      END IF;
      RETURN ReestrValue.SortingLotsAmount;
   END; --GetSettings

   FUNCTION AccountingExSecur RETURN NUMBER DETERMINISTIC
   IS
      v_Ret NUMBER;
   BEGIN
      IF( ReestrValue.AccountingExSecur IS NULL ) THEN
        ReestrValue.AccountingExSecur := Rsb_Common.GetRegIntValue('SECUR\МСФО\УЧЕТ ВАЛЮТНЫХ ДОЛЕВЫХ ЦБ', 0);
      END IF;
      RETURN ReestrValue.AccountingExSecur;
   END; --GetSettings

   FUNCTION EPSAvrLessThanYear RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.EPSAvrLessThanYear IS NULL ) then
         if( Rsb_Common.GetRegBoolValue('SECUR\МСФО\ЭПС ДЛЯ  ДО МЕНЬШЕ ГОДА', 0) = TRUE ) then
            ReestrValue.EPSAvrLessThanYear := EPSAVRLESSTHANYEAR_YES;
         else
            ReestrValue.EPSAvrLessThanYear := EPSAVRLESSTHANYEAR_NO;
         end if;
      end if;
      return ReestrValue.EPSAvrLessThanYear;
   end; --GetSettings

   FUNCTION EPSAvrNSignDevACEPSACLM RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.EPSAvrNSignDevACEPSACLM IS NULL ) then
         if( Rsb_Common.GetRegBoolValue('SECUR\МСФО\ЭПС ДЛЯ ДО С НЕСУЩЕСТВ. ОТКЛ', 0) = TRUE ) then
            ReestrValue.EPSAvrNSignDevACEPSACLM := EPSAVRNSIGNDEVACEPSACLM_YES;
         else
            ReestrValue.EPSAvrNSignDevACEPSACLM := EPSAVRNSIGNDEVACEPSACLM_NO;
         end if;
      end if;
      return ReestrValue.EPSAvrNSignDevACEPSACLM;
   end; --GetSettings

   FUNCTION CALC_DEFDIFF_WITHOUT_PARTLY RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.CALC_DEFDIFF_WITHOUT_PARTLY IS NULL ) then
         if( Rsb_Common.GetRegBoolValue('SECUR\МСФО\CALC_DEFDIFF_WITHOUT_PARTLY', 0) = TRUE ) then
            ReestrValue.CALC_DEFDIFF_WITHOUT_PARTLY := DISCOUNT_WITHOUT_PARTLY_YES;
         else
            ReestrValue.CALC_DEFDIFF_WITHOUT_PARTLY := DISCOUNT_WITHOUT_PARTLY_NO;
         end if;
      end if;
      return ReestrValue.CALC_DEFDIFF_WITHOUT_PARTLY;
   end; --GetSettings

   FUNCTION CALC_PDD_BOND_SSPU RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.CALC_PDD_BOND_SSPU IS NULL ) then
         ReestrValue.CALC_PDD_BOND_SSPU := Rsb_Common.GetRegIntValue('SECUR\МСФО\НАЧИСЛЕНИЕ ПДД ПО ДО В ССПУ', 0);
      end if;
      return ReestrValue.CALC_PDD_BOND_SSPU;
   end; --GetSettings

   FUNCTION CALC_AMORTOWN_BEFOREOFFER RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.CALC_AMORTOWN_BEFOREOFFER IS NULL ) then
         if( Rsb_Common.GetRegIntValue('SECUR\ОЭБ_АМОРТИЗАЦИЯ_ДО_ОФЕРТЫ', 0) = 1 ) then
            ReestrValue.CALC_AMORTOWN_BEFOREOFFER := CALC_AMORTOWN_BEFOREOFFER_YES;
         else
            ReestrValue.CALC_AMORTOWN_BEFOREOFFER := CALC_AMORTOWN_BEFOREOFFER_NO;
         end if;
      end if;
      return ReestrValue.CALC_AMORTOWN_BEFOREOFFER;
   end; --GetSettings

   FUNCTION DATE_CONV_COURSE RETURN NUMBER DETERMINISTIC
   is
   begin
      if( ReestrValue.DATE_CONV_COURSE IS NULL ) then
         if( Rsb_Common.GetRegIntValue('SECUR\ДАТА КУРСА КОНВЕРТАЦИИ ЗАТРАТ', 0) = 1 ) then
            ReestrValue.DATE_CONV_COURSE := DATE_COURSE_COMISS;
         else
            ReestrValue.DATE_CONV_COURSE := DATE_COURSE_DELIV;
         end if;
      end if;
      return ReestrValue.DATE_CONV_COURSE;
   end; --GetSettings

   FUNCTION FRBONDS_AMORTCALCKIND_LM RETURN NUMBER DETERMINISTIC
   IS
      v_Ret NUMBER;
   BEGIN
      IF( ReestrValue.FRBondsAmortCalcKindLM IS NULL ) THEN
        ReestrValue.FRBondsAmortCalcKindLM := Rsb_Common.GetRegIntValue('SECUR\МСФО\УЧЕТ ОБЛИГАЦИЙ С ПЕРЕМ. КУП. ЛМ', 0);
      END IF;
      RETURN ReestrValue.FRBondsAmortCalcKindLM;
   END; --GetSettings


   FUNCTION IIF( Cond IN BOOLEAN, n1 IN NUMBER, n2 IN NUMBER )
     RETURN NUMBER
   IS
   BEGIN
     IF( Cond ) THEN
        RETURN n1;
     ELSE
        RETURN n2;
     END IF;
   END;

   FUNCTION IIF( Cond IN BOOLEAN, n1 IN DATE, n2 IN DATE )
     RETURN DATE
   IS
   BEGIN
     IF( Cond ) THEN
        RETURN n1;
     ELSE
        RETURN n2;
     END IF;
   END;

   FUNCTION IIF( Cond IN BOOLEAN, n1 IN VARCHAR2, n2 IN VARCHAR2 )
     RETURN VARCHAR2
   IS
   BEGIN
     IF( Cond ) THEN
        RETURN n1;
     ELSE
        RETURN n2;
     END IF;
   END;

   FUNCTION pMIN(  n1 IN NUMBER, n2 IN NUMBER )
     RETURN NUMBER
   IS
   BEGIN
     IF( n1 < n2 ) THEN
        RETURN n1;
     ELSE
        RETURN n2;
     END IF;
   END;

   FUNCTION pMAX(  n1 IN NUMBER, n2 IN NUMBER )
     RETURN NUMBER
   IS
   BEGIN
     IF( n1 < n2 ) THEN
        RETURN n2;
     ELSE
        RETURN n1;
     END IF;
   END;

   FUNCTION RSI_GetLastAccountedFrVal( DealID IN NUMBER, BofficeKind IN NUMBER, OnDate IN DATE ) RETURN NUMBER DETERMINISTIC
   IS
      FrVal NUMBER := 0;
      IsExists BOOLEAN := true;
   BEGIN
      BEGIN
             select T_FAIRVALUE into FrVal
              from (select frval.t_Date, FRVAL.T_FAIRVALUE, frval.t_ID
                        from ddvnfrval_dbt frval
                      where frval.t_DealID = DealID
                         and frval.t_DocKind= BofficeKind
                         and FRVAL.T_DATE = OnDate
                      order by frval.t_Date desc, frval.t_ID desc)
            where rownum = 1;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN IsExists := false;
         WHEN OTHERS THEN IsExists := false;
      END;
      IF( not IsExists )THEN
          BEGIN
                 select T_FAIRVALUE into FrVal
                  from (select frval.t_Date, FRVAL.T_FAIRVALUE, frval.t_ID
                            from ddvnfrval_dbt frval
                          where frval.t_DealID = DealID
                             and frval.t_DocKind= BofficeKind
                             and frval.t_Accounted = 'X'
                          order by frval.t_Date desc, frval.t_ID desc)
                where rownum = 1;
          EXCEPTION
             WHEN NO_DATA_FOUND THEN NULL;
             WHEN OTHERS THEN NULL;
          END;
      END IF;
      RETURN FrVal;
   END; -- RSI_GetLastAccountedFrVal

    -- Значение категории для сделки "Тест на рыночность пройден"
   FUNCTION RSI_DealAttrMarketTest( OBJTYPE IN NUMBER, DealID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      CategoryValue dobjattr_dbt.t_NumInList % TYPE;
   BEGIN
      BEGIN
          SELECT Attr.t_NumInList INTO CategoryValue
            FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
           WHERE AtCor.t_ObjectType = OBJTYPE
             AND AtCor.t_GroupID    = 47 -- Тест на рыночность пройден
             AND AtCor.t_Object     = LPAD(DealID, 34, '0')
             AND Attr.t_AttrID      = AtCor.t_AttrID
             AND Attr.t_ObjectType  = AtCor.t_ObjectType
             AND Attr.t_GroupID     = AtCor.t_GroupID;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN CategoryValue := chr(0);
         WHEN OTHERS THEN return -1;
      END;

      IF( CategoryValue <> chr(0) ) THEN
         return to_number(CategoryValue);
      ELSE
         return -1;
      END IF;

      RETURN -1;
   END; -- RSI_DealAttrMarketTest

    -- Значение категории для ц/б "Наблюдаемые исходные данные"
   FUNCTION RSI_AvoirAttrObsBaseData( FIID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      CategoryValue dobjattr_dbt.t_NumInList % TYPE;
   BEGIN
      BEGIN
          SELECT Attr.t_NumInList INTO CategoryValue
            FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
           WHERE AtCor.t_ObjectType = RSB_SECUR.OBJTYPE_AVOIRISS
             AND AtCor.t_GroupID    = 60 -- Наблюдаемые исходные данные
             AND AtCor.t_Object     = LPAD(FIID, 10, '0')
             AND Attr.t_AttrID      = AtCor.t_AttrID
             AND Attr.t_ObjectType  = AtCor.t_ObjectType
             AND Attr.t_GroupID     = AtCor.t_GroupID;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN CategoryValue := chr(0);
         WHEN OTHERS THEN return -1;
      END;

      IF( CategoryValue <> chr(0) ) THEN
         return to_number(CategoryValue);
      ELSE
         return -1;
      END IF;

      RETURN -1;
   END; -- RSI_AvoirAttrObsBaseData

    -- Значение категории для ц/б "Уровень исходных данных иерархии СС МСФО 13"
   FUNCTION RSI_AvoirAttrHSDataLevel( FIID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      CategoryValue dobjattr_dbt.t_NumInList % TYPE;
   BEGIN
      BEGIN
          SELECT Attr.t_NumInList INTO CategoryValue
            FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
           WHERE AtCor.t_ObjectType = RSB_SECUR.OBJTYPE_AVOIRISS
             AND AtCor.t_GroupID    = 55 -- Уровень исходных данных иерархии СС МСФО 13
             AND AtCor.t_Object     = LPAD(FIID, 10, '0')
             AND Attr.t_AttrID      = AtCor.t_AttrID
             AND Attr.t_ObjectType  = AtCor.t_ObjectType
             AND Attr.t_GroupID     = AtCor.t_GroupID;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN CategoryValue := chr(0);
         WHEN OTHERS THEN return -1;
      END;

      IF( CategoryValue <> chr(0) ) THEN
         return to_number(CategoryValue);
      ELSE
         return -1;
      END IF;

      RETURN -1;
   END; -- RSI_AvoirAttrHSDataLevel

    -- Значение категории для сделки "Наблюдаемые исходные данные"
   FUNCTION RSI_DealAttrObsBaseData( OBJTYPE IN NUMBER, DealID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      CategoryValue dobjattr_dbt.t_NumInList % TYPE;
   BEGIN
      BEGIN
          SELECT Attr.t_NumInList INTO CategoryValue
            FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
           WHERE AtCor.t_ObjectType = OBJTYPE
             AND AtCor.t_GroupID    = 48 -- Наблюдаемые исходные данные
             AND AtCor.t_Object     = LPAD(DealID, 34, '0')
             AND Attr.t_AttrID      = AtCor.t_AttrID
             AND Attr.t_ObjectType  = AtCor.t_ObjectType
             AND Attr.t_GroupID     = AtCor.t_GroupID;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN CategoryValue := chr(0);
         WHEN OTHERS THEN return -1;
      END;

      IF( CategoryValue <> chr(0) ) THEN
         return to_number(CategoryValue);
      ELSE
         return -1;
      END IF;

      RETURN -1;
   END; -- RSI_DealAttrObsBaseData

    -- Получить значение примечания
   FUNCTION RSI_GetNoteTextNum( p_ObjectType IN NUMBER, p_ObjectID IN VARCHAR2, p_NoteKind IN NUMBER, p_Date IN DATE ) RETURN NUMBER DETERMINISTIC
   IS
   BEGIN
      BEGIN
         return TO_NUMBER(regexp_replace(rsb_struct.getString(rsi_rsb_kernel.GetNote(p_ObjectType, p_ObjectID, p_NoteKind, p_Date)), '[^0-9.]+', ''));
      EXCEPTION
         WHEN OTHERS THEN return -1;
      END;
   END; -- RSI_DealAttrObsBaseData

   ----------------------------------------------------------------------------------------------------------------------

   PROCEDURE RSI_CopyWRTSUMtoRAW( p_Sum IN DPMWRTSUM_DBT%ROWTYPE, pmwrtsum IN OUT RAW )
   IS
   BEGIN

     rsb_struct.readStruct('dpmwrtsum_dbt');

     pmwrtsum :=   rsb_struct.putLong( 'T_SUMID',            pmwrtsum, NVL(p_Sum.T_SUMID, 0)            );
     pmwrtsum :=   rsb_struct.putInt( 'T_DOCKIND',          pmwrtsum, NVL(p_Sum.T_DOCKIND, 0)          );
     pmwrtsum :=   rsb_struct.putLong( 'T_DOCID',            pmwrtsum, NVL(p_Sum.T_DOCID, 0)            );
     pmwrtsum :=   rsb_struct.putInt( 'T_PARTNUM',          pmwrtsum, NVL(p_Sum.T_PARTNUM, 0)          );
     pmwrtsum :=   rsb_struct.putLong( 'T_PARTY',            pmwrtsum, NVL(p_Sum.T_PARTY, 0)            );
     pmwrtsum :=   rsb_struct.putLong( 'T_CONTRACT',         pmwrtsum, NVL(p_Sum.T_CONTRACT, 0)         );
     pmwrtsum :=   rsb_struct.putLong( 'T_FIID',             pmwrtsum, NVL(p_Sum.T_FIID, 0)             );
     pmwrtsum :=   rsb_struct.putLong( 'T_GROUPID',          pmwrtsum, NVL(p_Sum.T_GROUPID, 0)          );
     pmwrtsum :=   rsb_struct.putInt( 'T_BUY_SALE',         pmwrtsum, NVL(p_Sum.T_BUY_SALE, 0)         );
     pmwrtsum :=   rsb_struct.putInt( 'T_KIND',             pmwrtsum, NVL(p_Sum.T_KIND, 0)             );
     pmwrtsum :=   rsb_struct.putDate( 'T_DATE',             pmwrtsum, NVL(p_Sum.T_DATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putTime( 'T_TIME',             pmwrtsum, NVL(p_Sum.T_TIME, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_AMOUNT',           pmwrtsum, NVL(p_Sum.T_AMOUNT, 0)           );
     pmwrtsum :=   rsb_struct.putMoney( 'T_SUM',              pmwrtsum, NVL(p_Sum.T_SUM, 0)              );
     pmwrtsum :=   rsb_struct.putLong( 'T_CURRENCY',         pmwrtsum, NVL(p_Sum.T_CURRENCY, 0)         );
     pmwrtsum :=   rsb_struct.putMoney( 'T_COST',             pmwrtsum, NVL(p_Sum.T_COST, 0)             );
     pmwrtsum :=   rsb_struct.putMoney( 'T_BALANCECOST',      pmwrtsum, NVL(p_Sum.T_BALANCECOST, 0)      );
     pmwrtsum :=   rsb_struct.putMoney( 'T_NKDAMOUNT',        pmwrtsum, NVL(p_Sum.T_NKDAMOUNT, 0)        );
     pmwrtsum :=   rsb_struct.putMoney( 'T_INTERESTINCOME',   pmwrtsum, NVL(p_Sum.T_INTERESTINCOME, 0)   );
     pmwrtsum :=   rsb_struct.putMoney( 'T_NOTCARRYINTEREST', pmwrtsum, NVL(p_Sum.T_NOTCARRYINTEREST, 0) );
     pmwrtsum :=   rsb_struct.putDate( 'T_INTERESTDATE',     pmwrtsum, NVL(p_Sum.T_INTERESTDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putDate( 'T_BEGDATE',          pmwrtsum, NVL(p_Sum.T_BEGDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_BEGDISCOUNT',      pmwrtsum, NVL(p_Sum.T_BEGDISCOUNT, 0)      );
     pmwrtsum :=   rsb_struct.putDate( 'T_OLDBEGDATE',       pmwrtsum, NVL(p_Sum.T_OLDBEGDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_OLDBEGDISCOUNT',   pmwrtsum, NVL(p_Sum.T_OLDBEGDISCOUNT, 0)      );
     pmwrtsum :=   rsb_struct.putDate( 'T_BEGBONUSDATE',     pmwrtsum, NVL(p_Sum.T_BEGBONUSDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_BEGBONUS',         pmwrtsum, NVL(p_Sum.T_BEGBONUS, 0)      );
     pmwrtsum :=   rsb_struct.putMoney( 'T_DISCOUNTINCOME',   pmwrtsum, NVL(p_Sum.T_DISCOUNTINCOME, 0)   );
     pmwrtsum :=   rsb_struct.putMoney( 'T_NOTCARRYDISCOUNT', pmwrtsum, NVL(p_Sum.T_NOTCARRYDISCOUNT, 0) );
     pmwrtsum :=   rsb_struct.putDate( 'T_DISCOUNTDATE',     pmwrtsum, NVL(p_Sum.T_DISCOUNTDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_BONUS',            pmwrtsum, NVL(p_Sum.T_BONUS, 0)      );
     pmwrtsum :=   rsb_struct.putMoney( 'T_OLDBONUS',         pmwrtsum, NVL(p_Sum.T_OLDBONUS, 0)      );
     pmwrtsum :=   rsb_struct.putDate( 'T_BONUSDATE',        pmwrtsum, NVL(p_Sum.T_BONUSDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_OUTLAY',           pmwrtsum, NVL(p_Sum.T_OUTLAY, 0)           );
     pmwrtsum :=   rsb_struct.putMoney( 'T_RESERVAMOUNT',     pmwrtsum, NVL(p_Sum.T_RESERVAMOUNT, 0)     );
     pmwrtsum :=   rsb_struct.putMoney( 'T_INCOMERESERV',     pmwrtsum, NVL(p_Sum.T_INCOMERESERV, 0)     );
     pmwrtsum :=   rsb_struct.putDate( 'T_RESERVDATE',       pmwrtsum, NVL(p_Sum.T_RESERVDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_OVERAMOUNT',       pmwrtsum, NVL(p_Sum.T_OVERAMOUNT, 0)       );
     pmwrtsum :=   rsb_struct.putDate( 'T_OVERDATE',         pmwrtsum, NVL(p_Sum.T_OVERDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putString( 'T_COUPON',           pmwrtsum, NVL(p_Sum.T_COUPON, chr(1))           );
     pmwrtsum :=   rsb_struct.putString( 'T_PARTLY',           pmwrtsum, NVL(p_Sum.T_PARTLY, chr(1))           );
     pmwrtsum :=   rsb_struct.putInt( 'T_DEPARTMENT',       pmwrtsum, NVL(p_Sum.T_DEPARTMENT, 0)       );
     pmwrtsum :=   rsb_struct.putLong( 'T_DEALID',           pmwrtsum, NVL(p_Sum.T_DEALID, 0)           );
     pmwrtsum :=   rsb_struct.putDate( 'T_DEALDATE',         pmwrtsum, NVL(p_Sum.T_DEALDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putString( 'T_DEALCODE',         pmwrtsum, NVL(p_Sum.T_DEALCODE, chr(1))         );
     pmwrtsum :=   rsb_struct.putInt( 'T_STATE',            pmwrtsum, NVL(p_Sum.T_STATE, 0)            );
     pmwrtsum :=   rsb_struct.putDate( 'T_ENTERDATE',        pmwrtsum, NVL(p_Sum.T_ENTERDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putDate( 'T_STATEDATE',        pmwrtsum, NVL(p_Sum.T_STATEDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putInt( 'T_INSTANCE',         pmwrtsum, NVL(p_Sum.T_INSTANCE, 0)         );
     pmwrtsum :=   rsb_struct.putDate( 'T_CHANGEDATE',       pmwrtsum, NVL(p_Sum.T_CHANGEDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putInt( 'T_ACTION',           pmwrtsum, NVL(p_Sum.T_ACTION, 0)           );
     pmwrtsum :=   rsb_struct.putLong( 'T_ID_OPERATION',     pmwrtsum, NVL(p_Sum.T_ID_OPERATION, 0)     );
     pmwrtsum :=   rsb_struct.putInt( 'T_ID_STEP',          pmwrtsum, NVL(p_Sum.T_ID_STEP, 0)          );
     pmwrtsum :=   rsb_struct.putChar( 'T_ISFREE',           pmwrtsum, NVL(p_Sum.T_ISFREE, chr(0))           );
     pmwrtsum :=   rsb_struct.putChar( 'T_TRUST',            pmwrtsum, NVL(p_Sum.T_TRUST, chr(0))            );
     pmwrtsum :=   rsb_struct.putLong( 'T_PARENT',           pmwrtsum, NVL(p_Sum.T_PARENT, 0)           );
     pmwrtsum :=   rsb_struct.putLong( 'T_SOURCE',           pmwrtsum, NVL(p_Sum.T_SOURCE, 0)           );
     pmwrtsum :=   rsb_struct.putDate(  'T_BegInterestDate'   ,  pmwrtsum, NVL(p_Sum.T_BegInterestDate, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putDate(  'T_BegDiscountDate'   ,  pmwrtsum, NVL(p_Sum.T_BegDiscountDate, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_DiscountCorr'     ,  pmwrtsum, NVL(p_Sum.T_DiscountCorr, 0)       );
     pmwrtsum :=   rsb_struct.putMoney( 'T_OldBegBonus'      ,  pmwrtsum, NVL(p_Sum.T_OldBegBonus,  0)       );
     pmwrtsum :=   rsb_struct.putDate(  'T_RecalcDate'        ,  pmwrtsum, NVL(p_Sum.T_RecalcDate, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putChar(  't_IsEdit'            ,  pmwrtsum, NVL(p_Sum.T_IsEdit, chr(0))           );
     pmwrtsum :=   rsb_struct.putMoney('T_NOTWRTBONUS', pmwrtsum, NVL(p_Sum.T_NOTWRTBONUS, 0));
     pmwrtsum :=   rsb_struct.putMoney(  'T_CostPFI',   pmwrtsum, NVL(p_Sum.T_CostPFI, 0));
     pmwrtsum :=   rsb_struct.putString( 'T_SortCode',  pmwrtsum, NVL(p_Sum.T_SortCode, chr(1))           );
     pmwrtsum :=   rsb_struct.putMoney(  'T_AmountBD',   pmwrtsum, NVL(p_Sum.T_AmountBD, 0));
     pmwrtsum :=   rsb_struct.putInt(    'T_Portfolio',  pmwrtsum, NVL(p_Sum.T_Portfolio, 0)          );
     pmwrtsum :=   rsb_struct.putMoney(  'T_BalanceCostBD', pmwrtsum, NVL(p_Sum.T_BalanceCostBD, 0));
     pmwrtsum :=   rsb_struct.putMoney(  'T_OverAmountBD',  pmwrtsum, NVL(p_Sum.T_OverAmountBD, 0));
     pmwrtsum :=   rsb_struct.putDate( 'T_ACTIVATEDATE',     pmwrtsum, NVL(p_Sum.T_ACTIVATEDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putTime( 'T_ACTIVATETIME',     pmwrtsum, NVL(p_Sum.T_ACTIVATETIME, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_BLOCKAMOUNT',     pmwrtsum, NVL(p_Sum.T_BLOCKAMOUNT, 0));
     pmwrtsum :=   rsb_struct.putMoney( 'T_BEGDEFDIFF',         pmwrtsum, NVL(p_Sum.T_BEGDEFDIFF, 0));
     pmwrtsum :=   rsb_struct.putMoney( 'T_ACCOUNTEDDEFDIFF',   pmwrtsum, NVL(p_Sum.T_ACCOUNTEDDEFDIFF, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_DEFDIFFDATE',        pmwrtsum, NVL(p_Sum.T_DEFDIFFDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_WRTOUTLAY',          pmwrtsum, NVL(p_Sum.T_WRTOUTLAY, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_WRTOUTLAYDATE',      pmwrtsum, NVL(p_Sum.T_WRTOUTLAYDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_VATOUTLAY',          pmwrtsum, NVL(p_Sum.T_VATOUTLAY, 0));
     pmwrtsum :=   rsb_struct.putMoney( 'T_WRTVATOUTLAY',       pmwrtsum, NVL(p_Sum.T_WRTVATOUTLAY, 0));
     pmwrtsum :=   rsb_struct.putDouble('T_EFFECTINTERESTRATE', pmwrtsum, NVL(p_Sum.T_EFFECTINTERESTRATE, 0));
     pmwrtsum :=   rsb_struct.putMoney( 'T_FAIRVALUE',          pmwrtsum, NVL(p_Sum.T_FAIRVALUE, 0));
     pmwrtsum :=   rsb_struct.putMoney( 'T_AMORTCOST',          pmwrtsum, NVL(p_Sum.T_AMORTCOST, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_AMORTCOSTDATE',      pmwrtsum, NVL(p_Sum.T_AMORTCOSTDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_CORRVALUE',          pmwrtsum, NVL(p_Sum.T_CORRVALUE, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_CORRDATE',           pmwrtsum, NVL(p_Sum.T_CORRDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_ACCBALANCECOST',     pmwrtsum, NVL(p_Sum.T_ACCBALANCECOST, 0));
     pmwrtsum :=   rsb_struct.putInt(   'T_ACCFI',              pmwrtsum, NVL(p_Sum.T_ACCFI,          -1));
     pmwrtsum :=   rsb_struct.putInt(   'T_AMORTCALCKIND',      pmwrtsum, NVL(p_Sum.T_AMORTCALCKIND,  0));
     pmwrtsum :=   rsb_struct.putMoney( 'T_ESTRESERVE',         pmwrtsum, NVL(p_Sum.T_ESTRESERVE,     0));
     pmwrtsum :=   rsb_struct.putDate(  'T_ESTRESERVEDATE',     pmwrtsum, NVL(p_Sum.T_ESTRESERVEDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_CORRINTTOEIR', pmwrtsum, NVL(p_Sum.T_CORRINTTOEIR, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_CORRINTTOEIRDATE', pmwrtsum, NVL(p_Sum.T_CORRINTTOEIRDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_CORRESTRESERVE',     pmwrtsum, NVL(p_Sum.T_CORRESTRESERVE, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_CORRESTRESERVEDATE', pmwrtsum, NVL(p_Sum.T_CORRESTRESERVEDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putDate(  'T_BEGDEFDIFFDATE', pmwrtsum, NVL(p_Sum.T_BEGDEFDIFFDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_ADDINCOMEOWN',       pmwrtsum, NVL(p_Sum.T_ADDINCOMEOWN, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_ADDINCOMEOWNDATE', pmwrtsum, NVL(p_Sum.T_ADDINCOMEOWNDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_HEDGCORR',       pmwrtsum, NVL(p_Sum.T_HEDGCORR, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_HEDGCORRDATE',   pmwrtsum, NVL(p_Sum.T_HEDGCORRDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
     pmwrtsum :=   rsb_struct.putMoney( 'T_AMORTHEDGCORR',       pmwrtsum, NVL(p_Sum.T_AMORTHEDGCORR, 0));
     pmwrtsum :=   rsb_struct.putDate(  'T_AMORTHEDGCORRDATE',   pmwrtsum, NVL(p_Sum.T_AMORTHEDGCORRDATE, TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) );
   END;

   PROCEDURE RSI_CopyRAWtoWRTSUM( pmwrtsum IN RAW, p_Sum OUT DPMWRTSUM_DBT%ROWTYPE )
   IS
   BEGIN
     rsb_struct.readStruct('dpmwrtsum_dbt');

     p_Sum.T_SUMID            :=   rsb_struct.getLong( 'T_SUMID',                  pmwrtsum );
     p_Sum.T_DOCKIND          :=    rsb_struct.getInt( 'T_DOCKIND',                pmwrtsum );
     p_Sum.T_DOCID            :=   rsb_struct.getLong( 'T_DOCID',                  pmwrtsum );
     p_Sum.T_PARTNUM          :=    rsb_struct.getInt( 'T_PARTNUM',                pmwrtsum );
     p_Sum.T_PARTY            :=   rsb_struct.getLong( 'T_PARTY',                  pmwrtsum );
     p_Sum.T_CONTRACT         :=   rsb_struct.getLong( 'T_CONTRACT',               pmwrtsum );
     p_Sum.T_FIID             :=   rsb_struct.getLong( 'T_FIID',                   pmwrtsum );
     p_Sum.T_PORTFOLIO        :=   rsb_struct.getLong( 'T_PORTFOLIO',              pmwrtsum );
     p_Sum.T_GROUPID          :=   rsb_struct.getLong( 'T_GROUPID',                pmwrtsum );
     p_Sum.T_BUY_SALE         :=    rsb_struct.getInt( 'T_BUY_SALE',               pmwrtsum );
     p_Sum.T_KIND             :=    rsb_struct.getInt( 'T_KIND',                   pmwrtsum );
     p_Sum.T_DATE             :=   rsb_struct.getDate( 'T_DATE',                   pmwrtsum );
     p_Sum.T_TIME             :=   rsb_struct.getTime( 'T_TIME',                   pmwrtsum );
     p_Sum.T_AMOUNT           :=  rsb_struct.getMoney( 'T_AMOUNT',                 pmwrtsum );
     p_Sum.T_AMOUNTBD         :=  rsb_struct.getMoney( 'T_AMOUNTBD',               pmwrtsum );
     p_Sum.T_SUM              :=  rsb_struct.getMoney( 'T_SUM',                    pmwrtsum );
     p_Sum.T_CURRENCY         :=   rsb_struct.getLong( 'T_CURRENCY',               pmwrtsum );
     p_Sum.T_COST             :=  rsb_struct.getMoney( 'T_COST',                   pmwrtsum );
     p_Sum.T_BALANCECOST      :=  rsb_struct.getMoney( 'T_BALANCECOST',            pmwrtsum );
     p_Sum.T_BALANCECOSTBD    :=  rsb_struct.getMoney( 'T_BALANCECOSTBD',          pmwrtsum );
     p_Sum.T_NKDAMOUNT        :=  rsb_struct.getMoney( 'T_NKDAMOUNT',              pmwrtsum );
     p_Sum.T_INTERESTINCOME   :=  rsb_struct.getMoney( 'T_INTERESTINCOME',         pmwrtsum );
     p_Sum.T_NOTCARRYINTEREST :=  rsb_struct.getMoney( 'T_NOTCARRYINTEREST',       pmwrtsum );
     p_Sum.T_INTERESTDATE     :=   rsb_struct.getDate( 'T_INTERESTDATE',           pmwrtsum );
     p_Sum.T_BEGDATE          :=   rsb_struct.getDate( 'T_BEGDATE',                pmwrtsum );
     p_Sum.T_BEGDISCOUNT      :=  rsb_struct.getMoney( 'T_BEGDISCOUNT',            pmwrtsum );
     p_Sum.T_OLDBEGDATE       :=   rsb_struct.getDate( 'T_OLDBEGDATE',             pmwrtsum );
     p_Sum.T_OLDBEGDISCOUNT   :=  rsb_struct.getMoney( 'T_OLDBEGDISCOUNT',         pmwrtsum );
     p_Sum.T_BEGBONUSDATE     :=   rsb_struct.getDate( 'T_BEGBONUSDATE',           pmwrtsum );
     p_Sum.T_BEGBONUS         :=  rsb_struct.getMoney( 'T_BEGBONUS',               pmwrtsum );
     p_Sum.T_DISCOUNTINCOME   :=  rsb_struct.getMoney( 'T_DISCOUNTINCOME',         pmwrtsum );
     p_Sum.T_NOTCARRYDISCOUNT :=  rsb_struct.getMoney( 'T_NOTCARRYDISCOUNT',       pmwrtsum );
     p_Sum.T_DISCOUNTDATE     :=   rsb_struct.getDate( 'T_DISCOUNTDATE',           pmwrtsum );
     p_Sum.T_BONUS            :=  rsb_struct.getMoney( 'T_BONUS',                  pmwrtsum );
     p_Sum.T_OLDBONUS         :=  rsb_struct.getMoney( 'T_OLDBONUS',               pmwrtsum );
     p_Sum.T_BONUSDATE        :=   rsb_struct.getDate( 'T_BONUSDATE',              pmwrtsum );
     p_Sum.T_OUTLAY           :=  rsb_struct.getMoney( 'T_OUTLAY',                 pmwrtsum );
     p_Sum.T_RESERVAMOUNT     :=  rsb_struct.getMoney( 'T_RESERVAMOUNT',           pmwrtsum );
     p_Sum.T_INCOMERESERV     :=  rsb_struct.getMoney( 'T_INCOMERESERV',           pmwrtsum );
     p_Sum.T_RESERVDATE       :=   rsb_struct.getDate( 'T_RESERVDATE',             pmwrtsum );
     p_Sum.T_OVERAMOUNT       :=  rsb_struct.getMoney( 'T_OVERAMOUNT',             pmwrtsum );
     p_Sum.T_OVERAMOUNTBD     :=  rsb_struct.getMoney( 'T_OVERAMOUNTBD',           pmwrtsum );
     p_Sum.T_OVERDATE         :=   rsb_struct.getDate( 'T_OVERDATE',               pmwrtsum );
     p_Sum.T_COUPON           := rsb_struct.getString( 'T_COUPON',                 pmwrtsum );
     p_Sum.T_PARTLY           := rsb_struct.getString( 'T_PARTLY',                 pmwrtsum );
     p_Sum.T_DEPARTMENT       :=    rsb_struct.getInt( 'T_DEPARTMENT',             pmwrtsum );
     p_Sum.T_DEALID           :=   rsb_struct.getLong( 'T_DEALID',                 pmwrtsum );
     p_Sum.T_DEALDATE         :=   rsb_struct.getDate( 'T_DEALDATE',               pmwrtsum );
     p_Sum.T_DEALCODE         := rsb_struct.getString( 'T_DEALCODE',               pmwrtsum );
     p_Sum.T_STATE            :=    rsb_struct.getInt( 'T_STATE',                  pmwrtsum );
     p_Sum.T_ENTERDATE        :=   rsb_struct.getDate( 'T_ENTERDATE',              pmwrtsum );
     p_Sum.T_STATEDATE        :=   rsb_struct.getDate( 'T_STATEDATE',              pmwrtsum );
     p_Sum.T_INSTANCE         :=    rsb_struct.getInt( 'T_INSTANCE',               pmwrtsum );
     p_Sum.T_CHANGEDATE       :=   rsb_struct.getDate( 'T_CHANGEDATE',             pmwrtsum );
     p_Sum.T_ACTION           :=    rsb_struct.getInt( 'T_ACTION',                 pmwrtsum );
     p_Sum.T_ID_OPERATION     :=   rsb_struct.getLong( 'T_ID_OPERATION',           pmwrtsum );
     p_Sum.T_ID_STEP          :=    rsb_struct.getInt( 'T_ID_STEP',                pmwrtsum );
     p_Sum.T_ISFREE           :=   rsb_struct.getChar( 'T_ISFREE',                 pmwrtsum );
     p_Sum.T_TRUST            :=   rsb_struct.getChar( 'T_TRUST',                  pmwrtsum );
     p_Sum.T_PARENT           :=   rsb_struct.getLong( 'T_PARENT',                 pmwrtsum );
     p_Sum.T_SOURCE           :=   rsb_struct.getLong( 'T_SOURCE',                 pmwrtsum );
     p_Sum.T_BegInterestDate  :=  rsb_struct.getDate( 'T_BegInterestDate',         pmwrtsum );
     p_Sum.T_BegDiscountDate  :=  rsb_struct.getDate( 'T_BegDiscountDate',         pmwrtsum );
     p_Sum.T_DiscountCorr     :=  rsb_struct.getMoney( 'T_DiscountCorr',           pmwrtsum );
     p_Sum.T_OldBegBonus      :=  rsb_struct.getMoney( 'T_OldBegBonus',            pmwrtsum );
     p_Sum.T_RecalcDate       :=  rsb_struct.getDate( 'T_RecalcDate',              pmwrtsum );
     p_Sum.t_IsEdit           :=  rsb_struct.getChar( 't_IsEdit',                  pmwrtsum );
     p_Sum.T_NOTWRTBONUS      :=  rsb_struct.getMoney( 'T_NOTWRTBONUS',            pmwrtsum );
     p_Sum.T_CostPFI          :=  rsb_struct.getMoney( 'T_CostPFI',                pmwrtsum );
     p_Sum.T_SortCode         :=  rsb_struct.getString( 'T_SortCode',              pmwrtsum );
     p_Sum.T_ACTIVATEDATE     :=  rsb_struct.getDate( 'T_ACTIVATEDATE',            pmwrtsum );
     p_Sum.T_ACTIVATETIME     :=  rsb_struct.getTime( 'T_ACTIVATETIME',            pmwrtsum );
     p_Sum.T_BLOCKAMOUNT      :=  rsb_struct.getMoney( 'T_BLOCKAMOUNT',            pmwrtsum);
     p_Sum.T_BEGDEFDIFF          :=  rsb_struct.getMoney( 'T_BEGDEFDIFF',          pmwrtsum);
     p_Sum.T_ACCOUNTEDDEFDIFF    :=  rsb_struct.getMoney( 'T_ACCOUNTEDDEFDIFF',    pmwrtsum);
     p_Sum.T_DEFDIFFDATE         :=  rsb_struct.getDate( 'T_DEFDIFFDATE',          pmwrtsum );
     p_Sum.T_WRTOUTLAY           :=  rsb_struct.getMoney( 'T_WRTOUTLAY',           pmwrtsum);
     p_Sum.T_WRTOUTLAYDATE       :=  rsb_struct.getDate( 'T_WRTOUTLAYDATE',        pmwrtsum );
     p_Sum.T_VATOUTLAY           :=  rsb_struct.getMoney( 'T_VATOUTLAY',           pmwrtsum);
     p_Sum.T_WRTVATOUTLAY        :=  rsb_struct.getMoney( 'T_WRTVATOUTLAY',        pmwrtsum);
     p_Sum.T_EFFECTINTERESTRATE  :=  rsb_struct.getDouble( 'T_EFFECTINTERESTRATE', pmwrtsum);
     p_Sum.T_FAIRVALUE           :=  rsb_struct.getMoney( 'T_FAIRVALUE',           pmwrtsum);
     p_Sum.T_AMORTCOST           :=  rsb_struct.getMoney( 'T_AMORTCOST',           pmwrtsum);
     p_Sum.T_AMORTCOSTDATE       :=  rsb_struct.getDate( 'T_AMORTCOSTDATE',        pmwrtsum );
     p_Sum.T_CORRVALUE           :=  rsb_struct.getMoney( 'T_CORRVALUE',           pmwrtsum);
     p_Sum.T_CORRDATE            :=  rsb_struct.getDate( 'T_CORRDATE',             pmwrtsum );
     p_Sum.T_ACCBALANCECOST      :=  rsb_struct.getMoney( 'T_ACCBALANCECOST',      pmwrtsum);
     p_Sum.T_ACCFI               :=  rsb_struct.getInt(   'T_ACCFI',               pmwrtsum );
     p_Sum.T_AMORTCALCKIND       :=  rsb_struct.getInt(   'T_AMORTCALCKIND',       pmwrtsum );
     p_Sum.T_ESTRESERVE          :=  rsb_struct.getMoney( 'T_ESTRESERVE',          pmwrtsum);
     p_Sum.T_ESTRESERVEDATE      :=  rsb_struct.getDate( 'T_ESTRESERVEDATE',       pmwrtsum );
     p_Sum.T_CORRINTTOEIR        := rsb_struct.getMoney( 'T_CORRINTTOEIR',         pmwrtsum);
     p_Sum.T_CORRINTTOEIRDATE    := rsb_struct.getDate( 'T_CORRINTTOEIRDATE',      pmwrtsum );
     p_Sum.T_CORRESTRESERVE      :=  rsb_struct.getMoney( 'T_CORRESTRESERVE',      pmwrtsum);
     p_Sum.T_CORRESTRESERVEDATE  :=  rsb_struct.getDate( 'T_CORRESTRESERVEDATE',   pmwrtsum );
     p_Sum.T_BEGDEFDIFFDATE      :=  rsb_struct.getDate( 'T_BEGDEFDIFFDATE',       pmwrtsum );
     p_Sum.T_ADDINCOMEOWN        :=  rsb_struct.getMoney( 'T_ADDINCOMEOWN',        pmwrtsum);
     p_Sum.T_ADDINCOMEOWNDATE    :=  rsb_struct.getDate( 'T_ADDINCOMEOWNDATE',     pmwrtsum );
     p_Sum.T_HEDGCORR            :=  rsb_struct.getMoney( 'T_HEDGCORR',            pmwrtsum);
     p_Sum.T_HEDGCORRDATE        :=  rsb_struct.getDate( 'T_HEDGCORRDATE',         pmwrtsum );
     p_Sum.T_AMORTHEDGCORR       :=  rsb_struct.getMoney( 'T_AMORTHEDGCORR',       pmwrtsum);
     p_Sum.T_AMORTHEDGCORRDATE   :=  rsb_struct.getDate( 'T_AMORTHEDGCORRDATE',    pmwrtsum );
   END;
   /**
    * Заполнение дефолтными значениями незаполненных(null-х) полей в переданной структуре истории лота
    */
   PROCEDURE RSI_InsDfltIntoWRTBC( p_Sum IN OUT DPMWRTBC_DBT%ROWTYPE )
   IS
   BEGIN
       p_Sum.T_BCID               :=   NVL(p_Sum.T_BCID,0);
       p_Sum.T_SUMID              :=   NVL(p_Sum.T_SUMID,0);
       p_Sum.T_PORTFOLIO          :=   NVL(p_Sum.T_PORTFOLIO,-1);
       p_Sum.T_FIID               :=   NVL(p_Sum.T_FIID,0);
       p_Sum.T_GROUPID            :=   NVL(p_Sum.T_GROUPID,-1);
       p_Sum.T_DATE               :=   NVL(p_Sum.T_DATE,UnknownDate);
       p_Sum.T_TIME               :=   NVL(p_Sum.T_TIME,UnknownDate);
       p_Sum.T_AMOUNT             :=   NVL(p_Sum.T_AMOUNT,0);
       p_Sum.T_AMOUNTBD           :=   NVL(p_Sum.T_AMOUNTBD,0);
       p_Sum.T_SUM                :=   NVL(p_Sum.T_SUM,0);
       p_Sum.T_CURRENCY           :=   NVL(p_Sum.T_CURRENCY,0);
       p_Sum.T_COST               :=   NVL(p_Sum.T_COST,0);
       p_Sum.T_BALANCECOST        :=   NVL(p_Sum.T_BALANCECOST,0);
       p_Sum.T_BALANCECOSTBD      :=   NVL(p_Sum.T_BALANCECOSTBD,0);
       p_Sum.T_NKDAMOUNT          :=   NVL(p_Sum.T_NKDAMOUNT,0);
       p_Sum.T_INTERESTINCOME     :=   NVL(p_Sum.T_INTERESTINCOME,0);
       p_Sum.T_NOTCARRYINTEREST   :=   NVL(p_Sum.T_NOTCARRYINTEREST,0);
       p_Sum.T_INTERESTDATE       :=   NVL(p_Sum.T_INTERESTDATE,UnknownDate);
       p_Sum.T_BEGDATE            :=   NVL(p_Sum.T_BEGDATE,UnknownDate);
       p_Sum.T_BEGDISCOUNT        :=   NVL(p_Sum.T_BEGDISCOUNT,0);
       p_Sum.T_OLDBEGDATE         :=   NVL(p_Sum.T_OLDBEGDATE,UnknownDate);
       p_Sum.T_OLDBEGDISCOUNT     :=   NVL(p_Sum.T_OLDBEGDISCOUNT,0);
       p_Sum.T_BEGBONUSDATE       :=   NVL(p_Sum.T_BEGBONUSDATE,UnknownDate);
       p_Sum.T_BEGBONUS           :=   NVL(p_Sum.T_BEGBONUS,0);
       p_Sum.T_DISCOUNTINCOME     :=   NVL(p_Sum.T_DISCOUNTINCOME,0);
       p_Sum.T_NOTCARRYDISCOUNT   :=   NVL(p_Sum.T_NOTCARRYDISCOUNT,0);
       p_Sum.T_DISCOUNTDATE       :=   NVL(p_Sum.T_DISCOUNTDATE,UnknownDate);
       p_Sum.T_BONUS              :=   NVL(p_Sum.T_BONUS,0);
       p_Sum.T_OLDBONUS           :=   NVL(p_Sum.T_OLDBONUS,0);
       p_Sum.T_BONUSDATE          :=   NVL(p_Sum.T_BONUSDATE,UnknownDate);
       p_Sum.T_OUTLAY             :=   NVL(p_Sum.T_OUTLAY,0);
       p_Sum.T_RESERVAMOUNT       :=   NVL(p_Sum.T_RESERVAMOUNT,0);
       p_Sum.T_RESERVDATE         :=   NVL(p_Sum.T_RESERVDATE,UnknownDate);
       p_Sum.T_OVERAMOUNT         :=   NVL(p_Sum.T_OVERAMOUNT,0);
       p_Sum.T_OVERAMOUNTBD       :=   NVL(p_Sum.T_OVERAMOUNTBD,0);
       p_Sum.T_OVERDATE           :=   NVL(p_Sum.T_OVERDATE,UnknownDate);
       p_Sum.T_STATE              :=   NVL(p_Sum.T_STATE,0);
       p_Sum.T_STATEDATE          :=   NVL(p_Sum.T_STATEDATE,UnknownDate);
       p_Sum.T_INSTANCE           :=   NVL(p_Sum.T_INSTANCE,0);
       p_Sum.T_CHANGEDATE         :=   NVL(p_Sum.T_CHANGEDATE,UnknownDate);
       p_Sum.T_ACTION             :=   NVL(p_Sum.T_ACTION,0);
       p_Sum.T_ID_OPERATION       :=   NVL(p_Sum.T_ID_OPERATION,0);
       p_Sum.T_ID_STEP            :=   NVL(p_Sum.T_ID_STEP,0);
       p_Sum.T_LNKREF             :=   NVL(p_Sum.T_LNKREF,0);
       p_Sum.T_INCOMERESERV       :=   NVL(p_Sum.T_INCOMERESERV,0);
       p_Sum.T_BegInterestDate    :=   NVL(p_Sum.T_BegInterestDate,UnknownDate);
       p_Sum.T_BegDiscountDate    :=   NVL(p_Sum.T_BegDiscountDate,UnknownDate);
       p_Sum.T_DiscountCorr       :=   NVL(p_Sum.T_DiscountCorr,0);
       p_Sum.T_OldBegBonus        :=   NVL(p_Sum.T_OldBegBonus,0);
       p_Sum.T_RecalcDate         :=   NVL(p_Sum.T_RecalcDate,UnknownDate);
       p_Sum.T_IsEdit             :=   NVL(p_Sum.T_IsEdit,CHR(0));
       p_Sum.T_NOTWRTBONUS        :=   NVL(p_Sum.T_NOTWRTBONUS,0);
       p_Sum.T_CostPFI            :=   NVL(p_Sum.T_CostPFI,0);
       p_Sum.T_ACTIVATEDATE       :=   NVL(p_Sum.T_ACTIVATEDATE,UnknownDate);
       p_Sum.T_ACTIVATETIME       :=   NVL(p_Sum.T_ACTIVATETIME,UnknownDate);
       p_Sum.T_BLOCKAMOUNT        :=   NVL(p_Sum.T_BLOCKAMOUNT,0);
       p_Sum.T_BEGDEFDIFF         :=   NVL(p_Sum.T_BEGDEFDIFF,0);
       p_Sum.T_ACCOUNTEDDEFDIFF   :=   NVL(p_Sum.T_ACCOUNTEDDEFDIFF,0);
       p_Sum.T_DEFDIFFDATE        :=   NVL(p_Sum.T_DEFDIFFDATE,UnknownDate);
       p_Sum.T_WRTOUTLAY          :=   NVL(p_Sum.T_WRTOUTLAY,0);
       p_Sum.T_WRTOUTLAYDATE      :=   NVL(p_Sum.T_WRTOUTLAYDATE,UnknownDate);
       p_Sum.T_VATOUTLAY          :=   NVL(p_Sum.T_VATOUTLAY,0);
       p_Sum.T_WRTVATOUTLAY       :=   NVL(p_Sum.T_WRTVATOUTLAY,0);
       p_Sum.T_EFFECTINTERESTRATE :=   NVL(p_Sum.T_EFFECTINTERESTRATE,0);
       p_Sum.T_FAIRVALUE          :=   NVL(p_Sum.T_FAIRVALUE,0);
       p_Sum.T_AMORTCOST          :=   NVL(p_Sum.T_AMORTCOST,0);
       p_Sum.T_CORRVALUE          :=   NVL(p_Sum.T_CORRVALUE,0);
       p_Sum.T_CORRDATE           :=   NVL(p_Sum.T_CORRDATE,UnknownDate);
       p_Sum.T_ACCBALANCECOST     :=   NVL(p_Sum.T_ACCBALANCECOST,0);
       p_Sum.T_ACCFI              :=   NVL(p_Sum.T_ACCFI,-1);
       p_Sum.T_AMORTCALCKIND      :=   NVL(p_Sum.T_AMORTCALCKIND,0);
       p_Sum.T_ESTRESERVE         :=   NVL(p_Sum.T_ESTRESERVE,0);
       p_Sum.T_ESTRESERVEDATE     :=   NVL(p_Sum.T_ESTRESERVEDATE,UnknownDate);
       p_Sum.T_CORRINTTOEIR       :=   NVL(p_Sum.T_CORRINTTOEIR,0);
       p_Sum.T_CORRINTTOEIRDATE   :=   NVL(p_Sum.T_CORRINTTOEIRDATE,UnknownDate);
       p_Sum.T_CORRESTRESERVE     :=   NVL(p_Sum.T_CORRESTRESERVE,0);
       p_Sum.T_CORRESTRESERVEDATE :=   NVL(p_Sum.T_CORRESTRESERVEDATE,UnknownDate);
       p_Sum.T_BEGDEFDIFFDATE     :=   NVL(p_Sum.T_BEGDEFDIFFDATE,UnknownDate);
       p_Sum.T_ADDINCOMEOWN       :=   NVL(p_Sum.T_ADDINCOMEOWN,0);
       p_Sum.T_ADDINCOMEOWNDATE   :=   NVL(p_Sum.T_ADDINCOMEOWNDATE,UnknownDate);
       p_Sum.T_HEDGCORR           :=   NVL(p_Sum.T_HEDGCORR,0);
       p_Sum.T_HEDGCORRDATE       :=   NVL(p_Sum.T_HEDGCORRDATE,UnknownDate);
       p_Sum.T_AMORTHEDGCORR      :=   NVL(p_Sum.T_AMORTHEDGCORR,0);
       p_Sum.T_AMORTHEDGCORRDATE  :=   NVL(p_Sum.T_AMORTHEDGCORRDATE,UnknownDate);
   END;

   /**
    * Заполнение дефолтными значениями незаполненных(null-х) полей в переданной структуре лота
    */
   PROCEDURE RSI_InsDfltIntoWRTSUM( p_Sum IN OUT DPMWRTSUM_DBT%ROWTYPE )
   IS
   BEGIN
     p_Sum.T_SUMID              :=   NVL(p_Sum.T_SUMID,0);
     p_Sum.T_DOCKIND            :=   NVL(p_Sum.T_DOCKIND,0);
     p_Sum.T_DOCID              :=   NVL(p_Sum.T_DOCID,0);
     p_Sum.T_PARTNUM            :=   NVL(p_Sum.T_PARTNUM,0);
     p_Sum.T_PARTY              :=   NVL(p_Sum.T_PARTY,-1);
     p_Sum.T_CONTRACT           :=   NVL(p_Sum.T_CONTRACT,0);
     p_Sum.T_PORTFOLIO          :=   NVL(p_Sum.T_PORTFOLIO,-1);
     p_Sum.T_FIID               :=   NVL(p_Sum.T_FIID,0);
     p_Sum.T_GROUPID            :=   NVL(p_Sum.T_GROUPID,-1);
     p_Sum.T_BUY_SALE           :=   NVL(p_Sum.T_BUY_SALE,0);
     p_Sum.T_KIND               :=   NVL(p_Sum.T_KIND,0);
     p_Sum.T_DATE               :=   NVL(p_Sum.T_DATE,UnknownDate);
     p_Sum.T_TIME               :=   NVL(p_Sum.T_TIME,UnknownDate);
     p_Sum.T_AMOUNT             :=   NVL(p_Sum.T_AMOUNT,0);
     p_Sum.T_AMOUNTBD           :=   NVL(p_Sum.T_AMOUNTBD,0);
     p_Sum.T_SUM                :=   NVL(p_Sum.T_SUM,0);
     p_Sum.T_CURRENCY           :=   NVL(p_Sum.T_CURRENCY,0);
     p_Sum.T_COST               :=   NVL(p_Sum.T_COST,0);
     p_Sum.T_BALANCECOST        :=   NVL(p_Sum.T_BALANCECOST,0);
     p_Sum.T_BALANCECOSTBD      :=   NVL(p_Sum.T_BALANCECOSTBD,0);
     p_Sum.T_NKDAMOUNT          :=   NVL(p_Sum.T_NKDAMOUNT,0);
     p_Sum.T_INTERESTINCOME     :=   NVL(p_Sum.T_INTERESTINCOME,0);
     p_Sum.T_NOTCARRYINTEREST   :=   NVL(p_Sum.T_NOTCARRYINTEREST,0);
     p_Sum.T_INTERESTDATE       :=   NVL(p_Sum.T_INTERESTDATE,UnknownDate);
     p_Sum.T_BEGDATE            :=   NVL(p_Sum.T_BEGDATE,UnknownDate);
     p_Sum.T_BEGDISCOUNT        :=   NVL(p_Sum.T_BEGDISCOUNT,0);
     p_Sum.T_OLDBEGDATE         :=   NVL(p_Sum.T_OLDBEGDATE,UnknownDate);
     p_Sum.T_OLDBEGDISCOUNT     :=   NVL(p_Sum.T_OLDBEGDISCOUNT,0);
     p_Sum.T_BEGBONUSDATE       :=   NVL(p_Sum.T_BEGBONUSDATE,UnknownDate);
     p_Sum.T_BEGBONUS           :=   NVL(p_Sum.T_BEGBONUS,0);
     p_Sum.T_DISCOUNTINCOME     :=   NVL(p_Sum.T_DISCOUNTINCOME,0);
     p_Sum.T_NOTCARRYDISCOUNT   :=   NVL(p_Sum.T_NOTCARRYDISCOUNT,0);
     p_Sum.T_DISCOUNTDATE       :=   NVL(p_Sum.T_DISCOUNTDATE,UnknownDate);
     p_Sum.T_BONUS              :=   NVL(p_Sum.T_BONUS,0);
     p_Sum.T_OLDBONUS           :=   NVL(p_Sum.T_OLDBONUS,0);
     p_Sum.T_BONUSDATE          :=   NVL(p_Sum.T_BONUSDATE,UnknownDate);
     p_Sum.T_OUTLAY             :=   NVL(p_Sum.T_OUTLAY,0);
     p_Sum.T_RESERVAMOUNT       :=   NVL(p_Sum.T_RESERVAMOUNT,0);
     p_Sum.T_RESERVDATE         :=   NVL(p_Sum.T_RESERVDATE,UnknownDate);
     p_Sum.T_OVERAMOUNT         :=   NVL(p_Sum.T_OVERAMOUNT,0);
     p_Sum.T_OVERAMOUNTBD       :=   NVL(p_Sum.T_OVERAMOUNTBD,0);
     p_Sum.T_OVERDATE           :=   NVL(p_Sum.T_OVERDATE,UnknownDate);
     p_Sum.T_COUPON             :=   NVL(p_Sum.T_COUPON,CHR(1));
     p_Sum.T_PARTLY             :=   NVL(p_Sum.T_PARTLY,CHR(1));
     p_Sum.T_DEPARTMENT         :=   NVL(p_Sum.T_DEPARTMENT,0);
     p_Sum.T_DEALID             :=   NVL(p_Sum.T_DEALID,0);
     p_Sum.T_DEALDATE           :=   NVL(p_Sum.T_DEALDATE,UnknownDate);
     p_Sum.T_DEALCODE           :=   NVL(p_Sum.T_DEALCODE,CHR(1));
     p_Sum.T_STATE              :=   NVL(p_Sum.T_STATE,0);
     p_Sum.T_ENTERDATE          :=   NVL(p_Sum.T_ENTERDATE,UnknownDate);
     p_Sum.T_STATEDATE          :=   NVL(p_Sum.T_STATEDATE,UnknownDate);
     p_Sum.T_INSTANCE           :=   NVL(p_Sum.T_INSTANCE,0);
     p_Sum.T_CHANGEDATE         :=   NVL(p_Sum.T_CHANGEDATE,UnknownDate);
     p_Sum.T_ACTION             :=   NVL(p_Sum.T_ACTION,0);
     p_Sum.T_ID_OPERATION       :=   NVL(p_Sum.T_ID_OPERATION,0);
     p_Sum.T_ID_STEP            :=   NVL(p_Sum.T_ID_STEP,0);
     p_Sum.T_ISFREE             :=   NVL(p_Sum.T_ISFREE,CHR(0));
     p_Sum.T_TRUST              :=   NVL(p_Sum.T_TRUST,CHR(0));
     p_Sum.T_PARENT             :=   NVL(p_Sum.T_PARENT,0);
     p_Sum.T_SOURCE             :=   NVL(p_Sum.T_SOURCE,0);
     p_Sum.T_INCOMERESERV       :=   NVL(p_Sum.T_INCOMERESERV,0);
     p_Sum.T_BegInterestDate    :=   NVL(p_Sum.T_BegInterestDate,UnknownDate);
     p_Sum.T_BegDiscountDate    :=   NVL(p_Sum.T_BegDiscountDate,UnknownDate);
     p_Sum.T_DiscountCorr       :=   NVL(p_Sum.T_DiscountCorr,0);
     p_Sum.T_OldBegBonus        :=   NVL(p_Sum.T_OldBegBonus,0);
     p_Sum.T_RecalcDate         :=   NVL(p_Sum.T_RecalcDate,UnknownDate);
     p_Sum.T_IsEdit             :=   NVL(p_Sum.T_IsEdit,CHR(0));
     p_Sum.T_NOTWRTBONUS        :=   NVL(p_Sum.T_NOTWRTBONUS,0);
     p_Sum.T_COSTPFI            :=   NVL(p_Sum.T_COSTPFI,0);
     p_Sum.T_SortCode           :=   NVL(p_Sum.T_SortCode,CHR(1));
     p_Sum.T_ACTIVATEDATE       :=   NVL(p_Sum.T_ACTIVATEDATE,UnknownDate);
     p_Sum.T_ACTIVATETIME       :=   NVL(p_Sum.T_ACTIVATETIME,UnknownDate);
     p_Sum.T_BLOCKAMOUNT        :=   NVL(p_Sum.T_BLOCKAMOUNT,0);
     p_Sum.T_BEGDEFDIFF         :=   NVL(p_Sum.T_BEGDEFDIFF,0);
     p_Sum.T_ACCOUNTEDDEFDIFF   :=   NVL(p_Sum.T_ACCOUNTEDDEFDIFF,0);
     p_Sum.T_DEFDIFFDATE        :=   NVL(p_Sum.T_DEFDIFFDATE,UnknownDate);
     p_Sum.T_WRTOUTLAY          :=   NVL(p_Sum.T_WRTOUTLAY,0);
     p_Sum.T_WRTOUTLAYDATE      :=   NVL(p_Sum.T_WRTOUTLAYDATE,UnknownDate);
     p_Sum.T_VATOUTLAY          :=   NVL(p_Sum.T_VATOUTLAY,0);
     p_Sum.T_WRTVATOUTLAY       :=   NVL(p_Sum.T_WRTVATOUTLAY,0);
     p_Sum.T_EFFECTINTERESTRATE :=   NVL(p_Sum.T_EFFECTINTERESTRATE,0);
     p_Sum.T_FAIRVALUE          :=   NVL(p_Sum.T_FAIRVALUE,0);
     p_Sum.T_AMORTCOST          :=   NVL(p_Sum.T_AMORTCOST,0);
     p_Sum.T_AMORTCOSTDATE      :=   NVL(p_Sum.T_AMORTCOSTDATE,UnknownDate);
     p_Sum.T_CORRVALUE          :=   NVL(p_Sum.T_CORRVALUE,0);
     p_Sum.T_CORRDATE           :=   NVL(p_Sum.T_CORRDATE,UnknownDate);
     p_Sum.T_ACCBALANCECOST     :=   NVL(p_Sum.T_ACCBALANCECOST,0);
     p_Sum.T_ACCFI              :=   NVL(p_Sum.T_ACCFI,-1);
     p_Sum.T_AMORTCALCKIND      :=   NVL(p_Sum.T_AMORTCALCKIND,0);
     p_Sum.T_ESTRESERVE         :=   NVL(p_Sum.T_ESTRESERVE,0);
     p_Sum.T_ESTRESERVEDATE     :=   NVL(p_Sum.T_ESTRESERVEDATE,UnknownDate);
     p_Sum.T_CORRINTTOEIR       :=   NVL(p_Sum.T_CORRINTTOEIR,0);
     p_Sum.T_CORRINTTOEIRDATE   :=   NVL(p_Sum.T_CORRINTTOEIRDATE,UnknownDate);
     p_Sum.T_CORRESTRESERVE     :=   NVL(p_Sum.T_CORRESTRESERVE,0);
     p_Sum.T_CORRESTRESERVEDATE :=   NVL(p_Sum.T_CORRESTRESERVEDATE,UnknownDate);
     p_Sum.T_BEGDEFDIFFDATE     :=   NVL(p_Sum.T_BEGDEFDIFFDATE,UnknownDate);
     p_Sum.T_ADDINCOMEOWN       :=   NVL(p_Sum.T_ADDINCOMEOWN,0);
     p_Sum.T_ADDINCOMEOWNDATE   :=   NVL(p_Sum.T_ADDINCOMEOWNDATE,UnknownDate);
     p_Sum.T_HEDGCORR           :=   NVL(p_Sum.T_HEDGCORR,0);
     p_Sum.T_HEDGCORRDATE       :=   NVL(p_Sum.T_HEDGCORRDATE,UnknownDate);
     p_Sum.T_AMORTHEDGCORR      :=   NVL(p_Sum.T_AMORTHEDGCORR,0);
     p_Sum.T_AMORTHEDGCORRDATE  :=   NVL(p_Sum.T_AMORTHEDGCORRDATE,UnknownDate);
   END;

   /**
    * Заполнение дефолтными значениями незаполненных(null-х) полей в переданной структуре лота TMP
    */
   PROCEDURE RSI_InsDfltIntoWRTSUM_TMP( p_Sum IN OUT DPMWRTSUM_TMP%ROWTYPE )
   IS
   BEGIN
     p_Sum.T_SUMID              :=   NVL(p_Sum.T_SUMID,0);
     p_Sum.T_KIND               :=   NVL(p_Sum.T_KIND,0);
     p_Sum.T_AMOUNT             :=   NVL(p_Sum.T_AMOUNT,0);
     p_Sum.T_COST               :=   NVL(p_Sum.T_COST,0);
     p_Sum.T_BALANCECOST        :=   NVL(p_Sum.T_BALANCECOST,0);
     p_Sum.T_INTERESTADD        :=   NVL(p_Sum.T_INTERESTADD,0);
     p_Sum.T_BONUSADD           :=   NVL(p_Sum.T_BONUSADD,0);
     p_Sum.T_DISCOUNTADD        :=   NVL(p_Sum.T_DISCOUNTADD,0);
     p_Sum.T_INTERESTINCOME     :=   NVL(p_Sum.T_INTERESTINCOME,0);
     p_Sum.T_NOTCARRYINTEREST   :=   NVL(p_Sum.T_NOTCARRYINTEREST,0);
     p_Sum.T_INTERESTDATE       :=   NVL(p_Sum.T_INTERESTDATE,UnknownDate);
     p_Sum.T_BEGDISCOUNTDATE    :=   NVL(p_Sum.T_BEGDISCOUNTDATE,UnknownDate);
     p_Sum.T_BEGBONUSDATE       :=   NVL(p_Sum.T_BEGBONUSDATE,UnknownDate);
     p_Sum.T_DISCOUNTINCOME     :=   NVL(p_Sum.T_DISCOUNTINCOME,0);
     p_Sum.T_NOTCARRYDISCOUNT   :=   NVL(p_Sum.T_NOTCARRYDISCOUNT,0);
     p_Sum.T_DISCOUNTDATE       :=   NVL(p_Sum.T_DISCOUNTDATE,UnknownDate);
     p_Sum.T_BONUS              :=   NVL(p_Sum.T_BONUS,0);
     p_Sum.T_BONUSDATE          :=   NVL(p_Sum.T_BONUSDATE,UnknownDate);
     p_Sum.T_NOTWRTBONUS        :=   NVL(p_Sum.T_NOTWRTBONUS,0);
     p_Sum.T_DEFDIFFADD         :=   NVL(p_Sum.T_DEFDIFFADD,0);
     p_Sum.T_ACCOUNTEDDEFDIFF   :=   NVL(p_Sum.T_ACCOUNTEDDEFDIFF,0);
     p_Sum.T_DEFDIFFDATE        :=   NVL(p_Sum.T_DEFDIFFDATE,UnknownDate);
     p_Sum.T_WRTOUTLAYADD       :=   NVL(p_Sum.T_WRTOUTLAYADD,0);
     p_Sum.T_WRTOUTLAY          :=   NVL(p_Sum.T_WRTOUTLAY,0);
     p_Sum.T_WRTOUTLAYDATE      :=   NVL(p_Sum.T_WRTOUTLAYDATE,UnknownDate);
     p_Sum.T_VATOUTLAYADD       :=   NVL(p_Sum.T_VATOUTLAYADD,0);
     p_Sum.T_WRTVATOUTLAY       :=   NVL(p_Sum.T_WRTVATOUTLAY,0);
     p_Sum.T_CORRVALUE          :=   NVL(p_Sum.T_CORRVALUE,0);
     p_Sum.T_CORRDATE           :=   NVL(p_Sum.T_CORRDATE,UnknownDate);
     p_Sum.T_AMORTCOST          :=   NVL(p_Sum.T_AMORTCOST,0);
     p_Sum.T_CORRINTTOEIR       :=   NVL(p_Sum.T_CORRINTTOEIR,0);
     p_Sum.T_CORRINTTOEIRDATE   :=   NVL(p_Sum.T_CORRINTTOEIRDATE,UnknownDate);
     p_Sum.T_WRTCORRINTTOEIR    :=   NVL(p_Sum.T_WRTCORRINTTOEIR,0);
     p_Sum.T_GRDEALID           :=   NVL(p_Sum.T_GRDEALID,0);
     p_Sum.T_ESTRESERVEADD      :=   NVL(p_Sum.T_ESTRESERVEADD,0);
     p_Sum.T_ESTRESERVEDATE     :=   NVL(p_Sum.T_ESTRESERVEDATE,UnknownDate);
     p_Sum.T_CORRESTRESERVEADD  :=   NVL(p_Sum.T_CORRESTRESERVEADD,0);
     p_Sum.T_CORRESTRESERVEDATE :=   NVL(p_Sum.T_CORRESTRESERVEDATE,UnknownDate);
     p_Sum.T_PORTFOLIO          :=   NVL(p_Sum.T_PORTFOLIO,0);
     p_Sum.T_RESERVAMOUNTADD    :=   NVL(p_Sum.T_RESERVAMOUNTADD,0);
     p_Sum.T_INCOMERESERVADD    :=   NVL(p_Sum.T_INCOMERESERVADD,0);
     p_Sum.T_RESERVDATE         :=   NVL(p_Sum.T_RESERVDATE,UnknownDate);
     p_Sum.T_STATE              :=   NVL(p_Sum.T_STATE,0);
     p_Sum.T_OVERAMOUNT         :=   NVL(p_Sum.T_OVERAMOUNT,0);
     p_Sum.T_OVERAMOUNTADD      :=   NVL(p_Sum.T_OVERAMOUNTADD,0);
     p_Sum.T_DEALID             :=   NVL(p_Sum.T_DEALID,0);
     p_Sum.T_EFFECTINTERESTRATE :=   NVL(p_Sum.T_EFFECTINTERESTRATE,0);
     p_Sum.T_BEGDEFDIFFDATE     :=   NVL(p_Sum.T_BEGDEFDIFFDATE,UnknownDate);
     p_Sum.T_HEDGCORR           :=   NVL(p_Sum.T_HEDGCORR,0);
     p_Sum.T_HEDGCORRDATE       :=   NVL(p_Sum.T_HEDGCORRDATE,UnknownDate);
     p_Sum.T_AMORTHEDGCORR      :=   NVL(p_Sum.T_AMORTHEDGCORR,0);
     p_Sum.T_AMORTHEDGCORRDATE  :=   NVL(p_Sum.T_AMORTHEDGCORRDATE,UnknownDate);
   END;

   /**
    * Заполнение дефолтными значениями незаполненных(null-х) полей в переданной структуре линка лотов
    */
   PROCEDURE RSI_InsDfltIntoWRTLNK( p_Sum IN OUT DPMWRTLNK_DBT%ROWTYPE )
   IS
   BEGIN
     p_Sum.T_LNKID                :=   NVL(p_Sum.T_LNKID,0);
     p_Sum.T_SALEID               :=   NVL(p_Sum.T_SALEID,0);
     p_Sum.T_BUYID                :=   NVL(p_Sum.T_BUYID,0);
     p_Sum.T_KIND                 :=   NVL(p_Sum.T_KIND,0);
     p_Sum.T_AMOUNT               :=   NVL(p_Sum.T_AMOUNT,0);
     p_Sum.T_SUMSALE              :=   NVL(p_Sum.T_SUMSALE,0);
     p_Sum.T_SUMBUY               :=   NVL(p_Sum.T_SUMBUY,0);
     p_Sum.T_COSTSALE             :=   NVL(p_Sum.T_COSTSALE,0);
     p_Sum.T_COSTBUY              :=   NVL(p_Sum.T_COSTBUY,0);
     p_Sum.T_BALANCECOSTSALE      :=   NVL(p_Sum.T_BALANCECOSTSALE,0);
     p_Sum.T_BALANCECOSTBUY       :=   NVL(p_Sum.T_BALANCECOSTBUY,0);
     p_Sum.T_BALANCECOSTBD        :=   NVL(p_Sum.T_BALANCECOSTBD,0);
     p_Sum.T_INTERESTINCOMEBUY    :=   NVL(p_Sum.T_INTERESTINCOMEBUY,0);
     p_Sum.T_INTERESTINCOMEADD    :=   NVL(p_Sum.T_INTERESTINCOMEADD,0);
     p_Sum.T_NKDSALEAMOUNT        :=   NVL(p_Sum.T_NKDSALEAMOUNT,0);
     p_Sum.T_NKDBUYAMOUNT         :=   NVL(p_Sum.T_NKDBUYAMOUNT,0);
     p_Sum.T_NOTCARRYINTERESTBUY  :=   NVL(p_Sum.T_NOTCARRYINTERESTBUY,0);
     p_Sum.T_NOTCARRYINTERESTADD  :=   NVL(p_Sum.T_NOTCARRYINTERESTADD,0);
     p_Sum.T_BEGDISCOUNTCHANGE    :=   NVL(p_Sum.T_BEGDISCOUNTCHANGE,0);
     p_Sum.T_OLDBEGDISCOUNTCHANGE :=   NVL(p_Sum.T_OLDBEGDISCOUNTCHANGE,0);
     p_Sum.T_BEGBONUSCHANGE       :=   NVL(p_Sum.T_BEGBONUSCHANGE,0);
     p_Sum.T_DISCOUNTINCOMEBUY    :=   NVL(p_Sum.T_DISCOUNTINCOMEBUY,0);
     p_Sum.T_DISCOUNTINCOMEADD    :=   NVL(p_Sum.T_DISCOUNTINCOMEADD,0);
     p_Sum.T_NOTCARRYDISCOUNTBUY  :=   NVL(p_Sum.T_NOTCARRYDISCOUNTBUY,0);
     p_Sum.T_NOTCARRYDISCOUNTADD  :=   NVL(p_Sum.T_NOTCARRYDISCOUNTADD,0);
     p_Sum.T_BONUSBUY             :=   NVL(p_Sum.T_BONUSBUY,0);
     p_Sum.T_OLDBONUSBUY          :=   NVL(p_Sum.T_OLDBONUSBUY,0);
     p_Sum.T_BONUSADD             :=   NVL(p_Sum.T_BONUSADD,0);
     p_Sum.T_OUTLAYSALE           :=   NVL(p_Sum.T_OUTLAYSALE,0);
     p_Sum.T_OUTLAYBUY            :=   NVL(p_Sum.T_OUTLAYBUY,0);
     p_Sum.T_OVERCHANGE           :=   NVL(p_Sum.T_OVERCHANGE,0);
     p_Sum.T_RESERVCHANGE         :=   NVL(p_Sum.T_RESERVCHANGE,0);
     p_Sum.T_COUPON               :=   NVL(p_Sum.T_COUPON,CHR(1));
     p_Sum.T_PARTLY               :=   NVL(p_Sum.T_PARTLY,CHR(1));
     p_Sum.T_ID_OPERATION         :=   NVL(p_Sum.T_ID_OPERATION,0);
     p_Sum.T_ID_STEP              :=   NVL(p_Sum.T_ID_STEP,0);
     p_Sum.T_ACTION               :=   NVL(p_Sum.T_ACTION,0);
     p_Sum.T_CREATEDATE           :=   NVL(p_Sum.T_CREATEDATE,UnknownDate);
     p_Sum.T_INCOMERESERVCHANGE   :=   NVL(p_Sum.T_INCOMERESERVCHANGE,0);
     p_Sum.t_SaleInstance         :=   NVL(p_Sum.t_SaleInstance,0);
     p_Sum.t_BuyInstance          :=   NVL(p_Sum.t_BuyInstance,0);
     p_Sum.t_DiscountCorrChange   :=   NVL(p_Sum.t_DiscountCorrChange,0);
     p_Sum.t_OldBegBonusChange    :=   NVL(p_Sum.t_OldBegBonusChange,0);
     p_Sum.t_OVERCHANGEBD         :=   NVL(p_Sum.t_OVERCHANGEBD,0);
     p_Sum.t_NotWrtBonusBuy       :=   NVL(p_Sum.t_NotWrtBonusBuy,0);
     p_Sum.t_COSTPFIBUY           :=   NVL(p_Sum.t_COSTPFIBUY,0);
     p_Sum.T_BLOCKAMOUNTBuy       :=   NVL(p_Sum.T_BLOCKAMOUNTBuy,0);
     p_Sum.T_ACCOUNTEDDEFDIFFADD  :=   NVL(p_Sum.T_ACCOUNTEDDEFDIFFADD,0);
     p_Sum.T_ACCOUNTEDDEFDIFFBUY  :=   NVL(p_Sum.T_ACCOUNTEDDEFDIFFBUY,0);
     p_Sum.T_BEGDEFDIFFCHANGE     :=   NVL(p_Sum.T_BEGDEFDIFFCHANGE,0);
     p_Sum.T_WRTOUTLAYADD         :=   NVL(p_Sum.T_WRTOUTLAYADD,0);
     p_Sum.T_WRTOUTLAYBUY         :=   NVL(p_Sum.T_WRTOUTLAYBUY,0);
     p_Sum.T_WRTVATOUTLAYADD      :=   NVL(p_Sum.T_WRTVATOUTLAYADD,0);
     p_Sum.T_WRTVATOUTLAYBUY      :=   NVL(p_Sum.T_WRTVATOUTLAYBUY,0);
     p_Sum.T_VATOUTLAYCHANGE      :=   NVL(p_Sum.T_VATOUTLAYCHANGE,0);
     p_Sum.T_FAIRVALUECHANGE      :=   NVL(p_Sum.T_FAIRVALUECHANGE,0);
     p_Sum.T_AMORTCOSTCHANGE      :=   NVL(p_Sum.T_AMORTCOSTCHANGE,0);
     p_Sum.T_CORRVALUECHANGE      :=   NVL(p_Sum.T_CORRVALUECHANGE,0);
     p_Sum.T_ESTRESERVCHANGE      :=   NVL(p_Sum.T_ESTRESERVCHANGE,0);
     p_Sum.T_CORRINTTOEIRCHANGE   :=   NVL(p_Sum.T_CORRINTTOEIRCHANGE,0);
     p_Sum.T_CORRESTRESERVCHANGE  :=   NVL(p_Sum.T_CORRESTRESERVCHANGE,0);
     p_Sum.T_CORRINTTOEIRADD      :=   NVL(p_Sum.T_CORRINTTOEIRADD,0);
     p_Sum.T_ESTRESERVEADD        :=   NVL(p_Sum.T_ESTRESERVEADD,0);
     p_Sum.T_CORRESTRESERVEADD    :=   NVL(p_Sum.T_CORRESTRESERVEADD,0);
     p_Sum.T_RESERVADD            :=   NVL(p_Sum.T_RESERVADD,0);
     p_Sum.T_INCOMERESERVADD      :=   NVL(p_Sum.T_INCOMERESERVADD,0);
     p_Sum.T_OVERAMOUNTADD        :=   NVL(p_Sum.T_OVERAMOUNTADD,0);
     p_Sum.T_COSTBUYNAT           :=   NVL(p_Sum.T_COSTBUYNAT,0);
     p_Sum.T_ADDINCOMEOWNCHANGE   :=   NVL(p_Sum.T_ADDINCOMEOWNCHANGE,0);
     p_Sum.T_SOURCEBUYID          :=   NVL(p_Sum.T_SOURCEBUYID,0);
     p_Sum.T_HEDGCORRCHANGE       :=   NVL(p_Sum.T_HEDGCORRCHANGE,0);
     p_Sum.T_AMORTHEDGCORRCHANGE  :=   NVL(p_Sum.T_AMORTHEDGCORRCHANGE,0);
   END;

   -- получить SCDLPMWR из записи, переданной из ситсемы в виде RAW
   PROCEDURE RSI_GetSCDLPMWRFromRAW( RecDlpmwr IN RAW, rDlpmwr IN OUT dscdlpmwr_dbt%ROWTYPE )
   AS
   BEGIN
     InitError();
     rsb_struct.readStruct('dscdlpmwr_dbt');

     rDlpmwr.t_DealKind          := rsb_struct.getInt('t_DealKind', RecDlpmwr);
     rDlpmwr.t_DealID            := rsb_struct.getlong('t_DealID', RecDlpmwr);
     rDlpmwr.t_SumID             := rsb_struct.getlong('t_SumID', RecDlpmwr);
     rDlpmwr.t_OldAmount         := rsb_struct.getmoney('t_OldAmount', RecDlpmwr);
     rDlpmwr.t_CalcAmount        := rsb_struct.getmoney('t_CalcAmount', RecDlpmwr);
     rDlpmwr.t_NewAmount         := rsb_struct.getmoney('t_NewAmount', RecDlpmwr);
     rDlpmwr.t_State             := rsb_struct.getInt('t_State', RecDlpmwr);
     rDlpmwr.t_Party             := rsb_struct.getlong('t_Party', RecDlpmwr);
     rDlpmwr.t_Date              := rsb_struct.getdate('t_Date', RecDlpmwr );
     rDlpmwr.t_NewFIID           := rsb_struct.getlong('t_NewFIID', RecDlpmwr);
     rDlpmwr.t_SumFIIDAmount     := rsb_struct.getmoney('t_SumFIIDAmount', RecDlpmwr);
     rDlpmwr.t_SumNewAmount      := rsb_struct.getmoney('t_SumNewAmount', RecDlpmwr);
     rDlpmwr.t_OldCost           := rsb_struct.getmoney('t_OldCost', RecDlpmwr);
     rDlpmwr.t_SumFIIDCost       := rsb_struct.getmoney('t_SumFIIDCost', RecDlpmwr);
     rDlpmwr.t_SumNewCost        := rsb_struct.getmoney('t_SumNewCost', RecDlpmwr);
     rDlpmwr.t_CalcCost          := rsb_struct.getmoney('t_CalcCost', RecDlpmwr);
     rDlpmwr.t_NewCost           := rsb_struct.getmoney('t_NewCost', RecDlpmwr);
     rDlpmwr.t_InterestIncomeAdd := rsb_struct.getmoney('t_InterestIncomeAdd', RecDlpmwr);
     rDlpmwr.t_DiscountIncomeAdd := rsb_struct.getmoney('t_DiscountIncomeAdd', RecDlpmwr);
     rDlpmwr.t_OldInstance       := rsb_struct.getInt('t_OldInstance', RecDlpmwr);
     rDlpmwr.t_Kind              := rsb_struct.getInt('t_Kind', RecDlpmwr);

   END; -- RSI_GetSCDLPMWRFromRAW

   ----------------------------------------------------------------------------------------------------------------------
   -----  p_ClientID - Владелец (наш банк - UnknounParty)
   -----  p_ContractID  - Договор обслуживания
   -----  p_FI_Kind - Вид ФИ
   FUNCTION GetAmortizationMethod( p_ClientID IN NUMBER, p_ContractID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
     v_MethodID NUMBER;
   BEGIN

    IF p_ClientID > 0 THEN
      v_MethodID := PM_WRITEOFF_FIFO;
    ELSE
      v_MethodID := PM_WRITEOFF_FIFO;

      SELECT T_METHODID INTO v_MethodID
        FROM DPMWRTMET_DBT
       WHERE T_PARTY = p_ClientID
         AND T_CONTRACT = p_ContractID;
    END IF;

    RETURN v_MethodID;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
        SetError( WRTOFF_ERROR_20207 );
        RETURN UnknownValue;
      WHEN OTHERS THEN
        SetError( WRTOFF_ERROR_20207 );
        RETURN UnknownValue;
   END;

   ----------------------------------------------------------------------------------------------------------------------
   ----- Определяет необходимость начисления дохода на ц/б в продаже и операции начисления дохода и
   ----- определяет коэффициенты, требуемые для расчета. Используется в БО Ц/Б.
   FUNCTION WRTNeedChargeIncome( p_FIID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      v_AvoirKind   NUMBER;
   BEGIN

      SELECT t_AvoirKind INTO v_AvoirKind
        FROM dfininstr_dbt
       WHERE t_FIID = p_FIID;

      IF( RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) = FALSE ) THEN
         return 0;
      END iF;

      return 1;

   EXCEPTION
      WHEN OTHERS THEN
        return 0;
   END;

   ----- Определяет необходимость начисления премии на ц/б. Используется в БО Ц/Б.
   FUNCTION WRTNeedChargeBonus( p_FIID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
   BEGIN
      return WRTNeedChargeIncome( p_FIID );
   END;

   -- Определяет необходимость начисления процентного дохода на ц/б. Используется в БО Ц/Б.
   FUNCTION WRTNeedChargeInterestIncome( p_FIID IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      IncomeVolume NUMBER;
      IncomeRate   NUMBER;
   BEGIN

      SELECT T_IncomeVolume, t_IncomeRate
        INTO IncomeVolume, IncomeRate
        FROM DAVOIRISS_DBT
       WHERE T_FIID = p_FIID;

      IF( IncomeVolume != 0 OR IncomeRate != 0 OR RSI_RSB_FIInstr.FI_IsCouponAvoiriss(p_FIID) = 1 ) THEN
         return 1;
      END iF;

      return 0;

   EXCEPTION
      WHEN OTHERS THEN
        return 0;
   END;

   ----------------------------------------------------------------------------------------------------------------------
   -- Вычисление процентного дохода на купленные ц/б
   FUNCTION WRTCalcInterestIncome( CalcDate         IN DATE,   -- Дата начисления
                                   BuyDate          IN DATE,   -- Дата начала начисления ПД
                                   LnkKind          IN NUMBER, -- Вид связи списания
                                   FIID             IN NUMBER, -- ц/б
                                   Amount           IN NUMBER, -- Количество
                                   NKD              IN NUMBER, -- Сумма НКД
                                   PrevInterestDate IN DATE,   -- Дата предыдущего начисления
                                   PrevInterest     IN NUMBER, -- Предыдущее начисление
                                   Method           IN NUMBER, -- Метод списания
                                   Coupon           IN VARCHAR2 DEFAULT NULL, -- Номер купона
                                   IsTrust          IN BOOLEAN DEFAULT False,
                                   CorrectDate      IN NUMBER DEFAULT 0--  Признак коррекции последней даты месяца
                                                               --   0 - CalcDate не корректируется в соответствии с базисом расчета (умолч.)
                                                               --   1 - CalcDate корректируется в соответствии с базисом расчета

                                 ) RETURN NUMBER DETERMINISTIC
   IS
      v_NKDCourse NUMBER := 0;
      v_Ret       NUMBER := NULL;
      v_PrevInterestDate DATE;
   BEGIN

      if(v_Ret is null) then
         if(PrevInterestDate <> UnknownDate) THEN
            if(CalcDate < PrevInterestDate) THEN
               SetError( WRTOFF_ERROR_20219 );
            elsif(CalcDate = PrevInterestDate) THEN
               v_Ret := 0;
            end if;
         end if;
      end if;

      if(v_Ret is null) then
        v_PrevInterestDate := PrevInterestDate;
        IF RSI_RsbCalendar.IsWorkDay(v_PrevInterestDate) = 0 THEN
          v_PrevInterestDate := RSI_RsbCalendar.GetDateAfterWorkDay(v_PrevInterestDate, -1);
        END IF;
        
        BEGIN

          if( IsTrust ) then
             v_NKDCourse := RSI_RSB_FIInstr.FindNKDCource( FIID, CalcDate, 1 );
          else
             v_NKDCourse := RSI_RSB_FIInstr.FindNKDCource( FIID, CalcDate, 0 );
          end if;

          if( v_NKDCourse > 0 ) then
             v_Ret := (v_NKDCourse * Amount) - PrevInterest - NKD;

             IF Method = PM_WRITEOFF_AVERAGE AND LnkKind <> PMWRTLINK_KIND_RETISSUE AND LnkKind <> PMWRTLINK_KIND_RETCOUPON AND LnkKind <> PMWRTLINK_KIND_RETPARTLY THEN
               FOR one_fiw IN (SELECT t_DrawingDate
                                 FROM DFIWARNTS_DBT
                                WHERE t_FIID = FIID
                                  AND t_DrawingDate >= v_PrevInterestDate
                                  AND t_DrawingDate < CalcDate
                                  AND t_IsPartial = CHR(0)
                                  AND t_SPIsClosed = CHR(0)
                                  AND t_IsClosed = CHR(0)
                                ORDER BY t_DrawingDate ASC
                              )
               LOOP
                 v_Ret := v_Ret + RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, one_fiw.t_DrawingDate, Amount, 1, CorrectDate );
               END LOOP;

             END IF;

             v_Ret := ROUND(v_Ret, 2);

          end if;

        EXCEPTION
           WHEN OTHERS THEN NULL;
        END;
      end if;

      if(v_Ret is null) then
         if( LnkKind = PMWRTLINK_KIND_RETISSUE ) then -- Погашение выпуска
            if( RSI_RSB_FIInstr.FI_HasCoupon( FIID ) = true ) then
               if( (Coupon is not NULL) AND (Coupon != chr(1)) ) then
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, Coupon, Amount ) - PrevInterest - NKD, 2);
               else
                  v_Ret := 0;
               end if;
            else
               v_Ret := ROUND( RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, 0, Amount ) -
                               PrevInterest -
                               RSI_RSB_FIInstr.FI_CalcIncomeValue(FIID, BuyDate, Amount, 1), 2
                             );
             end if;

         elsif( LnkKind = PMWRTLINK_KIND_RETCOUPON ) then -- Погашение купона
            v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, Coupon, Amount ) - PrevInterest - NKD, 2);

         elsif( LnkKind = PMWRTLINK_KIND_RETPARTLY ) then -- Частичное погашение
           if( (Coupon is not NULL) AND (Coupon != chr(1)) ) then
              v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, Coupon, Amount ) - PrevInterest - NKD, 2);
           else
              v_Ret := 0;
           end if;

         else
            if( RSI_RSB_FIInstr.FI_HasCoupon( FIID ) = true ) then
               if( CalcDate <> BuyDate ) then
                  v_Ret     := 0;
                  
                  IF Method = PM_WRITEOFF_AVERAGE THEN
                    FOR one_fiw IN (SELECT t_DrawingDate
                                      FROM DFIWARNTS_DBT
                                     WHERE t_FIID = FIID
                                       AND t_DrawingDate >= v_PrevInterestDate
                                       AND t_DrawingDate < CalcDate
                                       AND t_IsPartial = CHR(0)
                                       AND t_SPIsClosed = CHR(0)
                                       AND t_IsClosed = CHR(0)
                                     ORDER BY t_DrawingDate ASC
                                   )
                    LOOP
                      v_Ret := v_Ret + RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, one_fiw.t_DrawingDate, Amount, 1, CorrectDate );
                    END LOOP;

                  END IF;
                  
                  v_Ret := ROUND(v_Ret + RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, CalcDate, Amount, 1, CorrectDate ) - PrevInterest - NKD, 2);
               else
                  v_Ret := 0;
               end if;
            else
               if( PrevInterestDate = UnknownDate ) then
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, CalcDate, Amount, 1, CorrectDate ) -
                                 RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, BuyDate, Amount, 1 ), 2);
               else
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, CalcDate, Amount, 1, CorrectDate ) - PrevInterest, 2);
               end if;
            end if;
         end if;
      end if;

      if (v_Ret >= 0 OR Method = PM_WRITEOFF_AVERAGE ) then
         return v_Ret;
      else
         return 0;
      end if;
   END; --WRTCalcInterestIncome

   ----------------------------------------------------------------------------------------------------------------------
   -- Вычисление дисконтного дохода на дату
   FUNCTION WRTCalcDiscountIncomeOnDate( CalcDate     IN DATE,   -- Дата начисления (D)
                                         EndDate      IN DATE,   -- Дата окончания периода начисления
                                         BuyDate      IN DATE,   -- Дата начала начисления ДД (Dпок)
                                         FIID         IN NUMBER, -- ц/б
                                         Discount0    IN NUMBER, -- Остаток начального дисконта
                                         InclDrwDate  IN NUMBER, -- Включать дату погошания
                                         Method       IN NUMBER  -- Метод списания
                                       ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE  DATE;
      v_R0           NUMBER;
      v_PARTSUM      NUMBER := 0;
      v_DiscSum      NUMBER;
      v_PrevDrawingDate DATE;
      v_BegDate DATE;
      v_BegDiscount NUMBER;
      v_TERMLESS CHAR;
      v_CalcDate DATE;
      v_IsOffer NUMBER;
      v_OfferDate DATE;

      FUNCTION CalcDiscountPart(p_BegDiscount IN NUMBER, p_BegDate IN DATE, p_EndDate IN DATE) RETURN NUMBER
      IS
        v_FWSUM      NUMBER := 0;
        v_CALCSUM    NUMBER := 0;
      BEGIN
        FOR one_war IN (SELECT ROWNUM as RN, T_DRAWINGDATE, 
                               RSI_RSB_FIInstr.FI_GetNominalOnDate(FIID, T_DRAWINGDATE-1) FV --Берем на предыдущую дату, т.к. в дату погашения ЧП номинал уже уменьшен
                          FROM DFIWARNTS_DBT
                         WHERE t_FIID = FIID
                           AND T_ISPARTIAL = chr(88)
                           AND T_DRAWINGDATE > p_BegDate
                         ORDER BY T_DRAWINGDATE ASC
                       )
        LOOP
          IF one_war.RN = 1 THEN
            v_FWSUM := v_FWSUM + (one_war.t_DrawingDate - p_BegDate) * one_war.FV;
          ELSE
            v_FWSUM := v_FWSUM + (one_war.t_DrawingDate - v_PrevDrawingDate) * one_war.FV;
          END IF;

          v_PrevDrawingDate := one_war.t_DrawingDate;

        END LOOP;

        IF v_FWSUM <> 0 THEN
          --Здесь также номинал берем на предыдущую дату, поскольку без этого, если начислять в дату погашения ЧП, то номинал получим уже уменьшенным
          v_CALCSUM := p_BegDiscount * RSI_RSB_FIInstr.FI_GetNominalOnDate(FIID, p_EndDate-1)/v_FWSUM * (p_EndDate - p_BegDate);
        END IF;

        RETURN v_CALCSUM;
      END;

   BEGIN
      if ( CALC_DISCOUNT_WITHOUT_PARTLY = DISCOUNT_WITHOUT_PARTLY_YES or RSI_RSB_FIInstr.FI_HasPartialDischarge(FIID) = false ) then

         v_DRAWINGDATE := rsb_secur.SC_GetTopCalcDate(RSB_SECUR.CALCKIND_AVR, FIID, CalcDate, v_IsOffer, v_TERMLESS, v_OfferDate);
         v_CalcDate := CASE WHEN CalcDate > v_DRAWINGDATE THEN v_DRAWINGDATE ELSE CalcDate END;

         if v_DRAWINGDATE = BuyDate then
            return 0.0;
         else
            return round(Discount0 * (v_CalcDate - BuyDate) / (v_DRAWINGDATE - BuyDate),2);
         end if;
      else
         IF Method = PM_WRITEOFF_AVERAGE THEN
           --При средневзвесе дата начала начисления BuyDate всегда меняется после каждого начисления и равна дате предыдущего начисления, поэтому исползуем её.
           v_BegDiscount := Discount0;
           v_BegDate     := BuyDate;

           FOR one_war IN (SELECT *
                             FROM DFIWARNTS_DBT
                            WHERE t_FIID = FIID
                              AND T_ISPARTIAL = chr(88)
                              AND T_DRAWINGDATE > BuyDate
                              AND T_DRAWINGDATE < EndDate
                            ORDER BY T_DRAWINGDATE ASC 
                          )
           LOOP

             v_DiscSum := CalcDiscountPart(v_BegDiscount, v_BegDate, one_war.t_DrawingDate);
             v_PARTSUM := v_PARTSUM + v_DiscSum;
             
             v_BegDiscount := v_BegDiscount - v_DiscSum;
             v_BegDate     := one_war.t_DrawingDate;

           END LOOP;

           v_PARTSUM := v_PARTSUM + CalcDiscountPart(v_BegDiscount, v_BegDate, EndDate);

         ELSE

           v_R0 := 100.0 - RSI_RSB_FIInstr.FI_GetPartialPersent(FIID, BuyDate);

           SELECT NVL(SUM(Discount0 * T_INCOMERATE * (CalcDate - BuyDate) /
                      (v_R0 * (T_DRAWINGDATE - BuyDate))
                     ),0) into v_PARTSUM
             FROM DFIWARNTS_DBT
            WHERE t_FIID = FIID
              AND T_ISPARTIAL = chr(88)
              AND (    (InclDrwDate  = 1 AND T_DRAWINGDATE >= EndDate)
                    OR (InclDrwDate != 1 AND T_DRAWINGDATE >  EndDate)
                  );
         END IF;

         return round(v_PARTSUM,2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;

   END; --WRTCalcDiscountIncomeOnDate

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления дисконтного дохода на купленные ц/б. Используется в БО Ц/Б.
   FUNCTION WRTCalcDiscountIncome( CalcDate         IN DATE,    -- Дата начисления
                                   BuyDate          IN DATE,    -- Дата начала начисления ДД
                                   LnkKind          IN NUMBER,  -- Вид связи списания
                                   FIID             IN NUMBER,  -- ц/б
                                   Amount           IN NUMBER,  -- Количество
                                   Cost             IN NUMBER,  -- Стоимость
                                   PrevDiscountDate IN DATE,    -- Дата предыдущего начисления
                                   PrevDiscount     IN NUMBER,  -- Предыдущее начисление
                                   Discount0        IN NUMBER,  -- Остаток начального дисконта
                                   OldDiscount0     IN NUMBER,  -- Остаток начального дисконта до перевода
                                   p_Party          IN NUMBER,
                                   p_Contract       IN NUMBER,
                                   RecalcDate       IN DATE     -- Дата пересчета дисконта при переводе
                                 ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret       NUMBER := NULL;
      v_Method    NUMBER;
   BEGIN

      if(PrevDiscountDate <> UnknownDate) THEN
         if(CalcDate < PrevDiscountDate) THEN
            SetError( WRTOFF_ERROR_20219 );
         elsif(CalcDate = PrevDiscountDate) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
            v_Method := GetAmortizationMethod( p_Party, p_Contract );

            if( LnkKind = PMWRTLINK_KIND_RETISSUE ) then -- Погашение выпуска
               if( Discount0 = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate (FIID, CalcDate - 1)* Amount - Cost - PrevDiscount, 2);
               end if;
            elsif( LnkKind = PMWRTLINK_KIND_RETCOUPON or LnkKind = PMWRTLINK_KIND_RETPARTLY ) then -- Погашение купона или Частичное погашение

               IF(v_Method = PM_WRITEOFF_AVERAGE) THEN
                  IF (Discount0 - PrevDiscount <= 0) THEN
                     v_Ret := 0;
                  ELSE
                     v_Ret := ROUND(WRTCalcDiscountIncomeOnDate (CalcDate, CalcDate, BuyDate, FIID, Discount0-PrevDiscount, 1, v_Method), 2);
                  END IF;

               ELSIF (Discount0 = 0) THEN
                  v_Ret := 0;

               ELSE
/* КД Проверяем не по старому дисконту а по дате рекласса
                  if(OldDiscount0 = 0 ) THEN
*/
 if(RecalcDate = TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) THEN
                     v_Ret := ROUND(WRTCalcDiscountIncomeOnDate (CalcDate, CalcDate, BuyDate, FIID, Discount0, 1, v_Method) - PrevDiscount, 2);
                  else
                     v_Ret := ROUND(WRTCalcDiscountIncomeOnDate (RecalcDate,  CalcDate, BuyDate,    FIID, OldDiscount0, 1, v_Method) +
                                    WRTCalcDiscountIncomeOnDate (CalcDate,    CalcDate, RecalcDate, FIID, Discount0,    1, v_Method) - PrevDiscount, 2);
                  end if;
               END IF;

            else

               IF( v_Method = PM_WRITEOFF_AVERAGE) THEN
                   IF (Discount0 - PrevDiscount <= 0) THEN
                      v_Ret := 0.0;
                   ELSE
                      v_Ret := ROUND(WRTCalcDiscountIncomeOnDate(CalcDate, CalcDate, BuyDate, FIID, Discount0-PrevDiscount, 0, v_Method), 2);
                   END IF;
               ELSE
                  if( Discount0 = 0 ) then
                     v_Ret := 0.0;
                  else
/* if(OldDiscount0 = 0 ) THEN */
 if(RecalcDate = TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) THEN
                        v_Ret := ROUND(WRTCalcDiscountIncomeOnDate(CalcDate, CalcDate, BuyDate, FIID, Discount0, 0, v_Method) - PrevDiscount, 2);
                     else
                        v_Ret := ROUND(WRTCalcDiscountIncomeOnDate(RecalcDate,  CalcDate, BuyDate,    FIID, OldDiscount0, 0, v_Method) +
                                       WRTCalcDiscountIncomeOnDate(CalcDate,    CalcDate, RecalcDate, FIID, Discount0,    0, v_Method) - PrevDiscount, 2);
                     end if;
                  end if;
               end if;
            end if;
         end if;

      END;

      if ( (v_Ret >= 0) or ( p_Party is not NULL and p_Party != 0 and p_Contract is not NULL and p_Contract >= 0 and
                             v_Method = PM_WRITEOFF_AVERAGE ) ) then
         return v_Ret;
      else
         return 0;
      end if;

   END;--WRTCalcDiscountIncome

   ----------------------------------------------------------------------------------------------------------------------
   -- Функция для вычисления суммы премии на дату. Используется в БО Ц/Б.
   FUNCTION WRTCalcBonusOnDate( CalcDate     IN DATE,   -- Дата начисления
                                EndDate      IN DATE,   -- Дата окончания периода начисления
                                BuyDate      IN DATE,   -- Дата начала начисления премии
                                FIID         IN NUMBER, -- ц/б
                                Bonus0       IN NUMBER, -- Остаток начальной премии
                                InclDrwDate  IN NUMBER, -- Включать дату погошания
                                Method       IN NUMBER  -- Метод списания
                              ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE  DATE;
      v_PARTSUM    NUMBER := 0;
      v_OLDPARTSUM NUMBER := 0;
      v_R0         NUMBER;
      v_PrevDrawingDate DATE;
      v_BonusSum      NUMBER;
      v_BegDate DATE;
      v_BegBonus NUMBER;
      v_TERMLESS CHAR;
      v_CalcDate DATE;
      v_IsOffer NUMBER;
      v_OfferDate DATE;

      FUNCTION CalcBonusPart(p_BegBonus IN NUMBER, p_BegDate IN DATE, p_EndDate IN DATE) RETURN NUMBER
      IS
        v_FWSUM      NUMBER := 0;
        v_CALCSUM    NUMBER := 0;
      BEGIN
        FOR one_war IN (SELECT ROWNUM as RN, T_DRAWINGDATE, 
                               RSI_RSB_FIInstr.FI_GetNominalOnDate(FIID, T_DRAWINGDATE-1) FV --Берем на предыдущую дату, т.к. в дату погашения ЧП номинал уже уменьшен
                          FROM DFIWARNTS_DBT
                         WHERE t_FIID = FIID
                           AND T_ISPARTIAL = chr(88)
                           AND T_DRAWINGDATE > p_BegDate
                         ORDER BY T_DRAWINGDATE ASC
                       )
        LOOP
          IF one_war.RN = 1 THEN
            v_FWSUM := v_FWSUM + (one_war.t_DrawingDate - p_BegDate) * one_war.FV;
          ELSE
            v_FWSUM := v_FWSUM + (one_war.t_DrawingDate - v_PrevDrawingDate) * one_war.FV;
          END IF;

          v_PrevDrawingDate := one_war.t_DrawingDate;

        END LOOP;

        IF v_FWSUM <> 0 THEN
          --Здесь также номинал берем на предыдущую дату, поскольку без этого, если начислять в дату погашения ЧП, то номинал получим уже уменьшенным
          v_CALCSUM := p_BegBonus * RSI_RSB_FIInstr.FI_GetNominalOnDate(FIID, p_EndDate-1)/v_FWSUM * (p_EndDate - p_BegDate);
        END IF;

        RETURN v_CALCSUM;
      END;

   BEGIN
      if ( CALC_BONUS_WITHOUT_PARTLY = BONUS_WITHOUT_PARTLY_YES or RSI_RSB_FIInstr.FI_HasPartialDischarge(FIID) = false ) then

         v_DRAWINGDATE := rsb_secur.SC_GetTopCalcDate(RSB_SECUR.CALCKIND_AVR, FIID, CalcDate, v_IsOffer, v_TERMLESS, v_OfferDate);
         v_CalcDate := CASE WHEN CalcDate > v_DRAWINGDATE THEN v_DRAWINGDATE ELSE CalcDate END;

         if v_DRAWINGDATE = BuyDate then
            return 0.0;
         else
            return ROUND( Bonus0 * (v_CalcDate - BuyDate) / (v_DRAWINGDATE - BuyDate),2);
         end if;
      else

         IF Method = PM_WRITEOFF_AVERAGE THEN
           --При средневзвесе дата начала начисления BuyDate всегда меняется после каждого начисления и равна дате предыдущего начисления, поэтому исползуем её.

           v_BegDate  := BuyDate;
           v_BegBonus := Bonus0;

           FOR one_war IN (SELECT *
                             FROM DFIWARNTS_DBT
                            WHERE t_FIID = FIID
                              AND T_ISPARTIAL = chr(88)
                              AND T_DRAWINGDATE > BuyDate
                              AND T_DRAWINGDATE < EndDate
                            ORDER BY T_DRAWINGDATE ASC 
                          )
           LOOP

             v_BonusSum  := CalcBonusPart(v_BegBonus, v_BegDate, one_war.t_DrawingDate);
             v_PARTSUM   := v_PARTSUM + v_BonusSum;
             v_BegBonus  := v_BegBonus - v_BonusSum;
             v_BegDate   := one_war.t_DrawingDate;

           END LOOP;

           v_PARTSUM := v_PARTSUM + CalcBonusPart(v_BegBonus, v_BegDate, EndDate);

         ELSE

           SELECT NVL(SUM(Bonus0 * T_INCOMERATE * (CalcDate - BuyDate) /
                      (100.0 * (T_DRAWINGDATE - BuyDate))
                       ),0) into v_PARTSUM
             FROM DFIWARNTS_DBT
            WHERE t_FIID = FIID
              AND T_ISPARTIAL = chr(88)
              AND (    (InclDrwDate  = 1 AND T_DRAWINGDATE >= EndDate)
                    OR (InclDrwDate != 1 AND T_DRAWINGDATE >  EndDate)
                  );

           SELECT NVL(SUM(Bonus0 * T_INCOMERATE/100.0),0) into v_OLDPARTSUM
             FROM DFIWARNTS_DBT
            WHERE t_FIID = FIID
              AND T_ISPARTIAL = chr(88)
              AND T_DRAWINGDATE > BuyDate
              AND (    (InclDrwDate  = 1 AND T_DRAWINGDATE <  EndDate)
                    OR (InclDrwDate != 1 AND T_DRAWINGDATE <= EndDate)
                  );
         END IF;

         return round(v_PARTSUM+v_OLDPARTSUM,2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;
   END; --WRTCalcBonusOnDate

   ----------------------------------------------------------------------------------------------------------------------
   -- Функция для вычисления суммы премии на дату. Используется в БО ОЭБ.
   FUNCTION WRTCalcBonusOwnOnDate( CalcDate     IN DATE,   -- Дата начисления
                                   BegDate      IN DATE,   -- Дата начала начисления премии
                                   FIID         IN NUMBER, -- ц/б
                                   Bonus0       IN NUMBER  -- Начальная премия
                                 ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE  DATE;
      v_OFFERDATE DATE;
      v_CalcDate DATE;
   BEGIN
      SELECT RSI_RSB_FIInstr.FI_GetNominalDrawingDate(F.t_FIID, (select t_Termless from davoiriss_dbt where t_FIID = F.t_FIID)) into v_DRAWINGDATE
        FROM DFININSTR_DBT F
       WHERE F.t_FIID = FIID;

      if CALC_AMORTOWN_BEFOREOFFER = CALC_AMORTOWN_BEFOREOFFER_YES then
         v_OFFERDATE := RSI_RSB_FIInstr.FI_GetOfferDate(FIID, CalcDate/*BegDate*/);/*DAN*/
         if v_OFFERDATE != UnknownDate then
            v_DRAWINGDATE := v_OFFERDATE;
         end if;
      end if;

      v_CalcDate := CalcDate;
      if v_CalcDate > v_DRAWINGDATE then
        v_CalcDate := v_DRAWINGDATE;
      end if;

      if v_DRAWINGDATE = BegDate then
         return 0.0;
      else
         return ROUND( Bonus0 * (v_CalcDate - BegDate) / (v_DRAWINGDATE - BegDate),2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;

   END; --WRTCalcBonusOwnOnDate

   ----------------------------------------------------------------------------------------------------------------------
   -- Функция для вычисления отсроченной разницы на дату. Используется в БО ОЭБ.
   FUNCTION WRTCalcDefDiffOwnOnDate( CalcDate     IN DATE,   -- Дата начисления
                                     BegDate      IN DATE,   -- Дата начала начисления отсроченной разницы
                                     FIID         IN NUMBER, -- ц/б
                                     BegDefDiff   IN NUMBER  -- Начальная отсроченная разница
                                   ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE  DATE;
      v_OFFERDATE DATE;
   BEGIN
      SELECT RSI_RSB_FIInstr.FI_GetNominalDrawingDate(F.t_FIID, (select t_Termless from davoiriss_dbt where t_FIID = F.t_FIID)) into v_DRAWINGDATE
        FROM DFININSTR_DBT F
       WHERE F.t_FIID = FIID;

      if CALC_AMORTOWN_BEFOREOFFER = CALC_AMORTOWN_BEFOREOFFER_YES then
         v_OFFERDATE := RSI_RSB_FIInstr.FI_GetOfferDate(FIID, CalcDate/*BegDate*/); /*DAN*/
         if v_OFFERDATE != UnknownDate then
            v_DRAWINGDATE := v_OFFERDATE;
         end if;
      end if;

      if v_DRAWINGDATE = BegDate then
         return 0.0;
      else
         return ROUND( BegDefDiff * (CalcDate - BegDate) / (v_DRAWINGDATE - BegDate),2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;

   END; --WRTCalcDefDiffOwnOnDate

   ----------------------------------------------------------------------------------------------------------------------
   -- Функция для вычисления суммы затрат на дату. Используется в БО ОЭБ.
   FUNCTION WRTCalcWrtOutlayOwnOnDate( CalcDate     IN DATE,   -- Дата начисления
                                       BegDate      IN DATE,   -- Дата начала начисления затрат
                                       FIID         IN NUMBER, -- ц/б
                                       BegWrtOutlay IN NUMBER  -- Начальные затраты
                                     ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE  DATE;
      v_OFFERDATE DATE;
   BEGIN
      SELECT RSI_RSB_FIInstr.FI_GetNominalDrawingDate(F.t_FIID, (select t_Termless from davoiriss_dbt where t_FIID = F.t_FIID)) into v_DRAWINGDATE
        FROM DFININSTR_DBT F
       WHERE F.t_FIID = FIID;

      if CALC_AMORTOWN_BEFOREOFFER = CALC_AMORTOWN_BEFOREOFFER_YES then
         v_OFFERDATE := RSI_RSB_FIInstr.FI_GetOfferDate(FIID,CalcDate/* BegDate*/); /*DAN*/
         if v_OFFERDATE != UnknownDate then
            v_DRAWINGDATE := v_OFFERDATE;
         end if;
      end if;

      if v_DRAWINGDATE = BegDate then
         return 0.0;
      else
         return ROUND( BegWrtOutlay * (CalcDate - BegDate) / (v_DRAWINGDATE - BegDate),2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;

   END; --WRTCalcWrtOutlayOwnOnDate

   ----------------------------------------------------------------------------------------------------------------------
   -- Функция для вычисления суммы НДС затрат на дату. Используется в БО ОЭБ.
   FUNCTION WRTCalcVatOutlayOwnOnDate( CalcDate     IN DATE,   -- Дата начисления
                                       BegDate      IN DATE,   -- Дата начала начисления НДС затрат
                                       FIID         IN NUMBER, -- ц/б
                                       BegVatOutlay IN NUMBER  -- Начальный НДС затрат
                                     ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE  DATE;
      v_OFFERDATE DATE;
   BEGIN
      SELECT RSI_RSB_FIInstr.FI_GetNominalDrawingDate(F.t_FIID, (select t_Termless from davoiriss_dbt where t_FIID = F.t_FIID)) into v_DRAWINGDATE
        FROM DFININSTR_DBT F
       WHERE F.t_FIID = FIID;

      if CALC_AMORTOWN_BEFOREOFFER = CALC_AMORTOWN_BEFOREOFFER_YES then
         v_OFFERDATE := RSI_RSB_FIInstr.FI_GetOfferDate(FIID, CalcDate/*BegDate*/); /*DAN*/
         if v_OFFERDATE != UnknownDate then
            v_DRAWINGDATE := v_OFFERDATE;
         end if;
      end if;

      if v_DRAWINGDATE = BegDate then
         return 0.0;
      else
         return ROUND( BegVatOutlay * (CalcDate - BegDate) / (v_DRAWINGDATE - BegDate),2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;

   END; --WRTCalcVatOutlayOwnOnDate

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления суммы премии на купленные ц/б. Используется в БО Ц/Б.
   FUNCTION WRTCalcBonus( CalcDate         IN DATE,    -- Дата начисления
                          BuyDate          IN DATE,    -- Дата начала начисления премии
                          LnkKind          IN NUMBER,  -- Вид связи списания
                          FIID             IN NUMBER,  -- ц/б
                          Amount           IN NUMBER,  -- Количество
                          Cost             IN NUMBER,  -- Стоимость
                          PrevBonusDate    IN DATE,    -- Дата предыдущего начисления
                          PrevBonus        IN NUMBER,  -- Предыдущее начисление
                          Bonus0           IN NUMBER,  -- Остаток начальной премии
                          OldBonus0        IN NUMBER,  -- Остаток начальной премии до перевода
                          p_Party          IN NUMBER,  -- Владелец
                          p_Contract       IN NUMBER,  -- Договор обслуживания
                          RecalcDate       IN DATE     -- Дата пересчета дисконта при переводе
                        ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret       NUMBER := NULL;
      InclDrwDate NUMBER := 0;
      v_Method    NUMBER;
   BEGIN

      if(PrevBonusDate <> UnknownDate) THEN
         if(CalcDate < PrevBonusDate) THEN
            SetError( WRTOFF_ERROR_20225 );
         elsif(CalcDate = PrevBonusDate) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
            if (Bonus0 = 0) then
               v_Ret := 0.0;
            else

              v_Method := GetAmortizationMethod( p_Party, p_Contract );

              if( LnkKind = PMWRTLINK_KIND_RETISSUE ) then -- Погашение выпуска
                v_Ret := ABS(ROUND(Cost - RSI_RSB_FIInstr.FI_GetNominalOnDate (FIID, CalcDate - 1)* Amount, 2));
              else

                if( LnkKind = PMWRTLINK_KIND_RETCOUPON or LnkKind = PMWRTLINK_KIND_RETPARTLY) then -- Погашение купона или Частичное погашение
                  InclDrwDate := 1;
                end if;

                if( v_Method = PM_WRITEOFF_AVERAGE ) then
                   if (Bonus0 - PrevBonus <= 0) then
                      v_Ret := 0.0;
                   else
                      v_Ret := ROUND(WRTCalcBonusOnDate(CalcDate, CalcDate, BuyDate, FIID, Bonus0 - PrevBonus, InclDrwDate, v_Method), 2);
                   end if;
                else
/* КД Проверяем не по стврой премии а по дате рекласса
                   if (OldBonus0 = 0) then
*/
 if(RecalcDate = TO_DATE( '01.01.0001', 'DD.MM.YYYY' )) THEN
                     v_Ret := ROUND(WRTCalcBonusOnDate(CalcDate, CalcDate, BuyDate, FIID, Bonus0, InclDrwDate, v_Method) - PrevBonus, 2);
                   else
                     v_Ret := ROUND(WRTCalcBonusOnDate(RecalcDate, CalcDate, BuyDate, FIID, OldBonus0, InclDrwDate, v_Method) +
                                    WRTCalcBonusOnDate(CalcDate, CalcDate, RecalcDate, FIID, Bonus0, InclDrwDate, v_Method) - PrevBonus, 2);
                   end if;
                end if;
              end if;
            end if;
         end if;

      EXCEPTION
         WHEN OTHERS THEN
           v_Ret := 0.0;
      END;

      if (v_Ret >= 0) then
         return v_Ret;
      else
         return 0;
      end if;
   END;--WRTCalcBonus

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления суммы премии на размещенные ц/б. Используется в БО ОЭБ.
   FUNCTION WRTCalcBonusOwn( CalcDate         IN DATE,    -- Дата начисления
                             BegDate          IN DATE,    -- Дата начала начисления премии
                             LinkKind IN NUMBER, --Вид связи списания
                             FIID             IN NUMBER,  -- ц/б
                             PrevBonusDate    IN DATE,    -- Дата предыдущего начисления
                             PrevBonus        IN NUMBER,  -- Предыдущее начисление
                             Bonus0           IN NUMBER   -- Начальная премия
                           ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret       NUMBER := NULL;
   BEGIN

      if(PrevBonusDate <> UnknownDate) THEN
         if(CalcDate < PrevBonusDate) THEN
            SetError( WRTOFF_ERROR_20225 );
         elsif((CalcDate = PrevBonusDate) AND (LinkKind NOT IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT))) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
           if( LinkKind IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT) ) then -- Погашение выпуска или Выкуп
               if( Bonus0 = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := Bonus0 - PrevBonus;
               end if;
           else
              if (Bonus0 = 0) then
                 v_Ret := 0.0;
              else
                 v_Ret := ROUND(WRTCalcBonusOwnOnDate(CalcDate, BegDate, FIID, Bonus0) - PrevBonus, 2);
              end if;
           end if;
         end if;

      EXCEPTION
         WHEN OTHERS THEN
           v_Ret := 0.0;
      END;

      if (v_Ret >= 0) then
         return v_Ret;
      else
         return 0;
      end if;
   END;--WRTCalcBonusOwn

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления суммы отсроченной разницы на размещенные ц/б. Используется в БО ОЭБ.
   FUNCTION WRTCalcDefDiffOwn( CalcDate         IN DATE,    -- Дата начисления
                               BegDate          IN DATE,    -- Дата начала начисления отсроченной разницы
                               LinkKind IN NUMBER, -- Вид связи списания
                               FIID             IN NUMBER,  -- ц/б
                               PrevDefDiffDate  IN DATE,    -- Дата предыдущего начисления
                               PrevDefDiff      IN NUMBER,  -- Ранее начисленная разница
                               BegDefDiff       IN NUMBER   -- Начальная отсроченная разница
                             ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret       NUMBER := NULL;
   BEGIN

      if(PrevDefDiffDate <> UnknownDate) THEN
         if(CalcDate < PrevDefDiffDate) THEN
            SetError( WRTOFF_ERROR_20257 );
         elsif((CalcDate = PrevDefDiffDate) AND (LinkKind NOT IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT))) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
            if( LinkKind IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT) ) then -- Погашение выпуска или Выкуп
               if( BegDefDiff = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := BegDefDiff - PrevDefDiff;
               end if;
           else
              if (BegDefDiff = 0) then
                 v_Ret := 0.0;
              else
                 v_Ret := ROUND(WRTCalcDefDiffOwnOnDate(CalcDate, BegDate, FIID, BegDefDiff) - PrevDefDiff, 2);
              end if;
            end if;
         end if;

      EXCEPTION
         WHEN OTHERS THEN
           v_Ret := 0.0;
      END;

      if (v_Ret != 0) then
         return v_Ret;
      else
         return 0;
      end if;
   END;--WRTCalcDefDiffOwn

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления суммы балансовой стоимости в ВН лота ОЭБ на дату. Используется в БО ОЭБ.
   FUNCTION WRTCalcBalanceCostOwnOnDate( SumID    IN NUMBER, -- Идентификатор лота
                                         OnDate   IN DATE    -- Дата расчета
                                       ) RETURN NUMBER DETERMINISTIC
   IS
      A              V_SCWRTHISTEX%ROWTYPE;
      v_BalanceCost  NUMBER := NULL;
      v_FaceFI       NUMBER := -1;
   BEGIN

      SELECT H.* INTO A
        FROM V_SCWRTHISTEX H
       WHERE H.T_SUMID    = SumID
         AND H.T_CHANGEDATE <= OnDate
         AND H.T_INSTANCE = ( SELECT MAX(B.T_INSTANCE)
                                FROM V_SCWRTHISTEX B
                               WHERE B.T_SUMID       = H.T_SUMID
                                 AND B.T_CHANGEDATE <= H.T_CHANGEDATE
                            );

     SELECT T_FACEVALUEFI INTO v_FaceFI
       FROM DFININSTR_DBT
      WHERE T_FIID = A.T_FIID;

      v_BalanceCost := A.T_COST - A.T_INTERESTINCOME - A.T_DISCOUNTINCOME
                                + A.T_BONUS - A.T_WRTOUTLAY - RSI_RSB_FIInstr.ConvSum(A.T_WRTVATOUTLAY, RSI_RSB_FIInstr.NATCUR, v_FaceFI, A.T_WRTOUTLAYDATE, 1 )
                                + A.T_CORRVALUE;

      return v_BalanceCost;

      EXCEPTION
         WHEN OTHERS THEN return 0;
   END;--WRTCalcBalanceCostOwnOnDate

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления суммы затрат на размещенные ц/б. Используется в БО ОЭБ.
   FUNCTION WRTCalcWrtOutlayOwn( CalcDate          IN DATE,    -- Дата начисления
                                 BegDate           IN DATE,    -- Дата начала начисления затрат
                                 LinkKind IN NUMBER, -- Вид связи списания
                                 FIID              IN NUMBER,  -- ц/б
                                 PrevWrtOutlayDate IN DATE,    -- Дата предыдущего начисления
                                 PrevWrtOutlay     IN NUMBER,  -- Ранее начисленные затраты
                                 BegWrtOutlay      IN NUMBER   -- Начальные затраты
                               ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret       NUMBER := NULL;
   BEGIN

      if(PrevWrtOutlayDate <> UnknownDate) THEN
         if(CalcDate < PrevWrtOutlayDate) THEN
            SetError( WRTOFF_ERROR_20257 );
         elsif((CalcDate = PrevWrtOutlayDate) AND (LinkKind NOT IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT))) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
            if( LinkKind IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT) ) then -- Погашение выпуска или Выкуп
               if( BegWrtOutlay = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := BegWrtOutlay - PrevWrtOutlay;
               end if;
           else
              if (BegWrtOutlay = 0) then
                 v_Ret := 0.0;
             else
                 v_Ret := ROUND(WRTCalcWrtOutlayOwnOnDate(CalcDate, BegDate, FIID, BegWrtOutlay) - PrevWrtOutlay, 2);
              end if;
            end if;
         end if;

      EXCEPTION
         WHEN OTHERS THEN
           v_Ret := 0.0;
      END;

      if (v_Ret >= 0) then
         return v_Ret;
      else
         return 0;
      end if;
   END;--WRTCalcWrtOutlayOwn

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления суммы НДС затрат на размещенные ц/б. Используется в БО ОЭБ.
   FUNCTION WRTCalcVatOutlayOwn( CalcDate          IN DATE,    -- Дата начисления
                                 BegDate           IN DATE,    -- Дата начала начисления НДС затрат
                                 LinkKind IN NUMBER, -- Вид связи списания
                                 FIID              IN NUMBER,  -- ц/б
                                 PrevVatOutlayDate IN DATE,    -- Дата предыдущего начисления
                                 PrevVatOutlay     IN NUMBER,  -- Ранее начисленный НДС затрат
                                 BegVatOutlay      IN NUMBER   -- Начальный НДС затрат
                               ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret       NUMBER := NULL;
   BEGIN

      if(PrevVatOutlayDate <> UnknownDate) THEN
         if(CalcDate < PrevVatOutlayDate) THEN
            SetError( WRTOFF_ERROR_20257 );
         elsif((CalcDate = PrevVatOutlayDate) AND (LinkKind NOT IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT))) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
            if( LinkKind IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT) ) then -- Погашение выпуска или Выкуп
               if( BegVatOutlay = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := BegVatOutlay - PrevVatOutlay;
               end if;
           else
              if (BegVatOutlay = 0) then
                 v_Ret := 0.0;
              else
                 v_Ret := ROUND(WRTCalcVatOutlayOwnOnDate(CalcDate, BegDate, FIID, BegVatOutlay) - PrevVatOutlay, 2);
              end if;
            end if;
         end if;

      EXCEPTION
         WHEN OTHERS THEN
           v_Ret := 0.0;
      END;

      if (v_Ret >= 0) then
         return v_Ret;
      else
         return 0;
      end if;
   END;--WRTCalcVatOutlayOwn

   ----------------------------------------------------------------------------------------------------------------------
   -- Вычисление процентного расхода на размещенные ц/б.
   FUNCTION WRTCalcInterestExpenseOwn( CalcDate         IN DATE,   -- Дата начисления
                                       PlaceDate        IN DATE,   -- Дата начала начисления ПКД
                                       LnkKind          IN NUMBER, -- Вид связи списания
                                       FIID             IN NUMBER, -- ц/б
                                       Amount           IN NUMBER, -- Количество
                                       NKD              IN NUMBER, -- Сумма НКД
                                       PrevInterestDate IN DATE,   -- Дата предыдущего начисления
                                       PrevInterest     IN NUMBER, -- Предыдущее начисление
                                       Coupon           IN VARCHAR2 DEFAULT NULL, -- Номер купона
                                       CorrectDate      IN NUMBER DEFAULT 0--  Признак коррекции последней даты месяца
                                                                   --   0 - CalcDate не корректируется в соответствии с базисом расчета (умолч.)
                                                                   --   1 - CalcDate корректируется в соответствии с базисом расчета
                                     ) RETURN NUMBER DETERMINISTIC
   IS
      v_HasCoupon BOOLEAN := FALSE;
      v_NKDCourse NUMBER  := 0;
      v_Ret       NUMBER  := NULL;
   BEGIN

      if(PrevInterestDate <> UnknownDate) THEN
         if(CalcDate < PrevInterestDate) THEN
            SetError( WRTOFF_ERROR_20253 );
         elsif(CalcDate = PrevInterestDate) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN

        v_HasCoupon := RSI_RSB_FIInstr.FI_HasCoupon( FIID );
        if(v_HasCoupon = true) THEN
           v_NKDCourse := RSI_RSB_FIInstr.FindNKDCource( FIID, CalcDate, 0 );
        end if;

      EXCEPTION
         WHEN OTHERS THEN NULL;
      END;

      if(v_Ret is null) then
         if( LnkKind = PMWRTLINK_KIND_RETISSUE ) then -- Погашение выпуска
            if( v_HasCoupon = true ) then
               if( (Coupon is not NULL) AND (Coupon != chr(1)) AND (Coupon != chr(0)) ) then
                  if( v_NKDCourse >= 0 ) then
                     v_Ret := ROUND((Amount * v_NKDCourse) - PrevInterest - NKD, 2);
                  else
                     v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, Coupon, Amount ) - PrevInterest - NKD, 2);
                  end if;
               else
                  v_Ret := 0;
               end if;
            else
               v_Ret := ROUND( RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, 0, Amount ) -
                               RSI_RSB_FIInstr.FI_CalcIncomeValue(FIID, PlaceDate, Amount, 1) -
                               PrevInterest, 2
                             );
            end if;

         elsif( LnkKind = PMWRTLINK_KIND_RETCOUPON ) then -- Погашение купона

            if( (Coupon is not NULL) AND (Coupon != chr(1)) AND (Coupon != chr(0)) ) then
               if( v_NKDCourse >= 0 ) then
                  v_Ret := ROUND((Amount * v_NKDCourse) - PrevInterest - NKD, 2);
               else
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcTotalIncome( FIID, Coupon, Amount ) - PrevInterest - NKD, 2);
               end if;
            else
               v_Ret := 0;
            end if;

         else
            if( v_HasCoupon = true ) then
               if( CalcDate <> PlaceDate ) then
                  if( v_NKDCourse >= 0 ) then
                     v_Ret := ROUND((Amount * v_NKDCourse) - PrevInterest - NKD, 2);
                  else
                     v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, CalcDate, Amount, 1, CorrectDate ) - PrevInterest - NKD, 2);
                  end if;
               else
                  v_Ret := 0;
               end if;
            else
               if( PrevInterestDate = UnknownDate ) then
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, CalcDate, Amount, 1, CorrectDate ) -
                                 RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, PlaceDate, Amount, 1 ), 2);
               else
                  v_Ret := ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue( FIID, CalcDate, Amount, 1, CorrectDate ) - PrevInterest, 2);
               end if;
            end if;
         end if;
      end if;

      if (v_Ret >= 0) then
         return v_Ret;
      else
         return 0;
      end if;
   END; --WRTCalcInterestExpenseOwn

   ----------------------------------------------------------------------------------------------------------------------
   -- Вычисление дисконтного расхода на дату
   FUNCTION WRTCalcDiscountExpOwnOnDate( EndDate      IN DATE,   -- Дата окончания периода начисления
                                         BegDate      IN DATE,   -- Дата начала начисления ДД
                                         FIID         IN NUMBER, -- ц/б
                                         Discount0    IN NUMBER  -- Начальный дисконт
                                       ) RETURN NUMBER DETERMINISTIC
   IS
      v_DRAWINGDATE DATE;
      v_OFFERDATE DATE;
      v_EndDate DATE;
   BEGIN
      SELECT RSI_RSB_FIInstr.FI_GetNominalDrawingDate(F.t_FIID, (select t_Termless from davoiriss_dbt where t_FIID = F.t_FIID)) into v_DRAWINGDATE
        FROM DFININSTR_DBT F
       WHERE F.t_FIID = FIID;

      if CALC_AMORTOWN_BEFOREOFFER = CALC_AMORTOWN_BEFOREOFFER_YES then
         v_OFFERDATE := RSI_RSB_FIInstr.FI_GetOfferDate(FIID, EndDate/*BegDate*/);/*DAN*/
         if v_OFFERDATE != UnknownDate then
            v_DRAWINGDATE := v_OFFERDATE;
         end if;
      end if;

      v_EndDate := EndDate;
      if v_EndDate > v_DRAWINGDATE then
        v_EndDate := v_DRAWINGDATE;
      end if;

      if v_DRAWINGDATE = BegDate then
         return 0.0;
      else
         return round(Discount0 * (v_EndDate - BegDate) / (v_DRAWINGDATE - BegDate),2);
      end if;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
           RETURN 0.0;
         WHEN OTHERS THEN
           RETURN 0.0;

   END; --WRTCalcDiscountExpOwnOnDate

   ----------------------------------------------------------------------------------------------------------------------
   ----- Функция для вычисления дисконтного расхода на размещенные ц/б. Используется в БО ОЭБ.
   FUNCTION WRTCalcDiscountExpenseOwn( CalcDate         IN DATE,    -- Дата начисления
                                       BegDate          IN DATE,    -- Дата начала начисления ДД
                                       LnkKind          IN NUMBER,  -- Вид связи списания
                                       FIID             IN NUMBER,  -- ц/б
                                       PrevDiscountDate IN DATE,    -- Дата предыдущего начисления
                                       PrevDiscount     IN NUMBER,  -- Начисленный дисконт
                                       Discount0        IN NUMBER   -- Начального дисконта
                                     ) RETURN NUMBER DETERMINISTIC
   IS
      v_Ret  NUMBER := NULL;
   BEGIN

      if(PrevDiscountDate <> UnknownDate) THEN
         if(CalcDate < PrevDiscountDate) THEN
            SetError( WRTOFF_ERROR_20253 );
         elsif((CalcDate = PrevDiscountDate) AND (LnkKind NOT IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT))) THEN
            v_Ret := 0;
         end if;
      end if;

      BEGIN
         if(v_Ret is null) then
            if( LnkKind IN (PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_BUYOUT) ) then -- Погашение выпуска или Выкуп
               if( Discount0 = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := Discount0 - PrevDiscount;
               end if;
            else

               if( Discount0 = 0 ) then
                  v_Ret := 0;
               else
                  v_Ret := ROUND(WRTCalcDiscountExpOwnOnDate(CalcDate, BegDate, FIID, Discount0) - PrevDiscount, 2);
               end if;
            end if;
         end if;

      END;

      if (v_Ret >= 0) then
         return v_Ret;
      else
         return 0;
      end if;

   END;--WRTCalcDiscountExpenseOwn

   -- Выполняет списание лота погашения купона по лотам размещения.
   PROCEDURE RSI_WRTLinkWrtOwn( p_RetLot           IN OUT DPMWRTSUM_DBT%ROWTYPE,
                                p_ID_Operation     IN     NUMBER,  -- Операция и шаг, на которых выполняется списание
                                p_ID_Step          IN     NUMBER,  --
                                p_LinkKind         IN     NUMBER,  -- Вид создаваемой связи
                                p_Action           IN     NUMBER,  -- Вид изменения на лоте
                                p_CalcInterest     IN     BOOLEAN, -- Расчитывать процентный доход
                                p_CalcDiscount     IN     BOOLEAN, -- Расчитывать дисконтный доход
                                p_CalcBonus        IN     BOOLEAN, -- Расчитывать премию
                                p_CalcDefDiff      IN     BOOLEAN, -- Рассчитывать отложенную разницу
                                p_CalcOutlay       IN     BOOLEAN  -- Рассчитывать существенные затраты
                              )
   IS
     v_PlaceLot   DPMWRTSUM_DBT%ROWTYPE;
     v_Link       DPMWRTLNK_DBT%ROWTYPE;
     v_PlaceAmount       NUMBER;
     v_SL                NUMBER;
     v_AmountRate        NUMBER;
     v_Amount            NUMBER;
     v_TMPLNKID          NUMBER;
     v_CalcDate          DATE;
     v_WrtSumTmp DPMWRTSUM_TMP%ROWTYPE;

     TYPE LotsCurTyp IS REF CURSOR;
     Lots LotsCurTyp;

   BEGIN
     InitError();

     IF( p_RetLot.t_Date < RsbSessionData.curdate ) THEN

        if( WRTAreChangesAfterDateOwn( p_RetLot.t_Department,
                                       p_RetLot.T_FIID,
                                       p_RetLot.T_DATE,
                                       UnknownTime,
                                       p_RetLot.T_DATE,
                                       1,
                                       p_RetLot.T_COUPON
                                     ) = True ) then
           SetError( WRTOFF_ERROR_20201, to_char(p_RetLot.t_SUMID) );
        END IF;
     END IF;

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     v_Amount   := p_RetLot.T_AMOUNT;
     v_TMPLNKID := 1;

     WHILE( v_Amount > 0 ) LOOP

        BEGIN
          IF SortingLotsAmount = SORTING_LOTS_AMOUNT_ASC THEN
            SELECT * INTO v_PlaceLot
              FROM
              (
                SELECT /*+ INDEX( PlaceLot DPMWRTSUM_DBT_IDXA)*/ PlaceLot.*
                  FROM DPMWRTSUM_DBT PlaceLot
                 WHERE PlaceLot.t_Department = p_RetLot.t_Department AND
                       PlaceLot.t_FIID       = p_RetLot.t_FIID AND
                       PlaceLot.t_Party      = p_RetLot.t_Party AND
                       PlaceLot.t_State      = PM_WRTSUM_PLACE_OWN AND
                       PlaceLot.t_Date      <= p_RetLot.t_Date  AND
                       ((PlaceLot.T_ACTIVATEDATE < p_RetLot.T_DATE) OR ((PlaceLot.T_ACTIVATEDATE = p_RetLot.T_DATE) and (PlaceLot.T_ACTIVATETIME <= p_RetLot.T_TIME))) AND
                       PlaceLot.t_Amount    > (SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
                                               FROM DPMWRTLNK_DBT  Link
                                              WHERE     Link.T_BUYID = PlaceLot.T_SUMID
                                                    AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/)
                                                    AND Link.T_COUPON = p_RetLot.T_COUPON
                                             ) + (select NVL(SUM(TMP.T_AMOUNT),0)
                                                    from DPMWRTLNK_TMP TMP
                                                   where TMP.T_BUYID = PlaceLot.T_SUMID)
                 AND NOT EXISTS (SELECT t_LnkID FROM DPMWRTLNK_DBT WHERE t_BuyID = PlaceLot.t_SumID AND t_SaleID = p_RetLot.t_SumID)
                ORDER BY t_Date ASC, t_Time ASC, T_DealDate ASC, T_SortCode ASC, T_Amount ASC
              )
             WHERE ROWNUM = 1;
           ELSE
             SELECT * INTO v_PlaceLot
              FROM
              (
                SELECT /*+ INDEX( PlaceLot DPMWRTSUM_DBT_IDXB)*/ PlaceLot.*
                  FROM DPMWRTSUM_DBT PlaceLot
                 WHERE PlaceLot.t_Department = p_RetLot.t_Department AND
                       PlaceLot.t_FIID       = p_RetLot.t_FIID AND
                       PlaceLot.t_Party      = p_RetLot.t_Party AND
                       PlaceLot.t_State      = PM_WRTSUM_PLACE_OWN AND
                       PlaceLot.t_Date      <= p_RetLot.t_Date  AND
                       ((PlaceLot.T_ACTIVATEDATE < p_RetLot.T_DATE) OR ((PlaceLot.T_ACTIVATEDATE = p_RetLot.T_DATE) and (PlaceLot.T_ACTIVATETIME <= p_RetLot.T_TIME))) AND
                       PlaceLot.t_Amount    > (SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
                                               FROM DPMWRTLNK_DBT  Link
                                              WHERE     Link.T_BUYID = PlaceLot.T_SUMID
                                                    AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/)
                                                    AND Link.T_COUPON = p_RetLot.T_COUPON
                                             ) + (select NVL(SUM(TMP.T_AMOUNT),0)
                                                    from DPMWRTLNK_TMP TMP
                                                   where TMP.T_BUYID = PlaceLot.T_SUMID)
                 AND NOT EXISTS (SELECT t_LnkID FROM DPMWRTLNK_DBT WHERE t_BuyID = PlaceLot.t_SumID AND t_SaleID = p_RetLot.t_SumID)
                ORDER BY t_Date ASC, t_Time ASC, T_DealDate ASC, T_SortCode ASC, T_Amount DESC
              )
             WHERE ROWNUM = 1;
           END IF;
        EXCEPTION
           WHEN NO_DATA_FOUND THEN EXIT;--выходим именно из цикла, а не из процедуры (это важно - дальше нас ждет начисление ПДД и линковка)
           WHEN OTHERS THEN RETURN;
        END;

        IF p_LinkKind = PMWRTLINK_KIND_RETADDINCOME THEN
          SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
            INTO v_SL
            FROM DPMWRTLNK_DBT  Link
           WHERE     Link.T_BUYID = v_PlaceLot.T_SUMID
                 AND Link.T_KIND in (PMWRTLINK_KIND_RETADDINCOME /*Погашение доп. дохода*/);
        ELSE

          SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
            INTO v_SL
            FROM DPMWRTLNK_DBT  Link
           WHERE     Link.T_BUYID = v_PlaceLot.T_SUMID
                 AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/)
                 AND Link.T_COUPON = p_RetLot.T_COUPON;
        END IF;

        INSERT INTO DPMWRTLNK_TMP
                   ( T_ID,
                     T_BUYID,
                     T_AMOUNT )
            VALUES ( v_TMPLNKID,
                     v_PlaceLot.T_SUMID,
                     v_PlaceLot.T_AMOUNT
                     );

        v_Amount   := v_Amount - (v_PlaceLot.T_AMOUNT - v_SL);
        v_TMPLNKID := v_TMPLNKID + 1;

     END LOOP;

     IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or p_CalcDefDiff = true or p_CalcOutlay = true) THEN

        v_CalcDate := RSI_RSB_FIInstr.FI_GetCouponDrawingDate( p_RetLot.T_FIID, p_RetLot.t_Coupon );

        --Выполнить начисление во временную таблицу
        --Фактически - начисление по всем лотам из DPMWRTLNK_TMP, а не по всем лотам размещения, как при начислении ПДД
        RSI_WRTChargeExpToOwnLotsTMP (true, p_RetLot.T_DATE, v_CalcDate, p_RetLot.T_FIID, p_RetLot.T_Department,
                                      p_CalcInterest,
                                      p_CalcDiscount,
                                      p_CalcBonus,
                                      p_CalcDefDiff,
                                      p_CalcOutlay,
                                      false,
                                      p_LinkKind,
                                      p_RetLot.T_COUPON,
                                      false
                                     );
     END IF;

     OPEN Lots FOR SELECT L.* INTO v_PLACELOT
                     FROM DPMWRTSUM_DBT L, DPMWRTLNK_TMP TMP
                    WHERE L.T_SUMID = TMP.T_BUYID
                   ORDER BY T_ID ASC;
     LOOP

        FETCH Lots INTO v_PLACELOT;
        EXIT WHEN Lots%NOTFOUND OR
                  Lots%NOTFOUND IS NULL;

        IF p_LinkKind = PMWRTLINK_KIND_RETADDINCOME THEN
          SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
            INTO v_SL
            FROM DPMWRTLNK_DBT  Link
           WHERE     Link.T_BUYID = v_PLACELOT.T_SUMID
                 AND Link.T_KIND in (PMWRTLINK_KIND_RETADDINCOME /*Погашение доп. дохода*/);
        ELSE

          SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
            INTO v_SL
            FROM DPMWRTLNK_DBT  Link
           WHERE     Link.T_BUYID = v_PLACELOT.T_SUMID
                 AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/)
                 AND Link.T_COUPON = p_RetLot.T_COUPON;
        END IF;

        v_PlaceAmount     := v_PlaceLot.T_AMOUNT - v_SL;
        v_AmountRate      := v_PlaceAmount / v_PlaceLot.T_AMOUNT;

        v_PlaceLot.T_AMOUNT           := v_PlaceAmount;
        v_PlaceLot.T_COST             := ROUND(v_PlaceLot.T_COST * v_AmountRate,2);
        v_PlaceLot.T_NKDAMOUNT        := ROUND(v_PlaceLot.T_NKDAMOUNT * v_AmountRate,2);
        v_PlaceLot.T_INTERESTINCOME   := ROUND(v_PlaceLot.T_INTERESTINCOME * v_AmountRate,2);
        v_PlaceLot.T_BEGDISCOUNT      := ROUND(v_PlaceLot.T_BEGDISCOUNT * v_AmountRate,2);
        v_PlaceLot.T_DISCOUNTINCOME   := ROUND(v_PlaceLot.T_DISCOUNTINCOME * v_AmountRate,2);
        v_PlaceLot.T_OUTLAY           := ROUND(v_PlaceLot.T_OUTLAY * v_AmountRate,2);
        v_PlaceLot.T_BEGBONUS         := ROUND(v_PlaceLot.T_BEGBONUS * v_AmountRate,2);
        v_PlaceLot.T_BONUS            := ROUND(v_PlaceLot.T_BONUS * v_AmountRate,2);
        v_PlaceLot.T_BEGDEFDIFF       := ROUND(v_PlaceLot.T_BEGDEFDIFF * v_AmountRate,2);
        v_PlaceLot.T_ACCOUNTEDDEFDIFF := ROUND(v_PlaceLot.T_ACCOUNTEDDEFDIFF * v_AmountRate,2);
        v_PlaceLot.T_WRTOUTLAY        := ROUND(v_PlaceLot.T_WRTOUTLAY * v_AmountRate,2);
        v_PlaceLot.T_VATOUTLAY        := ROUND(v_PlaceLot.T_VATOUTLAY * v_AmountRate,2);
        v_PlaceLot.T_WRTVATOUTLAY     := ROUND(v_PlaceLot.T_WRTVATOUTLAY * v_AmountRate,2);
        v_PlaceLot.T_FAIRVALUE        := ROUND(v_PlaceLot.T_FAIRVALUE * v_AmountRate,2);
        v_PlaceLot.T_AMORTCOST        := ROUND(v_PlaceLot.T_AMORTCOST * v_AmountRate,2);
        v_PlaceLot.T_CORRVALUE        := ROUND(v_PlaceLot.T_CORRVALUE * v_AmountRate,2);
        v_PlaceLot.T_ESTRESERVE       := ROUND(v_PlaceLot.T_ESTRESERVE * v_AmountRate,2);
        v_PlaceLot.T_CORRESTRESERVE   := ROUND(v_PlaceLot.T_CORRESTRESERVE * v_AmountRate,2);

        -- выполнить списание
        v_Link.t_LnkID               := 0;
        v_Link.t_SaleID              := p_RetLot.t_SumID;
        v_Link.t_BuyID               := v_PlaceLot.t_SumID;
        v_Link.t_Kind                := p_LinkKind;
        v_Link.t_InterestIncomeAdd   := 0;
        v_Link.t_DiscountIncomeAdd   := 0;
        v_Link.t_DiscountIncomeBuy   := 0;
        v_Link.t_BonusBuy            := 0;
        v_Link.t_OldBonusBuy         := 0;
        v_Link.t_BonusAdd            := 0;
        v_Link.t_OutlaySale          := 0;
        v_Link.t_ReservChange        := 0;
        v_Link.t_IncomeReservChange  := 0;
        v_Link.t_OverChange          := 0;
        v_Link.t_BalanceCostBD       := 0;
        v_Link.t_OverChangeBD        := 0;
        v_Link.t_BlockAmountBuy      := 0;
        v_Link.t_InterestIncomeBuy   := 0;
        v_Link.t_NotCarryInterestBuy := 0;
        v_Link.T_NOTCARRYINTERESTADD := 0;
        v_Link.t_BegDiscountChange   := 0;
        v_Link.t_OldBegDiscountChange:= 0;
        v_Link.T_DISCOUNTCORRCHANGE  := 0;
        v_Link.t_BegBonusChange      := 0;
        v_Link.T_OLDBEGBONUSCHANGE   := 0;
        v_Link.t_NotCarryDiscountBuy := 0;
        v_Link.T_NOTCARRYDISCOUNTADD := 0;
        v_Link.t_Coupon              := p_RetLot.t_Coupon;
        v_Link.t_Partly              := 0;
        v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
        v_Link.T_ACCOUNTEDDEFDIFFBUY := 0;
        v_Link.T_BEGDEFDIFFCHANGE    := 0;
        v_Link.T_WRTOUTLAYADD        := 0;
        v_Link.T_WRTOUTLAYBUY        := 0;
        v_Link.T_WRTVATOUTLAYADD     := 0;
        v_Link.T_WRTVATOUTLAYBUY     := 0;
        v_Link.T_VATOUTLAYCHANGE     := 0;
        v_Link.t_BalanceCostSale     := 0;
        v_Link.t_BalanceCostBuy      := 0;
        v_Link.t_OutlayBuy           := 0;
        v_Link.T_NOTWRTBONUSBUY      := 0;
        v_Link.T_COSTPFIBUY          := 0;
        v_Link.t_SumBuy              := 0;
        v_Link.t_ID_Operation        := p_ID_Operation;
        v_Link.t_ID_Step             := p_ID_Step;
        v_Link.t_Action              := p_Action;
        v_Link.t_CreateDate          := p_RetLot.t_Date;
        v_Link.T_FAIRVALUECHANGE     := 0;
        v_Link.T_AMORTCOSTCHANGE     := 0;
        v_Link.T_CORRVALUECHANGE     := 0;
        v_Link.T_ESTRESERVCHANGE     := 0;
        v_Link.T_CORRINTTOEIRCHANGE  := 0;
        v_Link.T_CORRESTRESERVCHANGE := 0;
        v_Link.T_ADDINCOMEOWNCHANGE  := 0;

        IF( v_PlaceLot.t_Amount <= p_RetLot.t_Amount ) THEN   -- погасить лот полностью
           v_AmountRate                 := v_PlaceLot.t_Amount / p_RetLot.t_Amount;

           v_Link.t_Amount              := v_PlaceLot.t_Amount;
           v_Link.t_SumSale             := ROUND(p_RetLot.t_Sum * v_AmountRate,2);
           v_Link.t_CostSale            := ROUND(p_RetLot.t_Cost * v_AmountRate,2);
           v_Link.t_CostBuy             := v_Link.t_CostSale;
           v_Link.t_NKDSaleAmount       := ROUND(p_RetLot.t_NKDAmount * v_AmountRate,2);

           IF (p_RetLot.t_Coupon != chr(1)) THEN
              v_Link.t_NKDBuyAmount      := v_PlaceLot.t_NKDAmount;
              v_Link.t_InterestIncomeBuy := v_PlaceLot.t_InterestIncome;
           ELSE
              v_Link.t_NKDBuyAmount     := 0;
           END IF;

           IF p_LinkKind = PMWRTLINK_KIND_RETADDINCOME THEN
             v_Link.t_AddIncomeOwnChange := v_PlaceLot.t_AddIncomeOwn;
           END IF;

        ELSE
           v_AmountRate                 := p_RetLot.t_Amount / v_PlaceLot.t_Amount;

           v_Link.t_Amount              := p_RetLot.t_Amount;
           v_Link.t_SumSale             := p_RetLot.t_Sum;
           v_Link.t_CostSale            := p_RetLot.t_Cost;
           v_Link.t_CostBuy             := v_Link.t_CostSale;
           v_Link.t_NKDSaleAmount       := p_RetLot.t_NKDAmount;

           IF (p_RetLot.t_Coupon != chr(1)) THEN
              v_Link.t_NKDBuyAmount      := ROUND(v_PlaceLot.t_NKDAmount * v_AmountRate,2);
              v_Link.t_InterestIncomeBuy := ROUND(v_PlaceLot.t_InterestIncome * v_AmountRate,2);
           ELSE
              v_Link.t_NKDBuyAmount        := 0;
           END IF;

           IF p_LinkKind = PMWRTLINK_KIND_RETADDINCOME THEN
             v_Link.t_AddIncomeOwnChange := ROUND(v_PlaceLot.t_AddIncomeOwn * v_AmountRate,2);
           END IF;

        END IF;

        IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or p_CalcDefDiff = true or p_CalcOutlay = true ) THEN
           BEGIN
             SELECT TMP.* into v_WrtSumTmp
               FROM DPMWRTSUM_TMP TMP
              WHERE TMP.T_SUMID = v_PlaceLot.T_SUMID;
           EXCEPTION
           WHEN OTHERS THEN
               SetError( WRTOFF_ERROR_20254 );
           END;

           if v_WrtSumTmp.T_AMOUNT = 0 then
              v_Link.T_INTERESTINCOMEADD   := 0;
              v_Link.T_DISCOUNTINCOMEADD   := 0;
              v_Link.T_BONUSADD            := 0;
              v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
              v_Link.T_WRTOUTLAYADD        := 0;
              v_Link.T_WRTVATOUTLAYADD     := 0;
           else
              v_Link.T_INTERESTINCOMEADD   := ROUND(v_WrtSumTmp.T_INTERESTADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_DISCOUNTINCOMEADD   := ROUND(v_WrtSumTmp.T_DISCOUNTADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_BONUSADD            := ROUND(v_WrtSumTmp.T_BONUSADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_ACCOUNTEDDEFDIFFADD := ROUND(v_WrtSumTmp.T_DEFDIFFADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_WRTOUTLAYADD        := ROUND(v_WrtSumTmp.T_WRTOUTLAYADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_WRTVATOUTLAYADD     := ROUND(v_WrtSumTmp.T_VATOUTLAYADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
           end if;
        END IF;

        BEGIN
           RSI_InsDfltIntoWRTLNK(v_Link);
           INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

           p_RetLot.t_Amount      := p_RetLot.t_Amount    - v_Link.t_Amount;
           p_RetLot.t_Sum         := p_RetLot.t_Sum       - v_Link.t_SumSale;
           p_RetLot.t_Cost        := p_RetLot.t_Cost      - v_Link.t_CostSale;
           p_RetLot.t_NKDAmount   := p_RetLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
        END;

     END LOOP;

     CLOSE Lots;

   END; -- RSI_WRTLinkWrtOwn

   ----------------------------------------------------------------------------------------------------------------------
 -- Функция для вычисления суммы отсроченной разницы на дату. Используется в БО ЦБ.
 FUNCTION WRTCalcDefDiffOnDate( CalcDate IN DATE, -- Дата начисления
                                BegDate IN DATE, -- Дата начала начисления отсроченной разницы
                                FIID IN NUMBER, -- ц/б
                                BegDefDiff IN NUMBER -- Начальная отсроченная разница
                              ) RETURN NUMBER DETERMINISTIC
 IS
    v_DRAWINGDATE DATE;
    v_R0          NUMBER;
    v_PARTSUM     NUMBER;
    v_TERMLESS    CHAR;
    v_CalcDate    DATE;
    v_IsOffer     NUMBER;
    v_OfferDate    DATE;
 BEGIN

    IF( CALC_DEFDIFF_WITHOUT_PARTLY = DEFDIFF_WITHOUT_PARTLY_YES OR RSI_RSB_FIInstr.FI_HasPartialDischarge(FIID) = FALSE ) THEN

       v_DRAWINGDATE := rsb_secur.SC_GetTopCalcDate(RSB_SECUR.CALCKIND_AVR, FIID, CalcDate, v_IsOffer, v_TERMLESS, v_OfferDate);
       v_CalcDate := CASE WHEN CalcDate > v_DRAWINGDATE THEN v_DRAWINGDATE ELSE CalcDate END;

       if v_DRAWINGDATE = BegDate then
          return 0.0;
       else
          return ROUND( BegDefDiff * (v_CalcDate - BegDate) / (v_DRAWINGDATE - BegDate),2);
       end if;

    ELSE
       v_R0 := 100.0 - RSI_RSB_FIInstr.FI_GetPartialPersent(FIID, BegDate);

       SELECT NVL(SUM(BegDefDiff * T_INCOMERATE * (CalcDate - BegDate) /
                  (v_R0 * (T_DRAWINGDATE - BegDate))
                 ),0) INTO v_PARTSUM
         FROM DFIWARNTS_DBT
        WHERE t_FIID = FIID
          AND T_ISPARTIAL = chr(88)
          AND T_DRAWINGDATE > BegDate
          AND T_DRAWINGDATE > CalcDate;

       return round(v_PARTSUM,2);
    END IF;

 EXCEPTION
    WHEN NO_DATA_FOUND THEN
       RETURN 0.0;
    WHEN OTHERS THEN
       RETURN 0.0;
 END; --WRTCalcDefDiffOnDate

 ----------------------------------------------------------------------------------------------------------------------
 -- Функция для вычисления суммы отсроченной разницы. Используется в БО ЦБ.
 FUNCTION WRTCalcDefDiff( CalcDate        IN DATE,   -- Дата начисления
                          BegDate         IN DATE,   -- Дата начала начисления отсроченной разницы
                          FIID            IN NUMBER, -- ц/б
                          Amount          IN NUMBER, -- Количество
                          PrevDefDiffDate IN DATE,   -- Дата предыдущего начисления
                          PrevDefDiff     IN NUMBER, -- Ранее начисленная разница
                          BegDefDiff      IN NUMBER, -- Начальная отсроченная разница
                          Party           IN NUMBER,
                          Contract        IN NUMBER
                          ) RETURN NUMBER DETERMINISTIC
 IS
   v_Ret NUMBER := NULL;
 BEGIN

   if(PrevDefDiffDate <> UnknownDate) THEN
     if(CalcDate < PrevDefDiffDate) THEN
       SetError( WRTOFF_ERROR_20257 );
     elsif(CalcDate = PrevDefDiffDate) THEN
       v_Ret := 0;
     end if;
   end if;

   BEGIN
     if(v_Ret is null) then
       IF( GetAmortizationMethod( Party, Contract ) = PM_WRITEOFF_AVERAGE
         ) THEN
           IF (ABS(BegDefDiff) - ABS(PrevDefDiff) <= 0) THEN
              v_Ret := 0.0;
           ELSE
              v_Ret := ROUND(WRTCalcDefDiffOnDate(CalcDate, BegDate, FIID, BegDefDiff - PrevDefDiff), 2);
           END IF;
       ELSE
         if (BegDefDiff = 0) then
           v_Ret := 0.0;
         else
           v_Ret := ROUND(WRTCalcDefDiffOnDate(CalcDate, BegDate, FIID, BegDefDiff) - PrevDefDiff, 2);
         end if;
       END IF;
     end if;

     EXCEPTION
       WHEN OTHERS THEN
         v_Ret := 0.0;
   END;

   if (v_Ret != 0) then
     return v_Ret;
   else
     return 0;
   end if;

 END; --WRTCalcDefDiff
 ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет сохранение архивных данных лота
   ----- Используется, в частности, при внесении изменений в лот на шагах. Должна быть вызвана перед изменением лота
   ----- Ошибки возвращаемые процедурой.
   -----  WRTOFF_ERROR_20200    CONSTANT INTEGER := -20200; --Не найден лот
   -----  WRTOFF_ERROR_20201    CONSTANT INTEGER := -20201; --Для лота %s есть операции за более позднюю дату
   -----  WRTOFF_ERROR_20202    CONSTANT INTEGER := -20202; --Операция выполнила данное изменение более ранней датой
   -----  WRTOFF_ERROR_20203    CONSTANT INTEGER := -20203; --Операция уже выполнила данное изменение

   PROCEDURE RSI_WRTSaveLot( p_SumID IN NUMBER, p_ID_Operation IN NUMBER, p_ID_Step IN NUMBER, p_ChangeDate IN DATE, p_Action IN NUMBER )
   IS
     v_pmwrtsum DPMWRTSUM_DBT%ROWTYPE;
     v_pmwrtbc  DPMWRTBC_DBT%ROWTYPE;
     v_Count    NUMBER;
   BEGIN
     InitError();

     BEGIN
       SELECT * INTO v_pmwrtsum
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SumID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;
     -- 1.   Если  SumID->DPMWRTSUM.T_CHANGEDATE > ChangeDate   ошибка "По лоту были операции за более позднюю дату"
     IF( v_pmwrtsum.t_ChangeDate > p_ChangeDate ) THEN
        SetError( WRTOFF_ERROR_20201, to_char(p_SumID) );
     END IF;

     -- 2.  Создать запись в PMWRTBC
     BEGIN
       v_pmwrtbc.t_SumID            := v_pmwrtsum.t_SumID;
       v_pmwrtbc.t_ID_Operation     := v_pmwrtsum.t_ID_Operation;
       v_pmwrtbc.t_ID_Step          := v_pmwrtsum.t_ID_Step;
       v_pmwrtbc.t_Action           := v_pmwrtsum.t_Action;
       v_pmwrtbc.t_Instance         := v_pmwrtsum.t_Instance;
       v_pmwrtbc.t_ChangeDate       := v_pmwrtsum.t_ChangeDate;
       v_pmwrtbc.t_FIID             := v_pmwrtsum.t_FIID;
       v_pmwrtbc.t_Portfolio        := v_pmwrtsum.t_Portfolio;
       v_pmwrtbc.t_GroupID          := v_pmwrtsum.t_GroupID;
       v_pmwrtbc.t_Date             := v_pmwrtsum.t_Date;
       v_pmwrtbc.t_Time             := v_pmwrtsum.t_Time;
       v_pmwrtbc.t_Amount           := v_pmwrtsum.t_Amount;
       v_pmwrtbc.t_AmountBD         := v_pmwrtsum.t_AmountBD;
       v_pmwrtbc.t_Sum              := v_pmwrtsum.t_Sum;
       v_pmwrtbc.t_Currency         := v_pmwrtsum.t_Currency;
       v_pmwrtbc.t_Cost             := v_pmwrtsum.t_Cost;
       v_pmwrtbc.t_BalanceCost      := v_pmwrtsum.t_BalanceCost;
       v_pmwrtbc.t_BalanceCostBD    := v_pmwrtsum.t_BalanceCostBD;
       v_pmwrtbc.t_NKDAmount        := v_pmwrtsum.t_NKDAmount;
       v_pmwrtbc.t_InterestIncome   := v_pmwrtsum.t_InterestIncome;
       v_pmwrtbc.t_NotCarryInterest := v_pmwrtsum.t_NotCarryInterest;
       v_pmwrtbc.t_InterestDate     := v_pmwrtsum.t_InterestDate;
       v_pmwrtbc.t_BegDate          := v_pmwrtsum.t_BegDate;
       v_pmwrtbc.t_BegDiscount      := v_pmwrtsum.t_BegDiscount;
       v_pmwrtbc.t_OldBegDate       := v_pmwrtsum.t_OldBegDate;
       v_pmwrtbc.t_OldBegDiscount   := v_pmwrtsum.t_OldBegDiscount;
       v_pmwrtbc.t_DiscountIncome   := v_pmwrtsum.t_DiscountIncome;
       v_pmwrtbc.t_NotCarryDiscount := v_pmwrtsum.t_NotCarryDiscount;
       v_pmwrtbc.t_DiscountDate     := v_pmwrtsum.t_DiscountDate;
       v_pmwrtbc.t_Outlay           := v_pmwrtsum.t_Outlay;
       v_pmwrtbc.t_ReservAmount     := v_pmwrtsum.t_ReservAmount;
       v_pmwrtbc.t_IncomeReserv     := v_pmwrtsum.t_IncomeReserv;
       v_pmwrtbc.t_ReservDate       := v_pmwrtsum.t_ReservDate;
       v_pmwrtbc.t_OverAmount       := v_pmwrtsum.t_OverAmount;
       v_pmwrtbc.t_OverAmountBD     := v_pmwrtsum.t_OverAmountBD;
       v_pmwrtbc.t_OverDate         := v_pmwrtsum.t_OverDate;
       v_pmwrtbc.t_State            := v_pmwrtsum.t_State;
       v_pmwrtbc.t_StateDate        := v_pmwrtsum.t_StateDate;
       v_pmwrtbc.t_LnkRef           := 0;
       v_pmwrtbc.t_BegBonusDate     := v_pmwrtsum.t_BegBonusDate;
       v_pmwrtbc.t_BegBonus         := v_pmwrtsum.t_BegBonus    ;
       v_pmwrtbc.t_Bonus            := v_pmwrtsum.t_Bonus       ;
       v_pmwrtbc.t_OldBonus         := v_pmwrtsum.t_OldBonus    ;
       v_pmwrtbc.t_BonusDate        := v_pmwrtsum.t_BonusDate   ;
       v_pmwrtbc.t_BegInterestDate  := v_pmwrtsum.t_BegInterestDate;
       v_pmwrtbc.t_BegDiscountDate  := v_pmwrtsum.t_BegDiscountDate;
       v_pmwrtbc.t_DiscountCorr     := v_pmwrtsum.t_DiscountCorr   ;
       v_pmwrtbc.t_OldBegBonus      := v_pmwrtsum.t_OldBegBonus    ;
       v_pmwrtbc.t_RecalcDate       := v_pmwrtsum.t_RecalcDate     ;
       v_pmwrtbc.t_IsEdit           := v_pmwrtsum.t_IsEdit         ;
       v_pmwrtbc.T_NOTWRTBONUS      := v_pmwrtsum.T_NOTWRTBONUS;
       v_pmwrtbc.T_CostPFI          := v_pmwrtsum.T_CostPFI;
       v_pmwrtbc.t_ActivateDate     := v_pmwrtsum.t_ActivateDate;
       v_pmwrtbc.t_ActivateTime     := v_pmwrtsum.t_ActivateTime;
       v_pmwrtbc.t_BlockAmount      := v_pmwrtsum.t_BlockAmount;
       v_pmwrtbc.T_BEGDEFDIFF       := v_pmwrtsum.T_BEGDEFDIFF;
       v_pmwrtbc.T_ACCOUNTEDDEFDIFF := v_pmwrtsum.T_ACCOUNTEDDEFDIFF;
       v_pmwrtbc.T_DEFDIFFDATE      := v_pmwrtsum.T_DEFDIFFDATE;
       v_pmwrtbc.T_WRTOUTLAY        := v_pmwrtsum.T_WRTOUTLAY;
       v_pmwrtbc.T_WRTOUTLAYDATE    := v_pmwrtsum.T_WRTOUTLAYDATE;
       v_pmwrtbc.T_VATOUTLAY        := v_pmwrtsum.T_VATOUTLAY;
       v_pmwrtbc.T_WRTVATOUTLAY     := v_pmwrtsum.T_WRTVATOUTLAY;
       v_pmwrtbc.T_EFFECTINTERESTRATE := v_pmwrtsum.T_EFFECTINTERESTRATE;
       v_pmwrtbc.T_FAIRVALUE        := v_pmwrtsum.T_FAIRVALUE;
       v_pmwrtbc.T_AMORTCOST        := v_pmwrtsum.T_AMORTCOST;
       v_pmwrtbc.T_CORRVALUE        := v_pmwrtsum.T_CORRVALUE;
       v_pmwrtbc.T_CORRDATE         := v_pmwrtsum.T_CORRDATE;
       v_pmwrtbc.T_ACCBALANCECOST   := v_pmwrtsum.T_ACCBALANCECOST;
       v_pmwrtbc.T_ACCFI            := v_pmwrtsum.T_ACCFI;
       v_pmwrtbc.T_AMORTCALCKIND    := v_pmwrtsum.T_AMORTCALCKIND;
       v_pmwrtbc.T_ESTRESERVE       := v_pmwrtsum.T_ESTRESERVE;
       v_pmwrtbc.T_ESTRESERVEDATE   := v_pmwrtsum.T_ESTRESERVEDATE;
       v_pmwrtbc.T_CORRINTTOEIR     := v_pmwrtsum.T_CORRINTTOEIR;
       v_pmwrtbc.T_CORRINTTOEIRDATE := v_pmwrtsum.T_CORRINTTOEIRDATE;
       v_pmwrtbc.T_CORRESTRESERVE     := v_pmwrtsum.T_CORRESTRESERVE;
       v_pmwrtbc.T_CORRESTRESERVEDATE := v_pmwrtsum.T_CORRESTRESERVEDATE;
       v_pmwrtbc.T_BEGDEFDIFFDATE     := v_pmwrtsum.T_BEGDEFDIFFDATE;
       v_pmwrtbc.T_ADDINCOMEOWN     := v_pmwrtsum.T_ADDINCOMEOWN;
       v_pmwrtbc.T_ADDINCOMEOWNDATE := v_pmwrtsum.T_ADDINCOMEOWNDATE;
       v_pmwrtbc.T_HEDGCORR         := v_pmwrtsum.T_HEDGCORR;
       v_pmwrtbc.T_HEDGCORRDATE     := v_pmwrtsum.T_HEDGCORRDATE;
       v_pmwrtbc.T_AMORTHEDGCORR    := v_pmwrtsum.T_AMORTHEDGCORR;
       v_pmwrtbc.T_AMORTHEDGCORRDATE:= v_pmwrtsum.T_AMORTHEDGCORRDATE;

       RSI_InsDfltIntoWRTBC(v_pmwrtbc);
       INSERT INTO DPMWRTBC_DBT VALUES v_pmwrtbc;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20261);

     END;
     
     -- 3. Обновить DPMWRTSUM, установив в нем T_ID_OPERATION = ID_Operation T_ID_STEP = ID_Step T_ACTION = Action T_INSTANCE = DPMWRTSUM.T_INSTANCE + 1
     BEGIN
       UPDATE DPMWRTSUM_DBT
          SET t_ID_Operation = p_ID_Operation,
              t_ID_Step      = p_ID_Step,
              t_Action       = p_Action,
              t_Instance     = t_Instance + 1,
              T_CHANGEDATE   = p_ChangeDate
        WHERE t_SumID = p_SumID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20261);
      END;

   END; --RSI_WRTSaveLot

   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет восстановление лота по архивным данным
   -----  WRTOFF_ERROR_20201    CONSTANT INTEGER := -20201; --Для лота %s есть операции за более позднюю дату
   -----  WRTOFF_ERROR_20204    CONSTANT INTEGER := -20204; --По лоту нет архивных данных
   PROCEDURE RSI_WRTRestoreLot( p_ID_Operation IN NUMBER, p_ID_Step IN NUMBER, p_Action IN NUMBER, p_SumID IN NUMBER DEFAULT 0 )
   IS
     v_Count    NUMBER;
     v_pmwrtbc  DPMWRTBC_DBT%ROWTYPE;
     v_N        NUMBER := 0;
   BEGIN

     -- 1.
     IF (p_ID_Operation = 0 AND p_ID_Step = 0) THEN
        RETURN;
     END IF;


     SELECT COUNT(1) INTO v_N
       FROM DPMWRTSUM_DBT
      WHERE T_ID_OPERATION = p_ID_Operation
        AND T_ID_STEP = p_ID_Step
        AND T_ACTION = p_Action
        AND ( (p_SumID = 0) OR (T_SUMID = p_SumID) );

     WHILE v_N > 0 LOOP

       FOR WRTSum IN (SELECT *
                        FROM DPMWRTSUM_DBT
                       WHERE t_ID_Operation = p_ID_Operation AND
                             t_ID_Step      = p_ID_Step AND
                             t_Action       = p_Action AND
                             ( (p_SumID = 0) OR (t_SumID = p_SumID) )
                     ) LOOP

  --        IF( (p_Action = PM_WRT_UPDTMODE_CREATE) OR
  --            (p_Action = PM_WRT_UPDTMODE_DELIVERYBPP) OR
  --            (p_Action in (PM_WRT_UPDTMODE_CDELIVERY, PM_WRT_UPDTMODE_CDELIVERY2) AND (WRTSum.t_Instance = 0) )
  --          ) THEN
          IF WRTSum.t_Instance = 0 THEN
            DELETE FROM DPMWRTSUM_DBT
                WHERE t_SumID = WRTSum.t_SumID;
          ELSE
             BEGIN
               SELECT * INTO v_pmwrtbc
                 FROM DPMWRTBC_DBT
                WHERE t_SumID    = WRTSum.t_SumID AND
                      t_Instance = (WRTSum.t_Instance - 1);
               EXCEPTION
                  WHEN OTHERS THEN
                    v_pmwrtbc := NULL;
             END;

             IF (v_pmwrtbc.T_SUMID IS NOT NULL) THEN

               UPDATE DPMWRTSUM_DBT
                  SET t_ID_Operation     = v_pmwrtbc.t_ID_Operation,
                      t_ID_Step          = v_pmwrtbc.t_ID_Step,
                      t_Action           = v_pmwrtbc.t_Action,
                      t_Instance         = v_pmwrtbc.t_Instance,
                      t_ChangeDate       = v_pmwrtbc.t_ChangeDate,
                      t_FIID             = v_pmwrtbc.t_FIID,
                      t_Portfolio        = v_pmwrtbc.t_Portfolio,
                      t_GroupID          = v_pmwrtbc.t_GroupID,
                      t_Date             = v_pmwrtbc.t_Date,
                      t_Time             = v_pmwrtbc.t_Time,
                      t_Amount           = v_pmwrtbc.t_Amount,
                      t_AmountBD         = v_pmwrtbc.t_AmountBD,
                      t_Sum              = v_pmwrtbc.t_Sum,
                      t_Currency         = v_pmwrtbc.t_Currency,
                      t_Cost             = v_pmwrtbc.t_Cost,
                      t_BalanceCost      = v_pmwrtbc.t_BalanceCost,
                      t_BalanceCostBD    = v_pmwrtbc.t_BalanceCostBD,
                      t_NKDAmount        = v_pmwrtbc.t_NKDAmount,
                      t_InterestIncome   = v_pmwrtbc.t_InterestIncome,
                      t_NotCarryInterest = v_pmwrtbc.t_NotCarryInterest,
                      t_InterestDate     = v_pmwrtbc.t_InterestDate,
                      t_BegDate          = v_pmwrtbc.t_BegDate,
                      t_BegDiscount      = v_pmwrtbc.t_BegDiscount,
                      t_OldBegDate       = v_pmwrtbc.t_OldBegDate,
                      t_OldBegDiscount   = v_pmwrtbc.t_OldBegDiscount,
                      t_DiscountIncome   = v_pmwrtbc.t_DiscountIncome,
                      t_NotCarryDiscount = v_pmwrtbc.t_NotCarryDiscount,
                      t_DiscountDate     = v_pmwrtbc.t_DiscountDate,
                      t_Outlay           = v_pmwrtbc.t_Outlay,
                      t_ReservAmount     = v_pmwrtbc.t_ReservAmount,
                      t_IncomeReserv     = v_pmwrtbc.t_IncomeReserv,
                      t_ReservDate       = v_pmwrtbc.t_ReservDate,
                      t_OverAmount       = v_pmwrtbc.t_OverAmount,
                      t_OverAmountBD     = v_pmwrtbc.t_OverAmountBD,
                      t_OverDate         = v_pmwrtbc.t_OverDate,
                      t_State            = v_pmwrtbc.t_State,
                      t_StateDate        = v_pmwrtbc.t_StateDate,
                      t_BegBonusDate     = v_pmwrtbc.t_BegBonusDate,
                      t_BegBonus         = v_pmwrtbc.t_BegBonus,
                      t_Bonus            = v_pmwrtbc.t_Bonus,
                      t_OldBonus         = v_pmwrtbc.t_OldBonus,
                      t_BonusDate        = v_pmwrtbc.t_BonusDate,
                      t_BegInterestDate  = v_pmwrtbc.t_BegInterestDate,
                      t_BegDiscountDate  = v_pmwrtbc.t_BegDiscountDate,
                      t_DiscountCorr     = v_pmwrtbc.t_DiscountCorr   ,
                      t_OldBegBonus      = v_pmwrtbc.t_OldBegBonus    ,
                      t_RecalcDate       = v_pmwrtbc.t_RecalcDate     ,
                      t_IsEdit           = v_pmwrtbc.t_IsEdit,
                      T_NOTWRTBONUS      = v_pmwrtbc.T_NOTWRTBONUS,
                      T_COSTPFI          = v_pmwrtbc.T_COSTPFI,
                      t_ActivateDate     = v_pmwrtbc.t_ActivateDate,
                      t_ActivateTime     = v_pmwrtbc.t_ActivateTime,
                      t_BlockAmount      = v_pmwrtbc.t_BlockAmount,
                      T_BEGDEFDIFF       = v_pmwrtbc.T_BEGDEFDIFF,
                      T_ACCOUNTEDDEFDIFF = v_pmwrtbc.T_ACCOUNTEDDEFDIFF,
                      T_DEFDIFFDATE      = v_pmwrtbc.T_DEFDIFFDATE,
                      T_WRTOUTLAY        = v_pmwrtbc.T_WRTOUTLAY,
                      T_WRTOUTLAYDATE    = v_pmwrtbc.T_WRTOUTLAYDATE,
                      T_VATOUTLAY        = v_pmwrtbc.T_VATOUTLAY,
                      T_WRTVATOUTLAY     = v_pmwrtbc.T_WRTVATOUTLAY,
                      T_EFFECTINTERESTRATE = v_pmwrtbc.T_EFFECTINTERESTRATE,
                      T_FAIRVALUE        = v_pmwrtbc.T_FAIRVALUE,
                      T_AMORTCOST        = v_pmwrtbc.T_AMORTCOST,
                      T_CORRVALUE        = v_pmwrtbc.T_CORRVALUE,
                      T_CORRDATE         = v_pmwrtbc.T_CORRDATE,
                      T_ACCBALANCECOST   = v_pmwrtbc.T_ACCBALANCECOST,
                      T_ACCFI            = v_pmwrtbc.T_ACCFI,
                      T_AMORTCALCKIND    = v_pmwrtbc.T_AMORTCALCKIND,
                      T_ESTRESERVE       = v_pmwrtbc.T_ESTRESERVE,
                      T_ESTRESERVEDATE   = v_pmwrtbc.T_ESTRESERVEDATE,
                      T_CORRINTTOEIR     = v_pmwrtbc.T_CORRINTTOEIR,
                      T_CORRINTTOEIRDATE = v_pmwrtbc.T_CORRINTTOEIRDATE,
                      T_CORRESTRESERVE     = v_pmwrtbc.T_CORRESTRESERVE,
                      T_CORRESTRESERVEDATE = v_pmwrtbc.T_CORRESTRESERVEDATE,
                      T_BEGDEFDIFFDATE     = v_pmwrtbc.T_BEGDEFDIFFDATE,
                      T_ADDINCOMEOWN       = v_pmwrtbc.T_ADDINCOMEOWN,
                      T_ADDINCOMEOWNDATE   = v_pmwrtbc.T_ADDINCOMEOWNDATE,
                      T_HEDGCORR           = v_pmwrtbc.T_HEDGCORR,
                      T_HEDGCORRDATE       = v_pmwrtbc.T_HEDGCORRDATE,
                      T_AMORTHEDGCORR      = v_pmwrtbc.T_AMORTHEDGCORR,
                      T_AMORTHEDGCORRDATE  = v_pmwrtbc.T_AMORTHEDGCORRDATE

                WHERE t_SumID = WRTSum.t_SumID;

                DELETE FROM DPMWRTBC_DBT
                 WHERE t_BCID = v_pmwrtbc.t_BCID;

              END IF;

          END IF;

       END LOOP;

       SELECT COUNT(1) INTO v_N
         FROM DPMWRTSUM_DBT
        WHERE T_ID_OPERATION = p_ID_Operation
          AND T_ID_STEP = p_ID_Step
          AND T_ACTION = p_Action
          AND ( (p_SumID = 0) OR (T_SUMID = p_SumID) );

     END LOOP;

     SELECT COUNT(1) INTO v_N
       FROM DPMWRTBC_DBT
      WHERE T_ID_OPERATION = p_ID_Operation
        AND T_ID_STEP = p_ID_Step
        AND T_ACTION = p_Action
        AND ( (p_SumID = 0) OR (T_SUMID = p_SumID) );

     IF v_N > 0 THEN
       SetError( WRTOFF_ERROR_20240 ); --Откатываемая операция по лоту не является последней
     END IF;

   END;--RSI_WRTRestoreLot

   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет восстановление лота по архивным данным. Используется только при откате шагов начислений.
   -- Используется для отката старых действий по начислению ПД и ДД, для новых операций эта ф-я для отката больше не используется.
   PROCEDURE RSI_WRTRestoreLotEx( p_ID_Operation IN NUMBER, p_ID_Step IN NUMBER, p_Action IN NUMBER, p_SumID IN NUMBER DEFAULT 0 )
   IS
     BEGIN
      RSI_WRTRestoreLot(p_ID_Operation,p_ID_Step,p_Action);
   END;--RSI_WRTRestoreLotEx

   --Выполняет осреднение дисконта и/или премии и отсроченной разницы по лотам портфеля при средневзвешенном списании..
   PROCEDURE RSI_WRTAveragePortfolioLots( p_OperDate     IN DATE,   -- Дата
                                          p_EndDate      IN DATE,
                                          p_FIID         IN NUMBER, -- Выпуск
                                          p_Department   IN NUMBER, -- Филиал
                                          p_Party        IN NUMBER,
                                          p_Contract     IN NUMBER,
                                          p_G            IN NUMBER, -- Портфели (по приоритетам, до 5-х штук, незаданные)
                                          p_STATE        IN NUMBER, -- Статус (поставлен, продан БПП)  ВР. Темы Айса 154213, 159624.
                                          p_ID_Operation IN NUMBER,
                                          p_ID_Step      IN NUMBER,
                                          p_Action       IN NUMBER,
                                          p_Discount     IN NUMBER, -- Осреднять дисконт (1 - да, 0 - нет)
                                          p_Bonus        IN NUMBER, -- Осреднять премию  (1 - да, 0 - нет)
                                          p_DefDiff      IN NUMBER, -- Осреднять отсроченную разницу  (1 - да, 0 - нет)
                                          p_CorrIntToEIR  IN NUMBER  -- Осреднять корректировку % до ЭПС (1 - да, 0 - нет)
                                        )
   IS
      AllBegDiscount  NUMBER;
      AllDiscount     NUMBER;
      AllAmount       NUMBER;
      AllEIRAmount    NUMBER;
      AllBegBonus     NUMBER;
      AllBonus        NUMBER;
      AllBegDefDiff   NUMBER;
      AllAccountedDefDiff  NUMBER;
      AllCorrIntToEIR NUMBER;
      AllCorrIntToEIR_FV NUMBER;
      AllHedgCorr     NUMBER;
      AllHedgCorr_FV  NUMBER;
      AllAmortHedgCorr     NUMBER;
      AllAmortHedgCorr_FV  NUMBER;
      RestAmount      NUMBER;
      RestEIRAmount   NUMBER;
      RestBegDiscount NUMBER;
      RestDiscount    NUMBER;
      RestBegBonus    NUMBER;
      RestBonus       NUMBER;
      RestBegDefDiff  NUMBER;
      RestAccountedDefDiff NUMBER;
      RestCorrIntToEIR NUMBER;
      RestCorrIntToEIR_FV NUMBER;
      RestHedgCorr    NUMBER;
      RestHedgCorr_FV NUMBER;
      RestAmortHedgCorr    NUMBER;
      RestAmortHedgCorr_FV NUMBER;
      CurBegDiscount  NUMBER;
      CurDiscount     NUMBER;
      CurBegBonus     NUMBER;
      CurBonus        NUMBER;
      CurBegDefDiff   NUMBER;
      CurAccountedDefDiff NUMBER;
      CurCorrIntToEIR NUMBER;
      CurCorrIntToEIR_FV NUMBER;
      CurHedgCorr     NUMBER;
      CurHedgCorr_FV  NUMBER;
      CurAmortHedgCorr     NUMBER;
      CurAmortHedgCorr_FV  NUMBER;
      CurCost         NUMBER;
      BalCost         NUMBER;
      MaxDiscountDate DATE;
      MaxBonusDate    DATE;
      MaxDefDiffDate  DATE;
      MaxCorrIntToEIRDate  DATE;
      MaxHedgCorrDate DATE;
      MaxAmortHedgCorrDate DATE;

     TYPE Number10Table_t IS TABLE OF NUMBER(10);
     TYPE Number5Table_t IS TABLE OF NUMBER(5);
     TYPE Number3212Table_t IS TABLE OF NUMBER(32,12);
     TYPE DateTable_t IS TABLE OF DATE;

     SumID            Number10Table_t;
     Amount           Number3212Table_t;
     begdiscount      Number3212Table_t;
     discountincome   Number3212Table_t;
     BegBonus         Number3212Table_t;
     Bonus            Number3212Table_t;
     Cost             Number3212Table_t;
     BalanceCost      Number3212Table_t;
     BegDefDiff       Number3212Table_t;
     AccountedDefDiff Number3212Table_t;
     CorrIntToEIR     Number3212Table_t;
     HedgCorr         Number3212Table_t;
     AmortHedgCorr    Number3212Table_t;
     DefDiffDate      DateTable_t;
     DiscountDate     DateTable_t;
     BonusDate        DateTable_t;
     CorrIntToEIRDate DateTable_t;
     HedgCorrDate     DateTable_t;
     AmortHedgCorrDate DateTable_t;
     AmortCalcKind    Number5Table_t;

     i NUMBER := 0;

     v_FaceValueFI NUMBER;

   BEGIN
     InitError();

     IF( p_Discount = 0 and p_Bonus = 0 ) THEN
        --Неверные параметры
        SetError( WRTOFF_ERROR_20262 );
     END IF;

     SELECT t_FaceValueFI INTO v_FaceValueFI
       FROM dfininstr_dbt
      WHERE t_FIID = p_FIID;

     SELECT NVL(SUM(t_Amount), 0),
            NVL(SUM(CASE WHEN p_CorrIntToEIR  = 1 AND t_AmortCalcKind IN (RSB_SECUR.AMORTCALCKIND_EPS, RSB_SECUR.AMORTCALCKIND_RPS) THEN t_Amount ELSE 0 END),0),
            (CASE WHEN p_Discount = 1 THEN SUM(t_BegDiscount)        ELSE 0 END),
            (CASE WHEN p_Discount = 1 THEN SUM(t_DiscountIncome)     ELSE 0 END),
            (CASE WHEN p_Bonus    = 1 THEN SUM(t_BegBonus)           ELSE 0 END),
            (CASE WHEN p_Bonus    = 1 THEN SUM(t_Bonus)              ELSE 0 END),
            (CASE WHEN p_DefDiff  = 1 THEN SUM(t_BegDefDiff)         ELSE 0 END),
            (CASE WHEN p_DefDiff  = 1 THEN SUM(t_AccountedDefDiff)   ELSE 0 END),
            (CASE WHEN p_CorrIntToEIR  = 1 THEN SUM(t_CorrIntToEIR)   ELSE 0 END),
            SUM(CASE WHEN p_CorrIntToEIR  = 1 AND t_CorrIntToEIRDate > UnknownDate THEN ROUND(RSI_RSB_FIInstr.ConvSum(t_CorrIntToEIR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, t_CorrIntToEIRDate, 0), 2) ELSE 0 END),
            SUM(t_HedgCorr),
            SUM(CASE WHEN t_HedgCorrDate > UnknownDate THEN ROUND(RSI_RSB_FIInstr.ConvSum(t_HedgCorr, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, t_HedgCorrDate, 0), 2) ELSE 0 END),
            SUM(t_AmortHedgCorr),
            SUM(CASE WHEN t_AmortHedgCorrDate > UnknownDate THEN ROUND(RSI_RSB_FIInstr.ConvSum(t_AmortHedgCorr, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, t_AmortHedgCorrDate, 0), 2) ELSE 0 END),
            NVL(MAX(t_DiscountDate), p_EndDate),
            NVL(MAX(t_BonusDate), p_EndDate),
            NVL(MAX(t_DefDiffDate), p_EndDate),
            NVL(MAX(t_CorrIntToEIRDate), p_EndDate),
            NVL(MAX(t_HedgCorrDate), TO_DATE('01.01.0001','DD.MM.YYYY')),
            NVL(MAX(t_AmortHedgCorrDate), TO_DATE('01.01.0001','DD.MM.YYYY'))
       INTO AllAmount,
            AllEIRAmount,
            AllBegDiscount,
            AllDiscount,
            AllBegBonus,
            AllBonus,
            AllBegDefDiff,
            AllAccountedDefDiff,
            AllCorrIntToEIR,
            AllCorrIntToEIR_FV,
            AllHedgCorr,
            AllHedgCorr_FV,
            AllAmortHedgCorr,
            AllAmortHedgCorr_FV,
            MaxDiscountDate,
            MaxBonusDate,   
            MaxDefDiffDate,
            MaxCorrIntToEIRDate,
            MaxHedgCorrDate,
            MaxAmortHedgCorrDate 
       FROM DPMWRTSUM_DBT
      WHERE T_PARTY       = p_Party
        AND T_DEPARTMENT  = p_Department
        AND T_CONTRACT    = p_Contract
        AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
        AND T_PORTFOLIO   = p_G
        AND T_ENTERDATE  <= p_OperDate
        AND T_DATE       <= p_EndDate
        AND T_FIID        = p_FIID
        AND T_STATE       = p_STATE
        AND T_AMOUNT      > 0;


     if( AllAmount > 0 ) then
        RestAmount           := AllAmount;
        RestEIRAmount        := AllEIRAmount;
        RestBegDiscount      := AllBegDiscount;
        RestDiscount         := AllDiscount;
        RestBegBonus         := AllBegBonus;
        RestBonus            := AllBonus;
        RestBegDefDiff       := AllBegDefDiff;
        RestAccountedDefDiff := AllAccountedDefDiff;
        RestCorrIntToEIR     := AllCorrIntToEIR;
        RestHedgCorr         := AllHedgCorr;
        RestAmortHedgCorr    := AllAmortHedgCorr;

        AllCorrIntToEIR_FV := ROUND(AllCorrIntToEIR_FV, 2);
        RestCorrIntToEIR_FV  := AllCorrIntToEIR_FV;

        AllHedgCorr_FV := ROUND(AllHedgCorr_FV, 2);
        RestHedgCorr_FV  := AllHedgCorr_FV;

        AllAmortHedgCorr_FV := ROUND(AllAmortHedgCorr_FV, 2);
        RestAmortHedgCorr_FV  := AllAmortHedgCorr_FV;

        BEGIN
          SELECT t_SumID,
                 t_Amount,
                 (CASE WHEN p_Discount = 1 THEN t_BegDiscount      ELSE 0 END),
                 (CASE WHEN p_Discount = 1 THEN t_DiscountIncome   ELSE 0 END),
                 t_DiscountDate,
                 (CASE WHEN p_Bonus    = 1 THEN t_BegBonus         ELSE 0 END),
                 (CASE WHEN p_Bonus    = 1 THEN t_Bonus            ELSE 0 END),
                 t_BonusDate,
                 (CASE WHEN p_Bonus    = 1 THEN t_Cost             ELSE 0 END),
                 (CASE WHEN p_DefDiff  = 1 THEN t_BegDefDiff       ELSE 0 END),
                 (CASE WHEN p_DefDiff  = 1 THEN t_AccountedDefDiff ELSE 0 END),
                 t_DefDiffDate,
                 (CASE WHEN p_CorrIntToEIR = 1 THEN t_CorrIntToEIR ELSE 0 END),
                 t_CorrIntToEIRDate,
                 t_HedgCorr,
                 t_HedgCorrDate,
                 t_AmortHedgCorr,
                 t_AmortHedgCorrDate,
                 t_BalanceCost,
                 t_AmortCalcKind
            BULK COLLECT INTO
                 SumID,
                 Amount,
                 begdiscount,
                 discountincome,
                 DiscountDate,
                 BegBonus,
                 Bonus,
                 BonusDate,
                 Cost,
                 BegDefDiff,
                 AccountedDefDiff,
                 DefDiffDate,
                 CorrIntToEIR,
                 CorrIntToEIRDate,
                 HedgCorr,
                 HedgCorrDate,
                 AmortHedgCorr,
                 AmortHedgCorrDate,
                 BalanceCost,
                 AmortCalcKind
            FROM DPMWRTSUM_DBT
           WHERE T_PARTY       = p_Party
             AND T_DEPARTMENT  = p_Department
             AND T_CONTRACT    = p_Contract
             AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
             AND T_PORTFOLIO   = p_G
             AND T_ENTERDATE  <= p_OperDate
             AND T_DATE       <= p_EndDate
             AND T_FIID        = p_FIID
             AND T_STATE       = p_STATE
             AND T_AMOUNT      > 0
           ORDER BY T_AMOUNT ASC, T_DATE DESC;

        EXCEPTION
          WHEN NO_DATA_FOUND THEN NULL;
        END;

        FOR i IN SumID.FIRST .. SumID.LAST
        LOOP
           
           if( RestAmount > Amount(i) ) then
              CurBegDiscount      := ROUND(AllBegDiscount/AllAmount*Amount(i),2);
              CurDiscount         := ROUND(AllDiscount/AllAmount*Amount(i),2);
              CurBegBonus         := ROUND(AllBegBonus/AllAmount*Amount(i),2);
              CurBonus            := ROUND(AllBonus/AllAmount*Amount(i),2);
              CurBegDefDiff       := ROUND(AllBegDefDiff/AllAmount*Amount(i),2);
              CurAccountedDefDiff := ROUND(AllAccountedDefDiff/AllAmount*Amount(i),2);
              CurHedgCorr         := ROUND(AllHedgCorr/AllAmount*Amount(i),2);
              CurAmortHedgCorr    := ROUND(AllAmortHedgCorr/AllAmount*Amount(i),2);
           else
              CurBegDiscount      := RestBegDiscount;
              CurDiscount         := RestDiscount;
              CurBegBonus         := RestBegBonus;
              CurBonus            := RestBonus;
              CurBegDefDiff       := RestBegDefDiff;
              CurAccountedDefDiff := RestAccountedDefDiff;
              CurHedgCorr         := RestHedgCorr;
              CurAmortHedgCorr    := RestAmortHedgCorr;
           end if;

           CurCorrIntToEIR := 0;
           IF AmortCalcKind(i) IN (RSB_SECUR.AMORTCALCKIND_EPS,RSB_SECUR.AMORTCALCKIND_RPS) THEN
             IF RestEIRAmount > Amount(i) THEN
               CurCorrIntToEIR     := ROUND(AllCorrIntToEIR/AllEIRAmount*Amount(i),2);
             ELSE
               CurCorrIntToEIR     := RestCorrIntToEIR;
             END IF;
           END IF;

           CurCost  := Cost(i) + Bonus(i) - CurBonus - BegBonus(i) + CurBegBonus;
           BalCost  := BalanceCost(i) - discountincome(i) + CurDiscount + Bonus(i) - CurBonus - BegBonus(i) + CurBegBonus;
           IF CorrIntToEIRDate(i) > UnknownDate THEN
             BalCost := BalCost - ROUND(RSI_RSB_FIInstr.ConvSum(CorrIntToEIR(i), RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, CorrIntToEIRDate(i), 0), 2);
           END IF;
           IF HedgCorrDate(i) > UnknownDate THEN
             BalCost := BalCost - ROUND(RSI_RSB_FIInstr.ConvSum(HedgCorr(i), RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, HedgCorrDate(i), 0), 2);
           END IF;
           IF AmortHedgCorrDate(i) > UnknownDate THEN
             BalCost := BalCost - ROUND(RSI_RSB_FIInstr.ConvSum(AmortHedgCorr(i), RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, AmortHedgCorrDate(i), 0), 2);
           END IF;

           CorrIntToEIR(i)     := CurCorrIntToEIR;
           CorrIntToEIRDate(i) := (CASE WHEN p_CorrIntToEIR = 1 AND CorrIntToEIRDate(i) = UnknownDate AND CorrIntToEIR(i) <> 0 THEN MaxCorrIntToEIRDate ELSE CorrIntToEIRDate(i) END);

           CurCorrIntToEIR_FV := 0;
           IF CorrIntToEIRDate(i) > UnknownDate THEN
             if( RestAmount > Amount(i) ) then
               CurCorrIntToEIR_FV := ROUND(RSI_RSB_FIInstr.ConvSum(CorrIntToEIR(i), RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, CorrIntToEIRDate(i), 0), 2);
             else
               CurCorrIntToEIR_FV := RestCorrIntToEIR_FV;
             end if;

             BalCost := BalCost + CurCorrIntToEIR_FV;
           END IF;

           HedgCorr(i)     := CurHedgCorr;
           HedgCorrDate(i) := (CASE WHEN HedgCorrDate(i) = UnknownDate AND HedgCorr(i) <> 0 THEN MaxHedgCorrDate ELSE HedgCorrDate(i) END);

           CurHedgCorr_FV := 0;
           IF HedgCorrDate(i) > UnknownDate THEN
             if( RestAmount > Amount(i) ) then
               CurHedgCorr_FV := ROUND(RSI_RSB_FIInstr.ConvSum(HedgCorr(i), RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, HedgCorrDate(i), 0), 2);
             else
               CurHedgCorr_FV := RestHedgCorr_FV;
             end if;

             BalCost := BalCost + CurHedgCorr_FV;
           END IF;

           AmortHedgCorr(i)     := CurAmortHedgCorr;
           AmortHedgCorrDate(i) := (CASE WHEN AmortHedgCorrDate(i) = UnknownDate AND AmortHedgCorr(i) <> 0 THEN MaxAmortHedgCorrDate ELSE AmortHedgCorrDate(i) END);

           CurAmortHedgCorr_FV := 0;
           IF AmortHedgCorrDate(i) > UnknownDate THEN
             if( RestAmount > Amount(i) ) then
               CurAmortHedgCorr_FV := ROUND(RSI_RSB_FIInstr.ConvSum(AmortHedgCorr(i), RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, AmortHedgCorrDate(i), 0), 2);
             else
               CurAmortHedgCorr_FV := RestAmortHedgCorr_FV;
             end if;

             BalCost := BalCost + CurAmortHedgCorr_FV;
           END IF;



           begdiscount(i)      := CurBegDiscount;
           discountincome(i)   := CurDiscount;
           DiscountDate(i)     := (CASE WHEN p_Discount = 1 AND DiscountDate(i) = UnknownDate AND discountincome(i) <> 0 THEN MaxDiscountDate ELSE DiscountDate(i) END);
           BegBonus(i)         := CurBegBonus;
           Bonus(i)            := CurBonus;
           BonusDate(i)        := (CASE WHEN p_Bonus = 1 AND BonusDate(i) = UnknownDate AND Bonus(i) <> 0 THEN MaxBonusDate ELSE BonusDate(i) END);
           BegDefDiff(i)       := CurBegDefDiff;
           AccountedDefDiff(i) := CurAccountedDefDiff;
           DefDiffDate(i)      := (CASE WHEN p_DefDiff = 1 AND DefDiffDate(i) = UnknownDate AND AccountedDefDiff(i) <> 0 THEN MaxDefDiffDate ELSE DefDiffDate(i) END);
           Cost(i)             := CurCost;
           BalanceCost(i)      := BalCost;

           RestAmount           := RestAmount - Amount(i);
           RestBegDiscount      := RestBegDiscount - CurBegDiscount;
           RestDiscount         := RestDiscount - CurDiscount;
           RestBegBonus         := RestBegBonus - CurBegBonus;
           RestBonus            := RestBonus - CurBonus;
           RestBegDefDiff       := RestBegDefDiff - CurBegDefDiff;
           RestAccountedDefDiff := RestAccountedDefDiff - CurAccountedDefDiff;
           
           IF AmortCalcKind(i) IN (RSB_SECUR.AMORTCALCKIND_EPS, RSB_SECUR.AMORTCALCKIND_RPS) THEN
             RestEIRAmount       := RestEIRAmount - Amount(i);
             RestCorrIntToEIR    := RestCorrIntToEIR - CurCorrIntToEIR;
             RestCorrIntToEIR_FV := RestCorrIntToEIR_FV - CurCorrIntToEIR_FV;
           END IF;

           RestHedgCorr    := RestHedgCorr - CurHedgCorr;
           RestHedgCorr_FV := RestHedgCorr_FV - CurHedgCorr_FV;

           RestAmortHedgCorr    := RestAmortHedgCorr - CurAmortHedgCorr;
           RestAmortHedgCorr_FV := RestAmortHedgCorr_FV - CurAmortHedgCorr_FV;

        END LOOP;

        i := 0;
        FOR i IN SumID.FIRST .. SumID.LAST
        LOOP
           RSI_WRTSaveLot (SumID(i), p_ID_Operation, p_ID_Step, p_OperDate, p_Action);
           
           UPDATE DPMWRTSUM_DBT
              SET t_begdiscount      = (CASE WHEN p_Discount = 1 THEN begdiscount(i)      ELSE t_begdiscount      END),
                  t_discountincome   = (CASE WHEN p_Discount = 1 THEN discountincome(i)   ELSE t_discountincome   END),
                  t_DiscountDate     = (CASE WHEN p_Discount = 1 THEN DiscountDate(i)     ELSE t_DiscountDate     END),
                  t_BegBonus         = (CASE WHEN p_Bonus    = 1 THEN BegBonus(i)         ELSE t_BegBonus         END),
                  t_Bonus            = (CASE WHEN p_Bonus    = 1 THEN Bonus(i)            ELSE t_Bonus            END),
                  t_BonusDate        = (CASE WHEN p_Bonus    = 1 THEN BonusDate(i)        ELSE t_BonusDate        END),
                  t_BegDefDiff       = (CASE WHEN p_DefDiff  = 1 THEN BegDefDiff(i)       ELSE t_BegDefDiff       END),
                  t_AccountedDefDiff = (CASE WHEN p_DefDiff  = 1 THEN AccountedDefDiff(i) ELSE t_AccountedDefDiff END),
                  t_DefDiffDate      = (CASE WHEN p_DefDiff  = 1 THEN DefDiffDate(i)      ELSE t_DefDiffDate      END),
                  t_Cost             = (CASE WHEN p_Bonus    = 1 THEN Cost(i)             ELSE t_Cost             END),
                  t_CorrIntToEIR     = (CASE WHEN p_CorrIntToEIR = 1 THEN CorrIntToEIR(i) ELSE t_CorrIntToEIR END),
                  t_CorrIntToEIRDate = (CASE WHEN p_CorrIntToEIR = 1 THEN CorrIntToEIRDate(i) ELSE t_CorrIntToEIRDate      END),
                  t_HedgCorr         = HedgCorr(i),
                  t_HedgCorrDate     = HedgCorrDate(i),
                  t_AmortHedgCorr    = AmortHedgCorr(i),
                  t_AmortHedgCorrDate= AmortHedgCorrDate(i),
                  t_BalanceCost      = BalanceCost(i)
            WHERE t_SumID = SumID(i);
        END LOOP;

     end if;

   EXCEPTION
      WHEN OTHERS THEN RETURN;
   END;

   PROCEDURE RSI_WRTAverageLots( p_OperDate     IN DATE,   -- Дата
                                 p_EndDate      IN DATE,
                                 p_FIID         IN NUMBER, -- Выпуск
                                 p_Department   IN NUMBER, -- Филиал
                                 p_Party        IN NUMBER,
                                 p_Contract     IN NUMBER,
                                 p_ID_Operation IN NUMBER,
                                 p_ID_Step      IN NUMBER,
                                 p_Action       IN NUMBER,
                                 p_Discount     IN NUMBER, -- Осреднять дисконт (1 - да, 0 - нет)
                                 p_Bonus        IN NUMBER, -- Осреднять премию  (1 - да, 0 - нет)
                                 p_DefDiff      IN NUMBER, -- Осреднять отсроченную разницу  (1 - да, 0 - нет)
                                 p_CorrIntToEIR IN NUMBER  -- Осреднять корректировку % до ЭПС (1 - да, 0 - нет)
                               )
   IS

   BEGIN
       RSI_WRTAveragePortfolioLots( p_OperDate, p_EndDate, p_FIID, p_Department, p_Party, p_Contract, KINDPORT_TRADE,  PM_WRTSUM_FORM    , p_ID_Operation, p_ID_Step, p_Action, p_Discount, p_Bonus, p_DefDiff, p_CorrIntToEIR );
       RSI_WRTAveragePortfolioLots( p_OperDate, p_EndDate, p_FIID, p_Department, p_Party, p_Contract, KINDPORT_TRADE,  PM_WRTSUM_SALE_BPP, p_ID_Operation, p_ID_Step, p_Action, p_Discount, p_Bonus, p_DefDiff, p_CorrIntToEIR );
       RSI_WRTAveragePortfolioLots( p_OperDate, p_EndDate, p_FIID, p_Department, p_Party, p_Contract, KINDPORT_SALE,   PM_WRTSUM_FORM    , p_ID_Operation, p_ID_Step, p_Action, p_Discount, p_Bonus, p_DefDiff, p_CorrIntToEIR );
       RSI_WRTAveragePortfolioLots( p_OperDate, p_EndDate, p_FIID, p_Department, p_Party, p_Contract, KINDPORT_SALE,   PM_WRTSUM_SALE_BPP, p_ID_Operation, p_ID_Step, p_Action, p_Discount, p_Bonus, p_DefDiff, p_CorrIntToEIR );
       RSI_WRTAveragePortfolioLots( p_OperDate, p_EndDate, p_FIID, p_Department, p_Party, p_Contract, KINDPORT_RETIRE, PM_WRTSUM_FORM    , p_ID_Operation, p_ID_Step, p_Action, p_Discount, p_Bonus, p_DefDiff, p_CorrIntToEIR );
       RSI_WRTAveragePortfolioLots( p_OperDate, p_EndDate, p_FIID, p_Department, p_Party, p_Contract, KINDPORT_RETIRE, PM_WRTSUM_SALE_BPP, p_ID_Operation, p_ID_Step, p_Action, p_Discount, p_Bonus, p_DefDiff, p_CorrIntToEIR );
   END;

   FUNCTION GetComSumByDeal(p_DocKInd NUMBER, p_DocID NUMBER, p_CalcDate DATE, p_ToFIID NUMBER, p_ExcludeRecOurBank INTEGER DEFAULT 0) RETURN NUMBER
   AS
     v_Sum NUMBER;
   BEGIN

     v_Sum := 0;

     FOR one_cm IN (SELECT (dlcomis.t_Sum-dlcomis.t_NDS) AllSum, comis.t_FIID_Comm Currency
                      FROM ddlcomis_dbt dlcomis, dsfcomiss_dbt comis
                     WHERE dlcomis.t_DocKind = p_DocKind
                       AND dlcomis.t_DocID   = p_DocID
                       AND dlcomis.t_FeeType   = comis.t_FeeType
                       AND dlcomis.t_ComNumber = comis.t_Number
                       AND dlcomis.t_Immaterial <> CHR(88)
                       AND 1 = (CASE WHEN p_ExcludeRecOurBank = 0 OR (comis.t_ReceiverID <> RsbSessionData.OurBank) THEN 1 ELSE 0 END)
                   )
     LOOP
       IF p_ToFIID <> -1 THEN
         v_Sum := v_Sum + ROUND(RSI_RSB_FIInstr.ConvSum( one_cm.AllSum, one_cm.Currency, p_ToFIID, p_CalcDate, 1 ),2);
       ELSE
         v_Sum := v_Sum + one_cm.AllSum;
       END IF;
     END LOOP;

     RETURN v_Sum;
   END;

   FUNCTION GetComNDSByDeal(p_DocKInd NUMBER, p_DocID NUMBER, p_CalcDate DATE, p_ToFIID NUMBER, p_ExcludeRecOurBank INTEGER DEFAULT 0) RETURN NUMBER
   AS
     v_Sum NUMBER;
   BEGIN

     v_Sum := 0;

     FOR one_cm IN (SELECT dlcomis.t_NDS AllSum, comis.t_FIID_Comm Currency
                      FROM ddlcomis_dbt dlcomis, dsfcomiss_dbt comis
                     WHERE dlcomis.t_DocKind = p_DocKind
                       AND dlcomis.t_DocID   = p_DocID
                       AND dlcomis.t_FeeType   = comis.t_FeeType
                       AND dlcomis.t_ComNumber = comis.t_Number
                       AND dlcomis.t_Immaterial <> CHR(88)
                       AND 1 = (CASE WHEN p_ExcludeRecOurBank = 0 OR (comis.t_ReceiverID <> RsbSessionData.OurBank) THEN 1 ELSE 0 END)
                   )
     LOOP
       IF p_ToFIID <> -1 THEN
         v_Sum := v_Sum + ROUND(RSI_RSB_FIInstr.ConvSum( one_cm.AllSum, one_cm.Currency, p_ToFIID, p_CalcDate, 1 ),2);
       ELSE
         v_Sum := v_Sum + one_cm.AllSum;
       END IF;
     END LOOP;

     RETURN v_Sum;
   END;

   FUNCTION GetComSumByDeal_Essential(p_DocKInd NUMBER, p_DocID NUMBER, p_CalcDate DATE, p_ToFIID NUMBER,
                                      p_PortfolioID NUMBER, p_Contract NUMBER, p_ToCompare NUMBER, p_ExcludeRecOurBank INTEGER DEFAULT 0) RETURN NUMBER
   AS
     v_Sum           NUMBER;
     v_SignDeviation BOOLEAN;
     v_RateKind      NUMBER;
     v_RateVal       NUMBER;
     v_DoCompare     NUMBER;
     v_CalcDate      DATE;
   BEGIN

     v_Sum := 0;
     IF(p_PortfolioID = KINDPORT_TRADE) Then --для ССПУ не учитываем
       return 0;
     END IF;

     FOR one_cm IN (SELECT (dlcomis.t_Sum - dlcomis.t_NDS) ComSum, comis.t_FIID_Comm Currency, dlcomis.t_PlanPayDate PlanPayDate, dlcomis.t_Contract
                      FROM ddlcomis_dbt dlcomis, dsfcomiss_dbt comis
                     WHERE dlcomis.t_DocKind = p_DocKind
                       AND dlcomis.t_DocID   = p_DocID
                       AND DLCOMIS.T_ISBACK != 'X' -- комиссии по 2 части сделки всегда считаются несущественными и сразу списываются на расходы
                       AND dlcomis.t_FeeType   = comis.t_FeeType
                       AND dlcomis.t_ComNumber = comis.t_Number
                       AND 1 = (CASE WHEN p_ExcludeRecOurBank = 0 OR (comis.t_ReceiverID <> RsbSessionData.OurBank) THEN 1 ELSE 0 END)

                   )
     LOOP
        IF(p_PortfolioID = KINDPORT_CLIENT AND p_Contract > 0 AND p_Contract != one_cm.t_Contract) THEN
          CONTINUE;
        END IF;

        if DATE_CONV_COURSE = DATE_COURSE_DELIV  then
           v_CalcDate := p_CalcDate;
        else
           v_CalcDate := one_cm.PlanPayDate;
        end if;
        v_DoCompare := RSI_RSB_FIInstr.ConvSum( one_cm.ComSum, one_cm.Currency, RSI_RSB_FIInstr.NATCUR,v_CalcDate, 1 );

        IF RSB_SECUR.GetEssentialDev(
               RSB_SECUR.LEVELESSENTIAL_CONTRACTCOSTS, --Затраты по договору
               p_PortfolioID,
               p_CalcDate,
               v_DoCompare,
               p_ToCompare,
               0,
               0,
               0,
               v_SignDeviation, -- Да/нет
               v_RateKind,      -- Наименование ставки используемой в дальнейшем
               v_RateVal        -- Значение ставки
              ) <> 0 THEN
           dbms_output.put_line('Ошибка: неверные параметры при вызове ф-ции проверки на существенность отклонения');
        END IF;

        IF v_SignDeviation = TRUE THEN
           IF p_ToFIID <> -1 THEN
             v_Sum := v_Sum + ROUND(RSI_RSB_FIInstr.ConvSum( one_cm.ComSum, one_cm.Currency, p_ToFIID, v_CalcDate/*one_cm.PlanPayDate*/, 1 ),2);
           ELSE
             v_Sum := v_Sum + one_cm.ComSum;
           END IF;
        END IF;
     END LOOP;

     RETURN v_Sum;

     EXCEPTION
       WHEN OTHERS THEN RETURN 0;
   END;

   FUNCTION GetComNDSByDeal_Essential(p_DocKInd NUMBER, p_DocID NUMBER, p_CalcDate DATE, p_ToFIID NUMBER,
                                      p_PortfolioID NUMBER, p_Contract NUMBER, p_ToCompare NUMBER, p_ExcludeRecOurBank INTEGER DEFAULT 0) RETURN NUMBER
   AS
     v_Sum           NUMBER;
     v_SignDeviation BOOLEAN;
     v_RateKind      NUMBER;
     v_RateVal       NUMBER;
     v_DoCompare     NUMBER;
   BEGIN
     v_Sum := 0;

     FOR one_cm IN (SELECT (dlcomis.t_Sum - dlcomis.t_NDS) ComSum, dlcomis.t_NDS NDS, comis.t_FIID_Comm Currency, dlcomis.t_PlanPayDate PlanPayDate, dlcomis.t_Contract
                      FROM ddlcomis_dbt dlcomis, dsfcomiss_dbt comis
                     WHERE dlcomis.t_DocKind = p_DocKind
                       AND dlcomis.t_DocID   = p_DocID
                       AND DLCOMIS.T_ISBACK != 'X' -- комиссии по 2 части сделки всегда считаются несущественными и сразу списываются на расходы
                       AND dlcomis.t_FeeType   = comis.t_FeeType
                       AND dlcomis.t_ComNumber = comis.t_Number
                       AND 1 = (CASE WHEN p_ExcludeRecOurBank = 0 OR (comis.t_ReceiverID <> RsbSessionData.OurBank) THEN 1 ELSE 0 END)
                   )
     LOOP
        IF(p_PortfolioID = KINDPORT_CLIENT AND p_Contract > 0 AND p_Contract != one_cm.t_Contract) THEN
          CONTINUE;
        END IF;

        v_DoCompare := RSI_RSB_FIInstr.ConvSum( one_cm.ComSum, one_cm.Currency, RSI_RSB_FIInstr.NATCUR, one_cm.PlanPayDate, 1 );

        IF RSB_SECUR.GetEssentialDev(
               RSB_SECUR.LEVELESSENTIAL_CONTRACTCOSTS, --Затраты по договору
               p_PortfolioID,
               p_CalcDate,
               v_DoCompare,
               p_ToCompare,
               0,
               0,
               0,
               v_SignDeviation, -- Да/нет
               v_RateKind,      -- Наименование ставки используемой в дальнейшем
               v_RateVal        -- Значение ставки
              ) <> 0 THEN
           dbms_output.put_line('Ошибка: неверные параметры при вызове ф-ции проверки на существенность отклонения');
        END IF;

        IF v_SignDeviation = TRUE THEN
           v_DoCompare := RSI_RSB_FIInstr.ConvSum( one_cm.NDS, one_cm.Currency, RSI_RSB_FIInstr.NATCUR, one_cm.PlanPayDate, 1 );
           v_Sum := v_Sum + ROUND(v_DoCompare,2);
        END IF;
     END LOOP;

     RETURN v_Sum;

     EXCEPTION
       WHEN OTHERS THEN RETURN 0;
   END;


   ----- Выполняет списание лота продажи/погашения выпуска по лотам покупки заданной группы списания.
   PROCEDURE RSI_WRTLinkSaleToBuy( p_SaleLot          IN OUT DPMWRTSUM_DBT%ROWTYPE,
                                   p_Portfolio        IN     NUMBER, -- Портфель. Если не задан -  игнорируется.
                                   p_Group            IN     NUMBER, -- Группа списания
                                   p_StartDate        IN     DATE,   -- Дата отбора лотов покупки. Если не задана  - игнорируется.
                                   p_Method           IN     NUMBER, -- Метод списания
                                   p_CheckTime        IN     NUMBER, -- Признак контроля времени
                                   p_ID_Operation     IN     NUMBER, -- Операция и шаг, на которых выполняется списание
                                   p_ID_Step          IN     NUMBER,
                                   p_LinkKind         IN     NUMBER, -- Вид создаваемой связи
                                   p_Action           IN     NUMBER, -- Вид изменения на лоте
                                   p_CalcInterest     IN     BOOLEAN, -- Расчитывать процентный доход
                                   p_CalcDiscount     IN     BOOLEAN, -- Расчитывать дисконтный доход
                                   p_CalcBonus        IN     BOOLEAN, -- Начислять премию
                                   p_CalcDefDiff      IN     BOOLEAN, -- Начислять отсроченную разницу
                                   p_CalcCorrIntToEIR IN     BOOLEAN, -- Начислять корректировку процентов до ЭПС
                                   p_CalcReserve      IN     BOOLEAN, -- Начислять резерв
                                   p_CalcOver         IN     BOOLEAN, -- Пересчитывать переоценку
                                   p_OnlyTodayBuys    IN     NUMBER --Списывать только с сегодняшних покупок, у которых установлена категория "Заключена в целях исполнения 2-й части РЕПО"
                                 )
   IS
     v_ArchSearch        BOOLEAN;
     v_BuyLot            DPMWRTSUM_DBT%ROWTYPE;
     v_Link              DPMWRTLNK_DBT%ROWTYPE;
     v_All               DPMWRTBC_DBT%ROWTYPE;
     v_CurBuy            DPMWRTBC_DBT%ROWTYPE;
     v_CheckTime         DPMWRTSUM_DBT.T_TIME%TYPE;
     v_AmountRate        NUMBER;
     v_Count             NUMBER;
     v_Amount            NUMBER;
     v_TMPLNKID          NUMBER;
     v_CalcDate          DATE;
     v_DRAWINGDATE       DATE;
     v_FaceValueFI       NUMBER;
     v_NeedLimitAmount   NUMBER;
     v_LnkAmount         NUMBER;
     v_K                 NUMBER;
     v_Val               NUMBER;
     v_AllVal            NUMBER;
     v_CurVal            NUMBER;
     v_LnkCostBuyNat     NUMBER;
     v_AvoirKind         NUMBER;
     v_BegCostBuy        NUMBER;
     v_BegCostBuyLnk     NUMBER;
     v_LastWrtCostBuyNat NUMBER;
     v_BegAmount         NUMBER;
     v_Termless          CHAR;
     v_NewSaleOvervalue  NUMBER := 0;
     v_OvervalueAdd      NUMBER := 0;
     v_RestOvervalueAdd  NUMBER := 0;
     v_RestAmount        NUMBER := 0;
     v_OldSaleOvervalue  NUMBER := 0;
     v_OverAmount        NUMBER := 0;
     /* КД*/ 
     v_NotDC NUMBER :=1;
     v_IsCoupDate NUMBER :=0; 
     v_Invest            NUMBER := 0;
     v_BonusRest         NUMBER := 0;
     v_AllCostRub        NUMBER := 0;
     v_IsBond            BOOLEAN := FALSE;
     v_SBCNew            NUMBER := 0;
     v_SBCNewNat         NUMBER := 0;
     v_SBCOldNat         NUMBER := 0;
     v_AllCostBuyNat     NUMBER := 0;
     v_CurBuyCostBuyNat  NUMBER := 0;
     v_BuyLotCostBuyNat  NUMBER := 0;
     v_IsLnk             NUMBER := 0;
     v_SaleAmount        NUMBER := 0;
     v_WrtAmount         NUMBER := 0;
     v_CrizOver          NUMBER := 0;
     v_WrtAmountAverOver NUMBER := 0;
     v_NeedAverOver      NUMBER := 0;
     v_AddOver           NUMBER := 0;
     v_OverAmountAdd     NUMBER := 0;


     v_Cost              NUMBER := 0;                                                                            
     v_CostRub           NUMBER := 0;
     v_InterestIncome    NUMBER := 0;                                                                  
     v_DiscountIncome    NUMBER := 0;                                                                  
     v_CostPFI           NUMBER := 0;                                                                         
     v_CorrValue         NUMBER := 0;                                                                       
     v_CorrIntToEIR      NUMBER := 0;                                                                     
     v_HedgCorr          NUMBER := 0;
     v_AmortHedgCorr     NUMBER := 0;
     v_NKDAmount         NUMBER := 0;

     v_ChangeCurBuyOver  NUMBER := 0;

     v_LotOutlay         NUMBER := 0;
     v_BOfficeKind       NUMBER := 0;

     v_SourceBuyID       NUMBER := 0;
     
     c_WRTSum2 sys_refcursor;

     CURSOR c_WRTSum IS (SELECT Lot.*
                           FROM DPMWRTSUM_DBT Lot
                          WHERE Lot.t_Department = p_SaleLot.t_Department AND
                                Lot.t_FIID       = p_SaleLot.t_FIID AND
                                Lot.t_Party      = p_SaleLot.t_Party AND
                                Lot.t_Contract   = p_SaleLot.t_Contract AND
                                (p_Group < 0 OR p_Group IS NULL OR Lot.t_GroupID = p_Group) AND
                                ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = Lot.t_Portfolio) ) AND
                                Lot.t_IsFree     = chr(88) AND
                                Lot.t_Date      <= p_SaleLot.t_Date  AND
                                ((Lot.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((Lot.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((Lot.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.t_Party > 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                --TIME                (CASE WHEN (p_CheckTime = 1) AND (t_Date = p_SaleLot.t_Date) THEN t_Time ELSE p_SaleLot.t_Time END) <= p_SaleLot.t_Time AND
                                (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE Lot.t_Date END) >= Lot.t_Date AND
                                (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE Lot.t_StateDate END) >= Lot.t_StateDate AND
                                Lot.t_SumID     <> p_SaleLot.t_Parent AND
                                ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (Lot.T_DATE = p_SaleLot.t_Date AND Lot.T_KIND = WRTSUM_KIND_B AND
                                                                                        EXISTS(SELECT 1
                                                                                                 FROM dobjatcor_dbt AtCor
                                                                                                WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                  AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                  AND AtCor.t_Object     = LPAD(Lot.t_DealID, 34, '0')
                                                                                                  AND AtCor.t_AttrID     = 1
                                                                                              )
                                                                                       )
                                ) AND
                                t_Amount - v_NeedLimitAmount * T_BLOCKAMOUNT > 0
                        );

     TYPE LotsCurTyp IS REF CURSOR;
     Lots LotsCurTyp;

   BEGIN
     InitError();

     v_ArchSearch := FALSE;

     IF( p_SaleLot.t_Date < RsbSessionData.curdate ) THEN

        if( p_CheckTime = 1 AND p_SaleLot.t_Party = -1) then
           v_CheckTime := p_SALELOT.T_TIME;
        else
           v_CheckTime := UnknownDate;
        end if;

        if( WRTAreChangesAfterDate( p_SALELOT.t_Department,
                                    p_SALELOT.T_FIID,
                                    p_SALELOT.T_PARTY,
                                    p_SALELOT.T_CONTRACT,
                                    p_Portfolio,
                                    p_Group,
                                    p_SALELOT.T_DATE,
                                    v_CheckTime,
                                    p_StartDate
                                  ) = True ) then
           SetError( WRTOFF_ERROR_20201, to_char(p_SALELOT.t_SUMID) );
        end if;
     END IF;

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     v_Amount := p_SaleLot.T_AMOUNT;
     v_TMPLNKID := 1;
     v_NeedLimitAmount := 1;

     IF( (Rsb_Common.GetRegFlagValue('SECUR\ПЕРЕД. ЗАБЛОКИР. ПОКУПКИ В РЕПО') = 'X') AND (p_SaleLot.T_KIND IN (200, 240, 290)) ) THEN
        v_NeedLimitAmount := 0;
     END IF;


     SELECT FIN.T_FACEVALUEFI, FIN.T_AVOIRKIND
       INTO v_FaceValueFI, v_AvoirKind
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID = p_SaleLot.t_FIID;

     v_IsBond := RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind);

     IF( p_Method = PM_WRITEOFF_FIFO OR p_Group = KINDPORT_BACK) THEN
        WHILE( v_Amount > 0 ) LOOP
           BEGIN
             IF SortingLotsAmount() = SORTING_LOTS_AMOUNT_ASC THEN

               SELECT * INTO v_BuyLot
                 FROM (SELECT /*+ INDEX( Buy DPMWRTSUM_DBT_IDXA)*/ Buy.*
                         FROM DPMWRTSUM_DBT Buy
                        WHERE Buy.t_Department = p_SaleLot.t_Department AND
                              Buy.t_FIID       = p_SaleLot.t_FIID AND
                              Buy.t_Party      = p_SaleLot.t_Party AND
                              (p_Group < 0 OR p_Group IS NULL OR Buy.t_GroupID = p_Group) AND
                              ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = Buy.t_Portfolio) ) AND
                              Buy.t_Contract   = p_SaleLot.t_Contract AND
                              Buy.T_ISFREE     = 'X' AND
                              (Buy.T_AMOUNT - v_NeedLimitAmount * Buy.T_BLOCKAMOUNT -
                                              (select NVL(SUM(TMP.T_AMOUNT),0)
                                                 from DPMWRTLNK_TMP TMP
                                                where TMP.T_BUYID = Buy.T_SUMID)) > 0 AND
                              Buy.t_State      = PM_WRTSUM_FORM AND
                              Buy.t_Date      <= p_SaleLot.t_Date  AND
                              (CASE WHEN (p_CheckTime = 1 AND p_SaleLot.t_Party = -1) AND (Buy.t_Date = p_SaleLot.t_Date) THEN Buy.t_Time ELSE p_SaleLot.t_Time END) <= p_SaleLot.t_Time AND
                              (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE Buy.t_Date END) >= Buy.t_Date AND
                              (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE Buy.t_StateDate END) >= Buy.t_StateDate AND
                              ((Buy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((Buy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((Buy.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.t_Party > 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                              Buy.T_SUMID <> p_SaleLot.t_Parent AND
                              ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (Buy.T_DATE = p_SaleLot.t_Date AND Buy.T_KIND = WRTSUM_KIND_B AND
                                                                                      EXISTS(SELECT 1
                                                                                                   FROM dobjatcor_dbt AtCor
                                                                                                  WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                    AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                    AND AtCor.t_Object     = LPAD(Buy.t_DealID, 34, '0')
                                                                                                    AND AtCor.t_AttrID     = 1
                                                                                                )
                                                                                     )
                              )
                        ORDER BY Buy.t_Date ASC, Buy.t_Time ASC, Buy.T_DealDate ASC, Buy.T_SortCode ASC, Buy.T_Amount ASC)

                WHERE ROWNUM = 1;

              ELSE

                SELECT * INTO v_BuyLot
                 FROM (SELECT /*+ INDEX( Buy DPMWRTSUM_DBT_IDXB)*/ Buy.*
                         FROM DPMWRTSUM_DBT Buy
                        WHERE Buy.t_Department = p_SaleLot.t_Department AND
                              Buy.t_FIID       = p_SaleLot.t_FIID AND
                              Buy.t_Party      = p_SaleLot.t_Party AND
                              (p_Group < 0 OR p_Group IS NULL OR Buy.t_GroupID = p_Group) AND
                              ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = Buy.t_Portfolio) ) AND
                              Buy.t_Contract   = p_SaleLot.t_Contract AND
                              Buy.T_ISFREE     = 'X' AND
                              (Buy.T_AMOUNT - v_NeedLimitAmount * Buy.T_BLOCKAMOUNT -
                                              (select NVL(SUM(TMP.T_AMOUNT),0)
                                                 from DPMWRTLNK_TMP TMP
                                                where TMP.T_BUYID = Buy.T_SUMID)) > 0 AND
                              Buy.t_State      = PM_WRTSUM_FORM AND
                              Buy.t_Date      <= p_SaleLot.t_Date  AND
                              (CASE WHEN (p_CheckTime = 1 AND p_SaleLot.t_Party = -1) AND (Buy.t_Date = p_SaleLot.t_Date) THEN Buy.t_Time ELSE p_SaleLot.t_Time END) <= p_SaleLot.t_Time AND
                              (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE Buy.t_Date END) >= Buy.t_Date AND
                              (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE Buy.t_StateDate END) >= Buy.t_StateDate AND
                              ((Buy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((Buy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((Buy.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.t_Party > 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                              Buy.T_SUMID <> p_SaleLot.t_Parent AND
                              ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (Buy.T_DATE = p_SaleLot.t_Date AND Buy.T_KIND = WRTSUM_KIND_B AND
                                                                                      EXISTS(SELECT 1
                                                                                                   FROM dobjatcor_dbt AtCor
                                                                                                  WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                    AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                    AND AtCor.t_Object     = LPAD(Buy.t_DealID, 34, '0')
                                                                                                    AND AtCor.t_AttrID     = 1
                                                                                                )
                                                                                     )
                              )
                        ORDER BY Buy.t_Date ASC, Buy.t_Time ASC, Buy.T_DealDate ASC, Buy.T_SortCode ASC, Buy.T_Amount DESC)

                WHERE ROWNUM = 1;
              END IF;
           EXCEPTION
              WHEN NO_DATA_FOUND THEN EXIT;--выходим именно из цикла, а не из процедуры (это важно - дальше нас ждет начисление ПДД и линковка)
              WHEN OTHERS THEN RETURN;
           END;

           INSERT INTO DPMWRTLNK_TMP
                      ( T_ID,
                        T_BUYID,
                        T_AMOUNT )
               VALUES ( v_TMPLNKID,
                        v_BuyLot.T_SUMID,
                        v_NeedLimitAmount * v_BuyLot.T_AMOUNT
                        );

           v_Amount   := v_Amount - v_BuyLot.T_AMOUNT;
           v_TMPLNKID := v_TMPLNKID + 1;
        END LOOP;

        IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or
            p_CalcDefDiff = true or p_CalcCorrIntToEIR = true ) THEN

           IF( p_LinkKind = PMWRTLINK_KIND_RETISSUE ) THEN
              select t_Termless into v_TERMLESS from davoiriss_dbt where t_FIID = p_SaleLot.T_FIID;
              v_CalcDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(p_SaleLot.T_FIID, v_TERMLESS);
           ELSE
              v_CalcDate := p_SaleLot.T_DATE;
           END IF;
           --Выполнить начисление во временную таблицу
           --Фактически - начисление по всем группам лотов из DPMWRTLNK_TMP, а не по всем лотам покупки, как при начислении ПДД
           RSI_WRTChargeIncomToLotsTMP (true, p_SaleLot.T_DATE, v_CalcDate, p_SaleLot.T_FIID, p_SaleLot.T_Department, -1, -1, -1, -1, -1, p_SaleLot.T_PARTY, p_SaleLot.T_CONTRACT,
                                        p_CalcInterest,
                                        p_CalcDiscount,
                                        p_CalcBonus,
                                        p_CalcDefDiff,
                                        p_CalcCorrIntToEIR,
                                        p_Method,
                                        p_SaleLot.T_TRUST = 'X',
                                        p_LinkKind,
                                        p_SaleLot.T_COUPON);

        END IF;
/* --262789
        IF( p_CalcReserve = true ) THEN
           -- Начислить РВЦБ/РВПЦБ
           RSI_WRTReserveLotsTMP(p_SaleLot.T_DATE, p_SaleLot.T_FIID, p_SaleLot.T_Department, 1, 1);
           -- Начислить оценочный резерв РОЦБ
           RSI_WRTEstReserveLotsTMP(p_SaleLot.T_DATE, p_SaleLot.T_FIID, p_SaleLot.T_Department, 1);
        END IF;
*/
        IF( p_CalcOver = true ) THEN
/* КД*/
 v_NotDC := 1 ;
 IF (p_SaleLot.T_KIND = WRTSUM_KIND_S) Then
   BEGIN 
     SELECT COUNT (1) INTO v_IsCoupDate
     FROM dfiwarnts_dbt warnt
     WHERE warnt.t_FIID = p_SaleLot.T_FIID and
     warnt.t_IsPartial <> chr(88) and
     warnt.t_DrawingDate = p_SaleLot.T_DATE;
   IF (v_IsCoupDate <>0) THEN
    v_NotDC := 0;
   END IF;
   EXCEPTION
    WHEN NO_DATA_FOUND THEN
    v_NotDC := 1 ;
   END;
   END iF;
 RSI_WRTOvervalueLotsTMP(p_SaleLot.T_DATE, p_SaleLot.T_FIID, p_SaleLot.T_Department, 1, p_SaleLot.T_DOCID , v_NotDC);
        END IF;

        OPEN Lots FOR SELECT L.* INTO v_BUYLOT
                        FROM DPMWRTSUM_DBT L, DPMWRTLNK_TMP TMP
                       WHERE L.T_SUMID = TMP.T_BUYID
                      ORDER BY T_ID ASC;
        LOOP

              FETCH Lots INTO v_BUYLOT;
              EXIT WHEN Lots%NOTFOUND OR
                        Lots%NOTFOUND IS NULL;

           IF( p_CalcOver AND (v_BuyLot.t_OverAmount <> 0 or v_BuyLot.T_CORRVALUE <> 0 or v_BuyLot.T_CORRINTTOEIR <> 0 or v_BuyLot.T_HEDGCORR <> 0 or v_BuyLot.T_AMORTHEDGCORR <> 0) ) THEN
              v_Val := v_BuyLot.t_BalanceCost - v_BuyLot.t_Cost - v_BuyLot.t_NKDAmount - v_BuyLot.t_InterestIncome - v_BuyLot.t_DiscountIncome - v_BuyLot.t_CostPFI;
           ELSE
              v_Val := v_BuyLot.t_OverAmount + v_BuyLot.T_CORRVALUE + v_BuyLot.T_CORRINTTOEIR + v_BuyLot.T_HEDGCORR + v_BuyLot.T_AMORTHEDGCORR;
           END IF;

           v_LnkCostBuyNat              := 0;

           -- теперь будем списывать
           v_Link.t_LnkID               := 0;
           v_Link.t_SaleID              := p_SaleLot.t_SumID;
           v_Link.t_BuyID               := v_BuyLot.t_SumID;
           v_Link.t_Kind                := p_LinkKind;
           v_Link.t_DiscountIncomeAdd   := 0;
           v_Link.t_InterestIncomeAdd   := 0;
           v_Link.t_BonusAdd            := 0;
           v_Link.t_Coupon              := p_SaleLot.t_Coupon;
           v_Link.t_Partly              := p_SaleLot.t_Partly;
           v_Link.t_ID_Operation        := p_ID_Operation;
           v_Link.t_ID_Step             := p_ID_Step;
           v_Link.t_Action              := p_Action;
           v_Link.t_CreateDate          := p_SaleLot.t_Date;
           v_LnkAmount                  := v_BuyLot.t_Amount;
           IF(v_NeedLimitAmount  != 0) THEN
              v_LnkAmount := v_LnkAmount  - v_BuyLot.T_BLOCKAMOUNT;
           END IF;

           IF( v_LnkAmount <= p_SaleLot.t_Amount ) THEN
              v_AmountRate                 := v_LnkAmount / p_SaleLot.t_Amount;

              IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                 BEGIN
                    IF v_BUYLOT.T_PARENT = 0 AND v_BUYLOT.T_SOURCE = 0 THEN
                      --Если лот не является порожденным в ПРЕПО, то нужно делать вычисления исходя из начальных значений лота

                      SELECT ROUND(RSI_RSB_FIInstr.ConvSum(B.T_SUM, B.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_BUYLOT.T_BEGDATE, 1),2), B.T_OUTLAY
                        INTO v_BegCostBuy, v_LotOutlay
                        FROM V_SCWRTHIST B
                       WHERE B.T_SUMID = v_BUYLOT.T_SUMID
                         AND B.T_INSTANCE = 0;

                      IF v_LotOutlay > 0 THEN
                        SELECT t_BOfficeKind INTO v_BOfficeKind
                          FROM ddl_tick_dbt
                         WHERE t_DealID = v_BUYLOT.T_DEALID;

                        v_BegCostBuy := v_BegCostBuy + GetComSumByDeal_Essential(v_BOfficeKind, v_BUYLOT.T_DEALID, v_BUYLOT.T_BEGDATE, RSI_RSB_FIInstr.NATCUR, v_BUYLOT.T_PORTFOLIO, v_BUYLOT.T_Contract, v_BegCostBuy);
                      END IF;

                    ELSE
                      --Если лот по 2ч ПРЕПО, то при передаче бумаг в ПРЕПО уже высчитывали рублевый эквивалент. Соответственно, можно взять его из той связи
                      SELECT LNK.T_COSTBUYNAT
                        INTO v_BegCostBuy
                        FROM DPMWRTLNK_DBT LNK
                       WHERE LNK.T_SALEID = v_BUYLOT.T_PARENT
                         AND LNK.T_BUYID = v_BUYLOT.T_SOURCE;

                    END IF;

                 EXCEPTION
                    WHEN OTHERS THEN v_BegCostBuy := 0;
                 END;

                 BEGIN
                    SELECT NVL(SUM(L.T_COSTBUYNAT),0) INTO v_LastWrtCostBuyNat
                      FROM DPMWRTLNK_DBT L
                     WHERE L.T_BUYID = v_BUYLOT.T_SUMID;
                 EXCEPTION
                    WHEN OTHERS THEN v_LastWrtCostBuyNat := 0;
                 END;

                 v_LnkCostBuyNat := v_BegCostBuy - v_LastWrtCostBuyNat;
              END IF;

              v_Link.t_Amount              := v_LnkAmount;
              v_Link.t_SumSale             := ROUND(p_SaleLot.t_Sum * v_AmountRate,2);
              v_Link.t_SumBuy              := ROUND(v_BuyLot.t_Sum * v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_CostSale            := ROUND(p_SaleLot.t_Cost * v_AmountRate,2);
              v_Link.t_CostBuy             := ROUND(v_BuyLot.t_Cost* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_NKDSaleAmount       := ROUND(p_SaleLot.t_NKDAmount * v_AmountRate,2);
              v_Link.t_NKDBuyAmount        := ROUND(v_BuyLot.t_NKDAmount* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_InterestIncomeBuy   := ROUND(v_BuyLot.t_InterestIncome* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_NotCarryInterestBuy := ROUND(v_BuyLot.t_NotCarryInterest* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_BegDiscountChange   := ROUND(v_BuyLot.t_BegDiscount*  v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_OldBegDiscountChange:= ROUND(v_BuyLot.t_OldBegDiscount*  v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.T_DISCOUNTCORRCHANGE  := ROUND(v_BUYLOT.T_DISCOUNTCORR*  v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_BegBonusChange      := ROUND(v_BuyLot.t_BegBonus* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.T_OLDBEGBONUSCHANGE   := ROUND(v_BUYLOT.T_OLDBEGBONUS* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_DiscountIncomeBuy   := ROUND(v_BuyLot.t_DiscountIncome* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_NotCarryDiscountBuy := ROUND(v_BuyLot.t_NotCarryDiscount* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_BonusBuy            := ROUND(v_BuyLot.t_Bonus * v_LnkAmount /v_BuyLot.T_AMOUNT,2);
              v_Link.t_OldBonusBuy         := ROUND(v_BuyLot.t_OldBonus* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_OutlaySale          := ROUND(p_SaleLot.t_Outlay * v_AmountRate,2);
              v_Link.t_OutlayBuy           := ROUND(v_BuyLot.t_Outlay* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_ReservChange        := ROUND(v_BuyLot.t_ReservAmount* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.T_INCOMERESERVCHANGE  := ROUND(v_BuyLot.T_INCOMERESERV* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_OverChange          := ROUND(v_BuyLot.t_OverAmount* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.t_BalanceCostBuy      := v_Link.t_CostBuy + v_Link.t_NKDBuyAmount + v_Link.t_InterestIncomeBuy + v_Link.t_DiscountIncomeBuy + v_BuyLot.t_CostPFI + ROUND(v_Val * v_LnkAmount / v_BuyLot.T_AMOUNT,2);
              v_Link.t_BalanceCostSale     := ROUND(p_SaleLot.t_BalanceCost * v_AmountRate,2);
              IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
                 v_Link.t_BalanceCostBD    := ROUND(p_SaleLot.t_BalanceCostBD * v_AmountRate,2);
                 v_Link.t_OverChangeBD     := ROUND(p_SaleLot.t_OverAmountBD * v_AmountRate,2);
              ELSE
                 v_Link.t_BalanceCostBD    := 0;
                 v_Link.t_OverChangeBD     := 0;
              END IF;

              v_Link.T_NOTWRTBONUSBUY      := ROUND(v_BuyLot.T_NOTWRTBONUS* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.T_COSTPFIBUY          := ROUND(v_BuyLot.T_COSTPFI* v_LnkAmount / v_BuyLot.t_Amount,2);
              v_Link.T_BLOCKAMOUNTBUY      := v_LnkAmount - (v_BuyLot.T_AMOUNT - v_BuyLot.T_BLOCKAMOUNT);
              v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
              v_Link.T_ACCOUNTEDDEFDIFFBUY := ROUND(v_BuyLot.T_ACCOUNTEDDEFDIFF* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_BEGDEFDIFFCHANGE    := ROUND(v_BuyLot.T_BEGDEFDIFF* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_WRTOUTLAYADD        := 0;
              v_Link.T_WRTOUTLAYBUY        := ROUND(v_BuyLot.T_WRTOUTLAY* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_WRTVATOUTLAYADD     := 0;
              v_Link.T_WRTVATOUTLAYBUY     := ROUND(v_BuyLot.T_WRTVATOUTLAY* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_VATOUTLAYCHANGE     := ROUND(v_BuyLot.T_VATOUTLAY* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_FAIRVALUECHANGE     := ROUND(v_BuyLot.T_FAIRVALUE* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_AMORTCOSTCHANGE     := ROUND(v_BuyLot.T_AMORTCOST* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_CORRVALUECHANGE     := ROUND(v_BuyLot.T_CORRVALUE* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_ESTRESERVCHANGE     := ROUND(v_BuyLot.T_ESTRESERVE* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_CORRINTTOEIRCHANGE  := ROUND(v_BuyLot.T_CORRINTTOEIR * v_LnkAmount /v_BuyLot.T_AMOUNT,2);
              v_Link.T_CORRESTRESERVCHANGE := ROUND(v_BuyLot.T_CORRESTRESERVE* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_CORRINTTOEIRADD     := 0;
              v_Link.T_ESTRESERVEADD       := 0;
              v_Link.T_CORRESTRESERVEADD   := 0;
              v_Link.T_RESERVADD           := 0;
              v_Link.T_INCOMERESERVADD     := 0;
              v_Link.T_OVERAMOUNTADD       := 0;
              v_Link.T_COSTBUYNAT          := v_LnkCostBuyNat;
              v_Link.T_ADDINCOMEOWNCHANGE  := ROUND(v_BuyLot.T_ADDINCOMEOWN* v_LnkAmount /v_BUYLOT.T_AMOUNT,2);
              v_Link.T_HEDGCORRCHANGE      := ROUND(v_BuyLot.T_HEDGCORR * v_LnkAmount /v_BuyLot.T_AMOUNT,2);
              v_Link.T_AMORTHEDGCORRCHANGE := ROUND(v_BuyLot.T_AMORTHEDGCORR * v_LnkAmount /v_BuyLot.T_AMOUNT,2);
           ELSE
              v_AmountRate                 := p_SaleLot.t_Amount / v_BuyLot.t_Amount;

              IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                 BEGIN
                   IF v_BUYLOT.T_PARENT = 0 AND v_BUYLOT.T_SOURCE = 0 THEN
                     --Если лот не является порожденным в ПРЕПО, то нужно делать вычисления исходя из начальных значений лота
                     SELECT ROUND(RSI_RSB_FIInstr.ConvSum(B.T_SUM, B.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_BUYLOT.T_BEGDATE, 1),2),
                            B.T_AMOUNT, B.T_OUTLAY
                       INTO v_BegCostBuy, v_BegAmount, v_LotOutlay
                       FROM V_SCWRTHIST B
                      WHERE B.T_SUMID = (CASE WHEN v_BUYLOT.T_SOURCE > 0 THEN v_BUYLOT.T_SOURCE ELSE v_BUYLOT.T_SUMID END)
                        AND B.T_INSTANCE = 0;

                     IF v_LotOutlay > 0 THEN
                       SELECT t_BOfficeKind INTO v_BOfficeKind
                         FROM ddl_tick_dbt
                        WHERE t_DealID = v_BUYLOT.T_DEALID;

                       v_BegCostBuy := v_BegCostBuy + GetComSumByDeal_Essential(v_BOfficeKind, v_BUYLOT.T_DEALID, v_BUYLOT.T_BEGDATE, RSI_RSB_FIInstr.NATCUR, v_BUYLOT.T_PORTFOLIO, v_BUYLOT.T_Contract, v_BegCostBuy);
                     END IF;

                   ELSE
                     --Если лот по 2ч ПРЕПО, то при передаче бумаг в ПРЕПО уже высчитывали рублевый эквивалент. Соответственно, можно взять его из той связи
                     SELECT LNK.T_COSTBUYNAT, LNK.T_AMOUNT
                       INTO v_BegCostBuy, v_BegAmount
                       FROM DPMWRTLNK_DBT LNK
                      WHERE LNK.T_SALEID = v_BUYLOT.T_PARENT
                        AND LNK.T_BUYID = v_BUYLOT.T_SOURCE;

                   END IF;
                 EXCEPTION
                    WHEN OTHERS THEN v_BegCostBuy := 0; v_BegAmount := 0;
                 END;

                 v_LnkCostBuyNat := ROUND((v_BegCostBuy * p_SaleLot.t_Amount / v_BegAmount),2);
              END IF;

              v_Link.t_Amount              := p_SaleLot.t_Amount;
              v_Link.t_SumSale             := p_SaleLot.t_Sum;
              v_Link.t_SumBuy              := ROUND(v_BuyLot.t_Sum * v_AmountRate,2);
              v_Link.t_CostSale            := p_SaleLot.t_Cost;
              v_Link.t_NKDSaleAmount       := p_SaleLot.t_NKDAmount;
              v_Link.t_NKDBuyAmount        := ROUND(v_BuyLot.t_NKDAmount * v_AmountRate,2);
              v_Link.t_InterestIncomeBuy   := ROUND(v_BuyLot.t_InterestIncome * v_AmountRate,2);
              v_Link.t_NotCarryInterestBuy := ROUND(v_BuyLot.t_NotCarryInterest * v_AmountRate,2);
              v_Link.t_BegDiscountChange   := ROUND(v_BuyLot.t_BegDiscount * v_AmountRate,2);
              v_Link.t_OldBegDiscountChange:= ROUND(v_BuyLot.t_OldBegDiscount * v_AmountRate,2);
              v_Link.T_DISCOUNTCORRCHANGE  := ROUND(v_BuyLot.T_DISCOUNTCORR  * v_AmountRate,2);
              v_Link.t_BegBonusChange      := ROUND(v_BuyLot.t_BegBonus * v_AmountRate,2);
              v_Link.T_OLDBEGBONUSCHANGE   := ROUND(v_BuyLot.T_OLDBEGBONUS  * v_AmountRate,2);
              v_Link.t_DiscountIncomeBuy   := ROUND(v_BuyLot.t_DiscountIncome * v_AmountRate,2);
              v_Link.t_NotCarryDiscountBuy := ROUND(v_BuyLot.t_NotCarryDiscount * v_AmountRate,2);
              v_Link.t_BonusBuy            := ROUND(v_BuyLot.t_Bonus * v_AmountRate,2);
              v_Link.t_OldBonusBuy         := ROUND(v_BuyLot.t_OldBonus * v_AmountRate,2);
              v_Link.t_OutlaySale          := p_SaleLot.t_Outlay;
              v_Link.t_OutlayBuy           := ROUND(v_BuyLot.t_Outlay * v_AmountRate,2);
              v_Link.t_ReservChange        := ROUND(v_BuyLot.t_ReservAmount * v_AmountRate,2);
              v_Link.t_INCOMERESERVCHANGE  := ROUND(v_BuyLot.t_INCOMERESERV * v_AmountRate,2);
              v_Link.t_OverChange          := ROUND(v_BuyLot.t_OverAmount * v_AmountRate,2);
              v_Link.t_CostBuy             := ROUND(v_BuyLot.t_Cost * v_AmountRate -
                                                    (v_buylot.t_begbonus * v_amountrate - v_link.t_begbonuschange) +
                                                    (v_buylot.t_bonus * v_amountrate - v_link.t_bonusbuy),2);
              v_Link.T_COSTPFIBUY          := ROUND(v_BuyLot.T_COSTPFI * v_AmountRate, 2);
              v_Link.t_BalanceCostBuy      := v_Link.t_CostBuy + v_Link.t_NKDBuyAmount + v_Link.t_InterestIncomeBuy + v_Link.t_DiscountIncomeBuy + v_Link.T_COSTPFIBUY + ROUND(v_Val * v_AmountRate,2);
              v_Link.t_BalanceCostSale     := p_SaleLot.t_BalanceCost;
              IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
                 v_Link.t_BalanceCostBD    := p_SaleLot.t_BalanceCostBD;
                 v_Link.t_OverChangeBD     := p_SaleLot.t_OverAmountBD;
              ELSE
                 v_Link.t_BalanceCostBD    := 0;
                 v_Link.t_OverChangeBD     := 0;
              END IF;

              v_Link.T_NOTWRTBONUSBUY      := ROUND(v_BuyLot.T_NOTWRTBONUS * v_AmountRate,2);
              v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
              v_Link.T_ACCOUNTEDDEFDIFFBUY := ROUND(v_BuyLot.T_ACCOUNTEDDEFDIFF * v_AmountRate,2);
              v_Link.T_BEGDEFDIFFCHANGE    := ROUND(v_BuyLot.T_BEGDEFDIFF * v_AmountRate,2);
              v_Link.T_WRTOUTLAYADD        := 0;
              v_Link.T_WRTOUTLAYBUY        := ROUND(v_BuyLot.T_WRTOUTLAY * v_AmountRate,2);
              v_Link.T_WRTVATOUTLAYADD     := 0;
              v_Link.T_WRTVATOUTLAYBUY     := ROUND(v_BuyLot.T_WRTVATOUTLAY * v_AmountRate,2);
              v_Link.T_VATOUTLAYCHANGE     := ROUND(v_BuyLot.T_VATOUTLAY * v_AmountRate,2);
              v_Link.T_FAIRVALUECHANGE     := ROUND(v_BuyLot.T_FAIRVALUE * v_AmountRate,2);
              v_Link.T_AMORTCOSTCHANGE     := ROUND(v_BuyLot.T_AMORTCOST * v_AmountRate,2);
              v_Link.T_CORRVALUECHANGE     := ROUND(v_BuyLot.T_CORRVALUE * v_AmountRate,2);
              v_Link.T_ESTRESERVCHANGE     := ROUND(v_BuyLot.T_ESTRESERVE * v_AmountRate,2);
              v_Link.T_CORRINTTOEIRCHANGE  := ROUND(v_BuyLot.T_CORRINTTOEIR * v_AmountRate,2);
              v_Link.T_CORRESTRESERVCHANGE := ROUND(v_BuyLot.T_CORRESTRESERVE* v_AmountRate,2);
              v_Link.T_CORRINTTOEIRADD     := 0;
              v_Link.T_ESTRESERVEADD       := 0;
              v_Link.T_CORRESTRESERVEADD   := 0;
              v_Link.T_RESERVADD           := 0;
              v_Link.T_INCOMERESERVADD     := 0;
              v_Link.T_OVERAMOUNTADD       := 0;
              v_Link.T_COSTBUYNAT          := v_LnkCostBuyNat;
              v_Link.T_ADDINCOMEOWNCHANGE  := ROUND(v_BuyLot.T_ADDINCOMEOWN* v_AmountRate,2);
              v_Link.T_HEDGCORRCHANGE      := ROUND(v_BuyLot.T_HEDGCORR * v_AmountRate,2);
              v_Link.T_AMORTHEDGCORRCHANGE := ROUND(v_BuyLot.T_AMORTHEDGCORR * v_AmountRate,2);
           END IF;

           IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or
               p_CalcDefDiff = true or p_CalcCorrIntToEIR = true ) THEN
              WRTChangeIncomeOnSale(v_Link, v_BuyLot, p_CalcInterest, p_CalcDiscount, p_CalcBonus, p_CalcDefDiff, p_CalcCorrIntToEIR, false /*p_CalcReserve*/, p_CalcOver, p_Method, v_CalcDate);
           END IF;

           BEGIN
              RSI_InsDfltIntoWRTLNK(v_Link);
              INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

              p_SaleLot.t_Amount        := p_SaleLot.t_Amount - v_Link.t_Amount;
              p_SaleLot.t_Sum           := p_SaleLot.t_Sum - v_Link.t_SumSale;
              p_SaleLot.t_Cost          := p_SaleLot.t_Cost - v_Link.t_CostSale;
              p_SaleLot.t_BalanceCost   := p_SaleLot.t_BalanceCost - v_Link.t_BalanceCostSale;
              p_SaleLot.t_NKDAmount     := p_SaleLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
              p_SaleLot.t_Outlay        := p_SaleLot.t_Outlay - v_Link.t_OutlaySale;

              IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD AND p_SaleLot.t_Party = UnknownParty) THEN
                 p_SaleLot.t_AmountBD      := p_SaleLot.t_AmountBD - v_Link.t_Amount;
                 p_SaleLot.t_BalanceCostBD := p_SaleLot.t_BalanceCostBD - v_Link.t_BalanceCostBD;
                 p_SaleLot.t_OverAmountBD  := p_SaleLot.t_OverAmountBD - v_Link.t_OverChangeBD;
              END IF;

           END;

        END LOOP;

        CLOSE Lots;
     ELSE --средневзвешенный

       v_Amount := p_SaleLot.T_AMOUNT;

       v_CrizOver := RSB_SECUR.GetMainObjAttr(cnst.OBJTYPE_AVOIRISS, LPAD(p_SaleLot.t_FIID, 10, '0'), 65/*Кризисная переоценка*/, p_SaleLot.t_Date);

       INSERT INTO DPMWRTSUM_TMP
                   (
                     T_SUMID,
                     T_KIND,
                     T_AMOUNT,
                     T_COST,
                     T_BALANCECOST,
                     T_INTERESTADD,
                     T_BONUSADD,
                     T_DISCOUNTADD,
                     T_INTERESTINCOME,
                     T_NOTCARRYINTEREST,
                     T_INTERESTDATE,
                     T_BEGDISCOUNTDATE,
                     T_BEGBONUSDATE,
                     T_DISCOUNTINCOME,
                     T_NOTCARRYDISCOUNT,
                     T_DISCOUNTDATE,
                     T_BONUS,
                     T_BONUSDATE,
                     T_NOTWRTBONUS,
                     T_DEFDIFFADD,
                     T_ACCOUNTEDDEFDIFF,
                     T_DEFDIFFDATE,
                     T_WRTOUTLAYADD,
                     T_WRTOUTLAY,
                     T_WRTOUTLAYDATE,
                     T_VATOUTLAYADD,
                     T_WRTVATOUTLAY,
                     T_CORRVALUE,
                     T_CORRDATE,
                     T_AMORTCOST,
                     T_CORRINTTOEIR,
                     T_CORRINTTOEIRDATE,
                     T_WRTCORRINTTOEIR,
                     T_ESTRESERVEADD,
                     T_CORRESTRESERVEADD,
                     T_RESERVAMOUNTADD,
                     T_INCOMERESERVADD,
                     T_PORTFOLIO,
                     T_STATE,
                     T_OVERAMOUNT,
                     T_OVERAMOUNTADD,
                     T_DEALID,
                     T_BEGDEFDIFFDATE,
                     T_HEDGCORR,
                     T_HEDGCORRDATE,
                     T_AMORTHEDGCORR,
                     T_AMORTHEDGCORRDATE
                   )
            SELECT
                     LOT.T_SUMID,
                     0,
                     LOT.T_AMOUNT,
                     LOT.T_COST,
                     LOT.T_BALANCECOST,
                     0,
                     0,
                     0,
                     LOT.T_INTERESTINCOME,
                     LOT.T_NOTCARRYINTEREST,
                     LOT.T_INTERESTDATE,
                     LOT.T_BEGDISCOUNTDATE,
                     LOT.T_BEGBONUSDATE,
                     LOT.T_DISCOUNTINCOME,
                     LOT.T_NOTCARRYDISCOUNT,
                     LOT.T_DISCOUNTDATE,
                     LOT.T_BONUS,
                     LOT.T_BONUSDATE,
                     LOT.T_NOTWRTBONUS,
                     0,
                     LOT.T_ACCOUNTEDDEFDIFF,
                     LOT.T_DEFDIFFDATE,
                     0,
                     LOT.T_WRTOUTLAY,
                     LOT.T_WRTOUTLAYDATE,
                     0,
                     LOT.T_WRTVATOUTLAY,
                     LOT.T_CORRVALUE,
                     LOT.T_CORRDATE,
                     LOT.T_AMORTCOST,
                     LOT.T_CORRINTTOEIR,
                     LOT.T_CORRINTTOEIRDATE,
                     0,
                     0,
                     0,
                     0,
                     0,
                     LOT.T_PORTFOLIO,
                     LOT.T_STATE,
                     LOT.T_OVERAMOUNT,
                     0,
                     LOT.T_DEALID,
                     LOT.T_BEGDEFDIFFDATE,
                     LOT.T_HEDGCORR,
                     LOT.T_HEDGCORRDATE,
                     LOT.T_AMORTHEDGCORR,
                     LOT.T_AMORTHEDGCORRDATE
        FROM DPMWRTSUM_DBT LOT
       WHERE LOT.t_Department = p_SaleLot.t_Department AND
             LOT.t_FIID       = p_SaleLot.t_FIID AND
             LOT.t_Party      = p_SaleLot.t_Party AND
             ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = LOT.t_Portfolio) ) AND
             (p_Group < 0 OR p_Group IS NULL OR LOT.t_GroupID = p_Group) AND
             LOT.t_Contract   = p_SaleLot.t_Contract AND
             LOT.t_State      = PM_WRTSUM_FORM AND
             LOT.t_IsFree     = chr(88) AND
             LOT.t_Date      <= p_SaleLot.t_Date  AND
             LOT.T_ACTIVATEDATE <= p_SaleLot.T_DATE AND
             (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LOT.t_Date END) >= LOT.t_Date AND
             (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LOT.t_StateDate END) >= LOT.t_StateDate AND
             LOT.T_Amount - v_NeedLimitAmount*LOT.T_BLOCKAMOUNT  > 0;



       IF( p_CalcOver = true ) THEN
         --Делаем временные связи, чтобы переоценить перед выбытием весь портфель во временной таблице по способу переоценки при выбытии
         INSERT INTO DPMWRTLNK_TMP
                ( T_ID,
                  T_BUYID,
                  T_AMOUNT )
         SELECT ROWNUM, TMP.T_SUMID, v_NeedLimitAmount * TMP.T_AMOUNT
           FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
          WHERE LOT.T_SUMID = TMP.T_SUMID
            AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
            AND LOT.T_PORTFOLIO NOT IN (KINDPORT_BACK, KINDPORT_BASICDEBT);


         RSI_WRTOvervalueLotsTMP(p_SaleLot.T_DATE, p_SaleLot.T_FIID, p_SaleLot.T_Department, 1, p_SaleLot.T_DOCID);

         --Временные связи больше не нужны
         DELETE FROM DPMWRTLNK_TMP;
       END IF;

       BEGIN
         SELECT Count(1),
                NVL(SUM(LOT.t_Amount),0),
                NVL(SUM(LOT.t_Cost),0),
                NVL(SUM(RSI_RSB_FIInstr.ConvSum(LOT.T_COST, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0), 
                NVL(SUM(LOT.t_BALANCECOST),0),
                NVL(SUM(LOT.t_NKDAmount),0),
                NVL(SUM(LOT.t_InterestIncome),0),
                NVL(SUM(LOT.t_NotCarryInterest),0),
                NVL(SUM(LOT.t_BegDiscount),0),
                NVL(SUM(LOT.t_OldBegDiscount),0),
                NVL(SUM(LOT.t_DiscountIncome),0),
                NVL(SUM(LOT.t_NotCarryDiscount),0),
                NVL(SUM(LOT.t_ReservAmount),0),
                NVL(SUM(LOT.t_IncomeReserv),0),
                NVL(SUM(LOT.t_Outlay),0),
                NVL(SUM(LOT.T_OVERAMOUNT),0),
                NVL(SUM(LOT.t_BegBonus),0),
                NVL(SUM(LOT.t_Bonus),0),
                NVL(SUM(LOT.t_OldBonus),0),
                NVL(SUM(LOT.T_DISCOUNTCORR),0),
                NVL(SUM(LOT.T_OLDBEGBONUS),0),
                NVL(SUM(LOT.T_NOTWRTBONUS),0),
                NVL(SUM(LOT.T_COSTPFI),0),
                NVL(SUM(LOT.T_BLOCKAMOUNT), 0),
                NVL(SUM(LOT.T_ACCOUNTEDDEFDIFF), 0),
                NVL(SUM(LOT.T_BEGDEFDIFF), 0),
                NVL(SUM(LOT.T_WRTOUTLAY), 0),
                NVL(SUM(LOT.T_WRTVATOUTLAY), 0),
                NVL(SUM(LOT.T_VATOUTLAY), 0),
                NVL(SUM(LOT.T_FAIRVALUE), 0),
                NVL(SUM(LOT.T_AMORTCOST), 0),
                NVL(SUM(LOT.T_CORRVALUE), 0),
                NVL(SUM(LOT.T_CORRINTTOEIR), 0),
                NVL(SUM(LOT.T_ESTRESERVE), 0),
                NVL(SUM(LOT.T_CORRESTRESERVE), 0),
                NVL(SUM(LOT.T_HEDGCORR), 0),
                NVL(SUM(LOT.T_AMORTHEDGCORR), 0)
           INTO v_Count,
                v_All.t_Amount,
                v_All.t_Cost,
                v_AllCostRub,
                v_ALL.T_BALANCECOST,
                v_All.t_NKDAmount,
                v_All.t_InterestIncome,
                v_All.t_NotCarryInterest,
                v_All.t_BegDiscount,
                v_All.t_OldBegDiscount,
                v_All.t_DiscountIncome,
                v_All.t_NotCarryDiscount,
                v_All.t_ReservAmount,
                v_All.t_IncomeReserv,
                v_All.t_Outlay,
                v_All.t_OverAmount,
                v_All.t_BegBonus,
                v_All.t_Bonus,
                v_All.t_OldBonus,
                v_All.T_DISCOUNTCORR,
                v_All.T_OLDBEGBONUS,
                v_All.T_NOTWRTBONUS,
                v_All.T_COSTPFI,
                v_All.T_BLOCKAMOUNT,
                v_All.T_ACCOUNTEDDEFDIFF,
                v_All.T_BEGDEFDIFF,
                v_All.T_WRTOUTLAY,
                v_All.T_WRTVATOUTLAY,
                v_All.T_VATOUTLAY,
                v_All.T_FAIRVALUE,
                v_All.T_AMORTCOST,
                v_All.T_CORRVALUE,
                v_All.T_CORRINTTOEIR,
                v_All.T_ESTRESERVE,
                v_All.T_CORRESTRESERVE,
                v_All.T_HEDGCORR,
                v_All.T_AMORTHEDGCORR
           FROM DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP
          WHERE TMP.T_SUMID = LOT.T_SUMID;

       END;

       IF( (v_All.t_Amount - v_NeedLimitAmount*v_All.T_BLOCKAMOUNT) <= p_SaleLot.t_Amount )THEN --полная продажа портфеля
         FOR BuyLot IN c_WRTSum LOOP
            v_LnkAmount := BuyLot.t_Amount - v_NeedLimitAmount*BuyLot.T_BLOCKAMOUNT;

            v_Link.t_LnkID               := 0;
            v_Link.t_SaleID              := p_SaleLot.t_SumID;
            v_Link.t_BuyID               := BuyLot.t_SumID;
            v_Link.t_Kind                := p_LinkKind;
            v_Link.t_Amount              := v_LnkAmount;
            v_Link.t_SumSale             := ROUND(p_SaleLot.t_Sum * v_LnkAmount / p_SaleLot.t_Amount,2);
            v_Link.t_SumBuy              := ROUND(BuyLot.t_Sum * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_CostSale            := ROUND(p_SaleLot.t_Cost * v_LnkAmount / p_SaleLot.t_Amount,2);
            v_Link.t_CostBuy             := ROUND(BuyLot.t_Cost * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_BalanceCostSale     := ROUND(p_SaleLot.t_BalanceCost * v_LnkAmount / p_SaleLot.t_Amount,2);
            v_Link.t_BalanceCostBuy      := ROUND(BUYLOT.T_BALANCECOST * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_NKDSaleAmount       := ROUND(p_SaleLot.t_NKDAmount * v_LnkAmount / p_SaleLot.t_Amount,2);
            v_Link.t_NKDBuyAmount        := ROUND(BuyLot.t_NKDAmount * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_InterestIncomeBuy   := ROUND(BuyLot.t_InterestIncome * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_InterestIncomeAdd   := 0;
            v_Link.t_NotCarryInterestBuy := ROUND(BuyLot.t_NotCarryInterest * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_BegDiscountChange   := ROUND(BuyLot.t_BegDiscount * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_OldBegDiscountChange:= ROUND(BuyLot.t_OldBegDiscount * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_DISCOUNTCORRCHANGE  := ROUND(BUYLOT.T_DISCOUNTCORR * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_BegBonusChange      := ROUND(BuyLot.t_BegBonus * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_OLDBEGBONUSCHANGE   := ROUND(BUYLOT.T_OLDBEGBONUS * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_DiscountIncomeBuy   := ROUND(BuyLot.t_DiscountIncome * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_DiscountIncomeAdd   := 0;
            v_Link.t_NotCarryDiscountBuy := ROUND(BuyLot.t_NotCarryDiscount * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_NotCarryDiscountAdd := 0;
            v_Link.t_BonusBuy            := ROUND(BuyLot.t_Bonus * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_OldBonusBuy         := ROUND(BuyLot.t_OldBonus * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_BonusAdd            := 0;
            v_Link.t_OutlaySale          := ROUND(p_SaleLot.t_Outlay * v_LnkAmount / p_SaleLot.t_Amount,2);
            v_Link.t_OutlayBuy           := ROUND(BuyLot.t_Outlay * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_ReservChange        := ROUND(BuyLot.t_ReservAmount * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_IncomeReservChange  := ROUND(BuyLot.t_IncomeReserv * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_OverChange          := ROUND(BuyLot.t_OverAmount * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.t_Coupon              := p_SaleLot.t_Coupon;
            v_Link.t_Partly              := p_SaleLot.t_Partly;
            v_Link.t_ID_Operation        := p_ID_Operation;
            v_Link.t_ID_Step             := p_ID_Step;
            v_Link.t_Action              := p_Action;
            v_Link.t_CreateDate          := p_SaleLot.t_Date;

            IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
               v_Link.t_BalanceCostBD    := ROUND(p_SaleLot.t_BalanceCostBD * v_LnkAmount / p_SaleLot.t_Amount,2);
               v_Link.t_OverChangeBD     := ROUND(p_SaleLot.t_OverAmountBD * v_LnkAmount / p_SaleLot.t_Amount,2);
            ELSE
               v_Link.t_BalanceCostBD    := 0;
               v_Link.t_OverChangeBD     := 0;
            END IF;

            v_Link.T_NOTWRTBONUSBUY := ROUND(BuyLot.T_NOTWRTBONUS * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_COSTPFIBUY     := ROUND(BuyLot.T_COSTPFI * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_BLOCKAMOUNTBUY := v_LnkAmount - (BuyLot.T_AMOUNT - BuyLot.T_BLOCKAMOUNT);

            v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
            v_Link.T_ACCOUNTEDDEFDIFFBUY := ROUND(BuyLot.T_ACCOUNTEDDEFDIFF * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_BEGDEFDIFFCHANGE    := ROUND(BuyLot.T_BEGDEFDIFF * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_WRTOUTLAYADD        := 0;
            v_Link.T_WRTOUTLAYBUY        := ROUND(BuyLot.T_WRTOUTLAY * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_WRTVATOUTLAYADD     := 0;
            v_Link.T_WRTVATOUTLAYBUY     := ROUND(BuyLot.T_WRTVATOUTLAY * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_VATOUTLAYCHANGE     := ROUND(BuyLot.T_VATOUTLAY * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_FAIRVALUECHANGE     := ROUND(BuyLot.T_FAIRVALUE * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_AMORTCOSTCHANGE     := ROUND(BuyLot.T_AMORTCOST * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_CORRVALUECHANGE     := ROUND(BuyLot.T_CORRVALUE * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_ESTRESERVCHANGE     := ROUND(BuyLot.T_ESTRESERVE * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_CORRINTTOEIRCHANGE  := ROUND(BuyLot.T_CORRINTTOEIR * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_CORRESTRESERVCHANGE := ROUND(BuyLot.T_CORRESTRESERVE* v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_CORRINTTOEIRADD     := 0;
            v_Link.T_ESTRESERVEADD       := 0;
            v_Link.T_CORRESTRESERVEADD   := 0;
            v_Link.T_RESERVADD           := 0;
            v_Link.T_INCOMERESERVADD     := 0;
            v_Link.T_OVERAMOUNTADD       := 0;
            v_Link.T_ADDINCOMEOWNCHANGE  := ROUND(BuyLot.T_ADDINCOMEOWN* v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_HEDGCORRCHANGE      := ROUND(BuyLot.T_HEDGCORR * v_LnkAmount / BuyLot.t_Amount,2);
            v_Link.T_AMORTHEDGCORRCHANGE := ROUND(BuyLot.T_AMORTHEDGCORR * v_LnkAmount / BuyLot.t_Amount,2);

            IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
               BEGIN
                  IF BuyLot.T_PARENT = 0 AND BuyLot.T_SOURCE = 0 THEN
                    --Если лот не является порожденным в ПРЕПО, то нужно делать вычисления исходя из начальных значений лота
                    SELECT ROUND(RSI_RSB_FIInstr.ConvSum(B.T_SUM, B.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, BuyLot.T_BEGDATE, 1),2), B.T_OUTLAY
                      INTO v_BegCostBuy, v_LotOutlay
                      FROM V_SCWRTHIST B
                     WHERE B.T_SUMID = BuyLot.T_SUMID
                       AND B.T_INSTANCE = 0;

                    IF v_LotOutlay > 0 THEN
                      SELECT t_BOfficeKind INTO v_BOfficeKind
                        FROM ddl_tick_dbt
                       WHERE t_DealID = BuyLot.T_DEALID;

                      v_BegCostBuy := v_BegCostBuy + GetComSumByDeal_Essential(v_BOfficeKind, BuyLot.T_DEALID, BuyLot.T_BEGDATE, RSI_RSB_FIInstr.NATCUR, BuyLot.T_PORTFOLIO, BuyLot.T_Contract, v_BegCostBuy);
                    END IF;

                  ELSE
                    --Если лот по 2ч ПРЕПО, то при передаче бумаг в ПРЕПО уже высчитывали рублевый эквивалент. Соответственно, можно взять его из той связи
                    SELECT NVL(SUM(LNK.T_COSTBUYNAT), 0)
                      INTO v_BegCostBuy
                      FROM DPMWRTLNK_DBT LNK
                     WHERE LNK.T_SALEID = BuyLot.T_PARENT
                       AND LNK.T_SOURCEBUYID = BuyLot.T_SOURCE;
                  END IF;
                  
               EXCEPTION
                  WHEN OTHERS THEN v_BegCostBuy := 0;
               END;

               BEGIN
                  SELECT NVL(SUM(L.T_COSTBUYNAT),0) INTO v_LastWrtCostBuyNat
                    FROM DPMWRTLNK_DBT L
                   WHERE L.T_BUYID = BuyLot.T_SUMID;
               EXCEPTION
                  WHEN OTHERS THEN v_LastWrtCostBuyNat := 0;
               END;

               v_LnkCostBuyNat := ROUND((v_BegCostBuy - v_LastWrtCostBuyNat) * v_Link.t_Amount/BuyLot.t_Amount, 2);
            END IF; 

            v_Link.T_COSTBUYNAT          := v_LnkCostBuyNat; 

            IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or p_CalcDefDiff = true) THEN
               WRTChangeIncomeOnSale(v_Link, BuyLot, p_CalcInterest, p_CalcDiscount, p_CalcBonus, p_CalcDefDiff, p_CalcCorrIntToEIR, false /*p_CalcReserve*/, p_CalcOver, p_Method, p_SaleLot.t_Date);
            END IF;

            RSI_InsDfltIntoWRTLNK(v_Link);
            INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

            p_SaleLot.t_Amount        := p_SaleLot.t_Amount - v_Link.t_Amount;
            p_SaleLot.t_Sum           := p_SaleLot.t_Sum - v_Link.t_SumSale;
            p_SaleLot.t_Cost          := p_SaleLot.t_Cost - v_Link.t_CostSale;
            p_SaleLot.t_NKDAmount     := p_SaleLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
            p_SaleLot.t_Outlay        := p_SaleLot.t_Outlay - v_Link.t_OutlaySale;
            p_SaleLot.t_BalanceCost   := p_SaleLot.t_BalanceCost - v_Link.t_BalanceCostSale;

            IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
               p_SaleLot.t_AmountBD      := p_SaleLot.t_AmountBD - v_Link.t_Amount;
               p_SaleLot.t_BalanceCostBD := p_SaleLot.t_BalanceCostBD - v_Link.t_BalanceCostBD;
               p_SaleLot.t_OverAmountBD  := p_SaleLot.t_OverAmountBD - v_Link.t_OverChangeBD;
            END IF;

         END LOOP;
       ELSE
         IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
           
           --Если лот не является порожденным в ПРЕПО, то нужно делать вычисления исходя из начальных значений лота
           SELECT NVL(SUM(RSI_RSB_FIInstr.ConvSum(B.T_SUM, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0), NVL(SUM(B.T_OUTLAY), 0)
             INTO v_BegCostBuy, v_LotOutlay
             FROM DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP, V_SCWRTHIST B
            WHERE TMP.T_SUMID = LOT.T_SUMID
              AND LOT.T_PARENT = 0
              AND LOT.T_SOURCE = 0
              AND B.T_SUMID = LOT.T_SUMID
              AND B.T_INSTANCE = 0;


           IF v_LotOutlay > 0 THEN
             FOR one_rec IN (SELECT LOT.T_PORTFOLIO, LOT.T_CONTRACT, LOT.T_BEGDATE, LOT.T_SUM, TK.T_DEALID, TK.T_BOFFICEKIND
                                FROM DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP, DDL_TICK_DBT TK
                               WHERE TMP.T_SUMID = LOT.T_SUMID
                                 AND LOT.T_PARENT = 0
                                 AND LOT.T_SOURCE = 0
                                 AND TK.T_DEALID = LOT.T_DEALID
                            )
             
             LOOP
               v_BegCostBuy := v_BegCostBuy + GetComSumByDeal_Essential(one_rec.t_BOfficeKind, one_rec.T_DEALID, one_rec.T_BEGDATE, RSI_RSB_FIInstr.NATCUR, one_rec.T_PORTFOLIO, one_rec.t_Contract, NVL(RSI_RSB_FIInstr.ConvSum(one_rec.T_SUM, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, one_rec.T_BEGDATE, 1),0));
             END LOOP;
           END IF;

           --Если лот по 2ч ПРЕПО, то при передаче бумаг в ПРЕПО уже высчитывали рублевый эквивалент. Соответственно, можно взять его из той связи
           SELECT NVL(SUM(LNK.T_COSTBUYNAT), 0)
             INTO v_BegCostBuyLnk
             FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP
            WHERE TMP.T_SUMID = LOT.T_SUMID
              AND LOT.T_PARENT > 0
              AND LOT.T_SOURCE > 0
              AND LNK.T_SALEID = LOT.T_PARENT
              AND LNK.T_SOURCEBUYID = LOT.T_SOURCE;

           v_BegCostBuy := v_BegCostBuy + v_BegCostBuyLnk;

           SELECT NVL(SUM(L.T_COSTBUYNAT),0) INTO v_LastWrtCostBuyNat
             FROM DPMWRTLNK_DBT L, DPMWRTSUM_TMP TMP
            WHERE L.T_BUYID = TMP.T_SUMID;

           v_AllCostBuyNat := v_BegCostBuy - v_LastWrtCostBuyNat;
         END IF;

         v_CurBuy.t_Amount           := p_SaleLot.t_Amount;
         v_CurBuy.t_Cost             := ROUND(v_All.t_Cost * v_CurBuy.t_Amount / (v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuyCostBuyNat          := ROUND(v_AllCostBuyNat * v_CurBuy.t_Amount / (v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_NKDAmount        := ROUND(v_All.t_NKDAmount * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         
         v_CurBuy.t_InterestIncome := ROUND(v_All.t_InterestIncome * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);

         IF (p_SaleLot.t_NKDAmount - v_CurBuy.t_NKDAmount) > 0 AND (p_SaleLot.t_NKDAmount - v_CurBuy.t_NKDAmount) < v_CurBuy.t_InterestIncome THEN
           --Это ситуация, когда продаются ранее купленные лоты
           --В продаже будет актуальный НКД, поэтому мы списать накопленного дохода можем не больше, чем разница между продажей и покупкой
           v_CurBuy.t_InterestIncome := p_SaleLot.t_NKDAmount-v_CurBuy.t_NKDAmount;
         END IF;

         v_CurBuy.t_NotCarryInterest := ROUND(v_All.t_NotCarryInterest * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_BegDiscount      := ROUND(v_All.t_BegDiscount * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_OldBegDiscount   := ROUND(v_All.t_OldBegDiscount * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_DISCOUNTCORR     := ROUND(v_ALL.T_DISCOUNTCORR* v_CurBuy.T_AMOUNT /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_OLDBEGBONUS      := ROUND(v_ALL.T_OLDBEGBONUS * v_CurBuy.T_AMOUNT /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_DiscountIncome   := ROUND(v_All.t_DiscountIncome * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_NotCarryDiscount := ROUND(v_All.t_NotCarryDiscount * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_BegBonus         := ROUND(v_All.t_BegBonus * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_Bonus            := ROUND(v_All.t_Bonus * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_OldBonus         := ROUND(v_All.t_OldBonus * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_ReservAmount     := ROUND(v_All.t_ReservAmount * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_IncomeReserv     := ROUND(v_All.t_IncomeReserv * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.t_Outlay           := ROUND(v_All.t_Outlay * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_NOTWRTBONUS      := ROUND(v_All.T_NOTWRTBONUS * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_COSTPFI          := ROUND(v_All.T_COSTPFI * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_ACCOUNTEDDEFDIFF := ROUND(v_All.T_ACCOUNTEDDEFDIFF * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_BEGDEFDIFF       := ROUND(v_All.T_BEGDEFDIFF * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_WRTOUTLAY        := ROUND(v_All.T_WRTOUTLAY * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_WRTVATOUTLAY     := ROUND(v_All.T_WRTVATOUTLAY * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_VATOUTLAY        := ROUND(v_All.T_VATOUTLAY * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_FAIRVALUE        := ROUND(v_All.T_FAIRVALUE * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_AMORTCOST        := ROUND(v_All.T_AMORTCOST * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_CORRVALUE        := ROUND(v_All.T_CORRVALUE * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_CORRINTTOEIR     := ROUND(v_All.T_CORRINTTOEIR * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_ESTRESERVE       := ROUND(v_All.T_ESTRESERVE * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_CORRESTRESERVE   := ROUND(v_All.T_CORRESTRESERVE * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_HEDGCORR         := ROUND(v_All.T_HEDGCORR * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_CurBuy.T_AMORTHEDGCORR    := ROUND(v_All.T_AMORTHEDGCORR * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);

         --Списываемое вложение (чистая стоимость без остатка премии)
         v_Invest     := ROUND((v_All.t_Cost + v_All.t_Bonus - v_All.t_BegBonus + v_All.t_CostPFI) * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         v_BonusRest  := ROUND((v_All.t_BegBonus - v_All.t_Bonus) * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
         
         IF v_All.T_COSTPFI <> 0 THEN
            v_CurBuy.T_COSTPFI := v_Invest - (v_CurBuy.t_Cost - v_BonusRest);
         END IF;
         
         v_CurBuy.t_Bonus := v_CurBuy.t_BegBonus - v_BonusRest;

         --Занесем во временную таблицу связей лоты, которые будут выбывать по количеству
         --Это нужно для того, чтобы по кризисным бумагам 
         --(по акциям и облигациям, купленным до даты окончания кризисной переоценки) 
         --списывать переоцеку по среднему 
         --с учетом переоцененых виртуально бумаг
         
         IF v_CrizOver = 1 THEN --Да

             --По кризисным бумага по среднему списываем только для лотов, купленных до даты окончания кризисной переоценки
             
             --Количество с датой приобретения меньше или равно дате окончания кризисной переоценки
             SELECT COUNT(1) INTO v_NeedAverOver
               FROM DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP
              WHERE LOT.T_FIID = p_SaleLot.t_FIID
                AND LOT.T_PARTY = -1
                AND LOT.T_CONTRACT = 0
                AND LOT.T_AMOUNT > 0
                AND LOT.T_BEGDATE <= g_EndCrizDate
                AND TMP.T_SUMID = LOT.T_SUMID
                AND ROWNUM = 1;

           IF v_NeedAverOver > 0 THEN --Есть лоты, выбывающие с переоценкой по среднему. Тогда нужно учесть переоценку при выбытии при расчете средней переоценки
             IF SortingLotsAmount() = SORTING_LOTS_AMOUNT_ASC THEN
               OPEN c_WRTSum2 FOR SELECT /*+ INDEX( LotBuy DPMWRTSUM_DBT_IDXA)*/ LotBuy.*
                                    FROM DPMWRTSUM_DBT LotBuy
                                   WHERE LotBuy.t_Department = p_SaleLot.t_Department AND
                                         LotBuy.t_FIID       = p_SaleLot.t_FIID AND
                                         LotBuy.t_Party      = p_SaleLot.t_Party AND
                                         LotBuy.t_Contract   = p_SaleLot.t_Contract AND
                                         (p_Group < 0 OR p_Group IS NULL OR LotBuy.t_GroupID = p_Group) AND
                                         ( (p_Portfolio <= 0) OR (p_Portfolio IS NULL) OR (p_Portfolio = LotBuy.t_Portfolio) ) AND
                                         LotBuy.t_IsFree     = CHR(88) AND
                                         LotBuy.t_Date      <= p_SaleLot.t_Date  AND
                                         (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_Date END) >= LotBuy.t_Date AND
                                         (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_StateDate END) >= LotBuy.t_StateDate AND
                                         ((LotBuy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((LotBuy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((LotBuy.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                                         LotBuy.t_SumID <> p_SaleLot.t_Parent AND
                                         ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (LotBuy.T_DATE = p_SaleLot.t_Date AND LotBuy.T_KIND = WRTSUM_KIND_B AND
                                                                                                 EXISTS(SELECT 1
                                                                                                          FROM dobjatcor_dbt AtCor
                                                                                                         WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                           AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                           AND AtCor.t_Object     = LPAD(LotBuy.t_DealID, 34, '0')
                                                                                                           AND AtCor.t_AttrID     = 1
                                                                                                       )
                                                                                                )
                                         )AND
                                          t_Amount - v_NeedLimitAmount * T_BLOCKAMOUNT > 0
                                   ORDER BY LotBuy.t_Date ASC, LotBuy.t_Time ASC, LotBuy.T_DealDate ASC, LotBuy.T_SortCode ASC, LotBuy.T_Amount ASC;
             ELSE
               OPEN c_WRTSum2 FOR SELECT /*+ INDEX( LotBuy DPMWRTSUM_DBT_IDXB)*/ LotBuy.*
                                    FROM DPMWRTSUM_DBT LotBuy
                                   WHERE LotBuy.t_Department = p_SaleLot.t_Department AND
                                         LotBuy.t_FIID       = p_SaleLot.t_FIID AND
                                         LotBuy.t_Party      = p_SaleLot.t_Party AND
                                         LotBuy.t_Contract   = p_SaleLot.t_Contract AND
                                         (p_Group < 0 OR p_Group IS NULL OR LotBuy.t_GroupID = p_Group) AND
                                         ( (p_Portfolio <= 0) OR (p_Portfolio IS NULL) OR (p_Portfolio = LotBuy.t_Portfolio) ) AND
                                         LotBuy.t_IsFree     = CHR(88) AND
                                         LotBuy.t_Date      <= p_SaleLot.t_Date  AND
                                         (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_Date END) >= LotBuy.t_Date AND
                                         (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_StateDate END) >= LotBuy.t_StateDate AND
                                         ((LotBuy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((LotBuy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((LotBuy.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                                         LotBuy.t_SumID <> p_SaleLot.t_Parent AND
                                         ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (LotBuy.T_DATE = p_SaleLot.t_Date AND LotBuy.T_KIND = WRTSUM_KIND_B AND
                                                                                                 EXISTS(SELECT 1
                                                                                                          FROM dobjatcor_dbt AtCor
                                                                                                         WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                           AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                           AND AtCor.t_Object     = LPAD(LotBuy.t_DealID, 34, '0')
                                                                                                           AND AtCor.t_AttrID     = 1
                                                                                                       )
                                                                                                )
                                         )AND
                                         t_Amount - v_NeedLimitAmount * T_BLOCKAMOUNT > 0
                                   ORDER BY LotBuy.t_Date ASC, LotBuy.t_Time ASC, LotBuy.T_DealDate ASC, LotBuy.T_SortCode ASC, LotBuy.T_Amount DESC;
             END IF;

             v_SaleAmount := p_SaleLot.t_Amount;
             v_TMPLNKID := 1;
             LOOP
               FETCH c_WRTSum2 INTO v_BuyLot;
               EXIT WHEN c_WRTSum2%notfound;
             
               v_WrtAmount := v_NeedLimitAmount * v_BuyLot.T_AMOUNT;
               IF v_WrtAmount > v_SaleAmount THEN
                 v_WrtAmount := v_SaleAmount;
               END IF;  

               IF v_WrtAmount > 0 THEN
                 INSERT INTO DPMWRTLNK_TMP
                            ( T_ID,
                              T_BUYID,
                              T_AMOUNT )
                     VALUES ( v_TMPLNKID,
                              v_BuyLot.T_SUMID,
                              v_WrtAmount
                              );

                 v_SaleAmount := v_SaleAmount - v_WrtAmount;
                 v_TMPLNKID   := v_TMPLNKID + 1;
               END IF;

               IF v_SaleAmount = 0 THEN 
                 EXIT;
               END IF;

             END LOOP;


             --Кол-во бумаг, которые будут выбывать сейчас по средней переоценке
             IF v_IsBond = TRUE THEN
               --Облигации по средней переоценке только те, которые куплены до даты окончания кризисной переоценки
               SELECT NVL(SUM(LTMP.T_AMOUNT), 0) INTO v_WrtAmountAverOver
                 FROM DPMWRTLNK_TMP LTMP, DPMWRTSUM_DBT LOT
                WHERE LOT.T_SUMID = LTMP.T_BUYID
                  AND LOT.T_BEGDATE <= g_EndCrizDate;

               IF v_WrtAmountAverOver > 0 THEN
                 --Сумма переоценки на выбываемые бумаги, которые были сейчас переоценены
                 SELECT NVL(SUM(ROUND(TMP.T_OVERAMOUNTADD/LOT.T_AMOUNT*LTMP.T_AMOUNT, 2)), 0) INTO v_AddOver
                   FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP LTMP
                  WHERE LOT.T_SUMID = TMP.T_SUMID
                    AND LOT.T_BEGDATE >= g_BegCrizDate
                    AND LTMP.T_BUYID = TMP.T_SUMID;

                 v_All.T_OVERAMOUNT := v_All.T_OVERAMOUNT + v_AddOver;
                 
                 v_CurBuy.T_OVERAMOUNT := ROUND(v_All.T_OVERAMOUNT * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
               END IF;
             ELSE
               --Акции по средней переоценке только те, которые куплены до даты окончания кризисной переоценки
               SELECT NVL(SUM(LTMP.T_AMOUNT), 0) INTO v_WrtAmountAverOver
                 FROM DPMWRTLNK_TMP LTMP, DPMWRTSUM_DBT LOT
                WHERE LOT.T_SUMID = LTMP.T_BUYID
                  AND LOT.T_BEGDATE < g_EndCrizDate;
             
               IF v_WrtAmountAverOver > 0 THEN

                 --Сумма переоценки на выбываемые бумаги, которые были сейчас переоценены
                 SELECT NVL(SUM(ROUND(TMP.T_OVERAMOUNTADD/LOT.T_AMOUNT*LTMP.T_AMOUNT, 2)), 0) INTO v_AddOver
                   FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP LTMP
                  WHERE LOT.T_SUMID = TMP.T_SUMID
                    AND LOT.T_BEGDATE >= g_BegCrizDate
                    AND LTMP.T_BUYID = TMP.T_SUMID;

                 v_All.T_OVERAMOUNT := v_All.T_OVERAMOUNT + v_AddOver;

                 v_CurBuy.T_OVERAMOUNT := ROUND(v_All.T_OVERAMOUNT * v_CurBuy.t_Amount /(v_All.t_Amount - v_NeedLimitAmount * v_All.T_BLOCKAMOUNT),2);
                 
               END IF;
             END IF;

           END IF;
         END IF;

         IF SortingLotsAmount() = SORTING_LOTS_AMOUNT_ASC THEN
           OPEN c_WRTSum2 FOR SELECT /*+ INDEX( LotBuy DPMWRTSUM_DBT_IDXA)*/ LotBuy.*
                                FROM DPMWRTSUM_DBT LotBuy
                               WHERE LotBuy.t_Department = p_SaleLot.t_Department AND
                                     LotBuy.t_FIID       = p_SaleLot.t_FIID AND
                                     LotBuy.t_Party      = p_SaleLot.t_Party AND
                                     LotBuy.t_Contract   = p_SaleLot.t_Contract AND
                                     (p_Group < 0 OR p_Group IS NULL OR LotBuy.t_GroupID = p_Group) AND
                                     ( (p_Portfolio <= 0) OR (p_Portfolio IS NULL) OR (p_Portfolio = LotBuy.t_Portfolio) ) AND
                                     LotBuy.t_IsFree     = CHR(88) AND
                                     LotBuy.t_Date      <= p_SaleLot.t_Date  AND
                                     (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_Date END) >= LotBuy.t_Date AND
                                     (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_StateDate END) >= LotBuy.t_StateDate AND
                                     ((LotBuy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((LotBuy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((LotBuy.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                                     LotBuy.t_SumID <> p_SaleLot.t_Parent AND
                                     ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (LotBuy.T_DATE = p_SaleLot.t_Date AND LotBuy.T_KIND = WRTSUM_KIND_B AND
                                                                                             EXISTS(SELECT 1
                                                                                                      FROM dobjatcor_dbt AtCor
                                                                                                     WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                       AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                       AND AtCor.t_Object     = LPAD(LotBuy.t_DealID, 34, '0')
                                                                                                       AND AtCor.t_AttrID     = 1
                                                                                                   )
                                                                                            )
                                     )AND
                                      t_Amount - v_NeedLimitAmount * T_BLOCKAMOUNT > 0
                               ORDER BY LotBuy.t_Date ASC, LotBuy.t_Time ASC, LotBuy.T_DealDate ASC, LotBuy.T_SortCode ASC, LotBuy.T_Amount ASC;
         ELSE
           OPEN c_WRTSum2 FOR SELECT /*+ INDEX( LotBuy DPMWRTSUM_DBT_IDXB)*/ LotBuy.*
                                FROM DPMWRTSUM_DBT LotBuy
                               WHERE LotBuy.t_Department = p_SaleLot.t_Department AND
                                     LotBuy.t_FIID       = p_SaleLot.t_FIID AND
                                     LotBuy.t_Party      = p_SaleLot.t_Party AND
                                     LotBuy.t_Contract   = p_SaleLot.t_Contract AND
                                     (p_Group < 0 OR p_Group IS NULL OR LotBuy.t_GroupID = p_Group) AND
                                     ( (p_Portfolio <= 0) OR (p_Portfolio IS NULL) OR (p_Portfolio = LotBuy.t_Portfolio) ) AND
                                     LotBuy.t_IsFree     = CHR(88) AND
                                     LotBuy.t_Date      <= p_SaleLot.t_Date  AND
                                     (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_Date END) >= LotBuy.t_Date AND
                                     (CASE WHEN p_StartDate IS NOT NULL THEN p_StartDate ELSE LotBuy.t_StateDate END) >= LotBuy.t_StateDate AND
                                     ((LotBuy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((LotBuy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and ((LotBuy.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR p_CheckTime = 0 OR p_SaleLot.T_KIND = WRTSUM_KIND_GS))) AND
                                     LotBuy.t_SumID <> p_SaleLot.t_Parent AND
                                     ((p_OnlyTodayBuys = 0) OR (p_OnlyTodayBuys IS NULL) OR (LotBuy.T_DATE = p_SaleLot.t_Date AND LotBuy.T_KIND = WRTSUM_KIND_B AND
                                                                                             EXISTS(SELECT 1
                                                                                                      FROM dobjatcor_dbt AtCor
                                                                                                     WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                                                                                                       AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                                                                                                       AND AtCor.t_Object     = LPAD(LotBuy.t_DealID, 34, '0')
                                                                                                       AND AtCor.t_AttrID     = 1
                                                                                                   )
                                                                                            )
                                     )AND
                                     t_Amount - v_NeedLimitAmount * T_BLOCKAMOUNT > 0
                               ORDER BY LotBuy.t_Date ASC, LotBuy.t_Time ASC, LotBuy.T_DealDate ASC, LotBuy.T_SortCode ASC, LotBuy.T_Amount DESC;
         END IF;

         LOOP
           FETCH c_WRTSum2 INTO v_BuyLot;
           EXIT WHEN c_WRTSum2%notfound;

           if( p_SaleLot.t_Amount > 0
               OR v_CURBUY.T_COST>0
               OR v_CurBuyCostBuyNat>0
               OR v_CURBUY.T_NKDAMOUNT>0
               OR v_CURBUY.T_INTERESTINCOME>0
               OR v_CURBUY.T_NOTCARRYINTEREST>0
               OR v_CURBUY.T_BEGDISCOUNT>0
               OR v_CURBUY.T_OLDBEGDISCOUNT>0
               OR v_CURBUY.T_DISCOUNTCORR>0
               OR v_CURBUY.T_DISCOUNTINCOME>0
               OR v_CURBUY.T_NOTCARRYDISCOUNT>0
               OR v_CURBUY.T_RESERVAMOUNT>0
               OR v_CURBUY.T_INCOMERESERV>0
               OR v_CURBUY.T_BEGBONUS>0
               OR v_CURBUY.T_OLDBEGBONUS>0
               OR v_CURBUY.T_BONUS>0
               OR v_CURBUY.T_OLDBONUS>0
               OR v_CURBUY.T_NOTWRTBONUS>0
               OR v_CURBUY.T_COSTPFI<>0
               OR v_CURBUY.T_BEGDEFDIFF<>0
               OR v_CURBUY.T_ACCOUNTEDDEFDIFF<>0
               OR v_CURBUY.T_CORRVALUE<>0
               OR v_CURBUY.T_CORRINTTOEIR<>0
               OR v_CURBUY.T_OVERAMOUNT<>0
               OR v_CURBUY.T_HEDGCORR<>0
               OR v_CURBUY.T_AMORTHEDGCORR<>0
             ) THEN

              v_ChangeCurBuyOver := 0;

              v_Link := NULL;
              v_Link.t_LnkID               := 0;
              v_Link.t_Amount              := 0;
              v_Link.t_SaleID              := p_SaleLot.t_SumID;
              v_Link.t_BuyID               := v_BuyLot.t_SumID;
              v_Link.t_Kind                := p_LinkKind;
              v_Link.t_Coupon              := p_SaleLot.t_Coupon;
              v_Link.t_Partly              := p_SaleLot.t_Partly;
              v_Link.t_ID_Operation        := p_ID_Operation;
              v_Link.t_ID_Step             := p_ID_Step;
              v_Link.t_Action              := p_Action;
              v_Link.t_CreateDate          := p_SaleLot.t_Date;
              v_Link.T_NOTWRTBONUSBUY      := 0;
              v_Link.T_COSTPFIBUY          := 0;
              v_Link.T_BLOCKAMOUNTBUY      := 0;
              v_Link.T_CORRESTRESERVCHANGE := 0;
              v_Link.T_ADDINCOMEOWNCHANGE  := 0;

              v_LnkAmount := v_BuyLot.t_Amount - v_NeedLimitAmount * v_BuyLot.T_BLOCKAMOUNT;
              if (v_LnkAmount <= p_SaleLot.t_Amount) then
                 v_Link.t_Amount              := v_LnkAmount;
                 v_Link.t_SumSale             := ROUND(p_SaleLot.t_Sum * v_LnkAmount / p_SaleLot.t_Amount,2);
                 v_Link.t_SumBuy              := v_BuyLot.t_Sum;
                 v_Link.t_CostSale            := ROUND(p_SaleLot.t_Cost * v_LnkAmount / p_SaleLot.t_Amount,2);
                 v_Link.t_BalanceCostSale     := ROUND(p_SaleLot.t_BalanceCost * v_LnkAmount / p_SaleLot.t_Amount,2);

                 IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
                    v_Link.t_BalanceCostBD    := ROUND(p_SaleLot.t_BalanceCostBD * v_LnkAmount / p_SaleLot.t_Amount,2);
                    v_Link.t_OverChangeBD     := ROUND(p_SaleLot.t_OverAmountBD * v_LnkAmount / p_SaleLot.t_Amount,2);
                 ELSE
                    v_Link.t_BalanceCostBD    := 0;
                    v_Link.t_OverChangeBD     := 0;
                 END IF;

                 v_Link.t_NKDSaleAmount       := ROUND(p_SaleLot.t_NKDAmount * v_LnkAmount / p_SaleLot.t_Amount,2);
                 v_Link.t_OutlaySale          := ROUND(p_SaleLot.t_Outlay * v_LnkAmount / p_SaleLot.t_Amount,2);
                 v_Link.T_BLOCKAMOUNTBUY      := v_LnkAmount - (v_BuyLot.t_Amount - v_BuyLot.T_BLOCKAMOUNT);

              elsif (p_SaleLot.t_Amount > 0) then

                 v_Link.t_Amount              := p_SaleLot.t_Amount;
                 v_Link.t_SumSale             := p_SaleLot.t_Sum;
                 v_Link.t_SumBuy              := ROUND(v_BuyLot.t_Sum * p_SaleLot.t_Amount / v_BuyLot.t_Amount,2);
                 v_Link.t_CostSale            := p_SaleLot.t_Cost;
                 v_Link.t_BalanceCostSale     := p_SaleLot.t_BalanceCost;

                 IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
                    v_Link.t_BalanceCostBD    := p_SaleLot.t_BalanceCostBD;
                    v_Link.t_OverChangeBD     := p_SaleLot.t_OverAmountBD;
                 ELSE
                    v_Link.t_BalanceCostBD    := 0;
                    v_Link.t_OverChangeBD     := 0;
                 END IF;

                 v_Link.t_NKDSaleAmount       := p_SaleLot.t_NKDAmount;
                 v_Link.t_OutlaySale          := p_SaleLot.t_Outlay;
                 v_Link.T_BLOCKAMOUNTBUY      := 0;
              end if;

              if (v_Count > 1) then

                 v_K := v_LnkAmount / v_BuyLot.t_Amount;

                 v_Link.t_CostBuy             := pMIN(ROUND(v_BuyLot.t_Cost * v_K, 2), v_CurBuy.t_Cost);
                 v_Link.t_NKDBuyAmount        := pMIN(ROUND(v_BuyLot.t_NKDAmount * v_K, 2), v_CurBuy.t_NKDAmount);
                 v_Link.t_InterestIncomeBuy   := pMIN(ROUND(v_BuyLot.t_InterestIncome * v_K, 2), v_CurBuy.t_InterestIncome);
                 v_Link.t_NotCarryInterestBuy := pMIN(ROUND(v_BuyLot.t_NotCarryInterest * v_K, 2), v_CurBuy.t_NotCarryInterest);
                 v_Link.t_BegDiscountChange   := pMIN(ROUND(v_BuyLot.t_BegDiscount * v_K, 2), v_CurBuy.t_BegDiscount );
                 v_Link.t_OldBegDiscountChange:= pMIN(ROUND(v_BuyLot.t_OldBegDiscount * v_K, 2), v_CurBuy.t_OldBegDiscount);
                 v_Link.T_DISCOUNTCORRCHANGE  := pMIN(ROUND(v_BuyLot.T_DISCOUNTCORR * v_K, 2), v_CurBuy.T_DISCOUNTCORR);
                 v_Link.t_BegBonusChange      := pMIN(ROUND(v_BuyLot.t_BegBonus * v_K, 2), v_CurBuy.t_BegBonus);
                 v_Link.T_OLDBEGBONUSCHANGE   := pMIN(ROUND(v_BuyLot.T_OLDBEGBONUS * v_K, 2), v_CurBuy.T_OLDBEGBONUS);
                 v_Link.t_DiscountIncomeBuy   := pMIN(ROUND(v_BuyLot.t_DiscountIncome * v_K, 2), v_CurBuy.t_DiscountIncome);
                 v_Link.t_NotCarryDiscountBuy := pMIN(ROUND(v_BuyLot.t_NotCarryDiscount * v_K, 2), v_CurBuy.t_NotCarryDiscount);
                 
                 v_Link.T_COSTPFIBUY          := 0;
                 IF v_CurBuy.T_COSTPFI <> 0 THEN
                   IF v_CurBuy.T_COSTPFI > 0 THEN
                      v_Link.T_COSTPFIBUY  := pMIN(ROUND(v_BuyLot.T_COSTPFI * v_K, 2), v_CurBuy.T_COSTPFI);
                   ELSE
                     v_Link.T_COSTPFIBUY  := pMAX(ROUND(v_BuyLot.T_COSTPFI * v_K, 2), v_CurBuy.T_COSTPFI);
                   END IF;   
                 END IF;
                   
                 v_Link.t_BonusBuy            := pMIN(ROUND(v_BuyLot.T_BONUS * v_K, 2), v_CurBuy.T_BONUS);
                  
                 v_Link.t_OldBonusBuy         := pMIN(ROUND(v_BuyLot.t_OldBonus * v_K, 2), v_CurBuy.t_OldBonus);
                 v_Link.t_ReservChange        := pMIN(ROUND(v_BuyLot.t_ReservAmount * v_K, 2), v_CurBuy.t_ReservAmount);
                 v_Link.t_IncomeReservChange  := pMIN(ROUND(v_BuyLot.t_IncomeReserv * v_K, 2), v_CurBuy.t_IncomeReserv);
                 v_Link.t_OutlayBuy           := pMIN(ROUND(v_BuyLot.t_Outlay * v_K, 2), v_CurBuy.t_Outlay);


                 IF v_CrizOver = 1 /*Да*/ AND v_BuyLot.t_BEGDATE <= g_EndCrizDate THEN
                    
                    v_AddOver := 0;
                    IF v_BuyLot.t_BegDate = p_SaleLot.t_Date THEN
                      --Если облигация куплена сегодня и сразу же продается (в т.ч. и частично), то на выбываемое кол-во могла доначислиться переоценка
                      --Т.к. с выбываемого лота переоценка списывается по среднему, то с этого лота списать мы можем больше или меньше, чем доначислили (до этого переоценка была нулевая, т.к. лот только что куплен)
                      --Соответственно после выбытия на лот нужно закинуть разницу между доначисленной переоценкой и той, которая должна быть списана с лота по среднему
                    
                      SELECT NVL(SUM(ROUND(t_OverAmountAdd * v_Link.t_Amount / v_BuyLot.t_Amount, 2)), 0) INTO v_AddOver
                        FROM DPMWRTSUM_TMP TMP
                       WHERE TMP.t_SumID = v_BuyLot.T_SumID;

                      IF ABS(v_CurBuy.T_OVERAMOUNT) < ABS(v_AddOver) THEN
                        --Если по среднему выбывает переоценки меньше, чем доначислили, то разницу занесем на лот
                        --На лот должно добавиться то, что превышает среднее значение в части доначисленной переоценки
                        v_Link.t_OverChange := v_CurBuy.T_OVERAMOUNT - v_AddOver;
                        v_ChangeCurBuyOver := v_CurBuy.T_OVERAMOUNT;
                      ELSE
                        --Иначе списать с лота больше, чем доначислили мы не можем. Соответственно в линке сумма списанной ранее начисленной переоценки будет 0
                        --Но приэтом вся доначисленная переоценка в этой операции будет считаться списанной автоматически
                        v_ChangeCurBuyOver := v_AddOver; 
                      END IF;
                    ELSE
                      IF v_CurBuy.T_OVERAMOUNT = 0 THEN
                        v_Link.t_OverChange := 0;
                      ELSE
                        if v_All.T_OVERAMOUNT >= 0 then
                          v_Link.t_OverChange := pMIN(ROUND((v_BuyLot.T_OVERAMOUNT) * v_K, 2), v_CurBuy.T_OVERAMOUNT);
                        else
                          v_Link.t_OverChange := pMAX(ROUND((v_BuyLot.T_OVERAMOUNT) * v_K, 2), v_CurBuy.T_OVERAMOUNT);
                        end if;
                      END IF;

                      v_ChangeCurBuyOver := v_Link.t_OverChange;
                    END IF;
                 ELSE
                    IF v_CrizOver = 1 /*Да*/ AND v_Link.t_Amount = 0 AND v_CurBuy.T_OVERAMOUNT <> 0 THEN
                      --Ситуация, когда в кризисной переоценки выбывало часть по среднему, но среднюю переоценку не удалось с них списать полностью
                      --Тогда досписываем её с оставшихся лотов
                      if v_All.T_OVERAMOUNT >= 0 then
                        v_Link.t_OverChange := pMIN(ROUND(v_BuyLot.T_OVERAMOUNT * v_K, 2), v_CurBuy.T_OVERAMOUNT);
                      else
                        v_Link.t_OverChange := pMAX(ROUND(v_BuyLot.T_OVERAMOUNT * v_K, 2), v_CurBuy.T_OVERAMOUNT);
                      end if;
                    ELSE
                      --Списываем переоценку с лота, приходящуюся на выбываемое кол-во
                      v_Link.t_OverChange := ROUND(v_BuyLot.t_OverAmount * v_Link.t_Amount / v_BuyLot.t_Amount, 2);
                    END IF;

                    v_ChangeCurBuyOver := v_Link.t_OverChange;
                 END IF;

                 v_Link.T_NOTWRTBONUSBUY      := pMIN(ROUND(v_BuyLot.T_NOTWRTBONUS * v_K, 2), v_CurBuy.T_NOTWRTBONUS);
                 v_Link.T_WRTOUTLAYBUY        := pMIN(ROUND(v_BuyLot.T_WRTOUTLAY * v_K, 2), v_CurBuy.T_WRTOUTLAY);
                 v_Link.T_WRTVATOUTLAYBUY     := pMIN(ROUND(v_BuyLot.T_WRTVATOUTLAY * v_K, 2), v_CurBuy.T_WRTVATOUTLAY);
                 v_Link.T_VATOUTLAYCHANGE     := pMIN(ROUND(v_BuyLot.T_VATOUTLAY * v_K, 2), v_CurBuy.T_VATOUTLAY);
                 v_Link.T_FAIRVALUECHANGE     := pMIN(ROUND(v_BuyLot.T_FAIRVALUE * v_K, 2), v_CurBuy.T_FAIRVALUE);
                 v_Link.T_AMORTCOSTCHANGE     := pMIN(ROUND(v_BuyLot.T_AMORTCOST * v_K, 2), v_CurBuy.T_AMORTCOST);

                 if v_All.T_ACCOUNTEDDEFDIFF >= 0 then
                   v_Link.T_ACCOUNTEDDEFDIFFBUY := pMIN(ROUND(v_BuyLot.T_ACCOUNTEDDEFDIFF * v_K, 2), v_CurBuy.T_ACCOUNTEDDEFDIFF);
                 else
                   v_Link.T_ACCOUNTEDDEFDIFFBUY := pMAX(ROUND(v_BuyLot.T_ACCOUNTEDDEFDIFF * v_K, 2), v_CurBuy.T_ACCOUNTEDDEFDIFF);
                 end if;

                 if v_All.T_BEGDEFDIFF >= 0 then
                   v_Link.T_BEGDEFDIFFCHANGE    := pMIN(ROUND(v_BuyLot.T_BEGDEFDIFF * v_K, 2), v_CurBuy.T_BEGDEFDIFF);
                 else
                   v_Link.T_BEGDEFDIFFCHANGE    := pMAX(ROUND(v_BuyLot.T_BEGDEFDIFF * v_K, 2), v_CurBuy.T_BEGDEFDIFF);
                 end if;

                 if v_All.T_CORRVALUE >= 0 then
                    v_Link.T_CORRVALUECHANGE  := pMIN(ROUND(v_BuyLot.T_CORRVALUE * v_K, 2), v_CurBuy.T_CORRVALUE);
                 else
                    v_Link.T_CORRVALUECHANGE  := pMAX(ROUND(v_BuyLot.T_CORRVALUE * v_K, 2), v_CurBuy.T_CORRVALUE);
                 end if;
                 
                 if v_All.T_CORRINTTOEIR >= 0 then
                   v_Link.T_CORRINTTOEIRCHANGE  := pMIN(ROUND(v_BuyLot.T_CORRINTTOEIR * v_K, 2), v_CurBuy.T_CORRINTTOEIR);
                 else
                   v_Link.T_CORRINTTOEIRCHANGE  := pMAX(ROUND(v_BuyLot.T_CORRINTTOEIR * v_K, 2), v_CurBuy.T_CORRINTTOEIR);
                 end if;

                 if v_All.T_ESTRESERVE >= 0 then
                   v_Link.T_ESTRESERVCHANGE     := pMIN(ROUND(v_BuyLot.T_ESTRESERVE * v_K, 2), v_CurBuy.T_ESTRESERVE);
                 else
                   v_Link.T_ESTRESERVCHANGE     := pMAX(ROUND(v_BuyLot.T_ESTRESERVE * v_K, 2), v_CurBuy.T_ESTRESERVE);
                 end if;

                 if v_All.T_CORRESTRESERVE >= 0 then
                   v_Link.T_CORRESTRESERVCHANGE := pMIN(ROUND(v_BuyLot.T_CORRESTRESERVE * v_K, 2), v_CurBuy.T_CORRESTRESERVE);
                 else
                   v_Link.T_CORRESTRESERVCHANGE := pMAX(ROUND(v_BuyLot.T_CORRESTRESERVE * v_K, 2), v_CurBuy.T_CORRESTRESERVE);
                 end if;

                 if v_All.T_HEDGCORR >= 0 then
                   v_Link.T_HEDGCORRCHANGE  := pMIN(ROUND(v_BuyLot.T_HEDGCORR * v_K, 2), v_CurBuy.T_HEDGCORR);
                 else
                   v_Link.T_HEDGCORRCHANGE  := pMAX(ROUND(v_BuyLot.T_HEDGCORR * v_K, 2), v_CurBuy.T_HEDGCORR);
                 end if;

                 if v_All.T_AMORTHEDGCORR >= 0 then
                   v_Link.T_AMORTHEDGCORRCHANGE  := pMIN(ROUND(v_BuyLot.T_AMORTHEDGCORR * v_K, 2), v_CurBuy.T_AMORTHEDGCORR);
                 else
                   v_Link.T_AMORTHEDGCORRCHANGE  := pMAX(ROUND(v_BuyLot.T_AMORTHEDGCORR * v_K, 2), v_CurBuy.T_AMORTHEDGCORR);
                 end if;

                 IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                   BEGIN
                      
                     IF v_BuyLot.T_PARENT = 0 AND v_BuyLot.T_SOURCE = 0 THEN
                       --Если лот не является порожденным в ПРЕПО, то нужно делать вычисления исходя из начальных значений лота
                       SELECT ROUND(RSI_RSB_FIInstr.ConvSum(B.T_SUM, B.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_BuyLot.T_BEGDATE, 1),2),
                              B.T_AMOUNT, B.T_OUTLAY
                         INTO v_BegCostBuy, v_BegAmount, v_LotOutlay
                         FROM V_SCWRTHIST B
                        WHERE B.T_SUMID = v_BuyLot.T_SUMID
                          AND B.T_INSTANCE = 0;

                       IF v_LotOutlay > 0 THEN
                         SELECT t_BOfficeKind INTO v_BOfficeKind
                           FROM ddl_tick_dbt
                          WHERE t_DealID = v_BuyLot.T_DEALID;

                         v_BegCostBuy := v_BegCostBuy + GetComSumByDeal_Essential(v_BOfficeKind, v_BuyLot.T_DEALID, v_BuyLot.T_BEGDATE, RSI_RSB_FIInstr.NATCUR, v_BuyLot.T_PORTFOLIO, v_BuyLot.T_Contract, v_BegCostBuy);
                       END IF;

                     ELSE
                       --Если лот по 2ч ПРЕПО, то при передаче бумаг в ПРЕПО уже высчитывали рублевый эквивалент. Соответственно, можно взять его из той связи
                       SELECT NVL(SUM(LNK.T_COSTBUYNAT), 0), NVL(SUM(LNK.T_AMOUNT),0)
                         INTO v_BegCostBuy, v_BegAmount
                         FROM DPMWRTLNK_DBT LNK
                        WHERE LNK.T_SALEID = v_BuyLot.T_PARENT
                          AND LNK.T_SOURCEBUYID = v_BuyLot.T_SOURCE;

                     END IF;
                      
                   EXCEPTION
                      WHEN OTHERS THEN v_BegCostBuy := 0; v_BegAmount := 0;
                   END;

                   BEGIN
                      SELECT NVL(SUM(L.T_COSTBUYNAT),0) INTO v_LastWrtCostBuyNat
                        FROM DPMWRTLNK_DBT L
                       WHERE L.T_BUYID = v_BuyLot.T_SUMID;
                   EXCEPTION
                      WHEN OTHERS THEN v_LastWrtCostBuyNat := 0;
                   END;

                   IF v_Link.t_Amount = v_BuyLot.t_Amount THEN
                     v_BuyLotCostBuyNat := ROUND((v_BegCostBuy - v_LastWrtCostBuyNat) * v_Link.t_Amount/v_BuyLot.t_Amount, 2);
                   ELSE
                     v_BuyLotCostBuyNat := ROUND(v_BegCostBuy * v_Link.t_Amount / v_BegAmount, 2);
                   END IF;

                   v_Link.t_CostBuyNat := pMIN(v_BuyLotCostBuyNat, v_CurBuyCostBuyNat);
                   
                 END IF;
              else

                 v_Link.t_CostBuy             := v_CurBuy.t_Cost;
                 v_Link.t_NKDBuyAmount        := v_CurBuy.t_NKDAmount;
                 v_Link.t_InterestIncomeBuy   := v_CurBuy.t_InterestIncome;
                 v_Link.t_NotCarryInterestBuy := v_CurBuy.t_NotCarryInterest;
                 v_Link.t_BegDiscountChange   := v_CurBuy.t_BegDiscount;
                 v_Link.t_OldBegDiscountChange:= v_CurBuy.t_OldBegDiscount;
                 v_Link.T_DISCOUNTCORRCHANGE  := v_CurBuy.T_DISCOUNTCORR;
                 v_Link.t_BegBonusChange      := v_CurBuy.t_BegBonus;
                 v_Link.T_OLDBEGBONUSCHANGE   := v_CurBuy.T_OLDBEGBONUS;
                 v_Link.t_DiscountIncomeBuy   := v_CurBuy.t_DiscountIncome;
                 v_Link.t_NotCarryDiscountBuy := v_CurBuy.t_NotCarryDiscount;
                 v_Link.T_COSTPFIBUY          := v_CurBuy.T_COSTPFI;
                 v_Link.t_BonusBuy            := v_CurBuy.t_Bonus;
                 v_Link.t_OldBonusBuy         := v_CurBuy.t_OldBonus;
                 v_Link.t_ReservChange        := v_CurBuy.t_ReservAmount;
                 v_Link.t_IncomeReservChange  := v_CurBuy.t_IncomeReserv;
                 v_Link.t_OutlayBuy           := v_CurBuy.t_Outlay;
                 v_Link.T_NOTWRTBONUSBUY      := v_CurBuy.T_NOTWRTBONUS;
                 v_Link.T_ACCOUNTEDDEFDIFFBUY := v_CurBuy.T_ACCOUNTEDDEFDIFF;
                 v_Link.T_BEGDEFDIFFCHANGE    := v_CurBuy.T_BEGDEFDIFF;
                 v_Link.T_WRTOUTLAYBUY        := v_CurBuy.T_WRTOUTLAY;
                 v_Link.T_WRTVATOUTLAYBUY     := v_CurBuy.T_WRTVATOUTLAY;
                 v_Link.T_VATOUTLAYCHANGE     := v_CurBuy.T_VATOUTLAY;
                 v_Link.T_FAIRVALUECHANGE     := v_CurBuy.T_FAIRVALUE;
                 v_Link.T_AMORTCOSTCHANGE     := v_CurBuy.T_AMORTCOST;
                 v_Link.T_CORRVALUECHANGE     := v_CurBuy.T_CORRVALUE;
                 v_Link.T_ESTRESERVCHANGE     := v_CurBuy.T_ESTRESERVE;
                 v_Link.T_CORRINTTOEIRCHANGE  := v_CurBuy.T_CORRINTTOEIR;
                 v_Link.T_CORRESTRESERVCHANGE := v_CurBuy.T_CORRESTRESERVE;
                 v_Link.T_ADDINCOMEOWNCHANGE  := v_CurBuy.T_ADDINCOMEOWN;
                 v_Link.T_HEDGCORRCHANGE      := v_CurBuy.T_HEDGCORR;
                 v_Link.T_AMORTHEDGCORRCHANGE := v_CurBuy.T_AMORTHEDGCORR;

                 IF v_CrizOver = 1 /*Да*/ AND v_BuyLot.t_BEGDATE <= g_EndCrizDate THEN
                    
                    v_AddOver := 0;
                    IF v_BuyLot.t_BegDate = p_SaleLot.t_Date THEN
                      --Если бумага куплена сегодня и сразу же продается (в т.ч. и частично), то на выбываемое кол-во могла доначислиться переоценка
                      --Т.к. с выбываемого лота переоценка списывается по среднему, то с этого лота списать мы можем больше или меньше, чем доначислили (до этого переоценка была нулевая, т.к. лот только что куплен)
                      --Соответственно после выбытия на лот нужно закинуть разницу между доначисленной переоценкой и той, которая должна быть списана с лота по среднему
                      
                      SELECT NVL(SUM(ROUND(t_OverAmountAdd * v_Link.t_Amount / v_BuyLot.t_Amount, 2)), 0) INTO v_AddOver
                        FROM DPMWRTSUM_TMP TMP
                       WHERE TMP.t_SumID = v_BuyLot.T_SumID;

                      IF ABS(v_CurBuy.T_OVERAMOUNT) < ABS(v_AddOver) THEN
                        --Если по среднему выбывает переоценки меньше, чем доначислили, то разницу занесем на лот
                        --На лот должно добавиться то, что превышает среднее значение в части доначисленной переоценки
                        v_Link.t_OverChange := v_CurBuy.T_OVERAMOUNT - v_AddOver;
                        v_ChangeCurBuyOver := v_CurBuy.T_OVERAMOUNT;

                      ELSE
                        --Иначе списать с лота больше, чем доначислили мы не можем. Соответственно в линке сумма списанной ранее начисленной переоценки будет 0
                        --Но приэтом вся доначисленная переоценка в этой операции будет считаться списанной автоматически
                        v_ChangeCurBuyOver := v_AddOver; 
                      END IF;
                    ELSE
                      if v_All.T_OVERAMOUNT >= 0 then
                        v_Link.t_OverChange := pMIN(ROUND((v_BuyLot.T_OVERAMOUNT) * v_Link.t_Amount / v_BuyLot.t_Amount, 2), v_CurBuy.T_OVERAMOUNT);
                      else
                        v_Link.t_OverChange := pMAX(ROUND((v_BuyLot.T_OVERAMOUNT) * v_Link.t_Amount / v_BuyLot.t_Amount, 2), v_CurBuy.T_OVERAMOUNT);
                      end if;

                      v_ChangeCurBuyOver := v_Link.t_OverChange;
                    END IF;
                 ELSE

                    IF v_CrizOver = 1 /*Да*/ AND v_Link.t_Amount = 0 AND v_CurBuy.T_OVERAMOUNT <> 0 THEN
                      --Ситуация, когда в кризисной переоценки выбывало часть по среднему, но среднюю переоценку не удалось с них списать полностью
                      --Тогда досписываем её с оставшихся лотов
                      if v_All.T_OVERAMOUNT >= 0 then
                        v_Link.t_OverChange := pMIN(ROUND(v_BuyLot.T_OVERAMOUNT * v_K, 2), v_CurBuy.T_OVERAMOUNT);
                      else
                        v_Link.t_OverChange := pMAX(ROUND(v_BuyLot.T_OVERAMOUNT * v_K, 2), v_CurBuy.T_OVERAMOUNT);
                      end if;
                    ELSE
                      --Списываем переоценку с лота, приходящуюся на выбываемое кол-во
                      v_Link.t_OverChange := ROUND(v_BuyLot.t_OverAmount * v_Link.t_Amount / v_BuyLot.t_Amount, 2);
                    END IF;

                    v_ChangeCurBuyOver := v_Link.t_OverChange;
                 END IF;

                 v_Link.t_CostBuyNat := v_CurBuyCostBuyNat;
              end if;

              v_Link.t_BalanceCostBuy := ROUND((  v_Link.t_CostBuy
                                                + v_Link.t_NKDBuyAmount
                                                + v_Link.t_InterestIncomeBuy
                                                + v_Link.t_DiscountIncomeBuy
                                                + v_Link.t_CostPFIBuy
                                                + (CASE WHEN v_Link.t_OverChange <> 0 AND v_BuyLot.T_OVERDATE > UnknownDate THEN RSI_RSB_FIInstr.ConvSum(v_Link.t_OverChange, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_BuyLot.T_OVERDATE, 1) ELSE 0 END)
                                                + (CASE WHEN v_Link.t_CORRVALUECHANGE <> 0 AND v_BuyLot.T_CORRDATE > UnknownDate THEN RSI_RSB_FIInstr.ConvSum(v_Link.t_CORRVALUECHANGE, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_BuyLot.T_CORRDATE, 1) ELSE 0 END)
                                                + (CASE WHEN v_Link.t_CORRINTTOEIRCHANGE <> 0 AND v_BuyLot.T_CORRINTTOEIRDATE > UnknownDate THEN RSI_RSB_FIInstr.ConvSum(v_Link.t_CORRINTTOEIRCHANGE, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_BuyLot.T_CORRINTTOEIRDATE, 1) ELSE 0 END)
                                               ), 2);


              IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or p_CalcDefDiff = true) THEN
                 WRTChangeIncomeOnSale (v_Link, v_BuyLot, p_CalcInterest, p_CalcDiscount, p_CalcBonus, p_CalcDefDiff, p_CalcCorrIntToEIR, false /*p_CalcReserve*/, p_CalcOver, p_Method, p_SaleLot.t_Date);
              END IF;

              BEGIN
                 RSI_InsDfltIntoWRTLNK(v_Link);

                 IF v_Link.T_AMOUNT               <> 0 OR               
                    v_Link.T_SUMSALE              <> 0 OR 
                    v_Link.T_SUMBUY               <> 0 OR 
                    v_Link.T_COSTSALE             <> 0 OR 
                    v_Link.T_COSTBUY              <> 0 OR 
                    v_Link.T_BALANCECOSTSALE      <> 0 OR 
                    v_Link.T_BALANCECOSTBUY       <> 0 OR 
                    v_Link.T_BALANCECOSTBD        <> 0 OR 
                    v_Link.T_INTERESTINCOMEBUY    <> 0 OR 
                    v_Link.T_INTERESTINCOMEADD    <> 0 OR 
                    v_Link.T_NKDSALEAMOUNT        <> 0 OR 
                    v_Link.T_NKDBUYAMOUNT         <> 0 OR 
                    v_Link.T_NOTCARRYINTERESTBUY  <> 0 OR 
                    v_Link.T_NOTCARRYINTERESTADD  <> 0 OR 
                    v_Link.T_BEGDISCOUNTCHANGE    <> 0 OR 
                    v_Link.T_OLDBEGDISCOUNTCHANGE <> 0 OR 
                    v_Link.T_BEGBONUSCHANGE       <> 0 OR 
                    v_Link.T_DISCOUNTINCOMEBUY    <> 0 OR 
                    v_Link.T_DISCOUNTINCOMEADD    <> 0 OR 
                    v_Link.T_NOTCARRYDISCOUNTBUY  <> 0 OR 
                    v_Link.T_NOTCARRYDISCOUNTADD  <> 0 OR 
                    v_Link.T_BONUSBUY             <> 0 OR 
                    v_Link.T_OLDBONUSBUY          <> 0 OR 
                    v_Link.T_BONUSADD             <> 0 OR 
                    v_Link.T_OUTLAYSALE           <> 0 OR 
                    v_Link.T_OUTLAYBUY            <> 0 OR 
                    v_Link.T_RESERVCHANGE         <> 0 OR 
                    v_Link.T_OVERCHANGE           <> 0 OR
                    v_Link.T_OVERCHANGEBD         <> 0 OR 
                    v_Link.T_INCOMERESERVCHANGE   <> 0 OR 
                    v_Link.T_DISCOUNTCORRCHANGE   <> 0 OR 
                    v_Link.T_OLDBEGBONUSCHANGE    <> 0 OR 
                    v_Link.T_NOTWRTBONUSBUY       <> 0 OR 
                    v_Link.T_COSTPFIBUY           <> 0 OR 
                    v_Link.T_BLOCKAMOUNTBUY       <> 0 OR 
                    v_Link.T_ACCOUNTEDDEFDIFFADD  <> 0 OR
                    v_Link.T_ACCOUNTEDDEFDIFFBUY  <> 0 OR 
                    v_Link.T_BEGDEFDIFFCHANGE     <> 0 OR 
                    v_Link.T_WRTOUTLAYADD         <> 0 OR 
                    v_Link.T_WRTOUTLAYBUY         <> 0 OR 
                    v_Link.T_WRTVATOUTLAYADD      <> 0 OR 
                    v_Link.T_WRTVATOUTLAYBUY      <> 0 OR 
                    v_Link.T_VATOUTLAYCHANGE      <> 0 OR 
                    v_Link.T_FAIRVALUECHANGE      <> 0 OR 
                    v_Link.T_AMORTCOSTCHANGE      <> 0 OR 
                    v_Link.T_CORRVALUECHANGE      <> 0 OR 
                    v_Link.T_ESTRESERVCHANGE      <> 0 OR 
                    v_Link.T_CORRINTTOEIRCHANGE   <> 0 OR 
                    v_Link.T_CORRESTRESERVCHANGE  <> 0 OR 
                    v_Link.T_CORRINTTOEIRADD      <> 0 OR 
                    v_Link.T_ESTRESERVEADD        <> 0 OR 
                    v_Link.T_CORRESTRESERVEADD    <> 0 OR 
                    v_Link.T_RESERVADD            <> 0 OR 
                    v_Link.T_INCOMERESERVADD      <> 0 OR 
                    v_Link.T_OVERAMOUNTADD        <> 0 OR 
                    v_Link.T_ADDINCOMEOWNCHANGE   <> 0 OR
                    v_Link.T_COSTBUYNAT           <> 0 THEN 

                   IF v_Link.t_Amount = 0 THEN
                     v_Link.t_SourceBuyID := v_SourceBuyID;
                   ELSE
                     v_SourceBuyID := v_BuyLot.t_SumID;
                   END IF;

                   INSERT INTO DPMWRTLNK_DBT VALUES v_Link;
                 END IF;

                 p_SaleLot.t_Amount        := p_SaleLot.t_Amount - v_Link.t_Amount;
                 p_SaleLot.t_Sum           := p_SaleLot.t_Sum - v_Link.t_SumSale;
                 p_SaleLot.t_Cost          := p_SaleLot.t_Cost - v_Link.t_CostSale;
                 p_SaleLot.t_BalanceCost   := p_SaleLot.t_BalanceCost - v_Link.t_BalanceCostSale;
                 p_SaleLot.t_NKDAmount     := p_SaleLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
                 p_SaleLot.t_Outlay        := p_SaleLot.t_Outlay - v_Link.t_OutlaySale;

                 IF( p_LinkKind = PMWRTLINK_KIND_DISCARDBD ) THEN
                    p_SaleLot.t_AmountBD      := p_SaleLot.t_AmountBD - v_Link.t_Amount;
                    p_SaleLot.t_BalanceCostBD := p_SaleLot.t_BalanceCostBD - v_Link.t_BalanceCostBD;
                    p_SaleLot.t_OverAmountBD  := p_SaleLot.t_OverAmountBD - v_Link.t_OverChangeBD;
                 END IF;

                 v_CurBuy.t_Amount           := v_CurBuy.t_Amount - v_Link.t_Amount;
                 v_CurBuy.t_Cost             := v_CurBuy.t_Cost - v_Link.t_CostBuy;
                 v_CurBuy.T_BALANCECOST      := v_CurBuy.T_BALANCECOST - v_Link.T_BALANCECOSTBUY;
                 v_CurBuy.t_NKDAmount        := v_CurBuy.t_NKDAmount - v_Link.t_NKDBuyAmount;
                 v_CurBuy.t_InterestIncome   := v_CurBuy.t_InterestIncome - v_Link.t_InterestIncomeBuy;
                 v_CurBuy.t_NotCarryInterest := v_CurBuy.t_NotCarryInterest - v_Link.t_NotCarryInterestBuy;
                 v_CurBuy.t_BegDiscount      := v_CurBuy.t_BegDiscount - v_Link.t_BegDiscountChange;
                 v_CurBuy.t_OldBegDiscount   := v_CurBuy.t_OldBegDiscount - v_Link.t_OldBegDiscountChange;
                 v_CurBuy.T_DISCOUNTCORR     := v_CurBuy.T_DISCOUNTCORR - v_Link.T_DISCOUNTCORRCHANGE;
                 v_CurBuy.t_DiscountIncome   := v_CurBuy.t_DiscountIncome - v_Link.t_DiscountIncomeBuy;
                 v_CurBuy.t_NotCarryDiscount := v_CurBuy.t_NotCarryDiscount - v_Link.t_NotCarryDiscountBuy;
                 v_CurBuy.t_ReservAmount     := v_CurBuy.t_ReservAmount - v_Link.t_ReservChange;
                 v_CurBuy.t_IncomeReserv     := v_CurBuy.t_IncomeReserv - v_Link.t_IncomeReservChange;
                 v_CurBuy.t_BegBonus         := v_CurBuy.t_BegBonus - v_Link.t_BegBonusChange;
                 v_CurBuy.T_OLDBEGBONUS      := v_CurBuy.T_OLDBEGBONUS  - v_Link.T_OLDBEGBONUSCHANGE;
                 v_CurBuy.t_Bonus            := v_CurBuy.t_Bonus - v_Link.t_BonusBuy;
                 IF v_CurBuy.t_Bonus < 0 THEN
                    v_CurBuy.t_Bonus := 0;
                 END IF;   
                 v_CurBuy.t_OldBonus         := v_CurBuy.t_OldBonus - v_Link.t_OldBonusBuy;
                 --v_CurBuy.t_OverAmount       := v_CurBuy.t_OverAmount - v_Link.t_OverChange;
                 v_CurBuy.t_Outlay           := v_CurBuy.t_Outlay - v_Link.t_OutlayBuy;
                 v_CurBuy.T_NOTWRTBONUS      := v_CurBuy.T_NOTWRTBONUS - v_Link.T_NOTWRTBONUSBUY;
                 v_CurBuy.T_COSTPFI          := v_CurBuy.T_COSTPFI - v_Link.T_COSTPFIBUY;
                 v_CurBuy.T_ACCOUNTEDDEFDIFF := v_CurBuy.T_ACCOUNTEDDEFDIFF - v_Link.T_ACCOUNTEDDEFDIFFBUY;
                 v_CurBuy.T_BEGDEFDIFF       := v_CurBuy.T_BEGDEFDIFF - v_Link.T_BEGDEFDIFFCHANGE;
                 v_CurBuy.T_WRTOUTLAY        := v_CurBuy.T_WRTOUTLAY - v_Link.T_WRTOUTLAYBUY;
                 v_CurBuy.T_WRTVATOUTLAY     := v_CurBuy.T_WRTVATOUTLAY - v_Link.T_WRTVATOUTLAYBUY;
                 v_CurBuy.T_VATOUTLAY        := v_CurBuy.T_VATOUTLAY - v_Link.T_VATOUTLAYCHANGE;
                 v_CurBuy.T_FAIRVALUE        := v_CurBuy.T_FAIRVALUE - v_Link.T_FAIRVALUECHANGE;
                 v_CurBuy.T_AMORTCOST        := v_CurBuy.T_AMORTCOST - v_Link.T_AMORTCOSTCHANGE;
                 v_CurBuy.T_CORRVALUE        := v_CurBuy.T_CORRVALUE - v_Link.T_CORRVALUECHANGE;
                 v_CurBuy.T_ESTRESERVE       := v_CurBuy.T_ESTRESERVE - v_Link.T_ESTRESERVCHANGE;
                 v_CurBuy.T_CORRESTRESERVE   := v_CurBuy.T_CORRESTRESERVE - v_Link.T_CORRESTRESERVCHANGE;
                 v_CurBuy.T_CORRINTTOEIR     := v_CurBuy.T_CORRINTTOEIR - v_Link.T_CORRINTTOEIRCHANGE;
                 v_CurBuy.T_ADDINCOMEOWN     := v_CurBuy.T_ADDINCOMEOWN - v_Link.T_ADDINCOMEOWNCHANGE;
                 v_CurBuy.T_HEDGCORR         := v_CurBuy.T_HEDGCORR - v_Link.T_HEDGCORRCHANGE;
                 v_CurBuy.T_AMORTHEDGCORR    := v_CurBuy.T_AMORTHEDGCORR - v_Link.T_AMORTHEDGCORRCHANGE;
                 v_CurVal                    := v_CurVal - v_Val;
                 v_Count                     := v_Count - 1;

                 IF v_CrizOver = 1 /*Да*/ AND v_CurBuy.t_OVERAMOUNT <> 0 THEN
                   if v_All.T_OVERAMOUNT >= 0 then
                     v_CurBuy.t_OVERAMOUNT := v_CurBuy.t_OVERAMOUNT - pMIN(v_ChangeCurBuyOver, v_CurBuy.T_OVERAMOUNT);
                   else
                     v_CurBuy.t_OVERAMOUNT := v_CurBuy.t_OVERAMOUNT - pMAX(v_ChangeCurBuyOver, v_CurBuy.T_OVERAMOUNT);
                   end if;
                 END IF;

                 v_CurBuyCostBuyNat := v_CurBuyCostBuyNat - v_Link.t_CostBuyNat;
              END;
           END IF;
         END LOOP;

         CLOSE c_WRTSum2;
       END IF;
    
       SELECT COUNT(1) INTO v_IsLnk
         FROM DPMWRTSUM_TMP TMP, DPMWRTLNK_DBT LNK
        WHERE TMP.T_OVERAMOUNTADD <> 0
          AND LNK.T_BUYID = TMP.T_SUMID
          AND LNK.T_SALEID = p_SaleLot.t_SumID
          AND LNK.T_ID_OPERATION = p_ID_Operation
          AND LNK.T_ID_STEP = p_ID_Step
          AND LNK.T_AMOUNT > 0
          AND ROWNUM = 1;

       --Добавить на связи добавленную переоценку, приходящуюся на выбываемые лоты (делаем после формирования связей, т.к. сразу её проблематично посчитать)
       IF p_CalcOver = true AND v_All.t_Amount > 0 AND v_IsLnk > 0 THEN
         
         IF v_CrizOver = 1 /*Да*/ AND p_SaleLot.t_Date <= g_EndCrizDate THEN
           --Для кризисных бумаг могла быть только переоценка купленных сегодня лотов и сразу же проданных
           --Поэтому в связи просто занесем то, что добавили по таким лотам

           FOR one_lot IN (SELECT TMP.T_SUMID, TMP.T_AMOUNT, TMP.T_OVERAMOUNTADD 
                             FROM DPMWRTSUM_TMP TMP
                            WHERE TMP.T_OVERAMOUNTADD <> 0
                              AND EXISTS(SELECT 1
                                           FROM DPMWRTLNK_DBT LNK
                                          WHERE LNK.T_BUYID = TMP.T_SUMID
                                            AND LNK.T_SALEID = p_SaleLot.t_SumID
                                            AND LNK.T_ID_OPERATION = p_ID_Operation
                                            AND LNK.T_ID_STEP = p_ID_Step
                                            AND LNK.T_AMOUNT > 0
                                        )
                          )
           LOOP

              v_RestAmount       := one_lot.t_Amount;
              v_RestOvervalueAdd := one_lot.t_OverAmountAdd;

              FOR one_lnk IN (SELECT LNK.T_LNKID, LNK.T_AMOUNT
                                FROM DPMWRTLNK_DBT LNK
                               WHERE LNK.T_BUYID = one_lot.T_SUMID
                                 AND LNK.T_SALEID = p_SaleLot.t_SumID
                                 AND LNK.T_ID_OPERATION = p_ID_Operation
                                 AND LNK.T_ID_STEP = p_ID_Step
                                 AND LNK.T_AMOUNT > 0     
                               ORDER BY LNK.T_AMOUNT ASC
                             )
              LOOP

                IF v_RestAmount = one_lnk.t_Amount THEN
                  v_OverAmount := v_RestOvervalueAdd;
                ELSE
                  v_OverAmount := ROUND(one_lot.t_OverAmountAdd/one_lot.t_Amount*one_lnk.t_Amount, 2);
                END IF;

                UPDATE DPMWRTLNK_DBT
                   SET T_OVERAMOUNTADD = v_OverAmount
                 WHERE T_LNKID = one_lnk.T_LNKID;

                v_RestAmount       := v_RestAmount - one_lnk.t_Amount;
                v_RestOvervalueAdd := v_RestOvervalueAdd - v_OverAmount;

              END LOOP;
           END LOOP;


         ELSE

           --Старая сумма переоценки, приходящаяся на выбываемые лоты
           SELECT NVL(SUM(ROUND(BC.T_OVERAMOUNT*LNK.T_AMOUNT/BC.T_AMOUNT,2)), 0) INTO v_OldSaleOvervalue
               FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_DBT BUY, DPMWRTBC_DBT BC, DPMWRTSUM_TMP TMP
            WHERE LNK.T_SALEID = p_SaleLot.t_SumID
              AND LNK.T_ID_OPERATION = p_ID_Operation
              AND LNK.T_ID_STEP = p_ID_Step
              AND BUY.T_SUMID = LNK.T_BUYID
              AND BUY.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
              AND BC.T_SUMID = BUY.T_SUMID
              AND BC.T_INSTANCE = LNK.T_BUYINSTANCE-1
              AND BC.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
              AND TMP.T_SUMID = BC.T_SUMID
              AND TMP.T_OVERAMOUNTADD <> 0;

           
           --Удалить всё лишнее из временных таблиц
           DELETE FROM DPMWRTSUM_TMP TMP
           WHERE NOT EXISTS(SELECT 1 FROM DPMWRTLNK_DBT LNK 
                            WHERE LNK.T_SALEID = p_SaleLot.t_SumID
                              AND LNK.T_ID_OPERATION = p_ID_Operation
                              AND LNK.T_ID_STEP = p_ID_Step
                              AND LNK.T_BUYID = TMP.T_SUMID);

           IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
              v_SBCOldNat  := v_AllCostRub + v_All.T_CORRINTTOEIR + v_All.T_CORRVALUE + v_All.T_HEDGCORR + v_All.T_AMORTHEDGCORR;
           ELSE
              v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_All.T_COST + v_All.T_NKDAMOUNT + v_All.T_INTERESTINCOME + v_All.T_DISCOUNTINCOME + v_All.T_COSTPFI), v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_SaleLot.t_Date, 1) 
                                     + v_All.T_CORRINTTOEIR + v_All.T_CORRVALUE + v_All.T_HEDGCORR + v_All.T_AMORTHEDGCORR), 2);
           END IF;

           --Старая БС к выбытию
           v_SBCOldNat := v_SBCOldNat * v_Amount / v_All.t_Amount;

           --Вычесть БС лотов, которые не переоценивались. В результате получим старую БС для переоценки
           SELECT NVL(SUM(BC.T_COST),0),
                  NVL(SUM(RSI_RSB_FIInstr.ConvSum(BC.T_COST, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, BC.T_BEGDATE, 1)),0),
                  NVL(SUM(BC.T_NKDAMOUNT),0) ,
                  NVL(SUM(BC.T_INTERESTINCOME),0) ,
                  NVL(SUM(BC.T_DISCOUNTINCOME),0) ,
                  NVL(SUM(BC.T_COSTPFI),0), 
                  NVL(SUM(BC.T_CORRVALUE),0),
                  NVL(SUM(BC.T_CORRINTTOEIR),0),
                  NVL(SUM(BC.T_HEDGCORR),0),
                  NVL(SUM(BC.T_AMORTHEDGCORR),0)
             INTO v_Cost,
                  v_CostRub,
                  v_NKDAmount,
                  v_InterestIncome,
                  v_DiscountIncome,
                  v_CostPFI,
                  v_CorrValue,
                  v_CorrIntToEIR,
                  v_HedgCorr,
                  v_AmortHedgCorr
             FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_DBT BUY, DPMWRTBC_DBT BC, DPMWRTSUM_TMP TMP
            WHERE LNK.T_SALEID = p_SaleLot.t_SumID
              AND LNK.T_ID_OPERATION = p_ID_Operation
              AND LNK.T_ID_STEP = p_ID_Step
              AND BUY.T_SUMID = LNK.T_BUYID
              AND BUY.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
              AND BC.T_SUMID = BUY.T_SUMID
              AND BC.T_INSTANCE = LNK.T_BUYINSTANCE-1
              AND BC.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
              AND TMP.T_SUMID = BC.T_SUMID
              AND TMP.T_OVERAMOUNTADD = 0;

           IF( v_IsBond = FALSE AND v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR ) THEN
              v_SBCOldNat  := v_SBCOldNat - (v_CostRub + v_CORRINTTOEIR + v_CORRVALUE);
           ELSE
              v_SBCOldNat  := v_SBCOldNat - (ROUND((RSI_RSB_FIInstr.ConvSum((v_COST + v_NKDAMOUNT + v_INTERESTINCOME + v_DISCOUNTINCOME + v_COSTPFI), v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_SaleLot.t_Date, 1) 
                                                    + v_CORRINTTOEIR + v_CORRVALUE), 2));
           END IF;

           -- Во временной таблице в T_BALANCECOST уже новая БС, равная ТСС (или другому курсу)
           SELECT NVL(SUM(ROUND(TMP.T_BALANCECOST*LNK.T_AMOUNT/TMP.T_AMOUNT,2)), 0) INTO v_SBCNew
             FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_TMP TMP
            WHERE LNK.T_SALEID = p_SaleLot.t_SumID
              AND LNK.T_ID_OPERATION = p_ID_Operation
              AND LNK.T_ID_STEP = p_ID_Step
              AND TMP.T_SUMID = LNK.T_BUYID
              AND TMP.T_OVERAMOUNTADD <> 0;

           v_SBCNewNat        := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_SaleLot.t_Date, 1);

           --Новая сумма переоценки, приходящаяся на выбываемые лоты
           v_NewSaleOvervalue := v_SBCNewNat - v_SBCOldNat;

           --Добавленная переоценка
           v_OvervalueAdd     := ROUND(v_NewSaleOvervalue - v_OldSaleOvervalue, 2);
           
           v_RestOvervalueAdd := v_OvervalueAdd;
           v_RestAmount       := v_Amount;

           IF v_OvervalueAdd <> 0 THEN
             FOR one_lnk IN (SELECT LNK.T_LNKID, LNK.T_AMOUNT
                               FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_DBT LOT
                              WHERE LNK.T_SALEID = p_SaleLot.t_SumID
                                AND LNK.T_ID_OPERATION = p_ID_Operation
                                AND LNK.T_ID_STEP = p_ID_Step
                                AND LOT.T_SUMID = LNK.T_BUYID
                                AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
                                AND LOT.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
                              ORDER BY LNK.T_LNKID ASC
                            )
             LOOP

                IF one_lnk.T_AMOUNT = v_RestAmount THEN
                  v_OverAmount := v_RestOvervalueAdd;
                ELSE
                  v_OverAmount := ROUND(v_OvervalueAdd*one_lnk.T_AMOUNT/v_Amount, 2);
                END IF;

                UPDATE DPMWRTLNK_DBT
                   SET T_OVERAMOUNTADD = v_OverAmount
                 WHERE T_LNKID = one_lnk.T_LNKID;

                v_RestOvervalueAdd := v_RestOvervalueAdd - v_OverAmount;    
                v_RestAmount       := v_RestAmount - one_lnk.T_AMOUNT;

             END LOOP;
           END IF;
         END IF;
       END IF; 

       IF(p_SaleLot.t_Kind <> RSB_PMWRTOFF.WRTSUM_KIND_FS_TRUSTREQ) THEN
          RSI_WRTAverageRedistrSum( p_ID_Operation, p_ID_Step, p_SaleLot, p_Portfolio, p_Group, p_CalcOver );
       END IF;

     END IF;


     --Для всех лотов по данной бумаге, где есть начисленная корректировка хеджирования, перенсем её в корректировку к амортизации
     IF p_SaleLot.t_Party = UnknownParty THEN
       UPDATE DPMWRTSUM_DBT
          SET T_AMORTHEDGCORR = T_AMORTHEDGCORR + T_HEDGCORR,
              T_AMORTHEDGCORRDATE = GREATEST(T_HEDGCORRDATE, T_AMORTHEDGCORRDATE),
              T_HEDGCORR = 0
        WHERE T_FIID = p_SaleLot.t_FIID
          AND T_DEPARTMENT = p_SaleLot.t_Department
          AND T_PARTY = p_SaleLot.t_Party
          AND T_HEDGCORR <> 0;
     END IF;
   END;--RSI_WRTLinkSaleToBuy

   ----- Выполняет списание по лоту продажи выкупленных лотов.
   PROCEDURE RSI_WRTLinkSaleToBuyOwn( p_SaleLot          IN OUT DPMWRTSUM_DBT%ROWTYPE,
                                      p_ID_Operation     IN     NUMBER, -- Операция и шаг, на которых выполняется списание
                                      p_ID_Step          IN     NUMBER
                                    )
   IS
     v_BuyLot          DPMWRTSUM_DBT%ROWTYPE;
     v_Link            DPMWRTLNK_DBT%ROWTYPE;
     v_AmountRate      NUMBER;
     v_Amount          NUMBER;
     v_LnkAmount       NUMBER;
     v_Break           BOOLEAN;

     c_WRTSum sys_refcursor;

   BEGIN
     InitError();

     IF( p_SaleLot.t_Date < RsbSessionData.curdate ) THEN

        if( WRTAreChangesAfterDateOwn( p_SALELOT.t_Department,
                                       p_SALELOT.T_FIID,
                                       p_SALELOT.T_DATE,
                                       p_SALELOT.T_TIME,
                                       p_SALELOT.T_DATE
                                     ) = True ) then
           SetError( WRTOFF_ERROR_20201, to_char(p_SALELOT.t_SUMID) );
        end if;
     END IF;

     v_Break := false;
     v_Amount := p_SaleLot.T_AMOUNT;

     IF SortingLotsAmount() = SORTING_LOTS_AMOUNT_ASC THEN
        OPEN c_WRTSum FOR SELECT /*+ INDEX( LotBuy DPMWRTSUM_DBT_IDXA)*/ LotBuy.*
                            FROM DPMWRTSUM_DBT LotBuy
                           WHERE LotBuy.t_Department = p_SaleLot.t_Department AND
                                 LotBuy.t_FIID       = p_SaleLot.t_FIID AND
                                 LotBuy.t_Party      = p_SaleLot.t_Party AND
                                 LotBuy.t_State      = PM_WRTSUM_BUYOUT_OWN AND
                                 (LotBuy.t_Date < p_SaleLot.t_Date OR (LotBuy.t_Date = p_SaleLot.t_Date AND LotBuy.t_Time <= p_SaleLot.t_Time)) AND
                                 ((LotBuy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((LotBuy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and (LotBuy.T_ACTIVATETIME <= p_SaleLot.T_TIME)))
                           ORDER BY LotBuy.t_Date ASC, LotBuy.t_Time ASC, LotBuy.T_DealDate ASC, LotBuy.T_SortCode ASC, LotBuy.T_Amount ASC;
     ELSE
        OPEN c_WRTSum FOR SELECT /*+ INDEX( LotBuy DPMWRTSUM_DBT_IDXB)*/ LotBuy.*
                            FROM DPMWRTSUM_DBT LotBuy
                           WHERE LotBuy.t_Department = p_SaleLot.t_Department AND
                                 LotBuy.t_FIID       = p_SaleLot.t_FIID AND
                                 LotBuy.t_Party      = p_SaleLot.t_Party AND
                                 LotBuy.t_State      = PM_WRTSUM_BUYOUT_OWN AND
                                 (LotBuy.t_Date < p_SaleLot.t_Date OR (LotBuy.t_Date = p_SaleLot.t_Date AND LotBuy.t_Time <= p_SaleLot.t_Time)) AND
                                 ((LotBuy.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((LotBuy.T_ACTIVATEDATE = p_SaleLot.T_DATE) and (LotBuy.T_ACTIVATETIME <= p_SaleLot.T_TIME)))
                           ORDER BY LotBuy.t_Date ASC, LotBuy.t_Time ASC, LotBuy.T_DealDate ASC, LotBuy.T_SortCode ASC, LotBuy.T_Amount DESC;
     END IF;

     WHILE( v_Amount > 0 and v_Break = false ) LOOP
        BEGIN
           FETCH c_WRTSum INTO v_BuyLot;
           EXIT WHEN c_WRTSum%notfound OR
                   c_WRTSum IS NULL;

           if (v_BuyLot.T_AMOUNT <= v_Amount ) then
              v_AmountRate := 1;
              v_LnkAmount  := v_BuyLot.t_Amount;
           else
              v_AmountRate := v_Amount / v_BuyLot.t_Amount;
              v_LnkAmount  := v_Amount;
           end if;

           v_Link := NUll;

           v_Link.t_LnkID               := 0;
           v_Link.t_SaleID              := p_SaleLot.t_SumID;
           v_Link.t_BuyID               := v_BuyLot.t_SumID;
           v_Link.t_Kind                := PMWRTLINK_KIND_SALE_BUYOUT;
           v_Link.t_Amount              := v_LnkAmount;
           v_Link.t_SumSale             := 0;
           v_Link.t_SumBuy              := ROUND(v_BuyLot.t_Sum * v_AmountRate,2);
           v_Link.t_CostSale            := 0;
           v_Link.t_CostBuy             := ROUND(v_BuyLot.t_Cost * v_AmountRate,2);
           v_Link.t_BalanceCostSale     := 0;
           v_Link.t_BalanceCostBD       := 0;
           v_Link.t_NKDSaleAmount       := 0;
           v_Link.t_NKDBuyAmount        := ROUND(v_BuyLot.t_NKDAmount * v_AmountRate,2);
           v_Link.t_InterestIncomeBuy   := 0;
           v_Link.t_InterestIncomeAdd   := 0;
           v_Link.t_NotCarryInterestBuy := 0;
           v_Link.T_NOTCARRYINTERESTADD := 0;
           v_Link.t_BegDiscountChange   := 0;
           v_Link.t_OldBegDiscountChange:= 0;
           v_Link.T_DISCOUNTCORRCHANGE  := 0;
           v_Link.t_BegBonusChange      := 0;
           v_Link.T_OLDBEGBONUSCHANGE   := 0;
           v_Link.t_DiscountIncomeBuy   := 0;
           v_Link.t_DiscountIncomeAdd   := 0;
           v_Link.t_NotCarryDiscountBuy := 0;
           v_Link.T_NOTCARRYDISCOUNTADD := 0;
           v_Link.t_BalanceCostBuy      := 0;
           v_Link.t_BonusBuy            := 0;
           v_Link.t_OldBonusBuy         := 0;
           v_Link.t_BonusAdd            := 0;
           v_Link.t_OutlaySale          := 0;
           v_Link.t_OutlayBuy           := 0;
           v_Link.t_ReservChange        := 0;
           v_Link.t_IncomeReservChange  := 0;
           v_Link.t_OverChange          := 0;
           v_Link.t_OverChangeBD        := 0;
           v_Link.t_ID_Operation        := p_ID_Operation;
           v_Link.t_ID_Step             := p_ID_Step;
           v_Link.t_Action              := PM_WRT_UPDTMODE_SALE_BUYOUT;
           v_Link.t_CreateDate          := p_SaleLot.t_Date;
           v_Link.T_NOTWRTBONUSBUY      := 0;
           v_Link.T_COSTPFIBUY          := 0;
           v_Link.t_BlockAmountBuy      := 0;
           v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
           v_Link.T_ACCOUNTEDDEFDIFFBUY := 0;
           v_Link.T_BEGDEFDIFFCHANGE    := 0;
           v_Link.T_WRTOUTLAYADD        := 0;
           v_Link.T_WRTOUTLAYBUY        := 0;
           v_Link.T_WRTVATOUTLAYADD     := 0;
           v_Link.T_WRTVATOUTLAYBUY     := 0;
           v_Link.T_VATOUTLAYCHANGE     := 0;
           v_Link.T_FAIRVALUECHANGE     := 0;
           v_Link.T_AMORTCOSTCHANGE     := 0;
           v_Link.T_CORRVALUECHANGE     := 0;
           v_Link.T_ESTRESERVCHANGE     := 0;
           v_Link.T_CORRINTTOEIRCHANGE  := 0;
           v_Link.T_CORRESTRESERVCHANGE := 0;
           v_Link.T_ADDINCOMEOWNCHANGE  := 0;

           RSI_InsDfltIntoWRTLNK(v_Link);
           INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

           v_Amount   := v_Amount - v_Link.T_AMOUNT;
        EXCEPTION
           WHEN OTHERS THEN
              v_Break := TRUE;
        END;
     END LOOP;

     CLOSE c_WRTSum;

     IF v_Amount > 0 THEN
       IF( p_SaleLot.T_DealCode != ' ' ) THEN
           SetError( WRTOFF_ERROR_20208, to_char(p_SaleLot.T_DealCode) );
       ELSE
           SetError( WRTOFF_ERROR_20208, ' ');
       END IF;
     END IF;

   END;--RSI_WRTLinkSaleToBuyOwn

   ----- Выполняет списание лота погашения выпуска по размещенным и выкупленным лотам.
   PROCEDURE RSI_WRTLinkRetireLotOwn( p_RetLot           IN OUT DPMWRTSUM_DBT%ROWTYPE, -- Буфер лота погашения
                                      p_StartDate        IN     DATE,   -- Дата отбора лотов размещения. Если не задана  - игнорируется.
                                      p_ID_Operation     IN     NUMBER, -- Операция и шаг, на которых выполняется списание
                                      p_ID_Step          IN     NUMBER,
                                      p_LinkKind         IN     NUMBER, -- Вид создаваемой связи
                                      p_Action           IN     NUMBER, -- Вид изменения на лоте
                                      p_CalcInterest     IN     BOOLEAN, -- Расчитывать процентный доход
                                      p_CalcDiscount     IN     BOOLEAN, -- Расчитывать дисконтный доход
                                      p_CalcBonus        IN     BOOLEAN, -- Начислять премию
                                      p_CalcDefDiff      IN     BOOLEAN, -- Начислять отложенную разницу
                                      p_CalcOutlay       IN     BOOLEAN  -- Начислять существенные затраты
                                    )
   IS
     v_TargetLot       DPMWRTSUM_DBT%ROWTYPE;
     v_Link            DPMWRTLNK_DBT%ROWTYPE;
     v_WrtSumTmp       DPMWRTSUM_TMP%ROWTYPE;
     v_AmountRate      NUMBER;
     v_OverAmount      NUMBER;
     v_Amount          NUMBER;
     v_TMPLNKID        NUMBER;
     v_CalcDate        DATE;
     v_DRAWINGDATE     DATE;
     v_LnkAmount       NUMBER;
     v_Termless        CHAR;

     TYPE LotsCurTyp IS REF CURSOR;
     Lots LotsCurTyp;

   BEGIN
     InitError();

     IF( p_RetLot.t_Date < RsbSessionData.curdate ) THEN

        if( WRTAreChangesAfterDateOwn( p_RetLot.t_Department,
                                       p_RetLot.T_FIID,
                                       p_RetLot.T_DATE,
                                       p_RetLot.T_TIME,
                                       p_StartDate
                                     ) = True ) then
           SetError( WRTOFF_ERROR_20201, to_char(p_RetLot.t_SUMID) );
        end if;
     END IF;

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     v_Amount := p_RetLot.T_AMOUNT;
     v_TMPLNKID := 1;

     WHILE( v_Amount > 0 ) LOOP
        BEGIN
          IF SortingLotsAmount() = SORTING_LOTS_AMOUNT_ASC THEN

            SELECT * INTO v_TargetLot
              FROM (SELECT /*+ INDEX( Lot DPMWRTSUM_DBT_IDXA)*/ Lot.*
                      FROM DPMWRTSUM_DBT Lot
                     WHERE Lot.t_Department = p_RetLot.t_Department AND
                           Lot.t_FIID       = p_RetLot.t_FIID AND
                           Lot.t_Party      = p_RetLot.t_Party AND
                           Lot.t_State      IN (PM_WRTSUM_PLACE_OWN, PM_WRTSUM_BUYOUT_OWN) AND
                           (Lot.T_AMOUNT - (select NVL(SUM(TMP.T_AMOUNT),0)
                                              from DPMWRTLNK_TMP TMP
                                             where TMP.T_BUYID = Lot.T_SUMID)) > 0 AND
                           (Lot.t_Date < p_RetLot.t_Date OR (Lot.t_Date = p_RetLot.t_Date AND Lot.t_Time <= p_RetLot.t_Time)) AND
                           (CASE WHEN p_StartDate IS NOT NULL AND p_StartDate != UnknownDate THEN p_StartDate ELSE Lot.t_Date END) >= Lot.t_Date AND
                           (CASE WHEN p_StartDate IS NOT NULL AND p_StartDate != UnknownDate THEN p_StartDate ELSE Lot.t_StateDate END) >= Lot.t_StateDate AND
                           ((Lot.T_ACTIVATEDATE < p_RetLot.T_DATE) OR ((Lot.T_ACTIVATEDATE = p_RetLot.T_DATE) and (Lot.T_ACTIVATETIME <= p_RetLot.T_TIME)))
                     ORDER BY Lot.t_Date ASC, Lot.t_Time ASC, Lot.T_DealDate ASC, Lot.T_SortCode ASC, Lot.T_Amount ASC)

             WHERE ROWNUM = 1;

           ELSE

             SELECT * INTO v_TargetLot
              FROM (SELECT /*+ INDEX( Lot DPMWRTSUM_DBT_IDXB)*/ Lot.*
                      FROM DPMWRTSUM_DBT Lot
                     WHERE Lot.t_Department = p_RetLot.t_Department AND
                           Lot.t_FIID       = p_RetLot.t_FIID AND
                           Lot.t_Party      = p_RetLot.t_Party AND
                           Lot.t_State      IN (PM_WRTSUM_PLACE_OWN, PM_WRTSUM_BUYOUT_OWN) AND
                           (Lot.T_AMOUNT - (select NVL(SUM(TMP.T_AMOUNT),0)
                                              from DPMWRTLNK_TMP TMP
                                             where TMP.T_BUYID = Lot.T_SUMID)) > 0 AND
                           (Lot.t_Date < p_RetLot.t_Date OR (Lot.t_Date = p_RetLot.t_Date AND Lot.t_Time <= p_RetLot.t_Time)) AND
                           (CASE WHEN p_StartDate IS NOT NULL AND p_StartDate != UnknownDate THEN p_StartDate ELSE Lot.t_Date END) >= Lot.t_Date AND
                           (CASE WHEN p_StartDate IS NOT NULL AND p_StartDate != UnknownDate THEN p_StartDate ELSE Lot.t_StateDate END) >= Lot.t_StateDate AND
                           ((Lot.T_ACTIVATEDATE < p_RetLot.T_DATE) OR ((Lot.T_ACTIVATEDATE = p_RetLot.T_DATE) and (Lot.T_ACTIVATETIME <= p_RetLot.T_TIME)))
                     ORDER BY Lot.t_Date ASC, Lot.t_Time ASC, Lot.T_DealDate ASC, Lot.T_SortCode ASC, Lot.T_Amount DESC)

             WHERE ROWNUM = 1;
           END IF;
        EXCEPTION
           WHEN NO_DATA_FOUND THEN EXIT;--выходим именно из цикла, а не из процедуры (это важно - дальше нас ждет начисление ПДД и линковка)
           WHEN OTHERS THEN RETURN;
        END;

        INSERT INTO DPMWRTLNK_TMP
                   ( T_ID,
                     T_BUYID,
                     T_AMOUNT )
            VALUES ( v_TMPLNKID,
                     v_TargetLot.T_SUMID,
                     v_TargetLot.T_AMOUNT
                     );

        v_Amount   := v_Amount - v_TargetLot.T_AMOUNT;
        v_TMPLNKID := v_TMPLNKID + 1;
     END LOOP;

     IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or p_CalcDefDiff = true or p_CalcOutlay = true) THEN

        IF( p_LinkKind = PMWRTLINK_KIND_RETISSUE ) THEN
           select t_Termless into v_TERMLESS from davoiriss_dbt where t_FIID = p_RetLot.T_FIID;
           v_CalcDate:= RSI_RSB_FIInstr.FI_GetNominalDrawingDate(p_RetLot.T_FIID, v_TERMLESS);
        ELSE
           v_CalcDate := p_RetLot.T_DATE;
        END IF;
        --Выполнить начисление во временную таблицу
        --Фактически - начисление по всем группам лотов из DPMWRTLNK_TMP, а не по всем лотам размещения, как при начислении ПДД
        RSI_WRTChargeExpToOwnLotsTMP (true, p_RetLot.T_DATE, v_CalcDate, p_RetLot.T_FIID, p_RetLot.T_Department,
                                      p_CalcInterest,
                                      p_CalcDiscount,
                                      p_CalcBonus,
                                      p_CalcDefDiff,
                                      p_CalcOutlay,
                                      false,
                                      p_LinkKind,
                                      p_RetLot.T_COUPON,
                                      false);

     END IF;

     OPEN Lots FOR SELECT L.* INTO v_TargetLot
                     FROM DPMWRTSUM_DBT L, DPMWRTLNK_TMP TMP
                    WHERE L.T_SUMID = TMP.T_BUYID
                   ORDER BY T_ID ASC;
     LOOP

           FETCH Lots INTO v_TargetLot;
           EXIT WHEN Lots%NOTFOUND OR
                     Lots%NOTFOUND IS NULL;

        -- теперь будем списывать
        v_Link.t_LnkID               := 0;
        v_Link.t_SaleID              := p_RetLot.t_SumID;
        v_Link.t_BuyID               := v_TargetLot.t_SumID;
        v_Link.t_Kind                := p_LinkKind;
        v_Link.t_DiscountIncomeAdd   := 0;
        v_Link.t_InterestIncomeAdd   := 0;
        v_Link.t_BonusAdd            := 0;
        v_Link.t_Coupon              := p_RetLot.t_Coupon;
        v_Link.t_ID_Operation        := p_ID_Operation;
        v_Link.t_ID_Step             := p_ID_Step;
        v_Link.t_Action              := p_Action;
        v_Link.t_CreateDate          := p_RetLot.t_Date;
        v_LnkAmount                  := v_TargetLot.t_Amount;
        v_Link.t_BalanceCostSale     := 0;
        v_Link.t_BalanceCostBD       := 0;
        v_Link.t_NotCarryInterestBuy := 0;
        v_Link.t_NotCarryInterestAdd := 0;
        v_Link.t_OldBegDiscountChange:= 0;
        v_Link.T_DISCOUNTCORRCHANGE  := 0;
        v_Link.T_OLDBEGBONUSCHANGE   := 0;
        v_Link.t_NotCarryDiscountBuy := 0;
        v_Link.T_NOTCARRYDISCOUNTADD := 0;
        v_Link.t_BalanceCostBuy      := 0;
        v_Link.t_OldBonusBuy         := 0;
        v_Link.t_ReservChange        := 0;
        v_Link.T_INCOMERESERVCHANGE  := 0;
        v_Link.t_OverChange          := 0;
        v_Link.t_OverChangeBD        := 0;
        v_Link.T_NOTWRTBONUSBUY      := 0;
        v_Link.T_COSTPFIBUY          := 0;
        v_Link.T_BLOCKAMOUNTBUY      := 0;
        v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
        v_Link.T_WRTOUTLAYADD        := 0;
        v_Link.T_WRTVATOUTLAYADD     := 0;
        v_Link.T_ESTRESERVCHANGE     := 0;
        v_Link.T_CORRESTRESERVCHANGE := 0;
        v_Link.T_ADDINCOMEOWNCHANGE  := 0;

        IF( v_LnkAmount <= p_RetLot.t_Amount ) THEN
           v_AmountRate                 := v_LnkAmount / p_RetLot.t_Amount;

           v_Link.t_Amount              := v_LnkAmount;
           v_Link.t_SumSale             := ROUND(p_RetLot.t_Sum * v_AmountRate,2);
           v_Link.t_SumBuy              := v_TargetLot.t_Sum;
           v_Link.t_CostSale            := ROUND(p_RetLot.t_Cost * v_AmountRate,2);
           v_Link.t_CostBuy             := v_TargetLot.t_Cost;
           v_Link.t_NKDSaleAmount       := ROUND(p_RetLot.t_NKDAmount * v_AmountRate,2);
           v_Link.t_NKDBuyAmount        := v_TargetLot.t_NKDAmount;
           v_Link.t_InterestIncomeBuy   := v_TargetLot.t_InterestIncome;
           v_Link.t_BegDiscountChange   := v_TargetLot.t_BegDiscount;
           v_Link.t_BegBonusChange      := v_TargetLot.t_BegBonus;
           v_Link.t_DiscountIncomeBuy   := v_TargetLot.t_DiscountIncome;
           v_Link.t_BonusBuy            := v_TargetLot.t_Bonus;
           v_Link.t_OutlaySale          := ROUND(p_RetLot.t_Outlay * v_AmountRate,2);
           v_Link.t_OutlayBuy           := v_TargetLot.t_Outlay;
           v_Link.T_ACCOUNTEDDEFDIFFBUY := v_TargetLot.T_ACCOUNTEDDEFDIFF;
           v_Link.T_BEGDEFDIFFCHANGE    := v_TargetLot.T_BEGDEFDIFF;
           v_Link.T_WRTOUTLAYBUY        := v_TargetLot.T_WRTOUTLAY;
           v_Link.T_WRTVATOUTLAYBUY     := v_TargetLot.T_WRTVATOUTLAY;
           v_Link.T_VATOUTLAYCHANGE     := v_TargetLot.T_VATOUTLAY;
           v_Link.T_FAIRVALUECHANGE     := v_TargetLot.T_FAIRVALUE;
           v_Link.T_AMORTCOSTCHANGE     := v_TargetLot.T_AMORTCOST;
           v_Link.T_CORRVALUECHANGE     := v_TargetLot.T_CORRVALUE;
           v_Link.T_CORRINTTOEIRCHANGE  := v_TargetLot.T_CORRINTTOEIR;
           v_Link.T_HEDGCORRCHANGE      := v_TargetLot.T_HEDGCORR;
           v_Link.T_AMORTHEDGCORRCHANGE := v_TargetLot.T_AMORTHEDGCORR;

        ELSE
           v_AmountRate                 := p_RetLot.t_Amount / v_TargetLot.t_Amount;

           v_Link.t_Amount              := p_RetLot.t_Amount;
           v_Link.t_SumSale             := p_RetLot.t_Sum;
           v_Link.t_SumBuy              := ROUND(v_TargetLot.t_Sum * v_AmountRate,2);
           v_Link.t_CostSale            := p_RetLot.t_Cost;
           v_Link.t_CostBuy             := ROUND(v_TargetLot.t_Cost * v_AmountRate,2);
           v_Link.t_NKDSaleAmount       := p_RetLot.t_NKDAmount;
           v_Link.t_NKDBuyAmount        := ROUND(v_TargetLot.t_NKDAmount * v_AmountRate,2);
           v_Link.t_InterestIncomeBuy   := ROUND(v_TargetLot.t_InterestIncome * v_AmountRate,2);
           v_Link.t_BegDiscountChange   := ROUND(v_TargetLot.t_BegDiscount * v_AmountRate,2);
           v_Link.t_BegBonusChange      := ROUND(v_TargetLot.t_BegBonus * v_AmountRate,2);
           v_Link.t_DiscountIncomeBuy   := ROUND(v_TargetLot.t_DiscountIncome * v_AmountRate,2);
           v_Link.t_BonusBuy            := ROUND(v_TargetLot.t_Bonus * v_AmountRate,2);
           v_Link.t_OutlaySale          := p_RetLot.t_Outlay;
           v_Link.t_OutlayBuy           := ROUND(v_TargetLot.t_Outlay * v_AmountRate,2);
           v_Link.T_ACCOUNTEDDEFDIFFBUY := ROUND(v_TargetLot.T_ACCOUNTEDDEFDIFF* v_AmountRate,2);
           v_Link.T_BEGDEFDIFFCHANGE    := ROUND(v_TargetLot.T_BEGDEFDIFF* v_AmountRate,2);
           v_Link.T_WRTOUTLAYBUY        := ROUND(v_TargetLot.T_WRTOUTLAY* v_AmountRate,2);
           v_Link.T_WRTVATOUTLAYBUY     := ROUND(v_TargetLot.T_WRTVATOUTLAY* v_AmountRate,2);
           v_Link.T_VATOUTLAYCHANGE     := ROUND(v_TargetLot.T_VATOUTLAY* v_AmountRate,2);
           v_Link.T_FAIRVALUECHANGE     := ROUND(v_TargetLot.T_FAIRVALUE* v_AmountRate,2);
           v_Link.T_AMORTCOSTCHANGE     := ROUND(v_TargetLot.T_AMORTCOST* v_AmountRate,2);
           v_Link.T_CORRVALUECHANGE     := ROUND(v_TargetLot.T_CORRVALUE* v_AmountRate,2);
           v_Link.T_CORRINTTOEIRCHANGE  := ROUND(v_TargetLot.T_CORRINTTOEIR* v_AmountRate,2);
           v_Link.T_HEDGCORRCHANGE      := ROUND(v_TargetLot.T_HEDGCORR* v_AmountRate,2);
           v_Link.T_AMORTHEDGCORRCHANGE := ROUND(v_TargetLot.T_AMORTHEDGCORR* v_AmountRate,2);
        END IF;

        IF( (p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or p_CalcDefDiff = true or p_CalcOutlay = true) and v_TargetLot.t_State = PM_WRTSUM_PLACE_OWN ) THEN
           BEGIN
             SELECT TMP.* into v_WrtSumTmp
               FROM DPMWRTSUM_TMP TMP
              WHERE TMP.T_SUMID = v_TargetLot.T_SUMID;
           EXCEPTION
           WHEN OTHERS THEN
               SetError( WRTOFF_ERROR_20254 );
           END;

           if v_WrtSumTmp.T_AMOUNT = 0 then
              v_Link.T_INTERESTINCOMEADD   := 0;
              v_Link.T_DISCOUNTINCOMEADD   := 0;
              v_Link.T_BONUSADD            := 0;
              v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
              v_Link.T_WRTOUTLAYADD        := 0;
              v_Link.T_WRTVATOUTLAYADD     := 0;
           else
              v_Link.T_INTERESTINCOMEADD   := ROUND(v_WrtSumTmp.T_INTERESTADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_DISCOUNTINCOMEADD   := ROUND(v_WrtSumTmp.T_DISCOUNTADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_BONUSADD            := ROUND(v_WrtSumTmp.T_BONUSADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_ACCOUNTEDDEFDIFFADD := ROUND(v_WrtSumTmp.T_DEFDIFFADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_WRTOUTLAYADD        := ROUND(v_WrtSumTmp.T_WRTOUTLAYADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
              v_Link.T_WRTVATOUTLAYADD     := ROUND(v_WrtSumTmp.T_VATOUTLAYADD / v_WrtSumTmp.T_AMOUNT * v_Link.T_AMOUNT,2);
           end if;

        END IF;

        BEGIN
           RSI_InsDfltIntoWRTLNK(v_Link);
           INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

           p_RetLot.t_Amount        := p_RetLot.t_Amount - v_Link.t_Amount;
           p_RetLot.t_Sum           := p_RetLot.t_Sum - v_Link.t_SumSale;
           p_RetLot.t_Cost          := p_RetLot.t_Cost - v_Link.t_CostSale;
           p_RetLot.t_NKDAmount     := p_RetLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
           p_RetLot.t_Outlay        := p_RetLot.t_Outlay - v_Link.t_OutlaySale;
        END;

     END LOOP;

     CLOSE Lots;

   END;--RSI_WRTLinkRetireLotOwn

   -- Выполняет списание лота продажи по 2 ч. по указанному лоту 1 ч.
   PROCEDURE RSI_WRTLinkLotRepoPart2( p_SaleLot          IN OUT DPMWRTSUM_DBT%ROWTYPE,
                                      p_CheckTime        IN     NUMBER, -- Признак контроля времени
                                      p_ID_Operation     IN     NUMBER, -- Операция и шаг, на которых выполняется списание
                                      p_ID_Step          IN     NUMBER,
                                      p_LinkKind         IN     NUMBER, -- Вид создаваемой связи
                                      p_Action           IN     NUMBER, -- Вид изменения на лоте
                                      p_CalcInterest     IN    BOOLEAN, -- Расчитывать процентный доход
                                      p_CalcDiscount     IN    BOOLEAN, -- Расчитывать дисконтный доход
                                      p_CalcBonus        IN    BOOLEAN, -- Начислять премию
                                      p_CalcOver         IN    BOOLEAN, -- Пересчитывать переоценку
                                      p_BuyID            IN     NUMBER  -- Списываемый лот 1ч
                                    )
   IS
     v_Link        DPMWRTLNK_DBT%ROWTYPE;
     v_BuyLot      DPMWRTSUM_DBT%ROWTYPE;
     v_AmountRate  NUMBER;
     v_OverAmount  NUMBER;
     v_Method      NUMBER;
     v_i           NUMBER;
     v_b           NUMBER;
     v_d           NUMBER;
     v_dd          NUMBER;
     v_e           NUMBER;
     v_FaceValueFI NUMBER;

   BEGIN

      BEGIN
        SELECT * INTO v_BuyLot
          FROM DPMWRTSUM_DBT
         WHERE t_SumID = p_BuyID;
      EXCEPTION
         WHEN OTHERS THEN
             SetError( WRTOFF_ERROR_20200 );
      END;

      IF(    v_BUYLOT.T_DEPARTMENT != p_SALELOT.T_DEPARTMENT
          OR v_BUYLOT.T_PARTY      != p_SALELOT.T_PARTY
          OR v_BUYLOT.T_CONTRACT   != p_SALELOT.T_CONTRACT
          OR v_BUYLOT.T_DATE        > p_SALELOT.T_DATE
          OR ( (p_CheckTime > 0) AND
               (v_BUYLOT.T_TIME > p_SALELOT.T_TIME) AND
               (v_BUYLOT.T_DATE = p_SALELOT.T_DATE)
             )
        ) THEN
         SetError( WRTOFF_ERROR_20212 );
         RETURN;
      END IF;

      IF( v_BUYLOT.T_CHANGEDATE > p_SALELOT.T_DATE ) THEN
         SetError( WRTOFF_ERROR_20213 );
         RETURN;
      END IF;

      IF( v_BUYLOT.T_STATE != PM_WRTSUM_FORM ) THEN
         SetError( WRTOFF_ERROR_20214 );
         RETURN;
      END IF;

      SELECT FIN.T_FACEVALUEFI
       INTO v_FaceValueFI
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID = p_SaleLot.t_FIID;

      IF( v_BUYLOT.T_ISFREE = 'X' ) THEN

         IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true) THEN

            v_Method := GetAmortizationMethod( p_SALELOT.T_Party, p_SALELOT.T_Contract );

            RSI_WRTCalcIncomeOnLotTMP(v_BUYLOT.T_SumID, p_SALELOT.T_DATE,
                                      p_CalcInterest,
                                      p_CalcDiscount,
                                      p_CalcBonus,
                                      false, false, 0,
                                      v_i, v_d, v_b, v_dd, v_e); --тут возвращаемые параметры нам не нужны

         END IF;

         IF( p_CalcOver AND (v_BuyLot.t_OverAmount <> 0) ) THEN
            v_OverAmount := v_BuyLot.t_BalanceCost - v_BuyLot.t_Cost - v_BuyLot.t_NKDAmount - v_BuyLot.t_InterestIncome - v_BuyLot.t_DiscountIncome - v_BuyLot.t_CostPFI;
         ELSE
            v_OverAmount := v_BuyLot.t_OverAmount;
         END IF;

         -- теперь будем списывать
         v_Link.t_LnkID               := 0;
         v_Link.t_SaleID              := p_SaleLot.t_SumID;
         v_Link.t_BuyID               := v_BuyLot.t_SumID;
         v_Link.t_Kind                := p_LinkKind;
         v_Link.t_DiscountIncomeAdd   := 0;
         v_Link.t_InterestIncomeAdd   := 0;
         v_Link.t_NotCarryDiscountAdd := 0;
         v_Link.t_NotCarryInterestAdd := 0;
         v_Link.t_BonusAdd            := 0;
         v_Link.t_BalanceCostBD       := 0;
         v_Link.t_OverChangeBD        := 0;
         v_Link.T_BLOCKAMOUNTBUY      := 0;
         v_Link.t_Coupon              := p_SaleLot.t_Coupon;
         v_Link.t_Partly              := p_SaleLot.t_Partly;
         v_Link.t_ID_Operation        := p_ID_Operation;
         v_Link.t_ID_Step             := p_ID_Step;
         v_Link.t_Action              := p_Action;
         v_Link.t_CreateDate          := p_SaleLot.t_Date;
         IF( v_BuyLot.t_Amount <= p_SaleLot.t_Amount ) THEN
            v_AmountRate                 := v_BuyLot.t_Amount / p_SaleLot.t_Amount;

            v_Link.t_BalanceCostSale     := ROUND(p_SaleLot.t_BalanceCost * v_AmountRate, 2);
            v_Link.t_Amount              := v_BuyLot.t_Amount;
            v_Link.t_SumSale             := ROUND(p_SaleLot.t_Sum * v_AmountRate,2);
            v_Link.t_SumBuy              := v_BuyLot.t_Sum;
            v_Link.t_CostSale            := ROUND(p_SaleLot.t_Cost * v_AmountRate,2);
            v_Link.t_CostBuy             := v_BuyLot.t_Cost;
            v_Link.t_NKDSaleAmount       := ROUND(p_SaleLot.t_NKDAmount * v_AmountRate,2);
            v_Link.t_NKDBuyAmount        := v_BuyLot.t_NKDAmount;
            v_Link.t_InterestIncomeBuy   := v_BuyLot.t_InterestIncome;
            v_Link.t_NotCarryInterestBuy := v_BuyLot.t_NotCarryInterest;
            v_Link.t_BegDiscountChange   := v_BuyLot.t_BegDiscount;
            v_Link.t_OldBegDiscountChange:= v_BuyLot.t_OldBegDiscount;
            v_Link.T_DISCOUNTCORRCHANGE  := v_BUYLOT.T_DISCOUNTCORR;
            v_Link.t_BegBonusChange      := v_BuyLot.t_BegBonus;
            v_Link.T_OLDBEGBONUSCHANGE   := v_BUYLOT.T_OLDBEGBONUS;
            v_Link.t_DiscountIncomeBuy   := v_BuyLot.t_DiscountIncome;
            v_Link.t_NotCarryDiscountBuy := v_BuyLot.t_NotCarryDiscount;
            v_Link.t_BonusBuy            := v_BuyLot.t_Bonus;
            v_Link.t_OldBonusBuy         := v_BuyLot.t_OldBonus;
            v_Link.t_OutlaySale          := ROUND(p_SaleLot.t_Outlay * v_AmountRate,2);
            v_Link.t_OutlayBuy           := v_BuyLot.t_Outlay;
            v_Link.t_ReservChange        := v_BuyLot.t_ReservAmount;
            v_Link.t_IncomeReservChange  := v_BuyLot.t_IncomeReserv;
            v_Link.t_OverChange          := v_BuyLot.t_OverAmount;
            v_Link.T_COSTPFIBUY          := v_BuyLot.T_COSTPFI;
            v_Link.t_BalanceCostBuy      := v_Link.t_CostBuy + v_Link.t_NKDBuyAmount + v_Link.t_InterestIncomeBuy + v_Link.t_DiscountIncomeBuy + v_Link.T_COSTPFIBUY + v_OverAmount;
            v_Link.T_NOTWRTBONUSBUY      := v_BuyLot.T_NOTWRTBONUS;
            v_Link.T_ACCOUNTEDDEFDIFFBUY := v_BuyLot.T_ACCOUNTEDDEFDIFF;
            v_Link.T_BEGDEFDIFFCHANGE    := v_BuyLot.T_BEGDEFDIFF;
            v_Link.T_WRTOUTLAYBUY        := v_BuyLot.T_WRTOUTLAY;
            v_Link.T_WRTVATOUTLAYBUY     := v_BuyLot.T_WRTVATOUTLAY;
            v_Link.T_VATOUTLAYCHANGE     := v_BuyLot.T_VATOUTLAY;
            v_Link.T_FAIRVALUECHANGE     := v_BuyLot.T_FAIRVALUE;
            v_Link.T_AMORTCOSTCHANGE     := v_BuyLot.T_AMORTCOST;
            v_Link.T_CORRVALUECHANGE     := v_BuyLot.T_CORRVALUE;
            v_Link.T_ESTRESERVCHANGE     := v_BuyLot.T_ESTRESERVE;
            v_Link.T_CORRINTTOEIRCHANGE  := v_BuyLot.T_CORRINTTOEIR;
            v_Link.T_CORRESTRESERVCHANGE := v_BuyLot.T_CORRESTRESERVE;
            v_Link.T_HEDGCORRCHANGE      := v_BuyLot.T_HEDGCORR;
            v_Link.T_AMORTHEDGCORRCHANGE := v_BuyLot.T_AMORTHEDGCORR;
        ELSE
            v_AmountRate                 := p_SaleLot.t_Amount / v_BuyLot.t_Amount;

            v_Link.t_BalanceCostSale     := p_SaleLot.t_BalanceCost;
            v_Link.t_Amount              := p_SaleLot.t_Amount;
            v_Link.t_SumSale             := p_SaleLot.t_Sum;
            v_Link.t_SumBuy              := ROUND(v_BuyLot.t_Sum * v_AmountRate,2);
            v_Link.t_CostSale            := p_SaleLot.t_Cost;
            v_Link.t_CostBuy             := ROUND(v_BuyLot.t_Cost * v_AmountRate,2);
            v_Link.t_NKDSaleAmount       := p_SaleLot.t_NKDAmount;
            v_Link.t_NKDBuyAmount        := ROUND(v_BuyLot.t_NKDAmount * v_AmountRate,2);
            v_Link.t_InterestIncomeBuy   := ROUND(v_BuyLot.t_InterestIncome * v_AmountRate,2);
            v_Link.t_NotCarryInterestBuy := ROUND(v_BuyLot.t_NotCarryInterest * v_AmountRate,2);
            v_Link.t_BegDiscountChange   := ROUND(v_BuyLot.t_BegDiscount * v_AmountRate,2);
            v_Link.t_OldBegDiscountChange:= ROUND(v_BuyLot.t_OldBegDiscount * v_AmountRate,2);
            v_Link.T_DISCOUNTCORRCHANGE  := ROUND(v_BuyLot.t_DISCOUNTCORR * v_AmountRate,2);
            v_Link.T_OLDBEGBONUSCHANGE   := ROUND(v_BuyLot.T_OLDBEGBONUS * v_AmountRate,2);
            v_Link.t_BegBonusChange      := ROUND(v_BuyLot.t_BegBonus * v_AmountRate,2);
            v_Link.t_DiscountIncomeBuy   := ROUND(v_BuyLot.t_DiscountIncome * v_AmountRate,2);
            v_Link.t_NotCarryDiscountBuy := ROUND(v_BuyLot.t_NotCarryDiscount * v_AmountRate,2);
            v_Link.t_BonusBuy            := ROUND(v_BuyLot.t_Bonus * v_AmountRate,2);
            v_Link.t_OldBonusBuy         := ROUND(v_BuyLot.t_OldBonus * v_AmountRate,2);
            v_Link.t_OutlaySale          := p_SaleLot.t_Outlay;
            v_Link.t_OutlayBuy           := ROUND(v_BuyLot.t_Outlay * v_AmountRate,2);
            v_Link.t_ReservChange        := ROUND(v_BuyLot.t_ReservAmount * v_AmountRate,2);
            v_Link.t_IncomeReservChange  := ROUND(v_BuyLot.t_IncomeReserv * v_AmountRate,2);
            v_Link.t_OverChange          := ROUND(v_BuyLot.t_OverAmount * v_AmountRate,2);
            v_Link.T_COSTPFIBUY          := ROUND(v_BuyLot.T_COSTPFI * v_AmountRate,2);
            v_Link.t_BalanceCostBuy      := v_Link.t_CostBuy + v_Link.t_NKDBuyAmount + v_Link.t_InterestIncomeBuy + v_Link.t_DiscountIncomeBuy + v_Link.T_COSTPFIBUY + ROUND(v_OverAmount* v_AmountRate,2);
            v_Link.T_NOTWRTBONUSBUY      := ROUND(v_BuyLot.T_NOTWRTBONUS * v_AmountRate,2);
            v_Link.T_ACCOUNTEDDEFDIFFBUY := ROUND(v_BuyLot.T_ACCOUNTEDDEFDIFF * v_AmountRate,2);
            v_Link.T_BEGDEFDIFFCHANGE    := ROUND(v_BuyLot.T_BEGDEFDIFF * v_AmountRate,2);
            v_Link.T_WRTOUTLAYBUY        := ROUND(v_BuyLot.T_WRTOUTLAY * v_AmountRate,2);
            v_Link.T_WRTVATOUTLAYBUY     := ROUND(v_BuyLot.T_WRTVATOUTLAY * v_AmountRate,2);
            v_Link.T_VATOUTLAYCHANGE     := ROUND(v_BuyLot.T_VATOUTLAY * v_AmountRate,2);
            v_Link.T_FAIRVALUECHANGE     := ROUND(v_BuyLot.T_FAIRVALUE * v_AmountRate,2);
            v_Link.T_AMORTCOSTCHANGE     := ROUND(v_BuyLot.T_AMORTCOST * v_AmountRate,2);
            v_Link.T_CORRVALUECHANGE     := ROUND(v_BuyLot.T_CORRVALUE * v_AmountRate,2);
            v_Link.T_ESTRESERVCHANGE     := ROUND(v_BuyLot.T_ESTRESERVE * v_AmountRate,2);
            v_Link.T_CORRINTTOEIRCHANGE  := ROUND(v_BuyLot.T_CORRINTTOEIR * v_AmountRate,2);
            v_Link.T_CORRESTRESERVCHANGE := ROUND(v_BuyLot.T_CORRESTRESERVE * v_AmountRate,2);
            v_Link.T_HEDGCORRCHANGE      := ROUND(v_BuyLot.T_HEDGCORR * v_AmountRate,2);
            v_Link.T_AMORTHEDGCORRCHANGE := ROUND(v_BuyLot.T_AMORTHEDGCORR * v_AmountRate,2);
         END IF;

         IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true) THEN
            WRTChangeIncomeOnSale(v_Link, v_BuyLot, p_CalcInterest, p_CalcDiscount, p_CalcBonus, false, false, false, false, v_Method, p_SaleLot.T_Date);
         END IF;

         BEGIN
            RSI_InsDfltIntoWRTLNK(v_Link);
            INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

            p_SaleLot.t_Amount      := p_SaleLot.t_Amount - v_Link.t_Amount;
            p_SaleLot.t_Sum         := p_SaleLot.t_Sum - v_Link.t_SumSale;
            p_SaleLot.t_Cost        := p_SaleLot.t_Cost - v_Link.t_CostSale;
            p_SaleLot.t_BalanceCost := p_SaleLot.t_BalanceCost - v_Link.t_BalanceCostSale;
            p_SaleLot.t_NKDAmount   := p_SaleLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
            p_SaleLot.t_Outlay      := p_SaleLot.t_Outlay - v_Link.t_OutlaySale;
         END;
      END IF;

   END; -- RSI_WRTLinkLotRepoPart2


   -- Выполняет списание лота продажи по 2 ч. по лотам 1 ч.
   PROCEDURE RSI_WRTLinkSaleToLot( p_SaleLot          IN OUT DPMWRTSUM_DBT%ROWTYPE,
                                   p_CheckTime        IN     NUMBER, -- Признак контроля времени
                                   p_ID_Operation     IN     NUMBER, -- Операция и шаг, на которых выполняется списание
                                   p_ID_Step          IN     NUMBER,
                                   p_LinkKind         IN     NUMBER, -- Вид создаваемой связи
                                   p_Action           IN     NUMBER, -- Вид изменения на лоте
                                   p_CalcInterest     IN    BOOLEAN, -- Расчитывать процентный доход
                                   p_CalcDiscount     IN    BOOLEAN, -- Расчитывать дисконтный доход
                                   p_CalcBonus        IN    BOOLEAN, -- Начислять премию
                                   p_CalcOver         IN    BOOLEAN  -- Пересчитывать переоценку
                                 )
   IS
     v_Link       DPMWRTLNK_DBT%ROWTYPE;
     v_BuyLot     DPMWRTSUM_DBT%ROWTYPE;
     v_AmountRate NUMBER;
     v_OverAmount NUMBER;
     v_Method     NUMBER;
     v_Flag       NUMBER;
     v_i          NUMBER;
     v_b          NUMBER;
     v_d          NUMBER;

     v_Break      BOOLEAN;

     v_BuyID      NUMBER;

   BEGIN
      if( p_SALELOT.T_AMOUNT = 0 ) then
         return;
      end if;

      if( p_SALELOT.T_PARENT = 0 ) then
         SetError( WRTOFF_ERROR_20211 );
         return;
      end if;

      RSI_WRTLinkLotRepoPart2(p_SaleLot, p_CheckTime, p_ID_Operation, p_ID_Step, p_LinkKind, p_Action, p_CalcInterest, p_CalcDiscount, p_CalcBonus, p_CalcOver, p_SaleLot.T_PARENT); -- списываем кусочек начального лота 1ч ОР. Может быть уже нулевым

      IF p_SaleLot.t_Date < NewRepoDate() THEN
        v_Break := TRUE;
      ELSE
        v_Break := FALSE;
      END IF;

      WHILE v_Break = FALSE AND p_SaleLot.t_Amount > 0 LOOP

        BEGIN
          v_BuyID := 0;

          IF SortingLotsAmount() = SORTING_LOTS_AMOUNT_ASC THEN
            SELECT q.T_SUMID INTO v_BuyID
              FROM ( SELECT /*+ INDEX( Buy DPMWRTSUM_DBT_IDXA)*/ Lot.t_SUMID
                       FROM DPMWRTSUM_DBT Lot
                      WHERE Lot.t_SOURCE     = p_SaleLot.t_Parent
                        AND Lot.t_Department = p_SaleLot.t_Department
                        AND Lot.t_FIID       = p_SaleLot.t_FIID
                        AND Lot.t_Party      = p_SaleLot.t_Party
                        AND Lot.t_Portfolio  IN (KINDPORT_BACK, KINDPORT_BACK_KSU)
                        AND Lot.t_Contract   = p_SaleLot.t_Contract
                        AND Lot.t_IsFree     = 'X'
                        AND Lot.t_Date       <= p_SaleLot.t_Date
                        AND ((Lot.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR 
                             ((Lot.T_ACTIVATEDATE = p_SaleLot.T_DATE) and 
                              ((Lot.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR 
                               (p_CheckTime = 0)
                              )
                             )
                            )
                      ORDER BY Lot.t_DATE ASC, Lot.t_TIME ASC, Lot.t_DEALDATE ASC, Lot.t_SortCode ASC, Lot.t_Amount ASC
                   ) q
             WHERE ROWNUM = 1;
           ELSE
             SELECT q.T_SUMID INTO v_BuyID
              FROM ( SELECT /*+ INDEX( Buy DPMWRTSUM_DBT_IDXB)*/ Lot.t_SUMID
                       FROM DPMWRTSUM_DBT Lot
                      WHERE Lot.t_SOURCE     = p_SaleLot.t_Parent
                        AND Lot.t_Department = p_SaleLot.t_Department
                        AND Lot.t_FIID       = p_SaleLot.t_FIID
                        AND Lot.t_Party      = p_SaleLot.t_Party
                        AND Lot.t_Portfolio  IN (KINDPORT_BACK, KINDPORT_BACK_KSU)
                        AND Lot.t_Contract   = p_SaleLot.t_Contract
                        AND Lot.t_IsFree     = 'X'
                        AND Lot.t_Date       <= p_SaleLot.t_Date
                        AND ((Lot.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR 
                             ((Lot.T_ACTIVATEDATE = p_SaleLot.T_DATE) and 
                              ((Lot.T_ACTIVATETIME <= p_SaleLot.T_TIME AND p_CheckTime = 1) OR 
                               (p_CheckTime = 0)
                              )
                             )
                            )
                      ORDER BY Lot.t_DATE ASC, Lot.t_TIME ASC, Lot.t_DEALDATE ASC, Lot.t_SortCode ASC, Lot.t_Amount DESC
                   ) q
             WHERE ROWNUM = 1;
           END IF;

           RSI_WRTLinkLotRepoPart2(p_SaleLot, p_CheckTime, p_ID_Operation, p_ID_Step, p_LinkKind, p_Action, p_CalcInterest, p_CalcDiscount, p_CalcBonus, p_CalcOver, v_BuyID);

           EXCEPTION
             WHEN OTHERS THEN
               v_Break := TRUE;

        END;

      END LOOP;

   END; -- RSI_WRTLinkSaleToLot

   ----- Выполняет списание лота продажи или погашения выпуска по сделке. Не используется для погашения купона или ЧП
   PROCEDURE RSI_WRTLinkSale( p_SaleID       IN NUMBER, -- Списываемый лот
                              p_G1           IN NUMBER, -- Группы списания (по приоритетам, до 5-х штук, незаданные - UnknownValue (-1))
                              p_G2           IN NUMBER,
                              p_G3           IN NUMBER,
                              p_G4           IN NUMBER,
                              p_G5           IN NUMBER,
                              p_CI1          IN NUMBER, -- Признаки необходимости начисления ПДД по соотв. группам (портфелям)
                              p_CI2          IN NUMBER,
                              p_CI3          IN NUMBER,
                              p_CI4          IN NUMBER,
                              p_CI5          IN NUMBER,
                              p_LinkToParent IN NUMBER, -- Признак необходимости связывания с лотом 1 ч.
                              p_CP           IN NUMBER, -- Признак необходимости начисления дохода по 1 ч.
                              p_RetBD        IN NUMBER, -- Признак списания ОД с лота 1 ч. (может задаваться только если установлен LinkToParent)
                              p_StartDate    IN DATE,   -- Дата отбора лотов покупки. Если не задана  - игнорируется. Используется в погашении выпуска.
                              p_ID_Operation IN NUMBER, -- Операция и шаг, на которых выполняется списание
                              p_ID_Step      IN NUMBER,
                              p_GrpID        IN NUMBER  -- Группа обработки
                            )
   IS
     v_SaleLot          DPMWRTSUM_DBT%ROWTYPE;
     v_SourceLot        dpmwrtsum_dbt%ROWTYPE;
     v_Method           NUMBER;
     v_LnkKind          NUMBER;
     v_Action           NUMBER;
     v_CheckTime        NUMBER;
     v_Group            NUMBER;
     v_CI               NUMBER;
     v_LnkToParentKind  NUMBER;
     v_ActionRetBD      NUMBER;
     v_CalcInterest     NUMBER;
     v_CalcDiscount     NUMBER;
     v_CalcBonus        NUMBER;
     v_CalcDefDiff      NUMBER;
     v_CalcCorrIntToEIR NUMBER;
     v_CalcReserve      NUMBER;
     v_FaceValueFI      NUMBER;
     v_CalcOver         BOOLEAN;

     v_DestGroup     NUMBER;
     v_Lot2    DPMWRTSUM_DBT%ROWTYPE;
     v_Lot2New DPMWRTSUM_DBT%ROWTYPE;
     v_RestLot2Amount NUMBER;
     v_Lot2Amount     NUMBER;
     v_RestAmount     NUMBER;
     v_Break          BOOLEAN;
     v_MaxPartNum NUMBER;
     v_Sale       DPMWRTSUM_DBT%ROWTYPE;
     v_OldAmount      NUMBER;
     v_Amount        NUMBER;
   BEGIN
     InitError();

     BEGIN
       SELECT * INTO v_SaleLot
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SaleID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     IF( (v_SaleLot.t_State != PM_WRTSUM_FORM) OR
         (v_SaleLot.t_Amount = 0) ) THEN
        SetError( WRTOFF_ERROR_20206 );
     END IF;

     IF( v_SaleLot.t_Kind = WRTSUM_KIND_FS_TRUSTREQ ) THEN -- списание по заявлению ВВК в ДУ
        v_Method := PM_WRITEOFF_FIFO;
     ELSE
        v_Method := GetAmortizationMethod( v_SaleLot.t_Party, v_SaleLot.t_Contract );
        if( v_Method = UnknownValue ) then
           return;
        end if;
     END IF;

     IF( v_SaleLot.t_Kind not in (WRTSUM_KIND_DP, WRTSUM_KIND_DC) ) THEN
        BEGIN
          select t_FaceValueFI into v_FaceValueFI
            from dfininstr_dbt
           where t_FIID = v_SaleLot.t_FIID;
        EXCEPTION
           WHEN OTHERS THEN v_FaceValueFI := 0;
        END;

           v_CalcOver := True;
     END IF;

     IF( v_SaleLot.t_Kind = WRTSUM_KIND_DI ) THEN -- Погашение выпуска
        v_LnkKind   := PMWRTLINK_KIND_RETISSUE;
        v_Action    := PM_WRT_UPDTMODE_RETISSUE;
        v_CheckTime := 0;
     ELSIF( v_SaleLot.t_Kind = WRTSUM_KIND_DC ) THEN -- Погашение купона
        v_LnkKind   := PMWRTLINK_KIND_RETCOUPON;
        v_Action    := PM_WRT_UPDTMODE_RETCOUPON;
     ELSIF( v_SaleLot.t_Kind = WRTSUM_KIND_DP ) THEN -- Частичное погашение
        v_LnkKind   := PMWRTLINK_KIND_RETPARTLY;
        v_Action    := PM_WRT_UPDTMODE_RETPARTLY;
     ELSE
        IF( p_LinkToParent = 1 ) THEN
           IF( p_RetBD = 1) THEN
              IF (RSI_RSB_FIInstr.FI_IsKSU(v_SaleLot.t_FIID) > 0) THEN
                 v_LnkKind    := PMWRTLINK_KIND_DISCARD;
              ELSE
                 v_LnkKind    := PMWRTLINK_KIND_DISCARDBD; -- оставил, для совместимости. Начиная с перехода на 215-Т, смысла выделять эти связи в отдельный вид больше не видится
              END IF;
           ELSE
              v_LnkKind    := PMWRTLINK_KIND_DISCARD;
           END IF;
           v_LnkToParentKind := PMWRTLINK_KIND_DISCARD;
        ELSE
          v_LnkKind   := PMWRTLINK_KIND_DISCARD;
        END IF;
        v_Action    := PM_WRT_UPDTMODE_DISCARD;
        IF( v_SaleLot.t_Kind = WRTSUM_KIND_FS_TRUSTREQ ) THEN -- списание по заявлению ВВК в ДУ
           v_CheckTime := 1;
        ELSE
           IF(
               Rsb_Common.GetRegFlagValue('SECUR\NOT_CHECK_TIME_OFFLINE') = chr(0) AND v_SaleLot.t_Party = -1

             ) THEN
              v_CheckTime := 1;
           ELSE
              v_CheckTime := 0;
           END IF;
        END IF;
     END IF;

     if( (v_SALELOT.T_KIND = WRTSUM_KIND_DP) OR (v_SALELOT.T_KIND = WRTSUM_KIND_DC) ) then

        if( ( (v_SALELOT.t_Party = UnknownParty) OR (v_SALELOT.t_Trust = 'X') ) AND
            (WRTNeedChargeInterestIncome (v_SALELOT.t_FIID) = 1)
          ) then
           v_CalcInterest := 1;
        else
           v_CalcInterest := 0;
        end if;

        if( ( (v_SALELOT.t_Party = UnknownParty) OR (v_SALELOT.t_Trust = 'X') ) AND
            (WRTNeedChargeIncome (v_SALELOT.t_FIID) = 1)
          ) then
           v_CalcDiscount := 1;
        else
           v_CalcDiscount := 0;
        end if;

        -- !!! В ДУ премий нет.
        if( (v_SALELOT.t_Party = UnknownParty) AND
            (v_SALELOT.t_Trust != 'X') AND
            (WRTNeedChargeBonus (v_SALELOT.t_FIID) = 1)
          ) then
           v_CalcBonus := 1;
        else
           v_CalcBonus := 0;
        end if;

        if( v_SALELOT.t_Party = UnknownParty ) then
           v_CalcDefDiff := 1;
           v_CalcCorrIntToEIR := 1;
        else
           v_CalcDefDiff := 0;
           v_CalcCorrIntToEIR := 0;
        end if;

        FOR v_ID IN 1..5 LOOP
           IF( v_ID = 1 ) THEN
              v_Group := p_G1;
              v_CI    := p_CI1;
           ELSIF( v_ID = 2 ) THEN
              v_Group := p_G2;
              v_CI    := p_CI2;
           ELSIF( v_ID = 3 ) THEN
              v_Group := p_G3;
              v_CI    := p_CI3;
           ELSIF( v_ID = 4 ) THEN
              v_Group := p_G4;
              v_CI    := p_CI4;
           ELSIF( v_ID = 5 ) THEN
              v_Group := p_G5;
              v_CI    := p_CI5;
           END IF;

           if( (v_SaleLot.t_Amount > 0) AND (v_Group != UnknownValue) ) then
              RSI_WRTLinkWrt( v_SALELOT, v_Group, p_StartDate, v_Method, p_ID_Operation, p_ID_Step,
                          v_LnkKind, v_Action,
                          (v_CalcInterest     = 1 and v_CI > 0),
                          (v_CalcDiscount     = 1 and v_CI > 0),
                          (v_CalcBonus        = 1 and v_CI > 0),
                          (v_CalcDefDiff      = 1 and v_CI > 0),
                          (v_CalcCorrIntToEIR = 1 and v_CI > 0),
                          p_GrpID
                        );
           end if;
        END LOOP;
     else

        if( ( (v_SALELOT.t_Party = UnknownParty) OR (v_SALELOT.t_Trust = 'X') ) AND
            (WRTNeedChargeInterestIncome (v_SALELOT.t_FIID) = 1)
          ) then
           v_CalcInterest := 1;
        else
           v_CalcInterest := 0;
        end if;

        if( ( (v_SALELOT.t_Party = UnknownParty) OR (v_SALELOT.t_Trust = 'X') ) AND
            (WRTNeedChargeIncome (v_SALELOT.t_FIID) = 1)
          ) then
           v_CalcDiscount := 1;
        else
           v_CalcDiscount := 0;
        end if;

        if( (v_SALELOT.t_Party = UnknownParty) AND
            (v_SALELOT.t_Trust != 'X') AND
            (WRTNeedChargeBonus (v_SALELOT.t_FIID) = 1)
          ) then
           v_CalcBonus := 1;
        else
           v_CalcBonus := 0;
        end if;

        if( v_SALELOT.t_Party = UnknownParty ) then
           v_CalcDefDiff := 1;
           v_CalcCorrIntToEIR := 1;
           v_CalcReserve := 1;
        else
           v_CalcDefDiff := 0;
           v_CalcCorrIntToEIR := 0;
           v_CalcReserve := 0;
        end if;

        if( p_LinkToParent > 0 ) then
           RSI_WRTLinkSaleToLot( v_SaleLot, v_CheckTime, p_ID_Operation, p_ID_Step,
                             v_LnkToParentKind, v_Action,
                             (v_CalcInterest = 1 and p_CP > 0),
                             (v_CalcDiscount = 1 and p_CP > 0),
                             (v_CalcBonus    = 1 and p_CP > 0),
                             true--v_CalcOver
                           );
        end if;

        if (p_LinkToParent = 1 and p_RetBD = 0) then
           RETURN; -- если запускали целенаправленно для списания по 2ч ОР бумаг из 1ч ОР, то выходим.
        end if;

        FOR v_ID IN 1..5 LOOP

           IF( v_ID = 1 ) THEN
              v_Group := p_G1;
              v_CI    := p_CI1;
           ELSIF( v_ID = 2 ) THEN
              v_Group := p_G2;
              v_CI    := p_CI2;
           ELSIF( v_ID = 3 ) THEN
              v_Group := p_G3;
              v_CI    := p_CI3;
           ELSIF( v_ID = 4 ) THEN
              v_Group := p_G4;
              v_CI    := p_CI4;
           ELSIF( v_ID = 5 ) THEN
              v_Group := p_G5;
              v_CI    := p_CI5;
           END IF;

           IF( (v_SaleLot.t_Amount > 0) AND ( v_Group <> UnknownValue ) ) THEN

              RSI_WRTLinkSaleToBuy(v_SaleLot, UnknownValue, v_Group, p_StartDate, v_Method,
                               v_CheckTime, p_ID_Operation, p_ID_Step, v_LnkKind, v_Action,
                               (v_CalcInterest     = 1 and v_CI > 0),
                               (v_CalcDiscount     = 1 and v_CI > 0),
                               (v_CalcBonus        = 1 and v_CI > 0),
                               (v_CalcDefDiff      = 1 and v_CI > 0),
                               (v_CalcCorrIntToEIR = 1 and v_CI > 0),
                               v_CalcReserve=1,
                               true--v_CalcOver
                              );

              -- !!! Если v_Date >= Дата_из_настройки_"Дата начала нового БУ РЕПО" и бумага - КСУ, и покупок с нужным портфелем/группой найти не удалось,
              -- 1) Если ищем по группе ПВО_КСУ(зачисления), то перебрать все ушедшие в ПР лоты КСУ(зачислений), и "перевесить" их на поставленные лоты 1ч обратного РЕПО с КСУ
              -- 2) Если ищем по группе ПВО_КСУ(РЕПО), то перебрать все ушедшие в ПР лоты КСУ(РЕПО), и "перевесить" их на поставленные лоты 1ч зачислений КСУ
              -- это только для списаний и 2ч ОР (1ч ПР может списывать с обоих групп списания)
              IF( (v_SaleLot.t_Amount > 0) AND (v_SaleLot.t_Date >= NewRepoDate()) AND (RSI_RSB_FIInstr.FI_IsKSU(v_SaleLot.t_FIID) > 0) AND (v_SaleLot.t_Kind IN (WRTSUM_KIND_FS, WRTSUM_KIND_RRWAS2))) THEN

                --v_Group - группа с которой списываем (и не находим).
                --v_DestGroup := соотв-но другая группа КСУ (если v_Group == 12 то 112, иначе 12).
                --Нужно с группы v_DestGroup списать в прямое РЕПО, а столько же бумаг группы v_Group вернуть с прямого РЕПО.
                if( v_Group = KINDPORT_BACK_KSU )then
                   v_DestGroup := KINDPORT_KSU;
                else
                   v_DestGroup := KINDPORT_BACK_KSU;
                end if;

                -- кол-во поставленных бумаг в v_DestGroup
                SELECT NVL(SUM(Lot.T_AMOUNT), 0) INTO v_RestAmount
                  FROM DPMWRTSUM_DBT Lot
                 WHERE Lot.t_Department = v_SaleLot.t_Department
                   AND Lot.t_FIID       = v_SaleLot.t_FIID
                   AND Lot.t_Party      = v_SaleLot.t_Party
                   AND Lot.t_Contract   = v_SaleLot.t_Contract
                   AND Lot.t_Portfolio  = KINDPORT_BACK_KSU
                   AND Lot.t_GroupID    = v_DestGroup
                   AND Lot.t_IsFree     = 'X';

                v_Break := FALSE;
                WHILE( (v_Break = FALSE) AND (v_RestAmount > 0) )
                LOOP

                   v_Lot2 := NULL;

                   BEGIN
                    SELECT * INTO v_Lot2
                      -- непоставленный лот 2ч ПР в ПВО_КСУ_БПП, притом группы v_Group
                      FROM (SELECT Lot2.*
                             FROM DPMWRTSUM_DBT Lot2
                            WHERE Lot2.t_Kind     = WRTSUM_KIND_RRWAB2
                              AND Lot2.t_buy_Sale = PM_WRITEOFF_SUM_BUY
                              AND Lot2.t_GroupID  = v_Group
                              AND Lot2.t_State    = PM_WRTSUM_NOTFORM
                              AND Lot2.t_Amount   > 0
                              AND Lot2.t_Party    = v_SaleLot.t_Party
                              AND Lot2.t_Contract = v_SaleLot.t_Contract
                              AND Lot2.t_DocKind  = 29 --DLDOC_PAYMENT
                              AND Lot2.t_DocID    in (select rq.t_ID
                                                        from ddlrq_dbt rq
                                                       where rq.t_FIID     = v_SaleLot.t_FIID
                                            and rq.t_PlanDate > v_SaleLot.t_Date -- сомнения. PlanDate или FactDate. Должны быть 2ч ПР за будущие даты (сегодняшние уже обработали в другом месте алгоритма и сегодня).
                                        )
                              ORDER BY Lot2.T_SUMID ASC
                           )
                      WHERE ROWNUM = 1;

                      EXCEPTION
                           WHEN OTHERS THEN
                             v_Break := TRUE;
                   END;

                   IF v_Break = FALSE THEN

                     v_Lot2Amount := v_Lot2.t_Amount; -- в лоте 2ч ПР ПВО_КСУ, группа v_Group
                     v_RestLot2Amount := v_Lot2Amount;
                     v_Amount := least(v_RestAmount, v_RestLot2Amount);
                     v_Amount := least(v_Amount, v_SaleLot.t_Amount);  -- сколько можем перевесить из поставленных
                                                                       -- лотов группы v_DestGroup вместо лотов группы
                                                                       -- v_Group по 2ч ПР, притом не более чем мы хотим списать.

                     IF v_Amount <= 0 THEN
                       v_Break := TRUE;
                     END IF;

                     IF v_Break = FALSE THEN

                       SELECT * INTO v_SourceLot -- лот 1ч ПР.
                         FROM DPMWRTSUM_DBT
                        WHERE t_SumID = v_Lot2.t_Parent;

                       SELECT MAX(LOT.T_PARTNUM) INTO v_MaxPartNum
                         FROM DPMWRTSUM_DBT LOT
                        WHERE LOT.T_DOCKIND = v_SourceLot.t_DocKind
                          AND LOT.T_DOCID   = v_SourceLot.t_DocID;

                       --Создать лот списания, выполнить списание этим лотом с портфеля ПВО_КСУ (группа v_DestGroup), лот 2ч ПР поставить.
                       v_Sale := NULL;

                       v_Sale.T_SUMID        := 0;
                       v_Sale.T_DOCKIND      := v_SourceLot.t_DocKind;
                       v_Sale.T_DOCID        := v_SourceLot.t_DocID;
                       v_Sale.T_PARTNUM      := v_MaxPartNum + 1;
                       v_Sale.T_PARTY        := v_SourceLot.t_Party; 
                       v_Sale.T_CONTRACT     := v_SourceLot.t_Contract;
                       v_Sale.T_FIID         := v_SourceLot.t_FIID;
                       v_Sale.T_GROUPID      := -1;
                       v_Sale.T_PORTFOLIO    := -1;
                       v_Sale.T_BUY_SALE     := PM_WRITEOFF_SUM_SALE; --Списание
                       v_Sale.T_KIND         := WRTSUM_KIND_MS; --Списание из портфеля
                       v_Sale.T_DATE         := v_SaleLot.t_Date;
                       v_Sale.T_TIME         := TO_DATE('01/01/0001 23/59/59','DD/MM/YYYY HH24/MI/SS');
                       v_Sale.T_AMOUNT       := v_Amount;
                       v_Sale.T_DEPARTMENT   := v_SourceLot.t_Department;
                       v_Sale.T_DEALID       := v_SourceLot.t_DealID;
                       v_Sale.T_DEALDATE     := v_SourceLot.t_DealDate;
                       v_Sale.T_DEALCODE     := v_SourceLot.t_DealCode;
                       v_Sale.T_STATE        := PM_WRTSUM_FORM;
                       v_Sale.T_ENTERDATE    := v_SaleLot.t_Date;
                       v_Sale.T_STATEDATE    := v_SaleLot.t_Date;
                       v_Sale.T_INSTANCE     := 0;
                       v_Sale.T_CHANGEDATE   := v_SaleLot.t_Date;
                       v_Sale.T_ACTION       := PM_WRT_UPDTMODE_CREATE;
                       v_Sale.T_ID_OPERATION := p_ID_Operation;
                       v_Sale.T_ID_STEP      := p_ID_Step;
                       v_Sale.T_TRUST        := CHR(0);
                       v_Sale.T_SOURCE       := v_SourceLot.t_SumID;
                       v_Sale.T_ACTIVATEDATE := v_SaleLot.t_Date;
                       -- T_ACTIVATETIME???

                       RSI_InsDfltIntoWRTSUM(v_Sale);
                       INSERT INTO DPMWRTSUM_DBT VALUES v_Sale RETURNING t_SUMID INTO v_Sale.T_SUMID;

                       v_Method := GetAmortizationMethod(v_Sale.T_PARTY, v_Sale.T_CONTRACT);

                       -- Списываем этим лотом с той группы где есть бумаги.
                       RSI_WRTLinkSaleToBuy(v_Sale, KINDPORT_BACK_KSU, v_DestGroup, NULL,
                                            v_Method, 0, p_ID_Operation, p_ID_Step, PMWRTLINK_KIND_PORTFOLIO, v_Action, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0);

                       --создать лоты 2ч ПР (ПВО_КСУ_БПП) по данным списания (по связям)

                       INSERT INTO DPMWRTSUM_DBT
                              ( T_SUMID, T_DOCKIND, T_DOCID, T_PARTNUM, T_FIID, T_PORTFOLIO, T_GROUPID, T_BUY_SALE, T_KIND, T_DATE, T_TIME, T_AMOUNT, T_AMOUNTBD, T_SUM, T_CURRENCY,
                                T_COST, T_BALANCECOST, T_BALANCECOSTBD, T_NKDAMOUNT, T_INTERESTINCOME, T_NOTCARRYINTEREST, T_INTERESTDATE, T_BEGDISCOUNT, T_DISCOUNTINCOME, T_NOTCARRYDISCOUNT,
                                T_DISCOUNTDATE, T_OUTLAY, T_OVERAMOUNT, T_OVERAMOUNTBD, T_OVERDATE, T_DEPARTMENT, T_DEALID, T_DEALDATE, T_DEALCODE, T_STATE, T_ENTERDATE, T_STATEDATE,
                                T_CHANGEDATE, T_ACTION, T_ID_OPERATION, T_ID_STEP, T_PARENT, T_SOURCE, T_COUPON, T_PARTLY, t_BegDate,
                                t_BegBonusDate, t_BegBonus, t_Bonus, t_OldBonus, t_BonusDate, T_OLDBEGDATE, T_OLDBEGDISCOUNT, T_BEGINTERESTDATE, T_BEGDISCOUNTDATE,
                                T_OLDBEGBONUS, T_RECALCDATE, T_NOTWRTBONUS, T_COSTPFI, T_ACTIVATEDATE, T_ACTIVATETIME )
                              (SELECT 0, 29, v_Lot2.t_DocID, (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                                                FROM DPMWRTSUM_DBT LOT
                                                               WHERE LOT.T_DOCKIND = 29
                                                                 AND LOT.T_DOCID   = v_Lot2.t_DocID) + ROWNUM,
                                             Lot.t_FIID, KINDPORT_BACK_BPP_KSU, Lot.T_GROUPID, PM_WRITEOFF_SUM_BUY, WRTSUM_KIND_RRWAB2,
                                             Lot.T_DATE, Lot.T_TIME, Lnk.T_AMOUNT, 0, Lnk.T_SUMBUY, Lot.T_CURRENCY, Lnk.T_COSTBUY, Lnk.T_BALANCECOSTBUY, 0, Lnk.T_NKDBUYAMOUNT,
                                             Lnk.T_INTERESTINCOMEBUY, Lnk.T_NOTCARRYINTERESTBUY, Lot.T_INTERESTDATE, Lnk.T_BEGDISCOUNTCHANGE, Lnk.T_DISCOUNTINCOMEBUY,
                                             Lnk.T_NOTCARRYDISCOUNTBUY, Lot.T_DISCOUNTDATE, Lnk.T_OUTLAYBUY, Lnk.T_OVERCHANGE, 0, Lot.T_OVERDATE, Lot.T_DEPARTMENT,
                                             Lot.T_DEALID, Lot.T_DEALDATE, Lot.T_DEALCODE, PM_WRTSUM_NOTFORM, v_Sale.T_DATE, v_Sale.T_DATE, v_Sale.T_DATE,
                                             PM_WRT_UPDTMODE_CREATE, v_Sale.T_ID_OPERATION, v_Sale.T_ID_STEP, v_Sale.t_SumID, (CASE WHEN Lot.t_Source > 0 THEN Lot.t_Source ELSE Lot.t_SumID END), chr(1), chr(1),Lot.t_BegDate,
                                             Lot.t_BegBonusDate, Lnk.t_BegBonusChange, Lnk.t_BonusBuy, Lnk.t_OldBonusBuy, Lot.t_BonusDate, Lot.t_OldBegDate,
                                             Lnk.T_OLDBEGDISCOUNTCHANGE, Lot.T_BEGINTERESTDATE, Lot.T_BEGDISCOUNTDATE,
                                             Lnk.T_OLDBEGBONUSCHANGE, Lot.T_RECALCDATE, Lnk.T_NOTWRTBONUSBUY, Lnk.t_COSTPFIBUY, UnknownDate, UnknownDate
                                        FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                                       WHERE Lot.t_SumID     = Lnk.t_BuyID
                                         AND Lnk.t_SaleID    = v_Sale.T_SUMID
                                         AND Lnk.t_Amount    > 0
                                         AND Lot.t_Portfolio = KINDPORT_BACK_KSU);

                       v_RestLot2Amount := v_RestLot2Amount - v_Amount; -- умельшаем доступное количество в текущем лоте 2ч ПР
                       v_RestAmount := v_RestAmount - v_Amount;

                       IF v_RestLot2Amount = 0 THEN -- вернули всё по лоту 2ч ПР
                         RSI_WRTSaveLot(v_Lot2.T_SUMID, p_ID_Operation, p_ID_Step, v_SaleLot.t_Date, PM_WRT_UPDTMODE_CORRECT2);

                         UPDATE DPMWRTSUM_DBT
                            SET t_State = PM_WRTSUM_FORM,
                                   t_Portfolio = KINDPORT_BACK_KSU
                          WHERE T_SUMID = v_Lot2.T_SUMID;
                       ELSE

                         SELECT NVL(MAX(LOT.T_PARTNUM), 0) INTO v_MaxPartNum
                           FROM DPMWRTSUM_DBT LOT
                          WHERE LOT.T_DOCKIND = v_Lot2.T_DOCKIND
                            AND LOT.T_DOCID = v_Lot2.T_DOCID
                            AND LOT.T_BUY_SALE = v_Lot2.T_BUY_SALE;

                         v_Lot2New := v_Lot2;
                         --v_Lot2 - Непоставленный остаток лота 2ч. Будем уменьшать.
                         --v_Lot2New - новый кусочек от лота 2ч, поставленный.

                         v_Lot2New.T_SUMID        := 0;
                         v_Lot2New.T_PARTNUM      := v_MaxPartNum + 1;
                         v_Lot2New.T_STATE        := PM_WRTSUM_FORM;
                         v_Lot2New.T_INSTANCE     := 0;
                         v_Lot2New.T_CHANGEDATE   := v_SaleLot.t_Date;
                         v_Lot2New.T_ACTION       := PM_WRT_UPDTMODE_CREATE;
                         v_Lot2New.T_ID_OPERATION := p_ID_Operation;
                         v_Lot2New.T_ID_STEP      := p_ID_Step;
                         v_Lot2New.T_Portfolio := KINDPORT_BACK_KSU;

                         RSI_WRTSaveLot(v_Lot2.T_SUMID, p_ID_Operation, p_ID_Step, v_SaleLot.t_Date, PM_WRT_UPDTMODE_CORRECT2);

                         v_OldAmount := v_Lot2.t_Amount;

                         v_Lot2.t_Amount           := v_RestLot2Amount;
                         v_Lot2.t_Sum              := round(v_Lot2.t_Sum * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_NKDAmount        := round(v_Lot2.t_NKDAmount * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_InterestIncome   := round(v_Lot2.t_InterestIncome * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_NotCarryInterest := round(v_Lot2.t_NotCarryInterest * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_BegDiscount      := round(v_Lot2.t_BegDiscount * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_BegBonus         := round(v_Lot2.t_BegBonus * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_DiscountIncome   := round(v_Lot2.t_DiscountIncome * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_NotCarryDiscount := round(v_Lot2.t_NotCarryDiscount * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_Cost             := round(v_Lot2.t_Cost * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_BalanceCost      := v_Lot2.t_Cost;
                         v_Lot2.t_COSTPFI          := round(v_Lot2.T_COSTPFI * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_ReservAmount     := round(v_Lot2.t_ReservAmount * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_IncomeReserv     := round(v_Lot2.t_IncomeReserv * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_OverAmount       := round(v_Lot2.t_OverAmount * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_Outlay           := round(v_Lot2.t_Outlay * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_DISCOUNTCORR     := round(v_Lot2.t_DISCOUNTCORR * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_OLDBEGBONUS      := round(v_Lot2.t_OLDBEGBONUS * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_Bonus            := round(v_Lot2.t_Bonus * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_OldBonus         := round(v_Lot2.t_OldBonus * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_OLDBEGDISCOUNT   := round(v_Lot2.t_OLDBEGDISCOUNT * v_RestLot2Amount / v_OldAmount, 2);
                         v_Lot2.t_NOTWRTBONUS      := round(v_Lot2.T_NOTWRTBONUS * v_RestLot2Amount / v_OldAmount, 2);

                         UPDATE DPMWRTSUM_DBT
                            SET t_Amount           = v_Lot2.t_Amount,
                                t_Sum              = v_Lot2.t_Sum,
                                t_NKDAmount        = v_Lot2.t_NKDAmount,
                                t_InterestIncome   = v_Lot2.t_InterestIncome,
                                t_NotCarryInterest = v_Lot2.t_NotCarryInterest,
                                t_BegDiscount      = v_Lot2.t_BegDiscount,
                                t_BegBonus         = v_Lot2.t_BegBonus,
                                t_DiscountIncome   = v_Lot2.t_DiscountIncome,
                                t_NotCarryDiscount = v_Lot2.t_NotCarryDiscount,
                                t_Cost             = v_Lot2.t_Cost,
                                t_BalanceCost      = v_Lot2.t_Cost,
                                t_COSTPFI          = v_Lot2.T_COSTPFI,
                                t_ReservAmount     = v_Lot2.t_ReservAmount,
                                t_IncomeReserv     = v_Lot2.t_IncomeReserv,
                                t_OverAmount       = v_Lot2.t_OverAmount,
                                t_Outlay           = v_Lot2.t_Outlay,
                                t_DISCOUNTCORR     = v_Lot2.t_DISCOUNTCORR,
                                t_OLDBEGBONUS      = v_Lot2.t_OLDBEGBONUS,
                                t_Bonus            = v_Lot2.t_Bonus,
                                t_OldBonus         = v_Lot2.t_OldBonus,
                                t_OLDBEGDISCOUNT   = v_Lot2.t_OLDBEGDISCOUNT,
                                t_NOTWRTBONUS      = v_Lot2.T_NOTWRTBONUS
                          WHERE t_SUMID = v_Lot2.T_SUMID;

                         v_Lot2New.t_Amount           := v_Lot2New.t_Amount           - v_Lot2.t_Amount;
                         v_Lot2New.t_Sum              := v_Lot2New.t_Sum              - v_Lot2.t_Sum;
                         v_Lot2New.t_NKDAmount        := v_Lot2New.t_NKDAmount        - v_Lot2.t_NKDAmount;
                         v_Lot2New.t_InterestIncome   := v_Lot2New.t_InterestIncome   - v_Lot2.t_InterestIncome;
                         v_Lot2New.t_NotCarryInterest := v_Lot2New.t_NotCarryInterest - v_Lot2.t_NotCarryInterest;
                         v_Lot2New.t_BegDiscount      := v_Lot2New.t_BegDiscount      - v_Lot2.t_BegDiscount;
                         v_Lot2New.t_BegBonus         := v_Lot2New.t_BegBonus         - v_Lot2.t_BegBonus;
                         v_Lot2New.t_DiscountIncome   := v_Lot2New.t_DiscountIncome   - v_Lot2.t_DiscountIncome;
                         v_Lot2New.t_NotCarryDiscount := v_Lot2New.t_NotCarryDiscount - v_Lot2.t_NotCarryDiscount;
                         v_Lot2New.t_Cost             := v_Lot2New.t_Cost             - v_Lot2.t_Cost;
                         v_Lot2New.t_BalanceCost      := v_Lot2New.t_BalanceCost      - v_Lot2.t_BalanceCost;
                         v_Lot2New.t_COSTPFI          := v_Lot2New.t_COSTPFI          - v_Lot2.t_COSTPFI;
                         v_Lot2New.t_ReservAmount     := v_Lot2New.t_ReservAmount     - v_Lot2.t_ReservAmount;
                         v_Lot2New.t_IncomeReserv     := v_Lot2New.t_IncomeReserv     - v_Lot2.t_IncomeReserv;
                         v_Lot2New.t_OverAmount       := v_Lot2New.t_OverAmount       - v_Lot2.t_OverAmount;
                         v_Lot2New.t_Outlay           := v_Lot2New.t_Outlay           - v_Lot2.t_Outlay;
                         v_Lot2New.t_DISCOUNTCORR     := v_Lot2New.t_DISCOUNTCORR     - v_Lot2.t_DISCOUNTCORR;
                         v_Lot2New.t_OLDBEGBONUS      := v_Lot2New.t_OLDBEGBONUS      - v_Lot2.t_OLDBEGBONUS;
                         v_Lot2New.t_Bonus            := v_Lot2New.t_Bonus            - v_Lot2.t_Bonus;
                         v_Lot2New.t_OldBonus         := v_Lot2New.t_OldBonus         - v_Lot2.t_OldBonus;
                         v_Lot2New.t_OLDBEGDISCOUNT   := v_Lot2New.t_OLDBEGDISCOUNT   - v_Lot2.t_OLDBEGDISCOUNT;
                         v_Lot2New.t_NOTWRTBONUS      := v_Lot2New.t_NOTWRTBONUS      - v_Lot2.t_NOTWRTBONUS;

                         INSERT INTO DPMWRTSUM_DBT VALUES v_Lot2New RETURNING t_SUMID INTO v_Lot2New.T_SUMID;
                       END IF;

                     END IF;

                   END IF;

                END LOOP;

                -- спишет с тех лотов, которые выше вернули для КСУ
                RSI_WRTLinkSaleToBuy(v_SaleLot, UnknownValue, v_Group, p_StartDate, v_Method,
                                 v_CheckTime, p_ID_Operation, p_ID_Step, v_LnkKind, v_Action,
                                 (v_CalcInterest     = 1 and v_CI > 0),
                                 (v_CalcDiscount     = 1 and v_CI > 0),
                                 (v_CalcBonus        = 1 and v_CI > 0),
                                 (v_CalcDefDiff      = 1 and v_CI > 0),
                                 (v_CalcCorrIntToEIR = 1 and v_CI > 0),
                                 v_CalcReserve=1,
                                 v_CalcOver
                                );

              END IF; -- КСУ

           END IF;
        END LOOP;
     end if;

     IF( v_SaleLot.t_Amount > 0 and v_SALELOT.T_KIND = WRTSUM_KIND_DI and
         v_SaleLot.t_AMOUNT <= WRTGetPortfolioAmount(v_SaleLot.t_DEPARTMENT,v_SaleLot.t_FIID,v_SaleLot.t_Party,v_SaleLot.t_Contract,KINDPORT_BACK,-1,v_SaleLot.t_Date,1,0,0)
       ) THEN

         v_SaleLot.T_AMOUNT      := 0;
         v_SaleLot.T_SUM         := 0;
         v_SaleLot.T_COST        := 0;
         v_SaleLot.T_BALANCECOST := 0;
         v_SaleLot.T_NKDAMOUNT   := 0;

         UPDATE DPMWRTSUM_DBT
            SET T_AMOUNT      = 0,
                T_SUM         = 0,
                T_COST        = 0,
                T_BALANCECOST = 0,
                T_NKDAMOUNT   = 0
          WHERE t_SumID = v_SaleLot.t_SumID;

     END IF;

     IF( v_SaleLot.t_Amount > 0 ) THEN
        IF v_SaleLot.t_Source > 0 THEN
           BEGIN
              SELECT *
                INTO v_SourceLot
                FROM dpmwrtsum_dbt
               WHERE t_sumid = v_SaleLot.t_Source;
           EXCEPTION
              WHEN OTHERS
              THEN
                 SetError( WRTOFF_ERROR_20200);
           END;

           IF( v_SourceLot.t_DealCode != ' ' ) THEN
               SetError( WRTOFF_ERROR_20208, to_char(v_SourceLot.t_DealCode) );
           ELSE
               SetError( WRTOFF_ERROR_20208, ' ');
           END IF;
        ELSE
           IF( v_SaleLot.t_DealCode != ' ' ) THEN
               SetError( WRTOFF_ERROR_20208, to_char(v_SaleLot.t_DealCode) );
           ELSE
               SetError( WRTOFF_ERROR_20208, ' ');
           END IF;
        END IF;
     END IF;

     IF( v_SaleLot.t_AmountBD > 0 ) THEN
        SetError( WRTOFF_ERROR_20215 );
     END IF;
   END;--RSI_WRTLinkSale

   ----- Откат RSI_WRTLinkSale
   PROCEDURE RSI_WRTRecoilLinkSale( p_ID_Operation IN NUMBER, -- Операция и шаг, на которых выполняется списание
                                p_ID_Step      IN NUMBER,
                                p_SaleID       IN NUMBER  -- Списываемый лот для которого выполняется откат
                              )
   IS
     v_SaleLot          DPMWRTSUM_DBT%ROWTYPE;
   BEGIN
     BEGIN
       SELECT * INTO v_SaleLot
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SaleID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     RSI_WRTRestoreLot( p_ID_Operation, p_ID_Step, PM_WRT_UPDTMODE_AVERAGE_DST, 0 );

     BEGIN
       DELETE FROM dpmwrtlnk_dbt
        WHERE     t_SaleID = p_SaleID
              AND t_ID_Operation = p_ID_Operation
              AND t_ID_Step = p_ID_Step;
     END;

   END;

   ----- Выполняет списание лота погашения в сделке ОЭБ.
   PROCEDURE RSI_WRTLinkRetireOwn( p_RetLotID     IN NUMBER, -- Списываемый лот
                                   p_ID_Operation IN NUMBER, -- Операция и шаг, на которых выполняется списание
                                   p_ID_Step      IN NUMBER
                                 )
   IS
     v_RetLot           DPMWRTSUM_DBT%ROWTYPE;
     v_LnkKind          NUMBER;
     v_Action           NUMBER;
     v_CalcInterest     NUMBER;
     v_CalcDiscount     NUMBER;
     v_CalcBonus        NUMBER;
     v_CalcDefDiff      NUMBER;
     v_CalcOutlay       NUMBER;
   BEGIN
     InitError();

     BEGIN
       SELECT * INTO v_RetLot
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_RetLotID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     IF( (v_RetLot.t_State != PM_WRTSUM_CLOSE_OWN) OR
         (v_RetLot.t_Amount = 0) ) THEN
        SetError( WRTOFF_ERROR_20206 );
     END IF;

     IF( v_RetLot.t_Kind = WRTSUM_KIND_DI ) THEN -- Погашение выпуска
        v_LnkKind      := PMWRTLINK_KIND_RETISSUE;
        v_Action       := PM_WRT_UPDTMODE_RETISSUE;
        v_CalcDiscount := WRTNeedChargeIncome (v_RetLot.t_FIID);
        v_CalcBonus    := WRTNeedChargeBonus (v_RetLot.t_FIID);
        v_CalcInterest := WRTNeedChargeInterestIncome (v_RetLot.t_FIID);
        v_CalcDefDiff  := 1;
        v_CalcOutlay   := 1;

        if( v_RetLot.t_Amount > 0 ) then
           RSI_WRTLinkRetireLotOwn( v_RetLot, UnknownDate, p_ID_Operation, p_ID_Step,
                                    v_LnkKind, v_Action,
                                    v_CalcInterest=1,
                                    v_CalcDiscount=1,
                                    v_CalcBonus=1,
                                    v_CalcDefDiff=1,
                                    v_CalcOutlay=1
                                  );
        end if;
     ELSIF( v_RetLot.t_Kind = WRTSUM_KIND_DAI ) THEN -- Погашение доп. дохода
        v_LnkKind      := PMWRTLINK_KIND_RETADDINCOME;
        v_Action       := PM_WRT_UPDTMODE_RETADDINCOME;
        v_CalcDiscount := 0;
        v_CalcBonus    := 0;
        v_CalcInterest := 0;
        v_CalcDefDiff  := 0;
        v_CalcOutlay   := 0;

        RSI_WRTLinkWrtOwn( v_RetLot, p_ID_Operation, p_ID_Step,
                           v_LnkKind, v_Action,
                           v_CalcInterest=1,
                           v_CalcDiscount=1,
                           v_CalcBonus=1,
                           v_CalcDefDiff=1,
                           v_CalcOutlay=1
                         );
     ELSIF( v_RetLot.t_Kind = WRTSUM_KIND_DC ) THEN -- Погашение купона
        v_LnkKind      := PMWRTLINK_KIND_RETCOUPON;
        v_Action       := PM_WRT_UPDTMODE_RETCOUPON;
        v_CalcDiscount := 0;
        v_CalcBonus    := 0;
        v_CalcInterest := WRTNeedChargeInterestIncome (v_RetLot.t_FIID);
        v_CalcDefDiff  := 0;
        v_CalcOutlay   := 0;

        RSI_WRTLinkWrtOwn( v_RetLot, p_ID_Operation, p_ID_Step,
                           v_LnkKind, v_Action,
                           v_CalcInterest=1,
                           v_CalcDiscount=1,
                           v_CalcBonus=1,
                           v_CalcDefDiff=1,
                           v_CalcOutlay=1
                         );
     END IF;

     IF( v_RetLot.t_Amount > 0 ) THEN
        SetError( WRTOFF_ERROR_20255 );
     END IF;
   END;--RSI_WRTLinkRetireOwn

   ----- Выполняет связывание лота выкупа с размещенными лотами.
   PROCEDURE RSI_WRTLinkRedemptionOwn( p_RdLot         IN OUT DPMWRTSUM_DBT%ROWTYPE, -- Буфер лота выкупа
                                       p_ID_Operation  IN     NUMBER, -- Операция и шаг, на которых выполняется списание
                                       p_ID_Step       IN     NUMBER
                                     )
   IS
     v_PlaceLot       DPMWRTSUM_DBT%ROWTYPE;
     v_Link           DPMWRTLNK_DBT%ROWTYPE;
     v_WrtSumTmp      DPMWRTSUM_TMP%ROWTYPE;
     v_AmountRate     NUMBER;
     v_Amount         NUMBER;
     v_TMPLNKID       NUMBER;
     v_CalcInterest   NUMBER;
     v_CalcDiscount   NUMBER;
     v_CalcBonus      NUMBER;
     v_CalcDefDiff    NUMBER;
     v_CalcOutlay     NUMBER;
     v_LnkAmount      NUMBER;
     v_CalcDate       DATE;

     TYPE LotsCurTyp IS REF CURSOR;
     Lots LotsCurTyp;

     PROCEDURE AddLotTMP(p_Lot IN DPMWRTSUM_DBT%ROWTYPE)
      IS
         v_LotTMP     DPMWRTSUM_TMP%ROWTYPE;
      BEGIN
         v_LotTMP := NULL;

         v_LotTMP.T_SUMID            := p_Lot.T_SUMID;
         v_LotTMP.T_AMOUNT           := p_Lot.T_AMOUNT;
         v_LotTMP.T_COST             := p_Lot.T_COST;
         v_LotTMP.T_BALANCECOST      := p_Lot.T_BALANCECOST;
         v_LotTMP.T_INTERESTINCOME   := p_Lot.T_INTERESTINCOME;
         v_LotTMP.T_NOTCARRYINTEREST := p_Lot.T_NOTCARRYINTEREST;
         v_LotTMP.T_INTERESTDATE     := p_Lot.T_INTERESTDATE;
         v_LotTMP.T_BEGDISCOUNTDATE  := p_Lot.T_BEGDISCOUNTDATE;
         v_LotTMP.T_BEGBONUSDATE     := p_Lot.T_BEGBONUSDATE;
         v_LotTMP.T_DISCOUNTINCOME   := p_Lot.T_DISCOUNTINCOME;
         v_LotTMP.T_NOTCARRYDISCOUNT := p_Lot.T_NOTCARRYDISCOUNT;
         v_LotTMP.T_DISCOUNTDATE     := p_Lot.T_DISCOUNTDATE;
         v_LotTMP.T_BONUS            := p_Lot.T_BONUS;
         v_LotTMP.T_BONUSDATE        := p_Lot.T_BONUSDATE;
         v_LotTMP.T_NOTWRTBONUS      := p_Lot.T_NOTWRTBONUS;
         v_LotTMP.T_ACCOUNTEDDEFDIFF := p_Lot.T_ACCOUNTEDDEFDIFF;
         v_LotTMP.T_DEFDIFFDATE      := p_Lot.T_DEFDIFFDATE;
         v_LotTMP.T_WRTOUTLAY        := p_Lot.T_WRTOUTLAY;
         v_LotTMP.T_WRTOUTLAYDATE    := p_Lot.T_WRTOUTLAYDATE;
         v_LotTMP.T_WRTVATOUTLAY     := p_Lot.T_WRTVATOUTLAY;
         v_LotTMP.T_CORRVALUE        := p_Lot.T_CORRVALUE;
         v_LotTMP.T_CORRDATE         := p_Lot.T_CORRDATE;
         v_LotTMP.T_AMORTCOST        := p_Lot.T_AMORTCOST;
         v_LotTMP.T_CORRINTTOEIR     := p_Lot.T_CORRINTTOEIR;
         v_LotTMP.T_CORRINTTOEIRDATE := p_Lot.T_CORRINTTOEIRDATE;
         v_LotTMP.T_PORTFOLIO        := p_Lot.T_PORTFOLIO;
         v_LotTMP.T_STATE            := p_Lot.T_STATE;
         v_LotTMP.T_OVERAMOUNT       := p_Lot.T_OVERAMOUNT;
         v_LotTMP.T_DEALID           := p_Lot.T_DEALID;
         v_LotTMP.T_ADDINCOMEOWN     := p_Lot.T_ADDINCOMEOWN;
         v_LotTMP.T_KIND             := 0;
         v_LotTMP.T_HEDGCORR         := p_Lot.T_HEDGCORR;
         v_LotTMP.T_HEDGCORRDATE     := p_Lot.T_HEDGCORRDATE;
         v_LotTMP.T_AMORTHEDGCORR    := p_Lot.T_AMORTHEDGCORR;
         v_LotTMP.T_AMORTHEDGCORRDATE:= p_Lot.T_AMORTHEDGCORRDATE;

         RSI_InsDfltIntoWRTSUM_TMP(v_LotTMP);

         INSERT INTO DPMWRTSUM_TMP VALUES v_LotTMP;
      END;

   BEGIN
     InitError();

     IF( p_RdLot.t_Date < RsbSessionData.curdate ) THEN

        if( WRTAreChangesAfterDateOwn( p_RdLot.t_Department,
                                       p_RdLot.T_FIID,
                                       p_RdLot.T_DATE,
                                       p_RdLot.T_TIME,
                                       p_RdLot.T_DATE
                                     ) = True ) then
           SetError( WRTOFF_ERROR_20201, to_char(p_RdLot.t_SUMID) );
        END IF;
     END IF;

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     v_Amount       := p_RdLot.T_AMOUNT;
     v_TMPLNKID     := 1;
     v_CalcDiscount := WRTNeedChargeIncome(p_RdLot.t_FIID);
     v_CalcBonus    := WRTNeedChargeBonus(p_RdLot.t_FIID);
     v_CalcDefDiff  := 1;
     v_CalcOutlay   := 1;
     v_CalcInterest := WRTNeedChargeInterestIncome (p_RdLot.t_FIID);

     WHILE( v_Amount > 0 ) LOOP

        BEGIN
          IF SortingLotsAmount = SORTING_LOTS_AMOUNT_ASC THEN
            SELECT * INTO v_PlaceLot
              FROM
              (
                SELECT /*+ INDEX( PlaceLot DPMWRTSUM_DBT_IDXA)*/ PlaceLot.*
                  FROM DPMWRTSUM_DBT PlaceLot
                 WHERE PlaceLot.t_Department = p_RdLot.t_Department AND
                       PlaceLot.t_FIID       = p_RdLot.t_FIID AND
                       PlaceLot.t_Party      = p_RdLot.t_Party AND
                       PlaceLot.t_State      = PM_WRTSUM_PLACE_OWN AND
                       (PlaceLot.t_Date < p_RdLot.t_Date OR (PlaceLot.t_Date = p_RdLot.t_Date AND PlaceLot.t_Time <= p_RdLot.t_Time)) AND
                       ((PlaceLot.T_ACTIVATEDATE < p_RdLot.T_DATE) OR ((PlaceLot.T_ACTIVATEDATE = p_RdLot.T_DATE) and (PlaceLot.T_ACTIVATETIME <= p_RdLot.T_TIME))) AND
                       PlaceLot.t_Amount    > (select NVL(SUM(TMP.T_AMOUNT),0)
                                                 from DPMWRTLNK_TMP TMP
                                                where TMP.T_BUYID = PlaceLot.T_SUMID)
                 AND NOT EXISTS (SELECT t_LnkID FROM DPMWRTLNK_DBT WHERE t_BuyID = PlaceLot.t_SumID AND t_SaleID = p_RdLot.t_SumID)
                ORDER BY t_Date ASC, t_Time ASC, T_DealDate ASC, T_SortCode ASC, T_Amount ASC
              )
             WHERE ROWNUM = 1;
           ELSE
             SELECT * INTO v_PlaceLot
              FROM
              (
                SELECT /*+ INDEX( PlaceLot DPMWRTSUM_DBT_IDXB)*/ PlaceLot.*
                  FROM DPMWRTSUM_DBT PlaceLot
                 WHERE PlaceLot.t_Department = p_RdLot.t_Department AND
                       PlaceLot.t_FIID       = p_RdLot.t_FIID AND
                       PlaceLot.t_Party      = p_RdLot.t_Party AND
                       PlaceLot.t_State      = PM_WRTSUM_PLACE_OWN AND
                       (PlaceLot.t_Date < p_RdLot.t_Date OR (PlaceLot.t_Date = p_RdLot.t_Date AND PlaceLot.t_Time <= p_RdLot.t_Time)) AND
                       ((PlaceLot.T_ACTIVATEDATE < p_RdLot.T_DATE) OR ((PlaceLot.T_ACTIVATEDATE = p_RdLot.T_DATE) and (PlaceLot.T_ACTIVATETIME <= p_RdLot.T_TIME))) AND
                       PlaceLot.t_Amount    > (select NVL(SUM(TMP.T_AMOUNT),0)
                                                 from DPMWRTLNK_TMP TMP
                                                where TMP.T_BUYID = PlaceLot.T_SUMID)
                 AND NOT EXISTS (SELECT t_LnkID FROM DPMWRTLNK_DBT WHERE t_BuyID = PlaceLot.t_SumID AND t_SaleID = p_RdLot.t_SumID)
                ORDER BY t_Date ASC, t_Time ASC, T_DealDate ASC, T_SortCode ASC, T_Amount DESC
              )
             WHERE ROWNUM = 1;
           END IF;
        EXCEPTION
           WHEN NO_DATA_FOUND THEN EXIT;--выходим именно из цикла, а не из процедуры (это важно - дальше нас ждет начисление ПДД и линковка)
           WHEN OTHERS THEN RETURN;
        END;

        AddLotTMP(v_PlaceLot);

        INSERT INTO DPMWRTLNK_TMP
                   ( T_ID,
                     T_BUYID,
                     T_AMOUNT )
            VALUES ( v_TMPLNKID,
                     v_PlaceLot.T_SUMID,
                     v_PlaceLot.T_AMOUNT
                     );

        v_Amount   := v_Amount - v_PlaceLot.T_AMOUNT;
        v_TMPLNKID := v_TMPLNKID + 1;

     END LOOP;

      v_CalcDate := p_RdLot.t_Date;

      --Выполнить начисление во временную таблицу
      --Фактически - начисление по всем лотам из DPMWRTLNK_TMP, а не по всем лотам размещения, как при начислении ПДД
      RSI_WRTChargeExpToOwnLotsTMP (true, p_RdLot.T_DATE, v_CalcDate, p_RdLot.T_FIID, p_RdLot.T_Department,
                                    v_CalcInterest=1,
                                    v_CalcDiscount=1,
                                    v_CalcBonus=1,
                                    v_CalcDefDiff=1,
                                    v_CalcOutlay=1,
                                    false,
                                    PMWRTLINK_KIND_BUYOUT,
                                    NULL,
                                    false
                                   );

     OPEN Lots FOR SELECT L.* INTO v_PLACELOT
                     FROM DPMWRTSUM_DBT L, DPMWRTLNK_TMP TMP
                    WHERE L.T_SUMID = TMP.T_BUYID
                   ORDER BY T_ID ASC;
     LOOP

        FETCH Lots INTO v_PLACELOT;
        EXIT WHEN Lots%NOTFOUND OR
                  Lots%NOTFOUND IS NULL;

       IF( v_PlaceLot.T_AMOUNT <= p_RdLot.T_AMOUNT ) THEN
          v_AmountRate := 1;
          v_LnkAmount  := v_PLACELOT.T_AMOUNT;
       ELSE
          v_AmountRate := p_RdLot.T_AMOUNT / v_PLACELOT.T_AMOUNT;
          v_LnkAmount  := p_RdLot.T_AMOUNT;
       END IF;

        v_Link.t_LnkID               := 0;
        v_Link.t_SaleID              := p_RdLot.t_SumID;
        v_Link.t_BuyID               := v_PlaceLot.t_SumID;
        v_Link.t_Kind                := PMWRTLINK_KIND_BUYOUT;
        v_Link.t_Amount              := v_LnkAmount;
        v_Link.t_SumSale             := 0;
        v_Link.t_SumBuy              := ROUND(v_PLACELOT.t_Sum * v_AmountRate,2);
        v_Link.t_CostSale            := 0;
        v_Link.t_CostBuy             := ROUND(v_PLACELOT.t_Cost * v_AmountRate,2);
        v_Link.t_BalanceCostSale     := 0;
        v_Link.t_BalanceCostBD       := 0;
        v_Link.t_NKDSaleAmount       := 0;
        v_Link.t_NKDBuyAmount        := ROUND(v_PLACELOT.t_NKDAmount * v_AmountRate,2);
        v_Link.t_InterestIncomeBuy   := ROUND(v_PLACELOT.t_INTERESTINCOME * v_AmountRate,2);
        v_Link.t_InterestIncomeAdd   := 0;
        v_Link.t_NotCarryInterestBuy := 0;
        v_Link.T_NOTCARRYINTERESTADD := 0;
        v_Link.t_BegDiscountChange   := ROUND(v_PLACELOT.t_BEGDISCOUNT * v_AmountRate,2);
        v_Link.t_OldBegDiscountChange:= 0;
        v_Link.T_DISCOUNTCORRCHANGE  := 0;
        v_Link.t_BegBonusChange      := ROUND(v_PLACELOT.t_BEGBONUS * v_AmountRate,2);
        v_Link.T_OLDBEGBONUSCHANGE   := 0;
        v_Link.t_DiscountIncomeBuy   := ROUND(v_PLACELOT.t_DISCOUNTINCOME * v_AmountRate,2);
        v_Link.t_DiscountIncomeAdd   := 0;
        v_Link.t_NotCarryDiscountBuy := 0;
        v_Link.T_NOTCARRYDISCOUNTADD := 0;
        v_Link.t_BalanceCostBuy      := 0;
        v_Link.t_BonusBuy            := ROUND(v_PLACELOT.t_BONUS * v_AmountRate,2);
        v_Link.t_OldBonusBuy         := 0;
        v_Link.t_BonusAdd            := 0;
        v_Link.t_OutlaySale          := 0;
        v_Link.t_OutlayBuy           := ROUND(v_PLACELOT.t_OUTLAY * v_AmountRate,2);
        v_Link.t_ReservChange        := 0;
        v_Link.t_IncomeReservChange  := 0;
        v_Link.t_OverChange          := 0;
        v_Link.t_OverChangeBD        := 0;
        v_Link.t_ID_Operation        := p_ID_Operation;
        v_Link.t_ID_Step             := p_ID_Step;
        v_Link.t_Action              := PM_WRT_UPDTMODE_BUYOUT;
        v_Link.t_CreateDate          := p_RdLot.t_Date;
        v_Link.T_NOTWRTBONUSBUY      := 0;
        v_Link.T_COSTPFIBUY          := 0;
        v_Link.t_BlockAmountBuy      := 0;
        v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
        v_Link.T_ACCOUNTEDDEFDIFFBUY := ROUND(v_PLACELOT.t_ACCOUNTEDDEFDIFF * v_AmountRate,2);
        v_Link.T_BEGDEFDIFFCHANGE    := ROUND(v_PLACELOT.t_BEGDEFDIFF * v_AmountRate,2);
        v_Link.T_WRTOUTLAYADD        := 0;
        v_Link.T_WRTOUTLAYBUY        := ROUND(v_PLACELOT.t_WRTOUTLAY * v_AmountRate,2);
        v_Link.T_WRTVATOUTLAYADD     := 0;
        v_Link.T_WRTVATOUTLAYBUY     := ROUND(v_PLACELOT.t_WRTVATOUTLAY * v_AmountRate,2);
        v_Link.T_VATOUTLAYCHANGE     := ROUND(v_PLACELOT.t_VATOUTLAY * v_AmountRate,2);
        v_Link.T_FAIRVALUECHANGE     := ROUND(v_PLACELOT.T_FAIRVALUE * v_AmountRate,2);
        v_Link.T_AMORTCOSTCHANGE     := ROUND(v_PLACELOT.T_AMORTCOST * v_AmountRate,2);
        v_Link.T_CORRVALUECHANGE     := ROUND(v_PLACELOT.T_CORRVALUE * v_AmountRate,2);
        v_Link.T_ESTRESERVCHANGE     := 0;
        v_Link.T_CORRESTRESERVCHANGE := 0;
        v_Link.T_CORRINTTOEIRCHANGE  := ROUND(v_PLACELOT.T_CORRINTTOEIR * v_AmountRate,2);
        v_Link.T_ADDINCOMEOWNCHANGE  := ROUND(v_PLACELOT.T_ADDINCOMEOWN * v_AmountRate,2);
        v_Link.T_HEDGCORRCHANGE      := ROUND(v_PLACELOT.T_HEDGCORR * v_AmountRate,2);
        v_Link.T_AMORTHEDGCORRCHANGE := ROUND(v_PLACELOT.T_AMORTHEDGCORR * v_AmountRate,2);

        BEGIN
          SELECT TMP.* into v_WrtSumTmp
            FROM DPMWRTSUM_TMP TMP
           WHERE TMP.T_SUMID = v_PLACELOT.T_SUMID;
        EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20254 );
        END;

        if (v_WrtSumTmp.t_Amount = 0) then
           v_Link.t_InterestIncomeAdd := 0.0;
           v_Link.t_DiscountIncomeAdd := 0.0;
           v_Link.t_BonusAdd := 0.0;
           v_Link.t_AccountedDefDiffAdd := 0.0;
           v_Link.t_WrtOutlayAdd := 0.0;
           v_Link.t_WrtVatOutlayAdd := 0.0;
        else
           v_Link.t_InterestIncomeAdd := ROUND(v_WrtSumTmp.t_INTERESTADD / v_WrtSumTmp.t_Amount * v_Link.t_Amount,2);
           v_Link.t_DiscountIncomeAdd := ROUND(v_WrtSumTmp.t_DISCOUNTADD / v_WrtSumTmp.t_Amount * v_Link.t_Amount,2);
           v_Link.t_BonusAdd := ROUND(v_WrtSumTmp.t_BONUSADD / v_WrtSumTmp.t_Amount * v_Link.t_Amount,2);
           v_Link.t_AccountedDefDiffAdd := ROUND(v_WrtSumTmp.t_DEFDIFFADD / v_WrtSumTmp.t_Amount * v_Link.t_Amount,2);
           v_Link.t_WrtOutlayAdd := ROUND(v_WrtSumTmp.t_WRTOUTLAYADD / v_WrtSumTmp.t_Amount * v_Link.t_Amount,2);
           v_Link.t_WrtVatOutlayAdd := ROUND(v_WrtSumTmp.t_VATOUTLAYADD / v_WrtSumTmp.t_Amount * v_Link.t_Amount,2);
        end if;

        BEGIN
           RSI_InsDfltIntoWRTLNK(v_Link);
           INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

           p_RdLot.t_Amount      := p_RdLot.t_Amount    - v_Link.t_Amount;
        END;
     END LOOP;

     CLOSE Lots;

     --Для всех лотов по данной бумаге, где есть начисленная корректировка хеджирования, перенсем её в корректировку к амортизации
     UPDATE DPMWRTSUM_DBT
        SET T_AMORTHEDGCORR = T_AMORTHEDGCORR + T_HEDGCORR,
            T_AMORTHEDGCORRDATE = GREATEST(T_HEDGCORRDATE, T_AMORTHEDGCORRDATE),
            T_HEDGCORR = 0
      WHERE T_FIID = p_RdLot.t_FIID
        AND T_DEPARTMENT = p_RdLot.t_Department
        AND T_PARTY = -1
        AND T_HEDGCORR <> 0;

   END;--RSI_WRTLinkRedemptionOwn

   ----- Процедура распределения сумм с нулевых связей при создании лотов по второй части Прямого РЕПО, по портфелю
   PROCEDURE CorrectLotsFromLinkByPortfolio( p_SaleID IN NUMBER, p_Portfolio IN NUMBER )
   IS
     v_Count        NUMBER;
     v_All          DPMWRTBC_DBT%ROWTYPE;
     v_Rest         DPMWRTBC_DBT%ROWTYPE;
     v_CountInPort  NUMBER;
     v_AmountInPort NUMBER;
     v_LotNumber    NUMBER;

     CURSOR cLots2PR IS SELECT Lot.*
                          FROM DPMWRTSUM_DBT Lot
                         WHERE T_PARENT = p_SaleID
                           AND T_PORTFOLIO = p_Portfolio
                         ORDER BY T_AMOUNT;

   BEGIN
      --v_All - то, что нужно распределить
      BEGIN
        SELECT Count(1),
               NVL(SUM(Lnk.T_SUMBUY             ),0),
               NVL(SUM(Lnk.T_COSTBUY            ),0),
               NVL(SUM(Lnk.T_BALANCECOSTBUY     ),0),
               NVL(SUM(Lnk.T_NKDBUYAMOUNT       ),0),
               NVL(SUM(Lnk.T_INTERESTINCOMEBUY  ),0),
               NVL(SUM(Lnk.T_DISCOUNTINCOMEBUY  ),0),
               NVL(SUM(Lnk.T_OUTLAYBUY          ),0),
               NVL(SUM(Lnk.T_OVERCHANGE         ),0),
               NVL(SUM(Lnk.t_BonusBuy           ),0),
               NVL(SUM(Lnk.t_OldBonusBuy        ),0),
               NVL(SUM(Lnk.t_ACCOUNTEDDEFDIFFBUY),0),
               NVL(SUM(Lnk.t_CORRVALUECHANGE    ),0),
               NVL(SUM(Lnk.t_CORRINTTOEIRCHANGE ),0),
               NVL(SUM(Lnk.t_BEGBONUSCHANGE     ),0),
               NVL(SUM(Lnk.t_BEGDISCOUNTCHANGE  ),0),
               NVL(SUM(Lnk.t_HEDGCORRCHANGE     ),0),
               NVL(SUM(Lnk.t_AMORTHEDGCORRCHANGE),0)
          INTO v_Count,
               v_All.t_SUM             ,
               v_All.t_COST            ,
               v_All.t_BALANCECOST     ,
               v_All.t_NKDAMOUNT       ,
               v_All.t_INTERESTINCOME  ,
               v_All.t_DISCOUNTINCOME  ,
               v_All.t_OUTLAY          ,
               v_All.t_OVERAMOUNT      ,
               v_All.t_Bonus           ,
               v_All.t_OldBonus        ,
               v_All.t_AccountedDefDiff,
               v_All.t_CorrValue       ,
               v_All.t_CorrIntToEIR    ,
               v_All.t_BegBonus        ,
               v_All.t_BegDiscount     ,
               v_All.t_HedgCorr        ,
               v_All.t_AmortHedgCorr
          FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
         WHERE Lot.t_SumID     = Lnk.t_BuyID
           AND Lnk.t_SaleID    = p_SaleID
           AND Lnk.t_Amount    = 0
           AND Lot.t_Portfolio = p_Portfolio;
      END;

      -- Если вообще что-то ушло в это РЕПО из этого портфеля
      IF v_Count > 0 THEN
         SELECT Count(1),
                NVL(SUM(T_AMOUNT),0)
           INTO v_CountInPort,
                v_AmountInPort
           FROM DPMWRTSUM_DBT
          WHERE T_PARENT = p_SaleID
            AND T_PORTFOLIO = p_Portfolio;

         -- Просто занести на этот 1 лот, без всяких распределений. Из этого портфеля в этом РЕПО только 1 ненулевой лот.
         IF v_CountInPort = 1 THEN
            UPDATE DPMWRTSUM_DBT
               SET t_SUM              = t_SUM              + v_All.t_SUM             ,
                   t_COST             = t_COST             + v_All.t_COST            ,
                   t_BALANCECOST      = t_BALANCECOST      + v_All.t_BALANCECOST     ,
                   t_NKDAMOUNT        = t_NKDAMOUNT        + v_All.t_NKDAMOUNT       ,
                   t_INTERESTINCOME   = t_INTERESTINCOME   + v_All.t_INTERESTINCOME  ,
                   t_DISCOUNTINCOME   = t_DISCOUNTINCOME   + v_All.t_DISCOUNTINCOME  ,
                   t_OUTLAY           = t_OUTLAY           + v_All.t_OUTLAY          ,
                   t_OVERAMOUNT       = t_OVERAMOUNT       + v_All.t_OVERAMOUNT      ,
                   t_Bonus            = t_Bonus            + v_All.t_Bonus           ,
                   t_OldBonus         = t_OldBonus         + v_All.t_OldBonus        ,
                   t_AccountedDefDiff = t_AccountedDefDiff + v_All.t_AccountedDefDiff,
                   t_CorrValue        = t_CorrValue        + v_All.t_CorrValue       ,
                   t_CorrIntToEIR     = t_CorrIntToEIR     + v_All.t_CorrIntToEIR    ,
                   t_BegBonus         = t_BegBonus         + v_All.t_BegBonus        ,
                   t_BegDiscount      = t_BegDiscount      + v_All.t_BegDiscount     ,
                   t_HedgCorr         = t_HedgCorr         + v_All.t_HedgCorr        ,
                   t_AmortHedgCorr    = t_AmortHedgCorr    + v_All.t_AmortHedgCorr
             WHERE T_PARENT = p_SaleID
               AND T_PORTFOLIO = p_Portfolio;

         -- Считаем пропорционально кол-ву в лотах 2ч ПР.
         ELSIF v_CountInPort > 1 THEN

            v_Rest.t_SUM              := v_All.t_SUM             ;
            v_Rest.t_COST             := v_All.t_COST            ;
            v_Rest.t_BALANCECOST      := v_All.t_BALANCECOST     ;
            v_Rest.t_NKDAMOUNT        := v_All.t_NKDAMOUNT       ;
            v_Rest.t_INTERESTINCOME   := v_All.t_INTERESTINCOME  ;
            v_Rest.t_DISCOUNTINCOME   := v_All.t_DISCOUNTINCOME  ;
            v_Rest.t_OUTLAY           := v_All.t_OUTLAY          ;
            v_Rest.t_OVERAMOUNT       := v_All.t_OVERAMOUNT      ;
            v_Rest.t_Bonus            := v_All.t_Bonus           ;
            v_Rest.t_OldBonus         := v_All.t_OldBonus        ;
            v_Rest.t_AccountedDefDiff := v_All.t_AccountedDefDiff;
            v_Rest.t_CorrValue        := v_All.t_CorrValue       ;
            v_Rest.t_CorrIntToEIR     := v_All.t_CorrIntToEIR    ;
            v_Rest.t_BegBonus         := v_All.t_BegBonus        ;
            v_Rest.t_BegDiscount      := v_All.t_BegDiscount     ;
            v_Rest.t_HedgCorr         := v_All.t_HedgCorr        ;
            v_Rest.t_AmortHedgCorr    := v_All.t_AmortHedgCorr   ;

            -- Номер текущего распределяемого лота.
            v_LotNumber := 0;

            -- Цикл по всем лотам 2ч этого же РЕПО
            FOR Lots2PR IN cLots2PR LOOP
               v_LotNumber := v_LotNumber + 1;

               -- в последний лот спишем все остатки
               IF v_LotNumber = v_CountInPort THEN
                  UPDATE DPMWRTSUM_DBT
                     SET t_SUM              = t_SUM              + v_Rest.t_SUM             ,
                         t_COST             = t_COST             + v_Rest.t_COST            ,
                         t_BALANCECOST      = t_BALANCECOST      + v_Rest.t_BALANCECOST     ,
                         t_NKDAMOUNT        = t_NKDAMOUNT        + v_Rest.t_NKDAMOUNT       ,
                         t_INTERESTINCOME   = t_INTERESTINCOME   + v_Rest.t_INTERESTINCOME  ,
                         t_DISCOUNTINCOME   = t_DISCOUNTINCOME   + v_Rest.t_DISCOUNTINCOME  ,
                         t_OUTLAY           = t_OUTLAY           + v_Rest.t_OUTLAY          ,
                         t_OVERAMOUNT       = t_OVERAMOUNT       + v_Rest.t_OVERAMOUNT      ,
                         t_Bonus            = t_Bonus            + v_Rest.t_Bonus           ,
                         t_OldBonus         = t_OldBonus         + v_Rest.t_OldBonus        ,
                         t_AccountedDefDiff = t_AccountedDefDiff + v_Rest.t_AccountedDefDiff,
                         t_CorrValue        = t_CorrValue        + v_Rest.t_CorrValue       ,
                         t_CorrIntToEIR     = t_CorrIntToEIR     + v_Rest.t_CorrIntToEIR    ,
                         t_BegBonus         = t_BegBonus         + v_Rest.t_BegBonus        ,
                         t_BegDiscount      = t_BegDiscount      + v_Rest.t_BegDiscount     ,
                         t_HedgCorr         = t_HedgCorr         + v_Rest.t_HedgCorr        ,
                         t_AmortHedgCorr    = t_AmortHedgCorr    + v_Rest.t_AmortHedgCorr
                   WHERE T_SUMID = Lots2PR.t_SUMID;
               ELSE
                  --Распределим пропорционально кол-вам в лотах.
                  UPDATE DPMWRTSUM_DBT
                     SET t_SUM              = t_SUM              + ROUND(v_All.t_SUM              * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_COST             = t_COST             + ROUND(v_All.t_COST             * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_BALANCECOST      = t_BALANCECOST      + ROUND(v_All.t_BALANCECOST      * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_NKDAMOUNT        = t_NKDAMOUNT        + ROUND(v_All.t_NKDAMOUNT        * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_INTERESTINCOME   = t_INTERESTINCOME   + ROUND(v_All.t_INTERESTINCOME   * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_DISCOUNTINCOME   = t_DISCOUNTINCOME   + ROUND(v_All.t_DISCOUNTINCOME   * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_OUTLAY           = t_OUTLAY           + ROUND(v_All.t_OUTLAY           * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_OVERAMOUNT       = t_OVERAMOUNT       + ROUND(v_All.t_OVERAMOUNT       * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_Bonus            = t_Bonus            + ROUND(v_All.t_Bonus            * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_OldBonus         = t_OldBonus         + ROUND(v_All.t_OldBonus         * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_AccountedDefDiff = t_AccountedDefDiff + ROUND(v_All.t_AccountedDefDiff * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_CorrValue        = t_CorrValue        + ROUND(v_All.t_CorrValue        * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_CorrIntToEIR     = t_CorrIntToEIR     + ROUND(v_All.t_CorrIntToEIR     * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_BegBonus         = t_BegBonus         + ROUND(v_All.t_BegBonus         * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_BegDiscount      = t_BegDiscount      + ROUND(v_All.t_BegDiscount      * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_HedgCorr         = t_HedgCorr         + ROUND(v_All.t_HedgCorr         * Lots2PR.t_Amount / v_AmountInPort, 2),
                         t_AmortHedgCorr    = t_AmortHedgCorr    + ROUND(v_All.t_AmortHedgCorr    * Lots2PR.t_Amount / v_AmountInPort, 2)
                   WHERE T_SUMID = Lots2PR.t_SUMID;

                  v_Rest.t_SUM              := v_Rest.t_SUM              - ROUND(v_All.t_SUM              * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_COST             := v_Rest.t_COST             - ROUND(v_All.t_COST             * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_BALANCECOST      := v_Rest.t_BALANCECOST      - ROUND(v_All.t_BALANCECOST      * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_NKDAMOUNT        := v_Rest.t_NKDAMOUNT        - ROUND(v_All.t_NKDAMOUNT        * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_INTERESTINCOME   := v_Rest.t_INTERESTINCOME   - ROUND(v_All.t_INTERESTINCOME   * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_DISCOUNTINCOME   := v_Rest.t_DISCOUNTINCOME   - ROUND(v_All.t_DISCOUNTINCOME   * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_OUTLAY           := v_Rest.t_OUTLAY           - ROUND(v_All.t_OUTLAY           * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_OVERAMOUNT       := v_Rest.t_OVERAMOUNT       - ROUND(v_All.t_OVERAMOUNT       * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_Bonus            := v_Rest.t_Bonus            - ROUND(v_All.t_Bonus            * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_OldBonus         := v_Rest.t_OldBonus         - ROUND(v_All.t_OldBonus         * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_AccountedDefDiff := v_Rest.t_AccountedDefDiff - ROUND(v_All.t_AccountedDefDiff * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_CorrValue        := v_Rest.t_CorrValue        - ROUND(v_All.t_CorrValue        * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_CorrIntToEIR     := v_Rest.t_CorrIntToEIR     - ROUND(v_All.t_CorrIntToEIR     * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_BegBonus         := v_Rest.t_BegBonus         - ROUND(v_All.t_BegBonus         * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_BegDiscount      := v_Rest.t_BegDiscount      - ROUND(v_All.t_BegDiscount      * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_HedgCorr         := v_Rest.t_HedgCorr         - ROUND(v_All.t_HedgCorr         * Lots2PR.t_Amount / v_AmountInPort, 2);
                  v_Rest.t_AmortHedgCorr    := v_Rest.t_AmortHedgCorr    - ROUND(v_All.t_AmortHedgCorr    * Lots2PR.t_Amount / v_AmountInPort, 2);
               END IF;
            END LOOP;
         END IF;
      END IF;
   END; --CorrectLotsFromLinkByPortfolio

   --Получить группу списания по портфелю
   FUNCTION RSI_GetWrtoffGroupByPortfolio(p_Portfolio IN NUMBER, p_IsAvrWrt IN NUMBER DEFAULT 0) RETURN NUMBER
   AS
     v_Group NUMBER;
   BEGIN

     v_Group := KINDPORT_UNDEF;

     IF p_Portfolio = KINDPORT_CLIENT THEN
       v_Group := KINDPORT_CLIENT;
     ELSIF p_Portfolio = KINDPORT_TRADE THEN
       v_Group := KINDPORT_TRADE;
     ELSIF p_Portfolio = KINDPORT_SALE THEN
       v_Group := KINDPORT_SALE;
     ELSIF p_Portfolio = KINDPORT_CONTR THEN
       v_Group := KINDPORT_CONTR;
     ELSIF p_Portfolio = KINDPORT_PROMISSORY THEN
       v_Group := KINDPORT_PROMISSORY;
     ELSIF p_Portfolio = KINDPORT_RETIRE THEN
       v_Group := KINDPORT_RETIRE;
     ELSIF p_Portfolio = KINDPORT_BACK THEN
       v_Group := KINDPORT_BACK;
     ELSIF p_Portfolio = KINDPORT_TRUST THEN
       v_Group := KINDPORT_TRUST;
     ELSIF p_Portfolio = KINDPORT_BASICDEBT THEN
       v_Group := KINDPORT_BASICDEBT;
     ELSIF p_Portfolio = KINDPORT_BACK_KSU THEN
       IF p_IsAvrWrt = 1 THEN
          v_Group := KINDPORT_KSU;
       ELSE
          v_Group := KINDPORT_BACK_KSU;
       END IF;
     END IF;

     RETURN v_Group;
   END;

   ----- Процедура создания лотов по второй части Прямого РЕПО
   PROCEDURE RSI_WRTCreateLotsFromLink( p_SaleID       IN NUMBER,
                                        p_RQID    IN NUMBER, -- ТО по второй части
                                        p_IsOneDayREPO IN NUMBER
                                      )
   IS
     v_SaleLot     DPMWRTSUM_DBT%ROWTYPE;
     v_RQ          DDLRQ_DBT%ROWTYPE;
     v_CountTP     NUMBER;
     v_CountPVO    NUMBER;
     v_CountPVOKSU NUMBER;
     v_CountTP0    NUMBER;
     v_CountCLNT   NUMBER;
     v_AmortizationMethod NUMBER;
     v_BEGDISCOUNTCHANGE0    NUMBER;
     v_BegBonusChange0       NUMBER;
     v_OLDBEGDISCOUNTCHANGE0 NUMBER;
     v_OLDBEGBONUSCHANGE0    NUMBER;

     v_SumID NUMBER;
     v_Lot     DPMWRTSUM_DBT%ROWTYPE;
     v_Leg2    DDL_LEG_DBT%ROWTYPE;

     v_Sum       NUMBER;
     v_Cost      NUMBER;
     v_NKDAmount NUMBER;
     v_Portfolio NUMBER;
     v_GroupID   NUMBER;
     v_BegDiscount NUMBER;
     v_BegBonus    NUMBER;

     v_FaceValueFI NUMBER;

     v_ExistNOSS NUMBER;

     v_NeedChargeInterestIncome NUMBER;
     v_NeedChargeIncome NUMBER;

     v_State NUMBER;
     v_Action NUMBER;

     v_AvoirKind NUMBER;

     v_ActivateDate DATE := UnknownDate;
     v_ActivateTime DATE := UnknownDate;

     v_LnksAmount     NUMBER;
     v_CostPFIBuy     NUMBER;
     v_RestCostPFIBuy NUMBER;
     v_RestAmount     NUMBER;
     v_AddCostPFI     NUMBER;

   BEGIN

     BEGIN
       SELECT * INTO v_SaleLot
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SaleID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     BEGIN
       SELECT * INTO v_RQ
         FROM DDLRQ_DBT
        WHERE t_ID = p_RQID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20216 );
     END;

     BEGIN
       SELECT COUNT(1) INTO v_CountTP
         FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
        WHERE     Lot.t_SumID     = Lnk.t_BuyID
              AND Lnk.t_SaleID    = p_SaleID
              AND Lot.t_Portfolio in (KINDPORT_TRADE, KINDPORT_SALE, KINDPORT_RETIRE, KINDPORT_CONTR);
     END;

     BEGIN
       SELECT COUNT(1) INTO v_CountPVO
         FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
        WHERE     Lot.t_SumID     = Lnk.t_BuyID
              AND Lnk.t_SaleID    = p_SaleID
              AND Lot.t_Portfolio = KINDPORT_BACK;
     END;

     BEGIN
       SELECT COUNT(1) INTO v_CountPVOKSU
         FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
        WHERE     Lot.t_SumID     = Lnk.t_BuyID
              AND Lnk.t_SaleID    = p_SaleID
              AND Lot.t_Portfolio = KINDPORT_BACK_KSU;
     END;

     BEGIN
       SELECT COUNT(1) INTO v_CountCLNT
         FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
        WHERE     Lot.t_SumID     = Lnk.t_BuyID
              AND Lnk.t_SaleID    = p_SaleID
              AND Lot.t_Portfolio = KINDPORT_CLIENT;
     END;

     SELECT * INTO v_Leg2
       FROM DDL_LEG_DBT LEG2
      WHERE LEG2.T_LEGKIND = 2
        AND LEG2.T_DEALID = v_Rq.T_DOCID
        AND LEG2.T_LEGID = 0;

     SELECT FIN.T_FACEVALUEFI, FIN.t_AvoirKind INTO v_FaceValueFI, v_AvoirKind
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID =  v_rq.T_FIID;

     v_AmortizationMethod := GetAmortizationMethod( v_SaleLot.t_Party, v_SaleLot.t_Contract );

     ---- Нужно только для ТП и ППР
     IF( v_CountTP > 0 OR v_CountPVOKSU > 0 OR (v_CountPVO > 0 AND v_SaleLot.t_Date >= NewRepoDate())) THEN
        v_SumID := 0;
        BEGIN
          IF v_CountTP > 0 THEN
            IF p_IsOneDayREPO = 1 THEN
              v_State  := PM_WRTSUM_FORM;
              v_Action := PM_WRT_UPDTMODE_DELIVERY;
              v_ActivateDate := v_RQ.t_FactDate;
              v_ActivateTime := v_Leg2.t_SUPPLYTIME;
            ELSE
              if (p_IsOneDayREPO = 0) then
                v_State  := PM_WRTSUM_SALE_BPP;
              else
                v_State := PM_WRTSUM_NOTFORM;
              end if;
              v_Action := PM_WRT_UPDTMODE_DELIVERYBPP;
            END IF;

            INSERT INTO DPMWRTSUM_DBT
                   ( T_SUMID, T_DOCKIND, T_DOCID, T_PARTNUM, T_FIID, T_PORTFOLIO, T_GROUPID, T_BUY_SALE, T_KIND, T_DATE, T_TIME, T_AMOUNT, T_SUM, T_CURRENCY,
                     T_COST, T_BALANCECOST, T_NKDAMOUNT, T_INTERESTINCOME, T_NOTCARRYINTEREST, T_INTERESTDATE, T_BEGDISCOUNT, T_DISCOUNTINCOME, T_NOTCARRYDISCOUNT,
                     T_DISCOUNTDATE, T_OUTLAY, T_OVERAMOUNT, T_OVERDATE, T_DEPARTMENT, T_DEALID, T_DEALDATE, T_DEALCODE, T_STATE, T_ENTERDATE, T_STATEDATE,
                     T_CHANGEDATE, T_ACTION, T_ID_OPERATION, T_ID_STEP, T_PARENT, T_SOURCE, T_COUPON, T_PARTLY, t_BegDate,
                     t_BegBonusDate, t_BegBonus, t_Bonus, t_OldBonus, t_BonusDate, T_OLDBEGDATE, T_OLDBEGDISCOUNT, T_BEGINTERESTDATE, T_BEGDISCOUNTDATE,
                     T_OLDBEGBONUS, T_RECALCDATE, T_NOTWRTBONUS, T_COSTPFI, T_ACTIVATEDATE, T_ACTIVATETIME, T_BLOCKAMOUNT,
                     T_BEGDEFDIFF, T_ACCOUNTEDDEFDIFF, T_DEFDIFFDATE, T_WRTOUTLAY, T_WRTOUTLAYDATE, T_VATOUTLAY, T_WRTVATOUTLAY, T_EFFECTINTERESTRATE,
                     T_FAIRVALUE, T_AMORTCOST, T_AMORTCOSTDATE, T_CORRVALUE, T_CORRDATE,
                     T_ACCFI, T_ACCBALANCECOST,
                     T_AMORTCALCKIND, T_ESTRESERVE, T_ESTRESERVEDATE, T_CORRINTTOEIR, T_CORRINTTOEIRDATE, T_CORRESTRESERVE, T_CORRESTRESERVEDATE, 
                     T_BEGDEFDIFFDATE, T_HEDGCORR, T_HEDGCORRDATE, T_AMORTHEDGCORR, T_AMORTHEDGCORRDATE
                   )
                   (SELECT 0, 29, v_RQ.t_ID, (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                               FROM DPMWRTSUM_DBT LOT
                                              WHERE LOT.T_DOCKIND = 29
                                                AND LOT.T_DOCID   = v_RQ.t_ID) + ROWNUM,
                                  Lot.t_FIID, Lot.T_PORTFOLIO, Lot.T_GROUPID, PM_WRITEOFF_SUM_BUY, WRTSUM_KIND_RRWAB2,
                                  Lot.T_DATE, Lot.T_TIME, Lnk.T_AMOUNT, Lnk.T_SUMBUY, Lot.T_CURRENCY, Lnk.T_COSTBUY, Lnk.T_BALANCECOSTBUY, Lnk.T_NKDBUYAMOUNT,
                                  Lnk.T_INTERESTINCOMEBUY, Lnk.T_NOTCARRYINTERESTBUY, Lot.T_INTERESTDATE, Lnk.T_BEGDISCOUNTCHANGE, Lnk.T_DISCOUNTINCOMEBUY,
                                  Lnk.T_NOTCARRYDISCOUNTBUY, Lot.T_DISCOUNTDATE, Lnk.T_OUTLAYBUY, Lnk.T_OVERCHANGE, Lot.T_OVERDATE, Lot.T_DEPARTMENT,
                                  Lot.T_DEALID, Lot.T_DEALDATE, Lot.T_DEALCODE, v_State, v_SaleLot.T_DATE, v_SaleLot.T_DATE, v_SaleLot.T_DATE,
                                  v_Action, v_SaleLot.T_ID_OPERATION, v_SaleLot.T_ID_STEP, v_SaleLot.t_SumID, Lot.t_SumID, chr(1), chr(1),Lot.t_BegDate,
                                  Lot.t_BegBonusDate, Lnk.t_BegBonusChange, Lnk.t_BonusBuy, Lnk.t_OldBonusBuy, Lot.t_BonusDate, Lot.t_OldBegDate,
                                  Lnk.T_OLDBEGDISCOUNTCHANGE, Lot.T_BEGINTERESTDATE, Lot.T_BEGDISCOUNTDATE,
                                  Lnk.T_OLDBEGBONUSCHANGE, Lot.T_RECALCDATE, Lnk.T_NOTWRTBONUSBUY, Lnk.t_COSTPFIBUY, v_ActivateDate, v_ActivateTime, Lnk.T_BLOCKAMOUNTBUY,
                                  Lnk.T_BEGDEFDIFFCHANGE, Lnk.T_ACCOUNTEDDEFDIFFBUY, Lot.T_DEFDIFFDATE, Lnk.T_WRTOUTLAYBUY, Lot.T_WRTOUTLAYDATE, Lnk.T_WRTVATOUTLAYBUY,
                                  Lot.T_WRTVATOUTLAY, Lot.T_EFFECTINTERESTRATE, Lnk.T_FAIRVALUECHANGE, Lnk.T_AMORTCOSTCHANGE, Lot.T_AMORTCOSTDATE, Lnk.T_CORRVALUECHANGE, Lot.T_CORRDATE,
                                  WRTDetermineAccFI(Lot.t_FIID),
                                  case when WRTDetermineAccFI(Lot.t_FIID) = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( Lnk.T_BALANCECOSTBUY, v_FaceValueFI, WRTDetermineAccFI(Lot.t_FIID), Lot.T_DATE, 1 ),2),0) end,
                                  Lot.T_AMORTCALCKIND, Lnk.T_ESTRESERVCHANGE, Lot.T_ESTRESERVEDATE, Lnk.T_CORRINTTOEIRCHANGE, Lot.T_CORRINTTOEIRDATE, Lnk.T_CORRESTRESERVCHANGE, Lot.T_CORRESTRESERVEDATE,
                                  Lot.t_BegDefDiffDate, Lnk.T_HEDGCORRCHANGE, Lot.t_HEDGCORRDATE, Lnk.T_AMORTHEDGCORRCHANGE, Lot.t_AMORTHEDGCORRDATE
                             FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                            WHERE     Lot.t_SumID     = Lnk.t_BuyID
                                  AND Lnk.t_SaleID    = p_SaleID
                                  AND Lnk.t_Amount    > 0
                                  AND Lot.t_Portfolio in (KINDPORT_TRADE, KINDPORT_SALE, KINDPORT_RETIRE, KINDPORT_CONTR));
          END IF;

          IF (v_CountPVO > 0 AND v_SaleLot.t_Date >= NewRepoDate()) THEN

            INSERT INTO DPMWRTSUM_DBT
                   ( T_SUMID, T_DOCKIND, T_DOCID, T_PARTNUM, T_FIID, T_PORTFOLIO, T_GROUPID, T_BUY_SALE, T_KIND, T_DATE, T_TIME, T_AMOUNT, T_AMOUNTBD, T_SUM, T_CURRENCY,
                     T_COST, T_BALANCECOST, T_BALANCECOSTBD, T_NKDAMOUNT, T_INTERESTINCOME, T_NOTCARRYINTEREST, T_INTERESTDATE, T_BEGDISCOUNT, T_DISCOUNTINCOME, T_NOTCARRYDISCOUNT,
                     T_DISCOUNTDATE, T_OUTLAY, T_OVERAMOUNT, T_OVERAMOUNTBD, T_OVERDATE, T_DEPARTMENT, T_DEALID, T_DEALDATE, T_DEALCODE, T_STATE, T_ENTERDATE, T_STATEDATE,
                     T_CHANGEDATE, T_ACTION, T_ID_OPERATION, T_ID_STEP, T_PARENT, T_SOURCE, T_COUPON, T_PARTLY, t_BegDate,
                     t_BegBonusDate, t_BegBonus, t_Bonus, t_OldBonus, t_BonusDate, T_OLDBEGDATE, T_OLDBEGDISCOUNT, T_BEGINTERESTDATE, T_BEGDISCOUNTDATE,
                     T_OLDBEGBONUS, T_RECALCDATE, T_NOTWRTBONUS, T_COSTPFI, T_ACTIVATEDATE, T_ACTIVATETIME, T_BLOCKAMOUNT,
                     T_BEGDEFDIFF, T_ACCOUNTEDDEFDIFF, T_DEFDIFFDATE, T_WRTOUTLAY, T_WRTOUTLAYDATE, T_VATOUTLAY, T_WRTVATOUTLAY, T_EFFECTINTERESTRATE,
                     T_FAIRVALUE, T_AMORTCOST, T_AMORTCOSTDATE, T_CORRVALUE, T_CORRDATE,
                     T_ACCFI, T_ACCBALANCECOST,
                     T_AMORTCALCKIND, T_ESTRESERVE, T_ESTRESERVEDATE, T_CORRINTTOEIR, T_CORRINTTOEIRDATE, T_CORRESTRESERVE, T_CORRESTRESERVEDATE,
                     T_BEGDEFDIFFDATE, T_HEDGCORR, T_HEDGCORRDATE, T_AMORTHEDGCORR, T_AMORTHEDGCORRDATE
                   )
                   (SELECT 0, 29, v_RQ.t_ID, (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                               FROM DPMWRTSUM_DBT LOT
                                              WHERE LOT.T_DOCKIND = 29
                                                AND LOT.T_DOCID   = v_RQ.t_ID) + ROWNUM,
                                  Lot.t_FIID, KINDPORT_BASICDEBT, Lot.T_GROUPID, PM_WRITEOFF_SUM_BUY, WRTSUM_KIND_RRWAB2,
                                  Lot.T_DATE, Lot.T_TIME, Lnk.T_AMOUNT, 0, Lnk.T_SUMBUY, Lot.T_CURRENCY, Lnk.T_COSTBUY, Lnk.T_BALANCECOSTBUY, 0, Lnk.T_NKDBUYAMOUNT,
                                  Lnk.T_INTERESTINCOMEBUY, Lnk.T_NOTCARRYINTERESTBUY, Lot.T_INTERESTDATE, Lnk.T_BEGDISCOUNTCHANGE, Lnk.T_DISCOUNTINCOMEBUY,
                                  Lnk.T_NOTCARRYDISCOUNTBUY, Lot.T_DISCOUNTDATE, Lnk.T_OUTLAYBUY, Lnk.T_OVERCHANGE, 0, Lot.T_OVERDATE, Lot.T_DEPARTMENT,
                                  Lot.T_DEALID, Lot.T_DEALDATE, Lot.T_DEALCODE, PM_WRTSUM_NOTFORM, v_SaleLot.T_DATE, v_SaleLot.T_DATE, v_SaleLot.T_DATE,
                                  PM_WRT_UPDTMODE_CREATE, v_SaleLot.T_ID_OPERATION, v_SaleLot.T_ID_STEP, v_SaleLot.t_SumID, (CASE WHEN Lot.t_Source > 0 THEN Lot.t_Source ELSE Lot.t_SumID END), chr(1), chr(1),Lot.t_BegDate,
                                  Lot.t_BegBonusDate, Lnk.t_BegBonusChange, Lnk.t_BonusBuy, Lnk.t_OldBonusBuy, Lot.t_BonusDate, Lot.t_OldBegDate,
                                  Lnk.T_OLDBEGDISCOUNTCHANGE, Lot.T_BEGINTERESTDATE, Lot.T_BEGDISCOUNTDATE,
                                  Lnk.T_OLDBEGBONUSCHANGE, Lot.T_RECALCDATE, Lnk.T_NOTWRTBONUSBUY, Lnk.t_COSTPFIBUY, v_ActivateDate, v_ActivateTime, Lnk.T_BLOCKAMOUNTBUY,
                                  Lnk.T_BEGDEFDIFFCHANGE, Lnk.T_ACCOUNTEDDEFDIFFBUY, Lot.T_DEFDIFFDATE, Lnk.T_WRTOUTLAYBUY, Lot.T_WRTOUTLAYDATE, Lnk.T_WRTVATOUTLAYBUY,
                                  Lot.T_WRTVATOUTLAY, Lot.T_EFFECTINTERESTRATE, Lnk.T_FAIRVALUECHANGE, Lnk.T_AMORTCOSTCHANGE, Lot.T_AMORTCOSTDATE, Lnk.T_CORRVALUECHANGE, Lot.T_CORRDATE,
                                  WRTDetermineAccFI(Lot.t_FIID),
                                  case when WRTDetermineAccFI(Lot.t_FIID) = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( Lnk.T_BALANCECOSTBUY, v_FaceValueFI, WRTDetermineAccFI(Lot.t_FIID), Lot.T_DATE, 1 ),2),0) end,
                                  Lot.T_AMORTCALCKIND, Lnk.T_ESTRESERVCHANGE, Lot.T_ESTRESERVEDATE, Lnk.T_CORRINTTOEIRCHANGE, Lot.T_CORRINTTOEIRDATE, Lnk.T_CORRESTRESERVCHANGE, Lot.T_CORRESTRESERVEDATE,
                                  Lot.t_BegDefDiffDate, Lnk.T_HEDGCORRCHANGE, Lot.T_HEDGCORRDATE, Lnk.T_AMORTHEDGCORRCHANGE, Lot.T_AMORTHEDGCORRDATE
                             FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                            WHERE     Lot.t_SumID     = Lnk.t_BuyID
                                  AND Lnk.t_SaleID    = p_SaleID
                                  AND Lnk.t_Amount    > 0
                                  AND Lot.t_Portfolio = KINDPORT_BACK);
          END IF;

          IF v_CountPVOKSU > 0 THEN

            INSERT INTO DPMWRTSUM_DBT
                   ( T_SUMID, T_DOCKIND, T_DOCID, T_PARTNUM, T_FIID, T_PORTFOLIO, T_GROUPID, T_BUY_SALE, T_KIND, T_DATE, T_TIME, T_AMOUNT, T_AMOUNTBD, T_SUM, T_CURRENCY,
                     T_COST, T_BALANCECOST, T_BALANCECOSTBD, T_NKDAMOUNT, T_INTERESTINCOME, T_NOTCARRYINTEREST, T_INTERESTDATE, T_BEGDISCOUNT, T_DISCOUNTINCOME, T_NOTCARRYDISCOUNT,
                     T_DISCOUNTDATE, T_OUTLAY, T_OVERAMOUNT, T_OVERAMOUNTBD, T_OVERDATE, T_DEPARTMENT, T_DEALID, T_DEALDATE, T_DEALCODE, T_STATE, T_ENTERDATE, T_STATEDATE,
                     T_CHANGEDATE, T_ACTION, T_ID_OPERATION, T_ID_STEP, T_PARENT, T_SOURCE, T_COUPON, T_PARTLY, t_BegDate,
                     t_BegBonusDate, t_BegBonus, t_Bonus, t_OldBonus, t_BonusDate, T_OLDBEGDATE, T_OLDBEGDISCOUNT, T_BEGINTERESTDATE, T_BEGDISCOUNTDATE,
                     T_OLDBEGBONUS, T_RECALCDATE, T_NOTWRTBONUS, T_COSTPFI, T_ACTIVATEDATE, T_ACTIVATETIME, T_BLOCKAMOUNT,
                     T_BEGDEFDIFF, T_ACCOUNTEDDEFDIFF, T_DEFDIFFDATE, T_WRTOUTLAY, T_WRTOUTLAYDATE, T_VATOUTLAY, T_WRTVATOUTLAY, T_EFFECTINTERESTRATE,
                     T_FAIRVALUE, T_AMORTCOST, T_AMORTCOSTDATE, T_CORRVALUE, T_CORRDATE,
                     T_ACCFI, T_ACCBALANCECOST,
                     T_AMORTCALCKIND, T_ESTRESERVE, T_ESTRESERVEDATE, T_CORRINTTOEIR, T_CORRINTTOEIRDATE, T_CORRESTRESERVE, T_CORRESTRESERVEDATE,
                     T_BEGDEFDIFFDATE, T_HEDGCORR, T_HEDGCORRDATE, T_AMORTHEDGCORR, T_AMORTHEDGCORRDATE
                   )
                   (SELECT 0, 29, v_RQ.t_ID, (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                               FROM DPMWRTSUM_DBT LOT
                                              WHERE LOT.T_DOCKIND = 29
                                                AND LOT.T_DOCID   = v_RQ.t_ID) + ROWNUM,
                                  Lot.t_FIID, KINDPORT_BACK_BPP_KSU, Lot.T_GROUPID, PM_WRITEOFF_SUM_BUY, WRTSUM_KIND_RRWAB2,
                                  Lot.T_DATE, Lot.T_TIME, Lnk.T_AMOUNT, 0, Lnk.T_SUMBUY, Lot.T_CURRENCY, Lnk.T_COSTBUY, Lnk.T_BALANCECOSTBUY, 0, Lnk.T_NKDBUYAMOUNT,
                                  Lnk.T_INTERESTINCOMEBUY, Lnk.T_NOTCARRYINTERESTBUY, Lot.T_INTERESTDATE, Lnk.T_BEGDISCOUNTCHANGE, Lnk.T_DISCOUNTINCOMEBUY,
                                  Lnk.T_NOTCARRYDISCOUNTBUY, Lot.T_DISCOUNTDATE, Lnk.T_OUTLAYBUY, Lnk.T_OVERCHANGE, 0, Lot.T_OVERDATE, Lot.T_DEPARTMENT,
                                  Lot.T_DEALID, Lot.T_DEALDATE, Lot.T_DEALCODE, PM_WRTSUM_NOTFORM, v_SaleLot.T_DATE, v_SaleLot.T_DATE, v_SaleLot.T_DATE,
                                  PM_WRT_UPDTMODE_CREATE, v_SaleLot.T_ID_OPERATION, v_SaleLot.T_ID_STEP, v_SaleLot.t_SumID, (CASE WHEN Lot.t_Source > 0 THEN Lot.t_Source ELSE Lot.t_SumID END), chr(1), chr(1),Lot.t_BegDate,
                                  Lot.t_BegBonusDate, Lnk.t_BegBonusChange, Lnk.t_BonusBuy, Lnk.t_OldBonusBuy, Lot.t_BonusDate, Lot.t_OldBegDate,
                                  Lnk.T_OLDBEGDISCOUNTCHANGE, Lot.T_BEGINTERESTDATE, Lot.T_BEGDISCOUNTDATE,
                                  Lnk.T_OLDBEGBONUSCHANGE, Lot.T_RECALCDATE, Lnk.T_NOTWRTBONUSBUY, Lnk.t_COSTPFIBUY, v_ActivateDate, v_ActivateTime, Lnk.T_BLOCKAMOUNTBUY,
                                  Lnk.T_BEGDEFDIFFCHANGE, Lnk.T_ACCOUNTEDDEFDIFFBUY, Lot.T_DEFDIFFDATE, Lnk.T_WRTOUTLAYBUY, Lot.T_WRTOUTLAYDATE, Lnk.T_WRTVATOUTLAYBUY,
                                  Lot.T_WRTVATOUTLAY, Lot.T_EFFECTINTERESTRATE, Lnk.T_FAIRVALUECHANGE, Lnk.T_AMORTCOSTCHANGE, Lot.T_AMORTCOSTDATE, Lnk.T_CORRVALUECHANGE, Lot.T_CORRDATE,
                                  WRTDetermineAccFI(Lot.t_FIID),
                                  case when WRTDetermineAccFI(Lot.t_FIID) = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( Lnk.T_BALANCECOSTBUY, v_FaceValueFI, WRTDetermineAccFI(Lot.t_FIID), Lot.T_DATE, 1 ),2),0) end,
                                  Lot.T_AMORTCALCKIND, Lnk.T_ESTRESERVCHANGE, Lot.T_ESTRESERVEDATE, Lnk.T_CORRINTTOEIRCHANGE, Lot.T_CORRINTTOEIRDATE, Lnk.T_CORRESTRESERVCHANGE, Lot.T_CORRESTRESERVEDATE,
                                  Lot.t_BegDefDiffDate, Lnk.T_HEDGCORRCHANGE, Lot.T_HEDGCORRDATE, Lnk.T_AMORTHEDGCORRCHANGE, Lot.T_AMORTHEDGCORRDATE
                             FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                            WHERE     Lot.t_SumID     = Lnk.t_BuyID
                                  AND Lnk.t_SaleID    = p_SaleID
                                  AND Lnk.t_Amount    > 0
                                  AND Lot.t_Portfolio = KINDPORT_BACK_KSU);
          END IF;

        END;

        -- Число нулевых связей. Если в них есть ненулевые значения параметров, способных повлиять на начисление ПДД,
        -- то не переносим их в другие лоты и ругаемся. Пока непонятно, может ли такое быть.
        BEGIN
          SELECT COUNT(1),
                 NVL(SUM(Lnk.T_BEGDISCOUNTCHANGE), 0),
                 NVL(SUM(Lnk.t_BegBonusChange), 0),
                 NVL(SUM(Lnk.T_OLDBEGDISCOUNTCHANGE), 0),
                 NVL(SUM(Lnk.T_OLDBEGBONUSCHANGE), 0)

            INTO v_CountTP0,
                 v_BEGDISCOUNTCHANGE0,
                 v_BegBonusChange0,
                 v_OLDBEGDISCOUNTCHANGE0,
                 v_OLDBEGBONUSCHANGE0

            FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
           WHERE     Lot.t_SumID     = Lnk.t_BuyID
                 AND Lnk.t_SaleID    = p_SaleID
                 AND Lnk.t_Amount    = 0
                 AND Lot.t_Portfolio in (KINDPORT_TRADE, KINDPORT_SALE, KINDPORT_RETIRE, KINDPORT_CONTR);
        END;

        -- Если средневзвес и в связи кол-во = 0, то не создаём новый лот, а "размажем" суммы из этой связи по лотам того же портфеля в том же РЕПО.
        IF( v_CountTP0 > 0 ) THEN
           IF( v_AmortizationMethod = PM_WRITEOFF_AVERAGE ) THEN
              IF v_OLDBEGDISCOUNTCHANGE0 > 0 OR v_OLDBEGBONUSCHANGE0 > 0 THEN
                 SetError( WRTOFF_ERROR_20238 ); --Ошибка при распределении сумм при создании лотов 2ч прямого РЕПО
              END IF;

              CorrectLotsFromLinkByPortfolio(p_SaleID, KINDPORT_TRADE);
              CorrectLotsFromLinkByPortfolio(p_SaleID, KINDPORT_SALE);
              CorrectLotsFromLinkByPortfolio(p_SaleID, KINDPORT_RETIRE);
              CorrectLotsFromLinkByPortfolio(p_SaleID, KINDPORT_CONTR);
           END IF;

        END IF;


     END IF;

     IF( v_CountCLNT > 0 ) THEN
        v_SumID := 0;
           
        IF p_IsOneDayREPO = 1 THEN
          v_State  := PM_WRTSUM_FORM;
          v_Action := PM_WRT_UPDTMODE_DELIVERY;
          v_ActivateDate := v_RQ.t_FactDate;
          v_ActivateTime := v_Leg2.t_SUPPLYTIME;
        ELSE
          if (p_IsOneDayREPO = 0) then
            v_State  := PM_WRTSUM_SALE_BPP;
          else
            v_State := PM_WRTSUM_NOTFORM;
          end if;
          v_Action := PM_WRT_UPDTMODE_DELIVERYBPP;
        END IF;

        INSERT INTO DPMWRTSUM_DBT
               ( T_SUMID, T_DOCKIND, T_DOCID, T_PARTNUM, T_PARTY, T_CONTRACT, T_FIID, T_PORTFOLIO, T_GROUPID, T_BUY_SALE, T_KIND, T_DATE, T_TIME, T_AMOUNT, T_SUM, T_CURRENCY,
                 T_COST, T_BALANCECOST, T_NKDAMOUNT, T_INTERESTINCOME, T_NOTCARRYINTEREST, T_INTERESTDATE, T_BEGDISCOUNT, T_DISCOUNTINCOME, T_NOTCARRYDISCOUNT,
                 T_DISCOUNTDATE, T_OUTLAY, T_OVERAMOUNT, T_OVERDATE, T_DEPARTMENT, T_DEALID, T_DEALDATE, T_DEALCODE, T_STATE, T_ENTERDATE, T_STATEDATE,
                 T_CHANGEDATE, T_ACTION, T_ID_OPERATION, T_ID_STEP, T_PARENT, T_SOURCE, T_COUPON, T_PARTLY, t_BegDate,
                 t_BegBonusDate, t_BegBonus, t_Bonus, t_OldBonus, t_BonusDate, T_OLDBEGDATE, T_OLDBEGDISCOUNT, T_BEGINTERESTDATE, T_BEGDISCOUNTDATE,
                 T_OLDBEGBONUS, T_RECALCDATE, T_NOTWRTBONUS, T_COSTPFI, T_ACTIVATEDATE, T_ACTIVATETIME, T_BLOCKAMOUNT,
                 T_BEGDEFDIFF, T_ACCOUNTEDDEFDIFF, T_DEFDIFFDATE, T_WRTOUTLAY, T_WRTOUTLAYDATE, T_VATOUTLAY, T_WRTVATOUTLAY, T_EFFECTINTERESTRATE,
                 T_FAIRVALUE, T_AMORTCOST, T_AMORTCOSTDATE, T_CORRVALUE, T_CORRDATE,
                 T_ACCFI, T_ACCBALANCECOST,
                 T_AMORTCALCKIND, T_ESTRESERVE, T_ESTRESERVEDATE, T_CORRINTTOEIR, T_CORRINTTOEIRDATE, T_CORRESTRESERVE, T_CORRESTRESERVEDATE,
                 T_BEGDEFDIFFDATE, T_HEDGCORR, T_HEDGCORRDATE, T_AMORTHEDGCORR, T_AMORTHEDGCORRDATE
               )
               (SELECT 0, 29, v_RQ.t_ID, (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                           FROM DPMWRTSUM_DBT LOT
                                          WHERE LOT.T_DOCKIND = 29
                                            AND LOT.T_DOCID   = v_RQ.t_ID) + ROWNUM,
                              Lot.t_Party, Lot.t_Contract,
                              Lot.t_FIID, Lot.T_PORTFOLIO, Lot.T_GROUPID, PM_WRITEOFF_SUM_BUY, WRTSUM_KIND_RRWAB2,
                              Lot.T_DATE, Lot.T_TIME, Lnk.T_AMOUNT, Lnk.T_SUMBUY, Lot.T_CURRENCY, Lnk.T_COSTBUY, Lnk.T_BALANCECOSTBUY, Lnk.T_NKDBUYAMOUNT,
                              Lnk.T_INTERESTINCOMEBUY, Lnk.T_NOTCARRYINTERESTBUY, Lot.T_INTERESTDATE, Lnk.T_BEGDISCOUNTCHANGE, Lnk.T_DISCOUNTINCOMEBUY,
                              Lnk.T_NOTCARRYDISCOUNTBUY, Lot.T_DISCOUNTDATE, Lnk.T_OUTLAYBUY, Lnk.T_OVERCHANGE, Lot.T_OVERDATE, Lot.T_DEPARTMENT,
                              Lot.T_DEALID, Lot.T_DEALDATE, Lot.T_DEALCODE, v_State, v_SaleLot.T_DATE, v_SaleLot.T_DATE, v_SaleLot.T_DATE,
                              v_Action, v_SaleLot.T_ID_OPERATION, v_SaleLot.T_ID_STEP, v_SaleLot.t_SumID, Lot.t_SumID, chr(1), chr(1),Lot.t_BegDate,
                              Lot.t_BegBonusDate, Lnk.t_BegBonusChange, Lnk.t_BonusBuy, Lnk.t_OldBonusBuy, Lot.t_BonusDate, Lot.t_OldBegDate,
                              Lnk.T_OLDBEGDISCOUNTCHANGE, Lot.T_BEGINTERESTDATE, Lot.T_BEGDISCOUNTDATE,
                              Lnk.T_OLDBEGBONUSCHANGE, Lot.T_RECALCDATE, Lnk.T_NOTWRTBONUSBUY, Lnk.t_COSTPFIBUY, v_ActivateDate, v_ActivateTime, Lnk.T_BLOCKAMOUNTBUY,
                              Lnk.T_BEGDEFDIFFCHANGE, Lnk.T_ACCOUNTEDDEFDIFFBUY, Lot.T_DEFDIFFDATE, Lnk.T_WRTOUTLAYBUY, Lot.T_WRTOUTLAYDATE, Lnk.T_WRTVATOUTLAYBUY,
                              Lot.T_WRTVATOUTLAY, Lot.T_EFFECTINTERESTRATE, Lnk.T_FAIRVALUECHANGE, Lnk.T_AMORTCOSTCHANGE, Lot.T_AMORTCOSTDATE, Lnk.T_CORRVALUECHANGE, Lot.T_CORRDATE,
                              WRTDetermineAccFI(Lot.t_FIID),
                              case when WRTDetermineAccFI(Lot.t_FIID) = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( Lnk.T_BALANCECOSTBUY, v_FaceValueFI, WRTDetermineAccFI(Lot.t_FIID), Lot.T_DATE, 1 ),2),0) end,
                              Lot.T_AMORTCALCKIND, Lnk.T_ESTRESERVCHANGE, Lot.T_ESTRESERVEDATE, Lnk.T_CORRINTTOEIRCHANGE, Lot.T_CORRINTTOEIRDATE, Lnk.T_CORRESTRESERVCHANGE, Lot.T_CORRESTRESERVEDATE,
                              Lot.t_BegDefDiffDate, Lnk.T_HEDGCORRCHANGE, Lot.T_HEDGCORRDATE, Lnk.T_AMORTHEDGCORRCHANGE, Lot.T_AMORTHEDGCORRDATE
                         FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                        WHERE     Lot.t_SumID     = Lnk.t_BuyID
                              AND Lnk.t_SaleID    = p_SaleID
                              AND Lnk.t_Amount    > 0
                              AND Lot.t_Portfolio in (KINDPORT_CLIENT));



     END IF;


     ---- Нужно для ПВО
     IF( v_CountPVO > 0 AND v_SaleLot.t_Date < NewRepoDate()) THEN
       v_SumID := 0;

       BEGIN
         IF p_IsOneDayREPO = 1 THEN
           v_State  := PM_WRTSUM_FORM;
           v_Action := PM_WRT_UPDTMODE_DELIVERY;
           v_ActivateDate := v_RQ.t_FactDate;
           v_ActivateTime := v_Leg2.t_SUPPLYTIME;
         ELSE
           v_State  := PM_WRTSUM_NOTFORM;
           v_Action := PM_WRT_UPDTMODE_DELIVERYBPP;
         END IF;

         FOR one_prm IN (SELECT SUM(Lnk.T_AMOUNT) AS T_AMOUNT, Lot.T_FIID,
                                SUM(Lnk.T_BALANCECOSTBUY) AS T_BALANCECOSTBUY,
                                NVL(SUM(Lnk.t_NKDBuyAmount),0) AS T_NKDBUYAMOUNT
                           FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                          WHERE Lot.t_SumID     = Lnk.t_BuyID
                            AND Lnk.t_SaleID    = p_SaleID
                            AND Lot.t_Portfolio = KINDPORT_BACK
                          GROUP BY Lot.T_FIID )
         LOOP
           v_NeedChargeInterestIncome := WRTNeedChargeInterestIncome(one_prm.T_FIID); --Облигации, имеющие купоны, или в анкете которых задан доход
           v_NeedChargeIncome := WRTNeedChargeIncome(one_prm.T_FIID); --Облигация

           IF p_IsOneDayREPO = 1 THEN

             v_Sum := ROUND((v_Leg2.T_COST * v_RQ.T_AMOUNT / v_Leg2.T_PRINCIPAL), 2);
             v_ExistNOSS := rsi_rsb_fiinstr.FI_ExistNOSS( v_rq.T_FIID, v_rq.T_FACTDATE, 27 );

             IF( (RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) ) and (v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR) ) THEN
               v_Portfolio := KINDPORT_SALE;
             ELSIF v_ExistNOSS = 1 THEN
               v_Portfolio := KINDPORT_TRADE;
             ELSE
               v_Portfolio := KINDPORT_SALE;
             END IF;

             v_GroupID := RSI_GetWrtoffGroupByPortfolio(v_Portfolio);
             v_Cost := one_prm.T_BALANCECOSTBUY;

             v_BegDiscount := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(v_rq.T_FIID, v_rq.T_FACTDATE)* one_prm.T_Amount, 2) - v_Cost;
             IF v_BegDiscount < 0 THEN
               v_BegDiscount := 0;
             END IF;

             v_BegBonus := v_Cost - ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(v_rq.T_FIID, v_rq.T_FACTDATE)* one_prm.T_Amount, 2);
             IF v_BegBonus < 0 THEN
               v_BegBonus := 0;
             END IF;

           ELSE
             v_Portfolio := KINDPORT_BASICDEBT;
             v_GroupID := KINDPORT_BASICDEBT;

             v_Cost := 0;

             v_BegDiscount := 0;

             v_BegBonus := 0;

             v_Sum := 0;

           END IF;


           INSERT INTO DPMWRTSUM_DBT
              (T_SUMID,
               T_DOCKIND,
               T_DOCID,
               T_PARTNUM,
               T_FIID,
               T_PORTFOLIO,
               T_GROUPID,
               T_BUY_SALE,
               T_KIND,
               T_DATE,
               T_TIME,
               T_AMOUNT,
               T_AMOUNTBD,
               T_BALANCECOST,
               T_BALANCECOSTBD,
               T_NKDAMOUNT,
               T_DEPARTMENT,
               T_DEALID,
               T_DEALDATE,
               T_DEALCODE,
               T_STATE,
               T_ENTERDATE,
               T_STATEDATE,
               T_CHANGEDATE,
               T_ACTION,
               T_ID_OPERATION,
               T_ID_STEP,
               T_PARENT,
               T_COUPON,
               T_PARTLY,
               T_BEGINTERESTDATE,
               T_BEGDISCOUNTDATE,
               T_OVERAMOUNTBD,
               T_COST,
               T_BEGDISCOUNT,
               T_BEGBONUS,
               T_SUM,
               T_ACTIVATEDATE,
               T_ACTIVATETIME,
               T_BLOCKAMOUNT,
               T_ACCFI,
               T_ACCBALANCECOST
              )
              VALUES (0,
                      29,
                      v_RQ.t_ID,
                      (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                             FROM DPMWRTSUM_DBT LOT
                                            WHERE LOT.T_DOCKIND = 29
                                              AND LOT.T_DOCID   = v_RQ.t_ID),
                      v_SaleLot.t_FIID,
                      v_Portfolio,
                      v_GroupID,
                      PM_WRITEOFF_SUM_BUY,
                      WRTSUM_KIND_RRWAB2,
                      (CASE WHEN p_IsOneDayREPO = 1 THEN v_RQ.t_FactDate ELSE v_RQ.t_PlanDate END),
                      v_SaleLot.T_TIME,
                      one_prm.T_AMOUNT,
                      one_prm.T_AMOUNT,
                      one_prm.T_BALANCECOSTBUY,
                      one_prm.T_BALANCECOSTBUY,
                      one_prm.T_NKDBUYAMOUNT,
                      v_SaleLot.T_DEPARTMENT,
                      v_SaleLot.T_DEALID,
                      v_SaleLot.T_DEALDATE,
                      v_SaleLot.T_DEALCODE,
                      v_State,
                      v_SaleLot.T_DATE,
                      v_SaleLot.T_DATE,
                      v_SaleLot.T_DATE,
                      v_Action,
                      v_SaleLot.T_ID_OPERATION,
                      v_SaleLot.T_ID_STEP,
                      v_SaleLot.t_SumID,
                      chr(1),
                      chr(1),
                      (CASE WHEN v_NeedChargeInterestIncome = 1 AND p_IsOneDayREPO = 1 THEN v_rq.T_FACTDATE ELSE v_RQ.t_PlanDate END),
                      (CASE WHEN v_NeedChargeIncome = 1 AND v_BegDiscount > 0 AND p_IsOneDayREPO = 1 THEN v_rq.T_FACTDATE ELSE v_RQ.t_PlanDate END),
                      0,
                      v_Cost,
                      v_BegDiscount,
                      v_BegBonus,
                      v_Sum,
                      v_ActivateDate,
                      v_ActivateTime,
                      0,
                      WRTDetermineAccFI(v_SaleLot.t_FIID),
                      case when WRTDetermineAccFI(v_SaleLot.t_FIID) = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.T_BALANCECOSTBUY, v_FaceValueFI, WRTDetermineAccFI(v_SaleLot.t_FIID), (CASE WHEN p_IsOneDayREPO = 1 THEN v_RQ.t_FactDate ELSE v_RQ.t_PlanDate END), 1 ),2),0) end
                     );


         END LOOP;

       END;

     END IF;
     
     IF v_SaleLot.t_Kind = WRTSUM_KIND_RRWAS1 AND v_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN
       --Если передача в БПП, то возможны ситуации, когда по среднему с лотов списывались какие-то параметры из-за нехватки на других лотах (например, СС ПФИ), но сам лотв БПП не уходил
       --Тогда нужно эти списанные значения с нулевых связей распределить по лотам БПП

       --Пока только СС ПФИ
       FOR one_rec IN (SELECT NVL(SUM(lnk.t_CostPFIBuy), 0) as SumCostPFIBuy, buy.t_Portfolio
                         FROM dpmwrtlnk_dbt lnk, dpmwrtsum_dbt buy
                        WHERE lnk.t_SaleID = v_SaleLot.t_SumID
                          AND lnk.t_Amount = 0
                          AND buy.t_SumID = lnk.t_BuyID
                        GROUP BY buy.t_Portfolio)
       LOOP

         SELECT NVL(SUM(lnk.t_Amount), 0) INTO v_LnksAmount
           FROM dpmwrtlnk_dbt lnk, dpmwrtsum_dbt buy
          WHERE lnk.t_SaleID = v_SaleLot.t_SumID
            AND buy.t_SumID = lnk.t_BuyID
            AND buy.t_Portfolio = one_rec.t_Portfolio;

         IF v_LnksAmount > 0 THEN

           v_RestCostPFIBuy := one_rec.SumCostPFIBuy;
           v_RestAmount     := v_LnksAmount;

           IF v_RestCostPFIBuy <> 0 THEN

             FOR one_lot IN (SELECT t_SumID, t_Amount
                               FROM dpmwrtsum_dbt
                              WHERE t_Parent = v_SaleLot.t_SumID
                                AND t_Kind = WRTSUM_KIND_RRWAB2
                                AND t_FIID = v_SaleLot.t_FIID
                                AND t_Amount > 0
                                AND t_Portfolio = one_rec.t_Portfolio 
                            )
             LOOP

               IF v_RestAmount = one_lot.t_Amount THEN
                 v_AddCostPFI := v_RestCostPFIBuy;
               ELSE
                 v_AddCostPFI := ROUND(one_rec.SumCostPFIBuy * one_lot.t_Amount / v_LnksAmount, 2);
               END IF;

               UPDATE dpmwrtsum_dbt
                  SET t_CostPFI = t_CostPFI + v_AddCostPFI,
                      t_BalanceCost = t_BalanceCost + v_AddCostPFI
                WHERE t_SumID = one_lot.t_SumID;

               v_RestCostPFIBuy := v_RestCostPFIBuy - v_AddCostPFI;
               v_RestAmount     := v_RestAmount     - one_lot.t_Amount;
             END LOOP;

           END IF;
        END IF;

       END LOOP;
     END IF; 

   END;
   ----------------------------------------------------------------------------------------------------------------------
   ----- Проверяет, есть ли изменения по лотам поставки после даты
   FUNCTION WRTAreChangesAfterDate(
      p_Department   IN NUMBER, -- Филиал. Если не задан (UnknounValue(-1)) игнорируется.
      p_FIID         IN NUMBER, -- ц/б
      p_Party        IN NUMBER, -- Владелец
      p_Contract     IN NUMBER, -- Договор обслуживания
      p_Portfolio    IN NUMBER, -- Портфель. Если не задан (UnknounValue(-1)) игнорируется.
      p_Group        IN NUMBER, -- Группа списания.  Если не задан (UnknounValue(-1)) игнорируется.
      p_CalcDate     IN DATE     DEFAULT UnknownDate, -- Дата расчета
      p_CalcTime     IN DATE     DEFAULT UnknownTime, -- Время расчета
      p_StartDate    IN DATE     DEFAULT UnknownDate, -- Дата отбора лотов покупки
      p_CheckCoupon  IN NUMBER   DEFAULT 0,           --  Признак проверки количества с учетом погашений купонов/ЧП
      p_Coupon       IN VARCHAR2 DEFAULT NULL,        -- Номер купона. Задается, только если установлен CheckCoupon
      p_Partly       IN VARCHAR2 DEFAULT NULL         -- Номер ЧП. Задается, только если установлен CheckCoupon
   ) RETURN BOOLEAN DETERMINISTIC

   IS
     v_Count NUMBER := 0;

   BEGIN

     if( p_CheckCoupon = 0 ) then
        SELECT COUNT(1) INTO v_Count
          FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
         WHERE ((p_Department <= 0) OR (p_Department is null) OR (L.T_DEPARTMENT  = p_Department) )
           AND L.T_FIID        = p_FIID
           AND L.T_PARTY       = p_Party
           AND L.T_CONTRACT    = p_Contract
           AND L.T_BUY_SALE    in ( PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO)
           AND L.T_STATE       = PM_WRTSUM_FORM
           AND L.T_STATEDATE  <= p_CalcDate
           AND L.T_DATE       <= p_CalcDate
           AND ( (p_CalcTime   = UnknownTime) OR
                 (p_CalcTime  is NULL) OR
                 (L.T_DATE     < p_CalcDate) OR
                 ((L.T_TIME <= p_CalcTime) AND (L.T_DATE = p_CalcDate))
               )
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_DATE <= p_StartDate))
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_STATEDATE <= p_StartDate))
           AND L.T_CHANGEDATE  > p_CalcDate
           AND B.T_SUMID       = L.T_SUMID
           AND ( (p_Group <= 0) OR (p_Group is null) OR (B.T_GROUPID  = p_Group) )
           AND ( (p_Portfolio <= 0) OR (p_Portfolio is null) OR (B.T_PORTFOLIO  = p_Portfolio) )
           AND B.T_AMOUNT > 0
           AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                  FROM DPMWRTBC_DBT M
                                 WHERE M.T_CHANGEDATE <= p_CalcDate
                                   AND M.T_SUMID       = L.T_SUMID
                              );
     else
        SELECT COUNT(1) INTO v_Count
          FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
         WHERE ((p_Department <= 0) OR (p_Department is null) OR (L.T_DEPARTMENT  = p_Department) )
           AND L.T_FIID        = p_FIID
           AND L.T_PARTY       = p_Party
           AND L.T_CONTRACT    = p_Contract
           AND L.T_BUY_SALE    in ( PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO)
           AND L.T_STATE       = PM_WRTSUM_FORM
           AND L.T_STATEDATE  <= p_CalcDate
           AND L.T_DATE       <= p_CalcDate
           AND ( (p_CalcTime   = UnknownTime) OR
                 (p_CalcTime  is NULL) OR
                 (L.T_DATE     < p_CalcDate) OR
                 ((L.T_TIME <= p_CalcTime) AND (L.T_DATE = p_CalcDate))
               )
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_DATE <= p_StartDate))
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_STATEDATE <= p_StartDate))
           AND L.T_CHANGEDATE  > p_CalcDate
           AND B.T_SUMID       = L.T_SUMID
           AND ( (p_Group <= 0) OR (p_Group is null) OR (B.T_GROUPID  = p_Group) )
           AND ( (p_Portfolio <= 0) OR (p_Portfolio is null) OR (B.T_PORTFOLIO  = p_Portfolio) )
           AND B.t_Amount      > (SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
                                    FROM DPMWRTLNK_DBT  Link
                                   WHERE     Link.T_BUYID = L.T_SUMID
                                         AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/, PMWRTLINK_KIND_RETPARTLY/*Частичное погашение*/)
                                         AND ( (p_COUPON is null) OR (Link.T_COUPON  = p_COUPON) )
                                         AND ( (p_PARTLY is null) OR (Link.T_PARTLY  = p_PARTLY) )
                                         AND Link.T_CREATEDATE <= p_CalcDate
                                 )
           AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                  FROM DPMWRTBC_DBT M
                                 WHERE M.T_CHANGEDATE <= p_CalcDate
                                   AND M.T_SUMID       = L.T_SUMID
                              );
     end if;

     RETURN (v_Count > 0);
   END;--WRTAreChangesAfterDate

   ----------------------------------------------------------------------------------------------------------------------
   ----- Проверяет, есть ли изменения по лотам размещения после даты
   FUNCTION WRTAreChangesAfterDateOwn(
      p_Department   IN NUMBER, -- Филиал. Если не задан (UnknounValue(-1)) игнорируется.
      p_FIID         IN NUMBER, -- ц/б
      p_CalcDate     IN DATE     DEFAULT UnknownDate, -- Дата расчета
      p_CalcTime     IN DATE     DEFAULT UnknownTime, -- Время расчета
      p_StartDate    IN DATE     DEFAULT UnknownDate, -- Дата отбора лотов размещения
      p_CheckCoupon  IN NUMBER   DEFAULT 0,           -- Признак проверки количества с учетом погашений купонов
      p_Coupon       IN VARCHAR2 DEFAULT NULL         -- Номер купона. Задается, только если установлен CheckCoupon
   ) RETURN BOOLEAN DETERMINISTIC

   IS
     v_Count NUMBER := 0;

   BEGIN

     if( p_CheckCoupon = 0 ) then
        SELECT COUNT(1) INTO v_Count
          FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
         WHERE ((p_Department <= 0) OR (p_Department is null) OR (L.T_DEPARTMENT  = p_Department) )
           AND L.T_FIID        = p_FIID
           AND L.T_PARTY       = UnknownParty
           AND L.T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
           AND L.T_STATE       = PM_WRTSUM_PLACE_OWN
           AND L.T_STATEDATE  <= p_CalcDate
           AND L.T_DATE       <= p_CalcDate
           AND ( (p_CalcTime   = UnknownTime) OR
                 (p_CalcTime  is NULL) OR
                 (L.T_DATE     < p_CalcDate) OR
                 ((L.T_TIME <= p_CalcTime) AND (L.T_DATE = p_CalcDate))
               )
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_DATE <= p_StartDate))
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_STATEDATE <= p_StartDate))
           AND L.T_CHANGEDATE  > p_CalcDate
           AND B.T_SUMID       = L.T_SUMID
           AND B.T_AMOUNT > 0
           AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                  FROM DPMWRTBC_DBT M
                                 WHERE M.T_CHANGEDATE <= p_CalcDate
                                   AND M.T_SUMID       = L.T_SUMID
                              );
     else
        SELECT COUNT(1) INTO v_Count
          FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
         WHERE ((p_Department <= 0) OR (p_Department is null) OR (L.T_DEPARTMENT  = p_Department) )
           AND L.T_FIID        = p_FIID
           AND L.T_PARTY       = UnknownParty
           AND L.T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
           AND L.T_STATE       = PM_WRTSUM_PLACE_OWN
           AND L.T_STATEDATE  <= p_CalcDate
           AND L.T_DATE       <= p_CalcDate
           AND ( (p_CalcTime   = UnknownTime) OR
                 (p_CalcTime  is NULL) OR
                 (L.T_DATE     < p_CalcDate) OR
                 ((L.T_TIME <= p_CalcTime) AND (L.T_DATE = p_CalcDate))
               )
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_DATE <= p_StartDate))
           AND ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (L.T_STATEDATE <= p_StartDate))
           AND L.T_CHANGEDATE  > p_CalcDate
           AND B.T_SUMID       = L.T_SUMID
           AND B.t_Amount      > (SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
                                    FROM DPMWRTLNK_DBT  Link
                                   WHERE     Link.T_BUYID = L.T_SUMID
                                         AND Link.T_KIND = PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/
                                         AND ( (p_COUPON is null) OR (Link.T_COUPON  = p_COUPON) )
                                         AND Link.T_CREATEDATE <= p_CalcDate
                                 )
           AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                  FROM DPMWRTBC_DBT M
                                 WHERE M.T_CHANGEDATE <= p_CalcDate
                                   AND M.T_SUMID       = L.T_SUMID
                              );
     end if;

     RETURN (v_Count > 0);
   END;--WRTAreChangesAfterDateOwn

   ----------------------------------------------------------------------------------------------------------------------
   ----- Определяет валюту учёта ВУ при создании лотов
   FUNCTION WRTDetermineAccFI(
      p_FIID IN NUMBER -- ц/б
   ) RETURN NUMBER
   IS
     v_FaceValueFI  NUMBER;
     v_AvoirKind    NUMBER;
     v_Ret          NUMBER;
   BEGIN
     SELECT t_FaceValueFI, t_AvoirKind INTO v_FaceValueFI, v_AvoirKind
       FROM DFININSTR_DBT
      WHERE T_FIID = p_FIID;

     IF RSI_RSB_FIInstr.FI_AvrKindsGetRoot( RSI_RSB_FIInstr.FIKIND_AVOIRISS, v_AvoirKind ) = RSI_RSB_FIInstr.AVOIRKIND_BOND THEN
       v_Ret := v_FaceValueFI;
     ELSE
       IF v_FaceValueFI = RSI_RSB_FIInstr.NATCUR or AccountingExSecur() = ACCOUNTINGEXSECUR_NATCUR THEN
         v_Ret := RSI_RSB_FIInstr.NATCUR;
       ELSIF v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR and AccountingExSecur() = ACCOUNTINGEXSECUR_FACEVALUEFI THEN
         v_Ret := v_FaceValueFI;
       ELSE
         v_Ret := v_FaceValueFI;
       END iF;
     END IF;

    RETURN v_Ret;

    EXCEPTION
      WHEN OTHERS THEN RETURN -1;
   END;--WRTDetermineAccFI

   ----------------------------------------------------------------------------------------------------------------------
   ----- Проверяет, есть ли изменения по поставленным и проданным БПП лотам приобретенных на заданную дату
   FUNCTION WRTAreChangesAfterEndDate(
      p_Department   IN NUMBER, -- Филиал
      p_FIID         IN NUMBER, -- ц/б
      p_Party        IN NUMBER, -- Владелец
      p_Contract     IN NUMBER, -- Договор обслуживания
      p_P1           IN NUMBER DEFAULT UnknownValue,
      p_P2           IN NUMBER DEFAULT UnknownValue,
      p_P3           IN NUMBER DEFAULT UnknownValue,
      p_P4           IN NUMBER DEFAULT UnknownValue,
      p_P5           IN NUMBER DEFAULT UnknownValue,  -- Портфели (до 5-х штук, незаданные - UnknownValue (-1))
      p_CalcDate     IN DATE,   -- Дата расчета
      p_EndDate      IN DATE    -- Дата окончания периода отбора
   ) RETURN BOOLEAN DETERMINISTIC
   IS
     v_Count NUMBER := 0;

   BEGIN
     SELECT 1 INTO v_Count FROM DUAL
      WHERE Exists( SELECT 1
                      FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
                     WHERE L.T_DEPARTMENT  = p_Department
                       AND L.T_PARTY       = p_Party
                       AND L.T_CONTRACT    = p_Contract
                       AND L.T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
                       AND L.T_ENTERDATE  <= p_CalcDate
                       AND L.T_CHANGEDATE  > p_CalcDate
                       AND L.T_DATE       <= p_EndDate
                       AND L.T_FIID        = p_FIID
                       AND B.T_SUMID       = L.T_SUMID
                       AND B.T_PORTFOLIO IN(p_P1, p_P2, p_P3, p_P4, p_P5)
                       AND B.T_AMOUNT      > 0
                       AND B.T_STATE       in (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)

                       AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                              FROM DPMWRTBC_DBT M
                                             WHERE M.T_CHANGEDATE <= p_CalcDate
                                               AND M.T_SUMID       = L.T_SUMID
                                          )
                  );
     RETURN (v_Count > 0);

     EXCEPTION
       WHEN OTHERS THEN RETURN FALSE;
   END;--WRTAreChangesAfterEndDate

   -- Проверяет, есть ли изменения по всем лотам портфеля после даты в глобальных операциях
   FUNCTION WRTAreGlobalChangesAfterDate(
      p_Department   IN NUMBER, -- Филиал
      p_FIID         IN NUMBER, -- ц/б
      p_Party        IN NUMBER, -- Владелец
      p_Contract     IN NUMBER, -- Договор обслуживания
      p_P1           IN NUMBER DEFAULT UnknownValue,
      p_P2           IN NUMBER DEFAULT UnknownValue,
      p_P3           IN NUMBER DEFAULT UnknownValue,
      p_P4           IN NUMBER DEFAULT UnknownValue,
      p_P5           IN NUMBER DEFAULT UnknownValue,  -- Портфели (до 5-х штук, незаданные - UnknownValue (-1))
      p_CalcDate     IN DATE   DEFAULT UnknownDate, -- Дата расчета
      p_Delivered    IN NUMBER DEFAULT 0, -- Отбирать поставленные
      p_NotDelivered IN NUMBER DEFAULT 0, -- Отбирать непоставленные
      p_WithoutAccept   IN NUMBER DEFAULT 0  -- Отбирать проданные БПП
   ) RETURN INTEGER DETERMINISTIC
   IS
     v_Count NUMBER := 0;

   BEGIN
      SELECT 1 INTO v_Count FROM DUAL
      WHERE Exists( SELECT 1
                      FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
                     WHERE L.T_DEPARTMENT  = p_Department
                       AND L.T_PARTY       = p_Party
                       AND L.T_CONTRACT    = p_Contract
                       AND L.T_BUY_SALE    in ( PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO)
                       AND L.T_ENTERDATE   <= p_CalcDate
                       AND L.T_CHANGEDATE  > p_CalcDate
                       AND L.T_FIID        = p_FIID
                       AND B.T_SUMID       = L.T_SUMID
                       AND B.T_PORTFOLIO IN(p_P1, p_P2, p_P3, p_P4, p_P5)
                       AND B.T_AMOUNT > 0
                       AND (    (p_Delivered > 0 AND B.T_STATE = PM_WRTSUM_FORM)
                             OR (p_NotDelivered > 0 AND B.T_STATE = PM_WRTSUM_NOTFORM)
                             OR (p_WithoutAccept > 0 AND B.T_STATE = PM_WRTSUM_SALE_BPP)
                           )
                       AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                              FROM DPMWRTBC_DBT M
                                             WHERE M.T_CHANGEDATE <= p_CalcDate
                                               AND M.T_SUMID       = L.T_SUMID
                                          )
                  );
      RETURN v_Count;

      EXCEPTION
        WHEN OTHERS THEN RETURN 0;
   END;--WRTAreGlobalChangesAfterDate

   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет переоценку по лотам одного портфеля
   ----- OperDate - Дата
   ----- FIID - Выпуск
   ----- Department -Филиал
   ----- ID_Operation, ID_Step - Операция и шаг, на которых выполняется сохранение
   ----- Course - Курс переоценки
   ----- Group - Группа списания (портфель)
   ----- BalanceCost - Новая текущая балансовая стоимость
   ----- Amount - Количество, на которое начислена бал. стоимость (для контроля)
   ----- OldBalanceCost - Старая балансовая стоимость без учета переоценок (Cакт) в ВН
   ----- OverAmount -  Новый остаток переоценки в НацВ
   PROCEDURE RSI_WRTOvervalueLots( p_OperDate     IN DATE,
                               p_FIID         IN NUMBER,
                               p_Department   IN NUMBER,
                               p_ID_Operation IN NUMBER,
                               p_ID_Step      IN NUMBER,
                               p_Course       IN NUMBER,
                               p_Portfolio    IN NUMBER,-- Портфель
                               p_BalanceCost  IN NUMBER,
                               p_Amount       IN NUMBER,
                               p_OldBalanceCost IN NUMBER, -- Старая балансовая стоимость
                               p_OverAmount     IN NUMBER  --  Сумма переоценки в НацВ
                              )
   IS
     v_CurAmount         NUMBER := 0;
     v_CurBalanceCost    NUMBER := 0;
     v_OldBalanceCost    NUMBER := 0;
     v_BalanceCost       NUMBER := 0; -- то значение, к-рое заносим в pmwrtsum
     v_CurOldBalanceCost NUMBER := 0;
     v_CurOverAmount     NUMBER := 0;
     v_LotOverAmount     NUMBER := 0;
     v_FaceFI            NUMBER := 0;
     v_Method            NUMBER;

   CURSOR cLot(Method IN NUMBER) IS
      SELECT *
        FROM DPMWRTSUM_DBT
       WHERE     T_PARTY      = -1
             AND T_BUY_SALE in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
             AND T_DEPARTMENT = p_Department
             AND T_CONTRACT   = 0
             AND T_Portfolio  = p_Portfolio
             AND T_DATE      <= p_OperDate
             AND T_FIID       = p_FIID
             AND (T_AMOUNT     > 0 OR
                  (Method = PM_WRITEOFF_AVERAGE AND T_BALANCECOST <> 0) -- в средневзвесе могут быть лоты с нулевым количеством и ненулевыми параметрами
                 )
             AND T_STATE       in (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
             ORDER BY t_SumID;

   BEGIN
     v_CurAmount         := p_Amount;
     v_CurBalanceCost    := p_BalanceCost;
     v_CurOldBalanceCost := p_OldBalanceCost;
     v_CurOverAmount     := p_OverAmount;
     v_Method := GetAmortizationMethod( -1, 0 );

     FOR Lot IN cLot(v_Method) LOOP

       RSI_WRTSaveLot( Lot.t_SumID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_OVERVALUE );

       v_OldBalanceCost := ROUND(Lot.t_Cost + LOT.T_NKDAMOUNT + LOT.T_INTERESTINCOME + LOT.T_DISCOUNTINCOME + LOT.T_COSTPFI,2);
       v_BalanceCost := ROUND( v_CurBalanceCost - (v_CurAmount - LOT.T_AMOUNT) * p_Course,2);

       SELECT T_FACEVALUEFI
         INTO v_FaceFI
         FROM DFININSTR_DBT
        WHERE T_FIID = p_FIID;

       v_LotOverAmount  := v_CurOverAmount - ROUND(RSI_RSB_FIInstr.ConvSum( v_CurBalanceCost - v_BalanceCost - v_CurOldBalanceCost + v_OldBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1 ),2);

       UPDATE DPMWRTSUM_DBT
          SET t_OverDate    = p_OperDate,
              t_BALANCECOST = v_BalanceCost,
              t_OverAmount  = v_LotOverAmount
       WHERE t_SumID   = Lot.t_SumID;

       v_CurBalanceCost    := v_CurBalanceCost    - v_BalanceCost; -- именно v_BalanceCost, а не LOT.T_BALANCECOST
       v_CurAmount         := v_CurAmount         - Lot.t_Amount;
       v_CurOldBalanceCost := v_CurOldBalanceCost - v_OldBalanceCost;
       v_CurOverAmount     := v_CurOverAmount - v_LotOverAmount;

     END LOOP;

     if (v_CurAmount != 0) or (v_CurBalanceCost != 0) or (v_CurOldBalanceCost != 0) or (v_CurOverAmount != 0) then
       SetError( WRTOFF_ERROR_20217 );
     end if;

   END;--RSI_WRTOvervalueLots


   PROCEDURE RSI_WRTOvervalueLotsTrust( p_OperDate       IN DATE,
                                    p_FIID           IN NUMBER,
                                    p_Department     IN NUMBER,
                                    p_ID_Operation   IN NUMBER,
                                    p_ID_Step        IN NUMBER,
                                    p_Course         IN NUMBER,
                                    p_Portfolio      IN NUMBER,-- Портфель
                                    p_Contract       IN NUMBER,
                                    p_Client         IN NUMBER,
                                    p_AccountCost    IN NUMBER,
                                    p_Amount         IN NUMBER,
                                    p_OldAccountCost IN NUMBER, -- Старая балансовая стоимость
                                    p_OverAmount     IN NUMBER  --  Сумма переоценки в НацВ
                                  )
   IS
     v_CurAmount         NUMBER := 0;
     v_CurAccountCost    NUMBER := 0;
     v_CurOldAccountCost NUMBER := 0;
     v_NewAccountCost    NUMBER := 0; -- то значение, к-рое заносим в pmwrtsum
     v_OldAccountCost    NUMBER := 0;
     v_CurOverAmount     NUMBER := 0;
     v_NewOverAmount     NUMBER := 0;
     v_FaceFI            NUMBER := 0;

   CURSOR cLot IS
      SELECT *
        FROM DPMWRTSUM_DBT
       WHERE     T_PARTY      = p_Client
             AND T_BUY_SALE in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
             AND T_DEPARTMENT = p_Department
             AND T_CONTRACT   = p_Contract
             AND T_Portfolio  = p_Portfolio
             AND T_DATE      <= p_OperDate
             AND T_FIID       = p_FIID
             AND T_AMOUNT     > 0
             AND T_STATE       in (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
             ORDER BY t_SumID;

   BEGIN
     IF (p_OperDate < RsbSessionData.curdate) THEN
       IF (WRTAreGlobalChangesAfterDate(p_Department, p_FIID, p_Client, p_Contract, p_Portfolio, UnknownValue, UnknownValue, UnknownValue, UnknownValue, p_OperDate, 1, 0, 0) > 0) THEN
         SetError( WRTOFF_ERROR_20220 );
       END IF;
     END IF;

     v_CurAmount         := p_Amount;
     v_CurAccountCost    := p_AccountCost;
     v_CurOldAccountCost := p_OldAccountCost ;
     v_CurOverAmount     := p_OverAmount;

     FOR Lot IN cLot LOOP

       RSI_WRTSaveLot( Lot.t_SumID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_OVERVALUE );

       IF( p_OverAmount != 0 ) THEN

          v_OldAccountCost := ROUND(LOT.T_BALANCECOST - LOT.T_NKDAMOUNT - LOT.T_INTERESTINCOME,2);
          v_NewAccountCost := v_CurAccountCost - ROUND( (v_CurAmount - LOT.T_AMOUNT) * p_Course, 2 );

          SELECT T_FACEVALUEFI
            INTO v_FaceFI
            FROM DFININSTR_DBT
           WHERE T_FIID = p_FIID;
          v_NewOverAmount  := v_CurOverAmount - ROUND(RSI_RSB_FIInstr.ConvSum( v_CurAccountCost- v_NewAccountCost - v_CurOldAccountCost + v_OldAccountCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1 ),2);

          UPDATE DPMWRTSUM_DBT L
             SET t_OverDate    = p_OperDate,
                 t_BALANCECOST = v_NewAccountCost + L.T_NKDAMOUNT + L.T_INTERESTINCOME,
                 t_OverAmount  = L.T_OVERAMOUNT + v_NewOverAmount
          WHERE L.t_SumID   = Lot.t_SumID;

          v_CurAmount      := v_CurAmount - LOT.T_AMOUNT;
          v_CurAccountCost    := v_CurAccountCost    - v_NewAccountCost;
          v_CurOldAccountCost := v_CurOldAccountCost - v_OldAccountCost;
          v_CurOverAmount     := v_CurOverAmount     - v_NewOverAmount;

       ELSE
          UPDATE DPMWRTSUM_DBT
             SET t_OverDate    = p_OperDate
          WHERE t_SumID   = Lot.t_SumID;
       END IF;

     END LOOP;

     IF( p_OverAmount != 0 ) THEN
        if (v_CurAmount != 0) or (v_CurAccountCost != 0) or (v_CurOldAccountCost != 0) or (v_CurOverAmount != 0) then
          SetError( WRTOFF_ERROR_20217 );
        end if;
     END IF;

   END;--RSI_WRTOvervalueLotsTrust

   PROCEDURE RSI_WRTAmortizeOvervalueSum( p_OperDate       IN DATE,
                                          p_FIID           IN NUMBER,
                                          p_Department     IN NUMBER,
                                          p_ID_Operation   IN NUMBER,
                                          p_ID_Step        IN NUMBER,
                                          p_Portfolio      IN NUMBER,-- Портфель
                                          p_Contract       IN NUMBER,
                                          p_Client             IN NUMBER,
                                          p_CorrectBalanceCost IN NUMBER,-- Корректировать балансовую стоимость
                                          p_Action             IN NUMBER -- Вид изменения
                                        )
   IS
   CURSOR cLot IS
      SELECT *
        FROM DPMWRTSUM_DBT
       WHERE     T_PARTY      = p_Client
             AND T_BUY_SALE in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
             AND T_DEPARTMENT = p_Department
             AND T_CONTRACT   = p_Contract
             AND T_Portfolio  = p_Portfolio
             AND T_DATE      <= p_OperDate
             AND ( (p_FIID < 0) OR (T_FIID = p_FIID ) )
             AND T_AMOUNT     > 0
             AND T_STATE       in (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
             ORDER BY t_SumID;

   BEGIN
     IF (p_OperDate < RsbSessionData.curdate) THEN
       IF (WRTAreGlobalChangesAfterDate(p_Department, p_FIID, p_Client, p_Contract, p_Portfolio, UnknownValue, UnknownValue, UnknownValue, UnknownValue, p_OperDate, 1, 0, 0) > 0) THEN
         SetError( WRTOFF_ERROR_20220 );
       END IF;
     END IF;

     FOR Lot IN cLot LOOP

       RSI_WRTSaveLot( Lot.t_SumID, p_ID_Operation, p_ID_Step, p_OperDate, p_Action );

       UPDATE DPMWRTSUM_DBT L
          SET t_OverDate    = p_OperDate,
              t_BalanceCost = (CASE WHEN p_CorrectBalanceCost = 0 THEN t_BalanceCost ELSE (t_BalanceCost - t_OverAmount) END),
              t_OverAmount  = 0
       WHERE L.t_SumID   = Lot.t_SumID;

     END LOOP;
   END;--RSI_WRTAmortizeOvervalueSum


   PROCEDURE RSI_WRTRestoreLotAlt( p_ID_Operation IN NUMBER, p_ID_Step IN NUMBER, p_Action IN NUMBER )
   IS
   CURSOR cLot IS
      SELECT t_SumID, t_BCID
        FROM V_SCWRTHISTEX
       WHERE     t_ID_Operation = p_ID_Operation
             and t_ID_Step      = p_ID_Step
             and t_Action       = p_Action
     ORDER BY t_BCID DESC;

   BEGIN

     FOR Lot IN cLot LOOP
        RSI_WRTRestoreLot( p_ID_Operation, p_ID_Step, p_Action, Lot.t_SumID );
     END LOOP;
   END;--RSI_WRTRestoreLotAlt

   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет переоценку по одного лота
   PROCEDURE RSI_WRTOvervalueLot( p_OperDate       IN DATE,
                              p_SumID          IN NUMBER,
                              p_ID_Operation   IN NUMBER,
                              p_ID_Step        IN NUMBER,
                              p_BalanceCost    IN NUMBER,
                              p_OverAmount     IN NUMBER,  --  Сумма переоценки в НацВ
                              p_IsBD           IN NUMBER
                            )
   IS
   BEGIN
     RSI_WRTSaveLot( p_SumID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_OVERVALUE );

     IF( p_IsBD = 1) THEN
        UPDATE DPMWRTSUM_DBT
           SET t_OverDate    = p_OperDate,
               t_BALANCECOSTBD = p_BalanceCost,
               t_OverAmountBD  = t_OverAmountBD + p_OverAmount
        WHERE t_SumID   = p_SumID;
     ELSE
        UPDATE DPMWRTSUM_DBT
           SET t_OverDate    = p_OperDate,
               t_BALANCECOST = p_BalanceCost,
               t_OverAmount  = t_OverAmount + p_OverAmount
        WHERE t_SumID   = p_SumID;
     END IF;
   END; --RSI_WRTOvervalueLot

   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет переоценку по лотам
   PROCEDURE RSI_WRTOvervalue( p_OperDate     IN DATE,   -- Дата
                           p_FIID         IN NUMBER, -- Выпуск
                           p_Department   IN NUMBER, -- Филиал
                           p_ID_Operation IN NUMBER, -- Операция и шаг, на которых выполняется сохранение
                           p_ID_Step      IN NUMBER,
                           p_Course       IN NUMBER, -- Курс переоценки (ТСС)

                           p_G1           IN NUMBER DEFAULT UnknownValue, -- Портфели (по приоритетам, до 5-х штук, незаданные - UnknownValue (-1) )
                           p_G2           IN NUMBER DEFAULT UnknownValue,
                           p_G3           IN NUMBER DEFAULT UnknownValue,
                           p_G4           IN NUMBER DEFAULT UnknownValue,
                           p_G5           IN NUMBER DEFAULT UnknownValue,

                           p_BC1          IN NUMBER DEFAULT 0, -- Новая балановая стоимость по портфелям (К-во * ТСС)
                           p_BC2          IN NUMBER DEFAULT 0,
                           p_BC3          IN NUMBER DEFAULT 0,
                           p_BC4          IN NUMBER DEFAULT 0,
                           p_BC5          IN NUMBER DEFAULT 0,

                           p_A1           IN NUMBER DEFAULT 0, -- Количество по портфелям для контроля
                           p_A2           IN NUMBER DEFAULT 0,
                           p_A3           IN NUMBER DEFAULT 0,
                           p_A4           IN NUMBER DEFAULT 0,
                           p_A5           IN NUMBER DEFAULT 0,

                           p_OBC1         IN NUMBER DEFAULT 0, -- Старая баласовая стоимость по портфелям (Cтек)
                           p_OBC2         IN NUMBER DEFAULT 0,
                           p_OBC3         IN NUMBER DEFAULT 0,
                           p_OBC4         IN NUMBER DEFAULT 0,
                           p_OBC5         IN NUMBER DEFAULT 0, -- Старая баласносая стоимость по группам списания  (портфелям) (Cтек)

                           p_O1           IN NUMBER DEFAULT 0, -- Сумма переоценки в НацВ по портфелям ( Д)
                           p_O2           IN NUMBER DEFAULT 0,
                           p_O3           IN NUMBER DEFAULT 0,
                           p_O4           IN NUMBER DEFAULT 0,
                           p_O5           IN NUMBER DEFAULT 0
                         )

   IS
   BEGIN
     IF (p_OperDate < RsbSessionData.curdate) THEN
       IF (WRTAreGlobalChangesAfterDate(p_Department, p_FIID, UnknownParty, 0, p_G1, p_G2, p_G3, p_G4, p_G5, p_OperDate, 1, 0, 1) > 0) THEN
         SetError( WRTOFF_ERROR_20220 );
       END IF;
     END IF;

     IF (p_A1 > 0 AND p_G1 != UnknownValue) THEN
       RSI_WRTOvervalueLots (p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_Course, p_G1, p_BC1, p_A1, p_OBC1, p_O1);
     END IF;

     IF (p_A2 > 0 AND p_G2 != UnknownValue) THEN
       RSI_WRTOvervalueLots (p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_Course, p_G2, p_BC2, p_A2, p_OBC2, p_O2);
     END IF;

     IF (p_A3 > 0 AND p_G3 != UnknownValue) THEN
       RSI_WRTOvervalueLots (p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_Course, p_G3, p_BC3, p_A3, p_OBC3, p_O3);
     END IF;

     IF (p_A4 > 0 AND p_G4 != UnknownValue) THEN
       RSI_WRTOvervalueLots (p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_Course, p_G4, p_BC4, p_A4, p_OBC4, p_O4);
     END IF;

     IF (p_A5 > 0 AND p_G5 != UnknownValue) THEN
       RSI_WRTOvervalueLots (p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_Course, p_G5, p_BC5, p_A5, p_OBC5, p_O5);
     END IF;

   END;--RSI_WRTOvervalue

   FUNCTION GetFirstSumID(p_SumID IN NUMBER) RETURN NUMBER
   AS
      v_SumID NUMBER := 0;
   BEGIN
     SELECT l.t_SumID INTO v_SumID
        FROM dpmwrtsum_dbt l
       WHERE     l.t_Source = 0
       START WITH l.t_SumID = p_SumID
       CONNECT BY l.t_SumID =  PRIOR l.t_Source;
   
      RETURN v_SumID;
   END;

   --Вычисляет курс за дату p_OnDate с учетом ноимнала на дату p_CalcDate (если курс в % от номинала)
   FUNCTION GetCrizCourse(p_FIID IN NUMBER, p_OnDate IN DATE, p_CalcDate IN DATE) RETURN NUMBER
   AS
     v_RateID   NUMBER; 
     v_RateDate DATE;
     v_RateDef    DRATEDEF_DBT%ROWTYPE;
     vRecRateHist DRATEHIST_DBT%ROWTYPE;
     v_Revflag  CHAR := CHR(0);
     v_InitFaceValue NUMBER := 0;
     v_CurrFaceValue NUMBER := 0;

     v_CrizCourse NUMBER := 0;
   BEGIN

     v_CrizCourse := RSB_SECUR.GetFairValueFromRates_RSHB(p_FIID, p_OnDate, v_RateID, v_RateDate);  /*GAA: с учетом инсталляции РСХБ*/

     IF v_RateID > 0 THEN
       SELECT * INTO v_RateDef
         FROM DRATEDEF_DBT
        WHERE T_RATEID = v_RateID;

       IF v_RateDef.t_IsRelative = 'X' THEN
         IF v_RateDate <> v_RateDef.t_SinceDate THEN

           SELECT * INTO  vRecRateHist
             FROM (SELECT RH.*
                     FROM  DRATEHIST_DBT RH
                     WHERE RH.T_RATEID = v_RateID
                       AND RH.T_SINCEDATE <= v_RateDate
                       ORDER BY T_RATEID, T_SINCEDATE DESC) 
            WHERE ROWNUM=1;

           v_RateDef.t_Rate          := vRecRateHist.t_Rate;
           v_RateDef.t_SinceDate     := vRecRateHist.t_SinceDate;
           v_RateDef.t_Point         := vRecRateHist.t_Point;
           v_RateDef.t_Scale         := vRecRateHist.t_Scale;
           v_RateDef.t_IsInverse     := vRecRateHist.t_IsInverse;
           v_RateDef.t_IsManualInput := vRecRateHist.t_IsManualInput;
           v_RateDef.t_InputDate     := vRecRateHist.t_InputDate;
           v_RateDef.t_InputTime     := vRecRateHist.t_InputTime;

         END IF;
         
         v_CrizCourse := RSI_RSB_FIInstr.ConvSum_ex(1, p_FIID, v_RateDef.t_FIID, p_CalcDate, v_RateDef, v_Revflag);
       ELSE
         SELECT T_FACEVALUE, rsb_fiinstr.FI_GetNominalOnDate(T_FIID, p_CalcDate)  
           INTO v_InitFaceValue, v_CurrFaceValue
           FROM DFININSTR_DBT
          WHERE T_FIID = p_FIID;

         IF v_InitFaceValue <> 0 AND v_CurrFaceValue <> v_InitFaceValue THEN
           v_CrizCourse := ROUND(v_CrizCourse * v_CurrFaceValue / v_InitFaceValue, v_RateDef.t_Point);
         END IF;
       END IF;

     END IF;

     RETURN v_CrizCourse;
   END; --GetCrizCourse

   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет переоценку по лотам во временной таблице
   PROCEDURE RSI_WRTOvervalueLotsTMP( p_OperDate   IN DATE,            -- Дата
                                      p_FIID       IN NUMBER,          -- Выпуск
                                      p_Department IN NUMBER,          -- Филиал
                                      p_ByLnk      IN NUMBER DEFAULT 0,-- Только по лотам покупки из временной таблицы связей
                                      p_RQID       IN NUMBER DEFAULT 0,-- ТО по сделке (при выбытии)
                                      p_NotIsDC    IN NUMBER DEFAULT 1 -- Погашение купона (при выбытии)  /* КД*/
                                    )

   IS
      v_FVCourseType     NUMBER := Rsb_Common.GetRegIntValue('SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ', 0);
      v_OverType         NUMBER := Rsb_Common.GetRegIntValue('SECUR\МСФО\ПЕРЕОЦЕНКА ПЕРЕД ВЫБЫТИЕМ', 0);
      v_Course           NUMBER;
      v_Lot              DPMWRTSUM_DBT%ROWTYPE;
      v_LotTMP           DPMWRTSUM_TMP%ROWTYPE;
      v_SBCOldNat        NUMBER;
      v_FaceFI           NUMBER;
      v_SBCNew           NUMBER;
      v_SBCNewNat        NUMBER;
      v_SNewOverValue    NUMBER;
      v_OldLotOverAmount NUMBER;
      v_BCOldNat         NUMBER;
      v_BCNew            NUMBER;
      v_BCNewNat         NUMBER;
      v_NewOverValue     NUMBER;
      v_AvoirKind        NUMBER;
      
      v_OldLotBalanceCostNat NUMBER;

      v_NewLotBalanceCost    NUMBER;
      v_NewLotBalanceCostNat NUMBER;

      v_NewRestBalanceCost NUMBER;

      v_NewLotOverAmount  NUMBER;

      v_RestAmount NUMBER;

      v_NeedOver BOOLEAN := TRUE;

      v_CrizOver NUMBER := 0;

      v_IsBond BOOLEAN := FALSE;

      v_SAmount         NUMBER;
      v_SOldAmount      NUMBER;
      v_SOverAmount     NUMBER;
      v_SCost           NUMBER;
      v_SCostRub        NUMBER;
      v_SCorrIntToEIR   NUMBER;
      v_SCorrValue      NUMBER;
      v_SInterestIncome NUMBER;
      v_SDiscountIncome NUMBER;
      v_SNKDAmount      NUMBER;
      v_SCostPFI        NUMBER; 
      v_SBegCost        NUMBER; 
      v_SBegAmount      NUMBER;
      v_SHedgCorr       NUMBER;
      v_SAmortHedgCorr  NUMBER; 

      v_CrizCourse      NUMBER;
      v_NKDRKind     NUMBER; /*GAA: Вид округления НКД*/
      
      v_Method NUMBER;
      v_CalcDate DATE;
      v_K NUMBER;

      --Дата исправительной переоценки. Необходимо здесь указать дату, если в неё нужно исправить неверную переоценку за предыдущие даты
      --v_CorrectDate DATE := TO_DATE('01.01.0001','DD.MM.YYYY');
      v_CorrectDate DATE := TO_DATE('20.05.2020','DD.MM.YYYY');

      --Дата первой переоценки по кризисному. 
      v_FirstCrizOverDate DATE := TO_DATE('28.02.2022','DD.MM.YYYY');

      TYPE LotsCurTyp IS REF CURSOR;
      Lots            LotsCurTyp;
      LotsTMP         LotsCurTyp;

      v_RateID NUMBER;
      v_RateDate DATE;

      v_NKD  NUMBER;
      v_NKD1 NUMBER;
      v_NKD2 NUMBER;

      PROCEDURE AddLotTMP(p_Lot IN DPMWRTSUM_DBT%ROWTYPE)
      IS
         v_LotTMP     DPMWRTSUM_TMP%ROWTYPE;
      BEGIN
         v_LotTMP := NULL;

         v_LotTMP.T_SUMID            := p_Lot.T_SUMID;
         v_LotTMP.T_AMOUNT           := p_Lot.T_AMOUNT;
         v_LotTMP.T_COST             := p_Lot.T_COST;
         v_LotTMP.T_BALANCECOST      := p_Lot.T_BALANCECOST;
         v_LotTMP.T_INTERESTINCOME   := p_Lot.T_INTERESTINCOME;
         v_LotTMP.T_NOTCARRYINTEREST := p_Lot.T_NOTCARRYINTEREST;
         v_LotTMP.T_INTERESTDATE     := p_Lot.T_INTERESTDATE;
         v_LotTMP.T_BEGDISCOUNTDATE  := p_Lot.T_BEGDISCOUNTDATE;
         v_LotTMP.T_BEGBONUSDATE     := p_Lot.T_BEGBONUSDATE;
         v_LotTMP.T_DISCOUNTINCOME   := p_Lot.T_DISCOUNTINCOME;
         v_LotTMP.T_NOTCARRYDISCOUNT := p_Lot.T_NOTCARRYDISCOUNT;
         v_LotTMP.T_DISCOUNTDATE     := p_Lot.T_DISCOUNTDATE;
         v_LotTMP.T_BONUS            := p_Lot.T_BONUS;
         v_LotTMP.T_BONUSDATE        := p_Lot.T_BONUSDATE;
         v_LotTMP.T_NOTWRTBONUS      := p_Lot.T_NOTWRTBONUS;
         v_LotTMP.T_ACCOUNTEDDEFDIFF := p_Lot.T_ACCOUNTEDDEFDIFF;
         v_LotTMP.T_DEFDIFFDATE      := p_Lot.T_DEFDIFFDATE;
         v_LotTMP.T_WRTOUTLAY        := p_Lot.T_WRTOUTLAY;
         v_LotTMP.T_WRTOUTLAYDATE    := p_Lot.T_WRTOUTLAYDATE;
         v_LotTMP.T_WRTVATOUTLAY     := p_Lot.T_WRTVATOUTLAY;
         v_LotTMP.T_CORRVALUE        := p_Lot.T_CORRVALUE;
         v_LotTMP.T_CORRDATE         := p_Lot.T_CORRDATE;
         v_LotTMP.T_AMORTCOST        := p_Lot.T_AMORTCOST;
         v_LotTMP.T_CORRINTTOEIR     := p_Lot.T_CORRINTTOEIR;
         v_LotTMP.T_CORRINTTOEIRDATE := p_Lot.T_CORRINTTOEIRDATE;
         v_LotTMP.T_PORTFOLIO        := p_Lot.T_PORTFOLIO;
         v_LotTMP.T_STATE            := p_Lot.T_STATE;
         v_LotTMP.T_OVERAMOUNT       := p_Lot.T_OVERAMOUNT;
         v_LotTMP.T_DEALID           := p_Lot.T_DEALID;
         v_LotTMP.T_KIND             := 0;
         v_LotTMP.T_BEGDEFDIFFDATE   := p_Lot.T_BEGDEFDIFFDATE;
         v_LotTMP.T_HEDGCORR         := p_Lot.T_HEDGCORR;
         v_LotTMP.T_HEDGCORRDATE     := p_Lot.T_HEDGCORRDATE;
         v_LotTMP.T_AMORTHEDGCORRDATE:= p_Lot.T_AMORTHEDGCORRDATE;

         RSI_InsDfltIntoWRTSUM_TMP(v_LotTMP);

         INSERT INTO DPMWRTSUM_TMP VALUES v_LotTMP;
      END;

   BEGIN

      SELECT T_FACEVALUEFI, T_AVOIRKIND INTO v_FaceFI, v_AvoirKind
        FROM DFININSTR_DBT
       WHERE T_FIID = p_FIID;

      v_IsBond := RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind);

      /*GAA: Определим Вид округления НКД */
        SELECT av.T_NKDRound_Kind INTO v_NKDRKind
         FROM davoiriss_dbt av
        WHERE av.T_FIID = p_FIID;
      /*GAA*/
      IF ( p_ByLnk <> 0 and v_OverType <> 1 and v_OverType <> 2) THEN   -- из СОБУ и настройка равна 3(не переоценивать)
        v_NeedOver := FALSE;
      END IF;

      v_Method := GetAmortizationMethod(-1, 0);

      IF v_NeedOver = TRUE THEN

        IF (p_ByLnk <> 0 and v_OverType = 1)  -- из СОБУ и настройка равна 1(по цене сделке)
          THEN
           SELECT (leg.t_totalcost/leg.t_principal)
           INTO v_Course 
           FROM DDL_LEG_DBT LEG, DDLRQ_DBT RQ
           WHERE  RQ.T_ID = p_RQID
              AND LEG.T_DEALID = RQ.T_DOCID
              AND LEG.T_LEGID = 0
              AND LEG.T_LEGKIND = DECODE( RQ.T_DEALPART, 1, 0, 2 );--LEG по продаже
        ELSIF (p_ByLnk <> 0 and v_OverType = 2)  -- из СОБУ и настройка равна 2(по ТСС за предыдущий день)
          THEN
            RSB_SECUR.SC_ConvSumTypeRepProc( 1, p_FIID, v_FaceFI, v_FaceFI, v_FVCourseType, p_OperDate-1, v_Course, v_RateID, v_RateDate); -- курс за дату СОБУ - 1

            v_NKD1 := RSI_RSB_FIInstr.FindNKDCource(p_FIID, v_RateDate);
            IF v_NKD1 < 0 THEN
              v_NKD1 := RSI_RSB_FIInstr.CalcNKD_Ex( p_FIID, v_RateDate, 1, 1 );
            END IF;

            v_NKD2 := RSI_RSB_FIInstr.FindNKDCource(p_FIID, p_OperDate);
            IF v_NKD2 < 0 THEN
              v_NKD2 := RSI_RSB_FIInstr.CalcNKD_Ex( p_FIID, p_OperDate, 1, p_NotIsDC /*old:1*/);/*UPD 84.2? адаптация*/
            END IF;

            v_Course := (NVL(v_Course, 0)-- курс за дату СОБУ - 1
                         - v_NKD1
                         + v_NKD2
/*Before 84.2:
                         - RSI_RSB_FIInstr.CalcNKD_Ex( p_FIID, v_RateDate, 1, 1 )
                         + RSI_RSB_FIInstr.CalcNKD_Ex( p_FIID, p_OperDate, 1, p_NotIsDC ) */ /* КД*/ 
                        );

        ELSE    -- из СО переоценки
          v_Course := NVL(RSB_Secur.SC_ConvSumTypeRep(1, p_FIID, v_FaceFI, v_FaceFI, v_FVCourseType, p_OperDate), 0);
        
        END IF;

        v_CrizOver := RSB_SECUR.GetMainObjAttr(cnst.OBJTYPE_AVOIRISS, LPAD(p_FIID, 10, '0'), 65/*Кризисная переоценка*/, p_OperDate);
      END IF;

     
      -- Переоценка портфелей СССД_ЦБ и ССПУ_ЦБ
      IF v_NeedOver = TRUE THEN 
        IF p_ByLnk = 0 THEN
           OPEN Lots FOR SELECT /*+ index(lot DPMWRTSUM_DBT_IDX3)*/ LOT.* INTO v_Lot
                           FROM dpmwrtsum_dbt LOT
                          WHERE LOT.T_PARTY = -1
                            AND LOT.T_DEPARTMENT = p_Department
                            AND LOT.T_CONTRACT = 0
                            AND LOT.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
                            AND LOT.T_BUY_SALE IN (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO)
                            AND LOT.T_STATEDATE <= p_OperDate
                            AND LOT.T_DATE <= p_OperDate
                            AND LOT.T_FIID = p_FIID
                            AND LOT.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                            AND LOT.T_AMOUNT > 0
                            AND NOT EXISTS (SELECT 1 FROM DPMWRTSUM_TMP WHERE T_SUMID = LOT.T_SUMID);
           LOOP
              FETCH Lots INTO v_Lot;
              EXIT WHEN Lots%NOTFOUND OR
                        Lots%NOTFOUND IS NULL;

              AddLotTMP( v_Lot );
           END LOOP;
           CLOSE Lots;
        END IF;

        IF v_CrizOver = 1 /*Да*/ AND p_OperDate >= g_BegCrizDate THEN
          --Кризисная переоценка
          
          IF v_Method = PM_WRITEOFF_AVERAGE THEN --Для средневзвеса свой вариант переоценки
            
            FOR one_portf IN (SELECT DISTINCT TMP.T_PORTFOLIO AS S_PORTFOLIO
                                FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                               WHERE TMP.T_AMOUNT > 0
                                 AND LOT.T_SUMID = TMP.T_SUMID
                                 AND TMP.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
                                 AND (CASE WHEN p_ByLnk <> 0 THEN
                                              CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                           ELSE 1 END
                                     ) = 1)
            LOOP

              --Для каждого портфеля сначала вычисляем суммарную переоценку для всех лотов, приобретенных ДО даты начала кризисной переоценки
              --По состоянию на дату первой операции кризисной переоцнки

              IF v_CorrectDate = p_OperDate AND p_ByLnk = 0 THEN
                v_CalcDate := v_FirstCrizOverDate;
              ELSE 
                IF v_FirstCrizOverDate = p_OperDate AND p_ByLnk = 0 THEN
                  v_CalcDate := v_FirstCrizOverDate;
                ELSE
                  v_CalcDate := UnknownDate;
                END IF;
              END IF;

              IF v_CalcDate > UnknownDate THEN

                SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                       NVL(SUM(V.T_AMOUNT),0) AS S_OLDAMOUNT,
                       NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ) !!!Именно текущая переоценка с лота, а не архивная
                       NVL(SUM(V.T_COST),0) AS S_COST, --(в ВН)
                       NVL(SUM(RSI_RSB_FIInstr.ConvSum(V.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, V.T_BEGDATE, 1)),0) AS S_COSTRUB,
                       NVL(SUM(V.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                       NVL(SUM(V.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                       NVL(SUM(V.T_INTERESTINCOME),0) AS S_INTERESTINCOME, --(в ВН)
                       NVL(SUM(V.T_DISCOUNTINCOME),0) AS S_DISCOUNTINCOME, --(в ВН)
                       NVL(SUM(V.T_NKDAMOUNT),0) AS S_NKDAMOUNT, --(в ВН)
                       NVL(SUM(V.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                       NVL(SUM(V.T_HEDGCORR),0) AS S_HEDGCORR, --(в НацВ)
                       NVL(SUM(V.T_AMORTHEDGCORR),0) AS S_AMORTHEDGCORR --(в НацВ)
                       INTO v_SAmount,
                            v_SOldAmount,
                            v_SOverAmount,
                            v_SCost,
                            v_SCostRub,
                            v_SCorrIntToEIR,
                            v_SCorrValue,
                            v_SInterestIncome,
                            v_SDiscountIncome,
                            v_SNKDAmount,
                            v_SCostPFI,
                            v_SHedgCorr,
                            v_SAmortHedgCorr
                  FROM DPMWRTSUM_TMP TMP, V_SCWRTHISTEX V
                 WHERE TMP.T_AMOUNT > 0
                   AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                   AND V.T_SUMID = TMP.T_SUMID
                   AND V.T_BEGDATE < g_BegCrizDate
                   AND V.T_INSTANCE  = (SELECT MAX(V1.T_INSTANCE) 
                                          FROM V_SCWRTHISTEX V1 
                                         WHERE V1.T_SUMID = V.T_SUMID 
                                           AND V1.T_CHANGEDATE <= v_CalcDate
                                       );

                IF v_SAmount > 0 THEN
                 
                  --Курс ТСС вычисляем за дату курса кризисной переоценки
                  v_CrizCourse := GetCrizCourse(p_FIID, g_CrizCourseDate, v_CalcDate);

                  IF v_IsBond = TRUE THEN
                    v_NKD := RSI_RSB_FIInstr.FindNKDCource(p_FIID, v_CalcDate);
                    IF v_NKD < 0 THEN
                      v_NKD := RSI_RSB_FIInstr.CalcNKD_Ex(p_FIID, v_CalcDate, 1, 0);
                    END IF; 
                    v_CrizCourse := v_CrizCourse + v_NKD;
                  END IF;

                  IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                     v_SBCOldNat  := v_SCostRub + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr;
                  ELSE
                     v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_SCost + v_SNKDAmount + v_SInterestIncome + v_SDiscountIncome + v_SCostPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1) 
                                            + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr), 2);
                  END IF;

                  --Т.к. в архивном состоянии кол-во могло быть другим, то берем часть, приходящуюся на текущее кол-во
                  v_SBCOldNat := v_SBCOldNat / v_SOldAmount * v_SAmount;

                  v_SBCNew        := v_SAmount * v_CrizCourse;
                  v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1);
                  v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
                  v_RestAmount    := v_SAmount;

                  FOR sub_prm IN ( SELECT V.T_COST,
                                          TMP.T_AMOUNT,
                                          V.T_AMOUNT AS OLDAMOUNT,
                                          TMP.T_OVERAMOUNT, --!!!Переоценка из текущего состояния
                                          V.T_CORRINTTOEIR,
                                          V.T_CORRVALUE,
                                          --TMP.T_OVERAMOUNTADD,
                                          TMP.T_SUMID,
                                          --TMP.T_KIND,
                                          V.T_INTERESTINCOME,
                                          V.T_DISCOUNTINCOME,
                                          --LOT.T_DATE,
                                          V.T_NKDAMOUNT,
                                          V.T_COSTPFI,
                                          V.T_BEGDATE,
                                          V.T_HEDGCORR,
                                          V.T_AMORTHEDGCORR
                                     FROM DPMWRTSUM_TMP TMP, V_SCWRTHISTEX V
                                    WHERE TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                      AND TMP.T_AMOUNT > 0
                                      AND V.T_SUMID = TMP.T_SUMID
                                      AND V.T_BEGDATE < g_BegCrizDate
                                      AND V.T_INSTANCE = (SELECT MAX(V1.T_INSTANCE) 
                                                            FROM V_SCWRTHISTEX V1 
                                                           WHERE V1.T_SUMID = V.T_SUMID 
                                                             AND V1.T_CHANGEDATE <= v_CalcDate
                                                         ) 
                                 )
                  LOOP

                     v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1) 
                                                     + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                     --Т.к. в архивном состоянии кол-во могло быть другим, то берем часть, приходящуюся на текущее кол-во
                     v_K := sub_prm.T_AMOUNT / sub_prm.OLDAMOUNT;

                     v_OldLotBalanceCostNat := v_OldLotBalanceCostNat * v_K;

                     v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                     
                     v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * v_CrizCourse;

                     v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                     v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1),2);
                     

                     IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                        IF sub_prm.T_AMOUNT = v_RestAmount THEN
                           v_NewLotOverAmount := v_SNewOverValue;
                        ELSE
                           v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * v_CrizCourse, v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1) - 
                                                       RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST * v_K, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                      ,2) + (sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR) * v_K;
                        END IF;
                     ELSE
                        v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);

                     END IF;

                     v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                     v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                     v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                     v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                     v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                     UPDATE DPMWRTSUM_TMP SET
                        T_BALANCECOST   = v_NewLotBalanceCost,
                        T_OVERAMOUNT    = v_NewLotOverAmount,
                        T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                     WHERE T_SUMID = sub_prm.T_SUMID;

                  END LOOP;


                END IF;
              END IF;


              --Переоценка бумаг, приобретенных в дату или после даты начала кризисной переоценки
              IF v_IsBond = FALSE AND p_OperDate < TO_DATE('01.01.2022','DD.MM.YYYY') THEN --Это работало только в 2020-м году. 
                --Акции, приобретенные в дату или после даты начала кризисной переоценки, переоцениваются по - старому, вне зависимости от значения категории
                SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                       NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ)
                       NVL(SUM(TMP.T_COST),0) AS S_COST, --(в ВН)
                       NVL(SUM(RSI_RSB_FIInstr.ConvSum(TMP.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0) AS S_COSTRUB,
                       NVL(SUM(TMP.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                       NVL(SUM(TMP.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                       NVL(SUM(LOT.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                       NVL(SUM(TMP.T_HEDGCORR),0) AS S_HEDGCORR, --(в НацВ)
                       NVL(SUM(TMP.T_AMORTHEDGCORR),0) AS S_AMORTHEDGCORR --(в НацВ)
                       INTO v_SAmount,
                            v_SOverAmount,
                            v_SCost,
                            v_SCostRub,
                            v_SCorrIntToEIR,
                            v_SCorrValue,
                            v_SCostPFI,
                            v_SHedgCorr,
                            v_SAmortHedgCorr
                  FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                 WHERE TMP.T_AMOUNT > 0
                   AND LOT.T_SUMID = TMP.T_SUMID
                   AND LOT.T_BEGDATE >= g_BegCrizDate
                   AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                   AND (CASE WHEN p_ByLnk <> 0 THEN
                                CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                             ELSE 1 END
                       ) = 1;

                IF v_SAmount > 0 THEN

                  IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                     v_SBCOldNat  := v_SCostRub + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr;
                  ELSE
                     v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_SCost + v_SCostPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                            + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr), 2);
                  END IF;

                  v_SBCNew        := v_SAmount * v_Course;
                  v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
                  v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
                  v_RestAmount    := v_SAmount;

                  FOR sub_prm IN ( SELECT TMP.T_BALANCECOST,
                                          TMP.T_COST,
                                          TMP.T_AMOUNT,
                                          TMP.T_OVERAMOUNT,
                                          TMP.T_CORRINTTOEIR,
                                          TMP.T_CORRVALUE,
                                          TMP.T_OVERAMOUNTADD,
                                          TMP.T_SUMID,
                                          TMP.T_KIND,
                                          TMP.T_INTERESTINCOME,
                                          TMP.T_DISCOUNTINCOME,
                                          LOT.T_DATE,
                                          LOT.T_NKDAMOUNT,
                                          LOT.T_COSTPFI,
                                          LOT.T_BEGDATE,
                                          TMP.T_HEDGCORR,
                                          TMP.T_AMORTHEDGCORR
                                     FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                                    WHERE TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                      AND TMP.T_AMOUNT > 0
                                      AND LOT.T_SUMID = TMP.T_SUMID
                                      AND LOT.T_BEGDATE >= g_BegCrizDate
                                      AND (CASE WHEN p_ByLnk <> 0 THEN
                                                   CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                                ELSE 1 END
                                          ) = 1 )
                  LOOP

                     v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                                     + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                     v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                     
                     v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * v_Course;

                     v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                     v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1),2);
                     

                     IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                        IF sub_prm.T_AMOUNT = v_RestAmount THEN
                           v_NewLotOverAmount := v_SNewOverValue;
                        ELSE
                           v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * v_Course, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) - 
                                                       RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                      ,2) + sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR;
                        END IF;
                     ELSE
                        v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);

                     END IF;

                     v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                     v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                     v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                     v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                     v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                     UPDATE DPMWRTSUM_TMP SET
                        T_BALANCECOST   = v_NewLotBalanceCost,
                        T_OVERAMOUNT    = v_NewLotOverAmount,
                        T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                     WHERE T_SUMID = sub_prm.T_SUMID;

                  END LOOP;

                END IF;

              ELSE
                
                --приобретенные в дату или после даты начала кризисной переоценки, но до даты окончания кризисной переоценки, переоцениваются по кризисному

                --Если дата лота <= даты первой операции кризисной переоценки, то эти лоты больше не переоцениваем

                --Вне исправительной процедуры переоцениваем только лоты с датой поставки = дате операции

                --Переоценку считаем для каждой даты приобретения
                FOR one_date IN (SELECT DISTINCT LOT.T_BEGDATE AS BegDate
                                   FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                                  WHERE TMP.T_AMOUNT > 0
                                    AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                    AND LOT.T_SUMID = TMP.T_SUMID
                                    AND LOT.T_BEGDATE >= g_BegCrizDate
                                    AND LOT.T_BEGDATE <= g_EndCrizDate
                                    AND 1 = (CASE WHEN v_FirstCrizOverDate = p_OperDate THEN 1 --В дату начала кризисной переоценки можно всё
                                                  WHEN v_CorrectDate = p_OperDate AND p_ByLnk = 0 THEN 1 --В дату корректировки можно всё
                                                  WHEN (v_CorrectDate <> p_OperDate OR p_ByLnk <> 0) AND LOT.T_BEGDATE = p_OperDate THEN 1 --Вне процедуры корректировки можно переоценивать купленные сегодня лоты
                                                  ELSE 0 END
                                            )
                                    AND (CASE WHEN p_ByLnk <> 0 THEN
                                              CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) AND LOT.T_BEGDATE = p_OperDate THEN 1 ELSE 0 END
                                           ELSE 1 END
                                     ) = 1)
                LOOP

                  --Для каждого портфеля и даты сначала вычисляем суммарную переоценку для всех лотов, приобретенных в дату или после даты начала кризисной переоценки

                  SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                         NVL(SUM(V.T_AMOUNT),0) AS S_OLDAMOUNT,
                         NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ) !!!Именно текущая переоценка
                         NVL(SUM(V.T_COST),0) AS S_COST, --(в ВН)
                         NVL(SUM(RSI_RSB_FIInstr.ConvSum(V.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, V.T_BEGDATE, 1)),0) AS S_COSTRUB,
                         NVL(SUM(V.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                         NVL(SUM(V.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                         NVL(SUM(V.T_INTERESTINCOME),0) AS S_INTERESTINCOME, --(в ВН)
                         NVL(SUM(V.T_DISCOUNTINCOME),0) AS S_DISCOUNTINCOME, --(в ВН)
                         NVL(SUM(V.T_NKDAMOUNT),0) AS S_NKDAMOUNT, --(в ВН)
                         NVL(SUM(V.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                         NVL(SUM(V.T_HEDGCORR),0) AS S_HEDGCORR, --(в НацВ)
                         NVL(SUM(V.T_AMORTHEDGCORR),0) AS S_AMORTHEDGCORR --(в НацВ)
                         INTO v_SAmount,
                              v_SOldAmount,
                              v_SOverAmount,
                              v_SCost,
                              v_SCostRub,
                              v_SCorrIntToEIR,
                              v_SCorrValue,
                              v_SInterestIncome,
                              v_SDiscountIncome,
                              v_SNKDAmount,
                              v_SCostPFI,
                              v_SHedgCorr,
                              v_SAmortHedgCorr
                    FROM DPMWRTSUM_TMP TMP, V_SCWRTHISTEX V
                   WHERE TMP.T_AMOUNT > 0
                     AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                     AND V.T_SUMID = TMP.T_SUMID
                     AND V.T_BEGDATE = one_date.BegDate
                     AND V.T_INSTANCE = ABS((SELECT MAX(V1.T_INSTANCE * (CASE WHEN p_ByLnk <> 0 THEN -1 ELSE 1 END)) --При выбытии в эту же дату возьмём минимальный инстанс, т.е. исходный
                                               FROM V_SCWRTHISTEX V1 
                                              WHERE V1.T_SUMID = V.T_SUMID 
                                                AND V1.T_CHANGEDATE <= (CASE WHEN (v_CorrectDate = p_OperDate OR v_FirstCrizOverDate = p_OperDate) AND V1.T_BEGDATE <= v_FirstCrizOverDate THEN v_FirstCrizOverDate
                                                                             ELSE V1.T_BEGDATE END)
                                            ))
                     AND (CASE WHEN p_ByLnk <> 0 THEN
                                  (CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) AND V.T_BEGDATE = p_OperDate THEN 1 ELSE 0 END) -- При выбытии переоцениваем только купленные в эту же дату и сразу же выбываемые
                               ELSE 1 END
                         ) = 1;

                  IF v_SAmount > 0 THEN

                    IF v_CorrectDate = p_OperDate AND p_ByLnk = 0 THEN
                      IF one_date.BegDate <= v_FirstCrizOverDate THEN
                        v_CalcDate := v_FirstCrizOverDate;
                      ELSE
                        v_CalcDate := one_date.BegDate;
                      END IF;
                    ELSE
                      v_CalcDate := p_OperDate;
                    END IF;
                   
                    --Курс ТСС вычисляем за дату приобретения
                    v_CrizCourse := GetCrizCourse(p_FIID, one_date.BegDate, v_CalcDate);

                    IF v_IsBond = TRUE THEN
                      v_NKD := RSI_RSB_FIInstr.FindNKDCource(p_FIID, v_CalcDate);
                      IF v_NKD < 0 THEN
                        v_NKD := RSI_RSB_FIInstr.CalcNKD_Ex(p_FIID, v_CalcDate, 1, 0);
                      END IF;
                      v_CrizCourse := v_CrizCourse + v_NKD;
                    END IF;

                    IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                       v_SBCOldNat  := v_SCostRub + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr;
                    ELSE
                       v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_SCost + v_SNKDAmount + v_SInterestIncome + v_SDiscountIncome + v_SCostPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1) 
                                              + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr), 2);
                    END IF;
                    --Т.к. в архивном состоянии кол-во могло быть другим, то берем часть, приходящуюся на текущее кол-во
                    v_SBCOldNat := v_SBCOldNat / v_SOldAmount * v_SAmount;

                    v_SBCNew        := v_SAmount * v_CrizCourse;
                    v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1);
                    v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
                    v_RestAmount    := v_SAmount;

                    FOR sub_prm IN ( SELECT V.T_COST,
                                            TMP.T_AMOUNT,
                                            V.T_AMOUNT AS OLDAMOUNT,
                                            TMP.T_OVERAMOUNT, --!!!Именно текущая переоценка
                                            V.T_CORRINTTOEIR,
                                            V.T_CORRVALUE,
                                            V.T_SUMID,
                                            V.T_INTERESTINCOME,
                                            V.T_DISCOUNTINCOME,
                                            V.T_NKDAMOUNT,
                                            V.T_COSTPFI,
                                            V.T_BEGDATE,
                                            V.T_HEDGCORR,
                                            V.T_AMORTHEDGCORR
                                       FROM DPMWRTSUM_TMP TMP, V_SCWRTHISTEX V
                                      WHERE TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                        AND TMP.T_AMOUNT > 0
                                        AND V.T_SUMID = TMP.T_SUMID
                                        AND V.T_BEGDATE = one_date.BegDate
                                        AND V.T_INSTANCE = ABS((SELECT MAX(V1.T_INSTANCE * (CASE WHEN p_ByLnk <> 0 THEN -1 ELSE 1 END)) --При выбытии в эту же дату возьмём минимальный инстанс, т.е. исходный
                                                                  FROM V_SCWRTHISTEX V1 
                                                                 WHERE V1.T_SUMID = V.T_SUMID 
                                                                   AND V1.T_CHANGEDATE <= (CASE WHEN (v_CorrectDate = p_OperDate OR v_FirstCrizOverDate = p_OperDate) AND V1.T_BEGDATE <= v_FirstCrizOverDate THEN v_FirstCrizOverDate
                                                                                                ELSE V1.T_BEGDATE END)
                                                              ))
                                        AND (CASE WHEN p_ByLnk <> 0 THEN
                                                     CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) AND V.T_BEGDATE = p_OperDate THEN 1 ELSE 0 END
                                                  ELSE 1 END
                                            ) = 1 )
                    LOOP

                       v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1) 
                                                       + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                       --Т.к. в архивном состоянии кол-во могло быть другим, то берем часть, приходящуюся на текущее кол-во
                       v_K := sub_prm.T_AMOUNT / sub_prm.OLDAMOUNT;

                       v_OldLotBalanceCostNat := v_OldLotBalanceCostNat * v_K;
                       
                       v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                       
                       v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * v_CrizCourse;

                       v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                       v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, v_CalcDate, 1),2);
                       
                       IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                          IF sub_prm.T_AMOUNT = v_RestAmount THEN
                             v_NewLotOverAmount := v_SNewOverValue;
                          ELSE
                             v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * v_CrizCourse, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) - 
                                                         RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                        ,2) + sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR;
                          END IF;
                       ELSE
                          v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);
                       END IF;

                       v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                       v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                       v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                       v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                       v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                       UPDATE DPMWRTSUM_TMP SET
                          T_BALANCECOST   = v_NewLotBalanceCost,
                          T_OVERAMOUNT    = v_NewLotOverAmount,
                          T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                       WHERE T_SUMID = sub_prm.T_SUMID;

                    END LOOP;


                  END IF;

                END LOOP;

              END IF;



            END LOOP;

          ELSE --Для FIFO

            FOR one_portf IN (SELECT DISTINCT TMP.T_PORTFOLIO AS S_PORTFOLIO
                                FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                               WHERE TMP.T_AMOUNT > 0
                                 AND LOT.T_SUMID = TMP.T_SUMID
                                 AND TMP.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
                                 AND (CASE WHEN p_ByLnk <> 0 THEN
                                              CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                           ELSE 1 END
                                     ) = 1)
            LOOP

              --Для каждого портфеля сначала вычисляем суммарную переоценку для всех лотов, приобретенных ДО даты начала кризисной переоценки

              SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                     NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ)
                     NVL(SUM(TMP.T_COST),0) AS S_COST, --(в ВН)
                     NVL(SUM(RSI_RSB_FIInstr.ConvSum(TMP.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0) AS S_COSTRUB,
                     NVL(SUM(TMP.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                     NVL(SUM(TMP.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                     NVL(SUM(TMP.T_INTERESTINCOME),0) AS S_INTERESTINCOME, --(в ВН)
                     NVL(SUM(TMP.T_DISCOUNTINCOME),0) AS S_DISCOUNTINCOME, --(в ВН)
                     NVL(SUM(LOT.T_NKDAMOUNT),0) AS S_NKDAMOUNT, --(в ВН)
                     NVL(SUM(LOT.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                     NVL(SUM(TMP.T_HEDGCORR),0) AS S_HEDGCORR, --(в НацВ)
                     NVL(SUM(TMP.T_AMORTHEDGCORR),0) AS S_AMORTHEDGCORR --(в НацВ)
                     INTO v_SAmount,
                          v_SOverAmount,
                          v_SCost,
                          v_SCostRub,
                          v_SCorrIntToEIR,
                          v_SCorrValue,
                          v_SInterestIncome,
                          v_SDiscountIncome,
                          v_SNKDAmount,
                          v_SCostPFI,
                          v_SHedgCorr,
                          v_SAmortHedgCorr
                FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
               WHERE TMP.T_AMOUNT > 0
                 AND LOT.T_SUMID = TMP.T_SUMID
                 AND LOT.T_BEGDATE < g_BegCrizDate
                 AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                 AND (CASE WHEN p_ByLnk <> 0 THEN
                              CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                           ELSE 1 END
                     ) = 1;

              IF v_SAmount > 0 THEN
               
                --Курс ТСС вычисляем за дату курса кризисной переоценки
                v_CrizCourse := GetCrizCourse(p_FIID, g_CrizCourseDate, p_OperDate);

                IF v_IsBond = TRUE THEN
                  /*GAA: Учтем вид округления НКД при вычислении ТСС для долговых ц/б*/
                  v_NKD := RSI_RSB_FIInstr.FindNKDCource(p_FIID, p_OperDate);
                  IF v_NKD < 0 THEN
                   IF (v_NKDRKind = RSB_SECUR.AVOIRISSNKDROUND_SUM) THEN
                      v_NKD := RSI_RSB_FIInstr.CalcNKD_Ex_NoRound(p_FIID, p_OperDate, 1, 0);
                    ELSE
                    v_NKD := RSI_RSB_FIInstr.CalcNKD_Ex(p_FIID, p_OperDate, 1, 0);
                  END IF;
                 end if;
                  v_CrizCourse := v_CrizCourse + v_NKD;
                END IF;

 /*before 84.2:
                 IF (v_NKDRKind = RSB_SECUR.AVOIRISSNKDROUND_SUM) THEN
                    v_CrizCourse := v_CrizCourse + RSI_RSB_FIInstr.CalcNKD_Ex_NoRound(p_FIID, p_OperDate, 1, 0);
                  ELSE
                    v_CrizCourse := v_CrizCourse + RSI_RSB_FIInstr.CalcNKD_Ex(p_FIID, p_OperDate, 1, 0);
                  END IF;*/ /*GAA*/


                IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                   v_SBCOldNat  := v_SCostRub + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr;
                ELSE
                   v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_SCost + v_SNKDAmount + v_SInterestIncome + v_SDiscountIncome + v_SCostPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                          + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr), 2);
                END IF;

                v_SBCNew        := v_SAmount * v_CrizCourse;
                v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
                v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
                v_RestAmount    := v_SAmount;

                FOR sub_prm IN ( SELECT TMP.T_BALANCECOST,
                                        TMP.T_COST,
                                        TMP.T_AMOUNT,
                                        TMP.T_OVERAMOUNT,
                                        TMP.T_CORRINTTOEIR,
                                        TMP.T_CORRVALUE,
                                        TMP.T_OVERAMOUNTADD,
                                        TMP.T_SUMID,
                                        TMP.T_KIND,
                                        TMP.T_INTERESTINCOME,
                                        TMP.T_DISCOUNTINCOME,
                                        LOT.T_DATE,
                                        LOT.T_NKDAMOUNT,
                                        LOT.T_COSTPFI,
                                        LOT.T_BEGDATE,
                                        TMP.T_HEDGCORR,
                                        TMP.T_AMORTHEDGCORR
                                   FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                                  WHERE TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                    AND TMP.T_AMOUNT > 0
                                    AND LOT.T_SUMID = TMP.T_SUMID
                                    AND LOT.T_BEGDATE < g_BegCrizDate
                                    AND (CASE WHEN p_ByLnk <> 0 THEN
                                                 CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                              ELSE 1 END
                                        ) = 1 )
                LOOP

                   v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                                   + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                   v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                   
                   v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * v_CrizCourse;

                   v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                   v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1),2);
                   

                   IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                      IF sub_prm.T_AMOUNT = v_RestAmount THEN
                         v_NewLotOverAmount := v_SNewOverValue;
                      ELSE
                         v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * v_CrizCourse, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) - 
                                                     RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                    ,2) + sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR;
                      END IF;
                   ELSE
                      v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);

                   END IF;

                   v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                   v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                   v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                   v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                   v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                   UPDATE DPMWRTSUM_TMP SET
                      T_BALANCECOST   = v_NewLotBalanceCost,
                      T_OVERAMOUNT    = v_NewLotOverAmount,
                      T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                   WHERE T_SUMID = sub_prm.T_SUMID;

                END LOOP;


              END IF;


              --Переоценка бумаг, приобретенных в дату или после даты начала кризисной переоценки
              IF v_IsBond = FALSE AND p_OperDate < TO_DATE('01.01.2022','DD.MM.YYYY') THEN --!!!Код не отрабатывает. Только для кризисной переоценки 2020-го года
                --Акции, приобретенные в дату или после даты начала кризисной переоценки, переоцениваются по - старому, вне зависимости от значения категории
                SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                       NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ)
                       NVL(SUM(TMP.T_COST),0) AS S_COST, --(в ВН)
                       NVL(SUM(RSI_RSB_FIInstr.ConvSum(TMP.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0) AS S_COSTRUB,
                       NVL(SUM(TMP.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                       NVL(SUM(TMP.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                       NVL(SUM(TMP.T_INTERESTINCOME),0) AS S_INTERESTINCOME, --(в ВН)
                       NVL(SUM(TMP.T_DISCOUNTINCOME),0) AS S_DISCOUNTINCOME, --(в ВН)
                       NVL(SUM(LOT.T_NKDAMOUNT),0) AS S_NKDAMOUNT, --(в ВН)
                       NVL(SUM(LOT.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                       NVL(SUM(TMP.T_HEDGCORR),0) AS S_HEDGCORR, --(в НацВ)
                       NVL(SUM(TMP.T_AMORTHEDGCORR),0) AS S_AMORTHEDGCORR --(в НацВ)
                       INTO v_SAmount,
                            v_SOverAmount,
                            v_SCost,
                            v_SCostRub,
                            v_SCorrIntToEIR,
                            v_SCorrValue,
                            v_SInterestIncome,
                            v_SDiscountIncome,
                            v_SNKDAmount,
                            v_SCostPFI,
                            v_SHedgCorr,
                            v_SAmortHedgCorr
                  FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                 WHERE TMP.T_AMOUNT > 0
                   AND LOT.T_SUMID = TMP.T_SUMID
                   AND LOT.T_BEGDATE >= g_BegCrizDate
                   AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                   AND (CASE WHEN p_ByLnk <> 0 THEN
                                CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                             ELSE 1 END
                       ) = 1;

                IF v_SAmount > 0 THEN

                  IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                     v_SBCOldNat  := v_SCostRub + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr;
                  ELSE
                     v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_SCost + v_SNKDAmount + v_SInterestIncome + v_SDiscountIncome + v_SCostPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                            + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr), 2);
                  END IF;

                  v_SBCNew        := v_SAmount * v_Course;
                  v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
                  v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
                  v_RestAmount    := v_SAmount;

                  FOR sub_prm IN ( SELECT TMP.T_BALANCECOST,
                                          TMP.T_COST,
                                          TMP.T_AMOUNT,
                                          TMP.T_OVERAMOUNT,
                                          TMP.T_CORRINTTOEIR,
                                          TMP.T_CORRVALUE,
                                          TMP.T_OVERAMOUNTADD,
                                          TMP.T_SUMID,
                                          TMP.T_KIND,
                                          TMP.T_INTERESTINCOME,
                                          TMP.T_DISCOUNTINCOME,
                                          LOT.T_DATE,
                                          LOT.T_NKDAMOUNT,
                                          LOT.T_COSTPFI,
                                          LOT.T_BEGDATE,
                                          TMP.T_HEDGCORR,
                                          TMP.T_AMORTHEDGCORR
                                     FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                                    WHERE TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                      AND TMP.T_AMOUNT > 0
                                      AND LOT.T_SUMID = TMP.T_SUMID
                                      AND LOT.T_BEGDATE >= g_BegCrizDate
                                      AND (CASE WHEN p_ByLnk <> 0 THEN
                                                   CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                                ELSE 1 END
                                          ) = 1 )
                  LOOP

                     v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                                     + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                     v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                     
                     v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * v_Course;

                     v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                     v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1),2);
                     

                     IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                        IF sub_prm.T_AMOUNT = v_RestAmount THEN
                           v_NewLotOverAmount := v_SNewOverValue;
                        ELSE
                           v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * v_Course, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) - 
                                                       RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                      ,2) + sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR;
                        END IF;
                     ELSE
                        v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);

                     END IF;

                     v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                     v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                     v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                     v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                     v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                     UPDATE DPMWRTSUM_TMP SET
                        T_BALANCECOST   = v_NewLotBalanceCost,
                        T_OVERAMOUNT    = v_NewLotOverAmount,
                        T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                     WHERE T_SUMID = sub_prm.T_SUMID;

                  END LOOP;

                END IF;

              ELSE
                --Облигации и акции, приобретенные в дату или после даты начала кризисной переоценки, но до даты окончания кризисной переоценки, переоцениваются по кризисному

                --Переоценку считаем для каждой даты приобретения
                FOR one_date IN (SELECT DISTINCT LOT.T_BEGDATE AS BegDate
                                   FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                                  WHERE TMP.T_AMOUNT > 0
                                    AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                    AND LOT.T_SUMID = TMP.T_SUMID
                                    AND LOT.T_BEGDATE >= g_BegCrizDate
                                    AND LOT.T_BEGDATE <= g_EndCrizDate
                                    AND (CASE WHEN p_ByLnk <> 0 THEN
                                              CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                           ELSE 1 END
                                     ) = 1)
                LOOP

                  --Для каждого портфеля и даты сначала вычисляем суммарную переоценку для всех лотов, приобретенных в дату или после даты начала кризисной переоценки

                  SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                         NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ)
                         NVL(SUM(TMP.T_COST),0) AS S_COST, --(в ВН)
                         NVL(SUM(RSI_RSB_FIInstr.ConvSum(TMP.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0) AS S_COSTRUB,
                         NVL(SUM(TMP.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                         NVL(SUM(TMP.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                         NVL(SUM(TMP.T_INTERESTINCOME),0) AS S_INTERESTINCOME, --(в ВН)
                         NVL(SUM(TMP.T_DISCOUNTINCOME),0) AS S_DISCOUNTINCOME, --(в ВН)
                         NVL(SUM(LOT.T_NKDAMOUNT),0) AS S_NKDAMOUNT, --(в ВН)
                         NVL(SUM(LOT.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                         NVL(SUM(V.T_COST),0) AS S_BEGCOST,
                         NVL(SUM(V.T_AMOUNT),0) AS S_BEGAMOUNT,
                         NVL(SUM(TMP.T_HEDGCORR),0) AS S_HEGCORR, --(в НацВ)
                         NVL(SUM(TMP.T_AMORTHEDGCORR),0) AS S_AMORTHEGCORR --(в НацВ)
                         INTO v_SAmount,
                              v_SOverAmount,
                              v_SCost,
                              v_SCostRub,
                              v_SCorrIntToEIR,
                              v_SCorrValue,
                              v_SInterestIncome,
                              v_SDiscountIncome,
                              v_SNKDAmount,
                              v_SCostPFI,
                              v_SBegCost,
                              v_SBegAmount,
                              v_SHedgCorr,
                              v_SAmortHedgCorr
                    FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT, DV_SCWRTHISTEX V
                   WHERE TMP.T_AMOUNT > 0
                     AND LOT.T_SUMID = TMP.T_SUMID
                     AND LOT.T_BEGDATE = one_date.BegDate
                     AND TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                     AND (CASE WHEN p_ByLnk <> 0 THEN
                                  CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                               ELSE 1 END
                         ) = 1
                     AND V.T_SUMID = GetFirstSumID(LOT.T_SUMID)
                     AND V.T_INSTANCE = 0;

                  IF v_SAmount > 0 THEN
                   
                    v_NKD := 0;

                    /*GAA: Учтем вид округления НКД при вычислении ТСС для долговых ц/б*/
                    IF v_IsBond = TRUE THEN
                      v_NKD := RSI_RSB_FIInstr.FindNKDCource(p_FIID, p_OperDate);
                      IF v_NKD < 0 THEN
                        IF (v_NKDRKind = RSB_SECUR.AVOIRISSNKDROUND_SUM) THEN
                          v_NKD :=  RSI_RSB_FIInstr.CalcNKD_Ex_NoRound(p_FIID, p_OperDate, 1, 0);
                        ELSE
                        v_NKD := RSI_RSB_FIInstr.CalcNKD_Ex(p_FIID, p_OperDate, 1, 0);
                      END IF;
                      END IF;
                    END IF;
/*Before 84.2:
                       IF (v_NKDRKind = RSB_SECUR.AVOIRISSNKDROUND_SUM) THEN
                         v_CrizCourse := v_CrizCourse + RSI_RSB_FIInstr.CalcNKD_Ex_NoRound(p_FIID, p_OperDate, 1, 0);
                       ELSE
                         v_CrizCourse := v_CrizCourse + RSI_RSB_FIInstr.CalcNKD_Ex(p_FIID, p_OperDate, 1, 0);
                       END IF;
                      
                    END IF;*//*GAA*/

                    IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                      v_SBCOldNat  := v_SCostRub + v_SCorrIntToEIR + v_SCorrValue;
                    ELSE
                      v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((v_SCost + v_SNKDAmount + v_SInterestIncome + v_SDiscountIncome + v_SCostPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                           + v_SCorrIntToEIR + v_SCorrValue + v_SHedgCorr + v_SAmortHedgCorr), 2);
                    END IF;

                    ---Для бумаг, приобретенных после 18.02.2022 ТСС = Счист на дату поставки + НКД
                    v_SBCNew        := v_SAmount *  (v_SBegCost/v_SBegAmount + v_NKD);
                    v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
                    v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
                    v_RestAmount    := v_SAmount;

                    FOR sub_prm IN ( SELECT TMP.T_BALANCECOST,
                                            TMP.T_COST,
                                            TMP.T_AMOUNT,
                                            TMP.T_OVERAMOUNT,
                                            TMP.T_CORRINTTOEIR,
                                            TMP.T_CORRVALUE,
                                            TMP.T_OVERAMOUNTADD,
                                            TMP.T_SUMID,
                                            TMP.T_KIND,
                                            TMP.T_INTERESTINCOME,
                                            TMP.T_DISCOUNTINCOME,
                                            LOT.T_DATE,
                                            LOT.T_NKDAMOUNT,
                                            LOT.T_COSTPFI,
                                            LOT.T_BEGDATE,
                                            TMP.T_HEDGCORR,
                                            TMP.T_AMORTHEDGCORR,
                                            V.T_COST AS BEGCOST,
                                            V.T_AMOUNT AS BEGAMOUNT
                                       FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT, DV_SCWRTHISTEX V
                                      WHERE TMP.T_PORTFOLIO = one_portf.S_PORTFOLIO
                                        AND TMP.T_AMOUNT > 0
                                        AND LOT.T_SUMID = TMP.T_SUMID
                                        AND LOT.T_BEGDATE = one_date.BegDate
                                        AND (CASE WHEN p_ByLnk <> 0 THEN
                                                     CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                                  ELSE 1 END
                                            ) = 1
                                        AND V.T_SUMID = GetFirstSumID(LOT.T_SUMID)
                                        AND V.T_INSTANCE = 0
                                     )
                    LOOP

                       v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                                       + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                       v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                       
                       v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * (sub_prm.BegCost/sub_prm.BegAmount + v_NKD);

                       v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                       v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1),2);
                       
                       IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                          IF sub_prm.T_AMOUNT = v_RestAmount THEN
                             v_NewLotOverAmount := v_SNewOverValue;
                          ELSE
                             v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * (sub_prm.BegCost/sub_prm.BegAmount + v_NKD), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) - 
                                                         RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                        ,2) + sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR;
                          END IF;
                       ELSE
                         v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);
                       END IF;

                       v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                       v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                       v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                       v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                       v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                       UPDATE DPMWRTSUM_TMP SET
                          T_BALANCECOST   = v_NewLotBalanceCost,
                          T_OVERAMOUNT    = v_NewLotOverAmount,
                          T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                       WHERE T_SUMID = sub_prm.T_SUMID;

                    END LOOP;


                  END IF;

                END LOOP;

              END IF;

            END LOOP;
          END IF;
        END IF;

        --Не кризисная переоценка или переоценка для кризисных облигаций и акций, купленных после даты окончания кризисной переоценки
        IF v_CrizOver <> 1 OR (v_CrizOver = 1 AND /*v_IsBond = TRUE AND*/ p_OperDate > g_EndCrizDate) THEN
        --ELSE
          -- Определим суммы по временной таблице для портфелей
          FOR one_prm IN (SELECT NVL(SUM(TMP.T_AMOUNT),0) AS S_AMOUNT,
                                 NVL(SUM(TMP.T_BALANCECOST),0) AS S_BALANCECOST, --(в ВН)
                                 NVL(SUM(TMP.T_OVERAMOUNT),0) AS S_OVERAMOUNT, --(в НацВ)
                                 NVL(SUM(TMP.T_COST),0) AS S_COST, --(в ВН)
                                 NVL(SUM(RSI_RSB_FIInstr.ConvSum(TMP.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, LOT.T_BEGDATE, 1)),0) AS S_COSTRUB,
                                 NVL(SUM(TMP.T_CORRINTTOEIR),0) AS S_CORRINTTOEIR, --(в НацВ)
                                 NVL(SUM(TMP.T_CORRVALUE),0) AS S_CORRVALUE, --(в НацВ)
                                 NVL(SUM(TMP.T_INTERESTINCOME),0) AS S_INTERESTINCOME, --(в ВН)
                                 NVL(SUM(TMP.T_DISCOUNTINCOME),0) AS S_DISCOUNTINCOME, --(в ВН)
                                 NVL(SUM(LOT.T_NKDAMOUNT),0) AS S_NKDAMOUNT, --(в ВН)
                                 NVL(SUM(LOT.T_COSTPFI),0) AS S_COSTPFI, --(в ВН)
                                 NVL(SUM(TMP.T_HEDGCORR),0) AS S_HEDGCORR, --(в НацВ)
                                 NVL(SUM(TMP.T_AMORTHEDGCORR),0) AS S_AMORTHEDGCORR, --(в НацВ)
                                 TMP.T_PORTFOLIO AS S_PORTFOLIO
                            FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                           WHERE TMP.T_AMOUNT > 0
                             AND LOT.T_SUMID = TMP.T_SUMID
                             AND TMP.T_PORTFOLIO IN (KINDPORT_SALE, KINDPORT_TRADE)
                             AND 1 = (CASE WHEN v_CrizOver <> 1 THEN 1 WHEN LOT.T_BEGDATE > g_EndCrizDate THEN 1 ELSE 0 END)
                             AND (CASE WHEN p_ByLnk <> 0 THEN
                                          CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                       ELSE 1 END
                                 ) = 1
                           GROUP BY TMP.T_PORTFOLIO )
          LOOP

             IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                v_SBCOldNat  := one_prm.S_COSTRUB + one_prm.S_CORRINTTOEIR + one_prm.S_CORRVALUE + one_prm.S_HEDGCORR + one_prm.S_AMORTHEDGCORR;
             ELSE
                v_SBCOldNat  := ROUND((RSI_RSB_FIInstr.ConvSum((one_prm.S_COST + one_prm.S_NKDAMOUNT + one_prm.S_INTERESTINCOME + one_prm.S_DISCOUNTINCOME + one_prm.S_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                       + one_prm.S_CORRINTTOEIR + one_prm.S_CORRVALUE + one_prm.S_HEDGCORR + one_prm.S_AMORTHEDGCORR), 2);
             END IF;

             v_SBCNew        := one_prm.S_AMOUNT * v_Course;
             v_SBCNewNat     := RSI_RSB_FIInstr.ConvSum(v_SBCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
             v_SNewOverValue := v_SBCNewNat - v_SBCOldNat;
             v_RestAmount    := one_prm.S_AMOUNT;

             FOR sub_prm IN ( SELECT TMP.T_BALANCECOST,
                                     TMP.T_COST,
                                     TMP.T_AMOUNT,
                                     TMP.T_OVERAMOUNT,
                                     TMP.T_CORRINTTOEIR,
                                     TMP.T_CORRVALUE,
                                     TMP.T_OVERAMOUNTADD,
                                     TMP.T_SUMID,
                                     TMP.T_KIND,
                                     TMP.T_INTERESTINCOME,
                                     TMP.T_DISCOUNTINCOME,
                                     LOT.T_DATE,
                                     LOT.T_NKDAMOUNT,
                                     LOT.T_COSTPFI,
                                     LOT.T_BEGDATE,
                                     TMP.T_HEDGCORR,
                                     TMP.T_AMORTHEDGCORR
                                FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                               WHERE TMP.T_PORTFOLIO = one_prm.S_PORTFOLIO
                                 AND TMP.T_AMOUNT > 0
                                 AND LOT.T_SUMID = TMP.T_SUMID
                                 AND 1 = (CASE WHEN v_CrizOver <> 1 THEN 1 WHEN LOT.T_BEGDATE > g_EndCrizDate THEN 1 ELSE 0 END)
                                 AND (CASE WHEN p_ByLnk <> 0 THEN
                                              CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                           ELSE 1 END
                                     ) = 1 )
             LOOP

                v_OldLotBalanceCostNat := ROUND((RSI_RSB_FIInstr.ConvSum((sub_prm.T_COST + sub_prm.T_NKDAMOUNT + sub_prm.T_INTERESTINCOME + sub_prm.T_DISCOUNTINCOME + sub_prm.T_COSTPFI), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) 
                                                + sub_prm.T_CORRVALUE + sub_prm.T_CORRINTTOEIR + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR), 2);

                v_OldLotOverAmount     := sub_prm.T_OVERAMOUNT;
                
                v_NewRestBalanceCost   := (v_RestAmount - sub_prm.T_AMOUNT) * v_Course;

                v_NewLotBalanceCost    := ROUND((v_SBCNew - v_NewRestBalanceCost), 2);
                v_NewLotBalanceCostNat := ROUND(v_SBCNewNat - RSI_RSB_FIInstr.ConvSum(v_NewRestBalanceCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1),2);
                

                IF( v_IsBond = FALSE AND v_FaceFI <> RSI_RSB_FIInstr.NATCUR ) THEN
                   IF sub_prm.T_AMOUNT = v_RestAmount THEN
                      v_NewLotOverAmount := v_SNewOverValue;
                   ELSE
                      v_NewLotOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum(sub_prm.T_AMOUNT * v_Course, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1) - 
                                                  RSI_RSB_FIInstr.ConvSum(sub_prm.T_COST, v_FaceFI, RSI_RSB_FIInstr.NATCUR, sub_prm.T_BEGDATE, 1)
                                                 ,2) + sub_prm.T_CORRINTTOEIR + sub_prm.T_CORRVALUE + sub_prm.T_HEDGCORR + sub_prm.T_AMORTHEDGCORR;
                   END IF;
                ELSE
                   v_NewLotOverAmount    := ROUND(v_SNewOverValue - (v_SBCNewNat - v_NewLotBalanceCostNat - v_SBCOldNat + v_OldLotBalanceCostNat),2);

                END IF;

                v_SBCNew         := v_SBCNew - v_NewLotBalanceCost;
                v_SBCNewNat      := v_SBCNewNat - v_NewLotBalanceCostNat;
                v_RestAmount     := v_RestAmount - sub_prm.T_AMOUNT;
                v_SBCOldNat      := v_SBCOldNat - v_OldLotBalanceCostNat;
                v_SNewOverValue  := v_SNewOverValue - v_NewLotOverAmount;

                UPDATE DPMWRTSUM_TMP SET
                   T_BALANCECOST   = v_NewLotBalanceCost,
                   T_OVERAMOUNT    = v_NewLotOverAmount,
                   T_OVERAMOUNTADD = v_NewLotOverAmount - v_OldLotOverAmount
                WHERE T_SUMID = sub_prm.T_SUMID;

             END LOOP;

          END LOOP;

        END IF;
        
      END IF;

      IF v_NeedOver = TRUE THEN
        -- Переоценка портфелей ПВО и ПВО_БПП
        IF p_ByLnk = 0 THEN
           OPEN Lots FOR SELECT LOT.* INTO v_Lot
                           FROM dpmwrtsum_dbt LOT
                          WHERE LOT.T_PARTY = -1
                            AND LOT.T_DEPARTMENT = p_Department
                            AND LOT.T_CONTRACT = 0
                            AND ((LOT.T_PORTFOLIO = KINDPORT_BACK and LOT.T_STATE = PM_WRTSUM_FORM) or
                                 (    LOT.T_PORTFOLIO = KINDPORT_BASICDEBT 
                                  and LOT.T_STATE = PM_WRTSUM_NOTFORM
                                 )
                                )
                            AND LOT.T_BUY_SALE IN (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO)
                            AND LOT.T_STATEDATE <= p_OperDate
                            AND LOT.T_DATE <= p_OperDate
                            AND LOT.T_FIID = p_FIID
                            AND LOT.T_AMOUNT > 0
                            AND NOT EXISTS (SELECT 1 FROM DPMWRTSUM_TMP WHERE T_SUMID = LOT.T_SUMID);
           LOOP
              FETCH Lots INTO v_Lot;
              EXIT WHEN Lots%NOTFOUND OR
                        Lots%NOTFOUND IS NULL;

              AddLotTMP( v_Lot );
           END LOOP;
           CLOSE Lots;
        END IF;

        FOR one_rec IN (SELECT TMP.*, LOT.T_NKDAMOUNT 
                          FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                         WHERE TMP.T_AMOUNT > 0
                           AND ((TMP.T_PORTFOLIO = KINDPORT_BACK and TMP.T_STATE = PM_WRTSUM_FORM) or
                                (    TMP.T_PORTFOLIO = KINDPORT_BASICDEBT 
                                 and TMP.T_STATE = PM_WRTSUM_NOTFORM
                                )
                               )
                           AND (CASE WHEN p_ByLnk <> 0 THEN
                                        CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = TMP.T_SUMID) THEN 1 ELSE 0 END
                                     ELSE 1 END
                               ) = 1
                           AND LOT.T_SUMID = TMP.T_SUMID)
        LOOP

           v_BCOldNat      := RSI_RSB_FIInstr.ConvSum((one_rec.T_COST+one_rec.T_NKDAMOUNT+one_rec.T_INTERESTINCOME+one_rec.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
           v_BCNew         := ROUND(one_rec.T_AMOUNT * v_Course, 2);
           v_BCNewNat      := RSI_RSB_FIInstr.ConvSum(v_BCNew, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1);
           v_NewOverValue  := ROUND(v_BCNewNat - v_BCOldNat, 2);

           UPDATE DPMWRTSUM_TMP SET
              T_BALANCECOST       = v_BCNew,
              T_OVERAMOUNTADD     = v_NewOverValue - one_rec.T_OVERAMOUNT,
              T_OVERAMOUNT        = v_NewOverValue
           WHERE T_SUMID = one_rec.T_SUMID
             AND T_KIND  = one_rec.T_KIND;

        END LOOP;
      END IF;

   END;--RSI_WRTOvervalueLotsTMP

 ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет отражение сумм переоценки на лотах по данным из временной таблицы.
   PROCEDURE RSI_WRTSaveOvervalueLots( p_OperDate     IN DATE,    -- Дата
                                       p_ID_Operation IN NUMBER,  -- Операция
                                       p_ID_Step      IN NUMBER   -- Шаг операции
                                     )
   IS
   BEGIN
      FOR one_prm IN (SELECT TMP.T_SUMID, TMP.T_BALANCECOST, TMP.T_OVERAMOUNT
                        FROM DPMWRTSUM_TMP TMP)
      LOOP
         RSI_WRTSaveLot(one_prm.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_OVERVALUE);

         UPDATE DPMWRTSUM_DBT LOT
            SET LOT.T_OVERDATE = p_OperDate,
                LOT.T_BALANCECOST = one_prm.T_BALANCECOST,
                LOT.T_OVERAMOUNT = one_prm.T_OVERAMOUNT
          WHERE LOT.T_SUMID = one_prm.T_SUMID;
      END LOOP;

      DELETE FROM DPMWRTSUM_TMP;

   END; --RSI_WRTSaveOvervalueLots
  
  -- получить значение настройки реестра для BOSS-1232
  procedure GetPrecisionRegValue(x_UseSumPrecision in out NUMBER) is
  begin
    IF(Rsb_Common.GetRegBoolValue('SECUR\BOSS-1232')) THEN
      x_UseSumPrecision := 1;
    ELSE
      x_UseSumPrecision := 0;
    END IF;
  end GetPrecisionRegValue;
  
  -- определить значение точности округления BOSS-1232 на основании нового выпуска 
  procedure GetSumPrecisionByNewFiid(
       p_NewFiid in NUMBER, 
       p_DealKind in NUMBER, 
       p_DealID in NUMBER,
       p_SumPrecision in out NUMBER 
       ) is
    v_commdate date := RsbSessionData.curdate;
    x_UseSumPrecision number;
    v_Note number :=-1; 
  begin
    
    p_SumPrecision := 6;
     
    GetPrecisionRegValue(x_UseSumPrecision);
    
    if (x_UseSumPrecision = 0) then

      begin
        SELECT  
          fi.t_sumprecision
        INTO p_SumPrecision
          FROM dfininstr_dbt fi
        WHERE fi.t_fiid = p_NewFiid;
      exception WHEN NO_DATA_FOUND THEN
        p_SumPrecision := -1;
      end;
      return;

    end if;
    
    -- из-за ограничения rsbacctransaction
    if (p_SumPrecision is null or p_SumPrecision < 0 or p_SumPrecision > g_MaxSumPrecision) then 
      p_SumPrecision := 6; 
    end if;
    
  end GetSumPrecisionByNewFiid;

 ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет зачисление при глобальной конвертации лотов.
   PROCEDURE RSI_WRTGlobalConvert( p_DealKind     IN NUMBER,   -- Вид документа операции
                                   p_DealID       IN NUMBER,   -- Идентификатор документа операции
                                   p_OperDate     IN DATE,     -- Дата операции
                                   p_ID_Operation IN NUMBER,   -- Операция
                                   p_ID_Step      IN NUMBER    -- Шаг операции
                                 )
   IS
     v_N           NUMBER := 0;
     v_Contract    NUMBER := 0;
     v_SaleID      NUMBER := 0;
     v_NKD         NUMBER := 0;
     v_Cost        NUMBER := 0;
     v_D           NUMBER := 0;
     v_BegDiscount NUMBER := 0;
     v_BegBonus    NUMBER := 0;
     v_IsTrust     NUMBER := 0;
     v_OperSubKind NUMBER := 0;
     v_NewCurrency NUMBER := 0;
     v_NewCostCurr NUMBER := 0;
     v_SumPrecision NUMBER :=6;

     CURSOR cPmwr (v_DealID IN NUMBER, v_DealKind IN NUMBER) IS
      SELECT LOT.T_SUMID, S.T_NEWAMOUNT, S.T_NEWFIID
        FROM DSCDLPMWR_DBT S, DPMWRTSUM_DBT LOT
       WHERE S.T_DEALKIND = v_DealKind
         AND S.T_DEALID   = v_DealID
         AND S.T_SUMID    = LOT.T_SUMID
         AND S.T_STATE    = SCDLPMWR_STATE_NOT_READY
         AND S.T_PARTY    = LOT.T_PARTY
         AND S.T_KIND     = 1;


     CURSOR cPmwrtbc (v_DealID IN NUMBER, v_DealKind IN NUMBER) IS
      SELECT BC.*, L.T_PARTY, L.T_CONTRACT, L.T_TRUST, L.T_ISFREE, L.T_DEALCODE, L.T_ENTERDATE, L.T_DEALDATE, L.T_DEALID, L.T_DEPARTMENT, L.T_BUY_SALE, L.T_AMORTCOSTDATE
        FROM DSCDLPMWR_DBT DS, DPMWRTBC_DBT BC, DPMWRTSUM_DBT L
       WHERE DS.T_DEALKIND    = v_DealKind
         AND DS.T_DEALID      = v_DealID
         AND DS.T_STATE       = SCDLPMWR_STATE_READY
         AND DS.T_KIND        = 1
         AND BC.T_SUMID       = DS.T_SUMID
         AND BC.T_INSTANCE    = DS.T_OLDINSTANCE  --до списания
         AND L.T_PARTY        = DS.T_PARTY
         AND L.T_SUMID        = BC.T_SUMID;

     CURSOR cDlfi (v_SumID IN NUMBER, v_DealID IN NUMBER, v_DealKind IN NUMBER) IS
      SELECT S.T_NEWFIID, S.T_NEWAMOUNT, S.T_PARTY, S.T_NEWCOST
        FROM DSCDLPMWR_DBT S, DSCDLFI_DBT F
       WHERE S.T_DEALKIND = v_DealKind
         AND S.T_DEALID   = v_DealID
         AND S.T_SUMID    = v_SumID
         AND S.T_KIND     = 1
         AND F.T_DEALKIND = v_DealKind
         AND F.T_DEALID   = v_DealID
         AND F.T_NewFIID  = S.T_NewFIID
      ORDER BY F.T_Num;

      x_UseSumPrecision NUMBER := 0; -- рубильник (BOSS-1232)


   BEGIN
     InitError();

     SELECT dl.t_OperSubKind
     INTO v_OperSubKind
       FROM ddl_comm_dbt dl
     WHERE t_DocKind = p_DealKind
        AND dl.t_DocumentID = p_DealID;

      -- рубильник BOSS-1232
     GetPrecisionRegValue(x_UseSumPrecision);

     SELECT count(1) INTO v_N
       FROM DSCDLFI_DBT
      WHERE T_DEALKIND = p_DealKind
        AND T_DEALID = p_DealID;

     IF v_N = 1 THEN
        FOR OnePmwr IN cPmwr(p_DealID, p_DealKind)
        LOOP
          RSI_WRTSaveLot(OnePmwr.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_GLOBALIN);

          GetSumPrecisionByNewFiid(OnePmwr.T_NEWFIID, p_DealKind, p_DealID, v_SumPrecision);
          UPDATE DPMWRTSUM_DBT LOT
             SET LOT.T_STATE = PM_WRTSUM_NOTFORM,
                 LOT.T_STATEDATE = p_OperDate,
                 LOT.T_FIID = OnePmwr.T_NEWFIID,
                 LOT.T_AMOUNT = case when x_UseSumPrecision = 1 
                   then round(OnePmwr.T_NEWAMOUNT, v_SumPrecision)
                   else  OnePmwr.T_NEWAMOUNT end 
           WHERE LOT.T_SUMID = OnePmwr.T_SUMID;

        END LOOP;
     END IF;


     FOR L IN cPmwrtbc(p_DealID, p_DealKind)
     LOOP
        v_Contract := L.T_CONTRACT;

        IF L.T_TRUST = 'X' THEN
          v_IsTrust := 1;
        ELSE
          v_IsTrust := 0;
        END IF;

        BEGIN
          SELECT LOT.t_SUMID INTO v_SaleID
            FROM DPMWRTSUM_DBT LOT
           WHERE LOT.T_DOCKIND = p_DealKind
             AND LOT.T_DOCID = p_DealID
             AND LOT.T_PARTY = L.T_PARTY
             AND LOT.T_CONTRACT = v_Contract
             AND LOT.T_Buy_Sale = PM_WRITEOFF_SUM_SALE; --Списание

          EXCEPTION
            WHEN OTHERS THEN
              v_SaleID := 0;
        END;

        FOR S IN cDlfi(L.T_SUMID, p_DealID, p_DealKind)
        LOOP

          GetSumPrecisionByNewFiid(S.T_NEWFIID, p_DealKind, p_DealID, v_SumPrecision);

          SELECT FIN.T_FACEVALUEFI
            INTO v_NewCurrency
            FROM DFININSTR_DBT FIN 
           WHERE FIN.T_FIID = S.T_NEWFIID;
           
          IF v_OperSubKind = 4 /*Объединение*/ THEN
            INSERT INTO DPMWRTSUM_DBT
                        ( T_SUMID,
                          T_DOCKIND,
                          T_DOCID,
                          T_PARTNUM,
                          T_PARTY,
                          T_CONTRACT,
                          T_FIID,
                          T_PORTFOLIO,
                          T_GROUPID,
                          T_BUY_SALE,
                          T_KIND,
                          T_DATE,
                          T_TIME,
                          T_AMOUNT,
                          T_AMOUNTBD,
                          T_SUM,
                          T_CURRENCY,
                          T_COST,
                          T_BALANCECOST,
                          T_BALANCECOSTBD,
                          T_NKDAMOUNT,
                          T_BEGINTERESTDATE,
                          T_INTERESTINCOME,
                          T_NOTCARRYINTEREST,
                          T_INTERESTDATE,
                          T_BEGDATE,
                          T_BEGDISCOUNTDATE,
                          T_BEGDISCOUNT,
                          T_OLDBEGDISCOUNT,
                          T_DISCOUNTCORR,
                          T_BEGBONUSDATE,
                          T_BEGBONUS,
                          T_OLDBEGBONUS,
                          T_RECALCDATE,
                          T_DISCOUNTINCOME,
                          T_NOTCARRYDISCOUNT,
                          T_DISCOUNTDATE,
                          T_BONUS,
                          T_OLDBONUS,
                          T_BONUSDATE,
                          T_OUTLAY,
                          T_RESERVAMOUNT,
                          T_INCOMERESERV,
                          T_RESERVDATE,
                          T_OVERAMOUNT,
                          T_OVERAMOUNTBD,
                          T_OVERDATE,
                          T_COUPON,
                          T_PARTLY,
                          T_DEPARTMENT,
                          T_DEALID,
                          T_DEALDATE,
                          T_DEALCODE,
                          T_STATE,
                          T_ENTERDATE,
                          T_STATEDATE,
                          T_INSTANCE,
                          T_CHANGEDATE,
                          T_ACTION,
                          T_ID_OPERATION,
                          T_ID_STEP,
                          T_ISFREE,
                          T_TRUST,
                          T_PARENT,
                          T_SOURCE,
                          T_ISEDIT,
                          T_NOTWRTBONUS,
                          T_COSTPFI,
                          T_ACTIVATEDATE,
                          T_BLOCKAMOUNT,
                          T_BEGDEFDIFF,        
                          T_ACCOUNTEDDEFDIFF,  
                          T_DEFDIFFDATE,       
                          T_WRTOUTLAY,         
                          T_WRTOUTLAYDATE,     
                          T_VATOUTLAY,         
                          T_WRTVATOUTLAY,      
                          T_EFFECTINTERESTRATE,
                          T_FAIRVALUE,         
                          T_AMORTCOST,         
                          T_AMORTCOSTDATE,     
                          T_CORRVALUE,         
                          T_CORRDATE,          
                          T_ACCBALANCECOST,    
                          T_ACCFI,             
                          T_AMORTCALCKIND,     
                          T_ESTRESERVE,        
                          T_ESTRESERVEDATE,    
                          T_CORRINTTOEIR,      
                          T_CORRINTTOEIRDATE,  
                          T_CORRESTRESERVE,    
                          T_CORRESTRESERVEDATE,
                          T_BEGDEFDIFFDATE,
                          T_HEDGCORR,      
                          T_HEDGCORRDATE,
                          T_AMORTHEDGCORR,      
                          T_AMORTHEDGCORRDATE     
                          )
                 VALUES ( --T_SUMID,
                          0,
                          --T_DOCKIND,
                          p_Dealkind,
                          --T_DOCID,
                          p_DealID,
                          --T_PARTNUM,
                          (NVL((SELECT MAX(LOT.T_PARTNUM)
                                  FROM DPMWRTSUM_DBT LOT
                                 WHERE LOT.T_DOCKIND  = p_DealKind
                                   AND LOT.T_DOCID    = p_DealID
                                   AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
                                ), 0
                              ) + 1),
                          --T_PARTY,
                          L.T_PARTY,
                          --T_CONTRACT,
                          L.T_CONTRACT,
                          --T_FIID,
                          S.T_NEWFIID,
                          --T_PORTFOLIO,
                          L.T_PORTFOLIO,
                          --T_GROUPID,
                          L.T_GROUPID,
                          --T_BUY_SALE,
                          L.T_BUY_SALE,
                          --T_KIND,
                          WRTSUM_KIND_GB,
                          --T_DATE,
                          L.T_DATE,
                          --T_TIME,
                          L.T_TIME,
                          --T_AMOUNT,
                          case when x_UseSumPrecision = 1 then
                            round(S.T_NEWAMOUNT, v_SumPrecision)
                          else S.T_NEWAMOUNT end
                            ,
                          --T_AMOUNTBD,
                          L.T_AMOUNTBD,
                          --T_SUM,
                          L.T_SUM,
                          --T_CURRENCY,
                          L.T_CURRENCY,
                          --T_COST,
                          L.T_COST,
                          --T_BALANCECOST,
                          L.T_BALANCECOST,
                          --T_BALANCECOSTBD,
                          L.T_BALANCECOSTBD,
                          --T_NKDAMOUNT,
                          L.T_NKDAMOUNT,
                          --T_BEGINTERESTDATE,
                          L.T_BEGINTERESTDATE,
                          --T_INTERESTINCOME,
                          L.T_INTERESTINCOME,
                          --T_NOTCARRYINTEREST,
                          0,
                          --T_INTERESTDATE,
                          L.T_INTERESTDATE,
                          --T_BEGDATE,
                          L.T_BEGDATE,
                          --T_BEGDISCOUNTDATE,
                          L.T_BEGDISCOUNTDATE,
                          --T_BEGDISCOUNT,
                          L.T_BEGDISCOUNT,
                          --T_OLDBEGDISCOUNT,
                          L.T_OLDBEGDISCOUNT,
                          --T_DISCOUNTCORR,
                          L.T_DISCOUNTCORR,
                          --T_BEGBONUSDATE,
                          L.T_BEGBONUSDATE,
                          --T_BEGBONUS,
                          L.T_BEGBONUS,
                          --T_OLDBEGBONUS,
                          L.T_OLDBEGBONUS,
                          --T_RECALCDATE,
                          L.T_RECALCDATE,
                          --T_DISCOUNTINCOME,
                          L.T_DISCOUNTINCOME,
                          --T_NOTCARRYDISCOUNT,
                          0,
                          --T_DISCOUNTDATE,
                          L.T_DISCOUNTDATE,
                          --T_BONUS,
                          L.T_BONUS,
                          --T_OLDBONUS,
                          L.T_OLDBONUS,
                          --T_BONUSDATE,
                          L.T_BONUSDATE,
                          --T_OUTLAY,
                          L.T_OUTLAY,
                          --T_RESERVAMOUNT,
                          L.T_RESERVAMOUNT,
                          --T_INCOMERESERV,
                          L.T_INCOMERESERV,
                          --T_RESERVDATE,
                          L.T_RESERVDATE,
                          --T_OVERAMOUNT,
                          L.T_OVERAMOUNT,
                          --T_OVERAMOUNTBD,
                          L.T_OVERAMOUNTBD,
                          --T_OVERDATE,
                          L.T_OVERDATE,
                          --T_COUPON,
                          chr(1),
                          --T_PARTLY,
                          chr(1),
                          --T_DEPARTMENT,
                          L.T_DEPARTMENT,
                          --T_DEALID,
                          L.T_DEALID,
                          --T_DEALDATE,
                          L.T_DEALDATE,
                          --T_DEALCODE,
                          L.T_DEALCODE,
                          --T_STATE,
                          L.T_STATE,
                          --T_ENTERDATE,
                          L.T_ENTERDATE,
                          --T_STATEDATE,
                          L.T_STATEDATE,
                          --T_INSTANCE,
                          0,
                          --T_CHANGEDATE,
                          L.T_CHANGEDATE,
                          --T_ACTION,
                          PM_WRT_UPDTMODE_GLOBALIN,
                          --T_ID_OPERATION,
                          p_ID_Operation,
                          --T_ID_STEP,
                          p_ID_Step,
                          --T_ISFREE,
                          L.T_ISFREE,
                          --T_TRUST,
                          chr(0),
                          --T_PARENT,
                          v_SaleID,
                          --T_SOURCE,
                          L.T_SUMID,
                          --T_ISEDIT
                          chr(0),
                          --T_NOTWRTBONUS
                          0,
                          --T_COSTPFI
                          L.T_COSTPFI,
                          --T_ACTIVATEDATE
                          L.T_ACTIVATEDATE,
                          --T_BLOCKAMOUNT
                          L.T_BLOCKAMOUNT,
                          --T_BEGDEFDIFF         
                          L.T_BEGDEFDIFF,        
                          --T_ACCOUNTEDDEFDIFF   
                          L.T_ACCOUNTEDDEFDIFF,  
                          --T_DEFDIFFDATE        
                          L.T_DEFDIFFDATE,       
                          --T_WRTOUTLAY          
                          L.T_WRTOUTLAY,         
                          --T_WRTOUTLAYDATE      
                          L.T_WRTOUTLAYDATE,     
                          --T_VATOUTLAY          
                          L.T_VATOUTLAY,         
                          --T_WRTVATOUTLAY       
                          L.T_WRTVATOUTLAY,      
                          --T_EFFECTINTERESTRATE 
                          L.T_EFFECTINTERESTRATE,
                          --T_FAIRVALUE          
                          L.T_FAIRVALUE,         
                          --T_AMORTCOST          
                          L.T_AMORTCOST,         
                          --T_AMORTCOSTDATE      
                          L.T_AMORTCOSTDATE,     
                          --T_CORRVALUE          
                          L.T_CORRVALUE,         
                          --T_CORRDATE           
                          L.T_CORRDATE,          
                          --T_ACCBALANCECOST     
                          L.T_ACCBALANCECOST,    
                          --T_ACCFI              
                          L.T_ACCFI,             
                          --T_AMORTCALCKIND      
                          L.T_AMORTCALCKIND,     
                          --T_ESTRESERVE         
                          L.T_ESTRESERVE,        
                          --T_ESTRESERVEDATE     
                          L.T_ESTRESERVEDATE,    
                          --T_CORRINTTOEIR       
                          L.T_CORRINTTOEIR,      
                          --T_CORRINTTOEIRDATE   
                          L.T_CORRINTTOEIRDATE,  
                          --T_CORRESTRESERVE     
                          L.T_CORRESTRESERVE,    
                          --T_CORRESTRESERVEDATE 
                          L.T_CORRESTRESERVEDATE,
                          --T_BEGDEFDIFFDATE     
                          L.T_BEGDEFDIFFDATE,
                          --T_HEDGCORR       
                          L.T_HEDGCORR,      
                          --T_HEDGCORRDATE   
                          L.T_HEDGCORRDATE,
                          --T_AMORTHEDGCORR       
                          L.T_AMORTHEDGCORR,      
                          --T_AMORTHEDGCORRDATE   
                          L.T_AMORTHEDGCORRDATE     
                          );


          ELSE
            
            v_NewCostCurr := RSI_RSB_FIINSTR.ConvSum(S.T_NEWCOST, 
                                                     L.t_Currency, 
                                                     v_NewCurrency, 
                                                     p_OperDate,
                                                     1);
            if (x_UseSumPrecision = 1) then  
              v_NKD  := RSI_RSB_FIInstr.FI_CalcNKD(S.T_NEWFIID, p_OperDate, round(S.T_NEWAMOUNT, v_SumPrecision), v_IsTrust);
            else
              v_NKD  := RSI_RSB_FIInstr.FI_CalcNKD(S.T_NEWFIID, p_OperDate, S.T_NEWAMOUNT, v_IsTrust);
            end if;

            v_Cost := ROUND(v_NewCostCurr ,2) - v_NKD;

            IF (S.T_PARTY = -1 OR v_IsTrust = 1) AND WRTNeedChargeIncome(S.T_NEWFIID) = 1 THEN
              v_D := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(S.T_NEWFIID, p_OperDate) * round(S.T_NEWAMOUNT, v_SumPrecision)) - v_Cost;
              IF v_D > 0 THEN
                v_BegDiscount := v_D;
                v_BegBonus    := 0;
              ELSE
                v_BegDiscount := 0;
                IF WRTNeedChargeBonus(S.T_NEWFIID) = 1 THEN
                  v_BegBonus := -v_D;
                ELSE
                  v_BegBonus := 0;
                END IF;
              END IF;
            ELSE
              v_BegDiscount := 0;
              v_BegBonus    := 0;
            END IF;

            INSERT INTO DPMWRTSUM_DBT
                        ( T_SUMID,
                          T_DOCKIND,
                          T_DOCID,
                          T_PARTNUM,
                          T_PARTY,
                          T_CONTRACT,
                          T_FIID,
                          T_PORTFOLIO,
                          T_GROUPID,
                          T_BUY_SALE,
                          T_KIND,
                          T_DATE,
                          T_TIME,
                          T_AMOUNT,
                          T_AMOUNTBD,
                          T_SUM,
                          T_CURRENCY,
                          T_COST,
                          T_BALANCECOST,
                          T_BALANCECOSTBD,
                          T_NKDAMOUNT,
                          T_BEGINTERESTDATE,
                          T_INTERESTINCOME,
                          T_NOTCARRYINTEREST,
                          T_INTERESTDATE,
                          T_BEGDATE,
                          T_BEGDISCOUNTDATE,
                          T_BEGDISCOUNT,
                          T_OLDBEGDISCOUNT,
                          T_DISCOUNTCORR,
                          T_BEGBONUSDATE,
                          T_BEGBONUS,
                          T_OLDBEGBONUS,
                          T_RECALCDATE,
                          T_DISCOUNTINCOME,
                          T_NOTCARRYDISCOUNT,
                          T_DISCOUNTDATE,
                          T_BONUS,
                          T_OLDBONUS,
                          T_BONUSDATE,
                          T_OUTLAY,
                          T_RESERVAMOUNT,
                          T_INCOMERESERV,
                          T_RESERVDATE,
                          T_OVERAMOUNT,
                          T_OVERAMOUNTBD,
                          T_OVERDATE,
                          T_COUPON,
                          T_PARTLY,
                          T_DEPARTMENT,
                          T_DEALID,
                          T_DEALDATE,
                          T_DEALCODE,
                          T_STATE,
                          T_ENTERDATE,
                          T_STATEDATE,
                          T_INSTANCE,
                          T_CHANGEDATE,
                          T_ACTION,
                          T_ID_OPERATION,
                          T_ID_STEP,
                          T_ISFREE,
                          T_TRUST,
                          T_PARENT,
                          T_SOURCE,
                          T_ISEDIT,
                          T_NOTWRTBONUS,
                          T_COSTPFI,
                          T_ACTIVATEDATE,
                          T_BLOCKAMOUNT,
                          T_AMORTCALCKIND,
                          T_EFFECTINTERESTRATE )
                 VALUES ( --T_SUMID,
                          0,
                          --T_DOCKIND,
                          p_Dealkind,
                          --T_DOCID,
                          p_DealID,
                          --T_PARTNUM,
                          (NVL((SELECT MAX(LOT.T_PARTNUM)
                                  FROM DPMWRTSUM_DBT LOT
                                 WHERE LOT.T_DOCKIND  = p_DealKind
                                   AND LOT.T_DOCID    = p_DealID
                                   AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
                                ), 0
                              ) + 1),
                          --T_PARTY,
                          S.T_PARTY,
                          --T_CONTRACT,
                          v_Contract,
                          --T_FIID,
                          S.T_NEWFIID,
                          --T_PORTFOLIO,
                          L.T_PORTFOLIO,
                          --T_GROUPID,
                          L.T_GROUPID,
                          --T_BUY_SALE,
                          PM_WRITEOFF_SUM_BUY,
                          --T_KIND,
                          WRTSUM_KIND_GB,
                          --T_DATE,
                          L.T_DATE,
                          --T_TIME,
                          L.T_TIME,
                          --T_AMOUNT,
                          case when x_UseSumPrecision = 1 then
                            round(S.T_NEWAMOUNT, v_SumPrecision)
                          else S.T_NEWAMOUNT end
                          ,
                          --T_AMOUNTBD,
                          0,
                          --T_SUM,
                          v_Cost,
                          --T_CURRENCY,
                          v_NewCurrency,
                          --T_COST,
                          v_Cost,
                          --T_BALANCECOST,
                          v_NewCostCurr,
                          --T_BALANCECOSTBD,
                          0,
                          --T_NKDAMOUNT,
                          v_NKD,
                          --T_BEGINTERESTDATE,
                          (CASE WHEN (S.T_PARTY = -1 OR v_IsTrust = 1) AND WRTNeedChargeIncome(S.T_NEWFIID) = 1 THEN p_OperDate
                                ELSE UnknownDate END),
                          --T_INTERESTINCOME,
                          0,
                          --T_NOTCARRYINTEREST,
                          0,
                          --T_INTERESTDATE,
                          UnknownDate,
                          --T_BEGDATE,
                          L.T_BEGDATE,
                          --T_BEGDISCOUNTDATE,
                          (CASE WHEN v_BegDiscount > 0 THEN p_OperDate
                                ELSE UnknownDate END),
                          --T_BEGDISCOUNT,
                          v_BegDiscount,
                          --T_OLDBEGDISCOUNT,
                          0,
                          --T_DISCOUNTCORR,
                          0,
                          --T_BEGBONUSDATE,
                          (CASE WHEN v_BegBonus > 0 THEN p_OperDate
                                ELSE UnknownDate END),
                          --T_BEGBONUS,
                          v_BegBonus,
                          --T_OLDBEGBONUS,
                          0,
                          --T_RECALCDATE,
                          UnknownDate,
                          --T_DISCOUNTINCOME,
                          0,
                          --T_NOTCARRYDISCOUNT,
                          0,
                          --T_DISCOUNTDATE,
                          UnknownDate,
                          --T_BONUS,
                          0,
                          --T_OLDBONUS,
                          0,
                          --T_BONUSDATE,
                          UnknownDate,
                          --T_OUTLAY,
                          0,
                          --T_RESERVAMOUNT,
                          0,
                          --T_INCOMERESERV,
                          0,
                          --T_RESERVDATE,
                          UnknownDate,
                          --T_OVERAMOUNT,
                          0,
                          --T_OVERAMOUNTBD,
                          0,
                          --T_OVERDATE,
                          UnknownDate,
                          --T_COUPON,
                          chr(1),
                          --T_PARTLY,
                          chr(1),
                          --T_DEPARTMENT,
                          L.T_DEPARTMENT,
                          --T_DEALID,
                          L.T_DEALID,
                          --T_DEALDATE,
                          L.T_DEALDATE,
                          --T_DEALCODE,
                          L.T_DEALCODE,
                          --T_STATE,
                          PM_WRTSUM_FORM,
                          --T_ENTERDATE,
                          p_OperDate,
                          --T_STATEDATE,
                          p_OperDate,
                          --T_INSTANCE,
                          0,
                          --T_CHANGEDATE,
                          p_OperDate,
                          --T_ACTION,
                          PM_WRT_UPDTMODE_GLOBALIN,
                          --T_ID_OPERATION,
                          p_ID_Operation,
                          --T_ID_STEP,
                          p_ID_Step,
                          --T_ISFREE,
                          'X',
                          --T_TRUST,
                          chr(0),
                          --T_PARENT,
                          v_SaleID,
                          --T_SOURCE,
                          L.T_SUMID,
                          --T_ISEDIT
                          chr(0),
                          --T_NOTWRTBONUS
                          0,
                          --T_COSTPFI
                          0,
                          --T_ACTIVATEDATE
                          p_OperDate,
                          --T_BLOCKAMOUNT
                          0,
                          --T_AMORTCALCKIND
                          L.T_AMORTCALCKIND,
                          --T_EFFECTINTERESTRATE
                          L.T_EFFECTINTERESTRATE
                          );
          END IF;

        END LOOP;

     END LOOP;

     FOR one_cl IN (SELECT L.T_ID, L.T_FIID, L.T_DEPARTMENT, L.T_CONTRACT, L.T_PARTY
                      FROM DPMWRTCL_DBT L
                     WHERE EXISTS( SELECT 1
                                     FROM DSCDLPMWR_DBT S
                                    WHERE S.T_DEALKIND = p_DealKind
                                      AND S.T_DEALID   = p_DealID
                                      AND S.T_SUMID    = L.T_ID
                                      AND S.T_PARTY    = L.T_PARTY
                                      AND S.T_KIND     = 2
                                 )
                   )
     LOOP

       FOR one_s IN (SELECT 
                         /*(case when x_UseSumPrecision = 1 then
                           round(S.T_NEWAMOUNT, v_SumPrecision)
                         else S.T_NEWAMOUNT end)*/ T_NEWAMOUNT
                           , S.T_DATE, F.T_NEWFIID
                       FROM DSCDLPMWR_DBT S, DSCDLFI_DBT F
                      WHERE S.T_DEALKIND = p_DealKind
                        AND S.T_DEALID = p_DealID
                        AND S.T_SUMID = one_cl.T_ID
                        AND S.T_PARTY <> -1
                        AND S.T_KIND = 2
                        AND F.T_DEALKIND = S.T_DEALKIND
                        AND F.T_DEALID = S.T_DEALID
                        AND F.T_NEWFIID = S.T_NEWFIID
                      ORDER BY F.T_NUM
                    )
       LOOP
         GetSumPrecisionByNewFiid(one_s.t_newfiid, p_DealKind, p_DealID, v_SumPrecision);

         RSI_WRTSetClientLot(
           one_s.T_NEWFIID, one_cl.T_DEPARTMENT, 
           one_cl.T_PARTY, one_cl.T_CONTRACT, 
           case when x_UseSumPrecision = 1 then
             round(one_s.T_NEWAMOUNT, v_SumPrecision)
             else one_s.T_NEWAMOUNT end,
           p_OperDate, p_ID_Operation, p_ID_Step, 1);
         RSI_WRTDelAndCheckClientLots(
           one_s.T_NEWFIID, one_cl.T_DEPARTMENT, one_cl.T_PARTY, 
           one_cl.T_CONTRACT, p_ID_Operation, p_ID_Step, 0);
       END LOOP;

     END LOOP;


   END; --RSI_WRTGlobalConvert

   ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет откат зачисления при глобальной конвертации лотов. Ее нет в проекте
   PROCEDURE RSI_WRTRestoreAfterGlConv( p_ID_Operation IN NUMBER,   -- Операция
                                        p_ID_Step      IN NUMBER,   -- Шаг операции, где корректируются лоты
                                        p_OperDate     IN DATE,     -- Дата операции ГО
                                        p_Department   IN NUMBER    -- Филиал в операции ГО
                                      )
   IS
     v_DealKind NUMBER;
     v_DealID   NUMBER;
     v_Count NUMBER;
     
     v_SumPrecision NUMBER :=6;


   BEGIN
     InitError();

     SELECT T_DOCKIND, TO_NUMBER(T_DOCUMENTID) INTO v_DealKind, v_DealID
       FROM DOPROPER_DBT
      WHERE T_ID_OPERATION = p_ID_Operation;

     RSI_WRTRestoreLot( p_ID_Operation, p_ID_Step, PM_WRT_UPDTMODE_GLOBALIN );

     SELECT Count(1) INTO v_Count
       FROM DSCDLPMWR_DBT S, DPMWRTCL_DBT L, DPMWRTCL_DBT L_OLD, DSCDLFI_DBT F
      WHERE S.T_DEALKIND = v_DealKind
        AND S.T_DEALID = v_DealID
        AND S.T_PARTY <> -1
        AND S.T_KIND = 2
        AND F.T_DEALKIND = S.T_DEALKIND
        AND F.T_DEALID = S.T_DEALID
        AND L_OLD.T_ID = S.T_SUMID
        AND L.T_PARTY = L_OLD.T_PARTY
        AND L.T_CONTRACT = L_OLD.T_CONTRACT
        AND L.T_FIID = F.T_NEWFIID
        AND L.T_DEPARTMENT = p_Department
        AND L.T_AMOUNT > 0
        AND L.T_ENDDATE >= p_OperDate
        AND L.T_ENDDATE <> TO_DATE('31.12.9999','DD.MM.YYYY');

     IF( v_Count > 0 ) THEN
        SetError( WRTOFF_ERROR_20220 ); --По лотам есть операции за более позднюю дату
     END IF;

     FOR one_l IN (
       SELECT S.T_NEWFIID, L.T_DEPARTMENT, L.T_PARTY, L.T_CONTRACT, 
                          S.T_NEWAMOUNT, S.T_DATE
                     FROM DSCDLPMWR_DBT S, DPMWRTCL_DBT L, DSCDLFI_DBT F
                    WHERE S.T_DEALKIND = v_DealKind
                      AND S.T_DEALID = v_DealID
                      AND S.T_SUMID = L.T_ID
                      AND S.T_PARTY <> -1
                      AND S.T_KIND = 2
                      AND F.T_DEALKIND = S.T_DEALKIND
                      AND F.T_DEALID = S.T_DEALID
                      AND F.T_NEWFIID = S.T_NEWFIID
                  )
     LOOP

       GetSumPrecisionByNewFiid(one_l.t_newfiid, v_DealKind, v_DealID, v_SumPrecision);

--v_SumPrecision := 6; -- TODO удалить

       RSI_WRTSetClientLot(one_l.T_NEWFIID, one_l.T_DEPARTMENT, 
                           one_l.T_PARTY, one_l.T_CONTRACT, -round(one_l.T_NEWAMOUNT,v_SumPrecision), 
                           p_OperDate, p_ID_Operation, p_ID_Step, 1);

       RSI_WRTDelAndCheckClientLots(one_l.T_NEWFIID, one_l.T_DEPARTMENT, one_l.T_PARTY, one_l.T_CONTRACT, p_ID_Operation, p_ID_Step, 0);

     END LOOP;

   END;--RSI_WRTRestoreAfterGlConv

   ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет откат отказа и локального перемещения. Ее нет в проекте
   PROCEDURE RSI_WRTRestoreAfterGlAct( p_DocKind      IN NUMBER,   -- Вид документа операции
                                          p_DocID        IN NUMBER,   -- Идентификатор документа операции
                                          p_ID_Operation IN NUMBER,   -- Операция
                                          p_ID_Step      IN NUMBER    -- Шаг операции, где корректируются лоты
                                        )
   IS
      v_Count         NUMBER := 0;
      v_UpdtMode      NUMBER := 0;
   BEGIN
     InitError();

     -- Удалить лоты  вида  "Перемещение в портфель", созданные на шаге ID_Operation/ID_Step

     -- Если по таким лотам были операции после создания этих лотов (т.е. записи в pmwrtbc по ним), то взводим ошибку
     SELECT count(1) INTO v_Count
       FROM DPMWRTSUM_DBT s, DPMWRTBC_DBT bc
      WHERE s.T_DOCKIND  = p_DocKind
        AND s.T_DOCID    = p_DocID
        AND s.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
        AND s.T_SUMID    = bc.T_SUMID
        AND s.T_PARTNUM <> 1;

     IF( v_Count > 0 ) THEN
        SetError( WRTOFF_ERROR_20220 ); --По лотам есть операции за более позднюю дату
     ELSE
        DELETE
          FROM DPMWRTSUM_DBT
         WHERE T_DOCKIND  = p_DocKind
           AND T_DOCID    = p_DocID
           AND T_BUY_SALE = PM_WRITEOFF_SUM_BUY
           AND T_PARTNUM <> 1;
     END IF;

     -- Удалить связи, созданные на шаге ID_Operation/ID_Step
     DELETE FROM DPMWRTLNK_DBT
      WHERE T_ID_Operation = p_ID_Operation
        AND T_ID_Step      = p_ID_Step;

     -- Удалить лоты  вида  "Списание из портфеля", созданные на шаге ID_Operation/ID_Step.
     -- Это только для глобальных операций и отказов. Не для перемещений.
     IF (p_DocKind <> 105) THEN --DL_MOVINGDOC

        -- Если по таким лотам были операции после создания этих лотов (т.е. записи в pmwrtbc по ним), то взводим ошибку
        SELECT count(1) INTO v_Count
          FROM DPMWRTSUM_DBT s, DPMWRTBC_DBT bc
         WHERE s.T_DOCKIND  = p_DocKind
           AND s.T_DOCID    = p_DocID
           AND s.T_BUY_SALE = PM_WRITEOFF_SUM_SALE
           AND s.T_SUMID    = bc.T_SUMID
           AND s.T_PARTNUM <> 1;

        IF( v_Count > 0 ) THEN
           SetError( WRTOFF_ERROR_20220 ); --По лотам есть операции за более позднюю дату
        ELSE
           DELETE
             FROM DPMWRTSUM_DBT
            WHERE T_DOCKIND  = p_DocKind
              AND T_DOCID    = p_DocID
              AND T_BUY_SALE = PM_WRITEOFF_SUM_SALE
              AND T_PARTNUM <> 1;
        END IF;

        IF (p_DocKind = 135) THEN
           v_UpdtMode := PM_WRT_UPDTMODE_GLOBALCONV;
        ELSE
           v_UpdtMode := PM_WRT_UPDTMODE_REJECTEXEC;
        END IF;

        RSI_WRTRestoreLot( p_ID_Operation, p_ID_Step, v_UpdtMode );
     END IF;

   END;--RSI_WRTRestoreAfterGlAct


   ---- Выполняет списание при глобальной конвертации лотов.
   PROCEDURE RSI_WRTGlobalWriteOff( p_DealKind     IN NUMBER,   -- Вид документа операции
                                    p_DealID       IN NUMBER,   -- Идентификатор документа операции
                                    p_DealCode     IN VARCHAR2, -- Код операции
                                    p_OperDate     IN DATE,     -- Дата списания
                                    p_OldFIID      IN NUMBER,   -- Старая ц/б
                                    p_IsTrust      IN NUMBER,   -- Признак ДУ
                                    p_Department   IN NUMBER,   -- Филиал
                                    p_ID_Operation IN NUMBER,   -- Операция
                                    p_ID_Step      IN NUMBER,   -- Шаг операции
                                    p_CalcIncome   IN NUMBER    -- Расчитывать доход
                                  )
   IS
      v_N            NUMBER := 0;
      v_Count        NUMBER := 0;
      v_Party        NUMBER := 0;
      v_Contract     NUMBER := 0;
      v_Amount       NUMBER := 0;
      v_SaleLot      DPMWRTSUM_DBT%ROWTYPE;
      v_PartNum      NUMBER := 1;
      v_Method       NUMBER := 0;
      v_CalcOver     NUMBER := 0;
      v_CalcDiscount NUMBER := 0;
      v_CalcInterest NUMBER := 0;
      v_CalcBonus    NUMBER := 0;
      v_FaceValueFI  NUMBER := -1;
      PrevSumID      NUMBER := 0;
      v_OperSubKind  NUMBER := 0;

      CURSOR cPmwr (v_DealID IN NUMBER, v_DealKind IN NUMBER) IS
      SELECT LOT.T_SUMID
        FROM DSCDLPMWR_DBT S, DPMWRTSUM_DBT LOT, DDLRQ_DBT RQD
       WHERE S.T_DEALKIND  = v_DealKind
         AND S.T_DEALID    = v_DealID
         AND S.T_SUMID     = LOT.T_SUMID
         AND S.T_STATE     = SCDLPMWR_STATE_NOT_READY
         AND S.T_KIND      = 1
         AND LOT.T_DOCKIND = 29 --Платеж
         AND LOT.T_DOCID   = RQD.T_ID
         AND EXISTS( SELECT 1
                       FROM DDLRQ_DBT RQP
                      WHERE RQP.T_DOCID = RQD.T_ID
                        AND RQP.T_DOCKIND = RQD.T_DOCKIND
                        AND RQP.T_TYPE IN (rsi_dlrq.DLRQ_TYPE_AVANCE, rsi_dlrq.DLRQ_TYPE_PAYMENT, rsi_dlrq.DLRQ_TYPE_DEPOSIT)
                        AND RQP.T_DEALPART = 1
                        AND RQP.T_STATE = rsi_dlrq.DLRQ_STATE_EXEC
                   );

      CURSOR cPC (v_DealID IN NUMBER, v_DealKind IN NUMBER) IS
      SELECT S.T_PARTY, L.T_CONTRACT, SUM(S.T_OLDAMOUNT) AS T_OLDAMOUNT
        FROM DSCDLPMWR_DBT S, DPMWRTSUM_DBT L
       WHERE S.T_DEALKIND = v_DealKind
         AND S.T_DEALID   = v_DealID
         AND S.T_SUMID    = L.T_SUMID
         AND S.T_STATE    = SCDLPMWR_STATE_READY
         AND S.T_KIND     = 1
         AND L.T_PARTY    = S.T_PARTY
         GROUP BY S.T_PARTY, L.T_CONTRACT;

      CURSOR cPC_ByParty (v_DealID IN NUMBER, v_DealKind IN NUMBER, v_Party IN NUMBER, v_Contract IN NUMBER) IS
      SELECT S.T_SUMID, S.T_OLDAMOUNT
        FROM DSCDLPMWR_DBT S, DPMWRTSUM_DBT L
       WHERE S.T_DEALKIND = v_DealKind
         AND S.T_DEALID   = v_DealID
         AND S.T_SUMID    = L.T_SUMID
         AND S.T_STATE    = SCDLPMWR_STATE_READY
         AND S.T_PARTY    = v_Party
         AND S.T_KIND     = 1
         AND L.T_CONTRACT = v_Contract;

      CURSOR cGroup (v_DealID IN NUMBER, v_DealKind IN NUMBER, v_Party IN NUMBER, v_Contract IN NUMBER) IS
      SELECT L2.T_GROUPID
        FROM DSCDLPMWR_DBT S2, DPMWRTSUM_DBT L2
       WHERE S2.T_DEALKIND = v_DealKind
         AND S2.T_DEALID   = v_DealID
         AND S2.T_SUMID    = L2.T_SUMID
         AND S2.T_STATE    = SCDLPMWR_STATE_READY
         AND S2.T_PARTY    = v_Party
         AND S2.T_KIND     = 1
         AND L2.T_CONTRACT = v_Contract
       GROUP BY L2.T_GROUPID;


   BEGIN
      InitError();

      SELECT t_OperSubKind INTO v_OperSubKind
       FROM ddl_comm_dbt
      WHERE t_DocKind = p_DealKind
        AND t_DocumentID = p_DealID;

      SELECT Count(1) INTO v_N
        FROM DSCDLFI_DBT
       WHERE T_DEALKIND = p_DealKind
         AND T_DEALID = p_DealID;

      --Перед выполнением проверяется, что список лотов остался актуальным
      IF (p_OperDate <> RsbSessionData.curdate) THEN
        SELECT COUNT(1) INTO v_Count
          FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
         WHERE L.T_FIID       = p_OldFIID
           AND L.T_DEPARTMENT = p_Department
           AND L.T_TRUST      = (CASE WHEN p_IsTrust = 0 THEN CHR(0) ELSE 'X' END)
           AND L.T_CHANGEDATE > p_OperDate
           AND B.T_SUMID      = L.T_SUMID
           AND (B.T_STATE IN (PM_WRTSUM_NOTFORM, PM_WRTSUM_SALE_BPP) OR
                (B.T_STATE = PM_WRTSUM_FORM AND
                 L.T_BUY_SALE IN (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO) AND
                 B.T_AMOUNT > 0) )

           AND (B.T_INSTANCE = (SELECT MAX(M.T_INSTANCE)
                                  FROM DPMWRTBC_DBT M
                                 WHERE M.T_CHANGEDATE <= p_OperDate
                                   AND M.T_SUMID      = L.T_SUMID
                               ) );

        IF v_Count <> 0 THEN
           SetError( WRTOFF_ERROR_20221 ); --По лотам старого выпуска есть операции за более позднюю дату
        END IF;
      END IF;

      --Проверяется, что задним числом не повявилось новых собственных лотов старого выпуска
      SELECT COUNT(1) INTO v_Count
        FROM DPMWRTSUM_DBT L, DDLRQ_DBT RQD
       WHERE L.T_FIID       = p_OldFIID
         AND L.T_TRUST      = (CASE WHEN p_IsTrust = 0 THEN CHR(0) ELSE 'X' END)
         AND L.T_DEPARTMENT = p_Department
         AND L.T_STATE      = PM_WRTSUM_NOTFORM --Не поставлен
         AND L.T_DOCKIND    = 29 --Платеж
         AND RQD.T_ID = L.T_DOCID
         AND EXISTS( SELECT 1
                       FROM DDLRQ_DBT RQP
                      WHERE RQP.T_DOCID = RQD.T_DOCID
                        AND RQP.T_DOCKIND = RQD.T_DOCKIND
                        AND RQP.T_TYPE IN (rsi_dlrq.DLRQ_TYPE_AVANCE, rsi_dlrq.DLRQ_TYPE_PAYMENT, rsi_dlrq.DLRQ_TYPE_DEPOSIT)
                        AND RQP.T_DEALPART = 1
                        AND RQP.T_STATE = rsi_dlrq.DLRQ_STATE_EXEC
                   )
         AND NOT EXISTS(SELECT 1
                          FROM DSCDLPMWR_DBT S
                         WHERE S.T_DEALKIND = p_DealKind
                           AND S.T_DEALID   = p_DealID
                           AND S.T_SUMID    = L.T_SUMID
                           AND S.T_PARTY    = L.T_PARTY
                           AND S.T_KIND     = 1
                       );
      IF v_N = 1 AND v_Count <> 0 THEN
         SetError( WRTOFF_ERROR_20227 ); --Появился непоставленный лот старого выпуска, не занесенный в список корректируемых лотов
      END IF;


      SELECT COUNT(1) INTO v_Count
        FROM DPMWRTSUM_DBT L
       WHERE L.T_FIID       = p_OldFIID
         AND L.T_TRUST      = (CASE WHEN p_IsTrust = 0 THEN CHR(0) ELSE 'X' END)
         AND L.T_DEPARTMENT = p_Department
         AND L.T_STATE      = PM_WRTSUM_FORM
         AND L.T_BUY_SALE   = PM_WRITEOFF_SUM_BUY
         AND L.T_AMOUNT     > 0
         AND NOT EXISTS( SELECT 1 FROM DSCDLPMWR_DBT WR
                          WHERE WR.T_DEALKIND = p_DealKind
                            AND WR.T_DEALID   = p_DealID
                            AND WR.T_SUMID    = L.T_SUMID
                            AND WR.T_PARTY    = L.T_PARTY
                            AND WR.T_KIND     = 1
                       );
      IF v_Count <> 0 THEN
         SetError( WRTOFF_ERROR_20228 ); --Появился поставленный лот старого выпуска, не занесенный в список корректируемых лотов
      END IF;


      SELECT COUNT(1) INTO v_Count
        FROM DPMWRTCL_DBT L
       WHERE L.T_FIID = p_OldFIID
         AND L.T_DEPARTMENT = p_Department
         AND L.T_AMOUNT > 0
         AND L.T_ENDDATE >= p_OperDate
         AND NOT EXISTS( SELECT 1 FROM DSCDLPMWR_DBT WR
                          WHERE WR.T_DEALKIND = p_DealKind
                            AND WR.T_DEALID   = p_DealID
                            AND WR.T_SUMID    = L.T_ID
                            AND WR.T_PARTY    = L.T_PARTY
                            AND WR.T_KIND     = 2
                       );
      IF v_Count <> 0 THEN
         SetError( WRTOFF_ERROR_20228 ); --Появился поставленный лот старого выпуска, не занесенный в список корректируемых лотов
      END IF;


      SELECT COUNT(1) INTO v_Count FROM DSCDLPMWR_DBT WHERE T_DEALID = p_DealID AND T_DEALKIND = p_DealKind;
      IF v_Count = 0 THEN
         RETURN;
      END IF;

      -- Проверяется, что собственные лоты с момента сохранения списка не поменялись в фоновом режиме
      SELECT COUNT(1) INTO v_Count
        FROM DSCDLPMWR_DBT S, DPMWRTSUM_DBT LOT
       WHERE S.T_DEALKIND = p_DealKind
         AND S.T_DEALID = p_DealID
         AND S.T_SUMID = LOT.T_SUMID
         AND S.T_PARTY = LOT.T_PARTY
         AND S.T_KIND  = 1
         AND S.T_OLDINSTANCE != LOT.T_INSTANCE;
      IF v_Count <> 0 THEN
         SetError( WRTOFF_ERROR_20223 ); --Лоты старого выпуска изменились с момента составления списка корректируемых лотов
      END IF;

      -- Проверяется, что клиентские лоты с момента сохранения списка не поменялись в фоновом режиме
      SELECT COUNT(1) INTO v_Count
        FROM DSCDLPMWR_DBT S, DPMWRTCL_DBT LOT
       WHERE S.T_DEALKIND = p_DealKind
         AND S.T_DEALID   = p_DealID
         AND S.T_SUMID    = LOT.T_ID
         AND S.T_PARTY    = LOT.T_PARTY
         AND S.T_KIND     = 2
         AND (S.T_OLDAMOUNT <> LOT.T_AMOUNT OR S.T_DATE <> LOT.T_BEGDATE OR LOT.T_ENDDATE <> TO_DATE('31.12.9999','DD.MM.YYYY'));
      IF v_Count <> 0 THEN
         SetError( WRTOFF_ERROR_20223 ); --Лоты старого выпуска изменились с момента составления списка корректируемых лотов
      END IF;


      SELECT Count(1) INTO v_N
        FROM DSCDLFI_DBT
       WHERE T_DEALKIND = p_DealKind
         AND T_DEALID = p_DealID;


      FOR LOT IN cPmwr(p_DealID, p_DealKind)
      LOOP
         RSI_WRTSaveLot(LOT.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_GLOBALOUT);

         UPDATE DPMWRTSUM_DBT
            SET T_STATE = (CASE WHEN v_N = 1 THEN PM_WRTSUM_DELAY ELSE PM_WRTSUM_CANCEL END),
                T_STATEDATE = p_OperDate
          WHERE T_SUMID = LOT.T_SUMID;

      END LOOP;

      FOR S IN cPC(p_DealID, p_DealKind)
      LOOP
         v_Party    := S.T_PARTY;
         v_Contract := S.T_CONTRACT;

         v_Amount := 0;
         PrevSumID := 0;
         FOR S_Party IN cPC_ByParty(p_DealID, p_DealKind, v_Party, v_Contract)
         LOOP
            if (S_Party.t_SumID <> PrevSumID) then
               v_Amount := v_Amount + S_Party.t_OldAmount;
               PrevSumID := S_Party.t_SumID;
            end if;
         END LOOP;

         v_SaleLot.T_SUMID            := 0;
         v_SaleLot.T_DOCKIND          := p_DealKind;
         v_SaleLot.T_DOCID            := p_DealID;
         v_SaleLot.T_PARTNUM          := v_PartNum;
         v_SaleLot.T_PARTY            := v_Party;
         v_SaleLot.T_CONTRACT         := v_Contract;
         v_SaleLot.T_FIID             := p_OldFIID;
         v_SaleLot.T_PORTFOLIO        := -1;
         v_SaleLot.T_GROUPID          := -1;
         v_SaleLot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE;
         v_SaleLot.T_KIND             := WRTSUM_KIND_GS;
         v_SaleLot.T_DATE             := p_OperDate;
         v_SaleLot.T_TIME             := UnknownTime;
         v_SaleLot.T_AMOUNT           := v_Amount;
         v_SaleLot.T_AMOUNTBD         := 0;
         v_SaleLot.T_SUM              := 0;
         v_SaleLot.T_CURRENCY         := 0;
         v_SaleLot.T_COST             := 0;
         v_SaleLot.T_BALANCECOST      := 0;
         v_SaleLot.T_BALANCECOSTBD    := 0;
         v_SaleLot.T_NKDAMOUNT        := 0;
         v_SaleLot.T_BEGINTERESTDATE  := UnknownDate;
         v_SaleLot.T_INTERESTINCOME   := 0;
         v_SaleLot.T_NOTCARRYINTEREST := 0;
         v_SaleLot.T_INTERESTDATE     := UnknownDate;
         v_SaleLot.T_BEGDATE          := UnknownDate;
         v_SaleLot.T_BEGDISCOUNTDATE  := UnknownDate;
         v_SaleLot.T_BEGDISCOUNT      := 0;
         v_SaleLot.T_OLDBEGDISCOUNT   := 0;
         v_SaleLot.T_DISCOUNTCORR     := 0;
         v_SaleLot.T_BEGBONUSDATE     := UnknownDate;
         v_SaleLot.T_BEGBONUS         := 0;
         v_SaleLot.T_OLDBEGBONUS      := 0;
         v_SaleLot.T_RECALCDATE       := UnknownDate;
         v_SaleLot.T_DISCOUNTINCOME   := 0;
         v_SaleLot.T_NOTCARRYDISCOUNT := 0;
         v_SaleLot.T_DISCOUNTDATE     := UnknownDate;
         v_SaleLot.T_BONUS            := 0;
         v_SaleLot.T_BONUSDATE        := UnknownDate;
         v_SaleLot.T_OUTLAY           := 0;
         v_SaleLot.T_RESERVAMOUNT     := 0;
         v_SaleLot.T_INCOMERESERV     := 0;
         v_SaleLot.T_RESERVDATE       := UnknownDate;
         v_SaleLot.T_OVERAMOUNT       := 0;
         v_SaleLot.T_OVERAMOUNTBD     := 0;
         v_SaleLot.T_OVERDATE         := UnknownDate;
         v_SaleLot.T_COUPON           := CHR(0);
         v_SaleLot.T_PARTLY           := CHR(0);
         v_SaleLot.T_DEPARTMENT       := p_Department;
         v_SaleLot.T_DEALID           := p_DealID;
         v_SaleLot.T_DEALDATE         := p_OperDate;
         v_SaleLot.T_DEALCODE         := p_DealCode;
         v_SaleLot.T_STATE            := PM_WRTSUM_FORM;
         v_SaleLot.T_ENTERDATE        := p_OperDate;
         v_SaleLot.T_STATEDATE        := p_OperDate;
         v_SaleLot.T_INSTANCE         := 0;
         v_SaleLot.T_CHANGEDATE       := p_OperDate;
         v_SaleLot.T_ACTION           := PM_WRT_UPDTMODE_DELIVERY;
         v_SaleLot.T_ID_OPERATION     := p_ID_Operation;
         v_SaleLot.T_ID_STEP          := p_ID_Step;
         v_SaleLot.T_ISFREE           := CHR(0);
         v_SaleLot.T_TRUST            := CHR(0);
         v_SaleLot.T_PARENT           := 0;
         v_SaleLot.T_SOURCE           := 0;
         v_SaleLot.T_ISEDIT           := CHR(0);
         v_SaleLot.T_ACTIVATEDATE     := p_OperDate;
         v_SaleLot.T_ACTIVATETIME     := UnknownTime;
         v_SaleLot.T_BLOCKAMOUNT      := 0;

         RSI_InsDfltIntoWRTSUM(v_SaleLot);
         INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.T_SUMID;

         v_PartNum := v_PartNum + 1;

         v_Method := GetAmortizationMethod( v_Party, v_Contract );

         if( v_Method = UnknownValue ) then
           SetError( WRTOFF_ERROR_20207 );
         end if;

         SELECT T_FACEVALUEFI INTO v_FaceValueFI FROM DFININSTR_DBT WHERE T_FIID = p_OldFIID;
         IF RSI_RSB_FIInstr.NATCUR = v_FaceValueFI OR v_OperSubKind = 4 /*Объединение*/ THEN
            v_CalcOver := 0;
         ELSE
            v_CalcOver := 1;
         END IF;

         IF (v_Party = -1 OR p_IsTrust = 1) AND v_Method <> PM_WRITEOFF_AVERAGE AND v_OperSubKind <> 4 /*Объединение*/ AND WRTNeedChargeIncome(p_OldFIID) <> 0 AND p_CalcIncome <> 0 THEN
           v_CalcDiscount := 1;
         ELSE
           v_CalcDiscount := 0;
         END IF;

         IF (v_Party = -1 OR p_IsTrust = 1) AND v_Method <> PM_WRITEOFF_AVERAGE AND v_OperSubKind <> 4 /*Объединение*/ AND WRTNeedChargeInterestIncome(p_OldFIID) <> 0 AND p_CalcIncome <> 0 THEN
           v_CalcInterest := 1;
         ELSE
           v_CalcInterest := 0;
         END IF;

         IF (v_Party = -1 OR p_IsTrust = 1) AND v_Method <> PM_WRITEOFF_AVERAGE AND v_OperSubKind <> 4 /*Объединение*/ AND WRTNeedChargeBonus(p_OldFIID) <> 0 AND p_CalcIncome <> 0 THEN
           v_CalcBonus := 1;
         ELSE
           v_CalcBonus := 0;
         END IF;

         FOR OneGroup IN cGroup (p_DealID, p_DealKind, v_Party, v_Contract)
         LOOP
            RSI_WRTLinkSaleToBuy(v_SaleLot,
                                 -1,
                                 OneGroup.T_GROUPID,
                                 NULL,
                                 v_Method,
                                 0,
                                 p_ID_Operation,
                                 p_ID_Step,
                                 PMWRTLINK_KIND_PORTFOLIO,
                                 PM_WRT_UPDTMODE_GLOBALOUT,
                                 (CASE WHEN v_CalcInterest = 0 THEN FALSE ELSE TRUE END),
                                 (CASE WHEN v_CalcDiscount = 0 THEN FALSE ELSE TRUE END),
                                 (CASE WHEN v_CalcBonus = 0 THEN FALSE ELSE TRUE END),
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 (CASE WHEN v_CalcOver = 0 THEN FALSE ELSE TRUE END)
                                );
         END LOOP;

      END LOOP;

      FOR one_lot IN (SELECT DISTINCT L.T_FIID, L.T_DEPARTMENT, L.T_PARTY, L.T_CONTRACT, S.T_DATE,
                             S.T_OLDAMOUNT
                        FROM DSCDLPMWR_DBT S, DPMWRTCL_DBT L
                       WHERE S.T_DEALKIND = p_DealKind
                         AND S.T_DEALID   = p_DealID
                         AND S.T_SUMID    = L.T_ID
                         AND S.T_PARTY    <> -1
                         AND S.T_KIND     = 2
                     )
      LOOP
        RSI_WRTSetClientLot(one_lot.T_FIID, one_lot.T_DEPARTMENT, one_lot.T_PARTY, one_lot.T_CONTRACT, -one_lot.T_OLDAMOUNT, p_OperDate, p_ID_Operation, p_ID_Step, 1);
      END LOOP;


      SELECT COUNT(1) INTO v_Count
        FROM DPMWRTCL_DBT L
       WHERE L.T_FIID = p_OldFIID
         AND L.T_DEPARTMENT = p_Department
         AND L.T_AMOUNT > 0
         AND L.T_ENDDATE >= p_OperDate;
      IF v_Count <> 0 THEN
         SetError( WRTOFF_ERROR_20242 ); --Списаны не все лоты конвертируемого выпуска
      END IF;
   END; --RSI_WRTGlobalWriteOff

   ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет откат списания при глобальной конвертации лотов. Ее нет в проекте
   PROCEDURE RSI_WRTRestoreAfterGlWrtOff( p_DocKind      IN NUMBER,   -- Вид документа операции
                                          p_DocID        IN NUMBER,   -- Идентификатор документа операции
                                          p_ID_Operation IN NUMBER,   -- Операция
                                          p_ID_Step      IN NUMBER    -- Шаг операции, где корректируются лоты
                                        )
   IS
      v_Count NUMBER := 0;

      v_OperDate DATE;
      v_Department NUMBER;
      v_OldFIID NUMBER;

   BEGIN
     InitError();

     SELECT T_COMMDATE, T_DIVISION, T_FIID INTO v_OperDate, v_Department, v_OldFIID
       FROM DDL_COMM_DBT
      WHERE T_DOCKIND = p_DocKind
        AND T_DOCUMENTID = p_DocID;

     DELETE FROM DPMWRTLNK_DBT
      WHERE T_ID_Operation = p_ID_Operation
        AND T_ID_Step      = p_ID_Step;

     -- Если по таким лотам были операции после создания этих лотов (т.е. записи в pmwrtbc по ним), то взводим ошибку
     SELECT count(1) INTO v_Count
       FROM DPMWRTSUM_DBT s, DPMWRTBC_DBT bc
      WHERE s.T_DOCKIND  = p_DocKind
        AND s.T_DOCID    = p_DocID
        AND s.T_BUY_SALE = PM_WRITEOFF_SUM_SALE
        AND s.T_SUMID    = bc.T_SUMID;

     IF( v_Count > 0 ) THEN
        SetError( WRTOFF_ERROR_20220 ); --По лотам есть операции за более позднюю дату
     ELSE
        DELETE
          FROM DPMWRTSUM_DBT
         WHERE T_DOCKIND  = p_DocKind
           AND T_DOCID    = p_DocID
           AND T_BUY_SALE = PM_WRITEOFF_SUM_SALE;
     END IF;

     RSI_WRTRestoreLot( p_ID_Operation, p_ID_Step, PM_WRT_UPDTMODE_GLOBALOUT );

     SELECT COUNT(1) INTO v_Count
       FROM DPMWRTCL_DBT L
      WHERE L.T_FIID = v_OldFIID
        AND L.T_DEPARTMENT = v_Department
        AND L.T_AMOUNT > 0
        AND L.T_ENDDATE >= v_OperDate
        AND L.T_ENDDATE <> TO_DATE('31.12.9999','DD.MM.YYYY');
     IF v_Count <> 0 THEN
        SetError( WRTOFF_ERROR_20220 ); --По лотам есть операции за более позднюю дату
     END IF;

     FOR one_lot IN (SELECT DISTINCT L.T_FIID, L.T_DEPARTMENT, L.T_PARTY, L.T_CONTRACT, S.T_OLDAMOUNT, S.T_DATE
                       FROM DSCDLPMWR_DBT S, DPMWRTCL_DBT L
                      WHERE S.T_DEALKIND = p_DocKind
                        AND S.T_DEALID = p_DocID
                        AND S.T_SUMID = L.T_ID
                        AND S.T_PARTY <> -1
                        AND S.T_KIND = 2
                    )
     LOOP
       RSI_WRTSetClientLot(one_lot.T_FIID, one_lot.T_DEPARTMENT, one_lot.T_PARTY, one_lot.T_CONTRACT, one_lot.T_OLDAMOUNT, v_OperDate, p_ID_Operation, p_ID_Step, 1);
       RSI_WRTDelAndCheckClientLots(one_lot.T_FIID, one_lot.T_DEPARTMENT, one_lot.T_PARTY, one_lot.T_CONTRACT, p_ID_Operation, p_ID_Step, 0);
     END LOOP;

   END;--RSI_WRTRestoreAfterGlWrtOff


   ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет глобальное перемещение лотов.
   PROCEDURE RSI_WRTGlobalMoving( p_OperDate     IN DATE,
                              p_FIID         IN NUMBER,
                              p_Department   IN NUMBER,
                              p_ID_Operation IN NUMBER,
                              p_ID_Step      IN NUMBER,
                              p_S1           IN NUMBER DEFAULT UnknownValue, -- Исходные портфели (до 3-х штук, незаданные - UnknownValue (-1) )
                              p_S2           IN NUMBER DEFAULT UnknownValue,
                              p_S3           IN NUMBER DEFAULT UnknownValue,
                              p_G1           IN NUMBER DEFAULT UnknownValue, -- Целевые портфели (до 3-х штук, незаданные - UnknownValue (-1) )
                              p_G2           IN NUMBER DEFAULT UnknownValue,
                              p_G3           IN NUMBER DEFAULT UnknownValue,
                              p_GG1          IN NUMBER DEFAULT UnknownValue, -- Целевые группы списания, соотв. портфелям (незаданные - UnknownValue (-1) )
                              p_GG2          IN NUMBER DEFAULT UnknownValue,
                              p_GG3          IN NUMBER DEFAULT UnknownValue,
                              p_A1           IN NUMBER, -- Количество по портфелям для контроля
                              p_A2           IN NUMBER,
                              p_A3           IN NUMBER,
                              p_R1           IN NUMBER, -- Признаки списания резерва по портфелям
                              p_R2           IN NUMBER,
                              p_R3           IN NUMBER,
                              p_O1           IN NUMBER, -- Признаки списания переоценки по портфелям
                              p_O2           IN NUMBER,
                              p_O3           IN NUMBER,
                              p_I1           IN NUMBER, -- Признаки списания дохода по портфелям
                              p_I2           IN NUMBER,
                              p_I3           IN NUMBER,
                              p_Action        IN NUMBER,
                              p_Delivered     IN NUMBER,
                              p_NotDelivered  IN NUMBER,
                              p_WithoutAccept IN NUMBER,
                              p_RecalcDiscount0 IN NUMBER
                            )
   IS
      v_Interest NUMBER := 0;
      v_Discount NUMBER := 0;
      v_Bonus    NUMBER := 0;
      v_FlagInterest NUMBER := 0;
      v_FlagDiscount NUMBER := 0;
      v_FlagBonus    NUMBER := 0;

   BEGIN
     IF (p_OperDate < RsbSessionData.curdate) THEN
       IF (WRTAreGlobalChangesAfterDate (p_Department, p_FIID, UnknownParty, 0, p_S1, p_S2, p_S3, UnknownValue, UnknownValue, p_OperDate, p_Delivered, p_NotDelivered, p_WithoutAccept) > 0) THEN
         SetError( WRTOFF_ERROR_20220 );
       END IF;
     END IF;

     v_Interest := WRTNeedChargeInterestIncome (p_FIID);
     v_Discount := WRTNeedChargeIncome (p_FIID);
     v_Bonus    := WRTNeedChargeBonus (p_FIID);

     IF (p_A1 > 0 AND p_S1 != UnknownValue) THEN
        IF( (p_I1 = 1) AND (v_Interest = 1) ) THEN
           v_FlagInterest := 1;
        ELSE
           v_FlagInterest := 0;
        END IF;

        IF( (p_I1 = 1) AND (v_Discount = 1) ) THEN
           v_FlagDiscount := 1;
        ELSE
           v_FlagDiscount := 0;
        END IF;

        IF( (p_I1 = 1) AND (v_Bonus = 1) ) THEN
           v_FlagBonus := 1;
        ELSE
           v_FlagBonus := 0;
        END IF;

        RSI_WRTMoveLots(p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_S1, p_G1, p_GG1, p_A1,
                    p_R1, p_O1, v_FlagInterest, v_FlagDiscount, v_FlagBonus,
                    p_Action, p_Delivered, p_NotDelivered, p_WithoutAccept, p_RecalcDiscount0);
     END IF;

     IF (p_A2 > 0 AND p_S2 != UnknownValue) THEN
        IF( (p_I2 = 1) AND (v_Interest = 1) ) THEN
           v_FlagInterest := 1;
        ELSE
           v_FlagInterest := 0;
        END IF;

        IF( (p_I2 = 1) AND (v_Discount = 1) ) THEN
           v_FlagDiscount := 1;
        ELSE
           v_FlagDiscount := 0;
        END IF;

        IF( (p_I2 = 1) AND (v_Bonus = 1) ) THEN
           v_FlagBonus := 1;
        ELSE
           v_FlagBonus := 0;
        END IF;

        RSI_WRTMoveLots(p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_S2, p_G2, p_GG2, p_A2,
                    p_R2, p_O2, v_FlagInterest, v_FlagDiscount, v_FlagBonus,
                    p_Action, p_Delivered, p_NotDelivered, p_WithoutAccept, p_RecalcDiscount0);
     END IF;

     IF (p_A3 > 0 AND p_S3 != UnknownValue) THEN
        IF( (p_I3 = 1) AND (v_Interest = 1) ) THEN
           v_FlagInterest := 1;
        ELSE
           v_FlagInterest := 0;
        END IF;

        IF( (p_I3 = 1) AND (v_Discount = 1) ) THEN
           v_FlagDiscount := 1;
        ELSE
           v_FlagDiscount := 0;
        END IF;

        IF( (p_I3 = 1) AND (v_Bonus = 1) ) THEN
           v_FlagBonus := 1;
        ELSE
           v_FlagBonus := 0;
        END IF;

        RSI_WRTMoveLots(p_OperDate, p_FIID, p_Department, p_ID_Operation, p_ID_Step, p_S3, p_G3, p_GG3, p_A3,
                    p_R3, p_O3, v_FlagInterest, v_FlagDiscount, v_FlagBonus,
                    p_Action, p_Delivered, p_NotDelivered, p_WithoutAccept, p_RecalcDiscount0);
     END IF;

   END;--RSI_WRTGlobalMoving


   ----------------------------------------------------------------------------------------------------------------------
   ----- Выполняет глобальное перемещение лотов портфеля
   ----- OperDate - Дата
   ----- FIID - Выпуск
   ----- Department -Филиал
   ----- ID_Operation, ID_Step - Операция и шаг, на которых выполняется сохранение
   ----- Source - Исходная группа списания (портфель)
   ----- Goal - Целевая группа списания (портфель)
   ----- Amount - Количество (для контроля)
   ----- WOReserv - Признак списания резерва
   ----- WOOverv - Признак списания переоценки
   ----- WOInterest - Списывать процентный доход
   ----- WODiscount- Списывать дисконтный доход
   ----- WOBonus - Списывать премию
   ----- IsResponsible - Признак надежной ц/б
   ----- Action - Вид действия: Глобальное перемещение, Локальное кризисное перемещение
   ----- Delivered - Отбирать поставленные.
   ----- NotDelivered - Отбирать непоставленные.
   ----- WithoutAccept - Отбирать проданные БПП
   ----- RecalcDiscount0 -  Пересчитывать дисконтный доход

   PROCEDURE RSI_WRTMoveLots( p_OperDate        IN DATE,
                              p_FIID            IN NUMBER,
                              p_Department      IN NUMBER,
                              p_ID_Operation    IN NUMBER,
                              p_ID_Step         IN NUMBER,
                              p_Source          IN NUMBER,
                              p_Goal            IN NUMBER,
                              p_GoalGroup       IN NUMBER, -- Целевая группа списания
                              p_Amount          IN NUMBER,
                              p_WOReserv        IN NUMBER,
                              p_WOOverv         IN NUMBER,
                              p_WOInterest      IN NUMBER,
                              p_WODiscount      IN NUMBER,
                              p_WOBonus         IN NUMBER,
                              p_Action          IN NUMBER,
                              p_Delivered       IN NUMBER,
                              p_NotDelivered    IN NUMBER,
                              p_WithoutAccept   IN NUMBER,
                              p_RecalcDiscount0 IN NUMBER
                            )
   IS
     v_CurAmount      NUMBER := 0;
     v_BC_Add         NUMBER := 0;
     v_PD_Add         NUMBER := 0;
     v_DD_Add         NUMBER := 0;
     v_FaceFI         NUMBER := 0;
     v_D              NUMBER := 0;
     CorrectCostPKU   NUMBER := 0;
     v_SumAmount      NUMBER := 0;
     v_SumBalancecost NUMBER := 0;
     v_SumCost        NUMBER := 0;
     v_ConvertSumBalancecost    NUMBER := 0;
     v_ConvertSumCost           NUMBER := 0;
     v_CurConvertSumBalancecost NUMBER := 0;
     v_CurConvertSumCost        NUMBER := 0;
     v_NewCost                  NUMBER := 0;
     v_NewBalancecost           NUMBER := 0;

     TYPE CTypeLot IS REF CURSOR RETURN DPMWRTSUM_DBT%ROWTYPE;
     cLot CTypeLot;
     LOT DPMWRTSUM_DBT%ROWTYPE;
   BEGIN
     v_CurAmount := p_Amount;

     SELECT T_FACEVALUEFI INTO v_FaceFI
       FROM DFININSTR_DBT
      WHERE T_FIID = p_FIID;

     IF( (v_FaceFI != RSI_RSB_FIInstr.NATCUR) and ((p_Source = KINDPORT_CONTR) or (p_Goal = KINDPORT_CONTR)) ) THEN
        CorrectCostPKU := 1;
     END IF;

     IF( CorrectCostPKU = 1 ) THEN /*да*/

        SELECT SUM(t_Amount), SUM(t_Balancecost), SUM(t_Cost)
          INTO v_SumAmount, v_SumBalancecost, v_SumCost
          FROM DPMWRTSUM_DBT
         WHERE T_PARTY       = -1
           AND T_DEPARTMENT  = p_Department
           AND T_CONTRACT    = 0
           AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
           AND T_PORTFOLIO   = p_Source
           AND ( ((p_Delivered    = 1) and (T_STATE = PM_WRTSUM_FORM    )) OR
                 ((p_NotDelivered = 1) and (T_STATE = PM_WRTSUM_NOTFORM )) OR
                 ((p_WithoutAccept= 1) and (T_STATE = PM_WRTSUM_SALE_BPP))
               )
           AND T_ENTERDATE   <= p_OperDate
           AND T_FIID        = p_FIID
           AND T_AMOUNT      > 0;

        IF( p_Goal = KINDPORT_CONTR ) THEN
           v_ConvertSumBalancecost := RSI_RSB_FIInstr.ConvSum(v_SumBalancecost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1 );
           v_ConvertSumCost        := RSI_RSB_FIInstr.ConvSum(v_SumCost, v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1 );
        ELSE /* p_Source = KINDPORT_CONTR */
           v_ConvertSumBalancecost := RSI_RSB_FIInstr.ConvSum(v_SumBalancecost, RSI_RSB_FIInstr.NATCUR, v_FaceFI, p_OperDate, 1 );
           v_ConvertSumCost        := RSI_RSB_FIInstr.ConvSum(v_SumCost, RSI_RSB_FIInstr.NATCUR, v_FaceFI, p_OperDate, 1 );
        END IF;
        v_CurConvertSumBalancecost := v_ConvertSumBalancecost;
        v_CurConvertSumCost        := v_ConvertSumCost;

     END IF;

     IF( CorrectCostPKU = 1 ) THEN
        OPEN cLot FOR
           SELECT *
             FROM DPMWRTSUM_DBT
            WHERE T_PARTY       = -1
              AND T_DEPARTMENT  = p_Department
              AND T_CONTRACT    = 0
              AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
              AND T_PORTFOLIO   = p_Source
              AND ( ((p_Delivered    = 1) and (T_STATE = PM_WRTSUM_FORM    )) OR
                    ((p_NotDelivered = 1) and (T_STATE = PM_WRTSUM_NOTFORM )) OR
                    ((p_WithoutAccept= 1) and (T_STATE = PM_WRTSUM_SALE_BPP))
                  )
              AND T_ENTERDATE   <= p_OperDate
              AND T_FIID        = p_FIID
              AND T_AMOUNT      > 0
           ORDER BY T_AMOUNT ASC;
     ELSE
        OPEN cLot FOR
           SELECT *
             FROM DPMWRTSUM_DBT
            WHERE T_PARTY       = -1
              AND T_DEPARTMENT  = p_Department
              AND T_CONTRACT    = 0
              AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
              AND T_PORTFOLIO   = p_Source
              AND ( ((p_Delivered    = 1) and (T_STATE = PM_WRTSUM_FORM    )) OR
                    ((p_NotDelivered = 1) and (T_STATE = PM_WRTSUM_NOTFORM )) OR
                    ((p_WithoutAccept= 1) and (T_STATE = PM_WRTSUM_SALE_BPP))
                  )
              AND T_ENTERDATE   <= p_OperDate
              AND T_FIID        = p_FIID
              AND T_AMOUNT      > 0;
     END IF;

     LOOP
        FETCH cLot INTO LOT;
        EXIT WHEN cLot%NOTFOUND;
       v_BC_Add := 0;
       v_PD_Add := 0;
       v_DD_Add := 0;

       RSI_WRTSaveLot (LOT.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, p_Action);

       IF( CorrectCostPKU = 1 ) THEN
          IF( v_CurAmount = LOT.T_Amount ) THEN
             v_NewCost        := v_CurConvertSumCost;
             v_NewBalancecost := v_CurConvertSumBalancecost;
          ELSE
             v_NewCost        := round(v_ConvertSumBalancecost / v_SumAmount * LOT.T_Amount, 2);
             v_NewBalancecost := round(v_ConvertSumBalancecost / v_SumAmount * LOT.T_Amount, 2);
          END IF;
          v_CurConvertSumCost        := v_CurConvertSumCost - v_NewCost;
          v_CurConvertSumBalancecost := v_CurConvertSumBalancecost - v_NewBalancecost;
          LOT.T_COST                 := v_NewCost;
          LOT.T_BALANCECOST          := v_NewBalancecost;
          UPDATE DPMWRTSUM_DBT SET
             T_COST        = v_NewCost,
             T_BALANCECOST = v_NewBalancecost
          WHERE T_SUMID = LOT.T_SUMID;
       END IF;

       v_BC_Add := 0;

       UPDATE DPMWRTSUM_DBT SET
         T_PORTFOLIO = p_Goal,
         t_GroupID   = p_GoalGroup
       where T_SUMID = LOT.T_SUMID;

       if( LOT.T_STATE = PM_WRTSUM_FORM ) then

          if( p_WOReserv = 1 ) then

             UPDATE DPMWRTSUM_DBT SET
                T_RESERVDATE   = p_OperDate,
                T_RESERVAMOUNT = 0,
                T_IncomeRESERV = 0
             where T_SUMID   = LOT.T_SUMID;

          end if;

       end if;

       if( LOT.T_STATE in (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP) ) then

          if( p_WOOverv = 1 ) then

             v_BC_Add := RSI_RSB_FIInstr.ConvSum( LOT.T_OVERAMOUNT, RSI_RSB_FIInstr.NATCUR, v_FaceFI, p_OperDate, 1 );

             UPDATE DPMWRTSUM_DBT SET
                T_OVERDATE    = p_OperDate,
                T_OVERAMOUNT  = 0
             where T_SUMID   = LOT.T_SUMID;

          end if;

          if( p_WOInterest = 1 ) then

             v_PD_Add := LOT.T_INTERESTINCOME;

             UPDATE DPMWRTSUM_DBT SET
                T_INTERESTDATE     = p_OperDate,
                T_INTERESTINCOME   = 0,
                T_NOTCARRYINTEREST = 0
             where T_SUMID   = LOT.T_SUMID;

          end if;

          if( p_WOBonus = 1 ) then

             UPDATE DPMWRTSUM_DBT SET
                T_BONUSDATE     = p_OperDate,
                T_BONUS         = 0,
                T_OLDBONUS      = 0
             where T_SUMID   = LOT.T_SUMID;

          end if;

          if( p_WODiscount = 1 ) then

             v_DD_Add := LOT.T_DISCOUNTINCOME;

             UPDATE DPMWRTSUM_DBT SET
                T_DISCOUNTDATE     = p_OperDate,
                T_DISCOUNTINCOME   = 0,
                T_NOTCARRYDISCOUNT = 0
             where T_SUMID   = LOT.T_SUMID;

          end if;

          LOT.T_COST := LOT.T_COST + v_BC_Add + v_PD_Add + v_DD_Add;

          UPDATE DPMWRTSUM_DBT SET
             T_COST = LOT.T_COST
          where T_SUMID = LOT.T_SUMID;

          if( p_WOOverv = 1 and p_RecalcDiscount0 = 1 ) then

             LOT.T_RECALCDATE     := p_OperDate;
             LOT.T_OLDBEGDISCOUNT := LOT.T_BEGDISCOUNT;
             LOT.T_OLDBEGBONUS    := LOT.T_BEGBONUS;
             LOT.T_OLDBONUS       := LOT.T_BONUS;

             v_D := ROUND((RSI_RSB_FIInstr.FI_GetNominalOnDate (p_FIID, p_OperDate) * LOT.T_AMOUNT), 2) - LOT.T_COST - LOT.T_DISCOUNTINCOME;
             LOT.T_BEGDISCOUNT    := GREATEST(v_D, 0);

             IF v_D < 0 AND LOT.T_NOTCARRYDISCOUNT > 0 THEN

               LOT.T_DISCOUNTCORR     := least(LOT.T_NOTCARRYDISCOUNT, -v_D);
               LOT.T_DISCOUNTINCOME   := LOT.T_DISCOUNTINCOME - LOT.T_DISCOUNTCORR;
               LOT.T_NOTCARRYDISCOUNT := LOT.T_NOTCARRYDISCOUNT - LOT.T_DISCOUNTCORR;

               v_D := v_D + LOT.T_DISCOUNTCORR;
             ELSE

               LOT.T_DISCOUNTCORR := 0;

             END IF;

             IF v_D < 0 AND WRTNeedChargeBonus(LOT.t_FIID) = 1 THEN
               LOT.T_BEGBONUS := -v_D;
             ELSE
               LOT.T_BEGBONUS := 0;
             END IF;

             IF LOT.T_BEGDISCOUNT > 0 AND LOT.T_OLDBEGDISCOUNT = 0 THEN
               LOT.T_BEGDISCOUNTDATE := LOT.T_RECALCDATE;
             END IF;

             IF LOT.T_BEGBONUS > 0 AND LOT.T_OLDBEGBONUS = 0 THEN
               LOT.T_BEGBONUSDATE := LOT.T_RECALCDATE;
             END IF;

             UPDATE DPMWRTSUM_DBT SET
                  T_BEGBONUS         = LOT.T_BEGBONUS,
                  T_BEGBONUSDATE     = LOT.T_BEGBONUSDATE,
                  T_BEGDISCOUNTDATE  = LOT.T_BEGDISCOUNTDATE,
                  T_DISCOUNTCORR     = LOT.T_DISCOUNTCORR,
                  T_OLDBEGDISCOUNT   = LOT.T_OLDBEGDISCOUNT,
                  T_BEGDISCOUNT      = LOT.T_BEGDISCOUNT,
                  T_RECALCDATE       = LOT.T_RECALCDATE,
                  T_OLDBEGBONUS      = LOT.T_OLDBEGBONUS,
                  T_OLDBONUS         = LOT.T_OLDBONUS,
                  T_DISCOUNTINCOME   = LOT.T_DISCOUNTINCOME,
                  T_NOTCARRYDISCOUNT = LOT.T_NOTCARRYDISCOUNT
             where T_SUMID   = LOT.T_SUMID;

          end if;
       end if;

       v_CurAmount := v_CurAmount - LOT.T_AMOUNT;

     END LOOP;
     CLOSE cLot;

     if (v_CurAmount != 0) then
       SetError( WRTOFF_ERROR_20205 );
     end if;

   END;--RSI_WRTMoveLots

   ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет локальное перемещение лотов.
   PROCEDURE RSI_WRTLocalMoving( p_SaleID       IN NUMBER,
                                 p_Goal         IN NUMBER, -- Целевой портфель
                                 p_GoalGroup    IN NUMBER, -- Целевая группа списания
                                 p_OperDate     IN DATE,
                                 p_ID_Operation IN NUMBER,
                                 p_ID_Step      IN NUMBER,
                                 WOOverv        IN NUMBER  -- Признак списания переоценки
                               )

   IS
     v_SaleLot      DPMWRTSUM_DBT%ROWTYPE;
     v_NewLot       DPMWRTSUM_DBT%ROWTYPE;
     v_SourceLot    DPMWRTSUM_DBT%ROWTYPE;
     v_Method       NUMBER;
     v_D            NUMBER;
     v_PartNum      NUMBER := 1;
     v_FaceFI       NUMBER := 0;

   CURSOR cLink IS
      SELECT *
        FROM DPMWRTLNK_DBT
       WHERE T_SALEID = p_SaleID
         AND T_KIND   = PMWRTLINK_KIND_PORTFOLIO;

   BEGIN
     InitError();

     BEGIN
       SELECT * INTO v_SaleLot
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SaleID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     v_Method := GetAmortizationMethod( UnknownParty, 0 );
     if( v_Method = UnknownValue ) then
        SetError( WRTOFF_ERROR_20207 );
     end if;

       RSI_WRTLinkSaleToBuy(v_SaleLot, v_SaleLot.t_Portfolio, v_SaleLot.t_GroupID, NULL, v_Method, 0, p_ID_Operation, p_ID_Step, PMWRTLINK_KIND_PORTFOLIO, PM_WRT_UPDTMODE_PORTFOLIO, false, false, false, false, false, false);

     FOR v_LINK IN cLink LOOP

       BEGIN
         SELECT * INTO v_SourceLot
           FROM DPMWRTSUM_DBT
          WHERE t_SumID = v_LINK.T_BUYID;
       EXCEPTION
          WHEN OTHERS THEN
              SetError( WRTOFF_ERROR_20200 );
       END;

       v_NewLot.T_DOCKIND            :=  105; -- Перевод ценных бумаг
       v_NewLot.T_DOCID              :=  v_SaleLot.T_DOCID;
       v_NewLot.T_PARTNUM            :=  v_PartNum;
       v_NewLot.T_PARTY              :=  UnknownParty;
       v_NewLot.T_CONTRACT           :=  0;
       v_NewLot.T_FIID               :=  v_SaleLot.T_FIID;
       v_NewLot.T_PORTFOLIO          :=  p_Goal;
       v_NewLot.T_GROUPID            :=  p_GoalGroup;
       v_NewLot.T_BUY_SALE           :=  PM_WRITEOFF_SUM_BUY;
       v_NewLot.T_KIND               :=  WRTSUM_KIND_MB;
       v_NewLot.T_DATE               :=  v_SourceLot.T_DATE;
       v_NewLot.T_TIME               :=  v_SourceLot.T_TIME;
       v_NewLot.T_AMOUNT             :=  v_LINK.T_AMOUNT;
       v_NewLot.T_AMOUNTBD           :=  0;
       v_NewLot.T_SUM                :=  v_LINK.T_SUMBUY;
       v_NewLot.T_CURRENCY           :=  v_SourceLot.T_CURRENCY;
       v_NewLot.T_COST               :=  v_LINK.T_COSTBUY;

       if( WOOverv = 1 ) then
          SELECT T_FACEVALUEFI INTO v_FaceFI
            FROM DFININSTR_DBT
           WHERE T_FIID = v_SaleLot.T_FIID;

          v_NewLot.T_COST := v_NewLot.T_COST + RSI_RSB_FIInstr.ConvSum( v_LINK.T_OVERCHANGE, 0, v_FaceFI, v_SALELOT.T_DATE, 1 );
       end if;

       v_NewLot.T_BALANCECOST        :=  v_LINK.T_BALANCECOSTBUY;
       v_NewLot.T_BALANCECOSTBD      :=  0;
       v_NewLot.T_NKDAMOUNT          :=  v_LINK.T_NKDBUYAMOUNT;
       v_NewLot.T_BEGINTERESTDATE    :=  v_SourceLot.T_BEGINTERESTDATE;
       v_NewLot.T_INTERESTINCOME     :=  v_LINK.T_INTERESTINCOMEBUY;
       v_NewLot.T_NOTCARRYINTEREST   :=  v_LINK.T_NOTCARRYINTERESTBUY;
       v_NewLot.T_INTERESTDATE       :=  v_SourceLot.T_INTERESTDATE;
       v_NewLot.T_BEGDATE            :=  v_SourceLot.T_BEGDATE;
       v_NewLot.T_BEGDISCOUNTDATE    :=  v_SourceLot.T_BEGDISCOUNTDATE;
       v_NewLot.T_BEGDISCOUNT        :=  v_LINK.t_BegDiscountChange;
       v_NewLot.T_OLDBEGDISCOUNT     :=  v_LINK.t_OldBegDiscountChange;
       v_NewLot.T_DISCOUNTCORR       :=  v_LINK.T_DISCOUNTCORRCHANGE;
       v_NewLot.T_BEGBONUSDATE       :=  v_SourceLot.T_BEGBONUSDATE;
       v_NewLot.T_OLDBEGBONUS        :=  v_LINK.T_OLDBEGBONUSCHANGE;
       v_NewLot.T_RECALCDATE         :=  v_SourceLot.T_RECALCDATE;
       v_NewLot.T_BEGBONUS           :=  v_LINK.t_BegBonusChange;
       v_NewLot.T_DISCOUNTINCOME     :=  v_LINK.T_DISCOUNTINCOMEBUY;
       v_NewLot.T_NOTCARRYDISCOUNT   :=  v_LINK.T_NOTCARRYDISCOUNTBUY;
       v_NewLot.T_DISCOUNTDATE       :=  v_SourceLot.T_DISCOUNTDATE;
       v_NewLot.T_BONUS              :=  v_LINK.T_BONUSBUY;
       v_NewLot.T_BONUSDATE          :=  v_SourceLot.T_BONUSDATE;
       v_NewLot.T_OUTLAY             :=  v_LINK.T_OUTLAYBUY;
       v_NewLot.T_RESERVAMOUNT       :=  0;
       v_NewLot.T_INCOMERESERV       :=  0;
       v_NewLot.T_RESERVDATE         :=  UnknownDate;

       if( WOOverv = 1 ) then
          v_NewLot.T_OVERAMOUNT         :=  0;
          v_NewLot.T_OVERDATE           :=  UnknownDate;
       else
          v_NewLot.T_OVERAMOUNT         :=  v_LINK.T_OVERCHANGE;
          v_NewLot.T_OVERDATE           :=  v_SourceLot.T_OVERDATE;
       end if;
       v_NewLot.T_OVERAMOUNTBD       :=  0;
       v_NewLot.T_COUPON             :=  chr(1);
       v_NewLot.T_PARTLY             :=  chr(1);
       v_NewLot.T_DEPARTMENT         :=  v_SaleLot.T_DEPARTMENT;
       v_NewLot.T_DEALID             :=  v_SourceLot.T_DEALID;
       v_NewLot.T_DEALDATE           :=  v_SourceLot.T_DEALDATE;
       v_NewLot.T_DEALCODE           :=  v_SourceLot.T_DEALCODE;
       v_NewLot.T_STATE              :=  PM_WRTSUM_FORM;
       v_NewLot.T_ENTERDATE          :=  v_SaleLot.T_DATE;
       v_NewLot.T_STATEDATE          :=  v_SourceLot.T_STATEDATE;
       v_NewLot.T_INSTANCE           :=  0;
       v_NewLot.T_CHANGEDATE         :=  v_SaleLot.T_DATE;
       v_NewLot.T_ACTION             :=  PM_WRT_UPDTMODE_INPORTFOLIO;
       v_NewLot.T_ID_OPERATION       :=  p_ID_Operation;
       v_NewLot.T_ID_STEP            :=  p_ID_Step;
       v_NewLot.T_ISFREE             :=  chr(88);
       v_NewLot.T_TRUST              :=  chr(0);
       v_NewLot.T_PARENT             :=  p_SaleID;
       v_NewLot.T_SOURCE             :=  v_SourceLot.T_SUMID;
       v_NewLot.T_IsEdit             :=  chr(0);
       v_NewLot.T_NOTWRTBONUS        :=  v_LINK.T_NOTWRTBONUSBUY;
       v_NewLot.T_COSTPFI            :=  v_LINK.T_COSTPFIBUY;

       v_NewLot.T_OLDBONUS           :=  v_LINK.T_OLDBONUSBUY;
       v_NewLot.T_OLDBEGDATE         :=  UnknownDate;

       v_NewLot.T_ACTIVATEDATE       :=  p_OperDate;
       v_NewLot.T_ACTIVATETIME       :=  UnknownTime;

       v_NewLot.T_BlockAmount        :=  v_LINK.T_BlockAmountBuy;
       v_NewLot.T_ACCFI              :=  WRTDetermineAccFI(v_NewLot.T_FIID);

       if( WOOverv = 1 AND v_LINK.T_OVERCHANGE != 0 AND WRTNeedChargeIncome(v_SaleLot.T_FIID) = 1 ) then
          IF( v_NewLot.T_RECALCDATE != UnknownDate ) THEN
             SetError( WRTOFF_ERROR_20226 );
          END IF;

          v_NewLot.T_RECALCDATE     := v_SALELOT.T_DATE;
          v_NewLot.T_OLDBEGDISCOUNT := v_NewLot.T_BEGDISCOUNT;
          v_NewLot.T_OLDBEGBONUS    := v_NewLot.T_BEGBONUS ;
          v_NewLot.T_OLDBONUS       := v_NewLot.T_BONUS;

          v_D := ROUND( RSI_RSB_FIInstr.FI_GetNominalOnDate( v_NewLot.T_FIID, v_SALELOT.T_DATE)* v_NewLot.T_AMOUNT, 2) - v_NewLot.T_COST - v_NewLot.T_DISCOUNTINCOME;
          if( v_D > 0 ) then
             v_NewLot.T_BEGDISCOUNT := v_D;
          else
             v_NewLot.T_BEGDISCOUNT := 0;
          end if;

          if( v_D < 0 AND v_NewLot.T_NOTCARRYDISCOUNT >0 ) then
             if( v_NewLot.T_NOTCARRYDISCOUNT < -v_D ) then
                v_NewLot.T_DISCOUNTCORR     := v_NewLot.T_NOTCARRYDISCOUNT;
             else
                v_NewLot.T_DISCOUNTCORR     := -v_D;
             end if;

             v_NewLot.T_DISCOUNTINCOME   := v_NewLot.T_DISCOUNTINCOME - v_NewLot.T_DISCOUNTCORR;
             v_NewLot.T_NOTCARRYDISCOUNT := v_NewLot.T_NOTCARRYDISCOUNT - v_NewLot.T_DISCOUNTCORR;
             v_D := v_D + v_NewLot.T_DISCOUNTCORR;
          else
             v_NewLot.T_DISCOUNTCORR     := 0;
          end if;

          if( v_D < 0 AND WRTNeedChargeBonus( v_NewLot.T_FIID) = 1 ) then
             v_NewLot.T_BEGBONUS := -v_D;
          else
             v_NewLot.T_BEGBONUS := 0;
          end if;

          IF( v_NewLot.T_BEGDISCOUNT > 0 AND v_NewLot.T_OLDBEGDISCOUNT = 0 ) THEN
             v_NewLot.T_BEGDISCOUNTDATE := v_NewLot.T_RECALCDATE;
          END IF;
          IF( v_NewLot.T_BEGBONUS > 0 AND v_NewLot.T_OLDBEGBONUS = 0 ) THEN
             v_NewLot.T_BEGBONUSDATE := v_NewLot.T_RECALCDATE;
          END IF;

       end if;

       RSI_InsDfltIntoWRTSUM(v_NewLot);
       INSERT INTO DPMWRTSUM_DBT VALUES v_NewLot;

       v_PartNum := v_PartNum + 1;
     END LOOP;

   END;--RSI_WRTLocalMoving

   --Выполнить перемещение ц/б
   PROCEDURE RSI_WRTExecMoving( p_DocumentID   IN NUMBER,
                                p_ID_Operation IN NUMBER,
                                p_ID_Step      IN NUMBER
                              )
   IS
     v_comm        DDL_COMM_DBT%ROWTYPE;
     v_fin         DFININSTR_DBT%ROWTYPE;
     v_SaleLot     DPMWRTSUM_DBT%ROWTYPE;
     v_SourceLot   DPMWRTSUM_DBT%ROWTYPE;
     v_NewLot      DPMWRTSUM_DBT%ROWTYPE;
     v_tick        DDL_TICK_DBT%ROWTYPE;
     v_avr         DAVOIRISS_DBT%ROWTYPE;

     v_Method        NUMBER;
     v_PartNum       NUMBER := 1;
     v_AmortCalcKind NUMBER;

     v_CurFIisBond BOOLEAN;
     v_FVCourseType     NUMBER := Rsb_Common.GetRegIntValue('SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ', 0);
     v_Course NUMBER;

     v_TSS NUMBER;
     v_OverValue NUMBER;

     v_D NUMBER;

     v_SignDeviation BOOLEAN;
     v_RateKind      NUMBER;
     v_RateVal       NUMBER;

     v_EIR           NUMBER;
     v_AmortCost     NUMBER;
     v_AmortCostDate DATE;
     v_DrawingDate   DATE;

     v_Group     NUMBER;
     v_OverMode  BOOLEAN;
                
     v_CurAmount NUMBER;
     v_Cost      NUMBER;

     v_SumOverAmount  NUMBER := 0;
     v_SumCorrValue   NUMBER := 0;
     v_SumAmount      NUMBER := 0;
     v_SumBalancecost NUMBER := 0;
     v_SumCost        NUMBER := 0;
     v_ConvertSumBalancecost    NUMBER := 0;
     v_ConvertSumCost           NUMBER := 0;
     v_CurConvertSumBalancecost NUMBER := 0;
     v_CurConvertSumCost        NUMBER := 0;
     v_NewCost                  NUMBER := 0;
     v_NewBalancecost           NUMBER := 0;

     v_BegDate DATE;

     v_EstReserve         NUMBER;
     v_EstReserveDate     DATE;
     v_CorrEstReserve     NUMBER;
     v_CorrEstReserveDate DATE;

   BEGIN
     InitError();

     SELECT CM.* INTO v_comm
       FROM DDL_COMM_DBT CM
      WHERE CM.T_DOCUMENTID = p_DocumentID;

     SELECT FIN.* INTO v_fin
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID = v_comm.T_FIID;

     SELECT AVR.* INTO v_avr
       FROM DAVOIRISS_DBT AVR
      WHERE AVR.T_FIID = v_fin.T_FIID;

     v_CurFIisBond := RSI_RSB_FIInstr.FI_IsAvrKindBond(v_fin.t_AvoirKind);

     v_Group := RSI_GetWrtoffGroupByPortfolio(v_comm.t_DestPortofolio);

     --Если переносим не в ПДО, то создаем новые лоты, т.к. может быть частичный перевод
     IF v_comm.t_DestPortofolio != KINDPORT_PROMISSORY AND v_comm.t_DestPortofolio != KINDPORT_CONTR AND v_comm.t_SrcPortfolio != KINDPORT_CONTR THEN

       IF v_comm.t_Hidden_Sum > 0 THEN
         --Создать лот выбытия из исходного портфеля для поставленных бумаг (не БПП)
         v_SaleLot.T_SUMID              :=  0;
         v_SaleLot.T_DOCKIND            :=  v_comm.t_DocKind;
         v_SaleLot.T_DOCID              :=  v_comm.t_DocumentID;
         v_SaleLot.T_PARTNUM            :=  0;
         v_SaleLot.T_PARTY              :=  UnknownParty;
         v_SaleLot.T_CONTRACT           :=  0;
         v_SaleLot.T_PORTFOLIO          :=  v_comm.t_SrcPortfolio;
         v_SaleLot.T_GROUPID            :=  RSI_GetWrtoffGroupByPortfolio(v_SaleLot.T_PORTFOLIO);
         v_SaleLot.T_FIID               :=  v_comm.t_FIID;
         v_SaleLot.T_BUY_SALE           :=  PM_WRITEOFF_SUM_SALE;
         v_SaleLot.T_KIND               :=  WRTSUM_KIND_MS;
         v_SaleLot.T_DATE               :=  v_comm.t_CommDate;
         v_SaleLot.T_TIME               :=  TO_DATE('01.01.0001 23:59:59','DD.MM.YYYY HH24:MI:SS');
         v_SaleLot.T_AMOUNT             :=  v_comm.t_Hidden_Sum;
         v_SaleLot.T_AMOUNTBD           :=  0;
         v_SaleLot.T_SUM                :=  0;
         v_SaleLot.T_CURRENCY           :=  0;
         v_SaleLot.T_COST               :=  0;
         v_SaleLot.T_BALANCECOST        :=  0;
         v_SaleLot.T_BALANCECOSTBD      :=  0;
         v_SaleLot.T_NKDAMOUNT          :=  0;
         v_SaleLot.T_INTERESTINCOME     :=  0;
         v_SaleLot.T_NOTCARRYINTEREST   :=  0;
         v_SaleLot.T_INTERESTDATE       :=  UnknownDate;
         v_SaleLot.T_BEGDATE            :=  UnknownDate;
         v_SaleLot.T_BEGDISCOUNT        :=  0;
         v_SaleLot.T_OLDBEGDATE         :=  UnknownDate;
         v_SaleLot.T_OLDBEGDISCOUNT     :=  0;
         v_SaleLot.T_DISCOUNTINCOME     :=  0;
         v_SaleLot.T_NOTCARRYDISCOUNT   :=  0;
         v_SaleLot.T_DISCOUNTDATE       :=  UnknownDate;
         v_SaleLot.T_OUTLAY             :=  0;
         v_SaleLot.T_RESERVAMOUNT       :=  0;
         v_SaleLot.T_INCOMERESERV       :=  0;
         v_SaleLot.T_RESERVDATE         :=  UnknownDate;
         v_SaleLot.T_OVERAMOUNT         :=  0;
         v_SaleLot.T_OVERAMOUNTBD       :=  0;
         v_SaleLot.T_OVERDATE           :=  UnknownDate;
         v_SaleLot.T_COUPON             :=  chr(1);
         v_SaleLot.T_PARTLY             :=  chr(1);
         v_SaleLot.T_PARENT             :=  0;
         v_SaleLot.T_SOURCE             :=  0;
         v_SaleLot.T_INSTANCE           :=  0;
         v_SaleLot.T_TRUST              :=  chr(0);
         v_SaleLot.T_ISFREE             :=  chr(0);
         v_SaleLot.T_DEPARTMENT         :=  v_comm.t_Division;
         v_SaleLot.T_DEALID             :=  v_comm.t_DocumentID;
         v_SaleLot.T_DEALDATE           :=  v_comm.t_CommDate;
         v_SaleLot.T_DEALCODE           :=  v_comm.t_CommCode;
         v_SaleLot.T_STATE              :=  PM_WRTSUM_FORM;
         v_SaleLot.T_ENTERDATE          :=  v_comm.t_CommDate;
         v_SaleLot.T_STATEDATE          :=  v_comm.t_CommDate;
         v_SaleLot.T_CHANGEDATE         :=  v_comm.t_CommDate;
         v_SaleLot.T_ACTION             :=  PM_WRT_UPDTMODE_DELIVERY;
         v_SaleLot.T_ID_OPERATION       :=  p_ID_Operation;
         v_SaleLot.T_ID_STEP            :=  p_ID_Step;
         v_SaleLot.T_BEGBONUSDATE       :=  UnknownDate;
         v_SaleLot.T_BEGBONUS           :=  0;
         v_SaleLot.T_BONUS              :=  0;
         v_SaleLot.T_BONUSDATE          :=  UnknownDate;
         v_SaleLot.T_ACTIVATEDATE       :=  v_comm.t_CommDate;
         v_SaleLot.T_ACTIVATETIME       :=  UnknownTime;
         v_SaleLot.T_BLOCKAMOUNT        :=  0;
         v_SaleLot.T_ACCFI              :=  WRTDetermineAccFI(v_SaleLot.T_FIID);

         RSI_InsDfltIntoWRTSUM(v_SaleLot);
         INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.t_SumID;

         --Выполнить списание этим лотом
         v_Method := GetAmortizationMethod( UnknownParty, 0 );
         if( v_Method = UnknownValue ) then
           SetError( WRTOFF_ERROR_20207 );
         end if;

         RSI_WRTLinkSaleToBuy(v_SaleLot, v_SaleLot.t_Portfolio, v_SaleLot.t_GroupID, NULL, v_Method, 0, p_ID_Operation, p_ID_Step, PMWRTLINK_KIND_PORTFOLIO, PM_WRT_UPDTMODE_PORTFOLIO, false, false, false, false, false, false);

         FOR v_LINK IN (SELECT *
                          FROM DPMWRTLNK_DBT
                         WHERE T_SALEID = v_SaleLot.t_SumID
                           AND T_KIND   = PMWRTLINK_KIND_PORTFOLIO)
         LOOP

           BEGIN
             SELECT * INTO v_SourceLot
               FROM DPMWRTSUM_DBT
              WHERE t_SumID = v_LINK.T_BUYID;
           EXCEPTION
              WHEN OTHERS THEN
                  SetError( WRTOFF_ERROR_20200 );
           END;

           SELECT * INTO v_tick
             FROM DDL_TICK_DBT
            WHERE t_DealID = v_SourceLot.T_DEALID;


           v_NewLot.T_SUMID              :=  0;

           v_NewLot.T_DOCKIND            :=  RSB_SECUR.DL_MOVINGDOC; -- Перевод ценных бумаг
           v_NewLot.T_DOCID              :=  v_SaleLot.T_DOCID;
           v_NewLot.T_PARTNUM            :=  v_PartNum;
           v_NewLot.T_PARTY              :=  UnknownParty;
           v_NewLot.T_CONTRACT           :=  0;
           v_NewLot.T_FIID               :=  v_SaleLot.T_FIID;
           v_NewLot.T_PORTFOLIO          :=  v_comm.t_DestPortofolio;
           v_NewLot.T_GROUPID            :=  v_Group;
           v_NewLot.T_BUY_SALE           :=  PM_WRITEOFF_SUM_BUY;
           v_NewLot.T_KIND               :=  WRTSUM_KIND_MB;
           v_NewLot.T_DATE               :=  v_SourceLot.T_DATE;
           v_NewLot.T_TIME               :=  v_SourceLot.T_TIME;
           v_NewLot.T_AMOUNT             :=  v_LINK.T_AMOUNT;
           v_NewLot.T_AMOUNTBD           :=  0;
           v_NewLot.T_SUM                :=  v_LINK.T_SUMBUY;
           v_NewLot.T_CURRENCY           :=  v_SourceLot.T_CURRENCY;
           v_NewLot.T_COST               :=  v_LINK.T_COSTBUY;
           v_NewLot.T_BALANCECOST        :=  v_LINK.T_BALANCECOSTBUY;
           v_NewLot.T_BALANCECOSTBD      :=  0;
           v_NewLot.T_NKDAMOUNT          :=  v_LINK.T_NKDBUYAMOUNT;
           v_NewLot.T_BEGINTERESTDATE    :=  v_SourceLot.T_BEGINTERESTDATE;
           v_NewLot.T_INTERESTINCOME     :=  v_LINK.T_INTERESTINCOMEBUY;
           v_NewLot.T_NOTCARRYINTEREST   :=  v_LINK.T_NOTCARRYINTERESTBUY;
           v_NewLot.T_INTERESTDATE       :=  v_SourceLot.T_INTERESTDATE;
           
           v_NewLot.T_BEGDATE            :=  v_SourceLot.T_BEGDATE;
           /*IF v_CurFIisBond = TRUE AND v_fin.t_FaceValueFI != RSI_RSB_FIInstr.NATCUR THEN
             v_NewLot.T_BEGDATE := v_comm.t_CommDate;
           END IF;*/

           v_NewLot.T_BEGDISCOUNTDATE    :=  v_SourceLot.T_BEGDISCOUNTDATE;
           v_NewLot.T_BEGDISCOUNT        :=  v_LINK.t_BegDiscountChange;
           v_NewLot.T_OLDBEGDISCOUNT     :=  v_LINK.t_OldBegDiscountChange;
           v_NewLot.T_DISCOUNTCORR       :=  v_LINK.T_DISCOUNTCORRCHANGE;
           v_NewLot.T_BEGBONUSDATE       :=  v_SourceLot.T_BEGBONUSDATE;
           v_NewLot.T_OLDBEGBONUS        :=  v_LINK.T_OLDBEGBONUSCHANGE;
           v_NewLot.T_RECALCDATE         :=  v_SourceLot.T_RECALCDATE;
           v_NewLot.T_BEGBONUS           :=  v_LINK.t_BegBonusChange;
           v_NewLot.T_DISCOUNTINCOME     :=  v_LINK.T_DISCOUNTINCOMEBUY;
           v_NewLot.T_NOTCARRYDISCOUNT   :=  v_LINK.T_NOTCARRYDISCOUNTBUY;
           v_NewLot.T_DISCOUNTDATE       :=  v_SourceLot.T_DISCOUNTDATE;
           v_NewLot.T_BONUS              :=  v_LINK.T_BONUSBUY;
           v_NewLot.T_BONUSDATE          :=  v_SourceLot.T_BONUSDATE;
           v_NewLot.T_OUTLAY             :=  v_LINK.T_OUTLAYBUY;
           
           IF (v_comm.t_SrcPortfolio = KINDPORT_ASCB AND v_comm.t_DestPortofolio = KINDPORT_SSSD) OR 
              (v_comm.t_SrcPortfolio = KINDPORT_SSSD AND v_comm.t_DestPortofolio = KINDPORT_ASCB) 
           THEN
             v_NewLot.T_RESERVAMOUNT       := v_LINK.T_RESERVCHANGE;
             v_NewLot.T_INCOMERESERV       := v_LINK.T_INCOMERESERVCHANGE;
             v_NewLot.T_RESERVDATE         := v_SourceLot.T_RESERVDATE;
           ELSE
             v_NewLot.T_RESERVAMOUNT       := 0;
             v_NewLot.T_INCOMERESERV       := 0;
             v_NewLot.T_RESERVDATE         := UnknownDate;
           END IF;

           IF v_comm.t_DestPortofolio = KINDPORT_ASCB THEN
             v_NewLot.T_OVERAMOUNT         := 0;
             v_NewLot.T_OVERDATE           := UnknownDate;
           ELSE
             v_NewLot.T_OVERAMOUNT         := v_LINK.T_OVERCHANGE;
             v_NewLot.T_OVERDATE           := v_SourceLot.T_OVERDATE;
           END IF;

           v_NewLot.T_OVERAMOUNTBD       :=  0;
           v_NewLot.T_COUPON             :=  chr(1);
           v_NewLot.T_PARTLY             :=  chr(1);
           v_NewLot.T_DEPARTMENT         :=  v_SaleLot.T_DEPARTMENT;
           v_NewLot.T_DEALID             :=  v_SourceLot.T_DEALID;
           v_NewLot.T_DEALDATE           :=  v_SourceLot.T_DEALDATE;
           v_NewLot.T_DEALCODE           :=  v_SourceLot.T_DEALCODE;
           v_NewLot.T_STATE              :=  PM_WRTSUM_FORM;
           v_NewLot.T_ENTERDATE          :=  v_SaleLot.T_DATE;
           v_NewLot.T_STATEDATE          :=  v_SourceLot.T_STATEDATE;
           v_NewLot.T_INSTANCE           :=  0;
           v_NewLot.T_CHANGEDATE         :=  v_SaleLot.T_DATE;
           v_NewLot.T_ACTION             :=  PM_WRT_UPDTMODE_INPORTFOLIO;
           v_NewLot.T_ID_OPERATION       :=  p_ID_Operation;
           v_NewLot.T_ID_STEP            :=  p_ID_Step;
           v_NewLot.T_ISFREE             :=  chr(88);
           v_NewLot.T_TRUST              :=  chr(0);
           v_NewLot.T_PARENT             :=  v_SaleLot.T_SUMID;
           v_NewLot.T_SOURCE             :=  v_SourceLot.T_SUMID;
           v_NewLot.T_IsEdit             :=  chr(0);
           v_NewLot.T_NOTWRTBONUS        :=  0;
           v_NewLot.T_COSTPFI            :=  v_LINK.T_COSTPFIBUY;

           v_NewLot.T_OLDBONUS           :=  v_LINK.T_OLDBONUSBUY;
           v_NewLot.T_OLDBEGDATE         :=  UnknownDate;

           v_NewLot.T_ACTIVATEDATE       :=  v_comm.t_CommDate;
           v_NewLot.T_ACTIVATETIME       :=  UnknownTime;

           v_NewLot.T_BLOCKAMOUNT        :=  v_LINK.T_BlockAmountBuy;
           v_NewLot.T_ACCFI              :=  WRTDetermineAccFI(v_NewLot.T_FIID);

           v_NewLot.T_BEGDEFDIFF         := v_LINK.T_BEGDEFDIFFCHANGE;
           v_NewLot.T_BEGDEFDIFFDATE     := v_SourceLot.T_BEGDEFDIFFDATE;
           v_NewLot.T_ACCOUNTEDDEFDIFF   := v_LINK.T_ACCOUNTEDDEFDIFFBUY;
           v_NewLot.T_WRTOUTLAY          := v_LINK.T_WRTOUTLAYBUY;
           v_NewLot.T_VATOUTLAY          := v_LINK.T_VATOUTLAYCHANGE;
           v_NewLot.T_WRTVATOUTLAY       := v_LINK.T_WRTVATOUTLAYBUY;
           v_NewLot.T_EFFECTINTERESTRATE := v_SourceLot.T_EFFECTINTERESTRATE;
           v_NewLot.T_FAIRVALUE          := v_LINK.T_FAIRVALUECHANGE;
           v_NewLot.T_AMORTCOST          := v_LINK.T_AMORTCOSTCHANGE;
           v_NewLot.T_AMORTCOSTDATE      := v_SourceLot.T_AMORTCOSTDATE;
           v_NewLot.T_CORRVALUE          := v_LINK.T_CORRVALUECHANGE;
           v_NewLot.T_CORRDATE           := v_SourceLot.T_CORRDATE;
           v_NewLot.T_AMORTCALCKIND      := v_SourceLot.T_AMORTCALCKIND;
           v_NewLot.T_CORRINTTOEIR       := v_LINK.T_CORRINTTOEIRCHANGE;
           v_NewLot.T_CORRINTTOEIRDATE   := v_SourceLot.T_CORRINTTOEIRDATE;
           v_NewLot.T_HEDGCORR           := v_LINK.T_HEDGCORRCHANGE;
           v_NewLot.T_HEDGCORRDATE       := v_SourceLot.T_HEDGCORRDATE;
           v_NewLot.T_AMORTHEDGCORR      := v_LINK.T_AMORTHEDGCORRCHANGE;
           v_NewLot.T_AMORTHEDGCORRDATE  := v_SourceLot.T_AMORTHEDGCORRDATE;

           IF v_comm.t_SrcPortfolio = KINDPORT_SSSD AND v_comm.t_DestPortofolio = KINDPORT_ASCB THEN
             v_NewLot.T_ESTRESERVE         := 0;
             v_NewLot.T_CORRESTRESERVE     := v_LINK.T_ESTRESERVCHANGE;
             v_NewLot.T_CORRESTRESERVEDATE := v_SourceLot.T_ESTRESERVEDATE;
           ELSIF v_comm.t_SrcPortfolio = KINDPORT_ASCB AND v_comm.t_DestPortofolio = KINDPORT_SSSD THEN
             v_NewLot.T_ESTRESERVE         := v_LINK.T_CORRESTRESERVCHANGE;
             v_NewLot.T_ESTRESERVEDATE     := v_SourceLot.T_CORRESTRESERVEDATE;
             v_NewLot.T_CORRESTRESERVE     := 0;
           ELSE
             v_NewLot.T_ESTRESERVE         := 0;
             v_NewLot.T_CORRESTRESERVE     := 0;
           END IF;

           IF (v_comm.t_SrcPortfolio = KINDPORT_SSPU AND v_comm.t_DestPortofolio = KINDPORT_ASCB) THEN
             v_NewLot.T_RECALCDATE     := v_SaleLot.T_DATE;

             v_NewLot.T_COST := v_LINK.T_COSTBUY + v_NewLot.T_DISCOUNTINCOME + ROUND(RSI_RSB_FIInstr.ConvSum(v_LINK.T_OVERCHANGE, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2);

             v_NewLot.T_BALANCECOST := v_NewLot.T_COST + v_NewLot.T_NKDAMOUNT + v_NewLot.T_INTERESTINCOME + v_NewLot.T_COSTPFI
                                       + ROUND(RSI_RSB_FIInstr.ConvSum(v_NewLot.T_CORRVALUE, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2)
                                       + ROUND(RSI_RSB_FIInstr.ConvSum(v_NewLot.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2)
                                       + ROUND(RSI_RSB_FIInstr.ConvSum(v_NewLot.T_HEDGCORR, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2)
                                       + ROUND(RSI_RSB_FIInstr.ConvSum(v_NewLot.T_AMORTHEDGCORR, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2);

             v_D := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate( v_NewLot.T_FIID, v_SALELOT.T_DATE)* v_NewLot.T_AMOUNT, 2) - v_NewLot.T_COST;

             IF v_D > 0 AND v_NewLot.T_BEGBONUS > 0 THEN --Премия сменилась на дисконт
               v_NewLot.T_OLDBEGBONUS    := v_NewLot.T_BEGBONUS;
               v_NewLot.T_OLDBONUS       := v_NewLot.T_BONUS;
               
               v_NewLot.T_BEGBONUS := 0;
               v_NewLot.T_BONUS    := 0;

               v_NewLot.T_BEGDISCOUNT    := v_D;
               v_NewLot.T_DISCOUNTINCOME := 0;
               v_NewLot.T_BEGDISCOUNTDATE := v_NewLot.T_RECALCDATE;

             ELSIF v_D > 0 AND v_NewLot.T_BEGDISCOUNT != v_D THEN --Изменилась величина начального дисконта
               v_NewLot.T_BEGDISCOUNT    := v_D;
               v_NewLot.T_DISCOUNTINCOME := 0;
               v_NewLot.T_DISCOUNTDATE   := v_NewLot.T_RECALCDATE;
               v_NewLot.T_BEGDISCOUNTDATE := v_NewLot.T_RECALCDATE;

             ELSIF v_D < 0 AND v_NewLot.T_BEGDISCOUNT > 0 THEN --Дисконт сменился на премию
               v_NewLot.T_OLDBEGDISCOUNT := v_NewLot.T_BEGDISCOUNT;
               
               v_NewLot.T_BEGDISCOUNT    := 0;
               v_NewLot.T_DISCOUNTINCOME := 0;

               v_NewLot.T_BEGBONUS     := -v_D;
               v_NewLot.T_BONUS        := 0;
               v_NewLot.T_BONUSDATE    := v_NewLot.T_RECALCDATE;
               v_NewLot.T_BEGBONUSDATE := v_NewLot.T_RECALCDATE;
             ELSIF v_D < 0 AND v_NewLot.T_BEGBONUS != -v_D THEN --Изменилась величина начальной премии
               v_NewLot.T_BEGBONUS     := -v_D;
               v_NewLot.T_BONUS        := 0;
               v_NewLot.T_BEGBONUSDATE := v_NewLot.T_RECALCDATE;

             ELSIF v_D = 0 AND v_NewLot.T_BEGBONUS > 0 THEN
               v_NewLot.T_OLDBEGBONUS    := v_NewLot.T_BEGBONUS;
               v_NewLot.T_OLDBONUS       := v_NewLot.T_BONUS;
               
               v_NewLot.T_BEGBONUS := 0;
               v_NewLot.T_BONUS    := 0;
             ELSIF v_D = 0 AND v_NewLot.T_BEGDISCOUNT > 0 THEN
               v_NewLot.T_OLDBEGDISCOUNT := v_NewLot.T_BEGDISCOUNT;
               
               v_NewLot.T_BEGDISCOUNT    := 0;
               v_NewLot.T_DISCOUNTINCOME := 0;
             END IF;

           END IF;

           RSI_InsDfltIntoWRTSUM(v_NewLot);
           INSERT INTO DPMWRTSUM_DBT VALUES v_NewLot RETURNING T_SUMID INTO v_NewLot.T_SUMID;


           v_AmortCalcKind          := 0;
           IF v_CurFIisBond = TRUE THEN --Только для облигаций
             v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
             
             IF v_NewLot.T_PORTFOLIO = KINDPORT_ASCB THEN
                IF RSB_SECUR.GetEssentialDev(
                       RSB_SECUR.LEVELESSENTIAL_AC, -- Вид уровня существенности = Отклонение АС
                       v_NewLot.T_PORTFOLIO, --Портфель = АС_БПП
                       v_comm.t_CommDate, --Плановая дата поставки
                       0,
                       0,
                       0,
                       v_tick.t_BOfficeKind,
                       v_tick.t_DealID,
                       v_SignDeviation, -- Да/нет
                       v_RateKind,      -- Наименование ставки используемой в дальнейшем
                       v_RateVal        -- Значение ставки
                      ) <> 0 THEN
                   dbms_output.put_line('Ошибка: неверные параметры при вызове ф-ции проверки на существенность отклонения');
                END IF;

                v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;

                IF v_SignDeviation = FALSE THEN
                   v_DrawingDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(v_NewLot.T_FIID, v_avr.t_Termless);

                   IF v_DrawingDate <> UnknownDate AND
                      ADD_MONTHS(v_NewLot.T_DATE, 12) > v_DrawingDate AND
                      EPSAvrLessThanYear() = EPSAVRLESSTHANYEAR_NO THEN
                      v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;

                   ELSIF EPSAvrNSignDevACEPSACLM() = EPSAVRNSIGNDEVACEPSACLM_NO THEN
                      v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;
                   END IF;
                END IF;

             ELSIF v_NewLot.T_PORTFOLIO = KINDPORT_SSPU AND Rsb_Common.GetRegIntValue('SECUR\МСФО\ЭПС ДЛЯ ЦБ В ССПУ_ЦБ', 0) = 1 THEN 
               v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
             ELSIF v_NewLot.T_PORTFOLIO = KINDPORT_SSSD AND Rsb_Common.GetRegIntValue('SECUR\МСФО\ЭПС ДЛЯ ЦБ В СССД_ЦБ', 0) = 1 THEN
               v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
             END IF;

             IF v_avr.t_FloatingRate = 'X' AND RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECDEAL, v_tick.t_DealID) = 0 THEN -- Тест на рыночность пройден = Да
               IF FRBONDS_AMORTCALCKIND_LM = 0 THEN
                 v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
               ELSE
                 v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
               END IF;
             END IF;
           END IF;


           v_EIR := 0;

           --определение АС по методу v_AmortCalcKind
           IF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS AND v_AmortCalcKind = v_SourceLot.T_AMORTCALCKIND THEN
              v_EIR           := v_SourceLot.T_EFFECTINTERESTRATE;
              v_AmortCost     := v_SourceLot.T_AMORTCOST;
              v_AmortCostDate := v_SourceLot.T_AMORTCOSTDATE;
           ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
              v_EIR           := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_AVR, v_NewLot.t_DealID, v_NewLot.t_SumID, v_NewLot.t_Date);
              v_AmortCost     := v_NewLot.T_BALANCECOST; --в ВН
              v_AmortCostDate := v_comm.t_CommDate;
           ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM THEN
              v_AmortCost     := v_NewLot.T_BALANCECOST; --в ВН
              v_AmortCostDate := v_comm.t_CommDate;
           END IF;

           IF v_comm.t_SrcPortfolio = KINDPORT_SSSD AND v_comm.t_DestPortofolio = KINDPORT_ASCB THEN
             IF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
                v_AmortCost := RSB_SECUR.CalcAS_EPS(RSB_SECUR.CALCKIND_AVR, v_NewLot.t_DealID, 0, v_comm.t_CommDate, v_EIR); --в ВН
             ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM THEN
                v_AmortCost := RSB_SECUR.CalcAS_Line(RSB_SECUR.CALCKIND_AVR, v_NewLot.t_DealID, 0, v_comm.t_CommDate); --в ВН
             END IF;
           END IF;

           UPDATE DPMWRTSUM_DBT
              SET T_AMORTCALCKIND      = v_AmortCalcKind,
                  T_EFFECTINTERESTRATE = v_EIR,
                  T_AMORTCOST          = v_AmortCost,
                  T_AMORTCOSTDATE      = v_AmortCostDate
            WHERE T_SUMID = v_NewLot.t_SumID;

           v_PartNum := v_PartNum + 1;
         END LOOP;
       END IF;

       v_NewLot := NULL;

       --лоты БПП - новые не создаем, а обновляем существующие, т.к. пока БПП всегда переводим все целиком
       v_CurAmount := v_comm.t_Currency_Sum;
       IF v_CurAmount > 0 THEN
         v_Course := NVL(RSB_Secur.SC_ConvSumTypeRep(1, v_fin.t_FIID, v_fin.t_FaceValueFI, v_fin.t_FaceValueFI, v_FVCourseType, v_comm.t_CommDate), 0);
         if(v_Course = 0) then
           SetError(WRTOFF_ERROR_20267);
         end if;
         
         FOR LOT IN (SELECT *
                       FROM DPMWRTSUM_DBT
                      WHERE T_PARTY       = -1
                        AND T_DEPARTMENT  = v_comm.t_Division
                        AND T_CONTRACT    = 0
                        AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
                        AND T_PORTFOLIO   = v_comm.t_SrcPortfolio
                        AND T_STATE       = PM_WRTSUM_SALE_BPP 
                        AND T_ENTERDATE   <= v_comm.t_CommDate
                        AND T_FIID        = v_comm.t_FIID
                        AND T_AMOUNT      > 0
                    )
         LOOP
           RSI_WRTSaveLot (LOT.T_SUMID, p_ID_Operation, p_ID_Step, v_comm.t_CommDate, PM_WRT_UPDTMODE_PORTFOLIO);
           
           v_BegDate := LOT.T_BEGDATE;
           IF v_CurFIisBond = TRUE AND v_fin.t_FaceValueFI != RSI_RSB_FIInstr.NATCUR THEN
              v_BegDate := v_comm.t_CommDate;
           END IF;

           IF v_comm.t_SrcPortfolio = KINDPORT_SSSD AND v_comm.t_DestPortofolio = KINDPORT_ASCB THEN
             v_EstReserve         := 0;
             v_EstReserveDate     := LOT.T_ESTRESERVEDATE;
             v_CorrEstReserve     := LOT.T_ESTRESERVE;
             v_CorrEstReserveDate := LOT.T_ESTRESERVEDATE;
           ELSIF v_comm.t_SrcPortfolio = KINDPORT_ASCB AND v_comm.t_DestPortofolio = KINDPORT_SSSD THEN
             v_EstReserve         := LOT.T_CORRESTRESERVE;
             v_EstReserveDate     := LOT.T_CORRESTRESERVEDATE;
             v_CorrEstReserve     := 0;
             v_CorrEstReserveDate := LOT.T_CORRESTRESERVEDATE;
           ELSE
             v_EstReserve         := 0;
             v_EstReserveDate     := LOT.T_ESTRESERVEDATE;
             v_CorrEstReserve     := 0;
             v_CorrEstReserveDate := LOT.T_CORRESTRESERVEDATE;
           END IF;

           UPDATE DPMWRTSUM_DBT
              SET T_PORTFOLIO          = v_comm.t_DestPortofolio,
                  T_GROUPID            = v_Group,
                  T_BEGDATE            = v_BegDate,
                  T_ESTRESERVE         = v_EstReserve,
                  T_ESTRESERVEDATE     = v_EstReserveDate,
                  T_CORRESTRESERVE     = v_CorrEstReserve,
                  T_CORRESTRESERVEDATE = v_CorrEstReserveDate,
                  T_OVERAMOUNT         = DECODE(v_comm.t_DestPortofolio, KINDPORT_ASCB, 0, T_OVERAMOUNT),
                  T_OVERDATE           = DECODE(v_comm.t_DestPortofolio, KINDPORT_ASCB, UnknownDate, T_OVERDATE)
            WHERE T_SUMID = LOT.T_SUMID;

           SELECT * INTO v_tick
             FROM DDL_TICK_DBT
            WHERE t_DealID = LOT.T_DEALID;

           v_AmortCalcKind          := 0;
           IF v_CurFIisBond = TRUE THEN --Только для облигаций
             v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
             
             IF v_comm.t_DestPortofolio = KINDPORT_ASCB THEN
                IF RSB_SECUR.GetEssentialDev(
                       RSB_SECUR.LEVELESSENTIAL_AC, -- Вид уровня существенности = Отклонение АС
                       v_comm.t_DestPortofolio, --Портфель = АС_БПП
                       v_comm.t_CommDate, --Плановая дата поставки
                       0,
                       0,
                       0,
                       v_tick.t_BOfficeKind,
                       v_tick.t_DealID,
                       v_SignDeviation, -- Да/нет
                       v_RateKind,      -- Наименование ставки используемой в дальнейшем
                       v_RateVal        -- Значение ставки
                      ) <> 0 THEN
                   dbms_output.put_line('Ошибка: неверные параметры при вызове ф-ции проверки на существенность отклонения');
                END IF;

                v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;

                IF v_SignDeviation = FALSE THEN
                   v_DrawingDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(LOT.T_FIID, v_avr.t_Termless);

                   IF v_DrawingDate <> UnknownDate AND
                      ADD_MONTHS(LOT.T_DATE, 12) > v_DrawingDate AND
                      EPSAvrLessThanYear() = EPSAVRLESSTHANYEAR_NO THEN
                      v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;

                   ELSIF EPSAvrNSignDevACEPSACLM() = EPSAVRNSIGNDEVACEPSACLM_NO THEN
                      v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;
                   END IF;
                END IF;

             ELSIF v_comm.t_DestPortofolio = KINDPORT_SSPU AND Rsb_Common.GetRegIntValue('SECUR\МСФО\ЭПС ДЛЯ ЦБ В ССПУ_ЦБ', 0) = 1 THEN 
               v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
             ELSIF v_comm.t_DestPortofolio = KINDPORT_SSSD AND Rsb_Common.GetRegIntValue('SECUR\МСФО\ЭПС ДЛЯ ЦБ В СССД_ЦБ', 0) = 1 THEN
               v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
             END IF;

             IF v_avr.t_FloatingRate = 'X' AND RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECDEAL, v_tick.t_DealID) = 0 THEN -- Тест на рыночность пройден = Да
               IF FRBONDS_AMORTCALCKIND_LM = 0 THEN
                 v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
               ELSE
                 v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
               END IF;
             END IF;
           END IF;


           v_EIR := 0;

           --определение АС по методу v_AmortCalcKind
           IF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS AND v_AmortCalcKind = v_SourceLot.T_AMORTCALCKIND THEN
              v_EIR           := LOT.T_EFFECTINTERESTRATE;
              v_AmortCost     := LOT.T_AMORTCOST;
              v_AmortCostDate := LOT.T_AMORTCOSTDATE;
           ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
              v_EIR           := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_AVR, LOT.t_DealID, LOT.t_SumID, LOT.t_Date);
              v_AmortCost     := LOT.T_BALANCECOST; --в ВН
              v_AmortCostDate := v_comm.t_CommDate;
           ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM THEN
              v_AmortCost     := LOT.T_BALANCECOST; --в ВН
              v_AmortCostDate := v_comm.t_CommDate;
           END IF;

           IF v_comm.t_SrcPortfolio = KINDPORT_SSSD AND v_comm.t_DestPortofolio = KINDPORT_ASCB THEN
             IF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
                v_AmortCost := RSB_SECUR.CalcAS_EPS(RSB_SECUR.CALCKIND_AVR, LOT.t_DealID, 0, v_comm.t_CommDate, v_EIR); --в ВН
             ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM THEN
                v_AmortCost := RSB_SECUR.CalcAS_Line(RSB_SECUR.CALCKIND_AVR, LOT.t_DealID, 0, v_comm.t_CommDate); --в ВН
             END IF;
           END IF;

           UPDATE DPMWRTSUM_DBT
              SET T_AMORTCALCKIND      = v_AmortCalcKind,
                  T_EFFECTINTERESTRATE = v_EIR,
                  T_AMORTCOST          = v_AmortCost,
                  T_AMORTCOSTDATE      = v_AmortCostDate
            WHERE T_SUMID = LOT.t_SumID;


           IF (v_comm.t_SrcPortfolio = KINDPORT_SSPU AND v_comm.t_DestPortofolio = KINDPORT_ASCB) THEN

             v_Cost := LOT.T_COST + LOT.T_DISCOUNTINCOME + ROUND(RSI_RSB_FIInstr.ConvSum(LOT.T_OVERAMOUNT, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2);

             LOT.T_BALANCECOST := v_Cost + LOT.T_INTERESTINCOME + LOT.T_COSTPFI
                                  + ROUND(RSI_RSB_FIInstr.ConvSum(LOT.T_CORRVALUE, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 ), 2)
                                  + ROUND(RSI_RSB_FIInstr.ConvSum(LOT.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1), 2)
                                  + ROUND(RSI_RSB_FIInstr.ConvSum(LOT.T_HEDGCORR, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1), 2)
                                  + ROUND(RSI_RSB_FIInstr.ConvSum(LOT.T_AMORTHEDGCORR, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1), 2);

             UPDATE DPMWRTSUM_DBT
                SET T_RECALCDATE  = v_comm.t_CommDate,
                    T_OVERAMOUNT  = 0,
                    T_OVERDATE    = UnknownDate,
                    T_COST        = v_Cost,
                    T_BALANCECOST = LOT.T_BALANCECOST
              WHERE T_SUMID = LOT.T_SUMID;
   
             v_D := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate( LOT.T_FIID, v_comm.t_CommDate)* LOT.T_AMOUNT, 2) - v_Cost;

             IF v_D > 0 AND LOT.T_BEGBONUS > 0 THEN --Премия сменилась на дисконт
               UPDATE DPMWRTSUM_DBT
                  SET T_OLDBEGBONUS     = LOT.T_BEGBONUS,
                      T_OLDBONUS        = LOT.T_BONUS,   
                      T_BEGBONUS        = 0,
                      T_BONUS           = 0,
                      T_BEGDISCOUNT     = v_D,                   
                      T_DISCOUNTINCOME  = 0,                     
                      T_BEGDISCOUNTDATE = v_comm.t_CommDate
                WHERE T_SUMID = LOT.T_SUMID;

             ELSIF v_D > 0 AND LOT.T_BEGDISCOUNT != v_D THEN --Изменилась величина начального дисконта
               UPDATE DPMWRTSUM_DBT
                  SET T_BEGDISCOUNT     = v_D,                  
                      T_DISCOUNTINCOME  = 0,                    
                      T_DISCOUNTDATE    = v_comm.t_CommDate,
                      T_BEGDISCOUNTDATE = v_comm.t_CommDate
                WHERE T_SUMID = LOT.T_SUMID;

             ELSIF v_D < 0 AND LOT.T_BEGDISCOUNT > 0 THEN --Дисконт сменился на премию
               UPDATE DPMWRTSUM_DBT
                  SET T_OLDBEGDISCOUNT = LOT.T_BEGDISCOUNT,
                      T_BEGDISCOUNT    = 0,                     
                      T_DISCOUNTINCOME = 0,                     
                      T_BEGBONUS       = -v_D,                    
                      T_BONUS          = 0,                       
                      T_BONUSDATE      = v_comm.t_CommDate,   
                      T_BEGBONUSDATE   = v_comm.t_CommDate       
                WHERE T_SUMID = LOT.T_SUMID;

             ELSIF v_D < 0 AND LOT.T_BEGBONUS != -v_D THEN --Изменилась величина начальной премии
               UPDATE DPMWRTSUM_DBT
                  SET T_BEGBONUS     = -v_D,                     
                      T_BONUS        = 0,                        
                      T_BEGBONUSDATE = v_comm.t_CommDate
                WHERE T_SUMID = LOT.T_SUMID;

             ELSIF v_D = 0 AND LOT.T_BEGBONUS > 0 THEN
               UPDATE DPMWRTSUM_DBT
                  SET T_OLDBEGBONUS = LOT.T_BEGBONUS,         
                      T_OLDBONUS    = LOT.T_BONUS,            
                      T_BEGBONUS    = 0,                        
                      T_BONUS       = 0                        
                WHERE T_SUMID = LOT.T_SUMID;

             ELSIF v_D = 0 AND LOT.T_BEGDISCOUNT > 0 THEN
               UPDATE DPMWRTSUM_DBT
                  SET T_OLDBEGDISCOUNT = LOT.T_BEGDISCOUNT,         
                      T_BEGDISCOUNT    = 0,                              
                      T_DISCOUNTINCOME = 0                                
                WHERE T_SUMID = LOT.T_SUMID;
               
             END IF;

           END IF;

           v_CurAmount := v_CurAmount - LOT.T_AMOUNT;
         END LOOP;

         IF (v_CurAmount != 0) THEN
           SetError( WRTOFF_ERROR_20205 );
         END IF;

       END IF;

     END IF;


     --Если переносим в ПДО, то переносим всегда весь портфель, поэтому просто обновляем существующие лоты
     --Если есть лоты БПП, то в ПДО переводить нельзя 
     IF v_comm.t_DestPortofolio = KINDPORT_PROMISSORY THEN

       v_CurAmount := v_comm.t_Hidden_Sum;

       FOR LOT IN (SELECT *
                     FROM DPMWRTSUM_DBT
                    WHERE T_PARTY       = -1
                      AND T_DEPARTMENT  = v_comm.t_Division
                      AND T_CONTRACT    = 0
                      AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
                      AND T_PORTFOLIO   = v_comm.t_SrcPortfolio
                      AND T_STATE       = PM_WRTSUM_FORM
                      AND T_ENTERDATE   <= v_comm.t_CommDate
                      AND T_FIID        = v_comm.t_FIID
                      AND T_AMOUNT      > 0
                  )
       LOOP

         RSI_WRTSaveLot (LOT.T_SUMID, p_ID_Operation, p_ID_Step, v_comm.t_CommDate, PM_WRT_UPDTMODE_PORTFOLIO);

         v_BegDate := LOT.T_BEGDATE;
         IF v_CurFIisBond = TRUE AND v_fin.t_FaceValueFI != RSI_RSB_FIInstr.NATCUR THEN
            v_BegDate := v_comm.t_CommDate;
         END IF;

         v_Cost := LOT.T_COST + LOT.T_NKDAMOUNT + LOT.T_INTERESTINCOME + LOT.T_DISCOUNTINCOME;

         UPDATE DPMWRTSUM_DBT
            SET T_PORTFOLIO          = v_comm.t_DestPortofolio,
                T_GROUPID            = v_Group,
                T_BEGDATE            = v_BegDate,
                T_COST               = v_Cost,
                T_BALANCECOST        = v_Cost + LOT.T_COSTPFI + LOT.T_OUTLAY,
                T_NKDAMOUNT          = 0,
                T_INTERESTINCOME     = 0,
                T_INTERESTDATE       = (CASE WHEN LOT.T_INTERESTDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_INTERESTDATE END),
                T_BEGBONUS           = 0,
                T_BONUS              = 0,
                T_BONUSDATE          = (CASE WHEN LOT.T_BONUSDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_BONUSDATE END),
                T_BEGDISCOUNT        = 0,
                T_DISCOUNTINCOME     = 0,
                T_DISCOUNTDATE       = (CASE WHEN LOT.T_DISCOUNTDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_DISCOUNTDATE END),
                T_OVERAMOUNT         = 0,
                T_OVERDATE           = (CASE WHEN LOT.T_OVERDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_OVERDATE END),
                T_CORRVALUE          = 0,
                T_CORRINTTOEIR       = 0,
                T_CORRINTTOEIRDATE   = (CASE WHEN LOT.T_CORRINTTOEIRDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_CORRINTTOEIRDATE END),
                T_RESERVAMOUNT       = 0,
                T_INCOMERESERV       = 0,
                T_RESERVDATE         = (CASE WHEN LOT.T_RESERVDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_RESERVDATE END),
                T_ESTRESERVE         = 0,
                T_ESTRESERVEDATE     = (CASE WHEN LOT.T_ESTRESERVEDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_ESTRESERVEDATE END),
                T_CORRESTRESERVE     = 0,
                T_CORRESTRESERVEDATE = (CASE WHEN LOT.T_CORRESTRESERVEDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_CORRESTRESERVEDATE END),
                T_BEGDEFDIFF         = 0,
                T_ACCOUNTEDDEFDIFF   = 0,
                T_DEFDIFFDATE        = (CASE WHEN LOT.T_DEFDIFFDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_DEFDIFFDATE END),
                T_HEDGCORR           = 0,
                T_HEDGCORRDATE       = (CASE WHEN LOT.T_HEDGCORRDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_HEDGCORRDATE END),
                T_AMORTHEDGCORR      = 0,
                T_AMORTHEDGCORRDATE  = (CASE WHEN LOT.T_AMORTHEDGCORRDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_AMORTHEDGCORRDATE END)
          WHERE T_SUMID = LOT.T_SUMID;

          v_CurAmount := v_CurAmount - LOT.T_AMOUNT;

       END LOOP;

       IF (v_CurAmount != 0) THEN
         SetError( WRTOFF_ERROR_20205 );
       END IF;

     END IF;

     --Если в ПКУ или из ПКУ, то переносим всегда весь портфель, поэтому просто обновляем существующие лоты
     IF v_comm.t_DestPortofolio = KINDPORT_CONTR OR v_comm.t_SrcPortfolio = KINDPORT_CONTR THEN

       SELECT NVL(SUM(t_Amount), 0), NVL(SUM(t_Balancecost), 0), NVL(SUM(t_Cost), 0), NVL(SUM(t_OverAmount), 0), NVL(SUM(t_CorrValue), 0)
         INTO v_SumAmount, v_SumBalancecost, v_SumCost, v_SumOverAmount, v_SumCorrValue
         FROM DPMWRTSUM_DBT
        WHERE T_PARTY       = -1
          AND T_DEPARTMENT  = v_comm.t_Division
          AND T_CONTRACT    = 0
          AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
          AND T_PORTFOLIO   = v_comm.t_SrcPortfolio
          AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
          AND T_ENTERDATE   <= v_comm.t_CommDate
          AND T_FIID        = v_comm.t_FIID
          AND T_AMOUNT      > 0;

       IF( v_comm.t_DestPortofolio = KINDPORT_CONTR ) THEN
          v_ConvertSumBalancecost := RSI_RSB_FIInstr.ConvSum(v_SumBalancecost, v_fin.t_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_comm.t_CommDate, 1 ) - v_SumOverAmount - v_SumCorrValue;
          v_ConvertSumCost        := RSI_RSB_FIInstr.ConvSum(v_SumCost, v_fin.t_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_comm.t_CommDate, 1 );
       ELSE 
          v_ConvertSumBalancecost := RSI_RSB_FIInstr.ConvSum(v_SumBalancecost, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 );
          v_ConvertSumCost        := RSI_RSB_FIInstr.ConvSum(v_SumCost, RSI_RSB_FIInstr.NATCUR, v_fin.t_FaceValueFI, v_comm.t_CommDate, 1 );
       END IF;
       v_CurConvertSumBalancecost := v_ConvertSumBalancecost;
       v_CurConvertSumCost        := v_ConvertSumCost;

       v_CurAmount := v_comm.t_Hidden_Sum + v_comm.t_Currency_Sum;

       FOR LOT IN (SELECT *
                     FROM DPMWRTSUM_DBT
                    WHERE T_PARTY       = -1
                      AND T_DEPARTMENT  = v_comm.t_Division
                      AND T_CONTRACT    = 0
                      AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
                      AND T_PORTFOLIO   = v_comm.t_SrcPortfolio
                      AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                      AND T_ENTERDATE   <= v_comm.t_CommDate
                      AND T_FIID        = v_comm.t_FIID
                      AND T_AMOUNT      > 0
                    ORDER BY T_AMOUNT DESC
                  )
       LOOP

         RSI_WRTSaveLot (LOT.T_SUMID, p_ID_Operation, p_ID_Step, v_comm.t_CommDate, PM_WRT_UPDTMODE_PORTFOLIO);

         IF( v_CurAmount = LOT.T_Amount ) THEN
            v_NewCost        := v_CurConvertSumCost;
            v_NewBalancecost := v_CurConvertSumBalancecost;
         ELSE
            v_NewCost        := round(v_ConvertSumBalancecost / v_SumAmount * LOT.T_Amount, 2);
            v_NewBalancecost := round(v_ConvertSumBalancecost / v_SumAmount * LOT.T_Amount, 2);
         END IF;
         v_CurConvertSumCost        := v_CurConvertSumCost - v_NewCost;
         v_CurConvertSumBalancecost := v_CurConvertSumBalancecost - v_NewBalancecost;

         v_BegDate := LOT.T_BEGDATE;
         IF v_CurFIisBond = TRUE AND v_fin.t_FaceValueFI != RSI_RSB_FIInstr.NATCUR THEN
            v_BegDate := v_comm.t_CommDate;
         END IF;

         IF v_comm.t_DestPortofolio = KINDPORT_CONTR THEN
           UPDATE DPMWRTSUM_DBT
              SET T_PORTFOLIO          = v_comm.t_DestPortofolio,
                  T_GROUPID            = v_Group,
                  T_BEGDATE            = v_BegDate,
                  T_COST               = v_NewCost,
                  T_BALANCECOST        = v_NewBalancecost,
                  T_OVERAMOUNT         = 0,
                  T_OVERDATE           = (CASE WHEN LOT.T_OVERDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_OVERDATE END),
                  T_CORRVALUE          = 0,
                  T_CORRINTTOEIR       = 0,
                  T_HEDGCORR           = 0,
                  T_AMORTHEDGCORR      = 0
            WHERE T_SUMID = LOT.T_SUMID;
         ELSE
           UPDATE DPMWRTSUM_DBT
              SET T_PORTFOLIO          = v_comm.t_DestPortofolio,
                  T_GROUPID            = v_Group,
                  T_BEGDATE            = v_BegDate,
                  T_COST               = v_NewCost,       
                  T_BALANCECOST        = v_NewBalancecost,
                  T_RESERVAMOUNT       = 0,
                  T_INCOMERESERV       = 0,
                  T_RESERVDATE         = (CASE WHEN LOT.T_RESERVDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_RESERVDATE END),
                  T_ESTRESERVE         = 0,
                  T_ESTRESERVEDATE     = (CASE WHEN LOT.T_ESTRESERVEDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_ESTRESERVEDATE END),
                  T_CORRESTRESERVE     = 0,
                  T_CORRESTRESERVEDATE = (CASE WHEN LOT.T_CORRESTRESERVEDATE != UnknownDate THEN v_comm.t_CommDate ELSE T_CORRESTRESERVEDATE END)
            WHERE T_SUMID = LOT.T_SUMID;
         END IF;

         v_CurAmount := v_CurAmount - LOT.T_AMOUNT;

       END LOOP;

       IF (v_CurAmount != 0) THEN
         SetError( WRTOFF_ERROR_20205 );
       END IF;

     END IF;



   END;--RSI_WRTExecMoving


   ----------------------------------------------------------------------------------------------------------------------
   ---- Выполняет все действия с лотами при отказе от РЕПО.
   ---- Считаем, что вызывается только если отказ от 2ч обратного РЕПО.
   PROCEDURE RSI_WRTRejectDeal( p_SumID        IN NUMBER,   -- ID лота 2ч обратного РЕПО
                                p_OperDate     IN DATE,     -- Дата операции
                                p_Portfolio    IN NUMBER,   -- Портфель, куда зачисляем ц/б
                                p_GroupID      IN NUMBER,   -- Группа списания

                                p_Amount       IN NUMBER,   -- Кол-во в лоте 1ч
                                p_Sum          IN NUMBER,   -- Стоимость (без НКД) из панели расчетов
                                p_Currency     IN NUMBER,   -- ВЦ из панели расчетов
                                p_Cost         IN NUMBER,   -- Стоимость (без НКД) из панели расчетов, переведенная в ВН по дате отказа
                                p_NKD          IN NUMBER,   -- НКД из панели расчетов
                                p_BegDiscount  IN NUMBER,   -- Новый начальный дисконт
                                p_BegBonus     IN NUMBER,   -- Новая начальная премия

                                p_ID_Operation IN NUMBER,   -- Операция
                                p_ID_Step      IN NUMBER    -- Шаг операции
                              )
   IS
      v_SaleLot       DPMWRTSUM_DBT%ROWTYPE;
      v_Lot2          DPMWRTSUM_DBT%ROWTYPE;
      v_Lot1          DPMWRTSUM_DBT%ROWTYPE;
      v_BuyLot        DPMWRTSUM_DBT%ROWTYPE;
      v_SaleID        NUMBER := 0;
      v_SumID         NUMBER := 0;

      v_Amount_PVO     NUMBER := 0;
      v_Amount_PVO_BPP NUMBER := 0;

      v_MaxPartNum     NUMBER := 0;

      v_LotState       NUMBER;
      v_DocID          NUMBER;

      TYPE Number10Table_t IS TABLE OF NUMBER(10);
      TYPE Number3212Table_t IS TABLE OF NUMBER(32,12);

      arrSumID            Number10Table_t;
      arrAmount           Number3212Table_t;

      i NUMBER := 0;
      v_FaceValueFI    NUMBER := 0;

   BEGIN
     InitError();

     -- Получим буфер лота 2ч обратного РЕПО
     SELECT * INTO v_Lot2
       FROM DPMWRTSUM_DBT
      WHERE t_SumID = p_SumID;

     -- Получим буфер лота 1ч обратного РЕПО
     SELECT * INTO v_Lot1
       FROM DPMWRTSUM_DBT
      WHERE t_SumID = v_Lot2.t_Parent;


     SELECT NVL(SUM(Buy.t_Amount), 0) INTO v_Amount_PVO
       FROM DPMWRTSUM_DBT Buy
      WHERE Buy.t_Source = v_Lot2.t_Parent
        AND Buy.t_Portfolio = KINDPORT_BACK
        AND Buy.t_State = PM_WRTSUM_FORM;

     v_Amount_PVO := v_Amount_PVO + v_Lot1.t_Amount;


     SELECT NVL(SUM(Buy2.t_Amount), 0) INTO v_Amount_PVO_BPP
       FROM DPMWRTSUM_DBT Buy2
      WHERE Buy2.t_Source = v_Lot2.t_Parent
        AND Buy2.t_Portfolio = KINDPORT_BASICDEBT
        AND Buy2.t_State = PM_WRTSUM_NOTFORM;

     SELECT FIN.T_FACEVALUEFI INTO v_FaceValueFI
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID = v_Lot1.t_FIID;


     BEGIN
       SELECT q.t_SumID,
              q.t_Amount
         BULK COLLECT INTO
              arrSumID,
              arrAmount
         FROM (SELECT Buy.t_SumID, Buy.t_Amount
                 FROM DPMWRTSUM_DBT Buy
                WHERE Buy.t_Amount > 0
                  AND Buy.t_Source = v_Lot2.t_Parent
                  AND (   (Buy.t_Portfolio = KINDPORT_BACK AND Buy.t_State = PM_WRTSUM_FORM)
                       OR (Buy.t_Portfolio = KINDPORT_BASICDEBT AND Buy.t_State = PM_WRTSUM_NOTFORM))
               UNION
               SELECT Buy.t_SumID, Buy.t_Amount
                 FROM DPMWRTSUM_DBT Buy
                WHERE Buy.t_SumID = v_Lot1.t_SumID
                  AND Buy.t_Amount > 0
              ) q;

       EXCEPTION
         WHEN NO_DATA_FOUND THEN NULL;

     END;


     IF v_Amount_PVO > 0 THEN
       SELECT NVL(MAX(LOT.T_PARTNUM), 0) INTO v_MaxPartNum
         FROM DPMWRTSUM_DBT LOT
        WHERE LOT.T_DOCKIND = v_Lot1.T_DOCKIND
          AND LOT.T_DOCID = v_Lot1.T_DOCID
          AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_SALE;


       --Создается лот списания
       v_SaleLot.T_SUMID              :=  0;
       v_SaleLot.T_DOCKIND            :=  v_Lot1.T_DOCKIND;
       v_SaleLot.T_DOCID              :=  v_Lot1.T_DOCID;
       v_SaleLot.T_PARTNUM            :=  v_MaxPartNum + 1;
       v_SaleLot.T_PARTY              :=  v_Lot1.T_PARTY;
       v_SaleLot.T_CONTRACT           :=  0;
       v_SaleLot.T_PORTFOLIO          :=  KINDPORT_BACK;
       v_SaleLot.T_GROUPID            :=  RSI_GetWrtoffGroupByPortfolio(v_SaleLot.T_PORTFOLIO);
       v_SaleLot.T_FIID               :=  v_Lot1.T_FIID;
       v_SaleLot.T_BUY_SALE           :=  PM_WRITEOFF_SUM_SALE;
       v_SaleLot.T_KIND               :=  WRTSUM_KIND_MS;
       v_SaleLot.T_DATE               :=  p_OperDate;
       v_SaleLot.T_TIME               :=  UnknownTime;
       v_SaleLot.T_AMOUNT             :=  v_Amount_PVO;
       v_SaleLot.T_AMOUNTBD           :=  0;
       v_SaleLot.T_SUM                :=  0;
       v_SaleLot.T_CURRENCY           :=  0;
       v_SaleLot.T_COST               :=  0;
       v_SaleLot.T_BALANCECOST        :=  0;
       v_SaleLot.T_BALANCECOSTBD      :=  0;
       v_SaleLot.T_NKDAMOUNT          :=  0;
       v_SaleLot.T_INTERESTINCOME     :=  0;
       v_SaleLot.T_NOTCARRYINTEREST   :=  0;
       v_SaleLot.T_INTERESTDATE       :=  UnknownDate;
       v_SaleLot.T_BEGDATE            :=  UnknownDate;
       v_SaleLot.T_BEGDISCOUNT        :=  0;
       v_SaleLot.T_OLDBEGDATE         :=  UnknownDate;
       v_SaleLot.T_OLDBEGDISCOUNT     :=  0;
       v_SaleLot.T_DISCOUNTINCOME     :=  0;
       v_SaleLot.T_NOTCARRYDISCOUNT   :=  0;
       v_SaleLot.T_DISCOUNTDATE       :=  UnknownDate;
       v_SaleLot.T_OUTLAY             :=  0;
       v_SaleLot.T_RESERVAMOUNT       :=  0;
       v_SaleLot.T_INCOMERESERV       :=  0;
       v_SaleLot.T_RESERVDATE         :=  UnknownDate;
       v_SaleLot.T_OVERAMOUNT         :=  0;
       v_SaleLot.T_OVERAMOUNTBD       :=  0;
       v_SaleLot.T_OVERDATE           :=  UnknownDate;
       v_SaleLot.T_COUPON             :=  chr(1);
       v_SaleLot.T_PARTLY             :=  chr(1);
       v_SaleLot.T_PARENT             :=  v_Lot1.t_SumID;
       v_SaleLot.T_SOURCE             :=  0;
       v_SaleLot.T_INSTANCE           :=  0;
       v_SaleLot.T_TRUST              :=  chr(0);
       v_SaleLot.T_ISFREE             :=  chr(0);
       v_SaleLot.T_DEPARTMENT         :=  v_Lot1.T_DEPARTMENT;
       v_SaleLot.T_DEALID             :=  v_Lot1.T_DEALID;
       v_SaleLot.T_DEALDATE           :=  v_Lot1.T_DEALDATE;
       v_SaleLot.T_DEALCODE           :=  v_Lot1.T_DEALCODE;
       v_SaleLot.T_STATE              :=  PM_WRTSUM_FORM;
       v_SaleLot.T_ENTERDATE          :=  p_OperDate;
       v_SaleLot.T_STATEDATE          :=  p_OperDate;
       v_SaleLot.T_CHANGEDATE         :=  p_OperDate;
       v_SaleLot.T_ACTION             :=  PM_WRT_UPDTMODE_DELIVERY;
       v_SaleLot.T_ID_OPERATION       :=  p_ID_Operation;
       v_SaleLot.T_ID_STEP            :=  p_ID_Step;
       v_SaleLot.T_BEGBONUSDATE       :=  UnknownDate;
       v_SaleLot.T_BEGBONUS           :=  0;
       v_SaleLot.T_BONUS              :=  0;
       v_SaleLot.T_BONUSDATE          :=  UnknownDate;
       v_SaleLot.T_ACTIVATEDATE       :=  p_OperDate;
       v_SaleLot.T_ACTIVATETIME       :=  UnknownTime;
       v_SaleLot.T_BLOCKAMOUNT        :=  0;
       v_SaleLot.T_ACCFI              := WRTDetermineAccFI(v_SaleLot.T_FIID);

       RSI_InsDfltIntoWRTSUM(v_SaleLot);
       INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.t_SumID;

       v_SaleID := v_SaleLot.t_SumID;

       -- Выполняется списание
       RSI_WRTLinkSaleToLot( v_SaleLot, 0, p_ID_Operation, p_ID_Step, PMWRTLINK_KIND_PORTFOLIO, PM_WRT_UPDTMODE_REJECTEXEC, false, false, false, false );

     END IF;

     IF v_Amount_PVO_BPP > 0 THEN

        FOR one_lot IN (SELECT t_SumID
                          FROM DPMWRTSUM_DBT
                         WHERE t_Source = v_Lot2.t_Parent
                           AND t_Portfolio = KINDPORT_BASICDEBT
                           AND t_State = PM_WRTSUM_NOTFORM
                       )
        LOOP
          RSI_WRTSaveLot(one_lot.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_REJECTEXEC);

          UPDATE DPMWRTSUM_DBT
             SET t_State = PM_WRTSUM_CANCEL
           WHERE t_SumID = one_lot.t_SumID;

        END LOOP;


        --Создать лот списания
        SELECT NVL(MAX(LOT.T_PARTNUM), 0) INTO v_MaxPartNum
          FROM DPMWRTSUM_DBT LOT
         WHERE LOT.T_DOCKIND = v_Lot1.T_DOCKIND
           AND LOT.T_DOCID = v_Lot1.T_DOCID
           AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_SALE;

        v_SaleLot := NULL;

        v_SaleLot.T_SUMID              :=  0;
        v_SaleLot.T_DOCKIND            :=  v_Lot1.T_DOCKIND;
        v_SaleLot.T_DOCID              :=  v_Lot1.T_DOCID;
        v_SaleLot.T_PARTNUM            :=  v_MaxPartNum + 1;
        v_SaleLot.T_PARTY              :=  v_Lot1.T_PARTY;
        v_SaleLot.T_CONTRACT           :=  0;
        v_SaleLot.T_PORTFOLIO          :=  -1;
        v_SaleLot.T_GROUPID            :=  RSI_GetWrtoffGroupByPortfolio(v_SaleLot.T_PORTFOLIO);
        v_SaleLot.T_FIID               :=  v_Lot1.T_FIID;
        v_SaleLot.T_BUY_SALE           :=  PM_WRITEOFF_SUM_SALE;
        v_SaleLot.T_KIND               :=  WRTSUM_KIND_RRWAS1;
        v_SaleLot.T_DATE               :=  p_OperDate;
        v_SaleLot.T_TIME               :=  UnknownTime;
        v_SaleLot.T_AMOUNT             :=  v_Amount_PVO_BPP;
        v_SaleLot.T_AMOUNTBD           :=  0;
        v_SaleLot.T_SUM                :=  0;
        v_SaleLot.T_CURRENCY           :=  0;
        v_SaleLot.T_COST               :=  0;
        v_SaleLot.T_BALANCECOST        :=  0;
        v_SaleLot.T_BALANCECOSTBD      :=  0;
        v_SaleLot.T_NKDAMOUNT          :=  0;
        v_SaleLot.T_INTERESTINCOME     :=  0;
        v_SaleLot.T_NOTCARRYINTEREST   :=  0;
        v_SaleLot.T_INTERESTDATE       :=  UnknownDate;
        v_SaleLot.T_BEGDATE            :=  UnknownDate;
        v_SaleLot.T_BEGDISCOUNT        :=  0;
        v_SaleLot.T_OLDBEGDATE         :=  UnknownDate;
        v_SaleLot.T_OLDBEGDISCOUNT     :=  0;
        v_SaleLot.T_DISCOUNTINCOME     :=  0;
        v_SaleLot.T_NOTCARRYDISCOUNT   :=  0;
        v_SaleLot.T_DISCOUNTDATE       :=  UnknownDate;
        v_SaleLot.T_OUTLAY             :=  0;
        v_SaleLot.T_RESERVAMOUNT       :=  0;
        v_SaleLot.T_INCOMERESERV       :=  0;
        v_SaleLot.T_RESERVDATE         :=  UnknownDate;
        v_SaleLot.T_OVERAMOUNT         :=  0;
        v_SaleLot.T_OVERAMOUNTBD       :=  0;
        v_SaleLot.T_OVERDATE           :=  UnknownDate;
        v_SaleLot.T_COUPON             :=  chr(1);
        v_SaleLot.T_PARTLY             :=  chr(1);
        v_SaleLot.T_PARENT             :=  0;
        v_SaleLot.T_SOURCE             :=  v_Lot2.t_SumID;
        v_SaleLot.T_INSTANCE           :=  0;
        v_SaleLot.T_TRUST              :=  chr(0);
        v_SaleLot.T_ISFREE             :=  chr(0);
        v_SaleLot.T_DEPARTMENT         :=  v_Lot1.T_DEPARTMENT;
        v_SaleLot.T_DEALID             :=  v_Lot1.T_DEALID;
        v_SaleLot.T_DEALDATE           :=  v_Lot1.T_DEALDATE;
        v_SaleLot.T_DEALCODE           :=  v_Lot1.T_DEALCODE;
        v_SaleLot.T_STATE              :=  PM_WRTSUM_FORM;
        v_SaleLot.T_ENTERDATE          :=  p_OperDate;
        v_SaleLot.T_STATEDATE          :=  p_OperDate;
        v_SaleLot.T_CHANGEDATE         :=  p_OperDate;
        v_SaleLot.T_ACTION             :=  PM_WRT_UPDTMODE_DELIVERY;
        v_SaleLot.T_ID_OPERATION       :=  p_ID_Operation;
        v_SaleLot.T_ID_STEP            :=  p_ID_Step;
        v_SaleLot.T_BEGBONUSDATE       :=  UnknownDate;
        v_SaleLot.T_BEGBONUS           :=  0;
        v_SaleLot.T_BONUS              :=  0;
        v_SaleLot.T_BONUSDATE          :=  UnknownDate;
        v_SaleLot.T_ACTIVATEDATE       :=  p_OperDate;
        v_SaleLot.T_ACTIVATETIME       :=  UnknownTime;
        v_SaleLot.T_BLOCKAMOUNT        :=  0;
        v_SaleLot.T_ACCFI              := WRTDetermineAccFI(v_SaleLot.T_FIID);

        RSI_InsDfltIntoWRTSUM(v_SaleLot);
        INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.t_SumID;


     END IF;


     IF (v_Amount_PVO + v_Amount_PVO_BPP) > 0 THEN
       SELECT NVL(MAX(LOT.T_PARTNUM), 0) INTO v_MaxPartNum
         FROM DPMWRTSUM_DBT LOT
        WHERE LOT.T_DOCKIND = v_Lot1.T_DOCKIND
          AND LOT.T_DOCID = v_Lot1.T_DOCID
          AND LOT.T_BUY_SALE = PM_WRITEOFF_SUM_BUY;

       FOR i IN arrSumID.FIRST .. arrSumID.LAST
       LOOP

         v_MaxPartNum := v_MaxPartNum + 1;

         --Создать лот зачисления
         v_BuyLot.T_SUMID              :=  0;
         v_BuyLot.T_DOCKIND            :=  v_Lot1.T_DOCKIND;
         v_BuyLot.T_DOCID              :=  v_Lot1.T_DOCID;
         v_BuyLot.T_PARTNUM            :=  v_MaxPartNum;
         v_BuyLot.T_PARTY              :=  v_Lot1.T_PARTY;
         v_BuyLot.T_CONTRACT           :=  0;
         v_BuyLot.T_PORTFOLIO          :=  p_Portfolio;
         v_BuyLot.T_GROUPID            :=  p_GroupID;
         v_BuyLot.T_FIID               :=  v_Lot1.T_FIID;
         v_BuyLot.T_BUY_SALE           :=  PM_WRITEOFF_SUM_BUY;
         v_BuyLot.T_KIND               :=  WRTSUM_KIND_MB;
         v_BuyLot.T_DATE               :=  p_OperDate;
         v_BuyLot.T_TIME               :=  UnknownTime;
         v_BuyLot.T_AMOUNT             :=  arrAmount(i);
         v_BuyLot.T_AMOUNTBD           :=  0;
         v_BuyLot.T_SUM                :=  ROUND(p_Sum * v_BuyLot.T_AMOUNT / p_Amount, 2);
         v_BuyLot.T_CURRENCY           :=  p_Currency;
         v_BuyLot.T_COST               :=  ROUND(p_Cost * v_BuyLot.T_AMOUNT / p_Amount, 2);
         v_BuyLot.T_NKDAMOUNT          :=  ROUND(RSI_RSB_FIInstr.FI_CalcNKD(v_BuyLot.T_FIID, p_OperDate, v_BuyLot.T_AMOUNT, 0), 2);
         v_BuyLot.T_BALANCECOST        :=  v_BuyLot.T_COST + v_BuyLot.T_NKDAMOUNT;
         v_BuyLot.T_BALANCECOSTBD      :=  0;
         v_BuyLot.T_BEGINTERESTDATE    :=  p_OperDate;

         v_BuyLot.T_BEGDISCOUNT        :=  p_BegDiscount;
         if( v_BuyLot.T_BEGDISCOUNT > 0 ) then
            v_BuyLot.T_BEGDISCOUNTDATE    :=  p_OperDate;
         end if;
         v_BuyLot.T_INTERESTINCOME     :=  0;
         v_BuyLot.T_NOTCARRYINTEREST   :=  0;
         v_BuyLot.T_INTERESTDATE       :=  UnknownDate;
         v_BuyLot.T_BEGDATE            :=  p_OperDate;
         v_BuyLot.T_OLDBEGDATE         :=  UnknownDate;
         v_BuyLot.T_OLDBEGDISCOUNT     :=  0;
         v_BuyLot.T_DISCOUNTINCOME     :=  0;
         v_BuyLot.T_NOTCARRYDISCOUNT   :=  0;
         v_BuyLot.T_DISCOUNTDATE       :=  UnknownDate;
         v_BuyLot.T_OUTLAY             :=  0;
         v_BuyLot.T_RESERVAMOUNT       :=  0;
         v_BuyLot.T_INCOMERESERV       :=  0;
         v_BuyLot.T_RESERVDATE         :=  UnknownDate;
         v_BuyLot.T_OVERAMOUNT         :=  0;
         v_BuyLot.T_OVERAMOUNTBD       :=  0;
         v_BuyLot.T_OVERDATE           :=  UnknownDate;
         v_BuyLot.T_COUPON             :=  chr(1);
         v_BuyLot.T_PARTLY             :=  chr(1);
         v_BuyLot.T_PARENT             :=  v_SaleID;
         v_BuyLot.T_SOURCE             :=  arrSumID(i);
         v_BuyLot.T_INSTANCE           :=  0;
         v_BuyLot.T_TRUST              :=  chr(0);
         v_BuyLot.T_ISFREE             :=  chr(88);
         v_BuyLot.T_DEPARTMENT         :=  v_Lot1.T_DEPARTMENT;
         v_BuyLot.T_DEALID             :=  v_Lot1.T_DEALID;
         v_BuyLot.T_DEALDATE           :=  v_Lot1.T_DEALDATE;
         v_BuyLot.T_DEALCODE           :=  v_Lot1.T_DEALCODE;
         v_BuyLot.T_STATE              :=  PM_WRTSUM_FORM;
         v_BuyLot.T_ENTERDATE          :=  p_OperDate;
         v_BuyLot.T_STATEDATE          :=  p_OperDate;
         v_BuyLot.T_CHANGEDATE         :=  p_OperDate;
         v_BuyLot.T_ACTION             :=  PM_WRT_UPDTMODE_INPORTFOLIO;
         v_BuyLot.T_ID_OPERATION       :=  p_ID_Operation;
         v_BuyLot.T_ID_STEP            :=  p_ID_Step;
         v_BuyLot.T_ACTIVATEDATE       :=  p_OperDate;
         v_BuyLot.T_ACTIVATETIME       :=  UnknownTime;
         v_BuyLot.T_BLOCKAMOUNT        :=  0;
         v_BuyLot.T_ACCFI              := WRTDetermineAccFI(v_BuyLot.T_FIID);
         v_BuyLot.T_ACCBALANCECOST     := case when v_BuyLot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_BuyLot.T_BALANCECOST, v_FaceValueFI, v_BuyLot.T_ACCFI, v_BuyLot.T_DATE, 1 ),2),0) end;

         if( (v_BuyLot.t_Party = UnknownParty) AND
             v_BuyLot.T_BEGBONUS > 0
           ) then
            v_BuyLot.T_BEGBONUSDATE := p_OperDate;
            v_BuyLot.T_BEGBONUS     := p_BegBonus;
         end if;

         v_BuyLot.T_BONUS              := 0;
         v_BuyLot.T_BONUSDATE          := UnknownDate;

         RSI_InsDfltIntoWRTSUM(v_BuyLot);
         INSERT INTO DPMWRTSUM_DBT VALUES v_BuyLot RETURNING t_SUMID INTO v_BuyLot.t_SumID;

         v_SumID := v_BuyLot.t_SumID;

         SELECT t_State, t_DocID INTO v_LotState, v_DocID
           FROM DPMWRTSUM_DBT
          WHERE t_SumID = arrSumID(i);

         IF v_LotState = PM_WRTSUM_CANCEL THEN

           RSI_WRTLinkLotRepoPart2(v_SaleLot, 0, p_ID_Operation, p_ID_Step, PMWRTLINK_KIND_PORTFOLIO, PM_WRT_UPDTMODE_REJECTEXEC, FALSE, FALSE, FALSE, FALSE, v_SumID);

           INSERT INTO DPMWRTSUM_DBT
                  ( T_SUMID, T_DOCKIND, T_DOCID, T_PARTNUM, T_FIID, T_PORTFOLIO, T_GROUPID, T_BUY_SALE, T_KIND, T_DATE, T_TIME, T_AMOUNT, T_SUM, T_CURRENCY,
                    T_COST, T_BALANCECOST, T_NKDAMOUNT, T_INTERESTINCOME, T_NOTCARRYINTEREST, T_INTERESTDATE, T_BEGDISCOUNT, T_DISCOUNTINCOME, T_NOTCARRYDISCOUNT,
                    T_DISCOUNTDATE, T_OUTLAY, T_OVERAMOUNT, T_OVERDATE, T_DEPARTMENT, T_DEALID, T_DEALDATE, T_DEALCODE, T_STATE, T_ENTERDATE, T_STATEDATE,
                    T_CHANGEDATE, T_ACTION, T_ID_OPERATION, T_ID_STEP, T_PARENT, T_SOURCE, T_COUPON, T_PARTLY, t_BegDate,
                    t_BegBonusDate, t_BegBonus, t_Bonus, t_OldBonus, t_BonusDate, T_OLDBEGDATE, T_OLDBEGDISCOUNT, T_BEGINTERESTDATE, T_BEGDISCOUNTDATE, T_OLDBEGBONUS, T_RECALCDATE )
                  (SELECT 0, 29, v_DocID, (SELECT (NVL(MAX(LOT.T_PARTNUM), 0) + 1)
                                             FROM DPMWRTSUM_DBT LOT
                                            WHERE LOT.T_DOCKIND = 29
                                              AND LOT.T_DOCID   = v_DocID) + ROWNUM,
                                 Lot.t_FIID, Lot.T_PORTFOLIO, Lot.T_GROUPID, PM_WRITEOFF_SUM_BUY, WRTSUM_KIND_RRWAB2,
                                 Lot.T_DATE, Lot.T_TIME, Lnk.T_AMOUNT, Lnk.T_SUMBUY, Lot.T_CURRENCY, Lnk.T_COSTBUY, Lnk.T_BALANCECOSTBUY, Lnk.T_NKDBUYAMOUNT,
                                 Lnk.T_INTERESTINCOMEBUY, Lnk.T_NOTCARRYINTERESTBUY, Lot.T_INTERESTDATE, Lnk.T_BEGDISCOUNTCHANGE, Lnk.T_DISCOUNTINCOMEBUY,
                                 Lnk.T_NOTCARRYDISCOUNTBUY, Lot.T_DISCOUNTDATE, Lnk.T_OUTLAYBUY, Lnk.T_OVERCHANGE, Lot.T_OVERDATE, Lot.T_DEPARTMENT,
                                 Lot.T_DEALID, Lot.T_DEALDATE, Lot.T_DEALCODE, PM_WRTSUM_SALE_BPP, v_SaleLot.T_DATE, v_SaleLot.T_DATE, v_SaleLot.T_DATE,
                                 PM_WRT_UPDTMODE_DELIVERYBPP, v_SaleLot.T_ID_OPERATION, v_SaleLot.T_ID_STEP, v_SaleLot.t_SumID, Lot.t_SumID, chr(1), chr(1),Lot.t_BegDate,
                                 Lot.t_BegBonusDate, Lnk.t_BegBonusChange, Lnk.t_BonusBuy, Lnk.t_OldBonusBuy, Lot.t_BonusDate, Lot.t_OldBegDate, Lnk.T_OLDBEGDISCOUNTCHANGE, Lot.T_BEGINTERESTDATE, Lot.T_BEGDISCOUNTDATE, Lnk.T_OLDBEGBONUSCHANGE, Lot.T_RECALCDATE
                            FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT Lot
                           WHERE Lnk.t_SaleID = v_SaleLot.t_SumID
                             AND Lnk.t_BuyID  = v_SumID
                             AND Lot.t_SumID  = Lnk.t_BuyID);
         END IF;
       END LOOP;
     END IF;

   END;--RSI_WRTRejectDeal

   --Выполняет начисление доходов на лоты во временную таблицу в операции начисления ПДД, погашения, либо при продаже
   PROCEDURE RSI_WRTChargeIncomToLotsTMP( p_IsWrtSale          IN BOOLEAN, -- Признак вызова при продаже\погашении или ПДД (true-списание\погашение, false-начисление ПДД)
                                          p_OperDate           IN DATE,   -- Дата
                                          p_EndDate            IN DATE,
                                          p_FIID               IN NUMBER, -- Выпуск
                                          p_Department         IN NUMBER, -- Филиал
                                          p_P1                 IN NUMBER DEFAULT UnknownValue, -- Портфели (по приоритетам, до 5-х штук, незаданные
                                          p_P2                 IN NUMBER DEFAULT UnknownValue,
                                          p_P3                 IN NUMBER DEFAULT UnknownValue,
                                          p_P4                 IN NUMBER DEFAULT UnknownValue,
                                          p_P5                 IN NUMBER DEFAULT UnknownValue,
                                          p_Party              IN NUMBER,
                                          p_Contract           IN NUMBER,
                                          p_CalcInterest       IN BOOLEAN, --начислять ПД
                                          p_CalcDiscount       IN BOOLEAN, --начислять ДД
                                          p_CalcBonus          IN BOOLEAN, --начислять премию
                                          p_CalcDefDiff        IN BOOLEAN, --начисление отсроченной разницы
                                          p_CalcCorrIntToEIR   IN BOOLEAN, --начисление корректировки процентов до ЭПС
                                          p_AmortizationMethod IN NUMBER, --метод списания
                                          p_IsTrust            IN BOOLEAN DEFAULT FALSE,
                                          p_LnkKind            IN NUMBER DEFAULT 0, -- Вид связи списания
                                          p_Coupon             IN VARCHAR2 DEFAULT NULL
                                        )
   IS
      v_PORTFOLIO       NUMBER := UnknownValue;
      v_STATE           NUMBER := UnknownValue;
      v_AMOUNT          NUMBER := 0;
      v_NKDAMOUNT       NUMBER := 0;
      v_INTERESTINCOME  NUMBER := 0;
      v_BEGINTERESTDATE DATE   := UnknownDate;
      v_INTERESTDATE    DATE;

      v_InterestAddRest NUMBER := 0;
      v_InterestAdd     NUMBER := 0;
      v_LotInterestAdd  NUMBER := 0;

      v_BonusAdd        NUMBER := 0;
      v_BonusAddRest    NUMBER := 0;
      v_LotBonusAdd     NUMBER := 0;
      v_BegBonusDate    DATE;

      v_BONUSDATE       DATE;
      v_RECALCDATE      DATE;
      v_BONUS           NUMBER := 0;
      v_BEGBONUS        NUMBER := 0;
      v_OLDBEGBONUS     NUMBER := 0;

      v_DEFDIFFDATE     DATE;
      v_BEGDEFDIFFDATE  DATE;
      v_ACCOUNTEDDEFDIFF NUMBER := 0;
      v_BEGDEFDIFF      NUMBER := 0;
      v_DefDiffAddRest  NUMBER := 0;
      v_DefDiffAdd      NUMBER := 0;
      v_LotDefDiffAdd   NUMBER := 0;

      v_CorrIntToEIR    NUMBER :=0;

      v_BEGDISCOUNTDATE DATE;
      v_DISCOUNTDATE    DATE;
      v_COST            NUMBER := 0;
      v_DISCOUNTINCOME  NUMBER := 0;
      v_BEGDISCOUNT     NUMBER := 0;
      v_OLDBEGDISCOUNT  NUMBER := 0;
      v_DiscountAdd     NUMBER := 0;
      v_DiscountAddRest NUMBER := 0;
      v_LotDiscountAdd  NUMBER := 0;

      v_FaceFI          NUMBER := 0;

      v_IsWrtSale       NUMBER := 0;    

      TYPE LOTSCurTyp IS REF CURSOR;
      LOTS_cur LOTSCurTyp;

      TYPE GROUPLOTSCurTyp IS REF CURSOR;
      GROUPLOTS_cur GROUPLOTSCurTyp;

      WrtSumTmp DPMWRTSUM_TMP%rowtype;

      CURSOR cLotInterest(PORTFOLIO IN NUMBER, STATE IN NUMBER, BEGINTERESTDATE IN DATE, INTERESTDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = p_Party
            AND T_DEPARTMENT  = p_Department
            AND T_CONTRACT    = p_Contract
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
            AND T_AMOUNT      > 0
            AND T_PORTFOLIO       = PORTFOLIO
            AND T_STATE           = STATE
            AND T_BEGINTERESTDATE = (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN T_BEGINTERESTDATE ELSE BEGINTERESTDATE END)
            AND 1 = (CASE WHEN p_AmortizationMethod <> PM_WRITEOFF_AVERAGE OR (p_AmortizationMethod = PM_WRITEOFF_AVERAGE AND T_BEGINTERESTDATE <> p_EndDate) THEN 1 ELSE 0 END)
            AND T_INTERESTDATE    = INTERESTDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotBonus(PORTFOLIO IN NUMBER, STATE IN NUMBER, BEGBONUSDATE IN DATE, BONUSDATE IN DATE, RECALCDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = p_Party
            AND T_DEPARTMENT  = p_Department
            AND T_CONTRACT    = p_Contract
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
            AND T_AMOUNT      > 0
            AND T_PORTFOLIO    = PORTFOLIO
            AND T_STATE        = STATE
            AND T_BEGBONUSDATE = BEGBONUSDATE
            AND T_BONUSDATE    = BONUSDATE
            AND T_RECALCDATE   = RECALCDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotDiscount(PORTFOLIO IN NUMBER, STATE IN NUMBER, BEGDISCOUNTDATE IN DATE, DISCOUNTDATE IN DATE, RECALCDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = p_Party
            AND T_DEPARTMENT  = p_Department
            AND T_CONTRACT    = p_Contract
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
            AND T_AMOUNT      > 0
            AND T_PORTFOLIO    = PORTFOLIO
            AND T_STATE           = STATE
            AND T_BEGDISCOUNTDATE = BEGDISCOUNTDATE
            AND T_DISCOUNTDATE    = DISCOUNTDATE
            AND T_RECALCDATE   = RECALCDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotCorrIntToEIR IS
         SELECT LOT.T_SUMID,
                LOT.T_CORRINTTOEIR,
                TMP.T_DEALID,
                TMP.T_CORRINTTOEIRDATE,
                TMP.T_INTERESTADD,
                TMP.T_BONUSADD,
                TMP.T_DISCOUNTADD,
                TMP.T_WRTOUTLAYADD,
                LOT.T_FAIRVALUE,
                FIN.T_FACEVALUE,
                FIN.T_FACEVALUEFI,
                LOT.T_DATE,
                TMP.T_INTERESTINCOME,
                TMP.T_BONUS,
                TMP.T_DISCOUNTINCOME,
                TMP.T_WRTOUTLAY,
                TMP.T_COST,
                TMP.T_AMOUNT,
                LOT.T_NKDAMOUNT,
                LOT.T_COSTPFI
           FROM DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP, DFININSTR_DBT FIN
          WHERE LOT.T_SUMID = TMP.T_SUMID
            AND LOT.T_PARTY       = p_Party  
            AND LOT.T_AMORTCALCKIND IN (RSB_SECUR.AMORTCALCKIND_EPS, RSB_SECUR.AMORTCALCKIND_RPS) 
            AND (1 = CASE WHEN v_IsWrtSale = 0 OR (v_IsWrtSale = 1 AND EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNKTMP WHERE LNKTMP.T_BUYID = LOT.T_SUMID)) THEN 1 ELSE 0 END)
            AND FIN.T_FIID = LOT.T_FIID
            AND RSI_RSB_FIINSTR.FI_AvrKindsGetRoot(fin.t_fi_kind, fin.t_avoirkind) = RSI_RSB_Fiinstr.AVOIRKIND_BOND
          ORDER BY LOT.T_AMOUNT ASC, LOT.T_DATE DESC;

      CURSOR cLotDefDiff(PORTFOLIO IN NUMBER, STATE IN NUMBER, BEGDEFDIFFDATE IN DATE, DEFDIFFDATE IN DATE, RECALCDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = p_Party
            AND T_DEPARTMENT  = p_Department
            AND T_CONTRACT    = p_Contract
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
            AND T_AMOUNT      > 0
            AND T_PORTFOLIO    = PORTFOLIO
            AND T_STATE        = STATE
            AND T_BEGDEFDIFFDATE = BEGDEFDIFFDATE
            AND T_DEFDIFFDATE  = DEFDIFFDATE
            AND T_RECALCDATE   = RECALCDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;
     
    FUNCTION CheckIncomeVolume( v_Method IN NUMBER
                          ) RETURN NUMBER DETERMINISTIC
    IS
      v_Old_INTERESTINCOME   NUMBER := 0;
      v_New_INTERESTINCOME  NUMBER := 0;
      v_BEGINTERESTDATE_tmp  DATE   := UnknownDate;
    BEGIN
         IF v_Method = PM_WRITEOFF_AVERAGE and v_IsWrtSale <> 1 THEN
           FOR LOT IN  (SELECT T_INTERESTDATE  as S_INTERESTDATE,
                                      NVL(SUM(T_AMOUNT), 0) S_AMOUNT,
                                      NVL(SUM(T_NKDAMOUNT), 0) S_NKDAMOUNT,
                                      NVL(SUM(T_INTERESTINCOME), 0) S_INTERESTINCOME
                                 FROM DPMWRTSUM_DBT
                                WHERE T_PARTY       = p_Party
                                  AND T_DEPARTMENT  = p_Department
                                  AND T_CONTRACT    = p_Contract
                                  AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
                                  AND T_PORTFOLIO   = v_PORTFOLIO
                                  AND T_ENTERDATE  <= p_OperDate
                                  AND T_DATE       <= p_EndDate 
                                  AND T_BEGINTERESTDATE <> p_EndDate
                                  AND T_FIID        = p_FIID
                                  AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                  AND T_AMOUNT      > 0
                                GROUP BY T_INTERESTDATE)

           LOOP

              v_Old_INTERESTINCOME := v_Old_INTERESTINCOME + LOT.S_INTERESTINCOME;

              v_New_INTERESTINCOME := v_New_INTERESTINCOME + LOT.S_INTERESTINCOME + WRTCalcInterestIncome (p_EndDate, v_BEGINTERESTDATE_tmp, p_LnkKind, p_FIID, LOT.S_AMOUNT,  LOT.S_NKDAMOUNT,  LOT.S_INTERESTDATE,  LOT.S_INTERESTINCOME, v_Method, p_Coupon, p_IsTrust, 1);

           END LOOP;

           IF v_New_INTERESTINCOME < v_Old_INTERESTINCOME THEN
             RETURN 1;
           END IF;
         END IF;
         RETURN 0;

      END;--CheckIncomeVolume
   
      PROCEDURE ChargeInterestIncome -- начисление ПД по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
         v_Method NUMBER;
      BEGIN

         v_Method := GetAmortizationMethod( p_Party, p_Contract );

         v_InterestAdd :=  WRTCalcInterestIncome (p_EndDate, v_BEGINTERESTDATE, p_LnkKind, p_FIID, v_AMOUNT, v_NKDAMOUNT, v_INTERESTDATE, v_INTERESTINCOME, v_Method, p_Coupon, p_IsTrust, 1);
         v_InterestAddRest := v_InterestAdd;
         v_AMOUNT0 := v_AMOUNT;
        
         IF CheckIncomeVolume(v_Method) = 0 THEN

         FOR LOT IN cLotInterest(v_PORTFOLIO, v_STATE, v_BEGINTERESTDATE, v_INTERESTDATE) LOOP

            IF v_Amount > LOT.T_AMOUNT THEN
               v_LotInterestAdd :=  WRTCalcInterestIncome (p_EndDate, v_BEGINTERESTDATE, p_LnkKind, p_FIID, LOT.T_AMOUNT, LOT.T_NKDAMOUNT, v_INTERESTDATE, LOT.T_INTERESTINCOME, v_Method, p_Coupon, p_IsTrust , 1);
            ELSE
               v_LotInterestAdd := v_InterestAddRest;
            END IF;

            IF v_LotInterestAdd > v_InterestAddRest  THEN 
               v_LotInterestAdd := v_InterestAddRest; 
            END IF;

            SELECT count(1) into v_Count
              FROM DPMWRTSUM_TMP TMP
             WHERE TMP.T_SUMID = LOT.T_SUMID;

            IF( v_Count > 0 ) THEN

               BEGIN
                  UPDATE DPMWRTSUM_TMP TMP SET
                    TMP.T_INTERESTADD       = v_LotInterestAdd,
                    TMP.T_INTERESTINCOME    = TMP.T_INTERESTINCOME + v_LotInterestAdd,
                    TMP.T_INTERESTDATE      = p_EndDate
                  where TMP.T_SUMID = LOT.T_SUMID;
               END;

            ELSE

               INSERT INTO DPMWRTSUM_TMP
                          (
                            T_SUMID,
                            T_KIND,
                            T_AMOUNT,
                            T_COST,
                            T_BALANCECOST,
                            T_INTERESTADD,
                            T_BONUSADD,
                            T_DISCOUNTADD,
                            T_INTERESTINCOME,
                            T_NOTCARRYINTEREST,
                            T_INTERESTDATE,
                            T_BEGDISCOUNTDATE,
                            T_BEGBONUSDATE,
                            T_DISCOUNTINCOME,
                            T_NOTCARRYDISCOUNT,
                            T_DISCOUNTDATE,
                            T_BONUS,
                            T_BONUSDATE,
                            T_NOTWRTBONUS,
                            T_DEFDIFFADD,
                            T_ACCOUNTEDDEFDIFF,
                            T_DEFDIFFDATE,
                            T_WRTOUTLAYADD,
                            T_WRTOUTLAY,
                            T_WRTOUTLAYDATE,
                            T_VATOUTLAYADD,
                            T_WRTVATOUTLAY,
                            T_CORRVALUE,
                            T_CORRDATE,
                            T_AMORTCOST,
                            T_CORRINTTOEIR,
                            T_CORRINTTOEIRDATE,
                            T_WRTCORRINTTOEIR,
                            T_ESTRESERVEADD,
                            T_CORRESTRESERVEADD,
                            T_RESERVAMOUNTADD,
                            T_INCOMERESERVADD,
                            T_PORTFOLIO,
                            T_STATE,
                            T_OVERAMOUNT,
                            T_OVERAMOUNTADD,
                            T_DEALID,
                            T_BEGDEFDIFFDATE,
                            T_HEDGCORR,
                            T_AMORTHEDGCORR
                          )
                   VALUES (
                            LOT.T_SUMID,
                            0,
                            LOT.T_AMOUNT,
                            LOT.T_COST,
                            LOT.T_BALANCECOST + v_LotInterestAdd,
                            v_LotInterestAdd,
                            0,
                            0,
                            v_LotInterestAdd + LOT.T_INTERESTINCOME,
                            LOT.T_NOTCARRYINTEREST,
                            p_EndDate,
                            LOT.T_BEGDISCOUNTDATE,
                            LOT.T_BEGBONUSDATE,
                            LOT.T_DISCOUNTINCOME,
                            LOT.T_NOTCARRYDISCOUNT,
                            LOT.T_DISCOUNTDATE,
                            LOT.T_BONUS,
                            LOT.T_BONUSDATE,
                            LOT.T_NOTWRTBONUS,
                            0,
                            LOT.T_ACCOUNTEDDEFDIFF,
                            LOT.T_DEFDIFFDATE,
                            0,
                            LOT.T_WRTOUTLAY,
                            LOT.T_WRTOUTLAYDATE,
                            0,
                            LOT.T_WRTVATOUTLAY,
                            LOT.T_CORRVALUE,
                            LOT.T_CORRDATE,
                            LOT.T_AMORTCOST,
                            LOT.T_CORRINTTOEIR,
                            LOT.T_CORRINTTOEIRDATE,
                            0,
                            0,
                            0,
                            0,
                            0,
                            LOT.T_PORTFOLIO,
                            LOT.T_STATE,
                            LOT.T_OVERAMOUNT,
                            0,
                            LOT.T_DEALID,
                            LOT.T_BEGDEFDIFFDATE,
                            LOT.T_HEDGCORR,
                            LOT.T_AMORTHEDGCORR
                          );
            END IF;

            v_Amount := v_Amount - LOT.T_AMOUNT;
            v_InterestAddRest := v_InterestAddRest - v_LotInterestAdd;
            
            IF v_Method != PM_WRITEOFF_AVERAGE THEN
            IF v_InterestAddRest < 0 THEN 
              v_InterestAddRest := 0; 
            END IF;
            END IF;
            


         END LOOP;

         if v_Amount <> 0 or ((v_InterestAddRest <> 0 AND  v_Method != PM_WRITEOFF_AVERAGE) or (v_InterestAddRest > 0 and v_Method = PM_WRITEOFF_AVERAGE)) then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;
         END IF;

      END;

      PROCEDURE ChargeBonus -- Начисление премии по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
         v_LOTCOST NUMBER := 0;
      BEGIN

         v_BonusAdd := WRTCalcBonus(p_EndDate, v_BEGBONUSDATE, p_LnkKind, p_FIID, v_AMOUNT, v_COST,
                                    v_BONUSDATE, v_BONUS, v_BEGBONUS, v_OLDBEGBONUS,
                                    p_Party, p_Contract, v_RECALCDATE
                                   );
         v_BonusAddRest := v_BonusAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotBonus(v_PORTFOLIO, v_STATE, v_BEGBONUSDATE, v_BONUSDATE, v_RECALCDATE) LOOP

            IF LOT.T_BEGBONUS = 0 and LOT.T_OLDBEGBONUS = 0 THEN
               v_LotBonusAdd := 0;
            ELSIF v_Amount > LOT.T_AMOUNT THEN
               IF p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN
                 v_LotBonusAdd := ROUND(v_BonusAdd * LOT.T_AMOUNT / v_AMOUNT0, 2);
               ELSE
               
                 SELECT NVL(SUM(TMP1.T_COST), LOT.T_COST) INTO v_LOTCOST
                   FROM DPMWRTSUM_TMP TMP1
                  WHERE TMP1.T_SUMID = LOT.T_SUMID
                    AND TMP1.T_KIND = 0;
                 
                 v_LotBonusAdd := WRTCalcBonus(p_EndDate, v_BEGBONUSDATE, p_LnkKind, p_FIID, LOT.T_AMOUNT, v_LOTCOST, 
                                               v_BONUSDATE, LOT.T_BONUS, LOT.T_BEGBONUS, LOT.T_OLDBEGBONUS,
                                               p_Party, p_Contract, v_RECALCDATE
                                              );
               END IF;
            ELSE
               v_LotBonusAdd := v_BonusAddRest;
            END IF;

            BEGIN

               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID
                  AND TMP.T_KIND  = 0;

               IF( v_Count > 0 ) THEN

                  UPDATE DPMWRTSUM_TMP SET
                    T_BONUSADD          = v_LotBonusAdd,
                    T_BONUS             = T_BONUS + v_LotBonusAdd,
                    T_BONUSDATE         = p_EndDate,
                    T_COST              = T_COST - v_LotBonusAdd,
                    T_BALANCECOST       = T_BALANCECOST - v_LotBonusAdd,
                    T_BEGBONUSDATE      = (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE then p_EndDate else T_BEGBONUSDATE end)
                  where T_SUMID = LOT.T_SUMID
                    and T_KIND  = 0;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_HEDGCORR,
                               T_AMORTHEDGCORR
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST - v_LotBonusAdd,
                               LOT.T_BALANCECOST - v_LotBonusAdd,
                               0,
                               v_LotBonusAdd,
                               0,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE then p_EndDate else LOT.T_BEGBONUSDATE end),
                               LOT.T_DISCOUNTINCOME,
                               LOT.T_NOTCARRYDISCOUNT,
                               LOT.T_DISCOUNTDATE,
                               LOT.T_BONUS + v_LotBonusAdd,
                               p_EndDate,
                               LOT.T_NOTWRTBONUS,
                               0,
                               LOT.T_ACCOUNTEDDEFDIFF,
                               LOT.T_DEFDIFFDATE,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               LOT.T_HEDGCORR,
                               LOT.T_AMORTHEDGCORR
                             );
               END IF;

            END;

            IF LOT.T_BEGBONUS > 0 or LOT.T_OLDBEGBONUS > 0 THEN
               v_Amount       := v_Amount - LOT.T_AMOUNT;
               v_BonusAddRest := v_BonusAddRest - v_LotBonusAdd;
            END IF;

         END LOOP;

         if v_Amount <> 0 or v_BonusAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeDiscountIncome -- Начисление дисконтного дохода по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
         v_LOTCOST NUMBER := 0;
      BEGIN

         v_DiscountAdd := WRTCalcDiscountIncome (p_EndDate, v_BEGDISCOUNTDATE, p_LnkKind, p_FIID,
                                                 v_AMOUNT, v_COST, v_DISCOUNTDATE, v_DISCOUNTINCOME,
                                                 v_BEGDISCOUNT, v_OLDBEGDISCOUNT,
                                                 p_Party, p_Contract, v_RECALCDATE);
         v_DiscountAddRest := v_DiscountAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotDiscount(v_PORTFOLIO, v_STATE, v_BEGDISCOUNTDATE, v_DISCOUNTDATE, v_RECALCDATE) LOOP

            IF LOT.T_BEGDISCOUNT = 0 and LOT.T_OLDBEGDISCOUNT = 0 THEN
               v_LotDiscountAdd := 0;
            ELSIF v_Amount > LOT.T_AMOUNT THEN
               IF p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN
                 v_LotDiscountAdd := ROUND(v_DiscountAdd * LOT.T_AMOUNT / v_AMOUNT0, 2);
               ELSE
               
                 SELECT NVL(SUM(TMP1.T_COST), LOT.T_COST) INTO v_LOTCOST
                   FROM DPMWRTSUM_TMP TMP1
                  WHERE TMP1.T_SUMID = LOT.T_SUMID
                    AND TMP1.T_KIND = 0;

                 v_LotDiscountAdd := WRTCalcDiscountIncome (p_EndDate, v_BEGDISCOUNTDATE, p_LnkKind, p_FIID,
                                                            LOT.T_AMOUNT, v_LOTCOST, v_DISCOUNTDATE, LOT.T_DISCOUNTINCOME,
                                                            LOT.T_BEGDISCOUNT, LOT.T_OLDBEGDISCOUNT,
                                                            p_Party, p_Contract, v_RECALCDATE);
              END IF;
            ELSE
               v_LotDiscountAdd := v_DiscountAddRest;
            END IF;

            BEGIN
               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID
                  AND TMP.T_KIND  = 0;

               IF( v_Count > 0 ) THEN

                   UPDATE DPMWRTSUM_TMP SET
                     T_DISCOUNTADD      = v_LotDiscountAdd,
                     T_DISCOUNTINCOME   = T_DISCOUNTINCOME + v_LotDiscountAdd,
                     T_DISCOUNTDATE     = p_EndDate,
                     T_BALANCECOST      = T_BALANCECOST + v_LotDiscountAdd,
                     T_BEGDISCOUNTDATE  = (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE then p_EndDate else T_BEGDISCOUNTDATE end)
                  where T_SUMID = LOT.T_SUMID
                    and T_KIND  = 0;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST + v_LotDiscountAdd,
                               0,
                               0,
                               v_LotDiscountAdd,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE then p_EndDate else LOT.T_BEGDISCOUNTDATE end),
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME + v_LotDiscountAdd,
                               /*(case when p_IsResponsible != 1 then (LOT.T_NOTCARRYDISCOUNT + v_LotDiscountAdd) else 0 end)*/0,
                               p_EndDate,
                               LOT.T_BONUS,
                               LOT.T_BONUSDATE,
                               LOT.T_NOTWRTBONUS,
                               0,
                               LOT.T_ACCOUNTEDDEFDIFF,
                               LOT.T_DEFDIFFDATE,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            IF LOT.T_BEGDISCOUNT > 0 or LOT.T_OLDBEGDISCOUNT > 0 THEN
               v_Amount          := v_Amount - LOT.T_AMOUNT;
               v_DiscountAddRest := v_DiscountAddRest - v_LotDiscountAdd;
            END IF;

         END LOOP;

         if v_Amount <> 0 or v_DiscountAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeDefDiff -- Начисление отсроченной разницы
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
      BEGIN
         v_DefDiffAdd := WRTCalcDefDiff(p_EndDate, v_BEGDEFDIFFDATE, p_FIID, v_AMOUNT,
                                    v_DEFDIFFDATE, v_ACCOUNTEDDEFDIFF, v_BEGDEFDIFF,
                                    p_Party, p_Contract
                                   );
         v_DefDiffAddRest := v_DefDiffAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotDefDiff(v_PORTFOLIO, v_STATE, v_BEGDEFDIFFDATE, v_DEFDIFFDATE, v_RECALCDATE) LOOP

            IF LOT.T_BEGDEFDIFF = 0 THEN
               v_LotDefDiffAdd := 0;
            ELSIF v_Amount > LOT.T_AMOUNT THEN
               IF p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN
                 v_LotDefDiffAdd := ROUND(v_DefDiffAdd * LOT.T_AMOUNT / v_AMOUNT0, 2);
               ELSE
               
                 v_LotDefDiffAdd := WRTCalcDefDiff(p_EndDate, v_BEGDEFDIFFDATE, p_FIID, LOT.T_AMOUNT,
                                               v_DEFDIFFDATE, LOT.T_ACCOUNTEDDEFDIFF, LOT.T_BEGDEFDIFF,
                                               p_Party, p_Contract
                                              );
               END IF;
            ELSE
               v_LotDefDiffAdd := v_DefDiffAddRest;
            END IF;

            BEGIN

               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID
                  AND TMP.T_KIND  = 0;

               IF( v_Count > 0 ) THEN

                  UPDATE DPMWRTSUM_TMP SET
                    T_DEFDIFFADD       = v_LotDefDiffAdd,
                    T_ACCOUNTEDDEFDIFF =  T_ACCOUNTEDDEFDIFF + v_LotDefDiffAdd,
                    T_DEFDIFFDATE      = p_EndDate,
                    T_BEGDEFDIFFDATE   = (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE then p_EndDate else T_BEGDEFDIFFDATE end)

                  where T_SUMID = LOT.T_SUMID
                    and T_KIND  = 0;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST,
                               0,
                               0,
                               0,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME,
                               LOT.T_NOTCARRYDISCOUNT,
                               LOT.T_DISCOUNTDATE,
                               LOT.T_BONUS,
                               LOT.T_BONUSDATE,
                               LOT.T_NOTWRTBONUS,
                               v_LotDefDiffAdd,
                               LOT.T_ACCOUNTEDDEFDIFF+v_LotDefDiffAdd,
                               p_EndDate,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE then p_EndDate else LOT.T_BEGDEFDIFFDATE end),
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            IF LOT.T_BEGDEFDIFF != 0 THEN
               v_Amount       := v_Amount - LOT.T_AMOUNT;
               v_DefDiffAddRest := v_DefDiffAddRest - v_LotDefDiffAdd;
            END IF;

         END LOOP;

         if v_Amount <> 0 or v_DefDiffAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeCorrIntToEIR -- Начисление корректировки процентов до ЭПС
      IS
        v_EIR NUMBER := 0;
        v_prevCorrIntToEIR_FV NUMBER;
        v_AmS                 NUMBER := 0;
        v_VBS                 NUMBER := 0;
        v_TotalAmount         NUMBER := 0;
        v_TotalCorrIntToEIR   NUMBER := 0;
        v_RestCorrIntToEIR    NUMBER := 0;
        v_RestAmount          NUMBER := 0;
        v_FaceValueFI         NUMBER;

        v_CostPFI NUMBER := 0;
            
        v_NKDCourse      NUMBER;
        v_CoupSum        NUMBER;
        v_PrevCoupSum    NUMBER;
        v_PartialSum     NUMBER;
        v_PrevPartialSum NUMBER;

      BEGIN

         IF GetAmortizationMethod( p_Party, p_Contract ) = PM_WRITEOFF_AVERAGE THEN
           FOR LOT IN cLotCorrIntToEIR() LOOP

              v_FaceValueFI := LOT.t_FaceValueFI;

              v_EIR := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_AVR, LOT.T_DEALID, LOT.T_SUMID, p_EndDate);

              v_NKDCourse := RSI_RSB_FIInstr.FindNKDCource(p_FIID, p_EndDate);


              SELECT nvl((SELECT (CASE WHEN v_NKDCourse > 0 THEN (v_NKDCourse*LOT.T_AMOUNT) 
                                     ELSE ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue(fw.t_FIID, fw.t_DrawingDate, LOT.T_AMOUNT, 1, 0, 0),fw.t_IncomePoint) 
                                END)
                            FROM dfiwarnts_dbt fw
                           WHERE FW.T_ID = (SELECT t_ID
                                              FROM dfiwarnts_dbt
                                             WHERE t_FIID = p_FIID
                                               AND t_IsPartial = CHR(0)
                                               AND t_SPIsClosed = CHR(88)
                                               AND t_DrawingDate = p_EndDate
                                               AND rownum = 1)
                        ), 0) INTO v_CoupSum FROM dual;


              SELECT nvl((SELECT SUM(ROUND(RSI_RSB_FIInstr.FI_CalcIncomeValue(fw.t_FIID, fw.t_DrawingDate, LOT.T_AMOUNT, 1, 0, 0),fw.t_IncomePoint)) 
                            FROM dfiwarnts_dbt fw
                           WHERE fw.t_FIID = p_FIID
                             AND fw.t_IsPartial = CHR(0)
                             AND fw.t_SPIsClosed = CHR(0)
                             AND fw.t_DrawingDate < p_EndDate
                             AND fw.t_DrawingDate > RSI_RsbCalendar.GetDateAfterWorkDay(p_EndDate,-1)
                         ), 0) INTO v_PrevCoupSum FROM dual;


              SELECT NVL(sum(LOT.T_AMOUNT * (CASE WHEN fw.t_RelativeIncome = CHR(0) THEN fw.t_IncomeVolume
                                             ELSE ROUND(LOT.T_FACEVALUE * fw.t_IncomeRate / GREATEST(1, fw.t_IncomeScale) / 100, fw.t_IncomePoint)
                                             END)),0) t_Sum INTO v_PartialSum
                     FROM DFIWARNTS_DBT fw
                    WHERE fw.t_FIID   = p_FIID
                      AND fw.t_IsPartial = CHR(88)
                      AND fw.t_SPIsClosed = CHR(88)
                      AND fw.t_DrawingDate = p_EndDate;

              SELECT NVL(sum(LOT.T_AMOUNT * (CASE WHEN fw.t_RelativeIncome = CHR(0) THEN fw.t_IncomeVolume
                                             ELSE ROUND(LOT.t_FaceValue * fw.t_IncomeRate / GREATEST(1, fw.t_IncomeScale) / 100, fw.t_IncomePoint)
                                             END)),0) t_Sum INTO v_PrevPartialSum
                     FROM DFIWARNTS_DBT fw
                    WHERE fw.t_FIID   = p_FIID
                      AND fw.t_IsPartial = CHR(88)
                      AND fw.t_SPIsClosed = CHR(0)
                      AND fw.t_DrawingDate < p_EndDate
                      AND fw.t_DrawingDate > RSI_RsbCalendar.GetDateAfterWorkDay(p_EndDate,-1);
            
              IF LOT.T_DATE = p_EndDate THEN
                v_AmS := v_AmS + RSB_SECUR.CalcAS_EPS0(RSB_SECUR.CALCKIND_AVR,LOT.T_DEALID, LOT.T_SUMID, p_EndDate, LOT.T_FAIRVALUE);
              ELSE
                v_AmS := v_AmS + v_PrevCoupSum + v_PrevPartialSum + RSB_SECUR.CalcAS_EPS(RSB_SECUR.CALCKIND_AVR, LOT.T_DEALID, LOT.T_SUMID, p_EndDate, v_EIR) - (v_CoupSum + v_PartialSum);
              END IF;  

              v_VBS := v_VBS + LOT.T_COST + LOT.T_NKDAMOUNT + LOT.T_INTERESTINCOME + LOT.T_DISCOUNTINCOME + LOT.T_COSTPFI;

              IF LOT.T_DATE = p_EndDate THEN
                 BEGIN
                   SELECT RSI_GetLastAccountedFrVal(t_DealID,t_BOfficeKind,LOT.T_DATE) INTO v_CostPFI
                     FROM DDL_TICK_DBT
                    WHERE T_DEALID = LOT.T_DEALID
                      AND T_ISPFI = 'X';
                       
                   EXCEPTION
                     WHEN NO_DATA_FOUND THEN v_CostPFI := 0;
                 END;       

                 v_CostPFI := RSI_RSB_FIInstr.ConvSum(v_CostPFI, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, LOT.T_DATE, 1);
                
                 v_VBS := v_VBS - v_CostPFI;            
              END IF;

              v_TotalAmount := v_TotalAmount + LOT.T_AMOUNT;

              UPDATE DPMWRTSUM_TMP TMP SET
                 TMP.T_EFFECTINTERESTRATE = v_EIR
               where TMP.T_SUMID = LOT.T_SUMID
                 and TMP.T_KIND  = 0;

           END LOOP;

           IF v_AmS IS NOT NULL AND v_VBS IS NOT NULL THEN
             v_TotalCorrIntToEIR := RSI_RSB_FIInstr.ConvSum(v_AmS - v_VBS, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_EndDate, 0);
             v_RestCorrIntToEIR  := v_TotalCorrIntToEIR;
             v_RestAmount        := v_TotalAmount;

             FOR LOT IN cLotCorrIntToEIR() LOOP

               IF v_RestAmount = LOT.T_AMOUNT THEN
                 v_CorrIntToEIR := ROUND(v_RestCorrIntToEIR, 2);
               ELSE
                 v_CorrIntToEIR := ROUND(v_TotalCorrIntToEIR * LOT.T_AMOUNT / v_TotalAmount, 2);
               END IF;

               v_prevCorrIntToEIR_FV := 0;
               IF LOT.t_CorrIntToEIRDate <> UnknownDate THEN
                 v_prevCorrIntToEIR_FV := RSI_RSB_FIInstr.ConvSum(LOT.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, LOT.t_FaceValueFI, LOT.t_CorrIntToEIRDate, 0);
               END IF;

               UPDATE DPMWRTSUM_TMP TMP SET
                 TMP.T_BALANCECOST        = ROUND((TMP.T_BALANCECOST - v_prevCorrIntToEIR_FV + RSI_RSB_FIInstr.ConvSum(v_CorrIntToEIR, RSI_RSB_FIInstr.NATCUR, LOT.t_FaceValueFI, p_EndDate, 0)), 2),
                 TMP.T_WRTCORRINTTOEIR    = -(v_CorrIntToEIR - TMP.T_CORRINTTOEIR), --С минусом, чтобы увеличить
                 TMP.T_CORRINTTOEIR       = v_CorrIntToEIR,
                 TMP.T_CORRINTTOEIRDATE   = p_EndDate
               where TMP.T_SUMID = LOT.T_SUMID
                 and TMP.T_KIND  = 0;

               v_RestCorrIntToEIR := v_RestCorrIntToEIR - v_CorrIntToEIR;
               v_RestAmount       := v_RestAmount - LOT.T_AMOUNT;
             END LOOP;
           END IF;

         ELSE

           FOR LOT IN cLotCorrIntToEIR() LOOP

              v_EIR := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_AVR, LOT.T_DEALID, LOT.T_SUMID, p_EndDate);

              v_CorrIntToEIR := RSB_SECUR.CalcCorrectPersentEPS(RSB_SECUR.CALCKIND_AVR,
                                                                LOT.T_DEALID,
                                                                LOT.T_SUMID,
                                                                p_EndDate,
                                                                UnknownDate,
                                                                LOT.T_INTERESTINCOME,
                                                                LOT.T_BONUS,
                                                                LOT.T_DISCOUNTINCOME,
                                                                LOT.T_WRTOUTLAY,
                                                                LOT.T_FAIRVALUE,
                                                                v_EIR);
              IF v_CorrIntToEIR IS NOT NULL THEN
                v_CorrIntToEIR := RSI_RSB_FIInstr.ConvSum(v_CorrIntToEIR, LOT.t_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_EndDate, 1);
                v_CorrIntToEIR := ROUND(v_CorrIntToEIR, 2);

                BEGIN

                   v_prevCorrIntToEIR_FV := 0;
                   IF LOT.t_CorrIntToEIRDate <> UnknownDate THEN
                     v_prevCorrIntToEIR_FV := RSI_RSB_FIInstr.ConvSum(LOT.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, LOT.t_FaceValueFI, LOT.t_CorrIntToEIRDate, 0);
                   END IF;

                   UPDATE DPMWRTSUM_TMP TMP SET
                     TMP.T_BALANCECOST        = ROUND((TMP.T_BALANCECOST - v_prevCorrIntToEIR_FV + RSI_RSB_FIInstr.ConvSum(v_CorrIntToEIR, RSI_RSB_FIInstr.NATCUR, LOT.t_FaceValueFI, p_EndDate, 0)), 2),
                     TMP.T_WRTCORRINTTOEIR    = -(v_CorrIntToEIR - TMP.T_CORRINTTOEIR), --С минусом, чтобы увеличить
                     TMP.T_CORRINTTOEIR       = v_CorrIntToEIR,
                     TMP.T_CORRINTTOEIRDATE   = p_EndDate,
                     TMP.T_EFFECTINTERESTRATE = v_EIR
                   where TMP.T_SUMID = LOT.T_SUMID
                     and TMP.T_KIND  = 0;

                END;
              END IF;

           END LOOP;

         END IF;
         
      END;

   BEGIN

     InitError();
     
     IF (p_Party != UnknownParty) THEN  
         RETURN;
     END IF;
            
     IF p_IsWrtSale = TRUE THEN
       v_IsWrtSale := 1;
     END IF;

     IF p_CalcInterest = true THEN --Начисление процентного дохода

       IF p_IsWrtSale = true THEN --списание/погашение
         IF p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN
           OPEN GROUPLOTS_cur FOR SELECT LOT.T_PORTFOLIO PORTFOLIO,
                                     LOT.T_STATE STATE,
                                     LOT.T_INTERESTDATE INTERESTDATE,
                             CURSOR( SELECT NVL(SUM(T_AMOUNT), 0) S_AMOUNT,
                                            NVL(SUM(T_NKDAMOUNT), 0) S_NKDAMOUNT,
                                            NVL(SUM(T_INTERESTINCOME), 0) S_INTERESTINCOME
                                       FROM DPMWRTSUM_DBT
                                      WHERE T_PARTY           = p_Party
                                        AND T_DEPARTMENT      = p_Department
                                        AND T_CONTRACT        = p_Contract
                                        AND T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                        AND T_ENTERDATE      <= p_OperDate
                                        AND T_DATE           <= p_EndDate
                                        AND T_FIID            = p_FIID
                                        AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                        AND T_AMOUNT          > 0
                                        AND T_PORTFOLIO       = LOT.T_PORTFOLIO
                                        AND T_STATE           = LOT.T_STATE
                                        AND T_INTERESTDATE    = LOT.T_INTERESTDATE)
                               FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                              WHERE TMP.T_BUYID = LOT.T_SUMID
                           GROUP BY LOT.T_PORTFOLIO, LOT.T_STATE, LOT.T_INTERESTDATE;

           LOOP

              FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_INTERESTDATE, LOTS_cur;
              EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                        GROUPLOTS_cur%NOTFOUND IS NULL;

              LOOP

                 FETCH LOTS_cur INTO v_AMOUNT, v_NKDAMOUNT, v_INTERESTINCOME;
                 EXIT WHEN LOTS_cur%NOTFOUND OR
                           LOTS_cur%NOTFOUND IS NULL;

                 ChargeInterestIncome;

              END LOOP;

           END LOOP;
         ELSE

           OPEN GROUPLOTS_cur FOR SELECT LOT.T_PORTFOLIO PORTFOLIO,
                                     LOT.T_STATE STATE,
                                     LOT.T_BEGINTERESTDATE BEGINTERESTDATE,
                                     LOT.T_INTERESTDATE INTERESTDATE,
                             CURSOR( SELECT NVL(SUM(T_AMOUNT), 0) S_AMOUNT,
                                            NVL(SUM(T_NKDAMOUNT), 0) S_NKDAMOUNT,
                                            NVL(SUM(T_INTERESTINCOME), 0) S_INTERESTINCOME
                                       FROM DPMWRTSUM_DBT
                                      WHERE T_PARTY           = p_Party
                                        AND T_DEPARTMENT      = p_Department
                                        AND T_CONTRACT        = p_Contract
                                        AND T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                        AND T_ENTERDATE      <= p_OperDate
                                        AND T_DATE           <= p_EndDate
                                        AND T_FIID            = p_FIID
                                        AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                        AND T_AMOUNT          > 0
                                        AND T_PORTFOLIO       = LOT.T_PORTFOLIO
                                        AND T_STATE           = LOT.T_STATE
                                        AND T_BEGINTERESTDATE = LOT.T_BEGINTERESTDATE 
                                        AND T_INTERESTDATE    = LOT.T_INTERESTDATE)
                               FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                              WHERE TMP.T_BUYID = LOT.T_SUMID
                           GROUP BY LOT.T_PORTFOLIO, LOT.T_STATE, LOT.T_BEGINTERESTDATE, LOT.T_INTERESTDATE;

           LOOP

              FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGINTERESTDATE, v_INTERESTDATE, LOTS_cur;
              EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                        GROUPLOTS_cur%NOTFOUND IS NULL;

              LOOP

                 FETCH LOTS_cur INTO v_AMOUNT, v_NKDAMOUNT, v_INTERESTINCOME;
                 EXIT WHEN LOTS_cur%NOTFOUND OR
                           LOTS_cur%NOTFOUND IS NULL;

                 ChargeInterestIncome;

              END LOOP;

           END LOOP;
         END IF;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление ПДД

         OPEN GROUPLOTS_cur  FOR  SELECT T_PORTFOLIO as PORTFOLIO,
                                    T_STATE as STATE,
                                    (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN UnknownDate ELSE T_BEGINTERESTDATE END) as BEGINTERESTDATE,
                                    T_INTERESTDATE  as INTERESTDATE,
                                    NVL(SUM(T_AMOUNT), 0) S_AMOUNT,
                                    NVL(SUM(T_NKDAMOUNT), 0) S_NKDAMOUNT,
                                    NVL(SUM(T_INTERESTINCOME), 0) S_INTERESTINCOME
                               FROM DPMWRTSUM_DBT
                              WHERE T_PARTY       = p_Party
                                AND T_DEPARTMENT  = p_Department
                                AND T_CONTRACT    = p_Contract
                                AND T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
                                AND T_PORTFOLIO IN (p_P1, p_P2, p_P3, p_P4, p_P5)
                                AND T_ENTERDATE  <= p_OperDate
                                AND T_DATE       <= p_EndDate 
                                AND T_BEGINTERESTDATE <> p_EndDate
                                AND T_FIID        = p_FIID
                                AND T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                AND T_AMOUNT      > 0
                              GROUP BY T_PORTFOLIO, T_STATE, (case when p_AmortizationMethod = PM_WRITEOFF_AVERAGE THEN UnknownDate ELSE T_BEGINTERESTDATE END), T_INTERESTDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGINTERESTDATE, v_INTERESTDATE, v_AMOUNT, v_NKDAMOUNT, v_INTERESTINCOME;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            ChargeInterestIncome;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcBonus = true THEN --Начисление премии

       IF p_IsWrtSale = true THEN --списание/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_PORTFOLIO PORTFOLIO,
                                   LOT.T_STATE STATE,
                                   LOT.T_BEGBONUSDATE BEGBONUSDATE,
                                   LOT.T_BONUSDATE BONUSDATE,
                                   LOT.T_RECALCDATE RECALCDATE,
                           CURSOR( SELECT NVL(SUM(case when (L.T_BEGBONUS > 0 OR L.T_OLDBEGBONUS > 0)
                                                       then L.T_AMOUNT else 0 end), 0) S_AMOUNT,
                                          NVL(SUM(case when (L.T_BEGBONUS > 0 OR L.T_OLDBEGBONUS > 0)
                                                       then (case when ( SELECT count(1)
                                                                           FROM DPMWRTSUM_TMP TMP1
                                                                          WHERE TMP1.T_SUMID = L.T_SUMID
                                                                            AND TMP1.T_KIND = 0 ) > 0
                                                                  then TMP1.T_cost else L.T_cost end)
                                                       else 0 end), 0) S_COST,
                                          NVL(SUM(L.T_BONUS), 0) S_BONUS,
                                          NVL(SUM(L.T_BEGBONUS), 0) S_BEGBONUS,
                                          NVL(SUM(L.T_OLDBEGBONUS), 0) S_OLDBEGBONUS
                                     FROM DPMWRTSUM_DBT L left join DPMWRTSUM_TMP TMP1 on TMP1.T_SUMID = L.T_SUMID AND TMP1.T_KIND = 0
                                    WHERE L.T_PARTY           = p_Party
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_CONTRACT        = p_Contract
                                      AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_DATE           <= p_EndDate
                                      AND L.T_FIID            = p_FIID
                                      AND L.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_PORTFOLIO       = LOT.T_PORTFOLIO
                                      AND L.T_STATE           = LOT.T_STATE
                                      AND L.T_BEGBONUSDATE    = LOT.T_BEGBONUSDATE
                                      AND L.T_BONUSDATE       = LOT.T_BONUSDATE
                                      AND L.T_RECALCDATE      = LOT.T_RECALCDATE)
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND 1=(CASE WHEN CALC_PDD_BOND_SSPU() = CALC_PDD_BOND_SSPU_PD AND LOT.T_PORTFOLIO=KINDPORT_TRADE THEN 0 ELSE 1 END)
                         GROUP BY LOT.T_PORTFOLIO, LOT.T_STATE, LOT.T_BEGBONUSDATE, LOT.T_BONUSDATE, LOT.T_RECALCDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGBONUSDATE, v_BONUSDATE, v_RECALCDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO v_AMOUNT, v_COST, v_BONUS, v_BEGBONUS, v_OLDBEGBONUS;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeBonus;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление ПДД

         OPEN GROUPLOTS_cur FOR SELECT L.T_PORTFOLIO PORTFOLIO,
                                    L.T_STATE STATE,
                                    L.T_BEGBONUSDATE BEGBONUSDATE,
                                    L.T_BONUSDATE BONUSDATE,
                                    L.T_RECALCDATE RECALCDATE,
                                    NVL(SUM(case when (L.T_BEGBONUS > 0 OR L.T_OLDBEGBONUS > 0)
                                                 then L.T_AMOUNT else 0 end), 0) S_AMOUNT,
                                    NVL(SUM(L.T_BONUS), 0) S_BONUS,
                                    NVL(SUM(L.T_BEGBONUS), 0) S_BEGBONUS,
                                    NVL(SUM(L.T_OLDBEGBONUS), 0) S_OLDBEGBONUS
                               FROM DPMWRTSUM_DBT L left join DPMWRTSUM_TMP TMP1 on TMP1.T_SUMID = L.T_SUMID AND TMP1.T_KIND = 0
                              WHERE L.T_PARTY           = p_Party
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_CONTRACT        = p_Contract
                                AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                AND L.T_PORTFOLIO IN (p_P1, p_P2, p_P3, p_P4, p_P5)
                                AND 1=(CASE WHEN CALC_PDD_BOND_SSPU() = CALC_PDD_BOND_SSPU_PD AND L.T_PORTFOLIO=KINDPORT_TRADE THEN 0 ELSE 1 END)
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_DATE           <= p_EndDate
                                AND L.T_FIID            = p_FIID
                                AND L.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                AND L.T_AMOUNT          > 0
                         GROUP BY L.T_PORTFOLIO, L.T_STATE, L.T_BEGBONUSDATE, L.T_BONUSDATE, L.T_RECALCDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGBONUSDATE, v_BONUSDATE, v_RECALCDATE, v_AMOUNT, v_BONUS, v_BEGBONUS, v_OLDBEGBONUS;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeBonus;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcDiscount = true THEN --Начисление дисконтного дохода

       IF p_IsWrtSale = true THEN --списание/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_PORTFOLIO PORTFOLIO,
                                   LOT.T_STATE STATE,
                                   LOT.T_BEGDISCOUNTDATE BEGDISCOUNTDATE,
                                   LOT.T_DISCOUNTDATE DISCOUNTDATE,
                                   LOT.T_RECALCDATE RECALCDATE,
                           CURSOR (SELECT NVL(SUM(case when (L.T_BEGDISCOUNT > 0 OR L.T_OLDBEGDISCOUNT > 0)
                                                       then L.T_AMOUNT else 0 end), 0) S_AMOUNT,
                                          NVL(SUM(case when (L.T_BEGDISCOUNT > 0 OR L.T_OLDBEGDISCOUNT > 0)
                                                       then (case when ( SELECT count(1)
                                                                           FROM DPMWRTSUM_TMP TMP1
                                                                          WHERE TMP1.T_SUMID = L.T_SUMID
                                                                            AND TMP1.T_KIND = 0 ) > 0
                                                                  then TMP1.T_cost else L.T_cost end)
                                                       else 0 end), 0) S_COST,
                                          NVL(SUM(L.T_DISCOUNTINCOME), 0) S_DISCOUNTINCOME,
                                          NVL(SUM(L.T_BEGDISCOUNT), 0) S_BEGDISCOUNT,
                                          NVL(SUM(L.T_OLDBEGDISCOUNT), 0) S_OLDBEGDISCOUNT
                                     FROM DPMWRTSUM_DBT L left join DPMWRTSUM_TMP TMP1 on TMP1.T_SUMID = L.T_SUMID AND TMP1.T_KIND = 0
                                    WHERE L.T_PARTY           = p_Party
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_CONTRACT        = p_Contract
                                      AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_DATE           <= p_EndDate
                                      AND L.T_FIID            = p_FIID
                                      AND L.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_PORTFOLIO       = LOT.T_PORTFOLIO
                                      AND L.T_STATE           = LOT.T_STATE
                                      AND L.T_BEGDISCOUNTDATE = LOT.T_BEGDISCOUNTDATE
                                      AND L.T_DISCOUNTDATE    = LOT.T_DISCOUNTDATE
                                      AND L.T_RECALCDATE      = LOT.T_RECALCDATE)
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND 1=(CASE WHEN CALC_PDD_BOND_SSPU() = CALC_PDD_BOND_SSPU_PD AND LOT.T_PORTFOLIO=KINDPORT_TRADE THEN 0 ELSE 1 END)
                         GROUP BY LOT.T_PORTFOLIO, LOT.T_STATE, LOT.T_BEGDISCOUNTDATE, LOT.T_DISCOUNTDATE, LOT.T_RECALCDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGDISCOUNTDATE, v_DISCOUNTDATE, v_RECALCDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO v_AMOUNT, v_COST, v_DISCOUNTINCOME, v_BEGDISCOUNT, v_OLDBEGDISCOUNT;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeDiscountIncome;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление ПДД

         OPEN GROUPLOTS_cur FOR  SELECT L.T_PORTFOLIO PORTFOLIO,
                                    L.T_STATE STATE,
                                    L.T_BEGDISCOUNTDATE BEGDISCOUNTDATE,
                                    L.T_DISCOUNTDATE DISCOUNTDATE,
                                    L.T_RECALCDATE RECALCDATE,
                                    NVL(SUM(case when (L.T_BEGDISCOUNT > 0 OR L.T_OLDBEGDISCOUNT > 0)
                                                       then L.T_AMOUNT else 0 end), 0) S_AMOUNT,
                                    NVL(SUM(case when (L.T_BEGDISCOUNT > 0 OR L.T_OLDBEGDISCOUNT > 0)
                                                       then (case when ( SELECT count(1)
                                                                           FROM DPMWRTSUM_TMP TMP1
                                                                          WHERE TMP1.T_SUMID = L.T_SUMID
                                                                            AND TMP1.T_KIND = 0 ) > 0
                                                                  then TMP1.T_cost else L.T_cost end)
                                                       else 0 end), 0) S_COST,
                                    NVL(SUM(L.T_DISCOUNTINCOME), 0) S_DISCOUNTINCOME,
                                    NVL(SUM(L.T_BEGDISCOUNT), 0) S_BEGDISCOUNT,
                                    NVL(SUM(L.T_OLDBEGDISCOUNT), 0) S_OLDBEGDISCOUNT
                               FROM DPMWRTSUM_DBT L left join DPMWRTSUM_TMP TMP1 on TMP1.T_SUMID = L.T_SUMID AND TMP1.T_KIND = 0
                              WHERE L.T_PARTY           = p_Party
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_CONTRACT        = p_Contract
                                AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                AND L.T_PORTFOLIO IN (p_P1, p_P2, p_P3, p_P4, p_P5)
                                AND 1=(CASE WHEN CALC_PDD_BOND_SSPU() = CALC_PDD_BOND_SSPU_PD AND L.T_PORTFOLIO=KINDPORT_TRADE THEN 0 ELSE 1 END)
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_DATE           <= p_EndDate
                                AND L.T_FIID            = p_FIID
                                AND L.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                AND L.T_AMOUNT          > 0
                         GROUP BY L.T_PORTFOLIO, L.T_STATE, L.T_BEGDISCOUNTDATE, L.T_DISCOUNTDATE, L.T_RECALCDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGDISCOUNTDATE, v_DISCOUNTDATE, v_RECALCDATE, v_AMOUNT, v_COST, v_DISCOUNTINCOME, v_BEGDISCOUNT, v_OLDBEGDISCOUNT;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeDiscountIncome;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcDefDiff = true THEN --Начисление отсроченной разницы

       IF p_IsWrtSale = true THEN --списание/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_PORTFOLIO PORTFOLIO,
                                   LOT.T_STATE STATE,
                                   LOT.T_BEGDEFDIFFDATE  BEGDEFDIFFDATE,
                                   LOT.T_DEFDIFFDATE DEFDIFFDATE,
                                   LOT.T_RECALCDATE RECALCDATE,
                           CURSOR( SELECT NVL(SUM(case when L.T_BEGDEFDIFF != 0
                                                       then L.T_AMOUNT else 0 end), 0) S_AMOUNT,
                                          NVL(SUM(L.T_ACCOUNTEDDEFDIFF), 0) S_ACCOUNTEDDEFDIFF,
                                          NVL(SUM(L.T_BEGDEFDIFF), 0) S_T_BEGDEFDIFF
                                     FROM DPMWRTSUM_DBT L left join DPMWRTSUM_TMP TMP1 on TMP1.T_SUMID = L.T_SUMID
                                    WHERE L.T_PARTY           = p_Party
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_CONTRACT        = p_Contract
                                      AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_DATE           <= p_EndDate
                                      AND L.T_FIID            = p_FIID
                                      AND L.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_PORTFOLIO       = LOT.T_PORTFOLIO
                                      AND L.T_STATE           = LOT.T_STATE
                                      AND L.T_BEGDEFDIFFDATE  = LOT.T_BEGDEFDIFFDATE
                                      AND L.T_DEFDIFFDATE     = LOT.T_DEFDIFFDATE
                                      AND L.T_RECALCDATE      = LOT.T_RECALCDATE
                                      AND L.T_BEGDEFDIFF      != 0)
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                         GROUP BY LOT.T_PORTFOLIO, LOT.T_STATE, LOT.T_BEGDEFDIFFDATE, LOT.T_DEFDIFFDATE, LOT.T_RECALCDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGDEFDIFFDATE, v_DEFDIFFDATE, v_RECALCDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO v_AMOUNT, v_ACCOUNTEDDEFDIFF, v_BEGDEFDIFF;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeDefDiff;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление ПДД

         OPEN GROUPLOTS_cur FOR SELECT L.T_PORTFOLIO PORTFOLIO,
                                    L.T_STATE STATE,
                                    L.T_BEGDEFDIFFDATE  BEGDEFDIFFDATE,
                                    L.T_DEFDIFFDATE DEFDIFFDATE,
                                    L.T_RECALCDATE RECALCDATE,
                                    NVL(SUM(case when L.T_BEGDEFDIFF != 0
                                                 then L.T_AMOUNT else 0 end), 0) S_AMOUNT,
                                    NVL(SUM(L.T_ACCOUNTEDDEFDIFF), 0) S_ACCOUNTEDDEFDIFF,
                                    NVL(SUM(L.T_BEGDEFDIFF), 0) S_BEGDEFDIFF
                               FROM DPMWRTSUM_DBT L left join DPMWRTSUM_TMP TMP1 on TMP1.T_SUMID = L.T_SUMID AND TMP1.T_KIND = 0
                              WHERE L.T_PARTY           = p_Party
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_CONTRACT        = p_Contract
                                AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_BUY
                                AND L.T_PORTFOLIO IN (p_P1, p_P2, p_P3, p_P4, p_P5)
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_BEGDEFDIFFDATE <= p_EndDate
                                AND L.T_FIID            = p_FIID
                                AND L.T_STATE IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP)
                                AND L.T_AMOUNT          > 0
                                AND L.T_BEGDEFDIFF      != 0 
                         GROUP BY L.T_PORTFOLIO, L.T_STATE, L.T_BEGDEFDIFFDATE, L.T_DEFDIFFDATE, L.T_RECALCDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_PORTFOLIO, v_STATE, v_BEGDEFDIFFDATE, v_DEFDIFFDATE, v_RECALCDATE, v_AMOUNT, v_ACCOUNTEDDEFDIFF, v_BEGDEFDIFF;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeDefDiff;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcCorrIntToEIR = true THEN --Начисление корректировки процентов по ЭПС
         ChargeCorrIntToEIR;
     END IF;

   END;--RSI_WRTChargeIncomToLotsTMP

   --Выполняет начисление расходов на лоты во временную таблицу в операции начисления ПДД, погашения, либо при продаже.
   PROCEDURE RSI_WRTChargeExpToOwnLotsTMP( p_IsRet              IN BOOLEAN, -- Признак вызова при возвращении ц/б (выкуп, погашение, зачисление) (true-выкуп/зачисление/погашение, false-начисление расхода)
                                           p_OperDate           IN DATE,    -- Дата
                                           p_EndDate            IN DATE,    -- Дата окончания периода начисления
                                           p_FIID               IN NUMBER,  -- Выпуск
                                           p_Department         IN NUMBER,  -- Филиал
                                           p_CalcInterest       IN BOOLEAN, --начислять ПД
                                           p_CalcDiscount       IN BOOLEAN, --начислять ДД
                                           p_CalcBonus          IN BOOLEAN, --начислять премию
                                           p_CalcDefDiff        IN BOOLEAN, --Начисление отсроченной разницы
                                           p_CalcOutLay         IN BOOLEAN, --Начисление затрат по сделкам
                                           p_CalcCorr           IN BOOLEAN, --Корректировка стоимости
                                           p_LnkKind            IN NUMBER DEFAULT 0, -- Вид связи списания
                                           p_Coupon             IN VARCHAR2 DEFAULT NULL, -- номер купона
                                           p_CalcAddInc         IN BOOLEAN DEFAULT FALSE -- Начислять доп. доход по БИО
                                         )
   IS
      v_CorrIntToEIR    NUMBER := 0;
      v_AmortCost       NUMBER := 0;
      v_AMOUNT          NUMBER := 0;
      v_NKDAMOUNT       NUMBER := 0;
      v_INTERESTINCOME  NUMBER := 0;
      v_BEGINTERESTDATE DATE;
      v_INTERESTDATE    DATE;

      v_InterestAddRest NUMBER := 0;
      v_InterestAdd     NUMBER := 0;
      v_LotInterestAdd  NUMBER := 0;

      v_BonusAdd        NUMBER := 0;
      v_BonusAddRest    NUMBER := 0;
      v_LotBonusAdd     NUMBER := 0;
      v_BegBonusDate    DATE;

      v_BONUSDATE       DATE;
      v_RECALCDATE      DATE;
      v_BONUS           NUMBER := 0;
      v_BEGBONUS        NUMBER := 0;

      v_BEGDISCOUNTDATE DATE;
      v_DISCOUNTDATE    DATE;
      v_COST            NUMBER := 0;
      v_DISCOUNTINCOME  NUMBER := 0;
      v_BEGDISCOUNT     NUMBER := 0;
      v_DiscountAdd     NUMBER := 0;
      v_DiscountAddRest NUMBER := 0;
      v_LotDiscountAdd  NUMBER := 0;

      v_DATE             DATE;
      v_BEGDEFDIFFDATE   DATE;
      v_DEFDIFFDATE      DATE;
      v_ACCOUNTEDDEFDIFF NUMBER := 0;
      v_BEGDEFDIFF       NUMBER := 0;
      v_DefDiffAdd       NUMBER := 0;
      v_DefDiffAddRest   NUMBER := 0;
      v_LotDefDiffAdd    NUMBER := 0;

      v_WRTOUTLAYDATE    DATE;
      v_WRTOUTLAY        NUMBER := 0;
      v_OUTLAY           NUMBER := 0;
      v_WRTVATOUTLAY     NUMBER := 0;
      v_VATOUTLAY        NUMBER := 0;
      v_WrtOutlayAdd     NUMBER := 0;
      v_VatOutlayAdd     NUMBER := 0;
      v_WrtOutlayAddRest NUMBER := 0;
      v_VatOutlayAddRest NUMBER := 0;
      v_LotWrtOutlayAdd  NUMBER := 0;
      V_LOTVATOUTLAYADD  NUMBER := 0;
      v_EIR              NUMBER := 0;

      v_IsRet            NUMBER := 0;
                        
      v_BioPFI           NUMBER := 0;
      v_BioPFICurrency   NUMBER := -1;

      v_ExistTmpLot      NUMBER := 0;

      v_SumAmount           NUMBER := 0;
      v_NewSumAddIncome     NUMBER := 0;
      v_RestAmount          NUMBER := 0;
      v_RestNewSumAddIncome NUMBER := 0;
      v_NewLotAddIncome     NUMBER := 0;
      v_LotAddIncomeAdd     NUMBER := 0;
      v_CalcCorrLimitDate   DATE   := TO_DATE('01.01.2019', 'DD.MM.YYYY');

      v_IsInterestIncomeCalcDisable BOOLEAN := FALSE;
      v_PaymentRefuse CHAR;

      TYPE LOTSCurTyp IS REF CURSOR;
      LOTS_cur LOTSCurTyp;

      TYPE GROUPLOTSCurTyp IS REF CURSOR;
      GROUPLOTS_cur GROUPLOTSCurTyp;

      CURSOR cLotInterest(BEGINTERESTDATE IN DATE, INTERESTDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = UnknownParty
            AND T_DEPARTMENT  = p_Department
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE       = PM_WRTSUM_PLACE_OWN
            AND T_PORTFOLIO != -2 /*AD*/
            AND T_AMOUNT      > 0
            AND T_BEGINTERESTDATE = BEGINTERESTDATE
            AND T_INTERESTDATE    = INTERESTDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotDiscount(BEGDISCOUNTDATE IN DATE, DISCOUNTDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = UnknownParty
            AND T_DEPARTMENT  = p_Department
            --AND T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
            AND T_BUY_SALE   in (  PM_WRITEOFF_SUM_PLACE, PM_WRTSUM_BUYOUT_OWN)
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
         --AND T_STATE       = PM_WRTSUM_PLACE_OWN
/*AD*/ AND  T_STATE IN ( PM_WRTSUM_PLACE_OWN,  PM_WRTSUM_BUYOUT_OWN )
            AND T_AMOUNT      > 0
            AND T_BEGDISCOUNTDATE = BEGDISCOUNTDATE
            AND T_DISCOUNTDATE    = DISCOUNTDATE
            AND T_BEGDISCOUNT     > 0
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotBonus(BEGBONUSDATE IN DATE, BONUSDATE IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = UnknownParty
            AND T_DEPARTMENT  = p_Department
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE       = PM_WRTSUM_PLACE_OWN
            AND T_AMOUNT      > 0
            AND T_BEGBONUSDATE = BEGBONUSDATE
            AND T_BONUSDATE    = BONUSDATE
            AND T_BEGBONUS     > 0
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotDefDiff(DEFDIFFDATE IN DATE, DATE_ IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = UnknownParty
            AND T_DEPARTMENT  = p_Department
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE       = PM_WRTSUM_PLACE_OWN
            AND T_AMOUNT      > 0
            AND T_BEGDEFDIFF  != 0
            AND T_BEGDEFDIFFDATE = DATE_
            AND T_DEFDIFFDATE = DEFDIFFDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      CURSOR cLotOutlay(WRTOUTLAYDATE IN DATE, DATE_ IN DATE) IS
         SELECT *
           FROM DPMWRTSUM_DBT
          WHERE T_PARTY       = UnknownParty
            AND T_DEPARTMENT  = p_Department
            AND T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
            AND T_ENTERDATE  <= p_OperDate
            AND T_DATE       <= p_EndDate
            AND T_FIID        = p_FIID
            AND T_STATE       = PM_WRTSUM_PLACE_OWN
            AND T_AMOUNT      > 0
            AND T_OUTLAY      > 0
            AND T_DATE        = DATE_
            AND T_WRTOUTLAYDATE = WRTOUTLAYDATE
          ORDER BY T_AMOUNT ASC, T_DATE DESC;

      PROCEDURE ChargeInterestIncome -- начисление ПД по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
      BEGIN

         IF (v_IsInterestIncomeCalcDisable) THEN
            v_InterestAdd := 0;
         ELSE
            v_InterestAdd := WRTCalcInterestExpenseOwn (p_EndDate, v_BEGINTERESTDATE, p_LnkKind, p_FIID, v_AMOUNT, v_NKDAMOUNT, v_INTERESTDATE, v_INTERESTINCOME, p_Coupon, 1);
         END IF;
         
         v_InterestAddRest := v_InterestAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotInterest(v_BEGINTERESTDATE, v_INTERESTDATE) LOOP

            IF v_Amount > LOT.T_AMOUNT THEN
               IF (v_IsInterestIncomeCalcDisable) THEN
                 v_LotInterestAdd := 0;
               ELSE
                 v_LotInterestAdd := WRTCalcInterestExpenseOwn (p_EndDate, v_BEGINTERESTDATE, p_LnkKind, p_FIID, LOT.T_AMOUNT, LOT.T_NKDAMOUNT, v_INTERESTDATE, LOT.T_INTERESTINCOME, p_Coupon, 1);
               END IF;
            ELSE
               v_LotInterestAdd := v_InterestAddRest;
            END IF;

            SELECT count(1) into v_Count
              FROM DPMWRTSUM_TMP TMP
             WHERE TMP.T_SUMID = LOT.T_SUMID;

            IF( v_Count > 0 ) THEN

               BEGIN
                  UPDATE DPMWRTSUM_TMP TMP SET
                    TMP.T_INTERESTADD       = v_LotInterestAdd,
                    TMP.T_INTERESTINCOME    = TMP.T_INTERESTINCOME + v_LotInterestAdd,
                    TMP.T_INTERESTDATE      = p_EndDate
                  where TMP.T_SUMID = LOT.T_SUMID;
               END;

            ELSE

               INSERT INTO DPMWRTSUM_TMP
                          (
                            T_SUMID,
                            T_KIND,
                            T_AMOUNT,
                            T_COST,
                            T_BALANCECOST,
                            T_INTERESTADD,
                            T_BONUSADD,
                            T_DISCOUNTADD,
                            T_INTERESTINCOME,
                            T_NOTCARRYINTEREST,
                            T_INTERESTDATE,
                            T_BEGDISCOUNTDATE,
                            T_BEGBONUSDATE,
                            T_DISCOUNTINCOME,
                            T_NOTCARRYDISCOUNT,
                            T_DISCOUNTDATE,
                            T_BONUS,
                            T_BONUSDATE,
                            T_NOTWRTBONUS,
                            T_DEFDIFFADD,
                            T_ACCOUNTEDDEFDIFF,
                            T_DEFDIFFDATE,
                            T_WRTOUTLAYADD,
                            T_WRTOUTLAY,
                            T_WRTOUTLAYDATE,
                            T_VATOUTLAYADD,
                            T_WRTVATOUTLAY,
                            T_CORRVALUE,
                            T_CORRDATE,
                            T_AMORTCOST,
                            T_CORRINTTOEIR,
                            T_CORRINTTOEIRDATE,
                            T_WRTCORRINTTOEIR,
                            T_ESTRESERVEADD,
                            T_CORRESTRESERVEADD,
                            T_RESERVAMOUNTADD,
                            T_INCOMERESERVADD,
                            T_PORTFOLIO,
                            T_STATE,
                            T_OVERAMOUNT,
                            T_OVERAMOUNTADD,
                            T_DEALID,
                            T_BEGDEFDIFFDATE,
                            T_ADDINCOMEOWN,
                            T_ADDINCOMEOWNADD,
                            T_ADDINCOMEOWNDATE,
                            T_HEDGCORR,
                            T_HEDGCORRDATE,
                            T_AMORTHEDGCORR,
                            T_AMORTHEDGCORRDATE
                          )
                   VALUES (
                            LOT.T_SUMID,
                            0,
                            LOT.T_AMOUNT,
                            LOT.T_COST,
                            LOT.T_BALANCECOST,
                            v_LotInterestAdd,
                            0,
                            0,
                            v_LotInterestAdd + LOT.T_INTERESTINCOME,
                            LOT.T_NOTCARRYINTEREST,
                            p_EndDate,
                            LOT.T_BEGDISCOUNTDATE,
                            LOT.T_BEGBONUSDATE,
                            LOT.T_DISCOUNTINCOME,
                            LOT.T_NOTCARRYDISCOUNT,
                            LOT.T_DISCOUNTDATE,
                            LOT.T_BONUS,
                            LOT.T_BONUSDATE,
                            LOT.T_NOTWRTBONUS,
                            0,
                            LOT.T_ACCOUNTEDDEFDIFF,
                            LOT.T_DEFDIFFDATE,
                            0,
                            LOT.T_WRTOUTLAY,
                            LOT.T_WRTOUTLAYDATE,
                            0,
                            LOT.T_WRTVATOUTLAY,
                            LOT.T_CORRVALUE,
                            LOT.T_CORRDATE,
                            LOT.T_AMORTCOST,
                            LOT.T_CORRINTTOEIR,
                            LOT.T_CORRINTTOEIRDATE,
                            0,
                            0,
                            0,
                            0,
                            0,
                            LOT.T_PORTFOLIO,
                            LOT.T_STATE,
                            LOT.T_OVERAMOUNT,
                            0,
                            LOT.T_DEALID,
                            LOT.T_BEGDEFDIFFDATE,
                            LOT.T_ADDINCOMEOWN,
                            0,
                            LOT.T_ADDINCOMEOWNDATE,
                            LOT.T_HEDGCORR,
                            LOT.T_HEDGCORRDATE,
                            LOT.T_AMORTHEDGCORR,
                            LOT.T_AMORTHEDGCORRDATE
                          );
            END IF;

            v_Amount := v_Amount - LOT.T_AMOUNT;
            v_InterestAddRest := v_InterestAddRest - v_LotInterestAdd;

         END LOOP;

         if v_Amount <> 0 or v_InterestAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeDiscountIncome -- Начисление дисконтного дохода по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
         v_LOTCOST NUMBER := 0;
      BEGIN

         v_DiscountAdd := WRTCalcDiscountExpenseOwn (p_EndDate, v_BEGDISCOUNTDATE, p_LnkKind, p_FIID,
                                                     v_DISCOUNTDATE, v_DISCOUNTINCOME,
                                                     v_BEGDISCOUNT);
         v_DiscountAddRest := v_DiscountAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotDiscount(v_BEGDISCOUNTDATE, v_DISCOUNTDATE) LOOP

            IF LOT.T_BEGDISCOUNT = 0 THEN
               v_LotDiscountAdd := 0;
            ELSIF v_Amount > LOT.T_AMOUNT THEN
               v_LotDiscountAdd := WRTCalcDiscountExpenseOwn (p_EndDate, v_BEGDISCOUNTDATE, p_LnkKind, p_FIID,
                                                              v_DISCOUNTDATE, LOT.T_DISCOUNTINCOME, LOT.T_BEGDISCOUNT);
            ELSE
               v_LotDiscountAdd := v_DiscountAddRest;
            END IF;

            BEGIN
               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID;

               IF( v_Count > 0 ) THEN

                  BEGIN
                     UPDATE DPMWRTSUM_TMP TMP SET
                       TMP.T_DISCOUNTADD       = v_LotDiscountAdd,
                       TMP.T_DISCOUNTINCOME    = TMP.T_DISCOUNTINCOME + v_LotDiscountAdd,
                       TMP.T_DISCOUNTDATE      = p_EndDate
                     where TMP.T_SUMID = LOT.T_SUMID;
                  END;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_ADDINCOMEOWN,
                               T_ADDINCOMEOWNADD,
                               T_ADDINCOMEOWNDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST,
                               0,
                               0,
                               v_LotDiscountAdd,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME + v_LotDiscountAdd,
                               LOT.T_NOTCARRYDISCOUNT,
                               p_EndDate,
                               LOT.T_BONUS,
                               LOT.T_BONUSDATE,
                               LOT.T_NOTWRTBONUS,
                               0,
                               LOT.T_ACCOUNTEDDEFDIFF,
                               LOT.T_DEFDIFFDATE,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               LOT.T_ADDINCOMEOWN,
                               0,
                               LOT.T_ADDINCOMEOWNDATE,
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            IF LOT.T_BEGDISCOUNT > 0 THEN
               v_Amount          := v_Amount - LOT.T_AMOUNT;
               v_DiscountAddRest := v_DiscountAddRest - v_LotDiscountAdd;
            END IF;

         END LOOP;

         if v_Amount <> 0 or v_DiscountAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeBonus -- Начисление премии по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
      BEGIN

         v_BonusAdd := WRTCalcBonusOwn(p_EndDate, v_BEGBONUSDATE, p_LnkKind, p_FIID,
                                       v_BONUSDATE, v_BONUS, v_BEGBONUS
                                      );
         v_BonusAddRest := v_BonusAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotBonus(v_BEGBONUSDATE, v_BONUSDATE) LOOP

            IF LOT.T_BEGBONUS = 0 THEN
               v_LotBonusAdd := 0;
            ELSIF v_Amount > LOT.T_AMOUNT THEN
               v_LotBonusAdd := WRTCalcBonusOwn(p_EndDate, v_BEGBONUSDATE, p_LnkKind, p_FIID,
                                                v_BONUSDATE, LOT.T_BONUS, LOT.T_BEGBONUS
                                               );
            ELSE
               v_LotBonusAdd := v_BonusAddRest;
            END IF;

            BEGIN

               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID;

               IF( v_Count > 0 ) THEN

                  UPDATE DPMWRTSUM_TMP SET
                    T_BONUSADD          = v_LotBonusAdd,
                    T_BONUS             = T_BONUS + v_LotBonusAdd,
                    T_BONUSDATE         = p_EndDate
                  where T_SUMID = LOT.T_SUMID;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_ADDINCOMEOWN,
                               T_ADDINCOMEOWNADD,
                               T_ADDINCOMEOWNDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST,
                               0,
                               v_LotBonusAdd,
                               0,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME,
                               LOT.T_NOTCARRYDISCOUNT,
                               LOT.T_DISCOUNTDATE,
                               LOT.T_BONUS + v_LotBonusAdd,
                               p_EndDate,
                               LOT.T_NOTWRTBONUS,
                               0,
                               LOT.T_ACCOUNTEDDEFDIFF,
                               LOT.T_DEFDIFFDATE,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               LOT.T_ADDINCOMEOWN,
                               0,
                               LOT.T_ADDINCOMEOWNDATE,
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            IF LOT.T_BEGBONUS > 0 THEN
               v_Amount       := v_Amount - LOT.T_AMOUNT;
               v_BonusAddRest := v_BonusAddRest - v_LotBonusAdd;
            END IF;

         END LOOP;

         if v_Amount <> 0 or v_BonusAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeDefDiff -- Начисление отсроченной разницы по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
      BEGIN

         v_DefDiffAdd := WRTCalcDefDiffOwn(p_EndDate, v_BEGDEFDIFFDATE, p_LnkKind, p_FIID,
                                           v_DEFDIFFDATE, v_ACCOUNTEDDEFDIFF, v_BEGDEFDIFF
                                          );
         v_DefDiffAddRest := v_DefDiffAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotDefDiff(v_DEFDIFFDATE, v_DATE) LOOP

            IF v_Amount > LOT.T_AMOUNT THEN
               v_LotDefDiffAdd := WRTCalcDefDiffOwn(p_EndDate, v_BEGDEFDIFFDATE, p_LnkKind, p_FIID,
                                                    v_DEFDIFFDATE, LOT.T_ACCOUNTEDDEFDIFF, LOT.T_BEGDEFDIFF
                                                   );
            ELSE
               v_LotDefDiffAdd := v_DefDiffAddRest;
            END IF;

            BEGIN

               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID;

               IF( v_Count > 0 ) THEN

                  UPDATE DPMWRTSUM_TMP SET
                    T_DEFDIFFADD        = v_LotDefDiffAdd,
                    T_ACCOUNTEDDEFDIFF  = T_ACCOUNTEDDEFDIFF + v_LotDefDiffAdd,
                    T_DEFDIFFDATE       = p_EndDate
                  where T_SUMID = LOT.T_SUMID;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_ADDINCOMEOWN,
                               T_ADDINCOMEOWNADD,
                               T_ADDINCOMEOWNDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST,
                               0,
                               0,
                               0,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME,
                               LOT.T_NOTCARRYDISCOUNT,
                               LOT.T_DISCOUNTDATE,
                               LOT.T_BONUS,
                               LOT.T_BONUSDATE,
                               LOT.T_NOTWRTBONUS,
                               v_LotDefDiffAdd,
                               LOT.T_ACCOUNTEDDEFDIFF + v_LotDefDiffAdd,
                               p_EndDate,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               LOT.T_ADDINCOMEOWN,
                               0,
                               LOT.T_ADDINCOMEOWNDATE,
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            v_Amount          := v_Amount - LOT.T_AMOUNT;
            v_DefDiffAddRest  := v_DefDiffAddRest - v_LotDefDiffAdd;

         END LOOP;

         if v_Amount <> 0 or v_DefDiffAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

      PROCEDURE ChargeOutlay -- Начисление затрат по сделкам по лотам во временную таблицу
      IS
         v_Count NUMBER;
         v_AMOUNT0 NUMBER := 0;
      BEGIN

         v_WrtOutlayAdd := WRTCalcWrtOutlayOwn(p_EndDate, v_DATE, p_LnkKind, p_FIID,
                                               v_WRTOUTLAYDATE, v_WRTOUTLAY, v_OUTLAY
                                              );
         v_VatOutlayAdd := WRTCalcVatOutlayOwn(p_EndDate, v_DATE, p_LnkKind, p_FIID,
                                               v_WRTOUTLAYDATE, v_WRTVATOUTLAY, v_VATOUTLAY
                                              );
         v_WrtOutlayAddRest := v_WrtOutlayAdd;
         v_VatOutlayAddRest := v_VatOutlayAdd;
         v_AMOUNT0 := v_AMOUNT;

         FOR LOT IN cLotOutlay(v_WRTOUTLAYDATE, v_DATE) LOOP

            IF v_Amount > LOT.T_AMOUNT THEN

               v_LotWrtOutlayAdd := WRTCalcWrtOutlayOwn(p_EndDate, v_DATE, p_LnkKind, p_FIID,
                                                        v_WRTOUTLAYDATE, LOT.T_WRTOUTLAY, LOT.T_OUTLAY
                                                       );
               v_LotVatOutlayAdd := WRTCalcVatOutlayOwn(p_EndDate, v_DATE, p_LnkKind, p_FIID,
                                                        v_WRTOUTLAYDATE, LOT.T_WRTVATOUTLAY, LOT.T_VATOUTLAY
                                                       );
            ELSE
               v_LotWrtOutlayAdd := v_WrtOutlayAddRest;
               v_LotVatOutlayAdd := v_VatOutlayAddRest;
            END IF;

            BEGIN

               SELECT count(1) into v_Count
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID;

               IF( v_Count > 0 ) THEN

                  UPDATE DPMWRTSUM_TMP SET
                    T_WRTOUTLAYADD      = v_LotWrtOutlayAdd,
                    T_WRTOUTLAY         = T_WRTOUTLAY + v_LotWrtOutlayAdd,
                    T_WRTOUTLAYDATE     = p_EndDate,
                    T_VATOUTLAYADD      = v_LotVatOutlayAdd,
                    T_WRTVATOUTLAY      = T_WRTVATOUTLAY + v_LotVatOutlayAdd
                  where T_SUMID = LOT.T_SUMID;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_ADDINCOMEOWN,
                               T_ADDINCOMEOWNADD,
                               T_ADDINCOMEOWNDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST,
                               0,
                               0,
                               0,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME,
                               LOT.T_NOTCARRYDISCOUNT,
                               LOT.T_DISCOUNTDATE,
                               LOT.T_BONUS,
                               LOT.T_BONUSDATE,
                               LOT.T_NOTWRTBONUS,
                               0,
                               LOT.T_ACCOUNTEDDEFDIFF,
                               LOT.T_DEFDIFFDATE,
                               v_LotWrtOutlayAdd,
                               LOT.T_WRTOUTLAY + v_LotWrtOutlayAdd,
                               p_EndDate,
                               v_LotVatOutlayAdd,
                               LOT.T_WRTVATOUTLAY + v_LotVatOutlayAdd,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               LOT.T_ADDINCOMEOWN,
                               0,
                               LOT.T_ADDINCOMEOWNDATE,
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            v_Amount           := v_Amount - LOT.T_AMOUNT;
            v_WrtOutlayAddRest := v_WrtOutlayAddRest - v_LotWrtOutlayAdd;
            v_VatOutlayAddRest := v_VatOutlayAddRest - v_LotVatOutlayAdd;

         END LOOP;

         if v_Amount <> 0 or v_WrtOutlayAddRest <> 0 or v_VatOutlayAddRest <> 0 then
            SetError( WRTOFF_ERROR_20217 ); --Заданы неверные суммы
         end if;

      END;

   BEGIN

     InitError();

     IF ( Rsb_Common.GetRegBoolValue('COMMON\WORK_MODE\USE_COUPON_REFUSE') AND RSI_RSB_FIInstr.FI_HasCoupon(p_FIID) AND (RSI_RSB_FIInstr.FI_IsAvoirissCouponRefuseRight(p_FIID) = 1) ) THEN

       IF p_IsRet = TRUE THEN
         v_IsInterestIncomeCalcDisable := TRUE;
       ELSE
         BEGIN
           SELECT w.t_PaymentRefuse INTO v_PaymentRefuse
             FROM DFIWARNTS_DBT w WHERE w.t_FIID = p_FIID 
                                    AND w.t_IsPartial != CHR(88) 
                                    AND p_EndDate BETWEEN w.t_FirstDate AND w.t_DrawingDate;
           EXCEPTION WHEN NO_DATA_FOUND THEN
             v_PaymentRefuse := CHR(0);
         END;

         IF v_PaymentRefuse = CHR(88) THEN
           v_IsInterestIncomeCalcDisable := TRUE;
         END IF;
       END IF;

     END IF;

     IF p_CalcInterest = true THEN --Начисление процентного дохода

       IF p_IsRet = true THEN --выкуп/зачисление/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_BEGINTERESTDATE BEGINTERESTDATE,
                                   LOT.T_INTERESTDATE INTERESTDATE,
                           CURSOR( SELECT NVL(SUM(T_AMOUNT), 0) P_AMOUNT,
                                          NVL(SUM(T_NKDAMOUNT), 0) P_NKDAMOUNT,
                                          NVL(SUM(T_INTERESTINCOME), 0) P_INTERESTINCOME
                                     FROM DPMWRTSUM_DBT
                                    WHERE T_PARTY           = UnknownParty
                                      AND T_DEPARTMENT      = p_Department
                                      AND T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                      AND T_ENTERDATE      <= p_OperDate
                                      AND T_DATE           <= p_EndDate
                                      AND T_FIID            = p_FIID
                                      AND T_STATE           = PM_WRTSUM_PLACE_OWN
                                      AND T_AMOUNT          > 0
                                      AND T_PORTFOLIO != -2 /*AD*/
                                      AND T_BEGINTERESTDATE = LOT.T_BEGINTERESTDATE
                                      AND T_INTERESTDATE    = LOT.T_INTERESTDATE)
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND LOT.T_STATE = PM_WRTSUM_PLACE_OWN
                         GROUP BY LOT.T_BEGINTERESTDATE, LOT.T_INTERESTDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_BEGINTERESTDATE, v_INTERESTDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO v_AMOUNT, v_NKDAMOUNT, v_INTERESTINCOME;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeInterestIncome;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление расхода

         OPEN GROUPLOTS_cur  FOR  SELECT T_BEGINTERESTDATE as BEGINTERESTDATE,
                                    T_INTERESTDATE  as INTERESTDATE,
                                    NVL(SUM(T_AMOUNT), 0) P_AMOUNT,
                                    NVL(SUM(T_NKDAMOUNT), 0) P_NKDAMOUNT,
                                    NVL(SUM(T_INTERESTINCOME), 0) P_INTERESTINCOME
                               FROM DPMWRTSUM_DBT
                              WHERE T_PARTY       = UnknownParty
                                AND T_DEPARTMENT  = p_Department
                                AND T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
                                AND T_ENTERDATE  <= p_OperDate
                                AND T_DATE       <= p_EndDate
                                AND T_FIID        = p_FIID
                                AND T_STATE       = PM_WRTSUM_PLACE_OWN
                                AND T_AMOUNT      > 0
                                AND T_PORTFOLIO != -2 /*AD*/
                              GROUP BY T_BEGINTERESTDATE, T_INTERESTDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_BEGINTERESTDATE, v_INTERESTDATE, v_AMOUNT, v_NKDAMOUNT, v_INTERESTINCOME;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            ChargeInterestIncome;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcDiscount = true THEN --Начисление дисконтного дохода

       IF p_IsRet = true THEN --выкуп/зачисление/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_BEGDISCOUNTDATE BEGDISCOUNTDATE,
                                   LOT.T_DISCOUNTDATE DISCOUNTDATE,
                           CURSOR (SELECT NVL(SUM(L.T_AMOUNT), 0) P_AMOUNT,
                                          NVL(SUM(L.T_DISCOUNTINCOME), 0) P_DISCOUNTINCOME,
                                          NVL(SUM(L.T_BEGDISCOUNT), 0) P_BEGDISCOUNT
                                     FROM DPMWRTSUM_DBT L
                                    WHERE L.T_PARTY           = UnknownParty
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_BUY_SALE   in(  PM_WRITEOFF_SUM_PLACE, PM_WRTSUM_BUYOUT_OWN)
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_DATE           <= p_EndDate
                                      AND L.T_FIID            = p_FIID
                          /*AD*/ AND  L.T_STATE IN ( PM_WRTSUM_PLACE_OWN,  PM_WRTSUM_BUYOUT_OWN )                       
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_BEGDISCOUNTDATE = LOT.T_BEGDISCOUNTDATE
                                      AND L.T_DISCOUNTDATE    = LOT.T_DISCOUNTDATE
                                      AND L.T_BEGDISCOUNT     > 0)
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND LOT.T_BEGDISCOUNT > 0
                 /*AD*/ AND  LOT.T_STATE IN ( PM_WRTSUM_PLACE_OWN,  PM_WRTSUM_BUYOUT_OWN )                  
                         GROUP BY LOT.T_BEGDISCOUNTDATE, LOT.T_DISCOUNTDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_BEGDISCOUNTDATE, v_DISCOUNTDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO v_AMOUNT, v_DISCOUNTINCOME, v_BEGDISCOUNT;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeDiscountIncome;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление расхода

         OPEN GROUPLOTS_cur FOR  SELECT L.T_BEGDISCOUNTDATE BEGDISCOUNTDATE,
                                    L.T_DISCOUNTDATE DISCOUNTDATE,
                                    NVL(SUM(L.T_AMOUNT), 0) P_AMOUNT,
                                    NVL(SUM(L.T_DISCOUNTINCOME), 0) P_DISCOUNTINCOME,
                                    NVL(SUM(L.T_BEGDISCOUNT), 0) P_BEGDISCOUNT
                               FROM DPMWRTSUM_DBT L
                              WHERE L.T_PARTY           = UnknownParty
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_BUY_SALE   in(  PM_WRITEOFF_SUM_PLACE, PM_WRTSUM_BUYOUT_OWN)
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_DATE           <= p_EndDate
                                AND L.T_FIID            = p_FIID
                    /*AD*/ AND  L.T_STATE IN ( PM_WRTSUM_PLACE_OWN,  PM_WRTSUM_BUYOUT_OWN )        
                                AND L.T_AMOUNT          > 0
                                AND L.T_BEGDISCOUNT     > 0
                         GROUP BY L.T_BEGDISCOUNTDATE, L.T_DISCOUNTDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_BEGDISCOUNTDATE, v_DISCOUNTDATE, v_AMOUNT, v_DISCOUNTINCOME, v_BEGDISCOUNT;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeDiscountIncome;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcBonus = true THEN --Начисление премии

       IF p_IsRet = true THEN --выкуп/зачисление/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_BEGBONUSDATE BEGBONUSDATE,
                                   LOT.T_BONUSDATE BONUSDATE,
                           CURSOR( SELECT NVL(SUM(L.T_AMOUNT), 0) S_AMOUNT,
                                          NVL(SUM(L.T_BONUS), 0) S_BONUS,
                                          NVL(SUM(L.T_BEGBONUS), 0) S_BEGBONUS
                                     FROM DPMWRTSUM_DBT L
                                    WHERE L.T_PARTY           = UnknownParty
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_DATE           <= p_EndDate
                                      AND L.T_FIID            = p_FIID
                                      AND L.T_STATE           = PM_WRTSUM_PLACE_OWN
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_BEGBONUSDATE    = LOT.T_BEGBONUSDATE
                                      AND L.T_BONUSDATE       = LOT.T_BONUSDATE
                                      AND L.T_BEGBONUS        > 0)
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND LOT.T_BEGBONUS > 0
                              AND LOT.T_STATE    = PM_WRTSUM_PLACE_OWN
                         GROUP BY LOT.T_BEGBONUSDATE, LOT.T_BONUSDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_BEGBONUSDATE, v_BONUSDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO v_AMOUNT, v_BONUS, v_BEGBONUS;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeBonus;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление ПДД

         OPEN GROUPLOTS_cur FOR SELECT L.T_BEGBONUSDATE BEGBONUSDATE,
                                    L.T_BONUSDATE BONUSDATE,
                                    NVL(SUM(L.T_AMOUNT), 0) S_AMOUNT,
                                    NVL(SUM(L.T_BONUS), 0) S_BONUS,
                                    NVL(SUM(L.T_BEGBONUS), 0) S_BEGBONUS
                               FROM DPMWRTSUM_DBT L
                              WHERE L.T_PARTY           = UnknownParty
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_DATE           <= p_EndDate
                                AND L.T_FIID            = p_FIID
                                AND L.T_STATE           = PM_WRTSUM_PLACE_OWN
                                AND L.T_AMOUNT          > 0
                                AND L.T_BEGBONUS        > 0
                         GROUP BY L.T_BEGBONUSDATE, L.T_BONUSDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_BEGBONUSDATE, v_BONUSDATE, v_AMOUNT, v_BONUS, v_BEGBONUS;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeBonus;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcDefDiff = true THEN --Начисление отсроченной разницы

        IF p_IsRet = true THEN --выкуп/зачисление/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_BEGDEFDIFFDATE BEGDEFDIFFDATE,
                                   LOT.T_DEFDIFFDATE DEFDIFFDATE,
                           CURSOR (SELECT NVL(SUM(L.T_AMOUNT), 0) S_AMOUNT,
                                          NVL(SUM(L.T_ACCOUNTEDDEFDIFF), 0) S_ACCOUNTEDDEFDIFF,
                                          NVL(SUM(L.T_BEGDEFDIFF), 0) S_BEGDEFDIFF
                                     FROM DPMWRTSUM_DBT L
                                    WHERE L.T_PARTY           = UnknownParty
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_BEGDEFDIFFDATE  = LOT.T_BEGDEFDIFFDATE
                                      AND L.T_FIID            = p_FIID
                                      AND L.T_STATE           = PM_WRTSUM_PLACE_OWN
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_DEFDIFFDATE    = LOT.T_DEFDIFFDATE
                                      AND L.T_BEGDEFDIFF     != 0
                                      )
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND LOT.T_BEGDEFDIFF != 0
                              AND LOT.T_STATE = PM_WRTSUM_PLACE_OWN
                              AND LOT.T_DATE <= p_EndDate
                         GROUP BY LOT.T_BEGDEFDIFFDATE, LOT.T_DEFDIFFDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_BEGDEFDIFFDATE, v_DEFDIFFDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO  v_AMOUNT, v_ACCOUNTEDDEFDIFF, v_BEGDEFDIFF;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeDefDiff;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление расхода

         OPEN GROUPLOTS_cur FOR SELECT L.T_BEGDEFDIFFDATE BEGDEFDIFFDATE,
                                    L.T_DEFDIFFDATE DEFDIFFDATE,
                                    NVL(SUM(L.T_AMOUNT), 0) S_AMOUNT,
                                    NVL(SUM(L.T_ACCOUNTEDDEFDIFF), 0) S_ACCOUNTEDDEFDIFF,
                                    NVL(SUM(L.T_BEGDEFDIFF), 0) S_BEGDEFDIFF
                               FROM DPMWRTSUM_DBT L
                              WHERE L.T_PARTY           = UnknownParty
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_DATE           <= p_EndDate
                                AND L.T_FIID            = p_FIID
                                AND L.T_STATE           = PM_WRTSUM_PLACE_OWN
                                AND L.T_AMOUNT          > 0
                                AND L.T_BEGDEFDIFF      != 0
                         GROUP BY L.T_BEGDEFDIFFDATE, L.T_DEFDIFFDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_BEGDEFDIFFDATE, v_DEFDIFFDATE, v_AMOUNT, v_ACCOUNTEDDEFDIFF, v_BEGDEFDIFF;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeDefDiff;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

     IF p_CalcOutlay = true THEN --Начисление затрат по сделкам

       IF p_IsRet = true THEN --выкуп/зачисление/погашение

         OPEN GROUPLOTS_cur FOR SELECT LOT.T_DATE DATE_,
                                   LOT.T_WRTOUTLAYDATE WRTOUTLAYDATE,
                           CURSOR (SELECT NVL(SUM(L.T_AMOUNT), 0) S_AMOUNT,
                                          NVL(SUM(L.T_WRTOUTLAY), 0) S_WRTOUTLAY,
                                    NVL(SUM(L.T_OUTLAY), 0) S_OUTLAY,
                                    NVL(SUM(L.T_WRTVATOUTLAY), 0) S_WRTVATOUTLAY,
                                    NVL(SUM(L.T_VATOUTLAY), 0) S_VATOUTLAY
                                     FROM DPMWRTSUM_DBT L
                                    WHERE L.T_PARTY           = UnknownParty
                                      AND L.T_DEPARTMENT      = p_Department
                                      AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                      AND L.T_ENTERDATE      <= p_OperDate
                                      AND L.T_FIID            = p_FIID
                                      AND L.T_STATE           = PM_WRTSUM_PLACE_OWN
                                      AND L.T_AMOUNT          > 0
                                      AND L.T_DATE    = LOT.T_DATE
                                      AND L.T_OUTLAY     > 0
                                      )
                             FROM DPMWRTSUM_DBT LOT, DPMWRTLNK_TMP TMP
                            WHERE TMP.T_BUYID = LOT.T_SUMID
                              AND LOT.T_OUTLAY > 0
                              AND LOT.T_STATE = PM_WRTSUM_PLACE_OWN
                              AND LOT.T_DATE <= p_EndDate
                         GROUP BY LOT.T_DATE, LOT.T_WRTOUTLAYDATE;

         LOOP

            FETCH GROUPLOTS_cur INTO v_DATE, v_WRTOUTLAYDATE, LOTS_cur;
            EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                      GROUPLOTS_cur%NOTFOUND IS NULL;

            LOOP

               FETCH LOTS_cur INTO  v_AMOUNT, v_WRTOUTLAY, v_OUTLAY, v_WRTVATOUTLAY, v_VATOUTLAY;
               EXIT WHEN LOTS_cur%NOTFOUND OR
                         LOTS_cur%NOTFOUND IS NULL;

               ChargeOutlay;

            END LOOP;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       ELSE --начисление расхода

         OPEN GROUPLOTS_cur FOR SELECT L.T_DATE DATE_,
                                    L.T_WRTOUTLAYDATE WRTOUTLAYDATE,
                                    NVL(SUM(L.T_AMOUNT), 0) S_AMOUNT,
                                    NVL(SUM(L.T_WRTOUTLAY), 0) S_WRTOUTLAY,
                                    NVL(SUM(L.T_OUTLAY), 0) S_OUTLAY,
                                    NVL(SUM(L.T_WRTVATOUTLAY), 0) S_WRTVATOUTLAY,
                                    NVL(SUM(L.T_VATOUTLAY), 0) S_VATOUTLAY
                               FROM DPMWRTSUM_DBT L
                              WHERE L.T_PARTY           = UnknownParty
                                AND L.T_DEPARTMENT      = p_Department
                                AND L.T_BUY_SALE        = PM_WRITEOFF_SUM_PLACE
                                AND L.T_ENTERDATE      <= p_OperDate
                                AND L.T_DATE           <= p_EndDate
                                AND L.T_FIID            = p_FIID
                                AND L.T_STATE           = PM_WRTSUM_PLACE_OWN
                                AND L.T_AMOUNT          > 0
                                AND L.T_OUTLAY          > 0
                         GROUP BY L.T_DATE, L.T_WRTOUTLAYDATE;

         LOOP

               FETCH GROUPLOTS_cur INTO v_DATE, v_WRTOUTLAYDATE, v_AMOUNT, v_WRTOUTLAY, v_OUTLAY, v_WRTVATOUTLAY, v_VATOUTLAY;
               EXIT WHEN GROUPLOTS_cur%NOTFOUND OR
                         GROUPLOTS_cur%NOTFOUND IS NULL;

               ChargeOutlay;

         END LOOP;

         CLOSE GROUPLOTS_cur;

       END IF;

     END IF;

    IF p_CalcCorr = true and p_IsRet = false THEN
      FOR LotTmp IN (   SELECT Lot.T_DEALID lot_DEALID,
                               TMP.T_DEALID tmp_DEALID,
                               TMP.T_CORRINTTOEIRDATE,
                               TMP.T_INTERESTADD,
                               TMP.T_BONUSADD,
                               TMP.T_DISCOUNTADD,
                               TMP.T_WRTOUTLAYADD,
                               LOT.T_FAIRVALUE,
                               LOT.t_SumID,
                               FIN.T_FACEVALUEFI,
                               LOT.t_DATE,
                               TMP.T_INTERESTINCOME,
                               TMP.T_BONUS,
                               TMP.T_DISCOUNTINCOME,
                               TMP.T_WRTOUTLAY
                          FROM DPMWRTSUM_DBT LOT, DPMWRTSUM_TMP TMP, DFININSTR_DBT FIN
                         WHERE LOT.T_SUMID = TMP.T_SUMID
                           AND LOT.T_PARTY = UnknownParty
                           AND LOT.T_DEPARTMENT = p_Department
                           AND LOT.T_FIID = p_FIID
                           AND LOT.T_STATE = PM_WRTSUM_PLACE_OWN
                           AND LOT.T_AMOUNT > 0
                           AND LOT.T_AMORTCALCKIND = RSB_SECUR.AMORTCALCKIND_EPS
                           AND LOT.T_CORRINTTOEIRDATE <= p_EndDate
                           AND FIN.T_FIID = LOT.T_FIID
                           AND (SELECT COUNT(*) 
                                  FROM DAVOIRISS_DBT AV 
                                  WHERE AV.T_FIID=FIN.T_FIID 
                                    AND AV.T_INCIRCULATIONDATE >= v_CalcCorrLimitDate) > 0 )
      LOOP
      
        v_EIR := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_OWN, LotTmp.lot_DEALID, LotTmp.t_SumID, p_EndDate);
        v_AmortCost := RSB_SECUR.CalcAS_EPS(RSB_SECUR.CALCKIND_OWN, LotTmp.lot_DEALID, LotTmp.t_SumID, p_EndDate, v_EIR);

        v_CorrIntToEIR := RSB_SECUR.CalcCorrectPersentEPS(RSB_SECUR.CALCKIND_OWN,
                                                          LotTmp.TMP_DEALID,
                                                          LotTmp.t_SumID,
                                                          p_EndDate,
                                                          UnknownDate,
                                                          LotTmp.T_INTERESTINCOME,
                                                          LotTmp.T_BONUS,
                                                          LotTmp.T_DISCOUNTINCOME,
                                                          LotTmp.T_WRTOUTLAY,
                                                          LotTmp.T_FAIRVALUE,
                                                          v_EIR
                                                          );
        IF v_CorrIntToEIR IS NULL THEN
          v_CorrIntToEIR := 0;
        ELSE
          v_CorrIntToEIR := RSI_RSB_FIInstr.ConvSum(v_CorrIntToEIR, LotTmp.t_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_EndDate, 1);
          v_CorrIntToEIR := ROUND(v_CorrIntToEIR, 2);
        END IF;

        UPDATE DPMWRTSUM_TMP
           SET T_CORRINTTOEIR = v_CorrIntToEIR,
               T_CORRINTTOEIRDATE = p_EndDate,
               T_AMORTCOST = v_AmortCost,
               T_EFFECTINTERESTRATE = v_EIR
         WHERE t_SumID = LotTmp.t_SumID;
      END LOOP;
    END IF;

    IF p_CalcAddInc = TRUE AND RSI_RSB_FIInstr.FI_IsBIO(p_FIID) <> 0 THEN

      SELECT NVL(SUM(LOT.T_AMOUNT), 0) as SumAmount
        INTO v_SumAmount
        FROM DPMWRTSUM_DBT LOT
       WHERE LOT.T_PARTY = UnknownParty
         AND LOT.T_DEPARTMENT = p_Department
         AND LOT.T_FIID = p_FIID
         AND LOT.T_STATE = PM_WRTSUM_PLACE_OWN
         AND LOT.T_AMOUNT > 0
         AND (v_IsRet = 0 OR EXISTS(SELECT 1
                                      FROM DPMWRTLNK_TMP LTMP
                                     WHERE LTMP.T_BUYID = LOT.T_SUMID
                                   ));

      IF v_SumAmount > 0 THEN

        BEGIN
          SELECT FR.T_ONEITEMFV, FR.T_CURRENCY
            INTO v_BioPFI, v_BioPFICurrency
            FROM DBIOFRVAL_DBT FR
           WHERE FR.T_FIID = p_FIID
             AND FR.T_DATE = (SELECT MAX(FR1.T_DATE) FROM DBIOFRVAL_DBT FR1 WHERE FR1.T_FIID = FR.T_FIID AND FR1.T_DATE <= p_EndDate);

          EXCEPTION
            WHEN OTHERS THEN v_BioPFI := NULL;
        END;

        IF v_BioPFI IS NOT NULL THEN

          v_NewSumAddIncome := ROUND(RSI_RSB_FIInstr.ConvSum(v_SumAmount*v_BioPFI, v_BioPFICurrency, RSI_RSB_FIInstr.NATCUR, p_EndDate, 1), 2);

          v_RestAmount          := v_SumAmount;
          v_RestNewSumAddIncome := v_NewSumAddIncome;

          FOR LOT IN (SELECT LOT.*
                            FROM DPMWRTSUM_DBT LOT
                           WHERE LOT.T_PARTY = UnknownParty
                             AND LOT.T_DEPARTMENT = p_Department
                             AND LOT.T_FIID = p_FIID
                             AND LOT.T_STATE = PM_WRTSUM_PLACE_OWN
                             AND LOT.T_AMOUNT > 0
                             AND (v_IsRet = 0 OR EXISTS(SELECT 1
                                                          FROM DPMWRTLNK_TMP LTMP
                                                         WHERE LTMP.T_BUYID = LOT.T_SUMID
                                                       ))
                         )
          LOOP

            IF v_RestAmount = LOT.t_Amount THEN
              v_NewLotAddIncome := v_RestNewSumAddIncome;
            ELSE
              v_NewLotAddIncome := ROUND(RSI_RSB_FIInstr.ConvSum(LOT.t_Amount*v_BioPFI, v_BioPFICurrency, RSI_RSB_FIInstr.NATCUR, p_EndDate, 1), 2);
            END IF;

            v_LotAddIncomeAdd := v_NewLotAddIncome - LOT.t_AddIncomeOwn;

            BEGIN

               SELECT count(1) into v_ExistTmpLot
                 FROM DPMWRTSUM_TMP TMP
                WHERE TMP.T_SUMID = LOT.T_SUMID;

               IF( v_ExistTmpLot > 0 ) THEN

                  UPDATE DPMWRTSUM_TMP SET
                    T_ADDINCOMEOWNADD  = v_LotAddIncomeAdd,
                    T_ADDINCOMEOWN     = v_NewLotAddIncome,
                    T_ADDINCOMEOWNDATE = p_EndDate
                  WHERE T_SUMID = LOT.T_SUMID;

               ELSE

                  INSERT INTO DPMWRTSUM_TMP
                             (
                               T_SUMID,
                               T_KIND,
                               T_AMOUNT,
                               T_COST,
                               T_BALANCECOST,
                               T_INTERESTADD,
                               T_BONUSADD,
                               T_DISCOUNTADD,
                               T_INTERESTINCOME,
                               T_NOTCARRYINTEREST,
                               T_INTERESTDATE,
                               T_BEGDISCOUNTDATE,
                               T_BEGBONUSDATE,
                               T_DISCOUNTINCOME,
                               T_NOTCARRYDISCOUNT,
                               T_DISCOUNTDATE,
                               T_BONUS,
                               T_BONUSDATE,
                               T_NOTWRTBONUS,
                               T_DEFDIFFADD,
                               T_ACCOUNTEDDEFDIFF,
                               T_DEFDIFFDATE,
                               T_WRTOUTLAYADD,
                               T_WRTOUTLAY,
                               T_WRTOUTLAYDATE,
                               T_VATOUTLAYADD,
                               T_WRTVATOUTLAY,
                               T_CORRVALUE,
                               T_CORRDATE,
                               T_AMORTCOST,
                               T_CORRINTTOEIR,
                               T_CORRINTTOEIRDATE,
                               T_WRTCORRINTTOEIR,
                               T_ESTRESERVEADD,
                               T_CORRESTRESERVEADD,
                               T_RESERVAMOUNTADD,
                               T_INCOMERESERVADD,
                               T_PORTFOLIO,
                               T_STATE,
                               T_OVERAMOUNT,
                               T_OVERAMOUNTADD,
                               T_DEALID,
                               T_BEGDEFDIFFDATE,
                               T_ADDINCOMEOWN,
                               T_ADDINCOMEOWNADD,
                               T_ADDINCOMEOWNDATE,
                               T_HEDGCORR,
                               T_HEDGCORRDATE,
                               T_AMORTHEDGCORR,
                               T_AMORTHEDGCORRDATE
                             )
                      VALUES (
                               LOT.T_SUMID,
                               0,
                               LOT.T_AMOUNT,
                               LOT.T_COST,
                               LOT.T_BALANCECOST,
                               0,
                               0,
                               0,
                               LOT.T_INTERESTINCOME,
                               LOT.T_NOTCARRYINTEREST,
                               LOT.T_INTERESTDATE,
                               LOT.T_BEGDISCOUNTDATE,
                               LOT.T_BEGBONUSDATE,
                               LOT.T_DISCOUNTINCOME,
                               LOT.T_NOTCARRYDISCOUNT,
                               LOT.T_DISCOUNTDATE,
                               LOT.T_BONUS,
                               LOT.T_BONUSDATE,
                               LOT.T_NOTWRTBONUS,
                               0,
                               LOT.T_ACCOUNTEDDEFDIFF,
                               LOT.T_DEFDIFFDATE,
                               0,
                               LOT.T_WRTOUTLAY,
                               LOT.T_WRTOUTLAYDATE,
                               0,
                               LOT.T_WRTVATOUTLAY,
                               LOT.T_CORRVALUE,
                               LOT.T_CORRDATE,
                               LOT.T_AMORTCOST,
                               LOT.T_CORRINTTOEIR,
                               LOT.T_CORRINTTOEIRDATE,
                               0,
                               0,
                               0,
                               0,
                               0,
                               LOT.T_PORTFOLIO,
                               LOT.T_STATE,
                               LOT.T_OVERAMOUNT,
                               0,
                               LOT.T_DEALID,
                               LOT.T_BEGDEFDIFFDATE,
                               v_NewLotAddIncome,
                               v_LotAddIncomeAdd,
                               p_EndDate,
                               LOT.T_HEDGCORR,
                               LOT.T_HEDGCORRDATE,
                               LOT.T_AMORTHEDGCORR,
                               LOT.T_AMORTHEDGCORRDATE
                             );
               END IF;

            END;

            v_RestAmount          := v_RestAmount          - LOT.T_AMOUNT;
            v_RestNewSumAddIncome := v_RestNewSumAddIncome - v_NewLotAddIncome;

          END LOOP;

        END IF;

      END IF;

    END IF;

   END;--RSI_WRTChargeExpToOwnLotsTMP

   --Выполняет вычисление сумм доходов по лоту покупки через временную таблицу.
   --Рекомендуется не увлекаться вызовом этой функции, т.к. она может быть медленной, ибо в процессе расчетов начисляет во временную таблицу по целой группе лотов,
   --  чтобы взять потом сумму доначисления лишь по одному требуемому.
   --Использовать её если действительно нужны суммы доначислений лишь по одному лоту и не предполагается потом искать сумму еще по совокупности схожих лотов.
   PROCEDURE RSI_WRTCalcIncomeOnLotTMP( p_SumID              IN NUMBER, -- лот
                                        p_CalcDate           IN DATE,   -- Дата расчетов
                                        p_CalcInterest       IN BOOLEAN, -- Начисление процентного дохода
                                        p_CalcDiscount       IN BOOLEAN, -- Начисление дисконтного дохода
                                        p_CalcBonus          IN BOOLEAN, -- Начисление премии
                                        p_CalcDefDiff        IN BOOLEAN, -- Начисление отсроченной разницы
                                        p_CalcCorrIntToEIR   IN BOOLEAN, -- Начисление корректировки % до ЭПС
                                        p_LinkKind           IN NUMBER DEFAULT 0, -- Константа вида расчёта
                                        p_InterestAdd        OUT NUMBER, -- доначисленный ПД
                                        p_DiscountAdd        OUT NUMBER, -- доначисленный ДД
                                        p_BonusAdd           OUT NUMBER, -- доначисленная премия
                                        p_DefDiffAdd         OUT NUMBER, -- доначисленная отсроченная разница
                                        p_CorrIntToEIRAdd    OUT NUMBER  -- доначисленная корректировка % до ЭПС
                                      )
   IS
     v_Lot       DPMWRTSUM_DBT%ROWTYPE;
     v_WrtSumTmp DPMWRTSUM_TMP%ROWTYPE;
     v_Method    NUMBER;

   BEGIN

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     p_InterestAdd     := 0;
     p_DiscountAdd     := 0;
     p_BonusAdd        := 0;
     p_DefDiffAdd      := 0;
     p_CorrIntToEIRAdd := 0;

     BEGIN

        SELECT * into v_Lot
          FROM DPMWRTSUM_DBT
         WHERE T_SUMID = p_SumID;

     EXCEPTION
        WHEN OTHERS THEN return;
     END;

     INSERT INTO DPMWRTLNK_TMP
                ( T_ID,
                  T_BUYID,
                  T_AMOUNT )
         VALUES ( 1,
                  p_SumID,
                  v_Lot.T_AMOUNT
                  );

     v_Method := GetAmortizationMethod( v_Lot.t_Party, v_Lot.t_Contract );

     --Выполнить начисление во временную таблицу
     --Фактически - начисление по всем лотам из группы со схожими параметрами начисления, как и для данного. Сохранение в DPMWRTLNK_TMP - лишь для общности реализации, чтобы не делать 3-ю ветку.
     RSI_WRTChargeIncomToLotsTMP(true, p_CalcDate, p_CalcDate, v_Lot.T_FIID, v_Lot.T_Department, -1, -1, -1, -1, -1, v_Lot.T_PARTY, v_Lot.T_CONTRACT,
                                 p_CalcInterest,  p_CalcDiscount, p_CalcBonus, p_CalcDefDiff, p_CalcCorrIntToEIR, v_Method, v_Lot.T_TRUST = 'X', p_LinkKind);

     IF( p_CalcInterest = true or p_CalcBonus = true or p_CalcDiscount = true or p_CalcDefDiff = true or p_CalcCorrIntToEIR = true ) THEN

        BEGIN
          SELECT TMP.* into v_WrtSumTmp
            FROM DPMWRTSUM_TMP TMP
           WHERE TMP.T_SUMID = v_Lot.T_SUMID
             AND TMP.T_KIND = 0;
        EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20239 );
        END;

        p_InterestAdd     := v_WrtSumTmp.T_InterestAdd;
        p_BonusAdd        := v_WrtSumTmp.T_BonusAdd;
        p_DiscountAdd     := v_WrtSumTmp.T_DiscountAdd;
        p_DefDiffAdd      := v_WrtSumTmp.T_ACCOUNTEDDEFDIFF;
        p_CorrIntToEIRAdd := -v_WrtSumTmp.T_WRTCORRINTTOEIR;

     END IF;

   END;--RSI_WRTCalcIncomeOnLotTMP

   --Выполняет вычисление сумм расходов по лоту/лотам размещения через временную таблицу.
   --Рекомендуется не увлекаться вызовом этой функции для одного лота, т.к. она может быть медленной, ибо в процессе расчетов начисляет во временную таблицу по целой группе лотов,
   --  чтобы взять потом сумму доначисления лишь по одному требуемому.
   --Использовать её если действительно нужны суммы доначислений лишь по одному лоту и не предполагается потом искать сумму еще по совокупности схожих лотов.
   PROCEDURE RSI_WRTCalcExpenseOnOwnLotTMP( p_SumID              IN NUMBER, -- лот. Если указано 0, то считаем для всех размещенных лотов
                                            p_FIID IN NUMBER, --Идентификатор ц/б
                                            p_Department IN NUMBER, --Филиал
                                            p_CalcDate           IN DATE,   -- Дата расчетов
                                            p_CalcInterest       IN NUMBER, -- Начисление процентного дохода
                                            p_CalcDiscount       IN NUMBER, -- Начисление дисконтного дохода
                                            p_CalcBonus          IN NUMBER, -- Начисление премии
                                            p_CalcDefDiff        IN NUMBER, -- Начисление отложенной разницы
                                            p_CalcOutlay         IN NUMBER, -- Начисление существенных затрат
                                            p_LinkKind           IN NUMBER DEFAULT 0, -- Константа вида расчёта
                                            p_Coupon             IN VARCHAR2 DEFAULT NULL, -- номер купона
                                            p_InterestAdd        OUT NUMBER, -- доначисленный ПД
                                            p_DiscountAdd        OUT NUMBER, -- доначисленный ДД
                                            p_BonusAdd           OUT NUMBER, -- доначисленная премия
                                            p_DefDiffAdd         OUT NUMBER, -- доначисленная отложенная разница
                                            p_OutlayAdd          OUT NUMBER, -- доначисленные существенные затраты
                                            p_VatOutlayAdd       OUT NUMBER  -- доначисленный НДС по существенным затратам
                                          )
   IS
     v_Lot       DPMWRTSUM_DBT%ROWTYPE;
     v_WrtSumTmp DPMWRTSUM_TMP%ROWTYPE;

     v_FIID NUMBER;
     v_Department NUMBER;

   BEGIN

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     p_InterestAdd  := 0;
     p_DiscountAdd  := 0;
     p_BonusAdd     := 0;
     p_DefDiffAdd   := 0;
     p_OutlayAdd    := 0;
     p_VatOutlayAdd := 0;


     IF p_SumID <> 0 THEN
        BEGIN

           SELECT * into v_Lot
             FROM DPMWRTSUM_DBT
            WHERE T_SUMID = p_SumID;

        EXCEPTION
           WHEN OTHERS THEN return;
        END;

        v_FIID := v_Lot.t_FIID;
        v_Department := v_Lot.t_Department;

        INSERT INTO DPMWRTLNK_TMP
                   ( T_ID,
                     T_BUYID,
                     T_AMOUNT )
            VALUES ( WRTSUMTMP_KIND_PD,
                     p_SumID,
                     v_Lot.T_AMOUNT
                     );
     ELSE

        v_FIID := p_FIID;
        v_Department := p_Department;

        INSERT INTO DPMWRTLNK_TMP
                        ( T_ID,
                          T_BUYID,
                          T_AMOUNT )
                 (SELECT ROWNUM, LOT.T_SUMID, LOT.T_AMOUNT
                     FROM DPMWRTSUM_DBT LOT
                    WHERE LOT.T_PARTY = UnknownParty
                    AND LOT.T_DEPARTMENT  = v_Department
                    AND LOT.T_BUY_SALE    = PM_WRITEOFF_SUM_PLACE
                    AND LOT.T_DATE       <= p_CalcDate
                    AND LOT.T_FIID        = v_FIID
                    AND LOT.T_STATE       = PM_WRTSUM_PLACE_OWN
                    AND LOT.T_AMOUNT      > 0);
     END IF;

     --Выполнить начисление во временную таблицу
     --Фактически - начисление по всем лотам из группы со схожими параметрами начисления, как и для данного. Сохранение в DPMWRTLNK_TMP - лишь для общности реализации, чтобы не делать отдельную ветку.
     RSI_WRTChargeExpToOwnLotsTMP(true, p_CalcDate, p_CalcDate, v_FIID, v_Department,
                                  p_CalcInterest<>0, p_CalcDiscount<>0, p_CalcBonus<>0, p_CalcDefDiff<>0, p_CalcOutlay<>0, false, p_LinkKind, p_Coupon, false);

     IF( p_CalcInterest <> 0 or p_CalcDiscount <> 0 or p_CalcBonus <> 0 or p_CalcDefDiff <> 0 or p_CalcOutlay <> 0 ) THEN

       IF p_SumID <> 0 THEN
         SELECT NVL(SUM(TMP.T_InterestAdd), 0),
            NVL(SUM(TMP.T_DiscountAdd), 0),
            NVL(SUM(TMP.T_BonusAdd), 0),
            NVL(SUM(TMP.T_DefDiffAdd), 0),
            NVL(SUM(TMP.T_WrtOutlayAdd), 0),
            NVL(SUM(TMP.T_VatOutlayAdd), 0)
            INTO p_InterestAdd, p_DiscountAdd, p_BonusAdd, p_DefDiffAdd, p_OutlayAdd, p_VatOutlayAdd
            FROM DPMWRTSUM_TMP TMP
            WHERE TMP.T_SUMID = p_SumID;
       ELSE

          SELECT NVL(SUM(TMP.T_InterestAdd), 0),
            NVL(SUM(TMP.T_DiscountAdd), 0),
            NVL(SUM(TMP.T_BonusAdd), 0),
            NVL(SUM(TMP.T_DefDiffAdd), 0),
            NVL(SUM(TMP.T_WrtOutlayAdd), 0),
            NVL(SUM(TMP.T_VatOutlayAdd), 0)
            INTO p_InterestAdd, p_DiscountAdd, p_BonusAdd, p_DefDiffAdd, p_OutlayAdd, p_VatOutlayAdd
            FROM DPMWRTSUM_TMP TMP
            WHERE TMP.T_SUMID IN (SELECT LNK.T_BUYID FROM DPMWRTLNK_TMP LNK);
       END IF;
     END IF;

   END;--RSI_WRTCalcExpenseOnOwnLotTMP

   ----- Выполняет начисление доходов на лоты в операции начисления ПДД.
   PROCEDURE RSI_WRTChargeIncomToLots( p_OperDate         IN DATE,   -- Дата
                                       p_EndDate          IN DATE,
                                       p_FIID             IN NUMBER, -- Выпуск
                                       p_Department       IN NUMBER, -- Филиал
                                       p_ID_Operation     IN NUMBER, -- Операция и шаг, на которых выполняется сохранение
                                       p_ID_Step          IN NUMBER,
                                       p_Party            IN NUMBER,
                                       p_Contract         IN NUMBER,
                                       p_CalcCorrIntToEIR IN NUMBER
                                     )
   IS
      v_IsResponsible       NUMBER;
      v_CalcDiscount        NUMBER := 0;
      v_CalcInterest        NUMBER := 0;
      v_CalcBonus           NUMBER := 0;
      v_Action              NUMBER := 0;
      v_AmortizationMethod  NUMBER := 0;
      v_prevSumID           NUMBER := 0;
      v_WrtBonus            NUMBER := 0;
      v_CalcDefDiff         NUMBER := 0;
      v_CalcCorrIntToEIR    NUMBER := 0;
      v_WrtSumTmp           DPMWRTSUM_TMP%ROWTYPE;
      v_Termless            CHAR;
      v_EndDate             DATE;
      v_DrawingDate         DATE;
      v_IsOffer             NUMBER;
      v_OfferDate           DATE;

      TYPE LotsCurTyp IS REF CURSOR;
      Lots LotsCurTyp;

   BEGIN
      InitError();
      
      IF (p_Party != UnknownParty) THEN  
          RETURN;
      END IF;
      
      v_AmortizationMethod := GetAmortizationMethod( p_Party, p_Contract );

      v_DrawingDate := rsb_secur.SC_GetTopCalcDate(RSB_SECUR.CALCKIND_AVR, p_FIID, p_EndDate, v_IsOffer, v_Termless, v_OfferDate);
      if( v_AmortizationMethod = PM_WRITEOFF_FIFO and v_Termless = 'X' and v_IsOffer = 1 ) then
         v_DrawingDate := v_OfferDate;
      end if;

      if v_DrawingDate IS NULL or v_DrawingDate = UnknownDate then
         SetError( WRTOFF_ERROR_20270, to_char(p_FIID) );
      end if;
      --если Dнач>Dпог, то Dнач=Dпог
      v_EndDate := CASE WHEN p_EndDate > v_DrawingDate THEN v_DrawingDate ELSE p_EndDate END;

      IF (p_OperDate < RsbSessionData.curdate) THEN
        IF (WRTAreChangesAfterEndDate(p_Department, p_FIID, p_Party, p_Contract, KINDPORT_TRADE/*ТП*/, KINDPORT_SALE/*ППР*/, KINDPORT_RETIRE/*ПУДП*/, -1, -1, p_OperDate, v_EndDate) = True) THEN
          SetError( WRTOFF_ERROR_20220 );
        END IF;
      END IF;

      v_CalcDiscount     := WRTNeedChargeIncome( p_FIID );
      v_CalcInterest     := WRTNeedChargeInterestIncome( p_FIID );
      v_CalcBonus        := v_CalcDiscount; 
      v_CalcDefDiff      := 1; 
      v_CalcCorrIntToEIR := p_CalcCorrIntToEIR;

      if( v_CalcDiscount = 0 and v_CalcInterest = 0 and v_CalcBonus = 0 and v_CalcDefDiff = 0 and v_CalcCorrIntToEIR = 0) then
         SetError( WRTOFF_ERROR_20209 ); -- по выпуску не начисляется доход
      end if;

      v_Action := PM_WRT_UPDTMODE_INCPDD;

      IF( (v_AmortizationMethod = PM_WRITEOFF_AVERAGE) AND (v_CalcDiscount = 1 OR v_CalcBonus = 1 OR v_CalcDefDiff = 1 OR v_CalcCorrIntToEIR = 1) ) THEN
         RSI_WRTAverageLots( p_OperDate, v_EndDate, p_FIID, p_Department, p_Party, p_Contract, p_ID_Operation, p_ID_Step, v_Action, v_CalcDiscount, v_CalcBonus, v_CalcDefDiff, v_CalcCorrIntToEIR);

         v_Action := PM_WRT_UPDTMODE_UNDEF;
      END IF;

      --Удалить все записи из DPMWRTSUM_TMP
      delete from DPMWRTSUM_TMP;

      IF v_AmortizationMethod = PM_WRITEOFF_AVERAGE AND Rsb_Common.GetRegBoolValue('SECUR\ТОЛЬКО ОСРЕДНЕНИЕ ПРИ НАЧИСЛ.') = true THEN
        return;
      END IF;

      --Выполнить начисление во временную таблицу
      RSI_WRTChargeIncomToLotsTMP (false, p_OperDate, v_EndDate, p_FIID, p_Department, KINDPORT_TRADE/*ТП*/, KINDPORT_SALE/*ППР*/, KINDPORT_RETIRE/*ПУДП*/, -1, -1, p_Party,
                                   p_Contract, v_CalcInterest=1, v_CalcDiscount=1, v_CalcBonus=1, v_CalcDefDiff=1, v_CalcCorrIntToEIR=1, v_AmortizationMethod);
      v_prevSumID := 0;

      OPEN Lots FOR SELECT TMP.*
                      FROM DPMWRTSUM_TMP TMP
                     ORDER BY TMP.T_SUMID;

      LOOP

         FETCH Lots INTO v_WrtSumTmp;
         EXIT WHEN Lots%NOTFOUND OR
                   Lots%NOTFOUND IS NULL;

         IF v_Action <> PM_WRT_UPDTMODE_UNDEF THEN
           IF (v_prevSumID <> v_WrtSumTmp.T_SUMID) THEN
             RSI_WRTSaveLot (v_WrtSumTmp.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, v_Action);
           END IF;
         END IF;

           UPDATE DPMWRTSUM_DBT L
            SET L.T_INTERESTINCOME   = v_WrtSumTmp.T_INTERESTINCOME,
                L.T_INTERESTDATE     = v_WrtSumTmp.T_INTERESTDATE,
                L.T_NOTCARRYINTEREST = v_WrtSumTmp.T_NOTCARRYINTEREST,
                L.T_BALANCECOST      = v_WrtSumTmp.T_BALANCECOST,
                L.T_BONUS            = v_WrtSumTmp.T_BONUS,
                L.T_NOTWRTBONUS      = (case when v_WrtBonus = 1 then 0 else v_WrtSumTmp.T_NOTWRTBONUS end),
                L.T_BONUSDATE        = v_WrtSumTmp.T_BONUSDATE,
                L.T_COST             = v_WrtSumTmp.T_COST,
                L.T_BEGBONUSDATE     = v_WrtSumTmp.T_BEGBONUSDATE,
                L.T_DISCOUNTINCOME   = v_WrtSumTmp.T_DISCOUNTINCOME,
                L.T_DISCOUNTDATE     = v_WrtSumTmp.T_DISCOUNTDATE,
                L.T_NOTCARRYDISCOUNT = v_WrtSumTmp.T_NOTCARRYDISCOUNT,
                L.T_BEGDISCOUNTDATE  = v_WrtSumTmp.T_BEGDISCOUNTDATE,
                L.T_ACCOUNTEDDEFDIFF = v_WrtSumTmp.T_ACCOUNTEDDEFDIFF,
                L.T_DEFDIFFDATE      = v_WrtSumTmp.T_DEFDIFFDATE,
                L.T_BEGDEFDIFFDATE   = v_WrtSumTmp.T_BEGDEFDIFFDATE,
                L.T_CORRINTTOEIR     = v_WrtSumTmp.T_CORRINTTOEIR,
                L.T_CORRINTTOEIRDATE = v_WrtSumTmp.T_CORRINTTOEIRDATE,
                L.T_EFFECTINTERESTRATE = (case when v_WrtSumTmp.T_EFFECTINTERESTRATE NOT IN (-1.0, 0.0) then v_WrtSumTmp.T_EFFECTINTERESTRATE else L.T_EFFECTINTERESTRATE end)

          WHERE L.T_SUMID = v_WrtSumTmp.T_SUMID;


         v_prevSumID := v_WrtSumTmp.T_SUMID;
      END LOOP;

      CLOSE Lots;

   END;--RSI_WRTChargeIncomToLots

   ----- Выполняет начисление расходов на лоты в операции начисления расхода.
   PROCEDURE RSI_ChargeExpenseToOwnLotsTMP( p_OperDate     IN DATE,   -- Дата
                                            p_EndDate      IN DATE,   -- Дата окончания периода начисления
                                            p_FIID         IN NUMBER, -- Выпуск
                                            p_Department   IN NUMBER, -- Филиал
                                            p_CalcInterest IN NUMBER DEFAULT 1, -- Начисление процентного расхода
                                            p_CalcDiscount IN NUMBER DEFAULT 1, -- Начисление дисконтного расхода
                                            p_CalcBonus    IN NUMBER DEFAULT 1, -- Начисление премии
                                            p_CalcDefDiff  IN NUMBER DEFAULT 1, -- Начисление отсроченной разницы
                                            p_CalcOutlay   IN NUMBER DEFAULT 1, -- Начисление затрат по договору
                                            p_CalcCorr     IN NUMBER DEFAULT 1, -- Корректировка стоимости
                                            p_CalcAddInc   IN NUMBER DEFAULT 0  -- Начисление доп. дохода по БИО
                                          )
   IS
      v_CalcDiscount        NUMBER := 0;
      v_CalcInterest        NUMBER := 0;
      v_CalcBonus           NUMBER := 0;
      v_CalcDefDiff         NUMBER := 0;
      v_CalcOutlay          NUMBER := 0;
      v_WrtSumTmp           DPMWRTSUM_TMP%ROWTYPE;
      v_CalcCorr            NUMBER := 0;
      v_CalcAddInc          NUMBER := 0;  

      TYPE LotsCurTyp IS REF CURSOR;
      Lots LotsCurTyp;

   BEGIN
      InitError();

      IF (p_OperDate < RsbSessionData.curdate) THEN
        IF( WRTAreChangesAfterDateOwn( p_Department,
                                       p_FIID,
                                       p_OperDate,
                                       UnknownTime,
                                       p_EndDate
                                     ) = True ) THEN
          SetError( WRTOFF_ERROR_20220 );
        END IF;
      END IF;

      --Удалить все записи из DPMWRTSUM_TMP
      delete from DPMWRTSUM_TMP;

      IF p_CalcDiscount = 1 THEN
         v_CalcDiscount := WRTNeedChargeIncome( p_FIID );
      END IF;

      if( p_CalcInterest = 1) then
         v_CalcInterest := WRTNeedChargeInterestIncome( p_FIID );
      end if;

      if( p_CalcBonus = 1) then
         v_CalcBonus    := WRTNeedChargeBonus( p_FIID );
      end if;

      if( p_CalcDefDiff = 1) then
         v_CalcDefDiff  := p_CalcDefDiff;
      end if;

      if( p_CalcOutlay = 1) then
         v_CalcOutlay   := p_CalcOutlay;
      end if;

      if( p_CalcAddInc = 1) then
         v_CalcAddInc   := p_CalcAddInc;
      end if;

      if( v_CalcDiscount = 0 and v_CalcInterest = 0 and v_CalcBonus = 0 and v_CalcDefDiff = 0 and v_CalcOutlay = 0 and v_CalcAddInc = 0) then
         SetError( WRTOFF_ERROR_20256 ); -- по выпуску не начисляется расход
      end if;

      if( p_CalcCorr = 1) then
         v_CalcCorr   := p_CalcCorr;
      end if;

      --Удалить все записи из DPMWRTSUM_TMP
      delete from DPMWRTSUM_TMP;

      --Выполнить начисление во временную таблицу
      RSI_WRTChargeExpToOwnLotsTMP (false, p_OperDate, p_EndDate, p_FIID, p_Department,
                                    v_CalcInterest=1, v_CalcDiscount=1, v_CalcBonus=1,
                                    v_CalcDefDiff=1, v_CalcOutlay=1, v_CalcCorr=1, 0, NULL, v_CalcAddInc=1);

   END;--RSI_ChargeExpenseToOwnLotsTMP


  ----- Выполняет начисление расходов на лоты в операции начисления расхода.
  PROCEDURE RSI_SaveChargeExpenseToOwnLots ( p_OperDate       IN DATE,
                                             p_ID_Operation   IN NUMBER,
                                             p_ID_Step        IN NUMBER
                                           )
  IS
  BEGIN
    FOR TMP IN (SELECT * FROM DPMWRTSUM_TMP TMP ORDER BY TMP.T_SUMID)
    LOOP
      RSI_WRTSaveLot (TMP.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_INCPDD);

      UPDATE DPMWRTSUM_DBT LOT
         SET LOT.T_INTERESTINCOME   = TMP.T_INTERESTINCOME,
             LOT.T_INTERESTDATE     = TMP.T_INTERESTDATE,
             LOT.T_DISCOUNTINCOME   = TMP.T_DISCOUNTINCOME,
             LOT.T_DISCOUNTDATE     = TMP.T_DISCOUNTDATE,
             LOT.T_BONUS            = TMP.T_BONUS,
             LOT.T_BONUSDATE        = TMP.T_BONUSDATE,
             LOT.T_ACCOUNTEDDEFDIFF = TMP.T_ACCOUNTEDDEFDIFF,
             LOT.T_DEFDIFFDATE      = TMP.T_DEFDIFFDATE,
             LOT.T_WRTOUTLAY        = TMP.T_WRTOUTLAY,
             LOT.T_WRTVATOUTLAY     = TMP.T_WRTVATOUTLAY,
             LOT.T_WRTOUTLAYDATE    = TMP.T_WRTOUTLAYDATE,
             LOT.T_AMORTCOST        = TMP.T_AMORTCOST,
             LOT.T_CORRINTTOEIR     = TMP.T_CORRINTTOEIR,
             LOT.T_CORRINTTOEIRDATE = TMP.T_CORRINTTOEIRDATE,
             LOT.T_AMORTCOSTDATE    = (CASE WHEN LOT.T_CORRINTTOEIRDATE != TMP.T_CORRINTTOEIRDATE THEN TMP.T_CORRINTTOEIRDATE ELSE LOT.T_AMORTCOSTDATE END),
             LOT.T_EFFECTINTERESTRATE = (CASE WHEN TMP.T_EFFECTINTERESTRATE NOT IN (-1.0, 0.0) THEN TMP.T_EFFECTINTERESTRATE ELSE LOT.T_EFFECTINTERESTRATE END),
             LOT.T_ADDINCOMEOWN     = TMP.T_ADDINCOMEOWN,
             LOT.T_ADDINCOMEOWNDATE = TMP.T_ADDINCOMEOWNDATE
       WHERE LOT.T_SUMID = TMP.T_SUMID;

    END LOOP;

  END; --RSI_WRTSaveChargeExpenseToOwnLots

   ----- Функция для вычисления доли дисконта в ЧП
   FUNCTION WRTCalcSumPart( p_FIID         IN NUMBER,    -- ц/б
                            p_Partly       IN VARCHAR2,  -- Номер ЧП.
                            p_Sum0         IN NUMBER,    -- Остаток начальной суммыго дисконта (дисконта, премии, отсроченной разницы)
                            p_BuyDate      IN DATE       -- Дата исходной покупки
                          ) RETURN NUMBER DETERMINISTIC
   IS
      v_Rate NUMBER := 0;
   BEGIN
      v_Rate := RSI_RSB_FIInstr.FI_GetPartialPersentByName( p_FIID, p_Partly );

      RETURN p_Sum0 * v_Rate / (100. - RSI_RSB_FIInstr.FI_GetPartialPersent( p_FIID, p_BuyDate ));
   END;--WRTCalcSumPart

   ----- вычисление сумм дохода по ЧП на лот
   PROCEDURE RSI_WRTCalcPartialIncome( p_SumID                      IN NUMBER,    -- Лот  Репо 2 ч.
                                       p_Partly                     IN VARCHAR2,  -- Номер ЧП.
                                       p_CalcDate                   IN DATE,      -- Дата начисления
                                       p_CurSum                  IN OUT NUMBER,   -- Распределяемая сумма дохода ЧП по сделке
                                       p_CurAmount               IN OUT NUMBER,   -- Распределяемое количество по сделке
                                       p_Portfolio                 OUT NUMBER,    -- Исходный портфель (из которого зачислен лот)
                                       p_IncomeSum                 OUT NUMBER,    -- Сумма дохода по ЧП по лоту
                                       p_DiscountIncomeSum         OUT NUMBER,    -- Доля дисконта Sдоля_дисконта)
                                       p_DiscountIncomeAdd         OUT NUMBER,    -- Доначисленный ДД (SдоначДД)
                                       p_NewCost                   OUT NUMBER,    -- Новая чистая стоимость
                                       p_NewBalanceCost            OUT NUMBER,    -- Новая текущая стоимость
                                       p_NewOutlay                 OUT NUMBER,    -- Новые затраты
                                       p_NewDiscountIncome         OUT NUMBER,    -- Новый ДД
                                       p_Discount0_korr            OUT NUMBER,    -- Коррекция дисконта (использовать как слагаемое для суммы в проводке)
                                       p_NewDiscount0              OUT NUMBER,    -- Новый начальный дисконт (занести в лот)
                                       p_InterestIncomeAdd         OUT NUMBER,    -- Доначисленный ПД
                                       p_NewInterestIncome         OUT NUMBER,    -- Новый ПД
                                       p_BonusAdd                  OUT NUMBER,    -- Доначисленная премия
                                       p_NewBonus                  OUT NUMBER,    -- Новая начисленная премия
                                       p_DefDiffSum                OUT NUMBER,    -- Доля отсроченной разницы, приходящаяся на ЧП
                                       p_AccountedDefDiffAdd       OUT NUMBER,    -- Доначисленная отсроченная разница
                                       p_NewAccountedDefDiff       OUT NUMBER,    -- Новая начисленная отсроченная разница
                                       p_DefDiff0_korr             OUT NUMBER,    -- Корректировка начальной отсроченной разницы
                                       p_NewDefDiff0               OUT NUMBER,    -- Новая начальная отсроченная разница
                                       p_CorrIntToEIRAdd           OUT NUMBER,    -- Доначисленная корректировка % до ЭПС
                                       p_NewCorrIntToEIR           OUT NUMBER     -- Новое значение корректировки % до ЭПС
                                     )
   IS
     v_LOT DPMWRTSUM_DBT%ROWTYPE;
     v_IsResponsible     NUMBER;
     v_CalcDate          DATE;
     v_D0_1              NUMBER;
     v_R_korr            NUMBER;
     v_FaceFI            NUMBER;
     v_B0_1              NUMBER;

   BEGIN
     InitError();

     BEGIN
       SELECT * INTO v_LOT
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SumID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     SELECT T_FACEVALUEFI INTO v_FaceFI
       FROM DFININSTR_DBT
      WHERE T_FIID = v_LOT.T_FIID;

     v_CalcDate := RSI_RSB_FIInstr.FI_GetPartialDrawingDate( v_LOT.t_FIID, p_Partly );

     p_Portfolio                 := 0;
     p_IncomeSum                 := 0;
     p_DiscountIncomeSum         := 0;
     p_DiscountIncomeAdd         := 0;
     p_NewCost                   := 0;
     p_NewBalanceCost            := 0;
     p_NewOutlay                 := 0;
     p_NewDiscountIncome         := 0;

     IF (v_LOT.T_STATE = PM_WRTSUM_SALE_BPP) THEN
        p_Portfolio := v_LOT.T_PORTFOLIO;

        IF (v_LOT.T_AMOUNT < p_CurAmount) THEN
           p_IncomeSum := ROUND( p_CurSum * v_LOT.T_AMOUNT / p_CurAmount, 2);
        ELSE
           p_IncomeSum := p_CurSum;
        END IF;

        p_CurAmount := p_CurAmount - v_LOT.T_AMOUNT;
        p_CurSum    := p_CurSum    - p_IncomeSum;

        --Выполнить начисление во временную таблицу
        RSI_WRTCalcIncomeOnLotTMP(p_SumID, v_CalcDate, true, true, true, true, true, PMWRTLINK_KIND_RETPARTLY, p_InterestIncomeAdd, p_DiscountIncomeAdd, p_BonusAdd, p_AccountedDefDiffAdd, p_CorrIntToEIRAdd);

        IF (v_LOT.T_BEGDISCOUNT > 0) THEN
           IF (v_LOT.T_OLDBEGDISCOUNT = 0) THEN
              p_DiscountIncomeSum := ROUND(WRTCalcSumPart (v_LOT.T_FIID, p_Partly, /*v_LOT.T_BEGDISCOUNT*/v_LOT.T_DISCOUNTINCOME, v_LOT.T_BEGDISCOUNTDATE), 2);
           ELSE
              v_D0_1 := WRTCalcSumPart( v_LOT.T_FIID, p_Partly, v_LOT.T_OLDBEGDISCOUNT, v_LOT.T_BEGDISCOUNTDATE);
              BEGIN
                SELECT SUM( WRTCalcSumPart( v_LOT.T_FIID, p_Partly, v_LOT.T_OLDBEGDISCOUNT, v_LOT.T_BEGDISCOUNTDATE) *
                            (v_LOT.T_RECALCDATE - v_LOT.T_BEGDISCOUNTDATE) / (warnts.T_DRAWINGDATE - v_LOT.T_BEGDISCOUNTDATE) )
                  INTO v_R_korr
                  FROM DFIWARNTS_DBT warnts
                 WHERE     warnts.t_FIID = v_LOT.T_FIID
                       AND warnts.T_ISPARTIAL  = 'X'
                       AND warnts.T_DRAWINGDATE > v_LOT.T_RECALCDATE
                       AND ((v_LOT.T_TRUST = chr(0) and warnts.T_SPISCLOSED = chr(0)) OR (v_LOT.T_TRUST = chr(88) and warnts.T_TSISCLOSED = chr(0)));
              END;

              IF( v_R_korr <> 0 ) THEN
                 v_R_korr := (v_D0_1 * (v_LOT.T_RECALCDATE  - v_LOT.T_BEGDISCOUNTDATE) / ( v_CalcDate - v_LOT.T_BEGDISCOUNTDATE)) / v_R_korr;
              END IF;

              p_DiscountIncomeSum := ROUND( v_D0_1 * (v_LOT.T_RECALCDATE - v_LOT.T_BEGDISCOUNTDATE)/(v_CalcDate - v_LOT.T_BEGDISCOUNTDATE)-
                                            v_LOT.T_DISCOUNTCORR * v_R_korr +
                                            WRTCalcSumPart (v_LOT.T_FIID, p_Partly, v_LOT.T_BEGDISCOUNT,  v_LOT.T_RECALCDATE), 2);
           END IF;

           p_Discount0_korr := 0;
           p_NewDiscount0 := v_LOT.T_BEGDISCOUNT;

           if( CALC_DISCOUNT_WITHOUT_PARTLY = DISCOUNT_WITHOUT_PARTLY_YES )then
              p_Discount0_korr := p_DiscountIncomeSum - v_LOT.T_DISCOUNTINCOME - p_DiscountIncomeAdd;
              if( p_Discount0_korr < 0 )then
                 p_Discount0_korr := 0;
              end if;
              p_NewDiscount0 := v_LOT.T_BEGDISCOUNT - p_Discount0_korr;
           end if;

           IF (p_Discount0_korr = 0) THEN
              p_NewDiscountIncome := v_LOT.T_DISCOUNTINCOME + p_DiscountIncomeAdd  - p_DiscountIncomeSum;
           ELSIF (p_Discount0_korr > 0) THEN
              p_NewDiscountIncome := 0;
           END IF;
        END IF;

        IF (v_LOT.T_BEGBONUS > 0) THEN
           p_NewBonus := v_LOT.T_BONUS + p_BonusAdd;
        END IF;

        IF (v_LOT.T_BEGDEFDIFF != 0) THEN
           p_DefDiffSum := ROUND(WRTCalcSumPart(v_LOT.T_FIID, p_Partly, v_LOT.T_BEGDEFDIFF, v_LOT.T_BEGDEFDIFFDATE), 2);

           p_DefDiff0_korr := 0;
           p_NewDefDiff0 := v_LOT.T_BEGDEFDIFF;

           if( CALC_DEFDIFF_WITHOUT_PARTLY = DEFDIFF_WITHOUT_PARTLY_YES )then
              p_DefDiff0_korr := p_DefDiffSum - v_LOT.T_ACCOUNTEDDEFDIFF - p_AccountedDefDiffAdd;
              if( p_DefDiff0_korr < 0 )then
                 p_DefDiff0_korr := 0;
              end if;
              p_NewDefDiff0 := v_LOT.T_BEGDEFDIFF - p_DefDiff0_korr;
           end if;

           IF (p_DefDiff0_korr = 0) THEN
              p_NewAccountedDefDiff := v_LOT.T_ACCOUNTEDDEFDIFF + p_AccountedDefDiffAdd - p_DefDiffSum;
           ELSIF (p_DefDiff0_korr > 0) THEN
              p_NewAccountedDefDiff := 0;
           END IF;
        END IF;

        p_NewCorrIntToEIR   := v_LOT.T_CORRINTTOEIR + p_CorrIntToEIRAdd;
        p_NewCost           := v_LOT.T_COST - p_IncomeSum + p_DiscountIncomeSum - p_BonusAdd;
        p_NewBalanceCost    := v_LOT.T_BALANCECOST - p_IncomeSum + p_DiscountIncomeAdd +
                               p_InterestIncomeAdd - p_BonusAdd -
                               RSI_RSB_FIInstr.ConvSum(v_LOT.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, v_FaceFI, v_LOT.T_CORRINTTOEIRDATE, 1 ) +
                               RSI_RSB_FIInstr.ConvSum(p_NewCorrIntToEIR, RSI_RSB_FIInstr.NATCUR, v_FaceFI, p_CalcDate, 1 );
        p_NewOutlay         := ROUND(v_LOT.T_OUTLAY - (p_IncomeSum - p_DiscountIncomeSum) * v_LOT.T_OUTLAY / v_LOT.T_COST, 2);

     ELSIF (v_LOT.T_PORTFOLIO = KINDPORT_BASICDEBT) THEN
        p_Portfolio := KINDPORT_BACK;

        IF (v_LOT.T_AMOUNT < p_CurAmount) THEN
           p_IncomeSum := ROUND( p_CurSum * v_LOT.T_AMOUNT / p_CurAmount, 2);
        ELSE
           p_IncomeSum := p_CurSum;
        END IF;

        p_CurAmount := p_CurAmount - v_LOT.T_AMOUNT;
        p_CurSum    := p_CurSum    - p_IncomeSum;
        p_NewBalanceCost := v_LOT.T_BALANCECOST;
     ELSE
        SetError( WRTOFF_ERROR_20212 );
     END IF;
   END;--RSI_WRTCalcPartialIncome

   ----- вычисление сумм дохода по погашению купона на лот
   PROCEDURE RSI_WRTCalcCouponIncome( p_SumID                     IN NUMBER,     -- Лот  Репо 2 ч.
                                      p_Coupon                    IN VARCHAR2,   -- Номер купона
                                      p_CalcDate                  IN DATE,       -- Дата начисления
                                      p_CurSum                    IN OUT NUMBER, -- Распределяемая сумма купонного дохода по сделке
                                      p_CurAmount                 IN OUT NUMBER, -- Распределяемое количество по сделке
                                      p_Portfolio                 OUT NUMBER,    -- Исходный портфель (из которого зачислен лот)
                                      p_IncomeSum                 OUT NUMBER,    -- Сумма купонного дохода по лоту
                                      p_NKD                       OUT NUMBER,    -- Сумма уплаченного НКД (НКДупл)
                                      p_InterestIncomeSum         OUT NUMBER,    -- Начисленный ПД (ПДначисл)
                                      p_InterestIncomeAdd         OUT NUMBER,    -- Доначисленный ПД SдоначПД)
                                      p_NewBalanceCost            OUT NUMBER,    -- Новая текущая стоимость
                                      p_BonusAdd                  OUT NUMBER,    -- Доначисленная премия (?(SдоначПр))
                                      p_NewBonus                  OUT NUMBER,    -- Новая премия
                                      p_NewCost                   OUT NUMBER,    -- Новая чистая стоимость
                                      p_DiscountIncomeAdd         OUT NUMBER,    -- Доначисленный дисконт
                                      p_NewDiscountIncome         OUT NUMBER,    -- Новый начисленный дисконт
                                      p_AccountedDefDiffAdd       OUT NUMBER,    -- Доначисленная отсроченная разница
                                      p_NewAccountedDefDiff       OUT NUMBER,    -- Новая начисленная отсроченная разница
                                      p_CorrIntToEIRAdd           OUT NUMBER,    -- Доначисленная корректировка % до ЭПС
                                      p_NewCorrIntToEIR           OUT NUMBER     -- Новое значение корректировки % до ЭПС
                                    )
   IS
     v_LOT DPMWRTSUM_DBT%ROWTYPE;
     v_ChargeBonus       NUMBER := 1;
     v_CalcDate          DATE;
     v_FaceFI            NUMBER := -1;
   BEGIN
     InitError();

     BEGIN
       SELECT * INTO v_LOT
         FROM DPMWRTSUM_DBT
        WHERE t_SumID = p_SumID;
     EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20200 );
     END;

     SELECT T_FACEVALUEFI INTO v_FaceFI
       FROM DFININSTR_DBT
      WHERE T_FIID = v_LOT.T_FIID;

     v_CalcDate := RSI_RSB_FIInstr.FI_GetCouponDrawingDate(v_LOT.t_FIID, p_Coupon);

     p_Portfolio                 := 0;
     p_IncomeSum                 := 0;
     p_NKD                       := 0;
     p_InterestIncomeSum         := 0;
     p_InterestIncomeAdd         := 0;
     p_NewBalanceCost            := 0;
     p_BonusAdd                  := 0;
     p_NewBonus                  := 0;
     p_NewCost                   := 0;

     IF (v_LOT.T_STATE = PM_WRTSUM_SALE_BPP) THEN

        p_Portfolio := v_LOT.T_PORTFOLIO;

        IF (v_LOT.T_AMOUNT < p_CurAmount) THEN
           p_IncomeSum := ROUND( p_CurSum * v_LOT.T_AMOUNT / p_CurAmount, 2);
        ELSE
           p_IncomeSum := p_CurSum;
        END IF;

        p_CurAmount := p_CurAmount - v_LOT.T_AMOUNT;
        p_CurSum    := p_CurSum    - p_IncomeSum;

        p_NKD       := v_LOT.T_NKDAMOUNT;

        --Выполнить начисление во временную таблицу
        RSI_WRTCalcIncomeOnLotTMP(p_SumID, v_CalcDate, true, true, v_ChargeBonus=1, true, true, 0, p_InterestIncomeAdd, p_DiscountIncomeAdd, p_BonusAdd, p_AccountedDefDiffAdd, p_CorrIntToEIRAdd);

        p_NewBonus := v_LOT.T_BONUS + p_BonusAdd;
        p_InterestIncomeSum   := v_LOT.T_INTERESTINCOME + p_InterestIncomeAdd;
        p_NewDiscountIncome   := v_LOT.T_DISCOUNTINCOME + p_DiscountIncomeAdd;
        p_NewAccountedDefDiff := v_LOT.T_ACCOUNTEDDEFDIFF + p_AccountedDefDiffAdd;
        p_NewCorrIntToEIR     := v_LOT.T_CORRINTTOEIR + p_CorrIntToEIRAdd;

        p_NewBalanceCost      := v_LOT.T_BALANCECOST - p_IncomeSum + p_InterestIncomeAdd + p_DiscountIncomeAdd - p_BonusAdd -
                                 RSI_RSB_FIInstr.ConvSum(v_LOT.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, v_FaceFI, v_LOT.T_CORRINTTOEIRDATE, 1) +
                                 RSI_RSB_FIInstr.ConvSum(p_NewCorrIntToEIR, RSI_RSB_FIInstr.NATCUR, v_FaceFI, p_CalcDate, 1);
        p_NewCost             := v_LOT.T_COST - p_BonusAdd;

     ELSIF (v_LOT.T_PORTFOLIO = KINDPORT_BASICDEBT) THEN
        p_Portfolio := KINDPORT_BACK;

        IF (v_LOT.T_AMOUNT < p_CurAmount) THEN
           p_IncomeSum := ROUND( p_CurSum * v_LOT.T_AMOUNT / p_CurAmount, 2);
        ELSE
           p_IncomeSum := p_CurSum;
        END IF;

        p_CurAmount := p_CurAmount - v_LOT.T_AMOUNT;
        p_CurSum    := p_CurSum    - p_IncomeSum;

        p_NewBalanceCost := v_LOT.T_BALANCECOST;
     END IF;
   END;--RSI_WRTCalcCouponIncome

   -- Процедура вычисления сумм дохода при отказе от 2ч сделки прямого РЕПО
   PROCEDURE RSI_WRTCalcIncomeRejectDeal( p_SumID                     IN  NUMBER, -- Лот  Репо 2 ч.
                                          p_CalcDate                  IN  DATE,   -- Дата отказа
                                          p_Portfolio                 OUT NUMBER, -- Исходный портфель (из которого зачислен лот)
                                          p_BonusAdd                  OUT NUMBER, -- Доначисленная премия (?(SдоначПр))
                                          p_NewBonus                  OUT NUMBER, -- Новая премия
                                          p_InterestIncomeAdd         OUT NUMBER, -- Доначисленный ПД SдоначПД)
                                          p_NewInterestIncome         OUT NUMBER, -- Новый ПД
                                          p_DiscountIncomeAdd         OUT NUMBER, -- Доначисленный ДД SдоначДД)
                                          p_NewDiscountIncome         OUT NUMBER, -- Новый ДД
                                          p_NewNotCarryInterestIncome OUT NUMBER, -- Новый не отнесенный на доходы ПД
                                          p_NewNotCarryDiscountIncome OUT NUMBER, -- Новый не отнесенный на доходы ДД
                                          p_NewCost                   OUT NUMBER, -- Новая чистая стоимость
                                          p_NewBalanceCost            OUT NUMBER, -- Новая текущая стоимость
                                          p_NewNotWrtBonus            OUT NUMBER  -- Новая премия, не отнесённая на расходы
                                        )
   IS
     v_Lot            DPMWRTSUM_DBT%ROWTYPE;
     v_ChargeDiscount NUMBER := 0;
     v_ChargeInterest NUMBER := 0;
     v_ChargeBonus    NUMBER := 0;
     v_dd             NUMBER;
     v_e              NUMBER;
   BEGIN

     InitError();

     SELECT * INTO v_Lot
       FROM DPMWRTSUM_DBT
      WHERE T_SUMID = p_SumID;

     IF v_Lot.t_State = PM_WRTSUM_SALE_BPP THEN
       p_Portfolio := v_Lot.t_Portfolio;

       v_ChargeInterest := WRTNeedChargeInterestIncome(v_Lot.t_FIID);
       v_ChargeDiscount := WRTNeedChargeIncome(v_Lot.t_FIID);
       v_ChargeBonus    := WRTNeedChargeBonus(v_Lot.t_FIID);

       IF( (v_ChargeInterest = 1) OR (v_ChargeDiscount = 1) OR (v_ChargeBonus = 1) ) THEN

          RSI_WRTCalcIncomeOnLotTMP(p_SumID, p_CalcDate, v_ChargeInterest=1, v_ChargeDiscount=1, v_ChargeBonus=1, false, false, 0, p_InterestIncomeAdd, p_DiscountIncomeAdd, p_BonusAdd, v_dd, v_e);

          p_NewBonus          := v_Lot.t_Bonus + p_BonusAdd;
          p_NewNotWrtBonus    := v_Lot.T_NOTWRTBONUS;
          p_NewInterestIncome := v_Lot.t_InterestIncome + p_InterestIncomeAdd;
          p_NewDiscountIncome := v_Lot.t_DiscountIncome + p_DiscountIncomeAdd;
          p_NewCost           := v_Lot.t_Cost - p_BonusAdd;
          p_NewBalanceCost    := v_Lot.t_BalanceCost + p_InterestIncomeAdd + p_DiscountIncomeAdd - p_BonusAdd;

          p_NewNotCarryInterestIncome := v_Lot.t_NotCarryInterest;
          p_NewNotCarryDiscountIncome := v_Lot.t_NotCarryDiscount;
       ELSE
          p_InterestIncomeAdd         := 0;
          p_DiscountIncomeAdd         := 0;
          p_BonusAdd                  := 0;
          p_NewBonus                  := 0;
          p_NewNotWrtBonus            := 0;
          p_NewInterestIncome         := 0;
          p_NewDiscountIncome         := 0;
          p_NewCost                   := v_Lot.t_Cost;
          p_NewBalanceCost            := v_Lot.t_BalanceCost;
          p_NewNotCarryInterestIncome := 0;
          p_NewNotCarryDiscountIncome := 0;
       END IF;

     ELSIF v_Lot.t_Portfolio = KINDPORT_BASICDEBT THEN
       p_Portfolio                 := KINDPORT_BACK;
       p_InterestIncomeAdd         := 0;
       p_DiscountIncomeAdd         := 0;
       p_BonusAdd                  := 0;
       p_NewInterestIncome         := v_Lot.t_InterestIncome;
       p_NewDiscountIncome         := v_Lot.t_DiscountIncome;
       p_NewCost                   := v_Lot.t_Cost;
       p_NewBalanceCost            := v_Lot.t_BalanceCost;
       p_NewNotCarryInterestIncome := v_Lot.t_NotCarryInterest;
       p_NewNotCarryDiscountIncome := v_Lot.t_NotCarryDiscount;

     ELSE
       SetError( WRTOFF_ERROR_20250 ); -- Некорректный лот
     END IF;

   END;--RSI_WRTCalcIncomeRejectDeal

   --Функция вычисления суммы начального дисконта или премии по лоту
   FUNCTION RSI_WRTCalcBegDiscountOrBonus( p_Leg IN ddl_leg_dbt%ROWTYPE,
                                           p_Cost IN NUMBER,
                                           p_Date IN DATE,
                                           p_CostPFI IN NUMBER,
                                           p_FaceValueFI IN NUMBER
                                         ) RETURN NUMBER
   IS
     v_Sum0 NUMBER := 0;

   BEGIN

     IF OnlyPriceInDiscountOrBonus() = 0 THEN
       v_Sum0 := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(p_Leg.t_PFI, p_Date) * p_Leg.t_Principal - (p_Cost + p_CostPFI), 2);
     ELSE
       IF p_Leg.t_RelativePrice = 'X' THEN
         v_Sum0 := ROUND((100.0 - p_Leg.t_Price)*RSI_RSB_FIInstr.FI_GetNominalOnDate(p_Leg.t_PFI, p_Date)* p_Leg.t_Principal / 100.0 - p_CostPFI, 2);
       ELSE
         v_Sum0 := ROUND((RSI_RSB_FIInstr.FI_GetNominalOnDate(p_Leg.t_PFI, p_Date) - RSI_RSB_FIInstr.ConvSum(p_Leg.t_Price, p_Leg.t_CFI, p_FaceValueFI, p_Date, 0))* p_Leg.t_Principal - p_CostPFI, 2);
       END IF;
     END IF;

     RETURN v_Sum0;

   END; --RSI_WRTCalcBegDiscountOrBonus

   -- Расчет начисленного дохода при погашении купона/ЧП.
   PROCEDURE RSI_WRTChangeIncomeOnWrt( p_Lnk              IN OUT DPMWRTLNK_DBT%ROWTYPE,
                                       p_BuyLot           IN DPMWRTSUM_DBT%ROWTYPE,
                                       p_CalcInterest     IN BOOLEAN,
                                       p_CalcDiscount     IN BOOLEAN,
                                       p_CalcBonus        IN BOOLEAN,
                                       p_CalcDefDiff      IN BOOLEAN, -- Начислять отсроченную разницу
                                       p_CalcCorrIntToEIR IN BOOLEAN, -- Начислять корректировку процентов до ЭПС
                                       p_Method           IN NUMBER,  -- метод списания
                                       p_CalcDate         IN DATE,    -- дата начисления
                                       p_Discount0_korr   OUT NUMBER, -- коррекция начального дисконта
                                       p_DefDiff0_korr    OUT NUMBER  -- коррекция начальной отсроченной разницы
                                     )
   IS
      v_WrtSumTmp DPMWRTSUM_TMP%ROWTYPE;
      v_DS            NUMBER := 0;
      R_korr          NUMBER := 0;
      D0_1            NUMBER := 0;
      NewDiscount0    NUMBER := 0;
      v_FaceFI        NUMBER := -1;
      v_Bs            NUMBER := 0;
      v_B0_1          NUMBER := 0;
      NewBonus0       NUMBER := 0;
      v_DDS           NUMBER := 0;
      NewDefDiff0     NUMBER := 0;
   BEGIN
        InitError();

        if (p_Method <> RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) then

           BEGIN
             SELECT TMP.* into v_WrtSumTmp
               FROM DPMWRTSUM_TMP TMP
              WHERE TMP.T_SUMID = p_BuyLot.T_SUMID
                AND TMP.T_KIND = 0;
           EXCEPTION
           WHEN OTHERS THEN
               SetError( WRTOFF_ERROR_20239 );
           END;

        end if;

        p_Lnk.T_INTERESTINCOMEADD := 0;
        IF (p_CalcInterest = true) THEN

           IF( p_Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
              if (p_CalcDate <> p_BuyLot.t_INTERESTDATE) AND (p_CalcDate <> p_BuyLot.t_ENTERDATE) THEN
                 SetError( WRTOFF_ERROR_20229 ); -- Не выполнено начисление процентного дохода на дату списания
              end if;
           ELSE

             p_Lnk.T_INTERESTINCOMEADD := round(((v_WrtSumTmp.T_INTERESTADD/v_WrtSumTmp.T_AMOUNT) * p_Lnk.T_AMOUNT),2);
             p_Lnk.T_BALANCECOSTBUY := p_Lnk.T_BALANCECOSTBUY - p_Lnk.T_INTERESTINCOMEADD;

             -- Увеличиить на сумму купона из панели погашения, пропорционально количеству в лоте.
             -- Но т.к. этот параметр напрямую в БД не хранится, то вычислим его как сумму ПД с этого лота и доначисоления ПД на этот лот.
             -- p_Lnk.T_BALANCECOSTBUY := p_Lnk.T_BALANCECOSTBUY + p_Lnk.T_INTERESTINCOMEBUY + p_Lnk.T_INTERESTINCOMEADD;
           END IF;

        END IF;

        -- начисление премии
        IF (p_CalcBonus = true) THEN
           IF( p_Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
              if (p_CalcDate <> p_BuyLot.t_BONUSDATE)  AND (p_CalcDate <> p_BuyLot.t_ENTERDATE) THEN
                 SetError( WRTOFF_ERROR_20233 ); -- Не выполнено начисление премии на дату списания
              end if;
           ELSE

             p_Lnk.T_BONUSADD := round(((v_WrtSumTmp.T_BONUSADD/v_WrtSumTmp.T_AMOUNT) * p_Lnk.T_AMOUNT),2);
             p_Lnk.T_BONUSBUY := - p_Lnk.T_BONUSADD; --С минусом, чтобы прибавить на лоте

             p_Lnk.T_COSTBUY        := p_LNK.T_COSTBUY        + p_Lnk.T_BONUSADD;
             p_Lnk.T_BALANCECOSTBUY := p_Lnk.T_BALANCECOSTBUY + p_Lnk.T_BONUSADD;

             p_Lnk.T_BEGBONUSCHANGE := 0;
           END IF;

        END IF;

        IF (p_CalcDiscount = true) THEN

           IF( p_Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
              if (p_CalcDate <> p_BuyLot.t_DISCOUNTDATE  AND (p_CalcDate <> p_BuyLot.t_ENTERDATE) AND
                  (p_Lnk.T_BEGDISCOUNTCHANGE > 0 OR p_Lnk.T_DISCOUNTINCOMEBUY <> 0)
                 ) THEN
                 SetError( WRTOFF_ERROR_20230 ); -- Не выполнено начисление дисконтного дохода на дату списания
              else
                 v_DS := ROUND(WRTCalcSumPart (p_BuyLot.T_FIID, p_Lnk.T_PARTLY,
                                               p_Lnk.T_BEGDISCOUNTCHANGE, p_CalcDate-1
                                              ), 2);

                 IF p_Lnk.T_DISCOUNTINCOMEBUY < v_DS THEN
                   v_DS := p_Lnk.T_DISCOUNTINCOMEBUY;
                 END IF;

                 p_Lnk.T_BEGDISCOUNTCHANGE := v_DS;
                 p_Lnk.T_DISCOUNTINCOMEBUY := v_DS;

                 p_Lnk.T_COSTBUY        := p_Lnk.T_COSTBUY - v_DS;
                 p_Lnk.T_BALANCECOSTBUY := p_Lnk.T_BALANCECOSTBUY - p_Lnk.T_COSTSALE + p_Lnk.T_COSTBUY + p_Lnk.T_DISCOUNTINCOMEBUY; 
              end if;
           ELSE

             IF (p_Lnk.T_OLDBEGDISCOUNTCHANGE = 0) THEN
                v_DS := ROUND(WRTCalcSumPart (p_BuyLot.T_FIID, p_Lnk.T_PARTLY,
                                              p_Lnk.T_BEGDISCOUNTCHANGE, p_BuyLot.T_BEGDISCOUNTDATE
                                             ), 2);
             ELSE

                D0_1 := WRTCalcSumPart( p_BuyLot.T_FIID, p_Lnk.T_PARTLY, p_Lnk.T_OLDBEGDISCOUNTCHANGE, p_BuyLot.T_BEGDISCOUNTDATE );

                SELECT NVL(SUM(WRTCalcSumPart( p_BuyLot.T_FIID, T_NUMBER,
                                               p_Lnk.T_OLDBEGDISCOUNTCHANGE, p_BuyLot.T_BEGDISCOUNTDATE
                                             ) * (p_BuyLot.T_RECALCDATE  - p_BuyLot.T_BEGDISCOUNTDATE)/(T_DRAWINGDATE - p_BuyLot.T_BEGDISCOUNTDATE)
                              ),0) into R_korr
                  FROM DFIWARNTS_DBT
                 WHERE t_FIID         = p_BuyLot.t_FIID
                   AND T_ISPARTIAL    = chr(88)
                   AND T_DRAWINGDATE >= p_BuyLot.T_RECALCDATE
                   AND ((p_BuyLot.T_TRUST = chr(0) and T_SPISCLOSED = chr(0)) OR (p_BuyLot.T_TRUST = chr(88) and T_TSISCLOSED = chr(0)));

                if( R_korr != 0 ) then
                   R_korr := D0_1 * (p_BuyLot.T_RECALCDATE  - p_BuyLot.T_BEGDISCOUNTDATE)/(p_CalcDate - p_BuyLot.T_BEGDISCOUNTDATE)/R_korr;
                end if;

                v_DS := ROUND(D0_1 * (p_BuyLot.T_RECALCDATE  - p_BuyLot.T_BEGDISCOUNTDATE)/(p_CalcDate - p_BuyLot.T_BEGDISCOUNTDATE)-
                              p_Lnk.T_DISCOUNTCORRCHANGE*R_korr +
                              WRTCalcSumPart (p_BuyLot.T_FIID, p_Lnk.T_PARTLY, p_Lnk.T_BEGDISCOUNTCHANGE, p_BuyLot.T_RECALCDATE), 2);

             END IF;

             p_Lnk.T_DISCOUNTINCOMEADD := round(((v_WrtSumTmp.T_DISCOUNTADD/v_WrtSumTmp.T_AMOUNT) * p_Lnk.T_AMOUNT),2);

             p_Discount0_korr := 0;
             NewDiscount0 := p_BuyLot.T_BEGDISCOUNT;

             if( CALC_DISCOUNT_WITHOUT_PARTLY = DISCOUNT_WITHOUT_PARTLY_YES )then
                p_Discount0_korr := v_DS - p_BuyLot.T_DISCOUNTINCOME - p_Lnk.T_DISCOUNTINCOMEADD;
                if( p_Discount0_korr < 0 )then
                   p_Discount0_korr := 0;
                end if;
                NewDiscount0 := p_BuyLot.T_BEGDISCOUNT - v_DS;
             end if;

             p_Lnk.T_COSTBUY := p_LNK.T_COSTBUY - v_DS;
             p_Lnk.T_BALANCECOSTBUY := p_Lnk.T_BALANCECOSTBUY - p_Lnk.T_DISCOUNTINCOMEADD - p_Discount0_korr;

             if( p_Discount0_korr = 0 )then
                p_Lnk.T_DISCOUNTINCOMEBUY := v_DS - p_Lnk.T_DISCOUNTINCOMEADD;
             elsif( p_Discount0_korr > 0 )then
                p_Lnk.T_DISCOUNTINCOMEBUY := p_BuyLot.T_DISCOUNTINCOME;
             end if;

             p_Lnk.T_BEGDISCOUNTCHANGE := p_BuyLot.T_BEGDISCOUNT - NewDiscount0;
           END IF;
        END IF;

        -- Отсроченная разница
        IF (p_CalcDefDiff = true) THEN
           IF( p_Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
              if (p_CalcDate <> p_BuyLot.T_DEFDIFFDATE) AND
                 (p_Lnk.T_BEGDEFDIFFCHANGE != 0 or p_Lnk.T_ACCOUNTEDDEFDIFFBUY !=0) AND
                 (p_CalcDate <> p_BuyLot.t_ENTERDATE) THEN
                 SetError( WRTOFF_ERROR_20263 ); -- Не выполнено начисление отсроченной разницы на дату списания
              end if;
           ELSE

             p_Lnk.T_ACCOUNTEDDEFDIFFADD := round(((v_WrtSumTmp.T_DEFDIFFADD/v_WrtSumTmp.T_AMOUNT) * p_Lnk.T_AMOUNT),2);

             v_DDS := ROUND(WRTCalcSumPart(p_BuyLot.T_FIID, p_Lnk.T_PARTLY,
                                           p_Lnk.T_BEGDEFDIFFCHANGE, p_BuyLot.T_BEGDEFDIFFDATE
                                          ), 2);
             p_DefDiff0_korr := 0;
             NewDefDiff0 := p_BuyLot.T_BEGDEFDIFF;

             if( CALC_DEFDIFF_WITHOUT_PARTLY = DEFDIFF_WITHOUT_PARTLY_YES )then
                p_DefDiff0_korr := v_DDS - p_BuyLot.T_ACCOUNTEDDEFDIFF - p_Lnk.T_ACCOUNTEDDEFDIFFADD;
                --if( p_DefDiff0_korr < 0 )then
                --   p_DefDiff0_korr := 0;
                --end if;
                NewDefDiff0 := p_BuyLot.T_BEGDEFDIFF - v_DDS;
             end if;

             if( p_DefDiff0_korr = 0 )then
                p_Lnk.T_ACCOUNTEDDEFDIFFBUY := v_DDS - p_Lnk.T_ACCOUNTEDDEFDIFFADD;
             elsif( p_Discount0_korr != 0 )then
                p_Lnk.T_ACCOUNTEDDEFDIFFBUY := p_BuyLot.T_ACCOUNTEDDEFDIFF;
             end if;

             p_Lnk.T_BEGDEFDIFFCHANGE := p_BuyLot.T_BEGDEFDIFF - NewDefDiff0;

           END IF;
        END IF;

        -- Корректировка % до ЭПС
        IF (p_CalcCorrIntToEIR = true) THEN
           SELECT T_FACEVALUEFI INTO v_FaceFI
             FROM DFININSTR_DBT
            WHERE T_FIID = p_BuyLot.T_FIID;

           p_Lnk.T_CORRINTTOEIRADD    := -round(((v_WrtSumTmp.T_WRTCORRINTTOEIR/v_WrtSumTmp.T_AMOUNT) * p_Lnk.T_AMOUNT),2); --С минусом, т.к. поле T_WRTCORRINTTOEIR с суммой списания
           p_Lnk.T_CORRINTTOEIRCHANGE := -p_Lnk.T_CORRINTTOEIRADD; --С минусом, чтобы увеличить
           IF p_Lnk.T_CORRINTTOEIRADD <> 0 THEN
             p_Lnk.T_BALANCECOSTBUY     := p_Lnk.T_BALANCECOSTBUY - RSI_RSB_FIInstr.ConvSum(p_Lnk.T_CORRINTTOEIRADD, RSI_RSB_FIInstr.NATCUR, v_FaceFI, p_CalcDate, 1 ); --С минусом, чтобы увеличить
           END IF;
        END IF;

   END; -- RSI_WRTChangeIncomeOnWrt

   ----------------------------------------------------------------------------------------------------------------------
   ----- Возвращает списанное к-во и списанную сумму из портфеля на дату.
   -----   Вход:
   ----- Department - Филиал
   ----- FIID - ц/б
   ----- Party - Владелец
   ----- Contract - Договор обслуживания
   ----- Portfolio  - Портфель
   ----- CalcDate -  Дата расчета
   -----   Выход:
   ----- Amount - Списанное к-во
   ----- OverAmount - Списанная сумма переоценки переоценки (?ПО)

   PROCEDURE WRTGetSaleOvervalue( p_Department                 IN NUMBER,
                                  p_FIID                       IN NUMBER,
                                  p_Party                      IN NUMBER,
                                  p_Contract                   IN NUMBER,
                                  p_Portfolio                  IN NUMBER,
                                  p_CalcDate                   IN DATE,
                                  p_Amount                    OUT NUMBER,
                                  p_OverAmount                OUT NUMBER
                                )
   IS
   BEGIN
      SELECT /*+ leading(l) index(b DPMWRTSUM_DBT_IDX0) index(s DPMWRTSUM_DBT_IDX0) */ NVL(SUM(L.T_AMOUNT), 0),
             NVL(SUM(ROUND(L.T_OVERCHANGE,2)), 0)
        INTO p_Amount, p_OverAmount
        FROM DPMWRTLNK_DBT L, DPMWRTSUM_DBT B, DPMWRTSUM_DBT S
       WHERE L.T_CREATEDATE  = p_CalcDate
         AND L.T_KIND        in (PMWRTLINK_KIND_DISCARD, PMWRTLINK_KIND_DISCARDBD, PMWRTLINK_KIND_RETISSUE, PMWRTLINK_KIND_PORTFOLIO)
         AND S.T_SUMID       = L.T_SALEID
         AND B.T_SUMID       = L.T_BUYID
         AND S.T_KIND        not in (WRTSUM_KIND_RRWAS1, WRTSUM_KIND_RRAS1, WRTSUM_KIND_LPS)
         AND S.T_DEPARTMENT  = p_Department
         AND S.T_FIID        = p_FIID
         AND S.T_PARTY       = p_Party
         AND B.T_PORTFOLIO   = p_Portfolio
         AND S.T_CONTRACT    = p_Contract;

   END;--WRTGetSaleOvervalue

   ---------------------------------------------------------------------------------------------------------------------------
   ----- Возвращаются суммы, измененные в сервисной операции. Применяется в операции начисления ПДД.
   -----   Вход:
   ----- ID_Operation, ID_Step - Операция и шаг, на которых выполнялось изменение
   ----- Action  - Вид изменения
   ----- Group  - Группа списания (портфель)
   ----- Delivered - Отбирать поставленные
   ----- WithoutAccept - Отбирать проданные БПП
   -----   Выход:
   ----- BalanceCost  -  Изменение текущей стоимости ( (Стек))
   ----- NotCarryInterest - Изменение не отнесенного на доходы ПД  (?ПДне_отн )
   ----- NotCarryDiscount - Изменение не отнесенного на доходы ДД  (?ДДне_отн)
   ----- InterestIncomeAdd - Доначисленный ПД (?Sдонач.ПДi)
   ----- DiscountIncomeAdd - Доначисленный ДД (?Sдонач.ДДi)
   ----- Bonus - изменение премии
   ----- WriteOffNotCarryIncome - Списание не отнесенного на доходы ПДД  (Sотн)

   PROCEDURE WRTGetServiceFinResult( p_ID_Operation IN NUMBER,
                                     p_ID_Step      IN NUMBER,
                                     p_Action       IN NUMBER,
                                     p_Party        IN NUMBER,
                                     p_Contract     IN NUMBER,
                                     p_FIID         IN NUMBER,
                                     p_Portfolio    IN NUMBER, -- Портфель. Если не задан - игнорируется.
                                     p_Delivered    IN NUMBER,
                                     p_WithoutAccept IN NUMBER,
                                     p_BalanceCost            OUT NUMBER,
                                     p_InterestIncome         OUT NUMBER,
                                     p_DiscountIncome         OUT NUMBER,
                                     p_Bonus                  OUT NUMBER,
                                     p_DefDiff                OUT NUMBER,
                                     p_CorrIntToEIR           OUT NUMBER,
                                     p_OldInterestIncome      OUT NUMBER,
                                     p_OldDiscountIncome      OUT NUMBER,
                                     p_OldBonus               OUT NUMBER,
                                     p_Amount                 OUT NUMBER,
                                     p_BonusAmount            OUT NUMBER,
                                     p_DiscountAmount         OUT NUMBER,
                                     p_InterestAmount         OUT NUMBER
                                   )
   IS
   BEGIN
     SELECT NVL(SUM(ROUND(A.T_BALANCECOST,2)      - ROUND(B.T_BALANCECOST,2)), 0),
            NVL(SUM(ROUND(A.T_INTERESTINCOME,2)   - ROUND(B.T_INTERESTINCOME,2)), 0),
            NVL(SUM(ROUND(A.T_DISCOUNTINCOME,2)   - ROUND(B.T_DISCOUNTINCOME,2)), 0),
            NVL(SUM(ROUND(A.T_BONUS,2) - ROUND(B.T_BONUS,2)), 0),
            NVL(SUM(ROUND(A.T_ACCOUNTEDDEFDIFF,2) - ROUND(B.T_ACCOUNTEDDEFDIFF,2)), 0),
            NVL(SUM(ROUND(A.T_CORRINTTOEIR ,2) - ROUND(B.T_CORRINTTOEIR ,2)), 0),
            NVL(SUM(ROUND(B.T_INTERESTINCOME,2)), 0),
            NVL(SUM(ROUND(B.T_DISCOUNTINCOME,2)), 0),
            NVL(SUM(ROUND(B.T_BONUS,2)), 0),
            NVL(SUM(ROUND(B.T_AMOUNT,2)), 0),
            NVL(sum(case when ROUND(A.T_BONUS,2) - ROUND(B.T_BONUS,2) > 0 then  ROUND(B.T_AMOUNT,2) else 0 end),0)  BONUSAMOUNT,
            NVL(sum(case when ROUND(A.T_DISCOUNTINCOME,2) - ROUND(B.T_DISCOUNTINCOME,2) > 0 then  ROUND(B.T_AMOUNT,2) else 0 end),0)  DISCOUNTAMOUNT,
            NVL(sum(case when ROUND(A.T_INTERESTINCOME,2) - ROUND(B.T_INTERESTINCOME,2) > 0 then  ROUND(B.T_AMOUNT,2) else 0 end),0)  INTERESTAMOUNT
       INTO p_BalanceCost, p_InterestIncome, p_DiscountIncome, p_Bonus, p_DefDiff, p_CorrIntToEIR,
            p_OldInterestIncome, p_OldDiscountIncome, p_OldBonus, p_Amount, p_BonusAmount, p_DiscountAmount, p_InterestAmount
       FROM V_SCWRTHISTEX A, DPMWRTBC_DBT B
      WHERE A.T_ID_OPERATION = p_ID_Operation
        AND A.T_ID_STEP      = p_ID_Step
        AND A.T_ACTION       = p_Action
        AND ((A.T_PARTY = p_Party) OR (p_Party = -1) OR (p_Party is NULL))
        AND ((A.T_CONTRACT = p_Contract) OR (p_Contract = 0) OR (p_Contract is NULL))
        AND ((A.T_FIID = p_FIID) OR (p_FIID = -1) OR (p_FIID is NULL))
        AND A.t_Portfolio != (CASE WHEN (p_Portfolio is NULL) OR (p_Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
        AND A.t_Portfolio  = (CASE WHEN (p_Portfolio is not NULL) and (p_Portfolio != UnknownValue) THEN p_Portfolio ELSE A.t_Portfolio END)
        AND B.T_SUMID        = A.T_SUMID
        AND B.T_INSTANCE     = A.T_INSTANCE - 1
        AND ((p_Delivered = 1 AND A.T_STATE = PM_WRTSUM_FORM) or (p_WithoutAccept = 1 AND A.T_STATE = PM_WRTSUM_SALE_BPP));

   END;--WRTGetServiceFinResult

   ----------------------------------------------------------------------------------------------------------------------
   ----Возвращаются суммы, измененные в операции глобального перемещения.
   ----Вход:
   ---- ID_Operation, ID_Step - Операция и шаг, на которых выполнялось изменение
   ---- Action  - Вид изменения
   ---- Source  - Исходный портфель (группа списания)
   ---- Goal  - Целевой портфель (группа списания)
   ---- State - статус лотов (посчитать по БПП)
   ----Выход:
   ---- Cost-Перемещенная чистая стоимость (?(Счист))
   ---- NKD -  Перемещенный НКД (?(НКД упл.))
   ---- BalanceCost  -  Перемещенная текущая стоимость (?(Стек))
   ---- InterestIncome - Перемещенный ПД (?Sнач.ПД) (зарезерв.)
   ---- DiscountIncome - Перемещенный ДД (?Sнач.ДД) (зарезерв.)
   ---- NotCarryInterest - Перемещенный не отнесенный на доходы ПД  (?ПДне_отн)
   ---- NotCarryDiscount - Перемещенный не отнесенный на доходы ДД  (?ДДне_отн)
   PROCEDURE WRTGetGlobalMovingFinResult( p_ID_Operation IN NUMBER,
                                          p_ID_Step      IN NUMBER,
                                          p_Action       IN NUMBER,
                                          p_Source       IN NUMBER,
                                          p_Goal         IN NUMBER,
                                          p_State        IN NUMBER,
                                          p_DocKind      IN NUMBER DEFAULT UnknownValue,
                                          p_DocID        IN NUMBER DEFAULT UnknownValue,
                                          p_Cost                   OUT NUMBER,
                                          p_NKD                    OUT NUMBER,
                                          p_BalanceCost            OUT NUMBER,
                                          p_InterestIncome         OUT NUMBER,
                                          p_DiscountIncome         OUT NUMBER,
                                          p_NotCarryInterest       OUT NUMBER,
                                          p_NotCarryDiscount       OUT NUMBER,
                                          p_OverAmount             OUT NUMBER, -- Списанная сумма переоценки
                                          p_ReservAmount           OUT NUMBER, -- Списанная сумма резерва
                                          p_IncomeReserv           OUT NUMBER  -- Списанная сумма резерва ПДД
)
   IS
   BEGIN
     SELECT NVL(SUM(ROUND(B.T_BALANCECOST,2)), 0),
            NVL(SUM(ROUND(B.T_NKDAMOUNT,2)), 0),
            NVL(SUM(ROUND(B.T_BALANCECOST,2)), 0),
            NVL(SUM(ROUND(B.T_INTERESTINCOME,2)), 0),
            NVL(SUM(ROUND(B.T_NOTCARRYINTEREST,2)), 0),
            NVL(SUM(ROUND(B.T_DISCOUNTINCOME,2)), 0),
            NVL(SUM(ROUND(B.T_NOTCARRYDISCOUNT,2)), 0),
            NVL(SUM(ROUND(B.T_OVERAMOUNT,2)), 0),
            NVL(SUM(ROUND(B.T_RESERVAMOUNT,2)), 0),
            NVL(SUM(ROUND(B.T_INCOMERESERV,2)), 0)
       INTO p_Cost, p_NKD, p_BalanceCost, p_InterestIncome, p_NotCarryInterest, p_DiscountIncome, p_NotCarryDiscount, p_OverAmount, p_ReservAmount, p_IncomeReserv
       FROM V_SCWRTHISTEX A, DPMWRTBC_DBT B
      WHERE A.T_ID_OPERATION = p_ID_Operation
        AND A.T_ID_STEP      = p_ID_Step
        AND A.T_ACTION       = p_Action
        AND B.T_PORTFOLIO    = p_Source
        AND A.T_PORTFOLIO    = p_Goal
        AND A.T_STATE        = p_State
        AND ((p_DocKind = UnknownValue) OR
             (p_DocKind is NULL)        OR
             ((A.T_DOCKIND = p_DocKind) AND (A.T_DOCID = p_DocID))
            )
        AND B.T_SUMID        = A.T_SUMID
        AND B.T_INSTANCE     = A.T_INSTANCE - 1;

   END;--WRTGetGlobalMovingFinResult

   -- Расчет начисленного дохода при списании.
   PROCEDURE WRTChangeIncomeOnSale( Lnk           IN OUT DPMWRTLNK_DBT%ROWTYPE,
                                    BuyLot        IN DPMWRTSUM_DBT%ROWTYPE,
                                    CalcInterest  IN BOOLEAN,
                                    CalcDiscount  IN BOOLEAN,
                                    CalcBonus     IN BOOLEAN,
                                    CalcDefDiff   IN BOOLEAN,
                                    CalcIntToEIR  IN BOOLEAN,
                                    CalcReserve   IN BOOLEAN,
                                    CalcOverValue IN BOOLEAN,
                                    Method        IN NUMBER, -- метод списания
                                    CalcDate      IN DATE    -- дата начисления
                                  )
   IS
      v_WrtSumTmp DPMWRTSUM_TMP%ROWTYPE;

      v_CheckDate DATE := CalcDate;
   BEGIN

      if ( Method != RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE ) then

        BEGIN
          SELECT TMP.* into v_WrtSumTmp
            FROM DPMWRTSUM_TMP TMP
           WHERE TMP.T_SUMID = BUYLOT.T_SUMID
             AND TMP.T_KIND = 0;
        EXCEPTION
        WHEN OTHERS THEN
            SetError( WRTOFF_ERROR_20239 );
        END;

      end if;

      LNK.T_INTERESTINCOMEADD := 0;
      LNK.T_BONUSADD := 0;

      --Процентный доход
      if (CalcInterest = true) then

         IF( Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
            IF Lnk.t_Kind = PMWRTLINK_KIND_RETISSUE THEN
              --Если погашение выпуска попало на выходной день, то его делают в ближайший рабочий день
              --Однако при этом доначисление могло быть только по дату погашения
              --Поэтому проверяем в том числе и наличие доначисления на плановую дату погашения, а не фактическую.
              
              SELECT T_DRAWINGDATE
                INTO v_CheckDate
                FROM DFININSTR_DBT
               WHERE T_FIID = BuyLot.T_FIID;
            END IF;

            if (BUYLOT.t_INTERESTDATE <> UnknownDate) and 
               (CalcDate <> BUYLOT.t_INTERESTDATE) and 
               (CalcDate <> BUYLOT.t_ENTERDATE) and 
               (v_CheckDate <> BUYLOT.t_INTERESTDATE)   
               THEN
               SetError( WRTOFF_ERROR_20229 ); -- Не выполнено начисление процентного дохода на дату списания
            else
               return;
            end if;
         END IF;

         IF LNK.T_NKDSALEAMOUNT = 0 AND (LNK.T_INTERESTINCOMEBUY <> 0 OR LNK.T_NKDBUYAMOUNT <> 0) THEN --При списании в операции объединения выпусков
           LNK.T_INTERESTINCOMEADD := round(((v_WrtSumTmp.T_INTERESTADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
         ELSE
           LNK.T_INTERESTINCOMEADD := LNK.T_NKDSALEAMOUNT - LNK.T_INTERESTINCOMEBUY - LNK.T_NKDBUYAMOUNT;
         END IF;

      end if;

      -- начисление премии
      if (CalcBonus = true) then

         IF( Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
            if (CalcDate <> BUYLOT.t_BONUSDATE) and (CalcDate <> BUYLOT.t_ENTERDATE) THEN
               SetError( WRTOFF_ERROR_20233 ); -- Не выполнено начисление премии на дату списания
            else
               return;
            end if;
         END IF;

         LNK.T_BONUSADD := round(((v_WrtSumTmp.T_BONUSADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
      end if;

      --Дисконтный доход
      if (CalcDiscount = true) then

         IF( Method = RSB_PMWRTOFF.PM_WRITEOFF_AVERAGE) THEN
            if (CalcDate <> BUYLOT.t_DISCOUNTDATE and (CalcDate <> BUYLOT.t_ENTERDATE) AND
                (LNK.T_BEGDISCOUNTCHANGE > 0 OR LNK.T_DISCOUNTINCOMEBUY <> 0)
               ) THEN
               SetError( WRTOFF_ERROR_20230 ); -- Не выполнено начисление дисконтного дохода на дату списания
            else
               return;
            end if;
         END IF;

         LNK.T_DISCOUNTINCOMEADD := round(((v_WrtSumTmp.T_DISCOUNTADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
      end if;

      --Отсроченная разница
      if (CalcDefDiff = true) then

         IF( Method = PM_WRITEOFF_AVERAGE) THEN
            if (CalcDate <> BUYLOT.T_DEFDIFFDATE and
               (LNK.T_BEGDEFDIFFCHANGE != 0 or LNK.T_ACCOUNTEDDEFDIFFBUY !=0) and
               (CalcDate <> BUYLOT.t_ENTERDATE) AND
                (LNK.T_BEGDISCOUNTCHANGE != 0 OR LNK.T_DISCOUNTINCOMEBUY <> 0)
               ) THEN
               SetError( WRTOFF_ERROR_20263 ); -- Не выполнено начисление отсроченной разницы на дату списания
            else
               return;
            end if;
         END IF;

         LNK.T_ACCOUNTEDDEFDIFFADD := round(((v_WrtSumTmp.T_DEFDIFFADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
      end if;

      --Корректировка % до ЭПС
      if (CalcIntToEIR = true) then
         LNK.T_CORRINTTOEIRADD := -round(((v_WrtSumTmp.T_WRTCORRINTTOEIR/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
      end if;

      --Резерв
      if (CalcReserve = true) then
         LNK.T_ESTRESERVEADD := round(((v_WrtSumTmp.T_ESTRESERVEADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
         LNK.T_CORRESTRESERVEADD := round(((v_WrtSumTmp.T_CORRESTRESERVEADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
         LNK.T_RESERVADD := round(((v_WrtSumTmp.T_RESERVAMOUNTADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
         LNK.T_INCOMERESERVADD := round(((v_WrtSumTmp.T_INCOMERESERVADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
      end if;

      --Переоценка
      if (CalcOverValue = true) then
         LNK.T_OVERAMOUNTADD := round(((v_WrtSumTmp.T_OVERAMOUNTADD/v_WrtSumTmp.T_AMOUNT) * LNK.T_AMOUNT),2);
      end if;

   END; -- WRTChangeIncomeOnSale

   -- Выполняет списание лота погашения купона или ЧП по лотам покупки заданной группы списания.
   PROCEDURE RSI_WRTLinkWrt( p_SaleLot          IN OUT DPMWRTSUM_DBT%ROWTYPE,
                             p_Group            IN     NUMBER,  -- Группа списания (портфель)
                             p_StartDate        IN     DATE,    -- Дата отбора лотов покупки. Если не задано - игнорируется.
                             p_Method           IN     NUMBER,  -- Метод списания
                             p_ID_Operation     IN     NUMBER,  -- Операция и шаг, на которых выполняется списание
                             p_ID_Step          IN     NUMBER,  --
                             p_LinkKind         IN     NUMBER,  -- Вид создаваемой связи
                             p_Action           IN     NUMBER,  -- Вид изменения на лоте
                             p_CalcInterest     IN     BOOLEAN, -- Расчитывать процентный доход
                             p_CalcDiscount     IN     BOOLEAN, -- Расчитывать дисконтный доход
                             p_CalcBonus        IN     BOOLEAN, -- Начислять премию
                             p_CalcDefDiff      IN     BOOLEAN, -- Начислять отсроченную разницу
                             p_CalcCorrIntToEIR IN     BOOLEAN, -- Начислять корректировку процентов до ЭСП
                             p_GrpID            IN     NUMBER   -- Группа обработки
                           )
   IS
     v_BuyLot             DPMWRTSUM_DBT%ROWTYPE;
     v_Link               DPMWRTLNK_DBT%ROWTYPE;
     v_All                DPMWRTBC_DBT%ROWTYPE;
     v_CurBuy             DPMWRTBC_DBT%ROWTYPE;
     v_BuyAmount          NUMBER;
     v_SL                 NUMBER;
     v_AmountRate         NUMBER;
     v_Amount             NUMBER;
     v_TMPLNKID           NUMBER;
     v_CalcDate           DATE;
     v_CDate              DATE;
     v_WrtInterest        NUMBER;
     v_Sum_Discount0_korr NUMBER;
     v_Sum_DefDiff0_korr  NUMBER;
     v_Discount0_korr     NUMBER;
     v_DefDiff0_korr      NUMBER;
     v_DlSumKind          NUMBER;
     v_FaceValueFI        NUMBER;
     TYPE LotsCurTyp IS REF CURSOR;
     Lots LotsCurTyp;
     v_Termless           CHAR;

     v_WrtDiscount        NUMBER;
     v_BegDiscount        NUMBER;
     v_DiscountIncome     NUMBER;
     v_DiscountDate       DATE;
     v_DS                 NUMBER;

     v_AllWrtDiscount        NUMBER;
     v_PrevWrtDiscount       NUMBER;

   BEGIN
     InitError();

     IF( p_SaleLot.t_Date < RsbSessionData.curdate ) THEN

        if( WRTAreChangesAfterDate( p_SALELOT.t_Department,
                                    p_SALELOT.T_FIID,
                                    p_SALELOT.T_PARTY,
                                    p_SALELOT.T_CONTRACT,
                                    UnknownValue,
                                    p_Group,
                                    p_SALELOT.T_DATE,
                                    UnknownTime,
                                    p_StartDate,
                                    1,
                                    p_SALELOT.T_COUPON,
                                    p_SALELOT.T_PARTLY
                                  ) = True ) then
           SetError( WRTOFF_ERROR_20201, to_char(p_SaleLot.t_SUMID) );
        END IF;
     END IF;

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Удалить все записи из DPMWRTLNK_TMP
     delete from DPMWRTLNK_TMP;

     v_Amount   := p_SaleLot.T_AMOUNT;
     v_TMPLNKID := 1;

     v_Sum_Discount0_korr := 0; v_Sum_DefDiff0_korr := 0;

     WHILE( v_Amount > 0 ) LOOP

        BEGIN
          IF SortingLotsAmount = SORTING_LOTS_AMOUNT_ASC THEN
            SELECT * INTO v_BuyLot
              FROM
              (
                SELECT /*+ INDEX( BuyLot DPMWRTSUM_DBT_IDXA)*/ BuyLot.*
                  FROM DPMWRTSUM_DBT BuyLot
                 WHERE BuyLot.t_Department = p_SaleLot.t_Department AND
                       BuyLot.t_FIID       = p_SaleLot.t_FIID AND
                       BuyLot.t_Party      = p_SaleLot.t_Party AND
                       BuyLot.t_GroupID    = p_Group AND
                       BuyLot.t_Contract   = p_SaleLot.t_Contract AND
                       BuyLot.t_IsFree     = 'X' AND
                       BuyLot.t_Date      <= p_SaleLot.t_Date  AND
                       ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (BuyLot.t_Date <= p_StartDate)) AND
                       ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (BuyLot.t_StateDate <= p_StartDate)) AND
                       ((BuyLot.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((BuyLot.T_ACTIVATEDATE = p_SaleLot.T_DATE) and (BuyLot.T_ACTIVATETIME <= p_SaleLot.T_TIME))) AND
                       BuyLot.t_Amount    > (SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
                                               FROM DPMWRTLNK_DBT  Link
                                              WHERE     Link.T_BUYID = BuyLot.T_SUMID
                                                    AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/, PMWRTLINK_KIND_RETPARTLY/*Частичное погашение*/)
                                                    AND Link.T_COUPON = p_SaleLot.T_COUPON
                                                    AND Link.T_PARTLY = p_SaleLot.T_PARTLY
                                             ) + (select NVL(SUM(TMP.T_AMOUNT),0)
                                                    from DPMWRTLNK_TMP TMP
                                                   where TMP.T_BUYID = BuyLot.T_SUMID)
                 AND NOT EXISTS (SELECT t_LnkID FROM DPMWRTLNK_DBT WHERE t_BuyID = BuyLot.t_SumID AND t_SaleID = p_SaleLot.t_SumID)
                ORDER BY t_Date ASC, t_Time ASC, T_DealDate ASC, T_SortCode ASC, T_Amount ASC
              )
             WHERE ROWNUM = 1;
           ELSE
             SELECT * INTO v_BuyLot
              FROM
              (
                SELECT /*+ INDEX( BuyLot DPMWRTSUM_DBT_IDXB)*/ BuyLot.*
                  FROM DPMWRTSUM_DBT BuyLot
                 WHERE BuyLot.t_Department = p_SaleLot.t_Department AND
                       BuyLot.t_FIID       = p_SaleLot.t_FIID AND
                       BuyLot.t_Party      = p_SaleLot.t_Party AND
                       BuyLot.t_GroupID    = p_Group AND
                       BuyLot.t_Contract   = p_SaleLot.t_Contract AND
                       BuyLot.t_IsFree     = 'X' AND
                       BuyLot.t_Date      <= p_SaleLot.t_Date  AND
                       ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (BuyLot.t_Date <= p_StartDate)) AND
                       ( (p_StartDate  = UnknownDate) OR (p_StartDate is NULL) OR (BuyLot.t_StateDate <= p_StartDate)) AND
                       ((BuyLot.T_ACTIVATEDATE < p_SaleLot.T_DATE) OR ((BuyLot.T_ACTIVATEDATE = p_SaleLot.T_DATE) and (BuyLot.T_ACTIVATETIME <= p_SaleLot.T_TIME))) AND
                       BuyLot.t_Amount    > (SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
                                               FROM DPMWRTLNK_DBT  Link
                                              WHERE     Link.T_BUYID = BuyLot.T_SUMID
                                                    AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/, PMWRTLINK_KIND_RETPARTLY/*Частичное погашение*/)
                                                    AND Link.T_COUPON = p_SaleLot.T_COUPON
                                                    AND Link.T_PARTLY = p_SaleLot.T_PARTLY
                                             ) + (select NVL(SUM(TMP.T_AMOUNT),0)
                                                    from DPMWRTLNK_TMP TMP
                                                   where TMP.T_BUYID = BuyLot.T_SUMID)
                 AND NOT EXISTS (SELECT t_LnkID FROM DPMWRTLNK_DBT WHERE t_BuyID = BuyLot.t_SumID AND t_SaleID = p_SaleLot.t_SumID)
                ORDER BY t_Date ASC, t_Time ASC, T_DealDate ASC, T_SortCode ASC, T_Amount DESC
              )
             WHERE ROWNUM = 1;
           END IF;
        EXCEPTION
           WHEN NO_DATA_FOUND THEN EXIT;--выходим именно из цикла, а не из процедуры (это важно - дальше нас ждет начисление ПДД и линковка)
           WHEN OTHERS THEN RETURN;
        END;

        SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
          INTO v_SL
          FROM DPMWRTLNK_DBT  Link
         WHERE     Link.T_BUYID = v_BuyLot.T_SUMID
               AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/, PMWRTLINK_KIND_RETPARTLY/*Частичное погашение*/)
               AND Link.T_COUPON = p_SaleLot.T_COUPON
               AND Link.T_PARTLY = p_SaleLot.T_PARTLY;

        INSERT INTO DPMWRTLNK_TMP
                   ( T_ID,
                     T_BUYID,
                     T_AMOUNT )
            VALUES ( v_TMPLNKID,
                     v_BuyLot.T_SUMID,
                     v_BuyLot.T_AMOUNT
                     );

        v_Amount   := v_Amount - (v_BuyLot.T_AMOUNT - v_SL);
        v_TMPLNKID := v_TMPLNKID + 1;

     END LOOP;

     IF( p_LinkKind = PMWRTLINK_KIND_RETPARTLY ) THEN
        v_CDate := RSI_RSB_FIInstr.FI_GetPartialDrawingDate( p_SaleLot.T_FIID, p_SaleLot.t_Partly );
     ELSE
        v_CDate := RSI_RSB_FIInstr.FI_GetCouponDrawingDate( p_SaleLot.T_FIID, p_SaleLot.t_Coupon );
     END IF;

     IF p_Method = PM_WRITEOFF_AVERAGE THEN
        SELECT t_Termless INTO v_Termless FROM DAVOIRISS_DBT WHERE t_FIID = p_SALELOT.T_FIID;
        v_CalcDate := CASE WHEN v_Termless = 'X' and p_SaleLot.T_DATE > RSI_RSB_FIInstr.FI_GetNominalDrawingDate(p_SALELOT.T_FIID, v_Termless)
                           THEN RSI_RSB_FIInstr.FI_GetNominalDrawingDate(p_SALELOT.T_FIID, v_Termless)
                           ELSE p_SaleLot.T_DATE END;
     ELSE
        v_CalcDate := v_CDate;
     END IF;

     IF( (p_Method <> PM_WRITEOFF_AVERAGE) and
         (p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or
          p_CalcDefDiff = true or p_CalcCorrIntToEIR = true) ) THEN

        --Выполнить начисление во временную таблицу
        --Фактически - начисление по всем группам лотов из DPMWRTLNK_TMP, а не по всем лотам покупки, как при начислении ПДД
        RSI_WRTChargeIncomToLotsTMP (true, p_SaleLot.T_DATE, v_CalcDate, p_SaleLot.T_FIID, p_SaleLot.T_Department, -1, -1, -1, -1, -1, p_SaleLot.T_PARTY, p_SaleLot.T_CONTRACT,
                                     p_CalcInterest,
                                     p_CalcDiscount,
                                     p_CalcBonus,
                                     p_CalcDefDiff,
                                     p_CalcCorrIntToEIR,
                                     p_Method,
                                     p_SaleLot.T_TRUST='X',
                                     p_LinkKind,
                                     p_SaleLot.T_COUPON
                                    );
     END IF;

     OPEN Lots FOR SELECT L.* INTO v_BUYLOT
                     FROM DPMWRTSUM_DBT L, DPMWRTLNK_TMP TMP
                    WHERE L.T_SUMID = TMP.T_BUYID
                   ORDER BY T_ID ASC;
     LOOP

        FETCH Lots INTO v_BUYLOT;
        EXIT WHEN Lots%NOTFOUND OR
                  Lots%NOTFOUND IS NULL;

        SELECT NVL(SUM(Link.T_AMOUNT),0) --в проекте T_AMOUNT - SL > 0
          INTO v_SL
          FROM DPMWRTLNK_DBT  Link
         WHERE     Link.T_BUYID = v_BuyLot.T_SUMID
               AND Link.T_KIND in (PMWRTLINK_KIND_RETCOUPON /*Погашение купона*/, PMWRTLINK_KIND_RETPARTLY/*Частичное погашение*/)
               AND Link.T_COUPON = p_SaleLot.T_COUPON
               AND Link.T_PARTLY = p_SaleLot.T_PARTLY;

        v_BuyAmount       := v_BuyLot.T_AMOUNT - v_SL;
        v_AmountRate      := v_BuyAmount / v_BuyLot.T_AMOUNT;

        v_WrtInterest := v_BuyLot.T_INTERESTINCOME;

        --При средневзвесе, если в ближайший рабочий день гасим купон, который попал на выходной день, 
        --то нужно списывать именно столько КД, сколько указано в погашении (на лотах начислено уже больше, т.к. было начисление по следующему купону)
        IF p_Method = PM_WRITEOFF_AVERAGE AND 
           v_CDate < v_CalcDate  AND 
           p_SaleLot.t_Coupon <> CHR(1) THEN

          IF v_BuyAmount = p_SaleLot.t_Amount THEN
            --Для последнего лота берем остаток НКД с лота погашения
            v_WrtInterest := p_SaleLot.t_NKDAmount;
          ELSE
            v_WrtInterest := ROUND(RSI_RSB_FIInstr.FI_CalcTotalIncome( p_SaleLot.T_FIID, p_SaleLot.t_Coupon, v_BuyAmount ), 2);
          END IF;

          v_WrtInterest := v_WrtInterest - v_BuyLot.T_NKDAMOUNT;

        END IF;

        v_WrtDiscount := v_BuyLot.T_DISCOUNTINCOME;

        --При средневзвесе, если в ближайший рабочий день гасим ЧП, которое попало на выходной день, 
        --то нужно списывать именно столько дисконта, сколько было бы, если бы ЧП гасили день в день
        IF p_Method = PM_WRITEOFF_AVERAGE AND 
           v_CDate < v_CalcDate  AND 
           p_SaleLot.t_Partly <> CHR(1) THEN
           
          --Определим, сколько списать дисконта по портфелю
          --Приходится вычислять каждый раз заново, т.к. лоты покупки не отсортированы по портфелю
          v_AllWrtDiscount := 0;
          FOR one_rec IN (SELECT NVL(SUM(V.T_BEGDISCOUNT),0) AllBegDiscount, NVL(SUM(V.T_DISCOUNTINCOME),0) AllDiscountIncome, V.T_DISCOUNTDATE 
                            FROM V_SCWRTHISTEX V, DPMWRTLNK_TMP TMP, DPMWRTSUM_DBT LOT
                           WHERE LOT.T_SUMID = TMP.T_BUYID
                             AND LOT.T_PORTFOLIO = v_BuyLot.T_PORTFOLIO
                             AND V.T_SUMID = TMP.T_BUYID
                             AND V.T_INSTANCE = (SELECT MAX(V1.T_INSTANCE)
                                                   FROM V_SCWRTHISTEX V1
                                                  WHERE V1.T_SUMID = V.T_SUMID
                                                    AND V1.T_CHANGEDATE <= v_CDate
                                                )
                          GROUP BY V.T_DISCOUNTDATE
                         )
          LOOP

            v_WrtDiscount := 0;
            IF (one_rec.AllBegDiscount - one_rec.AllDiscountIncome > 0) THEN
               
               --Вычисляем часть общего дисконта, прихдящуюся на погашаемое ЧП
               v_DS := ROUND(WRTCalcSumPart(p_SaleLot.T_FIID, p_SaleLot.t_Partly, one_rec.AllBegDiscount, v_CDate-1), 2);

               --Вычисляем сумму дисконта, которая была бы начислена по портфелю в дату погашения, если бы ЧП погашали день в день
               v_WrtDiscount := one_rec.AllDiscountIncome + ROUND(WRTCalcDiscountIncomeOnDate(v_CDate, v_CDate, one_rec.t_DiscountDate, p_SaleLot.T_FIID, one_rec.AllBegDiscount-one_rec.AllDiscountIncome, 1, p_Method), 2);
               
               --К списанию учитываем меньшую из этих двух сумм
               IF v_DS < v_WrtDiscount THEN
                 v_WrtDiscount := v_DS;
               END IF;
            END IF;

            v_AllWrtDiscount := v_AllWrtDiscount + v_WrtDiscount;
          END LOOP;

          --Определим сумму ранее списанного дисконта по портфелю по этому лоту погашения 
          SELECT NVL(SUM(T_BEGDISCOUNTCHANGE),0) INTO v_PrevWrtDiscount
            FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_DBT BUY
           WHERE LNK.T_SALEID = p_SaleLot.T_SUMID
             AND BUY.T_SUMID = LNK.T_BUYID
             AND BUY.T_PORTFOLIO = v_BuyLot.T_PORTFOLIO;

          --Определим сумму дисконта, которую осталось списать по портфелю
          v_AllWrtDiscount := v_AllWrtDiscount - v_PrevWrtDiscount;

          IF v_AllWrtDiscount > 0 THEN

            --Для каждого лота считаем свою сумму к списанию
            SELECT V.T_BEGDISCOUNT, V.T_DISCOUNTINCOME, V.T_DISCOUNTDATE
              INTO v_BegDiscount, v_DiscountIncome, v_DiscountDate
              FROM V_SCWRTHISTEX V
             WHERE V.T_SUMID = v_BuyLot.T_SUMID
               AND V.T_INSTANCE = (SELECT MAX(V1.T_INSTANCE)
                                     FROM V_SCWRTHISTEX V1
                                    WHERE V1.T_SUMID = V.T_SUMID
                                      AND V1.T_CHANGEDATE <= v_CDate
                                  );

            IF (v_BegDiscount - v_DiscountIncome <= 0) THEN
               v_WrtDiscount := 0;
            ELSE
               --Вычисляем часть дисконта, прихдящуюся на погашаемое ЧП
               v_DS := ROUND(WRTCalcSumPart(p_SaleLot.T_FIID, p_SaleLot.t_Partly, v_BegDiscount, v_CDate-1), 2);

               --Вычисляем сумму дисконта, которая была бы начислена по лоту в дату погашения, если бы ЧП погашали день в день
               v_WrtDiscount := v_DiscountIncome + ROUND(WRTCalcDiscountIncomeOnDate(v_CDate, v_CDate, v_DiscountDate, p_SaleLot.T_FIID, v_BegDiscount-v_DiscountIncome, 1, p_Method), 2);

               --К списанию будет меньшая из этих двух сумм
               IF v_DS < v_WrtDiscount THEN
                 v_WrtDiscount := v_DS;
               END IF;
            END IF;

            --Если по лоту сумму списания больше, чем остаток несписанного дисконта по порфтелю, то списываем только этот остаток
            IF v_AllWrtDiscount < v_WrtDiscount THEN
              v_WrtDiscount := v_AllWrtDiscount;
            END IF;
          END IF;
        END IF;

        v_BuyLot.T_AMOUNT           := v_BuyAmount;
        v_BuyLot.T_COST             := ROUND(v_BuyLot.T_COST * v_AmountRate,2);
        v_BuyLot.T_BALANCECOST      := ROUND(v_BuyLot.T_BALANCECOST * v_AmountRate,2);
        v_BuyLot.T_NKDAMOUNT        := ROUND(v_BuyLot.T_NKDAMOUNT * v_AmountRate,2);
        v_BuyLot.T_INTERESTINCOME   := ROUND(v_WrtInterest * v_AmountRate,2);
        v_BuyLot.T_NOTCARRYINTEREST := ROUND(v_BuyLot.T_NOTCARRYINTEREST * v_AmountRate,2);
        v_BuyLot.T_BEGDISCOUNT      := ROUND(v_BuyLot.T_BEGDISCOUNT * v_AmountRate,2);
        v_BuyLot.T_OLDBEGDISCOUNT   := ROUND(v_BuyLot.T_OLDBEGDISCOUNT * v_AmountRate,2);
        v_BuyLot.T_DISCOUNTCORR     := ROUND(v_BuyLot.T_DISCOUNTCORR * v_AmountRate,2);
        v_BuyLot.T_DISCOUNTINCOME   := ROUND(v_WrtDiscount * v_AmountRate,2);
        v_BuyLot.T_NOTCARRYDISCOUNT := ROUND(v_BuyLot.T_NOTCARRYDISCOUNT * v_AmountRate,2);
        v_BuyLot.T_BEGBONUS         := ROUND(v_BuyLot.T_BEGBONUS * v_AmountRate,2);
        v_BuyLot.T_OLDBEGBONUS      := ROUND(v_BuyLot.T_OLDBEGBONUS * v_AmountRate,2);
        v_BuyLot.T_BONUS            := ROUND(v_BuyLot.T_BONUS * v_AmountRate,2);
        v_BuyLot.T_OLDBONUS         := ROUND(v_BuyLot.T_OLDBONUS * v_AmountRate,2);
        v_BuyLot.T_OUTLAY           := ROUND(v_BuyLot.T_OUTLAY * v_AmountRate,2);
        v_BuyLot.T_NOTWRTBONUS      := ROUND(v_BuyLot.T_NOTWRTBONUS * v_AmountRate,2);
        v_BuyLot.T_COSTPFI          := ROUND(v_BuyLot.T_COSTPFI * v_AmountRate,2);
        v_BuyLot.T_AMORTCOST        := ROUND(v_BuyLot.T_AMORTCOST * v_AmountRate,2);
        v_BuyLot.T_CORRINTTOEIR     := ROUND(v_BuyLot.T_CORRINTTOEIR * v_AmountRate,2);
        v_BuyLot.T_BEGDEFDIFF       := ROUND(v_BuyLot.T_BEGDEFDIFF * v_AmountRate,2);
        v_BuyLot.T_ACCOUNTEDDEFDIFF := ROUND(v_BuyLot.T_ACCOUNTEDDEFDIFF * v_AmountRate,2);

        -- выполнить списание
        v_Link.t_LnkID               := 0;
        v_Link.t_SaleID              := p_SaleLot.t_SumID;
        v_Link.t_BuyID               := v_BuyLot.t_SumID;
        v_Link.t_Kind                := p_LinkKind;
        v_Link.t_InterestIncomeAdd   := 0;
        v_Link.t_DiscountIncomeAdd   := 0;
        v_Link.t_DiscountIncomeBuy   := 0;
        v_Link.t_BonusBuy            := 0;
        v_Link.t_OldBonusBuy         := 0;
        v_Link.t_BonusAdd            := 0;
        v_Link.t_OutlaySale          := 0;
        v_Link.t_ReservChange        := 0;
        v_Link.t_IncomeReservChange  := 0;
        v_Link.t_OverChange          := 0;
        v_Link.t_BalanceCostBD       := 0;
        v_Link.t_OverChangeBD        := 0;
        v_Link.t_BlockAmountBuy      := 0;
        v_Link.t_Coupon              := p_SaleLot.t_Coupon;
        v_Link.t_Partly              := p_SaleLot.t_Partly;
        v_Link.t_ID_Operation        := p_ID_Operation;
        v_Link.t_ID_Step             := p_ID_Step;
        v_Link.t_Action              := p_Action;
        v_Link.t_CreateDate          := p_SaleLot.t_Date;
        v_Link.T_ACCOUNTEDDEFDIFFADD := 0;
        v_Link.T_ACCOUNTEDDEFDIFFBUY := 0;
        v_Link.T_BEGDEFDIFFCHANGE    := 0;
        v_Link.T_WRTOUTLAYADD        := 0;
        v_Link.T_WRTOUTLAYBUY        := 0;
        v_Link.T_WRTVATOUTLAYADD     := 0;
        v_Link.T_WRTVATOUTLAYBUY     := 0;
        v_Link.T_VATOUTLAYCHANGE     := 0;
        v_Link.T_FAIRVALUECHANGE     := 0;
        v_Link.T_AMORTCOSTCHANGE     := 0;
        v_Link.T_CORRVALUECHANGE     := 0;
        v_Link.T_ESTRESERVCHANGE     := 0;
        v_Link.T_CORRINTTOEIRCHANGE  := 0;
        v_Link.T_CORRESTRESERVCHANGE := 0;
        v_Link.T_CORRINTTOEIRADD     := 0;
        v_Link.T_ESTRESERVEADD       := 0;
        v_Link.T_CORRESTRESERVEADD   := 0;
        v_Link.T_RESERVADD           := 0;
        v_Link.T_INCOMERESERVADD     := 0;
        v_Link.T_OVERAMOUNTADD       := 0;
        v_Link.T_COSTBUYNAT          := 0;
        v_Link.T_ADDINCOMEOWNCHANGE  := 0;
        v_Link.T_HEDGCORRCHANGE      := 0;
        v_Link.T_AMORTHEDGCORRCHANGE := 0;

        IF( v_BuyLot.t_Amount <= p_SaleLot.t_Amount ) THEN   -- списать покупку полностью
           v_AmountRate                 := v_BuyLot.t_Amount / p_SaleLot.t_Amount;

           v_Link.t_Amount              := v_BuyLot.t_Amount;
           v_Link.t_SumSale             := ROUND(p_SaleLot.t_Sum * v_AmountRate,2);
           v_Link.t_SumBuy              := 0;
           v_Link.t_CostSale            := ROUND(p_SaleLot.t_Cost * v_AmountRate,2);
           v_Link.t_CostBuy             := v_Link.t_CostSale;
           v_Link.t_NKDSaleAmount       := ROUND(p_SaleLot.t_NKDAmount * v_AmountRate,2);

           IF (p_SaleLot.t_Coupon != chr(1)) THEN
              IF v_BuyLot.t_PORTFOLIO = KINDPORT_BACK THEN
                 v_Link.t_NKDBuyAmount     := 0;
              ELSE
                 v_Link.t_NKDBuyAmount        := v_BuyLot.t_NKDAmount;
              END IF;

              v_Link.t_InterestIncomeBuy   := v_BuyLot.t_InterestIncome;
              v_Link.t_NotCarryInterestBuy := v_BuyLot.t_NotCarryInterest;
              v_Link.T_OLDBEGBONUSCHANGE   := v_BuyLot.T_OLDBEGBONUS;
           ELSE
              v_Link.t_NKDBuyAmount        := 0;
              v_Link.t_InterestIncomeBuy   := 0;
              v_Link.t_NotCarryInterestBuy := 0;
              v_Link.T_OLDBEGBONUSCHANGE   := 0;
           END IF;

           IF (p_SaleLot.t_Partly != chr(1)) THEN
              v_Link.t_NotCarryDiscountBuy := v_BuyLot.t_NotCarryDiscount;
              v_Link.t_BegDiscountChange   := v_BuyLot.t_BegDiscount;
              v_Link.t_OldBegDiscountChange:= v_BuyLot.t_OldBegDiscount;
              v_Link.T_DISCOUNTCORRCHANGE  := v_BuyLot.T_DISCOUNTCORR;
              v_Link.T_DISCOUNTINCOMEBUY   := v_BuyLot.t_DiscountIncome;
              --v_Link.T_COSTPFIBUY          := v_BuyLot.T_COSTPFI;
              v_Link.T_BEGDEFDIFFCHANGE    := v_BuyLot.T_BEGDEFDIFF;
              v_Link.T_AMORTCOSTCHANGE     := v_BuyLot.T_AMORTCOST;
              v_Link.T_CORRINTTOEIRCHANGE  := v_BuyLot.T_CORRINTTOEIR;
           ELSE
              v_Link.t_NotCarryDiscountBuy := 0;
              v_Link.t_BegDiscountChange   := 0;
              v_Link.t_OldBegDiscountChange:= 0;
              v_Link.T_DISCOUNTCORRCHANGE  := 0;
              v_Link.T_DISCOUNTINCOMEBUY   := 0;
              v_Link.t_BegBonusChange      := 0;
           END IF;

           v_Link.t_OutlayBuy           := 0;
           IF v_BuyLot.t_PORTFOLIO = KINDPORT_BACK THEN
             v_Link.t_BalanceCostBuy      := 0;
           ELSE
             v_Link.t_BalanceCostBuy      := v_Link.t_CostSale + v_Link.t_NKDSaleAmount/*v_Link.t_CostBuy + v_Link.t_NKDBuyAmount + v_Link.t_InterestIncomeBuy*/;
           END IF;
           v_Link.t_BalanceCostSale     := ROUND(p_SaleLot.t_BalanceCost * v_AmountRate,2);
           v_Link.T_NOTWRTBONUSBUY      := 0;
        ELSE
           v_AmountRate                 := p_SaleLot.t_Amount / v_BuyLot.t_Amount;

           v_Link.t_Amount              := p_SaleLot.t_Amount;
           v_Link.t_SumSale             := p_SaleLot.t_Sum;
           v_Link.t_SumBuy              := 0;
           v_Link.t_CostSale            := p_SaleLot.t_Cost;
           v_Link.t_CostBuy             := v_Link.t_CostSale;
           v_Link.t_NKDSaleAmount       := p_SaleLot.t_NKDAmount;

           IF (p_SaleLot.t_Coupon != chr(1)) THEN
              IF v_BuyLot.t_PORTFOLIO = KINDPORT_BACK THEN
                 v_Link.t_NKDBuyAmount     := 0;
              ELSE
                 v_Link.t_NKDBuyAmount     := ROUND(v_BuyLot.t_NKDAmount * v_AmountRate,2);
              END IF;
              v_Link.t_InterestIncomeBuy   := ROUND(v_BuyLot.t_InterestIncome * v_AmountRate,2);
              v_Link.t_NotCarryInterestBuy := ROUND(v_BuyLot.t_NotCarryInterest * v_AmountRate,2);
              v_Link.t_BegBonusChange      := ROUND(v_BuyLot.t_BegBonus * v_AmountRate,2);
              v_Link.T_OLDBEGBONUSCHANGE   := ROUND(v_BuyLot.T_OLDBEGBONUS * v_AmountRate,2);
           ELSE
              v_Link.t_NKDBuyAmount        := 0;
              v_Link.t_InterestIncomeBuy   := 0;
              v_Link.t_NotCarryInterestBuy := 0;
              v_Link.t_BegBonusChange      := 0;
              v_Link.T_OLDBEGBONUSCHANGE   := 0;
           END IF;

           IF (p_SaleLot.t_Partly != chr(1)) THEN
              v_Link.t_NotCarryDiscountBuy := ROUND(v_BuyLot.t_NotCarryDiscount * v_AmountRate,2);
              v_Link.t_BegDiscountChange   := ROUND(v_BuyLot.t_BegDiscount * v_AmountRate,2);
              v_Link.t_OldBegDiscountChange:= ROUND(v_BuyLot.t_OldBegDiscount * v_AmountRate,2);
              v_Link.T_DISCOUNTCORRCHANGE  := ROUND(v_BuyLot.T_DISCOUNTCORR * v_AmountRate,2);
              v_Link.T_DISCOUNTINCOMEBUY   := ROUND(v_BuyLot.t_DiscountIncome * v_AmountRate,2);
              --v_Link.T_COSTPFIBUY          := ROUND(v_BuyLot.T_COSTPFI * v_AmountRate,2);
              v_Link.T_BEGDEFDIFFCHANGE    := ROUND(v_BuyLot.T_BEGDEFDIFF * v_AmountRate,2);
              v_Link.T_AMORTCOSTCHANGE     := ROUND(v_BuyLot.T_AMORTCOST * v_AmountRate,2);
              v_Link.T_CORRINTTOEIRCHANGE  := ROUND(v_BuyLot.T_CORRINTTOEIR * v_AmountRate,2);
           ELSE
              v_Link.t_NotCarryDiscountBuy := 0;
              v_Link.t_BegDiscountChange   := 0;
              v_Link.t_OldBegDiscountChange:= 0;
              v_Link.T_DISCOUNTCORRCHANGE  := 0;
              v_Link.T_DISCOUNTINCOMEBUY   := 0;
              v_Link.T_COSTPFIBUY          := 0;
              v_Link.T_BEGDEFDIFFCHANGE    := 0;
              v_Link.T_AMORTCOSTCHANGE     := 0;
              v_Link.T_CORRINTTOEIRCHANGE  := 0;
           END IF;

           v_Link.t_OutlayBuy           := 0;
           IF v_BuyLot.t_PORTFOLIO = KINDPORT_BACK THEN
             v_Link.t_BalanceCostBuy      := 0;
           ELSE
             v_Link.t_BalanceCostBuy      := v_Link.t_CostSale + v_Link.t_NKDSaleAmount/*v_Link.t_CostBuy + v_Link.t_NKDBuyAmount + v_Link.t_InterestIncomeBuy*/;
           END IF;
           v_Link.t_BalanceCostSale     := p_SaleLot.t_BalanceCost;
           v_Link.T_NOTWRTBONUSBUY      := 0;
        END IF;

        IF( p_CalcInterest = true or p_CalcDiscount = true or p_CalcBonus = true or
            p_CalcDefDiff = true or p_CalcCorrIntToEIR = true ) THEN
           RSI_WRTChangeIncomeOnWrt(v_Link, v_BuyLot,
                                p_CalcInterest, p_CalcDiscount, p_CalcBonus, p_CalcDefDiff, p_CalcCorrIntToEIR,
                                p_Method, v_CalcDate, v_Discount0_korr, v_DefDiff0_korr);
           v_Sum_Discount0_korr := v_Sum_Discount0_korr + v_Discount0_korr;
           v_Sum_DefDiff0_korr  := v_Sum_DefDiff0_korr + v_DefDiff0_korr;
        END IF;

        IF( p_SaleLot.t_Partly != chr(1) and v_BuyLot.t_Cost > 0) THEN
           v_Link.t_OutlayBuy := ROUND(v_Link.t_CostBuy * v_BuyLot.t_Outlay / v_BuyLot.t_Cost,2);
        END IF;

        BEGIN
           RSI_InsDfltIntoWRTLNK(v_Link);
           INSERT INTO DPMWRTLNK_DBT VALUES v_Link;

           p_SaleLot.t_Amount      := p_SaleLot.t_Amount    - v_Link.t_Amount;
           p_SaleLot.t_Sum         := p_SaleLot.t_Sum       - v_Link.t_SumSale;
           p_SaleLot.t_Cost        := p_SaleLot.t_Cost      - v_Link.t_CostSale;
           p_SaleLot.t_BalanceCost := p_SaleLot.t_BalanceCost - v_Link.t_BalanceCostSale;
           p_SaleLot.t_NKDAmount   := p_SaleLot.t_NKDAmount - v_Link.t_NKDSaleAmount;
        END;

     END LOOP;

     CLOSE Lots;

     -- создать запись dlsum. Нужна для проводки
     if( (v_Sum_DefDiff0_korr > 0 or v_Sum_Discount0_korr > 0) and
         p_Group in(KINDPORT_TRADE,KINDPORT_SALE,KINDPORT_RETIRE) )then
        SELECT FIN.T_FACEVALUEFI
          INTO v_FaceValueFI
          FROM DFININSTR_DBT FIN
         WHERE FIN.T_FIID = p_SaleLot.t_FIID;

         if( v_Sum_DefDiff0_korr <> 0 )then
           v_DlSumKind := 0;

           if( p_Group = KINDPORT_TRADE )then
              v_DlSumKind := RSB_SECUR.DLSUM_SUM_DEFDIFF0_KORR_TP;
           elsif( p_Group = KINDPORT_SALE  )then
              v_DlSumKind := RSB_SECUR.DLSUM_SUM_DEFDIFF0_KORR_PPR;
           elsif( p_Group = KINDPORT_RETIRE )then
              v_DlSumKind := RSB_SECUR.DLSUM_SUM_DEFDIFF0_KORR_PUDP;
           end if;

           INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                           VALUES (0, Rsb_Secur.DL_RETIREMENT, p_SaleLot.t_DealID, v_DlSumKind, p_SaleLot.t_Date, v_Sum_DefDiff0_korr, 0, v_FaceValueFI, CHR(0), 0, p_GRPID, p_SALELOT.T_FIID);
        end if;

        if( v_Sum_Discount0_korr > 0 )then
           v_DlSumKind := 0;

           if( p_Group = KINDPORT_TRADE )then
              v_DlSumKind := RSB_SECUR.DLSUM_SUM_DISCOUNT0_KORR_TP;
           elsif( p_Group = KINDPORT_SALE  )then
              v_DlSumKind := RSB_SECUR.DLSUM_SUM_DISCOUNT0_KORR_PPR;
           elsif( p_Group = KINDPORT_RETIRE )then
              v_DlSumKind := RSB_SECUR.DLSUM_SUM_DISCOUNT0_KORR_PUDP;
           end if;

           INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                           VALUES (0, Rsb_Secur.DL_RETIREMENT, p_SaleLot.t_DealID, v_DlSumKind, p_SaleLot.t_Date, v_Sum_Discount0_korr, 0, v_FaceValueFI, CHR(0), 0, p_GRPID, p_SALELOT.T_FIID);
        end if;
     end if;

   END; -- RSI_WRTLinkWrt

   -- Возвращает остаток ц/б по портфелю (группе списания) на дату
   FUNCTION WRTGetPortfolioAmount( Department     IN NUMBER, -- Филиал.  Если не задан (UnknounValue(-1)) игнорируется
                                   FIID           IN NUMBER, -- ц/б
                                   Party          IN NUMBER, -- Владелец
                                   Contract       IN NUMBER, -- Договор обслуживания
                                   Portfolio      IN NUMBER, -- Портфель.  Если не задан (UnknounValue(-1)) игнорируется
                                   pGroup         IN NUMBER, -- Группа списания (портфель)
                                   CalcDate       IN DATE,   -- Дата расчета
                                   Delivered      IN NUMBER, -- Отбирать поставленные (1 или 0)
                                   NotDelivered   IN NUMBER, -- Отбирать непоставленные (1 или 0)
                                   WithoutAccept  IN NUMBER,  -- Отбирать проданные БПП
                                   IsTrust        IN NUMBER DEFAULT -1 -- Признак ДУ. Если не задан (-1), игнорируется
                                 ) RETURN NUMBER DETERMINISTIC
   IS
      v_Amount  NUMBER := 0;
      v_Amount1 NUMBER := 0;
      v_Amount2 NUMBER := 0;
      PartyID  NUMBER := Party;


      FUNCTION UseClientLotsInPMWRTSUM RETURN NUMBER
      IS
        v_cnt NUMBER := 0;
      BEGIN

        SELECT COUNT(1) INTO v_cnt
          FROM DPMWRTSUM_DBT
         WHERE T_PARTY > 0
           AND T_CONTRACT > 0
           AND T_AMOUNT > 0
           AND ROWNUM = 1;

        RETURN v_cnt;
      END;

   BEGIN

      if( Party = RsbSessionData.OurBank ) then
         PartyID := -1;
      end if;

      IF Portfolio = KINDPORT_CLIENT THEN
        IF Delivered <> 0 AND IsTrust <= 0 THEN
          v_Amount := WRTGetAmountByClient(Department, FIID, Party, Contract, CalcDate);
        END IF;
      ELSE

        if( CalcDate = RsbSessionData.curdate ) then
            SELECT /*+ index(l DPMWRTSUM_DBT_IDX3 ) */ NVL(SUM( t_Amount ),0)
              INTO v_Amount
              FROM DPMWRTSUM_DBT l
             WHERE     (Department = UnknownValue or t_Department = Department)
                   AND t_FIID       = FIID
                   AND ( (PartyID = 0) OR (PartyID is NULL) OR (t_Party = PartyID) )
                   AND ((pGroup    = UnknownValue) OR (pGroup    is NULL) OR (t_GroupID = pGroup))
                   AND t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
                   AND t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE t_Portfolio END)
                   AND ((t_Contract  = Contract) OR (Contract = -1))
                   AND ((t_Trust  = 'X') OR (IsTrust = -1) OR ((t_Trust  <> 'X') AND (IsTrust = 0)))
                   AND t_Buy_Sale   in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
                   AND t_Amount     > 0
                   AND ( (Delivered    = 1 AND t_State = PM_WRTSUM_FORM) OR
                         (NotDelivered = 1 AND t_State = PM_WRTSUM_NOTFORM) OR
                         (WithoutAccept   = 1 AND t_State = PM_WRTSUM_SALE_BPP)
                       );

            IF ((Portfolio = UnknownValue) OR (Portfolio is NULL)) AND Delivered <> 0 AND IsTrust <= 0 AND UseClientLotsInPMWRTSUM() = 0 THEN
              v_Amount := v_Amount + WRTGetAmountByClient(Department, FIID, Party, Contract, CalcDate);
            END IF;
        else
            SELECT /*+ index(l DPMWRTSUM_DBT_IDX3 ) */ NVL(SUM( t_Amount ), 0)
              INTO v_Amount1
              FROM DPMWRTSUM_DBT l
             WHERE     (Department = UnknownValue or t_Department = Department)
                   AND t_FIID       = FIID
                   AND ( (PartyID = 0) OR (PartyID is NULL) OR (t_Party = PartyID) )
                   AND ((pGroup    = UnknownValue) OR (pGroup    is NULL) OR (t_GroupID = pGroup))
                   AND t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
                   AND t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE t_Portfolio END)
                   AND ((t_Contract  = Contract) OR (Contract = -1))
                   AND ((t_Trust  = 'X') OR (IsTrust = -1) OR ((t_Trust  <> 'X') AND (IsTrust = 0)))
                   AND t_Buy_Sale   in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
                   AND T_CHANGEDATE <= CalcDate
                   AND t_Amount     > 0
                   AND ( (Delivered    = 1 AND t_State = PM_WRTSUM_FORM) OR
                         (NotDelivered = 1 AND t_State = PM_WRTSUM_NOTFORM) OR
                         (WithoutAccept   = 1 AND t_State = PM_WRTSUM_SALE_BPP)
                       );

            if( NotDelivered = 1 ) then
               SELECT  NVL(SUM( B.t_Amount ), 0)
                 INTO v_Amount2
                 FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
                WHERE     (Department = UnknownValue or L.t_Department = Department)
                      AND ( (PartyID = 0) OR (PartyID is NULL) OR (L.t_Party = PartyID) )
                      AND ((L.t_Contract  = Contract) OR (Contract = -1))
                      AND ((L.t_Trust  = 'X') OR (IsTrust = -1) OR ((L.t_Trust  <> 'X') AND (IsTrust = 0)))
                      AND L.t_Buy_Sale   in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
                      AND L.T_CHANGEDATE >  CalcDate
                      AND L.T_EnterDate  <= CalcDate
                      AND B.t_FIID = FIID -- !!! Для непоставленных лотов ФИ может меняться, проверяем в истории
                      AND B.T_SUMID      = L.T_SUMID
                      AND ((pGroup    = UnknownValue) OR (pGroup    is NULL) OR (B.t_GroupID = pGroup))
                      AND B.t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
                      AND B.t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE B.t_Portfolio END)
                      AND ( (Delivered    = 1 AND B.t_State = PM_WRTSUM_FORM) OR
                            (B.t_State = PM_WRTSUM_NOTFORM) OR
                            (WithoutAccept   = 1 AND B.t_State = PM_WRTSUM_SALE_BPP)
                          )
                      AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                             FROM DPMWRTBC_DBT M
                                            WHERE     M.T_CHANGEDATE <= CalcDate
                                                  AND M.T_SUMID      = L.T_SUMID
                                         );
            else
               SELECT /*+ index(l DPMWRTSUM_DBT_IDX10 ) */ NVL(SUM( B.t_Amount ), 0)
                 INTO v_Amount2
                 FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
                WHERE     (Department = UnknownValue or L.t_Department = Department)
                      AND ( (PartyID = 0) OR (PartyID is NULL) OR (L.t_Party = PartyID) )
                      AND ((L.t_Contract  = Contract) OR (Contract = -1))
                      AND ((L.t_Trust  = 'X') OR (IsTrust = -1) OR ((L.t_Trust  <> 'X') AND (IsTrust = 0)))
                      AND L.t_Buy_Sale   in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
                      AND L.T_CHANGEDATE >  CalcDate
                      AND L.T_EnterDate  <= CalcDate
                      AND L.t_FIID = FIID
                      AND B.T_SUMID      = L.T_SUMID
                      AND ((pGroup    = UnknownValue) OR (pGroup    is NULL) OR (B.t_GroupID = pGroup))
                      AND B.t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
                      AND B.t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE B.t_Portfolio END)
                      AND ( (Delivered    = 1 AND B.t_State = PM_WRTSUM_FORM) OR
                            (WithoutAccept   = 1 AND B.t_State = PM_WRTSUM_SALE_BPP)
                          )
                      AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                             FROM DPMWRTBC_DBT M
                                            WHERE     M.T_CHANGEDATE <= CalcDate
                                                  AND M.T_SUMID      = L.T_SUMID
                                         );
            end if;

            v_Amount := v_Amount1 + v_Amount2;

            IF ((Portfolio = UnknownValue) OR (Portfolio is NULL)) AND Delivered <> 0 AND IsTrust <= 0 AND UseClientLotsInPMWRTSUM() = 0 THEN
              v_Amount := v_Amount + WRTGetAmountByClient(Department, FIID, Party, Contract, CalcDate);
            END IF;
        end if;
      END IF;

      return v_Amount;
   END; -- WRTGetPortfolioAmount

   -- Возвращает остаток ц/б на лотах ОЭБ на дату.
   FUNCTION WRTGetAmountOwn( Department     IN NUMBER, -- Филиал.  Если не задан (UnknounValue(-1)) игнорируется
                             FIID           IN NUMBER, -- ц/б
                             CalcDate       IN DATE,   -- Дата расчета
                             Placed         IN NUMBER, -- Отбирать размещенные (1 или 0)
                             Redeemed       IN NUMBER  -- Отбирать выкупленные (1 или 0)
                           ) RETURN NUMBER DETERMINISTIC
   IS
      v_Amount  NUMBER := 0;
      v_Amount1 NUMBER := 0;
      v_Amount2 NUMBER := 0;
   BEGIN

      if( CalcDate = RsbSessionData.curdate ) then
          SELECT NVL(SUM( t_Amount ),0)
            INTO v_Amount
            FROM DPMWRTSUM_DBT
           WHERE     (Department  = UnknownValue or t_Department = Department)
                 AND t_FIID       = FIID
                 AND t_Party      = UnknownParty
                 AND t_Amount     > 0
                 AND ( (Placed    = 1 AND t_State = PM_WRTSUM_PLACE_OWN) OR
                       (Redeemed  = 1 AND t_State = PM_WRTSUM_BUYOUT_OWN)
                     );
      else
          SELECT NVL(SUM( t_Amount ), 0)
            INTO v_Amount1
            FROM DPMWRTSUM_DBT
           WHERE     (Department  = UnknownValue or t_Department = Department)
                 AND t_FIID       = FIID
                 AND t_Party      = UnknownParty
                 AND T_CHANGEDATE <= CalcDate
                 AND t_Amount     > 0
                 AND ( (Placed    = 1 AND t_State = PM_WRTSUM_PLACE_OWN) OR
                       (Redeemed  = 1 AND t_State = PM_WRTSUM_BUYOUT_OWN)
                     );

          SELECT NVL(SUM( B.t_Amount ), 0)
            INTO v_Amount2
            FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
           WHERE     (Department  = UnknownValue or L.t_Department = Department)
                 AND t_Party      = UnknownParty
                 AND L.T_CHANGEDATE >  CalcDate
                 AND L.T_EnterDate  <= CalcDate
                 AND B.t_FIID     = FIID
                 AND B.T_SUMID    = L.T_SUMID
                 AND ( (Placed    = 1 AND B.t_State = PM_WRTSUM_PLACE_OWN) OR
                       (Redeemed  = 1 AND B.t_State = PM_WRTSUM_BUYOUT_OWN)
                     )
                 AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                        FROM DPMWRTBC_DBT M
                                       WHERE     M.T_CHANGEDATE <= CalcDate
                                             AND M.T_SUMID      = L.T_SUMID
                                    );

          v_Amount := v_Amount1 + v_Amount2;
      end if;

      return v_Amount;
   END; -- WRTGetAmountOwn

   FUNCTION CheckDealORCB( DealID IN NUMBER, ORCB IN NUMBER ) RETURN NUMBER DETERMINISTIC
   IS
      DealFlag1 CHAR;
   BEGIN
      if( ORCB is NULL OR ORCB < 0 ) then
         return 1;
      end if;

      if( DealID is NULL OR DealID <= 0 ) then
         return 0;
      end if;

      BEGIN
         SELECT t_Flag1
           INTO DealFlag1
           FROM ddl_tick_dbt
          WHERE t_DealID = DealID;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN return 0;
      END;

      if( (ORCB > 0 AND DealFlag1 = 'X') OR
          (ORCB = 0 AND DealFlag1 != 'X')
        ) then
        return 1;
      end if;

      return 0;
   END;

   -- Возвращает к-во и суммы по портфелю (группе списания) на дату. Обрабатывает только поставленные лоты.
   PROCEDURE RSI_GetPortfolioCost( Department        IN NUMBER, -- Филиал. Если -1, то игнорируется
                                  FIID           IN NUMBER, -- ц/б
                                  p_Party        IN NUMBER, -- Владелец
                                  Contract       IN NUMBER, -- Договор обслуживания
                                  Portfolio      IN NUMBER, -- Портфель
                                  CalcDate       IN DATE,   -- Дата расчета
                                  CalcTime       IN DATE,   -- Время расчета. Если не задано - игнорируется.
                                  StartDate      IN DATE,   -- Дата отбора лотов покупки. Если не задана  - игнорируется
                                  Delivered      IN NUMBER, -- Отбирать поставленные
                                  WithoutAccept     IN NUMBER, -- Отбирать проданные БПП
                                  DealORCB       IN NUMBER, -- Только лоты покупки по сделкам ОРЦБ
                                  EndDate        IN DATE,   -- Дата окончания расчета (аналог StartDate)
                                  CalcSumm       OUT DPMWRTSUM_DBT%ROWTYPE, -- выходные значения сумм
                                  IsTrust        IN NUMBER DEFAULT -1 -- Признак ДУ. Если не задан (-1), игнорируется
                                )
   IS
      CalcSummBC  DPMWRTSUM_DBT%ROWTYPE;
      Party       NUMBER := p_Party;
      v_Method    NUMBER := -1;
      
      v_where     VARCHAR2(32000);
      v_cursor_id NUMBER;
      v_dummy     PLS_INTEGER;
      v_cur       sys_refcursor;
   BEGIN

      if( Party = RsbSessionData.OurBank ) then
         Party := -1;
      end if;

      if (Party = -1 and Contract = 0) then
         v_Method := GetAmortizationMethod( -1, 0 );
      end if;

      IF Portfolio = KINDPORT_CLIENT THEN
        CalcSumm.T_AMOUNT            := 0;
        CalcSumm.T_COST              := 0;
        CalcSumm.T_BALANCECOST       := 0;
        CalcSumm.T_NKDAMOUNT         := 0;
        CalcSumm.T_INTERESTINCOME    := 0;
        CalcSumm.T_NOTCARRYINTEREST  := 0;
        CalcSumm.T_DISCOUNTINCOME    := 0;
        CalcSumm.T_NOTCARRYDISCOUNT  := 0;
        CalcSumm.T_BONUS             := 0;
        CalcSumm.T_OUTLAY            := 0;
        CalcSumm.T_RESERVAMOUNT      := 0;
        CalcSumm.T_INCOMERESERV      := 0;
        CalcSumm.T_OVERAMOUNT        := 0;
        CalcSumm.T_OLDBONUS          := 0;
        CalcSumm.T_BEGBONUS          := 0;
        CalcSumm.t_NotWrtBonus       := 0;
        CalcSumm.t_COSTPFI           := 0;

        IF Delivered <> 0 AND IsTrust <= 0 THEN
          CalcSumm.T_AMOUNT := WRTGetAmountByClient(Department, FIID, Party, Contract, CalcDate);
        END IF;
      ELSE
        /*SELECT NVL(SUM(T_AMOUNT), 0),
                   NVL(SUM(ROUND(T_COST,2)), 0),
                   NVL(SUM(ROUND(T_BALANCECOST,2)), 0),
                   NVL(SUM(ROUND(T_NKDAMOUNT,2)), 0),
                   NVL(SUM(ROUND(T_INTERESTINCOME,2)), 0),
                   NVL(SUM(ROUND(T_NOTCARRYINTEREST,2)), 0),
                   NVL(SUM(ROUND(T_DISCOUNTINCOME,2)), 0),
                   NVL(SUM(ROUND(T_NOTCARRYDISCOUNT,2)), 0),
                   NVL(SUM(ROUND(T_BONUS,2)), 0),
                   NVL(SUM(ROUND(T_OUTLAY,2)), 0),
                   NVL(SUM(ROUND(T_RESERVAMOUNT,2)), 0),
                   NVL(SUM(ROUND(T_INCOMERESERV,2)), 0),
                   NVL(SUM(ROUND(T_OVERAMOUNT,2)), 0),
                   NVL(SUM(ROUND(T_OLDBONUS,2)), 0),
                   NVL(SUM(ROUND(T_BEGBONUS,2)) - SUM(ROUND(T_BONUS,2)) + SUM(ROUND(T_OLDBONUS,2)), 0),
                   NVL(SUM(ROUND(T_NOTWRTBONUS,2)), 0),
                   NVL(SUM(ROUND(T_COSTPFI,2)), 0)
              INTO CalcSumm.T_AMOUNT,
                   CalcSumm.T_COST,
                   CalcSumm.T_BALANCECOST,
                   CalcSumm.T_NKDAMOUNT,
                   CalcSumm.T_INTERESTINCOME,
                   CalcSumm.T_NOTCARRYINTEREST,
                   CalcSumm.T_DISCOUNTINCOME,
                   CalcSumm.T_NOTCARRYDISCOUNT,
                   CalcSumm.T_BONUS,
                   CalcSumm.T_OUTLAY,
                   CalcSumm.T_RESERVAMOUNT,
                   CalcSumm.T_INCOMERESERV,
                   CalcSumm.T_OVERAMOUNT,
                   CalcSumm.T_OLDBONUS,
                   CalcSumm.T_BEGBONUS, -- в проекте зовётся BonusRest, но поля такого нет и храним в T_BEGBONUS
                   CalcSumm.T_NOTWRTBONUS,
                   CalcSumm.T_COSTPFI
              FROM DPMWRTSUM_DBT
             WHERE     (Department = UnknownValue or t_Department = Department)
                   AND t_FIID       = FIID
                   AND t_Buy_Sale   in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
                   AND CheckDealORCB( t_DealID, DealORCB ) = 1
                   AND ( (Party = 0) OR (Party is NULL) OR (t_Party = Party) )
                   AND t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 END)
                   AND t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE t_Portfolio END)
                   AND ((t_Contract   = Contract) OR (Contract = -1))
                   AND ((t_Trust  = 'X') OR (IsTrust = -1) OR ((t_Trust  <> 'X') AND (IsTrust = 0)))
                   AND ((CalcDate = RsbSessionData.curdate) OR (T_DATE <= CalcDate AND T_CHANGEDATE <=  CalcDate))
                   AND (t_Amount     > 0 or v_Method = PM_WRITEOFF_AVERAGE)
                   AND ( ( Delivered     = 1 AND t_State = PM_WRTSUM_FORM ) OR
                         ( WithoutAccept = 1 AND t_State = PM_WRTSUM_SALE_BPP)
                       )
                   AND (((CASE WHEN (CalcTime  is null) OR
                                    (CalcTime  = UnknownTime)
                               THEN T_TIME ELSE CalcTime
                                END
                         ) >= T_TIME AND T_DATE = CalcDate
                        ) OR
                        (T_DATE < CalcDate)
                       )-- Если CalcTime задан то T_TIME <= CalcTime
                   AND (CASE WHEN (StartDate is null) OR (StartDate = UnknownDate) THEN T_DATE ELSE StartDate END) <= T_DATE -- Если StartDate задан то T_DATE <= StartDate
                   AND (CASE WHEN (StartDate is null) OR (StartDate = UnknownDate) THEN T_STATEDATE ELSE StartDate END) <= T_STATEDATE -- Если StartDate задан то T_DATE <= StartDate
                   AND (CASE WHEN (EndDate is null) OR (EndDate = UnknownDate) THEN T_DATE ELSE EndDate END) >= T_DATE;-- Если EndDate задан то T_DATE <= EndDate*/
                   
        v_where := ' t_FIID = :FIID
                     AND t_Buy_Sale in (:PM_WRITEOFF_SUM_BUY, :PM_WRITEOFF_SUM_BUY_BO)
                     AND RSB_PMWRTOFF.CheckDealORCB(t_DealID, :DealORCB) = 1 ';

        if Department != UnknownValue then
          v_where := v_where || ' AND t_Department = :Department ';
        end if;
        if nvl(Party, 0) != 0 then 
          v_where := v_where || ' AND t_Party = :Party ';
        end if;
        if nvl(Portfolio, UnknownValue) = UnknownValue then 
          v_where := v_where || ' AND t_Portfolio != :KINDPORT_CONTR ';
        else
          v_where := v_where || ' AND t_Portfolio != :KINDPORT_UNDEF-1 /*несуществующий портфель*/ AND t_Portfolio  = :Portfolio '; 
        end if;
        if Contract != -1 then 
          v_where := v_where || ' AND t_Contract   = :Contract '; 
        end if;
        if IsTrust not in (-1, 0) then 
          v_where := v_where || ' AND t_Trust  = ''X'' ';
        elsif IsTrust = 0 then
          v_where := v_where || ' AND t_Trust  != ''X'' ';
        end if;
        if v_Method != PM_WRITEOFF_AVERAGE then 
          v_where := v_where || ' AND t_Amount > 0 ';
        end if;
        if Delivered = 1 and WithoutAccept = 1 then 
          v_where := v_where || ' AND t_State in (:PM_WRTSUM_FORM, :PM_WRTSUM_SALE_BPP) ';
        elsif Delivered = 1 then
          v_where := v_where || ' AND t_State = :PM_WRTSUM_FORM ';
        elsif WithoutAccept = 1 then
          v_where := v_where || ' AND t_State = :PM_WRTSUM_SALE_BPP ';
        end if;
        if nvl(CalcTime, UnknownTime) = UnknownTime then 
          v_where := v_where || ' AND T_DATE <= :CalcDate ';
        else
          v_where := v_where || ' AND ((:CalcTime >= T_TIME AND T_DATE = :CalcDate) OR (T_DATE < :CalcDate)) ';
        end if;
        if CalcDate != RsbSessionData.curdate then 
          v_where := v_where || ' AND T_CHANGEDATE <= :CalcDate ';
        end if;
        if nvl(StartDate, UnknownDate) != UnknownDate then 
          v_where := v_where || ' AND :StartDate <= T_DATE AND :StartDate <= T_STATEDATE ';
        end if;
        if nvl(EndDate, UnknownDate) != UnknownDate then 
          v_where := v_where || ' AND :EndDate >= T_DATE ';
        end if;
        
        v_cursor_id := dbms_sql.open_cursor;
        dbms_sql.parse(v_cursor_id, 'SELECT NVL(SUM(T_AMOUNT), 0),
                                            NVL(SUM(ROUND(T_COST,2)), 0),
                                            NVL(SUM(ROUND(T_BALANCECOST,2)), 0),
                                            NVL(SUM(ROUND(T_NKDAMOUNT,2)), 0),
                                            NVL(SUM(ROUND(T_INTERESTINCOME,2)), 0),
                                            NVL(SUM(ROUND(T_NOTCARRYINTEREST,2)), 0),
                                            NVL(SUM(ROUND(T_DISCOUNTINCOME,2)), 0),
                                            NVL(SUM(ROUND(T_NOTCARRYDISCOUNT,2)), 0),
                                            NVL(SUM(ROUND(T_BONUS,2)), 0),
                                            NVL(SUM(ROUND(T_OUTLAY,2)), 0),
                                            NVL(SUM(ROUND(T_RESERVAMOUNT,2)), 0),
                                            NVL(SUM(ROUND(T_INCOMERESERV,2)), 0),
                                            NVL(SUM(ROUND(T_OVERAMOUNT,2)), 0),
                                            NVL(SUM(ROUND(T_OLDBONUS,2)), 0),
                                            NVL(SUM(ROUND(T_BEGBONUS,2)) - SUM(ROUND(T_BONUS,2)) + SUM(ROUND(T_OLDBONUS,2)), 0),
                                            NVL(SUM(ROUND(T_NOTWRTBONUS,2)), 0),
                                            NVL(SUM(ROUND(T_COSTPFI,2)), 0)
                                       FROM DPMWRTSUM_DBT
                                      WHERE ' || v_where , dbms_sql.native);

        dbms_sql.bind_variable(v_cursor_id, ':FIID', FIID);
        dbms_sql.bind_variable(v_cursor_id, ':PM_WRITEOFF_SUM_BUY', PM_WRITEOFF_SUM_BUY);
        dbms_sql.bind_variable(v_cursor_id, ':PM_WRITEOFF_SUM_BUY_BO', PM_WRITEOFF_SUM_BUY_BO);
        dbms_sql.bind_variable(v_cursor_id, ':DealORCB', DealORCB);
        if Department != UnknownValue then 
          dbms_sql.bind_variable(v_cursor_id, ':Department', Department);
        end if;
        if nvl(Party, 0) != 0 then 
          dbms_sql.bind_variable(v_cursor_id, ':Party', Party);
        end if;
        if nvl(Portfolio, UnknownValue) = UnknownValue then 
          dbms_sql.bind_variable(v_cursor_id, ':KINDPORT_CONTR', KINDPORT_CONTR);
        else
          dbms_sql.bind_variable(v_cursor_id, ':KINDPORT_UNDEF', KINDPORT_UNDEF);
          dbms_sql.bind_variable(v_cursor_id, ':Portfolio', Portfolio);
        end if;
        if Contract != -1 then 
          dbms_sql.bind_variable(v_cursor_id, ':Contract', Contract);
        end if;
        if Delivered = 1 and WithoutAccept = 1 then 
          dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_FORM', PM_WRTSUM_FORM);
          dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_SALE_BPP', PM_WRTSUM_SALE_BPP);
        elsif Delivered = 1 then
          dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_FORM', PM_WRTSUM_FORM);
        elsif WithoutAccept = 1 then
          dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_SALE_BPP', PM_WRTSUM_SALE_BPP);
        end if;
        if nvl(CalcTime, UnknownTime) != UnknownTime then 
          dbms_sql.bind_variable(v_cursor_id, ':CalcTime', CalcTime);
        end if;
        dbms_sql.bind_variable(v_cursor_id, ':CalcDate', CalcDate);
        if nvl(StartDate, UnknownDate) != UnknownDate then 
          dbms_sql.bind_variable(v_cursor_id, ':StartDate', StartDate);
        end if;
        if nvl(EndDate, UnknownDate) != UnknownDate then 
          dbms_sql.bind_variable(v_cursor_id, ':EndDate', EndDate);
        end if;
        
        v_dummy := DBMS_SQL.EXECUTE(v_cursor_id);
        v_cur := DBMS_SQL.to_refcursor(v_cursor_id);       
        fetch v_cur into CalcSumm.T_AMOUNT,
                         CalcSumm.T_COST,
                         CalcSumm.T_BALANCECOST,
                         CalcSumm.T_NKDAMOUNT,
                         CalcSumm.T_INTERESTINCOME,
                         CalcSumm.T_NOTCARRYINTEREST,
                         CalcSumm.T_DISCOUNTINCOME,
                         CalcSumm.T_NOTCARRYDISCOUNT,
                         CalcSumm.T_BONUS,
                         CalcSumm.T_OUTLAY,
                         CalcSumm.T_RESERVAMOUNT,
                         CalcSumm.T_INCOMERESERV,
                         CalcSumm.T_OVERAMOUNT,
                         CalcSumm.T_OLDBONUS,
                         CalcSumm.T_BEGBONUS, -- в проекте зовётся BonusRest, но поля такого нет и храним в T_BEGBONUS
                         CalcSumm.T_NOTWRTBONUS,
                         CalcSumm.T_COSTPFI;
        close v_cur;

        if CalcDate != RsbSessionData.curdate then
          /*SELECT NVL(SUM(B.T_AMOUNT), 0),
                 NVL(SUM(ROUND(B.T_COST,2)), 0),
                 NVL(SUM(ROUND(B.T_BALANCECOST,2)), 0),
                 NVL(SUM(ROUND(B.T_NKDAMOUNT,2)), 0),
                 NVL(SUM(ROUND(B.T_INTERESTINCOME,2)), 0),
                 NVL(SUM(ROUND(B.T_NOTCARRYINTEREST,2)), 0),
                 NVL(SUM(ROUND(B.T_DISCOUNTINCOME,2)), 0),
                 NVL(SUM(ROUND(B.T_NOTCARRYDISCOUNT,2)), 0),
                 NVL(SUM(ROUND(B.T_BONUS,2)), 0),
                 NVL(SUM(ROUND(B.T_OUTLAY,2)), 0),
                 NVL(SUM(ROUND(B.T_RESERVAMOUNT,2)), 0),
                 NVL(SUM(ROUND(B.T_INCOMERESERV,2)), 0),
                 NVL(SUM(ROUND(B.T_OVERAMOUNT,2)), 0),
                 NVL(SUM(ROUND(B.T_OLDBONUS,2)), 0),
                 NVL(SUM(ROUND(B.T_BEGBONUS,2)) - SUM(ROUND(B.T_BONUS,2)) + SUM(ROUND(B.T_OLDBONUS,2)), 0),
                 NVL(SUM(ROUND(B.T_NOTWRTBONUS,2)), 0),
                 NVL(SUM(ROUND(B.T_COSTPFI,2)), 0)
            INTO CalcSummBC.T_AMOUNT,
                 CalcSummBC.T_COST,
                 CalcSummBC.T_BALANCECOST,
                 CalcSummBC.T_NKDAMOUNT,
                 CalcSummBC.T_INTERESTINCOME,
                 CalcSummBC.T_NOTCARRYINTEREST,
                 CalcSummBC.T_DISCOUNTINCOME,
                 CalcSummBC.T_NOTCARRYDISCOUNT,
                 CalcSummBC.T_BONUS,
                 CalcSummBC.T_OUTLAY,
                 CalcSummBC.T_RESERVAMOUNT,
                 CalcSummBC.T_INCOMERESERV,
                 CalcSummBC.T_OVERAMOUNT,
                 CalcSummBC.T_OLDBONUS,
                 CalcSummBC.T_BEGBONUS,  -- в проекте зовётся BonusRest, но поля такого нет и храним в T_BEGBONUS
                 CalcSummBC.T_NOTWRTBONUS,
                 CalcSummBC.T_COSTPFI
            FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
           WHERE     (Department = UnknownValue or L.t_Department = Department)
                 AND ( (Party = 0) OR (Party is NULL) OR (L.t_Party = Party) )
                 AND ((L.t_Contract   = Contract) OR (Contract = -1))
                 AND L.t_Buy_Sale   in( PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO )
                 AND CheckDealORCB( L.t_DealID, DealORCB ) = 1
                 AND B.T_STATEDATE <= CalcDate
                 AND L.T_DATE      <= CalcDate
                 AND L.T_CHANGEDATE >  CalcDate
                 AND ((L.t_Trust  = 'X') OR (IsTrust = -1) OR ((L.t_Trust  <> 'X') AND (IsTrust = 0)))
                 AND (B.t_Amount     > 0 or v_Method = PM_WRITEOFF_AVERAGE)
                 AND ( ( Delivered     = 1 AND B.t_State = PM_WRTSUM_FORM ) OR
                       ( WithoutAccept = 1 AND B.t_State = PM_WRTSUM_SALE_BPP)
                     )
                 AND (((CASE WHEN (CalcTime  is null) OR
                                  (CalcTime  = UnknownTime)
                             THEN L.T_TIME ELSE CalcTime
                              END
                       ) >= L.T_TIME AND L.T_DATE = CalcDate
                      ) OR
                      (L.T_DATE < CalcDate)
                     )-- Если CalcTime задан то T_TIME <= CalcTime
                 AND (CASE WHEN (CalcTime  is null) OR (CalcTime  = UnknownTime) THEN L.T_TIME ELSE CalcTime  END) >= L.T_TIME -- Если CalcTime задан то T_TIME <= CalcTime
                 AND (CASE WHEN (StartDate is null) OR (StartDate = UnknownDate) THEN L.T_DATE ELSE StartDate END) <= L.T_DATE -- Если StartDate задан то T_DATE <= StartDate
                 AND (CASE WHEN (StartDate is null) OR (StartDate = UnknownDate) THEN L.T_STATEDATE ELSE StartDate END) <= L.T_STATEDATE -- Если StartDate задан то T_DATE <= StartDate
                 AND (CASE WHEN (EndDate is null) OR (EndDate = UnknownDate) THEN L.T_DATE ELSE EndDate END) >= L.T_DATE-- Если EndDate задан то T_DATE <= EndDate
                 AND L.t_FIID       = FIID
                 AND B.T_SUMID      = L.T_SUMID
                 AND B.t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 END)
                 AND B.t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE B.t_Portfolio END)
                 AND B.T_INSTANCE = ( SELECT MAX(M.T_INSTANCE)
                                        FROM DPMWRTBC_DBT M
                                       WHERE     M.T_CHANGEDATE <= CalcDate
                                             AND M.T_SUMID      = L.T_SUMID
                                    );*/
                                     
          v_where := ' L.t_Buy_Sale in (:PM_WRITEOFF_SUM_BUY, :PM_WRITEOFF_SUM_BUY_BO)
                       AND RSB_PMWRTOFF.CheckDealORCB(L.t_DealID, :DealORCB) = 1                   
                       AND B.T_STATEDATE <= :CalcDate
                       AND L.T_DATE <= :CalcDate
                       AND L.T_CHANGEDATE > :CalcDate
                       AND L.t_FIID = :FIID
                       AND B.T_SUMID = L.T_SUMID
                       AND B.T_INSTANCE = (SELECT MAX(M.T_INSTANCE)
                                             FROM DPMWRTBC_DBT M
                                            WHERE M.T_CHANGEDATE <= :CalcDate
                                              AND M.T_SUMID = L.T_SUMID
                                          ) ';
                   
          if Department != UnknownValue then
            v_where := v_where || ' AND L.t_Department = :Department ';
          end if;
          if nvl(Party, 0) != 0 then 
            v_where := v_where || ' AND L.t_Party = :Party ';
          end if;
          if nvl(Portfolio, UnknownValue) = UnknownValue then 
            v_where := v_where || ' AND B.t_Portfolio != :KINDPORT_CONTR ';
          else
            v_where := v_where || ' AND B.t_Portfolio != :KINDPORT_UNDEF-1 /*несуществующий портфель*/ AND B.t_Portfolio  = :Portfolio '; 
          end if;
          if Contract != -1 then 
            v_where := v_where || ' AND L.t_Contract = :Contract '; 
          end if;
          if IsTrust not in (-1, 0) then 
            v_where := v_where || ' AND L.t_Trust  = ''X'' ';
          elsif IsTrust = 0 then
            v_where := v_where || ' AND L.t_Trust  != ''X'' ';
          end if;
          if v_Method != PM_WRITEOFF_AVERAGE then 
            v_where := v_where || ' AND B.t_Amount > 0 ';
          end if;
          if Delivered = 1 and WithoutAccept = 1 then 
            v_where := v_where || ' AND B.t_State in (:PM_WRTSUM_FORM, :PM_WRTSUM_SALE_BPP) ';
          elsif Delivered = 1 then
            v_where := v_where || ' AND B.t_State = :PM_WRTSUM_FORM ';
          elsif WithoutAccept = 1 then
            v_where := v_where || ' AND B.t_State = :PM_WRTSUM_SALE_BPP ';
          end if;
          if nvl(CalcTime, UnknownTime) = UnknownTime then 
            v_where := v_where || ' AND L.T_DATE <= :CalcDate ';
          else
            v_where := v_where || ' AND ((:CalcTime >= L.T_TIME AND L.T_DATE = :CalcDate) OR (L.T_DATE < :CalcDate)) AND :CalcTime >= L.T_TIME ';
          end if;
          if nvl(StartDate, UnknownDate) != UnknownDate then 
            v_where := v_where || ' AND :StartDate <= L.T_DATE AND :StartDate <= L.T_STATEDATE ';
          end if;
          if nvl(EndDate, UnknownDate) != UnknownDate then 
            v_where := v_where || ' AND :EndDate >= L.T_DATE ';
          end if;
          
          v_cursor_id:=dbms_sql.open_cursor;
          dbms_sql.parse(v_cursor_id, 'SELECT NVL(SUM(B.T_AMOUNT), 0),
                                              NVL(SUM(ROUND(B.T_COST,2)), 0),
                                              NVL(SUM(ROUND(B.T_BALANCECOST,2)), 0),
                                              NVL(SUM(ROUND(B.T_NKDAMOUNT,2)), 0),
                                              NVL(SUM(ROUND(B.T_INTERESTINCOME,2)), 0),
                                              NVL(SUM(ROUND(B.T_NOTCARRYINTEREST,2)), 0),
                                              NVL(SUM(ROUND(B.T_DISCOUNTINCOME,2)), 0),
                                              NVL(SUM(ROUND(B.T_NOTCARRYDISCOUNT,2)), 0),
                                              NVL(SUM(ROUND(B.T_BONUS,2)), 0),
                                              NVL(SUM(ROUND(B.T_OUTLAY,2)), 0),
                                              NVL(SUM(ROUND(B.T_RESERVAMOUNT,2)), 0),
                                              NVL(SUM(ROUND(B.T_INCOMERESERV,2)), 0),
                                              NVL(SUM(ROUND(B.T_OVERAMOUNT,2)), 0),
                                              NVL(SUM(ROUND(B.T_OLDBONUS,2)), 0),
                                              NVL(SUM(ROUND(B.T_BEGBONUS,2)) - SUM(ROUND(B.T_BONUS,2)) + SUM(ROUND(B.T_OLDBONUS,2)), 0),
                                              NVL(SUM(ROUND(B.T_NOTWRTBONUS,2)), 0),
                                              NVL(SUM(ROUND(B.T_COSTPFI,2)), 0)
                                         FROM DPMWRTSUM_DBT L, DPMWRTBC_DBT B
                                        WHERE ' || v_where , dbms_sql.native);
                               
          dbms_sql.bind_variable(v_cursor_id, ':PM_WRITEOFF_SUM_BUY', PM_WRITEOFF_SUM_BUY);
          dbms_sql.bind_variable(v_cursor_id, ':PM_WRITEOFF_SUM_BUY_BO', PM_WRITEOFF_SUM_BUY_BO);
          dbms_sql.bind_variable(v_cursor_id, ':DealORCB', DealORCB);
          dbms_sql.bind_variable(v_cursor_id, ':CalcDate', CalcDate);
          dbms_sql.bind_variable(v_cursor_id, ':FIID', FIID);
          if Department != UnknownValue then 
            dbms_sql.bind_variable(v_cursor_id, ':Department', Department);
          end if;
          if nvl(Party, 0) != 0 then 
            dbms_sql.bind_variable(v_cursor_id, ':Party', Party);
          end if;
          if nvl(Portfolio, UnknownValue) = UnknownValue then 
            dbms_sql.bind_variable(v_cursor_id, ':KINDPORT_CONTR', KINDPORT_CONTR);
          else
            dbms_sql.bind_variable(v_cursor_id, ':KINDPORT_UNDEF', KINDPORT_UNDEF);
            dbms_sql.bind_variable(v_cursor_id, ':Portfolio', Portfolio);
          end if;
          if Contract != -1 then 
            dbms_sql.bind_variable(v_cursor_id, ':Contract', Contract);
          end if;
          if Delivered = 1 and WithoutAccept = 1 then 
            dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_FORM', PM_WRTSUM_FORM);
            dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_SALE_BPP', PM_WRTSUM_SALE_BPP);
          elsif Delivered = 1 then
            dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_FORM', PM_WRTSUM_FORM);
          elsif WithoutAccept = 1 then
            dbms_sql.bind_variable(v_cursor_id, ':PM_WRTSUM_SALE_BPP', PM_WRTSUM_SALE_BPP);
          end if;
          if nvl(CalcTime, UnknownTime) != UnknownTime then 
            dbms_sql.bind_variable(v_cursor_id, ':CalcTime', CalcTime);
          end if;
          if nvl(StartDate, UnknownDate) != UnknownDate then 
            dbms_sql.bind_variable(v_cursor_id, ':StartDate', StartDate);
          end if;
          if nvl(EndDate, UnknownDate) != UnknownDate then 
            dbms_sql.bind_variable(v_cursor_id, ':EndDate', EndDate);
          end if;
          
          v_dummy := DBMS_SQL.EXECUTE (v_cursor_id);
          v_cur := DBMS_SQL.to_refcursor (v_cursor_id);       
          fetch v_cur into CalcSummBC.T_AMOUNT,
                           CalcSummBC.T_COST,
                           CalcSummBC.T_BALANCECOST,
                           CalcSummBC.T_NKDAMOUNT,
                           CalcSummBC.T_INTERESTINCOME,
                           CalcSummBC.T_NOTCARRYINTEREST,
                           CalcSummBC.T_DISCOUNTINCOME,
                           CalcSummBC.T_NOTCARRYDISCOUNT,
                           CalcSummBC.T_BONUS,
                           CalcSummBC.T_OUTLAY,
                           CalcSummBC.T_RESERVAMOUNT,
                           CalcSummBC.T_INCOMERESERV,
                           CalcSummBC.T_OVERAMOUNT,
                           CalcSummBC.T_OLDBONUS,
                           CalcSummBC.T_BEGBONUS,  -- в проекте зовётся BonusRest, но поля такого нет и храним в T_BEGBONUS
                           CalcSummBC.T_NOTWRTBONUS,
                           CalcSummBC.T_COSTPFI;
          close v_cur;
     
          CalcSumm.T_AMOUNT           := CalcSumm.T_AMOUNT           + CalcSummBC.T_AMOUNT;
          CalcSumm.T_COST             := CalcSumm.T_COST             + CalcSummBC.T_COST;
          CalcSumm.T_BALANCECOST      := CalcSumm.T_BALANCECOST      + CalcSummBC.T_BALANCECOST;
          CalcSumm.T_NKDAMOUNT        := CalcSumm.T_NKDAMOUNT        + CalcSummBC.T_NKDAMOUNT;
          CalcSumm.T_INTERESTINCOME   := CalcSumm.T_INTERESTINCOME   + CalcSummBC.T_INTERESTINCOME;
          CalcSumm.T_NOTCARRYINTEREST := CalcSumm.T_NOTCARRYINTEREST + CalcSummBC.T_NOTCARRYINTEREST;
          CalcSumm.T_DISCOUNTINCOME   := CalcSumm.T_DISCOUNTINCOME   + CalcSummBC.T_DISCOUNTINCOME;
          CalcSumm.T_NOTCARRYDISCOUNT := CalcSumm.T_NOTCARRYDISCOUNT + CalcSummBC.T_NOTCARRYDISCOUNT;
          CalcSumm.T_BONUS            := CalcSumm.T_BONUS            + CalcSummBC.T_BONUS;
          CalcSumm.T_OUTLAY           := CalcSumm.T_OUTLAY           + CalcSummBC.T_OUTLAY;
          CalcSumm.T_RESERVAMOUNT     := CalcSumm.T_RESERVAMOUNT     + CalcSummBC.T_RESERVAMOUNT;
          CalcSumm.T_INCOMERESERV     := CalcSumm.T_INCOMERESERV     + CalcSummBC.T_INCOMERESERV;
          CalcSumm.T_OVERAMOUNT       := CalcSumm.T_OVERAMOUNT       + CalcSummBC.T_OVERAMOUNT;
          CalcSumm.T_OLDBONUS         := CalcSumm.T_OLDBONUS         + CalcSummBC.T_OLDBONUS;
          CalcSumm.T_BEGBONUS         := CalcSumm.T_BEGBONUS         + CalcSummBC.T_BEGBONUS;
          CalcSumm.T_NOTWRTBONUS      := CalcSumm.T_NOTWRTBONUS      + CalcSummBC.T_NOTWRTBONUS;
          CalcSumm.T_COSTPFI          := CalcSumm.T_COSTPFI          + CalcSummBC.T_COSTPFI;
        end if;
            
        IF ((Portfolio = UnknownValue) OR (Portfolio is NULL)) AND Delivered <> 0 AND IsTrust <= 0 THEN
          CalcSumm.T_AMOUNT := CalcSumm.T_AMOUNT + WRTGetAmountByClient(Department, FIID, Party, Contract, CalcDate);
        END IF;
     END IF;
   END; -- RSI_GetPortfolioCost

   -- Возвращает остаток ц/б по портфелю на дату
   PROCEDURE WRTRestOnDate( Department     IN NUMBER, -- Филиал
                           FIID           IN NUMBER, -- ц/б
                           Party          IN NUMBER, -- Владелец
                           Contract       IN NUMBER, -- Договор обслуживания
                           Portfolio      IN NUMBER, -- Портфель.  Если не задан (UnknounValue(-1)) игнорируется
                           CalcDate       IN DATE,   -- Дата расчета
                           DealORCB       IN NUMBER, -- Только лоты покупки по сделкам ОРЦБ
                           Delivered      IN NUMBER, -- Отбирать поставленные (1 или 0)
                           CalcSumm       OUT DPMWRTSUM_DBT%ROWTYPE -- выходные значения сумм
                         )
   IS
   BEGIN
      RSI_GetPortfolioCost( Department, FIID, Party, Contract, Portfolio,
                            CalcDate, UnknownTime, UnknownDate,
                            Delivered, 0, DealORCB, NULL, CalcSumm );
   END;

   -- Возвращает кол-во купленных за период ц/б по портфелю
   PROCEDURE WRTBuyForPeriod( Department     IN NUMBER, -- Филиал
                            FIID           IN NUMBER, -- ц/б
                            Party          IN NUMBER, -- Владелец
                            Contract       IN NUMBER, -- Договор обслуживания
                            Portfolio      IN NUMBER, -- Портфель.  Если не задан (UnknounValue(-1)) игнорируется
                            BeginDate      IN DATE,   -- Дата расчета
                            EndDate        IN DATE,   -- Дата расчета
                            DealORCB       IN NUMBER, -- Только лоты покупки по сделкам ОРЦБ
                            Delivered      IN NUMBER, -- Отбирать поставленные (1 или 0)
                            CalcSumm       OUT DPMWRTSUM_DBT%ROWTYPE -- выходные значения сумм
                          )
   IS
   BEGIN
      RSI_GetPortfolioCost( Department, FIID, Party, Contract, Portfolio,
                            EndDate, UnknownTime, BeginDate,
                            Delivered, 0, DealORCB, EndDate, CalcSumm );
   END;


   -- Возвращает кол-во проданных за период ц/б по портфелю
   PROCEDURE WRTSaleForPeriod( Department     IN NUMBER, -- Филиал
                             FIID           IN NUMBER, -- ц/б
                             Party          IN NUMBER, -- Владелец
                             Contract       IN NUMBER, -- Договор обслуживания
                             Portfolio      IN NUMBER, -- Портфель.  Если не задан (UnknounValue(-1)) игнорируется
                             BeginDate      IN DATE,   -- Дата расчета
                             EndDate        IN DATE,   -- Дата расчета
                             DealORCB       IN NUMBER, -- Только лоты покупки по сделкам ОРЦБ
                             CalcSumm       OUT DPMWRTSUM_DBT%ROWTYPE -- выходные значения сумм
                           )
   IS
   BEGIN

          SELECT NVL(SUM(Lnk.T_AMOUNT), 0),
                 NVL(SUM(ROUND(Lnk.T_CostSale,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_BalanceCostSale,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_NKDSaleAmount,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_InteresTIncomeAdd,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_NotCarryInterestAdd,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_DiscountIncomeAdd,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_NotCarryDiscountAdd,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_OutlaySale,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_ReservChange,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_IncomeReservChange,2)), 0),
                 NVL(SUM(ROUND(Lnk.T_OverChange,2)), 0)
            INTO CalcSumm.T_AMOUNT,
                 CalcSumm.T_COST,
                 CalcSumm.T_BALANCECOST,
                 CalcSumm.T_NKDAMOUNT,
                 CalcSumm.T_INTERESTINCOME,
                 CalcSumm.T_NOTCARRYINTEREST,
                 CalcSumm.T_DISCOUNTINCOME,
                 CalcSumm.T_NOTCARRYDISCOUNT,
                 CalcSumm.T_OUTLAY,
                 CalcSumm.T_RESERVAMOUNT,
                 CalcSumm.T_INCOMERESERV,
                 CalcSumm.T_OVERAMOUNT
            FROM DPMWRTLNK_DBT Lnk, DPMWRTSUM_DBT SumBuy
           WHERE     Lnk.t_BuyID = SumBuy.t_SumID
                 AND SumBuy.t_Department = Department
                 AND SumBuy.t_FIID       = FIID
                 AND CheckDealORCB( SumBuy.t_DealID, DealORCB ) = 1
                 AND ( (Party = 0) OR (Party is NULL) OR (SumBuy.t_Party = Party) )
                 AND SumBuy.t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
                 AND SumBuy.t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE SumBuy.t_Portfolio END)
                 AND SumBuy.t_Contract   = Contract
                 AND (CASE WHEN (BeginDate is null) OR (BeginDate = UnknownDate) THEN t_CreateDate ELSE BeginDate END) <= Lnk.t_CreateDate
                 AND (CASE WHEN (EndDate is null) OR (EndDate = UnknownDate) THEN t_CreateDate ELSE EndDate END) >= Lnk.t_CreateDate;
   END;

   -- Возвращает к-во и суммы по портфелю (группе списания) на дату. Обрабатывает только поставленные лоты.
   PROCEDURE WRTGetPortfolioCost( Department     IN NUMBER, -- Филиал
                                  FIID           IN NUMBER, -- ц/б
                                  Party          IN NUMBER, -- Владелец
                                  Contract       IN NUMBER, -- Договор обслуживания
                                  Portfolio      IN NUMBER, -- Портфель
                                  CalcDate       IN DATE,   -- Дата расчета
                                  CalcTime       IN DATE,   -- Время расчета. Если не задано - игнорируется.
                                  StartDate      IN DATE,   -- Дата отбора лотов покупки. Если не задана  - игнорируется
                                  Delivered      IN NUMBER, -- Отбирать поставленные
                                  WithoutAccept  IN NUMBER, -- Отбирать проданные БПП
                                  CalcSumm       OUT DPMWRTSUM_DBT%ROWTYPE, -- выходные значения сумм
                                  IsTrust        IN NUMBER DEFAULT -1 -- Признак ДУ. Если не задан (-1), игнорируется
                                )
   IS
   BEGIN
      RSI_GetPortfolioCost( Department, FIID, Party, Contract, Portfolio,
                            CalcDate, CalcTime, StartDate,
                            Delivered, WithoutAccept, -1, NULL, CalcSumm, IsTrust );
   END;

   -- Возвращает остаток ц/б по клиенту на дату. Возможен расчёт по всем клиентам/договорам
   FUNCTION WRTGetAmountByClient( Department     IN NUMBER,  -- Филиал( если -1 то игнорируется)
                                  FIID           IN NUMBER,  -- ц/б
                                  Party          IN NUMBER,  -- Владелец ( если 0 то игнорируется)
                                  Contract       IN NUMBER,  -- Договор обслуживания( если -1 то игнорируется)
                                  CalcDate       IN DATE     -- Дата расчета
                                ) RETURN NUMBER DETERMINISTIC

   IS
      v_Amount NUMBER := 0;
   BEGIN

      IF Party <> -1 THEN
        SELECT NVL(SUM(T_AMOUNT), 0) INTO v_Amount
          FROM DPMWRTCL_DBT
         WHERE 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = T_DEPARTMENT THEN 1 ELSE 0 END)
           AND T_FIID = FIID
           AND 1 = (CASE WHEN Party = 0 THEN 1 WHEN Party = T_PARTY THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN Contract = -1 THEN 1 WHEN Contract = T_CONTRACT THEN 1 ELSE 0 END)
           AND T_BEGDATE <= CalcDate
           AND T_ENDDATE >= CalcDate;
      END IF;

      RETURN v_Amount;

   END; --WRTGetAmountByClient

   -- Возвращает остаток ц/б по клиенту на дату, в обратном РЕПО. Возможен расчёт по всем клиентам/договорам
   FUNCTION WRTGetAmountByClientInBackRepo( Department     IN NUMBER,  -- Филиал( если -1 то игнорируется)
                                            FIID           IN NUMBER,  -- ц/б
                                            Party          IN NUMBER,  -- Владелец ( если 0 то игнорируется)
                                            Contract       IN NUMBER,  -- Договор обслуживания( если -1 то игнорируется)
                                            CalcDate       IN DATE     -- Дата расчета
                                          ) RETURN NUMBER DETERMINISTIC
   IS
      v_Amount NUMBER := 0;
      v_N NUMBER := 0;
   BEGIN

      --1. Проверить, что поставки 2ч с датой после даты расчета ещё не исполнены
      SELECT Count(1) INTO v_N
        FROM DDLRQ_DBT RQ, DDL_TICK_DBT TK
       WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
         AND RQ.T_DOCID = TK.T_DEALID
         AND RQ.T_DEALPART = 2
         AND RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_COMMIT --Обязательство
         AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
         AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY
         AND RQ.T_FIID = FIID
         AND RQ.T_FACTDATE > CalcDate
         AND TK.T_CLIENTID > 0 AND 1 = (CASE WHEN Party = 0 THEN 1 WHEN Party = TK.T_CLIENTID THEN 1 ELSE 0 END)
         AND TK.T_CLIENTCONTRID > 0 AND 1 = (CASE WHEN Contract = -1 THEN 1 WHEN Contract = TK.T_CLIENTCONTRID THEN 1 ELSE 0 END)
         AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END);

      IF v_N > 0 THEN
        SetError( WRTOFF_ERROR_20246 ); --Выполнена обработка операций за более поздние даты
      END IF;

      --2. Сумимируем остатки ЦТО по 2ч клиентских обратных РЕПО
      SELECT NVL(SUM(RQ2.T_AMOUNT), 0) INTO v_Amount
        FROM DDLRQ_DBT RQ1, DDLRQ_DBT RQ2, DDL_TICK_DBT TK
       WHERE RQ1.T_DOCKIND = TK.T_BOFFICEKIND
         AND RQ1.T_DOCID = TK.T_DEALID
         AND RQ1.T_DEALPART = 1
         AND RQ1.T_KIND = RSI_DLRQ.DLRQ_KIND_REQUEST --Требование
         AND RQ1.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
         AND RQ1.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY
         AND RQ1.T_FIID = FIID
         AND RQ1.T_FACTDATE > CalcDate
         AND RQ2.T_DOCKIND = TK.T_BOFFICEKIND
         AND RQ2.T_DOCID = TK.T_DEALID
         AND RQ2.T_DEALPART = 2
         AND RQ2.T_KIND = RSI_DLRQ.DLRQ_KIND_COMMIT --Обязательство
         AND RQ2.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
         AND RQ2.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY
         AND RQ2.T_FIID = FIID
         AND RQ2.T_FACTDATE < CalcDate
         AND TK.T_CLIENTID > 0 AND 1 = (CASE WHEN Party = 0 THEN 1 WHEN Party = TK.T_CLIENTID THEN 1 ELSE 0 END)
         AND TK.T_CLIENTCONTRID > 0 AND 1 = (CASE WHEN Contract = -1 THEN 1 WHEN Contract = TK.T_CLIENTCONTRID THEN 1 ELSE 0 END)
         AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END);

      RETURN v_Amount;

   END; --WRTGetAmountByClientInBackRepo

   -- Возвращает количество ц/б по клиенту на дату по всем ведённым операциям погашения со схожии параметрами. Возможен расчёт по всем клиентам/договорам.
   FUNCTION WRTGetAmountFromRetire( Department     IN NUMBER,  -- Филиал
                                    FIID           IN NUMBER,  -- ц/б
                                    Party          IN NUMBER,  -- Владелец
                                    Contract       IN NUMBER,  -- Договор обслуживания( если -1 то считаем и Бо ЦБ и ДУ)
                                    Coupon         IN VARCHAR2,-- Номер купона (пустая строка, если нет купона)
                                    Partly         IN VARCHAR2,-- Номер ЧП  (пустая строка, если нет ЧП)
                                    DealID         IN NUMBER,  -- ID проверяемой операции погашения
                                    Registrar      IN NUMBER DEFAULT 0,  -- ID депозитария
                                    OnlyExecAcc    IN NUMBER DEFAULT 0  -- Только с исполенным БУ
                                  ) RETURN NUMBER DETERMINISTIC
   IS
      v_Amount NUMBER := 0;
      v_Amount_Coupon NUMBER := 0;
      v_Amount_Partly NUMBER := 0;
   BEGIN

      IF ((Coupon IS NOT NULL) AND Coupon != chr(1)) OR ((Partly IS NOT NULL) AND Partly != chr(1)) THEN

        IF (Coupon IS NOT NULL) AND Coupon != chr(1) THEN
          SELECT NVL(SUM(LEG.T_PRINCIPAL), 0) INTO v_Amount_Coupon
            FROM DDL_TICK_DBT TK, DDL_LEg_DBT LEG, DOPRKOPER_DBT OPR
           WHERE TK.T_BOFFICEKIND = 117 --Погашение ц/б
             AND LEG.T_DEALID = TK.T_DEALID
             AND LEG.T_LEGKIND = 0 --1ч
             AND LEG.T_LEGID = 0
             AND LEG.T_PFI = FIID
             AND TK.T_NUMBER_COUPON = Coupon
             AND OPR.T_KIND_OPERATION = TK.T_DEALTYPE
             AND 1 = (CASE WHEN Party = 0 THEN 1 WHEN Party = TK.T_CLIENTID THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN Contract = -1 THEN 1 WHEN Contract = TK.T_CLIENTCONTRID THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN DealID = 0 THEN 1 WHEN DealID <> TK.T_DEALID THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN Registrar = 0 THEN 1 WHEN Registrar = LEG.T_Registrar THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN (OnlyExecAcc IS NULL OR OnlyExecAcc = 0) AND RSB_SECUR.IsRet_Issue(RSB_SECUR.get_OperationGroup(OPR.T_SYSTYPES)) = 1 
                                AND EXISTS(SELECT 1 
                                             FROM DDLRQ_DBT RQ, DPMWRTSUM_DBT LOT 
                                            WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
                                              AND RQ.T_DOCID = TK.T_DEALID
                                              AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC
                                              AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                                              AND RQ.T_FIID = FIID
                                              AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                                              AND LOT.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                              AND LOT.T_DOCID = RQ.T_ID
                                          ) THEN 0
                           ELSE 1 END)
             AND 1 = (CASE WHEN OnlyExecAcc IS NULL OR OnlyExecAcc = 0 THEN 1
                          WHEN TK.T_DEALSTATUS > 0 AND NOT EXISTS(SELECT 1 
                                                                    FROM DDLGRDEAL_DBT GRDEAL, DDLGRACC_DBT GRACC
                                                                   WHERE GRDEAL.T_DOCKIND = TK.T_BOFFICEKIND
                                                                     AND GRDEAL.T_DOCID = TK.T_DEALID
                                                                     AND GRACC.T_GRDEALID = GRDEAL.T_ID
                                                                     AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                                                     AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П 
                                                                 ) THEN 1
                      ELSE 0 END);
        END IF;

        IF (Partly IS NOT NULL) AND Partly != chr(1) THEN
          SELECT NVL(SUM(LEG.T_PRINCIPAL), 0) INTO v_Amount_Partly
            FROM DDL_TICK_DBT TK, DDL_LEg_DBT LEG, DOPRKOPER_DBT OPR
           WHERE TK.T_BOFFICEKIND = 117 --Погашение ц/б
             AND LEG.T_DEALID = TK.T_DEALID
             AND LEG.T_LEGKIND = 0 --1ч
             AND LEG.T_LEGID = 0
             AND LEG.T_PFI = FIID
             AND TK.T_NUMBER_PARTLY = Partly
             AND OPR.T_KIND_OPERATION = TK.T_DEALTYPE
             AND 1 = (CASE WHEN Party = 0 THEN 1 WHEN Party = TK.T_CLIENTID THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN Contract = -1 THEN 1 WHEN Contract = TK.T_CLIENTCONTRID THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN DealID = 0 THEN 1 WHEN DealID <> TK.T_DEALID THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN Registrar = 0 THEN 1 WHEN Registrar = LEG.T_Registrar THEN 1 ELSE 0 END)
             AND 1 = (CASE WHEN (OnlyExecAcc IS NULL OR OnlyExecAcc = 0) AND RSB_SECUR.IsRet_Issue(RSB_SECUR.get_OperationGroup(OPR.T_SYSTYPES)) = 1 
                                AND EXISTS(SELECT 1 
                                             FROM DDLRQ_DBT RQ, DPMWRTSUM_DBT LOT 
                                            WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
                                              AND RQ.T_DOCID = TK.T_DEALID
                                              AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC
                                              AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                                              AND RQ.T_FIID = FIID
                                              AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                                              AND LOT.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                              AND LOT.T_DOCID = RQ.T_ID
                                          ) THEN 0
                           ELSE 1 END)
             AND 1 = (CASE WHEN OnlyExecAcc IS NULL OR OnlyExecAcc = 0 THEN 1
                          WHEN TK.T_DEALSTATUS > 0 AND NOT EXISTS(SELECT 1 
                                                                    FROM DDLGRDEAL_DBT GRDEAL, DDLGRACC_DBT GRACC
                                                                   WHERE GRDEAL.T_DOCKIND = TK.T_BOFFICEKIND
                                                                     AND GRDEAL.T_DOCID = TK.T_DEALID
                                                                     AND GRACC.T_GRDEALID = GRDEAL.T_ID
                                                                     AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                                                     AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П 
                                                                 ) THEN 1
                      ELSE 0 END);
        END IF;

        IF v_Amount_Coupon > v_Amount_Partly THEN
          v_Amount := v_Amount_Coupon;
        ELSE
          v_Amount := v_Amount_Partly;
        END IF;

      ELSE

        SELECT NVL(SUM(LEG.T_PRINCIPAL), 0) INTO v_Amount
          FROM DDL_TICK_DBT TK, DDL_LEg_DBT LEG, DOPRKOPER_DBT OPR
         WHERE TK.T_BOFFICEKIND = 117 --Погашение ц/б
           AND LEG.T_DEALID = TK.T_DEALID
           AND LEG.T_LEGKIND = 0 --1ч
           AND LEG.T_LEGID = 0
           AND LEG.T_PFI = FIID
           AND 1 = (CASE WHEN Party = 0 THEN 1 WHEN Party = TK.T_CLIENTID THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN Contract = -1 THEN 1 WHEN Contract = TK.T_CLIENTCONTRID THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN DealID = 0 THEN 1 WHEN DealID <> TK.T_DEALID THEN 1 ELSE 0 END)
           AND OPR.T_KIND_OPERATION = TK.T_DEALTYPE
           AND RSB_SECUR.IsRet_Issue(RSB_SECUR.get_OperationGroup(OPR.T_SYSTYPES)) = 1
           AND 1 = (CASE WHEN Registrar = 0 THEN 1 WHEN Registrar = LEG.T_Registrar THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN (OnlyExecAcc IS NULL OR OnlyExecAcc = 0)
                              AND EXISTS(SELECT 1 
                                       FROM DDLRQ_DBT RQ, DPMWRTSUM_DBT LOT 
                                      WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
                                        AND RQ.T_DOCID = TK.T_DEALID
                                        AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC
                                        AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                                        AND RQ.T_FIID = FIID
                                        AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                                        AND LOT.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                        AND LOT.T_DOCID = RQ.T_ID
                                     ) THEN 0
                          ELSE 1 END)
           AND 1 = (CASE WHEN OnlyExecAcc IS NULL OR OnlyExecAcc = 0 THEN 1
                          WHEN TK.T_DEALSTATUS > 0 AND NOT EXISTS(SELECT 1 
                                                                    FROM DDLGRDEAL_DBT GRDEAL, DDLGRACC_DBT GRACC
                                                                   WHERE GRDEAL.T_DOCKIND = TK.T_BOFFICEKIND
                                                                     AND GRDEAL.T_DOCID = TK.T_DEALID
                                                                     AND GRACC.T_GRDEALID = GRDEAL.T_ID
                                                                     AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                                                     AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П 
                                                                 ) THEN 1
                      ELSE 0 END);

      END IF;

      RETURN v_Amount;

   END; --WRTGetAmountFromRetire

   -- Возвращает количество ц/б на дату по всем ведённым операциям погашения ОЭБ со схожии параметрами.
   FUNCTION WRTGetAmountFromRetireOwn( Department     IN NUMBER,  -- Филиал
                                       FIID           IN NUMBER,  -- ц/б
                                       Coupon         IN VARCHAR2,-- Номер купона (пустая строка, если нет купона)
                                       DealID         IN NUMBER,  -- ID проверяемой операции погашения
                                       OnlyExecAcc    IN NUMBER DEFAULT 0,  -- Только с исполенным БУ
                                       RetAddIncome   IN NUMBER DEFAULT 0  -- Признак отбора операций погашения доп. дохода
                                     ) RETURN NUMBER DETERMINISTIC
   IS
      v_Amount NUMBER := 0;
   BEGIN

      IF RetAddIncome <> 0 THEN
        SELECT NVL(SUM(LEG.T_PRINCIPAL), 0) INTO v_Amount
          FROM DDL_TICK_DBT TK, DDL_LEg_DBT LEG, DOPRKOPER_DBT OPR
         WHERE TK.T_BOFFICEKIND = RSB_SECUR.DL_RETIREMENT_OWN
           AND LEG.T_DEALID = TK.T_DEALID
           AND LEG.T_LEGKIND = 0 --1ч
           AND LEG.T_LEGID = 0
           AND LEG.T_PFI = FIID
           AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN DealID = 0 THEN 1 WHEN DealID <> TK.T_DEALID THEN 1 ELSE 0 END)
           AND OPR.T_KIND_OPERATION = TK.T_DEALTYPE
           AND RSB_SECUR.IsRet_ADDINCOME(RSB_SECUR.get_OperationGroup(OPR.T_SYSTYPES)) = 1
           AND 1 = (CASE WHEN (OnlyExecAcc IS NULL OR OnlyExecAcc = 0)
                              AND EXISTS(SELECT 1 
                                       FROM DDLRQ_DBT RQ, DPMWRTSUM_DBT LOT 
                                      WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
                                        AND RQ.T_DOCID = TK.T_DEALID
                                        AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC
                                        AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                                        AND RQ.T_FIID = FIID
                                        AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                                        AND LOT.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                        AND LOT.T_DOCID = RQ.T_ID
                                     ) THEN 0
                          ELSE 1 END)
           AND 1 = (CASE WHEN OnlyExecAcc IS NULL OR OnlyExecAcc = 0 THEN 1
                          WHEN TK.T_DEALSTATUS > 0 AND NOT EXISTS(SELECT 1 
                                                                    FROM DDLGRDEAL_DBT GRDEAL, DDLGRACC_DBT GRACC
                                                                   WHERE GRDEAL.T_DOCKIND = TK.T_BOFFICEKIND
                                                                     AND GRDEAL.T_DOCID = TK.T_DEALID
                                                                     AND GRACC.T_GRDEALID = GRDEAL.T_ID
                                                                     AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                                                     AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П 
                                                                 ) THEN 1
                      ELSE 0 END);

      ELSIF ((Coupon IS NOT NULL) AND Coupon != chr(1) AND Coupon != chr(0)) THEN

         SELECT NVL(SUM(LEG.T_PRINCIPAL), 0) INTO v_Amount
           FROM DDL_TICK_DBT TK, DDL_LEg_DBT LEG, DOPRKOPER_DBT OPR
          WHERE TK.T_BOFFICEKIND = RSB_SECUR.DL_RETIREMENT_OWN
            AND LEG.T_DEALID = TK.T_DEALID
            AND LEG.T_LEGKIND = 0 --1ч
            AND LEG.T_LEGID = 0
            AND LEG.T_PFI = FIID
            AND TK.T_NUMBER_COUPON = Coupon
            AND OPR.T_KIND_OPERATION = TK.T_DEALTYPE
            AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END)
            AND 1 = (CASE WHEN DealID = 0 THEN 1 WHEN DealID <> TK.T_DEALID THEN 1 ELSE 0 END)
            AND 1 = (CASE WHEN (OnlyExecAcc IS NULL OR OnlyExecAcc = 0) AND RSB_SECUR.IsRet_Issue(RSB_SECUR.get_OperationGroup(OPR.T_SYSTYPES)) = 1 
                                AND EXISTS(SELECT 1 
                                             FROM DDLRQ_DBT RQ, DPMWRTSUM_DBT LOT 
                                            WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
                                              AND RQ.T_DOCID = TK.T_DEALID
                                              AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC
                                              AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                                              AND RQ.T_FIID = FIID
                                              AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                                              AND LOT.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                              AND LOT.T_DOCID = RQ.T_ID
                                          ) THEN 0
                           ELSE 1 END)
            AND 1 = (CASE WHEN OnlyExecAcc IS NULL OR OnlyExecAcc = 0 THEN 1
                          WHEN TK.T_DEALSTATUS > 0 AND NOT EXISTS(SELECT 1 
                                                                    FROM DDLGRDEAL_DBT GRDEAL, DDLGRACC_DBT GRACC
                                                                   WHERE GRDEAL.T_DOCKIND = TK.T_BOFFICEKIND
                                                                     AND GRDEAL.T_DOCID = TK.T_DEALID
                                                                     AND GRACC.T_GRDEALID = GRDEAL.T_ID
                                                                     AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                                                     AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П 
                                                                 ) THEN 1
                      ELSE 0 END);

      ELSE

        SELECT NVL(SUM(LEG.T_PRINCIPAL), 0) INTO v_Amount
          FROM DDL_TICK_DBT TK, DDL_LEg_DBT LEG, DOPRKOPER_DBT OPR
         WHERE TK.T_BOFFICEKIND = RSB_SECUR.DL_RETIREMENT_OWN
           AND LEG.T_DEALID = TK.T_DEALID
           AND LEG.T_LEGKIND = 0 --1ч
           AND LEG.T_LEGID = 0
           AND LEG.T_PFI = FIID
           AND 1 = (CASE WHEN Department = -1 THEN 1 WHEN Department = TK.T_DEPARTMENT THEN 1 ELSE 0 END)
           AND 1 = (CASE WHEN DealID = 0 THEN 1 WHEN DealID <> TK.T_DEALID THEN 1 ELSE 0 END)
           AND OPR.T_KIND_OPERATION = TK.T_DEALTYPE
           AND RSB_SECUR.IsRet_Issue(RSB_SECUR.get_OperationGroup(OPR.T_SYSTYPES)) = 1
           AND 1 = (CASE WHEN (OnlyExecAcc IS NULL OR OnlyExecAcc = 0)
                              AND EXISTS(SELECT 1 
                                       FROM DDLRQ_DBT RQ, DPMWRTSUM_DBT LOT 
                                      WHERE RQ.T_DOCKIND = TK.T_BOFFICEKIND
                                        AND RQ.T_DOCID = TK.T_DEALID
                                        AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC
                                        AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                                        AND RQ.T_FIID = FIID
                                        AND RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                                        AND LOT.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                        AND LOT.T_DOCID = RQ.T_ID
                                     ) THEN 0
                          ELSE 1 END)
           AND 1 = (CASE WHEN OnlyExecAcc IS NULL OR OnlyExecAcc = 0 THEN 1
                          WHEN TK.T_DEALSTATUS > 0 AND NOT EXISTS(SELECT 1 
                                                                    FROM DDLGRDEAL_DBT GRDEAL, DDLGRACC_DBT GRACC
                                                                   WHERE GRDEAL.T_DOCKIND = TK.T_BOFFICEKIND
                                                                     AND GRDEAL.T_DOCID = TK.T_DEALID
                                                                     AND GRACC.T_GRDEALID = GRDEAL.T_ID
                                                                     AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                                                     AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П 
                                                                 ) THEN 1
                      ELSE 0 END);

      END IF;

      RETURN v_Amount;

   END; --WRTGetAmountFromRetireOwn

   -- Возвращает к-во ц/б в наличии у клиента по операции к погашению, по которым не введены погашения купонов/ЧП/выпусков на дату.
   FUNCTION WRTGetWrtAmount( Department     IN NUMBER,  -- Филиал
                             FIID           IN NUMBER,  -- ц/б
                             Party          IN NUMBER,  -- Владелец
                             Contract       IN NUMBER,  -- Договор обслуживания( если -1 то считаем и Бо ЦБ и ДУ)
                             Coupon         IN VARCHAR2,-- Номер купона (пустая строка, если нет купона)
                             Partly         IN VARCHAR2,-- Номер ЧП  (пустая строка, если нет ЧП)
                             CalcDate       IN DATE,    -- Дата расчета
                             StartDate      IN DATE,    -- Дата отбора лотов покупки. Если не задана  - игнорируется
                             DealID         IN NUMBER   -- ID проверяемой операции погашения
                           ) RETURN NUMBER DETERMINISTIC
   IS
      v_Amount NUMBER := 0;
      K_post   NUMBER := 0;
      K_pog    NUMBER := 0;
      v_CalcDate DATE;
   BEGIN
      if (StartDate is null) OR (StartDate = UnknownDate) then
         v_CalcDate := CalcDate;
      else
         v_CalcDate := StartDate;
      end if;

      IF Party = -1 THEN
        K_post := WRTGetPortfolioAmount(Department, FIID, -1, -1, -1, -1, v_CalcDate, 1, 0, 0, 0);
      ELSIF Party = 0 THEN
        K_post := WRTGetPortfolioAmount(Department, FIID, -1, -1, -1, -1, v_CalcDate, 1, 0, 0, 0) +
                  WRTGetAmountByClient(Department, FIID, Party, Contract, v_CalcDate);
      ELSE
        K_post := WRTGetAmountByClient(Department, FIID, Party, Contract, v_CalcDate);
      END IF;

      K_pog := WRTGetAmountFromRetire(Department, FIID, Party, Contract, Coupon, Partly, DealID);

      v_Amount := K_post - K_pog; --это максимальное количество бумаг, на которое можно ввести погашение DealID

      return v_Amount;
   END; -- WRTGetWrtAmount

   --Возвращает к-во ц/б, по которым не выполнен учет купонов или ЧП в прямых Репо. Используется в погашениях купонов/ЧП.
   FUNCTION WRTGetDirectRepoWrtAmount( Department     IN NUMBER,  -- Филиал
                                       FIID           IN NUMBER,  -- ц/б
                                       Party          IN NUMBER,  -- Владелец
                                       Contract       IN NUMBER,  -- Договор обслуживания
                                       PlanPortfolio  IN NUMBER,  -- Портфель планируемых лотов. Если не задан - игнорируется.
                                       IsPartial      IN NUMBER,  -- Признак ЧП
                                       CalcDate       IN DATE     -- Дата расчета
                                     ) RETURN NUMBER DETERMINISTIC
   IS
      Amount1  NUMBER := 0;
      Amount2  NUMBER := 0;
      Amount3  NUMBER := 0;
   BEGIN
      Amount1 := WRTGetPortfolioAmount(Department, FIID, Party, Contract, UnknownValue, UnknownValue, CalcDate, 0, 0, 1);
      Amount1 := Amount1 + WRTGetPortfolioAmount(Department, FIID, Party, Contract, PlanPortfolio, UnknownValue, CalcDate, 0, 1, 0);

      SELECT NVL(SUM(H.t_Amount),0)
        INTO Amount2
        FROM DPMWRTSUM_DBT H
       WHERE     ((H.t_Department = Department) OR (Department = -1))
             AND H.t_FIID = FIID
             AND ((Party = 0) OR (Party is NULL) OR (H.t_Party = Party))
             AND ((H.t_Contract  = Contract) OR (Contract = -1))
             AND H.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
             AND (((H.T_PORTFOLIO = PlanPortfolio) AND (H.T_STATE = PM_WRTSUM_NOTFORM)) OR (H.T_STATE = PM_WRTSUM_SALE_BPP))
             AND H.T_AMOUNT > 0
             AND H.T_CHANGEDATE = CalcDate
             AND H.T_ACTION = DECODE( IsPartial, 0, PM_WRT_UPDTMODE_COUPON, PM_WRT_UPDTMODE_PARTIAL );


      if( (PlanPortfolio IS NOT NULL) AND (PlanPortfolio != RSB_PMWRTOFF.KINDPORT_UNDEF) ) then
         SELECT NVL(SUM(B.t_Amount),0)
           INTO Amount3
           FROM DPMWRTBC_DBT B, DPMWRTSUM_DBT L
          WHERE     ((L.t_Department = Department) OR (Department = -1))
                AND B.t_FIID = FIID -- !!! Для непоставленных лотов ФИ может меняться, проверяем в истории
                AND L.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
                AND ((Party = 0) OR (Party is NULL) OR (L.t_Party = Party))
                AND ((L.t_Contract  = Contract) OR (Contract = -1))
                AND (((B.T_PORTFOLIO = PlanPortfolio) AND (B.T_STATE = PM_WRTSUM_NOTFORM)) OR (B.T_STATE = PM_WRTSUM_SALE_BPP))
                AND B.T_AMOUNT > 0
                AND B.T_CHANGEDATE = CalcDate
                AND B.T_ACTION = DECODE( IsPartial, 0, PM_WRT_UPDTMODE_COUPON, PM_WRT_UPDTMODE_PARTIAL )
                AND B.T_SUMID = L.T_SUMID;
      else
         SELECT NVL(SUM(B.t_Amount),0)
           INTO Amount3
           FROM DPMWRTBC_DBT B, DPMWRTSUM_DBT L
          WHERE     ((L.t_Department = Department) OR (Department = -1))
                AND L.t_FIID = FIID
                AND L.T_BUY_SALE = PM_WRITEOFF_SUM_BUY
                AND ((Party = 0) OR (Party is NULL) OR (L.t_Party = Party))
                AND ((L.t_Contract  = Contract) OR (Contract = -1))
                AND B.T_STATE = PM_WRTSUM_SALE_BPP
                AND B.T_AMOUNT > 0
                AND B.T_CHANGEDATE = CalcDate
                AND B.T_ACTION = DECODE( IsPartial, 0, PM_WRT_UPDTMODE_COUPON, PM_WRT_UPDTMODE_PARTIAL )
                AND B.T_SUMID = L.T_SUMID;
      end if;

      RETURN Amount1 - Amount2 - Amount3;
   END;

   FUNCTION GetDealSum(p_DocKind NUMBER, p_DocID NUMBER, p_SumKind IN NUMBER, p_ByDate IN DATE DEFAULT UnknownDate) RETURN NUMBER
   AS
     v_Sum NUMBER;
   BEGIN

     v_Sum := 0;

     FOR one_sum IN (SELECT T_SUM
                       FROM DDLSUM_DBT
                      WHERE T_DOCKIND = p_DocKind
                        AND T_DOCID = p_DocID
                        AND T_KIND = p_SumKind
                        AND T_DATE = (CASE WHEN p_ByDate <> UnknownDate THEN p_ByDate ELSE T_DATE END)
                     ORDER BY T_DATE DESC
                    )
     LOOP
       v_Sum := one_sum.T_SUM;
       EXIT;
     END LOOP;

     RETURN v_Sum;
   END;

   FUNCTION GetDealSumDate(p_DocKind NUMBER, p_DocID NUMBER, p_SumKind IN NUMBER) RETURN DATE
   AS
     v_Date DATE;
   BEGIN

     v_Date := TO_DATE('01.01.0001','DD.MM.YYYY');

     FOR one_sum IN (SELECT T_DATE
                       FROM DDLSUM_DBT
                      WHERE T_DOCKIND = p_DocKind
                        AND T_DOCID = p_DocID
                        AND T_KIND = p_SumKind
                     ORDER BY T_DATE DESC
                    )
     LOOP
       v_Date := one_sum.T_DATE;
       EXIT;
     END LOOP;

     RETURN v_Date;
   END;


   -- Возвращает списанные суммы с лота списания по группе списания (портфелю)
   PROCEDURE WRTGetSaleFinResult_EX( SaleID    IN NUMBER,  -- Списываемый лот
                                     Portfolio IN NUMBER,  -- Портфель. Если не задан - игнорируется.
                                     ParentLot IN NUMBER,  -- Метод учета лота по 1 ч.: 0  - Все лоты, 1 - Кроме лота по 1 ч., 2 -Только лот по 1 ч
                                     CostBuy              OUT NUMBER, --Списанная чистая стоимость ( (Счист))
                                     BalanceCostBuy       OUT NUMBER, --  Списанная текущая стоимость
                                     NKDBuy               OUT NUMBER, --  НКД ( (НКД упл.))
                                     InterestIncomeBuy    OUT NUMBER, -- Списанный начисленный ПД
                                     DiscountIncomeBuy    OUT NUMBER, -- писанный начисленный ДД
                                     NotCarryInterestBuy  OUT NUMBER, -- Списанный не отнесенный на доходы ПД  (?ПДне_отн)
                                     NotCarryDiscountBuy  OUT NUMBER, -- Списанный не отнесенный на доходы ДД  (?ДДне_отн)
                                     InterestIncomeAdd    OUT NUMBER, -- Доначисленный ПД (?Sдонач.ПДi)
                                     DiscountIncomeAdd    OUT NUMBER, -- Доначисленный ДД (?Sдонач.ДДi)
                                     NotCarryInterestAdd  OUT NUMBER, -- Доначисленный не отнесенный на доходы ПД  (?ПДне_отн)
                                     NotCarryDiscountAdd  OUT NUMBER, -- Доначисленный не отнесенный на доходы ДД  (?ДДне_отн)
                                     InterestIncomeSum    OUT NUMBER, -- Суммарный начисленный ПД (?ПДначисл)
                                     DiscountIncomeSum    OUT NUMBER, -- Суммарный начисленный ДД (?ДДначисл)
                                     NotCarryInterestSum  OUT NUMBER, -- Суммарный не отнесенный на доходы ПД  (?ПДне_отн)
                                     NotCarryDiscountSum  OUT NUMBER, -- Суммарный не отнесенный на доходы ДД  (?ДДне_отн)
                                     BalanceCostSum       OUT NUMBER, -- Суммарная текущая стоимость ( (Стек))
                                     OutlayBuy            OUT NUMBER, -- Списанные затраты
                                     OverAmountBuy        OUT NUMBER, -- Списанная сумма переоценки (?ПО)
                                     OverAmountAdd        OUT NUMBER, -- Сумма доначисленной переоценки
                                     OverAmountSum        OUT NUMBER, -- Суммарная списываемая переоценка
                                     ReservAmountBuy      OUT NUMBER, -- Списанная сумма резерва (Сумма созданного резерва)
                                     ReservAmountAdd      OUT NUMBER, -- Доначисленный резерв
                                     ReservAmountSum      OUT NUMBER, -- Сумма списываемого резерва
                                     BalanceCostBD        OUT NUMBER, -- Списанная стоимость в ОД (Часть остатка счета "- ОД", пропорциональная количеству ц/б, проданно-му из ТП и ППР)
                                     CostSale             OUT NUMBER, -- Проданная чистая стоимость (в ЧП - Sчпл)
                                     NKDSale              OUT NUMBER, -- НКД полученный (в погашении купона - SКуп_л)
                                     Amount               OUT NUMBER, -- Списанное к-во
                                     IncomeReservBuy      OUT NUMBER, -- Списанная сумма резерва ПДД (Сумма созданного резерва)
                                     IncomeReservAdd      OUT NUMBER, -- Доначисленный резерв по ПДД
                                     IncomeReservSum      OUT NUMBER, -- Списываемая сумма резерва по ПДД
                                     BonusAdd             OUT NUMBER, -- Доначисленная премия (?(SдоначПрi))
                                     CostSum              OUT NUMBER, -- Суммарная списанная чистая стоимость (в продаже -  Счист, в ЧП  -  ( Счист))
                                     StartDate             IN DATE   DEFAULT UnknownDate,   -- Дата отбора лотов покупки. Если не задана, игнорируется
                                     AfterStartDate        IN NUMBER DEFAULT 0, -- Признак отбора ц/б, купленных после даты отбора. 0 - нет, 1 - да
                                     BegBonus             OUT NUMBER, -- Начальная прамия (Премия0_2)
                                     OldBonus             OUT NUMBER, -- Премия начисленная до перемещения (S_Пр_начисл_1)
                                     BonusSum             OUT NUMBER, -- Суммарная начисленная премия
                                     BonusRest            OUT NUMBER, -- Остаток премии (? (ост. премии)
                                     NotWrtBonus          OUT NUMBER, -- сумма списания премии, не списанной на расходы
                                     AccounttedDefDiffBuy OUT NUMBER, -- Списанная сумма отсроченной разницы
                                     AccounttedDefDiffAdd OUT NUMBER, -- Доначисленная отсроченная разница
                                     AccounttedDefDiffSum OUT NUMBER, -- Суммарная списанная отсроченная разница
                                     CorrValueBuy         OUT NUMBER, -- Списанная сумма корректировки СС
                                     CorrIntToEIRBuy      OUT NUMBER, -- Списанная сумма корректировки % до ЭПС
                                     CorrIntToEIRAdd      OUT NUMBER, -- Добавленная корректировка % до ЭСП
                                     CorrIntToEIRSum      OUT NUMBER, -- Суммарная списываемая корректировка % до ЭПС
                                     EstReserveBuy        OUT NUMBER, -- Списанная сумма отсроченного резерва
                                     EstReserveAdd        OUT NUMBER, -- Доначисленный оценочный резерв
                                     EstReserveSum        OUT NUMBER, -- Суммарный списываемый оценочный резерв
                                     CorrEstReserveBuy    OUT NUMBER, -- Списанная сумма корректировки отсроченного резерва
                                     CorrEstReserveAdd    OUT NUMBER, -- Доначисленная корректировка оценочного резерва
                                     CorrEstReserveSum    OUT NUMBER, -- Суммарная списываемая корректировка оценочного резерва
                                     HedgCorrSum          OUT NUMBER, -- Суммарная списываемая начисленная корректировка хеджирования
                                     AmortHedgCorrSum     OUT NUMBER  -- Суммарная списываемая корректировка хеджирования, подлежащая амортизации
                                   )
   IS
     v_Korr_Discount0 NUMBER := 0;
     v_Korr_Bonus0    NUMBER := 0;
   BEGIN

      SELECT NVL(SUM(ROUND(Link.T_COSTBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_BALANCECOSTBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_NKDBUYAMOUNT,2)), 0),
             NVL(SUM(ROUND(Link.T_INTERESTINCOMEBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_DISCOUNTINCOMEBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_NOTCARRYINTERESTBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_NOTCARRYDISCOUNTBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_INTERESTINCOMEADD,2)), 0),
             NVL(SUM(ROUND(Link.T_DISCOUNTINCOMEADD,2)), 0),
             NVL(SUM(ROUND(Link.T_NOTCARRYINTERESTADD,2)), 0),
             NVL(SUM(ROUND(Link.T_NOTCARRYDISCOUNTADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.t_InterestIncomeBuy, 0),2)   + ROUND(NVL(Link.t_InterestIncomeAdd, 0),2)), 0),
             NVL(SUM(ROUND(NVL(Link.t_DiscountIncomeBuy, 0),2)   + ROUND(NVL(Link.t_DiscountIncomeAdd, 0),2)), 0),
             NVL(SUM(ROUND(NVL(Link.t_NotCarryInterestBuy, 0),2) + ROUND(NVL(Link.t_NotCarryInterestAdd, 0),2)), 0),
             NVL(SUM(ROUND(NVL(Link.t_NotCarryDiscountBuy, 0),2) + ROUND(NVL(Link.t_NotCarryDiscountAdd, 0),2)), 0),
             NVL(SUM(ROUND(NVL(Link.t_BalanceCostBuy, 0),2)      + ROUND(NVL(Link.t_InterestIncomeAdd, 0),2) + ROUND(NVL(Link.t_DiscountIncomeAdd, 0),2)), 0) - NVL(SUM(Link.T_BONUSADD), 0),
             NVL(SUM(ROUND(Link.T_OUTLAYBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_RESERVCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_RESERVADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_RESERVCHANGE, 0),2)        + ROUND(NVL(Link.T_RESERVADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_INCOMERESERVCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_INCOMERESERVADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_INCOMERESERVCHANGE, 0),2)  + ROUND(NVL(Link.T_INCOMERESERVADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_OVERCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_OVERAMOUNTADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_OVERCHANGE, 0),2)          + ROUND(NVL(Link.T_OVERAMOUNTADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_BALANCECOSTBD,2)), 0),
             NVL(SUM(ROUND(Link.T_COSTSALE,2)), 0),
             NVL(SUM(ROUND(Link.T_NKDSALEAMOUNT,2)), 0),
             NVL(SUM(Link.T_Amount), 0),
             NVL(SUM(Link.T_BONUSADD), 0),
             NVL(SUM(ROUND(Link.T_COSTBUY,2)), 0) - NVL(SUM(Link.T_BONUSADD), 0),
             NVL(SUM(Link.T_BEGBONUSCHANGE), 0),
             NVL(SUM(Link.T_OLDBONUSBUY), 0),
             NVL(SUM(ROUND(NVL(Link.T_BONUSBUY, 0),2) 
                   + ROUND(NVL(Link.T_BONUSADD, 0),2) 
                   - ROUND(NVL(Link.T_OLDBONUSBUY, 0),2)
                ), 0),
             NVL(SUM(ROUND(NVL(Link.T_BEGBONUSCHANGE, 0),2) 
                   - ROUND(NVL(Link.T_BONUSBUY, 0),2) 
                   - ROUND(NVL(Link.T_BONUSADD, 0),2) 
                   + ROUND(NVL(Link.T_OLDBONUSBUY, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_NOTWRTBONUSBUY,2)), 0) + NVL(SUM(ROUND(Link.T_BONUSADD,2)), 0),
             NVL(SUM(ROUND(Link.T_ACCOUNTEDDEFDIFFBUY,2)), 0),
             NVL(SUM(ROUND(Link.T_ACCOUNTEDDEFDIFFADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_ACCOUNTEDDEFDIFFBUY, 0),2) + ROUND(NVL(Link.T_ACCOUNTEDDEFDIFFADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_CORRVALUECHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_CORRINTTOEIRCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_CORRINTTOEIRADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_CORRINTTOEIRCHANGE, 0),2)  + ROUND(NVL(Link.T_CORRINTTOEIRADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_ESTRESERVCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_ESTRESERVEADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_ESTRESERVCHANGE, 0),2)     + ROUND(NVL(Link.T_ESTRESERVEADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_CORRESTRESERVCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_CORRESTRESERVEADD,2)), 0),
             NVL(SUM(ROUND(NVL(Link.T_CORRESTRESERVCHANGE, 0),2) + ROUND(NVL(Link.T_CORRESTRESERVEADD, 0),2)), 0),
             NVL(SUM(ROUND(Link.T_HEDGCORRCHANGE,2)), 0),
             NVL(SUM(ROUND(Link.T_AMORTHEDGCORRCHANGE,2)), 0)
        INTO CostBuy,
             BalanceCostBuy,
             NKDBuy,
             InterestIncomeBuy,
             DiscountIncomeBuy,
             NotCarryInterestBuy,
             NotCarryDiscountBuy,
             InterestIncomeAdd,
             DiscountIncomeAdd ,
             NotCarryInterestAdd,
             NotCarryDiscountAdd,
             InterestIncomeSum,
             DiscountIncomeSum,
             NotCarryInterestSum,
             NotCarryDiscountSum,
             BalanceCostSum,
             OutlayBuy  ,
             ReservAmountBuy,
             ReservAmountAdd,
             ReservAmountSum,
             IncomeReservBuy,
             IncomeReservAdd,
             IncomeReservSum,
             OverAmountBuy,
             OverAmountAdd,
             OverAmountSum,
             BalanceCostBD,
             CostSale,
             NKDSale,
             Amount,
             BonusAdd,
             CostSum,
             BegBonus,
             OldBonus,
             BonusSum ,
             BonusRest,
             NotWrtBonus,
             AccounttedDefDiffBuy,
             AccounttedDefDiffAdd,
             AccounttedDefDiffSum,
             CorrValueBuy,
             CorrIntToEIRBuy,
             CorrIntToEIRAdd,
             CorrIntToEIRSum,
             EstReserveBuy,
             EstReserveAdd,
             EstReserveSum,
             CorrEstReserveBuy,
             CorrEstReserveAdd,
             CorrEstReserveSum,
             HedgCorrSum,
             AmortHedgCorrSum
        FROM DPMWRTLNK_DBT Link, DPMWRTSUM_DBT LotBuy, DPMWRTSUM_DBT LotSale
       WHERE     Link.T_SALEID    = SaleID
             AND LotBuy.T_SUMID   = Link.T_BUYID
             AND LotSale.T_SUMID  = Link.T_SALEID
             AND LotBuy.t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
             AND LotBuy.t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE LotBuy.t_Portfolio END)
             AND (    (ParentLot = 0)
                   OR (ParentLot IS NULL)
                   OR ( ParentLot = 1 AND Link.T_BUYID != LotSale.T_PARENT)
                   OR ( ParentLot = 2 AND Link.T_BUYID  = LotSale.T_PARENT)
                 )
             AND ( (StartDate is null) OR (StartDate = UnknownDate) OR
                   (AfterStartDate = 0 AND
                    LotBuy.T_DATE <= StartDate AND
                    LotBuy.T_STATEDATE <= StartDate
                   ) OR
                   (AfterStartDate = 1 AND
                    (LotBuy.T_DATE > StartDate OR LotBuy.T_STATEDATE > StartDate)
                   )
                 );

       IF CALC_DISCOUNT_WITHOUT_PARTLY = DISCOUNT_WITHOUT_PARTLY_YES THEN
         SELECT (CASE WHEN CALC_DISCOUNT_WITHOUT_PARTLY = DISCOUNT_WITHOUT_PARTLY_YES THEN
                       NVL(SUM(GetDealSum(q.t_DocKind, q.t_DealID, DECODE(q.t_GroupID, 
                                                                          KINDPORT_SSPU, RSB_SECUR.DLSUM_SUM_DISCOUNT0_KORR_TP, 
                                                                          KINDPORT_SSSD, RSB_SECUR.DLSUM_SUM_DISCOUNT0_KORR_PPR, 
                                                                          KINDPORT_ASCB, RSB_SECUR.DLSUM_SUM_DISCOUNT0_KORR_PUDP, 0), q.T_CREATEDATE)), 0)
                      ELSE 0 END)
           INTO v_Korr_Discount0
           FROM (SELECT LotSale.t_DocKind, LotSale.t_DealID, LotBuy.t_GroupID, Link.T_CREATEDATE
                   FROM DPMWRTLNK_DBT Link, DPMWRTSUM_DBT LotBuy, DPMWRTSUM_DBT LotSale
                  WHERE Link.T_SALEID    = SaleID
                    AND LotBuy.T_SUMID   = Link.T_BUYID
                    AND LotSale.T_SUMID  = Link.T_SALEID
                    AND LotBuy.t_Portfolio != (CASE WHEN (Portfolio is NULL) OR (Portfolio = UnknownValue) THEN KINDPORT_CONTR ELSE KINDPORT_UNDEF-1 /*несуществующий портфель*/ END)
                    AND LotBuy.t_Portfolio  = (CASE WHEN (Portfolio is not NULL) and (Portfolio != UnknownValue) THEN Portfolio ELSE LotBuy.t_Portfolio END)
                    AND (    (ParentLot = 0)
                          OR (ParentLot IS NULL)
                          OR ( ParentLot = 1 AND Link.T_BUYID != LotSale.T_PARENT)
                          OR ( ParentLot = 2 AND Link.T_BUYID  = LotSale.T_PARENT)
                        )
                    AND ( (StartDate is null) OR (StartDate = UnknownDate) OR
                          (AfterStartDate = 0 AND
                           LotBuy.T_DATE <= StartDate AND
                           LotBuy.T_STATEDATE <= StartDate
                          ) OR
                          (AfterStartDate = 1 AND
                           (LotBuy.T_DATE > StartDate OR LotBuy.T_STATEDATE > StartDate)
                          )
                        )
                  GROUP BY LotSale.t_DocKind, LotSale.t_DealID, LotBuy.t_GroupID, Link.T_CREATEDATE
                 ) q;

         DiscountIncomeSum := DiscountIncomeSum + v_Korr_Discount0;

       END IF;


   END;

   PROCEDURE WRTGetSaleFinResult( SaleID    IN NUMBER,  -- Списываемый лот
                                  Portfolio IN NUMBER,  -- Портфель. Если не задан - игнорируется.
                                  ParentLot IN NUMBER,  -- Метод учета лота по 1 ч.: 0  - Все лоты, 1 - Кроме лота по 1 ч., 2 -Только лот по 1 ч
                                  CostBuy              OUT NUMBER, --Списанная чистая стоимость ( (Счист))
                                  BalanceCostBuy       OUT NUMBER, --  Списанная текущая стоимость
                                  NKDBuy               OUT NUMBER, --  НКД ( (НКД упл.))
                                  InterestIncomeBuy    OUT NUMBER, -- Списанный начисленный ПД
                                  DiscountIncomeBuy    OUT NUMBER, -- писанный начисленный ДД
                                  NotCarryInterestBuy  OUT NUMBER, -- Списанный не отнесенный на доходы ПД  (?ПДне_отн)
                                  NotCarryDiscountBuy  OUT NUMBER, -- Списанный не отнесенный на доходы ДД  (?ДДне_отн)
                                  InterestIncomeAdd    OUT NUMBER, -- Доначисленный ПД (?Sдонач.ПДi)
                                  DiscountIncomeAdd    OUT NUMBER, -- Доначисленный ДД (?Sдонач.ДДi)
                                  NotCarryInterestAdd  OUT NUMBER, -- Доначисленный не отнесенный на доходы ПД  (?ПДне_отн)
                                  NotCarryDiscountAdd  OUT NUMBER, -- Доначисленный не отнесенный на доходы ДД  (?ДДне_отн)
                                  InterestIncomeSum    OUT NUMBER, -- Суммарный начисленный ПД (?ПДначисл)
                                  DiscountIncomeSum    OUT NUMBER, -- Суммарный начисленный ДД (?ДДначисл)
                                  NotCarryInterestSum  OUT NUMBER, -- Суммарный не отнесенный на доходы ПД  (?ПДне_отн)
                                  NotCarryDiscountSum  OUT NUMBER, -- Суммарный не отнесенный на доходы ДД  (?ДДне_отн)
                                  BalanceCostSum       OUT NUMBER, -- Суммарная текущая стоимость ( (Стек))
                                  OutlayBuy            OUT NUMBER, -- Списанные затраты
                                  OverAmountBuy        OUT NUMBER, -- Списанная сумма переоценки (?ПО)
                                  ReservAmountBuy      OUT NUMBER, -- Списанная сумма резерва (Сумма созданного резерва)
                                  IncomeReservBuy      OUT NUMBER, -- Списанная сумма резерва ПДД (Сумма созданного резерва)
                                  BalanceCostBD        OUT NUMBER, -- Списанная стоимость в ОД (Часть остатка счета "- ОД", пропорциональная количеству ц/б, проданно-му из ТП и ППР)
                                  CostSale             OUT NUMBER, -- Проданная чистая стоимость (в ЧП - Sчпл)
                                  NKDSale              OUT NUMBER  -- НКД полученный (в погашении купона - SКуп_л)
                                )
   IS
      Amount       NUMBER;
      IncomeReserv NUMBER;
      BonusAdd     NUMBER;
      CostSum      NUMBER;
      v_BegBonus            NUMBER;
      v_OldBonus            NUMBER;
      v_BonusSum            NUMBER;
      v_BonusRest           NUMBER;
      v_NotWrtBonus         NUMBER;
      v_OverAmountAdd       NUMBER;
      v_OverAmountSum       NUMBER;
      v_ReservAmountAdd     NUMBER;
      v_ReservAmountSum     NUMBER;
      v_IncomeReservAdd     NUMBER;
      v_IncomeReservSum     NUMBER;
      v_AccountedDefDiffBuy NUMBER;
      v_AccountedDefDiffAdd NUMBER;
      v_AccountedDefDiffSum NUMBER;
      v_CorrValueBuy        NUMBER;
      v_CorrIntToEIRBuy     NUMBER;
      v_CorrIntToEIRAdd     NUMBER;
      v_CorrIntToEIRSum     NUMBER;
      v_EstReserveBuy       NUMBER;
      v_EstReserveAdd       NUMBER;
      v_EstReserveSum       NUMBER;
      v_CorrEstReserveBuy   NUMBER;
      v_CorrEstReserveAdd   NUMBER;
      v_CorrEstReserveSum   NUMBER;
      v_HedgCorrSum         NUMBER;
      v_AmortHedgCorrSum    NUMBER;
   BEGIN
      WRTGetSaleFinResult_EX( SaleID,
                              Portfolio,
                              ParentLot,
                              CostBuy,
                              BalanceCostBuy,
                              NKDBuy,
                              InterestIncomeBuy,
                              DiscountIncomeBuy,
                              NotCarryInterestBuy,
                              NotCarryDiscountBuy,
                              InterestIncomeAdd,
                              DiscountIncomeAdd,
                              NotCarryInterestAdd,
                              NotCarryDiscountAdd,
                              InterestIncomeSum,
                              DiscountIncomeSum,
                              NotCarryInterestSum,
                              NotCarryDiscountSum,
                              BalanceCostSum,
                              OutlayBuy,
                              OverAmountBuy,
                              v_OverAmountAdd,
                              v_OverAmountSum,
                              ReservAmountBuy,
                              v_ReservAmountAdd,
                              v_ReservAmountSum,
                              BalanceCostBD,
                              CostSale,
                              NKDSale,
                              Amount,
                              IncomeReserv,
                              v_IncomeReservAdd,
                              v_IncomeReservSum,
                              BonusAdd,
                              CostSum,
                              null,
                              null,
                              v_BegBonus,
                              v_OldBonus,
                              v_BonusSum,
                              v_BonusRest,
                              v_NotWrtBonus,
                              v_AccountedDefDiffBuy,
                              v_AccountedDefDiffAdd,
                              v_AccountedDefDiffSum,
                              v_CorrValueBuy,
                              v_CorrIntToEIRBuy,
                              v_CorrIntToEIRAdd,
                              v_CorrIntToEIRSum,
                              v_EstReserveBuy,
                              v_EstReserveAdd,
                              v_EstReserveSum,
                              v_CorrEstReserveBuy,
                              v_CorrEstReserveAdd,
                              v_CorrEstReserveSum,
                              v_HedgCorrSum,
                              v_AmortHedgCorrSum
                            );
   END;

    -- Выполняет резервирование по одному лоту
    PROCEDURE RSI_WRTReserveLot( p_OperDate        IN DATE,
                             p_SumID           IN NUMBER,
                             p_ID_Operation    IN NUMBER,
                             p_ID_Step         IN NUMBER,
                             p_ReservAmount    IN NUMBER, -- Новый резерв
                             p_SetIncomeReserv IN NUMBER, -- Признак установки резерва по ПДД
                             p_IncomeReserv    IN NUMBER  -- Новый резерв ПДД
                           )
    IS
    BEGIN
       RSI_WRTSaveLot( p_SumID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_RESERV );

       IF( p_SetIncomeReserv != 0 ) THEN
          UPDATE DPMWRTSUM_DBT
             SET t_ReservDate    = p_OperDate,
                 t_ReservAmount  = p_ReservAmount,
                 T_IncomeReserv  = p_IncomeReserv
           WHERE t_SumID   = p_SumID;
       ELSE
          UPDATE DPMWRTSUM_DBT
             SET t_ReservDate    = p_OperDate,
                 t_ReservAmount  = p_ReservAmount
           WHERE t_SumID   = p_SumID;
       END IF;

    END;

    FUNCTION RSI_QualityCategory( p_FIID IN NUMBER, p_Date IN DATE ) RETURN NUMBER DETERMINISTIC
    IS
       v_QualityCategory NUMBER := 0;
    BEGIN
       BEGIN
           SELECT TO_NUMBER(Attr.t_NumInList) INTO v_QualityCategory
             FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
            WHERE     AtCor.t_ObjectType = 12  -- OBJTYPE_AVOIRISS
                  AND AtCor.t_GroupID    = 13 -- Категория качества
                  AND AtCor.t_Object     = LPAD( p_FIID, 10, '0' )
                  AND AtCor.t_ValidFromDate  = ( SELECT MAX(t.T_ValidFromDate)
                                                   FROM DOBJATCOR_DBT t
                                                  WHERE     t.T_ObjectType = AtCor.T_ObjectType
                                                        AND t.T_GroupID    = AtCor.T_GroupID
                                                        AND t.t_Object     = AtCor.t_Object
                                                        AND t.T_ValidFromDate <= p_Date
                                                        AND (t.T_ValidToDate >= p_Date OR t.T_ValidToDate = UnknownDate)
                                               )
                  AND Attr.t_AttrID      = AtCor.t_AttrID
                  AND Attr.t_ObjectType  = AtCor.t_ObjectType
                  AND Attr.t_GroupID     = AtCor.t_GroupID
                  AND ROWNUM             = 1;

       EXCEPTION
          WHEN OTHERS THEN return 0;
       END;

       RETURN v_QualityCategory;
    END; -- RSI_QualityCategory

    FUNCTION RSI_QualityDeal( p_DealID IN NUMBER, p_Date IN DATE ) RETURN NUMBER DETERMINISTIC
    IS
       v_QualityCategory NUMBER := 0;
    BEGIN
       BEGIN
           SELECT TO_NUMBER(Attr.t_NumInList) INTO v_QualityCategory
             FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
            WHERE     AtCor.t_ObjectType = RSB_SECUR.OBJTYPE_SECDEAL
                  AND AtCor.t_GroupID    = 15 -- Категория качества
                  AND AtCor.t_Object     = LPAD( p_DealID, 34, '0' )
                  AND AtCor.t_ValidFromDate  = ( SELECT MAX(t.T_ValidFromDate)
                                                   FROM DOBJATCOR_DBT t
                                                  WHERE     t.T_ObjectType = AtCor.T_ObjectType
                                                        AND t.T_GroupID    = AtCor.T_GroupID
                                                        AND t.t_Object     = AtCor.t_Object
                                                        AND t.T_ValidFromDate <= p_Date
                                                        AND (t.T_ValidToDate >= p_Date OR t.T_ValidToDate = UnknownDate)
                                               )
                  AND Attr.t_AttrID      = AtCor.t_AttrID
                  AND Attr.t_ObjectType  = AtCor.t_ObjectType
                  AND Attr.t_GroupID     = AtCor.t_GroupID
                  AND ROWNUM             = 1;

       EXCEPTION
          WHEN OTHERS THEN return 0;
       END;

       RETURN v_QualityCategory;
    END; -- RSI_QualityDeal

    FUNCTION IS_TSS( p_FIID IN NUMBER, p_Date IN DATE ) RETURN NUMBER DETERMINISTIC
    IS
       v_IsTss NUMBER := 0;
    BEGIN
       BEGIN
           SELECT  1  INTO v_IsTss
             FROM dratedef_dbt rate
            WHERE  RATE.T_OTHERFI =  p_FIID
                  AND RATE.T_TYPE = 12 -- CC
                  AND RATE.T_SINCEDATE <= p_Date
                  AND ROWNUM             = 1;

       EXCEPTION
          WHEN OTHERS THEN return 0;
       END;

       RETURN v_IsTss;
    END; -- IS_TSS

   -- Выполняет резервирование по одному лоту во временную таблицу
   PROCEDURE RSI_WRTReservePortfolioLotsTMP( p_CalcDate         IN DATE,
                                             p_FIID             IN NUMBER,
                                             p_Department       IN NUMBER,
                                             p_Portfolio        IN NUMBER, -- Портфель
                                             p_State            IN NUMBER, -- Статус
                                             p_CalcIncomeReserv IN NUMBER, -- Признак расчета резерва по ПДД
                                             p_ByLnk            IN NUMBER  -- Признак: только по лотам из связи DPMWRTLNK_TMP
                                        )
   IS
      v_IsForm           NUMBER := 0;
      v_IsBPP            NUMBER := 0;
      v_Prc              NUMBER;
      v_Cat              NUMBER;
      v_CalcIncomeReserv NUMBER := 0;
      v_AvoirKind        NUMBER;
      v_Rold             NUMBER;
      v_Roldpdd          NUMBER;
      v_Rnew             NUMBER;
      v_Rnewpdd          NUMBER;
      v_Cnt              NUMBER;
      v_LotTMP           dpmwrtsum_tmp%rowtype;
      v_B                NUMBER;
      v_FaceFI           NUMBER := -1;
      v_Bpdd             NUMBER;
      v_i                NUMBER := 0;
      v_IsRegValRVP2     NUMBER := 0;
      v_DealID           NUMBER := 0;
      v_PrcDeal          NUMBER;
      v_CatDeal          NUMBER;
      v_Codedeal         VARCHAR2(30);
      v_OD               NUMBER;
      v_RnewTemp         NUMBER;
      v_DealType         NUMBER;
      v_BofficeKind      NUMBER;
      v_PrcTemp          NUMBER;
      v_AmountDeal       NUMBER;

   CURSOR cLot IS
      SELECT LOT.*
        FROM DPMWRTSUM_DBT LOT
       WHERE LOT.T_PARTY      = -1
         AND LOT.T_DEPARTMENT = p_Department
         AND LOT.T_CONTRACT   = 0
         AND LOT.T_Portfolio  = p_Portfolio
         AND LOT.T_BUY_SALE   = PM_WRITEOFF_SUM_BUY
         AND LOT.T_STATEDATE <= p_CalcDate
         AND LOT.T_DATE      <= p_CalcDate
         AND LOT.T_FIID       = p_FIID
         AND LOT.T_STATE      = p_State
         AND (CASE WHEN p_ByLnk <> 0 THEN
                      CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = LOT.T_SUMID) THEN 1 ELSE 0 END
                   ELSE 1 END
             ) = 1
         AND LOT.T_AMOUNT     > 0;

   BEGIN
     IF (Rsb_Common.GetRegIntValue('CB\РЕЗЕРВЫ\РВП ПО ПР. РЕПО', 0) = 2) THEN
       v_IsRegValRVP2 := 1;
     END IF;
     
     IF (p_CalcDate < RsbSessionData.curdate) THEN
        IF p_State = PM_WRTSUM_FORM THEN
           v_IsForm := 1;
        END IF;
        IF p_State = PM_WRTSUM_SALE_BPP THEN
           v_IsBPP := 1;
        END IF;

        IF (WRTAreGlobalChangesAfterDate(p_Department, p_FIID, -1, 0, p_Portfolio, UnknownValue, UnknownValue, UnknownValue, UnknownValue, p_CalcDate, v_IsForm, 0, v_IsBPP) > 0) THEN
           SetError( WRTOFF_ERROR_20220 );
        END IF;
     END IF;

     SELECT FIN.t_AvoirKind, FIN.T_FACEVALUEFI INTO v_AvoirKind, v_FaceFI
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID =  p_FIID;

     IF ((p_CalcIncomeReserv <> 0) AND
         RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) OR
         (p_Portfolio = KINDPORT_RETIRE)) THEN
        v_CalcIncomeReserv := 1;
     END IF;

     FOR LOT IN cLot LOOP
        v_Rold    := LOT.T_RESERVAMOUNT;
        v_Roldpdd := 0; v_Rnew := 0; v_Rnewpdd := 0; v_Bpdd := 0;
        IF p_CalcIncomeReserv <> 0 THEN
           v_Roldpdd := LOT.T_INCOMERESERV;
        END IF;
        v_Codedeal := '';
        v_DealID   := 0;

        IF(p_State = PM_WRTSUM_SALE_BPP) THEN
          --найти сделку
          BEGIN
            SELECT LotDeal.T_DEALID, LotDeal.T_DEALCODE INTO v_DealID, v_Codedeal
            FROM DPMWRTSUM_DBT LotDeal
            WHERE LotDeal.T_SUMID = LOT.T_PARENT;
          END; 
          --ОД  
          BEGIN
            SELECT rq.T_AMOUNT INTO v_OD
            FROM DDLRQ_DBT rq
            WHERE rq.T_DOCID = v_DealID
            AND rq.T_DOCKIND = RSB_SECUR.OBJTYPE_SECDEAL
            AND rq.T_DEALPART = 1 --по первойчасти
            AND rq.T_KIND = 0 -- требование
            AND rq.T_TYPE = 2 --оплата
            ;
          END; 
          

          v_CatDeal := RSI_QualityDeal( v_DealID, p_CalcDate );

          IF (v_CatDeal <> 1) THEN
             -- Для сделки определеить процент резервирования
             v_PrcDeal := NVL (Rsb_SCTX.GetNoteText (RSB_SECUR.OBJTYPE_SECDEAL, LPAD(v_DealID, 34, '0'), 8, p_CalcDate),0);
          ELSE
             v_Prc := 0;
          END IF;
  
          IF ((v_CatDeal = 1 AND v_PrcDeal <> 0) OR
             (v_CatDeal = 2 AND (v_PrcDeal < 1 OR v_PrcDeal > 20)) OR
             (v_CatDeal = 3 AND (v_PrcDeal < 21 OR v_PrcDeal > 50)) OR
             (v_CatDeal = 4 AND (v_PrcDeal < 51 OR v_PrcDeal > 99)) OR
             (v_CatDeal = 5 AND v_PrcDeal <> 100)) THEN
               SetError( WRTOFF_ERROR_28103,to_char(v_Codedeal)) ;
          END IF;
          v_PrcDeal := v_PrcDeal / 100;
          
          BEGIN
            SELECT tick.t_DealType, tick.t_BofficeKind, leg.t_principal INTO v_DealType, v_BofficeKind, v_AmountDeal
            FROM DDL_TICK_DBT tick, ddl_leg_dbt leg
            WHERE tick.T_DEALID = v_DealID
            AND leg.t_DealID = tick.T_DEALID
            AND leg.t_LegKind = 0
            AND leg.t_LegID = 0;
          END; 


          IF(v_i = 0 AND (v_IsRegValRVP2 = 0)) THEN --на выпуске смотрим только для значении настройки != 2
            -- Получить для ценной бумаги категорию качества
            v_Cat := RSI_QualityCategory( p_FIID, p_CalcDate );
            IF (v_Cat = 0) THEN
               SetError( WRTOFF_ERROR_20265 );
            END IF;
            

            IF (v_Cat <> 1) THEN

               IF(rsb_secur.IsBasket(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(v_DealType, v_BofficeKind))) = 0) THEN -- Не корзина
               -- Для ценной бумаги определеить процент резервирования
                 v_Prc := RSI_GetNoteTextNum( RSB_SECUR.OBJTYPE_AVOIRISS, LPAD(p_FIID, 10, '0'), 3, p_CalcDate );
                 IF (v_Prc < 0) THEN
                    SetError( WRTOFF_ERROR_20264, to_char(p_CalcDate) );
                 END IF;
               ELSE -- корзина
                 FOR c IN (select x.T_FIID 
                  from (SELECT ens.t_FIID, SUM (ENS.T_PRINCIPAL * (case when ENS.T_KIND = 0 thEn 1 else -1 END)) as SUM
                   FROM DDL_TICK_ENS_DBT ens
                  WHERE ens.T_DEALID = v_DealID
                  group by ens.t_FIID)   x
                  WHERE x.SUM > 0)                   
 
                  LOOP
                    v_PrcTemp := RSI_GetNoteTextNum( RSB_SECUR.OBJTYPE_AVOIRISS, LPAD(c.t_FIID, 10, '0'), 3, p_CalcDate );
                    IF (v_PrcTemp < 0) THEN
                      SetError( WRTOFF_ERROR_20264, to_char(p_CalcDate) );
                    END IF;
                    IF(v_PrcTemp > v_Prc) THEN
                      v_Prc :=v_PrcTemp;
                    END IF;
                    
                  END LOOP;
               
               END IF;
            ELSE
               v_Prc := 0;
            END IF;
  
            IF ((v_Cat = 1 AND v_Prc <> 0) OR
               (v_Cat = 2 AND (v_Prc < 1 OR v_Prc > 20)) OR
               (v_Cat = 3 AND (v_Prc < 21 OR v_Prc > 50)) OR
               (v_Cat = 4 AND (v_Prc < 51 OR v_Prc > 99)) OR
               (v_Cat = 5 AND v_Prc <> 100)) THEN
               SetError( WRTOFF_ERROR_20266 );
            END IF;
            v_Prc := v_Prc / 100;

            v_i := 1;
          END IF;


        ELSE

          IF(v_i = 0) THEN
            -- Получить для ценной бумаги категорию качества
            v_Cat := RSI_QualityCategory( p_FIID, p_CalcDate );
            IF (v_Cat = 0) THEN
               SetError( WRTOFF_ERROR_20265 );
            END IF;

            IF (v_Cat <> 1) THEN
               -- Для ценной бумаги определеить процент резервирования
               v_Prc := RSI_GetNoteTextNum( RSB_SECUR.OBJTYPE_AVOIRISS, LPAD(p_FIID, 10, '0'), 3, p_CalcDate );
               IF (v_Prc < 0) THEN
                  SetError( WRTOFF_ERROR_20264, to_char(p_CalcDate) );
               END IF;
            ELSE
               v_Prc := 0;
            END IF;
  
            IF ((v_Cat = 1 AND v_Prc <> 0) OR
               (v_Cat = 2 AND (v_Prc < 1 OR v_Prc > 20)) OR
               (v_Cat = 3 AND (v_Prc < 21 OR v_Prc > 50)) OR
               (v_Cat = 4 AND (v_Prc < 51 OR v_Prc > 99)) OR
               (v_Cat = 5 AND v_Prc <> 100)) THEN
               SetError( WRTOFF_ERROR_20266 );
            END IF;
            v_Prc := v_Prc / 100;

            v_i := 1;
          END IF;
        END IF;
        SELECT COUNT(1) INTO v_Cnt
          FROM DPMWRTSUM_TMP TMP
         WHERE TMP.T_SUMID = LOT.T_SUMID;

        IF( v_Cnt > 0 ) THEN
 
           SELECT TMP.* INTO v_LotTMP
             FROM DPMWRTSUM_TMP TMP
            WHERE TMP.T_SUMID = LOT.T_SUMID;

           IF(p_State = PM_WRTSUM_SALE_BPP) THEN
             IF p_Portfolio = KINDPORT_CONTR  THEN
                v_B := v_LotTMP.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT;
             ELSE
                v_B := RSI_RSB_FIInstr.ConvSum( (v_LotTMP.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
             END IF;
             v_Bpdd := RSI_RSB_FIInstr.ConvSum( (v_LotTMP.T_INTERESTINCOME + v_LotTMP.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
             v_B := v_B + v_Bpdd ; --S1
             v_RnewTemp := v_B  + v_LotTMP.T_OVERAMOUNT - v_OD * v_LotTMP.T_AMOUNT/v_AmountDeal;
             IF( (v_IsRegValRVP2 = 1) OR (IS_TSS( p_FIID, p_CalcDate ) = 1)) THEN -- настройка 2
               IF(v_RnewTemp <0) THEN
                 v_Rnew := 0;
               ELSE
                 v_Rnew := v_RnewTemp * v_PrcDeal;
               END IF;
             ELSE
               IF (v_PrcDeal < v_Prc) THEN
                 v_PrcDeal := v_Prc;
               END IF;
               IF(v_RnewTemp <0) THEN
                 v_Rnew := v_OD * v_LotTMP.T_AMOUNT/v_AmountDeal * v_Prc;
               ELSE
                 v_Rnew := v_OD * v_LotTMP.T_AMOUNT/v_AmountDeal * v_Prc + v_RnewTemp * v_PrcDeal;
               END IF;
             END IF;
             v_Rnewpdd :=v_Roldpdd;
           ELSE
           -- Резерв РВЦБ
             IF p_Portfolio = KINDPORT_CONTR AND p_State = PM_WRTSUM_SALE_BPP THEN
                v_B := v_LotTMP.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT;
             ELSE
                v_B := RSI_RSB_FIInstr.ConvSum( (v_LotTMP.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
             END IF;
             v_Rnew := v_B * v_Prc;

             -- Резерв РВПЦБ
             IF v_CalcIncomeReserv <> 0 THEN
                v_Bpdd := RSI_RSB_FIInstr.ConvSum( (v_LotTMP.T_INTERESTINCOME + v_LotTMP.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
                v_Rnewpdd := v_Bpdd * v_Prc;
             END IF;
           END IF;

           UPDATE DPMWRTSUM_TMP
              SET T_RESERVAMOUNTADD = ROUND(v_Rnew - v_Rold, 2),
                  T_INCOMERESERVADD = ROUND(v_Rnewpdd - v_Roldpdd, 2)
            WHERE t_SumID = v_LotTMP.t_SumID;

        ELSE

           IF(p_State = PM_WRTSUM_SALE_BPP) THEN
             IF p_Portfolio = KINDPORT_CONTR  THEN
                v_B := Lot.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT;
             ELSE
                v_B := RSI_RSB_FIInstr.ConvSum( (Lot.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
             END IF;
             v_Bpdd := RSI_RSB_FIInstr.ConvSum( (Lot.T_INTERESTINCOME + Lot.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
             v_B := v_B + v_Bpdd ; --S1
             v_RnewTemp := v_B + Lot.T_OVERAMOUNT - v_OD * Lot.T_AMOUNT/v_AmountDeal;
             
             IF( (v_IsRegValRVP2 = 1) OR (IS_TSS( p_FIID, p_CalcDate ) = 1)) THEN -- настройка 2
               IF(v_RnewTemp <0) THEN
                 v_Rnew := 0;
               ELSE
                 v_Rnew := v_RnewTemp * v_PrcDeal;
               END IF;
             ELSE
               IF (v_PrcDeal < v_Prc) THEN
                 v_PrcDeal := v_Prc;
               END IF;
               IF(v_RnewTemp <0) THEN
                 v_Rnew := v_OD * Lot.T_AMOUNT/v_AmountDeal * v_Prc;
               ELSE
                 v_Rnew := v_OD * Lot.T_AMOUNT/v_AmountDeal * v_Prc + v_RnewTemp * v_PrcDeal;
                 
               END IF;
             END IF;
             v_Rnewpdd := v_Roldpdd;

           ELSE

           -- Резерв РВЦБ
             IF p_Portfolio = KINDPORT_CONTR AND p_State = PM_WRTSUM_SALE_BPP THEN
                v_B := Lot.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT;
             ELSE
                v_B := RSI_RSB_FIInstr.ConvSum( (Lot.T_COST + Lot.T_COSTPFI + Lot.T_NKDAMOUNT), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
             END IF;
             v_Rnew := v_B * v_Prc;

           -- Резерв РВПЦБ
             IF v_CalcIncomeReserv <> 0 THEN
                v_Bpdd := RSI_RSB_FIInstr.ConvSum( (LOT.T_INTERESTINCOME + LOT.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
                v_Rnewpdd := v_Bpdd * v_Prc;
             END IF;
           
           END IF;

           v_LotTMP := NULL;

           v_LotTMP.T_SUMID              := LOT.T_SUMID;
           v_LotTMP.T_AMOUNT             := LOT.T_AMOUNT;
           v_LotTMP.T_COST               := LOT.T_COST;
           v_LotTMP.T_BALANCECOST        := LOT.T_BALANCECOST;
           v_LotTMP.T_INTERESTINCOME     := LOT.T_INTERESTINCOME;
           v_LotTMP.T_NOTCARRYINTEREST   := LOT.T_NOTCARRYINTEREST;
           v_LotTMP.T_INTERESTDATE       := LOT.T_INTERESTDATE;
           v_LotTMP.T_BEGDISCOUNTDATE    := LOT.T_BEGDISCOUNTDATE;
           v_LotTMP.T_BEGBONUSDATE       := LOT.T_BEGBONUSDATE;
           v_LotTMP.T_DISCOUNTINCOME     := LOT.T_DISCOUNTINCOME;
           v_LotTMP.T_NOTCARRYDISCOUNT   := LOT.T_NOTCARRYDISCOUNT;
           v_LotTMP.T_DISCOUNTDATE       := LOT.T_DISCOUNTDATE;
           v_LotTMP.T_BONUS              := LOT.T_BONUS;
           v_LotTMP.T_BONUSDATE          := LOT.T_BONUSDATE;
           v_LotTMP.T_NOTWRTBONUS        := LOT.T_NOTWRTBONUS;
           v_LotTMP.T_ACCOUNTEDDEFDIFF   := LOT.T_ACCOUNTEDDEFDIFF;
           v_LotTMP.T_DEFDIFFDATE        := LOT.T_DEFDIFFDATE;
           v_LotTMP.T_WRTOUTLAY          := LOT.T_WRTOUTLAY;
           v_LotTMP.T_WRTOUTLAYDATE      := LOT.T_WRTOUTLAYDATE;
           v_LotTMP.T_WRTVATOUTLAY       := LOT.T_WRTVATOUTLAY;
           v_LotTMP.T_CORRVALUE          := LOT.T_CORRVALUE;
           v_LotTMP.T_CORRDATE           := LOT.T_CORRDATE;
           v_LotTMP.T_AMORTCOST          := LOT.T_AMORTCOST;
           v_LotTMP.T_CORRINTTOEIR       := LOT.T_CORRINTTOEIR;
           v_LotTMP.T_CORRINTTOEIRDATE   := LOT.T_CORRINTTOEIRDATE;
           v_LotTMP.T_RESERVAMOUNTADD    := ROUND(v_Rnew - v_Rold, 2);
           v_LotTMP.T_INCOMERESERVADD    := ROUND(v_Rnewpdd - v_Roldpdd, 2);
           v_LotTMP.T_PORTFOLIO          := LOT.T_PORTFOLIO;
           v_LotTMP.T_STATE              := LOT.T_STATE;
           v_LotTMP.T_OVERAMOUNT         := LOT.T_OVERAMOUNT;
           v_LotTMP.T_DEALID             := LOT.T_DEALID;
           v_LotTMP.T_ESTRESERVEDATE     := LOT.T_ESTRESERVEDATE;    
           v_LotTMP.T_CORRESTRESERVEDATE := LOT.T_CORRESTRESERVEDATE;

           RSI_InsDfltIntoWRTSUM_TMP(v_LotTMP);

           INSERT INTO DPMWRTSUM_TMP VALUES v_LotTMP;
        END IF;

     END LOOP;
   END;--RSI_WRTReservePortfolioLotsTMP

   --Выполняет резервирование по одному лоту во временную таблицу
   PROCEDURE RSI_WRTReserveLotsTMP(p_CalcDate           IN DATE,
                                   p_FIID               IN NUMBER,
                                   p_Department         IN NUMBER,
                                   p_CalcIncomeReserv   IN NUMBER,
                                   p_ByLnk              IN NUMBER DEFAULT 0
                                  )
   IS
      v_AvoirKindRoot NUMBER;
   BEGIN
      SELECT RSI_RSB_FIInstr.FI_AvrKindsGetRoot( RSI_RSB_FIInstr.FIKIND_AVOIRISS, FIN.t_AvoirKind )
        INTO v_AvoirKindRoot
        FROM DFININSTR_DBT FIN
       WHERE FIN.T_FIID =  p_FIID;

      IF v_AvoirKindRoot = RSI_RSB_FIInstr.AVOIRKIND_BOND THEN
         RSI_WRTReservePortfolioLotsTMP(p_CalcDate, p_FIID, p_Department, KINDPORT_RETIRE, PM_WRTSUM_FORM, p_CalcIncomeReserv, p_ByLnk);
         RSI_WRTReservePortfolioLotsTMP(p_CalcDate, p_FIID, p_Department, KINDPORT_RETIRE, PM_WRTSUM_SALE_BPP, p_CalcIncomeReserv, p_ByLnk);
         RSI_WRTReservePortfolioLotsTMP(p_CalcDate, p_FIID, p_Department, KINDPORT_PROMISSORY, PM_WRTSUM_FORM, 0, p_ByLnk);
      ELSIF v_AvoirKindRoot = RSI_RSB_FIInstr.AVOIRKIND_SHARE OR
            v_AvoirKindRoot = RSI_RSB_FIInstr.AVOIRKIND_INVESTMENT_SHARE THEN
         RSI_WRTReservePortfolioLotsTMP(p_CalcDate, p_FIID, p_Department, KINDPORT_CONTR, PM_WRTSUM_FORM, 0, p_ByLnk);
      END IF;

      RSI_WRTReservePortfolioLotsTMP(p_CalcDate, p_FIID, p_Department, KINDPORT_CONTR, PM_WRTSUM_SALE_BPP, 0, p_ByLnk);

   END;

   PROCEDURE RSI_WRTReservePortfolioLotsTMP_usr( p_CalcDate         IN DATE,
                                             p_FIID             IN NUMBER,
                                             p_Department       IN NUMBER,
                                             p_Portfolio        IN NUMBER, -- Портфель
                                             p_State            IN NUMBER, -- Статус
                                             p_CalcIncomeReserv IN NUMBER, -- Признак расчета резерва по ПДД
                                             p_ByLnk            IN NUMBER  -- Признак: только по лотам из связи DPMWRTLNK_TMP
                                        )
   IS
      v_IsForm           NUMBER := 0;
      v_IsBPP            NUMBER := 0;
      v_Prc              NUMBER;
      v_Cat              NUMBER;
      v_CalcIncomeReserv NUMBER := 0;
      v_AvoirKind        NUMBER;
      v_Rold             NUMBER;
      v_Roldpdd          NUMBER;
      v_Rnew             NUMBER;
      v_Rnewpdd          NUMBER;
      v_Cnt              NUMBER;
      v_LotTMP           dpmwrtsum_tmp%rowtype;
      v_B                NUMBER;
      v_FaceFI           NUMBER := -1;
      v_Bpdd             NUMBER;
      v_i                NUMBER := 0;

   /*CURSOR cLot IS
      SELECT LOT.*
        FROM DPMWRTSUM_DBT LOT
       WHERE LOT.T_PARTY      = -1
         AND LOT.T_DEPARTMENT = p_Department
         AND LOT.T_CONTRACT   = 0
         AND LOT.T_Portfolio  = p_Portfolio
         AND LOT.T_BUY_SALE   = PM_WRITEOFF_SUM_BUY
         AND LOT.T_STATEDATE <= p_CalcDate
         AND LOT.T_DATE      <= p_CalcDate
         AND LOT.T_FIID       = p_FIID
         AND LOT.T_STATE      = p_State
         AND (CASE WHEN p_ByLnk <> 0 THEN
                      CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = LOT.T_SUMID) THEN 1 ELSE 0 END
                   ELSE 1 END
             ) = 1
         AND LOT.T_AMOUNT     > 0;*/
         CURSOR cLot IS SELECT Lot.*
                        FROM v_scwrthistex Lot
                        WHERE Lot.t_Party = -1
                           and Lot.t_Department = p_Department
                           and Lot.t_Contract = 0
                           and Lot.t_Portfolio in (KINDPORT_RETIRE, KINDPORT_PROMISSORY, KINDPORT_SALE)
                           and Lot.t_Buy_Sale = PM_WRITEOFF_SUM_BUY --зачисление
                           --and Lot.t_StateDate <= p_CalcDate
                           --and Lot.t_Date <= p_CalcDate
                           and lot.t_changedate <=p_CalcDate
                           and lot.t_instance = (select max(tt.t_instance) from v_scwrthistex tt where tt.t_sumid = lot.t_sumid and tt.t_changedate <=p_CalcDate)
                           and Lot.t_FIID = p_FIID
                           and Lot.t_State IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP) --поставлен, продан БПП
                           and (CASE WHEN p_ByLnk <> 0 THEN
                                        CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = Lot.T_SUMID) THEN 1 ELSE 0 END
                                     ELSE 1 END
                               ) = 1
                           and Lot.t_Amount > 0;
   BEGIN
     IF (p_CalcDate < RsbSessionData.curdate) THEN
        IF p_State = PM_WRTSUM_FORM THEN
           v_IsForm := 1;
        END IF;
        IF p_State = PM_WRTSUM_SALE_BPP THEN
           v_IsBPP := 1;
        END IF;
        IF (WRTAreGlobalChangesAfterDate(p_Department, p_FIID, -1, 0, p_Portfolio, UnknownValue, UnknownValue, UnknownValue, UnknownValue, p_CalcDate, v_IsForm, 0, v_IsBPP) > 0) THEN
           SetError( WRTOFF_ERROR_20220 );
        END IF;
     END IF;
     SELECT FIN.t_AvoirKind, FIN.T_FACEVALUEFI INTO v_AvoirKind, v_FaceFI
       FROM DFININSTR_DBT FIN
      WHERE FIN.T_FIID =  p_FIID;
     IF ((p_CalcIncomeReserv <> 0) AND
         RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) OR
         (p_Portfolio = KINDPORT_RETIRE)) THEN
        v_CalcIncomeReserv := 1;
     END IF;
     FOR LOT IN cLot LOOP
        v_Rold    := LOT.T_RESERVAMOUNT;
        v_Roldpdd := 0; v_Rnew := 0; v_Rnewpdd := 0; v_Bpdd := 0;
        IF p_CalcIncomeReserv <> 0 THEN
           v_Roldpdd := LOT.T_INCOMERESERV;
        END IF;
        IF(v_i = 0) THEN
          -- Получить для ценной бумаги категорию качества
          v_Cat := RSI_QualityCategory( p_FIID, p_CalcDate );
          IF (v_Cat = 0) THEN
             SetError( WRTOFF_ERROR_20265 );
          END IF;
          IF (v_Cat <> 1) THEN
             -- Для ценной бумаги определеить процент резервирования
             v_Prc := RSI_GetNoteTextNum( RSB_SECUR.OBJTYPE_AVOIRISS, LPAD(p_FIID, 10, '0'), 3, p_CalcDate );
             IF (v_Prc < 0) THEN
                SetError( WRTOFF_ERROR_20264, to_char(p_CalcDate) );
             END IF;
          END IF;
          IF ((v_Cat = 1 AND v_Prc <> 0) OR
             (v_Cat = 2 AND (v_Prc < 1 OR v_Prc > 20)) OR
             (v_Cat = 3 AND (v_Prc < 21 OR v_Prc > 50)) OR
             (v_Cat = 4 AND (v_Prc < 51 OR v_Prc > 99)) OR
             (v_Cat = 5 AND v_Prc <> 100)) THEN
             SetError( WRTOFF_ERROR_20266 );
          END IF;
          v_Prc := v_Prc / 100;
          v_i := 1;
        END IF;
        SELECT COUNT(1) INTO v_Cnt
          FROM DPMWRTSUM_TMP TMP
         WHERE TMP.T_SUMID = LOT.T_SUMID;
        IF( v_Cnt > 0 ) THEN
           SELECT TMP.* INTO v_LotTMP
             FROM DPMWRTSUM_TMP TMP
            WHERE TMP.T_SUMID = LOT.T_SUMID;
           -- Резерв РВЦБ
           IF p_Portfolio = KINDPORT_CONTR AND p_State = PM_WRTSUM_SALE_BPP THEN
              v_B := v_LotTMP.T_BALANCECOST;
           ELSE
              v_B := RSI_RSB_FIInstr.ConvSum( (v_LotTMP.T_BALANCECOST - v_LotTMP.T_INTERESTINCOME - v_LotTMP.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
           END IF;
           v_Rnew := v_B * v_Prc;
           -- Резерв РВПЦБ
           IF v_CalcIncomeReserv <> 0 THEN
              v_Bpdd := RSI_RSB_FIInstr.ConvSum( (v_LotTMP.T_INTERESTINCOME + v_LotTMP.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
              v_Rnewpdd := v_Bpdd * v_Prc;
           END IF;

           UPDATE DPMWRTSUM_TMP
              SET T_RESERVAMOUNTADD = v_Rnew - v_Rold,
                  T_INCOMERESERVADD = v_Rnewpdd - v_Roldpdd
            WHERE t_SumID = v_LotTMP.t_SumID;

        ELSE
           -- Резерв РВЦБ
           IF p_Portfolio = KINDPORT_CONTR AND p_State = PM_WRTSUM_SALE_BPP THEN
              v_B := LOT.T_BALANCECOST;
           ELSE
              v_B := RSI_RSB_FIInstr.ConvSum( (LOT.T_BALANCECOST - LOT.T_INTERESTINCOME - LOT.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
           END IF;
           v_Rnew := v_B * v_Prc;

           -- Резерв РВПЦБ
           IF v_CalcIncomeReserv <> 0 THEN
              v_Bpdd := RSI_RSB_FIInstr.ConvSum( (LOT.T_INTERESTINCOME + LOT.T_DISCOUNTINCOME), v_FaceFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1 );
              v_Rnewpdd := v_Bpdd * v_Prc;
           END IF;

           v_LotTMP := NULL;

           v_LotTMP.T_SUMID            := LOT.T_SUMID;
           v_LotTMP.T_AMOUNT           := LOT.T_AMOUNT;
           v_LotTMP.T_COST             := LOT.T_COST;
           v_LotTMP.T_BALANCECOST      := LOT.T_BALANCECOST;
           v_LotTMP.T_INTERESTINCOME   := LOT.T_INTERESTINCOME;
           v_LotTMP.T_NOTCARRYINTEREST := LOT.T_NOTCARRYINTEREST;
           v_LotTMP.T_INTERESTDATE     := LOT.T_INTERESTDATE;
           v_LotTMP.T_BEGDISCOUNTDATE  := LOT.T_BEGDISCOUNTDATE;
           v_LotTMP.T_BEGBONUSDATE     := LOT.T_BEGBONUSDATE;
           v_LotTMP.T_DISCOUNTINCOME   := LOT.T_DISCOUNTINCOME;
           v_LotTMP.T_NOTCARRYDISCOUNT := LOT.T_NOTCARRYDISCOUNT;
           v_LotTMP.T_DISCOUNTDATE     := LOT.T_DISCOUNTDATE;
           v_LotTMP.T_BONUS            := LOT.T_BONUS;
           v_LotTMP.T_BONUSDATE        := LOT.T_BONUSDATE;
           v_LotTMP.T_NOTWRTBONUS      := LOT.T_NOTWRTBONUS;
           v_LotTMP.T_ACCOUNTEDDEFDIFF := LOT.T_ACCOUNTEDDEFDIFF;
--           v_LotTMP.T_DEFDIFFDATE      := LOT.T_DEFDIFFDATE;
--           v_LotTMP.T_WRTOUTLAY        := LOT.T_WRTOUTLAY;
--           v_LotTMP.T_WRTOUTLAYDATE    := LOT.T_WRTOUTLAYDATE;
--           v_LotTMP.T_WRTVATOUTLAY     := LOT.T_WRTVATOUTLAY;
--           v_LotTMP.T_CORRVALUE        := LOT.T_CORRVALUE;
--           v_LotTMP.T_CORRDATE         := LOT.T_CORRDATE;
--           v_LotTMP.T_AMORTCOST        := LOT.T_AMORTCOST;
--           v_LotTMP.T_CORRINTTOEIR     := LOT.T_CORRINTTOEIR;
--           v_LotTMP.T_CORRINTTOEIRDATE := LOT.T_CORRINTTOEIRDATE;
                   v_LotTMP.T_DEFDIFFDATE        := null;--LOT.T_DEFDIFFDATE;
                   v_LotTMP.T_WRTOUTLAY          := null;--LOT.T_WRTOUTLAY;
                   v_LotTMP.T_WRTOUTLAYDATE      := null;--LOT.T_WRTOUTLAYDATE;
                   v_LotTMP.T_WRTVATOUTLAY       := null;--LOT.T_WRTVATOUTLAY;
                   v_LotTMP.T_CORRVALUE          := null;--LOT.T_CORRVALUE;
                   v_LotTMP.T_CORRDATE           := null;--LOT.T_CORRDATE;
                   v_LotTMP.T_AMORTCOST          := null;-- LOT.T_AMORTCOST;
                   v_LotTMP.T_CORRINTTOEIR       := null;--LOT.T_CORRINTTOEIR;
                   v_LotTMP.T_CORRINTTOEIRDATE   := null;--LOT.T_CORRINTTOEIRDATE;
           v_LotTMP.T_RESERVAMOUNTADD  := v_Rnew - v_Rold;
           v_LotTMP.T_INCOMERESERVADD  := v_Rnewpdd - v_Roldpdd;
           v_LotTMP.T_PORTFOLIO        := LOT.T_PORTFOLIO;
           v_LotTMP.T_STATE            := LOT.T_STATE;
           v_LotTMP.T_OVERAMOUNT       := LOT.T_OVERAMOUNT;
           v_LotTMP.T_DEALID           := LOT.T_DEALID;
           RSI_InsDfltIntoWRTSUM_TMP(v_LotTMP);
           INSERT INTO DPMWRTSUM_TMP VALUES v_LotTMP;
        END IF;
     END LOOP;
   END;--RSI_WRTReservePortfolioLotsTMP
    --Выполняет формирование оценочного резерва по всем подходящим лотам
    PROCEDURE RSI_WRTEstReserveLotsTMP(p_CalcDate    IN DATE,
                                       p_FIID        IN NUMBER,
                                       p_Department  IN NUMBER,
                                       p_ByLnk       IN NUMBER DEFAULT 0
                                      )
    IS
        v_k NUMBER;
        v_NewEstReserve NUMBER;
        v_EstReserveAdd NUMBER;
        v_CorrEstReserveAdd NUMBER;
        v_IsExistsInTmp NUMBER;
        v_LotTMP        DPMWRTSUM_TMP%ROWTYPE;
        v_FaceValueFI   NUMBER;
        v_DecisionDate  DATE := CASE WHEN rsi_rsb_kernel.GetNote(RSB_SECUR.OBJTYPE_AVOIRISS, LPAD(p_FIID, 10, '0'), 108, p_CalcDate) IS NULL 
                                THEN TO_DATE ('01.01.0001', 'dd.mm.yyyy')
                                ELSE rsb_struct.getDate(rsi_rsb_kernel.GetNote(RSB_SECUR.OBJTYPE_AVOIRISS, LPAD(p_FIID, 10, '0'), 108, p_CalcDate)) 
                            END;
        v_NonRefundActive NUMBER := 0;

        CURSOR c_Lot IS SELECT Lot.*
                        FROM dpmwrtsum_dbt Lot
                        WHERE Lot.t_Party = -1
                           and Lot.t_Department = p_Department
                           and Lot.t_Contract = 0
                           and Lot.t_Portfolio in (KINDPORT_RETIRE, KINDPORT_PROMISSORY, KINDPORT_SALE, KINDPORT_CONTR)
                           and Lot.t_Buy_Sale = PM_WRITEOFF_SUM_BUY --зачисление
                           and Lot.t_StateDate <= p_CalcDate
                           and Lot.t_Date <= p_CalcDate
                           and Lot.t_FIID = p_FIID
                           and Lot.t_State IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP) --поставлен, продан БПП
                           and (CASE WHEN p_ByLnk <> 0 THEN
                                        CASE WHEN EXISTS(SELECT 1 FROM DPMWRTLNK_TMP LNK WHERE LNK.T_BUYID = Lot.T_SUMID) THEN 1 ELSE 0 END
                                     ELSE 1 END
                               ) = 1
                           and Lot.t_Amount > 0;
    BEGIN

        SELECT FIN.T_FACEVALUEFI
          INTO v_FaceValueFI
          FROM DFININSTR_DBT FIN
         WHERE FIN.T_FIID = p_FIID;
         
        IF v_DecisionDate != TO_DATE ('01.01.0001', 'dd.mm.yyyy')
        THEN
          v_NonRefundActive := 1;
        END IF;

        FOR Lot IN c_Lot LOOP
 
            CONTINUE WHEN (Lot.t_Portfolio = KINDPORT_SALE and ( RSI_RSB_FIInstr.FI_IsAvrKindBond (RSI_RSB_FIInstr.FI_AvrKindsGetRootByFIID(Lot.t_Fiid)) = false) );    -- для недолговых в портфеле СССД пропустим   
            v_EstReserveAdd := 0;
            v_CorrEstReserveAdd := 0;

            v_IsExistsInTmp := 0;

            v_K := TO_NUMBER(NVL(RSB_SCTX.GetNoteText(101/*DL_SECURITYDOC*/, LPAD(Lot.t_DealID, 10, '0'), 36, p_CalcDate),'0'))/100; -- 36 Коэффициент для ОР, в процентах

            IF v_K = 0
            THEN
              v_K := TO_NUMBER(NVL(RSB_SCTX.GetNoteText(12/*OBJTYPE_AVOIRISS*/, LPAD(p_FIID, 10, '0'), 24, p_CalcDate),'0'))/100; -- 24 Коэффициент для ОР, в процентах
            END IF;

            begin
              SELECT 1 INTO v_IsExistsInTmp FROM dual WHERE EXISTS(SELECT 1 FROM dpmwrtsum_tmp WHERE t_SumID = Lot.t_SumID);

            exception
              WHEN NO_DATA_FOUND THEN
              v_IsExistsInTmp :=0;
            end;

            IF v_IsExistsInTmp = 1
            THEN
                SELECT * INTO v_LotTMP FROM dpmwrtsum_tmp WHERE t_SumID = Lot.t_SumID;
                --v_NewEstReserve := ROUND(v_k * (RSI_RSB_FIInstr.ConvSum((v_LotTMP.t_Cost+Lot.t_CostPFI+Lot.t_NKDAmount+v_LotTMP.t_InterestIncome+v_LotTMP.t_DiscountIncome) , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1) + v_LotTMP.t_CorrValue + v_LotTMP.t_CorrIntToEIR), 2); -- Golovkin upgrade 61.1 distr
                IF v_NonRefundActive = 1 THEN
                  v_NewEstReserve := ROUND(v_k * 
                  (RSI_RSB_FIInstr.ConvSum(v_LotTMP.t_Cost, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(Lot.t_CostPFI , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(Lot.t_NKDAmount , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(v_LotTMP.t_InterestIncome , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(v_LotTMP.t_DiscountIncome , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  v_LotTMP.t_CorrValue + v_LotTMP.t_CorrIntToEIR + v_LotTMP.T_OVERAMOUNT), 2);/*IS:515742 Сумма резерва должна округлятся до 2-х знаков после запятой*/
                ELSE
                  v_NewEstReserve := ROUND(v_k * (RSI_RSB_FIInstr.ConvSum((v_LotTMP.t_Cost+Lot.t_CostPFI+Lot.t_NKDAmount+v_LotTMP.t_InterestIncome+v_LotTMP.t_DiscountIncome) , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1) + v_LotTMP.t_CorrValue + v_LotTMP.t_CorrIntToEIR + v_LotTMP.T_OVERAMOUNT), 2);/*IS:515742 Сумма резерва должна округлятся до 2-х знаков после запятой*/
                END IF;
                IF Lot.t_Portfolio = KINDPORT_SALE
                THEN
                    v_EstReserveAdd := v_NewEstReserve - Lot.t_reservAmount - v_LotTMP.t_ReservAmountAdd - Lot.t_IncomeReserv - v_LotTMP.t_IncomeReservAdd - Lot.t_EstReserve;
                END IF;

                IF Lot.t_Portfolio = KINDPORT_RETIRE OR Lot.t_Portfolio = KINDPORT_PROMISSORY OR Lot.t_Portfolio = KINDPORT_CONTR
                THEN
                    v_CorrEstReserveAdd := v_NewEstReserve - Lot.t_reservAmount - v_LotTMP.t_ReservAmountAdd - Lot.t_IncomeReserv - v_LotTMP.t_IncomeReservAdd - Lot.t_CorrEstReserve;
                ELSE
                    v_CorrEstReserveAdd := 0;
                END IF;

                UPDATE dpmwrtsum_tmp SET t_EstReserveAdd = v_EstReserveAdd,
                                         t_CorrEstReserveAdd = v_CorrEstReserveAdd
                WHERE t_SumID = Lot.t_SumID;
            ELSE
                --v_NewEstReserve := ROUND(v_k * (RSI_RSB_FIInstr.ConvSum((Lot.t_Cost+Lot.t_CostPFI+Lot.t_NKDAmount+Lot.t_InterestIncome+Lot.t_DiscountIncome), v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1) + Lot.t_CorrValue + Lot.t_CorrIntToEIR), 2); -- Golovkin upgrade 61.1 distr
                IF v_NonRefundActive = 1 THEN
                  v_NewEstReserve := ROUND(v_k * 
                  (RSI_RSB_FIInstr.ConvSum(Lot.t_Cost, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(Lot.t_CostPFI , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(Lot.t_NKDAmount , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(Lot.t_InterestIncome , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  RSI_RSB_FIInstr.ConvSum(Lot.t_DiscountIncome , v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_DecisionDate, 1) + 
                  Lot.t_CorrValue + Lot.t_CorrIntToEIR + v_LotTMP.T_OVERAMOUNT), 2);/*IS:515742 Сумма резерва должна округлятся до 2-х знаков после запятой*/
                ELSE
                  v_NewEstReserve := ROUND(v_k * (RSI_RSB_FIInstr.ConvSum((Lot.t_Cost+Lot.t_CostPFI+Lot.t_NKDAmount+Lot.t_InterestIncome+Lot.t_DiscountIncome), v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_CalcDate, 1) + Lot.t_CorrValue + Lot.t_CorrIntToEIR + v_LotTMP.T_OVERAMOUNT), 2);/*IS:515742 Сумма резерва должна округлятся до 2-х знаков после запятой*/
                END IF;
                IF Lot.t_Portfolio = KINDPORT_SALE
                THEN
                    v_EstReserveAdd := v_NewEstReserve - Lot.t_ReservAmount - Lot.t_IncomeReserv - Lot.t_EstReserve;
 
                END IF;

                IF Lot.t_Portfolio = KINDPORT_RETIRE OR Lot.t_Portfolio = KINDPORT_PROMISSORY OR Lot.t_Portfolio = KINDPORT_CONTR
                THEN
                    v_CorrEstReserveAdd := v_NewEstReserve - Lot.t_ReservAmount - Lot.t_IncomeReserv - Lot.t_CorrEstReserve;
                END IF;

                IF v_EstReserveAdd <> 0 OR v_CorrEstReserveAdd <> 0
                THEN
                   v_LotTMP := NULL;

                   v_LotTMP.T_SUMID              := LOT.T_SUMID;
                   v_LotTMP.T_AMOUNT             := LOT.T_AMOUNT;
                   v_LotTMP.T_COST               := LOT.T_COST;
                   v_LotTMP.T_BALANCECOST        := LOT.T_BALANCECOST;
                   v_LotTMP.T_INTERESTINCOME     := LOT.T_INTERESTINCOME;
                   v_LotTMP.T_NOTCARRYINTEREST   := LOT.T_NOTCARRYINTEREST;
                   v_LotTMP.T_INTERESTDATE       := LOT.T_INTERESTDATE;
                   v_LotTMP.T_BEGDISCOUNTDATE    := LOT.T_BEGDISCOUNTDATE;
                   v_LotTMP.T_BEGBONUSDATE       := LOT.T_BEGBONUSDATE;
                   v_LotTMP.T_DISCOUNTINCOME     := LOT.T_DISCOUNTINCOME;
                   v_LotTMP.T_NOTCARRYDISCOUNT   := LOT.T_NOTCARRYDISCOUNT;
                   v_LotTMP.T_DISCOUNTDATE       := LOT.T_DISCOUNTDATE;
                   v_LotTMP.T_BONUS              := LOT.T_BONUS;
                   v_LotTMP.T_BONUSDATE          := LOT.T_BONUSDATE;
                   v_LotTMP.T_NOTWRTBONUS        := LOT.T_NOTWRTBONUS;
                   v_LotTMP.T_ACCOUNTEDDEFDIFF   := LOT.T_ACCOUNTEDDEFDIFF;
                   v_LotTMP.T_DEFDIFFDATE        := LOT.T_DEFDIFFDATE;
                   v_LotTMP.T_WRTOUTLAY          := LOT.T_WRTOUTLAY;
                   v_LotTMP.T_WRTOUTLAYDATE      := LOT.T_WRTOUTLAYDATE;
                   v_LotTMP.T_WRTVATOUTLAY       := LOT.T_WRTVATOUTLAY;
                   v_LotTMP.T_CORRVALUE          := LOT.T_CORRVALUE;
                   v_LotTMP.T_CORRDATE           := LOT.T_CORRDATE;
                   v_LotTMP.T_AMORTCOST          := LOT.T_AMORTCOST;
                   v_LotTMP.T_CORRINTTOEIR       := LOT.T_CORRINTTOEIR;
                   v_LotTMP.T_CORRINTTOEIRDATE   := LOT.T_CORRINTTOEIRDATE;
                   v_LotTMP.T_ESTRESERVEADD      := v_EstReserveAdd;
                   v_LotTMP.T_ESTRESERVEDATE     := p_CalcDate;
                   v_LotTMP.T_CORRESTRESERVEADD  := v_CorrEstReserveAdd;
                   v_LotTMP.T_CORRESTRESERVEDATE := p_CalcDate;
                   v_LotTMP.T_RESERVAMOUNTADD    := 0;
                   v_LotTMP.T_INCOMERESERVADD    := 0;
                   v_LotTMP.T_RESERVDATE         := p_CalcDate;
                   v_LotTMP.T_PORTFOLIO          := LOT.T_PORTFOLIO;
                   v_LotTMP.T_STATE              := LOT.T_STATE;
                   v_LotTMP.T_OVERAMOUNT         := LOT.T_OVERAMOUNT;
                   v_LotTMP.T_DEALID             := LOT.T_DEALID;

                   RSI_InsDfltIntoWRTSUM_TMP(v_LotTMP);

                   INSERT INTO DPMWRTSUM_TMP VALUES v_LotTMP;
                END IF;
            END IF;
        END LOOP;

    END;

    --Выполняет отражение сумм резерва на лотах по данным из временной таблицы
    PROCEDURE RSI_WRTSaveReserveLots(p_OperDate     DATE,
                                     p_ID_Operation NUMBER,
                                     p_ID_Step      NUMBER)
    IS
        CURSOR c_Tmp IS SELECT * FROM dpmwrtsum_tmp;
    BEGIN
        FOR Tmp IN c_Tmp LOOP
            RSI_WRTSaveLot(Tmp.t_SumID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_RESERV);

            UPDATE dpmwrtsum_dbt SET t_ReservDate = p_OperDate,
                                     t_ReservAmount = t_RESERVAMOUNT + Tmp.t_ReservAmountAdd,
                                     t_IncomeReserv = t_INCOMERESERV + Tmp.t_IncomeReservAdd,
                                     t_EstReserveDate = p_OperDate,
                                     t_EstReserve = t_EstReserve + Tmp.t_EstReserveAdd,
                                     t_CorrEstReserveDate = p_OperDate,
                                     t_CorrEstReserve = t_CorrEstReserve + Tmp.t_CorrEstReserveAdd
            WHERE t_SumID = Tmp.t_SumID;
        END LOOP;

        DELETE FROM dpmwrtsum_tmp;
    END;

    FUNCTION PT_IsResponsible( PartyID IN NUMBER, OperDate IN DATE ) RETURN NUMBER DETERMINISTIC
    IS
       QualityCategory dobjattr_dbt.t_NumInList % TYPE;
       RegPartyActive BOOLEAN;
    BEGIN
       BEGIN
           SELECT Attr.t_NumInList INTO QualityCategory
             FROM dobjatcor_dbt AtCor, dobjattr_dbt Attr
            WHERE     AtCor.t_ObjectType = 3  -- OBJTYPE_PARTY
                  AND AtCor.t_GroupID    = 13 -- Категория качества
                  AND AtCor.t_Object     = LPAD( PartyID, 10, '0' )
                  AND AtCor.t_ValidFromDate  = ( SELECT MAX(t.T_ValidFromDate)
                                                   FROM DOBJATCOR_DBT t
                                                  WHERE     t.T_ObjectType = AtCor.T_ObjectType
                                                        AND t.T_GroupID    = AtCor.T_GroupID
                                                        AND t.t_Object     = AtCor.t_Object
                                                        AND t.T_ValidFromDate <= OperDate
                                               )
                  AND Attr.t_AttrID      = AtCor.t_AttrID
                  AND Attr.t_ObjectType  = AtCor.t_ObjectType
                  AND Attr.t_GroupID     = AtCor.t_GroupID;

       EXCEPTION
          WHEN NO_DATA_FOUND THEN QualityCategory := chr(0);
          WHEN OTHERS THEN
             return 0;
       END;

       IF( QualityCategory = '1' OR QualityCategory = '2' ) THEN
          return 1;
       ELSIF( QualityCategory = '4' OR QualityCategory = '5' ) THEN
          return 0;
       ELSIF( QualityCategory = '3' ) THEN
          RegPartyActive := Rsb_Common.GetRegBoolValue( 'COMMON\ПЕРЕМЕННЫЕ\СУБЪЕКТ 3Й КАТЕГОРИИ КАЧЕСТВА', 0 );
          IF( RegPartyActive = true ) THEN
             return 1;
          ELSE
             return 0;
          END IF;
       END IF;

       RETURN 0;
    END; -- PT_IsResponsible

    PROCEDURE RSI_WRTAverageRedistrSum( p_ID_Operation IN NUMBER, p_ID_Step IN NUMBER,
                                        p_SaleLot IN DPMWRTSUM_DBT%ROWTYPE,
                                        p_Portfolio IN NUMBER, p_Group IN NUMBER, p_CalcOver IN BOOLEAN )
    IS
       v_Amount      NUMBER;
       v_CurBuy      DPMWRTSUM_DBT%ROWTYPE;
       v_WriteOffLot DPMWRTSUM_DBT%ROWTYPE;
       v_WrtOverAmount NUMBER;
       v_CurOverAmount NUMBER;
       v_FaceValueFI NUMBER;


       CURSOR Lots IS (SELECT *
                         FROM DPMWRTSUM_DBT
                        WHERE t_Department = p_SaleLot.t_Department AND
                              t_FIID       = p_SaleLot.t_FIID AND
                              t_Party      = p_SaleLot.t_Party AND
                              (p_Group < 0 OR p_Group IS NULL OR t_GroupID = p_Group) AND
                              ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = t_Portfolio) ) AND
                              t_Contract   = p_SaleLot.t_Contract AND
                              t_State      = PM_WRTSUM_FORM AND
                              t_IsFree     = CHR(88) AND
                              t_Amount     > 0
                      );
    BEGIN

       SELECT t_FaceValueFI INTO v_FaceValueFI
         FROM dfininstr_dbt
        WHERE t_FIID = p_SaleLot.t_FIID;

       BEGIN
         SELECT NVL(SUM(t_Cost),0),
                NVL(SUM(t_BalanceCost),0),
                NVL(SUM(t_NKDAmount),0),
                NVL(SUM(t_InterestIncome),0),
                NVL(SUM(t_BegDiscount),0),
                NVL(SUM(t_OldBegDiscount),0),
                NVL(SUM(T_DISCOUNTCORR),0),
                NVL(SUM(t_DiscountIncome),0),
                NVL(SUM(t_ReservAmount),0),
                NVL(SUM(t_IncomeReserv),0),
                NVL(SUM(t_OverAmount),0),
                NVL(SUM(t_Outlay),0),
                NVL(SUM(t_BegBonus),0),
                NVL(SUM(T_OLDBEGBONUS),0),
                NVL(SUM(t_Bonus),0),
                NVL(SUM(t_OldBonus),0),
                NVL(SUM(T_COSTPFI),0),
                NVL(SUM(T_BEGDEFDIFF),0),
                NVL(SUM(T_ACCOUNTEDDEFDIFF),0),
                NVL(SUM(T_CORRINTTOEIR),0),
                NVL(SUM(T_CORRVALUE),0), 
                NVL(SUM(T_ESTRESERVE),0),
                NVL(SUM(T_CORRESTRESERVE),0),
                NVL(SUM(T_HEDGCORR),0),
                NVL(SUM(T_AMORTHEDGCORR),0)                   
           INTO v_WriteOffLot.t_Cost,
                v_WriteOffLot.t_BalanceCost,
                v_WriteOffLot.t_NKDAmount,
                v_WriteOffLot.t_InterestIncome,
                v_WriteOffLot.t_BegDiscount,
                v_WriteOffLot.t_OldBegDiscount,
                v_WriteOffLot.T_DISCOUNTCORR,
                v_WriteOffLot.t_DiscountIncome,
                v_WriteOffLot.t_ReservAmount,
                v_WriteOffLot.t_IncomeReserv,
                v_WriteOffLot.t_OverAmount,
                v_WriteOffLot.t_Outlay,
                v_WriteOffLot.t_BegBonus,
                v_WriteOffLot.T_OLDBEGBONUS,
                v_WriteOffLot.t_Bonus,
                v_WriteOffLot.t_OldBonus,
                v_WriteOffLot.T_COSTPFI,
                v_WriteOffLot.T_BEGDEFDIFF,
                v_WriteOffLot.T_ACCOUNTEDDEFDIFF,
                v_WriteOffLot.T_CORRINTTOEIR,
                v_WriteOffLot.T_CORRVALUE,
                v_WriteOffLot.T_ESTRESERVE,
                v_WriteOffLot.T_CORRESTRESERVE,
                v_WriteOffLot.T_HEDGCORR,
                v_WriteOffLot.T_AMORTHEDGCORR
           FROM DPMWRTSUM_DBT
          WHERE t_Department = p_SaleLot.t_Department AND
                t_FIID       = p_SaleLot.t_FIID AND
                t_Party      = p_SaleLot.t_Party AND
                (p_Group < 0 OR p_Group IS NULL OR t_GroupID = p_Group) AND
                ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = t_Portfolio) ) AND
                t_Contract   = p_SaleLot.t_Contract AND
                t_State      = PM_WRTSUM_FORM AND
                t_Amount     = 0 AND
                (t_Cost > 0 OR
                 t_BalanceCost > 0 OR
                 t_NKDAmount > 0 OR
                 t_InterestIncome > 0 OR
                 t_BegDiscount > 0 OR
                 t_OldBegDiscount > 0 OR
                 T_DISCOUNTCORR > 0 OR
                 t_DiscountIncome > 0 OR
                 t_ReservAmount > 0 OR
                 t_IncomeReserv > 0 OR
                 t_OverAmount <> 0 OR
                 t_Outlay > 0 OR
                 t_BegBonus > 0 OR
                 T_OLDBEGBONUS > 0 OR
                 t_Bonus > 0 OR
                 t_OldBonus > 0 OR
                 T_COSTPFI <> 0 OR 
                 T_BEGDEFDIFF <> 0 OR 
                 T_ACCOUNTEDDEFDIFF <> 0 OR
                 T_CORRINTTOEIR <> 0 OR
                 T_CORRVALUE    <> 0 OR
                 T_ESTRESERVE <> 0 OR
                 T_CORRESTRESERVE <> 0 OR
                 T_HEDGCORR <> 0 OR
                 T_AMORTHEDGCORR <> 0
                );
       END;

       IF( p_CalcOver AND (v_WriteOffLot.t_OverAmount <> 0) ) THEN
          v_WrtOverAmount := ROUND(RSI_RSB_FIInstr.ConvSum((v_WriteOffLot.t_BalanceCost - v_WriteOffLot.t_Cost - v_WriteOffLot.t_NKDAmount - v_WriteOffLot.t_InterestIncome - v_WriteOffLot.t_DiscountIncome), v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, p_SaleLot.t_Date, 1 ), 2) - v_WriteOffLot.t_CORRVALUE - v_WriteOffLot.t_CORRINTTOEIR - v_WriteOffLot.t_HEDGCORR - v_WriteOffLot.t_AMORTHEDGCORR;
       ELSE
          v_WrtOverAmount := v_WriteOffLot.t_OverAmount;
       END IF;

       -- лот покупки списался по кол-ву, но суммы остались
       IF(   v_WriteOffLot.T_COST>0
          OR v_WriteOffLot.T_BalanceCost>0
          OR v_WriteOffLot.T_NKDAMOUNT>0
          OR v_WriteOffLot.T_INTERESTINCOME>0
          OR v_WriteOffLot.T_BEGDISCOUNT>0
          OR v_WriteOffLot.T_OLDBEGDISCOUNT>0
          OR v_WriteOffLot.T_DISCOUNTCORR>0
          OR v_WriteOffLot.T_DISCOUNTINCOME>0
          OR v_WriteOffLot.T_RESERVAMOUNT>0
          OR v_WriteOffLot.T_INCOMERESERV>0
          OR v_WriteOffLot.T_OVERAMOUNT<>0
          OR v_WriteOffLot.T_OUTLAY>0
          OR v_WriteOffLot.T_BEGBONUS>0
          OR v_WriteOffLot.T_OLDBEGBONUS>0
          OR v_WriteOffLot.T_BONUS>0
          OR v_WriteOffLot.T_OLDBONUS>0
          OR v_WriteOffLot.T_COSTPFI<>0
          OR v_WriteOffLot.T_BEGDEFDIFF<>0
          OR v_WriteOffLot.T_ACCOUNTEDDEFDIFF<>0
          OR v_WriteOffLot.T_CORRINTTOEIR<>0
          OR v_WriteOffLot.T_CORRVALUE<>0
          OR v_WriteOffLot.T_ESTRESERVE<>0
          OR v_WriteOffLot.T_CORRESTRESERVE<>0
          OR v_WriteOffLot.T_HEDGCORR<>0
          OR v_WriteOffLot.T_AMORTHEDGCORR<>0
         ) THEN

          BEGIN
             SELECT NVL(SUM(t_Amount),0)
               INTO v_Amount
               FROM DPMWRTSUM_DBT
              WHERE t_Department = p_SaleLot.t_Department AND
                    t_FIID       = p_SaleLot.t_FIID AND
                    t_Party      = p_SaleLot.t_Party AND
                    (p_Group < 0 OR p_Group IS NULL OR t_GroupID = p_Group) AND
                    ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = t_Portfolio) ) AND
                    t_Contract   = p_SaleLot.t_Contract AND
                    t_State      = PM_WRTSUM_FORM AND
                    t_IsFree     = CHR(88);
          EXCEPTION
             WHEN NO_DATA_FOUND THEN v_Amount := 0;
          END;

          IF v_Amount = 0 THEN
             SetError( WRTOFF_ERROR_20231 ); -- При списании по средневзвешенной остались нераспределенные суммы
          ELSE

             FOR Lot IN Lots LOOP

               IF( v_Amount - Lot.t_Amount > 0 ) THEN
                   v_CurBuy.T_COST             := ROUND(v_WriteOffLot.T_COST            * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_NKDAMOUNT        := ROUND(v_WriteOffLot.T_NKDAMOUNT       * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_INTERESTINCOME   := ROUND(v_WriteOffLot.T_INTERESTINCOME  * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_BEGDISCOUNT      := ROUND(v_WriteOffLot.T_BEGDISCOUNT     * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_OLDBEGDISCOUNT   := ROUND(v_WriteOffLot.T_OLDBEGDISCOUNT  * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_DISCOUNTCORR     := ROUND(v_WriteOffLot.T_DISCOUNTCORR    * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_DISCOUNTINCOME   := ROUND(v_WriteOffLot.T_DISCOUNTINCOME  * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_RESERVAMOUNT     := ROUND(v_WriteOffLot.T_RESERVAMOUNT    * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_INCOMERESERV     := ROUND(v_WriteOffLot.T_INCOMERESERV    * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_OVERAMOUNT       := ROUND(v_WriteOffLot.T_OVERAMOUNT      * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_OUTLAY           := ROUND(v_WriteOffLot.T_OUTLAY          * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_BEGBONUS         := ROUND(v_WriteOffLot.T_BEGBONUS        * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_OLDBEGBONUS      := ROUND(v_WriteOffLot.T_OLDBEGBONUS     * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_BONUS            := ROUND(v_WriteOffLot.T_BONUS           * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_OLDBONUS         := ROUND(v_WriteOffLot.T_OLDBONUS        * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_COSTPFI          := ROUND(v_WriteOffLot.T_COSTPFI         * Lot.t_Amount/v_Amount,2);
                   v_CurOverAmount             := ROUND(v_WrtOverAmount                 * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_BEGDEFDIFF       := ROUND(v_WriteOffLot.T_BEGDEFDIFF      * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_ACCOUNTEDDEFDIFF := ROUND(v_WriteOffLot.T_ACCOUNTEDDEFDIFF* Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_CORRINTTOEIR     := ROUND(v_WriteOffLot.T_CORRINTTOEIR    * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_CORRVALUE        := ROUND(v_WriteOffLot.T_CORRVALUE       * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_ESTRESERVE       := ROUND(v_WriteOffLot.T_ESTRESERVE      * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_CORRESTRESERVE   := ROUND(v_WriteOffLot.T_CORRESTRESERVE  * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_HEDGCORR         := ROUND(v_WriteOffLot.T_HEDGCORR        * Lot.t_Amount/v_Amount,2);
                   v_CurBuy.T_AMORTHEDGCORR    := ROUND(v_WriteOffLot.T_AMORTHEDGCORR   * Lot.t_Amount/v_Amount,2);
               ELSE
                   v_CurBuy.T_COST             := v_WriteOffLot.T_COST             ;
                   v_CurBuy.T_BALANCECOST      := v_WriteOffLot.T_BALANCECOST      ;
                   v_CurBuy.T_NKDAMOUNT        := v_WriteOffLot.T_NKDAMOUNT        ;
                   v_CurBuy.T_INTERESTINCOME   := v_WriteOffLot.T_INTERESTINCOME   ;
                   v_CurBuy.T_BEGDISCOUNT      := v_WriteOffLot.T_BEGDISCOUNT      ;
                   v_CurBuy.T_OLDBEGDISCOUNT   := v_WriteOffLot.T_OLDBEGDISCOUNT   ;
                   v_CurBuy.T_DISCOUNTCORR     := v_WriteOffLot.T_DISCOUNTCORR     ;
                   v_CurBuy.T_DISCOUNTINCOME   := v_WriteOffLot.T_DISCOUNTINCOME   ;
                   v_CurBuy.T_RESERVAMOUNT     := v_WriteOffLot.T_RESERVAMOUNT     ;
                   v_CurBuy.T_INCOMERESERV     := v_WriteOffLot.T_INCOMERESERV     ;
                   v_CurBuy.T_OVERAMOUNT       := v_WriteOffLot.T_OVERAMOUNT       ;
                   v_CurBuy.T_OUTLAY           := v_WriteOffLot.T_OUTLAY           ;
                   v_CurBuy.T_BEGBONUS         := v_WriteOffLot.T_BEGBONUS         ;
                   v_CurBuy.T_OLDBEGBONUS      := v_WriteOffLot.T_OLDBEGBONUS      ;
                   v_CurBuy.T_BONUS            := v_WriteOffLot.T_BONUS            ;
                   v_CurBuy.T_OLDBONUS         := v_WriteOffLot.T_OLDBONUS         ;
                   v_CurBuy.T_COSTPFI          := v_WriteOffLot.T_COSTPFI          ;
                   v_CurOverAmount             := v_WrtOverAmount                  ;
                   v_CurBuy.T_BEGDEFDIFF       := v_WriteOffLot.T_BEGDEFDIFF       ;
                   v_CurBuy.T_ACCOUNTEDDEFDIFF := v_WriteOffLot.T_ACCOUNTEDDEFDIFF ;
                   v_CurBuy.T_CORRINTTOEIR     := v_WriteOffLot.T_CORRINTTOEIR     ;
                   v_CurBuy.T_CORRVALUE        := v_WriteOffLot.T_CORRVALUE        ;
                   v_CurBuy.T_ESTRESERVE       := v_WriteOffLot.T_ESTRESERVE       ;
                   v_CurBuy.T_CORRESTRESERVE   := v_WriteOffLot.T_CORRESTRESERVE   ;
                   v_CurBuy.T_HEDGCORR         := v_WriteOffLot.T_HEDGCORR         ;
                   v_CurBuy.T_AMORTHEDGCORR    := v_WriteOffLot.T_AMORTHEDGCORR    ;
               END IF;

               v_Amount := v_Amount - Lot.t_Amount;

               v_WriteOffLot.T_COST             := v_WriteOffLot.T_COST             - v_CurBuy.T_COST             ;
               v_WriteOffLot.T_BALANCECOST      := v_WriteOffLot.T_BALANCECOST      - v_CurBuy.T_BALANCECOST      ;
               v_WriteOffLot.T_NKDAMOUNT        := v_WriteOffLot.T_NKDAMOUNT        - v_CurBuy.T_NKDAMOUNT        ;
               v_WriteOffLot.T_INTERESTINCOME   := v_WriteOffLot.T_INTERESTINCOME   - v_CurBuy.T_INTERESTINCOME   ;
               v_WriteOffLot.T_BEGDISCOUNT      := v_WriteOffLot.T_BEGDISCOUNT      - v_CurBuy.T_BEGDISCOUNT      ;
               v_WriteOffLot.T_OLDBEGDISCOUNT   := v_WriteOffLot.T_OLDBEGDISCOUNT   - v_CurBuy.T_OLDBEGDISCOUNT   ;
               v_WriteOffLot.T_DISCOUNTCORR     := v_WriteOffLot.T_DISCOUNTCORR     - v_CurBuy.T_DISCOUNTCORR     ;
               v_WriteOffLot.T_DISCOUNTINCOME   := v_WriteOffLot.T_DISCOUNTINCOME   - v_CurBuy.T_DISCOUNTINCOME   ;
               v_WriteOffLot.T_RESERVAMOUNT     := v_WriteOffLot.T_RESERVAMOUNT     - v_CurBuy.T_RESERVAMOUNT     ;
               v_WriteOffLot.T_INCOMERESERV     := v_WriteOffLot.T_INCOMERESERV     - v_CurBuy.T_INCOMERESERV     ;
               v_WriteOffLot.T_OVERAMOUNT       := v_WriteOffLot.T_OVERAMOUNT       - v_CurBuy.T_OVERAMOUNT       ;
               v_WriteOffLot.T_OUTLAY           := v_WriteOffLot.T_OUTLAY           - v_CurBuy.T_OUTLAY           ;
               v_WriteOffLot.T_BEGBONUS         := v_WriteOffLot.T_BEGBONUS         - v_CurBuy.T_BEGBONUS         ;
               v_WriteOffLot.T_OLDBEGBONUS      := v_WriteOffLot.T_OLDBEGBONUS      - v_CurBuy.T_OLDBEGBONUS      ;
               v_WriteOffLot.T_BONUS            := v_WriteOffLot.T_BONUS            - v_CurBuy.T_BONUS            ;
               v_WriteOffLot.T_OLDBONUS         := v_WriteOffLot.T_OLDBONUS         - v_CurBuy.T_OLDBONUS         ;
               v_WriteOffLot.T_COSTPFI          := v_WriteOffLot.T_COSTPFI          - v_CurBuy.T_COSTPFI          ;
               v_WrtOverAmount                  := v_WrtOverAmount                  - v_CurOverAmount             ;
               v_WriteOffLot.T_BEGDEFDIFF       := v_WriteOffLot.T_BEGDEFDIFF       - v_CurBuy.T_BEGDEFDIFF       ;
               v_WriteOffLot.T_ACCOUNTEDDEFDIFF := v_WriteOffLot.T_ACCOUNTEDDEFDIFF - v_CurBuy.T_ACCOUNTEDDEFDIFF ;
               v_WriteOffLot.T_CORRINTTOEIR     := v_WriteOffLot.T_CORRINTTOEIR     - v_CurBuy.T_CORRINTTOEIR     ;
               v_WriteOffLot.T_CORRVALUE        := v_WriteOffLot.T_CORRVALUE        - v_CurBuy.T_CORRVALUE        ;
               v_WriteOffLot.T_ESTRESERVE       := v_WriteOffLot.T_ESTRESERVE       - v_CurBuy.T_ESTRESERVE       ;
               v_WriteOffLot.T_CORRESTRESERVE   := v_WriteOffLot.T_CORRESTRESERVE   - v_CurBuy.T_CORRESTRESERVE   ;
               v_WriteOffLot.T_HEDGCORR         := v_WriteOffLot.T_HEDGCORR         - v_CurBuy.T_HEDGCORR         ;
               v_WriteOffLot.T_AMORTHEDGCORR    := v_WriteOffLot.T_AMORTHEDGCORR    - v_CurBuy.T_AMORTHEDGCORR    ;

               v_CurBuy.T_BALANCECOST := v_CurBuy.T_COST + v_CurBuy.T_NKDAMOUNT + v_CurBuy.T_INTERESTINCOME + v_CurBuy.T_DISCOUNTINCOME + v_CurOverAmount 
                                         + ROUND(RSI_RSB_FIInstr.ConvSum(v_CurBuy.T_CORRVALUE, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, p_SaleLot.t_Date, 1 ), 2)
                                         + ROUND(RSI_RSB_FIInstr.ConvSum(v_CurBuy.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, p_SaleLot.t_Date, 1 ), 2)
                                         + ROUND(RSI_RSB_FIInstr.ConvSum(v_CurBuy.T_HEDGCORR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, p_SaleLot.t_Date, 1 ), 2)
                                         + ROUND(RSI_RSB_FIInstr.ConvSum(v_CurBuy.T_AMORTHEDGCORR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, p_SaleLot.t_Date, 1 ), 2);

               RSB_PMWRTOFF.RSI_WRTSaveLot( Lot.t_SumID, p_ID_Operation, p_ID_Step, p_SaleLot.t_Date, RSB_PMWRTOFF.PM_WRT_UPDTMODE_AVERAGE_DST );

               UPDATE dpmwrtsum_dbt
                  SET T_COST             = T_COST             + v_CurBuy.T_COST             ,
                      T_BALANCECOST      = T_BALANCECOST      + v_CurBuy.T_BALANCECOST      ,
                      T_NKDAMOUNT        = T_NKDAMOUNT        + v_CurBuy.T_NKDAMOUNT        ,
                      T_INTERESTINCOME   = T_INTERESTINCOME   + v_CurBuy.T_INTERESTINCOME   ,
                      T_INTERESTDATE     = (CASE WHEN Lot.t_INTERESTDATE = UnknownDate AND v_CurBuy.T_INTERESTINCOME > 0 THEN p_SaleLot.t_Date ELSE T_INTERESTDATE END),         
                      T_BEGDISCOUNT      = T_BEGDISCOUNT      + v_CurBuy.T_BEGDISCOUNT      ,
                      T_BEGDISCOUNTDATE  = (CASE WHEN Lot.t_BEGDISCOUNTDATE = UnknownDate AND v_CurBuy.T_BEGDISCOUNT > 0 THEN p_SaleLot.t_Date ELSE T_BEGDISCOUNTDATE END),
                      T_OLDBEGDISCOUNT   = T_OLDBEGDISCOUNT   + v_CurBuy.T_OLDBEGDISCOUNT   ,
                      T_DISCOUNTCORR     = T_DISCOUNTCORR     + v_CurBuy.T_DISCOUNTCORR     ,
                      T_DISCOUNTINCOME   = T_DISCOUNTINCOME   + v_CurBuy.T_DISCOUNTINCOME   ,
                      T_DISCOUNTDATE     = (CASE WHEN Lot.t_DISCOUNTDATE = UnknownDate AND v_CurBuy.T_DISCOUNTINCOME > 0 THEN p_SaleLot.t_Date ELSE T_DISCOUNTDATE END),
                      T_RESERVAMOUNT     = T_RESERVAMOUNT     + v_CurBuy.T_RESERVAMOUNT     ,
                      T_RESERVDATE       = (CASE WHEN Lot.t_RESERVDATE = UnknownDate AND (v_CurBuy.T_RESERVAMOUNT > 0 OR v_CurBuy.T_INCOMERESERV > 0) THEN p_SaleLot.t_Date ELSE T_RESERVDATE END),         
                      T_INCOMERESERV     = T_INCOMERESERV     + v_CurBuy.T_INCOMERESERV     ,
                      T_OVERAMOUNT       = T_OVERAMOUNT       + v_CurBuy.T_OVERAMOUNT       ,
                      T_OVERDATE         = (CASE WHEN Lot.t_OVERDATE = UnknownDate AND v_CurBuy.T_OVERAMOUNT > 0 THEN p_SaleLot.t_Date ELSE T_OVERDATE END),
                      T_OUTLAY           = T_OUTLAY           + v_CurBuy.T_OUTLAY           ,
                      T_BEGBONUS         = T_BEGBONUS         + v_CurBuy.T_BEGBONUS         ,
                      T_OLDBEGBONUS      = T_OLDBEGBONUS      + v_CurBuy.T_OLDBEGBONUS      ,
                      T_BONUS            = T_BONUS            + v_CurBuy.T_BONUS            ,
                      T_BONUSDATE        = (CASE WHEN Lot.t_BONUSDATE = UnknownDate AND v_CurBuy.T_BONUS > 0 THEN p_SaleLot.t_Date ELSE T_BONUSDATE END),
                      T_OLDBONUS         = T_OLDBONUS         + v_CurBuy.T_OLDBONUS         ,
                      T_COSTPFI          = T_COSTPFI          + v_CurBuy.T_COSTPFI          ,
                      T_BEGDEFDIFF       = T_BEGDEFDIFF       + v_CurBuy.T_BEGDEFDIFF       ,
                      T_ACCOUNTEDDEFDIFF = T_ACCOUNTEDDEFDIFF + v_CurBuy.T_ACCOUNTEDDEFDIFF ,
                      T_DEFDIFFDATE      = (CASE WHEN Lot.t_DEFDIFFDATE = UnknownDate AND v_CurBuy.T_ACCOUNTEDDEFDIFF <> 0 THEN p_SaleLot.t_Date ELSE T_DEFDIFFDATE END),         
                      T_CORRINTTOEIR     = T_CORRINTTOEIR     + v_CurBuy.T_CORRINTTOEIR     ,
                      T_CORRINTTOEIRDATE = (CASE WHEN Lot.t_CORRINTTOEIRDATE = UnknownDate AND v_CurBuy.T_CORRINTTOEIR <> 0 THEN p_SaleLot.t_Date ELSE T_CORRINTTOEIRDATE END),
                      T_CORRVALUE        = T_CORRVALUE        + v_CurBuy.T_CORRVALUE,
                      T_CORRDATE         = (CASE WHEN Lot.t_CORRDATE = UnknownDate AND v_CurBuy.T_CORRVALUE <> 0 THEN p_SaleLot.t_Date ELSE T_CORRDATE END),
                      T_ESTRESERVE       = T_ESTRESERVE       + v_CurBuy.T_ESTRESERVE,
                      T_CORRESTRESERVE   = T_CORRESTRESERVE   + v_CurBuy.T_CORRESTRESERVE,
                      T_HEDGCORR         = T_HEDGCORR         + v_CurBuy.T_HEDGCORR,
                      T_HEDGCORRDATE     = (CASE WHEN Lot.t_HEDGCORRDATE = UnknownDate AND v_CurBuy.T_HEDGCORR <> 0 THEN p_SaleLot.t_Date ELSE T_HEDGCORRDATE END),
                      T_AMORTHEDGCORR    = T_AMORTHEDGCORR    + v_CurBuy.T_AMORTHEDGCORR,
                      T_AMORTHEDGCORRDATE= (CASE WHEN Lot.t_AMORTHEDGCORRDATE = UnknownDate AND v_CurBuy.T_AMORTHEDGCORR <> 0 THEN p_SaleLot.t_Date ELSE T_AMORTHEDGCORRDATE END)
                WHERE T_SumID = Lot.t_SumID;
             END LOOP;
            
             IF(   v_WriteOffLot.T_COST>0
                OR v_WriteOffLot.T_BALANCECOST>0
                OR v_WriteOffLot.T_NKDAMOUNT>0
                OR v_WriteOffLot.T_INTERESTINCOME>0
                OR v_WriteOffLot.T_BEGDISCOUNT>0
                OR v_WriteOffLot.T_OLDBEGDISCOUNT>0
                OR v_WriteOffLot.T_DISCOUNTCORR>0
                OR v_WriteOffLot.T_DISCOUNTINCOME>0
                OR v_WriteOffLot.T_RESERVAMOUNT>0
                OR v_WriteOffLot.T_INCOMERESERV>0
                OR v_WriteOffLot.T_OVERAMOUNT<>0
                OR v_WriteOffLot.T_OUTLAY>0
                OR v_WriteOffLot.T_BEGBONUS>0
                OR v_WriteOffLot.T_OLDBEGBONUS>0
                OR v_WriteOffLot.T_BONUS>0
                OR v_WriteOffLot.T_OLDBONUS>0
                OR v_WriteOffLot.T_COSTPFI<>0
                OR v_WriteOffLot.T_BEGDEFDIFF<>0
                OR v_WriteOffLot.T_ACCOUNTEDDEFDIFF<>0
                OR v_WriteOffLot.T_CORRINTTOEIR<>0
                OR v_WriteOffLot.T_CORRVALUE<>0
                OR v_WriteOffLot.T_ESTRESERVE<>0
                OR v_WriteOffLot.T_CORRESTRESERVE<>0
                OR v_WriteOffLot.T_HEDGCORR<>0
                OR v_WriteOffLot.T_AMORTHEDGCORR<>0
               ) THEN
               SetError( WRTOFF_ERROR_20231 ); -- При списании по средневзвешенной остались нераспределенные суммы
             END IF;

             UPDATE DPMWRTSUM_DBT
                SET t_Cost = 0,
                    t_BalanceCost = 0,
                    t_AccBalanceCost = 0,
                    t_NKDAmount = 0,
                    t_InterestIncome = 0,
                    t_BegDiscount = 0,
                    t_OldBegDiscount = 0,
                    T_DISCOUNTCORR = 0,
                    t_DiscountIncome = 0,
                    t_ReservAmount = 0,
                    t_IncomeReserv = 0,
                    t_OverAmount = 0,
                    t_Outlay = 0,
                    t_BegBonus = 0,
                    T_OLDBEGBONUS = 0,
                    t_Bonus = 0,
                    t_OldBonus = 0,
                    T_COSTPFI = 0,
                    T_BEGDEFDIFF = 0,      
                    T_ACCOUNTEDDEFDIFF = 0,
                    T_CORRINTTOEIR = 0,
                    T_CORRVALUE = 0, 
                    T_ESTRESERVE = 0,
                    T_CORRESTRESERVE = 0,
                    T_HEDGCORR = 0,
                    T_AMORTHEDGCORR = 0
              WHERE t_Department = p_SaleLot.t_Department AND
                    t_FIID       = p_SaleLot.t_FIID AND
                    t_Party      = p_SaleLot.t_Party AND
                    (p_Group < 0 OR p_Group IS NULL OR t_GroupID = p_Group) AND
                    ( (p_Portfolio <= 0) OR (p_Portfolio is NULL) OR (p_Portfolio = t_Portfolio) ) AND
                    t_Contract   = p_SaleLot.t_Contract AND
                    t_State      = PM_WRTSUM_FORM AND
                    t_Amount     = 0 AND
                    (t_Cost > 0 OR
                     t_BalanceCost > 0 OR
                     t_NKDAmount > 0 OR
                     t_InterestIncome > 0 OR
                     t_BegDiscount > 0 OR
                     t_OldBegDiscount > 0 OR
                     T_DISCOUNTCORR > 0 OR
                     t_DiscountIncome > 0 OR
                     t_ReservAmount > 0 OR
                     t_IncomeReserv > 0 OR
                     t_OverAmount <> 0 OR
                     t_Outlay > 0 OR
                     t_BegBonus > 0 OR
                     T_OLDBEGBONUS > 0 OR
                     t_Bonus > 0 OR
                     t_OldBonus > 0 OR
                     T_COSTPFI <> 0 OR
                     T_BEGDEFDIFF <> 0 OR
                     T_ACCOUNTEDDEFDIFF <> 0 OR
                     T_CORRINTTOEIR <> 0 OR
                     T_CORRVALUE <> 0 OR 
                     T_ESTRESERVE <> 0 OR
                     T_CORRESTRESERVE <> 0 OR
                     T_HEDGCORR <> 0 OR
                     T_AMORTHEDGCORR <> 0
                    );
          END IF;
       END IF;
    END;

    -- Выполняет откат списания по средневзвешенной по старому алгоритму
    -- Для совместимости со старой реализацией до #165720
    PROCEDURE RSI_WRTRecoilOldRedistrSum( p_ID_Operation IN NUMBER, p_ID_Step IN NUMBER )
    IS
       CURSOR curBC IS (SELECT t_SumID
                          FROM DPMWRTSUM_DBT
                         WHERE     t_ID_Operation = p_ID_Operation
                               AND t_ID_Step      = p_ID_Step
                               AND t_Action       = RSB_PMWRTOFF.PM_WRT_UPDTMODE_AVERAGE_WRTOFF
                    );
    BEGIN
       FOR BC IN curBC LOOP
          RSB_PMWRTOFF.RSI_WRTRestoreLot( p_ID_Operation, p_ID_Step, RSB_PMWRTOFF.PM_WRT_UPDTMODE_AVERAGE_WRTOFF, BC.t_SumID);
       END LOOP;
    END;

    ----------------------------------------------------------------------------------------------------------------------
    ---- Выполняет компенсационную поставку по РЕПО
    ---- Предпологается что все действия выполняются на одном шаге операции поэтому у нас ID платежа неизвестен
    ---- будем считать что на этом шаге может быть вставлен только один платеж с видом PM_PURP_COMPENS_BAi поэтому будем брать
    ---- платеж с максимальным ID и не закрытый
    PROCEDURE RSI_WRTCompensWrt( p_LotS         IN OUT DPMWRTSUM_DBT%ROWTYPE,   -- Вид документа операции
                                 p_ID_Operation IN NUMBER,   -- Операция
                                 p_ID_Step      IN NUMBER,   -- Шаг операции
                                 p_Lot2SumID    IN NUMBER,
                                 p_SaleRepoAmount IN NUMBER DEFAULT 0
                               )
    IS
      v_Lot2        DPMWRTSUM_DBT%ROWTYPE;
      v_SaleID      NUMBER;
      v_RAmount     NUMBER;
      v_Rate        NUMBER;
      v_Val         NUMBER;
      v_FACEVALUEFI NUMBER;
    BEGIN

      ---- Находим лот по второй части
      BEGIN
        SELECT * INTO v_Lot2
          FROM DPMWRTSUM_DBT
         WHERE t_SumID  = p_Lot2SumID;
      EXCEPTION
         WHEN OTHERS THEN
             SetError( WRTOFF_ERROR_20200 );
      END;

      RSI_WRTSaveLot( v_Lot2.t_SumID, p_ID_Operation, p_ID_Step, p_LotS.t_ChangeDate, PM_WRT_UPDTMODE_CDELIVERY );

      ---- Вставляем полученный лот
      INSERT INTO DPMWRTSUM_DBT VALUES p_LotS RETURNING t_SUMID INTO v_SaleID;
      p_LotS.T_SUMID := v_SaleID;

      IF( p_LotS.t_Kind in ( WRTSUM_KIND_RRAS2, WRTSUM_KIND_RRWAS2 ) ) THEN

         UPDATE dpmwrtsum_dbt
            SET t_Amount = t_Amount - p_LotS.t_Amount - p_SaleRepoAmount
          WHERE t_SumID = v_Lot2.T_SumID;

         IF( p_LotS.t_AmountBD > 0 ) THEN
            UPDATE dpmwrtsum_dbt
               SET t_AmountBD      = t_AmountBD - p_LotS.t_AmountBD,
                   t_BalanceCostBD = t_BalanceCostBD - p_LotS.t_BalanceCostBD,
                   t_OverAmountBD  = t_OverAmountBD - p_LotS.t_OverAmountBD
             WHERE t_SumID = v_Lot2.T_SumID;
         END IF;

      ELSE

         v_RAmount := v_Lot2.t_Amount - p_LotS.t_Amount;
         v_Rate    := v_RAmount / v_Lot2.t_Amount;

         IF( v_Lot2.t_Portfolio = KINDPORT_BASICDEBT AND p_LotS.t_ChangeDate < NewRepoDate()) THEN
            UPDATE dpmwrtsum_dbt
               SET t_Amount        = v_RAmount,
                   t_AmountBD      = v_RAmount,
                   t_BalanceCostBD = ROUND( t_BalanceCostBD * v_Rate, 2),
                   t_OverAmountBD  = ROUND( t_OverAmountBD * v_Rate, 2)
             WHERE t_SumID = v_Lot2.T_SumID;
         ELSE

            BEGIN
              SELECT T_FACEVALUEFI INTO v_FACEVALUEFI
                FROM DFININSTR_DBT
               WHERE t_FIID  = v_Lot2.T_FIID;
            EXCEPTION
               WHEN OTHERS THEN null;
            END;

            IF (v_FACEVALUEFI = 0 AND
                (v_Lot2.T_OVERAMOUNT <> 0 OR v_Lot2.T_CORRVALUE <> 0 OR v_Lot2.T_CORRINTTOEIR <> 0 OR v_Lot2.T_HEDGCORR <> 0 OR v_Lot2.T_AMORTHEDGCORR <> 0)) THEN
               v_Val := v_Lot2.T_OVERAMOUNT  + v_Lot2.T_CORRVALUE + v_Lot2.T_CORRINTTOEIR + v_Lot2.T_AMORTHEDGCORR;
            ELSE
               v_Val := v_Lot2.T_BALANCECOST - v_Lot2.T_COST - v_Lot2.T_NKDAMOUNT - v_Lot2.T_INTERESTINCOME - v_Lot2.T_DISCOUNTINCOME - v_Lot2.T_COSTPFI;
            END IF;

            UPDATE dpmwrtsum_dbt
               SET t_Amount             = v_RAmount,
                   t_Sum                = ROUND( t_Sum * v_Rate, 2),
                   t_NKDAmount          = ROUND( t_NKDAmount * v_Rate, 2),
                   t_Cost               = ROUND( t_Cost * v_Rate, 2),
                   t_BalanceCost        = ROUND( t_Cost * v_Rate, 2)
                                        + ROUND( t_NKDAmount * v_Rate, 2)
                                        + ROUND( T_INTERESTINCOME * v_Rate, 2)
                                        + ROUND( T_DISCOUNTINCOME * v_Rate, 2)
                                        + ROUND( v_Val * v_Rate, 2)
                                        + ROUND( T_COSTPFI * v_Rate, 2),
                   T_INTERESTINCOME     = ROUND( T_INTERESTINCOME * v_Rate, 2),
                   T_NOTCARRYINTEREST   = ROUND( T_NOTCARRYINTEREST * v_Rate, 2),
                   T_BEGDISCOUNT        = ROUND( T_BEGDISCOUNT * v_Rate, 2),
                   T_BEGBONUS           = ROUND( T_BEGBONUS * v_Rate, 2),
                   T_DISCOUNTINCOME     = ROUND( T_DISCOUNTINCOME * v_Rate, 2),
                   T_NOTCARRYDISCOUNT   = ROUND( T_NOTCARRYDISCOUNT * v_Rate, 2),
                   T_BONUS              = ROUND( T_BONUS * v_Rate, 2),
                   T_OLDBONUS           = ROUND( T_OLDBONUS * v_Rate, 2),
                   T_OUTLAY             = ROUND( T_OUTLAY * v_Rate, 2),
                   T_RESERVAMOUNT       = ROUND( T_RESERVAMOUNT * v_Rate, 2),
                   T_OVERAMOUNT         = ROUND( T_OVERAMOUNT * v_Rate, 2),
                   T_INCOMERESERV       = ROUND( T_INCOMERESERV * v_Rate, 2),
                   t_DISCOUNTCORR       = ROUND( t_DISCOUNTCORR * v_Rate, 2),
                   t_OLDBEGDISCOUNT     = ROUND( t_OLDBEGDISCOUNT * v_Rate, 2),
                   t_OLDBEGBONUS        = ROUND( t_OLDBEGBONUS * v_Rate, 2),
                   T_NOTWRTBONUS        = ROUND( T_NOTWRTBONUS * v_Rate, 2),
                   T_COSTPFI            = ROUND( T_COSTPFI * v_Rate, 2),
                   T_BLOCKAMOUNT        = LEAST( v_RAmount, T_BLOCKAMOUNT),
                   T_BEGDEFDIFF         = ROUND(T_BEGDEFDIFF * v_Rate, 2),
                   T_ACCOUNTEDDEFDIFF   = ROUND(T_ACCOUNTEDDEFDIFF * v_Rate, 2),
                   T_WRTOUTLAY          = ROUND(T_WRTOUTLAY * v_Rate, 2),
                   T_VATOUTLAY          = ROUND(T_VATOUTLAY * v_Rate, 2),
                   T_WRTVATOUTLAY       = ROUND(T_WRTVATOUTLAY * v_Rate, 2),
                   T_FAIRVALUE          = ROUND(T_FAIRVALUE * v_Rate, 2),
                   T_AMORTCOST          = ROUND(T_AMORTCOST * v_Rate, 2),
                   T_CORRVALUE          = ROUND(T_CORRVALUE * v_Rate, 2),
                   T_ACCFI              = WRTDetermineAccFI(T_FIID),
                   T_ESTRESERVE         = ROUND(T_ESTRESERVE * v_Rate, 2),
                   T_CORRINTTOEIR       = ROUND(T_CORRINTTOEIR * v_Rate, 2),
                   T_CORRESTRESERVE     = ROUND(T_CORRESTRESERVE * v_Rate, 2),
                   T_HEDGCORR           = ROUND(T_HEDGCORR * v_Rate, 2),
                   T_AMORTHEDGCORR      = ROUND(T_AMORTHEDGCORR * v_Rate, 2)
             WHERE t_SumID = v_Lot2.T_SumID;

            UPDATE dpmwrtsum_dbt
               SET t_AccBalanceCost   = NVL(ROUND(RSI_RSB_FIInstr.ConvSum( T_BALANCECOST, v_FaceValueFI, T_ACCFI, T_DATE, 1 ),2),0)
             WHERE t_SumID = v_Lot2.T_SumID
               AND T_ACCFI != -1;
         END IF;
      END IF;
    END;

   -- Возвращает сумму коррекции дисконта в локальном перемещении (ДДкор)
   FUNCTION WRTGetDiscountCorrection( ID_Operation IN NUMBER, -- Операция и шаг, на которых выполнялось изменение
                                      ID_Step IN NUMBER,
                                      pAction IN NUMBER -- Вид изменения
                                    ) RETURN NUMBER DETERMINISTIC
   IS
      v_Sum NUMBER := 0;
   BEGIN
      SELECT NVL( SUM(T_DISCOUNTCORR), 0 )
        INTO v_Sum
        FROM V_SCWRTHISTEX
       WHERE     t_ID_Operation = ID_Operation
             AND (CASE WHEN (ID_Step is null) OR (ID_Step <= 0) THEN t_ID_Step ELSE ID_Step END) = t_ID_Step
             AND t_Action       = pAction
             AND T_BUY_SALE     = PM_WRITEOFF_SUM_BUY;

      return v_Sum;
   END;



   -----------------------------------------------------------------------
   PROCEDURE SetCostToHist (pSumID IN NUMBER, pInstance IN NUMBER, pCost IN NUMBER, pBalanceCost IN NUMBER, pAmount IN NUMBER)
   IS
      v_Instance       NUMBER :=  pInstance;
      v_Cost           NUMBER :=  pCost;
      v_BalanceCost    NUMBER :=  pBalanceCost;
      v_Amount         NUMBER :=  pAmount;
      HC               V_SCWRTHISTEX%ROWTYPE;
      v_ErrorStr       VARCHAR2(1024) := '';

   BEGIN
      WHILE 1>0 LOOP
         BEGIN
            SELECT *
              INTO HC
              FROM V_SCWRTHISTEX
             WHERE     T_SUMID    = pSumID
                   AND T_INSTANCE = v_Instance;
         EXCEPTION
            WHEN NO_DATA_FOUND THEN return;
         END;

         IF( HC.T_ACTION IN ( RSB_PMWRTOFF.PM_WRT_UPDTMODE_DISCARD,
                              RSB_PMWRTOFF.PM_WRT_UPDTMODE_DISCARDBD,
                              RSB_PMWRTOFF.PM_WRT_UPDTMODE_RETISSUE,
                              RSB_PMWRTOFF.PM_WRT_UPDTMODE_PORTFOLIO,
                              RSB_PMWRTOFF.PM_WRT_UPDTMODE_GLOBALCONV
                            )
           ) then
            RSI_SetCostToLink( pSumID, HC.T_AMOUNT, HC.T_PORTFOLIO, HC.T_ID_OPERATION, HC.T_ID_STEP, HC.T_ACTION,
                           v_Cost, v_BalanceCost );

         elsif( (HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_CDELIVERY2) or
                (HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_CDELIVERY and v_Amount <> HC.T_AMOUNT)
              ) then
            return; -- обновится в свою очередь

         ELSIF( HC.T_ACTION IN ( RSB_PMWRTOFF.PM_WRT_UPDTMODE_COUPON,
                                 RSB_PMWRTOFF.PM_WRT_UPDTMODE_PARTIAL,
                                 RSB_PMWRTOFF.PM_WRT_UPDTMODE_OVERVALUE,
                                 RSB_PMWRTOFF.PM_WRT_UPDTMODE_INCPDD, 441, 442, -- начисление ПД, ДД
                                 RSB_PMWRTOFF.PM_WRT_UPDTMODE_RESERV
                               )
              ) then

            -- Выдать сообщение "По лоту выполнена операция "<HC.T_ACTION>". Стоимостные параметры могут быть рассчитаны некорректно"
            v_ErrorStr := 'По лоту выполнена операция "';

            IF( HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_COUPON ) THEN
               v_ErrorStr := v_ErrorStr||'Учет купона';

            ELSIF( HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_PARTIAL ) THEN
               v_ErrorStr := v_ErrorStr||'Учет ЧП';

            ELSIF( HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_OVERVALUE ) THEN
               v_ErrorStr := v_ErrorStr||'Переоценка';

            ELSIF( HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_INCPDD ) THEN
               v_ErrorStr := v_ErrorStr||'Начисление ПДД';

            ELSIF( HC.T_ACTION = 441 ) THEN
               v_ErrorStr := v_ErrorStr||'Начисление ПД';

            ELSIF( HC.T_ACTION = 442 ) THEN
               v_ErrorStr := v_ErrorStr||'Начисление ДД';

            ELSIF( HC.T_ACTION = RSB_PMWRTOFF.PM_WRT_UPDTMODE_RESERV ) THEN
               v_ErrorStr := v_ErrorStr||'Резервирование';

            END IF;

            v_ErrorStr := v_ErrorStr||'". Стоимостные параметры могут быть рассчитаны некорректно';

            INSERT INTO DSCTXMES_DBT ErrLog
               (
                  ErrLog.T_LotID,
                  ErrLog.T_FIID,
                  ErrLog.T_TYPE,
                  ErrLog.T_MESSAGE,
                  ErrLog.T_MESDATE
               )
               VALUES
               (
                  HC.T_SUMID, -1, 100, v_ErrorStr, null
               );

            IF( HC.T_ACTION <> RSB_PMWRTOFF.PM_WRT_UPDTMODE_RESERV) then --резервирование может и получиться
               return;
            END IF;

         end if;

         IF( pCost <> -1 ) THEN
            IF( HC.T_BCID > 0 ) THEN
               UPDATE DPMWRTBC_DBT
                  SET T_COST     = v_Cost
                WHERE T_BCID = HC.T_BCID;
            ELSE
               UPDATE DPMWRTSUM_DBT
                  SET T_COST     = v_Cost
                WHERE t_SumID = HC.t_SumID;
            END IF;
         END IF;

         IF( pBalanceCost <> -1 ) THEN
            IF( HC.T_BCID > 0 ) THEN
               UPDATE DPMWRTBC_DBT
                  SET T_BALANCECOST = v_BalanceCost
                WHERE T_BCID = HC.T_BCID;
            ELSE
               UPDATE DPMWRTSUM_DBT
                  SET T_BALANCECOST = v_BalanceCost
                WHERE t_SumID = HC.t_SumID;
            END IF;
         END IF;

         v_Amount := HC.t_Amount;
         v_Instance := v_Instance + 1;
      END LOOP;
   END; -- SetCostToHist

   PROCEDURE RSI_SetCostToLink( pBuyID IN NUMBER, pAmount IN NUMBER, pPortfolio IN NUMBER, pID_Operation IN NUMBER,
                            pID_Step IN NUMBER, pAction IN NUMBER,
                            pCost IN OUT NUMBER, pBalanceCost IN OUT NUMBER)
   IS
      Lnk                 DPMWRTLNK_DBT%ROWTYPE;
      v_CurCost           NUMBER;
      v_CurBalanceCost    NUMBER;
      SaleKind            NUMBER;
   BEGIN

      BEGIN
         SELECT *
           INTO Lnk  -- если найдется не одна, то где-то накосячили
           FROM DPMWRTLNK_DBT
          WHERE     T_BUYID = pBuyID
                AND T_ID_OPERATION = pID_Operation
                AND T_ID_STEP = pID_Step
                AND T_ACTION  = pAction;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN return;
      END;

      IF( pAmount = 0 ) THEN
         IF (pCost <> -1) THEN
            v_CurCost    := pCost;
            pCost        := 0;
         END IF;

         IF (pBalanceCost <> -1) THEN
            v_CurBalanceCost    := pBalanceCost;
            pBalanceCost        := 0;
         END IF;
      ELSE
         IF (pCost <> -1) THEN
            v_CurCost    := round(pCost* Lnk.T_AMOUNT / (pAmount + Lnk.T_AMOUNT),2);
            pCost        := pCost - v_CurCost;
         END IF;

         IF (pBalanceCost <> -1) THEN
            v_CurBalanceCost    := round(pBalanceCost* Lnk.T_AMOUNT / (pAmount + Lnk.T_AMOUNT),2);
            pBalanceCost        := pBalanceCost - v_CurBalanceCost;
         END IF;

      END IF;

      IF (pCost <> -1) THEN
         UPDATE DPMWRTLNK_DBT
            SET T_COSTBUY    = v_CurCost
          WHERE t_LnkID = Lnk.t_LnkID;
      END IF;

      IF (pBalanceCost <> -1) THEN
         UPDATE DPMWRTLNK_DBT
            SET T_BALANCECOSTBUY    = v_CurBalanceCost
          WHERE t_LnkID = Lnk.t_LnkID;
      END IF;

      SELECT T_KIND
        INTO SaleKind
        FROM DPMWRTSUM_DBT
       WHERE t_SumID = Lnk.T_SALEID;

      IF( (    pAction  = RSB_PMWRTOFF.PM_WRT_UPDTMODE_DISCARD
           AND SaleKind = RSB_PMWRTOFF.WRTSUM_KIND_RRWAS1
           AND pPortfolio IN ( RSB_PMWRTOFF.KINDPORT_TRADE, RSB_PMWRTOFF.KINDPORT_SALE)
          ) OR
          (    pAction  = RSB_PMWRTOFF.PM_WRT_UPDTMODE_PORTFOLIO
           AND SaleKind = RSB_PMWRTOFF.WRTSUM_KIND_MS
          ) OR
          (    pAction  = RSB_PMWRTOFF.PM_WRT_UPDTMODE_GLOBALCONV
          )
        ) THEN
        RSI_SetCostToMovedLot( pBuyID, Lnk.T_SALEID, pAction,
                           pPortfolio, v_CurCost, v_CurBalanceCost, Lnk.T_OVERCHANGE
                         );
      END IF;
   END; --RSI_SetCostToLink

   PROCEDURE RSI_SetCostToMovedLot( pBuyID IN NUMBER, pSaleID IN NUMBER, pAction IN NUMBER, pPortfolio IN NUMBER,
                                pCost IN NUMBER, pBalanceCost IN NUMBER, pOver IN NUMBER )
   IS
      L_FIID   NUMBER;
      L_SumID  NUMBER;
      L_Date  DATE;
      L_PORTFOLIO NUMBER;
      L_Amount NUMBER;
      v_FaceValueFI NUMBER;
      v_I      NUMBER;
      v_Cost   NUMBER;
   BEGIN
      BEGIN
         SELECT L2.t_FIID, L2.t_SumID, L2.t_Date, L2.t_Amount, L2.t_PORTFOLIO, fin.t_FaceValueFI
           INTO L_FIID, L_SumID, L_Date, L_Amount, L_PORTFOLIO, v_FaceValueFI
           FROM DPMWRTSUM_DBT L2, DFININSTR_DBT fin
          WHERE     L2.T_SOURCE = pBuyID
                AND L2.T_PARENT = pSaleID
                AND L2.t_FIID = fin.t_FIID;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN return;
      END;

      IF( pAction  = RSB_PMWRTOFF.PM_WRT_UPDTMODE_PORTFOLIO and
          L_PORTFOLIO = RSB_PMWRTOFF.KINDPORT_RETIRE and
          pPortfolio = RSB_PMWRTOFF.KINDPORT_SALE
        ) THEN
         IF (v_FaceValueFI <> 0) THEN
            v_Cost := pCost + RSI_RSB_FIInstr.ConvSum( pOver, 0, v_FaceValueFI, L_Date, 1 );
         ELSE
            v_Cost := pCost + pOver;
         END IF;
      ELSE
         v_Cost := pCost;
      END IF;

      SELECT min(B.T_INSTANCE)
        INTO v_I
        FROM V_SCWRTHIST B
       WHERE B.T_SUMID = L_SUMID;

      SetCostToHist( L_SUMID, v_I, v_Cost, pBalanceCost, L_Amount );
   END;

   -------------------------------------------------------------------------------
   --- ХП-шки для работы с временной таблицей SCDLFI
   -------------------------------------------------------------------------------

   PROCEDURE RSI_SCDLFISync( pDealKind IN NUMBER, pDealID IN NUMBER, pMode IN NUMBER)
   IS
     v_Count NUMBER;

     -- для вставки
     CURSOR scdlfi_cur IS
     SELECT * FROM dscdlfi_tmp
      WHERE ((t_Action = SCDL_INSERT) OR (t_Action = SCDL_UPDATE AND t_ID_from = 0))
        AND T_DEALKIND = pDealKind
        AND ((T_DEALID = pDealID) OR (T_DEALID = 0 AND pMode = 1));
   BEGIN

     IF (pMode = 1) THEN --вставка, конкурентных изменений не будет
        v_Count := 0;
     ELSE
        --Кол-во записей, которые были конкурентно изменены в реальной базе
        SELECT Count(1) INTO v_Count
          FROM dscdlfi_dbt real, dscdlfi_tmp tmp
         WHERE real.t_ID = tmp.t_ID_from
           AND tmp.T_DEALKIND_FROM = pDealKind
           AND tmp.T_DEALID_FROM   = pDealID
           AND (   real.T_NUM         != tmp.T_NUM_FROM
                OR real.T_NEWFIID     != tmp.T_NEWFIID_FROM
                OR real.T_NUMERATOR   != tmp.T_NUMERATOR_FROM
                OR real.T_DENOMINATOR != tmp.T_DENOMINATOR_FROM
               );
     END IF;

     --если конкурентных изменений нет, то обрабатываем записи в реальной базе
     IF v_Count = 0 THEN
        --1.Удаление
        DELETE FROM dscdlfi_dbt scdlfi
         WHERE  scdlfi.t_ID IN ( SELECT DISTINCT tmpscdlfi.t_ID_from
                                           FROM dscdlfi_tmp tmpscdlfi
                                          WHERE tmpscdlfi.t_Action = SCDL_DELETE
                                            AND tmpscdlfi.T_DEALKIND_FROM = pDealKind
                                            AND tmpscdlfi.T_DEALID_FROM   = pDealID );

        --2.Обновление
        UPDATE dscdlfi_dbt realscdlfi
           SET ( realscdlfi.T_DEALKIND   ,
                 realscdlfi.T_DEALID     ,
                 realscdlfi.T_NUM        ,
                 realscdlfi.T_NEWFIID    ,
                 realscdlfi.T_NUMERATOR  ,
                 realscdlfi.T_DENOMINATOR, 
                 realscdlfi.t_sumprecision) =
               ( SELECT tmpscdlfi.T_DEALKIND   ,
                        tmpscdlfi.T_DEALID     ,
                        tmpscdlfi.T_NUM        ,
                        tmpscdlfi.T_NEWFIID    ,
                        tmpscdlfi.T_NUMERATOR  ,
                        tmpscdlfi.T_DENOMINATOR,
                        tmpscdlfi.t_sumprecision
                   FROM dscdlfi_tmp tmpscdlfi
                  WHERE tmpscdlfi.t_ID_from       = realscdlfi.t_ID
                    AND tmpscdlfi.T_DEALKIND_FROM = pDealKind
                    AND tmpscdlfi.T_DEALID_FROM   = pDealID
                    AND tmpscdlfi.t_Action        = SCDL_UPDATE
               )
         WHERE realscdlfi.t_ID
            IN ( SELECT tmps.t_ID_from
                   FROM dscdlfi_tmp tmps
                  WHERE tmps.t_Action        = SCDL_UPDATE
                    AND tmps.T_DEALKIND_FROM = pDealKind
                    AND tmps.T_DEALID_FROM   = pDealID);

        --3.Вставка
        FOR tmpscdlfi IN scdlfi_cur LOOP
          INSERT INTO dscdlfi_dbt realscdlfi
                ( realscdlfi.T_DEALKIND   ,
                  realscdlfi.T_DEALID     ,
                  realscdlfi.T_NUM        ,
                  realscdlfi.T_NEWFIID    ,
                  realscdlfi.T_NUMERATOR  ,
                  realscdlfi.T_DENOMINATOR ,
                  realscdlfi.t_sumprecision )
           VALUES( tmpscdlfi.T_DEALKIND   ,
                   pDealID                ,
                   tmpscdlfi.T_NUM        ,
                   tmpscdlfi.T_NEWFIID    ,
                   tmpscdlfi.T_NUMERATOR  ,
                   tmpscdlfi.T_DENOMINATOR ,
                   tmpscdlfi.t_sumprecision
                   );
        END LOOP;

       -- чистим временную таблицу
        DELETE FROM dscdlfi_tmp scdlfitmp
         WHERE scdlfitmp.T_DEALKIND = pDealKind
           AND ((scdlfitmp.T_DEALID = pDealID) OR (scdlfitmp.T_DEALID = 0 AND pMode = 1));

     END IF;

   END RSI_SCDLFISync;

   FUNCTION ExistSCDLFI( pDealKind IN NUMBER, pDealID IN NUMBER, pNum IN NUMBER, pNewFIID IN NUMBER) RETURN NUMBER DETERMINISTIC
   IS
     v_Count NUMBER := 0;

   BEGIN

     SELECT Count(1) INTO v_Count
       FROM dscdlfi_tmp tmp
      WHERE tmp.T_DEALKIND = pDealKind
        AND tmp.T_DEALID   = pDealID
        AND (tmp.T_NUM     = pNum OR pNum = 0)
        AND (tmp.T_NEWFIID = pNewFIID OR pNewFIID = 0)
        AND tmp.t_Action  != SCDL_DELETE;

     IF v_Count = 0 THEN
        RETURN 0; -- нет
     ELSE
        RETURN 1; -- есть
     END IF;

   END ExistSCDLFI;

   PROCEDURE RSI_MarkForDeleteSCDLFI( pDealKind IN NUMBER, pDealID IN NUMBER)
   IS

   BEGIN

     UPDATE dscdlfi_tmp tmp
        SET tmp.t_Action = SCDL_DELETE
      WHERE tmp.T_DEALKIND = pDealKind
        AND tmp.T_DEALID   = pDealID;

   END RSI_MarkForDeleteSCDLFI;


   -------------------------------------------------------------------------------
   --- то же, для SCDLPMWR
   -------------------------------------------------------------------------------
   PROCEDURE RSI_SCDLPMWRSync( pDealKind IN NUMBER, pDealID IN NUMBER, pMode IN NUMBER)
   IS
     v_Count NUMBER;
     v_SumPrecision NUMBER :=6;

     -- для вставки
     CURSOR scdlpmwr_cur IS
     SELECT * FROM dscdlpmwr_tmp
      WHERE ((t_Action = SCDL_INSERT) OR (t_Action = SCDL_UPDATE AND t_DEALKIND_from = 0))
        AND T_DEALKIND = pDealKind
        AND ((T_DEALID = pDealID) OR (T_DEALID = 0 AND pMode = 1));

     -- для удаления
     CURSOR cscdlpmwr_del IS
         SELECT tmpscdlpmwr.T_SUMID_FROM, tmpscdlpmwr.T_NEWFIID_FROM, tmpscdlpmwr.T_KIND_FROM
           FROM dscdlpmwr_tmp tmpscdlpmwr
          WHERE tmpscdlpmwr.t_Action = SCDL_DELETE
            AND tmpscdlpmwr.T_DEALKIND_FROM = pDealKind
            AND tmpscdlpmwr.T_DEALID_FROM   = pDealID
          GROUP BY tmpscdlpmwr.T_SUMID_FROM, tmpscdlpmwr.T_NEWFIID_FROM, tmpscdlpmwr.T_KIND_FROM;

     -- для обновления
     CURSOR cscdlpmwr_upd IS
         SELECT tmpscdlpmwr.T_SUMID_FROM, tmpscdlpmwr.T_NEWFIID_FROM, tmpscdlpmwr.T_KIND_FROM
           FROM dscdlpmwr_tmp tmpscdlpmwr
          WHERE tmpscdlpmwr.t_Action = SCDL_UPDATE
            AND tmpscdlpmwr.T_DEALKIND_FROM = pDealKind
            AND tmpscdlpmwr.T_DEALID_FROM   = pDealID
          GROUP BY tmpscdlpmwr.T_SUMID_FROM, tmpscdlpmwr.T_NEWFIID_FROM, tmpscdlpmwr.T_KIND_FROM;

     x_UseSumPrecision NUMBER := 0; -- рубильник (BOSS-1232)


   BEGIN

     -- рубильник BOSS-1232
     GetPrecisionRegValue(x_UseSumPrecision);
     /*
       Note: в RSI_SCDLFISync не округляем, делаем это здесь 
     */
     --GetSumPrecisionByDLCOMM(pDealKind, pDealID, null, v_SumPrecision);


     IF (pMode = 1) THEN --вставка, конкурентных изменений не будет
        v_Count := 0;
     ELSE
        --Кол-во записей, которые были конкурентно изменены в реальной базе
        SELECT Count(1) INTO v_Count
          FROM dscdlpmwr_dbt real, dscdlpmwr_tmp tmp
         WHERE real.t_SUMID = tmp.t_SUMID_from
           AND real.t_NEWFIID = tmp.t_NEWFIID_from
           AND real.t_Kind = tmp.t_Kind
           AND tmp.T_DEALKIND_FROM = pDealKind
           AND tmp.T_DEALID_FROM   = pDealID
           AND real.T_DEALKIND = tmp.T_DEALKIND_FROM
           AND real.T_DEALID   = tmp.T_DEALID_FROM  
           AND (   real.T_OLDAMOUNT         != tmp.T_OLDAMOUNT_FROM
                OR real.T_CALCAMOUNT        != tmp.T_CALCAMOUNT_FROM
                OR real.T_NEWAMOUNT         != tmp.T_NEWAMOUNT_FROM
                OR real.T_STATE             != tmp.T_STATE_FROM
                OR real.T_PARTY             != tmp.T_PARTY_FROM
                OR real.T_DATE              != tmp.T_DATE_FROM
                OR real.T_SUMFIIDAMOUNT     != tmp.T_SUMFIIDAMOUNT_FROM
                OR real.T_SUMNEWAMOUNT      != tmp.T_SUMNEWAMOUNT_FROM
                OR real.T_OLDCOST           != tmp.T_OLDCOST_FROM
                OR real.T_SUMFIIDCOST       != tmp.T_SUMFIIDCOST_FROM
                OR real.T_SUMNEWCOST        != tmp.T_SUMNEWCOST_FROM
                OR real.T_CALCCOST          != tmp.T_CALCCOST_FROM
                OR real.T_NEWCOST           != tmp.T_NEWCOST_FROM
                OR real.T_INTERESTINCOMEADD != tmp.T_INTERESTINCOMEADD_FROM
                OR real.T_DISCOUNTINCOMEADD != tmp.T_DISCOUNTINCOMEADD_FROM
                OR real.T_OLDINSTANCE       != tmp.T_OLDINSTANCE_FROM
               );

     END IF;

     --если конкурентных изменений нет, то обрабатываем записи в реальной базе
     IF v_Count = 0 THEN
        --1.Удаление
        FOR scdlpmwr_del IN cscdlpmwr_del LOOP

           DELETE FROM dscdlpmwr_dbt scdlpmwr
            WHERE scdlpmwr.T_DEALKIND = pDealKind
              AND scdlpmwr.T_DEALID   = pDealID
              AND scdlpmwr.T_SUMID    = scdlpmwr_del.T_SUMID_FROM
              AND scdlpmwr.T_NEWFIID  = scdlpmwr_del.T_NEWFIID_FROM
              AND scdlpmwr.T_Kind     = scdlpmwr_del.T_KIND_FROM;
        END LOOP;

        --2.Обновление
        FOR scdlpmwr_upd IN cscdlpmwr_upd LOOP
           GetSumPrecisionByNewFiid(scdlpmwr_upd.t_newfiid_from, pDealKind, pDealID, v_SumPrecision);
           UPDATE dscdlpmwr_dbt realscdlpmwr
              SET ( realscdlpmwr.T_OLDAMOUNT        ,
                    realscdlpmwr.T_CALCAMOUNT       ,
                    realscdlpmwr.T_NEWAMOUNT        ,
                    realscdlpmwr.T_STATE            ,
                    realscdlpmwr.T_PARTY            ,
                    realscdlpmwr.T_DATE             ,
                    realscdlpmwr.T_SUMFIIDAMOUNT    ,
                    realscdlpmwr.T_SUMNEWAMOUNT     ,
                    realscdlpmwr.T_OLDCOST          ,
                    realscdlpmwr.T_SUMFIIDCOST      ,
                    realscdlpmwr.T_SUMNEWCOST       ,
                    realscdlpmwr.T_CALCCOST         ,
                    realscdlpmwr.T_NEWCOST          ,
                    realscdlpmwr.T_INTERESTINCOMEADD,
                    realscdlpmwr.T_DISCOUNTINCOMEADD,
                    realscdlpmwr.T_OLDINSTANCE
                  ) =
                  ( SELECT tmpscdlpmwr.T_OLDAMOUNT        ,
                           tmpscdlpmwr.T_CALCAMOUNT       ,
                           case when x_UseSumPrecision = 1 
                            then round(tmpscdlpmwr.T_NEWAMOUNT, v_SumPrecision)
                            else  tmpscdlpmwr.T_NEWAMOUNT end ,
                           tmpscdlpmwr.T_STATE            ,
                           tmpscdlpmwr.T_PARTY            ,
                           tmpscdlpmwr.T_DATE             ,
                           tmpscdlpmwr.T_SUMFIIDAMOUNT    ,
                           tmpscdlpmwr.T_SUMNEWAMOUNT     ,
                           tmpscdlpmwr.T_OLDCOST          ,
                           tmpscdlpmwr.T_SUMFIIDCOST      ,
                           tmpscdlpmwr.T_SUMNEWCOST       ,
                           tmpscdlpmwr.T_CALCCOST         ,
                           tmpscdlpmwr.T_NEWCOST          ,
                           tmpscdlpmwr.T_INTERESTINCOMEADD,
                           tmpscdlpmwr.T_DISCOUNTINCOMEADD,
                           tmpscdlpmwr.T_OLDINSTANCE
                      FROM dscdlpmwr_tmp tmpscdlpmwr
                     WHERE tmpscdlpmwr.T_DEALKIND_FROM = pDealKind
                       AND tmpscdlpmwr.T_DEALID_FROM   = pDealID
                       AND tmpscdlpmwr.T_SUMID_FROM    = realscdlpmwr.t_SUMID
                       AND tmpscdlpmwr.T_NEWFIID_FROM  = realscdlpmwr.t_NEWFIID
                       AND tmpscdlpmwr.t_Action        = SCDL_UPDATE
                  )
            WHERE realscdlpmwr.T_DEALKIND = pDealKind
              AND realscdlpmwr.T_DEALID   = pDealID
              AND realscdlpmwr.T_SUMID    = scdlpmwr_upd.T_SUMID_FROM
              AND realscdlpmwr.T_NEWFIID  = scdlpmwr_upd.T_NEWFIID_FROM
              AND realscdlpmwr.T_Kind     = scdlpmwr_upd.T_KIND_FROM;
        END LOOP;

        --3.Вставка
        FOR tmpscdlpmwr IN scdlpmwr_cur LOOP
           GetSumPrecisionByNewFiid(tmpscdlpmwr.T_NEWFIID, pDealKind, pDealID, v_SumPrecision);
          INSERT INTO dscdlpmwr_dbt realscdlpmwr
                ( realscdlpmwr.T_DEALKIND         ,
                  realscdlpmwr.T_DEALID           ,
                  realscdlpmwr.T_SUMID            ,
                  realscdlpmwr.T_OLDAMOUNT        ,
                  realscdlpmwr.T_CALCAMOUNT       ,
                  realscdlpmwr.T_NEWAMOUNT        ,
                  realscdlpmwr.T_STATE            ,
                  realscdlpmwr.T_PARTY            ,
                  realscdlpmwr.T_DATE             ,
                  realscdlpmwr.T_NEWFIID          ,
                  realscdlpmwr.T_SUMFIIDAMOUNT    ,
                  realscdlpmwr.T_SUMNEWAMOUNT     ,
                  realscdlpmwr.T_OLDCOST          ,
                  realscdlpmwr.T_SUMFIIDCOST      ,
                  realscdlpmwr.T_SUMNEWCOST       ,
                  realscdlpmwr.T_CALCCOST         ,
                  realscdlpmwr.T_NEWCOST          ,
                  realscdlpmwr.T_INTERESTINCOMEADD,
                  realscdlpmwr.T_DISCOUNTINCOMEADD,
                  realscdlpmwr.T_OLDINSTANCE      ,
                  realscdlpmwr.T_KIND
                )
           VALUES( tmpscdlpmwr.T_DEALKIND         ,
                   pDealID                        ,
                   tmpscdlpmwr.T_SUMID            ,
                   tmpscdlpmwr.T_OLDAMOUNT        ,
                   tmpscdlpmwr.T_CALCAMOUNT       ,
                   case when x_UseSumPrecision = 1 
                     then round(tmpscdlpmwr.T_NEWAMOUNT, v_SumPrecision)
                     else tmpscdlpmwr.T_NEWAMOUNT end
                   ,
                   tmpscdlpmwr.T_STATE            ,
                   tmpscdlpmwr.T_PARTY            ,
                   tmpscdlpmwr.T_DATE             ,
                   tmpscdlpmwr.T_NEWFIID          ,
                   tmpscdlpmwr.T_SUMFIIDAMOUNT    ,
                   tmpscdlpmwr.T_SUMNEWAMOUNT     ,
                   tmpscdlpmwr.T_OLDCOST          ,
                   tmpscdlpmwr.T_SUMFIIDCOST      ,
                   tmpscdlpmwr.T_SUMNEWCOST       ,
                   tmpscdlpmwr.T_CALCCOST         ,
                   tmpscdlpmwr.T_NEWCOST          ,
                   tmpscdlpmwr.T_INTERESTINCOMEADD,
                   tmpscdlpmwr.T_DISCOUNTINCOMEADD,
                   tmpscdlpmwr.T_OLDINSTANCE      ,
                   tmpscdlpmwr.T_KIND
                 );
        END LOOP;

       -- чистим временную таблицу
        DELETE FROM dscdlpmwr_tmp scdlpmwrtmp
         WHERE scdlpmwrtmp.T_DEALKIND = pDealKind
           AND ((scdlpmwrtmp.T_DEALID = pDealID) OR (scdlpmwrtmp.T_DEALID = 0 AND pMode = 1));

     END IF;

   END RSI_SCDLPMWRSync;

   PROCEDURE RSI_MarkForDeleteSCDLPMWR( pDealKind IN NUMBER, pDealID IN NUMBER)
   IS
     v_Count        NUMBER := 0;

     CURSOR scdlpmwr_cur IS
     SELECT * FROM dscdlpmwr_tmp
      WHERE T_DEALKIND = pDealKind
        AND T_DEALID = pDealID;

   BEGIN
     -- Те которых нет в постоянной таблице - удаляем из временной таблицы. Прочие маркируем к удалению.
--     FOR pmwr IN scdlpmwr_cur LOOP
--
--       SELECT COUNT(1) INTO v_Count
--         FROM dscdlpmwr_dbt scdlpmwr
--        WHERE scdlpmwr.T_DEALKIND = pmwr.T_DEALKIND_FROM
--          AND scdlpmwr.T_DEALID   = pmwr.T_DEALID_FROM
--          AND scdlpmwr.T_SUMID    = pmwr.T_SUMID_FROM
--          AND scdlpmwr.T_NEWFIID  = pmwr.T_NEWFIID_FROM;
--
--       -- нашли в постоянной БД - маркируем к удалению
--       IF v_Count > 0 THEN
--          UPDATE dscdlpmwr_tmp tmp
--             SET tmp.t_Action = SCDL_DELETE
--           WHERE tmp.T_DEALKIND = pmwr.T_DEALKIND_FROM
--             AND tmp.T_DEALID   = pmwr.T_DEALID_FROM
--             AND tmp.T_SUMID    = pmwr.T_SUMID_FROM
--             AND tmp.T_NEWFIID  = pmwr.T_NEWFIID_FROM;
--       ELSE
--          DELETE FROM dscdlpmwr_tmp tmp
--           WHERE tmp.T_DEALKIND = pmwr.T_DEALKIND
--             AND tmp.T_DEALID   = pmwr.T_DEALID
--             AND tmp.T_SUMID    = pmwr.T_SUMID
--             AND tmp.T_NEWFIID  = pmwr.T_NEWFIID;
--       END IF;
--
--     END LOOP;

     UPDATE dscdlpmwr_tmp tmp
        SET tmp.t_Action = SCDL_DELETE
      WHERE tmp.T_DEALKIND = pDealKind
        AND tmp.T_DEALID   = pDealID;

   END RSI_MarkForDeleteSCDLPMWR;

   PROCEDURE RSI_FillScdlpmwrByDlcomm( pDealKind IN NUMBER, pDealID IN NUMBER, pFIID IN NUMBER,
                                       pCommDate IN DATE, pBegDate IN DATE, pEndDate IN DATE,
                                       pFlag3 IN NUMBER, pDepartment IN NUMBER, pError OUT NUMBER, pOperSubKind IN NUMBER)
   IS
      v_Count        NUMBER := 0;
      N              NUMBER := 0;
      KC             NUMBER := 0;
      v_scdlfi       DSCDLFI_TMP%ROWTYPE;
      pNewAmount     NUMBER := 0;
      v_CalcDiscount NUMBER := 0;
      v_CalcInterest NUMBER := 0;
      v_InterestIncomeAdd NUMBER := 0;
      v_DiscountIncomeAdd NUMBER := 0;
      v_OldCost      NUMBER := 0;
      v_CalcCost     NUMBER := 0;
      SSold          NUMBER := 0;
      SSobsch        NUMBER := 0;
      Nold           NUMBER := 0;
      Nnew           NUMBER := 0;
      Sold           NUMBER := 0;
      Snew           NUMBER := 0;
      Nobsch         NUMBER := 0;
      Sobsch         NUMBER := 0;
      v_MaxSUMFIIDCOST NUMBER := 0;
      v_MaxNEWFIID     NUMBER := 0;
      PrevSumID        NUMBER := 0;
      v_Method         NUMBER;
      v_SumPrecision       NUMBER := 0;
      v_SumPrecisionScdlfi NUMBER := 0;

      CURSOR C_L_NOT_READY IS --непоставленные
      SELECT L.*
        FROM DPMWRTSUM_DBT L, DDLRQ_DBT rqd
       WHERE L.T_FIID        = pFIID
         AND L.T_DEPARTMENT  = pDepartment
         AND L.T_TRUST      != 'X'
         AND L.T_STATE       = PM_WRTSUM_NOTFORM
         AND L.T_DOCKIND     = 29
         AND L.T_DOCID       = rqd.t_ID
         AND (SELECT COUNT(1)
                FROM DDLRQ_DBT rqp
               WHERE rqp.T_DOCID  = rqd.T_DOCID
                 AND rqp.T_DOCKIND     = rqd.T_DOCKIND
                 AND rqp.T_TYPE    IN (rsi_dlrq.DLRQ_TYPE_AVANCE, rsi_dlrq.DLRQ_TYPE_PAYMENT, rsi_dlrq.DLRQ_TYPE_DEPOSIT) --Аванс, Контрактив
                 AND rqp.T_STATE = rsi_dlrq.DLRQ_STATE_EXEC
             ) > 0;

      CURSOR C_L_READY IS --поставленные
      SELECT *
        FROM DPMWRTSUM_DBT L
       WHERE L.T_FIID        = pFIID
         AND L.T_DEPARTMENT  = pDepartment
         AND L.T_TRUST      != 'X'
         AND L.T_STATE       = PM_WRTSUM_FORM
         AND L.T_BUY_SALE    = PM_WRITEOFF_SUM_BUY
         AND L.T_AMOUNT      > 0;

      CURSOR C_SCDLFI IS
      SELECT *
        FROM dscdlfi_tmp tmp
       WHERE tmp.T_DEALKIND = pDealKind
         AND tmp.T_DEALID   = pDealID
         AND tmp.t_Action  != SCDL_DELETE;

      CURSOR C_SCDLPMWR_BY_PARTY_CONTR IS
      SELECT DISTINCT sc.t_Party, sc.t_kind,
             (CASE WHEN sc.t_Kind = 1 THEN (SELECT s.t_Contract FROM dpmwrtsum_dbt s WHERE s.t_SumID = sc.t_SumID)
                   WHEN sc.t_Kind = 2 THEN (SELECT s.t_Contract FROM dpmwrtcl_dbt s WHERE s.t_ID = sc.t_SumID)
                   ELSE 0 END) as t_Contract
        FROM dscdlpmwr_tmp sc
       WHERE sc.T_DEALKIND = pDealKind
         AND sc.T_DEALID   = pDealID
         AND sc.t_State    = SCDLPMWR_STATE_READY
         AND sc.t_Action  != SCDL_DELETE;

      CURSOR C_SCDLPMWR_BY_PARTY_SUMID (p_Party IN NUMBER, p_Contract IN NUMBER, p_Kind IN NUMBER) IS
      SELECT sc.*
        FROM dscdlpmwr_tmp sc, dpmwrtsum_dbt s
       WHERE sc.T_DEALKIND = pDealKind
         AND sc.T_DEALID   = pDealID
         AND sc.t_State    = SCDLPMWR_STATE_READY
         AND sc.t_Action  != SCDL_DELETE
         AND s.t_SumID     = sc.t_SumID
         AND sc.t_Party    = p_Party
         AND sc.t_Kind     = p_Kind
         AND s.t_Contract  = p_Contract
       ORDER BY sc.t_SumID;

      CURSOR C_FICOST IS
      SELECT *
        FROM dficost_tmp tmp;

   BEGIN

      pError := 0;
      RSI_MarkForDeleteSCDLPMWR( pDealKind, pDealID);

      -- Если список новых выпусков не заполнен, ошибка
      IF ExistSCDLFI( pDealKind, pDealID, 0, 0) = 0 THEN
         pError := 1; --Список новых выпусков не заполнен
         return;
      END IF;

      SELECT COUNT(1) INTO v_Count
        FROM DPMWRTSUM_DBT L
       WHERE L.T_FIID        = pFIID
         AND L.T_DEPARTMENT  = pDepartment
         AND L.T_TRUST      != 'X'
         AND L.T_CHANGEDATE  > pCommDate;

      IF v_Count > 0 THEN
         pError := 2; --По лотам старого выпуска есть операции за более позднюю дату
         return;
      END IF;

      SELECT COUNT(1) INTO v_Count
        FROM DPMWRTCL_DBT L
       WHERE L.T_FIID = pFIID
         AND L.T_DEPARTMENT = pDepartment
         AND L.T_ENDDATE >= pCommDate
         AND L.T_ENDDATE <> TO_DATE('31.12.9999','DD.MM.YYYY');

      IF v_Count > 0 THEN
         pError := 2; --По лотам старого выпуска есть операции за более позднюю дату
         return;
      END IF;

      SELECT Count(1) INTO N
        FROM dscdlfi_tmp tmp
       WHERE tmp.T_DEALKIND = pDealKind
         AND tmp.T_DEALID   = pDealID
         AND tmp.t_Action  != SCDL_DELETE;

      IF N > 1 THEN
         SELECT SUM( TO_NUMBER(tmp.t_Numerator) / TO_NUMBER(tmp.t_Denominator) ) INTO KC
           FROM dscdlfi_tmp tmp
          WHERE tmp.T_DEALKIND = pDealKind
            AND tmp.T_DEALID   = pDealID
            AND tmp.t_Action  != SCDL_DELETE;
      END IF;

      IF N = 1 THEN
         SELECT * INTO v_scdlfi
           FROM dscdlfi_tmp tmp
          WHERE tmp.T_DEALKIND = pDealKind
            AND tmp.T_DEALID   = pDealID
            AND tmp.t_Action  != SCDL_DELETE;

         GetSumPrecisionByNewFiid(v_scdlfi.T_NEWFIID, pDealKind, 
                                    pDealID, v_SumPrecisionScdlfi);


         if v_SumPrecision = -1 then return; end if;

         FOR L IN C_L_NOT_READY LOOP

            pNewAmount := ROUND (L.T_AMOUNT * TO_NUMBER(v_scdlfi.t_Numerator) / TO_NUMBER(v_scdlfi.t_Denominator), v_SumPrecision);

            INSERT INTO dscdlpmwr_tmp( T_DEALKIND              ,
                                       T_DEALID                ,
                                       T_OLDAMOUNT             ,
                                       T_CALCAMOUNT            ,
                                       T_NEWAMOUNT             ,
                                       T_STATE                 ,
                                       T_SUMID                 ,
                                       T_PARTY                 ,
                                       T_DATE                  ,
                                       T_NEWFIID               ,
                                       T_SUMFIIDAMOUNT         ,
                                       T_SUMNEWAMOUNT          ,
                                       T_OLDCOST               ,
                                       T_SUMFIIDCOST           ,
                                       T_SUMNEWCOST            ,
                                       T_CALCCOST              ,
                                       T_NEWCOST               ,
                                       T_INTERESTINCOMEADD     ,
                                       T_DISCOUNTINCOMEADD     ,
                                       T_OLDINSTANCE           ,
                                       T_KIND                  ,
                                       T_DEALKIND_FROM         ,
                                       T_DEALID_FROM           ,
                                       T_OLDAMOUNT_FROM        ,
                                       T_CALCAMOUNT_FROM       ,
                                       T_NEWAMOUNT_FROM        ,
                                       T_STATE_FROM            ,
                                       T_SUMID_FROM            ,
                                       T_PARTY_FROM            ,
                                       T_DATE_FROM             ,
                                       T_NEWFIID_FROM          ,
                                       T_SUMFIIDAMOUNT_FROM    ,
                                       T_SUMNEWAMOUNT_FROM     ,
                                       T_OLDCOST_FROM          ,
                                       T_SUMFIIDCOST_FROM      ,
                                       T_SUMNEWCOST_FROM       ,
                                       T_CALCCOST_FROM         ,
                                       T_NEWCOST_FROM          ,
                                       T_INTERESTINCOMEADD_FROM,
                                       T_DISCOUNTINCOMEADD_FROM,
                                       T_OLDINSTANCE_FROM      ,
                                       T_KIND_FROM             ,
                                       T_ACTION
                                     )
                               VALUES( pDealKind               ,  --T_DEALKIND
                                       pDealID                 ,  --T_DEALID
                                       L.T_AMOUNT              ,  --T_OLDAMOUNT
                                       0                       ,  --T_CALCAMOUNT
                                       pNewAmount              ,  --T_NEWAMOUNT
                                       SCDLPMWR_STATE_NOT_READY,  --T_STATE
                                       L.T_SUMID               ,  --T_SUMID
                                       L.T_PARTY               ,  --T_PARTY
                                       L.T_DATE                ,  --T_DATE
                                       v_scdlfi.T_NEWFIID      ,  --T_NEWFIID
                                       0                       ,  --T_SUMFIIDAMOUNT
                                       0                       ,  --T_SUMNEWAMOUNT
                                       0                       ,  --T_OLDCOST
                                       0                       ,  --T_SUMFIIDCOST
                                       0                       ,  --T_SUMNEWCOST
                                       0                       ,  --T_CALCCOST
                                       0                       ,  --T_NEWCOST
                                       0                       ,  --T_INTERESTINCOMEADD
                                       0                       ,  --T_DISCOUNTINCOMEADD
                                       L.T_INSTANCE            ,  --T_OLDINSTANCE
                                       1                       ,  --T_KIND
                                       0                       ,  --T_DEALKIND_FROM
                                       0                       ,  --T_DEALID_FROM
                                       0                       ,  --T_OLDAMOUNT_FROM
                                       0                       ,  --T_CALCAMOUNT_FROM
                                       0                       ,  --T_NEWAMOUNT_FROM
                                       0                       ,  --T_STATE_FROM
                                       0                       ,  --T_SUMID_FROM
                                       0                       ,  --T_PARTY_FROM
                                       UnknownDate             ,  --T_DATE_FROM
                                       0                       ,  --T_NEWFIID_FROM
                                       0                       ,  --T_SUMFIIDAMOUNT_FROM
                                       0                       ,  --T_SUMNEWAMOUNT_FROM
                                       0                       ,  --T_OLDCOST_FROM
                                       0                       ,  --T_SUMFIIDCOST_FROM
                                       0                       ,  --T_SUMNEWCOST_FROM
                                       0                       ,  --T_CALCCOST_FROM
                                       0                       ,  --T_NEWCOST_FROM
                                       0                       ,  --T_INTERESTINCOMEADD_FROM
                                       0                       ,  --T_DISCOUNTINCOMEADD_FROM
                                       0                       ,  --T_OLDINSTANCE_FROM
                                       0                       ,  --T_KIND_FROM
                                       SCDL_INSERT                --T_ACTION
                                     );

         END LOOP;
      END IF;

      FOR L IN C_L_READY LOOP

         if( L.t_Party = UnknownParty AND pFlag3 = 1 AND pOperSubKind <> 4 /*Объединение*/ AND WRTNeedChargeIncome (pFIID) = 1 ) then
            v_CalcDiscount := 1;
         else
            v_CalcDiscount := 0;
         end if;

         if( L.t_Party = UnknownParty AND pFlag3 = 1 AND pOperSubKind <> 4 /*Объединение*/ AND WRTNeedChargeInterestIncome (pFIID) = 1 ) then
            v_CalcInterest := 1;
         else
            v_CalcInterest := 0;
         end if;

         FOR F IN C_SCDLFI LOOP
            GetSumPrecisionByNewFiid(F.T_NEWFIID, pDealKind, 
                                    pDealID, v_SumPrecision);

            pNewAmount := round(L.T_AMOUNT * TO_NUMBER(F.t_Numerator) / TO_NUMBER(F.t_Denominator), v_sumPrecision);

            v_Method := GetAmortizationMethod( L.T_Party, L.T_Contract );

            IF v_CalcInterest = 1 THEN
               v_InterestIncomeAdd := WRTCalcInterestIncome (pBegDate, L.t_BegInterestDate,
                                      0, L.t_FIID, L.t_Amount, L.t_NKDAmount, L.t_InterestDate,
                                      L.t_InterestIncome, v_Method, NULL, false, 0);
            ELSE
               v_InterestIncomeAdd := 0;
            END IF;

            IF v_CalcDiscount = 1 THEN
               v_DiscountIncomeAdd := WRTCalcDiscountIncome (pBegDate, L.t_BegDiscountDate,
                                      0, L.t_FIID, L.t_Amount,
                                      L.t_Cost, L.t_DiscountDate, L.t_DiscountIncome,
                                      L.t_BegDiscount, L.t_OldBegDiscount,
                                      L.t_Party, L.t_Contract, L.t_RecalcDate);
            ELSE
               v_DiscountIncomeAdd := 0;
            END IF;

            IF L.t_Portfolio = KINDPORT_SALE THEN
               v_OldCost := L.t_BalanceCost;
            ELSE
               v_OldCost := L.t_Cost + L.t_NKDAmount + L.t_InterestIncome + L.t_DiscountIncome;
            END IF;

            IF N > 1 THEN
               v_CalcCost := (v_OldCost + v_InterestIncomeAdd + v_DiscountIncomeAdd) * TO_NUMBER(F.t_Numerator) / TO_NUMBER(F.t_Denominator) / KC;
            ELSE
               v_CalcCost :=  v_OldCost + v_InterestIncomeAdd + v_DiscountIncomeAdd;
            END IF;

            INSERT INTO dscdlpmwr_tmp( T_DEALKIND              ,
                                       T_DEALID                ,
                                       T_OLDAMOUNT             ,
                                       T_CALCAMOUNT            ,
                                       T_NEWAMOUNT             ,
                                       T_STATE                 ,
                                       T_SUMID                 ,
                                       T_PARTY                 ,
                                       T_DATE                  ,
                                       T_NEWFIID               ,
                                       T_SUMFIIDAMOUNT         ,
                                       T_SUMNEWAMOUNT          ,
                                       T_OLDCOST               ,
                                       T_SUMFIIDCOST           ,
                                       T_SUMNEWCOST            ,
                                       T_CALCCOST              ,
                                       T_NEWCOST               ,
                                       T_INTERESTINCOMEADD     ,
                                       T_DISCOUNTINCOMEADD     ,
                                       T_OLDINSTANCE           ,
                                       T_KIND                  ,
                                       T_DEALKIND_FROM         ,
                                       T_DEALID_FROM           ,
                                       T_OLDAMOUNT_FROM        ,
                                       T_CALCAMOUNT_FROM       ,
                                       T_NEWAMOUNT_FROM        ,
                                       T_STATE_FROM            ,
                                       T_SUMID_FROM            ,
                                       T_PARTY_FROM            ,
                                       T_DATE_FROM             ,
                                       T_NEWFIID_FROM          ,
                                       T_SUMFIIDAMOUNT_FROM    ,
                                       T_SUMNEWAMOUNT_FROM     ,
                                       T_OLDCOST_FROM          ,
                                       T_SUMFIIDCOST_FROM      ,
                                       T_SUMNEWCOST_FROM       ,
                                       T_CALCCOST_FROM         ,
                                       T_NEWCOST_FROM          ,
                                       T_INTERESTINCOMEADD_FROM,
                                       T_DISCOUNTINCOMEADD_FROM,
                                       T_OLDINSTANCE_FROM      ,
                                       T_KIND_FROM             ,
                                       T_ACTION
                                     )
                               VALUES( pDealKind               ,  --T_DEALKIND
                                       pDealID                 ,  --T_DEALID
                                       L.T_AMOUNT              ,  --T_OLDAMOUNT
                                       pNewAmount              ,  --T_CALCAMOUNT
                                       pNewAmount              ,  --T_NEWAMOUNT
                                       SCDLPMWR_STATE_READY    ,  --T_STATE
                                       L.T_SUMID               ,  --T_SUMID
                                       L.T_PARTY               ,  --T_PARTY
                                       L.T_DATE                ,  --T_DATE
                                       F.T_NEWFIID             ,  --T_NEWFIID
                                       0                       ,  --T_SUMFIIDAMOUNT
                                       0                       ,  --T_SUMNEWAMOUNT
                                       v_OldCost               ,  --T_OLDCOST
                                       0                       ,  --T_SUMFIIDCOST
                                       0                       ,  --T_SUMNEWCOST
                                       v_CalcCost              ,  --T_CALCCOST
                                       v_CalcCost              ,  --T_NEWCOST
                                       v_InterestIncomeAdd     ,  --T_INTERESTINCOMEADD
                                       v_DiscountIncomeAdd     ,  --T_DISCOUNTINCOMEADD
                                       L.T_INSTANCE            ,  --T_OLDINSTANCE
                                       1                       ,  --T_KIND
                                       0                       ,  --T_DEALKIND_FROM
                                       0                       ,  --T_DEALID_FROM
                                       0                       ,  --T_OLDAMOUNT_FROM
                                       0                       ,  --T_CALCAMOUNT_FROM
                                       0                       ,  --T_NEWAMOUNT_FROM
                                       0                       ,  --T_STATE_FROM
                                       0                       ,  --T_SUMID_FROM
                                       0                       ,  --T_PARTY_FROM
                                       UnknownDate             ,  --T_DATE_FROM
                                       0                       ,  --T_NEWFIID_FROM
                                       0                       ,  --T_SUMFIIDAMOUNT_FROM
                                       0                       ,  --T_SUMNEWAMOUNT_FROM
                                       0                       ,  --T_OLDCOST_FROM
                                       0                       ,  --T_SUMFIIDCOST_FROM
                                       0                       ,  --T_SUMNEWCOST_FROM
                                       0                       ,  --T_CALCCOST_FROM
                                       0                       ,  --T_NEWCOST_FROM
                                       0                       ,  --T_INTERESTINCOMEADD_FROM
                                       0                       ,  --T_DISCOUNTINCOMEADD_FROM
                                       0                       ,  --T_OLDINSTANCE_FROM
                                       0                       ,  --T_KIND_FROM
                                       SCDL_INSERT                --T_ACTION
                                     );
         END LOOP;
      END LOOP;

      -- Перебираются поставленные клиентские лоты старого выпуска
      FOR one_cl IN (SELECT L.T_ID, L.T_PARTY, L.T_BEGDATE, L.T_AMOUNT
                       FROM DPMWRTCL_DBT L
                      WHERE L.T_FIID = pFIID
                        AND L.T_DEPARTMENT = pDepartment
                        AND L.T_ENDDATE = TO_DATE('31.12.9999','DD.MM.YYYY')
                        AND L.T_AMOUNT > 0
                    )
      LOOP


        FOR F IN C_SCDLFI LOOP

          GetSumPrecisionByNewFiid(F.T_NEWFIID, pDealKind, 
                                   pDealID, v_SumPrecision);

          pNewAmount := round(one_cl.T_AMOUNT * TO_NUMBER(F.t_Numerator) / TO_NUMBER(F.t_Denominator), v_sumPrecision);

          INSERT INTO dscdlpmwr_tmp( T_DEALKIND              ,
                                     T_DEALID                ,
                                     T_OLDAMOUNT             ,
                                     T_CALCAMOUNT            ,
                                     T_NEWAMOUNT             ,
                                     T_STATE                 ,
                                     T_SUMID                 ,
                                     T_PARTY                 ,
                                     T_DATE                  ,
                                     T_NEWFIID               ,
                                     T_SUMFIIDAMOUNT         ,
                                     T_SUMNEWAMOUNT          ,
                                     T_OLDCOST               ,
                                     T_SUMFIIDCOST           ,
                                     T_SUMNEWCOST            ,
                                     T_CALCCOST              ,
                                     T_NEWCOST               ,
                                     T_INTERESTINCOMEADD     ,
                                     T_DISCOUNTINCOMEADD     ,
                                     T_OLDINSTANCE           ,
                                     T_KIND                  ,
                                     T_DEALKIND_FROM         ,
                                     T_DEALID_FROM           ,
                                     T_OLDAMOUNT_FROM        ,
                                     T_CALCAMOUNT_FROM       ,
                                     T_NEWAMOUNT_FROM        ,
                                     T_STATE_FROM            ,
                                     T_SUMID_FROM            ,
                                     T_PARTY_FROM            ,
                                     T_DATE_FROM             ,
                                     T_NEWFIID_FROM          ,
                                     T_SUMFIIDAMOUNT_FROM    ,
                                     T_SUMNEWAMOUNT_FROM     ,
                                     T_OLDCOST_FROM          ,
                                     T_SUMFIIDCOST_FROM      ,
                                     T_SUMNEWCOST_FROM       ,
                                     T_CALCCOST_FROM         ,
                                     T_NEWCOST_FROM          ,
                                     T_INTERESTINCOMEADD_FROM,
                                     T_DISCOUNTINCOMEADD_FROM,
                                     T_OLDINSTANCE_FROM      ,
                                     T_KIND_FROM             ,
                                     T_ACTION
                                   )
                             VALUES( pDealKind               ,  --T_DEALKIND
                                     pDealID                 ,  --T_DEALID
                                     one_cl.T_AMOUNT         ,  --T_OLDAMOUNT
                                     pNewAmount              ,  --T_CALCAMOUNT
                                     pNewAmount              ,  --T_NEWAMOUNT
                                     SCDLPMWR_STATE_READY    ,  --T_STATE
                                     one_cl.T_ID             ,  --T_SUMID
                                     one_cl.T_PARTY          ,  --T_PARTY
                                     one_cl.T_BEGDATE        ,  --T_DATE
                                     F.T_NEWFIID             ,  --T_NEWFIID
                                     0                       ,  --T_SUMFIIDAMOUNT
                                     0                       ,  --T_SUMNEWAMOUNT
                                     0                       ,  --T_OLDCOST
                                     0                       ,  --T_SUMFIIDCOST
                                     0                       ,  --T_SUMNEWCOST
                                     0                       ,  --T_CALCCOST
                                     0                       ,  --T_NEWCOST
                                     0                       ,  --T_INTERESTINCOMEADD
                                     0                       ,  --T_DISCOUNTINCOMEADD
                                     0                       ,  --T_OLDINSTANCE
                                     2                       ,  --T_KIND
                                     0                       ,  --T_DEALKIND_FROM
                                     0                       ,  --T_DEALID_FROM
                                     0                       ,  --T_OLDAMOUNT_FROM
                                     0                       ,  --T_CALCAMOUNT_FROM
                                     0                       ,  --T_NEWAMOUNT_FROM
                                     0                       ,  --T_STATE_FROM
                                     0                       ,  --T_SUMID_FROM
                                     0                       ,  --T_PARTY_FROM
                                     UnknownDate             ,  --T_DATE_FROM
                                     0                       ,  --T_NEWFIID_FROM
                                     0                       ,  --T_SUMFIIDAMOUNT_FROM
                                     0                       ,  --T_SUMNEWAMOUNT_FROM
                                     0                       ,  --T_OLDCOST_FROM
                                     0                       ,  --T_SUMFIIDCOST_FROM
                                     0                       ,  --T_SUMNEWCOST_FROM
                                     0                       ,  --T_CALCCOST_FROM
                                     0                       ,  --T_NEWCOST_FROM
                                     0                       ,  --T_INTERESTINCOMEADD_FROM
                                     0                       ,  --T_DISCOUNTINCOMEADD_FROM
                                     0                       ,  --T_OLDINSTANCE_FROM
                                     0                       ,  --T_KIND_FROM
                                     SCDL_INSERT                --T_ACTION
                                   );


        END LOOP;

      END LOOP;

      FOR CParty IN C_SCDLPMWR_BY_PARTY_CONTR LOOP
         SSold   := 0;
         SSobsch := 0; --SSобщ

         IF (N = 1) THEN
            SELECT SUM(sc.t_OldAmount), SUM(sc.t_NewAmount), SUM(sc.t_OldCost), SUM(sc.t_NewCost)
              INTO Nold, Nnew, Sold, Snew
              FROM dscdlpmwr_tmp sc, dpmwrtsum_dbt s
             WHERE sc.T_DEALKIND = pDealKind
               AND sc.T_DEALID   = pDealID
               AND sc.t_State    = SCDLPMWR_STATE_READY
               AND sc.t_Action  != SCDL_DELETE
               AND sc.t_Party    = CParty.t_Party
               AND sc.t_Kind     = CParty.t_Kind
               AND s.t_Contract  = CParty.t_Contract
               AND s.t_SumID     = sc.t_SumID;

            -- так как N =1, то мы уверены, что v_scdlfi не null
            -- Nобщ
            Nobsch := ROUND (Nold * TO_NUMBER(v_scdlfi.t_Numerator) / TO_NUMBER(v_scdlfi.t_Denominator), v_SumPrecisionScdlfi);

            UPDATE dscdlpmwr_tmp tmp
               SET tmp.T_SUMFIIDAMOUNT = Nobsch,
                   tmp.T_SUMNEWAMOUNT  = Nnew,
                   tmp.T_SUMFIIDCOST   = Sold,
                   tmp.T_SUMNEWCOST    = Snew
             WHERE tmp.T_DEALKIND = pDealKind
               AND tmp.T_DEALID   = pDealID
               AND tmp.t_State    = SCDLPMWR_STATE_READY
               AND tmp.t_Action  != SCDL_DELETE
               AND tmp.t_Party    = CParty.t_Party
               AND tmp.t_Kind     = CParty.t_Kind
               AND (select s.t_Contract from dpmwrtsum_dbt s where s.t_SumID = tmp.t_SumID) = CParty.t_Contract;
         ELSE
           IF CParty.t_Kind = 1 THEN --Собственные

              DELETE FROM dficost_tmp;

              SSold := 0;
              PrevSumID := 0;
              FOR S IN C_SCDLPMWR_BY_PARTY_SUMID (CParty.t_Party, CParty.t_Contract, CParty.t_Kind) LOOP
                 if (S.t_SumID <> PrevSumID) then
                    SSold := SSold + S.t_OldCost;
                    PrevSumID := S.t_SumID;
                 end if;
              END LOOP;

              FOR F IN C_SCDLFI LOOP
                 SELECT SUM(sc.t_OldAmount), SUM(sc.t_NewAmount), SUM(sc.t_OldCost), SUM(sc.t_NewCost)
                   INTO Nold, Nnew, Sold, Snew
                   FROM dscdlpmwr_tmp sc, dpmwrtsum_dbt s
                  WHERE sc.T_DEALKIND = pDealKind
                    AND sc.T_DEALID   = pDealID
                    AND sc.t_State    = SCDLPMWR_STATE_READY
                    AND sc.t_Action  != SCDL_DELETE
                    AND sc.t_NewFIID  = F.t_NewFIID
                    AND sc.t_Party    = CParty.t_Party
                    AND sc.t_Kind     = CParty.t_Kind
                    AND s.t_Contract  = CParty.t_Contract
                    AND s.t_SumID     = sc.t_SumID;

                 GetSumPrecisionByNewFiid(F.T_NEWFIID, pDealKind, 
                                    pDealID, v_SumPrecision);
                 if v_SumPrecision = -1 then return; end if;

                 -- Nобщ
                 Nobsch := ROUND (Nold * TO_NUMBER(F.t_Numerator) / TO_NUMBER(F.t_Denominator), v_SumPrecision);

                 -- Sобщ
                 Sobsch := ROUND (Sold * TO_NUMBER(F.t_Numerator) / TO_NUMBER(F.t_Denominator) / KC, 2);

                 --SSобщ = SSобщ + Sобщ
                 SSobsch := SSobsch + Sobsch;

                 INSERT INTO dficost_tmp( T_NEWFIID       ,
                                          T_SUMFIIDAMOUNT ,
                                          T_SUMNEWAMOUNT  ,
                                          T_SUMFIIDCOST   ,
                                          T_SUMNEWCOST
                                        )
                                  VALUES( F.T_NEWFIID     ,  --T_NEWFIID
                                          Nobsch          ,  --T_SUMFIIDAMOUNT
                                          Nnew            ,  --T_SUMNEWAMOUNT
                                          Sobsch          ,  --T_SUMFIIDCOST
                                          Snew               --T_SUMNEWCOST
                                        );

              END LOOP;


              IF (SSold <> SSobsch) THEN
                 SELECT T_SUMFIIDCOST, T_NEWFIID
                   INTO v_MaxSUMFIIDCOST, v_MaxNEWFIID
                   FROM dficost_tmp
                  WHERE T_SUMFIIDCOST = (SELECT MAX(T_SUMFIIDCOST)
                                           FROM dficost_tmp
                                        )
                    AND ROWNUM = 1
                  ORDER BY T_NEWFIID;

                 UPDATE dficost_tmp
                    SET T_SUMFIIDCOST = v_MaxSUMFIIDCOST - (SSobsch - SSold)
                  WHERE T_NEWFIID = v_MaxNEWFIID;
              END IF;

              FOR FiCost IN C_FICOST LOOP
                 UPDATE dscdlpmwr_tmp tmp
                    SET tmp.T_SUMFIIDAMOUNT = FiCost.T_SUMFIIDAMOUNT,
                        tmp.T_SUMNEWAMOUNT  = FiCost.T_SUMNEWAMOUNT ,
                        tmp.T_SUMFIIDCOST   = FiCost.T_SUMFIIDCOST  ,
                        tmp.T_SUMNEWCOST    = FiCost.T_SUMNEWCOST
                  WHERE tmp.T_DEALKIND = pDealKind
                    AND tmp.T_DEALID   = pDealID
                    AND tmp.t_State    = SCDLPMWR_STATE_READY
                    AND tmp.t_Action  != SCDL_DELETE
                    AND tmp.t_NewFIID  = FiCost.t_NewFIID
                    AND tmp.t_Party    = CParty.t_Party
                    AND tmp.t_Kind     = CParty.t_Kind
                    AND (select s.t_Contract from dpmwrtsum_dbt s where s.t_SumID = tmp.t_SumID) = CParty.t_Contract;
              END LOOP;
           ELSE --клиентские

             FOR F IN C_SCDLFI LOOP
               SELECT SUM(sc.t_OldAmount), SUM(sc.t_NewAmount), SUM(sc.t_OldCost), SUM(sc.t_NewCost)
                      INTO Nold, Nnew, Sold, Snew
                 FROM dscdlpmwr_tmp sc, dpmwrtcl_dbt l
                WHERE sc.T_DEALKIND = pDealKind
                  AND sc.T_DEALID   = pDealID
                  AND sc.t_State    = SCDLPMWR_STATE_READY
                  AND sc.t_Action  != SCDL_DELETE
                  AND sc.t_NewFIID  = F.t_NewFIID
                  AND sc.t_Party    = CParty.t_Party
                  AND sc.t_Kind     = CParty.t_Kind
                  AND l.t_Contract  = CParty.t_Contract
                  AND l.t_ID        = sc.t_SumID;

               GetSumPrecisionByNewFiid(F.T_NEWFIID, pDealKind, 
                                   pDealID, v_SumPrecision);
               if v_SumPrecision = -1 then return; end if;
               
               -- Nобщ
               Nobsch := ROUND (Nold * TO_NUMBER(F.t_Numerator) / TO_NUMBER(F.t_Denominator), v_SumPrecision);

               UPDATE dscdlpmwr_tmp tmp
                  SET tmp.T_SUMFIIDAMOUNT = Nobsch,
                      tmp.T_SUMNEWAMOUNT  = Nnew
                WHERE tmp.T_DEALKIND = pDealKind
                  AND tmp.T_DEALID   = pDealID
                  AND tmp.t_NewFIID  = F.t_NewFIID
                  AND tmp.t_Party    = CParty.t_Party
                  AND tmp.t_Kind     = CParty.t_Kind;

             END LOOP;
           END IF;
         END IF;
      END LOOP;
      DELETE FROM dficost_tmp;

   END RSI_FillScdlpmwrByDlcomm;

   FUNCTION ExistLotsByDlComm( pDealKind IN NUMBER, pDealID IN NUMBER) RETURN NUMBER DETERMINISTIC
   IS
     v_Count NUMBER := 0;

   BEGIN

     SELECT Count(1) INTO v_Count
       FROM dpmwrtsum_dbt
      WHERE T_DOCKIND = pDealKind
        AND T_DOCID   = pDealID
        AND t_Buy_Sale in (PM_WRITEOFF_SUM_BUY, PM_WRITEOFF_SUM_BUY_BO );

     IF v_Count = 0 THEN
        RETURN 0; -- нет
     ELSE
        RETURN 1; -- есть
     END IF;

   END ExistLotsByDlComm;

   PROCEDURE FillScdlpmwrByDlcomm( pDealKind IN NUMBER, pDealID IN NUMBER, pFIID IN NUMBER,
                                   pCommDate IN DATE, pBegDate IN DATE, pEndDate IN DATE,
                                   pFlag3 IN NUMBER, pDepartment IN NUMBER, pError OUT NUMBER, pOperSubKind IN NUMBER)
   IS
   BEGIN
      RSI_FillScdlpmwrByDlcomm( pDealKind, pDealID, pFIID, pCommDate, pBegDate, pEndDate, pFlag3, pDepartment, pError, pOperSubKind);
   END FillScdlpmwrByDlcomm;


   --Выполняет генерацию ошибки при списании клиентских бумаг
   PROCEDURE RSI_WRTLinkClientLotSetError(p_FIID IN NUMBER,
                                          p_Department IN NUMBER,
                                          p_Party IN NUMBER,
                                          p_Contract IN NUMBER,
                                          p_NewAmount IN NUMBER,
                                          p_NewDate IN DATE,
                                          p_ID_Operation IN NUMBER,
                                          p_ID_Step IN NUMBER
                                         )
   IS

     v_CommCode DDL_COMM_DBT.T_COMMCODE%TYPE;
     v_PartyShortName DPARTY_DBT.T_SHORTNAME%TYPE;
     v_ContractNumber DSFCONTR_DBT.T_NUMBER%TYPE;
     v_FI_Code DFININSTR_DBT.T_FI_CODE%TYPE;

     v_OpName DOPRKOPER_DBT.T_NAME%TYPE;

   BEGIN

     SELECT T_SHORTNAME INTO v_PartyShortName
       FROM DPARTY_DBT
      WHERE T_PARTYID = p_Party;

     BEGIN
        SELECT T_NUMBER INTO v_ContractNumber
          FROM DSFCONTR_DBT
         WHERE T_ID = p_Contract;
       EXCEPTION WHEN NO_DATA_FOUND THEN v_ContractNumber := '';
     END;

     SELECT T_FI_CODE INTO v_FI_Code
       FROM DFININSTR_DBT
      WHERE T_FIID = p_FIID;

     IF p_ID_Step = -1 THEN

       SELECT T_COMMCODE INTO v_CommCode
         FROM DDL_COMM_DBT
        WHERE T_DOCUMENTID = p_ID_Operation;

       SetError( WRTOFF_ERROR_20243, 'с кодом '||v_CommCode||' по клиенту '||v_PartyShortName||' по договору номер '||v_ContractNumber||' на дату '||TO_CHAR(p_NewDate, 'DD.MM.YYYY')||' отрицательный остаток бумаг '||v_FI_Code||' равный '|| p_NewAmount);
     ELSE

       SELECT OK.T_NAME, NVL(CM.T_COMMCODE, tick.t_DealCode) INTO v_OpName, v_CommCode
         FROM DOPRKOPER_DBT OK, DOPROPER_DBT OP, DDL_COMM_DBT CM, DDL_TICK_DBT tick
        WHERE OP.T_ID_OPERATION = p_ID_Operation
          AND OK.T_KIND_OPERATION = OP.T_KIND_OPERATION
          AND CM.T_DOCKIND(+) = OP.T_DOCKIND
          AND LPAD( CM.T_DOCUMENTID(+), 34, '0' ) = OP.T_DOCUMENTID
          AND tick.t_BOfficeKind(+) = OP.T_DOCKIND
          AND LPAD( tick.t_DealID(+), 34, '0' ) = OP.T_DOCUMENTID;

       SetError( WRTOFF_ERROR_20244, 'вида '||v_OpName||
                                      CASE WHEN v_CommCode IS NOT NULL THEN ' с кодом '||v_CommCode
                                           ELSE ' №' || p_ID_Operation
                                      END ||
                                      ' по клиенту '||v_PartyShortName||' по договору номер '||v_ContractNumber||' на дату '||TO_CHAR(p_NewDate, 'DD.MM.YYYY')||' отрицательный остаток бумаг '||v_FI_Code||' равный '|| p_NewAmount);
     END IF;

      SetError( WRTOFF_ERROR_20207 );
   END RSI_WRTLinkClientLotSetError;

   --Выполняет занесение количества в клиентские лоты с даты.
   PROCEDURE SetAmountToHist( p_FIID IN NUMBER,
                              p_Department IN NUMBER,
                              p_Party IN NUMBER,
                              p_Contract IN NUMBER,
                              p_Amount IN NUMBER,
                              p_FactDate IN DATE)
   IS
     v_Break BOOLEAN := FALSE;
     v_Date DATE;
     v_MinBegDate DATE;
     v_cl DPMWRTCL_DBT%ROWTYPE;

   BEGIN

     IF p_FactDate = TO_DATE('31.12.9999','DD.MM.YYYY') THEN
       RETURN;
     END IF;

     v_Date := p_FactDate;

     While v_Break = FALSE LOOP

       SELECT NVL(Min(C2.T_BEGDATE), TO_DATE('01.01.0001','DD.MM.YYYY'))
         INTO v_MinBegDate
         FROM DPMWRTCL_DBT C2
        WHERE C2.T_FIID = p_FIID
          AND C2.T_DEPARTMENT = p_Department
          AND C2.T_PARTY = p_Party
          AND C2.T_CONTRACT = p_Contract
          AND C2.T_BEGDATE > v_Date;

       IF v_MinBegDate = TO_DATE('01.01.0001','DD.MM.YYYY') THEN
         INSERT INTO DPMWRTCL_DBT (T_ID, T_PARTY, T_CONTRACT, T_FIID, T_DEPARTMENT, T_BEGDATE, T_ENDDATE, T_AMOUNT)
                           VALUES (0, p_Party, p_Contract, p_FIID, p_Department, v_Date + 1, TO_DATE('31.12.9999','DD.MM.YYYY'), p_Amount);
         v_Break := TRUE;
       ELSE
         SELECT CL.* INTO v_cl
           FROM DPMWRTCL_DBT CL
          WHERE CL.T_FIID = p_FIID
            AND CL.T_DEPARTMENT = p_Department
            AND CL.T_PARTY = p_Party
            AND CL.T_CONTRACT = p_Contract
            AND CL.T_BEGDATE = v_MinBegDate;

         UPDATE DPMWRTCL_DBT CL
            SET CL.T_AMOUNT = CL.T_AMOUNT + p_Amount
          WHERE CL.T_ID = v_cl.t_ID;

         IF v_MinBegDate > v_Date + 1 THEN -- в лотах была дырка. Заполним.
           INSERT INTO DPMWRTCL_DBT (T_ID, T_PARTY, T_CONTRACT, T_FIID, T_DEPARTMENT, T_BEGDATE, T_ENDDATE, T_AMOUNT)
                             VALUES (0, p_Party, p_Contract, p_FIID, p_Department, v_Date + 1, v_MinBegDate - 1, p_Amount);
         END IF;

         v_Date := v_cl.T_EndDate;
         IF v_Date = TO_DATE('31.12.9999','DD.MM.YYYY') THEN
           v_Break := TRUE;
         END IF;
       END IF;
     END LOOP;
   END SetAmountToHist;

   --Выполняет обработку клиентского лота в сервисной операции БУ, либо на шаге операции (ГО, ИН, конвертация акций в ДР).
   PROCEDURE RSI_WRTSetClientLot( p_FIID IN NUMBER,
                                  p_Department IN NUMBER,
                                  p_Party IN NUMBER,
                                  p_Contract IN NUMBER,
                                  p_Amount IN NUMBER,
                                  p_FactDate IN DATE,
                                  p_ID_Operation IN NUMBER,
                                  p_ID_Step IN NUMBER,
                                  p_CheckRest IN NUMBER)
   IS
     v_cl DPMWRTCL_DBT%ROWTYPE;
     v_clexists BOOLEAN := FALSE;

     v_NewAmount DPMWRTCL_DBT.T_AMOUNT%TYPE;
     v_A DPMWRTCL_DBT.T_AMOUNT%TYPE;

     v_MinDate DATE := TO_DATE('01.01.0001','DD.MM.YYYY');
     v_EndDate DATE;
     v_MaxBegDate DATE;
   BEGIN

     v_A := p_Amount;
     
     SELECT NVL(Max(C2.T_BEGDATE), TO_DATE('01.01.0001','DD.MM.YYYY'))
       INTO v_MaxBegDate
       FROM DPMWRTCL_DBT C2
      WHERE C2.T_FIID = p_FIID
        AND C2.T_DEPARTMENT = p_Department
        AND C2.T_PARTY = p_Party
        AND C2.T_CONTRACT = p_Contract
        AND C2.T_BEGDATE <= p_FactDate;

     IF v_MaxBegDate <> TO_DATE('01.01.0001','DD.MM.YYYY') THEN
       v_clexists := TRUE;
     END IF;

     IF v_clexists = TRUE THEN
       BEGIN
         SELECT CL.* INTO v_cl
           FROM DPMWRTCL_DBT CL
          WHERE CL.T_FIID = p_FIID
            AND CL.T_DEPARTMENT = p_Department
            AND CL.T_PARTY = p_Party
            AND CL.T_CONTRACT = p_Contract
            AND CL.T_BEGDATE = v_MaxBegDate;

         EXCEPTION WHEN NO_DATA_FOUND THEN v_clexists := FALSE;
       END;


       IF v_clexists = TRUE AND v_cl.T_BEGDATE = p_FactDate THEN
         v_NewAmount := v_cl.T_AMOUNT + v_A;

         IF p_CheckRest <> 0 AND v_NewAmount < 0 THEN
           RSI_WRTLinkClientLotSetError(p_FIID, p_Department, p_Party, p_Contract, v_NewAmount, p_FactDate, p_ID_Operation, p_ID_Step);
         END IF;

         UPDATE DPMWRTCL_DBT SET T_AMOUNT = v_NewAmount WHERE T_ID = v_cl.T_ID;

         --занести в лоты с T_BEGDATE > v_cl.T_ENDDATE
         SetAmountToHist( p_FIID, p_DEPARTMENT, p_PARTY, p_CONTRACT, v_A, v_cl.T_ENDDATE );

       ELSIF v_clexists = TRUE AND v_cl.T_BEGDATE < p_FactDate THEN
         IF v_cl.T_ENDDATE < p_FactDate THEN  -- т.е. есть лот, но к p_FactDate он уже кончился - считаем что нет, создаём новый
           v_clexists := FALSE;
         ELSE
           v_NewAmount := v_cl.T_AMOUNT + v_A;

           IF p_CheckRest <> 0 AND v_NewAmount < 0 THEN
             RSI_WRTLinkClientLotSetError(p_FIID, p_Department, p_Party, p_Contract, v_NewAmount, p_FactDate, p_ID_Operation, p_ID_Step);
           END IF;

           INSERT INTO DPMWRTCL_DBT (T_ID, T_PARTY, T_CONTRACT, T_FIID, T_DEPARTMENT, T_BEGDATE, T_ENDDATE, T_AMOUNT)
                             VALUES (0, p_Party, p_Contract, p_FIID, p_Department, p_FactDate, v_cl.T_ENDDATE, v_NewAmount);

           UPDATE DPMWRTCL_DBT SET T_ENDDATE = p_FactDate - 1 WHERE T_ID = v_cl.T_ID;

           --занести в лоты c T_BEGDATE > v_cl.T_ENDDATE
           SetAmountToHist( p_FIID, p_DEPARTMENT, p_PARTY, p_CONTRACT, v_A, v_cl.T_ENDDATE );
         END IF;

       END IF;
     END IF;

     IF v_clexists = FALSE THEN

       SELECT NVL(Min(T_BEGDATE), TO_DATE('01.01.0001','DD.MM.YYYY')) INTO v_MinDate
         FROM DPMWRTCL_DBT
        WHERE T_FIID = p_FIID
          AND T_DEPARTMENT = p_Department
          AND T_PARTY = p_Party
          AND T_CONTRACT = p_Contract
          AND T_ENDDATE > p_FactDate;

       IF p_CheckRest <> 0 AND v_A < 0 THEN
         RSI_WRTLinkClientLotSetError(p_FIID, p_Department, p_Party, p_Contract, v_A, p_FactDate, p_ID_Operation, p_ID_Step);
       END IF;

       IF v_MinDate = TO_DATE('01.01.0001','DD.MM.YYYY') THEN
         v_EndDate := TO_DATE('31.12.9999','DD.MM.YYYY');
       ELSE
         v_EndDate := v_MinDate - 1;
       END IF;

       INSERT INTO DPMWRTCL_DBT (T_ID, T_PARTY, T_CONTRACT, T_FIID, T_DEPARTMENT, T_BEGDATE, T_ENDDATE, T_AMOUNT)
                         VALUES (0, p_Party, p_Contract, p_FIID, p_Department, p_FactDate, v_EndDate, v_A);

       --занести в лоты с T_BEGDATE > v_EndDate
       IF v_EndDate <> TO_DATE('31.12.9999','DD.MM.YYYY') THEN
         SetAmountToHist( p_FIID, p_DEPARTMENT, p_PARTY, p_CONTRACT, v_A, v_EndDate );
       END IF;
     END IF;
   END RSI_WRTSetClientLot;

   --Выполняет удаление нулевых лотов, объединяет лоты с равными датами и количествами, проверяет отрицательные остатки
   PROCEDURE RSI_WRTDelAndCheckClientLots(p_FIID IN NUMBER,
                                          p_Department IN NUMBER,
                                          p_Party IN NUMBER,
                                          p_Contract IN NUMBER,
                                          p_ID_Operation IN NUMBER,
                                          p_ID_Step IN NUMBER,
                                          p_CheckRest IN NUMBER)
   IS
     v_PrevID      DPMWRTCL_DBT.T_ID%TYPE;
     v_PrevAmount  DPMWRTCL_DBT.T_AMOUNT%TYPE;
     v_PrevEndDate DPMWRTCL_DBT.T_ENDDATE%TYPE;
   BEGIN

     v_PrevID := 0;
     v_PrevAmount := 0;
     v_PrevEndDate := TO_DATE('01.01.0001','DD.MM.YYYY');

     FOR one_cl IN (SELECT *
                      FROM DPMWRTCL_DBT
                     WHERE T_FIID = p_FIID
                       AND T_DEPARTMENT = p_Department
                       AND T_PARTY = p_Party
                       AND T_CONTRACT = p_Contract
                     ORDER BY T_BEGDATE
                   )
     LOOP
       IF one_cl.T_AMOUNT < 0 AND p_CheckRest <> 0 THEN
         RSI_WRTLinkClientLotSetError(p_FIID, p_Department, p_Party, p_Contract, one_cl.T_AMOUNT, one_cl.T_BEGDATE, p_ID_Operation, p_ID_Step);

       ELSIF one_cl.T_AMOUNT > 0 THEN
         IF one_cl.T_AMOUNT = v_PrevAmount AND v_PrevEndDate >= one_cl.T_BEGDATE-1 THEN
           UPDATE DPMWRTCL_DBT SET T_ENDDATE = one_cl.T_ENDDATE WHERE T_ID = v_PrevID;

           DELETE FROM DPMWRTCL_DBT WHERE T_ID = one_cl.T_ID;
         ELSE
           v_PrevID := one_cl.T_ID;
           v_PrevAmount := one_cl.T_AMOUNT;
           v_PrevEndDate := one_cl.T_ENDDATE;
         END IF;
       ELSIF one_cl.T_AMOUNT = 0 THEN
         DELETE FROM DPMWRTCL_DBT WHERE T_ID = one_cl.T_ID;

         v_PrevID := 0;
         v_PrevAmount := 0;
         v_PrevEndDate := TO_DATE('01.01.0001','DD.MM.YYYY');
       END IF;


     END LOOP;

   END RSI_WRTDelAndCheckClientLots;

   --ПолучитьГруппыСписания для НашегоБанка
   PROCEDURE GetWriteOffGroups( p_BOfficeKind IN NUMBER,
                                p_WrtKind IN NUMBER,
                                p_Portfolio IN NUMBER,
                                p_IsREPO IN NUMBER,
                                p_IsSALE IN NUMBER,
                                p_IsKSU IN NUMBER,
                                p_UseContr IN NUMBER,
                                p_G1 OUT NUMBER,
                                p_G2 OUT NUMBER,
                                p_G3 OUT NUMBER,
                                p_G4 OUT NUMBER,
                                p_G5 OUT NUMBER )
   AS
     v_Portfolio NUMBER;
   BEGIN

     p_G1 := -1;
     p_G2 := -1;
     p_G3 := -1;
     p_G4 := -1;
     p_G5 := -1;

     v_Portfolio := p_Portfolio;

     IF v_Portfolio = KINDPORT_CLIENT THEN
       p_G1 := KINDPORT_CLIENT;
     
     ELSIF p_BOfficeKind = 117 THEN
       IF p_WrtKind = WRTSUM_KIND_DI THEN --Для погашения выпусков
          p_G1 := KINDPORT_RETIRE;
          p_G2 := KINDPORT_TRADE;
          p_G3 := KINDPORT_SALE;
          p_G4 := KINDPORT_PROMISSORY;
       ELSE -- для погашения купонов/чп
          p_G1 := KINDPORT_RETIRE;
          p_G2 := KINDPORT_TRADE;
          p_G3 := KINDPORT_SALE;
          p_G4 := KINDPORT_BACK;
       END IF;

     ELSIF p_BOfficeKind = 101 OR p_BOfficeKind = 127 THEN

       IF p_IsREPO = 1 THEN
         v_Portfolio := KINDPORT_UNDEF;
       END IF;

       IF v_Portfolio = KINDPORT_TRADE THEN
          p_G1 := KINDPORT_TRADE;
          IF WriteOffOnlySetPortofolio() = 0 THEN
             p_G2 := KINDPORT_SALE;
             p_G3 := KINDPORT_RETIRE;
             p_G4 := KINDPORT_BACK;
          END IF;
       ELSIF v_Portfolio = KINDPORT_SALE THEN
          p_G1 := KINDPORT_SALE;
          IF WriteOffOnlySetPortofolio() = 0 THEN
             p_G2 := KINDPORT_TRADE;
             p_G3 := KINDPORT_RETIRE;
             p_G4 := KINDPORT_BACK;
          END IF;
       ELSIF v_Portfolio = KINDPORT_RETIRE THEN
          p_G1 := KINDPORT_RETIRE;
          IF WriteOffOnlySetPortofolio() = 0 THEN
             p_G2 := KINDPORT_SALE;
             p_G3 := KINDPORT_TRADE;
             p_G4 := KINDPORT_BACK;
          END IF;
       ELSIF v_Portfolio = KINDPORT_BACK THEN
          p_G1 := KINDPORT_BACK;
          IF WriteOffOnlySetPortofolio() = 0 THEN
             p_G2 := KINDPORT_SALE;   -- СССД_ЦБ
             p_G3 := KINDPORT_TRADE;  -- ССПУ_ЦБ
             p_G4 := KINDPORT_RETIRE;
          END IF;
       ELSIF v_Portfolio = KINDPORT_CONTR THEN
          p_G1 := KINDPORT_CONTR;
       ELSIF v_Portfolio = KINDPORT_PROMISSORY THEN
          p_G1 := KINDPORT_PROMISSORY;
       ELSIF v_Portfolio = KINDPORT_BACK_KSU THEN -- портфель в лоте списания КСУ или РЕПО КСУ
          IF p_BOfficeKind = 101 THEN -- для РЕПО
             p_G1 := KINDPORT_BACK_KSU;
             p_G2 := KINDPORT_KSU;
          ELSE                   -- для списаний
             p_G1 := KINDPORT_KSU;
             p_G2 := KINDPORT_BACK_KSU;
          END IF;
       ELSIF v_Portfolio = KINDPORT_UNDEF AND p_IsREPO = 1 THEN
          IF p_IsKSU > 0 THEN
            p_G1 := KINDPORT_BACK_KSU;
            p_G2 := KINDPORT_KSU;
          ELSE
            IF( p_IsSALE = 1 ) THEN
               if( p_UseContr = 0 ) then -- нет
                  p_G1 := KINDPORT_TRADE;
                  p_G2 := KINDPORT_SALE;
                  p_G3 := KINDPORT_RETIRE;
                  p_G4 := KINDPORT_BACK;
               else
                  p_G1 := KINDPORT_TRADE;
                  p_G2 := KINDPORT_SALE;
                  p_G3 := KINDPORT_RETIRE;
                  p_G4 := KINDPORT_CONTR;
                  p_G5 := KINDPORT_BACK;
               end if;
            ELSE
               p_G1 := KINDPORT_TRADE;
               p_G2 := KINDPORT_SALE;
               p_G3 := KINDPORT_BACK;
            END IF;
          END IF;
       END IF;

     END IF;

   END;
   
      -- Получение кода для сортировки
   FUNCTION WrtGetSortCode( p_DealID     IN NUMBER, 
                            p_DocKind    IN NUMBER, 
                            p_DealCode   IN VARCHAR2, 
                            p_DealCodeTS IN VARCHAR2
                          ) return VARCHAR2
   is
     v_SortType NUMBER;
     v_SortCode DPMWRTSUM_DBT.T_SORTCODE%TYPE;
   begin
     -- алгоритм взят для сортировки из триггера DPMWRTSUM_DBT_TBIU, поскольку лота на этом этапе ещё нет
     v_SortType := RSB_PMWRTOFF.SortingLotsCode();

     IF v_SortType = RSB_PMWRTOFF.SORTING_LOTS_CODE_BYINNERCODE THEN
       v_SortCode := p_DealCode;
     
     ELSIF v_SortType = RSB_PMWRTOFF.SORTING_LOTS_CODE_BYOUTERCODE THEN

       -- Если перемещения и концертации акций в ДР будут переведены на графики, то проверить логику по триггеру DPMWRTSUM_DBT_TBIU
       IF (p_DocKind = RSB_SECUR.DL_AVRWRT) THEN
         v_SortCode := p_DealCode;
       ELSE
         v_SortCode := p_DealCodeTS;
       END IF;

     ELSIF v_SortType = RSB_PMWRTOFF.SORTING_LOTS_CODE_BYID THEN
       v_SortCode := TO_CHAR(p_DealID);
     
     ELSE
       v_SortCode := p_DealCode;
     END IF;

     v_SortCode := lpad(v_SortCode, 30, ' ');

     RETURN v_SortCode;
   END; -- WrtGetSortCode

   --Получить признаки необходимости начисления ПДД
   PROCEDURE GetIncomeGroups(p_G1 IN NUMBER, p_G2 IN NUMBER, p_G3 IN NUMBER, p_G4 IN NUMBER, p_G5 IN NUMBER, p_CI1 OUT NUMBER, p_CI2 OUT NUMBER, p_CI3 OUT NUMBER, p_CI4 OUT NUMBER, p_CI5 OUT NUMBER)
   AS
   BEGIN

     p_CI1 := -1;
     p_CI2 := -1;
     p_CI3 := -1;
     p_CI4 := -1;
     p_CI5 := -1;

     IF p_G1 = KINDPORT_TRADE OR p_G1 = KINDPORT_SALE OR p_G1 = KINDPORT_RETIRE THEN
       p_CI1 := 1;
     END IF;

     IF p_G2 = KINDPORT_TRADE OR p_G2 = KINDPORT_SALE OR p_G2 = KINDPORT_RETIRE THEN
       p_CI2 := 1;
     END IF;

     IF p_G3 = KINDPORT_TRADE OR p_G3 = KINDPORT_SALE OR p_G3 = KINDPORT_RETIRE THEN
       p_CI3 := 1;
     END IF;

     IF p_G4 = KINDPORT_TRADE OR p_G4 = KINDPORT_SALE OR p_G4 = KINDPORT_RETIRE THEN
       p_CI4 := 1;
     END IF;

     IF p_G5 = KINDPORT_TRADE OR p_G5 = KINDPORT_SALE OR p_G5 = KINDPORT_RETIRE THEN
       p_CI5 := 1;
     END IF;

   END;


   -- восстановим условия сделки по данным в записи истории изменений
   PROCEDURE RSI_FillFromSPTKCHNG( p_tkch IN dsptkchng_dbt%ROWTYPE,
                                   p_Tick IN OUT ddl_tick_dbt%ROWTYPE,
                                   p_Leg  IN OUT ddl_leg_dbt%ROWTYPE,
                                   p_Leg2 IN OUT ddl_leg_dbt%ROWTYPE
                                 )
   AS
   BEGIN
      IF( p_Tick.t_DealID IS NOT NULL ) THEN
         p_Tick.t_Instance            := p_tkch.t_OldInstance;
         p_Tick.t_ChangeDate          := p_tkch.t_OldChangeDate;
         p_Tick.t_ChangeKind          := p_tkch.t_OldChangeKind;
         p_Tick.t_FixSum              := p_tkch.t_OldFixSum;
         p_Tick.t_PartyID             := p_tkch.t_OldPartyID;
         p_Tick.t_PreOutlay           := p_tkch.t_OldPreOutlay;
         p_Tick.t_DealTime            := p_tkch.t_OldDealTime;
         p_Tick.t_Flag3               := p_tkch.t_Flag3;
         p_Tick.t_PreOutlayFIID       := p_tkch.t_OldPreOutlayFIID;
         p_Tick.t_Flag5               := p_tkch.t_OldFlag5;
         p_Tick.t_ReturnIncomeKind    := p_tkch.t_OldReturnIncomeKind;
         p_Tick.t_PortfolioID         := p_tkch.t_OldPortfolio;
      END IF;

      IF( p_Leg.t_ID IS NOT NULL ) THEN
         p_Leg.t_CFI                  := p_tkch.t_OldCFI1;
         p_Leg.t_Price                := p_tkch.t_OldPrice1;
         p_Leg.t_Point                := p_tkch.t_OldPoint1;
         p_Leg.t_IncomeRate           := p_tkch.t_OldIncomeRate;
         p_Leg.t_Cost                 := p_tkch.t_OldCost1;
         p_Leg.t_TotalCost            := p_tkch.t_OldTotalCost1;
         p_Leg.t_NKD                  := p_tkch.t_OldNKD1;
         p_Leg.t_PFI                  := p_tkch.t_OldPFI1;
         p_Leg.t_Principal            := p_tkch.t_OldPrincipal;
         p_Leg.t_Formula              := p_tkch.t_OldFormula1;
         p_Leg.t_Start                := p_tkch.t_OldStart1;
         p_Leg.t_Maturity             := p_tkch.t_OldMaturity1;
         p_Leg.t_Expiry               := p_tkch.t_OldExpiry1;
         p_Leg.t_MaturityIsPrincipal  := p_tkch.t_OldMaturityIsPrincipal1;
         p_Leg.t_PayRegTax            := p_tkch.t_OldPayRegTax1;
         p_Leg.t_Registrar            := p_tkch.t_OldRegistrar1;
         p_Leg.t_Basis                := p_tkch.t_OldBasis;
         p_Leg.t_RejectDate           := p_tkch.t_OldRejectDate1;
         p_Leg.t_ReturnIncome         := p_tkch.t_OldReturnIncome;
         p_Leg.t_DeliveringFIID       := p_tkch.t_OldDeliveringFIID;
         p_Leg.t_StartDiff            := p_tkch.t_OldStartDiff1;
         p_Leg.t_PrincipalDiff        := p_tkch.t_OldPrincipalDiff1;
         p_Leg.t_Diff                 := p_tkch.t_OldDiff1;
      END IF;

      IF( p_Leg2.t_ID IS NOT NULL ) THEN
         p_Leg2.t_CFI                 := p_tkch.t_OldCFI2;
         p_Leg2.t_Price               := p_tkch.t_OldPrice2;
         p_Leg2.t_Point               := p_tkch.t_OldPoint2;
         p_Leg2.t_IncomeRate          := p_tkch.t_OldIncomeRate;
         p_Leg2.t_Cost                := p_tkch.t_OldCost2;
         p_Leg2.t_TotalCost           := p_tkch.t_OldTotalCost2;
         p_Leg2.t_NKD                 := p_tkch.t_OldNKD2;
         p_Leg2.t_PFI                 := p_tkch.t_OldPFI2;
         p_Leg2.t_Principal           := p_tkch.t_OldPrincipal2;
         p_Leg2.t_Formula             := p_tkch.t_OldFormula2;
         p_Leg2.t_Start               := p_tkch.t_OldStart2;
         p_Leg2.t_Maturity            := p_tkch.t_OldMaturity2;
         p_Leg2.t_Expiry              := p_tkch.t_OldExpiry2;
         p_Leg2.t_MaturityIsPrincipal := p_tkch.t_OldMaturityIsPrincipal2;
         p_Leg2.t_PayRegTax           := p_tkch.t_OldPayRegTax2;
         p_Leg2.t_Registrar           := p_tkch.t_OldRegistrar2;
         p_Leg2.t_RejectDate          := p_tkch.t_OldRejectDate2;
         p_Leg2.t_ReturnIncome        := p_tkch.t_OldReturnIncome;
         p_Leg2.t_StartDiff           := p_tkch.t_OldStartDiff2;
         p_Leg2.t_PrincipalDiff       := p_tkch.t_OldPrincipalDiff2;
         p_Leg2.t_Diff                := p_tkch.t_OldDiff2;
      END IF;
   END;

   PROCEDURE RSI_LoadCurDealData( p_GrDealID IN NUMBER,
                                  p_Tick IN OUT ddl_tick_dbt%ROWTYPE,
                                  p_Leg  IN OUT ddl_leg_dbt%ROWTYPE,
                                  p_Leg2 IN OUT ddl_leg_dbt%ROWTYPE
                                )
   AS
   BEGIN
      IF( p_Tick.t_DealID IS NOT NULL ) THEN
         BEGIN
           SELECT tick.* INTO p_Tick
             FROM ddl_tick_dbt tick, ddlgrdeal_dbt grdeal
            WHERE grdeal.t_ID   = p_GrDealID
              AND tick.t_DealID = grdeal.t_DocID;
         EXCEPTION
            WHEN OTHERS THEN NULL; -- добавить ошибку
         END;
      END IF;

      IF( p_Leg.t_ID IS NOT NULL ) THEN
         BEGIN
           SELECT leg.* INTO p_Leg
             FROM ddl_leg_dbt leg, ddlgrdeal_dbt grdeal
            WHERE grdeal.t_ID   = p_GrDealID
              AND leg.t_DealID  = grdeal.t_DocID
              AND leg.t_LegKind = 0
              AND leg.t_LegID   = 0;
         EXCEPTION
            WHEN OTHERS THEN NULL; -- добавить ошибку
         END;
      END IF;

      IF( p_Leg2.t_ID IS NOT NULL ) THEN
         BEGIN
           SELECT leg.* INTO p_Leg2
             FROM ddl_leg_dbt leg, ddlgrdeal_dbt grdeal
            WHERE grdeal.t_ID   = p_GrDealID
              AND leg.t_DealID  = grdeal.t_DocID
              AND leg.t_LegKind = 2
              AND leg.t_LegID   = 0;
         EXCEPTION
            WHEN OTHERS THEN NULL; -- добавить ошибку, если должна быть вторая часть
         END;
      END IF;
   END;

   PROCEDURE RSI_LoadNewDealData( p_GrDealID IN NUMBER,
                                  p_Instance IN NUMBER,
                                  p_Tick IN OUT ddl_tick_dbt%ROWTYPE,
                                  p_Leg  IN OUT ddl_leg_dbt%ROWTYPE,
                                  p_Leg2 IN OUT ddl_leg_dbt%ROWTYPE
                                )
   AS
      v_tkch dsptkchng_dbt%ROWTYPE;
   BEGIN
      BEGIN
        SELECT ch.* INTO v_tkch
          FROM dsptkchng_dbt ch, ddlgrdeal_dbt grdeal
         WHERE grdeal.t_ID      = p_GrDealID
           AND ch.t_DealID      = grdeal.t_DocID
           AND ch.t_OldInstance = (p_Instance + 1);
      EXCEPTION
         WHEN OTHERS THEN v_tkch.t_ID := 0;
      END;

      IF( v_tkch.t_ID > 0 ) THEN
         RSI_FillFromSPTKCHNG(v_tkch, p_Tick, p_Leg, p_Leg2);
      END IF;
   END;

   -- загрузить состояния ДО и ПОСЛЕ изменения
   PROCEDURE RSI_LoadSpTkChangeData( p_GrDealID IN NUMBER,
                                     p_TickOld IN OUT ddl_tick_dbt%ROWTYPE,
                                     p_LegOld  IN OUT ddl_leg_dbt%ROWTYPE,
                                     p_Leg2Old IN OUT ddl_leg_dbt%ROWTYPE,
                                     p_TickNew IN OUT ddl_tick_dbt%ROWTYPE,
                                     p_LegNew  IN OUT ddl_leg_dbt%ROWTYPE,
                                     p_Leg2New IN OUT ddl_leg_dbt%ROWTYPE
                                   )
   AS
      v_tkch dsptkchng_dbt%ROWTYPE;
   BEGIN
      -- загрузим текущее состояние, а потом накатим из истории
      RSI_LoadCurDealData(p_GrDealID, p_TickOld, p_LegOld, p_Leg2Old);
      RSI_LoadCurDealData(p_GrDealID, p_TickNew, p_LegNew, p_Leg2New);

      BEGIN
        SELECT ch.* INTO v_tkch
          FROM dsptkchng_dbt ch, ddlgracc_dbt gracc, ddlgrdeal_dbt grdeal
         WHERE gracc.t_GrDealID  = p_GrDealID
           AND gracc.t_AccNum    = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE
           AND grdeal.t_ID       = p_GrDealID
           AND ch.t_ID_Operation = gracc.t_ID_Operation
           AND ch.t_ID_Step      = gracc.t_ID_Step
           AND ch.t_DealID       = grdeal.t_DocID
         ORDER BY ch.t_OldInstance DESC;
      EXCEPTION
         WHEN OTHERS THEN v_tkch.t_ID := 0;
      END;

      IF( v_tkch.t_ID > 0 ) THEN
         RSI_FillFromSPTKCHNG(v_tkch, p_TickOld, p_LegOld, p_Leg2Old);
         RSI_LoadNewDealData(p_GrDealID, v_tkch.t_OldInstance, p_TickNew, p_LegNew, p_Leg2New);
      END IF;
   END;

   -- Выполняет списание лота продажи в сделке с 1 частью
   PROCEDURE RSI_WRTLinkSaleLot( p_S          IN OUT DPMWRTSUM_DBT%ROWTYPE, -- буфер лота продажи
                                 p_DocumentID IN NUMBER,                -- операция БУ (передать DL_COMM.T_DocumentID)
                                 p_GrpID      IN NUMBER,                -- группа обработки
                                 p_UseContr   IN NUMBER
                               )
   IS
     v_G1              NUMBER;
     v_G2              NUMBER;
     v_G3              NUMBER;
     v_G4              NUMBER;
     v_G5              NUMBER;
     v_CI1             NUMBER;
     v_CI2             NUMBER;
     v_CI3             NUMBER;
     v_CI4             NUMBER;
     v_CI5             NUMBER;
     v_LinkToParent    NUMBER;
     v_RetBD           NUMBER;
     v_Portfolio       NUMBER;
     v_BOfficeKind     NUMBER;
     v_OGroup          NUMBER;
     v_SalePartyClient NUMBER;
   BEGIN

      BEGIN
        SELECT TK.T_PORTFOLIOID, TK.T_BOFFICEKIND, RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)),
               (CASE WHEN TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = p_S.T_PARTY AND TK.T_PARTYCONTRID = p_S.T_CONTRACT THEN 1 ELSE 0 END)
          INTO v_Portfolio, v_BOfficeKind, v_OGroup, v_SalePartyClient
          FROM DDLRQ_DBT RQ, DDL_TICK_DBT TK
         WHERE RQ.T_ID          = p_S.T_DOCID
           AND TK.T_DEALID      = RQ.T_DOCID
           AND TK.T_BOFFICEKIND = RQ.T_DOCKIND;
      EXCEPTION
         WHEN OTHERS THEN NULL; -- добавить ошибку
      END;

      --Для собственных сделок с клиентом-контрагентом портфель будет ПВО, а нам при обработке клиента-контрагента нужен клиентский
      IF p_S.t_Party <> UnknownParty THEN
        v_Portfolio := KINDPORT_CLIENT;
      END IF;

      IF (( p_S.T_KIND in(WRTSUM_KIND_RRWAS2, WRTSUM_KIND_LCS) ) and (p_S.t_Party = -1)) THEN

         v_G1 := -1; v_G2 := -1; v_G3 :=  -1; v_G4 :=  -1; v_G5 :=  -1;
         v_CI1 := -1; v_CI2 := -1; v_CI3 := -1; v_CI4 := -1; v_CI5 := -1;

         v_LinkToParent := 1;
         v_RetBD := 0;

         RSI_WRTLinkSale( p_S.t_SumID,
                          v_G1,
                          v_G2,
                          v_G3,
                          v_G4,
                          v_G5,
                          v_CI1,
                          v_CI2,
                          v_CI3,
                          v_CI4,
                          v_CI5,
                          v_LinkToParent,
                          0,
                          v_RetBD,
                          NULL,
                          p_DocumentID,
                          -1,
                          p_GrpID
                        );

         -- возьмём актуальные данные после RSI_WRTLinkSale
         BEGIN
           SELECT * INTO p_S
             FROM DPMWRTSUM_DBT
            WHERE t_SumID = p_S.t_SumID;
         EXCEPTION
           WHEN OTHERS THEN
             SetError(WRTOFF_ERROR_20200);
         END;

      END IF;

      IF( p_S.t_Amount > 0 ) THEN

         v_G1 := -1; v_G2 := -1; v_G3 :=  -1; v_G4 :=  -1; v_G5 :=  -1;
         v_CI1 := -1; v_CI2 := -1; v_CI3 := -1; v_CI4 := -1; v_CI5 := -1;

         GetWriteOffGroups(v_BOfficeKind, p_S.t_Kind, v_Portfolio, RSB_SECUR.IsTwoPart(v_OGroup), RSB_SECUR.IsSale(v_OGroup), RSI_RSB_FIInstr.FI_IsKSU(p_S.t_FIID), p_UseContr, v_G1, v_G2, v_G3, v_G4, v_G5);

         IF (( p_S.t_Kind != WRTSUM_KIND_RRWAS1 ) and (p_S.t_Party = -1)) THEN
            GetIncomeGroups(v_G1, v_G2, v_G3, v_G4, v_G5, v_CI1, v_CI2, v_CI3, v_CI4, v_CI5);
         END IF;

         v_LinkToParent := 0;
         v_RetBD := 0;
         IF( RSB_SECUR.IsTwoPart(v_OGroup) = 1 ) THEN
            IF( ((v_SalePartyClient = 0 AND RSB_SECUR.IsBuy(v_OGroup) = 1) OR (v_SalePartyClient = 1 AND RSB_SECUR.IsSale(v_OGroup) = 1)) AND p_S.t_Parent > 0 ) THEN
               v_LinkToParent := 1;
            END IF;

            v_RetBD := 1;
         END IF;

         RSI_WRTLinkSale( p_S.t_SumID,
                          v_G1,
                          v_G2,
                          v_G3,
                          v_G4,
                          v_G5,
                          v_CI1,
                          v_CI2,
                          v_CI3,
                          v_CI4,
                          v_CI5,
                          v_LinkToParent,
                          0,
                          v_RetBD,
                          NULL,
                          p_DocumentID,
                          -1,
                          p_GrpID
                        );

         IF( p_S.t_Kind in(WRTSUM_KIND_RRWAS1, WRTSUM_KIND_LPS) ) THEN
            FOR one_rq2 IN (SELECT RQ2.T_ID RQID2
                              FROM DDLRQ_DBT RQ2
                             WHERE RQ2.T_DOCKIND  = 101
                               AND RQ2.T_DOCID    = p_S.t_DealID
                               AND RQ2.T_TYPE     = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                               AND RQ2.T_FIID     = p_S.t_FIID
                               AND RQ2.T_DEALPART = 2
                           )
            LOOP
              if (p_S.t_Party = -1) then
                RSI_WRTCreateLotsFromLink(p_S.t_SumID, one_rq2.RQID2, 0);
              else
                RSI_WRTCreateLotsFromLink(p_S.t_SumID, one_rq2.RQID2, 2);
              end if;
            END LOOP;
         END IF;
      END IF;

   END RSI_WRTLinkSaleLot;

   --Выполняет квитовку лотов в сервисной операции БУ
   PROCEDURE WRTLinkOurLotsByFI( p_DocumentID IN NUMBER,
                                 p_OperDate IN DATE,
                                 p_GrpID IN NUMBER,
                                 p_UseContr IN NUMBER,
                                 p_FIID IN NUMBER
                               )
   AS
     v_Date DATE;
     v_Department NUMBER;
     v_Lot     DPMWRTSUM_DBT%ROWTYPE;
     v_Lot2    DPMWRTSUM_DBT%ROWTYPE;
     v_Lot2New DPMWRTSUM_DBT%ROWTYPE;
     v_Sale1   DPMWRTSUM_DBT%ROWTYPE;
     v_Sale2   DPMWRTSUM_DBT%ROWTYPE;
     v_Buy     DPMWRTSUM_DBT%ROWTYPE;
     v_SaleLot DPMWRTSUM_DBT%ROWTYPE;
     v_Buy2    DPMWRTSUM_DBT%ROWTYPE;
     v_SourceLot DPMWRTSUM_DBT%ROWTYPE;
     v_G1 NUMBER;
     v_G2 NUMBER;
     v_G3 NUMBER;
     v_G4 NUMBER;
     v_G5 NUMBER;
     v_CI1 NUMBER;
     v_CI2 NUMBER;
     v_CI3 NUMBER;
     v_CI4 NUMBER;
     v_CI5 NUMBER;
     v_LinkToParent NUMBER;
     v_RetBD NUMBER;
     v_Sum       NUMBER;
     v_Cost      NUMBER;
     v_NKDAmount NUMBER;
     v_Portfolio NUMBER;
     v_GroupID   NUMBER;
     v_BegDiscount NUMBER;
     v_BegBonus    NUMBER;
     v_FaceValueFI NUMBER;
     v_ExistNOSS NUMBER;
     v_NeedChargeInterestIncome NUMBER;
     v_NeedChargeIncome NUMBER;
     v_IsOneDayREPO  NUMBER;
     v_NKD_          NUMBER;
     v_AvoirKind     NUMBER;
     v_NKDRound_Kind NUMBER;
     v_Amount        NUMBER;
     v_AmountBD      NUMBER;
     v_BalanceCostBD NUMBER;
     v_OverAmountBD  NUMBER;
     v_Old           NUMBER;
     v_RAmount       NUMBER;
     v_Nominal       NUMBER;
     v_SAmount       NUMBER;
     v_Rate          NUMBER;
     v_Val           NUMBER;
     v_IsWorkDay     NUMBER;
     v_Count         NUMBER;
     v_CheckDate     DATE;
     v_FIPKU         NUMBER;
     v_SumAmount      NUMBER;
     v_RestAmount     NUMBER;
     v_BalanceCost    NUMBER;
     v_LotRepo2       NUMBER;
     v_IsLnkTmp       NUMBER;
     v_OldAmount      NUMBER;
     v_NewAmount      NUMBER;
     v_RepoAmount     NUMBER;
     v_RestRepoAmount NUMBER;
     v_Lot2Amount     NUMBER;
     v_RestLot2Amount NUMBER;
     v_MaxPartNum NUMBER;
     v_Break      BOOLEAN;
     v_TMPLNKID   NUMBER;
     SumTP        NUMBER;
     NkdTP        NUMBER;
     BonusTP      NUMBER;
     NotWrtBonusTP NUMBER;
     SumPPR       NUMBER;
     NkdPPR       NUMBER;
     BonusPPR     NUMBER;
     NotWrtBonusPPR NUMBER;
     SumPUDP      NUMBER;
     NkdPUDP      NUMBER;
     BonusPUDP    NUMBER;
     NotWrtBonusPUDP NUMBER;
     SumOD        NUMBER;
     NkdOD        NUMBER;
     SumPKU       NUMBER;
     SumPVO_KSU   NUMBER;
     v_AmountNotBD NUMBER;
     v_RQ2         DDLRQ_DBT%ROWTYPE;
     v_Amount0    NUMBER;
     v_SaleRepoAmount NUMBER;
     v_AmountPVO  NUMBER;
     v_AmountPLUSOD NUMBER;
     v_AmountPVOBPP NUMBER;
     v_Leg1       DDL_LEG_DBT%ROWTYPE;
     v_FairValue     NUMBER;
     v_FairValueRub  NUMBER;
     v_FVCourseType  NUMBER := Rsb_Common.GetRegIntValue('SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ', 0);
     v_SignDeviation BOOLEAN;
     v_RateKind      NUMBER;
     v_RateVal       NUMBER;
     v_DeltaRub      NUMBER;
     v_CostRub       NUMBER;
     v_AmortCalcKind NUMBER := 0;
     v_DrawingDate   DATE;
     v_AmortCost     NUMBER := 0;
     v_ToCompare     NUMBER := 0;
     v_Msg           VARCHAR2(256);
     v_Cat55         NUMBER := 0;
     v_Cat60         NUMBER := 0;
     v_AlgUsed       NUMBER;
     v_EIR           NUMBER;
     v_ACK           NUMBER;
     v_RateID        NUMBER;
     v_Sum0          NUMBER;
     v_CurFIisBond   BOOLEAN;
     v_OverTPlus     NUMBER:= 0;
     v_OperType       NUMBER:= 0;
     v_Kind_Operation NUMBER:= 0;
     v_ExistOverTPlus NUMBER:= 0;
     v_ExistsBuy     BOOLEAN := FALSE;
     v_ExistsRetire  BOOLEAN := FALSE;
     v_Cnt           NUMBER := 0;
     v_Termless      CHAR; -- признак бессрочной ц/б
     v_Party         NUMBER;
     v_Contract      NUMBER;
     v_DetermineAccFI NUMBER;
     v_AvoirAttrObsBaseData NUMBER; 
     v_AmortizationMethod NUMBER;
     v_TestAttrID    NUMBER;
     v_CheckTime     NUMBER;
     v_FloatingRate  davoiriss_dbt.t_FloatingRate%type;
   BEGIN

     InitContextDeal;
     InitContextFIID;

     -- 1. Найти FIID, Department из pmwrtgrp где t_ID == GrpID
     SELECT T_DEPARTMENT, T_PARTY, T_CONTRACT INTO v_Department, v_Party, v_Contract
       FROM DPMWRTGRP_DBT
      WHERE T_ID = p_GrpID;

     SELECT FIN.T_FACEVALUEFI, FIN.t_AvoirKind, AVOIR.t_NKDRound_Kind, AVOIR.t_Termless, AVOIR.t_FloatingRate
       INTO v_FaceValueFI, v_AvoirKind, v_NKDRound_Kind, v_Termless, v_FloatingRate
       FROM DFININSTR_DBT FIN, DAVOIRISS_DBT AVOIR
      WHERE FIN.T_FIID = p_FIID
        AND AVOIR.T_FIID = FIN.T_FIID;

     SELECT t_ContractKind, t_OperSubKind INTO v_OperType, v_Kind_Operation
       FROM DDL_COMM_DBT
      WHERE t_DocumentID = p_DocumentID;

     IF( v_AvoirKind = RSI_RSB_FIInstr.AVOIRISSKIND_BASKET ) THEN
        return;
     END IF;

     v_CurFIisBond := RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind);
     
     IF (v_CurFIisBond = TRUE AND v_Termless = 'X' AND RSI_RSB_FIInstr.FI_GetNominalDrawingDate(p_FIID, v_Termless) = UnknownDate) THEN
        SetError( WRTOFF_ERROR_20269, to_char(p_FIID) ); --Отсутствует дата погашения ц/б с FIID %s, дата известного купона меньше даты расчета
     END IF;

     IF (v_Party = UnknownParty) THEN  
         v_NeedChargeInterestIncome := WRTNeedChargeInterestIncome(p_FIID); --Облигации, имеющие купоны, или в анкете которых задан доход
         v_NeedChargeIncome         := WRTNeedChargeIncome(p_FIID); --Облигация
         v_DetermineAccFI           := WRTDetermineAccFI(p_FIID);
         v_AvoirAttrObsBaseData     := RSI_AvoirAttrObsBaseData(p_FIID);
     END IF;    

     v_AmortizationMethod := GetAmortizationMethod(v_Party, v_Contract);

     -- 2.  V_Date
     SELECT NVL(MIN(GRDEAl.T_PLANDATE), TO_DATE('01.01.0001','DD.MM.YYYY')) INTO v_Date
       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL
      WHERE S.T_GRPID     = p_GrpID
        AND S.T_TYPE      = 1
        AND SD.T_SUBGRPID = S.T_SUBGRPID
        AND GRDEAL.T_ID   = SD.T_GRDEALID
        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECURITYDOC, RSB_SECUR.DL_RETIREMENT, RSB_SECUR.DL_AVRWRT)
        AND GRDEAL.T_PLANDATE <= p_OperDate
        AND GRDEAL.T_FIID      = p_FIID
        AND TK.T_DEALID        = GRDEAL.T_DOCID
        AND TK.T_DEPARTMENT    = v_Department
        AND ((GRDEAL.T_TEMPLNUM IN (RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLGR.DLGR_TEMPL_DELIVERY2, RSI_DLGR.DLGR_TEMPL_COMPDELIVERY)
              AND TK.T_CLIENTID      = v_Party
              AND TK.T_CLIENTCONTRID = v_Contract
             ) OR
             (GRDEAL.T_TEMPLNUM IN (RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2, RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR)
              AND TK.T_ISPARTYCLIENT = 'X'
              AND TK.T_PARTYID       = v_Party
              AND TK.T_PARTYCONTRID  = v_Contract
             )
            )
        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
        AND (v_OperType = 0 OR 
             v_Kind_Operation != 0 OR 
             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                       ELSE 0 END)
            )
        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN)
        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC);

     -- 3. Если v_Date < OperDate и v_Date != нач. дата
     IF v_Date < p_OperDate AND v_Date <> TO_DATE('01.01.0001','DD.MM.YYYY') THEN
       SetError( WRTOFF_ERROR_20247 ); --Необходимо выполнить сервисные операции БУ за более ранние даты
     END IF;

     IF v_Date = TO_DATE('01.01.0001','DD.MM.YYYY') THEN
       return;
     END IF;

     -- 4.1.  Обработать погашения за дату.
     FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            NVL(RQ.T_ID, 0) RQID,
                            LEG.T_COST Cost, LEG.T_CFI CFI, LEG.T_PRINCIPAL Principal, LEG.T_NKD NKD, LEG.T_PFI FIID,
                            TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALTIME DealTime, TK.T_NUMBER_COUPON Number_Coupon,
                            TK.T_NUMBER_PARTLY Number_Partly, TK.T_DEALCODE DealCode, TK.T_ISPFI ISPFI
                       FROM  DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL, DDL_LEG_DBT LEG
                      WHERE S.T_GRPID = p_GrpID
                        AND S.T_TYPE = 1
                        AND SD.T_SUBGRPID = S.T_SUBGRPID
                        AND GRDEAL.T_ID = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND = RSB_SECUR.DL_RETIREMENT --Погашение
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID = p_FIID
                        AND TK.T_DEALID = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID = v_Party
                        AND TK.T_CLIENTCONTRID = v_Contract
                        AND TK.T_DEPARTMENT = v_Department
                        AND TK.T_PFI = GRDEAL.T_FIID
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND = 0
                        AND LEG.T_DEALID = TK.T_DEALID
                        AND LEG.T_LEGID = 0
                        AND RQ.T_DOCKIND(+) = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID(+) = TK.T_DEALID
                        AND RQ.T_STATE(+) = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND(+) = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_FIID(+) = TK.T_PFI
                        AND RQ.T_TYPE(+) = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                    )
     LOOP

       SetContextDeal(one_prm.DealID);
       SetContextFIID(p_FIID);

       v_ExistsRetire := TRUE;

       v_Lot := NULL;

       v_Lot.T_SUMID            := 0;

       v_Lot.T_COUPON  := one_prm.Number_Coupon;
       v_Lot.T_PARTLY  := one_prm.Number_Partly;

       IF RSB_SECUR.IsRet_Issue(one_prm.OGroup) = 1 THEN --Погашение
         v_Lot.T_DOCKIND          := 29; /*DLDOC_PAYMENT*/
         v_Lot.T_DOCID            := one_prm.RQID;
         v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
         v_Lot.T_KIND             := WRTSUM_KIND_DI; --Погашение выпуска

         IF v_Party > 0 THEN
           v_Amount              := WRTGetPortfolioAmount(v_Department,one_prm.FIID,v_Party,v_Contract,NULL,NULL,one_prm.DealDate,1,0,0);
                                           
           if( one_prm.Number_Coupon <> chr(1) or one_prm.Number_Partly <> chr(1) )then
             v_Amount            := v_Amount - WRTGetAmountFromRetire(v_Department,one_prm.FIID,v_Party,v_Contract, one_prm.Number_Coupon,one_prm.Number_Partly, one_prm.DealID);
           end if;                                 
         ELSE

           if( one_prm.Number_Coupon <> chr(1) or one_prm.Number_Partly <> chr(1) )then
              v_Amount            := WRTGetWrtAmount(v_Department,one_prm.FIID,v_Party,v_Contract,one_prm.Number_Coupon,one_prm.Number_Partly,one_prm.DealDate,null,one_prm.DealID);
           else
              v_Amount            := WRTGetPortfolioAmount(v_Department,one_prm.FIID,v_Party,v_Contract,-1,-1,one_prm.DealDate,1,0,0);
           end if;
         END IF;

         v_Lot.T_SUM              := one_prm.Cost*v_Amount/one_prm.Principal;

       ELSE --Погашение купона/ЧП
         v_Lot.T_DOCKIND          := one_prm.BOfficeKind;
         v_Lot.T_DOCID            := one_prm.DealID;
         v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_COUPON; --Погашение купонов/частичное

         IF RSB_SECUR.IsRet_Coupon(one_prm.OGroup) = 1 THEN --Погашение купона
           v_Lot.T_KIND           := WRTSUM_KIND_DC;
         ELSE --Погашение ЧП
           v_Lot.T_KIND           := WRTSUM_KIND_DP;
         END IF;

         IF v_Party > 0 THEN
           v_Amount              := WRTGetPortfolioAmount(v_Department,one_prm.FIID,v_Party,v_Contract,NULL,NULL,one_prm.DealDate,1,0,0) -
                                    WRTGetAmountFromRetire(v_Department,one_prm.FIID,v_Party,v_Contract, one_prm.Number_Coupon,one_prm.Number_Partly, one_prm.DealID);
         ELSE
           v_Amount              := WRTGetWrtAmount(v_Department,one_prm.FIID,v_Party,v_Contract,one_prm.Number_Coupon,one_prm.Number_Partly,one_prm.DealDate,null,one_prm.DealID);
         END IF;

         v_Lot.T_SUM             := one_prm.Cost*v_Amount/one_prm.Principal;

       END IF;

       v_Lot.T_FIID             := one_prm.FIID;
       v_Lot.T_PARTNUM          := 0;
       v_Lot.T_PARTY            := v_Party;
       v_Lot.t_Contract         := v_Contract;
       v_Lot.T_DATE             := one_prm.DealDate;
       v_Lot.T_AMOUNT           := v_Amount;
       v_Lot.T_CURRENCY         := one_prm.CFI;
       v_Lot.T_COST             := v_Lot.T_SUM;

       v_Lot.T_NKDAMOUNT   := 0;
       IF v_Lot.T_COUPON <> CHR(1) THEN
         v_Lot.T_NKDAMOUNT := one_prm.NKD*v_Amount/one_prm.Principal;
       END IF;

       v_Lot.T_BALANCECOST      := v_Lot.T_SUM + v_Lot.T_NKDAMOUNT;
       v_Lot.T_DEPARTMENT       := v_Department;
       v_Lot.T_DEALID           := one_prm.DealID;
       v_Lot.T_DEALDATE         := one_prm.DealDate;
       v_Lot.T_TIME             := one_prm.DealTime;
       v_Lot.T_DEALCODE         := one_prm.DealCode;
       v_Lot.T_STATE            := PM_WRTSUM_FORM;
       v_Lot.T_ENTERDATE        := one_prm.DealDate;
       v_Lot.T_STATEDATE        := one_prm.DealDate;
       v_Lot.T_INSTANCE         := 0;
       v_Lot.T_CHANGEDATE       := one_prm.DealDate;
       v_Lot.T_ACTION           := PM_WRT_UPDTMODE_DELIVERY;
       v_Lot.T_ID_OPERATION     := p_DocumentID;
       v_Lot.T_ID_STEP          := -1;
       v_Lot.T_TRUST            := CHR(0);
       v_Lot.T_ACTIVATEDATE     := one_prm.DealDate;
       v_Lot.T_ACTIVATETIME     := UnknownTime;
       v_Lot.T_BLOCKAMOUNT      := 0;
       v_Lot.T_ACCFI            := v_DetermineAccFI;
       v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

       RSI_InsDfltIntoWRTSUM(v_Lot);
       INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;


     END LOOP;

     -- 4.2.  Запуск списания в погашении ц/б и доначислений при погашении купона/ЧП
     FOR one_wrt IN (SELECT /*+ INDEX( S DPMWRTSUM_DBT_IDXC)*/ S.T_KIND Kind, S.T_SUMID SumID, S.T_DEALID DealID, S.T_FIID FIID
                       FROM DPMWRTSUM_DBT S, DDL_TICK_DBT TK
                      WHERE S.T_AMOUNT > 0
                        AND S.T_PARTY = v_Party
                        AND S.T_CONTRACT = v_Contract
                        AND S.T_DATE <= v_Date -- если погашение купона выходной, а СОБУ планируется на ближайший рабочий 
                        AND S.T_FIID = p_FIID
                        AND S.T_DEPARTMENT = v_Department
                        AND (S.T_BUY_SALE = PM_WRITEOFF_SUM_COUPON OR (S.T_BUY_SALE = PM_WRITEOFF_SUM_SALE AND S.T_KIND = WRTSUM_KIND_DI))
                        AND TK.T_DEALID = S.T_DEALID
                        AND TK.T_BOFFICEKIND = RSB_SECUR.DL_RETIREMENT --Погашение
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                      ORDER BY S.T_DATE, S.T_TIME, S.T_DEALDATE, S.T_SORTCODE
                    )
     LOOP
       SetContextDeal( one_wrt.DealID );
       SetContextFIID(p_FIID);

       v_Portfolio := KINDPORT_UNDEF;
       IF v_Party > 0 THEN
         v_Portfolio := KINDPORT_CLIENT;
       END IF;

       GetWriteOffGroups(RSB_SECUR.DL_RETIREMENT, one_wrt.Kind, v_Portfolio, 0, 0, RSI_RSB_FIInstr.FI_IsKSU(one_wrt.FIID), p_UseContr, v_G1, v_G2, v_G3, v_G4, v_G5);

       if v_Party = -1 then
         GetIncomeGroups(v_G1, v_G2, v_G3, v_G4, v_G5, v_CI1, v_CI2, v_CI3, v_CI4, v_CI5);
       end if;

       RSI_WRTLinkSale( one_wrt.SumID,
                        v_G1,
                        v_G2,
                        v_G3,
                        v_G4,
                        v_G5,
                        v_CI1,
                        v_CI2,
                        v_CI3,
                        v_CI4,
                        v_CI5,
                        0,
                        0,
                        0,
                        NULL,
                        p_DocumentID,
                        -1,
                        p_GrpID
                      );
     END LOOP;

     -- 4.3. Обработать покупки/зачисления/1ч обратного РЕПО/1ч привлечения займа за дату
     FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            RQ.T_ID RQID, RQ.T_FIID FIID, RQ.T_AMOUNT Amount, RQ.T_FACTDATE FactDate, RQ.T_PLANDATE PlanDate,
                            LEG.T_COST Cost, LEG.T_TOTALCOST TotalCost, LEG.T_CFI CFI, LEG.T_NKD NKD, LEG.T_NKDFIID NKDFIID, LEG.t_CliringChange CliringChange, LEG.T_SUPPLYTIME SupplyTime,
                            LEG.T_START StartDate, LEG.T_INTERESTSTART InterestStart, LEG.T_ID LegRecID,
                            TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALTIME DealTime, TK.T_NUMBER_COUPON Number_Coupon,
                            TK.T_NUMBER_PARTLY Number_Partly, TK.T_DEALCODE DealCode, TK.T_PORTFOLIOID PortfolioID,
                            TK.T_PREOUTLAY PreOutlay, TK.T_PREOUTLAYFIID PreOutlayFIID,
                            GRDEAL.T_TEMPLNUM,
                            NVL(RQP.T_AMOUNT,0) PayAmount, NVL(RQP.T_FIID, -1) RqpFIID, TK.T_ISPFI ISPFI, TK.T_COMMDATE
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDLRQ_DBT RQP, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID 
                        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECURITYDOC, RSB_SECUR.DL_AVRWRT)
                        AND GRDEAL.T_TEMPLNUM IN (RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR)
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID = p_FIID
                        AND TK.T_DEALID = GRDEAL.T_DOCID
                        AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN 1
                                      WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1
                                      ELSE 0 END)
                        AND TK.T_DEPARTMENT   = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND     = 0
                        AND LEG.T_DEALID      = TK.T_DEALID
                        AND LEG.T_LEGID       = 0
                        AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID        = TK.T_DEALID
                        AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_FIID         = GRDEAL.T_FIID
                        AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                        AND RQ.T_KIND         = DECODE(GRDEAL.T_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLRQ.DLRQ_KIND_REQUEST /*Требование*/, RSI_DLRQ.DLRQ_KIND_COMMIT /*Обязательство*/)
                        AND RQ.T_DEALPART     = 1
                        AND RQP.T_DOCKIND  (+)= RQ.T_DOCKIND
                        AND RQP.T_DOCID    (+)= RQ.T_DOCID
                        AND RQP.T_TYPE     (+)= RSI_DLRQ.DLRQ_TYPE_PAYMENT --Оплата
                        AND RQP.T_DEALPART (+)= RQ.T_DEALPART
                        AND EXISTS(SELECT 1
                                     FROM DDLGRACC_DBT GRACC
                                    WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                      AND GRACC.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                      AND GRACC.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                  )
                    )
     LOOP

        SetContextDeal(one_prm.DealID);
        SetContextFIID(p_FIID);

        v_Lot := NULL;

        v_ExistsBuy := TRUE;

        IF RSB_SECUR.IsTwoPart(one_prm.OGroup) = 1 THEN --РЕПО и займ (обрабатываем 1ч.)

          IF (one_prm.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY AND RSB_SECUR.IsBuy(one_prm.OGroup) = 1) OR --Обратное РЕПО, Привлечение займа для клиента
             (one_prm.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR AND RSB_SECUR.IsSale(one_prm.OGroup) = 1) THEN --Прямое РЕПО для клиента-контрагента

            SELECT *
              INTO v_Leg1
              FROM DDL_LEG_DBT
             WHERE T_ID = one_prm.LegRecID;

            v_Lot.T_SUMID            := 0;
            v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
            v_Lot.T_DOCID            := one_prm.RQID;
            v_Lot.T_PARTNUM          := 0;
            v_Lot.T_PARTY            := v_Party;
            v_Lot.T_CONTRACT         := v_Contract;
            v_Lot.T_FIID             := one_prm.FIID;

            IF v_Party > 0 THEN
              v_Lot.T_PORTFOLIO      := KINDPORT_CLIENT;
            ELSE
              IF RSI_RSB_FIInstr.FI_IsKSU(v_Lot.T_FIID) > 0 THEN
                v_Lot.T_PORTFOLIO      := KINDPORT_BACK_KSU;
              ELSE
                v_Lot.T_PORTFOLIO      := KINDPORT_BACK;
              END IF;
            END IF;

            v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);
            v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_BUY_BO; --Зачисление на ВО
            v_Lot.T_KIND             := WRTSUM_KIND_RRWAB1; --Зачисление в РЕПО обратно БПП
            v_Lot.T_DATE             := one_prm.FactDate;
            v_Lot.T_TIME             := one_prm.SupplyTime;

            IF( RSB_SECUR.IsBasket(one_prm.OGroup) = 1 ) THEN
               v_Lot.T_AMOUNT   := 0;
               v_Lot.T_SUM      := 0;
               v_Lot.T_CURRENCY := -1;
               v_NKD_ := 0;
               BEGIN
                  SELECT t_Principal, t_TotalCost, t_CostFIID, t_NKD
                    INTO v_Lot.T_AMOUNT, v_Lot.T_SUM, v_Lot.T_CURRENCY, v_NKD_
                    FROM DDL_TICK_ENS_DBT
                   WHERE t_DealID = one_prm.DealID
                     AND t_Date   = one_prm.PlanDate
                     AND t_FIID   = one_prm.FIID;
               EXCEPTION
                  WHEN OTHERS THEN NULL;
               END;

               v_Lot.T_COST := RSI_RSB_FIInstr.ConvSum(v_Lot.T_SUM, v_Lot.T_CURRENCY, v_FaceValueFI, one_prm.FactDate, 0);
               if( v_NKDRound_Kind = 1 ) then
                  v_Lot.T_NKDAMOUNT := ROUND(v_NKD_, 2) * v_Lot.T_AMOUNT;
               else
                  v_Lot.T_NKDAMOUNT := ROUND(v_NKD_ * v_Lot.T_AMOUNT, 2);
               end if;
               v_Lot.T_BALANCECOST := v_Lot.T_COST + v_Lot.T_NKDAMOUNT;
            ELSE
               v_Lot.T_AMOUNT           := one_prm.Amount;
               v_Lot.T_SUM              := one_prm.Cost;
               v_Lot.T_CURRENCY         := one_prm.CFI;

               IF RSB_SECUR.IsLoan(one_prm.OGroup) = 1 THEN
                  v_Lot.T_BALANCECOST := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.TotalCost, one_prm.CFI, v_FaceValueFI, one_prm.FactDate, 1), 2);
               ELSE
                  v_Lot.T_BALANCECOST := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.PayAmount, one_prm.RqpFIID, v_FaceValueFI, one_prm.FactDate, 1), 2);
               END IF;

               v_Lot.T_NKDAMOUNT        := 0;
               IF v_NeedChargeIncome = 1 THEN
                  IF( one_prm.NKDFIID = v_FaceValueFI ) THEN
                     v_Lot.T_NKDAMOUNT := one_prm.NKD;
                  ELSE
                     v_Lot.T_NKDAMOUNT := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.NKD, one_prm.NKDFIID, v_FaceValueFI, one_prm.DealDate, 1),2);
                  END IF;
               END IF;
               v_Lot.T_COST := v_Lot.T_BALANCECOST - v_Lot.T_NKDAMOUNT;
            END IF;

            v_Lot.T_COSTPFI := 0;

            v_Sum0 := 0;
            IF( v_Lot.T_PORTFOLIO <> KINDPORT_CLIENT) THEN
               IF v_NeedChargeIncome = 1 THEN
                 v_Sum0 := RSI_WRTCalcBegDiscountOrBonus(v_Leg1, v_Lot.T_COST, v_Lot.T_DATE, v_Lot.T_COSTPFI, v_FaceValueFI);
               END IF;

               IF v_NeedChargeIncome = 1 THEN --Только для облигаций
                  v_Lot.T_BEGINTERESTDATE := one_prm.FactDate;

                  IF v_Sum0 < 0 THEN
                    v_Lot.T_BEGBONUS := ABS(v_Sum0); 
                  END IF;

                  IF v_Lot.T_BEGBONUS > 0 THEN
                    v_Lot.T_BEGBONUSDATE := one_prm.FactDate;
                  END IF;
               END IF;

               v_Lot.T_BEGDATE := one_prm.FactDate;

               IF v_NeedChargeIncome = 1 THEN
                 IF v_Sum0 > 0 THEN
                   v_Lot.T_BEGDISCOUNT := v_Sum0;
                 END IF;

                 IF v_Lot.T_BEGDISCOUNT > 0 THEN
                   v_Lot.T_BEGDISCOUNTDATE := one_prm.FactDate;
                 END IF;

               END IF;
            END IF;

            v_Lot.T_DEPARTMENT       := v_Department;
            v_Lot.T_DEALID           := one_prm.DealID;
            v_Lot.T_DEALDATE         := one_prm.DealDate;
            v_Lot.T_DEALCODE         := one_prm.DealCode;
            v_Lot.T_STATE            := PM_WRTSUM_FORM;
            v_Lot.T_ENTERDATE        := one_prm.DealDate;
            v_Lot.T_STATEDATE        := one_prm.FactDate;
            v_Lot.T_INSTANCE         := 0;
            v_Lot.T_CHANGEDATE       := one_prm.FactDate;
            v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
            v_Lot.T_ID_OPERATION     := p_DocumentID;
            v_Lot.T_ID_STEP          := -1;
            v_Lot.T_TRUST            := CHR(0);
            v_Lot.T_ACTIVATEDATE     := one_prm.FactDate;
            v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
            v_Lot.T_BLOCKAMOUNT      := 0;
            v_Lot.T_ACCFI            := v_DetermineAccFI;
            v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

          END IF;

        ELSIF RSB_SECUR.IsAvrWrtIn(one_prm.OGroup) = 1 THEN --Зачисление

          v_Lot.T_SUMID            := 0;
          v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
          v_Lot.T_DOCID            := one_prm.RQID;
          v_Lot.T_PARTNUM          := 0;
          v_Lot.T_PARTY            := v_Party;
          v_Lot.T_CONTRACT         := v_Contract;
          v_Lot.T_FIID             := one_prm.FIID;
          v_Lot.T_PORTFOLIO        := one_prm.PortfolioID;
          v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO, 1);
          v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_BUY; --Зачисление
          v_Lot.T_KIND             := WRTSUM_KIND_FB; --Зачисление лота
          v_Lot.T_DATE             := one_prm.DealDate;
          v_Lot.T_TIME             := one_prm.DealTime;
          v_Lot.T_AMOUNT           := one_prm.Amount;
          v_Lot.T_SUM              := one_prm.Cost;
          v_Lot.T_CURRENCY         := one_prm.CFI;
          v_Lot.T_BONUS            := 0;
          v_Lot.T_INTERESTINCOME   := 0;
          v_Lot.T_DISCOUNTINCOME   := 0;
          v_Lot.T_OVERAMOUNT       := 0;


          v_Lot.T_NKDAMOUNT        := 0;
          IF v_NeedChargeIncome = 1 THEN
            v_Lot.T_NKDAMOUNT      := one_prm.NKD;
          END IF;

          IF( v_Lot.T_PORTFOLIO <> KINDPORT_CLIENT) THEN
             IF v_NeedChargeInterestIncome = 1 THEN --Только облигаций имеющих купоны, или в анкете которых задан доход
                v_Lot.T_BEGINTERESTDATE  := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_INTERESTINCOME); --Процентный доход
                v_Lot.T_INTERESTINCOME   := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_INTERESTINCOME); --Процентный доход
                v_Lot.T_NOTCARRYINTEREST := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_INTERESTINCOMENOTCARRY); --Процентный доход, не отн. на доходы
             END IF;
          END IF;

          IF v_Lot.T_INTERESTINCOME != 0 THEN
            v_Lot.T_INTERESTDATE := one_prm.StartDate;
          END IF;

          v_Lot.T_BEGDATE := one_prm.StartDate;

          IF (v_NeedChargeIncome = 1 AND v_Lot.T_PORTFOLIO <> KINDPORT_CLIENT)THEN --Только по облигациям
            v_Lot.T_BEGBONUS := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGBONUS); --Начальная премия
            v_Lot.T_OLDBEGBONUS := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_OLDBEGBONUS); --Начальная премия до перевода

            IF v_Lot.T_BEGBONUS > 0 OR v_Lot.T_OLDBEGBONUS > 0 THEN
              v_Lot.T_BEGBONUSDATE := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGBONUS); --Начальная премия
            END IF;

            v_Lot.T_BONUS := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BONUS); --Премия

            IF v_Lot.T_BONUS != 0 THEN
              v_Lot.T_BONUSDATE := v_Lot.T_DATE;
            END IF;
            
            v_Lot.T_BEGDISCOUNT    := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGDISCONTINCOME); --Начальный дисконт
            v_Lot.T_OLDBEGDISCOUNT := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_OLDBEGDISCONTINCOME); --Начальный дисконт до перевода

            IF v_Lot.T_BEGDISCOUNT > 0 OR v_Lot.T_OLDBEGDISCOUNT > 0 THEN
              v_Lot.T_BEGDISCOUNTDATE := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGDISCONTINCOME); --Начальный дисконт
            END IF;

            v_Lot.T_RECALCDATE := one_prm.InterestStart;

            v_Lot.T_DISCOUNTINCOME   := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_DISCONTINCOME); --Дисконтный доход
            v_Lot.T_NOTCARRYDISCOUNT := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_DISCONTINCOMENOTCARRY); --Дисконтный доход не отн. на доходы

            IF v_Lot.T_DISCOUNTINCOME != 0 THEN
              v_Lot.T_DISCOUNTDATE := v_Lot.T_DATE;
            END IF;

            v_Lot.T_NOTWRTBONUS := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_NOTWRTBONUS);
          END IF;

          IF( v_Lot.T_PORTFOLIO = KINDPORT_CONTR ) THEN
             v_FIPKU := RSI_RSB_FIInstr.NATCUR;
          ELSE
             v_FIPKU := v_FaceValueFI;
          END IF;

          v_Lot.T_OUTLAY := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_OUTLAY) + --Затраты на приобретение
                            ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.PreOutlay, one_prm.PreOutlayFIID, v_FIPKU, v_Lot.T_DATE, 1 ),2);
          
          IF( v_Lot.T_PORTFOLIO <> KINDPORT_CLIENT) THEN
             v_Lot.T_OVERAMOUNT := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_OVERVALUE); --Переоценка
          
             IF v_Lot.T_OVERAMOUNT <> 0 THEN
               v_Lot.T_OVERDATE := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_OVERVALUE); --Переоценка
             END IF;
          END IF;

          v_Lot.T_COST             := ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.Cost, one_prm.CFI, v_FIPKU, one_prm.DealDate, 1 ),2) + v_Lot.T_OUTLAY - v_Lot.T_BONUS;

          v_Lot.T_BALANCECOST      := v_Lot.T_COST + v_Lot.T_NKDAMOUNT + v_Lot.T_INTERESTINCOME + v_Lot.T_DISCOUNTINCOME + ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_OVERAMOUNT, 0, v_FIPKU, one_prm.DealDate, 1 ),2) ;

          v_Lot.T_DEPARTMENT       := v_Department;
          v_Lot.T_DEALID           := one_prm.DealID;
          v_Lot.T_DEALDATE         := one_prm.DealDate;
          v_Lot.T_DEALCODE         := one_prm.DealCode;
          v_Lot.T_STATE            := PM_WRTSUM_FORM;
          v_Lot.T_ENTERDATE        := one_prm.DealDate;
          v_Lot.T_STATEDATE        := one_prm.DealDate;
          v_Lot.T_INSTANCE         := 0;
          v_Lot.T_CHANGEDATE       := one_prm.DealDate;
          v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
          v_Lot.T_ID_OPERATION     := p_DocumentID;
          v_Lot.T_ID_STEP          := -1;
          v_Lot.T_TRUST            := CHR(0);
          v_Lot.T_ACTIVATEDATE     := one_prm.DealDate;
          v_Lot.T_ACTIVATETIME     := one_prm.DealTime;
          v_Lot.T_BlockAmount      := 0;
          v_Lot.T_ACCFI            := v_DetermineAccFI;
          v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FIPKU, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

          v_Lot.T_AMORTCALCKIND          := 0;
          IF v_CurFIisBond = TRUE THEN
            v_Lot.T_AMORTCALCKIND := RSB_SECUR.AMORTCALCKIND_LM;

            IF v_FloatingRate = 'X' AND RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECDEAL, one_prm.DealID) = 0 THEN
              IF FRBONDS_AMORTCALCKIND_LM = 0 THEN
                v_Lot.T_AMORTCALCKIND := RSB_SECUR.AMORTCALCKIND_EPS;
              END IF;
            END IF;
          END IF;

        ELSIF (one_prm.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY AND RSB_SECUR.IsBuy(one_prm.OGroup) = 1) OR  --Покупка для клиента
              (one_prm.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR AND RSB_SECUR.IsSale(one_prm.OGroup) = 1) THEN --Продажа для клиента контрагента
          
          v_ExistOverTPlus := 0;
          v_OverTPlus      := 0;

          IF( one_prm.PortfolioID <> KINDPORT_CLIENT) THEN
             SELECT COUNT(1) INTO v_ExistOverTPlus
               FROM DDL_VALUE_DBT
              WHERE T_DOCKIND = Rsb_Secur.DL_SECURITYDOC
                AND T_DOCID = one_prm.DealID
                AND T_KIND IN (RSI_DLGR.DL_VALUE_KIND_PLUSDEALTOVER, RSI_DLGR.DL_VALUE_KIND_MINUSDEALTOVER)
                AND T_DATE <= one_prm.FactDate
                AND ROWNUM = 1;
          END IF;

          IF v_ExistOverTPlus > 0 THEN
            v_OverTPlus:= RSB_SECUR.GetDealSumOverTPlusOnDate(one_prm.DealID, 0, one_prm.FactDate) ;      
            RSI_DLGR.RSI_InsertDL_VALUE(Rsb_Secur.DL_SECURITYDOC, one_prm.DealID, RSI_DLGR.DL_VALUE_KIND_PLUSDEALTOVER, one_prm.FactDate, 0, RSI_RSB_FIInstr.NATCUR, p_DocumentID, -1, p_GrpID);
            RSI_DLGR.RSI_InsertDL_VALUE(Rsb_Secur.DL_SECURITYDOC, one_prm.DealID, RSI_DLGR.DL_VALUE_KIND_MINUSDEALTOVER, one_prm.FactDate, 0, RSI_RSB_FIInstr.NATCUR, p_DocumentID, -1, p_GrpID);
          END IF;

          SELECT *
            INTO v_Leg1
            FROM DDL_LEG_DBT
           WHERE T_ID = one_prm.LegRecID;

          v_Lot.T_AMOUNT           := one_prm.Amount;
          v_Lot.T_FIID             := one_prm.FIID;
          v_Lot.T_DATE             := one_prm.FactDate;
          v_Lot.T_SUM              := one_prm.Cost;
          v_Lot.T_CURRENCY         := one_prm.CFI;
          v_Lot.T_PORTFOLIO        := one_prm.PortfolioID;
          v_Lot.T_DEALID           := one_prm.DealID;
          v_Lot.T_DEALCODE         := one_prm.DealCode;

          v_FairValue              := v_Lot.T_AMOUNT * NVL(RSB_Secur.SC_ConvSumTypeRep(1, v_Lot.T_FIID, v_FaceValueFI, v_FaceValueFI, v_FVCourseType, v_Lot.T_DATE), 0);
          v_FairValueRub           := v_Lot.T_AMOUNT * NVL(RSB_Secur.SC_ConvSumTypeRep(1, v_Lot.T_FIID, RSI_RSB_FIInstr.NATCUR, RSI_RSB_FIInstr.NATCUR, v_FVCourseType, v_Lot.T_DATE), 0);
          v_CostRub                := RSI_RSB_FIInstr.ConvSum(one_prm.TotalCost, v_Lot.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE, 1); --Значение DDL_LEG.T_COST, переведенное в рубли по курсу на дату поставки

          v_AmortCalcKind          := 0;
          IF v_CurFIisBond = TRUE THEN
            v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
          END IF;
   
          IF (v_Lot.T_PORTFOLIO <> KINDPORT_CLIENT)  THEN  
              -- если не задан курс СС на ФИ, в соответствии с настройкой (SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ), то рассчитаем СС
             IF v_FairValue = 0 THEN
                IF RSB_SECUR.SC_CalcFairValue( v_Lot.T_FIID, -- идентификатор ц/б
                                            v_Lot.T_DATE, -- дата расчета
                                            RSB_SECUR.CALCKIND_AVR, -- вид расчета (0 необязательный)
                                            v_Lot.t_DealID, -- id сделки (0 необязательный)
                                            0, -- id лота (0 необязательный)
                                            rsb_secur.GetEndCoupDate(v_Lot.T_FIID, v_Lot.T_DATE), -- Дата окончания периода расчета купона
                                            v_FairValue, -- рассчитанное значение СС
                                            v_Msg, -- сообщение
                                            v_RateID, -- курс, использованный для вычисления СС
                                            v_Cat55, -- значение для категории "Уровень исходных данных иерархии СС МСФО 13"
                                            v_Cat60, -- значение для категории "Наблюдаемые исходные данные"
                                            v_AlgUsed, -- примененный алгоритм
                                            v_RateVal, -- ставка (может быть изменена, если применен алгоритм ALG_DISCCOSTSTREAM)
                                            v_ACK -- -- Вид расчета АС (может быть изменен, если применен алгоритм ALG_DISCCOSTSTREAM)
                                          ) = 0 THEN

                   IF v_AlgUsed = RSB_SECUR.ALG_DISCCOSTSTREAM AND v_ACK = RSB_SECUR.AMORTCALCKIND_RPS THEN
                      v_AmortCalcKind := v_ACK;
                      v_EIR := v_RateVal;
                      v_AmortCost := v_FairValue;
                   ELSIF v_AlgUsed != RSB_SECUR.ALG_DISCCOSTSTREAM THEN
                      v_FairValue := v_FairValue * v_Lot.T_AMOUNT;
                   END IF;

                  v_FairValueRub := RSI_RSB_FIInstr.ConvSum(v_FairValue, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE, 1);
                END IF;

                IF Length(v_Msg) > 0 THEN
                   RSB_SECUR.AddWarningLogTmp(v_Lot.T_DEALCODE, 1, v_Msg);
                END IF;
             END IF;
          
             IF RSB_SECUR.GetEssentialDev(
                 RSB_SECUR.LEVELESSENTIAL_FACTPRICE, -- Вид уровня существенности = Отклонение фактической цены
                 v_Lot.T_PORTFOLIO, --Номер портфеля, заданный в сделке
                 v_Lot.T_DATE, --Плановая дата поставки
                 v_CostRub,
                 v_FairValueRub,
                 0,
                 0,
                 0,
                 v_SignDeviation, -- Да/нет
                 v_RateKind,      -- Наименование ставки используемой в дальнейшем
                 v_RateVal        -- Значение ставки
                ) <> 0 THEN
                dbms_output.put_line('Ошибка: неверные параметры при вызове ф-ции проверки на существенность отклонения');
             END IF;

             IF v_SignDeviation = TRUE THEN
                v_DeltaRub := v_FairValueRub - v_CostRub;
                v_TestAttrID:= 2; --Нет
             ELSE
                v_DeltaRub := 0;
                v_TestAttrID:= 1; --Да
             END IF;

             --Заносим значение в категорию
             RSB_SECUR.SetDealMarketTestAttrID(v_Lot.T_DEALID, v_Lot.T_DATE, v_TestAttrID);
          
             IF v_CurFIisBond = TRUE THEN --Только для облигаций
                IF v_Lot.T_PORTFOLIO = KINDPORT_RETIRE/*АС_ЦБ*/ AND v_AmortCalcKind != RSB_SECUR.AMORTCALCKIND_RPS THEN
                   IF RSB_SECUR.GetEssentialDev(
                      RSB_SECUR.LEVELESSENTIAL_AC, -- Вид уровня существенности = Отклонение АС
                      v_Lot.T_PORTFOLIO, --Портфель = АС_БПП
                      v_Lot.T_DATE, --Плановая дата поставки
                      0,
                      0,
                      0,
                      one_prm.BOfficeKind,
                      one_prm.DealID,
                      v_SignDeviation, -- Да/нет
                      v_RateKind,      -- Наименование ставки используемой в дальнейшем
                      v_RateVal        -- Значение ставки
                     ) <> 0 THEN
                     dbms_output.put_line('Ошибка: неверные параметры при вызове ф-ции проверки на существенность отклонения');
                   END IF;

                   v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;

                   IF v_SignDeviation = FALSE THEN
                      v_DrawingDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(v_Lot.T_FIID, v_Termless);

                      IF v_DrawingDate <> UnknownDate AND
                         ADD_MONTHS(v_Lot.T_DATE, 12) > v_DrawingDate AND
                         EPSAvrLessThanYear() = EPSAVRLESSTHANYEAR_NO THEN
                         v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM /*ЛМ*/;

                      ELSIF EPSAvrNSignDevACEPSACLM() = EPSAVRNSIGNDEVACEPSACLM_NO THEN
                         v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM /*ЛМ*/;
                      END IF;
                   END IF;

                ELSIF v_Lot.T_PORTFOLIO = KINDPORT_TRADE/*ССПУ_ЦБ*/ AND Rsb_Common.GetRegIntValue('SECUR\МСФО\ЭПС ДЛЯ ЦБ В ССПУ_ЦБ', 0) = 1 THEN 
                   v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
                ELSIF v_Lot.T_PORTFOLIO = KINDPORT_SALE/*СССД_ЦБ*/ AND Rsb_Common.GetRegIntValue('SECUR\МСФО\ЭПС ДЛЯ ЦБ В СССД_ЦБ', 0) = 1 THEN
                   v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
                END IF;

                IF v_FloatingRate = 'X' AND v_TestAttrID = 1 THEN -- Тест на рыночность пройден = Да 
                   IF FRBONDS_AMORTCALCKIND_LM = 0 THEN
                      v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
                   ELSE
                      v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
                   END IF;
                END IF;
             END IF;

             v_EIR := 0;

             --определение АС по методу v_AmortCalcKind
             IF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
                v_EIR       := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_AVR, v_Lot.t_DealID, 0, v_Lot.T_DATE);
                v_AmortCost := RSB_SECUR.CalcAS_EPS0(RSB_SECUR.CALCKIND_AVR, v_Lot.T_DealID, 0, v_Lot.T_DATE, v_FairValue); --в ВН
             ELSIF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM THEN
                v_AmortCost := RSB_SECUR.CalcAS_Line(RSB_SECUR.CALCKIND_AVR, v_Lot.T_DealID, 0, v_Lot.T_DATE); --в ВН
             END IF;
          END IF; 
          
          v_Lot.T_SUMID            := 0;
          v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
          v_Lot.T_DOCID            := one_prm.RQID;
          v_Lot.T_PARTNUM          := 0;
          v_Lot.T_PARTY            := v_Party;
          v_Lot.T_CONTRACT         := v_Contract;
          v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);
          v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_BUY; --Зачисление
          v_Lot.T_KIND             := WRTSUM_KIND_B; --Покупка
          v_Lot.T_TIME             := one_prm.SupplyTime;

          v_Lot.T_NKDAMOUNT        := 0;
          IF v_NeedChargeIncome = 1 THEN
            v_Lot.T_NKDAMOUNT      := one_prm.NKD;
          END IF;

          IF( v_Lot.T_PORTFOLIO = KINDPORT_CONTR ) THEN
             v_FIPKU := RSI_RSB_FIInstr.NATCUR;
          ELSE
             v_FIPKU := v_FaceValueFI;
          END IF;

          v_ToCompare    := RSI_RSB_FIInstr.ConvSum( one_prm.TotalCost, v_Lot.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE, 1 );

          v_Lot.T_OUTLAY := GetComSumByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FIPKU, v_Lot.T_PORTFOLIO, v_Lot.T_Contract, v_ToCompare) ;
          if DATE_CONV_COURSE = DATE_COURSE_DELIV  then
            v_Lot.T_OUTLAY := v_Lot.T_OUTLAY  + ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.PreOutlay, one_prm.PreOutlayFIID, v_FIPKU, v_Lot.T_DATE, 1 ),2);
          else
            v_Lot.T_OUTLAY := v_Lot.T_OUTLAY  + ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.PreOutlay, one_prm.PreOutlayFIID, v_FIPKU, one_prm.T_COMMDATE, 1 ),2);
          end if;

          IF( v_Lot.T_PORTFOLIO = KINDPORT_TRADE) THEN
             v_Lot.T_OUTLAY := 0;
          END IF;

          v_Lot.T_BALANCECOST := ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.TotalCost, one_prm.CFI, v_FIPKU, v_Lot.T_DATE, 1 ),2) + v_Lot.T_OUTLAY;

          v_Lot.T_COSTPFI := 0;

          IF( one_prm.IsPFI = 'X' ) THEN -- Сделка ПФИ
             -- Справедливая стоимость ПФИ
             v_Lot.T_COSTPFI := RSI_GetLastAccountedFrVal(one_prm.DealID,one_prm.BOfficeKind,v_Lot.T_DATE);
             IF v_Lot.T_PORTFOLIO <> KINDPORT_CONTR THEN
                v_Lot.T_COSTPFI := RSI_RSB_FIInstr.ConvSum(v_Lot.T_COSTPFI, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_Lot.T_DATE, 1);
             END IF;
             v_Lot.T_BALANCECOST := v_Lot.T_BALANCECOST + v_Lot.T_COSTPFI;
          END IF;

          v_Lot.T_COST := v_Lot.T_BALANCECOST - v_Lot.T_NKDAMOUNT - v_Lot.T_COSTPFI;

          v_Lot.T_BEGDATE := one_prm.FactDate;

          v_Sum0 := 0;
          IF( v_Lot.T_PORTFOLIO <> KINDPORT_CLIENT) THEN
             IF v_NeedChargeIncome = 1 THEN
               v_Sum0 := RSI_WRTCalcBegDiscountOrBonus(v_Leg1, v_Lot.T_COST, v_Lot.T_DATE, v_Lot.T_COSTPFI, v_FaceValueFI);
             END IF;
          
             IF v_NeedChargeIncome = 1 THEN --Только по облигациям
                v_Lot.T_BEGINTERESTDATE := one_prm.FactDate;
          
                IF v_Sum0 < 0 THEN
                  v_Lot.T_BEGBONUS := ABS(v_Sum0);
                  v_Lot.T_BEGBONUSDATE := one_prm.FactDate;
                END IF;
          
                IF( v_AmortizationMethod = PM_WRITEOFF_AVERAGE ) THEN
                   v_Lot.T_BEGBONUSDATE := one_prm.FactDate;
                END IF;
             END IF;
          
             IF v_NeedChargeIncome = 1 THEN --Только по облигациям
               
               IF v_Sum0 > 0 THEN
                 v_Lot.T_BEGDISCOUNT := v_Sum0;
                 v_Lot.T_BEGDISCOUNTDATE := one_prm.FactDate;
               END IF;
          
               IF( v_AmortizationMethod = PM_WRITEOFF_AVERAGE ) THEN
                  v_Lot.T_BEGDISCOUNTDATE := one_prm.FactDate;
                  v_Lot.T_BEGDEFDIFFDATE  := one_prm.FactDate;
                  v_Lot.T_CORRDATE        := one_prm.FactDate;
               END IF;
          
               IF v_AvoirAttrObsBaseData = 1 THEN -- Наблюдаемые исходные данные = Нет
                  v_Lot.T_BEGDEFDIFF  := v_DeltaRub;
                  v_Lot.T_BEGDEFDIFFDATE := one_prm.FactDate;
               END IF;
          
               IF v_AvoirAttrObsBaseData = 0 THEN -- Наблюдаемые исходные данные = Да
                  v_Lot.T_CORRVALUE   := v_DeltaRub;
               END IF;
          
               v_Lot.T_OVERAMOUNT    := ROUND(v_OverTPlus,2);
               IF( v_Lot.T_OVERAMOUNT <> 0 ) THEN
                  v_Lot.T_OVERDATE   := v_Lot.T_DATE;
               END IF;
          
          
             ELSE --не облигации
                IF(v_DeltaRub <>0) THEN
                  v_Lot.T_OVERAMOUNT    := ROUND(v_DeltaRub,2);
                ELSE
                  v_Lot.T_OVERAMOUNT    := ROUND(v_OverTPlus,2);
                END IF;
          
                IF( v_Lot.T_OVERAMOUNT <> 0 ) THEN
                  v_Lot.T_OVERDATE   := v_Lot.T_DATE;
                END IF;
          
                IF v_AvoirAttrObsBaseData = 1 THEN -- Наблюдаемые исходные данные = Нет
                  v_Lot.T_CORRVALUE   := v_DeltaRub;
                END IF;
             END IF;
          END IF;

          v_Lot.T_DEPARTMENT       := v_Department;
          v_Lot.T_DEALDATE         := one_prm.DealDate;
          v_Lot.T_STATE            := PM_WRTSUM_FORM;
          v_Lot.T_ENTERDATE        := one_prm.DealDate;
          v_Lot.T_STATEDATE        := one_prm.FactDate;
          v_Lot.T_INSTANCE         := 0;
          v_Lot.T_CHANGEDATE       := one_prm.FactDate;
          v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
          v_Lot.T_ID_OPERATION     := p_DocumentID;
          v_Lot.T_ID_STEP          := -1;
          v_Lot.T_ISFREE           := 'X';
          v_Lot.T_TRUST            := CHR(0);
          v_Lot.T_ACTIVATEDATE     := one_prm.FactDate;
          v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
          v_Lot.T_BLOCKAMOUNT      := 0;
          v_Lot.T_VATOUTLAY        := GetComNDSByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, RSI_RSB_FIInstr.NATCUR, v_Lot.T_PORTFOLIO, v_Lot.T_Contract, v_ToCompare);
          
          IF v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
            v_Lot.T_EFFECTINTERESTRATE := v_EIR;
          END IF;

          v_Lot.T_FAIRVALUE        := v_FairValue;
          v_Lot.T_AMORTCOST        := ROUND(v_AMORTCOST,2);
          v_Lot.T_AMORTCOSTDATE    := v_Lot.T_DATE;
          v_Lot.T_BALANCECOST      := v_Lot.T_BALANCECOST + NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_OVERAMOUNT, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_Lot.T_DATE, 1),0)
                                    + NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_CORRVALUE, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_Lot.T_DATE, 1),0)  
                                    + NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_CORRINTTOEIR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_Lot.T_DATE, 1),0)
                                    + NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_HEDGCORR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_Lot.T_DATE, 1),0)
                                    + NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_AMORTHEDGCORR, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, v_Lot.T_DATE, 1),0);

          IF v_Lot.T_CORRVALUE <> 0 THEN -- Наблюдаемые исходные данные = Нет
             v_Lot.T_CORRDATE      := v_Lot.T_DATE;
          END IF;

          v_Lot.T_ACCFI            := v_DetermineAccFI;
          v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1),0) end;
          v_Lot.T_AMORTCALCKIND    := v_AmortCalcKind;
        END IF;

        IF v_Lot.T_SUMID IS NOT NULL THEN
          RSI_InsDfltIntoWRTSUM(v_Lot);
          INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;
        END IF;
     END LOOP;


     -- 4.4. Обработать продажи/списания/1ч прямого РЕПО/1ч размещения займа за дату
     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, GRDEAL.T_ID, GRDEAL.T_PLANTIME, 6 -- для сделок из 1ч или 1ч РЕПО
        FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL
       WHERE S.T_GRPID         = p_GrpID
         AND S.T_TYPE          = 1
         AND SD.T_SUBGRPID     = S.T_SUBGRPID
         AND GRDEAL.T_ID       = SD.T_GRDEALID
         AND GRDEAL.T_DOCKIND  IN (RSB_SECUR.DL_SECURITYDOC, RSB_SECUR.DL_AVRWRT)
         AND GRDEAL.T_PLANDATE = v_Date
         AND GRDEAL.T_FIID     = p_FIID
         AND GRDEAL.T_TEMPLNUM IN (RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR)
         AND TK.T_DEALID       = GRDEAL.T_DOCID
         AND TK.T_DEPARTMENT   = v_Department
         AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN 1
                       WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1
                       ELSE 0 END)
         AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
         AND (v_OperType = 0 OR 
              v_Kind_Operation != 0 OR 
              1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                             RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                             RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                        ELSE 0 END)
             )
         AND EXISTS(SELECT 1
                      FROM DDLGRACC_DBT GRACC
                     WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                       AND GRACC.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                       AND GRACC.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN --П
                   )
         AND EXISTS(SELECT 1
                      FROM DDLRQ_DBT RQ
                     WHERE RQ.T_DOCKIND  = TK.T_BOFFICEKIND
                       AND RQ.T_DOCID    = TK.T_DEALID
                       AND RQ.T_STATE    = RSI_DLRQ.DLRQ_STATE_EXEC
                       AND RQ.T_SUBKIND  = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                       AND RQ.T_KIND     = DECODE(GRDEAL.T_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLRQ.DLRQ_KIND_COMMIT /*Обязательство*/, RSI_DLRQ.DLRQ_KIND_REQUEST /*Требование*/)
                       AND RQ.T_TYPE     = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                       AND RQ.T_DEALPART = 1
                       AND RQ.T_FIID     = GRDEAL.T_FIID
                   )
     );

     --4.4.1. Если в дату обработки есть покупки и продажи/погашения, то при Средневзвесе нужно осреднить лоты
     IF(v_Party = -1 AND v_ExistsBuy = TRUE AND v_AmortizationMethod = PM_WRITEOFF_AVERAGE) THEN

       SELECT Count(1) INTO v_Cnt
         FROM DPMWRTORDER_TMP
        WHERE T_GRPID = p_GrpID
          AND T_SORT = 6
          AND ROWNUM = 1;

       IF v_ExistsRetire = TRUE OR v_Cnt > 0 THEN  
         RSI_WRTAverageLots(v_Date, v_Date, p_FIID, v_Department, v_Party, v_Contract, p_DocumentID, -1, PM_WRT_UPDTMODE_CORRECTSUM, 1, 1, 1, 1);
       END IF;
     END IF;

     -- 4.5. Обработать лоты компенсации при увеличении обеспечения в прямом и обратном РЕПО на корзину ц/б и при комп. поставке(увеличении) в РЕПО не на корзину
     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, GRDEAL.T_ID, GRDEAL.T_PLANTIME, 3 -- для увеличения обеспечения в ОР
        FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal
       WHERE S.T_GRPID           = p_GrpID
         AND S.T_TYPE            = 1
         AND SD.T_SUBGRPID       = S.T_SUBGRPID
         AND GRDEAL.T_ID         = SD.T_GRDEALID
         AND GRDEAL.T_DOCKIND    = RSB_SECUR.DL_SECURITYDOC
         AND GrDeal.T_PLANDATE   = v_Date
         AND GrDeal.T_FIID       = p_FIID
         AND GrDeal.T_TEMPLNUM   IN (RSI_DLGR.DLGR_TEMPL_COMPDELIVERY, RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR)
         AND TK.T_DEALID         = GrDeal.t_DocID
         AND TK.T_DEPARTMENT     = v_Department
         AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract 
         AND RSB_SECUR.IsBuy(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- обратное
                            THEN 1
                       WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract 
                            AND RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- прямое
                            THEN 1
                       ELSE 0 END)
         AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
         AND (v_OperType = 0 OR 
              v_Kind_Operation != 0 OR 
              1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                             RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                             RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                        ELSE 0 END)
             )
         AND EXISTS(SELECT 1
                      FROM DDLGRACC_DBT GrAcc
                     WHERE GrAcc.T_GRDEALID    = GrDeal.t_ID
                       AND GrAcc.T_ACCNUM      = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING
                       AND GrAcc.T_STATE       = RSI_DLGR.DLGRACC_STATE_PLAN
                   )
         AND EXISTS(SELECT 1
                      FROM DDL_TICK_ENS_DBT T, DDLGRDOC_DBT DocRQ, DDLGRDOC_DBT DocENS
                     WHERE T.T_DEALID          = TK.T_DEALID
                       AND T.T_FIID            = GrDeal.T_FIID
                       AND T.T_DATE            = v_Date
                       AND T.T_Kind            = RSB_SECUR.TICKENS_KIND_IN
                       AND DocRQ.T_GRDEALID    = GrDeal.t_ID
                       AND DocRQ.T_DOCKIND     = 29 --DLDOC_PAYMENT
                       AND DocRQ.T_SOURCETYPE  = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                       AND DocENS.T_GRDEALID   = GrDeal.t_ID
                       AND DocENS.T_DOCKIND    = 4723 --DL_DOCTICKENS
                       AND DocENS.T_DOCID      = T.T_ID
                       AND DocENS.T_SOURCETYPE = RSI_DLGR.DLGR_SOURCETYPE_ENS
                   )
     );

     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, GRDEAL.T_ID, GRDEAL.T_PLANTIME, 7 -- для увеличения обеспечения в ПР
        FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal
       WHERE S.T_GRPID           = p_GrpID
         AND S.T_TYPE            = 1
         AND SD.T_SUBGRPID       = S.T_SUBGRPID
         AND GRDEAL.T_ID         = SD.T_GRDEALID
         AND GRDEAL.T_DOCKIND    = RSB_SECUR.DL_SECURITYDOC
         AND GrDeal.T_PLANDATE   = v_Date
         AND GrDeal.T_FIID       = p_FIID
         AND GrDeal.T_TEMPLNUM   IN (RSI_DLGR.DLGR_TEMPL_COMPDELIVERY, RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR)
         AND TK.T_DEALID         = GrDeal.t_DocID
         AND TK.T_DEPARTMENT     = v_Department
         AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract 
         AND RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- прямое
                            THEN 1
                       WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract 
                            AND RSB_SECUR.IsBuy(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- обратное
                            THEN 1
                       ELSE 0 END)
         AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
         AND (v_OperType = 0 OR 
              v_Kind_Operation != 0 OR 
              1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                             RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                             RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                        ELSE 0 END)
             )
         AND EXISTS(SELECT 1
                      FROM DDLGRACC_DBT GrAcc
                     WHERE GrAcc.T_GRDEALID    = GrDeal.t_ID
                       AND GrAcc.T_ACCNUM      = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING
                       AND GrAcc.T_STATE       = RSI_DLGR.DLGRACC_STATE_PLAN
                   )
         AND EXISTS(SELECT 1
                      FROM DDL_TICK_ENS_DBT T, DDLGRDOC_DBT DocRQ, DDLGRDOC_DBT DocENS
                     WHERE T.T_DEALID          = TK.T_DEALID
                       AND T.T_FIID            = GrDeal.T_FIID
                       AND T.T_DATE            = v_Date
                       AND T.T_Kind            = RSB_SECUR.TICKENS_KIND_IN
                       AND DocRQ.T_GRDEALID    = GrDeal.t_ID
                       AND DocRQ.T_DOCKIND     = 29 --DLDOC_PAYMENT
                       AND DocRQ.T_SOURCETYPE  = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                       AND DocENS.T_GRDEALID   = GrDeal.t_ID
                       AND DocENS.T_DOCKIND    = 4723 --DL_DOCTICKENS
                       AND DocENS.T_DOCID      = T.T_ID
                       AND DocENS.T_SOURCETYPE = RSI_DLGR.DLGR_SOURCETYPE_ENS
                   )
     );


     -- 4.6 Если v_Date >= Дата_из_настройки_"Дата начала нового БУ РЕПО"
     IF ((v_Date >= NewRepoDate()) AND (v_Party = -1)) THEN
       SELECT NVL(SUM(Lot.T_AMOUNT), 0) INTO v_RestAmount
         FROM DPMWRTSUM_DBT Lot, DDL_TICK_DBT TK
        WHERE Lot.T_DEPARTMENT = v_Department
          AND Lot.T_FIID       = p_FIID
          AND Lot.T_PARTY      = v_Party
          AND Lot.T_CONTRACT   = v_Contract
          AND Lot.T_PORTFOLIO  <> KINDPORT_BACK
          AND Lot.T_ISFREE     = 'X'
          AND Lot.T_KIND       = WRTSUM_KIND_B
          AND Lot.T_DATE       = v_Date
          AND TK.T_DEALID      = Lot.t_DealID
          AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
          AND (v_OperType = 0 OR 
               v_Kind_Operation != 0 OR 
               1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                         WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                         WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                              RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                              RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                         ELSE 0 END)
              )
          AND EXISTS(SELECT 1
                       FROM dobjatcor_dbt AtCor
                      WHERE AtCor.t_ObjectType = Rsb_Secur.OBJTYPE_SECDEAL
                        AND AtCor.t_GroupID    = 35 -- OBJGROUP_TICKBUYFORREPO
                        AND AtCor.t_Object     = LPAD(Lot.t_DealID, 34, '0')
                        AND AtCor.t_AttrID     = 1
                    );

       v_Break := FALSE;
       WHILE v_Break = FALSE AND v_RestAmount > 0
       LOOP

          v_Lot2 := NULL;

          BEGIN
           SELECT * INTO v_Lot2
             FROM (SELECT Lot2.*
                    FROM DPMWRTSUM_DBT Lot2
                   WHERE Lot2.T_BUY_SALE   = PM_WRITEOFF_SUM_SALE
                     AND Lot2.T_FIID       = p_FIID
                     AND Lot2.T_PARTY      = v_Party
                     AND Lot2.T_CONTRACT   = v_Contract
                     AND Lot2.T_DEPARTMENT = v_Department
                     AND Lot2.T_AMOUNTBD > 0
                     ORDER BY Lot2.T_DATE ASC, Lot2.T_SUMID ASC
                   )
             WHERE ROWNUM = 1;

             EXCEPTION
                  WHEN OTHERS THEN
                    v_Break := TRUE;
          END;

          IF v_Break = FALSE THEN

            v_RepoAmount := v_Lot2.T_AMOUNTBD;
            v_RestRepoAmount := v_RepoAmount;
            v_Amount := least(v_RestAmount, v_RestRepoAmount);

            IF v_Amount <= 0 THEN
              v_Break := TRUE;
            END IF;

            IF v_Break = FALSE THEN

              SELECT MAX(LOT.T_PARTNUM) INTO v_MaxPartNum
                FROM DPMWRTSUM_DBT LOT
               WHERE LOT.T_DOCKIND = v_Lot2.t_DocKind
                 AND LOT.T_DOCID   = v_Lot2.t_DocID;

              --Аналог локального перемещения. Создать лот списания, выполнить списание этим лотом, выполнить зачисление в ПВО по связям списания
              v_SaleLot := NULL;

              v_SaleLot.T_SUMID        := 0;
              v_SaleLot.T_DOCKIND      := v_Lot2.t_DocKind;
              v_SaleLot.T_DOCID        := v_Lot2.t_DocID;
              v_SaleLot.T_PARTNUM      := v_MaxPartNum + 1;
              v_SaleLot.T_PARTY        := v_Party;
              v_SaleLot.T_CONTRACT     := v_Contract;
              v_SaleLot.T_FIID         := v_Lot2.t_FIID;
              v_SaleLot.T_GROUPID      := -1;
              v_SaleLot.T_PORTFOLIO    := -1;
              v_SaleLot.T_BUY_SALE     := PM_WRITEOFF_SUM_SALE; --Списание
              v_SaleLot.T_KIND         := WRTSUM_KIND_MS; --Списание из портфеля
              v_SaleLot.T_DATE         := v_Date;
              v_SaleLot.T_AMOUNT       := v_Amount;
              v_SaleLot.T_DEPARTMENT   := v_Lot2.t_Department;
              v_SaleLot.T_DEALID       := v_Lot2.t_DealID;
              v_SaleLot.T_DEALDATE     := v_Lot2.t_DealDate;
              v_SaleLot.T_DEALCODE     := v_Lot2.t_DealCode;
              v_SaleLot.T_STATE        := PM_WRTSUM_FORM;
              v_SaleLot.T_ENTERDATE    := v_Date;
              v_SaleLot.T_STATEDATE    := v_Date;
              v_SaleLot.T_INSTANCE     := 0;
              v_SaleLot.T_CHANGEDATE   := v_Date;
              v_SaleLot.T_ACTION       := PM_WRT_UPDTMODE_CREATE;
              v_SaleLot.T_ID_OPERATION := p_DocumentID;
              v_SaleLot.T_ID_STEP      := -1;
              v_SaleLot.T_TRUST        := CHR(0);
              v_SaleLot.T_SOURCE       := v_Lot2.t_SumID;
              v_SaleLot.T_ACTIVATEDATE := v_Date;
              v_SaleLot.T_ACTIVATETIME := TO_DATE('01.01.0001 23:59:59','DD.MM.YYYY HH24:MI:SS');
              v_SaleLot.T_TIME         := TO_DATE('01.01.0001 23:59:59','DD.MM.YYYY HH24:MI:SS');

              RSI_InsDfltIntoWRTSUM(v_SaleLot);
              INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.T_SUMID;

              SELECT * INTO v_SourceLot
                FROM DPMWRTSUM_DBT
               WHERE t_SumID = v_Lot2.t_Parent;


              RSI_WRTLinkSaleToBuy(v_SaleLot, v_SaleLot.T_PORTFOLIO, v_SaleLot.T_GROUPID, NULL,
                                   v_AmortizationMethod, 0, p_DocumentID, -1, PMWRTLINK_KIND_PORTFOLIO, PM_WRT_UPDTMODE_CORRECT2, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 1);

              --создать лоты зачисления в ПВО
              FOR one_lnkdata IN (SELECT BUY.T_DOCKIND, BUY.T_DOCID, BUY.T_FIID, BUY.T_DATE, BUY.T_TIME, BUY.T_CURRENCY, BUY.T_BEGDATE,
                                         BUY.T_DEPARTMENT, BUY.T_DEALID, BUY.T_DEALDATE, BUY.T_DEALCODE, BUY.T_STATEDATE, BUY.T_SUMID,
                                         LNK.T_AMOUNT, LNK.T_SUMBUY, LNK.T_COSTBUY, LNK.T_BALANCECOSTBUY, LNK.T_NKDBUYAMOUNT, LNK.T_OUTLAYBUY, LNK.T_COSTPFIBUY,
                                         (SELECT MAX(LOT.T_PARTNUM) FROM DPMWRTSUM_DBT LOT WHERE LOT.T_DOCKIND = BUY.T_DOCKIND AND LOT.T_DOCID = BUY.T_DOCID) MAXPARNUM,
                                         BUY.T_ACCFI, BUY.T_AMORTCALCKIND
                                    FROM DPMWRTLNK_DBT LNK, DPMWRTSUM_DBT BUY
                                   WHERE LNK.T_SALEID = v_SaleLot.T_SUMID
                                     AND BUY.T_SUMID = LNK.T_BUYID
                                 )
              LOOP
                v_Buy := NULL;

                v_Buy.T_SUMID         := 0;
                v_Buy.T_DOCKIND       := one_lnkdata.t_DocKind;
                v_Buy.T_DOCID         := one_lnkdata.t_DocID;
                v_Buy.T_PARTNUM       := one_lnkdata.MAXPARNUM + 1;
                v_Buy.T_PARTY         := v_Party;
                v_Buy.T_CONTRACT      := v_Contract;
                v_Buy.T_FIID          := one_lnkdata.t_FIID;
                v_Buy.T_PORTFOLIO     := KINDPORT_BACK;
                v_Buy.T_GROUPID       := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);
                v_Buy.T_BUY_SALE      := PM_WRITEOFF_SUM_BUY; --Зачисление
                v_Buy.T_KIND          := WRTSUM_KIND_MB; --Перемещение в портфель
                v_Buy.T_DATE          := one_lnkdata.t_Date;
                v_Buy.T_TIME          := one_lnkdata.t_Time;
                v_Buy.T_AMOUNT        := one_lnkdata.t_Amount;
                v_Buy.T_SUM           := one_lnkdata.t_SumBuy;
                v_Buy.T_CURRENCY      := one_lnkdata.t_Currency;
                v_Buy.T_COST          := one_lnkdata.t_CostBuy;
                v_Buy.T_BALANCECOST   := one_lnkdata.t_BalanceCostBuy;
                v_Buy.T_NKDAMOUNT     := one_lnkdata.t_NKDBuyAmount;
                v_Buy.T_BEGDATE       := one_lnkdata.t_BegDate;
                v_Buy.T_OUTLAY        := one_lnkdata.t_OutlayBuy;
                v_Buy.T_DEPARTMENT    := one_lnkdata.t_Department;
                v_Buy.T_DEALID        := v_SourceLot.t_DealID;
                v_Buy.T_DEALDATE      := one_lnkdata.t_DealDate;
                v_Buy.T_DEALCODE      := one_lnkdata.t_DealCode;
                v_Buy.T_STATE         := PM_WRTSUM_FORM;
                v_Buy.T_ENTERDATE     := v_Date;
                v_Buy.T_STATEDATE     := one_lnkdata.t_StateDate;
                v_Buy.T_INSTANCE      := 0;
                v_Buy.T_CHANGEDATE    := v_Date;
                v_Buy.T_ACTION        := PM_WRT_UPDTMODE_INPORTFOLIO;
                v_Buy.T_ID_OPERATION  := p_DocumentID;
                v_Buy.T_ISFREE        := 'X';
                v_Buy.T_ID_STEP       := -1;
                v_Buy.T_TRUST         := CHR(0);
                v_Buy.T_PARENT        := v_SaleLot.t_SumID;
                v_Buy.T_SOURCE        := v_SourceLot.t_SumID;
                v_Buy.T_COSTPFI       := one_lnkdata.t_CostPFIBuy;
                v_Buy.T_ACTIVATEDATE  := one_lnkdata.t_Date;
                v_Buy.T_ACTIVATETIME  := one_lnkdata.t_Time;
                v_Buy.t_BlockAmount   := 0;
                v_Buy.T_ACCFI         := one_lnkdata.T_ACCFI;
                v_Buy.T_AMORTCALCKIND := one_lnkdata.T_AMORTCALCKIND;

                RSI_InsDfltIntoWRTSUM(v_Buy);
                INSERT INTO DPMWRTSUM_DBT VALUES v_Buy RETURNING t_SUMID INTO v_Buy.T_SUMID;

              END LOOP;


              v_RestRepoAmount := v_RestRepoAmount - v_Amount;

              IF v_RestRepoAmount = 0 THEN
                RSI_WRTSaveLot( v_Lot2.T_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                UPDATE DPMWRTSUM_DBT
                   SET T_AMOUNTBD = v_Lot2.T_AMOUNTBD - v_RepoAmount,
                       T_BALANCECOSTBD = ROUND((v_Lot2.T_BALANCECOSTBD*(v_Lot2.T_AMOUNTBD - v_RepoAmount)/v_Lot2.T_AMOUNTBD), 2)
                 WHERE T_SUMID = v_Lot2.T_SUMID;

                 v_Lot2.T_BALANCECOSTBD := ROUND((v_Lot2.T_BALANCECOSTBD*(v_Lot2.T_AMOUNTBD - v_RepoAmount)/v_Lot2.T_AMOUNTBD), 2);
                 v_Lot2.T_AMOUNTBD := v_Lot2.T_AMOUNTBD - v_RepoAmount;
              END IF;

              v_RestAmount := v_RestAmount - v_Amount;

              IF v_RestAmount = 0 AND v_RestRepoAmount <> 0 THEN
                RSI_WRTSaveLot( v_Lot2.T_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                UPDATE DPMWRTSUM_DBT
                   SET T_AMOUNTBD = v_Lot2.T_AMOUNTBD - (v_RepoAmount - v_RestRepoAmount),
                       T_BALANCECOSTBD = ROUND((v_Lot2.T_BALANCECOSTBD*(v_Lot2.T_AMOUNTBD - (v_RepoAmount - v_RestRepoAmount))/v_Lot2.T_AMOUNTBD), 2)
                 WHERE T_SUMID = v_Lot2.T_SUMID;

                 v_Lot2.T_BALANCECOSTBD := ROUND((v_Lot2.T_BALANCECOSTBD*(v_Lot2.T_AMOUNTBD - (v_RepoAmount - v_RestRepoAmount))/v_Lot2.T_AMOUNTBD), 2);
                 v_Lot2.T_AMOUNTBD := v_Lot2.T_AMOUNTBD - (v_RepoAmount - v_RestRepoAmount);

              END IF;
            END IF;

          END IF;

       END LOOP;

     END IF;


     -- 4.8. Обработать лоты компенсации в прямом РЕПО. Уменьшение обеспечения
     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, GRDEAL.T_ID, GRDEAL.T_PLANTIME, 1 -- комп. поставка - уменьшение, в прямом РЕПО
       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal, DDLGRDEALPRM_DBT T
      WHERE S.T_GRPID          = p_GrpID
        AND S.T_TYPE           = 1
        AND SD.T_SUBGRPID      = S.T_SUBGRPID
        AND GRDEAL.T_ID        = SD.T_GRDEALID
        AND GRDEAL.T_DOCKIND   = RSB_SECUR.DL_SECURITYDOC
        AND GrDeal.T_PLANDATE  = v_Date
        AND GrDeal.T_FIID      = p_FIID
        AND GrDeal.t_TEMPLNUM  IN (RSI_DLGR.DLGR_TEMPL_COMPDELIVERY, RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR)
        AND T.T_GRDEALID       = GrDeal.t_ID
        AND TK.T_DEALID        = GrDeal.t_DocID
        AND TK.T_DEPARTMENT    = v_Department
        AND RSB_SECUR.IsTwoPart(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- РЕПО
        AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract 
                           AND RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- прямое
                           THEN 1
                      WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract 
                           AND RSB_SECUR.IsBuy(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- обратное
                           THEN 1
                      ELSE 0 END)
        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
        AND (v_OperType = 0 OR 
             v_Kind_Operation != 0 OR 
             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                       ELSE 0 END)
            )
        AND EXISTS(SELECT 1
                     FROM DDLGRACC_DBT GrAcc
                    WHERE GrAcc.T_GRDEALID  = GrDeal.t_ID
                      AND GrAcc.T_ACCNUM    = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING
                      AND GrAcc.T_STATE     = RSI_DLGR.DLGRACC_STATE_PLAN
                  )
        AND EXISTS(SELECT 1
                     FROM DDLGRDOC_DBT DOC, DDLRQ_DBT RQ, DDLRQ_DBT RQ2
                    WHERE DOC.T_GRDEALID     = GrDeal.t_ID
                      AND DOC.T_DOCKIND      = 29 --DLDOC_PAYMENT
                      AND DOC.T_SOURCETYPE   = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                      AND RQ.T_ID            = DOC.T_DOCID
                      AND RQ.t_DealPart      = 2
                      AND RQ.T_KIND          = DECODE(GRDEAL.T_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_COMPDELIVERY, RSI_DLRQ.DLRQ_KIND_REQUEST /*Требование*/, RSI_DLRQ.DLRQ_KIND_COMMIT /*Обязательство*/)
                      AND RQ2.T_DOCKIND      = TK.T_BOFFICEKIND
                      AND RQ2.T_DOCID        = TK.T_DEALID
                      AND RQ2.T_FIID         = GrDeal.T_FIID
                      AND RQ2.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY -- Поставка
                      AND RQ2.T_DEALPART     = 2
                  )
     );


     -- 4.9. В дату поставки 2ч прямого РЕПО занести суммы и статус "Поставлен" на лоты 2ч прямого РЕПО
     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, GRDEAL.T_ID, GRDEAL.T_PLANTIME, 2 -- Обработка 2ч ПР
        FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD,  DDLGRDEAL_DBT GRDEAL, DDL_TICK_DBT TK
       WHERE S.T_GRPID          = p_GrpID
         AND S.T_TYPE           = 1
         AND SD.T_SUBGRPID      = S.T_SUBGRPID
         AND GRDEAL.T_ID        = SD.T_GRDEALID
         AND GRDEAL.T_DOCKIND   = RSB_SECUR.DL_SECURITYDOC
         AND GRDEAL.T_PLANDATE  = v_Date
         AND GRDEAL.T_FIID      = p_FIID
         AND GRDEAL.T_TEMPLNUM  IN (RSI_DLGR.DLGR_TEMPL_DELIVERY2, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2)
         AND TK.T_DEALID        = GRDEAL.T_DOCID
         AND TK.T_DEPARTMENT    = v_Department
         AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY2 AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN 1
                       WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2 AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1
                       ELSE 0 END)
         AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
         AND (v_OperType = 0 OR 
              v_Kind_Operation != 0 OR 
              1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                             RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                             RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                        ELSE 0 END)
             )
         AND EXISTS(SELECT 1
                      FROM DDLGRACC_DBT GRACC
                     WHERE GRACC.T_GRDEALID  = GRDEAL.T_ID
                       AND GRACC.T_ACCNUM    = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                       AND GRACC.T_STATE     = RSI_DLGR.DLGRACC_STATE_PLAN --П
                   )
         AND EXISTS(SELECT 1
                      FROM DDLRQ_DBT RQ
                     WHERE RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                       AND RQ.T_DOCID        = TK.T_DEALID
                       AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                       AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                       AND RQ.T_KIND         = DECODE(GRDEAL.T_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_DELIVERY2, RSI_DLRQ.DLRQ_KIND_REQUEST, RSI_DLRQ.DLRQ_KIND_COMMIT)
                       AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                       AND RQ.T_DEALPART     = 2
                       AND RQ.T_FIID         = GRDEAL.T_FIID
                   )
     );


     -- 4.10. Обработать лоты компенсации обратного РЕПО. Уменьшение обеспечения
     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, GRDEAL.T_ID, GRDEAL.T_PLANTIME, 4 -- комп. поставка - уменьшение, в обратном РЕПО
        FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal
       WHERE S.T_GRPID          = p_GrpID
         AND S.T_TYPE           = 1
         AND SD.T_SUBGRPID      = S.T_SUBGRPID
         AND GRDEAL.T_ID        = SD.T_GRDEALID
         AND GRDEAL.T_DOCKIND   = RSB_SECUR.DL_SECURITYDOC
         AND GrDeal.T_PLANDATE  = v_Date
         AND GrDeal.T_FIID      = p_FIID
         AND GrDeal.t_TEMPLNUM  IN (RSI_DLGR.DLGR_TEMPL_COMPDELIVERY, RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR)
         AND EXISTS(SELECT 1
                      FROM DDLGRACC_DBT GrAcc
                     WHERE GrAcc.T_GRDEALID = GrDeal.t_ID
                       AND GrAcc.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING
                       AND GrAcc.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN
                   )
         AND TK.T_DEALID        = GrDeal.t_DocID
         AND TK.T_DEPARTMENT    = v_Department
         AND RSB_SECUR.IsTwoPart(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- РЕПО
         AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract 
                            AND RSB_SECUR.IsBuy(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- обратное
                            THEN 1
                       WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract 
                            AND RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 -- прямое
                            THEN 1
                       ELSE 0 END)
         AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
         AND (v_OperType = 0 OR 
              v_Kind_Operation != 0 OR 
              1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                        WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                             RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                             RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                        ELSE 0 END)
             )
         AND EXISTS(SELECT 1
                      FROM DDLGRDOC_DBT DOC, DDLRQ_DBT RQ, DDLRQ_DBT RQ2, DPMWRTSUM_DBT Lot2
                     WHERE DOC.T_GRDEALID     = GrDeal.t_ID
                       AND DOC.T_DOCKIND      = 29 --DLDOC_PAYMENT
                       AND DOC.T_SOURCETYPE   = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                       AND RQ.T_ID            = DOC.T_DOCID
                       AND RQ.t_DealPart      = 2
                       AND RQ.T_KIND          = DECODE(GrDeal.t_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_COMPDELIVERY, RSI_DLRQ.DLRQ_KIND_COMMIT /*Обязательство*/, RSI_DLRQ.DLRQ_KIND_REQUEST /*Требование*/)
                       AND RQ2.T_DOCKIND      = TK.T_BOFFICEKIND
                       AND RQ2.T_DOCID        = TK.T_DEALID
                       AND RQ2.T_FIID         = GrDeal.T_FIID
                       AND RQ2.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                       AND RQ2.T_DEALPART     = 2
                       AND Lot2.t_DocKind     = 29 --DLDOC_PAYMENT
                       AND Lot2.t_DocID       = RQ2.t_ID
                       AND Lot2.t_Buy_Sale    = PM_WRITEOFF_SUM_SALE --Списание
                       AND Lot2.t_PartNum     = 0
                       AND Lot2.t_Party       = v_Party
                       AND Lot2.t_Contract    = v_Contract
                   )
     );


     -- 4.11. В дату поставки 1ч, ОР создать непоставленные лоты 2ч ОР
     FOR one_prm IN (SELECT RQ2.T_ID RQID2, RQ2.T_PLANDATE PlanDate2, RQ2.T_AMOUNT Amount, LOT.T_SUMID PARENTID,
                            LEG2.T_SUPPLYTIME SupplyTime2,
                            TK.T_DEALID DealID, TK.T_DEALDATE DealDate, TK.T_DEALCODE DealCode, TK.T_PORTFOLIOID Portfolio
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLGRDEAL_DBT GRDEAL, DDLRQ_DBT RQ, DDLRQ_DBT RQ2, DDL_TICK_DBT TK, DDL_LEG_DBT LEG2, DPMWRTSUM_DBT LOT
                      WHERE S.T_GRPID          = p_GrpID
                        AND S.T_TYPE           = 1
                        AND SD.T_SUBGRPID      = S.T_SUBGRPID
                        AND GRDEAL.T_ID        = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND   = RSB_SECUR.DL_SECURITYDOC
                        AND GRDEAL.T_PLANDATE  = v_Date
                        AND GRDEAL.T_TEMPLNUM  IN (RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR)
                        AND GRDEAL.T_FIID      = p_FIID
                        AND TK.T_DEALID        = GRDEAL.T_DOCID
                        AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN 1
                                      WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1
                                      ELSE 0 END)
                        AND TK.T_DEPARTMENT    = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID        = TK.T_DEALID
                        AND RQ.T_FIID         = GRDEAL.T_FIID
                        AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                        AND RQ.T_KIND         = DECODE(GRDEAL.T_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_DELIVERY, RSI_DLRQ.DLRQ_KIND_REQUEST /*Требование*/, RSI_DLRQ.DLRQ_KIND_COMMIT /*Обязательство*/)
                        AND RQ.T_DEALPART     = 1
                        AND EXISTS(SELECT 1
                                     FROM DDLGRACC_DBT GRACC
                                    WHERE GRACC.T_GRDEALID  = GRDEAL.T_ID
                                      AND GRACC.T_ACCNUM    = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                      AND GRACC.T_STATE     = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                  )
                        AND LEG2.T_LEGKIND    = 2 --ЦУ 2-й ч.
                        AND LEG2.T_DEALID     = TK.T_DEALID
                        AND LEG2.T_LEGID      = 0
                        AND RQ2.T_DOCKIND     = RQ.T_DOCKIND
                        AND RQ2.T_DOCID       = RQ.T_DOCID
                        AND RQ2.T_FIID        = RQ.T_FIID
                        AND RQ2.T_SUBKIND     = RQ.T_SUBKIND
                        AND RQ2.T_TYPE        = RQ.T_TYPE
                        AND RQ2.T_DEALPART    = 2
                        AND LOT.T_DOCKIND     = 29
                        AND LOT.T_DOCID       = RQ.T_ID
                        AND LOT.T_KIND        = WRTSUM_KIND_RRWAB1
                        AND LOT.T_PARTNUM     = 0
                        AND LOT.T_PARTY       = v_Party
                        AND LOT.T_CONTRACT    = v_Contract
                    )
     LOOP
       SetContextDeal( one_prm.DealID );
       SetContextFIID(p_FIID);

       v_Lot := NULL;

       v_Lot.T_SUMID            := 0;
       v_Lot.T_DOCKIND          := 29; /*DLDOC_PAYMENT*/
       v_Lot.T_DOCID            := one_prm.RQID2;
       v_Lot.T_PARTNUM          := 0;
       v_Lot.T_PARTY            := v_Party;
       v_Lot.T_CONTRACT         := v_Contract;
       v_Lot.T_FIID             := p_FIID;
       v_Lot.T_PORTFOLIO        := one_prm.Portfolio;---1;
       v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);
       v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
       v_Lot.T_KIND             := WRTSUM_KIND_RRWAS2; --Списание в РЕПО обратном БПП
       v_Lot.T_DATE             := one_prm.PlanDate2;
       v_Lot.T_TIME             := one_prm.SupplyTime2;
       v_Lot.T_AMOUNT           := one_prm.Amount;
       v_Lot.T_DEPARTMENT       := v_Department;
       v_Lot.T_DEALID           := one_prm.DealID;
       v_Lot.T_DEALDATE         := one_prm.DealDate;
       v_Lot.T_DEALCODE         := one_prm.DealCode;
       v_Lot.T_STATE            := PM_WRTSUM_NOTFORM;
       v_Lot.T_ENTERDATE        := one_prm.DealDate;
       v_Lot.T_STATEDATE        := one_prm.DealDate;
       v_Lot.T_INSTANCE         := 0;
       v_Lot.T_CHANGEDATE       := one_prm.DealDate;
       v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
       v_Lot.T_ID_OPERATION     := p_DocumentID;
       v_Lot.T_ID_STEP          := -1;
       v_Lot.T_TRUST            := CHR(0);
       v_Lot.T_PARENT           := one_prm.PARENTID;
       v_Lot.T_ACCFI            := v_DetermineAccFI;

       RSI_InsDfltIntoWRTSUM(v_Lot);
       INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;
     END LOOP;


     -- 4.12. В дату поставки 2ч обратного РЕПО занести суммы и статус "Поставлен" на лоты 2ч РЕПО
     INSERT INTO DPMWRTORDER_TMP
            ( T_ID, T_GRPID, T_GRDEALID, T_PLANTIME, T_SORT )
     (SELECT 0, p_GrpID, q.t_ID, q.t_PLANTIME, 5 -- Обработка 2ч ОР
        FROM (SELECT GRDEAL.T_ID, GRDEAL.T_PLANTIME
                FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLGRDEAL_DBT GRDEAL, DDL_TICK_DBT TK
               WHERE S.T_GRPID          = p_GrpID
                 AND S.T_TYPE           = 1
                 AND SD.T_SUBGRPID      = S.T_SUBGRPID
                 AND GRDEAL.T_ID        = SD.T_GRDEALID
                 AND GRDEAL.T_DOCKIND   = RSB_SECUR.DL_SECURITYDOC
                 AND GRDEAL.T_PLANDATE  = v_Date
                 AND GRDEAL.T_FIID      = p_FIID
                 AND GRDEAL.T_TEMPLNUM  IN (RSI_DLGR.DLGR_TEMPL_DELIVERY2, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2)
                 AND TK.T_DEALID        = GRDEAL.T_DOCID
                 AND TK.T_DEPARTMENT    = v_Department
                 AND 1 = (CASE WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY2 AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN 1
                               WHEN GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2 AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1
                               ELSE 0 END)
                 AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                 AND (v_OperType = 0 OR 
                      v_Kind_Operation != 0 OR 
                      1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                     RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                     RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                ELSE 0 END)
                     )
                 AND EXISTS(SELECT 1
                              FROM DDLGRACC_DBT GRACC
                             WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                               AND GRACC.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                               AND GRACC.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN --П
                           )
                 AND EXISTS(SELECT 1
                              FROM DDLRQ_DBT RQ
                             WHERE RQ.T_DOCID    = TK.T_DEALID
                               AND RQ.T_DOCKIND  = TK.T_BOFFICEKIND
                               AND RQ.T_STATE    = RSI_DLRQ.DLRQ_STATE_EXEC
                               AND RQ.T_SUBKIND  = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                               AND RQ.T_KIND     = DECODE(GRDEAL.T_TEMPLNUM, RSI_DLGR.DLGR_TEMPL_DELIVERY2, RSI_DLRQ.DLRQ_KIND_COMMIT, RSI_DLRQ.DLRQ_KIND_REQUEST)
                               AND RQ.T_TYPE     = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                               AND RQ.T_DEALPART = 2
                               AND RQ.T_FIID     = GRDEAL.T_FIID
                           )
               ORDER BY GRDEAL.T_PLANDATE ASC, GRDEAL.T_PLANTIME ASC, TK.T_DEALCODE ASC
             ) q
     );

     IF(Rsb_Common.GetRegFlagValue('SECUR\NOT_CHECK_TIME_OFFLINE') = chr(0) AND v_Party = -1) THEN
        v_CheckTime := 1;
     ELSE
        v_CheckTime := 0;
     END IF;

     -- 4.13. Обработать строки графика из очереди
     FOR one_grdeal IN (SELECT Ord.*
                          FROM DPMWRTORDER_TMP Ord, DDLGRDEAL_DBT GrDeal, DDL_TICK_DBT Tick
                         WHERE Ord.T_GRPID           = p_GrpID
                             AND Ord.T_GRDEALID      = GrDeal.t_ID
                             AND Tick.T_BOFFICEKIND = GrDeal.T_DOCKIND
                             AND Tick.T_DEALID          = GrDeal.T_DOCID
                        ORDER BY (CASE WHEN v_CheckTime = 1 AND v_Party = -1 THEN 0
                                       WHEN EXISTS(SELECT 1 
                                                     FROM DDLGRDOC_DBT GRDOC, DDLRQ_DBT RQ, DDL_TICK_DBT TK
                                                    WHERE GRDOC.T_GRDEALID = Ord.T_GRDEALID
                                                      AND GRDOC.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                                      AND GRDOC.T_SOURCETYPE = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                                                      AND RQ.T_ID = GRDOC.T_DOCID
                                                      AND TK.T_DEALID = RQ.T_DOCID
                                                      AND 1 = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract AND RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_REQUEST THEN 1
                                                                    WHEN TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract AND RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_COMMIT THEN 1
                                                                    ELSE 0 END)
                                                  ) THEN 1
                                       WHEN EXISTS(SELECT 1 
                                                     FROM DDLGRDEAL_DBT GRDEAL, DDLGRDEAL_DBT GRDEAL2, DPMWRTORDER_TMP Ord2, DDLGRDOC_DBT GRDOC, DDLRQ_DBT RQ, DDL_TICK_DBT TK
                                                    WHERE GRDEAL.T_ID = Ord.T_GRDEALID
                                                      AND GRDEAL2.T_DOCKIND = GRDEAL.T_DOCKIND
                                                      AND GRDEAL2.T_DOCID = GRDEAL.T_DOCID
                                                      AND GRDEAL2.T_ID <> GRDEAL.T_ID
                                                      AND Ord2.T_GRDEALID = GRDEAL2.T_ID
                                                      AND GRDOC.T_GRDEALID = Ord2.T_GRDEALID
                                                      AND GRDOC.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                                                      AND GRDOC.T_SOURCETYPE = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                                                      AND RQ.T_ID = GRDOC.T_DOCID
                                                      AND TK.T_DEALID = RQ.T_DOCID
                                                      AND 1 = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract AND RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_REQUEST THEN 1
                                                                    WHEN TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract AND RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_COMMIT THEN 1
                                                                    ELSE 0 END)
                                                  ) THEN 1
                                       ELSE 2 END
                                 ) ASC,
                                 Ord.T_PlanTime ASC, Ord.T_Sort ASC, 
                                 RSB_PMWRTOFF.WrtGetSortCode(GrDeal.t_DocID, GrDeal.t_DocKind, Tick.t_DealCode, Tick.t_DealCodeTS) ASC
                       )
     LOOP

        IF( one_grdeal.t_Sort = 1 ) THEN

           -- выполнить зачисление при исполнении компенсационной поставки по прямому РЕПО

           v_ExistNOSS := rsi_rsb_fiinstr.FI_ExistNOSS(p_FIID, v_Date, 27);
           FOR one_prm IN (
                           SELECT RQ.T_ID t_RQID, NVL(RQ.t_Amount,0) t_PayAmount, RQ2.T_ID t_RQID2, GrDeal.t_ID t_GrDealID, GrDeal.t_PlanTime t_Time, T.t_SortMode, Leg1.t_CFI,
                                  TK.t_DealID, TK.t_DealCode, TK.t_DealDate, TK.t_DealType, TK.t_BofficeKind
                             FROM DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal, DDLGRDEALPRM_DBT T, DDLGRDOC_DBT DOC, DDLRQ_DBT RQ, DDLRQ_DBT RQ2, DDL_LEG_DBT Leg1
                            WHERE GrDeal.t_ID      = one_grdeal.t_GrDealID
                              AND GrDeal.t_ID      = T.T_GRDEALID
                              AND TK.T_BOFFICEKIND = GrDeal.T_DOCKIND
                              AND TK.T_DEALID      = GrDeal.T_DOCID
                              AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                              AND (v_OperType = 0 OR 
                                   v_Kind_Operation != 0 OR 
                                   1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                  RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                  RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                             ELSE 0 END)
                                  )
                              AND DOC.T_GRDEALID     = GrDeal.t_ID
                              AND DOC.T_DOCKIND      = 29 --DLDOC_PAYMENT
                              AND DOC.T_SOURCETYPE   = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                              AND RQ.T_ID            = DOC.T_DOCID
                              AND RQ.t_DealPart      = 2
                              AND RQ.T_KIND          = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN RSI_DLRQ.DLRQ_KIND_REQUEST
                                                             ELSE RSI_DLRQ.DLRQ_KIND_COMMIT END)
                              AND RQ2.T_DOCKIND      = TK.T_BOFFICEKIND
                              AND RQ2.T_DOCID        = TK.T_DEALID
                              AND RQ2.T_FIID         = p_FIID
                              AND RQ2.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                              AND RQ2.T_DEALPART     = 2
                              AND Leg1.T_LEGKIND     = 0
                              AND Leg1.T_DEALID      = TK.T_DEALID
                              AND Leg1.T_LEGID       = 0
                          )
           LOOP
              SetContextDeal(one_prm.t_DealID);
              SetContextFIID(p_FIID);

              SumTP   := 0; NkdTP   := 0; BonusTP   := 0; NotWrtBonusTP   := 0;
              SumPPR  := 0; NkdPPR  := 0; BonusPPR  := 0; NotWrtBonusPPR  := 0;
              SumPUDP := 0; NkdPUDP := 0; BonusPUDP := 0; NotWrtBonusPUDP := 0;
              SumOD   := 0; NkdOD   := 0;
              SumPKU  := 0;
              SumPVO_KSU := 0;

              v_Amount := one_prm.t_PayAmount;

              -- для каждого LOT2 такого что
              FOR two_prm IN (
                              SELECT t_SumID
                                FROM dpmwrtsum_dbt
                               WHERE t_DocKind  = 29 -- DLDOC_PAYMENT
                                 AND t_DocID    = one_prm.t_RQID2
                                 AND t_State    in(PM_WRTSUM_NOTFORM, PM_WRTSUM_SALE_BPP)
                                 AND t_Buy_Sale <> PM_WRITEOFF_SUM_SALE
                                 AND t_FIID     = p_FIID
                                 AND t_Party    = v_Party
                                 AND t_Contract = v_Contract
                            ORDER BY (case when RSB_SECUR.IsDealKSU(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(one_prm.t_DealType, one_prm.t_BofficeKind))) = 1 then 1
                                           when one_prm.t_SortMode = 1 then (case when t_Portfolio = KINDPORT_TRADE  then 1
                                                                                  when t_Portfolio = KINDPORT_SALE   then 2
                                                                                  when t_Portfolio = KINDPORT_RETIRE then 3
                                                                                  when t_Portfolio = KINDPORT_CONTR  then 4
                                                                                  when t_Portfolio = KINDPORT_BACK   then 5
                                                                                  else 10 end)
                                                                       else (case when t_Portfolio = KINDPORT_RETIRE then 1
                                                                                  when t_Portfolio = KINDPORT_TRADE  then 2
                                                                                  when t_Portfolio = KINDPORT_SALE   then 3
                                                                                  when t_Portfolio = KINDPORT_CONTR  then 4
                                                                                  when t_Portfolio = KINDPORT_BACK   then 5
                                                                                  else 10 end) end), T_DATE ASC, T_TIME ASC, T_DEALDATE ASC, T_DEALCODE
                             )
              LOOP
                 -- Находим лот
                 BEGIN
                   SELECT * INTO v_Lot2
                     FROM DPMWRTSUM_DBT
                    WHERE t_SumID  = two_prm.t_SumID;
                 EXCEPTION
                    WHEN OTHERS THEN SetError( WRTOFF_ERROR_20200 );
                 END;

                 RSI_WRTSaveLot(v_Lot2.t_SumID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CDELIVERY);

                 v_RAmount := v_Lot2.t_Amount - v_Amount; -- Нескомпенсированный остаток Lot2

                 IF( v_RAmount <= 0 ) THEN -- скомпенсирован весь Lot2
                    IF( v_Lot2.t_Kind = WRTSUM_KIND_RRWAB2 ) THEN -- поставка для прямого репо по второй части
                       IF( v_Lot2.t_Portfolio = KINDPORT_BASICDEBT AND v_Date < NewRepoDate()) THEN -- Лот по ц/б, списанным из ПВО
                          --Если на момент поставки по 2 ч ц/б имеет ТСС -ТП, иначе - ППР
                          IF( (RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) ) and (v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR) ) THEN
                             v_Lot2.t_Portfolio := KINDPORT_SALE;
                          ELSIF( v_ExistNOSS = 1 ) THEN
                             v_Lot2.t_Portfolio := KINDPORT_TRADE;
                          ELSE
                             v_Lot2.t_Portfolio := KINDPORT_SALE;
                          END IF;

                          v_Lot2.t_GroupID  := RSI_GetWrtoffGroupByPortfolio(v_Lot2.t_Portfolio);
                          v_Lot2.t_Amount   := v_Lot2.t_AmountBD;
                          v_Lot2.t_AmountBD := 0.0;
                          v_Lot2.t_Currency := one_prm.t_CFI;

                          IF( (v_Lot2.t_Party = -1) or (v_Lot2.t_Trust = CHR(88)) ) THEN
                             v_Lot2.t_BalanceCost   := v_Lot2.t_BalanceCostBD;
                             v_Lot2.t_BalanceCostBD := 0.0;
                             v_Lot2.t_NKDAmount     := RSI_RSB_FIInstr.FI_CalcNKD(v_Lot2.t_FIID, v_Date, v_Lot2.T_AMOUNT, 0);
                             v_Lot2.t_Cost          := v_Lot2.t_BalanceCost - v_Lot2.t_NKDAmount;

                             --Только для облигаций по своим лотам
                             IF( ((v_Lot2.t_Party <= 0) or (v_Lot2.t_Party = RsbSessionData.OurBank)) and (RSI_RSB_FIInstr.FI_AvrKindsGetRoot(2, v_AvoirKind) = RSI_RSB_FIInstr.AVOIRKIND_BOND) ) THEN
                                v_Nominal := RSI_RSB_FIInstr.FI_GetNominalOnDate(p_FIID, v_Date);
                                v_Lot2.t_BegDiscount := round(v_Lot2.t_Amount * v_Nominal, 2) - v_Lot2.t_Cost;
                                IF( v_Lot2.t_BegDiscount < 0 ) THEN
                                   v_Lot2.t_BegDiscount := 0;
                                END IF;
                                v_Lot2.t_BegBonus := v_Lot2.t_Cost - round(v_Lot2.t_Amount * v_Nominal, 2);
                                IF( v_Lot2.t_BegBonus < 0 ) THEN
                                   v_Lot2.t_BegBonus := 0;
                                END IF;
                                v_Lot2.t_BegInterestDate := v_Lot2.t_Date;
                                IF( v_Lot2.t_BegDiscount > 0 ) THEN
                                   v_Lot2.t_BegDiscountDate := v_Lot2.t_Date;
                                END IF;

                                IF( v_Lot2.t_BegDefDiff <> 0 ) THEN
                                   v_Lot2.t_BegDefDiffDate := v_Lot2.t_Date;
                                END IF;
                                IF( v_AmortizationMethod = PM_WRITEOFF_AVERAGE ) THEN
                                   v_Lot2.t_BegDiscountDate := v_Lot2.t_Date;
                                   v_Lot2.t_BegBonusDate    := v_Lot2.t_Date;
                                   v_Lot2.t_BegDefDiffDate  := v_Lot2.t_Date;
                                   v_Lot2.t_CorrDate        := v_Lot2.t_Date;
                                END IF;
                             END IF;
                          END IF;

                          v_Lot2.t_Sum  := round(RSI_RSB_FIInstr.ConvSum(v_Lot2.t_Cost, v_FaceValueFI, one_prm.t_CFI, v_Date, 0), 2);
                          v_Lot2.t_Time := one_prm.t_Time;
                          v_Lot2.t_Date := v_Date;

                          IF( (v_Lot2.t_Party = -1) or (v_Lot2.t_Trust = CHR(88)) ) THEN
                             v_Lot2.t_BegDate      := v_Lot2.t_Date;
                             v_Lot2.t_BegBonusDate := v_Lot2.t_Date;
                          END IF;
                       ELSE
                         IF v_Lot2.t_Portfolio = KINDPORT_BASICDEBT THEN
                           v_Lot2.t_Portfolio := KINDPORT_BACK;
                         END IF;

                         IF v_Lot2.t_Portfolio = KINDPORT_BACK_BPP_KSU THEN
                           v_Lot2.t_Portfolio := KINDPORT_BACK_KSU;
                         END IF;
                       END IF;

                       v_Lot2.t_State        := PM_WRTSUM_FORM;
                       v_Lot2.t_ID_Operation := p_DocumentID;
                       v_Lot2.t_ID_Step      := v_Party;
                       v_Lot2.t_Contract     := v_Contract;
                       v_Lot2.t_ActivateDate := v_Date;

                       IF( v_Lot2.t_Portfolio = KINDPORT_TRADE ) THEN
                          SumTP := SumTP + v_Lot2.t_Cost + v_Lot2.t_NKDAmount;
                          NkdTP := NkdTP + v_Lot2.t_NKDAmount;
                          BonusTP := BonusTP + v_Lot2.t_BegBonus - v_Lot2.t_Bonus + v_Lot2.t_OldBonus;
                          NotWrtBonusTP := NotWrtBonusTP + v_Lot2.T_NOTWRTBONUS;
                       ELSIF( v_Lot2.t_Portfolio = KINDPORT_SALE ) THEN
                          SumPPR := SumPPR + v_Lot2.t_Cost + v_Lot2.t_NKDAmount;
                          NkdPPR := NkdPPR + v_Lot2.t_NKDAmount;
                          BonusPPR := BonusPPR + v_Lot2.t_BegBonus - v_Lot2.t_Bonus + v_Lot2.t_OldBonus;
                          NotWrtBonusPPR := NotWrtBonusPPR + v_Lot2.T_NOTWRTBONUS;
                       ELSIF( v_Lot2.t_Portfolio = KINDPORT_RETIRE ) THEN
                          SumPUDP := SumPUDP + v_Lot2.t_Cost + v_Lot2.t_NKDAmount;
                          NkdPUDP := NkdPUDP + v_Lot2.t_NKDAmount;
                          BonusPUDP := BonusPUDP + v_Lot2.t_BegBonus - v_Lot2.t_Bonus + v_Lot2.t_OldBonus;
                          NotWrtBonusPUDP := NotWrtBonusPUDP + v_Lot2.T_NOTWRTBONUS;
                       ELSIF( v_Lot2.t_Portfolio = KINDPORT_BASICDEBT OR v_Lot2.t_Portfolio = KINDPORT_BACK ) THEN
                          SumOD := SumOD + v_Lot2.t_BalanceCost;
                          NkdOD := NkdOD + v_Lot2.t_NKDAmount;
                       ELSIF( v_Lot2.t_Portfolio = KINDPORT_CONTR ) THEN
                          SumPKU := SumPKU + v_Lot2.t_BalanceCost;
                       ELSIF(v_Lot2.t_Portfolio = KINDPORT_BACK_BPP_KSU OR v_Lot2.t_Portfolio = KINDPORT_BACK_KSU ) THEN
                          SumPVO_KSU := SumPVO_KSU + v_Lot2.t_BalanceCost;
                       END IF;

                       UPDATE DPMWRTSUM_DBT
                          SET t_Portfolio       = v_Lot2.t_Portfolio,
                              t_GroupID         = v_Lot2.t_GroupID,
                              t_Amount          = v_Lot2.t_Amount,
                              t_AmountBD        = v_Lot2.t_AmountBD,
                              t_Sum             = v_Lot2.t_Sum,
                              t_Currency        = v_Lot2.t_Currency,
                              t_BalanceCost     = v_Lot2.t_BalanceCost,
                              t_BalanceCostBD   = v_Lot2.t_BalanceCostBD,
                              t_NKDAmount       = v_Lot2.t_NKDAmount,
                              t_Cost            = v_Lot2.t_Cost,
                              t_BegDiscount     = v_Lot2.t_BegDiscount,
                              t_BegBonus        = v_Lot2.t_BegBonus,
                              t_BegDefDiff      = v_Lot2.t_BegDefDiff,
                              t_BegInterestDate = v_Lot2.t_BegInterestDate,
                              t_BegDiscountDate = v_Lot2.t_BegDiscountDate,
                              t_BegBonusDate    = v_Lot2.t_BegBonusDate,
                              t_BegDefDiffDate  = v_Lot2.t_BegDefDiffDate,
                              t_CorrDate        = v_Lot2.t_CorrDate,
                              t_Time            = v_Lot2.t_Time,
                              t_Date            = v_Lot2.t_Date,
                              t_BegDate         = v_Lot2.t_BegDate,
                              t_State           = v_Lot2.t_State,
                              t_ID_Operation    = v_Lot2.t_ID_Operation,
                              t_ID_Step         = v_Lot2.t_ID_Step,
                              t_ActivateDate    = v_Lot2.t_ActivateDate
                        WHERE t_SumID = v_Lot2.t_SumID;
                    END IF;

                    v_Amount := v_Amount - v_Lot2.t_Amount;
                 ELSE -- скомпенсирован не весь Lot2
                    v_SAmount := least(v_Amount, v_Lot2.t_Amount);
                    v_Rate    := v_RAmount / v_Lot2.t_Amount;

                    v_Val := 0;
                    IF( (v_Lot2.t_Portfolio = KINDPORT_TRADE) or
                        (v_Lot2.t_Portfolio = KINDPORT_SALE) or
                        (v_Lot2.t_Portfolio = KINDPORT_RETIRE) or
                        (v_Lot2.t_Portfolio = KINDPORT_BASICDEBT)
                      ) THEN
                       IF( (v_FaceValueFI = RSI_RSB_FIInstr.NATCUR) and
                           (v_Lot2.t_OverAmount != 0 or v_Lot2.T_CORRVALUE <> 0 or v_Lot2.T_CORRINTTOEIR <> 0 or v_Lot2.T_HEDGCORR <> 0 or v_Lot2.T_AMORTHEDGCORR <> 0) ) THEN
                          v_Val := v_Lot2.t_OverAmount + v_Lot2.T_CORRVALUE + v_Lot2.T_CORRINTTOEIR + v_Lot2.T_HEDGCORR + v_Lot2.T_AMORTHEDGCORR;
                       ELSE
                          v_Val := v_Lot2.t_BalanceCost - v_Lot2.t_Cost - v_Lot2.t_NKDAmount - v_Lot2.t_InterestIncome - v_Lot2.t_DiscountIncome - v_Lot2.t_CostPFI;
                       END IF;
                    ELSIF( v_Lot2.t_Portfolio = KINDPORT_CONTR ) THEN
                       v_Val := 0;
                    END IF;

                    v_Lot := v_Lot2;

                    v_Lot.t_SumID              := 0;
                    v_Lot.t_DocID              := one_prm.t_RQID;
                    v_Lot.t_PartNum            := 1;
                    v_Lot.t_Amount             := v_SAmount;
                    v_Lot.t_AmountBD           := 0;
                    v_Lot.t_BalanceCostBD      := 0;
                    v_Lot.t_OverAmountBD       := 0;
                    v_Lot.t_Instance           := 0;
                    v_Lot.t_EnterDate          := v_Date;
                    v_Lot.t_ChangeDate         := v_Date;
                    v_Lot.t_State              := PM_WRTSUM_FORM;
                    v_Lot.t_Action             := PM_WRT_UPDTMODE_CDELIVERY;
                    v_Lot.t_ID_Operation       := p_DocumentID;
                    v_Lot.t_ID_Step            := -1;
                    v_Lot.t_Parent             := v_Lot2.t_Parent;
                    v_Lot.t_Source             := v_Lot2.t_SumID;

                    v_Lot.t_ActivateDate       := v_Date;
                    v_Lot.t_ActivateTime       := one_prm.t_Time;
                    v_Lot.t_BlockAmount        := 0;

                    IF( v_Lot.t_Portfolio = KINDPORT_BASICDEBT AND v_Date < NewRepoDate()) THEN
                       IF( (RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) ) and (v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR) ) THEN
                          v_Lot.t_Portfolio := KINDPORT_SALE;
                       ELSIF( v_ExistNOSS = 1 ) THEN
                          v_Lot.t_Portfolio := KINDPORT_TRADE;
                       ELSE
                          v_Lot.t_Portfolio := KINDPORT_SALE;
                       END IF;
                       v_Lot.t_GroupID      := RSI_GetWrtoffGroupByPortfolio(v_Lot.t_Portfolio);
                       v_Lot.t_Date         := v_Date;
                       v_Lot.t_Time         := one_prm.t_Time;
                       v_Lot.t_NKDAmount    := RSI_RSB_FIInstr.FI_CalcNKD(v_Lot.t_FIID, v_Date, v_Lot.T_AMOUNT, 0);
                       v_Lot.t_BalanceCost  := v_Lot2.t_BalanceCostBD - round(v_Lot2.t_BalanceCostBD * v_RAmount / v_Lot2.t_AmountBD, 2);
                       v_Lot.t_OverAmount   := 0;
                       v_Lot.t_Cost         := v_Lot.t_BalanceCost - v_Lot.t_NKDAmount;
                       v_Lot.t_Currency     := one_prm.t_CFI;
                       v_Lot.t_Sum          := round(RSI_RSB_FIInstr.ConvSum(v_Lot.t_Cost, v_FaceValueFI, one_prm.t_CFI, v_Date, 0), 2);

                       v_Nominal := RSI_RSB_FIInstr.FI_GetNominalOnDate(v_Lot.t_FIID, v_Date);

                       IF( (v_Nominal * v_Lot.t_Amount - v_Lot.t_Cost) > 0 ) THEN
                          v_Lot.t_BegDiscount := round(v_Nominal * v_Lot.t_Amount - v_Lot.t_Cost, 2);
                       ELSE
                          v_Lot.t_BegDiscount := 0;
                       END IF;

                       IF( (v_Lot.t_Cost - v_Nominal * v_Lot.t_Amount) > 0 ) THEN
                          v_Lot.t_BegBonus := round(v_Lot.t_Cost - v_Nominal * v_Lot.t_Amount, 2);
                       ELSE
                          v_Lot.t_BegBonus := 0;
                       END IF;

                       v_Lot.t_BegDate         := v_Date;
                       v_Lot.t_BegInterestDate := v_Date;

                       IF( v_Lot.t_BegDiscount > 0 ) THEN
                          v_Lot.t_BegDiscountDate := v_Date;
                       END IF;

                       IF( v_Lot.t_BegBonus > 0 ) THEN
                          v_Lot.t_BegBonusDate := v_Date;
                       END IF;

                       IF( v_Lot.t_BegDefDiff <> 0 ) THEN
                          v_Lot.t_BegDefDiffDate := v_Date;
                       END IF;

                       IF( v_AmortizationMethod = PM_WRITEOFF_AVERAGE ) THEN
                          v_Lot.t_BegDiscountDate := v_Date;
                          v_Lot.t_BegBonusDate    := v_Date;
                          v_Lot.t_BegDefDiffDate  := v_Date;
                          v_Lot.t_CorrDate        := v_Date;
                       END IF;

                       v_Lot.t_DealID         := one_prm.t_DealID;
                       v_Lot.t_DealCode       := one_prm.t_DealCode;
                       v_Lot.t_DealDate       := one_prm.t_DealDate;
                       v_Lot.T_NOTWRTBONUS    := 0;
                       v_Lot.T_ACCFI          := v_DetermineAccFI;
                       v_Lot.T_ACCBALANCECOST := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;
                    ELSE
                       IF v_Lot2.t_Portfolio = KINDPORT_BASICDEBT THEN
                         v_Lot.t_Portfolio := KINDPORT_BACK;

                         IF v_Lot2.t_Source > 0 THEN
                           v_Lot.t_Source := v_Lot2.t_Source;
                         END IF;
                       END IF;

                       IF v_Lot2.t_Portfolio = KINDPORT_BACK_BPP_KSU THEN
                         v_Lot.t_Portfolio := KINDPORT_BACK_KSU;

                         IF v_Lot2.t_Source > 0 THEN
                           v_Lot.t_Source := v_Lot2.t_Source;
                         END IF;
                       END IF;

                       v_Lot.t_Sum              := v_Lot2.t_Sum             - round(v_Lot2.t_Sum * v_Rate, 2);
                       v_Lot.t_NKDAmount        := v_Lot2.t_NKDAmount       - round(v_Lot2.t_NKDAmount * v_Rate, 2);
                       v_Lot.t_InterestIncome   := v_Lot2.t_InterestIncome  - round(v_Lot2.t_InterestIncome * v_Rate, 2);
                       v_Lot.t_NotCarryInterest := v_Lot2.t_NotCarryInterest- round(v_Lot2.t_NotCarryInterest * v_Rate, 2);
                       v_Lot.t_BegDiscount      := v_Lot2.t_BegDiscount     - round(v_Lot2.t_BegDiscount * v_Rate, 2);
                       v_Lot.t_BegBonus         := v_Lot2.t_BegBonus        - round(v_Lot2.t_BegBonus * v_Rate, 2);
                       v_Lot.t_DiscountIncome   := v_Lot2.t_DiscountIncome  - round(v_Lot2.t_DiscountIncome * v_Rate, 2);
                       v_Lot.t_NotCarryDiscount := v_Lot2.t_NotCarryDiscount- round(v_Lot2.t_NotCarryDiscount * v_Rate, 2);
                       v_Lot.t_Cost             := v_Lot2.t_Cost            - round(v_Lot2.t_Cost * v_Rate, 2);
                       v_Lot.T_COSTPFI          := v_Lot2.T_COSTPFI         - round(v_Lot2.T_COSTPFI * v_Rate, 2);
                       v_Lot.t_BalanceCost      := v_Lot.t_Cost + v_Lot.t_NKDAmount + v_Lot.t_InterestIncome + v_Lot.t_DiscountIncome + v_Lot.T_COSTPFI + v_Val - round(v_Val * v_Rate, 2);
                       v_Lot.t_ReservAmount     := v_Lot2.t_ReservAmount    - round(v_Lot2.t_ReservAmount * v_Rate, 2);
                       v_Lot.t_IncomeReserv     := v_Lot2.t_IncomeReserv    - round(v_Lot2.t_IncomeReserv * v_Rate, 2);
                       v_Lot.t_OverAmount       := v_Lot2.t_OverAmount      - round(v_Lot2.t_OverAmount * v_Rate, 2);
                       v_Lot.t_Outlay           := v_Lot2.t_Outlay          - round(v_Lot2.t_Outlay * v_Rate, 2);
                       v_Lot.t_DISCOUNTCORR     := v_Lot2.t_DISCOUNTCORR    - round(v_Lot2.t_DISCOUNTCORR * v_Rate, 2);
                       v_Lot.t_OLDBEGBONUS      := v_Lot2.t_OLDBEGBONUS     - round(v_Lot2.t_OLDBEGBONUS * v_Rate, 2);
                       v_Lot.t_Bonus            := v_Lot2.t_Bonus           - round(v_Lot2.t_Bonus * v_Rate, 2);
                       v_Lot.t_OldBonus         := v_Lot2.t_OldBonus        - round(v_Lot2.t_OldBonus * v_Rate, 2);
                       v_Lot.t_OLDBEGDISCOUNT   := v_Lot2.t_OLDBEGDISCOUNT  - round(v_Lot2.t_OLDBEGDISCOUNT * v_Rate, 2);
                       v_Lot.T_NOTWRTBONUS      := v_Lot2.T_NOTWRTBONUS     - round(v_Lot2.T_NOTWRTBONUS * v_Rate, 2);

                       IF v_Lot2.T_BLOCKAMOUNT > 0 THEN
                         v_Lot.T_BLOCKAMOUNT    := v_Lot2.T_BLOCKAMOUNT     - round(v_Lot2.t_Amount - v_Lot.t_Amount, 2);
                       ELSE
                         v_Lot.T_BLOCKAMOUNT    := 0;
                       END IF;

                       v_Lot.T_ACCFI            := v_DetermineAccFI;
                       v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

                       v_Lot.T_BEGDEFDIFF         := v_Lot2.T_BEGDEFDIFF       - round(v_Lot2.T_BEGDEFDIFF * v_Rate, 2);
                       v_Lot.T_ACCOUNTEDDEFDIFF   := v_Lot2.T_ACCOUNTEDDEFDIFF - round(v_Lot2.T_ACCOUNTEDDEFDIFF * v_Rate, 2);
                       v_Lot.T_DEFDIFFDATE        := v_Lot2.T_DEFDIFFDATE;
                       v_Lot.T_WRTOUTLAY          := v_Lot2.T_WRTOUTLAY        - round(v_Lot2.T_WRTOUTLAY * v_Rate, 2);
                       v_Lot.T_WRTOUTLAYDATE      := v_Lot2.T_WRTOUTLAYDATE;
                       v_Lot.T_VATOUTLAY          := v_Lot2.T_VATOUTLAY        - round(v_Lot2.T_VATOUTLAY * v_Rate, 2);
                       v_Lot.T_WRTVATOUTLAY       := v_Lot2.T_WRTVATOUTLAY     - round(v_Lot2.T_WRTVATOUTLAY * v_Rate, 2);
                       v_Lot.T_EFFECTINTERESTRATE := v_Lot2.T_EFFECTINTERESTRATE;
                       v_Lot.T_FAIRVALUE          := v_Lot2.T_FAIRVALUE        - round(v_Lot2.T_FAIRVALUE * v_Rate, 2);
                       v_Lot.T_AMORTCOST          := v_Lot2.T_AMORTCOST        - round(v_Lot2.T_AMORTCOST * v_Rate, 2);
                       v_Lot.T_AMORTCOSTDATE      := v_Lot2.T_AMORTCOSTDATE;
                       v_Lot.T_CORRVALUE          := v_Lot2.T_CORRVALUE        - round(v_Lot2.T_CORRVALUE * v_Rate, 2);
                       v_Lot.T_AMORTCALCKIND      := v_Lot2.T_AMORTCALCKIND;
                       v_Lot.T_ESTRESERVE         := v_Lot2.T_ESTRESERVE       - round(v_Lot2.T_ESTRESERVE * v_Rate, 2);
                       v_Lot.T_ESTRESERVEDATE     := v_Lot2.T_ESTRESERVEDATE;
                       v_Lot.T_CORRINTTOEIR       := v_Lot2.T_CORRINTTOEIR     - round(v_Lot2.T_CORRINTTOEIR * v_Rate, 2);
                       v_Lot.T_CORRINTTOEIRDATE   := v_Lot2.T_CORRINTTOEIRDATE;
                       v_Lot.T_CORRESTRESERVE     := v_Lot2.T_CORRESTRESERVE   - round(v_Lot2.T_CORRESTRESERVE * v_Rate, 2);
                       v_Lot.T_CORRESTRESERVEDATE := v_Lot2.T_CORRESTRESERVEDATE;
                       v_Lot.T_HEDGCORR           := v_Lot2.T_HEDGCORR         - round(v_Lot2.T_HEDGCORR * v_Rate, 2);
                       v_Lot.T_HEDGCORRDATE       := v_Lot2.T_HEDGCORRDATE;
                       v_Lot.T_AMORTHEDGCORR      := v_Lot2.T_AMORTHEDGCORR    - round(v_Lot2.T_AMORTHEDGCORR * v_Rate, 2);
                       v_Lot.T_AMORTHEDGCORRDATE  := v_Lot2.T_AMORTHEDGCORRDATE;
                    END IF;

                    IF( v_Lot2.t_Portfolio = KINDPORT_TRADE ) THEN
                       SumTP := SumTP + v_Lot.t_Cost + v_Lot.t_NKDAmount;
                       NkdTP := NkdTP + v_Lot.t_NKDAmount;
                       BonusTP := BonusTP + v_Lot.t_BegBonus - v_Lot.t_Bonus + v_Lot.t_OldBonus;
                       NotWrtBonusTP := NotWrtBonusTP + v_Lot.T_NOTWRTBONUS;
                    ELSIF( v_Lot2.t_Portfolio = KINDPORT_SALE ) THEN
                       SumPPR := SumPPR + v_Lot.t_Cost + v_Lot.t_NKDAmount;
                       NkdPPR := NkdPPR + v_Lot.t_NKDAmount;
                       BonusPPR := BonusPPR + v_Lot.t_BegBonus - v_Lot.t_Bonus + v_Lot.t_OldBonus;
                       NotWrtBonusPPR := NotWrtBonusPPR + v_Lot.T_NOTWRTBONUS;
                    ELSIF( v_Lot2.t_Portfolio = KINDPORT_RETIRE ) THEN
                       SumPUDP := SumPUDP + v_Lot.t_Cost + v_Lot.t_NKDAmount;
                       NkdPUDP := NkdPUDP + v_Lot.t_NKDAmount;
                       BonusPUDP := BonusPUDP + v_Lot.t_BegBonus - v_Lot.t_Bonus + v_Lot.t_OldBonus;
                       NotWrtBonusPUDP := NotWrtBonusPUDP + v_Lot.T_NOTWRTBONUS;
                    ELSIF( v_Lot2.t_Portfolio = KINDPORT_BASICDEBT OR v_Lot2.t_Portfolio = KINDPORT_BACK ) THEN
                       SumOD := SumOD + v_Lot.t_BalanceCost;
                       NkdOD := NkdOD + v_Lot.t_NKDAmount;
                    ELSIF( v_Lot2.t_Portfolio = KINDPORT_CONTR ) THEN
                       SumPKU := SumPKU + v_Lot.t_BalanceCost;
                    ELSIF(v_Lot2.t_Portfolio = KINDPORT_BACK_BPP_KSU OR v_Lot2.t_Portfolio = KINDPORT_BACK_KSU) THEN
                       SumPVO_KSU := SumPVO_KSU + v_Lot.t_BalanceCost;
                    END IF;

                    RSI_InsDfltIntoWRTSUM(v_Lot);
                    RSI_WRTCompensWrt(v_Lot, p_DocumentID, -1, v_Lot2.t_SumID);

                    v_Amount := v_Amount - v_Lot.t_Amount;
                 END IF;

              EXIT WHEN( v_Amount <= 0 );
              END LOOP;

              IF( SumTP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_SUMTP, v_Date, SumTP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NkdTP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_NKDTP, v_Date, NkdTP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( BonusTP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_BONUSTP, v_Date, BonusTP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NotWrtBonusTP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_NOTCARRY_BONUS_TRADE, v_Date, NotWrtBonusTP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( SumPPR != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_SUMPPR, v_Date, SumPPR, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NkdPPR != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_NKDPPR, v_Date, NkdPPR, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( BonusPPR != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_BONUSPPR, v_Date, BonusPPR, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NotWrtBonusPPR != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_NOTCARRY_BONUS_SALE, v_Date, NotWrtBonusPPR, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( SumPUDP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_SUMPUDP, v_Date, SumPUDP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NkdPUDP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_NKDPUDP, v_Date, NkdPUDP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( BonusPUDP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_BONUSPUDP, v_Date, BonusPUDP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NotWrtBonusPUDP != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_NOTCARRY_BONUS_RETIRE, v_Date, NotWrtBonusPUDP, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( SumOD != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_SUMOD, v_Date, SumOD, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( NkdOD != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_NKDOD, v_Date, NkdOD, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( SumPVO_KSU != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_SUMBACKKSU, v_Date, SumPVO_KSU, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
              IF( SumPKU != 0 ) THEN
                 INSERT INTO DDLSUM_DBT (T_DLSUMID, t_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                                 VALUES (0, 29, one_prm.t_RQID, RSB_SECUR.DLSUM_COMPDEL_SUMPKU, v_Date, SumPKU, 0, v_FaceValueFI, CHR(0), 0, p_GrpID, p_FIID);
              END IF;
           END LOOP;

        ELSIF( one_grdeal.t_Sort = 2 ) THEN

           -- обработать 2ч ПР
           FOR one_rq IN (SELECT RQ.T_ID RQID, RQ.T_FACTDATE FACTDATE, RQ.T_KIND,
                                 RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                                 LEG2.T_COST COST2, LEG2.T_CFI CFI2, LEG.T_PRINCIPAL PRINCIPAL, TK.T_DEALID, LEG2.T_SupplyTime SupplyTime2
                            FROM DDLGRDEAL_DBT GrDeal, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDL_LEG_DBT LEG2
                           WHERE GrDeal.t_ID       = one_grdeal.t_GrDealID
                             AND TK.T_BOFFICEKIND  = GrDeal.T_DOCKIND
                             AND TK.T_DEALID       = GrDeal.T_DOCID
                             AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                             AND (v_OperType = 0 OR 
                                  v_Kind_Operation != 0 OR 
                                  1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                            WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                            WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                 RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                 RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                            ELSE 0 END)
                                 )
                             AND RQ.T_KIND         = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN RSI_DLRQ.DLRQ_KIND_REQUEST
                                                           ELSE RSI_DLRQ.DLRQ_KIND_COMMIT END)
                             AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                             AND RQ.T_DOCID        = TK.T_DEALID
                             AND RQ.T_FIID         = p_FIID
                             AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                             AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                             AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                             AND RQ.T_DEALPART     = 2
                             AND LEG.T_LEGKIND     = 0
                             AND LEG.T_DEALID      = TK.T_DEALID
                             AND LEG.T_LEGID       = 0
                             AND LEG2.T_LEGKIND    = 2
                             AND LEG2.T_DEALID     = TK.T_DEALID
                             AND LEG2.T_LEGID      = 0
                         )
           LOOP
             SetContextDeal(one_rq.t_DealID);
             SetContextFIID(p_FIID);

             v_ExistNOSS := rsi_rsb_fiinstr.FI_ExistNOSS( p_FIID, one_rq.FACTDATE, 27 );

             -- По всем непоставленным лотам 2ч (а их может быть несколко для случая 2ч ПР!)
             FOR one_wrt IN (SELECT LOT.T_SUMID SUMID, LOT.T_AMOUNT AMOUNT, LOT.T_AMOUNTBD AMOUNTBD, LOT.T_FIID FIID, LOT.T_KIND KIND, LOT.T_PORTFOLIO PORTFOLIO,
                                    LOT.T_SUM LOTSUM, LOT.T_BALANCECOSTBD BALANCECOSTBD, LOT.T_NKDAMOUNT NKDAMOUNT, LOT.T_PARENT PARENT, LOT.T_SOURCE SOURCE,
                                    LOT.T_DOCKIND DOCKIND, LOT.T_DOCID DOCID, LOT.T_DATE LOTDATE, LOT.T_TIME LOTTIME, LOT.T_CURRENCY CURRENCY, LOT.T_OVERAMOUNTBD OVERAMOUNTBD,
                                    LOT.T_DEPARTMENT DEPARTMENT, LOT.T_DEALID DEALID, LOT.T_DEALDATE DEALDATE, LOT.T_DEALCODE DEALCODE, LOT.T_ENTERDATE ENTERDATE,
                                    (SELECT MAX(LOT1.T_PARTNUM) FROM DPMWRTSUM_DBT LOT1 WHERE LOT1.T_DOCKIND = LOT.T_DOCKIND AND LOT1.T_DOCID = LOT.T_DOCID) MAXPARTNUM
                               FROM DPMWRTSUM_DBT LOT
                              WHERE LOT.T_DOCKIND = 29
                                AND LOT.T_DOCID = one_rq.RQID
                                AND LOT.T_STATE IN (PM_WRTSUM_SALE_BPP, PM_WRTSUM_NOTFORM)
                                AND LOT.T_PARTY    = v_Party
                                AND LOT.T_CONTRACT = v_Contract
                            )
             LOOP

               RSI_WRTSaveLot( one_wrt.SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_DELIVERY );

               IF one_wrt.KIND = WRTSUM_KIND_RRWAB2 AND one_wrt.PORTFOLIO = KINDPORT_BASICDEBT AND one_wrt.Source = 0 THEN

                   IF( (RSI_RSB_FIInstr.FI_IsAvrKindBond(v_AvoirKind) ) and (v_FaceValueFI <> RSI_RSB_FIInstr.NATCUR) ) THEN
                     v_Portfolio := KINDPORT_SALE;
                   ELSIF v_ExistNOSS = 1 THEN
                     v_Portfolio := KINDPORT_TRADE;
                   ELSE
                     v_Portfolio := KINDPORT_SALE;
                   END IF;

                   v_GroupID := RSI_GetWrtoffGroupByPortfolio(v_Portfolio);

                   v_Sum := ROUND((one_rq.COST2 * one_wrt.AMOUNT / one_rq.PRINCIPAL), 2);
                   v_Cost := one_wrt.BALANCECOSTBD - one_wrt.NKDAMOUNT;

                   v_BegDiscount := 0;
                   IF v_NeedChargeIncome = 1 THEN
                     v_BegDiscount := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(one_wrt.FIID, one_rq.FactDate)* one_wrt.Amount, 2) - v_Cost;
                   END IF;

                   v_BegBonus := 0;
                   IF v_NeedChargeIncome = 1 THEN
                     v_BegBonus := v_Cost - ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(one_wrt.FIID, one_rq.FactDate)* one_wrt.Amount, 2);
                   END IF;

                   RSI_InsDfltIntoWRTSUM(v_Lot);

                   UPDATE DPMWRTSUM_DBT
                      SET T_DATE = one_rq.FACTDATE,
                          T_STATE = PM_WRTSUM_FORM,
                          T_STATEDATE = one_rq.FACTDATE,
                          T_CHANGEDATE = one_rq.FACTDATE,
                          T_ACTION = PM_WRT_UPDTMODE_DELIVERY,
                          T_ID_OPERATION = p_DocumentID,
                          T_ID_STEP = -1,
                          T_PORTFOLIO = v_Portfolio,
                          T_GROUPID = v_GroupID,
                          T_SUM = v_Sum,
                          T_AMOUNTBD = 0,
                          T_CURRENCY = one_rq.CFI2,
                          T_BALANCECOST = T_BALANCECOSTBD,
                          T_COST = v_Cost,
                          T_BEGINTERESTDATE = (CASE WHEN v_NeedChargeInterestIncome = 1 THEN one_rq.FACTDATE ELSE T_BEGINTERESTDATE END),
                          T_BEGDATE = one_rq.FACTDATE,
                          T_BEGDISCOUNTDATE = (CASE WHEN v_NeedChargeIncome = 1 AND v_BegDiscount > 0 THEN one_rq.FACTDATE ELSE T_BEGDISCOUNTDATE END),
                          T_BEGDISCOUNT = (CASE WHEN v_BegDiscount < 0 THEN 0 ELSE v_BegDiscount END),
                          T_BEGBONUSDATE = (CASE WHEN v_NeedChargeIncome = 1 AND v_BegBonus > 0 THEN one_rq.FACTDATE ELSE T_BEGBONUSDATE END),
                          T_BEGBONUS = (CASE WHEN v_BegBonus < 0 THEN 0 ELSE v_BegBonus END),
                          T_OVERAMOUNTBD = 0,
                          T_ACTIVATEDATE = one_rq.FACTDATE,
                          T_ACTIVATETIME = one_rq.SupplyTime2

                    WHERE T_SUMID = one_wrt.SUMID;

               ELSE

                 v_Portfolio := one_wrt.Portfolio;
                 IF v_Portfolio = KINDPORT_BASICDEBT THEN
                   v_Portfolio := KINDPORT_BACK;
                 END IF;

                 IF v_Portfolio = KINDPORT_BACK_BPP_KSU THEN
                   v_Portfolio := KINDPORT_BACK_KSU;
                 END IF;

                 UPDATE DPMWRTSUM_DBT
                    SET T_STATE = PM_WRTSUM_FORM,
                        T_PORTFOLIO = v_Portfolio,
                        T_STATEDATE = one_rq.FACTDATE,
                        T_CHANGEDATE = one_rq.FACTDATE,
                        T_ACTION = PM_WRT_UPDTMODE_DELIVERY,
                        T_ID_OPERATION = p_DocumentID,
                        T_ID_STEP = -1,
                        T_ACTIVATEDATE = one_rq.FACTDATE,
                        T_ACTIVATETIME = one_rq.SupplyTime2

                  WHERE T_SUMID = one_wrt.SUMID;
               END IF;

             END LOOP;
           END LOOP;

        ELSIF( one_grdeal.t_Sort = 3 ) THEN

           -- обработать лот компенсации при увеличении обеспечения в обратном РЕПО на корзину ц/б или при комп. поставке (увеличении) в РЕПО не на корзину

           FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                                  DocRQ.T_DOCID T_RQID1, T.T_FIID, T.t_Date, GrDeal.T_PLANTIME, T.t_Principal, T.t_TotalCost, T.t_CostFIID, T.t_NKD,
                                  TK.t_DealID, TK.t_DealDate, TK.t_DealCode, TK.t_BOFFICEKIND, TK.T_PORTFOLIOID,
                                  LEG2.t_SupplyTime SupplyTime2
                             FROM DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal, DDL_TICK_ENS_DBT T, DDLGRDOC_DBT DocRQ, DDLGRDOC_DBT DocENS, DDL_LEG_DBT LEG2
                            WHERE GrDeal.t_ID       = one_grdeal.t_GrDealID
                              AND TK.T_BOFFICEKIND  = GrDeal.T_DOCKIND
                              AND TK.T_DEALID       = GrDeal.T_DOCID
                              AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                              AND (v_OperType = 0 OR 
                                   v_Kind_Operation != 0 OR 
                                   1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                  RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                  RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                             ELSE 0 END)
                                  )
                              AND LEG2.T_LEGKIND      = 2 --ЦУ 2-й ч.
                              AND LEG2.T_DEALID       = TK.T_DEALID
                              AND LEG2.T_LEGID        = 0
                              AND T.T_FIID            = GrDeal.T_FIID
                              AND T.T_DATE            = v_Date
                              AND T.T_Kind            = RSB_SECUR.TICKENS_KIND_IN
                              AND DocRQ.T_GRDEALID    = GrDeal.t_ID
                              AND DocRQ.T_DOCKIND     = 29 --DLDOC_PAYMENT
                              AND DocRQ.T_SOURCETYPE  = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                              AND DocENS.T_GRDEALID   = GrDeal.t_ID
                              AND DocENS.T_DOCKIND    = 4723 --DL_DOCTICKENS
                              AND DocENS.T_DOCID      = T.T_ID
                              AND DocENS.T_SOURCETYPE = RSI_DLGR.DLGR_SOURCETYPE_ENS
                              AND 1 = (CASE WHEN GrDeal.t_TemplNum = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY AND RSB_SECUR.IsBuy(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 /*обратное*/ THEN 1
                                            WHEN GrDeal.t_TemplNum = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR AND RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 /*прямое*/ THEN 1
                                            ELSE 0 END)
                          )
           LOOP
             SetContextDeal(one_prm.t_DealID);
             SetContextFIID(p_FIID);

             v_Lot := NULL;

             v_Lot.T_SUMID    := 0;
             v_Lot.T_DOCKIND  := 29; --DLDOC_PAYMENT
             v_Lot.T_DOCID    := one_prm.T_RQID1;
             v_Lot.T_PARTY    := v_Party;
             v_Lot.T_CONTRACT := v_Contract;
             v_Lot.T_FIID     := one_prm.T_FIID;
             v_Lot.T_DATE     := one_prm.T_DATE;
             v_Lot.T_TIME     := one_prm.T_PLANTIME;
             v_Lot.T_AMOUNT   := one_prm.t_Principal;
             v_Lot.T_SUM      := one_prm.t_TotalCost;
             v_Lot.T_CURRENCY := one_prm.t_CostFIID;
             v_Lot.T_COST     := RSI_RSB_FIInstr.ConvSum(one_prm.t_TotalCost, one_prm.t_CostFIID, RSI_RSB_FIInstr.NATCUR, one_prm.T_DATE, 0);
             if( v_NKDRound_Kind = 1 ) then
                v_Lot.T_NKDAMOUNT := ROUND(one_prm.t_NKD, 2) * one_prm.t_Principal;
             else
                v_Lot.T_NKDAMOUNT := ROUND(one_prm.t_NKD * one_prm.t_Principal, 2);
             end if;
             v_Lot.T_BALANCECOST  := v_Lot.T_COST + v_Lot.T_NKDAMOUNT;
             v_Lot.T_DEPARTMENT   := v_Department;
             v_Lot.T_DEALID       := one_prm.t_DealID;
             v_Lot.T_DEALDATE     := one_prm.t_DealDate;
             v_Lot.T_DEALCODE     := one_prm.t_DealCode;
             v_Lot.T_STATE        := PM_WRTSUM_FORM;
             v_Lot.T_ENTERDATE    := one_prm.t_Date;
             v_Lot.T_STATEDATE    := one_prm.t_Date;
             v_Lot.T_CHANGEDATE   := one_prm.t_Date;
             v_Lot.T_ACTION       := PM_WRT_UPDTMODE_CREATE;
             v_Lot.T_ID_OPERATION := p_DocumentID;
             v_Lot.T_ID_STEP      := -1;

             v_Lot.T_PARTNUM   := 0;

             IF v_Party > 0 THEN
               v_Lot.T_PORTFOLIO := KINDPORT_CLIENT;
             ELSE
               IF RSB_SECUR.IsDealKSU(one_prm.OGroup) = 1 THEN
                 v_Lot.T_PORTFOLIO := KINDPORT_BACK_KSU; --ПВО_КСУ
               ELSE
                 v_Lot.T_PORTFOLIO := KINDPORT_BACK; --ПВО
               END IF;
             END IF;

             v_Lot.T_BUY_SALE  := PM_WRITEOFF_SUM_BUY_BO; --Зачисление на ВО
             v_Lot.T_KIND      := WRTSUM_KIND_RRWAB1; --Зачисление в Репо обратном БПП
             v_Lot.T_BEGDATE   := one_prm.T_DATE;

             IF( v_NeedChargeIncome = 1 ) THEN --Только по облигациям
               v_Lot.T_BEGDISCOUNT := ROUND(RSI_RSB_FIInstr.FI_GetNominalOnDate(one_prm.T_FIID, one_prm.T_DATE)*one_prm.t_Principal - v_Lot.T_Cost, 2);

               IF v_Lot.T_BEGDISCOUNT < 0 THEN
                 v_Lot.T_BEGDISCOUNT := 0;
               END IF;

               IF v_Lot.T_BEGDISCOUNT > 0 THEN
                 v_Lot.T_BEGDISCOUNTDATE := one_prm.T_DATE;
               END IF;
             END IF;

             IF( v_NeedChargeIncome = 1 ) THEN --Только для облигаций
                v_Lot.T_BEGINTERESTDATE := one_prm.T_DATE;
                v_Lot.T_BEGBONUS := ROUND(v_Lot.T_Cost - RSI_RSB_FIInstr.FI_GetNominalOnDate(one_prm.T_FIID, one_prm.T_DATE)*one_prm.t_Principal, 2);

                IF( v_Lot.T_BEGBONUS > 0 ) THEN
                   v_Lot.T_BEGBONUSDATE := one_prm.T_DATE;
                ELSE
                   v_Lot.T_BEGBONUS := 0;
                END IF;
             END IF;

             v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);

             v_Lot.T_ACTIVATEDATE     := one_prm.T_DATE;
             v_Lot.T_ACTIVATETIME     := one_prm.T_PLANTIME;
             v_Lot.t_BlockAmount      := 0;
             v_Lot.T_ACCFI            := v_DetermineAccFI;
             v_Lot.T_ACCOUNTEDDEFDIFF := ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, RSI_RSB_FIInstr.NATCUR, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2);

             RSI_InsDfltIntoWRTSUM(v_Lot);
             INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;

             -- Для обратного РЕПО, для каждого лота пополнения обеспечения, создать по одному лоту 2ч
              BEGIN
                 SELECT * INTO v_RQ2
                   FROM DDLRQ_DBT
                  WHERE T_DOCKIND  = one_prm.t_BOFFICEKIND
                    AND T_DOCID    = one_prm.t_DealID
                    AND T_DEALPART = 2
                    AND T_SUBKIND  = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                    AND T_TYPE     = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                    AND T_FIID     = p_FIID;
              EXCEPTION
                 WHEN OTHERS THEN v_RQ2 := NULL;
              END;

              SELECT MAX(t_PartNum) INTO v_MaxPartNum
                FROM DPMWRTSUM_DBT
               WHERE t_DocKind  = 29 --DLDOC_PAYMENT
                 AND t_DocID    = NVL(v_RQ2.t_ID, -1)
                 AND t_Buy_Sale = PM_WRITEOFF_SUM_SALE; --Списание

              v_Lot2 := NULL;
              v_Lot2.T_SUMID        := 0;
              v_Lot2.T_DOCKIND      := 29; --DLDOC_PAYMENT
              v_Lot2.T_DOCID        := v_RQ2.t_ID;
              v_Lot2.T_PARTNUM      := v_MaxPartNum + 1;
              v_Lot2.T_PARTY        := v_Party;
              v_Lot2.T_CONTRACT     := v_Contract;
              v_Lot2.T_FIID         := p_FIID;
              v_Lot2.T_PORTFOLIO    := one_prm.t_PortfolioID;
              v_Lot2.T_GROUPID      := RSI_GetWrtoffGroupByPortfolio(v_Lot2.T_PORTFOLIO);
              v_Lot2.T_BUY_SALE     := PM_WRITEOFF_SUM_SALE; --Списание
              v_Lot2.T_KIND         := WRTSUM_KIND_RRWAS2; --Списание в РЕПО обратном БПП
              v_Lot2.T_DATE         := v_RQ2.t_PlanDate;
              v_Lot2.T_TIME         := one_prm.SupplyTime2;
              v_Lot2.T_AMOUNT       := one_prm.t_Principal;
              v_Lot2.T_DEPARTMENT   := v_Department;
              v_Lot2.T_DEALID       := one_prm.t_DealID;
              v_Lot2.T_DEALDATE     := one_prm.t_DealDate;
              v_Lot2.T_DEALCODE     := one_prm.t_DealCode;
              v_Lot2.T_STATE        := PM_WRTSUM_NOTFORM;
              v_Lot2.T_ENTERDATE    := v_Date;
              v_Lot2.T_STATEDATE    := v_Date;
              v_Lot2.T_INSTANCE     := 0;
              v_Lot2.T_CHANGEDATE   := v_Date;
              v_Lot2.T_ACTION       := PM_WRT_UPDTMODE_CREATE;
              v_Lot2.T_ID_OPERATION := p_DocumentID;
              v_Lot2.T_ID_STEP      := -1;
              v_Lot2.T_TRUST        := CHR(0);
              v_Lot2.T_PARENT       := v_Lot.T_SUMID;
              v_Lot2.T_DATE         := v_RQ2.t_PlanDate;
              v_Lot2.T_TIME         := one_prm.SupplyTime2;

              RSI_InsDfltIntoWRTSUM(v_Lot2);
              INSERT INTO DPMWRTSUM_DBT VALUES v_Lot2 RETURNING t_SUMID INTO v_Lot2.T_SUMID;

           END LOOP;

        ELSIF( one_grdeal.t_Sort = 6 ) THEN

           -- обработать продажу/списание/1ч прямого РЕПО/1ч размещения займа по этой строке графика

           FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                                  RQ.T_ID RQID, RQ.T_FIID FIID, RQ.T_AMOUNT Amount, RQ.T_FACTDATE FactDate, RQ.T_PLANDATE PlanDate,
                                  LEG.T_COST Cost, LEG.T_TOTALCOST TotalCost, LEG.T_CFI CFI, LEG.T_NKD NKD, LEG.T_NKDFIID NKDFIID, LEG.t_CliringChange CliringChange, LEG.T_SUPPLYTIME SupplyTime,
                                  LEG.T_START StartDate, LEG.T_INTERESTSTART InterestStart, LEG.T_ID LegRecID,
                                  TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALTIME DealTime, TK.T_NUMBER_COUPON Number_Coupon,
                                  TK.T_NUMBER_PARTLY Number_Partly, TK.T_DEALCODE DealCode, TK.T_PORTFOLIOID PortfolioID,
                                  TK.T_PREOUTLAY PreOutlay, TK.T_PREOUTLAYFIID PreOutlayFIID,
                                  NVL(RQP.T_AMOUNT,0) PayAmount, NVL(RQP.T_FIID, -1) RqpFIID,
                                  (CASE WHEN TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1 ELSE 0 END) as SalePartyClient
                             FROM DDLGRDEAL_DBT GrDeal, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDLRQ_DBT RQP
                            WHERE GrDeal.t_ID       = one_grdeal.t_GrDealID
                              AND TK.T_BOFFICEKIND  = GrDeal.T_DOCKIND
                              AND TK.T_DEALID       = GrDeal.T_DOCID
                              AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                              AND (v_OperType = 0 OR 
                                   v_Kind_Operation != 0 OR 
                                   1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                  RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                  RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                             ELSE 0 END)
                                  )
                              AND LEG.T_LEGKIND     = 0
                              AND LEG.T_DEALID      = TK.T_DEALID
                              AND LEG.T_LEGID       = 0
                              AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                              AND RQ.T_DOCID        = TK.T_DEALID
                              AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                              AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                              AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                              AND RQ.T_KIND         = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN RSI_DLRQ.DLRQ_KIND_COMMIT
                                                            ELSE RSI_DLRQ.DLRQ_KIND_REQUEST END)
                              AND RQ.T_DEALPART     = 1
                              AND RQ.T_FIID         = p_FIID
                              AND RQP.T_DOCKIND  (+)= RQ.T_DOCKIND
                              AND RQP.T_DOCID    (+)= RQ.T_DOCID
                              AND RQP.T_TYPE     (+)= RSI_DLRQ.DLRQ_TYPE_PAYMENT --Оплата
                              AND RQP.T_DEALPART (+)= RQ.T_DEALPART
                          )
           LOOP

              SetContextDeal(one_prm.DealID);
              SetContextFIID(p_FIID);

              v_Lot := NULL;

              IF RSB_SECUR.IsTwoPart(one_prm.OGroup) = 1 THEN --РЕПО или займ (обрабатываем 1ч.)

                IF (one_prm.SalePartyClient = 0 AND RSB_SECUR.IsSale(one_prm.OGroup) = 1) OR  --Прямое РЕПО, размещение займа для клиента
                   (one_prm.SalePartyClient = 1 AND RSB_SECUR.IsBuy(one_prm.OGroup) = 1) THEN --Обратное РЕПО для клиента-контрагента

                  v_Lot.T_SUMID            := 0;
                  v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
                  v_Lot.T_DOCID            := one_prm.RQID;
                  v_Lot.T_PARTNUM          := 0;
                  v_Lot.T_PARTY            := v_Party;
                  v_Lot.T_CONTRACT         := v_Contract;
                  v_Lot.T_FIID             := one_prm.FIID;
                  v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
                  v_Lot.T_KIND             := WRTSUM_KIND_RRWAS1; --Списание в РЕПО прямом БПП
                  v_Lot.T_DATE             := one_prm.FactDate;
                  v_Lot.T_TIME             := one_prm.SupplyTime;
                  v_Lot.T_DEPARTMENT       := v_Department;
                  v_Lot.T_DEALID           := one_prm.DealID;
                  v_Lot.T_DEALDATE         := one_prm.DealDate;
                  v_Lot.T_DEALCODE         := one_prm.DealCode;
                  v_Lot.T_STATE            := PM_WRTSUM_FORM;
                  v_Lot.T_ENTERDATE        := one_prm.DealDate;
                  v_Lot.T_STATEDATE        := one_prm.FactDate;
                  v_Lot.T_INSTANCE         := 0;
                  v_Lot.T_CHANGEDATE       := one_prm.FactDate;
                  v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
                  v_Lot.T_ID_OPERATION     := p_DocumentID;
                  v_Lot.T_ID_STEP          := -1;
                  v_Lot.T_TRUST            := CHR(0);
                  v_Lot.T_ACTIVATEDATE     := one_prm.FactDate;
                  v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
                  v_Lot.t_BlockAmount      := 0;

                  IF( RSB_SECUR.IsBasket(one_prm.OGroup) = 1 ) THEN
                     v_Lot.T_AMOUNT   := 0;
                     v_Lot.T_SUM      := 0;
                     v_Lot.T_CURRENCY := -1;
                     v_NKD_ := 0;
                     BEGIN
                        SELECT t_Principal, t_TotalCost, t_CostFIID, t_NKD
                          INTO v_Lot.T_AMOUNT, v_Lot.T_SUM, v_Lot.T_CURRENCY, v_NKD_
                          FROM DDL_TICK_ENS_DBT
                         WHERE t_DealID = one_prm.DealID
                           AND t_Date   = one_prm.PlanDate
                           AND t_FIID   = one_prm.FIID;
                     EXCEPTION
                        WHEN OTHERS THEN NULL;
                     END;

                     v_Lot.T_COST := RSI_RSB_FIInstr.ConvSum(v_Lot.T_SUM, v_Lot.T_CURRENCY, v_FaceValueFI, one_prm.FactDate, 0);
                     if( v_NKDRound_Kind = 1 ) then
                        v_Lot.T_NKDAMOUNT := ROUND(v_NKD_, 2) * v_Lot.T_AMOUNT;
                     else
                        v_Lot.T_NKDAMOUNT := ROUND(v_NKD_ * v_Lot.T_AMOUNT, 2);
                     end if;
                     v_Lot.T_BALANCECOST := v_Lot.T_COST + v_Lot.T_NKDAMOUNT;
                  ELSE
                     v_Lot.T_AMOUNT           := one_prm.Amount;
                     v_Lot.T_SUM              := one_prm.Cost;
                     v_Lot.T_CURRENCY         := one_prm.CFI;

                     IF RSB_SECUR.IsLoan(one_prm.OGroup) = 1 THEN
                        v_Lot.T_BALANCECOST := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.TotalCost, one_prm.CFI, v_FaceValueFI, one_prm.FactDate, 1), 2);
                     ELSE
                        v_Lot.T_BALANCECOST := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.PayAmount, one_prm.RqpFIID, v_FaceValueFI, one_prm.FactDate, 1), 2);
                     END IF;

                     v_Lot.T_NKDAMOUNT        := 0;
                     IF v_NeedChargeIncome = 1 THEN
                        IF( one_prm.NKDFIID = v_FaceValueFI ) THEN
                           v_Lot.T_NKDAMOUNT := one_prm.NKD;
                        ELSE
                           v_Lot.T_NKDAMOUNT := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.NKD, one_prm.NKDFIID, v_FaceValueFI, one_prm.DealDate, 1),2);
                        END IF;
                     END IF;
                     v_Lot.T_COST := v_Lot.T_BALANCECOST - v_Lot.T_NKDAMOUNT;
                  END IF;

                  v_Lot.T_ACCFI            := v_DetermineAccFI;
                  v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

                END IF;

              ELSIF RSB_SECUR.IsAvrWrtOut(one_prm.OGroup) = 1 THEN --Списание

                v_Lot.T_SUMID            := 0;
                v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
                v_Lot.T_DOCID            := one_prm.RQID;
                v_Lot.T_PARTNUM          := 0;
                v_Lot.T_PARTY            := v_Party;
                v_Lot.T_CONTRACT         := v_Contract;
                v_Lot.T_FIID             := one_prm.FIID;
                v_Lot.T_PORTFOLIO        := one_prm.PortfolioID;
                v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO, 1);
                v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
                v_Lot.T_KIND             := WRTSUM_KIND_FS; --Списание лота
                v_Lot.T_DATE             := one_prm.DealDate;
                v_Lot.T_TIME             := one_prm.DealTime;
                v_Lot.T_AMOUNT           := one_prm.Amount;
                v_Lot.T_SUM              := one_prm.Cost;
                v_Lot.T_CURRENCY         := one_prm.CFI;

                IF( v_Lot.T_PORTFOLIO = KINDPORT_CONTR ) THEN
                   v_FIPKU := RSI_RSB_FIInstr.NATCUR;
                ELSE
                   v_FIPKU := v_FaceValueFI;
                END IF;

                v_Lot.T_BALANCECOST      := ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.TotalCost, one_prm.CFI, v_FIPKU, one_prm.DealDate, 1 ),2);

                v_Lot.T_NKDAMOUNT        := 0;
                IF v_NeedChargeIncome = 1 THEN
                  v_Lot.T_NKDAMOUNT      := one_prm.NKD;
                END IF;

                v_Lot.T_COST             := v_Lot.T_BALANCECOST - v_Lot.T_NKDAMOUNT;

                v_Lot.T_DEPARTMENT       := v_Department;
                v_Lot.T_DEALID           := one_prm.DealID;
                v_Lot.T_DEALDATE         := one_prm.DealDate;
                v_Lot.T_DEALCODE         := one_prm.DealCode;
                v_Lot.T_STATE            := PM_WRTSUM_FORM;
                v_Lot.T_ENTERDATE        := one_prm.DealDate;
                v_Lot.T_STATEDATE        := one_prm.DealDate;
                v_Lot.T_INSTANCE         := 0;
                v_Lot.T_CHANGEDATE       := one_prm.DealDate;
                v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
                v_Lot.T_ID_OPERATION     := p_DocumentID;
                v_Lot.T_ID_STEP          := -1;
                v_Lot.T_TRUST            := CHR(0);
                v_Lot.T_ACTIVATEDATE     := one_prm.DealDate;
                v_Lot.T_ACTIVATETIME     := one_prm.DealTime;
                v_Lot.T_BlockAmount      := 0;
                v_Lot.T_ACCFI            := v_DetermineAccFI;
                v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FIPKU, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

              ELSIF (one_prm.SalePartyClient = 0 AND RSB_SECUR.IsSale(one_prm.OGroup) = 1) OR --Продажа для клиента
                    (one_prm.SalePartyClient = 1 AND RSB_SECUR.IsBuy(one_prm.OGroup) = 1) THEN --Покупка для лкиента-контрагента

                v_Lot.T_SUMID            := 0;
                v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
                v_Lot.T_DOCID            := one_prm.RQID;
                v_Lot.T_PARTNUM          := 0;
                v_Lot.T_PARTY            := v_Party;
                v_Lot.T_CONTRACT         := v_Contract;
                v_Lot.T_FIID             := one_prm.FIID;
                v_Lot.T_PORTFOLIO        := one_prm.PortfolioID;
                v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);
                v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
                v_Lot.T_KIND             := WRTSUM_KIND_S; --Продажа
                v_Lot.T_DATE             := one_prm.FactDate;
                v_Lot.T_TIME             := one_prm.SupplyTime;
                v_Lot.T_AMOUNT           := one_prm.Amount;
                v_Lot.T_SUM              := one_prm.Cost;
                v_Lot.T_CURRENCY         := one_prm.CFI;

                IF( v_Lot.T_PORTFOLIO = KINDPORT_CONTR ) THEN
                   v_FIPKU := RSI_RSB_FIInstr.NATCUR;
                ELSE
                   v_FIPKU := v_FaceValueFI;
                END IF;

                v_Lot.T_BALANCECOST      := ROUND(RSI_RSB_FIInstr.ConvSum( one_prm.TotalCost, one_prm.CFI, v_FIPKU, v_Lot.T_DATE, 1 ),2);

                v_Lot.T_NKDAMOUNT        := 0;
                IF v_NeedChargeIncome = 1 THEN
                  v_Lot.T_NKDAMOUNT      := one_prm.NKD;
                END IF;

                v_Lot.T_COST := v_Lot.T_BALANCECOST - v_Lot.T_NKDAMOUNT;

                v_Lot.T_DEPARTMENT       := v_Department;
                v_Lot.T_DEALID           := one_prm.DealID;
                v_Lot.T_DEALDATE         := one_prm.DealDate;
                v_Lot.T_DEALCODE         := one_prm.DealCode;
                v_Lot.T_STATE            := PM_WRTSUM_FORM;
                v_Lot.T_ENTERDATE        := one_prm.DealDate;
                v_Lot.T_STATEDATE        := one_prm.FactDate;
                v_Lot.T_INSTANCE         := 0;
                v_Lot.T_CHANGEDATE       := one_prm.FactDate;
                v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
                v_Lot.T_ID_OPERATION     := p_DocumentID;
                v_Lot.T_ID_STEP          := -1;
                v_Lot.T_TRUST            := CHR(0);
                v_Lot.T_ACTIVATEDATE     := one_prm.FactDate;
                v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
                v_Lot.T_BLOCKAMOUNT      := 0;
                v_Lot.T_ACCFI            := v_DetermineAccFI;
                v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FIPKU, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

              END IF;

              IF v_Lot.T_SUMID IS NOT NULL THEN
                RSI_InsDfltIntoWRTSUM(v_Lot);
                INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;
              END IF;

              RSI_WRTLinkSaleLot(v_Lot, p_DocumentID, p_GrpID, p_UseContr); -- ПР 1ч, продажи

           END LOOP;

        ELSIF( one_grdeal.t_Sort = 7 ) THEN

           -- обработать лот компенсации при увеличении обеспечения в прямом РЕПО на корзину ц/б или при комп. поставке (увеличении) в РЕПО не на корзину

           FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                                  DocRQ.T_DOCID T_RQID1, T.T_FIID, T.t_Date, GrDeal.T_PLANTIME, T.t_Principal, T.t_TotalCost, T.t_CostFIID, T.t_NKD,
                                  TK.t_DealID, TK.t_DealDate, TK.t_DealCode, TK.t_BOFFICEKIND, TK.T_PORTFOLIOID,
                                  LEG2.t_SupplyTime SupplyTime2
                             FROM DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal, DDL_TICK_ENS_DBT T, DDLGRDOC_DBT DocRQ, DDLGRDOC_DBT DocENS, DDL_LEG_DBT LEG2
                            WHERE GrDeal.t_ID       = one_grdeal.t_GrDealID
                              AND TK.T_BOFFICEKIND  = GrDeal.T_DOCKIND
                              AND TK.T_DEALID       = GrDeal.T_DOCID
                              AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                              AND (v_OperType = 0 OR 
                                   v_Kind_Operation != 0 OR 
                                   1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                  RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                  RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                             ELSE 0 END)
                                  )
                              AND LEG2.T_LEGKIND      = 2 --ЦУ 2-й ч.
                              AND LEG2.T_DEALID       = TK.T_DEALID
                              AND LEG2.T_LEGID        = 0
                              AND T.T_FIID            = GrDeal.T_FIID
                              AND T.T_DATE            = v_Date
                              AND T.T_Kind            = RSB_SECUR.TICKENS_KIND_IN
                              AND DocRQ.T_GRDEALID    = GrDeal.t_ID
                              AND DocRQ.T_DOCKIND     = 29 --DLDOC_PAYMENT
                              AND DocRQ.T_SOURCETYPE  = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                              AND DocENS.T_GRDEALID   = GrDeal.t_ID
                              AND DocENS.T_DOCKIND    = 4723 --DL_DOCTICKENS
                              AND DocENS.T_DOCID      = T.T_ID
                              AND DocENS.T_SOURCETYPE = RSI_DLGR.DLGR_SOURCETYPE_ENS
                              AND 1 = (CASE WHEN GrDeal.t_TemplNum = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY AND RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 /*прямое*/ THEN 1
                                            WHEN GrDeal.t_TemplNum = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR AND RSB_SECUR.IsBuy(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) = 1 /*обратное*/ THEN 1
                                            ELSE 0 END)
                          )
           LOOP
             SetContextDeal(one_prm.t_DealID);
             SetContextFIID(p_FIID);

             v_Lot := NULL;

             v_Lot.T_SUMID    := 0;
             v_Lot.T_DOCKIND  := 29; --DLDOC_PAYMENT
             v_Lot.T_DOCID    := one_prm.T_RQID1;
             v_Lot.T_PARTY    := v_Party;
             v_Lot.T_CONTRACT := v_Contract;
             v_Lot.T_FIID     := one_prm.T_FIID;
             v_Lot.T_DATE     := one_prm.T_DATE;
             v_Lot.T_TIME     := one_prm.T_PLANTIME;
             v_Lot.T_AMOUNT   := one_prm.t_Principal;
             v_Lot.T_SUM      := one_prm.t_TotalCost;
             v_Lot.T_CURRENCY := one_prm.t_CostFIID;
             v_Lot.T_COST     := RSI_RSB_FIInstr.ConvSum(one_prm.t_TotalCost, one_prm.t_CostFIID, RSI_RSB_FIInstr.NATCUR, one_prm.T_DATE, 0);
             if( v_NKDRound_Kind = 1 ) then
                v_Lot.T_NKDAMOUNT := ROUND(one_prm.t_NKD, 2) * one_prm.t_Principal;
             else
                v_Lot.T_NKDAMOUNT := ROUND(one_prm.t_NKD * one_prm.t_Principal, 2);
             end if;
             v_Lot.T_BALANCECOST  := v_Lot.T_COST + v_Lot.T_NKDAMOUNT;
             v_Lot.T_DEPARTMENT   := v_Department;
             v_Lot.T_DEALID       := one_prm.t_DealID;
             v_Lot.T_DEALDATE     := one_prm.t_DealDate;
             v_Lot.T_DEALCODE     := one_prm.t_DealCode;
             v_Lot.T_STATE        := PM_WRTSUM_FORM;
             v_Lot.T_ENTERDATE    := one_prm.t_Date;
             v_Lot.T_STATEDATE    := one_prm.t_Date;
             v_Lot.T_CHANGEDATE   := one_prm.t_Date;
             v_Lot.T_ACTION       := PM_WRT_UPDTMODE_CREATE;
             v_Lot.T_ID_OPERATION := p_DocumentID;
             v_Lot.T_ID_STEP      := -1;

             v_Lot.T_PARTNUM      := 1;
             v_Lot.T_BUY_SALE     := PM_WRITEOFF_SUM_SALE; --Списание
             v_Lot.T_KIND         := WRTSUM_KIND_RRWAS1; --Списание в Репо прямом БПП

             v_Lot.T_GROUPID      := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);

             v_Lot.T_ACTIVATEDATE := one_prm.T_DATE;
             v_Lot.T_ACTIVATETIME := one_prm.T_PLANTIME;
             v_Lot.T_ACCFI          := v_DetermineAccFI;
             v_Lot.T_ACCBALANCECOST := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, RSI_RSB_FIInstr.NATCUR, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

             RSI_InsDfltIntoWRTSUM(v_Lot);
             INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;

             RSI_WRTLinkSaleLot(v_Lot, p_DocumentID, p_GrpID, p_UseContr); -- увел. обесп. ПР 1ч

           END LOOP;

        ELSIF( one_grdeal.t_Sort = 4 ) THEN

           -- обработать компенсацию-уменьшение в обратном РЕПО, создать лот списания за дату компенсации и уменьшить количество в лоте 2ч
           FOR one_prm IN (
                           SELECT RQ.T_ID t_RQID, Lot2.t_FIID t_FIID, Lot2.t_GroupID t_GroupID, Lot2.t_Portfolio t_Portfolio, GrDeal.t_PlanTime t_Time, NVL(RQ.t_Amount,0) t_PayAmount, Lot2.t_Amount t_Amount,
                                  Lot2.t_AmountBD t_AmountBD, Lot2.t_BalanceCostBD t_BalanceCostBD, Lot2.t_OverAmountBD t_OverAmountBD, Leg1.t_Principal t_Principal1, Leg2.t_Principal t_Principal2,
                                  Leg2.t_Cost t_Cost2, Lot2.t_Currency t_Currency, TK.t_DealID, TK.t_DealDate, TK.t_DealCode, Lot2.t_Parent, Lot2.t_SumID, TK.t_DealType, TK.t_BofficeKind,
                                  Lot2.t_DocKind t_Lot2DocKind, Lot2.t_DocID t_Lot2DocID, Lot2.t_Time t_Lot2Time
                             FROM DDL_TICK_DBT TK, DDLGRDEAL_DBT GrDeal, DDLGRDOC_DBT DOC, DDLRQ_DBT RQ, DDLRQ_DBT RQ2, DPMWRTSUM_DBT Lot2, DDL_LEG_DBT Leg1, DDL_LEG_DBT Leg2
                            WHERE GrDeal.t_ID        = one_grdeal.t_GrDealID
                              AND TK.T_BOFFICEKIND = GrDeal.T_DOCKIND
                              AND TK.T_DEALID      = GrDeal.T_DOCID
                              AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                              AND (v_OperType = 0 OR 
                                   v_Kind_Operation != 0 OR 
                                   1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                             WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                  RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                  RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                             ELSE 0 END)
                                  )
                              AND DOC.T_GRDEALID     = GrDeal.t_ID
                              AND DOC.T_DOCKIND      = 29 --DLDOC_PAYMENT
                              AND DOC.T_SOURCETYPE   = RSI_DLGR.DLGR_SOURCETYPE_DLRQ
                              AND RQ.T_ID            = DOC.T_DOCID
                              AND RQ.t_DealPart      = 2
                              AND RQ.T_KIND          = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN RSI_DLRQ.DLRQ_KIND_COMMIT
                                                             ELSE RSI_DLRQ.DLRQ_KIND_REQUEST END)
                              AND RQ2.T_DOCKIND      = TK.T_BOFFICEKIND
                              AND RQ2.T_DOCID        = TK.T_DEALID
                              AND RQ2.T_FIID         = p_FIID
                              AND RQ2.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                              AND RQ2.T_DEALPART     = 2
                              AND Lot2.t_DocKind     = 29 --DLDOC_PAYMENT
                              AND Lot2.t_DocID       = RQ2.t_ID
                              AND Lot2.t_Buy_Sale    = PM_WRITEOFF_SUM_SALE --Списание
                              AND Lot2.t_PartNum     = 0
                              AND Lot2.t_Party       = v_Party
                              AND Lot2.t_Contract    = v_Contract
                              AND Leg1.T_LEGKIND     = 0
                              AND Leg1.T_DEALID      = TK.T_DEALID
                              AND Leg1.T_LEGID       = 0
                              AND Leg2.T_LEGKIND     = 2
                              AND Leg2.T_DEALID      = TK.T_DEALID
                              AND Leg2.T_LEGID       = 0
                          )
           LOOP
             SetContextDeal(one_prm.t_DealID);
             SetContextFIID(p_FIID );

             v_Lot := NULL;

             IF RSB_SECUR.IsDealKSU(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(one_prm.t_DealType, one_prm.t_BofficeKind))) = 1 THEN --КСУ

               SELECT NVL(SUM(Buy2.t_Amount),0) INTO v_AmountPVO
                 FROM DPMWRTSUM_DBT Buy2
                WHERE (Buy2.t_Source = one_prm.t_Parent OR Buy2.t_SumID = one_prm.t_Parent)
                  AND Buy2.t_Portfolio = KINDPORT_BACK_KSU
                  AND Buy2.t_State     = PM_WRTSUM_FORM;

               SELECT NVL(SUM(Buy2.t_Amount),0) INTO v_AmountPVOBPP
                 FROM DPMWRTSUM_DBT Buy2
                WHERE Buy2.t_Source    = one_prm.t_Parent
                  AND Buy2.t_Portfolio = KINDPORT_BACK_BPP_KSU
                  AND Buy2.t_State     = PM_WRTSUM_NOTFORM;

               v_Amount0 := least(one_prm.t_Amount, one_prm.t_PayAmount);

               IF v_Amount0 <= v_AmountPVO THEN
                 v_Amount := v_Amount0;
                 v_SaleRepoAmount := 0;
               ELSIF v_Amount0 < v_AmountPVO + v_AmountPVOBPP THEN
                 v_Amount := v_AmountPVO;
                 v_SaleRepoAmount := v_Amount0 - v_AmountPVO;
               ELSE
                 v_Amount := v_Amount0 - v_AmountPVOBPP;
                 v_SaleRepoAmount := v_AmountPVOBPP;
               END IF;

               v_Old := one_prm.t_Principal1 - one_prm.t_Amount;

               v_Cost := RSI_RSB_FIInstr.ConvSum(one_prm.t_Cost2, one_prm.t_Currency, v_FaceValueFI, v_Date, 0);

               --Создается лот списания

               v_Lot.T_SUMID            := 0;
               v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
               v_Lot.T_DOCID            := one_prm.t_RQID;
               v_Lot.T_PARTNUM          := 1;
               v_Lot.T_PARTY            := v_Party;
               v_Lot.T_CONTRACT         := v_Contract;
               v_Lot.T_FIID             := one_prm.t_FIID;
               v_Lot.T_GROUPID          := one_prm.t_GroupID;
               v_Lot.T_PORTFOLIO        := one_prm.t_Portfolio;
               v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
               v_Lot.T_KIND             := WRTSUM_KIND_RRWAS2; --Списание в РЕПО обратном БПП
               v_Lot.T_DATE             := v_Date;
               v_Lot.T_TIME             := one_prm.t_Time;
               v_Lot.T_AMOUNT           := v_Amount;

               IF( v_Old > 0 ) THEN
                  v_Lot.T_SUM  := round(one_prm.t_Cost2 * one_prm.t_PayAmount / one_prm.t_Principal1, 2);
                  v_Lot.T_COST := round(v_Cost * one_prm.t_PayAmount / one_prm.t_Principal1, 2);
               ELSE
                  v_Lot.T_SUM  := one_prm.t_Cost2 - round(one_prm.t_Cost2 * one_prm.t_Principal2 / one_prm.t_Principal1, 2);
                  v_Lot.T_COST := round(v_Cost, 0) - round(v_Cost * one_prm.t_Principal2 / one_prm.t_Principal1, 0);
               END IF;
               v_Lot.T_CURRENCY         := one_prm.t_Currency;
               v_Lot.T_NKDAMOUNT        := 0;
               v_Lot.T_BALANCECOST      := v_Lot.T_COST + v_Lot.T_NKDAMOUNT;
               v_Lot.T_DEPARTMENT       := v_Department;
               v_Lot.T_DEALID           := one_prm.t_DealID;
               v_Lot.T_DEALDATE         := one_prm.t_DealDate;
               v_Lot.T_DEALCODE         := one_prm.t_DealCode;
               v_Lot.T_STATE            := PM_WRTSUM_FORM;
               v_Lot.T_ENTERDATE        := v_Date;
               v_Lot.T_STATEDATE        := v_Date;
               v_Lot.T_CHANGEDATE       := v_Date;
               v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CDELIVERY;
               v_Lot.T_ID_OPERATION     := p_DocumentID;
               v_Lot.T_ID_STEP          := -1;
               v_Lot.T_PARENT           := one_prm.t_Parent;
               v_Lot.T_SOURCE           := one_prm.t_SumID;
               v_Lot.T_ACTIVATEDATE     := v_Date;
               v_Lot.T_ACTIVATETIME     := one_prm.t_Time;
               v_Lot.T_BLOCKAMOUNT      := 0;
               v_Lot.T_ACCFI            := v_DetermineAccFI;
               v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

               RSI_InsDfltIntoWRTSUM(v_Lot);
               RSI_WRTCompensWrt(v_Lot, p_DocumentID, -1, one_prm.t_SumID, v_SaleRepoAmount);

               RSI_WRTLinkSaleLot(v_Lot, p_DocumentID, p_GrpID, p_UseContr); -- КП ОР 2ч (КСУ)

               SELECT NVL(MAX(LOT.T_PARTNUM), 0) INTO v_MaxPartNum
                 FROM DPMWRTSUM_DBT LOT
                WHERE LOT.T_DOCKIND = one_prm.t_Lot2DocKind
                  AND LOT.T_DOCID   = one_prm.t_Lot2DocID;

               WHILE v_SaleRepoAmount > 0 LOOP

                  BEGIN
                     SELECT q.* INTO v_Buy2
                       FROM(SELECT Buy2.*
                              FROM DPMWRTSUM_DBT Buy2
                             WHERE Buy2.t_Source    = v_Lot.t_Parent
                               AND Buy2.t_Portfolio = KINDPORT_BACK_BPP_KSU
                               AND Buy2.t_State     = PM_WRTSUM_NOTFORM
                             ORDER BY t_SumID
                           ) q
                      WHERE ROWNUM = 1;

                     EXCEPTION
                          WHEN OTHERS THEN
                            SetError( WRTOFF_ERROR_20200);

                   END;

                   BEGIN
                     SELECT q.* INTO v_Sale1
                       FROM(SELECT Sale1.*
                              FROM DPMWRTSUM_DBT Sale1
                             WHERE Sale1.t_SumID = v_Buy2.t_Parent
                           ) q
                      WHERE ROWNUM = 1;

                     EXCEPTION
                          WHEN OTHERS THEN
                            SetError( WRTOFF_ERROR_20200);

                   END;

                   v_Amount := least(v_SaleRepoAmount, v_Buy2.t_Amount);

                   v_SaleLot := NULL;
                   v_MaxPartNum := v_MaxPartNum + 1;

                   v_SaleLot.T_SUMID            := 0;
                   v_SaleLot.T_DOCKIND          := one_prm.t_Lot2DocKind;
                   v_SaleLot.T_DOCID            := one_prm.t_Lot2DocID;
                   v_SaleLot.T_PARTNUM          := v_MaxPartNum;
                   v_SaleLot.T_PARTY            := v_Party;
                   v_SaleLot.T_CONTRACT         := v_Contract;
                   v_SaleLot.T_FIID             := one_prm.t_FIID;
                   v_SaleLot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_SaleLot.T_PORTFOLIO);
                   v_SaleLot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
                   v_SaleLot.T_KIND             := WRTSUM_KIND_RRWAS1; --Списание в РЕПО прямом БПП
                   v_SaleLot.T_DATE             := v_Date;
                   v_SaleLot.T_TIME             := one_prm.t_Lot2Time;

                   v_SaleLot.T_STATE            := PM_WRTSUM_FORM;
                   v_SaleLot.T_ENTERDATE        := v_Date;
                   v_SaleLot.T_STATEDATE        := v_Date;
                   v_SaleLot.T_INSTANCE         := 0;
                   v_SaleLot.T_CHANGEDATE       := v_Date;
                   v_SaleLot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
                   v_SaleLot.T_ID_OPERATION     := p_DocumentID;
                   v_SaleLot.T_ID_STEP          := -1;
                   v_SaleLot.T_TRUST            := CHR(0);
                   v_SaleLot.T_SOURCE           := one_prm.t_SumID;

                   v_SaleLot.T_DEPARTMENT       := v_Sale1.t_Department;
                   v_SaleLot.T_DEALID           := v_Sale1.t_DealID;
                   v_SaleLot.T_DEALDATE         := v_Sale1.t_DealDate;
                   v_SaleLot.T_DEALCODE         := v_Sale1.t_DealCode;

                   v_SaleLot.T_ACTIVATEDATE     := v_Date;
                   v_SaleLot.T_ACTIVATETIME     := one_prm.t_Lot2Time;

                   IF v_Amount = v_Buy2.t_Amount THEN

                     v_SaleLot.T_AMOUNT           := v_Buy2.t_Amount;
                     v_SaleLot.T_SUM              := v_Buy2.t_Sum;
                     v_SaleLot.T_CURRENCY         := v_Buy2.t_Currency;
                     v_SaleLot.T_COST             := v_Buy2.t_Cost;
                     v_SaleLot.T_BALANCECOST      := v_Buy2.t_BalanceCost;
                     v_SaleLot.T_NKDAMOUNT        := v_Buy2.t_NKDAmount;
                     v_SaleLot.T_ACCFI            := v_DetermineAccFI;
                     v_SaleLot.T_ACCBALANCECOST   := case when v_SaleLot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_SaleLot.T_BALANCECOST, v_FaceValueFI, v_SaleLot.T_ACCFI, v_SaleLot.T_DATE, 1 ),2),0) end;

                     RSI_InsDfltIntoWRTSUM(v_SaleLot);
                     INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.T_SUMID;

                     RSI_WRTLinkSaleLot(v_SaleLot, p_DocumentID, p_GrpID, p_UseContr); -- ПР 1ч в дату КП ОР 2ч. КСУ

                     RSI_WRTSaveLot( v_Buy2.t_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                     UPDATE DPMWRTSUM_DBT SET T_STATE = PM_WRTSUM_CANCEL WHERE T_SUMID = v_Buy2.t_SUMID;

                   ELSE

                     v_SaleLot.T_AMOUNT           := v_Amount;
                     v_SaleLot.T_SUM              := ROUND(v_Buy2.t_Sum*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_CURRENCY         := ROUND(v_Buy2.t_Currency*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_COST             := ROUND(v_Buy2.t_Cost*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_BALANCECOST      := ROUND(v_Buy2.t_BalanceCost*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_NKDAMOUNT        := ROUND(v_Buy2.t_NKDAmount*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_ACCFI            := v_DetermineAccFI;
                     v_SaleLot.T_ACCBALANCECOST   := case when v_SaleLot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_SaleLot.T_BALANCECOST, v_FaceValueFI, v_SaleLot.T_ACCFI, v_SaleLot.T_DATE, 1 ),2),0) end;

                     RSI_InsDfltIntoWRTSUM(v_SaleLot);
                     INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.T_SUMID;

                     RSI_WRTLinkSaleLot(v_SaleLot, p_DocumentID, p_GrpID, p_UseContr); -- ПР 1ч в дату КП ОР 2ч. КСУ

                     RSI_WRTSaveLot( v_Buy2.t_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                     UPDATE DPMWRTSUM_DBT
                        SET T_AMOUNT      = ROUND(T_AMOUNT*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_SUM         = ROUND(T_SUM*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_CURRENCY    = ROUND(T_CURRENCY*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_COST        = ROUND(T_COST*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_BALANCECOST = ROUND(T_BALANCECOST*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_NKDAMOUNT   = ROUND(T_NKDAMOUNT*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2)
                      WHERE T_SUMID = v_Buy2.t_SUMID;

                   END IF;

                   v_SaleRepoAmount := v_SaleRepoAmount - v_Amount;

               END LOOP;

             ELSE --Не КСУ
               IF v_Date >= NewRepoDate() THEN

                 SELECT NVL(SUM(Buy2.t_Amount),0) INTO v_AmountPVO
                   FROM DPMWRTSUM_DBT Buy2
                  WHERE (Buy2.t_Source = one_prm.t_Parent OR Buy2.t_SumID = one_prm.t_Parent)
                    AND Buy2.t_Portfolio = (CASE WHEN v_Party = UnknownParty THEN KINDPORT_BACK ELSE KINDPORT_CLIENT END)
                    AND 1 = (CASE WHEN v_Party = UnknownParty THEN 1 
                                  WHEN v_Party <> UnknownParty AND Buy2.t_Kind = WRTSUM_KIND_RRWAB1 THEN 1
                                  ELSE 0 END)
                    AND Buy2.t_State     = PM_WRTSUM_FORM;


                 SELECT NVL(SUM(Buy2.t_Amount),0) INTO v_AmountPLUSOD
                   FROM DPMWRTSUM_DBT Buy2
                  WHERE Buy2.t_Source    = one_prm.t_Parent
                    AND Buy2.t_Portfolio = (CASE WHEN v_Party = UnknownParty THEN KINDPORT_BASICDEBT ELSE KINDPORT_CLIENT END)
                    AND 1 = (CASE WHEN v_Party = UnknownParty THEN 1 
                                  WHEN v_Party <> UnknownParty AND Buy2.t_Kind = WRTSUM_KIND_RRWAB2 THEN 1
                                  ELSE 0 END)
                    AND Buy2.t_State     = PM_WRTSUM_NOTFORM;

                 v_Amount0 := least(one_prm.t_Amount, one_prm.t_PayAmount);
                 v_AmountNotBD := one_prm.t_Amount - one_prm.t_AmountBD;

                 IF v_Party = UnknownParty THEN
                   IF v_AmountNotBD != v_AmountPVO + v_AmountPLUSOD THEN
                     SetError( WRTOFF_ERROR_20217 );
                   END IF;
                 END IF;

                 IF v_Amount0 <= v_AmountPVO THEN
                   v_Amount := v_Amount0;
                   v_AmountBD := 0;
                   v_SaleRepoAmount := 0;
                 ELSIF v_Amount0 < v_AmountPVO + v_AmountPLUSOD THEN
                   v_Amount := v_AmountPVO;
                   v_AmountBD := 0;
                   v_SaleRepoAmount := v_Amount0 - v_AmountPVO;
                 ELSE
                   v_Amount := v_Amount0 - v_AmountPLUSOD;
                   v_AmountBD := v_Amount0 - v_AmountPVO - v_AmountPLUSOD;
                   v_SaleRepoAmount := v_AmountPLUSOD;
                 END IF;

                 v_Lot.T_AMOUNT := v_Amount;

               ELSE

                 v_AmountNotBD := one_prm.t_Amount - one_prm.t_AmountBD; -- сколько можем скомпенсировать не залезая в ОД
                 v_Amount := least(one_prm.t_Amount, one_prm.t_PayAmount); -- насколько уменьшим количество в лоте 2ч
                 IF (v_Amount <= v_AmountNotBD) THEN
                    v_AmountBD := 0;
                 ELSE
                    v_AmountBD := v_Amount - v_AmountNotBD;
                 END IF;

                 v_Lot.T_AMOUNT := one_prm.t_PayAmount;

               END IF;

               v_BalanceCostBD := 0.0;
               v_OverAmountBD  := 0.0;
               IF( one_prm.t_AmountBD > 0 ) THEN
                  v_BalanceCostBD := round(one_prm.t_BalanceCostBD * v_AmountBD / one_prm.t_AmountBD, 2);
                  v_OverAmountBD  := round(one_prm.t_OverAmountBD * v_AmountBD / one_prm.t_AmountBD, 2);
               END IF;
               v_Old  := one_prm.t_Principal1 - one_prm.t_Amount;
               v_Cost := RSI_RSB_FIInstr.ConvSum(one_prm.t_Cost2, one_prm.t_Currency, v_FaceValueFI, v_Date, 0);

               v_Lot.T_SUMID            := 0;
               v_Lot.T_DOCKIND          := 29; --DLDOC_PAYMENT
               v_Lot.T_DOCID            := one_prm.t_RQID;
               v_Lot.T_PARTNUM          := 1;
               v_Lot.T_PARTY            := v_Party;
               v_Lot.T_CONTRACT         := v_Contract;
               v_Lot.T_FIID             := one_prm.t_FIID;
               v_Lot.T_GROUPID          := one_prm.t_GroupID;
               v_Lot.T_PORTFOLIO        := one_prm.t_Portfolio;
               v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
               v_Lot.T_KIND             := WRTSUM_KIND_RRWAS2; --Списание в РЕПО обратном БПП
               v_Lot.T_DATE             := v_Date;
               v_Lot.T_TIME             := one_prm.t_Time;

               v_Lot.T_AMOUNTBD         := v_AmountBD;
               IF( v_Old > 0 ) THEN
                  v_Lot.T_SUM  := round(one_prm.t_Cost2 * one_prm.t_PayAmount / one_prm.t_Principal1, 2);
                  v_Lot.T_COST := round(v_Cost * one_prm.t_PayAmount / one_prm.t_Principal1, 2);
               ELSE
                  v_Lot.T_SUM  := one_prm.t_Cost2 - round(one_prm.t_Cost2 * one_prm.t_Principal2 / one_prm.t_Principal1, 2);
                  v_Lot.T_COST := round(v_Cost, 0) - round(v_Cost * one_prm.t_Principal2 / one_prm.t_Principal1, 0);
               END IF;
               v_Lot.T_CURRENCY         := one_prm.t_Currency;
               v_Lot.T_BALANCECOSTBD    := v_BalanceCostBD;
               v_Lot.T_OVERAMOUNTBD     := v_OverAmountBD;
               v_Lot.T_NKDAMOUNT        := RSI_RSB_FIInstr.FI_CalcNKD(v_Lot.T_FIID, v_Date, v_Lot.T_AMOUNT, 0);
               v_Lot.T_BALANCECOST      := v_Lot.T_COST + v_Lot.T_NKDAMOUNT;
               v_Lot.T_DEPARTMENT       := v_Department;
               v_Lot.T_DEALID           := one_prm.t_DealID;
               v_Lot.T_DEALDATE         := one_prm.t_DealDate;
               v_Lot.T_DEALCODE         := one_prm.t_DealCode;
               v_Lot.T_STATE            := PM_WRTSUM_FORM;
               v_Lot.T_ENTERDATE        := v_Date;
               v_Lot.T_STATEDATE        := v_Date;
               v_Lot.T_CHANGEDATE       := v_Date;
               v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CDELIVERY;
               v_Lot.T_ID_OPERATION     := p_DocumentID;
               v_Lot.T_ID_STEP          := -1;
               v_Lot.T_PARENT           := one_prm.t_Parent;
               v_Lot.T_SOURCE           := one_prm.t_SumID;

               v_Lot.T_ACTIVATEDATE     := v_Date;
               v_Lot.T_ACTIVATETIME     := one_prm.t_Time;
               v_Lot.T_ACCFI            := v_DetermineAccFI;
               v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

               RSI_InsDfltIntoWRTSUM(v_Lot);
               RSI_WRTCompensWrt(v_Lot, p_DocumentID, -1, one_prm.t_SumID, v_SaleRepoAmount);

               RSI_WRTLinkSaleLot(v_Lot, p_DocumentID, p_GrpID, p_UseContr); -- КП ОР 2ч

               IF v_Date >= NewRepoDate() THEN

                 WHILE v_SaleRepoAmount > 0 LOOP

                   BEGIN
                     SELECT q.* INTO v_Buy2
                       FROM(SELECT Buy2.*
                              FROM DPMWRTSUM_DBT Buy2
                             WHERE Buy2.t_Source    = v_Lot.t_Parent
                               AND Buy2.t_Portfolio = (CASE WHEN v_Party = UnknownParty THEN KINDPORT_BASICDEBT ELSE KINDPORT_CLIENT END)
                               AND Buy2.t_State     = PM_WRTSUM_NOTFORM
                               AND 1 = (CASE WHEN v_Party = UnknownParty THEN 1 
                                             WHEN v_Party <> UnknownParty AND Buy2.t_Kind = WRTSUM_KIND_RRWAB2 THEN 1
                                             ELSE 0 END)
                             ORDER BY t_SumID
                           ) q
                      WHERE ROWNUM = 1;

                     EXCEPTION
                          WHEN OTHERS THEN
                            SetError( WRTOFF_ERROR_20200);

                   END;

                   v_Amount := least(v_SaleRepoAmount, v_Buy2.t_Amount);

                   v_SaleLot := NULL;
                   v_MaxPartNum := v_MaxPartNum + 1;

                   v_SaleLot.T_SUMID            := 0;
                   v_SaleLot.T_DOCKIND          := v_Lot.T_DocKind;
                   v_SaleLot.T_DOCID            := v_Lot.T_DocID;
                   v_SaleLot.T_PARTNUM          := v_MaxPartNum;
                   v_SaleLot.T_PARTY            := v_Party;
                   v_SaleLot.T_CONTRACT         := v_Contract;
                   v_SaleLot.T_FIID             := v_Lot.T_FIID;
                   v_SaleLot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_SaleLot.T_PORTFOLIO);
                   v_SaleLot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
                   v_SaleLot.T_KIND             := WRTSUM_KIND_RRWAS1; --Списание в РЕПО прямом БПП
                   v_SaleLot.T_DATE             := v_Lot.T_Date;
                   v_SaleLot.T_TIME             := v_Lot.T_Time;

                   v_SaleLot.T_STATE            := PM_WRTSUM_FORM;
                   v_SaleLot.T_ENTERDATE        := v_Lot.T_Date;
                   v_SaleLot.T_STATEDATE        := v_Lot.T_Date;
                   v_SaleLot.T_INSTANCE         := 0;
                   v_SaleLot.T_CHANGEDATE       := v_Lot.T_Date;
                   v_SaleLot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
                   v_SaleLot.T_ID_OPERATION     := p_DocumentID;
                   v_SaleLot.T_ID_STEP          := -1;
                   v_SaleLot.T_TRUST            := CHR(0);
                   v_SaleLot.T_SOURCE           := v_Lot.T_SumID;

                   v_SaleLot.T_DEPARTMENT       := v_Buy2.t_Department;
                   v_SaleLot.T_DEALID           := v_Buy2.t_DealID;
                   v_SaleLot.T_DEALDATE         := v_Buy2.t_DealDate;
                   v_SaleLot.T_DEALCODE         := v_Buy2.t_DealCode;

                   v_SaleLot.T_ACTIVATEDATE     := v_Lot.T_Date;
                   v_SaleLot.T_ACTIVATETIME     := v_Lot.T_Time;

                   IF v_Amount = v_Buy2.t_Amount THEN

                     v_SaleLot.T_AMOUNT           := v_Buy2.t_Amount;
                     v_SaleLot.T_SUM              := v_Buy2.t_Sum;
                     v_SaleLot.T_CURRENCY         := v_Buy2.t_Currency;
                     v_SaleLot.T_COST             := v_Buy2.t_Cost;
                     v_SaleLot.T_BALANCECOST      := v_Buy2.t_BalanceCost;
                     v_SaleLot.T_NKDAMOUNT        := v_Buy2.t_NKDAmount;
                     v_SaleLot.T_ACCFI            := v_DetermineAccFI;
                     v_SaleLot.T_ACCBALANCECOST   := case when v_SaleLot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_SaleLot.T_BALANCECOST, v_FaceValueFI, v_SaleLot.T_ACCFI, v_SaleLot.T_DATE, 1 ),2),0) end;

                     RSI_InsDfltIntoWRTSUM(v_SaleLot);
                     INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.T_SUMID;

                     RSI_WRTLinkSaleLot(v_SaleLot, p_DocumentID, p_GrpID, p_UseContr); -- ПР 1ч в дату КП ОР 2ч

                     RSI_WRTSaveLot( v_Buy2.t_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                     UPDATE DPMWRTSUM_DBT SET T_STATE = PM_WRTSUM_CANCEL WHERE T_SUMID = v_Buy2.t_SUMID;

                   ELSE

                     v_SaleLot.T_AMOUNT           := v_Amount;
                     v_SaleLot.T_SUM              := ROUND(v_Buy2.t_Sum*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_CURRENCY         := ROUND(v_Buy2.t_Currency*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_COST             := ROUND(v_Buy2.t_Cost*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_BALANCECOST      := ROUND(v_Buy2.t_BalanceCost*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_NKDAMOUNT        := ROUND(v_Buy2.t_NKDAmount*v_Amount/v_Buy2.t_Amount, 2);
                     v_SaleLot.T_ACCFI            := v_DetermineAccFI;
                     v_SaleLot.T_ACCBALANCECOST   := case when v_SaleLot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_SaleLot.T_BALANCECOST, v_FaceValueFI, v_SaleLot.T_ACCFI, v_SaleLot.T_DATE, 1 ),2),0) end;

                     RSI_InsDfltIntoWRTSUM(v_SaleLot);
                     INSERT INTO DPMWRTSUM_DBT VALUES v_SaleLot RETURNING t_SUMID INTO v_SaleLot.T_SUMID;

                     RSI_WRTLinkSaleLot(v_SaleLot, p_DocumentID, p_GrpID, p_UseContr); -- ПР 1ч в дату КП ОР 2ч

                     RSI_WRTSaveLot( v_Buy2.t_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                     UPDATE DPMWRTSUM_DBT
                        SET T_AMOUNT      = ROUND(T_AMOUNT*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_SUM         = ROUND(T_SUM*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_CURRENCY    = ROUND(T_CURRENCY*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_COST        = ROUND(T_COST*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_BALANCECOST = ROUND(T_BALANCECOST*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2),
                            T_NKDAMOUNT   = ROUND(T_NKDAMOUNT*(v_Buy2.t_Amount-v_Amount)/v_Buy2.t_Amount, 2)
                      WHERE T_SUMID = v_Buy2.t_SUMID;

                   END IF;

                   v_SaleRepoAmount := v_SaleRepoAmount - v_Amount;

                 END LOOP;

               END IF;

             END IF;

           END LOOP;

        ELSIF( one_grdeal.t_Sort = 5 ) THEN

           -- обработать 2ч ОР

           FOR one_rq IN (SELECT RQ.T_ID RQID, RQ.T_FACTDATE FACTDATE, RQ.T_KIND,
                                 RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                                 LEG2.T_COST COST2, LEG2.T_CFI CFI2, LEG.T_PRINCIPAL PRINCIPAL, TK.T_DEALID, LEG2.T_SUPPLYTIME SupplyTime2
                            FROM DDLGRDEAL_DBT GrDeal, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDL_LEG_DBT LEG2
                           WHERE GrDeal.t_ID       = one_grdeal.t_GrDealID
                             AND GrDeal.t_TemplNum IN (RSI_DLGR.DLGR_TEMPL_DELIVERY2, RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2)
                             AND TK.T_BOFFICEKIND  = GrDeal.T_DOCKIND
                             AND TK.T_DEALID       = GrDeal.T_DOCID
                             AND 1 = (CASE WHEN GrDeal.t_TemplNum = RSI_DLGR.DLGR_TEMPL_DELIVERY2 AND TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN 1
                                           WHEN GrDeal.t_TemplNum = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2 AND TK.T_ISPARTYCLIENT = 'X' AND TK.T_PARTYID = v_Party AND TK.T_PARTYCONTRID = v_Contract THEN 1
                                           ELSE 0 END
                                     ) 
                             AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                             AND (v_OperType = 0 OR 
                                  v_Kind_Operation != 0 OR 
                                  1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                            WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                            WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                 RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                 RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                            ELSE 0 END)
                                 )
                             AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                             AND RQ.T_DOCID        = TK.T_DEALID
                             AND RQ.T_FIID         = p_FIID
                             AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                             AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                             AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY
                             AND RQ.T_DEALPART     = 2
                             AND RQ.T_KIND         = (CASE WHEN TK.T_CLIENTID = v_Party AND TK.T_CLIENTCONTRID = v_Contract THEN RSI_DLRQ.DLRQ_KIND_COMMIT
                                                           ELSE RSI_DLRQ.DLRQ_KIND_REQUEST END)
                             AND LEG.T_LEGKIND     = 0
                             AND LEG.T_DEALID      = TK.T_DEALID
                             AND LEG.T_LEGID       = 0
                             AND LEG2.T_LEGKIND    = 2
                             AND LEG2.T_DEALID     = TK.T_DEALID
                             AND LEG2.T_LEGID      = 0
                         )
           LOOP
             SetContextDeal(one_rq.t_DealID);
             SetContextFIID(p_FIID);

             v_ExistNOSS := rsi_rsb_fiinstr.FI_ExistNOSS( p_FIID, one_rq.FACTDATE, 27 );

             -- По всем непоставленным лотам 2ч
             FOR one_wrt IN (SELECT LOT.T_SUMID SUMID, LOT.T_AMOUNT AMOUNT, LOT.T_AMOUNTBD AMOUNTBD, LOT.T_FIID FIID, LOT.T_KIND KIND, LOT.T_PORTFOLIO PORTFOLIO,
                                    LOT.T_SUM LOTSUM, LOT.T_BALANCECOSTBD BALANCECOSTBD, LOT.T_NKDAMOUNT NKDAMOUNT, LOT.T_PARENT PARENT, LOT.T_SOURCE SOURCE,
                                    LOT.T_DOCKIND DOCKIND, LOT.T_DOCID DOCID, LOT.T_DATE LOTDATE, LOT.T_TIME LOTTIME, LOT.T_CURRENCY CURRENCY, LOT.T_OVERAMOUNTBD OVERAMOUNTBD,
                                    LOT.T_DEPARTMENT DEPARTMENT, LOT.T_DEALID DEALID, LOT.T_DEALDATE DEALDATE, LOT.T_DEALCODE DEALCODE, LOT.T_ENTERDATE ENTERDATE,
                                    (SELECT MAX(LOT1.T_PARTNUM) FROM DPMWRTSUM_DBT LOT1 WHERE LOT1.T_DOCKIND = LOT.T_DOCKIND AND LOT1.T_DOCID = LOT.T_DOCID) MAXPARTNUM
                               FROM DPMWRTSUM_DBT LOT
                              WHERE LOT.T_DOCKIND = 29
                                AND LOT.T_DOCID   = one_rq.RQID
                                AND LOT.T_STATE   = PM_WRTSUM_NOTFORM
                                AND LOT.T_PARTY   = v_Party
                                AND LOT.T_CONTRACT= v_Contract 
                            )
             LOOP

               RSI_WRTSaveLot( one_wrt.SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_DELIVERY );

               IF one_wrt.LotDate >= NewRepoDate() THEN
                 v_MaxPartNum  := one_wrt.MaxPartNum;
                 v_TMPLNKID := 1;

                 SELECT NVL(SUM(Buy2.t_Amount),0) INTO v_Amount
                   FROM DPMWRTSUM_DBT Buy2
                  WHERE Buy2.t_Source = one_wrt.Parent
                    AND Buy2.t_Portfolio IN (KINDPORT_BASICDEBT, KINDPORT_BACK_BPP_KSU)
                    AND Buy2.t_State = PM_WRTSUM_NOTFORM;

                 IF v_Amount > 0 THEN
                   one_wrt.AMOUNT := one_wrt.AMOUNT - v_Amount;

                   UPDATE DPMWRTSUM_DBT
                      SET t_Amount = one_wrt.AMOUNT
                    WHERE t_SumID  = one_wrt.SumID;


                 END IF;


               END IF;

               v_Sum := ROUND((one_rq.COST2 * one_wrt.AMOUNT / one_rq.PRINCIPAL), 2);
               v_Cost := ROUND((RSI_RSB_FIInstr.ConvSum( one_rq.COST2, one_rq.CFI2, v_FaceValueFI, one_rq.FACTDATE, 1 ) * one_wrt.AMOUNT / one_rq.PRINCIPAL), 2);
               v_NKDAmount := RSI_RSB_FIInstr.FI_CalcNKD(one_wrt.FIID, one_rq.FACTDATE, one_wrt.AMOUNT, 0);

               UPDATE DPMWRTSUM_DBT
                  SET T_DATE         = one_rq.FACTDATE,
                      T_TIME         = one_rq.SupplyTime2,
                      T_SUM          = v_Sum,
                      T_CURRENCY     = one_rq.CFI2,
                      T_COST         = v_Cost,
                      T_BALANCECOST  = v_Cost + v_NKDAmount,
                      T_NKDAMOUNT    = v_NKDAmount,
                      T_STATE        = PM_WRTSUM_FORM,
                      T_STATEDATE    = one_rq.FACTDATE,
                      T_CHANGEDATE   = one_rq.FACTDATE,
                      T_ACTION       = PM_WRT_UPDTMODE_DELIVERY,
                      T_ID_OPERATION = p_DocumentID,
                      T_ID_STEP      = -1,
                      T_ACTIVATEDATE = one_rq.FACTDATE,
                      T_ACTIVATETIME = one_rq.SupplyTime2
                WHERE T_SUMID = one_wrt.SUMID;

                BEGIN
                  SELECT * INTO v_Lot2
                    FROM DPMWRTSUM_DBT
                   WHERE t_SumID  = one_wrt.SUMID;
                EXCEPTION
                   WHEN OTHERS THEN SetError(WRTOFF_ERROR_20200);
                END;

                IF( v_Lot2.t_Amount > 0 ) THEN
                   RSI_WRTLinkSaleLot(v_Lot2, p_DocumentID, p_GrpID, p_UseContr); -- ОР 2ч
                END IF;


               IF one_wrt.LotDate >= NewRepoDate() THEN

                 FOR buy2 IN (SELECT Buy2.t_Amount, Buy2.t_Sum, Buy2.t_Cost, Buy2.t_BalanceCost, Buy2.t_NKDAmount, Buy2.t_SumID, Buy2.t_Currency,
                                     Sale1.t_Department, Sale1.t_DealID, Sale1.t_DealDate, Sale1.t_DealCode
                              FROM DPMWRTSUM_DBT Buy2, DPMWRTSUM_DBT Sale1
                             WHERE Buy2.t_Source = one_wrt.Parent
                               AND Sale1.t_SumID = Buy2.t_Parent
                               AND Buy2.t_Portfolio IN (KINDPORT_BASICDEBT, KINDPORT_BACK_BPP_KSU)
                               AND Buy2.t_Amount > 0
                               AND Buy2.t_State = PM_WRTSUM_NOTFORM
                           )
                 LOOP
                     v_Lot := NULL;

                     v_MaxPartNum := v_MaxPartNum + 1;

                     v_Lot.T_SUMID            := 0;
                     v_Lot.T_DOCKIND          := one_wrt.DocKind;
                     v_Lot.T_DOCID            := one_wrt.DocID;
                     v_Lot.T_PARTNUM          := v_MaxPartNum;
                     v_Lot.T_PARTY            := v_Party;
                     v_Lot.T_CONTRACT         := v_Contract;
                     v_Lot.T_FIID             := one_wrt.FIID;
                     v_Lot.T_GROUPID          := RSI_GetWrtoffGroupByPortfolio(v_Lot.T_PORTFOLIO);
                     v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_SALE; --Списание
                     v_Lot.T_KIND             := WRTSUM_KIND_RRWAS1; --Списание в РЕПО прямом БПП
                     v_Lot.T_DATE             := one_rq.FACTDATE;
                     v_Lot.T_TIME             := one_rq.SupplyTime2;--one_wrt.LotTime;
                     v_Lot.T_AMOUNT           := Buy2.t_Amount;
                     v_Lot.T_SUM              := Buy2.t_Sum;
                     v_Lot.T_CURRENCY         := Buy2.t_Currency;
                     v_Lot.T_COST             := Buy2.t_Cost;
                     v_Lot.T_BALANCECOST      := Buy2.t_BalanceCost;
                     v_Lot.T_NKDAMOUNT        := Buy2.t_NKDAmount;
                     v_Lot.T_DEPARTMENT       := Buy2.t_Department;
                     v_Lot.T_DEALID           := Buy2.t_DealID;
                     v_Lot.T_DEALDATE         := Buy2.t_DealDate;
                     v_Lot.T_DEALCODE         := Buy2.t_DealCode;
                     v_Lot.T_STATE            := PM_WRTSUM_FORM;
                     v_Lot.T_ENTERDATE        := one_rq.FACTDATE;
                     v_Lot.T_STATEDATE        := one_rq.FACTDATE;
                     v_Lot.T_INSTANCE         := 0;
                     v_Lot.T_CHANGEDATE       := one_rq.FACTDATE;
                     v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
                     v_Lot.T_ID_OPERATION     := p_DocumentID;
                     v_Lot.T_ID_STEP          := -1;
                     v_Lot.T_TRUST            := CHR(0);
                     v_Lot.T_SOURCE           := one_wrt.SumID;
                     v_Lot.T_ACTIVATEDATE     := one_rq.FACTDATE;
                     v_Lot.T_ACTIVATETIME     := one_rq.SupplyTime2;
                     v_Lot.T_ACCFI            := v_DetermineAccFI;
                     v_Lot.T_ACCBALANCECOST   := case when v_Lot.T_ACCFI = -1 then 0 else NVL(ROUND(RSI_RSB_FIInstr.ConvSum( v_Lot.T_BALANCECOST, v_FaceValueFI, v_Lot.T_ACCFI, v_Lot.T_DATE, 1 ),2),0) end;

                     RSI_InsDfltIntoWRTSUM(v_Lot);
                     INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;

                     RSI_WRTSaveLot( Buy2.t_SUMID, p_DocumentID, -1, v_Date, PM_WRT_UPDTMODE_CORRECT2 );

                     UPDATE DPMWRTSUM_DBT SET T_STATE = PM_WRTSUM_CANCEL WHERE T_SUMID = Buy2.t_SUMID;

                     RSI_WRTLinkSaleLot(v_Lot, p_DocumentID, p_GrpID, p_UseContr); -- ПР 1ч в дату ОР 2ч

                 END LOOP;


               END IF;
               
             END LOOP;
           END LOOP;

        END IF;

     END LOOP;

     --4.14.
     FOR one_prm IN (SELECT GRDEAL2.T_ID GrDealID2, TK.T_DEALID
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL, DDLGRDEAL_DBT GRDEAL2
                      WHERE S.T_GRPID          = p_GrpID
                        AND S.T_TYPE           = 1
                        AND SD.T_SUBGRPID      = S.T_SUBGRPID
                        AND GRDEAL.T_ID        = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND   IN (RSB_SECUR.DL_SECURITYDOC, RSB_SECUR.DL_RETIREMENT, RSB_SECUR.DL_AVRWRT)
                        AND GRDEAL.T_PLANDATE  = v_Date
                        AND GRDEAL.T_FIID      = p_FIID
                        AND TK.T_DEALID        = GRDEAL.T_DOCID
                        AND TK.T_DEPARTMENT    = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                        AND GRDEAL2.T_DOCKIND  = GRDEAL.T_DOCKIND
                        AND GRDEAL2.T_DOCID    = GRDEAL.T_DOCID
                        AND GRDEAL2.T_FIID     = GRDEAL.T_FIID
                        AND GRDEAL2.T_PLANDATE = v_Date
                        AND ((    GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY --Поставка 1ч
                              AND GRDEAL2.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_RECDELIVERY --Учет поставки 1ч
                             ) OR
                             (    GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERY2 --Поставка 2ч
                              AND GRDEAL2.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_RECDELIVERY2 --Учет поставки 2ч
                             ) OR
                             (    GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_COMPDELIVERY --Комп. поставка
                              AND GRDEAL2.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_RECCOMPDELIVERY --Учет комп. поставки
                             )
                            )
                    )
     LOOP

       SetContextDeal( one_prm.t_DealID );
       SetContextFIID(p_FIID);

       --4.14.1  установить на строку графика по учёту поставки БУ = П, при условии что поставка обработана в данной операции.
       RSI_DLGR.RSI_UpdateGrDealAccByID(one_prm.GrDealID2, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, RSI_DLGR.DLGRACC_STATE_PLAN, NULL, 0);

       --4.14.2 Создать связь группы обработки с графиком
       RSI_DLGR.RSI_SetDocGrDeal(one_prm.GrDealID2, 0, 0, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);

     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;


     --4.15.
     FOR one_prm IN (SELECT GRDEAL.T_ID GrDealID, TK.T_DEALID
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID          = p_GrpID
                        AND S.T_TYPE           = 1
                        AND SD.T_SUBGRPID      = S.T_SUBGRPID
                        AND GRDEAL.T_ID        = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECURITYDOC, RSB_SECUR.DL_RETIREMENT, RSB_SECUR.DL_AVRWRT)
                        AND GRDEAL.T_PLANDATE  = v_Date
                        AND GRDEAL.T_FIID      = p_FIID
                        AND GRDEAL.T_TEMPLNUM IN (RSI_DLGR.DLGR_TEMPL_DELIVERY, 
                                                  RSI_DLGR.DLGR_TEMPL_DELIVERY2, 
                                                  RSI_DLGR.DLGR_TEMPL_COMPDELIVERY,
                                                  RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR, 
                                                  RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2, 
                                                  RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR
                                                 )
                        AND TK.T_DEALID        = GRDEAL.T_DOCID
                        AND TK.T_DEPARTMENT    = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                    )
     LOOP

       SetContextDeal( one_prm.t_DealID );
       SetContextFIID(p_FIID);

       --4.15.1 установить на строку графика по поставке БУ = Ф
       RSI_DLGR.RSI_UpdateGrDealAccByID(one_prm.GrDealID, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, RSI_DLGR.DLGRACC_STATE_FACTEXEC, NULL, 0);

       --4.15.2 Создать связь группы обработки с графиком
       RSI_DLGR.RSI_SetDocGrDeal(one_prm.GrDealID, 0, 0, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);

     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;


     -- 4.16. Удалить данные из DPMWRTORDER_TMP
     EXECUTE IMMEDIATE 'DELETE FROM DPMWRTORDER_TMP WHERE T_GRPID = :1'
                 USING p_GrpID;

     EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN SetError(WRTOFF_ERROR_20268);


   END WRTLinkOurLotsByFI;

   PROCEDURE RSI_WRTLinkOurLots( p_DocumentID IN NUMBER,
                                 p_OperDate IN DATE,
                                 p_GrpID IN NUMBER,
                                 p_UseContr IN NUMBER
                               )
   AS

   BEGIN

     FOR one_fi IN (SELECT *
                      FROM DPMWRTGRPFI_DBT
                     WHERE T_GRPID = p_GrpID
                   )
     LOOP

       WRTLinkOurLotsByFI(p_DocumentID, p_OperDate, p_GrpID, p_UseContr, one_fi.t_FIID);

     END LOOP;

   END RSI_WRTLinkOurLots;

      --Выполняет квитовку клиентских лотов в сервисной операции БУ
   PROCEDURE WRTLinkClientLotsByFI(p_DocumentID IN NUMBER,
                                   p_Date IN DATE,
                                   p_GrpID IN NUMBER,
                                   p_FIID IN NUMBER
                                  )
   IS

     v_Department NUMBER;
     v_Party      NUMBER;
     v_Contract   NUMBER;
     v_OperType       NUMBER:= 0;
     v_Kind_Operation NUMBER:= 0;
   BEGIN

     InitContextDeal;
     InitContextFIID;

     SELECT T_DEPARTMENT, T_PARTY, T_CONTRACT INTO v_Department, v_Party, v_Contract
       FROM DPMWRTGRP_DBT
      WHERE T_ID = p_GrpID;

     SELECT t_ContractKind, t_OperSubKind INTO v_OperType, v_Kind_Operation
       FROM DDL_COMM_DBT
      WHERE t_DocumentID = p_DocumentID;

     --1. Зачисление и списание для владельцев
     FOR one_grouprq IN (SELECT NVL(SUM((CASE WHEN RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_REQUEST THEN RQ.T_AMOUNT ELSE -RQ.T_AMOUNT END)), 0) Amount
                           FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLGRDEAL_DBT GRDEAL, DDL_TICK_DBT TK, DDLRQ_DBT RQ
                          WHERE S.T_GRPID = p_GrpID
                            AND S.T_TYPE = 1
                            AND SD.T_SUBGRPID = S.T_SUBGRPID
                            AND GRDEAL.T_ID = SD.T_GRDEALID
                            AND GRDEAL.T_FIID  = p_FIID
                            AND TK.T_DEALID = GRDEAL.T_DOCID
                            AND RQ.T_DOCKIND = TK.T_BOFFICEKIND
                            AND RQ.T_DOCID = TK.T_DEALID
                            AND RQ.T_TYPE IN (RSI_DLRQ.DLRQ_TYPE_DELIVERY, RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY) --Поставка, Компенсационная поставка
                            AND RQ.T_FIID = p_FIID
                            AND RQ.T_FACTDATE = p_Date
                            AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC --Исполнено
                            AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS --ЦТО
                            AND GRDEAL.T_TEMPLNUM = (CASE WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 1 THEN RSI_DLGR.DLGR_TEMPL_DELIVERY
                                                          WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 2 THEN RSI_DLGR.DLGR_TEMPL_DELIVERY2
                                                          WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY THEN RSI_DLGR.DLGR_TEMPL_COMPDELIVERY
                                                          ELSE 0 END)
                            AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                            AND (v_OperType = 0 OR 
                                 v_Kind_Operation != 0 OR 
                                 1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                           WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                           WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                           ELSE 0 END)
                                )
                            AND EXISTS(SELECT 1
                                         FROM DDLGRACC_DBT GRACC
                                        WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                          AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                          AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                      )
                        )
     LOOP
     
       RSI_WRTSetClientLot(p_FIID, v_Department, v_Party, v_Contract, one_grouprq.Amount, p_Date, p_DocumentID, -1, 0);
     END LOOP;

     --2. Зачисление и списание для клиентов-контрагентов
     FOR one_grouprq IN (SELECT NVL(SUM((CASE WHEN RQ.T_KIND = RSI_DLRQ.DLRQ_KIND_REQUEST THEN -RQ.T_AMOUNT ELSE RQ.T_AMOUNT END)), 0) Amount
                           FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLGRDEAL_DBT GRDEAL, DDL_TICK_DBT TK, DDLRQ_DBT RQ
                          WHERE S.T_GRPID = p_GrpID
                            AND S.T_TYPE = 1
                            AND SD.T_SUBGRPID = S.T_SUBGRPID
                            AND GRDEAL.T_ID = SD.T_GRDEALID
                            AND GRDEAL.T_FIID  = p_FIID
                            AND TK.T_DEALID = GRDEAL.T_DOCID
                            AND RQ.T_DOCKIND = TK.T_BOFFICEKIND
                            AND RQ.T_DOCID = TK.T_DEALID
                            AND RQ.T_TYPE IN (RSI_DLRQ.DLRQ_TYPE_DELIVERY, RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY) --Поставка, Компенсационная поставка
                            AND RQ.T_FIID = p_FIID
                            AND RQ.T_FACTDATE = p_Date
                            AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC --Исполнено
                            AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS --ЦТО
                            AND GRDEAL.T_TEMPLNUM = (CASE WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 1 THEN RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR
                                                          WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 2 THEN RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2
                                                          WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY THEN RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR
                                                          ELSE 0 END)
                            AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                            AND (v_OperType = 0 OR 
                                 v_Kind_Operation != 0 OR 
                                 1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                           WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                           WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                           ELSE 0 END)
                                )
                            AND EXISTS(SELECT 1
                                         FROM DDLGRACC_DBT GRACC
                                        WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                          AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                          AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                      )
                        )
     LOOP
       RSI_WRTSetClientLot(p_FIID, v_Department, v_Party, v_Contract, one_grouprq.Amount, p_Date, p_DocumentID, -1, 0);
     END LOOP;

     --3. Проверить отрицательные остатки по группе
     RSI_WRTDelAndCheckClientLots(p_FIID, v_Department, v_Party, v_Contract, p_DocumentID, -1, 1);

     --4. Для владельцев, отметить в графике, что квитовка исполнена
     FOR one_grdeal IN (SELECT GRDEAL.T_ID GrDealID, RQ.T_ID RQID, TK.T_DEALID
                          FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLGRDEAL_DBT GRDEAL, DDL_TICK_DBT TK, DDLRQ_DBT RQ
                         WHERE S.T_GRPID = p_GrpID
                           AND S.T_TYPE = 1
                           AND SD.T_SUBGRPID = S.T_SUBGRPID
                           AND GRDEAL.T_ID = SD.T_GRDEALID
                           AND GRDEAL.T_FIID  = p_FIID
                           AND TK.T_DEALID = GRDEAL.T_DOCID
                           AND RQ.T_DOCKIND = TK.T_BOFFICEKIND
                           AND RQ.T_DOCID = TK.T_DEALID
                           AND RQ.T_TYPE IN (RSI_DLRQ.DLRQ_TYPE_DELIVERY, RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY) --Поставка, Компенсационная поставка
                           AND RQ.T_FIID = p_FIID
                           AND RQ.T_FACTDATE = p_Date
                           AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC --Исполнено
                           AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS --ЦТО
                           AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                           AND (v_OperType = 0 OR 
                                v_Kind_Operation != 0 OR 
                                1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                          WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                          WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                               RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                               RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                          ELSE 0 END)
                               )
                           AND GRDEAL.T_TEMPLNUM = (CASE WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 1 THEN RSI_DLGR.DLGR_TEMPL_DELIVERY
                                                         WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 2 THEN RSI_DLGR.DLGR_TEMPL_DELIVERY2
                                                         WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY THEN RSI_DLGR.DLGR_TEMPL_COMPDELIVERY
                                                         ELSE 0 END)
                           AND EXISTS(SELECT 1
                                        FROM DDLGRACC_DBT GRACC
                                       WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                         AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                         AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                     )

                       )
     LOOP
       SetContextDeal(one_grdeal.T_DealID);
       SetContextFIID(p_FIID);

       RSI_DLGR.RSI_SetDocGrDeal(one_grdeal.GrDealID, 29 /*DLDOC_PAYMENT*/, one_grdeal.RQID, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);
     END LOOP;

     --5. Для клиентов-контрагентов, отметить в графике, что квитовка исполнена
     FOR one_grdeal IN (SELECT GRDEAL.T_ID GrDealID, RQ.T_ID RQID, TK.T_DEALID
                           FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLGRDEAL_DBT GRDEAL, DDL_TICK_DBT TK, DDLRQ_DBT RQ
                          WHERE S.T_GRPID = p_GrpID
                            AND S.T_TYPE = 1
                            AND SD.T_SUBGRPID = S.T_SUBGRPID
                            AND GRDEAL.T_ID = SD.T_GRDEALID
                            AND GRDEAL.T_FIID  = p_FIID
                            AND TK.T_DEALID = GRDEAL.T_DOCID
                            AND RQ.T_DOCKIND = TK.T_BOFFICEKIND
                            AND RQ.T_DOCID = TK.T_DEALID
                            AND RQ.T_TYPE IN (RSI_DLRQ.DLRQ_TYPE_DELIVERY, RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY) --Поставка, Компенсационная поставка
                            AND RQ.T_FIID = p_FIID
                            AND RQ.T_FACTDATE = p_Date
                            AND RQ.T_STATE = RSI_DLRQ.DLRQ_STATE_EXEC --Исполнено
                            AND RQ.T_SUBKIND = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS --ЦТО
                            AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                            AND (v_OperType = 0 OR 
                                 v_Kind_Operation != 0 OR 
                                 1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                           WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                           WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                                RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                                RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                           ELSE 0 END)
                                )
                            AND GRDEAL.T_TEMPLNUM = (CASE WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 1 THEN RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR
                                                          WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_DELIVERY AND RQ.T_DEALPART = 2 THEN RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2
                                                          WHEN RQ.T_TYPE = RSI_DLRQ.DLRQ_TYPE_COMPDELIVERY THEN RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR
                                                          ELSE 0 END)
                            AND EXISTS(SELECT 1
                                         FROM DDLGRACC_DBT GRACC
                                        WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                          AND GRACC.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                          AND GRACC.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                      )
                        )
     LOOP
       SetContextDeal(one_grdeal.T_DealID);
       SetContextFIID(p_FIID);

       RSI_DLGR.RSI_SetDocGrDeal(one_grdeal.GrDealID, 29 /*DLDOC_PAYMENT*/, one_grdeal.RQID, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);
     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;

     WRTLinkOurLotsByFI(p_DocumentID, p_Date, p_GrpID, 1, p_FIID);

     DELETE FROM DFIID_TMP;
     INSERT INTO DFIID_TMP(FIID) values (p_FIID);

     --Добавить информацию об обращаемости ц/б по сделкам клиента для НДФЛ
     RSI_NPTO.RecalcCirculate(v_Party, p_Date, p_Date, 0);

   END WRTLinkClientLotsByFI;

   PROCEDURE RSI_WRTLinkClientLots(p_DocumentID IN NUMBER,
                                   p_Date IN DATE,
                                   p_GrpID IN NUMBER
                                  )
   AS

   BEGIN

     FOR one_fi IN (SELECT T_FIID
                      FROM DPMWRTGRPFI_DBT
                     WHERE T_GRPID = p_GrpID
                   )
     LOOP

       WRTLinkClientLotsByFI(p_DocumentID, p_Date, p_GrpID, one_fi.t_FIID);

     END LOOP;

   END RSI_WRTLinkClientLots;

   --Выполняет откат квитовки клиентских лотов в сервисной операции БУ
   PROCEDURE RSI_WRTRecoilLinkClientLots(p_DocumentID IN NUMBER,
                                         p_GrpID IN NUMBER
                                        )
   IS
     v_Amount NUMBER(32,12);

     v_GrpID NUMBER;
     v_cl DPMWRTCL_DBT%ROWTYPE;

     v_Department NUMBER;
     v_Party      NUMBER;
     v_Contract   NUMBER;
   BEGIN

     SELECT T_DEPARTMENT, T_PARTY, T_CONTRACT INTO v_Department, v_Party, v_Contract
       FROM DPMWRTGRP_DBT
      WHERE T_ID = p_GrpID;

     FOR one_fi IN (SELECT T_FIID FROM DPMWRTGRPFI_DBT WHERE T_GRPID = p_GrpID)
     LOOP

       FOR one_select IN (SELECT GRDEAL.T_TEMPLNUM TemplNum, GRDEAL.T_ID GrDealID, 
                                 RQ.T_KIND RqKind, RQ.T_AMOUNT Amount, RQ.T_FACTDATE FactDate
                            FROM DDLGRDOC_DBT DOC, DDLRQ_DBT RQ, DDLGRDEAL_DBT GRDEAL
                           WHERE DOC.T_SERVDOCKIND = RSB_SECUR.DL_SCACCOUNTING
                             AND DOC.T_SERVDOCID = p_DocumentID
                             AND DOC.T_GRPID = p_GrpID
                             AND DOC.T_DOCKIND = 29 /*DLDOC_PAYMENT*/
                             AND DOC.T_DOCID = RQ.T_ID
                             AND GRDEAL.T_ID = DOC.T_GRDEALID
                             AND GRDEAL.T_FIID = one_fi.t_FIID
                         )
       LOOP

         v_Amount := one_select.Amount;
         IF one_select.RqKind = RSI_DLRQ.DLRQ_KIND_REQUEST THEN
           v_Amount := -v_Amount;
         END IF;

         --если обрабатываем строку по клиенту-контрагенту
         IF one_select.TemplNum = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR OR
            one_select.TemplNum = RSI_DLGR.DLGR_TEMPL_DELIVERYCONTR2 OR
            one_select.TemplNum = RSI_DLGR.DLGR_TEMPL_COMPDELIVERYCONTR THEN

           v_Amount := -v_Amount;
         END IF;

         RSI_WRTSetClientLot(one_fi.t_FIID, v_Department, v_Party, v_Contract, v_Amount, one_select.FactDate, p_DocumentID, -1, 0);
       END LOOP;

       RSI_WRTDelAndCheckClientLots(one_fi.t_FIID, v_Department, v_Party, v_Contract, p_DocumentID, -1, 1);
     END LOOP;

     DELETE FROM DDLGRDOC_DBT WHERE T_SERVDOCKIND = RSB_SECUR.DL_SCACCOUNTING AND T_SERVDOCID = p_DocumentID AND T_GRPID = p_GrpID;

   END RSI_WRTRecoilLinkClientLots;

   --Выполняет обработку лотов Нашего Банка по сделкам ОЭБ в сервисной операции БУ.
   PROCEDURE WRTLinkOurLotsOwnByFI( p_DocumentID IN NUMBER,
                                    p_OperDate IN DATE,
                                    p_GrpID IN NUMBER,
                                    p_FIID IN NUMBER
                                  )
   AS
     v_Date                     DATE;
     v_CalcDate                 DATE;
     v_Department               NUMBER;
     v_Lot                      DPMWRTSUM_DBT%ROWTYPE;
     v_FaceValueFI              NUMBER;
     v_NeedChargeInterestIncome NUMBER;
     v_NeedChargeIncome         NUMBER;
     v_Amount                   NUMBER;
     v_Nominal                  NUMBER;
     v_BEGBONUS                 NUMBER;
     v_BEGDISCOUNT              NUMBER;
     v_CostFVFI                 NUMBER;
     v_FVCourseType             NUMBER := Rsb_Common.GetRegIntValue('SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ', 0);
     v_EPSOption                NUMBER := Rsb_Common.GetRegIntValue('SECUR\МСФО\УЧЕТ_ОЭБ_ПО_ЭПС', 0);
     v_TotalCostNat             NUMBER;
     v_CalcIntereset NUMBER := 1;
     v_CalcDiscount  NUMBER := 1;
     v_CalcBonus     NUMBER := 1;
     v_CalcOutlay    NUMBER := 1;
     v_CalcDefDiff   NUMBER := 1;
     v_CorrIntToEIR  NUMBER := 1;
     v_ExecMonth     NUMBER;
     v_MaturityMonth NUMBER;
     v_Msg           VARCHAR2(256);
     v_Cat55         NUMBER := 0;
     v_Cat60         NUMBER := 0;
     v_AlgUsed       NUMBER;
     v_RateID        NUMBER;
     v_OperType       NUMBER:= 0;
     v_Kind_Operation NUMBER:= 0;
     v_Termless       CHAR;
     v_DetermineAccFI NUMBER;
     v_AvoirAttrObsBaseData NUMBER;
     v_FullWrt       NUMBER;
     v_IsBIO         NUMBER := 0;
     v_BioPFI        NUMBER := 0;
     v_BioPFICurrency   NUMBER := -1;
     v_PlacedAmount  NUMBER := 0;
     v_RestAmount    NUMBER := 0;
     v_AddCommSum    NUMBER := 0;
     v_AddNDSSum     NUMBER := 0;
     v_TotalAddCommSum    NUMBER := 0;
     v_TotalAddNDSSum     NUMBER := 0;
     v_PrevBuyAmortComm  NUMBER := 0;
     v_PrevBuyAmortNDS   NUMBER := 0;
     v_SubordinateFIID NUMBER := 0;
      v_DrawingDate DATE;
   BEGIN

     InitContextDeal;
     InitContextFIID;

     -- 1. Найти FIID, Department из pmwrtgrp где t_ID == GrpID
     SELECT T_DEPARTMENT INTO v_Department
       FROM DPMWRTGRP_DBT
      WHERE T_ID = p_GrpID;

     SELECT FIN.T_FACEVALUEFI, AV.t_Termless
       INTO v_FaceValueFI, v_Termless
       FROM DFININSTR_DBT FIN, DAVOIRISS_DBT AV
      WHERE FIN.T_FIID = p_FIID
        AND AV.T_FIID = FIN.T_FIID;

     v_IsBIO := RSI_RSB_FIInstr.FI_IsBIO(p_FIID);

     SELECT t_ContractKind, t_OperSubKind INTO v_OperType, v_Kind_Operation
       FROM DDL_COMM_DBT
      WHERE t_DocumentID = p_DocumentID;

     v_NeedChargeInterestIncome := WRTNeedChargeInterestIncome(p_FIID); --Облигации, имеющие купоны, или в анкете которых задан доход
     v_NeedChargeIncome         := WRTNeedChargeIncome(p_FIID); --Облигация
     v_DetermineAccFI           := WRTDetermineAccFI(p_FIID);
     v_AvoirAttrObsBaseData     := RSI_AvoirAttrObsBaseData(p_FIID);

     IF (v_NeedChargeIncome = 1 AND v_Termless = 'X' AND RSI_RSB_FIInstr.FI_GetNominalDrawingDate(p_FIID, v_Termless) = UnknownDate) THEN
        SetError( WRTOFF_ERROR_20269, to_char(p_FIID) ); --Отсутствует дата погашения ц/б с FIID %s, дата известного купона меньше даты расчета
     END IF;

     -- 2.  V_Date
     SELECT NVL(MIN(GRDEAl.T_PLANDATE), TO_DATE('01.01.0001','DD.MM.YYYY')) INTO v_Date
       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL
      WHERE S.T_GRPID          = p_GrpID
        AND S.T_TYPE           = 1
        AND SD.T_SUBGRPID      = S.T_SUBGRPID
        AND GRDEAL.T_ID        = SD.T_GRDEALID
        AND GRDEAL.T_DOCKIND  IN (RSB_SECUR.DL_SECUROWN, RSB_SECUR.DL_AVRWRTOWN, RSB_SECUR.DL_RETIREMENT_OWN)
        AND GRDEAl.T_TEMPLNUM IN (RSI_DLGR.DLGR_TEMPL_DELIVERYOWN, RSI_DLGR.DLGR_TEMPL_EXECOWN)
        AND GRDEAL.T_PLANDATE <= p_OperDate
        AND GRDEAL.T_FIID      = p_FIID
        AND TK.T_DEALID        = GRDEAL.T_DOCID
        AND TK.T_CLIENTID      = -1
        AND TK.T_DEPARTMENT    = v_Department
        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
        AND (v_OperType = 0 OR 
             v_Kind_Operation != 0 OR 
             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                       ELSE 0 END)
            )
        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN)
        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC);

     -- 3. Если v_Date < OperDate и v_Date != нач. дата
     IF v_Date < p_OperDate AND v_Date <> TO_DATE('01.01.0001','DD.MM.YYYY') THEN
       SetError( WRTOFF_ERROR_20247 ); --Необходимо выполнить сервисные операции БУ за более ранние даты
     END IF;

     IF v_Date = TO_DATE('01.01.0001','DD.MM.YYYY') THEN
       return;
     END IF;

     IF v_IsBIO <> 0 THEN
         FOR one_rec IN (SELECT * 
                           FROM DBIOFRVAL_DBT
                          WHERE T_FIID = p_FIID
                            AND T_DATE <= v_Date
                          ORDER BY T_DATE DESC
                        )
         LOOP

           v_BioPFI         := one_rec.t_OneItemFv;
           v_BioPFICurrency := one_rec.t_Currency;

           EXIT;
         END LOOP;
     END IF;

     -- 4.1. Обработать размещения/списания за дату
     FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            RQ.T_ID RQID, RQ.T_FIID FIID, RQ.T_FACTDATE FactDate, LEG.T_SUPPLYTIME SupplyTime, RQ.T_AMOUNT Amount,
                            LEG.T_COST Cost, LEG.T_TOTALCOST TotalCost, LEG.T_CFI CFI, LEG.T_NKD NKD, TK.T_PLACEMENT PLACEMENT, RQ.T_PLANDATE PlanDate,
                            TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALCODE DealCode,
                            TK.T_DEALTIME DealTime, LEG.T_START StartDate, LEG.T_INTERESTSTART InterestStart
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECUROWN, RSB_SECUR.DL_AVRWRTOWN)
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYOWN
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND (TK.T_BOFFICEKIND = RSB_SECUR.DL_AVRWRTOWN or (TK.T_BOFFICEKIND = RSB_SECUR.DL_SECUROWN and TK.T_PLACEMENT = 'X'))
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND     = 0
                        AND LEG.T_DEALID      = TK.T_DEALID
                        AND LEG.T_LEGID       = 0
                        AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID        = TK.T_DEALID
                        AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_FIID         = GRDEAL.T_FIID
                        AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                        AND RQ.T_KIND         = RSI_DLRQ.DLRQ_KIND_COMMIT --Обязательство
                        AND RQ.T_DEALPART     = 1
                        AND EXISTS(SELECT 1
                                     FROM DDLGRACC_DBT GRACC
                                    WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                      AND GRACC.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                      AND GRACC.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                  )
                    )
     LOOP

        SetContextDeal(one_prm.DealID);
        SetContextFIID(p_FIID);

        v_Lot := NULL;

        IF (one_prm.BOfficeKind = RSB_SECUR.DL_SECUROWN and one_prm.PLACEMENT = 'X') THEN --размещения
           v_BEGBONUS := 0;
           v_BEGDISCOUNT := 0;

           v_Lot.T_DATE             := one_prm.PlanDate;
           v_Lot.T_AMOUNT           := one_prm.Amount;
           v_Lot.T_CURRENCY         := one_prm.CFI;
           v_Lot.T_COST             := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.Cost, v_Lot.T_CURRENCY, v_FaceValueFI, v_Lot.T_DATE, 1), 2);
           v_TotalCostNat           := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.TotalCost, v_Lot.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE, 1), 2);

           v_Nominal  := RSI_RSB_FIInstr.FI_GetNominalOnDate(p_FIID, v_Lot.T_DATE);


           v_BEGDISCOUNT := ROUND(GREATEST((v_Lot.T_AMOUNT * v_Nominal - (v_Lot.T_COST-NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_AMOUNT * v_BioPFI, v_BioPFICurrency, v_FaceValueFI, v_Lot.T_DATE, 1),0))), 0), 2);
           v_BEGBONUS    := ROUND(ABS(LEAST((v_Lot.T_AMOUNT * v_Nominal - (v_Lot.T_COST-NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_AMOUNT * v_BioPFI, v_BioPFICurrency, v_FaceValueFI, v_Lot.T_DATE, 1),0))), 0)), 2);

           v_Lot.T_SUMID            := 0;
           v_Lot.T_DOCKIND          := RSB_SECUR.DLDOC_PAYMENT;
           v_Lot.T_DOCID            := one_prm.RQID;
           v_Lot.T_PARTNUM          := 0;
           v_Lot.T_PARTY            := UnknownParty; --НашБанк
           v_Lot.T_CONTRACT         := 0;
           v_Lot.T_FIID             := one_prm.FIID;
           v_Lot.T_PORTFOLIO        := KINDPORT_UNDEF;
           v_Lot.T_GROUPID          := -1;
           v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_PLACE; --Размещение
           v_Lot.T_KIND             := WRTSUM_KIND_DSTR; --Размещение
           v_Lot.T_TIME             := one_prm.SupplyTime;
           v_Lot.T_SUM              := one_prm.Cost;
           IF v_NeedChargeIncome = 1 THEN
              v_Lot.T_NKDAMOUNT     := one_prm.NKD;
           END IF;
           IF v_NeedChargeIncome = 1 THEN --Только для облигаций
              v_Lot.T_BEGINTERESTDATE := one_prm.FactDate;
              v_Lot.T_BEGBONUS := v_BEGBONUS;

              IF v_Lot.T_BEGBONUS > 0 THEN
                 v_Lot.T_BEGBONUSDATE := one_prm.FactDate;
              END IF;
           END IF;
           v_Lot.T_BEGDATE          := one_prm.FactDate;
           IF v_NeedChargeIncome = 1 THEN
              v_Lot.T_BEGDISCOUNT := v_BEGDISCOUNT;

              IF v_Lot.T_BEGDISCOUNT > 0 THEN
                 v_Lot.T_BEGDISCOUNTDATE := one_prm.FactDate;
              END IF;
           END IF;

           v_Lot.T_OUTLAY := GetComSumByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FaceValueFI, KINDPORT_AC_OWN, 0, v_TotalCostNat, 1);
           
           v_Lot.T_DEPARTMENT       := v_Department;
           v_Lot.T_DEALID           := one_prm.DealID;
           v_Lot.T_DEALDATE         := one_prm.DealDate;
           v_Lot.T_DEALCODE         := one_prm.DealCode;
           v_Lot.T_STATE            := PM_WRTSUM_PLACE_OWN;
           v_Lot.T_ENTERDATE        := one_prm.DealDate;
           v_Lot.T_STATEDATE        := one_prm.FactDate;
           v_Lot.T_CHANGEDATE       := one_prm.FactDate;
           v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
           v_Lot.T_ID_OPERATION     := p_DocumentID;
           v_Lot.T_ID_STEP          := -1;
           v_Lot.T_ISFREE           := 'X';
           v_Lot.T_ACTIVATEDATE     := v_Lot.T_DATE;
           v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
           v_Lot.T_FAIRVALUE        := v_Lot.T_AMOUNT * NVL(RSB_Secur.SC_ConvSumTypeRep(1, one_prm.FIID, v_FaceValueFI, v_FaceValueFI, v_FVCourseType, v_Lot.T_DATE), 0);

           v_Lot.t_AmortCalcKind := 0;
           -- если не задан курс СС на ФИ, в соответствии с настройкой (SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ), то рассчитаем СС
           IF v_Lot.T_FAIRVALUE = 0 THEN
              IF RSB_SECUR.SC_CalcFairValue( v_Lot.T_FIID, -- идентификатор ц/б
                                             v_Lot.T_DATE, -- дата расчета
                                             RSB_SECUR.CALCKIND_OWN, -- вид расчета (0 необязательный)
                                             v_Lot.t_DealID, -- id сделки (0 необязательный)
                                             0, -- id лота (0 необязательный)
                                             rsb_secur.GetEndCoupDate(v_Lot.T_FIID, v_Lot.T_DATE), -- Дата окончания периода расчета купона
                                             v_Lot.T_FAIRVALUE, -- рассчитанное значение СС
                                             v_Msg, -- сообщение
                                             v_RateID, -- курс, использованный для вычисления СС
                                             v_Cat55, -- значение для категории "Уровень исходных данных иерархии СС МСФО 13"
                                             v_Cat60, -- значение для категории "Наблюдаемые исходные данные"
                                             v_AlgUsed, -- примененный алгоритм
                                             v_Lot.t_EFFECTINTERESTRATE, -- ставка (может быть изменена, если применен алгоритм ALG_DISCCOSTSTREAM)
                                             v_Lot.t_AmortCalcKind -- -- Вид расчета АС (может быть изменен, если применен алгоритм ALG_DISCCOSTSTREAM)
                                           ) = 0 THEN

                 IF v_AlgUsed = RSB_SECUR.ALG_DISCCOSTSTREAM AND v_Lot.t_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_RPS THEN
                    v_Lot.T_AMORTCOST := v_Lot.T_FAIRVALUE;
                 ELSIF v_AlgUsed != RSB_SECUR.ALG_DISCCOSTSTREAM THEN
                    v_Lot.T_FAIRVALUE := v_Lot.T_FAIRVALUE * v_Lot.T_AMOUNT;
                 END IF;
              END IF;
              
              IF Length(v_Msg) > 0 THEN
                  RSB_SECUR.AddWarningLogTmp(v_Lot.T_DEALCODE, 1, v_Msg);
              END IF;
           END IF;

           IF( RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECUROWN, one_prm.DealID) = 1 AND -- Тест на рыночность пройден = Нет
               v_AvoirAttrObsBaseData = 1 ) THEN                                -- Наблюдаемые исходные данные = Нет
              v_Lot.T_BEGDEFDIFF    := ROUND(v_TotalCostNat - RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE), 2);
              v_Lot.T_BEGDEFDIFFDATE := one_prm.FactDate;
           else
              v_Lot.T_BEGDEFDIFF    := 0;
           end if;

           IF v_EPSOption = 0 THEN --По методу ЭПС
             v_DrawingDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(v_Lot.T_FIID, v_Termless);

             IF v_DrawingDate <> UnknownDate AND
                 ADD_MONTHS(v_Lot.T_DATE, 12) > v_DrawingDate AND
                 EPSAvrLessThanYear() = EPSAVRLESSTHANYEAR_NO THEN
                v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;
             ELSE
                v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
             END IF;
           ELSIF v_EPSOption = 1 THEN --Без ЭПС
             v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
           END IF;

           v_Lot.T_VATOUTLAY        := GetComNDSByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FaceValueFI, KINDPORT_AC_OWN, 0, v_TotalCostNat, 1);
           IF v_Lot.t_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
             v_Lot.T_EFFECTINTERESTRATE := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_OWN, v_Lot.T_DEALID, 0, v_Lot.T_DATE);
             v_Lot.T_AMORTCOST      := RSB_SECUR.CalcAS_EPS0(RSB_SECUR.CALCKIND_OWN, v_Lot.T_DEALID, 0, v_Lot.T_DATE, v_Lot.T_FAIRVALUE);
           END IF;
           v_Lot.T_AMORTCOSTDATE    := v_Lot.T_DATE;
           v_Lot.T_ACCFI            := v_DetermineAccFI;
           IF( RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECUROWN, one_prm.DealID) = 1 AND -- Тест на рыночность пройден = Нет
               v_AvoirAttrObsBaseData = 0 ) THEN                                -- Наблюдаемые исходные данные = Да
             v_Lot.T_CORRINTTOEIR := ROUND(RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE) - v_TotalCostNat, 2);
             v_Lot.T_CORRINTTOEIRDATE := v_Lot.T_DATE;
           ELSE
             v_Lot.T_CORRINTTOEIR := 0;
             v_Lot.T_CORRINTTOEIRDATE := TO_DATE( '01.01.0001', 'DD.MM.YYYY' );
           END IF;

           IF v_IsBIO <> 0 THEN
             v_Lot.T_ADDINCOMEOWN     := ROUND(RSI_RSB_FIInstr.ConvSum(v_BioPFI*v_Lot.T_AMOUNT, v_BioPFICurrency, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE), 2);
             v_Lot.T_ADDINCOMEOWNDATE := v_Lot.T_DATE;
           END IF;
        ELSE --списания
           v_Lot.T_SUMID            := 0;
           v_Lot.T_DOCKIND          := RSB_SECUR.DLDOC_PAYMENT;
           v_Lot.T_DOCID            := one_prm.RQID;
           v_Lot.T_PARTNUM          := 0;
           v_Lot.T_PARTY            := UnknownParty; --НашБанк
           v_Lot.T_FIID             := one_prm.FIID;
           v_Lot.T_PORTFOLIO        := KINDPORT_UNDEF;
           v_Lot.T_GROUPID          := -1;
           v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_PLACE; --Размещение
           v_Lot.T_KIND             := WRTSUM_KIND_FS; --Списание
           v_Lot.T_DATE             := one_prm.DealDate;
           v_Lot.T_TIME             := one_prm.DealTime;
           v_Lot.T_AMOUNT           := one_prm.Amount;
           v_Lot.T_SUM              := one_prm.Cost;
           v_Lot.T_CURRENCY         := one_prm.CFI;
           v_Lot.T_COST             := RSI_RSB_FIInstr.ConvSum(one_prm.Cost, v_Lot.T_CURRENCY, v_FaceValueFI, v_Lot.T_DATE, 1);
           v_TotalCostNat           := RSI_RSB_FIInstr.ConvSum(one_prm.TotalCost, v_Lot.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE, 1);
           v_Lot.T_BALANCECOST      := 0;
           IF v_NeedChargeIncome = 1 THEN
              v_Lot.T_NKDAMOUNT     := one_prm.NKD;
           END IF;
           IF v_NeedChargeInterestIncome = 1 THEN --Только облигаций имеющих купоны, или в анкете которых задан доход
              v_Lot.T_BEGINTERESTDATE := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_INTERESTINCOME); --Процентный доход
              v_Lot.T_INTERESTINCOME  := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_INTERESTINCOME); --Процентный доход
           END IF;
           IF v_Lot.T_INTERESTINCOME != 0 THEN
              v_Lot.T_INTERESTDATE  := v_Lot.T_DATE;
           END IF;
           v_Lot.T_BEGDATE          := one_prm.StartDate;
           IF v_NeedChargeIncome = 1 THEN --Только по облигациям
              v_Lot.T_BEGBONUS        := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGBONUS); --Начальная премия
              IF v_Lot.T_BEGBONUS > 0 THEN
                 v_Lot.T_BEGBONUSDATE := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGBONUS); --Начальная премия
              END IF;
              v_Lot.T_BONUS           := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BONUS); --Премия
              IF v_Lot.T_BONUS != 0 THEN
                 v_Lot.T_BONUSDATE  := v_Lot.T_DATE;
              END IF;

              v_Lot.T_BEGDISCOUNT        := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGDISCONTINCOME); --Начальный дисконт
              IF v_Lot.T_BEGDISCOUNT > 0 THEN
                 v_Lot.T_BEGDISCOUNTDATE := GetDealSumDate(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_BEGDISCONTINCOME); --Начальный дисконт
              END IF;
              v_Lot.T_OLDBEGDISCOUNT := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_OLDBEGDISCONTINCOME); --Начальный дисконт до перевода
              v_Lot.T_RECALCDATE     := one_prm.InterestStart;
              v_Lot.T_DISCOUNTINCOME := GetDealSum(one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_DISCONTINCOME); --Дисконтный доход
              IF v_Lot.T_DISCOUNTINCOME != 0 THEN
                 v_Lot.T_DISCOUNTDATE := v_Lot.T_DATE;
              END IF;
           END IF;
           v_Lot.T_DISCOUNTCORR     := 0;
           v_Lot.T_OLDBEGBONUS      := 0;
           v_Lot.T_OLDBONUS         := 0;
           
           v_Lot.T_OUTLAY := GetComSumByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FaceValueFI, KINDPORT_AC_OWN, 0, v_TotalCostNat, 1);
           
           v_Lot.T_DEPARTMENT       := v_Department;
           v_Lot.T_DEALID           := one_prm.DealID;
           v_Lot.T_DEALDATE         := one_prm.DealDate;
           v_Lot.T_DEALCODE         := one_prm.DealCode;
           v_Lot.T_STATE            := PM_WRTSUM_FORM;
           v_Lot.T_ENTERDATE        := one_prm.DealDate;
           v_Lot.T_STATEDATE        := one_prm.DealDate;
           v_Lot.T_CHANGEDATE       := one_prm.DealDate;
           v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
           v_Lot.T_ID_OPERATION     := p_DocumentID;
           v_Lot.T_ID_STEP          := -1;
           v_Lot.T_TRUST            := CHR(0);
           v_Lot.T_NOTWRTBONUS      := 0;
           v_Lot.T_ACTIVATEDATE     := one_prm.DealDate;
           v_Lot.T_ACTIVATETIME     := one_prm.DealTime;
           v_Lot.T_BLOCKAMOUNT      := 0;
           v_Lot.T_FAIRVALUE        := v_Lot.T_AMOUNT * NVL(RSB_Secur.SC_ConvSumTypeRep(1, one_prm.FIID, v_FaceValueFI, v_FaceValueFI, v_FVCourseType, v_Lot.T_DATE), 0);
           -- если не задан курс СС на ФИ, в соответствии с настройкой (SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ), то рассчитаем СС
           IF v_Lot.T_FAIRVALUE = 0 THEN
              IF RSB_SECUR.SC_CalcFairValue( v_Lot.T_FIID, -- идентификатор ц/б
                                             v_Lot.T_DATE, -- дата расчета
                                             RSB_SECUR.CALCKIND_OWN, -- вид расчета (0 необязательный)
                                             v_Lot.t_DealID, -- id сделки (0 необязательный)
                                             0, -- id лота (0 необязательный)
                                             rsb_secur.GetEndCoupDate(v_Lot.T_FIID, v_Lot.T_DATE), -- Дата окончания периода расчета купона
                                             v_Lot.T_FAIRVALUE, -- рассчитанное значение СС
                                             v_Msg, -- сообщение
                                             v_RateID, -- курс, использованный для вычисления СС
                                             v_Cat55, -- значение для категории "Уровень исходных данных иерархии СС МСФО 13"
                                             v_Cat60, -- значение для категории "Наблюдаемые исходные данные"
                                             v_AlgUsed, -- примененный алгоритм
                                             v_Lot.t_EFFECTINTERESTRATE, -- ставка (может быть изменена, если применен алгоритм ALG_DISCCOSTSTREAM)
                                             v_Lot.t_AmortCalcKind -- -- Вид расчета АС (может быть изменен, если применен алгоритм ALG_DISCCOSTSTREAM)
                                           ) = 0 THEN

                 IF v_AlgUsed = RSB_SECUR.ALG_DISCCOSTSTREAM AND v_Lot.t_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_RPS THEN
                    v_Lot.T_AMORTCOST := v_Lot.T_FAIRVALUE;
                 ELSIF v_AlgUsed <> RSB_SECUR.ALG_DISCCOSTSTREAM THEN
                    v_Lot.T_FAIRVALUE := v_Lot.T_FAIRVALUE * v_Lot.T_AMOUNT;
                 END IF;
              END IF;

              IF Length(v_Msg) > 0 THEN
                  RSB_SECUR.AddWarningLogTmp(v_Lot.T_DEALCODE, 1, v_Msg);
              END IF;
           END IF;

           IF v_EPSOption = 0 THEN --По методу ЭПС
             v_DrawingDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(v_Lot.T_FIID, v_Termless);

             IF v_DrawingDate <> UnknownDate AND
                 ADD_MONTHS(v_Lot.T_DATE, 12) > v_DrawingDate AND
                 EPSAvrLessThanYear() = EPSAVRLESSTHANYEAR_NO THEN
                v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;
             ELSE
                v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
             END IF;
           ELSIF v_EPSOption = 1 THEN --Без ЭПС
             v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
           END IF;

           IF( RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECUROWN, one_prm.DealID) = 1 AND -- Тест на рыночность пройден = Нет
               v_AvoirAttrObsBaseData = 1 ) THEN                                 -- Наблюдаемые исходные данные = Нет
              v_Lot.T_BEGDEFDIFF    := ROUND(v_TotalCostNat - RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE), 2);
              v_Lot.T_BEGDEFDIFFDATE := one_prm.FactDate;
           else
              v_Lot.T_BEGDEFDIFF    := 0;
           end if;
           IF( RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECUROWN, one_prm.DealID) = 1 AND -- Тест на рыночность пройден = Нет
               v_AvoirAttrObsBaseData = 0 ) THEN                                -- Наблюдаемые исходные данные = Да
             v_Lot.T_CORRINTTOEIR := ROUND(RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE) - v_TotalCostNat, 2);
             v_Lot.T_CORRINTTOEIRDATE := v_Lot.T_DATE;
           ELSE
             v_Lot.T_CORRINTTOEIR := 0;
             v_Lot.T_CORRINTTOEIRDATE := TO_DATE( '01.01.0001', 'DD.MM.YYYY' );
           END IF;

           v_Lot.T_VATOUTLAY        := GetComNDSByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FaceValueFI, KINDPORT_AC_OWN, 0, v_TotalCostNat, 1);
           IF v_Lot.t_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
             v_Lot.T_EFFECTINTERESTRATE := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_OWN, v_Lot.T_DEALID, 0, v_Lot.T_DATE);
             v_Lot.T_AMORTCOST      := RSB_SECUR.CalcAS_EPS0(RSB_SECUR.CALCKIND_OWN, v_Lot.T_DEALID, 0, v_Lot.T_DATE, v_Lot.T_FAIRVALUE);
           END IF;
           v_Lot.T_AMORTCOSTDATE    := one_prm.PlanDate;
           v_Lot.T_ACCFI            := v_DetermineAccFI;
        END IF;

        IF v_Lot.T_SUMID IS NOT NULL THEN
          RSI_InsDfltIntoWRTSUM(v_Lot);
          INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;
        END IF;
     END LOOP;

     -- 4.2. Обработать покупки и зачисления за дату
     DELETE FROM DDLSUM_TMP;

     FOR one_prm IN (SELECT ROWNUM AS RN, RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            RQ.T_ID RQID, RQ.T_FIID FIID, RQ.T_AMOUNT Amount, RQ.T_FACTDATE FactDate,
                            LEG.T_COST Cost, LEG.T_CFI CFI, LEG.T_NKD NKD, LEG.T_SUPPLYTIME SupplyTime,
                            TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALTIME DealTime,
                            TK.T_DEALCODE DealCode, TK.T_FLAG2 FLAG2,
                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) IsOutExchange
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECUROWN, RSB_SECUR.DL_AVRWRTOWN)
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYOWN
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND     = 0
                        AND LEG.T_DEALID      = TK.T_DEALID
                        AND LEG.T_LEGID       = 0
                        AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID        = TK.T_DEALID
                        AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_FIID         = GRDEAL.T_FIID
                        AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                        AND RQ.T_KIND         = RSI_DLRQ.DLRQ_KIND_REQUEST --Требование
                        AND RQ.T_DEALPART     = 1
                        AND EXISTS(SELECT 1
                                     FROM DDLGRACC_DBT GRACC
                                    WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                      AND GRACC.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                      AND GRACC.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                  )
                    )
     LOOP

        SetContextDeal(one_prm.DealID);
        SetContextFIID(p_FIID);

        IF one_prm.RN = 1 THEN
          --Получим исходное кол-во размещенных бумаг
          v_PlacedAmount := WRTGetAmountOwn(v_Department, p_FIID, v_Date, 1, 0);
          v_RestAmount   := v_PlacedAmount;

          --При обработке первой записи рассчитаем суммы комиссий к списанию по выпуску во временную таблицу
          --Считать будем как полное выбытие, а затем для каждого выкупа возьмём пропорционально от общего кол-ва в размещении
          RSI_СalcOwnFiComTMP(p_FIID, p_OperDate, v_Date, 1);
        END IF;


        v_Nominal := RSI_RSB_FIInstr.FI_GetNominalOnDate(p_FIID, one_prm.FactDate);

        v_Lot := NULL;

        v_Lot.T_SUMID            := 0;
        v_Lot.T_DOCKIND          := RSB_SECUR.DLDOC_PAYMENT;
        v_Lot.T_DOCID            := one_prm.RQID;
        v_Lot.T_PARTNUM          := 0;
        v_Lot.T_PARTY            := UnknownParty; --НашБанк
        v_Lot.T_FIID             := one_prm.FIID;
        v_Lot.T_PORTFOLIO        := KINDPORT_UNDEF;
        v_Lot.T_GROUPID          := -1;
        v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_RET_PLACE; --Возвращение из размещения
        v_Lot.T_DATE             := one_prm.FactDate;
        v_Lot.T_TIME             := one_prm.SupplyTime;
        v_Lot.T_AMOUNT           := one_prm.Amount;
        v_Lot.T_SUM              := one_prm.Cost;
        v_Lot.T_CURRENCY         := one_prm.CFI;
        v_Lot.T_COST             := v_Lot.T_AMOUNT * v_Nominal;
        v_Lot.T_BALANCECOST      := 0;
        IF v_NeedChargeIncome = 1 THEN
           v_Lot.T_NKDAMOUNT     := one_prm.NKD;
        END IF;
        v_Lot.T_DEPARTMENT       := v_Department;
        v_Lot.T_DEALID           := one_prm.DealID;
        v_Lot.T_DEALDATE         := one_prm.DealDate;
        v_Lot.T_DEALCODE         := one_prm.DealCode;
        IF one_prm.IsOutExchange <> 0 AND one_prm.Flag2 = 'X' THEN
          v_Lot.T_STATE          := PM_WRTSUM_RET_OWN;
        ELSE 
          v_Lot.T_STATE          := PM_WRTSUM_BUYOUT_OWN;
        END IF;
        v_Lot.T_ENTERDATE        := one_prm.DealDate;
        v_Lot.T_STATEDATE        := one_prm.FactDate;
        v_Lot.T_CHANGEDATE       := one_prm.FactDate;
        v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
        v_Lot.T_ID_OPERATION     := p_DocumentID;
        v_Lot.T_ID_STEP          := -1;
        v_Lot.T_ACTIVATEDATE     := one_prm.FactDate;
        v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
        v_Lot.T_ACCFI            := v_DetermineAccFI;

        IF (one_prm.BOfficeKind = RSB_SECUR.DL_SECUROWN) THEN --покупка ОЭБ
           v_Lot.T_KIND          := WRTSUM_KIND_RDMP;
        ELSE --зачисление ОЭБ
           v_Lot.T_KIND          := WRTSUM_KIND_FB;
        END IF;

        RSI_InsDfltIntoWRTSUM(v_Lot);
        INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;

        RSI_WRTLinkRedemptionOwn( v_Lot, p_DocumentID, -1 );
         
        v_TotalAddCommSum := 0;
        v_TotalAddNDSSum  := 0;
        --Рассчитаем суммы комиссий по выпуску к списанию при выкупе
        FOR one_s IN (SELECT dls.*
                        FROM ddlsum_tmp dls, ddlcomis_dbt dlc
                       WHERE dls.t_DocKind = RSB_SECUR.DL_SECURITYCOM
                         AND dls.t_Kind    = RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM
                         AND dlc.t_ID      = dls.t_DocID
                         AND dls.t_ID      > 0
                     )
        LOOP

          IF v_RestAmount = v_Lot.T_AMOUNT THEN
            v_AddCommSum := one_s.t_Sum - v_PrevBuyAmortComm;
            v_AddNDSSum  := one_s.t_NDS - v_PrevBuyAmortNDS;
          ELSE
            v_AddCommSum := ROUND(one_s.t_Sum * one_prm.Amount / v_PlacedAmount, 2);
            v_AddNDSSum  := ROUND(one_s.t_NDS * one_prm.Amount / v_PlacedAmount, 2);
          END IF;

          INSERT INTO DDLSUM_TMP (T_ID, T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                          VALUES (-1*DDLSUM_TMP_SEQ.NEXTVAL, one_s.T_DOCKIND, one_s.T_DOCID, one_s.T_KIND, one_s.T_DATE, v_AddCommSum, v_AddNDSSum, one_s.T_CURRENCY, one_s.T_IMMATERIAL, 0, p_GrpID, p_FIID);

          v_TotalAddCommSum := v_TotalAddCommSum + v_AddCommSum; 
          v_TotalAddNDSSum  := v_TotalAddNDSSum  + v_AddNDSSum;  
        END LOOP;

        IF v_TotalAddCommSum > 0 OR v_TotalAddNDSSum > 0 THEN
          INSERT INTO DDLSUM_DBT (T_DLSUMID, T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                          VALUES (0, one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_KIND_OWNAVR_DEALAMORTCOM, v_Date, v_TotalAddCommSum, v_TotalAddNDSSum, RSI_RSB_FIINSTR.NATCUR, CHR(0), 0, p_GrpID, p_FIID);

          v_PrevBuyAmortComm := v_PrevBuyAmortComm + v_TotalAddCommSum;
          v_PrevBuyAmortNDS  := v_PrevBuyAmortNDS  + v_TotalAddNDSSum;
        
        END IF;

        v_RestAmount := v_RestAmount - v_Lot.T_AMOUNT;
     END LOOP;

     FOR one_s IN (SELECT T_DOCKIND, T_DOCID, T_KIND, T_DATE, NVL(SUM(T_SUM),0) as SumSum, NVL(SUM(T_NDS),0) as SumNDS, T_CURRENCY, T_IMMATERIAL, T_GRPID, T_FIID
                     FROM ddlsum_tmp
                    WHERE t_ID < 0
                    GROUP BY T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_CURRENCY, T_IMMATERIAL, T_GRPID, T_FIID
                  )
     LOOP

       RSI_DLGR.SetDLSUM(one_s.t_DocKind,
                         one_s.t_DocID,
                         one_s.t_Kind,
                         one_s.t_Currency,
                         one_s.t_Date,
                         one_s.SumSum,
                         one_s.SumNDS,
                         one_s.t_GrpID,
                         one_s.t_FIID
                        );
     END LOOP;

     DELETE FROM DDLSUM_TMP;

     -- 4.3. Обработать продажи за дату
     FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            RQ.T_ID RQID, RQ.T_FIID FIID, RQ.T_FACTDATE FactDate, LEG.T_SUPPLYTIME SupplyTime, RQ.T_AMOUNT Amount,
                            LEG.T_COST Cost, LEG.T_TOTALCOST TotalCost, LEG.T_CFI CFI, LEG.T_NKD NKD, TK.T_PLACEMENT PLACEMENT, RQ.T_PLANDATE PlanDate,
                            TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALCODE DealCode,
                            TK.T_DEALTIME DealTime, LEG.T_START StartDate
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDL_LEG_DBT LEG, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND  = RSB_SECUR.DL_SECUROWN
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYOWN
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND TK.T_PLACEMENT    <> 'X'
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND     = 0
                        AND LEG.T_DEALID      = TK.T_DEALID
                        AND LEG.T_LEGID       = 0
                        AND RQ.T_DOCKIND      = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID        = TK.T_DEALID
                        AND RQ.T_STATE        = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND      = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_FIID         = GRDEAL.T_FIID
                        AND RQ.T_TYPE         = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                        AND RQ.T_KIND         = RSI_DLRQ.DLRQ_KIND_COMMIT --Обязательство
                        AND RQ.T_DEALPART     = 1
                        AND EXISTS(SELECT 1
                                     FROM DDLGRACC_DBT GRACC
                                    WHERE GRACC.T_GRDEALID = GRDEAL.T_ID
                                      AND GRACC.T_ACCNUM   = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING --БУ
                                      AND GRACC.T_STATE    = RSI_DLGR.DLGRACC_STATE_PLAN --П
                                  )
                    )
     LOOP

        SetContextDeal(one_prm.DealID);
        SetContextFIID(p_FIID);

        v_Lot := NULL;

        v_BEGBONUS := 0;
        v_BEGDISCOUNT := 0;

        v_Lot.T_DATE             := one_prm.PlanDate;
        v_Lot.T_AMOUNT           := one_prm.Amount;
        v_Lot.T_CURRENCY         := one_prm.CFI;
        v_Lot.T_COST             := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.Cost, v_Lot.T_CURRENCY, v_FaceValueFI, v_Lot.T_DATE, 1), 2);
        v_TotalCostNat           := ROUND(RSI_RSB_FIInstr.ConvSum(one_prm.TotalCost, v_Lot.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE, 1),2);

        v_Nominal  := RSI_RSB_FIInstr.FI_GetNominalOnDate(p_FIID, v_Lot.T_DATE);
        
        v_BEGDISCOUNT := ROUND(GREATEST((v_Lot.T_AMOUNT * v_Nominal - (v_Lot.T_COST - NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_AMOUNT * v_BioPFI, v_BioPFICurrency, v_FaceValueFI, v_Lot.T_DATE, 1),0))), 0), 2);
        v_BEGBONUS    := ROUND(ABS(LEAST((v_Lot.T_AMOUNT * v_Nominal - (v_Lot.T_COST-NVL(RSI_RSB_FIInstr.ConvSum(v_Lot.T_AMOUNT * v_BioPFI, v_BioPFICurrency, v_FaceValueFI, v_Lot.T_DATE, 1),0))), 0)), 2);

        v_Lot.T_SUMID            := 0;
        v_Lot.T_DOCKIND          := RSB_SECUR.DLDOC_PAYMENT;
        v_Lot.T_DOCID            := one_prm.RQID;
        v_Lot.T_PARTNUM          := 0;
        v_Lot.T_PARTY            := UnknownParty; --НашБанк
        v_Lot.T_CONTRACT         := 0;
        v_Lot.T_FIID             := one_prm.FIID;
        v_Lot.T_PORTFOLIO        := KINDPORT_UNDEF;
        v_Lot.T_GROUPID          := -1;
        v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_PLACE; --Размещение
        v_Lot.T_KIND             := WRTSUM_KIND_DSTR; --Размещение
        v_Lot.T_TIME             := one_prm.SupplyTime;
        v_Lot.T_SUM              := one_prm.Cost;
        IF v_NeedChargeIncome = 1 THEN
           v_Lot.T_NKDAMOUNT     := one_prm.NKD;
        END IF;
        IF v_NeedChargeIncome = 1 THEN --Только для облигаций
           v_Lot.T_BEGINTERESTDATE := one_prm.FactDate;
           v_Lot.T_BEGBONUS := v_BEGBONUS;

           IF v_Lot.T_BEGBONUS > 0 THEN
              v_Lot.T_BEGBONUSDATE := one_prm.FactDate;
           END IF;
        END IF;
        v_Lot.T_BEGDATE          := one_prm.FactDate;
        IF v_NeedChargeIncome = 1 THEN
           v_Lot.T_BEGDISCOUNT := v_BEGDISCOUNT;

           IF v_Lot.T_BEGDISCOUNT > 0 THEN
              v_Lot.T_BEGDISCOUNTDATE := one_prm.FactDate;
           END IF;
        END IF;
        
        v_Lot.T_OUTLAY := GetComSumByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FaceValueFI, KINDPORT_AC_OWN, 0, v_TotalCostNat, 1);
        
        v_Lot.T_DEPARTMENT       := v_Department;
        v_Lot.T_DEALID           := one_prm.DealID;
        v_Lot.T_DEALDATE         := one_prm.DealDate;
        v_Lot.T_DEALCODE         := one_prm.DealCode;
        v_Lot.T_STATE            := PM_WRTSUM_PLACE_OWN;
        v_Lot.T_ENTERDATE        := one_prm.DealDate;
        v_Lot.T_STATEDATE        := one_prm.FactDate;
        v_Lot.T_CHANGEDATE       := one_prm.FactDate;
        v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
        v_Lot.T_ID_OPERATION     := p_DocumentID;
        v_Lot.T_ID_STEP          := -1;
        v_Lot.T_ISFREE           := 'X';
        v_Lot.T_ACTIVATEDATE     := v_Lot.T_DATE;
        v_Lot.T_ACTIVATETIME     := one_prm.SupplyTime;
        v_Lot.T_FAIRVALUE        := v_Lot.T_AMOUNT * NVL(RSB_Secur.SC_ConvSumTypeRep(1, one_prm.FIID, v_FaceValueFI, v_FaceValueFI, v_FVCourseType, v_Lot.T_DATE), 0);
        -- если не задан курс СС на ФИ, в соответствии с настройкой (SECUR\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ), то рассчитаем СС
        IF v_Lot.T_FAIRVALUE = 0 THEN
           IF RSB_SECUR.SC_CalcFairValue( v_Lot.T_FIID, -- идентификатор ц/б
                                          v_Lot.T_DATE, -- дата расчета
                                          RSB_SECUR.CALCKIND_OWN, -- вид расчета (0 необязательный)
                                          v_Lot.t_DealID, -- id сделки (0 необязательный)
                                          0, -- id лота (0 необязательный)
                                          rsb_secur.GetEndCoupDate(v_Lot.T_FIID, v_Lot.T_DATE), -- Дата окончания периода расчета купона
                                          v_Lot.T_FAIRVALUE, -- рассчитанное значение СС
                                          v_Msg, -- сообщение
                                          v_RateID, -- курс, использованный для вычисления СС
                                          v_Cat55, -- значение для категории "Уровень исходных данных иерархии СС МСФО 13"
                                          v_Cat60, -- значение для категории "Наблюдаемые исходные данные"
                                          v_AlgUsed, -- примененный алгоритм
                                          v_Lot.t_EFFECTINTERESTRATE, -- ставка (может быть изменена, если применен алгоритм ALG_DISCCOSTSTREAM)
                                          v_Lot.t_AmortCalcKind -- -- Вид расчета АС (может быть изменен, если применен алгоритм ALG_DISCCOSTSTREAM)
                                        ) = 0 THEN

              IF v_AlgUsed = RSB_SECUR.ALG_DISCCOSTSTREAM AND v_Lot.t_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_RPS THEN
                 v_Lot.T_AMORTCOST := v_Lot.T_FAIRVALUE;
              ELSIF v_AlgUsed != RSB_SECUR.ALG_DISCCOSTSTREAM THEN
                 v_Lot.T_FAIRVALUE := v_Lot.T_FAIRVALUE * v_Lot.T_AMOUNT;
              END IF;
           END IF;

           IF Length(v_Msg) > 0 THEN
               RSB_SECUR.AddWarningLogTmp(v_Lot.T_DEALCODE, 1, v_Msg);
           END IF;
        END IF;

        IF v_EPSOption = 0 THEN --По методу ЭПС
          v_DrawingDate := RSI_RSB_FIInstr.FI_GetNominalDrawingDate(v_Lot.T_FIID, v_Termless);

          IF v_DrawingDate <> UnknownDate AND
               ADD_MONTHS(v_Lot.T_DATE, 12) > v_DrawingDate AND
               EPSAvrLessThanYear() = EPSAVRLESSTHANYEAR_NO THEN
             v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM ;
          ELSE
             v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_EPS;
          END IF;
        ELSIF v_EPSOption = 1 THEN --Без ЭПС
          v_Lot.t_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;
        END IF;

        IF( RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECUROWN, one_prm.DealID) = 1 AND -- Тест на рыночность пройден = Нет
            v_AvoirAttrObsBaseData = 1 ) THEN                                 -- Наблюдаемые исходные данные = Нет
           v_Lot.T_BEGDEFDIFF       := ROUND(v_TotalCostNat - RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE), 2);
           v_Lot.T_BEGDEFDIFFDATE   := one_prm.FactDate;
        else
           v_Lot.T_BEGDEFDIFF    := 0;
        end if;
        v_Lot.T_VATOUTLAY        := GetComNDSByDeal_Essential(one_prm.BOfficeKind, one_prm.DealID, v_Lot.T_DATE, v_FaceValueFI, KINDPORT_AC_OWN, 0, v_TotalCostNat, 1);
        IF v_Lot.t_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
          v_Lot.T_EFFECTINTERESTRATE := RSB_SECUR.CalcEPS(RSB_SECUR.CALCKIND_OWN, v_Lot.T_DEALID, 0, v_Lot.T_DATE);
          v_Lot.T_AMORTCOST      := RSB_SECUR.CalcAS_EPS0(RSB_SECUR.CALCKIND_OWN, v_Lot.T_DEALID, 0, v_Lot.T_DATE, v_Lot.T_FAIRVALUE);
        END IF;
        v_Lot.T_AMORTCOSTDATE    := v_Lot.T_DATE;
        v_Lot.T_ACCFI            := v_DetermineAccFI;

        IF( RSI_DealAttrMarketTest(Rsb_Secur.OBJTYPE_SECUROWN, one_prm.DealID) = 1 AND -- Тест на рыночность пройден = Нет
            v_AvoirAttrObsBaseData = 0 ) THEN                                -- Наблюдаемые исходные данные = Да
          v_Lot.T_CORRINTTOEIR := ROUND(v_TotalCostNat - RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, v_FaceValueFI, RSI_RSB_FIInstr.NATCUR, v_Lot.T_DATE), 2);
          v_Lot.T_CORRINTTOEIRDATE := v_Lot.T_DATE;
        ELSE
          v_Lot.T_CORRINTTOEIR := 0;
          v_Lot.T_CORRINTTOEIRDATE := TO_DATE( '01.01.0001', 'DD.MM.YYYY' );
        END IF;

        IF v_Lot.T_SUMID IS NOT NULL THEN
           RSI_InsDfltIntoWRTSUM(v_Lot);
           INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;
        END IF;

        RSI_WRTLinkSaleToBuyOwn(v_Lot, p_DocumentID, -1);
     END LOOP;

     -- 4.4. Обработать погашения за дату

     -- 4.4.1. Обработать Исполнение. В дату исполнения выполнить доначисление дохода/расхода.
     FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            LEG.T_MATURITY, TK.T_FLAG3, TK.T_DEALID, TK.T_BOFFICEKIND
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL, DDL_LEG_DBT LEG
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_EXECOWN
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND GRDEAL.T_DOCKIND  = RSB_SECUR.DL_RETIREMENT_OWN
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND TK.T_PFI          = GRDEAL.T_FIID
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND = 0
                        AND LEG.T_DEALID = TK.T_DEALID
                        AND LEG.T_LEGID = 0
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                    )
     LOOP

       v_CalcIntereset := 0;
       v_CalcDiscount  := 0;
       v_CalcBonus     := 0;
       v_CalcOutlay    := 0;
       v_CalcDefDiff   := 0;
       v_CorrIntToEIR  := 0;

       IF RSB_SECUR.IsRet_Coupon(one_prm.OGroup) = 1 THEN --Погашение купона
         v_CalcIntereset := 1;
       ELSE
         v_CalcIntereset := 1;
         v_CalcDiscount  := 1;
         v_CalcBonus     := 1;
         v_CalcOutlay    := 1;
         v_CalcDefDiff   := 1;
         v_CorrIntToEIR  := 1;
       END IF;

       IF RSB_SECUR.IsRet_Coupon(one_prm.OGroup) = 1 OR one_prm.T_FLAG3 = CHR(0) THEN --Погашение купона или не досрочное погашение
         SELECT EXTRACT (MONTH FROM v_Date), EXTRACT (MONTH FROM one_prm.t_Maturity)
           INTO v_ExecMonth, v_MaturityMonth
           FROM dual;
         
         BEGIN 
          SELECT COUNT(1) INTO v_SubordinateFIID FROM davoiriss_dbt avoir WHERE avoir.t_fiid = p_FIID and avoir.T_SUBORDINATED != 'X';
         EXCEPTION 
              WHEN NO_DATA_FOUND THEN v_SubordinateFIID := 0;
         END;

         IF v_ExecMonth != v_MaturityMonth and v_SubordinateFIID != 0 THEN
           --дата переходящая, начисляем до конца месяца
           v_CalcDate := LAST_DAY(v_Date);
           v_FullWrt  := 0;
         ELSE
           --начисляем до даты погашения
           v_CalcDate := one_prm.t_Maturity;
           v_FullWrt  := 1;
         END IF;

         IF v_CalcOutlay = 1 AND v_CorrIntToEIR = 1 THEN
           --При расчете корректировки нужны также суммы доначисления комиссий по выпуску
           RSI_СalcOwnFiComTMP(p_FIID, v_Date, v_CalcDate, v_FullWrt);
         END IF;

         RSI_ChargeExpenseToOwnLotsTMP( v_Date,           -- Дата
                                        v_CalcDate,       -- Дата окончания периода начисления
                                        p_FIID,           -- Выпуск
                                        v_Department,     -- Филиал
                                        v_CalcIntereset,  -- Начисление процентного расхода
                                        v_CalcDiscount,   -- Начисление дисконтного расхода
                                        v_CalcBonus,      -- Начисление премии
                                        v_CalcDefDiff,    -- Начисление отсроченной разницы
                                        v_CalcOutlay,     -- Начисление затрат по договору
                                        v_CorrIntToEIR,   -- Корректировка % до ЭСП
                                        0                 -- Начисление доп. дохода по БИО
                                      );

         RSI_SaveChargeExpenseToOwnLots ( v_Date,
                                          p_DocumentID,
                                          -1
                                        );

         v_TotalAddCommSum := 0;
         v_TotalAddNDSSum  := 0;
         FOR one_s IN (SELECT dls.*
                         FROM ddlsum_tmp dls, ddlcomis_dbt dlc
                        WHERE dls.t_DocKind = RSB_SECUR.DL_SECURITYCOM
                          AND dls.t_Kind    = RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM
                          AND dlc.t_ID      = dls.t_DocID
                          AND dls.t_ID      > 0
                      )
         LOOP

           INSERT INTO DDLSUM_TMP (T_ID, T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                           VALUES (-1*DDLSUM_TMP_SEQ.NEXTVAL, one_s.T_DOCKIND, one_s.T_DOCID, one_s.T_KIND, one_s.T_DATE, one_s.t_Sum, one_s.t_NDS, one_s.T_CURRENCY, one_s.T_IMMATERIAL, 0, p_GrpID, p_FIID);

           v_TotalAddCommSum := v_TotalAddCommSum + one_s.t_Sum; 
           v_TotalAddNDSSum  := v_TotalAddNDSSum  + one_s.t_NDS;  
         END LOOP;

         IF v_TotalAddCommSum > 0 OR v_TotalAddNDSSum > 0 THEN
           INSERT INTO DDLSUM_DBT (T_DLSUMID, T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                           VALUES (0, one_prm.t_BOfficeKind, one_prm.t_DealID, RSB_SECUR.DLSUM_KIND_OWNAVR_DEALAMORTCOM, v_Date, v_TotalAddCommSum, v_TotalAddNDSSum, RSI_RSB_FIINSTR.NATCUR, CHR(0), 0, p_GrpID, p_FIID);
         
         END IF;
       END IF;
     END LOOP;

     FOR one_s IN (SELECT T_DOCKIND, T_DOCID, T_KIND, T_DATE, NVL(SUM(T_SUM),0) as SumSum, NVL(SUM(T_NDS),0) as SumNDS, T_CURRENCY, T_IMMATERIAL, T_GRPID, T_FIID
                     FROM ddlsum_tmp
                    WHERE t_ID < 0
                    GROUP BY T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_CURRENCY, T_IMMATERIAL, T_GRPID, T_FIID
                  )
     LOOP

       RSI_DLGR.SetDLSUM(one_s.t_DocKind,
                         one_s.t_DocID,
                         one_s.t_Kind,
                         one_s.t_Currency,
                         one_s.t_Date,
                         one_s.SumSum,
                         one_s.SumNDS,
                         one_s.t_GrpID,
                         one_s.t_FIID
                        );
     END LOOP;

     DELETE FROM DDLSUM_TMP;

     -- 4.4.2. Обработать Поставку
     FOR one_prm IN (SELECT RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND)) OGroup,
                            NVL(RQ.T_ID, 0) RQID,
                            LEG.T_CFI CFI, LEG.T_PRINCIPAL Principal, LEG.T_NKD NKD, LEG.T_PFI FIID, LEG.T_MATURITY Maturity,
                            TK.T_DEALID DealID, TK.T_BOFFICEKIND BOfficeKind, TK.T_DEALDATE DealDate, TK.T_DEALTIME DealTime, TK.T_NUMBER_COUPON Number_Coupon,
                            TK.T_DEALCODE DealCode
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDLRQ_DBT RQ, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL, DDL_LEG_DBT LEG
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND  = RSB_SECUR.DL_RETIREMENT_OWN
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYOWN
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND TK.T_PFI          = GRDEAL.T_FIID
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND LEG.T_LEGKIND = 0
                        AND LEG.T_DEALID = TK.T_DEALID
                        AND LEG.T_LEGID = 0
                        AND RQ.T_DOCKIND(+) = TK.T_BOFFICEKIND
                        AND RQ.T_DOCID(+) = TK.T_DEALID
                        AND RQ.T_STATE(+) = RSI_DLRQ.DLRQ_STATE_EXEC
                        AND RQ.T_SUBKIND(+) = RSI_DLRQ.DLRQ_SUBKIND_AVOIRISS
                        AND RQ.T_FIID(+) = TK.T_PFI
                        AND RQ.T_TYPE(+) = RSI_DLRQ.DLRQ_TYPE_DELIVERY --Поставка
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                      ORDER BY RSB_SECUR.IsRet_ADDINCOME(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) DESC
                    )
     LOOP

       SetContextDeal(one_prm.DealID);
       SetContextFIID(p_FIID);

       v_Nominal := RSI_RSB_FIInstr.FI_GetNominalOnDate(p_FIID, one_prm.DealDate);

       v_Lot := NULL;

       IF RSB_SECUR.IsRet_Issue(one_prm.OGroup) = 1 THEN --Погашение ОЭБ
          v_Lot.T_DOCKIND          := 29; /*DLDOC_PAYMENT*/
          v_Lot.T_DOCID            := one_prm.RQID;
          v_Lot.T_PORTFOLIO        := KINDPORT_UNDEF;
          v_Lot.T_GROUPID          := -1;
          v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_RET_PLACE; --Возврат из размещения
          v_Lot.T_KIND             := WRTSUM_KIND_DI; --Погашение выпуска
          if( (one_prm.Number_Coupon is not NULL) and one_prm.Number_Coupon <> chr(1) or one_prm.Number_Coupon <> chr(0) )then
             v_Amount              := WRTGetAmountOwn(v_Department, one_prm.FIID, one_prm.DealDate, 1, 1) -
                                      WRTGetAmountFromRetireOwn(v_Department, one_prm.FIID, one_prm.Number_Coupon, one_prm.DealID);
          else
             v_Amount              := WRTGetAmountOwn(v_Department, one_prm.FIID, one_prm.DealDate, 1, 1);
          end if;
          v_Lot.T_SUM              := v_Amount * v_Nominal;
       ELSIF RSB_SECUR.IsRet_ADDINCOME (one_prm.OGroup) = 1 THEN --Погашение доп. дохода
          v_Lot.T_DOCKIND          := one_prm.BOfficeKind;
          v_Lot.T_DOCID            := one_prm.DealID;
          v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_ADDINCOME; --Погашение доп. дохода
          v_Lot.T_KIND             := WRTSUM_KIND_DAI; --Погашение доп. дохода
          v_Amount                 := WRTGetAmountOwn(v_Department, one_prm.FIID, one_prm.DealDate, 1, 0) -
                                      WRTGetAmountFromRetireOwn(v_Department, one_prm.FIID, one_prm.Number_Coupon, one_prm.DealID, 0, 1);
          v_Lot.T_SUM              := 0;
       ELSE --Погашение купона ОЭБ
          v_Lot.T_DOCKIND          := one_prm.BOfficeKind;
          v_Lot.T_DOCID            := one_prm.DealID;
          v_Lot.T_BUY_SALE         := PM_WRITEOFF_SUM_COUPON; --Погашение купонов
          v_Lot.T_KIND             := WRTSUM_KIND_DC; --Погашение купона
          v_Amount                 := WRTGetAmountOwn(v_Department, one_prm.FIID, one_prm.DealDate, 1, 0) -
                                      WRTGetAmountFromRetireOwn(v_Department, one_prm.FIID, one_prm.Number_Coupon, one_prm.DealID);
          v_Lot.T_SUM              := 0;
       END IF;

       v_Lot.T_SUMID            := 0;
       v_Lot.T_PARTNUM          := 0;
       v_Lot.T_PARTY            := UnknownParty; --НашБанк
       v_Lot.T_FIID             := one_prm.FIID;
       v_Lot.T_DATE             := one_prm.Maturity;
       v_Lot.T_TIME             := one_prm.DealTime;
       v_Lot.T_AMOUNT           := v_Amount;
       v_Lot.T_CURRENCY         := one_prm.CFI;
       v_Lot.T_COST             := v_Lot.T_SUM;
       v_Lot.T_COUPON           := one_prm.Number_Coupon;
       IF v_Lot.T_COUPON <> CHR(1) THEN
         v_Lot.T_NKDAMOUNT      := one_prm.NKD*v_Amount/one_prm.Principal;
       END IF;
       v_Lot.T_DEPARTMENT       := v_Department;
       v_Lot.T_DEALID           := one_prm.DealID;
       v_Lot.T_DEALDATE         := one_prm.DealDate;
       v_Lot.T_DEALCODE         := one_prm.DealCode;
       v_Lot.T_STATE            := PM_WRTSUM_CLOSE_OWN;
       v_Lot.T_ENTERDATE        := one_prm.Maturity;
       v_Lot.T_STATEDATE        := one_prm.Maturity;
       v_Lot.T_CHANGEDATE       := one_prm.Maturity;
       v_Lot.T_ACTION           := PM_WRT_UPDTMODE_CREATE;
       v_Lot.T_ID_OPERATION     := p_DocumentID;
       v_Lot.T_ID_STEP          := -1;
       v_Lot.T_TRUST            := CHR(0);
       v_Lot.T_ACTIVATEDATE     := one_prm.Maturity;
       v_Lot.T_ACTIVATETIME     := one_prm.DealTime;
       v_Lot.T_ACCFI            := v_DetermineAccFI;

       RSI_InsDfltIntoWRTSUM(v_Lot);
       INSERT INTO DPMWRTSUM_DBT VALUES v_Lot RETURNING t_SUMID INTO v_Lot.T_SUMID;

       RSI_WRTLinkRetireOwn( v_Lot.T_SUMID, p_DocumentID, -1 );

       IF RSB_SECUR.IsRet_Issue(one_prm.OGroup) = 1 THEN --Погашение ОЭБ

         RSI_СalcOwnFiComTMP(p_FIID, v_Date, v_CalcDate, 1);

         v_TotalAddCommSum := 0;
         v_TotalAddNDSSum  := 0;
         FOR one_s IN (SELECT dls.*
                         FROM ddlsum_tmp dls, ddlcomis_dbt dlc
                        WHERE dls.t_DocKind = RSB_SECUR.DL_SECURITYCOM
                          AND dls.t_Kind    = RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM
                          AND dlc.t_ID      = dls.t_DocID
                          AND dls.t_ID      > 0
                      )
         LOOP

           INSERT INTO DDLSUM_TMP (T_ID, T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                           VALUES (-1*DDLSUM_TMP_SEQ.NEXTVAL, one_s.T_DOCKIND, one_s.T_DOCID, one_s.T_KIND, one_s.T_DATE, one_s.t_Sum, one_s.t_NDS, one_s.T_CURRENCY, one_s.T_IMMATERIAL, 0, p_GrpID, p_FIID);

           v_TotalAddCommSum := v_TotalAddCommSum + one_s.t_Sum; 
           v_TotalAddNDSSum  := v_TotalAddNDSSum  + one_s.t_NDS;  
         END LOOP;

         IF v_TotalAddCommSum > 0 OR v_TotalAddNDSSum > 0 THEN
           INSERT INTO DDLSUM_DBT (T_DLSUMID, T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_SUM, T_NDS, T_CURRENCY, T_IMMATERIAL, T_INSTANCE, T_GRPID, T_FIID)
                           VALUES (0, one_prm.BOfficeKind, one_prm.DealID, RSB_SECUR.DLSUM_KIND_OWNAVR_DEALAMORTCOM, v_Date, v_TotalAddCommSum, v_TotalAddNDSSum, RSI_RSB_FIINSTR.NATCUR, CHR(0), 0, p_GrpID, p_FIID);
         
         END IF;
       END IF;

     END LOOP;

     FOR one_s IN (SELECT T_DOCKIND, T_DOCID, T_KIND, T_DATE, NVL(SUM(T_SUM),0) as SumSum, NVL(SUM(T_NDS),0) as SumNDS, T_CURRENCY, T_IMMATERIAL, T_GRPID, T_FIID
                     FROM ddlsum_tmp
                    WHERE t_ID < 0
                    GROUP BY T_DOCKIND, T_DOCID, T_KIND, T_DATE, T_CURRENCY, T_IMMATERIAL, T_GRPID, T_FIID
                  )
     LOOP

       RSI_DLGR.SetDLSUM(one_s.t_DocKind,
                         one_s.t_DocID,
                         one_s.t_Kind,
                         one_s.t_Currency,
                         one_s.t_Date,
                         one_s.SumSum,
                         one_s.SumNDS,
                         one_s.t_GrpID,
                         one_s.t_FIID
                        );
     END LOOP;

     DELETE FROM DDLSUM_TMP;

     -- 4.5.
     FOR one_prm IN (SELECT GRDEAL2.T_ID GrDealID2, TK.T_DEALID
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL, DDLGRDEAL_DBT GRDEAL2
                      WHERE S.T_GRPID          = p_GrpID
                        AND S.T_TYPE           = 1
                        AND SD.T_SUBGRPID      = S.T_SUBGRPID
                        AND GRDEAL.T_ID        = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECUROWN, RSB_SECUR.DL_AVRWRTOWN, RSB_SECUR.DL_RETIREMENT_OWN)
                        AND GRDEAL.T_TEMPLNUM  = RSI_DLGR.DLGR_TEMPL_DELIVERYOWN --Поставка ОЭБ
                        AND GRDEAL.T_PLANDATE  = v_Date
                        AND GRDEAL.T_FIID      = p_FIID
                        AND TK.T_DEALID        = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID      = -1
                        AND TK.T_DEPARTMENT    = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                        AND GRDEAL2.T_DOCKIND  = GRDEAL.T_DOCKIND
                        AND GRDEAL2.T_DOCID    = GRDEAL.T_DOCID
                        AND GRDEAL2.T_FIID     = GRDEAL.T_FIID
                        AND GRDEAL2.T_PLANDATE = v_Date
                        AND GRDEAL2.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_RECDELIVERY --Учет поставки
                    )
     LOOP

       SetContextDeal( one_prm.t_DealID );
       SetContextFIID(p_FIID);

       --4.5.1  установить на строку графика по учёту поставки БУ = П, при условии что поставка обработана в данной операции.
       RSI_DLGR.RSI_UpdateGrDealAccByID(one_prm.GrDealID2, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, RSI_DLGR.DLGRACC_STATE_PLAN, NULL, 0);

       --4.5.2 Создать связь группы обработки с графиком
       RSI_DLGR.RSI_SetDocGrDeal(one_prm.GrDealID2, 0, 0, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);

     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;


     --4.6.
     FOR one_prm IN (SELECT GRDEAL.T_ID GrDealID, TK.T_DEALID
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND IN (RSB_SECUR.DL_SECUROWN, RSB_SECUR.DL_AVRWRTOWN, RSB_SECUR.DL_RETIREMENT_OWN)
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_DELIVERYOWN --Поставка ОЭБ
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                    )
     LOOP

       SetContextDeal( one_prm.t_DealID );
       SetContextFIID(p_FIID);

       --4.6.1 установить на строку графика по поставке БУ = Ф
       RSI_DLGR.RSI_UpdateGrDealAccByID(one_prm.GrDealID, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, RSI_DLGR.DLGRACC_STATE_FACTEXEC, NULL, 0);

       --4.6.2 Создать связь группы обработки с графиком
       RSI_DLGR.RSI_SetDocGrDeal(one_prm.GrDealID, 0, 0, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);

     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;

     -- 4.7.
     FOR one_prm IN (SELECT GRDEAL2.T_ID GrDealID2, TK.T_DEALID
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL, DDLGRDEAL_DBT GRDEAL2
                      WHERE S.T_GRPID          = p_GrpID
                        AND S.T_TYPE           = 1
                        AND SD.T_SUBGRPID      = S.T_SUBGRPID
                        AND GRDEAL.T_ID        = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND   = RSB_SECUR.DL_RETIREMENT_OWN
                        AND GRDEAL.T_TEMPLNUM  = RSI_DLGR.DLGR_TEMPL_EXECOWN --Исполнение ОЭБ
                        AND GRDEAL.T_PLANDATE  = v_Date
                        AND GRDEAL.T_FIID      = p_FIID
                        AND TK.T_DEALID        = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID      = -1
                        AND TK.T_DEPARTMENT    = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                        AND GRDEAL2.T_DOCKIND  = GRDEAL.T_DOCKIND
                        AND GRDEAL2.T_DOCID    = GRDEAL.T_DOCID
                        AND GRDEAL2.T_FIID     = GRDEAL.T_FIID
                        AND GRDEAL2.T_PLANDATE = v_Date
                        AND GRDEAL2.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_MOVEACC --Перенос на счета к исполнению
                    )
     LOOP

       SetContextDeal( one_prm.t_DealID );
       SetContextFIID(p_FIID);

       --4.7.1  установить на строку графика по переносу на счета к исполнению БУ = П, при условии что исполнение обработано в данной операции.
       RSI_DLGR.RSI_UpdateGrDealAccByID(one_prm.GrDealID2, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, RSI_DLGR.DLGRACC_STATE_PLAN, NULL, 0);

       --4.7.2 Создать связь группы обработки с графиком
       RSI_DLGR.RSI_SetDocGrDeal(one_prm.GrDealID2, 0, 0, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);

     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;

     --4.8.
     FOR one_prm IN (SELECT GRDEAL.T_ID GrDealID, TK.T_DEALID
                       FROM DPMWRTSUBGRP_DBT S, DPMWRTSUBDOC_DBT SD, DDL_TICK_DBT TK, DDLGRDEAL_DBT GRDEAL
                      WHERE S.T_GRPID         = p_GrpID
                        AND S.T_TYPE          = 1
                        AND SD.T_SUBGRPID     = S.T_SUBGRPID
                        AND GRDEAL.T_ID       = SD.T_GRDEALID
                        AND GRDEAL.T_DOCKIND  = RSB_SECUR.DL_RETIREMENT_OWN
                        AND GRDEAL.T_TEMPLNUM = RSI_DLGR.DLGR_TEMPL_EXECOWN --Исполнение ОЭБ
                        AND GRDEAL.T_PLANDATE = v_Date
                        AND GRDEAL.T_FIID     = p_FIID
                        AND TK.T_DEALID       = GRDEAL.T_DOCID
                        AND TK.T_CLIENTID     = -1
                        AND TK.T_DEPARTMENT   = v_Department
                        AND (v_Kind_Operation = 0 OR TK.T_DEALTYPE = v_Kind_Operation)
                        AND (v_OperType = 0 OR 
                             v_Kind_Operation != 0 OR 
                             1 = (CASE WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_EXCHANGE AND RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OUTEXCHANGE AND RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 1 THEN 1
                                       WHEN v_OperType = RSB_SECUR.SC_ACCOPERTYPE_OTHER AND 
                                            RSB_SECUR.ISEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 AND
                                            RSB_SECUR.ISOUTEXCHANGE(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(TK.T_DEALTYPE, TK.T_BOFFICEKIND))) = 0 THEN 1
                                       ELSE 0 END)
                            )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BU WHERE BU.T_GRDEALID = GRDEAL.T_ID AND BU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_ACCOUNTING AND BU.T_STATE = RSI_DLGR.DLGRACC_STATE_PLAN )
                        AND EXISTS(SELECT 1 FROM DDLGRACC_DBT BOU WHERE BOU.T_GRDEALID = GRDEAL.T_ID AND BOU.T_ACCNUM = RSI_DLGR.DLGR_ACCKIND_BACKOFFICE AND BOU.T_STATE = RSI_DLGR.DLGRACC_STATE_FACTEXEC)
                    )
     LOOP

       SetContextDeal( one_prm.t_DealID );
       SetContextFIID(p_FIID);

       --4.8.1 установить на строку графика по исполнению БУ = Ф
       RSI_DLGR.RSI_UpdateGrDealAccByID(one_prm.GrDealID, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, RSI_DLGR.DLGRACC_STATE_FACTEXEC, NULL, 0);

       --4.8.2 Создать связь группы обработки с графиком
       RSI_DLGR.RSI_SetDocGrDeal(one_prm.GrDealID, 0, 0, RSB_SECUR.DL_SCACCOUNTING, p_DocumentID, p_GrpID, 0, 0);

     END LOOP;

     RSI_DLGR.RSI_ExecCommitDLGR;


   END WRTLinkOurLotsOwnByFI;

   PROCEDURE RSI_WRTLinkOurLotsOwn( p_DocumentID IN NUMBER,
                                    p_OperDate IN DATE,
                                    p_GrpID IN NUMBER
                                  )
   AS

   BEGIN

     FOR one_fi IN (SELECT *
                      FROM DPMWRTGRPFI_DBT
                     WHERE T_GRPID = p_GrpID
                   )
     LOOP

       WRTLinkOurLotsOwnByFI(p_DocumentID, p_OperDate, p_GrpID, one_fi.t_FIID);

     END LOOP;

   END RSI_WRTLinkOurLotsOwn;

   --Выполняет откат обработки лотов Нашего Банка в сервисной операции БУ, в том числе и лотов ОЭБ
   PROCEDURE RSI_WRTRecoilLinkOurLots(p_DocumentID IN NUMBER,
                                      p_GrpID IN NUMBER
                                     )
   AS
     v_FIID NUMBER;
     v_Department NUMBER;
     v_Party NUMBER;
     v_Contract NUMBER;

     v_ID_Operation NUMBER;
     v_ID_Step NUMBER;
     v_Instance NUMBER;

     v_Nbc NUMBER;
     v_Nlot NUMBER;
     v_N NUMBER;

     v_pmwrtbc  DPMWRTBC_DBT%ROWTYPE;
   BEGIN

     SELECT T_DEPARTMENT, T_PARTY, T_CONTRACT INTO v_Department, v_Party, v_Contract
       FROM DPMWRTGRP_DBT
      WHERE T_ID = p_GrpID;

     FOR one_fi IN (SELECT T_FIID FROM DPMWRTGRPFI_DBT WHERE T_GRPID = p_GrpID)
     LOOP

       v_FIID := one_fi.t_FIID;

       --2. Удалить все связи по убыванию
       DELETE FROM (SELECT * FROM DPMWRTLNK_DBT LNK
                     WHERE LNK.T_ID_OPERATION = p_DocumentID
                       AND LNK.T_ID_STEP = -1
                       AND EXISTS (SELECT 1 
                                     FROM DPMWRTSUM_DBT LOT 
                                    WHERE LOT.T_FIID       = v_FIID 
                                      AND LOT.T_DEPARTMENT = v_Department 
                                      AND LOT.T_SUMID      = LNK.T_BUYID
                                      AND LOT.T_PARTY      = v_Party
                                      AND LOT.T_CONTRACT   = v_Contract
                                  )
                     ORDER BY LNK.T_LNKID DESC
                    );

       --3.
       SELECT COUNT(1) INTO v_N
         FROM DPMWRTSUM_DBT
        WHERE T_ID_OPERATION = p_DocumentID
          AND T_ID_STEP      = -1
          AND T_FIID         = v_FIID
          AND T_DEPARTMENT   = v_Department
          AND T_PARTY        = v_Party
          AND T_CONTRACT     = v_Contract
          AND ROWNUM         = 1;

       WHILE v_N > 0 LOOP

         FOR WRTSum IN (SELECT *
                          FROM DPMWRTSUM_DBT
                         WHERE t_ID_Operation = p_DocumentID AND
                               t_ID_Step      = -1 AND
                               t_FIID         = v_FIID AND
                               t_Department   = v_Department AND
                               t_Party        = v_Party AND
                               t_Contract     = v_Contract
                       ) LOOP

            IF WRTSum.t_Instance = 0 THEN
              DELETE FROM DPMWRTSUM_DBT
                  WHERE t_SumID = WRTSum.t_SumID;
            ELSE
               BEGIN
                 SELECT * INTO v_pmwrtbc
                   FROM DPMWRTBC_DBT
                  WHERE t_SumID    = WRTSum.t_SumID AND
                        t_Instance = (WRTSum.t_Instance - 1);
                 EXCEPTION
                    WHEN OTHERS THEN
                      v_pmwrtbc := NULL;
               END;

               IF (v_pmwrtbc.T_SUMID IS NOT NULL) THEN

                 UPDATE DPMWRTSUM_DBT
                    SET t_ID_Operation       = v_pmwrtbc.t_ID_Operation,
                        t_ID_Step            = v_pmwrtbc.t_ID_Step,
                        t_Action             = v_pmwrtbc.t_Action,
                        t_Instance           = v_pmwrtbc.t_Instance,
                        t_ChangeDate         = v_pmwrtbc.t_ChangeDate,
                        t_FIID               = v_pmwrtbc.t_FIID,
                        t_Portfolio          = v_pmwrtbc.t_Portfolio,
                        t_GroupID            = v_pmwrtbc.t_GroupID,
                        t_Date               = v_pmwrtbc.t_Date,
                        t_Time               = v_pmwrtbc.t_Time,
                        t_Amount             = v_pmwrtbc.t_Amount,
                        t_AmountBD           = v_pmwrtbc.t_AmountBD,
                        t_Sum                = v_pmwrtbc.t_Sum,
                        t_Currency           = v_pmwrtbc.t_Currency,
                        t_Cost               = v_pmwrtbc.t_Cost,
                        t_BalanceCost        = v_pmwrtbc.t_BalanceCost,
                        t_BalanceCostBD      = v_pmwrtbc.t_BalanceCostBD,
                        t_NKDAmount          = v_pmwrtbc.t_NKDAmount,
                        t_InterestIncome     = v_pmwrtbc.t_InterestIncome,
                        t_NotCarryInterest   = v_pmwrtbc.t_NotCarryInterest,
                        t_InterestDate       = v_pmwrtbc.t_InterestDate,
                        t_BegDate            = v_pmwrtbc.t_BegDate,
                        t_BegDiscount        = v_pmwrtbc.t_BegDiscount,
                        t_OldBegDate         = v_pmwrtbc.t_OldBegDate,
                        t_OldBegDiscount     = v_pmwrtbc.t_OldBegDiscount,
                        t_DiscountIncome     = v_pmwrtbc.t_DiscountIncome,
                        t_NotCarryDiscount   = v_pmwrtbc.t_NotCarryDiscount,
                        t_DiscountDate       = v_pmwrtbc.t_DiscountDate,
                        t_Outlay             = v_pmwrtbc.t_Outlay,
                        t_ReservAmount       = v_pmwrtbc.t_ReservAmount,
                        t_IncomeReserv       = v_pmwrtbc.t_IncomeReserv,
                        t_ReservDate         = v_pmwrtbc.t_ReservDate,
                        t_OverAmount         = v_pmwrtbc.t_OverAmount,
                        t_OverAmountBD       = v_pmwrtbc.t_OverAmountBD,
                        t_OverDate           = v_pmwrtbc.t_OverDate,
                        t_State              = v_pmwrtbc.t_State,
                        t_StateDate          = v_pmwrtbc.t_StateDate,
                        t_BegBonusDate       = v_pmwrtbc.t_BegBonusDate,
                        t_BegBonus           = v_pmwrtbc.t_BegBonus,
                        t_Bonus              = v_pmwrtbc.t_Bonus,
                        t_OldBonus           = v_pmwrtbc.t_OldBonus,
                        t_BonusDate          = v_pmwrtbc.t_BonusDate,
                        t_BegInterestDate    = v_pmwrtbc.t_BegInterestDate,
                        t_BegDiscountDate    = v_pmwrtbc.t_BegDiscountDate,
                        t_DiscountCorr       = v_pmwrtbc.t_DiscountCorr   ,
                        t_OldBegBonus        = v_pmwrtbc.t_OldBegBonus    ,
                        t_RecalcDate         = v_pmwrtbc.t_RecalcDate     ,
                        t_IsEdit             = v_pmwrtbc.t_IsEdit,
                        T_NOTWRTBONUS        = v_pmwrtbc.T_NOTWRTBONUS,
                        T_COSTPFI            = v_pmwrtbc.T_COSTPFI,
                        t_ActivateDate       = v_pmwrtbc.t_ActivateDate,
                        t_ActivateTime       = v_pmwrtbc.t_ActivateTime,
                        t_BlockAmount        = v_pmwrtbc.t_BlockAmount,
                        T_BEGDEFDIFF         = v_pmwrtbc.T_BEGDEFDIFF,
                        T_ACCOUNTEDDEFDIFF   = v_pmwrtbc.T_ACCOUNTEDDEFDIFF,
                        T_DEFDIFFDATE        = v_pmwrtbc.T_DEFDIFFDATE,
                        T_WRTOUTLAY          = v_pmwrtbc.T_WRTOUTLAY,
                        T_WRTOUTLAYDATE      = v_pmwrtbc.T_WRTOUTLAYDATE,
                        T_VATOUTLAY          = v_pmwrtbc.T_VATOUTLAY,
                        T_WRTVATOUTLAY       = v_pmwrtbc.T_WRTVATOUTLAY,
                        T_EFFECTINTERESTRATE = v_pmwrtbc.T_EFFECTINTERESTRATE,
                        T_FAIRVALUE          = v_pmwrtbc.T_FAIRVALUE,
                        T_AMORTCOST          = v_pmwrtbc.T_AMORTCOST,
                        T_CORRVALUE          = v_pmwrtbc.T_CORRVALUE,
                        T_CORRDATE           = v_pmwrtbc.T_CORRDATE,
                        T_CORRINTTOEIR       = v_pmwrtbc.T_CORRINTTOEIR,   
                        T_CORRINTTOEIRDATE   = v_pmwrtbc.T_CORRINTTOEIRDATE,
                        T_ACCBALANCECOST     = v_pmwrtbc.T_ACCBALANCECOST,
                        T_ESTRESERVE         = v_pmwrtbc.T_ESTRESERVE,
                        T_ESTRESERVEDATE     = v_pmwrtbc.T_ESTRESERVEDATE,
                        T_CORRESTRESERVE     = v_pmwrtbc.T_CORRESTRESERVE,
                        T_CORRESTRESERVEDATE = v_pmwrtbc.T_CORRESTRESERVEDATE,
                        T_BEGDEFDIFFDATE     = v_pmwrtbc.T_BEGDEFDIFFDATE,
                        T_ADDINCOMEOWN       = v_pmwrtbc.T_ADDINCOMEOWN,
                        T_ADDINCOMEOWNDATE   = v_pmwrtbc.T_ADDINCOMEOWNDATE,
                        T_HEDGCORR           = v_pmwrtbc.T_HEDGCORR,   
                        T_HEDGCORRDATE       = v_pmwrtbc.T_HEDGCORRDATE,
                        T_AMORTHEDGCORR      = v_pmwrtbc.T_AMORTHEDGCORR,   
                        T_AMORTHEDGCORRDATE  = v_pmwrtbc.T_AMORTHEDGCORRDATE

                  WHERE t_SumID = WRTSum.t_SumID;

                  DELETE FROM DPMWRTBC_DBT
                   WHERE t_BCID = v_pmwrtbc.t_BCID;

                END IF;

            END IF;

         END LOOP;

         SELECT COUNT(1) INTO v_N
           FROM DPMWRTSUM_DBT
          WHERE T_ID_OPERATION = p_DocumentID
            AND T_ID_STEP      = -1
            AND T_FIID         = v_FIID
            AND T_DEPARTMENT   = v_Department
            AND T_PARTY        = v_Party
            AND T_CONTRACT     = v_Contract
            AND ROWNUM         = 1;

       END LOOP;

       --5
       SELECT COUNT(1) INTO v_N
         FROM DPMWRTBC_DBT BC, DPMWRTSUM_DBT S
        WHERE BC.T_ID_OPERATION = p_DocumentID
          AND BC.T_ID_STEP      = -1
          AND S.T_SUMID         = BC.T_SUMID
          AND S.T_FIID          = v_FIID
          AND S.T_DEPARTMENT    = v_Department
          AND S.T_PARTY         = v_Party
          AND S.T_CONTRACT      = v_Contract;

       IF v_N > 0 THEN
         SetError( WRTOFF_ERROR_20240 ); --Откатываемая операция по лоту не является последней
       END IF;

     END LOOP;

     --6.
     FOR one_grdoc IN (SELECT DISTINCT T_GRDEALID
                         FROM DDLGRDOC_DBT
                        WHERE T_GRPID = p_GrpID
                          AND T_SERVDOCKIND = RSB_SECUR.DL_SCACCOUNTING
                          AND T_SERVDOCID = p_DocumentID
                      )
     LOOP
       RSI_DLGR.RSI_BackUpdateGrDealAccByID(one_grdoc.T_GRDEALID, RSI_DLGR.DLGR_ACCKIND_ACCOUNTING, 0);
     END LOOP;

     --7.
     DELETE FROM DDLGRDOC_DBT
      WHERE T_GRPID = p_GrpID
        AND T_SERVDOCKIND = RSB_SECUR.DL_SCACCOUNTING
        AND T_SERVDOCID = p_DocumentID;


   END RSI_WRTRecoilLinkOurLots;

   --создание scdlpmwr на шаге операции
   PROCEDURE RSI_CreateSCDLPMWR(RecDlpmwr IN RAW)
   AS
     rDlpmwr    dscdlpmwr_dbt%rowtype;
   BEGIN

      InitError();
      RSI_GetSCDLPMWRFromRAW( RecDlpmwr, rDlpmwr );

      INSERT INTO dscdlpmwr_dbt VALUES rDlpmwr;

   END;   -- RSI_CreateSCDLPMWR

   --откат создание scdlpmwr на шаге операции
   PROCEDURE RSI_RecoilSCDLPMWR(DealKind IN NUMBER, DealID IN NUMBER, SumID IN NUMBER, NewFIID IN NUMBER, Party IN NUMBER)
   AS
   BEGIN

      InitError();

      DELETE FROM dscdlpmwr_dbt
        WHERE t_DealKind = DealKind
          AND t_DealID = DealID
          AND t_SumID = SumID
          AND t_NewFIID = NewFIID;

   END;   -- RSI_CreateSCDLPMWR

   --Начислить доход по лотам во временную таблицу для последующего извлечения сумм по лотам для отчета "Оценка портфеля"
   PROCEDURE WRTChargeIncomToLotsTMP_Rep( p_CalcDate           IN DATE,   -- Дата
                                          p_FIID               IN NUMBER, -- Выпуск
                                          p_Department         IN NUMBER, -- Филиал
                                          p_P1                 IN NUMBER DEFAULT UnknownValue, -- Портфели (по приоритетам, до 5-х штук, незаданные
                                          p_P2                 IN NUMBER DEFAULT UnknownValue,
                                          p_P3                 IN NUMBER DEFAULT UnknownValue,
                                          p_P4                 IN NUMBER DEFAULT UnknownValue,
                                          p_P5                 IN NUMBER DEFAULT UnknownValue,
                                          p_Party              IN NUMBER,
                                          p_Contract           IN NUMBER,
                                          p_CalcInterest       IN INTEGER, --начислять ПД
                                          p_CalcDiscount       IN INTEGER, --начислять ДД
                                          p_CalcBonus          IN INTEGER  --начислять премию
                                        )
   AS
     v_AmortizationMethod NUMBER;
     v_IsResponsible      NUMBER;
     v_CalcDiscount       NUMBER := 0;
     v_CalcInterest       NUMBER := 0;
     v_CalcBonus          NUMBER := 0;
   BEGIN
     InitError();

     IF (p_CalcDiscount = 1 AND p_Party = UnknownParty ) THEN  
        v_CalcDiscount := WRTNeedChargeIncome( p_FIID );
     END IF;

     if( p_CalcInterest = 1 AND p_Party = UnknownParty )then  
        v_CalcInterest := WRTNeedChargeInterestIncome( p_FIID );
     end if;

     if ( p_CalcInterest = 1 AND p_Party = UnknownParty AND WRTNeedChargeBonus(p_FIID) = 1 ) then
        v_CalcBonus := 1; -- да
     else
        v_CalcBonus := 0; -- нет
     end if;

     v_IsResponsible := RSI_RSB_FIInstr.FI_IsResponsible( p_FIID, p_CalcDate );
     v_AmortizationMethod := GetAmortizationMethod( p_Party, p_Contract );

     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     --Выполнить начисление во временную таблицу
     RSI_WRTChargeIncomToLotsTMP (false, p_CalcDate, p_CalcDate, p_FIID, p_Department, p_P1, p_P2, p_P3, p_P4, p_P5, p_Party,
                                  p_Contract, v_CalcInterest=1, v_CalcDiscount=1, v_CalcBonus=1, false, true, v_AmortizationMethod );

   EXCEPTION WHEN OTHERS THEN NULL;
   END;   --WRTChargeIncomToLotsTMP

   --Откат создания денежных параметров сделки ПРЕПО
   PROCEDURE RSI_WRTRestoreCurrParmREPO( p_DealID       IN NUMBER,
                                          p_AttrID       IN NUMBER,
                                          p_ID_Operation IN NUMBER,
                                          p_ID_Step      IN NUMBER
                                        )
   AS
     v_Tick ddl_tick_dbt%rowtype;
   BEGIN

     InitError();

     SELECT * into v_Tick
       FROM DDL_TICK_DBT
      WHERE T_DEALID = p_DealID;

     --Восстнавливаем значение к категории
     RSB_SECUR.SetDealMarketTestAttrID(v_Tick.t_DealID, v_Tick.t_DealDate, p_AttrID);

     --Удалить денежные параметры
     RSI_WRTRestoreLot(p_ID_Operation, p_ID_Step, PM_WRT_UPDTMODE_RCURR, 0);

   END;--RSI_WRTRestoreCurrParmREPO

   --Создание денежных параметров сделки ПРЕПО
   PROCEDURE RSI_WRTCreateCurrParmREPO( p_DealID        IN NUMBER,
                                        p_ID_Operation  IN NUMBER,
                                        p_ID_Step       IN NUMBER,
                                        p_AmortCalcKind IN NUMBER DEFAULT 0,
                                        p_TestAttrID    IN NUMBER DEFAULT 0,
                                        p_FairValueRub  IN NUMBER DEFAULT UnknownValue
                                      )
   AS
     v_Tick ddl_tick_dbt%rowtype;
     v_Leg ddl_leg_dbt%rowtype;
     v_Rq1 ddlrq_dbt%rowtype;
     v_Rq2 ddlrq_dbt%rowtype;
     v_CurrLot DPMWRTSUM_DBT%ROWTYPE;

     v_AmortCalcKind NUMBER := RSB_SECUR.AMORTCALCKIND_EPS;--ЭПС по умолчанию
     v_RegEPSLessYear BOOLEAN := true;
     v_RegEPSWithUnImpDelta BOOLEAN := true;
     v_SignDeviation BOOLEAN := FALSE; --Отклонение существенно?
     v_RateKind NUMBER;
     v_RateVal NUMBER;
     v_EIR NUMBER := 0; --ЭПС
     v_RepoPeriodDays NUMBER := 0;
     v_MarketRateMin NUMBER   := 0; --РПСмин
     v_MarketRateMax NUMBER   := 0; --РПСмакс
     v_SourceDataLayer NUMBER := 0; --Уровень исходных данных
     v_TestAttrID NUMBER      := 2; --По умолчанию Нет
     v_FairValueRub NUMBER    := 0;
     v_Rq1AmountRub NUMBER    := 0;
     v_DeltaRub     NUMBER    := 0;
     v_AttrObsBaseData NUMBER := -1;
     v_Portfolio NUMBER := KINDPORT_UNDEF;
     v_IsSale NUMBER := 0;
     v_Msg VARCHAR2(256);
     v_Cat55 NUMBER := 0;
     v_Cat60 NUMBER := 0;
     v_AlgUsed NUMBER;
     v_AMORTCOST NUMBER := 0;
     v_ACK NUMBER;
     v_RateID NUMBER;
     v_EPS_Med NUMBER := Rsb_Common.GetRegIntValue('SECUR\МСФО\МЕТОД_РАСЧЕТА_ОТКЛ_ЭПС', 0);
     v_Val1 NUMBER;
     v_Val2 NUMBER;
     v_Val3 NUMBER;
   BEGIN

     InitError();

     SELECT * into v_Tick
       FROM DDL_TICK_DBT
      WHERE T_DEALID = p_DealID;

     SELECT * INTO v_Leg
       FROM ddl_leg_dbt
      WHERE t_LegKind = 0
        AND t_DealID = v_Tick.t_DealID
        AND t_LegID = 0;

     if( v_Tick.t_ClientID != UnknownParty )then
       RETURN;
     end if;

     if( RSB_SECUR.IsREPO(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(v_Tick.t_DealType, v_Tick.t_BofficeKind))) = 0 )then
       RETURN;
     end if;

     if( RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(v_Tick.t_DealType, v_Tick.t_BofficeKind))) != 0 )then
       v_IsSale := 1;
       v_Portfolio := KINDPORT_CURR_AC_BPP;
     else
       v_Portfolio := KINDPORT_CURR_AC_PVO;
     end if;

     SELECT * into v_Rq1
       FROM DDLRQ_DBT
      WHERE T_DOCKIND = v_Tick.t_BOfficeKind
        AND T_DOCID = v_Tick.t_DealID
        AND T_TYPE = RSI_DLRQ.DLRQ_TYPE_PAYMENT
        AND T_DEALPART = 1;

     SELECT * into v_Rq2
       FROM DDLRQ_DBT
      WHERE T_DOCKIND = v_Tick.t_BOfficeKind
        AND T_DOCID = v_Tick.t_DealID
        AND T_TYPE = RSI_DLRQ.DLRQ_TYPE_PAYMENT
        AND T_DEALPART = 2;

     IF p_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM OR p_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS THEN
       v_AmortCalcKind := p_AmortCalcKind;
     ELSE
       v_RegEPSLessYear := Rsb_Common.GetRegBoolValue('SECUR\МСФО\ЭПС ДЛЯ ДС ПО РЕПО МЕНЬШЕ ГОДА');
       if( v_RegEPSLessYear is NULL )then
         v_RegEPSLessYear := true;
       end if;

       --Определить метод расчета АС
       if( (add_months(v_Rq1.t_PlanDate,12) > v_Rq2.t_PlanDate) and (v_RegEPSLessYear = false) )then
         v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;--ЛМ
       else
         --Проверяем существенность отклонения АС, рассчитанной по методу ЛМ и ЭПС
         if( RSB_SECUR.GetEssentialDev( RSB_SECUR.LEVELESSENTIAL_AC, -- Вид уровня существенности - <Отклонение АС>
                                        v_Portfolio,                 -- Портфель
                                        v_Tick.t_DealDate,           -- Дата расчета = дата заключения сделки
                                        0,                           -- Что сравниваем  - не задаем
                                        0,                           -- С чем сравниваем  - минимальное  значение РПС  (РПСmin)
                                        0,                           -- С чем сравниваем  - максимальное значение РПС (РПСmax)
                                        v_Tick.t_BOfficeKind,        -- Вид объекта
                                        v_Tick.t_DealID,             -- Объект
                                        v_SignDeviation,             -- Да/нет
                                        v_RateKind,                  -- Наименование ставки используемой в дальнейшем
                                        v_RateVal                    -- Значение ставки
                                      ) = 0
           )then
           v_RegEPSWithUnImpDelta := Rsb_Common.GetRegBoolValue('SECUR\МСФО\ЭПС РЕПО С НЕСУЩ.ОТКЛ.ЭПС ОТ ЛМ');
           if( v_RegEPSWithUnImpDelta is NULL )then
             v_RegEPSWithUnImpDelta := true;
           end if;
           if( (v_SignDeviation = FALSE) and (v_RegEPSWithUnImpDelta = false) )then
             v_AmortCalcKind := RSB_SECUR.AMORTCALCKIND_LM;--ЛМ
           end if;
         end if;
       end if;
     END IF;

     v_Rq1AmountRub := RSI_RSB_FIInstr.ConvSum(v_Rq1.t_Amount, v_Rq1.t_FIID, RSI_RSB_FIInstr.NATCUR, v_Rq1.t_PlanDate, 1 );

     --Если v_AmortCalcKind == 2 /*ЭПС*/, необходимо определить существенность отклонения ЭПС от РПС
     if( v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS )then
       --Определить ЭПС
       v_EIR := RSB_SECUR.CalcEPS(case when v_IsSale = 1 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end, v_Tick.t_DealID, 0, v_Rq1.t_PlanDate);

       IF p_TestAttrID = 1 OR p_TestAttrID = 2 THEN
         v_TestAttrID := p_TestAttrID;
       ELSE
         --Определить количество дней ПРЕПО
         v_RepoPeriodDays := v_Rq2.t_PlanDate - v_Rq1.t_PlanDate;

         --Определяется минимальное и максимальное значение РПС (с учетом настройки SECUR\МСФО\МЕТОД_РАСЧЕТА_ОТКЛ_ЭПС)
         IF RSB_SECUR.GetRPS_LevelDevEPS
            ( case when v_IsSale=1 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end, -- Вид расчета
              1, --Фондовый дилинг
              v_Tick.t_Department,
              case when v_IsSale = 1 then 56 else 55 end,--Если сделка ОРЕПО, то 55 /*Вид банковского продукта - Размещение РЕПО */, иначе 56 /*Вид банковского продукта - Привлечение РЕПО*/
              0,                              -- Банковский продукт -не заполняем
              v_RepoPeriodDays,               -- Срок в днях
              v_Rq1.t_Amount,                 -- Сумма договора
              v_Rq1.t_FIID,                   -- Валюта договора
              0,                              -- Тип клиента - все клиенты
              v_Tick.t_DealDate,              -- Дата - дата расчета
              v_MarketRateMin,                -- РПСмин                 
              v_MarketRateMax,                -- РПСмакс                
              v_SourceDataLayer               -- Уровень исходных данных
            ) = 0 THEN
           -- Алгоритм 2
           IF v_EPS_Med = RSB_SECUR.ALG_CALCDEV_EPS2 THEN
             v_Val1 := v_MarketRateMax; -- РПСmax
             v_Val2 := v_EIR; -- ЭПС
             v_Val3 := v_Leg.t_IncomeRate / 100; -- ставка по договору
           -- Алгоритм 1
           ELSE
             v_Val1 := v_EIR; -- значение ЭПС (ЭПС)
             v_Val2 := v_MarketRateMin; -- минимальное  значение РПС (РПСmin)
             v_Val3 := v_MarketRateMax; -- максимальное значение РПС (РПСmax)
           END IF;

           --Определяется существенность отклонения ЭПС от РПС
           if( RSB_SECUR.GetEssentialDev( RSB_SECUR.LEVELESSENTIAL_EPS, -- Вид уровня существенности = Отклонение ЭПС
                                          v_Portfolio,                  -- Портфель
                                          v_Rq1.t_PlanDate,             -- Дата оплаты первой части сделки Репо
                                          v_Val1,                       -- Что сравниваем
                                          v_Val2,                       -- С чем сравниваем 1
                                          v_Val3,                       -- С чем сравниваем 2
                                          v_Tick.t_BofficeKind,         -- Вид объекта (для настройки ALG_CALCDEV_EPS2)
                                          v_Tick.t_DealID,              -- Объект (для настройки ALG_CALCDEV_EPS2)
                                          v_SignDeviation,              -- Да/нет
                                          v_RateKind,                   -- Наименование ставки используемой в дальнейшем
                                          v_RateVal                     -- Значение ставки
                                        ) = 0
             )then
             --Полученное значение v_SignDeviation записываем в категорию <Тест на рыночность пройден> для сделки
             if( v_SignDeviation = FALSE )then
               v_TestAttrID := 1;--Да
             end if;
           end if;
         end if;
       END IF;

       --Заносим значение в категорию
       RSB_SECUR.SetDealMarketTestAttrID(v_Tick.t_DealID, v_Tick.t_DealDate, v_TestAttrID);

       if( v_TestAttrID = 1 )then
         v_FairValueRub := v_Rq1AmountRub;
       elsif( v_TestAttrID = 2 )then

         IF p_FairValueRub != UnknownValue THEN
           v_FairValueRub := p_FairValueRub;

           v_DeltaRub := v_Rq1AmountRub - v_FairValueRub;
         ELSE
           v_FairValueRub := nvl(rsb_struct.getmoney(rsi_rsb_kernel.GetNote(RSB_SECUR.OBJTYPE_SECDEAL, LPAD(v_Tick.t_DealID, 34, '0'), 34, TO_DATE('31.12.9999','DD.MM.YYYY'))),0);
           -- если не задан курс СС на сделке, то рассчитаем
           IF v_FairValueRub = 0 THEN
             IF RSB_SECUR.SC_CalcFairValue( v_Tick.t_PFI, -- идентификатор ц/б
                                            v_Rq1.t_PlanDate, -- дата расчета
                                            case when v_IsSale != 0 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end, -- вид расчета (0 необязательный)
                                            v_Tick.t_DealID, -- id сделки (0 необязательный)
                                            0, -- id лота (0 необязательный)
                                            UnknownDate, -- Дата окончания периода расчета купона
                                            v_FairValueRub, -- рассчитанное значение СС
                                            v_Msg, -- сообщение
                                            v_RateID, -- курс, использованный для вычисления СС
                                            v_Cat55, -- значение для категории "Уровень исходных данных иерархии СС МСФО 13"
                                            v_Cat60, -- значение для категории "Наблюдаемые исходные данные"
                                            v_AlgUsed, -- примененный алгоритм
                                            v_RateVal, -- ставка (может быть изменена, если применен алгоритм ALG_DISCCOSTSTREAM)
                                            v_ACK -- -- Вид расчета АС (может быть изменен, если применен алгоритм ALG_DISCCOSTSTREAM)
                                          ) = 0 THEN

                v_FairValueRub := RSI_RSB_FIInstr.ConvSum(v_FairValueRub, v_Rq1.t_FIID, RSI_RSB_FIInstr.NATCUR, v_Rq1.t_PlanDate, 1);
                /*IF v_AlgUsed = RSB_SECUR.ALG_DISCCOSTSTREAM AND v_ACK = RSB_SECUR.AMORTCALCKIND_RPS THEN
                   v_EIR := v_RateVal;
                   v_AmortCost := v_FairValueRub;
                   v_AmortCalcKind := v_ACK;
                END IF;*/
             END IF;

             IF Length(v_Msg) > 0 THEN
                RSB_SECUR.AddWarningLogTmp(v_Tick.t_DealCode, 1, v_Msg);
             END IF;
           END IF;

           --Далее выполняем проверку на существенность отклонения фактической стоимости от СС
           if( RSB_SECUR.GetEssentialDev( RSB_SECUR.LEVELESSENTIAL_FACTPRICE, -- Вид уровня существенности = Отклонение фактической цены
                                          v_Portfolio,
                                          v_Rq1.t_PlanDate,
                                          v_Rq1AmountRub,
                                          v_FairValueRub,
                                          0,
                                          0,
                                          0,
                                          v_SignDeviation, -- Да/нет
                                          v_RateKind ,     -- Наименование ставки используемой в дальнейшем
                                          v_RateVal       -- Значение ставки
                                        ) = 0
             )then
             if( v_SignDeviation = True )then
               v_DeltaRub := v_Rq1AmountRub - v_FairValueRub;
             end if;
           end if;
         END IF;
       end if;

     end if;

     --Создать денежный лот РЕПО.
     v_CurrLot := NULL;

     v_CurrLot.T_SUMID            := 0;
     v_CurrLot.T_DOCKIND          := 29;--Платеж
     v_CurrLot.T_DOCID            := v_Rq1.t_ID;
     v_CurrLot.T_PARTNUM          := 0;
     v_CurrLot.T_PARTY            := UnknownParty;
     v_CurrLot.T_CONTRACT         := 0;
     v_CurrLot.T_FIID             := v_Rq1.t_FIID;--Валюта цены
     v_CurrLot.T_PORTFOLIO        := v_Portfolio;
     v_CurrLot.T_GROUPID          := -1;
     v_CurrLot.T_BUY_SALE         := case when v_IsSale = 1 then PM_WRITEOFF_SUM_BUY else PM_WRITEOFF_SUM_SALE end;
     v_CurrLot.T_KIND             := WRTSUM_KIND_RCURR;
     v_CurrLot.T_DATE             := v_Rq1.t_PlanDate;
     v_CurrLot.T_TIME             := UnknownTime;
     v_CurrLot.T_AMOUNT           := 0;
     v_CurrLot.T_AMOUNTBD         := 0;
     v_CurrLot.T_SUM              := v_Rq1.t_Amount;
     v_CurrLot.T_CURRENCY         := v_Rq1.t_FIID;
     v_CurrLot.T_COST             := 0;
     v_CurrLot.T_BALANCECOST      := 0;
     v_CurrLot.T_BALANCECOSTBD    := 0;
     v_CurrLot.T_NKDAMOUNT        := 0;
     v_CurrLot.T_BEGINTERESTDATE  := UnknownDate;
     v_CurrLot.T_INTERESTINCOME   := 0;
     v_CurrLot.T_NOTCARRYINTEREST := 0;
     v_CurrLot.T_INTERESTDATE     := UnknownDate;
     v_CurrLot.T_BEGDATE          := UnknownDate;
     v_CurrLot.T_BEGDISCOUNTDATE  := UnknownDate;
     v_CurrLot.T_BEGDISCOUNT      := 0;
     v_CurrLot.T_OLDBEGDISCOUNT   := 0;
     v_CurrLot.T_DISCOUNTCORR     := 0;
     v_CurrLot.T_BEGBONUSDATE     := UnknownDate;
     v_CurrLot.T_BEGBONUS         := 0;
     v_CurrLot.T_OLDBEGBONUS      := 0;
     v_CurrLot.T_RECALCDATE       := UnknownDate;
     v_CurrLot.T_DISCOUNTINCOME   := 0;
     v_CurrLot.T_NOTCARRYDISCOUNT := 0;
     v_CurrLot.T_DISCOUNTDATE     := UnknownDate;
     v_CurrLot.T_BONUS            := 0;
     v_CurrLot.T_BONUSDATE        := UnknownDate;
     v_CurrLot.T_OUTLAY           := GetComSumByDeal_Essential(v_Tick.t_BofficeKind, v_Tick.t_DealID, v_Rq1.t_PlanDate, -1, v_Portfolio, 0, v_Rq1AmountRub);
     v_CurrLot.T_RESERVAMOUNT     := 0;
     v_CurrLot.T_INCOMERESERV     := 0;
     v_CurrLot.T_RESERVDATE       := UnknownDate;
     v_CurrLot.T_OVERAMOUNT       := 0;
     v_CurrLot.T_OVERAMOUNTBD     := 0;
     v_CurrLot.T_OVERDATE         := UnknownDate;
     v_CurrLot.T_COUPON           := CHR(0);
     v_CurrLot.T_PARTLY           := CHR(0);
     v_CurrLot.T_DEPARTMENT       := v_Tick.t_Department;
     v_CurrLot.T_DEALID           := v_Tick.t_DealID;
     v_CurrLot.T_DEALDATE         := v_Tick.t_DealDate;
     v_CurrLot.T_DEALCODE         := v_Tick.t_DealCode;
     v_CurrLot.T_STATE            := PM_WRTSUM_NOTFORM;
     v_CurrLot.T_ENTERDATE        := UnknownDate;
     v_CurrLot.T_STATEDATE        := UnknownDate;
     v_CurrLot.T_INSTANCE         := 0;
     v_CurrLot.T_CHANGEDATE       := v_Rq1.t_PlanDate;
     v_CurrLot.T_ACTION           := PM_WRT_UPDTMODE_RCURR;
     v_CurrLot.T_ID_OPERATION     := p_ID_Operation;
     v_CurrLot.T_ID_STEP          := p_ID_Step;
     v_CurrLot.T_ISFREE           := CHR(88);
     v_CurrLot.T_TRUST            := CHR(0);
     v_CurrLot.T_PARENT           := 0;
     v_CurrLot.T_SOURCE           := 0;
     v_CurrLot.T_ISEDIT           := CHR(0);
     v_CurrLot.T_ACTIVATEDATE     := v_Rq1.t_PlanDate;
     v_CurrLot.T_ACTIVATETIME     := UnknownTime;
     v_CurrLot.T_BLOCKAMOUNT      := 0;
     v_CurrLot.T_CORRESTRESERVE   := 0;
     v_CurrLot.T_CORRESTRESERVEDATE:= UnknownDate;

     v_AttrObsBaseData := RSI_DealAttrObsBaseData(RSB_SECUR.OBJTYPE_SECDEAL,v_Tick.t_DealID);

     --Если категория на сделке <Наблюдаемые исходные данные> = нет
     if( v_AttrObsBaseData = 1 or v_AttrObsBaseData = -1)then
       v_CurrLot.T_BEGDEFDIFF := v_DeltaRub;
       v_CurrLot.T_BEGDEFDIFFDATE := v_Rq1.t_PlanDate;
     else
       v_CurrLot.T_BEGDEFDIFF := 0;
     end if;

     v_CurrLot.T_VATOUTLAY := GetComNDSByDeal_Essential(v_Tick.t_BofficeKind, v_Tick.t_DealID, v_Rq1.t_PlanDate, -1, v_Portfolio, 0, v_Rq1AmountRub);

     v_CurrLot.T_EFFECTINTERESTRATE := v_EIR;
     v_CurrLot.T_FAIRVALUE          := v_FairValueRub;

     --АС, определенная по методу v_AmortCalcKind в рублях
     v_CurrLot.T_AMORTCOST     := v_AMORTCOST;
     if( v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_EPS )then
       v_CurrLot.T_AMORTCOST   := RSB_SECUR.CalcAS_EPS0((case when v_IsSale = 1 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end), v_Tick.t_DealID, 0, v_CurrLot.T_DATE, v_CurrLot.T_FAIRVALUE); --в ВЦ для РЕПО
       v_CurrLot.T_AMORTCOST   := RSI_RSB_FIInstr.ConvSum(v_CurrLot.T_AMORTCOST, v_Rq1.t_FIID, RSI_RSB_FIInstr.NATCUR, v_CurrLot.T_DATE, 1);
     elsif v_AmortCalcKind = RSB_SECUR.AMORTCALCKIND_LM then
       v_CurrLot.T_AMORTCOST   := RSB_SECUR.CalcAS_Line((case when v_IsSale = 1 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end), v_Tick.t_DealID, 0, v_CurrLot.T_DATE); --в ВЦ для РЕПО
       v_CurrLot.T_AMORTCOST   := RSI_RSB_FIInstr.ConvSum(v_CurrLot.T_AMORTCOST, v_Rq1.t_FIID, RSI_RSB_FIInstr.NATCUR, v_CurrLot.T_DATE, 1);
     end if;
     v_CurrLot.T_AMORTCOSTDATE := v_Rq1.t_PlanDate;

     --Если категория на сделке <Наблюдаемые исходные данные> = да
     if( v_AttrObsBaseData = 0 )then
       v_CurrLot.T_CORRVALUE := v_DeltaRub;
     else
       v_CurrLot.T_CORRVALUE := 0;
     end if;

     v_CurrLot.T_CORRDATE := v_Rq1.t_PlanDate;
     v_CurrLot.T_AMORTCALCKIND := v_AmortCalcKind;

     RSI_InsDfltIntoWRTSUM(v_CurrLot);
     INSERT INTO DPMWRTSUM_DBT VALUES v_CurrLot;

   END;--RSI_WRTCreateCurrParmREPO

   PROCEDURE RSI_Mass_CreateCurrParmREPO IS
   BEGIN
     FOR UpdtDeal_rec IN (SELECT Deals.T_DealID, Deals.t_ID_Operation, Deals.t_ID_Step
                           FROM DV_MKDEAL_MASS_EXEC Deals
                        ) LOOP
       RSI_WRTCreateCurrParmREPO( UpdtDeal_rec.T_DealID, UpdtDeal_rec.t_ID_Operation, UpdtDeal_rec.t_ID_Step );
     END LOOP;
   END;

   --Выполняет начисление по сделке РЕПО на шаге операции начисления расходов/доходов
   PROCEDURE RSI_WRTCalcDealParmREPO( p_OperDate IN DATE,
                                      p_EndDate  IN DATE,
                                      p_DealID   IN NUMBER,
                                      p_SumPerc  IN NUMBER
                                    )
   AS
   BEGIN
     --Удалить все записи из DPMWRTSUM_TMP
     delete from DPMWRTSUM_TMP;

     RSI_WRTAccrueParmREPOTmp(0, p_SumPerc, p_EndDate, p_DealID, 0);

   END RSI_WRTCalcDealParmREPO;

   --Выполняет отражение начисления в денежных параметрах РЕПО в операции начисления доходов/расходов
   PROCEDURE RSI_WRTSetDealParmREPO( p_OperDate     IN DATE,
                                     p_EndDate      IN DATE,
                                     p_DealID       IN NUMBER,
                                     p_ID_Operation IN NUMBER,
                                     p_ID_Step      IN NUMBER
                                   )
   AS
     v_LotTMP DPMWRTSUM_TMP%ROWTYPE;
   BEGIN

     InitError();

     BEGIN
       select * into v_LotTMP
         from DPMWRTSUM_TMP;
     EXCEPTION WHEN OTHERS THEN
       SetError( WRTOFF_ERROR_20254 );--<Неверные данные>
     END;

     RSI_WRTSaveLot(v_LotTMP.T_SUMID, p_ID_Operation, p_ID_Step, p_EndDate, PM_WRT_UPDTMODE_RCURR_PROFIT);

     UPDATE DPMWRTSUM_DBT LOT
        SET LOT.T_ACCOUNTEDDEFDIFF = v_LotTMP.T_ACCOUNTEDDEFDIFF,
            LOT.T_DEFDIFFDATE      = p_EndDate,
            LOT.T_WRTOUTLAY        = v_LotTMP.T_WRTOUTLAY,
            LOT.T_WRTOUTLAYDATE    = p_EndDate,
            LOT.T_CORRINTTOEIR     = v_LotTMP.T_CORRINTTOEIR,
            LOT.T_CORRINTTOEIRDATE = p_EndDate,
            LOT.T_EFFECTINTERESTRATE = (case when v_LotTMP.T_EFFECTINTERESTRATE NOT IN (-1.0, 0.0) then v_LotTMP.T_EFFECTINTERESTRATE else LOT.T_EFFECTINTERESTRATE end)
      WHERE LOT.T_SUMID = v_LotTMP.T_SUMID;

   END RSI_WRTSetDealParmREPO;

   --Выполняет начисление по сделки РЕПО во временную таблицу при выполнении СОБУ
   PROCEDURE RSI_WRTAccrueParmREPOTmp( p_IsWrt    IN NUMBER,
                                       p_SumPerc  IN NUMBER,
                                       p_EndDate  IN DATE,
                                       p_DealID   IN NUMBER,
                                       p_GrDealID IN NUMBER DEFAULT 0
                                     )
   AS
     v_Lot DPMWRTSUM_DBT%ROWTYPE;
     v_LotTMP DPMWRTSUM_TMP%ROWTYPE;

     v_NewAccountedDefDiff NUMBER := 0;
     v_AddDefDiff NUMBER := 0;
     v_CorrIntToEIR NUMBER := 0;
     v_NewWrtOutlay NUMBER := 0;
     v_AddWrtOutlay NUMBER := 0;

     v_LotTMP_NRec NUMBER := 0;
     v_RQ2_PlanDate DATE := UnknownDate;
     v_IsSale NUMBER := 0;
     v_PrevSumPerc NUMBER := 0;
   BEGIN

     InitError();

     BEGIN
       select LOT.* into v_Lot
         from DPMWRTSUM_DBT LOT, DDL_TICK_DBT TK, DDLRQ_DBT RQ1
        where TK.T_DEALID = p_DealID
          and TK.T_BOFFICEKIND = Rsb_Secur.DL_SECURITYDOC
          and RQ1.T_DOCKIND = TK.T_BOFFICEKIND
          and RQ1.T_DOCID = TK.T_DEALID
          and RQ1.T_TYPE = RSI_DLRQ.DLRQ_TYPE_PAYMENT
          and RQ1.T_DEALPART = 1
          and LOT.T_DOCKIND = 29 --DLDOC_PAYMENT
          and LOT.T_DOCID = RQ1.T_ID
          and LOT.T_KIND = WRTSUM_KIND_RCURR;
     EXCEPTION WHEN NO_DATA_FOUND THEN
       SetError( WRTOFF_ERROR_20260 );--<Не найдены денежные параметры РЕПО>
     END;

     select RQ2.T_PLANDATE,
            RSB_SECUR.IsSale(RSB_SECUR.get_OperationGroup(RSB_SECUR.get_OperSysTypes(TK.t_DealType, TK.t_BofficeKind))) into v_RQ2_PlanDate, v_IsSale
       from DDL_TICK_DBT TK, DDLRQ_DBT RQ2
      where TK.T_DEALID = p_DealID
        and TK.T_BOFFICEKIND = Rsb_Secur.DL_SECURITYDOC
        and RQ2.T_DOCKIND = TK.T_BOFFICEKIND
        and RQ2.T_DOCID = TK.T_DEALID
        and RQ2.T_TYPE = RSI_DLRQ.DLRQ_TYPE_PAYMENT
        and RQ2.T_DEALPART = 2;

     if( v_Lot.T_CORRINTTOEIRDATE > p_EndDate or v_Lot.T_DEFDIFFDATE > p_EndDate )then
       SetError( WRTOFF_ERROR_20249 );--Выполнено начисление за более позднюю дату
     end if;

     select count(1) into v_LotTMP_NRec
       from DPMWRTSUM_TMP
     where T_SUMID = v_Lot.T_SumID;

     IF( v_LotTMP_NRec > 0 )THEN
       --Если найдена, то никаких действий не выполнять. При обычном начислении такого быть не должно, а при начислении в СОБУ повторное начисление делать не следует
       RETURN;
     END IF;

     IF( v_Lot.T_BEGDEFDIFF != 0 )THEN
        if( p_IsWrt != 0 )then
           v_NewAccountedDefDiff := v_Lot.T_BEGDEFDIFF;
        else
           v_NewAccountedDefDiff := ROUND(v_Lot.T_BEGDEFDIFF * (p_EndDate - v_Lot.T_BEGDEFDIFFDATE)/(v_RQ2_PlanDate - v_Lot.T_BEGDEFDIFFDATE), 2);
        end if;
        v_AddDefDiff := v_NewAccountedDefDiff - v_Lot.T_ACCOUNTEDDEFDIFF;
     END IF;

     IF( v_Lot.T_OUTLAY > 0 )THEN
        if( p_IsWrt != 0 )then
           --выполняем списание всего остатка затрат
           v_NewWrtOutlay := v_Lot.T_OUTLAY;
        else
           --Иначе списываем пропорционально периоду
           v_NewWrtOutlay := ROUND(v_Lot.T_OUTLAY * (p_EndDate - v_Lot.T_DATE)/(v_RQ2_PlanDate - v_Lot.T_DATE), 2);
        end if;
        v_AddWrtOutlay := v_NewWrtOutlay - v_Lot.T_WRTOUTLAY;
     END IF;

     IF( v_Lot.T_AMORTCALCKIND = RSB_SECUR.AMORTCALCKIND_EPS )THEN

        BEGIN
          SELECT s.t_Sum INTO v_PrevSumPerc
            FROM ddlsum_dbt s
           WHERE s.t_DocKind = RSB_SECUR.DL_SECURITYDOC
             AND s.t_DocID = p_DealID
             AND s.t_Kind = RSB_SECUR.DLSUM_SUM_TO_PERCENT_CFI
             AND s.T_DATE = (SELECT MAX (T_DATE)
                               FROM ddlsum_dbt
                              WHERE t_DocKind = s.t_DocKind
                                AND t_DocID = s.t_DocID
                                AND t_Kind = RSB_SECUR.DLSUM_SUM_TO_PERCENT_CFI 
                                AND T_DATE <= p_EndDate)
             AND ROWNUM = 1;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN v_PrevSumPerc := 0;
        END;

        v_LotTMP.T_EFFECTINTERESTRATE := RSB_SECUR.CalcEPS(case when v_IsSale != 0 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end, p_DealID, 0/*v_Lot.t_SumID*/, p_EndDate);

        v_CorrIntToEIR := RSB_SECUR.CalcCorrectPersentEPS(case when v_IsSale != 0 then RSB_SECUR.CALCKIND_PREPO else RSB_SECUR.CALCKIND_OREPO end,
                                                          p_DealID,
                                                          0/*v_Lot.t_SumID*/,
                                                          p_EndDate,
                                                          UnknownDate,
                                                          RSI_RSB_FIInstr.ConvSum((p_SumPerc + v_PrevSumPerc), RSI_RSB_FIInstr.NATCUR, v_Lot.T_CURRENCY, v_Lot.t_Date, 1 ), --в ВЦ для РЕПО
                                                          0,
                                                          0,
                                                          RSI_RSB_FIInstr.ConvSum(v_Lot.T_WRTOUTLAY, RSI_RSB_FIInstr.NATCUR, v_Lot.T_CURRENCY, v_Lot.t_Date, 1 ), --в ВЦ для РЕПО
                                                          RSI_RSB_FIInstr.ConvSum(v_Lot.T_FAIRVALUE, RSI_RSB_FIInstr.NATCUR, v_Lot.T_CURRENCY, v_Lot.t_Date, 1 ), --в ВЦ для РЕПО
                                                          v_LotTMP.T_EFFECTINTERESTRATE
                                                         );

        IF v_CorrIntToEIR IS NULL THEN
          v_CorrIntToEIR := 0;
        ELSE
          v_CorrIntToEIR := RSI_RSB_FIInstr.ConvSum(v_CorrIntToEIR, v_Lot.T_CURRENCY, RSI_RSB_FIInstr.NATCUR, v_Lot.t_Date, 1 );
          v_CorrIntToEIR := ROUND(v_CorrIntToEIR, 2);
        END IF;
     END IF;

     v_LotTMP.T_SUMID            := v_LOT.T_SUMID;
     v_LotTMP.T_DEFDIFFADD       := v_AddDefDiff;
     v_LotTMP.T_ACCOUNTEDDEFDIFF := v_NewAccountedDefDiff;
     v_LotTMP.T_WRTOUTLAYADD     := v_AddWrtOutlay;
     v_LotTMP.T_WRTOUTLAY        := v_NewWrtOutlay;
     v_LotTMP.T_CORRINTTOEIR     := v_CorrIntToEIR;
     v_LotTMP.T_GRDEALID         := p_GrDealID;

     IF( p_IsWrt != 0 )THEN
        v_LotTMP.T_WRTCORRINTTOEIR  := v_LotTMP.T_CORRINTTOEIR;
        v_LotTMP.T_RESERVAMOUNTADD := -v_LOT.T_RESERVAMOUNT;
        v_LotTMP.T_RESERVDATE := p_EndDate;
        v_LotTMP.T_CORRESTRESERVEADD := -v_LOT.T_CORRESTRESERVE;
        v_LotTMP.T_CORRESTRESERVEDATE := p_EndDate;
        v_LotTMP.T_CORRVALUE := 0;
        v_LotTMP.T_CORRDATE := p_EndDate;
     ELSE
        v_LotTMP.T_WRTCORRINTTOEIR  := 0;
        v_LotTMP.T_RESERVAMOUNTADD := 0;
        v_LotTMP.T_RESERVDATE := v_LOT.T_RESERVDATE;
        v_LotTMP.T_CORRESTRESERVEADD := 0;
        v_LotTMP.T_CORRESTRESERVEDATE := v_LOT.T_CORRESTRESERVEDATE;
        v_LotTMP.T_CORRVALUE := v_LOT.T_CORRVALUE;
        v_LotTMP.T_CORRDATE := v_LOT.T_CORRDATE;
     END IF;

     RSI_InsDfltIntoWRTSUM_TMP(v_LotTMP);

     INSERT INTO DPMWRTSUM_TMP VALUES v_LotTMP;

   END RSI_WRTAccrueParmREPOTmp;

   --Выполняет откат начисления в денежных параметрах РЕПО в СОБУ
   PROCEDURE RSI_WRTRestoreParmREPOAcc( p_DocumentID IN NUMBER,
                                        p_GrpID      IN NUMBER
                                      )
   AS
   BEGIN
     FOR one_select IN (SELECT DOC.T_DOCID
                          FROM DDLGRDOC_DBT DOC
                         WHERE DOC.T_DOCKIND = RSB_SECUR.DL_PMWRTSUM
                           AND DOC.T_SERVDOCKIND = RSB_SECUR.DL_SCACCOUNTING
                           AND DOC.T_SERVDOCID = p_DocumentID
                           AND DOC.T_GRPID = p_GrpID
                       )
     LOOP
       RSI_WRTRestoreLot(p_DocumentID, -1, PM_WRT_UPDTMODE_RCURR_PROFIT, one_select.T_DOCID);
     END LOOP;

     DELETE FROM DDLGRDOC_DBT WHERE T_DOCKIND = RSB_SECUR.DL_PMWRTSUM AND T_SERVDOCKIND = RSB_SECUR.DL_SCACCOUNTING AND T_SERVDOCID = p_DocumentID AND T_GRPID = p_GrpID;

   END RSI_WRTRestoreParmREPOAcc;

   --Выполняет отражение начисления в денежных параметрах РЕПО в СОБУ
   PROCEDURE RSI_WRTSaveParmREPOAcc( p_OperDate     IN DATE,
                                     p_GrpID        IN NUMBER,
                                     p_ID_Operation IN NUMBER,
                                     p_ID_Step      IN NUMBER
                                   )
   AS
     CURSOR cLot IS
         SELECT * FROM DPMWRTSUM_TMP;
   BEGIN
     InitError();

     FOR v_TMP IN cLot
     LOOP
       RSI_WRTSaveLot(v_TMP.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_RCURR_PROFIT);

       UPDATE DPMWRTSUM_DBT LOT
          SET LOT.T_ACCOUNTEDDEFDIFF   = v_TMP.T_ACCOUNTEDDEFDIFF,
              LOT.T_DEFDIFFDATE        = p_OperDate,
              LOT.T_WRTOUTLAY          = v_TMP.T_WRTOUTLAY,
              LOT.T_WRTOUTLAYDATE      = p_OperDate,
              LOT.T_CORRINTTOEIR       = v_TMP.T_CORRINTTOEIR - v_TMP.T_WRTCORRINTTOEIR,
              LOT.T_CORRINTTOEIRDATE   = p_OperDate,
              LOT.T_RESERVAMOUNT       = LOT.T_RESERVAMOUNT + v_TMP.T_RESERVAMOUNTADD,
              LOT.T_RESERVDATE         = v_TMP.T_RESERVDATE,
              LOT.T_CORRESTRESERVE     = LOT.T_CORRESTRESERVE + v_TMP.T_CORRESTRESERVEADD,
              LOT.T_CORRESTRESERVEDATE = v_TMP.T_CORRESTRESERVEDATE,
              LOT.T_CORRVALUE          = v_TMP.T_CORRVALUE,
              LOT.T_CORRDATE           = v_TMP.T_CORRDATE,
              LOT.T_EFFECTINTERESTRATE = (case when v_TMP.T_EFFECTINTERESTRATE NOT IN (-1.0, 0.0) then v_TMP.T_EFFECTINTERESTRATE else LOT.T_EFFECTINTERESTRATE end)
        WHERE LOT.T_SUMID = v_TMP.T_SUMID;

       INSERT INTO DDLGRDOC_DBT (T_ID, T_GRDEALID, T_DOCKIND, T_DOCID, T_SERVDOCKIND, T_SERVDOCID, T_GRPID, T_SOURCETYPE)
                         VALUES (0, v_TMP.T_GRDEALID, RSB_SECUR.DL_PMWRTSUM, v_TMP.T_SUMID, RSB_SECUR.DL_SCACCOUNTING, p_ID_Operation, p_GrpID, 0);
     END LOOP;

   END RSI_WRTSaveParmREPOAcc;

   --Выполнить наполнение таблицы данных для скроллинга лотов на дату
   PROCEDURE RSI_WRTFillTmpByFIID( p_FIID IN NUMBER,
                                   p_Date IN DATE
                                 )
   AS
   BEGIN
      INSERT INTO DPMWRTSUMHIST_TMP(
                                    T_SUMID,             
                                    T_DOCKIND,           
                                    T_DOCID,             
                                    T_PARTNUM,           
                                    T_PARTY,             
                                    T_CONTRACT,          
                                    T_PORTFOLIO,         
                                    T_FIID,              
                                    T_GROUPID,           
                                    T_BUY_SALE,          
                                    T_KIND,              
                                    T_DATE,              
                                    T_TIME,              
                                    T_AMOUNT,            
                                    T_AMOUNTBD,          
                                    T_SUM,               
                                    T_CURRENCY,          
                                    T_COST,              
                                    T_BALANCECOST,       
                                    T_BALANCECOSTBD,     
                                    T_NKDAMOUNT,         
                                    T_INTERESTINCOME,    
                                    T_NOTCARRYINTEREST,  
                                    T_INTERESTDATE,      
                                    T_BEGDATE,           
                                    T_BEGDISCOUNT,       
                                    T_OLDBEGDATE,        
                                    T_OLDBEGDISCOUNT,    
                                    T_BEGBONUSDATE,      
                                    T_BEGBONUS,          
                                    T_DISCOUNTINCOME,    
                                    T_NOTCARRYDISCOUNT,  
                                    T_DISCOUNTDATE,      
                                    T_BONUS,             
                                    T_BONUSDATE,         
                                    T_OUTLAY,            
                                    T_RESERVAMOUNT,      
                                    T_RESERVDATE,        
                                    T_OVERAMOUNT,        
                                    T_OVERAMOUNTBD,      
                                    T_OVERDATE,          
                                    T_COUPON,            
                                    T_PARTLY,            
                                    T_DEPARTMENT,        
                                    T_DEALID,            
                                    T_DEALDATE,          
                                    T_DEALCODE,          
                                    T_STATE,             
                                    T_ENTERDATE,         
                                    T_STATEDATE,         
                                    T_INSTANCE,          
                                    T_CHANGEDATE,        
                                    T_ACTION,            
                                    T_ID_OPERATION,      
                                    T_ID_STEP,           
                                    T_TRUST,             
                                    T_PARENT,            
                                    T_SOURCE,            
                                    T_INCOMERESERV,      
                                    T_BEGINTERESTDATE,   
                                    T_BEGDISCOUNTDATE,   
                                    T_DISCOUNTCORR,      
                                    T_OLDBEGBONUS,       
                                    T_RECALCDATE,        
                                    T_ISEDIT,            
                                    T_OLDBONUS,          
                                    T_NOTWRTBONUS,       
                                    T_COSTPFI,           
                                    T_SORTCODE,          
                                    T_BEGDEFDIFF,        
                                    T_ACCOUNTEDDEFDIFF,  
                                    T_DEFDIFFDATE,       
                                    T_WRTOUTLAY,         
                                    T_WRTOUTLAYDATE,     
                                    T_WRTVATOUTLAY,      
                                    T_EFFECTINTERESTRATE,
                                    T_FAIRVALUE,         
                                    T_AMORTCOST,         
                                    T_AMORTCOSTDATE,     
                                    T_CORRVALUE,         
                                    T_CORRDATE,          
                                    T_AMORTCALCKIND,     
                                    T_ESTRESERVE,        
                                    T_ESTRESERVEDATE,    
                                    T_CORRINTTOEIR,      
                                    T_CORRINTTOEIRDATE,  
                                    T_CORRESTRESERVE,    
                                    T_CORRESTRESERVEDATE,
                                    T_HEDGCORR,      
                                    T_HEDGCORRDATE,
                                    T_AMORTHEDGCORR,      
                                    T_AMORTHEDGCORRDATE)
                             SELECT s.T_SUMID,             
                                    s.T_DOCKIND,           
                                    s.T_DOCID,             
                                    s.T_PARTNUM,           
                                    s.T_PARTY,             
                                    s.T_CONTRACT,          
                                    s.T_PORTFOLIO,         
                                    s.T_FIID,              
                                    s.T_GROUPID,           
                                    s.T_BUY_SALE,          
                                    s.T_KIND,              
                                    s.T_DATE,              
                                    s.T_TIME,              
                                    s.T_AMOUNT,            
                                    s.T_AMOUNTBD,          
                                    s.T_SUM,               
                                    s.T_CURRENCY,          
                                    s.T_COST,              
                                    s.T_BALANCECOST,       
                                    s.T_BALANCECOSTBD,     
                                    s.T_NKDAMOUNT,         
                                    s.T_INTERESTINCOME,    
                                    s.T_NOTCARRYINTEREST,  
                                    s.T_INTERESTDATE,      
                                    s.T_BEGDATE,           
                                    s.T_BEGDISCOUNT,       
                                    s.T_OLDBEGDATE,        
                                    s.T_OLDBEGDISCOUNT,    
                                    s.T_BEGBONUSDATE,      
                                    s.T_BEGBONUS,          
                                    s.T_DISCOUNTINCOME,    
                                    s.T_NOTCARRYDISCOUNT,  
                                    s.T_DISCOUNTDATE,      
                                    s.T_BONUS,             
                                    s.T_BONUSDATE,         
                                    s.T_OUTLAY,            
                                    s.T_RESERVAMOUNT,      
                                    s.T_RESERVDATE,        
                                    s.T_OVERAMOUNT,        
                                    s.T_OVERAMOUNTBD,      
                                    s.T_OVERDATE,          
                                    s.T_COUPON,            
                                    s.T_PARTLY,            
                                    s.T_DEPARTMENT,        
                                    s.T_DEALID,            
                                    s.T_DEALDATE,          
                                    s.T_DEALCODE,          
                                    s.T_STATE,             
                                    s.T_ENTERDATE,         
                                    s.T_STATEDATE,         
                                    s.T_INSTANCE,          
                                    s.T_CHANGEDATE,        
                                    s.T_ACTION,            
                                    s.T_ID_OPERATION,      
                                    s.T_ID_STEP,           
                                    s.T_TRUST,             
                                    s.T_PARENT,            
                                    s.T_SOURCE,            
                                    s.T_INCOMERESERV,      
                                    s.T_BEGINTERESTDATE,   
                                    s.T_BEGDISCOUNTDATE,   
                                    s.T_DISCOUNTCORR,      
                                    s.T_OLDBEGBONUS,       
                                    s.T_RECALCDATE,        
                                    s.T_ISEDIT,            
                                    s.T_OLDBONUS,          
                                    s.T_NOTWRTBONUS,       
                                    s.T_COSTPFI,           
                                    s.T_SORTCODE,          
                                    s.T_BEGDEFDIFF,        
                                    s.T_ACCOUNTEDDEFDIFF,  
                                    s.T_DEFDIFFDATE,       
                                    s.T_WRTOUTLAY,         
                                    s.T_WRTOUTLAYDATE,     
                                    s.T_WRTVATOUTLAY,      
                                    s.T_EFFECTINTERESTRATE,
                                    s.T_FAIRVALUE,         
                                    s.T_AMORTCOST,         
                                    s.T_AMORTCOSTDATE,     
                                    s.T_CORRVALUE,         
                                    s.T_CORRDATE,          
                                    s.T_AMORTCALCKIND,     
                                    s.T_ESTRESERVE,        
                                    s.T_ESTRESERVEDATE,    
                                    s.T_CORRINTTOEIR,      
                                    s.T_CORRINTTOEIRDATE,  
                                    s.T_CORRESTRESERVE,    
                                    s.T_CORRESTRESERVEDATE,
                                    s.T_HEDGCORR,      
                                    s.T_HEDGCORRDATE,
                                    s.T_AMORTHEDGCORR,      
                                    s.T_AMORTHEDGCORRDATE
                             FROM v_scwrthistex s, dpmwrtsum_dbt lot
                            where lot.t_sumID = s.t_sumID 
                              and lot.t_Party = -1 
                              and lot.t_FIID = p_FIID
                              and s.t_instance = (SELECT MAX (s2.t_instance)
                                                    FROM v_scwrthistex s2
                                                   WHERE s2.t_sumid = s.t_sumid 
                                                     AND s2.t_changedate <= p_Date);

   END RSI_WRTFillTmpByFIID;

   -- Получить идентификатор сделки по лоту
   FUNCTION GetDealByLot(p_SumID IN NUMBER) RETURN NUMBER
   AS
      pmwrtsum DPMWRTSUM_DBT%ROWTYPE;
   BEGIN
      SELECT * INTO pmwrtsum FROM DPMWRTSUM_DBT WHERE t_SumID = p_SumID;
            
      IF( pmwrtsum.t_DocKind <> RSB_SECUR.DLDOC_PAYMENT ) THEN
         RETURN -1;
      ELSE
         RETURN pmwrtsum.t_DealID;
      END IF;
            
      RETURN -1;
      
   END GetDealByLot;

  -- Процедура расчета сумм доначисления комиссий по собственным облигациям во временную таблицу
  PROCEDURE RSI_СalcOwnFiComTMP(p_FIID IN NUMBER, p_OperDate IN DATE, p_CalcDate IN DATE, p_FullWrt IN NUMBER )
  IS
    v_OFFERDATE      DATE;
    v_DRAWINGDATE    DATE;
    v_FINDRAWINGDATE DATE; 
    v_LastBuyDate    DATE;

    v_SumComisRub NUMBER := 0;
    v_SumNDSRub   NUMBER := 0;
    v_StartAmortDate DATE; 

    v_NEWCOMSUM NUMBER := 0;
    v_NEWNDSSUM NUMBER := 0;
    v_ADDCOMM   NUMBER := 0;
    v_ADDNDS    NUMBER := 0;

    v_LastDayMonth DATE := LAST_DAY(p_CalcDate);
    v_LastWorkDayMonth  DATE;

    v_MonthAmortSum   NUMBER := 0;
    v_CommAddNDSAmort NUMBER := 0;
    v_CommAddAmort    NUMBER := 0;

  BEGIN

     DELETE FROM DDLSUM_TMP;

     SELECT T_DRAWINGDATE INTO v_FINDRAWINGDATE FROM DFININSTR_DBT WHERE T_FIID = p_FIID;

     --Определить дату последнего выкупа
     SELECT NVL(MAX(DLS.T_DATE), UnknownDate)
       INTO v_LastBuyDate
       FROM DDLSUM_DBT DLS
      WHERE DLS.T_KIND = RSB_SECUR.DLSUM_KIND_OWNAVR_DEALAMORTCOM
        AND DLS.T_DOCKIND = RSB_SECUR.DL_SECUROWN
        AND DLS.T_FIID = p_FIID;

     IF v_LastBuyDate = UnknownDate OR v_LastBuyDate <= p_CalcDate THEN

       --сначала рассчитываем комиссии без ежемесячной амортизации
       FOR one_cm IN (SELECT DLC.T_ID, DLC.T_STARTAMORTDATE,
                             NVL(RSB_FIINSTR.CONVSUM(DLC.T_SUM-DLC.T_NDS, CM.T_FIID_COMM, RSI_RSB_FIINSTR.NATCUR, DLC.T_PLANPAYDATE), 0) AS SUMCOMISRUB,  
                             NVL(RSB_FIINSTR.CONVSUM(DLC.T_NDS, CM.T_FIID_COMM, RSI_RSB_FIINSTR.NATCUR, DLC.T_PLANPAYDATE), 0) AS SUMNDSRUB,  
                             NVL((SELECT SUM(S.T_SUM) 
                                    FROM DDLSUM_DBT S 
                                   WHERE S.T_DOCKIND = RSB_SECUR.DL_SECURITYCOM
                                     AND S.T_DOCID = DLC.T_ID
                                     AND S.T_DATE > v_LastBuyDate 
                                 ), 0) AS PREVCOMSUMRUB,
                             NVL((SELECT SUM(S.T_NDS) 
                                    FROM DDLSUM_DBT S 
                                   WHERE S.T_DOCKIND = RSB_SECUR.DL_SECURITYCOM
                                     AND S.T_DOCID = DLC.T_ID 
                                     AND S.T_DATE > v_LastBuyDate
                                 ), 0) AS PREVNDSSUMRUB,
                             NVL((SELECT SUM(S.T_SUM) 
                                    FROM DDLSUM_DBT S 
                                   WHERE S.T_DOCKIND = RSB_SECUR.DL_SECURITYCOM
                                     AND S.T_DOCID = DLC.T_ID
                                     AND S.T_DATE <= v_LastBuyDate 
                                 ), 0) AS EXCLUDECOMSUMRUB,
                             NVL((SELECT SUM(S.T_NDS) 
                                    FROM DDLSUM_DBT S 
                                   WHERE S.T_DOCKIND = RSB_SECUR.DL_SECURITYCOM
                                     AND S.T_DOCID = DLC.T_ID
                                     AND S.T_DATE <= v_LastBuyDate 
                                 ), 0) AS EXCLUDENDSSUMRUB
                        FROM DDLCOMIS_DBT DLC, DSFCOMISS_DBT CM 
                       WHERE DLC.T_DOCKIND = RSB_SECUR.DLDOC_ISSUE
                         AND DLC.T_DOCID = p_FIID
                         AND DLC.T_MONTHAMORTSUM = 0 
                         AND DLC.T_STARTAMORTDATE <= p_CalcDate
                         AND DLC.T_STARTAMORTDATE <> UnknownDate
                         AND CM.T_FEETYPE = DLC.T_FEETYPE 
                         AND CM.T_NUMBER = DLC.T_COMNUMBER)
       LOOP
         v_DRAWINGDATE := v_FINDRAWINGDATE;
         
         IF CALC_AMORTOWN_BEFOREOFFER = CALC_AMORTOWN_BEFOREOFFER_YES THEN
           v_OFFERDATE := RSI_RSB_FIInstr.FI_GetOfferDate(p_FIID, one_cm.T_STARTAMORTDATE);
           IF v_OFFERDATE <> UnknownDate then
             v_DRAWINGDATE := v_OFFERDATE;
           END IF;
         END IF;

         --Из исходной суммы комиссии исключим всю самортизированную сумму до даты последнего выкупа
         v_SumComisRub := one_cm.SUMCOMISRUB - one_cm.EXCLUDECOMSUMRUB;
         v_SumNDSRub   := one_cm.SUMNDSRUB - one_cm.EXCLUDENDSSUMRUB;
        
         v_StartAmortDate := one_cm.T_STARTAMORTDATE;
         IF v_StartAmortDate < v_LastBuyDate THEN
           --Амортизировать продолжаем с даты последнего выкупа
           v_StartAmortDate := v_LastBuyDate;
         END IF;

         v_NEWCOMSUM := 0;
         v_NEWNDSSUM := 0;
         IF p_FullWrt <> 0 THEN
           v_NEWCOMSUM := v_SumComisRub;
           v_NEWNDSSUM := v_SumNDSRub;
         ELSE
           IF v_DRAWINGDATE > v_StartAmortDate THEN
             v_NEWCOMSUM := ROUND((v_SumComisRub * (p_CalcDate - v_StartAmortDate) / (v_DRAWINGDATE - v_StartAmortDate)), 2);
             v_NEWNDSSUM := ROUND((v_SumNDSRub * (p_CalcDate - v_StartAmortDate) / (v_DRAWINGDATE - v_StartAmortDate)), 2);
           END IF;
         END IF;

         v_ADDCOMM := v_NEWCOMSUM - one_cm.PREVCOMSUMRUB;
         v_ADDNDS  := v_NEWNDSSUM - one_cm.PREVNDSSUMRUB;

         IF v_ADDCOMM > 0 OR v_ADDNDS > 0 THEN

           INSERT INTO DDLSUM_TMP(T_ID,
                                  T_DOCKIND,
                                  T_DOCID,
                                  T_KIND,
                                  T_DATE,
                                  T_SUM,
                                  T_NDS,
                                  T_CURRENCY,
                                  T_IMMATERIAL,
                                  T_INSTANCE,
                                  T_GRPID,
                                  T_MARKETID,
                                  T_FIID)
                       VALUES(0,
                              RSB_SECUR.DL_SECURITYCOM,
                              one_cm.t_ID,
                              RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM,
                              p_CalcDate,
                              v_ADDCOMM,
                              v_ADDNDS,
                              RSI_RSB_FIINSTR.NATCUR,
                              CHR(0),
                              0,
                              0,
                              0,
                              p_FIID
                             );
         END IF;                                                   
       END LOOP;
     END IF;
     
     --если начисление в последний рабочий день месяца и есть комиссии с фиксированной ежемесячной амортизацией
     v_LastWorkDayMonth := RSI_RsbCalendar.GetDateAfterWorkDay(v_LastDayMonth+1, -1);
     
     FOR one_cm IN ( SELECT RSB_FIINSTR.CONVSUM(DLC.T_SUM, CM.T_FIID_COMM, RSI_RSB_FIINSTR.NATCUR, DLC.T_PLANPAYDATE) AS COMISRUB,  
                            RSB_FIINSTR.CONVSUM(DLC.T_NDS, CM.T_FIID_COMM, RSI_RSB_FIINSTR.NATCUR, DLC.T_PLANPAYDATE) AS NDSRUB, 
                            RSB_FIINSTR.CONVSUM(DLC.T_MONTHAMORTSUM, CM.T_FIID_COMM, RSI_RSB_FIINSTR.NATCUR, DLC.T_PLANPAYDATE) AS MONTHAMORTSUMRUB, 
                            DLC.T_ID, 
                            NVL((SELECT SUM(S.T_SUM) FROM DDLSUM_DBT S WHERE S.T_DOCKIND = RSB_SECUR.DL_SECURITYCOM AND S.T_DOCID = DLC.T_ID AND S.T_KIND = RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM
                                ), 0) PREVAMORTCOMSUM, 
                            NVL((SELECT SUM(S.T_NDS) FROM DDLSUM_DBT S WHERE S.T_DOCKIND = RSB_SECUR.DL_SECURITYCOM AND S.T_DOCID = DLC.T_ID AND S.T_KIND = RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM
                                ), 0) PREVAMORTNDSSUM 
                       FROM DDLCOMIS_DBT DLC, DSFCOMISS_DBT CM 
                      WHERE DLC.T_DOCKIND = RSB_SECUR.DLDOC_ISSUE
                        AND DLC.T_DOCID = p_FIID
                        AND DLC.T_STARTAMORTDATE <= p_CalcDate
                        AND DLC.T_STARTAMORTDATE <> UnknownDate
                        AND DLC.T_MONTHAMORTSUM > 0 
                        AND CM.T_FEETYPE = DLC.T_FEETYPE 
                        AND CM.T_NUMBER = DLC.T_COMNUMBER)
     LOOP

       IF p_FullWrt <> 0 OR p_CalcDate = v_LastWorkDayMonth THEN

         v_MonthAmortSum := one_cm.MonthAmortSumRub;

         IF (p_FullWrt <> 0) OR ((one_cm.PrevAmortComSum + one_cm.PrevAmortNDSSum + v_MonthAmortSum) > one_cm.ComisRub) THEN
           v_MonthAmortSum := one_cm.ComisRub - one_cm.PrevAmortComSum - one_cm.PrevAmortNDSSum;
         END IF;

         v_CommAddNDSAmort := ROUND((v_MonthAmortSum * one_cm.NDSRub / one_cm.ComisRub), 2);
         v_CommAddAmort    := v_MonthAmortSum - v_CommAddNDSAmort;

         INSERT INTO DDLSUM_TMP(T_ID,
                              T_DOCKIND,
                              T_DOCID,
                              T_KIND,
                              T_DATE,
                              T_SUM,
                              T_NDS,
                              T_CURRENCY,
                              T_IMMATERIAL,
                              T_INSTANCE,
                              T_GRPID,
                              T_MARKETID,
                              T_FIID)
                   VALUES(0,
                          RSB_SECUR.DL_SECURITYCOM,
                          one_cm.t_ID,
                          RSB_SECUR.DLSUM_KIND_OWNAVR_AMORTCOM,
                          p_CalcDate,
                          v_CommAddAmort,
                          v_CommAddNDSAmort,
                          RSI_RSB_FIINSTR.NATCUR,
                          CHR(0),
                          0,
                          0,
                          0,
                          p_FIID
                         );

       END IF;

     END LOOP;

  END; -- RSI_СalcOwnFiComTMP

  PROCEDURE RSI_AddHedgCorrToLotsTMP(p_OperDate IN DATE,
                                     p_FIID IN NUMBER,
                                     p_Department IN NUMBER,
                                     p_AddHedgCorr IN NUMBER,
                                     p_CorrCurrency IN NUMBER
                                    )
  AS
    v_SumHedgCorrNat      NUMBER := 0;
    v_RestAmount          NUMBER := 0;
    v_SumAmount           NUMBER := 0;
    v_RestSumHedgCorrNat  NUMBER := 0;
    v_LotHedgCorrNat      NUMBER := 0;

    v_LotBalanceCost      NUMBER := 0;

    v_FaceValueFI         NUMBER := -1;

  BEGIN

    EXECUTE IMMEDIATE 'TRUNCATE TABLE DPMWRTSUM_TMP';

    SELECT t_FaceValueFI INTO v_FaceValueFI FROM DFININSTR_DBT WHERE t_FIID = p_FIID;


    INSERT INTO DPMWRTSUM_TMP
                   (
                     T_SUMID,
                     T_KIND,
                     T_AMOUNT,
                     T_COST,
                     T_BALANCECOST,
                     T_INTERESTADD,
                     T_BONUSADD,
                     T_DISCOUNTADD,
                     T_INTERESTINCOME,
                     T_NOTCARRYINTEREST,
                     T_INTERESTDATE,
                     T_BEGDISCOUNTDATE,
                     T_BEGBONUSDATE,
                     T_DISCOUNTINCOME,
                     T_NOTCARRYDISCOUNT,
                     T_DISCOUNTDATE,
                     T_BONUS,
                     T_BONUSDATE,
                     T_NOTWRTBONUS,
                     T_DEFDIFFADD,
                     T_ACCOUNTEDDEFDIFF,
                     T_DEFDIFFDATE,
                     T_WRTOUTLAYADD,
                     T_WRTOUTLAY,
                     T_WRTOUTLAYDATE,
                     T_VATOUTLAYADD,
                     T_WRTVATOUTLAY,
                     T_CORRVALUE,
                     T_CORRDATE,
                     T_AMORTCOST,
                     T_CORRINTTOEIR,
                     T_CORRINTTOEIRDATE,
                     T_WRTCORRINTTOEIR,
                     T_ESTRESERVEADD,
                     T_CORRESTRESERVEADD,
                     T_RESERVAMOUNTADD,
                     T_INCOMERESERVADD,
                     T_PORTFOLIO,
                     T_STATE,
                     T_OVERAMOUNT,
                     T_OVERAMOUNTADD,
                     T_DEALID,
                     T_BEGDEFDIFFDATE,
                     T_HEDGCORR,
                     T_HEDGCORRDATE,
                     T_AMORTHEDGCORR,
                     T_AMORTHEDGCORRDATE
                   )
            SELECT
                     LOT.T_SUMID,
                     0,
                     LOT.T_AMOUNT,
                     LOT.T_COST,
                     LOT.T_BALANCECOST,
                     0,
                     0,
                     0,
                     LOT.T_INTERESTINCOME,
                     LOT.T_NOTCARRYINTEREST,
                     LOT.T_INTERESTDATE,
                     LOT.T_BEGDISCOUNTDATE,
                     LOT.T_BEGBONUSDATE,
                     LOT.T_DISCOUNTINCOME,
                     LOT.T_NOTCARRYDISCOUNT,
                     LOT.T_DISCOUNTDATE,
                     LOT.T_BONUS,
                     LOT.T_BONUSDATE,
                     LOT.T_NOTWRTBONUS,
                     0,
                     LOT.T_ACCOUNTEDDEFDIFF,
                     LOT.T_DEFDIFFDATE,
                     0,
                     LOT.T_WRTOUTLAY,
                     LOT.T_WRTOUTLAYDATE,
                     0,
                     LOT.T_WRTVATOUTLAY,
                     LOT.T_CORRVALUE,
                     LOT.T_CORRDATE,
                     LOT.T_AMORTCOST,
                     LOT.T_CORRINTTOEIR,
                     LOT.T_CORRINTTOEIRDATE,
                     0,
                     0,
                     0,
                     0,
                     0,
                     LOT.T_PORTFOLIO,
                     LOT.T_STATE,
                     LOT.T_OVERAMOUNT,
                     0,
                     LOT.T_DEALID,
                     LOT.T_BEGDEFDIFFDATE,
                     LOT.T_HEDGCORR,
                     LOT.T_HEDGCORRDATE,
                     LOT.T_AMORTHEDGCORR,
                     LOT.T_AMORTHEDGCORRDATE
        FROM DPMWRTSUM_DBT LOT
       WHERE LOT.t_Department = p_Department 
         AND LOT.t_FIID       = p_FIID 
         AND LOT.t_Party      = -1 
         AND (    (LOT.t_Portfolio  = KINDPORT_ASCB AND LOT.t_State IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP))
               OR (LOT.t_Portfolio  IN (KINDPORT_AC_OWN, -1) AND LOT.t_State = PM_WRTSUM_PLACE_OWN)) 
         AND LOT.t_Contract   = 0 
         AND LOT.t_Date      <= p_OperDate  
         AND LOT.T_ACTIVATEDATE <= p_OperDate 
         AND LOT.T_HEDGCORRDATE <= p_OperDate
         AND LOT.T_AMOUNT > 0
         AND NOT EXISTS(SELECT 1 FROM DPMWRTSUM_TMP TMP WHERE TMP.t_SumID = LOT.T_SumID);


    --Бумага одновременно не может быть в этих двух портфелях, т.к. это приобретенне и выпущенные ц/б
    --Поэтому можно смело считать кол-во по временной таблице - суммы не пересекутся
    SELECT NVL(SUM(T_AMOUNT), 0), NVL(SUM(T_HEDGCORR), 0) INTO v_SumAmount, v_SumHedgCorrNat
      FROM DPMWRTSUM_TMP;

    v_SumHedgCorrNat := v_SumHedgCorrNat + ROUND(RSI_RSB_FIInstr.ConvSum(p_AddHedgCorr, p_CorrCurrency, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1 ), 2) ;

    v_RestAmount         := v_SumAmount;
    v_RestSumHedgCorrNat := v_SumHedgCorrNat;

    --Распередяем новую полную сумму корректировки по лотам, пропорционально кол-ву
    FOR one_rec IN (SELECT TMP.T_SUMID, TMP.T_AMOUNT, TMP.T_HEDGCORR, TMP.T_BALANCECOST, TMP.T_HEDGCORRDATE, LOT.T_STATE
                      FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                     WHERE LOT.T_SUMID = TMP.T_SUMID
                     ORDER BY TMP.T_AMOUNT DESC
                   )
    LOOP
      IF one_rec.t_Amount = v_RestAmount THEN
        v_LotHedgCorrNat := v_RestSumHedgCorrNat;
      ELSE
        v_LotHedgCorrNat := ROUND(v_SumHedgCorrNat * one_rec.t_Amount / v_SumAmount, 2);
      END IF;

      IF one_rec.T_STATE = PM_WRTSUM_FORM THEN
        v_LotBalanceCost := one_rec.t_BalanceCost - ROUND(RSI_RSB_FIInstr.ConvSum(one_rec.t_HedgCorr, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, one_rec.t_HedgCorrDate, 1 ), 2)
                                                  + ROUND(RSI_RSB_FIInstr.ConvSum(v_LotHedgCorrNat,   RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, p_OperDate, 1 ), 2);
      ELSE
        v_LotBalanceCost := one_rec.t_BalanceCost;
      END IF;

      UPDATE DPMWRTSUM_TMP 
         SET T_HEDGCORR          = v_LotHedgCorrNat,
             T_HEDGCORRDATE      = p_OperDate,
             T_BALANCECOST       = v_LotBalanceCost
       WHERE T_SUMID = one_rec.T_SUMID;

      v_RestAmount         := v_RestAmount - one_rec.t_Amount;
      v_RestSumHedgCorrNat := v_RestSumHedgCorrNat - v_LotHedgCorrNat;
    END LOOP;

  END; -- RSI_AddHedgCorrToLotsTMP

  PROCEDURE RSI_WrtAmortHedgCorrToLotsTMP(p_OperDate IN DATE,
                                          p_FIID IN NUMBER,
                                          p_Department IN NUMBER,
                                          p_WrtAmortHedgCorr IN NUMBER,
                                          p_CorrCurrency IN NUMBER
                                         )
  AS
    v_SumHedgCorrNat      NUMBER := 0;
    v_RestAmount          NUMBER := 0;
    v_SumAmount           NUMBER := 0;
    v_RestSumHedgCorrNat  NUMBER := 0;
    v_LotHedgCorrNat      NUMBER := 0;
    v_SumAmortHedgCorrNat NUMBER := 0;
    v_RedistrHedgCorr     NUMBER := 0;
    v_RestRedistrHedgCorr NUMBER := 0;
    v_RestSumAmortHedgCorrNat NUMBER := 0;

    v_LotAmortHedgCorrNat NUMBER := 0;
    v_LotWrtHedgCorr      NUMBER := 0;

    v_LotBalanceCost      NUMBER := 0;

    v_FaceValueFI         NUMBER := -1;

    v_MaxAmortHedgCorrDate DATE;
  BEGIN

    EXECUTE IMMEDIATE 'TRUNCATE TABLE DPMWRTSUM_TMP';

    SELECT t_FaceValueFI INTO v_FaceValueFI FROM DFININSTR_DBT WHERE t_FIID = p_FIID;


    INSERT INTO DPMWRTSUM_TMP
                   (
                     T_SUMID,
                     T_KIND,
                     T_AMOUNT,
                     T_COST,
                     T_BALANCECOST,
                     T_INTERESTADD,
                     T_BONUSADD,
                     T_DISCOUNTADD,
                     T_INTERESTINCOME,
                     T_NOTCARRYINTEREST,
                     T_INTERESTDATE,
                     T_BEGDISCOUNTDATE,
                     T_BEGBONUSDATE,
                     T_DISCOUNTINCOME,
                     T_NOTCARRYDISCOUNT,
                     T_DISCOUNTDATE,
                     T_BONUS,
                     T_BONUSDATE,
                     T_NOTWRTBONUS,
                     T_DEFDIFFADD,
                     T_ACCOUNTEDDEFDIFF,
                     T_DEFDIFFDATE,
                     T_WRTOUTLAYADD,
                     T_WRTOUTLAY,
                     T_WRTOUTLAYDATE,
                     T_VATOUTLAYADD,
                     T_WRTVATOUTLAY,
                     T_CORRVALUE,
                     T_CORRDATE,
                     T_AMORTCOST,
                     T_CORRINTTOEIR,
                     T_CORRINTTOEIRDATE,
                     T_WRTCORRINTTOEIR,
                     T_ESTRESERVEADD,
                     T_CORRESTRESERVEADD,
                     T_RESERVAMOUNTADD,
                     T_INCOMERESERVADD,
                     T_PORTFOLIO,
                     T_STATE,
                     T_OVERAMOUNT,
                     T_OVERAMOUNTADD,
                     T_DEALID,
                     T_BEGDEFDIFFDATE,
                     T_HEDGCORR,
                     T_HEDGCORRDATE,
                     T_AMORTHEDGCORR,
                     T_AMORTHEDGCORRDATE
                   )
            SELECT
                     LOT.T_SUMID,
                     0,
                     LOT.T_AMOUNT,
                     LOT.T_COST,
                     LOT.T_BALANCECOST,
                     0,
                     0,
                     0,
                     LOT.T_INTERESTINCOME,
                     LOT.T_NOTCARRYINTEREST,
                     LOT.T_INTERESTDATE,
                     LOT.T_BEGDISCOUNTDATE,
                     LOT.T_BEGBONUSDATE,
                     LOT.T_DISCOUNTINCOME,
                     LOT.T_NOTCARRYDISCOUNT,
                     LOT.T_DISCOUNTDATE,
                     LOT.T_BONUS,
                     LOT.T_BONUSDATE,
                     LOT.T_NOTWRTBONUS,
                     0,
                     LOT.T_ACCOUNTEDDEFDIFF,
                     LOT.T_DEFDIFFDATE,
                     0,
                     LOT.T_WRTOUTLAY,
                     LOT.T_WRTOUTLAYDATE,
                     0,
                     LOT.T_WRTVATOUTLAY,
                     LOT.T_CORRVALUE,
                     LOT.T_CORRDATE,
                     LOT.T_AMORTCOST,
                     LOT.T_CORRINTTOEIR,
                     LOT.T_CORRINTTOEIRDATE,
                     0,
                     0,
                     0,
                     0,
                     0,
                     LOT.T_PORTFOLIO,
                     LOT.T_STATE,
                     LOT.T_OVERAMOUNT,
                     0,
                     LOT.T_DEALID,
                     LOT.T_BEGDEFDIFFDATE,
                     LOT.T_HEDGCORR,
                     LOT.T_HEDGCORRDATE,
                     LOT.T_AMORTHEDGCORR,
                     LOT.T_AMORTHEDGCORRDATE
        FROM DPMWRTSUM_DBT LOT
       WHERE LOT.t_Department = p_Department 
         AND LOT.t_FIID       = p_FIID 
         AND LOT.t_Party      = -1 
         AND (    (LOT.t_Portfolio  = KINDPORT_ASCB AND LOT.t_State IN (PM_WRTSUM_FORM, PM_WRTSUM_SALE_BPP))
               OR (LOT.t_Portfolio  IN (KINDPORT_AC_OWN, -1) AND LOT.t_State = PM_WRTSUM_PLACE_OWN)) 
         AND LOT.t_Contract   = 0 
         AND LOT.t_Date      <= p_OperDate  
         AND LOT.T_ACTIVATEDATE <= p_OperDate 
         AND LOT.T_AMORTHEDGCORRDATE <= p_OperDate
         AND LOT.T_AMOUNT > 0
         AND NOT EXISTS(SELECT 1 FROM DPMWRTSUM_TMP TMP WHERE TMP.t_SumID = LOT.T_SumID);

    SELECT NVL(MAX(T_AMORTHEDGCORRDATE),TO_DATE('01.01.0001','DD.MM.YYYY')) INTO v_MaxAmortHedgCorrDate FROM DPMWRTSUM_TMP;

    IF v_MaxAmortHedgCorrDate = p_OperDate THEN
      RETURN; --Уже выполнялась амортизация в эту дату
    END IF;

    --Для всех отношений хеджирования, которые закончились в период с даты последней амортизации и до даты текущей операции, выполнить перенос начисленной корректировки в корректировку к амортизации
    WITH cat AS (SELECT c.t_ID
                   FROM DMCCATEG_DBT c
                  WHERE c.t_LevelType = 1
                    AND c.t_Code IN ('+Корректировка, ц/б_Хедж','-Корректировка, ц/б_Хедж','+Корр, ОЭБ_Хедж','-Корр, ОЭБ_Хедж')
                )
    SELECT -1*NVL(SUM(rsb_account.restac(accdoc.t_Account, accdoc.t_Currency, hdr.t_EndDate, accdoc.t_Chapter, null)), 0) INTO v_RedistrHedgCorr
      FROM ddlhdgrelation_dbt hdr, dmcaccdoc_dbt accdoc, cat
     WHERE hdr.t_ObjDocKind = RSB_SECUR.OBJTYPE_AVOIRISS
       AND hdr.t_ObjID = p_FIID
       AND hdr.t_EndDate <> TO_DATE('01.01.0001','DD.MM.YYYY')
       AND hdr.t_EndDate > v_MaxAmortHedgCorrDate
       AND hdr.t_EndDate <= p_OperDate
       AND accdoc.t_DocKind = RSB_SECUR.SP_AVRHDGRELATION
       AND accdoc.t_DocID = hdr.t_ID
       AND accdoc.t_FIID = hdr.t_ObjID
       AND accdoc.t_CatID = cat.t_ID;

    --Бумага одновременно не может быть в этих двух портфелях, т.к. это приобретенне и выпущенные ц/б
    --Поэтому можно смело считать кол-во по временной таблице - суммы не пересекутся
    SELECT NVL(SUM(T_AMOUNT), 0), NVL(SUM(T_AMORTHEDGCORR), 0) INTO v_SumAmount, v_SumAmortHedgCorrNat
      FROM DPMWRTSUM_TMP;

    v_SumAmortHedgCorrNat := v_SumAmortHedgCorrNat - ROUND(RSI_RSB_FIInstr.ConvSum(p_WrtAmortHedgCorr, p_CorrCurrency, RSI_RSB_FIInstr.NATCUR, p_OperDate, 1 ), 2) + v_RedistrHedgCorr;

    v_RestAmount              := v_SumAmount;
    v_RestSumAmortHedgCorrNat := v_SumAmortHedgCorrNat;
    v_RestRedistrHedgCorr     := v_RedistrHedgCorr;

    --Распередяем новую полную сумму корректировки по лотам, пропорционально кол-ву
    FOR one_rec IN (SELECT TMP.T_SUMID, TMP.T_AMOUNT, TMP.T_AMORTHEDGCORR, TMP.T_HEDGCORR, TMP.T_BALANCECOST, TMP.T_AMORTHEDGCORRDATE, TMP.T_HEDGCORRDATE, LOT.T_STATE
                      FROM DPMWRTSUM_TMP TMP, DPMWRTSUM_DBT LOT
                     WHERE LOT.T_SUMID = TMP.T_SUMID
                     ORDER BY TMP.T_AMOUNT DESC
                   )
    LOOP
      IF one_rec.t_Amount = v_RestAmount THEN
        v_LotAmortHedgCorrNat := v_RestSumAmortHedgCorrNat;
        v_LotWrtHedgCorr      := v_RestRedistrHedgCorr;
      ELSE
        v_LotAmortHedgCorrNat := ROUND(v_SumAmortHedgCorrNat * one_rec.t_Amount / v_SumAmount, 2);
        v_LotWrtHedgCorr      := ROUND(v_RedistrHedgCorr * one_rec.t_Amount / v_SumAmount, 2);
      END IF;

      IF one_rec.T_STATE = PM_WRTSUM_FORM THEN
        v_LotBalanceCost := one_rec.t_BalanceCost + ROUND(RSI_RSB_FIInstr.ConvSum(v_LotAmortHedgCorrNat,   RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, p_OperDate, 1 ), 2);

        IF one_rec.t_AmortHedgCorrDate != UnknownDate THEN
          v_LotBalanceCost := one_rec.t_BalanceCost - ROUND(RSI_RSB_FIInstr.ConvSum(one_rec.t_AmortHedgCorr, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, one_rec.t_AmortHedgCorrDate, 1 ), 2);
        END IF;

        IF v_LotWrtHedgCorr <> 0 THEN
          v_LotBalanceCost := one_rec.t_BalanceCost - ROUND(RSI_RSB_FIInstr.ConvSum(v_LotWrtHedgCorr, RSI_RSB_FIInstr.NATCUR, v_FaceValueFI, one_rec.t_HedgCorrDate, 1 ), 2);
        END IF;
      ELSE
        v_LotBalanceCost := one_rec.t_BalanceCost;
      END IF;

      UPDATE DPMWRTSUM_TMP 
         SET T_AMORTHEDGCORR     = v_LotAmortHedgCorrNat,
             T_AMORTHEDGCORRDATE = p_OperDate,
             T_HEDGCORR          = T_HEDGCORR - v_LotWrtHedgCorr,
             T_HEDGCORRDATE      = (CASE WHEN v_LotWrtHedgCorr <> 0 THEN p_OperDate ELSE T_HEDGCORRDATE END),
             T_BALANCECOST       = v_LotBalanceCost
       WHERE T_SUMID = one_rec.T_SUMID;

      v_RestAmount              := v_RestAmount - one_rec.t_Amount;
      v_RestSumAmortHedgCorrNat := v_RestSumAmortHedgCorrNat - v_LotAmortHedgCorrNat;
      v_RestRedistrHedgCorr     := v_RestRedistrHedgCorr - v_LotWrtHedgCorr;
    END LOOP;

  END; -- RSI_WrtAmortHedgCorrToLotsTMP

  PROCEDURE RSI_WRTSaveHedgCorrLots( p_OperDate     IN DATE,    -- Дата
                                     p_ID_Operation IN NUMBER,  -- Операция
                                     p_ID_Step      IN NUMBER   -- Шаг операции
                                   )
   IS
   BEGIN
      FOR one_prm IN (SELECT TMP.T_SUMID, TMP.T_BALANCECOST, TMP.T_HEDGCORR, TMP.T_AMORTHEDGCORR, TMP.T_HEDGCORRDATE, TMP.T_AMORTHEDGCORRDATE
                        FROM DPMWRTSUM_TMP TMP)
      LOOP
         RSI_WRTSaveLot(one_prm.T_SUMID, p_ID_Operation, p_ID_Step, p_OperDate, PM_WRT_UPDTMODE_HEDGCORR);

         UPDATE DPMWRTSUM_DBT LOT
            SET LOT.T_HEDGCORR          = one_prm.T_HEDGCORR,
                LOT.T_HEDGCORRDATE      = one_prm.T_HEDGCORRDATE,
                LOT.T_AMORTHEDGCORR     = one_prm.T_AMORTHEDGCORR,
                LOT.T_AMORTHEDGCORRDATE = one_prm.T_AMORTHEDGCORRDATE,
                LOT.T_BALANCECOST       = one_prm.T_BALANCECOST
          WHERE LOT.T_SUMID = one_prm.T_SUMID;
      END LOOP;

      DELETE FROM DPMWRTSUM_TMP;

   END;

END RSB_PMWRTOFF;
/
