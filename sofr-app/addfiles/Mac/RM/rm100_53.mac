 /*
 $Name: rm100_53.mac
 $Module: АРМ позиционера
 $Description: Макрос шага(29072 - "Обработка невыясненной суммы"/53    - "Обработка невыясненной суммы")
 */
//-----------------------------------------------------------------------------
// Блок      : 29072 - "Обработка невыясненной суммы"
// Шаг       : 53    - "Обработка невыясненной суммы"
// Назначение: Макрос шага
// Описание  : Макрос шага
//-----------------------------------------------------------------------------
import PaymInter, WldInter, PTInter, OprInter, CTInter, "rmconst.mac", "cbsttls.mac", oralib, likepy, pmsummo, "pm_common.mac", pm_tools;

var PaymentObj:RsbPayment;

private macro GetAcc( FIID:integer, Account:string, Chapter:integer, Department, Open_Date, Close_Date ):integer
  FILE acc( account );
  acc.Account = Account;
  acc.Code_Currency = FIID;
  acc.Chapter = Chapter;
  if ( GetEQ(acc) )
    setparm(3, acc.Department);
    setparm(4, acc.Open_Date);
    setparm(5, acc.Close_Date);
    return 0;
  end;
  return 1;
end;    


PRIVATE CLASS TCategory( _GroupID:integer, _AttrID:integer )
  VAR GroupID:integer = _GroupID;
  VAR AttrID:integer  = _AttrID;
END;

//------------------------------------------------------------------------------
// Получить список категорий платежа
//------------------------------------------------------------------------------
PRIVATE MACRO GetCategoryForPayment( PaymentID:integer ):TArray

  var CatList:TArray = TArray();
  var query:string =  "select T_GROUPID, T_ATTRID " +
                       " from dobjatcor_dbt " +
                      " where t_ObjectType = :ObjectType " +
                        " and t_Object = LPAD(:PaymentID, 10, '0');";
  var params:TArray = makeArray( SQLParam( "ObjectType", OBJTYPE_PAYMENT ), 
                                 SQLParam( "PaymentID", PaymentID ) );
  
  var rs:RsdRecordset = execSQLselect( query, params, true );
  if( rs )
    while( rs.moveNext() )
      CatList[CatList.size] = TCategory( rs.value(0), rs.value(1) );
    end;
  end;
  return CatList;
ONERROR(x)
  return CatList;
END;


//-----------------------------------------------------------------------------
// Создать требование/поручение банка
//-----------------------------------------------------------------------------
PRIVATE MACRO CreateBankPayment( byvariant:integer, stat:@integer ):RsbPayment

  stat = 0;

  var Payment:RsbPayment = null; // платеж 
  var BankPayment:object = null; // первичный документ

  var pi       : TRecHandler = TRecHandler( "pmaddpi.dbt" );
  var piAccount: string  = "";
  var piClient : integer = 0;       
  var DC       : integer = IfThenElse( PaymentObj.IsCredit(), 1, 0 );
  
  if( byvariant == 3 ) // Платеж с уточ. записями
    if( ( PaymentObj.PIList( DC ).First() == 0 ) and ( PaymentObj.PIList( DC ).Current( pi ) == 0 ) )
      piAccount = pi.rec.Account;
      piClient  = pi.rec.AccountClient;
    end;
  end;

  // Заполнение полей кредитового платежа
  if( PaymentObj.IsCredit() )

    // Создание рублевого кредитового платежа
    if( ( PaymentObj.PayerFIID == PaymentObj.BaseFIID ) AND
        ( PaymentObj.PayerFIID == PaymentObj.ReceiverFIID ) AND
        ( PaymentObj.PayerFIID == 0 /*NATCUR*/ ) )

      BankPayment = GenObject( "RsbBankPayment", 0 );
      Payment     = BankPayment.Payment();

      BankPayment.Origin     = MEMORDER_FDOC_PROCUNKNOWNPM; // Обработка невыясненного платежа
      BankPayment.Oper       = {oper}; 
      BankPayment.Status     = 1/*MEMORDER_STATUS_POST*/;

      Payment.DocKind        = DLDOC_BANKPAYMENT;
      Payment.Purpose        = PM_PURP_BANKPAYMENT;

      Payment.BaseFIID       =
      Payment.PayerFIID      = 
      Payment.ReceiverFIID   = PaymentObj.PayerFIID;

      Payment.BaseAmount     = PaymentObj.PayerAmount;
      Payment.ReceiverAmount = PaymentObj.PayerAmount;
      Payment.PayerAmount    = PaymentObj.FuturePayerAmount;

    else
      
      BankPayment            = GenObject( "RsbBbCpOrder", 0 );
      Payment                = BankPayment.Payment();

      BankPayment.Origin       = CP_OR_PROCUNKNOWNPM; // Обработка невыясненного платежа
      BankPayment.Oper         = {oper}; 
      BankPayment.CurrentState = 0/*CP_ST_DEFERRED*/;

      Payment.DocKind        = BBANK_CPORDER;
      Payment.Purpose        = PM_PURP_BANKPAYMENT;
      Payment.ComissCharges  = PM_CHRG_SHA;

      Payment.BaseFIID       = PaymentObj.BaseFIID;
      Payment.PayerFIID      = PaymentObj.FuturePayerFIID;
      Payment.ReceiverFIID   = PaymentObj.FutureReceiverFIID;

      Payment.BaseAmount     = PaymentObj.BaseAmount;
      Payment.PayerAmount    = PaymentObj.FuturePayerAmount;
      Payment.ReceiverAmount = PaymentObj.FutureReceiverAmount;

    end;

    Payment.OrderFIID   = Payment.BaseFIID;
    Payment.OrderAmount = Payment.BaseAmount;

    Payment.IsFixPayerAmount = "X";

    stat = Payment.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                               {OurBank}, 
                               IfThenElse( Payment.DocKind == DLDOC_BANKPAYMENT, PTCK_BIC, PTCK_CONTR ),
                               "", 
                               "",
                               "",
                               PaymentObj.FuturePayerFIID, 
                               1/*CHAPT1*/, 
                               PaymentObj.FuturePayerAccount
                             );
    if( stat ) return null; end;

    stat = Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                                  {OurBank}, 
                                  0, 
                                  "", 
                                  "",
                                  "",
                                  PaymentObj.ReceiverFIID, 
                                  1/*CHAPT1*/, 
                                  IfThenElse( byvariant == 1, PaymentObj.ReceiverAccount, IfThenElse( byvariant == 3, piAccount, "" ) ),
                                  -1, 
                                  ""
                                );
    if( stat ) return null; end;

    Payment.Ground = substr( "Перечисление по назначению средств по док. " + PaymentObj.Number + " от " + PaymentObj.Date + " '" + PaymentObj.Ground + "'", 1, 600 );

  else // Заполнение полей дебетового платежа

    BankPayment = GenObject( "RsbBankClaim", 0 );
    Payment     = BankPayment.Payment();

    BankPayment.Origin     = MEMORDER_FDOC_PROCUNKNOWNPM; // Обработка невыясненного платежа
    BankPayment.Oper       = {oper}; 
    BankPayment.Status     = 1/*MEMORDER_STATUS_POST*/;

    Payment.DocKind        = DLDOC_BANKCLAIM;
    Payment.Purpose        = PM_PURP_BANKPAYMENT;

    Payment.BaseFIID       = PaymentObj.BaseFIID;

    Payment.BaseAmount     = PaymentObj.FutureBaseAmount;
    Payment.PayerAmount    = PaymentObj.PayerAmount;

    Payment.OrderFIID   = Payment.BaseFIID;
    Payment.OrderAmount = Payment.BaseAmount;

    stat = Payment.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                               {OurBank}, 
                               IfThenElse( byvariant == 1, PTCK_BIC, PTCK_CONTR ),
                               "", 
                               "",
                               "",
                               PaymentObj.PayerFIID, 
                               1/*CHAPT1*/, 
                               IfThenElse( byvariant == 1, PaymentObj.PayerAccount, IfThenElse( byvariant == 3, piAccount, "" ) ),
                               -1,
                               "",
                               ""
                             );
    if( stat ) return null; end;
    stat = Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                                  {OurBank}, 
                                  PTCK_BIC, 
                                  "", 
                                  "",
                                  "",
                                  PaymentObj.FutureReceiverFIID, 
                                  1/*CHAPT1*/, 
                                  PaymentObj.FutureReceiverAccount
                                );
    if( stat ) return null; end;

    Payment.DemandAcceptTerm = PM_DEMAND_TERM_WITHOUTACCEPT;
    Payment.DemandAccept = PM_DEMAND_ACCEPT_NONE;

    Payment.Ground = substr( "Списание средств по док. " + PaymentObj.Number + " от " + PaymentObj.Date + " '" + PaymentObj.Ground + "'", 1, 600 );

  end;
 
  Payment.Number      = PaymentObj.Number;
  Payment.Priority    = PaymentObj.Priority;
  Payment.PaymentKind = "Э";

  if( Payment.DocKind == DLDOC_BANKCLAIM )
    Payment.ShifrOper   = "02";
  else
    Payment.ShifrOper   = "01";
  end;
  
  Payment.PayDate     = PaymentObj.ValueDate;
  Payment.ClientDate  = 
  Payment.Date        = {curdate};
  Payment.ValueDate   = PM_GetDefaultValueDate(Payment.Department, Payment.PrimDocKind);
  Payment.NumberPack  = 0;
  Payment.Origin      = 2;
  Payment.ToBackOffice = PaymentObj.ToBackOffice;
  Payment.FeeType     = PaymentObj.FeeType;
  Payment.DefComID    = PaymentObj.DefComID; 

    // заполняются налоговые данные
  Payment.TaxAuthorState = PaymentObj.TaxAuthorState;
  Payment.BttTICode      = PaymentObj.BttTICode;
  Payment.OKATOCode      = PaymentObj.OKATOCode;
  Payment.TaxPmGround    = PaymentObj.TaxPmGround;
  Payment.TaxPmPeriod    = PaymentObj.TaxPmPeriod;
  Payment.TaxPmNumber    = PaymentObj.TaxPmNumber;
  Payment.TaxPmDate      = PaymentObj.TaxPmDate;
  Payment.TaxPmType      = PaymentObj.TaxPmType;

  if( byvariant == 3 )
    // Копируем из исходного платежа уточ. записи
    stat = CopyPIFromPaymIntoOthePaym( PaymentObj, Payment, DC );
    if( stat ) return null; end;
  end;

  // Установить признак автозапуска операции.
  BankPayment.LaunchOper = true;
  //Payment.CryptoAction( string("Автоматическое_формирование_платежей") );

  // Копируем из исходного платежа категории
  CopyPaymentCategories(Payment, PaymentObj, TRUE);
  
  // Копируем из исходного платежа примечания
  CopyPaymentNotes(Payment, PaymentObj);
   
  return Payment;

END;

// Проверки валютной операции
private macro CheckCurrencyOperation()

  var VOReject = "";
  var VORejectGround:string = "";

  if( PaymentObj.PM_Check117( VOReject, VORejectGround ) == 0 )
    if( VOReject == SET_CHAR )
     /* msgbox( VORejectGround );
      return 1;*/ // Прерываем операцию #226350
    end;
  else
    msgbox("Ошибка при проверке реквизитов валютной операции");
    return 1;
  end;
  return 0;
end;

//-----------------------------------------------------------------------------
// Выполнение шага
//-----------------------------------------------------------------------------
MACRO ExecuteStep( doc, first, DocKind:integer, ID_Operation:integer, ID_Step:integer )

  var PayPayment:RsbPayment = null;
  var Action:integer = 0;
  var stat:integer = 0;
  var RegVal:bool = false;
  var err;
  var Department, Open_Date, Close_Date;
  var retVal:integer = 0;
  
  array FlgRM;       // Массив флагов для R-макета
  array FlgKZRM;     // Массив флагов для R-макета ( казахская платежка )
  
  if( PaymentObj.FutureBaseAmount == $0 )
    if( УстановитьСтатусыПлатежа( OPR_PAYM_MANUAL, OPR_PAYM_ST_MANUAL_NOTNEED ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;    
    if( УстановитьСтатусыПлатежа( OPR_PAYM_STATE, OPR_PM_ST_CLOSE ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;
    
    return 0;
  end;
  
  var query = 
              " SELECT COUNT (*) " +
              "  FROM DPMPARTAT_DBT PMPARTAT " +
              " WHERE PMPARTAT.T_PAYMENTID = :PAYMENTID AND PMPARTAT.T_STATE = :STATE ";
              
  var rs = execSQLselect( query, makeArray( SQLParam("PAYMENTID", PaymentObj.PaymentID),
                                            SQLParam("STATE", WLD_STATUS_PMPARTAT_FILLED)), false );  
                                            
  if( rs and rs.moveNext() and (rs.value(0) != 0) )
  
    var question = "По документу заполнены записи реквизитов платежей для частичного исполнения|Для формирования платежей необходимо прервать выполнение шага и вызвать отдельную процедуру";
  
    if(IsOprMultiExec())
      msgbox( question );
      return 1;
    elif(ConfWin( makeArray( question ),
                  makeArray( "Продолжить", "Прервать" ) ) )                   
      msgbox("Пользователь прервал выполнение операции.");
      return 1;    
    end;
  end;
  
  GetRegistryValue( "АРМ ПОЗИЦИОНЕРА\\НЕВЫЯСНЕННЫЕ\\НОВЫЙ_ДОКУМЕНТ", V_BOOL, RegVal, err );  

  if(CheckDateStartOpr(ID_Operation))
    return 1;
  end;

  PaymentObj.ValueDate = PM_GetOperDay_Balance(PaymentObj.Department);

  // Если документу был установлен символ БО
  if( PaymentObj.ToBackOffice != "" ) 

    // Установить значения сегментов статуса
    if( УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, OPR_PAYM_ST_INDEX_NO ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;

    if( УстановитьСтатусыПлатежа( OPR_PAYM_BO_PROCESS, OPR_PAYM_ST_BO_YES ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;

  elif( ( PaymentObj.PIList(0).Size > 0 ) OR ( PaymentObj.PIList(1).Size > 0 ) ) // Если перед выполнением шага в исходный документ были введены уточняющие записи (сложная проводка)
    
    if( RegVal == false )
      if( УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, OPR_PAYM_ST_INDEX_NO ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return 1;
      end;

      if( УстановитьСтатусыПлатежа( OPR_PAYM_BO_PROCESS, OPR_PAYM_ST_BO_NO ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return 1;
      end;
    
      if( CheckCurrencyOperation())
        return 1;
      end;
      
    else
      // Без интерфейса формируется дочерний документ согласно приведенным ниже таблицам (вариант 2). 
      // В него из исходного документа также копируются введенные уточняющие записи, 
      // и очищается счет и наименование получателя (для дебетовых - счет и наименование плательщика)  
      PayPayment = CreateBankPayment( 3, @stat );
    end;
  else

    if( PaymentObj.IsCredit() )
      if ( PaymentObj.ReceiverAccount == "" )
        msgbox("Не указан счет получателя");
        return 1;
      end;

      retVal = GetAcc(PaymentObj.ReceiverFIID, PaymentObj.ReceiverAccount, PaymentObj.Chapter, Department, Open_Date, Close_Date);
      if ( (not retVal) and (Department == PaymentObj.EndDepartment) )
        if ( not ((Open_Date <= PaymentObj.ValueDate) and
                  ((Close_Date == date(0,0,0) ) or (Close_Date > PaymentObj.ValueDate ))
                 )
           )
          msgbox("Счет получателя закрыт");
          return 1;
        end;
      else
          msgbox("Не найден счет получателя № " + PaymentObj.ReceiverAccount);
          return 1;
      end;
    else
      if ( PaymentObj.PayerAccount == "" )
        msgbox("Не указан счет плательщика");
        return 1;
      end;
      
      
      retVal = GetAcc(PaymentObj.PayerFIID, PaymentObj.PayerAccount, PaymentObj.Chapter, Department, Open_Date, Close_Date);
      if ( (not retVal) and (Department == PaymentObj.EndDepartment) )
        if ( not ((Open_Date <= PaymentObj.ValueDate) and
                  ((Close_Date == date(0,0,0) ) or (Close_Date > PaymentObj.ValueDate ))
                 )
           )
          msgbox("Счет плательщика закрыт");
          return 1;
        end;
      else
          msgbox("Не найден счет плательщика № " + PaymentObj.PayerAccount);
          return 1;
      end;
    end;


    if( RegVal == false )
      if( УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, OPR_PAYM_ST_INDEX_NO ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return 1;
      end;

      if( УстановитьСтатусыПлатежа( OPR_PAYM_BO_PROCESS, OPR_PAYM_ST_BO_NO ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return 1;
      end;

      if( CheckCurrencyOperation())
        return 1;
      end;
      
    else

      PayPayment = CreateBankPayment( 1, @stat );

      FlgRM[PNRMPM_COUNT]     = 0;
      FlgKZRM[KZPNRMPM_COUNT] = 0;

      FlgRM[ PNRMPM_NUMBER ] = 1;
      FlgRM[ PNRMPM_GROUND ] = 1;
      FlgKZRM[ KZPNRMPM_NUMBER ] = 1;
      FlgKZRM[ KZPNRMPM_GROUND ] = 1;
    
      if( PayPayment.IsCredit() )
        FlgRM[ PNRMPM_ACCOUNTR ] = 1;
        FlgRM[ PNRMPM_INNR     ] = 1;
        FlgRM[ PNRMPM_NAMER    ] = 1;
        FlgKZRM[ KZPNRMPM_IIK_RECEIVER ] = 1;
        FlgKZRM[ KZPNRMPM_RNN_RECEIVER ] = 1;
        FlgKZRM[ KZPNRMPM_RECEIVER     ] = 1;
      else
        FlgRM[ PNRMPM_ACCOUNTP ] = 1;
        FlgRM[ PNRMPM_INNP     ] = 1;
        FlgRM[ PNRMPM_NAMEP    ] = 1;
        FlgKZRM[ KZPNRMPM_IIK_PAYER ] = 1;
        FlgKZRM[ KZPNRMPM_RNN_PAYER ] = 1;
        FlgKZRM[ KZPNRMPM_PAYER     ] = 1;
      end;

      if( ( stat == 0 ) AND GetDialogFlag() )
        if( not needUseKZpm() )
          Action = PM_ProcessPanel( PayPayment, 1, NULL, FlgRM );
        else
          Action = PM_ProcessPanel( PayPayment, 1, NULL, FlgKZRM );
        end;
        if( Action )
          if( Action == 4704 )
            msgbox( "Выполнение процедуры прервано пользователем" );
          else
            msgbox( "Ошибка при создании панели редактирования платежа" );
          end;
          return 1;
        end;
      end;
    end;
  end;

  // Значит ошибка при заполении полей платежа по перечислению невыясненной суммы
  if( stat )
    MemoryError( stat );
    msgbox( GetErrMsg() );
    return 1;
  end;

  if( RegVal == true )// Создать связь
    if( PaymentObj.LinkPayment( PayPayment, PMLINK_KIND_PROCUNKN ) )
      msgbox( GetErrMsg() );
      return 1;
    end;
  end;

  // Закрыть запись о невыясненной сумме исходного платежа.
  PaymentObj.CloseUnknown();

  if( RegVal == true )
    // Сегменту "Состояние платежа" статуса исходного платежа присваивается значение "Закрыт".
    if( УстановитьСтатусыПлатежа( OPR_PAYM_STATE, OPR_PM_ST_CLOSE ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;
  end;

  PaymentObj.StatusInfo = "Списан с картотеки невыясненных";

  return 0;
END;
