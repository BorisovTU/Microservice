//-----------------------------------------------------------------------------
// Блок     : 29000 - "Позиционирование"
// Шаг      : 10    - "Позиционирование"
// Описание : Макрос шага
//-----------------------------------------------------------------------------
import InsCarryDoc, PaymInter, PTInter, OprInter, BankInter, 
       "rmtools.mac", "cbctuncs.mac", "wlglobal.mac", "cbsttls.mac", "pm_common.mac", pm_setst, "pmcarfun.mac","pm_tools.mac", rsberror;

import pmprepromass;

var PaymentObj:RsbPayment;

record Corschem(corschem);/*корсхема до позиционирования*/
record OutProp(pmprop);/*исходящее свойство платежа после позиционирования*/

private macro IsUnfinAcc( FIID, Account ):bool
  var select = " select 1 " +
                 " from dmcaccdoc_dbt doc, dmccateg_dbt cat " +
                " where doc.t_Chapter = 1 " +
                  " and doc.t_Currency = :FIID " +
                  " and doc.t_Account = :Account " +
                  " and doc.t_CatID  = cat.t_ID " +
                  " and cat.t_Number = 103 ";

  var params = makeArray( SQLParam( "FIID", FIID ), 
                          SQLParam( "Account", Account ) );
  var rs = execSQLselect( select, params, TRUE );
  
  if( rs and rs.moveNext() )
    return true;
  else
    return false;
  end;
end;

private macro MR_ErrorDesc( stat:integer )
  if( stat == 1 )
    return "Неверный номер счёта";
  elif( stat == 2 )
    return "Недостаточно свободных средств на счёте";
  else
    return "";
  end;
end;

private class TReserveCreator( Payment:RsbPayment, Account:string, Chapter:integer, FIID:integer, Amount:money, p_CarryStatus:integer )

  private var m_Payment:RsbPayment = Payment,
              m_Account:string     = Account,
              m_Chapter:integer    = Chapter,
              m_FIID:integer       = FIID,
              m_Amount:money       = Amount;

  var CarryStatus : integer = p_CarryStatus;

  macro Create( ErrDesc:@string ) : integer
    var stat:integer = m_Payment.MakeReserve( m_Account, m_Chapter, m_FIID, m_Amount, {curdate}, false, true, true, false, false );
    ErrDesc = "Ошибка при формировании претензии к счету " + m_Account + "|" + MR_ErrorDesc( stat );
    return stat;
  end;

end;

//-----------------------------------------------------------------------------
// Выполнение шага
//-----------------------------------------------------------------------------
macro ExecuteStep( doc, first )

  var stat = 0;
  // Создатель резерва
  var ReserveCreator:TReserveCreator = null;

  // Для поиска корсхемы
  record cors(corschem);

  var Inner = PaymentObj.IsExternalIncoming() and not PaymentObj.IsTransit();
  var NeedCor, NeedTransferDate;
  if (Inner)
    NeedCor = PaymentObj.InCorschem;
    NeedTransferDate = PaymentObj.InTransferDate;
  else
    NeedCor = PaymentObj.OutCorschem;
    NeedTransferDate = PaymentObj.OutTransferDate;
    if( НайтиКорсхему( OutProp.Corschem, OutProp.PayFIID, cors ) )
      MsgBox( "Не найдена исходящая корсхема" );
      return 1;
    end;
  end;

  var carries : TArray,
    , carry   : TPaymentCarryInfo;

  if((NeedCor == OutProp.Corschem) and (NeedTransferDate == OutProp.TransferDate))
    if(GetOprStatus(OPR_PAYM_DO) == OPR_PM_ST_POS)
      carries = PM_GetAllCarries( PaymentObj.PaymentID, CHAPT1 );
      if( carries.size )
        carry = carries[carries.size-1];
        /* Если в последней проводке счет кредита (дебета для дебетового платежа) равен корсчету из исходящей корсхемы платежа 
           или является счетом СНР (имеет связь с категорией учета СНР)*/
        if( ( (PaymentObj.DbFlag == UNSET_CHAR) and (carry.ReceiverAccount == Corschem.Account) ) OR
            ( (PaymentObj.DbFlag == SET_CHAR)   and (carry.PayerAccount    == Corschem.Account) )             
          )
          if(УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_DISCHARGE))
            MsgBox( "Возникла ошибка при смене статусов операции платежа" );
            return 1;
          end;
        elif( ( (PaymentObj.DbFlag == UNSET_CHAR) and IsUnfinAcc( carry.ReceiverFIID, carry.ReceiverAccount ) ) OR
              ( (PaymentObj.DbFlag == SET_CHAR)   and IsUnfinAcc( carry.PayerFIID, carry.PayerAccount       ) )
            ) 
          PaymentObj.ValueDate = ValueDateForRmPosition(PaymentObj, cors);
          SetOprDate(29000000, PaymentObj.ValueDate);
          if(УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_DISCHARGE))
            MsgBox( "Возникла ошибка при смене статусов операции платежа" );
            return 1;
          end;
        else
          PaymentObj.ValueDate = ValueDateForRmPosition(PaymentObj, cors);
          SetOprDate(29000000, PaymentObj.ValueDate);
          if(УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_ENTER))
            MsgBox( "Возникла ошибка при смене статусов операции платежа" );
            return 1;
          end;
        end;

      end;
      
    end;

    if( IsCarryPlanDocs() )
      if ( not CarryPlanDocuments(PaymentObj.PaymentID) )
        MsgBox("Ошибка при помещении планируемой проводки в проведенные");
        return 1;
      end;
    end;
    return 0;
  end;

  if( PaymentObj.DocKind == DLDOC_MULTYPM )
    MemoryError( 6235 ); //PM_MSG_REPOSITMULTY_NOTALLOW
    DisplayError();
    return 1;
  end;
  
  if( (PaymentObj.DbFlag == SET_CHAR) and ( PaymentObj.StartDepartment != PaymentObj.Department ) )
    MsgBox("Дебетовые документы разрешено перепозиционировать только в начальном филиале");
    return 1;
  end;

  /* Удаляем проводку по корсчёту */
  carries = PM_GetAllCarries( PaymentObj.PaymentID, CHAPT1 );
  if( carries.size )
    carry = carries[carries.size-1];

    if( ( ( carry.ReceiverAccount == Corschem.Account ) and ( PaymentObj.DbFlag == IfThenElse(Inner, SET_CHAR, UNSET_CHAR) ) )OR
        ( ( carry.PayerAccount    == Corschem.Account ) and ( PaymentObj.DbFlag == IfThenElse(Inner, UNSET_CHAR, SET_CHAR) ) ) )
      var CarryRec:TRecHandler,
          CarryStatus:integer = -1;
      stat = PaymentObj.DeleteTransaction( carry.ACCTRNID, CarryRec, CarryStatus );
      /* Если по дебету удаляемой проводки стоит клиентский счёт и проводка проведённая,
         резервируем на счёте средства для новой проводки по корсчёту.
         Точнее, здесь только запоминаем, какой резерв надо создать */
      if( not stat )
        if( ( PaymentObj.DbFlag == UNSET_CHAR ) and 
            PM_FindBalanceInReg_117( "PS\\REQOPENACC\\Счета клиентов", carry.PayerAccount, 1 ) )
          ReserveCreator = TReserveCreator( PaymentObj, carry.PayerAccount, 1, carry.PayerFIID, carry.PayerAmount, CarryStatus );
        end;
      else
        MemoryError( stat );
        msgbox( "Ошибка удаления проводки по корсчёту | " + GetErrMsg() );
        return 1;
      end;
      
    end;
    PaymentObj.ValueDate = ValueDateForRmPosition(PaymentObj, cors);
    SetOprDate( 29000000, PaymentObj.ValueDate );
    //входящий платеж идет на предобработку
    if( УстановитьСтатусыПлатежа( OPR_PAYM_DO, IfThenElse(Inner, OPR_PM_ST_PREP, OPR_PM_ST_ENTER)) )
      MsgBox( "Возникла ошибка при смене статусов операции платежа" );
      return 1;
    end;

  end;

  if( not Inner )//корсхему можно только исходящему менять
    //Если изменилась исходящая корхема платежа
    if( ( PaymentObj.OutCorschem != OutProp.Corschem ) or ( PaymentObj.OutCorschemFIID != OutProp.PayFIID ) )
      if( cors.Department != Corschem.Department ) //Если корсхема в другом узле ТС
        if( УстановитьСтатусыПлатежа( OPR_PAYM_CABS, OPR_PM_ST_MFR_NO ) )
          MsgBox( "Возникла ошибка при смене статусов операции платежа" );
          return 1;
        end;            
      end ;
    end;


    if( GetOprStatus(OPR_PAYM_DIRECT) != OPR_PM_ST_DIR_OUT )
      if( УстановитьСтатусыПлатежа( OPR_PAYM_DIRECT, OPR_PM_ST_DIR_OUT ) )
        MsgBox( "Возникла ошибка при смене статусов операции платежа" );
        return 1;
      end;   
    end;
  end;
 
  if( IsCarryPlanDocs() )
    if( not CarryPlanDocuments( PaymentObj.PaymentID ) )
      MsgBox("Ошибка при помещении планируемой проводки в проведенные");
      return 1;
    end;
    // если кроме удаленной, были еще проводки - освободим резерв
    // если удаляемая проводка по к/с была плановая, то не удаляем резерв, а сохраняем
    if( ( carries.size > 1 ) and ( not ( ReserveCreator and ( ReserveCreator.CarryStatus == DOC_PLAN ) ) ) )
      PaymentObj.FreeReserve( PaymentObj.PayerAccount, PaymentObj.Chapter, PaymentObj.PayerFIID );
    end;
  end;            

  /* Отложенное создание резерва.
     Делается в случае, если удалённая проводка была проведённой */
  if( ReserveCreator and ( ReserveCreator.CarryStatus == DOC_ARH ) )
    var ErrDesc:string = "";
    stat = ReserveCreator.Create( @ErrDesc );
    if( stat )
      msgbox( ErrDesc );
      return 1;
    end;
  end;

  return 0;
end;


/* -----------------------------------------------------------------------------
   Массовое выполнение шага "Позиционирование"
   ----------------------------------------------------------------------------- */

var NewCorNumber:integer,
    NewFIID:integer,
    NewTransferDate:date,
    IsSender: string;

macro PM_MassRepositionExecute()
  
  var ErrMsg:string = "";

  var query  = "select dc.t_PaymentID, "
                      "dc.t_AccTrnID, "
                      "t.t_ID_Operation, "
                      "t.t_ID_Step "
               "from V_PMMASSOPFOREXE t, "
                    "table( PM_REPOSSTEP.GetPmCarriesForDelete() ) dc "
               "where dc.t_PaymentID = t.t_OrderID ";

  var rs:RsdRecordset = execSQLselect( query );

  while( rs.moveNext() )

    // Каждая проводка оборачивается в SAVEPOINT, чтобы если что, не откатывать все
    execSQL( "SAVEPOINT MassReposition" );

    if( not Opr_DeleteCarry( rs.value("t_AccTrnID"), rs.value("t_ID_Operation"), rs.value("t_ID_Step") ) )
      ErrMsg = "Ошибка при удалении балансовых проводок";
    end;

    if( IsCarryPlanDocs() )
      if( CB_CarryPlanDocuments( rs.value("t_PaymentID"), date(0, 0, 0), rs.value("t_ID_Operation"), rs.value("t_ID_Step") ) )
        ErrMsg = "Ошибка при помещении планируемой проводки в проведенные";
      end;
    end;            

    if( ErrMsg != "" )
      /* Если проводка неудачная, откатываемся до SAVEPOINT'а */
      execSQL( "ROLLBACK TO SAVEPOINT MassReposition" );
      /* и исключаем документ из дальнейшей обработки */
      execSQL( "update doprtemp_tmp "
                  "set t_ErrorStatus = :ErrorStatus, "
                      "t_ErrorMessage = :ErrorMessage "
                "where t_OrderID = :PaymentID",
               makeArray( SQLParam( "ErrorStatus",  1                       ),
                          SQLParam( "ErrorMessage", ErrMsg                  ),
                          SQLParam( "PaymentID",    rs.value("t_PaymentID") ) ) );
    end;
  
  end;
  
  return 0;
end;

/* -----------------------------------------------------------------------------
   Предтранзакционные действия 
   ----------------------------------------------------------------------------- */
macro PrepMassExecuteStep() 

  var p_IsCarryPlanDocs = IfThenElse( IsCarryPlanDocs(), 1, 0 );

  var stat:integer = execStoredFunc( "PM_REPOSSTEP.MassStepPrepare", V_INTEGER, makeArray( SQLParam( "p_IsSender", IsSender ),
                                                                                               SQLParam( "p_NewCorNumber", NewCorNumber ),
                                                                                               SQLParam( "p_NewFIID", NewFIID ),
                                                                                               SQLParam( "p_NewTransferDate", NewTransferDate ),
                                                                                               SQLParam( "p_IsCarryPlanDocs", p_IsCarryPlanDocs ) ) );

  
  
  if( stat )
    MemoryError( stat );
  end;

  return stat;

onerror( x )
  
  MemoryError( 1, RsbGetError( x ) );
  return 1;

end;

/* -----------------------------------------------------------------------------
   Транзакционные действия 
   Всё, что напроверяли, отражается на статусах документа, платежа, операции 
   ----------------------------------------------------------------------------- */
macro MassExecuteStep()
  
  var stat:integer = execStoredFunc( "PM_REPOSSTEP.MassStepExecute1", V_INTEGER );

  if( not stat )
    stat = PM_MassRepositionExecute();
  end;

  if( not stat )
    stat = execStoredFunc( "PM_REPOSSTEP.MassStepExecute2", V_INTEGER );
  end;

  if( stat )
    MemoryError( stat );
  end;

  return stat;

onerror( x )
  
  MemoryError( 1, RsbGetError( x ) );
  return 1;

end;

/* -----------------------------------------------------------------------------
   Действия после транзакции
   ----------------------------------------------------------------------------- */
macro PostMassExecuteStep()

  var stat:integer = execStoredFunc( "PM_REPOSSTEP.MassStepPost", V_INTEGER );

  if( stat )
    MemoryError( stat );
  end;

  return stat;

onerror( x )
  
  MemoryError( 1, RsbGetError( x ) );
  return 1;

end;
