//-----------------------------------------------------------------------------
// Блок      : Вне блока
// Шаг       : Вне шага
// Назначение: Различный функции
// Описание  : Общие для всех макросов АРМ и МБР функции
//-----------------------------------------------------------------------------
import RMInter, PTInter, CTInter,PaymInter, FIInter, BankInter, WldInter, OprInter,
"globals.mac", "rmconst.mac", oralib, likepy, "cat_acc.mac", pm_common, pm_opr;

var FL_DEBET = "Д", FL_KREDIT = "К";

const ПутьКНастройкеПроводитьЛиБухучет = "COMMON\\ПЕРЕМЕННЫЕ\\SYMB_BACK_NOT_ACCOUNTING";

//-----------------------------------------------------------------------------
// Первичный документ для счета КУ "БалКартотекаНОСТРО"
//-----------------------------------------------------------------------------
CLASS (TCommonFirstDoc) Wl_AccNostroFD( parm1 )

  MACRO InitParmArray
    ParmA[regList.registration(MC_TYPE_PARAMETR_DOCKIND   )] = 150; //DLDOC_PARTY
    ParmA[regList.registration(MC_TYPE_PARAMETR_DOCID     )] = Id;
    ParmA[regList.registration(MC_TYPE_PARAMETR_OWNER     )] = Id;

    FIRoleBArray[0] = 0;
  END;

  // Конструктор
  Id   = parm1; // ClientID
  InitTCommonFirstDoc();

  InitParmArray();
  Kind = ParmA[MC_TYPE_PARAMETR_DOCKIND];

END;

//-----------------------------------------------------------------------------
// Получить вид счета
//-----------------------------------------------------------------------------
macro PM_GetAccountKind( Account:string, FIID:integer, Chapter:integer ):string

  VAR select:string = " select acc.t_Kind_Account " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER       = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid    " +
                      "   and acc.T_ACCOUNT       = :account ";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapter ),     
                                SQLParam( "fiid",    FIID ),     
                                SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    return rset.value(0);
  end;     

  return "";
  
ONERROR(x)
  MsgBox( x.Message );
  return "";
end;
//-----------------------------------------------------------------------------

/*возвращает 1 если счет существует и он закрыт*/
macro ЗакрытЛиСчет(AccName, buff)
  FILE acc( account );
  acc.Account = AccName;
  acc.Code_Currency = 0;/*NATCUR*/
  acc.Chapter = 1;
  if ( GetEQ(acc) )
     if (acc.Open_Close != "\0")
         setparm(1, acc);
         return 1;
     end;
  end;
  return 0;
end;

/* Проверка номеров счетов на наличие в базе, если эти счета из нашего банка
 * (соответствующий Foreign...Acc == 0 )                                    */
macro IsAccountsOK( FIID, ForeignPayerAcc, Account_Payer, ForeignReceiverAcc, Account_Receiver )
  var stat = TRUE;
  if( ForeignPayerAcc == 0 )
    if( IsAccOk( Account_Payer, FIID ) == 0 )
      stat = TRUE;
    else
      stat = FALSE;
    end;
  end;

  if( ( stat == TRUE ) AND ( ForeignReceiverAcc == 0 ) )
    if( IsAccOk( Account_Receiver, FIID ) == 0 )
      stat = TRUE;
    else
      stat = FALSE;
    end;
  end;

  return stat;

end;


/* Выводим длинную строку Str в поле длиной LineWidth - StrLen( EmptyFlds ) */
/* EmptyFlds - предыдущие пустые колонки                                    */
/* LineWidth - общая длина строки отчета                                    */
macro WriteLongStr( Str, EmptyFlds, LineWidth, EndSymb )
  var i, FieldWidth = LineWidth - StrLen( EmptyFlds ) - 1, NumItems;
  array Strokes;

  macro AppendSpace( Str, Len, EndSymb )
    var slen = strlen( Str ), rstr;
    return Str + MkStr( " ", Len-slen ) + EndSymb;
  end;

  StrSplit( Str, Strokes, FieldWidth );
  println( AppendSpace( Strokes( 0 ), FieldWidth, EndSymb ) );
  i = 1;
  NumItems = Asize( Strokes );
  while( i < NumItems )
    println( AppendSpace( EmptyFlds + Strokes( i ), LineWidth - 1, EndSymb ) );
    i = i + 1;
  end;
end;


/* Читает значение SYMB_BACK_NOT_ACCOUNTING из BANK_INI */
macro Get_SYMB_BACK_NOT_ACCOUNTING()
  var err, retval;

  GetRegistryValue( ПутьКНастройкеПроводитьЛиБухучет, V_STRING, retval, err );
  if( err != 0 )
    retval = "";
  end;
  return retval;
end;

/* Определяет требуется ли проводить бухучет для платежа пришедшего */
/* бэк-офису, задаваемому символом Smb                              */
/* Возвращает TRUE если проводки делать нужно                       */
macro IsNeedInAccounting( FIID, Smb )
  var SYMB_BACK_NOT_ACCOUNTING = Get_SYMB_BACK_NOT_ACCOUNTING();

  if( strlen( Smb ) )
    if( FIID OR (Index(SYMB_BACK_NOT_ACCOUNTING, Smb)) )
      return FALSE;
    else
      return TRUE;
    end;
  else
    return TRUE;
  end;
end;

/* Определяет может ли этот платеж попадать в невыясненные */
macro IsCarryInUnknown( Smb )
  var SYMB_BACK_NOT_ACCOUNTING = Get_SYMB_BACK_NOT_ACCOUNTING();
  
  if( strlen( Smb ) )
    if( Index(SYMB_BACK_NOT_ACCOUNTING, Smb) )
      return FALSE;
    else
      return TRUE;
    end;
  else
    return TRUE;
  end;
end;

const WLPM_DIRECT_IN  = "X",
      WLPM_DIRECT_OUT = "";

macro RmMsg( str )
   if ( IsOprMultiExec()==FALSE )
      MsgBox( str );
   else
      RMMacroErrStr = String( str );
   end;
end;

/* После перевода на класс платежа - удалить */
macro CheckPayment( pmpaym, ppd, ppk )
   var CorrID, IsCB;
   File crs(corschem);

   if ( pmpaym.PayFIID==0 )

      if ( ppd.PaymentID and (ppd.IsSender=="X") )
         if ( ppd.OurCorrID<=0 )
            ClearRecord(crs);
            crs.FI_Kind=1;
            crs.FIID = ppd.PayFIID;
            crs.Number = ppd.Corschem;
            if ( not getEQ(crs) )
               msgBox("Не найдена корсхема");
               return false;
            end;
            CorrID = crs.CorrID;
         else
            CorrID = ppd.OurCorrID;
         end;
      else
         if ( ppk.OurCorrID<=0 )
            ClearRecord(crs);
            crs.FI_Kind=1;
            crs.FIID = ppk.PayFIID;
            crs.Number = ppk.Corschem;
            if ( not getEQ(crs) )
               msgBox("Не найдена корсхема");
               return false;
            end;
            CorrID = crs.CorrID;
         else
            CorrID = ppk.OurCorrID;
         end;
      end;

     if( IsBankType(CorrID, PT_KIND_PAYM_CASH_CENTRE ) or
          IsBankType(CorrID, PT_KIND_FIELDOFFICE_CENTRALBANK) )
         IsCB = 1;
      else
         IsCB = 0;
      end;

     if ( pmpaym.Payer AND ВидСубъекта(pmpaym.Payer, PTK_BANK) )
        /* Банковский */
        if ( ppd.PaymentID and (ppd.IsSender=="X") and (ppd.TransferDate>{curdate}) )
           /* Кредитовка */
           if ( IsCB )
               msgBox("Входящее банковское поручение, проходящее через ЦБ,|должно быть обработано текущим днем");
               return false;
           end;
        elif ( ppk.PaymentID and (ppk.IsSender=="X") and (ppk.TransferDate>{curdate}) )
           /* Дебетовка */
           msgBox("Входящее банковское требование|должно быть обработано текущим днем");
           return false;
        end;
     else
        /* Клиентский */
        if ( ppd.PaymentID and (ppd.IsSender=="X") and (ppd.TransferDate>{curdate}) )
           /* Кредитовка */
           if ( not IsCB )
              msgBox("Входящее клиентское поручение, не проходящее через ЦБ,|должно быть обработано текущим днем");
              return false;
           end;
        end;
     end;
  end;

  return true;
end;

macro CheckPaymentObj( PaymentObj:RsbPayment )
   var CorrID, IsCB;
   File crs(corschem);

   if ( PaymentObj.ReceiverFIID==0 )

      if ( PaymentObj.IsCredit() )
         if ( PaymentObj.PayerOurCorrID<=0 )
            ClearRecord(crs);
            crs.FI_Kind=1;
            crs.FIID = PaymentObj.BaseFIID;
            crs.Number = PaymentObj.InCorschem;
            if ( not getEQ(crs) )
               msgBox("Не найдена корсхема");
               return false;
            end;
            CorrID = crs.CorrID;
         else
            CorrID = PaymentObj.PayerOurCorrID;
         end;
      else
         if ( PaymentObj.ReceiverOurCorrID<=0 )
            ClearRecord(crs);
            crs.FI_Kind=1;
            crs.FIID = PaymentObj.BaseFIID;
            crs.Number = PaymentObj.InCorschem;
            if ( not getEQ(crs) )
               msgBox("Не найдена корсхема");
               return false;
            end;
            CorrID = crs.CorrID;
         else
            CorrID = PaymentObj.ReceiverOurCorrID;
         end;
      end;

     if( IsBankType(CorrID, PT_KIND_PAYM_CASH_CENTRE ) or
          IsBankType(CorrID, PT_KIND_FIELDOFFICE_CENTRALBANK) )
         IsCB = 1;
      else
         IsCB = 0;
      end;

     if ( PaymentObj.Payer AND ВидСубъекта(PaymentObj.Payer, PTK_BANK) )
        /* Банковский */
        if ( PaymentObj.IsCredit and (PaymentObj.InTransferDate>{curdate}) )
           /* Кредитовка */
           if ( IsCB )
               msgBox("Входящее банковское поручение, проходящее через ЦБ,|должно быть обработано текущим днем");
               return false;
           end;
        elif ( (not PaymentObj.IsCredit) and (PaymentObj.InTransferDate>{curdate}) )
           /* Дебетовка */
           msgBox("Входящее банковское требование|должно быть обработано текущим днем");
           return false;
        end;
     else
        /* Клиентский */
        if ( PaymentObj.IsCredit and (PaymentObj.InTransferDate>{curdate}) )
           /* Кредитовка */
           if ( not IsCB )
              msgBox("Входящее клиентское поручение, не проходящее через ЦБ,|должно быть обработано текущим днем");
              return false;
           end;
        end;
     end;
  end;

  return true;
end;


//заполняет строку нужными символами до нужной длины слева
macro zfill(Строка, Символ, Длина)
    while(strlen(Строка) < Длина)
       Строка = Символ + Строка;
    end;
    return Строка;
end;


/*
ищет среди открытых лоро-корсхем 
возвращает номер и валюту и ид корреспондента
*/
macro НайтиКорсхемуПоКорсчету(Корсчет, Номер, Валюта, Корреспондент )
  var rs:object;
  var select:string;
  var params:TArray;

  select = "select cors.t_Number, cors.t_FIID, cors.t_CorrID from dcorschem_dbt cors where "+
                            "cors.t_CorAccount = :CorS and cors.t_IsNostro = chr(0)"+
                            " and cors.t_State = 0 and cors.t_FI_Kind = 1";
  params = makeArray( SQLParam("CorS", Корсчет));
  rs = execSQLselect( select, params, FALSE );
  if( rs.MoveNext() )
      SetParm(1, rs.value(0));
      SetParm(2, rs.value(1));
      SetParm(3, rs.value(2));
    return 0;
  else
    return 1;
  end;
end;


macro ПолучитьИмяСубъекта(ID)
   var Name = "";
   record party(party);
   if(not ПолучитьСубъекта(ID, party))
      Name = party.Name;
   end;
   return Name;
end;

macro ПолучитьЛюбойКодСубъекта(ИД, КодПоУмолчанию)
   var Код = "", Error = 0;
   var rs:object;
   var select:string;
   var params:TArray;

   Код = ПолучитьКодСубъекта(ИД, КодПоУмолчанию, Error);
   if(Error)

      select = "select t_code, t_codekind from dobjcode_dbt where t_objectid = :ID and t_ObjectType =:OBJTYPE_PARTY and t_state = 0";
      params = makeArray( SQLParam("ID", ИД),
                          SQLParam("OBJTYPE_PARTY", OBJTYPE_PARTY));
      rs = execSQLselect( select, params, FALSE );
      if( rs.MoveNext() )
          Код = rs.value(0);
          SetParm(1, rs.value(1));
      end;
   end;
   return Код;
end;

macro ПолучитьФилиал( BankID )
  var select:string = "select dep.t_Code from ddp_dep_dbt dep " +
                      " where dep.t_PartyID = :BankID " +
                        " and dep.t_status <> 3";
  var params:TArray = makeArray( SQLParam("BankID", BankID));
  var rs:object = execSQLselect( select, params, FALSE );

  if( rs.moveNext() )
     return rs.value(0);
  end;
  return -1;
end;

macro ПолучитьФилиалСчета(Счет, Филиал)
   file account(account);
   account.Account = Счет;
   account.Chapter = 1;
   if (not(GetEQ(account)))
     return 1;
   end;
   SetParm(1, account.Department);
   return 0;
end;

macro ПолучитьОсновнойКодСубъектаДляТранспорта(ИД, Транспорт, Код, Значение)
   var rs:object;
   var select:string;
   var params:TArray;

   select = "select objcode.t_code, objcode.t_codekind from dobjcode_dbt objcode,"+ 
                  " dwltpcode_dbt tpcode where objcode.t_objectid = :ID and objcode.t_objectType =:OBJTYPE_PARTY and objcode.t_state = 0"+
                  " and tpcode.t_TpID =:Trans and tpcode.t_Primary =:CHAR1"+
                  " and objcode.t_codekind = tpcode.t_codekind" ;
  params = makeArray( SQLParam("ID", ИД),
                      SQLParam("OBJTYPE_PARTY", OBJTYPE_PARTY),
                      SQLParam("Trans", Транспорт),
                      SQLParam("CHAR1", SET_CHAR));
  rs = execSQLselect( select, params, FALSE );

   if( rs.MoveNext() )
       SetParm(2, rs.value(1));
       SetParm(3, rs.value(0));
       return 0;
   end;
   return 1;
end;

macro ПолучитьОсновнойТипКодаДляТранспорта(Транспорт, Код)
   var rs:object;
   var select:string;
   var params:TArray;

   select = " select tpcode.t_codekind from "+ 
            " dwltpcode_dbt tpcode where "+
            " tpcode.t_TpID =:Trans and tpcode.t_Primary = :CHAR1";
   params = makeArray( SQLParam("Trans", Транспорт),
                       SQLParam("CHAR1", SET_CHAR));
   rs = execSQLselect( select, params, FALSE );

   if( rs.MoveNext() )
       SetParm(1, rs.value(0));
       return 0;
   end;
   return 1;
end;

macro НайтиКорсхему(Ид, Валюта, Буфер)
   File cors(corschem) key 0;
   cors.Number  = Ид;
   cors.FIID    = Валюта;
   cors.State   = 0;
   cors.FI_Kind = FIKIND_CURRENCY;
   if ( GetEQ(cors) )
      copy(Буфер, cors);
      return 0;
   end;

   return 1;
end;

macro GetDKFlag( debet, credit )
    if ( (debet.PaymentID) and (debet.group==PAYMENTS_GROUP_EXTERNAL) )
       if ( debet.IsSender=="X")
          return FL_KREDIT;
       else
          return FL_DEBET;
       end;
    elif ( (credit.PaymentID) and (credit.group==PAYMENTS_GROUP_EXTERNAL) )
       if ( credit.IsSender!="X")
          return FL_KREDIT;
       else
          return FL_DEBET;
       end;
    else
       return "";
    end;
end;

macro IsTransitPaym( debet, credit )
    if ( (valtype(debet)==V_UNDEF) OR
         (valtype(credit)==V_UNDEF) )
       return false;
    end;
    if ( debet.PaymentID and (debet.group==PAYMENTS_GROUP_EXTERNAL) and 
         credit.PaymentID and (credit.group==PAYMENTS_GROUP_EXTERNAL) )
       return true;
    end;
    return false;
end;
/*дополнительно к сообщению об ошибке добавляется сообщение о
системной ошибке если оно есть*/
macro РасширенноеСообщениеОбОшибке( Msg:String )

    var Str = GetErrMsg();
    if(Str)
       Str = Msg + ": " + Str;
    else
       Str = Msg;
    end;

    MsgBox(Str);
end;

//-----------------------------------------------------------------------------
//  Проверить, существует ли счет в базе
//-----------------------------------------------------------------------------
macro СчетОткрыт( FIID:integer, Account:string, Chapter:integer, Type_Account:string, Department:@integer ):bool
  
  VAR select:string = " select acc.t_type_account, acc.t_department " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account "+
                      "   and acc.T_Open_Close = chr(0)";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapter ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    SetParm( 3, rset.value(0) );
    Department = rset.Value(1);
    return true;
  end;     
  return false;
  
ONERROR(x)
  MsgBox( x.Message );
  return false;
end;

//-----------------------------------------------------------------------------
// Счет существует и закрыт
//-----------------------------------------------------------------------------
macro СчетЗакрыт( FIID:integer, Account:string, Chapter:integer, Department:@integer ):bool
  
  Department = -1;
  VAR select:string = " select acc.t_department " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account "+
                      "   and acc.T_Open_Close > chr(0)";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapter ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    Department = rset.Value(0);
    return true;
  end;     
  return false;
  
ONERROR(x)
  MsgBox( x.Message );
  return false;
end;

//-----------------------------------------------------------------------------
// Получить тип счёта
//-----------------------------------------------------------------------------
private macro GetTypeAccount(account, chapter, FIID):string
  var rset:object;
  var select:string;

  select = " SELECT t_type_account"
            " FROM daccount_dbt "
            " WHERE t_account = ? AND "
            "       t_chapter = ? AND "
            "       t_code_currency = ?  ";

  var params:TArray = makeArray( SQLParam( "", account ),
                                 SQLParam( "", chapter ),
                                 SQLParam( "", FIID )
                               ); 


  rset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    return rset.value(0);
  else
    return "";
  end;

end;



//-----------------------------------------------------------------------------
// Проверка наличия необходимых средств на счёте ЛОРО
//-----------------------------------------------------------------------------
macro CheckLoroAccRest( Payment:RsbPayment ):bool
  
  record cors(corschem);
  var Rest :money   = $0;
  var TypeCorrAcc = "";
  
  // Найти входящую корсхему
  if( НайтиКорсхему( Payment.InCorschem, Payment.BaseFIID, cors ) )
    msgBox("Не найдена входящая корсхема");
    return 1;
  end;
  
  TypeCorrAcc = GetTypeAccount(cors.Account, CHAPT1, cors.FIID);
  //#138339 Если счёт парный или сворачиваемый, то проверки остатка не производим
  if( not( (Index(TypeCorrAcc, "N")>0) or (Index(TypeCorrAcc, "Ш")>0) ) ) 
      // Проверить свободный остаток
      AccGetFreeAmount( Rest, NULL, cors.Account, CHAPT1, cors.FIID, {curdate}, Payment.Priority, Payment.ClaimID );

      if( СчетПассивный(cors.Account, CHAPT1, cors.FIID) )
        if( Rest - Payment.FuturePayerAmount > cors.MinLimit )
          return true;
        else
          return false;
        end;
      elif( СчетАктивный(cors.Account, CHAPT1, cors.FIID) )
        if( (cors.MaxLimit == 0) or (Rest - Payment.FuturePayerAmount > cors.MaxLimit) )
          return true;
        else
          return false;
        end;
      end;
  end;

  return true;

end;

// проверка на вхождение в ТС
macro InTS( PartyID:integer ):bool
  var rs : RsdRecordset,
  Query: string = " SELECT * "+
                    " FROM ddp_dep_dbt dp "+
                   " WHERE dp.t_PartyID = :PartyID ",
  params: TArray = makeArray( SQLParam( "PartyID", PartyID  ) );

  return existsSQLselect( Query, params );
end;

//-----------------------------------------------------------------------------
// Платёж может быть помещён в картотеку невыясненных?
//-----------------------------------------------------------------------------
macro PM_CanBePlacedToUnknown( Payment:RsbPayment, Reason:@string ):bool

  var DocKind   :integer = Payment.DocKind,
      DocumentID:string  = string( Payment.PaymentID:o:34 );
  
  if( DocKind == 322 )
    DocKind = 320;
  end;
  
  Reason = "";

  var statusControl:integer,
      statusIndex  :integer;

  if( ( not PM_GetOprStatus( DocKind, DocumentID, OPR_PAYM_CONTROL, @statusControl ) ) or
      ( not PM_GetOprStatus( DocKind, DocumentID, OPR_PAYM_INDEX,   @statusIndex   ) ) )
    return false;
  end;

  if( ( statusControl != OPR_PAYM_ST_CTRL_CONTROL ) or
      ( ( statusIndex != OPR_PAYM_ST_INDEX_NO       ) and
        ( statusIndex != OPR_PAYM_ST_INDEX_UNKNOWN  ) ) ) 
    Reason = "Состояние платежа не допускает его перенос в картотеку невыясненных сумм";
    return false;
  end;

  if( Payment.Purpose == PM_PURP_MULTI )
    Reason = "Не допускает перенос в картотеку невыясненных сумм сводных платежей";
    return false;
  end;

  return true;
end;

//----------------------------------------------------------------------------
//Проверить наличие в картотеке ЛОРО счета документов к тому же корсчету ЛОРО с более высоким или таким же приоритетом
//----------------------------------------------------------------------------
macro UnpaidDocIsExist( Account:string, Priority:integer, Искать_С_РавнымПриоритетом:bool ):bool
  var SelectStr:string;
  var params   :TArray;
  var rs       :object;
  var sign     :string;
  
  if( Искать_С_РавнымПриоритетом )
    sign = "<=";
  else
    sign = "<";
  end;

  SelectStr = "select pm.t_PaymentID " +
              "  from dpmpaym_dbt pm, "
                    " dpmrmprop_dbt rm, "
                    " doproper_dbt opr, "
                    " doprcurst_dbt curst," +
                    " doprstep_dbt step" +
              " where rm.t_PaymentID = pm.t_PaymentID " +
                " and opr.t_DocumentID = lpad(pm.t_PaymentID, 34, '0') " +
                " and curst.t_ID_Operation = opr.t_ID_Operation " +
                " and curst.t_StatusKindID = :StatusKindID " +
                " and curst.t_NumValue = :NumValue " +
                " and pm.t_FuturePayerAccount = :FuturePayerAccount " +
                " and opr.t_DocKind in (:DocKind_1, :DocKind_2, :DocKind_3, :DocKind_4, :DocKind_5) " +
                " and step.t_ID_Operation = opr.t_ID_Operation " +
                " and step.t_IsExecute = 'R' " +
                " and step.t_Symbol = 'Л' ";
  SelectStr = SelectStr + " and rm.t_Priority " + sign + " :Priority ";

  params = makeArray( SQLParam("StatusKindID", OPR_PAYM_INDEX),
                      SQLParam("NumValue",     OPR_PAYM_ST_INDEX_LORO),
                      SQLParam("FuturePayerAccount", Account),
                      SQLParam("DocKind_1", WL_INDOC),
                      SQLParam("DocKind_2", DLDOC_MEMORIALORDER),
                      SQLParam("DocKind_3", CB_MULTYDOC),
                      SQLParam("DocKind_4", DLDOC_SUMMARY_MEMORDER),
                      SQLParam("DocKind_5", DLDOC_BANKORDER),
                      SQLParam("Priority", Priority)
                    );

  return existsSQLselect( SelectStr, params );
end;

macro ValueDateForRmPosition(Paym : RsbPayment, Corschem) : date
  var ValueDate : date = {curdate};
  var DocKind = Paym.PrimDocKind;
  record cors(corschem);
  Copy(cors, Corschem);

  if( GetParentOrEqualDocKindFromList(DocKind, PMDOC_BANKPAYMENT, PMDOC_BANKCLAIM) )
    ValueDate = PM_GetOperDay_Balance(cors.Department);
  elif( GetParentOrEqualDocKindFromList(DocKind, PMDOC_CLIENTPAYMENT) )
    if( Paym.StartDepartment == Paym.Department )
      ValueDate = PM_GetOperDay_BankServiceBalance(cors.Department);
    else
      ValueDate = PM_GetOperDay_Balance(cors.Department);
    end;
  end;

  return ValueDate;
end;

