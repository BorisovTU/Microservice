	//-----------------------------------------------------------------------------------------
// á†Ø„·™ ™Æ≠¢•‡‚†Ê®®
// Ç. ÉÆ‡´•≠™Æ
//-----------------------------------------------------------------------------------------
import bankinter, oralib, likepy, rsexts, rcw;

const impPath       = MergeFile (SplitFile (moduleFileName ()), "import"),
      logPath       = MergeFile (SplitFile (moduleFileName ()), "log"),
      numberModule  = 100,
      userpwd       = "1 1q2w3e",
      fldNameExist  = TRUE,
      impMask       = "*.csv",
      delim         = ";", //strFor (1),
      encode        = "lcansi";//"lcoem";


Private var rsdErrorCount = 0, rsdErrText, rsdOraString;

GenObject ("CConvert").run ();
exit (1);
//-----------------------------------------------------------------------------------------

Macro getLastRSDError ()
    return rsdErrText;
End;
//-----------------------------------------------------------------------------------------

Private macro timeShiftToStr ( dttm1, dttm2 )
    Var d1, d2, t1, t2, res = "", days, hh, mm, ss, tm;
    DtTmSplit (dttm1, d1, t1);
    DtTmSplit (dttm2, d2, t2);
    days = d2-d1;

    if ( t1 > t2 )
        days = days - 1;
        tm = time (23, 59, 59)-(t1-t2)+time (0, 0, 1);
    else
        tm = t2-t1;
    end;
    timeSplit (tm, hh, mm, ss);

    if ( days > 0 )
        return days + "§. " + hh + "Á. " + mm + "¨. " + ss + "·.";
    elif ( hh > 0 )
        return hh + "Á. " + mm + "¨. " + ss + "·.";
    elif ( mm > 0 )
        return mm + "¨. " + ss + "·.";
    elif ( ss > 0 )
        return ss + "·.";
    else
        return "0c.";
    end;
End;
//-----------------------------------------------------------------------------------------

Macro myExecSQL ( sqltext, params )
    rsdErrText = "";
    if ( sqltext == NULL ) sqltext = rsdOraString; end;
    var cmd:RsdCommand = RsdCommand (sqltext), i = 0;
    cmd.NullConversion = false;

    while ( params and (i < params.size) )
        cmd.addParam (params [i].name, params [i].type, params [i].value);
        i = i + 1;
    end;

    cmd.execute ();
    return cmd;
OnError 
    if ( rsdErrorCount >= cmd.connection.environment.ErrorCount ) rsdErrorCount = 0; end;
    while ( rsdErrorCount < cmd.connection.environment.ErrorCount )
        rsdErrText = rsdErrText + ifThenElse (rsdErrText, "\n", "") + cmd.connection.environment.error (rsdErrorCount).descr;
        rsdErrorCount = rsdErrorCount + 1;
    end;
End;
//-----------------------------------------------------------------------------------------

Macro nullDate ( dt )
    if ( valType (dt) == V_STRING )
        return date (0,0,0);
    end;
    return dt;
End;
//-----------------------------------------------------------------------------------------

Macro rsdStartCapture
    rsdOraString = "";
    SetOutHandler ("rsdCapture");
End;
//-----------------------------------------------------------------------------------------

Macro rsdEndCapture
    SetOutHandler ();
End;
//-----------------------------------------------------------------------------------------

Macro rsdCapture ( str )
    rsdOraString = String (rsdOraString, " ", str);
End;
//-----------------------------------------------------------------------------------------

Private class CConvert
    Private var doc;

    Private macro openCmdFile ()
        Var fName = MergeFile (SplitFile (moduleFileName ()), "convert", "cnv");
        doc = TStreamDoc (fName, "R", "rsoem");
        return true;
    onError
        return false;
    End;
    
    Macro destructor ()
        doc = NULL;
    End;
    
    Private macro runTerminal ( numProc, fName, mac, line1, line2, logName, procSize )
        file prm () txt write;
        open (prm, mergeFile (splitFile (getWorkFileName ("0")), "cnvparm", string (numproc)));
        insert (prm, "FILENAME="+fname);
        insert (prm, "MAC="+mac);
        insert (prm, "LINE1="+line1);
        insert (prm, "LINE2="+line2);
        insert (prm, "LOGNAME="+mergeFile (logPath, logName+"_"+numProc, "log"));
        insert (prm, "PROCSIZE="+procSize);
        close (prm);

        Var fso = CreateObject("rsax", "TRsAxServer", "FmAxServer", false).CreateComObject ("scripting.fileSystemObject");
        Var src = fso.openTextFile (mergeFile (getCurDir (true), "term.ini"));
        Var dst = fso.createTextFile (mergeFile (getCurDir (true), "term"+numProc+".ini"));
        while ( not src.atEndOfStream )
            Var str = src.readLine ();
            if ( index (str, "PROGRAM") == 1 )
                 str = "PROGRAM = startbnk.exe "+userpwd+" /modnum:131 /exec:"+numberModule+" /num:"+numProc;
            end;
            if ( substr (str, 1, 1) != ";" )
               dst.writeLine (str);
            end;
        end;

        src = dst = fso = NULL;

        if ( StartProg ("$"+mergefile (getcurdir (true), "termw.exe"), "-cterm"+numProc+".ini") == 0 )
            while ( not execSqlSelect ("select 1 from v$session where client_info = :1", makeArray (sqlParam ("1", "m:"+mac+"_"+numProc))).moveNext () )
               testEvent (100);
            end;
        end;

    End;

    Private macro runMultyProc ( numProc, module, modname )
        Var fName, logName, start;

        if ( not selectFile (fName, mergeFile (impPath, impMask)) )
            return FALSE;
        end;

        splitFile (fName, logName);
        logName = String (logName, date ():f, "_", time ());
        logName = trim (strsubst (strsubst (logName, ":", ""), " ", "0"));

        start = DtTm (Date (), Time ());
        setOutput (mergeFile (logPath, logName, "log"));
        [å„´Ï‚®ØÆ‚ÆÁ≠Æ• ¢ÎØÆ´≠•≠®•];
        [#] (modName);
        [ ];
        [î†©´: #] (fName);
        [########## ########] (date (), time ());

        Var doc = TStreamDoc (fName, "R", encode),
            size = TDirList (fName, "F").size (0),
            line1 = 1, line = 0, xSize = 0, str, runProc = 0,
            procSize = size/numProc;

        begAction (100, "å≠Æ£ÆØÆ‚ÆÁ≠Æ• ¢ÎØÆ´≠•≠®•");
        ExecMacroFile (MergeFile (SplitFile (moduleFileName ()), module), "preStep");

        changeAction ("èÆ§£Æ‚Æ¢™† §†≠≠ÎÂ §´Ô ØÆ‚Æ™† ¸ "+(runProc+1));
        while ( doc.readLine (@str) )
            xSize = xSize + strlen (str) + 2;
            line = line + 1;
            /*while ( (substr (trim (str), strlen (trim (str))) != delim) and doc.readLine (@str) )
                line = line + 1;
                xSize = xSize + strlen (str) + 2;
            end;*/
            if ( xSize >= procSize )
                runProc = runProc + 1;
                xSize = 0;
                runTerminal (runProc, fName, module, line1, line, logName, procSize);
                changeAction ("èÆ§£Æ‚Æ¢™† §†≠≠ÎÂ §´Ô ØÆ‚Æ™† ¸ "+(runProc+1));
                line1 = line + 1;
                if ( runProc == numProc-1 )
                    changeAction ("èÆ§£Æ‚Æ¢™† §†≠≠ÎÂ §´Ô ØÆ‚Æ™† ¸ "+numProc);
                    runTerminal (runProc+1, fName, module, line1, 0, logName, procSize);
                    break;
                end;
            end;
        end;
        while ( true )
            testEvent (2000);
            Var sql = execSqlSelect ("select count (1) from v$session where client_info like :1||'%'", makeArray (sqlParam ("1", "m:"+module)));
            sql.moveNext ();
            if ( int (sql.value (0)) == 0 )
                break;
            end;
            changeAction ("ÇÎØÆ´≠Ô•‚·Ô ØÆ‚Æ™Æ¢ "+int (sql.value (0)));
        end;

        ExecMacroFile (MergeFile (SplitFile (moduleFileName ()), module), "postStep");

        endAction ();
        [é°È•• ¢‡•¨Ô ¢ÎØÆ´≠•≠®Ô #] (timeShiftToStr (start, DtTm (date (), time ())));
        [
         ⁄ƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
         ≥èÆ‚Æ™≥ ëÆ ·‚‡Æ™® ≥ èÆ ·‚‡Æ™„ ≥      è‡Æ§Æ´¶®‚•´Ï≠Æ·‚Ï     ≥                   è‡Æ‚Æ™Æ´                  ≥         ç•Æ°‡†°Æ‚†≠≠Î• ß†Ø®·®        ≥
         √ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥];

        file rez () txt;
        Var ok, line2, long, error;
        for ( Var x, 1, numProc, 1 )
            ok = false;
            line1 = line2 = long = error = "";
            if ( open (rez, mergeFile (splitFile (getWorkFileName ("0")), "cnvparm", string (x))) )
                while ( next (rez) )
                    if ( index (rez.str, "RESULT") == 1 )
                        ok = true;
                    elif ( index (rez.str, "LINE1=") == 1 )
                        line1 = strSubst (rez.str, "LINE1=", "");
                    elif ( index (rez.str, "LINE2=") == 1 )
                        line2 = strSubst (rez.str, "LINE2=", "");
                    elif ( index (rez.str, "LONG=") == 1 )
                        long = strSubst (rez.str, "LONG=", "");
                    elif ( index (rez.str, "ERROR=") == 1 )
                        error = strSubst (rez.str, "ERROR=", "");
                    end;
                end;
                close (rez);
                delFile (mergeFile (splitFile (getWorkFileName ("0")), "cnvparm", string (x)));
            end;
            [≥#####≥###########≥###########≥############################≥#############################################≥######################################≥]
            (x, line1, ifThenElse (int (line2), line2, "™Æ≠•Ê"), ifThenElse (ok, long, "≠• ¢ÎØÆ´≠•≠"), logName+"_"+x:w, error:w);
        end;
        [¿ƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ];
        viewFile (setOutput ());
    End;

    Macro run ()
        file parm () txt;
        var mac, fname, num, linestart, lineend, logName, procSize;
        if ( getCmdLineParm ("num", num, V_STRING) )
            open (parm, mergeFile (splitFile (getWorkFileName ("0")), "cnvparm", string (num)));

            while ( next (parm) )
                if ( index (parm.str, "FILENAME=") == 1 )
                    fname = strSubst (parm.str, "FILENAME=", "");
                elif ( index (parm.str, "MAC=") == 1 )
                    mac = strSubst (parm.str, "MAC=", "");
                elif ( index (parm.str, "LOGNAME=") == 1 )
                    logName = strSubst (parm.str, "LOGNAME=", "");
                elif ( index (parm.str, "LINE1=") == 1 )
                    linestart = int (strSubst (parm.str, "LINE1=", ""));
                elif ( index (parm.str, "LINE2=") == 1 )
                    lineend = int (strSubst (parm.str, "LINE2=", ""));
                elif ( index (parm.str, "PROCSIZE=") == 1 )
                    procSize = int (strSubst (parm.str, "PROCSIZE=", ""));
                end;
            end;
            close (parm);

            if ( not ExistFile (MergeFile (SplitFile (moduleFileName ()), mac)) )
                MsgBox ("ç• ≠†©§•≠ ‰†©´ "+mac);
                return;
            end;
            myExecSql ("begin dbms_application_info.set_client_info (:1); end;", makeArray (sqlParam ("1", "m:"+mac+"_"+num)));
            ExecMacroFile (MergeFile (SplitFile (moduleFileName ()), mac), "runProc", fname, num, linestart, lineend, logName, procSize);
            TdirList ().remove ("$"+mergefile (getcurdir (true), "term"+num+".ini"), "F");
            return;
        end;

        if ( not openCmdFile () )
            MsgBox ("ç•¢Æß¨Æ¶≠Æ Æ‚™‡Î‚Ï „Ø‡†¢´ÔÓÈ®© ‰†©´");
            return FALSE;
        end;

        Var str, moduleNames = TArray (), modules = TArray (), procnum = TArray (), i, n, nProc;
        while ( doc.ReadLine (@str) )
            str = trim (str);
            if ( (SubStr (str, 1, 2) != "--") and (i = index (str, " ")) )
                n = SubStr (str, 1, i-1);
                if ( StrIsNumber (n) )
                    procnum [procnum.Size] = int (SubStr (str, 1, i-1));
                    str = SubStr (str, i+1);
                    i = index (str, " ");
                    modules [modules.Size] = SubStr (str, 1, i-1);
                    moduleNames [moduleNames.Size] = SubStr (str, i+1);
                else
                    procnum [procnum.Size] = 0;
                    modules [modules.Size] = SubStr (str, 1, i-1);
                    moduleNames [moduleNames.Size] = SubStr (str, i+1);
                end;
            end;
        end;

        i = 0;

        while ( (i = menu (moduleNames, NULL, "á†Ø„·™", NULL, NULL, i)) >= 0 )
            nProc = procNum [i];
            if ( not ExistFile (MergeFile (SplitFile (moduleFileName ()), modules [i])) )
                MsgBox ("ç• ≠†©§•≠ ‰†©´ ", MergeFile (SplitFile (moduleFileName ()), modules [i]));
            elif ( (nProc > 1) and getInt (nProc, "èÆ§‚¢•‡§®‚• ™Æ´®Á•·‚¢Æ ØÆ‚Æ™Æ¢", 2) and (nProc > 1) )
                runMultyProc (nProc, modules [i], moduleNames [i]);
            elif ( selectFile (fName, mergeFile (impPath, impMask)) )
                ExecMacroFile (MergeFile (SplitFile (moduleFileName ()), modules [i]), "preStep");
                ExecMacroFile (MergeFile (SplitFile (moduleFileName ()), modules [i]), "runMigration", fName);
                ExecMacroFile (MergeFile (SplitFile (moduleFileName ()), modules [i]), "postStep");
            end;
        end;
    End;
End;
//-----------------------------------------------------------------------------------------

Class CImpCommon
    Private var fName, doc, fSize = 0, processSize = 0, data = "", error = FALSE, errorStr = "", line = 0, errFile;
    Private var leftPaperKind = MakeArray ("02","03","04","05","06","07","09","1","10","11","12","13","14","2","22","26","27","3","91","MigratoryC","OTHERDOC","OtherStayI","PasportDN1","PasportDN2","PasportDN3","PasportDN4","PasportDN5","Registr","TaxInspReg","TaxReg","TmpRegistr","uncitizen","ÇÆ§è‡†¢†","è†·ØÆ‡‚","è†·ØÆ‡‚_êî","è†·ØÆ‡‚ëëê","ë‚„§Å®´•‚", "0", "5", "6", "18"),
                rsPaperKind   = MakeArray (6,   4,   1,   9,   3,   2,   10,  101, 11,  12,  5,   13,  14, 102,6,   15,  16,  103,18,  23,          21,        25,          19,          104,         105,          106,         7,          107,       108,        109,     20,          21,         110,       0,        0,           7,            111,         0,   5,   6,   18 );

    Private var startTime = DtTm (date (), time ());
    Private var processNumber;
	Private var NeedUpdate = false;

    Private macro setLog
        Var name;
        splitFile (fName, name);
        name = String (name, date ():f, "_", time ());
        name = trim (strsubst (strsubst (name, ":", ""), " ", "0"));
        name = mergeFile (logPath, name, "log");
        setOutput (name);
    End;
    
    Private macro openFile (namefile)
        if ( (namefile == NULL) and (not selectFile (fName, mergeFile (impPath, impMask))) )
            return FALSE;
        elif ( namefile )
            fName = namefile;
        end;
        doc = TStreamDoc (fName, "R", encode);
        fSize = TDirList (fName, "F").size (0);
        return TRUE;
    OnError
        return FALSE;
    End;

    Private macro fldMandatory ( val )
        return trim (val) != "";
    End;

    Private macro fldIsNumber ( val )
        if ( ExecSqlSelect ("select 1 from dual where translate (:1, '_0123456789', '_') is null", MakeArray (SqlParam ("1", val))).MoveNext () )
		    if ((int(val) == 2147483647) or (int(val) == -2147483647))
			  SetParm (1, numeric(val));
			else
              SetParm (1, int (val));
			end;
            return TRUE;
        end;
        return FALSE;
    End;
	
	
    Private macro fldIsMoney ( val )
        if ( ExecSqlSelect ("select 1 from dual where translate (:1, '_0123456789-.', '_') is null", MakeArray (SqlParam ("1", val))).MoveNext () )
            SetParm (1, money (val));
            return TRUE;
        end;
        return FALSE;
    End;
	
    Private macro fldIsMoney2 ( val )
	    val = strsubst(val, " ", "");
        if ( ExecSqlSelect ("select 1 from dual where translate (:1, '_0123456789-,', '_') is null", MakeArray (SqlParam ("1", val))).MoveNext () )
	    val = strsubst(val, ",", ".");
            SetParm (1, money (val));
            return TRUE;
        end;
        return FALSE;
    End;


    Private macro fldIsBool ( val, fill )
        if ( not inList (strupr (val), "ÑÄ", "çÖí", "1", "0") )
            return FALSE;
        end;
        if ( not ((valType (fill) == V_BOOL) and (fill == FALSE)) )
            setparm (1, inList (strupr (val), "ÑÄ", "1"));
        end;
        return TRUE;
    End;

    Private macro fldIsDate ( val )
        if ( (val == NULL) or (val == "") or (val == "00.00.0000") )
            setParm (1, zeroValue (V_DATE));
            return TRUE;
        end;
        Var dd, mm, yy, i;

        if ( strIsNumber (val) and (strlen (val) == 8) )
            dd = int (substr (val, 7));
            mm = int (substr (val, 5, 2));
            yy = int (substr (val, 1, 4));
            if ( (yy == 1900) and (mm == 1) and (dd == 1) )
                dd = mm = yy = 0;
            end;
        else
            val = trim (strsubst (val, "/", "."));
            if ( (i = index (val, ".")) == 0 )
                return FALSE;
            end;
            dd = int (substr (val, 1, i-1));
            val = substr (val, i+1);
            if ( (i = index (val, ".")) == 0 )
                return FALSE;
            end;
            mm = int (substr (val, 1, i-1));
            yy = int (substr (val, i+1));
            if ( yy < 100 ) yy = yy + 2000; end;
        end;
        setParm (1, date (dd, mm, yy));
        return TRUE;    
    onError
        return FALSE;
    End;

    Private macro fldIsDateYMD ( val )
        if ( (val == NULL) or (val == "") or (strupr(val) == "NULL") or (val == "0000.00.00") )
            setParm (1, zeroValue (V_DATE));
            return TRUE;
        end;
        Var dd, mm, yy, i;

        if ( strIsNumber (val) and (strlen (val) == 8) )
            dd = int (substr (val, 7));
            mm = int (substr (val, 5, 2));
            yy = int (substr (val, 1, 4));
            if ( (yy == 1900) and (mm == 1) and (dd == 1) )
                dd = mm = yy = 0;
            end;
        else
            val = trim (strsubst (val, "-", "."));
            if ( (i = index (val, ".")) == 0 )
                return FALSE;
            end;
            yy = int (substr (val, 1, i-1));
            val = substr (val, i+1);
            if ( (i = index (val, ".")) == 0 )
                return FALSE;
            end;
            mm = int (substr (val, 1, i-1));
            dd = int (substr (val, i+1));
            if ( yy < 100 ) yy = yy + 2000; end;
        end;
        setParm (1, date (dd, mm, yy));
        return TRUE;    
    onError
        return FALSE;
    End;

    Private macro fldIsTime ( val )
        if ( (val == NULL) or (val == "") )
            setParm (1, zeroValue (V_TIME));
            return TRUE;
        end;
        Var hh, mi, ss, i;
        if ( (i = index (val, ":")) == 0 )
            return FALSE;
        end;
        hh = int (substr (val, 1, i-1));
        val = substr (val, i+1);
        if ( (i = index (val, ":")) == 0 )
            return FALSE;
        end;
        mi = int (substr (val, 1, i-1));
        ss = int (substr (val, i+1));
        setParm (1, time (hh, mi, ss));
        return TRUE;
    onError
        return FALSE;
    End;
            
    Private macro addError ( str )
        errorStr = errorStr + ifThenElse (errorStr, "; ", "") + str;
        error = TRUE;
    End;
    
    Private macro checkLine
        return error;
    End;
    
    Private macro printLogCommon ( numproc, linestart, lineend )
        if ( numproc )
            println ("èÆ‚Æ™ ¸ "+numproc, " ·‚‡Æ™® · "+linestart+" "+ifThenElse (lineend, "ØÆ "+lineend, "§Æ ™Æ≠Ê† ‰†©´†"));
        end;
        Var long = timeShiftToStr (startTime, dtTm (date (), time ()));
        [è‡Æ§Æ´¶®‚•´Ï≠Æ·‚Ï Æ°‡†°Æ‚™® #] (long);
        if ( errFile )
            [ë‰Æ‡¨®‡Æ¢†≠ ‰†©´ · ÆË®°ÆÁ≠Î¨® ·‚‡Æ™†¨®: #] (errFile);
        end;
        [];

        file rez () txt write;
        if ( numproc )
            open (rez, mergeFile (splitFile (getWorkFileName ("0")), "cnvparm", string (numproc)));
            insert (rez, "RESULT");
            insert (rez, "LINE1="+linestart);
            insert (rez, "LINE2="+lineend);
            insert (rez, "LONG="+long);
            if ( errFile )
                insert (rez, "ERROR="+errFile);
            end;
            close (rez);
            myExecSql ("begin dbms_application_info.set_client_info (''); end;");
        end;
    End;

    Private macro eraseFldName ( val )
        Var i = index (val, "=");
        if ( i ) 
            val = substr (val, i+1);
        end;
        return val;
    End;

    Private macro loadLine
        var num = 1, val, str = data, i;
        while ( (num < parmCount ()) and (strlen (str) > 0) )
            if ( i = index (str, delim) )
                val = substr (str, 1, i-1);
                str = substr (str, i+1);
            else
                val = str;
                str = "";
            end;
            if ( fldNameExist )
                val = eraseFldName (val);
            end;
            setParm (num, trim (val));
            num = num + 1;
        end;
        errorStr = "";
        error = FALSE;
        checkLine ();
    End;

    Private macro nextLine
        if ( processSize == 0 )
            initProgress (fSize/1024, NULL, ifThenElse (processNumber, "é°‡†°Æ‚™†. èÆ‚Æ™ ¸ "+processNumber, "é°‡†°Æ‚™†"));
        end;
        Var res = doc.readLine (@data), addData, len;
        len = strlen (data);
        data = trim (data);
        //while ( (substr (data, strlen (data)) != delim) and doc.readLine (@addData) )
        //    data = data + trim (addData);
        //    len = len + strlen (addData);
        //    line = line + 1;
        //end;
        line = line + 1;
        useProgress ((processSize = processSize + len+2)/1024);
        return res;
    End;

    Private macro setPosition ( posLine )
        begAction (100, "èÆ®·™ ØÆß®Ê®®");
        processSize = -1;
        while ( line < posLine-1 )
            nextLine ();
        end;
        processSize = 0;
        endAction ();
    End;

    Private macro saveerr ( numproc )
        if ( errFile == NULL )
            Var name;
            splitFile (fName, name);
            name = String (name, date ():f, "_", time ());
            name = trim (strsubst (strsubst (name, ":", ""), " ", "0"));
            if ( numproc )
                name = name + "_" + numproc;
            end;
            errFile = mergeFile (impPath, name, "err");
        end;

        Var f = TStreamDoc (errFile, "A", encode);
        f.writeLine (data);
    End;

    Macro destructor ()
        doc = NULL;
        remProgress ();
    End;
End;
//-----------------------------------------------------------------------------------------