/** 
 @file QI_job.mac
 @brief Процедуры по квал.инвесторам ЮЛ
  
 # tag 
 - functional_block:Клиенты_Регистрация_на_бирже
 - code_type:API
 - Квал.инвесторы

   
 # changeLog 
 |date       |author         |tasks            |note                            
 |-----------|---------------|-----------------|--------------------------------
 |14.11.2023 |Гераськина Т.В.|BOSS-194         | Создание
 |09.01.2024 |Гераськина Т.В.|BOSS-194         | Code review
 |10.01.2024 |Гераськина Т.В.|BOSS-194         | Процедура исключения ЮЛ из реестра КИ
 |23.01.2024 |Гераськина Т.В.|DEF-60188        | Изменены даты отбора запуска планировщика
 |26.01.2024 |Гераськина Т.В.|DEF-60395        | Изменены даты отбора запуска планировщика для исключения
 |29.01.2024 |Гераськина Т.В.|DEF-60600        | Опечатка в наименовании письма
 |29.01.2024 |Гераськина Т.В.|DEF-60544        | Планировщик не завершает задание
 |29.01.2024 |Гераськина Т.В.|DEF-60620        | Изменено копирование в итоговую директорию
 |02.02.2024 |Гераськина Т.В.|DEF-60890        | Очищается имя файла для требования предоставить документы
 |02.02.2024 |Гераськина Т.В.|DEF-60925        | Изменено условие: не вычитаем 9 месяцев из текущей, а прибавляем 9 месяцев к дате включения
 |05.02.2024 |Гераськина Т.В.|DEF-60918        | Ручное удаление категории 140
 |06.02.2024 |Гераськина Т.В.|DEF-61108        | Ведущий "0" для даты
 |06.02.2024 |Гераськина Т.В.|DEF-61106        | Очищено "сообщение отправлено" для успешной отправки
 |06.02.2024 |Гераськина Т.В.|DEF-61113        | Скорректирован поиск почты
 |16.02.2024 |Гераськина Т.В.|DEF-61729        | Обновление даты и времени отправки сообщения на договоре
 |28.02.2024 |Гераськина Т.В.|DEF-62458        | Изменен текст для it_event при ошибке

*/ 
import rsd, cb_sql;
import "u_common_email_utils.mac";
import "dbo_qi_func.mac";
import "usr_table_int.mac";
import "stringUtils.mac";
import "dbo_qi_Exclusion.mac";
//import "dlwrept.mac";
import "dlwreps.mac";
import DealsInter;

// для ответа планировщика
private var SS_RESPONSE_REPEAT_OK = 0; /* Продолжение попытки выполнить исполняемую процедуру (функцию) после успешного исполнения */
private var SS_RESPONSE_REPEAT_ERROR = 1; /* Продолжение попытки выполнить исполняемую процедуру (функцию) после ошибки */
private var SS_RESPONSE_NEXT = 2; /* Успешное завершение работы метода - переход к следующему методу */
private var SS_RESPONSE_END = 3; /* Успешное завершение всего сервиса */
private var SS_RESPONSE_FATAL = 4; /* Ошибка исполнения, обработка всей цепочки прерывается */
private var SS_RESPONSE_PROXY = 5; /* Запрос отправлен во внешнюю систему через Proxy, требуется перриодический анализ изменения состояния */

/**
@brief Класс ответа планировщика
@param[in] p_ProcessState константы SS_*
@param[in] p_ErrorNumber код ошибки
@param[in] p_ErrorText текст ошибки

@return Заполенный объект класса
*/
private class c_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText)
   var ProcessState;
   var ErrorNumber;
   var ErrorText;

   private macro init_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText)
      if(ValType(p_ProcessState) != V_UNDEF)
         ProcessState = p_ProcessState;
      end;
      if(ValType(p_ErrorNumber) != V_UNDEF)
         ErrorNumber = p_ErrorNumber;
      end;
      if(ValType(p_ErrorText) != V_UNDEF)
         ErrorText = p_ErrorText;
      end;
   end;

   init_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText);
end;


const 
   NUMBER_MONTHS_OVERDUE = 9,
   NUMBER_DAYS_TO_CLAIM = 30,
   SS_SHEDULER_NUMBER_NOTIFY = 10052,
   C_READY_STATE = 0,
   C_SUCCESS_STATE = 1,
   C_PROCESSING_STATE = 2,
   C_ERROR_STATE = 100,
   SS_SHEDULER_NUMBER_EXCLUSION = 10053;
   
   var G_COUNT_LAST_DAYS = 0;

/**
@brief Получить абсолютный путь из относительного
@param[in] p_path относительный путь 

@return абсолютный путь
*/
PRIVATE MACRO processPath( p_path )
  var l_str, l_p, l_path = "";

  p_path = trim( p_path );

  if( substr( p_path, 1, 2 ) == ".." ) /* ссылка на вышестоящий каталог */
   p_path = substr( p_path, 3 );

   l_str  = getCWD(false);
   l_p    = strbrk( l_str, "\\" );
   while( l_p != 0 )
    l_path = l_path + substr( l_str, 1, l_p - 1 ) + "\\";
    l_str  = substr( l_str, l_p + 1 );
    l_p    = strbrk( l_str, "\\" );
   end;
   return ( substr( l_path, 1, strlen( l_path ) - 1 ) + p_path );

  elif( substr( p_path, 1, 1 ) == "." ) /* ссылка на текущий каталог */
   return ( getCWD + substr( p_path, 2 ) );
  end;

  return p_path;
END;


/**
@brief Получить путь к директории файлов по умолчанию из настройки
@param[out] error_text текст ошибки 

@return значение настройки
*/
private macro GetDefaultPath(error_text:@string)
   var errCode = 0;
   var res = "";
   var len = 0;
   error_text = "";

   GetRegistryValue(QI_REGISTRY_DIRECTORY, V_STRING, res, errCode);
   if ( (errCode == 0) and (StrLen(res) > 1) )
   else 
      error_text = "Не заданы системные настройки процесса: " + QI_REGISTRY_DIRECTORY;
   end;
   len = StrLen(res);
   if (Substr(res,len,1) == "\\")
   else
      res = res + "\\";
   end;

   return res;
end;


/**
@brief Формирование файла уведомления
@param[in] ds  Recordset 

@return полное имя файла
*/
macro FormFileClaim(ds, error_text:@string, error_code:@integer)
   var FormFileName = "";
   var DefaultPath = "";
   var FileNameSigner = "";
   error_text = "";
   var stat = true;
   var clientname = "", clean_clientname = "";
   var fTxt, tplName, RealFileName = "";
   var fNameTxtMess = "QiClaim_" + GetDateTimeMark(Date(), Time()) + "_" + String(Random(999))+".txt";

   
   var signer = GetQIDefaultSigner();
   clean_clientname = CleanStringForFilename(ds.value("t_shortname"));
   clean_clientname = StrSubst(clean_clientname,"_"," ");
   
   if (signer.oper == 0)
      error_text = "Не заданы системные настройки процесса: ""Подписант по умолчанию"" ";
      error_code = 10;
      stat = false;
   elif (StrLen(signer.post) <=1)
      error_text = "Не заполнена должность подписанта по умолчанию";
      error_code = 10;
      stat = false;
   elif (signer.signStampImageID == 0)
      error_text = "Отсутствует изображение подписи подписанта по умолчанию";
      error_code = 10;
      stat = false;
   end;
   
   if (stat and ((ds.value("t_legalform") == PTLEGF_INST) or 
                  IsIndividualEmployer(ds.value("t_partyid"))))
     var error;
     var errorCode = QINotifyIPS(ds.value("t_partyid"), CLAIM_QI, date(), signer.oper, null, null, @error);
   end;
   
   if (stat)
      if (not WEB_ShowImageByID(signer.signStampImageID, FileNameSigner))
         error_text = "Ошибка загрузки изображения с ID = " + signer.signStampImageID;
         error_code = 20;
         stat = false;
      end;
   end;
   FileNameSigner = processPath(FileNameSigner);
   
   if (stat)
      DefaultPath = GetDefaultPath(@error_text);
      if ( StrLen(DefaultPath) > 1 ) 
      else 
         error_code = 10;
         stat = false;
      end;
   end;

   if (ds.value("t_legalform") == PTLEGF_PERSN)
      clientname = ds.value("t_name");
   else 
      clientname = ds.value("t_shortname");
   end;
   
   if (stat)
      fTxt = TStreamDoc(fNameTxtMess, "C", "rsoem ", 1/*unix*/);
      if ( ValType(fTxt) != V_UNDEF )
      else
         error_text = "Текстовый файл вывода не открыт " + fNameTxtMess;
         error_code = 10;
         stat = false;
     end;
   end;   
      
   if (stat)
      FormFileName = "Требование о подтверждении статуса Квалифицированного инвестора "+clean_clientname+".pdf";

      tplName = "899-ОД-1-11.dotx";
      fTxt.WriteLine(tplName);     //Шаблон dotx
      fTxt.WriteLine(SubStr(FormFileName, 1, index(FormFileName, ".pdf")-1) + "_" + String(ds.value("t_partyid")));   //Файл docx

      fTxt.WriteLine("~Client");
      fTxt.WriteLine(clientname);
      
      fTxt.WriteLine("~Post");
      fTxt.WriteLine(signer.post);

      fTxt.WriteLine("~InsertImage");
//      fTxt.WriteLine("Sign#"+FileNameSigner+"#141#128"); //Имя_закладки#Полный путь к файлу с картинкой#258#238 //60%
      fTxt.WriteLine("Sign#"+FileNameSigner+"#154#142"); //Имя_закладки#Полный путь к файлу с картинкой#258#238 //60%

      fTxt.WriteLine("~SignerName");
      fTxt.WriteLine(signer.name);

      fTxt.WriteLine("~Date");
      fTxt.WriteLine(String(String(date():f)));

      //удаляем пустые строки в подписях
      fTxt.WriteLine("~DeleteRows");
      fTxt.WriteLine(string(2)); //Номер таблицы
      fTxt.WriteLine("%");
      fTxt.WriteLine(String(3+1)); //номер первой удаляемой строки
      fTxt.WriteLine(String(3+1)); //номер последней удаляемой строки

      fTxt.WriteLine("~DeleteRows");
      fTxt.WriteLine(string(2)); //Номер таблицы
      fTxt.WriteLine("%");
      fTxt.WriteLine(String(7+1-1)); //номер первой удаляемой строки
      fTxt.WriteLine(String(7+1-1)); //номер последней удаляемой строки

      //эмуляция метода close
      fTxt = TStreamDoc(fNameTxtMess, "R", "rsoem ", 1/*unix*/);
      
      RemoveFile(FormFileName);

      //Вызов функции из dlwreps.mac 
      if (not DLWREPS_PrintReportFromTagFile( fNameTxtMess, @RealFileName, Null/*CloseDoc*/, True/*SaveDocTwice*/ , Null/*UsePoiMode*/, FormFileName/*FileNamePDF*/, Null/*FileNameHTML*/, False/*ShowDoc*/) )
         error_text = "Ошибка создания файла " + FormFileName;
         error_code = 20;
         stat = false;
         FormFileName = ""; // чтобы не логировалось
      else
         if (not CopyFile(FormFileName, toANSI(DefaultPath+FormFileName), True /*Индикатор*/, "Копируем файл для отправки"))
            error_text = "Не удалось скопировать файл " + FormFileName + " в директорию " + string(toANSI(DefaultPath+FormFileName));
            error_code = 20;
         else
            //MsgBox("Успешно скопирован файл из "+pdfName+" в директорию "+ string(storage.FilePath(RESULTTAG, PDFTAG));
         end;            
      end;
      
   end;
   
   return toANSI(DefaultPath+FormFileName);
onError(e)

   var count, i, str="";
   if (e.Err)
      if (IsEqClass ("TRsComErr", e.err))
         count = e.err.Count;
         i = 0;
         while (i < count)
            str = string(str, e.err.Message(i), " (Code = ",e.err.Code(i), ", Level = ",e.err.Level(i), ")", strfor(10));
            i = i + 1
         end;
         str = str + " " + e.Module + " " + e.Line + " " + e.Message;
      elif (valtype(e.err) == v_string)
         str = e.err;
      else
         str = e.Module + " " + e.Line + " " + e.Message;
      end;  
   else
      str = e.Module + " " + e.Line + " " + e.Message;
   end;

   error_text = str;
   error_code = 20;
   
   return "";
end;


/**
@brief Вставка сообщения в ddlcontrmsg_dbt
@param[in] pkind  Вид сообщения
@param[in] pdlid  ddlcontr_dbt.t_dlcontrid
@param[out] error_text  текст ошибки

@return ddlcontrmsg_dbt.t_id 

Вставляется только запись. Связанный объект при необходимости загружается отдельно.
*/
macro PutMessage(pkind, pdlid, error_text:@string);
   var sql_str;
   var cmd;
   var v_msg = 0;
   
   sql_str = String( 
                     "DECLARE   \n"
                    ,"   v_dlId Ddlcontr_Dbt.t_Dlcontrid%TYPE := :p_dlId;   \n"
                    ,"   v_kind NUMBER(5) := :p_kind;   \n"
                    ,"   v_Msg    Ddlcontrmsg_Dbt.t_Id%TYPE;   \n"
                    ,"BEGIN   \n"
                    ,"   IF v_dlId IS NOT NULL THEN   \n"
                    ,"      INSERT INTO Ddlcontrmsg_Dbt   \n"
                    ,"         (t_Dlcontrid, t_Kind, t_Createdate, t_Createtime, t_Senddate, t_Sendtime)   \n"
                    ,"      VALUES   \n"
                    ,"         (v_dlId   \n"
                    ,"         ,v_kind   \n"
                    ,"         ,Trunc(SYSDATE)   \n"
                    ,"         ,To_Date('01010001 ' || To_Char(SYSDATE, 'HH24MISS'), 'DDMMYYYY HH24MISS')   \n"
                    ,"         ,NULL   \n"
                    ,"         ,NULL)   \n"
                    ,"      RETURNING t_Id INTO v_Msg;   \n"
                    ,"   END IF;   \n"
                    ,"   :p_Msg := v_Msg;  \n"
                    ,"END; ");
   cmd = RSDCommand(sql_str);
   cmd.AddParam("p_dlid", RSDBP_IN, pdlid);
   cmd.AddParam("p_kind", RSDBP_IN, pkind);
   cmd.AddParam("p_Msg", RSDBP_OUT, V_INTEGER);
   cmd.execute();
   v_msg = cmd.Value("p_Msg");
   cmd.close(); cmd = null;
   error_text = "";
   
   return v_msg;
onError(err)
   error_text = "";
   if ((err.Err != null) or (err.Err != nullval))
      error_text = err.message + getFullCmdErrorText(cmd);
   else 
      error_text = err.Message + " " + err.Module + " " + err.Line;
   end;
   
   return 0;
end;

/**
@brief Обновить дату и время отправки сообщения на договоре
@param[in] pmessageid  ddlcontr_dbt.t_dlcontrid

@return true/false 
*/
macro UpdateDlMessage(p_messageid, error_text:@string)
   var sql_str, cmd;

   sql_str = "UPDATE dDlContrMsg_dbt SET t_sendDate = :pdate, t_sendTime = :ptime WHERE t_ID = :pid ";
   cmd = RSDCommand(sql_str);
   cmd.AddParam("pdate", RSDBP_IN, date());
   cmd.AddParam("ptime", RSDBP_IN, time());
   cmd.AddParam("pid", RSDBP_IN, p_messageid);
   cmd.execute();
   cmd.close();

   error_text = "";
   return true;
onError(err)
   error_text = "";
   if ((err.Err != null) or (err.Err != nullval))
      error_text = err.message + getFullCmdErrorText(cmd);
   else 
      error_text = err.Message + " " + err.Module + " " + err.Line;
   end;
   
   return false;
end;

/**
@brief Прикрепление файла к ddlcontrmsg_dbt
@param[in] pmessageid  ddlcontr_dbt.t_dlcontrid
@param[in] FormFileName полное имя файла
@param[out] error_text  текст ошибки

@return true/false 

Если к сообщению уже что-то прикреплено, очищаем
*/
macro AttachFile(pmessageid, FormFileName, error_text:@string)
   var res = true;
   var sql_str, cmd, rs;
   
   sql_str =  " SELECT t_ImageID " +
              "   FROM dimgdata_dbt " +
              "  WHERE t_ObjectType = :pobjtype " +
              "    AND t_ObjectID = LPAD(:pid, 34, '0') "+
              "    AND t_ImageType = 1 ";
   cmd = RsdCommand(sql_str);
   cmd.AddParam("pobjtype", RSDBP_IN, OBJTYPE_BSCMSG_DL);
   cmd.AddParam("pid", RSDBP_IN, pmessageid);
   rs = RsdRecordset(cmd);
   while(res and rs.MoveNext())
      if(not WEB_DeleteImage(rs.Value("t_ImageID")))
         error_text = "Не удалось очистить прикрепленный объект";
         res = false;
      end;
   end;
   
   if (res)
      if (not LoadImageObj(FormFileName, OBJTYPE_BSCMSG_DL, String(pmessageid:o:34), 1))
         error_text = "К записи о сообщении не удалось прикрепить файл сообщения";
         res = false;
      end;
   end;
   
   return res;
end;

/**
@brief Простая проверка адреса электронной почты
@param[in] pemail  значение адреса

@return pemail/"-"

Проверяем длину адреса (больше 1 символа) и содержание знака @
*/
macro SimpleCheckEmail(pemail)
   var res = "-";
   if ( (strlen(pemail) <=1 ) or (Index(pemail,"@") <= 1) ) 
      res = "-";
   else 
      res = pemail;
   end;
   return res;
end;


/**
@brief Найти электронный адрес
@param[in] pdlcontrid  ddlcontr_dbt.t_dlcontrid
@param[in] ppartyid  partyid

@return email/"-"
*/
macro FindEmailClient(pdlcontrid, ppartyid)
   var sql_str, cmd, rs;
   var res = "-";
   var value1 = "-", value2 = "-", value3 = "-";
   var stat = true;
   
   sql_str = "select t_email from ddlcontr_dbt where t_dlcontrid = :pdlid";
   cmd = RSDCommand(sql_str);
   cmd.AddParam("pdlid", RSDBP_IN, pdlcontrid);
   rs = RSDRecordSet(cmd);
   if (rs.movenext())
      res = SimpleCheckEmail(rs.value("t_email"));
   end;
   if (res == "-") // нет адреса
      stat = false;
   end;
   if (not stat)
      sql_str  = "select t_value, t_contactkind, t_contacttype from dcontact_dbt "+
                 " where t_partyid = :partyid and t_contactkind = :pcontactkind";
      cmd = RSDCommand(sql_str);
      cmd.AddParam("partyid", RSDBP_IN, ppartyid);
      cmd.AddParam("pcontactkind", RSDBP_IN, CNTK_EMAIL);
      rs = RSDRecordSet(cmd);
      while (rs.movenext())
         if (rs.value("t_contacttype") == 8)
            value1 = SimpleCheckEmail(rs.value("t_value"));
         elif (rs.value("t_contacttype") == 1001)
            value2 = SimpleCheckEmail(rs.value("t_value"));
         else 
            value3 = SimpleCheckEmail(rs.value("t_value"));
         end;
      end;
      if (value1 != "-")
         res = value1;
      elif (value2 != "-")
         res = value2;
      elif (value3 != "-")
         res = value3;
      end;
   end;
   
   return res;
onError(e)
   return "-";
end;

/**
@brief Отправка почты
@param[in] ds RecordSet с данными клиента и договора
@param[in] pFormFileName полное имя файла
@param[in] pmessageid ddlcontrmsg_dbt.t_id
@param[out] statMes текст ошибки
@param[out] statCode код ошибки

@return true/false
*/
macro SendMessage(ds, dlcontrid, pFormFileName, pmessageid, statMes:@string, statCode:@integer)
   var emailText, Subject, v_email_processor;
   var client_email = "";
   var stat = true;
   var bcc_email_array, email_single;
   var registryPath: String = GetHiddenRecipientsRegistryPath(ds.value("t_legalForm") == PTLEGF_INST);

   client_email = FindEmailClient(dlcontrid, ds.value("t_partyid"));
   if (client_email == "-")
      statMes = "У клиента отсутствует электронная почта для рассылки";
      statCode = 10;
      stat = false;
   elif (not CheckEmails(client_email))
      statMes = "Некорректный емейл";
      statCode = 10;
      stat = false;
   end;
   
   if (stat)
      bcc_email_array = GetHiddenRecipients(registryPath);
      if (bcc_email_array.size == 0)
         statMes = "Не заданы системные настройки процесса: " + registryPath;
         statCode = 10;
         stat = false;
      end;
   end;

   if (stat) 

      if(not GetRegValueSwitchQI())//NEW PARAM
         // у писем одинаковый текст, но разный заголовок
         if (ds.value("t_messagetypeid") == OVERDUE_QI)
            Subject = "Уведомление об истечении статуса квалифицированного инвестора "+ds.value("t_shortname")+" "+ds.value("t_number");
         else 
            Subject = "Требование о подтверждении статуса Квалифицированного инвестора "+ds.value("t_shortname")+" "+ds.value("t_number");
         end;
      else 
         // у писем одинаковый текст, но разный заголовок
         if (ds.value("t_messagetypeid") == OVERDUE_QI)
            Subject = "Уведомление об истечении статуса квалифицированного инвестора "+ds.value("t_shortname");
         else 
            Subject = "Требование о подтверждении статуса Квалифицированного инвестора "+ds.value("t_shortname");
         end;
      end;
      
      Emailtext = String("Уважаемый Клиент!",
                         "\n",
                         "\nАО \x22Россельхозбанк\x22 уведомляет Вас, что "+String(SQL_ConvTypeDate(ds.value("t_controldate")):f)+" истекает срок статуса квалифицированного инвестора "+ds.value("t_name")+".",
                         "\n",
                         "\nПросим Вас предоставить документы по любому из перечисленных п.п. 2.1.1-2.1.5 раздела 2 Приложения 3 к Регламенту принятия решения о признании лица квалифицированным инвестором в АО \x22Россельхозбанк\x22 (далее - Регламент), с целью проведения проверки на соблюдение требований пункта 3.2 Регламента не позднее 10 (десяти) рабочих дней до истечения статуса квалифицированного инвестора.");
      v_email_processor = c_email_proc_env();
      v_email_processor.m_add_email_to_list(client_email);
      if (bcc_email_array.size > 0)
         for (email_single, bcc_email_array)
            v_email_processor.m_add_email_to_bcc_list(email_single);
         end;
      end;
      
      v_email_processor.m_set_msg_head(Subject);
      if (strlen(trim(pFormFileName)) > 1)
         v_email_processor.m_add_attach_to_list(pFormFileName);
      end;
      v_email_processor.m_add_row_to_msg_text(emailText);

      v_email_processor.m_save_to_submit_synch();
      v_email_processor.m_submit_email_synch();

      if(v_email_processor.m_get_error_status())
         statMes = "Сообщение сформировано, но не отправлено: " + v_email_processor.get_service_msg();
         statCode = 20;
         stat = false;
      else
         statMes = "";
         statCode = 0;
         stat = UpdateDlMessage(pmessageid, @statMes);
         if (not stat)
           statCode = 20;
         end;
      end;
   end;
   
   return stat;
onError(e)
   statMes = e.Message + " " + e.Module + " " + e.Line;
   statCode = 20;
   return false;
end;

/**
@brief  Класс для обновления таблицы DSCQINV_NOTIFY_DBT

*/
private class (c_usr_tbl_base) c_usr_tbl_dscqinv_notify()
   private class gen_dscqinv_notify()
      var T_ID             :integer,
          T_PARTYID        :integer,
          T_SFCONTRID      :integer,
          T_DLCONTRID      :integer,
          T_LASTREGDATE    :date,
          T_CONTROLDATE    :date,
          T_MESSAGETYPEID  :integer,
          T_SENDDATE       :date,
          T_FACTSENDDATE   :datetime,
          T_SENDSTATE      :integer,
          T_ERROR          :string,
          T_PATH           :string,
          T_MESSAGEID      :integer,
          T_UPDATEDATETIME :datetime;
   end;

   private macro init_table_obj()
      new_val_obj = gen_dscqinv_notify();
      where_val_obj = gen_dscqinv_notify();
   end;

   Initc_usr_tbl_base("DSCQINV_NOTIFY_DBT");

   init_table_obj();
end;

/**
@brief Фиксирование ошибки через it_event
@param[in] prs  RecordSet
@param[in] perr  Текст ошибки
@param[in] perr_code  Код ошибки
@return true/false
*/
macro FixError(prs, perr, perr_code)
   var sql_str, cmd;
   var v_errordesc, v_levelinfo, v_msgmeta, v_servicename, v_servicename_r;

   if (Valtype(perr_code) != V_INTEGER)
      perr_code = 20;
   end;
   
   if (prs.value("T_MESSAGETYPEID") == EXCLUSION_QI)
     v_servicename = "ws_QI_Expired";
     v_servicename_r = "Исключение клиента ЮЛ из Реестра КИ";
   else 
     v_servicename = "ws_QI_State_Notification";
     v_servicename_r = "Рассылка уведомлений об истечении срока действия статуса КИ";
   end;

   if (perr_code == 10)
      v_errordesc = "Сбой в бизнес-логике процедуры """+v_servicename_r+"""";
      v_levelinfo = -10;
   else 
      v_errordesc = "Ошибка выполнения процедуры """+v_servicename_r+"""";
      v_levelinfo = 10;
   end;

   v_msgmeta = String("<XML "
                      , " T_ID = \"",prs.value("T_ID"),"\""
                      , " T_PARTYID = \"",prs.value("T_PARTYID"),"\""
                      , " T_SFCONTRID = \"",prs.value("T_SFCONTRID"),"\""
                      , " T_DLCONTRID = \"",prs.value("T_DLCONTRID"),"\""
                      , " T_LASTREGDATE = \"",String(SQL_ConvTypeDate(prs.value("T_LASTREGDATE")):f),"\""
                      , " T_CONTROLDATE = \"",String(SQL_ConvTypeDate(prs.value("T_CONTROLDATE")):f),"\""
                      , " T_MESSAGETYPEID = \"",prs.value("T_MESSAGETYPEID"),"\""
                      , " T_SENDDATE = \"",String(SQL_ConvTypeDate(prs.value("T_SENDDATE")):f),"\""
                      , " T_FACTSENDDATE = \"",String(SQL_ConvTypeDate(prs.value("T_FACTSENDDATE")):f),"\""
                      , " T_SENDSTATE = \"",prs.value("T_SENDSTATE"),"\""
                      , " T_ERROR = \"",perr,"\""
                      , " T_PATH = \"",prs.value("T_PATH"),"\""
                      , " T_MESSAGEID = \"",prs.value("T_MESSAGEID"),"\""
                      , " T_UPDATEDATETIME = \"",prs.value("T_UPDATEDATETIME"),"\""
                      , " />" );

   sql_str = String(
      " begin  \n"+ 
      "   it_event.RegisterError(  p_SystemId => 'SOFR' \n"+
      "                           ,p_ServiceName => :pservicename \n"+
      "                           ,p_ErrorCode => :perrorcode \n"+
      "                           ,p_ErrorDesc => :perrordesc \n"+
      "                           ,p_LevelInfo => :plevelinfo \n"+
      "                           ,p_backtrace => null \n"+
      "                           ,p_MsgBODY => 'Сбой процесса '''||:pservicename_r||''': '||:perrortext \n"+
      "                           ,p_MsgMETA => :pmsgmeta); \n"+
      " end; ");
   cmd = RSDCommand(sql_str);
   cmd.AddParam("pservicename", RSDBP_IN, v_servicename);
   cmd.AddParam("perrorcode", RSDBP_IN, perr_code);
   cmd.AddParam("perrordesc", RSDBP_IN, v_errordesc);
   cmd.AddParam("plevelinfo", RSDBP_IN, v_levelinfo);
   cmd.AddParam("pservicename_r", RSDBP_IN, v_servicename_r);
   cmd.AddParam("perrortext", RSDBP_IN, perr);
   cmd.AddParam("pmsgmeta", RSDBP_IN, v_msgmeta);
   cmd.execute();
   cmd.close();
   
   return true;
onError(err)
   var error_text = "";
   if ((err.Err != null) or (err.Err != nullval))
      error_text = err.message + getFullCmdErrorText(cmd);
   else 
      error_text = err.Message + " " + err.Module + " " + err.Line;
   end;
   
   return false;
end;

/**
@brief Функция установки статуса для записи в DSCQINV_NOTIFY_DBT
@param[in] notifyID  Id в таблице
@param[in] newState  Новый статус
@return V_BOOL Статус операции (true - успешно)
*/
private macro SetNotifyState(notifyID, newState): Bool
  var result = true;
  
  if ((ValType(notifyID) != V_INTEGER) or (ValType(newState) != V_INTEGER))
    result = false;
  end;
  
  if (result)
    var execState = ExecSql("UPDATE DSCQINV_NOTIFY_DBT SET t_sendstate = ?, T_UPDATEDATETIME = ? WHERE t_ID = ? ", 
                            MakeArray(SQLParam("", newState), SQLParam("", dttm(date(),time())), SQLParam("", notifyID)), 
                            false);
    result = (execState != NULL);
  end;
  
  return result;
end;

/**
@brief Функция проверки необходимости обработки для записи в DSCQINV_NOTIFY_DBT
@param[in] notifyID  Id в таблице
@param[in] newState  Новый статус
@return V_BOOL Статус операции (true - успешно)
*/
private macro IsNotifyNeedProcessing(notifyID)
  var result = true;
  
  if (ValType(notifyID) != V_INTEGER)
    result = false;
  end;
  
  if (result)
    var rs = ExecSqlSelect("SELECT t_sendState FROM DSCQINV_NOTIFY_DBT WHERE t_ID = ? ", 
                           MakeArray(SQLParam("", notifyID)), 
                           false);
    if ((rs == NULL) or 
        (not rs.MoveNext()) or 
        ((rs.value("t_sendstate") == C_SUCCESS_STATE) or (rs.value("t_sendstate") == C_PROCESSING_STATE)))
      result = false;
    end;
  end;
  
  return result;
end;

/**
@brief Обработка по журналу событий уведомления и требования
@param[in] pId  Id записи журнала. Если не задан - обработка по всем в соответствующем статусе
*/
macro ProcessQISendNotify(pId)
   var sql_str, str_fltr, cmd, rs;
   var messageid = 0;
   var FormFileName = "";
   var err = "", stat = true, err_code = 10;
   var NotifyTbl = c_usr_tbl_dscqinv_notify();
   var errCode = 0;

   //DEF-60188
   GetRegistryValue(QI_REGISTRY_NOTIFICATIONDEALINE, V_INTEGER, G_COUNT_LAST_DAYS, errCode);
   if (errCode == 0) 
   else 
      G_COUNT_LAST_DAYS = 0; 
   end;

   if (pId)
      str_fltr = " and n.t_id = "+pId;
   else 
      str_fltr = "   and n.t_sendstate in (:pstate1, :pstate2 ) "+
                 "   and n.t_senddate >= trunc(sysdate) - :pdays ";
   end;
   
    if(not GetRegValueSwitchQI())//NEW PARAM
      sql_str = "select n.*, p.t_shortname, p.t_name, p.t_legalform, sf.t_number "+
             "  from DSCQINV_NOTIFY_DBT n, dparty_dbt p, dsfcontr_dbt sf "+
             " where p.t_partyid = n.t_partyid "+
             "   and sf.t_id = n.t_sfcontrid "+
             "   and t_messagetypeid in (:ptype1, :ptype2) "+str_fltr;
   else
      sql_str = "select n.*, p.t_shortname, p.t_name, p.t_legalform, sf.t_number "+
             "  from DSCQINV_NOTIFY_DBT n JOIN dparty_dbt p ON p.t_partyid = n.t_partyid  "+
             "                       LEFT JOIN dsfcontr_dbt sf ON sf.t_id = n.t_sfcontrid "+
             " where t_messagetypeid in (:ptype1, :ptype2) "+str_fltr;
   end;

   cmd = RSDCommand(sql_str);
   cmd.AddParam("ptype1", RSDBP_IN, OVERDUE_QI);
   cmd.AddParam("ptype2", RSDBP_IN, CLAIM_QI);
   cmd.AddParam("pstate1", RSDBP_IN, C_READY_STATE);
   cmd.AddParam("pstate2", RSDBP_IN, C_ERROR_STATE);
   cmd.AddParam("pdays", RSDBP_IN, G_COUNT_LAST_DAYS);
   
   rs = RSDRecordSet(cmd);
   while (rs.movenext())
      stat = true;
               
      if (not IsNotifyNeedProcessing(rs.value("t_id")))
        if (pId)
          return "Обработка записи не требуется";
        else
          continue;
        end;
      end;
      
      SetNotifyState(rs.value("t_id"), C_PROCESSING_STATE);
      FormFileName = "";
      
      if(not GetRegValueSwitchQI()) //NEW PARAM
        messageid = rs.value("T_MESSAGEID");
        
        if (messageid == 0)
           messageid = PutMessage(rs.value("t_messagetypeid"), rs.value("t_dlcontrid"), @err);
        end;
      
        if (messageid > 0)
           if (rs.value("t_messagetypeid") == CLAIM_QI)
              FormFileName = rs.value("T_PATH");
              if (StrLen(FormFileName) <= 1) // нет файла
                 FormFileName = FormFileClaim(rs, @err, @err_code);
              end;
              
              if (err == "")
              else
                 stat = false;
              end;
              
              if (stat)
                 stat = AttachFile(messageid, FormFileName, @err);
                 if (not stat)
                    FormFileName = ""; // чтобы не вводить в заблужение
                    err_code = 20;
                 end;
              end;
           end;
        else 
           err_code = 20;
           stat = false;
        end;
        
        if (stat)
           stat = SendMessage(rs, rs.value("t_dlcontrid"), FormFileName, messageid, @err, @err_code);
        end;
      else
        var dlContrId = 0;

        if (rs.value("t_messagetypeid") == CLAIM_QI)
          FormFileName = rs.value("T_PATH");
          if ((StrLen(FormFileName) <= 1) or (not ExistFile(FormFileName)))// нет файла
             FormFileName = FormFileClaim(rs, @err, @err_code);
          end;
          
          if (err != "")
            stat = false;
          end;
        end;
        
        if (stat)
          var cmdContracts = RSDCommand("SELECT dl.t_dlcontrID " +
                                          "FROM dSfContr_dbt sf " +
                                         "INNER JOIN dDlContr_dbt dl on dl.t_sfcontrID = sf.t_ID " +
                                         "WHERE sf.t_partyID = :partyid " +
                                           "AND sf.t_servKind = 0 " +
                                           "AND sf.t_dateClose = to_date('01.01.0001', 'DD.MM.YYYY')");
          cmdContracts.AddParam("partyid", RSDBP_IN, rs.value("t_partyid"));
          
          var contracts = RSDRecordSet(cmdContracts);
          var lastMessageid;
          var lastError;

          messageid = 0;
          err = "";
          
          while (contracts.MoveNext())
            lastMessageid = PutMessage(rs.value("t_messagetypeid"), contracts.value("t_dlcontrID"), @lastError);
            
            if (lastMessageid > 0)
              messageid = lastMessageid;
              dlContrId = contracts.value("t_dlcontrID");
            
              if (StrLen(FormFileName) > 0)
                AttachFile(messageid, FormFileName, @lastError);
              end;
            else
              err = lastError;
            end;
          end;
          
          if ((messageid == 0) and (StrLen(err) > 0))
            FormFileName = "";
            err_code = 20;
            stat = false;
          end;
        end;
        
        if (stat)
           stat = SendMessage(rs, dlContrId, FormFileName, messageid, @err, @err_code);
        end;
      end;

      if (stat)
         NotifyTbl.New_Val_Obj.T_SENDSTATE = C_SUCCESS_STATE;
         NotifyTbl.New_Val_Obj.T_FACTSENDDATE = dttm(date(),time());
      else
         NotifyTbl.New_Val_Obj.T_SENDSTATE = C_ERROR_STATE;
         FixError(rs, err, err_code);
      end;
      NotifyTbl.New_Val_Obj.T_ERROR = err;   // для успешной отправки пустое значение
      NotifyTbl.New_Val_Obj.T_PATH = FormFileName;
      NotifyTbl.New_Val_Obj.T_MESSAGEID = messageid;
      NotifyTbl.New_Val_Obj.T_UPDATEDATETIME = dttm(date(),time());
      NotifyTbl.Where_Val_Obj.T_ID = rs.value("t_id");

      if( not NotifyTbl.Update() )
         err = NotifyTbl.get_service_msg();
      end;
      
   end;
   rs.close; cmd.close;
   rs = null; cmd = null;

end;

/**
@brief Обработка по журналу событий исключения
@param[in] pId  Id записи журнала. Если не задан - обработка по всем в соответствующем статусе
*/
macro ProcessQIExclusion(pId)
   var sql_str, str_fltr, cmd, rs;
   var err = "", stat = true, err_code = 10;
   var reason;
   var stat_code = 0;
   var NotifyTbl = c_usr_tbl_dscqinv_notify();
   var ResultParams : CQINotificationResultParams = CQINotificationResultParams();
   var fileName = "", DL;
   var exclusionDate;

   reason = "Согласно п.4.9 Регламента принятия решения о признании лица квалифицированным инвестором";

   if (pId)
      str_fltr = " and n.t_id = "+pId;
   else 
      str_fltr = "   and n.t_sendstate in (:pstate1, :pstate2 ) "+
                 "   and n.t_senddate >= trunc(sysdate) - :pdays ";
   end;
   
   if(not GetRegValueSwitchQI()) //NEW PARAM
      sql_str = "select n.*, p.t_shortname, p.t_name, p.t_legalform, sf.t_number "+
             "  from DSCQINV_NOTIFY_DBT n, dparty_dbt p, dsfcontr_dbt sf "+
             " where p.t_partyid = n.t_partyid "+
             "   and sf.t_id = n.t_sfcontrid "+
             "   and t_messagetypeid = :ptype "+str_fltr;
   else
      sql_str = "select n.*, p.t_shortname, p.t_name, p.t_legalform, sf.t_number "+
             "  from DSCQINV_NOTIFY_DBT n JOIN dparty_dbt p ON p.t_partyid = n.t_partyid  "+
             "                       LEFT JOIN dsfcontr_dbt sf ON sf.t_id = n.t_sfcontrid "+
             " where t_messagetypeid = :ptype "+str_fltr;
   end;

   cmd = RSDCommand(sql_str);
   cmd.AddParam("ptype", RSDBP_IN, EXCLUSION_QI);
   cmd.AddParam("pstate1", RSDBP_IN, C_READY_STATE);
   cmd.AddParam("pstate2", RSDBP_IN, C_ERROR_STATE);
   cmd.AddParam("pdays", RSDBP_IN, G_COUNT_LAST_DAYS);
   
   rs = RSDRecordSet(cmd);
   while (rs.movenext())
      stat = true;
      
      if (not IsNotifyNeedProcessing(rs.value("t_id")))
        if (pId)
          return "Обработка записи не требуется";
        else
          continue;
        end;
      end;
      
      SetNotifyState(rs.value("t_id"), C_PROCESSING_STATE);
      exclusionDate = Date(rs.value("t_ControlDate")) + 1; 
      stat_code = DL_UpdateQI(rs.value("t_partyid"), DSCQINV_KIND_STATEMENT, exclusionDate, DSCQINV_STATE_EXCLUDED, reason);
      if (stat_code > 0) // исключить не удалось
         if (stat_code == 22578) // уже исключен, считаем, что это нормально
            stat = true;
         else
            err_code = 10;
            err = GetErrMessage(stat_code);
            stat = false;
         end;
      end;
      if (stat)
        // API не снимает категорию в отличии от ручного исключения
        stat = DisconnectObjAttr(OBJTYPE_BROKERCONTR_DL, string(rs.value("t_dlcontrid"):34:o), CATEGORY_USE_IN_APPLICATION, 0, exclusionDate);
      end;
      if (not stat)
         err_code = 10;
         err = "Не удалось удалить категорию "+CATEGORY_USE_IN_APPLICATION+" на договоре";
      end;

      if (stat)
         fileName = SQL_ConvTypeStr(rs.value("t_path"));
         if (StrLen(fileName) > 0)
           RemoveFile(fileName); // Исключение дублирования файлов при многократном вызове
         end;
         
         err = QIExclusionNotify(rs.value("t_dlcontrid"), exclusionDate, ResultParams);
         if (err == "")
         else
            err_code = ResultParams.Error_code;
            stat = false;
         end;
      end;

      if (stat)
         NotifyTbl.New_Val_Obj.T_SENDSTATE = C_SUCCESS_STATE;
         NotifyTbl.New_Val_Obj.T_FACTSENDDATE = dttm(date(),time());
      else
         NotifyTbl.New_Val_Obj.T_SENDSTATE = C_ERROR_STATE;
         FixError(rs, err, err_code);
      end;
      NotifyTbl.New_Val_Obj.T_ERROR = err;   // для успешной отправки пустое значение
      NotifyTbl.New_Val_Obj.T_PATH = ResultParams.Path;
      NotifyTbl.New_Val_Obj.T_MESSAGEID = ResultParams.MessageId;
      NotifyTbl.New_Val_Obj.T_UPDATEDATETIME = dttm(date(),time());
      NotifyTbl.Where_Val_Obj.T_ID = rs.value("t_id");

      if( not NotifyTbl.Update() )
         err = NotifyTbl.get_service_msg();
      end;
      
   end;
   rs.close; cmd.close;
   rs = null; cmd = null;

end;



/**
@brief Формирование строки исключения дублей
@param[in] pkind  Тип уведомления

@return строка not exists
*/
macro GetStrExist(pkind)
   var res;
   if(not GetRegValueSwitchQI())//NEW PARAM
      res =  "  and not exists (SELECT 1 from DSCQINV_NOTIFY_DBT qi_notify "+
             "                   WHERE qi_notify.t_partyid = bd.t_partyid "+
             "                     AND qi_notify.t_sfcontrid = bd.t_sfcontrid "+
             "                     AND qi_notify.t_lastregdate = bd.t_regdate "+
             "                     AND qi_notify.t_controldate = bd.t_controldate "+
             "                     AND qi_notify.t_messagetypeid = "+String(pkind)+" )";
   else
      res =  "  and not exists (SELECT 1 from DSCQINV_NOTIFY_DBT qi_notify "+
             "                   WHERE qi_notify.t_partyid = bd.t_partyid "+
             "                     AND qi_notify.t_lastregdate = bd.t_regdate "+
             "                     AND qi_notify.t_controldate = bd.t_controldate "+
             "                     AND qi_notify.t_messagetypeid = "+String(pkind)+" )";
   end;
   return res;
end;

/**
@brief Формирование строки insert ... select
@param[in] pkind  Тип уведомления
@param[in] pdate  Дата запуска

@return строка sql-запроса
*/
macro GetStrInsert(pkind, pdate)
   var res = String(  "INSERT into DSCQINV_NOTIFY_DBT (  \n"
                     ,"     T_ID, T_PARTYID, T_SFCONTRID, T_DLCONTRID, T_LASTREGDATE, T_CONTROLDATE, \n"
                     ,"     T_MESSAGETYPEID, T_SENDDATE, T_FACTSENDDATE, T_SENDSTATE, \n"
                     ,"     T_ERROR, T_PATH, T_MESSAGEID, T_CREATEDATETIME \n"
                     ,"     ) \n"
                     ," select null, t_partyid, t_sfcontrid, t_dlcontrid, t_regdate, t_controldate, \n"
                     ,"    "+pkind+", "+GetSqlDate(pdate)+", null, "+C_READY_STATE+", \n"
                     ,"    null, null, 0, sysdate ");
   return res;
end;

/**
@brief Истечение статуса КИ 
@param[in] pdate  Дата запуска
@param[in] psql_str  Основной текст запроса

Рассылка писем с уведомлением об истечении статуса КИ
*/
macro Run_overdue(pdate, psql_str)
   var sql_str, cmd;
   var sql_str_add_not_exist = GetStrExist(OVERDUE_QI);
   var sql_str_insert_select = GetStrInsert(OVERDUE_QI, pdate);
   
   sql_str = sql_str_insert_select +" from (" + psql_str + ") bd where add_months(bd.t_regdate,:pmonths) = :pdate " + sql_str_add_not_exist;

   cmd = RSDCommand(sql_str);
   cmd.AddParam("pmonths", RSDBP_IN, NUMBER_MONTHS_OVERDUE);
   cmd.AddParam("pdate", RSDBP_IN, pdate);
   cmd.execute();
   cmd.close();
end;


/**
@brief Требование подтверждения статуса КИ 
@param[in] pdate  Дата запуска
@param[in] psql_str  Основной текст запроса

Расылка писем с требованием о подтверждении статуса КИ
*/
macro Run_claim(pdate, psql_str)
   var sql_str, cmd;
   var sql_str_add_not_exist = GetStrExist(CLAIM_QI);
   var sql_str_insert_select = GetStrInsert(CLAIM_QI, pdate);
   
   sql_str = sql_str_insert_select +" from (" + psql_str + ") bd where t_controldate = :pdate + :pnumdays " + sql_str_add_not_exist;

   cmd = RSDCommand(sql_str);
   cmd.AddParam("pdate", RSDBP_IN, pdate);
   cmd.AddParam("pnumdays", RSDBP_IN, NUMBER_DAYS_TO_CLAIM);
   cmd.execute();
   cmd.close();
end;


/**
@brief Исключение из реестра КИ - вставка записи в журнал
@param[in] pdate  Дата запуска
@param[in] psql_str  Основной текст запроса

*/
macro Run_exclusion(pdate, psql_str)
   var sql_str, cmd;
   var sql_str_add_not_exist = GetStrExist(EXCLUSION_QI);
   var sql_str_insert_select = GetStrInsert(EXCLUSION_QI, pdate);
   
   sql_str = sql_str_insert_select +" from (" + psql_str + ") bd where 1=1 " + sql_str_add_not_exist;

   cmd = RSDCommand(sql_str);
   cmd.AddParam("pdate", RSDBP_IN, pdate);
   cmd.execute();
   cmd.close();
end;


/**
@brief Обновление статуса подвисших заданий
@param[in] pkind  Тип задания
@param[in] ptimeout  Таймаут в секундах
*/
macro RenewStatus(pkind:integer)
   var v_timeout_processing = 0, errCode = 0;

   GetRegistryValue(QI_REGISTRY_TIMEOUT_SEND_MESSAGE, V_INTEGER, v_timeout_processing, errCode);
   if (errCode == 0) 
   else 
      v_timeout_processing = 600; //значение по умолчанию, начальная настройка из дефекта DEF-64262
   end;

   var sql_str_upd, cmd_upd;

   sql_str_upd = "update dscqinv_notify_dbt "+
                 "  set t_sendstate = :p_state_new, "+
                 "      t_error = 'Истекло время обработки. Таймаут выполнения '||:p_timeout1||' секунд' "+
                 " where t_sendstate = :p_state_old "+
                 "   and (t_updatedatetime < (sysdate - NUMTODSINTERVAL(:p_timeout2, 'SECOND'))) "+
                 "   and t_messagetypeid = :p_kind ";
   cmd_upd = RSDCommand(sql_str_upd);
   cmd_upd.AddParam("p_state_new", RSDBP_IN, C_ERROR_STATE);
   cmd_upd.AddParam("p_timeout1", RSDBP_IN, v_timeout_processing);
   cmd_upd.AddParam("p_state_old", RSDBP_IN, C_PROCESSING_STATE);
   cmd_upd.AddParam("p_timeout2", RSDBP_IN, v_timeout_processing);
   cmd_upd.AddParam("p_kind", RSDBP_IN, pkind);
   cmd_upd.execute();
   cmd_upd.close();
end;


/**
@brief Проверка сроков истечения статусов КИ для ЮЛ
@return заполненый класс ResultSheduler

Процедура проверяет сроки по ЮЛ-квал.инвесторам и рассылает сообщения при необходимости
*/
macro ws_check_end_qi()
   var sql_str, rs, cmd;
   var last_run = date(0,0,0);
   var current_date = date();
   var ResultSheduler :object;
   var errCode;

   //DEF-60188
   GetRegistryValue(QI_REGISTRY_NOTIFICATIONDEALINE, V_INTEGER, G_COUNT_LAST_DAYS, errCode);
   if (errCode == 0) 
   else 
      G_COUNT_LAST_DAYS = 0; // в данном случае отсутствие настройки не ломает выгрузку, выгрузка только за текущий день
   end;

   last_run = current_date - G_COUNT_LAST_DAYS;

   //DEF-64262
   RenewStatus(OVERDUE_QI);
   RenewStatus(CLAIM_QI);
   
   // текст основного селекта - общий отбор для процедур
   // записи в реестре могут быть без договора, но он нам нужен в тексте письма, поэтому строгий селект
   if(not GetRegValueSwitchQI())//NEW PARAM
      sql_str = "select qi.t_sfcontrid, qi.t_partyid, "+
             "       case "+
             "          when qi.t_regdate > t_changedate then t_regdate "+
             "          else qi.t_changedate "+
             "       end t_regdate, "+
             "       nvl(dl.t_dlcontrid,0) t_dlcontrid, "+
             "       qi.t_controldate "+
             "  from "+
             "      dscqinv_dbt qi, "+
             "      ddlcontr_dbt dl, "+
             "      dparty_dbt p "+
             " where qi.t_kind = 2 "+
             "   and qi.t_state = 1 "+
             "   and p.t_partyid = qi.t_partyid "+
             "   and p.t_legalform = 1 "+
             "   and dl.t_sfcontrid = qi.t_sfcontrid ";
   else
       sql_str = "select qi.t_sfcontrid, qi.t_partyid, "+
             "       case "+
             "          when qi.t_regdate > t_changedate then t_regdate "+
             "          else qi.t_changedate "+
             "       end t_regdate, "+
             "       nvl(dl.t_dlcontrid,0) t_dlcontrid, "+
             "       qi.t_controldate "+
             "  from "+
             "      dscqinv_dbt qi JOIN dparty_dbt p ON p.t_partyid = qi.t_partyid "+
             "                                       AND p.t_legalform = 1 "+
             "                LEFT JOIN ddlcontr_dbt dl ON dl.t_sfcontrid = qi.t_sfcontrid "+
             " where qi.t_kind = 2 "+
             "   and qi.t_state = 1 ";
   end;

   // за полученный из настройки диапазон дат
   while (last_run <= current_date)
      Run_overdue(last_run, sql_str);
      Run_claim(last_run, sql_str);
      last_run = last_run + 1;
   end;

   ProcessQISendNotify();

   ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

   return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_FATAL, err.message, err.code);

  return ResultSheduler;

end;


/**
@brief Исключение клиента ЮЛ из Реестра КИ
@return заполненый класс ResultSheduler

Исключает клиента из реестра КИ при наступлении срока и рассылает уведомления
*/
macro expired_exclusion_qi()
   var sql_str, rs, cmd;
   var last_run = date(0,0,0);
   var current_date = date();
   var errCode;
   var ResultSheduler :object;

   //DEF-60395
   GetRegistryValue(QI_REGISTRY_NOTIFICATIONDEALINE, V_INTEGER, G_COUNT_LAST_DAYS, errCode);
   if (errCode == 0) 
   else 
      G_COUNT_LAST_DAYS = 0; // в данном случае отсутствие настройки не ломает выгрузку, выгрузка только за текущий день
   end;

   last_run = current_date - G_COUNT_LAST_DAYS;

   //DEF-64262
   RenewStatus(EXCLUSION_QI);

   if(not GetRegValueSwitchQI()) //NEW PARAM
      sql_str = "select qi.t_sfcontrid, qi.t_partyid, "+
             "       nvl(dl.t_dlcontrid,0) t_dlcontrid, "+
             "       case "+
             "          when qi.t_regdate > t_changedate then t_regdate "+
             "          else qi.t_changedate "+
             "       end t_regdate, "+
             "       qi.t_controldate "+
             "  from "+
             "      dscqinv_dbt qi, "+
             "      ddlcontr_dbt dl, "+
             "      dparty_dbt p "+
             " where qi.t_kind = 2 "+
             "   and qi.t_state = 1 "+
             "   and p.t_partyid = qi.t_partyid "+
             "   and p.t_legalform = 1 "+
             "   and dl.t_sfcontrid = qi.t_sfcontrid "+
             "   and qi.t_controldate = :pd - 1";
   else
      sql_str = "select qi.t_sfcontrid, qi.t_partyid, "+
             "       nvl(dl.t_dlcontrid,0) t_dlcontrid, "+
             "       case "+
             "          when qi.t_regdate > t_changedate then t_regdate "+
             "          else qi.t_changedate "+
             "       end t_regdate, "+
             "       qi.t_controldate "+
             "  from "+
             "      dscqinv_dbt qi JOIN dparty_dbt p ON p.t_partyid = qi.t_partyid "+
             "                                       AND p.t_legalform = 1 "+
             "                LEFT JOIN dsfcontr_dbt sf on sf.t_partyid = p.t_partyid  and sf.t_servkind = 0  "+
             "                LEFT JOIN ddlcontr_dbt dl ON dl.t_sfcontrid = sf.t_id  "+
             " where qi.t_kind = 2 "+
             "   and qi.t_state = 1 "+
             "   and qi.t_controldate = :pd - 1";
   end;
   

   // за полученный из настройки диапазон дат
   while (last_run <= current_date)
      Run_exclusion(last_run, sql_str);
      last_run = last_run + 1;
   end;

   ProcessQIExclusion();
   
   ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

   return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_FATAL, err.message, err.code);

  return ResultSheduler;

end;