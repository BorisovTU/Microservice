/*
$Name:        uacctcompare_rep.mac
$Module:      Интеграция с внешними системами
$Description: Отчет-сверка счетов, выгруженных в ЦФТ из СОФР
*/

//А.Киселев 17.05.2019 "Отчет-сверка счетов выгруженных в ЦФТ из СОФР".

import globals, ActiveX, oralib, likepy, rsexts;
import "global_utils_intgr.mac", "u_common_email_utils.mac", "dlutils.mac";
import "ucompare_func.mac";    // DEF-66506, DEF-71583
import "scsrvrepfun.mac";

private const EXPORT_XML_FILENAME_TXT = "for_acctcompare",
              CV_EMAIL_GRP_ETCOMPARE = 3; //группа сверки проводок загруженных в ЦФТ из СОФР

private const TRY_LIMIT = 3; //количество повторных попыток сверки 

private const Excel_RUS = 1049, //значение локализации для русского Excel
              HEADER_FILENAME_TXT = "header_acctcompare",
              BODY_FILENAME_TXT = "body_acctcompare",
              FOOTER_FILENAME_TXT = "footer_acctcompare"; 

private const xlPasteFormats = -4122,
              xlContinuous = 1,
              xlMedium = -4138,
              xlThin = 2,
              xlNone = -4142,
              xlEdgeLeft = 7,
              xlEdgeTop = 8,
              xlEdgeBottom = 9,
              xlEdgeRight = 10,
              xlDiagonalDown = 5,
              xlDiagonalUp = 6,
              xlInsertDeleteCells = 1,
              xlDelimited = 1,
              xlTextQualifierNone = -4142,
              xlRight  = -4152,
              xlLeft   = -4131,
              xlCenter = -4108,
              xlThemeColorLight1 = 2,
              xlThemeColorDark1 = 1,
              xlThemeColorDark2 = 3,
              xlLandscape = 2,

              SymbSeparator = "|";


private var LocalPathExcel = "",
            XLSExport_Path :string = "",
            CellNumX :integer,
            CellNumY :integer,
            CellNumDeltaY :integer = 0,
            CntAccountRow :integer = 0,
            CellYSectionBodySeparate :TArray = TArray(),
            SizeOfHeader :integer = 10, //3,
            SizeOfDeltaHeader :integer = 7,
            SizeOfFooter :integer = 5, //7,
            Max_X :integer = 26, //количество колонок
            PartyCnt :integer = 0,
            RowCnt :integer = 0,
            CNum = string(UserNumber),
            ExcelLanguage = 0,
            ExcelDecimalSeparator = "",
            FlOpenTxtFile :bool = false;


private macro TryToExcelQuit()
  if (ValType(ExcelApplication) != V_UNDEF)
     ExcelApplication.Workbooks.Close();
     ExcelApplication.Quit();
     ExcelApplication = null;
  end;
OnError(er)
end;


//преобразование bool в integer
private macro Bool_Int( Btype :bool) :integer

 if( (Valtype(Btype) != V_UNDEF) and (Btype) )
  return 1;
 else
  return 0;
 end;

end;
//преобразование bool в integer

//из массива объектов формируем SQL-строку
private macro GetSQLStrFromArray( ParamProcess :object );
const BEGIN_SQL_STR = " SELECT ",
      END_SQL_STR = " FROM DUAL ",
      SEPARATOR = ", ";

var Query :string = "",
    i :integer = 0,
    fl_first_str :bool = false;

 var load_all = false;

 if (ValType( uTryToGetPropS( ParamProcess, "Acct" ) ) == V_UNDEF) 
   load_all = true;
 else 
   if (ValType( ParamProcess.Acct ) == V_UNDEF)
     load_all = true;
   else 
     if ( ParamProcess.Acct.Size == 0 ) 
       load_all = true;
     end;
   end;
 end;
            
 if(load_all)
  Query = " SELECT -1 AS ID, '' AS ACC FROM DUAL ";
 else

  while( i < ParamProcess.Acct.Size )
   if( ParamProcess.Acct[i].Account != "-1" ) //признак неудаленного элемента массива

    if( fl_first_str )
     Query = Query + " UNION ALL ";
    else
     fl_first_str = true;
    end;

    Query = Query + BEGIN_SQL_STR + string(i) + " AS ID" + SEPARATOR + GetSQLString( ParamProcess.Acct[i].Account ) + " AS ACC" + END_SQL_STR;
   end;
   i = i + 1;
  end;

 end;

 if( Query == "" )
  Query = " SELECT -1 AS ID, '' AS ACC FROM DUAL "; //все элементы были удалены
 end;

 Query = Query + " ORDER BY 1";

 return Query;

end;



 /*
    Новая Excel-книга  без шаблона
    Входные параметры (необязательные):
       Visible       - признак отображения приложения на экране;
 */
 private macro NewExcelWorkbook_ ( Visible, ExcelFileName :string )

  if(ExcelApplication == null)
     if (isStandAlone())
        ExcelApplication = ActiveX("Excel.Application", null, true);
     else
        if (startAX == null)
           startAX = CreateObject("rsax", "TRsAxServer", "LoansAxServer", isStandalone());
        end;
        ExcelApplication = startAX.CreateComObject("Excel.Application");
     end;
  end;

  if( (Valtype(ExcelFileName) == V_UNDEF) or (Valtype(ExcelFileName) == 26) )
   ExcelApplication.Workbooks.Add(1);
  else
   ExcelApplication.Workbooks.Add( ExcelFileName );
  end;

  if (not ExcelApplication.Ready())
    //т.к. мы имеем дело с excel, да ещё и иногда запускаемом под tomcat, то сюрпризы не исключены
    //короткое гугление показывает, что отказ в исполнении команд для excel - частый случай
    //причины при этом могут быть всякими, от появившегося диалога с вопросом что excel не является приложением по умолчанию,
    //до слетевшей лицензии
    //на всякий случай тут после открытия книги, если excel ещё не готов, сделаем разовую паузу в 3 секунды
    RslWait(3000);
  end;

  ExcelApplication.DisplayAlerts = false;

  if (ValType (Visible) == V_BOOL)
    ExcelApplication.Visible = Visible;
  end;
  ActiveSheet = ExcelApplication.ActiveSheet;
  return true;
 end;


 private macro TranslateExcelFormula(Formula :string, LocalCode :integer) :string // получаем название формулы на языке локализации RUS / US International
 const Excel_RUS = 1049;                                                          // по любому из двух извесных названий
 var RUS_Formula :TArray,
     US_Formula :TArray,
     Index_;

  RUS_Formula = MakeArray("ЕСЛИ",
                          "СУММ",
                          "ОКРУГЛ");
  US_Formula = MakeArray("IF",
                         "SUM",
                         "ROUND");

  Index_ = find( RUS_Formula, Formula );
  if( Index_ < 0 )
   Index_ = find( US_Formula, Formula );
   if( Index_ < 0 )
    return Formula;
   end
  end;
  if ( LocalCode == Excel_RUS)
   return RUS_Formula[Index_];
  else
   return US_Formula[Index_];
  end
 end;


 private macro GetFormatedField(FieldValue :variant, FirstSeparator :string, LastSeparator :string) :string //форматировать значение поля и цеплять разделители
 var SepPos :integer = 0,
     SymSep :string = ",.";

  if( (ValType(FieldValue) ==  V_UNDEF) or (ValType(FieldValue) ==  V_STRING) and (FieldValue == "") or (ValType(FieldValue) ==  26) or
   (ValType(FieldValue) ==  V_DATE) and ( (string(FieldValue) == " 1.01.0001") or (FieldValue == date("00.00.0000")) ) )
   return FirstSeparator + "" + LastSeparator;
  else
   if( (ValType(FieldValue) ==  V_DATE) or (ValType(FieldValue) ==  V_DTTM) )
    FieldValue = StrSubst( string(date(FieldValue):10), " ", "0" );
   elif( ((ValType(FieldValue) ==  V_MONEY) or (ValType(FieldValue) ==  V_DOUBLE)) and (Index(FieldValue, ExcelDecimalSeparator) == 0) )
    FieldValue = string(FieldValue);
    if( ExcelDecimalSeparator == ",")
     SepPos = Index(FieldValue,".");
    else
     SepPos = Index(FieldValue,",");
    end;
    if( SepPos > 0)
     FieldValue = SubStr( FieldValue, 1, SepPos - 1 ) + ExcelDecimalSeparator + SubStr( FieldValue, SepPos+1 );
    end;
   end;
    return FirstSeparator + string(FieldValue) + LastSeparator;
  end;
 end;


macro  InsertBrokacc_acc(p_lastMaxVal,p_curMaxVal,p_curSeqLastVal)

//ЕДП
 var loadCmd = RsdCommand( 
       "insert into DBROKACC_ACC_DBT (T_BROKACC_KEY,T_ACCOUNTID )                                                                                                                            "
 +"\n"+"(                                                                                                                                                                                    "
 +"\n"+"         SELECT brok.t_autokey ,j.t_accountid                                                                                                                                        "
 +"\n"+"                  FROM dmcaccdoc_dbt mcdoc, dmccateg_dbt mccat, dbrokacc_dbt brok, DACCOUNT_DBT j, dparty_dbt E , DPERSN_DBT P                                                       "
 +"\n"+"                  WHERE  mccat.T_ID = mcdoc.T_CATID                                                                                                                                  "
 +"\n"+"                   AND mcdoc.T_ID > "+p_lastMaxVal+" and mcdoc.T_ID <= "+p_curMaxVal                                                                                                             
 +"\n"+"                   AND mccat.t_id in(70,344)                                                                                                                                         "
 +"\n"+"                   AND E.T_PARTYID = J.T_CLIENT                                                                                                                                      "
 +"\n"+"                   AND E.T_LEGALFORM = 2                                                                                                                                             "
 +"\n"+"                   AND P.T_PERSONID =  J.T_CLIENT                                                                                                                                    "
 +"\n"+"                   AND P.T_ISEMPLOYER <> CHR(88)                                                                                                                                     "
 +"\n"+"                   AND instr(t_usertypeaccount, chr(133)) != 0                                                                                                                       "
 +"\n"+"                   AND brok.T_SERVKIND = 0                                                                                                                                           "
 +"\n"+"                   AND brok.T_SERVKINDSUB = 0                                                                                                                                        "
 +"\n"+"                   AND brok.T_CURRENCY = mcdoc.T_CURRENCY                                                                                                                            "
 +"\n"+"                   AND mcdoc.T_ACCOUNT =j.T_ACCOUNT                                                                                                                                  "
 +"\n"+"                   AND J.T_CHAPTER = mcdoc.T_CHAPTER                                                                                                                                 "
 +"\n"+"                   AND J.T_CODE_CURRENCY = mcdoc.T_CURRENCY                                                                                                                          "
 +"\n"+"                   AND j.t_close_date = TO_DATE ('01.01.0001', 'dd.mm.yyyy')                                                                                                         "
 +"\n"+"                   AND SUBSTR(brok.T_ACCOUNT, 1, 5) = SUBSTR(mcdoc.T_ACCOUNT, 1, 5)                                                                                                  "
 +"\n"+"                   AND (mcdoc.T_ISCOMMON = 'X' or ( ( mcdoc.T_ISCOMMON = chr(0) ) and (mcdoc.t_disablingdate <> to_date('01010001','ddmmyyyy')) and (mcdoc.t_dockind = 0) ) )        "
 +"\n"+"                   AND J.T_ACCOUNTID NOT IN (SELECT A.T_ACCOUNTID FROM DBROKACC_ACC_DBT A WHERE A.T_ACCOUNTID = J.T_ACCOUNTID AND A.T_BROKACC_KEY = brok.T_AUTOKEY)            "
 +"\n"+"                    group by  brok.t_autokey , j.t_accountid)                                                                                                                        "
);

 loadCmd.execute( );

 loadCmd = null;

// не ЕДП
  loadCmd = RsdCommand( 
  
       "insert into DBROKACC_ACC_DBT (T_BROKACC_KEY,T_ACCOUNTID )                                                                                                                         "
 +"\n"+"  (                                                                                                                                                                               "
 +"\n"+"          SELECT brok.t_autokey,j.t_accountid                                                                                                                                     "
 +"\n"+"                    FROM dmcaccdoc_dbt mcdoc, dmccateg_dbt B, dsfcontr_dbt C, dbrokacc_dbt brok ,DACCOUNT_DBT j, dparty_dbt E, DPERSN_DBT P                                       "
 +"\n"+"                    WHERE  B.T_ID = mcdoc.T_CATID                                                                                                                                 "
 +"\n"+"                     AND b.t_id in(70,344)                                                                                                                                        "
 +"\n"+"                     AND mcdoc.T_ID > "+p_lastMaxVal+" and mcdoc.T_ID <= "+p_curMaxVal                                                                                                             
 +"\n"+"                   AND E.T_PARTYID = J.T_CLIENT                                                                                                                                   "
 +"\n"+"                   AND E.T_LEGALFORM = 2                                                                                                                                          "
 +"\n"+"                   AND P.T_PERSONID =  J.T_CLIENT                                                                                                                                 "
 +"\n"+"                   AND P.T_ISEMPLOYER <> CHR(88)                                                                                                                                  "
 +"\n"+"                   AND instr(t_usertypeaccount, chr(133)) = 0                                                                                                                     "
 +"\n"+"                     AND C.T_ID = mcdoc.T_CLIENTCONTRID                                                                                                                           "
 +"\n"+"                     AND brok.T_SERVKIND = C.T_SERVKIND                                                                                                                           "
 +"\n"+"                     AND brok.T_SERVKINDSUB = C.T_SERVKINDSUB                                                                                                                     "
 +"\n"+"                     AND brok.T_CURRENCY = mcdoc.T_CURRENCY                                                                                                                       "
 +"\n"+"                     AND mcdoc.T_ACCOUNT =j.T_ACCOUNT                                                                                                                             "
 +"\n"+"                     AND J.T_CHAPTER = mcdoc.T_CHAPTER                                                                                                                            "
 +"\n"+"                     AND J.T_CODE_CURRENCY = mcdoc.T_CURRENCY                                                                                                                     "
 +"\n"+"                     AND j.t_close_date = TO_DATE ('01.01.0001', 'dd.mm.yyyy')                                                                                                    "
 +"\n"+"                     AND  SUBSTR(brok.T_ACCOUNT, 1, 5) = SUBSTR(mcdoc.T_ACCOUNT, 1, 5)                                                                                            "
 +"\n"+"                     AND ((mcdoc.T_ISCOMMON = 'X') or ( ( mcdoc.T_ISCOMMON = chr(0) ) and (t_disablingdate <> to_date('01010001','ddmmyyyy')) and (t_dockind = 0) )               "
 +"\n"+"                     or (( mcdoc.T_ISCOMMON = chr(0) ) and (t_dockind = 3001) ) )                                                                                                 "
 +"\n"+"                      AND J.T_ACCOUNTID NOT IN (SELECT A.T_ACCOUNTID FROM DBROKACC_ACC_DBT A WHERE A.T_ACCOUNTID = J.T_ACCOUNTID AND A.T_BROKACC_KEY = brok.T_AUTOKEY)            "
 +"\n"+"    group by  brok.t_autokey , j.t_accountid )                                                                                                                                    "
      
 );

  loadCmd.execute( );
  loadCmd = null;

  //1)Добавляем в сверку сопоставление лицевых и сводных счетов 458ХХ.
  loadCmd = RsdCommand("  insert into dbrokacc_acc_dbt (t_brokacc_key, t_accountid)  "
    + "  (select brok.t_autokey, ac.t_accountid from dmcaccdoc_dbt mc  "
    + "  inner join dparty_dbt pr on mc.t_owner = pr.t_partyid  "
    + "  inner join dpersn_dbt pers on pers.t_personid =pr.t_partyid  "
    + "  inner join daccount_dbt ac on ac.t_account = mc.t_account  "
    + "  and ac.t_chapter = mc.t_chapter  "  //сопоставление глав
    + "  and mc.t_currency = ac.t_code_currency  "  //сопоставление валют
    + "  inner join dsfcontr_dbt sf on sf.t_id = mc.t_clientcontrid  "
    + "  inner join dbrokacc_dbt brok on brok.t_currency = mc.t_currency  "
    + "  and substr(brok.t_account, 1, 5) = substr(mc.t_account, 1, 5)  "
    + "  where mc.t_catid = 1055  " //категория учета 1055
    + "  and mc.t_id > "+ p_lastMaxVal +" and mc.t_id <= "+ p_curMaxVal   
    + "  and mc.t_iscommon = 'X'  "  //Признак общего - счет для всех сделок
    + "  and pr.t_legalform = 2  "  //ФЛ
    + "  and instr(t_usertypeaccount, chr(33)) = 0  "
    + "  and pers.t_isemployer <> chr(88)  "
    + "  and sf.t_servkind = 1  "  //Фондовый дилинг
    + "  and sf.t_servkindsub in (8, 9)  "  //Биржевой и внебиржевой рынок
    + "  and ac.t_accountid not in (select a.t_accountid  "               
    + "                             from dbrokacc_acc_dbt a  "
    + "                             where a.t_accountid = ac.t_accountid  "
    + "                             and a.t_brokacc_key = brok.t_autokey)  "
    + "  group by brok.t_autokey,ac.t_accountid);  ");

  loadCmd.execute( );
  loadCmd = null;

  //2)Добавляем в сверку сопоставление лицевых и сводных счетов 47423.
  loadCmd = RsdCommand("  insert into dbrokacc_acc_dbt (t_brokacc_key, t_accountid)  "
    + "  (select brok.t_autokey,ac.t_accountid  "
    + "  from dmcaccdoc_dbt mc, dparty_dbt pr, daccount_dbt ac, dsfcontr_dbt sf, dbrokacc_dbt brok, dpersn_dbt pers  "  
    + "  where mc.t_catid = 818  "
    + "  and mc.t_id > "+ p_lastMaxVal +" and mc.t_id <= "+ p_curMaxVal  
    + "  and mc.t_iscommon = 'X'  "
    + "  and mc.t_owner = pr.t_partyid  "
    + "  and pr.t_legalform = 2  "
    + "  and pers.t_isemployer <> chr(88)  "
    + "  and ac.t_account = mc.t_account  "
    + "  and ac.t_chapter = mc.t_chapter  "
    + "  and mc.t_currency = ac.t_code_currency  " 
    + "  and sf.t_id = mc.t_clientcontrid  "
    + "  and sf.t_servkind = 1  "  //Фондовый дилинг 
    + "  and sf.t_servkindsub = 8  "  //Биржевой рынок
    + "  and brok.t_servkind = 0  "
    + "  and brok.t_servkindsub = 0  "
    + "  and brok.t_currency = mc.t_currency  "                                                                                                                         
    + "  and substr(brok.t_account, 1, 5) = substr(mc.t_account, 1, 5)  "                                                                                                
    + "  and ac.t_accountid not in (select a.t_accountid from dbrokacc_acc_dbt a where a.t_accountid = ac.t_accountid and a.t_brokacc_key = brok.t_autokey)  "
    + "  group by brok.t_autokey,ac.t_accountid);  ");

  loadCmd.execute( );
  loadCmd = null;

  //3)ВНЕБИРЖА
  loadCmd = RsdCommand("  insert into dbrokacc_acc_dbt (t_brokacc_key, t_accountid)  "
    + "  (select brok.t_autokey,ac.t_accountid  "
    + "  from dmcaccdoc_dbt mc, dparty_dbt pr, daccount_dbt ac, dsfcontr_dbt sf, dbrokacc_dbt brok, dpersn_dbt pers  "
    + "  where mc.t_catid = 818  "
    + "  and mc.t_id > "+ p_lastMaxVal +" and mc.t_id <= "+ p_curMaxVal 
    + "  and mc.t_iscommon = 'X'  "
    + "  and mc.t_owner = pr.t_partyid  "
    + "  and pr.t_legalform = 2  "
    + "  and pers.t_isemployer <> chr(88)  "
    + "  and ac.t_account = mc.t_account  "
    + "  and ac.t_chapter = mc.t_chapter  "
    + "  and ac.t_close_date = to_date('01.01.0001', 'dd.mm.yyyy')  " 
    + "  and mc.t_currency = ac.t_code_currency  "
    + "  and sf.t_id = mc.t_clientcontrid  "
    + "  and sf.t_servkind = 1  "  //Фондовый дилинг 
    + "  and sf.t_servkindsub = 9  "  //Внебиржевой рынок
    + "  and brok.t_servkind = sf.t_servkind  "
    + "  and brok.t_servkindsub = sf.t_servkindsub  "
    + "  and brok.t_currency = mc.t_currency  "                                                                                                                          
    + "  and substr(brok.t_account, 1, 5) = substr(mc.t_account, 1, 5)  "                                                                                                
    + "  and ac.t_accountid not in (select a.t_accountid from dbrokacc_acc_dbt a where a.t_accountid = ac.t_accountid and a.t_brokacc_key = brok.t_autokey)  "
    + "  group by brok.t_autokey,ac.t_accountid);  ");

  loadCmd.execute( );
  loadCmd = null;
  
  SQL_Execute("UPDATE DCOMPARE_SETTINGS_DBT SET T_VALUE = '"+p_curMaxVal+"' WHERE T_KEY = 'MCDOCACC_LAST_MAXVAL'");
  SQL_Execute("UPDATE DCOMPARE_SETTINGS_DBT SET T_VALUE = '"+p_curSeqLastVal+"' WHERE T_KEY = 'MCDOCACC_SEQ_LASTVAL'");

end;

macro  InsertBrokacc_accrest(RestDate)

 var  loadCmd = RsdCommand( 
    " INSERT INTO DBROKACC_ACCREST_TMP (T_BROKACC_KEY, "
+"\n"+"                                   T_RESTDATE, "
+"\n"+"                                   T_RESTINCUR, "
+"\n"+"                                   T_RESTINRUB, "
+"\n"+"                                   T_DEBITCUR, "
+"\n"+"                                   T_DEBITRUB, "
+"\n"+"                                   T_CREDITCUR, "
+"\n"+"                                   T_CREDITRUB, "
+"\n"+"                                   T_RESTOUTCUR, "
+"\n"+"                                   T_RESTOUTRUB) "
+"\n"+"      SELECT a.t_autokey,?, "
+"\n"+"             SUM (CASE "
+"\n"+"                     WHEN c.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.RESTAC (c.T_ACCOUNT,c.T_CODE_CURRENCY,? - 1,c.T_CHAPTER,NULL) "
+"\n"+"                     ELSE 0 "
+"\n"+"                  END), "
+"\n"+"             SUM (RSB_ACCOUNT.RESTAC (C.T_ACCOUNT,C.T_CODE_CURRENCY,? - 1,C.T_CHAPTER,NULL,0)), "
+"\n"+"             SUM (CASE "
+"\n"+"                     WHEN C.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.DEBETAC (C.T_ACCOUNT,C.T_CHAPTER,C.T_CODE_CURRENCY,?,?) "
+"\n"+"                     ELSE 0 "
+"\n"+"                  END), "
+"\n"+"             SUM (RSB_ACCOUNT.DEBETAC (C.T_ACCOUNT,C.T_CHAPTER,C.T_CODE_CURRENCY,?,?,0)), "
+"\n"+"             SUM (CASE "
+"\n"+"                     WHEN C.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.KREDITAC (C.T_ACCOUNT,C.T_CHAPTER,C.T_CODE_CURRENCY,?,?) "
+"\n"+"                     ELSE 0 "
+"\n"+"                  END), "
+"\n"+"             SUM (RSB_ACCOUNT.KREDITAC (C.T_ACCOUNT,C.T_CHAPTER,C.T_CODE_CURRENCY,?,?,0)), "
+"\n"+"             SUM (CASE "
+"\n"+"                     WHEN C.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.RESTAC (C.T_ACCOUNT,C.T_CODE_CURRENCY,?,C.T_CHAPTER,NULL) "
+"\n"+"                     ELSE 0 "
+"\n"+"                  END), "
+"\n"+"             SUM (RSB_ACCOUNT.RESTAC (C.T_ACCOUNT,C.T_CODE_CURRENCY,?,C.T_CHAPTER,NULL,0)) "
+"\n"+"        FROM dbrokacc_dbt A, DBROKACC_ACC_DBT b, daccount_dbt c "
+"\n"+"       WHERE a.t_autokey = b.T_BROKACC_KEY AND b.t_accountid = c.t_accountid and not exists (select 1 from DBROKACC_ACCREST_TMP k where k.T_BROKACC_KEY = b.T_BROKACC_KEY and k.T_RESTDATE = ?) "
+"\n"+"    GROUP BY a.t_autokey "
   );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.AddParam( "", RSDBP_IN, RestDate );
  loadCmd.execute( );

end;

//получим курсор
private macro GetDataSet( DataSet :@RsdRecordset, QueryType :integer, ReqId :string, ParamProcess :object ) :integer
var Query :string = "", SelectQuery :string = "",
    Params :TArray,
    FlAcc :integer = 0,
    checkDs,
    seqLastVal :integer = 0,
    lastMaxVal :integer = 0,
    curSeqLastVal :integer = 0,
    curMaxVal :integer = 0,
    SQLStrFromArray :string = "",
    loadCmd,
    error;

 if( QueryType == 0 )


  //курсор в tmp
  DataSet = Null;
  SQLStrFromArray = GetSQLStrFromArray( ParamProcess );

  checkDs = ExecSQLSelect("SELECT T_VALUE FROM DCOMPARE_SETTINGS_DBT WHERE T_KEY = 'MCDOCACC_SEQ_LASTVAL'", NULL, false);
  if ((checkDs != NULL) and (checkDs.moveNext()))
    seqLastVal = SQL_ConvTypeInteger(checkDs.value("T_VALUE")); //последнее зафиксированное значение последовательности таблицы dmcaccdoc_dbt
  end;

  checkDs = ExecSQLSelect("SELECT T_VALUE FROM DCOMPARE_SETTINGS_DBT WHERE T_KEY = 'MCDOCACC_LAST_MAXVAL'", NULL, false);
  if ((checkDs != NULL) and (checkDs.moveNext()))
    lastMaxVal = SQL_ConvTypeInteger(checkDs.value("T_VALUE")); //последний обработанный счёт
  end;

  checkDs = ExecSQLSelect("SELECT last_number FROM user_sequences WHERE sequence_name = 'DMCACCDOC_DBT_SEQ'", NULL, false);
  if ((checkDs != NULL) and (checkDs.moveNext()))
    curSeqLastVal = SQL_ConvTypeInteger(checkDs.value("last_number")); //актуальное значение счётчика последовательности таблицы dmcaccdoc_dbt
  end;

  checkDs = ExecSQLSelect("SELECT max(t_id) as t_maxid FROM DMCACCDOC_DBT", NULL, false);
  if ((checkDs != NULL) and (checkDs.moveNext()))
    curMaxVal = SQL_ConvTypeInteger(checkDs.value("t_maxid")); //последний добавленный счёт, самый верхний
  end;

  //если актуальное значение последовательности меньше последнего сохранённого,
  // считаем что откатилась БД или сама последовательность слетела, сбрасываем последний обработанный счёт чтобы прогонять заново все
  if (curSeqLastVal < seqLastVal) 
    lastMaxVal = 0;
  end;

  BegAction(3000,"Дозагружается сопоставление аналитики с синтетикой",false);

//дополняем брокерские счета при необходимости
  InsertBrokacc_acc(lastMaxVal,curMaxVal,curSeqLastVal);

  EndAction();

  BegAction(3000,"Загружаются остатки сопоставления",false);

// Загружаем остатки 
  InsertBrokacc_accrest(ParamProcess.RestDate);

  EndAction();
          //исключая 306* потому что в ЦФТ они сводные
  SelectQuery
        = "  SELECT A.T_AUTOKEY, A.T_COUNTER, A.T_ACCT, A.T_CURRENCY, "+
          "  A.T_RESTINCUR, " +
          "  A.T_RESTINRUB, " +
          "  A.T_DEBITCUR, " +
          "  A.T_DEBITRUB, " +
          "  A.T_CREDITCUR, " +
          "  A.T_CREDITRUB, " +
          "  A.T_RESTOUTCUR, " +
          "  A.T_RESTOUTRUB, " +
          " CAST(( CASE WHEN B.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.RESTAC ( A.T_ACCT, B.T_CODE_CURRENCY, ? -1, B.T_CHAPTER, NULL) ELSE 0 END ) AS NUMBER(32,12)) AS T_RESTINCUR_, "+
          " CAST(RSB_ACCOUNT.RESTAC ( A.T_ACCT, B.T_CODE_CURRENCY, ? -1, B.T_CHAPTER, NULL, 0 ) AS NUMBER(32,12)) AS T_RESTINRUB_, "+
          " CAST(( CASE WHEN B.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.DEBETAC ( A.T_ACCT, B.T_CHAPTER, B.T_CODE_CURRENCY, ?, ? ) ELSE 0 END ) AS NUMBER(32,12)) AS T_DEBITCUR_, "+
          " CAST(RSB_ACCOUNT.DEBETAC ( A.T_ACCT, B.T_CHAPTER, B.T_CODE_CURRENCY, ?, ?, 0 ) AS NUMBER(32,12)) AS T_DEBITRUB_, "+
          " CAST(( CASE WHEN B.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.KREDITAC ( A.T_ACCT, B.T_CHAPTER, B.T_CODE_CURRENCY, ?, ? ) ELSE 0 END ) AS NUMBER(32,12)) AS T_CREDITCUR_,  "+
          " CAST(RSB_ACCOUNT.KREDITAC ( A.T_ACCT, B.T_CHAPTER, B.T_CODE_CURRENCY, ?, ?, 0 ) AS NUMBER(32,12)) AS T_CREDITRUB_,  "+
          " CAST(( CASE WHEN B.T_CODE_CURRENCY > 0 THEN RSB_ACCOUNT.RESTAC ( A.T_ACCT, B.T_CODE_CURRENCY, ?, B.T_CHAPTER, NULL ) ELSE 0 END ) AS NUMBER(32,12)) AS T_RESTOUTCUR_, "+
          " CAST(RSB_ACCOUNT.RESTAC ( A.T_ACCT, B.T_CODE_CURRENCY, ?, B.T_CHAPTER, NULL, 0 ) AS NUMBER(32,12)) AS T_RESTOUTRUB_, "+
          "  A.T_REQID, A.T_DETAILS " +
          " FROM uloadaccforcompare_dbt A, daccount_dbt B " +
          " , ( " + SQLStrFromArray + " ) Z " +
          " WHERE A.T_REQID = ? "+
          " AND B.T_ACCOUNT = A.T_ACCT "+
          " AND EXISTS (select 1 from DBALACC_TOCOMPARE_DBT k where A.T_ACCT like k.T_ACC) "+
          " AND B.T_CODE_CURRENCY = ( SELECT F.T_FIID FROM dfininstr_dbt F WHERE F.T_CODEINACCOUNT = A.T_CURRENCY AND F.T_FI_KIND = 1 AND F.T_AVOIRKIND = 0 AND ROWNUM = 1 ) "+
          " AND B.T_CHAPTER > 0 "+
          "  AND ( Z.ID < 0 " +
          "   OR ( Z.ACC = CHR(1) " +
          "    OR RSB_MASK.CompareStringWithMask( Z.ACC, A.T_ACCT ) > 0 ) ) "+
//shev
          "    and not exists (select 1 from dbrokacc_dbt where t_account = a.t_acct) "+


          " UNION ALL "+

          " SELECT S.T_AUTOKEY, S.T_COUNTER, S.T_ACCT, S.T_CURRENCY, "+
          " S.T_RESTINCUR, " +
          " S.T_RESTINRUB, " +
          " S.T_DEBITCUR, " +
          " S.T_DEBITRUB, " +
          " S.T_CREDITCUR, " +
          " S.T_CREDITRUB, " +
          " S.T_RESTOUTCUR, " +
          " S.T_RESTOUTRUB, " +
          " CAST(R.T_RESTINCUR as NUMBER(32,12)) as T_RESTINCUR_, " +
          " CAST(R.T_RESTINRUB as NUMBER(32,12)) as T_RESTINRUB_, " +
          " CAST(R.T_DEBITCUR as NUMBER(32,12)) as T_DEBITCUR_, " +
          " CAST(R.T_DEBITRUB as NUMBER(32,12)) as T_DEBITRUB_, " +
          " CAST(R.T_CREDITCUR as NUMBER(32,12)) as T_CREDITCUR_, " +
          " CAST(R.T_CREDITRUB as NUMBER(32,12)) as T_CREDITRUB_, " +
          " CAST(R.T_RESTOUTCUR as NUMBER(32,12)) as T_RESTOUTCUR_, " +
          " CAST(R.T_RESTOUTRUB as NUMBER(32,12)) as T_RESTOUTRUB_, " +
          " S.T_REQID, S.T_DETAILS "+

          " FROM uloadaccforcompare_dbt S, "+
          " dbrokacc_dbt A, DBROKACC_ACCREST_TMP r "+
          " , ( " + SQLStrFromArray + " ) Z " +
          " WHERE T_REQID = ? and (T_ACCT LIKE '306%' OR T_ACCT LIKE '458%' OR T_ACCT LIKE '47423%') and S.T_ACCT = A.T_ACCOUNT and a.t_autokey = r.T_BROKACC_KEY and r.T_RESTDATE = ?"+//AND b.t_accountid = c.t_accountid "+
          " AND EXISTS (select 1 from DBALACC_TOCOMPARE_DBT k where s.T_ACCT like k.T_ACC) "+
          "  AND ( Z.ID < 0 " +
          "   OR ( Z.ACC = CHR(1) " +
          "    OR RSB_MASK.CompareStringWithMask( Z.ACC, S.T_ACCT ) > 0 ) ) ";

  Query = "select * from ("+SelectQuery+")"+
          "  WHERE ( T_RESTINCUR  <> T_RESTINCUR_   " +
          "       OR T_RESTINRUB  <> T_RESTINRUB_   " +
          "       OR T_DEBITCUR   <> T_DEBITCUR_    " +
          "       OR T_DEBITRUB   <> T_DEBITRUB_    " +
          "       OR T_CREDITCUR  <> T_CREDITCUR_   " +
          "       OR T_CREDITRUB  <> T_CREDITRUB_   " +
          "       OR T_RESTOUTCUR <> T_RESTOUTCUR_  " +
          "       OR T_RESTOUTRUB <> T_RESTOUTRUB_ )";

  Params = makeArray( 
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ParamProcess.RestDate ),
    SQLParam("", ReqId ),
    SQLParam("", ReqId ),
    SQLParam("", ParamProcess.RestDate )
  ); 
  DataSet = execSQLselect( Query, Params );

 end;
end;
//получим курсор

//Отчет-сверка счетов выгруженных в ЦФТ из СОФР !!!!!!!!!В параметрах будет вместо фильтра ReqId соответственно нужно будет поменять SQL-запрос и его параметры
macro AcctCompareRepLogic( ReqId :string, ParamProcess: object, Fl_SetDialog :integer, errortext:@String ) :bool

var DataSet :RsdRecordset,
    i :integer = 0,
    outl = "",
    Fulloutputl = "",
    FileNameOut = "",
    StrBuf :string = "",
    ColumnType,
    ErrCode,
    Params :TArray,
    Dt,
    Mn,
    Year,
    Query :string,
    RefValue :string = "",
    v_email_processor;


 if( ( ValType(Fl_SetDialog) == V_UNDEF ) or ( ValType(Fl_SetDialog) == 26 ) )
  Fl_SetDialog = 0;
 end;

 if( Fl_SetDialog == 1 )
  InitProgress(-1, "Обработка данных.", "Обработка данных.");
 end;

//распарсить параметры в объект для SQL-запроса и шапки

 GetDataSet( @DataSet, 0, ReqId, ParamProcess ); //получим курсор расхождений счетов

 if( Fl_SetDialog == 1 )
  RemProgress();
  InitProgress(-1, "Формирование отчета.", "Формирование отчета");
 end;

 //шаблон в режиме POI
 var repTmpl = CTemplateSXLSX("Report_UAccTCompare.xlsx");
 var fileSavePathExcel = PathCombine(GetAbsoluteTxtPath(),EXPORT_XML_FILENAME_TXT+CNum+".xlsx");

 repTmpl.SetValue_NameCell("req_text", "В ответ на запрос СОФР: " + ReqId);
 repTmpl.SetValue_NameCell("period_text", 
                           "Операционный день " + StrSubst( string(date(ParamProcess.RestDate):10), " ", "0" )
                          );
 StrBuf = "";
 if( (ValType(uTryToGetPropS( ParamProcess, "Acct" )) != V_UNDEF) and (ValType(ParamProcess.Acct) != V_UNDEF)  and (ValType(ParamProcess.Acct) != 26) and
      (ParamProcess.Acct.Size > 0) )
   i = 0;
   StrBuf =  "";
   while( i < ParamProcess.Acct.Size )
     StrBuf = StrBuf + " Счет: " + ParamProcess.Acct[i].Account + ";\n";
     i = i + 1;
   end;
 else
   StrBuf = "Счет: Все";
 end;
 repTmpl.SetValue_NameCell("acc_text", StrBuf);
 var tableObj = repTmpl.RegisterTable("bodyline");

 var tableRowCount = 0;

 while(DataSet.MoveNext())
   if( ( DataSet.value("T_RESTINCUR", Null, V_MONEY) != DataSet.value("T_RESTINCUR_", Null, V_MONEY) ) or
       ( DataSet.value("T_RESTINRUB", Null, V_MONEY) != DataSet.value("T_RESTINRUB_", Null, V_MONEY) ) or
       ( DataSet.value("T_DEBITCUR", Null, V_MONEY) != DataSet.value("T_DEBITCUR_", Null, V_MONEY) ) or
       ( DataSet.value("T_DEBITRUB", Null, V_MONEY) != DataSet.value("T_DEBITRUB_", Null, V_MONEY) ) or
       ( DataSet.value("T_CREDITCUR", Null, V_MONEY) != DataSet.value("T_CREDITCUR_", Null, V_MONEY) ) or
       ( DataSet.value("T_CREDITRUB", Null, V_MONEY) != DataSet.value("T_CREDITRUB_", Null, V_MONEY) ) or
       ( DataSet.value("T_RESTOUTCUR", Null, V_MONEY) != DataSet.value("T_RESTOUTCUR_", Null, V_MONEY) ) or
       ( DataSet.value("T_RESTOUTRUB", Null, V_MONEY) != DataSet.value("T_RESTOUTRUB_", Null, V_MONEY) ) )
     tableObj.SetValueCell("bodyline_f1",SQL_ConvTypeStr(DataSet.value("T_ACCT")));
     tableObj.SetValueCell("bodyline_f2",SQL_ConvTypeSum(DataSet.value("T_RESTINCUR_")));
     tableObj.SetValueCell("bodyline_f3",SQL_ConvTypeSum(DataSet.value("T_RESTINCUR")));
     tableObj.SetValueCell("bodyline_f4",SQL_ConvTypeSum(DataSet.value("T_RESTINCUR")) - SQL_ConvTypeSum(DataSet.value("T_RESTINCUR_")));
     tableObj.SetValueCell("bodyline_f5",SQL_ConvTypeSum(DataSet.value("T_RESTINRUB_")));
     tableObj.SetValueCell("bodyline_f6",SQL_ConvTypeSum(DataSet.value("T_RESTINRUB")));
     tableObj.SetValueCell("bodyline_f7",SQL_ConvTypeSum(DataSet.value("T_RESTINRUB_")) - SQL_ConvTypeSum(DataSet.value("T_RESTINRUB")));
     tableObj.SetValueCell("bodyline_f8",SQL_ConvTypeSum(DataSet.value("T_DEBITCUR_")));
     tableObj.SetValueCell("bodyline_f9",SQL_ConvTypeSum(DataSet.value("T_DEBITCUR")));
     tableObj.SetValueCell("bodyline_f10",SQL_ConvTypeSum(DataSet.value("T_DEBITCUR_")) - SQL_ConvTypeSum(DataSet.value("T_DEBITCUR")));
     tableObj.SetValueCell("bodyline_f11",SQL_ConvTypeSum(DataSet.value("T_DEBITRUB_")));
     tableObj.SetValueCell("bodyline_f12",SQL_ConvTypeSum(DataSet.value("T_DEBITRUB")));
     tableObj.SetValueCell("bodyline_f13",SQL_ConvTypeSum(DataSet.value("T_DEBITRUB_")) - SQL_ConvTypeSum(DataSet.value("T_DEBITRUB")));
     tableObj.SetValueCell("bodyline_f14",SQL_ConvTypeSum(DataSet.value("T_CREDITCUR_")));
     tableObj.SetValueCell("bodyline_f15",SQL_ConvTypeSum(DataSet.value("T_CREDITCUR")));
     tableObj.SetValueCell("bodyline_f16",SQL_ConvTypeSum(DataSet.value("T_CREDITCUR_")) - SQL_ConvTypeSum(DataSet.value("T_CREDITCUR")));
     tableObj.SetValueCell("bodyline_f17",SQL_ConvTypeSum(DataSet.value("T_CREDITRUB_")));
     tableObj.SetValueCell("bodyline_f18",SQL_ConvTypeSum(DataSet.value("T_CREDITRUB")));
     tableObj.SetValueCell("bodyline_f19",SQL_ConvTypeSum(DataSet.value("T_CREDITRUB_")) - SQL_ConvTypeSum(DataSet.value("T_CREDITRUB")));
     tableObj.SetValueCell("bodyline_f20",SQL_ConvTypeSum(DataSet.value("T_RESTOUTCUR_")));
     tableObj.SetValueCell("bodyline_f21",SQL_ConvTypeSum(DataSet.value("T_RESTOUTCUR")));
     tableObj.SetValueCell("bodyline_f22",SQL_ConvTypeSum(DataSet.value("T_RESTOUTCUR_")) - SQL_ConvTypeSum(DataSet.value("T_RESTOUTCUR")));
     tableObj.SetValueCell("bodyline_f23",SQL_ConvTypeSum(DataSet.value("T_RESTOUTRUB_")));
     tableObj.SetValueCell("bodyline_f24",SQL_ConvTypeSum(DataSet.value("T_RESTOUTRUB")));
     tableObj.SetValueCell("bodyline_f25",SQL_ConvTypeSum(DataSet.value("T_RESTOUTRUB_")) - SQL_ConvTypeSum(DataSet.value("T_RESTOUTRUB")));
     tableObj.SetValueCell("bodyline_f26",SQL_ConvTypeStr(DataSet.value("T_DETAILS")));
     tableObj.AddStr();
     FlOpenTxtFile = true;
     tableRowCount = tableRowCount + 1;
     if( Fl_SetDialog == 1 )
       UseProgress(tableRowCount);
     end;
   end;
 end;
 tableObj.EndTable();
 repTmpl.SetValue_NameCell("count_text", string(tableRowCount));

 if (not repTmpl.GetWorkbook().saveAs(fileSavePathExcel))
   RunError("Не удалось создать xlsx файл");
 end;

 if( Fl_SetDialog == 1 )
  RemProgress();
 end;

 //флаг выгрузки взведен
 if( FlOpenTxtFile )

   // DEF-71583 Возвращает имя файла в виде: Каталог(по параметру) дата + count(utableprocessevent_dbt) для ObjType 
   var ExportPath = GetExportPath( "РСХБ\\ИНТЕГРАЦИЯ\\ДИРЕКТОРИИ\\EXPORT\\ACCTCOMPAREDIR", ParamProcess.RestDate, 5008 );

   //копирование в ресурс из реестра
   RemoveFile(ExportPath);

   if( not CopyFile( fileSavePathExcel, ExportPath ) )
    RunError("Ошибка копирования файла  " + ExportPath);
   end;

   //отправляем в почту
   v_email_processor = Null;
   v_email_processor = c_email_proc_env();
   v_email_processor.m_set_msg_head("СОФР - Отчет результат сверки счетов ЦФТ и СОФР.");
   v_email_processor.m_add_row_to_msg_text("Результат сверки счетов ЦФТ и СОФР в файле " + ExportPath + ". Приложен.");
   v_email_processor.m_add_attach_to_list( ExportPath );
   v_email_processor.m_save_to_submit_grp(CV_EMAIL_GRP_ETCOMPARE, true);
   v_email_processor.m_submit_email_synch();
   v_email_processor = Null;
   //отправляем в почту
 end;
 // флаг выгрузки взведен

 // открываем пользователю локальную книгу
 if( ( Fl_SetDialog == 1 ) and (ExcelApplication == null) )
   var termFilePath = PathCombine2(GetCurDir(true),"txtfile",EXPORT_XML_FILENAME_TXT+CNum+"acct"+".xlsx");
   var FilePath, FileName, FileExt;
   FilePath = SplitFile(termFilePath, FileName, FileExt);

   if( not CopyFile( fileSavePathExcel, "$" + termFilePath) )
     RunError("Ошибка копирования файла  " + fileSavePathExcel);
   end;

   SC_ShowFile("$"+FilePath,FileName+FileExt);

 end;
 // открываем пользователю локальную книгу

 return true;

onError(err)
 errortext = GetFullErrorMessage(err, 1000);
 if (Fl_SetDialog == 1)
   MsgBox(errortext);
 end;
 AddDBLogWithErrorObj("AcctCompareRepLogic",err);
 TryToExcelQuit();
 return false;
end;
//Отчет-сверка счетов выгруженных в ЦФТ из СОФР

macro AcctCompareRep( ReqId :string, ParamProcess: object, Fl_SetDialog :integer, errortext:@String ) :bool
  //запускаем в отдельном экземпляре RSL, чтобы при новом пуске, все было чисто
  var result = false;
  var cnt = 0;
  //повторяем TRY_LIMIT раз, пока от AcctCompareRepLogic возвращается false
  while ((not result) and (cnt <= TRY_LIMIT))
    result = ExecMacroFile( "uacctcompare_rep.mac", "AcctCompareRepLogic", ReqId, ParamProcess, Fl_SetDialog, @errortext);
    RslWait(5000);
    cnt=cnt+1;
  end;
  return result;
end;
