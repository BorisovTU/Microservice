/*
$Name: RollbackOriginSNOB.mac
$Module: Ядро Securities
$Description: Откат операции начального решения для 7294
*/
import "nptxstbfun.mac";
import rsd;

/**
@brief  Создать бекап имеющихся записей в Хранилище СОФР путем переноса всех записей из таблицы dnptxtotalbase_dbt в таблицу dnptxtotalbase_bkp

Если таблица *bkp существует, она удаляется.
Новая таблица создается полной копией существуеющей dnptxtotalbase_dbt
*/
macro BackUpTable()
   var sql_str;
   var cmd;

   sql_str = String(
      "declare \n "+
      "   vcnt number; "+
      "   vtablename varchar2(200) := 'dnptxtotalbase_bkp'; "+
      "   vsql varchar2(200); "+
      "begin "+
      "   select count(*) into vcnt "+
      "     from user_tables where upper(table_name) = upper(vtablename); "+
      "   if vcnt > 0 then "+
      "      vsql := 'drop table '||vtablename; "+
      "      execute immediate vsql; "+
      "   end if; "+
      "   vsql := 'create table '||vtablename||' as select * from dnptxtotalbase_dbt'; "+
      "   execute immediate vsql; "+
      "end;");
   cmd = RSDCommand(sql_str);
   cmd.execute;
   cmd.close;
   // если выпадет в ошибку, так тому и быть
end;


/**
@brief Переотправка записей в хранилище СНОБ

Отобрать из таблицы dnptxtotalbase_dbt все записи имеющие статус = Активная.
Для каждой отобранной записи установить статус записи = Отменена, статус подтверждения записи = Не подтверждена, сформировать и отправить запрос на изменение 
статуса записи ChangeStatusSNOBReq с новыми параметрами подтверждения отобранных записей.
При получении успешного ответа от хранилища СНОБ о изменении статуса установить статус подтверждения в Хранилище СНОБ = Подтверждена
a.	Если в ответном сообщении получена ошибка 21 (уже отменена), то для записи установить статус = Подтверждена

*/
macro RunSendNewRequests
   var query, cmd, DataSet;
   var err, ErrStr, ai = 0, aj = 0;
   var FindSTB = TRecHandler("nptxtotalbase.dbt");
   var ChngReq = c_ChangeStatusSNOBRequest;
   ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList = TArray;
   var ChngResp;
   var STBArr = TArray;
   var ВремяОтвета = ВРЕМЯ_ОТВЕТА_ОТ_ХРАНИЛИЩА_СНОБ();
   
   // все записи 
   query =   " select * "
           + "   from dnptxtotalbase_dbt "
           + "  where t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE;
   cmd = DL_RSDCommand(query);
   DataSet = cmd.Execute();
   while (DataSet.moveNext())
      FindSTB.Clear();
      DataSet.GetRecord().CopyTo(FindSTB.rec);
      
      FindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; //Не подтверждена
      FindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        //Отмененная
      err = CheckAndSaveSTB(FindSTB);
      if(err)
         err = 1;
         ErrStr = "Ошибка при обновлении записи ";
      end;
      
      if (not err)
         ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[ai] = c_ChangeStatusInfo();
         ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[ai].RecordID = c_IntegrationSymbolicIdentifierXType();
         ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[ai].RecordID.ObjectID = FindSTB.rec.StorID;
         ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[ai].RecordStatus = c_IntegrationDictionaryRecordXType();
         ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[ai].RecordStatus.RecordCode = string(FindSTB.rec.StorState);
         STBArr.value(ai) = FindSTB;
         ai = ai+1;
      else 
         DL_NPTX_TbAddMsg(FindSTB.rec.TBID, ErrStr);
      end;
   end;
   
   if(ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList.size > 0)
      ChngResp = ChangeStatusSNOBReq(ChngReq);

      if((ChngResp == NULL) or (ValType(ChngResp) != V_GENOBJ) or
         (ChngResp.ChangeStatusInfoList == NULL) or
         (ChngResp.ChangeStatusInfoList.size == 0)
        )
         // ничего не вышло, ответ от хранилища не получен
         ai = 0;
         while(ai < STBArr.size)
            if((ChngResp != NULL) and (ChngResp.ErrorList != NULL) and (ChngResp.ErrorList.size > 0))
               DL_NPTX_TbAddMsg(STBArr[ai].rec.TBID, "Ошибка при обработке ответа от Хранилища СНОБ. Код ошибки: "+string(trim(ChngResp.ErrorList[0].ErrorCode))+" " + string(trim(ChngResp.ErrorList[0].ErrorDesc)));
            else
               DL_NPTX_TbAddMsg(STBArr[ai].rec.TBID, "Не получен ответ от Хранилища СНОБ в течение "+ВремяОтвета+" секунд");
            end;
            ai = ai + 1;
         end;
      else 
         // ответ получен, обработаем массив результатов
         ai = 0;
         while(ai < STBArr.size)
            //записям присваиваем Статус подтверждения записи в Хранилище  = подтверждена 
            //ID записи в хранилище = полученный в ответе от хранилища СНОБ ID созданной в нем записи
           
            if(ChngResp != NULL)
               aj = 0;
               while(aj < ChngResp.ChangeStatusInfoList.size)
                  if (ChngResp.ChangeStatusInfoList[aj].RecordID != NULL)
                     if(ChngResp.ChangeStatusInfoList[aj].RecordID.ObjectID == STBArr[ai].rec.StorID)

                        if(    ( ChngResp.ChangeStatusInfoList[aj].Error != NULL) 
                           and (    (int(ChngResp.ChangeStatusInfoList[aj].Error.ErrorCode) == 0) 
                                 or (int(ChngResp.ChangeStatusInfoList[aj].Error.ErrorCode) == 21)  )
                          )
                           STBArr[ai].rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_CONFIRMED;
                        else 
                           STBArr[ai].rec.IdentErrStr = ChngResp.ChangeStatusInfoList[aj].Error.ErrorDesc;
                        end;
                        break;
                     end;
                  end;
                  aj = aj + 1;
               end;
            end;

            if(0 != CheckAndSaveSTB(STBArr[ai]))
               ErrStr = "Ошибка при обновлении события СНОБ";
               DL_NPTX_TbAddMsg(STBArr[ai].rec.TBID, ErrStr);
            end;

            ai = ai + 1;
         end;
      end;
   end;
   err = DL_NPTX_SaveTbMes();
end;


/**
@brief  Откат выполненного начального решения по наполнению Хранилища СНОБ. В условиях, когда Хранилище СНОБ не имеет возможности очистки полученных записей
*/
macro RunRollbackOrigin
   BackUpTable;
   RunSendNewRequests;
   
end;


RunRollbackOrigin;