/**
 @file Quik_UnloadINIFiles.mac
 @brief Выгрузка файлов INI  ИТС QUIK

 Изначальная постановка по ТЗ:
 Требуется реализовать ежедневную выгрузку соответствия биржевых кодов в настроечные файлы системы ИТС QUIK 
 По валютному рынку соответствие кодов выгружается в файл codes.ini. Путь к директории файла указывается в настройке РСХБ\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\QUIK_CODES_INI
 По срочному рынку соответствие кодов выгружается в файл deallib.ini. Путь к директории файла указывается в настройке РСХБ\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\QUIK_DEALLIB_INI
 Выгрузка осуществляется планировщиком по расписанию (ежедневно, по умол-чанию в 05:00). Выгрузка производится по всем действующим договорам в статусе 'Обработка завершена'.

 # tag
 - functional_block: Клиенты_ЮЛ
 - code_type: API

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |03.09.2024 |Зыков М.В.     |BOSS-5119                                       |Корректное отображение стоимости по еврооблигациям в QUIK
 |00.00.2022 |Гераськина Т.В.|BIQ-7785                                        |Выгрузка соответствия биржевых кодов клиентов в ИТС QUIK

*/
import BankInter, rsexts, rsd,spserv;
import "ws_msg_transform_sec.mac";     /* для обработки ошибок */
import "global_classes.mac";
import dlcontrfunc; // BIQ-7041 для кода биржи Спб
import "u_common_email_utils.mac";

var FS_old, FS_new;
var data_str;

private var flag_edp = false;
private var EdpDate = "";
private var reg_value;

private var flag_spb = false;
private var SpbDate = "";

private const REG_EDP = "РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\ДАТА ВКЛЮЧЕНИЯ ЕДП";

const REG_QUIK_CODES_INI = "РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\QUIK\\CODES_INI";
const REG_QUIK_DEALLIB_INI = "РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\QUIK\\DEALLIB_INI";
const REG_QUIK_CROSSRATE_INI = "РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\QUIK\\CROSSRATE_INI";
var PATH_QUIK_CODES_INI;
var PATH_QUIK_DEALLIB_INI;
var PATH_QUIK_CROSSRATE_INI;

//DEF-36355 Список доступных фирм в справочнике
private const NUMBER_LLVALUE_FIRMID = 5053;

/**
@brief Выгрузка файла codes.ini - соответствие кодов по валютному рынку

Берется существующий файл codes.ini. Считается, что файл codes.ini существует и имеет корректную структуру до начала загрузки (хотя бы блок [MICEX] в файле есть).
Выгрузка находит в файле блок [MICEX] и начало следующего блока [ 
  и/или [SPB] и начало следующего блока [
Все, что между найденным, заменяется свежими данными. Остальные строки копируются из старого файла в новый как есть.
После выгрузки старый файл заменяется на новый.
*/
macro RunCreateCodesFile()

   var FS_old, FS_new;
   var file_line:string, data_str;
   var flag_begin_codes = false;
   var flag_end_codes = false;
   var flag_put_codes = false;
   var FileName = "codes.ini";
   var FileName_temp = "..\\TxtFile\\codes_today.ini";
   var FullFileName;
   var Dest_Path = "..\\TxtFile";
   var DL;

   var flag_begin_codes_spb = false;
   var flag_end_codes_spb = false;
   var flag_put_codes_spb = false;

   var ErrCode, ErrText;

   var sql_str, rs, cmd;
   var cnt=0; 

   private const REG_SPB = "РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\ДАТА ВКЛЮЧЕНИЯ СПБ";

   // выгрузка соответствия кодов необходима только при работе в режиме ЕДП
   reg_value = GetRegistryValue (REG_SPB, V_STRING, SpbDate );
   if (ValType(reg_value) != V_UNDEF)
      if ((SpbDate != "00.00.0000") and ({curdate} >= date(SpbDate)))
         flag_spb = true;
      end;
   end;

   var marketid = ПолучитьБиржуПоВидуКодаДБО(DLCCK_SPB_BIDCODE); 

   //println(time);
   
   GetRegistryValue(REG_QUIK_CODES_INI, V_STRING, PATH_QUIK_CODES_INI, ErrCode);
   if( ( ErrCode > 0 ) or (not PATH_QUIK_CODES_INI) )
      ErrText = "Настройка "+REG_QUIK_CODES_INI+" не найдена или отключена, выгрузка невозможна";
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;
   
   // в директории уже должен находится файл, поэтому считаем, что директория существует
   DL = TDirList(PATH_QUIK_CODES_INI+"\\"+FileName, "F");
   if (DL.Count == 0)               // файлов нет
      ErrText = "Файл "+PATH_QUIK_CODES_INI+"\\"+FileName+" отсутствует";
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   else 
      DL.Copy(PATH_QUIK_CODES_INI+"\\"+FileName, "", Dest_Path+"\\", false, false, ""); //скопируем к себе без индикатора
      if (DL.IsCopy(0))
         FullFileName = Dest_Path+"\\"+FileName;
      else
         ErrText = "Файл "+PATH_QUIK_CODES_INI+"\\"+FileName+" не удалось скопировать";
         RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
      end;
   end;
   
   FS_old = TStreamDoc(FullFileName, "R", "rsansi"); // только на чтение
   FS_new = TStreamDoc(FileName_temp, "C", "rsansi"); 
   
   //BegAction(2000);
   while (FS_old.readLine(@file_line))
      if ( (not flag_begin_codes) and (Index(StrUpr(file_line), "[MICEX]") > 0 ) ) // нашли начало кодов
         flag_begin_codes = true;
         flag_end_codes = false;
         data_str = "[MICEX]";
         FS_new.WriteLine( data_str );
         data_str = "by_prefix=1";
         FS_new.WriteLine( data_str );
         data_str = "leave_comment=1";
         FS_new.WriteLine( data_str );
      end;
      if ( flag_begin_codes and (Index(StrUpr(file_line), "[MICEX]") == 0) and (Index(file_line, "[") > 0 )) // после начала кодов первая квадратная скобка
         flag_end_codes = true;
      end; 

      if (flag_spb)
         if ( (not flag_begin_codes_spb) and (Index(StrUpr(file_line), "[SPB]") > 0 ) ) // нашли начало кодов Спб
            flag_begin_codes_spb = true;
            flag_end_codes_spb = false;
            data_str = "[SPB]";
            FS_new.WriteLine( data_str );
            data_str = "by_prefix=1";
            FS_new.WriteLine( data_str );
            data_str = "leave_comment=1";
            FS_new.WriteLine( data_str );
            data_str = "leave_prefix=1";
            FS_new.WriteLine( data_str );
         end;
         if ( flag_begin_codes_spb and (Index(StrUpr(file_line), "[SPB]") == 0) and (Index(file_line, "[") > 0 )) // после начала кодов первая квадратная скобка
            flag_end_codes_spb = true;
         end; 
      end;

      if ( ( (not flag_begin_codes) or flag_end_codes )
           and ( (not flag_begin_codes_spb) or flag_end_codes_spb )
           ) // еще не нашли коды или уже закончились
         data_str = file_line;
         FS_new.WriteLine( data_str );
      else
         if ( (not flag_put_codes) and flag_begin_codes) // еще не записывали коды
            sql_str = "select mp.t_mpcode, obj.t_code "+
                      "  from dsfcontr_dbt sf, "+
                      "       ddlcontrmp_dbt mp, "+
                      "       ddlcontr_dbt dl, "+
                      "       ddlobjcode_dbt obj "+
                      " where sf.t_id = mp.t_sfcontrid "+
                      "   and dl.t_dlcontrid = mp.t_dlcontrid "+
                      "   and obj.t_codekind = 1 and obj.t_objecttype = 207 and obj.t_objectid = dl.t_dlcontrid and obj.t_bankclosedate = to_date('01.01.0001', 'dd.mm.yyyy') "+
                      "   and t_servkind = 21 and t_servkindsub = 8 and t_dateclose = to_date('01.01.0001', 'dd.mm.yyyy')"+
                      "   and exists (select 1 from dobjatcor_dbt o where o.t_objecttype = 207 and o.t_groupid = 101 "+
                      "                 and o.t_attrid = 3 and (o.t_validtodate >= sysdate or o.t_validtodate = to_date('01.01.0001','dd.mm.yyyy')) "+
                      "                 and lpad(dl.t_dlcontrid,34,'0') = o.t_object ) "+
                      "   and exists ( select 1 from dobjatcor_dbt o where o.t_objecttype = 659 and o.t_groupid = 102 "+
                      "                  and (o.t_validtodate >= sysdate or o.t_validtodate = to_date('01.01.0001','dd.mm.yyyy')) "+
                      "                  and o.t_object = lpad(sf.t_id,10,'0') and o.t_attrid = 1 )  ";

            cmd = RSDCommand(sql_str);
            rs = RSDRecordSet(cmd);
            while (rs.movenext)
               if ( (Substr(rs.value("t_code"),1,2) == "CM" ) or (Substr(rs.value("t_mpcode"),1,2) == "CM") )
                  continue;
               end;
               data_str = rs.value("t_code")+"/="+rs.value("t_mpcode")+"/"; 
               FS_new.WriteLine( data_str );
               Cnt = Cnt+1;
            end;
            flag_put_codes = true;
         end;

         if (flag_spb)
            if ( (not flag_put_codes_spb) and flag_begin_codes_spb) // еще не записывали коды
               sql_str = "select mp.t_mpcode, obj.t_code "+
                         "  from dsfcontr_dbt sf, "+
                         "       ddlcontrmp_dbt mp, "+
                         "       ddlcontr_dbt dl, "+
                         "       ddlobjcode_dbt obj "+
                         " where sf.t_id = mp.t_sfcontrid "+
                         "   and dl.t_dlcontrid = mp.t_dlcontrid "+
                         "   and obj.t_codekind = 1 and obj.t_objecttype = 207 and obj.t_objectid = dl.t_dlcontrid and obj.t_bankclosedate = to_date('01.01.0001', 'dd.mm.yyyy') "+
                         "   and t_servkind = 1 and t_servkindsub = 8 and mp.t_marketid = "+marketid+" and t_dateclose = to_date('01.01.0001', 'dd.mm.yyyy')"+
                         "   and exists (select 1 from dobjatcor_dbt o where o.t_objecttype = 207 and o.t_groupid = 101 "+
                         "                 and o.t_attrid = 3 and (o.t_validtodate >= sysdate or o.t_validtodate = to_date('01.01.0001','dd.mm.yyyy')) "+
                         "                 and lpad(dl.t_dlcontrid,34,'0') = o.t_object ) "+
                         "   and exists ( select 1 from dobjatcor_dbt o where o.t_objecttype = 659 and o.t_groupid = 102 "+
                         "                  and (o.t_validtodate >= sysdate or o.t_validtodate = to_date('01.01.0001','dd.mm.yyyy')) "+
                         "                  and o.t_object = lpad(sf.t_id,10,'0') and o.t_attrid = 1 ) ";

               cmd = RSDCommand(sql_str);
               rs = RSDRecordSet(cmd);
               while (rs.movenext)
                  if ( (Substr(rs.value("t_code"),1,2) == "CM" ) or (Substr(rs.value("t_mpcode"),1,2) == "CM") )
                     continue;
                  end;
                  data_str = rs.value("t_code")+"/="+rs.value("t_mpcode")+"/"; 
                  FS_new.WriteLine( data_str );
                  Cnt = Cnt+1;
               end;
               flag_put_codes_spb = true;
            end;
         end;

      end;

   end;

      
   FS_old = NULL;
   FS_new = NULL;
   //EndAction;
   
   // переименуем новый файл в старый
   DL.Remove(FullFileName, "F"); 
   if (not RenameFile (FileName_temp, FullFileName))
      ErrText = "Не удалось переименовать "+FileName_temp+" в "+FullFileName;
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;
   // переносим в исходную директорию новый файл
   DL.Copy(FullFileName, "", PATH_QUIK_CODES_INI+"\\", true, false, ""); 
   if (DL.IsCopy(0))
   else
      ErrText = "Файл "+FullFileName+" не удалось перенести в "+PATH_QUIK_CODES_INI;
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;

   //println(cnt);
   //println(time);

end;

/**
@brief Проверка существования и создание при необходимости временной таблицы для кодов по срочному рынку

Коды срочного рынка из ddlcontrmp_dbt сначала заносятся во временную таблицу, а потом переносятся в файл.
*/
macro CheckAndCreateTable()
   var sql_str, cmd;
   sql_str = 
      " declare "+
      "    cnt number(10);  "+
      " begin  "+
      "    select count(*) into cnt from user_tables  "+
      "    where table_name = upper('uTable_deallib_ini'); "+
      "    if cnt =  0 then "+
      "        execute immediate 'create global temporary table uTable_deallib_ini ( "+
      "            code varchar2(35 byte),  "+
      "            mpcode varchar2(30 byte), "+
      "            isfix varchar2(1) "+
      "        ) "+
      "        on commit preserve rows'; "+
      "    end if; "+
      "end;";
   cmd = RSDCommand(sql_str);
   cmd.execute;
   cmd.close;
   cmd = null; sql_str = null;
end;

/**
@brief Подготовка сведений для файла deallib.ini - запись в таблицу uTable_deallib_ini

Коды срочного рынка из ddlcontrmp_dbt сначала заносятся во временную таблицу, а потом переносятся в файл.
*/
macro FillCodesIntoTable
   var sql_str, cmd;
   sql_str = " begin "+
             "   delete from uTable_deallib_ini; "+
             "   insert into uTable_deallib_ini (code, mpcode, isfix) "+
             "   select obj.t_code, mp.t_mpcode, 'N' "+
             "     from dsfcontr_dbt sf, "+
             "          ddlcontrmp_dbt mp, "+
             "          ddlcontr_dbt dl, "+
             "          ddlobjcode_dbt obj "+
             "    where sf.t_id = mp.t_sfcontrid "+
             "      and dl.t_dlcontrid = mp.t_dlcontrid "+
             "      and sf.t_partyid <> 1 "+
             "      and obj.t_codekind = 1 and obj.t_objecttype = 207 and obj.t_objectid = dl.t_dlcontrid and obj.t_bankclosedate = to_date('01.01.0001', 'dd.mm.yyyy') "+
             "      and t_servkind = 15 and t_servkindsub = 8 and t_dateclose = to_date('01.01.0001', 'dd.mm.yyyy')"+
             "      and exists (select 1 from dobjatcor_dbt o where o.t_objecttype = 207 and o.t_groupid = 101 "+
             "                    and o.t_attrid = 3 and (o.t_validtodate >= sysdate or o.t_validtodate = to_date('01.01.0001','dd.mm.yyyy')) "+
             "                    and lpad(dl.t_dlcontrid,34,'0') = o.t_object ) "+
             "      and exists ( select 1 from dobjatcor_dbt o where o.t_objecttype = 659 and o.t_groupid = 102 "+
             "                     and (o.t_validtodate >= sysdate or o.t_validtodate = to_date('01.01.0001','dd.mm.yyyy')) "+
             "                     and o.t_object = lpad(sf.t_id,10,'0') and o.t_attrid = 1 ); "+
             " end;";
   cmd = RSDCommand(sql_str);
   cmd.execute;
   cmd.close;
   cmd = null; sql_str = null;
end;

/**
@brief Обновление строки таблицы 
@param[in] _rowid  rowid существующей записи в таблице
*/
macro UpdateTableLine(_rowid)
   var sql_str, cmd;
   sql_str = "update uTable_deallib_ini "+
             "   set isfix = 'Y' "+
             " where rowid = :r";
   cmd = RSDCommand(sql_str);
   cmd.AddParam("r", RSDBP_IN, _rowid);
   cmd.execute;
   cmd.close;
   cmd = null; sql_str = null;
end;

/**
@brief Запись обработанных записей из uTable_deallib_ini в файл deallib.ini
@param[in] _condition доп.условие для селекта
@param[in] _name имя секции
@param[in] _need_title признак необходимости добавить имя секции в файл
*/
macro PutCodes(_condition, _name, _need_title)
   var sql_str, cmd, rs;
   var cnt = 0;
   
   sql_str = "select d.*, rowid from uTable_deallib_ini d "+
             " where isfix = 'N' and substr(mpcode, 1,2) != 'CM' and "+_condition;
   cmd = RSDCommand(" select count(*) cnt from ("+sql_str+")");
   rs = RSDRecordSet(cmd);
   if (rs.movenext)
      cnt = rs.value("cnt");
   end;
   cmd.close; rs.close;
      
   if (cnt > 0)
      if (_need_title)
         data_str = _name;
         FS_new.WriteLine( data_str );
      end;
      cmd = RSDCommand(sql_str);
      rs = RSDRecordSet(cmd);
      while (rs.movenext)
         data_str = rs.value("code")+"=CL"+rs.value("mpcode"); 
         FS_new.WriteLine( data_str );
         UpdateTableLine(rs.value("rowid"));
      end;
   end;
   
   return cnt;
end;

/**
@brief Выгрузка файла deallib.ini - соответствие кодов по срочному рынку

Берется существующий файл deallib.ini. Считается, что файл deallib.ini существует и имеет корректную структуру до начала загрузки (хотя бы один блок [ChangeFutClientCodes_SPBFUTF50*] в файле есть).
Выгрузка находит в файле блок [ChangeFutClientCodes_SPBFUTF50 и начало следующего блока [ 
Все, что между найденным, заменяется свежими данными. Остальные строки копируются из старого файла в новый как есть.
После выгрузки старый файл заменяется на новый.
*/
macro RunCreateDeallibFile()

   var file_line:string;
   var flag_begin_codes = false;
   var flag_end_codes = false;
   var flag_put_codes = false;
   var FileName = "deallib.ini";
   var FileName_temp = "..\\TxtFile\\deallib_today.ini";
   var FullFileName;
   var Dest_Path = "..\\TxtFile";
   var DL;

   var ErrCode, ErrText;

   var sql_str, rs, cmd;
   var cnt=0; 
   var cnt_part=0;

   //DEF-36355 список фирм в справочнике 
   var firmname, section_name;

   //println(time);
   
   GetRegistryValue(REG_QUIK_DEALLIB_INI, V_STRING, PATH_QUIK_DEALLIB_INI, ErrCode);
   if( ( ErrCode > 0 ) or (not PATH_QUIK_DEALLIB_INI) )
      ErrText = "Настройка "+REG_QUIK_DEALLIB_INI+" не найдена или отключена, выгрузка невозможна";
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;
   
   // в директории уже должен находится файл, поэтому считаем, что директория существует
   DL = TDirList(PATH_QUIK_DEALLIB_INI+"\\"+FileName, "F");
   if (DL.Count == 0)               // файлов нет
      ErrText = "Файл "+PATH_QUIK_DEALLIB_INI+"\\"+FileName+" отсутствует";
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   else 
      DL.Copy(PATH_QUIK_DEALLIB_INI+"\\"+FileName, "", Dest_Path+"\\", false, false, ""); //скопируем к себе без индикатора
      if (DL.IsCopy(0))
         FullFileName = Dest_Path+"\\"+FileName;
      else
         ErrText = "Файл "+PATH_QUIK_DEALLIB_INI+"\\"+FileName+" не удалось скопировать";
         RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
      end;
   end;
   
   CheckAndCreateTable();
   FillCodesIntoTable();
   
   FS_old = TStreamDoc(FullFileName, "R", "rsansi"); // только на чтение
   FS_new = TStreamDoc(FileName_temp, "C", "rsansi"); 
   
   //BegAction(2000);
   while (FS_old.readLine(@file_line))
      if ( (not flag_begin_codes) and (Index(StrUpr(file_line), StrUpr("[ChangeFutClientCodes_SPBFUTF50")) > 0 ) ) // нашли начало кодов
         flag_begin_codes = true;
         flag_end_codes = false;
         data_str = file_line;
         //FS_new.WriteLine( data_str );
      end;
      if ( flag_begin_codes and (Index(StrUpr(file_line), StrUpr("[ChangeFutClientCodes_SPBFUTF50")) == 0) and (Index(file_line, "[") > 0 )) // после начала кодов первая квадратная скобка
         flag_end_codes = true;
      end; 

      if ( (not flag_begin_codes) or flag_end_codes ) // еще не нашли коды или уже закончились
         data_str = file_line;
         FS_new.WriteLine( data_str );
      else
         if (not flag_put_codes) // еще не записывали коды

            // каждая новая фирма заносится в отдельный блок. Список фирм - в справочнике 5053
            sql_str = "select t_code from dllvalues_dbt where t_list = "+NUMBER_LLVALUE_FIRMID+" order by t_element";
            rs = RSDRecordSet(sql_str);
            while (rs.movenext)
               firmname = rs.value("t_code");
               section_name = "[ChangeFutClientCodes_SPBFUT"+firmname+"]";

               if (firmname == "F502")
                  // "нестандартные" коды пишутся тоже в секцию F502 
                  cnt_part = PutCodes(" substr(mpcode, 1,2 ) <> 'F5' ", section_name, true);
                  cnt = cnt + cnt_part;
                  
                  if (cnt_part > 0) // было что заполнить, значит, заголовок больше не нужен
                     cnt_part = PutCodes(" substr(mpcode, 1,4 ) = '"+firmname+"' ", section_name, false);
                  else
                     cnt_part = PutCodes(" substr(mpcode, 1,4 ) = '"+firmname+"' ", section_name, true);
                  end;
                  cnt = cnt + cnt_part;
               else 
                  cnt_part = PutCodes(" substr(mpcode, 1,4 ) = '"+firmname+"' ", section_name, true);
                  cnt = cnt + cnt_part;
               end;
            end;
 
            flag_put_codes = true;
         end;
      end;
   end;
      
   FS_old = NULL;
   FS_new = NULL;
   //EndAction;
   
   // переименуем новый файл в старый
   DL.Remove(FullFileName, "F"); 
   if (not RenameFile (FileName_temp, FullFileName))
      ErrText = "Не удалось переименовать "+FileName_temp+" в "+FullFileName;
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;
   // переносим в исходную директорию новый файл
   DL.Copy(FullFileName, "", PATH_QUIK_DEALLIB_INI+"\\", true, false, ""); 
   if (DL.IsCopy(0))
   else
      ErrText = "Файл "+FullFileName+" не удалось перенести в "+PATH_QUIK_DEALLIB_INI;
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;

   //println(cnt);
   //println(time);
end;

private macro LineAddCRLF(sdata:string,line:string):string
 if (strlen(sdata)> 0)
  return sdata+StrFor(13)+StrFor(10)+line;
 else
  return line;
 end;
end;

// отправка уведомления
macro SendNotification(EmailText)
  var Subject, v_email_processor, mg =false;
  
  var err_reg;
  var email_group;
  v_email_processor = c_email_proc_env();

  GetRegistryValue("РСХБ\\ИНТЕГРАЦИЯ\\SEND_NOTIFY_BO", V_INTEGER, email_group, err_reg);
  if ( not err_reg)
     mg = true ;
     v_email_processor.m_get_email_group(email_group);
  end;

  var cmd = RsdCommand("select min(t_element) email_group from dllvalues_dbt t where t_list= 5009 and t_flag = 1 and t_name = 'SUPPORT_QUIK'");
  cmd.Execute();
  var rs = TRsbDataSet(cmd);
  if (rs.movenext())
     mg = true ;
     v_email_processor.m_get_email_group(rs.email_group);
  end;
  if (mg)
    Subject = "Ошибка обновления файла crossrate.ini в ИТС QUIK";

    v_email_processor.m_set_msg_head(Subject);
    v_email_processor.m_add_row_to_msg_text(EmailText);
    v_email_processor.m_save_to_submit_synch;
  end;
end;

macro RunCreateCrossRateFile()

   var ErrCode=0,ErrText;
   var FileName = "crossrate.ini";
   var DL;
   var Dest_Path = "..\\TxtFile";
   var FullFileName;
   var FileName_temp = "..\\TxtFile\\crossrate_today.ini";
   var file_line:string, data_str;
   var flag_begin_codes = false;
   var flag_end_codes = false;
   var crossrate = "";
   crossrate = LineAddCRLF(crossrate,"[crossrate_rate]");
   crossrate = LineAddCRLF(crossrate,"SUR=1");
   crossrate = LineAddCRLF(crossrate,"RUR=1");
   var scur ;
   var sql_str, rs, cmd,rate, Error, SinceDate;
   var cnt=0,poz=0,fiid ; 


   GetRegistryValue(REG_QUIK_CROSSRATE_INI, V_STRING, PATH_QUIK_CROSSRATE_INI, ErrCode);
   if( ( ErrCode > 0 ) or (not PATH_QUIK_CROSSRATE_INI) )
      ErrText = "Настройка "+PATH_QUIK_CROSSRATE_INI+" не найдена или отключена, выгрузка невозможна";
      SendNotification(ErrText);
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;
   
   // в директории уже должен находится файл, поэтому считаем, что директория существует
   DL = TDirList(PATH_QUIK_CROSSRATE_INI+"\\"+FileName, "F");
   if (DL.Count == 0)               // файлов нет
      ErrText = "Файл "+PATH_QUIK_CROSSRATE_INI+"\\"+FileName+" отсутствует";
      SendNotification(ErrText);
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   else 
      DL.Copy(PATH_QUIK_CROSSRATE_INI+"\\"+FileName, "", Dest_Path+"\\", false, false, ""); //скопируем к себе без индикатора
      if (DL.IsCopy(0))
         FullFileName = Dest_Path+"\\"+FileName;
      else
         ErrText = "Файл "+PATH_QUIK_CROSSRATE_INI+"\\"+FileName+" не удалось скопировать";
         SendNotification(ErrText);
         RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
      end;
   end;
   
   FS_old = TStreamDoc(FullFileName, "R", "rsansi"); // только на чтение
   FS_new = TStreamDoc(FileName_temp, "C", "rsansi"); 
   
   //BegAction(2000);
   ErrText ="";
   while (FS_old.readLine(@file_line))
     FS_new.WriteLine( file_line );
     if (Index(StrUpr(file_line), "[CROSSRATE]") > 0 )  // нашли начало кодов
       flag_begin_codes = true;
       continue;
     end;
     if (flag_begin_codes) 
       if (substr(file_line,4,1) == "=")
         scur = substr(file_line,1,3) ;
         if  ((scur != "SUR") and (scur != "RUR") )
           cmd = RsdCommand("select f.t_fiid from dfininstr_dbt f where t_fi_kind = 1 and t_ccy = :scur");
           cmd.AddParam("",RSDBP_IN,scur);
           cmd.Execute();
           rs = TRsbDataSet(cmd);
           if (rs.movenext())
             fiid = int(rs.fiid);
             poz = Index (file_line, ",",poz+1);
             poz = Index (file_line, ",",poz+1); // Вторая запятая 
             if (poz>0)
               cnt=int(Trim(substr(file_line,poz+1)));
               rate = GetRateOnDateCrossDbl( date(), fiid, NATCUR, false,0, @Error, @SinceDate ) ;
               if (rate != 0)
                 rate =trim(string(rate));
                 poz = Index (rate, ".") ;
                 if (cnt == 0 ) 
                   rate = substr(rate,1,poz-1); 
                 else         
                   rate = substr(rate,1,poz+cnt); 
                 end;
                 crossrate = LineAddCRLF(crossrate,(scur+"="+rate));
                 if (SinceDate != date())
                   ErrText = ErrText+"По валюте "+scur+" отсутствует курс на дату "+string(date())+".В файл выгружено значение за дату "+string(SinceDate)+"\n";
                 end ;
               else
                  ErrText = ErrText+"Для валюты  "+scur+" не определен курс \n";
               end ;
             else
               ErrText = ErrText+"Для строки '"+file_line+"' не определена разрядность значения курса \n";
             end;
           else
             ErrText = ErrText+"Для строки '"+file_line+"' не определена валюта \n";
           end ;
         end;
       else
         FS_new.WriteLine( crossrate );
         flag_begin_codes = false;
         break;
       end;
     end;
   end;
        
   FS_old = NULL;
   FS_new = NULL;
   //EndAction;
   if (strLen(ErrText)>0)
     SendNotification(ErrText);
   end;
   // переименуем новый файл в старый
   DL.Remove(FullFileName, "F"); 
   if (not RenameFile (FileName_temp, FullFileName))
      ErrText = "Не удалось переименовать "+FileName_temp+" в "+FullFileName;
      SendNotification(ErrText);
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;
   // переносим в исходную директорию новый файл
   DL.Copy(FullFileName, "", PATH_QUIK_CROSSRATE_INI+"\\", true, false, ""); 
   if (DL.IsCopy(0))
   else
      ErrText = "Файл "+FullFileName+" не удалось перенести в "+PATH_QUIK_CROSSRATE_INI;
      SendNotification(ErrText);
      RunError(ErrText, c_err_obj(ErrText,UNIVERSAL_ERROR_CODE));
   end;

   //println(cnt);
   //println(time);

end;


macro GetBOOLRegistry(addRevisePath): bool
  var res = false, err;
  GetRegistryValue( addRevisePath, V_BOOL, res, err );
  if ( err != 0 )
    RunError("Ошибка при получении значения настройки \"" + addRevisePath + "\"")
  end;
  return res;
end;



/**
@brief Основная процедура выгрузки кодов. Запускается планировщиком или из интерфейса из отдельного меню
*/
macro QUIK_ReFillCodes()
  var out_obj = c_Error();

  reg_value = GetRegistryValue (REG_EDP, V_STRING, EdpDate );
  if (ValType(reg_value) != V_UNDEF)
     if ((EdpDate != "00.00.0000") and ({curdate} >= date(EdpDate)))
        flag_edp = true;
     end;
  end;

  if (flag_edp)
    if (GetBOOLRegistry("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\QUIK\\ВЫГРУЖАТЬ CODES.INI") )
      RunCreateCodesFile();
    end;
    if (GetBOOLRegistry("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\QUIK\\ВЫГРУЖАТЬ DEALSLIB.INI") )
      RunCreateDeallibFile();
    end;
  end;
  if (GetBOOLRegistry("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\QUIK\\ВЫГРУЖАТЬ CROSSRATE.INI") )
    RunCreateCrossRateFile();
  end;
  out_obj.ErrorCode = 0;
  out_obj.ErrorDesc = "OK";

  return out_obj;

onError(err)
   out_obj = c_Error;
   out_obj.ErrorCode = c_err_obj.obtain_err_code(err);
   out_obj.ErrorDesc = c_err_obj.obtain_err_msg(err);

   return out_obj;
end;


