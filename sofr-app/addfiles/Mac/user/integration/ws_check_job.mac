/**
 @file 		ws_check_job.mac
 @brief 	Интеграция с внешними системами. Сервис обработчика потоков. Запуск по Sheduler

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |02.04.2025 |Велигжанин А.В.|DEF-86745                                       |Доработка ws_check_job_Event(), поправлено условие создания
 |           |               |                                                |для funcobj (нужно проверять с учетом T_OBJECTTYPE)
 |08.11.2018 |А.Киселев      |                                                |Сервис обработчика потоков. Запуск по Sheduler
*/
import globals, oralib, likepy;
import "usequence_job.mac";
//import "global_utils_intgr.mac";
import "u_common_email_utils.mac";
import "ws_msg_transform_sec.mac";
import "usr_table_int.mac";
import "IISContrMonitor_Reports.mac";
import "weekly_number_clients_Report.mac";
import "cblogger2.mac";
import "ws_quik_data_load.mac";
import "TransactionHelper.mac";

/*---------------------------------------------------------*/
/* На случай отсутствия макроса simple_service.mac - begin */
private var SS_RESPONSE_REPEAT_OK = 0; /* Продолжение попытки выполнить исполняемую процедуру (функцию) после успешного исполнения */
private var SS_RESPONSE_REPEAT_ERROR = 1; /* Продолжение попытки выполнить исполняемую процедуру (функцию) после ошибки */
private var SS_RESPONSE_NEXT = 2; /* Успешное завершение работы метода - переход к следующему методу */
private var SS_RESPONSE_END = 3; /* Успешное завершение всего сервиса */
private var SS_RESPONSE_FATAL = 4; /* Ошибка исполнения, обработка всей цепочки прерывается */
private var SS_RESPONSE_PROXY = 5; /* Запрос отправлен во внешнюю систему через Proxy, требуется перриодический анализ изменения состояния */

/* BIQ-7335 Гераськина Т.В. Константы вынесены в заголовок */
private const C_SOFR_CONTRBO = 9;
private const C_SOFR_NOB_IN = 20;
private const C_SOFR_NOB_OUT = 21;
private const C_SOFR_NOB_IN_UNDO = 29;
private const C_EVENT_STAT_NEW = 1;
private const C_EVENT_STAT_READY = 2;
private const C_EVENT_STAT_RUNNING = 3;
private const C_PROC_OUT_ARCH = 4;
private const C_PROC_OUT_ERR = 5;
private const CV_LIST_VALUES = 5002;

/*BIQ-8258*/
private const CONTRACT_CATEGORY_DOC_CLOSE = 122; 
private const BROKER_SERV_CONTR = 207;
private const IS_ANOTHER_CONTRACT_IIS = 121; 
private const CONTARCT_NOTEKIND_DATE_CLOSE_ISANOTHERCONTRACT = 175; 
private const BROKERCONTRACT_EMAIL_GRP = 16;

/*BOSS-8797*/
private const RepNumClients_EMAIL_GRP = 16;

private class c_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText)
   var ProcessState;
   var ErrorNumber;
   var ErrorText;

   private macro init_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText)
      if(ValType(p_ProcessState) != V_UNDEF)
         ProcessState = p_ProcessState;
      end;
      if(ValType(p_ErrorNumber) != V_UNDEF)
         ErrorNumber = p_ErrorNumber;
      end;
      if(ValType(p_ErrorText) != V_UNDEF)
         ErrorText = p_ErrorText;
      end;
   end;

   init_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText);
end;

/* На случай отсутствия макроса simple_service.mac - end   */
/*---------------------------------------------------------*/


//Получим значение из строки со спец. разделителями
private macro ParsePriority( StrParam :variant ) :integer
      var StrDigit :string = "0123456789",
          StrParamBuf :string = "",
          StrParamPriority :string = "",
          i :integer = 0,
          StrPos :integer = 0,
          SymbOpen :string = "<",
          SymbClose :string = ">",
          FlSymbClose :bool = false;

      if( (Valtype(StrParam) != V_UNDEF) and (Valtype(StrParam) != 26) and (StrParam != "") )

         i = 1;
         StrPos = 0;
         while( i <= StrLen(StrParam) ) //Вырезать часть со спец. разделителями

          if( (StrPos > 0) and ( Substr(StrParam, i, 1) != SymbClose ) )
           StrParamPriority = StrParamPriority + Substr(StrParam, i, 1);
          end;

          if( Substr(StrParam, i, 1) == SymbOpen )
           StrPos = i;
          end;

          if( Substr(StrParam, i, 1) == SymbClose )
           StrPos = -1;
           FlSymbClose = true;
          end;

          if( ((StrPos == 0 ) or (StrPos == -1)) and (Substr(StrParam, i, 1) != SymbOpen) and (Substr(StrParam, i, 1) != SymbClose) )
            StrParamBuf = StrParamBuf + Substr(StrParam, i, 1);
          end;
          i = i + 1;

         end;

         StrParam = StrParamBuf;
         StrParamBuf = "";

         if( not FlSymbClose )
          return 0;
         end;

         i = 1;
         while( i <= StrLen(StrParamPriority) ) //нормализация оставить, что только цифры

            if( Index( (StrDigit), Substr(StrParamPriority, i, 1) ) >= 1 )
               StrParamBuf = StrParamBuf + Substr(StrParamPriority, i, 1);
            end;
            i = i + 1;

         end;

         StrParamPriority = StrParamBuf;
         StrParamBuf = "";

      end;

      return int( StrParamPriority );

onError(err)

   return 0;


end;



//Обработчик исходящих потоков вызов по Sheduler
macro ws_check_job_Out() :object
var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;

  Params = Null;
  DataSet = Null;

//переделан objects на пользовательский справочник llvalues
/*
  Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, 1 AS T_TYPE, " +
          "  (SELECT B.T_CODE FROM dobjects_dbt B " +
          "   WHERE B.T_OBJECTTYPE = A.T_OBJECTTYPE ) AS T_CODE " + 
          " FROM uTableProcessOut_dbt A" +

          " WHERE A.T_STATUS = :p_Status ";
*/

  Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, 1 AS T_TYPE, " +
          "  (SELECT B.T_CODE FROM dllvalues_dbt B " +
          "   WHERE B.T_LIST = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH" + 
          "    AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_CODE " + 
          " FROM uTableProcessOut_dbt A" +
          " WHERE A.T_STATUS = :p_Status ";



  Params = makeArray( SQLParam( "p_Status", 1 ));  //формируется
  DataSet = execSQLselect( Query, Params );

  while( DataSet.MoveNext ) //создание записи в очереди

   if( InsertSequenceJobUsrObj( DataSet.value(0, Null, V_INTEGER), DataSet.value(1, Null, V_INTEGER),
    DataSet.value(2, Null, V_INTEGER), DataSet.value(3, Null, V_STRING)) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
   else
    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

  end;


  Params = Null;
  DataSet = Null;

  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;


//Обработчик исходящих потоков статус 12 снимает ожидание события OpenAccount
macro ws_check_job_Status12() :object

var Query :string = "",
    ResultSheduler :object;
var v_cmd;
var v_is_err = 0;

  Query = " DECLARE " +
          "    v_ret              INTEGER := 0; " +
          "    v_stat_nt          utableprocessevent_dbt.t_status%TYPE := ?; " +
          "    v_stat_r           utableprocessevent_dbt.t_status%TYPE := ?; " +
          " BEGIN " +
          "    BEGIN " +


          "        UPDATE utableprocessevent_dbt " +
          "           SET t_status = v_stat_r " +
          "         WHERE t_objecttype IN(1, 501) " +
          "           AND t_status = v_stat_nt; " +

          "    EXCEPTION " +
          "        WHEN OTHERS " +
          "        THEN " +
          "            v_ret := 1; " +

          "    END; " +

          "    ? := v_ret; " +
          " END; ";

  v_cmd = RSDCommand( Query );
  v_cmd.addParam("p_stat_nt", RSDBP_IN, 12  /*CV_STAT_WAIT_TRANSFER*/);
  v_cmd.addParam("p_stat_r", RSDBP_IN, 1 /*CV_STAT_READY*/ );
  v_cmd.addParam("p_result", RSDBP_OUT, V_INTEGER);
  v_cmd.execute();

  v_is_err = v_cmd.value("p_result");

  v_cmd.close(); v_cmd = NULL;

  if(v_is_err == 0)
   ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  end;

  return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end; /* macro ws_check_job_Status12() */



//Обработчик исходящих потоков типа Fast вызов по Sheduler
macro ws_check_job_Event() :object
const CV_USRFLD_NOT_TRANSFER = "1";
const CV_STAT_NOT_TRANSFER = -1420; /* NT - abcdefghijklmnopqrst */
const CV_STAT_READY = 1;
const CV_STAT_ERR = 5;
const CV_OBJ_TYPE_TRN = 1;
const CV_EVNT_TYPE_DEL = 3;

var Query :string = "", v_Query :string = "",
    Params :TArray, v_Params :TArray,
    DataSet :RsdRecordset, v_DataSet :RsdRecordset,
    ResultSheduler :object;
var v_sql, v_cmd, cmd;
var v_is_err = 0;
var regpath ="РСХБ\\ИНТЕГРАЦИЯ\\NUMBER_OF_ENTRIES_FOR_FUNCOBJ";
var number_funcobj = 0 ,stat;

  Params = Null;
  DataSet = Null;

//вывод информации о сессии в it_log для диагностики DEF-98163
  cmd = RSDCommand("begin it_log.log_handle('ws_check_job_Event',:p_text,it_log.C_MSG_TYPE__DEBUG); end;");
  cmd.AddParam("p_text", RSDBP_IN, "Начало: апдейт UTABLEPROCESSEVENT_DBT ");
  cmd.execute;
  cmd.close; cmd=null;

  v_sql =         "DECLARE ";
  v_sql = v_sql + "    v_ret NUMBER(5) := 0; ";
  v_sql = v_sql + "    v_stat_nt utableprocessevent_dbt.t_status%TYPE := :p_stat_nt; ";
  v_sql = v_sql + "    v_stat_err utableprocessevent_dbt.t_status%TYPE := :p_stat_err; ";
  v_sql = v_sql + "    v_obj_type utableprocessevent_dbt.t_objecttype%TYPE; ";
  v_sql = v_sql + "    v_stat_r utableprocessevent_dbt.t_status%TYPE := :p_stat_r; ";
  v_sql = v_sql + "    v_evnt_type_del utableprocessevent_dbt.t_type%TYPE := :p_evnt_type_del; ";
  v_sql = v_sql + "    v_usrfld_nt VARCHAR2(40 Byte) := :p_usrfld_nt; ";
  v_sql = v_sql + "    vaccountid number(10); ";
  v_sql = v_sql + "    vaccountid_pair number(10); ";
  v_sql = v_sql + "BEGIN ";
  v_sql = v_sql + "    BEGIN ";
  v_sql = v_sql + "        v_obj_type := 1; "; /* Обновление статусов проводок */

//def-57167 зачисления апдейтим в 5, чтобы можно было откатить

  v_sql = v_sql + "        MERGE INTO UTABLEPROCESSEVENT_DBT t                                          ";
  v_sql = v_sql + "             USING (SELECT /*+ ORDERED  index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX3) */ ";
  v_sql = v_sql + "                          DISTINCT TBL_EVNT.t_recid                                  ";
  v_sql = v_sql + "                      FROM UTABLEPROCESSEVENT_DBT TBL_EVNT,                          ";
  v_sql = v_sql + "                           DOPRDOCS_DBT DOCS,                                        ";
  v_sql = v_sql + "                           doproper_dbt OPER,                                        ";
  v_sql = v_sql + "                           dnptxop_dbt NPTXOP                                        ";
  v_sql = v_sql + "                     WHERE     DOCS.T_ACCTRNID = tbl_evnt.t_objectid                 ";
  v_sql = v_sql + "                           AND OPER.T_ID_OPERATION = DOCS.T_ID_OPERATION             ";
  v_sql = v_sql + "                           AND OPER.T_KIND_OPERATION = 2037                          ";
  v_sql = v_sql + "                           AND NPTXOP.T_SUBKIND_OPERATION = 10                       ";
  v_sql = v_sql + "                           AND TO_NUMBER (OPER.T_DOCUMENTID) = NPTXOP.T_ID           ";
  v_sql = v_sql + "                           AND TBL_EVNT.t_objecttype = v_obj_type                             ";
  v_sql = v_sql + "                           AND TBL_EVNT.T_STATUS = v_stat_r) TBL                            ";
  v_sql = v_sql + "                ON (TBL.t_recid = t.t_recid)                                         ";
  v_sql = v_sql + "        WHEN MATCHED                                                                 ";
  v_sql = v_sql + "        THEN                                                                         ";
  v_sql = v_sql + "           UPDATE SET t_status = v_stat_err;                                         ";

  v_sql = v_sql + "        UPDATE /*+ index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX3) */ utableprocessevent_dbt tbl_evnt ";
  v_sql = v_sql + "           SET tbl_evnt.t_status = v_stat_nt ";
  v_sql = v_sql + "         WHERE tbl_evnt.t_objecttype = v_obj_type ";
  v_sql = v_sql + "           AND tbl_evnt.t_status = v_stat_r ";
  v_sql = v_sql + "           AND EXISTS(SELECT 1 FROM dacctrn_dbt tbl_trn ";
  v_sql = v_sql + "                       WHERE tbl_trn.t_acctrnid = tbl_evnt.t_objectid ";
  v_sql = v_sql + "                         AND tbl_trn.t_userfield2 = v_usrfld_nt); ";


  v_sql = v_sql + "        MERGE INTO UTABLEPROCESSEVENT_DBT t                                         ";
  v_sql = v_sql + "             USING (SELECT  /*+ ORDERED index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX3) */";
  v_sql = v_sql + "                          DISTINCT TBL_EVNT.t_recid                                 ";
  v_sql = v_sql + "                      FROM UTABLEPROCESSEVENT_DBT TBL_EVNT,                         ";
  v_sql = v_sql + "                           dacctrn_dbt trn,                                         ";
  v_sql = v_sql + "                           doprdocs_dbt od,                                         ";
  v_sql = v_sql + "                           doproper_dbt op,                                         ";
  v_sql = v_sql + "                           dnptxop_dbt n                                            ";
  v_sql = v_sql + "                     WHERE     od.t_id_operation = OP.T_ID_OPERATION                ";
  v_sql = v_sql + "                           AND OD.T_DOCKIND = 1                                     ";
  v_sql = v_sql + "                           AND op.t_documentid = LPAD (n.t_id, 34, '0')             ";
  v_sql = v_sql + "                           AND op.t_dockind = n.t_dockind                           ";
  v_sql = v_sql + "                           AND n.t_dockind = 4607                                   ";
  v_sql = v_sql + "                           AND n.t_status > 0                                       ";
  v_sql = v_sql + "                           AND od.t_acctrnid = trn.t_acctrnid                       ";
  v_sql = v_sql + "                           AND trn.t_chapter = 1                                    ";
  v_sql = v_sql + "                           AND SUBSTR (trn.t_account_payer, 1, 5) <> '47423'        ";
  v_sql = v_sql + "                           AND SUBSTR (trn.t_account_receiver, 1, 5) <> '47423'     ";
  v_sql = v_sql + "                           AND TBL_EVNT.t_objectid = trn.t_acctrnid                 ";
  v_sql = v_sql + "                           AND n.t_dockind = 4607                                   ";
  v_sql = v_sql + "                           AND n.t_status > 0                                       ";
  v_sql = v_sql + "                           AND n.t_subkind_operation = 10                                 ";
 
  v_sql = v_sql + "                           AND TBL_EVNT.t_objecttype = v_obj_type                   ";
  v_sql = v_sql + "                           AND TBL_EVNT.T_STATUS = v_stat_r) TBL                    ";
  v_sql = v_sql + "                ON (TBL.t_recid = t.t_recid)                                        ";
  v_sql = v_sql + "         WHEN MATCHED                                                               ";
  v_sql = v_sql + "        THEN                                                                        ";
  v_sql = v_sql + "           UPDATE SET t_status = v_stat_nt;                                         ";

//shev 20201210 isup 518545 оптимизация запроса

  v_sql = v_sql + "        v_obj_type := 501; "; /* Обновление статусов платежей */

  v_sql = v_sql + "        UPDATE /*+ index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX3) */ utableprocessevent_dbt tbl_evnt ";
  v_sql = v_sql + "           SET tbl_evnt.t_status = v_stat_nt ";
  v_sql = v_sql + "         WHERE tbl_evnt.t_objecttype = v_obj_type ";
  v_sql = v_sql + "           AND tbl_evnt.t_status = v_stat_r ";
  v_sql = v_sql + "           AND EXISTS(SELECT 1 FROM dpmpaym_dbt tbl_paym ";
  v_sql = v_sql + "                       WHERE tbl_paym.t_paymentid = tbl_evnt.t_objectid ";
  v_sql = v_sql + "                         AND tbl_paym.t_userfield2 = v_usrfld_nt); ";

  v_sql = v_sql + "        v_obj_type := 4; "; /* Обновление статусов счетов */

  v_sql = v_sql + "        UPDATE /*+ index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX3) */ utableprocessevent_dbt tbl_evnt ";
  v_sql = v_sql + "           SET tbl_evnt.t_status = v_stat_nt ";
  v_sql = v_sql + "         WHERE tbl_evnt.t_objecttype = v_obj_type ";
//  v_sql = v_sql + "           AND tbl_evnt.t_type <> v_evnt_type_del "; /* Обрабатываем централизованно */
  v_sql = v_sql + "           AND tbl_evnt.t_status = v_stat_r ";
  v_sql = v_sql + "           AND EXISTS(SELECT 1 FROM daccount_dbt tbl_acc ";
  v_sql = v_sql + "                       WHERE tbl_acc.t_accountid = tbl_evnt.t_objectid ";
  v_sql = v_sql + "                         AND tbl_acc.t_userfield2 = v_usrfld_nt); ";

// DEF-42204 выгрузка парных счетов
// для второго счета ставим признак -1420 (Not Transfer)
  v_sql = v_sql + "        FOR pairs in ( ";
  v_sql = v_sql + "           select /*+ index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX3)*/ * from utableprocessevent_dbt tbl_evnt ";
  v_sql = v_sql + "           where tbl_evnt.t_status = v_stat_r ";
//DEF-63202 для закрытия счетов тоже отбрасываем парные
//  v_sql = v_sql + "             and tbl_evnt.t_type <> v_evnt_type_del ";
  v_sql = v_sql + "             and tbl_evnt.t_objecttype = v_obj_type ";
  v_sql = v_sql + "             and EXISTS(SELECT 1 FROM daccount_dbt tbl_acc ";
  v_sql = v_sql + "                         WHERE tbl_acc.t_accountid = tbl_evnt.t_objectid ";
  v_sql = v_sql + "                           AND t_pairaccount <> chr(1) AND t_pairaccount <> CHR(0) ) ";
  v_sql = v_sql + "                               ) LOOP ";
  v_sql = v_sql + "         begin ";
  v_sql = v_sql + "          select least(acc_pair.t_accountid, acc.t_accountid) main_account,  ";
  v_sql = v_sql + "                 greatest(acc_pair.t_accountid, acc.t_accountid) pairaccount ";
  v_sql = v_sql + "            into vaccountid, vaccountid_pair ";
  v_sql = v_sql + "            from daccount_dbt acc, daccount_dbt acc_pair ";
  v_sql = v_sql + "           where acc.t_pairaccount = acc_pair.t_account and acc.t_chapter = acc_pair.t_chapter ";
  v_sql = v_sql + "             and acc.t_code_currency = acc_pair.t_code_currency ";
  v_sql = v_sql + "             and acc.t_accountid = pairs.t_objectid; ";

  v_sql = v_sql + "          update /*+ index(tbl_evnt UTABLEPROCESSEVENT_DBT_IDX1)*/ utableprocessevent_dbt tbl_evnt ";
  v_sql = v_sql + "             set t_status = v_stat_nt ";
  v_sql = v_sql + "           where t_status = v_stat_r ";
  v_sql = v_sql + "             and t_objecttype = v_obj_type ";
  v_sql = v_sql + "             and t_objectid = vaccountid_pair; ";

  v_sql = v_sql + "         exception ";
  v_sql = v_sql + "           when no_data_found then null; ";
  v_sql = v_sql + "         end; ";

  v_sql = v_sql + "        END LOOP; ";

  v_sql = v_sql + "        COMMIT; ";

  v_sql = v_sql + "    EXCEPTION ";
  v_sql = v_sql + "        WHEN OTHERS ";
  v_sql = v_sql + "        THEN ";
  v_sql = v_sql + "            v_ret := 1; ";
  v_sql = v_sql + "            ROLLBACK; ";
  v_sql = v_sql + "    END; ";

  v_sql = v_sql + "    :p_result := v_ret; ";
  v_sql = v_sql + "END; ";

  v_cmd = RSDCommand(v_sql);
  v_cmd.addParam("p_stat_nt", RSDBP_IN, CV_STAT_NOT_TRANSFER);
  v_cmd.addParam("p_stat_err", RSDBP_IN, CV_STAT_ERR);
  v_cmd.addParam("p_stat_r", RSDBP_IN, CV_STAT_READY);
  v_cmd.addParam("p_evnt_type_del", RSDBP_IN, CV_EVNT_TYPE_DEL);
  v_cmd.addParam("p_usrfld_nt", RSDBP_IN, CV_USRFLD_NOT_TRANSFER);
  v_cmd.addParam("p_result", RSDBP_OUT, V_INTEGER);
  v_cmd.execute();

  v_is_err = v_cmd.value("p_result");

  v_cmd.close(); v_cmd = NULL; v_sql = NULL;

//вывод информации о сессии в it_log для диагностики DEF-98163
  cmd = RSDCommand("begin it_log.log_handle('ws_check_job_Event',:p_text,it_log.C_MSG_TYPE__DEBUG); end;");
  cmd.AddParam("p_text", RSDBP_IN, "Конец: апдейт UTABLEPROCESSEVENT_DBT ");
  cmd.execute;
  cmd.close; cmd=null;

  if(v_is_err == 0)
/* 20190905 - kva - добавлен objecttype 5024 для обработки (формирование и отправка временного пароля для входа в торг. терм.) */
/* 20190905 - kva - добавлен objecttype 5026 для обработки (регистрация Клиента в РСХБ-Брокер) */
/* 20191024 - kva - добавлен objecttype 5025 для обработки (регистрация Клиента в QUIK) */
/* 20230607 - Dylgerov - добавлен objecttype 5073 для отправки сообщения в ЦФТ об удалении проводки ЦФТ при удалении РОВУ по депозитарным комиссиям BIQ-10484 CCBO6443 */
/* def-26510 событие 5025 вынесено в отдельный планировщик */
// shev DEF-74364
   GetRegistryValue(regpath, V_INTEGER, number_funcobj, stat);

//вывод информации о сессии в it_log для диагностики DEF-98163
  cmd = RSDCommand("begin it_log.log_handle('ws_check_job_Event',:p_text,it_log.C_MSG_TYPE__DEBUG); end;");
  cmd.AddParam("p_text", RSDBP_IN, "Начало: Вставка заданий в funcobj ");
  cmd.execute;
  cmd.close; cmd=null;

//количество записей в пачках для вставки в funcobj
     v_Query = " SELECT count(A.T_RECID) " + 
             "  FROM uTableProcessEvent_dbt A " +
             "  WHERE A.T_STATUS = :p_Status " + 
             "    AND (   ( (A.T_OBJECTTYPE = 1) AND (t_timestamp < (sysdate - NUMTODSINTERVAL(2, 'MINUTE'))) ) " +
             "     OR A.T_OBJECTTYPE IN( 4, 501, 5020, 5009, 5008, 5024, 5026, 5030, 5073 ) ) "+ 
             "     AND NOT EXISTS (select 1 from dfuncobj_dbt d where D.T_OBJECTTYPE = A.T_OBJECTTYPE AND D.T_OBJECTID = A.T_OBJECTID)  ";    

     v_Params = makeArray( SQLParam( "p_Status", 1 ));  
     v_DataSet = execSQLselect( v_Query, v_Params );

     if( v_DataSet.MoveNext ) 
//вывод информации о сессии в it_log для диагностики DEF-98163
        cmd = RSDCommand("begin it_log.log_handle('ws_check_job_Event',:p_text,it_log.C_MSG_TYPE__DEBUG); end;");
        cmd.AddParam("p_text", RSDBP_IN, "Начало: Записи отбираются пачками по "+number_funcobj+". Количество вставляемых записей " +v_DataSet.value(0, Null, V_INTEGER));
        cmd.execute;
        cmd.close; cmd=null;
     end;

     v_Query = null; Params = Null; DataSet = Null;

     Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, A.T_OBJECTID, A.T_TYPE, " +
             "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
             "    WHERE B.T_LIST = 5002 " +
             "     AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_PRIORITY " + 
             "  FROM uTableProcessEvent_dbt A " +
             "  WHERE A.T_STATUS = :p_Status " + 
             "    AND (   ( (A.T_OBJECTTYPE = 1) AND (t_timestamp < (sysdate - NUMTODSINTERVAL(2, 'MINUTE'))) ) " +
             "     OR A.T_OBJECTTYPE IN( 4, 501, 5020, 5009, 5008, 5024, /*5025,*/ 5026, 5030, 5073 ) ) "+ // Пока будем централизованно создавать задания на обработку для всех типов
             "     AND NOT EXISTS (select 1 from dfuncobj_dbt d where D.T_OBJECTTYPE = A.T_OBJECTTYPE AND D.T_OBJECTID = A.T_OBJECTID)  ";     //DEF-82419, DEF-86745
     if(number_funcobj > 1)
       Query = Query + "and rownum <"+number_funcobj; // добавляем за раз количество записей, определенное настройкой
     end;

     Params = makeArray( SQLParam( "p_Status", 1 ));  //формируется
     DataSet = execSQLselect( Query, Params );

     v_is_err = 0;
     while( DataSet.MoveNext ) //создание записи в очереди


      if( InsertSequenceJobDstrObj( DataSet.value(0, Null, V_INTEGER),
                                    DataSet.value(1, Null, V_INTEGER),
                                    DataSet.value(2, Null, V_INTEGER),
                                    DataSet.value(3, Null, V_INTEGER),
                                    ParsePriority( DataSet.value(4, Null, V_STRING /*V_INTEGER*/) ) ) == 0 ) // вставить в очередь в соответствии с ObjectId в func_obj
//       ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
         ; /* Чтобы не менять условие */
      else
//       ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         v_is_err = 1;
      end;

     end;

//вывод информации о сессии в it_log для диагностики DEF-98163
     cmd = RSDCommand("begin it_log.log_handle('ws_check_job_Event',:p_text,it_log.C_MSG_TYPE__DEBUG); end;");
     cmd.AddParam("p_text", RSDBP_IN, "Конец: Вставка заданий в funcobj ");
     cmd.execute;
     cmd.close; cmd=null;

     if(v_is_err == 0)
        ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
     else
        /* Возможно, особого смысла в этом нет, если вызов осуществляется каждые 10 секунд, но пусть будет */
        ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
     end;

     Params = Null;
     DataSet = Null;

  else
     ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end; /* macro ws_check_job_Event() */


/* Обработчик событий закрытия счетов */
macro ws_check_job_Close_acc()
   const CV_USRFLD_NOT_TRANSFER = "1";
   const CV_STAT_NOT_TRANSFER = -1420; /* NT - abcdefghijklmnopqrst */
   const CV_DELTA_DAY = 3; /* Количество дней до выгрузки события */
   const CV_STAT_READY = 1;
   const CV_STAT_WAIT = 11;
   const CV_STAT_ERR = 5;
   const CV_OBJ_TYPE_ACC = 4;
   const CV_TYPE_CLOSE_ACC = 3;
   const CV_TYPE_ACC = 1; //shev 19.07.2019 для рассылки
   const CV_STAT_EXECUTE = 2; //shev 19.07.2019 для рассылки
   var v_sql, v_cmd, v_rs, i=0;
   var ResultSheduler : object;
   var v_delta_date;
   var v_email_processor;//shev 19.07.2019 для рассылки
   var AccId :TArray;
   var TextMessage; 
   const CV_EMAIL_GRP_CHD = 3;
   const CV_EMAIL_GRP_CLOSE_ACC = 10; //maa241019 - испр.ошибку компиляции

   if(IsWorkday(date()) == 1)
      v_delta_date = m_get_work_date_delta_before(date(), CV_DELTA_DAY);

      /* Для событий по счетам, для которых выставлен userfield2, устанавливаем статус "Не выгружается" */
/*
      v_sql = v_sql + "UPDATE utableprocessevent_dbt tbl_evnt ";
      v_sql = v_sql + "   SET tbl_evnt.t_status = :p_stat_nt ";
      v_sql = v_sql + " WHERE tbl_evnt.t_objecttype = :p_obj_type ";
      v_sql = v_sql + "   AND tbl_evnt.t_type = :p_evnt_type_del ";
      v_sql = v_sql + "   AND tbl_evnt.t_status = :p_stat_r ";
      v_sql = v_sql + "   AND EXISTS(SELECT 1 FROM daccount_dbt tbl_acc ";
      v_sql = v_sql + "               WHERE tbl_acc.t_accountid = tbl_evnt.t_objectid ";
      v_sql = v_sql + "                 AND tbl_acc.t_userfield2 = :p_usrfld_nt) ";

      v_cmd = RSDCommand(v_sql);
      v_cmd.addParam("p_stat_nt", RSDBP_IN, CV_STAT_NOT_TRANSFER);
      v_cmd.addParam("p_obj_type", RSDBP_IN, CV_OBJ_TYPE_ACC);
      v_cmd.addParam("p_evnt_type_del", RSDBP_IN, CV_TYPE_CLOSE_ACC);
      v_cmd.addParam("p_stat_r", RSDBP_IN, CV_STAT_READY);
      v_cmd.addParam("p_usrfld_nt", RSDBP_IN, CV_USRFLD_NOT_TRANSFER);
      v_cmd.execute();

      v_cmd.close(); v_cmd = null; v_sql = null;
*/
//      v_sql =         "SELECT tbl_evnt.t_recid, tbl_evnt.t_objecttype, tbl_evnt.t_objectid, tbl_evnt.t_type ";
//      v_sql = v_sql + "  FROM utableprocessevent_dbt tbl_evnt ";
/*      v_sql =         "UPDATE utableprocessevent_dbt tbl_evnt ";
      v_sql = v_sql + "   SET t_status = :p_status_r, t_lastupdate = SYSDATE ";
      v_sql = v_sql + " WHERE tbl_evnt.t_status IN (:p_status_w, :p_status_err) ";
      v_sql = v_sql + "   AND tbl_evnt.t_objecttype = :p_obj_acc ";
      v_sql = v_sql + "   AND tbl_evnt.t_type = :p_type_close ";
//      v_sql = v_sql + "   AND tbl_evnt.t_timestamp < (sysdate - NUMTODSINTERVAL(:p_delta_day, 'DAY')) ";
      v_sql = v_sql + "   AND tbl_evnt.t_timestamp <= :p_delta_date ";*/
/* shev 2019.08.27 Пока отключаю так как часто не приходят респонсы на открытие счета в результате закрытие не выгружается
      /* Проверка факта выгрузки, чтобы не возникло коллизий при появлении необходимости выгрузки открытия счета */
      v_sql = v_sql + "   AND EXISTS(SELECT tbl_acc.t_accountid FROM daccount_dbt tbl_acc ";
      v_sql = v_sql + "               WHERE tbl_acc.t_accountid = tbl_evnt.t_objectid ";
      v_sql = v_sql + "                 AND INSTR(tbl_acc.t_usertypeaccount, 'Ы') <> 0) ";
*/
/*maa170519 - заккоментировал, т.к. могут постоянно возникать ситуации, что проводки по счетам остаются (не должны выгружаться). альтернатив - добавлять все условия триггера
      /* Проверка существования не выгруженных проводок по выбранным счетам (предполагаем, что выставляется период, за который все проводки будут уже введены) */
      v_sql = v_sql + "   AND NOT EXISTS(SELECT tbl_trn.t_acctrnid FROM dacctrn_dbt tbl_trn ";
      v_sql = v_sql + "                   WHERE tbl_evnt.t_objectid IN (tbl_trn.t_accountid_payer, tbl_trn.t_accountid_receiver) ";
      v_sql = v_sql + "                     AND tbl_trn.t_userfield4 = chr(1) and tbl_trn.t_state <> 4 ) ";
*/

//  shev 300519 если осталось событие с выгрузкой проводок по счету, то счет не выгружаем  */
/*      v_sql = v_sql + " AND NOT EXISTS (select * from utableprocessevent_dbt tbl_evnt2 where tbl_evnt2.t_objecttype = 1 and tbl_evnt2.t_status in(1,2,5,11) and tbl_evnt2.t_objectid in (SELECT tbl_trn.t_acctrnid FROM dacctrn_dbt tbl_trn ";
      v_sql = v_sql + "               WHERE tbl_evnt.t_objectid IN (tbl_trn.t_accountid_payer, tbl_trn.t_accountid_receiver)))"; 
*/

   // gtv: обновление даты закрытия счета
v_sql =         "declare                         ";
v_sql = v_sql + "    v_status_r      number(10); ";
v_sql = v_sql + "    v_status_w      number(10); ";
v_sql = v_sql + "    v_status_err    number(10); ";
v_sql = v_sql + "    v_obj_acc        number(10);";
v_sql = v_sql + "    v_type_close    number(10) ;";
v_sql = v_sql + "    v_delta_date    date;       ";
v_sql = v_sql + "    v_close_date    date;       ";
v_sql = v_sql + "begin                                 ";
v_sql = v_sql + "    v_status_r       := :p_status_r;  ";
v_sql = v_sql + "    v_status_w       := :p_status_w;  ";
v_sql = v_sql + "    v_status_err     := :p_status_err;";
v_sql = v_sql + "    v_obj_acc        := :p_obj_acc;   ";
v_sql = v_sql + "    v_type_close     := :p_type_close;";
v_sql = v_sql + "    v_delta_date     := :p_delta_date;";
v_sql = v_sql + "    for c in (select * from utableprocessevent_dbt tbl_evnt            ";
v_sql = v_sql + "               where tbl_evnt.t_status IN (v_status_w)  ";
v_sql = v_sql + "                 AND tbl_evnt.t_objecttype = v_obj_acc         ";
v_sql = v_sql + "                 AND tbl_evnt.t_type = v_type_close            ";
v_sql = v_sql + "                 AND trunc(tbl_evnt.t_timestamp) <= v_delta_date ";
//shev 28.05.2020 isup 510381
//v_sql = v_sql + "                 AND NOT EXISTS (select * from utableprocessevent_dbt tbl_evnt2 ";
//v_sql = v_sql + "                                  where tbl_evnt2.t_objecttype = 1 and tbl_evnt2.t_status in(1,2,5,11) and tbl_evnt2.t_objectid in ";
//v_sql = v_sql + "                                 (SELECT tbl_trn.t_acctrnid FROM dacctrn_dbt tbl_trn                                               ";
//v_sql = v_sql + "                                  WHERE tbl_evnt.t_objectid IN (tbl_trn.t_accountid_payer, tbl_trn.t_accountid_receiver)))) loop   ";
v_sql = v_sql + "        ) loop   ";
v_sql = v_sql + "        v_close_date := trunc(sysdate);                                                                                            ";
v_sql = v_sql + "        update daccount_dbt set t_close_date = v_close_date where t_accountid = c.t_objectid and t_close_date != v_close_date;     ";
v_sql = v_sql + "        insert into uclose_account_log (t_recid, t_accountid, t_old_close_date, t_new_close_date, t_sysdate)                       ";
v_sql = v_sql + "        values (c.t_recid, c.t_objectid, trunc(c.t_timestamp), v_close_date, sysdate);                                             ";
v_sql = v_sql + "        UPDATE utableprocessevent_dbt tbl_evnt SET t_status = v_status_r, t_lastupdate = SYSDATE where t_recid = c.t_recid;        ";
v_sql = v_sql + "    end loop;                                                                                                                      ";
v_sql = v_sql + "end;                                                                                                                               ";

      v_cmd = RSDCommand(v_sql);
      v_cmd.addParam("p_status_r", RSDBP_IN, CV_STAT_READY);
      v_cmd.addParam("p_status_w", RSDBP_IN, CV_STAT_WAIT);
      v_cmd.addParam("p_status_err", RSDBP_IN, CV_STAT_ERR);
      v_cmd.addParam("p_obj_acc", RSDBP_IN, CV_OBJ_TYPE_ACC);
      v_cmd.addParam("p_type_close", RSDBP_IN, CV_TYPE_CLOSE_ACC);
//      v_cmd.addParam("p_delta_day", RSDBP_IN, CV_DELTA_DAY);
      v_cmd.addParam("p_delta_date", RSDBP_IN, v_delta_date);
      v_cmd.execute();

      v_cmd.close(); v_cmd = null; v_sql = null;

//shev 300519 Рассылка по почте не выгруженных счетов

      v_sql =         " select t_account, t_open_date,t_close_date from daccount_dbt where t_accountid in (   ";
      v_sql = v_sql + " SELECT tbl_evnt.t_objectid ";
      v_sql = v_sql + "  FROM utableprocessevent_dbt tbl_evnt ";
      v_sql = v_sql + "  WHERE tbl_evnt.t_status IN (:p_status_w, :p_status_err) ";
      v_sql = v_sql + "   AND tbl_evnt.t_objecttype = :p_obj_acc ";
      v_sql = v_sql + "   AND tbl_evnt.t_type = :p_type_close ";
      v_sql = v_sql + "   AND tbl_evnt.t_timestamp <= :p_delta_date ";
      v_sql = v_sql + "   AND EXISTS (select * from utableprocessevent_dbt tbl_evnt2 where tbl_evnt2.t_objecttype = 1 and tbl_evnt2.t_status in(1,2,5,11) and tbl_evnt2.t_objectid in (SELECT tbl_trn.t_acctrnid FROM dacctrn_dbt tbl_trn ";
      v_sql = v_sql + "               WHERE tbl_evnt.t_objectid IN (tbl_trn.t_accountid_payer, tbl_trn.t_accountid_receiver))))"; 


      v_cmd = RSDCommand(v_sql);
      v_cmd.addParam("p_status_err", RSDBP_IN, CV_STAT_ERR);
      v_cmd.addParam("p_status_w", RSDBP_IN, CV_STAT_WAIT);
      v_cmd.addParam("p_obj_acc", RSDBP_IN, CV_OBJ_TYPE_ACC);
      v_cmd.addParam("p_type_close", RSDBP_IN, CV_TYPE_CLOSE_ACC);
      v_cmd.addParam("p_delta_date", RSDBP_IN, v_delta_date);
      v_cmd.execute();

      v_rs = RSDRecordSet(v_cmd);

     if(v_rs.movenext)
        v_email_processor.m_set_msg_head("СОФР - Выгрузка закрытых счетов");
        v_email_processor.m_add_row_to_msg_text("Не выгрузились закрытые счета");
        v_email_processor.m_add_row_to_msg_text(" ");
        v_email_processor.m_add_row_to_msg_text("Счет             Дата открытия            Дата закрытия ");
        v_email_processor.m_add_row_to_msg_text(v_rs.value("t_Account")+"     "+v_rs.value("t_open_date")+"     "+v_rs.value("t_close_date"));
      end;


      while (v_rs.movenext)
         v_email_processor.m_add_row_to_msg_text(v_rs.value("t_Account")+"     "+v_rs.value("t_open_date")+"     "+v_rs.value("t_close_date"));
      end;

     v_email_processor.m_save_to_submit_grp(CV_EMAIL_GRP_CLOSE_ACC, true);
     v_email_processor.m_submit_email_synch();

      v_cmd.close(); v_rs=Null; v_cmd = null; v_sql = null;

   end;

   ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

   return ResultSheduler;

onError(err)
   ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

   return ResultSheduler;
end; /* macro ws_check_job_Close_acc() */



//Обработчик потоков типа Fast, например, обработка Response в ответ на интерфейсный Response, вызов по Sheduler
macro ws_check_job_In() :object
var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;
var v_is_err = 0;

  Params = Null;
  DataSet = Null;
//переделан objects на пользовательский справочник
  Query = " SELECT A.T_RECID, " +
          "  (SELECT B.T_ELEMENT FROM dllvalues_dbt B " +
          "   WHERE B.T_LIST = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH " + 
          "    AND B.T_CODE = TO_CHAR(A.T_OBJECTTYPE) ) AS T_OBJECTTYPE, " +
          "  1 AS T_OBJECTID, 1 AS T_TYPE, " +
          "  TO_CHAR( A.T_OBJECTTYPE ) AS T_CODE, " + 
          "  ( CASE WHEN A.T_OBJECTTYPE = 7 THEN 5022 WHEN A.T_OBJECTTYPE = 8 and substr(t_resulttext,1,22) = 'GetEntriesForVerify306' THEN 5031  WHEN A.T_OBJECTTYPE = 8 THEN 5021 ELSE 0 END ) AS USEROBJID, " +  //shev добавил условие для сверки зачислений
          "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
          "    WHERE B.T_LIST = 5002 " +
          "     AND  B.T_CODE  = TO_CHAR(A.T_OBJECTTYPE) ) AS T_PRIORITY " + 
          " FROM uTableProcessIn_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE IN( TO_NUMBER( '7' ), TO_NUMBER( '8' ) ) "; //типы объектов нужно разделять по группам обработки

  Params = makeArray( SQLParam( "p_Status", 2 /*1*/ ));  //формируется
  DataSet = execSQLselect( Query, Params );

  v_is_err = 0;
  while( DataSet.MoveNext ) //создание записи в очереди
   if( InsertSequenceJobUsrObj( DataSet.value(0, Null, V_INTEGER),
                                int(DataSet.value(/*1*/ 4, Null, V_STRING /*V_INTEGER*/ )),
                                DataSet.value(3, Null, V_INTEGER),
                                DataSet.value(4, Null, V_STRING),
                                DataSet.value(5, Null, V_INTEGER),
                                ParsePriority( DataSet.value(6, Null, V_STRING) )   ) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
//    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
     ; /* Чтобы не менять условие */
   else
//    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      v_is_err = 1;
   end;

  end;

  if(v_is_err == 0)
     ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
     ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  Params = Null;
  DataSet = Null;

  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;

//shev DEF-79638 удалять не стал, но планировщик отключил
//Обработчик потоков типа Slow, например, запускаем раз в день, вызов по Sheduler
macro ws_check_job_InS() :object
var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;
var v_is_err = 0;

  Params = Null;
  DataSet = Null;
//переделан objects на пользовательский справочник
/*
  Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, A.T_OBJECTID, A.T_TYPE, " +
          "  (SELECT B.T_CODE FROM dobjects_dbt B " +
          "   WHERE B.T_OBJECTTYPE = A.T_OBJECTTYPE ) AS T_CODE " + 
          " FROM uTableProcessEvent_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE IN( 5003 ) "; //типы объектов нужно разделять по группам обработки
*/

/* А.Киселев 05.02.2019 переключили на Processin
  Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, A.T_OBJECTID, A.T_TYPE, " +
          "  (SELECT B.T_CODE FROM dllvalues_dbt B " +
          "   WHERE B.T_LIST = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH " + 
          "    AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_CODE " + 
          " FROM uTableProcessEvent_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE IN( 5003 ) "; //типы объектов нужно разделять по группам обработки

*/


  Query = " SELECT A.T_RECID, " +
          "  (SELECT B.T_ELEMENT FROM dllvalues_dbt B " +
          "   WHERE B.T_LIST = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH " + 
          "    AND B.T_CODE = TO_CHAR(A.T_OBJECTTYPE) ) AS T_OBJECTTYPE, " +
          "  1 AS T_OBJECTID, 1 AS T_TYPE, " +
          "  TO_CHAR( A.T_OBJECTTYPE ) AS T_CODE, " + 
          "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
          "    WHERE B.T_LIST = 5002 " +
// 2020-05-13 Cherednichenko - явно приводим к varchar для сравнения с dllvalues_dbt.t_code
          "     AND B.T_CODE = TO_CHAR( A.T_OBJECTTYPE ) ) AS T_PRIORITY " + 
          " FROM uTableProcessIn_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE IN( TO_NUMBER( '1' ) ) "; //типы объектов нужно разделять по группам обработки


  Params = makeArray( SQLParam( "p_Status", 2 /*1*/ ));  //формируется
  DataSet = execSQLselect( Query, Params );

  v_is_err = 0;
  while( DataSet.MoveNext ) //создание записи в очереди
   if( InsertSequenceJobUsrObj( DataSet.value(0, Null, V_INTEGER),
                                int(DataSet.value(/*1*/ 4, Null, V_STRING /*V_INTEGER*/ )),
                                DataSet.value(3, Null, V_INTEGER),
                                DataSet.value(4, Null, V_STRING),
                                ParsePriority( DataSet.value(5, Null, V_STRING) )) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
//    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
     ; /* Чтобы не менять условие */
   else
//    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      v_is_err = 1;
   end;

  end;

  if(v_is_err == 0)
     ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
     ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  Params = Null;
  DataSet = Null;

  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;



//Обработчик потоков типа Slow, например, запускаем раз в 15 минут по налияию записи в таблице uTableProcessEvent_dbt, которая появляется раз в сутки, вызов по Sheduler
macro ws_check_job_EventS() :object

  var Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, A.T_OBJECTID, A.T_TYPE, " +
          "  (SELECT B.T_CODE FROM dllvalues_dbt B " +
          "   WHERE B.T_LIST = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH " + 
          "    AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_CODE, " + 
          "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
          "    WHERE B.T_LIST = 5002 " +
          "     AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_PRIORITY " + 
          " FROM uTableProcessEvent_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE IN( 5016, 5017, 5018, 5023, 5027, 5028, 5029 ) "; //типы объектов нужно разделять по группам обработки

  var Params:TArray = makeArray( SQLParam( "p_Status", 1 ));
  var DataSet :RsdRecordset = execSQLselect( Query, Params );

  var v_is_err = 0;
  while( DataSet.MoveNext ) 
   if( InsertSequenceJobUsrObj( DataSet.value(0, Null, V_INTEGER),
                                DataSet.value(1, Null, V_INTEGER),
                                DataSet.value(3, Null, V_INTEGER),
                                DataSet.value(4, Null, V_STRING),
                                ParsePriority( DataSet.value(5, Null, V_STRING ) )) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
   else
      v_is_err = 1;
   end;
  end;

  var ResultSheduler :object;
  if(v_is_err == 0)
     ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
     ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  Params = Null;
  DataSet = Null;

  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  return c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

end;


//Инициатор потоков типа Slow, например, запускаем раз в день, вызов по Sheduler
macro ws_Init_job_EventS() :object
   const CV_TYPE_RATES = 5017; /* Тип Загрузка курсов валют и ДМ */
   const CV_EMAIL_GRP_GET_RATE = 1;

   var v_sql :string = "",
       v_cmd,
       ResultSheduler :object;
   var v_ret = 0;
   var v_email_processor;

   v_sql =         "DECLARE ";
   v_sql = v_sql + "    cv_status_ready utableprocessevent_dbt.t_status%TYPE := 1; ";
   v_sql = v_sql + "    v_ret INTEGER := 0; ";
   v_sql = v_sql + "    v_funcid dfuncobj_dbt.t_funcid%TYPE := :p_funcid; ";
   v_sql = v_sql + "    v_objecttype utableprocessevent_dbt.t_objecttype%TYPE := :p_objecttype; ";
   v_sql = v_sql + "    v_status utableprocessevent_dbt.t_status%TYPE; ";
   v_sql = v_sql + "    v_recid utableprocessevent_dbt.t_recid%TYPE; ";
   v_sql = v_sql + "BEGIN ";
   v_sql = v_sql + "    BEGIN ";
   v_sql = v_sql + "        SELECT tbl_evnt.t_recid, tbl_evnt.t_status ";
   v_sql = v_sql + "          INTO v_recid, v_status ";
   v_sql = v_sql + "          FROM utableprocessevent_dbt tbl_evnt ";
   v_sql = v_sql + "         WHERE tbl_evnt.t_objecttype = v_objecttype ";
   v_sql = v_sql + "           AND TRUNC(tbl_evnt.t_timestamp) = TRUNC(SYSDATE) ";
   v_sql = v_sql + "           AND (   (tbl_evnt.t_status IN (1, 4)) ";
   v_sql = v_sql + "                OR ((tbl_evnt.t_status = 2) AND NOT EXISTS(SELECT tbl_func.t_id ";
   v_sql = v_sql + "                                                             FROM dfuncobj_dbt tbl_func ";
   v_sql = v_sql + "                                                            WHERE tbl_func.t_objecttype = tbl_evnt.t_objecttype ";
   v_sql = v_sql + "                                                              AND tbl_func.t_objectid = tbl_evnt.t_recid ";
   v_sql = v_sql + "                                                              AND tbl_func.t_funcid = v_funcid ";
   v_sql = v_sql + "                                                              AND tbl_func.t_state IN (1, 20)))); ";
   v_sql = v_sql + "        v_ret := 1; ";

   v_sql = v_sql + "    EXCEPTION ";
   v_sql = v_sql + "        WHEN NO_DATA_FOUND ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            v_ret := 0; ";

   v_sql = v_sql + "        WHEN OTHERS ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            v_ret := 3; ";
   v_sql = v_sql + "    END; ";

   v_sql = v_sql + "    BEGIN ";
   v_sql = v_sql + "        IF v_ret = 1 ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            IF v_status = 2 "; /* Перезапускаем */
   v_sql = v_sql + "            THEN ";
   v_sql = v_sql + "                UPDATE utableprocessevent_dbt ";
   v_sql = v_sql + "                   SET t_status = cv_status_ready ";
   v_sql = v_sql + "                 WHERE t_recid = v_recid; ";

   v_sql = v_sql + "                COMMIT; ";

   v_sql = v_sql + "            ELSE ";
   v_sql = v_sql + "                v_ret := 2; "; /* Действия не производятся */
   v_sql = v_sql + "            END IF; ";

   v_sql = v_sql + "        ELSIF v_ret = 0 ";
   v_sql = v_sql + "        THEN ";

   v_sql = v_sql + "            INSERT INTO utableprocessevent_dbt (t_objecttype, t_objectid, t_type, t_status, t_timestamp) ";
   v_sql = v_sql + "                 VALUES (v_objecttype, 1, 1, 1, SYSDATE); ";
   v_sql = v_sql + "            COMMIT; ";

   v_sql = v_sql + "        END IF; ";

   v_sql = v_sql + "    EXCEPTION ";
   v_sql = v_sql + "        WHEN OTHERS ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            v_ret := 3; ";
   v_sql = v_sql + "    END; ";

   v_sql = v_sql + "    :p_ret := v_ret; ";
   v_sql = v_sql + "END; ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_funcid", RSDBP_IN, CV_TYPE_RATES);
   v_cmd.addParam("p_objecttype", RSDBP_IN, CV_TYPE_RATES);
   v_cmd.addParam("p_ret", RSDBP_OUT, V_INTEGER);
   v_cmd.execute();

   v_ret = v_cmd.value("p_ret");

   v_cmd.close(); v_cmd = null; v_sql = null;

   /* 0 - Создано событие загрузку курсов валют; 1 - Статус события сброшен в 1; 2 - Никаких действий не выполнялось; 3 - Возникла ошибка */
   if((v_ret == 0) or (v_ret == 2))
      ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

   elif(v_ret == 1)
      ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

      /* Отправляем письмо */
      v_email_processor = c_email_proc_env();
      v_email_processor.m_set_msg_head("СОФР - Загрузка курсов валют");
      v_email_processor.m_add_row_to_msg_text("Процесс загрузки курсов валют был запущен заново.\nРекомендуется проконтролировать успешность завершения процедуры.");
      v_email_processor.m_save_to_submit_grp(CV_EMAIL_GRP_GET_RATE, true);
      v_email_processor.m_submit_email_synch();

   else
      ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end; /* macro ws_Init_job_EventS() */


//Инициатор потоков типа Slow, например, запускаем раз в день, вызов по Sheduler
macro ws_Init_job_EventBag() :object
   const CV_TYPE_RATES = 5020; /* Тип Запуск RSHBBag */

   var v_sql :string = "",
       v_cmd,
       ResultSheduler :object;

   v_sql =         "INSERT INTO uTableProcessEvent_dbt( t_objecttype, t_objectid, t_type, t_status, t_timestamp ) ";
   v_sql = v_sql + "( SELECT :p_type_rates_1, 1, 1, 1, SYSDATE FROM DUAL ";
   v_sql = v_sql + "   WHERE NOT EXISTS(SELECT t_recid FROM utableprocessevent_dbt ";
   v_sql = v_sql + "                     WHERE t_objecttype = :p_type_rates_2 ";
   v_sql = v_sql + "                       AND t_type = 1 ";
   v_sql = v_sql + "                       AND TRUNC(t_timestamp) = TRUNC(SYSDATE) ";
   v_sql = v_sql + "                       AND t_status IN (1, 2, 4)) ";
   v_sql = v_sql + "     AND ROWNUM = 1 ) "; /* На всякий случай */

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_type_rates_1", RSDBP_IN, CV_TYPE_RATES);
   v_cmd.addParam("p_type_rates_2", RSDBP_IN, CV_TYPE_RATES);
   v_cmd.execute();

   v_cmd.close(); v_cmd = null; v_sql = null;

   ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

   return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;


/*----------------------------------------------------------*/
/* Вставка задания в dfuncobj_dbt по utableprocessevent_dbt */
/*----------------------------------------------------------*/
/* Создается по одному конкретному событию */
macro m_ins_funcobj_by_event(p_rec_id, p_objecttype, p_status)
   var v_ret = true;
   var v_sql, v_cmd, v_rs;

   v_sql =         "SELECT tbl_evnt.t_recid, tbl_evnt.t_objecttype, 1 AS t_type, ";
   v_sql = v_sql + "       (SELECT tbl_llval.t_code FROM dllvalues_dbt tbl_llval ";
   v_sql = v_sql + "         WHERE tbl_llval.t_list = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH ";
// 2020-05-13 Cherednichenko - явно приводим к varchar для сравнения с dllvalues_dbt.t_code
   v_sql = v_sql + "           AND tbl_llval.t_code = TO_CHAR(tbl_evnt.t_objecttype)) AS t_code, ";

   v_sql = v_sql + "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
                   "    WHERE B.T_LIST = 5002 " +
                   "     AND B.T_ELEMENT = tbl_evnt.T_OBJECTTYPE ) AS T_PRIORITY ";

   v_sql = v_sql + "  FROM utableprocessevent_dbt tbl_evnt ";
   v_sql = v_sql + " WHERE tbl_evnt.t_recid = :p_rec_id ";
   v_sql = v_sql + "   AND tbl_evnt.t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND tbl_evnt.t_status = :p_status ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_rec_id", RSDBP_IN, p_rec_id);
   v_cmd.addParam("p_objecttype", RSDBP_IN, p_objecttype);
   v_cmd.addParam("p_status", RSDBP_IN, p_status);

   v_rs = RSDRecordSet(v_cmd);

   if(v_rs.movenext())
      if(InsertSequenceJobUsrObj(v_rs.value("t_recid"),
                                 v_rs.value("t_objecttype"),
                                 v_rs.value("t_type"),
                                 v_rs.value("t_code"),
                                 ParsePriority( v_rs.value("T_PRIORITY") )) != 0) /* вставить в func_obj в соответствии с Objecttype */
         v_ret = false;
      end;
   end;

   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   return v_ret;

onError(err)
   v_ret = false;
   return v_ret;
end; /* macro m_ins_funcobj_by_event() */


/*-------------------------------------------------------*/
/* Вставка задания в dfuncobj_dbt по utableprocessin_dbt */
/*-------------------------------------------------------*/
macro m_ins_funcobj_by_proc_in(p_rec_id, p_objecttype, p_status)
   var v_ret = true;
   var v_sql, v_cmd, v_rs;

   v_sql =         "SELECT tbl_proc.t_recid, tbl_proc.t_objecttype, 1 AS t_type, ";
   v_sql = v_sql + "       (SELECT tbl_llval.t_code FROM dllvalues_dbt tbl_llval ";
   v_sql = v_sql + "         WHERE tbl_llval.t_list = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH ";
// 2020-05-14 Cherednichenko - явно приводим к varchar для сравнения с dllvalues_dbt.t_code
   v_sql = v_sql + "           AND tbl_llval.t_code = TO_CHAR( tbl_proc.t_objecttype ) ) AS t_code, ";

   v_sql = v_sql + "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
                   "    WHERE B.T_LIST = 5002 " +
//                   "     AND TO_NUMBER( B.T_CODE ) = tbl_proc.T_OBJECTTYPE ) AS T_PRIORITY ";
// 2020-05-13 shev - явно приводим к varchar для сравнения с dllvalues_dbt.t_code
                   "     AND B.T_CODE = TO_CHAR(tbl_proc.T_OBJECTTYPE )) AS T_PRIORITY ";

   v_sql = v_sql + "  FROM utableprocessin_dbt tbl_proc ";
   v_sql = v_sql + " WHERE tbl_proc.t_recid = :p_rec_id ";
   v_sql = v_sql + "   AND tbl_proc.t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND tbl_proc.t_status = :p_status ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_rec_id", RSDBP_IN, p_rec_id);
   v_cmd.addParam("p_objecttype", RSDBP_IN, p_objecttype);
   v_cmd.addParam("p_status", RSDBP_IN, p_status);

   v_rs = RSDRecordSet(v_cmd);
   if(v_rs.movenext())
      if(InsertSequenceJobUsrObj(v_rs.value("t_recid"),
                                 v_rs.value("t_objecttype"),
                                 string("-", v_rs.value("t_type")),
                                 v_rs.value("t_code"),
                                 Null,
                                 ParsePriority( v_rs.value("T_PRIORITY") )) != 0) /* вставить в func_obj в соответствии с Objecttype */
         v_ret = false;
      end;
   end;

   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   return v_ret;

onError(err)
   v_ret = false;
   return v_ret;
end; /* macro m_ins_funcobj_by_proc_in() */


// BIQ-7335 результат загрузки НБО в Депозитарии 
// используется свой планировщик
macro ws_check_job_NOBOut_result()
   const C_STATUS_READY = 2;
   const C_STATUS_AFTER = 3;

   var v_sql, v_cmd, v_rs;
   var v_priority = "0", v_element = 0, v_recid = -1,v_parsep; 
   var v_result_scheduler;
   var v_state = true;

   v_sql =         "SELECT pin.t_recid, pin.t_objecttype, pin.t_status, llval.t_list, llval.t_note, llval.t_element ";
   v_sql = v_sql + "  FROM utableprocessin_dbt pin, ";
   v_sql = v_sql + "       dllvalues_dbt llval ";
   v_sql = v_sql + " WHERE pin.t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND pin.t_status = :p_status_r  ";
   v_sql = v_sql + "   AND llval.t_list = 5002   ";
   v_sql = v_sql + "   AND llval.t_code = to_char(pin.t_objecttype)";
   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_NOB_OUT);
   v_cmd.addParam("p_status_r", RSDBP_IN, C_STATUS_READY);
   v_rs = RSDRecordSet(v_cmd);
   if (v_rs.movenext())
      v_priority = v_rs.value("T_NOTE");
      v_element = v_rs.value("t_ELEMENT");
      v_recid = v_rs.value("t_recid");
   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;
   
   if (v_recid > 0)
      v_parsep = ParsePriority(v_priority);
      v_state = InsertSequenceJobUsrObj(  v_recid,
                                          v_element,
                                          2,    // входящий поток - ответ на исходящий
                                          C_SOFR_NOB_OUT,
                                          Null,
                                          v_parsep);
   else 
      v_state = 1;
   end;
   
   if(v_state == 0)
      m_upd_table_proc_in_status(v_recid, C_STATUS_AFTER);
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end; /* macro ws_check_job_NOBOut_result() */

/*----------------------------------------------------------------------*/
/* Поиск процесса подготовки результата обработки Договоров брокерского */
/* обслуживания                                                         */
/*----------------------------------------------------------------------*/
/* Предполагается, что в любом случае будет не более одного процесса    */
/* в utableprocessin_dbt, чьи данные находятся в sofr_contractboresult  */
/*----------------------------------------------------------------------*/
private macro ws_check_job_CntrBO_in()
   const C_STATUS_READY = 2;
   const C_STATUS_AFTER = 3;
//   const C_TABLE_NAME = "utableprocessin_dbt";

   var v_sql, v_cmd, v_rs;
   var v_result_scheduler;
   var v_state = true;

   /* Предполагаем, что все необходимые проверки в этой части  */
   /* выполняются на стороне внешней системы: заданные условия */
   /* однозначно сигнализируют о необходимости начала процесса */
   /* загрузки результата                                      */
   v_sql =         "SELECT t_recid, t_objecttype, t_status ";
   v_sql = v_sql + "  FROM utableprocessin_dbt ";
   v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND t_status = :p_status_r ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_CONTRBO);
   v_cmd.addParam("p_status_r", RSDBP_IN, C_STATUS_READY);

   v_rs = RSDRecordSet(v_cmd);
   /* Обрабатываем только первую запись */
   if(v_rs.movenext())
      v_state = m_ins_funcobj_by_proc_in(v_rs.value("t_recid"), v_rs.value("t_objecttype"), v_rs.value("t_status"));
      if(v_state)
         m_upd_table_proc_in_status(v_rs.value("t_recid"), C_STATUS_AFTER);
/* !!! - TODO - сделать анонимный блок */
      end;
   end;

   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   return v_state;

onError(err)
   v_state = false;
   return v_state;
end; /* macro ws_check_job_CntrBO_in() */


macro ws_check_job_CntrBO_out()
   const C_EVENT_STAT_NEW = 1;
   const C_PROC_OUT_ARCH = 4;
   const C_PROC_OUT_ERR = 5;

   var v_sql, v_cmd, v_rs;
   var v_state = true;

   v_sql =         "SELECT NVL(MIN(tbl_evnt.t_recid), -1) min_id ";
   v_sql = v_sql + "  FROM utableprocessevent_dbt tbl_evnt ";
   /* Сразу выполняем проверку существования не завершенных потоков выгрузки */
   v_sql = v_sql + " WHERE NOT EXISTS(SELECT tbl_out.t_recid ";
   v_sql = v_sql + "                    FROM utableprocessout_dbt tbl_out ";
   v_sql = v_sql + "                   WHERE tbl_out.t_objecttype = :p_objecttype_o ";
   v_sql = v_sql + "                     AND tbl_out.t_status NOT IN (:p_status_o1, :p_status_o2)) ";
   v_sql = v_sql + "   AND tbl_evnt.t_objecttype = :p_objecttype_e ";
   v_sql = v_sql + "   AND tbl_evnt.t_status = :p_status_e ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype_o", RSDBP_IN, C_SOFR_CONTRBO);
   v_cmd.addParam("p_status_o1", RSDBP_IN, C_PROC_OUT_ARCH);
   v_cmd.addParam("p_status_o2", RSDBP_IN, C_PROC_OUT_ERR);
   v_cmd.addParam("p_objecttype_e", RSDBP_IN, C_SOFR_CONTRBO);
   v_cmd.addParam("p_status_e", RSDBP_IN, C_EVENT_STAT_NEW);

   v_rs = RSDRecordSet(v_cmd);
   if(v_rs.movenext())
      /* Предполагается, что идентификаторы не будут отрицательными */
      if(v_rs.value("min_id") >= 0)
         /* Создаем задание для dfuncobj_dbt */
         v_state = m_ins_funcobj_by_event(v_rs.value("min_id"), C_SOFR_CONTRBO, C_EVENT_STAT_NEW);
      end;
   end;

   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   return v_state;

onError(err)
   v_state = false;
   return v_state;
end; /* macro ws_check_job_CntrBO_out() */


/*----------------------------------------------------------------*/
/* Обработчик события передачи Договоров брокерского обслуживания */
/*----------------------------------------------------------------*/
/* Предполагается, что запуск выполняется планировщиком всегда в  */
/* один поток                                                     */
/*----------------------------------------------------------------*/
/* Входные параметры:                                             */
/*    - in_prm_ssfunc = dss_func_dbt.t_parameters                 */
/*    - in_prm_ssshed = dss_sheduler_dbt.t_parameters             */
/*----------------------------------------------------------------*/
macro ws_check_job_CntrBO(in_prm_0, in_prm_ssfunc, in_prm_ssshed)
   var v_state = true;
   var v_result_scheduler;
   var v_direction;

   if(ValType(in_prm_ssfunc) != V_UNDEF)
      if(strlen(in_prm_ssfunc) != 0)
         v_direction = in_prm_ssfunc;
      else
         v_direction = "1";
      end;
   else
      v_direction = "1";
   end;

   if(v_direction == "1")
      v_state = ws_check_job_CntrBO_out();
   else
      v_state = ws_check_job_CntrBO_in();
   end;

   if(v_state)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;

onError(err)

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

   return v_result_scheduler;

end; /* macro ws_check_job_CntrBO() */


private macro ws_check_job_DEPOLoad_in()
   const C_SOFR_DEPOACC = 10;
   const C_PROC_IN_READY = 2;
   const C_PROC_IN_PROC = 3;
   const C_PROC_OUT_CREATE = 1;
   const C_PROC_TYPE = "-1";

   var v_sql, v_cmd, v_rs;
   var v_state = true;

   v_sql =         "DECLARE ";
   v_sql = v_sql + "    v_recid         NUMBER(10); ";
   v_sql = v_sql + "    v_obj_type      NUMBER(10) := :p_objecttype; ";
   v_sql = v_sql + "    v_stat_ready    NUMBER(10) := :p_status_ready; ";
   v_sql = v_sql + "    v_stat_create   NUMBER(10) := :p_status_create; ";
   v_sql = v_sql + "    v_stat_proc     NUMBER(10) := :p_status_proc; ";
   v_sql = v_sql + "    v_proc_type     VARCHAR2(10 Char) := :p_proc_type; ";
   v_sql = v_sql + "    v_obj_type_code dllvalues_dbt.t_code%TYPE; ";
   v_sql = v_sql + "    v_ret           NUMBER(5) := 0; ";
   v_sql = v_sql + "BEGIN ";
   v_sql = v_sql + "    BEGIN ";
   v_sql = v_sql + "        SELECT tbl_proc.t_recid, tbl_proc.t_objecttype, ";
   v_sql = v_sql + "               (SELECT tbl_llval.t_code FROM dllvalues_dbt tbl_llval ";
   v_sql = v_sql + "                 WHERE tbl_llval.t_list = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH ";
// 2020-05-14 Cherednichenko - явно приводим к varchar для сравнения с dllvalues_dbt.t_code
//   v_sql = v_sql + "                   AND tbl_llval.t_code = tbl_proc.t_objecttype ) AS t_code ";
   v_sql = v_sql + "                   AND tbl_llval.t_code = TO_CHAR( tbl_proc.t_objecttype ) ) AS t_code ";
   v_sql = v_sql + "          INTO v_recid, v_obj_type, v_obj_type_code ";
   v_sql = v_sql + "          FROM utableprocessin_dbt tbl_proc ";
   v_sql = v_sql + "         WHERE tbl_proc.t_objecttype = v_obj_type ";
   v_sql = v_sql + "           AND tbl_proc.t_status = v_stat_ready; ";

   v_sql = v_sql + "        v_ret := USR_PKG_IMPORT_SOFR.InsertSequenceJobUsrObj(v_recid, v_obj_type, v_proc_type, v_obj_type_code); ";

   v_sql = v_sql + "        IF v_ret = 0 ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            UPDATE utableprocessin_dbt ";
   v_sql = v_sql + "               SET t_status = v_stat_proc ";
   v_sql = v_sql + "             WHERE t_recid = v_recid; ";

   v_sql = v_sql + "            INSERT INTO utableprocessout_dbt (t_objecttype, t_status, t_timestamp) ";
   v_sql = v_sql + "                 VALUES (v_obj_type, v_stat_create, sysdate); ";

   v_sql = v_sql + "            COMMIT; ";
   v_sql = v_sql + "        END IF; ";
   v_sql = v_sql + "    EXCEPTION ";
   v_sql = v_sql + "        WHEN NO_DATA_FOUND ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            v_ret := 1; "; /* На данный момент отсутствуют даные для обмена */
   v_sql = v_sql + "        WHEN OTHERS ";
   v_sql = v_sql + "        THEN ";
   v_sql = v_sql + "            v_ret := 2; "; /* Не удалось обновить запись */
   v_sql = v_sql + "            ROLLBACK; ";
   v_sql = v_sql + "    END; ";

   v_sql = v_sql + "    :p_result := v_ret; ";
   v_sql = v_sql + "END; ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_DEPOACC);
   v_cmd.addParam("p_status_ready", RSDBP_IN, C_PROC_IN_READY);
   v_cmd.addParam("p_status_create", RSDBP_IN, C_PROC_OUT_CREATE);
   v_cmd.addParam("p_status_proc", RSDBP_IN, C_PROC_IN_PROC);
   v_cmd.addParam("p_proc_type", RSDBP_IN, C_PROC_TYPE);
   v_cmd.addParam("p_result", RSDBP_OUT, V_INTEGER);
   v_cmd.execute();

   if(v_cmd.value("p_result") == 1)
   /* На данный момент отсутствуют даные для обмена */
   /* По ФТ должно быть e-mail оповещение */
      v_state = true;
   elif(v_cmd.value("p_result") == 2)
      v_state = false;
   elif(v_cmd.value("p_result") != 0)
   /* Непредвиденные ошибки */
      v_state = false;
   end;

   v_cmd.close(); v_cmd = NULL; v_sql = NULL;

   return v_state;

onError(err)
   v_state = false;
   return v_state;
end; /* macro ws_check_job_DEPOLoad_in() */


/*----------------------------------------------------------------*/
/* Обработчик загрузки данных по счетам и договорам ДЕПО          */
/*----------------------------------------------------------------*/
/* Предполагается, что запуск выполняется планировщиком всегда в  */
/* один поток                                                     */
/*----------------------------------------------------------------*/
/* Входные параметры:                                             */
/*    - in_prm_ssfunc = dss_func_dbt.t_parameters                 */
/*    - in_prm_ssshed = dss_sheduler_dbt.t_parameters             */
/*----------------------------------------------------------------*/
macro ws_check_job_DEPOLoad(in_prm_0, in_prm_ssfunc, in_prm_ssshed)
   var v_state = true;
   var v_result_scheduler;
   var v_direction;

   if(ValType(in_prm_ssfunc) != V_UNDEF)
      if(strlen(in_prm_ssfunc) != 0)
         v_direction = in_prm_ssfunc;
      else
         v_direction = "1";
      end;
   else
      v_direction = "1";
   end;

   if(v_direction == "-1")
      v_state = ws_check_job_DEPOLoad_in();
   end;

   if(v_state)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;

onError(err)

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

   return v_result_scheduler;

end;


/*----------------------------------------------------------------*/
/* Обработчик события сверки данных по счетам ДЕПО                */
/*----------------------------------------------------------------*/
/* Предполагается, что запуск выполняется планировщиком всегда в  */
/* один поток                                                     */
/*----------------------------------------------------------------*/
/* Входные параметры:                                             */
/*    - in_prm_ssfunc = dss_func_dbt.t_parameters                 */
/*    - in_prm_ssshed = dss_sheduler_dbt.t_parameters             */
/*----------------------------------------------------------------*/
macro ws_check_job_DEPORevise(in_prm_0, in_prm_ssfunc, in_prm_ssshed)
   const C_SOFR_DEPORevise = 11;
   const C_STATUS_READY = 2;
   const C_STATUS_AFTER = 3;
   const C_TABLE_NAME = "utableprocessin_dbt";

   var v_state = 0;
   var v_result_scheduler;
   var v_direction;
   var v_sql, v_cmd, v_rs;
   var v_sql_e, v_cmd_e;

   if(ValType(in_prm_ssfunc) != V_UNDEF)
      if(strlen(in_prm_ssfunc) != 0)
         v_direction = in_prm_ssfunc;
      else
         v_direction = "1";
      end;
   else
      v_direction = "1";
   end;

   v_sql =         "SELECT t_recid, t_objecttype, t_status ";
   v_sql = v_sql + "  FROM utableprocessin_dbt ";
   v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND t_status = :p_status_r ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_DEPORevise);
   v_cmd.addParam("p_status_r", RSDBP_IN, C_STATUS_READY);

   v_rs = RSDRecordSet(v_cmd);
   if(v_rs.movenext())
      v_sql_e =           "BEGIN ";
      v_sql_e = v_sql_e + "    :v_ret := USR_PKG_IMPORT_SOFR.MakeStartProcessWTask(:p_recid, ";
      v_sql_e = v_sql_e + "                                                        :p_status_a, ";
      v_sql_e = v_sql_e + "                                                        :p_type, ";
      v_sql_e = v_sql_e + "                                                        :p_tbl_name); ";
      v_sql_e = v_sql_e + "END;";

      v_cmd_e = RSDCommand(v_sql_e);
      v_cmd_e.addParam("v_ret", RSDBP_RETVAL, V_INTEGER);
      v_cmd_e.addParam("p_recid", RSDBP_IN, v_rs.value("t_recid"));
      v_cmd_e.addParam("p_status_a", RSDBP_IN, C_STATUS_AFTER);
      v_cmd_e.addParam("p_type", RSDBP_IN, v_direction);
      v_cmd_e.addParam("p_tbl_name", RSDBP_IN, C_TABLE_NAME);
      v_cmd_e.execute();

      v_state = v_cmd_e.value("v_ret");
   end;

   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   if(v_state == 0)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;

onError(err)

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

   return v_result_scheduler;

end; /* macro ws_check_job_DEPORevise() */


/* Формирование данных ПКЛ*/
macro ws_Init_job_Event_PKL() :object
var Query :string = "",
    ResultSheduler :object;

  Query = " INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP ) " +
          "  ( SELECT 5018, 1, 1, 1, SYSDATE FROM DUAL ) "; //тип выгрузка данных ПКЛ

  execSQL( Query );

  ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

  return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;

//Обработчик исходящих потоков для выгрузки информации по договорам БО
macro ws_unload_contr() :object
var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;

  Params = Null;
  DataSet = Null;

  Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, A.T_OBJECTID, A.T_TYPE, " +
          "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
          "    WHERE B.T_LIST = 5002 " +
          "     AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_PRIORITY " + 
          " FROM uTableProcessEvent_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE IN( 207, 5207, /*6207,*/ 8207 ) "; 

  Params = makeArray( SQLParam( "p_Status", 1 ));
  DataSet = execSQLselect( Query, Params );

  while( DataSet.MoveNext ) //создание записи в очереди
   if( InsertSequenceJobDstrObj(DataSet.value(0, Null, V_INTEGER), DataSet.value(1, Null, V_INTEGER), DataSet.value(2, Null, V_INTEGER),
                                DataSet.value(3, Null, V_INTEGER),
                                ParsePriority( DataSet.value(4, Null, V_STRING ) )
                               ) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
   else
    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

  end;
  
  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;
/*-----------------------------------------*/
/* Выгрузка ЦХД сделки                     */
/*-----------------------------------------*/

macro ws_Init_job_Event_CHD() :object
var Query :string = "", CMD,
    ResultSheduler :object;
var v_email_processor;
var CV_EMAIL_GRP_CHD = 1;

  cmd =ExecSqlSelect( "select * from uTableProcessEvent_dbt where T_OBJECTTYPE = 5016 and t_status < 4 ");
  cmd.movenext();
  if (valtype(cmd.value(0))!= 26)
    execSQL("update uTableProcessEvent_dbt set t_status = 5, t_resulttext = 'Ошибка события', t_lastupdate = sysdate where t_status < 4 and T_OBJECTTYPE = 5016");
  end;

/*maa20190522-закомментировал т.к. могут быть проблемы с блокировкой    
//shev 19.07.2019  
  cmd =ExecSqlSelect( "select * from uTableProcessEvent_dbt where T_OBJECTTYPE = 5016 and t_status = 4 and trunc(t_timestamp)= trunc(sysdate) ");
  cmd.movenext();

  if (valtype(cmd.value(0))!= 26)
      v_email_processor = c_email_proc_env();
      v_email_processor.m_set_msg_head("СОФР - Выгрузка в ЦХД");
      v_email_processor.m_add_row_to_msg_text("Попытка повторной выгрузки данных в ЦХД (ws_check_job.mac 1458)");
      v_email_processor.m_save_to_submit_grp(CV_EMAIL_GRP_CHD, true);
      v_email_processor.m_save_to_submit();
      return c_ssRunResult(SS_RESPONSE_END);
  end;
*/
             
  Query = " INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP ) " +
          "  ( SELECT 5016, 1, 1, 1, SYSDATE FROM DUAL ) "; //тип загрузка курсов

  execSQL( Query );

  ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

  return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;


/*-----------------------------------------*/
/* Выгрузка ЦХД ценные бумаги              */
/*-----------------------------------------*/
macro ws_Init_job_Event_CHD_SEC() :object

  if (ExecSqlSelect( "select * from uTableProcessEvent_dbt where T_OBJECTTYPE = 5027 and t_status < 4").movenext()) 
    execSQL("update uTableProcessEvent_dbt set t_status = 5, t_resulttext = 'Ошибка события', t_lastupdate = sysdate where t_status < 4 and T_OBJECTTYPE = 5027");  
  end;

  execSQL(" INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP ) " +
          "  ( SELECT 5027, 1, 1, 1, SYSDATE FROM DUAL ) "); //тип выгрузка МБК ЦБ

  return c_ssRunResult(SS_RESPONSE_END);

onError(err)
  return c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
end;

/*-----------------------------------------*/
/* Выгрузка ЦХД сделок по ПФИ              */
/*-----------------------------------------*/
macro ws_Init_job_Event_CHD_PFI() :object

  if (ExecSqlSelect( "select * from uTableProcessEvent_dbt where T_OBJECTTYPE = 5028 and t_status < 4").movenext()) 
    execSQL("update uTableProcessEvent_dbt set t_status = 5, t_resulttext = 'Ошибка события', t_lastupdate = sysdate where t_status < 4 and T_OBJECTTYPE = 5028");  
  end;

  execSQL(" INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP ) " +
          "  ( SELECT 5028, 1, 1, 1, SYSDATE FROM DUAL ) "); //тип выгрузка ПФИ

  return c_ssRunResult(SS_RESPONSE_END);

onError(err)
  return c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
end;


/*-----------------------------------------*/
/* Асинхронная отправка e-mail уведомлений */
/*-----------------------------------------*/
macro ws_asynch_email_send()
   const VC_VERSION_ERR = 10; /* Значение t_version, после которого письма перестают попадать в обработку */
   const VC_LETTER_PROC_MARK = "E"; /* Метка для t_issend - письмо отправить не удалось (для асинхронного режима) */
   var v_result_scheduler;
   var v_sql, v_cmd;

   v_sql =         "UPDATE demail_notify_dbt ";
   v_sql = v_sql + "   SET t_issend = :p_err_stat ";
   v_sql = v_sql + " WHERE t_issend NOT IN (CHR(88), :p_err_mark) ";
   v_sql = v_sql + "   AND t_version >= :p_version_err ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_err_stat", RSDBP_IN, VC_LETTER_PROC_MARK);
   v_cmd.addParam("p_err_mark", RSDBP_IN, VC_LETTER_PROC_MARK);
   v_cmd.addParam("p_version_err", RSDBP_IN, VC_VERSION_ERR);
   v_cmd.execute();

   v_cmd.close(); v_cmd = NULL; v_sql = NULL;

   /* Отправляем e-mail в асинхронном режиме */
   c_email_proc_env.m_submit_email_asynch();

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   return v_result_scheduler;

onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end; /* macro ws_asynch_email_send() */



/*-----------------------------------------*/
/* Формирование файла ДБО                  */
/*-----------------------------------------*/

macro ws_Init_job_Event_DBO() :object
var Query :string = "", CMD,
    ResultSheduler :object;
var v_email_processor;
var CV_EMAIL_GRP_CHD = 1;
var DBO_UNLOAD_TYPE = "РСХБ\\ИНТЕГРАЦИЯ\\ДБО_XML";

   // BIQ-7785 основной тип выгрузок - XML
   var v_xml = true, stat;
   GetRegistryValue(DBO_UNLOAD_TYPE, V_BOOL, v_xml, stat);
   if (stat>0)
      v_xml = true; // не найдено - значит, XML
   end;

  cmd =ExecSqlSelect( "select * from uTableProcessEvent_dbt where T_OBJECTTYPE = 5023 and t_status < 4 ");
  cmd.movenext();
  if (valtype(cmd.value(0))!= 26)
    execSQL("update uTableProcessEvent_dbt set t_status = 5, t_resulttext = 'Ошибка события', t_lastupdate = sysdate where t_status < 4 and T_OBJECTTYPE = 5023");
  end;

  if (v_xml)
     Query = " INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP, T_NOTE ) " +
             " VALUES ( 5023, 1, 1, 5, SYSDATE, 'Включена настройка "+DBO_UNLOAD_TYPE+". Событие для выгрузки не создается'  ) "; 
  else            
     Query = " INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP ) " +
             "  ( SELECT 5023, 1, 1, 1, SYSDATE FROM DUAL ) "; //тип загрузка курсов
  end;

  execSQL( Query );

  ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

  return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;


/*-------------------------------------------------------------------------------------------*/
/* Выгрузка закрытия договоров. Отдельным событием, если понадобится изменить период запуска */
/*-------------------------------------------------------------------------------------------*/
macro ws_Init_job_EventCloseContract() 
   var Query :string = "",
       Params :TArray,
       DataSet :RsdRecordset,
       ResultSheduler :object;
   var v_is_err = 0;

   Params = Null;
   DataSet = Null;
   Query = " SELECT A.t_recid, A.t_objecttype, A.t_objectid, A.t_type, " +
           "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
           "     WHERE B.T_LIST = 5002 " +
           "       AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_PRIORITY " + 

           "   FROM utableprocessevent_dbt A " +
           "  WHERE A.t_status = :p_Status " + 
           "    AND A.t_objecttype = 5100 "; 

   Params = makeArray( SQLParam( "p_Status", 1 ));  //формируется
   DataSet = execSQLselect( Query, Params );

   v_is_err = 0;
   while( DataSet.MoveNext ) //создание записи в очереди
      if( InsertSequenceJobDstrObj( DataSet.value(0, Null, V_INTEGER),
                                    DataSet.value(1, Null, V_INTEGER),
                                    DataSet.value(2, Null, V_INTEGER),
                                    DataSet.value(3, Null, V_INTEGER),
                                    ParsePriority( DataSet.value(4, Null, V_STRING ) ) ) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
//         ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
         ; /* Чтобы не менять условие */
      else
//         ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         v_is_err = 1;
      end;

   end;

   if(v_is_err == 0)
      ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   Params = Null;
   DataSet = Null;

   return ResultSheduler;

onError(err)

   Params = Null;
   DataSet = Null;

   ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

   return ResultSheduler;

end;


/*---------------------------------------------------*/
/*         Выгрузка закрытия договора по id          */
/*---------------------------------------------------*/
/* Запускается вручную, поэтому ничего не возвращает */
/*---------------------------------------------------*/
macro ws_Init_job_EventCloseContract_single(_contrid) 
   var Query :string = "",
       Params :TArray,
       DataSet :RsdRecordset,
       ResultSheduler :object;
   var v_is_err = 0;

   Params = Null;
   DataSet = Null;
   Query = " SELECT A.t_recid, A.t_objecttype, A.t_objectid, A.t_type, " +
           "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
           "     WHERE B.T_LIST = 5002 " +
           "       AND B.T_ELEMENT = A.T_OBJECTTYPE ) AS T_PRIORITY " + 
           "   FROM utableprocessevent_dbt A " +
           "  WHERE A.t_status = :p_Status " + 
           "    AND A.t_objecttype = 5100 "; 
   if (ValType(_contrid) != V_UNDEF)
      Query = Query + "AND A.t_objectid="+_contrid;
   end;

   Params = makeArray( SQLParam( "p_Status", 1 ));  //формируется
   DataSet = execSQLselect( Query, Params );

   v_is_err = 0;
   while( DataSet.MoveNext ) //создание записи в очереди
      if( InsertSequenceJobDstrObj( DataSet.value(0, Null, V_INTEGER),
                                    DataSet.value(1, Null, V_INTEGER),
                                    DataSet.value(2, Null, V_INTEGER),
                                    DataSet.value(3, Null, V_INTEGER),
                                    ParsePriority( DataSet.value(4, Null, V_STRING ) ) ) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
//         ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
         ; /* Чтобы не менять условие */
      else
//         ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         v_is_err = 1;
      end;

   end;

   Params = Null;
   DataSet = Null;

onError(err)

   Params = Null;
   DataSet = Null;

end;

/*----------------------------------------------------------------------*/
/* Поиск процесса загрузки предметов залога из ЕБПЗ                     */
/*----------------------------------------------------------------------*/
macro ws_check_job_EBPZ_bills_in ()
   const C_SOFR_EBPZ_BILL = 51;
   const C_STATUS_READY = 2;
   const C_STATUS_OK = 4;

   var v_sql, v_cmd, v_rs_in, v_rs_out;
   var v_result_scheduler;
   var v_state = true;
   var ResultSheduler:object;

   ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR); //По умолчанию поток отправляется на повтор

   v_sql =         "SELECT t_recid, t_objecttype, t_status ";
   v_sql = v_sql + "  FROM utableprocessin_dbt ";
   v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND t_status = :p_status_r ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_EBPZ_BILL);
   v_cmd.addParam("p_status_r", RSDBP_IN, C_STATUS_READY);

   v_rs_in = RSDRecordSet(v_cmd);
   if (v_rs_in.movenext())

      //Проверка на отсутствие необработанного исходящего потока
      v_sql =         "SELECT t_recid ";
      v_sql = v_sql + "  FROM uTableProcessOut_dbt ";
      v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";
      v_sql = v_sql + "   and t_status = :p_status_r";

      v_cmd = RSDCommand(v_sql);
      v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_EBPZ_BILL);
      v_cmd.addParam("p_status_r", RSDBP_IN, C_STATUS_READY);

      v_rs_out = RSDRecordSet(v_cmd);
      if(not v_rs_out.movenext())
         v_state = m_ins_funcobj_by_proc_in(v_rs_in.value("t_recid"), v_rs_in.value("t_objecttype"), v_rs_in.value("t_status"));
         if(v_state)
            m_upd_table_proc_in_status(v_rs_in.value("t_recid"), C_STATUS_OK);
            ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
         end;
      end;

      v_rs_out.close();
   end;

   v_rs_in.close(); v_cmd.close(); v_rs_in = NULL; v_rs_out = NULL; v_cmd = NULL; v_sql = NULL;

   return ResultSheduler;

onError(err)
   v_state = false;
   return v_state;
End;

/*---------------------------------------------------------------------------*/
/* Анализ и заполнение положительных значений НПР2 из буферной таблицы       */
/*---------------------------------------------------------------------------*/
macro ws_SOFR_positiveValues_NPR2 ()
      var v_sql, 
          v_cmd,
          v_rs,
          v_sql_result,
          v_sql_errortext;
      var v_hour, v_minutes;
      var ResultSheduler:object;

   TimeSplit (Time(), v_hour, v_minutes );


   if(((v_hour == 10) and (v_minutes == 25)) or 
      ((v_hour == 17) and (v_minutes == 25)) or 
      ((v_hour == 0) and (v_minutes == 10)))

         v_sql =         " DECLARE";
         v_sql = v_sql + "    v_date DATE := SYSDATE;";
         v_sql = v_sql + "    v_prev_timestamp DATE;";
         v_sql = v_sql + "    v_curr_timestamp DATE;";
         v_sql = v_sql + "    v_curr_hour NUMBER := EXTRACT(HOUR FROM CAST(v_date AS TIMESTAMP));";
         v_sql = v_sql + "    v_state NUMBER(5) := 0;";
         v_sql = v_sql + "    v_errm VARCHAR(1000);";
         v_sql = v_sql + "BEGIN";
         v_sql = v_sql + "  BEGIN";
         v_sql = v_sql + "    IF v_curr_hour = 10 THEN";
         v_sql = v_sql + "        v_curr_timestamp := TRUNC(v_date) + INTERVAL '10' HOUR;";
         v_sql = v_sql + "        v_prev_timestamp := TRUNC(v_date) - 1 + INTERVAL '23' HOUR + INTERVAL '55' MINUTE;";
         v_sql = v_sql + "    ELSIF v_curr_hour = 17 THEN";
         v_sql = v_sql + "        v_curr_timestamp := TRUNC(v_date) + INTERVAL '17' HOUR;";
         v_sql = v_sql + "        v_prev_timestamp := TRUNC(v_date) + INTERVAL '10' HOUR;";
         v_sql = v_sql + "    ELSIF v_curr_hour = 0 THEN";
         v_sql = v_sql + "        v_curr_timestamp := TRUNC(v_date) - 1 + INTERVAL '23' HOUR + INTERVAL '55' MINUTE;";
         v_sql = v_sql + "        v_prev_timestamp := TRUNC(v_date) - 1 + INTERVAL '17' HOUR;";
         v_sql = v_sql + "    ELSE";
         v_sql = v_sql + "        RETURN;";
         v_sql = v_sql + "    END IF;";
         v_sql = v_sql + "    INSERT INTO DRCV_DBT DRC (t_loaddate,";
         v_sql = v_sql + "                             t_FirmID,";
         v_sql = v_sql + "                             T_EKK,";
         v_sql = v_sql + "                             T_TIMESTAMP,";
         v_sql = v_sql + "                             t_EVENTYPE,";
         v_sql = v_sql + "                             t_ENTITYNUMBER,";
         v_sql = v_sql + "                             t_PORTFOLIOVALUE,";
         v_sql = v_sql + "                             t_INITMARGIN,";
         v_sql = v_sql + "                             t_MINMARGIN,";
         v_sql = v_sql + "                             t_RCV1,";
         v_sql = v_sql + "                             t_RCV2)";
         v_sql = v_sql + "    WITH RCV_TABLE AS ( ";
         v_sql = v_sql + "        SELECT d.t_ekk AS ekk, COUNT(*) AS cnt ";
         v_sql = v_sql + "        FROM DRCV_DBT d, ";
         v_sql = v_sql + "         (SELECT DISTINCT d.t_ekk AS ekk  ";
         v_sql = v_sql + "            FROM DRCV_DBT d ";
         v_sql = v_sql + "           WHERE d.t_timestamp = v_curr_timestamp";
         v_sql = v_sql + "             AND d.t_rcv2 < 0) t ";
         v_sql = v_sql + "        WHERE  d.t_rcv2 < 0 ";
         v_sql = v_sql + "          AND d.t_timestamp = v_prev_timestamp ";
         v_sql = v_sql + "         AND d.t_ekk = t.ekk ";
         v_sql = v_sql + "        GROUP BY d.t_ekk ) ";
         v_sql = v_sql + "    SELECT TRUNC(SYSDATE),";
         v_sql = v_sql + "           RCV.FirmID,";
         v_sql = v_sql + "           RCV.CLIENTCODE,";
         v_sql = v_sql + "           RCV.DATETIME,";
         v_sql = v_sql + "           RCV.EVENTYPE,";
         v_sql = v_sql + "           RCV.ENTITYNUMBER,";
         v_sql = v_sql + "           RCV.PORTFOLIOVALUE,";
         v_sql = v_sql + "           RCV.INITMARGIN,";
         v_sql = v_sql + "           RCV.MINMARGIN,";
         v_sql = v_sql + "           RCV.RCV1,";
         v_sql = v_sql + "           RCV.RCV2";
         v_sql = v_sql + "      FROM SOFR_RCV2Violations RCV";
         v_sql = v_sql + "      JOIN RCV_TABLE R ON R.ekk = RCV.clientcode";
         v_sql = v_sql + "                      AND R.cnt > 0";
         v_sql = v_sql + "     WHERE RCV.DATETIME > v_prev_timestamp AND RCV.DATETIME < v_curr_timestamp";
         v_sql = v_sql + "       AND RCV.rcv2 > 0;";
         v_sql = v_sql + "    COMMIT;";
         v_sql = v_sql + "  EXCEPTION";
         v_sql = v_sql + "    WHEN OTHERS THEN";
         v_sql = v_sql + "        v_state := 1;";
         v_sql = v_sql + "        v_errm := SQLERRM;";
         v_sql = v_sql + "  END;";
         v_sql = v_sql + "     :p_state := v_state;                     ";
         v_sql = v_sql + "     :p_errm := v_errm;                       ";
         v_sql = v_sql + "END;";
         
         v_cmd = RSDCommand(v_sql);
         v_cmd.addParam("p_state", RSDBP_OUT, V_INTEGER);
         v_cmd.addParam("p_errm", RSDBP_OUT, V_STRING,1000);
         v_cmd.execute();

         v_sql_result = v_cmd.value("p_state");
         v_sql_errortext =  v_cmd.value("p_errm");

         v_cmd.close(); v_cmd = NULL; 
      
         if (v_sql_result == 1)
            ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
            
         else 
            ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
         end;         
      else    
         ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
      end;

   return ResultSheduler;   
   
onError(err)
   ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return ResultSheduler;
end;


/*----------------------------------------------------------------------*/
/*  загрузка данных по НПР2                               */
/*----------------------------------------------------------------------*/
macro ws_check_job_npr2_in ()
   const C_SOFR_NPR2 = 13;
   const C_SOFR_NPR2_DLL = 33;
   const C_STATUS_READY = 2;

   var v_sql, v_cmd, v_rs;
   var v_result_scheduler;
   var v_state = true;
   var ResultSheduler:object;

   var hour, minutes;

  TimeSplit ( Time(), hour, minutes );


   if(((hour == 10) and (minutes == 5)) or 
      ((hour == 17) and (minutes == 5)) or 
      ((hour == 23) and (minutes == 59)))


      ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR); 

      v_sql =         "SELECT t_recid, t_status, 1 AS T_TYPE, ";
      v_sql = v_sql + " (SELECT B.T_NOTE FROM dllvalues_dbt B " ;
      v_sql = v_sql + "  WHERE B.T_LIST = 5002 AND B.T_CODE = '"+C_SOFR_NPR2_DLL+"') AS T_PRIORITY" ;
      v_sql = v_sql + "  FROM utableprocessin_dbt ";
      v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";
      v_sql = v_sql + "   AND t_status = :p_status_r ";

      v_cmd = RSDCommand(v_sql);
      v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_NPR2);
      v_cmd.addParam("p_status_r",   RSDBP_IN, C_STATUS_READY);

      v_rs = RSDRecordSet(v_cmd);
      if (v_rs.movenext())

         if(InsertSequenceJobUsrObj(v_rs.value("t_recid"),
                                    C_SOFR_NPR2_DLL,
                                    string("-", v_rs.value("t_type")),
                                    C_SOFR_NPR2_DLL,
                                    Null,
                                    ParsePriority( v_rs.value("T_PRIORITY") )) != 0) 

               ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
         else
               ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         end;

      end;

      v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;
   else 
      ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
   end;

   return ResultSheduler;

onError(err)
   v_state = false;
   return v_state;
End;

/*-----------------------------------------*/
/* Выгрузка в ЦХД данных по ц/б в ДУ       */
/*-----------------------------------------*/

macro ws_Init_job_Event_CHD_DU() :object
var Query :string = "", CMD,
    ResultSheduler :object;
var v_email_processor;
var CV_EMAIL_GRP_CHD = 1;

  cmd =ExecSqlSelect( "select * from uTableProcessEvent_dbt where T_OBJECTTYPE = 5029 and t_status < 4 ");
  cmd.movenext();
  if (valtype(cmd.value(0))!= 26)
    execSQL("update uTableProcessEvent_dbt set t_status = 5, t_resulttext = 'Ошибка события', t_lastupdate = sysdate where t_status < 4 and T_OBJECTTYPE = 5029");
  end;

            
  Query = " INSERT INTO uTableProcessEvent_dbt( T_OBJECTTYPE, T_OBJECTID, T_TYPE, T_STATUS, T_TIMESTAMP ) " +
          "  ( SELECT 5029, 1, 1, 1, SYSDATE FROM DUAL ) "; //тип выгрузка ДУ
  execSQL( Query );

  ResultSheduler = c_ssRunResult(SS_RESPONSE_END);

  return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;


/* BIQ-7335 Гераськина Т.В. Передача данных о НОБ из Депозитария в СОФР */
macro ws_check_job_NOBIn()
   var v_sql, v_cmd, v_rs;
   var v_result_scheduler;
   var v_state = true;

   v_sql =         "SELECT t_recid, t_objecttype, t_status ";
   v_sql = v_sql + "  FROM utableprocessin_dbt ";
   v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";   
   v_sql = v_sql + "   AND t_status = :p_status_r ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_NOB_IN);
   v_cmd.addParam("p_status_r", RSDBP_IN, C_EVENT_STAT_READY);

   v_rs = RSDRecordSet(v_cmd);
   /* Обрабатываем только первую запись */
   if(v_rs.movenext())
      v_state = m_ins_funcobj_by_proc_in(v_rs.value("t_recid"), v_rs.value("t_objecttype"), v_rs.value("t_status"));
      if(v_state)
         m_upd_table_proc_in_status(v_rs.value("t_recid"), C_EVENT_STAT_RUNNING);
      end;
   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   if(v_state != 0)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;

onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end; /* macro ws_check_job_NOBIn() */

/* BIQ-7335 Гераськина Т.В. Передача данных об откатах НОБ из Депозитария в СОФР */
macro ws_check_job_NOBIn_Undo()
   var v_sql, v_cmd, v_rs;
   var v_result_scheduler;
   var v_state = true;

   v_sql =         "SELECT t_recid, t_objecttype, t_status ";
   v_sql = v_sql + "  FROM utableprocessin_dbt ";
   v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";   
   v_sql = v_sql + "   AND t_status = :p_status_r ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_SOFR_NOB_IN_UNDO);
   v_cmd.addParam("p_status_r", RSDBP_IN, C_EVENT_STAT_READY);

   v_rs = RSDRecordSet(v_cmd);
   /* Обрабатываем только первую запись */
   if(v_rs.movenext())
      v_state = m_ins_funcobj_by_proc_in(v_rs.value("t_recid"), v_rs.value("t_objecttype"), v_rs.value("t_status"));
      if(v_state)
         m_upd_table_proc_in_status(v_rs.value("t_recid"), C_EVENT_STAT_RUNNING);
      end;
   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   if(v_state != 0)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;

onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end; /* macro ws_check_job_NOBIn_Undo() */

macro ws_check_job_NOB_out()
  var v_result_scheduler;

  var saveDialogFlag = SetDialogFlag(0);
  v_result_scheduler = ExecMacroFile("dlcontrsc.mac","ПечатьДоговоровСПревышениемНОБ", "");
  SetDialogFlag(saveDialogFlag);

  if (v_result_scheduler!=1)
  return v_result_scheduler;
  else
     v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
     return v_result_scheduler;
  end;
end;

private class (c_usr_tbl_base) c_usr_tbl_uTableProcessEvent()
   private class gen_uTableProcessEvent()
      var T_RECID :integer,
          T_TIMESTAMP :datetime,
          T_OBJECTTYPE :integer,
          T_OBJECTID :integer,
          T_TYPE :integer,
          T_STATUS :integer,
          T_NOTE :string,
          T_MESSAGEID :integer,
          T_RESULTCODE :string,
          T_RESULTTEXT :string;
   end;

   private macro init_table_obj()
      new_val_obj = gen_uTableProcessEvent();
      where_val_obj = gen_uTableProcessEvent();
   end;

   Initc_usr_tbl_base("uTableProcessEvent_dbt");

   init_table_obj();
end;


macro ws_check_job_RefiilQUIK
   var ProcessEventTbl;
   var v_result_scheduler;
   var v_recid = 0;

   ProcessEventTbl = c_usr_tbl_uTableProcessEvent();
   ProcessEventTbl.New_Val_Obj.T_STATUS = C_EVENT_STAT_READY;
   ProcessEventTbl.New_Val_Obj.T_OBJECTTYPE = 40;
   ProcessEventTbl.New_Val_Obj.T_OBJECTID = 1;
   ProcessEventTbl.New_Val_Obj.T_TIMESTAMP = dttm(date(), time());
   ProcessEventTbl.add_returning_prm("T_RECID");

   if( not ProcessEventTbl.Insert() ) 
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      return v_result_scheduler;
   else
      v_recid = ProcessEventTbl.New_Val_Obj.T_RECID;
      ProcessEventTbl = Null;  
   end;
   // сразу создаем FuncObj
   m_ins_funcobj_by_event(v_recid, 40, C_EVENT_STAT_READY);

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end;


macro ws_SPB_out

   var ProcessEventTbl;
   var v_result_scheduler;
   var v_recid = 0;
   var objecttype = 41;

   ProcessEventTbl = c_usr_tbl_uTableProcessEvent();
   ProcessEventTbl.New_Val_Obj.T_STATUS = C_EVENT_STAT_READY;
   ProcessEventTbl.New_Val_Obj.T_OBJECTTYPE = objecttype;
   ProcessEventTbl.New_Val_Obj.T_OBJECTID = 1;
   ProcessEventTbl.New_Val_Obj.T_TIMESTAMP = dttm(date(), time());
   ProcessEventTbl.add_returning_prm("T_RECID");

   if( not ProcessEventTbl.Insert() ) 
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      return v_result_scheduler;
   else
      v_recid = ProcessEventTbl.New_Val_Obj.T_RECID;
      ProcessEventTbl = Null;  
   end;
   // сразу создаем FuncObj
   m_ins_funcobj_by_event(v_recid, objecttype, C_EVENT_STAT_READY);

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;

end;

macro ws_SPB_in
   var v_result_scheduler;
   var v_recid = 0, v_state = true;

   var v_sql, v_cmd, v_rs;

   v_sql = "select t_recid, t_objecttype, t_status, t_timestamp, t_fullfilename "+
           "  from utableprocessin_dbt where t_objecttype in (61,62,63,64,66) and t_status = :status";
   v_cmd = RSDCommand(v_sql);
   v_cmd.AddParam("status", RSDBP_IN, C_EVENT_STAT_READY);
   v_rs = RSDRecordSet(v_cmd);

   // обрабатываем не поштучно, а сразу вообще все файлы от Спб
   while (v_rs.movenext)
//      v_state = m_ins_funcobj_by_proc_in(v_rs.value("t_recid"), v_rs.value("t_objecttype"), v_rs.value("t_status"));
//      if(v_state)
         m_upd_table_proc_in_status(v_rs.value("t_recid"), C_EVENT_STAT_RUNNING);
         v_recid = v_rs.value("t_recid");
//      end;
   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;
   if (v_recid > 0)
//      v_state = m_ins_funcobj_by_proc_in(v_recid, 61, 2);
      v_state = m_ins_funcobj_by_proc_in(v_recid, 61, 3); //мы же только что в статус 3 перевели. а ищем в статусе 2
   end;

   if(v_state != 0)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end;

/* BIQ-9185 Гераськина Т.В. обработка событий по квал.инвесторам */
/* 5070 - уведомление клиенту о включении в реестр квал.инвесторов */
macro ws_QI
   var v_sql, v_cmd, v_rs;
   var v_result_scheduler;
   var v_state = true;
   const C_QI_INCLUSION = 5070;
   var ProcessEventTbl;

   v_sql =         "SELECT tbl_evnt.t_recid, tbl_evnt.t_objecttype, tbl_evnt.t_objectid, nvl(tbl_evnt.t_type,1) as t_type, ";
   v_sql = v_sql + "       tbl_llval.t_code, tbl_llval.t_note as T_PRIORITY ";
   v_sql = v_sql + "  FROM utableprocessevent_dbt tbl_evnt, dllvalues_dbt tbl_llval ";
   v_sql = v_sql + " WHERE tbl_llval.t_list = USR_PKG_IMPORT_SOFR.GetOBJECT_SYNCH ";
   v_sql = v_sql + "   AND tbl_llval.t_element = tbl_evnt.t_objecttype ";
   v_sql = v_sql + "   AND tbl_evnt.t_objecttype = :p_objecttype ";
   v_sql = v_sql + "   AND tbl_evnt.t_status = :p_status ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype", RSDBP_IN, C_QI_INCLUSION);
   v_cmd.addParam("p_status", RSDBP_IN, C_EVENT_STAT_NEW);
   v_rs = RSDRecordSet(v_cmd);
   if(v_rs.movenext())
      if(InsertSequenceJobUsrObj(v_rs.value("t_objectid"),
                                 v_rs.value("t_objecttype"),
                                 v_rs.value("t_recid"),
                                 v_rs.value("t_code"),
                                 Null,
                                 ParsePriority( v_rs.value("T_PRIORITY") ) )!= 0) /* вставить в func_obj в соответствии с Objecttype */
         v_state = false;
      end;
      if (v_state)
         //установка статуса в uTableProcessEvent_dbt
         ProcessEventTbl = c_usr_tbl_uTableProcessEvent();
         ProcessEventTbl.New_Val_Obj.T_STATUS = C_EVENT_STAT_RUNNING;
         ProcessEventTbl.Where_Val_Obj.T_RECID = v_rs.value("t_recid");
         if( not ProcessEventTbl.Update() )
            v_state = false;
         end;
         ProcessEventTbl = Null;
      end;

   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   if(v_state)
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   return v_result_scheduler;

onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;

end;

/* BIQ-9185 Гераськина Т.В.
   Рассылка уведомлений по праве исключения из реестра квал.инвесторов
*/
macro ws_job_QI_Exclusion
   var ProcessEventTbl;
   var v_result_scheduler;
   var v_recid = 0;
   var C_OBJECTTYPE = 5071;
   var C_CODE = 71;
   var v_state = true;

   var sql_str, rs, cmd, cnt = 0; 
   // процесс длительный, поэтому вставляем только 1 незавершенное событие за сутки
   sql_str = "select count(*) from utableprocessevent_dbt f "+
             " where t_objecttype = :objecttype and t_objectid = 1 and trunc(t_timestamp) = trunc(sysdate) "+
             "   and t_status not in (4,5) ";
   cmd = RSDCommand(sql_str);
   cmd.AddParam("objecttype", RSDBP_IN, C_OBJECTTYPE);
   rs = RSDRecordSet(cmd);
   if (rs.movenext)
      cnt = rs.value(0);
   end;
   if (cnt == 0)
      ProcessEventTbl = c_usr_tbl_uTableProcessEvent();
      ProcessEventTbl.New_Val_Obj.T_STATUS = C_EVENT_STAT_READY;
      ProcessEventTbl.New_Val_Obj.T_OBJECTTYPE = C_OBJECTTYPE;
      ProcessEventTbl.New_Val_Obj.T_OBJECTID = 1;
      ProcessEventTbl.New_Val_Obj.T_TIMESTAMP = dttm(date(), time());
      ProcessEventTbl.add_returning_prm("T_RECID");

      if( not ProcessEventTbl.Insert() ) 
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         return v_result_scheduler;
      else
         v_recid = ProcessEventTbl.New_Val_Obj.T_RECID;
         ProcessEventTbl = Null;  
      end;
      // сразу создаем FuncObj
      if(InsertSequenceJobUsrObj(v_recid,
                                 C_OBJECTTYPE,
                                 1,
                                 C_CODE,
                                 Null,
                                 "0")!= 0) /* вставить в func_obj в соответствии с Objecttype */
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      else 
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
      end;
   else
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   end;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;

end;

//def-26510 обработка запросов QUIK вынесена в отдельный планировщик
macro ws_process_quik() :object

const CV_QUIK_EVENT = 5025;
const CV_STAT_READY = 1;

var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;
var v_is_err = 0;
var v_priority;

   Query =  "select u.t_recid, u.t_objecttype, u.t_objectid, u.t_type, l.t_note as t_priority "+
            "  from uTableProcessEvent_dbt u, "+
            "       dllvalues_dbt l "+
            " where l.t_list = :p_list and l.t_element = u.t_objecttype "+
            "   and u.t_objecttype = :p_objecttype and u.t_status = :p_Status "; 
   Params = makeArray( SQLParam( "p_list", CV_LIST_VALUES ), 
                       SQLParam( "p_objecttype", CV_QUIK_EVENT ), 
                       SQLParam( "p_Status", CV_STAT_READY ) );
   DataSet = execSQLselect( Query, Params );

   v_is_err = 0;
   while( DataSet.MoveNext ) //создание записи в очереди
      v_priority = ParsePriority( DataSet.value(4, Null, V_STRING) );
      if( InsertSequenceJobDstrObj( DataSet.value(0, Null, V_INTEGER),
                                    DataSet.value(1, Null, V_INTEGER),
                                    DataSet.value(2, Null, V_INTEGER),
                                    DataSet.value(3, Null, V_INTEGER),
                                    v_priority ) == 0 ) 
         ; 
      else
         v_is_err = 1;
      end;
   end;

   if(v_is_err == 0)
      ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
   else
      ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   end;

   Params = Null;
   DataSet = Null;

   return ResultSheduler;

onError(err)
  Params = Null;
  DataSet = Null;
  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  return ResultSheduler;
end; /* macro ws_process_quik() */


//def-27935 Равномерная выгрузка зависших событий в АСОА
//Обработчик исходящих потоков для выгрузки досье в АСОА
macro ws_unload_ASOA() :object
var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;

const REG_NUMBER_SET = "РСХБ\\ИНТЕГРАЦИЯ\\INTEGR_SERV_PRM\\EXT_SERVICES\\UPLOADDOC\\МАКС_КОЛ-ВО_ОБЪЕКТОВ_СЕАНСА";
const CV_LIST_VALUES = 5002;
const CV_ASOA_EVENT = 6207;
const CV_STAT_READY = 1;
var v_priority;
var v_cnt =0, v_number_set=0, stat;

   GetRegistryValue(REG_NUMBER_SET, V_INTEGER, v_number_set, stat);
   if (stat>0)
      v_number_set = 0; // без ограничений
   end;

   Params = Null;
   DataSet = Null;

   Query =  "select u.t_recid, u.t_objecttype, u.t_objectid, u.t_type, l.t_note as t_priority "+
            "  from uTableProcessEvent_dbt u, "+
            "       dllvalues_dbt l "+
            " where l.t_list = :p_list and l.t_element = u.t_objecttype "+
            "   and u.t_objecttype = :p_objecttype and u.t_status = :p_Status "+
            " order by u.t_recid"; 
   Params = makeArray( SQLParam( "p_list", CV_LIST_VALUES ), 
                       SQLParam( "p_objecttype", CV_ASOA_EVENT ), 
                       SQLParam( "p_Status", CV_STAT_READY ) );
   DataSet = execSQLselect( Query, Params );

   while( DataSet.MoveNext ) //создание записи в очереди
      v_priority = ParsePriority( DataSet.value(4, Null, V_STRING) );
      if( InsertSequenceJobDstrObj(DataSet.value(0, Null, V_INTEGER), DataSet.value(1, Null, V_INTEGER), DataSet.value(2, Null, V_INTEGER),
                                   DataSet.value(3, Null, V_INTEGER),
                                   v_priority
                                   ) == 0) // вставить в очередь в соответствии с ObjectId в func_obj
         ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
      else
         ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      end;
      v_cnt = v_cnt + 1;
      if (v_number_set > 0)
         if (v_cnt > v_number_set)
            break;
         end;
      end;
   end;
  
  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  return ResultSheduler;

onError(err)
  Params = Null;
  DataSet = Null;
  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  return ResultSheduler;
end;

// BIQ-7817 
// Ответ на запрос на получение активов клиента
// ИП-оффлайн
macro ws_check_job_assets
   const C_SOFR_ASSET_IN = 33;
   const C_SOFR_ASSET_OUT = 35;

   var v_result_scheduler;
   var v_recid = 0, v_state = true, v_priority = 0;
   var v_sql, v_cmd, v_rs;
   var v_sql2, v_cmd2, v_rs2;
   var v_cmd_upd;
   var v_cnt = 0;

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR); //По умолчанию поток отправляется на повтор

   v_sql = "select batch_id "+
           "  from ISMR_DATA where object_flow = :p_objecttype and status = :p_status "+
           " order by date_begin";
   v_cmd = RSDCommand(v_sql);
   v_cmd.AddParam("p_objecttype", RSDBP_IN, C_SOFR_ASSET_IN);
   v_cmd.AddParam("p_status", RSDBP_IN, C_EVENT_STAT_READY);
   v_rs = RSDRecordSet(v_cmd);

   // событие должно быть одно, потому что таблица по клиентам каждый раз очищается
   if (v_rs.movenext)
      //Проверка на отсутствие текущего входящего потока (в том числен добавлено в dfuncobj_dbt, но еще не выполнено)
      v_sql2 = "SELECT count(*) cnt "+
               "  FROM ISMR_DATA "+
               " WHERE object_flow = :p_objecttype "+
               "   AND status = :p_status";
      v_cmd2 = RSDCommand(v_sql2);
      v_cmd2.addParam("p_objecttype", RSDBP_IN, C_SOFR_ASSET_IN);
      v_cmd2.addParam("p_status", RSDBP_IN, C_EVENT_STAT_RUNNING);
      v_rs2 = RSDRecordSet(v_cmd2);
      if (v_rs2.movenext())
         v_cnt = v_rs2.value("cnt");
      end;
      v_rs2.close; v_cmd2.close;
      v_rs2 = null; v_cmd2 = null;

      if (v_cnt == 0)
         v_recid = v_rs.value("batch_id");
         v_sql2 = "select l.t_note as t_priority, l.t_element, l.t_code "+
                  "  from dllvalues_dbt l "+
                  " where l.t_list = :p_list and l.t_code = to_char(:p_objecttype)"; 
         v_cmd2 = RSDCommand(v_sql2);
         v_cmd2.AddParam("p_list", RSDBP_IN, CV_LIST_VALUES);
         v_cmd2.AddParam("p_objecttype", RSDBP_IN, C_SOFR_ASSET_OUT);
         v_rs2 = RSDRecordSet(v_cmd2);
         if (v_rs2.movenext)
            v_priority = ParsePriority(v_rs2.value("t_priority"));
            v_state = InsertSequenceJobUsrObj( 1, v_rs2.value("t_code"), 1, v_rs2.value("t_code"), 0, v_priority );
            if (v_state == 0)
               v_cmd_upd = RSDCommand("update ISMR_DATA set status = :pstatus where batch_id = :pbatch_id ");
               v_cmd_upd.AddParam("pstatus", RSDBP_IN, C_EVENT_STAT_RUNNING);
               v_cmd_upd.AddParam("pbatch_id", RSDBP_IN, v_recid);
               v_cmd_upd.execute;
               v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
               v_cmd_upd.close; v_cmd_upd = null;
            end;
         end;
         v_rs2.close; v_cmd2.close;
         v_rs2 = null; v_cmd2 = null;
      end;
   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end;

// DEF-36300
// Пропущенные значения кодов срочного рынка
// По планировщику проверяется количество свободных значений в последовательностях
macro ws_check_job_DropSeqF500
   var v_result_scheduler;
   var v_sql, v_rs;
   var v_sql2, v_cmd2;
   var res;
   var v_max_number, stat;
   
   private const REG_NUMBER_MISSED = "РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\КОЛ-ВО_ПРОПУЩ_КОДОВ_ДЛЯ_СБРОСА";
   private const NUMBER_LLVALUE_FIRMID = 5053; 
   
   GetRegistryValue(REG_NUMBER_MISSED, V_INTEGER, v_max_number, stat);
   if (stat>0)
      v_max_number = 200; 
   end;

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR); //По умолчанию поток отправляется на повтор

   v_sql2 = 
   "declare "+
   "   v_sql varchar2(2000); "+
   "   v_maxmissedcount number := :p_maxmissedcount; "+
   "   v_firmid varchar2(200) := :p_firmid; "+
   "   v_lastnumber number; "+
   "   v_free_codes number; "+
   "   v_seq_name varchar2(100); "+
   "   c_maxcount constant number := 46656; "+
   "begin "+
   "   v_seq_name := 'U_' || UPPER (v_firmid) || '_SEQ'; "+
   "   v_sql := 'SELECT last_number FROM all_sequences WHERE sequence_name = :p_seq_name'; "+
   "   begin "+
   "      execute immediate v_sql into v_lastnumber using v_seq_name; "+
   "   exception "+
   "      when no_data_found then v_lastnumber :=0; "+
   "   end; "+
   "   if v_lastnumber > 0  and v_lastnumber+v_maxmissedcount > c_maxcount  then "+
   "      v_sql := 'select  :p_maxcount - count(distinct(t_mpcode)) from ddlcontrmp_dbt where t_mpcode like '''||UPPER (v_firmid)||'%'''; "+
   "      execute immediate v_sql into v_free_codes using c_maxcount; "+
   "      if v_free_codes > v_maxmissedcount then "+
   "         v_sql :=  'DROP SEQUENCE '||v_seq_name; "+
   "         execute immediate v_sql; "+
   "         v_sql := 'CREATE SEQUENCE '||v_seq_name||' START WITH 1 MAXVALUE '||c_maxcount||' MINVALUE 1'; "+
   "         execute immediate v_sql; "+
   "         :p_res := 'OK';  "+
   "      end if; "+
   "   end if;  "+
   "exception "+
   "   when others then :p_res := sqlerrm; "+
   "end; ";

   v_sql = "select t_code from dllvalues_dbt where t_list = "+NUMBER_LLVALUE_FIRMID+" order by t_element";
   v_rs = RSDRecordSet(v_sql);
   while (v_rs.movenext)
      v_cmd2 = RSDCommand(v_sql2);
      v_cmd2.Addparam("p_maxmissedcount", RSDBP_IN, v_max_number);
      v_cmd2.Addparam("p_firmid", RSDBP_IN, v_rs.value("t_code"));
      v_cmd2.addParam("p_res", RSDBP_OUT, V_STRING);
      v_cmd2.execute;
      res = v_cmd2.value("p_res");
      
      if ( (ValType(res) == V_UNDEF) or (ValType(res) == 26) )
         // ничего не было сделано
      else
         if (res == "OK")
            WS_WriteAuditMessage("Планировщиком выполнен сброс последовательности U_"+StrUpr(v_rs.value("t_code"))+"_SEQ" );
         else 
            WS_WriteAuditMessage("Планировщиком не выполнен сброс последовательности U_"+StrUpr(v_rs.value("t_code"))+"_SEQ, ошибка "+res);
         end;
      end;
   end;
   
   v_rs.close; v_rs = null;
   v_cmd2.close; v_cmd2 = null;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end;

// BIQ-11556 
// Формирование остатков по внебирже в служебной таблице
macro ws_FillContrTable_job
   const C_SOFR_OVERSTOCK = 5160;

   var v_result_scheduler;
   var v_recid = 0, v_state = true, v_priority = 0;
   var v_sql, v_cmd, v_rs;
   var v_cmd_upd;

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR); //По умолчанию поток отправляется на повтор

   v_sql =        " declare ";
   v_sql = v_sql+ "  vres number; ";
   v_sql = v_sql+ "  vcnt number; ";
   v_sql = v_sql+ "  vobjecttype number := :pobjecttype; ";
   v_sql = v_sql+ " begin ";
   v_sql = v_sql+ "  update utableprocessevent_dbt d ";
   v_sql = v_sql+ "     set t_status = 5, t_note = 'Timeout 3 HOURS' ";
   v_sql = v_sql+ "   where t_objecttype = vobjecttype ";
   v_sql = v_sql+ "     and t_status = 2 ";
   v_sql = v_sql+ "     and t_timestamp < (sysdate - NUMTODSINTERVAL(3, 'HOUR')); ";
   v_sql = v_sql+ "  select count(*) into vcnt ";
   v_sql = v_sql+ "    from uTableProcessEvent_dbt "; 
   v_sql = v_sql+ "   where t_objecttype = vobjecttype and t_status in (1,2); ";
   v_sql = v_sql+ "  if vcnt = 0 then ";
   v_sql = v_sql+ "     INSERT INTO uTableProcessEvent_dbt ";
   v_sql = v_sql+ "      (t_timestamp, t_objecttype, t_objectid, t_type, t_status)  ";
   v_sql = v_sql+ "     VALUES (sysdate, vobjecttype, 1, 1, 1) ";
   v_sql = v_sql+ "     returning t_recid into vres; ";
   v_sql = v_sql+ "  else  ";
   v_sql = v_sql+ "     vres := 0; ";
   v_sql = v_sql+ "  end if;  ";
   v_sql = v_sql+ "  :pres := vres; ";
   v_sql = v_sql+ " end; ";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("pobjecttype", RSDBP_IN, C_SOFR_OVERSTOCK);
   v_cmd.addParam("pres", RSDBP_OUT, v_integer);
   v_cmd.execute();

   v_recid = int(v_cmd.Value("pres"));
   v_cmd.close(); v_cmd = null; v_sql = null;

   if (v_recid == 0)
      // проверим, есть ли необработанное событие. При добавлении в dfuncobj есть проверка на дублирование
      v_sql =        " select t_recid ";
      v_sql = v_sql+ "   from uTableProcessEvent_dbt "; 
      v_sql = v_sql+ "  where t_objecttype = :pobjecttype and t_status = :pstatus ";
      v_cmd = RSDCommand(v_sql);
      v_cmd.addParam("pobjecttype", RSDBP_IN, C_SOFR_OVERSTOCK);
      v_cmd.addParam("pstatus", RSDBP_IN, C_EVENT_STAT_NEW);
      v_rs = RSDRecordSet(v_cmd);
      if (v_rs.movenext)
         v_recid = v_rs.value("t_recid");
      end; 
   end;

   if (v_recid > 0)
      v_sql =        "select l.t_note as t_priority, l.t_element, l.t_code ";
      v_sql = v_sql+ "  from dllvalues_dbt l ";
      v_sql = v_sql+ " where l.t_list = :p_list and l.t_code = to_char(:p_objecttype)"; 
      v_cmd = RSDCommand(v_sql);
      v_cmd.AddParam("p_list", RSDBP_IN, CV_LIST_VALUES);
      v_cmd.AddParam("p_objecttype", RSDBP_IN, C_SOFR_OVERSTOCK);
      v_rs = RSDRecordSet(v_cmd);
      if (v_rs.movenext)
         v_priority = ParsePriority(v_rs.value("t_priority"));
         v_state = InsertSequenceJobDstrObj( v_recid, v_rs.value("t_code"), 1, 1, v_priority );
         if (v_state == 0)
            v_cmd_upd = RSDCommand("update uTableProcessEvent_dbt set t_status = :pstatus, t_lastupdate = sysdate where t_recid = :precid ");
            v_cmd_upd.AddParam("pstatus", RSDBP_IN, C_EVENT_STAT_READY);
            v_cmd_upd.AddParam("precid", RSDBP_IN, v_recid);
            v_cmd_upd.execute;
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
            v_cmd_upd.close; v_cmd_upd = null;
         end;

      end;
      v_rs.close; v_cmd.close;
      v_rs = null; v_cmd = null;
   else 
      v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
   end;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end;
/* BIQ-8258 Шишкин Е.В.
   рассылка уведомлений о расторжение договора ИИС в связи с непредоставлением подтверждающих документов по ИИС
*/

macro ws_job_Close_AC()
   var ProcessEventTbl;
   var v_result_scheduler;
   var v_recid = 0;
   const C_OBJECTTYPE = 8258;

   var sql, rs, cmd, cnt = 0; 

//запускаем только в рабочий день, для закрытия отберуться договора у которых значение примечания(дата закрытия) меньше или равна текущей дате
   if(IsWorkday(date()) == 1)

      sql = " select sf.t_datebegin, sf.t_partyid,dd.* from ddlcontr_dbt dd, dsfcontr_dbt sf where dd.t_sfcontrid = sf.t_id and sf.t_dateclose = to_date('01.01.0001','dd.mm.yyyy')    "+
            " and exists ( select 1 from dobjatcor_dbt obj where obj.t_objecttype = "+BROKER_SERV_CONTR+" and obj.t_object = dd.t_dlcontrid                   "+
            "                    and obj.t_groupid = "+IS_ANOTHER_CONTRACT_IIS+" and obj.t_validtodate = to_date('31.12.9999','dd.mm.yyyy') and obj.t_attrid = 1    "+
            "            )                                                                                                                  "+
            " and exists ( select 1 from dnotetext_dbt where                                                                                "+
            "                   t_objecttype = "+BROKER_SERV_CONTR+" and t_documentid = lpad( dd.t_dlcontrid,34,'0') and t_notekind = "+CONTARCT_NOTEKIND_DATE_CLOSE_ISANOTHERCONTRACT+
            "                    and rsb_struct.getdate(t_text) <= trunc(sysdate)                                                            "+
            "            )                                                                                                                  "+                
            " and not exists ( SELECT 1 FROM dobjatcor_dbt obj WHERE obj.t_objecttype = "+BROKER_SERV_CONTR+" AND obj.t_object = dd.t_dlcontrid               "+
            "                  AND obj.t_groupid = "+CONTRACT_CATEGORY_DOC_CLOSE+"                                                                                      "+
            "                  AND obj.t_validtodate = TO_DATE ('31.12.9999', 'dd.mm.yyyy') AND obj.t_attrid = 1                            "+
            "                )                                                                                                              ";
                                                                                                                          
      rs = RSDRecordSet(sql);
   
      while (rs.movenext)         
   
         ProcessEventTbl = c_usr_tbl_uTableProcessEvent();
         ProcessEventTbl.New_Val_Obj.T_STATUS = C_EVENT_STAT_READY;
         ProcessEventTbl.New_Val_Obj.T_OBJECTTYPE = C_OBJECTTYPE;
         ProcessEventTbl.New_Val_Obj.T_OBJECTID = rs.value("t_dlcontrid");
         ProcessEventTbl.New_Val_Obj.T_TIMESTAMP = dttm(date(), time());
         ProcessEventTbl.add_returning_prm("T_RECID");
   
         if( not ProcessEventTbl.Insert() ) 
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
            return v_result_scheduler;
         else
            v_recid = ProcessEventTbl.New_Val_Obj.T_RECID;
            ProcessEventTbl = Null;  
         end;
   
         // сразу создаем FuncObj
         if(InsertSequenceJobUsrObj(v_recid,
                                    C_OBJECTTYPE,
                                    rs.value("t_dlcontrid"),
                                    C_OBJECTTYPE,                                    
                                    Null,
                                    "0")!= 0) 
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         else 
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
         end;
       end;
   end;

   return v_result_scheduler;

onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;

end;

/* BIQ-8258 Шишкин Е.В.
   рассылка уведомлений о необходимости предоставления подтверждающих документов по ИИС
*/

Macro ws_Notify_AC()

 private file attr("objattr.dbt") key 0;
 private file attrcor("objatcor.dbt") key 0;

 private const  CONTR_MESSAGE_NOTIFY_IIS = 507;
 private const  EMAILTEXT = string(" Уважаемый Клиент! ",
                                  "\n",
                                  "\nИнформируем, что Вами в АО \x22Россельхозбанк\x22 не предоставлены подтверждающие документы о расторжении договора ИИС,", 
                                  "\nзаключенного с другим профессиональным участником в соответствии с данными, указанными при заключении договора ИИС в АО \x22Россельхозбанк\x22.", 
                                  "\nОбращаем внимание, что подтверждающие документы требуется предоставить не позднее 30-ти календарных дней с даты заключения договора ИИС в АО \x22Россельхозбанк\x22.",
                                  "\nВ случае непредоставления документов договор ИИС будет расторгнут.",
                                  "\nПеречень документов, которые необходимо предоставить в \x22Россельхозбанк\x22 :",
                                  "\n- Подтверждение прекращения предыдущего договора (копию подписанного соглашения о расторжении или уведомления о расторжении с отметкой о его принятии профессиональным участником рынка ценных бумаг);",
                                  "\n- Сведения о физическом лице и его индивидуальном инвестиционном счете (форма утверждена Приказом ФНС России от 15.12.2014 N ММВ-7-11/646@).",
                                  "\n",
                                  "\n",
     	 		          "\n			        			С уважением,           ",
     	  	        	    "\n						АО \x22Россельхозбанк\x22.   \n\n");
        
 var sql, rs, cmd, query, params;
 var ObjCat, SecondNotify, FirstNotify;
 var EMailContact,SUBJECT, BeginDateContract, DateFirstNotify, DateSecondNotify;
 var dlcontrmsg, contrmsg;
 var v_result_scheduler;
 var v_email_processor;
                              
 GetRegistryValue ("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\ИНФОРМИРОВАНИЕ ПО ИИС\\ПЕРВОЕ СООБЩ. КЛИЕНТУ ИИС", V_INTEGER, FirstNotify);
 GetRegistryValue ("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\ИНФОРМИРОВАНИЕ ПО ИИС\\ПОВТОРНОЕ СООБЩ. КЛИЕНТУ ИИС", V_INTEGER, SecondNotify);

 sql = " select dd.t_dlcontrid, dd.t_email, sf.t_datebegin, sf.t_partyid,sf.t_number, (select t_name from dparty_dbt where t_partyid = sf.t_partyid) as fio "+
       " from ddlcontr_dbt dd, dsfcontr_dbt sf  where dd.t_iis = chr(88) "+
       " and dd.t_sfcontrid = sf.t_id and sf.t_dateclose = to_date('01.01.0001','dd.mm.yyyy')                                               "+
       " and exists ( select 1 from dobjatcor_dbt obj where obj.t_objecttype =  "+BROKER_SERV_CONTR+" and obj.t_object = dd.t_dlcontrid      "+
       "              and obj.t_groupid = "+IS_ANOTHER_CONTRACT_IIS+" and obj.t_validtodate = to_date('31.12.9999','dd.mm.yyyy') and obj.t_attrid = 1  "+
       "            )                                                                                                                       "+
       " and not exists ( SELECT 1 FROM dobjatcor_dbt obj WHERE obj.t_objecttype = "+BROKER_SERV_CONTR+" AND obj.t_object = dd.t_dlcontrid  "+
       "                  AND obj.t_groupid = "+CONTRACT_CATEGORY_DOC_CLOSE+"                                                               "+
       "                  AND obj.t_validtodate = TO_DATE ('31.12.9999', 'dd.mm.yyyy') AND obj.t_attrid = 1                                 "+
       "                )                                                                                                                   ";
                                                                                                                                            

 rs = RSDRecordSet(sql);
 while (rs.movenext) 

   BeginDateContract = date(date(rs.value("t_datebegin")));
   DateFirstNotify = GetDateAfterWorkDays(BeginDateContract, int(FirstNotify), 0); //дата первой отправки сообщения

   cmd = ExecSqlSelect("select max(t_senddate), count(t_senddate) from ddlcontrmsg_dbt where t_dlcontrid = :dlcontr and t_kind = "+CONTR_MESSAGE_NOTIFY_IIS+" and t_senddate <> to_date('01.01.0001','dd.mm.yyyy')", makeArray(SqlParam("dlcontr", rs.value("t_dlcontrid") )));
   if(cmd.movenext());
      if(cmd.value(1)>0) //если первая отправка сообщения уже была 
         DateSecondNotify = GetDateAfterWorkDays(date(cmd.value(0)), SecondNotify, 0); //дата повторных отправок сообщений
      end;
   end;
 
   if((DateFirstNotify == date()) or (DateSecondNotify == date())) // прошло достаточно дней для первой или второй рассылки

      v_email_processor = c_email_proc_env();

// создадим сообщение на договоре
      dlcontrmsg = Tbfile("dlcontrmsg.dbt", "W", 0);
     
      dlcontrmsg.rec.DlContrID = rs.value("t_dlcontrid");
      dlcontrmsg.rec.Kind = CONTR_MESSAGE_NOTIFY_IIS;
      dlcontrmsg.rec.CreateDate = {curdate};
      dlcontrmsg.rec.CreateTime = Time();
      dlcontrmsg.rec.MarketID = -1;
      if(dlcontrmsg.insert())
        contrmsg = true;
      end;
     
// отправим сообщение клиенту
      if(contrmsg)
         if (rs.value("t_email") != "");
            EMailContact = rs.value("t_email");
         else
            EMailContact = "-";
         end;

         SUBJECT = "Уведомление о необходимости предоставления документов по ИИС номер договора "+rs.value("t_number")+" ФИО "+rs.value("fio");

         v_email_processor.m_set_msg_head(SUBJECT);
         v_email_processor.m_add_email_to_list(EMailContact);
         v_email_processor.m_add_email_to_bcc_list("custody@rshb.ru");
         v_email_processor.m_add_broker_email_to_bcc_list();
         v_email_processor.m_add_row_to_msg_text(EMAILTEXT);
         v_email_processor.m_save_to_submit_synch();
         v_email_processor.m_submit_email_synch();
      
//установим время отправки если успешно отправили
         if(not v_email_processor.m_get_error_status())
            query = " UPDATE DDLCONTRMSG_DBT SET T_SENDDATE = :SENDDATE, T_SENDTIME = :SENDTIME WHERE t_id in (select max(t_id) from DDLCONTRMSG_DBT where t_dlcontrid = :ID and t_kind = 507)";
            params = makeArray(SQLParam("SENDDATE", {curdate}),
                               SQLParam("SENDTIME", Time()),
                               SQLParam("ID", rs.value("t_dlcontrid")));
            execSQL(query, params, true);   
         end;

      end; 

      EMailContact = null; DateFirstNotify = null; DateSecondNotify = null; BeginDateContract = null; v_email_processor = null;

   end;

 end;
   
 sql = null; rs.close; rs = null; ObjCat= null;

 return  v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);

onError(err)

   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;

end;


/* BIQ-8258 Шишкин Е.В.
   Отчет по договорам ИИС, по которым не предоставлены подтверждающие документы
*/

macro ws_Report_AC()

 var v_email_processor = c_email_proc_env();
 var v_result_scheduler;
 var FirstNotifyReport,SecondNotifyReport;
 var ReportPath :Tarray;
 var sql, rs, cmd;

 GetRegistryValue ("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\ИНФОРМИРОВАНИЕ ПО ИИС\\ПЕРВЫЙ ОТЧЕТ ОД И ДРРК", V_INTEGER, FirstNotifyReport);
 GetRegistryValue ("РСХБ\\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\\ИНФОРМИРОВАНИЕ ПО ИИС\\ПОВТОРНЫЙ ОТЧЕТ ОД И ДРРК", V_INTEGER, SecondNotifyReport);
                                                                                                                                          
 sql = " select dd.t_dlcontrid, sf.t_datebegin, sf.t_partyid from ddlcontr_dbt dd, dsfcontr_dbt sf  where dd.t_iis = chr(88)               "+
       " and dd.t_sfcontrid = sf.t_id and sf.t_dateclose = to_date('01.01.0001','dd.mm.yyyy')                                              "+
       " and exists ( select 1 from dnotetext_dbt where                                                                                    "+
       "                   t_objecttype = "+BROKER_SERV_CONTR+" and t_documentid = lpad( dd.t_dlcontrid,34,'0') and t_notekind = "+CONTARCT_NOTEKIND_DATE_CLOSE_ISANOTHERCONTRACT+
       "                    and rsb_struct.getdate(t_text) = trunc(sysdate) + :NotifyReport                                                "+
       "            )                                                                                                                      "+                
       " and exists ( select 1 from dobjatcor_dbt obj where obj.t_objecttype =  "+BROKER_SERV_CONTR+" and obj.t_object = dd.t_dlcontrid    "+
       "              and obj.t_groupid = "+IS_ANOTHER_CONTRACT_IIS+" and obj.t_validtodate = to_date('31.12.9999','dd.mm.yyyy') and obj.t_attrid = 1 "+
       "            )                                                                                                                      "+
       " and not exists ( SELECT 1 FROM dobjatcor_dbt obj WHERE obj.t_objecttype =  "+BROKER_SERV_CONTR+" AND obj.t_object = dd.t_dlcontrid "+
       "                  AND obj.t_groupid = "+CONTRACT_CATEGORY_DOC_CLOSE+"                                                              "+
       "                  AND obj.t_validtodate = TO_DATE ('31.12.9999', 'dd.mm.yyyy') AND obj.t_attrid = 1                                "+
       "                )                                                                                                                  ";


 cmd = RSDCommand(sql);
 cmd.addParam("NotifyReport", RSDBP_IN, FirstNotifyReport);
 rs = RSDRecordSet(cmd);

//Если есть договора для отчета, сформируем и получим путь до него
 if (rs.movenext) 

    ReportPath = ReportRunEx(true, FirstNotifyReport);
                       
    v_email_processor.m_set_msg_head("Первый отчет по договорам ИИС, по которым не предоставлены подтверждающие документы");
    v_email_processor.m_get_email_group(BROKERCONTRACT_EMAIL_GRP);
    v_email_processor.m_add_attach_to_list(ReportPath[0]);
    v_email_processor.m_save_to_submit_grp(BROKERCONTRACT_EMAIL_GRP, true);
    v_email_processor.m_submit_email_synch();
                       
 end;

 cmd = null; rs = null;v_email_processor = null;

 cmd = RSDCommand(sql);
 cmd.addParam("NotifyReport", RSDBP_IN, SecondNotifyReport);
 rs = RSDRecordSet(cmd);

//Если есть договора для отчета, сформируем и получим путь до него
 if (rs.movenext) 

    v_email_processor = c_email_proc_env();
    ReportPath = ReportRunEx(true, SecondNotifyReport);
                       
    v_email_processor.m_set_msg_head("Повторный отчет по договорам ИИС, по которым не предоставлены подтверждающие документы");
    v_email_processor.m_get_email_group(BROKERCONTRACT_EMAIL_GRP);
    v_email_processor.m_add_attach_to_list(ReportPath[0]);
    v_email_processor.m_save_to_submit_grp(BROKERCONTRACT_EMAIL_GRP, true);
    v_email_processor.m_submit_email_synch();
                       
 end;

 return v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
                       
onError(err)           
 v_result_scheduler =  c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
 return v_result_scheduler;
                       
end;

/**
@brief Создает записи в очередь обработки по CDI
@return заполненый класс c_ssRunResult

Процедура добавляет в таблицу dfuncobj_dbt записи 
по сервисам (CdiFindOrg CdiGetOrg CdiUpdateOrg CdiCreateOrg) 
в соотсветствии с наполнением таблицы uTableProcessEvent_dbt
*/
macro ws_check_job_cdi_in() :object
const CV_STAT_READY = 1, 
      CV_STAT_ERROR = 1005; // DEF-55464 если сервис был недоступен, код ошибки 1005. Для "справедливых" ошибок запрос не повторяется
const SERV_CDI_FIND_ORG   = 5053,
      SERV_CDI_GET_ORG    = 5054,
      SERV_CDI_UPDATE_ORG = 5055,
      SERV_CDI_CREATE_ORG = 5056;

var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;
var v_is_err = 0;

  Params  = Null;
  DataSet = Null;

  Query = " SELECT A.T_RECID, A.T_OBJECTTYPE, A.T_TYPE, A.T_OBJECTTYPE, B.T_NOTE, A.T_OBJECTID " +
          "   FROM uTableProcessEvent_dbt A, dllvalues_dbt B " +
          "  WHERE to_char(A.T_OBJECTTYPE) = B.T_CODE AND B.T_LIST = 5002 "+ 
          "    AND ( ( A.T_STATUS in (:p_Status1, :p_Status2) " + 
          "    AND A.T_OBJECTTYPE IN( " + SERV_CDI_GET_ORG    + ", " + 
                                          SERV_CDI_FIND_ORG   + ","+          //DEF-59172
                                          SERV_CDI_UPDATE_ORG + " ) )" +
          "    OR ( A.T_STATUS = :p_Status1 " + 
          "    AND A.T_OBJECTTYPE IN( " + SERV_CDI_FIND_ORG   + ", " +       //не логично, но пусть будет
                                          SERV_CDI_CREATE_ORG + " ) ) )";

  Params = makeArray( SQLParam( "p_Status1", CV_STAT_READY ),   //формируется
                      SQLParam( "p_Status2", CV_STAT_ERROR ));  //ошибка
  DataSet = execSQLselect( Query, Params );
  v_is_err = 0;

  while( DataSet.MoveNext ) //создание записи в очереди
    if( InsertSequenceJobUsrObj(  DataSet.value(0, Null, V_INTEGER),
                                  DataSet.value(1, Null, V_INTEGER),
                                  DataSet.value(2, Null, V_INTEGER),
                                  DataSet.value(3, Null, V_INTEGER),
                                  ParsePriority( DataSet.value(4, Null, V_STRING ) ) ) == 0 ); // вставить в очередь в соответствии с ObjectId в func_obj
    else
      v_is_err = 1;
    end;
  end;

  if(v_is_err == 0)
    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  Params  = Null;
  DataSet = Null;

  return ResultSheduler;

onError(err)

  Params = Null;
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;

end;

/**
@brief Создает событие CdiFindOrg по субъектам без CDI ID
@return заполненый класс c_ssRunResult

Процедура добавляет в таблицу utableprocessevent_dbt записи 
события CdiFindOrg по субъектам без CDI ID

*/
macro ws_check_cdi_ID()
  var ResultSheduler :object;
  var ProcessEventTblNew:object;

  var ActiveCDI = false;
  var v_error  = 0;
  var cmd, DataSet;

  GetRegistryValue( "РСХБ\\ИНТЕГРАЦИЯ\\ВЗАИМОДЕЙСТВИЕ С AC CDI\\АКТИВНО", V_BOOL, ActiveCDI, v_error );

  if (ActiveCDI)
  
    cmd = RSDCommand( " SELECT * " +
                      "   FROM dparty_dbt party " +
                      "  WHERE     (   party.T_Legalform = 1 " +
                      "             OR ( ((SELECT a.t_nameobject " +
                      "                    FROM dobjatcor_dbt  c " +
                      "                         INNER JOIN DOBJATTR_DBT a " +
                      "                             ON     a.t_groupid = c.t_groupid " +
                      "                                AND a.t_attrid = c.t_attrid " +
                      "                                AND a.t_objecttype = c.t_objecttype " +
                      "                   WHERE     a.t_objecttype = 3 " +
                      "                         AND a.t_groupid = 150 " +
                      "                         AND c.t_object = LPAD (party.t_partyid, 10, '0') " +
                      "                         AND c.t_validfromdate <= :p_date " +
                      "                         AND c.t_validtodate > :p_date) IN " +
                      "                     ('IE','PP')) OR (select prs.t_isemployer from dpersn_dbt prs where prs.t_personid  = party.t_partyid) = chr(88) )) " +
                      "        AND (SELECT COUNT (1) " +
                      "               FROM DOBJCODE_DBT code " +
                      "              WHERE code.T_CODEKIND = 110 /*PARTY_CODEKIND_CDI*/ " +
                      "                AND code.T_OBJECTID = party.t_partyid " +
                      "                AND code.T_OBJECTTYPE = 3   /*PARTY*/) = 0 ");
                    
    cmd.AddParam("p_date", RSDBP_IN, {curdate});
  
    DataSet = RSDRecordSet(cmd);
  
    var cmdFindPE, DSPE;
    var PartyId = -1;
    while (DataSet.moveNext())
      PartyId = DataSet.value("T_PARTYID");
     
      cmdFindPE = RSDCommand( " SELECT 1 " +
                              "   FROM utableprocessevent_dbt " +
                              "  WHERE t_objecttype = 5053/*CdiFindOrg*/ AND t_objectid = :p_PartyID ");

      cmdFindPE.AddParam("p_PartyID", RSDBP_IN, PartyId);
    
      DSPE = RSDRecordSet(cmdFindPE);
    
      if(DSPE.moveNext() == false)//если записи нет, то регистрируем событие CdiFindOrg 
        ProcessEventTblNew = c_usr_tbl_uTableProcessEvent;
        ProcessEventTblNew.New_Val_Obj.T_OBJECTTYPE = 5053;/*CdiFindOrg*/
        ProcessEventTblNew.New_Val_Obj.T_STATUS     = 1;
        ProcessEventTblNew.New_Val_Obj.T_OBJECTID   = PartyId;
        ProcessEventTblNew.New_Val_Obj.T_TYPE       = 1;
        ProcessEventTblNew.New_Val_Obj.T_TIMESTAMP  = dttm(date(), time());
        ProcessEventTblNew.New_Val_Obj.T_NOTE       = -1;

        if( not ProcessEventTblNew.Insert() ) 
          ProcessEventTblNew = Null;
          ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
          return ResultSheduler;
        else 
          ProcessEventTblNew = Null;
        end;
      end;
    end;
    DSPE = Null;
  end;
  
  if(v_error == 0)
    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  DataSet = Null;

  return ResultSheduler;

onError(err)
  DataSet = Null;

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;
end;


/**
@brief Вызывает хранимую процедуру, которая отправляет неторговые операции в СИ
@return clob json сообщение
*/

macro ws_TI_Non_Trade(pObjecttype, pObjectid, pParam)
  var v_sql,v_cmd, v_code = 0 , v_desc = "";
  var ResultSheduler :object;

  v_sql = "DECLARE" +
           " v_ErrorCode NUMBER; "+
           " v_ErrorDesc VARCHAR2 (2000);"+
           " p_out_json clob; "+
          " BEGIN"+
            " it_broker.non_trade (p_out_json, v_ErrorCode, v_ErrorDesc);"+
            ":p_code := v_ErrorCode; "+
            ":p_desc := v_ErrorDesc; "+
          " END;";

   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_code", RSDBP_OUT, V_INTEGER);
   v_cmd.addParam("p_desc", RSDBP_OUT, V_STRING);
   v_cmd.execute();

   v_code = v_cmd.value("p_code");
   v_desc = v_cmd.value("p_desc");

  if(v_code == 0)
    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  v_cmd.close(); v_cmd = null; v_sql = null;

  return ResultSheduler;

onError(err)

  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);

  return ResultSheduler;
end;

/**
@brief массовый вызов Импорт ИН из RuData
*/
macro ws_RuData_FaceValue(pObjecttype, pObjectid, pParam)
  var v_sql,v_cmd, v_code = 0;
  var ResultSheduler :object;

   v_sql = "declare  "
                + "  out_result_code   NUMBER; "               
                + "  out_result_text   VARCHAR2(4000); "  
                + "  begin" 
                + "  it_rudata.DateOptionsTableWrapper_Rq(p_result_code  => out_result_code  "
                + "                                      ,p_result_text  => out_result_text ) ;"
                + "   ?:= out_result_code; " 
                + " end;";  

         v_cmd = RSDCommand(v_sql);
         v_cmd.addParam("out_result_code",   RSDBP_OUT, V_INTEGER);
         v_cmd.Execute(); 

         v_code = v_cmd.value("out_result_code");

  if(v_code == 0)
    ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
    ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  v_cmd.close(); v_cmd = null; v_sql = null;

  return ResultSheduler;

onError(err)

   ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return ResultSheduler;
end;

/** 
@brief сбор логов, в случае если есть ошибки при ответных сообщениях из кафки. Отправляем на почту сгруппированные логи, группа рассылки NKDEndMonth
*/
macro ws_Notification_FailedRuData_FaceValue(pObjecttype, pObjectid, pParam)
  var v_sql,v_cmd, rs, msgText;
  var ResultSheduler :object;
  var v_email_processor :Object;
 
 
 v_sql  =  " WITH GROUP_EMAIL AS (SELECT  NVL(MAX(t_Element),0) as t_Element  from dllvalues_dbt where t_List = 5009 and T_NAME = 'NKDEndMonth'), "
         + "   LOG_DATA AS ( "
         + "   SELECT i.object_name,  "
         + "          RTRIM(XMLAGG(XMLELEMENT(e,i.msg || ';',CHR(10)).EXTRACT('//text()')).GetClobVal(),CHR(10)) as all_errors "
         + "  FROM itt_log i  "
         + "   WHERE i.object_name in ('IT_RUDATA.DATEOPTIONSTABLE_RESP','IT_RUDATA.DATEOPTIONSTABLE_RQ')  "
         + "      AND i.msg_type = 'ERROR'   "
         + "      AND TRUNC(i.create_sysdate) = TRUNC(SYSDATE)  "
         + "   GROUP BY i.object_name )"
         + "   SELECT g.t_Element AS t_group_email, dbms_lob.substr(l.all_errors, 4000) as t_all_errors, l.object_name  as t_object_name"
         + "   FROM group_email g CROSS JOIN log_data l  "
		 + "  WHERE all_errors IS NOT NULL; ";

 v_cmd = RSDCommand(v_sql);
 v_cmd = RSDCommand(v_sql);
 rs = RSDRecordSet(v_cmd);

 while (rs.moveNext())
    v_email_processor = c_email_proc_env();
    if(rs.value("t_object_name") == "IT_RUDATA.DATEOPTIONSTABLE_RESP") 
        msgText = "Ошибки при обработке ответных сообщений из топика ips.rudata-sinkable-nominal";
    elif(rs.value("t_object_name") == "IT_RUDATA.DATEOPTIONSTABLE_RQ")
        msgText = "Ошибки  при формировании сообщений в топик sofr.send-list-of-bonds-info";
    end;               
    v_email_processor.m_set_msg_head(msgText);
    v_email_processor.m_add_row_to_msg_text(rs.value("t_all_errors"));  
    v_email_processor.m_get_email_group(rs.value("t_group_email"));
    v_email_processor.m_save_to_submit_grp(rs.value("t_group_email"), true);
    v_email_processor.m_submit_email_synch();                     
 end;

 ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
 return ResultSheduler;

onError(err)
  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  return ResultSheduler;
end;


/**
@brief загрузка общей информации о ценных бумагах из rudata
*/
macro ws_check_job_securities() :object
var Query :string = "",
    Params :TArray,
    DataSet :RsdRecordset,
    ResultSheduler :object;
var v_is_err = 0, 
    v_recid = 0,
    v_priority = 0;

var C_FUNC_LOADBONDANDSEC           = 5200, 
    C_FUNC_LOAD_RATINGS             = 5201,
    C_FUNC_DELETEBADEMITENTSRATINGS = 5202,
    C_FUNC_LOADRATINGREPNATALL      = 5203,
    C_FUNC_LOADRATINGALLCOUNTRYS    = 5204;

  Params = Null;
  DataSet = Null;

  Query = " SELECT A.T_RECID, " +
          "  ( SELECT B.T_NOTE FROM dllvalues_dbt B " +
          "    WHERE B.T_LIST = 5002 " +
          "     AND B.T_CODE = TO_CHAR( A.T_OBJECTTYPE ) ) AS T_PRIORITY " + 
          " FROM uTableProcessIn_dbt A " +
          " WHERE A.T_STATUS = :p_Status " + 
          "  AND A.T_OBJECTTYPE = 1 "; 
  Params = makeArray( SQLParam( "p_Status", 2 ));  //формируется
  DataSet = execSQLselect( Query, Params );

  v_is_err = 0;
  while( DataSet.MoveNext ) //создание записи в очереди
    v_recid = DataSet.value(0, Null, V_INTEGER);
    v_priority = ParsePriority( DataSet.value(1, Null, V_STRING) );
   
    if( InsertSequenceJobUsrObj(v_recid,
                                C_FUNC_LOADBONDANDSEC,
                                1,
                                String(C_FUNC_LOADBONDANDSEC),
                                v_priority) == 0) 
    else
      v_is_err = 1;
    end;
   
    if( InsertSequenceJobUsrObj(v_recid,
                                C_FUNC_LOAD_RATINGS,
                                1,
                                String(C_FUNC_LOAD_RATINGS),
                                v_priority) == 0) 
    else
      v_is_err = 1;
    end;

    if( InsertSequenceJobUsrObj(v_recid,
                                C_FUNC_DELETEBADEMITENTSRATINGS,
                                1,
                                String(C_FUNC_DELETEBADEMITENTSRATINGS),
                                v_priority) == 0) 
    else
      v_is_err = 1;
    end;
    
    if( InsertSequenceJobUsrObj(v_recid,
                                C_FUNC_LOADRATINGREPNATALL,
                                1,
                                String(C_FUNC_LOADRATINGREPNATALL),
                                v_priority) == 0) 
    else
      v_is_err = 1;
    end;
    
    if( InsertSequenceJobUsrObj(v_recid,
                                C_FUNC_LOADRATINGALLCOUNTRYS,
                                1,
                                String(C_FUNC_LOADRATINGALLCOUNTRYS),
                                v_priority) == 0) 
    else
      v_is_err = 1;
    end;
    
  end;

  if(v_is_err == 0)
     ResultSheduler = c_ssRunResult(SS_RESPONSE_END);
  else
     ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  end;

  Params = Null;
  DataSet = Null;

  return ResultSheduler;

onError(err)
  Params = Null;
  DataSet = Null;
  ResultSheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  return ResultSheduler;
end;
                            
macro ws_check_job_client_report()

 var v_email_processor = c_email_proc_env();
 var v_result_scheduler;
 var ReportPath :Tarray;

 ReportPath = Client_ReportRunEx(true);

 v_email_processor.m_set_msg_head("Еженедельный отчет по регистрации договоров");
 v_email_processor.m_get_email_group(RepNumClients_EMAIL_GRP);
 v_email_processor.m_add_attach_to_list(ReportPath[0]);
 v_email_processor.m_save_to_submit_grp(RepNumClients_EMAIL_GRP, true);
 v_email_processor.m_submit_email_synch();  v_email_processor.m_save_to_submit_grp(RepNumClients_EMAIL_GRP, true);
  v_email_processor.m_submit_email_synch();

  return v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
                       
onError(err)           

  v_result_scheduler =  c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
  return v_result_scheduler;

end;

private macro UpdateProcessInStatus(objectType:integer, oldStatus:integer, newStatus:integer)
   var query =
           "update utableprocessin_dbt "
         + "   set t_status = :statusNew "
         + " where t_status = :statusOld "
         + "   and t_objecttype = :objectType ";
   var params = MakeSqlParamsArray(newStatus, oldStatus, objectType);
   execSQL(query, params);
end;

macro ws_SOFR_AssetLimits()
   var guid = CreateGUID();
   var logger = LoggerFactory().NewItLog("ws_SOFR_AssetLimits").WithPrefix("guid=" + guid).GetLogger();
   var startTime = Dttm(Date(), Time());
   var isSuccess:bool = false;
   var transaction = TransactionHelper();

   var depoLimitsJournal = DepoLimitsJournalLoader(logger);
   var moneyLimitsJournal = MoneyLimitsJournalLoader(logger);
   var futuresHoldingJournal = FuturesHoldingJournalLoader(logger);
   var ccpPriceRange = CcpPriceRangeLoader(logger);

   var assetLimitsObjectType = 13;
   var statusLoadedToBuffer = 2;
   var statusLoadedToSofr = 4;
   var statusError = 5;

   transaction.Begin();
   depoLimitsJournal.PrepareToLoad(guid);
   moneyLimitsJournal.PrepareToLoad(guid);
   futuresHoldingJournal.PrepareToLoad(guid);
   ccpPriceRange.PrepareToLoad(guid);
   transaction.Commit();

   transaction.Begin();
   isSuccess = depoLimitsJournal.Load(guid, startTime);
   if (isSuccess == false)
      RunError("Ошибка загрузки данных depoLimitsJournal");
   end;

   isSuccess = moneyLimitsJournal.Load(guid, startTime);
   if (isSuccess == false)
      RunError("Ошибка загрузки данных moneyLimitsJournal");
   end;

   isSuccess = futuresHoldingJournal.Load(guid, startTime);
   if (isSuccess == false)
      RunError("Ошибка загрузки данных futuresHoldingJournal");
   end;

   isSuccess = ccpPriceRange.Load(guid, startTime);
   if (isSuccess == false)
      RunError("Ошибка загрузки данных ccpPriceRange");
   end;
   transaction.Commit();

   logger.Info(string("Начало обработки: ", startTime,
                     "; загружено depoLimitsJournal: ", depoLimitsJournal.count,
                     "; загружено moneyLimitsJournal: ", moneyLimitsJournal.count,
                     "; загружено futuresHoldingJournal: ", futuresHoldingJournal.count,
                     "; загружено ccpPriceRange: ", ccpPriceRange.count
               )
   );

   depoLimitsJournal.ClearBuffer();
   moneyLimitsJournal.ClearBuffer();
   futuresHoldingJournal.ClearBuffer();
   ccpPriceRange.ClearBuffer();

   UpdateProcessInStatus(assetLimitsObjectType, statusLoadedToBuffer, statusLoadedToSofr);
   return c_ssRunResult(SS_RESPONSE_END);
OnError(err)
   transaction.RollBack();
   var errorText = GetFullErrMsg(err);
   logger.ErrorClob("error", errorText);
   UpdateProcessInStatus(assetLimitsObjectType, statusLoadedToBuffer, statusError);

   var mailProcessor = c_email_proc_env();
   mailProcessor.m_set_msg_head("Ошибка при загрузке данных из системы QUIK");
   mailProcessor.m_add_row_to_msg_text(string("Макрос: ws_check_job.mac\n", errorText));
   mailProcessor.m_save_to_submit_grp(BROKERCONTRACT_EMAIL_GRP, true);

   return c_ssRunResult(SS_RESPONSE_FATAL);
end;