/**
 @file CdiGetOrgXrefReq.mac
 @brief Интеграция с внешними системами. Запрос ссылок по Субъекту ЮЛ в CDI 

 Синхронный запрос через ИП-онлайн в АС CDI ссылок по субъекту юр.лицу (список идентификаторов разных систем).
 Синхронность обеспечивается настройкой Томката в app.properties - имя сервиса в соответствии со справочником типов данных
 должно быть указано в rshb.ip.sync.services

 # tag
 - functional_block: Клиенты_ЮЛ
 - code_type: API

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |27.07.2022 |Гераськина Т.В.|BIQ-9555                                        |Замена PersonGetXRefLEReq на сервис CdiGetOrgXrefReq

*/

import "secur_prc_msg_transform.mac";     /* Функционал преобразования сообщений */
import "RequestWS.mac";                   /* Функция передачи запроса в Web Sphere */
import "uws_exchng_log.mac";              /* Функционал логирования */
import func_lib;
import global_classes;

/**
@brief Основной класс запроса. Соответствует структре XML CdiGetOrgXrefReq (s_out_rs_secur_xml_schema.xsd)
@param[in] Incomedata код АБС (код 101 субъекта)

Класс автоматически не заполняется - создается пустым. Нужно вызвать uInitPrime отдельно.
*/
class c_CdiGetOrgXrefReq(Incomedata) 
   var ExtIdSourceSystem   ;  ///< Код системы источника      Справочник
   var ExtIdPartySourceId;    ///< ID клиента на источнике    Идентификатор
   var PartyId;               ///< ID клиента в CDI           Идентификатор
   
   macro uInitPrime(IncomeData)
      ExtIdSourceSystem = c_IntegrationDictionaryRecordXType();
      ExtIdSourceSystem.RecordCode = "CFT";
      
      ExtIdPartySourceId = c_IntegrationSymbolicIdentifierXType();
      ExtIdPartySourceId = Incomedata;
   end;
end;

/**
@brief Основной класс ответа. Соответствует структре XML CdiGetOrgXrefResp (s_in_rs_secur_xml_schema.xsd)
@param[in] Incomedata код АБС (код 101 субъекта)

Класс повторяет класс c_CdiGetOrgXrefReq + доп.параметр ExtIdSourceSystemName
*/
class (c_CdiGetOrgXrefReq) c_CdiGetOrgXrefResp 
   Initc_CdiGetOrgXrefReq;
      
   var  ExtIdSourceSystemName: string;
end;

/**
@brief Адаптер ответа - перекладывание сгенерированного Object RCW\TXRMessageImpl во внутренний объявленный класс
@param[in] Incomedata преобразованный в Object RCW\TXRMessageImpl XML-ответ  

При заполнении класса производятся проверки данных. А также исходный TXRMessageImpl не очень хорошо работает с массивами, 
поэтому перезаполнение внутреннего класса имеет смысл.
uInitPrime вызывается при создании объекта класса с тем же входным параметром, что и класс

*/
private class adp_CdiGetOrgXrefResp(IncomeData)
   var ExtIdList;    ///< Список кросс-ссылок
   var ErrorList;    ///< Блок ошибок обработки
  
   /** @brief Заполнение параметров в соответствии со схемой/спецификацией */
   private macro uInitPrime(IncomeData)
      var err_txt;
      var aux_buff, aux_buff2, ai;
      var temp_ExtId;
      var temp_Error;
            
      var nametag_up = "CdiGetOrgXrefResp";
      
      if(ValType(IncomeData) != V_UNDEF)
         aux_buff = uTryToGetPropS(IncomeData, "ExtIdList");
         if(ValType(aux_buff) == V_GENOBJ)
            ExtIdList = TArray;
            aux_buff = 0;
            nametag_up = nametag_up+".ExtIdList";
            while(IncomeData.ExtIdList.size > aux_buff)
               temp_ExtId = c_CdiGetOrgXrefResp;
               temp_ExtId.ExtIdSourceSystemName = getValueFromProperty(IncomeData.ExtIdList.value(aux_buff), "ExtIdSourceSystemName"  , nametag_up);
               temp_ExtId.ExtIdSourceSystem = getDictionaryFromProperty(IncomeData.ExtIdList.value(aux_buff), "ExtIdSourceSystem", nametag_up);
               temp_ExtId.ExtIdPartySourceId = getSymbolFromProperty(IncomeData.ExtIdList.value(aux_buff), "ExtIdPartySourceId", nametag_up);
               temp_ExtId.PartyId = getSymbolFromProperty(IncomeData.ExtIdList.value(aux_buff), "PartyId", nametag_up);
               
               ExtIdList.value(aux_buff) = temp_ExtId;
               aux_buff = aux_buff + 1;
               temp_ExtId = NULL;
            end;
         elif(ValType(aux_buff) == V_UNDEF) // при возникновении ошибки контейнер будет пустым
         else  // передали не класс
            err_txt = string(InErrNotObj, nametag_up+".ExtIdList");
            RunError(err_txt, c_err_obj(err_txt,ERR_CODE_TECH_ERROR));
         end;  

         aux_buff = uTryToGetPropS(IncomeData, "ErrorList");
         if(ValType(aux_buff) == V_GENOBJ)
            ErrorList = TArray;
            aux_buff = 0;
            nametag_up = nametag_up+".ErrorList";
            while(IncomeData.ErrorList.size > aux_buff)
               temp_Error = c_Error;
               temp_Error.ErrorCode = getValueFromProperty(IncomeData.ErrorList.value(aux_buff), "ErrorCode", nametag_up);
               temp_Error.ErrorDesc = getValueFromProperty(IncomeData.ErrorList.value(aux_buff), "ErrorDesc", nametag_up);
               
               ErrorList.value(aux_buff) = temp_Error;
               aux_buff = aux_buff + 1;
               temp_Error = NULL;
            end;
         elif(ValType(aux_buff) == V_UNDEF) // блок ошибок не обязательный
         else // передали не класс
            err_txt = string(InErrNotObj, nametag_up+".ErrorList");
            RunError(err_txt, c_err_obj(err_txt,ERR_CODE_TECH_ERROR));
         end;  
      end;
   end;
   
   /** @brief Поиск кросс-ссылки для переданной системы
       @param[in] _SystemId Наименование системы, как передает CDI ответе (используется CFT и SOFR)
       @return Значение кросс-ссылки (класс идентификатора переданной системы)

       Класс для возврата заполнен всегда. Если в ответе не было интересующей системы, то идентификатор будет = "-1"
    */
   macro GetSystemXref(_SystemId)
      var res = c_CdiGetOrgXrefResp;
      res.PartyId = c_IntegrationSymbolicIdentifierXType();
      res.PartyId.ObjectId = "-1"; 
      res.ExtIdPartySourceId = c_IntegrationSymbolicIdentifierXType();
      res.ExtIdPartySourceId.ObjectId = "-1";
      res.ExtIdSourceSystem = c_IntegrationDictionaryRecordXType();
      res.ExtIdSourceSystem.RecordCode = "-1";

      var ExtId;
      if (ValType(ExtIdList) == V_GENOBJ)
         for (ExtId, ExtIdList)
            if ( Valtype(ExtId.ExtIdSourceSystem) != V_UNDEF )
               if ( (Valtype(ExtId.ExtIdSourceSystem.RecordCode) != V_UNDEF) and (ExtId.ExtIdSourceSystem.RecordCode == _SystemId) )
                  res = ExtId;
               end;
            end;
         end;
      end;
      return res;
   end;

   uInitPrime(IncomeData);
end; 

/** 
@brief Основной класс работы с сервисом
@param[in] IncomeData Входящий параметр для c_CdiGetOrgXrefReq

Из-за особенностей преобразования XML по схеме, верхний объект обязательно должен содержать единственный параметр, название 
которого соответствует корневому тегу в схеме XSD. И этот объект определяется как класс, который заполняется по переданным параметрам
*/
private class c_CdiGetOrgXrefProcessor(IncomeData)
   var CdiGetOrgXrefReq; ///< Строго по названию корневого тега запроса 
   CdiGetOrgXrefReq = c_CdiGetOrgXrefReq;
   CdiGetOrgXrefReq.uInitPrime(IncomeData);
end; 

/** 
@brief Адаптер для вызова сервиса "Запрос ссылок по Субъекту ФЛ"
@param[in] ReqData Входящий параметр для c_CdiGetOrgXrefReq
@param[in] p_transparent_id Сквозной идентификатор входящего XML-запроса, который инициировал запрос ссылок (CreateClientLE)

@return Объект класса adp_CdiGetOrgXrefResp или NULL, если произошла ошибка
 */
macro run_CdiGetOrgXrefReq(ReqData, p_transparent_id)
   const QUEUE_OUT = 2; // исходящая очередь 
   const QUEUE_CDIGETORGXREF = 28; // Id вида запроса из спровочника типов данных

   var RespData = NULL;
   var err_txt = NULL;
   
   private var v_out_obj;
   private var RequestText;
   private var v_transformator;
   private var v_answer;
   private var v_answer_data;
   private var v_logger_obj;
   private var v_log_id;
   private var xml_str;
   private var v_xml_rpc_reqid = XmlRpcRequestId();  // запрос инициируем из-под текущего запроса по созданию/обновлению ЮЛ, поэтому генерируем ID

   if ( (ReqData == NULL) or (ValType(ReqData) == V_UNDEF) )
      return null;
   end;

   v_transformator = c_secur_msg_converter();

   // заполнение класса информацией 
   v_out_obj = c_CdiGetOrgXrefProcessor(ReqData);  // заполненный класс для запроса ссылок
   RequestText = v_transformator.m_secur_internal_resp(v_out_obj);   // преобразование класса в XML по схеме
   
   v_logger_obj = uws_exchng_logger(null, p_transparent_id, v_xml_rpc_reqid, "CdiGetOrgXrefReq", modulename(), null, RequestText); // логирование в usr_exchng_log
   v_log_id = v_logger_obj.get_log_id(); // ID внутренних логов потом передадим в исходящий запрос. Им все равно, а нам потом проще найти запрос в dqueue_log_dbt (t_jmscorrelationid)
  
//   err_txt = v_transformator.m_validate_out_xml(RequestText); // внутренняя проверка преобразованного XML по исходящей XSD
   if (err_txt == NULL)
      v_answer = SubmitRequestToWS( QUEUE_OUT,           // ИД очереди.
                                    "",                  // ИД сообщения.
                                    "",                  // Идентификатор Бэк Офиса. (не обрабатывается).
                                    true,                // Признак синхронной обработки. Если не указан, = False
                                    "SOFR",              // Подразделение системы-отпр
                                    QUEUE_CDIGETORGXREF, // ИД типа данных 
                                    RequestText,         // Бизнес данные в виде XML
                                    v_log_id,            // ID usr_exchng_log
                                    "CDI",               // Имя системы. Если не задано, берется из справочника типов данных
                                    30                   // Тайм-аут для синхронного запроса (время ожидания ответа)
                                    );
      if (v_answer.ResultCode == 0)    // ошибок вроде отсутствия синхронного ответа или проверки метки целостности не случилось
         xml_str = v_answer.responsetext;
         v_logger_obj.add_response(xml_str); 

         v_transformator = NULL;
         if (xml_str)   // ответ не пустой
            /* Преобразуем запрос в объектный вид - begin */
            v_transformator = c_secur_msg_converter();
            if(not v_transformator.m_decode_escaped_char(xml_str))   // очистка от служебных символов
               RunError(v_transformator.get_service_msg(), c_usr_err_obj(v_transformator.get_service_msg()));
            end;
            v_answer_data = v_transformator.m_secur_wol_internal_req(v_transformator.get_pure_msg()); // преобразование из XML в объект RCW\TXRMessageImpl
            /* Преобразуем запрос в объектный вид - end */

            if(ValType(v_answer_data) == V_UNDEF)
               err_txt = "Не удалось преобразовать XML в объект";
               RunError(err_txt, c_usr_err_obj(err_txt)); 
            end;
               
            RespData = adp_CdiGetOrgXrefResp(v_answer_data);  /* Преобразование объекта к виду, ожидаемому Системой */
         end;
      else 
         v_logger_obj.add_error_info(v_answer.ResultCode, v_answer.ResultText);  // зафиксируем ошибку в usr_exchng_log
      end;

   else
      v_logger_obj.add_error_info(UNIVERSAL_ERROR_CODE, err_txt);    // зафиксируем ошибку в usr_exchng_log
   end;

   return RespData; 

onError(err)
   return NULL;
end; 

/** 
@brief Точка входа
@param[in] ReqData Входящий параметр для c_CdiGetOrgXrefReq
@param[in] in_transparent_id Сквозной идентификатор входящего XML-запроса, который инициировал запрос ссылок (CreateClientLE)

@return Объект класса adp_CdiGetOrgXrefResp или NULL, если произошла ошибка
 */
macro CdiGetOrgXrefReq (ReqData, in_transparent_id) 
   return run_CdiGetOrgXrefReq(ReqData, in_transparent_id); 
end;

