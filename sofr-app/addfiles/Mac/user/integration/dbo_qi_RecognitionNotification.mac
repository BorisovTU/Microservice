/**
 @file dbo_qi_RecognitionNotification.mac
 @brief Функционал отправки уведомления о включении в реестр квалифицированных инвесторов
 
 Файл содержит функционал для формирования уведомления о включении субъекта в реестр
 квалифицированных инвесторов и его отправки по e-mail.
 
  # tag
 - functional_block:Отчетность_Клиент
 - code_type:API
 - code_type:Report
 - Квалификация
 - КИ
 - Квалифицированный инвестор
 
  # changeLog
 |date       |author       |tasks                                                     |note                                                        
 |-----------|-------------|----------------------------------------------------------|-------------------------------------------------------------
 |05.12.2023 |Топорков Д.В.|BIQ-16875 BOSS-194 BOSS-1282 BOSS-1421                    | Создание
 */
 
import rsd;
import "dbo_qi_func.mac"; // CSigner, CClient
import "dlcnst.inc";
import "logger.mac";
import "padej.mac";
import "dlutils.mac";
import "dlwreps.mac";

private const NOTIFICATION_NAME = "ФОД-1-5"; ///< Наименование бланка уведомления/имя шаблона
private const NOTIFICATION_DATA_TABLE_NUMBER = 2;
private const BROKERCONTR_IMGTYPE_RECOGNITIONNOTIFICATION = 101;

private const SHOWFILE  = false;
/// Константы содержимого для e-mail
private const QIRECOGNITION_EMAIL_SUBJECT = "Уведомление о присвоении статуса Квалифицированный инвестор";
private const QIRECOGNITION_EMAIL_BODY = 
  "Добрый день!\n" +
  "\n" +
  "В соответствии с условиями Регламента принятия решения о признании лица квалифицированным инвестором в АО \x22Россельхозбанк\x22 " +
  "направляем Вам Уведомление об успешном включении Вас в Реестр квалифицированных инвесторов АО \x22Россельхозбанк\x22.\n" +
  "\n";

var logger;

/**
@brief Класс с параметрами уведомлений по признанию КИ
*/
class (CQINotificationParams) CQIRecognitionParams()
  var recognitionDate: Date;      ///< Дата признания субъекта КИ
  var resultFileName: String;     ///< Имя файла сформированного уведомления
  var isSendEmail: Bool;
  var isPdfOutput: Bool;
  var isDocOutput: Bool;
  
  /**
  @brief Процедура начальной инициализации класса
  */
  private macro Init()
    recognitionDate = Date();
    resultFileName = "";
    isSendEmail = false;
    isPdfOutput = false;
    isDocOutput = false;
  end;
  //--- конструктор ---
  InitCQINotificationParams();
  Init();
end; // CQIRecognitionParams

/**
@brief Функция выбора значения в зависимости от условия
@param[in] condition Условие для выбора (true/false !0/0)
@param[in] valueTrue Значение которое вернет функция при condition = true (тип Variant)
@param[in] valueFalse Значение которое вернет функция при condition = false (тип Variant)
@return valueTrue при condition=true, valueFalse при condition=false (тип Variant)
*/
private macro IIF(condition, resultOnTrue, resultOnFalse)
   if (condition)
      return resultOnTrue;
   else
      return resultOnFalse;
   end;
end;

/**
@brief Функция записи сообщения в логгер
@param[in] msg - Сообщение
@param[in] logType - Тип сообщения (если не указано, то будет интерпритировано как LOGTYPE_INFO
@return Переданное значение msg
*/
private macro LogMessage(msg, logType)
  logger.log(msg, logType);
  return msg;
end;

/**
@brief Процедура записи в логгер параметров Уведомления о признании
@param[in] recognitionParams Параметры уведомления о признании
*/
private macro LogQIRecognitionParams(recognitionParams: CQIRecognitionParams)
  LogMessage("Формирование уведомления для клиента " + recognitionParams.client.shortName + ", договор №" + recognitionParams.client.contractNumber);
  LogMessage("Дата : " + recognitionParams.recognitionDate);
  LogMessage("Подписант : " + recognitionParams.signer.oper + ", " + recognitionParams.signer.name + ", " + recognitionParams.signer.post);
end;

/**
@brief Функция проверки параметров Уведомления о признании
@param[in] recognitionParams Параметры уведомления о признании
@param[out] error Текст ошибки
@return true В случае корректных параметров
@return false Параметры некорректны (см. error)
*/
private macro CheckQIRecognitionConditions(recognitionParams: CQIRecognitionParams, storage: CStorageInfo, error: @String): Bool
  error = "";
  /// Общие проверки
  if (StrLen(error) == 0)
    if ((ValType(recognitionParams.dlContrID) == V_UNDEF) or (recognitionParams.dlContrID <= 0))
      error = "Не задан договор обслуживания";
    elif ((ValType(recognitionParams.client) == V_UNDEF) or (ValType(recognitionParams.client.emails) == V_UNDEF) or (recognitionParams.client.emails.size == 0))
      error = "У клиента отсутствует электронная почта для рассылки";
    elif ((ValType(recognitionParams.recognitionDate) == V_UNDEF) or (recognitionParams.recognitionDate == date(0,0,0)))
      error = "Не задана дата признания";
    elif ((ValType(recognitionParams.signer) == V_UNDEF) or (recognitionParams.signer.oper <= 0))
      error = "Не заданы системные настройки процесса: Подписант по умолчанию";
    elif (StrLen(storage.GetDirectory(RESULTTAG).path) <= 1)
      error = "Не заданы системные настройки процесса: Директория";
    end;
  end;
  /// Проверки подписанта
  if (StrLen(error) == 0)
    if ((ValType(recognitionParams.signer.post) != V_STRING) or (StrLen(recognitionParams.signer.post) == 0))
      error = "Не заполнена должность подписанта по умолчанию";
    elif ((ValType(recognitionParams.signer.signStampImageID) != V_INTEGER) or (recognitionParams.signer.signStampImageID == 0))
      error = "Отсутствует изображение подписи подписанта по умолчанию";
    end;
  end;
  /// Проверка наличия договора в реестре квалифицированных инвесторов
  if (StrLen(error) == 0)
    var sql;

    if(not GetRegValueSwitchQI()) //NEW PARAM
      sql = "SELECT * FROM dScQinv_dbt WHERE t_sfContrID = (SELECT t_sfContrID FROM dDlContr_dbt WHERE t_dlContrID = " + recognitionParams.dlContrID + ") ORDER BY t_regDate DESC";
    else
      sql = " SELECT * " +
              "  FROM dScQinv_dbt   " +
              " WHERE t_partyid  = (SELECT sf.t_partyid   " +
              "                      FROM dDlContr_dbt d JOIN dsfcontr_dbt sf ON d.t_sfcontrid = sf.t_id   " +
              "                      WHERE t_dlContrID = " + recognitionParams.dlContrID + ") " +
              " ORDER BY t_regDate DESC ";
    end;

    var qInvRec = TRsbDataSet(sql);

    if(not GetRegValueSwitchQI()) //NEW PARAM

      /// Если записи нет, то можно дальше работать, иначе проверка
      if (qInvRec.MoveNext()) // интересует только первая запись (с максимальной t_regDate)
        if (qInvRec.state == 0)
          error = "Договор исключен из реестра КИ";
        elif (qInvRec.state != 1)
          error = "Неизвестный статус договора в реестре квалифицированных инвесторов";
        end;
      else
        error = "Договор отсутствует в реестре квалифицированных инвесторов";
      end;
    else
      /// Если записи нет, то можно дальше работать, иначе проверка
      if (qInvRec.MoveNext()) // интересует только первая запись (с максимальной t_regDate)
        if (qInvRec.state == 0)
          error = "Клиент исключен из реестра КИ";
        elif (qInvRec.state != 1)
          error = "Неизвестный статус клиента в реестре квалифицированных инвесторов";
        end;
      else
        error = "Клиент отсутствует в реестре квалифицированных инвесторов";
      end;
    end;
  end;

  if (StrLen(error) > 0)
    return false;
  end;

  return true;
end;

/**
@brief Функция получения объекта класса CStorageInfo (данные об используемых директориях и файлах в них)
@param[in] recognitionParams Параметры уведомления о признании
@return Настроенный объекта класса CStorageInfo

# Предполагается следующее использование директорий:
- WORKTAG   Директория WorkFile сервера приложений (установлена в конструкторе CStorageInfo)
- RESULTTAG Директория для итогового хранения файлов согласно настроек банка (либо значение установленное в конструкторе CStorageInfo)
- TXTTAG    Директория TxtFile сервера приложений (установлена в конструкторе CStorageInfo)
# Предполагается следующее использование файлов:
- WORKTAG/WORKTAG     Временный файл данных отчета для заполнения шаблона
- WORKTAG/SIGNTAG     Временный файл изображение подписи и печати для вставки в Уведомление
- RESULTTAG/RESULTTAG Файл уведомления в формате DOC (формируется в зависимости от параметров)
- RESULTTAG/PDFTAG    Файл уведомления в формате PDF (формируется в зависимости от параметров)
- TXTTAG/LOGTAG       Файл для записи лога (возможно удаляется в случае отсутствия ошибок)
*/
private macro GetQIStorageInfo(recognitionParams: CQIRecognitionParams): CStorageInfo
  var fileTag: String = "Уведомление_квал_инвест_";
  var cleanClientName: String = CleanStringForFilename(recognitionParams.client.shortName);
  if ((ValType(recognitionParams) != V_UNDEF) and (ValType(recognitionParams.client) != V_UNDEF) and (ValType(recognitionParams.client.shortName) == V_STRING))
    fileTag = fileTag + cleanClientName;
  end;
  
  var storageInfo: CStorageInfo = CStorageInfo(fileTag);
  var errCode: Integer;
  var targetDirectory: String;
    
   /// Если задана настройка директории сохранения файлов, то установим ее в RESULTTAG
   //РСХБ\БРОКЕРСКОЕ ОБСЛУЖИВАНИЕ\КВАЛИФИКАЦИЯ\ДИРЕКТОРИЯ
   GetRegistryValue(QI_REGISTRY_DIRECTORY, V_STRING, targetDirectory, errCode);
   if ((errCode == 0) and (ValType(targetDirectory) == V_STRING))
     targetDirectory = Trim(targetDirectory);
     if (StrLen(targetDirectory) > 0)
       storageInfo.AddDirectory(RESULTTAG, NormalizePath(targetDirectory, false), false);
     else
       LogMessage("Не задана настройка " + QI_REGISTRY_DIRECTORY);
       storageInfo.AddDirectory(RESULTTAG, "", false);
     end;
   end;
  
  /// Переопределим имена файлов с меткой RESULTTAG в директории RESULTTAG
  var resultFileName: String = "Уведомление о признании лица квалифицированным инвестором " + StrSubst(cleanClientName, "_", " ");

  SplitFile(GetUnexistedFileName(toANSI(storageInfo.GetDirectory(RESULTTAG).Path + resultFileName + ".pdf")), resultFileName); // т.к. целевой pdf, то ориентируемся на него
  storageInfo.AddFile(RESULTTAG, RESULTTAG, resultFileName, "docx", false);
  storageInfo.AddFile(RESULTTAG, PDFTAG, resultFileName, "pdf", false);
  /// Добавим информацию для файла логгирования
  storageInfo.AddFile(TXTTAG, LOGTAG, "QiRecognition_" + GetDateTimeMark(Date(), Time()) + "_" + String(Random(999)), "txt", false);
  return storageInfo;
end;


/**
@brief Процедура создания файла(ов) уведомления 
@param[in] rejectionParams Параметры уведомления об признании
@param[in] storage Данные об используемых директориях/файлах
@param[out] error Текст ошибки
@return True в случае успешного создания файла(ов) уведомления, false в случае ошибки
*/
private macro CreateQIRecognitionNotification(recognitionParams: CQIRecognitionParams, storage: CStorageInfo, error: @String): Bool
  var textReader: CTextReader;
  var textLines: TArray;
  var offset: Integer = 0;
  var deltaRowsPrinted = 0;
  var i: Integer = 0;
  var RealFileName = ""; 
  var fTxt, fNameTxtMess = "";
  var tplName = NOTIFICATION_NAME + ".dotx"; //FindTemplate(NOTIFICATION_NAME + ".dotx");
  var pdfName = Null;
  fNameTxtMess = storage.FilePath(TXTTAG, TXTTAG);
        
  fTxt = TStreamDoc(fNameTxtMess, "C", "rsoem ", 1/*unix*/);
  if ( ValType(fTxt) != V_UNDEF )
  else
    error = "Текстовый файл вывода не открыт " + fNameTxtMess;
	return false;
  end;

  fTxt.WriteLine(tplName);     //Шаблон dotx
  fTxt.WriteLine(SubStr(tplName, 1, index(tplName, ".dot")-1) + "_" + String(recognitionParams.client.partyID));   //Файл docx
  //recognitionParams.DLcontrID
 
  fTxt.WriteLine("~Client");
  fTxt.WriteLine(IIF(recognitionParams.client.legalForm == PTLEGF_PERSN, recognitionParams.client.fullName, recognitionParams.client.shortName));

  if (recognitionParams.client.legalForm == PTLEGF_PERSN)
    textReader = CTextReader(Падеж(recognitionParams.client.fullName, 2));
  else
    textReader = CTextReader(recognitionParams.client.fullName);
  end;
  
  fTxt.WriteLine("~ClientFull1");
  fTxt.WriteLine(textReader.ReadLine(76));

//В таблицу пришлось вставить пустые строки, которые обрамляют строки с подчеркиванием
//После печати в переменные, необходимо эти пустые строки удалять
  i = 0;
  if (NOT textReader.HasNext() )
    fTxt.WriteLine("~DeleteRows");
    fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
    fTxt.WriteLine("%");
    fTxt.WriteLine(String(3+deltaRowsPrinted)); //номер первой удаляемой строки
    fTxt.WriteLine(String(5+deltaRowsPrinted)); //номер последней удаляемой строки
    deltaRowsPrinted = deltaRowsPrinted - 3;
  else
    While (textReader.HasNext())
      if (i == 0)
         fTxt.WriteLine("~ClientFull1_1");
         fTxt.WriteLine(textReader.ReadLine(83));
         i = i + 1;
         //удаляем пустые строки
         fTxt.WriteLine("~DeleteRows");
         fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
         fTxt.WriteLine("%");
         fTxt.WriteLine(String(3+deltaRowsPrinted)); //номер первой удаляемой строки
         fTxt.WriteLine(String(4+deltaRowsPrinted)); //номер последней удаляемой строки
         deltaRowsPrinted = deltaRowsPrinted - 2;
       else
         fTxt.WriteLine("~MultipleRow");  /*добавляем строку таблицы*/
         fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER));/*идентификатор таблицы*/      
         fTxt.WriteLine(String(1));                              /*необходимое количество строк*/
         fTxt.WriteLine("");                                     /*закладка для таблицы*/
         fTxt.WriteLine(String(5+deltaRowsPrinted));             /*номер ряда, который необходимо размножить*/
 
         fTxt.WriteLine("~ClientFull1_"+String(1+i)); //1 начальное значение
         fTxt.WriteLine(textReader.ReadLine(83)); /*!!!*/
          
         i = i + 1;
         deltaRowsPrinted = deltaRowsPrinted + 1;
      end;
    end;
  end; 
//Удаляем пустую строку над строкой с линией ФИО
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(6+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(6+deltaRowsPrinted)); //номер первой последней строки
  deltaRowsPrinted = deltaRowsPrinted - 1;


  if (recognitionParams.client.legalForm == PTLEGF_PERSN)
    textReader = CTextReader(Падеж(recognitionParams.client.fullName, 6));
  else
    textReader = CTextReader(recognitionParams.client.fullName);
  end;

  fTxt.WriteLine("~ClientFull2");
  fTxt.WriteLine(textReader.ReadLine(65));
  i = 0;
  if (NOT textReader.HasNext() )
    fTxt.WriteLine("~DeleteRows");
    fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
    fTxt.WriteLine("%");
    fTxt.WriteLine(String(15+deltaRowsPrinted)); //номер первой удаляемой строки
    fTxt.WriteLine(String(17+deltaRowsPrinted)); //номер последней удаляемой строки
    deltaRowsPrinted = deltaRowsPrinted - 3;
  else
    While (textReader.HasNext())
      if (i == 0)
         fTxt.WriteLine("~ClientFull2_1");
         fTxt.WriteLine(textReader.ReadLine(83));
         i = i + 1;
         
         //удаляем пустые строки
         fTxt.WriteLine("~DeleteRows");
         fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
         fTxt.WriteLine("%");
         fTxt.WriteLine(String(15+deltaRowsPrinted)); //номер первой удаляемой строки
         fTxt.WriteLine(String(16+deltaRowsPrinted)); //номер последней удаляемой строки
         deltaRowsPrinted = deltaRowsPrinted - 2;
      else
         fTxt.WriteLine("~MultipleRow");  /*добавляем строку таблицы*/
         fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER));/*идентификатор таблицы*/      
         fTxt.WriteLine(String(1));                              /*необходимое количество строк*/
         fTxt.WriteLine("");                                     /*закладка для таблицы*/
         fTxt.WriteLine(String(17+deltaRowsPrinted));            /*номер ряда, который необходимо размножить*/
         
         fTxt.WriteLine("~ClientFull2_"+String(1+i)); //1 начальное значение
         fTxt.WriteLine(textReader.ReadLine(83)); /*!!!*/
          
         i = i + 1;
         deltaRowsPrinted = deltaRowsPrinted + 1;
      end;
    end;
  end; 
//Удаляем пустую строку под линией ФИО
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(18+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(18+deltaRowsPrinted)); //номер первой последней строки
  deltaRowsPrinted = deltaRowsPrinted - 1;

//Удаляем пустую строку под линией даты
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(NOTIFICATION_DATA_TABLE_NUMBER)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(22+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(22+deltaRowsPrinted)); //номер первой последней строки
  deltaRowsPrinted = deltaRowsPrinted - 1;

  fTxt.WriteLine("~RecognitionDate");
  fTxt.WriteLine(String(recognitionParams.recognitionDate:f));

  fTxt.WriteLine("~Post");
  fTxt.WriteLine(recognitionParams.signer.post);

  fTxt.WriteLine("~InsertImage");
  fTxt.WriteLine("Sign#"+storage.FilePath(WORKTAG, SIGNTAG)+"#154#142"); //Имя_закладки#Полный путь к файлу с картинкой#258#238 //60%
  //PlaceInlineShapeBackward(processor.ReplaceBookmarkByImage("Sign", storage.FilePath(WORKTAG, SIGNTAG)));
  
  fTxt.WriteLine("~SignerName");
  fTxt.WriteLine(recognitionParams.signer.name);

 
  //эмуляция метода close
  fTxt = TStreamDoc(fNameTxtMess, "R", "rsoem ", 1/*unix*/);
  
  recognitionParams.resultFileName = "";
  
  if (recognitionParams.isPdfOutput)
//     pdfName = storage.FilePath(RESULTTAG, PDFTAG);
     pdfName = SubStr(fNameTxtMess, 1, index(fNameTxtMess, ".")-1) + ".pdf";
  end;

  //Вызов функции из dlwreps.mac 
  DLWREPS_PrintReportFromTagFile( fNameTxtMess, @RealFileName, Null/*CloseDoc*/, Null/*SaveDocTwice*/ , Null/*UsePoiMode*/, pdfName/*FileNamePDF*/, null  /*, FileNameHTML*/,SHOWFILE/*ShowDoc*/);
  recognitionParams.resultFileName = RealFileName;

  if (not CopyFile(pdfName, storage.FilePath(RESULTTAG, PDFTAG), True /*Индикатор*/, "Копируем файл для отправки"))
    error = "Не удалось скопировать файл " + pdfName + " в директорию " + string(storage.FilePath(RESULTTAG, PDFTAG));
  else
     //MsgBox("Успешно скопирован файл из "+pdfName+" в директорию "+ string(storage.FilePath(RESULTTAG, PDFTAG));
  end;

  if (not CopyFile(RealFileName, storage.FilePath(RESULTTAG, RESULTTAG), True /*Индикатор*/, "Копируем файл для отправки"))
    error = "Не удалось скопировать файл " + RealFileName + " в директорию " + string(storage.FilePath(RESULTTAG, RESULTTAG));
  else
     //MsgBox("Успешно скопирован файл из "+pdfName+" в директорию "+ string(storage.FilePath(RESULTTAG, PDFTAG));
  end;
  
  
  recognitionParams.resultFileName = storage.FilePath(RESULTTAG, RESULTTAG) + 
                                     IIF(StrLen(recognitionParams.resultFileName) > 0, "; ", "") + 
                                     storage.FilePath(RESULTTAG, PDFTAG);
  DelFile(fNameTxtMess);
  DelFile(pdfName);
  
  return StrLen(error) == 0;
  
onError(err)
    
  error = LogMessage("Ошибка выполнения:|" + err.Module + " строка " + err.Line + "|" + err.message, LOGTYPE_ERROR);
  
  return false;
end;

/**
@brief Функция создания сообщения для ДБО с прикрепленным файлом уведомления
@param[in] recognitionParams Параметры уведомления о признании
@param[in] storage Данные об используемых директориях/файлах
@param[out] error Текст ошибки
@return Индекс записи в таблице dDlContrMsg_dbt
@return null В случае ошибки записи

Предполагается, что файл уведомления RESULTTAG/PDFTAG уже создан
*/
private macro CreateQIRecognitionDBOMessage(recognitionParams: CQIRecognitionParams, storage: CStorageInfo, error: @String): Integer
  var dlContrMsg = Tbfile("dlcontrmsg.dbt", "W", 0);
  
  dlContrMsg.clear();
  dlContrMsg.rec.DlContrID = recognitionParams.dlContrID;
  dlContrMsg.rec.Kind = RECOGNITION_QI;
  dlContrMsg.rec.CreateDate = Date();
  dlContrMsg.rec.CreateTime = Time();
  dlContrMsg.rec.SendDate = Date(0,0,0);
  dlContrMsg.rec.SendTime = Time(0,0,0);
  dlContrMsg.rec.IsOnlineSendMes = UNSET_CHAR;
  dlContrMsg.rec.MarketID = -1;
  dlContrMsg.rec.SendMesState = 0;
  if(not dlContrMsg.insert())
    return 0;
  end;
  
  LogMessage("Создано сообщение к ДБО с ID = " + dlContrMsg.rec.ID);
  
  if((not LoadImageObj(storage.FilePath(RESULTTAG, PDFTAG), OBJTYPE_BSCMSG_DL, UniID(dlContrMsg, OBJTYPE_BSCMSG_DL), 1)) and (ValType(error) == V_STRING))
    error = IIF(StrLen(error) > 0, error + "|", "") + "К записи о сообщении ДБО не удалось прикрепить файл сообщения";
  end;
  
  return dlContrMsg.rec.ID;
end;

/**
@brief Процедура отправки e-mail
@param[in] recognitionParams Параметры уведомления о признании
@param[in] storage Данные об используемых директориях/файлах
@param[out] error Текст ошибки

Предполагается, что файл уведомления RESULTTAG/PDFTAG уже создан
*/
private macro SendQIRecognitionEmail(recognitionParams: CQIRecognitionParams, storage: CStorageInfo, error: @String)
  var emailProcessor = c_email_proc_env();
  var isLegalPerson: Bool = recognitionParams.client.legalForm == PTLEGF_INST;
  var registryPath: String = GetHiddenRecipientsRegistryPath(isLegalPerson);
  var hiddenRecipients: TArray = GetHiddenRecipients(registryPath);

  if (hiddenRecipients.size == 0)
    error = "Не заданы системные настройки процесса: Направлять скрытую копию по " + IIF(isLegalPerson, "ЮЛ", "ФЛ");
    return;
  end;
  
  /// Формируем письмо
  RunProcByParamArray(R2M(emailProcessor, "m_add_email_to_list"), recognitionParams.client.emails); ///< Список получателей
  RunProcByParamArray(R2M(emailProcessor, "m_add_email_to_bcc_list"), hiddenRecipients);            ///< Список получателей скрытой копии
  emailProcessor.m_set_msg_head(QIRECOGNITION_EMAIL_SUBJECT);                                       ///< Тема письма
  emailProcessor.m_add_row_to_msg_text(QIRECOGNITION_EMAIL_BODY);                                   ///< Текст 
  emailProcessor.m_add_attach_to_list(storage.FilePath(RESULTTAG, PDFTAG));                         ///< Прикрепленный файл

  /// Сохраняем для отправки плановой процедурой 
  emailProcessor.m_save_to_submit_synch();
  /// Отправляем
  emailProcessor.m_submit_email_synch();

  if(emailProcessor.m_get_error_status())
    if (ValType(error) == V_STRING)
      error = IIF(StrLen(error) > 0, error + "|", "") + "Сообщение сформировано, но не отправлено: " + emailProcessor.get_service_msg();
    end;
  else
    LogMessage("Письмо отправлено");
  end;
end;

/**
@brief Процедура отправки данных в IPS Фабрику документов для формирования уведомления
@param[in] recognitionParams Параметры уведомления о признании
*/
private macro QIRecognitionNotifyIPS(recognitionParams: CQIRecognitionParams)
  var error: String = ""; // Возможную ошибку пока игнорируем
  
  if ((recognitionParams.client.legalForm == PTLEGF_INST) or IsIndividualEmployer(recognitionParams.client.partyID))
    var errorCode = QINotifyIPS(recognitionParams.client.partyId, RECOGNITION_QI, recognitionParams.recognitionDate, recognitionParams.signer.oper, null, ПадежО(recognitionParams.client.fullName, 6), @error);
    
    if (errorCode != 0)
      LogMessage("Ошибка формирования уведомления через Фабрику документов (IPS): " + error, LOGTYPE_ERROR);
    end;
  end;
end;

/**
@brief Функция формирования и отправки уведомления о признании квалифицированного инвестора
@param[in] recognitionParams Параметры уведомления о признании
@return V_STRING Текст ошибки
*/
macro QIRecognitionNotification(recognitionParams: CQIRecognitionParams): String
  logger = CTxtLogger();
  
  var storage: CStorageInfo = GetQIStorageInfo(recognitionParams);
  var error: String = "";

  logger.InitFile(storage.FilePath(TXTTAG, LOGTAG));
  LogQIRecognitionParams(recognitionParams);
  recognitionParams.resultFileName = "";
  
  /// Проверка параметров операции
  if (not CheckQIRecognitionConditions(recognitionParams, storage, @error))
    return LogMessage("Ошибка проверки параметров:|" + error, LOGTYPE_ERROR);
  end;
  
  /// Отправка данных для создания уведомления через Фабрику документов (IPS)
  QIRecognitionNotifyIPS(recognitionParams);
  
  if (ImageUpload(storage, recognitionParams.signer.signStampImageID, @error))
    LogMessage("Создан файл подписи " + storage.FilePath(WORKTAG, SIGNTAG));
  else
    return LogMessage("Ошибка при загрузке файла подписи (id = " + recognitionParams.signer.signStampImageID + ") " + error, LOGTYPE_ERROR);
  end;

  /// формирование файла(ов) уведомления
  if (not CreateQIRecognitionNotification(recognitionParams, storage, @error))
    return LogMessage("Ошибка формирования файла(ов) уведомления " + error);
  end;
  LogMessage("Сформированы файлы: " + recognitionParams.resultFileName);
 
 /*Скопировать PDF в директорию отправки*/ 
 
 /// Прикрепление уведомления к ДБО (Alt + F2)
  if (not LoadImageObj(storage.FilePath(RESULTTAG, PDFTAG), OBJTYPE_BROKERCONTR_DL, String(recognitionParams.dlContrID:o:34), BROKERCONTR_IMGTYPE_RECOGNITIONNOTIFICATION))
      /*D:\RSHB_SOFR_WRK\Export\Уведомление о признании лица квалифицированным инвестором Худян РГ.pdf, 207, 101*/
    return LogMessage("Ошибка при прикреплении файла Уведомления к ДБО");
  end;
  LogMessage("Файл уведомления прикреплен к ДБО");
  
  /// Создание сообщения dDlContrMsg
  var dlContrMsgID: Integer = CreateQIRecognitionDBOMessage(recognitionParams, storage, @error);
  
  /// Отправка e-mail
  if (recognitionParams.isSendEmail)
    var errLength = StrLen(error);
  
    SendQIRecognitionEmail(recognitionParams, storage, @error);
    if ((errLength == StrLen(error)) and (dlContrMsgID > 0)) // При отправке не добавилось ошибок и сообщение на договоре было сохранено
      // Обновим дату отправки сообщения
      ExecSql("UPDATE dDlContrMsg_dbt SET t_sendDate = ?, t_sendTime = ? WHERE t_ID = ? ", makeArray(SQLParam("", Date()), SQLParam("", Time()), SQLParam("", dlContrMsgID)));
    end;
  end;
  
  if (StrLen(error) > 0)
    LogMessage(error, LOGTYPE_ERROR);
  end;
  
  logger.close();
  /// Если нет ошибок, то отметим файл лога на удаление
  if ((logger.GetMessagesCount(LOGTYPE_WARNING) == 0) and (logger.GetMessagesCount(LOGTYPE_ERROR) == 0))
    storage.GetFile(TXTTAG, LOGTAG).IsTemporary = true;
  end;
  
  return error;
  
onError (err)
  error = LogMessage("Ошибка выполнения:|" + err.Module + " строка " + err.Line + "|" + err.message, LOGTYPE_ERROR);
  LogMessage(GetFullErrorMessage(err), LOGTYPE_ERROR);
  logger.close();
  
  return error;
end;