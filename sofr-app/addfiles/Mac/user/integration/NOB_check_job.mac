
/* BIQ-7335 Гераськина Т.В. Передача данных о НОБ из СОФР в Депозитарий */
/* вынесена единственная функция - непосредственное выполнение выгрузки НОБ, чтобы избежать циклического вызова макросов*/

import "PrepareNOBFromSOFRToDepo.mac";
import "usr_table_int.mac";
import "usequence_job.mac";

private const C_SOFR_NOB_IN = 20;
private const C_SOFR_NOB_OUT = 21;
private const C_SOFR_NOB_IN_UNDO = 22;
private const C_EVENT_STAT_NEW = 1;
private const C_EVENT_STAT_READY = 2;
private const C_EVENT_STAT_RUNNING = 3;
private const C_PROC_OUT_ARCH = 4;
private const C_PROC_OUT_ERR = 5;

/*---------------------------------------------------------*/
/* На случай отсутствия макроса simple_service.mac - begin */
private var SS_RESPONSE_REPEAT_OK = 0; /* Продолжение попытки выполнить исполняемую процедуру (функцию) после успешного исполнения */
private var SS_RESPONSE_REPEAT_ERROR = 1; /* Продолжение попытки выполнить исполняемую процедуру (функцию) после ошибки */
private var SS_RESPONSE_NEXT = 2; /* Успешное завершение работы метода - переход к следующему методу */
private var SS_RESPONSE_END = 3; /* Успешное завершение всего сервиса */
private var SS_RESPONSE_FATAL = 4; /* Ошибка исполнения, обработка всей цепочки прерывается */
private var SS_RESPONSE_PROXY = 5; /* Запрос отправлен во внешнюю систему через Proxy, требуется перриодический анализ изменения состояния */


private class c_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText)
   var ProcessState;
   var ErrorNumber;
   var ErrorText;

   private macro init_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText)
      if(ValType(p_ProcessState) != V_UNDEF)
         ProcessState = p_ProcessState;
      end;
      if(ValType(p_ErrorNumber) != V_UNDEF)
         ErrorNumber = p_ErrorNumber;
      end;
      if(ValType(p_ErrorText) != V_UNDEF)
         ErrorText = p_ErrorText;
      end;
   end;

   init_ssRunResult(p_ProcessState, p_ErrorNumber, p_ErrorText);
end;

/* На случай отсутствия макроса simple_service.mac - end   */
/*---------------------------------------------------------*/


private class (c_usr_tbl_base) c_usr_tbl_uTableProcessEvent()
   private class gen_uTableProcessEvent()
      var T_RECID :integer,
          T_TIMESTAMP :datetime,
          T_OBJECTTYPE :integer,
          T_OBJECTID :integer,
          T_TYPE :integer,
          T_STATUS :integer,
          T_NOTE :string,
          T_MESSAGEID :integer,
          T_RESULTCODE :string,
          T_RESULTTEXT :string;
   end;

   private macro init_table_obj()
      new_val_obj = gen_uTableProcessEvent();
      where_val_obj = gen_uTableProcessEvent();
   end;

   Initc_usr_tbl_base("uTableProcessEvent_dbt");

   init_table_obj();
end;

private class (c_usr_tbl_base) c_usr_tbl_utableprocessout()
   private class gen_utableprocessout()
      var T_RECID :integer,
          T_OBJECTTYPE :integer,
          T_STATUS :integer,
          T_TIMESTAMP :datetime,
          T_RESULTCODE :string,
          T_RESULTTEXT :string;
   end;

   private macro init_table_obj()
      new_val_obj = gen_utableprocessout();
      where_val_obj = gen_utableprocessout();
   end;

   Initc_usr_tbl_base("utableprocessout_dbt");

   init_table_obj();
end;

//Получим значение из строки со спец. разделителями
private macro ParsePriority( StrParam :variant ) :integer
      var StrDigit :string = "0123456789",
          StrParamBuf :string = "",
          StrParamPriority :string = "",
          i :integer = 0,
          StrPos :integer = 0,
          SymbOpen :string = "<",
          SymbClose :string = ">",
          FlSymbClose :bool = false;

      if( (Valtype(StrParam) != V_UNDEF) and (Valtype(StrParam) != 26) and (StrParam != "") )

         i = 1;
         StrPos = 0;
         while( i <= StrLen(StrParam) ) //Вырезать часть со спец. разделителями

          if( (StrPos > 0) and ( Substr(StrParam, i, 1) != SymbClose ) )
           StrParamPriority = StrParamPriority + Substr(StrParam, i, 1);
          end;

          if( Substr(StrParam, i, 1) == SymbOpen )
           StrPos = i;
          end;

          if( Substr(StrParam, i, 1) == SymbClose )
           StrPos = -1;
           FlSymbClose = true;
          end;

          if( ((StrPos == 0 ) or (StrPos == -1)) and (Substr(StrParam, i, 1) != SymbOpen) and (Substr(StrParam, i, 1) != SymbClose) )
            StrParamBuf = StrParamBuf + Substr(StrParam, i, 1);
          end;
          i = i + 1;

         end;

         StrParam = StrParamBuf;
         StrParamBuf = "";

         if( not FlSymbClose )
          return 0;
         end;

         i = 1;
         while( i <= StrLen(StrParamPriority) ) //нормализация оставить, что только цифры

            if( Index( (StrDigit), Substr(StrParamPriority, i, 1) ) >= 1 )
               StrParamBuf = StrParamBuf + Substr(StrParamPriority, i, 1);
            end;
            i = i + 1;

         end;

         StrParamPriority = StrParamBuf;
         StrParamBuf = "";

      end;

      return int( StrParamPriority );

onError(err)

   return 0;


end;



macro ws_check_job_NOB_out_run()
   var v_sql, v_cmd, v_rs;
   var v_recid = -1, v_recid_out_new = -1, v_priority = "0", v_element = 0, v_parsep;
   var v_state, v_result_scheduler;
   var ProcessEventTbl, ProcessOutTbl;
   var checkFiles, checkFiles_obj;

   // Проверка на существование незавершенных выгрузок за все время 
   v_sql =         "SELECT t_recid, t_status FROM utableprocessout_dbt ";
   v_sql = v_sql + " WHERE t_objecttype = :p_objecttype_nobout ";
   v_sql = v_sql + "   AND t_status IN (:p_status_new, :p_status_ready, :p_status_running) ";
   v_cmd = RSDCommand(v_sql);
   v_cmd.addParam("p_objecttype_nobout", RSDBP_IN, C_SOFR_NOB_OUT);
   v_cmd.addParam("p_status_new", RSDBP_IN, C_EVENT_STAT_NEW);
   v_cmd.addParam("p_status_ready", RSDBP_IN, C_EVENT_STAT_READY);
   v_cmd.addParam("p_status_running", RSDBP_IN, C_EVENT_STAT_RUNNING);
   v_rs = RSDRecordSet(v_cmd);
   if(v_rs.movenext())     // достаточно одной записи
      v_recid = v_rs.value("t_recid");
   end;
   v_rs.close(); v_cmd.close(); v_rs = NULL; v_cmd = NULL; v_sql = NULL;
   
   // запись в utableprocessout_dbt - все равно создаем с тем или иным статусом
   ProcessOutTbl = c_usr_tbl_utableprocessout;
   ProcessOutTbl.New_Val_Obj.T_OBJECTTYPE = C_SOFR_NOB_OUT;
   ProcessOutTbl.New_Val_Obj.T_TIMESTAMP = dttm(date(), time());
   ProcessOutTbl.add_returning_prm("T_RECID");

   // проверка на размер файлов выгрузки
   checkFiles = CkeckNOBFromSOFRToDepo;

   if (checkFiles.ErrorCode == -1)  // все файлы нулевые
      v_state = false;
      ProcessOutTbl.New_Val_Obj.T_STATUS = C_PROC_OUT_ERR;
      ProcessOutTbl.New_Val_Obj.T_RESULTTEXT = Substr(checkFiles.ErrorDesc,1,1000);
      if( not ProcessOutTbl.Insert() ) 
         ProcessOutTbl = Null;
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
         return v_result_scheduler;
      else
         ProcessOutTbl = Null;
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_END); // отработало успешно, но выгружать не будем
         return v_result_scheduler;
      end;
   else

      if (v_recid > 0) // есть необработанные
         v_state = false;
         ProcessOutTbl.New_Val_Obj.T_STATUS = C_PROC_OUT_ERR;
         ProcessOutTbl.New_Val_Obj.T_RESULTTEXT = "Есть незавершенное событие "+v_recid;
         if( not ProcessOutTbl.Insert() ) 
            ProcessOutTbl = Null;
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
            return v_result_scheduler;
         else
            ProcessOutTbl = Null;
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_END); // отработало успешно, но выгружать не будем
            return v_result_scheduler;
         end;
      else
         v_state = true;
         ProcessOutTbl.New_Val_Obj.T_STATUS = C_EVENT_STAT_NEW;
         if( not ProcessOutTbl.Insert() ) 
            v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
            return v_result_scheduler;
         else
            v_recid_out_new = ProcessOutTbl.New_Val_Obj.T_RECID;
            ProcessOutTbl = Null;  
         end;
      end;
   end;
   
   if (v_state)
      // dfuncobj_dbt
      // проверка на дублирование  dfuncobj_dbt внутри самой функции
      v_sql =         "SELECT T_NOTE, t_ELEMENT FROM dllvalues_dbt " ;
      v_sql = v_sql + "  WHERE T_LIST = 5002 AND T_CODE = '"+C_SOFR_NOB_OUT+"'" ;
      v_rs = RSDRecordSet(v_sql);
      if (v_rs.movenext())
         v_priority = v_rs.value("T_NOTE");
         v_element = v_rs.value("t_ELEMENT");
      else 
         v_priority = "0";
         v_element = 0;
      end;
      v_parsep = ParsePriority(v_priority);
      
      v_state = InsertSequenceJobUsrObj( v_recid_out_new,
                                         v_element,
                                         1,     // исходящий поток
                                         C_SOFR_NOB_OUT,
                                         v_parsep);
      if(v_state != 0)
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_END);
      else
         v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
      end;
   end;

   return v_result_scheduler;
onError(err)
   v_result_scheduler = c_ssRunResult(SS_RESPONSE_REPEAT_ERROR);
   return v_result_scheduler;
end; /* macro ws_check_job_NOB_out() */
