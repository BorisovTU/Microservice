/*-----------------------------------------------------------------*/
/* Инструментарий для преобразования сообщений                     */
/*                                                                 */
/* Author: Карпов В.                                               */
/*                                                                 */
/* Changes:                                                        */
/*                                                                 */
/*-----------------------------------------------------------------*/

import rsd;
//import serviceaction;          /* Содержится в global_utils.mac */
import "global_utils_intgr.mac"; /* Функции общего назначения */
import "external_ws_call.mac";   /* Взаимодействие с внешним сервисом */
import "uws_exchng_log.mac";     /* Журнализация взаимодействия с внешним сервисом */
import likepy;
import xmlRpcInter;


/* Методы преобразования транспортных сообщений */
class c_com_msg_converter()
   private var v_service_msg = "";
   private var v_result_msg = "";

   private var v_pure_msg = "";

   /* Метод получения текста сервисного сообщения */
   macro get_service_msg()
      return v_service_msg;
   end;

   /* Метод получения текста сформированного сообщения */
   macro get_result_msg()
      return v_result_msg;
   end;

   /* Метод получения текста чистого сообщения */
   macro get_pure_msg()
      return v_pure_msg;
   end;

   /* Валидация сообщения по схеме - begin */
   /* Метод создания com-объекта */
   private macro m_create_com_object(p_com_obj_name)
      private var v_obj = NULL;
      private var v_obj_com = NULL;
      v_service_msg = "";

      if(IsStandAlone())
         v_obj = ActiveX(p_com_obj_name);
      else
         v_obj_com = CreateObject("rsax", "TRsAxServer", "RsAxServer", false);
         v_obj = v_obj_com.CreateComObject(p_com_obj_name, true);
      end;

      return v_obj;

   onError(err)
      v_obj = NULL;

      v_service_msg = c_usr_err_obj.obtain_err_msg(err);

      return v_obj;
   end; /* macro m_create_com_object() */

   /* Метод валидации сообщения */
   /* В случае проблем возвращает текст, если все в порядке - NULL */
   macro m_validate_xml(p_xml_string, p_xsd_path)
      private var v_validate_str = NULL;
      private var v_load_result = NULL;
      private var v_xsd = NULL;
      private var v_xsd_cache = NULL;
      private var v_parser = NULL;

      v_service_msg = "";

      if(ValType(p_xsd_path) == V_UNDEF)
         v_service_msg = "Не задан путь к XML схеме";
         RunError(v_service_msg, c_usr_err_obj(v_service_msg));
      end;

      v_xsd = m_create_com_object("Msxml2.DOMDocument.6.0");
      if(ValType(v_xsd) == V_UNDEF)
         v_xsd = m_create_com_object("Msxml2.DOMDocument.4.0");

         if(ValType(v_xsd) == V_UNDEF)
            /* Проблемы при работе с MSXML2.DOMDocument */
            v_service_msg = string("Ошибка MSXML2.DOMDocument: ", v_service_msg);
            RunError(v_service_msg, c_usr_err_obj(v_service_msg));
         end;
      end;

      v_xsd_cache = m_create_com_object("Msxml2.XMLSchemaCache.6.0");
      if(ValType(v_xsd_cache) == V_UNDEF)
         v_xsd_cache = m_create_com_object("Msxml2.XMLSchemaCache.4.0");

         if(ValType(v_xsd_cache) == V_UNDEF)
            /* Проблемы при работе с Msxml2.XMLSchemaCache */
            v_service_msg = string("Ошибка Msxml2.XMLSchemaCache: ", v_service_msg);
            RunError(v_service_msg, c_usr_err_obj(v_service_msg));
         end;
      end;

      v_parser = m_create_com_object("Msxml2.DOMDocument.6.0");
      if(ValType(v_parser) == V_UNDEF)
         v_parser = m_create_com_object("Msxml2.DOMDocument.4.0");

         if(ValType(v_parser) == V_UNDEF)
            /* Проблемы при работе с MSXML2.DOMDocument */
            v_service_msg = string("Ошибка MSXML2.DOMDocument: ", v_service_msg);
            RunError(v_service_msg, c_usr_err_obj(v_service_msg));
         end;
      end;

      v_xsd.load(p_xsd_path);
      v_xsd_cache.add("", v_xsd);

      v_parser.async = false;
      v_parser.schemas = v_xsd_cache;

      v_load_result = v_parser.loadXML(p_xml_string);

      if(not v_load_result)
         v_validate_str = v_parser.parseError.reason;
      end;

      v_xsd = NULL;
      v_xsd_cache = NULL;
      v_parser = NULL;

      return v_validate_str;

   onError(err)
      v_validate_str = c_usr_err_obj.obtain_err_msg(err);
      return v_validate_str;
   end; /* macro m_validate_xml() */
   /* Валидация сообщения по схеме - end */

   /* Метод преобразования объекта в сообщение с трансформацией */
   macro m_obj_to_msg(p_rsl_obj, p_xsl_path)
      private var v_xml_rpc;
      private var v_stat = ConvertToXML(p_rsl_obj, "", v_xml_rpc);

      private var v_result_msg;
      if(ValType(p_xsl_path) != V_UNDEF)
         v_result_msg = ApplyXSLT(v_xml_rpc, p_xsl_path);
      else
         v_result_msg = v_xml_rpc;
      end;

      return v_result_msg;
   end;

   /* Метод преобразования сообщения в RSL объект (с предварительной трансформацией) */
   macro m_msg_to_obj(p_orig_msg, p_xsl_path)
      private var v_xml_rpc;
      if(ValType(p_xsl_path) != V_UNDEF)
         v_xml_rpc = ApplyXSLT(p_orig_msg, p_xsl_path);
      else
         v_xml_rpc = p_orig_msg;
      end;

      private var v_result_obj = NULL;
      private var v_stat = ConvertToRSL(v_xml_rpc, v_result_obj);

      return v_result_obj;
   end;

   /*--------------------------------------------------------------------------------------*/
   /* Вспомогательная функция при проверке наличия root_ns_alias в списке пространств имен */
   /*--------------------------------------------------------------------------------------*/
   private macro m_check_alias_in_list(p_is_root_ns,
                                       p_ns_list,
                                       p_root_ns_alias,
                                       p_root_ns_in_list)
      private var v_ret = false;

      if(not p_root_ns_in_list)
         if(p_is_root_ns)
            if(index(p_ns_list, string("xmlns:", p_root_ns_alias, "=")) != 0)
               v_ret = true;
            end;
         end;

      else
         v_ret = true;
      end;

      return v_ret;
   end; /* macro m_check_alias_in_list() */

   /*-----------------------------------------------*/
   /* Добавление пространства имен к исходным тегам */
   /*-----------------------------------------------*/
   private macro m_add_ns_to_msg(p_src_msg, p_root_ns_alias)
      private var v_ret;

      private var v_pos_a = index(p_src_msg, "<");
      private var v_pos_b = index(p_src_msg, ">");
      private var v_root_el_len = v_pos_b - (v_pos_a + 1);
      private var v_root_el_name = substr(p_src_msg, (v_pos_a + 1), v_root_el_len);
      private var v_src_len = strlen(p_src_msg);

      private var v_pos_s1 = v_pos_b;
      private var v_pos_s2;

      /* В конце строки могут быть лишние символы, которые входят в длину */
      while((v_src_len - v_pos_s1) > v_root_el_len)
         v_pos_s2 = index(p_src_msg, v_root_el_name, v_pos_s1);
         if(v_pos_s2 != 0)
            v_pos_s1 = v_pos_s2 + v_root_el_len;
            v_pos_b = v_pos_s2;
         else
            v_pos_s1 = v_src_len;
         end;
      end;
      private var v_main_msg_len = v_pos_b - (v_pos_a + 1);

      v_ret = string("<", p_root_ns_alias, ":",
                   substr(p_src_msg, (v_pos_a + 1), v_main_msg_len),
                   p_root_ns_alias, ":", v_root_el_name, ">");

      return v_ret;
   end; /* macro m_add_ns_to_msg() */

   /*--------------------------------------------*/
   /* Функция, заключающая запрос в soap-обертку */
   /*--------------------------------------------*/
   macro m_wrap_req_in_soap(p_src_msg, p_root_ns_alias, p_ns_list)

      private var v_ret = true;
      private var v_temp_msg;
      private var v_list_type = ValType(p_ns_list);
      private var v_root_ns_type = ValType(p_ns_list);
      private var v_is_root_ns = false;
      private var v_root_ns_in_list = false;
      private var v_list_cntr = 0;

      if(v_root_ns_type == V_STRING)
         if(strlen(p_root_ns_alias) != 0)
            v_is_root_ns = true;
         end;
      end;

      v_temp_msg = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"";

      if(v_list_type == V_STRING)
         v_root_ns_in_list = m_check_alias_in_list(v_is_root_ns,
                                                   p_ns_list,
                                                   p_root_ns_alias,
                                                   v_root_ns_in_list);
         v_temp_msg = v_temp_msg + string(" ", p_ns_list);

      elif(v_list_type == V_GENOBJ)
         while(v_list_cntr < p_ns_list.size)
            v_root_ns_in_list = m_check_alias_in_list(v_is_root_ns,
                                                      p_ns_list.value(v_list_cntr),
                                                      p_root_ns_alias,
                                                      v_root_ns_in_list);
            v_temp_msg = v_temp_msg + string(" ", p_ns_list.value(v_list_cntr));
         end;
      end;

      v_temp_msg = v_temp_msg + ">";
      v_temp_msg = v_temp_msg +    "<soapenv:Header/>";
      v_temp_msg = v_temp_msg +    "<soapenv:Body>";

      if(v_is_root_ns)
         v_temp_msg = v_temp_msg + m_add_ns_to_msg(p_src_msg, p_root_ns_alias);
      else
         v_temp_msg = v_temp_msg + p_src_msg;
      end;

      v_temp_msg = v_temp_msg +    "</soapenv:Body>";
      v_temp_msg = v_temp_msg + "</soapenv:Envelope>";

      v_result_msg = v_temp_msg;

      if(v_is_root_ns)
         if(not v_root_ns_in_list)
            v_service_msg = "Пространство имен сообщения не определено";
            v_ret = false;
         end;
      end;

      return v_ret;
   end; /* macro m_wrap_req_in_soap() */

end; /* class c_com_msg_converter() */


/*-------------------------------------*/
/* Общий класс вызова внешнего сервиса */
/*-------------------------------------*/
class c_com_ext_ws_processor()
   private var vg_service_logger; /* Переменная для объекта логирования сообщений веб-сервиса */
   private var vg_service_msg = "";
   private var vg_service_code = "";

   /* Признак отсутствия экранированных символов в ответе сервиса */
   private var vg_is_native_markup = false; /* Значение по умолчанию */
   private var vg_log_module_name = "WS_PROC";
   /* Используемый журнал */
   private var vg_logging_type = 2; /* 0 - не используется (не желательно!); 1 - используется "легкий" журнал; 2 - используется "подробный" журнал */

   private var vg_req_id    = NULL;
   private var vg_req_obj   = NULL;
   private var vg_req_msg   = NULL;
   private var vg_resp_msg  = NULL;
   private var vg_resp_obj  = NULL;
   /* Используемые параметры аутентификации */
   private var vg_auth_type = 0; /* 0 - не используется; 1 - логин/пароль; 2 - сертификат; 3 - используется 1 и 2 */
   private var vg_auth_login = "";
   private var vg_auth_password = "";
   private var vg_certificate_path = "";
   private var vg_hdr_val_host = "";
   private var vg_hdr_val_soapaction = "";

   private var vg_t_resolve = 30000;
   private var vg_t_connect = 60000;
   private var vg_t_send = 30000;
   private var vg_t_receive = 60000;


   /* Метод задания текста сервисного сообщения */
   macro set_service_msg(in_serv_msg)
      vg_service_msg = in_serv_msg;
   end;

   /* Метод получения текста сервисного сообщения */
   macro get_service_msg()
      return vg_service_msg;
   end;

   /* Метод задания значения сервисного кода */
   macro set_service_code(in_serv_code)
      vg_service_code = in_serv_code;
   end;

   /* Метод получения значения сервисного кода */
   macro get_service_code()
      private var ret;

      if(strlen(vg_service_code) == 0)
         ret = UNIVERSAL_ERROR_CODE;
      else
         ret = vg_service_code;
      end;

      return ret;
   end;

   /* Метод получения признака отсутствия экранированных символов в ответе сервиса */
   macro get_is_native_markup()
      return vg_is_native_markup;
   end;

   /* Метод задания признака отсутствия экранированных символов в ответе сервиса */
   macro set_is_native_markup(in_is_native_markup)
      vg_is_native_markup = in_is_native_markup;
   end;

   /* Метод задания названия модуля для лога */
   macro set_log_module_name(in_log_module_name)
      /* В таблице журнала поле T_MODULE имеет длину 25 символов */
      if(strlen(in_log_module_name) > 25)
         vg_log_module_name = substr(in_log_module_name, 1, 25);
      end;
   end;

   /* Метод получения названия модуля для лога */
   macro get_log_module_name()
      return vg_log_module_name;
   end;

   /* Метод задания идентификатора зарпоса */
   macro set_req_id(in_req_id)
      vg_req_id = in_req_id;
   end;

   /* Метод получения идентификатора запроса */
   macro get_req_id()
      private var ret;

      if(ValType(vg_req_id) == V_UNDEF)
         ret = "";
      else
         ret = vg_req_id;
      end;

      return ret;
   end;

   /* Метод задания объекта запроса */
   macro set_req_obj(in_req_obj)
      vg_req_obj = in_req_obj;
   end;

   /* Метод получения объекта запроса */
   macro get_req_obj()
      return vg_req_obj;
   end;

   /* Метод задания текста сообщения запроса */
   macro set_req_msg(in_req_msg)
      vg_req_msg = in_req_msg;
   end;

   /* Метод получения текста сообщения запроса */
   macro get_req_msg()
      return vg_req_msg;
   end;

   /* Метод задания текста ответного сообщения */
   macro set_resp_msg(in_resp_msg)
      vg_resp_msg = in_resp_msg;
   end;

   /* Метод получения текста ответного сообщения */
   macro get_resp_msg()
      return vg_resp_msg;
   end;

   /* Метод задания объекта ответа */
   macro set_resp_obj(in_resp_obj)
      vg_resp_obj = in_resp_obj;
   end;

   /* Метод получения объекта ответа */
   macro get_resp_obj()
      return vg_resp_obj;
   end;

   /* Метод получения заданного пути к сертификату */
   macro get_cert_path()
      return vg_certificate_path;
   end;

   /*-------------------------------------*/
   /* Получить значение настройки реестра */
   /*-------------------------------------*/
   private macro m_get_reg_parm(p_reg_path, p_val_type, p_ret_val : @bool)
      private const CV_ERR_TEXT = "Ошибка получения значения настройки реестра: ";
      private var v_ret;
//      private var {oper};
      private var v_err_code = 0;
      private var v_reg_val;

      GetRegistryValue(p_reg_path, p_val_type, v_reg_val, v_err_code, null, {oper});

      if(v_err_code == 0)
         p_ret_val = true;
         v_ret = v_reg_val;
      else
         p_ret_val = false;
         v_ret = "";
         vg_service_msg = string(CV_ERR_TEXT, v_err_code);
      end;

      return v_ret;

   onError(err)
      p_ret_val = false;
      v_ret = "";
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_get_reg_parm() */

   /*-----------------------------------------------------------------------*/
   /*               Задать значение типа используемого журнала              */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_logging_type_val(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Тип журнализации - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_INTEGER;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_logging_type = v_reg_val;
         else
            vg_logging_type = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_logging_type = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_logging_type_val() */

   /*-----------------------------------------------------------------------*/
   /*                  Задать значение типа аутентификации                  */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_auth_type_val(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Тип аутентификации - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_INTEGER;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_auth_type = v_reg_val;
         else
            vg_auth_type = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_auth_type = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_auth_type_val() */

   /*-----------------------------------------------------------------------*/
   /*                Задать значение логина (аутентификация)                */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_auth_login_val(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Логин (аутентификация) - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_STRING;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_auth_login = v_reg_val;
         else
            vg_auth_login = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_auth_login = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_auth_login_val() */

   /*-----------------------------------------------------------------------*/
   /*                Задать значение пароля (аутентификация)                */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_auth_pwd_val(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Логин (аутентификация) - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_STRING;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_auth_password = v_reg_val;
         else
            vg_auth_password = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_auth_password = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_auth_pwd_val() */

   /*-----------------------------------------------------------------------*/
   /*                     Задать значение заголовка Host                    */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_host_val(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Заголовок Host - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_STRING;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_hdr_val_host = v_reg_val;
         else
            vg_hdr_val_host = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_hdr_val_host = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_host_val() */

   /*-----------------------------------------------------------------------*/
   /*                  Задать значение заголовка SOAPAction                 */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_soapaction_val(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Заголовок SOAPAction - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_STRING;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_hdr_val_soapaction = v_reg_val;
         else
            vg_hdr_val_soapaction = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_hdr_val_soapaction = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_soapaction_val() */

   /*-----------------------------------------------------------------------*/
   /*                       Задать путь к сертификату                       */
   /*-----------------------------------------------------------------------*/
   /* p_is_reg_path - признак, определяющий передается ли в p_val само      */
   /*                 значение (false - по умолчанию), либо путь к значению */
   /*                 в реестре настроек (true - необходимо указать явно)   */
   /*-----------------------------------------------------------------------*/
   macro m_set_cert_path(p_val, p_is_reg_path)
      private const CV_ERR_TEXT = "Путь к сертификату - Ошибка: ";
      private var v_ret = true;
      private var v_reg_val;
      private var v_val_type = V_STRING;
      private var v_is_reg_path = false;

      if(ValType(p_is_reg_path) != V_UNDEF)
         v_is_reg_path = p_is_reg_path;
      end;

      /* При необходимости берем значение из реестра настроек */
      if(v_is_reg_path)
         v_reg_val = m_get_reg_parm(p_val, v_val_type, @v_ret);

         if(v_ret)
            vg_certificate_path = v_reg_val;
         else
            vg_certificate_path = "";
            vg_service_msg = string(CV_ERR_TEXT, vg_service_msg)
         end;
      else
         vg_certificate_path = p_val;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string(CV_ERR_TEXT, c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_set_cert_path() */

   /*------------------------------------------------------*/
   /* Метод подготовки строки авторизации по формату Basic */
   /*------------------------------------------------------*/
   private macro m_make_auth_str(p_ret_val :@bool)
      private var v_ret;
      private var v_raw_str;
      private var v_stat;

      v_raw_str = string(vg_auth_login, ":", vg_auth_password);
      v_stat = EncodeBase64(v_raw_str, v_ret);

      p_ret_val = v_stat;
      if(not v_stat)
         v_ret = "";
      end;

      return v_ret;
   end; /* macro m_make_auth_str() */

   /*----------------------------------------------*/
   /* Метод получения сообщения запроса из объекта */
   /*----------------------------------------------*/
   macro m_make_req_msg(p_root_ns_alias, p_ns_list)
      private var v_ret = true;
/* !!! - Необходимо перегружать для каждого случая - !!! */ /*
      private var v_wrap_obj;

      vg_req_msg = c_440p_msg_converter.m_440p_external_req(vg_req_obj);
      v_wrap_obj = c_440p_msg_converter();

      if(v_wrap_obj.m_wrap_req_in_soap(vg_req_msg, p_root_ns_alias, p_ns_list))
         vg_req_msg = v_wrap_obj.get_result_msg();
      else
         vg_service_msg = vg_req_msg.get_service_msg();
         v_ret = false;
      end;

      v_wrap_obj = null;
*/
      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string("При формировании сообщения запроса возникла ошибка: ",
                           c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_make_req_msg() */

   /*-------------------------------------------------------*/
   /* Метод получения сообщения без экранированных символов */
   /*-------------------------------------------------------*/
   private macro get_native_markup_msg(p_mix_msg)
      var v_ret;

      v_ret = StrSubst(p_mix_msg, "&lt;", "<");
      v_ret = StrSubst(v_ret, "&#60;", "<");
      v_ret = StrSubst(v_ret, "&gt;", ">");
      v_ret = StrSubst(v_ret, "&#62;", ">");

      return v_ret;
   end;

   /*---------------------------------------------*/
   /* Метод получения объекта из сообщения ответа */
   /*---------------------------------------------*/
   macro m_make_resp_obj()
      var v_ret = true;
/* !!! - Необходимо перегружать для каждого случая - !!! */ /*
      if(m_get_pure_response()) // 20180923 - метод удален
         vg_resp_obj = c_com_msg_converter.m_external_resp(vg_pure_resp); // 20180923 - свойство удалено
      else
         v_ret = false;
      end;
*/
      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string("В процессе преобразования ответа возникла ошибка: ",
                              c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_make_resp_obj() */

   /*------------------------------*/
   /* Установка значений таймаутов */
   /*------------------------------*/
   macro m_set_timeouts(p_t_resolve, p_t_connect, p_t_send, p_t_receive)
      if(ValType(p_t_resolve) != V_UNDEF)
         vg_t_resolve = p_t_resolve;
      end;
      if(ValType(p_t_connect) != V_UNDEF)
         vg_t_connect = p_t_connect;
      end;
      if(ValType(p_t_send) != V_UNDEF)
         vg_t_send = p_t_send;
      end;
      if(ValType(p_t_receive) != V_UNDEF)
         vg_t_receive = p_t_receive;
      end;
   end;

   /* Метод записи информации об ошибке в лог и закрытие объекта лога */
   macro m_make_final_log(p_error_code, p_error_msg)
      private var v_ret = true;
      private var v_error_code = "0";
      private var v_error_msg = "";

      if(ValType(p_error_code) != V_UNDEF)
         v_error_code = string(p_error_code);
      end;

      if(ValType(p_error_msg) != V_UNDEF)
         v_error_msg = p_error_msg;
      end;

      if(ValType(vg_service_logger) != V_UNDEF)
         if(vg_logging_type == 1)
            vg_service_logger.add_error_info(v_error_code, v_error_msg); /* 3/3 лога */
         elif(vg_logging_type == 2)
            vg_service_logger.add_error_info(v_error_code, v_error_msg); /* 3/3 лога */
         end;

         vg_service_logger = null;
      else
         v_ret = false;
      end;

      return v_ret;
   end; /* macro m_make_final_log() */

   /*------------------------------------------------------------------*/
   /* Метод вызова внешнего web-сервиса посредством WinHttpRequest.5.1 */
   /*------------------------------------------------------------------*/
   /* p_macro_name  - название макроса, из которого выполняется вызов  */
   /*                 (используется для логирования)                   */
   /* p_module_name - название модуля (функционала), выполняющего      */
   /*                 вызов (используется для логирования)             */
   /* p_host        - особое значение заголовка Host                   */
   /* p_soap_action - особое значение заголовка SOAPAction             */
   /*------------------------------------------------------------------*/
   /* При необходимости использования иного набора параметров запроса, */
   /*           !!! - следует перегрузить данный метод - !!!           */
   /*------------------------------------------------------------------*/
   macro uCallExtServiceViaWinHttp(p_url_str,
                                   p_macro_name,
                                   p_module_name,
                                   p_host,
                                   p_soap_action)
//      private const CV_HDR_NAME_ACCEPT_ENCODING = "Accept-Encoding";
      private const CV_HDR_NAME_CONTENT_TYPE = "Content-Type";
      private const CV_HDR_NAME_HOST = "Host";
      private const CV_HDR_NAME_SOAP_ACTION = "SOAPAction";
//      private const CV_HDR_VAL_ACCEPT_ENCODING = "gzip,deflate";
      private const CV_HDR_VAL_CONTENT_TYPE = "text/xml;charset=UTF-8";
      private const CV_HDR_NAME_AUTH = "Authorization";
      private const CV_HDR_VAL_AUTH = "Basic ";
      private const CV_ERR_TEXT_AUTH = " аутентификации (не хватает параметров)";
      var v_ret = true;
      var v_resp_xml_soap;
      var v_module_name, v_host, v_soap_action;

      var v_http_req = c_external_ws_caller();

      /* Значение по умолчанию */
      if(ValType(p_module_name) != V_UNDEF)
         v_module_name = p_module_name;
      else
         v_module_name = vg_log_module_name;
      end;

      /* Если заданы особые значения заголовков Host и SOAPAction, то используем их */
      if(ValType(p_host) != V_UNDEF)
         v_host = p_host;
      else
         v_host = vg_hdr_val_host;
      end;

      if(ValType(p_soap_action) != V_UNDEF)
         v_soap_action = p_soap_action;
      else
         v_soap_action = vg_hdr_val_soapaction;
      end;

      /* Логирование - begin */
      if(vg_logging_type == 1)
         vg_service_logger = uws_exchng_logger(true,
                                               vg_req_id,
                                               XmlRpcRequestId(),
                                               v_module_name,
                                               p_macro_name); /* 1/3 лога */
      elif(vg_logging_type == 2)
         vg_service_logger = uws_exchng_logger(false,
                                               vg_req_id,
                                               XmlRpcRequestId(),
                                               v_module_name,
                                               p_macro_name,
                                               NULL,
                                               vg_req_msg); /* 1/3 лога */
      end;
      /* Логирование - end */

      /* Определение URL */
      v_http_req.server_url = p_url_str;

      /* Определение таймаутов */
      v_http_req.timeout_resolve = vg_t_resolve;
      v_http_req.timeout_connect = vg_t_connect;
      v_http_req.timeout_send    = vg_t_send;
      v_http_req.timeout_receive = vg_t_receive;

      /* Определение заголовков */
//      v_http_req.add_http_header(CV_HDR_NAME_ACCEPT_ENCODING, CV_HDR_VAL_ACCEPT_ENCODING);
      v_http_req.add_http_header(CV_HDR_NAME_CONTENT_TYPE, CV_HDR_VAL_CONTENT_TYPE);
      v_http_req.add_http_header(CV_HDR_NAME_SOAP_ACTION, v_soap_action);
      v_http_req.add_http_header(CV_HDR_NAME_HOST, v_host);

      /* Определение http-опций запроса */
      /* WinHttpRequestOption_SslErrorIgnoreFlags = 0x3300 (13056) - all server certificate errors being ignored */
//      v_http_req.set_option_value(4, 13056);

      /*----------------------------------*/
      /* Параметры аутентификации - begin */
      if(vg_auth_type == 1)
         /* Логин/пароль */
         if(strlen(vg_auth_login) == 0)
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": логин")));
         end;
/* Пока предполагаем, что пустой пароль тоже допустим *//*
         if(strlen(vg_auth_password) == 0)
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": пароль")));
         end;
*/
         v_http_req.add_http_header(CV_HDR_NAME_AUTH, string(CV_HDR_VAL_AUTH, m_make_auth_str(@v_ret)));
         if(not v_ret)
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": строка логин/пароль")));
         end;

      elif(vg_auth_type == 2)
         /* Сертификат */
         if(strlen(vg_certificate_path) != 0)
            v_http_req.client_https_certificate = vg_certificate_path;
         else
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": путь к сертификату")));
         end;

      elif(vg_auth_type == 3)
         /* Логин/пароль */
         if(strlen(vg_auth_login) == 0)
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": логин")));
         end;
/* Пока предполагаем, что пустой пароль тоже допустим *//*
         if(strlen(vg_auth_password) == 0)
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": пароль")));
         end;
*/
         v_http_req.add_http_header(CV_HDR_NAME_AUTH, string(CV_HDR_VAL_AUTH, m_make_auth_str(@v_ret)));
         if(not v_ret)
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": строка логин/пароль")));
         end;
         /* Сертификат */
         if(strlen(vg_certificate_path) != 0)
            v_http_req.client_https_certificate = vg_certificate_path;
         else
            RunError(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH),
                     c_usr_err_obj(string("Тип ", vg_auth_type, CV_ERR_TEXT_AUTH, ": путь к сертификату")));
         end;

      //else // в остальных случаях параметры аутентификации не настраиваются
      end; /* if(vg_auth_type == 1) */
      /* Параметры аутентификации - end */
      /*--------------------------------*/

      /* Отправка запроса */
      if(v_http_req.submit_request(vg_req_msg))
         /* Success! */
         /* v_resp_xml_soap = v_http_req.get_response_text(); */
         /* Если вдруг символы '<' и '>' экранируются, то приводим строку к нормальному виду */
         if(vg_is_native_markup)
            v_resp_xml_soap = v_http_req.get_response_text();
         else
            v_resp_xml_soap = get_native_markup_msg(v_http_req.get_response_text());
         end;

         vg_resp_msg = v_resp_xml_soap;

         /* Логирование - begin */
         if(vg_logging_type == 1)
            vg_service_logger.add_error_info("0", substr(1, vg_resp_msg, 255)); /* 2/3 лога */
         elif(vg_logging_type == 2)
            vg_service_logger.add_response(vg_resp_msg); /* 2/3 лога */
         end;
         /* Логирование - end */

      else
         /* Error! */
         if(vg_is_native_markup)
            v_resp_xml_soap = v_http_req.get_response_text();
         else
            v_resp_xml_soap = get_native_markup_msg(v_http_req.get_response_text());
         end;

         vg_resp_msg = v_resp_xml_soap;

         /* Логирование - begin */
         if(vg_logging_type == 1)
            vg_service_logger.add_error_info(string(v_http_req.get_return_code()),
                                             string(v_http_req.get_return_code(), " (", v_http_req.get_status_text(), ")", ": ", v_http_req.get_service_msg())); /* 2/3 лога */
         elif(vg_logging_type == 2)
            vg_service_logger.add_response(vg_resp_msg,
                                           string(v_http_req.get_return_code()),
                                           string(v_http_req.get_return_code(), " (", v_http_req.get_status_text(), ")", ": ", v_http_req.get_service_msg())); /* 2/3 лога */
         end;
         /* Логирование - end */

         set_service_msg(string(v_http_req.get_return_code(), " (", v_http_req.get_status_text(), ")", ": ", v_http_req.get_service_msg()));
         v_ret = false;
      end;

/* Закомментировано, чтобы иметь возможность работать с объектом снаружи (под отладкой) */ /*
      vg_service_logger = null;
*/
      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string("В сеансе вызова сервиса возникла ошибка: ",
                              c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro uCallExtServiceViaWinHttp() */

end; /* class c_com_ext_ws_processor() */