/*
$Name:        ws_msg_transform_sec.mac
$Module:      Интеграция с внешними системами
$Description: Инструментарий для преобразования сообщений Веб-сервисов
*/

/*----------------------------------------------------------*/
/* Автор: Карпов В.                                         */
/*----------------------------------------------------------*/

import rsd;
import "global_utils_intgr.mac";
import likepy;
import xmlRpcInter;

import "external_ws_call.mac"; /* Функционал для работы с объектом WinHttpRequest.5.1 */
import "uws_exchng_log.mac";   /* Функционал для логирования взаимодействия с сервисами */

import oralib; //maa200318 - debug

const ERR_CODE_NO_REQUIRED_PRM = -1000; /* Не заполнено обязательное поле */
const ERR_CODE_TECH_ERROR      = -1001; /* Список технических ошибок - см. документацию */
const ERR_CODE_NO_IN_PRM       = -1002; /* Отсутствуют параметры запроса */
const ERR_CODE_CANT_TRANSFORM  = -1003; /* Ошибка формата сообщения */
const ERR_CODE_NOT_CORRECT_VAL = -1004; /* Ошибка обработки. Некорректное значение реквизита */
const ERR_CODE_CONTRACT_NOT_FOUND = -1005; /* Номер договора не найден */
const ERR_CODE_CLIENT_NOT_FOUND = -1006; /* Клиент не найден */

const ERR_TEXT_NO_IN_MSG = "Не были переданы входные данные";

const InErrComPartM = "Не заданы обязательные параметры: ";
private var {oper};

//maa200318 - для отладки и просмотра трассы точки начала и конца работы кода
macro OutputInTrace( place )
  var query = "Select '"+ place +"' From dual;";
  var rs:RsdRecordset = execSQLselect( query );
  rs.moveFirst();
end;

/*
/*-----------------------------------------------------------*/
/* Функция получения значения свойства заданного класса      */
/* Отличается от TryToGetProp() проверкой на пустую строку   */
/* Если в xml передана пустая строка, то функция вернет NULL */
/*-----------------------------------------------------------*/
macro uTryToGetPropS(obj:object, propName:string)
   var ret;
   ret = genGetProp(obj, propName);
   if(ValType(ret) == V_STRING)
      if(StrLen(ret) == 0)
         ret = NULL;
      end;
   elif(ValType(ret) == V_DATE)
      if(ret == date(0, 0, 0))
         ret = NULL;
      end;
   end;
   return ret;

   onError
      return NULL
end;
*/

/*------------------------------------------*/
/* Класс для хранения полного текста ошибки */
/*------------------------------------------*/
class c_err_obj(p_err_msg, p_err_code)
   private var v_prop_list = TArray();
   private var v_err_code = "";
   var v_err_msg = "";

   /* Конструктор */
   private macro init_err_obj_params(p_err_msg, p_err_code)
      if(ValType(p_err_msg) != V_UNDEF)
         v_err_msg = string(p_err_msg);
      end;
      if(ValType(p_err_code) != V_UNDEF)
         v_err_code = string(p_err_code);
      end;
   end;

   /* Поиск свойства с заданным именем в заданном объекте */
   private macro try_to_find_prop(p_err_obj, p_prop_name, p_use_exist)
      var ret = false;
      var v_cntr_list = 0;
                                            
      if((ValType(p_use_exist) == V_UNDEF))
         v_prop_list.size = 0;
         v_prop_list = TArray(GetObjProps(p_err_obj, true));
      else
         if(not p_use_exist)
            v_prop_list.size = 0;
            v_prop_list = TArray(GetObjProps(p_err_obj, true));
         end;
      end;

      while((not ret) and (v_prop_list.size > v_cntr_list))
         if(v_prop_list.value(v_cntr_list) == p_prop_name)
            ret = true;
         end;
         v_cntr_list = v_cntr_list + 1;
      end;

      if(ValType(p_use_exist) == V_UNDEF)
         v_prop_list.size = 0;
      end;

      return ret;
   end;

   /* Получить v_err_msg */
   macro get_err_msg()
      return v_err_msg;
   end;

   /* Получить v_err_code */
   macro get_err_code()
      return v_err_code;
   end;

   /* Получить служебное сообщение из объекта ошибки */
   macro obtain_err_msg(p_err_obj)
      private var actx_code, actx_text, actx_msg;
      private var v_err_obj = NULL;

      if(try_to_find_prop(p_err_obj, "AxCode", false))
         actx_code = uTryToGetPropS(p_err_obj, "AxCode");
      else
         actx_code = 0;
      end;
      if(try_to_find_prop(p_err_obj, "Message", true))
         actx_text = uTryToGetPropS(p_err_obj, "Message");
      else
         actx_text = "0";
      end;
      if(try_to_find_prop(p_err_obj, "AxMes", true))
         actx_msg = uTryToGetPropS(p_err_obj, "AxMes");
      else
         actx_msg = "0";
      end;
      if(actx_code == 0)
         if(try_to_find_prop(p_err_obj, "Err", true))
            v_err_obj = uTryToGetPropS(p_err_obj, "Err");
            if(ValType(v_err_obj) == V_GENOBJ)
               if(try_to_find_prop(v_err_obj, "v_err_msg"))
                  v_err_msg = uTryToGetPropS(v_err_obj, "v_err_msg");
                  if(ValType(v_err_msg) == V_UNDEF)
                     v_err_msg = actx_text;
                  end;
               else
                  v_err_msg = actx_text;
               end;
            else
               v_err_msg = actx_text;
            end;
         else
            v_err_msg = actx_text;
         end;
      else
         v_err_msg = string(actx_text, ": Code: ", actx_code, "; Text: ", actx_msg);
      end;

      return v_err_msg;
   end;

   /* Получить код ошибки */
   macro obtain_err_code(p_err_obj, p_def_code)
      private var v_err_obj = NULL;

      if(try_to_find_prop(p_err_obj, "Err"))
         v_err_obj = uTryToGetPropS(p_err_obj, "Err");
         if(ValType(v_err_obj) == V_GENOBJ)
            if(try_to_find_prop(v_err_obj, "v_err_msg"))
               v_err_code = p_err_obj.err.get_err_code();
            end;
         end;
      end;

      if(strlen(v_err_code) == 0)
         if(ValType(p_def_code) != V_UNDEF)
            v_err_code = p_def_code;
         else
            if(try_to_find_prop(p_err_obj, "Code"))
               v_err_code = uTryToGetPropS(p_err_obj, "Code");
               if(ValType(v_err_code) == V_UNDEF)
                  v_err_code = UNIVERSAL_ERROR_CODE;
               end;
            else
               v_err_code = UNIVERSAL_ERROR_CODE;
            end;
         end;
      end;

      return v_err_code;
   end;

   init_err_obj_params(p_err_msg, p_err_code);
end; /* class c_err_obj() */


/*-------------------------------------*/
/* Получить значение настройки реестра */
/*-------------------------------------*/
macro uGetRegistryParam(reg_path, val_type)
   var ret;
//   var {oper};
   var err_code = 0;
   var reg_val;

   GetRegistryValue(reg_path, val_type, reg_val, err_code, null, {oper});

   if(err_code == 0)
      ret = reg_val;
   else
      ret = "";
   end;

   return ret;

onError(err)
   ret = "";

   return ret;
end; /* macro uGetRegistryParam() */


/*-------------------------------------------------------------*/
/* Функция получения строки сообщения об отсутствии параметров */
/*-------------------------------------------------------------*/
macro make_prm_absense_msg(name_list)
   var ret;
   var aux_buff = 0;

   if(name_list.size > 1)
      ret = InErrComPartM;
   else
      ret = InErrComPart;
   end;

   while(aux_buff < name_list.size)
      if(aux_buff != 0)
         ret = string(ret, ", ", name_list.value(aux_buff));
      else
         ret = string(ret, name_list.value(aux_buff));
      end;
      aux_buff = aux_buff + 1;
   end;

   return ret;
end; /* macro make_prm_absense_msg() */


/* Методы преобразования транспортных сообщений */
class psb_msg_converter_sec()
   private const SEC_MSG_XSD   = "E:\\public_e\\home\\Karpov\\xsl\\s_in_rs_secur_xml_schema.xsd";
   private const SEC_EXT_REQ_XSL  = "E:\\public_e\\home\\Karpov\\xsl\\t_secur_xml_rpc_to_ifx.xsl";
   private const SEC_EXT_RESP_XSL = "E:\\public_e\\home\\Karpov\\xsl\\t_secur_ifx_to_xml_rpc.xsl";
   private const SEC_INT_REQ_XSL  = "E:\\public_e\\home\\Karpov\\xsl\\t_secur_ifx_to_xml_rpc.xsl";
   private const SEC_INT_RESP_XSL = "E:\\public_e\\home\\Karpov\\xsl\\t_secur_xml_rpc_to_ifx.xsl";

   private var service_msg = "";
   private var result_msg = "";

   private var pure_msg = "";

   /* Метод получения текста сервисного сообщения */
   macro get_service_msg()
      return service_msg;
   end;

   /* Метод получения текста сформированного сообщения */
   macro get_result_msg()
      return result_msg;
   end;

   /* Метод получения текста чистого сообщения */
   macro get_pure_msg()
      return pure_msg;
   end;

   /* Валидация сообщения по схеме - begin */
   /* Метод создания com-объекта */
   private macro create_com_object(com_obj_name)
      private var obj = NULL;
      private var obj_com = NULL;
      service_msg = "";
 OutputInTrace ("debug44001");  //maa-debug
      if(IsStandAlone())
 OutputInTrace ("debug44002");  //maa-debug
         obj = ActiveX(com_obj_name);
      else
 OutputInTrace ("debug44003");  //maa-debug
 OutputInTrace (com_obj_name);  //maa-debug
         obj_com = CreateObject("rsax", "TRsAxServer", "RsAxServer", true); //maa200318  - сменил третий параметр на True чтобы избежать ошибки создания ком-объекта
 OutputInTrace ("qwe1111");  //maa-debug
         obj = obj_com.CreateComObject(com_obj_name, true);
 OutputInTrace ("qwe2211");  //maa-debug
      end;

      return obj;

   onError(err)
      obj = NULL;

      service_msg = c_err_obj.obtain_err_msg(err);

      return obj;
   end;

   /* Метод валидации сообщения */
   /* В случае проблем возвращает текст, если все в порядке - NULL */
   macro sec_validate_xml(xml_string)
      private var validate_str = NULL;
      private var load_result = NULL;
      private var v_xsd = NULL;
      private var v_xsd_cache = NULL;
      private var v_parser = NULL;

      service_msg = "";
OutputInTrace ("debug30001");  //maa-debug
      v_xsd = create_com_object("Msxml2.DOMDocument.6.0");
OutputInTrace ("debug30002");  //maa-debug
      if(ValType(v_xsd) == V_UNDEF)
OutputInTrace ("debug30003");  //maa-debug
         v_xsd = create_com_object("Msxml2.DOMDocument.6.0");  //4
OutputInTrace ("debug30004");  //maa-debug
         if(ValType(v_xsd) == V_UNDEF)
            /* Проблемы при работе с MSXML2.DOMDocument */
            RunError("Ошибка MSXML2.DOMDocument", c_err_obj(service_msg));
         end;
      end;
OutputInTrace ("debug30005");  //maa-debug
      v_xsd_cache = create_com_object("Msxml2.XMLSchemaCache.6.0");
OutputInTrace ("debug30006");  //maa-debug
      if(ValType(v_xsd_cache) == V_UNDEF)
OutputInTrace ("debug30007");  //maa-debug
         v_xsd_cache = create_com_object("Msxml2.XMLSchemaCache.6.0"); //4
OutputInTrace ("debug30008");  //maa-debug
         if(ValType(v_xsd_cache) == V_UNDEF)
            /* Проблемы при работе с Msxml2.XMLSchemaCache */
            RunError("Ошибка Msxml2.XMLSchemaCache", c_err_obj(service_msg));
         end;
      end;
OutputInTrace ("debug30009");  //maa-debug
      v_parser = create_com_object("Msxml2.DOMDocument.6.0");
OutputInTrace ("debug30010");  //maa-debug
      if(ValType(v_parser) == V_UNDEF)
OutputInTrace ("debug30011");  //maa-debug
         v_parser = create_com_object("Msxml2.DOMDocument.6.0");   //4
OutputInTrace ("debug30012");  //maa-debug
         if(ValType(v_parser) == V_UNDEF)
            /* Проблемы при работе с MSXML2.DOMDocument */
            RunError("Ошибка MSXML2.DOMDocument", c_err_obj(service_msg));
         end;
      end;
OutputInTrace ("debug30013");  //maa-debug
      v_xsd.load(SEC_MSG_XSD);
OutputInTrace ("debug30014");  //maa-debug
      v_xsd_cache.add("", v_xsd);
OutputInTrace ("debug30015");  //maa-debug
      v_parser.async = false;
      v_parser.schemas = v_xsd_cache;
OutputInTrace ("debug30016");  //maa-debug
      load_result = v_parser.loadXML(xml_string);
OutputInTrace ("debug30017");  //maa-debug
      if(not load_result)
OutputInTrace ("debug30018");  //maa-debug
         validate_str = v_parser.parseError.reason;
      end;

      v_xsd = NULL;
      v_xsd_cache = NULL;
      v_parser = NULL;     

      return validate_str;

   onError(err)
OutputInTrace ("debug39999991");  //maa-debug
      validate_str = c_err_obj.obtain_err_msg(err);
      return validate_str;
   end;
   /* Валидация сообщения по схеме - end */

   /* Направление запроса RS-Connect -> Абонент - begin */
   /* Метод преобразования сообщения запроса внешнего сервиса */
   macro sec_external_req(rsl_obj)
      private var xml_rpc;
      private var stat = ConvertToXML(rsl_obj, "", xml_rpc);

      private var result_msg = ApplyXSLT(xml_rpc, SEC_EXT_REQ_XSL);

      return result_msg;
   end;

   /* Метод преобразования сообщения ответа внешнего сервиса () */
   macro sec_external_resp(orig_msg)
      private var xml_rpc = ApplyXSLT(orig_msg, SEC_EXT_RESP_XSL);

      private var result_obj = NULL;
      private var stat = ConvertToRSL(xml_rpc, result_obj);

      return result_obj;
   end;
   /* Направление запроса RS-Connect -> Абонент - end */

   /* Направление запроса Абонент -> RS-Connect - begin */
   /* Метод преобразования сообщения запроса сервиса RS-Connect */
   macro sec_internal_req(orig_msg)
      private var xml_rpc = ApplyXSLT(orig_msg, SEC_INT_REQ_XSL);

      private var result_obj = NULL;
      private var stat = ConvertToRSL(xml_rpc, result_obj);

      return result_obj;
   end;

   /* Метод преобразования сообщения ответа сервиса RS-Connect */
   macro sec_internal_resp(rsl_obj)
      private var xml_rpc;
      private var stat = ConvertToXML(rsl_obj, "", xml_rpc);

      private var result_msg = ApplyXSLT(xml_rpc, SEC_INT_RESP_XSL);

      return result_msg;
   end;
   /* Направление запроса Абонент -> RS-Connect - end */

   /*--------------------------------------------------------------------------------------*/
   /* Вспомогательная функция при проверке наличия root_ns_alias в списке пространств имен */
   /*--------------------------------------------------------------------------------------*/
   private macro check_alias_in_list(p_is_root_ns,
                                     p_ns_list,
                                     p_root_ns_alias,
                                     p_root_ns_in_list)
      private var ret = false;

      if(not p_root_ns_in_list)
         if(p_is_root_ns)
            if(index(p_ns_list, string("xmlns:", p_root_ns_alias, "=")) != 0)
               ret = true;
            end;
         end;

      else
         ret = true;
      end;

      return ret;
   end; /* private macro check_alias_in_list() */

   /*-----------------------------------------------*/
   /* Добавление пространства имен к исходным тегам */
   /*-----------------------------------------------*/
   private macro add_ns_to_msg(p_src_msg, p_root_ns_alias)
      private var ret;

      private var pos_a = index(p_src_msg, "<");
      private var pos_b = index(p_src_msg, ">");
      private var root_el_len = pos_b - (pos_a + 1);
      private var root_el_name = substr(p_src_msg, (pos_a + 1), root_el_len);
      private var src_len = strlen(p_src_msg);

      private var pos_s1 = pos_b;
      private var pos_s2;

      /* В конце строки могут быть лишние символы, которые входят в длину */
      while((src_len - pos_s1) > root_el_len)
         pos_s2 = index(p_src_msg, root_el_name, pos_s1);
         if(pos_s2 != 0)
            pos_s1 = pos_s2 + root_el_len;
            pos_b = pos_s2;
         else
            pos_s1 = src_len;
         end;
      end;
      private var main_msg_len = pos_b - (pos_a + 1);

      ret = string("<", p_root_ns_alias, ":",
                   substr(p_src_msg, (pos_a + 1), main_msg_len),
                   p_root_ns_alias, ":", root_el_name, ">");

      return ret;
   end; /* private macro add_ns_to_msg() */

   /*--------------------------------------------*/
   /* Функция, заключающая запрос в soap-обертку */
   /*--------------------------------------------*/
   macro sec_wrap_req_in_soap(src_msg, root_ns_alias, ns_list)

      private var ret = true;
      private var temp_msg;
      private var list_type = ValType(ns_list);
      private var root_ns_type = ValType(ns_list);
      private var is_root_ns = false;
      private var root_ns_in_list = false;
      private var list_cntr = 0;

      if(root_ns_type == V_STRING)
         if(strlen(root_ns_alias) != 0)
            is_root_ns = true;
         end;
      end;

      temp_msg = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"";

      if(list_type == V_STRING)
         root_ns_in_list = check_alias_in_list(is_root_ns,
                                                  ns_list,
                                                  root_ns_alias,
                                                  root_ns_in_list);
         temp_msg = temp_msg + string(" ", ns_list);

      elif(list_type == V_GENOBJ)
         while(list_cntr < ns_list.size)
            root_ns_in_list = check_alias_in_list(is_root_ns,
                                                  ns_list.value(list_cntr),
                                                  root_ns_alias,
                                                  root_ns_in_list);
            temp_msg = temp_msg + string(" ", ns_list.value(list_cntr));
         end;
      end;

      temp_msg = temp_msg + ">";
      temp_msg = temp_msg +    "<soapenv:Header/>";
      temp_msg = temp_msg +    "<soapenv:Body>";

      if(is_root_ns)
         temp_msg = temp_msg + add_ns_to_msg(src_msg, root_ns_alias);
      else
         temp_msg = temp_msg + src_msg;
      end;

      temp_msg = temp_msg +    "</soapenv:Body>";
      temp_msg = temp_msg + "</soapenv:Envelope>";

      result_msg = temp_msg;

      if(is_root_ns)
         if(not root_ns_in_list)
            service_msg = "Пространство имен сообщения не определено";
            ret = false;
         end;
      end;

      return ret;
   end; /* macro sec_wrap_req_in_soap() */

   /*---------------------------*/
   /* Получить чистое сообщение */
   /*---------------------------*/
   macro make_pure_msg_from_ifx(src_ifx)
      const border1 = "<IFX>";
      const border2 = "</IFX>";
      var ret = true;
      var pos1, pos2;
      var aux_buff;

      if(ValType(src_ifx) == V_STRING)
         /* Если вдруг символы '<' и '>' экранируются, то приводим строку к нормальному виду */
         aux_buff = StrSubst(src_ifx, "&lt;", "<");
         aux_buff = StrSubst(aux_buff, "&#60;", "<");
         aux_buff = StrSubst(aux_buff, "&gt;", ">");
         aux_buff = StrSubst(aux_buff, "&#62;", ">");

         pos1 = index(aux_buff, border1);
         pos2 = index(aux_buff, border2);

         if((pos1 == 0) or (pos2 == 0))
            service_msg = "Полученное сообщение не соответствует заданному формату";
            ret = false;
         else
            pure_msg = substr(aux_buff, (pos1 + strlen(border1)), (pos2 - pos1 - strlen(border1)));
         end;
         /* Удаление оставшихся частей секции CDATA */
         pure_msg = StrSubst(pure_msg, "]]]]>><![CDATA[", "");
         pure_msg = StrSubst(pure_msg, "]]]]><![CDATA[>", "");
         pure_msg = StrSubst(pure_msg, "<![CDATA[", "");
         pure_msg = StrSubst(pure_msg, "]]>", "");

      else
         service_msg = "Тип данных не соответствует ожидаемому";
         ret = false;
      end;

      return ret;

   onError(err)
      ret = false;
      service_msg = string("При получении чистого сообщения возникла ошибка: ",
                           uTryToGetPropS(err, "message"));

      return ret;
   end; /* macro make_pure_msg_from_ifx() */
end; /* class psb_msg_converter_sec() */


/*-------------------------------------*/
/* Общий класс вызова внешнего сервиса */
/*-------------------------------------*/
class c_serviceProcessor_sec()
   var service_logger; /* Переменная для объекта логирования сообщений веб-сервиса */
   private var service_msg = "";
   private var service_code = "";

   private var req_id    = NULL;
   private var req_obj   = NULL;
   private var req_msg   = NULL;
   private var resp_msg  = NULL;
   private var pure_resp = NULL;
   private var resp_obj  = NULL;
   private var certificate_path = "";

   private var v_t_resolve = 30000;
   private var v_t_connect = 60000;
   private var v_t_send = 30000;
   private var v_t_receive = 60000;


   /* Метод задания текста сервисного сообщения */
   macro set_service_msg(in_serv_msg)
      service_msg = in_serv_msg;
   end;

   /* Метод получения текста сервисного сообщения */
   macro get_service_msg()
      return service_msg;
   end;

   /* Метод задания значения сервисного кода */
   macro set_service_code(in_serv_code)
      service_code = in_serv_code;
   end;

   /* Метод получения значения сервисного кода */
   macro get_service_code()
      private var ret;

      if(strlen(service_code) == 0)
         ret = UNIVERSAL_ERROR_CODE;
      else
         ret = service_code;
      end;

      return ret;
   end;

   /* Метод задания идентификатора зарпоса */
   macro set_req_id(in_req_id)
      req_id = in_req_id;
   end;

   /* Метод получения идентификатора запроса */
   macro get_req_id()
      private var ret;

      if(ValType(req_id) == V_UNDEF)
         ret = "";
      else
         ret = req_id;
      end;

      return ret;
   end;

   /* Метод задания объекта запроса */
   macro set_req_obj(in_req_obj)
      req_obj = in_req_obj;
   end;

   /* Метод получения объекта запроса */
   macro get_req_obj()
      return req_obj;
   end;

   /* Метод задания текста сообщения запроса */
   macro set_req_msg(in_req_msg)
      req_msg = in_req_msg;
   end;

   /* Метод получения текста сообщения запроса */
   macro get_req_msg()
      return req_msg;
   end;

   /* Метод задания текста ответного сообщения */
   macro set_resp_msg(in_resp_msg)
      resp_msg = in_resp_msg;
   end;

   /* Метод получения текста ответного сообщения */
   macro get_resp_msg()
      return resp_msg;
   end;

   /* Метод задания текста ответного сообщения без оберток */
   macro set_pure_resp(in_pure_resp)
      pure_resp = in_pure_resp;
   end;

   /* Метод получения текста ответного сообщения без оберток */
   macro get_pure_resp()
      return pure_resp;
   end;

   /* Метод задания объекта ответа */
   macro set_resp_obj(in_resp_obj)
      resp_obj = in_resp_obj;
   end;

   /* Метод получения объекта ответа */
   macro get_resp_obj()
      return resp_obj;
   end;

   /* Метод получения заданного пути к сертификату */
   macro get_cert_path()
      return certificate_path;
   end;

   /*---------------------------*/
   /* Задать путь к сертификату */
   /*---------------------------*/
   macro set_cert_path(reg_path)
      private var ret = true;
//      private var {oper};
      private var err_code = 0;
      private var reg_val;
      private var val_type = V_STRING;

      GetRegistryValue(reg_path, val_type, reg_val, err_code, null, {oper});

      if(err_code == 0)
         certificate_path = reg_val;
      else
         certificate_path = "";
      end;

      return ret;

   onError(err)
      ret = false;
      service_msg = string("При получении пути к сертификату возникла ошибка: ",
                           uTryToGetPropS(err, "message"));

      return ret;
   end; /* macro set_cert_path() */

   /*----------------------------------------------*/
   /* Метод получения сообщения запроса из объекта */
   /*----------------------------------------------*/
   macro make_req_msg(root_ns_alias, ns_list)
      private var ret = true;
      private var wrap_obj;

      req_msg = psb_msg_converter_sec.sec_external_req(req_obj);
      wrap_obj = psb_msg_converter_sec();

      if(wrap_obj.sec_wrap_req_in_soap(req_msg, root_ns_alias, ns_list))
         req_msg = wrap_obj.get_result_msg();
      else
         service_msg = req_msg.get_service_msg();
         ret = false;
      end;

      wrap_obj = null;

      return ret;

   onError(err)
      ret = false;
      service_msg = string("При формировании сообщения запроса возникла ошибка: ",
                           uTryToGetPropS(err, "message"));

      return ret;
   end; /* macro make_req_msg() */

   /*-----------------------------------------------*/
   /* Метод получения ответного XML-IFX без оберток */
   /*-----------------------------------------------*/
   private macro get_pure_response()
      const border1 = "<IFX>";
      const border2 = "</IFX>";
      var ret = true;
      var pos1, pos2;

      pos1 = index(resp_msg, border1);
      pos2 = index(resp_msg, border2);

      if((pos1 == 0) or (pos2 == 0))
         service_msg = "Полученный ответ не соответствует заданному формату";
         ret = false;
      else
         pure_resp = substr(resp_msg, (pos1 + strlen(border1)), (pos2 - pos1 - strlen(border1)));
      end;
      /* Удаление оставшихся частей секции CDATA */
      pure_resp = StrSubst(pure_resp, "]]]]>><![CDATA[", "");
      pure_resp = StrSubst(pure_resp, "]]]]><![CDATA[>", "");
      pure_resp = StrSubst(pure_resp, "<![CDATA[", "");
      pure_resp = StrSubst(pure_resp, "]]>", "");

      return ret;

   onError(err)
      ret = false;
      service_msg = string("При получении чистого ответа возникла ошибка: ",
                           uTryToGetPropS(err, "message"));

      return ret;
   end; /* macro get_pure_response() */

   /*-------------------------------------------------------*/
   /* Метод получения сообщения без экранированных символов */
   /*-------------------------------------------------------*/
   private macro get_native_markup_msg(mix_msg)
      var ret;

      ret = StrSubst(mix_msg, "&lt;", "<");
      ret = StrSubst(ret, "&#60;", "<");
      ret = StrSubst(ret, "&gt;", ">");
      ret = StrSubst(ret, "&#62;", ">");

      return ret;
   end;

   /*---------------------------------------------*/
   /* Метод получения объекта из сообщения ответа */
   /*---------------------------------------------*/
   macro make_resp_obj()
      var ret = true;

      if(get_pure_response())
         resp_obj = psb_msg_converter_sec.sec_external_resp(pure_resp);
      else
         ret = false;
      end;

      return ret;

   onError(err)
      ret = false;
      service_msg = string("В процессе преобразования ответа возникла ошибка: ",
                           uTryToGetPropS(err, "message"));

      return ret;
   end; /* macro make_resp_obj() */

   /*------------------------*/
   /* Получить значение тега */
   /*------------------------*/
   private macro get_teg_value(part_msg)
      var ret;
      var start_pos;
      var end_pos;

      start_pos = index(part_msg, ">") + 1;
      end_pos = index(part_msg, "</");

      if(end_pos > start_pos)
         ret = substr(part_msg, start_pos, (end_pos - start_pos));
      else
         ret = "";
      end;

      return ret;
   end; /* macro get_teg_value() */

   /*---------------------------------------------------------------*/
   /* Проверка принадлежности типа сообщения к сообщениям об ошибке */
   /*---------------------------------------------------------------*/
   private macro check_out_error_msg(out_msg)
      var ret = false;
      var str_pos_prev;
      var str_pos_cur;
      var err_code, err_text;

      str_pos_cur = index(out_msg, "ault");
      if(str_pos_cur != 0)
         str_pos_prev = str_pos_cur;
         str_pos_cur = index(out_msg, "faultcode", str_pos_prev);

         if(str_pos_cur != 0)
            err_code = get_teg_value(substr(out_msg, str_pos_cur));

            str_pos_prev = str_pos_cur;
            str_pos_cur = index(out_msg, "faultstring", str_pos_prev);

            if(str_pos_cur != 0)
               err_text = get_teg_value(substr(out_msg, str_pos_cur));

               /* Сообщение с ошибкой подтверждено - определяем параметры */
               service_msg = err_code;
               service_code = err_text;
               service_logger.add_error_info(service_code, service_msg); /* 3/3 лога */

               ret = true;
            end;
         end;
      end;

      return ret;
   end; /* macro check_out_error_msg() */

   /*------------------------------*/
   /* Установка значений таймаутов */
   /*------------------------------*/
   macro set_timeouts(p_t_resolve, p_t_connect, p_t_send, p_t_receive)
      if(ValType(p_t_resolve) != V_UNDEF)
         v_t_resolve = p_t_resolve;
      end;
      if(ValType(p_t_connect) != V_UNDEF)
         v_t_connect = p_t_connect;
      end;
      if(ValType(p_t_send) != V_UNDEF)
         v_t_send = p_t_send;
      end;
      if(ValType(p_t_receive) != V_UNDEF)
         v_t_receive = p_t_receive;
      end;
   end;

   /*------------------------------------------------------------------*/
   /* Метод вызова внешнего web-сервиса посредством WinHttpRequest.5.1 */
   /*------------------------------------------------------------------*/
/*   macro uCallExtServiceViaWinHttp(p_url_str, p_macro_name, p_module_name, p_host, p_soap_action)
      var ret = true;
      var aux_buff;
      var resp_xml_soap;
      var resp_xml;
      var v_module_name, v_host, v_soap_action;

      var http_req = external_ws_caller();

      if(ValType(p_module_name) != V_UNDEF)
         v_module_name = p_module_name;
      else
         v_module_name = "Securities";
      end;

      if(ValType(p_host) != V_UNDEF)
         v_host = p_host;
      else
         v_host = "xid.psbnk.msk.ru:51000";
      end;

      if(ValType(p_soap_action) != V_UNDEF)
         v_soap_action = p_soap_action;
      else
         v_soap_action = "\"http://sap.com/xi/WebService/soap1.1\""
      end;

      service_logger = uws_exchng_logger(NULL, req_id, XmlRpcRequestId(), v_module_name, p_macro_name, NULL, req_msg); /* 1/3 лога */

      http_req.server_url = p_url_str;

      http_req.timeout_resolve = v_t_resolve;
      http_req.timeout_connect = v_t_connect;
      http_req.timeout_send    = v_t_send;
      http_req.timeout_receive = v_t_receive;

//      http_req.add_http_header("Accept-Encoding", "gzip,deflate");
      http_req.add_http_header("Content-Type", "text/xml;charset=UTF-8");
//      http_req.add_http_header("SOAPAction", "\"http://tempuri.org/XMLRPCCall\"");
//      http_req.add_http_header("SOAPAction", "\"http://rsbank.softlab.ru/XMLRPCCall\"");
      http_req.add_http_header("SOAPAction", v_soap_action);
      http_req.add_http_header("Host", v_host);

      http_req.set_option_value(4, 13056);

      /* Если есть путь к сертификату - используем сертификат */
      if(strlen(certificate_path) != 0)
         http_req.client_https_certificate = certificate_path;
      end;

      if(http_req.submit_request(req_msg))
         /* Success! */
         /* resp_xml_soap = http_req.get_response_text(); */
         /* Если вдруг символы '<' и '>' экранируются, то приводим строку к нормальному виду */
         resp_xml_soap = get_native_markup_msg(http_req.get_response_text());

         resp_msg = resp_xml_soap;

         service_logger.add_response(resp_msg); /* 2/3 лога */
      else
         /* Error! */
         resp_xml_soap = get_native_markup_msg(http_req.get_response_text());

         resp_msg = resp_xml_soap;

         service_logger.add_response(resp_msg,
                                     string(http_req.get_return_code()),
                                     string(http_req.get_return_code(), " (", http_req.get_status_text(), ")", ": ", http_req.get_service_msg())); /* 2/3 лога */
         set_service_msg(string(http_req.get_return_code(), " (", http_req.get_status_text(), ")", ": ", http_req.get_service_msg()));
         ret = false;
      end;

      if(ret)
         if(check_out_error_msg(resp_msg))
            ret = false;
         end;
      end;

      service_logger = null;

      return ret;

   onError(err)
      ret = false;
      service_msg = string("В сеансе вызова сервиса возникла ошибка: ",
                           uTryToGetPropS(err, "message"));

      return ret;
   end; /* macro uCallExtServiceViaWinHttp() */
*/

end; /* class c_serviceProcessor_sec() */