/**
 @file dbo_qi_RejectionNotification.mac
 @brief Функционал отправки уведомления об отказе признания лица квалифицированным инвестором.
 
 Файл содержит функционал для формирования уведомления об отказе признания лица
 квалифицированным инвестором и его отправки по e-mail.
 
  # tag
 - functional_block:Отчетность_Клиент
 - code_type:API
 - code_type:Report
 - Квалификация
 - КИ
 - Квалифицированный инвестор
 
  # changeLog
 |date       |author       |tasks                                                     |note                                                        
 |-----------|-------------|----------------------------------------------------------|-------------------------------------------------------------
 |01.11.2023 |Топорков Д.В.|BIQ-16875 BOSS-194 BOSS-1286                              | Создание
 */
 
import rsd;
import "dbo_qi_func.mac"; // CSigner, CClient
import "dlcnst.inc";
import "logger.mac";
import "dlutils.mac";
import "dlwreps.mac";

private const NOTIFICATION_NAME = "899-ОД-1-6"; ///< Наименование бланка уведомления/имя шаблона
private const QIREJECTION_DEFAULT_REASON = "В соответствии с п. 4.4. Регламента принятия решения о признании лица квалифицированным инвестором в АО \"Россельхозбанк\"."; ///< Причина отказа по умолчанию
/// Константы содержимого для e-mail
private const QIREJECTION_EMAIL_SUBJECT = "Уведомление об отказе в присвоении статуса Квалифицированный инвестор";
private const QIREJECTION_EMAIL_BODY = 
  "Добрый день!\n" +
  "\n" +
  "В соответствии с условиями Регламента принятия решения о признании лица квалифицированным инвестором в АО \x22Россельхозбанк\x22 " +
  "направляем Вам Уведомление об отказе включения в Реестр квалифицированных инвесторов/ об исключении из Реестра квалифицированных инвесторов  АО \x22Россельхозбанк\x22.\n" +
  "\n";

var logger;

/**
@brief Класс с параметрами уведомлений по отказу в статусе КИ
*/
class (CQINotificationParams) CQIRejectionParams()
  var reason: String;      ///< Причина отказа
  
  /**
  @brief Процедура начальной инициализации класса
  */
  private macro InitRejection()
    reason = QIREJECTION_DEFAULT_REASON;
  end;
  //--- конструктор ---
  InitCQINotificationParams();
  InitRejection();
end; // CQIRejectionParams

/**
@brief Функция выбора значения в зависимости от условия
@param[in] condition Условие для выбора (true/false !0/0)
@param[in] valueTrue Значение которое вернет функция при condition = true (тип Variant)
@param[in] valueFalse Значение которое вернет функция при condition = false (тип Variant)
@return valueTrue при condition=true, valueFalse при condition=false (тип Variant)
*/
private macro IIF(condition, resultOnTrue, resultOnFalse)
   if (condition)
      return resultOnTrue;
   else
      return resultOnFalse;
   end;
end;

/**
@brief Функция записи сообщения в логгер
@param[in] msg - Сообщение
@param[in] logType - Тип сообщения (если не указано, то будет интерпритировано как LOGTYPE_INFO
@return Переданное значение msg
*/
private macro LogMessage(msg, logType)
  logger.log(msg, logType);
  return msg;
end;

/**
@brief Процедура записи в логгер параметров Уведомления об отказе
@param[in] rejectionParams Параметры уведомления об отказе
*/
private macro LogQIRejectionParams(rejectionParams: CQIRejectionParams)
  LogMessage("Формирование уведомления для клиента " + rejectionParams.client.shortName + ", договор №" + rejectionParams.client.contractNumber);
  LogMessage("Дата : " + rejectionParams.notificationDate);
  LogMessage("Причина : " + rejectionParams.reason);
  LogMessage("Подписант : " + rejectionParams.signer.oper + ", " + rejectionParams.signer.name + ", " + rejectionParams.signer.post);
end;

/**
@brief Функция проверки параметров Уведомления об отказе
@param[in] rejectionParams Параметры уведомления об отказе
@param[out] error Текст ошибки
@return true В случае корректных параметров
@return false Параметры некорректны (см. error)
*/
private macro CheckQIRejectionConditions(rejectionParams: CQIRejectionParams, storage: CStorageInfo, error: @String): Bool
  error = "";
  /// Общие проверки
  if (StrLen(error) == 0)
    if ((ValType(rejectionParams.dlContrID) == V_UNDEF) or (rejectionParams.dlContrID <= 0))
      error = "Не задан договор обслуживания";
    elif ((ValType(rejectionParams.client) == V_UNDEF) or (ValType(rejectionParams.client.emails) == V_UNDEF) or (rejectionParams.client.emails.size == 0))
      error = "У клиента отсутствует электронная почта для рассылки";
    elif ((ValType(rejectionParams.notificationDate) == V_UNDEF) or (rejectionParams.notificationDate == date(0,0,0)))
      error = "Не задана дата отказа";
    elif ((ValType(rejectionParams.reason) == V_UNDEF) or (StrLen(rejectionParams.reason) == 0))
      error = "Не задана причина отказа";
    elif ((ValType(rejectionParams.signer) == V_UNDEF) or (rejectionParams.signer.oper <= 0))
      error = "Не заданы системные настройки процесса: Подписант по умолчанию";
    elif (StrLen(storage.GetDirectory(RESULTTAG).path) <= 1)
      error = "Не заданы системные настройки процесса: Директория";
    end;
  end;
  /// Проверки подписанта
  if (StrLen(error) == 0)
    if ((ValType(rejectionParams.signer.post) != V_STRING) or (StrLen(rejectionParams.signer.post) == 0))
      error = "Не заполнена должность подписанта";
    elif ((ValType(rejectionParams.signer.signStampImageID) != V_INTEGER) or (rejectionParams.signer.signStampImageID == 0))
      error = "Отсутствует изображение подписи подписанта";
    end;
  end;
  /// Проверка наличия договора в реестре квалифицированных инвесторов
  if (StrLen(error) == 0)
    var sql;

    if(not GetRegValueSwitchQI()) //NEW PARAM
      sql = "SELECT * FROM dScQinv_dbt WHERE t_sfContrID = (SELECT t_sfContrID FROM dDlContr_dbt WHERE t_dlContrID = " + rejectionParams.dlContrID + ") ORDER BY t_regDate DESC";
    else
      sql = "SELECT * FROM dScQinv_dbt WHERE t_partyid = " + rejectionParams.client.partyid + " ORDER BY t_regDate DESC";
    end;

    var qInvRec = TRsbDataSet(sql);

    if(not GetRegValueSwitchQI()) //NEW PARAM
      /// Если записи нет, то можно дальше работать, иначе проверка
      if (qInvRec.MoveNext()) // интересует только первая запись (с максимальной t_regDate)
        if (qInvRec.state == 1)
          error = "Договор включен в реестр КИ";
        elif (qInvRec.state > 0)
          error = "Неизвестный статус договора в реестре квалифицированных инвесторов";
        end;
      end;
    else
        /// Если записи нет, то можно дальше работать, иначе проверка
      if (qInvRec.MoveNext()) // интересует только первая запись (с максимальной t_regDate)
        if (qInvRec.state == 1)
          error = "Клиент по договору включен в реестр КИ";
        elif (qInvRec.state > 0)
          error = "Неизвестный статус клиента в реестре квалифицированных инвесторов";
        end;
      end;
    end;
  end;

  if (StrLen(error) > 0)
    return false;
  end;

  return true;
end;

/**
@brief Функция получения объекта класса CStorageInfo (данные об используемых директориях и файлах в них)
@param[in] rejectionParams Параметры уведомления об отказе
@return Настроенный объекта класса CStorageInfo

# Предполагается следующее использование директорий:
- WORKTAG   Директория WorkFile сервера приложений (установлена в конструкторе CStorageInfo)
- RESULTTAG Директория для итогового хранения файлов согласно настроек банка (либо значение установленное в конструкторе CStorageInfo)
- TXTTAG    Директория TxtFile сервера приложений (установлена в конструкторе CStorageInfo)
# Предполагается следующее использование файлов:
- WORKTAG/WORKTAG     Временный файл данных отчета для заполнения шаблона
- WORKTAG/SIGNTAG     Временный файл изображение подписи и печати для вставки в Уведомление
- RESULTTAG/RESULTTAG Файл уведомления в формате DOC (не формируется)
- RESULTTAG/PDFTAG    Файл уведомления в формате PDF
- TXTTAG/LOGTAG       Файл для записи лога (возможно удаляется в случае отсутствия ошибок)
*/
private macro GetQIStorageInfo(rejectionParams: CQIRejectionParams): CStorageInfo
  var fileTag: String = "Уведомление_квал_инвест_";
  var cleanClientName: String = CleanStringForFilename(rejectionParams.client.shortName);
  if ((ValType(rejectionParams) != V_UNDEF) and (ValType(rejectionParams.client) != V_UNDEF) and (ValType(rejectionParams.client.shortName) == V_STRING))
    fileTag = fileTag + cleanClientName;
  end;
  
  var storageInfo: CStorageInfo = CStorageInfo(fileTag);
  var errCode: Integer;
  var targetDirectory: String;
    
   /// Если задана настройка директории сохранения файлов, то установим ее в RESULTTAG
   GetRegistryValue(QI_REGISTRY_DIRECTORY, V_STRING, targetDirectory, errCode);
   if ((errCode == 0) and (ValType(targetDirectory) == V_STRING))
     targetDirectory = Trim(targetDirectory);
     if (StrLen(targetDirectory) > 0)
       storageInfo.AddDirectory(RESULTTAG, NormalizePath(targetDirectory, false), false);
     else
       LogMessage("Не задана настройка " + QI_REGISTRY_DIRECTORY);
       storageInfo.AddDirectory(RESULTTAG, "", false);
     end;
   end;
  
  /// Переопределим имена файлов с меткой RESULTTAG в директории RESULTTAG
  var resultFileName: String = "Уведомление об отказе в признании лица квалифицированным инвестором " + StrSubst(cleanClientName, "_", " ");
  
  SplitFile(GetUnexistedFileName(toANSI(storageInfo.GetDirectory(RESULTTAG).Path + resultFileName + ".pdf")), resultFileName); // т.к. целевой pdf, то ориентируемся на него
  storageInfo.AddFile(RESULTTAG, RESULTTAG, resultFileName, "doc", false);
  storageInfo.AddFile(RESULTTAG, PDFTAG, resultFileName, "pdf", false);
  /// Добавим информацию для файла логирования
  storageInfo.AddFile(TXTTAG, LOGTAG, "QiRejection_" + GetDateTimeMark(Date(), Time()) + "_" + String(Random(999)), "txt", false);
  return storageInfo;
end;

/**
@brief Процедура создания файла уведомления 
@param[in] rejectionParams Параметры уведомления об отказе
@param[in] storage Данные об используемых директориях/файлах
@param[out] error Текст ошибки
@return True в случае успешного создания файла уведомления, false в случае ошибки
*/
private macro CreateQIRejectionNotification(rejectionParams: CQIRejectionParams, storage: CStorageInfo, error: @String): Bool
  var textReader: CTextReader = CTextReader(rejectionParams.reason);
  var i=0;
  var deltaRowsPrinted = 0; 
  var RealFileName = ""; 
  var fTxt, fNameTxtMess = "", pdfName = "";
  var tplName = NOTIFICATION_NAME + ".dotx"; //FindTemplate(NOTIFICATION_NAME + ".dotx");
  fNameTxtMess = storage.FilePath(TXTTAG, TXTTAG);
  
  //Пустные строки в шаболне нужня для того чтобы обрамлять строки с подчеркиванием
  //Так экранируется, в PDF, перенос подчеркивания на другие строки
  //После заполнения строки с закладкой, ненужные пустые строки удаляются макросом
  
  fTxt = TStreamDoc(fNameTxtMess, "C", "rsoem ", 1/*unix*/);
  if ( ValType(fTxt) != V_UNDEF )
  else
    error = "Текстовый файл вывода не открыт " + fNameTxtMess;
    return false;
  end;

  fTxt.WriteLine(tplName);     //Шаблон dotx
  fTxt.WriteLine(SubStr(tplName, 1, index(tplName, ".dot")-1) + "_" + String(rejectionParams.client.partyID));   //Файл docx

  fTxt.WriteLine("~Client");
  fTxt.WriteLine(IIF(rejectionParams.client.legalForm == PTLEGF_PERSN, 
                                          rejectionParams.client.fullName, rejectionParams.client.shortName));

  fTxt.WriteLine("~IsExclusion");
  fTxt.WriteLine("[X]"); // StrFor(82) Символ [V] шрифта Wingdings 2 //StrFor(251) Символ [V] шрифта Dejavu

  fTxt.WriteLine("~IsFull");
  fTxt.WriteLine("[  ]"); 

  fTxt.WriteLine("~IsPartly");
  fTxt.WriteLine("[  ]"); 

  fTxt.WriteLine("~IsType");
  fTxt.WriteLine("[  ]"); 

  fTxt.WriteLine("~Reason_2");
  fTxt.WriteLine(textReader.ReadLine(25));

  i = 0;
  if (NOT textReader.HasNext() )
    fTxt.WriteLine("~DeleteRows");
    fTxt.WriteLine(string(2)); //Номер таблицы
    fTxt.WriteLine("%");
    fTxt.WriteLine(String(2 + deltaRowsPrinted)); //номер первой удаляемой строки
    fTxt.WriteLine(String(4 + deltaRowsPrinted)); //номер последней удаляемой строки
    deltaRowsPrinted = deltaRowsPrinted - 3;
  else
    While (textReader.HasNext())
      if (i == 0)
        fTxt.WriteLine("~Reason_2_1");
        fTxt.WriteLine(textReader.ReadLine(83));
        i=i+1;

        //удаляем пустые строки
        fTxt.WriteLine("~DeleteRows");
        fTxt.WriteLine(string(2)); //Номер таблицы
        fTxt.WriteLine("%");
        fTxt.WriteLine(String(2+deltaRowsPrinted)); //номер первой удаляемой строки
        fTxt.WriteLine(String(3+deltaRowsPrinted)); //номер последней удаляемой строки
        deltaRowsPrinted = deltaRowsPrinted - 2;
      else
      
        fTxt.WriteLine("~MultipleRow");  /*добавляем строку таблицы*/
        fTxt.WriteLine(string(2));/*идентификатор таблицы*/      
        fTxt.WriteLine(String(1));                              /*необходимое количество строк*/
        fTxt.WriteLine("");                                     /*закладка для таблицы*/
        fTxt.WriteLine(String(4+deltaRowsPrinted));             /*номер ряда, который необходимо размножить*/
 
        fTxt.WriteLine("~Reason_2_"+String(1+i)); //1 начальное значение
        fTxt.WriteLine(textReader.ReadLine(83)); 
          
        i = i + 1;
        deltaRowsPrinted = deltaRowsPrinted + 1;
      end;
    end;
  end; 

   //удаляем пустые строки
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(2)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(5+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(5+deltaRowsPrinted)); //номер последней удаляемой строки
  deltaRowsPrinted = deltaRowsPrinted - 1;


  fTxt.WriteLine("~ClientBody");
  fTxt.WriteLine("");

   //удаляем пустые строки до
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(2)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(8+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(9+deltaRowsPrinted)); //номер последней удаляемой строки
  deltaRowsPrinted = deltaRowsPrinted - 2;

   //удаляем пустые строки после
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(2)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(11+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(11+deltaRowsPrinted)); //номер последней удаляемой строки
  deltaRowsPrinted = deltaRowsPrinted - 1;

  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(2)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(24+deltaRowsPrinted)); //номер первой удаляемой строки
  fTxt.WriteLine(String(24+deltaRowsPrinted)); //номер последней удаляемой строки
  deltaRowsPrinted = deltaRowsPrinted - 1;


  fTxt.WriteLine("~Post");
  fTxt.WriteLine(rejectionParams.signer.post);

  fTxt.WriteLine("~InsertImage");
//  fTxt.WriteLine("Sign#"+storage.FilePath(WORKTAG, SIGNTAG)); //Имя_закладки#Полный путь к файлу с картинкой 
  fTxt.WriteLine("Sign#"+storage.FilePath(WORKTAG, SIGNTAG)+"#154#142"); //Имя_закладки#Полный путь к файлу с картинкой#258#238 //60%

  fTxt.WriteLine("~SignerName");
  fTxt.WriteLine(rejectionParams.signer.name);

  fTxt.WriteLine("~Date");
  fTxt.WriteLine(String(rejectionParams.notificationDate:f));

   //удаляем пустые строки в подписях
  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(3)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(3+1)); //номер первой удаляемой строки
  fTxt.WriteLine(String(3+1)); //номер последней удаляемой строки

  fTxt.WriteLine("~DeleteRows");
  fTxt.WriteLine(string(3)); //Номер таблицы
  fTxt.WriteLine("%");
  fTxt.WriteLine(String(7+1-1)); //номер первой удаляемой строки
  fTxt.WriteLine(String(7+1-1)); //номер последней удаляемой строки

  //эмуляция метода close
  fTxt = TStreamDoc(fNameTxtMess, "R", "rsoem ", 1/*unix*/);

  pdfName = SubStr(fNameTxtMess, 1, index(fNameTxtMess, ".")-1) + ".pdf";

  //Вызов функции из dlwreps.mac 
  DLWREPS_PrintReportFromTagFile( fNameTxtMess, @RealFileName, Null/*CloseDoc*/, True/*SaveDocTwice*/ , Null/*UsePoiMode*/, pdfName/*FileNamePDF*/, Null/*FileNameHTML*/, False/*ShowDoc*/);
 
  if (not CopyFile(pdfName, storage.FilePath(RESULTTAG, PDFTAG), True /*Индикатор*/, "Копируем файл для отправки"))
    error = "Не удалось скопировать файл " + pdfName + " в директорию " + string(storage.FilePath(RESULTTAG, PDFTAG));
  else
     //MsgBox("Успешно скопирован файл из "+pdfName+" в директорию "+ string(storage.FilePath(RESULTTAG, PDFTAG));
  end;            

  //exclusionParams.resultFileName = RealFileName;

  DelFile(fNameTxtMess);
  DelFile(pdfName);
  
  return StrLen(error) == 0;
    
onError(err)
  error = LogMessage("Ошибка выполнения:|" + err.Module + " строка " + err.Line + "|" + err.message, LOGTYPE_ERROR);
  
  return false;
end;

/**
@brief Функция создания сообщения для ДБО с прикрепленным файлом уведомления
@param[in] rejectionParams Параметры уведомления об отказе
@param[in] storage Данные об используемых директориях/файлах
@param[out] error Текст ошибки
@return Индекс записи в таблице dDlContrMsg_dbt
@return null В случае ошибки записи

Предполагается, что файл уведомления RESULTTAG/PDFTAG уже создан
*/
private macro CreateQIRejectionDBOMessage(rejectionParams: CQIRejectionParams, storage: CStorageInfo, error: @String)
  var dlContrMsg = Tbfile("dlcontrmsg.dbt", "W", 0);
  
  dlContrMsg.clear();
  dlContrMsg.rec.DlContrID = rejectionParams.dlContrID;
  dlContrMsg.rec.Kind = REJECTION_QI;
  dlContrMsg.rec.CreateDate = Date();
  dlContrMsg.rec.CreateTime = Time();
  dlContrMsg.rec.SendDate = Date(0,0,0);
  dlContrMsg.rec.SendTime = Time(0,0,0);
  dlContrMsg.rec.IsOnlineSendMes = UNSET_CHAR;
  dlContrMsg.rec.MarketID = -1;
  dlContrMsg.rec.SendMesState = 0;
  if(not dlContrMsg.insert())
    return 0;
  end;
  
  LogMessage("Создано сообщение к ДБО с ID = " + dlContrMsg.rec.ID);
  
  if((not LoadImageObj(storage.FilePath(RESULTTAG, PDFTAG), OBJTYPE_BSCMSG_DL, UniID(dlContrMsg, OBJTYPE_BSCMSG_DL), 1)) and (ValType(error) == V_STRING))
    error = IIF(StrLen(error) > 0, error + "|", "") + "К записи о сообщении ДБО не удалось прикрепить файл сообщения";
  end;
  
  return dlContrMsg.rec.ID;
end;

/**
@brief Процедура отправки e-mail
@param[in] rejectionParams Параметры уведомления об отказе
@param[in] storage Данные об используемых директориях/файлах
@param[out] error Текст ошибки

Предполагается, что файл уведомления RESULTTAG/PDFTAG уже создан
*/
private macro SendQIRejectionEmail(rejectionParams: CQIRejectionParams, storage: CStorageInfo, error: @String)
  var emailProcessor = c_email_proc_env();
  var isLegalPerson: Bool = rejectionParams.client.legalForm == PTLEGF_INST;
  var registryPath: String = GetHiddenRecipientsRegistryPath(isLegalPerson);
  var hiddenRecipients: TArray = GetHiddenRecipients(registryPath);
  
  if (hiddenRecipients.size == 0)
    error = "Не заданы системные настройки процесса: Направлять скрытую копию по " + IIF(isLegalPerson, "ЮЛ", "ФЛ");
    return;
  end;

  /// Формируем письмо
  RunProcByParamArray(R2M(emailProcessor, "m_add_email_to_list"), rejectionParams.client.emails); ///< Список получателей
  RunProcByParamArray(R2M(emailProcessor, "m_add_email_to_bcc_list"), hiddenRecipients);          ///< Список получателей скрытой копии
  
  if(not GetRegValueSwitchQI())//NEW PARAM
    emailProcessor.m_set_msg_head(QIREJECTION_EMAIL_SUBJECT + " " + rejectionParams.client.shortName + " " + rejectionParams.client.contractNumber); ///< Тема письма
  else
    emailProcessor.m_set_msg_head(QIREJECTION_EMAIL_SUBJECT + " " + rejectionParams.client.shortName); ///< Тема письма
  end;
  emailProcessor.m_add_row_to_msg_text(QIREJECTION_EMAIL_BODY);                                   ///< Текст 
  emailProcessor.m_add_attach_to_list(storage.FilePath(RESULTTAG, PDFTAG));                       ///< Прикрепленный файл

  /// Сохраняем для отправки плановой процедурой 
  emailProcessor.m_save_to_submit_synch();
  /// Отправляем
  emailProcessor.m_submit_email_synch();

  if(emailProcessor.m_get_error_status())
    if (ValType(error) == V_STRING)
      error = IIF(StrLen(error) > 0, error + "|", "") + "Сообщение сформировано, но не отправлено: " + emailProcessor.get_service_msg();
    end;
  else
    LogMessage("Письмо отправлено");
  end;
end;

/**
@brief Процедура отправки данных в IPS Фабрику документов для формирования уведомления
@param[in] rejectionParams Параметры уведомления о признании
*/
private macro QIRejectionNotifyIPS(rejectionParams: CQIRejectionParams)
  var error: String = ""; // Возможную ошибку пока игнорируем
  
  /// Только для ЮЛ и ИП
  if ((rejectionParams.client.legalForm == PTLEGF_INST) or IsIndividualEmployer(rejectionParams.client.partyID))
    var errorCode = QINotifyIPS(rejectionParams.client.partyId, REJECTION_QI, rejectionParams.notificationDate, rejectionParams.signer.oper, rejectionParams.reason, null, @error);
    
    if (errorCode != 0)
      LogMessage("Ошибка формирования уведомления через Фабрику документов (IPS): " + error, LOGTYPE_ERROR);
    end;
  end;
end;

/**
@brief Функция формирования и отправки Уведомления об отказе в признании квалифицированным инвестором
@param[in] rejectionParams Параметры уведомления об отказе
@return V_STRING Текст ошибки
*/
macro QIRejectionNotification(rejectionParams: CQIRejectionParams): String
  logger = CTxtLogger();
  
  var storage: CStorageInfo = GetQIStorageInfo(rejectionParams);
  var error: String = "";

  logger.InitFile(storage.FilePath(TXTTAG, LOGTAG));
  LogQIRejectionParams(rejectionParams);
  
  /// Проверка параметров операции
  if (not CheckQIRejectionConditions(rejectionParams, storage, @error))
    return LogMessage("Ошибка проверки параметров:|" + error, LOGTYPE_ERROR);
  end;
  
  /// Отправка данных для создания уведомления через Фабрику документов (IPS)
  QIRejectionNotifyIPS(rejectionParams);
  
  if (ImageUpload(storage, rejectionParams.signer.signStampImageID, @error))
    LogMessage("Создан файл подписи " + storage.FilePath(WORKTAG, SIGNTAG));
  else
    return LogMessage("Ошибка при загрузке файла подписи (id = " + rejectionParams.signer.signStampImageID + ") " + error, LOGTYPE_ERROR);
  end;

  /// формирование файла уведомления
  if (not CreateQIRejectionNotification(rejectionParams, storage, @error))
    return LogMessage("Ошибка формирования файла уведомления " + error);
  end;
  LogMessage("Сформирован файл PDF " + storage.FilePath(RESULTTAG, PDFTAG));
  
  /// Создание сообщения dDlContrMsg
  var dlContrMsgID: Integer = CreateQIRejectionDBOMessage(rejectionParams, storage, @error);
  
  /// Отправка e-mail
  var errLength = StrLen(error);
  SendQIRejectionEmail(rejectionParams, storage, @error);
  
  if ((errLength == StrLen(error)) and (dlContrMsgID > 0)) // При отправке не добавилось ошибок и сообщение на договоре было сохранено
    // Обновим дату отправки сообщения
    ExecSql("UPDATE dDlContrMsg_dbt SET t_sendDate = ?, t_sendTime = ? WHERE t_ID = ? ", makeArray(SQLParam("", Date()), SQLParam("", Time()), SQLParam("", dlContrMsgID)));
  end;
  
  if (StrLen(error) > 0)
    LogMessage(error, LOGTYPE_ERROR);
  end;
  
  logger.close();
  /// Если нет ошибок, то отметим файл лога на удаление
  if ((logger.GetMessagesCount(LOGTYPE_WARNING) == 0) and (logger.GetMessagesCount(LOGTYPE_ERROR) == 0))
    storage.GetFile(TXTTAG, LOGTAG).IsTemporary = true;
  end;
  
  return error;
  
onError (err)
  error = LogMessage("Ошибка выполнения:|" + err.Module + " строка " + err.Line + "|" + err.message, LOGTYPE_ERROR);
  LogMessage(GetFullErrorMessage(err), LOGTYPE_ERROR);
  logger.close();
  
  return error;
end;