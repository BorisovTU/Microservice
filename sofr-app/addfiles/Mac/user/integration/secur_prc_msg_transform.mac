/*
$Name:        secur_prc_msg_transform.mac
$Module:      Интеграция с внешними системами
$Description: Инструментарий для поддержки взаимодействия систем
*/

/*-----------------------------------------------------------------*/
/* Author: Карпов В.                                               */
/*-----------------------------------------------------------------*/
import "global_prc_msg_transform.mac";

/* Методы преобразования транспортных сообщений */
class (c_com_msg_converter) c_secur_msg_converter()

   private const CV_SECUR_MSG_XSD_IN     = "..\\mac\\USER\\Integration\\xsl\\s_in_rs_secur_xml_schema.xsd";
   private const CV_SECUR_MSG_XSD_OUT    = "..\\mac\\USER\\Integration\\xsl\\s_out_rs_secur_xml_schema.xsd";
   private const CV_SECUR_EXT_REQ_XSL    = "..\\mac\\USER\\Integration\\xsl\\t_secur_xml_rpc_to_ifx.xsl";
   private const CV_SECUR_EXT_RESP_XSL   = "..\\mac\\USER\\Integration\\xsl\\t_secur_ifx_to_xml_rpc.xsl";
   private const CV_SECUR_INT_REQ_XSL    = "..\\mac\\USER\\Integration\\xsl\\t_secur_ifx_to_xml_rpc.xsl";
   private const CV_SECUR_INT_RESP_XSL   = "..\\mac\\USER\\Integration\\xsl\\t_secur_xml_rpc_to_ifx.xsl";
   private const CV_SECUR_IP_INT_REQ_XSL = "..\\mac\\USER\\Integration\\xsl\\t_secur_ip_ifx_to_xml_rpc.xsl";
   private const CV_SECUR_WOL_INT_REQ_XSL = "..\\mac\\USER\\Integration\\xsl\\t_secur_ifx_wol_to_xml_rpc.xsl";
   private const CV_SECUR_WOL_EXT_RESP_XSL = "..\\mac\\USER\\Integration\\xsl\\t_secur_ifx_wol_to_xml_rpc.xsl";

   private var vg_pure_msg = ""; /* "Чистое" сообщение */

   /* Получение текста "чистого" сообщения */
   macro get_pure_msg()
      return vg_pure_msg;
   end;

   /* Методы валидации сообщения - begin */
   /* В случае проблем возвращает текст, если все в порядке - NULL */
   macro m_secur_validate_xml_in(p_xml_string)
      private var v_ret = m_validate_xml(p_xml_string, CV_SECUR_MSG_XSD_IN);

      return v_ret;
   end;

   macro m_secur_validate_xml_out(p_xml_string)
      private var v_ret = m_validate_xml(p_xml_string, CV_SECUR_MSG_XSD_OUT);

      return v_ret;
   end;
   /* Методы валидации сообщения - end */

   /* Направление запроса RS -> Внешняя Система - begin */
   /* Метод преобразования сообщения запроса внешнего сервиса */
   macro m_secur_external_req(p_rsl_obj)
      private var v_ret = m_obj_to_msg(p_rsl_obj, CV_SECUR_EXT_REQ_XSL);

      return v_ret;
   end;

   /* Метод преобразования сообщения ответа внешнего сервиса () */
   macro m_secur_external_resp(p_orig_msg)
      private var v_ret = m_msg_to_obj(p_orig_msg, CV_SECUR_EXT_RESP_XSL);

      return v_ret;
   end;

   macro m_secur_wol_external_resp(p_orig_msg)
      private var v_ret = m_msg_to_obj(p_orig_msg, CV_SECUR_WOL_EXT_RESP_XSL);

      return v_ret;
   end;
   /* Направление запроса RS -> Внешняя Система - end */

   /* Направление запроса Внешняя Система -> RS - begin */
   /* Метод преобразования сообщения запроса сервиса RS */
   macro m_secur_internal_req(p_orig_msg)
      private var v_ret = m_msg_to_obj(p_orig_msg, CV_SECUR_INT_REQ_XSL);

      return v_ret;
   end;

   macro m_secur_wol_internal_req(p_orig_msg)
      private var v_ret = m_msg_to_obj(p_orig_msg, CV_SECUR_WOL_INT_REQ_XSL);

      return v_ret;
   end;

   /* Метод преобразования сообщения ответа сервиса RS */
   macro m_secur_internal_resp(p_rsl_obj)
      private var v_ret = m_obj_to_msg(p_rsl_obj, CV_SECUR_INT_RESP_XSL);

      return v_ret;
   end;
   /* Направление запроса Внешняя Система -> RS - end */

   /* Направление запроса ИП -> RS - begin */
   macro m_secur_ip_internal_req(p_orig_msg)
      private var v_ret = m_msg_to_obj(p_orig_msg, CV_SECUR_IP_INT_REQ_XSL);

      return v_ret;
   end;
   /* Направление запроса ИП -> RS - end */

   /*---------------------------------*/
   /* Заменить экранированные символы */
   /*---------------------------------*/
   macro m_decode_escaped_char(p_src_ifx)
      private var v_ret = true;
      private var v_aux_buff;

      if(ValType(p_src_ifx) == V_STRING)
         /* kva: Будем считать, что замена экранированных символов не требуется, если первый символ уже в нормальном виде */
         if(substr(p_src_ifx, 1, 1) == "&")
            /* Если вдруг символы '<' и '>' экранируются, то приводим строку к нормальному виду */
            v_aux_buff = StrSubst(p_src_ifx, "&lt;", "<");
            v_aux_buff = StrSubst(v_aux_buff, "&#60;", "<");
            v_aux_buff = StrSubst(v_aux_buff, "&gt;", ">");
            v_aux_buff = StrSubst(v_aux_buff, "&#62;", ">");

            /* Удаление оставшихся частей секции CDATA */
            v_aux_buff = StrSubst(v_aux_buff, "]]]]>><![CDATA[", "");
            v_aux_buff = StrSubst(v_aux_buff, "]]]]><![CDATA[>", "");
            v_aux_buff = StrSubst(v_aux_buff, "<![CDATA[", "");
            v_aux_buff = StrSubst(v_aux_buff, "]]>", "");

            vg_pure_msg = v_aux_buff;

         else
            vg_pure_msg = p_src_ifx; /* kva: Если замена не потребовалась - передаем сообщение как есть */
         end;

      else
         v_service_msg = "Тип данных не соответствует ожидаемому";
         v_ret = false;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      v_service_msg = string("При замене экранированных символов возникла ошибка: ",
                             c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_decode_escaped_char() */

   /*---------------------------*/
   /* Получить чистое сообщение */
   /*---------------------------*/
   macro m_make_pure_msg_from_ifx(p_src_ifx)
      private const CV_BORDER_1 = "<IFX>";
      private const CV_BORDER_2 = "</IFX>";
      private var v_ret = true;
      private var v_pos1, v_pos2;
      private var v_aux_buff;

      if(ValType(p_src_ifx) == V_STRING)
         v_aux_buff = p_src_ifx;
         v_pos1 = index(v_aux_buff, CV_BORDER_1);
         v_pos2 = index(v_aux_buff, CV_BORDER_2);

         if((v_pos1 == 0) or (v_pos2 == 0))
            v_service_msg = "Полученное сообщение не соответствует заданному формату";
            v_ret = false;
         else
            vg_pure_msg = substr(v_aux_buff, (v_pos1 + strlen(CV_BORDER_1)), (v_pos2 - v_pos1 - strlen(CV_BORDER_1)));
         end;

      else
         v_service_msg = "Тип данных не соответствует ожидаемому";
         v_ret = false;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      v_service_msg = string("При получении чистого сообщения возникла ошибка: ",
                             c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_make_pure_msg_from_ifx() */

   private macro m_remove_ns_from_xml(p_xml_string)
      const cv_beg = " xmlns";
      const cv_end = "\">";
      var v_ret;
      var v_beg_ind, v_end_ind;

      v_beg_ind = index(p_xml_string, cv_beg);
      v_end_ind = index(p_xml_string, cv_end, v_beg_ind);

      if((v_beg_ind != 0) and (v_end_ind != 0))
         v_ret = string(substr(p_xml_string, 1, (v_beg_ind - 1)),
                        substr(p_xml_string, (v_end_ind + 1)));
      else
         v_ret = p_xml_string;
      end;

      return v_ret;
   end;

   /* Валидация входящего сообщения по схеме входящих */
   /* ValType(ret) != V_UNDEF - ошибка */
   macro m_validate_in_xml(p_xml_string)
      var v_ret;
      var v_xml_string;

      v_xml_string = m_remove_ns_from_xml(p_xml_string);

      v_ret = m_validate_xml(v_xml_string, CV_SECUR_MSG_XSD_IN);

      return v_ret;
   end;

   /* Валидация исходящего сообщения по схеме исходящих */
   /* ValType(ret) != V_UNDEF - ошибка */
   macro m_validate_out_xml(p_xml_string)
      var v_ret;
      var v_xml_string;

      v_xml_string = m_remove_ns_from_xml(p_xml_string);

      v_ret = m_validate_xml(v_xml_string, CV_SECUR_MSG_XSD_OUT);

      return v_ret;
   end;

   Initc_com_msg_converter();
end; /* class (c_com_msg_converter) c_secur_msg_converter() */


/*-------------------------------*/
/* Класс вызова внешнего сервиса */
/*-------------------------------*/
class (c_com_ext_ws_processor) c_secur_ext_ws_processor(p_is_ws_policy_usrnametoken : bool)
   private var v_state = true; /* Статус */
   /* Предполагаем, что в ответе не будет экранированных символов */
   private const VC_IS_NATIVE_MARKUP = true;
   /* Название модуля, характерное для представленного функционала */
   private const VC_LOG_MODULE_NAME  = "SECUR";
   /* Тип журнала: 0 - не используется (не желательно!); 1 - используется "легкий" журнал; 2 - используется "подробный" журнал */
   private const VC_LOGGING_TYPE     = 2;
   /* Параметры для работы с сервисом */
   /* Параметры аутентификации: 0 - не используется; 1 - логин/пароль; 2 - сертификат; 3 - используется 1 и 2 */
   private const VC_AUTH_TYPE        = 0;
   /* Значение заголовка host для обращения к сервису */
   private const VC_HOST_VAL         = "10.18.121.18:1414";
   /* Значение заголовка SOAPAction для обращения к сервису */
   private const VC_SOAPACTION_VAL   = "\"http://systematica.ru/ModullarWebService/IModullarWebService/Run\"";
   /* Путь к сертификату в локальном хранилище */
   private const VC_CERT_PATH        = "";
   /* Логин, используемый для аутентификации */
   private const VC_AUTH_LOGIN       = "";
   /* Пароль, используемый для аутентификации */
   private const VC_AUTH_PWD         = "";
   /* Признак шифрования пароля в случае использования WS-Policy */
   private const VC_IS_PWD_ENCODE    = false;
   /* Признак использования WS-Policy UsernameToken в обертке SOAP */
   private var vg_is_ws_policy_usrnametoken = false; /* Значение по умолчанию */

   /*---------------------------------*/
   /* Метод получения признака ошибки */
   /*---------------------------------*/
   macro m_get_state()
      return v_state;
   end;

   /*----------------------------------------------*/
   /* Метод получения сообщения запроса из объекта */
   /*----------------------------------------------*/
   /*      Перегруженный метод базового класса     */
   /*----------------------------------------------*/
   macro m_make_req_msg(p_root_ns_alias, p_ns_list)
      private var v_ret = true;
      private var v_username = NULL;
      private var v_password = NULL;
      private var v_pwd_encode;

      private var v_wrap_obj;

      /* Подготавливаем теги для WS-Policy UsernameToken */
      if(vg_is_ws_policy_usrnametoken)
         v_username = string("<wsse:Username>", vg_auth_login, "</wsse:Username>");
         if(VC_IS_PWD_ENCODE)
            v_ret = EncodeBase64(vg_auth_password, v_pwd_encode);

            if(v_ret)
               v_password = string("<wsse:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">",
                                   v_pwd_encode,
                                   "</wsse:Password>");
            else
               vg_service_msg = "Ошибка кодирования пароля для UsernameToken";
            end;
         else
            v_password = string("<wsse:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\">",
                                vg_auth_password,
                                "</wsse:Password>");
         end;
      end;

      if(v_ret)
         vg_req_msg = c_secur_msg_converter.m_secur_external_req(vg_req_obj);
         v_wrap_obj = c_secur_msg_converter();

         if(v_wrap_obj.m_wrap_req_in_soap(vg_req_msg,
                                          p_root_ns_alias,
                                          p_ns_list,
                                          vg_is_ws_policy_usrnametoken,
                                          v_username,
                                          v_password))
            vg_req_msg = v_wrap_obj.get_result_msg();
         else
            vg_service_msg = vg_req_msg.get_service_msg();
            v_ret = false;
         end;

         v_wrap_obj = null;
      end;

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string("При формировании сообщения запроса возникла ошибка: ",
                              c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_make_req_msg() */

   /*---------------------------------------------*/
   /* Метод получения объекта из сообщения ответа */
   /*---------------------------------------------*/
   /*     Перегруженный метод базового класса     */
   /*---------------------------------------------*/
   macro m_make_resp_obj()
      var v_ret = true;

      vg_resp_obj = c_secur_msg_converter.m_secur_external_resp(vg_resp_msg);

      return v_ret;

   onError(err)
      v_ret = false;
      vg_service_msg = string("В процессе преобразования ответа возникла ошибка: ",
                              c_usr_err_obj.obtain_err_msg(err));

      return v_ret;
   end; /* macro m_make_resp_obj() */

   /*-------------*/
   /* Конструктор */
   /*-------------*/
   private macro m_init_prime(i_is_ws_policy_usrnametoken : bool)
      /* После инициализации объекта необходимо выполнить проверку наличия ошибок: m_get_is_error() и get_service_msg() */

      set_is_native_markup(VC_IS_NATIVE_MARKUP);
      set_log_module_name(VC_LOG_MODULE_NAME);

      if(v_state)
         v_state = m_set_logging_type_val(VC_LOGGING_TYPE);
      end;
      if(v_state)
         v_state = m_set_auth_type_val(VC_AUTH_TYPE);
      end;
      if(v_state)
         v_state = m_set_host_val(VC_HOST_VAL);
      end;
      if(v_state)
         v_state = m_set_soapaction_val(VC_SOAPACTION_VAL);
      end;
      if(v_state)
         v_state = m_set_cert_path(VC_CERT_PATH);
      end;
      if(v_state)
         v_state = m_set_auth_login_val(VC_AUTH_LOGIN);
      end;
      if(v_state)
         v_state = m_set_auth_pwd_val(VC_AUTH_PWD);
      end;

      if(ValType(i_is_ws_policy_usrnametoken) != V_UNDEF)
         vg_is_ws_policy_usrnametoken = i_is_ws_policy_usrnametoken;

         /* Если предполагается использовать WS-Policy UsernameToken, то проверяем наличие логина/пароля */
         if(vg_is_ws_policy_usrnametoken)
            if((v_state) and (strlen(vg_auth_login) == 0))
               v_state = false;
               vg_service_msg = "Для использования UsernameToken должен быть задан логин";
            end;
/* Пока предполагаем, что пустой пароль тоже допустим *//*
            if((v_state) and (strlen(vg_auth_password) == 0))
               v_state = false;
               vg_service_msg = "Для использования UsernameToken должен быть задан пароль";
         end;
*/
         end;
      end;

   end; /* private macro m_init_prime() */

   Initc_com_ext_ws_processor();

   m_init_prime(p_is_ws_policy_usrnametoken);
end; /* class (c_com_ext_ws_processor) c_secur_ext_ws_processor() */