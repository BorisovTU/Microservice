/*
$Name:        dlmarket_reports_unpacked.mac
$Module:      Securities
$Description: Распаковка файлов отчетов биржи СПБ из архивов
*/
import "dlcontrfunc.mac";

private const OPTION_FOR = 1; // Вариант реализации: 0=дистрибутив; 1=РСХБ;
private const CLEAR_ATTR_READONLY = false; // попробовать снять атрибут "Только чтение" на файлах в папке "Входящие"

private const IMPORTDIR = "РСХБ\\ДИРЕКТОРИИ\\SPBIMPORT";
private const REGPATH_SPB82 = "SECUR\\SPB\\PATH_SPB82";
// Соответствие названия файлов и каталогов:
private const SPB21="SPB21",   QUOTESX="QUOTESX",
              MFB98="MFB98",   PRNCPL_PAYM="PRNCPL_PAYM",
              SPB03="SPB03",   DEALSX="DEALSX",
              MFB06C="MFB06C", CLEARCX="CLEARCX",
              MFB13="MFB13",   NETTOX="NETTOX",
              MFB99="MFB99",   CASH_FLOW="CASH_FLOW",
              ORDERS="ORDERS", ORDERSX="ORDERSX",
              /*прочие отчеты*/NOTUSED="NOTUSED",
              SPB82="SPB82";

// Обрабатываемые архивы СПБ 
private const PACK_KIND_ZIP = 1;
private const PACK_KIND_7Z  = 2;

private var DlArchivator:TDlArchivator,
            pathPacked="", pathUnpackedTmp="", pathDone="", pathErr="",
            PathImportSPB="", pathSPB82="", pathNOTUSED="", pathORDERSX_SPB="",
            pathQUOTESX_SPB="", pathPRNCPL_PAYM_SPB="", pathDEALSX_SPB="", pathCLEARCX_SPB="", pathNETTOX_SPB="", pathCASH_FLOW_SPB="";

// Для протокола
private var UnpackedFiles:TArray = TArray();
private var PackErr:TArray = TArray();

private macro GetStrRegVal(regPath:string, stat:@integer): string
  var val = "";
  stat = 0;

  GetRegistryValue(regPath, V_STRING, val, stat);
  if(stat != 0)
    msgbox("Ошибка при получении значения настройки: " + regPath);
  elif(val == "")
    stat = 1;
    msgbox("Не задано значение настройки: " + regPath);
  end;

  return val;
end;

private macro GetRegImportDir( Str:STRING, ErrMes:@string ):string
  var RegDir = "", err, ImpDir = "";
  var flag1 = 0, flag2 = 0, flagStr = 0;

  GetRegistryValue(ImportDir, V_STRING, RegDir, err);
  RegDir = RegDir + ";";

  if(err)
    ErrMes = "Ошибка получения значения настройки \"" + ImportDir + "\"";
    return "";
  end;

  flag2 = index(RegDir, ";");

  while(flag2 != 0)
    if(not Str)  /* если подстрока пути не задана, берём подстроку до первого символа ";" */
      flagStr = 1;
    else
      flagStr = index(RegDir, Str);
    end;

    if( ( flagStr > flag1) and ( flagStr < flag2 ) )
      ImpDir = MergeFile(SubStr(RegDir,flag1+1,flag2 - flag1 - 1),"");
      break;
    end;

    flag1 = flag2;
    flag2 = index(RegDir,";",flag2+1);

    if( not flag2 AND (flagStr > flag1) )
      flag2 = strlen(RegDir)+1;
    end;
  end;

  return ImpDir;
end;

private macro GetDirPath(): integer
  var stat = 0;

  pathPacked = GetStrRegVal("РСХБ\\ДИРЕКТОРИИ\\ARHIVSPB\\PATH_PACKED", @stat);
  if(stat == 0)
    pathPacked = DL_GetFullPath(pathPacked);
    stat = ExistDir(pathPacked);
    if(stat != 0)
      msgbox("Нет каталога или нет доступа к каталогу: " + pathPacked);
    end;
  end;

  if(stat == 0)
    pathUnpackedTmp = GetStrRegVal("РСХБ\\ДИРЕКТОРИИ\\ARHIVSPB\\PATH_UNPACKED_TMP", @stat);
    if(stat == 0)
      pathUnpackedTmp = DL_GetFullPath(pathUnpackedTmp);
      if((stat = DL_CreateDirIfNotExists(pathUnpackedTmp)) != 0)
        msgbox("Нет каталога или нет доступа к каталогу: " + pathUnpackedTmp);
      end;
    end;
  end;

  if(stat == 0)
    pathDone = GetStrRegVal("РСХБ\\ДИРЕКТОРИИ\\ARHIVSPB\\PATH_DONE", @stat);
    if(stat == 0)
      pathDone = DL_GetFullPath(pathDone);
      if((stat = DL_CreateDirIfNotExists(pathDone)) != 0)
        msgbox("Нет каталога или нет доступа к каталогу: " + pathDone);
      end;
    end;
  end;

  if(stat == 0)
    pathErr = GetStrRegVal("РСХБ\\ДИРЕКТОРИИ\\ARHIVSPB\\PATH_ERR", @stat);
    if(stat == 0)
      pathErr = DL_GetFullPath(pathErr);
      if((stat = DL_CreateDirIfNotExists(pathErr)) != 0)
        msgbox("Нет каталога или нет доступа к каталогу: " + pathErr);
      end;
    end;
  end;

  if(stat == 0)
    var errStr = "";
    PathImportSPB = GetRegImportDir("SPB", @errStr);
    if((ErrStr != "") or (PathImportSPB == ""))
       stat = 1;
       if(errStr == "")
         errStr = "Проверьте путь импорта в настройках";
       end;
       msgbox(errStr);
    end;
    if(stat == 0)
      PathImportSPB = DL_GetFullPath(PathImportSPB);
    end;

    if(OPTION_FOR == 0) // для дистрибутива
       if(stat == 0)
         pathQUOTESX_SPB = PathImportSPB+QUOTESX+"\\";
         if((stat = DL_CreateDirIfNotExists(pathQUOTESX_SPB)) != 0)
           msgbox("Нет каталога или нет доступа к каталогу: " + pathQUOTESX_SPB);
         end;
       end;

       if(stat == 0)
         pathPRNCPL_PAYM_SPB = PathImportSPB+PRNCPL_PAYM+"\\";
         if((stat = DL_CreateDirIfNotExists(pathPRNCPL_PAYM_SPB)) != 0)
           msgbox("Нет каталога или нет доступа к каталогу: " + pathPRNCPL_PAYM_SPB);
         end;
       end;

       if(stat == 0)
         pathDEALSX_SPB = PathImportSPB+DEALSX+"\\";
         if((stat = DL_CreateDirIfNotExists(pathDEALSX_SPB)) != 0)
           msgbox("Нет каталога или нет доступа к каталогу: " + pathDEALSX_SPB);
         end;
       end;

       if(stat == 0)
         pathCLEARCX_SPB = PathImportSPB+CLEARCX+"\\";
         if((stat = DL_CreateDirIfNotExists(pathCLEARCX_SPB)) != 0)
           msgbox("Нет каталога или нет доступа к каталогу: " + pathCLEARCX_SPB);
         end;
       end;

       if(stat == 0)
         pathNETTOX_SPB = PathImportSPB+NETTOX+"\\";
         if((stat = DL_CreateDirIfNotExists(pathNETTOX_SPB)) != 0)
           msgbox("Нет каталога или нет доступа к каталогу: " + pathNETTOX_SPB);
         end;
       end;

       if(stat == 0)
         pathCASH_FLOW_SPB = PathImportSPB+CASH_FLOW+"\\";
         if((stat = DL_CreateDirIfNotExists(pathCASH_FLOW_SPB)) != 0)
           msgbox("Нет каталога или нет доступа к каталогу: " + pathCASH_FLOW_SPB);
         end;
       end;

      if(stat == 0)
        pathNOTUSED = PathImportSPB+NOTUSED+"\\";
        if((stat = DL_CreateDirIfNotExists(pathNOTUSED)) != 0)
          msgbox("Нет каталога или нет доступа к каталогу: " + pathNOTUSED);
        end;
      end;

      if(stat == 0)
        pathORDERSX_SPB = PathImportSPB+ORDERSX+"\\";
        if((stat = DL_CreateDirIfNotExists(pathORDERSX_SPB)) != 0)
          msgbox("Нет каталога или нет доступа к каталогу: " + pathORDERSX_SPB);
        end;
      end;
    end;
  end;

  if(stat == 0)
    pathSPB82 = GetStrRegVal(REGPATH_SPB82, @stat);
    if(stat == 0)
      pathSPB82 = DL_GetFullPath(pathSPB82);
      if((stat = DL_CreateDirIfNotExists(pathSPB82)) != 0)
        msgbox("Нет каталога или нет доступа к каталогу: " + pathSPB82);
      end;
    end;
  end;

  return stat;
end;

private macro MoveFile(fromPathName, toPathName): integer
  var stat=0;
  if(not CopyFile(fromPathName, toPathName) )
    stat = 1;
    msgbox("Не удалось скопировать файл из \""+fromPathName+"\" в \""+toPathName+"\"");
  elif(not RemoveFile(fromPathName))
    stat = 1;
    msgbox("Не удалось удалить файл \""+fromPathName+"\".\nВозможно стоит атрибут только для чтения.");
  end;

  return stat;
end;

private macro WrapQuote(str): string
  return "\"" + str + "\"";
end;

private macro ClearAttrReadOnly(filePathName): integer
  var stat = 0;
  stat = startProg("attrib", " -r "+WrapQuote(filePathName), false);
  return stat;
end;

private macro MovePack(fileName, fileExt, fromPath, toPath, tryClearAttrReadOnly, packKind): integer
  
  var extType:string = "";
  if (packKind == PACK_KIND_ZIP)
    extType = ".z*"; //+".z\\d+$"
  elif (packKind == PACK_KIND_7Z)
    extType = ".7z.*";
  end;

  if(tryClearAttrReadOnly)
    ClearAttrReadOnly(fromPath+fileName+fileExt);
  end;
  var stat = MoveFile(fromPath+fileName+fileExt, toPath+fileName+fileExt);

  if(stat == 0)
    var PackParts = TDirList(fromPath+fileName+extType, "F"); 
    if(PackParts.Count > 0)
      var i=0;
      while((i < PackParts.Count) and (stat == 0))
        if(tryClearAttrReadOnly)
          ClearAttrReadOnly(fromPath+PackParts.name(i));
        end;
        stat = MoveFile(fromPath+PackParts.name(i), toPath+PackParts.name(i));
        i = i + 1;
      end;
    end;
  end;

  return stat;
end;

private macro RemoveDirTmp(path): integer
  var stat = 0;
  var fList = TDirList(path+"*.*", "F");
  if(fList.Count > 0)
    var i=0;
    while((i < fList.Count) and (stat == 0))
      if(not RemoveFile(path+fList.name(i)))
        stat = 1;
        msgbox("Не удалось удалить файл \""+path+fList.name(i)+"\"");
      end;
      i = i + 1;
    end;
  end;

  if(stat == 0)
    if(not RemoveDir(path))
      stat = 1;
      msgbox("Не удалось удалить каталог \""+path+"\"");
    end;
  end;

  return stat;
end;

macro GetDirNameByDateStr(strDate:string):string
   var YY:string, MM:string, DD:string;
   YY = substr(strDate, 3, 2);
   MM = substr(strDate, 6, 2);
   DD = substr(strDate, 9, 2);
   return DD+MM+YY;
end;

private macro MoveFileToImportDir_RSHB(ePath, parts:TArray, fileName, fileExt, packKind): integer
  var stat = 0, ImpDirDate;
   	
  if(packKind == PACK_KIND_ZIP)
    if((parts[0] == "MFB98A") or
       (parts[0] == "SPB03M") or
       (parts[0] == "SPB21M") or
       (parts[0] == "BE21") or
       (parts[0] == "BE03")
      )
      ImpDirDate = GetDirNameByDateStr(parts[1]);
    elif(parts[1] == MFB13)
      ImpDirDate = GetDirNameByDateStr(parts[3]);
    else
      ImpDirDate = GetDirNameByDateStr(parts[2]);
    end;
  elif(packKind == PACK_KIND_7Z)
    // заявки (orders-ORDERS_RSXBM-2022-01-28.txt)
    if((parts.size == 2) and (strlen(parts[1]) == 16)) //RSXBM-2022-01-28
      ImpDirDate = GetDirNameByDateStr(substr(parts[1], 7));
    end;
  end;

  ImpDirDate = PathImportSPB+ImpDirDate+"\\";
  if((stat = DL_CreateDirIfNotExists(ImpDirDate)) != 0)
    msgbox("Нет каталога или нет доступа к каталогу: " + ImpDirDate);
  end;

  if(stat == 0)
    stat = MoveFile(ePath+fileName+fileExt, ImpDirDate+fileName+fileExt);

    if(stat == 0)
      UnpackedFiles[UnpackedFiles.size] = ImpDirDate+fileName+fileExt;
    end;
  end;

  return stat;
end;

private macro MoveFileToImportDir(ePath, parts:TArray, fileName, fileExt, packKind): integer
  var stat = 0, ImpDir;

  if(packKind == PACK_KIND_ZIP)
    if(parts[1] == SPB21)
      ImpDir = pathQUOTESX_SPB;
    elif(parts[1] == MFB98)
      ImpDir = pathPRNCPL_PAYM_SPB;
    elif(parts[1] == SPB03)
      ImpDir = pathDEALSX_SPB;
    elif(parts[1] == MFB06C)
      ImpDir = pathCLEARCX_SPB;
    elif(parts[1] == MFB13)
      ImpDir = pathNETTOX_SPB;
    elif(parts[1] == MFB99)
      ImpDir = pathCASH_FLOW_SPB;
    else
      ImpDir = pathNOTUSED;
    end;
  elif(packKind == PACK_KIND_7Z)
    ImpDir = pathORDERSX_SPB;
  end;

  stat = MoveFile(ePath+fileName+fileExt, ImpDir+fileName+fileExt);

  if(stat == 0)
    UnpackedFiles[UnpackedFiles.size] = ImpDir+fileName+fileExt;
  end;

  return stat;
end;

private macro ProcessFiles(ePath:string, packKind:integer): integer
  var stat=0, i=0, fileName, fileExt, fromPathName, toPathName,
      fList, parts, ImpDirDate;

  fList = TDirList(ePath+"*.*", "F");
  if(fList.Count > 0)
    while((i < fList.Count) and (stat == 0))

      SplitFile(fList.name(i), fileName, fileExt);
      parts = split(fileName, "_");

      if(parts.size > 0)
        if((packKind == PACK_KIND_ZIP) and (parts[1] == SPB82))
          stat = MoveFile(ePath+fileName+fileExt, pathSPB82+fileName+fileExt);
         
          if(stat == 0)
            UnpackedFiles[UnpackedFiles.size] = pathSPB82+fileName+fileExt;
          end;

        else
          if(OPTION_FOR == 1) // РСХБ
            stat = MoveFileToImportDir_RSHB(ePath, parts, fileName, fileExt, packKind);
          else // дистрибутив
            stat = MoveFileToImportDir(ePath, parts, fileName, fileExt, packKind);
          end;
        end;
      end;

      i = i + 1;
    end;
  end;
  
  return stat;
end;

private macro ProcessPack(PackName:string, packKind:integer): integer
  var stat=0, fileName, fileExt, aFile, ePath, erStr="";
  SplitFile(PackName, fileName, fileExt);

  // перенесем в папку для распаковки
  stat = MovePack(fileName, fileExt, pathPacked, pathUnpackedTmp, CLEAR_ATTR_READONLY, packKind);

  // распакуем архив
  if(stat == 0)
    aFile = pathUnpackedTmp+PackName;
    ePath = pathUnpackedTmp+fileName+"\\";

    stat = DlArchivator.Extract(aFile, ePath, @erStr);
    if(stat == 0)
      // переместим распакованные файлы архивов согласно правилам ТЗ
      stat = ProcessFiles(ePath, packKind);

      // удалим временную папку
      if(stat == 0)
        RemoveDirTmp(ePath);
      end;

      if(stat == 0)
        stat = MovePack(fileName, fileExt, pathUnpackedTmp, pathDone, null, packKind);
      end;
    else
      msgbox(erStr);
      MovePack(fileName, fileExt, pathUnpackedTmp, pathErr, null, packKind);
    end;
    end;

  if(stat != 0)
    PackErr[PackErr.size] = PackName;
  end;

  return stat;
end;

private macro PrintUnpackedFiles()
  if(UnpackedFiles.size > 0)
[
 ┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
 │  В импорты добавлены файлы                                                                                        │
];
    for (var item, UnpackedFiles)
[├───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
 │###################################################################################################################│]
  (item:w);
    end;
[└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘];
  end;
end;

private macro PrintPackErr()
  if(PackErr.size > 0)
[
 ┌───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
 │  Были ошибки при обработке архивов                                                                                │
];
    for (var item, PackErr)
[├───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
 │###################################################################################################################│]
  (item:w);
    end;
[└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘];
  end;
end;

private macro PrintProtocol()
[
                                               Обработка архивов биржи СПБ
                                                за ########## г. ########
]
  ({CurDate}, Time());
  PrintUnpackedFiles();
  PrintPackErr();
end;


// Процедура распаковки файлов отчетов биржи из архивов
private macro MarketReportUnpacked(): integer
  var stat=0, i=0, existsPack=false;

  InitError();

  DlArchivator = TDlArchivator();
  if(DlArchivator.GetStat() == 0)

    stat = GetDirPath();
    if(stat == 0)
      UnpackedFiles.size = 0; PackErr.size = 0;

      // Проверяем папку "Входящие" на наличие новых архивов и заберем их
      var Packs = TDirList(pathPacked+"*.7z", "F");
      if((Packs.Count > 0) and (stat == 0))
        existsPack=true;
        InitProgress(Packs.Count, "Обработка файлов архивов биржи 7z", "Обработка файлов архивов биржи 7z");
        i = 0;
        while((i < Packs.Count) and (stat == 0))
          stat = ProcessPack(Packs.name(i), PACK_KIND_7Z);
          i = i + 1;
          UseProgress(i);
        end;
        RemProgress();
      end;

      Packs = TDirList(pathPacked+"*.zip", "F");
      if((Packs.Count > 0) and (stat == 0))
       existsPack=true;
        InitProgress(Packs.Count, "Обработка файлов архивов биржи zip", "Обработка файлов архивов биржи zip");
        i = 0;
        while((i < Packs.Count) and (stat == 0))
          stat = ProcessPack(Packs.name(i), PACK_KIND_ZIP);
          i = i + 1;
          UseProgress(i);
        end;
        RemProgress();
      end;

      if(existsPack)
        PrintProtocol();
      else
[Нет архивов для обработки];
      end;
    end;
  end;

  return stat;
end;


MarketReportUnpacked();
