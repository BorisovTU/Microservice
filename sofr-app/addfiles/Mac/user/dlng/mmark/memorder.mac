 /*
 $Name: memorder.mac
 $Module: Ядро Banking
 $Description: Макрос скроллинга платежей и требований банка
 */


import globals, CTInter, OprInter, check117, "pmchoper.mac", "pm_tools.mac", PaymInter, "pm_opr.mac", pm_common, pm_chksave, "pm_syscont.mac";
import "cb_FillFactura.mac", "pmedit.mac", pmbuff;
import "pmchangeprop.mac",funk;

FILE   fmo_party      ("party.dbt");
FILE   fmo_account  ("account.dbt");
FILE   fmo_partcode   ("partcode.dbt");

/*номера полей в панели*/
const fld_Number:TArray = makeArray( 1, 1, 1),
      fld_baseFIID:TArray = makeArray( 7, 0, 0 ),
      fld_bankaccr:TArray = makeArray( 23, 17, 43),
      fld_bankaccp:TArray = makeArray( 18, 12, 18),
      fld_Ground:TArray = makeArray( 30, 22, 45),
      fld_PayerINN:TArray = makeArray( 10, 5, 0),  /*инн получателя*/
      fld_ReceiverINN:TArray = makeArray( 25, 19, 0); /*инн плательщика*/
const fld_paym_kind      = 3,  /*Вид платежа*/
      fld_kzPayerCode    = 7,
      fld_kzReceiverCode = 18;

class (TPanelFields)TBankPayorderPanelFields( p_ResName:string, p_ResLbr:string )
  
  InitTPanelFields( p_ResName, p_ResLbr );
  
  PrevInstrAgentCode = GetFieldNum( "PrevInstrAgentCode" );
  IntermediaryBankCode = GetFieldNum( "IntermediaryBankCode" );
  SenderBankCode = GetFieldNum( "SenderBankCode" );
  ExecutorBankCode = GetFieldNum( "ExecutorBankCode" );
  PrevInstrAgentAccount = GetFieldNum( "PrevInstrAgentAccount" );
  IntermediaryBankAccount = GetFieldNum( "IntermediaryBankAccount" );
  SenderBankAccount = GetFieldNum( "SenderBankAccount" );
  ExecutorBankAccount = GetFieldNum( "ExecutorBankAccount" );
end;


private const MEMORDER_STATUS_POST = 1; /* Отложенный документ */

/* Установка подсказки для скролингов из макроса */

private const Hint_ByStatus   :string = 
"/*+FIRST_ROWS LEADING(t pmpaym pmrmprop debet credit oproper oprcurst) INDEX(t dmemorder_dbt_idx1) INDEX(pmpaym dpmpaym_dbt_idx0) USE_NL(t pmpaym pmrmprop debet credit oproper oprcurst)*/";

private const Hint_ByValueDate:string = 
"/*+FIRST_ROWS LEADING(pmpaym t pmrmprop debet credit oproper oprcurst) INDEX(pmpaym dpmpaym_dbt_idx11) INDEX(t dmemorder_dbt_idx0) USE_NL(pmpaym t pmrmprop debet credit oproper oprcurst)*/";

private const Hint_ByCloseDate:string = 
"/*+FIRST_ROWS LEADING(pmpaym t pmrmprop debet credit oproper oprcurst) INDEX(pmpaym dpmpaym_dbt_idx15) INDEX(t dmemorder_dbt_idx0) USE_NL(pmpaym t pmrmprop debet credit oproper oprcurst)*/";

private const Hint_ByStep     :string = 
"/*+FIRST_ROWS LEADING(t oproper memorder pmpaym pmrmprop debet credit oprcurst) INDEX(t doprstep_dbt_idx10) INDEX(memorder dmemorder_dbt_idx0) INDEX(pmpaym dpmpaym_dbt_idx0) USE_NL(t oproper memorder pmpaym pmrmprop debet credit oprcurst)*/";



PRIVATE MACRO GetFldNum(DocKind:integer)
  if (DocKind == DLDOC_BANKCLAIM)
    return 0;
  end;
  if (DocKind == DLDOC_BANKPAYMENT)
    return 1;
  end;
  if (DocKind == DLDOC_BANKPAYORDER)
    return 2;
  end;
  return 0;
end;



MACRO УстановитьПодсказку( TableName:string, IndexNum:integer, DefaultHint:string, ScrolStates:integer ):string
  /*  Возможные значения ScrolStates:
       0 - Все
       1 - Отложенные
       2 - Открытые
       3 - Закрытые
       4 - Отвергнутые
       5 - Для контроля
      10 - Картотека требований
      11 - Оплаченные требования
      12 - Отказанные требования
      13 - Все поступившие требования */
  
  /* Все, Закрытые */
  if( ( ScrolStates == 0 ) or
      ( ScrolStates == 3 ) )

    var dtflt:PMScrolDateFltr = PMScrolDateFltr();

    if( dtflt.IsSet( DTFL_CLOSEDATE ) )
      return Hint_ByCloseDate;
    elif( dtflt.IsSet( DTFL_VALUEDATE ) )
      return Hint_ByValueDate;
    else
      return Hint_ByCloseDate;
    end;

  /* Подготовленные к шагу */ 
  elif ( ScrolStates == 5 )
    return Hint_ByStep;

  /* Остальные */
  else 
    return Hint_ByStatus;
  end;

  return DefaultHint;

END;

/* Просто ищем Party по PartyId*/
macro FindPartyByPartyID( PartyID )
   var retval, OldKey;
   OldKey = KeyNum (0, fmo_party);

   fmo_party.PartyId = PartyId;
   retval = getEQ(fmo_party);

   keyNum (OldKey, fmo_party);
   return retval;
end;

/* Ищем имеем ли мы БИК*/
macro FindBIC ( PartyID )
   var retval, OldKey;
   OldKey = KeyNum (0, fmo_partcode);

   fmo_partcode.PartyId = PartyId;
   fmo_partcode.CodeKind = 3; //PTCK_BIC

   retval = getEQ(fmo_partcode);

   keyNum (OldKey, fmo_partcode);
   return retval;
end;

/* Возвращает код головного банка, если таковой есть, для банка заданного ID*/
macro GetHeadBankCode (BankID)
   if( not FindBIC( BankID ) )
     FindPartyByPartyID(BankID);
     if(fmo_party.Superior != -1 )
       if( FindPartyByPartyID( fmo_party.Superior ) )
         return fmo_party.PartyId;
       else return -1;
       end;
     else return -1;
     end;
   else return -1;
   end;
end;

//------------------------------------------------------------------------------
//   Функция проверяет наличие лиц. счета
//------------------------------------------------------------------------------
private MACRO ЛСчетСуществует( Chapter:integer, FIID:integer, Account:string ):bool
  VAR select:string = " select acc.T_ACCOUNT " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account "+
                      "   and acc.T_Open_Close = chr(0)";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapter ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  return ( rset and rset.moveNext() );
END;

macro CheckBankID( BankID, FIID, Account )
   return 0;

   if( (BankID == {OurBank}) or (BankID == GetHeadBankCode({OurBank})) )
      /* ищем среди наших счетов */
      if( ЛСчетСуществует( 1, FIID, Account ) )
        if( r_memorder.DocKind == 16 ) //DLDOC_BANKPAYMENT
          if ( RsbGetTrue (false, true, "Проверьте реквизиты получателя. | Указанный счет есть в \"нашем банке\". | Отправить \"внешний\" платеж? ") == false)
                return fld_bankaccr[GetFldNum(r_memorder.DocKind)];
             end;
           else
          if ( RsbGetTrue (false, true, "Проверьте реквизиты плательщика. | Указанный счет есть в \"нашем банке\". | Отправить \"внешний\" платеж? ") == false)
                return fld_bankaccp[GetFldNum(r_memorder.DocKind)];
             end;
        end;
      end;
   end;
   return 0;
end;

macro    Новый_Документ()

        return 0;
end;

macro    Проверить_Документ( Режим )
  var stat = 0, BankID, FIID, Account, NeedCheckBankID = 0,
      CHANG_IMPORTANT = -11,
      CHANG_NOTIMPORTANT = -10,
      res,
      Sh_Oper,
      OldDoc = 0;

  var ErrStr:string = "";


  /*Проверяем номер для всех документов, в том числе и отложенных.*/
  if( (Режим == 2 ) or (Режим == 3) or (Режим == 8) )
    if( needUseKZpm() and ( r_pmpaym.Dockind != DLDOC_BANKCLAIM ) )
      if( CompareStrWithMasks("10-29&??", r_pmkz.PayerCode) )
        MsgBox("Некорректное значение КОд");
        return fld_kzPayerCode;
      end;
      if( CompareStrWithMasks("10-29&??", r_pmkz.ReceiverCode) )
        MsgBox("Некорректное значение Кбе");
        return fld_kzReceiverCode;
      end;
    end;

    if( (not stat) and (not IsUFEBS(r_credit, r_debet)))
      res = CheckINN(r_pmrmprop.PayerINN);
      if (res)
         msgBox ("Ошибка в ИНН плательщика");
         return 1;
      end;

      res = CheckINN(r_pmrmprop.ReceiverINN);
      if (res)
         msgBox ("Ошибка в ИНН получателя");
         return 1;
      end;

      if(stat==2)    
       return stat = fld_PayerINN[GetFldNum(r_memorder.DocKind)];
      end;
      if(stat==3)    
       return stat = fld_ReceiverINN[GetFldNum(r_memorder.DocKind)];
      end;
    end;

    if( r_memorder.DocKind == 17 ) //DLDOC_BANKCLAIM
      if( r_pmpaym.PayerBankID == r_pmpaym.ReceiverBankID  )
        MsgBox("Банк плательщика не должен совпадать с|банком получателя" );
        return fld_bankaccp[GetFldNum(r_memorder.DocKind)];
      end;
    end;
      
    if( PM_CheckPayments( r_pmpaym, r_debet, r_credit, r_pmrmprop, 1 ) )
      return 1;
    end;

    /* Общие проверки по списку */
    if( r_pmpaym.Dockind == DLDOC_BANKPAYMENT )
      stat = BBBP_ScrolMacroCommonChecks( TPanelFields(), r_pmpaym, r_debet, r_credit, r_pmrmprop, r_pmserv );
    elif( r_pmpaym.Dockind == DLDOC_BANKCLAIM )
      stat = BBBC_ScrolMacroCommonChecks( TPanelFields(), r_pmpaym, r_debet, r_credit, r_pmrmprop );
    elif( r_pmpaym.Dockind == DLDOC_BANKPAYORDER )
      stat = BBBPO_ScrolMacroCommonChecks( TBankPayorderPanelFields( "BNKPORD", "bank.lbr" ), r_pmpaym, r_debet, r_credit, r_pmrmprop );
    end;
    if( stat != NOTERROR )
      return stat;
    end;

    if( StrLen( r_pmrmprop.Number ) == 0 )
      MsgBox("Не задан номер документа");
      return fld_Number[GetFldNum(r_memorder.DocKind)];
    end;

    if( not StrIsNumber(r_pmrmprop.Number) )
      MsgBox("Номер документа нечисловой");
      return fld_Number[GetFldNum(r_memorder.DocKind)];
    else
       if( int(r_pmrmprop.Number) == 0 )
          MsgBox("Номер документа не может быть нулевым");
          return fld_Number[GetFldNum(r_memorder.DocKind)];
       end;
    end;

    if( StrLen( r_pmrmprop.Ground ) == 0 )
      MsgBox("Введите Назначение платежа");
      return fld_Ground[GetFldNum(r_memorder.DocKind)];
    end;
    
    if( StrLen( r_pmrmprop.Ground )>210 )                
      if ( RsbGetTrue( False,True,"Основание платежа превышает 210 символов.|Продолжить?")==False )                   
         return fld_Ground[GetFldNum(r_memorder.DocKind)];
      end;
    end;

    if( StrLen( r_pmrmprop.PartyInfo)>210-33 )
      if ( RsbGetTrue( False,True,"Информация участнику превышает 177 символов.|Продолжить?")==False )
         return 1;
      end;
    end;

    if( StrLen( r_pmrmprop.ReceiverBankName)>140 )
      if ( RsbGetTrue( False,True,"Наименование банка получателя превышает 140 символов.|Продолжить?")==False )
         return 1;
      end;
    end;

    if( StrLen( r_pmrmprop.PayerBankName)>140 )
      if ( RsbGetTrue( False,True,"Наименование банка плательщика превышает 140 символов.|Продолжить?")==False )
         return 1;
      end;
    end;

    if( StrLen( r_pmrmprop.ReceiverName)>160 )
      if ( RsbGetTrue( False,True,"Наименование получателя превышает 160 символов.|Продолжить?")==False )
         return 1;
      end;
    end;

    if( StrLen( r_pmrmprop.PayerName)>160 )
      if ( RsbGetTrue( False,True,"Наименование плательщика превышает 160 символов.|Продолжить?")==False )
         return 1;
      end;
    end;

    // KS 19.08.2019 При вводе платежа (исходящий, введён вручную) проверять заполненность поля "Пачка", в случае нулевого значения предупреждать, что такой платёж не будет выгружен в БИС;
    if( ( r_credit.corschem != -1 ) and ( r_pmpaym.Origin == PAYMENT_OR_MANUAL ) and ( r_pmpaym.NumberPack==0 ) )
      if ( RsbGetTrue( False,True,"Номер пачки не задан!|Платеж не будет выгружен в БИС|Продолжить?")==False )
         return 1;
      end;
    end;

    if ( GetDialogFlag() )
      /* Проверить по 117-И */
      if( r_memorder.DocKind == 16 )
        if( CheckOnSave_117( r_pmpaym, NULL, r_credit, NULL, r_pmrmprop ) )
          return fld_Number[GetFldNum(r_memorder.DocKind)];
        end;
      else
        if( CheckOnSave_117( r_pmpaym, r_debet, NULL, NULL, r_pmrmprop ) )
          return fld_Number[GetFldNum(r_memorder.DocKind)];
        end;
      end;
      if(PM_CheckCO(r_pmpaym,r_pmrmprop,r_debet,r_credit))
         return 1;
      end;
    end;
  
    /*  Если код банка равен нашему банку или код банка равен коду нашего головного банка */
    if( r_memorder.DocKind == 16 ) //DLDOC_BANKPAYMENT
      if( strlen(r_credit.BankCode) and
          ((Режим != 3) or ((Режим == 3) and
                            ((r_credit.BankCode != r_credit_old.BankCode) or
                             (r_pmpaym.ReceiverAccount != r_pmpaym_old.ReceiverAccount)))))
        NeedCheckBankID = 1;
        BankID  = r_pmpaym.ReceiverBankID;
        FIID    = r_pmpaym.FIID;
        Account = r_pmpaym.ReceiverAccount;
      end;
    else
      if( strlen(r_debet.BankCode) and
          ((Режим != 3) or ((Режим == 3) and
                            ((r_debet.BankCode != r_debet_old.BankCode) or
                             (r_pmpaym.PayerAccount != r_pmpaym_old.PayerAccount)))))
        NeedCheckBankID = 1;
        BankID  = r_pmpaym.PayerBankID;
        FIID    = r_pmpaym.FIID;
        Account = r_pmpaym.payerAccount;
      end;
    end;
    /*платеж внешний*/
    if( NeedCheckBankID and (Режим != 3) and (r_memorder_old.OrderID == 0) ) 
      stat = CheckBankID( BankID, FIID, Account );
      if( stat ) return stat; end;
    end;

    if( r_memorder.DocKind == 16 ) //DLDOC_BANKPAYMENT
      ErrStr = PM_CheckPaymAccounts( r_pmpaym, NULL, r_credit, r_pmrmprop, 1 );
    else
      ErrStr = PM_CheckPaymAccounts( r_pmpaym, r_debet, NULL, r_pmrmprop, 1 );
    end;

    if( strlen(ErrStr) > 0 )
      msgbox( ErrStr );
      return 1;
    end;
  end;

  if(Режим == 1 ) /*УДАЛЕНИЕ ДОКУМЕНТА*/
    if(not isDLMRuning())
      if(r_memorder.Origin == MEMORDER_FDOC_ZP)
        msgbox("Документ порожден п/с \"Заработная плата\".|Удаление запрещено.");
        stat = 1;
      elif(r_memorder.Origin == MEMORDER_FDOC_SF)
        msgbox("Документ является платой за обслуживание.|Удаление запрещено.");
        stat = 1;
      elif(r_memorder.Origin == MEMORDER_FDOC_CONTRACT)
        msgbox("Документ порожден п/с \"Учет договоров\".|Удаление запрещено.");
        stat = 1;
      elif(r_memorder.Origin == MEMORDER_FDOC_DP)
        if(not Index( "Д", StrFor(GetIdentProgram())))
           msgbox("Документ порожден п/с \"Депозиты\".|Удаление запрещено.");
           stat = 1;
        end;
      elif(r_memorder.Origin == MEMORDER_FDOC_LOANS)
        if(not Index( "Ц", StrFor(GetIdentProgram())))
          msgbox("Документ порожден п/с \"Кредитование\".|Удаление запрещено.");
          stat = 1;
        end;
      elif(r_memorder.Origin == MEMORDER_FDOC_RETAIL)
        if(not Index( "ВБD", StrFor(GetIdentProgram())))
          msgbox("Документ порожден п/с \"Обслуж.физ.лиц\".|Удаление запрещено.");
          stat = 1;
        end;
      elif( r_memorder.Origin == MEMORDER_FDOC_RETURN )
        msgbox("Документ порожден при возврате невыясненного платежа. |Удаление запрещено");
        stat = 1;
      elif( r_memorder.Origin == MEMORDER_FDOC_PROCUNKNOWNPM )
        msgbox("Документ порожден при обработке невыясненной суммы.|Удаление запрещено.");
        stat = 1;
      elif( r_memorder.Origin == MEMORDER_FDOC_REDIRECT )
        msgbox("Документ порожден при перенаправлении невыясненного платежа. |Удаление запрещено");
        stat = 1;
      elif( r_memorder.Origin == MEMORDER_FDOC_CLOSACC )
        msgbox("Документ порожден при перечислении средств поступивших на закрытый счет по новым реквизитам. |Удаление запрещено");
        stat = 1;
      elif( r_memorder.Origin == MEMORDER_FDOC_TRANZIT )
        msgbox("Документ порожден при перенаправлении транзитного платежа. |Удаление запрещено");
        stat = 1;
      end;

    end;

    if(CheckDeletePayment(r_pmpaym.PaymentID))
      return 1;
    end;
  elif(Режим == 2)  /* ВВОД ДОКУМЕНТА */
  elif(Режим == 3)  /* РЕДАКТИРОВАНИЕ ДОКУМЕНТА */
    /*При редактировании производим проверку важности внесенных изменений */
    /* Константы важности внесенных изменений:           */
    /* CHANG_NOTIMPORTANT   - изменения неважные (сохранение без отката операции)*/
    /* CHANG_IMPORTANT      - изменения важны (сохранение изменений возможно только при откате) */
    /* CHANG_NOTKEEP        - не сохранять изменения */
    /* Если возвращаемое значение  > 0, то это оно интерпритируется как номер поля с ошибочным параметром*/
    /* Если возвращаемое значение  = 0, то cчитается, что проверка прошла успешно
       и сохранение изменений можно производить без отката операции      */
    if (StandartCheckUpdate(TCheckUpdateParam(r_pmpaym, r_debet, r_credit, r_pmrmprop), 
        TCheckUpdateParam(r_pmpaym_old, r_debet_old, r_credit_old, r_pmrmprop_old)) == CHANG_NOTKEEP)
      return CHANG_NOTKEEP;
    end;
  elif(Режим == 7 ) /*ПОМЕЩЕНИЕ ДОКУМЕНТА В ОТЛОЖЕННЫЕ, ОТКАТ ОПЕРАЦИИ*/
  elif( Режим == 8 )  /*ВВОД В ОТЛОЖЕННЫЕ*/
  elif(Режим == OBJ_AFTEREDIT) /* Проверка важности изменений влияющей на необходимость смены опера документа
                                  (изменения в буферах не сохраняются)*/
    return IsImportantChangeForOperBankPaym(r_pmpaym, r_pmpaym_old, r_pmrmprop, r_pmrmprop_old, r_credit, r_credit_old, r_debet, r_debet_old, r_pmdemand, r_pmdemand_old)
  end;

  return stat;

end;

macro    Проверить_Счет_В_Документе( поле ) /*0-счет плательщика, 1-счет получателя*/
        var новое_значение_счета;

        if(поле) новое_значение_счета = r_pmpaym.ReceiverAccount;
        else новое_значение_счета = r_pmpaym.PayerAccount;
        end;
        return новое_значение_счета;
end;

macro    Функция_Пользователя( Режим:integer )
 /*
 Возможные значения Режим:
  UFN_PANEL_INPUT(1) - функция вызвана из панели ввода объекта;
  UFN_PANEL_EDIT(2) - функция вызвана из панели корректировки объекта;
  UFN_SCROL(3) - функция вызвана из панели скролинга, единичный вызов, любая корректировка объекта запрещена;
  UFN_SCROL_FMASS(4) - функция вызвана из панели скролинга, работа по нескольким записям, вызов до начала обработки, любая корректировка объекта запрещена;
 
// Пример работы: 
 if( Режим == UFN_SCROL )
   return UPDTPAGE;    // Обновить страницу записей и область скролинга
   //return UPDTREC;     // Обновить текущую запись, загрузив из файла
 end;
 */

  private var ii,rs21,que;
  ii=0;
  getint(ii,"ВВОД");
  if ( ii == 1000 )
      que="update dpmpaym_dbt set t_paymstatus=1000 where t_paymentid="+r_pmpaym.paymentid;
      rs21 = LnGetRecordSet(que);
      MSGBOX("отправлен в РС !");
  elif ( ii == 32000 )
      que="update dpmpaym_dbt set t_paymstatus=32000 where t_paymentid="+r_pmpaym.paymentid;
      rs21 = LnGetRecordSet(que);
      MSGBOX("отправлен в банк !");
  elif ( ii == 100 )
      que="update dpmpaym_dbt set t_paymstatus=100 where t_paymentid="+r_pmpaym.paymentid;
      rs21 = LnGetRecordSet(que);
      MSGBOX("отказ !");
  elif ( ii == 0 )
      que="update dpmpaym_dbt set t_paymstatus=0 where t_paymentid="+r_pmpaym.paymentid;
      rs21 = LnGetRecordSet(que);
      MSGBOX("отказ !");

  end;


 return 0;
end;


macro    ЗапроситьРеквизиты()
  return ChoicePaymentPropertiesFromScrol();
end;

macro    УстановитьРеквизиты( PaymentID )
  return ChangePaymentPropertiesFromScrol( PaymentID );
end;

