import rcw, rslx, rsexts;

const XMLField                      = "xml";
const NODE_INVALID                  = 0;
const NODE_CHILD                    = 1;
const NODE_ATTR                     = 2;
const NODE_TEXT                     = 3;
const NODE_CDATA_SECTION            = 4;
const NODE_ENTITY_REFERENCE         = 5;
const NODE_ENTITY                   = 6;
const NODE_PROCESSING_INSTRUCTION   = 7;
const NODE_COMMENT                  = 8;
const NODE_DOCUMENT                 = 9;
const NODE_DOCUMENT_TYPE            = 10;
const NODE_DOCUMENT_FRAGMENT        = 11;
const NODE_NOTATION                 = 12;

const       DEF_DELSPACE            = 0;
private var l_iDelSpace             = DEF_DELSPACE;
private var p_REGVAL_1              = false;//RegistryVal("BANK_INI\\ВЕДЕНИЕ КОРСЧЕТОВ\\ВЫГРУЗКА\\КОНТРОЛЬ_ПРОБЕЛОВ", V_INTEGER, false);
var p_REGVAL_2                      = false;//RegistryVal("BANK_INI\\ВЕДЕНИЕ КОРСЧЕТОВ\\ВЫГРУЗКА\\ФОРМАТИРОВАНИЕ XML-ФАЙЛА", V_UNDEF, false); /*95148*/
private var p_REGVAL_3              = false;//RegistryVal("BANK_INI\\ВЕДЕНИЕ КОРСЧЕТОВ\\ЗАГРУЗКА\\КОНТРОЛЬ_ПРОБЕЛОВ", V_INTEGER, false);
private var p_REGVAL_4              = false;//RegistryVal("BANK_INI\\ВЕДЕНИЕ КОРСЧЕТОВ\\ДИРЕКТОРИИ\\ARHSENDDIR", V_STRING, false);
var p_noSaveArh:bool                = false;

//
/*
macro GetUIC_From() : string
   var rc, ErrCod;
   GetRegistryValue("BANK_INI\\ВЕДЕНИЕ КОРСЧЕТОВ\\НАШ КОД СОСТАВИТЕЛЯ", V_STRING, rc, ErrCod );
   if ((not ErrCod) and (trim(rc) != ""))
      return rc;
   end;
   return substr({MFO_Bank}, 3, 7) + "000";
end;
*/

private macro Iif(a, b, c)
   if (a)
      return b;
   else
      return c;
   end;
end;

private macro IsNum (  str         : string             // Проверяемая строка,
            ,  bFractional : bool /* = false */ // Допускается ли разделитель (точка).
            )  : bool

   var   iPos  : integer = 1
      ,  len   : integer = strlen(str)
      ,  n0    : integer = CodeFor("0")
      ,  n9    : integer = CodeFor("9")
      ,  n     : integer;

   // Проверка символов, начиная с начала строки.
   while(iPos <= len)
      n = CodeFor( substr(str, iPos, 1) );
      if ( (n < n0) or (n > n9) )
         if (     bFractional
            and   ( n == CodeFor(".") )
            )
            bFractional = false; // << Допускается не более одного разделителя.
         elif ( (iPos != 1) or (n != CodeFor("-")) )
            return false;
         end;
      end;
      iPos = iPos + 1;
   end;
   return true;
end;


macro GetParmDelSpace(bSend) : integer
   l_iDelSpace = IIF((bSend == true) OR (bSend == NULL), p_REGVAL_1, p_REGVAL_3);
   if (l_iDelSpace == null)
      l_iDelSpace = DEF_DELSPACE;
   end;
   return l_iDelSpace;
end;

macro ParmDelSpace() : integer
   return l_iDelSpace;
end;

macro ResetParmDelSpace() : integer
   l_iDelSpace = DEF_DELSPACE;
   return l_iDelSpace
end;

macro GetKoefMoney(): integer
   var m = $1.00;
   var K : integer = 100 / double(m);
   return K;
end;

//┌─  Type format conversions: RSL >> XML ───────────────────────────────────────────────────┐
//└──────────────────────────────────────────────────────────────────────────────────────────┘
macro xmldate(val : variant) : string
   var str : string = string(val:f);
   if (val == "")// нулевая дата
      return "";
   end;
   return   substr(str, 7, 4) + "-" // year,
         +  substr(str, 4, 2) + "-" // month,
         +  substr(str, 1, 2);      // day.
end;

macro xmltime(val : variant) : string
   var h = time(0, 0, 0, 0), m : integer, s : integer;

   if (     (valtype(val) == V_TIME)
      and   (val != h)
      )
      TimeSplit(val, h, m, s);
      return string(h:o:2) + ":" + string(m:o:2) + ":" + string(s:o:2);
   else
      return "";
   end;
end;

macro xmlMoney(val : variant) : string
   var str : string;
   if (val == 0)  // Replace with ZeroValue() when accessible.
      str = "";
   else
      str = string(val);
   end;
   return substr( str, 1, index(str, ".") - 1 );
end;

macro valtoxml(val : variant) : string
   var   type  : integer = valtype(val)
      ,  str   : string
      ,  dt    : date
      ,  tm    : time;

   if   ( type == V_STRING )
      if   (ParmDelSpace() == 0)
         return val;
      elif (ParmDelSpace() == 1)
         return trim(val);
      elif (ParmDelSpace() == 2)
         if (strlen(trim(val)) != strlen(val))
            RunError("", "Пробелы в начале(конце) строки");
         else
            return val;
         end;
      else
         if   (DEF_DELSPACE == 0)
            return val;
         elif (DEF_DELSPACE == 1)
            return trim(val);
         elif (DEF_DELSPACE == 2)
            if (strlen(trim(val)) != strlen(val))
               RunError("", "Пробелы в начале(конце) строки");
            else
               return val;
            end;
         else
            return val;
         end;
      end;
   elif ( type == V_DTTM )
      dttmsplit(val, dt, tm);
      str = xmltime(tm);
      if (str == "")
         str = xmldate(dt);
         return Iif(str == "", "", str + "T00:00:00");
      else
         return xmldate(dt) + "T" + str;
      end;
   elif ( type == V_TIME )
      return xmltime(val);
   elif ( type == V_DATE )
      return xmldate(val);
   elif ( type == V_MONEY )
      return xmlMoney( Numeric(val) * GetKoefMoney());
   elif ( type == V_MONEYL )
      return xmlMoney( Numeric(val) * GetKoefMoney());
   elif ( type == V_UNDEF )
      return "";
   else
      return string(val);
   end;
end;


//┌─  Type format conversions: XML >> RSL ───────────────────────────────────────────────────┐
//└──────────────────────────────────────────────────────────────────────────────────────────┘
private macro rslint(val : string) : integer
   if ( IsNum(val) )
      return int(val);
   end;
   RunError();
end;

private macro rsldouble(val : string) : double
   if ( IsNum(val, true) )
      return double(val);
   end;
   RunError();
end;

private macro rsldoubleL(val : string) : doubleL
   if ( IsNum(val, true) )
      return doubleL(val);
   end;
   RunError();
end;

private macro rsltime(val : variant) : time
   if (     ( valtype(val) == V_STRING )
      and   ( val          != "" )
      )
      if (  ( strlen(val)        != 8     )
         or ( substr(val, 3, 1)  != ":"   )
         or ( substr(val, 6, 1)  != ":"   )
         )
         RunError();
      end;
      return time (  rslint( substr(val, 1, 2) )
                  ,  rslint( substr(val, 4, 2) )
                  ,  rslint( substr(val, 7, 2) )
                  );
   elif ( valtype(val) == V_TIME )
      return val;
   else
      return time(0, 0, 0);
   end;
end;

macro rsldate(val : variant) : date
   if (     ( valtype(val) == V_STRING )
      and   ( val          != "" )
      )
      if (  ( strlen(val)        != 10    )
         or ( substr(val, 5, 1)  != "-"   )
         or ( substr(val, 8, 1)  != "-"   )
         )
         RunError();
      end;
      return date (  rslint( substr(val, 9, 2) )
                  ,  rslint( substr(val, 6, 2) )
                  ,  rslint( substr(val, 1, 4) )
                  );
   elif ( valtype(val) == V_DATE )
      return val;
   else
      return date(0, 0, 0);
   end;
end;

private macro rsldttm(val : variant) /* : date */
   if (     ( valtype(val) == V_STRING )
      and   ( val          != "" )
      )
      if ( substr(val, 11, 1) != "T" )
         RunError();
      end;
      return Dttm (  rsldate( substr(val, 1, 10) )
                  ,  rsltime( substr(val, 12)    )
                  );
   elif ( valtype(val) == V_DTTM )
      return val;
   elif ( valtype(val) == V_DATE )
      return Dttm( val, time(0, 0, 0) );
   elif ( valtype(val) == V_TIME )
      return Dttm( date(0, 0, 0), val );
   else
      return Dttm( date(0, 0, 0), time(0, 0, 0) );
   end;
end;

//
macro xmltoval(val : variant, type : integer)

   var i : integer = 0;
   if (val == null)  // << Required to prevent conversions like null >> "Undefined".
      val = "";      //
   end;              //

//   if   ( type == V_STRING )
//      return string(val);
   if   ( type == V_STRING )
      if   (ParmDelSpace() == 0)
         return string(val);
      elif (ParmDelSpace() == 1)
         return trim(string(val));
      elif (ParmDelSpace() == 2)
         if (strlen(trim(string(val))) != strlen(string(val)))
            RunError("", "Пробелы в начале(конце) строки");
         else
            return string(val);
         end;
      end;
   elif ( type == V_DATE )    return rsldate(val);
   elif ( type == V_INTEGER ) return rslint(val);
   elif ( type == V_MONEY )   return money( rsldouble(val) / GetKoefMoney());
   elif ( type == V_TIME )    return rsltime(val);
   elif ( type == V_MONEYL )  return moneyl( rsldoubleL(val) / GetKoefMoney());
   elif ( type == V_DOUBLE )  return rsldouble(val);
   elif ( type == V_DOUBLEL ) return rsldoubleL(val);
   elif ( type == V_DTTM )    return rsldttm(val);
   else                       return string(val);
   end;
   return val;

OnError(er)
   RunError( "Неверный формат XML-типа " + (type) );
end;


//┌─  XML tag parsing ───────────────────────────────────────────────────────────────────────┐
//└──────────────────────────────────────────────────────────────────────────────────────────┘
macro delNamespacePrefix(s : string) : string
   var nColon : integer = index(s, ":");
   return substr(s, nColon + 1);
end;

//
// Return true if equal.
//
macro strcmpXML(s1 : string, s2 : string) : bool
   return delNamespacePrefix(s1) == delNamespacePrefix(s2);
end;

macro GetNamespace(node : object) : string
   var   i     : integer = 0  // Node attibute index,
      ,  attr  : object;      // Node attibute.

   while (i < node.attributes.length)
      attr = node.attributes.item(i);
      if ( attr and (attr.nodeType == NODE_ATTR)
         and ( substr(attr.NodeName(), 1, 5) == "xmlns" )
         )
        return attr.nodeValue;
      end;
      i = i + 1;
   end;
   return "";
end;


private macro DetermitPrefixByNamespace(node : object, szNamespace : string) : string
   var   i     : integer = 0  // Node attibute index,
      ,  attr  : object;      // Node attibute.

   while (i < node.attributes.length)
      attr = node.attributes.item(i);
      if( attr and (attr.nodeType == NODE_ATTR) )
         if (     ( substr(attr.NodeName(), 1, 5) == "xmlns" )
            and   ( attr.nodeValue == szNamespace )
            )
            return substr(attr.NodeName(), 7);
         end;
      end;
      i = i + 1;
   end;
   return "";
end;

private macro DetermitNamespaceByPrefix(node : object, szPrefix : string) : string
   var   i     : integer = 0  // Node attibute index,
      ,  attr  : object;      // Node attibute.

   while (i < node.attributes.length)
      attr = node.attributes.item(i);
      if( attr and (attr.nodeType == NODE_ATTR) )
         if ( attr.NodeName() == ("xmlns:" + szPrefix) )
            return attr.nodeValue;
         end;
      end;
      i = i + 1;
   end;
   return "";
end;

private macro deleteAttrByNamespace(node : object, szNamespace : string, prefix)
   var i : integer, child : object, nodeID, szCurNamespace : string;

   if ( valtype(prefix) == V_UNDEF )
      prefix = "";
   end;

   if ( node.NodeType==NODE_DOCUMENT )
      i = 0;
      while (i < node.childNodes.length)
         child = node.childNodes.item(i);
         if( child and (child.nodeType == NODE_CHILD) )
            return deleteAttrByNamespace(child, szNamespace, prefix);
         end;
         i = i + 1;
      end;
      return;
   end;

   if (prefix == "")
      /* Префикс пространства имени не определен, определяем */
      prefix = DetermitPrefixByNamespace(node, szNamespace);
   else
      /* Префикс пространства имени определен, проверяем переопределили его или нет */
      szCurNamespace = DetermitNamespaceByPrefix(node, prefix);
      if ( (szCurNamespace != "") and (szCurNamespace != szNamespace) )
         /* Его переопределили, значит определяем префикс заного */
         prefix = DetermitPrefixByNamespace(node, szNamespace);
      end;
   end;

   /* Сначала удаляем все атрибуты пространства имен */
   if (prefix != "")
      i = 0;
      while (i < node.attributes.length)
         child = node.attributes.item(i);
         if( child and (child.nodeType==NODE_ATTR) )
            if ( substr(child.NodeName(), 1, strlen(prefix) + 1) == (prefix + ":")  )
               /* Удаляем такой атрибут */
               nodeID = node.getAttributeNode( child.NodeName() );
               node.removeAttributeNode(nodeID);
            end;
         end;
         i = i + 1;
      end;
   end;

   /* Потом удаляем объявление пространства имени */
   i = 0;
   while (i < node.attributes.length)
      child = node.attributes.item(i);
      if( child and (child.nodeType==NODE_ATTR) )
         if (     ( (substr(child.NodeName(),1,5) == "xmlns")
            and   (child.nodeValue==szNamespace) )
            )
            /* Удаляем такой атрибут */
            nodeID = node.getAttributeNode(child.NodeName());
            node.removeAttributeNode( nodeID );
         end;
      end;
      i=i+1;
   end;

   i = 0;
   while (i < node.childNodes.length)
      child = node.childNodes.item(i);
      if ( child and (child.nodeType == NODE_CHILD) )
         deleteAttrByNamespace(child, szNamespace, prefix);
      end;
      i = i + 1;
   end;
end;  // << deleteAttrByNamespace().

private macro GetPrefix(name : string) : string
   if ( Index(name, ":") )
      return substr( name, 1, Index(name,":") - 1 );
   end;
   return "";
end;

private macro GetNodeName(name : string) : string
   return substr( name, index(name, ":") + 1 );
end;


//------------------------------------------------------------------------------------------//


private class Attributes
   private var m_Name   = TArray
            ,  m_Value  = TArray;

   macro Length() : integer
      return m_Name.size;
   end;

   macro Add(arrt_name, arrt_value)
      m_Value[m_Name.Size] = arrt_value;
      m_Name[m_Name.Size]  = arrt_name;
   end;

   /* Сортируем атрибуты в порядке возрастания, причем атрибуты без префикса ставим впереди */
   macro SortAttr()
      var i : integer = 0, j : integer, tmpstr;
      while ( i < Length() - 1 )
         j = i + 1;
         while ( j < Length() )
            if (  ( GetPrefix(m_Name[i]) > GetPrefix(m_Name[j]) )
               OR (     ( GetPrefix(m_Name[i]) == GetPrefix(m_Name[j]) )
                  and   ( m_Name[i] > m_Name[j] )
                  )
               )
               tmpstr      = m_Name[i];
               m_Name[i]   = m_Name[j];
               m_Name[j]   = tmpstr;
               tmpstr      = m_Value[i];
               m_Value[i]  = m_Value[j];
               m_Value[j]  = tmpstr;
            end;
            j = j + 1;
         end;
         i = i + 1;
      end;
   end;

   macro InsertAttributes(item : object)
      var i : integer = 0;

      while ( i < Length() )
         item.setAttribute( m_Name[i], m_Value[i] );
         i = i + 1;
      end;
   end;

   macro Clear()
      m_Name.size = 0;
   end;

   macro Construct()
      Clear();
   end;

   Construct();
end;  // << class Attributes.


//------------------------------------------------------------------------------------------//


private class Namespaces
   var m_URI         = TArray;
   var m_prefix      = TArray;
   var m_newPrefix   = TArray;

   macro Length() : integer
      return m_URI.size;
   end;

   macro Add(uri_name, prefix_name)
      m_prefix[m_URI.size] = prefix_name;
      m_URI[m_URI.size]    = uri_name;
   end;

   macro Update(i : integer, uri_name, prefix_name)
      m_prefix[ i ]  = prefix_name;
      m_URI[ i ]     = uri_name;
   end;

   macro FindByPrefix(prefix_name) : integer
      var i : integer= 0;
      while ( i < Length() )
         if (m_prefix[i] == prefix_name)
            return i;
         end;
         i = i + 1;
      end;
      return -1;
   end;

   /* Добавить новый или обновить существующий */
   /* div_nmsp (необязательный) - список отличающихся пространст имен */
   macro ConditionAdd(uri_name, prefix_name, div_nmsp)
      var i : integer = FindByPrefix(prefix_name);
      if (i < 0)
         Add(uri_name, prefix_name);
         if ( valtype(div_nmsp) != V_UNDEF )
            div_nmsp.Add(uri_name, prefix_name);
         end;
      else
         if (     (uri_name != m_URI[i])
            and   (valtype(div_nmsp) != V_UNDEF)
            )
            div_nmsp.Add(uri_name, prefix_name);
         end;
         Update(i, uri_name, prefix_name);
      end;
   end;

   macro Copy(from : Namespaces, ind : integer, unCond)
      if (ind >= 0)
         if ( (valtype(unCond) == V_UNDEF) OR (unCond == false) )
            ConditionAdd(from.m_URI[ind], from.m_prefix[ind]);
         else
            Add(from.m_URI[ind], from.m_prefix[ind]);
         end;
      end;
   end;

   /* Отсортировать по пространству имен */
   macro SortByURI()
      var i : integer = 0, j : integer, tmpstr;
      while ( i < Length() - 1 )
         j = i + 1;
         while ( j < Length() )
            if ( m_URI[i] > m_URI[j] )
               tmpstr      = m_URI[i];
               m_URI[i]    = m_URI[j];
               m_URI[j]    = tmpstr;
               tmpstr      = m_prefix[i];
               m_prefix[i] = m_prefix[j];
               m_prefix[j] = tmpstr;
            end;
            j = j + 1;
         end;
         i = i + 1;
      end;
   end;

   macro SortByPrefix()
      var i : integer = 0, j : integer, tmpstr;
      while ( i < Length() - 1 )
         j = i + 1;
         while( j < Length() )
            if ( m_prefix[i] > m_prefix[j] )
               tmpstr      = m_URI[i];
               m_URI[i]    = m_URI[j];
               m_URI[j]    = tmpstr;
               tmpstr      = m_prefix[i];
               m_prefix[i] = m_prefix[j];
               m_prefix[j] = tmpstr;
            end;
            j = j + 1;
         end;
         i = i + 1;
      end;
   end;

   /* Создать новые префиксы */
   macro CreateNewPrefix()
      var i : integer = 0, count;
      while (i < Length() )
         if (i == 0)
            count = 1;
         else
            if ( m_URI[i] != m_URI[i - 1] )
               count = count + 1;
            end;
         end;
         m_newPrefix[i] = string("n", count);
         i = i + 1;
      end;
   end;

   macro TakeNewPrefix()
      var i : integer = 0, count;
      while ( i < Length() )
         m_newPrefix[i] = m_prefix[i];
         i = i + 1;
      end;
   end;

   /* Создает полный список пространств имен для узла */
   /* div_nmsp (необязательный) - список изменившихся пространств имен */
   macro CreateGlobal(parent_nmsp, node : object, div_nmsp)
      var child : object, i : integer;

      m_URI.size = 0;
      if ( valtype(div_nmsp) != V_UNDEF )
         div_nmsp.m_URI.size = 0;
      end;

      i = 0;
      while ( i < parent_nmsp.Length() )
         copy(parent_nmsp, i, true);
         i = i + 1;
      end;

      i = 0;
      while (i < node.attributes.length)
         child = node.attributes.item(i);
         if( child and (child.nodeType == NODE_ATTR) )
            if ( substr(child.NodeName(), 1, 5) == "xmlns" )
               if ( child.NodeName() == "xmlns" )
                  ConditionAdd(child.NodeValue, "", div_nmsp);
               else
                  ConditionAdd(child.NodeValue, substr(child.NodeName(), 7), div_nmsp);
               end;
            end;
         end;
         i = i + 1;
      end;

      if ( valtype(div_nmsp) != V_UNDEF )
         div_nmsp.SortByPrefix();
         div_nmsp.TakeNewPrefix();
      end;
   end;

   /* Создает список пространств имен для актуальных только для текущего узла (не считая дочерних) */
   macro CreateLocal(current_nmsp, node)
      var child : object, i : integer, pref;

      m_URI.size = 0;
      pref     = GetPrefix( node.NodeName() );
      copy( current_nmsp, current_nmsp.FindByPrefix(pref) );

      i = 0;
      while (i < node.attributes.length)
         child = node.attributes.item(i);
         if( child and (child.nodeType == NODE_ATTR) )
            pref = GetPrefix( child.NodeName() );
            /* На атрибуты действует пространство имени узла, а не пространство имен по умолчанию */
            if ( pref!="" )
               copy( current_nmsp, current_nmsp.FindByPrefix(pref) );
            end;
         end;
         i = i + 1;
      end;

      SortByURI();
      CreateNewPrefix();

   end;

   /* Вставляем описания пространств имен в узел */
   macro InsertNamespaces( item: object )
      var i : integer = 0;
      while ( i < Length() )
         if ( (i == 0) OR (m_newPrefix[i] != m_newPrefix[i - 1]) )
            item.setAttribute("xmlns:" + m_newPrefix[i], m_URI[i]);
         end;
         i = i + 1;
      end;
   end;

   /* Получить имя узла в соответствии с требованиями нормализации */
   macro TrueNameNode( name )
      var   pref : string  = GetPrefix(name)
         ,  ind : integer  = FindByPrefix(pref);
      if (ind < 0)
         if ( pref != "" )
            RunError("Существуют неизвестные префиксы пространств имен");
         else
            return name;
         end;
      end;
      return m_newPrefix[ind] + ":" + GetNodeName(name);
   end;

   /* Получить имя атрибута в соответствии с требованиями нормализации */
   macro TrueNameAttr(name : string) : string
      var   pref  : string = GetPrefix(name)
         ,  ind   : integer;
      if (pref != "")
         ind = FindByPrefix(pref);
         if (ind < 0)
            RunError("Существуют неизвестные префиксы пространств имен");
         end;
         return m_newPrefix[ind] + ":" + GetNodeName(name);
      else
         return name;
      end;
   end;

   macro Construct()
      m_URI.size = 0;
   end;

   Construct();
end;     // << class Namespaces


//------------------------------------------------------------------------------------------//


// Проверяет, содержит ли строка не пробельные символы.
private macro IsFill(str : string) : bool
   var   i     : integer   = 0
      ,  len   : integer   = strlen(str)
      ,  smb   : string;
   while (i < len)
      smb = substr(str, i + 1, 1);
      if (     (smb != " ")
         and   (smb != strfor(10))
         and   (smb != strfor(13))
         and   (smb != strfor(9))
         )
         return true;
      end;
      i = i + 1;
   end;
   return false;
end;

private macro SortNamespacesNode (  IsDelComment
                                 ,  node : object
                                 ,  xml : object
                                 ,  parent_nmsp : Namespaces
                                 ,  parentNode : object
                                 )
   var   cur_nmsp   = Namespaces
      ,  child_nmsp = Namespaces
      ,  child : object
      ,  it : object
      ,  i
      ,  IsNeedCloseNode : bool = true;

   child_nmsp.CreateGlobal(parent_nmsp, node);
   cur_nmsp.CreateLocal(child_nmsp, node);

   it = xml.createElement( cur_nmsp.TrueNameNode(node.NodeName()) );

   cur_nmsp.InsertNamespaces(it);

   i = 0;
   while( i < node.attributes.length )
      child = node.attributes.item(i);
      if( child and (child.nodeType == NODE_ATTR) )
         if ( substr(child.NodeName(), 1, 5) != "xmlns" )
            it.setAttribute( cur_nmsp.TrueNameAttr(child.NodeName()), child.NodeValue );
         end;
      end;
      i = i + 1;
   end;

   i = 0;
   while (i < node.childNodes.length)
      child = node.childNodes.item(i);
      if( child and (child.nodeType == NODE_CHILD) )
         SortNamespacesNode(IsDelComment, child, xml, child_nmsp, it);
         IsNeedCloseNode = false;
      elif ( child and (child.nodeType == NODE_TEXT) )
         if ( IsFill(child.nodeValue) )
            it.appendChild( xml.createTextNode(child.nodeValue) );
            IsNeedCloseNode = false;
         end;
      elif ( child and (child.nodeType==NODE_COMMENT) and (not IsDelComment) )
         it.appendChild( xml.createComment(child.nodeValue) );
         /* Использование этих блоков в УФЭБС запрещен */
         /*elif ( child and (child.nodeType==NODE_CDATA_SECTION) )
         it.appendChild( xml.createCDATASection(child.nodeValue) );
         elif ( child and (child.nodeType==NODE_ENTITY_REFERENCE) )
         it.appendChild( xml.createEntityReference(child.nodeValue) );*/
      end;
      i = i + 1;
   end;

   /* Насильно закрываем тег */
   if (IsNeedCloseNode)
      it.appendChild(xml.createTextNode(""));
   end;

   if ( valtype(parentNode) == V_UNDEF )
      xml.appendChild(it);
   else
      parentNode.appendChild(it);
   end;
end;

private macro SortNamespaces(node : object, xml : object, IsDelComment)
   var arr_nmsp = Namespaces, i, child : object;

   if (node.NodeType == NODE_DOCUMENT)
      i = 0;
      while (i < node.childNodes.length)
         child = node.childNodes.item(i);
         if( child and (child.nodeType == NODE_CHILD) )
            SortNamespacesNode( IsDelComment, child, xml, arr_nmsp );
         elif ( child and (child.nodeType == NODE_COMMENT) and (not IsDelComment) )
            xml.appendChild( xml.createComment(child.nodeValue) );
            /* Использование этих блоков в УФЭБС запрещен */
            /*elif ( child and (child.nodeType==NODE_CDATA_SECTION) )
            xml.appendChild( xml.createCDATASection(child.nodeValue) );
            elif ( child and (child.nodeType==NODE_ENTITY_REFERENCE) )
            xml.appendChild( xml.createEntityReference(child.nodeValue) );*/
         end;
         i = i + 1;
      end;
      return;
   end;

   SortNamespacesNode( IsDelComment, node, xml, arr_nmsp );
end;

private macro CanonizationFirstPassNode(  IsDelComment
                                       ,  node : object
                                       ,  xml : object
                                       ,  parent_nmsp : Namespaces
                                       ,  parentNode:object
                                       )
   var attr       = Attributes;
   var div_nmsp   = Namespaces;
   var child_nmsp = Namespaces;
   var child : object, item : object, i;
   var IsNeedCloseNode : bool = true;

   if ( index(node.NodeName(), "SigContainer") > 0 )
      return;
   end;

   child_nmsp.CreateGlobal(parent_nmsp, node, div_nmsp);

   item = xml.createElement( node.NodeName() );

   div_nmsp.InsertNamespaces(item);

   i = 0;
   while (i < node.attributes.length)
      child = node.attributes.item(i);
      if( child and (child.nodeType == NODE_ATTR) )
         if ( substr(child.NodeName(), 1, 5) != "xmlns" )
            attr.Add( child.NodeName(), child.NodeValue);
         end;
      end;
      i = i + 1;
   end;

   attr.SortAttr();
   attr.InsertAttributes(item);

   i = 0;
   while (i < node.childNodes.length)
     child = node.childNodes.item(i);
     if( child and (child.nodeType == NODE_CHILD) )
        CanonizationFirstPassNode(IsDelComment, child, xml, child_nmsp, item);
        IsNeedCloseNode = false;
     elif ( child and (child.nodeType == NODE_TEXT) )
        if ( IsFill(child.nodeValue) )
           item.appendChild( xml.createTextNode(child.nodeValue) );
           IsNeedCloseNode = false;
        end;
     elif ( child and (child.nodeType == NODE_COMMENT) and not IsDelComment )
        item.appendChild( xml.createComment(child.nodeValue) );
     /* Все это запретили в УФЭБС */
     /*elif ( child and (child.nodeType==NODE_CDATA_SECTION) )
        item.appendChild( xml.createCDATASection(child.nodeValue) );
     elif ( child and (child.nodeType==NODE_ENTITY_REFERENCE) )
        item.appendChild( xml.createEntityReference(child.nodeValue) );*/
     end;
     i = i + 1;
   end;

   /* Насильно закрываем тег */
   if ( IsNeedCloseNode )
      item.appendChild( xml.createTextNode("") );
   end;

   if ( valtype(parentNode) == V_UNDEF )
      xml.appendChild(item);
   else
      parentNode.appendChild(item);
   end;
end;

/* Удяляем избыточные пространства имен и сортируем аттрибуты */
private macro CanonizationFirstPass(node : object, xml : object, IsDelComment)
   var arr_nmsp = Namespaces, i, child:object;

   if ( node.NodeType == NODE_DOCUMENT )
      i = 0;
      while (i < node.childNodes.length)
         child = node.childNodes.item(i);
         if( child and (child.nodeType == NODE_CHILD) )
            CanonizationFirstPassNode( IsDelComment, child, xml, arr_nmsp );
         elif ( child and (child.nodeType == NODE_COMMENT) and not IsDelComment )
            xml.appendChild( xml.createComment(child.nodeValue) );
            /* Все это запретили в УФЭБС */
            /*elif ( child and (child.nodeType==NODE_CDATA_SECTION) )
            xml.appendChild( xml.createTextNode(child.nodeValue) );
            elif ( child and (child.nodeType==NODE_ENTITY_REFERENCE) )
            xml.appendChild( xml.createEntityReference(child.nodeValue) );*/
         end;
         i = i + 1;
      end;
      return;
   end;

   CanonizationFirstPassNode( IsDelComment, node, xml, arr_nmsp );

end;


macro isalpha(c : string) : bool
   var alpha : string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
   return ( index(alpha, c) > 0 );
end;


macro isalnum(c : string)
   var alpha="0123456789";
   if ( index(alpha, c) > 0 )
      return true;
   else
      return isalpha(c);
   end;
end;

private macro ReadFileToStr(srcFileName : string, bXmlClient : bool) : string

   if (bXmlClient)
      return CallRemoteRsl("sxml_wrm.mac", "ReadFileToStr_wrm", srcFileName);
   elif ( ExistFile(srcFileName) )
      //return ReadTxtFile(srcFileName);
   end;

   return "";
end;


private macro CanonizationSecondPass(srcFileName : string, bXmlClient : bool)

   var  ch,  smbInd, state, oldState;
   var  tmpstr : string, src : string, dstString : string;
   var  ind : integer = 0, len;
   var  stat : bool   = TRUE ;
   var  Pass : TArray = TArray(7);


   const ST_UNDEF    = 0,
         ST_NODE     = 1,
         ST_TEXT     = 2,
         ST_LAT      = 3,
         ST_EQ       = 4,
         ST_ATTR     = 5,
         ST_ATAP     = 6,
         IND_LT      = 0,
         IND_GT      = 1,
         IND_SPACE   = 2,
         IND_LAT     = 3,
         IND_DIGT    = 4,
         IND_EQ      = 5,
         IND_APOS    = 6,
         IND_DBAPOS  = 7,
         IND_OTHER   = 8;

   while (ind < 7)
      Pass[ind] = TArray(9);
      ind = ind + 1;
   end;

   Pass[0][0] = ST_NODE; Pass[0][1] = ST_UNDEF; Pass[0][2] = ST_UNDEF; Pass[0][3] = ST_UNDEF; Pass[0][4] = ST_UNDEF; Pass[0][5] = ST_UNDEF; Pass[0][6] = ST_UNDEF; Pass[0][7] = ST_UNDEF; Pass[0][8] = ST_UNDEF;
   Pass[1][0] = ST_NODE; Pass[1][1] = ST_TEXT ; Pass[1][2] = ST_NODE ; Pass[1][3] = ST_LAT  ; Pass[1][4] = ST_NODE ; Pass[1][5] = ST_NODE ; Pass[1][6] = ST_NODE ; Pass[1][7] = ST_NODE ; Pass[1][8] = ST_NODE ;
   Pass[2][0] = ST_NODE; Pass[2][1] = ST_TEXT ; Pass[2][2] = ST_TEXT ; Pass[2][3] = ST_TEXT ; Pass[2][4] = ST_TEXT ; Pass[2][5] = ST_TEXT ; Pass[2][6] = ST_TEXT ; Pass[2][7] = ST_TEXT ; Pass[2][8] = ST_TEXT ;
   Pass[3][0] = ST_NODE; Pass[3][1] = ST_TEXT ; Pass[3][2] = ST_LAT  ; Pass[3][3] = ST_LAT  ; Pass[3][4] = ST_LAT  ; Pass[3][5] = ST_EQ   ; Pass[3][6] = ST_NODE ; Pass[3][7] = ST_NODE ; Pass[3][8] = ST_NODE ;
   Pass[4][0] = ST_NODE; Pass[4][1] = ST_TEXT ; Pass[4][2] = ST_EQ   ; Pass[4][3] = ST_NODE ; Pass[4][4] = ST_NODE ; Pass[4][5] = ST_NODE ; Pass[4][6] = ST_NODE ; Pass[4][7] = ST_ATTR ; Pass[4][8] = ST_NODE ;
   Pass[5][0] = ST_ATTR; Pass[5][1] = ST_ATTR ; Pass[5][2] = ST_ATTR ; Pass[5][3] = ST_ATTR ; Pass[5][4] = ST_ATTR ; Pass[5][5] = ST_ATTR ; Pass[5][6] = ST_ATAP ; Pass[5][7] = ST_NODE ; Pass[5][8] = ST_ATTR ;
   Pass[6][0] = ST_ATAP; Pass[6][1] = ST_ATAP ; Pass[6][2] = ST_ATAP ; Pass[6][3] = ST_ATAP ; Pass[6][4] = ST_ATAP ; Pass[6][5] = ST_ATAP ; Pass[6][6] = ST_ATTR ; Pass[6][7] = ST_ATAP ; Pass[6][8] = ST_ATAP ;

   state       = ST_UNDEF;
   tmpstr      = "";
   dstString   = "";
   src         = ReadFileToStr(srcFileName, bXmlClient);
   len         = strlen(src);
   ind         = 0;
   dstString   = "";

   while (ind < len)
      ch = substr(src, ind + 1, 1);
      if (ch == "<")
         smbInd = IND_LT;
      elif (ch == ">")
         smbInd = IND_GT;
      elif (ch == " ")
         smbInd = IND_SPACE;
      elif ( isalpha(ch) )
         smbInd = IND_LAT;
      elif ( isalnum(ch) )
         smbInd = IND_DIGT;
      elif (ch == "=")
         smbInd = IND_EQ;
      elif (ch == "\'")
         smbInd = IND_APOS;
      elif (ch == "\"")
         smbInd = IND_DBAPOS;
      else
         smbInd = IND_OTHER;
      end;

      oldState = state;
      state = Pass[state][smbInd];

      if (  (     (state != ST_ATTR)
            AND   (state != ST_ATAP)
            AND   (state != ST_TEXT)
            )
         OR (     (oldState != ST_ATTR)
            AND   (oldState != ST_ATAP)
            AND   (oldState != ST_TEXT)
            )
         )
         if ( tmpstr != "" )
            dstString   = dstString+tmpstr;
            tmpstr      = "";
         end;
         dstString = dstString+ch;
      else
         if (ch == "\r")
            tmpstr = tmpstr + "&#xD;";
         elif ( (state == ST_ATTR) OR (state == ST_ATAP) )
            if (ch == "\t")
               tmpstr = tmpstr + "&#x9;";
            elif (ch == "\n")
               tmpstr = tmpstr + "&#xA;";
            elif ( (ch == "\"") AND (state == ST_ATAP) )
               tmpstr = tmpstr + "&quot;";
            else
               tmpstr = tmpstr + ch;
            end;
         else
            tmpstr = tmpstr + ch;
         end;
      end;
      ind = ind + 1;
   end;

   return dstString;
end;

private macro IndexEx(str1 : @string, str2 : string, nPos : integer)
   var   str   : string    = substr(str1, nPos)
      ,  i     : integer   = index(str, str2);
   if (i == 0)
      return 0;
   end;
   return i + nPos - 1;
end;

private macro __StrNumIndex(strSrc : @string, strToken : string, iPos : integer)
   var i = strlen(strToken), str : string;
   for
      iPos = IndexEx(@strSrc, strToken, iPos);
      if (iPos == 0)
         return 0;
      end;
      str = substr(@strSrc, iPos + i, 1);
      if ( ("0" < str) and (str < "9") )
         return iPos;
      end;
      iPos = iPos + 1;
   end;
end;

private macro parseXMLDocs(src : @string, docs : @TArray) : integer
   var iStart : integer, iEnd  : integer = 1, iRes : integer = 0;
   while (     ( (iStart   = __StrNumIndex(@src, "<n1:ED", iEnd)) > 0 )
         and   ( (iEnd     = __StrNumIndex(@src, "</n1:ED", iStart + 10)) > 0 )
         )
      iEnd        = iEnd   + 11;
      docs[iRes]  = substr(src, iStart, iEnd - iStart);
      iRes        = iRes + 1;
   end;
   return iRes;
end;

macro getchild(elem, szName : string, child : @object) : bool
   var   i  : integer = 0
      ,  n  : integer = elem.childNodes.length;
   while (i < n)
      child = elem.childNodes.item(i);
      if ( strcmpXML(szName, child.NodeName) )
         return true;
      end;
      i = i + 1;
   end;
   child = null;
   return false;
onError
   return false;
end;



//------------------------------------------------------------------------------------------//


class TXML(bMode : bool, encode:string )

//-АТРИБУТЫ--------------------------------------------------------------------

   var         m_bServer   : bool      = bMode;
   var         m_doc;
   private var m_obj;
   private var m_head;
   private var m_curr;
   private var m_isfirst   : bool;
   private var m_nErr      : integer   = 0;

//-МЕТОДЫ----------------------------------------------------------------------

   private macro adderror(iErr : integer) : integer
      if ( (m_nErr == 0) and (iErr != 0) )
         m_nErr = iErr;
      end;
      return m_nErr;
   end;

   private macro BuildXMLErrDesc() : string
      var str : string;

      if (m_doc.ParseError.errorCode == 0)
         return "";
      end;

      str   = "Ошибка XML-парсера: "   + m_doc.ParseError.errorCode
            + " "                      + m_doc.ParseError.reason
            + "\n URL:              "  + m_doc.ParseError.url;

      if (m_doc.ParseError.srcText == "")
         return str;
      end;

      return   str
            + "\n XML-код:          "  + m_doc.ParseError.srcText
            + "\n Позиция в файле:  "  + m_doc.ParseError.filepos
            + "\n Строка:           "  + m_doc.ParseError.line
            + "\n Позиция в строке: "  + m_doc.ParseError.linepos;
   end;

   private macro checkerror() : integer
      return adderror(m_doc.ParseError.errorCode);
   onError
      m_nErr = -1;
      return -1;
   end;

   private macro error() : integer
      var iErr = checkerror();
      if (iErr == 0)
         m_nErr = -1;
      end;
      return m_nErr;
   end;

   private macro __createXMLObj(xml : object, strName : string)
      var o : object;
      if (m_bServer)
         o = ActiveX(strName);
      else
         o = m_obj.CreateComObject(strName);
      end;
      SetParm(1, o);
      return true;
   OnError(er)
      return false;
   end;

   private macro CreateXMLObject()
      var o : object;
      if (  __createXMLObj(o, "MSXML2.DOMDocument")
         or __createXMLObj(o, "MSXML.DOMDocument")
//       or __createXMLObj(o, "MSXML2.DOMDocument.4.0")
         )
         return o;
       end;
      msgbox("Ошибка инициализации Active-X компонента.");
      exit(1);
   end;

   private macro Constructor(encode:string)
      var elemVersion : object; // << XMLDOMNode.

      if (not m_bServer)
         m_obj = CreateObject("rsax", "TRsAxServer", "RsAxServer", m_bServer);
      end;

      m_doc       = CreateXMLObject();   
      if ( ValType(encode) != V_UNDEF )
         elemVersion = m_doc.createProcessingInstruction("xml", "version=\"1.0\" encoding=\"" + encode + "\"");
      else
         elemVersion = m_doc.createProcessingInstruction("xml", "version=\"1.0\" encoding=\"WINDOWS-1251\"");
      end;
      m_doc.appendChild(elemVersion);
   onError
      msgbox("Ошибка инициализации Active-X компонента.\nВозможно необходимо переустановить Internet Explorer.");
      exit(1);
   end;

   private macro BaseNorm(d : @Object)
      d.normalize();
      return true;
   OnError
      return false;
   end;

   macro Normalize(IsDelComment : bool)
      var   doc_temp1 : object
         ,  doc_temp2 : object;

      if( BaseNorm(@m_doc) )
         return;
      end;

      doc_temp1 = CreateXMLObject();
      doc_temp2 = CreateXMLObject();

      if ( valtype(IsDelComment) == V_UNDEF )
         IsDelComment = true;
      end;

      doc_temp1 = m_doc;

      /* Удаляем аттрибуты, определяющие XML-схему */

      deleteAttrByNamespace(doc_temp1, "http://www.w3.org/2001/XMLSchema-instance");

      /* Сортируем пространства имен */
      SortNamespaces(doc_temp1, doc_temp2, IsDelComment);

      m_doc = doc_temp2;
   end;

   macro Canonize(IsDelComment : bool)
      var   doc_temp1 : object = CreateXMLObject()
         ,  doc_temp2 : object = CreateXMLObject();

      if ( valtype(IsDelComment) == V_UNDEF )
         IsDelComment = true;
      end;

      doc_temp1 = m_doc;

      /* Выполняем первый проход канонизации (второй сделает Си-код перед вычислением подписи) */
      CanonizationFirstPass(doc_temp1, doc_temp2, IsDelComment);
      m_doc = doc_temp2;
   end;

   macro Transform(isDelComment : bool)
      Normalize(isDelComment);
      Canonize(isDelComment);
   end;

   macro GetNCPacket(IsDelComment : bool, SignDoc : @string)
      var   doc_temp1 : object = CreateXMLObject()
         ,  doc_temp2 : object = CreateXMLObject()
         ,  doc_temp3 : object = CreateXMLObject()
         ,  temp_name : string;

      if ( valtype(IsDelComment) == V_UNDEF )
         IsDelComment = true;
      end;

      doc_temp1 = m_doc;

      if( BaseNorm(@doc_temp1) )
         doc_temp2 = doc_temp1;
      else
         doc_temp1 = m_doc;
         deleteAttrByNamespace(doc_temp1, "http://www.w3.org/2001/XMLSchema-instance");
         SortNamespaces(doc_temp1, doc_temp2, IsDelComment);
      end;

      CanonizationFirstPass(doc_temp2, doc_temp3, IsDelComment);

      temp_name = getWorkFileName("ufebs");

      WriteTxtFile(temp_name, doc_temp3.xml);

      SignDoc = CanonizationSecondPass(temp_name, not m_bServer);

      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
   onError(er)
      //Rethrow( er, "Нормализация XML-кода пакета ЭД" );
   end;

   macro GetNCDocs(IsDelComment : bool, SignSubDocs : @TArray)
       var  doc_temp1 : object = CreateXMLObject()
         ,  doc_temp2 : object = CreateXMLObject()
         ,  doc_temp3 : object = CreateXMLObject()
         ,  temp_name : string
         ,  res_str;

       if ( valtype(IsDelComment) == V_UNDEF )
          IsDelComment = true;
       end;

       doc_temp1 = m_doc;

       if ( BaseNorm(@doc_temp1) )
         doc_temp2 = doc_temp1;
       else
         doc_temp1 = m_doc;
         deleteAttrByNamespace(doc_temp1, "http://www.w3.org/2001/XMLSchema-instance");
         SortNamespaces(doc_temp1, doc_temp2, IsDelComment);
       end;

       CanonizationFirstPass(doc_temp2, doc_temp3, IsDelComment);

       temp_name = getWorkFileName("ufebs");

       WriteTxtFile(temp_name, doc_temp3.xml);

       res_str = CanonizationSecondPass(temp_name, not m_bServer);

       if ( parseXMLDocs(@res_str, @SignSubDocs) == 0 )
         RunError("", "Нормализация XML-документа");
       end;
   end;

   macro load(path : string)
      m_doc.load(path);
      if (m_doc.ParseError.errorCode);
         RunError( "", BuildXMLErrDesc() );
      end;
   onError(er)
      //Rethrow(er, "Загрузка XML-документа");
   end;

   macro save(path : string, encode:string )

      var Str_xml = "";
      var l_parm  = p_REGVAL_2;
      if ((l_parm != NULL) AND (l_parm == "X"/*95148*/))     
         Str_xml = m_doc.xml;
         Str_xml = StrSubst(Str_xml,"><",">\n<");
         if ( ValType(encode) != V_UNDEF )
            Str_xml = StrSubst(Str_xml,"<?xml version=\"1.0\"?>","<?xml version=\"1.0\" encoding=\"" + encode + "\"?>");
         else
            Str_xml = StrSubst(Str_xml,"<?xml version=\"1.0\"?>","<?xml version=\"1.0\" encoding=\"WINDOWS-1251\"?>");
         end;
         m_doc.LoadXml(Str_xml);
      end;
      m_doc.save(path);
      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;

      if ( not p_noSaveArh )
         var szFileName = "";
         var szExtFile = "";
         var szSendDir = SplitFile(path,szFileName,szExtFile);
         var szArhPath = MergeFile(p_REGVAL_4,szFileName,szExtFile);
         if (StrUpr(path) != StrUpr(szArhPath))
            m_doc.save(szArhPath);
         end;
      end;
   onError(er)
      //Rethrow(er, "Сохранение XML-документа");
   end;

   macro createelem(name : string) : object /* << XMLDOMElement */
      return m_doc.createElement(name);
   end;

   macro add(pname, cname) : object /* : XMLDOMNode */
      var prnt, chld : object /* << XMLDOMNode */, i : integer = 0;

      if ( (valtype(cname) == V_UNDEF) or ( (valtype(pname) == V_STRING) and (pname == "")) )
         chld = m_doc.createElement(pname);
         m_doc.appendChild(chld);
      elif ( valtype(pname) == V_GENOBJ )
         pname.appendChild(cname);
      elif ( valtype(pname) == V_STRING )
         prnt = m_doc.DocumentElement.SelectNodes(pname);
         chld = m_doc.createElement(cname);
         while ( i < prnt.length )
            prnt.item(i).appendChild(chld);
            i = i + 1;
         end;
      end;
      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
      return chld;
   onError(er)
      //Rethrow(er, "Добавление XML-элемента");
   end;

   macro addelem(pname : string, chld : object /* << XMLDOMNode */)
      var prnt, i = 0;

      prnt = m_doc.DocumentElement.SelectNodes(pname);
      while ( i < prnt.length )
         prnt.item(i).appendChild(chld);
         i = i + 1;
      end;

      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
   onError(er)
      //Rethrow(er, "Добавление XML-элемента");
   end;

   macro setattr(pname : string, name, value, num)
      var i = 0, prnt = m_doc.DocumentElement.SelectNodes(pname);

      if ( valtype(num) == V_INTEGER )
         if ( (num > 0) and (num <= prnt.length) )
            prnt.item(num - 1).SetAttribute( name, valtoxml(value) );
         end;
      else
         while ( i < prnt.length )
            prnt.item(i).SetAttribute( name, valtoxml(value) );
            i = i + 1;
         end;
      end;

      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
   onError(er)
      //Rethrow(er, "Запись XML-атрибута");
   end;

   macro setval(pname : string, value, num)
      var i : integer = 0, prnt = m_doc.DocumentElement.SelectNodes(pname);
      var j : integer = 0, chld : TArray;

      if ( valtype(num) == V_INTEGER )
         if ( (num > 0) and (num <= prnt.length) )
            j = 0;
            chld = TArray;
            while ( j < prnt.item(num - 1).childNodes.length )
               chld[j] = prnt.item(num - 1).childNodes.item(j);
               j = j + 1;
            end;
            prnt.item(num - 1).text = valtoxml(value);
            j = 0;
            while (j < chld.size)
               prnt.item(num - 1).appendChild(chld[j]);
               j = j + 1;
            end;
         end;
      else
         while (i < prnt.length)
            j = 0;
            chld = TArray;
            while ( j < prnt.item(i).childNodes.length )
               chld[j] = prnt.item(i).childNodes.item(j);
               j = j + 1;
            end;
            prnt.item(i).text = valtoxml(value);
            j = 0;
            while (j < chld.size)
               prnt.item(i).appendChild(chld[j]);
               j = j + 1;
            end;
            i = i + 1;
         end;
      end;

      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
   onError(er)
      //Rethrow(er, "Запись XML-атрибута");
   end;

   macro replval(pname : string, value)
      var prnt = m_doc.DocumentElement.SelectNodes(pname);

      prnt.item(0).text = valtoxml(value);

      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
   end;

   macro SetSigToDocs(SDocs : TArray, prntNode : object) : integer
      var   iItem : integer = 0
         ,  iDoc  : integer = 0
         ,  prnt  : object /* << XMLDOMNodeList */ = prntNode.childNodes
         ,  ptr   : object /* << XMLDOMNode */;

      if ( prnt.item(0).childNodes.length == 0 )
         iItem = 1;
      end;

      while (iItem < prnt.length)
         ptr = createelem("sig:SigValue");
         ptr.setAttribute("xmlns:sig","urn:cbr-ru:dsig:v1.1");
         ptr.text = " " + SDocs[iDoc];
         prnt.item(iItem).insertBefore( ptr, prnt.item(iItem).childNodes.item(0) );
         iItem = iItem  + 1;
         iDoc  = iDoc   + 1;
      end;

      if (m_doc.ParseError.errorCode)
         RunError( "", BuildXMLErrDesc() );
      end;
      return iDoc;
   onError(er)
      //Rethrow(er, "Установка ЭЦП на документ");
   end;

   macro findelem(pname : string, elem : @variant, num) : integer
      var lst;

      if (pname == null)
         elem = m_doc.DocumentElement.parentNode;
         return 0;
      end;

      lst = m_doc.DocumentElement.SelectNodes(pname);

      if ( (valtype(num) == V_INTEGER) and (num >= 0) and (num < lst.length) )
         elem = lst.item(num);
         return 0;
      end;
      return 1;
   onError(er)
      //Rethrow(er, "Поиск XML-элемента");
   end;

   macro getRoot() : object
      return m_doc.childNodes(m_doc.childNodes.length - 1);
   end;

   macro rewind(pname) : integer
      m_isfirst   = true;
      m_curr      = 0;
      return findelem(pname, @m_head, 0);
   onError
      return error();
   end;

   macro next() : integer
      if (not m_head.hasChildNodes)
         return 0;
      end;
      if (m_isfirst)
         m_isfirst = false;
         if (not m_head.hasChildNodes)
            return 0;
         end;
         m_curr = m_head.FirstChild;
      else
         if ( ValType(m_curr.NextSibling) == V_UNDEF )
            return 0;
         end;
         m_curr = m_curr.NextSibling;
      end;

      return 1;
   onError
      return error();
   end;

   macro getcurr()
      return m_curr;
   onError
      return error();
   end;

   macro gethead()
      return m_head;
   onError
      return error();
   end;

   macro getattr(attr, name, value : @variant, type : integer) : integer
      if ( strcmpXML(attr.nodeName, name) )
         value = xmltoval(attr.nodeValue, type);
      end;
      return 0;
   onError
      return error();
   end;

//-----------------------------------------------------------------------------
   Constructor(encode);

END;
