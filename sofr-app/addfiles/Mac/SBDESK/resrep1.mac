/*
$Name: resrep1.mac
$Module: Касса
$Description: Ф. 25-а 
*/

/* закомментировано при удалении таблицы ddesk_rec_dbt по ##197859, 198467 */
/*

import BankInter, deprintr, ChkPrn, Stat_Tot, ResComm, Res1_Out, sign_rep, sqlConv, chkboss, RSD;

/* Взведите в true для выпуска отчета по наращенным процентам */

const
  ОТЧЕТ_ПО_НАРАЩЕННЫМ = true;

const
  Rdt_Chapt4 = 0,
  Rdt_AccumPc = 1;  

const
  CK_NEW          = 0, 
  CK_OLD          = 1;

private const
  DST_IO          = 1,                  /* Инкассация */
  DST_SAFE        = 2,                  /* Сейф */
  DST_WORKDESK    = 3,                  /* Рабочий стол кассира */
  DST_RDESK       = 4,                  /* Касса пересчета */
  DST_PANTRY      = 5,                  /* Кладовая отделения */
  DST_EDESK       = 6,                  /* Вечерняя касса */
  DST_TCD         = 11;                 /* Сейф TCD */

private var vBalAcc, vBalAccNR;
private var vKind = "";

// -------------------------------------------
//    Поиск балансовых счетов 2-го порядка.
// -------------------------------------------
private macro BalAccForKind( FlagCur, Kind )

  var cmdA, rsA;
  var vFind = false;
  var groupId = 0;

  cmdA = RsdCommand( "select ng.t_BalAcc2 as rBalAcc, ng.t_BalAcc2NotResid as rBalAccNR "
                       "from dsbnumgrp_dbt ng "
                       "where ng.t_groupid = "
                         "( select min(typgrp.t_groupid) "
                             "from dsbtypgrp_dbt typgrp "
                             "where typgrp.t_flagcur = :flagCur and "
                                  "typgrp.t_kind = :kind )" );

  rsA = RsdRecordset( cmdA );

  cmdA.addParam( "flagCur", RSDBP_IN, FlagCur );
  cmdA.addParam( "kind", RSDBP_IN, Kind );

  cmdA.execute;

  vBalAcc   = "";
  vBalAccNR = "";

  if ( rsA.moveNext() )
    vBalAcc   = rsA.value( "rBalAcc" );
    vBalAccNR = rsA.value( "rBalAccNR" );
    vFind = true;
  end;

  return vFind;
end;

// -------------------------------------------
//    Проверка наличия записей статистики.
// -------------------------------------------
private macro StatForCurDayExists( pFlagRez )

  var cmdA, rsA;

  cmdA = RsdCommand( "select count(*) from dsb_depst_dbt s "
                       "where s.t_FNCash = ? and "
                             "s.t_IsCur = ? and "
                             "s.t_Kind = ? and "
                             "s.t_CodCur = ? and "
                             "s.t_FlagRez = chr(?) and "
                             "( s.t_Date < ? or "
                               "( s.t_Date = ? and "
                                 "s.t_Mode <= ? ) )" );

  rsA = RsdRecordset( cmdA );

  cmdA.addParam( "fncash",  RSDBP_IN, Branch );
  cmdA.addParam( "iscur",   RSDBP_IN, IsCur );
  cmdA.addParam( "kind",    RSDBP_IN, vKind );
  cmdA.addParam( "codcurr", RSDBP_IN, Currency.rec.Code_Currency );
  cmdA.addParam( "rez",     RSDBP_IN, pFlagRez );
  cmdA.addParam( "date1",   RSDBP_IN, {curdate} );
  cmdA.addParam( "date2",   RSDBP_IN, {curdate} );
  cmdA.addParam( "mode",    RSDBP_IN, Mode );

  cmdA.execute;

  return rsA.moveNext();
end;

macro ReportOnCurCIResource;

  var
    PrevRest=$0, IPrevRest = 0,
    CurRest=$0, ICurRest = 0,
    Deb=$0, IDeb = 0,
    Cred=$0,ICred = 0,  
    OtherDeb=$0, IOtherDeb = 0,
    OtherCred=$0, IOtherCred = 0;

  if ( not IsShown )
    return;
  end;

  CalcTurns(CashVal.rec.RefValue,Cred,ICred,Deb,IDeb);
  CalcOtherTurns(CashVal.rec.RefValue,OtherCred,IOtherCred,OtherDeb,IOtherDeb);

  if ( IsKept )
    CashAcc.addFilter("t.t_Branch = " + string( Branch ) +
		      " and t.t_CashOper = " + GetSQLString( Safe ) + 
		      " and t.t_SubAccount = " + GetSQLString( "" ) +
		      " and t.t_RefValue = " + string( CashVal.rec.RefValue ) );
    CashAcc.KeyNum = 2;
    CashAcc.rec.Branch=Branch;
    CashAcc.rec.CashOper=Safe;
    CashAcc.rec.SubAccount="";
    CashAcc.rec.RefValue=CashVal.rec.RefValue;
    CashAcc.rec.Date={curdate};
    if( CashAcc.GetLT and
      (CashAcc.rec.Branch==Branch) and
      (CashAcc.rec.RefValue==CashVal.rec.RefValue) and
      (CashAcc.rec.CashOper==Safe) and
      (CashAcc.rec.SubAccount==""))
      IPrevRest=CashAcc.rec.RestCol;
      if ( CashAcc.rec.RestMoney )
        PrevRest = CashAcc.rec.RestMoney;
      else
        PrevRest = $1 * CashAcc.rec.RestCol;
      end;
    end;
    CashAcc.dropFilter;
  else
    PrevRest = $0;
  end;


  CashAcc.KeyNum = 1;
  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper=Safe;
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if( CashAcc.GetEQ )
    ICurRest=CashAcc.rec.RestCol;
    if ( CashAcc.rec.RestMoney )
      CurRest = CashAcc.rec.RestMoney;
    else
      CurRest = $1 * CashAcc.rec.RestCol;
    end;
  end;

  if ( Mode )
    PrevRest = CurRest;
    Deb = Cred = OtherDeb = OtherCred = $0;
    IPrevRest = ICurRest;
    IDeb = ICred = IOtherDeb = IOtherCred = 0;
  end;

  if ( CashVal.rec.TypeValue == TYPERES_MINCAPISSUE + CI_COIN )
    if ( CIMisc.KindOfCoin == CK_OLD )
      OutCoinLineW(GetValName,PrevRest,IPrevRest,CurRest,ICurRest,Cred,ICred,OtherCred,IOtherCred,Deb,IDeb,OtherDeb,IOtherDeb);
    else
      OutCoinLine(GetValName,PrevRest,IPrevRest,CurRest,ICurRest,Cred,ICred,OtherCred,IOtherCred,Deb,IDeb,OtherDeb,IOtherDeb);
    end;
  else
    OutCILine(GetValName,PrevRest,IPrevRest,CurRest,ICurRest,Cred,ICred,OtherCred,IOtherCred,Deb,IDeb,OtherDeb,IOtherDeb,false);
  end;

end;

macro GetCurrCodeForValue

  var
    SaveKey = CashVal.KeyNum,
    Pos,
    CurrCode = 0;

  if ( CashVal.rec.GroupValue )
    Pos = CashVal.GetPos;
    CashVal.KeyNum = 0;
    CashVal.rec.RefValue = CashVal.rec.GroupValue;
    if ( CashVal.GetEQ and ( CashVal.rec.TypeValue == CV_Currency ) )
      CurrCode = CashVal.rec.CodIntValue;
    end;
    CashVal.KeyNum = SaveKey;
    CashVal.GetDirect( Pos );
  else
    if ( CashVal.rec.RefValueReport == 1 )
      CurrCode = 1;
    end; 
  end;
  return CurrCode;
end;

macro ReportOnCIResources;

  var stat;

  if ( Chapter == 1 )
    TotPrevRest  = 0;
    TotCredit    = 0;
    TotDebet     = 0;
    TotOtherCred = 0;
    TotOtherDeb  = 0;
    TotRest      = 0;
    TotPrevRestA  = $0.0L;
    TotCreditA    = $0.0L;
    TotDebetA     = $0.0L;
    TotOtherCredA = $0.0L;
    TotOtherDebA  = $0.0L;
    TotRestA      = $0.0L;
    TotPrevRestPurposeP  = 0;
    TotCredPurposeP      = 0;
    TotDebPurposeP       = 0;
    TotOtherCredPurposeP = 0;
    TotOtherDebPurposeP  = 0;
    TotCurRestPurposeP   = 0;
    TotPrevRestPurpose  = $0.0L;
    TotCredPurpose      = $0.0L;
    TotDebPurpose       = $0.0L;
    TotOtherCredPurpose = $0.0L;
    TotOtherDebPurpose  = $0.0L;
    TotCurRestPurpose   = $0.0L;
    Chapter1IsEmpty = true;
  end;

  SmthPrinted = false;

  CashVal.addFilter("t.t_FlagIntoBalance = " + string( Chapter ) +
                    " and exists ( select a.t_Branch from dsb_casac_dbt a where "
                    " a.t_Branch = " + string( Branch ) +
                    " and a.t_CashOper = " + GetSQLString( Safe ) +
                    " and a.t_SubAccount = " + GetSQLString( "" ) +
                    " and a.t_RefValue = t.t_RefValue" +
                    " and a.t_Date = " + sqlDateToStr( {curdate} ) +
                    " )" );

  CashVal.rec.FlagIntoBalance = Chapter;
  stat = CashVal.GetGE;
  while (stat and (CashVal.rec.FlagIntoBalance == Chapter) )
    if ( (CashVal.rec.TypeValue != TYPERES_MINCAPISSUE + CI_COIN) AND
	 ( GetCurrCodeForValue == Currency.rec.Code_Currency )  )
      ReportOnCurCIResource();
    end;
    stat = CashVal.Next;
  end;
  CashVal.dropFilter;

  if( ( Chapter == 2 ) and ( not IsCur ) )
    CashVal.rec.TypeValue = TYPERES_MINCAPISSUE + CI_MISC;
    OutCILine("Целевые займы",0,0,0,0,0,0,0,0,0,0,0,0,true);
  end;
  
  if ( SmthPrinted )
    OutCITotLine;
  end;
end;

macro ReportOnCoinResourcesForMetal( NoWeight );

  var stat;

  MetalSubHeadPrinted = false;

  CashVal.addFilter("t.t_FlagIntoBalance = " + string( Chapter ) +
                    " and exists ( select a.t_Branch from dsb_casac_dbt a where "
                    " a.t_Branch = " + string( Branch ) +
                    " and a.t_CashOper = " + GetSQLString( Safe ) +
                    " and a.t_SubAccount = " + GetSQLString( "" ) +
                    " and a.t_RefValue = t.t_RefValue" +
                    " and a.t_Date = " + sqlDateToStr( {curdate} ) +
                    " )" );

  CashVal.rec.FlagIntoBalance = Chapter;
  stat = CashVal.GetGE;
  while( (stat) and (CashVal.rec.FlagIntoBalance == Chapter) )
    if ((CashVal.rec.RefValueReport != 1 ) AND
        (CashVal.rec.TypeValue == TYPERES_MINCAPISSUE + CI_COIN) )
      FindCIMisc( CI_COIN, CashVal.rec.CodIntValue );
      if ( ( NoWeight and ( CIMisc.KindOfCoin == CK_NEW ) )
        or ( ( not NoWeight ) and ( CIMisc.KindOfCoin == CK_OLD ) ) )
        if ( CIMisc.MaterialRef == CICode.AutoKey )
          ReportOnCurCIResource();
        end;
      end;
    end;
    stat = CashVal.Next;
  end;
  CashVal.dropFilter;
end;

macro ReportOnCoinResources( NoWeight );

  var
    RecFound;

  TotPrevRest  = 0;
  TotCredit    = 0;
  TotDebet     = 0;
  TotOtherCred = 0;
  TotOtherDeb  = 0;
  TotRest      = 0;
  TotPrevRestA  = $0.0L;
  TotCreditA    = $0.0L;
  TotDebetA     = $0.0L;
  TotOtherCredA = $0.0L;
  TotOtherDebA  = $0.0L;
  TotRestA      = $0.0L;

  if ( NoWeight )
    OutCoinHeader;
  else
    OutCoinHeaderW;
  end;

  ClearRecord( CICode );
  CICode.UpLink = 0;
  CICode.Group = 2; /* CRE_MATERIAL */
  RecFound = GetGE( CICode );
  while ( RecFound
    and ( CICode.UpLink == 0 ) 
    and ( CICode.Group == 2 ) ) /* CRE_MATERIAL */
    ReportOnCoinResourcesForMetal( NoWeight );
    RecFound = Next( CICode );
  end;
  if ( NoWeight )
    OutCoinTotLine;
  else
    OutCoinTotLineW;
  end;
  OutCoinTail;
end;

macro ReportOnCurVFResource;

  var
    PrevRest=$0, IPrevRest = 0,
    CurRest=$0, ICurRest = 0,
    Deb=$0, IDeb = 0,
    Cred=$0,ICred = 0,  
    OtherDeb=$0, IOtherDeb = 0,
    OtherCred=$0, IOtherCred = 0;

  if ( not IsShown )
    return;
  end;

  CalcTurns(CashVal.rec.RefValue, Cred, ICred, Deb, IDeb);
  CalcOtherTurns(CashVal.rec.RefValue,OtherCred, IOtherCred, OtherDeb, IOtherDeb);

  if ( IsKept )
    CashAcc.addFilter("t.t_Branch = " + string( Branch ) +
		      " and t.t_CashOper = " + GetSQLString( Safe ) + 
		      " and t.t_SubAccount = " + GetSQLString( "" ) +
		      " and t.t_RefValue = " + string( CashVal.rec.RefValue ) );
    CashAcc.KeyNum = 2;
    CashAcc.rec.Branch=Branch;
    CashAcc.rec.CashOper=Safe;
    CashAcc.rec.SubAccount="";
    CashAcc.rec.RefValue=CashVal.rec.RefValue;
    CashAcc.rec.Date={curdate};
    if( CashAcc.GetLT and
      (CashAcc.rec.Branch==Branch) and
      (CashAcc.rec.RefValue==CashVal.rec.RefValue) and
      (CashAcc.rec.CashOper==Safe) and
      (CashAcc.rec.SubAccount==""))
      IPrevRest=CashAcc.rec.RestCol;
      if ( CashAcc.rec.RestMoney )
        PrevRest = CashAcc.rec.RestMoney;
      else
        PrevRest = $1 * CashAcc.rec.RestCol;
      end;
    end;
    CashAcc.dropFilter;
  else
    PrevRest = $0;
  end;

  CashAcc.KeyNum = 1;
  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper=Safe;
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if( CashAcc.GetEQ )
    ICurRest=CashAcc.rec.RestCol;
    if ( CashAcc.rec.RestMoney )
      CurRest = CashAcc.rec.RestMoney;
    else
      CurRest = $1 * CashAcc.rec.RestCol;
    end;
  end;

  if ( Mode )
    PrevRest = CurRest;
    Deb = Cred = OtherDeb = OtherCred = $0;
    IPrevRest = ICurRest;
    IDeb = ICred = IOtherDeb = IOtherCred = 0;
  end;

  OutVFLine(GetValName,PrevRest,IPrevRest,CurRest,ICurRest,Cred,ICred,OtherCred,IOtherCred,Deb,IDeb,OtherDeb,IOtherDeb);

end;

macro ReportOnVFResources;

  CashVal.rec.FlagIntoBalance = 3;

  OutVFHeader;

  CashVal.addFilter("t.t_FlagIntoBalance = 3 " +
                    " and exists ( select a.t_Branch from dsb_casac_dbt a where "
                    " a.t_Branch = " + string( Branch ) +
                    " and a.t_CashOper = " + GetSQLString( Safe ) +
                    " and a.t_SubAccount = " + GetSQLString( "" ) +
                    " and a.t_RefValue = t.t_RefValue" +
                    " and a.t_Date = " + sqlDateToStr( {curdate} ) +
                    " )" );

  if(CashVal.GetGE and (CashVal.rec.FlagIntoBalance==3))
    if(CashVal.rec.RefValueReport!=1)
      ReportOnCurVFResource;
    end;
    while(CashVal.Next and (CashVal.rec.FlagIntoBalance==3))
      if(CashVal.rec.RefValueReport!=1)
        ReportOnCurVFResource;
      end;
    end;
  end;
  CashVal.dropFilter;
  OutVFTotLine;
end;

macro ReportOnCurDepType(Citizenship,TypeReport,pBalAcc)

  record TmpStat("sb_depst.dbt");

  if ( Citizenship )
    tBalAccNR = pBalAcc;
  else
    tBalAcc   = pBalAcc;
  end;

  DepType.rec.FlagCur = IsCur;
  DepType.rec.Kind    = vKind;
  if ( NOT DepType.GetEQ() )
    DepType.rec.Name = vKind;
  end;

  DepStat.rec.FNCash=Branch;
  DepStat.rec.IsCur=IsCur;
  DepStat.rec.Kind=vKind;
  DepStat.rec.CodCur=Currency.rec.Code_Currency;
  DepStat.rec.FlagRez=Citizenship;
  DepStat.rec.BalAcc=pBalAcc;
  DepStat.rec.Date={curdate};
  DepStat.rec.Mode = Mode;                                

  DepStat.addFilter("t.t_FNCash = " + string(Branch) +
		    " and t.t_IsCur = " + string(IsCur) + 
		    " and t.t_Kind = " + GetSQLString( DepType.rec.Kind ) + 
		    " and t.t_CodCur = " + string(Currency.rec.Code_Currency) +
		    " and t.t_FlagRez = " + sqlChar( Citizenship ) );

  if(not (DepStat.GetLE
     and (DepStat.rec.FNCash==Branch)
     and (DepStat.rec.IsCur==IsCur)
     and (DepStat.rec.Kind==vKind)
     and (DepStat.rec.CodCur==Currency.rec.Code_Currency)
     and (DepStat.rec.FlagRez==Citizenship)
     and (DepStat.rec.BalAcc==pBalAcc)))
    DepStat.dropFilter;
    return ;
  end;

  if( ( DepStat.rec.Date=={curdate} ) and ( DepStat.rec.Mode == Mode ) )
    Copy(TmpStat,DepStat);
    if(DepStat.Prev
      and (DepStat.rec.FNCash==Branch)
      and (DepStat.rec.IsCur==IsCur)
      and (DepStat.rec.Kind==vKind)
      and (DepStat.rec.CodCur==Currency.rec.Code_Currency)
      and (DepStat.rec.FlagRez==Citizenship)
      and (DepStat.rec.BalAcc==pBalAcc))
      Copy(PrevStat,DepStat);
      Copy(DepStat,TmpStat);
    else
      ClearRecord(PrevStat);
      Copy(DepStat,TmpStat);
    end;
  else
    Copy(PrevStat,DepStat);
    DepStat.rec.CurOpenAc    = 0;
    DepStat.rec.CurClosAc    = 0;
    DepStat.rec.DebSum       = 0;
    DepStat.rec.KredSum      = 0;
    DepStat.rec.EstimIn      = 0;
    DepStat.rec.EstimOut     = 0;
    DepStat.rec.EstimOverOut = 0;
  end;

  if (TypeReport == 0)
    OutDepLine();
  else
    OutDepLine2();
  end;

  DepStat.dropFilter;
end;

macro StatForCurDayExistsCond( Citizenship )

  var 
    rv;

  rv = " exists ( select s.t_FNCash from dsb_depst_dbt s where " +
       " s.t_FNCash = " + string( Branch ) +
       " and s.t_IsCur = " + string( IsCur ) +
       " and s.t_Kind = t.t_Kind" + 
       " and s.t_CodCur = " + string( Currency.rec.Code_Currency ) +
       " and ( s.t_Date < " + sqlDateToStr( {curdate} ) + 
       " or ( s.t_Date = " + sqlDateToStr( {curdate} ) + " and s.t_Mode <= " + string( Mode ) + ") ) )";
                                       
  if ( Citizenship != null )
    rv = rv + " and s.t_FlagRez = " + sqlChar( Citizenship );
  end;

  rv = rv + " )";

  return rv;
end;

macro ReportOnDepTypes( mode )

  var stat;
  var i,j,k;
  var cmdN, rsN, cmdG, rsG;
  var BA_TMP;
  array ABalAcc,BalAcc;

  SmthPrinted = false;

  TotPrevAcc=0;
  TotAcc=0;
  TotOpenedAcc=0;
  TotClosedAcc=0;

  TotPrevRest = $0L;
  TotCredit   = $0L;
  TotDebet    = $0L;
  TotRest     = $0L;

  TotPrevEstimRest = $0L;
  TotEstimIn       = $0L;
  TotEstinOut      = $0L;
  TotEstimOverOut  = $0L;
  TotEstimRest     = $0L;

  DepType.KeyNum = 2;
  DepType.rec.FlagCur = IsCur;
  DepType.rec.Kind    = "";

  DepType.AddFilter( "t_FlagCur = " + string( IsCur ) +
                     " and " + StatForCurDayExistsCond() );

  stat = DepType.GetGE;
  while (stat and (DepType.Rec.FlagCur == IsCur) )
    BalAccForKind( IsCur, DepType.Rec.Kind );
    BalAcc(0) = Trim(vBalAcc);
    BalAcc(1) = Trim(vBalAccNR);
    i = 0;
    while (i < ASize(BalAcc))
      if (ASize(ABalAcc) == 0)
        ABalAcc(0) = BalAcc(i);
      else
        j = 0;
        k = -1;
        while (j < ASize(ABalAcc))
          if (BalAcc(i) == ABalAcc(j))
            k = j;
            j = ASize(ABalAcc); /* Чтобы быстрее выйти из цикла */
          end;
          j = j + 1;
        end;
        if (k == -1)
          k = ASize(ABalAcc);
          ABalAcc(k) = BalAcc(i);
        end;
      end;
      i = i + 1;
    end;
    stat = DepType.Next;
  end;

  DepType.DropFilter;

  /* Сортируем в порядке возрастания */
  i = 0;
  while (i < ASize(ABalAcc))
    j = i;
    k = i;
    while (j < ASize(ABalAcc))
      if (ABalAcc(k) > ABalAcc(j))
        k = j;
      end;
      j = j + 1;
    end;
    BA_TMP = ABalAcc(i);
    ABalAcc(i) = ABalAcc(k);
    ABalAcc(k) = BA_TMP;
    i = i + 1;
  end;

  if ( mode == Rdt_Chapt4 )
    i = 0;
    while (i < ASize(ABalAcc))
      /* Сначала идем для резидентов */
      DepType.KeyNum = 2;
      WasPrintBA = false;
      BATotPrevAcc = 0;
      BATotPrevRest = $0;
      BATotOpenedAcc = 0;
      BATotCredit = $0;
      BATotClosedAcc = 0;
      BATotDebet = $0;
      BATotAcc = 0;
      BATotRest = $0;

      cmdN = RsdCommand( "select ng.t_GroupID as rID "
                           "from dsbnumgrp_dbt ng "
                           "where ng.t_BalAcc2 = :balacc" );

      rsN = RsdRecordset( cmdN );

      cmdN.addParam( "balacc", RSDBP_IN, ABalAcc(i) );

      cmdN.execute;

      while ( rsN.moveNext() )
        cmdG = RsdCommand( "select typgrp.t_kind as rKind "
                             "from dsbtypgrp_dbt typgrp "
                             "where typgrp.t_groupid = :gid and "
                                   "typgrp.t_flagcur = :flagCur" );

        rsG = RsdRecordset( cmdG );

        cmdG.addParam( "gid", RSDBP_IN, rsN.value( "rID" ) );
        cmdG.addParam( "flagCur", RSDBP_IN, IsCur );

        cmdG.execute;

        while ( rsG.moveNext() )
          vKind = rsG.value( "rKind" );
          if ( ( vKind != "Служебный" )  AND  StatForCurDayExists( 0 ) )
            ReportOnCurDepType( StrFor(0), 0, ABalAcc(i) );
          end;
        end;
      end;
  
      // Потом идем для нерезидентов
      cmdN = RsdCommand( "select ng.t_GroupID as rID "
                           "from dsbnumgrp_dbt ng "
                           "where ng.t_BalAcc2NotResid = :balacc" );

      rsN = RsdRecordset( cmdN );

      cmdN.addParam( "balacc", RSDBP_IN, ABalAcc(i) );

      cmdN.execute;

      while ( rsN.moveNext() )
        cmdG = RsdCommand( "select typgrp.t_kind as rKind "
                             "from dsbtypgrp_dbt typgrp "
                             "where typgrp.t_groupid = :gid and "
                                   "typgrp.t_flagcur = :flagCur" );

        rsG = RsdRecordset( cmdG );

        cmdG.addParam( "gid", RSDBP_IN, rsN.value( "rID" ) );
        cmdG.addParam( "flagCur", RSDBP_IN, IsCur );

        cmdG.execute;

        while ( rsG.moveNext() )
          vKind = rsG.value( "rKind" );
          if ( ( vKind != "Служебный" )  AND  StatForCurDayExists( 1 ) )
            ReportOnCurDepType( StrFor(1), 0, ABalAcc(i) );
          end;
        end;
      end;
  
      if ( WasPrintBA )
        OutStatTotalsBA1( ABalAcc(i) );
      end;
      i = i + 1;
    end;
  
    if ( SmthPrinted )
      OutStatTotals;
    end;
 end;

 if ( mode == Rdt_AccumPc  )
    // Отчет по наращенным процентам
    i = 0;
    while (i < ASize(ABalAcc))
      BAPrevEstimRest = $0L;
      BAEstimIn       = $0L;
      BAEstinOut      = $0L;
      BAEstimOverOut  = $0L;
      BAEstimRest     = $0L;
      WasPrintBA      = FALSE;
  
      // Сначала идем для резидентов
      cmdN = RsdCommand( "select ng.t_GroupID as rID "
                           "from dsbnumgrp_dbt ng "
                           "where ng.t_BalAcc2 = :balacc" );

      rsN = RsdRecordset( cmdN );

      cmdN.addParam( "balacc", RSDBP_IN, ABalAcc(i) );

      cmdN.execute;

      while ( rsN.moveNext() )
        cmdG = RsdCommand( "select typgrp.t_kind as rKind "
                             "from dsbtypgrp_dbt typgrp "
                             "where typgrp.t_groupid = :gid and "
                                   "typgrp.t_flagcur = :flagCur" );

        rsG = RsdRecordset( cmdG );

        cmdG.addParam( "gid", RSDBP_IN, rsN.value( "rID" ) );
        cmdG.addParam( "flagCur", RSDBP_IN, IsCur );

        cmdG.execute;

        while ( rsG.moveNext() )
          vKind = rsG.value( "rKind" );
          if ( ( vKind != "Служебный" )  AND  StatForCurDayExists( 0 ) )
            ReportOnCurDepType( StrFor(0), 1, ABalAcc(i) );
          end;
        end;
      end;

      // Потом идем для нерезидентов
      cmdN = RsdCommand( "select ng.t_GroupID as rID "
                           "from dsbnumgrp_dbt ng "
                           "where ng.t_BalAcc2 = :balacc" );

      rsN = RsdRecordset( cmdN );

      cmdN.addParam( "balacc", RSDBP_IN, ABalAcc(i) );

      cmdN.execute;

      while ( rsN.moveNext() )
        cmdG = RsdCommand( "select typgrp.t_kind as rKind "
                             "from dsbtypgrp_dbt typgrp "
                             "where typgrp.t_groupid = :gid and "
                                   "typgrp.t_flagcur = :flagCur" );

        rsG = RsdRecordset( cmdG );

        cmdG.addParam( "gid", RSDBP_IN, rsN.value( "rID" ) );
        cmdG.addParam( "flagCur", RSDBP_IN, IsCur );

        cmdG.execute;

        while ( rsG.moveNext() )
          vKind = rsG.value( "rKind" );
          if ( ( vKind != "Служебный" )  AND  StatForCurDayExists( 1 ) )
            ReportOnCurDepType( StrFor(1), 1, ABalAcc(i) );
          end;
        end;
      end;

      if (WasPrintBA)
        OutStatTotalBA();
      end;
      i = i + 1;
    end;

    if ( SmthPrinted )  
      OutStatTotals2();
    end;
  end;

end;


macro AddOthStat(s1,s2)

  s1.Rest=s1.Rest+s2.Rest;
  s1.KredSum=s1.KredSum+s2.KredSum;
  s1.DebSum=s1.DebSum+s2.DebSum;
  s1.ColOper=s1.ColOper+s2.ColOper;
end;

macro AddToTotStatCO

  record TmpStat("sb_othst.dbt");

  OthStat.rec.FNCash=Branch;
  OthStat.rec.AplicKind=SB_CASHOPERT;
  OthStat.rec.CodCur=0;
  OthStat.rec.GroupOper=PayKind.GroupOpert;
  OthStat.rec.NumOper=PayKind.NumOperat;
  OthStat.rec.DateOper={curdate};
  OthStat.addFilter("t.t_FNCash = " + string(Branch) +
		    " and t.t_AplicKind = " + string(SB_CASHOPERT) +
		    " and t.t_CodCur = 0 " +
		    " and t.t_GroupOper = " + string( PayKind.GroupOpert ) +
		    " and t.t_NumOper = " + string( PayKind.NumOperat ) );
  if(not (OthStat.GetLE
     and (OthStat.rec.FNCash==Branch)
     and (OthStat.rec.AplicKind==SB_CASHOPERT)
     and (OthStat.rec.CodCur==0)
     and (OthStat.rec.GroupOper==PayKind.GroupOpert)
     and (OthStat.rec.NumOper==PayKind.NumOperat)))
    OthStat.dropFilter;
    return ;
  end;

  if(OthStat.rec.DateOper=={curdate})
    Copy(TmpStat,OthStat);
    if(OthStat.Prev and not IsQuarterStart(TmpStat.DateOper, OthStat.rec.DateOper)
      and (OthStat.rec.FNCash==Branch)
      and (OthStat.rec.AplicKind==SB_CASHOPERT)
      and (OthStat.rec.CodCur==0)
      and (OthStat.rec.GroupOper==PayKind.GroupOpert)
      and (OthStat.rec.NumOper==PayKind.NumOperat))
      AddOthStat(TotOthPrevStat,OthStat.rec);
      AddOthStat(TotOthStat,TmpStat);
    else
      AddOthStat(TotOthStat,TmpStat);
    end;
  else
    OthStat.rec.ColOper=0;
    OthStat.rec.DebSum=0;
    OthStat.rec.KredSum=0;
    AddOthStat(TotOthStat,OthStat.rec);
  end;
  OthStat.dropFilter;
end;

macro ReportOnCashOps

  var
    RecFound;

  ClearRecord(TotOthStat);
  ClearRecord(TotOthPrevStat);

  ClearRecord(PayKind);
  PayKind.IsCur=0;
  PayKind.GroupOpert=CO_NalPer;
  RecFound=GetGE(PayKind);
  while(RecFound 
    and (PayKind.IsCur==0)
    and (PayKind.GroupOpert==CO_NalPer))
    AddToTotStatCO;
    RecFound=Next(PayKind);
  end;

  ClearRecord(PayKind);
  PayKind.IsCur=0;
  PayKind.GroupOpert=CO_Payed;
  RecFound=GetGE(PayKind);
  while(RecFound
    and (PayKind.IsCur==0)
    and (PayKind.GroupOpert==CO_Payed))
    AddToTotStatCO;
    RecFound=Next(PayKind);
  end;
  OutOthStatLineCO;
end;

macro AddToTotStatCI(Type,Issue)

  var
    RecFound;

  ClearRecord(CIAcc);
  CIAcc.Branch = Branch;
  CIAcc.Type = Type;
  CIAcc.Issue = Issue;
  RecFound = GetGE(CIAcc);
  while(RecFound
    and (CIAcc.Issue == Issue)
    and (CIAcc.Branch == Branch)
    and (CIAcc.Type == Type))
    DepStat.rec.ColAccounts = DepStat.rec.ColAccounts + 1;
    if(CIAcc.OpenDate != {curdate})
      PrevStat.ColAccounts = PrevStat.ColAccounts + 1;
    end;
    if(CIAcc.State == AS_OPEN)
      DepStat.rec.ColOpenedAcc = DepStat.rec.ColOpenedAcc + 1;
      DepStat.rec.Rest = DepStat.rec.Rest + CIAcc.Sum;
      if(CIAcc.OpenDate != {curdate})
        PrevStat.ColOpenedAcc = PrevStat.ColOpenedAcc + 1;
        PrevStat.Rest = PrevStat.Rest + CIAcc.Sum;
      else
        DepStat.rec.KredSum = DepStat.rec.KredSum + CIAcc.Sum;
      end;
    else
      DepStat.rec.ColClosedAcc = DepStat.rec.ColClosedAcc + 1;
      if(CIAcc.OpenDate != {curdate})
        PrevStat.ColClosedAcc = PrevStat.ColClosedAcc + 1;
      else
        PrevStat.Rest = PrevStat.Rest + CIAcc.Sum;
        DepStat.rec.DebSum = DepStat.rec.DebSum + CIAcc.Sum;
      end;
    end;
    RecFound = Next(CIAcc);
  end;
end;

macro ReportOnCapIssues

  var
    RecFound;

  ClearRecord(DepStat.rec);
  ClearRecord(PrevStat);

  ClearRecord(OGSZIss);
  OGSZIss.Type=CI_OGSZ;
  RecFound=GetGE(OGSZIss);
  while(RecFound and (OGSZIss.Type==CI_OGSZ))
    AddToTotStatCI(OGSZIss.Type,OGSZIss.IssueID);
    RecFound=Next(OGSZIss);
  end;

  Rewind(CIMisc);
  while(Next(CIMisc))
    AddToTotStatCI(CIMisc.Type,CIMisc.IssueID);
  end;

  ClearRecord(Cert);
  Cert.Type=CI_CERT;
  RecFound=GetGE(Cert);
  while(RecFound and (Cert.Type==CI_CERT))
    AddToTotStatCI(Cert.Type,Cert.Issue);
    RecFound=Next(Cert);
  end;

  OutOthStatLineCI;
end;

macro AddToTotStatCP

  record TmpStat("sb_othst.dbt");

  OthStat.rec.FNCash=Branch;
  OthStat.rec.AplicKind=SB_COMPAY;
  OthStat.rec.CodCur=0;
  OthStat.rec.GroupOper=CO_CommPay;
  OthStat.rec.NumOper=PayRecip.ID;
  OthStat.rec.DateOper={curdate};
  OthStat.rec.Mode=Mode;
  OthStat.addFilter("t.t_FNCash = " + string(Branch) +
		    " and t.t_AplicKind = " + string(SB_COMPAY) +
		    " and t.t_CodCur = 0 " +
		    " and t.t_GroupOper = " + string( CO_CommPay ) +
		    " and t.t_NumOper = " + string( PayRecip.ID ) );

  if(not (OthStat.GetLE
     and (OthStat.rec.FNCash==Branch)
     and (OthStat.rec.AplicKind==SB_COMPAY)
     and (OthStat.rec.CodCur==0)
     and (OthStat.rec.GroupOper==CO_CommPay)
     and (OthStat.rec.NumOper==PayRecip.ID)))
    OthStat.dropFilter;
    return ;
  end;

  if( ( OthStat.rec.DateOper=={curdate} ) and ( OthStat.rec.Mode == Mode ) )
    Copy(TmpStat,OthStat);
    if(OthStat.Prev and not IsQuarterStart(TmpStat.DateOper, OthStat.rec.DateOper)
      and (OthStat.rec.FNCash==Branch)
      and (OthStat.rec.AplicKind==SB_COMPAY)
      and (OthStat.rec.CodCur==0)
      and (OthStat.rec.GroupOper==CO_CommPay)
      and (OthStat.rec.NumOper==PayRecip.ID))
      AddOthStat(TotOthPrevStat,OthStat.rec);
      AddOthStat(TotOthStat,TmpStat);
    else
      AddOthStat(TotOthStat,TmpStat);
    end;
  else
    OthStat.rec.ColOper=0;
    OthStat.rec.DebSum=0;
    OthStat.rec.KredSum=0;
    AddOthStat(TotOthStat,OthStat.rec);
  end;
  OthStat.dropFilter;
end;

macro ReportOnCommPays

  var
    RecFound;

  ClearRecord(TotOthStat);
  ClearRecord(TotOthPrevStat);

  ClearRecord(PayRecip);
  RecFound=GetGE(PayRecip);
  while(RecFound)
    AddToTotStatCP;
    RecFound=Next(PayRecip);
  end;

  OutOthStatLineCP;
end;

macro TreatCurCrResource;

  var
    PrevRest=$0,
    CurRest=$0,
    Deb=$0,
    Cred=$0,
    OtherDeb=$0,
    OtherCred=$0;

  Currency.rec.Code_Currency=CashVal.rec.CodIntValue;
  if(not Currency.GetEQ )
    Currency.Clear;
    Currency.rec.Name_Currency="не найдена";
  end;

  CalcOtherTurns(CashVal.rec.RefValue,OtherCred,OtherDeb);

  CashAcc.addFilter("t.t_Branch = " + string( Branch ) +
		    " and t.t_CashOper = " + Safe + 
		    " and t.t_SubAccount = ''" +
		    " and t.t_RefValue = " + string( CashVal.rec.RefValue ) );
  CashAcc.KeyNum = 2;
  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper=Safe;
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if( CashAcc.GetLT and
    (CashAcc.rec.Branch==Branch) and
    (CashAcc.rec.RefValue==CashVal.rec.RefValue) and
    (CashAcc.rec.CashOper==Safe) and
    (CashAcc.rec.SubAccount==""))
    PrevRest=CashAcc.rec.RestMoney;
  end;
  CashAcc.dropFilter;

  CashAcc.KeyNum = 1;
  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper=Safe;
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if( CashAcc.GetEQ )
    CurRest=CashAcc.rec.RestMoney;
  end;

  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper="Инкассация";
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if( CashAcc.GetEQ )
    Cred=CashAcc.rec.DebMoney;
    Deb=CashAcc.rec.KredMoney;
  end;
  WriteNBData(0,PrevRest,CurRest,Cred,0,Deb,0);
end;

macro TreatCrResources;

  CashVal.rec.TypeValue=CV_Currency;
  CashVal.rec.CodIntValue=0;

  if(CashVal.GetEQ)
    TreatCurCrResource;
  end;
end;

macro ReportOnDepOps

  getTotalDepStats( {curdate}, 0 );
  copy( DepStat, TotalStat );
  getTotalDepStats( {curdate} - 1 , 0 );
  copy( PrevStat, TotalStat );

  OutOpMemLine("1. Первоначальные взносы по вкладам населения",
    PrevStat.OpenInOper, DepStat.rec.OpenInOper);
  OutOpMemLine("2. Дополнительные взносы по вкладам населения",
    PrevStat.DopInOper, DepStat.rec.DopInOper);
  OutOpMemLine("3. Частичные выдачи и закрытие счетов по вкладам населения",
    PrevStat.OutOper, totalStat.OutOper);
end;

macro ReportOnCIOps

  record TmpStat("sb_othst.dbt");

  OthStat.rec.FNCash=Branch;
  OthStat.rec.AplicKind=SB_CAPISSUE;
  OthStat.rec.CodCur=0;
  OthStat.rec.GroupOper=0;
  OthStat.rec.NumOper=0;
  OthStat.rec.DateOper={curdate};
  OthStat.rec.Mode=Mode;

  OthStat.addFilter("t.t_FNCash = " + string(Branch) +
		    " and t.t_AplicKind = " + string(SB_CAPISSUE) +
		    " and t.t_CodCur = 0 " +
		    " and t.t_GroupOper = 0" +
		    " and t.t_NumOper = 0" );
  if(not (OthStat.GetLE
     and (OthStat.rec.FNCash==Branch)
     and (OthStat.rec.AplicKind==SB_CAPISSUE)
     and (OthStat.rec.CodCur==0)
     and (OthStat.rec.GroupOper==0)
     and (OthStat.rec.NumOper==0)))
    OthStat.dropFilter;
    return ;
  end;

  if( ( OthStat.rec.DateOper=={curdate} ) and ( OthStat.rec.Mode == Mode ) )
    Copy(TmpStat,OthStat);
    if(OthStat.Prev and not IsQuarterStart(TmpStat.DateOper, OthStat.rec.DateOper)
      and (OthStat.rec.FNCash==Branch)
      and (OthStat.rec.AplicKind==SB_CAPISSUE)
      and (OthStat.rec.CodCur==0)
      and (OthStat.rec.GroupOper==0)
      and (OthStat.rec.NumOper==0))
      Copy(PrevOthStat,OthStat);
      Copy(OthStat,TmpStat);
    else
      ClearRecord(PrevOthStat);
      Copy(OthStat,TmpStat);
    end;
  else
    Copy(PrevOthStat,OthStat);
  end;
  OutOpMemLine("5. Операции с ОГЗ и билетами денежно-вещевых лотерей",
    PrevOthStat.ColOper, OthStat.rec.ColOper);
  OthStat.dropFilter;
end;

macro ReportOnCOOps

  var
    RecFound;

  ClearRecord(TotOthStat);
  ClearRecord(TotOthPrevStat);

  ClearRecord(PayKind);
  PayKind.GroupOpert = CO_NalPer;
  AddToTotStatCO;
  PayKind.GroupOpert = CO_Comission;
  AddToTotStatCO;
  PayKind.GroupOpert = CO_Conversion;
  AddToTotStatCO;
  PayKind.GroupOpert = CO_Payed;
  AddToTotStatCO;

  OutOpMemLine("6. Операции по приему платежей от организаций и населения",
    TotOthPrevStat.ColOper, TotOthStat.ColOper);
end;

macro ReportOnCPOps

  var
    RecFound;

  record TmpStat("sb_othst.dbt");

  OthStat.rec.FNCash=Branch;
  OthStat.rec.AplicKind=SB_COMPAY;
  OthStat.rec.CodCur=0;
  OthStat.rec.GroupOper=CO_CommPay;
  OthStat.rec.NumOper=0;
  OthStat.rec.DateOper={curdate};
  OthStat.rec.Mode=Mode;

  OthStat.addFilter("t.t_FNCash = " + string(Branch) +
		    " and t.t_AplicKind = " + string(SB_COMPAY) +
		    " and t.t_CodCur = 0 " +
		    " and t.t_GroupOper = " + string( CO_CommPay ) +
		    " and t.t_NumOper = 0" );
  if(not (OthStat.GetLE
     and (OthStat.rec.FNCash==Branch)
     and (OthStat.rec.AplicKind==SB_COMPAY)
     and (OthStat.rec.CodCur==0)
     and (OthStat.rec.GroupOper==CO_CommPay)
     and (OthStat.rec.NumOper==0)))
    OthStat.dropFilter;
    return ;
  end;

  if(OthStat.rec.DateOper=={curdate})
    Copy(TmpStat,OthStat);
    if(OthStat.Prev and not IsQuarterStart(TmpStat.DateOper, OthStat.rec.DateOper)
      and (OthStat.rec.FNCash==Branch)
      and (OthStat.rec.AplicKind==SB_COMPAY)
      and (OthStat.rec.CodCur==0)
      and (OthStat.rec.GroupOper==CO_CommPay)
      and (OthStat.rec.NumOper==0))
      Copy(PrevOthStat,OthStat);
      Copy(OthStat,TmpStat);
    else
      ClearRecord(PrevOthStat);
      Copy(OthStat,TmpStat);
    end;
  else
    Copy(PrevOthStat,OthStat);
  end;

  OutOpMemLine("7. Другие кассовые и расчетные операции",
    PrevOthStat.ColOper, OthStat.rec.ColOper);

  OthStat.dropFilter;
end;

macro ReportOnOps

  TotPrevNOps = 0;
  TotNOps = 0;
  OutOpHead;
  ReportOnDepOps;
  ReportOnCIOps;
  ReportOnCOOps;
  ReportOnCPOps;
  OutOpTotals;
end;

macro ReportOnMemTurns

  record TmpStat("sb_depst.dbt");

  OutMemHead;

  getTotalDepStats( {curdate}, 0 );
  copy( DepStat, totalStat );
  getTotalDepStats( {curdate} - 1, 0 );
  copy( PrevStat, totalStat );

  OutOpMemLine("1. Безналичные зачисления во вклады",
    PrevStat.MemInOper, DepStat.rec.MemInOper);
end;

macro Chapters1And2
  Chapter=1;
  ReportOnCIResources;
  Chapter=2;
  ReportOnCIResources;
end;

macro ReportOnDepTypes_Chapt4

  ReportOnDepTypes( Rdt_Chapt4 );
end;

macro ReportOnDepTypes_AccumPc

  ReportOnDepTypes( Rdt_AccumPc );
end;

  var
    RegPath = "RS-RETAIL\\ПЕЧАТИ\\ФОРМА_25",
    Chapt4 = true;

  ByeBoss(0);

  CheckPrinter( RegPath, StrFor( 0 ) );

  if (MsgBoxEx("Печатать раздел \"Учет вкладов\"?", MB_YES + MB_NO, IND_YES) == IND_NO )
    Chapt4 = false;
  end;

  Message (" Создается форма 25-а ...");
  if ( GetProgramID != CodeFor( "П" )  )
    Safe = GetNativeSafe;
    DeskSubj.Branch = Branch;
    DeskSubj.Type = DST_SAFE;
    DeskSubj.Name = Safe;
    if ( not GetEQ( DeskSubj ) )
      MsgBox( "Не найден субъект кассы: ", Safe );
      Exit( -1 );
    end;
  else
    ClearRecord( DeskSubj );
    DeskSubj.Reports = "A";
  end;

  if ( Index( DeskSubj.Reports, "A" ) != 0 )
    OutTitle;

    /* Главы 1 и 2 */
    ForEachCurr( "Chapters1And2" );

    /* Глава 3 */
    ReportOnVFResources;

    /* Глава 4 */

    if (Chapt4)
      ForEachCurr( "ReportOnDepTypes_Chapt4" );
    end;

    OutBottom;
    PrintLn( StrFor( 12 ) );
             
    if ( ОТЧЕТ_ПО_НАРАЩЕННЫМ )
      SmthPrinted_Accum = false;
      ForEachCurr( "ReportOnDepTypes_AccumPc" );
      if ( SmthPrinted_Accum )
        OutBottom;
        PrintLn( StrFor( 12 ) );
      end;
    end;
  end;
  if ( Index( DeskSubj.Reports, "М" ) != 0 )
    Chapter=1;
    ReportOnCoinResources( false );
    ReportOnCoinResources( true );
  end;

  ElectronDigitalSignReport( );

  ExitMacro;

end;

*/