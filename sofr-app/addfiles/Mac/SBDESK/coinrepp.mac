
/* Ведомость по монетам ( штуки ) */

import ResCommP;

const
  ShowNullLines=false;  /* Показывать ли строки, где все нули */

const
  CK_NEW          = 0, 
  CK_OLD          = 1;

var
  MetalSubheadPrinted;

var
  TotPrevRest=$0,
  TotCredit=$0,
  TotDebet=$0,
  TotOtherCred=$0,
  TotOtherDeb=$0,
  TotRest=$0,
  TotPrevRestA=$0,
  TotCreditA=$0,
  TotDebetA=$0,
  TotOtherCredA=$0,
  TotOtherDebA=$0,
  TotRestA=$0, 

  MetTotPrevRest=$0,
  MetTotCredit=$0,
  MetTotDebet=$0,
  MetTotOtherCred=$0,
  MetTotOtherDeb=$0,
  MetTotRest=$0,
  MetTotPrevRestA=$0,
  MetTotCreditA=$0,
  MetTotDebetA=$0,
  MetTotOtherCredA=$0,
  MetTotOtherDebA=$0,
  MetTotRestA=$0;

macro OutCoinHeader;

  [ Филиал # ]( GetBranchName );
  [ ];
  [ ];
  [                                                 Монеты, учитываемые по номиналу ];
  [                                                 ############################### ]
  ( {curdate}:m:c );
  [ ];
  [ # ]( DeskSubj.Desc );
  [ ];
  [+-------------------------+-------+--------+----------------------+-------------------------------------------+---------------------+];
  [|                         |       |        |       Остаток        |                  Обороты                  |       Остаток       |];
  [|       Наименование      |       |        |      на начало       |---------------------+---------------------+      на  конец      |];
  [|                         | Проба | Номин. |         дня          |       Приход        |       Расход        |         дня         |];
  [|   монеты, год выпуска   |       |        +----------+-----------+----------+----------+----------+----------+----------+----------+];
  [|                         |       |        |  Кол-во  |   Сумма   |  Кол-во  |  Сумма   |  Кол-во  |  Сумма   |  Кол-во  |  Сумма   |];
  [+-------------------------+-------+--------+----------+-----------+----------+----------+----------+----------+----------+----------+];
end;

macro OutCoinLine(NameVal,PrevRest,CurRest,Cred,OtherCred,Deb,OtherDeb);

  if((not ShowNullLines) and (PrevRest==$0) and (Cred==$0) and (OtherCred==$0)
     and (Deb==$0) and (OtherDeb==$0) and (CurRest==$0))
    return;
  end;

  if ( not MetalSubheadPrinted )
    PrintLn;
    PrintLn( CICode.String );
    PrintLn( MkStr( "=", StrLen( CICode.String ) ) );
    PrintLn;
    [+-------------------------+-------+--------+----------+-----------+----------+----------+----------+----------+----------+----------+];
    MetalSubheadPrinted = true;
  end;

  GetPos( CICode );

  FindCICode( CIMisc.HallmarkRef );

  [| ########################|#######|########|##########|###########|##########|##########|##########|##########|##########|##########|]
  (
    ( NameVal + ", " + String( CIMisc.IssueYear ) ):w,
    CICode.Double:0:0,
    CIMisc.Par,
    Int( Double ( PrevRest ) / 100 ):z,
    Money( PrevRest * CIMisc.Par / 100 ):z,
    Int( Double( Cred + OtherCred ) / 100 ):z,
    Money( ( Cred + OtherCred ) * CIMisc.Par / 100 ):z,
    Int( Double( Deb + OtherDeb ) / 100 ):z,
    Money( ( Deb + OtherDeb ) * CIMisc.Par / 100 ):z,
    Int( Double( CurRest ) / 100 ):z,
    Money( CurRest * CIMisc.Par / 100 ):z
  );
  MetTotPrevRest=MetTotPrevRest+PrevRest;
  MetTotPrevRestA=MetTotPrevRestA+Money( PrevRest * CIMisc.Par / 100 );
  MetTotCredit=MetTotCredit+Cred;
  MetTotCreditA=MetTotCreditA+Money( Cred * CIMisc.Par / 100 );
  MetTotDebet=MetTotDebet+Deb;
  MetTotDebetA=MetTotDebetA+Money( Deb * CIMisc.Par / 100 );
  MetTotOtherCred=MetTotOtherCred+OtherCred;
  MetTotOtherCredA=MetTotOtherCredA+Money( OtherCred * CIMisc.Par / 100 );
  MetTotOtherDeb=MetTotOtherDeb+OtherDeb;
  MetTotOtherDebA=MetTotOtherDebA+Money( OtherDeb * CIMisc.Par / 100 );
  MetTotRest=MetTotRest+CurRest;
  MetTotRestA=MetTotRestA+Money( CurRest * CIMisc.Par / 100 );

  GetDirect( CICode );
end;

macro OutCoinTotLine

  [+=========================+=======+========+==========+===========+==========+==========+==========+==========+==========+==========+];
  [| И т о г о :             |       |        |##########|###########|##########|##########|##########|##########|##########|##########|]
  (
    Int( Double( TotPrevRest ) / 100 ),
    Money( TotPrevRestA ),
    Int( Double( TotCredit + TotOtherCred ) / 100 ),
    Money( TotCreditA + TotOtherCredA ),
    Int( Double( TotDebet + TotOtherDeb ) / 100 ),
    Money( TotDebetA + TotOtherDebA ),
    Int( Double( TotRest ) / 100 ),
    Money( TotRestA )
  );
end;

macro OutCoinMetTotLine

  [+-------------------------+-------+--------+----------+-----------+----------+----------+----------+----------+----------+----------+];
  [| ####################### |       |        |##########|###########|##########|##########|##########|##########|##########|##########|]
  (
    "Итого " + CICode.String + ":",  
    Int( Double( MetTotPrevRest ) / 100 ),
    Money( MetTotPrevRestA ),
    Int( Double( MetTotCredit + MetTotOtherCred ) / 100 ),
    Money( MetTotCreditA + MetTotOtherCredA ),
    Int( Double( MetTotDebet + MetTotOtherDeb ) / 100 ),
    Money( MetTotDebetA + MetTotOtherDebA ),
    Int( Double( MetTotRest ) / 100 ),
    Money( MetTotRestA )
  );

  TotPrevRest=TotPrevRest+MetTotPrevRest;
  TotPrevRestA=TotPrevRestA+MetTotPrevRestA;
  TotCredit=TotCredit+MetTotCredit;
  TotCreditA=TotCreditA+MetTotCreditA;
  TotDebet=TotDebet+MetTotDebet;
  TotDebetA=TotDebetA+MetTotDebetA;
  TotOtherCred=TotOtherCred+MetTotOtherCred;
  TotOtherCredA=TotOtherCredA+MetTotOtherCredA;
  TotOtherDeb=TotOtherDeb+MetTotOtherDeb;
  TotOtherDebA=TotOtherDebA+MetTotOtherDebA;
  TotRest=TotRest+MetTotRest;
  TotRestA=TotRestA+MetTotRestA;
end;

macro OutCoinTail

  [                                                                           ];
  [                                                                           ];
  [                                                                           ];
  [___________________________________________________________________________];
  [  ( Управляющий учреждением СБ РФ )                                        ];
  [___________________________________________________________________________];
  [  ( Главный бухгалтер )                                                    ];
  [___________________________________________________________________________];
  [  ( Заведующий кладовой )                                                  ];
  PrintLn( StrFor( 12 ) );
end;

macro ReportOnCurCoin

  var
    PrevRest=0,
    CurRest=0,
    Deb=0,
    Cred=0,
    OtherDeb=0,
    OtherCred=0;

  /* В ведомости следует считать монеты поштучно! */

  CashVal.rec.UnitMeas = RESMESUNIT_POINT;

  CalcTurns(CashVal.rec.RefValue,Cred,Deb,OtherCred,OtherDeb);

  CashAcc.KeyNum = 2;
  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper=Safe;
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if(CashAcc.GetLT and
    (CashAcc.rec.Branch==Branch) and
    (CashAcc.rec.RefValue==CashVal.rec.RefValue) and
    (CashAcc.rec.CashOper==Safe) and
    (CashAcc.rec.SubAccount==""))
    if(CashVal.rec.UnitMeas==RESMESUNIT_POINT)
      PrevRest=Money(CashAcc.rec.RestCol*100);
    else
      PrevRest=CashAcc.rec.RestMoney;
    end;
  end;

  CashAcc.KeyNum = 1;
  CashAcc.rec.Branch=Branch;
  CashAcc.rec.CashOper=Safe;
  CashAcc.rec.SubAccount="";
  CashAcc.rec.RefValue=CashVal.rec.RefValue;
  CashAcc.rec.Date={curdate};
  if(CashAcc.GetEQ)
    if(CashVal.rec.UnitMeas==RESMESUNIT_POINT)
      CurRest=Money(CashAcc.rec.RestCol*100);
      if ( {DeskOpen} )
        PrevRest = PrevRest + Money( ( CashAcc.rec.EKredCol - CashAcc.rec.EDebCol ) * 100 ); 
      end;
    else
      CurRest=CashAcc.rec.RestMoney;
      if ( {DeskOpen} )
        PrevRest = PrevRest + CashAcc.rec.EKredMoney - CashAcc.rec.EDebMoney; 
      end;
    end;
  end;
  OutCoinLine(CashVal.rec.NameValue,PrevRest,CurRest,Cred,OtherCred,Deb,OtherDeb);
end;

macro ReportOnCoinResourcesForMetal;

  var stat;
                       
  MetTotPrevRest=$0;
  MetTotCredit=$0;
  MetTotDebet=$0;
  MetTotOtherCred=$0;
  MetTotOtherDeb=$0;
  MetTotRest=$0;
  MetTotPrevRestA=$0;
  MetTotCreditA=$0;
  MetTotDebetA=$0;
  MetTotOtherCredA=$0;
  MetTotOtherDebA=$0;
  MetTotRestA=$0;

  MetalSubHeadPrinted = false;

  CashVal.rec.FlagIntoBalance = 1;
  CashVal.rec.BalAccount      = "";
  stat = CashVal.GetGE;
  while (stat)  
    if ( CashVal.rec.FlagIntoBalance == 1 )
      if ((CashVal.rec.RefValueReport != 1          ) AND
          (CashVal.rec.TypeValue == CV_MinCI + CI_COIN) )
        FindCIMisc( CI_COIN, CashVal.rec.CodIntValue );
        if ( ( CIMisc.KindOfCoin == CK_NEW ) 
          and ( CIMisc.MaterialRef == CICode.AutoKey ) )
          ReportOnCurCoin();
        end;
      end;
      stat = CashVal.Next;
    else
      stat = FALSE;
    end;
  end;
  
  if ( MetalSubHeadPrinted )
    OutCoinMetTotLine;
  end; 
end;

macro ReportOnCoinResources;

  var
    RecFound;

  TotPrevRest  = $0.0L;
  TotCredit    = $0.0L;
  TotDebet     = $0.0L;
  TotOtherCred = $0.0L;
  TotOtherDeb  = $0.0L;
  TotRest      = $0.0L;
  TotPrevRestA  = $0.0L;
  TotCreditA    = $0.0L;
  TotDebetA     = $0.0L;
  TotOtherCredA = $0.0L;
  TotOtherDebA  = $0.0L;
  TotRestA      = $0.0L;

  OutCoinHeader;

  ClearRecord( CICode );
  CICode.UpLink = 0;
  CICode.Group = 2; /* CRE_MATERIAL */
  RecFound = GetGE( CICode );
  while ( RecFound
    and ( CICode.UpLink == 0 ) 
    and ( CICode.Group == 2 ) ) /* CRE_MATERIAL */
    ReportOnCoinResourcesForMetal;
    RecFound = Next( CICode );
  end;
  OutCoinTotLine;
  OutCoinTail;
end;

macro TreatCurrentSafe

  TotPrevRest=$0;
  TotCredit=$0;
  TotDebet=$0;
  TotOtherCred=$0;
  TotOtherDeb=$0;
  TotRest=$0;
  TotPrevRestA=$0;
  TotCreditA=$0;
  TotDebetA=$0;
  TotOtherCredA=$0;
  TotOtherDebA=$0;
  TotRestA=$0;

  if ( Index( DeskSubj.Reports, "М" ) != 0 )
    ReportOnCoinResources;
  end;
end;

  var
    RegPath = "RS-RETAIL\\ПЕЧАТИ\\ВЕДОМОСТЬ_ПО_МОНЕТАМ_ШТУКИ",
    RecFound;

  CheckPrinter( RegPath, StrFor( 0 ) );

  if ( {EDeskOpen} )
    OperBrigade = B_EDESK;
  elif ( {DeskOpen} ) 
    OperBrigade = B_RDESK;
  end;

  if ( {RprtDSubj} == "" )
    KeyNum( DeskSubj, 1 );
    ClearRecord( DeskSubj );
    DeskSubj.Branch = Branch;
    DeskSubj.Type = DST_PANTRY;
    RecFound = GetGE( DeskSubj );
    while ( RecFound
      and ( DeskSubj.Branch == Branch )
      and ( DeskSubj.Type == DST_PANTRY ) )
      Safe = DeskSubj.Name;
      TreatCurrentSafe;
      RecFound = Next( DeskSubj );
    end;
    KeyNum( DeskSubj, 0 );
    DeskSubj.Branch = Branch;
    DeskSubj.Name = RDesk;
    if ( GetEQ( DeskSubj ) )
      Safe = DeskSubj.Name;
      TreatCurrentSafe;
    end;
  else
    DeskSubj.Branch = Branch;
    DeskSubj.Name = {RprtDSubj};
    if ( GetEQ( DeskSubj ) )
      Safe = DeskSubj.Name;
      TreatCurrentSafe;
    end;
  end;
  ExitMacro;
end;
