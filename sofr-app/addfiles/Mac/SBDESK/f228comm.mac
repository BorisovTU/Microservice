import TDate, RSD;

file DBcAcc( "dbc_acc.dbt" ) key 0;
file DBcAccMy ( "dbc_acc.dbt" ) key 0; // KIN
file DBcDoc( "dbc_doc.dbt" ) key 2;

file SbCasac( "sb_casac.dbt" ) key 0;
private file CashDoc( "sb_casdc.dbt" ) key 7;
file Tmp( "f228temp.tmp" ) key 0 write;

private const
  ShowNullLines=false,  /* Показывать ли строки, где все нули */
  FlagLaserPrint = FALSE; // FALSE - отключить

private const
  CK_NEW          = 0, 
  CK_OLD          = 1;

private const
  TYPEDOC_CARRYON   = 2;

private var
  HeadPrinted,
  SmbMetalPrinted,
  NameMetalPrinted = false,
  NeedPrintNewMetallName = false, /* Печатать название металла после предыдущего */
  NeedPrintOutCoinMetTotLine = false; /* Печатать ли итоговую строку по металлу */


private var
  MetalSubheadPrinted,
  PrevDate,
  IsExistRest = true;

private var
  TotPrevRest=$0,
  TotPrevRestMass=$0,
  TotPrevRestSum=$0,
  TotCredit=$0,
  TotCreditMass=$0,
  TotCreditSum=$0,
  TotDebet=$0,
  TotDebetMass=$0,
  TotDebetSum=$0,
  TotOtherCred=$0,
  TotOtherCredMass=$0,
  TotOtherCredSum=$0,

  MetTotPrevRest=0,
  MetTotPrevRestMass=$0,
  MetTotPrevRestSum=$0,
  MetTotCredit=0,
  MetTotCreditMass=$0,
  MetTotCreditSum=$0,
  MetTotDebet=0,
  MetTotDebetMass=$0,
  MetTotDebetSum=$0,
  MetTotOtherCred=0,
  MetTotOtherCredMass=$0,
  MetTotOtherCredSum=$0;

/*************************************************/
private macro GetStrForSignt()
  var str = "";
  
  if( GetBankStandart() == 0 )
    str = "(наименование, № филиала Сбербанка России/№ ВСП)";
  else
    str = "(Наименование кредитной организации)";
  end;

  return str;
end;
/*************************************************/

private macro FindNextStrAcc()
  
  var RecFoundMy;  //KIN
  var FlagNewStr;  //KIN
  var FlagFirst = TRUE;
  var i = 0;
  var BalPrice = $0l;

       ClearRecord( DBcAccMy );
       DBcAccMy.Branch = Branch;
       DBcAccMy.Date = {curdate};
       DBcAccMy.Subj = Safe;
       DBcAccMy.ValueRef = CashVal.rec.RefValue;
       RecFoundMy = GetGE( DBcAccMy );
       while ( RecFoundMy
         and ( DBcAccMy.Branch == Branch )
         and ( DBcAccMy.Date == {curdate} )
         and ( DBcAccMy.Subj == Safe )
         and ( DBcAccMy.ValueRef == CashVal.rec.RefValue ))
         
           // Делаем проверку на разные балансовые стоимости
         if(FlagFirst)  // первый раз заходим
          BalPrice  = DBcAccMy.BalCost;
          FlagFirst = FALSE;
          i = i + 1;
         else // другие разы
            if (BalPrice == DBcAccMy.BalCost) // Если цена одинакова
                i = i + 1;
            else  // Цена разная
                BalPrice = DBcAccMy.BalCost;
            end;
         end;

         RecFoundMy = Next( DBcAccMy );
       end;
       if (i > 1) // Больше одной записи
        FlagNewStr = TRUE;
       else
        FlagNewStr = FALSE;
       end;
    
    return FlagNewStr;

end;

private macro GetBranchName()
  var ddep = TRecHandler( "i_dp_dep.rec" );
  var party = TRecHandler( "i_party.rec" );

  if ( findDepartment(NumFNCash, null, ddep, party) )
    return party.rec.Name + "  " + ddep.rec.Name;
  else
    return "<не найден>";
  end;
end;

private macro PrintSeparator()
  [+----------------------+--------+-----------+------------+--------------+];
end;

private macro OutCoinHeader;

  var dateStr = TDateStorage;

  if( FlagLaserPrint )
    println ("E&l1O(3R(s0p16.00h16)");
  end;
  [ ];
  [ ########################################################################]
  ( GetBranchName:w );
  [ ------------------------------------------------		      ф.№228];
  [ ################################################			    ]
  ( GetStrForSignt():c );
  [ ];                                                                      
  [ ];                                                                      
  [                 		       К Н И Г А    		            ];
  [ 	 учета монет Банка России (старых образцов) и иностранных монет     ];
  [                     из драгоценных металлов в хранилище                 ];
  [ ];
  [ ];
  [                                                          Месяц__#_______]
  ( dateStr.getNameMonthForNum(null,true) );
/*
  if ( {RprtDSubj} == "" )
    PrintLn( DeskSubj.Desc );
  end;
*/
  [+----------------------+--------+-----------+---------------------------+];
  [|     Краткое          |        | Качество  |          Остаток на       |];
  [|   наименование       | Металл |           |      #                    |]( dateStr.getDateInCurStr("\"dd\" month yyyy г.", {curdate} + 1) );
  [|  монеты, номинал     |        | чеканки,  |                           |];
  [|                      |        |  проба    |------------+--------------+];
  [|                      |        |           |            |              |];
  [|                      |        |           | Кол-во, шт |    Сумма     |];
  [|                      |        |           |            |     руб.     |];
  PrintSeparator();                             
/*
  [|         1            |   2    |     3     |      4     |       5      |];
  PrintSeparator();
*/
end;

private macro OutCoinTail

  [ ];
  [ Заведующий кассой            _______________     ______________________ ];
  [  			  		                    (Ф.И.О.)        ];
  [ ];
  [ Руководитель филиала банка   _______________     ______________________ ];
  [  				  	 	            (Ф.И.О.)        ];
  [ ];
  [ С данными бухгалтерского учета сверено:				    ];
  [ ];
  [ Главный бухгалтер		 _______________     ______________________ ];
  [  					                    (Ф.И.О.)        ];
  [ ];
  PrintLn( StrFor( 12 ) );
end;


macro OutCoinMetTotLine(metall)

  [|######################|                    |############|##############|]
  (
    "Итого " + metall + ":", 
/*
    MetTotPrevRest:z:w,
    (MetTotPrevRestMass):3:2:z:w,
    MetTotPrevRestSum:z:w,
    MetTotCredit:z:w,
    (MetTotCreditMass):3:2:z:w,
    MetTotCreditSum:z:w,
    MetTotDebet:z:w,
    (MetTotDebetMass):3:2:z:w,
    MetTotDebetSum:z:w,
*/
    MetTotOtherCred,
/*    (MetTotOtherCredMass):3:2:z:w, */
    MetTotOtherCredSum:z:w
  );
  PrintSeparator();

  MetTotPrevRest=0;
  MetTotPrevRestMass=$0;
  MetTotPrevRestSum=$0;
  MetTotCredit=0;
  MetTotCreditMass=$0;
  MetTotCreditSum=$0;
  MetTotDebet=0;
  MetTotDebetMass=$0;
  MetTotDebetSum=$0;
  MetTotOtherCred=0;
  MetTotOtherCredMass=$0;
  MetTotOtherCredSum=$0;

end;

private macro CreateStr( HallMarkRef )
  var retval = string(HallMarkRef);
  while( (strlen(retval) > 0) and (substr(retval, strlen(retval), 1) == "0" ) )
    retval = substr(retval,1,strlen(retval)-1);
  end;
  if( substr(retval,strlen(retval),1) == "." )
    retval = substr(retval,1,strlen(retval)-1);
  end;
  return retval;
end;

private macro OutCoinLine();

var Metall,
    Name,
    Quality,
    Par,
    IssueYear,
    PrevRest,
    Weight,
    BalCost,
    Cred,
    Deb,
    CurRest,
    NeedTotLine = false;

  rewind( Tmp );
  while(next(Tmp))

    Name = Tmp.Name;
    Quality = Tmp.Quality;
    Par = Tmp.Par;
    IssueYear = Tmp.IssueYear;
    PrevRest = Tmp.PrevRest;
    Weight = Tmp.Weight;
    BalCost = Tmp.BalCost;
    Cred = Tmp.Cred;
    Deb = Tmp.Deb;
    CurRest = Tmp.CurRest;

    if ( ( PrevRest != $0 ) or ( Cred != $0 ) or ( Deb != $0 ) or ( CurRest != $0 ) )

      if ( not HeadPrinted )
        OutCoinHeader;
        HeadPrinted = true;
      end;

      if( Metall != Tmp.Metall )
        if(NeedTotLine and NeedPrintOutCoinMetTotLine)
          OutCoinMetTotLine(Metall);
        end;
        Metall = Tmp.Metall;
        if( NeedPrintNewMetallName )
          [|																	    				|];
          [|###################### 													    					|]
          ( ("Металл: " + Metall):w );
        end;
        NeedTotLine = true;
      end;  

      [|######################|########|###########|############|##############|] 
      (
        ( Name + ", " + Par ):w,
/*          String( IssueYear ) ):w,*/

        Tmp.Metall:w,

        (Quality + ", " + CreateStr(Tmp.HallMarkRef)):w,
/*
        Par:w,
   
        BalCost:z, 
        
        PrevRest:z,
        PrevRest * Double( Weight / 10000  ):0:2:z,
        BalCost * PrevRest:z, 

        Cred:z,
        Cred * Double( Weight / 10000  ):0:2:z,
        BalCost * Cred:z, 

        Deb:z,
        Deb * Double( Weight / 10000  ):0:2:z,
        BalCost * Deb:z, 
*/
        CurRest:z,
/*        CurRest * Double( Weight / 10000  ):0:2:z, */
        BalCost * CurRest:z 
      );              
      PrintSeparator();

      MetTotPrevRest=MetTotPrevRest + PrevRest;
      MetTotPrevRestMass=MetTotPrevRestMass + PrevRest * Double( Weight / 10000  );
      MetTotPrevRestSum=MetTotPrevRestSum + BalCost * PrevRest;
      MetTotCredit=MetTotCredit + Cred;
      MetTotCreditMass=MetTotCreditMass + Cred * Double( Weight / 10000  );
      MetTotCreditSum=MetTotCreditSum + BalCost*Cred;
      MetTotDebet=MetTotDebet + Deb;
      MetTotDebetMass=MetTotDebetMass + Deb * Double( Weight / 10000  );
      MetTotDebetSum=MetTotDebetSum + BalCost * Deb;
      MetTotOtherCred=MetTotOtherCred + CurRest;
      MetTotOtherCredMass=MetTotOtherCredMass + CurRest * Double( Weight / 10000  );
      MetTotOtherCredSum=MetTotOtherCredSum + BalCost * CurRest;
    end;

  end;
  if(NeedTotLine and NeedPrintOutCoinMetTotLine)
    OutCoinMetTotLine(Metall);
  end;
  if(HeadPrinted)
    OutCoinTail;
  end;
end;

private macro GetHallMark( HallMarkRef )
file Ci_Code2( "ci_code.dbt" ) key 0;
var retval = 0;

  Ci_Code2.AutoKey = HallMarkRef;
  if( getEQ( Ci_Code2 ) )
    retval = Ci_Code2.Double;
  end;

  return retval;
end;

private macro FillTmpFile(BalCost,PrevRest,CurRest,Cred,Deb);

  Tmp.Metall = CICode.String;
  Tmp.Name =  CIMisc.Name;
  Tmp.Quality = CIMisc.Quality;
  Tmp.Par = CIMisc.Par;
  Tmp.IssueYear = CIMisc.IssueYear;
  Tmp.Weight = CIMisc.Weight;
  Tmp.BalCost = BalCost;
  Tmp.PrevRest = PrevRest;
  Tmp.Cred = Cred;
  Tmp.Deb = Deb;
  Tmp.CurRest = CurRest;
  Tmp.HallMarkRef = GetHallMark( CIMisc.HallMarkRef );
  if ( ( Tmp.PrevRest != $0 ) or ( Tmp.Cred != $0 ) or ( Tmp.Deb != $0 ) or ( Tmp.CurRest != $0 ) )
    if(not Insert( Tmp ))
      MsgBox("Не могу вставить строку во временный файл!");
    end;
  end;

end;

private macro IsCashDocConfirmed

  ClearRecord( CashDoc );
  CashDoc.RefValue = DBcDoc.ValueRef;
  CashDoc.ApplicationKind = DBcDoc.LinkApplicKind;
  CashDoc.ApplicationKey = DBcDoc.LinkApplicKey;
  if ( GetEQ( CashDoc ) and CashDoc.TypeDoc == TYPEDOC_CARRYON )
    return true;
  end;
  return false;
end;

private macro CalcCoinTurns( Cred, Deb )

  var
    RecFound;

  Cred = Deb = 0;
  ClearRecord( DBcDoc );
  DBcDoc.Branch = Branch;
  DBcDoc.Date = {curdate};
  DBcDoc.Subj = "";  // При покупке монет система ничего там не пишет
//  DBcDoc.Subj = Safe;
  DBcDoc.ValueRef = DBcAcc.ValueRef;
  DBcDoc.DateReceived = DBcAcc.DateReceived;
  DBcDoc.BalCost = DBcAcc.BalCost;
  RecFound = GetGE( DBcDoc );
  while ( RecFound
    and ( DBcDoc.Branch == Branch )
    and ( DBcDoc.Date == {curdate} )
//    and ( DBcDoc.Subj == Safe )
//    and ( DBcDoc.ValueRef == DBcAcc.ValueRef )
//    and ( DBcDoc.BalCost == DBcAcc.BalCost ) 
        )
    if (( DBcDoc.ValueRef == DBcAcc.ValueRef ) AND  ( DBcDoc.BalCost == DBcAcc.BalCost ))
      if ( IsCashDocConfirmed )
        if (not(DBcDoc.Subj)) // Только при покупке монет  оно не заполнено
           Cred = Cred + DBcDoc.NumItems;
        else // Остальное без изменений
          if ( DBcDoc.Subj == Safe )
            if ( DBcDoc.DebCred == FLAGDEBCRED_IN )
              Cred = Cred + DBcDoc.NumItems;
            else
              Deb = Deb + DBcDoc.NumItems;
            end;
          end;
        end;
      end;
    end;
    RecFound = Next( DBcDoc );
  end;
  SetParm( 0, Cred );
  Setparm( 1, Deb );
end;

private macro ReportOnCurBalCost

  var
    RecFound,
    BalCost = DBcAcc.BalCost, 
    PrevRest=0,
    CurRest=0,
    Deb=0,
    Cred=0,
    DateForPrevRest;

  GetPos( DBcAcc );

  CurRest = DBcAcc.NumItems;
  CalcCoinTurns(Cred,Deb);

  if(IsExistRest)
    if( ValType( PrevDate ) == V_UNDEF )
      ClearRecord( SbCasac );
      SbCasac.Branch = Branch;
      SbCasac.Date = {curdate};
      SbCasac.CashOper = "";
      SbCasac.SubAccount = "";
      SbCasac.RefValue = 0;
      IsExistRest = GetLT( SbCasac );
      if(IsExistRest)
	PrevDate = SbCasac.Date;
      end;
    end;
    if(IsExistRest)
      ClearRecord( DBcAcc );
      DBcAcc.Branch = Branch;
      DBcAcc.Date = PrevDate;
      DBcAcc.Subj = Safe;
      DBcAcc.ValueRef = CashVal.rec.RefValue;
/*      DBcAcc.BalCost = BalCost;*/
      RecFound = GetGE( DBcAcc );
      while( RecFound and
            (DBcAcc.Branch == Branch) and
            (DBcAcc.Date == PrevDate) and
            (DBcAcc.Subj == Safe)     and
            (DBcAcc.ValueRef == CashVal.rec.RefValue) and
            (DBcAcc.BalCost != BalCost) )
        RecFound = next( DBcAcc );
      end;
      if( RecFound and
         (DBcAcc.Branch == Branch) and
         (DBcAcc.Date == PrevDate) and
         (DBcAcc.Subj == Safe)     and
         (DBcAcc.ValueRef == CashVal.rec.RefValue) and
         (DBcAcc.BalCost == BalCost) )
        PrevRest = PrevRest + DBcAcc.NumItems;
      end;
    end;
  end;

  GetDirect( DBcAcc );
/*  OutCoinLine(DBcAcc.BalCost,PrevRest,CurRest,Cred,Deb); */
  FillTmpFile(DBcAcc.BalCost,PrevRest,CurRest,Cred,Deb);

end;

private macro ReportOnCurCoin

  var
    RecFound;

  ClearRecord( DBcAcc );
  DBcAcc.Branch = Branch;
  DBcAcc.Date = {curdate};
  DBcAcc.Subj = Safe;
  DBcAcc.ValueRef = CashVal.rec.RefValue;
  RecFound = GetGE( DBcAcc );
  while ( RecFound
    and ( DBcAcc.Branch == Branch )
    and ( DBcAcc.Date == {curdate} )
    and ( DBcAcc.Subj == Safe )
    and ( DBcAcc.ValueRef == CashVal.rec.RefValue ) )
    if( 
      ( DeskSubj.Type < 5 ) AND // Операция не кладовой и не вечерней кассы
      (DBcAcc.NumItems == 0)  // Нулевой остаток на строке
      )
      if(FindNextStrAcc())  // Проверяем, есть ли еще строки за день
        // Шагаем на следующую строку
        RecFound = Next( DBcAcc );
      else // Строк больше нет, выпускаем отчет
        ReportOnCurBalCost;  
        RecFound = Next( DBcAcc );
      end;
    else
      ReportOnCurBalCost;  
      RecFound = Next( DBcAcc );
    end;
  end;
end;

private macro ReportOnCoinResourcesForMetal;

  var stat;
                       
  CashVal.KeyNum = 1;
  CashVal.rec.TypeValue = CV_MinCI + CI_COIN;
  CashVal.rec.CodIntValue= 0;
  CashVal.rec.Type = 0;
  stat = CashVal.GetGE;
  while ( (stat)  and
	  (CashVal.rec.TypeValue == CV_MinCI + CI_COIN) )
    FindCIMisc( CI_COIN, CashVal.rec.CodIntValue );
    if ( ( CIMisc.KindOfCoin == CK_OLD ) 
      and ( CIMisc.MaterialRef == CICode.AutoKey ) )
      ReportOnCurCoin();
    end;
    stat = CashVal.Next;
  end;            
  if( SmbMetalPrinted and NeedPrintOutCoinMetTotLine )
    OutCoinMetTotLine;
  end;
end;


macro ReportOnCoinResources;

  var
    RecFound;

  TotPrevRest=$0;
  TotPrevRestMass=$0;
  TotPrevRestSum=$0;
  TotCredit=$0;
  TotCreditMass=$0;
  TotCreditSum=$0;
  TotDebet=$0;
  TotDebetMass=$0;
  TotDebetSum=$0;
  TotOtherCred=$0;
  TotOtherCredMass=$0;
  TotOtherCredSum=$0;

  ClearRecord( CICode );
  CICode.UpLink = 0;
  CICode.Group = 2; 
  RecFound = GetGE( CICode );
  while ( RecFound
    and ( CICode.UpLink == 0 ) 
    and ( CICode.Group == 2 ) ) 
    ReportOnCoinResourcesForMetal;
    RecFound = Next( CICode );
  end;
  if ( HeadPrinted )
    OutCoinTail;
  end;
end;

macro ClearTmpFile
   var cmd;
   cmd = RsdCommand( NULL, string("truncate table df228temp_tmp") );
   cmd.execute();

end;


macro TreatCurrentSafe

  TotPrevRest=$0;
  TotPrevRestMass=$0;
  TotPrevRestSum=$0;
  TotCredit=$0;
  TotCreditMass=$0;
  TotCreditSum=$0;
  TotDebet=$0;
  TotDebetMass=$0;
  TotDebetSum=$0;
  TotOtherCred=$0;
  TotOtherCredMass=$0;
  TotOtherCredSum=$0;

/*  if ( Index( DeskSubj.Reports, "W" ) != 0 )*/
  ClearTmpFile;
  ReportOnCoinResources;
  OutCoinLine;
/*  end;*/
end;
