/*
$Name: total203.mac
$Module: Касса
$Description: Сводная форма 203
*/

/* закомментировано при удалении таблицы ddesk_rec_dbt по ##197859, 198467 */
/*
import DeprIntr, Pcs2Mon, OperCode, SQLConv;

var
  DeskRec = TBFile( "desk_rec.dbt", "w", 0 ), 
  CashVal = TBFile( "sb_casvl.dbt", "r", 0 ), 
  NameAlg = TBFile( "namealg.dbt", "r", 0, "namealg.dbt", "bank.def" ), 
  DSubOper = TBFile( "dsuboper.dbt", "r", 0 ), 
  CashDoc = TBFile( "sb_casdc.dbt", "r", 0 ), 
  Bunch = TBFile( "bunch.dbt", "r", 0 ), 
  DepDoc = TBFile( "sbdepdoc.dbt", "r", 3 ), 
  GroupMember = TBFile( "groupmem.dbt", "r", 0 );

const
  SB_NOTBALANCE = 1000,
  TYPERES_CURRENCY = 1;

const
  TYPEDOC_CARRYOFF = 1,  /* Отложен (не подтвержден) */
  TYPEDOC_CARRYON  = 2;  /* Проведен (подтвержден)   */

const
  DOT_NONE  = 0,		/* Ордер не выпускается */
  DOT_53_54 = 1, 		/* Ордера 53/54 */
  DOT_203   = 2;		/* Ордер 203 */

private var
  Branch = NumFNCash,
  Brigade = GetOperBrigade,
  {curdate};                      

const
  TYPE_RES_PAY    = 0, /* Платежеспособные ресурсы */
  TYPE_RES_NOPAY  = 1, /* Неплатежеспособные ресурсы */
  TYPE_RES_DOUBT  = 2, /* Сомнительные ресурсы */
  TYPE_RES_SAVE   = 3, /* На хранении */
  TYPE_RES_EXP    = 4, /* На экспертизу */
  TYPE_RES_INCASS = 5; /* На инкассо */

const
  CV_Currency = 1,
  CV_ValForm = 2,
  CV_MinCI = 500;

const
  VALFORM_BOOK     = 1,
  VALFORM_CUR_BOOK = 1,
  VALFORM_2O       = 14, 
  VALFORM_27       = 6;

const
  SB_CASHDOC       = -10;

const
  CASHOP_DEBET     = 5;

const
  OP_OPENCAS       = 1;

array
  NewAcc,
  OnDemand,
  Replace;

var
  LineCnt=0,
  NewAccCnt=0,
  OnDemandCnt=0,
  ReplaceCnt=0;

file RetOp ("ret_op.dbt") key 0;
var TypeComplexOper;


const
	OP_DUBL_SBOOK           =   206,
	OP_CONTRACT_OPEN        =   1401,
	OP_CARDCNTR_OPEN        =   1411,
	OP_OPEN_MAINCARDCTR_ACC =   301,
	SB_DEPOSIT				=	1;

macro IntTo07Str( n )

  var
    s = String( n );

  while ( StrLen( s ) < 7 )
    s = "0" + s;
  end;
  return s;
end;

macro ToStr( n )
  
  if ( ( CashVal.Rec.TypeValue == CV_ValForm ) and ( CashVal.Rec.CodIntValue == VALFORM_27 ) )
    return IntTo07Str( n );
  else
    return String( n );
  end;
end;

macro GetWorkDeskName( OperID, BrigadeID )

  var
    OperStr = String( OperID ),
    BrigadeStr = String( BrigadeID );

  return MkStr( "0", 4 - StrLen( OperStr ) ) + OperStr + "/" +
    MkStr( "0", 2 - StrLen( BrigadeStr ) ) +BrigadeStr;
end;

macro OutBackHead;

  [ ----------------------------------------------------------------------];
  [ |   Номера лицевых счетов, по которым израсходованы ценные бланки    |];
  [ |--------------------------------------------------------------------|];
  [ |  Выписано по вновь   |   Выписано при явке  |    Выписано взамен   |];
  [ |   открытым счетам    |       вкладчиков     |  исписан. и утрачен. |];
  [ |----------------------|----------------------|----------------------|];
end;

macro OutBackBottom;

/*
  [___________________________________________________________________________________________________________________________];
  [ ];
  [     
         Ст. контролер ___________________             Кассир __________________
  ];
*/
  [ ----------------------------------------------------------------------];
  [ ];
  [ ];
end;

macro OutBackLine;

  var
    NewAccItem="",
    OnDemandItem="",
    ReplaceItem="";

  if(LineCnt<NewAccCnt)
    NewAccItem=NewAcc(LineCnt);
  end;
  if(LineCnt<OnDemandCnt)
    OnDemandItem=OnDemand(LineCnt);
  end;
  if(LineCnt<ReplaceCnt)
    ReplaceItem=Replace(LineCnt);
  end;

  [  ###################### ###################### ###################### ]
  (
    NewAccItem,
    OnDemandItem,
    ReplaceItem
  );
end;

//Возвращает номер счета дока из sbdepdoc.dbt


macro GetAccFromDoc(appKind, appKey)
	var cmd, rs;

    cmd = RsdCommand(
	    "Select "
			"T_ACCOUNT as Acc, "
			"T_TYPECOMPLEXOPER as TypeComplexOper "
		"From DSBDEPDOC_DBT "
		"Where "
			"T_IAPPLICATIONKIND=? "
			"AND T_APPLICATIONKEY=? "
	);
	cmd.addParam("appKind", RSDBP_IN, appKind);
	cmd.addParam("appKey", RSDBP_IN, appKey);

	cmd.execute();
	
	rs = RsdRecordset(cmd);
	if( rs.MoveNext() )
	    TypeComplexOper=rs.value("TypeComplexOper");
	    return rs.value("Acc");
	else
	    return "";
	end;
end;

//Ищем первый (по порядку sb_casln.NumLinkDoc) вкладной документ (sbdepdoc.dbt) в связке.
macro GetDocFromLink(appKind, appKey)
    var cmd, rs;

    cmd = RsdCommand(
	    "Select T_APPLICATIONKEY2 as AppKeyRet "
		"From DSB_CASLN_DBT "
		"Where "
			"T_APPLICATIONKIND1 = ? "
			"AND T_APPLICATIONKEY1=? "
			"AND T_APPLICATIONKIND2=1 "
		"Order by "
			"T_NUMLINKDOC "
			
	);
	cmd.addParam("appKind", RSDBP_IN, appKind);
	cmd.addParam("appKey", RSDBP_IN, appKey);

	cmd.execute();

	rs = RsdRecordset(cmd);
	if( rs.MoveNext() )
	    return rs.value("AppKeyRet");
	else
	    return "";
	end;
end;

macro GetDocAccFromLink(appKind, appKey)
    var ak;
    ak=GetDocFromLink(appKind, appKey);
    if(ak!="")
		return GetAccFromDoc(SB_DEPOSIT, ak);
	else
	    return "";
	end;
end;

macro TreatPrimary
	var acc;
	
	var cmd, rs;
	
    cmd = RsdCommand(
	    "Select "
			"T_APPLICATIONKEY1 as AppKeyRet, "
			"T_APPLICATIONKIND1 as AppKindRet "
		"From DSB_CASLN_DBT "
		"Where "
			"T_APPLICATIONKIND2 = ? "
			"AND T_APPLICATIONKEY2=? "
		"Order by "
			"T_NUMLINKDOC "
	);
	cmd.addParam("appKind", RSDBP_IN, CashDoc.Rec.ApplicationKind);
	cmd.addParam("appKey", RSDBP_IN, CashDoc.Rec.ApplicationKey);

	cmd.execute();

	rs = RsdRecordset(cmd);
	if( rs.MoveNext() )
	    RetOp.ApplicationKind=rs.value("AppKindRet");
	    RetOp.ApplicationKey=rs.value("AppKeyRet");
	else
	    return;
	end;

	if(GetEQ(RetOp))
		if(RetOp.Operation == OP_DUBL_SBOOK)
		    Replace(ReplaceCnt)=GetDocAccFromLink(RetOp.ApplicationKind, RetOp.ApplicationKey);
		    ReplaceCnt=ReplaceCnt+1;
		    return;
		elif ( in(RetOp.Operation, OP_OPEN_MAINCARDCTR_ACC, OP_CONTRACT_OPEN, OP_CARDCNTR_OPEN) )
			NewAcc(NewAccCnt)=GetDocAccFromLink(RetOp.ApplicationKind, RetOp.ApplicationKey);
	      	NewAccCnt=NewAccCnt+1;
	      	return;
		else
		    TypeComplexOper=0;
		    acc=GetDocAccFromLink(RetOp.ApplicationKind, RetOp.ApplicationKey); //SB_DEPOSIT
		    if( (acc!="") And (TypeComplexOper == OP_OPENCAS) )
			    NewAcc(NewAccCnt)=acc;
			    NewAccCnt=NewAccCnt+1;
			    return;
		    end;
		end;

		acc=GetDocAccFromLink(RetOp.ApplicationKind, RetOp.ApplicationKey);
		if(acc!="")
	        OnDemand(OnDemandCnt)= acc;//RetOp.ApplicationKey;
			OnDemandCnt=OnDemandCnt+1;
		end;
	end;
end;

macro TreatDocsForOper

  var
    Subj = GetWorkDeskName( GroupMember.Rec.Oper, Brigade ),
    RecFound;

  CashDoc.Rec.Branch=Branch;
  CashDoc.Rec.CashDateDoc={curdate};
  CashDoc.Rec.TypeDoc=TYPEDOC_CARRYON;
  CashDoc.Rec.CashOper=Subj;
  CashDoc.Rec.RefValue=CashVal.Rec.RefValue;

  CashDoc.AddFilter( "t.t_Branch = " + String( Branch ) +
                     " and t.t_CashDateDoc = " + SQLDateToStr( {curdate} ) +
                     " and t.t_TypeDoc = " + String( TYPEDOC_CARRYON ) +
                     " and t.t_CashOper = " + GetSQLString( Subj ) +
                     " and t.t_RefValue = " + String( CashVal.Rec.RefValue ) +
                     " and t.t_NumOper = " + String( CASHOP_DEBET ) );

  RecFound=CashDoc.GetGE;
  while(RecFound and
    (CashDoc.Rec.Branch==Branch) and
    (CashDoc.Rec.CashDateDoc=={curdate}) and
    (CashDoc.Rec.TypeDoc==TYPEDOC_CARRYON) and
    (CashDoc.Rec.CashOper==Subj) and
    (CashDoc.Rec.RefValue==CashVal.Rec.RefValue))
    if(CashDoc.Rec.NumOper==CASHOP_DEBET)
      TreatPrimary;
    end;
    RecFound=CashDoc.Next;
  end;

  CashDoc.DropFilter;
end;

macro TreatOpers

  var
    RecFound;

  GroupMember.Clear;
  GroupMember.Rec.Branch = Branch;
  GroupMember.Rec.Date = {curdate};
  GroupMember.Rec.Group = Brigade;

  GroupMember.AddFilter( "t.t_Branch = " + String( Branch ) +
                         " and t.t_Date = " + SQLDateToStr( {curdate} ) +
                         " and t.t_Group = " + String( Brigade ) );

  RecFound = GroupMember.GetGE;
  while(RecFound
    and (GroupMember.Rec.Branch == Branch)
    and (GroupMember.Rec.Date == {curdate})
    and (GroupMember.Rec.Group == Brigade))
    TreatDocsForOper;
    RecFound = GroupMember.Next;
  end;

  GroupMember.DropFilter;
end;

macro PrintBookInfo

  var
    NumLines;

  OutBackHead;
  NewAccCnt=0;
  OnDemandCnt=0;
  ReplaceCnt=0;
  LineCnt=0;
  ASize(NewAcc,0);
  ASize(OnDemand,0);
  ASize(Replace,0);
  TreatOpers;
  NumLines=NewAccCnt;
  if(OnDemandCnt>NumLines)
    NumLines=OnDemandCnt;
  end;
  if(ReplaceCnt>NumLines)
    NumLines=ReplaceCnt;
  end;
  LineCnt=0;
  while(LineCnt<NumLines);
    OutBackLine;
    LineCnt=LineCnt+1;
  end;
  OutBackBottom;
end;

macro PrintRNHead

  [ ];
  [--------------------------------------------------------------------------];
  [|           |                   Номера                     |             |];
  [|  Номинал  |----------------------------------------------|  Количество |];
  [|           |          с           |           по          |             |];
  [|-----------|----------------------|-----------------------|-------------|];
end;

macro PrintRNLine( Par, Series, Min, Max )

  if ( CashVal.Rec.HasRegNumber != StrFor( 0 ) )
    [ ########### ###################### ####################### ############# ]
    ( Par:z, 
      RegNumToStr( Series, Min, true ), 
      RegNumToStr( Series, Max, true ), 
      Max - Min + 1 );
  else
    [ ###########                                                ############# ]
    ( Par:z, Max );
  end;
end;

macro PrintRNForDoc
  
  var
    RecFound;

  if ( CashDoc.Rec.Series or CashDoc.Rec.MinRegistrNumber 
    or ( CashDoc.Rec.Nominal and ( CashVal.Rec.HasRegNumber == StrFor( 0 ) ) ) )
    PrintRNLine( CashDoc.Rec.Nominal, CashDoc.Rec.Series, CashDoc.Rec.MinRegistrNumber, CashDoc.Rec.MaxRegistrNumber );
  else
    Bunch.Clear;
    Bunch.Rec.BagAppKind = CashDoc.Rec.ApplicationKind; 
    Bunch.Rec.BagAppKey = CashDoc.Rec.ApplicationKey; 
    Bunch.Rec.Nominal = $10000000000;

    Bunch.AddFilter( "t.t_BagAppKind = " + String( CashDoc.Rec.ApplicationKind ) +
                     " and t.t_BagAppKey = " + GetSQLString( CashDoc.Rec.ApplicationKey ) );

    RecFound = Bunch.GetGE;
    while ( RecFound
      and ( Bunch.Rec.BagAppKind == CashDoc.Rec.ApplicationKind ) 
      and ( Bunch.Rec.BagAppKey == CashDoc.Rec.ApplicationKey ) )
      PrintRNLine( Bunch.Rec.Nominal, Bunch.Rec.Series, Bunch.Rec.Min, Bunch.Rec.Max );
      RecFound = Bunch.Next;
    end;

    Bunch.DropFilter;
  end;
end;

macro PrintRegNumbers

  var
    RecFound;

  PrintRNHead;

  CashDoc.Clear;
  CashDoc.Rec.Branch = DeskRec.Rec.Branch;
  CashDoc.Rec.CashDateDoc = DeskRec.Rec.Date;
  CashDoc.Rec.TypeDoc = TYPEDOC_CARRYON;

  CashDoc.AddFilter( "t.t_Branch = " + String( DeskRec.Rec.Branch ) +
                     " and t.t_CashDateDoc = " + SQLDateToStr( DeskRec.Rec.Date ) +
                     " and t.t_TypeDoc = " + String( TYPEDOC_CARRYON ) +
                     " and t.t_NumOper = " + String( DeskRec.Rec.Operation ) +
                     " and t.t_SubOper = " + String( DeskRec.Rec.SubOper ) +
                     " and t.t_RefValue = " + String( DeskRec.Rec.ValueRef ) +
                     " and t.t_Brigade = " + String( DeskRec.Rec.Brigade ) );

  RecFound = CashDoc.GetGE;
  while ( RecFound
    and ( CashDoc.Rec.Branch == DeskRec.Rec.Branch )
    and ( CashDoc.Rec.CashDateDoc == DeskRec.Rec.Date )
    and ( CashDoc.Rec.TypeDoc == TYPEDOC_CARRYON ) )
    if (  ( CashDoc.Rec.NumOper == DeskRec.Rec.Operation )
      and ( CashDoc.Rec.SubOper == DeskRec.Rec.SubOper )
      and ( CashDoc.Rec.RefValue == DeskRec.Rec.ValueRef )
      and ( CashDoc.Rec.Brigade == DeskRec.Rec.Brigade ) )
      PrintRNForDoc;
    end;
    RecFound = CashDoc.Next;
  end;

  CashDoc.DropFilter;

  [ ];
  [ ];
end;

macro FindCashValue( RefValue )

  CashVal.Rec.RefValue = RefValue;
  return CashVal.GetEQ;
end;

macro GetGround

  var
    OpStr,
    SubOpStr = "",
    TypeStr = "";

  NameAlg.Rec.iTypeAlg = 803;
  NameAlg.Rec.iNumberAlg = DeskRec.Rec.Operation;
  NameAlg.GetEQ;
  OpStr = NameAlg.Rec.szNameAlg; 

  if ( DeskRec.Rec.SubOper )
    DSubOper.Rec.Branch = Branch;
    DSubOper.Rec.OperType = DeskRec.Rec.Operation;
    DSubOper.Rec.Type = DeskRec.Rec.SubOper;
    if ( DSubOper.GetEQ )
      SubOpStr = " (подвид '" + DSubOper.Rec.Name + "')";
    end;
  end;

  if ( CashVal.Rec.Type != 0 )
    NameAlg.Rec.iTypeAlg = 811;
    NameAlg.Rec.iNumberAlg = CashVal.Rec.Type;
    NameAlg.GetEQ;
    TypeStr = " (" + NameAlg.Rec.szNameAlg + ")";
  end;

  return OpStr + SubOpStr + ": " + CashVal.Rec.NameValue + TypeStr;
end;

macro PrintOrd

  FindCashValue( DeskRec.Rec.ValueRef );

  if ( ( CashVal.Rec.OrderType == DOT_203 ) 
    and ( ( CashVal.Rec.HasRegNumber != StrFor( 0 ) ) 
    or ( CashVal.Rec.HasNominal != StrFor( 0 ) ) ) )
    PrintRegNumbers;
  end;

  if  ( ( CashVal.Rec.TypeValue == CV_ValForm )
    and ( DeskRec.Rec.Operation == CASHOP_DEBET )
    and ( ( CashVal.Rec.CodIntValue == VALFORM_BOOK )
       or ( CashVal.Rec.CodIntValue == VALFORM_CUR_BOOK )
       or ( CashVal.Rec.CodIntValue == VALFORM_2O ) ) )
    PrintBookInfo;
  end;
end;

macro BatchReportForCurrMode( IsCur );

  var
    i = 0,
    RecFound;

  DeskRec.Clear;
  DeskRec.Rec.IsCur = IsCur;
  DeskRec.Rec.Branch = Branch;
  DeskRec.Rec.Date = {curdate};

  DeskRec.AddFilter( "t.t_IsCur = " + String( IsCur ) +
                     " and t.t_Branch = " + String( Branch ) +
                     " and t.t_Date = " + SQLDateToStr( {curdate} ) +
                     " and t.t_Brigade = " + String( Brigade ) ); 

  RecFound = DeskRec.GetGE;
  while ( RecFound
    and ( DeskRec.Rec.IsCur == IsCur )
    and ( DeskRec.Rec.Branch == Branch )
    and ( DeskRec.Rec.Date == {curdate} ) )
    if ( DeskRec.Rec.Brigade == Brigade )
      PrintOrd;                     
      i = i + 1;
      Message( "Ордеров напечатано: " + String( i ) );
    end;
    RecFound = DeskRec.Next;
  end;   

  DeskRec.DropFilter;
end;

macro BatchReport

  BatchReportForCurrMode( NumFlagCur );
end;

macro PrintSingleOrder( AppKind, AppKey )

  DeskRec.KeyNum = 1;
  DeskRec.Rec.ApplicationKind = AppKind;
  DeskRec.Rec.ApplicationKey  = AppKey;
  if ( DeskRec.GetEQ )
    PrintOrd;
  end;
end;

*/