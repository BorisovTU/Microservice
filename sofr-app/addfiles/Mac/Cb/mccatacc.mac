/*
$Name:             mccatacc.mac
$Module:           Ядро ГКБО
$Description:      Фомирование номеров счетов для создания по категориям
*/
IMPORT CTInter, FIInter, OprInter, PTInter, SFInter, BankInter, "globals.mac", "mccatacf.mac", rsd, "likepy.mac", oralib, mc_lib, "dlmisc.mac";
import lib_str,fx_globals;

/*Номера символов из MCSTPELM_DBT*/
PRIVATE CONST MCSTPELM_SYMBOL_В = 1, /*Код валюты л/с;*/
              MCSTPELM_SYMBOL_Э = 2, /*Код эмитента (код вида "Код для л/с" эмитента)*/
              MCSTPELM_SYMBOL_Б = 3, /*Балансовый счет*/
              MCSTPELM_SYMBOL_А = 4, /*Код для л/с (вида "Код для л/с") векселедателя или акцептанта*/
              MCSTPELM_SYMBOL_Р = 5, /*код для л/с (вида "Код для л/с")" для торговой площадки (расчетного центра)*/
              MCSTPELM_SYMBOL_Г = 6, /*Код гарантийного обеспечения)*/
              MCSTPELM_SYMBOL_С = 7, /*Код сектора торговой площадки*/
              MCSTPELM_SYMBOL_Ф = 8, /*Номер филиала*/
              MCSTPELM_SYMBOL_К = 9, /*Защитный ключ*/
              MCSTPELM_SYMBOL_Л = 10, /*Код срочности*/
              MCSTPELM_SYMBOL_V = 11, /*Код финансового иструмента*/
              MCSTPELM_SYMBOL_U = 12, /*Код для л/с (вида "Код для л/с") клиента по счету*/
              MCSTPELM_SYMBOL_S = 13, /*Код клиента в БО ценных бумаг (22)*/
              MCSTPELM_SYMBOL_П = 14, /*Символы, заданные в маске шаблона номера*/
              MCSTPELM_SYMBOL_У = 15, /*Код л/с доходов/расходов*/
              MCSTPELM_SYMBOL_Н = 16, /*Номер договора/сделки (номер документа)*/
              MCSTPELM_SYMBOL_Д = 17, /*Код договора обслуживания клиента*/
              MCSTPELM_SYMBOL_D = 18, /*Код договора обслуживания банка*/
              MCSTPELM_SYMBOL_О = 19, /*Код для л/с (вида "Код для л/с") для владельца*/
              MCSTPELM_SYMBOL_М = 20, /*Код для л/с (вида "Код для л/с") для места хранения*/
              MCSTPELM_SYMBOL_W = 21, /*Номер вышестоящего документа данного первичного документа*/
              MCSTPELM_SYMBOL_F = 22, /*Код бэк-офиса*/
              MCSTPELM_SYMBOL_Е = 23, /*Код для л/с (вида "Код для л/с") (центра ответственности для субъекта*/
              MCSTPELM_SYMBOL_Х = 24, /*Код портфеля*/
              MCSTPELM_SYMBOL_Q = 25, /*День месяца даты картотеки*/
              MCSTPELM_SYMBOL_G = 26, /*Номер месяца даты картотеки*/
              MCSTPELM_SYMBOL_Т = 27, /*Год даты картотеки*/
              MCSTPELM_SYMBOL_Z = 28, /*Уникальный порядковый номер счета*/
              MCSTPELM_SYMBOL_R = 29, /*Код для л/с (вида "Код для л/с") для контрагента*/
              MCSTPELM_SYMBOL_I = 30, /*Код анкеты векселя*/
              MCSTPELM_SYMBOL_NUMBER = 31, /*Цифры*/
/*              MCSTPELM_SYMBOL_Y = 32, /*Схема переоценки*/ */
              MCSTPELM_SYMBOL_APOSTR = 33,/*Произвольные символы*/
              MCSTPELM_SYMBOL_FK= 34, /*Номер филиала-корреспондента*/
              MCSTPELM_SYMBOL_Ц= 35, /*Код вида договора ДУ*/
              MCSTPELM_SYMBOL_И= 36, /*Код договора ДУ (ИДДУ, ДП ОФБУ, ОУ ОФБУ) в номере л/счета*/
              MCSTPELM_SYMBOL_Ю= 37, /*Код ближайшего узла ТС, в котором есть хранилище ценностей */
              MCSTPELM_SYMBOL_N= 38, /*Вид финансового инструмента*/
              MCSTPELM_SYMBOL_Ъ= 39, /*Назначение счета (код из соотв. параметра)*/
              MCSTPELM_SYMBOL_L = 48, /*Уникальный порядковый номер счета*/
              MCSTPELM_SYMBOL_CODE_KA= 40, /*Код контрагента для срочных контрактов*/
              MCSTPELM_SYMBOL_CODE_REQ = 41, /*Код вида требований*/
              MCSTPELM_SYMBOL_FI_BUH = 42, /*Код вида ФИ для бухучета*/
              MCSTPELM_SYMBOL_Ч = 43, /*Код вида обязательств*/
              MCSTPELM_SYMBOL_CODE_DEB = 44, /*Код вида расходов ДУ*/
              MCSTPELM_SYMBOL_CODE_CRED = 45, /*Код вида доходов ДУ*/
              MCSTPELM_SYMBOL_ACCKIND = 46, /*Код вида счета*/
              MCSTPELM_SYMBOL_ACCFUN = 47, /*Код назначения счета*/
              MCSTPELM_SYMBOL_GENAGR = 49, /*Номер генерального соглашения*/
              MCSTPELM_SYMBOL_FIROLE = 51, /*Роль финансового инструмента*/
              MCSTPELM_SYMBOL_IDSTORAGE = 52, /*ID места хранения*/
              MCSTPELM_SYMBOL_ACCTYPE = 53, /*Тип счета*/
              MCSTPELM_SYMBOL_AVRHDINSTR = 54, /*Порядковый номер открываемого л/с по каждому следующему ИХ*/
              MCSTPELM_SYMBOL_HEDGETYPER = 55, /*Тип отношений хеджирования*/
              MCSTPELM_SYMBOL_COUP_NUM = 56, /*Номер купона*/
              MCSTPELM_SYMBOL_GENAGRFISSIKO = 1000, /*Номер генерального соглашения ФИССИКО*/
              MCSTPELM_SYMBOL_Я = 1001, /*ID сделки для внебиржи ПФИ (ddvndeal_dbt)*/
              MCSTPELM_SYMBOL_Щ = 1002, /*в зависимости от таблицы ddvndeal_dbt ddvdeal_dbt*/
              MCSTPELM_SYMBOL_Ж = 1003, /*Номер для счетов доходов/расходов от переоценки по таблице DNN706_DBT*/
              MCSTPELM_SYMBOL_PSVOP = 1004, /*J - номер платежа по сделке Процентный СВОП*//*PNV*/
              MCSTPELM_SYMBOL_З = 1005, /*Порядковый номер сделки Корзины Репо*/
              MCSTPELM_SYMBOL_Ь = 1006, /*Порядковый номер выпуска для Корзины Репо*/
              MCSTPELM_SYMBOL_1007 = 1007, /*кредитная линия */
              MCSTPELM_SYMBOL_SFCONTRMARKET = 1008;/*Торговая площадка по ДО*/

PRIVATE CONST DPRT_CODE_KIND = "COMMON\\КАТЕГОРИИ СРЕДСТВ\\ВИД_КОДА_ФИЛИАЛА";
PRIVATE CONST VSP_IN_CATACC  = "COMMON\\КАТЕГОРИИ СРЕДСТВ\\ВСП В КУ";

// Подвиды операции удержания НДФЛ enum DL_TXHOLD_OPTYPE
PRIVATE CONST DL_TXHOLD_OPTYPE_TAXREF  = 70;

/*символ в который заключается часть маски, подставляемая в счет без изменений*/
PRIVATE CONST APOSTROPHE     = "\""; 
PRIVATE CONST SET_CHAR = "X";

/*Нужно ключевать созданный счет */
PRIVATE VAR MC_NEED_GETKEY = false; 

PRIVATE VAR mctplelmCH = TBFile( "mctplelm.dbt", "R", 0 );
PRIVATE VAR mctplelmID = TBFile( "mctplelm.dbt", "R", 1 );

private var OperGroupsArray = TArray(); /*кэш*/
private var _Group;

Private MACRO SP_GetOperationGroup_( DealType, BofficeKind, Flag1, Flag4 )

   if( DealType >= 0 )
      if( OperGroupsArray[DealType] == null )
         _Group = GetOperationGroup( DealType );
         if( _Group < 0 )
            return -1;
         end;
      else
         return OperGroupsArray[DealType];
      end;
   else
      return -1;
   end;

   if( BofficeKind == DL_RETIREMENT )
      if( Flag1 == SET_CHAR ) /*ОРЦБ*/
         _Group = bOR( _Group, 4 );
      elif( Flag4 == SET_CHAR ) /*Брокерское*/
         _Group = bOR( _Group, 16384 ); /*IS_BROKER = 0x4000 (100000000000000)*/
      else /*внебиржевое*/    
         _Group = bOR( _Group, 8192 ); /*IS_OUTEXCHANGE = 0x2000 (10000000000000)*/
      end;
   end;
   OperGroupsArray[DealType] = _Group;

   return _Group;
END;

Private MACRO SP_GetOperationGroup( Deal )
   return SP_GetOperationGroup_( Deal.DealType, Deal.BofficeKind, Deal.Flag1, Deal.Flag4 );
END;

Private macro GetOpGroup( dl_tick )
   return SP_GetOperationGroup( dl_tick );
end;

PRIVATE MACRO SayError( Categ:TRecHandler, Error:STRING, IsWarning:BOOL )
   if( IsWarning == null )
      Error = "Ошибка при формировании счета по категории \"" + categ.rec.Code + "\".|" + Error;
   end;

   if( isOprMultiExec == false )
      msgbox( Error );
   end;

   if( IsWarning == null )
      runerror( Error );
   end;
END;

PRIVATE MACRO GetSymbolByIDElement( CatID:INTEGER, IDElement:INTEGER )
  mctplelmID.Clear();
  mctplelmID.rec.CatID     = CatID;
  mctplelmID.rec.IDElement = IDElement;
  if( mctplelmID.GetEQ )
     return mctplelmID.rec.Symbol;
  end;
  return "";
END;

PRIVATE MACRO GetIDElementBySymbol( CatID:INTEGER, Symbol:STRING )
  mctplelmCH.Clear();
  mctplelmCH.rec.CatID  = CatID;
  mctplelmCH.rec.Symbol = Symbol;
  if( mctplelmCH.GetEQ )
     return mctplelmCH.rec.IDElement;
  end;
  return 0;
END;

private macro GetPartOfAccountByPosOnlyNumb(accNumb, begPos, charCount, defaultVal)
  if ((StrLen(accNumb) - begPos - 1) >= charCount)
    var result = SubStr(accNumb, begPos, charCount);
    return IIF(StrIsNumber(result),result,defaultVal);
  end;
  return defaultVal;
end;

/*сконвертить латинскую букву в русскую, если они одинаковы по написанию*/
PRIVATE MACRO ConvertSymb( Symb:STRING )
   var NumPos,
       LatStr = "ABCEHKMOPTX",
       RusStr = "АВСЕНКМОРТХ";

   NumPos = Index( LatStr, Symb );

   if( NumPos > 0 )
      return SubStr( RusStr, NumPos, 1 );
   end;
   return Symb;
END;

/*В верхний регистр и сконвертить в строке латинские буквы в русские (одинаковые по написанию)*/
PRIVATE MACRO ConvertString( SrcString:STRING )
   var i = 1, sym;

   SrcString = StrUpr( SrcString );
   sym = SubStr( SrcString, 1, 1 );
   while( sym )
      StrSet(SrcString, i, ConvertSymb(sym));
      i = i + 1;
      sym = SubStr(SrcString, i, 1)
   end;
   return SrcString;
END;

/*получить номер договора обслуживания*/
PRIVATE MACRO MC_GetContrNumber( id )
  var sfcontr = TRecHandler("sfcontr.dbt");
  
  if( SfGetContr( id, sfcontr ) )     
     return sfcontr.rec.AccCode;
  end;
  return "";
END;

/*  возвращает числовой код значения заданного справочника*/
PRIVATE MACRO MC_GetValueFlag( List, Element )
   var ll = TRecHandler("llvalues.dbt");      
   if( LL_FindLLVALUES( List, Element, ll ) == true )       
      return ll.rec.flag;
   end;    
   return 0; 
END;

/*найти значение классификатора*/
PRIVATE MACRO GetValueFromTempl(categ, templ, ClassNum)
  var value = -1;
  if (categ.rec.Class1 == ClassNum)
    value = templ.rec.Value1;
  elif (categ.rec.Class2 == ClassNum)
    value = templ.rec.Value2;
  elif (categ.rec.Class3 == ClassNum)
    value = templ.rec.Value3;
  elif (categ.rec.Class4 == ClassNum)
    value = templ.rec.Value4;
  elif (categ.rec.Class5 == ClassNum)
    value = templ.rec.Value5;
  elif (categ.rec.Class6 == ClassNum)
    value = templ.rec.Value6;
  elif (categ.rec.Class7 == ClassNum)
    value = templ.rec.Value7;
  elif (categ.rec.Class8 == ClassNum)
    value = templ.rec.Value8;
  end;

  return value;
END;

/*найти значение классификатора*/
MACRO MC_GetValueFromTempl(categ, templ, ClassNum)
  return GetValueFromTempl(categ, templ, ClassNum);
END;

//Порядковый номер ц/б для счетов доходов/расходов от переоценки
PRIVATE MACRO GetFiNumberMarginP( FIID, Symb )
  var sql:string, prm:TArray, rsval:RsdRecordset;

  var query:string = "SELECT COUNT(1) FROM DNN706_DBT nn WHERE nn.t_fiid = :FIID  AND :Symb in (t_ofr07, t_ofr02)";
  var params:TArray = makeArray( SQLParam( "FIID", FIID ),
                               SQLParam( "Symb", Symb ) ); 
  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
     if(rs.value(0) == 1)
        sql = "select to_number(t_nn, '99') from DNN706_DBT where t_fiid = :FIID and :Symb in (t_ofr07, t_ofr02)";
        prm = makeArray( SQLParam( "FIID", FIID ),
                         SQLParam( "Symb", Symb ) ); 
        rsval = execSQLselect( sql, prm, true );
        if( rsval and rsval.moveNext() )
           return int(rsval.value(0)); 
        end;

     elif(rs.value(0) == 0)

        sql = " select NVL(max(to_number(t_nn, '99'))+1, 1) from DNN706_DBT where :Symb in (t_ofr07, t_ofr02)";
        prm = makeArray( SQLParam( "Symb", Symb ) ); 
        rsval = execSQLselect( sql, prm, true );
        if( rsval and rsval.moveNext() )
           return int(rsval.value(0)); 
        end;

     end;
  end;

ONERROR(x)
  
  MsgBox( "Ошибка получения порядкового номера счета для счетов доходов/расходов от переоценки " + x.Message );
  return -1;

END;

/*PNV*/
/*Порядковый номер платежа Проц.СВОП*/
PRIVATE MACRO GetFiNumberPSVOP( dealid, ID)
  var sql:string, NUM = 0;

  var query = "select rownum, pay.* from DDVNPMGR_DBT pay where pay.t_dealid  = ? order by t_paydate";
  var cmd = RSDCommand(query);
  cmd.addParam( "", RSDBP_IN, dealid /*1*/ );
  cmd.execute();
  var rs = TRsbDataSet(cmd);
  while(rs.MoveNext())
     if (ID == rs.id)
         NUM = rs.rownum; 
     end;
  end;
  return Int(NUM);
  ONERROR(x)
  
  MsgBox( "Ошибка получения порядкового номера платежа " + x.Message );
  return -1;

END;
/*PNV*/


private macro L_Z( num, len )
    var str1, len1;
    str1 = trim( string( num ) );
    len1 = strlen( str1 );
    if ( len1 >= len ) return str1;
    else  return  mkstr("0", len-len1 ) + str1;
    end;
end;

Private macro CreateStringL818( FD, account, Acccode );
  var query, cmd, rs;
  var N = 0, AccPart1 = "", StrAcccode = "";

  AccPart1 = SubStr(account, 1, 5);
  If(strlen(Acccode) > 4)
    StrAcccode = substr(Acccode, strlen(Acccode)-4);
  else
    StrAcccode = L_Z(Acccode, 5);
  end;

  query = " select val.t_val "
        + "   FROM (select t_val from dgenval_dbt where t_val <= 99 order by t_val) val "
        + "  WHERE (NOT EXISTS (SELECT 1 " 
        + "                      FROM daccount_dbt acc "
        + "                     WHERE acc.t_sort LIKE (?||'___9900'||LPAD(TO_CHAR(val.t_val), 2, '0')||?) "
        + "                       AND acc.t_account LIKE (?||'____9900'||LPAD(TO_CHAR(val.t_val), 2, '0')||?) "
        + "                       AND acc.t_chapter = 1) "
        + "         OR ((EXISTS (SELECT 1 " 
        + "                      FROM dmcaccdoc_dbt acc "
        + "                     WHERE acc.t_catid = 818 "
        + "                       AND acc.t_iscommon = 'X' "
        + "                       AND acc.t_clientcontrid = ? "
        + "                       AND acc.t_account LIKE (?||'____9900'||LPAD(TO_CHAR(val.t_val), 2, '0')||?) "
        + "                       AND acc.t_chapter = 1)) "
        + "              AND " 
        + "             (NOT EXISTS (SELECT 1 " 
        + "                            FROM daccount_dbt acc " 
        + "                           WHERE acc.t_sort = ?||?||'9900'||LPAD(TO_CHAR(val.t_val), 2, '0')||? " 
        + "                             AND acc.t_account LIKE (?||?||'_9900'||LPAD(TO_CHAR(val.t_val), 2, '0')||?) "
        + "                             AND acc.t_client <> ? "
        + "                             AND acc.t_chapter = 1) " 
        + "             ) "
        + "            )) "
        + "    AND ROWNUM = 1 ";  

  cmd = RSDCommand(query);

  cmd.addParam( "", RSDBP_IN, AccPart1 );
  cmd.addParam( "", RSDBP_IN, StrAcccode );
  cmd.addParam( "", RSDBP_IN, AccPart1 );
  cmd.addParam( "", RSDBP_IN, StrAcccode );
  cmd.addParam( "", RSDBP_IN, FD.Getsubcontr.rec.id );
  cmd.addParam( "", RSDBP_IN, AccPart1 );
  cmd.addParam( "", RSDBP_IN, StrAcccode );
  cmd.addParam( "", RSDBP_IN, AccPart1 );
  cmd.addParam( "", RSDBP_IN, SubStr(account, 6, 3) );
  cmd.addParam( "", RSDBP_IN, StrAcccode );
  cmd.addParam( "", RSDBP_IN, AccPart1 );
  cmd.addParam( "", RSDBP_IN, SubStr(account, 6, 3) );
  cmd.addParam( "", RSDBP_IN, StrAcccode );
  cmd.addParam( "", RSDBP_IN, FD.Getsubcontr.rec.partyid );

  cmd.execute();
  rs = TRsbDataSet(cmd);
  if(rs.MoveNext())
    N = int(rs.value(0));
  end; 

  return N;
END;

PRIVATE MACRO CreateStringL( PartyID, CatID )

if ( CatID == 818) /*+РасчетыКомисс1  слишком много счетов и бессмысленная проверка работает очень долго*/
   return 0;
end;
var query:string = "SELECT COUNT(1) + 1 "+
                   "   FROM dmcaccdoc_dbt mc"+
                   " WHERE mc.t_Contractor = :Contr"+
                   "   AND mc.t_CatID      = :CatID";

var params:TArray = makeArray( SQLParam( "Contr", PartyID ),
                               SQLParam( "CatID", CatID   )
                             ); 

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
    return  int( rs.value(0) );
  else
    return 0;
  end;

ONERROR(x)
  
  MsgBox( "Ошибка получения порядкового номера счета для контрагента" + x.Message );
  return -1;

END;


PRIVATE MACRO Nkl(pa1)

var query:string = " select count(*) from ddl_tick_dbt where t_bofficekind = :bofficekind";

var params:TArray = makeArray( SQLParam( "bofficekind", pa1   )
                             ); 

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
    return  int( rs.value(0) );
  else
    return 0;
  end;

ONERROR(x)
  
  MsgBox( "Ошибка получения порядкового номера кредитной линии" );
  return -1;

END;
  //Нумерация для внебирж. в разрезе сделки
PRIVATE MACRO CreateStringYA( PartyID, CatID, DealID )

var query:string = "SELECT COUNT(1)+1 FROM ("
		   " SELECT 1 "+
                   "   FROM dmcaccdoc_dbt mc, ddvndeal_dbt d"+
                   " WHERE mc.t_docid = d.t_id AND mc.t_Contractor = :Contr"+
                   "   AND mc.t_CatID      = :CatID"+
                  "  AND d.t_id = :DealID" +
		  " UNION ALL " +
		" SELECT 1  " +
		" FROM dmcaccdoc_dbt mc,ddvnpmgr_dbt g, ddvndeal_dbt d " +
		" WHERE mc.t_docid = g.t_id " +
		" AND g.t_dealid = d.t_id "+
		" AND mc.t_Contractor = :Contr "+
		"  AND mc.t_CatID      = :CatID "+
		" AND d.t_id = :DealID "+
		" )";

var params:TArray = makeArray( SQLParam( "Contr", PartyID ),
                               SQLParam( "CatID", CatID   ),
                               SQLParam( "DealID", DealID   )
                             ); 
var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
    return  int( rs.value(0) );
  else
    return 0;
  end;

ONERROR(x)
  
  MsgBox( "Ошибка получения порядкового номера счета для контрагента" + x.Message );
  return -1;

END;

/* Получть уникальный порядковый номер счета*/
PRIVATE MACRO CreateStringZ( categ, SymbolZ, Account, accdoc )
  
  var i, len;
  var SqlMask, Symbol;
  var rs;
  var Z_From, Z_To;
  var QueryStr; 
  var subAcc, retVal;

  /* Установить нулевой счет - запрос вернул, что счета с походящей маской нет */
  PRIVATE MACRO SetNull( Account )
    var i, len;
   
    i = 0; len = strlen( Account );
    while( i < len )
      if( (SubStr(Account, i + 1, 1) == SymbolZ) )
        
        StrSet( Account, i + 1, "0" );
      end;

      i = i + 1;
    end;
    
    return Account;
  end;

  /* Получить и вернуть следующий счет */
  PRIVATE MACRO SetNextAccount( Account, MaxAccount );

    PRIVATE var i, curLenMaxZStr, curLenMaxAccount, N;
    PRIVATE var MaxZStr, Symbol;
    PRIVATE var NextValue : double;
   
    MaxZStr = MaxAccount;

    i = 0; curLenMaxZStr = 0; N = StrLen( MaxAccount );
    while( i < N )
      
      i = i + 1;
      /* в цифра у счета */
      if( Index("0123456789", SubStr(MaxAccount, i, 1)) )
        
        curLenMaxZStr = curLenMaxZStr + 1;

        StrSet( MaxZStr, curLenMaxZStr, SubStr(MaxAccount, i, 1) );

      end;

    end;

    MaxZStr = SubStr( MaxZStr, 1, curLenMaxZStr );

    NextValue = int(MaxZStr) + 1;

    MaxZStr = string( NextValue:0:0 );

    if( StrLen(MaxZStr) > curLenMaxZStr )
      SayError( Categ, "Невозможно сгенерировать подстановку шаблона" );
    end;

    i = 0; N = curLenMaxZStr - strlen( MaxZStr );
    while( i < N )
      MaxZStr = "0" + MaxZStr;

      i = i + 1;
    end;

    i = 0; curLenMaxZStr = 0; curLenMaxAccount = 0; N = StrLen( Account );
    while( i < N )
      
      i = i + 1;

      /* в этой позиции 'Z' у маски */
      if( SubStr(Account, i, 1) == SymbolZ )
        
        curLenMaxAccount = curLenMaxAccount + 1;

        Symbol = SubStr( MaxAccount, curLenMaxAccount, 1 );

        if( Index("0123456789", Symbol) )
          curLenMaxZStr = curLenMaxZStr + 1;

          Symbol = SubStr( MaxZStr, curLenMaxZStr, 1 );
        end;

        StrSet( Account, i, Symbol );

      end;

    end;
    
    return Account;
  end;

  /* 
  *  Начало работы функции
  */

  if( Trim(accdoc.rec.Account) != "" )
    i = 0; len = strlen( Account );
    while( i < len )
      
      i = i + 1;

      if( SubStr(Account, i, 1) == SymbolZ )
        StrSet( Account, i, SubStr(accdoc.rec.Account, i, 1) );
      end;
      
    end;
    return Account;
  end;

  SqlMask = Account;

  Z_From = 0; Z_To = 0;

  i = 0; len = strlen( Account );
  while( i < len )
    
    i = i + 1;

    Symbol = SubStr( Account, i, 1 );
    if( (Symbol == SymbolZ) or (SubStr( categ.rec.Mask, i, 1 ) == GetSymbolByIDElement( accdoc.rec.CatID, MCSTPELM_SYMBOL_К)) )
      
      if( Symbol == SymbolZ )
        if( Z_From == 0 ) Z_From = i; end;
        Z_To = i;
      end;
      
      Symbol = "_";
    end;

    StrSet( SqlMask, i, Symbol );

  end;

  QueryStr = "";
  QueryStr = QueryStr + "SELECT MAX(SUBSTR(t_Account, " + Z_From + ", "+ (Z_To - Z_From + 1)+ ")) AS t_Account ";
  QueryStr = QueryStr + "  FROM ";
  QueryStr = QueryStr + " ( ";
  QueryStr = QueryStr + "SELECT t_AccDocAccount AS t_Account ";
  QueryStr = QueryStr + "  FROM dbatch_mcopenacc_tmp ";
  QueryStr = QueryStr + " WHERE t_AccDocAccount LIKE " + "'" + SqlMask + "' ";
  QueryStr = QueryStr + "UNION ALL ";
  QueryStr = QueryStr + "SELECT t_Account AS t_Account ";
  QueryStr = QueryStr + "  FROM daccount_dbt ";
  QueryStr = QueryStr + " WHERE t_Account LIKE " + "'" + SqlMask + "' ";
  QueryStr = QueryStr + " ) ";

  rs = RsdRecordset( QueryStr );
  if( rs.moveNext() )
    subAcc = rs.value(0,retVal);

    if(retVal == false)
      Account = SetNextAccount( Account, rs.value(0) );
    else
      Account = SetNull( Account );
    end;
  end;

  return Account;

END;

PRIVATE VAR TSOrder = NULL;
PRIVATE MACRO GetTSOrder( SFContrID:INTEGER ):BOOL
  if( TSOrder == NULL )
     TSOrder = TRecHandler( "tsorder.dbt" );
  end;
  return CB_GetTSContrBySfContr( SFContrID, TSOrder );
END;

/*Получить код вида договора ДУ в номере л/счета*/
PRIVATE MACRO TSOrder_GetKindCodeInAccount( accdoc:TRecHandler )
  VAR Value = -1;

  if( GetTSOrder( accdoc.rec.ClientContrID ) )
     Value = MC_TSOrder_GetKindCode( TSOrder );
     if( Value > 0 )
        Value = MC_GetValueFlag( OBJTYPE_TSKIND_ASSETMANAGE, Value );
     end;
  else
     MsgBox( "По договору ПЗО, указанному в параметрах счета, не найден договор ДУ." );
  end;
  return Value;
END;

/*Код договора ДУ (ИДДУ, ДП ОФБУ, ОУ ОФБУ) в номере л/счета*/
PRIVATE MACRO TSOrder_GetNumber_InAccount( accdoc:TRecHandler )
  VAR Value = -1;

  if( GetTSOrder( accdoc.rec.ClientContrID ) )
     Value = MC_TSOrder_GetCodeInAccount( TSOrder );
  else
     MsgBox( "По договору ПЗО, указанному в параметрах счета, не найден договор ДУ." );
  end;
  return Value;
END;


PRIVATE MACRO GetCodeTSStorage( PartyID:integer):string

var query:string = "select pc.T_CODE"+
                  " from   dpartcode_dbt pc"+
                  " where  pc.T_PARTYID  = :Place"+
                  " and    pc.T_CODEKIND = :VS";

var params:TArray = makeArray( SQLParam( "Place", PartyID            ),
                               SQLParam( "VS"   , PTCK_VALUESSTORAGE )
                             ); 

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
    return  rs.value(0);
  else
    return "0000";
  end;

ONERROR(x)
  
  MsgBox( "Ошибка получения Код хранилища ценностей|" + x.Message );
  return -1;

END;

PRIVATE MACRO GetCodeDVKind( FIID:integer):string

var query:string = "select fi.t_fi_kind, fi.t_avoirkind, dv.t_optiontype, dv.t_optionstyle"+
                   "  from   dfininstr_dbt fi, dfideriv_dbt dv"+
                   " where  fi.t_fiid = dv.t_fiid"+
                   " and    fi.t_fiid = :FIID";

var params:TArray = makeArray( SQLParam( "FIID", FIID ) ); 

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
     if( rs.value(0) == FIKIND_DERIVATIVE )
        if( rs.value(1) == DERIVATIVE_FUTURES )
           return "2";
        elif( rs.value(1) == DERIVATIVE_OPTION )
           if( (rs.value(2) == 2) and (rs.value(3) == 1) )
              return "3";
           elif( (rs.value(2) == 1) and (rs.value(3) == 1) )
              return "4";
           elif( (rs.value(2) == 2) and (rs.value(3) == 2) )
              return "5";
           elif( (rs.value(2) == 1) and (rs.value(3) == 2) )
              return "6";
           else
              return "0";
           end;
        else
           return "0";
        end;
     else
        return "0";
     end;
  else
    return "0";
  end;

ONERROR(x)
  
  MsgBox( "Ошибка получения вида ПИ|" + x.Message );
  return -1;

END;

PRIVATE MACRO GetNextNumberAvrHdInstr(accdoc)
  var query;
  var Num = 1;
  var ObjDocKind;
  if((accdoc.rec.DocKind == SP_AVRHDGRELATION) or (accdoc.rec.DocKind == DL_VEKHDGRELATION))
    query =   " select NVL(MAX(TO_NUMBER(SUBSTR(accdoc.t_Account, 15, 1))), 0)"
            + "   from DDLHDGRELATION_DBT hdg, dmcaccdoc_dbt accdoc "
            + "  where hdg.t_ID = :ID "
            + "    and accdoc.t_CatID   = :CatID "
            + "    and accdoc.t_DocKind = " + accdoc.rec.DocKind
            + "    and accdoc.t_DocID   = hdg.t_ID ";

    var params:TArray = makeArray( SQLParam( "ID",    accdoc.rec.DocID),
                                   SQLParam( "CatID",   accdoc.rec.CatID)
                                 ); 

    var rs:RsdRecordset = execSQLselect( query, params, true );
    if( rs and rs.moveNext() )
      if(int(rs.value(0)) != 0)
         Num = int(rs.value(0)); // На случай, если выполняется поиск счета для уже существующих отношений
      else
         if(accdoc.rec.DocKind == SP_AVRHDGRELATION)
            ObjDocKind = OBJTYPE_AVOIRISS;
         else
            ObjDocKind = OBJTYPE_FICERT;
         end;
         query =   " select NVL(MAX(TO_NUMBER(SUBSTR(accdoc.t_Account, 15, 1))), 0)"
                  + "   from DDLHDGRELATION_DBT hdg, dmcaccdoc_dbt accdoc "
                  + "  where hdg.t_ObjID      = :ObjID "
                  + "    and hdg.t_ObjDocKind = " + ObjDocKind
                  + "    and accdoc.t_CatID   = :CatID "
                  + "    and accdoc.t_DocKind = " + accdoc.rec.DocKind
                  + "    and accdoc.t_DocID   = hdg.t_ID ";

         params = makeArray( SQLParam( "ObjID",    accdoc.rec.FIID),
                           SQLParam( "CatID",   accdoc.rec.CatID)
                                       ); 

         rs = execSQLselect( query, params, true );

    if( rs and rs.moveNext() )
      Num = int(rs.value(0)) + 1;
    end;

    if(Num > 9)
      msgbox("Ошибка при определении порядкового номера ИХ. Номер больше 9");
    end;
  end;
    end;
  end;

  return Num;
END;

PRIVATE MACRO InsertAcc(DealID:integer, Value:integer, Balance:string, Currency:string):integer
  var stat = 0;
  var SQLQuery =
    "DECLARE"
   + " v_Stat INTEGER; "
   + " FUNCTION InsertACC(DealID NUMBER, Val NUMBER, Balance VARCHAR2, Currency VARCHAR2) RETURN NUMBER"
   +  " IS"
   + " BEGIN "
   + " EXECUTE IMMEDIATE 'insert into DBUSYACC_DBT (t_DealID, t_Value, t_Balance, t_Currency) Values (:DealID, :Val, :Balance, :Currency)' " 
   + " USING IN DealID, IN Val, IN Balance, IN Currency;"
   + "   RETURN 0; "
   + " EXCEPTION "
   + " WHEN OTHERS THEN "
   + "   RETURN 1;"
   + " END;"
   + " BEGIN "
   + " ?:= InsertACC(?, ?, ?, ?);"
   + " END; ";

  var RsdCmd = RsdCommand(SQLQuery);
  RsdCmd.addParam( "Stat", RSDBP_OUT, stat );
  RsdCmd.addParam( "DealID", RSDBP_IN, DealID );
  RsdCmd.addParam( "Val", RSDBP_IN, Value );
  RsdCmd.addParam( "Balance", RSDBP_IN, Balance );
  RsdCmd.addParam( "Currency", RSDBP_IN, Currency );
  RsdCmd.execute();

  stat = int(RsdCmd.Value("Stat"));

  return stat;
END;

PRIVATE MACRO GenerateFreeAcc(DealID:integer, Balance:string, Currency:string, fillialNumb:string):integer
  if (valtype(fillialNumb) != V_STRING)
    fillialNumb = "00";
  end;
  var Value:integer = 0; 
  var Rsd ;
  var query = " SELECT nvl(max(t_value),0) " 
            + "   FROM dbusyacc_dbt b "
            + "  WHERE b.t_dealid = :DealID "
            + "    AND b.t_balance = :Balance "
            + "    AND b.t_currency = :Currency "
            + "    AND NOT EXISTS (SELECT 1 " 
            + "                      FROM daccount_dbt acc "
            + "                     WHERE acc.t_sort = b.t_balance||b.t_currency||'99'||:FilialNumb||'8'||LPAD(TO_CHAR(b.t_value), 6, '0') and acc.t_account LIKE (b.t_balance||b.t_currency||'_99'||:FilialNumb||'8'||LPAD(TO_CHAR(b.t_value), 6, '0'))) ";
  var params:TArray = makeArray( SQLParam("DealID",   DealID),
                                 SQLParam("Balance",  Balance),
                                 SQLParam("Currency", Currency),
                                 SQLParam("FilialNumb", fillialNumb)
                               ); 
           
  var rs:RsdRecordset = execSQLselect( query, params, true );
  if( rs and rs.moveNext() and (int(rs.value(0)) != 0) )
     Value = int(rs.value(0));
  else
     var stat:integer = 1;
     while( stat )
        Rsd  = RsdCommand(" begin ? := rsb_account.GetNewNumAccDeal(?,?,?,?); end; " );
        Rsd.addParam("v_result",RSDBP_OUT,V_INTEGER);
        Rsd.addParam("p_balance",RSDBP_IN,Balance);
        Rsd.addParam("p_CURRENCY",RSDBP_IN,Currency);
        Rsd.addParam("p_DealID",RSDBP_IN, DealID);
        Rsd.addParam("p_filialAddNumb",RSDBP_IN, fillialNumb);
        Rsd.execute();
        Value = int(Rsd.value("v_result"));
        stat = InsertAcc(DealID, Value, Balance, Currency);
     end;
  end;
  return Value;
END;

PRIVATE MACRO GenerateFreeAccMM(DealID:integer, Balance:string, Currency:string):integer
  var Value:integer = 0; 
  var query = " SELECT nvl(max(t_value),0) " 
            + "   FROM dbusyacc_dbt b "
            + "  WHERE b.t_dealid = :DealID "
            + "    AND b.t_balance = :Balance "
            + "    AND b.t_currency = :Currency "
            + "    AND NOT EXISTS (SELECT 1 " 
            + "                      FROM daccount_dbt acc "
            + "                     WHERE acc.t_sort = b.t_balance||b.t_currency||'9900'||LPAD(TO_CHAR(b.t_value), 7, '0') and acc.t_account LIKE (b.t_balance||b.t_currency||'_9900'||(LPAD(TO_CHAR(b.t_value), 7, '0')))) ";
  var params:TArray = makeArray( SQLParam("DealID",   DealID),
                                 SQLParam("Balance",  Balance),
                                 SQLParam("Currency", Currency)
                               ); 
           
  var rs:RsdRecordset = execSQLselect( query, params, true );
  if( rs and rs.moveNext() and (int(rs.value(0)) != 0) )
     Value = int(rs.value(0));
  else
     var stat:integer = 1;
     while( stat )
        query = " select val.t_val "
              + "   FROM (select t_val from dgenval_dbt where t_val > 0 order by t_val) val "
              + "  WHERE NOT EXISTS (SELECT 1 "
              + "                      FROM dbusyacc_dbt acc "
              + "                     WHERE val.t_val = acc.t_value  "
              + "                       AND acc.t_dealid <> :DealID "
              + "                       AND acc.t_balance = :Balance "
              + "                       AND acc.t_currency = :Currency) "
              + "        and NOT EXISTS (SELECT 1 " 
              + "                      FROM daccount_dbt acc "
              + "                     WHERE acc.t_sort = :Balance||:Currency||'9900'||LPAD(TO_CHAR(val.t_val), 7, '0')  "
              + "                       AND acc.t_account LIKE (:Balance||:Currency||'_9900'||LPAD(TO_CHAR(val.t_val), 7, '0'))) "
              + "         AND ROWNUM < 2 ";
        params = makeArray( SQLParam("DealID",   DealID),
                            SQLParam("Balance",  Balance),
                            SQLParam("Currency", Currency)                        
                          ); 
   
        rs = execSQLselect( query, params, true );
        if( rs and rs.moveNext() )
           Value = int(rs.value(0));
           stat = InsertAcc(DealID, Value, Balance, Currency);
        end;
     end;
  end;
  return Value;
END;

PRIVATE MACRO CheckAndGetUniqAccPFI1(Value:integer, Balance:string, Currency:string, OperDate:date)
  var newValue_pfi1 = Value;

  while (true)
    var que_pf1i =  " SELECT /*+ ordered index(accdoc DMCACCDOC_DBT_IDX1) */ acc.* " 
                      + "   FROM daccount_dbt acc, dmcaccdoc_dbt accdoc"
                      + "  WHERE substr(acc.t_account,1,8)||substr(acc.t_account,10) = (:Balance||:Currency||'99008'||(LPAD(:ValueAcc, 6, '0'))) "
                      + "    AND accdoc.t_account = acc.t_account "
                      + "    AND accdoc.t_chapter = acc.t_chapter "
                      + "    AND accdoc.t_catid != (SELECT cat.t_id FROM dmccateg_dbt cat WHERE cat.t_code = 'Выбытие ПФИ1') ";
    var par_pf1i:TArray = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("ValueAcc", string(newValue_pfi1))
                                  );
    var rs_pf1i = execSQLselect( que_pf1i, par_pf1i, false );
    if( rs_pf1i and rs_pf1i.moveNext() )
      newValue_pfi1 = newValue_pfi1 + 1;
      continue;
    else
      que_pf1i =  " SELECT acc.* " 
                      + "   FROM daccount_dbt acc"
                      + "  WHERE substr(acc.t_account,1,8)||substr(acc.t_account,10) =(:Balance||:Currency||'99008'||(LPAD(:ValueAcc, 6, '0'))) ";
      par_pf1i = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("ValueAcc", string(newValue_pfi1))
                                  );
      rs_pf1i = execSQLselect( que_pf1i, par_pf1i, true );
      if( rs_pf1i and rs_pf1i.moveNext() )
        if ((rs_pf1i.value("t_close_date") == date(0,0,0)) OR (rs_pf1i.value("t_close_date") > OperDate))
          break;
        else
          newValue_pfi1 = newValue_pfi1 + 1;
          continue;
        end;
      else
        break;
      end;
    end;
  end;

  return newValue_pfi1;
END;

PRIVATE MACRO InsertAccContr(ContrAgent:integer, Value:integer, Balance:string, Currency:string, BA:string, ContrCode:string, numbInFill:string):integer
  var stat = 0;
  var SQLQuery =
    "DECLARE"
   + " v_Stat INTEGER; "
   + " FUNCTION InsertACCContr(Val NUMBER, Balance VARCHAR2, Currency VARCHAR2, BA VARCHAR2, ContrCode VARCHAR2, ContrAgent NUMBER, numbInFill VARCHAR2) RETURN NUMBER"
   +  " IS"
   + " BEGIN "
   + " EXECUTE IMMEDIATE 'insert into dbusyacccontr_dbt (T_CONTRAGENT, T_VALUE, T_BALANCE, T_CURRENCY, T_BA, T_CONTRCODE, T_NUMBINFILL) Values (:ContrAgent, :Val, :Balance, :Currency, :BA, :ContrCode, :numbInFill)' " 
   + " USING IN ContrAgent, IN Val, IN Balance, IN Currency, IN BA, IN ContrCode, IN numbInFill;"
   + "   RETURN 0; "
   + " EXCEPTION "
   + " WHEN DUP_VAL_ON_INDEX THEN RETURN 0; "
   + " WHEN OTHERS THEN "
   + "   RETURN 1;"
   + " END;"
   + " BEGIN "
   + " ?:= InsertACCContr(?, ?, ?, ?, ?, ?, ?);"
   + " END; ";

  var RsdCmd = RsdCommand(SQLQuery);
  RsdCmd.addParam( "Stat", RSDBP_OUT, stat );
  RsdCmd.addParam( "Val", RSDBP_IN, Value );
  RsdCmd.addParam( "Balance", RSDBP_IN, Balance );
  RsdCmd.addParam( "Currency", RSDBP_IN, Currency );
  RsdCmd.addParam( "BA", RSDBP_IN, BA );
  RsdCmd.addParam( "ContrCode", RSDBP_IN, ContrCode );
  RsdCmd.addParam( "ContrAgent", RSDBP_IN, ContrAgent );
  RsdCmd.addParam( "numbInFill", RSDBP_IN, numbInFill );
  RsdCmd.execute();

  stat = int(RsdCmd.Value("Stat"));

  return stat;
END;

PRIVATE MACRO CheckAndGetUniqAccForward(Value:integer, Balance:string, Currency:string, ClientCode:string, Contragent:integer, numbInFill:string, OperDate:date)
  ClientCode = IIF (strlen(ClientCode) > 3, substr(ClientCode, strlen(ClientCode)-2), ClientCode);
  var cutValue:integer = IIF( strlen(string(Value)) > 3, substr(string(Value), strlen(string(Value))-2),Value); 
  var newValue_forward = cutValue;

    var que_forward =   " SELECT acc.* " 
                      + "   FROM daccount_dbt acc"
                      + "  WHERE acc.t_client != :Contragent "
                      + "    and substr(acc.t_account,1,8)||substr(acc.t_account,10) = (:Balance||:Currency||'99' || :numbInFill ||'4'|| (LPAD(:ClientCode, 3, '0'))||(LPAD(:ValueAcc, 3, '0')))  ";
    var par_forward:TArray = makeArray(SQLParam("Contragent", Contragent), 
                                    SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("numbInFill", string(numbInFill)),
                                    SQLParam("ClientCode", ClientCode),
                                    SQLParam("ValueAcc", string(newValue_forward))

                                  );
    var rs_forward = execSQLselect( que_forward, par_forward, false );
    if( rs_forward and rs_forward.moveNext() )
      var query = " SELECT nvl(max(t_value),0) " 
            + "   FROM dbusyacccontr_dbt b "
            + "  WHERE b.t_balance = :Balance "
            + "    AND b.t_currency = :Currency "
            + "    AND b.t_ba = :BA "
            + "    AND b.t_contrcode = :ContrCode "
            + "    AND b.t_contragent = :Contragent "
            + "    AND b.t_numbinfill = :numbInFill ";
      var params:TArray = makeArray(SQLParam("Balance",  Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("BA", cutValue),
                                    SQLParam("ContrCode", ClientCode),
                                    SQLParam("Contragent", Contragent),
                                    SQLParam("numbInFill", numbInFill)
                                    ); 
           
      var rs:RsdRecordset = execSQLselect( query, params, true );
      if( rs and rs.moveNext() and (int(rs.value(0)) != 0) )
        newValue_forward = int(rs.value(0));
      else
       var stat:integer = 1;
       while( stat )
          var Rsd  = RsdCommand(" begin ? := rsb_account.GetNewNumAccContrF(?,?,?,?,?); end; " );
          Rsd.addParam("v_result",RSDBP_OUT,V_INTEGER);
          Rsd.addParam("p_balance",RSDBP_IN,Balance);
          Rsd.addParam("p_CURRENCY",RSDBP_IN,Currency);
          Rsd.addParam("p_BA",RSDBP_IN, cutValue);
          Rsd.addParam("p_ContrCode",RSDBP_IN, ClientCode);
          Rsd.addParam("p_numbInFill",RSDBP_IN, numbInFill);
          Rsd.execute();
          newValue_forward = int(Rsd.value("v_result"));
          stat = InsertAccContr(Contragent, newValue_forward, Balance, Currency, cutValue, ClientCode, numbInFill);
       end;
    end;
    end;


  return newValue_forward;
  
END;

PRIVATE MACRO CheckAndGetUniqAccForwardMetal(Balance:string, Currency:string, Client, TemplNum:integer, OperDate:date)
  var ClientCode = ПолучитьКодСубъектаДляСчета( Client, PTCK_ACC );
  ClientCode = IIF (strlen(ClientCode) > 4, substr(ClientCode, strlen(ClientCode)-3), ClientCode);
  var cutValue:integer = ClientCode;
  var newValue_forward = cutValue;

  while (true)
    var que_forward =  " SELECT /*+ ordered  index(accdoc DMCACCDOC_DBT_IDX1) */ acc.* " 
                      + "   FROM daccount_dbt acc, dmcaccdoc_dbt accdoc"
                      + "  WHERE substr(acc.t_account,1,8)||substr(acc.t_account,10) = (:Balance||:Currency||'990030'||(LPAD(:TemplNum, 1, '0'))||(LPAD(:ClientCode, 4, '0'))) "
                      + "    AND accdoc.t_account = acc.t_account "
                      + "    AND accdoc.t_chapter = acc.t_chapter "
                      + "    AND acc.t_client <> :Client "
                      + "    AND accdoc.t_catid in (SELECT cat.t_id FROM dmccateg_dbt cat WHERE cat.t_code in ('+Форвард, расчетыДМ', '-Форвард, расчетыДМ')) ";
    var par_forward:TArray = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("TemplNum", string(TemplNum)),
                                    SQLParam("ClientCode", string(newValue_forward)),
                                    SQLParam("Client", Client)
                                  );
    var rs_forward = execSQLselect( que_forward, par_forward, false );
    if( rs_forward and rs_forward.moveNext() )
      newValue_forward = IIF((newValue_forward == cutValue) and (cutValue != 1), 1, newValue_forward + 1);
      continue;
    else
      que_forward =  " SELECT acc.* " 
                      + "   FROM daccount_dbt acc"
                      + "  WHERE substr(acc.t_account,1,8)||substr(acc.t_account,10) = :Balance||:Currency||'990030'||(LPAD(:TemplNum, 1, '0'))||(LPAD(:ClientCode, 4, '0')) AND acc.t_client <> :Client ";
      par_forward = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("TemplNum", string(TemplNum)),
                                    SQLParam("ClientCode", string(newValue_forward)),
                                    SQLParam("Client", Client)
                                  );
      rs_forward = execSQLselect( que_forward, par_forward, true );
      if( rs_forward and rs_forward.moveNext() )  
        newValue_forward = IIF((newValue_forward == cutValue) and (cutValue != 1), 1, newValue_forward + 1);
        continue;
      else
        break;
      end;
    end;
  end;

  return newValue_forward;
END;

PRIVATE MACRO CheckAndGetUniqAccFOther(Value:integer, Balance:string, Currency:string, OperDate:date)
  var cutValue:integer = IIF( strlen(string(Value)) > 7, substr(string(Value), strlen(string(Value))-6),Value); 
  var newValue_forward = cutValue;

  while (true)
    var que_forward =   " SELECT /*+ ordered  index(accdoc DMCACCDOC_DBT_IDX1) */ acc.* " 
                      + "   FROM daccount_dbt acc, dmcaccdoc_dbt accdoc"
                      + "  WHERE substr(acc.t_account,1,8)||substr(acc.t_account,10) = :Balance||:Currency||'9900'||(LPAD(:ValueAcc, 7, '0')) "
                      + "    AND accdoc.t_account = acc.t_account "
                      + "    AND accdoc.t_chapter = acc.t_chapter "
                      + "    AND accdoc.t_catid in (SELECT cat.t_id FROM dmccateg_dbt cat WHERE cat.t_code in ('+Форвард, прочие', '-Форвард, прочие')) ";
    var par_forward:TArray = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("ValueAcc", string(newValue_forward))
                                  );
    var rs_forward = execSQLselect( que_forward, par_forward, false );
    if( rs_forward and rs_forward.moveNext() )
      newValue_forward = IIF((newValue_forward == cutValue) and (cutValue != 1), 1, newValue_forward + 1);
      continue;
    else
      que_forward =  " SELECT acc.* " 
                      + "   FROM daccount_dbt acc"
                      + "  WHERE substr(acc.t_account,1,8)||substr(acc.t_account,10) = :Balance||:Currency||'9900'||(LPAD(:ValueAcc, 7, '0')) ";
      par_forward = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("ValueAcc", string(newValue_forward))
                                  );
      rs_forward = execSQLselect( que_forward, par_forward, true );
      if( rs_forward and rs_forward.moveNext() )
        newValue_forward = IIF((newValue_forward == cutValue) and (cutValue != 1), 1, newValue_forward + 1);
        continue;
      else
        break;
      end;
    end;
  end;

  return newValue_forward;
END;


PRIVATE MACRO CheckAndGetUniqAccFOther0(Value:string, Balance:string, Currency:string, FIID_code:string, Contragent:integer, numbInFill:string)
  FIID_code = IIF (strlen(FIID_code) > 3, substr(FIID_code, strlen(FIID_code)-2), FIID_code);
  var cutValue = IIF( strlen(string(Value)) > 4, substr(string(Value), strlen(string(Value))-3),Value); 
  var newValue_forward = cutValue;
  var NeedContinue = true;


  var que_forward =   " SELECT /*+ ordered index(accdoc DMCACCDOC_DBT_IDX1) */ accdoc.* " 
                      + "   FROM dmcaccdoc_dbt accdoc, daccount_dbt acc "
                      + " WHERE acc.t_sort =  (:Balance||:Currency||'99' || :numbInFill ||(LPAD(:FIID_code, 3, '0'))||(LPAD(:ValueAcc, 4, '0'))) "
                      + "  and acc.t_account like (:Balance||:Currency||'_99' || :numbInFill ||(LPAD(:FIID_code, 3, '0'))||(LPAD(:ValueAcc, 4, '0'))) "
                      + "  and accdoc.t_account = acc.t_account "
                      + "  and accdoc.t_chapter = acc.t_chapter "
                      + "  and accdoc.t_Contractor = -1 "
                      + "  and accdoc.t_catid in (SELECT cat.t_id FROM dmccateg_dbt cat WHERE cat.t_code in ('+Форвард, прочие0', '-Форвард, прочие0','+Форвард, прочие', '-Форвард, прочие')) ";
  var par_forward:TArray = makeArray( SQLParam("Balance", Balance),
                                    SQLParam("Currency", Currency),
                                    SQLParam("numbInFill", numbInFill),
                                    SQLParam("FIID_code", FIID_code),
                                    SQLParam("ValueAcc", string(cutValue))
                                  );
  var rs_forward = execSQLselect( que_forward, par_forward, false );

  if(rs_forward.moveNext() )
    var query = " SELECT nvl(max(t_value),0) " 
            + "   FROM dbusyacccontr_dbt b "
            + "  WHERE b.t_balance = :Balance "
            + "    AND b.t_currency = :Currency "
            + "    AND b.t_ba = :BA "
            + "    AND b.t_contrcode = :ContrCode "
            + "    AND b.t_contragent = :Contragent "
            + "    AND b.t_numbinfill = :numbInFill ";
    var params:TArray = makeArray(SQLParam("Balance",  Balance),
                                 SQLParam("Currency", Currency),
								 SQLParam("BA", FIID_code),
								 SQLParam("ContrCode", cutValue),
								 SQLParam("Contragent", Contragent),
								 SQLParam("numbInFill", numbInFill)
                               ); 
           
    var rs:RsdRecordset = execSQLselect( query, params, true );
    if( rs and rs.moveNext() and (int(rs.value(0)) != 0) )
      newValue_forward = int(rs.value(0));
    else
       var stat:integer = 1;
       while( stat )
          var Rsd  = RsdCommand(" begin ? := rsb_account.GetNewNumAccContr(?,?,?,?,?); end; " );
          Rsd.addParam("v_result",RSDBP_OUT,V_INTEGER);
          Rsd.addParam("p_balance",RSDBP_IN,Balance);
          Rsd.addParam("p_CURRENCY",RSDBP_IN,Currency);
          Rsd.addParam("p_BA",RSDBP_IN, FIID_code);
          Rsd.addParam("p_ContrCode",RSDBP_IN, cutValue);
          Rsd.addParam("p_numbInFill",RSDBP_IN, numbInFill);
          Rsd.execute();
          newValue_forward = int(Rsd.value("v_result"));
          stat = InsertAccContr(Contragent, newValue_forward, Balance, Currency, FIID_code, cutValue, numbInFill);
       end;
    end; 
  end;

  return newValue_forward;
  
END;

/* Вернуть значение (строка или число), которое вставляется в счет вместо символа маски.
   Account        - строка в которой символы шаблона заменяются на свои значения
   Symbol         - символ для замены в шаблоне
   IDElement      - что означает Symbol в счете (конст. MCSTPELM_SYMBOL_...)
   UseLeftJustify - способ выравнивания полученного значения при подстановке его в счет
                    true  - выравнивание по левому краю, false - по правому*/
PRIVATE MACRO MC_GetValueForSymbol( Account:STRING, Symbol:STRING, IDElement:INTEGER, UseLeftJustify:@BOOL, categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT )

  var fininstr, mcperiod, err, FIID, DprtCodeKind = 1, DprtPartyCode = "", 
      KindPort, KeyIndex, NumBO, PartyID, KindAcc,
      CodeReq, CodeFIBu, CodeComm, CodeDeb, CodeCred, AccKind, AccFun,
      CategIsIndividual = ( FD != NULL ), bVSPinCatAcc = false,
      queryCode,  cmdCode, rsCode,
      Value = -1;
     /*CHVA*/
      var q, rsbQuery, KindOfInstr;
      q = "select  t_fi_kind      "+ 
              "from dfininstr_dbt a             "+ 
              "where a.t_fiid = " + accdoc.rec.Currency;  
          rsbQuery = TRsbDataSet(q);
      if (rsbQuery.MoveNext())
          KindOfInstr = rsbQuery.fi_kind; 
      end;  
      /*CHVA*/     
    Var NextNum = 0, Avoir;

  /*по умолчанию при подстановке в счет значения, возвращаемого данным методом 
    используем выравнивание по правому краю:
     - значение короче, отведенного под него места в шаблоне, то добавляем к нему нули слева
     - значение длинее, отведенного под него места в шаблоне, то лишние символы слева отрезаем */
  UseLeftJustify = false; 

  if( IDElement   == MCSTPELM_SYMBOL_В ) /*Код валюты л/с;*/                                                        
     if( accdoc.rec.Currency >= 0 )  
 
        if (StrUpr(GenClassName(FD)) == "DVFIRSTDOCNDEAL")
            if( (FD.deal.rec.kind == 2715) and (KindOfInstr ==6) and (accdoc.rec.chapter == 1) and (SubStr(Account, 1, 3) == "474")  ) /*CHVA если сделка с драгметаллом, то в код счета вместо ВВВ становится код контрактива (не металла) SVE только для внебалансовых счетов*/
                Value = ПолучитьКодФинИнДляСчета( accdoc.rec.fiid ); 
            else
        	Value = ПолучитьКодФинИнДляСчета( accdoc.rec.Currency );
            end;    
        else
            Value = ПолучитьКодФинИнДляСчета( accdoc.rec.Currency );
        end;
     end;

  elif( IDElement == MCSTPELM_SYMBOL_Э ) /*Код эмитента (код вида "Код для л/с" эмитента)*/                         

     PartyID = accdoc.rec.Issuer;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr( MC_TYPE_PARAMETR_ISSUER, NULL, NULL, accdoc.rec.FiRole );
     end;

     if( PartyID != -1 )
        if(PartyID != 0)
        Value = ПолучитьКодСубъектаДляСчета( PartyID );
//        else
//           Value = 0;
        end;
     else
        SayError( Categ, "У счета не определено значение характеристики \"Эмитент\"");
     end;

  elif( IDElement == MCSTPELM_SYMBOL_Б ) /*Балансовый счет*/                                                        
     UseLeftJustify = true; /*выравнивание по левому краю*/
     Value = MC_GetBalance( accdoc, templ, FD );      

  elif( IDElement == MCSTPELM_SYMBOL_А ) /*Код для л/с (вида "Код для л/с") векселедателя или акцептанта*/          
     Value = accdoc.rec.Issuer;      

  elif( IDElement == MCSTPELM_SYMBOL_Р ) /*Код расчетного центра ОРЦБ (код вида "Код РЦ ОРЦБ")*/                    

     PartyID = accdoc.rec.MarketPlaceID;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_MARKET_PLACE, NULL, NULL, accdoc.rec.FiRole);
     end;

     Value = ПолучитьКодСубъекта(PartyID, PTCK_ACC, err);
     if( err != 0 )
        SayError(Categ, "Не найден код в номере лицевого счета субъекта " + ПолучитьКодСубъекта(PartyID, PTCK_CONTR, err));
     end; 

  elif( IDElement == MCSTPELM_SYMBOL_Г ) /*Код гарантийного обеспечения)*/                                          
     Value = 0;      

  elif( IDElement == MCSTPELM_SYMBOL_С ) /*Код сектора торговой площадки*/                                          
     Value = accdoc.rec.MarketPlaceOfficeID;

     if( (Value <= 0) AND CategIsIndividual) /*Пробуем вытащить из документа*/
        Value = FD.GetParametr( MC_TYPE_PARAMETR_MARKET_PLACE_OFFICE, NULL, NULL, accdoc.rec.FiRole);
        if( Value < /* поменял <= на < по запросу 153139  */ 0 ) /*не задан сектор*/
           if( FD.GetParametr( MC_TYPE_PARAMETR_MARKET_PLACE, NULL, NULL, accdoc.rec.FiRole) > 0 )
              Value = 1; /*задана ТП*/
           else
              Value = 0;
           end;
        end;
     end; 

  elif( IDElement == MCSTPELM_SYMBOL_Ф ) /*Номер филиала*/                                                          
  /*
     GetRegistryValue( DPRT_CODE_KIND, V_INTEGER, DprtCodeKind, err );
     if( err != 0 )
        SayError( Categ, "Ошибка при получении значения настройки \"" + DPRT_CODE_KIND + "\"");
     end;

     GetRegistryValue( VSP_IN_CATACC, V_BOOL, bVSPinCatAcc, err );
     if( err != 0 )
        SayError( Categ, "Ошибка при получении значения настройки \"" + VSP_IN_CATACC + "\"");
     end;

     if( bVSPinCatAcc == false )
       err = CB_GetDprtPartyCode( accdoc.rec.DepartmentID, DprtCodeKind, DprtPartyCode );
       if( err != 0 )
          CB_GetDepartmentCodeAndName( accdoc.rec.DepartmentID, DprtPartyCode );
          SayError( Categ, "Не найден код вида " + DprtCodeKind + " для субъекта, ассоциированного с филиалом " + DprtPartyCode ); 
       end;
     else
       err = CB_GetDprtPartyCode( accdoc.rec.Branch, DprtCodeKind, DprtPartyCode );
       if( err != 0 )
          CB_GetDepartmentCodeAndName( accdoc.rec.Branch, DprtPartyCode );
          SayError( Categ, "Не найден код вида " + DprtCodeKind + " для субъекта, ассоциированного с ВСП " + DprtPartyCode ); 
       end;
     end;
*/
     if(categ.rec.code == "Счет МФР для возврата")
       Value = "0000";
     else
       Value = "9900";
     end;

  elif( IDElement == MCSTPELM_SYMBOL_FK ) /*Номер филиала-корреспондента*/                                                          
     if((FD != NULL) AND (FD.nptxop != NULL) AND (FD.nptxop.rec.DocKind == DL_HOLDNDFL) AND (FD.nptxop.rec.SubKind_Operation == DL_TXHOLD_OPTYPE_TAXREF) )
        queryCode = " select substr(dep.t_Name, 1 ,4) Code " +
                        " from dsettacc_dbt settacc, ddp_dep_dbt dep " +
                        " where dep.t_partyId = settacc.t_BankID "+
                        "  and settacc.t_Account = ? ";
        cmdCode = RSDCommand(queryCode);
        cmdCode.AddParam("", RSDBP_IN, FD.nptxop.rec.Account);

        rsCode = TRsbDataSet(cmdCode);
        if(rsCode.MoveNext())
          Value = rsCode.Code;
        end;
     elif((accdoc != NULL) AND (categ.rec.code == "Счет МФР для возврата"))
        queryCode = " select substr(dep.t_Name, 1 ,4) Code " +
                        " from  ddp_dep_dbt dep " +
                        " where dep.t_partyId = ? ";
        cmdCode = RSDCommand(queryCode);
        cmdCode.AddParam("", RSDBP_IN, accdoc.rec.Contractor);
        rsCode = TRsbDataSet(cmdCode);
        if(rsCode.MoveNext())
          Value = rsCode.Code;
        end;
     else
        GetRegistryValue( DPRT_CODE_KIND, V_INTEGER, DprtCodeKind, err );
        if( err != 0 )
           SayError( Categ, "Ошибка при получении значения настройки \"" + DPRT_CODE_KIND + "\"");
        end;
     
        err = CB_GetDprtPartyCode( accdoc.rec.CorrDepartmentID, DprtCodeKind, DprtPartyCode );
        if( err != 0 )
           CB_GetDepartmentCodeAndName( accdoc.rec.CorrDepartmentID, DprtPartyCode );
           SayError( Categ, "Не найден код вида " + DprtCodeKind + " для субъекта, ассоциированного с филиалом " + DprtPartyCode ); 
        end;
     
        Value = DprtPartyCode;
     end;

  elif( IDElement == MCSTPELM_SYMBOL_К ) /*Защитный ключ*/                                                          
     MC_NEED_GETKEY = true;
     KeyIndex = Index( Account, Symbol );
     if( KeyIndex != GetKeyPosition() )
        SayError( Categ, "Позиция ключа в шаблоне не соответствует значению для банка");
     elif( Index(SubStr(Account, KeyIndex + 1), Symbol) > 0 )
        SayError( Categ, "В шаблоне несколько позиций для ключа (символ \"" + Symbol + "\")" );
     end;

  elif( IDElement == MCSTPELM_SYMBOL_Л ) /*Код срочности*/                                                         
     mcperiod = TBFile( "mcperiod.dbt", "R" );
     mcperiod.Clear();
     mcperiod.rec.ID = accdoc.rec.PeriodID;
     if( mcperiod.GetEQ() )
        Value = mcperiod.rec.PeriodCode;
     end;

  elif( IDElement == MCSTPELM_SYMBOL_V ) /*Код финансового иструмента*/                                      

     fininstr = TRecHandler("fininstr.dbt");

     FIID = accdoc.rec.FIID;
     //из-за неправильного заполенения fiid используем так для фиссико
     if ((accdoc.rec.dockind == 199) or (accdoc.rec.dockind == 4813) or (accdoc.rec.dockind == 4815) or (accdoc.rec.dockind == 4811))
       if (accdoc.rec.FIID != accdoc.rec.CURRENCY)
        FIID = accdoc.rec.CURRENCY;
       end;
/*KD*/
       If(FD.ВидБазовогоАктива() == FIKIND_AVOIRISS)
          FIID = accdoc.rec.FIID;
       end;
     end;
      // Переопределим для реализации
     If(categ.rec.code == "Реализация, ц/б")
         FIID = accdoc.rec.FIID;
     end;
     if( (FIID == -1) AND CategIsIndividual )
        FIID = FD.GetParametr(MC_TYPE_PARAMETR_FIID, NULL, NULL, accdoc.rec.FiRole); 
     end; 

     var IsForwardOther = false;
     if ((categ.rec.code == "+Форвард, прочие0") OR (categ.rec.code == "-Форвард, прочие0")
       OR (categ.rec.code == "+Форвард, прочие") OR (categ.rec.code == "-Форвард, прочие"))
        FIID = FD.GetParametr(MC_TYPE_PARAMETR_FIID, NULL, NULL, FIROLE_BA); 
        IsForwardOther = true; 
     end;

     if( (FIID >= 0) AND (ПолучитьФинИн( FIID, fininstr ) == 0) )
        /*код регистрации ценной бумаги*/ 
        if((fininstr.rec.FI_Kind == FIKIND_METAL) and IsForwardOther)
          Value = fininstr.rec.ISO_Number;
        elif( fininstr.rec.CodeInAccount != "")
           Value = fininstr.rec.CodeInAccount;
        else
           Value = fininstr.rec.FI_Code;
        end;
     end;
	 
     if (((categ.rec.code == "+Форвард, расчеты") OR (categ.rec.code == "-Форвард, расчеты")) and (accdoc.rec.templnum == 1))
       Value = CheckAndGetUniqAccForward( Value, 
                                  string(MC_GetBalance( accdoc, templ, FD )), 
                                  string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency )), 
                                  ПолучитьКодСубъектаДляСчета( MC_GetClient( accdoc, templ, categ, FD ), PTCK_ACC ),
                                  accdoc.rec.Contractor,
                                  "00", 
                                  accdoc.rec.ActionDate);
     end;
  
	 if (StrUpr(GenClassName(FD)) == "DVFIRSTDOCDEAL")
		 if ((categ.rec.code == "Выбытие ПФИ1") AND CategIsIndividual)
			Value = CheckAndGetUniqAccPFI1(Value, string(MC_GetBalance( accdoc, templ, FD )), string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency )), accdoc.rec.ActionDate);
		 end;
	 end;
  elif(( IDElement == MCSTPELM_SYMBOL_U ) or ( IDElement == MCSTPELM_SYMBOL_GENAGRFISSIKO )) /*Код для л/с (вида "Код для л/с") клиента по счету*/      
      if (((categ.rec.code == "+Форвард, расчетыДМ") OR (categ.rec.code == "-Форвард, расчетыДМ")))
       Value = CheckAndGetUniqAccForwardMetal( string(MC_GetBalance( accdoc, templ, FD )), 
                                  string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency )), 
                                  MC_GetClient( accdoc, templ, categ, FD ), 
                                  templ.rec.number,
                                  accdoc.rec.ActionDate);
     else
         Value = ПолучитьКодСубъектаДляСчета( MC_GetClient( accdoc, templ, categ, FD ), PTCK_ACC );
     end;

  elif( IDElement == MCSTPELM_SYMBOL_S ) /*Код клиента в БО ценных бумаг (22)*/                                    
     Value = ПолучитьКодСубъектаДляСчета( MC_GetClient( accdoc, templ, categ, FD ), PTCK_INDEPO );

  elif( IDElement == MCSTPELM_SYMBOL_У ) /*Код л/с доходов/расходов*/                                              
     Value = 0;      

  elif ( IDElement == MCSTPELM_SYMBOL_1007 )
   Value = Nkl(FD.tick.rec.bofficekind);
  elif( IDElement == MCSTPELM_SYMBOL_Н ) /*Номер договора/сделки (номер документа)*/                               
  /*
     if( CategIsIndividual )
        Value = FD.GetParametr( MC_TYPE_PARAMETR_NUMBER, NULL, NULL, accdoc.rec.FiRole );
        if( Value == -1 )
           Value = string( FD.ID );
        end;
     end;
*/
     if (FD.kind  == 102) 
         var MMDealID:integer = 0;    
         MMDealID = FD.tick.rec.dealid;
         Value = MMDealID;
         if( (categ.rec.code == "ОД") or
            (categ.rec.code == "-% к погашению") or
            (categ.rec.code == "+% к погашению") or
            (categ.rec.code == "ОДТФ")  or
            (categ.rec.code == "Р, ссуды")  )
            var PREV_MC_NEED_GETKEY = MC_NEED_GETKEY;
            var MMBalance:string = string(MC_GetBalance( accdoc, templ, FD ));
            MC_NEED_GETKEY = PREV_MC_NEED_GETKEY;
            if( (categ.rec.code == "ОД") )
               mcperiod = TBFile( "mcperiod.dbt", "R" );
               mcperiod.Clear();
               mcperiod.rec.ID = accdoc.rec.PeriodID;
               if( mcperiod.GetEQ() )
                  MMBalance = substr(MMBalance, 1, 3) + string(mcperiod.rec.PeriodCode);
               end;
            end;
            var MMCurrency:string = "";      
            if( accdoc.rec.Currency >= 0 )   
               MMCurrency = string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency ));
            end;
            var MMStrValue:string = string(Value);
            if(strlen(MMStrValue) > 7)
               MMStrValue = substr(MMStrValue, strlen(MMStrValue)-6, 7);
            end;
            var query1 = " SELECT 1 " 
                     + "   FROM daccount_dbt "
                     + "  WHERE t_sort = :Balance||:Currency||'9900'||LPAD(:ValueAcc, 7, '0') and t_account LIKE (:Balance||:Currency||'_9900'||(LPAD(:ValueAcc, 7, '0'))) ";
            var params1:TArray = makeArray( SQLParam("Balance", MMBalance),
                                          SQLParam("Currency", MMCurrency),
                                          SQLParam("ValueAcc", MMStrValue)
                                          ); 
            var rs1:RsdRecordset = execSQLselect( query1, params1, true );
            if( rs1 and rs1.moveNext() )
               Value = GenerateFreeAccMM(MMDealID, MMBalance, MMCurrency); 
            end;
         end;
     elif (FD.kind  == 101)
        Value = string(FD.tick.rec.dealid);
       /* if (((categ.rec.code == "+Форвард, прочие") OR (categ.rec.code == "-Форвард, прочие")) and ((accdoc.rec.templnum >= 1) and (accdoc.rec.templnum <= 6)))
          Value = CheckAndGetUniqAccFOther( FD.tick.rec.dealid, 
                                  string(MC_GetBalance( accdoc, templ, FD )), 
                                  string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency )),
                                  accdoc.rec.ActionDate);  
          else
          Value = string(FD.tick.rec.dealid);
        end;   */
     elif (FD.kind  == 143)
        Value = string(FD.ID);
     elif ((FD.kind == 4813) or  (FD.kind == 4815))
        Value = string(FD.id);
     elif (StrUpr(GenClassName(FD)) == "DVFIRSTDOCNDEAL")/*CHVA*/
     
       if ((categ.rec.code == "-Корр,Хедж_ДП") OR (categ.rec.code == "+Корр,Хедж_ДП"))
         Value = string(FD.Deal.rec.ID);
       else
         Value = SubStr (FD.Deal.rec.code,index (FD.Deal.rec.code, ":")+1);
       end;

     elif (FD.kind  == 176) 
         If(IsREPO(GetOpGroup(FD.tick.rec)))
            Value = ReadNoteForObject(OBJTYPE_SECDEAL, UniID(FD.tick,OBJTYPE_SECDEAL), 205);
         end;

     else
        Value = FD.GetParametr( MC_TYPE_PARAMETR_NUMBER, NULL, NULL, accdoc.rec.FiRole );
        if( Value == -1 )
           Value = string( FD.ID );
        end;
     end;


  elif( IDElement == MCSTPELM_SYMBOL_Д ) /*Код договора обслуживания клиента*/                                     
     PartyID = accdoc.rec.ClientContrID;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_CLIENT, NULL, NULL, accdoc.rec.FIRole);
     end;
     Value = MC_GetContrNumber( PartyID );

  elif( IDElement == MCSTPELM_SYMBOL_D ) /*Код договора обслуживания банка*/                                       
     PartyID = accdoc.rec.BankContrID;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_BANK, NULL, NULL, accdoc.rec.FIRole);
     end;
     Value = MC_GetContrNumber( PartyID );

  elif( IDElement == MCSTPELM_SYMBOL_О ) /*Код для л/с (вида "Код для л/с") для владельца*/                        
     PartyID = accdoc.rec.Owner;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_OWNER, NULL, NULL, accdoc.rec.FIRole);
     end;
     Value = ПолучитьКодСубъектаДляСчета( PartyID );

  elif( IDElement == MCSTPELM_SYMBOL_М ) /*Код для л/с (вида "Код для л/с") для места хранения*/                   
     PartyID = accdoc.rec.Place;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_PLACE, NULL, NULL, accdoc.rec.FIRole, accdoc.rec.Currency);
     elif ((StrUpr(GenClassName(FD)) == "DVFIRSTDOCDEAL") and (PartyID == 2)) //TEG 15.06.19 
         PartyID = 4; //TEG если ММВБ, то сменим на НРД                          
     end;
     Value = ПолучитьКодСубъектаДляСчета(PartyID);

  elif( IDElement == MCSTPELM_SYMBOL_W ) /*Номер вышестоящего документа данного первичного документа*/             
     if( CategIsIndividual )
        Value = fd.GetParametr(MC_TYPE_PARAMETR_SENIORNUMBER, NULL, NULL, accdoc.rec.FIRole);
     end;
  elif( IDElement == MCSTPELM_SYMBOL_F ) /*Код бэк-офиса*/                                                         
     NumBO = GetValueFromTempl(categ, templ, LLCLASS_BACKOFFICE);
     if( (NumBO == -1) AND CategIsIndividual )
       NumBO = FD.GetParametrTemplate( OBJTYPE_BACKOFFICE, LLCLASS_BACKOFFICE );
     end;
     Value = MC_GetValueFlag( OBJTYPE_BACKOFFICE, NumBO );
/*КД*/
     // Переопределим для реализации
     If(categ.rec.code == "Реализация, ц/б")
         Value = "5";
     end;
  elif( IDElement == MCSTPELM_SYMBOL_Е ) /*Код для л/с (вида "Код для л/с") (центра ответственности для субъекта*/ 
     PartyID = accdoc.rec.Centr;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CENTR, NULL, NULL, accdoc.rec.FIRole);
     end;
     Value = ПолучитьКодСубъектаДляСчета( PartyID );

  elif( IDElement == MCSTPELM_SYMBOL_Х ) /*Код портфеля*/                                                          

     Value = GetValueFromTempl( categ, templ, LLCLASS_KINDPORT );
     if( (Value == -1) AND CategIsIndividual )
        Value = FD.GetParametrTemplate( OBJTYPE_KINDPORT, LLCLASS_KINDPORT, accdoc.rec.ActionDate, accdoc.rec.FIRole );
     end;

  elif( IDElement == MCSTPELM_SYMBOL_Q ) /*День месяца даты картотеки*/                                            
     DateSplit( MC_ConvertIndexDateToDate(categ, accdoc.rec.IndexDate), Value, null, null);

  elif( IDElement == MCSTPELM_SYMBOL_G ) /*Номер месяца даты картотеки*/                                           
     DateSplit( MC_ConvertIndexDateToDate(categ, accdoc.rec.IndexDate), null, Value, null );

  elif( IDElement == MCSTPELM_SYMBOL_Т ) /*Год даты картотеки*/                                                    
     DateSplit( MC_ConvertIndexDateToDate(categ, accdoc.rec.IndexDate), null, null, Value);

  elif( IDElement == MCSTPELM_SYMBOL_Z ) /*Уникальный порядковый номер счета*/                                     
     Value = CreateStringZ( categ, Symbol, Account, accdoc );

  elif( IDElement == MCSTPELM_SYMBOL_R ) /*Код для л/с (вида "Код для л/с") для контрагента*/                      
     PartyID = accdoc.rec.Contractor;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTRACTOR, NULL, NULL, accdoc.rec.FIRole);
     end;
     Value = ПолучитьКодСубъектаДляСчета( PartyID );
  
     if ((categ.rec.code == "+Форвард, прочие0") OR (categ.rec.code == "-Форвард, прочие0") OR 
         (categ.rec.code == "+Форвард, прочие") OR (categ.rec.code == "-Форвард, прочие"))
       var FIID_code = "";
       var numbInFill = "01";
       if((categ.rec.code == "+Форвард, прочие") OR (categ.rec.code == "-Форвард, прочие"))
         numbInFill = "02";
       end;
       fininstr = TRecHandler("fininstr.dbt");
       FIID = FD.GetParametr(MC_TYPE_PARAMETR_FIID, NULL, NULL, FIROLE_BA); 	 

       if( (FIID >= 0) AND (ПолучитьФинИн( FIID, fininstr ) == 0) )
         /*код регистрации ценной бумаги*/ 
         if(fininstr.rec.FI_Kind == FIKIND_METAL)
           FIID_code = fininstr.rec.ISO_Number;
         elif( fininstr.rec.CodeInAccount != "")
           FIID_code = fininstr.rec.CodeInAccount;
         else
           FIID_code = fininstr.rec.FI_Code;
         end;
       end;

       Value = CheckAndGetUniqAccFOther0( Value, 
                                  string(MC_GetBalance( accdoc, templ, FD )), 
                                  string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency )), 
                                  FIID_code, 
                                  PartyID,
                                  numbInFill);
     end;
  elif( IDElement == MCSTPELM_SYMBOL_I ) /*Код анкеты векселя*/                                                    
     if( CategIsIndividual )
        Value = fd.GetParametr( MC_TYPE_PARAMETR_VEKSELCODE, NULL, NULL, accdoc.rec.FIRole );
     end;
  elif( IDElement == MCSTPELM_SYMBOL_Ц ) /*Код вида договора ДУ*/
     Value = TSOrder_GetKindCodeInAccount( accdoc );
  elif( IDElement == MCSTPELM_SYMBOL_И ) /*Код договора ДУ (ИДДУ, ДП ОФБУ, ОУ ОФБУ) в номере л/счета*/
     Value = TSOrder_GetNumber_InAccount( accdoc );
 
  elif( IDElement == MCSTPELM_SYMBOL_Ю ) /*Код ближайшего узла ТС, в котором есть хранилище ценностей*/
      Value   = GetCodeTSStorage( accdoc.rec.Place );

  elif( IDElement == MCSTPELM_SYMBOL_N ) /*Код производного инструмента*/
      Value   = GetCodeDVKind( accdoc.rec.FIID );

  elif( IDElement == MCSTPELM_SYMBOL_Ъ ) /*Назначение счета (код из соотв. параметра)*/
     KindAcc = GetValueFromTempl( categ, templ, LLCLASS_KIND_ACC_PDD );
     if( (KindAcc == -1) AND CategIsIndividual )
        KindAcc = FD.GetParametrTemplate( OBJTYPE_KIND_ACCOUNT_SECUR, LLCLASS_KIND_ACC_PDD, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_KIND_ACCOUNT_SECUR, KindAcc ); 

  elif( IDElement == MCSTPELM_SYMBOL_CODE_KA ) /*Код контрагента для срочных контрактов*/
     PartyID = accdoc.rec.Contractor;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTRACTOR, NULL, NULL, accdoc.rec.FIRole);
     end;
     Value = ПолучитьКодСубъектаДляСчета( PartyID, PTCK_CONTRACT );
  elif( IDElement == MCSTPELM_SYMBOL_CODE_REQ )
     CodeReq = GetValueFromTempl( categ, templ, LLCLASS_TSREQKIND );
     if( (CodeReq == -1) AND (FD != NULL) )
        CodeReq = FD.GetParametrTemplate( OBJTYPE_TSREQKIND, LLCLASS_TSREQKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSREQKIND, CodeReq ); 
  elif( IDElement == MCSTPELM_SYMBOL_FI_BUH )
     CodeFIBu = GetValueFromTempl( categ, templ, LLCLASS_TSFIKIND );
     if( (CodeFIBu == -1) AND (FD != NULL) )
        CodeFIBu = FD.GetParametrTemplate( OBJTYPE_TSFIKIND, LLCLASS_TSFIKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSFIKIND, CodeFIBu );
  elif( IDElement == MCSTPELM_SYMBOL_Ч ) 
     CodeComm = GetValueFromTempl( categ, templ, LLCLASS_TSCOMMKIND );
     if( (CodeComm == -1) AND (FD != NULL) )
        CodeComm = FD.GetParametrTemplate( OBJTYPE_TSCOMMKIND, LLCLASS_TSCOMMKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSCOMMKIND, CodeComm );
  elif( IDElement == MCSTPELM_SYMBOL_CODE_DEB )
     CodeDeb = GetValueFromTempl( categ, templ, LLCLASS_TSDEBKIND );
     if( (CodeDeb == -1) AND (FD != NULL) )
        CodeDeb = FD.GetParametrTemplate( OBJTYPE_TSDEBKIND, LLCLASS_TSDEBKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSDEBKIND, CodeDeb );
  elif( IDElement == MCSTPELM_SYMBOL_CODE_CRED )
     CodeCred = GetValueFromTempl( categ, templ, LLCLASS_TSCREDKIND );
     if( (CodeCred == -1) AND (FD != NULL) )
        CodeCred = FD.GetParametrTemplate( OBJTYPE_TSCREDKIND, LLCLASS_TSCREDKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSCREDKIND, CodeCred );
  elif( IDElement == MCSTPELM_SYMBOL_ACCKIND )
     AccKind = GetValueFromTempl( categ, templ, LLCLASS_TSACCKIND );
     if( (AccKind == -1) AND (FD != NULL) )
        AccKind = FD.GetParametrTemplate( OBJTYPE_TSACCKIND, LLCLASS_TSACCKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSACCKIND, AccKind );
  elif( IDElement == MCSTPELM_SYMBOL_ACCFUN )
     AccFun = GetValueFromTempl( categ, templ, LLCLASS_TSACCOWNKIND );
     if( (AccFun == -1) AND (FD != NULL) )
        AccFun = FD.GetParametrTemplate( OBJTYPE_TSACCOWNKIND, LLCLASS_TSACCOWNKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSACCOWNKIND, AccFun );
  elif( IDElement == MCSTPELM_SYMBOL_L ) /*Уникальный порядковый номер счета*/                                     
     If(accdoc.rec.Catid == 818)
        Value = CreateStringL818( FD, account, FD.GetSubContr.rec.acccode );
     else
     Value = CreateStringL( accdoc.rec.Contractor, accdoc.rec.CatID );
     end;
  elif( IDElement == MCSTPELM_SYMBOL_GENAGR ) /*Номер генерального соглашения*/
     Value = FD.GetGenAgrCodeInAccount();
  elif( IDElement == MCSTPELM_SYMBOL_FIROLE ) /*Роль ФИ*/
     Value = string(accdoc.rec.FIRole);
  elif( IDElement == MCSTPELM_SYMBOL_IDSTORAGE ) /*ID места хранения*/
     Value = FD.GetParametr(MC_TYPE_PARAMETR_PLACESTORAGE, NULL, NULL, accdoc.rec.FIRole);
  elif( IDElement == MCSTPELM_SYMBOL_ACCTYPE ) /*Тип счета*/
     Value = FD.GetParametr(MC_TYPE_PARAMETR_ACCTYPE, NULL, NULL, accdoc.rec.FIRole);
  elif( IDElement == MCSTPELM_SYMBOL_AVRHDINSTR )
     Value = GetNextNumberAvrHdInstr(accdoc);
  elif( IDElement == MCSTPELM_SYMBOL_HEDGETYPER )
     Value = FD.GetParametrTemplate( OBJTYPE_HEDGETYPER, LLCLASS_KIND_HEDGE_REL, accdoc.rec.ActionDate);
  elif( IDElement == MCSTPELM_SYMBOL_COUP_NUM ) /*Номер купона*/
     Value = FD.GetParametr(MC_TYPE_PARAMETR_COUP_NUM, NULL, categ.rec.Code, accdoc.rec.FIRole);
  elif( IDElement == MCSTPELM_SYMBOL_Я) /*ID сделки для внебиржи ПФИ (ddvndeal_dbt)*/                                     
    var DealID:integer = 0;                                    
    if (StrUpr(GenClassName(FD)) == "DVFIRSTDOCPMGR")                                    
       DealID = FD.DealFd.deal.rec.ID;
    else
       DealID = FD.ID;
    end;
    Value = DealID;
    var partOfFilialNumb = GetPartOfAccountByPosOnlyNumb(Account, 12, 2, "00");
    if( (categ.rec.code == "+Форвард, прочие0") or
        (categ.rec.code == "-Форвард, прочие0") or
        (categ.rec.code == "+Форвард, дрейф внебирж") or
        (categ.rec.code == "-Форвард, дрейф внебирж") or
        (categ.rec.code == "Выбытие ПФИ") )
       NumBO = GetValueFromTempl(categ, templ, LLCLASS_BACKOFFICE);
       if( (NumBO == -1) AND CategIsIndividual )
          NumBO = FD.GetParametrTemplate( OBJTYPE_BACKOFFICE, LLCLASS_BACKOFFICE );
       end;
       if( MC_GetValueFlag( OBJTYPE_BACKOFFICE, NumBO ) == 8 )
          var Balance:string = string(MC_GetBalance( accdoc, templ, FD ));
          if( (categ.rec.code == "+Форвард, дрейф внебирж") or (categ.rec.code == "-Форвард, дрейф внебирж") )
             mcperiod = TBFile( "mcperiod.dbt", "R" );
             mcperiod.Clear();
             mcperiod.rec.ID = accdoc.rec.PeriodID;
             if( mcperiod.GetEQ() )
                Balance = substr(Balance, 1, 3) + string(mcperiod.rec.PeriodCode);
             end;
          end;
          var Currency:string = "";      
          if( accdoc.rec.Currency >= 0 )   
             Currency = string(ПолучитьКодФинИнДляСчета( accdoc.rec.Currency ));
          end;
          var StrValue:string = string(Value);
          if(strlen(StrValue) > 6)
             StrValue = substr(StrValue, strlen(StrValue)-5, 6);
          end;
          var query = " SELECT 1 " 
                    + "   FROM daccount_dbt "
                    + "  WHERE t_sort = :Balance||:Currency||'99'||:FilialNumb||'8'||LPAD(:ValueAcc, 6, '0') and t_account LIKE (:Balance||:Currency||'_99'||:FilialNumb||'8'||LPAD(:ValueAcc, 6, '0')) ";
          var params:TArray = makeArray( SQLParam("Balance",  Balance),
                                         SQLParam("Currency", Currency),
                                         SQLParam("FilialNumb", partOfFilialNumb),
                                         SQLParam("ValueAcc", StrValue)
                                       ); 
        
          var rs:RsdRecordset = execSQLselect( query, params, true );
          if( rs and rs.moveNext() )
             Value = GenerateFreeAcc(DealID, Balance, Currency, partOfFilialNumb); 
          end;
       end;
    end;    
  elif( IDElement == MCSTPELM_SYMBOL_Щ) /* в зависимости от того какой клас первичка, для всех не описанных алгоритм поиска по F*/ 
    if ((StrUpr(GenClassName(FD)) == "DVFIRSTDOCNDEAL") or (StrUpr(GenClassName(FD)) == "DVFIRSTDOCPMGR"))
       Value = 3;
    elif (StrUpr(GenClassName(FD)) =="DVFIRSTDOCDEAL")
       Value = 4; 
    else 
       //иначе пока по бэкофису ( IDElement == MCSTPELM_SYMBOL_F ) /*Код бэк-офиса*/                                                         
       NumBO = GetValueFromTempl(categ, templ, LLCLASS_BACKOFFICE);
       if( (NumBO == -1) AND CategIsIndividual )
         NumBO = FD.GetParametrTemplate( OBJTYPE_BACKOFFICE, LLCLASS_BACKOFFICE );
       end;
       Value = MC_GetValueFlag( OBJTYPE_BACKOFFICE, NumBO );
    end;
  elif( IDElement == MCSTPELM_SYMBOL_Ж) /*Номер для счетов доходов/расходов от переоценки по таблице DNN706_DBT*/ 
     Value = 0;
     if ( (categ.rec.code == "+МаржаП, ц/б") or
          (categ.rec.code == "-МаржаП, ц/б") )
        Value = GetFiNumberMarginP( accdoc.rec.fiid, substr(account, 14,5) );
     end;    
  elif( IDElement == MCSTPELM_SYMBOL_PSVOP) /*Номер платежа в сделке Проц.СВОП*/ /*PNV*/
     Value = 0;
     Value = GetFiNumberPSVOP( FD.dealFD.deal.rec.id, FD.id);
/*KD*/

  elif( IDElement == MCSTPELM_SYMBOL_З) /*Поряжковый номер сделки Корзины Репо*/ 
    Value = ReadNoteForObject(OBJTYPE_SECDEAL, UniID(FD.tick,OBJTYPE_SECDEAL), 204);

  elif( IDElement == MCSTPELM_SYMBOL_Ь) /*Поряжковый номер выпуска для сделок Корзины Репо*/ 
    Value = 0;

     fininstr = TRecHandler("fininstr.dbt");
     Avoir = TRecHandler("Avoiriss.dbt");

     FIID = accdoc.rec.FIID;
     if( (FIID == -1) AND CategIsIndividual )
        FIID = FD.GetParametr(MC_TYPE_PARAMETR_FIID, NULL, NULL, accdoc.rec.FiRole); 
     end;  

     if( (FIID >= 0) AND (ПолучитьФинИн( FIID, fininstr, Avoir ) == 0) )
         Value = ReadNoteForObject(OBJTYPE_AVOIRISS, UniID(avoir,OBJTYPE_AVOIRISS), 106);
         If(Value == 0)
            NextNum = 0;
            GenerateReference(1000010, NextNum);
            AddNoteForObject(OBJTYPE_AVOIRISS, UniID(avoir,OBJTYPE_AVOIRISS), 106, int(NextNum));
            Value = NextNum;
         end;
     end;
  elif (IDElement == MCSTPELM_SYMBOL_SFCONTRMARKET)
    PartyID = accdoc.rec.ClientContrID;
    if( (PartyID == -1) AND CategIsIndividual )
       PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_CLIENT, NULL, NULL, accdoc.rec.FIRole);
    end;
    Value = MC_GetSybmValByCatAndSfcontr(categ.rec.code, PartyID );
  else
     SayError( Categ, "Элемент шаблона счета с номером " + string(IDElement) + " не обрабатывается в макрофункции генерации номера счета.|Вместо данного символа в счет подставится '0'.", true  );
  end;

  return Value;
end;

/* Формирование номера счета по маске. Заменяет подстановочные символы на маску из шаблона 
   Symbol    - символ для замены в маске шаблона 
   IDElement - значение данного символа
   Account   - строка в которой заменяются символы
   Mask      - шаблон для подстановки*/
PRIVATE MACRO ChangeStrForSymb( categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT, Symbol:STRING, IDElement:INTEGER, Account:STRING, Mask:STRING )
  
   var Number, LeftJustify, i, j, StrNumber,
       SymbLen      = 0, 
       TemplMaskLen = strlen(Mask);

   /*определить количество символов для замены в шаблоне*/
   i = 1; 
   while( i <= TemplMaskLen )
      if( SubStr(Mask, i, 1) == Symbol )
         SymbLen = SymbLen + 1; 
      end;
      i = i + 1;
   end;

   if( SymbLen != 0 ) /*есть что менять*/
      Number = MC_GetValueForSymbol( Account, Symbol, IDElement, @LeftJustify, categ, accdoc, templ, FD );

      if( (valtype(Number) == V_INTEGER) AND (Int(Number) < 0) )
         Number = "";
      end; 

      StrNumber = LZ_acc( string(Number), SymbLen, LeftJustify );
      i = TemplMaskLen;
      j = SymbLen;
      while( (i > 0) AND (j > 0) )
         if( SubStr(Account, i, 1) == Symbol )
            /*когда i-1 == 0, SubStr вернет "", можно не проверять отдельно */
            Account = SubStr(Account, 1, i-1) + StrSubst( SubStr(Account, i), Symbol, SubStr(StrNumber, j, 1) );
            j = j - 1
         end;
         i = i - 1;
      end;
   end;
   return Account; 
end;

/*Заключить в кавычки каждый символ из подстроки ограниченной символом APOSTROPHE в AddMask
  Т.е. вместо 123"ABC"456 сделать 123"A""B""C"456
  Необходимо для правильной подстановки в случае, если символы доп. маски идут в шаблоне не подряд*/
PRIVATE MACRO ParseAddMask( categ:TRecHandler, AddMask:STRING )
  var i = 1, CurCh, AddMaskLen, NewAddMask = "", ApostrCount = 0;

  if( Index( AddMask, APOSTROPHE) == 0 )
     return AddMask;
  end;

  AddMaskLen = strlen( AddMask );
  while( i <= AddMaskLen )
     CurCh = SubStr( AddMask, i, 1);

     if( CurCh == APOSTROPHE )
        ApostrCount = ApostrCount + 1;
        i = i + 1;
        while( i <= AddMaskLen )
           CurCh = SubStr( AddMask, i, 1);
           if( CurCh == APOSTROPHE )
              ApostrCount = ApostrCount + 1;
              break;
           end;
           NewAddMask = NewAddMask + APOSTROPHE + CurCh + APOSTROPHE;
           i = i + 1;
        end;
     else
        NewAddMask = NewAddMask + CurCh;
     end;

     i = i + 1;
  end;

  if( mod(ApostrCount, 2 ) != 0 )
     SayError( categ, "Количество символов <"+APOSTROPHE+"> в дополнительной маске шаблона счета должно быть четным." );
  end;

  return NewAddMask;
END;

/* Подставить дополнительную маску шаблона в основную (Mask) и вернуть результат.*/
PRIVATE MACRO InsertAddMask( categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT, Mask:STRING )
  var i, j, CurCh, CurAddCh, AddCh, Symbol_AddMask, AddMask;

  Symbol_AddMask = GetSymbolByIDElement( categ.rec.Id, MCSTPELM_SYMBOL_П );

  if( Symbol_AddMask != "" )
     AddMask = ParseAddMask( categ, templ.rec.Mask );
     i = strlen( Mask );
     j = strlen( AddMask );
     while( i > 0 )
        CurCh = SubStr( Mask, i, 1);
        if( CurCh == APOSTROPHE ) /*пропустить обработку символа из маски*/
           i = i - 1;
           while( i > 0 )
              if( SubStr( Mask, i, 1) == APOSTROPHE )
                 break;
              end;
              i = i - 1;
           end;
        elif( CurCh == Symbol_AddMask ) /*подставить в маску вместо данного символа - символ из доп. маски*/
           if( j > 0 )
              CurAddCh = SubStr( AddMask, j, 1);
              if( CurAddCh == APOSTROPHE ) 
                 /*Символ в доп. маске заключен в APOSTROPHE, он должен остаться неизменным 
                   и при подстановке в основную маску*/
                 AddCh = SubStr( AddMask, j-2, 3);
                 j = j - 3;
              else
                 AddCh = CurAddCh;
                 j = j - 1;
              end;
           else /*В основной маске больше символов для подстановке доп. маски, чем сама доп. маска */
              AddCh = "0";
           end;
           Mask = SubStr( Mask, 1, i-1) + AddCh + SubStr( Mask, i+1);
        end;
        i = i -1;
     end;
  end;
  return Mask;
END;

/*Удалить из Mask символы, заключенные в APOSTROPHE (включая и сами символы APOSTROPHE)*/
PRIVATE MACRO DeleteConstString( categ:TRecHandler, Mask:STRING )
  var LeftA, RightA, TmpStr;

  LeftA = Index( Mask, APOSTROPHE); /*левая скобка*/
  while( LeftA != 0 )
     TmpStr = SubStr( Mask, LeftA+1 );
     RightA = Index( TmpStr, APOSTROPHE ); /*Правая скобка*/
     if( RightA == 0 )
        SayError( categ, "Количество символов <"+APOSTROPHE+"> в шаблоне счета должно быть четным." );
     end;
     Mask = SubStr(Mask,1,LeftA-1) + SubStr(TmpStr,RightA+1);
     LeftA = Index( Mask, APOSTROPHE);
  end;

  return Mask;
END;

/*Подставить в Account неизменяемые строки - заключенные в APOSTROPHE в Mask */
PRIVATE MACRO AddConstString( categ:TRecHandler, Account:STRING, Mask:STRING )
  var i = 1, j = 1, NewAccount = "", MaskLen, CurCh;

  if( Index( Mask, APOSTROPHE) == 0 )
     return Account;
  end;

  MaskLen = StrLen( Mask );
  while( i <= MaskLen )
    if( SubStr(Mask, i, 1) == APOSTROPHE )
       i = i + 1; 
       while( i <= MaskLen )
          if( SubStr(Mask, i, 1) == APOSTROPHE )
             break;
          else
             NewAccount = NewAccount + SubStr(Mask, i, 1);
          end;
          i = i + 1;
       end;
    else
       NewAccount = NewAccount + SubStr(Account, j, 1);
       j = j + 1;
    end;
    i = i + 1;
  end;

  return NewAccount;
END;

/*******************************************************************
 Сформировать номер счета по маске шаблона КУ                    
 Возможен рекурсивный вызов, если балансовый счет содержит в себе символы 
 categ       - категория (mccateg.dbt)                           
 accdoc      - счет категории учета (mcaccdoc.dbt)               
 templ       - шаблон счета (mctempl.dbt)                          
 FD          - Первичный документ                                
 Mask        - Маска шаблона, по ктоторой будет формироваться счет 
 *******************************************************************/
MACRO MC_MakeAccountNumber( categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT, Mask:STRING )

  var b_Continue, MaskLen, Account, i, Symbol_IDElement, FullMask, CurSymb,
      ChangedSymbols = "0123456789";
  var DprtPartyCode : string;

  MC_NEED_GETKEY = false;

  /* Подставить дополнительную маску шаблона в счет.
     !!! всегда должно быть до обработки остальных символов шаблона. */
  FullMask = InsertAddMask( categ, accdoc, templ, FD, Mask );

  Account = Mask = ConvertString( DeleteConstString( categ, FullMask ) );

  MaskLen = strlen( Mask );
  i = 1; 
  while( i <= MaskLen )
     CurSymb = SubStr(Mask, i, 1);
     if( Index( ChangedSymbols, CurSymb ) == 0 ) /*символ еще не обработан*/

        Symbol_IDElement = GetIDElementBySymbol( categ.rec.Id, CurSymb );
        if( Symbol_IDElement != 0 )
           Account = ChangeStrForSymb( categ, accdoc, templ, FD, CurSymb, Symbol_IDElement, Account, Mask );
           ChangedSymbols = ChangedSymbols + CurSymb;
        else
           SayError( Categ, "В шаблоне счета не задано значение для символа \"" + CurSymb + "\"." );
        end;

     end; 
     i = i + 1;
  end;

  Account = AddConstString( categ, Account, FullMask );

  if( MC_NEED_GETKEY == true )
     DprtPartyCode = "";
     
     CB_GetDprtPartyCode( accdoc.rec.DepartmentID, PTCK_BIC, DprtPartyCode );
     
     Account = GetKey( Account, DprtPartyCode );
  end;

  return Account;

OnError
     return "";
END;
