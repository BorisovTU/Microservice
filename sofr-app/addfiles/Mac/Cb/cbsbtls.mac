/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*  Константы и вспомогательные функции для работы с сообщениями СМФР СБ РФ */
/*  Вынесено из МБР                                                         */
/*  Имя файла: cbsbtls.mac                                                  */
/*  Создан:  10.02.03                                                AAV    */
/****************************************************************************/

import "globals.mac",FIINTER,PTINTER;

const SB_DelimiterS    = "|",
      SB_DelimiterE    = ":",
      SB_Indention     = " ";

private const ПутьКНастройкамКлиентскихСчетов   = "PS\\REQOPENACC\\СЧЕТА КЛИЕНТОВ";

const ТипОбслуживанияПоУмолчанию = "1201"; /* 1 - Валовые платежи, 2 - не срочный, 0 - приоритет, 1 - без запроса статуса */

/* Заголовки, сигнатуры, типы документов, подтипы документов */
const FileSBRF3Head      = "SBRF3:", /* Заголовок файла */
      FileSBRFListHead   = "STLIST:", /* Заголовок файла выписки СБРФ */
      FileSBRF3Foot      = "EOF",    /* Признак конца файла (может отсутствовать) */

      SB_Tag_EndField       = "EE",
      SB_Tag_ReferenceField = "ST",
      SB_Tag_ExtraInfoField = "ME",
      SB_Tag_KeyField       = "KS",
      SB_Tag_TypeDoc        = "DT",
      SB_Tag_SubTypeDoc     = "UT",
      SB_Tag_LastDate       = "LD",
      SB_Tag_OperContent    = "OS",

      SB_Tag_Amount         = "AM",
      SB_Tag_Currency       = "CU",

      SB_Tag_PIB            = "PIB", /* Хранение блока целевой информации в одном поле релиза */
  
      /* Три нижеследующих поля не регламентированы, но используются для ЭЦП */
      SB_Tag_CreateDate  = "_DATE_",
      SB_Tag_Creator     = "_CREATOR_",
      SB_Tag_Number      = "_NUMBRER_",
      SB_Tag_Sign        = "_SIGN_",

      SB_Tag_KeyField_len = 8,  /* Длина ключевого поля */
      SB_abonent_len      = 3,  /* Длина кода абонента */
      SB_date_len         = 6,  /* Длина даты */
      SB_number_len       = 6,  /* Длина Номера Документа */
      SB_creator_len      = 10, /* Длина участника - создателя */
      SB_sign_len         = 3,  /* Длина сигнатуры */

      sign_0B1 = "0B1", /* Платежное поручение, платежный ордер */
      sign_0B2 = "0B2", /* Платежное требование */
      sign_0B3 = "0B3", /* Платежное требование-поручение */
      sign_0B4 = "0B4", /* Дебетовое авизо */
      sign_0B5 = "0B5", /* Кредитовое авизо, платежный ордер */
      sign_0B6 = "0B6", /* Отказы на: поручение, требование, требование-поручение, дебетовое авизо, кредитовое авизо */
      sign_0B7 = "0B7", /* Сообщение участнику */
      sign_0B9 = "0B9", /* Выписка */
      sign_0BB = "0BB", /* Подтверждения на: платежное поручение, платежное требование */
      sign_0BF = "0BF", /* Сообщение свободного формата */
      sign_0BG = "0BG", /* Приложение к кредитовым авизо */
      sign_0BH = "0BH", /* Приложение к дебетовым авизо */
      sign_0SA = "0SA", /* Квитанция получения сообщения */
      sign_0SAERR = "0SAERR", /* Квитанция получения сообщения об ошибке */
      sign_0BQ = "0BQ", /* Запрос на получение выписки */

      type_len = 3,     /* длина типа документа */
      type_001 = "001", /* Платежное поручение, платежный ордер */
      type_002 = "002", /* Платежное требование */
      type_003 = "003", /* Платежное требование-поручение */
      type_004 = "004", /* Дебетовое авизо */
      type_005 = "005", /* Кредитовое авизо */
      type_007 = "007", /* Сообщение участнику */
      type_070 = "070", /* Сообщение свободного формата */
      type_101 = "101", /* Подтверждение на платежное поручение */
      type_102 = "102", /* Подтверждения на платежное требование */
      type_104 = "104", /* */
      type_105 = "105", /* */
      type_601 = "601", /* Отказ на поручение */
      type_602 = "602", /* Отказ на требование */
      type_603 = "603", /* Отказ на требование-поручение */
      type_604 = "604", /* Отказ на дебетовое авизо */
      type_605 = "605", /* Отказ на кредитовое авизо */
      type_704 = "704", /* Приложение к кредитовым авизо */
      type_705 = "705", /* Приложение к дебетовым авизо */
      type_709 = "709", /* Запрос выписки */
      type_undef = "", /* Приложение к дебетовым авизо */

      sub_type_len = 1, /* длина подтипа документа */
      sub_type_0 = "0", /*  */
      sub_type_1 = "1", /*  */
      sub_type_2 = "2", /* Подтип документа: general financial institution transfer */
      sub_type_3 = "3", /* Подтип документа: банковский перевод */
      sub_type_4 = "4", /* Подтип документа: платежный ордер */
      sub_type_5 = "5", /*  */
      sub_type_6 = "6", /*  */
      sub_type_8 = "8", /* Подтип инкассового поручения */
      sub_type_9 = "9", 
      sub_type_undef = "", /*  */

      /* Вид платежной системы (вид кода) по SBRF3 макс. длина 6 символов */
      KindCodeSBRF3_CONTR       = "",
      KindCodeSBRF3_CLIENT      = "",
      KindCodeSBRF3_BANKLICENSE = "",
      KindCodeSBRF3_BIC         = "МФО",    /* БИК ЦБ*/
      KindCodeSBRF3_CLIRING     = "СБ8",    /* Код клиринга СБ РФ */
      KindCodeSBRF3_SWIFT       = "SWIFT",  /* BIC ISO */
      KindCodeSBRF3_REUTER      = "",
      KindCodeSBRF3_MICEX       = "",
      KindCodeSBRF3_DEPOREGN    = "",
      KindCodeSBRF3_CHIPS       = "",
      KindCodeSBRF3_BICPLUS     = "",
      KindCodeSBRF3_NATCOD      = "",
      KindCodeSBRF3_BANKREGNUM  = "",
      KindCodeSBRF3_SMFR        = "СБ8",
      KindCodeSBRF3_SBRF        = "СБ8",
      KindCodeSBRF3_INN         = "",
      KindCodeSBRF3_ORCBLICENSE = "";

/* Вернуть дату по строке ДДММГГ */
macro ДДММГГДата(Str)
  var Year;
  Year = int(SubStr(Str,5,2)); /* YY */
  if( Year > 79 ) /* в соответствии с рекомендациями SWIFT-RUR 5 1.5.1 */
    Year = Year + 1900;
  else
    Year = Year + 2000;
  end;
  return date(int(SubStr(Str,1,2)),  /* DD */
                  int(SubStr(Str,3,2)),  /* MM */
                  Year);
end;

/* Препарирует переданную дату и возвращает ее в строке формата ДДММГГ      */
macro ДатаДДММГГ( Дата )
  var День, Месяц, Год;

  datesplit( Дата, День, Месяц, Год );

  if( День  < 10 )   День  = String( "0", день  );  end;
  if( Месяц < 10 )   Месяц = String( "0", месяц );  end;
  Год = SubStr( String( год ), 3 );

  return String( День, Месяц, Год );
end;

/* Считывает требуемое поле из строки str по задаваемой лексеме fname в формате 
   SBRF3. Результат помещает в fval. В случае проблем возвращает FALSE */
macro ReadFieldSBRF3( fval, fname, str )
  var pos, pos2, fname_len, temp_str, lenvar_formal, temp_str2, lenvar_fact, par;
  
  Setparm( 0, "" );

  if( fname == SB_Tag_Sign )
    par = SubStr( str, 1, SB_sign_len ); 
  elif( fname == SB_Tag_CreateDate )
    par = SubStr( str, 1 + SB_sign_len, SB_date_len );
  elif( fname ==  SB_Tag_Creator )
    par = SubStr( str, 1 + SB_sign_len + SB_date_len, SB_creator_len );
  elif( fname == SB_Tag_Number )
    par = SubStr( str, 1 + SB_sign_len + SB_date_len + SB_creator_len, SB_number_len );
  else
    pos = Index( str, SB_DelimiterS + fname );
    if( pos == 0 ) return FALSE; end;

    fname_len = Strlen( fname ) + 1; /* 1 - для учета начального разделителя */
    /* Строка, начинающаяся с описателя длины нужного поля */
    temp_str = Substr( str, pos+fname_len );
    /* Формальная длина параметра */
    lenvar_formal = Int( Substr( temp_str, 1, Index( temp_str, SB_DelimiterE ) - 1 ) );
    /* Строка, начинающаяся с данных */
    temp_str2 = Substr( temp_str, Index( temp_str, SB_DelimiterE ) + 1 );
    
    if( lenvar_formal )
      par = Substr( temp_str2, 1, lenvar_formal );
    else
      par = "";
    end;

    /* Фактическая длина параметра */
    lenvar_fact = Strlen( par );
    if( lenvar_formal != lenvar_fact )
      return FALSE;
    end;
  end;

  Setparm( 0, par );
  return TRUE;
end;

/* Формирование поля собщения в формате СБРФ3 */
macro MakeFieldSBRF3( field_name, field_value, to_ansi, to_upr )
  var sb_value;

  if( (ValType(to_upr) == V_BOOL) and (to_upr == true) )
    sb_value = StrUpr( field_value );
  else
    sb_value = field_value;
  end;

  if( (ValType(to_ansi) == V_BOOL) and (to_ansi == true) )
    sb_value = ToANSI( sb_value, true );
  end;

  return string( SB_DelimiterS, field_name, strlen(sb_value), SB_DelimiterE, sb_value );
end;

/* Заменить пробелы нулями */
macro CB_StrSubst0( str )
  return StrSubst( str, " ", "0" );
end;

/* Определяет по виду кода RS-Bank вид платежной системы по SBRF3           */
macro ПолучитьВидКодаSBRF3( KindCode )
  var KINDCODESTR;

  if(   KindCode == PTCK_CONTR        )
    KindCodeStr = KindCodeSBRF3_CONTR;
  elif( KindCode == PTCK_CLIENT       )
    KindCodeStr = KindCodeSBRF3_CLIENT;
  elif( KindCode == PTCK_BANKLICENSE  )
    KindCodeStr = KindCodeSBRF3_BANKLICENSE;
  elif( KindCode == PTCK_BIC          )
    KindCodeStr = KindCodeSBRF3_BIC;
  elif( KindCode == PTCK_CLIRING      )
    KindCodeStr = KindCodeSBRF3_CLIRING;
  elif( KindCode == PTCK_SWIFT        )
    KindCodeStr = KindCodeSBRF3_SWIFT;
  elif( KindCode == PTCK_REUTER       )
    KindCodeStr = KindCodeSBRF3_REUTER;
  elif( KindCode == PTCK_MICEX        )
    KindCodeStr = KindCodeSBRF3_MICEX;
  elif( KindCode == PTCK_DEPOREGN     )
    KindCodeStr = KindCodeSBRF3_DEPOREGN;
  elif( KindCode == PTCK_CHIPS        )
    KindCodeStr = KindCodeSBRF3_CHIPS;
  elif( KindCode == PTCK_BICPLUS      )
    KindCodeStr = KindCodeSBRF3_BICPLUS;
  elif( KindCode == PTCK_NATCOD       )
    KindCodeStr = KindCodeSBRF3_NATCOD;
  elif( KindCode == PTCK_BANKREGNUM   )
    KindCodeStr = KindCodeSBRF3_BANKREGNUM;
  elif( KindCode == PTCK_SMFR         )
    KindCodeStr = KindCodeSBRF3_SMFR;        
  elif( KindCode == PTCK_SBRF         )
    KindCodeStr = KindCodeSBRF3_SBRF;        
  elif( KindCode == PTCK_INN          )
    KindCodeStr = KindCodeSBRF3_INN;        
  elif( KindCode == PTCK_ORCBLICENSE  )
    KindCodeStr = KindCodeSBRF3_ORCBLICENSE; 
  else
    KindCodeStr = "";
  end;
  return KindCodeStr;
end;

/* Обрфботка exeption */
macro SB_ExeptionMessage(er)
  var i = 1, str = "";

  while(i <= StrLen(er.Message))
    if (SubStr(er.Message, i, 1) == "|")
      str = SubStr(er.Message, i+1);
      i = StrLen(er.Message);
    else
      i = i + 1;
    end;
  end;

  if (str == "")
    Msgbox(String(er.Message, "|Модуль: ", er.Module, " Строка: ", er.Line));
  else
    Msgbox(str);
  end;
end;

FILE wlaccount( account ) key 0;
/* Определяет принадлежит ли счет нашему банку или нет */
macro SB_IsOwnerAccOwnBank( Acc )  
   var МаскиСчетовКлиентов = "", err; 
   GetRegistryValue(ПутьКНастройкамКлиентскихСчетов, V_STRING, МаскиСчетовКлиентов, err);
   if (StrLen (МаскиСчетовКлиентов)==0) 
               return true;               
   end;// Если маски вообще не заданы. То и сравнивать имя нет смысла. 
       // Пр. работа только с банковскими счетами
   МаскиСчетовКлиентов = StrSubst ( МаскиСчетовКлиентов, ";", "," );
   if (CompareStrWithMasks (МаскиСчетовКлиентов,Acc)) 
               return true;
   end;
   return false;
end;

/***************************************************************************/
/*  Функция последовательного считывания полей из строки сообщений SBRF3   */
/*  Возвращает: 0  - все ОК                                                */
/*              4  - неверный формат поля                                  */
/*              8  - Уже прочитано и обработано последнее поле             */
/***************************************************************************/
macro SB_СчитатьПолеИзСообщения( КодПоля, ЗначениеПоля, СтрокаСообщения )
  var  pos, pos1, ДлинаПоля;
 
  pos = Index( СтрокаСообщения, SB_DelimiterS );
  if( pos == 0 )
    return 4;
  end;
  КодПоля = SubStr( СтрокаСообщения, pos + 1, 2 );
 
  if( КодПоля == SB_Tag_EndField )
    return 8;
  end;
 
  pos1 = Index( СтрокаСообщения, SB_DelimiterE );
  if( pos1 == 0 )
    return 4;
  end;
 
  ДлинаПоля = int(SubStr( СтрокаСообщения, pos + 3, pos1 - pos - 3 ));
  ЗначениеПоля = SubStr( СтрокаСообщения, pos1 + 1, ДлинаПоля );
 
  /* Запрос 26166. Ошибка состояла в том, что становились на
     последний символ разобранного поля. Если этот символ - :, то
     зависает. Надо становится на следующий символ. 30/11/01 BARS   */
  СтрокаСообщения = SubStr( СтрокаСообщения, pos1 + ДлинаПоля + 1 );
 
  /* Возвращаем код поля */
  SetParm( 0, КодПоля );
  /* Возвращаем значение поля */
  SetParm( 1, ЗначениеПоля );
  /* Возвращаем остаток строки */
  SetParm( 2, СтрокаСообщения );

  return 0;
end;

/*Инструментарий шестнадцатиричоного кодирования*/
/*Выходные функции:
  SB_КодироватьШестнадцатирично  ( СтрокаСообщения )
  SB_ДекодироватьШестнадцатирично( СтрокаСообщения )
*/
macro GetHexFigure ( Число:Integer ):String

   if  (Число == 0)
      return "0";
   elif(Число == 1)
      return "1";
   elif(Число == 2)
      return "2";
   elif(Число == 3)
      return "3";
   elif(Число == 4)
      return "4";
   elif(Число == 5)
      return "5";  
   elif(Число == 6)
      return "6";   
   elif(Число == 7)
      return "7";   
   elif(Число == 8)
      return "8";   
   elif(Число == 9)
      return "9";   
   elif(Число == 10)
      return "A";
   elif(Число == 11)
      return "B";
   elif(Число == 12)
      return "C";   
   elif(Число == 13)
      return "D";   
   elif(Число == 14)
      return "E";   
   elif(Число == 15)
      return "F";   
   else
      RunError("Ошибка при шестнадцатиричном кодировании");   
   end;

   return "";
end;

macro GetDecFromHexFigure ( Число:String ):integer
   if  (Число == "0")
      return 0;
   elif(Число == "1")
      return 1;
   elif(Число == "2")
      return 2;
   elif(Число == "3")
      return 3;
   elif(Число == "4")
      return 4;
   elif(Число == "5")
      return 5;  
   elif(Число == "6")
      return 6;   
   elif(Число == "7")
      return 7;   
   elif(Число == "8")
      return 8;   
   elif(Число == "9")
      return 9;   
   elif((Число == "A") or (Число == "a"))
      return 10;
   elif((Число == "B") or (Число == "b"))
      return 11;
   elif((Число == "C") or (Число == "c"))
      return 12;   
   elif((Число == "D") or (Число == "d"))
      return 13;   
   elif((Число == "E") or (Число == "e"))
      return 14;   
   elif((Число == "F") or (Число == "f"))
      return 15;   
   else
      RunError("Ошибка при шестнадцатиричном декодировании");   
   end;

   return -1;
end;

/*Каждому байту данных соответствует пара шестнадцатиричных чисел*/
macro GetHexDigit ( Строка:String ):String
   var num:integer = Codefor(Строка);

   return GetHexFigure(int(num/16)) + GetHexFigure(num - int(num/16)*16);
end;

macro SB_КодироватьШестнадцатирично( СтрокаСообщения:String ):String
   var Строка:String = "";
   var len = StrLen(СтрокаСообщения);

   while(СтрокаСообщения)
      Строка = Строка + GetHexDigit( СтрокаСообщения ); 
      СтрокаСообщения = SubStr(СтрокаСообщения, 2);
   end;

   if( 2*len != StrLen(Строка))
      RunError("Ошибка при шестнадцатиричном кодировании");   
   end;

   return Строка;
end;

macro SB_ДекодироватьШестнадцатирично( СтрокаСообщения:String ):String
   var Строка:String = "";
   var len = StrLen(СтрокаСообщения);

   while(СтрокаСообщения)
      Строка = Строка + StrFor(  GetDecFromHexFigure( SubStr(СтрокаСообщения, 1, 1) )*16 
                               + GetDecFromHexFigure( SubStr(СтрокаСообщения, 2, 1) )    ); 
      СтрокаСообщения = SubStr(СтрокаСообщения, 3);
   end;

   if(len != 2*StrLen(Строка))
      RunError("Ошибка при шестнадцатиричном декодировании");   
   end;

   return Строка;
end;
