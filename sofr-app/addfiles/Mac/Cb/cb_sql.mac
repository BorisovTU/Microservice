/*
$Name:           cb_sql.mac
$Module:         Ядро ГКБО
$Description:    Утилиты для работы с Oracle и RSD
*/

/*───────────────────────────────────────────────────────────────────────────┐
  RS-Bank V6                                                 R-Style Softlab

  Утилиты для работы с Oracle и RSD.

  Создан: 08.01.2004 - Sal.

  Процедуры:
     CopyRSetToFBuff     - копирование данных из полей RS в структуру.
     SQL_ConvTypeSum     - обработка денежного типа из Recordset'a.
     SQL_ConvTypeStr     - обработка строкого типа из Recordset'a.
     SQL_ConvTypeDate    - обработка типа "дата" из Recordset'a.
     SQL_ConvType        - обработка любого типа из Recordset'a.
     SQL_ConvSpec        - преобразование специальных значений.
     SQL_GetTableName    - получение имени SQL-таблицы.
     SQL_Print           - печать запроса.
     SQL_Execute         - выполнение SQL-команды и обработка ошибок.
     SQL_ExecuteAndGetRs - выполнение SQL-команды и получение набора записей.
     SQL_ExecuteSimple   - выполнение SQL-запроса и получение набора записей.
     SQL_ExecuteCatch    - выполнение SQL-команды с игнорированием исключений.
     SQL_Drop            - выполнение SQL-команды "DROP...".
     SQL_GetNRecs        - количество результирующих записей запроса.
     SQL_GetNRecsWhere   - количество результирующих записей запроса.
     SQL_Truncate        - удаление всех записей.
     SQL_ExecuteTrn      - выполнить несколько команд в транзакции.
     SQL_Mask            - сконвертировать DOS-маску в SQL-маску.
     GetSQLDate          - представить дату в SQL-формате.
     GetSQLString        - представить строку в SQL-формате.
     GetSQLChar          - представить символ в SQL-формате.
     GetSQLFldList       - получить список полей по словарному описанию структуры.

  Классы:
     SQL_Dumper          - вывод данных по запросу в виде таблицы
└───────────────────────────────────────────────────────────────────────────*/
import RsbDataSet, treport, lib_lang;

/***********************************************************************
   Внутренние константы
***********************************************************************/
CONST MUL_CHAR     = "*";
CONST ONE_CHAR     = "?";
CONST MUL_CHAR_SQL = "%";
CONST ONE_CHAR_SQL = "_";

PRIVATE CONST V_SPECVAL = 26;
/***********************************************************************
   Коды ошибок
***********************************************************************/
CONST ORA_00942 = -00942;
CONST ORA_00955 = -00955;
CONST ORA_01418 = -01418;
CONST ORA_02289 = -02289;
CONST ORA_04080 = -04080;

CONST TABLE_OR_VIEW_DOES_NOT_EXIST               = ORA_00942;
CONST NAME_IS_ALREADY_USED_BY_AN_EXISTING_OBJECT = ORA_00955;
CONST SPECIFIED_INDEX_DOES_NOT_EXIST             = ORA_01418;
CONST SEQUENCE_DOES_NOT_EXIST                    = ORA_02289;
CONST TRIGGER_DOES_NOT_EXIST                     = ORA_04080;

/***********************************************************************
   Возвратить "Money" после RecordSet'a

   sum - значение

   Возвращаемое значение: (MoneyL)
***********************************************************************/
MACRO SQL_ConvTypeSum( sum )
    var t = ValType( sum );

    /* Передан SQL'ый NULL*/
    if (ValType(sum) == V_SPECVAL)
      return $0;
    end;

    if( ( t == V_DOUBLE ) or ( t == V_DOUBLEL ) or ( t == V_MONEY ) )
        return MoneyL( sum );
    elif( sum == NULL )
        return $0;
    end;

    return sum;
END;

/***********************************************************************
   Возвратить "String" после RecordSet'a

   val - значение

   Возвращаемое значение: STRING
***********************************************************************/
MACRO SQL_ConvTypeStr( val )
    /* Передан SQL'ый NULL*/
    if (ValType(val) == V_SPECVAL)
      return "";
    end;

    if    ( ValType (val) == V_UNDEF  ) return "";
    elif  ( ValType (val) == V_STRING )
        if ( (StrLen(val) == 1) and (CodeFor(val) == 1) )
            val = String("");
        end;
    end;

    return val;
END;

/***********************************************************************
   Возвратить "Time" после RecordSet'a

   dt - значение

   Возвращаемое значение: TIME
***********************************************************************/
MACRO SQL_ConvTypeTime( dt )
    var tm = Time(0,0,0);

    /* Передан SQL'ый NULL*/
    if( dt == NULL )
        return Time( 0, 0, 0 );
    elif (ValType(dt) == V_SPECVAL)
        return Time(0, 0, 0);
    elif( ValType( dt ) == V_DTTM )
        DtTmSplit( dt, dt, tm );
    elif( ValType( dt ) == V_DATE )
        return Time( 0, 0, 0 );
    end;

    return tm;
END;

/***********************************************************************
   Возвратить "Date" после RecordSet'a

   dt - значение

   Возвращаемое значение: DATE
***********************************************************************/
MACRO SQL_ConvTypeDate( dt )
    var d, m, y;

    /* Передан SQL'ый NULL*/
    if (ValType(dt) == V_SPECVAL)
      return Date(0, 0, 0);
    end;

    if( dt == NULL )
        return Date( 0, 0, 0 );
    end;
    if( ValType( dt ) == V_DTTM )
        DtTmSplit( dt, dt );
    end;
    if( ValType( dt ) == V_DATE )
        DateSplit( dt, d, m, y );
        if ( ( d == 1 ) and ( m == 1 ) and ( y == 1 ) )
            return Date( 0, 0, 0 );
        end;
    end;

    return dt;
END;

/***********************************************************************
   Возвратить "DateTime" после RecordSet'a

   dt - значение

   Возвращаемое значение: DateTime
***********************************************************************/

macro SQL_ConvTypeDateTime(dt)
  return DtTm(SQL_ConvTypeDate(dt), SQL_ConvTypeTime(dt));
end;

/***********************************************************************
   Возвратить "Integer" после RecordSet'a

   val - значение

   Возвращаемое значение: (INTEGER)
***********************************************************************/
MACRO SQL_ConvTypeInteger( val )
    var t = ValType( val );

    /* Передан SQL'ый NULL*/
    if (ValType(val) == V_SPECVAL)
      return 0;
    end;

    if( t == V_INTEGER )
        return val;
    elif (( t == V_DOUBLE ) or ( t == V_DOUBLEL ) or ( t == V_MONEY ) or ( t == V_MONEYL ) or (t == V_NUMERIC))
        return Int(val);
    elif( val == NULL )
        return 0;
    end;

    return val;
END;

/***********************************************************************
   Возвратить "bool" после RecordSet'a

   val - значение

   Возвращаемое значение: (bool)
***********************************************************************/

macro SQL_ConvTypeBool(val)
    var t = ValType(val);

    /* Передан SQL'ый NULL*/
    if (t == V_SPECVAL)
      return false;
    end;

    if (t == V_INTEGER)
        return val != 0;
    elif(t == V_STRING)
        return val == "X";
    elif(t == V_BOOL)
        return val;
    end;

    return false;
end;

/***********************************************************************
   Возвратить значение после RecordSet'a (для любого типа)

   val - значение

   Возвращаемое значение: разное; NULL, если dt == NULL.
***********************************************************************/
MACRO SQL_ConvType( val )
    var t = ValType( val );

    /* Передан SQL'ый NULL*/
    if (ValType(val) == V_SPECVAL)
      return NULL; /* подсунули неизвестно что - получили неизвестно что */
    end;

    if( ( t == V_DOUBLE ) or ( t == V_DOUBLEL ) or ( t == V_MONEY ) or ( t == V_MONEYL ) )
        return SQL_ConvTypeSum( val );
    elif( t == V_STRING )
        return SQL_ConvTypeStr( val );
    elif( ( t == V_DTTM ) or ( t == V_DATE ) )
        return SQL_ConvTypeDate( val );
    elif( t == V_INTEGER )
        return SQL_ConvTypeInteger( val );
    end;
    return val;
END;

/***********************************************************************
   Преобразовать специальное значение, хранимое в БД для использования
   в программе.

   Ora Chr(1)      -> Rsl String("")
   Ora Date(1,1,1) -> Rsl Date(0,0,0)
   Ora DateTime    -> Rsl Date

   value - значение

   Возвращаемое значение: преобразованное значение.
***********************************************************************/
MACRO SQL_ConvSpec(value)
    var valueType = ValType(value);

    /* Передан SQL'ый NULL*/
    if (valueType == V_SPECVAL)
      return NULL;
    end;

    if   (valueType == V_STRING)
        value = SQL_ConvTypeStr(value);
    elif (valueType == V_DATE)
        value = SQL_ConvTypeDate(value);
    elif (valueType == V_DTTM)
        value = SQL_ConvTypeDate(value);
    end;

    return value;
END;

/***********************************************************************
   Копирует текущее содержимое Recordset'а в буфер файла или структуры

   fbuff          - буфер файла или структуры
   rset           - Recordset или TRsbDataSet
   FldAliasPrefix - префикс алиаса поля

   Возвращаемое значение: НЕТ
***********************************************************************/
MACRO CopyRSetToFBuff( fbuff, rset, FldAliasPrefix )
    DefaultParm(FldAliasPrefix, "");

    var wrkBuff = TRecHandler(FileName(fbuff)),
        idx   = 0,
        nflds = wrkBuff.FldNumber(),
        val,
        NullConv;

    wrkBuff.Clear();

    if (IsEqClass("RsdRecordset", rset))
        NullConv = rset.Command.NullConversion;
        rset.Command.NullConversion = true;
    end;

    if (IsEqClass("RsbDataSet", rset))
        NullConv = rset.NullConversion;
        rset.NullConversion = true;
    end;

    if ( FldAliasPrefix == "" )
        FldAliasPrefix = "t_";
    end;

    while( idx < nflds )
         val = rset.value( FldAliasPrefix + wrkBuff.FldName( idx ) );

         if ( ValType( wrkBuff.item( idx ) ) == V_STRING )
             wrkBuff.item( idx ) = SQL_ConvTypeStr( val );
         elif( val != NULL )
             wrkBuff.item( idx ) = rset.value( FldAliasPrefix + wrkBuff.FldName( idx ), null, ValType( wrkBuff.item( idx ) ) );
         end;

        idx = idx + 1;
    end;

    if (IsEqClass("RsdRecordset", rset))
        rset.Command.NullConversion = NullConv;
    end;

    if (IsEqClass("RsbDataSet", rset))
        rset.NullConversion = NullConv;
    end;

    Copy(fbuff, wrkBuff);
END;

/***********************************************************************
   Формирует имя SQL-таблицы по имени файла или структуре, его
   описывающей.

   f - файл или имя файла

   Возвращаемое значение: (STRING) имя SQL-таблицы
***********************************************************************/
MACRO SQL_GetTableName( f )
    Var fnm, idx;

    if   ( ValType(f) == V_STRING ) fnm = f;
    elif ( ValType(f) == V_FILE   ) fnm = FileName(f);
    elif ( ValType(f) == V_GENOBJ ) fnm = f.FileName;
    end;

    if ( Index(fnm,".") > 0 )
        idx = StrLen(fnm);

        while( idx > 0 )
            if ( SubStr(fnm,idx,1) == "\\" )
                return string("d" + StrSubst( SubStr(fnm,idx+1), ".", "_" ));
            end;
            idx = idx - 1;
        end;

        return string("d" + StrSubst( SubStr(fnm,idx+1), ".", "_" ));
    end;

    return fnm;
END;

/***********************************************************************
   Форматирует и печатает текст SQL-предложения

   cmd - переменная типа RsdCommand с заполненным CmdText или строка,
         содержащая SQL-команду

   Возвращаемое значение: (STRING) отформатированная строка.
***********************************************************************/
MACRO SQL_Print( cmd )
   Var squery;

   if ( ValType(cmd) == V_STRING )
      squery = cmd;
   else
      squery = cmd.CmdText;
   end;

   PrintLn("Текст команды: ");
   PrintLn(squery);
END;

/***********************************************************************
   Выполняет SQL-команду и обработку ошибок

   cmd - переменная типа RsdCommand с заполненным CmdText или строка,
         содержащая SQL-команду

   msg - сообщение в статус-строке

   isUsingIndic - показать прогресс-бар на время выполнения запроса

   Возвращаемое значение: (RsdCommand) выполненная команда, переданная
   в качестве, либо сгенерированная по тексту запроса.
***********************************************************************/
MACRO SQL_Execute( cmd, msg, isUsingIndic )
    var i = 0,
        command;

    if ( ValType(cmd) == V_STRING )
        command = RsdCommand(cmd);
    else
        command = cmd;
    end;

    if (msg != NULL)
        Message(msg);
    end;

    if (isUsingIndic == NULL)
        isUsingIndic = false;
    end;

    if (isUsingIndic)
        InitProgress(-1, msg, msg);
    end;

    command.execute();

    if (isUsingIndic)
        RemProgress();
    end;

    return command;

    OnError(err);
    PrintLn( "Строка: ", err.line );
    PrintLn( err.message );
    while( i < command.connection.environment.ErrorCount )
        PrintLn( command.connection.environment.Error(i).Descr);
        i = i + 1;
    end;
    SQL_Print(command);
    RunError();
END;

/***********************************************************************
   Выполняет SQL-команду и обработку ошибок

   cmd - строка, содержащая SQL-команду

   msg - сообщение в статус-строке

   Возвращаемое значение: (RsdRecordset) Recordset выполненной команды.
***********************************************************************/
MACRO SQL_ExecuteAndGetRs( cmd, msg )
    return TRsbDataSet(cmd);
END;

/***********************************************************************
   Выполняет SQL-запрос и обработку ошибок

   from   - имя таблицы ил файла
   select - поля выборки
   where  - фильтрация
   order  - сортировка
   msg    - сообщение в статус-строке

   Возвращаемое значение: (RsdRecordset) Recordset выполненного запроса.
***********************************************************************/
MACRO SQL_ExecuteSimple( from, select, where, order, msg )
    if( ( from == NULL ) or ( select == NULL ) )
        RunError( "|Неправильный вызов функции SQL_ExecuteSimple:|первые два параметра должны быть определены" );
    end;

    var query = "SELECT " + select                  + "\n" +
                "FROM   " + SQL_GetTableName(from)  + "\n";

    if ( where != NULL )
        query = query + "WHERE  " + where + "\n";
    end;

    if ( order != NULL )
        query = query + "ORDER BY " + order + "\n";
    end;

    return SQL_ExecuteAndGetRs( query, msg );
END;

/***********************************************************************
   Выполняет SQL-команду с перехватом PL/SQL-исключений, передаваемых
   в качестве параметров.

   cmd - переменная типа RsdCommand с заполненным CmdText или строка,
         содержащая SQL-команду

   msg - сообщение в статус-строке

   Возвращаемое значение: НЕТ
***********************************************************************/
MACRO SQL_ExecuteCatch( cmd, msg )
    var i = 0;

    var command;

    var PLSQL_exception_num     = 0,
        PLSQL_block             = "",
        PLSQL_exception_declare = "DECLARE\n",
        PLSQL_exception_catch   = "EXCEPTION\n",
        PLSQL_command_execute   = "BEGIN\n",
        PLSQL_end               = "END;\n";

    if ( ValType(cmd) == V_STRING )
        command = RsdCommand(cmd);
    else
        command = cmd;
    end;

    i = 2;
    while( GetParm(i,PLSQL_exception_num) )
        PLSQL_exception_declare = PLSQL_exception_declare +
                                  "\te_exception_" + (i-2) + " EXCEPTION;\n" +
                                  "\tPRAGMA EXCEPTION_INIT( e_exception_" + (i-2) + ", " + PLSQL_exception_num + " );\n";

        PLSQL_exception_catch   = PLSQL_exception_catch +
                                  "\tWHEN e_exception_" + (i-2) + " THEN NULL;\n";

        i = i + 1;
    end;

    PLSQL_command_execute = PLSQL_command_execute + "\tEXECUTE IMMEDIATE '" + command.cmdText + "';\n";

    PLSQL_block = PLSQL_exception_declare +
                  PLSQL_command_execute   +
                  PLSQL_exception_catch   +
                  PLSQL_end;

    command.cmdText = PLSQL_Block;

    SQL_Execute(command,msg);
END;

/***********************************************************************
   Удаляет объект, игнорируя ошибку в случае его отсутствия

   cmd - переменная типа RsdCommand с заполненным CmdText или строка,
         содержащая SQL-команду

   msg - сообщение в статус-строке

   Возвращаемое значение: НЕТ
***********************************************************************/
MACRO SQL_Drop( cmd, msg )
    SQL_ExecuteCatch( cmd, msg,
                      TABLE_OR_VIEW_DOES_NOT_EXIST,
                      SPECIFIED_INDEX_DOES_NOT_EXIST,
                      TRIGGER_DOES_NOT_EXIST,
                      SEQUENCE_DOES_NOT_EXIST );
END;

/***********************************************************************
   Возвращает количество записей в запросе

   query - текст запроса

   Возвращаемое значение: (INT) количество записей

   Примечания: фактически, выполняет запрос и подсчитывает количество
   записей результата, поэтому, для запросов, выполняемых длительное
   время, использовать не рекомендуется.
***********************************************************************/
MACRO SQL_GetNRecs( query : String )
    var nRecs   = 0,
        dataSet = TRsbDataSet("SELECT NVL(cast(COUNT(*) as integer),0) nRecs FROM (" + Query + ") subq");

    if ( dataSet.moveNext() )
        nRecs = Int(dataSet.nRecs);
    end;

    return nRecs;
END;

/***********************************************************************
   Возвращает количество записей в запросе

   from  - имя таблицы (возможно, нескольких) или имя файла
   where - строка с WHERE-условием (необязательный параметр)

   Возвращаемое значение: (INT) количество записей

   Примечания: фактически, выполняет запрос и подсчитывает количество
   записей результата, поэтому, для запросов, выполняемых длительное
   время, использовать не рекомендуется.
***********************************************************************/
MACRO SQL_GetNRecsWhere( from, where : String )
    var nRecs   = 0,
        cmdText = "SELECT NVL(cast(COUNT(*) as integer),0) nRecs FROM " + SQL_GetTableName(from),
        dataSet;

    if ( where != "" )
        cmdText = cmdText + " " + where;
    end;

    dataSet = TRsbDataSet(cmdText);

    if ( dataSet.moveNext() )
       nRecs = Int(dataSet.nRecs);
    end;

    return NRecs;
end;

/***********************************************************************
   Удаляет все записи из таблицы

   f - файл или имя таблицы

   Возвращаемое значение: Нет
***********************************************************************/
MACRO SQL_Truncate( f )
    SQL_Execute("TRUNCATE TABLE " + SQL_GetTableName(f));
END;

/***********************************************************************
   Выполняет в транзакции набор SQL-команд

   ... - переменная типа RsdCommand с заполненным CmdText или строка,
         содержащая SQL-команду

   Возвращаемое значение: Нет
***********************************************************************/
MACRO SQL_ExecuteTrn( /*...*/ )
    var i = 0,
        cmd;

    RslDefCon.BeginTrans();

    i = 0;
    while( GetParm(i,cmd) )
        SQL_Execute( cmd );
        i = i + 1;
    end;

    RslDefCon.CommitTrans();

    return;

    OnError();
    RslDefCon.RollbackTrans();
    RunError();
END;

/***********************************************************************
   Получить SQL-представление даты

   _date - дата, котороую необходимо преобразовать

   Возвращаемое значение: (STRING) SQL-представление даты
***********************************************************************/
MACRO GetSQLDate( _date )
    if ( _date!=date(0,0,0) )
        return string( "TO_DATE( '",substr(string(_date), 1, 10),"', 'DD.MM.YYYY' )" );
    else
        return "TO_DATE('01-01-0001', 'DD-MM-YYYY')";
    end;
end;

/***********************************************************************
   Получить SQL-представление строки

   str - строка, котороую необходимо преобразовать

   Возвращаемое значение: (STRING) SQL-представление строки
***********************************************************************/
MACRO GetSQLString( str )
    if ( str=="" )
        return "chr(1)";
    else
        return string("'", strsubst(String(str), "'", "''"), "'");
    end;
end;

/***********************************************************************
   Получить SQL-представление символа

   str - символ, который необходимо преобразовать

   Возвращаемое значение: (STRING) SQL-представление символа
***********************************************************************/
MACRO GetSQLChar( str )
    if ( str=="" )
        return "chr(0)";
    else
        return string( "'",str,"'" );
    end;
end;

/**
 * Получить булево тождество в виде строки
 * для подстановки в SQL-запрос: 1 = 1 или 0 = 1.
 *
 * @param isVerity Значение булевой переменной.
 *
 * @return булево тождество в виде строки
 */
macro getSqlBoolIdentity(isVerity : Bool) : String
    if (isVerity)
        return "1 = 1"
    end;

    return "0 = 1";
end;
/***********************************************************************
   Преобразует DOS-маску (*,?) в SQL-маску (%,_)

   str - DOS-маска

   Возвращаемое значение: (STRING) SQL-маска
***********************************************************************/
MACRO SQL_Mask( mask )
    return StrSubst( StrSubst(mask,MUL_CHAR,MUL_CHAR_SQL), ONE_CHAR, ONE_CHAR_SQL );
END;

/***********************************************************************
   Формирует по словарному описанию список полей структуры с псевдонимами

   Struct           - название структуры, или RECORD, или TRecHandler,
                                          или FILE,   или TBFile
   Dict             - словарь (по умолчанию "bank.def"), нужен только при
                      задании строкового имени структуры
   TableAlias       - алиас таблицы в SQL-запросе (по умолчанию "")
   FieldAliasPrefix - префикс алиаса поля в SQL-запросе (по умолчанию - "")

   Возвращаемое значение: (STRING) список полей через запятую
***********************************************************************/
MACRO GetSQLFldList(Struct, Dict, TableAlias, FieldAliasPrefix)
  macro MakeFld(FieldName, TableAlias, FieldAliasPrefix)
    return TableAlias + "t_" + FieldName + " AS " + FieldAliasPrefix + FieldName;
  end;

  var wrkStruct;
  var i;
  var str = "";

  DefaultParm(Dict,             "bank.def");
  DefaultParm(TableAlias,       "");
  DefaultParm(FieldAliasPrefix, "");

  if ((ValType(Struct) != V_STRING) and
      (ValType(Struct) != V_FILE)   and
      (ValType(Struct) != V_STRUC)  and
      (ValType(Struct) != V_GENOBJ)
     )
    RunError("Не задана структура таблицы");
  end;

  if (ValType(Struct) == V_GENOBJ)
    if ((IsEqClass("TRecHandler", Struct) == false) and (IsEqClass("TBFile", Struct) == false))
      RunError("Не задана структура таблицы");
    end;
  end;

  if (ValType(Struct) == V_STRING)
    wrkStruct = TRecHandler(Struct, Dict);
  else
    wrkStruct = TRecHandler(FileName(Struct));
  end;

  if (TableAlias != "")
    TableAlias = TableAlias + ".";
  end;

  i = 0;
  while(i < FldNumber(wrkStruct)-1);
    str = str + MakeFld(FldName(wrkStruct, i), TableAlias, FieldAliasPrefix) + ", ";
    i = i+1;
  end;
  str = str + MakeFld(FldName(wrkStruct, i), TableAlias, FieldAliasPrefix);

  return str;

  OnError(err)
    PrintLn("Модуль: ", err.Module, " Строка: ", err.Line);
    PrintLn(err.Message);
    RunError();
END;

/***********************************************************************
   Формирует по словарному описанию список полей структуры

   Struct           - название структуры, или RECORD, или TRecHandler,
                                          или FILE,   или TBFile
   Dict             - словарь (по умолчанию "bank.def"), нужен только при
                      задании строкового имени структуры
   TableAlias       - алиас таблицы в SQL-запросе (по умолчанию "")
   FieldAliasPrefix - префикс алиаса поля в SQL-запросе
                      (по умолчанию - строка из TableAlias)

   Возвращаемое значение: (STRING) список полей через запятую
***********************************************************************/
macro sqlGetFieldsString(tableName, tableAlias, fieldAliasPrefix)

    defaultParm(fieldAliasPrefix, "");

    var fieldAlias;

    tableAlias = ternary(tableAlias == null, "", tableAlias + ".");

    var fl = "";
    var rs = RsdRecordset("SELECT * FROM " + tableName + " WHERE 0 = 1");

    rs.moveNext();

    var i = 0;
    var n = rs.fldCount;
    while (i < n)
        fieldAlias = ternary(fieldAliasPrefix == "", "", "AS" + " " + fieldAliasPrefix + "_" + rs.fld(i).name);
        fl = fl + ternary(i > 0, ", ", "") + tableAlias + rs.fld(i).name + " " + fieldAlias;
        i  = i + 1;
    end;

    return fl;
end;

/* Обертка запроса для скроллинга с паджинацией */
macro SQL_WrapSelect( Query:string,    /* Строка запроса */
                      PageNum:integer, /* Номер страницы */
                      PageSize:integer /* Размер страницы */
                    ):string
  var RetVal:string = "";

  RetVal = " SELECT t.* FROM ( SELECT rownum RN, tt.* FROM ( " + Query;

  if( PageSize > 0 )
     RetVal = RetVal + " ) tt WHERE ROWNUM <= " + string(PageSize*(PageNum + 1)) + " ) t WHERE t.RN >= " + string(PageSize*(PageNum) + 1) + " ";
  else
     RetVal = RetVal + " ) tt ) t ";
  end;

  return RetVal;
end;

/***********************************************************************
   Вывод данных по запросу в виде таблицы.
   offset - отступ от левого края.
***********************************************************************/
CLASS SQL_Dumper( offset )
    private var rep = CTableReport( offset );

    private var fields = TArray;    // массив полей в порядке следования
    private var types  = TArray;    // массив типов полей в порядке следования

    /* Преобразовать тип значения
       value - значение
       type  - требумый тип значения
       (надо бы её сделать библиотечной)
    */
    private
    MACRO ConvertToType(value, type : Integer)
        if (ValType(value) != type)
            if   (type == V_UNDEF)
                value = NULL;
            elif (type == V_INTEGER)
                value = Int(value);
            elif (type == V_DOUBLE)
                value = Double(value);
            elif (type == V_DOUBLEL)
                value = DoubleL(value);
            elif (type == V_MONEY)
                value = Money(value);
            elif (type == V_MONEYL)
                value = MoneyL(value);
            elif (type == V_STRING)
                value = String(value);
            elif (type == V_DATE)
                value = Date(value);
            elif (type == V_TIME)
                value = Time(value);
            end;
        end;

        return value;
    END;

    /* Добавить колонку
       field    - имя поля в запросе
       name     - имя колонки в печатной таблице (заголовок)
       len      - ширина колонки
       type     - тип колонки
    */
    MACRO AddColumn( field, name, len, type )
        rep.AddColumn( name, len );
        fields[fields.size] = field;

        if (ValType(type) == V_INTEGER)
            types[types.size] = type;
        else
            types[types.size] = V_UNDEF;
        end;
    END;

    /* Собственно вывод.
       Параметры - как в SQL_ExecuteAndGetRs:
       cmd - текст SQL-запроса
       msg - сообщение для статус-строки
       text - название таблицы
       Если данные есть, выводит и возвращает true, иначе возвращает false.
    */
    MACRO Dump(cmd, msg, text)
        var rs = SQL_ExecuteAndGetRs(cmd, msg);
        var rep_continue = rs.MoveNext();
        if(not rep_continue)
            return false;
        end;

        rep.PrintHead(text);
        var vals = TArray;
        var i;
        while(rep_continue)
            i = 0;
            while(i < fields.size)
                vals[i] = SQL_ConvSpec(rs.Value(fields[i]));
                if (types[i] != V_UNDEF)
                    vals[i] = ConvertToType(vals[i], types[i]);
                end;
                i = i + 1;
            end;
            rep.PrintStringTransferByWord(vals);
            rep_continue = rs.MoveNext();
        end;
        rep.PrintBottom( );

        return true;
    END;
END;
