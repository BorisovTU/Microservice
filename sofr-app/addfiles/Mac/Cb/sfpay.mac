/*
$Name:        sfpay.mac
$Module:      РКО (ПЗО)  
$Description: Единый способ формирования документов оплаты удержанных комиссий и ТО
*/


/*                                                                          */
/*  Имя файла: sfpay.mac                                                    */
/*  Создан: 23.07.2001                                        Стасевич В.   */
/*  Переработан: 22.01.2010                                   SolAN         */
/****************************************************************************/
import sfcommon, sfpaym, sfpayord, sfpaydoc, sfbnkclm, sfpaycor, sfpaycash;

private macro IsOurBank( BankID )
  if( (BankID == {HeadBankID}) OR (BankID == {OurBank}) )
    return true;
  else
    return false;
  end;
end;

private macro CheckIfCashDocPossible( objectType, objectBuf, sfcomiss, sidebet, sicredit, IsCashDoc:@bool )
  
  IsCashDoc = false;
  
  if( (objectType == OBJTYPE_SFSINGDF) AND (sfcomiss.InstantPayment == "X") AND IsOurBank(sicredit.rec.BankID) )
    return SfCheckCashAccountType( sidebet.Rec.Account, sidebet.Rec.FIID, @IsCashDoc );
  else
    return 0;
  end;

end;

/*
  Входные параметры:
    sidebet   - ПИ дебета УК/ТО
    sicredit  - ПИ кредита УК/ТО
    sfcomiss  - вид комиссии справочника ГК DSFCOMISS_DBT
    payParams - параметры оплаты ПЗО - объект класса TSfPayParams

Возвращаемое значение:
    0 - создание платежа возможно,
    значение > 0 - код ошибки, по причине которой невозможно создание платежа.
*/
macro CheckCreateSfPayment(sidebet, sicredit, sfcomiss, payParams)
  var stat = 0;
  var ErrMsg = "";

  var bSayError = true;
  if( IsOprMultiExec() )
    bSayError = false;
  end;

  var IsCashDoc = false;
  stat = CheckIfCashDocPossible( payParams.objectType, payParams.objectBuf, sfcomiss, sidebet, sicredit, @IsCashDoc );
  if( stat != 0 )
    SfPayErrorTreat( stat, bSayError );
    ErrMsg = GetSfPay_ErrMsg(stat);
    payParams.SetError( stat, ErrMsg );
    return stat;
  end;

  if( IsCashDoc == true )
    stat = SfCheckCashDocParams( sicredit, sidebet );
    if( stat )
      SfPayErrorTreat( stat, bSayError );
      ErrMsg = GetSfPay_ErrMsg(stat);
      payParams.SetError( stat, ErrMsg );
      return stat;
    else
      return 0;
    end;
  elif( (IsOurBank(sidebet.rec.PartyID)) OR (sidebet.rec.PartyID == 0) )   //Если направление комиссии (ТО) к банку
    if( sidebet.rec.Department == 0)       
        stat = SFPAY_ERROR_PAYERACC_NOTAINOURBANK;
        SfPayErrorTreat( stat, bSayError );
        ErrMsg = GetSfPay_ErrMsg(stat);
        payParams.SetError( stat, ErrMsg );
        return stat;
    end;

    return 0;
  else /*Если направление комиссии (ТО) к клиенту*/
    if( sicredit.rec.Department == 0 )
      stat = SFPAY_ERROR_RECEIVERACC_NOTAINOURBANK;
      SfPayErrorTreat( stat, bSayError );
      ErrMsg = GetSfPay_ErrMsg(stat);
      payParams.SetError( stat, ErrMsg );
      return stat;
    end;
        
    if( sidebet.rec.Department == 0 )
      stat = SFPAY_ERROR_CLAIM_IMPOSSIBLE;
      SfPayErrorTreat( stat, bSayError );
      ErrMsg = GetSfPay_ErrMsg(stat);
      payParams.SetError( stat, ErrMsg );
      return stat;
    end;
/*
    //Если счет плательщика и счет получателя в нашем филиале и настройка "CB\BANKORDERFORCOMM" = YES, то
    if( (bBankorderForComm_Setting()) AND bSfRightFilial(sidebet, sicredit) )
      return 0;
    else                                      
      /* Иначе (счет плательщика и счет получателя открыты в разных on-line филиалах),
         1. Если счет плательщика и счет получателя рублевые, то*/
      if( (sidebet.rec.FIID == NATCUR) AND (sicredit.rec.FIID == NATCUR) )
        /*2. Формируем рублевое клиентское требование. Параметры акцепта берем согласно СПИ ДО. 
        Если комиссия взимается без ДО, то формируется безакцептное требование. 
        3. Сформированное требование выгружаем в РКО в том филиале, в котором открыт счет плательщика. */
        return 0;

      else/*4. Иначе (счета плательщика или счет получателя не рубли). 
        Создаем валютный клиентский платеж и вставляем его в РКО в том филиале, где открыт счет плательщика.*/
        return 0;
      end;
    end;
*/
  end;

  return stat;
end;

private macro SfFormPayDoc( sidebet, sicredit, sfcomiss, payParams:TSfPayParams,
                            sfinvlnk, SumInInvFIID, IsBatchMode,  
                            bilfDocArray:@TArray,  oprchild)
  var sum = $0;
  var converted_sum = $0;

  var paymStatus = null;

  var bSayError = true;
  if( IsOprMultiExec() )
    bSayError = false;
  end;

  payParams.correctSums( sfcomiss );
  payParams.getPlusCalcAccounts( sicredit );


  var stat = CheckCreateSfPayment(sidebet, sicredit, sfcomiss, payParams);
  if(stat != 0)
    return stat;
  end;

  var IsCashDoc = false;
  CheckIfCashDocPossible( payParams.objectType, payParams.objectBuf, sfcomiss, sidebet, sicredit, @IsCashDoc ); // нужен для определения IsCashDoc

  if( IsCashDoc == true )
      return SfFormCashOrderExt( sidebet, sicredit, sfcomiss, payParams, IsBatchMode, oprchild );
  elif( (IsOurBank(sidebet.rec.PartyID)) OR (sidebet.rec.PartyID == 0) )   //Если направление комиссии (ТО) к банку

    if( sicredit.rec.Department == 0 )
      paymStatus = PM_READY_TO_SEND;
    end;

    return SfFormBankPaymentExt( sidebet, sicredit, sfcomiss, payParams, paymStatus, sfinvlnk, null, IsBatchMode, oprchild );
  else /*Если направление комиссии (ТО) к клиенту*/
    //Если счет плательщика и счет получателя в нашем филиале и настройка "CB\BANKORDERFORCOMM" = YES, то
    if( (bBankorderForComm_Setting()) AND bSfRightFilial(sidebet, sicredit) )
      return SfFormBankOrderExt( sidebet, sicredit, sfcomiss, payParams, sfinvlnk, null,
                                 IsBatchMode, oprchild );
    else                                      
      /* Иначе (счет плательщика и счет получателя открыты в разных on-line филиалах),
         1. Если счет плательщика и счет получателя рублевые, то*/
      if( (sidebet.rec.FIID == NATCUR) AND (sicredit.rec.FIID == NATCUR) )
        /*2. Формируем рублевое клиентское требование. Параметры акцепта берем согласно СПИ ДО. 
        Если комиссия взимается без ДО, то формируется безакцептное требование. 
        3. Сформированное требование выгружаем в РКО в том филиале, в котором открыт счет плательщика. */
        return SfFormClientOrderExt( sidebet, sicredit, sfcomiss, payParams, sfinvlnk, null, 
                                     IsBatchMode, oprchild );

      else/*4. Иначе (счета плательщика или счет получателя не рубли). 
        Создаем валютный клиентский платеж и вставляем его в РКО в том филиале, где открыт счет плательщика.*/
        return SfFormClientPaymExt( sidebet, sicredit, sfcomiss, payParams, sfinvlnk, null,
                                  IsBatchMode, oprchild );
      end;
    end;
  end;

  return 0;
end;

macro SfFormDocsCommon
( 
   OutBuffer, 
   sidebet,                 // Дт. - СПИ по счету плательщика                   
   sicredit,                // Кт. - СПИ по счет получателя                     
   sfcomiss,                // буфер вида комиссии                              
   payParams:TSfPayParams,  // параметры оплаты ПЗО - объект класса TSfPayParams
   sfinvlnk,                // параметр связи ТО с платежом                     
   SumInInvFIID,            // сумма оплтаты в валюте ТО                       
   bilfDocArray:@TArray,    // массив параметров ЗК СФ                          
   IsBatchMode,             // пакетный режим формирования РДД                  
   oprchild                 // буфер записи таблицы oprchild.dbt                
)
  var retval = 0;

  payParams.feeType = SF_FEE_TYPE_PERIOD; /*objectType == OBJTYPE_SFDEFCOM или */
  if( payParams.objectType == OBJTYPE_OPRSFCOM )
    payParams.feeType = SF_FEE_TYPE_SINGLE;
  elif( payParams.objectType == OBJTYPE_SFSINGDF )
    payParams.feeType = SF_FEE_TYPE_ONCE;
  elif( payParams.objectType == OBJTYPE_SFINVOICE )
    payParams.feeType = SF_FEE_TYPE_INVOICE;
  end;    

  if( payParams.ground == "" )
      payParams.ground = "Оплата комиссии " + sfcomiss.Code;
  end;  

  if( OutBuffer != null )
    if( SfPayCorrect(sfcomiss, payParams.payDate, payParams.ground, payParams.paySum, payParams.taxSum, 
                     payParams.FIID, payParams.primKind, payParams.primID, payParams.feeType, payParams.objectBuf,
                     payParams.payMethod, sidebet, sicredit, OutBuffer) )
      return 1;
    end;
  end;

  if( (not Sf_IsInstalledRKO()) OR (payParams.payMethod == SF_PAY_METHOD_DOCUMENT) )

    retval = SfFormDocuments( sidebet, sicredit, sfcomiss, payParams.payDate, payParams.paySum, payParams.taxSum, 
                              payParams.FIID, payParams.SfComPD, payParams.IsIncluded, payParams.isNVPI,
                              payParams.FacturaID, @bilfDocArray, payParams.objectType, payParams.objectBuf, oprchild.ID_Operation, oprchild.ID_Step );

  else
    retval = SfFormPayDoc( sidebet, sicredit, sfcomiss, payParams, sfinvlnk, SumInInvFIID,
                           isBatchMode, @bilfDocArray, oprchild );
  end;

  return retval;

end;

/*Универсальная функция формирования документов(   
  Из sfcontr берется 
    FIID    -- валюта сумм
    FIIDPayer
    AccountPayer
    payMethod)*/

macro SfFormDocs
(
  OutBuffer,   /* буфер для формирования выходного документа для Insert...Document */
  sidebet,
  sicredit,
  sfcomiss,    /* запись sfcomiss.dbt */
  payDate,     /* дата оплаты */
  ground,      /* основание   */
  paySum,      /* сумма в валюте FIID */
  taxSum,      /* НДС в валюте FIID   */
  FIID,
  primKind,    /* тип первички KIND_OF_DOC */
  primID,      /* ID первички */
  objectType,  /* вид объекта   */
  objectBuf,   /* объект */
  payMethod,
  SfComPD,     /* для единовременных и период объект класса SfConComPrimDoc, для разовых - SfSingDfPrimDoc */
  IsIncluded,
  isNVPI,
  FacturaID,
  bilfDocArray:@TArray,
  sfinvlnk,
  IsBatchMode, ID_Operation, ID_Step, ChildDocKind:@integer, ChildDocID:@string, PreAcptID
   
)
  var payParams = TSfPayParams;
  var stat = 0;

  payParams.payDate = payDate; 
  payParams.ground = ground; 
  payParams.paySum = paySum; 
  payParams.taxSum = taxSum; 
  payParams.FIID = FIID;
  payParams.primKind = primKind; 
  payParams.primID = primID; 
  payParams.objectType = objectType; 
  payParams.objectBuf = objectBuf; 
  payParams.payMethod = payMethod; 
  payParams.SfComPD = SfComPD; 
  payParams.IsIncluded = IsIncluded; 
  payParams.isNVPI = isNVPI; 
  payParams.FacturaID = FacturaID;
  payParams.PreAcptID = PreAcptID;

  if(PreAcptID != null)
    payParams.PreAcptID = PreAcptID
  end;

  var oprchild = TRecHandler("oprchild.tmp");
  ClearRecord( oprchild );
  if(ID_Operation != null)
    oprchild.rec.ID_Operation = ID_Operation;
    oprchild.rec.ID_Step      = ID_Step;     
  end;

  stat = SfFormDocsCommon( OutBuffer, sidebet, sicredit, sfcomiss, 
    payParams, sfinvlnk, null, @bilfDocArray, IsBatchMode, oprchild.rec );

  ChildDocKind = oprchild.rec.Child_DocKind   ;
  ChildDocID   = oprchild.rec.Child_DocumentID;

  return stat;
end;

macro SfInvFormDocs( OutBuffer, sidebet, sicredit, sfcomiss, payParams:TSfPayParams, sfinvlnk, SumInInvFIID, bilfDocArray:@TArray )

  var oprchild = TRecHandler("oprchild.tmp");
  ClearRecord( oprchild );
 
  return SfFormDocsCommon( OutBuffer, sidebet, sicredit, sfcomiss, 
    payParams, sfinvlnk, SumInInvFIID, @bilfDocArray, null, oprchild.rec );

end;

