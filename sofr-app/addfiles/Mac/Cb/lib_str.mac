import lib_lang;

/**
 *  Группа констант выравнивания. Используется в StrAlign.
 */
const STR_ALIGN_LEFT   = 1,
      STR_ALIGN_RIGHT  = 2,
      STR_ALIGN_CENTER = 3,
      STR_ALIGN_STD    = 4; // стандартное выравнивание, используется в CTableReport

/**
 *  Разбить строку по символам-разделителям.
 *  str - строка
 *  delim - список разделителей (каждый из 1 символа)
 *  Если delim не задан, ищутся разделители ",", ";" и " ".
 *  Возвращает массив строк.
 */
MACRO StrCut( str, delim, save_delim )
    DefaultParm(delim, ",; ");
    DefaultParm(save_delim, false);

    var arr = TArray, i = StrBrk( str, delim );

    while( i > 0 )
        if (save_delim)
          arr( arr.size ) = substr( str, 1, i );
          str = substr( str, i + 1 );
        else
          arr( arr.size ) = trim( substr( str, 1, i - 1 ) );
          str = trim( substr( str, i + 1 ) );
        end;
        i = StrBrk( str, delim );
    end;

    if( str != "" )
      if (save_delim)
        arr( arr.size ) = str;
      else
        arr( arr.size ) = trim( str );
      end;
    end;

    return arr;
END;

/**
 *  Собрать из массива строк строку, вставляя между частями разделитель.
 *  arr - массив строк.
 *  delim - разделитель.
 *  Если delim не задан, разделитель не вставляется, строки просто конкатенируются.
 *  Возвращает собранную строку. NULL'ы игнорируются.
 */
MACRO StrAssemble( arr, delim )
    if( delim == NULL )
        delim = "";
    end;
    var i = 0;
    var res = "";
    while( i < arr.size )
        if( arr[i] != NULL )
            if( res != "" )
                res = res + delim;
            end;
            res = res + arr[i];
        end;

        i = i + 1;
    end;
    return res;
END;

/**
 *  Обертка функции StrSplit с параметром TArray вместо Array
 */
MACRO StrSplitTArray( str, tArr, len )
    Array arr;
    var arrLen = StrSplit( str, Arr, len );
    var i = 0;

    while ( i <= arrLen )
        tArr[i] = arr(i);
        i = i + 1;
    end;
    return arrLen;
END;

/**
 *  Выравнивает строку str по ширине width с выравниванием align (по умолчанию STR_ALIGN_LEFT),
 *  заполняя fill'ом (по умолчанию " "). Если fill длиннее одного символа, берётся первый.
 *
 *  @version 1.1
 */
MACRO StrAlign(str, width, align, fill)

    // 12.07.2010 ABP В версии 1.1 убрал лишние вычисления, временами они отнимают непозволительно много времени.
    if ((str == NULL) or (width == NULL))
        RunError("|Ошибка программирования|Первые 2 параметра функции StrAlign - обязательные!");
    end;

    if (align == NULL)
        align = STR_ALIGN_LEFT;
    end;

    if (fill == NULL)
        fill = " ";
    end;

    var length = strlen(str);
    var length1;
    var left;
    var right;

    if (align == STR_ALIGN_RIGHT)
        return mkstr(fill, width - length) + str;
    elif (align == STR_ALIGN_CENTER)
        length1 = width - length;
        left = length1 / 2;
        right = length1 - left;
        return mkstr(fill, left) + str + mkstr(fill, right);
    else    // LEFT по умолчанию
        return str + mkstr(fill, width - length);
    end;

END;

/**
 * Возвращает спецификатор форматирования RSL по номеру формата для ф-ции strAlign()
 */
macro getFormatSpecifier(formatNumber)
    if (formatNumber == STR_ALIGN_RIGHT)
        return ":r";
    elif (formatNumber == STR_ALIGN_LEFT)
        return ":l";
    else
        return ":c";
    end;
end;

/**
 *  Перенос строки по словам в заданной ширине с заданным выравниванием,
 *  если слово не влезает в ширину, оно так же разбивается на части
 */
MACRO StrTransferByWord(str, width, align, fill)

  DefaultParm(width, strlen(str));
  DefaultParm(align, STR_ALIGN_LEFT);
  DefaultParm(fill, " ");

  str = strsubst(str, "\n", " ");

  var TempWordsArray = StrCut(str, NULL, true), WordsArray = TArray(20), SplittedWord;
  var ResultArray = TArray(10);
  var i, j, TempString;

  i = 0;
  while(i < TempWordsArray.Size)
    if (strlen(TempWordsArray[i]) > width)
      SplittedWord = StrSplit2(TempWordsArray[i], width);

      j = 0;
      while(j < SplittedWord.Size)
        WordsArray[WordsArray.Size] = SplittedWord[j];
        j = j+1;
      end;
    else
      WordsArray[WordsArray.Size] = TempWordsArray[i];
    end;

    i = i+1;
  end;

  i = 0;
  while(i < WordsArray.Size)
    TempString = "";

    while((i < WordsArray.Size) and ((strlen(TempString) + min(strlen(WordsArray[i]), strlen(trim(WordsArray[i])))) <= width))
      TempString = TempString + WordsArray[i];
      i = i+1;
    end;

    ResultArray[ResultArray.Size] = StrAlign(trim(TempString), width, align, fill);
  end;

  return ResultArray;
END;

/**
 *  Дополняет строку слева заданным символом
 */
macro strLpad(str, length, symbol)
    var i = strlen(str);

    while (i < length)
        str = symbol + str;
        i = i + 1;
    end;

    return str;
end;

/**
 *  Дополняет строку справа заданным символом
 */
macro strRpad(str, length, symbol)
    var i = strlen(str);

    while (i < length)
        str = str + symbol;
        i = i + 1;
    end;

    return str;
end;

/**
 * Аналог функции LTRIM в SQL
 */
macro strLtrim(Str : string, SymbSet : string) : string
  // из пустой строки нечего удалять
  if(not Str)
    return Str;
  end;

  // по умолчанию удаляем пробелы
  if(SymbSet == null)
    SymbSet = " ";
  end;

  while( index(SymbSet, substr(Str, 1, 1)) )
    Str = substr(Str, 2);
  end;

  return Str;
end;
