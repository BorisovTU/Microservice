 /*
 $Name: oralib.mac
 $Module: Ядро Банкинг
 $Description: Элементарные функции для выполнения SQL-команд

  # tag
  - functional_block: API_для_работы_с_БД
  - code_type: API 
  
  # changelog
  |date       |author         |tasks                                                   |note                                                        
  |-----------|---------------|--------------------------------------------------------|-------------------------------------------------------------
  |2024.09.06 |Дылгеров Ц.В.  |                                                        | Добавление функции execSQLarray, возвращающей массив значений. 
  |2023.12.18 |Велигжанин А.В.|DEF-58620                                               | Доработка DropTempProc(), удаление процедуры обернул для
  |           |               |                                                        | обработки exception
  |2023.11.01 |Сенников И.В.  |DEF-53361                                               | Добавление вспомогательного класса для запуска insert-ов 
  |           |               |                                                        | в фоне и с прогрессом

*/

/*----------------------------------------------------------------------------*/
/* Элементарные функции для выполнения SQL-команд                             */
/*----------------------------------------------------------------------------*/

import rsd, rsberror;

// параметр для параметризованного запроса
CLASS SQLParam( _name:string, _value:variant, _type:integer, _string_size : integer )
  var name :string  = _name, 
      value:variant = _value,
      type : integer,
      string_size : integer = _string_size;

  if( _type == NULL )
    _type = RSDBP_IN;
  end;
  type = _type;
END;

// получить строку ошибок RSD
MACRO getRSDErrorsString( cmd:RsdCommand ):string
  var i:integer = 0;
  var err_text:string = "";
  var delim:string="";

  if( cmd and cmd.connection and cmd.connection.environment )
    while( i < cmd.connection.environment.ErrorCount )
      err_text = err_text + delim + cmd.connection.environment.error(i).descr;
      i = i + 1;
      delim = "\n";
    end;
  end;
  return err_text;
END;

// добавление параметров в параметрический запрос
PRIVATE MACRO addParams( sqlcmd:RsdCommand, params:TArray )
  var i:integer = 0;
  var param:SQLParam = NULL;
  while( params AND (i < params.size) )
    param = params.value(i);
    sqlcmd.addParam( param.name, param.type, param.value, param.string_size );
    i = i + 1;
  end;
END;

// выполнить SQL-команду, не возвращающую record set
//   sqltext - текст команды
//   params  - параметры для параметризованного запроса (SQLParam)
//   throw   - возбуждать ли исключение (по умолчанию возбуждается)
// при успешном выполнении возвращает объект RsdCommand, иначе NULL или возбуждается исключение (по умолчанию)
MACRO execSQL( sqltext:string, params:TArray, throw:bool ):RsdCommand
  var cmd:RsdCommand = RsdCommand( sqltext );
  cmd.NullConversion = true;
  addParams( cmd, params );
  cmd.execute();

  if( cmd != NULL )
    var i : integer = 0;
    while( params AND (i < params.size) )
      if( (params.value(i).type == RSDBP_OUT) or (params.value(i).type == RSDBP_IN_OUT) )
        params.value(i).value = cmd.value(i);
      end;

      i = i + 1;
    end;
  end;

  return cmd;
ONERROR(x)
  if( (throw==NULL) OR throw )
    RsbThrow( getRSDErrorsString( cmd ) );
  else
    return NULL;
  end;
END;

// выполнить SQL-команду, возвращающую record set
//   sqltext     - текст команды
//   params      - параметры для параметризованного запроса (SQLParam)
//   throw       - возбуждать ли исключение (по умолчанию возбуждается)
//   crsLocation - местоположение курсора (RSDVAL_SERVER, RSDVAL_CLIENT, RSDVAL_CLIENT_IF_NEEDED)
//   crsType     - тип курсора (RSDVAL_STATIC, RSDVAL_DYNAMIC, RSDVAL_FORVARD_ONLY, RSDVAL_KEYSET_DRIVEN)
// при успешном выполнении возвращает объект RsdRecordset, иначе NULL или возбуждается исключение (по умолчанию)
MACRO execSQLselect( sqltext:string, params:TArray, throw:bool, crsLocation:integer, crsType:integer ):RsdRecordset
  var cmd:RsdCommand = RsdCommand( sqltext );
  cmd.NullConversion = true;
  addParams( cmd, params );
  cmd.execute();
  var rs:RsdRecordset = RsdRecordset( cmd, crsLocation, crsType );
  rs.open();
  return rs;
ONERROR(x)
  if( (throw==NULL) OR throw )
    RsbThrow( getRSDErrorsString( cmd ) );
  else
    return NULL;
  end;
END;

// выполнить SQL-процедуру
//   procname    - имя процедуры
//   retvaltype  - возвращаемое значение процедуры (V_UNDEF если ничего не возращает)
//   params      - параметры для параметризованного запроса (SQLParam)
// при успешном выполнении возвращает NULL (или значение, возвращаемое процедурой), иначе возбуждается исключение (по умолчанию)
// в params для рараметров RSDBP_OUT в value вернутся значения
MACRO execStoredFunc( procname:string, retvaltype:integer, params:TArray ):variant
  var sqltext = "";
  var i:integer = 0;
  var param:TArray = TArray(), sqlp:SQLParam = NULL;
  
  if( retvaltype != V_UNDEF )
    sqltext = "? := "
  end;
  sqltext = "begin " + sqltext + procname + "(";

  while( params AND (i < params.size) )
    sqltext = sqltext + "?";
    if( ((i+1) < params.size) )
      sqltext = sqltext + ", ";
    end;
    i = i + 1;
  end;
  sqltext = sqltext + "); end;";

  if( retvaltype != V_UNDEF )
    param.value(param.size) = SQLParam("retval", retvaltype, RSDBP_RETVAL);
  end;

  i = 0;
  while( params AND (i < params.size) )
    param.value(param.size) = params.value(i);
    i = i + 1;
  end;

  var cmd:RsdCommand = execSQL( sqltext, param, true );

  if( cmd != NULL )
    i = 0;
    while( params AND (i < params.size) )
      if( (params.value(i).type == RSDBP_OUT) or (params.value(i).type == RSDBP_IN_OUT) )
        if( retvaltype != V_UNDEF )
          params.value(i).value = cmd.value(i+1);
        else
          params.value(i).value = cmd.value(i);
        end;
      end;
      i = i + 1;
    end;

    if( retvaltype != V_UNDEF )
      return cmd.value(0);
    else
      return NULL;
    end;
  else
    return NULL;
  end;
END;

/* аналог ExecSql, но со списком параметров запроса через запятую в аргументах функции
   и с выключенным NullConversion

  Поскольку скоро всё равно будет переход с оракла на постгре и этот макрос постепенно 
  будет терять свою актуальность, то просто сделаю копи-паст с нужными мне небольшими изменениями
  и не буду заморачиваться с правильностью и чистотой кода
*/
macro ExecSqlWithParams(sqltext): RsdRecordset
  var params = null;
  var SQLParmCount : integer = ParmCount() - 1;
  var i:integer;
  if( SQLParmCount > 0 )
    params = TArray( SQLParmCount, SQLParmCount );
    var parm;
    i = 1;
    while( GetParm(i, parm) )
      params[ params.size ] = sqlparam("",parm);
      i = i + 1;
    end;
  end;

  var cmd:RsdCommand = RsdCommand( sqltext );
  cmd.NullConversion = false;
  addParams( cmd, params );
  cmd.execute();

  //todo: код ниже бесполезен, т.к. массив params недоступен
  //за пределами функции. При необходимости вернусь сюда,
  //чтобы подумать, как можно сделать иначе
  if( cmd != NULL )
    i = 0;
    while( params AND (i < params.size) )
      if( (params.value(i).type == RSDBP_OUT) or (params.value(i).type == RSDBP_IN_OUT) )
        params.value(i).value = cmd.value(i);
      end;

      i = i + 1;
    end;
  end;

  return cmd;
ONERROR(x)
  RsbThrow( getRSDErrorsString( cmd ) );
end;

/* аналог ExecSqlSelect, но со списком параметров запроса через запятую в аргументах функции
   и с выключенным NullConversion

  Поскольку скоро всё равно будет переход с оракла на постгре и этот макрос постепенно 
  будет терять свою актуальность, то просто сделаю копи-паст с нужными мне небольшими изменениями
  и не буду заморачиваться с правильностью и чистотой кода
*/
macro ExecSqlSelectWithParams(sqltext):RsdRecordset
  var params = null;
  var SQLParmCount : integer = ParmCount() - 1;
  var i:integer;
  if( SQLParmCount > 0 )
    params = TArray( SQLParmCount, SQLParmCount );
    var parm;
    i = 1;
    while( GetParm(i, parm) )
      params[ params.size ] = sqlparam("",parm);
      i = i + 1;
    end;
  end;

  var cmd:RsdCommand = RsdCommand( sqltext );
  cmd.NullConversion = false;
  addParams( cmd, params );
  cmd.execute();

  var rs:RsdRecordset = RsdRecordset(cmd);
  rs.open();
  return rs;
ONERROR(x)
  RsbThrow( getRSDErrorsString( cmd ) );
end;

// преобразовать дату из SQL-формата в RSL-формат
MACRO sqlDate2date( sqlDate:variant ):date
  var dt:date;
  DtTmSplit( sqlDate, dt );
  if(dt == NULL)
    dt = date(0,0,0);
  end;
  return dt;
END;

// Проверить существование выборки
//   sqltext - текст команды
//   params  - параметры для параметризованного запроса (SQLParam)
MACRO existsSQLselect( sqltext:string, params:TArray ):bool
  var rs:RsdRecordset = execSQLselect( string( "select 1 from dual where exists ( ", sqltext, " )" ),
                                       params, false );
  return ( rs and rs.moveNext() );
END;

// Базовый класс для удобного чтения выборки
// Имена полей у наследника должны соответствовать названиям полей выборки за исключением "t_"
CLASS TRsdRecordReader
  /* Чтение данных из RSD-выборки */
  macro Read( rs:RsdRecordset )
    var i:integer = 0,
        count:integer = rs.FldCount,
        fld:RsdField;
    while( i < count )
      fld = rs.Fld(i);
      GenSetProp( this, SubStr( fld.Name, 3 ), fld.Value );
      i = i + 1;
    end;
  end;
END;

MACRO execSQLselectPrm( sqltext:string ) : RsdRecordset
  var params = null;

  var SQLParmCount : integer = ParmCount() - 1;
  if( SQLParmCount > 0 )
    params = TArray( SQLParmCount, SQLParmCount );

    var parm : SQLParam, i:integer = 1;
    while( GetParm(i, parm) )
      params[ params.size ] = parm;
      i = i + 1;
    end;
  end;

  return execSQLselect(sqltext, params);
END;

/**
  @brief  - execSQLarray - возвращает массив полей первой найденной строки
  @param  - параметры передаются фактически, по аналогии с execSQLselectPrm  
  @return - массив полей. Если ничего не найдено, то вернется пустой массив 
  Example:
    var itog = execSQLselectPrmArray("select 1,2,'test',null from dual where 1=1 and :1=1 and :2='1'",1,"1",null);
    for (var i:integer, 0, itog.size-1)
      println(itog[i]);
    end;
*/

macro execSQLarray(sqltext)
  var result = tarray;
  var params = null;
  var SQLParmCount : integer = ParmCount() - 1;
  if( SQLParmCount > 0 )
    params = TArray( SQLParmCount, SQLParmCount );
    var parm, i:integer = 1;
    while( GetParm(i, parm) )
      params[ params.size ] = sqlparam("",parm);
      i = i + 1;
    end;
  end;
  var rs=execSQLselect(sqltext, params);
  if(rs.movenext)
    for(var j:integer,0,rs.fldcount-1)
      result[result.size] = rs.value(j);
    end; 
  end;
  return result;  
end;

/*  параметры, переданные в функцию, оборачиваются в SqlParam и возвращаются массивом.
    пример:
    var result = MakeSqlParamsArray(1, 2, 3);

    в переменной result будет:
    result(result.size()) = SqlParam("", 1);
    result(result.size()) = SqlParam("", 2);
    result(result.size()) = SqlParam("", 3);
*/
macro MakeSqlParamsArray() //params...
  var params = null;
  var paramsCount:integer = ParmCount();
  if( paramsCount > 0 )
    params = TArray(paramsCount, paramsCount);
    var parm, i:integer = 0;
    while( GetParm(i, parm) )
      params[params.size] = SqlParam("", parm);
      i = i + 1;
    end;
  end;
  
  return params;
end;

/**
  @brief  - execSQLselectPrmDyn - возвращает Recordset, как execSQLselectPrm, но параметры передаются динамически
  @param  - параметры передаются фактически, по аналогии с execSQLselectPrm  
  @return - Recordset
*/
macro execSQLselectPrmDyn(sqltext): RsdRecordset
  var params = null;
  var SQLParmCount : integer = ParmCount() - 1;
  if( SQLParmCount > 0 )
    params = TArray( SQLParmCount, SQLParmCount );
    var parm, i:integer = 1;
    while( GetParm(i, parm) )
      params[ params.size ] = sqlparam("",parm);
      i = i + 1;
    end;
  end;
  return execSQLselect(sqltext, params);
end;


// выполнить SQL-команду, не возвращающую record set в отдельном соединении
//   sqltext - текст команды
//   con - объект соединения
//   params  - параметры для параметризованного запроса (SQLParam)
//   throw   - возбуждать ли исключение (по умолчанию возбуждается)
// при успешном выполнении возвращает объект RsdCommand, иначе NULL или возбуждается исключение (по умолчанию)
MACRO execSQLSepCon( sqltext:string, con:RsdConnection, params:TArray, throw:bool ):RsdCommand
  var cmd:RsdCommand = RsdCommand(con, sqltext );
  cmd.NullConversion = true;
  addParams( cmd, params );
  cmd.execute();

  if( cmd != NULL )
    var i : integer = 0;
    while( params AND (i < params.size) )
      if( (params.value(i).type == RSDBP_OUT) or (params.value(i).type == RSDBP_IN_OUT) )
        params.value(i).value = cmd.value(i);
      end;

      i = i + 1;
    end;
  end;

  return cmd;
ONERROR(x)
  if( (throw==NULL) OR throw )
    RsbThrow( getRSDErrorsString( cmd ) );
  else
    return NULL;
  end;
END;

// выполнить SQL-команду, возвращающую record set в отдельном соединении
//   sqltext     - текст команды
//   params      - параметры для параметризованного запроса (SQLParam)
//   throw       - возбуждать ли исключение (по умолчанию возбуждается)
//   crsLocation - местоположение курсора (RSDVAL_SERVER, RSDVAL_CLIENT, RSDVAL_CLIENT_IF_NEEDED)
//   crsType     - тип курсора (RSDVAL_STATIC, RSDVAL_DYNAMIC, RSDVAL_FORVARD_ONLY, RSDVAL_KEYSET_DRIVEN)
// при успешном выполнении возвращает объект RsdRecordset, иначе NULL или возбуждается исключение (по умолчанию)
MACRO execSQLselectSepCon( sqltext:string, con:RsdConnection, params:TArray, throw:bool, crsLocation:integer, crsType:integer ):RsdRecordset
  var cmd:RsdCommand = RsdCommand(con, sqltext );
  cmd.NullConversion = true;
  addParams( cmd, params );
  cmd.execute();
  var rs:RsdRecordset = RsdRecordset( cmd, crsLocation, crsType );
  rs.open();
  return rs;
ONERROR(x)
  if( (throw==NULL) OR throw )
    RsbThrow( getRSDErrorsString( cmd ) );
  else
    return NULL;
  end;
END;

/**
  @brief - Получение ID сессии в БД
  @return ID сессии
*/
macro GetDBSessionID ()
  var rs = ExecSQLSelect("select RSB_DLUTILS.GETSESSIONID as t_sessionid from dual");
  if (rs.MoveNext())
    return numeric(rs.value("t_sessionid"));
  end;
  return numeric(-1);
end;

/**
@brief Класс выполнения SQL (как правило insert-ов) в фоне и с выводом прогресс бара исполнения
@param[in] SqlScript - Непараметризированный текст запроса

Информация о прогрессе вытягивается из v$session_longops,
поэтому если запрос делает сканирования, hash_join, сортировки и т.п.
то по таким операция нарисуется прогресс бар

Но нужно иметь ввиду, что на сервере БД должен быть включен шедулер
Иначе класс не заработает
*/
class BackgroundSQLExecuter(SqlScript:string)

  /**
    @brief - Получить id процесса из последовательности
    @return void
  */
  private macro GetUniqBgProcId()
    var ds = ExecSQLSelect("select BGEXECUTER_SEQ.NEXTVAL as t_nextval from dual");
    if (ds.movenext())
       return string(ds.value("t_nextval"):0:0);
    end;
    return -1
  end;

  private var m_sql = SqlScript;
  private var m_procId = GetUniqBgProcId();

  /**
    @brief - Удалить временную процедуру с запросом к исполнению
    @return void
  */
  private macro DropTempProc()
    var sql = "BEGIN "
             +"   BEGIN "
             +"      execute immediate 'DROP PROCEDURE BGSQLExecuter_PROC_"+m_procId+"'; "
             +"   EXCEPTION "
             +"      WHEN OTHERS "
             +"      THEN "
             +"         NULL; "
             +"   END; " 
             +"END; ";
    execSQL(sql);
  OnError(err)
  end;

  /**
    @brief - Создать временную процедуру с запросом к исполнению
    @return void
  */
  private macro CreateTempProc()
    var sql =
      " CREATE OR REPLACE PROCEDURE BGSQLExecuter_PROC_"+m_procId
     +" AS "
     +" BEGIN "
     + m_sql + "; "
     +" END BGSQLExecuter_PROC_"+m_procId+"; ";
    execSQL(sql);
  end;

  /**
    @brief  - Удалить задание ораклового шедулера (с остановкой выполнения)
    @return void
  */
  private macro DropBGProcByScheduler()
    var sql = "BEGIN "
             +"   BEGIN "
             +"      DBMS_SCHEDULER.drop_job ('RUN_SQLBG_"+m_procId+"', TRUE); "
             +"   EXCEPTION "
             +"      WHEN OTHERS "
             +"      THEN "
             +"         NULL; "
             +"   END; " 
             +"END; ";
    execSQL(sql);
    DropTempProc();
  end;

  /**
    @brief  - Запустить задания ораклового шедулера
    @return void
  */
  private macro RunBGProcByScheduler()
    DropBGProcByScheduler();
    CreateTempProc();
    var sql = "DECLARE "
             +"   v_job1     VARCHAR2(20) := 'RUN_SQLBG_"+m_procId+"';"
             +"BEGIN "
             +"   DBMS_SCHEDULER.create_job (job_name => v_job1, job_type => 'PLSQL_BLOCK', job_action => 'BGSQLExecuter_PROC_"+m_procId+";'); "
             +"   DBMS_SCHEDULER.run_job (v_job1, FALSE); "
             +"END; " ;
    execSQL(sql);
  OnError(err)
    DropBGProcByScheduler();
    RunError(err);
  end;

  /**
    @brief  - Ожидание выполнения задания ораклового шедулера
    @param[in] InitMsg - текст сообщения ожидания (необязательный параметр)
    @return void
  */
  private macro WaitingExecute(InitMsg)
    var flag = true, ds, sqlId = "", curSqlId = "";
    var msg = "Выполнение длительного SQL";
    if ((ValType(InitMsg) == V_STRING) and (Trim(InitMsg) != ""))
      msg = InitMsg;
    end;
    EndAction();
    RslWait(1000);
    BegAction(2000, msg, false);
    RslWait(3000);
    while (flag)
      ds = null;
      ds = ExecSQLSelect(" select 1 from user_scheduler_jobs where job_name = 'RUN_SQLBG_"+m_procId+"' and state in ( 'RUNNING', 'SCHEDULED')");
      if (not ds.movenext())
         //Если наш джоб завершил работу, то вываливаемся
         flag = false;
      end;
      ds = null;
      ds = ExecSQLSelect(
          "   SELECT OPNAME, TARGET, SOFAR, TOTALWORK, CAST(SQL_ADDRESS as varchar2(30)) as SQL_ADDRESS"
         +"     FROM v$session_longops "
         +"    WHERE sid = "
         +"             NVL ( "
         +"                (SELECT SID "
         +"                   FROM v$session "
         +"                  WHERE MODULE = 'DBMS_SCHEDULER' AND ACTION = 'RUN_SQLBG_"+m_procId+"'), "
         +"                -1) "
         +"      and TOTALWORK <> SOFAR "
         +" ORDER BY start_time DESC "
         +" FETCH NEXT 1 ROWS ONLY "
      ); 
      if (ds.movenext())
        curSqlId = String(ds.value("SQL_ADDRESS"));
        if ((sqlId != curSqlId) and (sqlId != ""))
          RemProgress();
        end;
        if (sqlId != curSqlId)
          if (sqlId == "")
            EndAction();
          end;
          var targ = String(ds.value("TARGET"));
          if ((ValType(ds.value("TARGET")) == 26) or (Trim(targ) == ""))
            targ = "---";
          end;
          InitProgress(Int(ds.value("TOTALWORK")),
                       "Цель: "+targ+". Имя операции: "+String(ds.value("OPNAME"))+".",
                       "Выполнение длительного SQL");
          sqlId = curSqlId;
        end;
        if (sqlId != "")
          UseProgress(Int(ds.value("SOFAR")));
        end;
      else
        if (sqlId != "")
          sqlId = "";
          RemProgress();
          BegAction(2000, msg, false);
        end;
      end;
      RslWait(1000);
    end;
    if (sqlId == "")
      EndAction();
    else
      RemProgress();
    end;
    //добавлен возврат ошибки от прикладной функции
    ds = ExecSQLSelect(
        " SELECT det.STATUS, det.ERRORS "
       +"   FROM dba_scheduler_job_run_details det "
       +"  WHERE det.job_name = 'RUN_SQLBG_"+m_procId+"' "
       +" FETCH NEXT 1 ROWS ONLY "
    ); 
    if (ds.movenext() and (ds.value("STATUS") != "SUCCEEDED"))
      //бросаем ошибку если статус не "успешно"
      RunError(ds.value("ERRORS"));
    end;
    DropBGProcByScheduler();
  OnError(err)
    DropBGProcByScheduler();
    RunError(err);
  end;


  /**
    @brief  - Запуск sql скрипта переданного в конструкторе на исполнение
    @param[in] msg - текст сообщения ожидания (необязательный параметр)
    @return void
  */
  macro Run(msg)
    RunBGProcByScheduler();
    WaitingExecute(msg);
  end;

  macro Destructor()
    DropBGProcByScheduler();
  end;

end;