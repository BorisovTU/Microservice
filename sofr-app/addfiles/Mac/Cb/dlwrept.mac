/*
$Name:        dlwrept.mac
$Module:      ag
$Description: Печать отчета Word-ом на терминале.
*/
/* ───────────────────────────────────────────────────────────────────────────┐
    RS-Bank                                        R-Style Software Lab Ltd
    Файл подсистемы "Векселя"

    Печать отчета Word-ом на терминале.

    SRR 24.04.2001
    IR 21.10.02   перенес из векселей
└─────────────────────────────────────────────────────────────────────────── */
IMPORT rslx, dlreptl;
Import "or_exl_h.mac";
Import "or_tools.mac";
import "jvmutils.mac";

PRIVATE FILE tags () txt;
PRIVATE VAR WordApp: object = null;
private var _CountFiles = 0; /*счетчик попыток сформировать имя документа*/
private var _MaxCountFiles = 1000; /*максимальное количество попыток формирования имени документа*/

private const wdColorBlack = 0;
private const wdColorRed   = 255;
private var   _FontColor = wdColorBlack; // цвет вставляемого текста

class POIDLWREPT()
   private var jvm          :object = NULL;
   private var reportCreator:object = NULL;
   private var document:object = NULL;
   private var formatRep = WINREP_FORMAT_DOC;
   private var convertToPdf:bool = false;
   private var convertToHtml:bool = false;
   private var fileNamePdf:string  = "";
   private var fileNameHtml:string = "";
 
   var saveDocumentPath:string = "";

   macro GetJvm()
      if( jvm == null )
          jvm = CreateObject ("rsjvm", "TJavaHost", "GlobalJavaHost");
      end;

      return jvm;

      OnError( e )
          RunError("JVM init error", WR_GetJavaExceptionText(e));
   end;

   macro GetReportCreator()             
      if( reportCreator == NULL )                
          reportCreator = GetJvm().callStaticMethod("ru.softlab.rsbank.poireports.ReportCreator", "getInstance")
      end;

      return reportCreator;

      OnError( e )
          RunError("ReportCreator getInstance error", WR_GetJavaExceptionText(e));

   end;

   macro OpenDocument( FileName:string ):bool
      var FullFileName = DLREPTL_GetFullDotFileName(FileName);
      if( not existFile( FullFileName ) )
          msgbox( "Не найден файл-шаблон ", FullFileName, ".|Проверьте правильность пути" );
          return false;
      end;
      document = reportCreator.openDocument(FullFileName);
      if( document )
          formatRep = GetTemplateFileFormat(FileName);
          return true;
      end;

      return false;

      OnError( e )
          RunError("OpenDocument error", "Ошибка открытия файла-шаблона " + FullFileName);
          return false;
   end;

   private macro GetWorkDirName():string
      var DirName:string = "", 
          StrErr :string = ""; 

      GetRegistryValue( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR", V_STRING, DirName, StrErr );
      if( not DirName )
          DirName = GetIniString( "TEXTDIR" );
      end;
   
      if( not DirName )
          DirName = GetEnv("TEMP");
          if( not DirName )
              DirName = GetEnv("TMP");
          end;
      else
          if( SubStr(DirName, 1, 1) == "." )
              DirName = GetCurDir(FALSE) + "\\" + DirName;
          end;
      end;

      return DirName;
   end;

   macro SetConvertToPdf( __FileNamePdf:string )
       if( ValType(__FileNamePdf) )
           FileNamePdf = __FileNamePdf;
           convertToPdf = true;
       end;   
   end;

   macro SetConvertToHtml( __FileNameHtml:string )
       if( ValType(__FileNameHtml) )
           FileNameHtml = __FileNameHtml;
           convertToHtml = true;
       end;   
   end;


   //Param FileName is obsolete
   macro SaveDocument( FileName, SaveDocTwice, ShowDoc ):bool
      var ReportFileName:string = "";
      var ReportFileNameExt:string = "";
      
      var DocumentTerm:string = "";
      var DocumentName:string = "";
      var DocumentPath:string = "";

      var stat:bool = true;

      if (not (ValType(SaveDocTwice) == V_BOOL))
          SaveDocTwice = True;
      end;
      if (not (ValType(ShowDoc) == V_BOOL))
          ShowDoc = True;
      end;

      if( formatRep == WINREP_FORMAT_DOCX )
          ReportFileNameExt = "docx";
      else
          ReportFileNameExt = "doc";
      end;

      ReportFileName = GetWorkDirName() + "\\" + JavaGetGuidExlusiveFileName(GetJvm(), ReportFileNameExt);

      if( NOT Check_SaveAs(@ReportFileName) )
          return false;
      end;

      stat = document.saveAs(ReportFileName); 
     
      if( stat )
          var filePath, name, ext;
          if( convertToPdf )
              SplitFile(fileNamePdf, name, ext);

              filePath = GetWorkDirName() + "\\" + name + ext;

              reportCreator.exportToPdf(document.getDocumentPath() + "\\" + document.getDocumentName(), filePath);
          end;

          if( convertToHtml )
              SplitFile(fileNameHtml, name, ext);

              filePath = GetWorkDirName() + "\\" + name + ext;
              reportCreator.exportToHtml(document.getDocumentPath() + "\\" + document.getDocumentName(), filePath);
          end;

          if( NOT isStandalone() )
              if( Index(toAnsi(NameDirTerm), ":") OR Index(toAnsi(NameDirTerm), "\\\\") )
                  DocumentTerm = SubStr(toAnsi(NameDirTerm), 2);
              else
                  DocumentTerm = GetCurDir(true)+"\\"+SubStr(toAnsi(NameDirTerm), 2);
              end;

              MakeDir(toAnsi(NameDirTerm)); 

              DocumentName = document.getDocumentName();
                    
              if( OR_ExistFile(DocumentTerm + DocumentName) )
                  DocumentName = GetUniqAdd(document.getDocumentName());
              end;                          

              if( NOT CopyFile(toANSI(document.getDocumentPath() + "\\" + document.getDocumentName()), "$" + toANSI(DocumentTerm + DocumentName)))
                  DocumentName = GetUniqAdd(DocumentName);
                  if( NOT CopyFile(toANSI(document.getDocumentPath() + "\\" + document.getDocumentName()), "$" + toANSI(DocumentTerm + DocumentName)) )
                      MsgBox( "Ошибка при передаче файла <" + toAnsi(document.getDocumentName()) + "> на терминал.|Из|<"+ toAnsi(document.getDocumentPath()) + ">|в|<"+toAnsi(DocumentTerm) + ">" );
                      return false;
                  end;
              end; 
                        
              DocumentPath = "$" + DocumentTerm + DocumentName;
          else
              DocumentPath = document.getDocumentPath() + "\\" + document.getDocumentName();
          end;
          
          this.saveDocumentPath = document.getDocumentPath() + "\\" + document.getDocumentName();

          if(ShowDoc)
              stat = StartShellProgram(DocumentPath); 
          end;

          if( stat AND (NOT isStandalone()) AND (NOT SaveDocTwice) )
              if( ExistFile(toANSI(document.getDocumentPath() + "\\" + document.getDocumentName())))
                  RemoveFile(toANSI(document.getDocumentPath() + "\\" + document.getDocumentName()));
              end;
          end; 
      end;

      return stat;

      OnError( e )
          RunError("SaveDocument error", "Ошибка сохранения файла " + ReportFileName);
          return false;

   end;

   macro GetDocument()
      if (document != NULL)
         return document;
      end;
      return NULL;
   end;

   reportCreator = GetReportCreator();
end;

// 
/* Открыть документ по шаблону. Вернет открытый документ */
PRIVATE MACRO OpenWordDocumentByDot( DotFileName, isRsAxServer )
var
    FullDotFileName, WordDoc;
    if (ValType(isRsAxServer) == V_UNDEF)
      isRsAxServer = false;
    end;
    
    if (isRsAxServer)
      WordApp = CreateObject("rsax", "TRsAxServer", "RsAxServer", true).CreateComObject("Word.Application", false);
    else
      WordApp = ActiveX("Word.Application", null, TRUE)
    end;
    
    if (WordApp == null) 
        return null;
    end;

    FullDotFileName = DLREPTL_GetFullDotFileName (DotFileName);

    /* Проверить, можно ли найти шаблон документа по указанному пути */
    if( not existFile ( FullDotFileName ) )
       msgbox( "Не найден файл-шаблон ", FullDotFileName, ".|Проверьте правильность пути" );
       return null;
    end;
   
    WordDoc = WordApp.Documents.Add( FullDotFileName, FALSE );
   
    if( WordDoc == null )
       msgbox( "Ошибка открытия файла-шаблона ", FullDotFileName );
       WordApp.Quit;
       return null;
    end;

    return WordDoc;
end;

/* Открыть ворд. Вставить пустой документ */
PRIVATE MACRO OpenWordDocumentAdd()
var
    FullDotFileName, WordDoc;

    if ((WordApp = ActiveX("Word.Application", null, TRUE)) == null) 
        return null;
    end;

    WordDoc = WordApp.Documents.Add;
   
    if( WordDoc == null )
       msgbox("Ошибка создания документа");
       WordApp.Quit;
       return null;
    end;

    return WordDoc;
end;

/* Увеличение числа, которым заканчивается строка, на j
      Вход: xxxx123, 5. Результат: xxxx128.
*/
PRIVATE MACRO IncTail(str, j)
var
   i = 0, ch, l, stop = false;

   if(ValType(j) != V_INTEGER)
     j = INT(j);
   end;

   if(j == 0)
      return str;
   end;

   if(ValType(str) != V_STRING)
     str = String(str);
   end;

   if((l = strlen(str)) == 0)
      return String(j);
   end;

   while(not stop)
      if(i == l)
         return String(INT(str) + j);
      else
         ch = Substr(str, l - i, 1);  /* рассматриваем строку с конца */
         if(ch == "0")
           i = i + 1;
         elif(INT(ch) != 0)
           i = i + 1;
         else
           stop = true;
         end;
      end;
   end;                                     

   if(i == 0)
     return String(str, j);
   else
     return String(Substr(str, 1, l-i), INT(Substr(str, l-i+1, i)) + j);
   end;

END;

/* Определяет имя новой закладки.
   Если name содержит подстроку "_dup_" и перед ней стоит число,
   то увеличивает его на 1. 
     Например name = "Test5_dup_7", результат работы функции "Test6_dup_7"

   Если перед подстрокой "_dup_" не число, то увеличивает на 1 число 
   стоящее в конце строки.
     Например name = "Test_dup_7", результат работы функции "Test_dup_8"
*/
PRIVATE MACRO ОпредИмяНовЗакл( name, i )
var p, l = strlen(name), head, ch;

  if((p = Index(StrLwr(name), "_dup_")) > 0)
    /* k = цифра найденная перед подстрокой "_dup_" */
    ch = SubStr(name, p-1, 1);
    head = SubStr(name, 1, p-1);
    if((ch == "0") OR (INT(ch) > 0))  /* если найденный символ является числом */
      return String(IncTail(head, i), Substr(name, p, l-p+1));
    end
  end;

  return IncTail(name, i);

END;

/*Удаляет таблицу на которую навешена указанная закладка
  str имеет вид "ИмяЗакладки\n"*/

PRIVATE MACRO DeleteTable(wd, str)
var table,                  /*таблицы*/
    bm = "",                /*наименование закладки*/
    NumBM:integer,          /*Количество закладок*/
    p:integer,
    i:integer;

    bm = str; /*закладка*/
    /*перебираем закладки */
    NumBM = wd.Bookmarks.Count;    /* кол-во закладок в документе */
    i = 0;
    while (i < NumBM)
      if(bm == wd.Bookmarks(i+1).name) /*если нашли нужную закладку*/
        wd.Bookmarks(i+1).Range.Tables(1).Delete;
        return;
      end;
      i = i + 1;
    end;
END;

PRIVATE MACRO PoiDeleteTable(document:object, bookmarkName:string)
    document.deleteTable(bookmarkName);

    OnError( e )
        RunError("PoiDeleteTable", "Ошибка удаления таблицы  " + bookmarkName);
END;


private macro КоординатыУдаляемыхСтрок(i_a:@integer, i_b:@integer, str)
    var p = StrBrk(str, "\n");  // конец первой строки 
   
    i_a = Int(SubStr(str, 1));  
    // вторая строка 
    str = Substr(str, p + 1);
    i_b = Int(SubStr(str, 1));
end;

// Удалить строки
/* Формат вызова:
~DeleteRows
1     - номер таблицы
%
8  - координаты первой строки
9  - координаты последней строки
*/
private macro DeleteRows( wd, str )
var p,
    tabno,          /* номер таблицы */
    n_str_a=0,      // координаты 1 строки
    n_str_b=0,      // координаты последней строки
    table, 
    CountDeleteRows = 0, // кол-во раз удалить
    tmpstr = "";
  
   p = Index(str, "\n");          /*первый разделитель (разделяет номер таблицы и символ '%')*/
   tabno = Int(Substr(str, 1, p - 1)); /*номер таблицы*/
   tmpstr = Substr(str, p + 1); 
   if(SubStr(Trim(tmpstr), 1, 1) != "%")
      // ошибка
      return;
   else
      p = Index(tmpstr, "\n");
      tmpstr = Substr(tmpstr, p + 1); 
   end;        

   if((tabno < 0) or (tabno > wd.Tables.Count))
      /* неверный индекс таблицы */
      return;
   end;

   /*Table = wd.Tables(tabno);
   КоординатыУдаляемыхСтрок(@n_str_a, @n_str_b, tmpstr);
   if((n_str_a == 0) or (n_str_b == 0))
      // ничего нет - ошибка
      return;
   else
       while(n_str_b >= n_str_a)
         table.Rows(n_str_b).Delete;
         n_str_b = n_str_b - 1;
       end;
   end; */
   end;

private macro PoiDeleteRows( document:object, tagStr:string )
   var p;
   var tableIndex;        // номер таблицы 
   var firstRow = 0;      // координаты 1 строки
   var lastRow  = 0;      // координаты последней строки
   var tmpStr   = "";
  
   p          = Index(tagStr, "\n");             // первый разделитель (разделяет номер таблицы и символ '%')
   tableIndex = Int( Substr(tagStr, 1, p - 1) ); // номер таблицы
   tmpStr     = Substr(tagStr, p + 1); 

   if( SubStr( Trim(tmpStr), 1, 1 ) != "%" )
       // ошибка
       return;
   else
       p = Index(tmpStr, "\n");
       tmpStr = Substr(tmpStr, p + 1); 
   end;        

   if( tableIndex < 0 )
       // неверный индекс таблицы 
       return;
   end;

   КоординатыУдаляемыхСтрок( @firstRow, @lastRow, tmpStr );

   if( (firstRow == 0) or (lastRow == 0) )
      // ничего нет - ошибка
      return;
   end;
 
   document.removeRowByIndex( tableIndex - 1, firstRow - 1 , lastRow - 1 );       

   OnError( e )
        RunError("PoiDeleteRows", "Ошибка удаления строк");   
end;

private macro КоординатыОбъединяемыхЯчеек(i_a:@integer, j_a:@integer, i_b:@integer, j_b:@integer, str)
var 
    p = StrBrk(str, ","),
    q = StrBrk(str, "\n");  // конец первой строки (координат 1 ячейки)

    i_a = Int(SubStr(str, 1, p - 1));  
    j_a = Int(SubStr(str, p + 1, q));

    // вторая строка (координаты последней ячейки)
    str = Substr(str, q + 1);

    p = StrBrk(str, ",");
    i_b = Int(SubStr(str, 1, p - 1)); 
    j_b = Int(SubStr(str, p + 1));    
end;

// Объединить ячейки 
/* Формат вызова:
~MergeCells
1     - номер таблицы
%
0     - текст оставлять/1 - текст затирать
8,1   - координаты первой ячейки
11,1  - координаты последней ячейки
*/
private macro MergeCells( wd, str )
var p,
    tabno,                     /* номер таблицы */
    n_str_a=0, n_coll_a=0,     // координаты 1 ячейки
    n_str_b=0, n_coll_b=0,     // координаты последней ячейки
    flagMergeRows,
    flagTextNull = 1,       // затирать текст "ненужных" ячеек
    table, 
    CountMerge = 0, // кол-во раз объединить
    tmpstr = "";
  
   p = Index(str, "\n");          /*первый разделитель (разделяет номер таблицы и символ '%')*/
   tabno = Int(Substr(str, 1, p - 1)); /*номер таблицы*/
   tmpstr = Substr(str, p + 1); 
   if(SubStr(Trim(tmpstr), 1, 1) != "%")
      // ошибка
      return;
   else
      p = Index(tmpstr, "\n");
      tmpstr = Substr(tmpstr, p + 1); 

      flagTextNull = Substr(tmpstr, 1, 1);
      p = Index(tmpstr, "\n");
      tmpstr = Substr(tmpstr, p + 1);  
   end;        

   if((tabno < 0) or (tabno > wd.Tables.Count))
      /* неверный индекс таблицы */
      return;
   end;

   Table = wd.Tables(tabno);
   КоординатыОбъединяемыхЯчеек(@n_str_a, @n_coll_a, @n_str_b, @n_coll_b, tmpstr);
   if((n_str_a == 0) or (n_str_b == 0) or (n_coll_a == 0) or (n_coll_b == 0))
      // ничего нет - ошибка
      return;
   else
      if((n_str_a < n_str_b) and (n_coll_a == n_coll_b))
          flagMergeRows = true;
      elif((n_str_a == n_str_b) and (n_coll_a < n_coll_b))
          flagMergeRows = false;
      else
          // ошибка
          return;
      end;   
   end;

   if(flagMergeRows) // объединяем строки
      CountMerge = n_str_b - n_str_a;
      while(CountMerge > 0) 
        if(flagTextNull != 0)
           table.Cell(n_str_b, n_coll_a).Range.Text = ""; 
        end;
        table.Cell(n_str_b, n_coll_a).Merge(table.Cell(n_str_b - 1, n_coll_a));        
        n_str_b = n_str_b - 1;
        CountMerge = CountMerge - 1;
      end;
   else // объединяем столбцы
      CountMerge = n_coll_b - n_coll_a;
      while(CountMerge > 0) 
        if(flagTextNull != 0)
           table.Cell(n_str_b, n_coll_a).Range.Text = "";
        end;
        table.Cell(n_str_a, n_coll_b).Merge(table.Cell(n_str_a, n_coll_b - 1));
        n_coll_b = n_coll_b - 1;
        CountMerge = CountMerge - 1;
      end;
   end;
end;

// Объединить ячейки 
/* Формат вызова:
~MergeCells
1     - номер таблицы
%
0     - текст оставлять/1 - текст затирать
8,1   - координаты первой ячейки
11,1  - координаты последней ячейки
*/
private macro PoiMergeCells( document:object, tagStr:string )
   var p;
   var tableIndex;                  // номер таблицы 
   var firstRow = 0, firstCol = 0;  // координаты 1 ячейки
   var lastRow  = 0, lastCol = 0;   // координаты последней ячейки
   var flagMergeRows;
   var flagTextNull = 1;            // затирать текст "ненужных" ячеек
   var tmpstr = "";
   
   p = Index( tagStr, "\n");                     // первый разделитель (разделяет номер таблицы и символ '%')
   tableIndex = Int( Substr(tagStr, 1, p - 1) ); // номер таблицы
   tmpStr = Substr(tagStr, p + 1); 

   if( SubStr( Trim(tmpStr), 1, 1 ) != "%" )
       // ошибка
       return;
   else
       p = Index(tmpStr, "\n");
       tmpStr = Substr(tmpStr, p + 1); 

       flagTextNull = Substr(tmpStr, 1, 1);
       p = Index(tmpStr, "\n");
       tmpStr = Substr(tmpStr, p + 1);  
   end;        

   if( tableIndex < 0 )
       /* неверный индекс таблицы */
       return;
   end;

   КоординатыОбъединяемыхЯчеек( @firstRow, @firstCol, @lastRow, @lastCol, tmpStr );

   if( (firstRow == 0) or (lastCol == 0) or (firstCol == 0) or (lastCol == 0) )
       // ничего нет - ошибка
       return;
   else
       if( (firstRow < lastRow) and (firstCol == lastCol) )
           flagMergeRows = true;
       elif( (firstRow == lastRow) and (firstCol < lastCol) )
           flagMergeRows = false;
       else
           // ошибка
           return;
      end;   
   end;
   
   if( tableIndex > 0 )
      tableIndex = tableIndex - 1;
   end; 
   
   if( flagMergeRows ) 
       // объединяем строки
       document.mergeCellsVertically(tableIndex, firstCol - 1, firstRow - 1, lastRow - 1, true);
   else
       // объединяем столбцы
       document.mergeCellsHorizontal(tableIndex, firstRow - 1, firstCol - 1, lastCol - 1, true);
   end;

   OnError( e )
        RunError("PoiMergeCells", "Ошибка при объединии ячеек");   
end;

/* Информация об одной закладке размножаемой строки
*/
PRIVATE CLASS Info (_column, _cellcount, _name, _range, _BookmarkOffsetStart, _BookmarkOffsetEnd)
var
     column = _column,
     cellcount = _cellcount,
     name = _name,
     range = _range,
     BookmarkOffsetStart = _BookmarkOffsetStart,
     BookmarkOffsetEnd = _BookmarkOffsetEnd;
END;


/* Класс содержит информацию о bookmark'ах размножаемой строки
*/
PRIVATE CLASS BookmarksInfo (_Table, _lastrow, _atEnd )
PRIVATE  var Table, lastrow, atEnd;
var Inf = TArray;

   Inf.Size = 0;
   Table = _Table;
   lastrow = _lastrow;
   atEnd = _atEnd;

   MACRO Make()
   VAR 
     j = 0, n, k, Bookmark,
     columns = Table.Rows(lastrow).Cells.Count,
     BookmarkOffsetStart, BookmarkOffsetEnd;

     while( j < columns)
       n = Table.Rows(lastrow).Cells(j+1).Range.Bookmarks.Count;
       k = 0;
       while( k < n )
         Bookmark = Table.Rows(lastrow).Cells(j+1).Range.Bookmarks(k+1);
         if(Bookmark.Range.InRange(Table.Rows(lastrow).Cells(j+1).Range))
            BookmarkOffsetStart = Bookmark.Range.Start - Table.Rows(lastrow).Cells(j+1).Range.Start;
            BookmarkOffsetEnd = GenGetProp(Bookmark.Range, "End") - Bookmark.Range.Start;
            Inf[Inf.Size] = Info(j+1,
                                 k+1,
                                 Bookmark.Name,
                                 Bookmark.Range,
                                 BookmarkOffsetStart,
                                 BookmarkOffsetEnd);
         end;
         k = k + 1;
       end;
       j = j + 1;
     end;
   END;

   MACRO CopyPaste(rows)
   VAR i = 0, columns = Table.Rows(lastrow).Cells.Count;

     Table.Rows(lastrow).Cells(1).Select;
     WordApp.Selection.MoveRight(1,columns-1,1);
     WordApp.Selection.Copy;
     WordApp.Selection.InsertRowsBelow(rows);

     while( i < rows )
       Table.Rows(lastrow+i+1).Cells(1).Select;
       WordApp.Selection.MoveRight(1,columns-1,1);
       WordApp.Selection.Paste;
       i = i + 1;
     end;
   END;

   MACRO CopyPasteAtEnd(rows)
   VAR i = 0, columns = Table.Rows(lastrow).Cells.Count;
     
     var wdColumn = 9;
     var wdLine = 5;

     Table.Rows(lastrow).Cells(1).Select;
     WordApp.Selection.MoveRight(1,columns-1,1);
     WordApp.Selection.Copy;
     
     columns = Table.Rows(Table.Rows.Count).Cells.Count;

     Table.Rows(Table.Rows.Count).Cells(1).Select;
     WordApp.Selection.MoveRight(1,columns + 1,1);
     WordApp.Selection.EndKey(wdLine);     
     WordApp.Selection.Paste;

   END;

   MACRO AddInRow(i)
   var 
     j, m = 0, NewBkmName, NewBkmRange;
     
     var rowNo = 0;
     if( atEnd )
       rowNo = Table.Rows.Count
     else
       rowNo = lastrow+i;
     end;

     while (m < Inf.Size)
        NewBkmName = ОпредИмяНовЗакл(Inf[m].Name, i);
        j = Inf[m].column;
        /* определение расположения */
        NewBkmRange = Inf[m].Range;
        NewBkmRange.Start = Table.Rows(rowNo).Cells(j).Range.Start + Inf[m].BookmarkOffsetStart;
        GenSetProp (NewBkmRange, "End", NewBkmRange.Start + Inf[m].BookmarkOffsetEnd);
        Table.Rows(rowNo).Cells(j).Range.Bookmarks.Add (NewBkmName, NewBkmRange);
        m = m + 1;
     end;
   END;

   MACRO AddBookmarks(rows)
   VAR i = 0;
     while( i < rows )
       AddInRow(i + 1);
       i = i + 1;
     end;
   END;
END;


/* Осуществляет разбор строки 'str'
01.04.2004 Панкратов А.В.
   'str' - представляет собой строку вида: "_tabno_\n_rows_\n_tbmark_\n_ln_",
где
    _tabno_ - номер изменяемой таблицы в документе.
    _rows_ - кол-во добавляемых строк.
    _tbmark_ - закладка для таблицы.
    _ln_ - номер ряда в таблице, кот. необходимо размножить
    ДЛЯ СОВМЕСТИМОСТИ оставлены также следующие варианты задания параметров :

    1 - _tabno_\n_rows_  - при этом размножаться будет последний(!) ряд в таблице

    2 - _tabno_\n_rows_\n_tbmark_ - размножаться будет последний ряд, в таблице с
    закладкой tbmark

    3 - _tabno_\n_rows_\n_#_\n_ln_ - размножаться будет ряд ln в таблице с номером
    tabno

    Символ "#" следует вводить через print или println по понятным причинам.
*/
PRIVATE MACRO ParseInfo( wd, str, table:@variant, rows:@variant, lastrow:@variant, atEnd:@variant)
var
    p, tabno, i, n, tmpstr = "", bmtable = "";

   p = Index(str, "\n");          /*первый разделитель (разделяет номер таблицы и число строк)*/
   tabno = Int(Substr(str, 1, p - 1)); /*номер таблицы*/
   tmpstr = Substr(str, p + 1);
   p = Index(tmpstr, "\n");         /*разделяет число строк и закладку таблицы*/
   if(p == 0) /*закладка таблицы не задана*/
     rows = Int(tmpstr);
   else
     rows = Int(Substr(tmpstr, 1, p - 1)); /*количество строк*/
     tmpstr = Substr(tmpstr, p + 1); /*закладка таблицы*/
     p = Index(tmpstr, "\n");
     if(p == 0)
       bmtable = Trim(tmpstr);
     else
       lastrow = Int(SubStr(Trim(tmpstr), p + 1));
       if(SubStr(Trim(tmpstr), 1, 1) != "#")
         bmtable = SubStr(Trim(tmpstr), 1, p - 1);
       end;

       tmpstr = Substr(tmpstr, p + 1); 
       p = Index(tmpstr, "\n");
       if( p == 0 )
         atEnd = 0;
       else
         atEnd = Int(SubStr(Trim(tmpstr), p + 1)); /*куда копировать? в конец таблицы?*/
       end;
     end;
   end;

   /* Поиск таблицы */
   table = null;
   if(bmtable == "") 
     /* закладка не задана, ищем таблицу по номеру */
     if((tabno < 0) or (tabno > wd.Tables.Count))
       /* неверный индекс таблицы */
       return;
     end;
     Table = wd.Tables(tabno);
   else
     /* задана закладка, ищем перебором закладок */
     n = wd.Bookmarks.Count;    /* кол-во закладок в документе */
     i = 0;
     while ((table == null) AND (i < n))
       if(bmtable == wd.Bookmarks(i+1).name) /*если нашли нужную*/
         Table = wd.Bookmarks(i+1).Range.Tables(1);
       end;
       i = i + 1;
     end;
   end;
END;


// Размножить строку таблицы.
PRIVATE MACRO MultipleRow( wd, str )
var
    rows = 0,                  /* кол-во размножаемых рядов */
    table: object = null,      /* указывает на таблицу, в которой производится размножение */
    lastrow = -1,              /* номер размножаемого ряда (если он задан, если нет - последний ряд в таблице) */
    atEnd = 0,
    BookmInfo: object = null;  /* класс с информацией о bookmark'ах размножаемого ряда */
  
   ParseInfo(wd, str, @table, @rows, @lastrow, @atEnd);

   if(table == null)
     /* Не нашли таблицу */
     return;
   elif(rows <= 0)
     /* неверное кол-во строк для добавления */
     return;
   end;

   if(lastrow < 0)
     lastrow = table.Rows.Count;
     atEnd = 0;
   end;

   BookmInfo = BookmarksInfo (Table, lastrow, (atEnd > 0) );
   BookmInfo.Make();

   if(atEnd == 0)
     BookmInfo.CopyPaste(rows);
   else
     BookmInfo.CopyPasteAtEnd(rows);
   end;
   BookmInfo.AddBookmarks(rows);
END;

PRIVATE MACRO PoiParseInfo (tagStr:string, TableIndex:@variant, Rows:@variant, LastRow:@variant, AtEnd:@variant)
   var p, i, n;
   var tmpStr = "";
   var bmtable = "";

   p = Index( tagStr, "\n" );                        // первый разделитель (разделяет номер таблицы и число строк)
   TableIndex = Int( Substr( tagStr, 1, p - 1 ) );   // номер таблицы
   tmpStr = Substr( tagStr, p + 1 );

   p = Index( tmpStr, "\n" );                    // разделяет число строк и закладку таблицы
   if( p == 0 ) 
      // закладка таблицы не задана
      Rows = Int(tmpStr);
   else
      Rows = Int(Substr(tmpStr, 1, p - 1));     // количество строк
      tmpstr = Substr(tmpStr, p + 1);           // закладка таблицы
      p = Index(tmpStr, "\n");

      if( p == 0 )
         bmtable = Trim(tmpStr);
      else
         lastrow = Int(SubStr(Trim(tmpStr), p + 1));
         if( SubStr(Trim(tmpStr), 1, 1) != "#")
            bmtable = SubStr(Trim(tmpStr), 1, p - 1);
         end;

         tmpStr = Substr(tmpStr, p + 1); 
         p = Index(tmpStr, "\n");
         if( p == 0 )
            atEnd = 0;
         else
            atEnd = Int(SubStr(Trim(tmpStr), p + 1)); // куда копировать? в конец таблицы?
         end;
      end;
   end;
END;


private macro PoiMultipleRow( document:object, tagStr:string )
   var rowCount:integer   = 0;   // кол-во размножаемых рядов 
   var tableIndex:integer = 0;   // указывает на таблицу, в которой производится размножение 
   var rowIndex:integer   = -1;  // номер размножаемого ряда (если он задан, если нет - последний ряд в таблице) 
   var atEnd:integer      = 0;
   var i:integer          = 1; 
  
   PoiParseInfo(tagStr, @tableIndex, @rowCount, @rowIndex, @atEnd);  
   
   if( rowIndex > 0 )
       rowIndex = rowIndex - 1;
   elif( rowIndex < 0 )
       rowIndex = document.getRowsCount(tableIndex - 1);
   end; 

   if( atEnd == 0 )
       while( i <= rowCount )
           document.copyRow(tableIndex - 1, rowIndex, rowIndex + i, i);
           i = i + 1;
       end;
   else
       while( i <= rowCount )
           document.copyRow(tableIndex - 1, rowIndex, rowIndex + i, i);
           i = i + 1;
       end;
   end;

   OnError( e )
        RunError("PoiMultipleRow", "Ошибка копирования строк");   
end;


/* Обработка дубликатов закладок в документе 'wd'.
     Для закладок вида 'закладка_dup_номер', копирует содержимое
     из оригинальной закладки вида 'закладка', если она есть.
   Обновление происходит в 2 этапа:
     на первом запоминается информация о дубликатах и их тексте.
     на втором данная информация заносится в закладки-дубликаты.
   Обновление сразу невозможно, т.к. при обновлении закладок 
     сбивается их последовательность.
*/
PRIVATE MACRO ResolveDupBookmarks( wd )
var
   i = 0,                           /* индекс закладки */
   bookmark,                        /* текущая закладка */
   p,                               /* позиция фрагмента _dup_ в имени закладки */
   origin,                          /* имя оригинальной закладки */
   text, 
   tagrange,
   name,
   dup = 0, 
   j = 0,
   n = wd.Bookmarks.Count;    /* кол-во закладок в документе */
array
   info;

   /* первый этап: заполнение информационного массива
   */
   while (i < n)
     Bookmark = wd.Bookmarks(i+1);
     name = Bookmark.name;
     p = Index(StrLwr(name), "_dup_");
     if(p > 1)
         info(j) = name;
         info(j+1) = "";
         origin = Substr(name, 1, p - 1);
         if (wd.Bookmarks.Exists(origin))    /* запоминаем оригинал, если он есть */
             info(j+1) = wd.Bookmarks(origin).Range.Text;
         end;
         j = j + 2;
         dup = dup + 1;
     end;
     i = i + 1;
   end;

   /* Второй этап: обновление закладок-дубликатов
   */
   i = 0;
   j = 0;
   while (i < dup)
     if(info(j+1) == "") 
       /* нечем обновлять */;
     elif(wd.Bookmarks.Exists(info(j)))    /* обновить дубликат, если он есть */
        tagrange = wd.Bookmarks(info(j)).Range;
        tagrange.Text = info(j+1);
        GenSetProp (tagrange,"End", tagrange.Start + strlen(info(j+1)));
     end;
     j = j + 2;
     i = i + 1;
   end;

END;

PRIVATE MACRO POIResolveDupBookmarks( document:object )
   var i = 0;                // индекс закладки *
   var p;                    // позиция фрагмента _dup_ в имени закладки 
   var origin;               // имя оригинальной закладки  
   var name;
   var dup = 0; 
   var j = 0;  
   array info;

   var listBookmarks = document.getDocumentBookmarks().toArray();
   var n = listBookmarks.size();

   while( i < n )
       name = listBookmarks(i);
       p = Index( StrLwr(name), "_dup_" );

       if( p > 1 )
           info(j) = name;
           info(j + 1) = "";
           origin = Substr(name, 1, p - 1);

           if( document.isBookmarkExist(origin) )
               // запоминаем оригинал, если он есть 
               info(j + 1) = document.getBookmarkValue(origin);
           end;

           j = j + 2;
           dup = dup + 1;
       end;

       i = i + 1;
   end;

   // Второй этап: обновление закладок-дубликатов
   i = 0;
   j = 0;

   while( i < dup )
       if( document.isBookmarkExist(info(j)) )    
           document.replaceBookmark(info(j), info(j + 1))
       end;
       j = j + 2;
       i = i + 1;
   end;

END;


/* Удаляет строку в таблице, где есть закладка 'tag'.
     Если удаление строки имело место, процесс дальше не продолжается,
     т.к. в этом случае сбиваются индексы строк таблицы, а возвращается true.
*/
PRIVATE MACRO RemoveRowWithTag( wd, tag )
var
  t, r, c,
  tables, rows, columns,
  table,
  tagrange;

  if(not wd.Bookmarks.Exists(tag)) 
     /* закладки нет, ничего не делаем */
     return false;
  else
     tagrange = wd.Bookmarks(tag).Range;
  end;

  tables = wd.Tables.Count;
  t = 0;
  while( t < tables )
    table = wd.Tables(t+1);
    rows = table.rows.count;
    r = 1;
    while( r < rows )
      if(r == 1)
        columns = table.rows(1).Cells.Count;
      end;
      c = 0;
      while( c < columns )  
        if(tagrange.InRange(Table.Rows(r+1).Cells(c+1).Range))
           Table.Rows(r+1).Delete;
           return true;
        end;
        c = c + 1;
      end;
      r = r + 1;
    end;
    t = t + 1;
  end;

  /* Если ~#R_метка не относится ни к одной строке таблицы,
     нужно просто удалить содержимое метки.
  */
  tagrange.Text = "";
  GenSetProp(tagrange,"End", tagrange.Start + strlen(""));

  return false;
END;

PRIVATE MACRO POIRemoveRowWithTag( document:object, tagStr:string )
   if( not document.isBookmarkExist(tagStr) )
       return false;
   end;
   document.removeRow(tagStr);
   return true;
END;



// Удаляет строки в таблице, где есть закладка вида "~#R_закладка"
PRIVATE MACRO RemoveRows( wd, tags )
   rewind(tags);
   while (Next(tags))
       if(Substr(tags.str,1,4) == "~#R_" )
          while(RemoveRowWithTag(wd, Substr(tags.str,5)))
            /* продолжаем, пока не удалим все строки с закладками */
          end;
       end;
   end;
END;

// Удаляет строки в таблице, где есть закладка вида "~#R_закладка"
PRIVATE MACRO POIRemoveRows( document:object, tags )
   rewind(tags);

   while( Next(tags) )
       if( Substr( tags.str, 1, 4) == "~#R_" )
           while( POIRemoveRowWithTag(document, Substr(tags.str, 5)) )
            /* продолжаем, пока не удалим все строки с закладками */
           end;
       end;
   end;
END;


private macro CopyTable( wd, tags )  

  var origTable, newTable, newBkmName, newBkmRange,
    BookmarkOffsetStart, BookmarkOffsetEnd,
    bm, origBm, BmName, wdStory = 6,
    tabNo, rowCount, rowNo, columnCount,
    NumBM:integer, i:integer, j:integer, k:integer;

  tabNo = tags;
  origTable = wd.Tables(tabNo);
  origTable.Select;  

  WordApp.Selection.Copy;
  WordApp.Selection.EndKey( wdStory );
  WordApp.Selection.Paragraphs.Add;
  WordApp.Selection.Paste;
  WordApp.Selection.Paragraphs.Add;

  newTable = wd.Tables( wd.Tables.Count ); 

  rowCount = origTable.Rows.Count;
  i = 0;
  while( i < rowCount )
    rowNo = i + 1;
    columnCount = origTable.Rows(rowNo).Cells.Count;
    j = 0;
    while( j < columnCount )     
      NumBM = origTable.Rows(rowNo).Cells(j+1).Range.Bookmarks.Count;
      k = 0;
      while( k < NumBM )
        origBm = origTable.Rows(rowNo).Cells(j+1).Range.Bookmarks(k+1);
        if( origBm.Range.InRange(origTable.Rows(i+1).Cells(j+1).Range) )
          BookmarkOffsetStart = origBm.Range.Start - origTable.Rows(rowNo).Cells(j+1).Range.Start;
          BookmarkOffsetEnd = GenGetProp(origBm.Range, "End") - origBm.Range.Start;

          newBkmName = ОпредИмяНовЗакл( origBm.Name, 1 );

          /* определение расположения */
          newBkmRange = origBm.Range;
          newBkmRange.Start = newTable.Rows(rowNo).Cells(j+1).Range.Start + BookmarkOffsetStart;
          GenSetProp (NewBkmRange, "End", NewBkmRange.Start + BookmarkOffsetEnd);
          newTable.Rows(rowNo).Cells(j+1).Range.Bookmarks.Add (NewBkmName, NewBkmRange);
        end;
        k = k + 1;
      end;
      j = j + 1;
    end;
    i = i + 1;
  end;

end;

private macro PoiCopyTable( document:object, tagsStr:string )  
  var tableIndex = tagsStr;

  document.copyTableToEnd(tableIndex);
end;


// ~CopyTableAfter
// 1 - Номер таблицы
// 2 - На сколько сместить индексы закладок(меток)
private macro CopyTableAfter( wd, tags )

  var lineSep, bmShift,
    origTable, newTable, newBkmName, newBkmRange,
    BookmarkOffsetStart, BookmarkOffsetEnd,
    bm, origBm, BmName, wdParagraph = 4,
    tabNo, rowCount, rowNo, columnCount,
    NumBM:integer, i:integer, j:integer, k:integer;

  // Разделитель разделяет номер таблицы и смещение индексов закладок(меток)
  lineSep = Index(tags, "\n");
  // Номер таблицы
  tabNo = Int(Substr(tags, 1, lineSep - 1));
  // Смещение индексов закладок(меток)
  bmShift = Int(Substr(tags, lineSep + 1));

  origTable = wd.Tables(tabNo);
  origTable.Select;  

  WordApp.Selection.Copy;
  WordApp.Selection.MoveDown(wdParagraph);

  WordApp.Selection.Paragraphs.Add;
  WordApp.Selection.MoveDown(wdParagraph);

  WordApp.Selection.Paragraphs.Add;
  WordApp.Selection.Paste;

  newTable = wd.Tables( tabNo + 1 ); 

  rowCount = origTable.Rows.Count;
  i = 0;
  while( i < rowCount )
    rowNo = i + 1;
    columnCount = origTable.Rows(rowNo).Cells.Count;
    j = 0;
    while( j < columnCount )     
      NumBM = origTable.Rows(rowNo).Cells(j+1).Range.Bookmarks.Count;
      k = 0;
      while( k < NumBM )
        origBm = origTable.Rows(rowNo).Cells(j+1).Range.Bookmarks(k+1);
        if( origBm.Range.InRange(origTable.Rows(i+1).Cells(j+1).Range) )
          BookmarkOffsetStart = origBm.Range.Start - origTable.Rows(rowNo).Cells(j+1).Range.Start;
          BookmarkOffsetEnd = GenGetProp(origBm.Range, "End") - origBm.Range.Start;

          newBkmName = ОпредИмяНовЗакл( origBm.Name, bmShift );

          // определение расположения 
          newBkmRange = origBm.Range;
          newBkmRange.Start = newTable.Rows(rowNo).Cells(j+1).Range.Start + BookmarkOffsetStart;
          GenSetProp (NewBkmRange, "End", NewBkmRange.Start + BookmarkOffsetEnd);
          newTable.Rows(rowNo).Cells(j+1).Range.Bookmarks.Add (NewBkmName, NewBkmRange);
        end;
        k = k + 1;
      end;
      j = j + 1;
    end;
    i = i + 1;
  end;
end;

private macro PoiCopyTableAfter( document:object, tagsStr:string )  
  var lineSep, tableIndex, bmShift;
    
  // Разделитель разделяет номер таблицы и смещение индексов закладок(меток)
  lineSep = Index(tags, "\n");

  // Номер таблицы
  tableIndex = Int(Substr(tagsStr, 1, lineSep - 1));

  // Смещение индексов закладок(меток)
  bmShift = Int(Substr(tagsStr, lineSep + 1));

  document.copyTable(tableIndex);
end;


private macro NewBmNamesForTable( wd, tags )
  var p, tabNo, rowNo, incr, i:integer, j:integer, 
    table, columnCount, 
    numBm, bm, newBkmName, newBkmRange;

  p = Index(tags, "\n");          /*первый разделитель (разделяет номер таблицы и номер строк)*/
  tabNo = Int(Substr(tags, 1, p - 1)); /*номер таблицы*/
  tags = Substr(tags, p + 1);
  p = Index(tags, "\n");   /*разделяет номер строк и значение инскремента*/
  rowNo = Int(Substr(tags, 1, p - 1)); /*номер строки*/
  tags = Substr(tags, p + 1);
  incr = Int(tags);

  table = wd.Tables(tabNo);

  columnCount = table.Rows(rowNo).Cells.Count;
  i = 0;
  while( i < columnCount )     
    numBM = table.Rows(rowNo).Cells(i+1).Range.Bookmarks.Count;
    j = 0;
    while( j < numBM )
      bm = table.Rows(rowNo).Cells(i+1).Range.Bookmarks(j+1);
      if( bm.Range.InRange(table.Rows(rowNo).Cells(i+1).Range) )
        newBkmName = ОпредИмяНовЗакл( bm.Name, incr);
        newBkmRange = bm.Range;
        newBkmRange.Text = bm.Range.Text;
        table.Rows(rowNo).Cells(i+1).Range.Bookmarks.Add( newBkmName, newBkmRange );        
      end;
      j = j + 1;
    end;
    i = i + 1;
  end;
end;

private macro PoiNewBmNamesForTable( document:object, tagsStr:string )
end;

private macro SetFontColor( tagstr:string )
  if   ( StrUpr(tagstr) == "RED"  ) _FontColor = wdColorRed;
  elif ( StrUpr(tagstr) == "BLACK") _FontColor = wdColorBlack;
  end;
end;

private macro PoiSetFontColor( document:object, tag, tagStr:string)
  if( StrUpr(tagStr) == "RED"  ) 
      _FontColor = wdColorRed;
  elif( StrUpr(tagStr) == "BLACK") 
      _FontColor = wdColorBlack;
  end;

  document.setBookmarkFontColor(tag, tagstr)
end;

private macro PoiAddPicture( document:object, tag, tagStr:string)
  var filePath:string = "";
  var pos  = Index(tagStr, "#");
  var width, height;

  if (pos > 0)
     //File
     tag = SubStr(tagStr, 1, pos - 1);
     tagStr = SubStr(tagStr, pos + 1);

     pos  = Index(tagStr, "#");
     if (pos > 0)
        //Size
        filePath = SubStr(tagStr, 1, pos - 1);
        tagStr = SubStr(tagStr, pos + 1);

        pos  = Index(tagStr, "#");
        if (pos > 0)
           width  = Int(SubStr(tagStr, 1, pos - 1));
           height = Int(SubStr(tagStr, pos + 1));
        else
        end;
     else
        filePath = Trim(tagStr);
     end;
  end;

  if((ValType(width) != V_UNDEF) and (ValType(height) != V_UNDEF))
     document.addResizedPicture(tag, filePath, width, height);
  else
     document.addPicture(tag, filePath);
  end;

end;


/* Заполнить вордовый файл данными из файла с тегами
   Используются две взаимонесовместные технологии:
      - размножение закладок в таблицах
      - копирование групп.
   При копировании групп происходит запоминание первого параграфа в буфер обмена.
   При использовании других тегов содержимое буфера обмена может нарушаться (обратите внимание!)
*/
PRIVATE MACRO FillOneDocumentFromTagFile(WordDoc, tags)
var
    tagfound = false, tag, tagstr, tagrange, i = 0, count = 0, Para, killBm = false;
var pos: Integer;
var filePath;

    while (Next(tags))
        count = count + 1;
    end;
    Rewind(tags);
    InitProgress(count, "", "Заполнение шаблона");

    while ((not tagfound) and Next(tags))
        if (SubStr(Trim (tags.str),1,1) == "~")
            tagfound = true;
        end;
    end;

    Para = WordDoc.Paragraphs(1);
    Para.Range.Select;
    WordApp.Selection.Copy;
    WordApp.Selection.Collapse ();   /* wdCollapseEnd = 0 */

    while (tagfound)
        tag = SubStr(Trim (tags.str),2);
        tagstr = null;
        tagfound = false;
        while ((not tagfound) and Next(tags))
            if (SubStr(Trim (tags.str),1,1)=="~")
                tagfound = true;
            elif (tagstr==null)
                tagstr = tags.str + "\n";
            else
                tagstr = tagstr + tags.str + "\n";
            end;
        end;

        if(tagstr==null)
            tagstr = "";
        else
            tagstr = Substr (tagstr, 1, strlen (tagstr)-1); /*Последний перевод строки обрезаем*/
        end;

        if( tag == "KillBm") 
            killBm = true;
        elif( tag == "DeleteTable")
            /*Удалить таблицу*/
            DeleteTable(WordDoc, tagstr);
        elif( tag == "CopyTable")
            /*Копировать таблицу в конец документа*/
            CopyTable(WordDoc, tagstr);
        elif( tag == "CopyTableAfter")
            /*Копировать и вставить таблицу после копируемой таблицы*/
            CopyTableAfter(WordDoc, tagstr);
        elif( tag == "NewBmNamesForTable")
            NewBmNamesForTable( WordDoc, tagstr )
        elif( tag == "MultipleRow" )
            /* размножить строку таблицы */
            MultipleRow(WordDoc, tagstr);
        elif ( tag == "MergeCells" )
            /* Объединить ячеки */
            MergeCells(WordDoc, tagstr);
        elif ( tag == "DeleteRows" )
            /* Удалить строки в таблице */
            DeleteRows(WordDoc, tagstr);
        elif ( tag == "NewGroup" )
            WordDoc.Paragraphs(1).Range.Select;
            WordApp.Selection.Collapse ();   /* wdCollapseEnd = 0 */
            WordApp.Selection.Paste;
        elif ( tag == "InsertImage" )
            /// Вставить картинку, tagstr в виде имя_закладки#полное_имя_файла
            pos  = Index(tagStr, "#");
            if (pos > 0)
                filePath = SubStr(tagStr, pos + 1);
                tag = SubStr(tagStr, 1, pos - 1);
                if (WordDoc.Bookmarks.Exists(tag))
                    WordDoc.Bookmarks(tag).Select();
                    WordApp.Selection.InlineShapes.AddPicture(filePath);
                end;
            end;
        elif ( tag == "InsertImageBackward" )
            /// Вставить картинку позади текста, tagstr в виде имя_закладки#полное_имя_файла
            pos = Index(tagStr, "#");
            if (pos > 0)
                filePath = SubStr(tagStr, pos + 1);
                tag = SubStr(tagStr, 1, pos - 1);
                if (WordDoc.Bookmarks.Exists(tag))
                    WordDoc.Bookmarks(tag).Select();
                    var inlineShape = WordApp.Selection.InlineShapes.AddPicture(filePath);
                    if (inlineShape != null)
                      var top = inlineShape.Borders.DistanceFromTop;
                      var left = inlineShape.Borders.DistanceFromLeft;
                      var shape = inlineShape.ConvertToShape();
                      shape.WrapFormat.Type = 5; ///< wdWrapBehind
                      shape.top = top;
                      shape.left = left;
                    end;
                end;
            end;
        elif (WordDoc.Bookmarks.Exists(tag))    /* обновить закладку */
            tagrange = WordDoc.Bookmarks(tag).Range;
            WordDoc.Bookmarks(tag).Range.Text = tagstr;
            GenSetProp (tagrange,"End",tagrange.Start+strlen(tagstr));
            if(not killBm)
              WordDoc.Bookmarks.Add (tag, tagrange);
            end;
        end;

        UseProgress (i = i + 1);
    end;
    RemProgress;

    WordDoc.Fields.Update;
END;

private macro POIFillOneDocumentFromTagFile(document:object, tags)
    var tagfound = false, tag, tagstr, tagrange, i = 0, count = 0, killBm = false;

    while (Next(tags))
        count = count + 1;
    end;
    Rewind(tags);
    InitProgress(count, "", "Заполнение шаблона");
    
    while ((not tagfound) and Next(tags))
        if (SubStr(Trim (tags.str),1,1) == "~")
            tagfound = true;
        end;
    end;

    while (tagfound)
        tag = SubStr(Trim (tags.str),2);
        tagstr = null;
        tagfound = false;
        while ((not tagfound) and Next(tags))
            if (SubStr(Trim (tags.str),1,1)=="~")
                tagfound = true;
            elif (tagstr==null)
                tagstr = tags.str + "\n";
            else
                tagstr = tagstr + tags.str + "\n";
            end;
        end;

        if(tagstr==null)
            tagstr = "";
        else
            tagstr = Substr (tagstr, 1, strlen (tagstr)-1); /*Последний перевод строки обрезаем*/
        end;

        if( tag == "KillBm") 
            killBm = true;
        elif( tag == "DeleteTable")
            /*Удалить таблицу*/
            PoiDeleteTable(document, tagstr);
        elif( tag == "CopyTable")
            /*Копировать таблицу в конец документа*/
            PoiCopyTable(document, tagstr);
        elif( tag == "CopyTableAfter")
            /*Копировать и вставить таблицу после копируемой таблицы*/
            PoiCopyTableAfter(document, tagstr);
        elif( tag == "NewBmNamesForTable")
            PoiNewBmNamesForTable(document, tagstr)
        elif( tag == "MultipleRow" )
            /* размножить строку таблицы */
            PoiMultipleRow(document, tagstr);
        elif ( tag == "MergeCells" )
            /* Объединить ячеки */
            PoiMergeCells(document, tagstr);
        elif ( tag == "DeleteRows" )
            /* Удалить строки в таблице */
            PoiDeleteRows(document, tagstr);
        elif ( tag == "NewGroup" )
            /*WordDoc.Paragraphs(1).Range.Select;
            WordApp.Selection.Collapse ();   
            WordApp.Selection.Paste;*/
        elif ( tag == "FontColor" )
            PoiSetFontColor(document, tag, tagstr); 
        elif ( tag == "InsertImage" )
            // Вставить картинку, tagstr в виде имя_закладки#полное_имя_файла
            PoiAddPicture( document, tag, tagStr);
        elif ( tag == "InsertImageBackward" )
            PoiAddPicture( document, tag, tagStr);
        else     
            document.replaceBookmark(tag, tagstr);
        end;

        UseProgress (i = i + 1);
    end;
    RemProgress;
END;


private macro _GetUniqDocFileName( strFileName, strFileExt )
  var docfilename; /*имя файла документа*/
  var fullFileName = "";
  _CountFiles = 1;

  if((strFileExt == null) or (strFileExt == "") or (index(strFileExt, ".") != 1))
    fullFileName = strFileName;
  else
    fullFileName = strFileName + "_" + substr(strFileExt, 2);
  end;
  docfilename = DLREPTL_GetFullTxtFileName(fullFileName);

  /**
   * Если сформированное имя файла уже существует, 
   * то подставим в имя значение нашего счетчика _CountFiles. 
   * И так пока не получим уникальное имя 
   * или счетчик не превысит _MaxCountFiles.
   */
  while(OR_ExistFile(docfilename) and (not OR_DeleteFile(docfilename)) and (_CountFiles < _MaxCountFiles))

    docfilename = DLREPTL_GetFullTxtFileName(fullFileName + "_" + string(_CountFiles));
    _CountFiles = _CountFiles + 1;

  end;

  return docfilename;
end;

private macro _WordDocSaveAs(WordDoc, docfilename)
  /* Записать документ в RTF формате */
  WordDoc.SaveAs( docfilename/*, 6*/ ); /* 6 - RTF*/
end;

// установить Вид - Разметка Страницы
private macro Set_View_Type(WordDoc)
   If( WordDoc.ActiveWindow.View.SplitSpecial == 0 /*wdPaneNone*/ )
       WordDoc.ActiveWindow.ActivePane.View.Type = 3; /*wdPrintView*/
    Else
       WordDoc.ActiveWindow.View.Type = 3; /*wdPrintView*/
    End;
onerror
end;


// Напечатать   
// Параметры: 
// tagfilename -имя файла с инструкциями приложению Word
// IsTerm - признак трехзвенки: если true, то трехзвенка, иначе - двухзвенка
// RealFileName - реальное имя файла документа
// CloseDoc - признак необходимости закрытия документа
// SaveDocTwice - признак необходимости сохранения документа дважды (для возможности копирования первого экземпляра)

MACRO DLWREPT_PrintReportFromTagFile(tagfilename:string, IsTerm:bool, RealFileName:@string, CloseDoc:bool, SaveDocTwice:bool)
    var dotfilename; /*имя файла шаблона документа*/
    var docfilename; /*имя файла документа*/
    var strFileName; /*строка с именем файла документа*/
    var strFileExt; /*строка с расширением файла документа*/
    var WordDoc; /*приложение word*/
    var WordName; /*имя окна редактирования документа в приложении word*/
    var WordIsVisible;

    RealFileName = "";

    if (not open (tags,tagfilename))
        msgbox ("Источник данных не открыт");
        return false;
    end;

    if (Next(tags))
        dotfilename = trim (tags.str);
    else
        return false;
    end;

    if (Next(tags))
        docfilename = trim (tags.str);
        SplitFile(docfilename, strFileName, strFileExt);
    else
        return false;
    end;

    if (not IsTerm)
        DLREPTL_InitServerWork(dotfilename);
    end;
    

    WordDoc = OpenWordDocumentByDot (dotfilename);
    if (WordDoc==null)
        return false;
    end;
    WordIsVisible = WordDoc.Application.Visible;

    /*скрыть приложение Word*/
    WordDoc.Application.Visible = false;

    FillOneDocumentFromTagFile (WordDoc, tags);

    Set_View_Type(WordDoc);

    /* Обработать дубликаты закладок */
    ResolveDupBookmarks(WordDoc);

    /* Удалить строки, если нужно */
    RemoveRows(WordDoc, tags);
    Close (tags);

    /* Переходим в начало документа */
    WordDoc.Application.Browser.Previous;

    /*получить уникальное имя документа и вернуть его в вызывающий код*/
    docfilename = _GetUniqDocFileName(strFileName, strFileExt);
    _WordDocSaveAs(WordDoc, docfilename);

    /* Если хотим использовать этот путь для копирования файла в другое место, 
     * то параметр SaveDocTwice должен быть true. Иначе ошибка при копировании, 
     * т.к. пока файл открыт в Word'е его нельзя копировать.
     */
    RealFileName = docfilename;

    if(SaveDocTwice == true)
      docfilename = _GetUniqDocFileName(strFileName, strFileExt);
      _WordDocSaveAs(WordDoc, docfilename);
    end;

    if(WordIsVisible or not (CloseDoc == true))
      WordDoc.Application.Visible = true;
      WordName = WordDoc.Application.Name;
      if (WordDoc.Application.Tasks.Exists(WordName))
          WordDoc.Application.Tasks(WordName).Activate(false);
      else
          WordDoc.Application.Activate;
      end;
      if(CloseDoc == true)
          WordApp.ActiveDocument.Close();
      end;
    end;

    return true;
END;


MACRO POIDLWREPT_PrintReportFromTagFile (TagFileName:string, IsTerm:bool, RealFileName:@string, CloseDoc:bool, SaveDocTwice:bool, FileNamePdf:string, FileNameHtml:string, ShowDoc:bool)
    var dotfilename; /* имя файла шаблона документа*/
    var docfilename; /* имя файла документа*/
    var strFileName; /* строка с именем файла документа*/
    var strFileExt;  /* строка с расширением файла документа*/
    
    RealFileName = "";

    var report:POIDLWREPT = POIDLWREPT(true);
    
    if( ValType(FileNamePdf) == V_STRING )
        report.SetConvertToPdf(FileNamePdf);
    end;

    if( ValType(FileNameHtml) == V_STRING )
        report.SetConvertToHtml(FileNameHtml);
    end;

    var val:string = SysGetProperty("TXT_ENCODE_OUT");

    if( NOT open( tags, TagFileName, val) )
        MsgBox ("Источник данных не открыт");
        return false;
    end;
    
    if( Next(tags) )
        dotfilename = trim(tags.str);
    else
        return false;
    end;

    if( Next(tags) )
        docfilename = trim(tags.str);
        SplitFile( docfilename, strFileName, strFileExt );
    else
        return false;
    end;

    if( not IsTerm )
        DLREPTL_InitServerWork(dotfilename);
    end;
    
    if( not report.OpenDocument(dotfilename) )
        return false;
    end;
    
    POIFillOneDocumentFromTagFile(report.GetDocument(), tags);

    POIResolveDupBookmarks(report.GetDocument());
    
    POIRemoveRows(report.GetDocument(), tags);
    
    Close(tags);
    
    report.SaveDocument(docfilename, SaveDocTwice, ShowDoc);
    
    RealFileName = report.saveDocumentPath;

    return true;
END;

// Параметры:
// TagFileName  - имя файла с инструкциями приложению Word
// IsTerm       - признак трехзвенки: если true, то трехзвенка, иначе - двухзвенка
// CloseDoc     - признак необходимости закрытия документа
// SaveDocTwice - признак необходимости сохранения документа дважды (для возможности копирования первого экземпляра)
// UsePoiMode   - признак печати через APACHE POI
macro DLWREPT_PrintReportFromTagFileEx( TagFileName:string, IsTerm:bool, CloseDoc:bool, SaveDocTwice:bool, UsePoiMode:bool)
  var stat;
  var RealFileName:string; 
  
  if( UsePoiMode )
     stat = POIDLWREPT_PrintReportFromTagFile(TagFileName, IsTerm, @RealFileName, CloseDoc, SaveDocTwice);
  else
     stat = DLWREPT_PrintReportFromTagFile(TagFileName, IsTerm, @RealFileName, CloseDoc, SaveDocTwice);
  end;

  if(not stat)
    RealFileName = "";
  end;

  return RealFileName;
end;

// Слить отчеты в один отчет
// Параметры:
// TagFileName - имя файла с инструкциями приложению Word
// IsTerm - признак трехзвенки: если true, то трехзвенка, иначе - двухзвенка
macro DLWREPT_MergeReportFromTagFile( TagFileName:string, IsTerm:bool)
  var docfilename; // имя файла документа
  var WordDoc;     // приложение word
  var WordName;    // имя окна редактирования документа в приложении word
  var Count = 0;
  
  if(not open (tags,tagfilename))
      msgbox ("Источник данных не открыт");
      return false;
  end;

  WordDoc = OpenWordDocumentAdd();
  if(WordDoc == null)
      return false;
  end;

  while(next(tags))
    docfilename = trim(tags.str);
    if(ExistFile(docfilename))
      if(Count > 0)
        WordDoc.Application.Selection.InsertBreak(7);
      end;
      WordDoc.Application.Selection.InsertFile(docfilename, "", false, false, false);
      Count = Count + 1;
    else
      msgbox("Файл \"", docfilename, "\" не найден");
    end;
  end;
  
  /*скрыть приложение Word*/
  WordDoc.Application.Visible = true;

  close(tags);

  WordName = WordDoc.Application.Name;
  if (WordDoc.Application.Tasks.Exists(WordName))
    WordDoc.Application.Tasks(WordName).Activate(false);
  else
    WordDoc.Application.Activate;
  end;

  return true;
end;

// Напечатать2, возвращает документ WordDoc
// Параметры:
// tagfilename - имя файла с инструкциями приложению Word
// RealFileName - реальное имя файла документа
MACRO DLWREPT_PrintReportFromTagFile2 ( tagfilename : string, RealFileName : @string)
   var dotfilename; // имя файла шаблона документа
   var docfilename; // имя файла документа
   var strFileName; // строка с именем файла документа
   var strFileExt;  // строка с расширением файла документа
   var WordDoc;     // приложение word

   RealFileName = "";

   if (not open (tags, tagfilename))
      msgbox ("Источник данных не открыт");
      return false;
   end;

   if (Next(tags))
      dotfilename = trim (tags.str);
   else
      return false;
   end;

   if (Next(tags))
      docfilename = trim (tags.str);
      SplitFile(docfilename, strFileName, strFileExt);
   else
      return false;
   end;

   DLREPTL_InitServerWork(dotfilename);

   WordDoc = OpenWordDocumentByDot (dotfilename, true);
   if (WordDoc == null)
      return null;
   end;

   FillOneDocumentFromTagFile (WordDoc, tags);

   // Обработать дубликаты закладок 
   ResolveDupBookmarks(WordDoc);

   // Удалить строки, если нужно 
   RemoveRows(WordDoc, tags);
   Close (tags);

   // Переходим в начало документа 
   WordDoc.Application.Browser.Previous;

   // получить уникальное имя документа и вернуть его в вызывающий код
   docfilename = _GetUniqDocFileName(strFileName, strFileExt);
   _WordDocSaveAs(WordDoc, docfilename);

   RealFileName = docfilename;

   return WordDoc;
END;

macro DLWREPT_SaveAs(wordDoc, fileName: String, format: Integer): Bool
  if ((WordApp != null) and (wordDoc !=null) and (ValType(format) == V_INTEGER))
    WordDoc.SaveAs( fileName, format);
    return true;
  end;
  
  return false;
  
onerror (err)
  return false;
end;