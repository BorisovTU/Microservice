/*
$Name:        or_tpl_h.mac
$Module:      Ядро ГКБО
$Description: Инструмент для работы с xls-шаблонами
*/
Import BankInter;
Import rsexts;
Import "or_set_h.mac"; // Настройки, применяемые в инструменте
Import "or_tools.mac"; // Общие, часто применяемые, инструментальные функции
Import "or_exl_h.mac"; // Модуль с классами для работы с Excel, Word и IE
Import "or_rep_h.mac";
Import "ws_progress.mac";

PRIVATE CONST DEBUG_COPY  = false/*true*/;

private var dbg_time = null;
private var dbg_num = 0;
private var _recreate_ = false;

macro setRecreateSheets(ok:bool)
  _recreate_ = ok;
end;

private macro dbg(msg)
  if (DEBUG_COPY)
    if (msg == null)
      dbg_num = dbg_num + 1;
      msg = string(dbg_num);
    else
      dbg_num = 0;
    end;
    if (dbg_time != null)
      msg = string(time() - dbg_time) + " " + string(msg);
    end;
    println(msg);
    dbg_time = time();
  end;
end;


/****** Пользовательский объект "Строка подитогов" */
private class CSubItogBase( ObjTable:object, SubItogName:string, NumbSubItog:integer )
   private var m_ObjTable    :object  = NULL;
   private var m_SubItogName :string  = "";
   private var m_NumbSubItog :integer = 0;
   private var m_ObjTemlXLS  :object  = NULL;
   private var m_Range       :object  = NULL; 

   macro Init( ObjTable:object, SubItogName:string, NumbSubItog:integer )
       m_ObjTable    = ObjTable;            
       m_SubItogName = SubItogName;            
       m_NumbSubItog = NumbSubItog;            
       m_ObjTemlXLS  = ObjTable.GetObjTemlXLS();
       m_Range       = NULL;                    
   end;

   Init( ObjTable, SubItogName, NumbSubItog);

   // Вывести строку подитогов в текущую строку 
   macro AddStr()
       m_Range.Copy();
       m_ObjTable.RangeTable.Insert(xlDown);
       m_ObjTable.AddressDiapazon.OffSet_Bottom(m_Range.Rows.Count);   
   end;

   //  Удалить подитог 
   macro Delete()
       m_Range.Delete();     
   end;

   // Метод проверки текущего шаблона подстроки на номер 
   macro CheckNumbSubItog( NumbSubItog:integer ) : bool
       return (m_NumbSubItog == NumbSubItog)
   end;
end;

private class (CSubItogBase) CSubItogPoi( ObjTable:object, SubItogName:string, NumbSubItog:integer )

   InitCSubItogBase(ObjTable, SubItogName, NumbSubItog);

   macro AddStr()
       var workbook = m_ObjTemlXLS.GetWorkbook();
       if( workbook != NULL )
           workbook.copyRow(workbook.getActiveSheetIndex(), workbook.getRangeFirstRow(m_SubItogName), workbook.getRangeLastRow(m_SubItogName) + 1); 
           m_ObjTable.AddressDiapazon.OffSet_Bottom(1);           
       end;
   end;

   macro Delete()
       m_ObjTemlXLS.GetWorkbook().removeRow( m_ObjTemlXLS.GetWorkbook().getActiveSheetIndex(), m_SubItogName);    
   end;
end;

private class (CSubItogBase) CSubItogExcel( ObjTable:object, SubItogName:string, NumbSubItog:integer )

   InitCSubItogBase(ObjTable, SubItogName, NumbSubItog);

   if( m_ObjTemlXLS )
       m_Range = m_ObjTemlXLS.Sheet.Range(m_SubItogName);  
   end;
end;

/****** Пользовательский объект "Список строк подитогов" */
private class (tarray) ClsSubItog()
/****************** Методы объекта
   macro Add()    - Пользовательский метод добавления шаблона подитогов в список
   macro AddStr() - Пользовательский метод вывода строки подитогов в текущую строку
   macro Delete() - Пользовательский метод удаления списка подитогов
   macro Find()   - Пользовательский метод поиска объекта с номером NumbSubItog
   macro Get()    - Пользовательский метод получить объект из списка
*/
   // Конструктор родительского объекта
   InitTArray(); 

   // Пользовательский метод добавления шаблона подитогов в список 
   // Table       - Ссылка на родительский объект таблицы
   // SubItogName - Имя диапазона со строкой подитогов
   // NumbSubItog - Номер строки шаблона подитогов (по умолчанию номер в списке)
   macro Add( Table:object, SubItogName:string, NumbSubItog:integer ) : object    
       var Obj:object = NULL;
       var Number:integer = 0;
 
       if( ValType(NumbSubItog) )
           Number = NumbSubItog;
       else              
           Number = this.Size;
       end;

	   if ((ValType(Table) == V_GENOBJ) and (IsEqClass("CTableTmplPOI", Table)))
           Obj = CSubItogPoi(Table, SubItogName, Number);
       else
           Obj = CSubItogExcel(Table, SubItogName, Number);
       end;

       this[this.Size] = Obj;

       return Obj;
   end;

   // Пользовательский метод получить объект из списка 
   macro Get( Pos ) : object
       return this[Pos];
   end;

   // Пользовательский метод поиска объекта с номером NumbSubItog 
   macro Find( NumbSubItog:integer ) : object
       var i:integer = 0;

       while( i < this.size )
           if( this.Get(i).CheckNumbSubItog(NumbSubItog) )
               return this.Get(i);
           end;
           i = i + 1;
       end;

       MsgBox("Ошибка[ClsSubItog.Find]!|Не найден шаблон подитогов с номером <", NumbSubItog, ">!");
       return NULL;
   end;

   // Пользовательский метод вывода строки подитогов в текущую строку 
   macro AddStr( NumbSubItog:integer )
       var SubItog:object = this.Find(NumbSubItog);

       if( SubItog )
           SubItog.AddStr();
       end;
   end;

   // Пользовательский метод удаления списка подитогов 
   macro Delete()
       var i:integer = 0;
       while( i < this.Size )
           this.Get(i).Delete();
           i = i + 1;
       end;
   end;
end;

private class CSaveRange(NumbSheet:integer, Name:string, Address:string, Empty:bool)
   var m_NumbSheet:integer = NumbSheet;
   var m_Name:string       = Name;
   var m_Address  :string  = Address;
   var m_Empty    :bool    = false;
   
   if( ValType(Empty) ) 
      m_Empty = Empty;
   end;

   macro CheckName( Name:string ) : bool
       return (m_Name == Name)
   end;

   macro CheckNumbSheet( NumbSheet:integer ) : bool
       return (m_NumbSheet == NumbSheet)
   end;

end;

private class CTableTmplBase(TableName:string, HeaderName:string, ObjTemlXLS:object, TxtHeader:string, HeaderOnPage:bool) 

/* Методы объекта
   macro AddStr()         - Пользовательский метод для добавления строки в таблицу
   macro ClearCurRow()    - Пользовательский метод очищающий значения во всех ячейках диапазона - "строка таблицы"
   macro EndTable()       - Пользовательский метод для завершения вывода таблицы - удаляет все шаблонные строки 
   macro FillTabelFromCSV()-Пользовательский метод формирования отчета при помощи csv-файла(ов)
   macro GetCurAddress()  - Пользовательский метод возвращающий адрес ячейки с именем CellName
   macro GetFormulaSumm() - Пользовательский метод возвращающий формулу для подсчета значений по колонке CellName ячейки таблицы, в пределах форм bRow-eRow, если не заданы, то по всей таблице
   macro GetObjTemlXLS()  - Пользовательский метод получения ссылки на основной объект
   macro SetValueCell()   - Пользовательский метод для заполнения ячейки таблицы с именем CellName значением Value
   macro vPrintCell()     - Виртуальный метод, перегружать для изменения форматирования в отдельной  ячейке 
   macro vPrintString()   - Виртуальный метод, перегружать для  форматирования строки отчёта 
   macro RegisterSubItog()- Пользовательский метод для регистрации строк подитогов
   macro AddStrSubItog()  - Пользовательский метод вывода строки подитогов в текущую строку таблицы

*/

   // Private
   private  var m_TableName        :string     = "";                       // Имя диапазона с основной строкой таблицы
   private  var m_HeaderName       :string     = "";                       // Имя диапазона с шапкой таблицы
   private  var m_ObjTemlXLS       :object     = NULL;                     // Ссылка на основной объект шаблона (CTemplateXLS)
   private  var m_NumbRowsInTable  :integer    =  1;                       // Кол-во строк листа Excel в одной строке таблицы
   private  var m_NumbRow          :integer    =  0;                       // Номер текущей строки
   private  var m_lsSubItog        :ClsSubItog = ClsSubItog;               // Список шаблонов строк подитогов
   private  var m_AddressRangeTable:CAddressDiapazon = CAddressDiapazon(); // Первоначальный Адрес диапазона таблицы
   private  var m_NumbSheet        :integer    = 0;                        // Номер закладки, с шаблоном таблицы, если не задан, то пользователь сам должен был его установить
   private  var m_lsDeleteRange    :tarray     = tarray;                   // Диапазоны рабочих строк подлежащих удалению
   private  var Func_BeforeAddSheet:variant    = NULL;
   private  var Func_AfterAddSheet :variant    = NULL;
   private  var Func_AfterAutoFill :variant    = NULL;
   private  var Func_AfterReOpenTempleFile :variant    = NULL;
   private  var m_TxtHeader        :string     = "";                       // Шапка таблицы в тексте
   private  var m_TxtObjPrint                  = NULL;
   private  var m_HeaderOnPage:bool            = false;                    // печатать шапку на каждой странице
   private  var m_lsAddressDiapazon:Tarray = Tarray();

   // Public
   var AddressDiapazon:CAddressDiapazon = CAddressDiapazon();             // Адрес диапазона таблицы
   var RangeTable:object   = NULL;                                        // Объект - диапазон таблицы
   var bRowTable :integer  = 1;                                           // Номер первой строки таблицы
   var eRowTable :integer  = 1;                                           // Номер последней строки таблицы
   var m_WorkDir :string   = "";                                          // Путь до временных файлов
   var PrintStrArr:Tarray  = Tarray();                                    // Текущая строка для вывода в текст
   var addRowCount:integer = 0;

   macro Init(TableName, HeaderName, ObjTemlXLS, TxtHeader, HeaderOnPage)
       if( ValType(TableName) )
           m_TableName = TableName;
       end;
       if( ValType(HeaderName) )
           m_HeaderName = HeaderName;
       end;
       if( ValType(ObjTemlXLS) )
           m_ObjTemlXLS = ObjTemlXLS;
           m_WorkDir = ObjTemlXLS.m_WorkDir;
       end;
       if( ValType(TxtHeader)  )
           m_TxtHeader = TxtHeader;
       end;
       if( ValType(HeaderOnPage) )
           m_HeaderOnPage = HeaderOnPage;
       end;
   end;

   macro InitRange(Range, SheetIndex, Address, StartRow)
       if( ValType(Range) == V_GENOBJ )
           RangeTable          = Range;
           AddressDiapazon     = CAddressDiapazon(Range.Address);
           m_AddressRangeTable = CAddressDiapazon(Range.Address);
           bRowTable           = Range.Row;
           m_NumbRowsInTable   = Range.Rows.Count;
       end;
       if( ValType(SheetIndex) )
           m_NumbSheet = SheetIndex;
       end;
       if( ValType(Address) )
           AddressDiapazon = Address;
           m_AddressRangeTable = Address;
       end;
       if( ValType(StartRow) )
           bRowTable = StartRow;
       end;
   end;

   Init (TableName, HeaderName, ObjTemlXLS, TxtHeader, HeaderOnPage);

   macro GetTableRange():string
       return AddressDiapazon.Get_Address();
   end;

   macro AddDeleteRange(Range:CSaveRange)   
       if( ValType(Range.m_Name) )
           var Index = this.Find(Range.m_Name, Range.m_NumbSheet);
           if (Index != -1)
              m_lsDeleteRange[Index] = Range;
              return;
           end;
       end;
       m_lsDeleteRange[m_lsDeleteRange.Size] = Range;
   end;

   macro Find( Name:string, NumbSheet:integer ) : integer
       var i:integer = 0;

       while( i < m_lsDeleteRange.size )
           if( m_lsDeleteRange(i).CheckName(Name) and m_lsDeleteRange(i).CheckNumbSheet(NumbSheet) )
               return i;
           end;
           i = i + 1;
       end;

       return -1;
   end;

   macro GetDeleteRanges():tarray
       return m_lsDeleteRange;
   end;

   // Пользовательский метод получения ссылки на основной объект 
   macro GetObjTemlXLS()
       return m_ObjTemlXLS;
   end;

   // Задание CallBack-а для обработки сообщение "Новый лист ДО" 
   macro Set_Func_BeforeAddSheet( _Func_BeforeAddSheet:variant )
       Func_BeforeAddSheet = _Func_BeforeAddSheet;
   end;

   // Задание CallBack-а для обработки сообщение "Новый лист ПОСЛЕ" 
   macro Set_Func_AfterAddSheet ( _Func_AfterAddSheet :variant )
       Func_AfterAddSheet  = _Func_AfterAddSheet ;
   end;

   // Задание CallBack-а для обработки сообщение "После применения формата" 
   macro Set_Func_AfterAutoFill ( _Func_AfterAutoFill :variant )
       Func_AfterAutoFill  = _Func_AfterAutoFill ;
   end;

   // Задание CallBack-а для обработки сообщение "После переоткрытия файла шаблона" 
   macro Set_Func_AfterReOpenTempleFile ( _Func_AfterReOpenTempleFile :variant )
       Func_AfterReOpenTempleFile  = _Func_AfterReOpenTempleFile ;
   end;

   // Пользовательский метод для добавления строки в таблицу 
   macro AddStr()       
       var HeaderRow = 0;
       var HeaderDiaposon ;
       var PrevDiaposon;
       var PrevAddress;
         
       if( m_HeaderName and m_HeaderOnPage )
           HeaderDiaposon = m_ObjTemlXLS.Sheet.Range(m_HeaderName);
       end;

       if( m_ObjTemlXLS.GetCopyByRows() )
           var str  = String(RangeTable.Row, ":", RangeTable.Row + RangeTable.Rows.count - 1);
           var str2 ="";
           var str3 = "";

           m_ObjTemlXLS.Sheet.Rows(str).Copy();

           if(m_HeaderName and m_HeaderOnPage)
              PrevAddress = RangeTable.Address;
           end;

           m_ObjTemlXLS.Sheet.Rows(str).Insert( xlDown );
         
           if( m_HeaderName and m_HeaderOnPage )
               PrevDiaposon = m_ObjTemlXLS.Sheet.Range(PrevAddress);
               if( PrevDiaposon.Rows(1).PageBreak != xlPageBreakNone )
                   str2 = String(HeaderDiaposon.Row,":",HeaderDiaposon.Row + HeaderDiaposon.Rows.count -1);
                   str3 = string(PrevDiaposon.Row,":",PrevDiaposon.Row + PrevDiaposon.Rows.count -1);
                   m_ObjTemlXLS.Sheet.Range(str2).Copy();
                   m_ObjTemlXLS.Sheet.Range(str3).Insert(xlDown);
                   AddressDiapazon.OffSet_Bottom(HeaderDiaposon.Rows.Count);
                   m_ObjTemlXLS.Sheet.Rows(PrevDiaposon.Row - HeaderDiaposon.Rows.count).PageBreak = xlPageBreakManual;
               end; 
            end;
       else
           // Скопируем  диапазон - "строка таблицы" 
           RangeTable.Copy();              
           if( m_HeaderName and m_HeaderOnPage )
               PrevAddress = RangeTable.Address;  
           end;
           // Вставим диапазон со смещением вниз (xlDown)                                  
           RangeTable.Insert( xlDown );    
           
           if( m_HeaderName and m_HeaderOnPage )
               if( m_ObjTemlXLS.Sheet.Range(PrevAddress).Rows(1).PageBreak != xlPageBreakNone )
                   PrevDiaposon = m_ObjTemlXLS.Sheet.Range(PrevAddress);
                   HeaderDiaposon.Copy();
                   m_ObjTemlXLS.Sheet.Range(PrevAddress).Insert(xlDown);
                   // Если высота шапки меньше высоты табличной строки, она может вставится на предыдущую строку
                   m_ObjTemlXLS.Sheet.Rows(PrevDiaposon.Row - HeaderDiaposon.Rows.count).PageBreak = xlPageBreakManual; 
                   AddressDiapazon.OffSet_Bottom(HeaderDiaposon.Rows.Count);
               end; 
           end;
       end;

       // Кроме первого раза
       if( m_NumbRow )
           // Увеличим полученный диапазон на высоту вставленной строки таблицы
           AddressDiapazon.OffSet_Bottom(m_NumbRowsInTable);
       end;

       // Занесем текущее значение в номер последней строки таблицы
       eRowTable = RangeTable.Rows.Row - 1;   

       // Номер строки таблицы
       m_NumbRow  = m_NumbRow + 1;    

       // Прочистим шаблон, чтобы пользователь заполнял только значимые поля          
       this.ClearCurRow();                            
   end;

   // Пользовательский метод возвращающий формулу для подсчета значений по колонке
   // CellName ячейки таблицы, в пределах форм bRow-eRow, если не заданы, то по всей таблице 
   // По замечаниям ГПБ убрано наименование листа из формулы 
   macro GetFormulaSummREG( CellName:string, FixRow:bool, bRow:integer, eRow:integer ) : string
       var Formula   :string = "";                               // Строка содержащая результирующую формулу
       var Column    :string = "";                               // Строка с символьным кодом колонки
       var SpecSymbol:string = "";                               // Строка с символом фиксированного диапазона
       var Pos       :integer = 0;                               // Вспомогательные переменные
       var TmpAddress:string  = "";                              // -//-

       if( m_ObjTemlXLS.ExcelLanguageInterface != EXCEL_INTERFACE_RUS )
           Formula = "=SUM(";
       else             
           Formula = "=СУММ(";
       end;

       if( NOT bRow )
          bRow = this.bRowTable;
       end;
       if( NOT eRow ) 
           eRow = this.eRowTable + m_NumbRowsInTable;
       end;

       if( ValType(FixRow) AND FixRow )
           SpecSymbol = "$"; // Использовать фиксированный диапазон
       end;

       TmpAddress = m_ObjTemlXLS.Sheet.Range(CellName).Address; 
         
       if( (Pos = index(TmpAddress, "$")) != 0 )
           TmpAddress = SubStr(TmpAddress, Pos+1);
            if( (Pos = index(TmpAddress, "$")) != 0 )
               Column = SubStr(TmpAddress, 1, Pos-1);
            end;
       end;

       return Formula + String(SpecSymbol, Column, SpecSymbol,bRow, ":", SpecSymbol, Column, SpecSymbol, eRow) + ")";
        
   OnError( ObjError )
        ErrorMessage( ObjError, "[CTableTmpl.GetFormulaSumm] Ошибка!" );
        return "";
   end;


   // Пользовательский метод возвращающий формулу для подсчета значений по колонке
   // CellName ячейки таблицы, в пределах форм bRow-eRow, если не заданы, то по всей таблице 
   macro GetFormulaSumm( CellName:string, FixRow:bool, bRow:integer, eRow:integer ) : string
         var Formula   :string = "";                               // Строка содержащая результирующую формулу
         var Column    :string = "";                               // Строка с символьным кодом колонки
         var SpecSymbol:string = "";                               // Строка с символом фиксированного диапазона
         var Pos       :integer = 0;                               // Вспомогательные переменные
         var TmpAddress:string  = "";                              // -//-

         if( m_ObjTemlXLS.ExcelLanguageInterface != EXCEL_INTERFACE_RUS )
             Formula = "=SUM(";
         else                    
             Formula = "=СУММ(";
         end;

         // Приклеем номер листа
         Formula = String(Formula, "'", m_ObjTemlXLS.SheetName(), "'!");

         if( NOT bRow )
             bRow = this.bRowTable;
         end;
         if( NOT eRow )
             eRow = this.eRowTable + m_NumbRowsInTable;
         end;

         if( ValType(FixRow) AND FixRow )
             SpecSymbol = "$"; // Использовать фиксированный диапазон
         end;
      
         TmpAddress = m_ObjTemlXLS.Sheet.Range(CellName).Address; 

         if( (Pos = index(TmpAddress, "$")) != 0 )
             TmpAddress = SubStr(TmpAddress, Pos + 1);
             if( (Pos = index(TmpAddress, "$")) != 0 )
                 Column = SubStr(TmpAddress, 1, Pos - 1);
             end;
         end;

         return Formula + String(SpecSymbol, Column, SpecSymbol,bRow, ":", SpecSymbol, Column, SpecSymbol, eRow) + ")";;

   OnError( ObjError )
         ErrorMessage( ObjError, "[CTableTmpl.GetFormulaSumm] Ошибка!" );
         return "";
   end;

   // Пользовательский метод очищающий значения во всех ячейках диапазона - "строка таблицы" 
   macro ClearCurRow()
         RangeTable.Value = "";
   end;

   // Пользовательский метод возвращающий адрес ячейки с именем CellName 
   macro GetCurAddress( CellName:string ) : string
         return m_ObjTemlXLS.Sheet.Range(CellName).Address;
   end;

   // Пользовательский метод для завершения вывода таблицы - удаляет все шаблонные строки 
   macro EndTable()
         var i:integer = 0;

         while( i < m_lsDeleteRange.Size )
            m_ObjTemlXLS.Book.Sheets.Item(m_lsDeleteRange[i].m_NumbSheet).Range(m_lsDeleteRange[i].m_Address).Delete(); 
            i = i + 1;                                                                             
         end;

         if( NOT m_lsDeleteRange.Size )
             if( m_ObjTemlXLS.GetCopyByRows() )
                 var str = String( RangeTable.Row, ":", RangeTable.Row + RangeTable.Rows.count - 1 );
                 m_ObjTemlXLS.Sheet.Rows(str).Delete();
             else
                 // Удаляем шаблон таблицы
                 RangeTable.Delete(); 
             end;
         end;

         // Удаляем шаблоны подитогов
         m_lsSubItog.Delete();     

   OnError( ObjErr )
         ErrorMessage(ObjErr, "[CTableTmpl.EndTable] Ошибка!");
         return false;
   end;

   // Пользовательский метод для заполнения ячейки таблицы с именем CellName значением Value                    
   macro SetValueCell( CellName:string, Value:variant, isNeedTrimStr :bool )
         m_ObjTemlXLS.SetValue_NameCell( CellName, Value, isNeedTrimStr );
   end;

   // Пользовательский метод для регистрации строк подитогов 
   macro RegisterSubItog( SubItogName:string, NumbSubItog:integer ) : object  
         return m_lsSubItog.Add(this, SubItogName, NumbSubItog);
   end;

   // Пользовательский метод вывода строки подитогов в текущую строку таблицы 
   macro AddStrSubItog( NumbSubItog:integer, CurRow:integer )
         m_lsSubItog.AddStr( NumbSubItog );
   end;

   // Внутренний метод получения массива форматов ячеек строки шаблона таблицы 
   private macro GetlsFormat() : tarray
         var i :integer = 0;
         var ls:tarray  = TArray();

         while( i < AddressDiapazon.GetNumbColumn )
            ls[i] = m_ObjTemlXLS.Sheet.Range( AddressDiapazon.GetColumn(i) ).NumberFormat;
            i = i + 1;
         end;

         return ls
   end;

   // Сформировать заголовок на следующем листе 
   private macro CreateNextHeader( HeaderAddress:CAddressDiapazon ) : bool
         var i      :integer = 0;  
         var Range:object  = NULL;  
         var Address:CAddressDiapazon = NULL;

         // Если заголовок таблицы передан, то работаем с ним, иначе создаем свой с номерами
         if( m_HeaderName != "" )
             m_ObjTemlXLS.Book.Sheets.Item(m_NumbSheet).Range(m_HeaderName).Copy;
             Address = CAddressDiapazon(m_ObjTemlXLS.Book.Sheets.Item(m_NumbSheet).Range(m_HeaderName).Address);

             Address.OffSet_Row( -Address.Get_bRow() );
             Range = m_ObjTemlXLS.Sheet.Range(Address.Get_Address());

             // Вставим шаблонную строку с признаком "Сохранять ширину оригинала"
             Range.PasteSpecial(xlPasteColumnWidths); 

             // Вставим шаблонную строку с признаком "Сохранять данные"
             Range.PasteSpecial(xlPasteAll); 

             HeaderAddress = CAddressDiapazon(Range.Address);
         else
             HeaderAddress = CAddressDiapazon(m_AddressRangeTable.Get_Address());
             HeaderAddress.OffSet_Row( -HeaderAddress.Get_bRow() );

             while( i < HeaderAddress.GetNumbColumn )
                 Range = m_ObjTemlXLS.Sheet.Range( HeaderAddress.GetColumn(i) );
                 Range.NumberFormat        = "@";           // Формат
                 Range.NumberFormatLocal   = "@";
                 Range.HorizontalAlignment = ALIGN_CENTER;  // Выравнивание
                 Range.Value               = String(i+1);   // Значение

                 m_ObjTemlXLS.SetBorder( HeaderAddress.GetColumn(i) ); // Обрамление
                 i = i + 1;
             end;
         end;
         SetParm(1, HeaderAddress); 
         return true;

   OnError( ObjErr )
         ErrorMessage(ObjErr, "[CTableTmpl.CreateNextHeader] Oшибка!");
         return false;
   end;

   // Создание полного имени файла 
   private macro CreateFullFileName( FileTxtName:string, NamePathSource:string ) : string
         var TempNamePath        :string  = "";  // Временные переменные
         var TempNamePathSource  :string  = "";  // -//-
         var TempNamePathDestName:string  = "";  // -//-
         var TempNamePathDestExt :string  = "";  // -//-
         var FullFileTxtName     :string  = "";  // -//-

         // Определим путь до временных папок, где должен располагаться файл с данными
         if( IsStandAlone() OR m_ObjTemlXLS.UsePoi())
             // Если в строке пути есть знак ":" или "\\", то это имя файла с путем, не трогаем его
             if( Index(toAnsi(FileTxtName), ":") OR Index(toAnsi(FileTxtName), "\\\\") )
                 FullFileTxtName = FileTxtName
             else
                 FullFileTxtName = m_WorkDir + "\\" + FileTxtName;  // Получим полное имя файла с данными
             end;
             SetParm(2,FullFileTxtName);
         else
             // Если в строке пути есть знак ":" или "\\", то это абсолютный путь
             if( Index(toAnsi(NameDirTerm), ":") OR Index(toAnsi(NameDirTerm), "\\\\") )
                 TempNamePath = SubStr(toAnsi(NameDirTerm), 2);
             else
                 TempNamePath = GetCurDir(true)+"\\"+SubStr(toAnsi(NameDirTerm), 2);
             end;
             MakeDir(toAnsi(NameDirTerm) );

             // Если в строке пути есть знак ":" или "\\", то это имя файла с путем, не трогаем его
             if( Index(toAnsi(FileTxtName), ":") OR Index(toAnsi(FileTxtName), "\\\\") )
                 TempNamePathSource = FileTxtName
             else
                 TempNamePathSource = m_WorkDir+"\\"+ FileTxtName
             end;

             // Вдруг передали полный путь, так Мы отрежем только его имя
             SplitFile(FileTxtName, TempNamePathDestName, TempNamePathDestExt);
             SetParm(2,TempNamePathSource);
             // Перешлем на терминал рабочий файл с данными
             if( NOT CopyFile( toANSI(TempNamePathSource),
                               toANSI(NameDirTerm+TempNamePathDestName+TempNamePathDestExt) ) )

                 MsgBox( "Ошибка при передаче файла <" + toAnsi(FileTxtName) +
                          "> на терминал.|Из|<"+ toAnsi(TempNamePathSource)+
                          ">|в|<"+toAnsi(NameDirTerm+TempNamePathDestName+TempNamePathDestExt) + ">" );

                 return false;
             end;

             // Получим полное имя файла с данными
             FullFileTxtName = TempNamePath + TempNamePathDestName+TempNamePathDestExt;
         end;
         return FullFileTxtName;
   end;

   // Регистрация таблицы в шаблонном объекте
   macro Register( ObjTemlXLS )
         Init(m_TableName, m_HeaderName, ObjTemlXLS);

         if( m_ObjTemlXLS.m_PrintText )
             m_ObjTemlXLS.SetHeaderTxtTable(m_TxtHeader);
             m_TxtObjPrint = m_ObjTemlXLS.m_TxtObjPrint; 
         end;

         this.m_WorkDir = ObjTemlXLS.m_WorkDir;
   end;

   // Заполнение ячейки, виртуальный метод для перегрузки
   macro vPrintCell(CellNum:integer, StrNum:integer, PrintStr:string)
         m_TxtObjPrint.AddPrintCell(PrintStr, 0, 0, "", REP_ELEM_TABL);
   end;

   macro vPrintStringEnd(StrNum:integer)
         m_TxtObjPrint.AddStr(NULL, TEMPLATE_DEFAULT);
   end;

   // Заполнение строки, виртуальный метод для перегрузки
   macro vPrintString(StrNum:integer)
         var k:integer = 0;

         while( k < PrintStrArr.Size)
             vPrintCell(k, StrNum, PrintStrArr[k]);
             k = k + 1;
         end; 
         vPrintStringEnd(StrNum);
   end; 

   // Заполнение текстового отчёта из scv
   macro FillTxtTableFromCSV(FileTxtName, SymbolDelimiter)
         FILE TxtRpRead () txt;

         if( m_ObjTemlXLS.m_PrintText)
           if( NOT WR_Open(TxtRpRead, FileTxtName) )
               MsgBox("[FillTxtTableFromCSV] Не найден файл:\n", FileTxtName);
               return false;
           end; 

           var StrNum:integer  = 0;
           while( (Next(TxtRpRead)) )
               var ParStr  :string   = TxtRpRead.Str;
               var printStr:string   = "";
               var Pos     :integer  = 0;
               var lenght  :integer  = 0;
               var CellNum  :integer = 0;

               PrintStrArr.Size = 0;

               if( Not ValType(SymbolDelimiter) )
                   SymbolDelimiter = ";";
               end;

               CellNum = 0;

               while( lenght = StrLen(ParStr))
                   pos  = Index (ParStr,SymbolDelimiter);
                   if( Not pos )
                       printStr = ParStr;
                       ParStr = "";
                   else
                       printStr = SubStr(ParStr,1,pos - 1);
                       ParStr =   SubStr(ParStr,pos + 1,lenght);
                   end;

                   var printstrlen = StrLen(printStr);
                   if( (SubStr(printStr,1,1)=="\"" ) and (SubStr(printStr,printstrlen) == "\"") )
                       printStr = SubStr(printStr,2,printstrlen - 2);
                   end;

                   if( printStr == " " )
                       printStr = "";
                   end;

                   PrintStrArr[CellNum] = printStr;                                                                                
                   CellNum = CellNum + 1;
               end;

               vPrintString(StrNum);

               StrNum = StrNum + 1;
           end;
           Close(TxtRpRead );
         end; 
   end;

   // Пользовательский метод для заполнения таблицы данными из CSV-файла 
   macro FillTabelFromCSV( FileTxtName:variant, NumbSheet:integer, SymbolDelimiter:string, Coding:integer, showErrorMessage:bool):bool  
         var  i               :integer = 0;       // Временные переменные
         var  stat            :bool    = true;    // -//-
         var  LoclsFileName   :tarray  = TArray;  // Массив с именами файлов с данными
         var  Book_txt        :object  = NULL;    // Книга    с данными csv-файла
         var  Sheet_txt       :object  = NULL;    // Закладка с данными csv-файла
         var  Pos             :integer = 0;       // Временные переменные
         var  Address_AutoFill:string  = "";      // -//-
         var  FullFileTxtName :string  = "";      // -//-
         var  lsFormat        :tarray  = TArray();
         var  HeaderAddress   :CAddressDiapazon = CAddressDiapazon;
         var  SheetName       :string = "";
         
         // Передали имя файла
         if( ValType(FileTxtName) == V_STRING )
             LoclsFileName[0] = FileTxtName;
         elif( (ValType(FileTxtName) == V_GENOBJ) AND (strUpr(GenClassName(FileTxtName)) == "TARRAY") )
             LoclsFileName = FileTxtName;
         else
             MsgBox( "[CTableTmpl.FillTabelFromCSV] Неверный тип первого параметра функции (функий принимает V_STRING или V_GENOBJ<TARRAY>)!" );
             return false;
         end;

         if( NumbSheet )
             m_NumbSheet = NumbSheet;
         end;

         if( m_ObjTemlXLS.m_PrintXls )
             // Получим массив форматов ячеек шаблона таблицы
             lsFormat = GetlsFormat();
         end;

         m_ObjTemlXLS.SetUseCSV();

         m_ObjTemlXLS.TabInitProgress(LoclsFileName.Size * 8, "...Открытие и заполнение шаблона данными", "Открытие и заполнение шаблона данными...");

         // Цикл по csv-файлам (если данных оказалось слишком много, 
         // более MAXROWSHEET, и они перенесены на следующие листы)
         while(i < LoclsFileName.Size)
             var FullFileTxtNameServ:string = "";

             var TxtFileFullName:string = CreateFullFileName(LoclsFileName[i], TxtFileFullName);

             FullFileTxtName = CreateFullFileName( LoclsFileName[i], FullFileTxtNameServ);
         
             if( m_ObjTemlXLS.m_PrintXls )
                 // Откроем текстовый файл с данными талицы
                 if(m_ObjTemlXLS.OpenTxt(FullFileTxtName, SymbolDelimiter, Coding, lsFormat))
                     // Получим ссылки на объкты: Книга и Закладка
                     m_ObjTemlXLS.TabUseProgress(i * 8 + 1);
                     Book_txt  = m_ObjTemlXLS.Application.Workbooks(m_ObjTemlXLS.Application.Workbooks.Count);
                     Sheet_txt = Book_txt.Sheets(1);

                     // Если все получилось, то копируем данные
                     if(ValType(Sheet_txt))
                         // Если пользователь указал закладку с таблицей, то выберем её, иначе пусть этим занимается сам!!!
                         m_ObjTemlXLS.TabUseProgress(i * 8 + 2);
                         if(i == 0)
                             if( m_NumbSheet )
                                 m_ObjTemlXLS.SheetChange(m_NumbSheet);
                             end;
                             SheetName = m_ObjTemlXLS.SheetName();                             
                         elif(i > 0)
                             // Запускаем CallBack для отслеживания сообщения "Добавления листа"
                             if(Func_BeforeAddSheet != NULL)
                                 ExecMacro2(Func_BeforeAddSheet, this, FullFileTxtName);
                             end;

                             // Добавим новую закладку
                             m_ObjTemlXLS.SheetAdd(m_ObjTemlXLS.Sheet.Index/*Добавить сразу за этим листом*/);
                             m_ObjTemlXLS.SheetName(SheetName);

                             // Сформируем заголовок
                             stat = CreateNextHeader(HeaderAddress);
                             if( stat )
                                 m_ObjTemlXLS.Book.Sheets.Item(m_NumbSheet).Range(m_TableName).Copy();                   // Скопируем шаблонную строку

                                 HeaderAddress.OffSet_Row(HeaderAddress.GetNumbRow());                                 // Сместимся вниз на кол-во строк заголовка от верха заголовка
                                 HeaderAddress.OffSet_Bottom(-(HeaderAddress.GetNumbRow-m_AddressRangeTable.GetNumbRow));

                                 RangeTable = m_ObjTemlXLS.Sheet.Range(HeaderAddress.Get_Address());                     // Получим новую ссылку на диапазон - "строка таблицы"
                                 RangeTable.PasteSpecial(xlPasteColumnWidths);                                         // Вставим шаблонную строку с признаком "Сохранять ширину оригинала"
                                 RangeTable.PasteSpecial(xlPasteAll);                                                  // Вставим шаблонную строку с признаком "Сохранять данные"
                                 bRowTable = RangeTable.Row;                                                           // Получим строку листа с которой начнем вывод строк таблицы
                             end;
                             
                             AddressDiapazon = CAddressDiapazon(RangeTable.Address);

                             // Запускаем CallBack для отслеживания сообщения "Добавления листа"
                             if(Func_AfterAddSheet != NULL)
                                 ExecMacro2(Func_AfterAddSheet, this, FullFileTxtName);
                             end;
                         end;
                         
                         AddressDiapazon.Init(RangeTable.Address);
                         var AddressRangeTable = AddressDiapazon;

                         // Получим первоначальный адрес диапазон шаблона строки таблицы
                         m_ObjTemlXLS.TabUseProgress(i * 8 + 3);
                         if((Pos = Index(RangeTable.Address, ":")) != 0)
                             Address_AutoFill = SubStr(RangeTable.Address, 1, Pos);
                         end;
                    
                         // Перейдем на закладку с данными
                         Sheet_txt.Activate();    
                         var SourceRange = Sheet_txt.Range(m_ObjTemlXLS.Application.ActiveWindow.Selection, Sheet_txt.Cells.SpecialCells(xlLastCell));

                         // Вставим пустой диапазон, куда будем копировать данные
                         RangeTable.Resize(SourceRange.Rows.Count).Insert(xlDown);
                     
                         // Cкопировать таблицу в то место, где находится шаблон таблицы
                         SourceRange.Copy(m_ObjTemlXLS.Sheet.Range(AddressRangeTable.Get_Address()));
                                                         
                         // Занесем текущее значение в номер последней строки таблицы
                         eRowTable = SourceRange.Rows.Count;  
                         AddressRangeTable.OffSet_Bottom(eRowTable);
                     
                         // Получим окончательный адрес диапазон шаблона строки таблицы
                         m_ObjTemlXLS.TabUseProgress(i * 8 + 4);
                         if((Pos = Index(AddressRangeTable.Get_Address(), ":")) != 0)
                             Address_AutoFill = Address_AutoFill + SubStr(AddressRangeTable.Get_Address(), Pos + 1);
                         end;
                         AddressDiapazon.Init(Address_AutoFill);
                         AddressDiapazon.OffSet_Bottom(-1);

                         // Закроем книгу с табличными данными
                         m_ObjTemlXLS.TabUseProgress(i * 8 + 5);                     
                         // Для того, чтобы не сохранять буфер обмена (занимает кучу времени!!!)
                         m_ObjTemlXLS.Application.CutCopyMode = False;

                         Book_txt.Close(false);
                         Book_txt  = NULL;
                         Sheet_txt = NULL;
                     
                         // Применяем форматирование по шаблону
                         m_ObjTemlXLS.TabUseProgress(i * 8 + 6);
                         RangeTable.AutoFill(m_ObjTemlXLS.Sheet.Range(Address_AutoFill), xlFillFormats);

                         // Запускаем CallBack для отслеживания сообщения "Добавления листа"
                         if(Func_AfterAutoFill != NULL)
                             ExecMacro2(Func_AfterAutoFill, this, FullFileTxtName,  // Имя csv-файла с данными 
                                                                  Address_AutoFill);// Диапазон текущего листа с импортированными данными, к кторому уже применен формат
                         end;

                         // Удаляем переданный файл с терминала, если работали в 3-х звенке
                         m_ObjTemlXLS.TabUseProgress(i * 8 + 7);
                         if( (NOT IsStandAlone()) AND (NOT ___FlagDebug___) )
                             if( ExistFile(toANSI("$" + FullFileTxtName)) )
                                 RemoveFile( toANSI("$" + FullFileTxtName) );
                             end;
                         end;

                         m_ObjTemlXLS.TabUseProgress(i * 8 + 8);
                         AddDeleteRange(CSaveRange(m_ObjTemlXLS.Sheet.Index, m_TableName, RangeTable.Address));

                     else
                         m_ObjTemlXLS.TabRemProgress();
                         return false;
                     end;
                 else
                     m_ObjTemlXLS.TabRemProgress();
                     return false;
                 end;
             end;
             FillTxtTableFromCSV( FullFileTxtNameServ, SymbolDelimiter );
             i = i + 1;
         end;

         m_ObjTemlXLS.TabRemProgress();

         if( m_ObjTemlXLS.m_PrintXls )
             // Спозиционируемся на первый лист
             if( m_ObjTemlXLS.SheetCount() )
                 m_ObjTemlXLS.SheetChange(m_NumbSheet);
             end;
         end;

         return stat;

   OnError(ObjErr)
       if (showErrorMessage==null) 
         ErrorMessage(ObjErr, "[CTableTmpl.FillTabelFromCSV] Oшибка!");
       else
         if (showErrorMessage==true) 
           ErrorMessage(ObjErr, "[CTableTmpl.FillTabelFromCSV] Oшибка!");
         end;
       end;
       return false;
   end;

   macro Destructor()
   end;
end;


class (CTableTmplBase) CTableTmplPOI(TableName :string, HeaderName:string, ObjTemlXLS:object, TxtHeader:string, HeaderOnPage:bool ) 

/************************** Методы объекта
   macro AddStr()         - Пользовательский метод для добавления строки в таблицу
   macro ClearCurRow()    - Пользовательский метод очищающий значения во всех ячейках диапазона - "строка таблицы"
   macro GetCurAddress()  - Пользовательский метод возвращающий адрес ячейки с именем CellName
   macro EndTable()       - Пользовательский метод для завершения вывода таблицы - удаляет все шаблонные строки 
   macro FillTabelFromCSV()-Пользовательский метод формирования отчета при помощи csv-файла(ов)
   macro GetFormulaSumm() - Пользовательский метод возвращающий формулу для подсчета значений по колонке CellName ячейки таблицы, в пределах форм bRow-eRow, если не заданы, то по всей таблице
*/
   private var workbook:object = NULL;

   InitCTableTmplBase(TableName, HeaderName, ObjTemlXLS, TxtHeader, HeaderOnPage);

   macro GetWorkbook()
       if( workbook == NULL)
           if( m_ObjTemlXLS )
               workbook = m_ObjTemlXLS.GetWorkbook();
               if( workbook )
                   workbook.setTableRange(m_TableName);

                   var Address    = workbook.getTableRangeString(true);
                   var SheetIndex = workbook.getActiveSheetIndex();
                   var StartRow   = workbook.getTableRangeFirstRow() + workbook.getTableRangeCount();

                   InitRange(NULL, SheetIndex, CAddressDiapazon (Address), StartRow);

                   AddDeleteRange(CSaveRange (SheetIndex, m_TableName, m_TableName, true));               
               end;    
           end;
       end;
       return workbook;
   end;

   private macro CloseWorkbook()
      if( workbook )
          workbook.close();
      end;
      workbook = NULL;
   end;
   
   macro AddStr()
       m_NumbRow = m_NumbRow + 1;
             
       if( NOT m_ObjTemlXLS.UseCSV() )
           GetWorkbook().addTemplateStr(GetWorkbook().getActiveSheetIndex(), GetWorkbook().getTableRangeFirstRow());
           if( m_NumbRow > 1 )
               AddressDiapazon.OffSet_Bottom(1);
           end; 
           eRowTable = AddressDiapazon.Get_eRow() + 1;
       else
           if( GetDeleteRanges().Size == 0 )
               AddDeleteRange(CSaveRange (0, m_TableName(), m_TableName(), true));
           end;
       end;
       return;     
   end;

   // Пользовательский метод возвращающий формулу для подсчета значений по колонке
   // CellName ячейки таблицы, в пределах форм bRow-eRow, если не заданы, то по всей таблице 
   // По замечаниям ГПБ убрано наименование листа из формулы 
   macro GetFormulaSummREG( CellName:string, FixRow:bool, bRow:integer, eRow:integer ) : string

       var Formula   :string = "";                               // Строка содержащая результирующую формулу
       var Column    :string = "";                               // Строка с символьным кодом колонки
       var SpecSymbol:string = "";                               // Строка с символом фиксированного диапазона
       var Pos       :integer = 0;                               // Вспомогательные переменные
       var TmpAddress:string  = "";                              // -//-

       if( m_ObjTemlXLS.ExcelLanguageInterface != EXCEL_INTERFACE_RUS )
           Formula = "=SUM(";
       else 
           Formula = "=СУММ(";
       end;

       if( NOT bRow )
           bRow = this.bRowTable;
       end;
       if( NOT eRow ) 
           eRow = this.eRowTable + m_NumbRowsInTable;
       end;

       if( ValType(FixRow) AND FixRow )
           SpecSymbol = "$"; // Использовать фиксированный диапазон
       end;

       TmpAddress = GetWorkbook().getRangeAddress(CellName, true);
 
       if( (Pos = index(TmpAddress, "$")) != 0 )
           TmpAddress = SubStr(TmpAddress, Pos+1);
           if( (Pos = index(TmpAddress, "$")) != 0 )
               Column = SubStr(TmpAddress, 1, Pos-1);
           end;
       end;

       return Formula + String(SpecSymbol, Column, SpecSymbol,bRow, ":", SpecSymbol, Column, SpecSymbol, eRow) + ")";

   OnError( ObjError )
       ErrorMessage( ObjError, "[CTableTmpl.GetFormulaSumm] Ошибка!" );
       return "";
   end;


   /// Пользовательский метод возвращающий формулу для подсчета значений по колонке
   //  CellName ячейки таблицы, в пределах форм bRow-eRow, если не заданы, то по всей таблице 
   macro GetFormulaSumm( CellName:string, FixRow:bool, bRow:integer, eRow:integer ) : string
       var Formula   :string = "";                               // Строка содержащая результирующую формулу
       var Column    :string = "";                               // Строка с символьным кодом колонки
       var SpecSymbol:string = "";                               // Строка с символом фиксированного диапазона
       var Pos       :integer = 0;                               // Вспомогательные переменные
       var TmpAddress:string  = "";                              // -//-

       if( m_ObjTemlXLS.ExcelLanguageInterface != EXCEL_INTERFACE_RUS )
           Formula = "=SUM(";
       else                  
           Formula = "=СУММ(";
       end;

       // Приклеем номер листа
       Formula = String(Formula, "'", m_ObjTemlXLS.SheetName(), "'!");

       if( NOT bRow )
           bRow = this.bRowTable;
       end;
       if( NOT eRow )
           eRow = this.eRowTable + m_NumbRowsInTable;
       end;

       if( ValType(FixRow) AND FixRow )
           SpecSymbol = "$"; // Использовать фиксированный диапазон
       end;

       TmpAddress = GetWorkbook().getRangeAddress(CellName, true); 
         
       if( (Pos = index(TmpAddress, "$")) != 0 )
           TmpAddress = SubStr(TmpAddress, Pos + 1);
           if( (Pos = index(TmpAddress, "$")) != 0 )
               Column = SubStr(TmpAddress, 1, Pos - 1);
           end;
       end;

       return Formula + String(SpecSymbol, Column, SpecSymbol,bRow, ":", SpecSymbol, Column, SpecSymbol, eRow) + ")";

   OnError( ObjError )
       ErrorMessage( ObjError, "[CTableTmpl.GetFormulaSumm] Ошибка!" );
       return "";
   end;

   // Пользовательский метод очищающий значения во всех ячейках диапазона - "строка таблицы" 
   macro ClearCurRow()
       GetWorkbook().clearRow(GetWorkbook().getActiveSheetIndex(), GetWorkbook().getRangeFirstRow(m_TableName), GetWorkbook().getRangeLastRow(m_TableName));         
   end;

   // Пользовательский метод возвращающий адрес ячейки с именем CellName 
   macro GetCurAddress( CellName:string ) : string
       return GetWorkbook().getRangeAddress(CellName, false);
   end;

   // Пользовательский метод для завершения вывода таблицы - удаляет все шаблонные строки 
   macro EndTable()
       if( NOT m_ObjTemlXLS.UseCSV() AND ((GetDeleteRanges().Size == 0) OR (GetDeleteRanges().Size AND (GetDeleteRanges()[0].m_Empty))))
           GetWorkbook().removeRow( GetDeleteRanges()[0].m_NumbSheet, m_TableName);
           bRowTable = bRowTable - 1;
       end; 
 
       m_lsSubItog.Delete();
   end;

   macro GetTableRange( SheetIndex ):string
       if( m_ObjTemlXLS.UseBigReport() )
           if( ValType(SheetIndex) != V_INTEGER )
               SheetIndex = m_NumbSheet;
           end;
           
           return m_lsAddressDiapazon[SheetIndex].Get_Address();
       end;
       return AddressDiapazon.Get_Address();
   end;

   macro FillTableFromCSVLight( FileTxtName:variant, NumbSheet:integer):bool
       var  i:integer = 0;
       var  FileNamesList:tarray  = TArray;
       var  HeaderAddress:CAddressDiapazon = CAddressDiapazon;
       var  DeleteLastSheet:bool = false;

       if( ValType(FileTxtName) == V_STRING )
           FileNamesList[0] = FileTxtName;
       elif( (ValType(FileTxtName) == V_GENOBJ) AND (StrUpr(GenClassName(FileTxtName)) == "TARRAY") )
           FileNamesList = FileTxtName;
       else
           MsgBox( "[CTableTmpl.FillTabelFromCSV] Неверный тип первого параметра функции (функий принимает V_STRING или V_GENOBJ<TARRAY>)!" );
           return false;
       end;

       if( NumbSheet )
           m_NumbSheet = NumbSheet;
       end;

       m_ObjTemlXLS.SetUseCSV();

       GetWorkbook().setActiveSheet(m_NumbSheet);

       m_ObjTemlXLS.TabInitProgress(FileNamesList.Size, "...Открытие и заполнение шаблона данными", "Открытие и заполнение шаблона данными...");
       
       while(i < FileNamesList.Size)
           var FullFileNameServer:string = "";
           var FileFullName:string       = CreateFullFileName(FileNamesList[i], FileFullName);
           var FullFileTxtName           = CreateFullFileName(FileNamesList[i], FullFileNameServer);
           var SheetIndex                = GetWorkbook().getActiveSheetIndex();
           var RecordCount = 0;

           if( i > 0 )
               if( Func_BeforeAddSheet != NULL )
                   ExecMacro2(Func_BeforeAddSheet, this, FullFileTxtName);
               end;
 
               var NewSheetName  = GetWorkbook().createSheetByNameAndIndex(GetWorkbook().getSheetNameAt(0), -1, SheetIndex + 1);
               var NewSheetIndex = GetWorkbook().getSheetIndex(NewSheetName);
               var RowTo = 0;
               var ColTo = 0;
               var Count = 0;

               // Перейти на новый лист
               GetWorkbook().setActiveSheet(NewSheetIndex);
                
               // Добавить на новый лист-продолжение шапку таблицы с номерами столбцов 
               HeaderAddress = CAddressDiapazon(m_AddressRangeTable.Get_Address());
               HeaderAddress.OffSet_Row( -HeaderAddress.Get_bRow() );
               while( Count < HeaderAddress.GetNumbColumn )
                   m_ObjTemlXLS.SetAlign( 0, Count, ALIGN_CENTER );
                   m_ObjTemlXLS.SetValue( 0, Count, Count + 1);
                   Count = Count + 1;
               end;
               m_ObjTemlXLS.SetDiapazon( 0, 0, 0, Count - 1);
               m_ObjTemlXLS.SetBorder();

               RowTo = HeaderAddress.GetNumbRow();

               // Клонировать шаблонную строку на лист-продолжение   
               GetWorkbook().cloneRange(workbook.getSheetsCount() - 1, NewSheetIndex, m_TableName, RowTo, ColTo);

               GetWorkbook().setTableRange(m_TableName);

               m_NumbSheet = NewSheetIndex;
               SheetIndex = NewSheetIndex;

               if( Func_AfterAddSheet != NULL )
                   ExecMacro2(Func_AfterAddSheet, this, FullFileTxtName);
               end;
           end;

           bRowTable = GetWorkbook().getTableRangeFirstRow() + 1;

           // Сохраним шаблонную строку на отдельном листе, так как после сброса она не доступна.
           if( (i == 0) and (m_ObjTemlXLS.UseTotalBook() == false))
               m_ObjTemlXLS.GetReportCreator().saveTemplateRow(GetWorkbook(), SheetIndex, m_TableName);
               DeleteLastSheet = true;
           end;                                
           
           RecordCount = m_ObjTemlXLS.GetReportCreator().importCSVLight(GetWorkbook(), FileFullName, SheetIndex, m_TableName);
          
           AddressDiapazon = CAddressDiapazon (GetWorkbook().getTableRangeString(true));

           i = i + 1;

           m_ObjTemlXLS.TabUseProgress(i, FileNamesList.Size);
       end;

       if( DeleteLastSheet and (m_ObjTemlXLS.UseTotalBook() == false) )
           m_ObjTemlXLS.GetReportCreator().deleteLastSheet(GetWorkbook());
       end;

       m_ObjTemlXLS.TabRemProgress();

       return true;

   OnError(ObjErr)
       m_ObjTemlXLS.TabRemProgress();
       ErrorMessage(ObjErr, "[CTableTmplPOI.FillTableFromCSVLight] Oшибка!");
       return false;
   end;

   macro FillTabelFromCSV( FileTxtName:variant, NumbSheet:integer, SymbolDelimiter:string, Coding:integer ):bool          
       var  i             :integer = 0;       
       var  FileNamesList :tarray  = TArray;  
       var  HeaderAddress :CAddressDiapazon = CAddressDiapazon;
       var  Encode        :string           = WR_lsEncode[WR_CURRENCODE].webCharSet;
       var  IsReversive   :bool             = false;

       // Передали имя файла
       if( ValType(FileTxtName) == V_STRING )
           FileNamesList[0] = FileTxtName;
       elif( (ValType(FileTxtName) == V_GENOBJ) AND (StrUpr(GenClassName(FileTxtName)) == "TARRAY") )
           FileNamesList = FileTxtName;
       else
           MsgBox( "[CTableTmpl.FillTabelFromCSV] Неверный тип первого параметра функции (функий принимает V_STRING или V_GENOBJ<TARRAY>)!" );
           return false;
       end;

       if( NumbSheet )
           m_NumbSheet = NumbSheet;
       end;

       if( NOT SymbolDelimiter )
           SymbolDelimiter = ";";
       end;

       m_ObjTemlXLS.SetUseCSV();

       m_ObjTemlXLS.TabInitProgress(FileNamesList.Size, "...Открытие и заполнение шаблона данными", "Открытие и заполнение шаблона данными...");

       var CurSheetIndex = GetWorkbook().getActiveSheetIndex();
    
       while(i < FileNamesList.Size)
           var FullFileNameServer:string = "";
           var FileFullName:string       = CreateFullFileName(FileNamesList[i], FileFullName);
           var FullFileTxtName           = CreateFullFileName(FileNamesList[i], FullFileNameServer);
           var FileSize:integer          = WR_GetFileSize(FileFullName);
           var FileEmpty:bool            = FileSize == 0;

           if( i > 0 )
               if( Func_BeforeAddSheet != NULL )
                   ExecMacro2(Func_BeforeAddSheet, this, FullFileTxtName);
               end;
               
               var NewSheetName  = GetWorkbook().createSheetByNameAndIndex(GetWorkbook().getSheetNameAt(0), CurSheetIndex, -1);
               var NewSheetIndex = GetWorkbook().getSheetIndex(NewSheetName);
               var RowTo = 0;;
               var ColTo = 0;
               var Count = 0;

               workbook.setActiveSheetByName(NewSheetName);
                
               if( m_HeaderName != "" )
                   GetWorkbook().cloneRange(m_NumbSheet, NewSheetIndex, m_HeaderName, RowTo, ColTo);
                   RowTo = RowTo + GetWorkbook().getRangeRowCount(m_HeaderName);  
               else
                   HeaderAddress = CAddressDiapazon(m_AddressRangeTable.Get_Address());
                   HeaderAddress.OffSet_Row( -HeaderAddress.Get_bRow() );
                   while( Count < HeaderAddress.GetNumbColumn )
                       m_ObjTemlXLS.SetAlign( 0, Count, ALIGN_CENTER );
                       m_ObjTemlXLS.SetValue( 0, Count, Count + 1);
                       Count = Count + 1;
                   end;
                   m_ObjTemlXLS.SetDiapazon( 0, 0, 0, Count - 1);
                   m_ObjTemlXLS.SetBorder();
                   RowTo = HeaderAddress.GetNumbRow();
               end;

               GetWorkbook().setActiveSheet(m_NumbSheet);
               GetWorkbook().cloneRange(m_NumbSheet, NewSheetIndex, m_TableName, RowTo, ColTo);
               GetWorkbook().setTableRange(m_TableName);
               workbook.setActiveSheetByName(NewSheetName);

               if( Func_AfterAddSheet != NULL )
                   ExecMacro2(Func_AfterAddSheet, this, FullFileTxtName);
               end;
               CurSheetIndex = CurSheetIndex + 1;
           end;
           
           var SheetIndex = GetWorkbook().getActiveSheetIndex();

           bRowTable = GetWorkbook().getTableRangeFirstRow() + 1;

           AddDeleteRange(CSaveRange(SheetIndex, m_TableName, m_TableName, FileEmpty));
                                
           m_ObjTemlXLS.GetReportCreator().importCSV(GetWorkbook(), FileFullName, SheetIndex, m_TableName, SymbolDelimiter, Encode, IsReversive);
            
           AddressDiapazon = CAddressDiapazon (GetWorkbook().getTableRangeString(true));

           m_lsAddressDiapazon[SheetIndex] = AddressDiapazon;

           if( Func_AfterAutoFill != NULL )
               ExecMacro2(Func_AfterAutoFill, this, FullFileTxtName, AddressDiapazon.Get_Address());
           end;
                 
           FillTxtTableFromCSV( FullFileNameServer, SymbolDelimiter );

           if( m_ObjTemlXLS.UseBigReport() )
               var TemplFile = "";
               var Name:string  = "";
               var Ext :string  = "";

               SplitFile( FullFileNameServer, Name, NULL );
               SplitFile( m_ObjTemlXLS.TemplateName, NULL, Ext);

               TemplFile = String(Name, Ext);
               TemplFile = CreateFullFileName(TemplFile, TemplFile);
              
               if( m_ObjTemlXLS.Check_SaveAs(@TemplFile) )
                   if( workbook.saveAs(TemplFile) )
                       CloseWorkbook();
                       m_ObjTemlXLS.AddNewSheetTemplateFile(TemplFile);
                       if( NOT m_ObjTemlXLS.OpenTemplate( m_ObjTemlXLS.TemplateName ) )
                          return false;
                       end;
                       workbook = m_ObjTemlXLS.GetWorkbook();
                       workbook.setActiveSheet(m_NumbSheet);
                       workbook.setTableRange(m_TableName);
                   end;
               end;
           end;

           if( (NOT IsStandAlone()) AND (NOT ___FlagDebug___))
               if( ExistFile(toANSI(FullFileTxtName)) )
                   RemoveFile( toANSI(FullFileTxtName) );
               end;
           end;

           i = i + 1;

           m_ObjTemlXLS.TabUseProgress(i, FileNamesList.Size);
       end;    

       m_ObjTemlXLS.TabRemProgress();

       return true;

   OnError(ObjErr)
       m_ObjTemlXLS.TabRemProgress();
       ErrorMessage(ObjErr, "[CTableTmplPOI.FillTabelFromCSV] Oшибка!");
       return false;
   end;

   // Деструктор 
   macro Destructor()
   end;

   // Вызываем GetWorkbook чтобы зарегистрировать таблицу в Java объекте (setTableRange)
   GetWorkbook();
end;

class (CTableTmplBase) CTableTmpl(TableName:string, HeaderName:string, ObjTemlXLS:object, TxtHeader:string, HeaderOnPage:bool)
 
   InitCTableTmplBase(TableName, HeaderName, ObjTemlXLS, TxtHeader, HeaderOnPage);

   if( m_ObjTemlXLS AND m_ObjTemlXLS.m_PrintXls )
       InitRange(ObjTemlXLS.Sheet.Range(TableName), m_ObjTemlXLS.Sheet.Index);
   end;
end;


/****** Класс для создания отчетов на основе шаблонов  
        FileName        - имя открываемого файла
        NewAppMode      - режим создания приложения, true/false  - новое приложение/используем существующее
        PrintText       - вывод в текст
        PrintXls        - вывод строк на  листе в текстовом отчёте
        CountStrOnPage  - количество строк на странице
*/
class (CDAOMSExcel) CTemplateXLS(FileName:string, NewAppMode:bool, PrintText:bool, PrintXls:bool, CountStrOnPage, IsWebService:bool, UsePoiMode:bool, UseBigReportMode:bool, ForceFormatRep:INTEGER )
/************************ Методы объекта
   [Public]
   GetFlagShowIndicator- Пользовательский метод для получения флага показа встроенного индикатора
   OpenTemplate        - Пользовательский метод для открытия шаблона
   RegisterTable       - Пользовательский метод для регистрации таблицы
   SaveAsTemplate      - Пользовательский метод для записи готового файла на диск
   SetPathTemplate     - Пользовательский метод для задания пути до шаблонов
   SetFlagDebug        - Пользовательский метод для включения-выключения режима отладки
   SetFlagShowIndicator- Пользовательский метод для установки флага показа встроенного индикатора
   SetValue_NameCell   - Пользовательский метод для установки значения в именованую ячейку  (диапазона)
   SetValueMultiCell   - Пользовательский метод для вывода значения в несколько полей(см. описание ниже) 
   SetValueMultiCellArr- Пользовательский метод для вывода значения в несколько полей из массива(см. описание ниже)    
   SetNewPage          - Вставка разрыва страницы (используется перед CopyAllSheetInTotalBook, если нужно печатать на новый лист)
   SetXLSXFormat       - Пользовательский метод для установки XLSX-формата сохранения файла
   AddPictureCell      - Пользовательский метод для добавления рисунка  в именованую ячейку  (диапазон)
   SetConvertToPDF     - Пользовательcкий метод для установки флага  конвертации в PDF-формат и имени файла для сохранения.

   ################ Методы работы с общей книгой, позволяющие по одному шаблону сформировать множество документов в одной книге (по закладкам)
   CreateTotalBook         - Создание общей книги для копирования в ней данных списка шаблонов
   OpenTotalBook           - Открытие существующей общей книги для копирования в нее данных списка шаблонов
   CopyAllSheetInTotalBook - Копирование в итоговую (общую) книгу всех закладок из шаблона списка шаблонов
   SaveTotalBook           - Сохранение общей книги

   [Private]
   GetWorkDirName            - Метод для получения рабочего каталога 
   GetLoadNewApplicationMode - Метод для получения значения переменной LOADNEWAPPLICATION */

   var m_PrintText:bool = false;           // Вывод в текст;
   var m_PrintXls :bool = true;            // Вывод в xls
   var m_TxtObjPrint    = NULL;            // Объект вывода в текст

   private var m_CountStrOnPage   :integer = DefaultTxtPageSize; // Количество строк на печатный лист;    
   private var CopyByRows         :bool    = false;
   private var DirName_Template   :string  = "";                 // Имя папки, в которой размещаются шаблоны
   private var m_FlagShowIndicator:bool    = true;               // Флаг показа встроенного индикатора
   private var SaveExistingBook   :bool    = false;              // Сохранять изменения в существующей общей книге
   var BookNew_All                :object  = NULL;               // Указатель на объект общей книги

   var TemplateName:string        = "";  // Имя шаблона (задется при открытии)
   var UniqTemplateName:string    = "";  // Уникальное имя шаблона
   var m_WorkDir:string           = "";  // Рабочий каталог
   var ReportPath:string          = "";  // Путь до готовых отчетов
   var ReportFileName_xls:string  = "";  // Имя сформированного отчета в формате xls
   var m_lsTmpTemplFile:tarray    = TArray; 

   /*--V6-- private*/
   var NeedNewSheet:bool              = true;     // Будем создовать новую закладку или нет
   private var LastPosition           = TArray(); // Позиция на закладке
   private var LastAddedCell:string   = "";
   private var TmpSheet               = NULL;     // Закладка для технических нужд
   private var TmpCell                = NULL;     // Временная ссылка на ячейку
   private var CellKoeffNormal:double = 7.035;    // Ширина ячейки в пиксилях делённая на ширину в пунктах Normal
   private var FormatRep              = WINREP_FORMAT_XLS;
   private var ConvertToPDF:bool      = false;
   private var FileNamePDF:string     = "";
   private var ShowFilePDF:bool       = true;

   // Web properties
   private var jvm = CreateObject("rsjvm", "TJavaHost", "GlobalJavaHost");
   private var reportCreator:object  = NULL;
   private var workbook:object       = NULL;
   private var totalWorkbook:object  = NULL;
   private var m_usePoiMode:bool     = false;
   private var m_useCSV:bool         = false;
   private var m_useBigReport        = false;
   private var m_deleteTemplate      = true;
   private var m_overwriteFile       = true;
   private var m_useMasterTotalBook  = false;
   private var m_ForceFormatRep      = NULL;
   private var m_ProgressIndicator   = CreateProgressIndicator(IsWebService);
   private var m_lsRangesDiapazon:tarray = TArray();
   private var m_lsTemplateFile:tarray   = TArray(); 
   private var m_ProgressCounter = 0; 
   private var m_UseTotalBook:bool   = false;

   macro TabInitProgress( maxValue:integer, status:string, header:string )
       if( m_FlagShowIndicator )
           m_ProgressIndicator.Start( maxValue, status, header );
           m_ProgressCounter = m_ProgressCounter + 1; 
       end;
   end;

   macro TabUseProgress( value:integer, maxValue:integer, text:string)
       if( m_FlagShowIndicator )
           m_ProgressIndicator.Update( value, maxValue, text);
       end;
   end;

   macro TabRemProgress()
       if( m_FlagShowIndicator )
           m_ProgressIndicator.Stop();
           m_ProgressCounter = m_ProgressCounter - 1; 
       end;
   end;
 
   macro TabRemProgressAll()
       if( m_FlagShowIndicator )
           while( m_ProgressCounter > 0 )
               m_ProgressIndicator.Stop();
               m_ProgressCounter = m_ProgressCounter - 1; 
           end;
       end;
   end;
 
   macro GetReportCreator()             
       if (reportCreator == NULL)                
           reportCreator = jvm.callStaticMethod("ru.softlab.rsbank.poireports.ReportCreator", "getInstance")
       end;
       return reportCreator;
   end;

   macro GetWorkbook()
     if (workbook)
        return workbook;
     end;
     return null;
   end;

   macro UsePoi() : bool
       return m_usePoiMode;
   end;

   macro UseTotalBook() : bool
       return m_UseTotalBook;
   end;


   /**** (Private) Метод для получения значения переменной LOADNEWAPPLICATION */
   private macro GetLoadNewApplicationMode():bool
       return WR_GetLoadNewApplicationMode();
   end;

   private macro GetUsePoiMode():bool
       var usePoiMode:bool = false;
       var StrErr:string = "";
       var RegKey:string = "BANK_INI\\WINDOWS REPORT\\ИСПОЛЬЗОВАТЬ APACHE POI";
  
       if( NOT GetRegistryValue(RegKey, V_UNDEF, usePoiMode, StrErr) )
           MsgBox("В реестре не найден ключ ["+RegKey+"]!|", StrErr);
       end;    
       return usePoiMode;
   end;
   
   if( ValType( UsePoiMode ) )
       m_usePoiMode = UsePoiMode;
   else
       m_usePoiMode = GetUsePoiMode();
   end;

   if( m_usePoiMode )
       reportCreator = GetReportCreator();
       this.ExcelLanguageInterface = LANGUAGE_ENG;
   else
       // Конструктор базового объекта
       if( ValType(NewAppMode) )
           InitCDAOMSExcel(FileName, NewAppMode); 
       else
           InitCDAOMSExcel(FileName, GetLoadNewApplicationMode()); 
       end;
   end;

   if( ValType(PrintText) )
       m_PrintText = PrintText; 
   end;

   if( ValType(CountStrOnPage) )
       m_CountStrOnPage = CountStrOnPage;
   end;

   if( ValType(PrintXls) )   
       m_PrintXls = PrintXls;
   end;

   if( ValType(UseBigReportMode) )
       m_useBigReport = UseBigReportMode;     
   end;

   if( ValType(ForceFormatRep) )
       m_ForceFormatRep = ForceFormatRep;
   end;

   macro UseCSV() : bool
       return m_useCSV;
   end;

   macro SetUseCSV()
       m_useCSV = true;
   end;

   macro ReSetUseCSV()
       m_useCSV = false;
   end;

   macro UseMasterTotalBook()
       return m_useMasterTotalBook;
   end;

   macro NeedMasterTotalBook()
       m_useMasterTotalBook = true;
   end;
   
   macro UseBigReport() : bool
       if( NOT UsePoi() )
           return FALSE;
       end;

       return m_useBigReport;
   end;

   macro AddRangesDiapazon(Index:integer, Diapazon:CAddressDiapazon)
       
       if( m_lsRangesDiapazon[Index] == null ) 
           m_lsRangesDiapazon[Index] = TArray();
       end;
       m_lsRangesDiapazon[Index][m_lsRangesDiapazon[Index].size] = Diapazon;
   end;

   macro AddTemplateFile(Index:integer, FileName:string)
       if( m_lsTemplateFile[Index] == null ) 
           m_lsTemplateFile[Index] = TArray();
       end;
       m_lsTemplateFile[Index][m_lsTemplateFile[Index].size] = FileName;

   end;

   macro RemoveTemplateFile()
       if( NOT ___FlagDebug___ )
           var i = 0;
           while( i < m_lsTemplateFile.Size )
              if( (ValType(m_lsTemplateFile[i]) == V_GENOBJ) AND (strUpr(GenClassName(m_lsTemplateFile[i])) == "TARRAY") )
                  var j = 0;
                  while( j < m_lsTemplateFile[i].Size )
                      if( ExistFile( toANSI(m_lsTemplateFile[i][j])) )
                          RemoveFile( toANSI(m_lsTemplateFile[i][j]) );
                      end;
                      j =  j + 1;
                  end;
              else
                  if( ExistFile( toANSI(m_lsTemplateFile[i])) )
                      RemoveFile( toANSI(m_lsTemplateFile[i]) );
                  end;
              end;
              i = i + 1;
           end;
       end;
       m_lsTemplateFile.size = 0;
       m_lsRangesDiapazon.size = 0;
   end;

   macro AddNewSheetTemplateFile(FileName:string)
       m_lsTemplateFile[m_lsTemplateFile.size()] = FileName;
   end;

   // Позиция вставки следующего блока для CopyAllSheetTotalBook
   macro GetLastPosition( Sheet:variant ):integer
       var sheetIndex;
       
       if( UsePoi() )
           sheetIndex = totalWorkbook.getSheetIndex(Sheet);
           if( sheetIndex < 0 ) 
              return 1;
           end;
       else
           sheetIndex = BookNew_All.Sheets(Sheet).Index;
       end;

       var Position = LastPosition[sheetIndex];
       if( NOT ValType(Position) )
          Position = LastPosition[sheetIndex] = 1; 
       end; 
   
       return Position;
   end;

   macro SetHeaderTxtTable(Header)
       if( NOT m_TxtObjPrint )
           m_TxtObjPrint = CMakeReport( Header, NULL, m_CountStrOnPage );
       else
           m_TxtObjPrint.AddNewSheetBreak( "", Header );
       end;
   end;

   /*Добавить не разрывную по листам область (принимает имя именнованого диапозона)*/ 
   macro AddNotRipRegion(NameRegion)
       var LocNotRipRegion  = Sheet.Range(NameRegion);
       var i = 2;
       while(i <= LocNotRipRegion.Rows.count)
           if(LocNotRipRegion.Rows(i).PageBreak != xlPageBreakNone)
              LocNotRipRegion.Rows(1).PageBreak = xlPageBreakManual;
           end;
           i = i+ 1;
       end;
   end;

   /**** (Public) Создание общей книги для копирования в ней данных списка шаблонов */
   macro CreateTotalBook() : bool
       if( m_PrintXls )
           if( UsePoi() )  
               if( reportCreator == null )
                   return false;
               end;
               
               if( UseBigReport() )
                   totalWorkbook = reportCreator.addWorkbookSXSSF();
               else
                   if( FormatRep == WINREP_FORMAT_XLSX )
                       totalWorkbook = reportCreator.addWorkbookXLSX();
                   else
                       totalWorkbook = reportCreator.addWorkbookXLS();
                   end;
               end;
           else
               // Проверим создание приложения
               if( NOT this.vrt_CreateApplicationExcel() )
                   return false; 
               end;
               // Для того, чтобы не сохранять буфер обмена (занимает кучу времени!!!)
               this.Application.CutCopyMode = False;

               // Добавим книгу
               this.Application.Workbooks.Add();

               // Получим ссылку на добавленную книгу, она последняя в коллекции книг
               BookNew_All = this.Application.Workbooks.Item( this.Application.Workbooks.Count );

               // Удалим все пустые закладки (с которыми MSExcel создает пустую книги),
               // кроме последней, т.к. она не удаляется, она будет удалена в методе SaveTotalBook
               while( BookNew_All.Sheets.Count > 1 )
                  BookNew_All.Sheets(BookNew_All.Sheets.Count).Delete();
               end;
           end;

           m_UseTotalBook = true;

           return true;
       end;
           OnError( ObjError )
              ErrorMessage(ObjError, "[CTemplateXLS.CreateTotalBook] Oшибка!");
              return false;
   end;

   macro PoiOpenTotalBook (TotalBookName:string) : bool
       var TmpFileName:string = "";
       
       if( NOT TotalBookName )
           MsgBoxEx("[CTemplateXLS.PoiOpenTotalBook]!|Не указано имя книги!", MB_OK+MB_ERROR, IND_OK, "Ошибка!");
           return false;
       end;
        
       if( reportCreator == null )
           return false;
       end;

       if( Index(toAnsi(TotalBookName), ":") OR Index(toAnsi(TotalBookName), "\\\\") )
           TmpFileName = TotalBookName;
       else
           if( NOT IsStandAlone() )
               if( NOT CopyFile( "$" + toANSI(GetCurDir(TRUE) + "\\" + SubStr(toAnsi(NameDirTerm), 2) + TotalBookName), toANSI(this.m_WorkDir + "\\" + TotalBookName)) )
                   return false;
               end;
           end;
           TmpFileName = this.m_WorkDir + "\\" + TotalBookName;
       end;
                               
       totalWorkbook = reportCreator.openWorkbook(TmpFileName);
       
       return true;
       
       OnError( ObjError )
           ErrorMessage(ObjError, "[CTemplateXLS.PoiOpenTotalBook] Oшибка!");
           return false;
   end;

   /**** (Public) Открытие существующей общей книги для копирования в нее данных списка шаблонов */
   macro OpenTotalBook (TotalBookName:string) : bool

       if( UsePoi() )
           return PoiOpenTotalBook( TotalBookName );
       end;   

       var TmpFileName:string = "";
       
       if( m_PrintXls )  
           if( NOT TotalBookName )
               MsgBoxEx("[CTemplateXLS.OpenTotalBook]!|Не указано имя книги!", MB_OK+MB_ERROR, IND_OK, "Ошибка!");
               return false;
           end;

           if( UsePoi() AND (reportCreator == null))
               return false;
           else
               // Проверим создание приложения
               if( NOT CreateApplication() )
                   return false; 
               end;
           end;

           if( Index(toAnsi(TotalBookName), ":") OR Index(toAnsi(TotalBookName), "\\\\") )
               TmpFileName = TotalBookName;
           elif( NOT IsStandAlone() )
               TmpFileName = GetCurDir(TRUE) + "\\" + SubStr(toAnsi(NameDirTerm), 2) + "\\" + TotalBookName;
           else
               TmpFileName = this.m_WorkDir + "\\" + TotalBookName;
           end;
                                       
           this.Open(TmpFileName);

           // Добавим новый лист
           this.SheetAdd();
              
           BookNew_All = this.Book;
          
           return true;
       end;        
       OnError( ObjError )
           ErrorMessage(ObjError, "[CTemplateXLS.OpenTotalBook] Oшибка!");
           return false;
   end; 

   macro ExistSheetTotalbook(sheet:string):bool 
       var i = 1;

       if( UsePoi() )
           return totalWorkbook.existsSheet(sheet); 
       end;

       while( i <= BookNew_All.Sheets.Count )
          if( BookNew_All.Sheets(i).Name ==  sheet )
              return true;
          end;
          i = i + 1;
       end;  
 
       return false; 
   end;

   macro SetCopyByRows(_CopyByRows:bool)
       CopyByRows = _CopyByRows;
   end;
   macro GetCopyByRows()
       return CopyByRows;
   end;

   macro GetTargetPastePos(sheetName:string, copyPos:string, pastePos:variant)

       if( NOT ExistSheetTotalbook( sheetName ) )
           return 0;
       end;

       var address:string = ""; 
       var pastePosString = "";
       var pastePosInt    = 0;
      
       if( ValType(pastePos)  == V_STRING) 
           pastePosString = pastePos;
       elif( ValType(pastePos) == V_INTEGER)
           pastePosInt = pastePos;
       end;

       if( UsePoi() )
           address = workbook.getRangeAddress(copyPos, true);
       else
           address = Sheet.Range(copyPos);
       end;

       var copyAddress:CAddressDiapazon = CAddressDiapazon( address );

       if( pastePosString != "" )
           if( UsePoi() )
               address = workbook.getRangeAddress(pastePosString, true);           
           else
               address = Sheet.Range(pastePosString);
           end;

           var pasteAddress:CAddressDiapazon = CAddressDiapazon( address );  

           return pasteAddress.Get_eRow() + copyAddress.GetNumbRow();
       else
           return GetLastPosition( sheetName ) + pastePosInt + copyAddress.GetNumbRow();       
       end;                   

       return 0;
   end;

   /**** (Public) Копирование в итоговую (общую) книгу всех закладок из шаблона списка шаблонов */
   macro CopyAllSheetInTotalBook(SheetName:string,       // Имя закладки,по умолчанию имя закладки из шаблона
                                 _FlagSheet:bool,        // true - на новую закладку, на существующую
                                 _CopyPos:string,        // Что копировать м.б. диапазон вида "A1:T60" или имя именованного диапозона
                                 _PastePos:variant,
                                 _PasteSheetName:variant // Имя закладки, в которую копировать
                                ) : bool  

       macro SetUniqeName(_Name:String):string // Установка уникального имени

            var Name =_Name;
            var Count:integer = 0;
            var j = 1;
            var k = 1;
            Count = BookNew_All.Sheets.Count;
            while( j <= Count )
                while(Name == BookNew_All.Sheets(j).Name); 
                    Name =  _Name + "(" + k + ")";
                    j = 0;                    
                    k = k + 1;
                    break; 
                end;
                j = j + 1;        
            end; 
            return Name;      
       end; 

       macro GetSheetName( l_SheetName:string )
          var TmpSheetName:string = l_SheetName;
          if( StrLen(TmpSheetName) > MAX_LENGTH_NAME_SHEET )
             TmpSheetName = SubStr(TmpSheetName, 1, MAX_LENGTH_NAME_SHEET);
          end;
          return TmpSheetName;
       end;

       if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
          // Обрежем если имя пришло большое
          _PasteSheetName = GetSheetName(_PasteSheetName); 
       end;
       
       if( m_PrintXls )
           var FlagSheet:bool   = true,
               CopyPos  :string = "",
               PastePos :string = "",
               SheetNameFrom:string = "",
               SheetNameTo:string = "";


           // В новые закладки или на одну закладку
           if( ValType(_FlagSheet) == V_BOOL ) 
               FlagSheet = _FlagSheet;     
           end;

           // Откуда копировать
           if( ValType(_CopyPos) == V_STRING ) 
               CopyPos = _CopyPos
           end; 

           var i:integer = 1, Name, OldCutCopyMode;
           var rowCount = 0;
           var totalSheetCount = 1;
    
           
           if( UsePoi() )
               var PastePosInt:integer = 0;

               if( ValType(_PastePos)  == V_STRING) 
                   PastePos = _PastePos;
                   PastePosInt = 0;
               elif( ValType(_PastePos) == V_INTEGER)
                   PastePos    = "";
                   PastePosInt = _PastePos;
               end;

               CopyPos = StrSubst(CopyPos, "$", "");   

               TabInitProgress( m_lsTemplateFile.Size, "Копирование листа в общую книгу", "Копирование листа в общую книгу" );

               if( UseBigReport() AND UseCSV() AND m_lsTemplateFile.Size)
                   i = 0;
                   while( i < m_lsTemplateFile.Size )
                       workbook = GetReportCreator().openWorkbook(m_lsTemplateFile[i]);
                       if( workbook )
                           if( i == 0 )
                               if( (ValType(SheetName) == V_STRING) )
                                  SheetChange(SheetName);
                               else
                                  SheetChange(workbook.getSheetName());
                               end;    
                           else
                               SheetChange(workbook.getSheetsCount());
                           end;

                           if( FlagSheet )
                               SheetNameFrom = workbook.getSheetName();
                               SheetNameTo = workbook.getSheetNameAt(0);

                               if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                                   SheetNameTo = _PasteSheetName;
                               end;

                               if( i > 0 )
                                   SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo); 
                               end;

                               workbook.copySheet(totalWorkbook, SheetNameFrom, SheetNameTo);
                               NeedNewSheet = true;
                           else  
                               if( (ValType(SheetName) != V_STRING) OR (SheetName != workbook.getSheetName()))
                                   SheetName = workbook.getSheetName();
                               end;

                               if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                                   SheetNameFrom = SheetName;
                                   SheetNameTo = _PasteSheetName;
                               elif( SheetName != null )
                                   SheetNameFrom = SheetName;
                                   SheetNameTo = SheetName;
                               else
                                   SheetNameFrom = workbook.getSheetName();
                                   SheetNameTo = totalworkbook.getSheetName();
                               end;

                               if( i == 0 )
                                   if( NOT totalWorkbook.existsSheet(SheetNameTo) )
                                       SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo); 
                                       workbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo); 
                                   end;
                                   workbook.copyRangeToSheet(totalWorkbook, SheetNameFrom, SheetNameTo, CopyPos, PastePos, PastePosInt);
                               else 
                                   SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo); 
                                   workbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo); 
                                   NeedNewSheet = true;

                                   workbook.copySheet(totalWorkbook, SheetNameFrom, SheetNameTo);
                               end;

                               rowCount = workbook.getRangeRowCount(CopyPos);
                           end;
                           totalSheetCount = totalWorkbook.getSheetsCount();
                           workbook.close();
                           workbook = null;
                       end;
                       i = i + 1;
                       TabUseProgress( i, m_lsTemplateFile.Size );
                   end;

                   RemoveTemplateFile();
               else  
                   if( FlagSheet )
                       i = 1;
                       while( i <= SheetCount() )
                           SheetChange(i);

                           SheetNameFrom = workbook.getSheetName();
                           SheetNameTo = workbook.getSheetName();

                           if( totalWorkbook.existsSheet(SheetNameTo) )
                              SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo);
                              workbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo);       
                           end;

                           workbook.copySheet(totalWorkbook, SheetNameFrom, SheetNameTo);

                           totalSheetCount = totalWorkbook.getSheetsCount();
                           NeedNewSheet = true;
                           i = i + 1;
                           m_ProgressIndicator.Update( i, m_lsTmpTemplFile.Size );
                       end;
                   else   
                       if( UseBigReport() AND (ValType(SheetName) == V_STRING) )
                           SheetChange(SheetName);
                       end;

                       if( (ValType(SheetName) != V_STRING) OR (SheetName != workbook.getSheetName()))
                           SheetName = workbook.getSheetName();
                       end;

                       if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                           SheetNameFrom = SheetName;
                           SheetNameTo = _PasteSheetName;
                       elif( SheetName != null )
                           SheetNameFrom = SheetName;
                           SheetNameTo = SheetName;
                       else
                           SheetNameFrom = workbook.getSheetName();
                           SheetNameTo = totalworkbook.getSheetName();
                       end; 
                       

                       if( NOT totalWorkbook.existsSheet(SheetNameTo) )
                           NeedNewSheet = true;
                       end;  

                       if( NeedNewSheet)
                           SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo);
                           workbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo);
                       else
                           if( (PastePos == "") AND (totalWorkbook.getLastAddedRow() != 0))
                               var RowNum = totalWorkbook.getLastAddedRow() + 1 + PastePosInt;
                               var ColNum = workbook.getRangeFirstCol(CopyPos);
                               PastePos = workbook.getCellRangeAddress(RowNum, RowNum, ColNum, ColNum);
                           end;
                       end;        

                       workbook.copyRangeToSheet(totalWorkbook, SheetNameFrom, SheetNameTo, CopyPos, PastePos, PastePosInt);

                       totalSheetCount = totalWorkbook.getSheetIndex(SheetNameTo);
                       rowCount = workbook.getRangeRowCount(CopyPos);
                       LastPosition[totalSheetCount] = totalWorkbook.getLastRowNum(SheetNameTo);
                   end;       

               end;   

               if( NeedNewSheet )
                   NeedNewSheet = false;
                   LastPosition[totalSheetCount] = 0;
               end;

               TabRemProgress();
               
               return true;
           end;   

           OldCutCopyMode = this.Application.CutCopyMode;
           this.Application.CutCopyMode = False;

           i = 1;
           if( FlagSheet ) // true - на новую закладку
               // Номер добавленной вкладки
               var indexAddSheet:integer = 0; 
               while( i <= Book.Sheets.Count )
                    BookNew_All.Sheets(1).Activate(); // всегда приходится активировать закладку с которой работаем, т.к 
                                                      // при некоторых операциях активация сбивается
                    NeedNewSheet = true;          
                    indexAddSheet = BookNew_All.Sheets.Count;    
                    this.Book.Sheets(i).Copy(BookNew_All.Sheets(BookNew_All.Sheets.Count/*в хвост*/));

                    if(ValType(SheetName)) 
                        BookNew_All.Sheets.Item(indexAddSheet).Name = SetUniqeName(SheetName);
                    end;

                    BookNew_All.Sheets.Item(indexAddSheet).Activate();
                    this.Book.Sheets(i).Cells.Copy(BookNew_All.Sheets.Item(indexAddSheet).Range("A1"));  // ячейки перекопируем т.к. строки > 255 обрезаются   
                    this.Book.Sheets(i).Range("A1").Copy();                                              // очистим буфер обмена
                    this.Application.Range("A1").Select;                                                 // снимем выделение

                    totalSheetCount = BookNew_All.Sheets.count;
                    i = i + 1;
               end;
           else
               if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                   if(Not ExistSheetTotalBook(_PasteSheetName))
                       NeedNewSheet = true;
                   else
                       BookNew_All.Sheets(_PasteSheetName).Activate;
                       totalSheetCount = BookNew_All.Sheets( _PasteSheetName ).Index;
                   end;
               elif( SheetName != null )
                   if(Not ExistSheetTotalbook(SheetName))
                       NeedNewSheet = true;
                   else
                       BookNew_All.Sheets(SheetName).Activate;
                       totalSheetCount = BookNew_All.Sheets( SheetName ).Index;
                   end;
               end;

               if(NeedNewSheet)
                   BookNew_All.Sheets(1).Activate();
                   NeedNewSheet = false ;
                   totalSheetCount = BookNew_All.Sheets.count;
                   Sheet.Copy(BookNew_All.Sheets(totalSheetCount));
                   BookNew_All.Sheets(totalSheetCount).Cells.Delete;
                   LastPosition[totalSheetCount] = 1;     
                   if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                       BookNew_All.Sheets(totalSheetCount).Name = _PasteSheetName;
                   elif( SheetName )
                       BookNew_All.Sheets(totalSheetCount).Name = SheetName;
                   end;
               end;
/*--V6-- begin*/
                 if( _PasteSheetName != null )
                    if(ValType(_PasteSheetName) == V_INTEGER) 
                       totalSheetCount = _PasteSheetName;
                    elif(ValType(_PasteSheetName) == V_STRING)
                       totalSheetCount = BookNew_All.Sheets( _PasteSheetName ).Index;
                    end;
                 end;
/*--V6-- end*/
               if(ValType(_PastePos)  == V_STRING) //куда копировать
                   PastePos = _PastePos;
               elif(ValType(_PastePos) == V_INTEGER)
                   LastPosition[totalSheetCount] = LastPosition[totalSheetCount] + _PastePos;
                   PastePos = "A"+ LastPosition[totalSheetCount] ;

               else
                   PastePos = "A" + LastPosition[totalSheetCount];
               end;

               if(CopyPos)
                   if(GetCopyByRows())
                       var str = String(Sheet.Range(CopyPos).Row,":",Sheet.Range(CopyPos).Row + Sheet.Range(CopyPos).Rows.count - 1);
                       Sheet.Rows(str).Copy();
                   else
                       Sheet.Range(CopyPos).Copy();
                   end;
               else    Sheet.Cells.Copy();
               end;

               BookNew_All.Sheets(totalSheetCount).Activate();
               if( PastePos)
                   BookNew_All.Sheets(totalSheetCount).Range(PastePos).PasteSpecial(xlPasteColumnWidths); // Вставим шаблонную строку с признаком "Сохранять ширину оригинала"
                   BookNew_All.Sheets(totalSheetCount).Range(PastePos).PasteSpecial(xlPasteAll         ); // Вставим шаблонную строку с признаком "Сохранять данные"
                   Sheet.Range("A1").Copy();                                                    // Очистим буфер обмена
               end;

               if(ValType(_PastePos)  == V_STRING ) 
                   var CellPos = CAddress(_PastePos);
                   LastPosition[totalSheetCount] = max(LastPosition[totalSheetCount], CellPos.Get_bRow() + Sheet.Range(CopyPos).Rows.Count);
               else
                   LastPosition[totalSheetCount] = LastPosition[totalSheetCount] + Sheet.Range(CopyPos).Rows.Count;
               end;

               BookNew_All.Sheets(totalSheetCount).Activate();
           end; 
           this.Application.CutCopyMode = OldCutCopyMode;
           return true;
        end;

      OnError( ObjError )
         ErrorMessage(ObjError, "[CTemplateXLS.CopyAllSheetInTotalBook] Oшибка!");
         return false; 
   end;

   /**** (Public) Копирование в итоговую (общую) книгу всех закладок из шаблона списка шаблонов */
   //Ex: Cохраняет высоту строк при копировании диапазона, а также позволяет копировать изображение при копировании диапазона
   macro CopyAllSheetInTotalBookEx( SheetName:string,  // Имя закладки,по умолчанию имя закладки из шаблона
                                    _FlagSheet:bool,   // true - на новую закладку, на существующую
                                    _CopyPos:string,   // Что копировать м.б. диапозон вида "A1:T60" или имя именованного диапозона
                                    _PastePos:variant, // сколько строчек отступить (int) или куда на новом листе копировать, например, "A1"
                                    _PicName:string,   // Имя копируемого изображения(например,"Рисунок 1") Параметр актуален при _FlagSheet = false
                                    _Pic_X,            // Координаты смещения изображения по оси Х         
                                    _Pic_Y             // Координаты смещения изображения по оси Y   
                                 ) : bool
       macro SetUniqeName(_Name:String):string 
            var Name =_Name;
            var Count:integer = 0;
            var j = 1;
            var k = 1;
            Count = BookNew_All.Sheets.Count;
            while( j <= Count )
                while(Name == BookNew_All.Sheets(j).Name); 
                    Name =  _Name + "(" + k + ")";
                    j = 0;                    
                    k = k + 1;
                    break; 
                end;
                j = j + 1;        
            end; 
            return Name;      
       end; 

       // Флаг должен быть сброшен, чтобы корректно происходило копирование на существующую закладку
       NeedNewSheet = false; 

       if( m_PrintXls )
           var FlagSheet:bool = true,
               Pic_X = 2,
               Pic_Y = 2,
               CopyPos  :string="",
               PastePos :string="";

           // В новые закладки или на одну закладку
           if( ValType(_FlagSheet) == V_BOOL) 
               FlagSheet = _FlagSheet;     
           end;

           // Откуда копировать
           if( ValType(_CopyPos) == V_STRING) 
               CopyPos = _CopyPos
           end;

           if( ValType(_Pic_X) == V_INTEGER)
               Pic_X = _Pic_X;
           end;

           if( ValType(_Pic_Y) == V_INTEGER)
               Pic_Y = _Pic_Y;
           end;
           
           var i:integer = 1, Name, OldCutCopyMode;
           var count = 1; 

           OldCutCopyMode = this.Application.CutCopyMode;
           this.Application.CutCopyMode = False;

           i = 1;
           // Номер добавленной вкладки
           var indexAddSheet:integer = 0; 

           if( FlagSheet )  // true - на новую закладку
               while( i <= Book.Sheets.Count )
                  NeedNewSheet  = true;
                  indexAddSheet = BookNew_All.Sheets.Count;

                  // Всегда приходится активировать закладку с которой работаем, т.к при некоторых операциях активация сбивается
                  BookNew_All.Sheets(indexAddSheet).Activate(); 
                  this.Book.Sheets(i).Copy(BookNew_All.Sheets(BookNew_All.Sheets.Count/*в хвост*/));

                  if( ValType(SheetName) )
                      BookNew_All.Sheets.Item(indexAddSheet).Name = SetUniqeName(SheetName);
                  end;

                  BookNew_All.Sheets.Item(indexAddSheet).Activate();
                  this.Book.Sheets(i).Cells.Copy(BookNew_All.Sheets.Item(indexAddSheet).Range("A1"));  // ячейки перекопируем т.к. строки > 255 обрезаются    
                  this.Application.Range("A1").Select;                                                 // снимем выделение
                  
                  count = BookNew_All.Sheets.count;

                  //После копирования закладки в главную книгу, позицию устанавливаем на посл. строку для корректного дописывания данных в закладку
                  LastPosition[count] = BookNew_All.Sheets.Item(indexAddSheet).Cells.SpecialCells(xlLastCell).Row;
                  i = i + 1;
               end;
           else
               if( SheetName != null )
                   if( NOT ExistSheetTotalbook(SheetName) )
                       NeedNewSheet = true;
                   else
                       BookNew_All.Sheets(SheetName).Activate;    
                       count = BookNew_All.Sheets( SheetName ).Index ;                      
                   end;
               end;

               if( NeedNewSheet )
                   BookNew_All.Sheets(1).Activate();
                   NeedNewSheet = false ;
                   count = BookNew_All.Sheets.count;
                   Sheet.Copy(BookNew_All.Sheets(count));
                   LastPosition[count] = 1;     
                   if( SheetName ) 
                       BookNew_All.Sheets(count).Name = SheetName;
                   end;
               end;

               if( ValType(_PastePos)  == V_STRING ) //куда копировать
                  PastePos = _PastePos;
               elif( ValType(_PastePos) == V_INTEGER )
                  LastPosition[count] = LastPosition[count] + _PastePos;
                  PastePos = "A"+ LastPosition[count] ;
               else
                   LastPosition[count] = LastPosition[count] + Sheet.Range(CopyPos).Rows.Count;
               end;

               BookNew_All.Sheets(count).Activate();
           end; 
           this.Application.CutCopyMode = OldCutCopyMode;
           return true;
        end;
      OnError( ObjError )
      ErrorMessage(ObjError, "[CTemplateXLS.CopyAllSheetInTotalBook] Oшибка!");
      return false; 
   end;

   /**** (Public) Сохранение общей книги */
   macro SaveTotalBook( NameFile:string, ShowAppl:bool, _SaveExistingBook:bool ) : bool
         if( m_PrintXls AND (NOT UsePoi()) )
             // Удалим лишнюю закладку. т.к. при создании книги в ней всегда есть один лист 
             // (который нельзя удалить в начале после создания, т.к. MSExcel не дает удалить последний лист)
             // Этот лишний лист будет последним, т.к. вставляли Мы перед ним 
             if( BookNew_All.Sheets.Count > 1 )
                 BookNew_All.Sheets(BookNew_All.Sheets.Count).Delete();
             end;
             this.Book = BookNew_All;
         end;

         if( ValType(_SaveExistingBook) )
             SaveExistingBook = _SaveExistingBook;
         end;
         
         if( m_PrintXls )
             if( UsePoi() )
                 if (SaveExistingBook)
                     
                     workbook = totalWorkbook;

                     this.SaveAsTemplate(NameFile, ShowAppl);
                 else
                     if( totalWorkbook.getSheetsCount() > 1 )
                         totalWorkbook.removeSheet(0);
                     end;              
   
                     this.SaveAsTotalbook(NameFile, ShowAppl);

                     workbook = totalWorkbook;
                 end;
             else
                 this.SaveAsTemplate(NameFile, ShowAppl);
             end;
           
         end;

         OnError( ObjError )
            ErrorMessage(ObjError, "[CTemplateXLS.SaveTotalBook] Oшибка!");
            return false;
   end;

   macro CopyTotalBookToWorkBook() : bool
         if( NOT UsePoi() )
             return true;
         end;

         if( totalWorkbook.getSheetsCount() > 1 )
             totalWorkbook.removeSheet(0);
         end;      
        
         workbook = totalWorkbook;

         OnError( ObjError )
            ErrorMessage(ObjError, "[CTemplateXLS.CopyTotalBookToWorkBook] Oшибка!");
            return false;
   end;


   macro SaveSubTotalBook( NameFile:string, ShowAppl:bool ) : bool
         var stat:bool = true;

         if( m_PrintXls )
             m_deleteTemplate = false;
             m_overwriteFile  = false;

             if( NOT UsePoi() )
                 if( BookNew_All.Sheets.Count > 1 )
                     BookNew_All.Sheets(BookNew_All.Sheets.Count).Delete();
                 end;
                 var saveBook = this.Book;
                 this.Book = BookNew_All;
                 stat = this.SaveAsTemplate(NameFile, ShowAppl);
                 this.Book = saveBook;
             else
                 if( totalWorkbook.getSheetsCount() > 1 )
                     totalWorkbook.removeSheet(0);
                 end;              
                 stat = this.SaveAsTotalbook(NameFile, ShowAppl);
             end;
         end;
         return stat;

         OnError( ObjError )
             ErrorMessage(ObjError, "[CTemplateXLS.SaveSubTotalBook] Oшибка!");
             return false;
   end;

   macro SaveMasterTotalBook( NameFile:string, ReportFileNames:TArray, ShowAppl:bool) : bool 
         var stat:bool = true;

         if( NOT m_useMasterTotalBook )
             return false;
         end;

         if (ReportFileNames.Size == 0)
             return false;
         end;

         var savePoiMode = m_usePoiMode;
         m_usePoiMode = false;

         if( CreateTotalBook() )
             var i :integer = 0;
             var indexSheet:integer = 0;
         
             while( i < ReportFileNames.Size )
                 if( this.Open(ReportFileNames[i]) )
                     var j = 1;
                     while( j <= this.Book.Sheets.Count )
                         this.BookNew_All.Sheets(1).Activate(); 
                         indexSheet = BookNew_All.Sheets.Count;    
                         this.Book.Sheets(j).Copy(BookNew_All.Sheets(BookNew_All.Sheets.Count));
                         j = j + 1;                            
                     end;
                     this.Close();
                 end;
                 i = i + 1;
             end;
         
             var saveBook = this.Book;
             stat = SaveTotalBook( NameFile, ShowAppl);
             this.Book = saveBook;
         end;

         return stat;
 
         m_usePoiMode = savePoiMode;
         OnError( ObjError )
             ErrorMessage(ObjError, "[CTemplateXLS.SaveMasterTotalBook] Oшибка!");
             return false;
   end;


   macro SetToolCategory(workbook:object)
       var Category:string = "CTemplateXLS";

       if( m_useCSV )
           Category = "CTemplateXLS + CTableTmpl";
       end;

       if (NOT UsePoi())
           this.SetDocProperty(NULL, NULL, NULL, Category);  
       else
           if (workbook != NULL)
           workbook().setApplicationName("Apache POI");
           workbook().setCategory(Category); 
       end; 
   end;
   end;

   /**** (Private) Метод для получения рабочего каталога */
   private macro GetWorkDirName() : string
      var DirName:string = "", /* Строка с именем пути                         */
          StrErr :string = ""; /* Строка с ошибкой определения временной папки */

      GetRegistryValue( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR",
                        V_STRING, DirName, StrErr );

      /* Если в реестре нет ключа "TEXTDIR" или значение не задано, то поищем в bank.ini */
      if( NOT DirName )
          DirName = GetIniString( "TEXTDIR" );
      end;

      if( NOT DirName )
          DirName = GetEnv("TEMP");
          if( NOT DirName )
              DirName = GetEnv("TMP");
          end;
      else
          /* Если первый символ в DirName - это точка, то значит путь относительный, */
          /* тогда приклеем к нему CyrDir, иначе путь абсолютный                     */
          if( SubStr(DirName, 1, 1) == "." )
              DirName = GetCurDir(false) + "\\" + DirName;
          end;
      end;

      return DirName;
   end;

   // DEF-69958, в отчете 'Реестр ВУ' случаются ошибки в этом месте, непонятно почему. Добавил обрабочик ошибок.
   private macro TogglePreview
      this.Application.ActiveWindow.View = 2;//xlPageBreakPreview;
      this.Application.ActiveWindow.View = 1;//xlNormalView
   OnError(ObjErr)
     return ;
   end; // TogglePreview

   /**** (Public) Пользовательский метод для открытия шаблона
                  Если передан флаг ShowAppl, то мы его используем для показа\не показа
                  приложения при открытии шаблона, если он не задан, то НЕ показываем  */
   macro OpenTemplate( TemplName:string, ShowAppl:bool ) : bool
  
         var stat:bool = true; 
   
         if( m_PrintXls )
             var NameFile:string  = "", // Временная переменная (имя файла)
                 ExtFile :string  = "", // Временная переменная (расширение файла)
                 TempStr :string  = "", // Временная переменная
                 LastNameTemplate :string,
                 StrErr  :integer =  0; // Код с ошибкой
             var RegKey  :string  = "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEMPLSDIR"; // Ключ в реестре с путем к шаблонам

             var RegKeyUSR  :string  = "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\USERTEMPLSDIR"; // Ключ в реестре с путем к шаблонам
             var DirName_TemplateUSR;

             if( NOT TemplName )
                 MsgBoxEx("[CTemplateXLS.OpenTemplate]!|Не указано имя шаблона!", MB_OK+MB_ERROR, IND_OK, "Ошибка!");
                 return false;
             end;

             // Если пользователь не задал путь до шаблонов, то поищем его в реестре
             if( NOT DirName_Template )
                 // Найдем месторасположение шаблонов на сервере, они лежат в одном из путей прописанных в 
                 // "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEMPLSDIR"
                 GetRegistryValue( RegKey, V_STRING, DirName_Template, StrErr );

                 GetRegistryValue( RegKeyUSR, V_STRING, DirName_TemplateUSR, StrErr );
                 DirName_Template = DirName_TemplateUSR +  DirName_Template;                 
             end;

             if( NOT DirName_Template )
                 GetString(DirName_Template, string("В настройках банка не указан путь до шаблонов <", RegKey, ">!|Укажите путь до папки с шаблонами."));
             end;

             if( NOT DirName_Template )
                 MsgBox( "Ошибка!|Не задан путь до папки с шаблонами." );
                 return false;
             end;

             // Определим месторасположение каждого шаблона из списка
             TempStr = FindPath(toANSI(TemplName), DirName_Template);
             if( NOT TempStr )
                 MsgBox( "В путях <",DirName_Template, ">|не найден шаблон|<",TemplName,">!|",
                          "Поместите шаблон в указанный путь и повторите операцию." );
                 return false;
             end;

             // Запускаем в локали
             if( isStandalone() OR UsePoi() )

                 // Если в строке пути есть знак ":" или "\\", то это абсолютный путь
                 if( Index(toAnsi(TempStr), ":") OR Index(toAnsi(TempStr), "\\\\") )
                     ;
                 else
                     // Добавим текущий путь
                     TempStr = GetCurDir(false)+"\\"+ TempStr;
                 end;

             // Запускаем в 3-х звенке
             else

                 MakeDir( "$"+NameTemplateDirTerm ); // Создадим папку с шаблонами

                 SplitFile( TempStr, NameFile, ExtFile );
                 NameFile = NameFile + ExtFile;


                 // Если в строке пути есть знак ":" или "\\", то это абсолютный путь
                 if( Index(toAnsi(TempStr), ":") OR Index(toAnsi(TempStr), "\\\\") );
                 else
                     // Добавим текущий путь
                     TempStr = GetCurDir(false)+"\\"+ TempStr;
                 end;
                 
                 LastNameTemplate = NameTemplateDirTerm+"\\"+NameFile;

                 // Проверим дату модификации шаблона на сервере и на терминале
                 if( NOT CheckFilesEqual( TempStr, "$"+ LastNameTemplate ) )

                     // Перешлем на терминал шаблон
                     if( NOT CopyFile( TempStr, "$"+ LastNameTemplate ) )
                      
                         UniqTemplateName = LastNameTemplate = GetUniqAddWhithConnect(LastNameTemplate);

                         if( NOT CopyFile( TempStr, "$"+ LastNameTemplate ) )
                             MsgBox( "Ошибка при передаче файла <" + toOEM(NameFile) +
                                     "> на терминал.|Из|<"+ toOEM(TempStr)+
                                     ">|в|<$"+toOEM(LastNameTemplate) + ">" );
                             return false;
                         end;
                     end;
                 end;
                 TempStr = GetCurDir(true)+"\\"+ LastNameTemplate;
             end;

             var TemplFormat = GetTemplateFileFormat(TemplName);
                 
             if( (TemplFormat == WINREP_FORMAT_XLSX) OR (TemplFormat == WINREP_FORMAT_XML_TEMPLATE) )
                 FormatRep       = WINREP_FORMAT_XLSX;
                 MAXROWSHEET     = MAX_ROWSHEET_XLSX;
                 ROW_FLUSH_COUNT = FLUSH_COUNT_XLSX;
             elif( (TemplFormat == WINREP_FORMAT_XLSB) )
                 FormatRep       = WINREP_FORMAT_XLSB;
                 MAXROWSHEET     = MAX_ROWSHEET_XLSX;
                 ROW_FLUSH_COUNT = FLUSH_COUNT_XLSX;
             end;

             if( UsePoi() )
                 if( (FormatRep == WINREP_FORMAT_XLSX) AND (TemplFormat == WINREP_FORMAT_XML_TEMPLATE) )
                     TempStr = reportCreator.SaveXLTXAsXLSX(TempStr);
                 end;
            
                 workbook = reportCreator.openWorkbook( TempStr );

                 SheetChange(1);

                 stat = true;
             else
                 stat = this.Open( TempStr );
             end;

             if( stat )
                 TemplateName = TemplName;
             end;

             // Проверим флаг ShowAppl, для показа прилоения с файлом
             if( ValType(ShowAppl) ) this.Show(ShowAppl);
             else                    this.Show(false   );
             end;

             // установим предпросмотр и вернем назад, нужно для отображения границ на листе   
             if( NOT UsePoi() )
                TogglePreview(); // DEF-69958, вынесено в отдельную процедуру, с обработкой ошибки, если случится
             end;
         end;
         return stat;
   OnError(ObjErr) 
     // DEF-69958, Добавлен обрабочик ошибок
     return stat;
   end; // END OpenTemplate()


   /**** (Public) Пользовательский метод для записи готового файла на диск   
                  Если пользователь передал имя файла NameFile (имя должно быть без расширения),
                  то используется оно (к имени приписывается номер коннекта),
                  если имя не передали, то получаем его на основании имени выходного потока (обычно имя макроса).
                  Если передан флаг ShowAppl, то мы его используем для показа\не показа приложения после сохранения,
                  если он не задан, то показываем                    */
   macro SaveAsWorkbook( NameFile:string, ShowAppl:bool, workBook:object ) : bool
         var TempNamePath   :string = "";                                             // Путь до временных папок
         var TmpOutFileName :string = m_WorkDir + "\\" + GetExlusiveFileName("out");  // Имя временного файла куда переключим выходной поток (для определения текущего имени)
         var LastNameFileTmp:string = SetOutPut(TmpOutFileName, true);                // Имя текущего выходного потока
         var LastNameFile   :string = "";                                             // Имя результирующего отчета
         var LastNameFileExt:string = "";                                             // Расширение результирующего отчета
         var WorkBookTerm   :string = "";
         var WorkBookName   :string = "";
         var stat           :bool   = true;
         var _FormatRep = FormatRep;

         if (m_ForceFormatRep != NULL)
            _FormatRep = m_ForceFormatRep;
         end;

         /* Обрежем путь и получим только имя */
         SplitFile(LastNameFileTmp, LastNameFile, LastNameFileExt);

         // Если пользователь сам задал имя файла, то его и возьмем, но номер коннекта все равно допишем в хвост
         if( NameFile )
             LastNameFile = NameFile;
         end;

         /* в рамках Author: maltsevn@SOFTLAB
         Author date: 12.07.2023 12:44:06
         Commit hash: 92413a0e
         Summary: ССВО-6798
         было внесено что приклеивается расширение последнего файла лога
         В части работ по DEF-79259 убираю приклеивание _log к имени файла
         Если где-то это будет нужно в дальнейшем надо будет менять под конкрентый отчет
         Но я не вижу смысла клеить прошлое расширение файла лога в имя нового файла
		 В рамках DEF-79741 добавлена проверка на число, для приклепления номера сессии*/

         if( LastNameFile AND LastNameFileExt AND StrIsNumber(SubStr(LastNameFileExt, 2)) )
             LastNameFile = LastNameFile + "_" + SubStr(LastNameFileExt, 2);
         end;
         

         // Восстанавливаем поток вывода и удаляем получившийся файл
         SetOutPut(LastNameFileTmp, true);
         DelFile( TmpOutFileName );

         // Определим путь до временных папок, куда будем записывать готовый отчет
         if( IsStandAlone() OR UsePoi() )
             TempNamePath = m_WorkDir + "\\";
         else
             // Если в строке пути есть знак ":" или "\\", то это абсолютный путь
             if( Index(toAnsi(NameDirTerm), ":") OR Index(toAnsi(NameDirTerm), "\\\\") )
                 TempNamePath = SubStr(toAnsi(NameDirTerm), 2);
             else
                 TempNamePath = GetCurDir(true)+"\\"+SubStr(toAnsi(NameDirTerm), 2);
             end;
             MakeDir(toAnsi(NameDirTerm) );
         end;
         
         if( _FormatRep == WINREP_FORMAT_XLSX )
            LastNameFile = TempNamePath + LastNameFile + ".xlsx";
         elif( _FormatRep == WINREP_FORMAT_XLSB )
            LastNameFile = TempNamePath + LastNameFile + ".xlsb";
         else
            LastNameFile = TempNamePath + LastNameFile + ".xls";
         end;

         if( this.Application AND TmpSheet AND this.Application.WorkBooks.count )
             TmpSheet.Delete();
         end;

         // Проверим флаг ShowAppl, для показа прилоения с файлом
         if( ValType(ShowAppl) ) this.Show(ShowAppl);
         else                    this.Show(true);
         end;

         if( m_TxtObjPrint )
             m_TxtObjPrint.PrintRep();
         end;

         if( m_PrintXls )
             
             SetToolCategory(workBook);

             if( UsePoi() )
                 if( NOT m_overwriteFile )
                     if( OR_ExistFile(LastNameFile) )
                         LastNameFile = GetUniqAdd( LastNameFile );
                     end;
                 else 
                     if( NOT Check_SaveAs(LastNameFile))
                         return false;
                     end;
                 end;
                 stat = workBook.saveAs( LastNameFile );
                 if( stat )
                    if( NOT isStandalone() )
                        if( Index(toAnsi(NameDirTerm), ":") OR Index(toAnsi(NameDirTerm), "\\\\") )
                            WorkBookTerm = SubStr(toAnsi(NameDirTerm), 2);
                        else
                            WorkBookTerm = GetCurDir(true)+"\\"+SubStr(toAnsi(NameDirTerm), 2);
                        end;

                        MakeDir(toAnsi(NameDirTerm)); 
                        WorkBookName = workBook.getWorkbookName();
                    
                         if( NOT m_overwriteFile )
                             if( OR_ExistFile(WorkBookTerm + WorkBookName) )
                                 WorkBookName = GetUniqAdd(workBook.getWorkbookName());
                             end;
                         end; 

                         var tmpWorkBookTerm;
                         if( substr(WorkBookTerm, 1, 1) == "$" )
                             tmpWorkBookTerm = WorkBookTerm;
                         else
                             tmpWorkBookTerm = "$" + WorkBookTerm;
                         end;

                         if( NOT CopyFile(toANSI(workBook.getWorkbookPath() + "\\" + workBook.getWorkbookName()), toANSI(tmpWorkBookTerm + WorkBookName)))
                             WorkBookName = GetUniqAdd(WorkBookName);
                            if( NOT CopyFile(toANSI(workBook.getWorkbookPath() + "\\" + workBook.getWorkbookName()), toANSI(tmpWorkBookTerm + WorkBookName)) )
                                MsgBox( "Ошибка при передаче файла <" + toAnsi(workBook.getWorkbookName()) + "> на терминал.|Из|<"+ toAnsi(workBook.getWorkbookPath()) + ">|в|<"+toAnsi(tmpWorkBookTerm) + ">" );
                                return false;
                            end;
                        end; 

                        if( NOT ___FlagDebug___ )
                            if( ExistFile(toANSI(workBook.getWorkbookPath() + "\\" + workBook.getWorkbookName())))
                                RemoveFile(toANSI(workBook.getWorkbookPath() + "\\" + workBook.getWorkbookName()));
                            end;
                        end;
                    else
                        WorkBookTerm = workBook.getWorkbookPath();
                        WorkBookName = workBook.getWorkbookName();
                    end;

                    ReportPath         = WorkBookTerm;
                    ReportFileName_xls = WorkBookName;

                    if( (NOT ValType(ShowAppl)) OR ShowAppl)
                        if( (NOT IsStandalone()) AND (Substr(WorkBookTerm, 1, 1) != "$") )
                            stat = StartShellProgram("$" + WorkBookTerm  + "\\" + workBook.getWorkbookName());
                        else
                            stat = StartShellProgram(workBook.getWorkbookPath() + "\\" + workBook.getWorkbookName());
                        end;
                        if( stat )
                            this.SetPageBreaks();
                            this.Show(true);
                        end;
                    end;
                 else
                    MsgBox( "Ошибка при сохранении файла <" + toAnsi(workBook.getWorkbookPath() + "\\" + workBook.getWorkbookName()) + ">");
                 end;
             elif( NOT SaveExistingBook ) 
                 if( NOT m_overwriteFile )
                     stat = SaveAsNotOverwrite( LastNameFile, _FormatRep );
                 else
                     stat = SaveAs( LastNameFile, _FormatRep );
                 end;
             else 
                 stat = Save();
             end;

             if( ConvertToPDF )
                 this.ExportAsFixedFormat( FileNamePDF, ShowFilePDF );
             end;
         end;

         if( NOT UsePoi() )
            ReportPath         = this.Book.Path;
            ReportFileName_xls = this.Book.Name;
         end;

         // Удалим лишние копии шаблона на терминале
         if( m_deleteTemplate AND (OR_ExistFile(toANSI(UniqTemplateName))) )
            OR_DeleteFile(UniqTemplateName); 
         end;

         return stat;
   end; /* End SaveAsTemplate() */

   macro SaveAsTotalbook( NameFile:string, ShowAppl:bool ) : bool
         
         return SaveAsWorkbook( NameFile, ShowAppl, totalWorkbook );
   end; 

   macro SaveAsTemplate( NameFile:string, ShowAppl:bool ) : bool
         
         return SaveAsWorkbook( NameFile, ShowAppl, workbook ); 
   end;


   /**** (Public) Пользовательский метод для задания пути до шаблонов */
   macro SetPathTemplate( _DirName_Template:string )
         DirName_Template = _DirName_Template;
   end;

   /**** (Public) Пользовательский метод для включения-выключения режима отладки */
   macro SetFlagDebug( _FlagDebug:bool )
         if( Not ValType(_FlagDebug) )
              ___FlagDebug___ = Not ___FlagDebug___;
         else ___FlagDebug___ = _FlagDebug;
         end;
   end;

   /* (Public) Пользовательский метод установки флага показа встроенного индикатора */
   macro SetFlagShowIndicator( FlagShowIndicator:bool )
         m_FlagShowIndicator = FlagShowIndicator;
   End;

   /* (Public) Пользовательский метод получения флага показа встроенного индикатора */
   macro GetFlagShowIndicator() : bool
         return m_FlagShowIndicator;
   End;

   /* (Public) Пользовательский метод для добавления рисунка  в именованую ячейку  (диапазон) */ 
   macro AddPictureCell( CellName:string, FilePath:string, FlagLinkToPicFile:bool, FlagDeletePicFile:bool) : bool
         var stat:bool = true;  

         if( NOT m_PrintXls )
             return stat;
         end;

         if( CellName == "")
            MsgBox( "[AddPicture] Ошибка!|Не задан адрес ячейки." );
            return false;
         end;

         var Picture:object = CPicture( FilePath, this.Sheet.Range(CellName).Left, this.Sheet.Range(CellName).Top);

         // Если работаем в трехзвенке, пошлем файлы рисунков на терминал
         if (NOT isStandAlone() )
            if( NOT CopyFile( toANSI(Picture.GetFileName()), toANSI(Picture.GetTermFileName()) ) )
               MsgBox( "Ошибка при передаче файла <" + toAnsi(Picture.GetShortName()) + "> на терминал.|Из|<" + toAnsi(Picture.GetFileName()) + ">|в|<"+toAnsi(Picture.GetTermFileName()) + ">" );
               return false;
            end;
         end;

         // Вставим рисунок на лист
         stat = AddPicture( Picture.GetAbsTermFileName(), 
                            FlagLinkToPicFile, 
                            Picture.GetLeftPos(), 
                            Picture.GetTopPos() ); 

         // Если работаем в трехзвенке, удадалим лишние файлы
         if( (NOT isStandAlone()) AND OR_ExistFile(toANSI(Picture.GetTermFileName())) )
            OR_DeleteFile( Picture.GetTermFileName() ); 
         end; 

         // Если исходный файл больше не нужен, то удалим его. Работает только c FlagLinkToFile = FALSE
         if (FlagDeletePicFile AND (FlagLinkToPicFile == FALSE) AND ExistFile(toANSI(Picture.GetFileName())) )
             DelFile( Picture.GetFileName() );
         end;
         
         return stat;

         OnError( ObjError )
           ErrorMessage(ObjError, "[AddPicture] Oшибка!");
           return false;
   end;

   /**** (Public) Пользовательский метод для установки значения в именованую ячейку  (диапазона) */
   macro SetValue_NameCell( NameCell:string, Value:variant, StrL, isNeedTrimStr ) : bool
        if (isNeedTrimStr == NULL)
            isNeedTrimStr = true;
        end;
         macro FormatValue (NameCell:string, Value:variant, isNeedTrimStr)
             var CellFormat = workbook.getCellFormat(NameCell);

             if( ValType(Value) == V_UNDEF )
                return "";
                 end;
             if( ValType(Value) == V_STRING )
                if (isNeedTrimStr)
                    return Trim(Value);
                else
                    return Value;
                end;
             end;
             
             if( ValType(Value) == V_DTTM ) 
                 DtTmSplit( Value, Value );
             end;
             
             if( ValType(Value) == V_DATE ) 
                 if( (Value == Date(0,0,0)) OR (CellFormat=="@") OR (CellFormat=="General"))
                 Value = string(Value:f);
             end;
             elif( ValType (Value) == V_TIME ) 
                 if( (Value == Time(0,0,0)) OR (CellFormat=="@") OR (CellFormat=="General"))
                     Value = string(Value:f);
                 end;
             end;  
             
             return Value;
         end;

         if( UsePoi() )   
             workbook.setCellValue(NameCell, FormatValue (NameCell, Value, isNeedTrimStr));
             return true;
         end;
         
         this.Sheet.Range(NameCell).Value = Value;

         if( ValType(StrL) AND StrL )
             if( NOT TmpSheet )
                 TmpSheet = Book.Sheets.Add();
                 TmpCell = TmpSheet.Range("A1");
                 CellKoeffNormal = TmpCell.Width/TmpCell.ColumnWidth - 0.3;
                 TmpSheet.Visible = false;
                 TmpCell.WrapText = true;
             end;

             TmpCell.ColumnWidth = Sheet.Range(NameCell).Width * CellKoeffNormal;
             TmpCell.Value = Value;

             if( Sheet.Range(NameCell).RowHeight < TmpCell.RowHeight )
               Sheet.Range(NameCell).RowHeight = TmpCell.RowHeight; 
             end;
         end;

         LastAddedCell = NameCell;

         return true;

         OnError(ObjErr)
            if( ___FlagDebug___ )
                ErrorMessage(ObjErr, "[CTable.EndTable] Ошибка!");
            end;
            return false;
   end;                      
                     
   /* заполняет ячейки вида  ┌──┬──┬──┐      ┌──┬──┐ ┌──┬──┐
                             │  │  │  │  или │  │  │-│  │  │
                             └──┴──┴──┘      └──┴──┘ └──┴──┘
   можно использовать для документов взятых из Гаранта или Консультанта.
   NameCell - имя первой ячейки(остольные имменовать не нужно)
   Value:string - значение, которое будет разбито посимвольно и записано в каждую ячейку
   Wcell - сколько столбцов Excel обьеденены в одну (обычно ячейки состоят из нескольких столбцов)
   LenCell - число ячеек (необязат.), если не задан используется длинна строки
   если в шаблоне в ячейке, уже есть значение - не заполняется (используется для разделителей . - / и тд.)
  */
   macro SetValueMultiCell( NameCell:string, Value:string, WCell:integer, LenCell:integer )       
       var Len = StrLen(Value);

       if( ValType(LenCell) )
           Len = LenCell; 
       end;

       if( UsePoi() )
           if( ValType(Value) )
               workbook.setCellMultiValue(NameCell, Value, Len);
           end;
           return;
       end;       

       var RangeM:object = this.Sheet.Range(NameCell);
       var i:integer = 1;
       var j:integer = 0;

       while(i <= Len)
            RangeM.Value = Substr(Value, i, 1);
            j = 0;
            while( ((Valtype(RangeM.Value)) OR (j == 0) ) AND (j < 50) )
                RangeM = this.Sheet.Range(RangeM.Cells(1, WCell + 1).Address);
                j = j + 1;
            end;  
            i = i+1;
       end; 

       LastAddedCell = NameCell;
       
   end;
   /* заполняет ячейки вида  ┌──┬──┬──┐      ┌──┬──┐ ┌──┬──┐
                             │  │  │  │  или │  │  │-│  │  │
                             └──┴──┴──┘      └──┴──┘ └──┴──┘
   можно использовать для документов взятых из Гаранта или Консультанта.
   NameCell - имя первой ячейки(остольные имменовать не нужно)
   arr:tarray - массив, который будет разбит поэлементно и записан в каждую ячейку
   Wcell - сколько столбцов Excel обьеденены в одну (обычно ячейки состоят из нескольких столбцов)
   LenCell - число ячеек (необязат.), если не задан используется размер массива
   если в шаблоне в ячейке, уже есть значение - не заполняется (используется для разделителей . - / и тд.)
  */
   macro SetValueMultiCellArr( NameCell:string, ArrValues:tarray, WCell:integer, LenCell:integer )       
       var Len = ArrValues.size;
       if( ValType(LenCell) )
           Len = LenCell; 
       end;

       if( UsePoi() )
           return;
       end;

       var RangeM:object = this.Sheet.Range(NameCell);
       var i:integer = 0;
       var j:integer = 0;


       while(i < Len)
            RangeM.Value = ArrValues[i];
            j = 0;
            while( ( (Valtype(RangeM.Value) ) OR (j == 0) ) AND (j < 50) )
                RangeM = this.Sheet.Range(RangeM.Cells(1, WCell + 1).Address);
                j = j + 1;
            end;  
            i = i + 1;
       end; 

       LastAddedCell = NameCell;       
   end;

   // Вставка разрыва страницы
   macro SetNewPage()
         if( NOT m_PrintXls )
             return true;
         end;
                           
         var ActiveSheet:object = this.Book.ActiveSheet;
         var LastRow:integer = ActiveSheet.Range(LastAddedCell).Rows(ActiveSheet.Range(LastAddedCell).Rows.Count).Row;

         ActiveSheet.HPageBreaks.Add(ActiveSheet.Range("A" + int(LastRow + 1)));     
   end;

   macro SetXLSXFormat()
      
      if( UsePoi() )
          FormatRep = WINREP_FORMAT_XLSX;
          return;
      end;

      if( m_PrintXls AND (int(this.Application.version) >= MS_2007) )
          FormatRep = WINREP_FORMAT_XLSX;
      end;
   end;


   /* (Public) Пользовательский метод для установки флага конвертации в PDF-формат и имени файла для сохранения */ 
   macro SetConvertToPDF( _FileNamePDF:string, _ShowFilePDF:bool )

        ConvertToPDF = true;

        if( ValType(_FileNamePDF) )
            FileNamePDF = _FileNamePDF;
        end;  

        if( ValType(_ShowFilePDF) )
            ShowFilePDF = _ShowFilePDF;
        end;
   end;

   /**** (Public) Пользовательский метод для регистрации таблицы */
   macro RegisterTable( TableName :string, HeaderName:string, HeaderOnPage ) : object   
                        
         var ObjTable = NULL;

         if( UsePoi() )
             ObjTable = CTableTmplPOI( TableName, HeaderName, this, NULL, HeaderOnPage );
         else
             ObjTable = CTableTmpl( TableName, HeaderName, this, NULL, HeaderOnPage );
         end;

         ObjTable.m_WorkDir = m_WorkDir;

         return ObjTable;
   end;


   // Конструктор
   m_WorkDir = GetWorkDirName();

   if( ExcelLanguage == LANGUAGE_AUTO )
       ExcelLanguage = this.GetExcelLanguage();  
   end;

   if( FileName )
       OpenTemplate( FileName );
   end;

   macro Close()
       if ( UsePoi() )
          if( workbook )  
            workbook.close();
            workbook = NULL;
          end;
          return;
       else
          this.Close();
          TmpSheet = NULL;
       end;
   end;

   macro SheetName()
       var Name;                   
       GetParm(1, Name);
      
       if (UsePoi())
          if (ValType(Name) AND (Name != ""))
              workbook.setSheetName(Name);
          else
              return workbook.getSheetName();
          end;
       else
          return this.SheetName(Name);
       end;
   end;

   macro SheetClear(index:integer)
       if (UsePoi())
           workbook.SheetClear(index);
       else
           this.SheetClear(index);
       end;
   end;

   macro SheetCount()
       if (UsePoi())
           return workbook.getSheetsCount();
       else
           return this.SheetCount();
       end;
   end;

   macro SheetCountTotalBook()
       if (UsePoi())
           return totalworkbook.getSheetsCount();
       end;
       return 0;
   end;

   macro GetSheetNameTotalBook(index:integer)
       if (UsePoi())
           if (index)
              return totalworkbook.getSheetNameAt(index - 1);
           end;
       end;    
       return "";
   end;     
              
   macro SheetDelete(index:integer)
       if (UsePoi())
           if (index)
              workbook.removeSheet(index - 1);
              return true;
           else
              return false;
           end;
       else
           return this.SheetDelete(index);
       end;
   end;

   macro SetAlign()
       var Row;       
       var Col;       
       var Alignment; 
       
       GetParm(2, Col);
       if(ValType(Col))
          GetParm(1, Row);
          GetParm(3, Alignment);
       else 
          GetParm(1, Alignment);
       end;
       if (UsePoi())
           workbook.setAlignment(Row, Col, Alignment);
       else
           this.SetAlign(Row, Col, Alignment);
       end;
   end;

   macro SetSheetColor(colorIndex:integer)
       if (UsePoi())
           workbook.setSheetColor(colorIndex);
       else
           this.SetSheetColor(colorIndex);
       end;
   end;

   macro SetBkColor()
       var Row;                  
       var Col;                  
       var Color;                 

       GetParm(2, Col);
       if( ValType(Col) )
           GetParm(1, Row);
           GetParm(3, Color);
           if (UsePoi())
               workbook.setBackgroundColor(Color, Row, Col);
           else
               this.SetBkColor(Row, Col, Color);
           end;
       else
           GetParm(1, Color);
           if (UsePoi())
               workbook.setBackgroundColorRange(Color);
           else
              this.SetBkColor(Color);
           end;
       end;     
   end;

   macro SetFrColor()
       var Color, ColorInt;                
       var Row;                  
       var Col;                  

       GetParm(2, Col);
       if( ValType(Col) )
           GetParm(1, Row);
           GetParm(3, Color);
           if (ValType(Color) == V_STRING)
               ColorInt = int(Color);
           else
               ColorInt = Color;
           end; 
           if (UsePoi())
               workbook.setFontColor(ColorInt, Row, Col);
           else
              this.SetFrColor(Row, Col, ColorInt);
       end;
       else
           GetParm(1, Color);
           if (ValType(Color) == V_STRING)
               ColorInt = int(Color);
           else
               ColorInt = Color;
           end;
           if (UsePoi())
              workbook.setFontColorRange(ColorInt, Row, Col);
           else
              this.SetFrColor(ColorInt);
           end;
       end;    
   end;

   macro SetFont(ObjFontProp_or_Name, Size:integer, Bold:bool, Italic:bool, UnderLine:integer, FrColor:integer, BkColor:integer)
       
       if (UsePoi())
           if (ValType(ObjFontProp_or_Name) != V_STRING)
               ObjFontProp_or_Name = "";
           end;

           if (ValType(Size) != V_INTEGER)
               Size = 0;
           end;

           if (ValType(Bold) != V_BOOL)
               Bold = false;
           end;

           if (ValType(Italic) != V_BOOL)
               Italic = false;
           end;

           if (ValType(UnderLine) != V_INTEGER)
               UnderLine = FONTSTYLE_UNDERLINENO;
           end;

           if (ValType(FrColor) != V_INTEGER)
               FrColor = 0;
           end;

           if (ValType(BkColor) != V_INTEGER)
              BkColor = 0;
           end;

           workbook.setFont(ObjFontProp_or_Name, Size, Bold, Italic, UnderLine, FrColor, BkColor);        
       else
           this.SetFont(ObjFontProp_or_Name, Size, Bold, Italic, UnderLine, FrColor, BkColor);
       end;

   end;

   macro ColWidth():integer
       var Address;
       var Col;   
       var Width; 

       GetParm(1, Address);
       GetParm(2, Width);
       
       if( (ValType(Address) == V_STRING) AND (Address != "") )
           if (UsePoi())
               if (Width == 0)
                  workbook.setRangeColumnHiden(Address);
               else
                  workbook.setColumnWidth(Address, Width*256);
               end; 
           else
               this.ColWidth2(Address, Width);
           end;
           return;
       end;

       GetParm (1, Col);

       if (UsePoi())
           if (Width == 0)
               workbook.setColumnHiden(Col);
           else
               workbook.setColumnWidth(Col, Width*256);
           end;
       else
           this.ColWidth(Col, Width);
       end;
   end;

   macro RowHeight():integer
       var Address;
       var Row;   
       var Height; 

       GetParm(1, Address);
       GetParm(2, Height);

       if( (ValType(Address) == V_STRING) AND (Address != "") )
           if (UsePoi())
               if (Height == 0)
                  workbook.setRangeHiden(Address);
               else
                  workbook.setRangeRowHeight(Address, Height);
               end;
           else
              this.RowHeight2(Address, Height);
           end;
           return;
       end;

       GetParm(1, Row);

       if (UsePoi())
           if (Height == 0)
              workbook.setRowHiden(Row);
           else
              workbook.setRowHeight(Row, Height);
           end;
       else
           this.RowHeight(Row, Height);
       end;
   end;
   

   macro SheetChange (sheet:variant, flagNoMessage:bool)
       if (UsePoi())
           if (workbook)
               if (ValType(sheet) == V_STRING)
                   workbook.setActiveSheetByName(sheet);
               elif (ValType(sheet) == V_INTEGER)
                   if (sheet > 0 )
                      sheet = sheet - 1;
                   end;
                   workbook.setActiveSheet(sheet);
               end;
               return true;
           end;
           return false;
       else
          return this.SheetChange(sheet, flagNoMessage);
       end; 
   end;         

   macro SetDiapazon()
       var firstRow, firstCol, lastRow, lastCol;      
       var diapazon:string = ""; 
       
       GetParm(1, firstRow);
       GetParm(2, firstCol);
       GetParm(3, lastRow);
       GetParm(4, lastCol);
       if(ValType(lastCol))
           diapazon = _SplitCoord(firstRow, firstCol) + ":" + _SplitCoord(lastRow, lastCol);
       else 
           GetParm(1, diapazon);
       end;

       if (UsePoi())
          workbook.setRangeByAddress(diapazon);
          return true;
       else
          return this.SetDiapazon(firstRow, firstCol, lastRow, lastCol);
       end;
    end;
    
    macro SheetAdd (sheetIndex:integer)
       if (UsePoi())
           if( sheetIndex )
               workbook.createSheet(sheetIndex);
               workbook.setActiveSheet(sheetIndex);
           else
               workbook.createSheet();
               workbook.setActiveSheetByName("Лист1");
           end;
           
       else
           this.SheetAdd (sheetIndex);
       end;
       
    end; 

    macro SetBorder()
       var Diapazon; 
       var Left, Top, Bottom, Right, InSideVertical, InSideHorizont; 
       
       GetParm(1, Diapazon);
       if( (ValType(Diapazon) == V_STRING) AND (Diapazon != "") )
           SetDiapazon(Diapazon);
           GetParm(2, Left);
           GetParm(3, Top); 
           GetParm(4, Bottom);
           GetParm(5, Right);
           GetParm(6, InSideVertical);
           GetParm(7, InSideHorizont);
       else
           GetParm(1, Left);
           GetParm(2, Top); 
           GetParm(3, Bottom);
           GetParm(4, Right);
           GetParm(5, InSideVertical);
           GetParm(6, InSideHorizont);
       end;
       
       if (UsePoi())
           if( ValType(Top) != V_INTEGER )
               Top = 0;
           end;
           if( ValType(Bottom) != V_INTEGER )
               Bottom = 0;
           end;
           if( ValType(Right) != V_INTEGER )
               Right = 0;
           end;
           if( (ValType(Diapazon) == V_STRING) AND (Diapazon != "") )
               if( ValType(Left) != V_INTEGER)
                   workbook.setBorderAddress(Diapazon);
               else
                   workbook.setBorderAddressIndex(Diapazon, Top, Left, Right, Bottom); 
               end;
           elif( ValType(Left) == V_INTEGER )
               workbook.setBorderIndex(Top, Left, Right, Bottom);
           else
               workbook.setBorderRange();
           end;
       else
           if( (ValType(Left) != V_INTEGER) AND (ValType(Top) != V_INTEGER) AND (ValType(Bottom) != V_INTEGER) AND (ValType(Right) != V_INTEGER) )
               this.SetBorder(Diapazon); 
           else
               this.SetBorder(Diapazon, Left, Top, Bottom, Right, InSideVertical, InSideHorizont);
           end;
       end;
    end;

    macro SetValue()
       var Coord;         
       var Row;           
       var Col;           
       var Value:variant; 

       GetParm (3, Value);
       if (ValType(Value))
           GetParm(1, Row);
           GetParm(2, Col);
           if (ValType(Row) == V_INTEGER)
               Coord = _SplitCoord (Row, Col);
           else 
               Coord = Row + Col;
           end;
           if (UsePoi())
              workbook.setCellIndexValue(Row, Col, Value);  
              return;
           end;
       else GetParm (1, Coord);
           GetParm (2, Value);
           if (UsePoi())
              workbook.setCellReferenceValue(Coord, Value);
              return;
           end;
       end;
       
       this.SetValue(Row, Col, Value);
    end;

    macro SetAutoFilter (RangeName:string, Sheet:variant)
       if (UsePoi())
           if (ValType(Sheet) == V_STRING)
              workbook.setAutoFilter(Sheet, RangeName);
           elif ((ValType(Sheet) == V_INTEGER) and (Sheet < workbook.getSheetsCount()))
              workbook.setAutoFilter(workbook.getSheetNameAt(Sheet), RangeName);  
           else
              workbook.setAutoFilter(workbook.getSheetName(), RangeName);
           end;
       else
           this.SetAutoFilter(RangeName, Sheet);
       end;

       return true;
    end;

    macro SetAutoFilterTotalbook (RangeName:string, Sheet:variant)
       if (UsePoi())
           if (totalWorkbook)
              if (ValType(Sheet) == V_STRING)
                 totalWorkbook.setAutoFilter(Sheet, RangeName);
              elif ((ValType(Sheet) == V_INTEGER) and (Sheet < totalWorkbook.getSheetsCount()))
                 totalWorkbook.setAutoFilter(totalWorkbook.getSheetNameAt(Sheet), RangeName);  
              else
                 totalWorkbook.setAutoFilter(totalWorkbook.getSheetName(), RangeName);
              end;
              return true;
           end;
           return false;
       else
           var saveBook = this.Book;
           this.Book = BookNew_All;
           this.SetAutoFilter(RangeName, Sheet);
           this.Book = saveBook;
       end;

       return true;
    end; 

    macro RemoveColumn (RangeName:string, Sheet:variant)
       if (UsePoi())
          if (ValType(Sheet) == V_INTEGER)
             workbook.removeColumnByIndex(Sheet, RangeName);
          elif (ValType(Sheet) == V_STRING)
             workbook.removeColumn(Sheet, RangeName);  
          else
             workbook.removeColumn(workbook.getSheetName(), RangeName);
          end;
       else
          this.RemoveColumn(RangeName, Sheet);
       end;

       return true;
    end;

    macro SetPageNumber (PageName:string, PageNumber)
       var PageNumStr:string = "";
  
       if (UsePoi())
           if (ValType(PageNumber) == V_INTEGER)
               PageNumStr = string(PageNumber);
           else 
               PageNumStr = PageNumber;
           end;
           workbook.setPageNumber(workbook.getSheetName(), PageName, PageNumStr);
       end;
    end;

    macro Calculate()
       if (UsePoi())
           workbook.calculate();
       end;
    end;

    macro ReplaceCellString(StringFrom:string, StringTo:string)
       if (UsePoi())
           if (workbook != null)
              workbook.replaceCellString(StringFrom, StringTo);
           end;
       end;         
    end;

     
    macro SetMerge()
       var Diapazon, FirstRow, FirstCol, LastRow, LastCol; 

       GetParm(1, Diapazon);

       if (NOT UsePoi())
          if( (ValType(Diapazon) == V_STRING) AND (Diapazon != "") )
              this.SetDiapazon(Diapazon);
          end;
          return this.Merge();
       end;
       
       if( (ValType(Diapazon) == V_STRING) AND (Diapazon != "") )
          workbook.setMergeAddress(Diapazon);
       else
          GetParm(1, firstRow);
          GetParm(2, firstCol);
          GetParm(3, lastRow);
          GetParm(4, lastCol);

          if( ValType(firstRow) == V_INTEGER )
             workbook.setMerge(FirstRow, FirstCol, LastRow, LastCol);      
          else
             workbook.setMergeRange();
          end;
       end;   
    end;

    /**
     @brief Объединить ячейки в общей книге
     @param [in] FirstRow Номер столбца начала объединения / Diapazon Диапазон для объединения
     @param [in] firstCol Номер ряда начала объединения 
     @param [in] lastRow Номер столбца окончания объединения
     @param [in] lastCol Номер ряда окончания объединения
    */
    macro SetMergeTotal()
       var Diapazon, FirstRow, FirstCol, LastRow, LastCol; 

       GetParm(1, Diapazon);

       if (NOT UsePoi())
         var saveBook = this.Book;
         this.Book = BookNew_All;

         if( (ValType(Diapazon) == V_STRING) AND (Diapazon != "") )
           this.SetDiapazon(Diapazon);
         end;

         var res = this.Merge();
         this.Book = saveBook;
         return res;
       end;
       
       if( (ValType(Diapazon) == V_STRING) AND (Diapazon != "") )
          totalWorkbook.setMergeAddress(Diapazon);
       else
          GetParm(1, firstRow);
          GetParm(2, firstCol);
          GetParm(3, lastRow);
          GetParm(4, lastCol);

          if( ValType(firstRow) == V_INTEGER )
             totalWorkbook.setMerge(FirstRow, FirstCol, LastRow, LastCol);
          else
             totalWorkbook.setMergeRange();
          end;
       end;
    end;

    macro SetCellFormat(Address:string, Format:string)
        if( UsePoi() )
            workbook.setCellFormat(Address, Format);
        else
            Format = StrSubst( Format, GetLocaleDecimalSeparator(), Application.International(3/*xlDecimalSeparator*/) );
            this.Sheet.Range(Address).NumberFormat = Format;
            this.Sheet.Range(Address).NumberFormatLocal = Format;
        end; 
        OnError(ObjError)
            ErrorMessage(ObjError, "[CTemplateXLS.SetCellFormat] Oшибка!");
        return;
    end;

    macro GetActiveSheetIndex()
        if (UsePoi())
            return workbook.getActiveSheetIndex();
        end;
        return this.Sheet.Index;
    end;

    macro SetPageBreaks() // DEF-52640, перегрузка для разрыва страниц, чтобы правильно копировалась настройка для POI
        if (not UsePoi())
            this.SetPageBreaks();
        end;
    OnError(ObjErr)
       // DEF-69958, Добавлен обрабочик ошибок
       return ;
    end;

    macro SetAutoFit( RangeName:string, _Sheet:variant ) : bool
        if (UsePoi())
            if( (ValType(_Sheet) == V_STRING) )
                SheetChange(_Sheet);
            else
                SheetChange(workbook.getSheetName());
            end; 
            return workbook.setRangeColumnWidth(RangeName, -1);
        end;
        this.SetAutoFit( RangeName, _Sheet );
    end;

    macro SetAutoFitTotalbook( RangeName:string, _Sheet:variant ) : bool
        if (UsePoi())
            if (totalworkbook)
               if (ValType(_Sheet) == V_STRING)
                   totalworkbook.setActiveSheetByName(_Sheet);
               else
                   totalworkbook.setActiveSheet(totalworkbook.getSheetName());
               end;
               totalworkbook.setRangeColumnWidth(RangeName, -1);
               return true;
            end;
            return false;
        end;
        var saveBook = this.Book;
        this.Book = BookNew_All;
        this.SetAutoFit( RangeName, _Sheet );
        this.Book = saveBook;     
    end;
 
    macro OpenWorkBook (FileName:string) : bool
       if( NOT UsePoi() )
           return false;
       end;

       var TmpFileName:string = "";

       if( m_PrintXls )
           if( NOT FileName )
               MsgBoxEx("[CTemplateXLS.OpenWorkBook]!|Не указано имя книги!", MB_OK + MB_ERROR, IND_OK, "Ошибка!");
               return false;
           end;

           if( reportCreator == null)
               return false;
           end;

           if( Index(toAnsi(FileName), ":") OR Index(toAnsi(FileName), "\\\\") )
               TmpFileName = FileName;
           else
               TmpFileName = this.m_WorkDir + "\\" + FileName;
           end;

           workbook = reportCreator.openWorkbook( TmpFileName );

           SheetChange(1);

           return true;
       end;
       OnError( ObjError )
           ErrorMessage(ObjError, "[CTemplateXLS.OpenWorkBook] Oшибка!");
           return false;
    end;

       
    macro Destructor ()
       reportCreator = NULL;
       if( UsePoi() )
           if( workbook )
               workbook.close();
           end;
           if( totalWorkbook )
               totalWorkbook.close();
           end;
       end;
       workbook      = NULL;
       totalWorkbook = NULL;
       this.Destructor(); 
    end;

end;


FILE __File_CSV_Write__ (  ) txt 10000 write;
FILE __File_CSV_Read__  (  ) txt;

/**** Объект для подготовки CSV-файла */
class C_CSVFile( _Delim:string ) // Символ разделитель полей
    var         m_FileName  :string  = "";            // Имя файла
    private var m_Write     :bool    = FALSE;         // Статус файла (для чтения, для записи)
    private var m_Flashing  :bool    = FALSE;
    private var m_Delim     :string  = ";";           // Символ разделитель
    private var m_CurRow    :string  = "";            // текущее значение(содержание) строки
    private var m_NumRow    :integer = 0 ;            // Номер текущей строки
    private var m_LimitRow  :integer = MAXROWSHEET;
    private var m_FileID;                             // ID файла
    private var m_lsFileName:tarray = Tarray();       // Список созданных файлов
    private var m_Func_AddSheet:variant = NULL;       // CallBack вызываемый при добьавлении нового файла
    private var DecimalSeparator = GetLocaleInfo( 0, LOCALE_SDECIMAL, (NOT IsStandAlone()) );

 
    if( ValType(_Delim) )
        m_Delim = _Delim;
    end;

    macro SetLimitRow(LimitRow:integer)
        m_LimitRow = LimitRow;
    end;

    // Метод для получения рабочего каталога 
    private macro GetWorkDirName() : string
        var DirName:string = "";  // Строка с именем пути                         
        var StrErr :string = "";  // Строка с ошибкой определения временной папки 

        GetRegistryValue( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR", V_STRING, DirName, StrErr );

        /* Если в реестре нет ключа "TEXTDIR" или значение не задано, то поищем в bank.ini */
        if( NOT DirName )
            DirName = GetIniString( "TEXTDIR" );
        end;

        if( NOT DirName )
            DirName = GetEnv("TEMP");
            if( NOT DirName )
                DirName = GetEnv("TMP");
            end;
        else
            /* Если первый символ в DirName - это точка, то значит путь относительный, */
            /* тогда приклеем к нему CyrDir, иначе путь абсолютный                     */
            if( SubStr(DirName, 1, 1) == "." )
                DirName = GetCurDir(false) + "\\" + DirName;
            end;
        end;

        return DirName;
    end;

    private macro GetUsePoiMode():bool
        var usePoiMode:bool = false;
        var StrErr:string = "";
        var RegKey:string = "BANK_INI\\WINDOWS REPORT\\ИСПОЛЬЗОВАТЬ APACHE POI";
  
        if( NOT GetRegistryValue(RegKey, V_UNDEF, usePoiMode, StrErr) )
            MsgBox("В реестре не найден ключ ["+RegKey+"]!|", StrErr);
        end;    
        return usePoiMode;
    end;

    macro GetCurRow(): String
        return m_CurRow;
    end;

    macro CreateFullFileName( _FileName:string ) : string
        var PathName       :string = GetWorkDirName();
        var OutFileName    :string = PathName + "\\" + GetExlusiveFileName("out");  // Имя временного файла куда переключим выходной поток (для определения текущего имени)
        var LastNameFileTmp:string = SetOutPut(OutFileName, true)    ;              // Имя текущего выходного потока
        var LastNameFile   :string = "";                                            // Имя результирующего отчета
        var LastNameFileExt:string = "";                                            // Расширение результирующего отчета
        var NameFile       :string = "";                                            // Имя результирующего отчета
        var NameFileExt    :string = "";                                            // Расширение результирующего отчета
        var FullFileName   :string = "";

        SplitFile(_FileName, NameFile, NameFileExt);

        // Обрежем путь и получим только имя 
        SplitFile(LastNameFileTmp, LastNameFile, LastNameFileExt);

        FullFileName = String(PathName,"\\",NameFile, "_", SubStr(LastNameFileExt, 2), NameFileExt);

        // Восстанавливаем поток вывода и удаляем получившийся файл
        SetOutPut(LastNameFileTmp, true);
        DelFile( OutFileName );

        return FullFileName;
    end;

    /* Метод открывает текстовый файл с именен FileName, со статусом Write */
    /* Если не задано имя файла, то предоставляем панель для выбора файла  */
    macro FileOpen( _FileName:string, _Write:bool ) : bool
        m_FileName = _FileName;
        m_Write    = _Write   ;

        m_lsFileName[m_lsFileName.Size] = m_FileName;

        if( m_Write ) 
            m_FileID = __File_CSV_Write__;
        else 
            m_FileID = __File_CSV_Read__ ;
        end;

        // Если не задано имя файла, то предоставляем панель для выбора файла 
        if( NOT this.m_FileName )
            if( NOT SelectFile(this.m_FileName, "*.csv") ) return FALSE; end;
        end;

        if( NOT WR_Open( m_FileID, this.m_FileName ) )
            MsgBox("Ошибка открытия файла <" +this.m_FileName+ ">!");
            return FALSE;
        end;

        return TRUE;
    end;

    macro FileClose()
        CLOSE(m_FileID);
    end;

    // Методы навигации по текстовому файлу. Их действия очевидны. поэтому и не описываю 
    macro EOF()
        return ( NOT NEXT(m_FileID) );
    end;

    macro Get()
        return m_FileID.Str;
    end;

    macro GetFields(Pos:integer)
        return m_FileID(Pos);
    end;

    // Метод возвращает список имен сформированных файлов 
    macro GetlsFileName() : tarray
        return m_lsFileName();
    end;

    macro MoveFirst()
        ReWind( m_FileID );
    end;

    macro MoveNext()
        return NEXT( m_FileID );
    end;

    macro cnv_Double(Value:double, Point:integer)
        if( NOT ValType(Point) )
            Point = SetDefPrec(); 
        end;

        return StrSubst(String(Value:*:*, 0, Point), ".", DecimalSeparator);
    end;

    macro cnv_Money (Value:money, Point:integer)
        return cnv_Double(Value, Point);
    end;

    macro cnv_String(Value:string, p_woQuotes: bool)   
        var l_woQuotes = false;  //по умолчанию ставим вокруг строк кавычки 
        if (ValType(p_woQuotes)!=V_UNDEF)
          l_woQuotes = p_woQuotes;    
        end;  

        var TmpValue:string = StrSubst( StrSubst( Value, "\n", ""), "\r", "");
            
        if( TmpValue )
            if (l_woQuotes) //def-40139
              TmpValue = StrSubst( Value,"\"", ""); //def-40139
              return String(TmpValue);
            else
              return String("\"", StrSubst(TmpValue, "\"", "\"\""), "\"");
            end;
        else  
            return " "; // Добавлено специально, т.к. если пустая последняя ячейка, то все падает на методе AutoFill
        end;
    end;      

    // Пользовательский метод добавления ячейки в строку. Point - кол-во знаков после запятой 
    macro AddCell( Value:variant, Point:integer, woQuotes: bool)
        var TmpStr:string  = "";
        var Type  :integer = ValType(Value); // Тип значения
        var l_woQuotes = false;  //по умолчанию ставим вокруг строк кавычки 
        if (ValType(woQuotes)!=V_UNDEF)
          l_woQuotes = woQuotes;    
        end;  
        if( Type == V_STRING ) 
            if( GetUsePoiMode() )
                if( IsDigitalString(Value) )
               TmpStr = Value;
           else 
                    TmpStr = StrSubst( StrSubst( Value, "\n", ""), "\r", "");
                    if( TmpStr )
                        TmpStr = String("\"", StrSubst(TmpStr, "\"", "\"\""), "\"");
                    else  
                        TmpStr = " "; 
                    end;
                end;
            else 
               TmpStr = this.cnv_String(Value, l_woQuotes);
           end;
        elif( Type == V_UNDEF  )
            TmpStr = " ";
        elif( (Type == V_MONEYL) OR (Type == V_MONEY) OR (Type == V_DOUBLE) OR (Type == V_DOUBLEL) ) 
            TmpStr = cnv_Money( WR_ЧислоCЗаданнойТочностью(Value, Point), Point );
        else     
            TmpStr = WR_ЧислоCЗаданнойТочностью( Value, Point );
        end;

        if( m_CurRow ) 
            m_CurRow = m_CurRow + m_Delim + TmpStr;
        else 
            m_CurRow = TmpStr;
        end;
    end;

    // Пользовательский метод добавления NumEmptyCell-пустых ячеек в строку 
    macro AddEmptyCell( NumEmptyCell:integer )
        var i:integer = 0;

        while( i < NumEmptyCell )
            AddCell(NULL);
            i = i + 1;
        end;
    end;

    // Сформировать новое имя файла 
    private macro CreateNextFileName( _FileName:string ) : string
        var Dir :string = "";
        var Name:string = "";
        var Ext :string = "";

        Dir = SplitFile(m_FileName, Name, Ext);

        // Продолжения уже были
        if( m_lsFileName.Size > 1 )
            SplitFile(m_lsFileName[0], Name, NULL);
        end;

        return string(Dir, Name, "_", m_lsFileName.Size, Ext);
    end;

    macro Set_Func_AddSheet( Func_AddSheet:variant )
        m_Func_AddSheet = Func_AddSheet;
    end;

    // Пользовательский метод добавления строки (сформированной при помощи AddCell()) в текстовый файл 
    macro AddRow(IgnoreMAXROWSHEET)
        if( m_Write )
            if( m_numRow >= m_LimitRow ) /*bpv*/
               if ((ValType(IgnoreMAXROWSHEET) == V_UNDEF) or not IgnoreMAXROWSHEET)
                   // Т.к. превысили лимит, то закроем текущий файл и откроем новый для добавления остатка данных
                   this.FileClose();

                   m_FileName = CreateNextFileName(m_FileName);
                   if( NOT FileOpen( m_FileName, m_Write ) )
                       return false;
                   end;

                    // Запускаем CallBack для отслеживания сообщения "Добавления листа"
                   if( m_Func_AddSheet != NULL )
                       ExecMacro2(m_Func_AddSheet, this);
                   end;

                   m_numRow = 0;
               end;
            end;

            Insert( m_FileID, m_CurRow );
            m_numRow = m_numRow + 1;
        end;

        m_CurRow = "";
    end;

    // Пользовательский метод добавления строки в текстовый файл 
    macro Put(/*Значения ячеек*/)
        var i    :integer = 0;
        var Value:variant = NULL;

        while( GetParm(i = i + 1, Value) )
            AddCell( Value );
        end;

        AddRow();
    end;

    // Пользовательский метода добавления в текстовый файл целой строки, уже отформатированной разделителями
    macro PutRow(NewRow:string)
      m_CurRow = NewRow;
      AddRow();
    end;

    // Пользовательский метод показа полученного файла при помощи стандартного RSL-ного просмотровщика 
    macro View()
        ViewFile(m_FileID);
    end;
end;


class (CTableTmplPOI) CTableSXLSX( TableName:string, HeaderName:string, ObjTemlXLS:object, TxtHeader:string, HeaderOnPage:bool ) 

   private macro SaveTmpTemplate(FileName:string, FileIndex:integer, SheetIndex:integer):bool
       var TemplFile = "";
       var Name:string  = "";
       var Ext :string  = "";
               
       SplitFile( FileName, Name, NULL );
       SplitFile( m_ObjTemlXLS.TemplateName, NULL, Ext);

       TemplFile = String(Name, Ext);
       TemplFile = CreateFullFileName(TemplFile, TemplFile);
       
       if( m_ObjTemlXLS.Check_SaveAs(@TemplFile) )
           if( workbook.saveAs(TemplFile) )
               m_ObjTemlXLS.close();

               CloseWorkbook();

               m_ObjTemlXLS.AddTemplateFile(FileIndex, TemplFile);               

               if( NOT m_ObjTemlXLS.OpenTemplate( m_ObjTemlXLS.TemplateName ) )
                  return false;
               end;

               workbook = m_ObjTemlXLS.GetWorkbook();
               workbook.setActiveSheet(SheetIndex);

               if( Func_AfterReOpenTempleFile != NULL )
                   ExecMacro2(Func_AfterReOpenTempleFile, this, m_ObjTemlXLS.TemplateName);
               end;

               workbook.setTableRange(m_TableName);

               m_NumbSheet = SheetIndex;

               return true;
           end;
       end;

       return false;
   end;

   macro FillTabelFromCSV( FileTxtName:variant, NumbSheet:integer, SymbolDelimiter:string, Coding:integer ):bool          
       var  i               :integer          = 0;    
       var  j               :integer          = 0;
       var  FileNamesList   :tarray           = TArray;  
       var  CreateNewSheet  :bool             = false;
       var  SheetRecordCount:integer          = 0;
       var  HeaderAddress   :CAddressDiapazon = CAddressDiapazon;
       var  Encode          :string           = WR_lsEncode[WR_CURRENCODE].webCharSet;
       var  DeleteLastSheet :bool             = false;

       // Передали имя файла
       if( ValType(FileTxtName) == V_STRING )
           FileNamesList[0] = FileTxtName;
       elif( (ValType(FileTxtName) == V_GENOBJ) AND (StrUpr(GenClassName(FileTxtName)) == "TARRAY") )
           FileNamesList = FileTxtName;
       else
           MsgBox( "[CTableSXLSX.FillTabelFromCSV] Неверный тип первого параметра функции (функий принимает V_STRING или V_GENOBJ<TARRAY>)!" );
           return false;
       end;

       if( NumbSheet )
           m_NumbSheet = NumbSheet;
       end;

       if( NOT SymbolDelimiter )
           SymbolDelimiter = ";";
       end;

       m_ObjTemlXLS.SetUseCSV();

       m_ObjTemlXLS.TabInitProgress( FileNamesList.Size, "...Открытие и заполнение шаблона данными", "Открытие и заполнение шаблона данными...");

       while(i < FileNamesList.Size)
           var FullFileNameServer:string = "";
           var FileFullName:string       = CreateFullFileName(FileNamesList[i], FileFullName);
           var FullFileTxtName           = CreateFullFileName(FileNamesList[i], FullFileNameServer);
           var CurrSheetIndex            = GetWorkbook().getActiveSheetIndex();
           var FileSize:integer          = WR_GetFileSize(FileFullName);
           // Снчала проверим, помещаемся ли на лист. Если нет, то добавить новый
           if( SheetRecordCount + m_ObjTemlXLS.GetReportCreator().getRowCountFromCSV(FileFullName) >= MAXROWSHEET )
               if( Func_BeforeAddSheet != NULL )
                   ExecMacro2(Func_BeforeAddSheet, this, FullFileTxtName);
               end;
  
               var NewSheetName  = GetWorkbook().createSheetByNameAndIndex(GetWorkbook().getSheetNameAt(0), -1, CurrSheetIndex + 1);
               var NewSheetIndex = GetWorkbook().getSheetIndex(NewSheetName);
               var RowTo = 0;
               var ColTo = 0;
               var Count = 0;
                
               // Удалить лишнюю шаблонную строку с текущего листа
               GetWorkbook().removeRow(CurrSheetIndex, m_TableName);

               // Перейти на новый лист
               GetWorkbook().setActiveSheet(NewSheetIndex);
                
               // Добавить на новый лист-продолжение шапку таблицы с номерами столбцов 
                   HeaderAddress = CAddressDiapazon(m_AddressRangeTable.Get_Address());
                   HeaderAddress.OffSet_Row( -HeaderAddress.Get_bRow() );
                   while( Count < HeaderAddress.GetNumbColumn )
                       m_ObjTemlXLS.SetAlign( 0, Count, ALIGN_CENTER );
                       m_ObjTemlXLS.SetValue( 0, Count, Count + 1);
                       Count = Count + 1;
                   end;
                   m_ObjTemlXLS.SetDiapazon( 0, 0, 0, Count - 1);
                   m_ObjTemlXLS.SetBorder();

                   RowTo = HeaderAddress.GetNumbRow();

               // Клонировать шаблонную строку на лист-продолжение   
               GetWorkbook().cloneRange(workbook.getSheetsCount() - 1, NewSheetIndex, m_TableName, RowTo, ColTo);

               GetWorkbook().setTableRange(m_TableName);

               //GetWorkbook().setActiveSheet(NewSheetIndex);
               m_NumbSheet = NewSheetIndex;

               if( Func_AfterAddSheet != NULL )
                   ExecMacro2(Func_AfterAddSheet, this, FullFileTxtName);
               end;

               SheetRecordCount = 0;

               j = j + 1;
           end; 
           
           var SheetIndex = GetWorkbook().getActiveSheetIndex();

           bRowTable = GetWorkbook().getTableRangeFirstRow() + 1;

           AddDeleteRange(CSaveRange(GetWorkbook().getActiveSheetIndex(), m_TableName, m_TableName, FileSize == 0));
                                
           // Сохраним шаблонную строку на отдельном листе, так как после сброса она не доступна.
           if( (i == 0) and (m_ObjTemlXLS.UseTotalBook() == false))
               m_ObjTemlXLS.GetReportCreator().saveTemplateRow(GetWorkbook(), SheetIndex, m_TableName);
               DeleteLastSheet = true;
           end;

           var NeedShiftRowDown = true;
           if( m_ObjTemlXLS.UseTotalBook() )
               NeedShiftRowDown = false
           end;

           var RecordCount = m_ObjTemlXLS.GetReportCreator().fillTableFromCSV(GetWorkbook(), FileFullName, SheetIndex, m_TableName, SymbolDelimiter, Encode, SheetRecordCount, NeedShiftRowDown);
          
           SheetRecordCount = SheetRecordCount + RecordCount;

           AddressDiapazon = CAddressDiapazon (GetWorkbook().getTableRangeString(true));

           eRowTable = GetWorkbook().getTableRangeLastRow() + 1;

           // Для получения корректной формулы нужно подсчитать общее количество строк по всех файлах на одном листе
           if( i == 0 )
              addRowCount = 0;
              var k = 1;
              while( k < FileNamesList.Size )
                  var FileName = CreateFullFileName(FileNamesList[k], FileFullName);
                  addRowCount = addRowCount + m_ObjTemlXLS.GetReportCreator().getRowCountFromCSV(FileName);
                  k = k + 1;
              end;
           end;

           m_lsAddressDiapazon[SheetIndex] = AddressDiapazon;
           
           m_ObjTemlXLS.AddRangesDiapazon(SheetIndex, AddressDiapazon);

           if( Func_AfterAutoFill != NULL )
               ExecMacro2(Func_AfterAutoFill, this, FullFileTxtName, AddressDiapazon.Get_Address());
           end;     

           if( m_ObjTemlXLS.UseTotalBook() )
               if (NOT SaveTmpTemplate(FullFileNameServer, j, CurrSheetIndex) ) 
                   m_ObjTemlXLS.TabRemProgress();
                   return false;
	       end;
           else
               // Сбросить заполненные строки на диск. Останутся последние 100, к остальным доступа больше нет.
               GetWorkbook().flushRow(SheetIndex);

               // Добавить новую копию шаблонной строки, если листов несколько, кроме последнего листа.
               if( (FileNamesList.Size > 1) and (i != (FileNamesList.Size - 1) ) )
                   m_ObjTemlXLS.GetReportCreator().addTemplateRow(GetWorkbook(), SheetIndex, m_TableName, SheetRecordCount);
               end;

           end;

           if( NOT ___FlagDebug___)
               if( ExistFile(toANSI(FullFileTxtName)) )
                   RemoveFile( toANSI(FullFileTxtName) );
               end;
           end;

           i = i + 1;

           m_ObjTemlXLS.TabUseProgress(i, FileNamesList.Size);
       end;    

       if( DeleteLastSheet and (m_ObjTemlXLS.UseTotalBook() == false) )
           m_ObjTemlXLS.GetReportCreator().deleteLastSheet(GetWorkbook());
       end;

       m_ObjTemlXLS.TabRemProgress();

       return true;

   OnError(ObjErr)
       m_ObjTemlXLS.TabRemProgress();
       ErrorMessage(ObjErr, "[CTableSXLSX.FillTabelFromCSV] Oшибка!");
       return false;
   end;

   InitCTableTmplPOI(TableName, HeaderName, ObjTemlXLS, TxtHeader, HeaderOnPage); 
 
end;

class (CTemplateXLS) CTemplateSXLSX( FileName:string )
   var rowAccessSize  = -1;

   macro OpenTemplate( TemplName:string, ShowAppl:bool ) : bool
       
       if( this.OpenTemplate( TemplName, ShowAppl ) ) 
           workbook = reportCreator.openWorkbookSXSSF(workbook, rowAccessSize); 
           return true;
       end;
       return false;
   end;

   macro FlushSheetTotalbook( Sheet:variant )
       var index:integer = 0;

       if( (ValType(Sheet) == V_STRING) )
           index = totalWorkbook.getSheetIndex(Sheet);
       else
           index = Sheet; 
       end;

       totalWorkbook.flushSheet(index);

       return true;

       OnError( ObjError )
           ErrorMessage(ObjError, "[CTemplateSXLSX.FlushSheetTotalbook] Oшибка!");
           return false;

   end;

   macro CheckHeapSize()

       totalWorkbook.CheckHeapSize();

   end;

   macro CreateTotalBook() : bool
       var TemplateDir:string  = "",
           TempStr:string      = "", 
           StrErr:string       = "";

       if( reportCreator == null )
           return false;
       end;
  
       GetRegistryValue( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEMPLSDIR", V_STRING, TemplateDir, StrErr );
      
       TempStr = FindPath(toANSI("Template0.xlsx"), TemplateDir);

       if( TempStr != "")
           if( SubStr(TempStr, 1, 1) == "." )
               TempStr = GetCurDir(FALSE) + "\\" + TempStr;
           end;

           var totalTemplate = reportCreator.openWorkbook( TempStr );

           totalWorkbook = reportCreator.openWorkbookSXSSF(totalTemplate, 100);
       else
           totalWorkbook = reportCreator.addWorkbookSXSSF();
       end;
               
       m_UseTotalBook = true;

       return true;
       
       OnError( ObjError )
           ErrorMessage(ObjError, "[CTemplateSXLSX.CreateTotalBook] Oшибка!");
           return false;
   end;


   macro CopyAllSheetInTotalBook( SheetName:string, _FlagSheet:bool, _CopyPos:string, _PastePos:variant, _PasteSheetName:variant) : bool  
       var FlagSheet    :bool    = true;
       var CopyPos      :string  = ""; 
       var PastePos     :string  = "";
       var PastePosInt  :integer = 0;
       var SheetNameFrom:string  = "";
       var SheetNameTo  :string  = "";

       if( ValType(_FlagSheet) == V_BOOL ) 
           FlagSheet = _FlagSheet;     
       end;

       if( ValType(_CopyPos) == V_STRING ) 
           CopyPos = StrSubst(_CopyPos, "$", "");   
       end; 

       if( ValType(_PastePos)  == V_STRING) 
           PastePos = _PastePos;
           PastePosInt = 0;
       elif( ValType(_PastePos) == V_INTEGER)
           PastePos    = "";
           PastePosInt = _PastePos;
       end;

       var i:integer = 0;
       var rowCount = 0;
       var totalSheetCount = 1;
       var SheetIndex = workbook().getActiveSheetIndex();

       TabInitProgress( m_lsTemplateFile.Size, "...Копирование листа в общую книгу", "Копирование листа в общую книгу..." );

       if( UseCSV() AND m_lsTemplateFile.Size)
           while( i < m_lsTemplateFile.Size )
               if( (ValType(m_lsTemplateFile[i]) == V_GENOBJ) AND (strUpr(GenClassName(m_lsTemplateFile[i])) == "TARRAY") )
                   var j:integer = 0;

                   if (FlagSheet)
                       NeedNewSheet = true;    
                   end; 

                   if( i > 0 )
                       NeedNewSheet = true;
                   end;                   

                   TabInitProgress( m_lsTemplateFile[i].Size, "...Копирование диапазона на лист", "Копирование диапазона на лист..." );

                   while( j < m_lsTemplateFile[i].Size )
                       var tmpWorkbook = GetReportCreator().openWorkbookLight(m_lsTemplateFile[i][j]);
                       if( tmpWorkbook )
                           tmpWorkbook.setActiveSheet(SheetIndex);
                   
                           if( NeedNewSheet )
                               SheetChange(tmpWorkbook.getSheetsCount());   
                           end;

                           if( (ValType(SheetName) != V_STRING) OR (SheetName != tmpWorkbook.getSheetName()))
                               SheetName = tmpWorkbook.getSheetName();
                           end;

                           if( (_PasteSheetName != NULL) and (ValType(_PasteSheetName) == V_STRING) )
                               SheetNameFrom = SheetName;
                               SheetNameTo = _PasteSheetName;
                           elif( SheetName != NULL )
                               SheetNameFrom = SheetName;
                               SheetNameTo = SheetName;
                           else
                               SheetNameFrom = tmpWorkbook.getSheetName();
                               SheetNameTo = totalworkbook.getSheetName();
                           end;
    
                           if( NeedNewSheet OR (NOT totalWorkbook.existsSheet(SheetNameTo) ) )
                               SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo); 
                               tmpWorkbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo); 
                           end;    

                           if( NeedNewSheet )
                               tmpWorkbook.copySheet(totalWorkbook, SheetNameFrom, SheetNameTo);
                               _PasteSheetName = SheetNameTo;
                               NeedNewSheet = false;
                           else 
                               if( (j == 0) and (m_lsTemplateFile[i].Size == 1))
                                  tmpWorkbook.copyRangeToSheet(totalWorkbook, SheetNameFrom, SheetNameTo, CopyPos, PastePos, PastePosInt);
                               else
                                  CopyPos = StrSubst(m_lsRangesDiapazon[SheetIndex][j].Get_Address(), "$", "");

                                  var RowNum = totalWorkbook.getLastAddedRow() + 1;
                                  var ColNum = tmpWorkbook.getRangeFirstCol(CopyPos);

                                  PastePos = tmpWorkbook.getCellRangeAddress(RowNum, RowNum, ColNum, ColNum); 

                                  tmpWorkbook.copyRangeToSheet(totalWorkbook, SheetNameFrom, SheetNameTo, CopyPos, PastePos, 0);
                               end;  
                               rowCount = tmpWorkbook.getRangeRowCount(CopyPos);
                           end;

                           totalSheetCount = totalWorkbook.getSheetsCount();
                           tmpWorkbook.close();
                           tmpWorkbook = null;
                       end;
                       j = j + 1;
                       TabUseProgress( j, m_lsTemplateFile[i].Size );
                   end;
                   TabRemProgress();
               else
                   tmpWorkbook = GetReportCreator().openWorkbookLight(m_lsTemplateFile[i]);
                   if( tmpWorkbook )
                       tmpWorkbook.setActiveSheet(tmpWorkbook.getSheetsCount());
                   
                       if( FlagSheet )
                           SheetNameFrom = tmpWorkbook.getSheetName();
                           SheetNameTo = tmpWorkbook.getSheetNameAt(0);

                           if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                               SheetNameTo = _PasteSheetName;
                           end;

                       else  
                           if( (ValType(SheetName) != V_STRING) OR (SheetName != tmpWorkbook.getSheetName()))
                               SheetName = tmpWorkbook.getSheetName();
                           end;

                           if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                               SheetNameFrom = SheetName;
                               SheetNameTo = _PasteSheetName;
                           elif( SheetName != null )
                               SheetNameFrom = SheetName;
                               SheetNameTo = SheetName;
                           else
                               SheetNameFrom = tmpWorkbook.getSheetName();
                               SheetNameTo = totalworkbook.getSheetName();
                           end;
    
                       end;

                       if( NOT totalWorkbook.existsSheet(SheetNameTo) )
                           SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo); 
                           tmpWorkbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo); 
                       end;    

                       tmpWorkbook.copySheet(totalWorkbook, SheetNameFrom, SheetNameTo);              

                       totalSheetCount = totalWorkbook.getSheetsCount();
                       tmpWorkbook.close();
                       tmpWorkbook = null;
                   end;

               end;
               i = i + 1;
               TabUseProgress( i, m_lsTemplateFile.Size );
           end;

           RemoveTemplateFile();
           m_lsTemplateFile.Size = 0;
       else  
           if( FlagSheet )
               i = 1;
               while( i <= SheetCount() )
                   SheetChange(i);
                   workbook.copySheet(totalWorkbook, workbook.getSheetName(), workbook.getSheetName());
                   totalSheetCount = totalWorkbook.getSheetsCount();
                   NeedNewSheet = true;
                   i = i + 1;
               end;
           else   
               if( (ValType(SheetName) == V_STRING) )
                   SheetChange(SheetName);
               end;

               if( (ValType(SheetName) != V_STRING) OR (SheetName != workbook.getSheetName()))
                   SheetName = workbook.getSheetName();
               end;

               if( (_PasteSheetName != null) and (ValType(_PasteSheetName) == V_STRING) )
                     SheetNameFrom = SheetName;
                     SheetNameTo = _PasteSheetName;
               elif( SheetName != null )
                     SheetNameFrom = SheetName;
                     SheetNameTo = SheetName;
               else
                     SheetNameFrom = workbook.getSheetName();
                     SheetNameTo = totalworkbook.getSheetName();
               end; 
                       

               if( NOT totalWorkbook.existsSheet(SheetNameTo) )
                   NeedNewSheet = true;
               end;  

               if( NeedNewSheet)
                   SheetNameTo = totalWorkbook.createSheetByName(SheetNameTo);
                   workbook.copySheetSettings(totalWorkbook, SheetNameFrom, SheetNameTo); 
               else
                   RowNum = totalWorkbook.getLastAddedRow() + 1 + PastePosInt;
                   ColNum = workbook.getRangeFirstCol(CopyPos);
                   PastePos = workbook.getCellRangeAddress(RowNum, RowNum, ColNum, ColNum); 
               end;

               workbook.copyRangeToSheet(totalWorkbook, SheetNameFrom, SheetNameTo, CopyPos, PastePos, PastePosInt);

               totalSheetCount = totalWorkbook.getSheetIndex(SheetNameTo);
               rowCount = workbook.getRangeRowCount(CopyPos);                
           end;       
       end;
               
       if( NeedNewSheet )
           NeedNewSheet = false;
       end;

       TabRemProgress(); 
       
       return true;
        

       OnError( ObjError )
           TabRemProgressAll();  /* DEF-44748, при ошибке нужно удалить все прогресс-бары, а не только последний  */ 
           ErrorMessage(ObjError, "[CTemplateSXLSX.CopyAllSheetInTotalBook] Oшибка!");
           return false; 
   end;

   macro RegisterTable( TableName:string, HeaderName:string, HeaderOnPage ):object   
       return CTableSXLSX( TableName, HeaderName, this, NULL, HeaderOnPage );
   end;

   macro SaveTotalBook( NameFile:string, ShowAppl:bool, SaveExistingBook:bool ):bool
       if( totalWorkbook.getSheetsCount() > 1 )
           totalWorkbook.removeSheet(0);
       end;              
   
       this.SaveAsTotalbook(NameFile, ShowAppl, SaveExistingBook);

       workbook = totalWorkbook;
         
       OnError( ObjError )
           ErrorMessage(ObjError, "[CTemplateSXLSX.SaveTotalBook] Oшибка!");
           return false;
   end;

   macro GetTotalWorkbook()
     if (totalWorkbook)
        return totalWorkbook;
     end;
     return null;
   end;

   InitCTemplateXLS( FileName, NULL, NULL, NULL, NULL, NULL, true, true, NULL );
   
   SetXLSXFormat();
end;

class (CTemplateSXLSX) CTemplateTrueSXLSX( FileName:string )
  InitCTemplateSXLSX(FileName);

  workbook = GetReportCreator().openWorkbookSXSSF(workbook, -1);
end;

class (CTemplateSXLSX) CTemplateLightSXLSX( FileName:string )
             
  InitCTemplateSXLSX(FileName);

  rowAccessSize = 100;
end; 