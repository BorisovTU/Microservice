/************************************************************************/
/*         Автоматизированная банковская система RS-Bank                */
/*                 Copyright (c) R-Style Software Lab 2000              */
/*                                                                      */
/*  Имя файла        : tximport.mac                                     */
/*                                                                      */
/*  Описание         : Макрос импорта бюджетных классификаторов         */
/*                                                                      */
/*  Программист      : Бурак В.Ю.                                       */
/*                                                                      */
/*  Создан           : 07.09.00                                         */
/*                                                                      */
/************************************************************************/

const Пустое_значение = "NULL",
      TX_EMPTY       = 1,
      TX_DELIMITER   = 2,
      TX_NODELIMITER = 3,
      TX_WRONGFILEFORMAT = 4,
      TX_INSERT      = 5,
      TX_EOF         = 6;

record txy_record( bt_txy );
record tx_record ( bt_tx );
record nact_record( bt_nact );

var Разделитель, Количество_полей;


macro StrToDate (Строка: string)
  var D, M, Y;
  if ( Строка == Пустое_значение )
     Y = 0;
     M = 0;
     D = 0;
  else
     Y = Int (SubStr ( Строка, 1, 4 ));
     M = Int (SubStr ( Строка, 5, 2 ));
     D = Int (SubStr ( Строка, 7, 2 ));
  end;
  return Date (D, M, Y);
end;

macro div_mod( arg1, arg2 )         /* Остаток от деления arg1 на arg2 */
  return arg1 - (arg1/arg2)*arg2;
end;

macro Чтение_разделителя( Буфер_строки )
    var Строка = trim( Буфер_строки ),
                 Длина_строки = strlen( Строка );

    if( Длина_строки == 0 )
      return TX_EMPTY;
    end;
    if( Длина_Строки == 1 )
      Разделитель = Строка;
      return TX_DELIMITER;
    end;
    if( Длина_Строки > 1 )
      return TX_NODELIMITER;
    end;
end;

macro Вырезать_данное_из_строки( Строка, Поле )
      var pos = Index( Строка, Разделитель ), real_pos = 0, real_len = 0,
          next_chr, count = 0, Остаток_строки, stat = 0;

      if( not strlen( Строка ) )
         return stat = TX_WRONGFILEFORMAT;
      end;

      if( pos )
        Остаток_строки = Строка;
        while( ( not real_pos) and (pos) and (not stat) )
          count = 1;
          next_chr = SubStr( Остаток_строки, pos+count, 1);
          while( next_chr == Разделитель )
            count = count + 1;
            next_chr = SubStr( Остаток_строки, pos+count, 1);
          end;
          if( not div_mod( count, 2) )
            real_len = real_len+pos+count-1;
            Остаток_строки = SubStr( Остаток_строки, pos+count );
            pos = Index( Остаток_строки, Разделитель );
            if( (not pos) and (not strlen(Остаток_строки)) )
              stat = TX_WRONGFILEFORMAT;
            end;
            if( (not pos) and strlen(Остаток_строки) )/*значит последнее поле*/
             real_pos = strlen(Остаток_строки) + 1;
            end;
          else
            real_pos = real_len+pos+count-1;
          end;
        end;
      else
        if( not strlen(Строка) )
          stat = TX_WRONGFILEFORMAT;
        else
          Остаток_строки = Строка;
          real_pos = strlen(Остаток_строки) + 1;
        end;
      end;
      if ( stat )
        return stat;
      end;

      Поле   = SubStr( Строка, 1, real_pos - 1);
      Строка = Substr( Строка, real_pos + 1 );

      SetParm( 0, Строка );
      if( Поле != Пустое_значение )
        StrSubst( Поле, Разделитель+Разделитель, Разделитель );
        SetParm( 1, Поле );
      end;

      return stat;
end;

macro Прием_классификаторов( Строка )
      var stat;

      stat = Вырезать_данное_из_строки( Строка, txy_record.ID );
      if( stat )
        return stat;
      else
        txy_record.ID = Int(txy_record.ID);
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.Tag );
      if( stat )
        return stat;
      else
        if( strlen(txy_record.Tag) > 12 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.Caption );
      if( stat )
        return stat;
      else
        if( strlen(txy_record.Caption) > 12 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.Note );
      if( stat )
        return stat;
      else
        if( strlen(txy_record.Note) > 255 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.CB1 );
      if( stat )
        return stat;
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.CB2 );
      if( stat )
        return stat;
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.CB3 );
      if( stat )
        return stat;
      end;

      stat = Вырезать_данное_из_строки( Строка, txy_record.CB4 );
      if( stat )
        return stat;
      end;

/*      if( (not txy_record.CB1) and (not txy_record.CB2) and
          (not txy_record.CB3) and (not txy_record.CB4) )
        return stat = TX_WRONGFILEFORMAT;
      end;       */

      stat = Вырезать_данное_из_строки( Строка, txy_record.MaxLen );
      if( stat )
        return stat;
      else
        txy_record.MaxLen = Int(txy_record.MaxLen);
      end;

      return stat = TX_INSERT;
end;

macro Прием_элементов_классификаторов( Строка )
      var stat, txtDate1, txtDate2;

      stat = Вырезать_данное_из_строки( Строка, tx_record.ID );
      if( stat )
        return stat;
      else
        tx_record.ID = Int(tx_record.ID);
      end;

      stat = Вырезать_данное_из_строки( Строка, tx_record.Code );
      if( stat )
        return stat;
      else
        if( strlen(tx_record.Code) > 12 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      stat = Вырезать_данное_из_строки( Строка, tx_record.Taxonomy );
      if( stat )
        return stat;
      else
        tx_record.Taxonomy = Int(tx_record.Taxonomy);
      end;

      stat = Вырезать_данное_из_строки( Строка, tx_record.Superior );
      if( stat )
        return stat;
      else
        tx_record.Superior = Int(tx_record.Superior);
      end;
      /*
      stat = Вырезать_данное_из_строки( Строка, txtDate1);
      if( stat )
        return stat;
      else
        tx_record.Approved = StrToDate (txtDate1);
      end;*/

      stat = Вырезать_данное_из_строки( Строка, tx_record.Approval );
      if( stat )
        return stat;
      else
        tx_record.Approval = Int(tx_record.Approval);
      end;

     /* stat = Вырезать_данное_из_строки( Строка, txtDate2);
      if( stat )
        return stat;
      else
        tx_record.Abolished = StrToDate ( txtDate2 );
      end;*/

      stat = Вырезать_данное_из_строки( Строка, tx_record.Abolishment );
      if( stat )
        return stat;
      else
        tx_record.Abolishment = Int(tx_record.Abolishment);
      end;

      stat = Вырезать_данное_из_строки( Строка, tx_record.Note );
      if( stat )
        return stat;
      else
        if( strlen(tx_record.Note) > 1024 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      return stat = TX_INSERT;

end;

macro Прием_нормативных_актов( Строка )
      var stat;

      stat = Вырезать_данное_из_строки( Строка, nact_record.ID );
      if( stat )
        return stat;
      else
        nact_record.ID = Int(nact_record.ID);
      end;

      stat = Вырезать_данное_из_строки( Строка, nact_record.Caption );
      if( stat )
        return stat;
      else
        if( strlen(nact_record.Caption) > 128 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      stat = Вырезать_данное_из_строки( Строка, nact_record.Note );
      if( stat )
        return stat;
      else
        if( strlen(nact_record.Note) > 1024 )
          return stat = TX_WRONGFILEFORMAT;
        end;
      end;

      return stat = TX_INSERT;
end;

macro ОтчетИмпортаБК (Error, NumberTxy, NumberTx, NumberNact)
           [              Отчет об импорте бюджетных классификаторов      ];
           [ ];
   if (Error == 0)
      [+------------------------------------------------------+--------------------+];
      [| импортируемые данные                                 | количество записей |];
      [+------------------------------------------------------+--------------------+];
      [| коды бюджетных классификаторов                       | ################## |](NumberTxy);
      [+------------------------------------------------------+--------------------+];
      [| бюджетные классификаторы                             | ################## |](NumberTx);
      [+------------------------------------------------------+--------------------+];
      [| нормативные акты                                     | ################## |](NumberNact);
      [+------------------------------------------------------+--------------------+];
   else
           [              Даные не импортированы, были ошибки.];
        end;

end;

