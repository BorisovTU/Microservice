/*
$Name: MessageWs.mac
$Module: Ядро ГКБО
$Description: Функция передать ответ в Web Sphere
*/

import BankInter, RSD ;
import "QueueWSClass.mac", "QueueWSLib.mac", "serviceaction.mac", "commonutil.mac", "email_notifyfun.mac";

private const UOL_WEB_SPHERE = 1495;
                  


/*
@brief функция для вставки во временную таблицу отправляемых xml в ответе на сервис GetBrokerContractInfo
@param[in] encode кодировка вставляемой xml
@param[in] message xml
*/
                 
private macro LogOnOff(encode,message)
  var errCode: Integer;
  var OnOff = false,cmd,rs;

  const GetBrokerReg ="РСХБ\\ИНТЕГРАЦИЯ\\ВКЛЮЧИТЬ_ЛОГИ_GETBROKERCONTRACT";  

  GetRegistryValue(GetBrokerReg, V_BOOL, OnOff, errCode);

  if(errCode!=0)
    OnOff = false;
  end;

  if(OnOff)
    cmd = RSDCommand( "insert into getbroker_tmp (t_encoding,t_message) values(:Encoding,:xml)" );
    cmd.addParam( "Encoding", RSDBP_IN, encode );
    cmd.addParam( "xml", RSDBP_IN, message );
    cmd.Execute();
  end;

end;

 
private macro InsQueueMessageToWS(QueueID, ReqIDTrEn, ReqIDMes, JMSCorrelationID, XMLTrEn)
  var stat = 0;
  var OutId = 0;
  var cmd;
  var strQ = "";

  var Expiration = GetWaitingSynWS();

  if(ReqIDMes != "")
    strQ =  "{ ? = CALL RSI_RSB_WEB_SPHERE.InsRequestToWS(?, ?, ?, ?, ?, ? )  }";
  else
    strQ =  "{ ? = CALL RSI_RSB_WEB_SPHERE.InsRequestToWS(?, ?, NULL, ?, ?, ? )  }";
  end;

  cmd = RSDCommand( strQ );

  cmd.addParam( "retv", RSDBP_OUT, V_INTEGER );
  cmd.addParam( "", RSDBP_IN, QueueID   );
  cmd.addParam( "", RSDBP_IN, ReqIDTrEn );
  if(ReqIDMes != "")
    cmd.addParam( "", RSDBP_IN, ReqIDMes  );
  end;
  cmd.addParam( "", RSDBP_IN, JMSCorrelationID ); 
//  cmd.addParam( "", RSDBP_IN, Utf8ToOem(XMLTrEn)   );
  cmd.addParam( "", RSDBP_IN, XMLTrEn    );
  cmd.addParam( "", RSDBP_IN, Expiration );
  

  cmd.execute();

  if (cmd.value("retv") != 0)
    stat = cmd.value("retv");
  end;

  if(stat == 0)
    return true;
  else
    return false;
  end;
end;

private macro GetExtentionSubStr(xml)

  var str = "";

  if(xml != null)

    var pos_start = RsRegexSearch(xml, "<\\w+:Extention");

    var pos_end = 0;

    var pos = pos_start;

    var indx = RsRegex("<\\/\\w+:Extention>");

    while ((pos = indx.indexIn(xml, pos)) != -1)
        pos = pos + indx.matchedLength();
        pos_end = pos;
    end;

    str = substr(xml, pos_start, pos_end - pos_start + 1);
  
  end;

  return str;
  
end;

private macro GetDefQueueID()

  var p = 0;

  var cmd, rs;

  var query = "select q.t_id from dqueuews_dbt q where q.t_isdefault = 'X' and q.t_type = 2"; // исходящая

  cmd = RsdCommand(query);
  rs = RsdRecordset(cmd);

  if(rs.movenext)

    p = SQL_ConvType(rs.value("t_id"));

  end;

  return p;

end;

private macro GetQueueIDIn(QueueID)

  var p = 0;

  var cmd, rs;

  var query = "select qr.t_queueidin from dqueuerelws_dbt qr where qr.t_queueidout = ?";

  cmd = RsdCommand(query);
  
  cmd.addParam( "", RSDBP_IN, QueueID);
  
  rs = RsdRecordset(cmd);

  if(rs.movenext)

    p = SQL_ConvType(rs.value("t_queueidin"));

  end;

  return p;

end;

private macro GetACCounterpartyCode(ACCounterparty)

  var p = "";
  
  var query, cmd, rs;
  
  query =   " SELECT llvalues.T_CODE CODE               "+
    " FROM dllvalues_dbt llvalues               "+
    " WHERE  llvalues.T_LIST = 4067 AND llvalues.T_ELEMENT  = ? ";

  cmd = RsdCommand(query);

  cmd.addParam( "ACCounterparty", RSDBP_IN, ACCounterparty);

  rs = RsdRecordset(cmd);

  if (rs.movenext)

      p = rs.value("CODE"); 
    
  end;
  
  return p;
  
end;


macro CryptXmlRequestToWS_JCP(xmltxt, error)
   var cmd = RsdCommand("select t_keyinformation from dkeyinfows_dbt where t_iskeyactive = 'X' order by t_id desc");
   var pp = RsdRecordSet(cmd);

   cmd.execute();
   if( pp.moveNext())
      var jvm = createObject( "rsjvm", "TJavaHost" );
      var hcp = jvm.CreateJavaObject( "ru.softlab.hmac.HmacCP" );
      hcp.setEncryptedKey(pp.value("t_keyinformation"));
      hcp.setSigner("SOFR");

      var b64req = "";
      //EncodeBase64(OemToUtf8(xmltxt), b64req);
      EncodeBase64(xmltxt, b64req);
      var res64 = hcp.injectHMACBase64(b64req);

      var tmp = "";
      DecodeBase64(res64 , tmp);

      //var res = Utf8ToOem(tmp);
      var res = tmp;
      //var res = hcp.injectHMAC(xmltxt);
      //println(res);
      if (res == "")
         RunError("Ошибка: ошибка наложения МЦ.");
      end;
      return res;
   else
      RunError("Ошибка: нет активных ключей.");
   end;
OnError(err)
   error = err;

end;

macro SendMessageToWSEx(QueueID     :integer,    // ИД очереди.
                        ReqIDMes    :string,     // ИД сообщения.
                        SenderID    :string,     // Идентификатор Бэк Офиса. (не понятно, как передавать через транспортный конверт, как вариант для типа 1 передавать через вторую секцию param, типа 2 передавать через блок расширений).
                        BranchNumber:string,     // Подразделение системы-назначения.
                        JMSMessageIDInit:string, // ИД исходного сообщения, на которое сформирован Ответ.
                        DataType    :integer,    // ИД типа данных
                        RequestText :string,     // Бизнес данные в виде XML.
                        StatusStr   :string,     // Статус ответа (обязательно для типа 2) (см. Д2).
                        Description :string,     // Текст ошибки если  RequestText = null (только для типа 2) (см. Д2).
                        Code        :integer,    // Код результата (обязательно для типа 2) (см. Д2).
                        QueueIDMes  :integer,    // Очередь, в которой искать сообщение, можно передать 0 
                        TypeMes     :integer,    // Тип очереди, в которой искать сообщение, можно передать 0  
                        Extention,               // Extentions
                        FromSystemReq:string      // Система, отправившая запрос
)

  var ResGetMessage = TResSubmitAnswerToWS;

  ResGetMessage.ReqIDMes = ReqIDMes;
  ResGetMessage.SenderID = SenderID;
  ResGetMessage.ResultCode = 0;
  var sigXmltxt = "";
  var cmd, rs;
  var SelXml = "";

/*
  var ReqIDMes      :String   = ""; // Из входящих параметров  +
  var SenderID      :String   = ""; // Из входящих параметров  +
  var ResultCode    :String   = ""; // Результат обработки +
  var ResultText    :String   = ""; // Текст ошибки  
  var JMSMessageID  :String   = ""; // ИД сообщения, переданного в ИП  
*/                   

  private FILE DataTypeWS(DataTypeWS);
  private FILE MonTrEnWS(MonTrEnWS);
  var stat = 0;
  var error, parser;
  var FullPathXSD = "";
  var TypeEnvelope = 2;
  var FromSystem = "";
  var TransXmlText = "";
  var EMail = "";
  var retv;
  var QueueIDIn = 0;



  if(ResGetMessage.ReqIDMes == "")
    ResGetMessage.ReqIDMes = CreateGUID();
  end;
  
  if(QueueID == 0)
    QueueID = GetDefQueueID();
  end;
  
  QueueIDIn = GetQueueIDIn(QueueID);
  
  if(QueueIDIn == 0)
    ResGetMessage.ResultCode = 1008; // Не найдена связанная входящая очередь для переданной исходящей очереди  
    ResGetMessage.ResultText = "Не найдена связанная входящая очередь для переданной исходящей очереди";

    WriteXrLogQueueWS(SRV_XR_KIND_OUT, ResGetMessage.ReqIDMes, RequestText, ResGetMessage.ResultCode);
  end;

  if(QueueIDMes == 0)
    QueueIDMes = QueueIDIn    ;
    TypeMes    = TYPE_QUEUE_IN;
  end;
  
  stat = 0;
  GetRegistryValue( "COMMON\\QUEUE\\E-MAIL", V_STRING, EMail, stat );

  ClearRecord(DataTypeWS);
  DataTypeWS.ID = DataType;
  if(getEQ(DataTypeWS))
    if(DataTypeWS.FileNameXSD != "")
      var regValue = "";
      GetRegistryValue( "COMMON\\QUEUE\\ПУТЬ К XSD", V_STRING, regValue, stat );

      if(regValue != "")
        FullPathXSD = regValue + "\\" + DataTypeWS.FileNameXSD;
      else
        FullPathXSD = DataTypeWS.FileNameXSD;
      end;

      var IsValidFile = ValidateXmlXsd(RequestText, FullPathXSD, @parser);
      if (not IsValidFile)
          ResGetMessage.ResultCode = 1001; //Контроль по XSD схеме не пройден
          ResGetMessage.ResultText = "Контроль по XSD схеме "+ DataTypeWS.FileNameXSD + " не пройден. " + parser ;
                            
          WriteXrLogQueueWS(SRV_XR_KIND_OUT, ResGetMessage.ReqIDMes, RequestText, ResGetMessage.ResultCode);
      end;
    end;  
  else
    ResGetMessage.ResultCode = 1100; // Запись справочника типов данных не найдена. ID =  
    ResGetMessage.ResultText = "Запись справочника типов данных не найдена. DataType = " + DataType ;

    WriteXrLogQueueWS(SRV_XR_KIND_OUT, ResGetMessage.ReqIDMes, RequestText, ResGetMessage.ResultCode);
  end;

  if(ResGetMessage.ResultCode == 0)
    cmd = RSDCommand( "SELECT t_ReqIDTrEn FROM dqueuelinks_dbt WHERE t_JMSMessageID = ? AND t_QueueID = ? AND t_Type = ?" );
    cmd.NullConversion = true;
    cmd.addParam( "", RSDBP_IN, JMSMessageIDInit); // ??JMSMessageID
    cmd.addParam( "", RSDBP_IN, QueueIDIn       );
    cmd.addParam( "", RSDBP_IN, TYPE_QUEUE_IN );

    rs = RsdRecordSet(cmd);
    if (rs.moveNext())
      var ReqIDTrEnIn = rs.value("t_ReqIDTrEn");
    end; 
  end;


  if(ResGetMessage.ResultCode == 0)
    error = 0;
    GetRegistryValue( "COMMON\\QUEUE\\ТИП КОНВЕРТА", V_INTEGER, TypeEnvelope, error );
    
    if(error != 0)
      TypeEnvelope = 2;
    end;

    error = 0;
    GetRegistryValue( "COMMON\\QUEUE\\КОД СИСТЕМЫ", V_STRING, FromSystem, error );

    TransXmlText = TransXmlQueueWS( RequestText );
    var xmltxt = "";
    if(TypeEnvelope == 2)

      cmd = RSDCommand( "SELECT t_ID, length(t_Message) as len, t_Message FROM dxr_log_dbt WHERE T_REQID IN (SELECT T_REQIDMES FROM dqueuelinks_dbt WHERE  T_QUEUEID = ? AND T_TYPE = ? AND T_REQIDTREN = ?)" );
      cmd.NullConversion = true;
      cmd.addParam( "", RSDBP_IN, QueueIDMes     );
      cmd.addParam( "", RSDBP_IN, TypeMes        );
      cmd.addParam( "", RSDBP_IN, ReqIDTrEnIn    );

      rs = RsdRecordSet(cmd);
      if (rs.moveNext())
        var LenXml = int(rs.value("len"));
        rs.Fld("t_Message").Read(SelXml, LenXml);
      end; 

      // DEF-13631 когда во входящем блоке описание xmlns не находится внутри тега Extention, код перестает быть универсальным, нужен заголовок
      //var xmlExtention = extension_mes;
      var temp_Extention;
      var ToSystem;
      if (ValType(FromSystemReq) == V_Undef)
         ToSystem = GetACCounterpartyCode(DataTypeWS.ACCounterparty)
      else
         ToSystem = FromSystemReq;
      end;

      CaptureOutput;      
      println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
      println("<operation xmlns:sec=\"http://rshb/transport/security\" xmlns:bons2=\"http://rshb/transport/envelope\"");
      println("    xmlns=\"http://rshb/transport/interface\">");
      println("    <input>");
      println("        <bons2:Header>");
      println("            <bons2:FromSystem>"+FromSystem+"</bons2:FromSystem>");
//      println("            <bons2:ToSystem>"+GetACCounterpartyCode(DataTypeWS.ACCounterparty)+"</bons2:ToSystem>");
      println("            <bons2:ToSystem>"+ToSystem+"</bons2:ToSystem>");
      println("            <bons2:Direction>ANSWER</bons2:Direction>");
      println("            <bons2:FromBranch>"+BranchNumber+"</bons2:FromBranch>");
      //println("            <bons2:ToBranch>"+GetACCounterpartyCode(DataTypeWS.ACCounterparty)+"</bons2:ToBranch>"); ????
      println("            <bons2:ToBranch>"+BranchNumber+"</bons2:ToBranch>");
      println("            <bons2:Interaction>ASYNC</bons2:Interaction>");
      println("            <bons2:Service>"+DataTypeWS.ParmIP+"</bons2:Service>");
      println("        </bons2:Header>");
      println("        <bons2:Message>"+TransXmlText+"</bons2:Message>");
      println("        <bons2:Result Status=\""+StatusStr+"\">");
      println("                     <bons2:Code>"+Code+"</bons2:Code>");
      
      if ((Description!= "") and (ValType(Description) != V_UNDEF))
        println("                     <bons2:Description>"+Description+"</bons2:Description>");
      end;
      
      println("        </bons2:Result>");
      for (temp_Extention, Extention)
         println("     <bons2:Extention>");
         println("        <bons2:name>"+temp_Extention.name+"</bons2:name>");
         println("        <bons2:value>"+temp_Extention.value+"</bons2:value>");
         println("     </bons2:Extention>");
      end;
      println("    </input>");
      println("</operation>"+" ");

      xmltxt = StopCaptureOutput;
    elif(TypeEnvelope == 1)
      
      CaptureOutput;

      println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
      println("<ba1:plc_acct_get xmlns:ba1=\"http://OnlineBankToEsb/OnlineBank\"");
      println("    xmlns:se=\"http://rshb/transport/security\" xmlns:tns=\"http://bis.ru/transport\">");
      println("    <input fromBranch=\""+BranchNumber+"\" fromSystem=\""+FromSystem+"\" toSystem=\""+GetACCounterpartyCode(DataTypeWS.ACCounterparty)+"\" operation=\"\" pass=\"ASYNC\"");
      println("        service=\""+DataTypeWS.ParmIP+"\" toBranch=\""+GetACCounterpartyCode(DataTypeWS.ACCounterparty)+"\" userDirect=\"REQUEST\">");
      println("        <tns:parameters>");
      println("            <tns:param>");
      println("                <tns:name>DATA</tns:name>");
      println("                <tns:num>1</tns:num>");
      println("                <tns:type>DATASET</tns:type>");
      println("                <tns:value>"+TransXmlText+"</tns:value>");
      println("                <tns:format>NOTCODED</tns:format>");
      println("            </tns:param>");
      println("        </tns:parameters>");
      println("    </input>");
      println("</ba1:plc_acct_get>");

      xmltxt = StopCaptureOutput;
    end;

      // с этого момента, перед подписанием конвертируем в Utf8  
      xmltxt = OemToUtf8(xmltxt);
      var err = null;

      if(DataTypeWS.IsMacInfo == "X")
        //CB_CryptXmlRequestToWS(xmltxt, sigXmltxt, ResGetMessage.ResultCode, ResGetMessage.ResultText);
        sigXmltxt = CryptXmlRequestToWS_JCP(xmltxt, @err);
      else
        sigXmltxt = xmltxt;
      end;

      if (err != null)
         // TODO : обработка ошибок
      end;

      var sigXmltxtOem = Utf8ToOem(sigXmltxt);
      if(ResGetMessage.ResultCode == 0)
        WriteAuditLog(UOL_WEB_SPHERE, sigXmltxtOem);
      end;

      if(ResGetMessage.ResultCode == 0)
        var ReqIDTrEnOut = CreateGUID();
        WriteXrLogQueueWS(SRV_XR_KIND_OUT, ReqIDTrEnOut, sigXmltxtOem, ResGetMessage.ResultCode);
      end;

      if(ResGetMessage.ResultCode == 0)
         var sigXmltxtLen = strlen(sigXmltxt);

         // Если больше 500kB 
         if(sigXmltxtLen > 512000)
           if(EMail != "")
             AddNotifyToDbt("WebSphere ошибка.", "Превышен размер сообщения "+sigXmltxtLen, EMail);
             SendNotyfyToEmail(false, false);                               
           end;
           
           ResGetMessage.ResultCode = 1004; //  Превышен размер сообщения  
           ResGetMessage.ResultText = "Превышен размер сообщения " + sigXmltxtLen;
         end;
      end;

//def-62960
      if(DataTypeWS.ParmIP == "GetBrokerContractInfo") 
         LogOnOff("CryptXml_UTF8",sigXmltxt);
      end;

      if(ResGetMessage.ResultCode == 0)
         retv = InsQueueMessageToWS(QueueID, ReqIDTrEnOut, ResGetMessage.ReqIDMes, JMSMessageIDInit, sigXmltxt);

         if(not retv)
           ResGetMessage.ResultCode = 1101; //  Ошибка вставки конверта в очередь.
           ResGetMessage.ResultText = "Ошибка вставки конверта в очередь.";
         end;
      end;

      if(ResGetMessage.ResultCode == 0)
        error = 0;
        var WaitingSyn = GetWaitingSynWS();

        var MonTrEnID = 0;
        var Sec       = 0;
        
        //if(IsSync == false)

          cmd = RSDCommand( "SELECT t_ID, ((sysdate - TO_DATE(TO_CHAR( mon.t_SysDate, 'DD.MM.YYYY ') || TO_CHAR(mon.t_SysTime, 'HH24:MI:SS'), 'DD.MM.YYYY HH24:MI:SS')) * 86400) AS sec "+
                            "  FROM DMonTrEnWS_dbt mon, DQueueLinks_dbt que  WHERE  mon.t_ReqIDTrEn=que.t_ReqIDTrEn AND  mon.t_IsTimeOut=CHR(0)  " +
                            "  AND que.t_ReqIDTrEn = ? AND que.t_QueueID = ? AND que.t_Type = ? "
                          );

          cmd.NullConversion = true;
          cmd.addParam( "", RSDBP_IN, ReqIDTrEnIn    );
          cmd.addParam( "", RSDBP_IN, QueueIDIn        );
          cmd.addParam( "", RSDBP_IN, TYPE_QUEUE_IN );
          rs = RsdRecordSet(cmd);
          if (rs.moveNext())
            MonTrEnID = rs.value("t_ID");
            Sec = rs.value("Sec");

          //  Sec = Sec *1000;
          end; 

          if(MonTrEnID > 0)
            if(Sec > WaitingSyn)
              cmd = RSDCommand( "UPDATE DMonTrEnWS_dbt SET t_IsTimeOut='X' WHERE t_ID = ?" );
              cmd.addParam( "", RSDBP_IN, MonTrEnID );
              cmd.Execute();
            else
              cmd = RSDCommand( "UPDATE DMonTrEnWS_dbt SET t_YesAnswer='X' WHERE t_ID = ?" );
              cmd.addParam( "", RSDBP_IN, MonTrEnID );
              cmd.Execute();
            end;
          end;
      end;
      
      if(ResGetMessage.ResultCode == 0)
        var StartDateTime; 
        var CurDateTime;
        var JMSMessageID = "";
        var MessageXML = "";
      
        StartDateTime = CB_GetTimeBigInt();
        //StartDateTime = StartDateTime *1000; // в миллисекунды
        CurDateTime = StartDateTime;

        while((JMSMessageID == "") AND ((CurDateTime - StartDateTime) <= WaitingSyn)) 
          cmd = RSDCommand( "SELECT t_JMSMessageID FROM dqueuelinks_dbt WHERE t_ReqIDTrEn = ? AND t_QueueID = ? AND t_Type = ?" );
          cmd.NullConversion = true;
          cmd.addParam( "", RSDBP_IN, ReqIDTrEnOut      );
          cmd.addParam( "", RSDBP_IN, QueueID        );
          cmd.addParam( "", RSDBP_IN, TYPE_QUEUE_OUT );

          rs = RsdRecordSet(cmd);
          if (rs.moveNext())
            JMSMessageID = rs.value("t_JMSMessageID");
          end; 

          CurDateTime = CB_GetTimeBigInt();
          //CurDateTime = CurDateTime * 1000; // в миллисекунды
        end;

        if(JMSMessageID != "")
          ResGetMessage.JMSMessageID = JMSMessageID;
        else
          ResGetMessage.ResultCode = 1103; //  Ответ на запрос не получен в асинхронном режиме
          ResGetMessage.ResultText = "Ответ на запрос не получен в асинхронном режиме";
        end;
      end;
  end;

  return ResGetMessage;
end;


macro SendMessageToWS(QueueID     :integer,    // ИД очереди.
                      ReqIDMes    :string,     // ИД сообщения.
                      SenderID    :string,     // Идентификатор Бэк Офиса. (не понятно, как передавать через транспортный конверт, как вариант для типа 1 передавать через вторую секцию param, типа 2 передавать через блок расширений).
                      BranchNumber:string,     // Подразделение системы-назначения.
                      JMSMessageIDInit:string, // ИД исходного сообщения, на которое сформирован Ответ.
                      DataType    :integer,    // ИД типа данных
                      RequestText :string,     // Бизнес данные в виде XML.
                      StatusStr   :string,     // Статус ответа (обязательно для типа 2) (см. Д2).
                      Description :string,     // Текст ошибки если  RequestText = null (только для типа 2) (см. Д2).
                      Code        :integer,    // Код результата (обязательно для типа 2) (см. Д2).
                      Extention           ,    // Extention
                      FromSystemReq:string     // Система, отправившая запрос
)


  return SendMessageToWSEx(QueueID         , // ИД очереди.
                           ReqIDMes        , // ИД сообщения.
                           SenderID        , // Идентификатор Бэк Офиса. (не понятно, как передавать через транспортный конверт, как вариант для типа 1 передавать через вторую секцию param, типа 2 передавать через блок расширений).
                           BranchNumber    , // Подразделение системы-назначения.
                           JMSMessageIDInit, // ИД исходного сообщения, на которое сформирован Ответ.
                           DataType        , // ИД типа данных
                           RequestText     , // Бизнес данные в виде XML.
                           StatusStr       , // Статус ответа (обязательно для типа 2) (см. Д2).
                           Description     , // Текст ошибки если  RequestText = null (только для типа 2) (см. Д2).
                           Code            , // Код результата (обязательно для типа 2) (см. Д2).
                           0               , // Очередь, в которой искать сообщение, можно передать 0 
                           0               , // Тип очереди, в которой искать сообщение, можно передать 0  
                           Extention       , // Extention
                           FromSystemReq     // Система, отправившая запрос
                          );

end;