import FIInter, likepy, oralib;

/**************************************************************/
/* Определение платежа, содержащего общую сумму по            */
/* погашению задолженности по кредиту                         */
/*                                                            */
/* Макрофункции передается счет кредита и назначении платежа  */
/*                                                            */
/* Процедура возвращает:                                      */
/*  - TRUE в случае удачи                                     */                                
/*  - FALSE в случае неудачи                                  */
/**************************************************************/

private var search_words:TArray = makeArray( "КРЕДИТ", "КРЕДИТА", "КРЕДИТУ", "КРЕДИТОМ",
                                             "ССУДА", "ССУДЫ", "ССУДУ", "ССУДОЙ","ССУДЕ", 
                                             "КРЕДИТНЫЙ ДОГОВОР", "КРЕДИТНОГО ДОГОВОРА",
                                             "КРЕДИТНОМУ ДОГОВОРУ", "КРЕДИТНЫМ ДОГОВОРОМ", 
                                             "КРЕДИТНОМ ДОГОВОРЕ" );

private var nosearch_words:TArray = makeArray( "МБК", "МБД", "МЕЖБАНКОВСКИЙ", "МЕЖБАНКОВСКОГО", 
                                               "МЕЖБАНКОВСКОМУ", "МЕЖБАНКОВСКИМ", "МЕЖБАНКОВСКОМ" );

macro DefineDocWithAmountRepayment( ReceiverAccount:string, Ground:string ):bool
  var words:TArray = filter( split( StrUpr(Ground), " " ) );

  var i:integer = 0, j:integer = 0, count:integer = 0;
  var StrWithMasks:string = "441*-457*, 459*, 458*, 47427*, 70101*";
                            
  if( CompareStrWithMasks( StrWithMasks, ReceiverAccount ) == 0 )
     return true;
  else
     if( ReceiverAccount == "" ) // не задан счет кредита
       while( i < search_words.size ) // в назначении платежа присутствует хотя бы одно слово (словосочетание)
         if( find(words, split(search_words[i], " ") ) != -1 )
           while( j < nosearch_words.size ) // в назначении платежа отсутствует любое из слов (абревиатур)
             if( find(words, split(nosearch_words[j], " ") ) != -1 )
               count = count + 1;
             end;
             j = j + 1;
           end;

           if( count == 0 )
             return true;
           else
             return false;
           end;
         end;
         i = i + 1;
       end;
     end;
  end;

  return false;
end;

/* Технические лицевые счета на балансовом 00000 для резервирования средств на счете клиента в разрезе валюты */
private CONST ПутьНастройкиTECH_ACCOUNT = "RS-LOANS\\TECH_ACCOUNT\\";

/* Получить номер технического счета для резервирования средств */
MACRO GetTechAccountLoans(FIID:integer, CreditAccount:string):integer
  
  var err, TypeVal, ISO_Number;

  // Определим буквенный ISO-код валюты 
  ISO_Number = ПолучитьКодФинИн(FIID, err, 0);

  TypeVal = GetRegistryValue( ПутьНастройкиTECH_ACCOUNT + ISO_Number, V_STRING, CreditAccount, err );
  if( ( TypeVal == V_UNDEF ) or ( err != 0 ) or (strlen(CreditAccount) == 0) )
    MsgBox( "Не задан номер технического счета для резервирования средств в валюте "+ISO_Number+".|Значение настройки " + ПутьНастройкиTECH_ACCOUNT + ISO_Number );
    return 1;
  end; 
  SetParm( 1, CreditAccount );

  return 0;
END;
MACRO LnFindType( ReplicationBO:string ):string
  var Query:string = " select ta.T_NAME_TYPE " +
                     " from dtypeac_dbt ta " +
                     " where ta.T_INUMTYPE = :NumType " +
                     "  and ta.T_TYPE_ACCOUNT = :Type ";

  var Params:TArray = makeArray( SQLParam( "NumType", 22     ),
                                 SQLParam( "Type", ReplicationBO ) );

  var rs:RsdRecordset = execSQLselect( Query, Params, true );

  if( rs and rs.MoveNext() )
    return rs.Value(0);
  end;
  return "";
END;
