 /*
 $Name: bnk_common.mac
 $Module: Ядро Банкинг
 $Description: Общие функции для макросов Расчетного Банка
 */

import oralib, likepy, BankInter, PTInter, FIInter; 
// Нежелательно импортировать здесь другие макросы Расч. банка,
// т.к. этот макрофайл сам предназначен для импорта в макросы РБ

// Source - строка, из которой надо взять последние символы
// SymbCount - количество символов
macro GetLastSymbols(Source : string, SymbCount : integer) : string
  var Len : integer = strlen(Source);
  if(Len <= SymbCount)
    return Source;
  end;

  return substr(Source, Len - SymbCount + 1);
end;

// символы до знака "/"
macro GetSymbolsBeforeSlash(s : string) : string
  var ind_slash = Index(s, "/");

  if ( ind_slash != 0 ) 
    return SubStr(s, 1, ind_slash-1); 
  end;

  return s;
end;

// символы после знака "/"
macro GetSymbolsAfterSlash(s : string) : string
  var ind_slash = Index(s, "/");

  if ( ind_slash != 0 ) 
    return SubStr(s, ind_slash+1); 
  end;

  return "";
end;

macro Bnk_GetRegistryValue( RegPath : string, 
                            TypeVal : integer, 
                            DefaultValue : variant
                          ) : variant

  var RegValue : variant = null, err : integer = 0;

  TypeVal = GetRegistryValue( RegPath, TypeVal, RegValue, err );
  if( ( TypeVal == V_UNDEF ) OR ( err != 0 ) )
    return DefaultValue;
  end;

  return RegValue;
end;

macro Bnk_GetLLValuesName(List : integer, CodeOrElement, NotFoundName : string) : string

  if(NotFoundName == null)
    NotFoundName = "";
  end;

  var select : string = "select t_Name " + 
                        "  from dllvalues_dbt " +
                        " where t_List = :List ";

  var params : TArray = makeArray( SQLParam("List", List) );

  if ( valtype(CodeOrElement) == V_INTEGER )

    select = select + "     and t_Element = :Element";       
    params[ params.size ] = SQLParam("Element", CodeOrElement);

  elif ( valtype(CodeOrElement) == V_STRING )

    select = select + "     and t_Code = :Code";
    params[params.size] = SQLParam("Code", CodeOrElement);

  else
    RunError("Неверный тип параметра CodeOrElement макропроцедуры Bnk_GetLLValuesName");
  end;

  var rs : RsdRecordset = execSQLselect( select, params );
  if ( rs and rs.MoveNext() )
    return rs.value("t_Name");
  end;

  return NotFoundName;
end;

macro GetLLClsValName(ClassificatorOrShortName, CodeOrElement) : string
  var select : string = "select llval.t_Name " + 
                        "  from dllvalues_dbt llval, dllclsval_dbt clsval ";
  var where : string =  " where llval.t_List = clsval.t_List " +
                        "   and llval.t_Element = clsval.t_Element ";

  var params : TArray = TArray();

  if ( valtype(ClassificatorOrShortName) == V_INTEGER )

    where = where +    "    and clsval.t_Classificator = :Classificator ";
    params[ params.size ] = SQLParam("Classificator", ClassificatorOrShortName);

  elif ( valtype(ClassificatorOrShortName) == V_STRING )

    select = select + ", dllclass_dbt cls ";
    where = where +    "    and clsval.t_Classificator = cls.t_Classificator " +
                       "    and cls.t_ShortName = :ShortName ";
    params[ params.size ] = SQLParam("ShortName", ClassificatorOrShortName);

  else
    RunError("Неверный тип параметра ClassificatorOrShortName макропроцедуры GetLLClsValName");
  end;

  if ( valtype(CodeOrElement) == V_INTEGER )

    where = where +    "     and llval.t_Element = :Element";       
    params[ params.size ] = SQLParam("Element", CodeOrElement);

  elif ( valtype(CodeOrElement) == V_STRING )

    where = where +    "     and llval.t_Code = :Code";
    params[params.size] = SQLParam("Code", CodeOrElement);

  else
    RunError("Неверный тип параметра CodeOrElement макропроцедуры Bnk_GetLLValuesName");
  end;

  var rs : RsdRecordset = execSQLselect( select + where, params );
  if ( rs and rs.MoveNext() )
    return rs.value("t_Name");
  end;

  return "";
end;

macro GetFIIDByCodeInAccount(CodeInAccount : string) : integer
  var FIID : integer = -1; // ALLFININSTR

  var q : string = "select t_FIID "
                   "  from dfininstr_dbt "
                   " where t_FI_Kind = :FI_Kind "
                   "   and t_CodeInAccount = :CodeInAccount ";

  var params : TArray = makeArray( SQLParam("FI_Kind", FIKIND_CURRENCY),
                                   SQLParam("CodeInAccount", CodeInAccount) );

  var rs : RsdRecordset = execSQLselect(q, params);

  if( rs and rs.moveNext() )
    FIID = rs.value("t_FIID");
  end;

  return FIID;
end;

macro Bnk_GetAccountFIID(Account : string) : integer
  var CodeInAccount : string = substr( Account, 6, 3 );
  return GetFIIDByCodeInAccount(CodeInAccount);
end;

macro Bnk_GetNameAlg(Type : integer, Number : integer) : string
  var query : string = 
    "select t_szNameAlg "
    "  from dnamealg_dbt "
    " where t_iTypeAlg = :TypeAlg "
    "   and t_iNumberAlg = :NumberAlg ";

  var rs : RsdRecordset = execSQLselectPrm( query,
                                            SQLParam("TypeAlg", Type),
                                            SQLParam("NumberAlg", Number) );

  if(rs and rs.moveNext())
    return rs.value(0);
  end;

  return "";
end;

macro GetISO_Number(FIID : integer) : string
  var ISO_Number : string = "";

  var rs : RsdRecordset = execSQLselectPrm
    ( "select t_ISO_Number "
      "  from dfininstr_dbt "
      " where t_FIID = :FIID ",
      SQLParam("FIID", FIID) );

  if(rs and rs.moveNext())
    ISO_Number = rs.value(0);
  end;

  return ISO_Number;
end;

macro GetType_Account(FIID : integer, Account : string, Chapter : integer) : string
  var Type_Account : string = "";

  var rs : RsdRecordset = execSQLselectPrm
    ( "select t_Type_Account "
      "  from daccount_dbt "
      " where t_Code_Currency = :Code_Currency "
      "   and t_Account = :Account "
      "   and t_Chapter = :Chapter ",
      SQLParam( "Code_Currency", FIID ),
      SQLParam( "Account", Account ),
      SQLParam( "Chapter", Chapter ) );

  if(rs and rs.moveNext())
    Type_Account = rs.value(0);
  end;

  return Type_Account;
end;


macro Bnk_WorkWithRetail():bool
  var Work_Retail:bool = false;
  var err:integer = 0;

  GetRegistryValue( "COMMON\\WORK_MODE\\WORK_WITH_RETAIL", V_BOOL, Work_Retail, err );
  if( err != 0 )
    msgbox(" Ошибка чтения настройки COMMON\\WORK_MODE\\WORK_WITH_RETAIL ");
    return false;
  end;

  return Work_Retail;
end;

// Макрос удаления нечисловых символов из строки.
// Параметры: Str - исходная строка, 
// fullClear - флаг полной очистки (true) или очистки только начальных и конечных нечисловых символов (false) 
// Возвращаемое значение - очищенная строка
macro DeleteNotDigitSymbols( Str: string, fullClear: bool ): string
  var i = 1, ch, DigitString = "0123456789";
  var tmpStr = "";
  var oldPos = 0, pos = 0;

  var bPos = 0, ePos = strlen( Str );
  var flag = true;

  if( fullClear == true )
    while( i <= strlen( Str ) )
      ch = SubStr( Str, i, 1 );
      if( not Index( DigitString, ch ))
        pos = i;
        if( pos != oldPos + 1 )
          tmpStr = tmpStr + SubStr( Str, oldPos + 1, pos - oldPos - 1 );
        end;
        oldPos = pos;
      end;
      i = i + 1;
    end;

  else

    while( ( i <= strlen( Str ) ) and flag )
      ch = SubStr( Str, i, 1 );
      if( Index( DigitString, ch ))
        bPos = i;
        flag = false;
      end;
      i = i + 1;
    end;

    flag = true;
    i = strlen( Str );
    while( ( i >= 1 ) and flag )
      ch = SubStr( Str, i, 1 );
      if( Index( DigitString, ch ))
        ePos = i;
        flag = false;
      end;
      i = i - 1;
    end;

    tmpStr = SubStr( Str, bPos, ePos - bPos + 1 );

  end;

  if( StrLen( tmpStr ) )  // если были нечисловые символы tmpStr будет не пуста
    return tmpStr;
  else
    return Str; 
  end;
end;

// Макрос поиска и удаления определенных символов из строки
// Параметры: initialStr - исходная строка, symbolsStr - строка с символами. которые нужно удалить.
// Возвращаемое значение - исходная строка с удаленными символами  
macro DeleteExistingSymbols( initialStr : string, symbolsStr : string ): string
 var tmpStr = "";
 var ch;
 var i = 1, oldPos = 0, pos = 0;
 if( initialStr and symbolsStr )
   while( i <= strlen( initialStr ) )
     ch = SubStr( initialStr, i, 1 );
     if( Index( symbolsStr, ch ))
       pos = i;
       if( pos != oldPos + 1 )
         tmpStr = tmpStr + SubStr( initialStr, oldPos + 1, pos - oldPos - 1 );
       end;
       oldPos = pos;
     end;
     i = i + 1;
   end;
   if( (oldpos == 0) or ((oldpos > 0) and (oldPos <= strlen( initialStr ))) )
     tmpStr = tmpStr + SubStr( initialStr, oldPos + 1 )
   end; 
 end;
 return tmpStr;
end;

// Макрос нормализации строковых значений. Заменяет символы переноса, перевода каретки, табуляции пробелами.
// Удаляются множественные. начальные и конечные пробелы
// Параметры: Str - исходная строка, outStrLen - Количество символов возвращаемой строки.
// Возвращаемое значение - нормализованная строка   
macro StrNormalization( Str: string, outStrLen: integer ): string
  var tmpStr = "";
  var ch, chr;
  var pos = 1, len = 0;
  var restart = false;

  if( Str != "" )

    tmpStr = Str;

    // 1. Замена сиволов переноса, перевода каретки, табуляции на пробел
    tmpStr = StrSubst( tmpStr, "\n", " " );
    tmpStr = StrSubst( tmpStr, "\t", " " );
    tmpStr = StrSubst( tmpStr, "\r", " " );

    // 2. Удаление множественных пробелов
    pos = 1;
    len = strlen( tmpStr );
    while( pos <= len )
      ch = SubStr( tmpStr, pos, 1 );
      if( ch == " " )
        chr = SubStr( tmpStr, pos + 1, 1 );
        if( ( chr == " " ) and ( pos != len ) )
          tmpStr = SubStr( tmpStr, 1, pos ) + SubStr( tmpStr, pos + 2 );
          restart = true;
        end;
      end;
      if( restart == true )
        pos = 1;
        len = strlen( tmpStr );
        restart = false;
      else
        pos = pos + 1;
      end;

    end;

    // 3. Обрезать строку. если указана длина 
    if( outStrLen )
      tmpStr = SubStr( tmpStr, 1, outStrLen );
    end;
       
    // 4. Удаление начальных и конечных пробелов
    tmpStr = Trim( tmpStr );

    return tmpStr;

  else 
    return Str;
  end;
end;

// Макрос подавления ведущих нулей в числах, представленных в виде строковых значений.
// Удаляются нули, находящиеся в начале строки
// Параметры: str - исходная строка.
// Возвращаемое значение - строка без ведущих нулей   
macro FirstZerosDelete( str: string ): string
  var tmpStr = str;
  var chr = "";
  if( tmpStr and (strlen( tmpStr ) > 1) )
    chr = SubStr( tmpStr, 1, 1);
    while( chr == "0" )
      tmpStr = SubStr( tmpStr, 2 );
      chr = SubStr( tmpStr, 1, 1);
    end; 
  end;
  return tmpStr;
end;

// Макрос замены подстроки от конца исходной строки до первого пробела
// Параметры: str - исходная строка, newStr - подстрока, которой необходимо заменить часть исходной.
// Возвращаемое значение - строка с замененной конечной подстрокой   
macro ChangeStrAfterLastSpace( str: string, newStr: string ): string
  var space = " ";
  var len  = 0, pos = 0;
  var ch = "";
  str = Trim( str );
  if( not Index( str, space ) )
    return newStr;
  end;
  len = pos = strlen( str );
  while( ( pos != 1 ) and ( pos <= len ) )
    ch = SubStr( str, pos, 1 );
    if( ch == space )
      return ( SubStr( str, 1, pos ) + newStr );
    end;
    pos = pos - 1;
  end;
end;

macro Bnk_GetTxtFileDir():string
  var txtfiledir : string = "";
  txtfiledir = Bnk_GetRegistryValue( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR", V_STRING, "..\\txtfile" );
  return txtfiledir;
end;

macro Bnk_GetImageID( ObjectType : integer, ObjectStrID : string, ImageType : integer )
  var ImageID = 0;

  var query : string = " SELECT t_ImageID " +
                       " FROM dimgdata_dbt " +
                       " WHERE t_ObjectType = :ObjectType " +
                       "   AND t_ObjectID   = :ObjectStrID " +
                       "   AND t_ImageType  = :ImageType " +
                       "   AND t_CloseDate  = :CloseDate " +
                       " ORDER BY t_ImageID DESC";

  var rs : RsdRecordset = execSQLselectPrm( query,
                                            SQLParam( "ObjectType",  ObjectType ),
                                            SQLParam( "ObjectStrID", ObjectStrID ),
                                            SQLParam( "ImageType",   ImageType ),
                                            SQLParam( "CloseDate",   date(0,0,0) ) );

  if( rs and rs.moveNext() )
    ImageID = rs.value( "t_ImageID" );
  end;

  return ImageID;
end;

macro Bnk_GetCorschemDepartment( Number : integer, FIID : integer ):integer
  var Department : integer = -1;

  var query : string = " SELECT t_Department " +
                       " FROM dcorschem_dbt " +
                       " WHERE t_Number = :Num " +
                       "   AND t_FIID   = :FIID ";

  var rs : RsdRecordset = execSQLselectPrm( query,
                                            SQLParam( "Num",  Number ),
                                            SQLParam( "FIID", FIID ) );

  if( rs and rs.moveNext() )
    Department = rs.value( "t_Department" );
  end;

  return Department;
end;

macro Bnk_GetCorschemCorAccount( Number : integer, FIID : integer ):string
  var CorAccount : string = "";

  var query : string = " SELECT t_CorAccount " +
                       " FROM dcorschem_dbt " +
                       " WHERE t_Number = :Num " +
                       "   AND t_FIID   = :FIID ";

  var rs : RsdRecordset = execSQLselectPrm( query,
                                            SQLParam( "Num",  Number ),
                                            SQLParam( "FIID", FIID ) );

  if( rs and rs.moveNext() )
    CorAccount = rs.value( "t_CorAccount" );
  end;

  return CorAccount;
end;

// Функция перенесена из giszhkhproc.mac и переименована, так как будет использоваться в других макросах
// Подготовить строку с перечислением узлов ТС к формату, который будет использоваться в запросе
macro ConvertInCondToSQLFormat( source )
  
  // Разбиваем строку по разделителю ","
  var parts = split( source, "," );
  
  // Для каждого элемента обрезаем пробелы и обрамляем в sql-ные кавычки
  var i = 0;
  while( i < parts.size )
    parts[i] = "'" + Trim( parts[i] ) + "'";
    i = i + 1;
  end;
  
  // Собираем элементы массива в одну строку с разделителем ","
  return join( parts, "," );
end;
