/*
  $Name:         mfrcarry.mac
  $Module:       РКО
  $Description:  Выполнение единичной проводки по счетам МФР
*/
//-----------------------------------------------------------------------------
// Блок      : 29001 - "Межфилиальные расчеты ЦАБС"
// Шаг       : 10    - "Перевод по счетам МФР ЦАБС"
// Назначение: Различные функции
// Описание  : Выполнение единичной проводки по счетам МФР
//-----------------------------------------------------------------------------
import globals, InsCarryDoc, CTInter, PaymInter, FIInter, oralib, likepy, pm_common, pm_setst;
import "mfr_acc.mac", "pm_tools.mac", "pm_opr.mac", "pmcarry1.mac";
import pmsummo;
import "pmbencom.mac";

//-----------------------------------------------------------------------------
// Получить название филиала
//-----------------------------------------------------------------------------
PRIVATE MACRO GetDepartmentName(Department:integer):string
  var rset:object;
  var select:string;
  var params:TArray = TArray();

  select = " SELECT T_NAME FROM DDP_DEP_DBT WHERE T_CODE = :Department ";

  params[params.size] = SQLParam( "Department", Department );
  rset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    return rset.value(0);
  end;

  return "";
END;

//-----------------------------------------------------------------------------
// Получить проводку
//-----------------------------------------------------------------------------
PRIVATE MACRO getCarry( AccTrnID:integer ):TBFile
    
  var fdocument = TBFile("acctrn.dbt",   "R", 5, "acctrn.dbt",   "bank.def");
  if( fdocument and AccTrnID )
    fdocument.rec.AccTrnID = AccTrnID;
    if( fdocument.GetEQ() and ( fdocument.rec.Result_Carry != 83 ) )
      return fdocument;
    end;
  end;

  return NULL;
END;

//-----------------------------------------------------------------------------
// Удалить проводку по помещению на счет незавершенных расчетов
//-----------------------------------------------------------------------------
PRIVATE MACRO DeleteAccUnclosedCarry( Payment:RsbPayment, id_operation, id_step ):integer
  
  var carrydocument:TBFile;                
 
  // найти привязку проводки к найденному шагу
  var select:string = "select oprdocs.t_AccTrnID " +
                       " from doprdocs_dbt oprdocs " +
                      " where oprdocs.t_DocKind = :DocKind " + 
                        " and oprdocs.t_ID_Operation = :ID_Operation " +
                        " and oprdocs.t_ID_Step = :ID_Step; "; 
      
  var params:TArray = makeArray( SQLParam( "DocKind"     , DLDOC_CARRY  ),
                                 SQLParam( "ID_Operation", id_operation ),
                                 SQLParam( "ID_Step"     , id_step      ) );
      
  var rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )

    carrydocument = getCarry( rset.value(0) );
    
    if( carrydocument )
      Payment.FuturePayerAccount = carrydocument.rec.Account_Payer;
      // удалить проводку по помещению на счет незавершенных расчетов
      if( not Opr_DeleteCarry( carrydocument.rec.AccTrnID ) )
        MsgBox("Ошибка при удалении проводки");
        return 1;
      end;
    end;

  end;
  
  return 0;
END;

//-----------------------------------------------------------------------------
// Удаление проводки по счетам межфилиальных расчетов
//-----------------------------------------------------------------------------
PRIVATE MACRO DeleteMfrCarry( Payment:RsbPayment, HistoryID:integer ):integer

  file pmdphist( "pmdphist.dbt", "bank.def") key 0;

  var selectC:string = "";
  var paramsC:TArray = TArray();
  var rsetC:RsdRecordset;

  // найдем запись маршрута платежа внутри ЦАБС
  pmdphist.HistoryID = HistoryID;
  pmdphist.PaymentID = Payment.PaymentID;
  if( not GetEQ(pmdphist) )
    MsgBox("Не найдена запись маршрута платежа внутри ЦАБС");
    return 1;
  end;

  // найти шаг операции (ID_Operation, ID_Step), 
  // к которому привязана вставка записи pmdphist.dbt 
  var select:string = "select oprdocs.t_ID_Operation, oprdocs.t_ID_Step " +
                       " from doprdocs_dbt oprdocs " +
                      " where oprdocs.t_DocKind = :DocKind " + 
                        " and oprdocs.t_DocumentID = :DocumentID "; 
  
  var params:TArray = makeArray( SQLParam( "DocKind"   , DLDOC_PMDPHIST ),
                                 SQLParam( "DocumentID", UniID(pmdphist, 0, DLDOC_PMDPHIST) ) );
  
  var rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )

    // найти привязки проводок к найденному шагу
    paramsC = TArray();
    selectC = "select oprdocs.t_AccTrnID " +
               " from doprdocs_dbt oprdocs " +
              " where oprdocs.t_DocKind = :DocKind " + 
                " and oprdocs.t_ID_Operation = :ID_Operation " +
                " and oprdocs.t_ID_Step = :ID_Step; "; 
          
    paramsC = makeArray( SQLParam( "DocKind"     , DLDOC_CARRY   ),
                         SQLParam( "ID_Operation", rset.value(0) ),
                         SQLParam( "DocumentID"  , rset.value(1) ) );
    
    rsetC = execSQLselect( selectC, paramsC, TRUE );
    while( rsetC and rsetC.moveNext() )
      // удалить проводку с возможностью отката 
      if( not Opr_DeleteCarry( rset.value(0) ) )
        MsgBox("Ошибка при удалении проводки");
        return 1;
      end;
    end;
  
  end;

  return 0;
END;

private macro GetOutCorAccount( PaymentID:integer ):string

  var CorAcc = "";
  var select:string = " select cor.t_account " +
                      "   from dcorschem_dbt cor, " +
                      "        dpmprop_dbt   prop " +
                      "  where prop.t_PaymentID = :PaymentID "
                      "    and cor.t_number = prop.t_corschem " +
                      "    and cor.T_FIID = prop.t_payfiid" +
                      "    and prop.t_debetcredit = 0 " +
                      "    and prop.t_Group = 1 ";/*PAYMENTS_GROUP_EXTERNAL*/

  var params:TArray = makeArray( SQLParam( "PaymentID", PaymentID  ) );
  var rset:RsdRecordset = execSQLselect( select, params, TRUE ); 
  if( rset and rset.moveNext() )
    CorAcc = rset.value(0);
  end;
  return CorAcc;
end;

private macro FindCommonODBalance(Dep1: integer, Dep2: integer, FromDate: date): date
  var ODBalance = date(0, 0, 0);

  var query = "select t1.t_Curdate " +
              "  from dcurdate_dbt t1, dcurdate_dbt t2 " +
              " where t1.t_Branch = :Dep1 " +
              "   and t2.t_Branch = :Dep2 " +
              "   and t1.t_Curdate >= :FromDate " +
              "   and t1.t_IsBalance = 'X' " +
              "   and t2.t_Curdate = t1.t_Curdate " +
              "order by t1.t_Curdate asc ";
  var params = makeArray( SQLParam("Dep1", Dep1),
                          SQLParam("Dep2", Dep2),
                          SQLParam("FromDate", FromDate) );
  var rs = execSQLselect(query, params);
  if( rs )
    var ODBalance1 = date(0, 0, 0), ODBalance2 = date(0, 0, 0);
    while( rs.moveNext )
      ODBalance1 =  PM_GetOperDay_Balance(Dep1, date(rs.value("t_Curdate")));
      ODBalance2 =  PM_GetOperDay_Balance(Dep2, date(rs.value("t_Curdate")));
      if( ODBalance1 == ODBalance2 )
        ODBalance = ODBalance1;
        break;
      end;
    end;
  end;

  return ODBalance;
end;

//-----------------------------------------------------------------------------
// Единичная проводка по счетам межфилиальных расчетов
//-----------------------------------------------------------------------------
MACRO MakeCarry( PaymentID:integer, InvHistoryID:integer, InvDirection:integer ):integer

  var payment:RsbPayment = RsbPayment( PaymentID );
  var Department:integer = payment.Department;
  var NextDep:integer    = MFR_GetNextDepartment( Department, payment.EndDepartment );
  var NextDepCode = "", NextDepName = "";
  CB_GetDepartmentCodeAndName(NextDep, NextDepCode, NextDepName);    
  var paymtr:RsbPaymTransaction = NULL;
  var id_operation:integer = 0, id_step:integer = 0;
  var fact_date:date = date(0,0,0);
  var IsCreditAddPI:bool = IfThenElse( ( payment.PIList(1).Size > 0 ), true, false );
  var IsAddedPI:bool = IfThenElse( ( payment.PIList(0).Size > 0 ) or ( payment.PIList(1).Size > 0 ), true, false );
  var stat:integer = 0;
  var FuturePayerAccount:string;
  file dp_dep("dp_dep.dbt");
  file party("party.dbt");
  var str, depName = "", partyName = "";
  record _wlreq( "wlreq.dbt" );
  record Corschem( corschem );
  record wlconf( wlconf );
  Array Text;
  Array Buttons;
  var IsKlient:integer;
  var query:string, param:TArray, rs:RsdRecordset;
  var IfNext         :integer = 0;


  if( NextDep == Department ) /* Проводку делать не надо */
    return 0;
  end;

    // Проверить, что дата pmpaym.ValueDate открыта в филиале NextDepartment
  var select:string = " select t_IsClosed " +
                        " from dcurdate_dbt " +
                       " where t_Branch = :NextDepartment " +
                         " and t_CurDate = :ValueDate " +
                         " and t_IsBalance = 'X' " +
                         " and t_IsClosed = chr(0) ";

  var params:TArray = makeArray( SQLParam( "NextDepartment", NextDep           ),
                                 SQLParam( "ValueDate"     , payment.ValueDate ) );
  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  // Если день отсутствует или закрыт
  if( not rset or not rset.moveNext() )
    if( not PM_PrevStepIsAccUnclosed(Payment, @id_operation, @id_step, @fact_date)  ) // Платеж не помещался на СНР
      MsgBox("В филиале  " + NextDepCode + " " + NextDepName + 
             " отсутствует операционный день, совпадающий с датой значения платежа. " +
             "Проводка в следующем филиале датой " + payment.ValueDate + " невозможна");
      return 1;
    else
      var ODBalance = FindCommonODBalance(payment.Department, NextDep, payment.ValueDate);
      if( ODBalance == date(0, 0, 0) )
        MsgBox("В филиале "  + NextDepCode + " " + NextDepName + 
               " отсутствует операционный день, в котором возможно выполнение проводки"); 
        return 1;
      end;
      payment.ValueDate = ODBalance;
      if( ПлатежИсходящий(payment) )
        PM_CorrectOutTransferDate( payment );
      end;
    end;
  end;

  if( payment.StartDepartment != payment.EndDepartment )
    if( IsExistCallBackRSL( payment.PaymentID, 60/*WLD_STATUS_REQ_RECEIV*/, ID_Operation, ID_Step ) )
      return 1;
    end;
/* 
    IsExistCallBack( payment.PaymentID, 60/*WLD_STATUS_REQ_RECEIV*/, _wlreq) )

    query = " select dp.t_Name, pt.t_Name from ddp_dep_dbt dp, dparty_dbt pt where dp.t_PartyID = ? and pt.t_PartyID = dp.t_PartyID " ;
    param = makeArray( SQLParam( "", _wlreq.OriginatorID ));
    rs = execSQLselect( query, param, TRUE );
    rs.moveNext();

    str = string("Есть необработанный запрос из филиала ", rs.value(0), " ", rs.value(1), " на отзыв документа.");
    if(not IsOprMultiExec())
      Text(0) = string( str,"|Провести?");
      Buttons(0) = " Отложить "; 
      Buttons(1) = " Провести "; 

      if( ConfWin(Text,Buttons) )
        if(PlaceReqToClose(_wlreq.ReqID, ID_Operation, ID_Step))
          msgbox( "Ошибка при помещении отзыва в обработанные" );
          return 1;
        end;
      else
        return 1;   
      end;
    else
      msgbox(str);
      return 1;  
    end;
*/
  end;

  // Инициатор платежа
  var arr = makeArray( SQLParam( "p_PaymentID", payment.PaymentID) );
  var retval:integer = 0;

  if ( payment.Categories.IsAttrPresense(OBJ_PAYMENT_GROUP_INITIATOR_PYMENT, 1, NULL, NULL, false, {curdate} ) )
    IsKlient = 1;
  elif ( payment.Categories.IsAttrPresense(OBJ_PAYMENT_GROUP_INITIATOR_PYMENT, 2, NULL, NULL, false, {curdate} ) )
    IsKlient = 0;
  else
    retval = execStoredFunc( "PM_COMMON.GetOperInitiatorCtg", V_INTEGER, arr );
    if( retval )  
      payment.Categories.ConnectAttr(16, retval, NULL, NULL, {curdate} );
      if(retval == 1)
        IsKlient = 1;
      end;
      if( retval == 2)
        IsKlient = 0;
      end;
    end;
  end;

  if( InvDirection == PAYMENTS_DIRECT_REVERSE ) // тогда прямое направление
    paymtr = payment.MakeTransaction();
    if( paymtr == NULL )
      MsgBox("Ошибка при создании проводки по платежу");
      return 1;
    end;

    /* Все те общие значения, которые можно выделить для разных проводок */
    paymtr.Chapter       = 1;                                            
    paymtr.Date_Carry    = payment.ValueDate;
    paymtr.Number_Pack   = payment.NumberPack;
    paymtr.Numb_Document = payment.Number;
    paymtr.ResultCarry   = 1;
    paymtr.Kind_Oper     = " 1";

    if(payment.ShifrOper != "")
      paymtr.Shifr_Oper  = payment.ShifrOper;
    else
      paymtr.Shifr_Oper    = "09";
    end;
    
    paymtr.Ground        = "Проводка по счетам МФР внутри ЦАБС";
    paymtr.Department    = Department;
  
    paymtr.Status_After  = GetPaymentCarryKind( payment );

    if( ( payment.CoverAmount != $0 ) and
        ( payment.PIList(PRT_Debet ).Size == 0 ) and 
        ( payment.PIList(PRT_Credit).Size == 0 ) ) 
      paymtr.SumEquivalentCarry = payment.CoverAmount;
    end;

    if( not payment.IsCredit() )

      if( (payment.StartDepartment == payment.Department) AND
          (payment.BaseFIID != payment.ReceiverFIID ) )

        /* Проводка мультивалютная */
        paymtr.FIIDPayer       = payment.BaseFIID;
        paymtr.FIIDReceiver    = payment.FutureReceiverFIID;
        paymtr.SumPayer        = payment.FutureBaseAmount;
        paymtr.SumReceiver     = payment.FutureReceiverAmount;
        paymtr.AccountPayer    = MFR_GetAccountActive( Department, NextDep, payment.BaseFIID, IsKlient );
        paymtr.AccountReceiver = payment.FutureReceiverAccount;
      else
        paymtr.FIIDPayer       = payment.FutureReceiverFIID;
        paymtr.FIIDReceiver    = payment.FutureReceiverFIID;
        paymtr.SumPayer        = payment.FutureReceiverAmount;
        paymtr.SumReceiver     = payment.FutureReceiverAmount;
        paymtr.AccountPayer    = MFR_GetAccountActive( Department, NextDep, payment.FutureReceiverFIID, IsKlient );
        paymtr.AccountReceiver = payment.FutureReceiverAccount;
      end;

    else
      if( (payment.StartDepartment == payment.Department) AND
          (payment.PIList(PRT_Debet).Size > 0) )
        if( payment.MakeMultyTransaction(NULL, MFR_GetAccountPassive( Department, NextDep, payment.BaseFIID ), payment.BaseFIID))
          MsgBox("Ошибка в мультипроводке");
          return 1;
        end;
        return 0;
      elif( (payment.StartDepartment == payment.Department) AND
          (payment.BaseFIID != payment.PayerFIID ) )
        /* Проводка мультивалютная */
        paymtr.FIIDPayer       = payment.FuturePayerFIID;
        paymtr.FIIDReceiver    = payment.BaseFIID;
        paymtr.SumPayer        = payment.FuturePayerAmount;
        if( payment.FutureBaseAmount != 0 )
          paymtr.SumReceiver   = payment.FutureBaseAmount;
        else
          paymtr.SumReceiver   = payment.BaseAmount;
        end;
        paymtr.SumReceiver     = payment.BaseAmount;
        paymtr.AccountPayer    = payment.FuturePayerAccount;
        paymtr.AccountReceiver = MFR_GetAccountPassive( Department, NextDep, payment.BaseFIID, IsKlient );
      else
        /* Проводка в одной валюте */
        paymtr.FIIDPayer       = payment.FuturePayerFIID;
        paymtr.FIIDReceiver    = payment.FuturePayerFIID;
        paymtr.SumPayer        = payment.FuturePayerAmount;
        paymtr.SumReceiver     = payment.FuturePayerAmount;
        paymtr.AccountPayer    = payment.FuturePayerAccount;
        paymtr.AccountReceiver = MFR_GetAccountPassive( Department, NextDep, payment.FuturePayerFIID, IsKlient );
      end;

    end;
    paymtr.ClaimID  = GetClaimID( payment, paymtr.AccountPayer, paymtr.Chapter, paymtr.FIIDPayer );

    // Заполняем дату списания со счета плательщика датой проводки
    if( (paymtr.AccountPayer == payment.PayerAccount) and
        (paymtr.FIIDPayer    == payment.PayerFIID   )  ) 
       payment.PayerChargeOffDate = paymtr.Date_Carry; 
    end;

    if( (paymtr.AccountReceiver == payment.FutureReceiverAccount) and (paymtr.FIIDReceiver == payment.FutureReceiverFIID)
        or (IsExistAddPiInCurDep(payment, PRT_Credit) and (payment.Department == payment.StartDepartment)))
      payment.ReceiverChargeOffDate = paymtr.Date_Carry;
    end;

    FuturePayerAccount = payment.FuturePayerAccount;

    if((payment.PIList(0).Size == 0) and (payment.PIList(1).Size == 0) )
      if(not CopyInCarryAllCashSymbol(paymtr, payment ))
          msgbox("Ошибка при копировании кассовых символов из платежа в проводку.");
          return 1;
        end;

      if( not RmCopyInCarryCashSymbol( payment, paymtr) )
          msgbox("Ошибка при копировании кассовых символов из платежа в проводку.");
          return 1;
        end;
      end;
      
    if( not paymtr.Carry )
      MsgBox("Ошибка при актуализации платежа");
        return 1;
      end;

    // если проводка была проведенная, освобождаем резерв
    if( paymtr.Status_After == ACCTRN_STATUS_DOCUMENT )
      payment.FreeReserve( payment.PayerAccount, CHAPT1, payment.PayerFIID );
    end;

    if( payment.Department == payment.StartDepartment )
      if( InsertPmsend(payment.PaymentID, WLD_ACTION_PMSEND_EXEC) != 0 )
        msgbox("Ошибка при вставке записи об отправке платежа во внешнюю систему");
        return 1;
      end;
    end;

    /*Формирование подтверждения дебета или кредита по корсчету аналогично шагу "Зачисление". PRJ_000411_Межфилиальные_расчеты_в_рамках_ЦАБС#25*/
    
    var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );

    if( not IsAddedPI )  

      //Создание подтверждения по проводке для дебета
      ClearRecord( wlconf );
      FillConfirmationParamByCarry( wlconf, payment, paymtr, 1 );
      
      if( not GetCorsByConf( wlconf, Corschem ) )
        if( (Corschem.State == 0) and (Corschem.CreateConfirmation == SET_CHAR) )
          if( CreateConfirmation( wlconf ) == FALSE )
            msgbox("Ошибка при создании подтверждения дебета по проводке");
            return 1;
          end;
        end;
      end;
               
      //Создание подтверждения по проводке для кредита
      ClearRecord( wlconf );
      FillConfirmationParamByCarry( wlconf, payment, paymtr, 2 );
      if( not GetCorsByConf( wlconf, Corschem ) )
        if( (Corschem.State == 0) and (Corschem.CreateConfirmation == SET_CHAR) )
          if( CreateConfirmation( wlconf ) == FALSE )
             msgbox("Ошибка при создании подтверждения кредита по проводке");
             return 1;
          end;
        end;
      end;

    else //  if( not IsAddedPI )  

      //Создаём подтверждения по уточняющим записям
      if( payment.PIList( PRT_Debet ).Size > 0 )
        FillConfirmationParamByCarry( wlconf, payment, paymtr, 1 );
        IfNext = payment.PIList( PRT_Debet ).First();
        while( (IfNext==0) and (payment.PIList( PRT_Debet ).Current( pi ) == 0) )
          wlconf.Account = pi.rec.Account;
          wlconf.FIID    = pi.rec.FIID;
          wlconf.Sum     = pi.rec.Amount; 
          if( not GetCorsByConf( wlconf, Corschem ) )
            if( (Corschem.State == 0) and (Corschem.CreateConfirmation == SET_CHAR) )
              if( CreateConfirmation( wlconf ) == FALSE )
                msgbox("Ошибка при создании подтверждения по уточняющей записи дебета");
                return 1;
              end;
            end;
          end;      
          IfNext = payment.PIList( PRT_Debet ).Next();
        end;
      end;

      //Создаём подтверждения по уточняющим записям
      if( payment.PIList( PRT_Credit ).Size > 0 )
        FillConfirmationParamByCarry(wlconf, payment, paymtr, 2);
        IfNext = payment.PIList( PRT_Credit ).First();
        while( (IfNext==0) and (payment.PIList( PRT_Credit ).Current( pi ) == 0) )
          wlconf.Account = pi.rec.Account;
          wlconf.FIID    = pi.rec.FIID;
          wlconf.Sum     = pi.rec.Amount; 
          if( not GetCorsByConf( wlconf, Corschem ) )
            if( (Corschem.State == 0) and (Corschem.CreateConfirmation == SET_CHAR) )
              if( CreateConfirmation( wlconf ) == FALSE )
                 msgbox("Ошибка при создании подтверждения по уточняющей записи кредита");
                 return 1;
              end;
            end;                                   
          end;
          IfNext = payment.PIList( PRT_Credit ).Next();
        end;
      end;
    
    end; //  if( not IsAddedPI )

    if( (payment.ComissCharges == PM_CHRG_BEN) and (PayBenFromCorr == true) )
      if( not IsCreditAddPI )
        stat = PayCommisBEN( payment, paymtr.AccountReceiver, paymtr.FIIDReceiver );
      else
        msgbox("Не определен плательщик комиссии");
        return 1;
      end;

      if( stat )
        return stat;
      end;
    end;

  else // удалить проводку по счетам МФР

    if( DeleteMfrCarry( payment, InvDirection ) )
      return 1;
    end;

  end;  

  return 0;

END;
