import XmlRpcInter, rcw;

private const DEFAULT_XML2RSL_XSLT = "xml_to_xml_rpc_response.xsl";
private var jvm = createObject( "rsjvm", "TJavaHost" );

///////////////////////////////////////////////////
CLASS LastResultInfo
   var finalResult:INTEGER;
   var outMessage:STRING;
END;

///////////////////////////////////////////////////
MACRO getLastResult(reqId:STRING)
   var finRes, mes;

   var result = GetLastResultById(reqId, finRes, mes);

   var res = LastResultInfo();

   res.finalResult = finRes;
   res.outMessage = "<![CDATA[ " + mes + " ]]>";

   return res;
   
END;

///////////////////////////////////////////////////
private macro CreateXMLObject(xml:object, name:string)
  SetParm(0, ActiveX(name, null, true));
  return true;

onError
  return false;
end;

private macro CreateXMLSchemaCollection(dtd:object, name:string)
  SetParm(0, ActiveX(name, null, true));
  return true;

onError
  return false;
end;


///////////////////////////////////////////////////
private macro CreateXML2Object(xml:object)
  SetParm(0, ActiveX("Msxml2.DOMDocument", null, true));
  return true;

onError
  return false;
end;

///////////////////////////////////////////////////
private macro CreateXML1Object(xml:object)
  SetParm(0, ActiveX("MSXML.DOMDocument"));
  return true;

onError
  return false;
end;

///////////////////////////////////////////////////
// создать объект MSXML для валидации
///////////////////////////////////////////////////
macro CreateXMLParserValidate()
  var obj:object = NULL;

  if (CreateXMLObject(obj, "Msxml2.DOMDocument.6.0"))
    return obj;
  end;
  if (CreateXMLObject(obj, "Msxml2.DOMDocument.4.0"))
    return obj;
  end;

  return null;
end;

///////////////////////////////////////////////////
// создать объект MSXML
///////////////////////////////////////////////////
macro CreateXMLParser()
  var obj:object = NULL;

  if (CreateXML2Object(obj))
    return obj;
  end;      
  if (CreateXML1Object(obj))
    return obj;
  end;

  return null;
end;

///////////////////////////////////////////////////
// создать XSD схему
///////////////////////////////////////////////////
macro CreateSchemaCollection()
  var dtd:object = NULL;

  if (CreateXMLObject(dtd, "Msxml2.XMLSchemaCache.6.0"))
    return dtd;
  end;
  if (CreateXMLObject(dtd, "Msxml2.XMLSchemaCache.4.0"))
    return dtd;
  end;
  
  return null;
end;


///////////////////////////////////////////////////
// применить XSLT преобразование к строке
///////////////////////////////////////////////////
macro ApplyXSLT(XMLtext, XSLTfileName)

var tr = jvm.CreateJavaObject( "ru.softlab.rsbank.tools.xslt.RsbXsltTransformer");
var result = tr.transform(XSLTfileName, XMLtext);
return result;

 /* var xml = CreateXMLParser();
  xml.validateOnParse = true;
  xml.async = false;

  xml.loadXML(XMLtext);

  var xslt = CreateXMLParser();
  xslt.validateOnParse = true;
  xslt.async = false;

  xslt.load(XSLTfileName);

  return xml.transformNode(xslt);*/
end;

////////////////////////////////////////////////////////
// создать объект RSL по XML-строке в формате RsXmlRpc
////////////////////////////////////////////////////////
macro ConvertToRSL(XMLtext, xrMessage, reqId, convertToANSI)

  if (ValType(convertToANSI) == V_UNDEF)
     convertToANSI = true;
  end;
 
  var logRec = TXRLogRecord();

  if (convertToANSI)
     logRec.messageText = ToANSI(XMLtext, true);
  else
     logRec.messageText = XMLtext;
  end;

  xrMessage = logRec.getMessageObject();
  reqId = logRec.reqId;

  SetParm(1, xrMessage);
  SetParm(2, reqId);
  return 0;

onError(ex)
  return ex.code;
end;

///////////////////////////////////////////////////
// Базовый класс для формирования XmlRpc сообщения 
///////////////////////////////////////////////////
CLASS TXRBaseMessage
   var messageKind:INTEGER;
   var reqId:STRING;
   var logicalId:STRING;
   var source:STRING;
   var destination:STRING;
   var direction:INTEGER;

   // проверка на соответствие XSD-схеме
   MACRO validate(xml:STRING)

      var result:STRING;

      // создаем xsd-схему
      var xsd = CreateXMLParserValidate();
      xsd.load("RsXmlRpc.xsd");

      var cache = CreateSchemaCollection();
      cache.add("http://www.softlab.ru/xml-rpc/schema", xsd);

      var parser = CreateXMLParserValidate();
      parser.async="false";
      parser.schemas = cache;

      var bres = parser.loadXML(xml);

      if (not bres)
         result = parser.parseError.reason;
      end;
      
      return result;
      
   END;

   MACRO GetParams(val)
      var res_xml;
      var res_values = TArray();
      var parm;
      var i = 0;

      var stat = ConvertToXML(val, reqId, res_xml);

      // создаем MS-парсер
      var parser = CreateXMLParser();
      parser.async="false";
      var xml = parser.loadXML(res_xml);

      var parmList = parser.getElementsByTagName("params");

      return parmList;

   END;

   macro GetParam(val)
      var res_xml;
      var res_values = TArray();
      var parm;
      var i = 0;

      var stat = ConvertToXML(val, reqId, res_xml);

      // создаем MS-парсер
      var parser = CreateXMLParser();
      parser.async="false";
      var xml = parser.loadXML(res_xml);

      var parmList = parser.getElementsByTagName("param");

      return parmList;
   end;

   MACRO GenerateMessage(UseCDATA:BOOL):STRING
      RunError("Метод не реализован!");
   END;
END;

////////////////////////////////////////////////////////////
// Класс для формирования XmlRpc сообщения типа "Запрос"
////////////////////////////////////////////////////////////
CLASS (TXRBaseMessage)TXRRequest
   messageKind = 1;

   var macroName:STRING;
   var macroFunc:STRING;
   var params;

   var Parm;
   var Parms; /*массив параметров*/
   var requestTemplate = 
"<?xml version='1.0'?> " +
"<methodCall xmlns=\"http://www.softlab.ru/xml-rpc/schema\" " +
"            xmlns:r=\"http://www.softlab.ru/xml-rpc/schema\" " +
"            r:reqId=\"\" " +
"            r:logicalId=\"\" " +
"            r:source=\"\" " +
"            r:destination=\"\" " +
"            r:direction=\"0\"> " +
"  <methodName></methodName> " +
//"   <params> " +
//"   </params> " +
"</methodCall>";

   MACRO GetMethodName():STRING
      return "RunMacro." + macroName + "." + macroFunc;
   END;

   MACRO GenerateMessage(UseCDATA:BOOL):STRING
      var result = "";
      var paramList;
      var parmj;
      var p;
      var i = 0;
      var j = 0;
      var params;
   
      var parser = CreateXMLParser();
      parser.async="false";
      var xml = parser.loadXML(requestTemplate);

      // кладем атрибуты methodCall
      var methodCall = parser.selectSingleNode("methodCall");

      methodCall.setAttribute("r:reqId", reqId);
      methodCall.setAttribute("r:logicalId", logicalId);
      methodCall.setAttribute("r:source", source);
      methodCall.setAttribute("r:destination", destination);
      methodCall.setAttribute("r:direction", direction);

      // кладем мethodName
      var methodName = methodCall.selectSingleNode("methodName");
      methodName.text = GetMethodName();

      if((ValType(Parms) != V_UNDEF) and (Parms.size > 0))
         
         j = 0;
         while (j < Parms.size)
            parmj = Parms[j];
            if (j == 0) /*первый параметр <param> добавляем вместе с узлом <params>*/
              paramList = GetParams(parmj);
              if(paramList.length > 0)
                 p = paramList.item(0);
                 methodCall.AppendChild(p);
                 params = methodCall.selectSingleNode("params"); /*запоминаем узел <params>*/
              end;
            else
              paramList = GetParam(parmj);
              if(paramList.length > 0)
                 p = paramList.item(0);
                 params.AppendChild(p); /*остальные параметры <param> добавляем в узел <params>*/
              end;
            end;

            j = j + 1;
         end;

      elif (ValType(Parm) != V_UNDEF)
         paramList = GetParams(Parm);
         i = 0;
         while (i < paramList.length)
            p = paramList.item(i);
            methodCall.AppendChild(p);
            i = i + 1;
         end;

      end;

      result = parser.xml;

      var err = validate(result);
      if (StrLen(err) > 0)
         RunError(err);
      end; 

      if (UseCDATA)
         result = "<![CDATA[" + result + "]]>";
      end;

      return result;
   END;
END;


////////////////////////////////////////////////////////////
// Класс для формирования XmlRpc сообщения типа "Ответ"
////////////////////////////////////////////////////////////
CLASS (TXRBaseMessage)TXRResponse
   messageKind = 3;

   var Parm;

  MACRO GenerateMessage(UseCDATA:BOOL):STRING
      var res_xml;
      var i = 0;
      var result;

      var stat = ConvertToXML(Parm, reqId, res_xml);

      // создаем MS-парсер
      var parser = CreateXMLParser();
      parser.async="false";
      var xml = parser.loadXML(res_xml);

      var methodResponse = parser.selectSingleNode("methodResponse");
      methodResponse.setAttribute("n0:reqId", reqId);
      methodResponse.setAttribute("n0:logicalId", logicalId);

      result = parser.xml;

      var err = validate(result);
      if (StrLen(err) > 0)
         RunError(err);
      end; 

      if (UseCDATA)
         result = "<![CDATA[" + result + "]]>";
      end;

      return result;

   END;
END;

/////////////////////////////////////////////////////////////////////////////////
// Класс-параметр для формирования XmlRpc сообщения типа "Сообщение об ошибке"
/////////////////////////////////////////////////////////////////////////////////
CLASS TXRErrorParm
   var faultType:INTEGER;
   var faultCode:INTEGER;
   var faultString:STRING;
END;

/////////////////////////////////////////////////////////////////////////////////
// Класс для формирования XmlRpc сообщения типа "Сообщение об ошибке"
/////////////////////////////////////////////////////////////////////////////////
CLASS (TXRBaseMessage)TXRError
  messageKind = 3;
  var Parm = TXRErrorParm();
   
  MACRO GenerateMessage(UseCDATA:BOOL):STRING
      var res_xml;
      var i = 0;
      var result;

      result = 
"<?xml version=\"1.0\" ?> " + "\n" +
" <methodResponse xmlns=\"http://www.softlab.ru/xml-rpc/schema\" xmlns:n0=\"http://www.softlab.ru/xml-rpc/schema\" n0:reqId=\"" + reqId + "\"> " + "\n" +
"  <fault>" + "\n" +
"   <value>" + "\n" +
"    <struct>" + "\n" +
"     <member>" + "\n" +
"      <name>faultType</name> " + "\n" +
"      <value>" + "\n" +
"       <integer>" + string(Parm.faultType) + "</integer> " + "\n" +
"      </value>" + "\n" +
"     </member>" + "\n" +
"     <member>" + "\n" +
"      <name>faultCode</name> " + "\n" +
"      <value>" + "\n" +
"       <integer>" + string(Parm.faultCode) + "</integer> " + "\n" +
"      </value>" + "\n" +
"     </member>" + "\n" +
"     <member>" + "\n" +
"      <name>faultString</name>" + "\n" +
"      <value>" + "\n" +
"       <string>"+ string(Parm.faultCode) + "</string> " + "\n" +
"      </value>" + "\n" +
"     </member>" + "\n" +
"    </struct>" + "\n" +
"   </value>" + "\n" +
"  </fault>" + "\n" +
" </methodResponse>";

      var err = validate(result);
      if (StrLen(err) > 0)
         RunError(err);
      end; 

      if (UseCDATA)
         result = "<![CDATA[" + result + "]]>";
      end;

      return result;

   END;
END;

/////////////////////////////////////////////////////////////////////////////////
// Функция преобразования сообщения из формата XML-RPC в IFX
/////////////////////////////////////////////////////////////////////////////////
MACRO ConvertXmlRpcToIFX(XmlRpcMessage:STRING):STRING
   var res_xml = ApplyXSLT(XmlRpcMessage, "xml_rpc_to_ifx.xsl");
   return res_xml;
END;

/////////////////////////////////////////////////////////////////////////////////
// Функция преобразования сообщения из формата IFX в XML-RPC запрос 
/////////////////////////////////////////////////////////////////////////////////
MACRO ConvertIFXToXmlRpcRequest(IFXMessage:STRING):STRING
   var res_xml = ApplyXSLT(IFXMessage, "ifx_to_xml_rpc_request.xsl");
   return res_xml;
END;

/////////////////////////////////////////////////////////////////////////////////
// Функция преобразования сообщения из формата IFX в XML-RPC ответ 
/////////////////////////////////////////////////////////////////////////////////
MACRO ConvertIFXToXmlRpcResponse(IFXMessage:STRING):STRING
   var res_xml = ApplyXSLT(IFXMessage, "ifx_to_xml_rpc_response.xsl");
   return res_xml;
END;

/////////////////////////////////////////////////////////////////////////////////
// Функция преобразования произвольного XML-объекта в RSL объект  
/////////////////////////////////////////////////////////////////////////////////
MACRO ConvertXmlToRsl(Xml:STRING, xsltFile:STRING):OBJECT
   if (STRLEN(xsltFile) == 0)
      // XSLT преобразование не определено - используем стандартное
      xsltFile = DEFAULT_XML2RSL_XSLT;
   end;
   var res_xml = ApplyXSLT(Xml, xsltFile);

   var res_obj = NULL;
   var stat = ConvertToRSL(res_xml, res_obj);

   return res_obj;
END;

/////////////////////////////////////////////////////////////////////////////////
// Функция преобразования сообщения формата IFX в RSL-объект 
/////////////////////////////////////////////////////////////////////////////////
MACRO ConvertIFXToRsl(IFXMessage:STRING):OBJECT
   var res_xml = ApplyXSLT(IFXMessage, "ifx_to_xml_rpc_response.xsl");

   var res_obj = NULL;
   var stat = ConvertToRSL(res_xml, res_obj);

   return res_obj;
END;

/////////////////////////////////////////////////////////////////////////////////
// Функция преобразования RSL-объекта в сообщение формата IFX  
/////////////////////////////////////////////////////////////////////////////////
MACRO ConvertRslToIFX(Rsl:OBJECT):STRING

   var xml_rpc;
   var stat = ConvertToXML(Rsl, "", xml_rpc);

   var ifx_xml = ConvertXmlRpcToIFX(xml_rpc);

   return ifx_xml;
END;





