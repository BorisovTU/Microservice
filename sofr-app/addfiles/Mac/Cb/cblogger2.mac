/*
  cblogger2.mac
  Ещё одни утилиты для логирования

  Задумка такая, что есть класс c_logger(), который, по сути, испольняет роль интерфейса, как в других языках.
  В этом классе не должно быть логики, это просто шаблон необходимых макро-процедур, которые должны быть реализованы в наследниках.

  При использовании можно будет выбрать тот или иной класс в зависимости от логики и далее ничего менять не нажно.

  Пример:

  macro Example(isAuto:bool)
    var logger:c_logger();

    if (isAuto)
      logger = LoggerFactory().NewItLog("logger_name").GetLogger();
    else
      logger = LoggerFactory().NewPrintLog("logger_name").GetLogger();
    end;

    logger.Info("start process");
    //logic
    logger.Debug("Additional info");
    //logic
    logger.Info("end process");
  onError()
   logger.Error("Error text");
  end;

  В примере выше логирование будет производиться в itt_log или в обычный println() в зависимости от параметро isAuto
*/
import oralib, likepy;

//template
class c_logger()
  const IT_LOG_TYPE:integer = 1;
  const PRINT_TYPE:integer = 2;
  const FILE_TYPE:integer = 3;

  macro Info(text:string) end;
  macro Debug(text:string) end;
  macro Error(text:string) end;
  macro ErrorClob(text:string, clobText:string) end;

  // использовать как статический метод для создания уникального имени файла перед созданием объекта
  macro DateTimeName
       var dd, mm, yyyy;
       var hh, min, sec;
       var dt: date;
       var tm: time;
       dt = date;
       tm = time;
       DateSplit(dt, dd, mm, yyyy);
       TimeSplit(tm, hh, min, sec);
       return string(yyyy:o:4)+string(mm:o:2)+string(dd:o:2)+"_"+string(hh:o:2)+string(min:o:2)+string(sec:o:2);
  end;
end;


/**

  @brief класс c_logger_file_log для вывода в текстовый файл-лог

  Пример использования:
  var lobj = NewLogger(c_logger.FILE_TYPE, "mylogger_name", c_logger.DateTimeName+"myfile_name"); 
  lobj.info("my text info");
  lobj.debug("my text debug");

  В результате в файле D:\RSHB_SOFR_DEBUG\TxtFile\20240920_170305myfile_name.1011 будет следующие строки:
  2024/09/20 17:03:05: my text info
  2024/09/20 17:03:05: mylogger_name.debug: my text debug

*/
private class (c_logger) c_logger_file_log(p_objectName:string, p_fileName:string)
  private var objectName = p_objectName;
  private var fileName = p_fileName;

  private macro DateTimeStr
       var dd, mm, yyyy;
       var hh, min, sec;
       var dt: date;
       var tm: time;

       dt = date;
       tm = time;
       DateSplit(dt, dd, mm, yyyy);
       TimeSplit(tm, hh, min, sec);

       return string(yyyy:o:4)+"/"+string(mm:o:2)+"/"+string(dd:o:2)+" "+string(hh:o:2)+":"+string(min:o:2)+":"+string(sec:o:2);
  end;

  private macro basePrint(text:string, type:string, appended: bool)
    var m_appended: bool;
    if(ValType(appended) == v_undef)
      m_appended = true;
    else 
      m_appended = appended;
    end;
    SetOutput(GetTxtFileName(fileName), m_appended);
    println(DateTimeStr() + ": " + type + text);
    SetOutput(null,true);
  end;

  macro Info (text:string, appended: bool)
    basePrint(text, "", appended);
  End;

  macro Debug(text:string, appended: bool)
    basePrint(text, objectName + ".debug: ", appended);
  end;

  macro Error(text:string, appended: bool)
    basePrint(text, objectName + ".ERROR: ", appended);
  end;

  macro ErrorClob(text:string, clobText:string, appended: bool)
    basePrint(text, objectName + ".ERROR: ", appended);
  end;

  macro viewLogFile()
    info(GetTxtFileName(fileName));
    ViewFile(GetTxtFileName(fileName));
  end;

end;

private class (c_logger) c_logger_it_log(p_objectName:string)
  private var objectName = p_objectName;

  macro Info(text:string)
    var query = "begin "
              + "  it_log.log_handle(p_object => :obj, "
              + "                    p_msg    => :msg, "
              + "                    p_msg_type => it_log.c_msg_type__msg); "
              + "end;";

    ExecSql(query, MakeArray(SqlParam("obj", objectName),
                             SqlParam("msg", text)));
  end;

  macro Debug(text:string)
    var query = "begin "
              + "  it_log.log_handle(p_object => :obj, "
              + "                    p_msg    => :msg, "
              + "                    p_msg_type => it_log.c_msg_type__debug); "
              + "end;";

    ExecSql(query, MakeArray(SqlParam("obj", objectName),
                             SqlParam("msg", text)));
  end;

  macro Error(text:string)
    var query = "begin "
              + "  it_log.log_error(p_object => :obj, "
              + "                   p_msg    => :msg); "
              + "end;";

    ExecSql(query, MakeArray(SqlParam("obj", objectName),
                             SqlParam("msg", text)));
  end;

  macro ErrorClob(text:string, clobText:string)
    var params = MakeArray(SqlParam("p_object",   objectName),
                           SqlParam("p_msg",      text),
                           SqlParam("p_msg_clob", clobText));
    ExecStoredFunc("it_log.log_error", V_UNDEF, params);
  end;
end;

private class (c_logger) c_logger_print(p_objectName:string)
  private var objectName = p_objectName;

  macro Info (text:string)
    println(time() + ": " + text);
  End;

  macro Debug(text:string)
    println(time() + ": " + objectName + ".debug: " + text);
  end;

  macro Error(text:string)
    println(time() + ": " + objectName + ".ERROR: " + text);
  end;

  macro ErrorClob(text:string, clobText:string)
    println(time() + ": " + objectName + ".ERROR: " + clobText);
  end;
end;

macro NewLogger(loggerType:integer, objectName:string, fileName:string):c_logger
  if (loggerType == c_logger.IT_LOG_TYPE) 
    return c_logger_it_log(objectName);
  end;

  if (loggerType == c_logger.PRINT_TYPE) 
    return c_logger_print(objectName);
  end;

  if (loggerType == c_logger.FILE_TYPE) 
    return c_logger_file_log(objectName, fileName);
  end;

  return c_logger;
end;

/**
@brief        Функция структурирует сообщение об ошибке
@param[in] ObjError   объект ошибки
@return       строка сообщения, структурированная 
*/
macro GetFullErrMsg( ObjError:object ):string

  var errCode, errMes, count, i;

  if (IsEqClass ("TRslError",ObjError))
    errMes = ObjError.Message; 
    errCode = ObjError.Code; 
  else
    errMes = ObjError.getMessage(); 
    errCode = ObjError.getErrorCode(); 
  end;

  var Cause = ObjError.err;

  if (IsEqClass ("TRsComErr", Cause))
    count = Cause.Count;
    i = 0;
    while (i < count)
      errMes = errMes + ";"+ Cause.Message (i) + " (Code = " + Cause.Code (i) +
                                                ", Level = " + Cause.Level (i) + ")" ;
      i = i + 1
    end;
  end;

  if(IsEqClass("TDbError", Cause))
    errMes = errMes + ";" + Cause.Stat + "-" + Cause.Oper + "-" + Cause.Table + "-" + Cause.Message;
  end;

  if(isEqClass("TRsdError", Cause))
    i = 0;
    while(i < Cause.environment.ErrorCount)
      errMes = errMes + ";" + Cause.environment.Error(i).Descr;
      i = i + 1;
    end;
  end;

  if(errCode != 17)
    return "\n|Code    : " + string( errCode )+
           "\n|Message : " + string( errMes )+
           "\n|Module  : " + string( ObjError.Module )+
           "\n|Line    : " + string( ObjError.Line )+
           "\n|AxCode  : " + string( ObjError.AxCode )+
           "\n|Err     : " + string( Cause )+
           "\n|AxMes   : " + string( ObjError.AxMes );
  else 
    return "Прерывание пользователя!"; // прерывание пользователя
  end;
end;

/////////////////////////////ДЕКОРАТОРЫ
/* В конце строки записывает затраченное время с псоледней записи в лог или с создания экземпляра класса

  var logger = NewLogger(c_logger.IT_LOG_TYPE, "test").WithElapsedTime();
  //прошло две секунды
  logger.Info("point1"); //пишет в лог: "point1. elapsed time 00:00:02"
  //прошшла ещё одна минута
  logger.Info("point2"); //пишет в лог: "point2. elapsed time 00:01:00"

*/
private class (c_logger) c_logger_with_elapsed_time(_logger:c_logger)
  private var logger:c_logger = _logger;
  private var checkedTime = Time();

  private macro GetElapsedTime():string
    var hh, min, sec;
    var elpasedTime = Time() - checkedTime;
    checkedTime = Time();

    timeSplit(elpasedTime, hh, min, sec);
    return string(hh:o:2) + ":" + string(min:o:2) + ":" + string(sec:o:2);
  end;

  macro Info (text:string)
    logger.Info(text + ". elpasedTime: " +  GetElapsedTime());
  End;

  macro Debug(text:string)
    logger.Debug(text + ". elpasedTime: " + GetElapsedTime());
  end;

  macro Error(text:string)
    logger.Error(text + ". elpasedTime: " + GetElapsedTime());
  end;

  macro ErrorClob(text:string, clobText:string)
    logger.ErrorClob(text + ". elpasedTime: " + GetElapsedTime(), clobText);
  end;
end;

/* Декортаор для логгера.
  Добавляет заданый постоянный префикс ко всем записям в лог
*/
private class (c_logger) c_logger_with_prefix(_logger:c_logger, _prefix:string)
  private var logger:c_logger = _logger;
  private var prefix:string = _prefix;

  macro Info (text:string)
    logger.Info(prefix + ". " + text);
  End;

  macro Debug(text:string)
    logger.Debug(prefix + ". " + text);
  end;

  macro Error(text:string)
    logger.Error(prefix + ". " + text);
  end;

  macro ErrorClob(text:string, clobText:string)
    logger.ErrorClob(prefix + ". " + text, clobText);
  end;
end;


///////////////////////////////////////////ФАБРИКА
//наверное, сразу нужно было так делать
class LoggerFactory()
  private var logger:c_logger;

  macro NewItLog(objectName:string):LoggerFactory
    logger = c_logger_it_log(objectName);
    return this;
  end;

  macro NewPrintLog(objectName:string):LoggerFactory
    logger = c_logger_print(objectName);
    return this;
  end;

  //возвращает декоратор c_logger_with_elapsed_time
  macro WithElapsedTime():LoggerFactory
    logger = c_logger_with_elapsed_time(logger);
    return this;
  end;

  //Декоратор с постоянным префиксом
  macro WithPrefix(prefix:string):LoggerFactory
    logger = c_logger_with_prefix(logger, prefix);
    return this;
  end;

  macro GetLogger():c_logger
    return logger;
  end;
end;