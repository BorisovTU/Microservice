 /*
 $Name: pmcarfun.mac
 $Module: Ядро Banking
 $Description: Функции для работы с проводками
 */

import globals, oralib, PaymInter, FIInter;
import likepy, pm_tools;


private const query = "SELECT T_AUTOKEY, "
                             "T_ACCTRNID, "
                             "T_DATE, "
                             "T_CHAPTER, "
                             "T_PAYERFIID, "
                             "T_PAYERAMOUNT, "
                             "T_PAYERACCOUNT, "
                             "T_RECEIVERFIID, "
                             "T_RECEIVERAMOUNT, "
                             "T_RECEIVERACCOUNT, "
                             "T_SHIFR_OPER, "
                             "T_NUMBER_PACK, "
                             "T_NUMB_DOCUMENT, "
                             "T_KIND_OPER, "
                             "T_GROUND, "
                             "T_DEPARTMENT, "
                             "T_REASON, "
                             "T_CARRYSTATUS "
                        "FROM TABLE( PM_CARFUN.GetPaymentCarries( ? ) )";

/**
 * Структура выборки с информацией о проводках
 */
class (TRsdRecordReader) TPaymentCarryInfo
  var AUTOKEY:integer,
      ACCTRNID:integer,
      DATE:date,
      CHAPTER:integer,
      PAYERFIID:integer,
      PAYERAMOUNT:money,
      PAYERACCOUNT:string,
      RECEIVERFIID:integer,
      RECEIVERAMOUNT:money,
      RECEIVERACCOUNT:string,
      SHIFR_OPER:string,
      NUMBER_PACK:integer,
      NUMB_DOCUMENT:string,
      KIND_OPER:string,
      GROUND:string,
      DEPARTMENT:integer,
      REASON:integer,
      CARRYSTATUS:integer;
  initTRsdRecordReader();
end;

// Перепроводка платежа на другой счёт
macro CarryPaymOnNewAccount( PaymentObj:RsbPayment, // Платёж
                             Side:integer,          // Сторона проводки (PRT_Debet или PRT_Credit)
                             Chapter:integer,       // Глава счёта
                             OldFIID:integer,       // Валюта старого счёта
                             OldAccount:string,     // Номер старого счёта
                             NewFIID:integer,       // Валюта нового счёта
                             NewAccount:string,     // Номер нового счёта
                             CarryStatus:integer,   // Статус новой проводки (необязательный)
                             NewDateValue:date      // Дата новой проводки (необязательный)
)
 var params = makeArray(SQLParam( "PaymentID", PaymentObj.PaymentID ));
 var rs:RsdRecordset = execSQLselect( query, params, false );
 var Del:bool = false;
 var stat = 0;
 var paymtr:RsbPaymTransaction = PaymentObj.MakeTransaction();
 var carrydoc:TRecHandler;
 var SumPayer, SumReceiver;
 var TypeDoc;
 while(rs.moveNext() and (Del == false))
     if( ((Side == PRT_Debet)  and ( rs.value("T_PAYERACCOUNT"   )  == OldAccount) and (rs.value("T_PAYERFIID"   ) == OldFIID)) or
         ((Side == PRT_Credit) and ( rs.value("T_RECEIVERACCOUNT")  == OldAccount) and (rs.value("T_RECEIVERFIID") == OldFIID)) ) 
         Del = true
     end;
 end;
   if( Del == true )
       //удаляем старую проводку
       if( not PaymentObj.DeleteTransaction(int(rs.value("T_ACCTRNID")), carrydoc, TypeDoc) )
       //выполняем аналогичную удаленной    
          paymtr.SumPayer     = rs.value("T_PAYERAMOUNT"   );
          paymtr.SumReceiver  = rs.value("T_RECEIVERAMOUNT");                    
          
          if( OldFIID != NewFIID ) 
            if(( NewFIID == rs.value("T_PAYERFIID")) and ( Side == PRT_Credit ))
                paymtr.SumReceiver = paymtr.SumPayer;
            elif(( NewFIID == rs.value("T_RECEIVERFIID")) and ( Side == PRT_Debet ))
                paymtr.SumPayer = paymtr.SumReceiver;
            else
              if( Side == PRT_Credit )
                ConvSumCross(paymtr.SumReceiver, paymtr.SumPayer, rs.value("T_DATE"), rs.value("T_PAYERFIID"), NewFIID);
              else
                ConvSumCross(paymtr.SumPayer, paymtr.SumReceiver, rs.value("T_DATE"), rs.value("T_RECEIVERFIID"), NewFIID);
              end;
            end;
          end;

          if(Side == PRT_Credit)    
            paymtr.FIIDReceiver = NewFIID;
            paymtr.AccountReceiver = NewAccount;
            paymtr.FIIDPayer    = rs.value("T_PAYERFIID"); 
            paymtr.AccountPayer = rs.value("T_PAYERACCOUNT");
          else
            paymtr.FIIDPayer    = NewFIID;
            paymtr.AccountPayer = NewAccount;
            paymtr.FIIDReceiver = rs.value("T_RECEIVERFIID");
            paymtr.AccountReceiver = rs.value("T_RECEIVERACCOUNT");
          end;
       
          paymtr.Chapter         = carrydoc.rec.Chapter;
          paymtr.Date_Carry      = carrydoc.rec.Date_Carry;
          if( NewDateValue != null )
            paymtr.Date_Carry = NewDateValue;
          end;
          paymtr.Shifr_Oper      = carrydoc.rec.Shifr_Oper;
          paymtr.Number_Pack     = carrydoc.rec.Number_Pack;
          paymtr.Numb_Document   = carrydoc.rec.Numb_Document;
          paymtr.Kind_Oper       = carrydoc.rec.Kind_Oper;
          paymtr.Ground          = carrydoc.rec.Ground;
          paymtr.Department      = carrydoc.rec.Department;
          paymtr.ClaimID         = PaymentObj.ClaimID;
          paymtr.Reason          = rs.value("T_REASON");
          
          if( CarryStatus != NULL ) // если передан тип проводки
            paymtr.Status_After = CarryStatus;
          else
            if( TypeDoc != 2 /*DOC_ARH*/ )
              paymtr.Status_After = ACCTRN_STATUS_PLAN;
            end;
          end;

          if( not paymtr.Carry )
            MsgBox("Ошибка при актуализации платежа");
            return 1;
          end;  
          
          // Копируем кассовые символы в новую проводку
          if(not CopyCarryCashSymbol(paymtr, rs.value("T_ACCTRNID")))
            msgbox("Ошибка при копировании кассовых символов.");
            return 1;
          end;
       else
         MsgBox("Ошибка при удалении проводки");
         return 1;
       end;
   end;
 
end;

macro DeleteCarryOnAccount(PaymentObj:RsbPayment, Side, FIID, Account)
 
 var params = makeArray(SQLParam( "PaymentID", PaymentObj.PaymentID ));
 var rs:RsdRecordset = execSQLselect( query, params, false );
 var Del:bool = false;
 var stat = 0;
 var carrydoc:TRecHandler;

 while(rs.moveNext())
   if(((Side == PRT_Debet)  and ( rs.value("T_PAYERACCOUNT"   )  == Account) and (rs.value("T_PAYERFIID"   ) == FIID)) or
      ((Side == PRT_Credit) and ( rs.value("T_RECEIVERACCOUNT")  == Account) and (rs.value("T_RECEIVERFIID") == FIID)) )      
     return PaymentObj.DeleteTransaction(int(rs.value("T_ACCTRNID")));
   end;
 end;
end;

// Перепроводка платежа другой датой
macro CarryPaymOnNewDate(PaymentObj:RsbPayment, NewValueDate:Date)

 var params = makeArray(SQLParam( "PaymentID", PaymentObj.PaymentID ));
 var rs:RsdRecordset = execSQLselect( query, params, false, RSDVAL_CLIENT, RSDVAL_STATIC );
 var paymtr:RsbPaymTransaction;
 var stat = 0, i = 0;
 var carrydoc:TRecHandler;
 array carrydocs; 
 
 if(PaymentObj.ValueDate == NewValueDate)
   return 0; // проводка и так с нужной датой
 end;

 // удаляем проводки
 while( rs.movePrev() )
   if( rs.value("T_CHAPTER") == 1/*CHAPT1*/ ) 
     PaymentObj.DeleteTransaction(int(rs.value("T_ACCTRNID")),carrydoc);
     carrydocs(i) = carrydoc;
     i = i + 1;
   end;
 end;

 // делаем проводки с новой датой
 while( rs.moveNext() )
   if( rs.value("T_CHAPTER") == 1/*CHAPT1*/ )
     i = i - 1;
     paymtr = PaymentObj.MakeTransaction();
     //выполняем аналогичную удаленной проводку (меняем только дату)   
     paymtr.SumPayer     = rs.value("T_PAYERAMOUNT");
     paymtr.SumReceiver  = rs.value("T_RECEIVERAMOUNT");                    
        
     paymtr.FIIDPayer    = rs.value("T_PAYERFIID"); 
     paymtr.AccountPayer = rs.value("T_PAYERACCOUNT");
     paymtr.FIIDReceiver = rs.value("T_RECEIVERFIID");
     paymtr.AccountReceiver = rs.value("T_RECEIVERACCOUNT");

     paymtr.Chapter         = carrydocs(i).rec.Chapter;
     paymtr.Date_Carry      = NewValueDate;       
     paymtr.Shifr_Oper      = carrydocs(i).rec.Shifr_Oper;
     paymtr.Number_Pack     = carrydocs(i).rec.Number_Pack;
     paymtr.Numb_Document   = carrydocs(i).rec.Numb_Document;
     paymtr.Kind_Oper       = carrydocs(i).rec.Kind_Oper;
     paymtr.Ground          = carrydocs(i).rec.Ground;
     paymtr.Department      = carrydocs(i).rec.Department;
     paymtr.Status_After    = ACCTRN_STATUS_DOCUMENT;
     paymtr.ClaimID         = PaymentObj.ClaimID;
     paymtr.Reason          = rs.value("T_REASON");
        
     if( ( PaymentObj.CoverAmount != $0            ) and 
         ( PaymentObj.PIList(PRT_Debet ).Size == 0 ) and 
         ( PaymentObj.PIList(PRT_Credit).Size == 0 ) ) 
       paymtr.SumEquivalentCarry = PaymentObj.CoverAmount;          
     end;

     if( not paymtr.Carry )
       MsgBox("Ошибка при актуализации платежа");
       return 1;
     end;  
    // Заполняем дату списания со счета плательщика новой датой 
    if( (paymtr.AccountPayer == PaymentObj.PayerAccount) and
        (paymtr.FIIDPayer    == PaymentObj.PayerFIID   )  ) 
       PaymentObj.PayerChargeOffDate = NewValueDate; 
    end;
     
     // Копируем кассовые символы в новую проводку
     if(not CopyCarryCashSymbol(paymtr, rs.value("T_ACCTRNID")))
       msgbox("Ошибка при копировании кассовых символов.");
       return 1;
     end;
   end;
 end;

 PaymentObj.ValueDate = NewValueDate;
 
 return 0;
end;  

/**
 * Получить все проводки, связанные с платежом
 * @deprecated      Использовать PM_GetAllCarries
 * @param PaymentID Идентификатор платежа
 * @param rs        Возвращаемый набор записей (record set)
 * @param Chapter   Глава проводок (необязательный)
 * @return          !0, если проводки выбрана, 0 - если не выбраны
 */
macro ПолучитьВсеПроводки( PaymentID:integer, rs:@RsdRecordset, Chapter:integer )
  var params:TArray = makeArray( SQLParam( "PaymentID", PaymentID ) );
  var _query:string = query;
  if( valtype(Chapter) != V_UNDEF )
    _query = string( _query, " WHERE T_CHAPTER = ", Chapter );
  end;
  _query = _query + " ORDER BY T_AUTOKEY";
  rs = execSQLselect( _query, params, true, null, RSDVAL_STATIC );
  return rs.FldCount;  
end;

/**
 * Получить все проводки, связанные с платежом
 * @param PaymentID Идентификатор платежа
 * @param Chapter   Глава проводок (необязательный)
 * @return          Массив структур (TPaymentCarryInfo) с информацией о проводках
 */
macro PM_GetAllCarries( PaymentID:integer, Chapter:integer ):TArray
  var rs      : RsdRecordSet
    , carries : TArray = TArray(10, 10)
    , carry   : TPaymentCarryInfo;
  ПолучитьВсеПроводки( PaymentID, @rs, Chapter );
  while( rs.moveNext() )
    carry = TPaymentCarryInfo();
    carry.read( rs );
    carries[carries.size] = carry;
  end;
  return carries;
end;


//Удаляет последнюю проводку по платежу
macro DeleteLastCarry(PaymentObj:RsbPayment)
  var params = makeArray(SQLParam( "PaymentID", PaymentObj.PaymentID ));
  var rs:RsdRecordset = execSQLselect( query, params, false, null, RSDVAL_STATIC); //RSDVAL_STATIC - чтобы moveLast() работал
  
  if(rs.moveLast())
    return PaymentObj.DeleteTransaction(int(rs.value("T_ACCTRNID")));
  end;  

  return 0; //Нет проводок
end;

// Перепроводка платежа на другой счёт в массовом режиме
macro CarryPaymOnNewAccountMass(PaymentID,
                                ID_Operation,
                                ID_Step,
                                Side,       // Сторона проводки (PRT_Debet или PRT_Credit)
                                Chapter,    // Глава счёта
                                OldFIID,    // Валюта старого счёта
                                OldAccount, // Номер старого счёта
                                NewFIID,    // Валюта нового счёта
                                NewAccount, // Номер нового счёта
                                NewDateValue
)
 var params = makeArray(SQLParam( "PaymentID", PaymentID ));
 var rs:RsdRecordset = execSQLselect( query, params, false );
 var stat = 0;
 var paymtr:RsbPaymTransaction;
 var Del:bool = false;
 var ErrorMsg;
 
 while(rs.moveNext() and (Del == false))
     if( ((Side == PRT_Debet)  and ( rs.value("T_PAYERACCOUNT")  == OldAccount) and (rs.value("T_PAYERFIID") == OldFIID)) or
         ((Side == PRT_Credit) and ( rs.value("T_RECEIVERACCOUNT") == OldAccount) and (rs.value("T_RECEIVERFIID") == OldFIID)) ) 
         Del = true;
     end;
 end;

 if( Del == true )
   /*удаляем старую проводку*/
   if( Opr_DeleteCarry(int(rs.value("T_ACCTRNID")),ID_Operation,ID_Step) )   
     //выполняем аналогичную удаленной    
      paymtr = RsbPaymTransaction( PaymentID );

      paymtr.SumPayer     = rs.value("T_PAYERAMOUNT");
      paymtr.SumReceiver  = rs.value("T_RECEIVERAMOUNT");                          
      if( OldFIID != NewFIID ) 
        if(( NewFIID == rs.value("T_PAYERFIID")) and ( Side == PRT_Credit ))
            paymtr.SumReceiver = paymtr.SumPayer;
        elif(( NewFIID == rs.value("T_RECEIVERFIID")) and ( Side == PRT_Debet ))
            paymtr.SumPayer = paymtr.SumReceiver;
        else
          if( Side == PRT_Credit )
            ConvSumCross(paymtr.SumReceiver, paymtr.SumPayer, rs.value("T_DATE"), rs.value("T_PAYERFIID"), NewFIID);
          else
            ConvSumCross(paymtr.SumPayer, paymtr.SumReceiver, rs.value("T_DATE"), rs.value("T_RECEIVERFIID"), NewFIID);
          end;
        end;
      end;
      if(Side == PRT_Credit)    
        paymtr.FIIDReceiver = NewFIID;
        paymtr.AccountReceiver = NewAccount;
        paymtr.FIIDPayer    = rs.value("T_PAYERFIID"); 
        paymtr.AccountPayer = rs.value("T_PAYERACCOUNT");
      else
        paymtr.FIIDPayer    = NewFIID;
        paymtr.AccountPayer = NewAccount;
        paymtr.FIIDReceiver = rs.value("T_RECEIVERFIID");
        paymtr.AccountReceiver = rs.value("T_RECEIVERACCOUNT");
      end;
   
      paymtr.Chapter = rs.value("T_CHAPTER");

      if( NewDateValue != NULL )
        paymtr.Date_Carry = NewDateValue;      
      else
        paymtr.Date_Carry = rs.value("T_DATE");
      end;
    
      paymtr.Shifr_Oper      = rs.value("T_SHIFR_OPER");
      paymtr.Number_Pack     = rs.value("T_NUMBER_PACK");
      paymtr.Numb_Document   = rs.value("T_NUMB_DOCUMENT");
      paymtr.Kind_Oper       = rs.value("T_KIND_OPER");
      paymtr.Ground          = rs.value("T_GROUND");
      paymtr.Department      = rs.value("T_DEPARTMENT");      
      paymtr.Status_After    = ACCTRN_STATUS_DOCUMENT;
      paymtr.Reason          = rs.value("T_REASON");
      paymtr.ID_Operation    = ID_Operation;
      paymtr.ID_Step         = ID_Step;

      if( not paymtr.Carry(NULL,ErrorMsg) )
        msgbox("Ошибка проводки с " + paymtr.AccountPayer + " на " + paymtr.AccountReceiver + " датой " + paymtr.Date_Carry + ": " + ErrorMsg);
        return 1;
      end;  
     // Копируем кассовые символы в новую проводку
     if(not CopyCarryCashSymbol(paymtr, rs.value("T_ACCTRNID")))
       msgbox("Ошибка копирования кассовых символов в проводку " + rs.value("T_ACCTRNID"));
       return 1;
     end;
   else     
     msgbox("Ошибка удаления проводки " + rs.value("T_ACCTRNID"));
     return 1;
   end;
 end;
 
end;
macro CarryPaymOnNewDateMass(PaymentID:Integer, NewValueDate:Date, ID_Operation, ID_Step )

 var params = makeArray(SQLParam( "PaymentID", PaymentID ));
 var rs:RsdRecordset = execSQLselect( query, params, false, RSDVAL_CLIENT, RSDVAL_STATIC );
 var paymtr:RsbPaymTransaction;
 var stat = 0, ErrorMsg;

 while( rs.moveNext() )
   if( rs.value("T_CHAPTER") == 1/*CHAPT1*/ ) 
     if( Opr_DeleteCarry(int(rs.value("T_ACCTRNID")),ID_Operation,ID_Step) )  
       paymtr = RsbPaymTransaction( PaymentID );
       paymtr.SumPayer     = rs.value("T_PAYERAMOUNT");
       paymtr.SumReceiver  = rs.value("T_RECEIVERAMOUNT");                    
       paymtr.FIIDPayer    = rs.value("T_PAYERFIID"); 
       paymtr.AccountPayer = rs.value("T_PAYERACCOUNT");
       paymtr.FIIDReceiver = rs.value("T_RECEIVERFIID");
       paymtr.AccountReceiver = rs.value("T_RECEIVERACCOUNT");
       paymtr.Chapter         = rs.value("T_CHAPTER");
       paymtr.Date_Carry      = NewValueDate;       
       paymtr.Shifr_Oper      = rs.value("T_SHIFR_OPER");
       paymtr.Number_Pack     = rs.value("T_NUMBER_PACK");
       paymtr.Numb_Document   = rs.value("T_NUMB_DOCUMENT");
       paymtr.Kind_Oper       = rs.value("T_KIND_OPER");
       paymtr.Ground          = rs.value("T_GROUND");
       paymtr.Department      = rs.value("T_DEPARTMENT");
       paymtr.Status_After    = ACCTRN_STATUS_DOCUMENT;
       paymtr.Reason          = rs.value("T_REASON");
       paymtr.ID_Operation    = ID_Operation;
       paymtr.ID_Step         = ID_Step;
          
       if( not paymtr.Carry(NULL, ErrorMsg) )
         return 1;
       end;  
       // Копируем кассовые символы в новую проводку
       if(not CopyCarryCashSymbol(paymtr, rs.value("T_ACCTRNID")))
         return 1;
       end;
     else
       return 1;
     end;
   end;
 end;
 
 return 0;
end;                            

// Проверка возможности отзыва платежа
macro IsPaymentRevocable(PaymentID : integer, PaymStatus : integer) : bool

  if(PaymStatus > PM_READY_TO_SEND)
    return FALSE;
  end;

  var IrrevocRegVal : integer;
  if( GetRegistryValue("CB\\PAYMENTS\\IRREVOCABILITY", V_INTEGER, IrrevocRegVal) != V_INTEGER )
    IrrevocRegVal = 0;
  end;

  if(IrrevocRegVal != 2) // нужно проверять наличие проводок по платежу по главе А 
    var rs : RsdRecordset;

    if( ПолучитьВсеПроводки(PaymentID, @rs, 1/*CHAPT1*/) and rs.moveFirst() )

      if(IrrevocRegVal == 1) // не допускаются фактические

        var IsFact : bool = ( rs.value("t_CarryStatus") == TRN_STATE_FACT );

        while(not IsFact and rs.moveNext())
          IsFact = ( rs.value("t_CarryStatus") == TRN_STATE_FACT );
        end;

        if(IsFact)
          return FALSE;
        end;
      else // не должно быть никаких
        return FALSE;
      end;

    end;

  end;

  // проверки пройдены
  return TRUE;
end;
