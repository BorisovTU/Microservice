//-----------------------------------------------------------------------------
// Блок     : 29014  - "Предобработка платежа банка"
//            29015  - "Предобработка требования банка"
//            29016  - "Предобработка клиентского платежа"
//            29017  - "Предобработка кассового документа"
//            29018  - "Предобработка мемориального документа"
// Шаг      : 60(50) - "Проверка остатков по счетам"
// Описание : Общие функции
//-----------------------------------------------------------------------------
import pm_common, pm_setst, "cbsttls.mac", "pm_reserve.mac";

CONST PAYMERR_NORESERVCREDIT = 5;

PRIVATE MACRO IsSFOrigin( Payment:RsbPayment ):bool
  var obj:object = NULL;
  
  IF( ( Payment.DocKind == DLDOC_BANKPAYMENT ) or ( Payment.DocKind == DLDOC_BANKCLAIM ) )
    IF( Payment.DocKind == DLDOC_BANKPAYMENT )
      obj = GenObject( "RsbBankPayment", Payment.DocumentID );
    ELSE
      obj = GenObject( "RsbBankClaim", Payment.DocumentID );
    END;
    return (obj.Origin == MEMORDER_FDOC_SF);
  
  ELIF( Payment.DocKind == BBANK_CPORDER )
    obj = GenObject( "RsbBbCpOrder", Payment.DocumentID );
    return (obj.Origin == CP_OR_SF);
  END;

  return false;
end;

// Проверка на порожденность от клиентского платежа
MACRO ПорожденКлиентскимПлатежом(DocumentID:integer)
  var Query: string = " SELECT * "+
                      " FROM doprdocs_dbt d , doproper_dbt o "+
                      " WHERE d.t_DocKind = : DocKind AND "+
                      "       d.t_DocumentID = : DocumentID AND "+
                      "       d.t_ID_Operation = o.t_ID_Operation AND "+
                      "       o.t_DocKind = : DocKindOper ",
      params: TArray = makeArray( SQLParam( "DocKind"    , CASH_PS_OUTORDER),
                                  SQLParam( "DocumentID" , string( DocumentID:34:o ) ),
                                  SQLParam( "DocKindOper", PS_PAYORDER     ));

  return existsSQLselect( Query, params );
END;

//-----------------------------------------------------------------------------
// Формирование сообщения о отсутствии свободного остатка
//-----------------------------------------------------------------------------
MACRO ErrFreeAmount( Payment:RsbPayment, acclaim:TRecHandler ):string                                      
  if( acclaim.rec.ClaimId )                                                                                
    if( acclaim.rec.RestKind == 1 )                                                                        
      return "На счет плательщика " + Payment.PayerAccount + " наложен полный арест";                      
    else                                                                                                   
      return "На счет плательщика " + Payment.PayerAccount + " наложен частичный арест";                   
    end;                                                                                                   
  else                                                                                                     
    if(IsSFOrigin(Payment))                                                                                
      return "Недостаточно средств на счете плательщика " + Payment.PayerAccount + " для оплаты комиссии"; 
    else                                                                                                   
      return "Недостаточно средств на счете плательщика " + Payment.PayerAccount;                          
    end;                                                                                                   
  end;                                                                                                     
END;

//-----------------------------------------------------------------------------
// Предупредить об отсутсвии средств на корсчете ЛОРО
//-----------------------------------------------------------------------------
private macro GetActionErrFreeAmountLORO( Payment:RsbPayment ):integer

  Array Text;
  Array Buttons;

  var DialogFlag = TSetDialogFlag(1);

  var result:integer = GetCachedVar( "StageLORO_BBANKPAYMENT" + string( Payment.PayerAccount ) );
  if( ValType( result ) == V_UNDEF )

    Text(0) = "На корреспондентском счете ЛОРО " + Payment.PayerAccount + " недостаточно средств. Поместить документ в очередь к корсчету ЛОРО?";
    
    Buttons(0) = "В очередь";
    Buttons(1) = "Отвергнуть";

    result = ConfWin( Text, Buttons );

    if( IsOprMultiExec() )
      SetCachedVar( "StageLORO_BBANKPAYMENT" + string( Payment.PayerAccount ), result );
    end;
  end;

  return result;
end;

macro CheckReceiverAccount( Account, FIID, Amount, ValueDate, TransferDate, CreditGroup )
  
  var  KindAccount,
       TypeAccount,
       PairAccount;
    
  var rs:RsdRecordset,
      Query: string = " SELECT d.t_Kind_Account, d.t_Type_Account, d.t_PairAccount "+
                        " FROM daccount_dbt d "+
                        " WHERE d.t_Account       = :Account "+                       
                        "   AND d.t_Chapter       = :Chapter "+                 
                        "   AND d.t_Code_Currency = :FIID    ",

              
  params: TArray = makeArray( SQLParam( "Account" , Account ),
                              SQLParam( "Chapter" , CHAPT1  ),
                              SQLParam( "FIID"    , FIID    ));
                                  
  rs = execSQLselect( Query, params , true  );
  
  if( ValType(TransferDate) == V_UNDEF )
    TransferDate = ValueDate;
  end;

  if( ValType(CreditGroup) == V_UNDEF )
    CreditGroup = PAYMENTS_GROUP_INTERNAL;
  end;

  if( rs.MoveNext() and rs )

    params = makeArray( SQLParam( "p_Amount"         , Amount    ),
                        SQLParam( "p_ReceiverAccount", Account   ),
                        SQLParam( "p_Chapter"        , CHAPT1    ),
                        SQLParam( "p_FIID"           , FIID      ),
                        SQLParam( "p_ValueDate"      , ValueDate ),
                        SQLParam( "p_TransferDate"   , TransferDate ),
                        SQLParam( "p_TypeAcc"        , rs.Value(1) ),
                        SQLParam( "p_Kind_Account"   , rs.Value(0) ),
                        SQLParam( "p_PairAccount"    , rs.Value(2) ),
                        SQLParam( "p_CreditGroup"    , CreditGroup )
                      );

    if(execStoredFunc( "PM_RESTFUN.CheckRestForAccountCredit", V_INTEGER, params ) > 0)
      return false;
    end;   
  end;   
  return true;
end;

private macro CheckReceiverAccounts( Payment : RsbPayment ) : integer
  if( Payment.PIList(PRT_Credit).Size > 0 )  // проверяем разноску
    var pi :TRecHandler     = TRecHandler( "pmaddpi.dbt" );
    var piList:RsbPIPayment = Payment.PIList( PRT_Credit );
    var ok : bool           = ( PIList.First( pi ) == 0 );

    while( ok )
      if( not CheckReceiverAccount( pi.rec.Account, pi.rec.FIID, pi.rec.Amount, Payment.ValueDate ) )
        return PAYMERR_NORESERVCREDIT;
      end;
      ok = ( PIList.Next( pi ) == 0 );
    end;

  else
    if( not CheckReceiverAccount( Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.FutureReceiverAmount, Payment.ValueDate, Payment.OutTransferDate, Payment.ReceiverGroup ) )
      return PAYMERR_NORESERVCREDIT;
    end;
  end;

  return 0;
end;

//-----------------------------------------------------------------------------
// Общие проверки остатков по счетам
//-----------------------------------------------------------------------------
MACRO PM_CheckAccRestCommon( Payment:RsbPayment ):integer

  var DocKind:integer = Payment.DocKind;
  var RestDebet;
  var RestCredit;
  var Rest;
  var obj:object;
  var stat:integer = 0;
  var acclaim :TRecHandler = TRecHandler( "acclaim.dbt" );
  var CheckILORO = true;
  var DialogFlag;
  var IsI2 : bool, IsWaiting : bool, IsWP : bool;

  if( ( Payment.DocKind == DLDOC_BANKPAYMENT ) or ( Payment.DocKind == BBANK_CPORDER ) )
    if( IsLoroAccount(Payment.PayerAccount, Payment.PayerFIID) and IsChildTranzitOrigin(Payment) )
      if( GetClaimSum(Payment) != Payment.FuturePayerAmount )
        RejectPayment(Payment, "На корсчете ЛОРО не зарезервированы средства для исполнения платежа");
      end;
    else
      if( stat = CheckRestAndMakeReserve( Payment, true, true, true, true, 
                                          GetOprStatus(OPR_PAYM_PERMISSION), NULL, 
                                          true, true, 0, true, CheckILORO, true ) )
        return stat;
      end;
    end;

    if (GetOprStatus(OPR_PAYM_INDEX) <= OPR_PAYM_ST_INDEX_NO)
      if( not stat and (stat = CheckReceiverAccounts(Payment)) )
        return stat;
      end;
    end;

  elif( Payment.DocKind == DLDOC_BANKCLAIM )
    if( ( not ПлатежВнешний( Payment ) ) and СчетПассивный( Payment.PayerAccount, CHAPT1, Payment.PayerFIID ) and
        ( not ЕстьПарныйСчет( Payment.PayerAccount, CHAPT1, Payment.PayerFIID ) ) )
      if( stat = CheckRestAndMakeReserve( Payment, true, true, true, true, 
                                          GetOprStatus(OPR_PAYM_PERMISSION), NULL, 
                                          true, null, null, null, CheckILORO, true ) )
        return stat;
      end;
    end;

    if (GetOprStatus(OPR_PAYM_INDEX) <= OPR_PAYM_ST_INDEX_NO)
      if( not CheckReceiverAccount( Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.FutureReceiverAmount, Payment.ValueDate, Payment.OutTransferDate, Payment.ReceiverGroup ) )
        return PAYMERR_NORESERVCREDIT;
      end;
    end;

  elif( InList(Payment.DocKind, PS_PAYORDER, PS_CPORDER, PS_INRQ) and
        (Payment.PrimDocKind != DOC_BO_PAYMENT)
      )
  
      if( not ОбслуживаетсяКлиент( ОпределитьРеальногоПлательщика( Payment ), PTSK_PAY ) )
        msgbox("Счет плательщика не принадлежит клиенту. Ошибка выбора операции");
        return 1;
      end;

      if( СчетАктивный( Payment.PayerAccount, CHAPT1, Payment.PayerFIID ) or
          ЕстьПарныйСчет( Payment.PayerAccount, CHAPT1, Payment.PayerFIID ) )
        msgbox( "Счет не принадлежит клиенту" );
        return 1;
      end;
  elif( Payment.PrimDocKind == DOC_BO_PAYMENT )
    if( stat = CheckRestAndMakeReserve( Payment, true, true, true, true, 
                                        GetOprStatus(OPR_PAYM_PERMISSION), NULL, 
                                        true, true, 0, true, CheckILORO, true ) )
      return stat;
    end;

    if (GetOprStatus(OPR_PAYM_INDEX) <= OPR_PAYM_ST_INDEX_NO)
      if( not stat and (stat = CheckReceiverAccounts(Payment)) )
        return stat;
      end;
    end;

  elif( ( Payment.DocKind == CASH_BOF_ADDORDER ) or
        ( Payment.DocKind == CASH_PS_INCORDER  ) or
        ( Payment.DocKind == CASH_PS_OUTORDER  ) or
        ( Payment.DocKind == CASH_BOF_INCORDER ) or
        ( Payment.DocKind == CASH_BOF_OUTORDER ) )
  
  
  elif( /*( Payment.DocKind == DLDOC_MEMORIALORDER ) or*/ ( Payment.DocKind == CB_MULTYDOC) )
    //вроде нигде не вызывается переписано в макросе mochkrst.mac
    if( Payment.DocKind == DLDOC_MEMORIALORDER )
      obj = GenObject( "RsbMemorialOrder", Payment.DocumentID );
    elif( Payment.DocKind == CB_MULTYDOC )
      obj = GenObject( "RsbMultyDoc", Payment.DocumentID );
    end;
    
    if( СчетПассивный( Payment.PayerAccount, obj.Chapter, Payment.PayerFIID ) and 
        ( not ЕстьПарныйСчет( Payment.PayerAccount, obj.Chapter, Payment.PayerFIID ) ) )
      AccGetFreeAmount( RestDebet, NULL, Payment.PayerAccount, obj.Chapter, Payment.PayerFIID, {curdate}, Payment.Priority, Payment.ClaimID );
      if( RestDebet < Payment.FuturePayerAmount )
        msgbox( "Недостаточно средств для списания" );
        return 1;
      end;
    end;

    if( ( Payment.ToBackOffice == "" ) or ( Payment.NotForBackOffice == "X" ) )  
      if( not CheckReceiverAccount( Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.FutureReceiverAmount, Payment.ValueDate ) )
        return PAYMERR_NORESERVCREDIT;
      end;
    end;
  end;

  return 0;
END;
