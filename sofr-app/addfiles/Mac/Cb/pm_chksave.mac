/*
$Name:             pm_chksave.mac
$Module:           Ядро Banking
$Description:      Общие проверки макросов скроллингов
*/

import BankInter, OprInter, likepy, pm_tools, pm_common, pmlib, rmcmptl, pm_const,
       CTInter, "pm_check_pbr.mac", "bnk_common.mac", "pm_allowtransfer.mac";

// Серьезность ошибки
const NOTERROR = 0, // Ошибки нет
      WARNING  = 1, // Предупредить пользователя.
      ERROR    = 2; // Серьезная ошибка. Сохранять нельзя.

private const SET_CHAR   = "X";
private const UNSET_CHAR = "";

//-----------------------------------------------------------------------------
// Является ли субъект резидентом
//-----------------------------------------------------------------------------
private macro IsResident( PartyID:integer ):bool

  var select:string = " select party.T_NotResident " +
                        " from dparty_dbt party "+
                       " where party.T_PARTYID = :PartyID";
  var params:TArray = makeArray( SQLParam( "PartyID", PartyID ) );
  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    if( rset.value(0) == "X" )     
      return false;
    end;
  end;

  return true;
end;
  
// Получить bankdprt.rec.CheckData для банка плательщика/получателя
private macro GetBankDprtCheckData( BICRCCCode: string ):string
  var rs:object;
  var select:string;
  var params:TArray;
  var checkData = "";

  if( BICRCCCode )
    select = "select bnkdp.t_checkdata " + 
             "from dbankdprt_dbt bnkdp " + 
             "where bnkdp.t_partyid = ( " + 
                     "select oc.t_objectid " + 
                     "from dobjcode_dbt oc " +
                     "where oc.t_code = :Code " +
                     " and oc.t_objecttype = :ObjectType " +
                     " and oc.t_codekind = :CodeKind " +
                     " and rownum = 1 ) ";

    params = makeArray( SQLParam( "Code", BICRCCCode ),
                        SQLParam( "ObjectType", OBJTYPE_PARTY ),
                        SQLParam( "CodeKind", PTCK_BIC )
                      );

    rs = execSQLselect( select, params );

    if ( rs and rs.moveNext() )
      checkData = rs.value( "t_checkdata" );
    end;
  end;
  return checkData;
end;
      
// Поля панели (инициализируем реальными значениями в наследнике)
// !!! Инициализировать реальными значениями полей (нумерация с нуля)!!!
// По умолчанию перемешаемся в первое поле
// Если указаны ResName:string, ResLbr:string, 
// то пытаемся определить номера панели основываясь на стандартное название полей (\bbin.lib\PM\pmin.s362 namespace PPF)
class TPanelFields( p_ResName:string, p_ResLbr:string )
  
  var dlgPanel = null; 
  
  if( (ValType(p_ResName) != V_UNDEF) and (p_ResName != "") )
    dlgPanel = TRecHandler(p_ResName, p_ResLbr, TRUE);
  end;

  macro GetFieldNum( fieldName:string )
    var fldNum = 0;

    if(dlgPanel != null )
      while( fldNum < FldNumber(dlgPanel))
        if( fieldName == FldName (dlgPanel, fldNum))
          return fldNum;
        end;
        fldNum = fldNum + 1;
      end;
    end;
    return fldNum;
  end;


  var Number:integer             = GetFieldNum( "Number" ),
      BaseAmount:integer         = GetFieldNum( "BaseAmount" ),
      FIID:integer               = 0,
      BaseFIID:integer           = 0,
      PayFIID:integer            = 0,
      Priority:integer           = GetFieldNum( "Priority" ),
      NumberPack:integer         = GetFieldNum( "NumberPack" ),
      rmDate:integer             = GetFieldNum( "Date" ),
      PayDate:integer            = GetFieldNum( "PayDate" ),
      ValueDate:integer          = GetFieldNum( "ValueDate" ),
      PayerBankEnterDate:integer = GetFieldNum( "PayerBankEnterDate" ),
      ReceiverBankMarkDate:integer = GetFieldNum( "ReceiverBankMarkDate" ),
      TransferDate:integer       = 0,
      PayerAccount:integer       = GetFieldNum( "PayerAccount" ),
      ReceiverAccount:integer    = GetFieldNum( "ReceiverAccount" ),
      PayerName:integer          = GetFieldNum( "PayerName" ),      
      Ground:integer             = GetFieldNum( "Ground" ),
      PaymentKind:integer        = GetFieldNum( "PaymentKind" ),
      PayerBankCodeKind:integer  = GetFieldNum( "PayerBankCodeKind" ),
      PayerBankCode:integer      = GetFieldNum( "PayerBankCode" ),
      PayerCorrAccNostro:integer = GetFieldNum( "PayerCorrAccNostro" ),
      ReceiverBankCodeKind:integer  = GetFieldNum( "ReceiverBankCodeKind" ),
      ReceiverBankCode:integer      = GetFieldNum( "ReceiverBankCode" ),
      ReceiverCorrAccNostro:integer = GetFieldNum( "ReceiverCorrAccNostro" ),
      ReceiverName:integer          = GetFieldNum( "ReceiverName" ),
      PrevInstrAgentCode = 0,
      IntermediaryBankCode = 0,
      SenderBankCode = 0,
      ExecutorBankCode = 0,
      PrevInstrAgentAccount = 0,
      IntermediaryBankAccount = 0,
      SenderBankAccount = 0,
      ExecutorBankAccount = 0;
end;

private class TExecFunSaveChkParm( )
  // Парамерты платежа
  var pm_paym:TRecHandler;
  var debet:TRecHandler;
  var credit:TRecHandler;
  var rm:TRecHandler;
  var pspayord:TRecHandler;
  var pspaydem:TRecHandler;
  var pmserv:TRecHandler;

  var PrevInstrAgent:TRecHandler;
  var SenderBank:TRecHandler;
  var ExecutorBank:TRecHandler;
  var IntermediaryBank:TRecHandler;
  var PayerBank:TRecHandler;
  var ReceiverBank:TRecHandler;
  
  var PaymentObj:RsbPayment; 
  // Поля панели
  var flds:TPanelFields;
  
  // Буфера счетов (чтобы не искать каждый раз)
  var PayerAccount = null;
  var ReceiverAccount = null;
  
  // Буфера счетов разноски
  var PIAccounts:TArray = TArray();

  // Буфера параметров банков
  var PayerBankDprt:TRecHandler = null;
  var ReceiverBankDprt:TRecHandler = null;

  macro GetPayerBankDprt():TRecHandler
    if( (PayerBankDprt == null) and ( pm_paym.rec.PayerBankID > 0 ) )
      PayerBankDprt = Bnk_GetBankDprt( pm_paym.rec.PayerBankID );
    end;
    return PayerBankDprt;
  end;

  macro GetReceiverBankDprt():TRecHandler
    if( (ReceiverBankDprt == null) and ( pm_paym.rec.ReceiverBankID > 0 ) )
      ReceiverBankDprt = Bnk_GetBankDprt( pm_paym.rec.ReceiverBankID );
    end;
    return ReceiverBankDprt;
  end;

end;

// Класс ошибки
private class TError( _stat:integer, _msg:string , _fld:integer)
  var stat:integer = _stat; // Серьезность ошибки
  var msg:string = _msg;    // Сообщение
  var fld:integer;          // Поле в которое перемещаемся
  
  if(_fld != null )
    fld = _fld;
  else
    fld = 0;
  end;
end;

private class (TExecFunPIParm)TExecFunSaveChkPIParm( _prm:TExecFunSaveChkParm, _err:TArray, _func:variant, _Side:integer )
  var err/*:TArray*/ = _err;
  var prm:TExecFunSaveChkParm = _prm;
  var func:variant = _func;
  var Side:integer = _Side;
  var i:integer = 0; // Порядковый номер записи разноски
  InitTExecFunPIParm();
end;

private macro GetMsg(err:TError)
  return err.msg;
end;

private class TExecFunSaveChk( _prm:TExecFunSaveChkParm )

  var prm:TExecFunSaveChkParm = _prm;

  var ChkFun:TArray = TArray();
  var Errors:TArray = TArray();

  macro AddChk(Fun:variant)
    ChkFun[ChkFun.size] = Fun;
  end;

  macro ShowAllErrors()
    var AllError = join( map( Errors, @GetMsg ), ".|" );
    Bnk_ToRSTrace( "PmChkMac", "Error", AllError );
    msgbox(AllError);
  end;
  
  macro ShowWarning(msg:string)
    Array Text, Buttons;
    Bnk_ToRSTrace( "PmChkMac", "Warning", msg );
    Text(0) = msg;
    Buttons( 0 ) = "Cохранить";
    Buttons( 1 ) = "Продолжить редактирование";
    return IfThenElse(ConfWin( Text, Buttons ) == 0, NOTERROR, ERROR);
  end;

  macro Execute()
    if(ChkFun.size == 0)
      return NOTERROR;
    end;

    var i = 0;
    var Warnings = "";
    var WarningFld = 0;

    // Выполним все проверки
    while( i < ChkFun.size )
      Bnk_ToRSTrace( "PmChkMac", "Begin", ChkFun[i] );
      if(not ExecMacro( ChkFun[i], prm, Errors ))
        msgbox("Не найдена процедура в макросе pm_chksave.mac: " + ChkFun[i]);
        return ERROR;
      end;
      Bnk_ToRSTrace( "PmChkMac", "End", ChkFun[i] );
      i = i + 1;
    end;
  
    // Если есть хоть одна ERROR, то выводим список ошибок и отваливаем
    i = 0;
    while(i < Errors.size)
      if(Errors[i].stat == ERROR)
        ShowAllErrors();
        return Errors[i].fld + 1; // Увеличиваем на 1, так как реальная нумерация полей начинается с 0.
      end;
      i = i + 1;
    end;

    // Если нет ERROR, то показываем предупреждения и спрашиваем
    // как дальше жить
    i = 0;
    WarningFld = 0;
    while(i < Errors.size)
      if(Errors[i].stat == WARNING)
        Warnings = Warnings + "\n" + Errors[i].msg;
        WarningFld = i;
      end;
      i = i + 1;
    end;

    if( Warnings != "" )
      if( ShowWarning(Warnings) == ERROR )
        return Errors[WarningFld].fld + 1; // Увеличиваем на 1, так как реальная нумерация полей начинается с 0.
      end;
    end;

    return NOTERROR;
  end;

end;

// Определение платежей, выгруженных из бэк-офисов
private macro PaymentInBackOffice( prm:TExecFunSaveChkParm ):bool
             
  var obj = GetRsbPmDocument( prm.pm_paym.rec.paymentID, prm.pm_paym.rec.DocKind );
                                                  
  if( ( prm.pm_paym.rec.DocKind == PS_PAYORDER ) and InList( obj.Origin, PSPO_OR_LOANS, PSPO_OR_RETAIL, PSPO_OR_DEPOSIT ) )
    return true;
  end;                                          
                                                      
  if( InList( prm.pm_paym.rec.DocKind, PS_CPORDER, PS_INRQ, BBANK_CPORDER ) and 
      InList( obj.Origin, CP_FDOC_CRDHDP, CP_OR_ZP, CP_OR_LOANS, CP_OR_RETAIL, CP_OR_DEPOSIT, CP_OR_LOANS_5_50, CP_OR_RETAIL_5_50, CP_OR_MVODB_5_50 ) )
    return true;
  end;

  if( InList( prm.pm_paym.rec.DocKind, DLDOC_BANKPAYMENT, DLDOC_BANKCLAIM ) and
      InList( obj.Origin, MEMORDER_FDOC_ZP, MEMORDER_FDOC_CONTRACT, MEMORDER_FDOC_DP, MEMORDER_FDOC_LOANS, MEMORDER_FDOC_RETAIL, MEMORDER_FDOC_LOANS_5_50, MEMORDER_FDOC_RETAIL_5_50, MEMORDER_FDOC_MVODB_5_50 ) )
    return true;
  end;                                                           

  if( ( prm.pm_paym.rec.DocKind == DLDOC_BANKORDER ) and InList( obj.Origin, PD_OR_LOANS, PD_OR_RETAIL, PD_OR_INCOUNTING, PD_OR_DEPLEGPERS, PD_OR_LOANS_5_50, PD_OR_RETAIL_5_50, PD_OR_MVODB_5_50 ) )
    return true;
  end;
  
  return false;
end;

// 1. Наличие номера документа
private macro CheckNumber( prm:TExecFunSaveChkParm, err:TArray )
  // Номер документа должен быть задан
  if(prm.rm.rec.Number == "")
    err[err.size] = TError(ERROR, "Номер документа должен быть задан", prm.flds.Number);
  end;
end;

// 2. Допустимость номера документа для РКЦ
private macro CheckNumberForRKC( prm:TExecFunSaveChkParm, err:TArray )
  if( (prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL) and not prm.debet.rec.IsSender
      or
      (prm.credit.rec.Group == PAYMENTS_GROUP_EXTERNAL) and not prm.credit.rec.IsSender
    )
    if( IsPmPosPSBR(prm.debet, prm.credit) and
        ( int( GetLastSymbols(prm.rm.rec.Number, PM_DOCNO_NONZERO_LEN) ) == 0 ) 
      )
      err[err.size] = TError(ERROR, "Шесть последних разрядов номера должны быть отличны от '000000'", prm.flds.Number);
    end;
  end;
end;

// 3. Вид платежа 
private macro CheckPaymentType( prm:TExecFunSaveChkParm, err:TArray )
  
  var PermissiblePaymentKind:string = "";
  var errReg = 0;

  GetRegistryValue( "CB\\PAYMENTS\\ENABLEPAYWAYS", V_STRING, PermissiblePaymentKind, errReg );

  if( (errReg == 0) and (Index(PermissiblePaymentKind, prm.rm.rec.PaymentKind) == 0))
    err[err.size] = TError(ERROR, "Неверный тип платежа", prm.flds.PaymentKind);
  end;
end;

// 5. Наличие суммы платежа
private macro CheckBaseAmount( prm:TExecFunSaveChkParm, err:TArray )
  // Сумма платежа > 0
  if(prm.pm_paym.rec.BaseAmount <= $0)
    err[err.size] = TError(ERROR, "Сумма платежа должна быть больше нуля", prm.flds.BaseAmount);
  end;
end;

// 6. Валюта платежа
// Все три валюты заданы и имеются в справочнике финансовых инструментов
private macro CheckSaveFIID( prm:TExecFunSaveChkParm, err:TArray )
  if( (prm.PaymentObj.PIList(PRT_Debet).Size == 0) and (CheckFIID( prm.pm_paym.rec.FIID ) != 0) )
    err[err.size] = TError(ERROR, "Валюта плательщика должна быть задана", prm.flds.FIID);
  end;
  
  if( CheckFIID( prm.pm_paym.rec.BaseFIID ) != 0 )
    err[err.size] = TError(ERROR, "Базовая валюта платежа должна быть задана", prm.flds.BaseFIID);
  end;
  
  if( (prm.PaymentObj.PIList(PRT_Credit).Size == 0) and (CheckFIID( prm.pm_paym.rec.PayFIID ) != 0) )
    err[err.size] = TError(ERROR, "Валюта получателя должна быть задана", prm.flds.PayFIID);
  end;
end;

// 7. Курс валюты платежа
// Курс трёх валют платежа на дату значения может быть определен
private macro CheckSaveRate( prm:TExecFunSaveChkParm, err:TArray )
  
  if((prm.pm_paym.rec.FIID != ALLFININSTR) and (CheckRateForDate( prm.pm_paym.rec.FIID, prm.pm_paym.rec.ValueDate ) != 0))
    err[err.size] = TError(ERROR, "Не найден курс валюты плательщика");
  end;
  
  if( (prm.pm_paym.rec.BaseFIID != ALLFININSTR) and (CheckRateForDate( prm.pm_paym.rec.BaseFIID, prm.pm_paym.rec.ValueDate ) != 0) )
    err[err.size] = TError(ERROR, "Не найден курс базовой валюты платежа");
  end;
  
  if( (prm.pm_paym.rec.PayFIID != ALLFININSTR) and  (CheckRateForDate( prm.pm_paym.rec.PayFIID, prm.pm_paym.rec.ValueDate ) != 0) )
    err[err.size] = TError(ERROR,  "Не найден курс валюты получателя");
  end;

end;

// 8. Очередность 
// Очередность задана и находится в интервале от 0 до 6.
private macro CheckSavePriority( prm:TExecFunSaveChkParm, err:TArray )
  if( CheckPriority( prm.rm.rec.Priority, prm.pm_paym.rec.DocKind ) != 0 )
    err[err.size] = TError(ERROR, "Очередность должна находиться в интервале от 0 до " + PM_DefaultMaxPriority(), prm.flds.Priority);
  end;
end;

// 9. Номер пачки  
// Номер пачки не отрицательный
private macro CheckSaveNumberPack( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.pm_paym.rec.NumberPack < 0 )
    err[err.size] = TError(ERROR, "Номер пачки должен быть положительный либо равен 0", prm.flds.NumberPack);
  end;
end;

// 10. Дата документа
// Дата документа задана
private macro CheckSaveDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.rm.rec.Date == date(0,0,0) )
    err[err.size] = TError(ERROR, "Дата документа должна быть задана", prm.flds.rmDate);
  end;
end;

// 11. Дата платежа (pmrmprop.Date)
// Дата платежа <= дате опердня, в котором проводится операция.
private macro CheckSavePaymentDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.pm_paym.rec.ValueDate < prm.rm.rec.Date )
    err[err.size] = TError(ERROR, "Дата составления документа не может быть больше даты значения", prm.flds.rmDate);
  end;
end;

// 12. Дата значения (pmpaym.ValueDate)  
// Если настройка реестра CB\PAYMENTS\CheckValueDate имеет значение "Yes", 
// то в начальном филиале платежа есть операционный день, соответствующий дате значения 
private macro CheckSaveValueDate( prm:TExecFunSaveChkParm, err:TArray )
  if( needCheckValueDate() and
      not existsOperDay(prm.pm_paym.rec.ValueDate, prm.pm_paym.rec.StartDepartment) )
    err[err.size] = TError(ERROR, "Нет операционного дня с указанной датой значения", prm.flds.ValueDate);
  end;
end;

// 13. Документ не устарел
private macro CheckSaveOldDoc( prm:TExecFunSaveChkParm, err:TArray )
  var PoDocKind = 0;

  if( prm.pm_paym.rec.DocKind == PS_PAYORDER )
    PoDocKind = prm.pspayord.rec.DocKind;
  end;

  var OldDoc = GetRegValueOldDoc( prm.pm_paym.rec.DocKind, PoDocKind, ( prm.pm_paym.rec.FIID == NATCUR ) and ( prm.pm_paym.rec.PayFIID == NATCUR ) and ( prm.pm_paym.rec.BaseFIID == NATCUR ) );
  if(  (ValType(OldDoc) == V_INTEGER) and (OldDoc > 0) )
    if((prm.pm_paym.rec.PayerBankEnterDate - prm.rm.rec.Date) > OldDoc ) 
      err[err.size] = TError(ERROR, "Дата составления документа меньше даты поступления в банк плательщика более чем на " + OldDoc + " дней. Документ устарел и не может быть обработан", prm.flds.rmDate);
    end;
  end;
end;

// Дата поступления в банк плательщика
private macro CheckSavePayerBankEnterDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.pm_paym.rec.PayerBankEnterDate == date(0,0,0) )
    err[err.size] = TError(ERROR, "Не задана дата поступления в банк плательщика", prm.flds.PayerBankEnterDate);
  end;
  if( needCheckPayerBankEnterDate() and
      not existsOperDay(prm.pm_paym.rec.PayerBankEnterDate, prm.pm_paym.rec.StartDepartment) )
    err[err.size] = TError(ERROR, "Нет операционного дня с указанной датой поступления документа в банк плательщика", prm.flds.PayerBankEnterDate);
  end;
  if( prm.pm_paym.rec.ValueDate < prm.pm_paym.rec.PayerBankEnterDate )
    err[err.size] = TError(ERROR, "Дата поступления в банк плательщика не может быть больше даты значения", prm.flds.PayerBankEnterDate);
  end;
end;

// Дата поступления предъявленного требования
private macro CheckSavePayerBankEnterDateCLAIM( prm:TExecFunSaveChkParm, err:TArray )

  if( prm.pm_paym.rec.PayerBankEnterDate < prm.pm_paym.rec.ValueDate )
    err[err.size] = TError(ERROR, "Дата поступления в банк не может быть меньше даты его составления", prm.flds.PayerBankEnterDate);
  end;
end;

// Дата поступления выставленного требования
private macro CheckSaveReceiverBankMarkDateCLAIM( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.rm.rec.Date > prm.pm_paym.rec.ReceiverBankMarkDate )
    err[err.size] = TError(ERROR, "Дата поступления в банк получателя не может быть меньше даты составления документа", prm.flds.ReceiverBankMarkDate);
  end;
end;

private macro needCheckReceiverBankMarkDate()
  var err = 0;
  var CheckRecBankEnterDate = false;
  GetRegistryValue( "CB\\PAYMENTS\\CHECKRECBANKENTERDATE", V_BOOL, CheckRecBankEnterDate, err );
  return CheckRecBankEnterDate;
end;

// Дата поступления в банк получателя
private macro CheckSaveReceiverBankMarkDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.pm_paym.rec.ReceiverBankMarkDate == date(0,0,0) )
    err[err.size] = TError(ERROR, "Не задана дата поступления в банк получателя", prm.flds.ReceiverBankMarkDate);
  end;
  if( needCheckReceiverBankMarkDate() and
      not existsOperDay(prm.pm_paym.rec.ReceiverBankMarkDate, prm.pm_paym.rec.StartDepartment) )
    err[err.size] = TError(ERROR, "Нет операционного дня с указанной датой поступления документа в банк получателя", prm.flds.ReceiverBankMarkDate);
  end;
  if( prm.rm.rec.Date > prm.pm_paym.rec.ReceiverBankMarkDate )
    err[err.size] = TError(ERROR, "Дата поступления в банк получателя не может быть меньше даты составления документа", prm.flds.ReceiverBankMarkDate);
  end;
end;

// Документ, предъявленный в банк получателя, не устарел
private macro CheckReceiverBankMarkDateNoOld( prm:TExecFunSaveChkParm, err:TArray )
 var OldDoc = GetRegValueOldDoc( prm.pm_paym.rec.DocKind, NULL, ( prm.pm_paym.rec.FIID == NATCUR ) and ( prm.pm_paym.rec.PayFIID == NATCUR ) and ( prm.pm_paym.rec.BaseFIID == NATCUR ) );
  if( (ValType(OldDoc) == V_INTEGER) and (OldDoc > 0) and ((prm.pm_paym.rec.ReceiverBankMarkDate - prm.rm.rec.Date) > OldDoc ) )
    err[err.size] = TError(ERROR,  "Дата составления документа меньше даты поступления в банк получателя более чем на " + OldDoc + " дней. Документ устарел и не может быть обработан");
  end;
end;

// Есть баланс в дату значения
private macro CheckSaveValueDateIsBalance( prm:TExecFunSaveChkParm, err:TArray )
  var ServiceKind, Balance;
  if( not GetDateAttr( prm.pm_paym.rec.ValueDate, ServiceKind, Balance, prm.pm_paym.rec.Department ) )
    if( Balance == CALENDAR_BALANCE_NO )
      err[err.size] = TError(ERROR, "Невозможно исполнение платежа указанной датой значения", prm.flds.ValueDate);
    end;
  else
    err[err.size] = TError(ERROR, "В календаре не найдена указанная дата значения", prm.flds.ValueDate);
  end;
end;

// ДПП
private macro CheckSaveTransferDate( prm:TExecFunSaveChkParm, err:TArray )
  var pmprop : TRecHandler = TRecHandler("pmprop.dbt");
  if( not prm.debet.rec.IsSender and (prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL) )
    Copy(pmprop, prm.debet);
  elif( not prm.credit.rec.IsSender and (prm.credit.rec.Group == PAYMENTS_GROUP_EXTERNAL) )
    Copy(pmprop, prm.credit);
  else
    return;
  end;

  if( pmprop.rec.TransferDate == date(0,0,0) )
    err[err.size] = TError(ERROR, "Не задана исходящая ДПП", prm.flds.TransferDate);
  end;

  if( pmprop.rec.TransferDate < prm.pm_paym.rec.ValueDate )
    err[err.size] = TError(ERROR, "Исходящая ДПП не может быть меньше даты значения", prm.flds.TransferDate);
  end;
  
end;

// Банк плательщика

// Код банка плательщика задан, банк существует в справочнике банков и открыт
private macro CheckSavePayerBankCodeExistsOpen( prm:TExecFunSaveChkParm, err:TArray )
  
  var bankdprt:TRecHandler = prm.GetPayerBankDprt();
  
  if ( prm.debet.rec.CodeKind <= 0 ) 
    err[err.size] = TError(ERROR, "Вид кода банка плательщика не может быть равен " + prm.debet.rec.CodeKind, prm.flds.PayerBankCodeKind);
  end;
  
  if( strlen(prm.debet.rec.BankCode) <= 0 )
    err[err.size] = TError(ERROR, "Не задан код банка плательщика", prm.flds.PayerBankCode);
  end;

  if( bankdprt == null )
    err[err.size] = TError(ERROR, "Не найден банк плательщика в справочнике банков", prm.flds.PayerBankCode);
  else
    if( bankdprt.rec.Lock == "X" )
      err[err.size] = TError(ERROR, "Отделение банка плательщика закрыто", prm.flds.PayerBankCode);
    end;
  end;

end;

private macro CheckSavePayerBankED107( prm:TExecFunSaveChkParm, err:TArray )
  // Код банка плательщика задан, банк существует в справочнике банков и открыт
  CheckSavePayerBankCodeExistsOpen(prm, err);
end;

private macro CheckSavePayerBankPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtIsPartPSBR
    ( prm.pm_paym.rec.PayerBankID, 
      "Банк плательщика", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSavePayerBankRestrictPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtRestrictPartPSBR
    ( prm.pm_paym.rec.PayerBankID, 
      "банка плательщика", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSavePayerBankCorrectPZN( prm:TExecFunSaveChkParm, err:TArray )

  var query = 
    "SELECT dp_dep.t_PartyID FROM ddp_dep_dbt dp_dep " +
    "  INNER JOIN dcorschem_dbt corschem ON dp_dep.t_code = corschem.t_department " +
    "  WHERE corschem.t_number = :Corschem AND corschem.t_FIID = :PayFIID";
    
  var params = makeArray( SQLParam( "Corschem", IfThenElse(prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL, prm.debet.rec.Corschem, prm.credit.rec.Corschem ) ),
                          SQLParam( "PayFIID", IfThenElse(prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL, prm.debet.rec.PayFIID, prm.credit.rec.PayFIID ) ) );
                              
  var rs = execSQLselect( query, params );

  if( rs and rs.moveNext() )
    var Msg : string = "";
    var stat : integer = CheckPtIsCorrectPZN
      ( rs.value(0),
        "банка плательщика", 
        @Msg
      );

    if(Msg)
      err[err.size] = TError( ERROR, Msg );
    end;
  end;
end;


private macro CheckSavePayerBank( prm:TExecFunSaveChkParm, err:TArray )
  
  // Код банка плательщика задан, банк существует в справочнике банков и открыт
  CheckSavePayerBankCodeExistsOpen(prm, err);

  if( IsPmPosPSBR(prm.debet, prm.credit) )
    CheckSavePayerBankPartInPSBR(prm, err);
    CheckSavePayerBankRestrictPartInPSBR(prm, err);
    CheckSavePayerBankCorrectPZN(prm, err);
  end;

end;

// БИК банка плательщика
private macro CheckSavePayerBankBIC( prm:TExecFunSaveChkParm, err:TArray )

  var bic = ПолучитьКодСубъекта( prm.pm_paym.rec.PayerBankID, PTCK_BIC, 1 );
  if( strlen(bic) <= 0 )
    err[err.size] = TError(ERROR, "Не найден БИК банка плательщика", prm.flds.PayerBankCode);
  end;

end;


// Наличие корсчета банка плательщика
private macro CheckSavePayerBankCorrAcc( prm:TExecFunSaveChkParm, err:TArray )

  var bankdprt:TRecHandler = prm.GetPayerBankDprt();
  if( bankdprt != null )
    if( bankdprt.rec.UERType != PT_KIND_PAYM_CASH_CENTRE )
      if( strlen( prm.rm.rec.PayerCorrAccNostro ) == 0 )
        err[err.size] = TError(ERROR, "Не задан корсчет банка плательщика", prm.flds.PayerCorrAccNostro);
      end;

      if( AccountIsMask( prm.rm.rec.PayerCorrAccNostro ) )
        err[err.size] = TError(ERROR, "Корсчет банка плательщика задан маской", prm.flds.PayerCorrAccNostro);
      end;
    elif( strlen( prm.rm.rec.PayerCorrAccNostro ) != 0 )
      err[err.size] = TError(ERROR, "Банк плательщика является УБР. Корсчет должен быть не задан.", prm.flds.PayerCorrAccNostro);
    end;
  end;
end;

// Допустимость корсчета банка плательщика
private macro CheckSavePermissibilityPayerBankCorrAcc( prm:TExecFunSaveChkParm, err:TArray )
  var bankdprt:TRecHandler = prm.GetPayerBankDprt();

  if( bankdprt != null and prm.rm and prm.pm_paym and prm.credit )
    if( (prm.debet.rec.codekind == PTCK_BIC) and (strlen( prm.rm.rec.PayerCorrAccNostro ) != 0) )
        // В проверке написано: в соответствии с правилами ключевания в РКЦ банка (bankdprt.CheckAlg). - Но возможность указать этот параметр из rsl я не нашел, поэтому пока так
        var AccKey = GetKey( prm.rm.rec.PayerCorrAccNostro, GetBankDprtCheckData( bankdprt.rec.BIC_RCC ) );
        if( AccKey != prm.rm.rec.PayerCorrAccNostro )
          err[err.size] = TError(ERROR, "Неверный ключ у корсчета банка плательщика. Должен быть " + SubStr(AccKey, 9, 1), prm.flds.PayerCorrAccNostro );
        end;
    end;
  end;     
end;


// Текущая дата документа
private macro CheckSaveCurrentDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.rm.rec.Date != prm.pm_paym.rec.ValueDate )
    err[err.size] = TError(ERROR, "Дата документа должна быть равна дате значения", prm.flds.rmDate);
  end;
end;

//-------------------------------------------------
// Утилитные функции для проверки счетов
//-------------------------------------------------
// Подкачка буферов счетов
private macro PumpAccount(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  
  var Account_buf:TRecHandler = TRecHandler("account.dbt");

  if((AccStr == "") or AccountIsMask( AccStr ))
    Account_buf = null;
  else
    if(pi != null)
      if(not PM_GetAccountRecord( pi.rec.Account, pi.rec.FIID, pi.rec.Chapter, Account_buf ))
        Account_buf = null;
      end;
    elif(not PM_GetAccountRecord( AccStr, IfThenElse(Side == PRT_Debet, prm.pm_paym.rec.FIID, prm.pm_paym.rec.PayFIID), prm.pm_paym.rec.Chapter, Account_buf ))
      Account_buf = null;
    end;
  end;

  if(pi != null)
    prm.PIAccounts[prm.PIAccounts.size] = Account_buf;
  elif(Side == PRT_Debet)
    prm.PayerAccount = Account_buf;
  elif(Side == PRT_Credit)
    prm.ReceiverAccount = Account_buf;
  end;
end;

macro pmchksave_CheckSavePIAccounts( piprm:TExecFunSaveChkPIParm )
  if(piprm.prm.PIAccounts.size > piprm.i)
    if(not ExecMacro(piprm.func, piprm.prm, piprm.i, piprm.Side, piprm.pi.rec.Account, piprm.prm.PIAccounts[piprm.i], piprm.pi, piprm.err))
      msgbox("Не найдена процедура в макросе pm_chksave.mac: " + piprm.func);
      return ERROR;
    end;
  else
    if(not ExecMacro(piprm.func, piprm.prm, piprm.i, piprm.Side, piprm.pi.rec.Account, null, piprm.pi, piprm.err))
      msgbox("Не найдена процедура в макросе pm_chksave.mac: " + piprm.func);
      return ERROR;
    end;
  end;
  piprm.i = piprm.i + 1;
  return NOTERROR;
end;

private macro GetNameAccFromErr(Side:integer, pi:TRecHandler)
  
  if(pi == null)
    if(Side == PRT_Debet)
      return "Счет плательщика ";
    else
      return "Счет получателя ";
    end;
  else
    if(pi.rec.Account == "")
      return "Счет разноски: ";
    else
      return "Счет разноски " + pi.rec.Account + ": ";
    end;
  end;

end;

// check_future - проверку выполнять для текущего счета дебета
private macro CheckSavePayerAccount( prm:TExecFunSaveChkParm, err:TArray, func:variant, check_future:bool )
  
  if(prm.PaymentObj.PIList(PRT_Debet).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Debet, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, err, func, PRT_Debet ));
  else
    var AccStr = "",
        AccRec : TRecHandler = TRecHandler("account.dbt");
    if(check_future)
      AccStr = prm.pm_paym.rec.FuturePayerAccount;
      if(not PM_GetAccountRecord( AccStr, prm.pm_paym.rec.FIID_FuturePayAcc, prm.pm_paym.rec.Chapter, AccRec ))
        AccRec = null;
      end;
    else
      AccStr = prm.pm_paym.rec.PayerAccount;
      AccRec = prm.PayerAccount;
    end;
    ExecMacro2(func, prm, 0, PRT_Debet, AccStr, AccRec, null, err);
  end;

end;

// check_future - проверку выполнять для текущего счета кредита
private macro CheckSaveReceiverAccount( prm:TExecFunSaveChkParm, err:TArray, func:variant, check_future:bool )
  
  if(prm.PaymentObj.PIList(PRT_Credit).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Credit, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, err, func, PRT_Credit ));
  else
    var AccStr = "",
        AccRec : TRecHandler = TRecHandler("account.dbt");
    if(check_future)
      AccStr = prm.pm_paym.rec.FutureReceiverAccount;
      if(not PM_GetAccountRecord( AccStr, prm.pm_paym.rec.FIID_FutureRecAcc, prm.pm_paym.rec.Chapter, AccRec ))
        AccRec = null;
      end;
    else
      AccStr = prm.pm_paym.rec.ReceiverAccount;
      AccRec = prm.ReceiverAccount;
    end;
    ExecMacro2(func, prm, 0, PRT_Credit, AccStr, AccRec, null, err);
  end;

end;

// Наличие счета
// Счет задан 
private macro CheckSaveAccountSetComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  
  if(AccStr == "")
    err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "должен быть задан", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  end;

end;

// Наличие счета плательщика 
// Счет плательщика задан 
private macro CheckSavePayerAccountSet( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountSetComm" );
end;


// 20. Допустимость счета плательщика
private macro CheckSavePayerAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  /*
  if((AccStr != "") and (prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL))
    if(Account == null)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    elif((Account.rec.Open_Close == "З") and (Account.rec.Close_Date <= prm.pm_paym.rec.ValueDate))
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "закрыт с " + Account.rec.Close_Date, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
  */


  if((AccStr != "") and (prm.debet.rec.CodeKind == PTCK_BIC) and (IsResident(prm.pm_paym.rec.PayerBankID)))
    var AccKey = GetKey( AccStr, prm.debet.rec.BankCode );

  if( AccKey != AccStr )
    err[err.size] = TError(ERROR, "В номере счета " + AccStr + " неверно значение ключа. Должно быть  " + AccKey );
  end;

/*  
    if( AccKey != AccStr )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "неверный ключ. Должен быть " + SubStr(AccKey, 9, 1), IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
*/
  end;
end;

private macro CheckSavePayerAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSavePayerAccountOkComm" );
end;

// проверка соответствия формату 302-П ЦБ РФ    
private macro CheckSaveAccountIs302P( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )
  var Resident = false;  

  if( Side == PRT_Debet )
    Resident = IsResident(prm.pm_paym.rec.PayerBankID);
  elif( Side == PRT_Credit )
    Resident = IsResident(prm.pm_paym.rec.ReceiverBankID);
  end;
  
  if( ( AccStr != "" ) and ( Resident == true ) )
    if( IsNotFormat302P( AccStr ) )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не соответствует действующим правилам ЦБ РФ обозначения лицевых счетов", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

//Счет плательщика соответствует формату 302-П ЦБ РФ
private macro CheckSavePayerAccountIs302P( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountIs302P" );
end;

//Счет плательщика не является маской
private macro CheckSaveAccountIsMask( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )

  if(AccStr != "")
    if( AccountIsMask( AccStr ) )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не может быть маской", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSavePayerAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountIsMask" );
end;

// 21. Разрешение операции по счету плательщика
private macro CheckSavePayerAccountOprComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)

  // Проверку выполняем, только если банк плательщика входит в ЦАБС (группа платежа <> "внешний") 
  // и счет плательщика есть в нашей базе
  if( (prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL) or (Account == null) )
    return;
  end;

  if( (prm.pm_paym.rec.DocKind != PS_INRQ) and 
        (Account.rec.Open_Close == "З")      and 
        (Account.rec.Close_Date <= IfThenElse( EditFromHistScrol , {curdate}, prm.rm.rec.Date))
      )
    err[err.size] = TError(WARNING, GetNameAccFromErr(Side, pi) + "закрыт с " + Account.rec.Close_Date, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  end;
  
  if(Index(Account.rec.Type_Account, "Т"))
    err[err.size] = TError(WARNING, GetNameAccFromErr(Side, pi) + "запрещена операция дебета", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  elif(prm.pm_paym.rec.ValueDate <= Account.rec.DateNoChange)
    err[err.size] = TError(WARNING, GetNameAccFromErr(Side, pi) + "наложен запрет проводок до " + Account.rec.DateNoChange, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  end;
end;

private macro CheckSavePayerAccountOpr( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSavePayerAccountOprComm" );
end;

// Наличие наименования плательщика
private macro CheckSavePayerNameSet( prm:TExecFunSaveChkParm, err:TArray )
  if((prm.PaymentObj.PIList(PRT_Debet).Size == 0) and (prm.rm.rec.PayerName == ""))
    err[err.size] = TError(ERROR, "Наименование плательщика должно быть задано", prm.flds.PayerName);
  end;
end;

// Допустимость наименования плательщика
private macro CheckSavePayerNameOk( prm:TExecFunSaveChkParm, err:TArray )

  var CheckNameOption = PM_GetCheckNameOption();
  if( (InList( CheckNameOption, PM_CNO_PR_CHECK, PM_CNO_P_CHECK)) and  
       not PaymentInBackOffice(prm)  and
      // платеж не был выгружен из любого бэк-офиса RS-Bank (см. проект 463, п. Определение платежей, выгруженных из бэк-офисов),  and
      (PM_IsBankInTS(prm.pm_paym.rec.PayerBankID, true)) 
    ) 
    var NameWarning = prm.PaymentObj.Notes.ReadNote(NOTEKIND_PAYM_NAMEWARNING, {curdate});
    var errMsg = "";
    var res: integer = ПроверитьДопустимостьНаименования( prm.pm_paym.rec.Payer, 
                                                          prm.rm.rec.PayerName, 
                                                          prm.rm.rec.PayerINN,
                                                          prm.pm_paym.rec.PayerAccount,
                                                          prm.pm_paym.rec.FIID);
    if( res == PAYMERR_CHECKNAMNEWRONGINN )
      errMsg = "ИНН плательщика не совпадает с имеющимися в справочнике. "
    elif( res == PAYMERR_CHECKNAMNEWRONGNAME )
      errMsg = "Наименование плательщика не совпадает с имеющимися в справочнике. "
    end;

    if ( errMsg != "" )
      err[err.size] = TError(WARNING, errMsg, prm.flds.PayerName);
      InitError();
      NameWarning = NameWarning + errMsg;
      prm.PaymentObj.Notes.AddNote(NOTEKIND_PAYM_NAMEWARNING, NameWarning);
    end;
  end;
end;

// Банк получателя

private macro CheckSaveReceiverBankPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtIsPartPSBR
    ( prm.pm_paym.rec.ReceiverBankID, 
      "Банк получателя", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSaveReceiverBankRestrictPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtRestrictPartPSBR
    ( prm.pm_paym.rec.ReceiverBankID, 
      "банка получателя", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSaveReceiverBankCorrectPZN( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtIsCorrectPZN
    ( prm.pm_paym.rec.ReceiverBankID, 
      "банка получателя", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( ERROR, Msg );
  end;
end;

private macro CheckSaveReceiverBank( prm:TExecFunSaveChkParm, err:TArray )
  // TODO Если документ является инкассовым поручением (pspayord.DocKind = PSPOKIND_REQUEST) - это пока не проверяем, так как в клиентских платежах на данный момент проверка не отрабатывает

  var bankdprt:TRecHandler = prm.GetReceiverBankDprt();

  if ( prm.credit.rec.CodeKind <= 0 ) 
    err[err.size] = TError(ERROR, "Вид кода банка получателя не может быть равен " + prm.credit.rec.CodeKind, prm.flds.ReceiverBankCodeKind);
  end;

  if( strlen(prm.credit.rec.BankCode) <= 0 )
    err[err.size] = TError(ERROR, "Не задан кода банка получателя", prm.flds.ReceiverBankCode);
  end;

  if((prm.credit.rec.CodeKind > 0) and (strlen(prm.credit.rec.BankCode) > 0))
    if( not Bnk_IsExistsPartyCode( prm.pm_paym.rec.ReceiverBankID, prm.credit.rec.CodeKind, prm.credit.rec.BankCode, prm.pm_paym.rec.DocKind == PS_INRQ ))
      err[err.size] = TError(ERROR, "Не найден код банка получателя", prm.flds.ReceiverBankCode);
    end;
  end;

  if( bankdprt == null )
    err[err.size] = TError(ERROR, "Не найден банк получателя в справочнике банков", prm.flds.ReceiverBankCode);
  else
    if( bankdprt.rec.Lock == "X" )
      err[err.size] = TError(ERROR, "Отделение банка получателя закрыто", prm.flds.ReceiverBankCode);
    end;
  end;

  if( IsPmPosPSBR(prm.debet, prm.credit) )
    CheckSaveReceiverBankPartInPSBR(prm, err);
    CheckSaveReceiverBankRestrictPartInPSBR(prm, err);
    CheckSaveReceiverBankCorrectPZN(prm, err);
  end;
end;


// БИК банка получателя
private macro CheckSaveReceiverBankBIC( prm:TExecFunSaveChkParm, err:TArray )

  var bic = ПолучитьКодСубъекта( prm.pm_paym.rec.ReceiverBankID, PTCK_BIC, 1 );
  if( strlen(bic) <= 0 )
    err[err.size] = TError(ERROR, "Не найден БИК банка получателя", prm.flds.ReceiverBankCode);
  end;

end;

// Наличие корсчета банка получателя
private macro CheckSaveReceiverBankCorrAcc( prm:TExecFunSaveChkParm, err:TArray )
  
  var bankdprt:TRecHandler = prm.GetReceiverBankDprt();
  
  if( bankdprt != null )
    if( bankdprt.rec.UERType != PT_KIND_PAYM_CASH_CENTRE )
      if( strlen( prm.rm.rec.ReceiverCorrAccNostro ) == 0 )
        err[err.size] = TError(ERROR, "Не задан корсчет банка получателя", prm.flds.ReceiverCorrAccNostro);
      end;

      if( AccountIsMask( prm.rm.rec.ReceiverCorrAccNostro ) )
        err[err.size] = TError(ERROR, "Корсчет банка получателя задан маской", prm.flds.ReceiverCorrAccNostro);
      end;
    elif( strlen( prm.rm.rec.ReceiverCorrAccNostro ) != 0 )
      err[err.size] = TError(ERROR, "Банк получателя является УБР. Корсчет должен быть не задан.", prm.flds.ReceiverCorrAccNostro);
    end;
  end;
end;

// Допустимость корсчета банка получателя
private macro CheckSavePermissibilityRecBankCorrAcc( prm:TExecFunSaveChkParm, err:TArray )
  var bankdprt:TRecHandler = prm.GetReceiverBankDprt;  
  if( bankdprt != null and prm.rm and prm.pm_paym and prm.credit )
    if( (strlen( prm.rm.rec.ReceiverCorrAccNostro ) != 0) and (IsResident(prm.pm_paym.rec.ReceiverBankID)) and (prm.credit.rec.CodeKind == PTCK_BIC) )
        // В проверке написано: в соответствии с правилами ключевания в РКЦ банка (bankdprt.CheckAlg). - Но возможность указать этот параметр из rsl я не нашел, поэтому пока так
        var AccKey = GetKey( prm.rm.rec.ReceiverCorrAccNostro, GetBankDprtCheckData( bankdprt.rec.BIC_RCC ) );
        if( AccKey != prm.rm.rec.ReceiverCorrAccNostro )
          err[err.size] = TError(ERROR, "Неверный ключ у корсчета банка получателя. Должен быть " + SubStr(AccKey, 9, 1), prm.flds.ReceiverCorrAccNostro );
        end;
    end;
  end;   
end;


// Наличие счета получателя
private macro CheckSaveReceiverAccountIsSet(prm:TExecFunSaveChkParm, err:TArray)
  if( prm.pm_paym.rec.ReceiverAccount == "" )
    err[err.size] = TError(ERROR, "Не задан счет получателя", prm.flds.ReceiverAccount );
  end;
end;

//Счет получателя соответствует формату 302-П ЦБ РФ   
private macro CheckSaveReceiverAccountIs302P( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountIs302P" );
end;

//Счет получателя не является маской
private macro CheckSaveReceiverAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountIsMask" );
end;

// Допустимость счета получателя
private macro CheckSaveReceiverAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)

  if( (AccStr != "") and (not PM_AllowUnknownReceiverAccount(prm.pm_paym)) and (prm.credit.rec.CodeKind == PTCK_BIC) and (IsResident(prm.pm_paym.rec.ReceiverBankID)))
  
    var AccKey = GetKey( AccStr, prm.credit.rec.BankCode );
      
    if( AccKey != AccStr )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "неверный ключ. Должен быть " + SubStr(AccKey, 9, 1), IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;

  end;
end;

private macro CheckSaveReceiverAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveReceiverAccountOkComm" );
end;


// Разрешение зачисления на счет получателя
private macro CheckSaveReceiverAccountOprComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if( (Account != null) and (not PM_AllowUnknownReceiverAccount(prm.pm_paym)) )
    if(Index(Account.rec.Type_Account, "У"))
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "запрещена операция кредита", IfThenElse(pi == NULL, prm.flds.ReceiverAccount, 0));
    elif(prm.pm_paym.rec.ValueDate <= Account.rec.DateNoChange)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "наложен запрет проводок до " + Account.rec.DateNoChange, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSaveReceiverAccountOpr( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveReceiverAccountOprComm" );
end;

// Наличие наименования получателя
private macro CheckSaveReceiverNameSet( prm:TExecFunSaveChkParm, err:TArray )
  if(prm.rm.rec.ReceiverName == "")
    err[err.size] = TError(ERROR, "Наименование получателя должно быть задано", prm.flds.ReceiverName);
  end;
end;


// Допустимость наименования получателя
private macro CheckSaveReceiverNameOk( prm:TExecFunSaveChkParm, err:TArray )

  var CheckNameOption = PM_GetCheckNameOption();
  if( (InList( CheckNameOption, PM_CNO_PR_CHECK, PM_CNO_R_CHECK)) and   
       not PaymentInBackOffice(prm)  and
      // платеж не был выгружен из любого бэк-офиса RS-Bank (см. проект 463, п. Определение платежей, выгруженных из бэк-офисов),  and
      (PM_IsBankInTS(prm.pm_paym.rec.ReceiverBankID, true) ) 
    )
    var NameWarning = prm.PaymentObj.Notes.ReadNote(NOTEKIND_PAYM_NAMEWARNING, {curdate});
    var errMsg = "";
    var res: integer = ПроверитьДопустимостьНаименования( prm.pm_paym.rec.Receiver, 
                                                          prm.rm.rec.ReceiverName, 
                                                          prm.rm.rec.ReceiverINN,
                                                          prm.pm_paym.rec.ReceiverAccount,
                                                          prm.pm_paym.rec.PayFIID);
    if( res == PAYMERR_CHECKNAMNEWRONGINN )
      errMsg = "ИНН получателя не совпадает с имеющимися в справочнике. "
    elif( res == PAYMERR_CHECKNAMNEWRONGNAME )
      errMsg = "Наименование получателя не совпадает с имеющимися в справочнике. "
    end;

    if( errMsg != "" )
      err[err.size] = TError(WARNING, errMsg, prm.flds.ReceiverName);
      NameWarning = NameWarning + errMsg;
      prm.PaymentObj.Notes.AddNote(NOTEKIND_PAYM_NAMEWARNING, NameWarning);
    end;
  end;
end;

// Наличие назначения платежа
private macro CheckSaveGround( prm:TExecFunSaveChkParm, err:TArray )
  if(prm.rm.rec.Ground == "")
    err[err.size] = TError(ERROR, "Назначение платежа должно быть задано", prm.flds.Ground);
  end;
end;

// Счет плательщика не корреспондентский
private macro CheckSavePayerAccountIsNotCorAcc( prm:TExecFunSaveChkParm, err:TArray )

  if( (prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL) and not IsChildTranzitOriginByRec( prm.pm_paym ) and (prm.PayerAccount != null) and ( prm.pm_paym.rec.PrimDocOrigin != PD_OR_PARTAT ) )
    if( Index(prm.PayerAccount.rec.Type_Account, "К"))
       err[err.size] = TError(ERROR,"Счет плательщика не должен быть корреспондентским", prm.flds.PayerAccount);
    end;
  end;
end;

private macro CheckSaveAccountMFRComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if( (Account != null) and PM_AccountIsMFR( Account.rec.Account, Account.rec.Chapter, Account.rec.Code_Currency) )
    err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не должен быть счетом МФР", IfThenElse(pi == NULL, IfThenElse(Side == PRT_Credit, prm.flds.ReceiverAccount, prm.flds.PayerAccount), 0));
  end;
end;

// Счет плательщика не счет МФР
private macro CheckSavePayerAccountMFR( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountMFRComm" );
end;

// Счет получателя не счет МФР
private macro CheckSaveReceiverAccountMFR( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountMFRComm" );
end;


// Наличие счета получателя или разноски по кредиту
// (Счет получателя задан и не является маской) или существует разноска по кредиту у платежа
private macro CheckSaveReceiverAccountOrAddPiSet( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountSetComm" );
end;

// 44. Проверка наличия счета получателя для платежа с разноской по дебету
private macro CheckSaveReceiverAccountWithAddPI( prm:TExecFunSaveChkParm, err:TArray )
  if((prm.PaymentObj.PIList(PRT_Debet).Size > 0) and (prm.pm_paym.rec.ReceiverAccount == ""))
    err[err.size] = TError(ERROR, "Платеж с разноской по дебету, не может быть обработан без счета получателя", prm.flds.ReceiverAccount);
  end;
end;

// Проверка номера IBAN плательщика
private macro CheckSavePayerIBAN( prm:TExecFunSaveChkParm, err:TArray )
  // TODO Должно быть сделано по 161999
end;

// Проверка номера IBAN получателя
private macro CheckSaveReceiverIBAN( prm:TExecFunSaveChkParm, err:TArray )
  // TODO Должно быть сделано по 161999
end;

private macro isPayingAgent( PartyID ):bool
  var count: integer = 0; 
  var select = " select count(1)" +  
               " from dpartyown_dbt" +  
               " where t_PartyID = :PartyID" + 
               "  and  ( t_PartyKind = :PTK_PAYING_AGENT " +          // Платежный агент
                    " or t_PartyKind = :PTK_BANK_PAYING_AGENT " +     // Банковский платежный агент
                    " or t_PartyKind = :PTK_BANK_PAYING_SUBAGENT ) "  // Банковский платежный субагент 
               ;
  var params = makeArray( SQLParam( "PartyID", PartyID ),
                          SQLParam( "PTK_PAYING_AGENT", PTK_PAYING_AGENT ),
                          SQLParam( "PTK_BANK_PAYING_AGENT", PTK_BANK_PAYING_AGENT ),
                          SQLParam( "PTK_BANK_PAYING_SUBAGENT", PTK_BANK_PAYING_SUBAGENT )
                        );

  var rs = execSQLselect( select, params );

  if( rs and rs.moveNext() )
    count = int( rs.value(0) );
  end;

  if( count > 0 )
    return true;
  end;

  return false;
end;

/**
 * 53. Допустимость списания со счета плательщика (ограничение операций по спец. банковским счетам)
 */

private macro _AllReceiverAccountsAreClient_One( overallResult:bool, acc:TRecHandler ):bool
  return overallResult and ( not PM_IsBankAccount( acc.rec.Account, acc.rec.Code_Currency, acc.rec.Chapter ) );
end;

private macro _CheckAllReceiverAccountsAreClient( prm:TExecFunSaveChkParm ):bool
  if( not prm.PaymentObj.PIList( PRT_Credit ).size )
    return ( not PM_IsBankAccount( prm.pm_paym.rec.ReceiverAccount, prm.pm_paym.rec.PayFIID, prm.pm_paym.rec.Chapter ) );
  else
    return reduce( prm.PIAccounts, @_AllReceiverAccountsAreClient_One, true );
  end;
end;

private macro CheckSaveSpecialPayerAccount_One( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )
  if( ( Account != null ) and ( Index( Account.rec.Type_Account, "Я" ) ) and ( isPayingAgent( Account.rec.Client ) ) )
    if( InList( prm.pm_paym.rec.DocKind, CASH_PS_OUTORDER, CASH_BOF_OUTORDER, DLDOC_INOUTORDER) )
      err[err.size] = TError( WARNING, "Счет " + AccStr + " является специальным банковским счетом платежного агента (субагента).|Расходные кассовые операции по специальным банковским счетам платежных агентов не допускаются.", prm.flds.PayerAccount );
    elif( not _CheckAllReceiverAccountsAreClient( prm ) )
      err[err.size] = TError( WARNING, "Счет " + AccStr + " является специальным банковским счетом платежного агента (субагента).|Списание средств с таких счетов на счета, принадлежащие банку, не допускается.", prm.flds.PayerAccount );
    end;
  end;
end;

private macro CheckSaveSpecialPayerAccount( prm:TExecFunSaveChkParm, err:TArray )
  var Account_buf:TRecHandler = TRecHandler("account.dbt");
  if( ( prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL ) and ( PM_GetAccountRecord( prm.pm_paym.rec.PayerAccount, prm.pm_paym.rec.FIID, prm.pm_paym.rec.Chapter, Account_buf ) ) )
    CheckSavePayerAccount( prm, err, "CheckSaveSpecialPayerAccount_One" );
  end;
end;

/**
 * 54. Допустимость зачисления на счет получателя (ограничение операций по спец. банковским счетам)
 */

private macro _AllPayerAccountsAreSpecial_One( overallResult:bool, acc:TRecHandler ):bool
  return overallResult and ( ( Index( acc.rec.Type_Account, "Я" ) > 0 ) and ( isPayingAgent( acc.rec.Client ) ) );
end;

private macro _CheckAllPayerAccountsAreSpecial( prm:TExecFunSaveChkParm ):bool
  if( not prm.PaymentObj.PIList( PRT_Debet ).size )
    if( prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL )
      return ( ( Index( prm.PayerAccount.rec.Type_Account, "Я" ) > 0 ) and ( isPayingAgent( prm.PayerAccount.rec.Client ) ) );
    else
      return PM_ExternalAccountIsSpecial( prm.pm_paym.rec.PayerAccount );
    end;
  else
    return reduce( prm.PIAccounts, @_AllPayerAccountsAreSpecial_One, true );
  end;
end;

private macro CheckSaveSpecialReceiverAccount_One( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )
  if( ( Account != null ) and ( Index( Account.rec.Type_Account, "Я" ) ) and ( isPayingAgent( Account.rec.Client ) ) )
    /* Все счета по дебету тоже должны быть спецбанковскими */
    if( not _CheckAllPayerAccountsAreSpecial( prm ) )
      err[err.size] = TError( WARNING, "Счет получателя " + AccStr + " является специальным банковским платежного агента (субагента).|Допускается зачисление на средств на такой счет только с другого специального банковского счета платежного агента.", prm.flds.ReceiverAccount );
    end;
  end;
end;

private macro CheckSaveSpecialReceiverAccount( prm:TExecFunSaveChkParm, err:TArray )
  var BackOfficeList = GetAllBackOfficesFromReg();
  if( ( prm.credit.rec.Group == PAYMENTS_GROUP_INTERNAL ) and ( not isBackOfficeAccount( prm.pm_paym.rec.PayerAccount, BackOfficeList ) ) )
    CheckSaveReceiverAccount( prm, err, "CheckSaveSpecialReceiverAccount_One" );
  end;
end;


// 55. Допустимость текущего счета дебета
private macro CheckSaveFuturePayerAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if(AccStr != "")
    if(Account == null)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден");
    end;
  end;
end;

private macro CheckSaveFuturePayerAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveFuturePayerAccountOkComm", true );
end;

// 56. Допустимость текущего счета кредита
private macro CheckSaveFutureReceiverAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if(AccStr != "")
    if(Account == null)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден");
    end;
  end;
end;

private macro CheckSaveFutureReceiverAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveFutureReceiverAccountOkComm", true );
end;

// Проверка длины реквизитов
private macro CheckSave383PLength( prm:TExecFunSaveChkParm, err:TArray )

  // Утилитные функции
  macro initLen(Field: string, Len: integer, Name: string)
    var a= TArray(false, 3, 3);
    a[0] = Field;
    a[1] = Len;
    a[2] = Name;
    return a;
  end;

  macro extractINN(InnKpp)
    var i = index(InnKpp, "/");
    if (i > 0)
      return SubStr(InnKpp, 0, i - 1);
    end;
    return InnKpp;
  end;

  private macro extractKPP(InnKpp)
    var i = index(InnKpp, "/");
    if (i > 0)
      return SubStr(InnKpp, i + 1);
    end;
    return "";
  end;




  // Тело функции

  var checklen: bool;          
  var regError = 0;
  GetRegistryValue("CB\\PAYMENTS\\CHECKMAXLENATTR", V_BOOL, checklen, regError);
  if ((regError != 0) or checklen)
    var fields = TArray();

    fields[fields.size] = initLen(prm.rm.rec.Number, 6, "Номер документа");
    fields[fields.size] = initLen(prm.rm.rec.PaymentKind, 1, "Вид платежа");
    fields[fields.size] = initLen(StrSubst(prm.pm_paym.rec.BaseAmount:0:2, ".",""), 18, "Сумма");//без разделителей
    fields[fields.size] = initLen(prm.rm.rec.PayerName, 160, "Наименование плательщика");
    fields[fields.size] = initLen(prm.pm_paym.rec.PayerAccount, 20, "Счет плательщика");
    if (prm.debet.rec.codeKind == 3)
      fields[fields.size] = initLen(prm.debet.rec.BankCode, 9, "БИК банка плательщика");
    end;
    fields[fields.size] = initLen(prm.rm.rec.PayerCorrAccNostro, 20, "Счет банка плательщика");
    if (prm.credit.rec.codeKind == 3)
      fields[fields.size] = initLen(prm.credit.rec.BankCode, 9, "БИК банка получателя");
    end;
    fields[fields.size] = initLen(prm.rm.rec.ReceiverCorrAccNostro, 20, "Счет банка получателя");
    fields[fields.size] = initLen(prm.rm.rec.ReceiverName, 160, "Наименование получателя");
    fields[fields.size] = initLen(prm.pm_paym.rec.ReceiverAccount, 20, "Счет получателя");
    fields[fields.size] = initLen(prm.rm.rec.Shifroper, 2, "Вид операции");
    fields[fields.size] = initLen(prm.rm.rec.Priority, 1, "Очередность платежа");
    fields[fields.size] = initLen(prm.rm.rec.Ground, 210, "Назначение платежа");

    if (prm.pm_paym.rec.DocKind == 201/*PS_PAYORDER*/)
      fields[fields.size] = initLen( prm.pspaydem.rec.AcceptTerm, 1, "Условие оплаты" );
      fields[fields.size] = initLen( prm.pspaydem.rec.AcceptPeriod, 1, "Срок для акцепта" );
    end;

    fields[fields.size] = initLen(GetContentOperationString(prm.pm_paym.rec.ContentOperation, prm.pm_paym ), 16, "Содержание операции");
    fields[fields.size] = initLen(extractINN(prm.rm.rec.PayerINN), 12, "ИНН плательщика");
    fields[fields.size] = initLen(extractINN(prm.rm.rec.ReceiverINN), 12, "ИНН получателя");
    fields[fields.size] = initLen(prm.rm.rec.TaxAuthorState, 2, "Статус составителя документа");
    fields[fields.size] = initLen(extractKPP(prm.rm.rec.PayerINN), 9, "КПП плательщика");
    fields[fields.size] = initLen(extractKPP(prm.rm.rec.ReceiverINN), 9, "КПП получателя");
    fields[fields.size] = initLen(prm.rm.rec.BttTiCode, 20, "Код бюджетной классификации");
    fields[fields.size] = initLen(prm.rm.rec.OKATOCode, 11, "Код ОКАТО");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmGround, 2, "Основание налогового платежа");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmPeriod, 10, "Налоговый период");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmNumber, 15, "Номер налогового документа");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmType, 2, "Тип налогового платежа");
    fields[fields.size] = initLen(prm.pm_paym.rec.PayerBankMarkDate, 10, "Отметки банка"); //без разделителей 8
    fields[fields.size] = initLen(prm.pm_paym.rec.ReceiverBankMarkDate, 10, "Отметки банка получателя");//без разделителей 8
    fields[fields.size] = initLen(prm.pm_paym.rec.PayerBankEnterDate, 10, "Поступ. в банк плат.");//без разделителей 8
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymNumber, 3, "№ ч. плат");
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymShifrMain, 2, "Шифр плат. документа");
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymNumMain, 6, "№ плат. док.");
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymRestAmountMain, 18, "Сумма остатка платежа");

    var item: TArray;
    for( item, fields )
      if (strlen(item[0]) > item[1])
        err[err.size] = TError(WARNING, "Длина реквизита '"+item[2]+"' превышает "+item[1]+" символов.");
      end;
    end;
  end;
end;

// Ненулевой номер документа
private macro CheckSaveNumberIsZero(prm:TExecFunSaveChkParm, err:TArray)

  if( not StrIsNumber(prm.rm.rec.Number) )
    err[err.size] = TError(ERROR, "Номер документа нечисловой", prm.flds.Number);
  elif( int(prm.rm.rec.Number) == 0 )
    err[err.size] = TError(ERROR, "Номер документа не может быть нулевым", prm.flds.Number);
  end; 
  
end;

// Платеж не является оплатой коммунальных услуг
private macro CheckSaveIsHCSPayment(prm:TExecFunSaveChkParm, err:TArray)
  if( (prm.pm_paym != null) and (prm.rm != null) and (prm.pmserv != null) )
    var er = IsHCSPaymentReceiver( prm.pm_paym, prm.rm, prm.pmserv );
    if( er )
      prm.PaymentObj.Notes.AddNote( NOTEKIND_PAYM_HCSWARNING, er );
      err[err.size] = TError( WARNING, er );
    end;
  end;      
end;

//Вид платежа Имеет значение <С> - <срочно>
private macro CheckPaymentTypeS( prm:TExecFunSaveChkParm, err:TArray )
  if( not InList(prm.rm.rec.PaymentKind, "С", "Н") )
    err[err.size] = TError(ERROR, "Для поручения банка может использоваться вид платежа \"срочно\" или \"не задан\"", prm.flds.PaymentKind );
  end;
end;

private macro СheckBankNameAndAccountEx( BankID:integer, BankCodeKind:integer, BankName:string, BankAccount:string, Field:integer, err:TArray, errString:string )
  var res : bool = true;
  if( BankID > 0 )  
    if( not ( InList( BankCodeKind, PTCK_BIC, PTCK_SWIFT ) or ( (BankName != "") and (BankAccount != "") ) ) )
      res = false;
    end;
  end;
  return res;
end;

private macro СheckBankNameAndAccount( BankID:integer, BankCodeKind:integer, BankName:string, BankAccount:string, Field:integer, err:TArray, errString:string )
  if( not СheckBankNameAndAccountEx( BankID, BankCodeKind, BankName, BankAccount, Field, err, errString ) )
    err[err.size] = TError(WARNING, "Сведений о " + errString + " недостаточно для включения их в сообщение.|Задайте код вида 3 \"БИК (ЦБ РФ)\" или 6 \"BIC ISO (SWIFT)\".|Если такого кода у банка нет, задайте наименование и номер счета", Field);
  end;
end;

private macro CheckBankCode( BankID:integer, CodeKind:integer, BankCode:string, Field:integer, err:TArray, errString:string )
  var Code = "";
  var CodeOwnerID = 0;
  if( CodeKind == PTCK_BIC )
    if( not ((GetPartyCodeEx( BankID, PTCK_BIC, @Code, @CodeOwnerID ) == 0) and (Code == BankCode)) )
      err[err.size] = TError(ERROR, "Для " + errString + " указан недействующий БИК.|Задайте БИК, который действует на " + {curdate} + 
                                    ", или укажите код банка другого вида, например, BIC SWIFT", Field );
    end;  
  end;
end;

private macro CheckBankCodeBIC( CodeKind:integer, BankCode : string, Field:integer, 
                                err:TArray, errString:string ) : bool
  var Code = "";
  var CodeOwnerID = 0;

  if( (CodeKind != PTCK_BIC) or not BankCode )
    err[err.size] = TError(ERROR, "Для " + errString + " необходимо задать БИК", Field );
    return false;
  end;

  return true;
end;

private macro CheckBankCodeEquality( BankID:integer, CodeKind:integer, BankCode:string, Field:integer, err:TArray, errString:string, errStringE:string )
  var Code = "";
  var CodeOwnerID = 0;
  if( not ((GetPartyCodeEx( BankID, PTCK_BIC, @Code, @CodeOwnerID ) == 0) and (Code == BankCode)) )
    err[err.size] = TError(ERROR, "Для " + errString + " указан недействующий БИК.|Задайте БИК, который действует на " + {curdate} + 
                                  ", или укажите другой " + errStringE, Field );
  end;  
end;

private macro CheckBankExistsAndOpened( BankID:integer, BankCodeKind:integer, BankCodeValue:string, Field:integer, err:TArray, errString:string )
  
  if( BankID > 0)    
    var bankdprt:TRecHandler = Bnk_GetBankDprt( BankID );
    
    if ( ( BankCodeKind > 0 ) and ( strlen(BankCodeValue) > 0 ) )
      if( bankdprt == null )
        err[err.size] = TError(ERROR, "Не найден " + errString + " в справочнике банков", Field );
      else
        if( bankdprt.rec.Lock == "X" )
          err[err.size] = TError(ERROR, "Отделение " + errString  + " закрыто", Field );
        end;
      end;
    end;
  end;
end;

private macro CheckBankDefined( BankID:integer, Field:integer, err:TArray, errString:string )
  
  if( BankID <= 0)
    err[err.size] = TError(ERROR, "Не задан " + errString, Field );
  end;
end;

private macro checkBankBlock( BankID:integer, Field:integer, err:TArray, errString:string )
  var Code:string = "";
  var CodeOwnerID:integer = 0;
  
  if( BankID > 0 )
    var bankdprt:TRecHandler = Bnk_GetBankDprt( BankID );
  
    if ( IsResident( BankID ) and (GetPartyCodeEx( BankID, PTCK_BIC, @Code, @CodeOwnerID ) == 0 ) )    
      if( trim(bankdprt.rec.Real) == "БЛОК" )
        err[err.size] = TError( WARNING, "Счет " + errString + " заблокирован. Необходимо указать другой банк.", Field );
      end;
    end;
  end;
end;

private macro checkBankControlCodeEmpty( BankID:integer, Field:integer, err:TArray, errString:string )
  var Code:string = "";
  var CodeOwnerID:integer = 0;
  
  if( BankID > 0 )
    var bankdprt:TRecHandler = Bnk_GetBankDprt( BankID );
  
    if ( IsResident( BankID ) and (GetPartyCodeEx( BankID, PTCK_BIC, @Code, @CodeOwnerID ) == 0 ) )    
      if( strlen(trim(bankdprt.rec.Real)) > 0 )
        err[err.size] = TError(WARNING, "Код контроля " + errString + " равен '" + bankdprt.rec.Real + "'", Field);
      end;
    end;
  end;
end;

private macro checkBankAccount( BankID:integer, BankAccount:string, Field:integer, err:TArray, errString:string )
  var Code:string = "";
  var CodeOwnerID:integer = 0;
  
  if( BankID > 0 )  
    if( IsResident( BankID ) and (BankAccount != "") and IsNotFormat302P( BankAccount ) )
        err[err.size] = TError(ERROR, "Счет " + errString + " не соответствует действующим правилам ЦБ РФ обозначения лицевых счетов", Field);
    end;
  end;
end;

private macro checkAccountIsMask( BankAccount:string, Field:integer, err:TArray, errString:string )
  if( (strlen(BankAccount) > 0) and AccountIsMask( BankAccount ) )
      err[err.size] = TError(ERROR, "Счет " + errString + " не может быть маской", Field );
    end;
end;

private macro CheckAccountKey( BankID:integer, BankAccount:string, BankCodeKind:integer, Field:integer, err:TArray, errString:string )
  var bankdprt:TRecHandler = Bnk_GetBankDprt( BankID );
  if( bankdprt != null )
    if( (strlen( BankAccount ) != 0) and (IsResident(BankID)) and (BankCodeKind == PTCK_BIC) )
        // В проверке написано: в соответствии с правилами ключевания в РКЦ банка (bankdprt.rec.CheckAlg). - Но возможность указать этот параметр из rsl я не нашел, поэтому пока так
        var AccKey = GetKey( BankAccount, GetBankDprtCheckData( bankdprt.rec.BIC_RCC ) );
        if( AccKey != BankAccount )
          err[err.size] = TError(ERROR, "Неверный ключ у счета " + errString + ". Должен быть " + SubStr(AccKey, 9, 1), Field );
        end;
    end;
  end;   
end;

private macro CheckReceiverAccountKey( BankID:integer, BankAccount:string, BankCodeKind:integer, BankCode:string, Field:integer, err:TArray, errString:string )
  var bankdprt:TRecHandler = Bnk_GetBankDprt( BankID );
  if( bankdprt != null )
    if( (strlen( BankAccount ) != 0) and (IsResident(BankID)) and (BankCodeKind == PTCK_BIC) )
        var AccKey = GetKey( BankAccount, BankCode );
        if( AccKey != BankAccount )
          err[err.size] = TError(ERROR, "Неверный ключ у счета " + errString + ". Должен быть " + SubStr(AccKey, 9, 1), Field );
        end;
    end;
  end;   
end;

private macro CheckAccountRKC( BankID:integer, BankAccount:string, Field:integer, err:TArray, errString:string )
  var bankdprt:TRecHandler = Bnk_GetBankDprt( BankID );
  if( (bankdprt == null) or (strlen(BankAccount) == 0) or (BankAccount != bankdprt.rec.CorAcc) )
    err[err.size] = TError(WARNING, "В качестве счета " + errString + " необходимо задать номер корреспондентского счета, открытого банку в ПБР", Field );
  end;      
end;

private macro CheckBankIsCorschemDepartment( BankID:integer, FIID:integer, CorschemNumber:integer, Field:integer, err:TArray, errString:string, errString1:string, errString2:string )

  var query = 
              "SELECT dp_dep.t_PartyID " +
              "FROM ddp_dep_dbt dp_dep " +
              "     INNER JOIN dcorschem_dbt corschem " +
              "        ON corschem.t_Department = dp_dep.t_Code " +
             "WHERE corschem.t_number = :CorschemNumber AND corschem.t_FIID = :FIID";
             
  var rs = execSQLselect( query, makeArray( SQLParam("CorschemNumber", CorschemNumber), SQLParam("FIID", FIID) ) );
  
  if( (not rs) or ( not rs.movenext() ) or (rs.value(0) != BankID ) )
    err[err.size] = TError(ERROR, errString + " не является владельцем корсчета (схемы расчетов), " + errString1 + " должны быть " + errString2 + " средства", Field );
  end;
end;

private macro checkBankIsOurDep( BankID:integer, err:TArray, fullError:bool, errString:string, Field:integer )

  if( BankID == {OurBank} )
    return;
  end; 
  
  var query = 
              "SELECT dp_dep.t_PartyID " +
              "FROM ddp_dep_dbt dp_dep " +
              "WHERE dp_dep.t_AccessMode = :AccessMode AND dp_dep.t_PartyID = :PartyID";
              
  var rs = execSQLselect( query, makeArray( SQLParam("AccessMode", 1), SQLParam("PartyID", BankID) ) );
  
  if( (not rs) or ( not rs.movenext() ) )
    err[err.size] = TError(ERROR, IfThenElse( fullError, "Обработка транзитных поручений банка не предусмотрена. ", "") + errString + " должен являться филиалом, работающим в ЦАБС", Field );
  end;  
end;

// Наименование и номер счета банка-плательщика
private macro CheckPaymentPayerBankNameAndAccount( prm:TExecFunSaveChkParm, err:TArray )
  СheckBankNameAndAccount( prm.pm_paym.rec.PayerBankID, prm.debet.rec.CodeKind, prm.rm.rec.PayerBankName, prm.pm_paym.rec.PayerAccount, prm.flds.PayerBankCode, err, "банке плательщике" );  
end;

//Код банка-плательщика
private macro CheckPaymentPayerBankCode( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckBankCode(prm.pm_paym.rec.PayerBankID, prm.debet.rec.CodeKind, prm.debet.rec.BankCode, prm.flds.PayerBankCode, err, "банка-плательщика" );
end;

// Банк плательщика существует и открыт
private macro CheckSavePayerBankExistAndOpened( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckBankExistsAndOpened( prm.pm_paym.rec.PayerBankID, prm.debet.rec.CodeKind, prm.debet.rec.BankCode, prm.flds.PayerBankCode, err, ",банка-плательщика" );
end;

// Наличие банка
private macro CheckNeededBankExistence( FirstBankID:integer, FirstBankCodeKind:integer, FirstBankName:string, FirstBankAccount:string, 
                                        SecondBankID:integer, SecondBankCodeKind:integer, SecondBankName:string, SecondBankAccount:string, Field:integer, err:TArray, 
                                        FirstBankErrString:string, SecondBankErrString:string, SecondBankErrStringE:string )
  if( FirstBankID > 0 )  
    if( СheckBankNameAndAccountEx( FirstBankID, FirstBankCodeKind, FirstBankName, FirstBankAccount, Field, err, "" ) 
       and
        ( (SecondBankID <= 0) or (not СheckBankNameAndAccountEx( SecondBankID, SecondBankCodeKind, SecondBankName, SecondBankAccount, Field, err, "" ))) 
      )
      err[err.size] = TError(WARNING, "Информация о " + FirstBankErrString + " не может быть указана без информации о " + SecondBankErrString + ".|Заполните реквизиты " + 
                             SecondBankErrStringE + " согласно требованиям к ED107 или удалите сведения о " + FirstBankErrString, Field);
    end;
  end; 
end;

// Наличие банка-плательщика
private macro CheckSaveCheckPayerBankExistence( prm:TExecFunSaveChkParm, err:TArray )
    CheckNeededBankExistence( prm.PrevInstrAgent.rec.PartyID, prm.PrevInstrAgent.rec.CodeKind, prm.PrevInstrAgent.rec.Name, prm.PrevInstrAgent.rec.OutAccount, 
                              prm.pm_paym.rec.PayerBankID, prm.debet.rec.CodeKind, prm.rm.rec.PayerBankName, prm.pm_paym.rec.PayerAccount, 
                              prm.flds.PayerBankCode, err, 
                              "предыдущем инструктирующем банке", "банке-плательщике", "банка-плательщика" );
end;

// Наличие банка-получателя
private macro CheckSaveCheckReceiverBankExistence( prm:TExecFunSaveChkParm, err:TArray )
    CheckNeededBankExistence( prm.IntermediaryBank.rec.PartyID, prm.IntermediaryBank.rec.CodeKind, prm.IntermediaryBank.rec.Name, prm.IntermediaryBank.rec.OutAccount, 
                              prm.pm_paym.rec.ReceiverBankID, prm.credit.rec.CodeKind, prm.rm.rec.ReceiverBankName, prm.pm_paym.rec.ReceiverAccount, 
                              prm.flds.ReceiverAccount, err, 
                              "агенте банка-получателя", "банке-получателе", "банка-получателя" );
end;

//Банк-плательщика является <нашим> филиалом
private macro CheckSavePayerBankIsOurDep( prm:TExecFunSaveChkParm, err:TArray )
  checkBankIsOurDep( prm.pm_paym.rec.PayerBankID, err, true, "Банк-плательщик", prm.flds.PayerBankCode );
end;


// Проверки банков участников операции
private macro CheckSavePrevInstrAgentExistAndOpened( prm:TExecFunSaveChkParm, err:TArray )

  CheckBankExistsAndOpened( prm.PrevInstrAgent.rec.PartyID, prm.PrevInstrAgent.rec.CodeKind, prm.PrevInstrAgent.rec.CodeValue, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка" );
end;

private macro CheckSaveIntermediaryBankExistAndOpened( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckBankExistsAndOpened( prm.IntermediaryBank.rec.PartyID, prm.IntermediaryBank.rec.CodeKind, prm.IntermediaryBank.rec.CodeValue, prm.flds.IntermediaryBankCode, err, "агента банка-получателя" );  
end;

private macro CheckSaveReceiverBankExistAndOpened( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckBankExistsAndOpened( prm.pm_paym.rec.ReceiverBankID, prm.credit.rec.CodeKind, prm.credit.rec.BankCode, prm.flds.ReceiverBankCode, err, "банка-получателя" );
end;

private macro CheckSavePrevInstrAgentBlock( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankBlock( prm.PrevInstrAgent.rec.PartyID, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка" );
end;

private macro CheckSaveIntermediaryBankBlock( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankBlock( prm.IntermediaryBank.rec.PartyID, prm.flds.IntermediaryBankCode, err, "агента банка-получателя" );
end;

private macro CheckSaveReceiverBankBlock( prm:TExecFunSaveChkParm, err:TArray )
    
  checkBankBlock( prm.ReceiverBank.rec.PartyID, prm.flds.ReceiverBankCode, err, "банка-получателя" );
end;

private macro CheckSavePrevInstrAgentControlCode( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankControlCodeEmpty(prm.PrevInstrAgent.rec.PartyID, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка");
end;

private macro CheckSaveIntermediaryBankControlCode( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankControlCodeEmpty(prm.IntermediaryBank.rec.PartyID, prm.flds.IntermediaryBankCode, err, "агента банка-получателя");
end;

private macro CheckSaveReceiverBankControlCode( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankControlCodeEmpty( prm.ReceiverBank.rec.PartyID, prm.flds.ReceiverBankCode, err, "банка-получателя" );
end;

private macro CheckSavePrevInstrAgentCode( prm:TExecFunSaveChkParm, err:TArray )

  CheckBankCode(prm.PrevInstrAgent.rec.PartyID, prm.PrevInstrAgent.rec.CodeKind, prm.PrevInstrAgent.rec.CodeValue, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка" );
end;

private macro CheckSaveIntermediaryBankCode( prm:TExecFunSaveChkParm, err:TArray )

  CheckBankCode( prm.IntermediaryBank.rec.PartyID, prm.IntermediaryBank.rec.CodeKind, prm.IntermediaryBank.rec.CodeValue, prm.flds.IntermediaryBankCode, err, "агента банка-получателя" );
end;

private macro CheckSaveReceiverBankCode( prm:TExecFunSaveChkParm, err:TArray )

  CheckBankCode( prm.pm_paym.rec.ReceiverBankID, prm.ReceiverBank.rec.CodeKind, prm.ReceiverBank.rec.CodeValue, prm.flds.ReceiverBankCode, err, "банка-получателя" );
end;

// Наименование и номер счета предыдущего инструктирующего банка
private macro CheckPaymentPrevInstrAgentBankNameAndAccount( prm:TExecFunSaveChkParm, err:TArray )
  СheckBankNameAndAccount( prm.PrevInstrAgent.rec.PartyID, prm.PrevInstrAgent.rec.CodeKind, prm.PrevInstrAgent.rec.Name, 
                           prm.PrevInstrAgent.rec.OutAccount, prm.flds.PrevInstrAgentCode, err, "предыдущем инструктирующем банке" );  
end;                       

// Наименование и номер счета агента банка-получателя
private macro CheckPaymentIntermediaryBankNameAndAccount( prm:TExecFunSaveChkParm, err:TArray )
  СheckBankNameAndAccount( prm.IntermediaryBank.rec.PartyID, prm.IntermediaryBank.rec.CodeKind, prm.IntermediaryBank.rec.Name, 
                           prm.IntermediaryBank.rec.OutAccount, prm.flds.IntermediaryBankCode, err, "агенте банка-получателя" );  
end;
                                                         
// Наименование и номер счета банка-получателя
private macro CheckPaymentReceiverBankNameAndAccount( prm:TExecFunSaveChkParm, err:TArray )
  СheckBankNameAndAccount( prm.pm_paym.rec.ReceiverBankID, prm.credit.rec.CodeKind, prm.rm.rec.ReceiverBankName, 
                           prm.pm_paym.rec.ReceiverAccount, prm.flds.ReceiverAccount, err, "банке-получателе" );  
end;

private macro CheckSavePrevInstrAgentAccount( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankAccount( prm.PrevInstrAgent.rec.PartyID, prm.PrevInstrAgent.rec.OutAccount, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка" );
end;

private macro CheckSaveIntermediaryBankAccount( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankAccount( prm.IntermediaryBank.rec.PartyID, prm.IntermediaryBank.rec.OutAccount, prm.flds.IntermediaryBankCode, err, "агента банка-получателя"  );  
end;

private macro CheckSaveReceiverBankAccount( prm:TExecFunSaveChkParm, err:TArray )
  
  checkBankAccount( prm.pm_paym.rec.ReceiverBankID, prm.pm_paym.rec.ReceiverAccount, prm.flds.ReceiverAccount, err, "банка-получателя"  );
end;

private macro CheckSavePrevInstrAgentAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  
  checkAccountIsMask( prm.PrevInstrAgent.rec.OutAccount, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка" );
end;

private macro CheckSaveIntermediaryBankAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  
  checkAccountIsMask( prm.IntermediaryBank.rec.OutAccount, prm.flds.IntermediaryBankCode, err, "агента банка-получателя"  );  
end;

private macro CheckSaveReceiverBankAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  
  checkAccountIsMask( prm.pm_paym.rec.ReceiverAccount, prm.flds.ReceiverAccount, err, "банка-получателя"  );
end;

private macro CheckSavePrevInstrAgentAccountKey( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckAccountKey( prm.PrevInstrAgent.rec.PartyID, prm.PrevInstrAgent.rec.OutAccount, prm.PrevInstrAgent.rec.CodeKind, prm.flds.PrevInstrAgentCode, err, "предыдущего инструктирующего банка" );
end;

private macro CheckSaveIntermediaryBankAccountKey( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckAccountKey( prm.IntermediaryBank.rec.PartyID, prm.IntermediaryBank.rec.OutAccount, prm.IntermediaryBank.rec.CodeKind, prm.flds.IntermediaryBankCode, err, "агента банка-получателя"  );  
end;

private macro CheckSaveReceiverBankAccountKey( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckReceiverAccountKey( prm.pm_paym.rec.ReceiverBankID, prm.pm_paym.rec.ReceiverAccount, prm.credit.rec.CodeKind, prm.credit.rec.BankCode, prm.flds.ReceiverAccount, err, "банка-получателя"  );
end;

private macro CheckSaveReceiverBankIsOurDep( prm:TExecFunSaveChkParm, err:TArray )
  checkBankIsOurDep( prm.pm_paym.rec.ReceiverBankID, err, true, "Банк-получатель", prm.flds.ReceiverBankCode );
end;


//Проверки банка отправителя
private macro CheckSaveSenderBankExistAndOpened( prm:TExecFunSaveChkParm, err:TArray )

    CheckBankDefined( prm.SenderBank.rec.PartyID, prm.flds.SenderBankCode, err, "банк-отправитель");
    CheckBankExistsAndOpened( prm.SenderBank.rec.PartyID, prm.SenderBank.rec.CodeKind, prm.SenderBank.rec.CodeValue, prm.flds.SenderBankCode, err, "банка-отправителя" );
end;

private macro CheckSaveSenderBankCodeBIC( prm:TExecFunSaveChkParm, err:TArray )

    if( CheckBankCodeBIC( prm.SenderBank.rec.CodeKind, prm.SenderBank.rec.CodeValue, 
                          prm.flds.SenderBankCode, err, "банка-отправителя" 
                        ) == true
      )
      CheckBankCodeEquality( prm.SenderBank.rec.PartyID, prm.SenderBank.rec.CodeKind, prm.SenderBank.rec.CodeValue, prm.flds.SenderBankCode, err, "банка-отправителя", "банк-отправитель" )
    end;
end;

private macro CheckSaveSenderBankPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtIsPartPSBR
    ( prm.SenderBank.rec.PartyID, 
      "Банк-отправитель", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSaveSenderBankRestrictPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtRestrictPartPSBR
    ( prm.SenderBank.rec.PartyID, 
      "банка-отправителя", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSaveSenderBankAccountRKC( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckAccountRKC( prm.SenderBank.rec.PartyID, prm.SenderBank.rec.OutAccount, prm.flds.SenderBankAccount, err, "банка-отправителя" )
end;

private macro CheckSaveSenderBankIsCorschemDepartment( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckBankIsCorschemDepartment( prm.SenderBank.rec.PartyID, prm.credit.rec.PayFIID, prm.credit.rec.Corschem, prm.flds.SenderBankAccount, err, "Банк-отправителя", "с которого", "перечислены" )
end;

private macro CheckSaveSenderBankIsOurDep( prm:TExecFunSaveChkParm, err:TArray )
  checkBankIsOurDep( prm.SenderBank.rec.PartyID, err, false, "Банк-отправителя", prm.flds.SenderBankCode );
end;


//Проверки банка исполнителя
private macro CheckSaveExecutorBankExistAndOpened( prm:TExecFunSaveChkParm, err:TArray )

  CheckBankDefined( prm.ExecutorBank.rec.PartyID, prm.flds.ExecutorBankCode, err, "банк-исполнитель");
  CheckBankExistsAndOpened( prm.ExecutorBank.rec.PartyID, prm.ExecutorBank.rec.CodeKind, prm.ExecutorBank.rec.CodeValue, prm.flds.ExecutorBankCode, err, "банка-исполнителя" );
end;

private macro CheckSaveExecutorBankCodeBIC( prm:TExecFunSaveChkParm, err:TArray )

  if( CheckBankCodeBIC( prm.ExecutorBank.rec.CodeKind, prm.ExecutorBank.rec.CodeValue, 
                        prm.flds.ExecutorBankCode, err, "банка-исполнителя"
                      ) == true
    )
    CheckBankCodeEquality( prm.ExecutorBank.rec.PartyID, prm.ExecutorBank.rec.CodeKind, prm.ExecutorBank.rec.CodeValue, prm.flds.ExecutorBankCode, err, "банка-исполнителя", "банк-исполнитель" );
  end;
end;

private macro CheckSaveExecutorBankPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtIsPartPSBR
    ( prm.ExecutorBank.rec.PartyID, 
      "Банк-исполнитель", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSaveExecutorBankRestrictPartInPSBR( prm:TExecFunSaveChkParm, err:TArray )
  var Msg : string = "";
  var stat : integer = CheckPtRestrictPartPSBR
    ( prm.ExecutorBank.rec.PartyID, 
      "банка-исполнителя", 
      @Msg
    );

  if(Msg)
    err[err.size] = TError( IfThenElse(stat, ERROR, WARNING), Msg );
  end;
end;

private macro CheckSaveExecutorBankAccountRKC( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckAccountRKC( prm.ExecutorBank.rec.PartyID, IfThenElse( prm.pm_paym.rec.DocKind == DLDOC_BANKPAYORDER, prm.ExecutorBank.rec.OutAccount, prm.ExecutorBank.rec.InAccount), prm.flds.ExecutorBankAccount, err, "банка-исполнителя" )
end;

private macro CheckSaveExecutorBankIsCorschemDepartment( prm:TExecFunSaveChkParm, err:TArray )
  
  CheckBankIsCorschemDepartment( prm.ExecutorBank.rec.PartyID, prm.debet.rec.PayFIID, prm.debet.rec.Corschem, prm.flds.ExecutorBankAccount, err, "Банк-исполнителя", "на который", "зачислены" )
end;

private macro CheckSaveExecutorBankIsOurDep( prm:TExecFunSaveChkParm, err:TArray )
  checkBankIsOurDep( prm.ExecutorBank.rec.PartyID, err, false, "Банк-исполнителя", prm.flds.ExecutorBankCode );
end;


macro CheckMacroScrolCommon( flds:TPanelFields, checks:TArray, pm_paym, debet, credit, rm, pmserv, pspayord, pspaydem ):integer

  record PrevInstrAgent(pmroute);
  record SenderBank(pmroute);
  record ExecutorBank(pmroute);
  record IntermediaryBank(pmroute);
  record PayerBank(pmroute);
  record ReceiverBank(pmroute);

  Bnk_ToRSTrace( "ComPmChkMac", "Begin", "checks.size = " + checks.size );

  var prm:TExecFunSaveChkParm = TExecFunSaveChkParm();
  
  if(pm_paym != null)
    prm.pm_paym = TRecHandler( "pmpaym.dbt" );
    Copy(prm.pm_paym, pm_paym);
  end;

  if(debet != null)
    prm.debet = TRecHandler( "pmprop.dbt" );
    Copy(prm.debet, debet);
  end;
  
  if(credit != null)
    prm.credit = TRecHandler( "pmprop.dbt" );
    Copy(prm.credit, credit);
  end;
  
  if(rm != null)
    prm.rm = TRecHandler( "pmrmprop.dbt" );
    Copy(prm.rm, rm);
  end;

  if(pspayord != null)
    prm.pspayord = TRecHandler( "pspayord.dbt" );
    Copy(prm.pspayord, pspayord);
  end;
  
  if(pspaydem != null)
    prm.pspaydem = TRecHandler( "pspaydem.dbt" );
    Copy(prm.pspaydem, pspaydem);
  end;

  if(pmserv != null)
    prm.pmserv = TRecHandler( "pmserv.dbt" );
    Copy(prm.pmserv, pmserv);
  end;
  
  if( flds == null )
    prm.flds = TPanelFields();
  else
    prm.flds = flds;
  end;

  prm.PaymentObj = RsbPayment(pm_paym.PaymentID);

  if( (prm.PaymentObj.DocKind == DLDOC_BANKPAYORDER ) or (  ( prm.PaymentObj.DocKind == WL_WIPM ) and ( prm.PaymentObj.Purpose == PM_PURP_BANKPAYORDER ) ) )
    ClearRecord( PayerBank );
    ClearRecord( PrevInstrAgent );
    ClearRecord( SenderBank );
    ClearRecord( ExecutorBank );
    ClearRecord( IntermediaryBank );
    ClearRecord( ReceiverBank );

    if( prm.PaymentObj.GetOperationParticipantsFromRoute( PrevInstrAgent, SenderBank, ExecutorBank, IntermediaryBank, PayerBank, ReceiverBank ) )
      prm.PrevInstrAgent = TRecHandler( "pmroute.dbt" );
      Copy( prm.PrevInstrAgent, PrevInstrAgent);
      prm.SenderBank = TRecHandler( "pmroute.dbt" );
      Copy( prm.SenderBank, SenderBank);
      prm.ExecutorBank = TRecHandler( "pmroute.dbt" );
      Copy( prm.ExecutorBank, ExecutorBank);
      prm.IntermediaryBank = TRecHandler( "pmroute.dbt" );
      Copy( prm.IntermediaryBank, IntermediaryBank);
      prm.PayerBank = TRecHandler( "pmroute.dbt" );
      Copy( prm.PayerBank, PayerBank);
      prm.ReceiverBank = TRecHandler( "pmroute.dbt" );
      Copy( prm.ReceiverBank, ReceiverBank);
    else
      return ERROR;
    end;
  end;

  // Перед началом проверок очистим примечание платежа вида <Результаты проверки наименований>.  
  prm.PaymentObj.Notes.DelNote( NOTEKIND_PAYM_NAMEWARNING );
  
  Bnk_ToRSTrace( "ComPmChkMac", "Event", "BeginPumpAccount" );

  // Заполняем буфера счетов плательщика и получателя
  if(prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL)
    PumpAccount(prm, 0, PRT_Debet, pm_paym.PayerAccount)
  end;
  
  if(prm.credit.rec.Group == PAYMENTS_GROUP_INTERNAL)
    PumpAccount(prm, 0, PRT_Credit, pm_paym.ReceiverAccount)
  end;

  // Сохряняем в массиве счета разноски
  if(prm.PaymentObj.PIList(PRT_Debet).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Debet, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, null, "PumpAccount", PRT_Debet ) );
  elif(prm.PaymentObj.PIList(PRT_Credit).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Credit, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, null, "PumpAccount", PRT_Credit ) );
  end;

  Bnk_ToRSTrace( "ComPmChkMac", "Event", "EndPumpAccount" );

  var exec:TExecFunSaveChk = TExecFunSaveChk(prm);
  var func:variant;
  for( func, checks )
    exec.AddChk( func );
  end;

  var retVal = NOTERROR;
  if((retVal == NOTERROR) and (exec.ChkFun.size > 0))
    retVal = exec.Execute();
  end;

  Bnk_ToRSTrace( "ComPmChkMac", "End", "retVal = " + retVal );
  return retVal;
end;

/**
 * Проверки для банковских ордеров
 */
macro BBBO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer

  var checks:TArray = TArray();
  
  checks[checks.size] = "CheckNumber";
  checks[checks.size] = "CheckBaseAmount";
  if(pm_paym.Purpose == PM_PURP_CBANKORDER)
    checks[checks.size] = "CheckSaveFIID";
    checks[checks.size] = "CheckSaveRate";
  end;
  checks[checks.size] = "CheckSave383PLength";
  checks[checks.size] = "CheckSavePriority";
  checks[checks.size] = "CheckSaveNumberPack";
  checks[checks.size] = "CheckSaveDate";
  checks[checks.size] = "CheckSavePaymentDate";
  checks[checks.size] = "CheckSaveValueDate";
  checks[checks.size] = "CheckSaveValueDateIsBalance";
  checks[checks.size] = "CheckSavePayerNameSet";
  checks[checks.size] = "CheckSavePayerNameOk";
  checks[checks.size] = "CheckSavePayerAccountSet";
  checks[checks.size] = "CheckSavePayerAccountOk";
  checks[checks.size] = "CheckSavePayerAccountOpr";    
  checks[checks.size] = "CheckSaveReceiverAccountOk";
  checks[checks.size] = "CheckSaveReceiverAccountOpr";
  checks[checks.size] = "CheckSaveGround";
  checks[checks.size] = "CheckSavePayerAccountMFR";
  checks[checks.size] = "CheckSaveReceiverAccountMFR";
  checks[checks.size] = "CheckSaveReceiverAccountOrAddPiSet";
  checks[checks.size] = "CheckSaveReceiverAccountWithAddPI";
  checks[checks.size] = "CheckSaveSpecialPayerAccount";
  checks[checks.size] = "CheckSaveSpecialReceiverAccount";
  checks[checks.size] = "CheckSaveFuturePayerAccountOk";
  checks[checks.size] = "CheckSaveFutureReceiverAccountOk";

  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );

end;

/**
 * Проверки для рублёвых платежей РКО
 */
macro PSPO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm, pmserv, pspayord, pspaydem ):integer
  var checks:TArray;
  if( pspayord.DocKind != PSPOKIND_CASH_REQUEST )
    checks = makeArray( "CheckSavePaymentDate",
                        "CheckSaveOldDoc",
                        "CheckSavePayerBankEnterDate",
                        "CheckSaveValueDateIsBalance",
                        "CheckSaveTransferDate",
                        "CheckNumberForRKC",
                        "CheckSavePayerNameOk",
                        "CheckSaveReceiverNameOk",
                        "CheckSavePayerAccountIs302P",
                        "CheckSaveReceiverAccountIs302P",
                        "CheckSaveSpecialPayerAccount",
                        "CheckSaveSpecialReceiverAccount",
                        "CheckSaveReceiverAccountOk",
                        "CheckSaveFuturePayerAccountOk",
                        "CheckSaveFutureReceiverAccountOk",
                        "CheckSave383PLength",
                        "CheckSaveReceiverBank" );
  
    if( pspayord.DocKind == PSPOKIND_ORDER )
      checks[checks.size] = "CheckSavePermissibilityPayerBankCorrAcc";
      checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
    end;
    
    if( pspayord.DocKind == PSPOKIND_AKKREDITIV )
      checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
    end;
     
  else
    checks = TArray();
  end;


  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm, pmserv, pspayord, pspaydem );
end;

/**
 * Проверки для валютных платежей РКО
 */
macro PSCP_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm, pmserv ):integer

  var checks:TArray = makeArray( "CheckSavePaymentDate",
                                 "CheckSaveOldDoc",
                                 "CheckSavePayerBankEnterDate",
                                 "CheckSavePayerNameOk",
                                 "CheckSaveReceiverNameOk",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveReceiverAccountOk",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk",
                                 "CheckSaveIsHCSPayment" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm, pmserv );
end;

/**
 * Проверки для рублёвых платежей банка
 */
macro BBBP_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm, pmserv ):integer
  var checks:TArray = makeArray( "CheckSavePaymentDate",
                                 "CheckSaveOldDoc",
                                 "CheckSavePayerBankEnterDate",
                                 "CheckSavePayerNameOk",
                                 "CheckSaveReceiverNameOk",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckNumberForRKC",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveReceiverAccountOk",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk",
                                 "CheckSaveIsHCSPayment",
                                 "CheckSaveReceiverBank" );

    
  if( pm_paym.Dockind == DLDOC_BANKPAYMENT )
    checks[checks.size] = "CheckSave383PLength";
  end;
  
  if( pm_paym.Dockind == DLDOC_BANKPAYMENT )
    checks[checks.size] = "CheckSavePermissibilityPayerBankCorrAcc";
    checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  end;         
  
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm, pmserv );
end;

/**
 * Проверки для валютных платежей банка
 */
macro BBCP_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm, pmserv ):integer
  var checks:TArray = makeArray( "CheckSavePaymentDate",
                                 "CheckSaveOldDoc",
                                 "CheckSavePayerBankEnterDate",
                                 "CheckSavePayerNameOk",
                                 "CheckSaveReceiverNameOk",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIsMask",
                                 "CheckSaveReceiverAccountIsMask",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveReceiverAccountOk",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk",
                                 "CheckSaveIsHCSPayment" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm, pmserv );
end;

/**
 * Проверки для требований банка
 */
macro BBBC_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckPaymentType",
                                 "CheckSaveOldDoc",
                                 "CheckSaveValueDate",
                                 "CheckSavePayerNameOk",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSavePayerAccountOk",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk",
                                 "CheckSaveReceiverBank" );
  checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для поручений банка
 */
macro BBBPO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckNumber",
                                 "CheckNumberForRKC",
                                 "CheckPaymentTypeS",
                                 "CheckBaseAmount",
                                 "CheckSavePriority",
                                 "CheckSaveNumberPack",
                                 "CheckSaveDate",
                                 "CheckSavePaymentDate",
                                 "CheckSaveValueDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSave383PLength",
                                 "CheckSaveNumberIsZero",
                                 "CheckPaymentPayerBankNameAndAccount",
                                 "CheckPaymentPayerBankCode",
                                 "CheckSavePayerBankED107",
                                 "CheckSavePayerBankIsOurDep",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSavePayerAccountIsMask",
                                 "CheckSavePayerAccountOk",
                                 "CheckSavePayerAccountOpr",
                                 "CheckSavePrevInstrAgentExistAndOpened",
                                 "CheckSaveIntermediaryBankExistAndOpened",
                                 "CheckSaveReceiverBankExistAndOpened",
                                 "CheckPaymentPrevInstrAgentBankNameAndAccount",
                                 "CheckPaymentIntermediaryBankNameAndAccount",
                                 "CheckPaymentReceiverBankNameAndAccount",
                                 "CheckSaveIntermediaryBankBlock",
                                 "CheckSaveReceiverBankBlock",
                                 "CheckSaveIntermediaryBankControlCode",
                                 "CheckSaveReceiverBankControlCode",
                                 "CheckSavePrevInstrAgentCode",
                                 "CheckSaveIntermediaryBankCode",
                                 "CheckSaveReceiverBankCode",
                                 "CheckSavePrevInstrAgentAccount",
                                 "CheckSaveIntermediaryBankAccount",
                                 "CheckSaveReceiverBankAccount",
                                 "CheckSavePrevInstrAgentAccountIsMask",
                                 "CheckSaveIntermediaryBankAccountIsMask",
                                 "CheckSaveReceiverBankAccountIsMask",
                                 "CheckSavePrevInstrAgentAccountKey",
                                 "CheckSaveIntermediaryBankAccountKey",
                                 "CheckSaveReceiverBankAccountKey",
                                 "CheckSaveCheckPayerBankExistence",
                                 "CheckSaveCheckReceiverBankExistence",
                                 "CheckSaveSenderBankExistAndOpened",
                                 "CheckSaveSenderBankCodeBIC",
                                 "CheckSaveSenderBankPartInPSBR",
                                 "CheckSaveSenderBankRestrictPartInPSBR",
                                 "CheckSaveSenderBankAccountRKC",
                                 "CheckSaveSenderBankIsCorschemDepartment",
                                 "CheckSaveSenderBankIsOurDep",
                                 "CheckSaveExecutorBankExistAndOpened",
                                 "CheckSaveExecutorBankCodeBIC",
                                 "CheckSaveExecutorBankPartInPSBR",
                                 "CheckSaveExecutorBankRestrictPartInPSBR",
                                 "CheckSaveExecutorBankAccountRKC" );
                                  
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;
               
/**
 * Проверки для мемордеров
 */
macro BBMO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckNumber",
                                 "CheckBaseAmount",
                                 "CheckSaveFIID",
                                 "CheckSaveRate",
                                 "CheckSaveDate",
                                 "CheckSaveValueDate",
                                 "CheckSaveCurrentDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSavePayerAccountSet",
                                 "CheckSavePayerAccountOk",
                                 "CheckSavePayerAccountOpr",
                                 "CheckSaveReceiverAccountIsSet",
                                 "CheckSaveReceiverAccountOk",
                                 "CheckSaveReceiverAccountOpr",     
                                 "CheckSaveGround",
                                 "CheckSaveReceiverAccountWithAddPI",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk"
                                 );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для инкассовых поручений к валютному счёту
 */
macro INRQ_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm, pmserv ):integer
  var checks:TArray = makeArray( "CheckSavePaymentDate",
                                 "CheckSaveOldDoc",
                                 "CheckSavePayerBankEnterDate",
                                 "CheckSavePayerNameOk",
                                 "CheckSaveReceiverNameOk",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveReceiverAccountOk",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk",
                                 "CheckSave383PLength",
                                 "CheckSaveIsHCSPayment",
                                 "CheckSaveReceiverBank" );
  checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm, pmserv );
end;

/**
 * Проверки для кассовых документов
 */
macro CS_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray;
  if( InList( pm_paym.DocKind, CASH_PS_OUTORDER, CASH_BOF_OUTORDER, DLDOC_INOUTORDER ) )
    checks = makeArray( "CheckSavePayerAccountIs302P",
                        "CheckSaveReceiverAccountIs302P",
                        "CheckSaveSpecialPayerAccount",
                        "CheckSaveSpecialReceiverAccount" ,
                        "CheckSaveNumberPack",
                        "CheckSaveRate",               
                        "CheckSavePayerAccountOpr",
                        "CheckSaveReceiverAccountOpr");
  else
    checks = TArray();
  end;
  checks[ checks.size ] = "CheckSaveCurrentDate";
  checks[ checks.size ] = "CheckSaveValueDateIsBalance";
 
  if( InList( pm_paym.DocKind, CASH_PS_INCORDER, CASH_BOF_INCORDER ) )
    checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  end;

  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для входящих платежей
 */
macro RMIN_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSaveOldDoc",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSavePayerNameOk",
                                 "CheckSaveReceiverNameOk",
                                 "CheckSaveTransferDate" );
  
    checks[checks.size] = "CheckSavePermissibilityPayerBankCorrAcc";
    checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для входящих поручений банка
 */
macro RMIN_ScrolMacroCommonChecksForBankPayorder( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckBaseAmount",
                                 "CheckSavePriority",                                 
                                 "CheckSaveDate",
                                 "CheckSavePaymentDate",
                                 "CheckSaveValueDateIsBalance", 
                                 "CheckSavePrevInstrAgentExistAndOpened",
                                 "CheckSaveIntermediaryBankExistAndOpened",
                                 "CheckSaveReceiverBankExistAndOpened",
                                 "CheckSavePrevInstrAgentExistAndOpened",
                                 "CheckSaveIntermediaryBankExistAndOpened",
                                 "CheckSaveReceiverBankExistAndOpened",
                                 "CheckSaveReceiverBankIsOurDep",
                                 "CheckSaveSenderBankExistAndOpened",
                                 "CheckSaveSenderBankCodeBIC",
                                 "CheckSaveSenderBankAccountRKC",
                                 "CheckSaveExecutorBankExistAndOpened",
                                 "CheckSaveExecutorBankCodeBIC",
                                 "CheckSaveExecutorBankAccountRKC",
                                 "CheckSaveExecutorBankIsCorschemDepartment",
                                 "CheckSaveExecutorBankIsOurDep");
                                  
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;


/**
 * Проверки для ЭСИД
 */
macro CL_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  
  var checks:TArray = TArray();
  
  checks[checks.size] = "CheckNumber";
  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ))
    checks[checks.size] = "CheckNumberForRKC";
    checks[checks.size] = "CheckPaymentType";
  end;
  checks[checks.size] = "CheckBaseAmount";

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_IN_PMCLAIM, DLDOC_IN_PMCOL ))
    checks[checks.size] = "CheckSavePriority";
  end;
  
  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL, DLDOC_IN_PMCLAIM ))
    checks[checks.size] = "CheckSaveNumberPack";
  end;
  
  checks[checks.size] = "CheckSaveDate";
  
  if( InList( pm_paym.DocKind, DLDOC_IN_PMCOL, DLDOC_IN_PMCLAIM ) )
    checks[checks.size] = "CheckSavePayerBankEnterDate";
  end;
  
  if( InList( pm_paym.DocKind, DLDOC_IN_PMCLAIM ) )
    checks[checks.size] = "CheckSavePayerBankEnterDateCLAIM";
  end;
  
  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM ) )
    checks[checks.size] = "CheckSaveReceiverBankMarkDateCLAIM";
  end;

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSaveReceiverBankMarkDate";
    checks[checks.size] = "CheckReceiverBankMarkDateNoOld";
  end;
  
  checks[checks.size] = "CheckSavePayerBank";

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSavePayerBankBIC";
    checks[checks.size] = "CheckSavePayerBankCorrAcc";
  end;

  if( InList( pm_paym.DocKind, DLDOC_IN_PMCLAIM, DLDOC_IN_PMCOL ))
    checks[checks.size] = "CheckSavePayerAccountSet";
  end;
  
  checks[checks.size] = "CheckSavePayerAccountOk";
  checks[checks.size] = "CheckSavePayerAccountIs302P";

  if( InList( pm_paym.DocKind, DLDOC_IN_PMCLAIM, DLDOC_IN_PMCOL ))
    checks[checks.size] = "CheckSavePayerAccountIsMask";
  end;

  checks[checks.size] = "CheckSavePayerNameSet";

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSavePayerNameOk";
  end;

  if( InList( pm_paym.DocKind, DLDOC_IN_PMCLAIM, DLDOC_IN_PMCOL ))
    checks[checks.size] = "CheckSaveReceiverBank";
  end;

  checks[checks.size] = "CheckSaveReceiverBankBIC";

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSaveReceiverBankCorrAcc";
  end;

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSaveReceiverAccountIsSet";
  end;
  
  checks[checks.size] = "CheckSaveReceiverAccountIs302P";
  checks[checks.size] = "CheckSaveReceiverAccountIsMask";
  checks[checks.size] = "CheckSaveReceiverAccountOk";
  
  checks[checks.size] = "CheckSaveReceiverNameSet";

  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSaveReceiverNameOk";
  end;

  checks[checks.size] = "CheckSaveGround";
  
  if( InList( pm_paym.DocKind, DLDOC_IN_PMCLAIM, DLDOC_IN_PMCOL ))
    checks[checks.size] = "CheckSavePayerAccountIsNotCorAcc";
    checks[checks.size] = "CheckSavePayerAccountMFR";
  end;
  
  checks[checks.size] = "CheckSaveReceiverAccountMFR";

  
  if( pm_paym.DocKind == DLDOC_IN_PMCOL )
    checks[checks.size] = "CheckSavePayerIBAN";
  end;

  if( pm_paym.DocKind == DLDOC_OUT_PMCOL )
    checks[checks.size] = "CheckSaveReceiverIBAN";
  end;

  checks[checks.size] = "CheckSave383PLength";
  checks[checks.size] = "CheckSaveNumberIsZero";
 
  if( InList( pm_paym.DocKind, DLDOC_OUT_PMCLAIM, DLDOC_OUT_PMCOL ) )
    checks[checks.size] = "CheckSavePermissibilityPayerBankCorrAcc";
    checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  end;
  
  if( InList( pm_paym.DocKind, DLDOC_IN_PMCLAIM, DLDOC_IN_PMCOL ) )
    checks[checks.size] = "CheckSavePermissibilityRecBankCorrAcc";
  end;
  
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

