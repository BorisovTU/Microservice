 /*
 $Name:        pmbo3.mac
 $Module:      Ядро Банкинг
 $Description: Макрос шага
 */

//-----------------------------------------------------------------------------
// Блок     : 29010 - "Обработка в БО"
// Шаг      : 30    - "Проверка отредактированного платежа"
// Описание : Макрос шага
//-----------------------------------------------------------------------------
import PaymInter, cbsttls, pm_setst, OprInter, lnpaym, "pm_const.mac", BankInter;
var PaymentObj:RsbPayment;
var CurrAddPI      :TRecHandler = TRecHandler( "pmaddpi.dbt" );

private macro isExists( Acc:string, Chapt:integer, FIID:integer ):bool

  VAR select:string = " select 1 " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account ";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapt ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Acc ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    return true;
  else
    return false;
  end;
end;

// счёт существует
private macro GetErrAccList_isExists( PaymentObj:RsbPayment ):string
  
  var accStr:string = "",
      accExists:bool = false,
      isNext, AddPI;

  accExists = isExists( PaymentObj.FuturePayerAccount, CHAPT1, PaymentObj.FuturePayerFIID );
  if( not accExists )
    accStr = accStr + PaymentObj.FuturePayerAccount;
  end;
  accExists = isExists( PaymentObj.FutureReceiverAccount, CHAPT1, PaymentObj.FutureReceiverFIID );
  if( not accExists )
    accStr = accStr + PaymentObj.FutureReceiverAccount;
  end;
  //если есть разноска по какой-то из сторон  
  AddPI  = PaymentObj.PIList(PRT_Debet);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accExists = isExists( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( not accExists )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  AddPI  = PaymentObj.PIList(PRT_Credit);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accExists = isExists( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( not accExists )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  return accStr;
end;

private macro isOpen( Acc:string, Chapt:integer, FIID:integer ):bool

  VAR select:string = " select 1 " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account "+
                      "   and acc.T_Open_Close = chr(0)";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapt ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Acc ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    return true;
  else
    return false;
  end;
end;

// счёт открыт
private macro GetErrAccList_isOpen( PaymentObj:RsbPayment ):string
  
  var accStr:string = "",
      accOpen:bool = false,
      isNext, AddPI;

  accOpen = isOpen( PaymentObj.FuturePayerAccount, CHAPT1, PaymentObj.FuturePayerFIID );
  if( not accOpen )
    accStr = accStr + PaymentObj.FuturePayerAccount;
  end;
  accOpen = isOpen( PaymentObj.FutureReceiverAccount, CHAPT1, PaymentObj.FutureReceiverFIID );
  if( not accOpen )
    accStr = accStr + PaymentObj.FutureReceiverAccount;
  end;
  //если есть разноска по какой-то из сторон  
  AddPI  = PaymentObj.PIList(PRT_Debet);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accOpen = isOpen( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( not accOpen )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  AddPI  = PaymentObj.PIList(PRT_Credit);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accOpen = isExists( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( not accOpen )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  return accStr;
end;

private macro letDebet( Acc:string, Chapt:integer, FIID:integer ):bool
  VAR select:string = " select acc.t_type_account, acc.t_DateNoChange " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account ";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapt ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Acc ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    if( Index( rset.Value(0), "Т" ) > 0 )
      return false;
    end;
    if( date(rset.Value(1)) != date(0,0,0) ) 
      if( date(rset.Value(1)) < PaymentObj.ValueDate  ) 
        return false;
      end;
    end;
  end;
  return true;  
end;

// разрешено дебетование
private macro GetErrAccList_letDebet( PaymentObj:RsbPayment ):string
  
  var accStr:string = "",
      accDebet:bool = false,
      isNext, AddPI;

  accDebet = letDebet( PaymentObj.FuturePayerAccount, CHAPT1, PaymentObj.FuturePayerFIID );
  if( not accDebet )
    accStr = accStr + PaymentObj.FuturePayerAccount;
  end;
  //если есть разноска по дебету
  AddPI  = PaymentObj.PIList(PRT_Debet);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accDebet = letDebet( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( not accDebet )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  return accStr;
end;

private macro letCredit( Acc:string, Chapt:integer, FIID:integer ):bool
  VAR select:string = " select acc.t_type_account, acc.t_DateNoChange " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account ";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapt ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Acc ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    if( Index( rset.Value(0), "У" ) > 0 )
      return false;
    end;
    if( date(rset.Value(1)) != date(0,0,0) ) 
      if( date(rset.Value(1)) < PaymentObj.ValueDate )
        return false;
      end;
    end;
  end;
  return true;  
end;

// разрешено кредитование
private macro GetErrAccList_letCredit( PaymentObj:RsbPayment ):string
  
  var accStr:string = "",
      accCredit:bool = false,
      isNext, AddPI;

  accCredit = letCredit( PaymentObj.FutureReceiverAccount, CHAPT1, PaymentObj.FutureReceiverFIID );
  if( not accCredit )
    accStr = accStr + PaymentObj.FutureReceiverAccount;
  end;
  //если есть разноска по кредиту
  AddPI  = PaymentObj.PIList(PRT_Credit);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accCredit = letCredit( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( not accCredit )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  return accStr;
end;

private macro getDep( Acc:string, Chapt:integer, FIID:integer ):integer

  VAR select:string = " select acc.t_department " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account ";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapt ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Acc ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    return rset.Value(0);
  else
    return -1;
  end;
end;

// принадлежит филиалу
private macro GetErrAccList_rightDep( PaymentObj:RsbPayment ):string
  
  var accStr:string = "",
      accDep:integer = 0,
      isNext, AddPI;

  accDep = getDep( PaymentObj.FutureReceiverAccount, CHAPT1, PaymentObj.FutureReceiverFIID );
  if( accDep != PaymentObj.Department )
    accStr = accStr + PaymentObj.FutureReceiverAccount;
  end;
  accDep = getDep( PaymentObj.FuturePayerAccount, CHAPT1, PaymentObj.FuturePayerFIID );
  if( accDep != PaymentObj.Department )
    accStr = accStr + PaymentObj.FuturePayerAccount;
  end;
  //если есть разноска по какой-то из сторон  
  AddPI  = PaymentObj.PIList(PRT_Debet);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accDep = getDep( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( accDep != PaymentObj.StartDepartment  )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  AddPI  = PaymentObj.PIList(PRT_Credit);
  isNext = AddPI.First(0);
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    accDep = getDep( CurrAddPI.rec.Account, CHAPT1, CurrAddPI.rec.FIID );
    if( accDep != PaymentObj.EndDepartment  )
      accStr = accStr + CurrAddPI.rec.Account;
    end;
    isNext = AddPI.Next();
  end;
  return accStr;
end;

private macro isClientAccounts( PaymentObj:RsbPayment ):bool

  var AddPI  = PaymentObj.PIList(PRT_Credit),
      isNext = AddPI.First(0);
//pmpaym.FutureReceiverAccount клиентский или (есть разноска по кредиту и хотя бы один из счетов разноски клиентский)
  if( not PM_IsBankAccount( PaymentObj.FutureReceiverAccount, PaymentObj.FutureReceiverFIID ) )
    return true;
  end;
  
  while( (isNext == 0) and (AddPI.Current( CurrAddPI ) == 0) )
    if( not PM_IsBankAccount( CurrAddPI.rec.Account, CurrAddPI.rec.FIID ) )
      return true;
    end;
    isNext = AddPI.Next();
  end;
  return false;
end;

//-----------------------------------------------------------------------------
// Выполнение шаг
//-----------------------------------------------------------------------------
//MACRO ExecuteStep( doc, paymDoc )
MACRO ExecuteCaseStep(Kind_Operation, Number_Step, paymDoc, KindDoc)
  var Department:integer = 0,
      Type_Account:string = "",
      Client:integer = 0,
      DateNoChange:date,
      accExists:bool = false,
      erraccList:string = "",
      stat = 0,
      regval:bool = false,
      err = 0,                                                
      error = "Платеж № " + PaymentObj.Number + " от " + PaymentObj.ValueDate + " некорректно отредактирован в бэк-офисе: ";

  if(PaymentObj.CheckTerror == CHT_NOTCHECK)
    if( GetDialogFlag() )
      msgbox("Внимание! По платежу не выполнена проверка на необходимость приостановления или блокирования операции в целях ПОД/ФТ. Необходимо проверить платеж в ручном режиме");
    else
      CreateWarning(null, PAYMERR_TERR_NOTCHECKED);
    end;
  end;

  erraccList = GetErrAccList_isExists( PaymentObj );
  if( StrLen(erraccList) > 0 )
    error = error + "\nНе найден(ы) счет(а): " + erraccList;
    stat = 1;
  end;
  // является открытым на дату pmpaym.ValueDate
  erraccList = GetErrAccList_isOpen( PaymentObj );
  if( StrLen(erraccList) > 0 )
    error = error + "\nЗакрыт(ы) счет(а): " + erraccList;
    stat = 1;
  end;
  // По счету со стороны дебета разрешена операция дебета (в типе счета отсутствует "Т" (Арест на дебет)) 
  erraccList = GetErrAccList_letDebet( PaymentObj );
  if( StrLen(erraccList) > 0 )
    error = error + "\nЗапрещено дебетование: " + erraccList;
    stat = 1;
  end;
  // По счету со стороны кредита разрешена операция кредита (в типе счета отсутствует "У" (Арест на кредит)) 
  erraccList = GetErrAccList_letCredit( PaymentObj );
  if( StrLen(erraccList) > 0 )
    error = error + "\nЗапрещено кредитование: " + erraccList;
    stat = 1;
  end;
  //Cчета по дебету принадлежат банку филиалу  pmpaym.StartDepartment, счета по кредиту принадлежат филиалу pmpaym.endDepartment.
  erraccList = GetErrAccList_rightDep( PaymentObj );
  if( StrLen(erraccList) > 0 )
    error = error + "\nПринадлежит(ат) другому филиалу счет(а): " + erraccList;
    stat = 1;
  end;

  if( PaymentObj.PrimDocKind == 320 ) 
    error = error + "\nПлатеж будет помещен в невыясненные";
  else
    error = error + "\nПлатеж будет отвергнут";
  end;

  //В единичном режиме вывести сообщение на экран, в групповом сформировать предупреждение, которое вывести потом в протокол выполнения шага
  if( stat and GetDialogFlag() )
    MsgBox( error );
  end;

  if( stat )
    // Установить примечание "Причина отказа" = сформированное сообщение
    if( PaymentObj.Notes.AddNote( PM_NOTEKIND_DENIALGROUND, error ) != 0 )
      msgbox( "Ошибка при вставке примечания платежа" );
      return "";
    end;

    if( PaymentObj.PrimDocKind == 320 )
      if( УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, OPR_PAYM_ST_INDEX_UNKNOWN ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return "";
      end;
    else
      if( УстановитьСтатусыПлатежа( OPR_PAYM_STATE, OPR_PM_ST_REJECT ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return "";
      end;
    end;
  end;
 
  if( not stat )
    GetRegistryValue("АРМ ПОЗИЦИОНЕРА\\ЗАЧИСЛЕНИЕ\\ПОДТВЕРЖДЕНИЕ ВТОРЫМ ЛИЦОМ", V_BOOL, regval, err);
    if( regval and (PaymentObj.PrimDocKind == 320) and isClientAccounts( PaymentObj ) )
      return "40";
    else
      return "";
    end;
  end;
  
  return "";
END;