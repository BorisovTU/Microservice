/**                                                                                                             
 @file ParseCftClientSPI.mac                                                                                
 @brief AVT_BOSS-1223. Для возврата излишне уплаченного НДФЛ требуется выгружать сведения о последнем открытом в ЦФТ текущем счете клиента (40817...).
                                                                                                                                                                                                                                                                                                                            
 # changeLog                                                                                                    
 |date       |author         |tasks               |note                                                         
 |-----------|---------------|--------------------|-------------------------------------------------------------
 |2025.10.22 |Шестаков Д.В.  |BOSS-1223           |Создание макроса  для счетов СПИ                                                                                                                                                                                                                                                                                      
*/ 

import OprInter, rsd, RsbDataSet, SQLCONV, dlmisc, RsbFormsInter, "globals.mac", "func_lib.mac";


private var IsNtr = isStandalone();

/**
 @brief коррекция терминального имени для копирования
 @param[in] путь к фалу
 @return скорректированный путь к фалу
*/    
PRIVATE MACRO fnam4copy(p)
   if (not isNtr)
      if (substr(p, 1, 1) == "$")
         return p;
      end;
      return string("$", p);
   end;
   return p;
end;

/*
@brief Функция копирования файлов с сервера на терминал/с терминала на сервер
@param[in] filepath путь к выбранному файлу
@param[in] copyServ True - копирование на сервер приложений, False - копирование на териминальник
@return string актуальный путь после копирования
*/
PRIVATE MACRO SaveFile(filepath:string, copyServ:bool):string
    
    if(not IsNtr) 
      var file_name, file_ext, path_work;
      SplitFile(filepath, file_name, file_ext);  
      file_name = MergeFile("", file_name, + file_ext);
      
      if(copyServ) // когда мы на терминале, копируем файл на СП
         path_work = "..\\workfile\\" + file_name;
         if(not CopyFile(fnam4copy(filepath), path_work, true, "Копируется файл на сервер приложений..."))
            runerror("Ошибка копирования файла с терминала на сервер", "Ошибка копирования файла с терминала на сервер " + toOem(filepath));
         end;
         filepath = path_work;

      else // когда мы на терминале, копируем файл c севера на терминал
         path_work = GetCurDir(true) + "\\txtfile\\" + file_name;
         if(not CopyFile(filepath,fnam4copy(path_work), true, "Копируется файл на терминал..."))
            runerror("Ошибка копирования файла с сервера на терминал", "Ошибка копирования файла с сервера на терминал " + toOem(filepath));
         end;
         filepath = path_work;
      end;      
    end;
    
    return filepath;
end;

/*
@brief Функция формирования шапки протокола
*/
PRIVATE MACRO CreateHeaderWithError()

  [ ];
  [    Протокол ; ];
  [   ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐];
  [   │     Ошибка                                                                                                                                                                                                                 │];
  [   ├────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤];

end;

/*
@brief Функция формирования шапки протокола
*/
PRIVATE MACRO CreateHeader()

  [ ];
  [    Протокол ; ];

end;

/*
@brief Функция печати строки в протокол
@param[in] ErrDesc текст ошибки выполнения процедуры
*/
PRIVATE MACRO AddRow(ErrDesc)

      [   │ ###########################################################################################################################################################################################################################│](ErrDesc);
      [   ├────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤];
end;

/*
@brief Функция печати строки в протокол по статистике
@param[in] all    количество всех обработанных
@param[in] errors количество ошибочных
*/
PRIVATE MACRO AddStatistics(all,errors)

   [
        Итого обработано                           = ##### шт.
        Обработано с ошибками                      = ##### шт.
   ]
(
  all,
  errors
);
END;

/*
@brief Функция парсинга строчки по разделителю
@param[in] inputStr текст из файла csv
*/
PRIVATE MACRO ParseCftCLient(inputStr:string) 
   var sql, cmd;

   sql = 
         "BEGIN                       "+
         "   ValidateAndParseCftClient(:input_str); "+
         "END;  ";
    
   cmd = RSDCommand(sql);
   cmd.addParam("input_str", RSDBP_IN, inputStr);
   cmd.execute();
   cmd.close(); cmd = NULL; sql = NULL;
 
END; 

/*
@brief Функция печати статистики
*/
PRIVATE MACRO printStatistics() 
   var sql            :String,
       cmd            :Object,
       DataSet        :Object,
       allCnt         :Integer,
       errCnt         :Integer;

   sql = " SELECT COUNT(*) t_cnt, 'ALL' t_tp FROM DPROTOCOLVALIDATECFT_TMP "
       + "   UNION ALL "
       + " SELECT COUNT(*) t_cnt, 'ERR' t_tp FROM DPROTOCOLVALIDATECFT_TMP"
       + " WHERE t_error_code = 1";

   cmd = RSDCommand(sql);
   DataSet = TRsbDataSet(cmd);

   while(DataSet.moveNext())
      if(DataSet.tp == "ALL")
        allCnt = DataSet.cnt;
      else
        errCnt = DataSet.cnt; 
      end;
   end;

   AddStatistics(allCnt,errCnt);
END;

/*
@brief Функция печати ошибочно обработанных строк
*/
PRIVATE MACRO printErrorDesc() 
   var sql            :String,
       cmd            :Object,
       DataSet        :Object;

   sql = " SELECT T_MESSAGE FROM DPROTOCOLVALIDATECFT_TMP"
       + " WHERE t_error_code = 1"
       + " ORDER BY t_id";

   cmd = RSDCommand(sql);
   DataSet = TRsbDataSet(cmd);

   while(DataSet.moveNext())
      AddRow(DataSet.T_MESSAGE);
   end;
END;

/*
@brief Функция загрузки файла *.csv 
*/
PRIVATE MACRO execLoadClientSPI()
    
   var fileName      :string, 
       extName       :string, 
       mask          :string = "*.csv",
       fileFullName  :string = "",
       filePath      :string = string("Import"),
       onTerm        :bool   = true,
       filenameOutput  :string = "Протокол_загрузки_СПИ_" + string(UserNumber) + ".txt",
       logFullNameFile :string = "..\\txtfile\\"+ filenameOutput,
       cmd             :object,
       cnt             :integer;

   file datafile()    txt;
   file output_file() txt write;

   debugbreak;
  filePath = "$\\..\\" + filePath + "\\"  + mask;
  if (not SelectFile(fileFullName, filePath, "Выберите файл для загрузки", 0, onTerm))
    MsgBox("Файл не выбран");
    return false;
  end;
  splitfile(fileFullName, fileName, extName);

   fileFullName = SaveFile(fileFullName, true);

   if (not Open(datafile, fileFullName, "rsansi")) 
      MsgBox("Ошибка открытия файла " + fileFullName);
   end;

   SQL_Execute("DELETE FROM DPROTOCOLVALIDATECFT_TMP");

   Rewind( datafile );
   while ( Next(datafile) )
      ParseCftCLient(datafile.Str);
   end;
   Close(datafile);

	if(not Open(output_file, logFullNameFile))
    	runerror("Ошибка при открытии файла протокола|" + logFullNameFile);
  	end;

   cmd = DL_RSDCommand("SELECT * FROM DPROTOCOLVALIDATECFT_TMP WHERE T_ERROR_CODE <> 0");

    cnt = cmd.GetCount();

   SetOutput(logFullNameFile); 
   
   if (cnt > 0 ) 
      CreateHeaderWithError();
      printErrorDesc();
   else
      CreateHeader();
   end;
   
   printStatistics();
   SetOutput(null, true);
  	Close(output_file);
	
  	//доставим загружаемый файл на терминал
  	logFullNameFile = SaveFile(logFullNameFile, False);
   //Покажем файл отчёта на экран
  	ViewFile(output_file); 

END;

if (Gettrue(false, "Необходимо ли загрузить файл со списком счетов клиентов?"))
   execLoadClientSPI();
end;
  
