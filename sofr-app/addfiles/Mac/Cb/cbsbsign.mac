/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/*        Формирование блока данных для ключевания сообщений SBRF3          */
/*                                                                          */
/*  Имя файла: sbchkey.mac                                                  */
/*  Создан:    10.07.02                                      Алешин А.В.    */
/****************************************************************************/

import PTInter, "cbsbtls.mac";

/* Варианты формирования блока данных в зависимости от типа и подтипа документа */
const BUFTYPE_BASE    = 1, /* 001(), 002(), 003(), 004(), 005(), 704(), 705(), 001(4), 005(4) */
      BUFTYPE_REFUSAL = 2, /* 601, 602, 603, 604, 605 */
      BUFTYPE_CONFIRM = 3, /* 101, 102, 104, 105 */
      BUFTYPE_INFO    = 4, /* 007 */
      BUFTYPE_SWIFT   = 5, /* 001(0), 002(0), 003(0), 004(0), 005(0), 001(1), 005(1) */
      BUFTYPE_TRANSF  = 6; /* 001(2), 005(2), 001(3), 005(3) */

const TAG_DELIMETER = "\n"; /* Разделитель данных при формировании блока */

const DONT_ADD = "_ERROR_"; /* Это значение должен вернуть Rules, если поле не нужно включать в блок */

const SC_BY_DEF = "11"; /* Значение тэга "SC" по умолчанию */

const MAX_FLD_BLOCK_LEN = 140; /* Максимальная длина данных поля, которая должна участвовать в формированиии блока */

/* 1. Поля документа включаются в блок данных в кодировке ASCII
   2. При включении полей документа в блок данных из них удаляются все пробелы 
   (шестнадцатеричный код ASCII - 0x20 
      Считаем, что все поля уже в кодировке OEM, поэтому не конвертим
   3. Поля при выводе в блок данных разделяются символом перевода строки 
   (шестнадцатеричный код ASCII - 0x0A). Разделитель добавляется в блок данных 
   даже, если поле является пустым и в блок данных выводится как строка 
   нулевой длины    */
macro Rules( str );
  return String( StrSubst( str, " ", "" ), TAG_DELIMETER );
end;

/* 2.4.  Числовые поля, содержащие описание номеров документов, выводятся в 
   блок данных без лидирующих нулей. Если поле имеет нулевое значение, 
   то оно выводится в блок данных как строка нулевой длины*/
macro Rules1( str, SBRFStr )
  
  while( SubStr( str, 1, 1 ) == "0" )    
    str = substr( str, 2 );
  end;

  return str;
end;

/* 2.2. Даты выводятся в блок данных в виде 6-байтовой текстовой строки 
   в формате ДДММГГ (день, месяц, год) с дополнением лидирующими нулями. 
   Например, 2 августа 2001 года - 020801. Пустые даты в блок данных 
   включаются как строка нулевой длины */
macro Rules2( str, SBRFStr )
  return str;
end;

/* 2.5. Числовые поля, содержащие суммы, представляются в виде целого числа 
   (например, сумма в рублях переводится в копейки) и выводятся в блок данных 
   без лидирующих нулей и каких бы то ни было разделителей. Если поле имеет 
   нулевое значение, то оно выводится в блок данных как строка нулевой длины */
macro Rules3( str, SBRFStr )
  while( SubStr( str, 1, 1 ) == "0" )    
    str = substr( str, 2 );
  end;
  return str;
end;

/* Идентификатор документа (дата создания, участник-создатель, номер) хранится 
   в транспортном файле в виде строки постоянной длины (22 символа). 
   Вышеназванные поля выводятся в блок данных как отдельные поля, 
   разграниченные символами 0x0A в соответствии с п.2.6 */
macro Rules4( str, SBRFStr )
  return str;
end;

/* Поле PT включается в блок данных в том же виде, как оно передается 
   в транспортном файле формата SBRF3. Если в транспортном файле отсутствует 
   поле РТ, то в блок данных выводится значение по умолчанию - 1201 */
macro Rules5( str, SBRFStr )
  if( str == "" )
    str = ТипОбслуживанияПоУмолчанию;
  end;
  return str;
end;

/* Поле SC включается в блок данных в том же виде, как оно передается в 
   транспортном файле формата SBRF3. Если в транспортном файле отсутствует 
   тэг SC, то в блок данных выводится значение по умолчанию - 11 */
macro Rules6( str, SBRFStr )
  if( str == "" )
    str = SC_BY_DEF;
  end;
  return str;
end;

/* Поле ST включается в блок данных в том же виде, как оно передается в 
   транспортном файле: первые 6 байт - дата создания в формате ДДММГГ, 
   следующие 10 байт - код участника-создателя, следующие 6 байт - номер 
   документа, выровненный слева нулями. Если в транспортном файле отсутствует 
   тэг ST, то в блок данных выводится строка нулевой длины */
macro Rules7( str, SBRFStr )
  return str;
end;

/* В сообщении участнику текст размещается в трех полях транспортного файла. 
   В блок данных они включаются одним целым в следующем порядке - MP, PP, PN. 
   При этом между полями не вставляется разделитель 0х0А */
macro Rules8( str, SBRFStr )
  var val_MP = "", val_PP = "", val_PN = "";

  ReadFieldSBRF3( val_MP, "MP", SBRFStr );
  ReadFieldSBRF3( val_PP, "PP", SBRFStr );
  ReadFieldSBRF3( val_PN, "PN", SBRFStr );

  str = val_MP + val_PP + val_PN;

  return str;
end;

/* Если значение поля состоит более чем из 140 символов, то в блок данных 
   включаются только первые 140 символов. При этом необходимо учитывать, 
   что удаление пробелов производится только после выделения этих 140 символов */
macro Rules9( str, SBRFStr )
  if( strlen( str) > MAX_FLD_BLOCK_LEN )
    str = SubStr( str, 1, MAX_FLD_BLOCK_LEN );
  end;
  return str;
end;

/* Поле включается в блок данных только при значении поля UT равном 5 */
macro Rules10( str, SBRFStr )
  var val_UT = "";
  
  if( (not ReadFieldSBRF3( val_UT, "UT", SBRFStr )) OR (val_UT != sub_type_5) )
    return DONT_ADD;
  end;

  return str;
end;

var ПоляБлокаДанных = Tarray;

class ТПолеБлока( _name, _rules_fun1, _rules_fun2 )
  var Name:string          = "",
      RulesFun1:string     = "",
      RulesFun2:string     = "";

  Name          = _name;
  RulesFun1     = _rules_fun1;
  RulesFun2     = _rules_fun2;

  /* Добавляем поле в список полей */
  ПоляБлокаДанных(ПоляБлокаДанных.Size) = this;

  macro ОбработатьПолеФормы( buff )
    var tempStr = "", val = "";

    /* Получаем значение конкретного поля */  
    ReadFieldSBRF3( val, Name, buff );

    /* Если заданы дополнительные правила обработки поля */
    if( (RulesFun1 != "") OR (RulesFun2 != "") )
      
      if( RulesFun1 != "" )
        tempStr = ExecMacro2( RulesFun1, val, buff );
        if( tempStr == DONT_ADD )
          return "";
        end;
      end;

      if( (RulesFun2 != "") )
        tempStr = ExecMacro2( RulesFun2, tempStr, buff );
        if( tempStr == DONT_ADD )
          return "";
        end;
      end;
      
      return Rules(tempStr);
    else
      return Rules(val);
    end;

  end;

end; /* class ТПолеБлока */

/* Создание списка полей, участвующих в формировании блока данных */
macro MakeBlockFld( type )
  GenObject( "ТПолеБлока", SB_Tag_CreateDate, "Rules2", "Rules4" );
  GenObject( "ТПолеБлока", SB_Tag_Creator, "Rules4", "" );
  GenObject( "ТПолеБлока", SB_Tag_Number, "Rules1", "Rules4" );
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR ((type == BUFTYPE_TRANSF)) )
    GenObject( "ТПолеБлока", "AM", "Rules3", "" );
    GenObject( "ТПолеБлока", "BC", "", "" );
    GenObject( "ТПолеБлока", "BN", "", "" );
    GenObject( "ТПолеБлока", "CU", "", "" );
  end;
  GenObject( "ТПолеБлока", "DT", "", "" );
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "ED", "Rules2", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR ((type == BUFTYPE_TRANSF)) )
    GenObject( "ТПолеБлока", "IB", "", "" );
    GenObject( "ТПолеБлока", "IC", "", "" );
    GenObject( "ТПолеБлока", "IS", "", "" );
  end;  
  GenObject( "ТПолеБлока", "LD", "Rules2", "" );
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR ((type == BUFTYPE_TRANSF)) )
    GenObject( "ТПолеБлока", "MP", "", "" );
  elif( type == BUFTYPE_INFO )
    GenObject( "ТПолеБлока", "MP", "Rules8", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_INFO) OR (type == BUFTYPE_SWIFT) OR ((type == BUFTYPE_TRANSF)) )
    GenObject( "ТПолеБлока", "MT", "", "" );
  end;
  GenObject( "ТПолеБлока", "PA", "", "" );
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "PN", "", "" );
  elif( type == BUFTYPE_SWIFT )
    GenObject( "ТПолеБлока", "PN", "Rules9", "" );
  end;
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "PP", "", "" );
  elif( type == BUFTYPE_SWIFT )
    GenObject( "ТПолеБлока", "PP", "Rules9", "" );
  end;
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "PT", "Rules5", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) )
    GenObject( "ТПолеБлока", "RA", "", "" );
  end;
  GenObject( "ТПолеБлока", "RC", "", "" );
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "RF", "", "" );
    GenObject( "ТПолеБлока", "RI", "", "" );
  end;
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "RN", "", "" );
  elif( type == BUFTYPE_SWIFT )
    GenObject( "ТПолеБлока", "RN", "Rules9", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR (type == BUFTYPE_TRANSF) )
    GenObject( "ТПолеБлока", "RS", "", "" );
  end;
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "SA", "", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR (type == BUFTYPE_TRANSF) )
    GenObject( "ТПолеБлока", "SB", "", "" );
  end;
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "SC", "Rules6", "" );
    GenObject( "ТПолеБлока", "SD", "Rules2", "" );
    GenObject( "ТПолеБлока", "SF", "", "" );
    GenObject( "ТПолеБлока", "SI", "", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR (type == BUFTYPE_TRANSF) )
    GenObject( "ТПолеБлока", "SN", "", "" );
    GenObject( "ТПолеБлока", "SS", "", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_INFO) )
    GenObject( "ТПолеБлока", "ST", "Rules7", "" );
  end;
  if( (type == BUFTYPE_BASE) OR (type == BUFTYPE_SWIFT) OR (type == BUFTYPE_TRANSF) )
    GenObject( "ТПолеБлока", "VD", "Rules2", "" );
  end;
  if( type == BUFTYPE_REFUSAL )
    GenObject( "ТПолеБлока", "WR", "", "" );
  end;
  if( type == BUFTYPE_BASE )
    GenObject( "ТПолеБлока", "UO", "Rules10", "" );
    GenObject( "ТПолеБлока", "TD", "Rules10", "" );
    GenObject( "ТПолеБлока", "DU", "Rules10", "" );
    GenObject( "ТПолеБлока", "AD", "Rules2", "Rules10" );
    GenObject( "ТПолеБлока", "AA", "Rules10", "" );
  end;
end;

/* Непосредственное формирование блока данных */
macro MakeDataInit( SBRFStr )
  var count = 0, fld, BlockStr = "", str;

  while( count < ПоляБлокаДанных.size )
    fld = ПоляБлокаДанных.Value(count);
    str = fld.ОбработатьПолеФормы( SBRFStr );
    BlockStr = BlockStr + str;
    count = count + 1;
  end;

  return BlockStr;
end;

/* Формирование блока данных для ключевания СБРФ 
   Возращаемое значение:
   TRUE  - блок данных сформирован
   FALSE - в лучае ошибки */
macro CB_FormingDataInit
( 
  ClientID:integer,   /* Идентификатор участника, на которого ключуем сообщение */
  SBRFStr:string,     /* Строка в формате СБРФ3-сообщения */
  Block:string        /* Возвращаемое значение, блок данных */
)
  var BlockStr = "", type = BUFTYPE_BASE, type_doc = type_undef, 
      sub_type_doc = sub_type_undef, val_LD, error, FormName = sign_0B1;

  /* Определим вариант формирования блока данных в зависимости от типа (подтипа)
     документа */
  ReadFieldSBRF3( type_doc,     SB_Tag_TypeDoc,    SBRFStr );
  ReadFieldSBRF3( sub_type_doc, SB_Tag_SubTypeDoc, SBRFStr );
  ReadFieldSBRF3( FormName,     SB_Tag_Sign,       SBRFStr );

  /* Если в сообщении не указан тип документа, то определяем  его по номеру формы */
  if( type_doc == type_undef )
    if( FormName == sign_0B1 )
      type_doc = type_001;
    elif( FormName == sign_0B2 )
      type_doc = type_002;
    elif( FormName == sign_0B3 )
      type_doc = type_003;
    elif( FormName == sign_0B4 )
      type_doc = type_004;
    elif( FormName == sign_0B5 )
      type_doc = type_005;
    elif( FormName == sign_0B6 )
      type_doc = type_601;
    elif( FormName == sign_0B7 )
      type_doc = type_007;
    elif( FormName == sign_0BB )
      type_doc = type_101;
    elif( FormName == sign_0BG )
      type_doc = type_704;
    elif( FormName == sign_0BH )
      type_doc = type_705;
    else
      type_doc = type_001;
    end;
  end;

  if(   ((type_doc == type_001) AND (sub_type_doc == sub_type_undef)) OR 
        ((type_doc == type_002) AND (sub_type_doc == sub_type_undef)) OR
        ((type_doc == type_003) AND (sub_type_doc == sub_type_undef)) OR
        ((type_doc == type_004) AND (sub_type_doc == sub_type_undef)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_undef)) OR
        ((type_doc == type_704) AND (sub_type_doc == sub_type_undef)) OR
        ((type_doc == type_705) AND (sub_type_doc == sub_type_undef)) OR
        ((type_doc == type_001) AND (sub_type_doc == sub_type_4)) OR
        ((type_doc == type_001) AND (sub_type_doc == sub_type_5)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_4)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_5)) )
    type = BUFTYPE_BASE;
  elif( (type_doc == type_601) OR (type_doc == type_602) OR
        (type_doc == type_603) OR (type_doc == type_604) OR
        (type_doc == type_605) )
    type = BUFTYPE_REFUSAL;
  elif( (type_doc == type_101) OR (type_doc == type_102) OR
        (type_doc == type_104) OR (type_doc == type_105) )
    type = BUFTYPE_CONFIRM;
  elif( type_doc == type_007 )
    type = BUFTYPE_INFO;
  elif( ((type_doc == type_001) AND (sub_type_doc == sub_type_0)) OR
        ((type_doc == type_002) AND (sub_type_doc == sub_type_0)) OR
        ((type_doc == type_003) AND (sub_type_doc == sub_type_0)) OR
        ((type_doc == type_004) AND (sub_type_doc == sub_type_0)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_0)) OR
        ((type_doc == type_001) AND (sub_type_doc == sub_type_1)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_1)) )
    type = BUFTYPE_SWIFT;
  elif( ((type_doc == type_001) AND (sub_type_doc == sub_type_2)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_2)) OR
        ((type_doc == type_001) AND (sub_type_doc == sub_type_3)) OR
        ((type_doc == type_005) AND (sub_type_doc == sub_type_3)) )
    type = BUFTYPE_SWIFT;
  else
    type = BUFTYPE_BASE;
  end;

  MakeBlockFld( type );
  BlockStr = MakeDataInit( SBRFStr );

  /* Очищаем массив */
  ПоляБлокаДанных = Tarray;

  /* Разделитель не выводится в блок данных после последнего поля */  
  if( SubStr( BlockStr, StrLen(BlockStr) - StrLen(TAG_DELIMETER) + 1, StrLen(TAG_DELIMETER) ) == TAG_DELIMETER )
    BlockStr = SubStr( BlockStr, 1, StrLen(BlockStr) - StrLen(TAG_DELIMETER) );
  end;

  /* Следующие строки не регламентированы инструкцией 680-П, однако они 
     обязательно нужны для выбора ключа криптоплагином ключевания cpsbrf.dll 
     Первые     6 символов - дата ключа, 
     следующие 10 символов - идентификатор участника */  
  if( not ReadFieldSBRF3( val_LD, SB_Tag_LastDate, SBRFStr ))
    ReadFieldSBRF3( val_LD, SB_Tag_CreateDate, SBRFStr );
  end;

  BlockStr = val_LD + ПолучитьКодСубъекта(ClientID, PTCK_CLIRING, error) + BlockStr;
  if( error )
    MsgBox( "Не найден код клиринга для внешнего абонента сообщения" );
    return FALSE;
  end;

  SetParm( 2, BlockStr );

  return TRUE;
end;

