/*──────────────────────────────────────────────────────────────────────────────────────────┐
  RS-Bank 6.0                                                         R-Style Software Lab

  File Name   : rb_updsf.mac
  Created     : 03.09.2011
  Programmer  : Popova O.
  Description : Обработка объектов банковских продуктов вида РКО при создании ДО

└───────────────────────────────────────────────────────────────────────────────────────────*/
import BankInter, SfInter, CtInter, PTInter, oralib, likepy;

// Допустимые виды документов для вида продукта РКО ( PRD_KIND_PAYMENT_SERVICE )
private const DOCKIND_SFCONTR = 402;            // "Договор обслуживания"

// Допустимые виды объектов для вида продукта РКО ( PRD_KIND_PAYMENT_SERVICE )
private const OBJPRD_KIND_CUSTOM_ACCOUNT = 1;   // Расчетный счет
private const OBJPRD_KIND_CURR_ACCOUNT   = 2;   // Текущий счет
private const OBJPRD_KIND_TRANS_ACCOUNT  = 3;   // Транзитный счет

private macro getAccount( Account:string, Chapter:integer, FIID:integer, recAcc:TRecHandler ):bool

  var fAcc = TBFile("account.dbt" , "R", 0, "account.dbt" , "bank.def");
  fAcc.rec.Code_Currency = FIID;
  fAcc.rec.Chapter       = Chapter;
  fAcc.rec.Account       = Account;
  if( not fAcc.GetEQ() )
    msgbox( "Не найден счет ", Account );
    return false;
  end;
  copy( recAcc, fAcc );
  return true;
end;

private macro СоздатьОбъектПродуктаКлиента( ClientProductID     :integer,      /* ID продукта клиента */ 
                                            ParentID            :integer,      /* Вышестоящий объекта продукта клиента */
                                            AccRecord           :TRecHandler,  /* Объект продукта - счет */
                                            ObjectProductKindID :integer,      /* ID допустимого для продукта вида объекта */ 
                                            BeginDate           :date,         /* Дата регистрации объекта для продукта */
                                            EndDate             :date          /* Дата прекращение использования объекта для продукта */
                                          ):string

  var ProductObj:RsbProductObject = RsbProductObject();
  var ErrMsg:string = "";

  ProductObj.ClientProductID      = ClientProductID;
  ProductObj.ParentID             = ParentID;
  ProductObj.ObjectProductKindID  = ObjectProductKindID;
  ProductObj.ObjectID             = UniID( AccRecord, OBJTYPE_ACCOUNT );
  ProductObj.ObjectNumber         = AccRecord.rec.Account;
  ProductObj.BeginDate            = BeginDate;

  ProductObj.AddProductObject( ErrMsg );

  // отметим дату прекращения использования объекта
  if( EndDate != date(0,0,0) )
    ProductObj.CloseProductObject( ErrMsg, EndDate );
  end;

  SetParm( 6, ProductObj.ClntProdObjID );

  return ErrMsg;
end;

// Вспомогательные классы
private class ОбъектыПродуктаКлиента( _ProductObj:RsbClientProduct )

  var ProductObj:RsbClientProduct = _ProductObj;
  var ObjectList:TArray = TArray(); // список объектов продукта ProductObj, массив из RsbProductObject
  _ProductObj.GetObjectsList( ObjectList );

end;

private class ОбъектыПродуктовКлиентаДляСчета( Account:string, Chapter:integer, FIID:integer )

  var Acc:TRecHandler = TRecHandler("account");
  var ОбъектыСчета = TArray(); // массив из ОбъектыПродуктаКлиента

  macro AddProduct( _ProductObj:RsbClientProduct )
    ОбъектыСчета[ОбъектыСчета.size] = ОбъектыПродуктаКлиента( _ProductObj );
  end;

  // Конструктор
  getAccount( Account, Chapter, FIID, Acc );
end;

private macro getSfContrID( Account:TRecHandler )

  var SfContr = TbFile( "sfcontr.dbt", "R", 1 );
  SfContr.rec.ServKind    = PTSK_PAY;
  SfContr.rec.ObjectType  = SF_ACCOUNT;
  SfContr.rec.FIID        = Account.rec.Code_Currency;
  SfContr.rec.Object      = Account.rec.Account;
  if( SfContr.GetEQ() )
    return SfContr.rec.ID;
  end;
  return -1;
end;

private macro СписокОбъектовПродуктаОсновныхСчетовПоТранзитному( Account:string, Chapter:integer, FIID:integer ):TArray

  var ProductList = TArray(),  // Список продуктов клиента
      retListElem:ОбъектыПродуктовКлиентаДляСчета = NULL,
      retvalList  = TArray(),  // массив объектов ОбъектыПродуктовКлиентаДляСчета
      i = 0;

  var BPrdObj:object = NULL;     // prdproduct.dbt

  var select = "", params = TArray(), rs:object = NULL;

  var TrAccount:TRecHandler = TRecHandler( "account" ); // запись транзитного счета
  var  _Account:TRecHandler = TRecHandler( "account" ); // запись основного счета

  if( getAccount( Account, Chapter, FIID, TrAccount ) and Index( TrAccount.rec.Type_Account, "Y" ) )

    // для транзитного счета найдем все основные
    select = "select t_ObjectID from dobjlink_dbt where t_ObjectType = :ObjType"+
             " and t_AttrID = :AttrID and t_GroupID = :GroupID and t_AttrType = :AttrType"; 

    params = makeArray( SQLParam( "ObjType" , OBJTYPE_ACCOUNT                     ),
                        SQLParam( "AttrID"  , UniID( TrAccount, OBJTYPE_ACCOUNT ) ),
                        SQLParam( "GroupID" , OBJROLE_ACC_TRANSIT                 ),
                        SQLParam( "AttrType", OBJTYPE_ACCOUNT                     ) );

    rs = execSQLselect( select, params, FALSE );

    while( rs and rs.MoveNext() )
      RestoreFromUniID( rs.Value(0), _Account, OBJTYPE_ACCOUNT ); 
      retListElem = ОбъектыПродуктовКлиентаДляСчета( _Account.rec.Account, _Account.rec.Chapter, _Account.rec.Code_Currency );
      // получить список продуктов клиента счета
      if( BP_GetClientProductsList( ProductList, retListElem.Acc.rec.Client ) )
        i = 0;
        while( i < ProductList.size )
          // из списка выберем БП клиента вида "РКО" привязанные к ДО основного счета
          if( ProductList[i].SfContrID == getSfContrID( retListElem.Acc ) )
            BPrdObj = RsbBankProduct( ProductList[i].ProductID );
            if( ( BPrdObj.ProductKindID     == PRD_KIND_PAYMENT_SERVICE/*РКО*/ ) and 
                ( BPrdObj.ProductDocKindID  == DOCKIND_SFCONTR/*ДО*/           ) and
                ( BPrdObj.ServiceKind       == PTSK_PAY /*РКО*/                ) )
              retListElem.AddProduct( ProductList[i] );
            end;
          end;
          i = i + 1;
        end;
      end;
      retvalList[retvalList.size] = retListElem;
    end;
  end;
  return retvalList;
end;

private macro НайтиОбъектПродуктаВида( ObjectList:TArray, ObjectKindID:integer, Account:TRecHandler ):object
  var i = 0;
  while( i < ObjectList.size )
    if( ( ObjectList[i].ObjectType          == OBJTYPE_ACCOUNT ) and 
        ( ObjectList[i].ObjectProductKindID == ObjectKindID    ) and
        ( ObjectList[i].ObjectID            == UniID( Account, OBJTYPE_ACCOUNT ) ) )
      return ObjectList[i];
    end;
    i = i + 1;
  end;
  return NULL;
end;

// Функция вызывается при создании ДО 
// 0 - в случае успеха 
// Или строку с ошибкой 
// Или номер ошибки 
macro RB_CreateSfContr( SfContr, PrdClient )

  var BPrdObj :object = NULL;     // prdproduct.dbt

  var ErrMsg = "", parentID = 0, i = 0, j = 0;
  var ObjList = TArray(), 
      MainProductObject   :object = NULL, // основной объект продукта клиента
      TransitProductObject:object = NULL; // объект продукта клиента транзитного счета

  var trSfContr = TbFile( "sfcontr.dbt", "R", 1 );   // ДО для транзитного счета
  var ClntProdObjID = 0; //ID объекта продукта клиента по основному счету

  if( SfContr.ObjectType != SF_ACCOUNT )
    return 0;
  end;

  var acc:TRecHandler = TRecHandler( "account" ); // счет по ДО
  getAccount( SfContr.Object, 1/*CHAPT1*/, SfContr.FIID, acc );

  if( PrdClient.ProductID > 0 )
    BPrdObj = RsbBankProduct( PrdClient.ProductID );
    if( ( BPrdObj.ProductKindID     == PRD_KIND_PAYMENT_SERVICE/*РКО*/ ) and 
        ( BPrdObj.ProductDocKindID  == DOCKIND_SFCONTR/*ДО*/           ) and
        ( BPrdObj.ServiceKind       == PTSK_PAY /*РКО*/                ) )
      // Создаем объект продукта клиента для счета по ДО
      ErrMsg = СоздатьОбъектПродуктаКлиента( PrdClient.ClientProductID, 0, acc,
                                             IfThenElse( SfContr.FIID == 0/*NATCUR*/, OBJPRD_KIND_CUSTOM_ACCOUNT, OBJPRD_KIND_CURR_ACCOUNT ), 
                                             SfContr.DateBegin, date(0,0,0), ClntProdObjID );
      if( ErrMsg != "" )
        return ErrMsg;
      end;
      // если есть связанный транзитный счет, надо создать объект и для него
      if( GetLinkedObject( OBJROLE_ACC_TRANSIT, OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ), OBJTYPE_ACCOUNT, acc ) == 0 )
        trSfContr.rec.ServKind     = PTSK_PAY;
        trSfContr.rec.ObjectType   = SF_ACCOUNT;
        trSfContr.rec.FIID         = acc.rec.Code_Currency;
        trSfContr.rec.Object       = acc.rec.Account;
        GetEQ( trSfContr );  // ДО по транзитному счету может не быть, это не ошибка
        ErrMsg = СоздатьОбъектПродуктаКлиента( PrdClient.ClientProductID, ClntProdObjID, acc, OBJPRD_KIND_TRANS_ACCOUNT, 
                                               IfThenElse( trSfContr.rec.ID > 0, trSfContr.rec.DateBegin, SfContr.DateBegin ), 
                                               IfThenElse( trSfContr.rec.ID > 0, trSfContr.rec.DateClose, SfContr.DateClose ) );
        if( ErrMsg != "" )
          return ErrMsg;
        end;
      end;
    end;
  else // не передан PrdClient - создается объект по транзитному счету

    // Для каждого основного счета, привязанного к транзитному, должен быть создан объект продукта клиента по транзитному счету
    ObjList = СписокОбъектовПродуктаОсновныхСчетовПоТранзитному( SfContr.object, 1/*CHAPT1*/, SfContr.FIID );

    while( i < ObjList.size ) // цикл по счетам
      j = 0;
      while( j < ObjList[i].ОбъектыСчета.size ) // цикл по продуктам счета
        // найдем основной объект продукта
        MainProductObject = НайтиОбъектПродуктаВида( ObjList[i].ОбъектыСчета[j].ObjectList, IfThenElse( ObjList[i].Acc.rec.Code_Currency == 0/*NATCUR*/, 
                                                     OBJPRD_KIND_CUSTOM_ACCOUNT, OBJPRD_KIND_CURR_ACCOUNT ), ObjList[i].Acc );
        // найдем объект продукта транзитного счета
        TransitProductObject = НайтиОбъектПродуктаВида( ObjList[i].ОбъектыСчета[j].ObjectList, OBJPRD_KIND_TRANS_ACCOUNT, acc );
        // если объект транзитного счета не найден, нужно его создать
        if( TransitProductObject == NULL )
          if( MainProductObject != NULL )
            parentID = MainProductObject.ClntProdObjID;
          end; 
          ErrMsg = СоздатьОбъектПродуктаКлиента( ObjList[i].ОбъектыСчета[j].ProductObj.ClientProductID, parentID, 
                                                 acc, OBJPRD_KIND_TRANS_ACCOUNT, SfContr.DateBegin, SfContr.DateClose );
        end;
        j = j + 1;
      end;
      i = i + 1;
    end;
  end;
 
  return ErrMsg;
end;


// Функция вызывается при обновлении ДО 
macro RB_UpdateSfContr( SfContr, OldSfContr, PrdClient, OldPrdClient )

  if( SfContr.ObjectType != SF_ACCOUNT )
    return 0;
  end;

  // при смене продукта создадим объекты продукта для основного и транзитного счетов
  if( PrdClient.ProductID != OldPrdClient.ProductID )
    return RB_CreateSfContr( SfContr, PrdClient );
  end;

  var acc:TRecHandler = TRecHandler( "account" ); // счет по ДО
  var ObjList = TArray(), 
      TransitProductObject:object = NULL; // объект продукта клиента транзитного счета
  var ErrMsg = "", i = 0, j = 0;

  // при смене даты заключения/расторжения ДО для транзитного счета изменим даты в объектах продукта
  if( ( SfContr.DateBegin != OldSfContr.DateBegin ) or ( SfContr.DateClose != OldSfContr.DateClose ) )
    if( ( getAccount( SfContr.Object, 1/*CHAPT1*/, SfContr.FIID, acc ) and Index( acc.rec.Type_Account, "Y" ) ) and
        ( PrdClient.ProductID == 0 ) )

      ObjList = СписокОбъектовПродуктаОсновныхСчетовПоТранзитному( SfContr.object, 1/*CHAPT1*/, SfContr.FIID );

      while( i < ObjList.size ) // цикл по счетам
        j = 0;
        while( j < ObjList[i].ОбъектыСчета.size ) // цикл по продуктам счета
          // найдем объект продукта транзитного счета
          TransitProductObject = НайтиОбъектПродуктаВида( ObjList[i].ОбъектыСчета[j].ObjectList, OBJPRD_KIND_TRANS_ACCOUNT, ObjList[i].Acc );
          // если объект транзитного счета найден, обновим его
          if( TransitProductObject != NULL )
            TransitProductObject.BeginDate = SfContr.DateBegin;
            TransitProductObject.EndDate   = SfContr.DateClose;
            TransitProductObject.UpdateProductObject( ErrMsg );
          end;
          j = j + 1;
        end;
        i = i + 1;
      end;
    end;
  end;

  return ErrMsg;
end; 


// Функция вызывается перед удалением ДО 
macro RB_DeleteSfContr( SfContr )

  if( SfContr.ObjectType != SF_ACCOUNT )
    return 0;
  end;

  // при удалении ДО по транзитному счету удалим все его объекты продукта
  var acc:TRecHandler = TRecHandler( "account" ); // счет по ДО
  var ObjList = TArray(), 
      TransitProductObject:object = NULL; // объект продукта клиента транзитного счета
  var ErrMsg = "", i = 0, j = 0;
  
  if( getAccount( SfContr.Object, 1/*CHAPT1*/, SfContr.FIID, acc ) and Index( acc.rec.Type_Account, "Y" ) )

    ObjList = СписокОбъектовПродуктаОсновныхСчетовПоТранзитному( SfContr.object, 1/*CHAPT1*/, SfContr.FIID );

    while( i < ObjList.size ) // цикл по счетам
      j = 0;
      while( j < ObjList[i].ОбъектыСчета.size ) // цикл по продуктам счета
        // найдем объект продукта транзитного счета
        TransitProductObject = НайтиОбъектПродуктаВида( ObjList[i].ОбъектыСчета[j].ObjectList, OBJPRD_KIND_TRANS_ACCOUNT, ObjList[i].Acc );
        // если объект транзитного счета найден, удалим его
        if( TransitProductObject != NULL )
          TransitProductObject.DeleteProductObject( ErrMsg );
        end;
        j = j + 1;
      end;
      i = i + 1;
    end;
  end;
  return ErrMsg;
end; 
