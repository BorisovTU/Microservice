/*
 $Name: res_fun.mac
 $Module: Ядро ГКБО 
 $Description: Вспомогательные функции для формирования резервов
 */
/*
 *  Вспомогательные функции для формирования резервов
 */
Import BankInter, FIInter, CTInter, Календарь, "res_const.mac", RSD, oralib, likepy;

/* Является ли субъект нашим банком */
macro IsOurBank(PartyID):bool

  /*if(PartyID == {OurBank})
    return true;
  end;*/

  var select:string = "SELECT count(1) " +
                       " FROM ddp_dep_dbt dep " +
                      " WHERE dep.t_PartyID  = :PartyID ";
          
  var params:TArray = makeArray(SQLParam("PartyID", PartyID));
  var rset:RsdRecordset = execSQLselect(select, params, false);

  if((NOT rset) OR (NOT rset.moveNext()) OR (rset.value(0) == 0))
    return false;
  end;

  return true;
END;

/* Найти код классификации */
private macro GetElementByRsvClass( Classificator : integer, Element : integer ) : string
  
  file llclass ( "llclass.dbt"  );
  record llvalues( "llvalues.dbt" );

  llclass.Classificator = Classificator;
  if( getEQ(llclass) )
    
    if( LL_FindLLVALUES(llclass.List, Element, llvalues) )
      return llvalues.Code;
    end;
  
  end;

  return "";

end;

/* получить первое число месяца, в который входит данная дата */
private macro GetFirstDateOfMonth( MonthDate )
  var mon, year;

  DateSplit( MonthDate, null, mon, year );

  return Date( 1, mon, year );

end;

/* получить последнее число месяца, в который входит данная дата */
private macro GetLastDateOfMonth( MonthDate )

  var FirstDateOfNextMonth = DateAfterCalenMonths( MonthDate, 1 );

  return GetFirstDateOfMonth( FirstDateOfNextMonth ) - 1;

end;

/* получить буфер счета */
private macro GetAccountRecord( accRec, Chapter : integer, Account : string, FIID : integer ) : bool
  file acc ("account.dbt" ) key 0;
  acc.Chapter       = Chapter;
  acc.Account       = Account;
  acc.Code_Currency = FIID;
  if( getEQ( acc ) )
    Copy( accRec, acc );
    return true;
  end;
  return false;
end;

/* получить буфер портфеля */
private macro GetAcCaseRecord( accaseRec, CaseID : integer ) : bool
  file accase("accase.dbt") key 0;

  accase.CaseID = CaseID;
  if( GetEQ(accase) )
    Copy( accaseRec, accase );
    return true;
  end;
  return false;
end;


/* получить значение примечания счета */
private macro GetAccountNote( Chapter : integer, FIID : integer, Account : string, NoteKind : integer, DateNote : date )
  record accRec("account.dbt");
  var Note;
  var DateFrom = null;
  
  if( GetAccountRecord(accRec, Chapter, Account, FIID) )
    
    Note = readNoteForObject( OBJTYPE_ACCOUNT, UniID(accRec, OBJTYPE_ACCOUNT), NoteKind, DateNote, DateFrom );

    if( (DateFrom == null) or (DateFrom == Date(0, 0, 0)) )
      Note = null;
    end;
  
  end;

  return Note;

end;

/* получить связанный счет для счета */
private macro GetAccountLinkObject( accRec, ObjRole : integer )
  record LinkAccountRec("account.dbt");
  var LinkAccount = null;
  
  if( GetLinkedObject(ObjRole, OBJTYPE_ACCOUNT, UniID(accRec, OBJTYPE_ACCOUNT), OBJTYPE_ACCOUNT, LinkAccountRec) == 0 )
    LinkAccount = LinkAccountRec.Account;
  end;

  return LinkAccount;

end;

/* получить остаток по модулю на счете за дату */
private macro GetAccRest( accRec, DateRest, RestCurrency )
  
  var RestAcc = RestA( accRec.Account, DateRest, null, accRec.Chapter, accRec.Code_Currency, RestCurrency );

  if( RestAcc < $0 )
    RestAcc = -RestAcc;
  end;

  return RestAcc;

end;



/* получить значение настройки для определения минимального процента резервирования */
private macro GetReservePercentFromRegistry( TypeReserveRegPath : string )
  var err : integer;
  var ReservePercent : double;
  
  GetRegistryValue( ReserveRegistryPath + TypeReserveRegPath, V_DOUBLE, ReservePercent, err );
  if( err != 0 ) 
    ReservePercent = null; 
    MsgBox ("Не задано значение настройки ", ReserveRegistryPath + TypeReserveRegPath); 
  end;

  return ReservePercent;
end;

/*
 * Получить процент резервирования по контрагенту для счета
 */
macro GetProcentOfReserveContr( Chapter : integer, FIID : integer, Account : string, DateProcent : date ) : double
  return GetAccountNote( Chapter, FIID, Account, AccNoteKind_ReserveProcentContr, DateProcent );
end;

/*
 * Получить процент резервирования РВП для счета
 */
macro GetProcentOfReserve( Chapter : integer, FIID : integer, Account : string, DateProcent : date ) : double
  return GetAccountNote( Chapter, FIID, Account, AccNoteKind_ReserveProcent, DateProcent );
end;

/*
 * Получить процент резервирования РОФШ для счета
 */
macro GetProcentOfReserveOffshore( Chapter : integer, FIID : integer, Account : string, DateProcent : date ) : double
  return GetAccountNote( Chapter, FIID, Account, AccNoteKind_ReserveProcentOffshore, DateProcent );
end;

/*
 * Получить процент оценочного резерва для счета
 */
macro GetProcentOfReserveEstimated( Chapter : integer, FIID : integer, Account : string, DateProcent : date ) : double
  return GetAccountNote( Chapter, FIID, Account, AccNoteKind_ReserveEstimated, DateProcent );
end;

/*
 * Получить минимальный процент резерва для счета
 */
macro GetAccountMinPercentReserve( Chapter : integer, FIID : integer, Account : string, DateProcent : date ) : double
  var MinPercentReserve = GetAccountNote( Chapter, FIID, Account, AccNoteKind_MinPercentReserve, DateProcent );
  if(MinPercentReserve == null)
    MinPercentReserve = $0;
  end;
  return MinPercentReserve;
end;

/*
 * Получить минимальный процент резервирования РВП
 */
macro GetMinReserveProcent( RiskGroup : integer ) : double
  return GetReservePercentFromRegistry( "РВП\\" + string(RiskGroup) );
end;

/*
 * Получить минимальный процент резервирования РВПС
 */
macro GetMinReserveProcentLoans( RiskGroup : integer ) : double
  return GetReservePercentFromRegistry( "РВПС\\" + string(RiskGroup) );
end;

/*
 * Получить минимальный процент резервирования РВП для портфеля
 */
macro GetMinReserveProcentCase( RiskGroup : integer ) : double
  return GetReservePercentFromRegistry( "РВП ПОТ\\" + string(RiskGroup) );
end;

/*
 * Получить минимальный процент резервирования РВПС для портфеля
 */
macro GetMinReserveProcentLoansCase( RiskGroup : integer ) : double
  return GetReservePercentFromRegistry( "РВПС ПОС\\" + string(RiskGroup) );
end;

/*
 * Получить минимальный процент резервирования РОФШ
 */
macro GetMinReserveProcentOffshore( OffshoreGroup : integer ) : double
  return GetReservePercentFromRegistry( "РОФШ\\" + string(OffshoreGroup) );
end;

/*
 * Получить категорию обеспечения
 */
macro GetCategoryOfEnsuring( Chapter : integer, FIID : integer, Account : string, DateProcent : date ) : string
  return GetAccountNote( Chapter, FIID, Account, AccNoteKind_EnsuringCategory, DateProcent );
end;

/*
 * Получить дату обращения взыскания на налог
 */
macro GetPawnCollectionDate( Chapter : integer, FIID : integer, Account : string ) : date
  return GetAccountNote( Chapter, FIID, Account, AccNoteKind_PawnCollectionDate );
end;

/*
 * Получить максимальный остаток за период
 */
macro GetMaxAccRest( accRec, DateFrom : date, DateTo : date ) : money
  
  var _curDate = DateFrom;
  var RestMax = $0, _curDateRest : money;

  while( _curDate <= DateTo )
    _curDateRest = GetAccRest( accRec, _curDate, NATCUR );
    if( RestMax < _curDateRest )
      RestMax = _curDateRest;
    end;

    _curDate = _curDate + 1;
  end;

  return RestMax;

end;


/*
 * Получить максимальный остаток за за каждый рабочий день периода
 */
macro GetMaxAccRestWork( accRec, DateFrom : date, DateTo : date ) : money
  
  var _curDate = DateFrom;
  var RestMax = $0, _curDateRest : money;

  while( _curDate <= DateTo )
    if( IsWorkday(_curDate) )
      _curDateRest = GetAccRest( accRec, _curDate, NATCUR );
      if( abs(RestMax) < abs(_curDateRest) )
        RestMax = abs(_curDateRest);
      end;
    end;
    _curDate = _curDate + 1;
  end;

  return RestMax;

end;

/*
 * Получить максимальный остаток за отчетный период, в который входит дата резерва
 */
macro GetMaxAbsAccRest( accRec, DateReserve : date ) : money
  
  var DateFrom : date, DateTo : date;

  DateFrom = GetFirstDateOfMonth( DateReserve );
  DateTo   = GetLastDateOfMonth( DateReserve );

  return GetMaxAccRest( accRec, DateFrom, DateTo );

end;


/*
 * максимальный остаток по счету в течение последних 30 календарных дней за каждый рабочий день периода
 */
macro GetMaxAbsAcc30DayRest( accRec, DateReserve : date ) : money
  
  var DateFrom : date, DateTo : date;

  DateTo   = DateReserve ;
  DateFrom = DateReserve - 30;

  return GetMaxAccRestWork( accRec, DateFrom, DateTo );

end;


/*
 * Получить среднедневной дебетовый оборот за отчетный период, в который входит дата резерва
 */
macro GetAverageAccDebetTurn30Day( accRec, DateReserve : date, Open_Date : date ) : money
  
  var nWorkDays : integer;
  var turnDate : money, DebetTurn : money;
  var DateFrom : date, DateTo : date, _curDate : date;

  DateFrom = DateReserve - 29 ;
  if(DateFrom < Open_Date) 
    DateFrom = Open_Date; 
  end;
  DateTo   = DateReserve ;

  _curDate = DateFrom;
  DebetTurn = $0; nWorkDays = 0;
  while( _curDate <= DateTo )
    
//    if( IsWorkday(_curDate) )
      
      turnDate = DebetA( accRec.Account, _curDate, null, accRec.Chapter, accRec.Code_Currency, NATCUR );

      if( turnDate < $0 )
        turnDate = -turnDate;
      end;

      DebetTurn = DebetTurn + turnDate;
      nWorkDays = nWorkDays + 1;

//    end;

    _curDate = _curDate + 1;

  end;

  return DebetTurn / nWorkDays;

end;


/*
 * Получить среднедневной дебетовый оборот за отчетный период, в который входит дата резерва
 */
macro GetAverageAccDebetTurn( accRec, DateReserve : date ) : money
  
  var nWorkDays : integer;
  var turnDate : money, DebetTurn : money;
  var DateFrom : date, DateTo : date, _curDate : date;

  DateFrom = GetFirstDateOfMonth( DateReserve );
  DateTo   = GetLastDateOfMonth( DateReserve );

  _curDate = DateFrom;
  DebetTurn = $0; nWorkDays = 0;
  while( _curDate <= DateTo )
    
    if( IsWorkday(_curDate) )
      
      turnDate = DebetA( accRec.Account, _curDate, null, accRec.Chapter, accRec.Code_Currency, NATCUR );

      if( turnDate < $0 )
        turnDate = -turnDate;
      end;

      DebetTurn = DebetTurn + turnDate;
      nWorkDays = nWorkDays + 1;

    end;

    _curDate = _curDate + 1;

  end;

  return DebetTurn / nWorkDays;

end;

/*
 * Получить коэффициент обеспечения
 */
macro GetCoefficientOfEnsuring( EnsuringCategory : integer, PawnCollectionDate : date, DateReserve : date ) : double
  var Coefficient = null;
  var Period = DateReserve - PawnCollectionDate;

  if( Period < 0 ) Period = 0; end;
  
  if( EnsuringCategory == 1 )
    
      if( Period > 545 ) Coefficient = 0;
    elif( Period > 365 ) Coefficient = 0.5;
    elif( Period > 270 ) Coefficient = 0.7;
    else                 Coefficient = 1; end;
  
  elif( EnsuringCategory == 2 )
  
      if( Period > 545 ) Coefficient = 0;
    elif( Period > 365 ) Coefficient = 0.25;
    elif( Period > 270 ) Coefficient = 0.35;
    else                 Coefficient = 0.5; end;

  end;
  
  return Coefficient;
end;

/*
 * Получить счет резерва для портфеля
 */
macro GetReserveAccount( CaseID : integer ) : string
  file accase("accase.dbt") key 0;
  record accasscs("accasscs.dbt");
  var ReserveAccount = null;

  accase.CaseID = CaseID;
  if( GetEQ(accase) )
    ClearRecord(accasscs);
    ReserveAccount = GetAccountReserveForCase(accase, accasscs);
  end;
  if( ReserveAccount == "" ) ReserveAccount = null; end;

  return ReserveAccount;
end;

/*
 * Получить счет резерва для лицевого счета
 */
macro GetAccCaseReserveAccount( Chapter : integer, FIID : integer, Account : string ) : string
  record accRec("account.dbt");
  var ReserveAccount = null;

  if( GetAccountRecord(accRec, Chapter, Account, FIID) )
    
    /* сначала ищем счет, сформированный через категории учета */
    ReserveAccount = CB_GetAccountReserve( accRec );

    if( ReserveAccount == "" )
      /* если нет, то ищем в связанных объектах */
      ReserveAccount = GetAccountLinkObject( accRec, AccObjRole_AccountReserve );
    end;
        
    if( ReserveAccount == "" ) ReserveAccount = null; end;
  
  end;

  return ReserveAccount;
end;

private macro GetAcSubcaseRecord( acSubcaseRec, CaseID : integer, DateFrom : date) : bool

  file accassub("accassub.dbt") key 0;
  var rs;

  rs = RsdRecordset("SELECT /*+FIRST_ROWS*/ t.t_CaseID, t.t_DateFrom, t.t_ReserveType " +
                    "FROM daccassub_dbt t " +
                    "WHERE t.t_CaseID = " + CaseID +
                    "  AND t.t_DateFrom <= TO_DATE('" + DateFrom + "') " +
                    "ORDER BY t.t_CaseID DESC, t.t_DateFrom DESC, t.t_ReserveType DESC");
  if( rs.movenext )
    accassub.CaseID      = CaseID;
    accassub.DateFrom    = rs.value(1);
    accassub.ReserveType = rs.value(2);

    if( GetEQ(accassub) )
      Copy( acSubcaseRec, accassub );
      return true;
    end;
  end;

  return false;

end;

/*
 * Получить классификацию РВП
 */
macro GetClassifReserve( Chapter : integer, FIID : integer, Account : string, DateClassif : date ) : string
  record rsvprm("rsvprm.dbt");
  record accase("accase.dbt");
  record accasepm("accasepm.dbt");
  record accassub("accassub.dbt");
  var CaseID : integer;
  var Classif = null;
  
  CaseID = GetCaseOfAccount( Chapter, FIID, Account, DateClassif );

  if( (CaseID == null) or (CaseID == 0) )
    /* счет не входит ни в один из портфелей */
    ClearRecord( rsvprm );
    if( (CB_GetRsvParmForAccount(DateClassif, Account, Chapter, rsvprm)) and (rsvprm.ParamID != 0) )
      Classif = GetElementByRsvClass( LLCLASS_RSRVLOSS_BY_ACC, rsvprm.RsvClass );
    end;
  else
    /* счет входит в портфель - возвращаем классификацию для портфеля */
    if( (GetAcCaseRecord(accase, CaseID)) and (accase.ReserveKind == ACCASE_RESERVEKIND_RVP) )
      if( GetACCASEPM_on_Date(CaseID, DateClassif, accasepm) )
        if ( GetAcSubcaseRecord(accassub, CaseID, DateClassif) )   
          Classif = GetElementByRsvClass( LLCLASS_RSRVLOSS_BY_CASE, accassub.ReserveType );
        end;
      end;
    end;
  end;

  return Classif;
end;

/*
 * Получить классификацию РВПС
 */
macro GetClassifReserveLoans( Chapter : integer, FIID : integer, Account : string, DateClassif : date ) : string
  record rsvprm("rsvprm.dbt");
  record accase("accase.dbt");
  record accasepm("accasepm.dbt");
  record accassub("accassub.dbt");
  var CaseID : integer;
  var Classif = null;
  
  CaseID = GetCaseOfAccount( Chapter, FIID, Account, DateClassif );

  if( (CaseID == null) or (CaseID == 0) )
    /* счет не входит ни в один из портфелей */
    ClearRecord( rsvprm );
    if( (CB_GetRsvParmForAccount(DateClassif, Account, Chapter, rsvprm)) and (rsvprm.ParamID != 0) )
      Classif = GetElementByRsvClass( LLCLASS_RSVLOANSLOSS_BY_ACC, rsvprm.RsvClassLoans );
    end;
  else
    /* счет входит в портфель - возвращаем классификацию для портфеля */
    if( (GetAcCaseRecord(accase, CaseID)) and (accase.ReserveKind == ACCASE_RESERVEKIND_RVPS) )
      if( GetACCASEPM_on_Date(CaseID, DateClassif, accasepm) )
        if ( GetAcSubcaseRecord(accassub, CaseID, DateClassif) )   
          Classif = GetElementByRsvClass( LLCLASS_RSRLOANSVLOSS_BY_CASE, accassub.ReserveType );
        end;
      end;
    end;
  end;

  return Classif;
end;

/*
 * Получить классификацию РОФШ
 */
macro GetClassifReserveOffshore( Chapter : integer, FIID : integer, Account : string, DateClassif : date ) : string
  record rsvprm("rsvprm.dbt");
  var CaseID : integer;
  var Classif = null;
  
  CaseID = GetCaseOfAccount( Chapter, FIID, Account, DateClassif );

  if( (CaseID == null) or (CaseID == 0) )
    /* счет не входит ни в один из портфелей */
    ClearRecord( rsvprm );
    if( (CB_GetRsvParmForAccount(DateClassif, Account, Chapter, rsvprm)) and (rsvprm.ParamID != 0) )
      Classif = GetElementByRsvClass( LLCLASS_OFFSHORERSRV, rsvprm.RsvClassOffshore );
    end;
  end;

  return Classif;
end;

/* получить фактический резерв */
private macro _GetFactReserve( ResAcc : string, DateReserve : date, SubAccID : integer, ClassifReserve : string ) : money
  var AccAnaliticsID : integer;
  var FactReserve = null;
  
  AccAnaliticsID = GetAccAnaliticsID( SYS_ANL_ACCRESERVE, ResAcc, NATCUR, BalanceChapter );
  if( SubAccID )
    /* ищем остаток на субсчете */
    if( AccAnaliticsID )
      FactReserve = RestSubAcc( AccAnaliticsID, SubAccID, DateReserve );
    end;
  elif( (AccAnaliticsID == 0) and (ClassifReserve != null) and (ClassifReserve != "") )
    /**/
    FactReserve = RestA( ResAcc, DateReserve, null, BalanceChapter );
  end;

  return FactReserve;

end;


/*
 * Получить фактический резерв РВП
 */
macro GetFactReserve( ReserveAccount : string, DateReserve : date, ClassifReserve : string ) : money
  var SubAccID : integer;
  
  /* сначала найдем субсчет */
  SubAccID = GetSubAccID( SYS_ANL_ACCRESERVE, ReserveAccount, NATCUR, BalanceChapter, RsvSubAccName );
  return _GetFactReserve( ReserveAccount, DateReserve, SubAccID, ClassifReserve );

end;

/*
 * Получить фактический резерв РВПC
 */
macro GetFactReserveLoans( ReserveAccount : string, DateReserve : date, ClassifReserve : string ) : money
  var SubAccID : integer;
  
  /* сначала найдем субсчет */
  SubAccID = GetSubAccID( SYS_ANL_ACCRESERVE, ReserveAccount, NATCUR, BalanceChapter, RsvLoansSubAccName );
  return _GetFactReserve( ReserveAccount, DateReserve, SubAccID, ClassifReserve );

end;

/*
 * Получить фактический резерв РОФШ
 */
macro GetFactReserveOffshore
(
  ReserveAccount       : string
 ,DateReserve          : date
 ,ClassReserveOffshore : string
 ,ClassReserve         : string
 ,ClassReserveLoans    : string
) : money
  var SubAccID : integer;

  if( ((ClassReserve != null) and (ClassReserve != "")) or ((ClassReserveLoans != null) and (ClassReserveLoans != "")) )
    ClassReserveOffshore = null;
  end;
  
  /* сначала найдем субсчет */
  SubAccID = GetSubAccID( SYS_ANL_ACCRESERVE, ReserveAccount, NATCUR, BalanceChapter, RsvOffshoreSubAccName );
  return _GetFactReserve( ReserveAccount, DateReserve, SubAccID, ClassReserveOffshore );

end;

/* Получение суммы просроченных требований 
    ClaimAccountFIID    - валюта счёта требований
    ClaimAccountChapter - глава счёта требований
    ClaimAccount        - номер счёта требований
    CalcDate            - дата расчёта
    OverdueTerm         - срок, после которого требования считаются просроченными
    ClaimAccMask        - маска счетов получателя, которые также надо учесть
    Sum                 - возвращаемая сумма
   Возвращает номер ошибки, 0 - успешно. */
macro GetOverdueClaimSum( ClaimAccountFIID   :integer,
                          ClaimAccountChapter:integer,
                          ClaimAccount       :string,
                          CalcDate           :date,
                          OverdueTerm        :integer,
                          ClaimAccMask       :string,
                          Sum                :@money ):integer
  
  var pOverdueMaxTerm:SQLParam = SQLParam( "p_OverdueMaxTerm", V_INTEGER, RSDBP_OUT );
  var pSum:SQLParam = SQLParam( "p_Sum", V_MONEY, RSDBP_OUT );
  var params:TArray = makeArray( SQLParam( "p_ClaimAccountFIID",    ClaimAccountFIID ),
                                 SQLParam( "p_ClaimAccountChapter", ClaimAccountChapter ),
                                 SQLParam( "p_ClaimAccount",        ClaimAccount ),
                                 SQLParam( "p_Date",                CalcDate ),
                                 SQLParam( "p_OverdueTerm",         OverdueTerm ),
                                 SQLParam( "p_ClaimAccMask",        ClaimAccMask ),
                                 pSum,
                                 pOverdueMaxTerm );
  var stat:integer = execStoredFunc( "ps.GetOverdueClaimSum", V_INTEGER, params );
  Sum = pSum.value;
  return stat;
end;
