/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/*        Формирование блока данных для ключевания сообщений Swift-SB       */
/*                                                                          */
/*  Имя файла: sbsbsign.mac                                                 */
/*  Создан:    01.09.04                                    Фомченкова Л.Н.  */
/****************************************************************************/

import PTInter, "swsbtls.mac", "cbsbtls.mac", oralib, likepy;

/* Варианты формирования блока данных в зависимости от типа и подтипа документа */
private const BUFTYPE_ANS        = 1,  /* 000(S)  ответ*/
              BUFTYPE_CONF       = 2,  /* 001(S)  подтверждение*/
              BUFTYPE_MPM        = 3,  /* 102()  сводный платеж*/
              BUFTYPE_MPMN       = 4,  /* 102(N)  сводный платеж*/
              BUFTYPE_PM         = 5,  /* 103(, S, N) обычный платеж */
              BUFTYPE_BPM        = 6,  /* 202(, S, N) банковский перевод */
              BUFTYPE_DEM        = 7,  /* 204(S) требование */
              BUFTYPE_NOT        = 8,  /* 210() уведомление */
              BUFTYPE_CONFD      = 9,  /* 900(S) подтверждение */
              BUFTYPE_CONFC      = 10, /* 910(N)  подтверждение*/
              BUFTYPE_REQ        = 11, /* n92 запрос на отмену*/
              BUFTYPE_R          = 12, /* n95 запросы*/
              BUFTYPE_A          = 13, /* n96 ответы*/
              BUFTYPE_INFO       = 14; /* n99 информационное */

private const TAG_DELIMITER   = "\n";  /* Разделитель данных при формировании блока */
private const НачалоБлокаB    = 7;     /* для 102 формы */
private const КонецБлокаB102  = 20;    /* релиз 102 */
private const КонецБлокаB102N = 18;    /* релиз 102N */
private const НачалоБлокаA    = 3;     /* для 210 формы */
private const КонецБлокаA     = 6;     /* для 210 формы */
private const SET_CHAR        = "X";

private var type = "", type_link_mes = "";



/* 1. Поля документа включаются в блок данных в кодировке ASCII
   2. При включении полей документа в блок данных из них удаляются все пробелы(0x20),
      символы табуляции(0х9), перевода строки(0х0А) и возврата каретки(0х0D) 
   3. Поля при выводе в блок данных разделяются символом перевода строки 
      (0x0A). Разделитель добавляется в блок данных даже, если поле является пустым и 
      в блок данных выводится как строка нулевой длины    */
macro Rules( str );
  str = StrSubst( str, " ", "" );
  str = StrSubst( str, "\n", "" );
  str = StrSubst( str, "\t", "" );
  return ToANSI(str, true);
end;

/* Числовые поля, содержащие суммы, без завершающих нулей в дробной части */
macro Rules1( str )
  while( SubStr( str, StrLen(str), 1 ) == "0" )    
    str = substr( str, 1, StrLen(str) - 1 );
  end;
  return str;
end;

macro СлужебныйЗаголовок( RsMs:RsbMessage, retStr, НФ, MST )
  var RcvBankCode_SMFR, SndBankCode_SMFR, 
     КодКлирингаОтправителя, OwnerCode,
     error, ID, MesSubType;

  /* Определить форму и релиз сообщения */
  if( not WlDefineForm( RsMs.RlsFormID) )
    return false;
  end;

  /* Определяем подтип сообщения ("S", "N" или "") */
  MesSubType = substr(f_wlmesrls.Name, strlen(f_wlmesrls.Name), 1);
  if ((MesSubType != КодПодтипСообщения_КорСчет) and (MesSubType != КодПодтипСообщения_СМФР))
    MesSubType = "";
  end;
  
  /* Активный код участника отправителя */
  if (RsMs.Direct == SET_CHAR)
    SndBankCode_SMFR = ПолучитьКодСубъекта(wlmes.OutsideAbonentID, PTCK_SMFR, error);
  else
    error = ПолучитьНашКодСУчетомТС(PTCK_SMFR, false, SndBankCode_SMFR, OwnerCode, КодКлирингаОтправителя);
  end;  
  if (error)
    std.msg( string("Не найден код СМФР Отправителя сообщения!"));
    return false;
  end;
  
  /* Активный код участника получателя */
  if (RsMs.Direct != SET_CHAR)
    RcvBankCode_SMFR = ОпределитьПолучателяСообщения(wlmes, КодКлирингаОтправителя, OwnerCode);
  else
    error = ПолучитьНашКодСУчетомТС(PTCK_SMFR, false, RcvBankCode_SMFR, OwnerCode);
  end;
  if (RcvBankCode_SMFR == "")
    std.msg( string("Не найден код СМФР Получателя сообщения!"));
    return false;
  end;

  retStr = string(Rules(RsMs.TRN), TAG_DELIMITER, Rules(f_wlmesfrm.Name), Rules(MesSubType), TAG_DELIMITER, Rules(SndBankCode_SMFR), TAG_DELIMITER, Rules(RcvBankCode_SMFR), TAG_DELIMITER);
  
  setparm(1, retStr );
  setparm(2, f_wlmesfrm.Name );
  setparm(3, MesSubType );

  return true;
end;


var ПоляБлокаДанных = Tarray;

class ТПолеБлока( _name, _ИскатьПоОпции, _ПовторяющеесяПоле, _Контекст, _rules_fun1 )
  var Name:string          = "",
      RulesFun1:string     = "",
      Контекст:string      = "",
      ИскатьПоОпции:bool   = false, 
      ПовторяющеесяПоле:bool   = false;
      /*ПолеУжеВстречалось:bool = false;*/

  Name          = _name;
  RulesFun1     = _rules_fun1;
  Контекст      = _Контекст;
  ИскатьПоОпции = _ИскатьПоОпции; 
  ПовторяющеесяПоле = _ПовторяющеесяПоле;

  /* Добавляем поле в список полей */
  ПоляБлокаДанных(ПоляБлокаДанных.Size) = this;

  macro ОбработатьПолеФормы( value )
    /* Если заданы дополнительные правила обработки поля */
    if( RulesFun1 != "" )
       value = ExecMacro2( RulesFun1, value);
    end;
    if (Name != CopyMandatoryFields)
      value = Rules(value);
      return string(value, TAG_DELIMITER);
    else
      return string(value);
    end;

  end;

end; /* class ТПолеБлока */

/* Создание списка полей исходных сообщений */
macro ПоляИсходныхСообщений( )
  /* Очищаем массив */
  ПоляБлокаДанных = Tarray;
  GenObject( "ТПолеБлока", "20",false, false, "", "" );
  if( substr(type_link_mes, 1, 3) == "102")
    GenObject( "ТПолеБлока", "23", false, false, "", "" );
    GenObject( "ТПолеБлока", "21", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "32B", false, false, "Sequence B", "Rules1" );
    if(type_link_mes == "102I")
       GenObject( "ТПолеБлока", "50", true, false, "Sequence B\\50a", "" );
    end;
    GenObject( "ТПолеБлока", "59", true, false, "Sequence B\\59a", "" );
    GenObject( "ТПолеБлока", "71A", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "19", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "53", true, false, "53a", "" );
    GenObject( "ТПолеБлока", "54A", false, false, "", "" );
  end;  
  if( substr(type_link_mes, 1, 3) == "103")
    GenObject( "ТПолеБлока", "23B", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "50", true, false, "50a", "" );
    GenObject( "ТПолеБлока", "59", true, false, "59a", "" );
    GenObject( "ТПолеБлока", "71A", false, false, "", "" );
  end;  
  if(substr(type_link_mes, 1, 3) == "202")
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    if( type_link_mes != "202I")
       GenObject( "ТПолеБлока", "52", true, false, "52a", "" );
       GenObject( "ТПолеБлока", "57", true, false, "57a", "" );
    end;
    GenObject( "ТПолеБлока", "58", true, false, "58a", "" );
  end;  
  if(type_link_mes == "204S")
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "52", true, false, "52a", "" );
    GenObject( "ТПолеБлока", "58", true, false, "58a", "" );
    GenObject( "ТПолеБлока", "72", false, false, "", "" );
  end;  
  if(substr(type_link_mes, 1, 3) == "910")
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "25", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "52", true, false, "52a", "" );
  end;  
end;


/* Создание списка полей, участвующих в формировании блока данных */
macro MakeBlockFld( )
  GenObject( "ТПолеБлока", "20",false, false, "", "" );
  if( type == BUFTYPE_ANS )
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "77A", false, false, "", "" );
    GenObject( "ТПолеБлока", "MFIELDS", false, false, "", "ОбработатьПоляИсходныхСообщений" );
  end;
  if( type == BUFTYPE_CONF )
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "25D", false, false, "", "" );
    GenObject( "ТПолеБлока", "21C", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "72", false, false, "", "" );
  end;
  if( (type == BUFTYPE_MPM) or (type == BUFTYPE_MPMN))
    GenObject( "ТПолеБлока", "23", false, false, "", "" );
    GenObject( "ТПолеБлока", "", true, false, "50a", "" );
    GenObject( "ТПолеБлока", "", true, false, "52a", "" );
    GenObject( "ТПолеБлока", "26T", false, false, "", "" );
    GenObject( "ТПолеБлока", "71A", false, false, "", "" );
    GenObject( "ТПолеБлока", "36", false, false, "", "" );
    GenObject( "ТПолеБлока", "21", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "32B", false, false, "Sequence B", "Rules1" );
    if(type == BUFTYPE_MPM)
       GenObject( "ТПолеБлока", "", true, false, "Sequence B\\50a", "" );
       GenObject( "ТПолеБлока", "", true, false, "Sequence B\\52a", "" );
    end;
    GenObject( "ТПолеБлока", "", true, false, "Sequence B\\57a", "" );
    GenObject( "ТПолеБлока", "", true, false, "Sequence B\\59a", "" );
    GenObject( "ТПолеБлока", "70", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "26T", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "77B", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "33B", false, false, "Sequence B", "Rules1" );
    GenObject( "ТПолеБлока", "71A", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "77F", false, true, "Sequence B\\77F", "" );
    GenObject( "ТПолеБлока", "77G", false, false, "Sequence B", "" );
    GenObject( "ТПолеБлока", "36", false, false, "Sequence B", "Rules1" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "19", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "71G", false, false, "", "" );
    GenObject( "ТПолеБлока", "", true, false, "53a", "" );
    GenObject( "ТПолеБлока", "54A", false, false, "", "" );
    GenObject( "ТПолеБлока", "72", false, false, "", "" );
  end;  
  if( type == BUFTYPE_PM)
    GenObject( "ТПолеБлока", "23B", false, false, "", "" );
    GenObject( "ТПолеБлока", "23E", false, true, "23E", "" );
    GenObject( "ТПолеБлока", "26T", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "33B", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "36", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "", true, false, "50a", "" );
    GenObject( "ТПолеБлока", "", true, false, "52a", "" );
    GenObject( "ТПолеБлока", "", true, false, "57a", "" );
    GenObject( "ТПолеБлока", "", true, false, "59a", "" );
    GenObject( "ТПолеБлока", "70", false, false, "", "" );
    GenObject( "ТПолеБлока", "71A", false, false, "", "" );
    GenObject( "ТПолеБлока", "71F", false, true, "71F", "" );
    GenObject( "ТПолеБлока", "71G", false, false, "", "" );
    GenObject( "ТПолеБлока", "72", false, false, "", "" );
    GenObject( "ТПолеБлока", "77B", false, false, "", "" );
  end;  
  if( (type == BUFTYPE_BPM) or (type == BUFTYPE_DEM))
    if( type == BUFTYPE_BPM)
       GenObject( "ТПолеБлока", "21", false, false, "", "" );
    end;
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "", true, false, "52a", "" );
    GenObject( "ТПолеБлока", "", true, false, "57a", "" );
    GenObject( "ТПолеБлока", "", true, false, "58a", "" );
    GenObject( "ТПолеБлока", "72", false, false, "", "" );
  end;  
  if( type == BUFTYPE_NOT)
    GenObject( "ТПолеБлока", "25", false, false, "", "" );
    GenObject( "ТПолеБлока", "30", false, false, "", "" );
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "32B", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "", true, false, "50a", "" );
    GenObject( "ТПолеБлока", "", true, false, "52a", "" );
  end;  
  if( type == BUFTYPE_CONFD)
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "25D", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "MFIELDS", false, false, "", "ОбработатьПоляИсходныхСообщений" );
  end;  
  if( type == BUFTYPE_CONFC)
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "25", false, false, "", "" );
    GenObject( "ТПолеБлока", "32A", false, false, "", "Rules1" );
    GenObject( "ТПолеБлока", "", true, false, "50a", "" );
    GenObject( "ТПолеБлока", "", true, false, "52a", "" );
    GenObject( "ТПолеБлока", "72", false, false, "", "" );
  end;  
  if( type == BUFTYPE_REQ)
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "11S", false, false, "", "" );
    GenObject( "ТПолеБлока", "79", false, false, "", "" );
    GenObject( "ТПолеБлока", "MFIELDS", false, false, "", "ОбработатьПоляИсходныхСообщений" );
  end;
  if( (type == BUFTYPE_R) or (type == BUFTYPE_A))
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    if (type == BUFTYPE_R) 
       GenObject( "ТПолеБлока", "75", false, false, "", "" );
    else
       GenObject( "ТПолеБлока", "76", false, false, "", "" );
    end;
    GenObject( "ТПолеБлока", "77A", false, false, "", "" );
    GenObject( "ТПолеБлока", "", true, false, "11a", "" );
    GenObject( "ТПолеБлока", "79", false, false, "", "" );
    GenObject( "ТПолеБлока", "MFIELDS", false, false, "", "ОбработатьПоляИсходныхСообщений" );
  end;
  if( type == BUFTYPE_INFO)
    GenObject( "ТПолеБлока", "21", false, false, "", "" );
    GenObject( "ТПолеБлока", "79", false, false, "", "" );
  end;
end;

/**/
macro СоответствиеФормы()
   if (type == BUFTYPE_ANS)
       if ((substr(type_link_mes, 1, 3) == "102") or (substr(type_link_mes, 1, 3) == "103") or 
           (substr(type_link_mes, 1, 3) == "202"))
           return true;
       end;
   end;
   if (type == BUFTYPE_CONFD)
       if ((substr(type_link_mes, 1, 3) == "103") or (substr(type_link_mes, 1, 3) == "202"))
           return true;
       end;
   end;
   if (type == BUFTYPE_REQ)
       if ((substr(type_link_mes, 1, 3) == "102") or (substr(type_link_mes, 1, 3) == "103") or 
           (substr(type_link_mes, 1, 3) == "202") or (type_link_mes == "204S") or (substr(type_link_mes, 1, 3) == "910"))
           return true;
       end;
   end;
   if ((type == BUFTYPE_A) or (type == BUFTYPE_R))
       if ((substr(type_link_mes, 1, 3) == "102") or (substr(type_link_mes, 1, 3) == "103") or 
           (substr(type_link_mes, 1, 3) == "202") or (type_link_mes == "204S") or (substr(type_link_mes, 1, 3) == "910"))
           return true;
       end;
   end;
   return false;
end;

/*Выделяет из блока данных данные с полями
начиная с поля 20(считаем , что оно у нас всегда есть иначе ругаемся) и до первой закрывающейся скобки
*/
macro УрезатьБлок(БлокДанных)
    var index20, index_end;
    index20 = Index(БлокДанных, ":20:");
    if (index20 == 0)
        RunError("Не найдено поле 20 в поле " + CopyMandatoryFields);
    end;
    БлокДанных = SubStr(БлокДанных, index20);
    /*ищем закрывающююся скобку*/
    index_end = Index(БлокДанных, "-}");
    if (index_end != 0)
        БлокДанных = SubStr(БлокДанных, 1, index_end - 1);
    end;
end;



macro НайтиПолеВБлоке(ИмяПоля, БлокДанных)
   var tmpBlock, ind;
   ind = Index(БлокДанных, ":" + ИмяПоля);
   if (ind == 0)
      return "";
   end;
   tmpBlock = SubStr(БлокДанных, ind + 1);
   ind = Index(tmpBlock, ":");
   if (ind == 0)
      return "";
   end;
   tmpBlock = SubStr(tmpBlock, ind + 1);
   ind = Index(tmpBlock, ":");
   if (ind != 0)
      tmpBlock = SubStr(tmpBlock, 1, ind - 1);
   end;
   return tmpBlock;
end;

macro РазбитьСтроку(Строка, Массив, Разделитель)
   var ind, i = 0;
   ind = Index(Строка, Разделитель);
   while(ind)
      Массив(i) = Substr(Строка, 1, ind - 1);        
      i = i + 1;
      Строка = Substr(Строка, ind );
      ind = Index(SubStr(Строка, StrLen(Разделитель) + 1), Разделитель);
      if (ind != 0 )
         ind = ind + StrLen(Разделитель);
      end;
   end;
   Массив(i) = Строка;
end;

/**/
macro ОбработатьПоляИсходныхСообщений(БлокДанных)
   var i = 0, fld, fld_value, retStr = "", arr = TArray, НачалоПовторяющегосяБлока, КонецПовторяющегосяБлока, Num = 0;
   if(not СоответствиеФормы())
       return "";
   end;
   ПоляИсходныхСообщений( );
   УрезатьБлок(БлокДанных);
   /*Теперь ищем в нем необходимые поля*/
   if (substr(type_link_mes, 1, 3) != "102I") /*102 форму обработаем отдельно*/
       while( i < ПоляБлокаДанных.Size )
           fld = ПоляБлокаДанных.Value(i);
           fld_value = НайтиПолеВБлоке(fld.Name, БлокДанных);
           retStr = retStr + fld.ОбработатьПолеФормы(fld_value);
           i = i + 1;
       end;
   else
       РазбитьСтроку(БлокДанных, arr, ":21:");/*считаем что повторяющийся блок всегда начинается с ":21:"*/
       НачалоПовторяющегосяБлока = 2;
       if (type_link_mes == "102I") 
          КонецПовторяющегосяБлока = 6;
       else
          КонецПовторяющегосяБлока = 5;
       end;
       while( i < НачалоПовторяющегосяБлока )/*обработка полей до повторяющегося блока*/
           fld = ПоляБлокаДанных.Value(i);
           fld_value = НайтиПолеВБлоке(fld.Name, arr.value(num));
           retStr = retStr + fld.ОбработатьПолеФормы(fld_value);
           i = i + 1;
       end;
       if (arr.size > 1)/*есть хотя бы один повторяющийся блок*/
           num = num + 1;
           while (num < arr.size)
              i = НачалоПовторяющегосяБлока;
              while( i <= КонецПовторяющегосяБлока )/*обработка полей повторяющегося блока*/
                  fld = ПоляБлокаДанных.Value(i);
                  fld_value = НайтиПолеВБлоке(fld.Name, arr.value(num));
                  retStr = retStr + fld.ОбработатьПолеФормы(fld_value);
                  i = i + 1;
              end;
              num = num + 1;
           end;
           num = num - 1;/*нужно потому поля после повторяющегося блока находятся в последнем повторяющемся блоке*/
       end;
       i = КонецПовторяющегосяБлока + 1;
       while( i < ПоляБлокаДанных.Size )/*обработка полей после повторяющегося блока*/
           fld = ПоляБлокаДанных.Value(i);
           fld_value = НайтиПолеВБлоке(fld.Name, arr.value(num));
           retStr = retStr + fld.ОбработатьПолеФормы(fld_value);
           i = i + 1;
       end;
   end;

   ПоляБлокаДанных = TArray;   /*очистить поля*/

   return retStr;
end;

/*ищет поле в списке, возвращает индекс или -1 если ничего не нашел
ищет по имени и контексту или по контексту если поле с опцией 
*/
macro НайтиПолеВСписке(Имя, Контекст)
    var i = 0;
    while (i < ПоляБлокаДанных.Size)
        if ((ПоляБлокаДанных.Value(i).Name == Имя) and (ПоляБлокаДанных.Value(i).Контекст == Контекст))
            return i;
        end;
        if ((ПоляБлокаДанных.Value(i).ИскатьПоОпции) and (ПоляБлокаДанных.Value(i).Контекст == Контекст))
            return i;
        end;
        i = i + 1;
    end;
    return -1;
end;

macro ПолучитьНомерБлока( FieldID:integer ) 
  var tmpstr:string = "";
  var rs:object;
  var select:string;
  var params:TArray;

  select = "select t_BlockName from  dwlmesfld_dbt"+
                           " start with t_FieldID =:FieldID"+
                           " connect by prior t_Master = t_FieldID";
  params = makeArray( SQLParam("FieldID", FieldID));
  rs = execSQLselect( select, params, FALSE );
    
  if( not rs.MoveNext() )
    return tmpstr;
  end;

  while( rs.moveNext() )    
    if( tmpstr != "" )
      tmpstr = "\\" + tmpstr;
    end;
    tmpstr = rs.value(0) + tmpstr;
  end;

  return tmpstr;
end;

/* формирование информационнго блока */
macro MakeDataInit( MesID:integer )
  var count = 0, fld, BlockStr = "", str, context;
  var НачалоБлока = 0, КонецБлока = 0, i_continue, index, tmp_index;
  var rs:object;
  var select:string;
  var params:TArray;

  select = "select wltpfld.t_Name, wlmesval.t_Value, wlmesval.t_FieldID"+ 
                           " from dwltpfld_dbt wltpfld, dwlmesval_dbt wlmesval, dwlmes_dbt wlmes"+
                           " where wlmes.t_MesID =:MesID"+
                           " AND wlmes.t_MesID = wlmesval.t_MesID"+
                           " AND wlmesval.t_TpFieldID = wltpfld.t_TpFieldID"+
                           " order by wlmesval.t_Index";
  params = makeArray( SQLParam("MesID", MesID));
  rs = execSQLselect( select, params, FALSE );
  type_link_mes = "";
  if (type == BUFTYPE_MPM) /*102*/
      НачалоБлока = НачалоБлокаB;
      КонецБлока = КонецБлокаB102;
  end;
  if (type == BUFTYPE_MPMN) /*102N*/
      НачалоБлока = НачалоБлокаB;
      КонецБлока = КонецБлокаB102N;
  end;
  if (type == BUFTYPE_NOT) /*210*/
      НачалоБлока = НачалоБлокаA;
      КонецБлока = КонецБлокаA;
  end;
  
  while( (count < ПоляБлокаДанных.size) or (type == BUFTYPE_NOT))
    i_continue = 1;
    while(i_continue)/*читаем поля сообщения пока не встретим то что нам нужно*/
       if( not rs.MoveNext() ) /*поля кончились в реальном сообщении*/
           if (НачалоБлока)
               if(count < НачалоБлока)
                   count = КонецБлока + 1;/* пропускаем блок*/
               end;
           end;
           while( count < ПоляБлокаДанных.size )
               fld = ПоляБлокаДанных.Value(count);
               BlockStr = BlockStr + fld.ОбработатьПолеФормы("");
               count = count + 1;
           end;
           return BlockStr;
       end;

       if( rs.value(0) == ТипИПодтипСообщения )
         type_link_mes = rs.value(1);
       end;
   
       /* Определим название блока для поля */
       context = ПолучитьНомерБлока( rs.value(2) ); 

       index = НайтиПолеВСписке(rs.value(0), context);
       if (index > -1) /*поле включается в блок данных*/
           i_continue = 0;
       end;
    end;
    if (index == count)/*обрабатываем поле*/
       fld = ПоляБлокаДанных.Value(count);
       BlockStr = BlockStr + fld.ОбработатьПолеФормы(rs.value(1));
       count = count + 1;
    elif(index > count)/*значит какие то поля пропущены*/
       if (НачалоБлока)
           if((count < НачалоБлока) and (index > КонецБлока))/* пропускаем блок*/
               while( count < НачалоБлока )/*если есть поля до блока выводим разделители*/
                   fld = ПоляБлокаДанных.Value(count);
                   BlockStr = BlockStr + fld.ОбработатьПолеФормы("");
                   count = count + 1;
               end;
               count = КонецБлока + 1;
           end;
       end;
       while( count < index ) /*выводим разделители вместо полей которых нет*/
           fld = ПоляБлокаДанных.Value(count);
           BlockStr = BlockStr + fld.ОбработатьПолеФормы("");
           count = count + 1;
       end;
       fld = ПоляБлокаДанных.Value(count);
       BlockStr = BlockStr + fld.ОбработатьПолеФормы(rs.value(1));
       count = count + 1;
    elif(index < count) /*может быть в случае если есть повторяющийся блок и если поля повторяютя*/
       if (НачалоБлока) /*повторяющийся блок*/
           tmp_index = count;
           while( tmp_index <= КонецБлока ) /*разделители до конца блока*/
               fld = ПоляБлокаДанных.Value(tmp_index);
               BlockStr = BlockStr + fld.ОбработатьПолеФормы("");
               tmp_index = tmp_index + 1;
           end;
           tmp_index = НачалоБлока;
           while( tmp_index < index ) /*разделители c начала блока до нужного поля*/
               fld = ПоляБлокаДанных.Value(tmp_index);
               BlockStr = BlockStr + fld.ОбработатьПолеФормы("");
               tmp_index = tmp_index + 1;
           end;
       end;
       fld = ПоляБлокаДанных.Value(index);
       BlockStr = BlockStr + fld.ОбработатьПолеФормы(rs.value(1));
       count = index + 1;
    end;
  end;

  return BlockStr;
end;


/* Непосредственное формирование блока данных 
   RsMs   - сконструированный объект класса RsbMessage 
   retStr - возвращаемое значение, БЦИ 
*/
macro ФормированиеБлокаДанных( RsMs:RsbMessage, retStr )
  var type_doc, sub_type_doc, BlockStr, error, ДатаКлючевания, ClientID;

  if( not СлужебныйЗаголовок( RsMs, retStr, type_doc, sub_type_doc))
     return false;
  end;

  /* определяем тип блока */
  if( type_doc == "000" )
    type = BUFTYPE_ANS;
  elif( type_doc == "001" )
    type = BUFTYPE_CONF;
  elif( (type_doc == "102") and (sub_type_doc == ""))
    type = BUFTYPE_MPM;
  elif( (type_doc == "102") and (sub_type_doc == КодПодтипСообщения_СМФР) )
    type = BUFTYPE_MPMN;
  elif( type_doc == "103" )
    type = BUFTYPE_PM;
  elif( type_doc == "202" )
    type = BUFTYPE_BPM;
  elif( type_doc == "204" )
    type = BUFTYPE_DEM;
  elif( type_doc == "210" )
    type = BUFTYPE_NOT;
  elif( type_doc == "900" )
    type = BUFTYPE_CONFD;
  elif( type_doc == "910" )
    type = BUFTYPE_CONFC;
  elif( substr(type_doc, 2, 2) == "92" )
    type = BUFTYPE_REQ;
  elif (substr(type_doc, 2, 2) == "95")
    type = BUFTYPE_R;
  elif (substr(type_doc, 2, 2) == "96")
    type = BUFTYPE_A;
  elif( substr(type_doc, 2, 2) == "99" )
    type = BUFTYPE_INFO;
  else
    setparm(1, "");
    return true;
  end;

  MakeBlockFld();
  BlockStr = MakeDataInit( RsMs.MesID );

  /* Очищаем массив */
  ПоляБлокаДанных = Tarray;
  retStr = retStr + BlockStr;
  /* Разделитель не выводится в блок данных после последнего поля */  
  if( SubStr( retStr, StrLen(retStr) - StrLen(TAG_DELIMITER) + 1, StrLen(TAG_DELIMITER) ) == TAG_DELIMITER )
    retStr = SubStr( retStr, 1, StrLen(retStr) - StrLen(TAG_DELIMITER) );
  end;

  /* Следующие строки не регламентированы инструкцией 680-П, однако они 
     обязательно нужны для выбора ключа криптоплагином ключевания cpsbrf.dll 
     Первые     6 символов - дата ключа(если исходящее то опердень, входящее - из wlmes.OutsideAbonentDate), 
     следующие 10 символов - идентификатор участника */  
  if( wlmes.Direct == SET_CHAR )
    ДатаКлючевания = RsMs.OutsideAbonentDate;
  else
    ДатаКлючевания = {curdate};
  end;

  /* Код клиента для ключевания: берем код СМФР внегнего абонента и дополняем нулями до 10 символов */
  ClientID = ПолучитьКодСубъекта( RsMs.OutsideAbonentID, PTCK_SMFR, error );
  if( error )
    MsgBox( "Не найден код СМФР для внешнего абонента сообщения" );
    return false;
  end;
  ClientID = ClientID + "000000";

  /* Итоговый блок целевой информации */
  retStr = ДатаДДММГГ(ДатаКлючевания) + ClientID + retStr;

  setparm(1, retStr);
  
  /* debug info */
  std.out( 2, String("Размер БЦИ: ", strlen(retStr) - 16) );
  std.out( 2, "------------------------------------------" );
  std.out( 2, SubStr( retStr, 17 ) );
  std.out( 2, "------------------------------------------" );
  
  return true;
end;

// Функция формирования БЦИ в массовом режиме
macro MassSWSBSource()
  var fsgn:TBFile = TBFile( "sgnmass.tmp", "w", 0 );
  var PIB, rsms, err, text;

  fsgn.AddFilter( "t.t_Macro='swsbsign.mac' and t.t_MacroFunc='SWSBSource'" );

  ClearRecord( fsgn );

  var stat:bool = fsgn.GetGE();

  while( stat )
    /* Конструируем объект сообщение */
    rsms = RsbMessage( int(fsgn.rec.DocID) );
    
    /* Формируем блок данных для ключевания */
    if( ФормированиеБлокаДанных( RsMs, PIB ) )
      fsgn.rec.PBI = PIB;
      stat = fsgn.Update();
      err = Status(text);
      if( not stat )
        MsgBox( text );
      end;
    end;

    stat = fsgn.Next();
  end;
  
  fsgn.DropFilter();
  return 1; // без ошибок
end;

/* Функция формирования блока целевой информации по сообщению RS-Bank'а
   RsMs        - сконструированный объект класса RsbMessage 
   SourceAttrs - набор атрибутов, участвующих в формированиии БЦИ 
   Работает как в обычном так и в массовом режиме в зависимости от IsMass */
macro SWSBSource( RsMs:RsbMessage, SourceAttrs:string )
  var PIB:string = "";
  var IsMass:bool = false;

  if( getparm(2,IsMass) and (IsMass == true) ) // массовый режим
    MassSWSBSource();
    return 1; // без ошибок
  else
    /* Формируем блок данных для ключевания */
    if( not ФормированиеБлокаДанных( RsMs, PIB ) )
      return 1;
    end;

    return PIB; /* Успешное завершение */
  end;

  OnError(er) /* обработка ошибок */
    SB_ExeptionMessage(er);
    if(IsMass == true)
      return 0;
    else
      return 1;
    end;
end;
