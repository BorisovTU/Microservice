/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

    (c) R-Style Software Lab 2001
    RS Bank 5.10

    Информирование о необработанных документах


    filename cbinfcom.mac ( CB INF COMmon )

    Общие для всех процедур функции высокого уровня
    
                    Mikhailov S.,   22.08.2001, Wed
                    v.2             30-10-2001, Tue
                    
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/


import BankInter, PaymInter, OprInter, ReportInter, globals;
import cbinfint;
import impcomm;
import RSD;

/*
    Названия списков
*/
const   LIST_DEFERRED ="Отложенные";
const   LIST_WORKING = "Открытые";
const   LIST_PLANNED = "Планируемые";
const   LIST_I1      = "Картотека 1 c истекшим сроком акцепта";
const   LIST_I2      = "Картотека 2"; /*CBINF_I2*/
const   LIST_RMINPROP= "Картотека невыясненных сумм";
const   LIST_CARDFILE= "Картотека корр. счета";
/*cbinfsnd skipped*/
const   LIST_CPSEND  = "Ответные валютные платежи";


/*
// типы статусов платежа. В смысле к какой части платежа они относятся.
typedef enum PAYMSTATUS_TYPES {
*/
const  PAYMSTATUS_MAIN = 0;        /* статус платежа*/
const  PAYMSTATUS_PROP = 1;            /* статус свойств платежа*/




/*202, 27, 28
//
//  Системные статусы валютных платежек
//CP_STATES 
*/

const  CP_ST_DEFERRED  = 0;  /* Отложена*/
const  CP_ST_WORKING   = 1;  /* Обрабатывается*/
const  CP_ST_REJECTED  = 10; /* Отвергнута*/
const  CP_ST_CLOSED    = 15;  /* Закрыта*/

/*  410
//
//  Статусы кассового ордера
//
typedef enum STAT_CASH_ORDER {
*/

const  STAT_CASH_ORDER_ALL    = 0;  /* не используется*/
const  STAT_CASH_ORDER_POST   =1 ;    /* отложен*/
const  STAT_CASH_ORDER_OPEN   =2 ;    /* открыт*/
const  STAT_CASH_ORDER_CLOSE  =3 ;     /* закрыт*/


/*  240
//
//  Статусы заявления на выдачу чековых книжек
//
typedef enum CHECKISS_ST {
*/

const  CHECKISS_ST_ALL    = 0;  /* не используется*/
const  CHECKISS_ST_POST   =1;    /* отложено*/
const  CHECKISS_ST_OPEN   =2;    /* открыто*/
const  CHECKISS_ST_CLOSE   =3;     /* закрыто*/




/*  230
//
//  Системные статусы заявления на открытие счета
//
typedef enum REQOPENA_STATES {
*/

const  REQOPENA_ST_DEFERRED  = 0;  /* Отложена */
const  REQOPENA_ST_WORKING   = 1;  /* Обрабатывается*/
const  REQOPENA_ST_REJECTED  = 20; /* Отвергнута*/
const  REQOPENA_ST_CLOSED    = 30;  /* Закрыта*/


/*  231
//
//  Системные статусы заявления на закрытие счета
//
typedef enum REQCLOSA_STATES {
*/

const  REQCLOSA_ST_DEFERRED  = REQOPENA_ST_DEFERRED; /* Отложено*/
const  REQCLOSA_ST_WORKING   = REQOPENA_ST_WORKING;  /* Обрабатывается*/
const  REQCLOSA_ST_REJECTED  = REQOPENA_ST_REJECTED; /* Отвергнуто*/
const  REQCLOSA_ST_CLOSED    = REQOPENA_ST_CLOSED;    /* Закрыто*/



/*  200
//
//  Системные статусы заявления на покупку\продажу валюты
//
typedef enum PSBCORD_STATES {*/


const  PSBCORD_ST_DEFERRED  = 0;  /* Отложена*/
const  PSBCORD_ST_WORKING   = 10; /* Обрабатывается*/
const  PSBCORD_ST_REJECTED  = 15; /* Отвергнута*/
const  PSBCORD_ST_CLOSED    = 20;  /* Закрыта*/


/*  15
*/
const  MCDOC_STATUS_ALL = 0;
const  MCDOC_STATUS_POST =1;
const  MCDOC_STATUS_OPEN=2;
const  MCDOC_STATUS_CLOSE=3;

/*  16, 17, 18
// состояния мем. ордеров
enum {
*/
const  MEMORDER_STATUS_ALL = 0; /* don't use this in database file.*/
const  MEMORDER_STATUS_POST =1;
const  MEMORDER_STATUS_OPEN =2;
const  MEMORDER_STATUS_CLOSE =3;



/*  27 see 202
*/


/*  28 see 202
*/

/*
typedef enum CARDINDEXNUMBERS {          // Константы картотек
*/
const     CARDINDEX1 = 1;      /* Картотека №1*/
const     CARDINDEX2 = 2;       /* Картотека №2*/


/*Названия первичек, документов, и т.д., всего, о чем можно информировать */
const               CBINF_RegPsPayOrd="Рублевый платежный документ";/*201*/
const               CBINF_RegPsCpOrd="Валютный платежный документ";/*202*/
const               CBINF_RegPSCshDoc="Объявление на взнос наличными";/*410*/
const               CBINF_RegCheckIss="Заявление на выд. чек. книжки";/*240*/
const               CBINF_RegReqOpenA="Заявление на открытие счета";/*230*/
const               CBINF_RegReqClosA="Заявление на закрытие счета";/*231*/
const               CBINF_RegPsBcOrd="Заявка на конвертацию валюты";/*200*/
const               CBINF_RegMultyDoc="Мультивалютный документ";/*15*/
const               CBINF_RegBankPayment="Платеж банка";/*16*/
const               CBINF_RegBankClaim="Требование банка";/*17*/
const               CBINF_RegBBCpOrd="Валютный платеж банка";/*27*/

const               CBINF_Planned= "Планируемый документ";

const               CBINF_I1        = "Документ картотеки 1";
const               CBINF_I2        = "Счет картотеки 2";
const               CBINF_RMINPROP  = "Документ картотеки невыясненных сумм";
const               CBINF_CARDFILE  = "Документ картотеки корр. счета";
/*cbinfsnd skiped*/
const               CBINF_CPSEND    = "Ответный валютный платеж";
const               CBINF_CPSEND_NOTDEF= "Необработаный ответный валютный платеж";


/* Информирование для этого опера*/
const     CBINF_OperOfReport:integer  = {oper} ;




/*
    Сколько нашли документов
*/
var NDocs;


/*Сообщение о ненайденном платеже*/
macro CBINF_MsgNoPmPaym(  RegPath, 
                          PrimName/*ex.: CBINF_RegPsPayOrd*/,
                          PrimBuff/*ex pspayord*/ )
                          
    CBINF_Error( "Не найден платеж для документа " + PrimName, CBINF_OutReport/* Сюда м. попасть только при создании отчета*/ ); 

    return CBINF_StatusError;
end;/*CBINF_MsgNoPmPaym*/                                     





/*
    Функция, получающая информацию для отчета.
    Возвращаемые параметры должны быть с начала
*/
macro CBINF_GetPrimInfo(    DocNumber, DedetAcc, CreditAcc, Sum, /* -- это возвр. параметры.
                                                                    Они должны быть сначала,
                                                                    Нельзя менять порядок, чтобы правильно работал SetParm*/
                            RegPath, /* registry */
                            PrimName/* название объекта или первички ex.: CBINF_RegPsPayOrd*/,
                            PrimBuff/* Буфер объекта ex. pspayord*/ )

    var pm_DocKind = 0, pm_DocumentID = 0, pm_Purpose = 0, pm_SubPurpose = -1, 
        pm_PaymentID = 0;

    file pmpaym ( pmpaym ) key 1;/* DocKind DocumentID Purpose SubPurpose DM!!!
                                        PaymentID
                                        Amount PayerAccount ReceiverAccount*/
    file pmpaym_id( pmpaym )key 0 ;
    
    file pmrmprop( pmrmprop ) key 0;/*PaymentID Number */


/*    record pspayord( pspayord );
    record pscpord( pscpord );
    record pscshdoc( pscshdoc );
    record checkiss( checkiss );
    record reqopena( reqopena );
    record reqclosa( reqclosa );
    record ps_bcord( ps_bcord );
    record multydoc( multydoc );
    record memorder( memorder );
    record bbcpord( bbcpord );


    record document( document );*/
    record doc_inf( "docinfo.rec" );

/**/


    SetParm( 0, "" );
    SetParm( 1, "" );
    SetParm( 2, "" );
    SetParm( 3, Money( 0 )  );

    
    if( ( PrimName == CBINF_RegPsPayOrd ) or
        ( PrimName == CBINF_I1 ) )
        
/*MsgBox( "cbinfcom primbuff.OrderId = ", primbuff.OrderId ); */

/*        setbuff( pspayord, PrimBuff ); Чтоб было понятно */
        
/*MsgBox( "cbinfcom pspayord.OrderId = ", pspayord.OrderId ); */
        
        pm_DocKind = PS_PAYORDER;
        pm_DocumentID=PrimBuff.OrderID;/*pspayord*/
        pm_Purpose  = PM_PURP_POPRIMARY;
        pm_SubPurpose  = 0;
        
    elif( PrimName == CBINF_RMINPROP )
    
        pm_PaymentID = PrimBuff.PaymentID;/*rminprop*/
        
    elif( (PrimName == CBINF_CARDFILE )or
          (PrimName == CBINF_CPSEND )or
          (PrimName == CBINF_CPSEND_NOTDEF) )
          
        pm_PaymentID = PrimBuff.PaymentID;/*pmprop*/
        
    elif( PrimName == CBINF_RegPsCpOrd )

/*        setbuff( pscpord, PrimBuff ); Чтоб было понятно */
        
        pm_DocKind    = PS_CPORDER;
        pm_DocumentID = PrimBuff.OrderID;/**/
        pm_Purpose    = PM_PURP_POPRIMARY;
        pm_SubPurpose = 0;
        
    elif( PrimName == CBINF_RegPSCshDoc )/*410*/
/*        setbuff( pscshdoc, PrimBuff );
*/
        pm_DocKind    = CASH_PS_INCORDER;
        pm_DocumentID = PrimBuff.AutoKey;/**/
        pm_Purpose    = PM_PURP_CASHBAL;
        pm_SubPurpose = 0;

//        setParm( 0, PrimBuff.Numb_Document );
        setParm( 2, PrimBuff.ClientAccount );

    elif( PrimName == CBINF_RegCheckIss )

/*        setbuff( checkiss, PrimBuff ); Чтоб было понятно */
        SetParm( 0, PrimBuff.Number );
        
    elif( PrimName == CBINF_RegReqOpenA )

/*        setbuff( reqopena, PrimBuff ); Чтоб было понятно */
        SetParm( 0, PrimBuff.Number );
        
    elif( PrimName == CBINF_RegReqClosA )

/*        setbuff( reqclosa, PrimBuff ); Чтоб было понятно */
        SetParm( 0, PrimBuff.Number );
        
    elif( PrimName == CBINF_RegPsBcOrd )/*200*/
    
/*        SetBuff( ps_bcord, PrimBuff );
*/        
        SetParm( 0, PrimBuff.Number );
        SetParm( 1, PrimBuff.SourceAccount );
        SetParm( 2, PrimBuff.RequiredAccount );
/*
25603, сумма продаваемых\покупаемых?
see also psbclf\psbcopr\ PS_BCCheck
*/
        if( PrimBuff.SourceAmount )
            SetParm( 3, PrimBuff.SourceAmount );
        else
            SetParm( 3, PrimBuff.RequiredAmount );
        end;
        
        
    elif( PrimName == CBINF_RegMultyDoc )/*15*/
    
/*        SetBuff( multydoc, PrimBuff );
*/        
//        SetParm( 0, PrimBuff.Numb_Document );
//        SetParm( 1, PrimBuff.Account_from );
//        SetParm( 2, PrimBuff.Account_To );
//        SetParm( 3, PrimBuff.Amount_From );
        pm_DocKind    = CB_MULTYDOC;
        pm_DocumentID = PrimBuff.AutoKey;
        pm_Purpose    = PM_PURP_MULTYDOC;
        pm_SubPurpose = 0;
        
    elif( PrimName == CBINF_RegBankPayment )

/*        setbuff( memorder, PrimBuff );
*/        
        pm_DocKind    = DLDOC_BANKPAYMENT;
        pm_DocumentID = PrimBuff.OrderID;
        pm_Purpose    = PM_PURP_BANKPAYMENT;
        pm_SubPurpose = 0;

    elif( PrimName == CBINF_RegBankClaim )

/*        setbuff( memorder, PrimBuff );
*/        
        pm_DocKind    = DLDOC_BANKCLAIM;
        pm_DocumentID = PrimBuff.OrderID;
        pm_Purpose    = PM_PURP_BANKPAYMENT;
        pm_SubPurpose = 0;

    elif( PrimName == CBINF_RegBBCpOrd )

/*        setbuff( bbcpord, PrimBuff );
*/        
        pm_DocKind    = BBANK_CPORDER;
        pm_DocumentID = PrimBuff.OrderID;
        pm_Purpose    = PM_PURP_BANKPAYMENT;
        pm_SubPurpose = 0;

    elif( PrimName == CBINF_Planned )
/*        setbuff( document, PrimBuff );
*/
        ClearRecord( doc_inf );
        
        if ( ПолучитьИнформациюПоДокументу( PrimBuff, doc_inf ) )
            CBINF_Error( "Ошибка при определнии свойств документа " + PrimBuff.Numb_Document, CBINF_OutReport/* Сюда м. попасть только при создании отчета*/ );
            return CBINF_StatusError;
        end;


        SetParm( 0, doc_inf.Numb_Document );
        SetParm( 1, doc_inf.PayerAccount );
        SetParm( 2, doc_inf.ReceiverAccount );
        SetParm( 3, /*doc_inf.Amount*/PrimBuff.Sum );
        
    end;/*if PrimName*/

/*Можем искать платеж по разным ключам */
    if( pm_DocKind or pm_PaymentID  )

        if( pm_DocKind )
            pmpaym.DocKind = pm_DocKind;
            pmpaym.DocumentID=pm_DocumentID;
            pmpaym.Purpose  = pm_Purpose;
            pmpaym.SubPurpose  = pm_SubPurpose;
            
    /*MsgBox("pmpaym search dockind = ", pm_DocKind, " docid = ",pm_DocumentID,  " purp = ", pm_Purpose, " subp = " , pm_SubPurpose );*/
        
            if( ( not GetGE( pmpaym ) ) or /* Ключ дублируемый */
                    (  pmpaym.DocKind != pm_DocKind ) or
                    (  pmpaym.DocumentID != pm_DocumentID ) or 
                    (  pmpaym.Purpose != pm_Purpose) or
                    (  pmpaym.SubPurpose != pm_SubPurpose ) )
                    
                   return CBINF_MsgNoPmPaym(   RegPath, 
                                               PrimName/*ex.: CBINF_RegPsPayOrd*/,
                                               PrimBuff/*pspayord*/);
            end;
        elif( pm_PaymentID )
            pmpaym_id.PaymentID=pm_PaymentID;
            
    /*MsgBox("pmpaym search dockind = ", pm_DocKind, " docid = ",pm_DocumentID,  " purp = ", pm_Purpose, " subp = " , pm_SubPurpose );*/
        
            if(  not GetEQ( pmpaym_id ) ) 
                    
                   return CBINF_MsgNoPmPaym(   RegPath, 
                                               PrimName/*ex.: CBINF_RegPsPayOrd*/,
                                               PrimBuff/*pspayord*/ );
            end;
/*  Для единообразия */
            copy( pmpaym, pmpaym_id );
        end;/*pm_DocKind*/
        
           SetParm( 1, pmpaym.PayerAccount );/*Для CBINF_RegPSCshDoc это счет кассы. SCR 25603, p.1a*/
           
        if( PrimName != CBINF_RegPSCshDoc )/*Для этой первички из платежа только сумма и счет клиента*/
           SetParm( 2, pmpaym.ReceiverAccount );
        end;
        
        SetParm( 3, pmpaym.Amount );
    
        if( ( PrimName == CBINF_RegPsPayOrd ) or 
            ( PrimName == CBINF_I1 ) or
            ( PrimName == CBINF_RMINPROP )  or
            ( PrimName == CBINF_CARDFILE )  or            
            ( PrimName == CBINF_RegBankPayment ) or 
            ( PrimName == CBINF_RegBankClaim ) or 
            ( PrimName == CBINF_RegPsCpOrd ) or 
            ( PrimName == CBINF_RegBBCpOrd ) or
            ( PrimName == CBINF_CPSEND ) or
            ( PrimName == CBINF_CPSEND_NOTDEF )  )
    
             pmrmprop.PaymentID = pmpaym.PaymentID;
             
             if( (  not GetEQ( pmrmprop ) ) or 
                ( pmrmprop.PaymentID != pmpaym.PaymentID ) )

                 CBINF_Error( "Не найдены реквизиты платежа для документа " + PrimName, CBINF_OutReport/* Сюда м. попасть только при создании отчета*/ );
                 return CBINF_StatusError;
                 
             end;
    
             SetParm( 0, pmrmprop.Number );
    
        end;/*if PrimName */

    end;/*if pm_DocKind*/
    
    return CBINF_StatusOk;
    
end;/*CBINF_GetPrimInfo*/




/* 
    Функция вывода сообщения о найденном документе
*/
macro MsgDocFound(  RegPath/* Путь к настройкам в реестре*/,
                    PrimName/*Название первички(либо просто объекта, о которм нужно проинформировать )
                              Желательно определять в cbinfcom.mac CBINF_....  */,
                    PrimBuff/* Буфер этого объекта*/,
                    State   /* отложен, открыт,... -- optional*/ )
    var ListName = "";
/*
    Признак найденного документа
*/
    
    CBINF_Result = 1;


    if( PrimName == CBINF_Planned )
        CBINF_Message( "В системе есть проводки,|запланированные к исполнению на текущий операционный день" );
    elif( primName == CBINF_I1 )        
        CBINF_Message( "В картотеке 1 есть документы с истекшим сроком акцепта" );
    elif( primName == CBINF_RMINPROP )        
        CBINF_Message( "В списке невыясненных платежей есть документы с истекшим сроком рассмотрения" );
    elif( primName == CBINF_CARDFILE )        
        CBINF_Message( "В картотеке коррсчета есть документы" );
    elif( primName == CBINF_CPSEND )
        CBINF_Message( "В списке ответных валютных платежей есть суммы,|подлежащие обязательной или обратной продаже")
    elif( primName == CBINF_CPSEND_NOTDEF )
        CBINF_Message( "Имеется ответный валютный платеж|с неустановленным видом продажи валюты")
    elif( primName == CBINF_I2 )        
        CBINF_Message( "В картотеке 2 есть документы, которые можно оплатить" );
    else
        if( PrimName == CBINF_RegPsPayOrd )
            if( state == PSPO_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == PSPO_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegPsCpOrd )
            if( state == CP_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == CP_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegPSCshDoc ) /*410*/

            if( state == STAT_CASH_ORDER_POST )
                ListName = LIST_DEFERRED;
            elif( state == STAT_CASH_ORDER_OPEN )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegCheckIss )

            if( state == CHECKISS_ST_POST )
                ListName = LIST_DEFERRED;
            elif( state == CHECKISS_ST_OPEN )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegReqOpenA )
            if( state == REQOPENA_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == REQOPENA_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegReqClosA )
            if( state == REQCLOSA_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == REQCLOSA_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegPsBcOrd ) /*200*/

            if( state == PSBCORD_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == PSBCORD_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegMultyDoc ) /*15*/
        
            if( state == MCDOC_STATUS_POST )
                ListName = LIST_DEFERRED;
            elif( state == MCDOC_STATUS_OPEN )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegBankPayment )
            if( state == MEMORDER_STATUS_POST )
                ListName = LIST_DEFERRED;
            elif( state == MEMORDER_STATUS_OPEN )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegBankClaim )
            if( state == MEMORDER_STATUS_POST )
                ListName = LIST_DEFERRED;
            elif( state == MEMORDER_STATUS_OPEN )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegBBCpOrd )
            if( state == CP_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == CP_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        elif( PrimName == CBINF_RegPsCpOrd )/*28*/

            if( state == CP_ST_DEFERRED )
                ListName = LIST_DEFERRED;
            elif( state == CP_ST_WORKING )
                ListName = LIST_WORKING;
            end;
            
        
        end;/*if PrimName */

        CBINF_Message( "В списке " + ListName + " -- " + PrimName + " есть документы" );
    end;/*if PrimName == CBINF_Planned */
    

    return CBINF_StatusExitOk;
end;/*MsgDocFound*/


/*Печать заголовка*/
macro PrintHeader( RegPath , ListName )
    CBINF_Result = 0;
    Ndocs = 0;
[Документы списка #####################################](ListName);
end;/*PrintHeader*/

/*Печать окончания отчета*/
macro PrintFooter( RegPath, ListName )
[ ];
    if( listName == LIST_I2 )
[Итого счетов: ##########](NDocs);
    else
[Итого документов: ##########](NDocs);
    end;
[   ];
[   ];
end;/*PrintFooter*/


/*Строка отчета*/
macro PrintLine( RegPath, PrimName/*ex.: CBINF_RegPsPayOrd*/, PrimBuff/*pspayord*/ )
    var this_stat;
    var DocNumber, DebetAcc, CreditAcc, Sum;
    
    CBINF_Result = 1;
    Ndocs = NDocs + 1;

    this_stat = CBINF_GetPrimInfo( DocNumber, DebetAcc, CreditAcc, Sum, 
                                    RegPath, PrimName/*ex.: CBINF_RegPsPayOrd*/, PrimBuff/*pspayord*/ );
    if( this_stat )
        return this_stat;
    end;

    if( ( PrimName == CBINF_RegPsPayOrd ) or
        ( PrimName == CBINF_I1 ) or
        ( PrimName == CBINF_RMINPROP ) or
        ( PrimName == CBINF_CARDFILE ) or
        ( PrimName == CBINF_CPSEND ) or
        ( PrimName == CBINF_CPSEND_NOTDEF ) or
        
        ( PrimName == CBINF_RegPsCpOrd ) or 
        ( PrimName == CBINF_RegPSCshDoc) or

        ( PrimName == CBINF_RegPsBcOrd ) or 
        ( PrimName == CBINF_RegMultyDoc ) or 
        
        ( PrimName == CBINF_RegBankPayment ) or 
        ( PrimName == CBINF_RegBankClaim ) or 
        
        ( PrimName == CBINF_RegBBCpOrd ) or
        
        ( PrimName == CBINF_Planned ) )
[###################################### N ############### ](PrimName, DocNumber);
[Дт ######################### Кт ######################### Сумма #######################]
(  DebetAcc:f, CreditAcc:f, Sum );

    elif(   ( PrimName == CBINF_RegCheckIss ) or 
            ( PrimName == CBINF_RegReqOpenA ) or 
            ( PrimName == CBINF_RegReqClosA ) )
[################################### N ###############]
( PrimName, DocNumber );

    elif( PrimName == CBINF_I2 )
[Счет N #########################. Остаток счета #######################]
(PrimBuff.Account:f, PrimBuff.Sum );

    end;/*if PrimName*/

[ ];    
    return CBINF_StatusOk;
end;/*PrintLine*/












/*
    Определение прав доступа опера к найденному документу
    Передавать опера, которому принадлежит документ 
    возвр. 0 -- "наш" документ

*/
macro CBINF_OperDocFit( OperOfDoc/* опер, которому принадлежит документ */ )
    return IsAccessToOperInf( OperOfDoc, CBINF_OperOfReport );
end;/*CBINF_OperDocFit*/

/*
    Наша операция?
*/
macro CBINF_OperOfOpr( Is, ID_Operation )
/*    file oprstep( oprstep )key 0;*/
    file opergrra( opergrra )key 0;

/*    oprstep.ID_operation = ID_Operation;
    oprstep.ID_step = 0;
    GetGE(oprstep);
*/
    var f = TRUE;
    var rs;
    var cmd;
/*    rewind( oprstep );*/
/*    
    while( f and (oprstep.ID_Operation == ID_Operation))
        if( oprstep.IsExecute != "X" ) 
*/
        /*Запланированный шаг, либо отверж. --- см. cbopuf\opstep*/
            /* ( oprstep.IsExecute != "W" ) */
/*
    Если опер не задан -- показываем
*/

    cmd = RSDCommand("select t.T_OPER, t.T_OPERORGROUP" +
                      " from doprstep_dbt t " +
                      " where t.T_IsExecute <> 'X' " +
                      "  and t.T_ID_OPERATION = " + ID_Operation );
    rs = RsdRecordset( cmd );           
    cmd.execute;


    while (rs.MoveNext)
            if( not rs.value(0) )
                SetParm( 0, true );
                return CBINF_StatusOk;
            end;

/* имеет право только если входит в группу?*/
            if( rs.value(1) == "X" )
                opergrra.Oper = CBINF_OperOfReport;
                opergrra.GroupNum = rs.value(0);

                SetParm( 0, GetEQ( opergrra ) );
                return CBINF_StatusOk;
                
            else
                SetParm( 0, not CBINF_OperDocFit( rs.value(0) ) );
                return CBINF_StatusOk;
            end;
            
/*        end;oprstep.ID_Operation*/
    /*f = Next(oprstep);*/
    end;/*next( oprstep )*/

    SetParm( 0, false );
    return CBINF_StatusOk;
    
end;


private const DOCUMENTID_LEN = 34;

/*
    Наш платеж?
*/
macro IsOperDoc( Is, PaymentID, DocKind, OutType )
    file oproper( oproper ) key 1;
    var stat;
    var Is_opr;

    oproper.DocKind = DocKind;
    oproper.DocumentID = LZ( PaymentID, DOCUMENTID_LEN );
    oproper.Start_date = date( 0, 0, 0 );

    if( ( not GetGE( oproper ) ) or
        ( oproper.DocKind != DocKind ) or
        ( oproper.DocumentID != LZ( PaymentID, DOCUMENTID_LEN ) ) )
        CBINF_Error( "Не найден экземпляр операции по платежу " + PaymentID, outType );
        return CBINF_StatusError;
    end;

    stat = CBINF_OperOfOpr( Is_opr, oproper.ID_Operation );
    SetParm( 0, Is_opr );

    return stat;
end;



