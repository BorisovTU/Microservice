/*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 5.0                                          R-Style Software Lab

  File Name   : rep_nu.mac
  Programmer  : Зорина
  Description : Таблица соответствия счетов бухгалтерского и налогового учета
  Comment     :
  Modification: 12.04.02. Богданова.
                Печать в 2 строки с наименованиями лицевых счетов.
                Если в ТС не задан корр.счет НУ ищутся корр.счета по связи
                с ролями OBJROLE_CUR_NUCORACCP,OBJROLE_CUR_NUCORACCA. 
└───────────────────────────────────────────────────────────────────────────*/
IMPORT CTInter;

FILE tc ( tc_nd ) ;
FILE curr ( fininstr );
FILE obchap ( obchaptr );

CONST Num_Chapters = 5,
      Chapt6 = 6,
      NumPlan = 0;

array NameTurn;
      NameTurn(0) = "все";
      NameTurn(1) = "дебет";
      NameTurn(2) = "кредт";

Var ChapTek = -1;

/* ----------------------------------------------------- */
MACRO GetCodCurrency( FIID )    /* Взять код валюты */

    curr.FIID = FIID;
    if ( getEQ( curr ) ) return curr.FI_Code;
    else return "";
    end;
END;
/* ----------------------------------------------------- */

MACRO NameTurnKind( Kind )
/*
FILE alg(namealg) ; /* алгоритмы выборов */
CONST ALG_NU_TURN = 111;

  alg.iTypeAlg = ALG_NU_TURN; /* Виды оборотов */
  alg.iNumberAlg = Kind; /* Номер вида */
  if ( getEQ(alg) ) return alg.szNameAlg;
  else return "":
  end;
*/
  return NameTurn(Kind-1);
END;
/* ----------------------------------------------------- */
MACRO GetNameChap ( Chap )   

    obchap.Chapter = Chap;
    if ( getEQ( obchap ) ) return obchap.symbol + "." + obchap.Name;
    else return "";
    end;
END;
/* ----------------------------------------------------- */

MACRO Header
[          Таблица соответствия счетов бухгалтерского и налогового учета
                           на ####################### ]
({curdate}:m:l);

END;

MACRO ZaGlav (Chapter)
[
   Глава  #
 ┌─────┬───┬─────────────────────────┬─────┬─────────────────────────┬─────────────────────────┬─────────────────────────┬────┬───────┐
 │  N  │Вал│   Номер лицевого счета  │ Вид │   Номер лицевого счета  │  Счет корреспонденции   │ Маска счета корреспонд. │Искл│Отказ  │
 │ П/п │юта│   бухгалтерского учета  │обор.│     налогового учета    │    налогового учета     │  бухгалтерского учета   │    │от обр.│]

( GetNameChap (Chapter));
END;

MACRO Footer
[└─────┴───────────────────────────────────┴───────────────────────────────────────────────────┴─────────────────────────┴────┴───────┘];
END;


MACRO NameNFU ( Account, Cur )

FILE bal  ( balance );

Var BalRef, name;

macro  CallName (  b, Acc )

      b.Chapter  = Chapt6;
      b.iNumPlan = NumPlan;
      b.Balance  =  Acc;

      if ( GetLE( b ) )
         while ( ( Index( Acc, b.Balance ) != 1 ) and ( Prev(b) ) and (b.Chapter == Chapt6) )

         end;
         if ( ( Index( Acc, b.Balance ) == 1 ) and ( b.Chapter == Chapt6 ) )
            return "БС: " + b.Name_Part; 
         else
           msgbox ("Не найден балансовый счет для счета НУ: " + string ( Acc )); 
           return "";
         end;
      end;
      return "";
end;

  BalRef =  bal;

  name = CallName ( BalRef, Account );
  setparm ( 2, BalRef.kind_account );
  return name;

END;

macro GetACAtr ( Acc, Cur, Chapt, Name, Kind );

FILE  a (account);
FILE  ac ("account$.dbt");

Var aref;

   if ( Cur ) aref = ac;
   else       aref = a;
   end;


   aref.Chapter = Chapt;
   aref.Account = Acc;

   if (Cur) 
       aref.Code_Currency = cur;
   end;

 if ( GetEq( aref ))
    setparm ( 3, aref.NameAccount);
    setparm ( 4, aref.Kind_Account );
 else
  /*  msgbox ("Не найден счет : " + Acc);*/
    setparm ( 3, "" );
    setparm ( 4, "" );
 end;

end;

macro GetCorNU ( accountNU, cur , kind)
Var role;
RECORD attr ( account );
 
   curr.FIID = cur;

   if   ( Kind == "А" )
      role = OBJROLE_CUR_NUCORACCP;
   elif ( Kind == "П" )
      role = OBJROLE_CUR_NUCORACCA;
   else
      return "";
   end;

   if(not GetLinkedObject( role, OBJTYPE_CURRENCY, curr, OBJTYPE_ACCOUNT, attr ))
      return ( attr.Account) ;
   end;

return "";

end;


MACRO PrintString( counter, tc )
Var NameFU = "", NameNU = "", kind = "";
ARRAY MaskIns, AtrExcl;

MaskIns (0) = "";  AtrExcl (0) = "";
MaskIns (1) = "";  AtrExcl (1) = "";

if ( ChapTek != tc.ChapterFU )

    if ( ChapTek >= 0)
         FOOTER();
    end;

    ZaGlav( tc.ChapterFU ); /* Печать заголовка главы */
    ChapTek = tc.ChapterFU;

 [├─────┼───┼─────────────────────────┼─────┼─────────────────────────┼─────────────────────────┼─────────────────────────┼────┼───────┤];
else
[├─────┼───┬─────────────────────────┬─────┼─────────────────────────┬─────────────────────────┼─────────────────────────┼────┼───────┤];
end;


   GetAcAtr ( tc.AccountFU, tc.FIIDFU, tc.ChapterFU, NameFu, Kind ); 
   GetAcAtr ( tc.AccountNU, tc.FIIDNU, Chapt6, NameNu, Kind ); 


if ( strlen(Kind) == 0) 
   NameNU = NameNFU ( tc.AccountNU, tc.FIIDNU, Kind );
end;

if ( tc.DopCorAccNU == "")
     tc.DopCorAccNU = GetCorNU (tc.AccountNU, tc.FIIDNU, Kind);
end;

if ( strlen(tc.CorBalanceFU) > 0 )
    MaskIns (0) = tc.CorBalanceFU;
  if ( strlen(tc.CorBalanceFUExcl) > 0 )
      MaskIns (1) = tc.CorBalanceFUExcl;
      AtrExcl( 1 ) = "X";
  end;
elif  ( strlen(tc.CorBalanceFUExcl) > 0 )
      MaskIns (0) = tc.CorBalanceFUExcl;
      AtrExcl( 0 ) = "X";
end;

 
[│#####│###│#########################│#####│#########################│#########################│#########################│ #  │   #   │]
( counter, GetCodCurrency (tc.FIIDFU), tc.AccountFU, NameTurnKind(tc.TurnKind), tc.AccountNU,
  tc.DopCorAccNU:w, MaskIns (0):w,  AtrExcl( 0 ), tc.NotUsed );
[│     │###################################│###################################################│#########################│ #  │       │]
(       NameFU ,                            NameNU, MaskIns (1):w,  AtrExcl( 1 )   );


END;                                                                          



MACRO PrintReport( Chapter, Currency, Sort )
 var counter = 1, i, l_next;


    Header;/* Печать заголовка */

 clearRecord(tc);
 tc.AccountFU = "";
 tc.FIIDNU   = 0;
 tc.AccountNU = "";
 if ( ( Chapter >  0 ) and ( Currency >= 0 ) ) /* По одной главе и одной валюте */
  tc.ChapterFU = Chapter;
  tc.FIIDFU    = Currency;
  l_next = getGE( tc ) and
           ( tc.ChapterFU == Chapter ) and
           ( tc.FIIDFU    == Currency );

 while( l_next )
   printString( counter, tc );
   l_next = next( tc ) and
            ( tc.ChapterFU == Chapter ) and
            ( tc.FIIDFU    == Currency );
   counter = counter + 1;
  end;

 elif( ( Chapter >  0 ) and ( Currency <  0 ) ) /* По одной главе и всем  валютам */
  tc.ChapterFU = Chapter;
  tc.FIIDFU    = 0;
  l_next = getGE( tc ) and ( tc.ChapterFU == Chapter );
  while( l_next )
   printString( counter, tc );
   l_next = next( tc ) and ( tc.ChapterFU == Chapter );
   counter = counter + 1;
  end;
 elif( ( Chapter == 0 ) and ( Currency <  0 ) ) /* По всем главам и всем валютам */
  if( ( Sort == "3" ) or ( Sort == "32" ) )
   while( next( curr ) )
    while( next( tc ) )
     if( tc.FIIDFU == curr.FIID )
      printString( counter, tc );
      counter = counter + 1;
     end;
    end;
   end;
  else
   while( next( tc ) )
    printString( counter, tc );
    counter = counter + 1;
   end;
  end;
 elif( ( Chapter == 0 ) and ( Currency >= 0 ) ) /* По всем главам и одной валюте  */
  i = 1;
  while( i <= Num_Chapters ) /* По всем главам */
   tc.FIIDFU    = Currency;
   tc.ChapterFU = i;
   l_next = getGE( tc ) and
            ( tc.ChapterFU == i ) and
            ( tc.FIIDFU    == Currency );
   while( l_next )
    printString( counter, tc );
    l_next = next( tc ) and
             ( tc.ChapterFU == i ) and
             ( tc.FIIDFU    == Currency );
    counter = counter + 1;
   end;
   i = i + 1;
  end;
 end;

 if( counter == 1  )
  println( "Нет данных для отчета." );
 else
  Footer;
 end;

END;

/*printreport(0,-1,32);*/

/*EOF*/