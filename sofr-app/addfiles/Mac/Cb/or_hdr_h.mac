/*╔═══════════════════════════════════════════════════════════════════════════╗*/
/*║           Автоматизированная банковская система RS-Bank v5.1              ║*/
/*║               Copyright (c) R-Style Software Lab 2001-2004                ║*/
/*║                                                                           ║*/
/*║ Имя файла     or_hdr_h.mac                                                ║*/
/*║                                                                           ║*/
/*║ Описание      Классы для работы с заголовками ("конструктор" заголовков)  ║*/
/*║                                                                           ║*/
/*║ Программист   Зуев С.В.                                                   ║*/
/*║                                                                           ║*/
/*║ Создан        11.03.2002                                                  ║*/
/*║                                                                           ║*/
/*╚═══════════════════════════════════════════════════════════════════════════╝*/
IMPORT "or_tools.mac";

/* Константа для обозначения элемента помеченного к удалению */
CONST REMOVING_ELEMENT = "_REMOVING_ELEMENT_";
/* Константа для принудительного добавления (см. метод CreateHeader) или удаления (см. метод ParcelHeader) 
   строки с нумерацией столбцов */
CONST NUMBER_LINE = 1;                    

/* Универсальный класс для работы с заголовками ("конструктор" заголовков) */
/* Идея! Самый верхний уровень - корень. Он всегда есть, но никогда не печатается. Просто все к нему как бы клеится */
CLASS CHeader(_StrValue:string, _Width:integer)

  var StrValue:string  = "";     /* Значение в элементарном заголовке (ячейке) */
  var Width   :integer = 0;      /* Ширина заголовка (актуально только для заголовков самого нижнего уровня) */
  var ArrChild:TArray  = TArray; /* Массив дочерних заголовков */

  /* Список методов:
     Init              - инициализация объекта
     AddChild          - добавление дочерних заголовков    
     RemoveChild       - удаление дочерних заголовков
     MarkRemoveParent  - пометка элементов для удаления вместе с пустыми родительскими заголовками 
     RemoveParent      - удаления дочерних заголовков вместе с пустыми родительскими заголовками 
     GetMaxLevel       - получение максимального уровня вложенности
    *ConvertNode       - конвертация узлов заголовка в необходимое представление
    *PrintStructHeader - печать структуры заголовка
     CalcWidthHeader   - расчет ширины заголовка
    *CalcHeightLevel   - расчет высоты одного уровня заголовка
     CalcHeightHeader  - расчет высоты заголовка на указанном уровне
     AddNumberLine     - принудительное добавления строки с нумерацией столбцов
     RemoveNumberLine  - принудительное удаление строки с нумерацией столбцов
    *CreateSepHeader   - получение разделителей для одной строки заголовка
    *CreateStrHeader   - получение одной строки заголовка
     CreateHeader      - получение строки заголовка
     ParcelHeader      - закачка строки заголовка в объект заголовка
  */

  /* (Public) Инициализация объекта */
  Macro Init(l_StrValue:string, l_Width:integer)

     if( ValType(l_StrValue) )   this.StrValue = l_StrValue;   end;
     if( ValType(l_Width   ) )   this.Width    = l_Width   ;   end;

  End; /* Init */

  /* (Public) Добавление дочерних заголовков (допускается передавать значение заголовка + ширину заголовка, или уже готовый
     объект класса CHeader) */
  Macro AddChild(l_StrValue, l_Width:integer)

     var ObjHeader:CHeader; /* Объект класса CHeader */

     if(ValType(l_StrValue) == V_GENOBJ)
          ObjHeader = l_StrValue;
     else ObjHeader = CHeader(String(l_StrValue), l_Width);
     end;
     this.ArrChild[this.ArrChild.Size()] = ObjHeader;
     this.Width = 0;

  End; /* AddChild */

  /* (Public) Удаление дочерних заголовков по номеру (нумерация с 0 и надо не забывать, что если необходимо удалить несколько
      столбцов, то удалять надо начиная с бОльших, так как после каждого удаления столбцы перенумеровываются). При удалении 
      последнего дочернего заголовка ширина родительского приравнивается к ширине последнего удаленного. Если номер столбца
      не задан - удаляются все, а ширина родительского назначается равной сумме всех дочерних заголовков */
  Macro RemoveChild(NumChild:integer);

     var i    :integer = 0;                    /* Счетчик циклов */
     var SzArr:integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */

     if(ValType(NumChild))
          if(NumChild < SzArr)
               /* Если удаляемый элемент последний, то изменим ширину родительского */ 
               if(SzArr == 1)
                    this.Width = this.CalcWidthHeader();               
               end;
               i = NumChild;
               while(i < (SzArr - 1))
                    this.ArrChild[i] = this.ArrChild[i + 1];
                    i = i + 1;
               end;
               this.ArrChild.Size() = this.ArrChild.Size() - 1;
          end;
     else this.Width = this.CalcWidthHeader();
          this.ArrChild.Size() = 0;
     end;

  End; /* RemoveChild */

  /* (Public) Пометка элементов для дальнейшего удаления вместе с родителями, оставшимися без деток, методом RemoveParent.
      Нумерация колонок начинается с 1, порядок пометки произвольный */
  Macro MarkRemoveParent(NumChild:integer, CurCountCol:integer)

     var i       :integer = 0;                    /* Счетчик циклов */
     var SzArr   :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var CountCol:integer = 0;                    /* Текущее количество заголовков нижнего уровня */

     if(ValType(CurCountCol))
          CountCol = CurCountCol;
     end;
     if(SzArr)
          while(i < SzArr)
               CountCol = this.ArrChild[i].MarkRemoveParent(NumChild, CountCol);
               /* Если номер колонки совпал и это заголовок нижнего уровня пометим его к удалению */
               if((CountCol == NumChild)and(Not this.ArrChild[i].ArrChild.Size()))
                    this.ArrChild[i].StrValue = REMOVING_ELEMENT;
               end;
               i = i + 1;
          end;
     else CountCol = CountCol + 1;
     end;
     return CountCol;     
       
  End; /* MarkRemoveParent */

  /* (Public) Хитрое удаление родителей оставшихся без деток. Указываются абсолютные номера заголовков самого нижнего уровня.
     Они удаляются и проверяются родители оставшиеся без деток, они также удаляются и т.д. (рекурсивно) */
  Macro RemoveParent()

     var SzArr:integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var i    :integer = SzArr;                /* Счетчик циклов */

     if(SzArr)
          while(i > 0)
               i = i - 1;
               this.ArrChild[i].RemoveParent();
               if(this.ArrChild[i].StrValue == REMOVING_ELEMENT)
                    this.RemoveChild(i);
                    if(Not this.ArrChild.Size())
                         this.StrValue = REMOVING_ELEMENT;
                    else this.StrValue = Trim(this.StrValue);
                    end;
               end;
          end;
     end;     

  End; /* RemoveParent */

  /* (Public) Получение максимального уровня вложенности (рекурсивно) */
  Macro GetMaxLevel(CurMaxLevel:integer, CurLevel:integer)

     var i       :integer = 0;                    /* Счетчик циклов */
     var SzArr   :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var Level   :integer = 0;                    /* Текущий уровень вложенности */
     var MaxLevel:integer = 0;                    /* Максимальный уровень вложенности */

     if(ValType(CurMaxLevel))
          MaxLevel = CurMaxLevel;
     end;
     if(ValType(CurLevel))
          Level = CurLevel;
     end;
     if(SzArr)
          Level = Level + 1;
          while(i < SzArr)
               MaxLevel = Max(this.ArrChild[i].GetMaxLevel(MaxLevel, Level), Level);
               i = i + 1;
          end;
          Level = Level - 1;
     end;
     return MaxLevel;

  End; /* GetMaxLevel */

  /* (Private) Конвертация узлов заголовка в необходимое представление */
  Macro ConvertNode(_Str:string)

     var i       :integer = 2;                       /* Счетчик циклов */      
     var LenStr  :integer = StrLen(_Str);            /* Размер получившейся строки заголовка */
     var MaxWidth:integer = Index(_Str,"\n");        /* Ширина заголовка */
     var NumSymb :integer = 0;                       /* Номер символа в текущей строке заголовка */
     var RetStr  :string  = SubStr(_Str, 1, LenStr); /* Результирующая строка заголовка (именно так!!!, в другом 
                                                        случае от строки остается не более 1024 символов) */
     if(Not MaxWidth)
          MaxWidth = LenStr;
     end;
     StrSet(RetStr, 1, "┌"); 
     while(i <= LenStr)
          if(SubStr(RetStr, i, 1) == "┼")
               NumSymb = Mod(i, MaxWidth);
               /* Если элемент первый в строке */ 
               if(NumSymb == 1)
                    /* Проверяем знак справа от этого символа */                    
                    if(SubStr(RetStr, i + 1, 1) != "─")          
                         StrSet(RetStr, i, "│");
                    else StrSet(RetStr, i, "├");
                    end; 
               /* Если элемент предпоследний в строке */ 
               elif(NumSymb == (MaxWidth - 1))
                    if(i == (MaxWidth - 1))
                         StrSet(RetStr, i, "┐"); 
                    else /* Проверяем знак слева от этого символа */
                         if(SubStr(RetStr, i - 1, 1) != "─")          
                              StrSet(RetStr, i, "│");
                         else StrSet(RetStr, i, "┤");
                         end;
                    end;
               else if(NumSymb)
                         /* Проверяем знак над этим символом */
                         if(i > MaxWidth)
                              if(SubStr(RetStr, i - MaxWidth, 1) != "│")
                                   StrSet(RetStr, i, "┬" );
                              else /* Проверяем знак слева от этого символа */
                                   if(SubStr(RetStr, i - 1, 1) != "─")          
                                        /* Проверяем знак справа от этого символа */
                                        if(SubStr(RetStr, i + 1, 1) != "─")          
                                             StrSet(RetStr, i, "│" );
                                        else StrSet(RetStr, i, "├");                                   
                                        end;
                                   else /* Проверяем знак справа от этого символа */
                                        if(SubStr(RetStr, i + 1, 1) != "─")          
                                             StrSet(RetStr, i, "┤" );
                                        end;
                                   end; 
                              end;
                         else StrSet(RetStr, i, "┬" );
                         end;
                    end;
               end;
          end;
          i = i + 1;
     end;
     return RetStr;

  End; /* ConvertNode */

  /* (Private) Печать структуры заголовка (рекурсивно) */
  Macro PrintStructHeader(CurProbel:string)

     var i     :integer = 0;                    /* Счетчик циклов */
     var SzArr :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var Probel:string  = "";                   /* Строка, содержащая количество пробелов для отступа */

     if(ValType(CurProbel))
          Probel = CurProbel;
     end;

     Println(Probel + Trim(this.StrValue));
     if(SzArr)  
          Println(Probel + "{");
          while(i < SzArr)
               Probel = Probel + "   ";
               this.ArrChild[i].PrintStructHeader(Probel);
               Probel = SubStr(Probel, 1 , StrLen(Probel) - 3);
               i = i + 1;
          end;
          Println(Probel + "}");
     end;

  End; /* PrintStructHeader */

  /* (Public) Расчет ширины заголовка (рекурсивно) */
  Macro CalcWidthHeader()

     var i          :integer = 0;                    /* Счетчик циклов */
     var SzArr      :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var WidthHeader:integer = 0;                    /* Общая ширина заголовка */
 
     if(SzArr)
          while(i < SzArr)
               if(WidthHeader)
                    WidthHeader = WidthHeader + 1;
               end;
               WidthHeader = WidthHeader + this.ArrChild[i].CalcWidthHeader();
               i = i + 1;
          end;
     else if(WidthHeader)
               WidthHeader = WidthHeader + 1;
          end;
          WidthHeader = WidthHeader + this.Width;
     end;
     return WidthHeader;
 
  End; /* CalcWidthHeader */
  
  /* (Private) Расчет высоты одного уровня заголовка */
  Macro CalcHeightLevel(PrintLevel:integer, CurLevel:integer, MaxLevel:integer, HeightHeader:integer, CurMaxHeightHeader:integer)

     var i          :integer = 0;                    /* Счетчик циклов */
     var SzArr      :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var Level      :integer = CurLevel;             /* Текущий уровень вложенности */
     var HeightLevel:integer = 0;                    /* Высота текущего уровня вложенности */
     var TempHeight :integer = 0;                    /* Вспомогательная переменная для расчета высоты */ 
     var ArrSplit   :TArray  = TArray;               /* Вспомогательный массив для разложения строки заголовка */    
     var MaxHeightHeader     = CurMaxHeightHeader;

     if(Level == PrintLevel)
           ArrSplit = TR_StrSplitExt(Trim(this.StrValue), this.CalcWidthHeader());
           if((SzArr)or(Level == MaxLevel))
                HeightLevel     = ArrSplit.Size();
           else MaxHeightHeader = HeightHeader + ArrSplit.Size() + Level;
           end;
           if(Level == MaxLevel)
                HeightLevel = Max(HeightHeader + HeightLevel + Level, MaxHeightHeader) - HeightHeader - PrintLevel;
           end;
     end;
     MaxHeightHeader = Max(MaxHeightHeader, CurMaxHeightHeader);
     if(SzArr)
          Level = Level + 1;
          while(i < SzArr)
               HeightLevel = Max(HeightLevel, this.ArrChild[i].CalcHeightLevel(PrintLevel, Level, MaxLevel, HeightHeader, MaxHeightHeader));
               i = i + 1;
          end;
          Level = Level - 1;
     end;
     SetParm(5, MaxHeightHeader);
     return HeightLevel;      

  End; /* CalcHeightLevel */

  /* (Public) Расчет высоты заголовка на указанном уровне. Если параметр не задан, то рассчитывается максимальная высота заголовка */
  Macro CalcHeightHeader(CurLevel:integer)

     var i           :integer = 1;                  /* Счетчик циклов */
     var MaxLevel    :integer = this.GetMaxLevel(); /* Максимальный уровень вложенности */
     var HeightHeader:integer = 0;                  /* Высота заголовка */
     var Level       :integer = MaxLevel;           /* Уровень для которого производится расчет высоты заголовка */

     if(ValType(CurLevel))
          Level = CurLevel;
     end;     
     while(i <= Level)
          HeightHeader = HeightHeader + this.CalcHeightLevel(i, 0, MaxLevel, HeightHeader, 0);
          i = i + 1;
     end;     
     return HeightHeader;

  End; /* CalcHeightHeader */

  /* (Public) Принудительное добавления строки с нумерацией столбцов */   
  Macro AddNumberLine(_Str:string);

     var LenStr  :integer = StrLen(_Str);                        /* Размер получившейся строки заголовка */
     var MaxWidth:integer = Index(_Str,"\n");                    /* Ширина заголовка */
     var LastStr :string  = SubStr(_Str, LenStr - MaxWidth + 2); /* Последняя строка заголовка */
     var i       :integer = 0;                                   /* Счетчик циклов */
     var TempStr1:string  = SubStr(LastStr, 2);                  /* Вспомогательная строка */
     var TempStr2:string  = "";                                  /* Вспомогательная строка */
     var TempStr3:string  = "";                                  /* Вспомогательная строка */
     var Pos     :integer = Index(TempStr1, "┼");                /* Номер позиции символа */
     var Str     :string  = _Str + "\n│";;                       /* Возвращаемая строка */

     while(Pos)
          i = i + 1;
          TempStr3 = "\"" + String(i) + "\"";
          TempStr2 = "String("
                  + TempStr3 + ":"
                  + String(Pos - 1)
                  + ":c)";
          Str = Str + TR_ExecExp(TempStr2) + "│";
          TempStr1 = SubStr(TempStr1, Pos + 1);

          Pos = Index(TempStr1, "┼");
     end;
     Str = Str + "\n" + LastStr;    
     return Str;
       
  End; /* AddNumberLine */

  /* (Public) Принудительное удаление строки с нумерацией столбцов (если точнее, то всех "бездетных" элементов) */   
  Macro RemoveNumberLine()  

     var SzArr :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var i     :integer = this.ArrChild.Size(); /* Счетчик циклов */

     if(SzArr)  
          while(i > 0)
               i = i - 1;
               if(this.ArrChild[i].ArrChild.Size())
                    this.ArrChild[i].RemoveNumberLine();
               else this.RemoveChild(i);
               end;
          end;
     end;

  End; /* RemoveNumberLine */

  /* (Private) Получение разделителей для одной строки заголовка */
  Macro CreateSepHeader(PrintLevel:integer, CurLevel:integer, MaxLevel:integer, HeightLevel:integer, HeightHeader:integer, Parent)

     var i        :integer = 0;                    /* Счетчик циклов */
     var SzArr    :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var Level    :integer = CurLevel;             /* Текущий уровень вложенности */
     var TempStr  :string  = "";                   /* Вспомогательная переменная для использования в функции TR_ExecExp */
     var TempValue:string  = "";                   /* Вспомогательная переменная для использования в функции TR_ExecExp */ 
     var Str      :string  = "";                   /* Строка заголовка первого приближения */
     var ArrSplit :TArray  = TArray;               /* Вспомогательный массив для разложения строки заголовка */    

     if(Level == PrintLevel)
          if(Not SzArr)
               if(PrintLevel < MaxLevel)
                    ArrSplit  = TArray;
                    ArrSplit  = TR_StrSplitExt(this.StrValue, this.CalcWidthHeader());
                    if(ArrSplit[HeightHeader - Parent.CalcHeightHeader(Level - 1) + HeightLevel - 1])
                         TempValue = "\"" + TrStrSubst(String(ArrSplit[HeightHeader - Parent.CalcHeightHeader(Level - 1) + HeightLevel - 1]), "\"", "\\" + "\"")  + "\"";
                    else TempValue = "\"" + "\"";
                    end;
                    TempStr = "String("
                            + TempValue + ":"
                            + String(this.CalcWidthHeader())
                            + ":c)";
                    Str = Str + TR_ExecExp(TempStr);
               else Str = Str + MkStr("─", this.CalcWidthHeader());
               end;
               Str = Str + "┼";
          else while(i < SzArr)
                    Str = Str + MkStr("─", this.ArrChild[i].CalcWidthHeader());
                    Str = Str + "┼";
                    i = i + 1;  
               end;
          end;
     end;
     if(SzArr)
          i = 0;
          Level = Level + 1;
          while(i < SzArr)
               Str = Str + this.ArrChild[i].CreateSepHeader(PrintLevel, Level, MaxLevel, HeightLevel, HeightHeader, Parent);
               i = i + 1;
          end;
          Level = Level - 1;
     else if(Level < PrintLevel)
               if(PrintLevel < MaxLevel)
                    ArrSplit  = TArray;
                    ArrSplit  = TR_StrSplitExt(this.StrValue, this.CalcWidthHeader());
                    if(ArrSplit[HeightHeader - Parent.CalcHeightHeader(Level - 1) + HeightLevel + PrintLevel - Level - 1])
                         TempValue = "\"" + TrStrSubst(String(ArrSplit[HeightHeader - Parent.CalcHeightHeader(Level - 1) + HeightLevel + PrintLevel - Level - 1]), "\"", "\\" + "\"")  + "\"";
                    else TempValue = "\"" + "\"";
                    end;
                    TempStr = "String("
                            + TempValue + ":"
                            + String(this.CalcWidthHeader())
                            + ":c)";
                    Str = Str + TR_ExecExp(TempStr);
               else Str = Str + MkStr("─", this.CalcWidthHeader());
               end;
               Str = Str + "┼";
          end;
     end;       
     return Str;      

  End; /* CreateSepHeader */

  /* (Private) Получение одной строки заголовка */
  Macro CreateStrHeader(PrintLevel:integer, CurLevel:integer, HeightLevel:integer, HeightHeader:integer, Parent)

     var i        :integer = 0;                    /* Счетчик циклов */
     var SzArr    :integer = this.ArrChild.Size(); /* Размер массива дочерних заголовков */
     var Level    :integer = CurLevel;             /* Текущий уровень вложенности */
     var TempStr  :string  = "";                   /* Вспомогательная переменная для использования в функции TR_ExecExp */
     var TempValue:string  = "";                   /* Вспомогательная переменная для использования в функции TR_ExecExp */ 
     var Str      :string  = "";                   /* Строка заголовка первого приближения */
     var ArrSplit :TArray  = TArray;               /* Вспомогательный массив для разложения строки заголовка */    

     if(Level == PrintLevel)
          ArrSplit  = TR_StrSplitExt(this.StrValue, this.CalcWidthHeader());
          if(ArrSplit.Size() >= HeightLevel)
               TempValue = "\"" + TrStrSubst(String(ArrSplit[HeightLevel - 1]), "\"", "\\" + "\"")  + "\"";
          else TempValue = "\"" + "\"";
          end;
          TempStr = "String("
                  + TempValue + ":"
                  + String(this.CalcWidthHeader())
                  + ":c)";
          Str = Str + TR_ExecExp(TempStr);
          Str = Str + "│";
     end;
     if(SzArr)
          Level = Level + 1;
          while(i < SzArr)
               Str = Str + this.ArrChild[i].CreateStrHeader(PrintLevel, Level, HeightLevel, HeightHeader, Parent);
               i = i + 1;
          end;
          Level = Level - 1;
     else if(Level < PrintLevel)
               ArrSplit  = TArray;
               ArrSplit  = TR_StrSplitExt(this.StrValue, this.CalcWidthHeader());
               if(ArrSplit[HeightHeader - Parent.CalcHeightHeader(Level - 1) + HeightLevel + PrintLevel - level - 1])
                    TempValue = "\"" + TrStrSubst(String(ArrSplit[HeightHeader - Parent.CalcHeightHeader(Level - 1) + HeightLevel + PrintLevel - level - 1]), "\"", "\\" + "\"")  + "\"";
               else TempValue = "\"" + "\"";
               end;
               TempStr = "String("
                       + TempValue + ":"
                       + String(this.CalcWidthHeader())
                       + ":c)";
               Str = Str + TR_ExecExp(TempStr);
               Str = Str + "│";
          end;
     end; 
     return Str;      

  End; /* CreateStrHeader */

  /* (Public) Получение заголовка (рекурсивно) */
  Macro CreateHeader(FlagAddNumberLine:integer)

     var i              :integer = 0;                  /* Счетчик циклов */
     var MaxLevel       :integer = this.GetMaxLevel(); /* Максимальный уровень вложенности */
     var Str            :string  = "";                 /* Строка заголовка первого приближения (необходима для метода ConvertNode) */
     var HeightLevel    :integer = 0;                  /* Высота текущего уровня */
     var HeightHeader   :integer = 0;                  /* Высота всего заголовка для текущего уровня */
     var MaxHeightHeader:integer = 0;                  /* Максимальная высота заголовка */
     var j              :integer = 0;                  /* Счетчик циклов */

     while(i <= MaxLevel)
          if(i != 0)
               j = 1;
               HeightLevel = this.CalcHeightLevel(i, 0, MaxLevel, HeightHeader, MaxHeightHeader);
               while(j <= HeightLevel)
                    Str = Str + "│";
                    Str = Str + this.CreateStrHeader(i, 0, j, HeightHeader, this);
                    Str = Str + "\n";
                    j   = j + 1;
               end;
          end;
          Str = Str + "┼";
          Str = Str + this.CreateSepHeader(i, 0, MaxLevel, j, HeightHeader, this);
          if(i != MaxLevel)
               Str = Str + "\n";
          end;
          HeightHeader = HeightHeader + HeightLevel;
          i = i + 1;
     end;
     if(FlagAddNumberLine == NUMBER_LINE)
          Str = this.AddNumberLine(Str);
     end;
     Str = this.ConvertNode(Str);
     return Str;

  End; /* CreateHeader */

  /* (Public) Закачка строки заголовка в объект заголовка */ 
  Macro ParcelHeader(Str:string, FlagRemoveNumberLine:integer)

     var Pos      :integer = Index(Str, "\n"); /* Позиция найденного символа-разделителя */
     var HeightStr:integer = 0;                /* Высота строки заголовка */
     var WidthStr :integer = Index(Str, "\n"); /* Ширина строки заголовка */
     var CrntStr  :string  = "";               /* Текущая строка */
     var i        :integer = 0;                /* Счетчик циклов */
     var NewStr   :string  = "";               /* Строка, которая формируется для вызова рекурсии */
     var TempStr  :string  = Str;              /* Вспомогательная строка для подсчета высоты */

     /* Расчитаем высоту строки заголовка */
     while(Pos)
          HeightStr = HeightStr + 1;
          TempStr   = SubStr(TempStr, Pos + 1);
          Pos       = StrBrk(TempStr, "\n");
     end;
     HeightStr = HeightStr + 1;     
     Pos = StrBrk(Str, "┌┬┐├┼┤");
     while((Pos)and(Pos < WidthStr))
          if(Pos > 1)
               i = 1;
               /* Если не последняя строка, то вызовем себя рекурсивно с новой строкой */
               if(i < (HeightStr - 1))
                    /* Формируем очередной объект заголовка */
                    CrntStr = SubStr(Str, 1 + WidthStr * i, Pos - 1);
                    this.AddChild("", StrLen(CrntStr));
                    while(Not Index(CrntStr, "─"))
                         this.ArrChild[this.ArrChild.Size() - 1].StrValue = this.ArrChild[this.ArrChild.Size() - 1].StrValue + CrntStr;
                         i = i + 1;
                         CrntStr = SubStr(Str, 1 + WidthStr * i, Pos - 1);
                    end;
                    /* Формируем строку для рекурсии */
                    NewStr = "";
                    while(i < HeightStr)
                         CrntStr = SubStr(Str, WidthStr * i, Pos + 1);
                         NewStr = NewStr + CrntStr;
                         if(i < (HeightStr - 1))
                              NewStr = NewStr + "\n";
                         end;
                         i = i + 1;
                    end;
                    this.ArrChild[this.ArrChild.Size() - 1].ParcelHeader(NewStr);
               end;
          end;
          Str = SubStr(Str, Pos + 1);
          Pos = StrBrk(Str, "┌┬┐├┼┤");
     end;
     if(FlagRemoveNumberLine == NUMBER_LINE)
          this.RemoveNumberLine();
     end;

  End; /* ParcelHeader */

  /* Конструктор */
  Init(_StrValue, _Width);
  /**/

END; /* CHeader */
