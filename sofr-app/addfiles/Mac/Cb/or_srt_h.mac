/*╔═══════════════════════════════════════════════════════════════════════════╗*/
/*║           Автоматизированная банковская система RS-Bank v5.1              ║*/
/*║               Copyright (c) R-Style Software Lab 2001-2004                ║*/
/*║                                                                           ║*/
/*║ Имя файла     or_srt_h.mac                                                ║*/
/*║                                                                           ║*/
/*║ Описание      Функции сортировки на все случаи жизни                      ║*/
/*║                                                                           ║*/
/*║ Программист   Зуев С.В.                                                   ║*/
/*║                                                                           ║*/
/*║ Создан        27.02.2002                                                  ║*/
/*║                                                                           ║*/
/*╚═══════════════════════════════════════════════════════════════════════════╝*/
/* Список классов:
  *CSortField   - Вспомогательный класс для сортировки
  *CSubResField - Вспомогательный класс для подведения подитогов 

Список функций:
  SortArray          - Функция сортирует массив TArray по возрастанию или по убыванию, в зависимости от флага
  QSortWithUserMacro - Функция сортирует массив TArray с любыми типами данных с использованием пользовательского макроса сравнения элементов
*/
/* Класс поля сортировки */
CLASS CSortField(_Number:integer, _Direct:integer)

  VAR Number:integer = 0; /* Номер столбца для сортировки */
  VAR Direct:integer = 1; /* Направление сортировки (больше 0 - по возрастанию (по умолчанию), меньше 0 - по убыванию) */
 
  /* Инициализация класса */
  Macro Init(l_Number:integer, l_Direct:integer);

     if( ValType(l_Number) )   this.Number = l_Number;    end;
     if( ValType(l_Direct) )   this.Direct = l_Direct;    end;

  End; /* Init */

  /* Конструктор */
  this.Init(_Number, _Direct);

END; /* CSortField */

/* Класс поля подитогов */
CLASS (CSortField)CSubResField(_Number    :integer, _Direct               :integer, _NumColSubRes:integer,
                               _TextSubRes:string,  _CountStrForShowSubRes:integer,_StrModif_ForSubRes:string,
                               _StrModif_ForSubResSum:string )

  VAR NumColSubRes         :integer = 0;       /* Номер столбца, в котором будет располагаться текст для подитогов */
  VAR TextSubRes           :string  = "ИТОГО"; /* Текст для подитогов */
  VAR CountStrForShowSubRes:integer = 1;       /* Минимальное количество строк необходимых для показа подитогов (по умолчанию 1) */ 
  VAR StrModif_ForSubRes   :string  = "l:ex_FS(b):ex_B(rlbt)";
  VAR StrModif_ForSubResSum:string  = ":r:ex_FS(b)";
  /* Инициализация класса */
  Macro Init(l_Number:integer, l_Direct:integer, l_NumColSubRes:integer, l_TextSubRes:string, l_CountStrForShowSubRes:integer,l_StrModif_ForSubRes:string,l_StrModif_ForSubResSum:string)
     /* Конструктор родительского класса */
     InitCSortField(l_Number, l_Direct);

     if(ValType(l_NumColSubRes         ))  this.NumColSubRes          = l_NumColSubRes         ; end;
     if(ValType(l_TextSubRes           ))  this.TextSubRes            = l_TextSubRes           ; end;
     if(ValType(l_CountStrForShowSubRes))  this.CountStrForShowSubRes = l_CountStrForShowSubRes; end;
     if(ValType(l_StrModif_ForSubRes   ))  this.StrModif_ForSubRes    = l_StrModif_ForSubRes   ; end;
     if(ValType(l_StrModif_ForSubResSum))  this.StrModif_ForSubResSum = l_StrModif_ForSubResSum; end;
  End; /* Init */                       

  /* Конструктор наследника */
  this.Init(_Number, _Direct, _NumColSubRes, _TextSubRes, _CountStrForShowSubRes,_StrModif_ForSubRes,_StrModif_ForSubResSum);

END; /* CSubResField */

/* Сортирует массив TArray по возрастанию при флаге FlagSort равном True или по убыванию, при False */
MACRO SortArray(Arr, FlagSort)

  VAR i        :integer = 0;          /* Счетчик циклов */
  VAR j        :integer = 0;          /* Счетчик циклов */
  VAR sz       :integer = Arr.Size(); /* Размер переданного массива */
  VAR TempIndex:integer = 0;          /* Временная переменная для индекса */
  VAR TempValue;                      /* Временная переменная для значения */

  if(FlagSort)
       while(i < sz)
            TempIndex = i;
            j = i;
            while( j < (sz-1))
                 if(Arr[j+1] < Arr[TempIndex])            
                      TempIndex = j + 1;
                 end;
                 j = j + 1;
            end;
            TempValue = Arr[TempIndex];
            Arr[TempIndex] = Arr[i];
            Arr[i] =  TempValue;
            i = i + 1;
       end;
  else while(i < sz)
            TempIndex = i;
            j = i;
            while( j < (sz-1))
                 if(Arr[j+1] > Arr[TempIndex])            
                      TempIndex = j + 1;
                 end;
                 j = j + 1;
            end;
            TempValue = Arr[TempIndex];
            Arr[TempIndex] = Arr[i];
            Arr[i] =  TempValue;
            i = i + 1;
       end;
  end;
  Return Arr;

END; /* SortArray */

/* Макрос для сортировки массива TArray в произвольном порядке. Массив может содержать как данные 
   нативных типов, так и объекты. Макрос сравнения данных CmpFldMacro определяется пользователем
   и передается в виде имени. Если это не глобальный макрос, а имя метода некоторого объекта, то
   необходимо передать ссылку на этот объект в параметре Obj, иначе Null.
*/
/* Пример макроса сравнения : сортировка простого массива в прямом порядке */
Macro CmpParamForQSort(p1, p2):integer

  if  (p1 < p2) return -1;
  elif(p1 > p2) return  1;
  end;
  return 0;

End; /* CmpParamForQSort */

/* Сортирует массив TArray с любыми типами данных с использованием пользовательского макроса сравнения элементов */
Macro QSortWithUserMacro(Arr:TArray, CmpFldMacro, Obj, _BegDiap, _EndDiap)

  var BegDiap:integer = 0;              /* Начало диапазона сортировки */
  var EndDiap:integer = Arr.Size() - 1; /* Конец диапазона сортировки */

  /* Проверим корректность переданного диапазона сортировки */
  if(ValType(_BegDiap))
       if((_BegDiap >= BegDiap)and(_BegDiap <= EndDiap))
            BegDiap = _BegDiap;
       end;
  end;
  if(ValType(_EndDiap))
       if((_EndDiap >= BegDiap)and(_EndDiap <= EndDiap))
            EndDiap = _EndDiap;
       end;
  end;

  /* Макрос по технологии быстрой сортировки */
  macro QuickSort(left:integer, right:integer)

       var i   :integer = left;
       var j   :integer = right;
       var flag:bool    = TRUE;
       var swap;
       var test = Arr[Int((left+right)/2.0)];

       while(flag)
            if(Not Obj)
                 while(ExecMacro2(CmpFldMacro, Arr[i], test) < 0)
                      i = i + 1;
                 end; 
                 while(ExecMacro2(CmpFldMacro, test, Arr[j]) < 0)
                      j = j - 1;
                 end; 
            else while(GenRun(Obj, CmpFldMacro, Arr[i], test) < 0)
                      i = i + 1;
                 end; 
                 while(GenRun(Obj, CmpFldMacro, test, Arr[j]) < 0)
                      j = j - 1;
                 end; 
            end;
            if(i <= j)
                 swap   = Arr[i];
                 Arr[i] = Arr[j];
                 Arr[j] = swap;
                 i      = i + 1;
                 j      = j - 1;
            end;
            if(i > j)
                 flag = FALSE;
            end;
       end;
       if(left < j)
            QuickSort(left, j);
       end;
       if(i < right)
            QuickSort(i, right);
       end;
  end; /* QuickSort */

  if(Arr.Size() > 1)
       QuickSort(BegDiap, EndDiap);
  end;

End; /* QSortWithUserMacro */
