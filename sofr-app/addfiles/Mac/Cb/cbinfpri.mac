/*
    CBINF PRImary
    
    Информирование о необработанных документах

    Обработка первичек для списков отложенных и открытых

            Mikhailov S., 22.08.2001, Wed

    
*/


import cbinfcom;
import RSD;

/*__________________________________*/
macro ProcPSPayOrd( RegPath, OutType/*CBINF_Out...*/, State/*PSPO_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file pspayord( pspayord ) key 2;

/*    rewind ( pspayord );*/
    
  InitProgress( NRecords(pspayord), "Информирование о необработанных документах" );
  
/*    while( next( pspayord ) )*/

    cmd = RSDCommand("select t.T_OPER, t.t_OrderID" +
                      " from dpspayord_dbt t " +
                      " where t.T_CurrentState = " + State );
    rs = RsdRecordset( cmd );           
    cmd.execute;


    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress(  );
      
        if( /*( pspayord.CurrentState == State ) and*/ ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            pspayord.OrderId = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegPsPayOrd, pspayord, State );
                if( this_stat )
                    RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegPsPayOrd, pspayord );
                if( this_stat )
                    RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcPSPayOrd*/




/*__________________________________*/
macro ProcPsCpOrd( RegPath, OutType/*CBINF_Out...*/, State/*CP_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file pscpord( pscpord ) key 2;

/*    rewind ( pscpord );
  */  

  InitProgress( NRecords(pscpord), "Информирование о необработанных документах" );
  
/*    while( next( pscpord ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.t_OrderID" +
                      " from dpscpord_dbt t " +
                      " where t.T_CurrentState = " + State);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( pscpord.CurrentState == State ) and*/ ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            pscpord.OrderId = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegPsCpOrd, pscpord, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegPsCpOrd, pscpord );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcPsCpOrd*/



/*__410________________________________*/
macro ProcPsCshDoc( RegPath, OutType/*CBINF_Out...*/, State/*STAT_CASH_ORDER_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file pscshdoc( pscshdoc ) key 0;

/*    rewind ( pscshdoc );
  */  

  InitProgress( NRecords(pscshdoc), "Информирование о необработанных документах" );
  
/*    while( next( pscshdoc ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.T_AutoKey " +
                      " from dpscshdoc_dbt t " +
                      " where t.T_Status = " + State +
                      " and   t.T_DocKind = " + CASH_PS_INCORDER);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( pscshdoc.DocKind == CASH_PS_INCORDER ) and 
            ( pscshdoc.Status == State ) and */
            ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            pscshdoc.AutoKey = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegPSCshDoc, pscshdoc, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegPSCshDoc, pscshdoc );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcPsCshDoc*/



/*__________________________________*/
macro ProcCheckIss( RegPath, OutType/*CBINF_Out...*/, State/*CHECKISS_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file checkiss( checkiss ) key 2;

/*    rewind ( checkiss );
  */  

  InitProgress( NRecords(checkiss), "Информирование о необработанных документах" );
  
/*    while( next( checkiss ) )
  */
      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
    cmd = RSDCommand("select t.T_OPER, t.t_Number" +
                      " from dcheckiss_dbt t " +
                      " where t.T_CurrentState = " + State);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

        if(/* ( checkiss.CurrentState == State ) and*/ ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            checkiss.Number = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegCheckIss, checkiss, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegCheckIss, checkiss );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcCheckIss*/

/*__________________________________*/
macro ProcReqOpenA( RegPath, OutType/*CBINF_Out...*/, State/*REQOPENA_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file reqopena( reqopena ) key 3;

/*    rewind ( reqopena );
  */  

  InitProgress( NRecords(reqopena), "Информирование о необработанных документах" );
  
/*    while( next( reqopena ) )
  */
      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
    cmd = RSDCommand("select t.T_OPER, t.t_Number" +
                      " from dreqopena_dbt t " +
                      " where t.T_CurrentState = " + State);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

        if(/* ( reqopena.CurrentState == State ) and*/ ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            reqopena.Number = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegReqOpenA, reqopena, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegReqOpenA, reqopena );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcReqOpenA*/


/*__________________________________*/
macro ProcReqClosA( RegPath, OutType/*CBINF_Out...*/, State/*REQCLOSA_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file reqclosa( reqclosa ) key 3;

/*    rewind ( reqclosa );
  */  

  InitProgress( NRecords(reqclosa), "Информирование о необработанных документах" );
  
/*    while( next( reqclosa ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.t_Number" +
                      " from dreqclosa_dbt t " +
                      " where t.T_CurrentState = " + State);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( reqclosa.CurrentState == State ) and*/ ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            reqclosa.Number = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegReqClosA, reqclosa, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegReqClosA, reqclosa );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcReqClosA*/


/*__200________________________________*/
macro ProcPsBcOrd( RegPath, OutType/*CBINF_Out...*/, State/*PSBCORD_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file ps_bcord( ps_bcord ) key 0;

/*    rewind ( ps_bcord );
  */  

  InitProgress( NRecords(ps_bcord), "Информирование о необработанных документах" );
  
/*    while( next( ps_bcord ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.t_Number, t.T_SourceAccount, t.T_RequiredAccount" +
                      " from dps_bcord_dbt t " +
                      " where t.T_CurrentState = " + State);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( ps_bcord.CurrentState == State ) and */
            ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            ps_bcord.Number = rs.value(1); /* чтобы не исправлять cbinfcom.mac */
            ps_bcord.SourceAccount = rs.value(2); /* чтобы не исправлять cbinfcom.mac */
            ps_bcord.RequiredAccount = rs.value(3); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegPsBcOrd, ps_bcord, State );
                if( this_stat )
                    RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegPsBcOrd, ps_bcord );
                if( this_stat )
                    RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcPsBcOrd*/


/*__15________________________________*/
macro ProcMultyDoc( RegPath, OutType/*CBINF_Out...*/, State/*MCDOC_STATUS_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file multydoc( multydoc ) key 0;

/*    rewind ( multydoc );
  */  

  InitProgress( NRecords(multydoc), "Информирование о необработанных документах" );
  
/*    while( next( multydoc ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.t_AutoKey" +
                      " from dmultydoc_dbt t " +
                      " where t.T_Status = " + State);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( multydoc.Status == State ) and */
            ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            multydoc.AutoKey = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegMultyDoc, multydoc, State );
                if( this_stat )
                    RemProgress( nmbRec );
                  return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegMultyDoc, multydoc );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcMultyDoc*/




/*__________________________________*/
macro ProcBankPayment( RegPath, OutType/*CBINF_Out...*/, State/*MEMORDER_STATUS_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file memorder( memorder ) key 1;

/*    rewind ( memorder );
  */  

  InitProgress( NRecords(memorder), "Информирование о необработанных документах" );
  
/*    while( next( memorder ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.T_OrderID" +
                      " from dmemorder_dbt t " +
                      " where t.T_Status = " + State +
                      " and   t.T_DocKind = " + DLDOC_BANKPAYMENT);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( memorder.DocKind == DLDOC_BANKPAYMENT ) and
            ( memorder.Status == State ) and*/
            ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            memorder.OrderId = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegBankPayment, memorder, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegBankPayment, memorder );
                if( this_stat )
                  RemProgress( nmbRec );
                   return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcBankPayment*/



/*__________________________________*/
macro ProcBankClaim( RegPath, OutType/*CBINF_Out...*/, State/*MEMORDER_STATUS_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file memorder( memorder ) key 1;

/*    rewind ( memorder );
  */  

  InitProgress( NRecords(memorder), "Информирование о необработанных документах" );
  
/*    while( next( memorder ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.T_OrderID" +
                      " from dmemorder_dbt t " +
                      " where t.T_Status = " + State +
                      " and   t.T_DocKind = " + DLDOC_BANKCLAIM);
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( memorder.DocKind == DLDOC_BANKCLAIM ) and
            ( memorder.Status == State ) and*/
            ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            memorder.OrderId = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegBankClaim, memorder, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegBankClaim, memorder );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcBankClaim*/

/*__________________________________*/
macro ProcBBCpOrd( RegPath, OutType/*CBINF_Out...*/, State/*CP_ST_...*/ )
    var this_stat, nmbRec = 0, cmd, rs;
    file bbcpord( bbcpord ) key 2;

/*    rewind ( bbcpord );
  */  

  InitProgress( NRecords(bbcpord), "Информирование о необработанных документах" );
  
/*    while( next( bbcpord ) )
  */
    cmd = RSDCommand("select t.T_OPER, t.t_OrderID" +
                      " from dbbcpord_dbt t " +
                      " where t.T_CurrentState = " + State );
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if(/* ( bbcpord.CurrentState == State ) and*/ ( CBINF_OperDocFit( rs.value(0) ) == 0 ) )
        
            bbcpord.OrderId = rs.value(1); /* чтобы не исправлять cbinfcom.mac */

            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegBBCpOrd, bbcpord, State );
                if( this_stat )
                  RemProgress( nmbRec );
                   return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegBBCpOrd, bbcpord );
                if( this_stat )
                  RemProgress( nmbRec );
                   return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcBBCpOrd*/



/*___28_______________________________*/
/*
macro ProcBBCpTrn( RegPath, OutType/*CBINF_Out...*/, State/*CP_ST_...*/ )
    var this_stat, nmbRec = 0;
    file bbcptrn( bbcptrn ) key 2;

    rewind ( bbcptrn );
    

  InitProgress( NRecords(bbcptrn), "Информирование о необработанных документах" );
  
    while( next( bbcptrn ) )

      nmbRec = nmbRec + 1;
      UseProgress( nmbRec );
      
        if( ( bbcptrn.CurrentState == State ) and ( CBINF_OperDocFit( bbcptrn.Oper ) == 0 ) )
        
            if( OutType == CBINF_OutMsg )
            
                this_stat = MsgDocFound( RegPath, CBINF_RegBBCpTrn, bbcptrn, State );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            elif( OutType == CBINF_OutReport )
                this_stat = PrintLine( RegPath, CBINF_RegBBCpTrn, bbcptrn );
                if( this_stat )
                  RemProgress( nmbRec );
                    return this_stat;
                end;
                
            end;/*OutType*/
            
        end;/*if CBINF_OperDocFit*/
        
    end;/*while*/

    RemProgress( nmbRec );
    return CBINF_StatusOk;
    
end;/*ProcBBCpTrn*/
*/



