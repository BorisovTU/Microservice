/* ──────────────────────────────────────────────────────────────────────────┐
   RS-Bank V6                                                 R-Style Softlab
   Файл проекта RS-Reporting

   Класс для создания кеша

   CREATED : 26.04.2013 ABP
└────────────────────────────────────────────────────────────────────────── */

import lib_lang;

const CACHE_MODE_INDEX = 0;
const CACHE_MODE_ORDERED = 1;
const CACHE_MODE_DISORDERED = 2;

private class TBaseCache(initialSize : Integer, createValueFunction, createKeyFunction)
    private var m_initialSize : Integer;
    private var m_container : TArray;

    private var m_createValueFunction;
    private var m_createKeyFunction;

    private var m_currentIndex : Integer;

    private macro createValue(key)
        if (m_createValueFunction != null)
            return callR2M(m_createValueFunction, key);
        else
            return null;
        end;
    end;

    private macro createKey(value)
        if (m_createKeyFunction != null)
            return callR2M(m_createKeyFunction, value);
        else
            return null;
        end;
    end;

    private macro createContainer()
        if (m_container == null)
            m_container = TArray(m_initialSize, int(m_initialSize/2));
        end;
    end;

    private macro constructorTBaseCache(initialSize : Integer, createValueFunction, createKeyFunction)
        m_initialSize = initialSize;
        m_createValueFunction = createValueFunction;
        m_createKeyFunction = createKeyFunction;
        m_currentIndex = -1;
    end;

    /**
     * Инициализация итератора кеша
     */
    macro rewind()
        m_currentIndex = -1;
    end;

    macro clear()
        rewind();
        if (m_container != null)
            m_container.size = 0;
        end;
    end;

    /**
     * Переход на следующий определенный (не равен null) элемент кеша.
     */
    macro next() : Bool
        if (m_container == null)
            return false;
        end;

        m_currentIndex = m_currentIndex + 1;

        while (    (m_currentIndex < m_container.size)
               and (m_container.value(m_currentIndex) == null)
              )
            m_currentIndex = m_currentIndex + 1;
        end;

        if (m_currentIndex >= m_container.size)
            return false;
        end;

        return true;
    end;

    macro getCurrent() : Variant
        if (   (m_currentIndex >= m_container.size)
            or (m_currentIndex == -1)
           )
            return false;
        end;

        return m_container.value(m_currentIndex);
    end;

    macro getCurrentIndex() : Integer
        return m_currentIndex;
    end;

    constructorTBaseCache(initialSize, createValueFunction, createKeyFunction);
end;

// ключом является индекс массива
// не рекомендуется для больших значений ключа, т.к. ОЧЕНЬ сильно расходует память: макс. значение ключа примерно равно объему
// выделяемой памяти в байтах
private class (TBaseCache) TCacheKeyUsingIndex(initialSize : Integer, createValueFunction, createKeyFunction)
    // добавляет значение в контейнер, если в контейнере нет ключа этого значения
    // возвращает добавленное значение, ключ, индекс в хранилище
    // при незаданном ключе попытается определить его по значению
    // при незаданном значении попытается определить его по ключу
    macro add(key, value, idx : integer, isOrderedData : bool)
        defaultParm(isOrderedData, false);
        idx = null;

        var needAddition = false;

        createContainer();

        if ((key < 0) or (key == null))
            key = createKey(value);
        end;

        if (key >= 0)
            var tempValue = m_container.value(key);
            if (tempValue == null)
                if (value == null)
                    value = createValue(key);
                end;
                m_container.value(key) = value;
            else
                value = tempValue;
            end;
            idx = key;
        end;

        setParm(1, key);
        setParm(3, idx);
        return value;
    end;

    // Возвращает значение по ключу,
    // так же возвращает значение индекса в хранилище.
    // Если в хранилище отсутсвует элемент с заданным ключом,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro get(key, idx : Integer)
        idx = key;
        var value = getDirect(idx, key);
        setParm(1, idx);
        setParm(2, key);
        return value;
    end;

    // Возвращает значение по индексу в массиве-хранилище,
    // так же возвращает значение ключа через параметр key.
    // Если в хранилище отсутсвует элемент с заданным индексом и в параметре key передали значение,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro getDirect(idx : Integer, key)
        var value = null;

        createContainer();

        key = idx;
        if (idx >= 0)
            value = m_container.value(idx);

            if (value == null)
                value = createValue(key);
                add(key, value, idx, false);
            end;
        end;

        setParm(1, idx);
        setParm(2, key);
        return value;
    end;

    private macro constructorTCacheKeyUsingIndex(initialSize : Integer, createValueFunction, createKeyFunction)
        initTBaseCache(initialSize, createValueFunction, createKeyFunction);
    end;

    constructorTCacheKeyUsingIndex(initialSize, createValueFunction, createKeyFunction);
end;

// данные хранятся упорядоченно
private class (TBaseCache) TCacheOrderedStorage(initialSize : Integer, createValueFunction, createKeyFunction)
    private const FIND_ALGORITHM_THRESHOLD = 100;

    // поиск значения по ключу
    // использует бинарный поиск или перебор в зависимости от размера хранилища
    // возвращает найденное значение или null, индекс найденного значения или null
    // при needIndex == true вернет значение индекса для вставки в массив, если не найдет значение по ключу
    private macro find(key, idx, needIndex)
        defaultParm(needIndex, false);

        var value = null;
        var i;

        if (m_container.size > FIND_ALGORITHM_THRESHOLD)
            var left;
            var right;

            left = 0;
            right = m_container.size - 1;

            while (left < right)
                i = int((left + right)/2);
                if (m_container.value(i).value(0) < key)
                    left = i + 1;
                else
                    right = i;
                end;
            end;

            if (m_container.value(left).value(0) == key)
                value = m_container.value(left).value(1);
                idx = left;
            else
                if (needIndex)
                    idx = left + 1;
                else
                    idx = null;
                end;
            end;
        else
            i = 0;
            value = null;
            while ((i < m_container.size) and (m_container.value(i).value(0) < key))
                i = i + 1;
            end;
            if ((i < m_container.size) and (m_container.value(i).value(0) == key))
                value = m_container.value(i).value(1);
                idx = i;
            else
                if (needIndex)
                    idx = i;
                else
                    idx = null;
                end;
            end;
        end;

        setParm(2, idx);
        return value;
    end;

    // добавляет значение в контейнер, если в контейнере нет ключа этого значения
    // возвращает добавленное значение, ключ, индекс в хранилище
    // при незаданном ключе попытается определить его по значению
    // при незаданном значении попытается определить его по ключу
    macro add(key, value, idx : integer, isOrderedData : bool)
        defaultParm(isOrderedData, false);
        idx = null;

        var needAddition = false;

        createContainer();

        if (key != null)
            var tempValue = find(key, idx, true);
            if (tempValue == null)
                if (value == null)
                    value = createValue(key);
                end;
                needAddition = true;
            else
                value = tempValue;
            end;
        end;

        if ((not needAddition) and (key == null) and (value != null))
            key = createKey(value);
            if ((key != null) and (find(key, idx, true) == null))
                needAddition = true;
            end;
        end;

        if (needAddition)
            if (isOrderedData)
                m_container.value(idx) = TArray(2);
                m_container.value(idx).value(0) = key;
                m_container.value(idx).value(1) = value;
            else

                var size = m_container.size;
                var tempContainer : TArray;

                var i;
                var j;

                if (idx > 3 * size/4)

                    tempContainer = TArray(3 * size/4);
                    i = idx;
                    j = 0;
                    while (i < size)
                        tempContainer.value(j) = m_container.value(i);
                        i = i + 1;
                        j = j + 1;
                    end;

                    m_container.value(idx) = TArray(2);
                    m_container.value(idx).value(0) = key;
                    m_container.value(idx).value(1) = value;

                    i = idx + 1;
                    j = 0;
                    while (j < tempContainer.size)
                        m_container.value(i) = tempContainer.value(j);
                        i = i + 1;
                        j = j + 1;
                    end;

                else

                    tempContainer = TArray(size + 1);
                    i = 0;
                    j = 0;
                    while (i < idx)
                        tempContainer.value(j) = m_container.value(i);
                        i = i + 1;
                        j = j + 1;
                    end;

                    tempContainer.value(idx) = TArray(2);
                    tempContainer.value(idx).value(0) = key;
                    tempContainer.value(idx).value(1) = value;

                    i = idx;
                    j = idx + 1;
                    while (j < tempContainer.size)
                        tempContainer.value(j) = m_container.value(i);
                        i = i + 1;
                        j = j + 1;
                    end;

                end;

            end;
        end;

        setParm(1, key);
        setParm(3, idx);
        return value;
    end;

    // Возвращает значение по ключу,
    // так же возвращает значение индекса в хранилище.
    // Если в хранилище отсутсвует элемент с заданным ключом,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro get(key, idx : Integer)
        var value = null;

        value = add(key, value, idx, false);

        setParm(1, key);
        setParm(2, idx);
        return value;
    end;

    // Возвращает значение по индексу в массиве-хранилище,
    // так же возвращает значение ключа через параметр key.
    // Если в хранилище отсутсвует элемент с заданным индексом и в параметре key передали значение,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro getDirect(idx : Integer, key)
        var value = null;

        createContainer();

        if ((idx >= 0) and (idx < m_container.size))
            value = m_container.value(idx).value(1);
            key = m_container.value(idx).value(0);
        else
            if (key != null)
                idx = null;
                value = createValue(key);
                add(key, value, idx, false);
            end;
        end;

        setParm(1, idx);
        setParm(2, key);
        return value;
    end;

    private macro constructorTCacheOrderedStorage(initialSize : Integer, createValueFunction, createKeyFunction)
        initTBaseCache(initialSize, createValueFunction, createKeyFunction);
    end;

    constructorTCacheOrderedStorage(initialSize, createValueFunction, createKeyFunction);
end;

// данные хранятся неупорядоченно
private class (TBaseCache) TCacheDisorderedStorage(initialSize : Integer, createValueFunction, createKeyFunction)

    // поиск значения по ключу
    // использует бинарный поиск или перебор в зависимости от размера хранилища
    // возвращает найденное значение или null, индекс найденного значения или null
    // при needIndex == true вернет значение индекса для вставки в массив, если не найдет значение по ключу
    private macro find(key, idx, needIndex)
        defaultParm(needIndex, false);

        var value = null;
        var i;

        i = 0;
        value = null;
        while ((i < m_container.size) and (m_container.value(i).value(0) != key))
            i = i + 1;
        end;
        if ((i < m_container.size) and (m_container.value(i).value(0) == key))
            value = m_container.value(i).value(1);
            idx = i;
        else
            if (needIndex)
                idx = i;
            else
                idx = null;
            end;
        end;

        setParm(2, idx);
        return value;
    end;

    // добавляет значение в контейнер, если в контейнере нет ключа этого значения
    // возвращает добавленное значение, ключ, индекс в хранилище
    // при незаданном ключе попытается определить его по значению
    // при незаданном значении попытается определить его по ключу
    macro add(key, value, idx : integer, isOrderedData : bool)
        defaultParm(isOrderedData, false);
        idx = null;

        var needAddition = false;

        createContainer();

        if (key != null)
            var tempValue = find(key, idx, true);
            if (tempValue == null)
                if (value == null)
                    value = createValue(key);
                end;
                needAddition = true;
            else
                value = tempValue;
            end;
        end;

        if ((not needAddition) and (key == null) and (value != null))
            key = createKey(value);
            if ((key != null) and (find(key, idx, true) == null))
                needAddition = true;
            end;
        end;

        if (needAddition)
            m_container.value(idx) = TArray(2);
            m_container.value(idx).value(0) = key;
            m_container.value(idx).value(1) = value;
        end;

        setParm(1, key);
        setParm(3, idx);
        return value;
    end;

    // Возвращает значение по ключу,
    // так же возвращает значение индекса в хранилище.
    // Если в хранилище отсутсвует элемент с заданным ключом,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro get(key, idx : Integer)
        var value = null;

        value = add(key, value, idx, false);

        setParm(1, key);
        setParm(2, idx);
        return value;
    end;

    // Возвращает значение по индексу в массиве-хранилище,
    // так же возвращает значение ключа через параметр key.
    // Если в хранилище отсутсвует элемент с заданным индексом и в параметре key передали значение,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro getDirect(idx : Integer, key)
        var value = null;

        createContainer();

        if ((idx >= 0) and (idx < m_container.size))
            value = m_container.value(idx).value(1);
            key = m_container.value(idx).value(0);
        else
            if (key != null)
                idx = null;
                value = createValue(key);
                add(key, value, idx, false);
            end;
        end;

        setParm(1, idx);
        setParm(2, key);
        return value;
    end;

    private macro constructorTCacheDisorderedStorage(initialSize : Integer, createValueFunction, createKeyFunction)
        initTBaseCache(initialSize, createValueFunction, createKeyFunction);
    end;

    constructorTCacheDisorderedStorage(initialSize, createValueFunction, createKeyFunction);

end;

class TRepCache(mode : Integer, initialSize : Integer, createValueFunction, createKeyFunction)
    private var m_mode : Integer;
    private var m_initialSize : Integer;
    private var m_cache : Object;

    macro getMode()
        return m_mode;
    end;

    macro add(key, value, idx : integer, isOrderedData : bool)
        var _value = m_cache.add(key, value, idx, isOrderedData);
        setParm(1, key);
        setParm(3, idx);
        return _value;
    end;

    // Возвращает значение по ключу,
    // так же возвращает значение индекса в хранилище.
    // Если в хранилище отсутсвует элемент с заданным ключом,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro get(key, idx : Integer)
        var value = m_cache.get(key, idx);
        setParm(1, key);
        setParm(2, idx);
        return value;
    end;

    // Возвращает значение по индексу в массиве-хранилище,
    // так же возвращает значение ключа через параметр key.
    // Если в хранилище отсутсвует элемент с заданным индексом и в параметре key передали значение,
    // то будет вызван метод createValue, формирующий значение по ключу.
    // Полученное значение будет сохранено, метод вернет собственно значение и индекс в хранилище через параметр idx.
    macro getDirect(idx : Integer, key)
        var value = m_cache.getDirect(idx, key);
        setParm(1, idx);
        setParm(2, key);
        return value;
    end;

    macro clear()
        m_cache.clear();
    end;

    /**
     * Инициализация итератора кеша
     */
    macro rewind()
        m_cache.rewind();
    end;

    /**
     * Переход на следующий определенный (не равен null) элемент кеша.
     */
    macro next() : Bool
        return m_cache.next();
    end;

    macro getCurrent() : Variant
        return m_cache.getCurrent();
    end;

    macro getCurrentIndex() : Integer
        return m_cache.getCurrentIndex();
    end;

    private macro constructorTCache(mode : Integer, initialSize : Integer, createValueFunction, createKeyFunction)
        m_mode = mode;

        if (m_mode == CACHE_MODE_INDEX)
            m_cache = TCacheKeyUsingIndex(initialSize, createValueFunction, createKeyFunction);
        elif (m_mode == CACHE_MODE_ORDERED)
            m_cache = TCacheOrderedStorage(initialSize, createValueFunction, createKeyFunction);
        else
            m_cache = TCacheDisorderedStorage(initialSize, createValueFunction, createKeyFunction);
        end;

        m_initialSize = initialSize;
    end;

    constructorTCache(mode, initialSize, createValueFunction, createKeyFunction);
end;
