/*
$Name:          treport.mac
$Module:        Отчетность
$Description:   Класс для автоматизированного создания отчетов.
*/

/****************************************************************************
  RS-Bank version 5.0, 5.1, 6.0                               R-Style SoftLab

  Класс для автоматизированного создания отчетов.

  FILENAME: treport.mac

  NOTIFICATION:
     Класс CTableReport - табличный отчет

     Конструктор:
       CTableReport(POffset, PShadow, PInShadow, printToBuffer)
       POffset : Integer    - Смещение таблицы от левого края
       PShadow : Bool       - Рисовать ли линии снаружи таблицы
       PInshadow : Bool     - Рисовать ли линии внутри таблицы
       printToBuffer : Bool - Вывод во внутренний буфер (TArray)
       indent : Integer     - Отступ слева и справа, по умолчанию - 1 пробел

     Методы:
       - добавить колонку с именем Name, длиной Len и выравниванием Aln в отчет
         AddColumn( Name, Len, [Aln] )
         Если параметр Len имеет тип V_INTEGER, то ширина колонки определяется как max(Len,<Длина_заголовка_колонки>)
         Если параметр Len имеет тип V_DOUBLE, то ширина колонки равна заданной, а заголовок каждой колонки переносится по строкам

       - напечатать шапку отчета с информационной строкой StrInf до шапки таблицы.
         PrintHead( StrInf )

       - напечатать разделитель с линиями или без
         PrintSeparator( ShadowIgnore )

       - напечатать строчку отчета
         PrintString( ... )

       - напечатать строчку отчета с расчетом результирующей высоты колонки и переносом строк по словам.
         PrintStringTransferByWord( ... )

       - напечатать закрывашку отчета  с информационной строкой StrInf до закрывашки таблицы.
         PrintBottom( StrInf )

       - получить внутренний буфер (TArray), сформированный вызовами методами Print*. Каждый элемент - строка.
         getPrintBuffer()


     Класс CObjectTableReport - табличный отчёт, выводящий объекты.
        Является наследником CTableReport.

     Новые/изменённые методы:
        - AddColumn( name, propName, len, align )
          Добавить колонку для вывода свойства propName объектов.
          Остальные параметры - как в CTableReport::AddColumn.

        - PrintObjectTransferByWord( obj ) - полный аналог PrintStringTransferByWord
          Передаётся экземляр объекта, свойства которого надо выводить.


  CREATED:  23.10.02 Sal.

  MODIFICATIONS:
    26.01.2005  SCR 64023
        BugZ  Добавил PrintStringTransferByWord.
    27.01.2005  SCR 61616
        BugZ  Проинициализировать не указанные значения полей пустой строкой
              во избежание Undefined при вызове функций без параметров.
    28.01.2005
        BugZ  Импортируются библиотеки lib_str, lib_arr.
    01.12.2011
        ABP Добавил вывод во внутренний буфер
****************************************************************************/

Import BankInter;
Import lib_str, lib_arr;

Macro GetReg( Path )
  Var err = 0,
      val;

  GetRegistryValue( Path, V_UNDEF, val, err );

  return val;
End;

/* Константы, требуемые для печати отчетов */
Const DOCUMENTSUMLEN = int( GetReg("BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ОТОБРАЖЕНИЕ ПОЛЕЙ\\DOCUMENTSUMLEN") ),
      ACCOUNTRESTLEN = int( GetReg("BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ОТОБРАЖЕНИЕ ПОЛЕЙ\\ACCOUNTRESTLEN") ),
      ACCOUNTLEN     = int( GetReg("BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ОТОБРАЖЕНИЕ ПОЛЕЙ\\ACCOUNTLEN"    ) ),
      /*06 Aug 07 Mon 16:55:10 Malakhova Irina 106937*/
      ACCOUNTNAMELEN = int( GetReg("BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ОТОБРАЖЕНИЕ ПОЛЕЙ\\ACCOUNTNAMELEN"    ) );

/* Выпавнивание */
Const AL_LEFT   = STR_ALIGN_LEFT,   /* по левому краю  */
      AL_CENTER = STR_ALIGN_CENTER, /* по центру       */
      AL_RIGHT  = STR_ALIGN_RIGHT,  /* по правому краю */
      AL_STD    = STR_ALIGN_STD;    /* стандартное     */

/* Колонка отчета  */
CLASS CColumn( PName, PLen, PAlign, isBordered_)

  private var Name : String;   /* Имя колонки       */
  private var Len  : Integer;  /* Длина колонки     */
  private var Ofs  : Integer;  /* Смещение названия */
  private var Aln  : Integer;  /* Выравнивание      */
  private var m_isBordered = nvl(isBordered_, true);

  macro setBorder(isTrue : Bool)
    m_isBordered = isTrue;
  end;

  macro isBordered()
    return m_isBordered;
  end;

  Private
  Macro GetNameLen( Name )
    Var i       = 1,
        si      = 0,
        NameLen = StrLen(Name),
        SubLen  = 0;

    while( i <= NameLen )
      if ( SubStr( Name, i, 1 ) == "|" )
        if ( si > SubLen )
          SubLen = si;
        end;
        si = 0;
      else
        si = si + 1;
      end;
      i = i + 1;
    end;

    if ( si > SubLen )
      SubLen = si;
    end;

    return SubLen;
  End;

  Macro GetLen()
    return Len;
  End;

  Macro GetName()
    return Name;
  End;

  Macro GetOfs()
    return Ofs;
  End;

  Macro GetAln()
    return Aln;
  End;

  Macro GetCrossString()
      var i = 0;
      var line = "";
      var aln = GetAln();
      var len = GetLen();

      if (aln == AL_LEFT)
          while (i < Len/2)
              line = line + " ";
              i = i + 1;
          end;
          return line = line + "X";
      elif (aln == AL_RIGHT)
          line = line + "X";
          while (i < Len/2)
              line = line + " ";
              i = i + 1;
          end;
          return line;
      else
          return "X";
      end;
  End;

  if ( ValType( PName ) == V_STRING  )
    Name = PName;
  else
    Name = "Column"
  end;

  if   ( Index( Name, ">>" ) > 0 )    /* смещение вправо */
    Ofs  =  1;
    Name =  SubStr( Name, 3 );
  elif ( Index( Name, "<<" ) > 0 )    /* смещение влево  */
    Ofs  = -1;
    Name =  SubStr( Name, 3 );
  else                                /* по центру       */
    Ofs  =  0;
  end;

  if ( ValType( PLen  ) == V_INTEGER )
    Len  = Max( PLen, GetNameLen(Name) );
  elif (valType(pLen) == V_DOUBLE) // 29.12.2008 ABP Кривизна редкостная. Но ничего более умного в голову не приходит
    Len = PLen;
  else
    Len  = GetNameLen( Name );
  end;

  if ( ValType( PAlign) == V_INTEGER )
    Aln = PAlign;
  else
    Aln = AL_STD;
  end;

END;


/* Табличный отчет */
CLASS CTableReport( POffset, PShadow, PInShadow, printToBuffer, indent )

  Private var AColumns  = TArray;       /* Список колонок                        */
  Private var Shadow    : Bool;         /* Рисовать ли все линии                 */
  Private var InShadow  : Bool;         /* Рисовать ли линии внутри таблицы      */
  Private var Offset    : Integer;      /* Смещение таблицы от левого края       */
  Private var StrOff    : String;       /* Строчка пробелов для учета смещения   */
  Private var Empty     : Bool;         /* Выведена ли в отчет хоть одна строчка */
  Private var SumLen    : Integer;      /* Суммарная ширина таблицы              */
  Private var MemStr    : String;       /* Для запоминания строки                */
  Private var NumStr    : Integer;      /* Количество строк (значимых)           */
  Private var HasOwner  : Bool;         /* Есть ли отчет владелец                */
  Private var OwnerRep;                 /* Отчет владелец                        */
  Private var LastElem  : Integer;      /* Последний нарисованный элемент        */
  Private var AFiles    = TArray;       /* Файлы вывода                          */
  Private var UseStdOut : Bool;         /* Использовать стандартный вывод        */
  Private var m_isAllCenter : Bool = false; /* Использовать вывод по центру*/
  Private var TR_ELEM_HEADER = 1,
              TR_ELEM_STRING = 2,
              TR_ELEM_BOTTOM = 3,
              TR_ELEM_SEPART = 4;
  Private var m_useColumnNumbering : Bool = false; /* Печатать номера колонок при печати заголовка */
  Private var m_startColumnNumber : Integer = 1; /* Номер первой колонки */

  private var m_incrementalWidth : TArray; // ширины колонок, предшествующих i-ой, нарастающим итогом

  private var m_printToBuffer : Bool;
  private var m_printBuffer : TArray;

  private var m_indent : Integer;
  private var m_indentationString : String;
  private var m_separatorIndentationString : String;

  macro setBufferPrint(isPrintToBuffer : Bool)
      var oldValue = m_printToBuffer;
      m_printToBuffer = isPrintToBuffer;
      return oldValue;
  end;

  macro clearMem()
      MemStr = "";
      NumStr = 0;
  end;

  macro setAllCenter(isTrue : Bool)
      m_isAllCenter = isTrue;
  end;

  /* Установить таблицу-владельца - НАЧАЛО */
  Macro SetOwnerRep( POwnerRep )

    OwnerRep = POwnerRep;
    HasOwner = True;

  End;
  /* Установить таблицу-владельца - КОНЕЦ  */


  /* Добавить колонку - НАЧАЛО */
  Macro AddColumn( Name, Len, Aln , isBordered)

     Var Col = CColumn( Name, Len, Aln , isBordered);

     AColumns(AColumns.Size) = Col;

     // Сохраняем предыдущую ширину колонок
     m_incrementalWidth.value(m_incrementalWidth.size) = SumLen;

     SumLen = SumLen + Col.GetLen() + 1 + 2*m_indent;

  End;
  /* Добавить колонку - КОНЕЦ */

    /*
    Добавить последнюю колонку так, чтоб достигнуть заданной общей ширины. Ширина колонки не менее заданной.
  */
  Macro AddLastColumn( Name, Len, Aln, isBordered, OverallWidth)

     Var Col = CColumn( Name, OverallWidth-(CColumn( Name, Len, Aln, isBordered).GetLen()+1+2*m_indent), Aln, isBordered);

     AColumns(AColumns.Size) = Col;

     // Сохраняем предыдущую ширину колонок
     m_incrementalWidth.value(m_incrementalWidth.size) = SumLen;

     SumLen = SumLen + Col.GetLen() + 1 + 2*m_indent;

  End;

  /* очистка столбцов шапки (возможность печатать разные таблицы в контексте одного объекта класса) */
  Macro clearColumn()
     AColumns.size = 0;
  End;

  /* Добавить файл вывода - НАЧАЛО */
  Macro AddOutFile( Name, AddToFile )
     AFiles(AFiles.Size) = Name;

     if ( ValType(AddToFile) != V_BOOL )
       AddToFile = False;
     end;

     setoutput( Name, AddToFile );
     setoutput( NULL, True      );
  End;
  /* Добавить файл вывода - КОНЕЦ */


  /* Напечатать часть отчета-владельца - НАЧАЛО */
  Private
  Macro PrintOwnerRep( Start )
     Var i,         /* Индексная переменная    */
         ownerLen;  /* Длина отчета-владельца  */

     if ( HasOwner )

       if ( Start )

         MemStr = MemStr + OwnerRep.GetStrOff();
         if ( OwnerRep.GetShadow() )
           MemStr = MemStr + " ";
         else
           MemStr = MemStr + "│";
         end;

       else

         ownerLen = OwnerRep.GetSumLen() + 1 + OwnerRep.GetOffset();

         i = StrLen(MemStr) - int( StrLen(MemStr) / (ownerLen + 1) ) * ( ownerLen + 1 ) + 1;

         while( i < ownerLen )
           MemStr = MemStr + " ";
           i = i + 1;
         end;

         if ( OwnerRep.GetShadow() )
           MemStr = MemStr + "│";
         else
           MemStr = MemStr + "│";
         end;
       end;

     end;

     if ( not Start )
       MemStr = MemStr + "\n";
     end;

  End;
  /* Напечатать часть отчета-владельца - КОНЕЦ  */


  /* Удалить последнюю линию  - НАЧАЛО */
  Macro DelMemLastString()
     Var i; /* индексная переменная  */

     LastElem = 0;

     i = StrLen( MemStr ) - 1;

     if ( i < SumLen + 1 )
       MemStr = "";
       return;
     end;

     while ( (SubStr( MemStr, i, 1) != "\n") and (i > 0) )
       i = i - 1;
     end;

     MemStr = SubStr( MemStr, 1, i );

     if ( LastElem == TR_ELEM_STRING )
       NumStr = NumStr - 1;
       if ( NumStr == 0 )
         Empty = True;
       end;
     end;

     LastElem = 0;
  End;
  /* Удалить последнюю линию  - КОНЕЦ  */


  /* Запомнить шапку - НАЧАЛО */
  Macro MemHead( StrInf, Smooth , isFirst)

     Var NCols = AColumns.Size, /* всего колонок                */
         nCol  = 0,             /* текущая колонка              */
         Name  = "",            /* имя текущей колонки          */
         Len   = 0,             /* длина текущей колонки        */
         i     = 0,             /* индексная переменная         */
         nspc  = 0,             /* количество пробелов          */
         nlvls = 1;             /* количество уровней заголовка */

     macro isOldLevelCounting()

        var result = false;
        var i;

        i = 0;
        while (i < aColumns.size)

            if (index(aColumns[i].getName(), "|") != 0)
                result = true;
                break;
            end;

            i = i + 1;

        end;

        return result;

     end;

     /* Определить количество строк заголовка при заданной ширине колонок */
     macro getLinesAmount()

        var amount = 1;
        var strings = TArray();
        var i;

        i = 0;
        while (i < aColumns.size)

            strings = strTransferByWord(aColumns[i].getName(), aColumns[i].getLen());

            if (strings.size > amount)
                amount = strings.size;
            end;

            i = i + 1;

        end;

        return amount;

     end;

     /* Определить количество уровней заголовка */
     macro GetLevels()

        Var NameLen  = 0,
            nlvlsCol = 1;

        macro GetLvlsCol( SubName )
           Var ind = Index(SubName, "|");

           if ( ind > 0 )
             nlvlsCol = nlvlsCol + 1;
             GetLvlsCol( SubStr(SubName, ind + 1) );
           end;
        end;

        nCol = 0;
        while( nCol < NCols )
           Name    = AColumns(nCol).GetName();
           NameLen = StrLen( Name );

           nlvlsCol = 1;
           GetLvlsCol(Name);

           if ( nlvlsCol > nlvls )
             nlvls = nlvlsCol;
           end;

           nCol    = nCol + 1;
        end;

        return nlvls;

     end;

     /* Рисуем верх */
     macro PutTop()

        if ( (Trim(StrInf) != "") and (not HasOwner) )
          MemStr = MemStr + StrInf + "\n";
        end;

        PrintOwnerRep( True );

        MemStr = MemStr + StrOff;

        if ( Shadow )
          PrintOwnerRep( False );
          return;
        end;

        nCol = 0;
        while( nCol < NCols )

           Len = AColumns(nCol).GetLen();

           if ( nCol == 0 )
             MemStr = MemStr + ternary(nvl(isFirst, true),"┌","├");
           else
             MemStr = MemStr + ternary(nvl(isFirst, true) or InShadow or Smooth or not AColumns[nCol].isBordered(),"┬","┼");
           end;

           MemStr = MemStr + m_separatorIndentationString;

           i = 0;
           while ( i < Len )
             MemStr = MemStr + "─";
             i = i + 1;
           end;

           MemStr = MemStr + m_separatorIndentationString;

           nCol = nCol + 1;

        end;
        MemStr = MemStr + ternary(nvl(isFirst, true),"┐","┤");

        PrintOwnerRep( False );
     end;

     /* Рисуем надписи */
     macro PutTxt( TxtLevel )

        macro GetLevelName( SubName, ndelim )
           Var ind = Index( SubName, "|" );
           if ( ind > 0 )
             if ( ndelim < TxtLevel - 1 )
               SubName = GetLevelName( SubStr(SubName, ind + 1), ndelim + 1);
             else
               return SubStr( SubName, 1, ind - 1 );
             end;
           else
             if ( ndelim  < TxtLevel - 1 )
               SubName = " ";
             end;
           end;

           return SubName;
        end;

        Var nspc_l = 0,
            nspc_r = 0;

        Var Ofs = 0;

        PrintOwnerRep( True );

        MemStr = MemStr + StrOff;

        nCol = 0;
        while( nCol < NCols )

           Len  = AColumns(nCol).GetLen();
           Name = AColumns(nCol).GetName();
           Ofs  = AColumns(nCol).GetOfs();

           Name = GetLevelName( Name, 0 );

           if ( not Shadow )
             MemStr = MemStr + "│";
           else
             MemStr = MemStr + " ";
           end;
           MemStr = MemStr + m_indentationString;

           if   ( Ofs < 0 )
             nspc_l = 0;
             nspc_r = Len - StrLen( Name );
           elif ( Ofs > 0 )
             nspc_l = Len - StrLen( Name );
             nspc_r = 0;
           else
             nspc_l = int( (Len - StrLen( Name )    )/2 );
             nspc_r = int( (Len - StrLen( Name ) + 1)/2 );
           end;

           i    = 0;
           nspc = nspc_l;
           while( i < nspc )
             MemStr = MemStr + " ";
             i = i + 1;
           end;

           MemStr = MemStr +  Name;

           i    = 0;
           nspc = nspc_r;
           while( i < nspc )
             MemStr = MemStr + " ";
             i = i + 1;
           end;

           MemStr = MemStr + m_indentationString;

           nCol = nCol + 1;

        end;
        if ( not Shadow )
          MemStr = MemStr + "│";
        else
          MemStr = MemStr + " ";
        end;

        PrintOwnerRep( False );

        if ( TxtLevel < nlvls )
          PutTxt( TxtLevel + 1 );
        end;
     end;

    /* Новый вариант */
    macro putLines()

        var i;

        var strings = TArray();

        var align;

        i = 0;
        while (i < nlvls)

            PrintOwnerRep(True);

            MemStr = MemStr + StrOff;

            nCol = 0;
            while (nCol < NCols)

                len  = aColumns(nCol).GetLen();
                name = aColumns(nCol).GetName();

                if (aColumns(nCol).getOfs() < 0)
                    align = STR_ALIGN_LEFT;
                elif (aColumns(nCol).getOfs() == 0)
                    align = STR_ALIGN_CENTER;
                else
                    align = STR_ALIGN_RIGHT;
                end;

                strings = strTransferByWord(name, len+2*m_indent, align);
                name = nvl(strings[i], mkStr(" ", len+2*m_indent));

                if (not Shadow)
                  MemStr = MemStr + "│";
                else
                  MemStr = MemStr + " ";
                end;

                MemStr = MemStr +  name;

                nCol = nCol + 1;

            end;

            if (not Shadow)
              MemStr = MemStr + "│";
            else
              MemStr = MemStr + " ";
            end;

            PrintOwnerRep(False);

            i = i + 1;

        end;

    end;

     /* Рисуем низ */
     macro PutBot()

        PrintOwnerRep( True );

        MemStr = MemStr + StrOff;

        if ( Shadow )
          PrintOwnerRep( False );
          return;
        end;

        nCol = 0;
        while( nCol < NCols )

          Len = AColumns(nCol).GetLen();

          if ( nCol== 0 )
            MemStr = MemStr + "├";
          else
            if ( InShadow or Smooth or not AColumns[nCol].isBordered())
              MemStr = MemStr + "┴";
            else
              MemStr = MemStr + "┼";
            end;
          end;

          MemStr = MemStr + m_separatorIndentationString;

          i = 0;
          while ( i < Len )
            MemStr = MemStr + "─";
            i = i + 1;
          end;

          MemStr = MemStr + m_separatorIndentationString;

          nCol = nCol + 1;

        end;
        MemStr = MemStr + "┤";

        PrintOwnerRep( False );
     end;

     LastElem = TR_ELEM_HEADER;

     if ( ValType( Smooth ) == V_UNDEF )
       Smooth = False;
     end;

     if (isOldLevelCounting())
         GetLevels();
         PutTop( );
         PutTxt(1);
         PutBot( );
     else
         nlvls = getLinesAmount();
         PutTop();
         putLines();
         PutBot();
     end;

  End;
  /* Запомнить шапку - КОНЕЦ */


  /* Запомнить разделитель строк - НАЧАЛО */
  Macro MemSeparator( ShadowIgnore )
     Var NCols = AColumns.Size, /* всего колонок         */
         nCol  = 0,             /* текущая солонка       */
         Len   = 0,             /* длина текущей колонки */
         i     = 0;             /* индексная переменная  */

     if ( Empty or (LastElem == TR_ELEM_SEPART))
       return;
     end;

     LastElem = TR_ELEM_SEPART;

     PrintOwnerRep( True );

     if ( ValType(ShadowIgnore) != V_BOOL )
       ShadowIgnore = false;
     end;

     MemStr = MemStr + StrOff;

     if ( Shadow )
       PrintOwnerRep( False );
       return;
     end;

     if ( InShadow and (not ShadowIgnore) )
       MemStr = MemStr + "│";

       i = 1;
       while ( i < SumLen )
         MemStr = MemStr + " ";
         i = i + 1;
       end;

       MemStr = MemStr + "│";
       return;
     end;

     nCol = 0;
     while( nCol < NCols )

       Len = AColumns(nCol).GetLen();

       if ( nCol== 0 )
         MemStr = MemStr + "├";
       else
         if ( InShadow or not AColumns[nCol].isBordered())
           MemStr = MemStr + "─";
         else
           MemStr = MemStr + "┼";
         end;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       i = 0;
       while ( i < Len )
         MemStr = MemStr + "─";
         i = i + 1;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       nCol = nCol + 1;

     end;
     MemStr = MemStr + "┤";

     PrintOwnerRep( False );
  End;
  /* Запомнить разделитель строк - КОНЕЦ */


  /* Запомнить строчку отчета - НАЧАЛО */
  Macro MemString()
     Var NCols = AColumns.Size, /* всего колонок                                      */
         nCol  = 0,             /* текущая солонка                                    */
         Len   = 0,             /* длина текущей колонки                              */
         Aln   = 0,             /* выравнивание                                       */
         i     = 0,             /* индексная переменная                               */
         Parm,                  /* значение текущей колонки                           */
         StrParm;               /* значение текущей колонки, преобразованное в строку */

     LastElem = TR_ELEM_STRING;

     PrintOwnerRep( True );

     MemStr = MemStr + StrOff;

     nCol = 0;
     while( nCol < NCols )

       Len = AColumns(nCol).GetLen();
       Aln = AColumns(nCol).GetAln();

       GetParm( nCol + 1, Parm );

       /* SCR 61616: Проинициализировать неуказанные значения полей пустой строкой во избежание Undefined при вызове функции без параметров. */
       if ( ValType( Parm ) == V_UNDEF )
            Parm = "";
       end;

       i = 0;
       StrParm = "";
       while ( i < Len )
         StrParm = StrParm + " ";
         i       = i + 1;
       end;

       if (( Aln == AL_CENTER ) or m_isAllCenter)
         ExecExp("StrParm = String(parm:" + Len + ":c)");
       elif   ( Aln == AL_LEFT )
         ExecExp("StrParm = String(parm:" + Len + ":l)");
       elif ( Aln == AL_RIGHT )
         ExecExp("StrParm = String(parm:" + Len + ":r)");
       else
         ExecExp("StrParm = String(parm:" + Len + ")");
       end;

       if   ( Shadow or (InShadow and (nCol != 0)) or not AColumns[nCol].isBordered())
         MemStr = MemStr + " ";
       else
         MemStr = MemStr + "│";
       end;
       MemStr = MemStr + m_indentationString;

       MemStr = MemStr +  StrParm ;

       MemStr = MemStr + m_indentationString;

       nCol = nCol + 1;

     end;
     if ( Shadow )
       MemStr = MemStr + " ";
     else
       MemStr = MemStr + "│";
     end;

     PrintOwnerRep( False );

     Empty = False;

     NumStr = NumStr + 1;

  End;
  /* Запомнить строчку отчета - КОНЕЦ */


  /* Вывести на экран запомненную строку - НАЧАЛО */
  Macro PrintMemStr()

     Var i; /* индексная переменная */
     var strings : TArray;

     if ( trim(MemStr) == "" )
       return;
     end;

     if (m_printToBuffer)
       strings = TArray();
       strings = strcut(memStr, "\n", true);
       for (var str, strings)
         if (substr(str, strlen(str), 1) == "\n")
           m_printBuffer[m_printBuffer.size] = substr(str, 1, strlen(str) - 1);
         else
           m_printBuffer[m_printBuffer.size] = str;
         end;
       end;
     elif ( AFiles.Size == 0 )
       Print( MemStr );
     else
       i = 0;
       while( i < AFiles.Size )
         setoutput( AFiles(i), True );
         Print( MemStr );
         i = i + 1;
       end;
       setoutput( NULL, True  );

       if ( UseStdOut )
         Print( MemStr );
       end;
     end;

     MemStr = "";

  End;
  /* Вывести на экран запомненную строку - КОНЕЦ */


  /* Сбросить запомненную строку - НАЧАЛО */
  Macro ResetMemStr()
     MemStr = "";
  End;
  /* Сбросить запомненную строку - КОНЕЦ */

  /* Нарисовать шапку - НАЧАЛО */
  Macro PrintHead( StrInf, Smooth , isFirst)

     var isAllCenter;
     var parameterStr;
     var i;

     MemHead( StrInf, Smooth , isFirst);
     PrintMemStr();

     isAllCenter = m_isAllCenter;
     m_isAllCenter = true;

     parameterStr = "";
     i = 0;
     while (i < aColumns.size)

        parameterStr = parameterStr + "," + string(m_startColumnNumber + i);

        i = i + 1;

     end;

     parameterStr = subStr(parameterStr, 2);

     if (m_useColumnNumbering)
         parameterStr = "memString(" + parameterStr + ")";
         execExp(parameterStr);
         PrintMemStr();
     end;

     m_isAllCenter = isAllCenter;

  End;
  /* Нарисовать шапку - КОНЕЦ */

  Macro MemStringTransferByWord()

     Var P;
     Var P0=TArray, P1=TArray, P2=TArray, P3=TArray, P4=TArray, P5=TArray, P6=TArray, P7=TArray, P8=TArray, P9=TArray,
         P10=TArray,P11=TArray,P12=TArray,P13=TArray,P14=TArray,P15=TArray,P16=TArray,P17=TArray,P18=TArray,P19=TArray,
         P20=TArray,P21=TArray,P22=TArray,P23=TArray,P24=TArray,P25=TArray,P26=TArray,P27=TArray,P28=TArray,P29=TArray,
         P30=TArray,P31=TArray,P32=TArray,P33=TArray,P34=TArray,P35=TArray,P36=TArray,P37=TArray,P38=TArray,P39=TArray,
         P40=TArray,P41=TArray,P42=TArray,P43=TArray,P44=TArray,P45=TArray,P46=TArray,P47=TArray,P48=TArray,P49=TArray,
         P50=TArray,P51=TArray,P52=TArray,P53=TArray,P54=TArray,P55=TArray,P56=TArray,P57=TArray,P58=TArray,P59=TArray;
     /* Для хранения "мультистроки" в виде матрицы, например,
                                строка 1,2,"длинная строчка",
        при ширине 3-колонки 10  будет представлена как:
                                1, 2, длинная
                                 ,  , строчка
     */
     Var PT = ArrCreate( P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,
                         P10,P11,P12,P13,P14,P15,P16,P17,P18,P19,
                         P20,P21,P22,P23,P24,P25,P26,P27,P28,P29,
                         P30,P31,P32,P33,P34,P35,P36,P37,P38,P39,
                         P40,P41,P42,P43,P44,P45,P46,P47,P48,P49,
                         P50,P51,P52,P53,P54,P55,P56,P57,P58,P59 );

     Var i;
     Var MaxStringHeight;
     Var colLength;
     var parameter;
     var j : integer;


     var secondParameter;

     GetParm( 1, P );
     GetParm( 2, secondParameter );
     /* Передан не один массив - общая логика, иначе оптимизация на скорость (с этим массивом и работаем) */
     if( ( GenClassName( P ) != "TArray" ) or ( ValType( secondParameter ) != V_UNDEF ) )

        /* Восстановить первоначальное состояние */
        i = 1;
        P = TArray;


        while ( GetParm( i, parameter ) )
           if ( GenClassName( parameter ) == "TArray" )
             j = 1;
             while( j <= parameter.size )
                P[i-1] = parameter[j-1];
                i = i + 1;
                j = j + 1;
             end;

           else
             P[i-1] = parameter;
             i = i + 1;
           end;
        end;



     end;

     i = 1;
     MaxStringHeight = 1;
     while ( ( i <= P.size ) and ( i <= AColumns.size ) )
        colLength = AColumns(i-1).GetLen();

        if ( ( ValType(P[i-1]) == V_STRING ) AND ( StrLen(P[i-1]) > colLength ) )
            // Разбиваем строчку по словам и выясняем высоту ряда.
            MaxStringHeight = Max( MaxStringHeight, StrSplitTArray( P[i-1], PT[i-1], colLength ) );
        else
            // Копируем без изменений
            PT[i-1][0] = P[i-1];
        end;
        i = i + 1;
     end;


     /* Запоминаем сформированный ряд высотой MaxStringHeight */
     i = 1;
     while( i <= MaxStringHeight )
         MemString( PT[0][i-1], PT[1][i-1], PT[2][i-1], PT[3][i-1], PT[4][i-1], PT[5][i-1], PT[6][i-1], PT[7][i-1], PT[8][i-1], PT[9][i-1],
                    PT[10][i-1], PT[11][i-1], PT[12][i-1], PT[13][i-1], PT[14][i-1], PT[15][i-1], PT[16][i-1], PT[17][i-1], PT[18][i-1], PT[19][i-1],
                    PT[20][i-1], PT[21][i-1], PT[22][i-1], PT[23][i-1], PT[24][i-1], PT[25][i-1], PT[26][i-1], PT[27][i-1], PT[28][i-1], PT[29][i-1],
                    PT[30][i-1], PT[31][i-1], PT[32][i-1], PT[33][i-1], PT[34][i-1], PT[35][i-1], PT[36][i-1], PT[37][i-1], PT[38][i-1], PT[39][i-1],
                    PT[40][i-1], PT[41][i-1], PT[42][i-1], PT[43][i-1], PT[44][i-1], PT[45][i-1], PT[46][i-1], PT[47][i-1], PT[48][i-1], PT[49][i-1],
                    PT[50][i-1], PT[51][i-1], PT[52][i-1], PT[53][i-1], PT[54][i-1], PT[55][i-1], PT[56][i-1], PT[57][i-1], PT[58][i-1], PT[59][i-1] );
         i = i + 1;
     end;

     return MaxStringHeight;

  end;


  /* Напечатать строчку отчета с переносом по словам - НАЧАЛО */
  Macro PrintStringTransferByWord(param)
     Var rowsQuantity;
     Var i;
     Var P;

     if (isEqClass("TArray", param))
       P = param;
     else
       P = TArray;

       i = 1;
       while ( GetParm( i, P[i-1] ) )
         i = i + 1;
       end;
     end;

     rowsQuantity = MemStringTransferByWord( P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10],
                                             P[11], P[12], P[13], P[14], P[15], P[16], P[17], P[18], P[19], P[20],
                                             P[21], P[22], P[23], P[24], P[25], P[26], P[27], P[28], P[29], P[30],
                                             P[31], P[32], P[33], P[34], P[35], P[36], P[37], P[38], P[39], P[40],
                                             P[41], P[42], P[43], P[44], P[45], P[46], P[47], P[48], P[49], P[50],
                                             P[51], P[52], P[53], P[54], P[55], P[56], P[57], P[58], P[59], P[60] );

     i = 1;
     while( i <= rowsQuantity )
        PrintMemStr();
        i = i + 1;
     end;
  End;


  /* Напечатать строчку отчета с переносом по словам - КОНЕЦ */



  /* Напечатать строчку отчета - НАЧАЛО */
  Macro PrintString()
     Var P = TArray;
     Var i;

     i = 1;
     while ( GetParm( i, P(i-1) ) )
       i = i + 1;
     end;

     MemString( P(0), P(1), P(2), P(3), P(4), P(5), P(6), P(7), P(8), P(9), P(10),
                P(11), P(12), P(13), P(14), P(15), P(16), P(17), P(18), P(19), P(20),
                P(21), P(22), P(23), P(24), P(25), P(26), P(27), P(28), P(29), P(30),
                P(31), P(32), P(33), P(34), P(35), P(36), P(37), P(38), P(39), P(40),
                P(41), P(42), P(43), P(44), P(45), P(46), P(47), P(48), P(49), P(50),
                P(51), P(52), P(53), P(54), P(55), P(56), P(57), P(58), P(59), P(60) );
     PrintMemStr();
  End;
  /* Напечатать строчку отчета - КОНЕЦ */


  /* Напечатать разделитель строк - НАЧАЛО */
  Macro PrintSeparator( ShadowIgnore )
     MemSeparator( ShadowIgnore );
     PrintMemStr();
  End;
  /* Напечатать разделитель строк - КОНЕЦ */


  /* Запомнить закрывашку - НАЧАЛО */
  Macro MemBottom( StrInf )
     Var NCols = AColumns.Size, /* всего колонок         */
         nCol  = 0,             /* текущая солонка       */
         Len   = 0,             /* длина текущей колонки */
         i     = 0;             /* индексная переменная  */

     if (LastElem == TR_ELEM_SEPART)
       DelMemLastString();
     end;

     LastElem = TR_ELEM_BOTTOM;

     PrintOwnerRep( True );

     if ( Shadow )
       if ( (Trim(StrInf) != "") and (not HasOwner) )
         MemStr = MemStr + StrInf + "\n";
       end;
       PrintOwnerRep( False );
       return;
     end;

     MemStr = MemStr + StrOff;

     nCol = 0;
     while( nCol < NCols )

       Len = AColumns(nCol).GetLen();

       if ( nCol== 0 )
         MemStr = MemStr + "└";
       else
         if ( InShadow or not AColumns[nCol].isBordered())
           MemStr = MemStr + "─";
         else
           MemStr = MemStr + "┴";
         end;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       i = 0;
       while ( i < Len )
         MemStr = MemStr + "─";
         i = i + 1;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       nCol = nCol + 1;

     end;
     MemStr = MemStr + "┘";

     PrintOwnerRep( False );

     if ( (Trim(StrInf) != "") and (not HasOwner) )
       MemStr = MemStr + StrInf + "\n";
     end;

  End;

  Macro MemBottomExt( FirstCol, StrInf )
     Var NCols = AColumns.Size, /* всего колонок         */
         nCol  = 0,             /* текущая солонка       */
         Len   = 0,             /* длина текущей колонки */
         i     = 0;             /* индексная переменная  */

     if (LastElem == TR_ELEM_SEPART)
       DelMemLastString();
     end;

     LastElem = TR_ELEM_BOTTOM;

     PrintOwnerRep( True );

     if ( Shadow )
       if ( (Trim(StrInf) != "") and (not HasOwner) )
         MemStr = MemStr + StrInf + "\n";
       end;
       PrintOwnerRep( False );
       return;
     end;

     MemStr = MemStr + StrOff;

     nCol = 0;
     while( nCol < FirstCol )

       Len = AColumns(nCol).GetLen();

       if ( nCol== 0 )
         MemStr = MemStr + "└";
       else
         MemStr = MemStr + "─";
       end;

       MemStr = MemStr + m_separatorIndentationString;

       i = 0;
       while ( i < Len )
         MemStr = MemStr + "─";
         i = i + 1;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       nCol = nCol + 1;

     end;

     while( nCol < NCols )

       Len = AColumns(nCol).GetLen();

       if ( nCol== 0 )
         MemStr = MemStr + "└";
       else
         if ( InShadow or (not AColumns[nCol].isBordered()))
           MemStr = MemStr + "─";
         else
           MemStr = MemStr + "┴";
         end;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       i = 0;
       while ( i < Len )
         MemStr = MemStr + "─";
         i = i + 1;
       end;

       MemStr = MemStr + m_separatorIndentationString;

       nCol = nCol + 1;

     end;
     MemStr = MemStr + "┘";

     PrintOwnerRep( False );

     if ( (Trim(StrInf) != "") and (not HasOwner) )
       MemStr = MemStr + StrInf + "\n";
     end;

  End;
  /* Запомнить закрывашку - КОНЕЦ */

  /* Нарисовать закрывашку - НАЧАЛО */
  Macro PrintBottom( StrInf )
     MemBottom( StrInf );
     PrintMemStr();
  End;

  Macro PrintBottomExt( FirstCol, StrInf )
     MemBottomExt( FirstCol, StrInf );
     PrintMemStr();
  End;
  /* Нарисовать закрывашку - КОНЕЦ */


  /* Запомнить нестандартную строчку - НАЧАЛО */
  Macro MemStringExt( StrResult, FirstCol )
     Var NCols = AColumns.Size, /* всего колонок                                      */
         nCol  = 0,             /* текущая солонка                                    */
         Len   = 0,             /* длина текущей колонки                              */
         Aln   = 0,             /* выравнивание                                       */
         i     = 0,             /* индексная переменная                               */
         Parm,                  /* значение текущей колонки                           */
         nParm,                 /* номер текущего параметра                           */
         StrParm;               /* значение текущей колонки, преобразованное в строку */

     LastElem = TR_ELEM_STRING;

     PrintOwnerRep( True );

     MemStr = MemStr + StrOff;

     if ( Shadow )
       MemStr = MemStr + " ";
     else
       MemStr = MemStr + "│";
     end;

     StrParm = "";

     nCol = 0;
     while( nCol < FirstCol )

       Len = AColumns(nCol).GetLen();
       i   = 0;

       StrParm = StrParm + m_indentationString;

       while ( i < Len )
         StrParm = StrParm + " ";
         i = i + 1;
       end;

       StrParm = StrParm + m_indentationString + " ";

       nCol = nCol + 1;
     end;

     StrSet( StrParm, 2, StrResult );
     StrParm = SubStr( StrParm, 1, StrLen(StrParm) - 1 );

     MemStr = MemStr +  StrParm;

     nParm = 3;
     nCol  = FirstCol;
     while( nCol < NCols )

       Len = AColumns(nCol).GetLen();
       Aln = AColumns(nCol).GetAln();

       GetParm( nParm, Parm );

       /* SCR 61616: Проинициализировать неуказанные значения полей пустой строкой во избежание Undefined при вызове функции без параметров. */
       if ( ValType( Parm ) == V_UNDEF )
            Parm = "";
       end;

       nParm = nParm + 1;

       i = 0;
       StrParm = "";
       while ( i < Len )
         StrParm = StrParm + " ";
         i       = i + 1;
       end;

       if   ( Aln == AL_LEFT )
         ExecExp("StrParm = String(parm:" + Len + ":l)");
       elif ( Aln == AL_CENTER )
         ExecExp("StrParm = String(parm:" + Len + ":c)");
       elif ( Aln == AL_RIGHT )
         ExecExp("StrParm = String(parm:" + Len + ":r)");
       else
         ExecExp("StrParm = String(parm:" + Len + ")");
       end;

       if ( Shadow or InShadow or not AColumns[nCol].isBordered())
         MemStr = MemStr + " ";
       else
         MemStr = MemStr + "│";
       end;
       MemStr = MemStr + m_indentationString;

       MemStr = MemStr + StrParm;

       MemStr = MemStr + m_indentationString;

       nCol = nCol + 1;

     end;
     if ( Shadow )
       MemStr = MemStr + " ";
     else
       MemStr = MemStr + "│";
     end;

     Empty = False;

     PrintOwnerRep( False );

     NumStr = NumStr + 1;

  End;
  /* Запомнить нестандартную строчку - КОНЕЦ */

  Macro PrintStringExt( StrResult, FirstCol )
     Var P = TArray;
     Var i;

     i = 3;
     while ( GetParm( i, P(i-3) ) )
       i = i + 1;
     end;

     MemStringExt( StrResult, FirstCol, P(0), P(1), P(2), P(3), P(4), P(5), P(6), P(7), P(8), P(9), P(10),
                                        P(11), P(12), P(13), P(14), P(15), P(16), P(17), P(18), P(19), P(20),
                                        P(21), P(22), P(23), P(24), P(25), P(26), P(27), P(28), P(29), P(30),
                                        P(31), P(32), P(33), P(34), P(35), P(36), P(37), P(38), P(39), P(40),
                                        P(41), P(42), P(43), P(44), P(45), P(46), P(47), P(48), P(49), P(50),
                                        P(51), P(52), P(53), P(54), P(55), P(56), P(57), P(58), P(59), P(60) );
     PrintMemStr();
  End;


  /* Запомнить нестандартный разделитель - НАЧАЛО */
  Macro MemSeparatorExt( ShadowIgnore, Top, FirstCol, isAllTop )
     Var NCols = AColumns.Size, /* всего колонок         */
         nCol  = 0,             /* текущая солонка       */
         Len   = 0,             /* длина текущей колонки */
         i     = 0;             /* индексная переменная  */

     if ( Empty or ((LastElem == TR_ELEM_SEPART)))
       return;
     end;

     LastElem = TR_ELEM_SEPART;

     PrintOwnerRep( True );

     if ( ValType(ShadowIgnore) != V_BOOL )
       ShadowIgnore = false;
     end;

     if (ValType(isAllTop) != V_BOOL)
        isAllTop = true;
     end;

     MemStr = MemStr + StrOff;

     if ( Shadow )
       PrintOwnerRep( False );
       return;
     end;

     if ( InShadow and (not ShadowIgnore) or not AColumns[nCol].isBordered())
       MemStr = MemStr + "│";

       i = 1;
       while ( i < SumLen )
         MemStr = MemStr + " ";
         i = i + 1;
       end;

       MemStr = MemStr + "│";
       PrintOwnerRep( False );
       return;
     end;

     MemStr = MemStr + "├";

     nCol = 0;
     while( nCol < FirstCol )

       Len = AColumns(nCol).GetLen();
       i   = 0;

       if ( nCol != 0 )
         if ( InShadow or not AColumns[nCol].isBordered())
           MemStr = MemStr + "─";
         else
           if (isAllTop)
               if   ( Top == True )
                 MemStr = MemStr + "┴";
               elif ( Top == False )
                 MemStr = MemStr + "┬";
               else
                 MemStr = MemStr + "─";
               end;
           else
               MemStr = MemStr + "─";
           end;
         end;
       end;
       MemStr = MemStr + "─";

       while ( i < Len )
         MemStr = MemStr + "─";
         i = i + 1;
       end;

       MemStr = MemStr + "─";

       nCol = nCol + 1;
     end;

     nCol = FirstCol;
     while( nCol < NCols )

       Len = AColumns(nCol).GetLen();

       if ( InShadow or not AColumns[nCol].isBordered())
         MemStr = MemStr + "─";
       else
         if (isAllTop)
             MemStr = MemStr + "┼";
         else
             if   ( Top == True )
               MemStr = MemStr + "┴";
             elif ( Top == False )
               MemStr = MemStr + "┬";
             else
               MemStr = MemStr + "─";
             end;
         end;
       end;

       MemStr = MemStr + "─";

       i = 0;
       while ( i < Len )
         MemStr = MemStr + "─";
         i = i + 1;
       end;

       MemStr = MemStr + "─";

       nCol = nCol + 1;

     end;
     MemStr = MemStr + "┤";

     PrintOwnerRep( False );
  End;
  /* Запомнить нестандартную разделитель - КОНЕЦ */


  /* Напечатать нестандартный разделитель - НАЧАЛО */
  Macro PrintSeparatorExt( ShadowIgnore, Top, FirstCol, isAllTop )
     MemSeparatorExt( ShadowIgnore, Top, FirstCol, isAllTop );
     PrintMemStr();
  End;
  /* Напечатать нестандартную разделитель - КОНЕЦ */


  /* Запомнить произвольную строку - НАЧАЛО */
  Macro MemFreeString( Str )
     PrintOwnerRep( True  );
     MemStr = MemStr + Str;
     PrintOwnerRep( False );
  End;
  /* Запомнить произвольную строку - КОНЕЦ */


  /* Напечатать произвольную строку - НАЧАЛО */
  Macro PrintFreeString( Str, useBorder )
     if ((useBorder != null) and useBorder)
        Str = "│" + substr(Str, 1, this.getSumLen()-1) + "│";
     end;
     MemFreeString( Str );
     PrintMemStr();
  End;
  /* Напечатать произвольную строку - КОНЕЦ */

  /* Очистить файлы вывода - НАЧАЛО */
  Macro ClearOutFiles()
     Var i; /* индексная переменная */

     i = 0;
     while( i < AFiles.Size )
       setoutput ( AFiles(i) );
       i = i + 1;
     end;
     setoutput( NULL, True  );
  End;
  /* Очистить файлы вывода - КОНЕЦ */

  /* Вставить файл - НАЧАЛО */
  Macro PrintFromFile( NameFrom, NameTo )
     Var i; /* индексная переменная */

     file frep() txt 512;

     if ( not Open( frep, NameFrom ) )
       return;
     end;

     i = 0;
     while( i < AFiles.Size )
       if ( (ValType( NameTo ) == V_STRING) and (NameTo != "") )
         if ( AFiles(i) == NameTo )
           setoutput( AFiles(i), True );
           Rewind( frep );
           while ( Next(frep) )
             Println( frep.Str );
           end;
         end;
       elif ( (ValType( NameTo ) == V_UNDEF) or ((ValType( NameTo ) == V_STRING) and (NameTo == "")) )
         setoutput( AFiles(i), True );
         Rewind( frep );
         while ( Next(frep) )
           Println( frep.Str );
         end;
       end;
       i = i + 1;
     end;
     setoutput( NULL, True  );

     if ( UseStdOut and ( (ValType( NameTo ) == V_UNDEF) or ((ValType( NameTo ) == V_STRING) and (NameTo == "")) ) )
       Rewind( frep );
       while ( Next(frep) )
         if (m_printToBuffer)
           m_printBuffer[m_printBuffer.size] = frep.Str;
         else
           Println( frep.Str );
         end;
       end;
     end;

     Close( frep );

  End;
  /* Вставить файл - КОНЕЦ */

  /* Функции получения/уствновки параметров отчета для внешних вызовов - НАЧАЛО */
  Macro GetShadow()
    return Shadow;
  End;

  Macro GetInShadow()
    return InShadow;
  End;

  Macro GetOffset()
    return Offset;
  End;

  Macro GetStrOff()
    return StrOff;
  End;

  Macro GetEmpty()
    return Empty;
  End;

  Macro SetEmpty()
    Empty  = true;
    NumStr = 0;
  End;

  Macro GetSumLen()
    return SumLen;
  End;

  macro getWidthBeforeCol(columnNumber)
    return m_incrementalWidth.value(columnNumber);
  end;

  Macro GetMemStr()
    return MemStr;
  End;

  Macro GetAColumns()
    return AColumns;
  End;

  Macro GetAFiles()
    return AFiles;
  End;

  Macro GetHasOwner()
    return HasOwner;
  End;

  Macro GetOwnerRep()
    return OwnerRep;
  End;

  Macro GetLastElem()
    return LastElem;
  End;

  Macro GetNumStr()
    return NumStr;
  End;

  Macro GetUseStdOut()
    return UseStdOut;
  End;

  macro getPrintBuffer()
    return m_printBuffer;
  end;

  macro getIndent()
    return m_indent;
  end;

  Macro SetUseStdOut( stduse )
    return UseStdOut = stduse;
  End;

  Macro SetStartColumnNumber(number)
    var oldValue = m_startColumnNumber;
    m_startColumnNumber = number;
    return oldValue;
  End;

  Macro SetUseColumnNumbering(isUse)
    m_useColumnNumbering = isUse;
  end;

  macro setOffset(pOffset)
    Offset = pOffset;
    while (pOffset > 0)
      StrOff  = StrOff  + " ";
      pOffset = pOffset - 1;
    end;
  end;
  /* Функции получения/уствновки параметров отчета для внешних вызовов - КОНЕЦ */


  /* Утилиты - НАЧАЛО */
  Macro MakeFrom( Rep )
    AColumns = Rep.GetAColumns();
    Shadow   = Rep.GetShadow();
    InShadow = Rep.GetInShadow();
    Offset   = Rep.GetOffset();
    StrOff   = Rep.GetStrOff();
    SumLen   = Rep.GetSumLen();

    HasOwner = Rep.GetHasOwner();
    OwnerRep = Rep.GetOwnerRep();
    LastElem = Rep.GetLastElem();

    AFiles   = Rep.GetAFiles();

    Empty    = true;
    NumStr   = 0;
    MemStr   = "";
  End;

  Macro CopyStrFrom( Rep )
    MemStr = MemStr + Rep.GetMemStr();
    if ( not Rep.GetEmpty() )
      Empty = false;
    end;
    NumStr = NumStr + Rep.GetNumStr();
  End;
  /* Утилиты - КОНЕЦ */


  /* Таблица пуста */
  Empty  = True;
  NumStr = 0;

  /* Смещения нет  */
  StrOff = "";

  /* Суммарная длина */
  SumLen = 0;

  /* Нет запомненной строки */
  MemStr = "";

  /* Нет владельца */
  HasOwner = False;

  /* Использовать стандартный вывод */
  UseStdOut = False;

  /* Определяем смещение */
  if ( ValType( POffset ) == V_INTEGER )
    Offset = POffset;
    while( POffset > 0 )
      StrOff  = StrOff  + " ";
      POffset = POffset - 1;
    end;
  else
    Offset = 0;
  end;

  /* Рисуем ли линии */
  if ( ValType( PShadow ) == V_BOOL    )
    Shadow = PShadow;
  else
    Shadow = False;
  end;

  /* Рисуем ли линии внутри таблицы */
  if ( ValType( PInShadow ) == V_BOOL  )
    InShadow = PInShadow;
  else
    InShadow = False;
  end;

  if ( Shadow )
    InShadow = True;
  end;

  m_printToBuffer = nvl(printToBuffer, false);
  m_printBuffer = TArray(100, 100);

  m_incrementalWidth = TArray(10, 5);

  m_indent = nvl(indent, 1);
  m_indentationString = mkStr(" ", m_indent);
  m_separatorIndentationString = mkStr("─", m_indent);

END;

// Класс для печати объектов в табличном виде. Параметры такие же, как у базового.
CLASS( CTableReport ) CObjectTableReport( POffset, PShadow, PInShadow )
    InitCTableReport( POffset, PShadow, PInShadow );

    private var PropNames = TArray; // имена свойств объекта, кот. надо выводить

    // Добавить колонку с заголовком Name для вывода свойства propName.
    // Параметры, кроме propName, как в одноимённой функции базового класса.
    MACRO AddColumn( name, propName, len, align )
        PropNames[PropNames.size] = propName;
        AddColumn( name, len, align );
    END;

    // Вывести строку с объектом obj.
    MACRO PrintObjectTransferByWord( obj )
        var values = TArray;
        var i = 0;
        while( i < PropNames.size )
          if( PropNames[i] == NULL )
            values[i] = "";
          else
            values[i] = ExecExp( "obj." + PropNames[i] );
          end;
          i = i + 1;
        end;
        PrintStringTransferByWord( values );
    END;
END;
