/*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 5.1                                         R-Style Software Lab

  File Name   : prim_lib.mac                                 March 11,2002
  Programmer  : LCh
  Description : Обработка первичных документов. 
  Comment     : Вспомогательные функции.
  Modifications:
 
└───────────────────────────────────────────────────────────────────────────*/
import BankInter, FIInter, PaymInter, OprInter, param;
import cbinfint;
import cb_sql, oralib;

FILE pspayord( pspayord );
FILE pscpord( pscpord );
FILE pscshdoc( pscshdoc );
FILE checkiss( checkiss );
FILE reqopena( reqopena );
FILE reqclosa( reqclosa );
FILE ps_bcord( ps_bcord );
FILE multydoc( multydoc );
FILE memorder( memorder );
FILE bbcpord( bbcpord );
FILE cb_doc( cb_doc );

FILE pmpaym ( pmpaym );
FILE pmprop ( pmprop );
FILE pmrmprop( pmrmprop );
FILE obchaptr( obchaptr );
FILE pers    ( person );
FILE ОперВГр ( acsgroupoper  );

Var ArrDocKind = Tarray;
  ArrDocKind( 0)  = 201;  /*  Рублевый платежный документ клиента */
  ArrDocKind( 1)  = 202;  /*  Валютный платежный документ клиента */
  ArrDocKind( 2)  = 200;  /*  Поручение на покупку валюты  */
  ArrDocKind( 3)  = 250;  /*  Ответные платежи РКО */
  ArrDocKind( 4)  = 300;  /* Ответный электронный документ Корсчетов*/
  ArrDocKind( 5)  = 310;  /* Начальный платеж АРМ                   */
  ArrDocKind( 6)  = 320;  /* Ответный электронный документ МБР      */
  ArrDocKind( 7)  = 15;   /* мультивалютный документ            */
  ArrDocKind( 8)  = 70;   /*  Новые мемориальные ордера(и рубли и валюта)*/
  ArrDocKind( 9)  = 16;   /*  платеж банка                      */
  ArrDocKind(10)  = 17;   /*  требование банка                  */
  ArrDocKind(11)  = 18;   /*  требование-поручение банка        */
  ArrDocKind(12)  = 27;   /*  валютный платеж банка              */
  ArrDocKind(13)  = 28;   /*  валютный перевод банка            */
  ArrDocKind(14)  = 410;  /* Объявление на взнос наличными в РКО    */
  ArrDocKind(15)  = 420;  /* Чек в РКО                              */
  ArrDocKind(16)  = 430;  /* Объявление на взнос наличными в ББ     */
  ArrDocKind(17)  = 440;  /* Чек в ББ                               */
  ArrDocKind(18)  = 240;  /*  Заявление на выдачу чековой книжки */
  ArrDocKind(19)  = 230;  /*  Заявление на открытие счета        */
  ArrDocKind(20)  = 231;  /*  Заявление на закрытие счета        */

var   /* Параметры фильтра первичных документов */
   f_Department = 0, 
   f_dat1, f_dat2,
   f_currency   = -1,
   f_PayerAccount    = "",
   f_ReceiverAccount = "",
   f_GrOper = 0,  
   f_oper   = 0,
   f_NumberPack   = 0,
   f_needOwnDoc   = false,
   f_needOwnStep  = false,
   FlagFOper  = TRUE,
   FlagAccess = TRUE;

var ЗначениеПоля = TArray;

    /* Коды полей в таблице */
const
   N_DATE     = 0,
   N_CURR     = 1,
   N_NUMDOC   = 2,
   N_DEBET    = 3,
   N_CREDIT   = 4,
   N_SUM      = 5,
   N_OPER     = 6,
   N_PACK     = 7,
   N_LIST     = 8,
   N_KIND     = 9,
   N_STEP     = 10,
   N_GRND     = 11,
   N_DPRT     = 12,
   N_STATE    = 13,
   N_ID       = 14;

const DOCUMENTID_LEN = 34;
const
    STATUS_POST  = 1, /* отложено*/
    STATUS_OPEN  = 2, /* открыто*/
    STATUS_CLOSE = 3; /* закрыто*/


/* 201   Статус pspayord
const  PSPO_ST_DEFERRED  = 0;
const  PSPO_ST_WORKING   = 1;
const  PSPO_ST_I2        = 2;
const  PSPO_ST_I1        = 3;
const  PSPO_ST_REJECTED  = 10;
const  PSPO_ST_CLOSED    = 15;
*/
/* 202, 27, 28  Системные статусы валютных платежек */
const  CP_ST_DEFERRED  = 0;  /* Отложена*/
const  CP_ST_WORKING   = 1;  /* Обрабатывается*/
const  CP_ST_REJECTED  = 10; /* Отвергнута*/
const  CP_ST_CLOSED    = 15;  /* Закрыта*/

/*  410  Статусы кассового ордера */
const  STAT_CASH_ORDER_POST   =1 ;    /* отложен*/
const  STAT_CASH_ORDER_OPEN   =2 ;    /* открыт*/
const  STAT_CASH_ORDER_CLOSE  =3 ;     /* закрыт*/


/*  240  Статусы заявления на выдачу чековых книжек */
const  CHECKISS_ST_POST   =1;    /* отложено*/
const  CHECKISS_ST_OPEN   =2;    /* открыто*/
const  CHECKISS_ST_CLOSE   =3;     /* закрыто*/

/*  230  Системные статусы заявления на открытие счета */
const  REQOPENA_ST_DEFERRED  = 0;  /* Отложена */
const  REQOPENA_ST_WORKING   = 1;  /* Обрабатывается*/
const  REQOPENA_ST_REJECTED  = 20; /* Отвергнута*/
const  REQOPENA_ST_CLOSED    = 30;  /* Закрыта*/

/*  231  Системные статусы заявления на закрытие счета */
const  REQCLOSA_ST_DEFERRED  = REQOPENA_ST_DEFERRED; /* Отложено*/
const  REQCLOSA_ST_WORKING   = REQOPENA_ST_WORKING;  /* Обрабатывается*/
const  REQCLOSA_ST_REJECTED  = REQOPENA_ST_REJECTED; /* Отвергнуто*/
const  REQCLOSA_ST_CLOSED    = REQOPENA_ST_CLOSED;    /* Закрыто*/

/*  200  Системные статусы заявления на покупку\продажу валюты */
const  PSBCORD_ST_DEFERRED  = 0;  /* Отложена*/
const  PSBCORD_ST_WORKING   = 10; /* Обрабатывается*/
const  PSBCORD_ST_REJECTED  = 15; /* Отвергнута*/
const  PSBCORD_ST_CLOSED    = 20;  /* Закрыта*/

/*  15*/
const  MCDOC_STATUS_POST =1;
const  MCDOC_STATUS_OPEN=2;
const  MCDOC_STATUS_CLOSE=3;

/*  16, 17, 18 состояния мем. ордеров */
const  MEMORDER_STATUS_POST =1;
const  MEMORDER_STATUS_OPEN =2;
const  MEMORDER_STATUS_CLOSE =3;

/*  70 Системные мемориальных ордеров */
const   CB_DOC_STATE_DEFERRED   =  0; /* Отложен */
const   CB_DOC_STATE_WORKING    =  1; /* Обрабатывается */
const   CB_DOC_STATE_CLOSED     = 50; /* Закрыт         */

/*  27 see 202*/
/*  28 see 202*/


/*------------------------------------------*/
/* разбор строки p_Str с разделителями из delim -> в массив p_Arr */
MACRO StrToArrInt( p_Str, p_Arr, delim )
     var k = strBrk( p_Str, delim ),
         i;

     p_Arr.Size = 0;
     while ( k > 0 ) 
        i = int(substr( p_Str, 1, k-1));
        p_Str = substr( p_Str, k+1);
        k = strBrk( p_Str, delim );
        if ( i != 0 )
          p_Arr(p_Arr.size) = i;
        end;
     end;
     i = int( p_Str );
     if ( i != 0 )
          p_Arr(p_Arr.size) = i;
     end;
END;

/*------------------------------------------*/
MACRO GetNameOper( oper )
  pers.Oper = oper;
  if(  getEQ( pers ) )
   return  pers.Name;
  end;
  return "";
END;

/*------------------------------------------*/
macro LZ( num, len )
    var str1 = trim( string( num ) ),
        len1 = strlen( str1 );
    if ( len1 >= len ) return str1;
    else  return  mkstr("0", len-len1 ) + str1 ;
    end;
end;

/*------------------------------------------*/
macro LZ_ID( num, len )
    var str1 = trim( string( num ) ),
        len1 = strlen( str1 );
    if ( len1 >= len ) return str1;
    else  return  mkstr("0", len-len1 ) + str1;
    end;
end;

/*--------------------------------- */
macro DateLZ( dat )
 var d,m,y;
  datesplit( dat, d, m, y );
  return LZ(y,4) + LZ(m,2) + LZ(d,2);
end;


macro  FiltrCurrency( Currency ) 
  if ( (f_currency >= 0 ) and (f_currency != Currency ) )
       return FALSE; 
  else return TRUE;
  end;
end;

macro  FiltrDepartment( Department ) 
  if ( (f_Department != 0 ) and ( f_Department != Department) )
       return FALSE; 
  else return TRUE;
  end;
end;

macro  FiltrDate( Dat ) 
  if ( (f_Dat1 > Dat) or  (f_Dat2 < Dat) )
       return FALSE; 
  else return TRUE;
  end;
end;

macro  FiltrNumberPack( NumberPack ) 
  if ( (f_NumberPack != 0 ) and ( f_NumberPack != NumberPack) )
       return FALSE; 
  else return TRUE;
  end;
end;

/*  Фильтр по группам */
macro FiltrGrOper( Oper ) 

  if ( f_oper != 0 )
    ОперВГр.Oper = Oper;
    ОперВГр.GroupID = f_oper;
    if ( not getEQ( ОперВГр ) )    
       return FALSE; 
    end;
  end;
  if  (  FlagAccess and IsAccessToOperInf( Oper ) ) 
    return FALSE;              /* Нет прав доступа к оперу */
  end;
  return TRUE;
end;

/*  Фильтр по операционистам */  
macro  FiltrOper( Oper ) 
  if ( (f_oper != 0 ) and ( f_oper != Oper) )
       return FALSE; 
  end;
  if  (  FlagAccess and IsAccessToOperInf( Oper ) ) 
    return FALSE;              /* Нет прав доступа к оперу */
  end;
  return TRUE;
end;

MACRO DefFlagAccess
 file Опер( person);

 FlagAccess = TRUE;
 if ( f_Oper != 0 )
   if( f_GrOper == 0 )  /* Фильтр опера*/
     if ( (f_Oper == {oper} )  or        /* Только свои счета */
           not IsAccessToOperInf(f_Oper)  )
          FlagAccess = FALSE;
          return;
     end;
   else                /* Фильтр группы оперов */
     ReplaceMacro( "FiltrOper", "FiltrGrOper" );
   end;
 end;

 pers.Oper = {oper};
 getEQ( pers );
 if  ( ( pers.CTypePerson == "А") or
       ( pers.CTypePerson == "У") or
       ( pers.CTypePerson == "Б") )
   FlagAccess = FALSE;
 else
   FlagAccess = TRUE;
 end;
END;


macro CheckAccountMask( acc, mask )
   if ( (mask == "") or (CompareStrWithMasks( mask, acc ) == 0) ) return true; 
   end;
   return false;
end;

/*------------------------------------------*/
/*    Есть проводки опера или группы? */
macro Check_OperOfOpr( DocKind, DocumentID )

  FILE oproper (oproper) KEY 1; /* Экземпляр операции  */     
  FILE oprstep (oprstep) KEY 0; /* Шаг операции */     
  record d ( arhdoc );
  var stat;
  macro CheckOprStep
    var l_next;
    clearrecord( oprstep );
    oprstep.ID_operation = oproper.ID_operation;
    oprstep.ID_step = -1;
    l_next = getGE( oprstep ) ;
    while( l_next  and ( oprstep.ID_operation == oproper.ID_operation ) )

              /* выполненный + проверка опера шага */
      if( f_needOwnStep and (oprstep.IsExecute   == "X") and  FiltrOper( oprstep.Oper) ) 
           return true;
      end;

      if( f_needOwnDoc )  /* проверка опера документа */
        ClearRecord( d );
        while ( GetDocsByOperStep( d, oproper.ID_Operation, oprstep.ID_step ) )
          if ( FiltrOper(d.Oper) ) 
           return true;
          end;
        end;
      end;

      l_next = next( oprstep );
    end;

    return false;
  end;

  /* Сканирование шагов операции */
  oproper.DocKind    = DocKind;
  oproper.DocumentID = DocumentID;
  oproper.Start_date = date(0,0,0);
  stat = getGE( oproper );
  while( stat and (oproper.DocKind    == DocKind)
              and (oproper.DocumentID == DocumentID ) )

    message( "Проверка шагов операции ",oproper.ID_operation );
    if ( CheckOprStep() )  return TRUE; end;

    stat = next( oproper );
  end;
  return FALSE;
end;

/*------------------------------------------*/
macro FiltrDocInf( ArrDocInf )
   if ( 
        not FiltrDate( ArrDocInf( N_DATE ) ) or
        not FiltrCurrency( ArrDocInf( N_CURR ) ) or
        not FiltrDepartment( ArrDocInf( N_DPRT ) )  or
        not FiltrNumberPack( ArrDocInf( N_PACK ) )  or
        not CheckAccountMask( ArrDocInf( N_DEBET ), f_PayerAccount ) or
        not CheckAccountMask( ArrDocInf( N_CREDIT), f_ReceiverAccount ) 
      ) 
     return false;
   elif ( FlagFOper )   /* проверка опера */
       if ( not FiltrOper( ArrDocInf( N_OPER ) ) and  /* не наш документ */
            ( (not f_needOwnDoc and not f_needOwnStep) or 
              not Check_OperOfOpr( ArrDocInf(N_KIND), ArrDocInf(N_ID) ) ))
         return false;
       end;
   end;
   return true;

end;

/*------------------------------------------*/
macro FiltrPmPaym( pm )

   if ( not FiltrCurrency( pm.FIID ) or
        not FiltrDepartment( pm.Department )  or
        not FiltrNumberPack( pm.NumberPack )  or
        not CheckAccountMask( pm.PayerAccount, f_PayerAccount ) or
        not CheckAccountMask( pm.ReceiverAccount, f_ReceiverAccount ) )
        return false;
   else return true;
   end;

end;


/*-----------------------------------*/
/* Платеж */
macro FillInfPm( ArrDocInf, pm )

   macro GetRmProp( PaymentID )
     pmrmprop.PaymentID = PaymentID;
     if ( getEQ(pmrmprop) ) 
       ArrDocInf( N_NUMDOC)   = pmrmprop.Number;
       ArrDocInf( N_GRND)     = pmrmprop.Ground;
     end;
   end;

   ArrDocInf( N_ID  )     = LZ_ID( pm.PaymentID, DOCUMENTID_LEN ); 

   ArrDocInf( N_DATE )    = pm.ValueDate;
   ArrDocInf( N_CURR )    = pm.FIID; 
   ArrDocInf( N_NUMDOC)   = "";
   ArrDocInf( N_DEBET )   = pm.PayerAccount;
   ArrDocInf( N_CREDIT)   = pm.ReceiverAccount;
   ArrDocInf( N_SUM   )   = pm.Amount;
   ArrDocInf( N_OPER  )   = 0;
   ArrDocInf( N_PACK  )   = pm.NumberPack;
   ArrDocInf( N_DPRT  )   = pm.Department;
   ArrDocInf( N_GRND  )   = "";

   GetRmProp( pm.PaymentID );

end;


macro GetPmPaym( ArrDocInf, DocumentID, Purpose )

/*    keynum( pmpaym, 1);
    pmpaym.DocKind    = ArrDocInf(N_KIND);  
    pmpaym.DocumentID = DocumentID;
    pmpaym.Purpose    = Purpose;
    pmpaym.SubPurpose = 0; 
  */
    var cmd, rs;
    cmd = RSDCommand("select t.* " +
                      " from dpmpaym_dbt t " +
                      " where t.T_DocKind = " + ArrDocInf(N_KIND) +
                      " and t.T_DocumentID = " + DocumentID +
                      " and t.T_Purpose = " + Purpose +
                      " and t.T_SubPurpose >= 0"
                      " order by t.T_DocKind, t.T_DocumentID, t.T_Purpose, t.T_PaymentID, t.T_SubPurpose");
    rs = RsdRecordset( cmd );           
    cmd.execute;

    if ( rs.MoveNext /*getGE( pmpaym ) and (pmpaym.DocKind == ArrDocInf(N_KIND)) 
                and (pmpaym.DocumentID == DocumentID)
                and (pmpaym.Purpose    == Purpose )*/ )
      CopyRSetToFBuff(pmpaym, rs);
      FillInfPm( ArrDocInf, pmpaym );
      return TRUE;
    end;
    return FALSE;
end;


macro FillInfPsCsh( ArrDocInf, fDoc )

   if ( not GetPmPaym( ArrDocInf, fDoc.AutoKey, PM_PURP_CASHBAL ) )
     ArrDocInf( N_DEBET ) = "";
     ArrDocInf( N_CREDIT) = "";
     ArrDocInf( N_CURR  ) = 0; 
     ArrDocInf( N_SUM   ) = 0;
     ArrDocInf( N_GRND  ) = "";
     ArrDocInf( N_NUMDOC) = "";
     ArrDocInf( N_DPRT  ) = 0;
   end;

   ArrDocInf( N_ID  )     = LZ_ID( fDoc.AutoKey, 12 ); 

   if ( (fDoc.DocKind == 410)  or (fDoc.DocKind == 430) ) /* Объявление на взнос наличными*/
     ArrDocInf( N_CREDIT)   = fDoc.ClientAccount;
   else /* Чек */
     ArrDocInf( N_DEBET )   = fDoc.ClientAccount;
   end;                     
   ArrDocInf( N_OPER  )   = fDoc.Oper;

end;


macro FillInfCheckIss( ArrDocInf, fDoc )

   ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, 12 ); 

   ArrDocInf( N_DATE )    = fDoc.Date;
   ArrDocInf( N_CURR )    = 0; 
   ArrDocInf( N_NUMDOC)   = fDoc.Number;
   ArrDocInf( N_DEBET )   = "";
   ArrDocInf( N_CREDIT)   = fDoc.Account;
   ArrDocInf( N_SUM   )   = 0;
   ArrDocInf( N_OPER  )   = fDoc.Oper;
   ArrDocInf( N_PACK  )   = fDoc.NumberPack;
   ArrDocInf( N_DPRT  )   = fDoc.Department;
   ArrDocInf( N_GRND  )   = fDoc.Ground;

end;

macro FillInfReqOpenA( ArrDocInf, fDoc )

   ArrDocInf( N_ID  )     = LZ_ID( fDoc.RequestID, DOCUMENTID_LEN ); 

   ArrDocInf( N_DATE )    = fDoc.Date;
   ArrDocInf( N_CURR )    = fDoc.Code_Currency; 
   ArrDocInf( N_NUMDOC)   = fDoc.Number;
   ArrDocInf( N_DEBET )   = "";
   ArrDocInf( N_CREDIT)   = fDoc.Account;
   ArrDocInf( N_SUM   )   = 0;
   ArrDocInf( N_OPER  )   = fDoc.Oper;
   ArrDocInf( N_PACK  )   = 0;
   ArrDocInf( N_DPRT  )   = fDoc.Department;
   ArrDocInf( N_GRND  )   = "";
end;


macro FillInfReqCloseA( ArrDocInf, fDoc )

   ArrDocInf( N_ID  )     = LZ_ID( fDoc.RequestID, 10 ); 

   ArrDocInf( N_DATE )    = fDoc.Date;
   ArrDocInf( N_CURR )    = fDoc.Code_Currency; 
   ArrDocInf( N_NUMDOC)   = fDoc.Number;
   ArrDocInf( N_DEBET )   = "";
   ArrDocInf( N_CREDIT)   = fDoc.Account;
   ArrDocInf( N_SUM   )   = 0;
   ArrDocInf( N_OPER  )   = fDoc.Oper;
   ArrDocInf( N_PACK  )   = fDoc.NumberPack;
   ArrDocInf( N_DPRT  )   = fDoc.Department;
   ArrDocInf( N_GRND  )   = fDoc.Ground;
end;


macro FillInfMultyDoc( ArrDocInf, fDoc )
   var md = RsbMultyDoc(fDoc.AutoKey);

   ArrDocInf( N_ID  )     = LZ_ID( md.AutoKey, DOCUMENTID_LEN ); 

   ArrDocInf( N_DATE )    = md.Payment.Date;
   ArrDocInf( N_NUMDOC)   = md.Payment.Number;
   ArrDocInf( N_DEBET )   = md.Payment.PayerAccount;
   ArrDocInf( N_CREDIT)   = md.Payment.ReceiverAccount;
/* ArrDocInf( N_CURR )    = md.Payment.PayerFIID;
   ArrDocInf( N_SUM   )   = md.Payment.PayerAmount;
*/
/* Две валюты, две суммы! */
   ArrDocInf( N_CURR )    = -1;
   ArrDocInf( N_SUM   )   = 0;
   ArrDocInf( N_OPER  )   = md.Oper;
   ArrDocInf( N_PACK  )   = md.Payment.NumberPack;
   ArrDocInf( N_DPRT  )   = md.Payment.Department;
   ArrDocInf( N_GRND  )   = md.Payment.Ground;

END;

macro FillInfBcOrd( ArrDocInf, fDoc )

/*?*/ ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, DOCUMENTID_LEN ); 
   ArrDocInf( N_DATE )    = fDoc.OrderDate; 
   ArrDocInf( N_NUMDOC)   = fDoc.Number;
   ArrDocInf( N_DEBET )   = fDoc.SourceAccount;
   ArrDocInf( N_CREDIT)   = fDoc.RequiredAccount;
   if (fDoc.SourceAmount)
    ArrDocInf( N_SUM   )   = fDoc.SourceAmount;
    ArrDocInf( N_CURR )    = fDoc.SourceFIID;
   else
    ArrDocInf( N_SUM   )   = fDoc.RequiredAmount;
    ArrDocInf( N_CURR )    = fDoc.RequiredFIID;
   end;

   ArrDocInf( N_OPER  )   = fDoc.Oper;
   ArrDocInf( N_PACK  )   = fDoc.NumberPack;
   ArrDocInf( N_DPRT  )   = fDoc.Department;
   ArrDocInf( N_GRND  )   = fDoc.Ground;

end;

macro FillInfCbDoc( ArrDocInf, fDoc )
   var mo = RsbMemorialOrder(fDoc.DocumentID);

   ArrDocInf( N_ID  )     = LZ_ID( mo.DocumentID, 10 ); 
   ArrDocInf( N_DATE )    = mo.Payment.ValueDate;
   ArrDocInf( N_CURR )    = mo.Code_Currency; 
   ArrDocInf( N_NUMDOC)   = mo.Payment.Number;
   ArrDocInf( N_DEBET )   = mo.Payment.PayerAccount;
   ArrDocInf( N_CREDIT)   = mo.Payment.ReceiverAccount;
   ArrDocInf( N_SUM   )   = mo.Payment.PayerAmount;
   ArrDocInf( N_OPER  )   = mo.Oper;
   ArrDocInf( N_PACK  )   = mo.Payment.NumberPack;
   ArrDocInf( N_DPRT  )   = mo.Payment.Department;
   ArrDocInf( N_GRND  )   = mo.Payment.Ground;
end;


macro FillInfPsOrd( ArrDocInf, fDoc )

   ArrDocInf( N_DATE )    = date(0,0,0);
   ArrDocInf( N_CURR )    = 0;
   ArrDocInf( N_NUMDOC)   = "";
   ArrDocInf( N_DEBET )   = "";
   ArrDocInf( N_CREDIT)   = "";
   ArrDocInf( N_SUM   )   = $0;
   ArrDocInf( N_PACK  )   = 0;
   ArrDocInf( N_DPRT  )   = 0;
   ArrDocInf( N_GRND  )   = "";

  if  (   ArrDocInf( N_KIND ) == 201 )
    GetPmPaym( ArrDocInf, fDoc.OrderID, PM_PURP_POPRIMARY );
    ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, DOCUMENTID_LEN ); 

  elif( ( ArrDocInf( N_KIND ) == 16 ) or
        ( ArrDocInf( N_KIND ) == 17 ) or
        ( ArrDocInf( N_KIND ) == 18 ) ) 
    GetPmPaym( ArrDocInf, fDoc.OrderID, PM_PURP_BANKPAYMENT );
    ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, 12 ); 

  elif(   ArrDocInf( N_KIND ) == 202 )       /* валютных платежек*/
    GetPmPaym( ArrDocInf, fDoc.OrderID, PM_PURP_POPRIMARY );
    ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, DOCUMENTID_LEN ); 
  elif(   ArrDocInf( N_KIND ) == 27 ) /*Валютный платеж банка*/
    GetPmPaym( ArrDocInf, fDoc.OrderID, PM_PURP_BANKPAYMENT );
    ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, DOCUMENTID_LEN ); 
  elif(   ArrDocInf( N_KIND ) == 28 )  /* Валютный банковский перевод */
    GetPmPaym( ArrDocInf, fDoc.OrderID, PM_PURP_BANKPAYMENT );
    ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, DOCUMENTID_LEN ); 
  else
    ArrDocInf( N_ID  )     = LZ_ID( fDoc.OrderID, DOCUMENTID_LEN ); 
  end;

  ArrDocInf( N_OPER  )   = fDoc.Oper;


end;
        


 /* Фильтр открытых/закрытых */
macro FiltrCloseDate( State, CloseDate)
    if  ( State == STATUS_OPEN )
        if ( CloseDate != date(0,0,0) ) return FALSE; end;
    elif( State == STATUS_CLOSE ) 
        if ( CloseDate == date(0,0,0) ) return FALSE; end;
    end;
    return TRUE;
end;

macro ProcPmPaym( DocKind, State, procFill, procFDoc)
  var stat, stat_proc = true, cmd, rs;
/*    keynum( pmpaym, 10); /* Платежи  DocKind+ValueDate+Purpose+SubPurpose */
    pmpaym.DocKind    = DocKind;  
    pmpaym.ValueDate  = f_dat1;
    pmpaym.Purpose    = 0;
    pmpaym.SubPurpose = 0; 

    stat = getGE( pmpaym );
  */  
  cmd = RSDCommand("select t.* " +
                      " from dpmpaym_dbt t " +
                      " where t.T_DocKind = " + DocKind +
                      " and t.T_ValueDate BETWEEN " + GetSQLDate(f_dat2) + " and " + GetSQLDate(f_dat2) );
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)
        CopyRSetToFBuff(pmpaym, rs);
/*    while( stat and stat_proc and (pmpaym.DocKind == DocKind) and (pmpaym.ValueDate <= f_dat2) )
  */
          ExecMacro( procFill, ЗначениеПоля, pmpaym );
          if ( FiltrDocInf( ЗначениеПоля ) )
            stat_proc = ExecMacro2( procFDoc, ЗначениеПоля, pmpaym );
          end;
/*      stat = next( pmpaym ); 
  */      
    end;/*while*/
  return stat_proc;
end;

/*__250_________________________*/
macro ProcPmPaymProp( DocKind, State, procFill, procFDoc)
  var stat, stat_proc = true, cmd, rs;
  const PM_KVITPROCESSING = 3100,  /* Обрабатывается в БЭК-ОФИСЕ */
        PM_FINISHED       = 32000;  /* Завершенный платеж         */

    macro GetPmProp( PaymentID, DK )
      pmprop.PaymentID = PaymentID;
      pmprop.DebetCredit = DK;
      if ( getEQ(pmprop) and ( pmprop.IsSender != "" /*ответный*/) )
        return TRUE;
      end;
      return FALSE;
    end;

    if  ( State == STATUS_OPEN ) State = PM_KVITPROCESSING;
    else                         State = PM_FINISHED; 
    end;

/*    keynum( pmpaym, 9); /* ToBackOffice+PaymStatus+ValueDate+FIID+Amount */
    pmpaym.ToBackOffice = "Ч"; /*РКО*/
    pmpaym.PaymStatus   = State; 
    pmpaym.ValueDate    = f_dat1;
    pmpaym.FIID         = 0;
    pmpaym.Amount       = 0;

    stat = getGE( pmpaym );
  */
  cmd = RSDCommand("select t.* " +
                      " from dpmpaym_dbt t " +
                      " where t.T_PaymStatus = " + State +
                      " and t.T_ToBackOffice = 'Ч' " +
                      " and t.T_FIID <> 0 " +
                      " and t.T_ValueDate BETWEEN " + GetSQLDate(f_dat2) + " and " + GetSQLDate(f_dat2) );
    rs = RsdRecordset( cmd );           
    cmd.execute;

    while (rs.MoveNext)
      CopyRSetToFBuff(pmpaym, rs);
/*    while( stat and stat_proc 
                and (pmpaym.ToBackOffice == "Ч"  )
                and (pmpaym.PaymStatus   == State)
                and (pmpaym.ValueDate <= f_dat2) )*/
      if (/* ( pmpaym.FIID != 0 ) and*/  /*Валютный*/   /*ответный*/
           ( GetPmProp( rs.value(0) /*pmpaym.PaymentID*/, 0) or GetPmProp( rs.value(0) /*pmpaym.PaymentID*/, 1) ) )
          ExecMacro( procFill, ЗначениеПоля, pmpaym );
          if ( FiltrDocInf( ЗначениеПоля ) )
            stat_proc = ExecMacro2( procFDoc, ЗначениеПоля, pmpaym );
          end;
      end;
      /*  stat = next( pmpaym );*/

    end;/*while*/

  return stat_proc;
end;

/* Получить платеж по альтернативному ключу */
MACRO GetPaymentAttKey( m_DocumentID, m_DocKind, m_Purpose );
  var rset:object;
  var select:string;
  var params:TArray = TArray();

  select = " SELECT pm.T_DEPARTMENT, pm.T_FIID, pm.t_payfIID " +
           "   FROM dpmpaym_dbt pm " +
           "  WHERE pm.T_DocKind    = :DocKind" +
           "    AND pm.T_DocumentID = :DocumentID" +
           "    AND pm.T_Purpose    = :Purpose" +
           "    AND pm.T_SubPurpose = 0";
  params[params.size] = SQLParam( "DocKind", m_DocKind );
  params[params.size] = SQLParam( "DocumentID", m_DocumentID );
  params[params.size] = SQLParam( "Purpose", m_Purpose );
  rset = execSQLselect( select, params, TRUE );
  
  if( rset and rset.moveNext() )
    pmpaym.Department = rset.value(0);
    pmpaym.FIID       = rset.value(1);
    pmpaym.PayFIID    = rset.value(2);
    return true;
  end;
  return false;
END;

/*__410__420__430__440_________________________*/
macro ProcPsCshDoc( DocKind, State /*STAT_CASH_ORDER_...*/, procFill, procFDoc )
  var  stat_proc = true;

  macro  ScanCSDoc( fDoc, IsCurrency )
   var stat, cmd, rs;
   cmd = RSDCommand("select t.*" +
                      " from " + SQL_GetTableName( fDoc ) + " t "
                      " where t.T_Status = " + State +
                      " and t.T_IsCurrency = " + IsCurrency +
                      " and t.T_DocKind = " + DocKind);
   rs = RsdRecordset( cmd );           
   cmd.execute;

   while( rs.MoveNext )
     CopyRSetToFBuff(fDoc, rs);
     if( GetPaymentAttKey( fDoc.AutoKey, DocKind, PM_PURP_CASHBAL ) )
       if( FiltrDepartment( pmpaym.Department ) )
         ExecMacro( procFill, ЗначениеПоля, fDoc );
         if ( FiltrDocInf( ЗначениеПоля ) )
            stat_proc  = ExecMacro2( procFDoc, ЗначениеПоля, fDoc );
         end;
       end;
     end;
    end;/*while*/
  end;

  if (  f_currency <= 0  )
    ScanCSDoc( pscshdoc, "chr(0)" );  /* Рубли */
  end;
  if ( (f_currency < 0) or (f_currency > 0) )
    ScanCSDoc( pscshdoc, "'X'" ); /* Валюта */
  end;

  return stat_proc;
    
end;/*ProcPsCshDoc*/


macro ProcFDocKind( fDoc, DocKind, State, procFill, procFDoc )
  var stat;
  var  stat_proc = true;

   ClearRecord(fDoc);
   fDoc.DocKind = DocKind;
   fDoc.Status  = State;
   stat = getGE(fDoc);
   while( stat and stat_proc and ( fDoc.DocKind == DocKind ) and ( fDoc.Status == State ) )
      ExecMacro( procFill, ЗначениеПоля, fDoc );
      if ( FiltrDocInf( ЗначениеПоля ) )
          stat_proc = ExecMacro2( procFDoc, ЗначениеПоля, fDoc );
      end;
      stat = next(fDoc);
        
   end;/*while*/

  return stat_proc;
end;

/*____240__230__231__________________________*/
macro ProcFDocCurState( fDoc, State, procFill, procFDoc )
  var stat;
  var  stat_proc = true;
  var cmd, rs;

/*   ClearRecord(fDoc);

   fDoc.CurrentState = State;
   fDoc.CloseDate = date(0,0,0);
   stat = getGE(fDoc);
  */
   cmd = RSDCommand("select t.*" +
                      " from " + SQL_GetTableName( fDoc ) + " t "
                      " where t.T_CurrentState = " + State );
   rs = RsdRecordset( cmd );           
   cmd.execute;
   while (rs.MoveNext)

    if ( FileName(fDoc) == "pspayord.dbt" )
      fDoc.Oper = rs.value(4);
      fDoc.OrderID = rs.value(0);
     else
      CopyRSetToFBuff(fDoc, rs);
    end;
/*   while( stat and stat_proc and ( fDoc.CurrentState  == State ) )*/
      ExecMacro( procFill, ЗначениеПоля, fDoc );
      if ( FiltrDocInf( ЗначениеПоля ) )
          stat_proc = ExecMacro2( procFDoc, ЗначениеПоля, fDoc );
      end;
      /*stat = next(fDoc);*/
   end;/*while*/

  return stat_proc;
end;

/*__15________________________________*/
MACRO ProcMultyDoc(  State, procFill, procFDoc )
  var save_currency = f_currency;
  var stat_proc:bool = true;
 
  /* Фильтр по валютам */
  MACRO FiltrSaveCurrency( md )   /* Две валюты! */
    if( (save_currency >= 0 ) and 
        (save_currency != md.Payment.PayerFIID ) and 
        (save_currency != md.Payment.ReceiverFIID )  )
        return FALSE; 
    else return TRUE;
    end;
  END;

  MACRO ScanMDocChapter(fDoc, Chapter)
    var md:RsbMultyDoc;
    var mrset:object;
    var mselect:string;
    var mparams:TArray = TArray();
   
    mselect = "SELECT mcd.*" +
              "  FROM " + SQL_GetTableName( fDoc ) + " mcd " +
              " WHERE mcd.t_Chapter = :Chapter" +
              "   AND mcd.t_Status  = :State";
    mparams[mparams.size] = SQLParam( "Chapter", Chapter );
    mparams[mparams.size] = SQLParam( "State", State );
    mrset = execSQLselect( mselect, mparams, TRUE );

    while( mrset and mrset.moveNext() and stat_proc )
      CopyRSetToFBuff(fDoc, mrset);
      md = RsbMultyDoc(fDoc.AutoKey);
      if( FiltrDepartment( md.Payment.Department ) and FiltrSaveCurrency(md) )
        ExecMacro( procFill, ЗначениеПоля, fDoc );
        if ( FiltrDocInf( ЗначениеПоля ) )
          stat_proc = ExecMacro2( procFDoc, ЗначениеПоля, fDoc );
        end;
      end;
     end;
  END;

  if( f_currency >= 0) f_currency = -1; end;

  rewind(obchaptr );
  while( next(obchaptr) )
    ScanMDocChapter(multydoc, obchaptr.Chapter);
  END;

  f_currency = save_currency;

  return stat_proc;
end;/*ProcMultyDoc*/


/*__70________________________________*/
MACRO ProcCbDoc( DocKind, State, procFill, procFDoc )
  var stat_proc:bool = true;

  MACRO ScanCbDocChapter(fDoc, Chapter)
    var mo:RsbMemorialOrder;
    var mrset:object;
    var mselect:string;
    var mparams:TArray = TArray();

    mselect = "SELECT cbd.*" +
              "  FROM " + SQL_GetTableName( fDoc ) + " cbd " +
              " WHERE cbd.t_Chapter = :Chapter" +
              "   AND cbd.t_State   = :State";
    mparams[mparams.size] = SQLParam( "Chapter", Chapter );
    mparams[mparams.size] = SQLParam( "State", State );
    mrset = execSQLselect( mselect, mparams, TRUE );
    
    while( mrset and mrset.moveNext() and stat_proc )
      CopyRSetToFBuff(fDoc, mrset);
      mo = RsbMemorialOrder(fDoc.DocumentID);
      if( FiltrDepartment( mo.Payment.Department ) )
        ExecMacro( procFill, ЗначениеПоля, fDoc );
        if ( FiltrDocInf( ЗначениеПоля ) )
          stat_proc =ExecMacro2( procFDoc, ЗначениеПоля, fDoc );
        end;
      end;
    end;
  END;

  rewind(obchaptr);
  while( stat_proc and next(obchaptr) )
    ScanCbDocChapter( cb_doc, obchaptr.Chapter);
  end;

  return stat_proc;
end;/*ProcCbDoc*/


macro FillFDocKind( ArrDocInf, DocKind )

  ArrDocInf( N_KIND  )   = DocKind; 
  if  (   DocKind == 201 )
    FillInfPsOrd( ArrDocInf, pspayord );

  elif(   DocKind == 202 )       /* валютных платежек*/
    FillInfPsOrd( ArrDocInf, pscpord );

  elif(   DocKind == 200 ) /* заявления на покупку\продажу валюты */
    FillInfBcOrd( ArrDocInf, ps_bcord );

  elif(   DocKind == 250 )
    FillInfPm( ArrDocInf, pmpaym );

  elif(   DocKind == 240 ) /*  заявления на выдачу чековых книжек */
    FillInfCheckIss( ArrDocInf, checkiss );

  elif(   DocKind == 230 ) /*  заявления на открытие счета */
    FillInfReqOpenA( ArrDocInf, reqopena );

  elif(   DocKind == 231 )   /* заявления на закрытие счета */
    FillInfReqCloseA( ArrDocInf, reqclosa );

  elif(   DocKind == 27 ) /*Валютный платеж банка*/
    FillInfPsOrd( ArrDocInf, bbcpord );

  elif  ( DocKind == 15 )
    FillInfMultyDoc( ArrDocInf, multydoc );

  elif  ( DocKind == 70 )
    FillInfCbDoc( ArrDocInf, cb_doc );

  elif( ( DocKind == 16 ) or
        ( DocKind == 17 ) or
        ( DocKind == 18 ) ) 
    FillInfPsOrd( ArrDocInf, memorder );

  /*  платежи МБР */
  elif( ( DocKind == 300 ) or
        ( DocKind == 310 ) or
        ( DocKind == 320 ) )
    FillInfPm( ArrDocInf, pmpaym );

  /*  первичные документы в Кассе */
  elif( ( DocKind == 410 ) or  /* CASH_PS_INCORDER   Объявление на взнос наличными в РКО */
        ( DocKind == 420 ) or  /* CASH_PS_OUTORDER   Чек в РКО */
        ( DocKind == 430 ) or  /* CASH_BOF_INCORDER  Объявление на взнос наличными в ББ */
        ( DocKind == 440 ) )   /* CASH_BOF_OUTORDER  Чек в ББ */
    FillInfPsCsh( ArrDocInf, pscshdoc );

  else
/*    FillInfDummy( ArrDocInf, null );*/
  end;
end;

macro GetFDocPos( fDoc, ObjID, DocKind )
  keynum( fDoc, 0 );
  if  ( (  DocKind == 201 ) or
        (  DocKind == 202 ) or /* валютных платежек*/
        (  DocKind == 200 ) or /* заявления на покупку\продажу валюты */
        (  DocKind == 240 ) or /* заявления на выдачу чековых книжек */
        (  DocKind == 27  ) or /* Валютный платеж банка*/
        (  DocKind == 28  ) or /* Валютный банковский перевод */
        (  DocKind == 16  ) or
        (  DocKind == 17  ) or
        (  DocKind == 18  )  )
   fDoc.OrderID    = int( ObjID );
  elif( (  DocKind == 250 ) or
        (  DocKind == 300 ) or
        (  DocKind == 310 ) or
        (  DocKind == 320 )  )
   fDoc.PaymentID  = int( ObjID );
  elif( (  DocKind == 230 ) or  /* заявления на открытие счета */
        (  DocKind == 231 )  )  /* заявления на закрытие счета */
   fDoc.RequestID  = int( ObjID );
  elif( (  DocKind == 15  ) or  /* CASH_PS_INCORDER   Объявление на взнос наличными в РКО */  
        (  DocKind == 410 ) or  /* CASH_PS_OUTORDER   Чек в РКО */                            
        (  DocKind == 420 ) or  /* CASH_BOF_INCORDER  Объявление на взнос наличными в ББ */   
        (  DocKind == 430 ) or  /* CASH_BOF_OUTORDER  Чек в ББ */                             
        (  DocKind == 440 )  )
   fDoc.AutoKey    = int( ObjID );
  elif  (  DocKind == 70 )
   fDoc.DocumentID = int( ObjID );
  end;
  return getEQ( fDoc );
end;
/* Взять перв.документ по адресу в файле */
macro GetFDocKind( ArrDocInf, DocKind, ObjectID )
  /*
  macro GetFDocPos( fDoc, Addr )
    return GetDirect( fDoc, Addr);
  end;*/

  ArrDocInf( N_KIND  )   = DocKind; 
  if  (   DocKind == 201 )
    if ( not GetFDocPos( pspayord, ObjectID, DocKind )) return FALSE; end;
    FillInfPsOrd( ArrDocInf, pspayord );

  elif(   DocKind == 202 )       /* валютных платежек*/
    if ( not GetFDocPos( pscpord, ObjectID, DocKind  )) return FALSE; end;
    FillInfPsOrd( ArrDocInf, pscpord );

  elif(   DocKind == 200 ) /* заявления на покупку\продажу валюты */
    if ( not GetFDocPos( ps_bcord, ObjectID, DocKind  )) return FALSE; end;
    FillInfBcOrd( ArrDocInf, ps_bcord );

  elif(   DocKind == 250 )
    if ( not GetFDocPos( pmpaym, ObjectID, DocKind  )) return FALSE; end;
    FillInfPm( ArrDocInf, pmpaym );

  elif(   DocKind == 240 ) /*  заявления на выдачу чековых книжек */
    if ( not GetFDocPos( checkiss, ObjectID, DocKind  )) return FALSE; end;
    FillInfCheckIss( ArrDocInf, checkiss );

  elif(   DocKind == 230 ) /*  заявления на открытие счета */
    if ( not GetFDocPos( reqopena, ObjectID, DocKind  )) return FALSE; end;
    FillInfReqOpenA( ArrDocInf, reqopena );

  elif(   DocKind == 231 )   /* заявления на закрытие счета */
    if ( not GetFDocPos( reqclosa, ObjectID, DocKind  )) return FALSE; end;
    FillInfReqCloseA( ArrDocInf, reqclosa );

  elif(   DocKind == 27 ) /*Валютный платеж банка*/
    if ( not GetFDocPos( bbcpord, ObjectID, DocKind  )) return FALSE; end;
    FillInfPsOrd( ArrDocInf, bbcpord );

  elif  ( DocKind == 15 )
    if ( not GetFDocPos( multydoc, ObjectID, DocKind  )) return FALSE; end;
    FillInfMultyDoc( ArrDocInf, multydoc );

  elif  ( DocKind == 70 )
    if ( not GetFDocPos( cb_doc, ObjectID, DocKind  )) return FALSE; end;
    FillInfCbDoc( ArrDocInf, cb_doc );

  elif( ( DocKind == 16 ) or
        ( DocKind == 17 ) or
        ( DocKind == 18 ) ) 
    if ( not GetFDocPos( memorder, ObjectID, DocKind  )) return FALSE; end;
    FillInfPsOrd( ArrDocInf, memorder );

  /*  платежи МБР */
  elif( ( DocKind == 300 ) or
        ( DocKind == 310 ) or
        ( DocKind == 320 ) )
    if ( not GetFDocPos( pmpaym, ObjectID, DocKind  )) return FALSE; end;
    FillInfPm( ArrDocInf, pmpaym );

  /*  первичные документы в Кассе */
  elif( ( DocKind == 410 ) or  /* CASH_PS_INCORDER   Объявление на взнос наличными в РКО */
        ( DocKind == 420 ) or  /* CASH_PS_OUTORDER   Чек в РКО */
        ( DocKind == 430 ) or  /* CASH_BOF_INCORDER  Объявление на взнос наличными в ББ */
        ( DocKind == 440 ) )   /* CASH_BOF_OUTORDER  Чек в ББ */
    if ( not GetFDocPos( pscshdoc, ObjectID, DocKind  )) return FALSE; end;
    FillInfPsCsh( ArrDocInf, pscshdoc );
  end;

  return TRUE;
end;


/* Сканирование перв.документов определенного вида и состояния */
/* State:  STATUS_POST  STATUS_OPEN  STATUS_CLOSE */
/*          procFDoc(ЗначениеПоля) */
macro ProccessFDocKind( DocKind, State, procFDoc )
  var stat_proc = true;

  ЗначениеПоля( N_KIND  )   = DocKind; 
  if  (   DocKind == 201 )
    if   ( State == STATUS_POST )   State = PSPO_ST_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = PSPO_ST_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = PSPO_ST_CLOSED;/* закрыто*/
    end;
    keynum( pspayord, 2);
    stat_proc = ProcFDocCurState( pspayord, State, @FillInfPsOrd, procFDoc );

  elif(   DocKind == 202 )       /* валютных платежек*/
    if   ( State == STATUS_POST )   State = CP_ST_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = CP_ST_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = CP_ST_CLOSED;/* закрыто*/
    end;
    keynum( pscpord, 2);
    stat_proc = ProcFDocCurState( pscpord, State, @FillInfPsOrd, procFDoc );

  elif(   DocKind == 200 ) /* заявления на покупку\продажу валюты */
    if   ( State == STATUS_POST )   State = PSBCORD_ST_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = PSBCORD_ST_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = PSBCORD_ST_CLOSED;/* закрыто*/
    end;
    keynum( ps_bcord, 1);
    stat_proc = ProcFDocCurState( ps_bcord, State, @FillInfBcOrd, procFDoc );

  elif(   DocKind == 250 )
    stat_proc = ProcPmPaymProp( DocKind, State, @FillInfPm, procFDoc); 

  elif(   DocKind == 240 ) /*  заявления на выдачу чековых книжек */
    if   ( State == STATUS_POST )   State = CHECKISS_ST_POST; /* отложено*/
    elif ( State == STATUS_OPEN )   State = CHECKISS_ST_OPEN; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = CHECKISS_ST_CLOSE;/* закрыто*/
    end;
    keynum( checkiss, 2);
    stat_proc = ProcFDocCurState( checkiss, State, @FillInfCheckIss, procFDoc );

  elif(   DocKind == 230 ) /*  заявления на открытие счета */
    if   ( State == STATUS_POST )   State = REQOPENA_ST_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = REQOPENA_ST_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = REQOPENA_ST_CLOSED;/* закрыто*/
    end;
    keynum( reqopena, 3);
    stat_proc = ProcFDocCurState( reqopena, State, @FillInfReqOpenA, procFDoc );

  elif(   DocKind == 231 )   /* заявления на закрытие счета */
    if   ( State == STATUS_POST )   State = REQCLOSA_ST_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = REQCLOSA_ST_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = REQCLOSA_ST_CLOSED;/* закрыто*/
    end;
    keynum( reqclosa, 3);
    stat_proc = ProcFDocCurState( reqclosa, State, @FillInfReqCloseA, procFDoc );

  elif(   DocKind == 27 ) /*Валютный платеж банка*/
    if   ( State == STATUS_POST )   State = CP_ST_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = CP_ST_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = CP_ST_CLOSED;/* закрыто*/
    end;
    keynum( bbcpord, 2);
    stat_proc = ProcFDocCurState( bbcpord, State, @FillInfPsOrd, procFDoc );

  elif  ( DocKind == 15 )

    keynum( multydoc, 1); /* Chapter+Status+CloseDate*/
    if   ( State == STATUS_POST )   State = MCDOC_STATUS_POST;
    elif ( State == STATUS_OPEN )   State = MCDOC_STATUS_OPEN;
    elif ( State == STATUS_CLOSE )  State = MCDOC_STATUS_CLOSE;
    end;
    stat_proc = ProcMultyDoc(  State, @FillInfMultyDoc, procFDoc );

  elif  ( DocKind == 70 )
    keynum(cb_doc,1); /*Chapter+State+CloseDate+DocumentID*/
    if   ( State == STATUS_POST )   State = CB_DOC_STATE_DEFERRED; /* отложено*/
    elif ( State == STATUS_OPEN )   State = CB_DOC_STATE_WORKING; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = CB_DOC_STATE_CLOSED;/* закрыто*/
    end;
    stat_proc = ProcCbDoc(  DocKind, State, @FillInfCbDoc, procFDoc );

  elif( ( DocKind == 16 ) or
        ( DocKind == 17 ) or
        ( DocKind == 18 ) ) 
    keynum( memorder, 1);  /*DocKind+Status+CloseDate+OrderID*/
    if   ( State == STATUS_POST )   State = MEMORDER_STATUS_POST; /* отложено*/
    elif ( State == STATUS_OPEN )   State = MEMORDER_STATUS_OPEN; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = MEMORDER_STATUS_CLOSE;/* закрыто*/
    end;
    stat_proc = ProcFDocKind( memorder, DocKind, State, @FillInfPsOrd, procFDoc );

  /*  платежи МБР */
  elif( ( DocKind == 300 ) or
        ( DocKind == 310 ) or
        ( DocKind == 320 ) )

    stat_proc = ProcPmPaym( DocKind, State, @FillInfPm, procFDoc );

  /*  первичные документы в Кассе */
  elif( ( DocKind == 410 ) or  /* CASH_PS_INCORDER   Объявление на взнос наличными в РКО */
        ( DocKind == 420 ) or  /* CASH_PS_OUTORDER   Чек в РКО */
        ( DocKind == 430 ) or  /* CASH_BOF_INCORDER  Объявление на взнос наличными в ББ */
        ( DocKind == 440 ) )   /* CASH_BOF_OUTORDER  Чек в ББ */

    if   ( State == STATUS_POST )   State = STAT_CASH_ORDER_POST; /* отложено*/
    elif ( State == STATUS_OPEN )   State = STAT_CASH_ORDER_OPEN; /* открыто*/
    elif ( State == STATUS_CLOSE )  State = STAT_CASH_ORDER_CLOSE;/* закрыто*/
    end;
    keynum( pscshdoc, 4);
    stat_proc = ProcPsCshDoc( DocKind, State, @FillInfPsCsh, procFDoc );
  end;

  return stat_proc;
end;


