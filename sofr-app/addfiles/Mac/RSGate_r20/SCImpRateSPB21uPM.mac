/*
$Name:        SCImpRateSPB21uPM.mac
$Module:      Шлюз Securities
$Description: Загрузка курсов СПБ, XML формат SPB21 с пом. Payments
*/

IMPORT gtdlfun_u, PTInter, FIInter, "DlRepForm_h.mac", "globals.mac", "secinter.mac", "gtImSpbP_DL.mac", "SCImpRateCompReport.mac";

PRIVATE VAR   FlagCtrlBrk = false;
PRIVATE CONST CtrlBrkErr  = 17;

PRIVATE CONST Код_на_СПБ_ФинИн   = 22;
PRIVATE CONST Код_на_СПБ_Субъект = 76;

PRIVATE CONST RATE_KIND_MARKET     = 1;  /*курс вида "Рыночная цена"         */        
PRIVATE CONST RATE_KIND_MIN        = 2;  /*курс вида "Минимальная цена"      */
PRIVATE CONST RATE_KIND_MAX        = 3;  /*курс вида "Максимальная цена"     */
PRIVATE CONST RATE_KIND_WA         = 4;  /*курс вида "Средневзвешенная цена" */
PRIVATE CONST RATE_KIND_NKD1SEC    = 15; /*курс вида "НКД на одну бумагу"    */
PRIVATE CONST RATE_KIND_VOLUME     = 35; /*курс вида "(СПБ) Объём торгов"    */
PRIVATE CONST RATE_KIND_MARKET_TAX = 21; /*курс вида "Рыночная цена для НДФЛ"*/

PRIVATE CONST AVRKIND_EQUITY_SHARE              = "АКЦИИ ОБЫКНОВЕННЫЕ",
              AVRKIND_PREFERENCE_SHARE          = "АКЦИИ ПРИВИЛЕГИРОВАННЫЕ",
              AVRKIND_INVESTMENT_SHARE_OPEN     = "ПАЙ ОТКРЫТОГО ПИФ",
              AVRKIND_INVESTMENT_SHARE_CLOSE    = "ПАЙ ЗАКРЫТОГО ПИФ",
              AVRKIND_ETF                       = "ETF",
              AVRKIND_RDR                       = "RDR",
              AVRKIND_ADR                       = "ADR",
              AVRKIND_GDR                       = "GDR",
              AVRKIND_INVESTMENT_SHARE_INTERVAL = "ПАЙ ИНТЕРВАЛЬНОГО ПИФ",
              AVRKIND_MORTGAGE                  = "ИПОТЕЧНЫЙ ВЕКСЕЛЬ",
              AVRKIND_BOND_STATE                = "ГОСУДАРСТВЕННЫЕ ОБЛИГАЦИИ",
              AVRKIND_BOND_MUNICIPAL            = "МУНИЦИПАЛЬНЫЕ ОБЛИГАЦИИ",
              AVRKIND_BOND_CB                   = "ОБЛИГАЦИИ ЦЕНТРАЛЬНОГО БАНКА",
              AVRKIND_BOND_CORPORATE            = "КОРПОРАТИВНЫЕ ОБЛИГАЦИИ",
              AVRKIND_BOND_CREDIT               = "ОБЛИГАЦИИ КРЕДИТНОЙ ОРГАНИЗАЦИИ",
              AVRKIND_BOND_EXCHANGE             = "БИРЖЕВЫЕ ОБЛИГАЦИИ";

/* Точность задания курса по умолчанию */
private const RATE_POINT  = 4;

private var msgboxu_str;
private macro msgboxu(str)
  msgboxu_str = str;
end;

private macro FileDateInName(date_val)
  var day, month, year;
  DateSplit(date_val,day,month,year);

  return RGDLFUN_LZ(year,4) + "-" + RGDLFUN_LZ(month,2) + "-" + RGDLFUN_LZ(day,2);
end;

PRIVATE CLASS SC_ImportRateSPB21uPM(dt)
  var m_date = dt;
  var m_IsCreateReport = false;

  PRIVATE VAR m_RateParm  = TRecHandler("rateparm");
  PRIVATE VAR m_RateType  = TArray();
  PRIVATE VAR m_BaseFI    = TRecHandler("fininstr.dbt");
  PRIVATE VAR m_BaseAvoir = TRecHandler("avoiriss.dbt");
  PRIVATE VAR m_fideriv   = TBFile("fideriv.dbt");

  PRIVATE VAR m_AllRecords, m_RatesCount, m_ErrorCount, m_WarnCount, m_BeginTime, m_ExecuteTime;
  PRIVATE VAR m_ImpFileName = NULL;

  PRIVATE CLASS DataRates()
    var TradeDate:date,
        BoardID:string,
        SecurityId:string,
        FaceValue:double,
        SecCurrencyId:string,
        SecurityType:string,
        Decimals:integer,
        CurrencyId:string,
        AccruedInterest:double,
        TotalAmount:double,
        MaxDealPrice:double,
        MinDealPrice:double,
        WAPrice:double,
        MarketPrice3:double;

    macro Init()
      TradeDate = date(0,0,0);
      BoardID = SecurityId = SecCurrencyId = SecurityType = CurrencyId = "";
      Decimals = 0;
      AccruedInterest = TotalAmount = MaxDealPrice = MinDealPrice = WAPrice = MarketPrice3 = 0.0;
    end;

    macro InitRecords()
      SecurityId = SecCurrencyId = SecurityType = CurrencyId = "";
      Decimals = 0;
      AccruedInterest = TotalAmount = MaxDealPrice = MinDealPrice = WAPrice = MarketPrice3 = 0.0;
    end;
  END;

  PRIVATE VAR Rates = DataRates();

  macro ImpDate()
    return m_date;
  end;

  PRIVATE CLASS RateType( _TypeName:STRING, _IsMarketPlace:STRING )
     VAR TypeName      = _TypeName,
         IsMarketPlace = _IsMarketPlace;
  END;

  MACRO Error( Str:STRING ):BOOL
     MsgBox( "ERROR: " + Str );
     m_ErrorCount = m_ErrorCount + 1;
     return false;
  END;

  MACRO Warning( Str:STRING ):BOOL
     MsgBox( "WARNING: " + Str );
     m_WarnCount = m_WarnCount + 1;
     return true;
  END;

  MACRO ImportOneCourse( FI_Code:STRING,          // Код ФИ (Базовый ФИ)
                         FI_CodeKind:INTEGER,     // Вид кода ФИ (FICK_...)
                         RateKind:INTEGER,        // Вид курса
                         IsRelative:BOOL,         // Признак относительной котировки
                         IsDominant:BOOL,         // Признак основного курса
                         IsInverse:BOOL,          // Признак обратной котировки
                         Scale:INTEGER,           // Масштаб курса
                         Point:INTEGER,           // Количество значащих цифр
                         SinceDate:DATE,          // Дата установки курса
                         FI_CurCode:STRING,       // Код валюты котировки (Котируемый ФИ)
                         FI_CurCodeKind:INTEGER,  // Вид кода валюты котировки (FICK_...)
                         MarketCode:STRING,       // Код торговой площадки
                         MarketCodeKind:INTEGER,  // Вид кода субъекта торговой площадки (PTCK_...)
                         MarketOffice:INTEGER,    // Сектор торговой площадки
                         Rate:DOUBLE,             // Значение курса
                         TCC_FLAG:BOOL,           // Возможность надежного определения справедливой стоимости
                         BoardID:STRING           // Режим торгов
                       ):BOOL

     VAR QuotFIID = -1, FinError, CatErr = 0, TCC_Val;

     m_AllRecords = m_AllRecords + 1;

     if( Rate <= 0 )
        return true;
     end;

     m_RateParm.Clear();

     m_RateParm.rec.OtherFI = m_BaseFI.rec.FI_Code;

     if( (IsRelative != NULL) AND (IsRelative == true) )
        m_RateParm.rec.IsRelative = "X";
     end;

     if( m_BaseFI.rec.FI_Kind != FIKIND_CURRENCY )

        if( (FI_CurCode != NULL) AND (FI_CurCode != "") ) /*валюта котировки*/
           if( (FI_CurCodeKind == NULL) OR (FI_CurCodeKind <= 0) )
              FI_CurCodeKind = FICK_USERCODE;
           end;

           QuotFIID = ПолучитьКодФинИн( FI_CurCode, FinError, FI_CurCodeKind );
           if( (FinError != 0) OR (QuotFIID < 0) ) 
              return Error( "В ГКБО не найден ФИ с кодом \"" + FI_CurCode + "\" вида " + FI_CurCodeKind );
           end; 
        elif( m_BaseFI.rec.FI_Kind == FIKIND_DERIVATIVE )
           if( m_fideriv.rec.PriceMode == DERIVATIVE_MODE_PARENTFI )
              QuotFIID = m_BaseFI.rec.ParentFI;
           else
              QuotFIID = m_fideriv.rec.TickFIID;
           end;
        else
           QuotFIID = m_BaseFI.rec.FaceValueFI;
        end;

        if( m_RateParm.rec.IsRelative == SET_CHAR ) /* при заданном признаке отностиельной котировки валюта котировки должна совпадать с валютой номинала*/
           /* если это не так выведем в лог предупреждение */
           if( m_BaseFI.rec.FaceValueFI != QuotFIID )
              Warning( "<"+FI_Code + "> задан признак относительной котировки. Валюта котировки "+GetFICode(QuotFIID) +" не совпадает с валютой номинала ц/б " + GetFICode(m_BaseFI.rec.FaceValueFI) );
           end;
        end;
     else
        /*для валют котировка в нацвалюте*/
        QuotFIID = NATCUR; 
     end;

     if( (RateKind == NULL) OR (RateKind <= 0) )
        return Error( "<"+FI_Code + "> неверно задан вид курса." );
     elif( m_RateType[RateKind] == NULL )
        return Error( "<"+FI_Code + "> не найден вид курса (Type = " + RateKind +")." );
     else
        m_RateParm.rec.Type = RateKind;
     end;

     m_RateParm.rec.Name = m_RateType[m_RateParm.rec.Type].TypeName + " из " + iif( MarketCode == SPBEX_CODE, "СПБ", "ММВБ");

     /*котируемый ФИ*/
     m_RateParm.rec.FI_Code = ПолучитьКодФинИн( QuotFIID, FinError, FICK_USERCODE );
     if( (FinError != 0) OR (m_RateParm.rec.FI_Code == "") ) 
        return Error( "<"+FI_Code + "> не найден котируемый ФИ (FIID = " + QuotFIID + ")." + GetErrMsg() );
     end;

     if( m_RateType[m_RateParm.rec.Type].IsMarketPlace == "X" )
        if( (MarketCode != NULL) AND (MarketCode != "") )
           if( (MarketCodeKind == NULL) OR (MarketCodeKind <= 0) )
              MarketCodeKind = PTCK_CONTR;
           end;

           m_RateParm.rec.Market_Place = ПолучитьКодСубъекта( MarketCode, MarketCodeKind );
           if( m_RateParm.rec.Market_Place <= 0 )
              return Error( "В ГКБО не найден субъект с кодом \"" + MarketCode + "\" вида " + MarketCodeKind );  
           end;

           if( (MarketOffice != NULL) AND (MarketOffice > 0) )
              m_RateParm.rec.Section = MarketOffice;
           end;
        end;
     end;

     if( (IsInverse != NULL) AND (IsInverse == true) )
        m_RateParm.rec.IsInverse = "X";
     end;

     if( (Scale == NULL) OR (Scale <= 0) )
        m_RateParm.rec.Scale = 1;
     else
        m_RateParm.rec.Scale = Scale;
     end;

     if( (Point != NULL) AND (Point >= 0) )
        m_RateParm.rec.Point = Point;
     else
        if( (m_BaseFI.rec.FI_Kind == FIKIND_DERIVATIVE) AND (m_fideriv.rec.FIID > 0) )
           if( m_RateParm.rec.Type == RATETYPE_MINSTEP_PRICE )
              m_RateParm.rec.Point = m_BaseFI.rec.Point;
           else
              m_RateParm.rec.Point = m_fideriv.rec.TickPoint;
           end;
        else
           m_RateParm.rec.Point = RATE_POINT;
        end;
     end;

     m_RateParm.rec.Rate = Money( floor( Rate * pow(10,m_RateParm.rec.Point)+0.5) );

     if( (SinceDate == NULL) OR (SinceDate == DATE(0,0,0)) )
        m_RateParm.rec.SinceDate = ImpDate();
     else
        m_RateParm.rec.SinceDate = SinceDate;
     end;

     if( (IsDominant != NULL) AND (IsDominant == true) )
        m_RateParm.rec.IsDominant = "X";
     end;

     if( УстановитьКурс( m_RateParm ) != 0 ) /*внутри УстановитьКурс транзакция*/
        return Error( "<"+FI_Code + "> ошибка при установке курса <" + m_RateType[m_RateParm.rec.Type].TypeName + ">." + GetErrMsg() );
     end;

     if( TCC_FLAG != NULL )
        /*Установить "Возможность надежного определения справедливой стоимости"*/
        if( TCC_Flag == true )
           TCC_Val = 1;
        else
           TCC_Val = 2;
        end;

        var ТекущееЗначениеТСС;
        
        GetMainObjAttr(null, OBJTYPE_AVOIRISS, L_Z(m_BaseFI.rec.FIID, 10), 27, ТекущееЗначениеТСС);
        
        if((ValType(ТекущееЗначениеТСС) == V_UNDEF) or (ТекущееЗначениеТСС != TCC_Val))
           /*Установить "Возможность надежного определения справедливой стоимости"*/
           if( (not DisconnectObjAttr( OBJTYPE_AVOIRISS, L_Z( m_BaseFI.rec.FIID, 10 ), 27 )) 
               OR
               (not ConnectObjAttr( CatErr, OBJTYPE_AVOIRISS, L_Z( m_BaseFI.rec.FIID, 10 ), 27, TCC_Val )) 
               OR
               (CatErr != 0)
             )
              return Error( "<"+FI_Code + "> ошибка при установке категории <" + ИмяКатегории(OBJTYPE_AVOIRISS, 27) + ">." + GetErrMsg() );
           end;
        end;

     end;

     m_RatesCount = m_RatesCount + 1; 
     return true;
  END;

  PRIVATE MACRO RunImp( RateKind:INTEGER, RateValue:DOUBLE, result_protocol:@TStrCollector, recs:@integer, errrecs:@integer, errmsg:@string, isExitWarning:bool):INTEGER
    var imp_date, SecType, CurRate, IsDominant, IsRelative;

    if(isExitWarning)
      m_WarnCount = m_WarnCount + 1;
    else
      if( Rates.TradeDate != date(0,0,0) )
        imp_date = Rates.TradeDate;
      else
        imp_date = ImpDate();
      end;
      msgboxu_str = "";
      replacemacro("msgbox","msgboxu");

      SecType = StrUpr(Rates.SecurityType);

      if( RateKind == RATE_KIND_MARKET )
        IsDominant = true;
      else
        IsDominant = false;
      end; 

      if( (Rates.CurrencyId == "PCT") and (RateKind != RATE_KIND_NKD1SEC) )
        IsRelative = true;
      else
        IsRelative = false;
      end;

      if( Rates.CurrencyId == "PCT" )
        CurRate = Rates.SecCurrencyId;
      else
        CurRate = Rates.CurrencyId;
      end;

      if( (in(SecType,                
              AVRKIND_BOND_STATE, 
              AVRKIND_BOND_MUNICIPAL, 
              AVRKIND_BOND_CB,
              AVRKIND_BOND_CORPORATE,
              AVRKIND_BOND_CREDIT,
              AVRKIND_BOND_EXCHANGE)) and (RateKind != RATE_KIND_NKD1SEC) )  //По сути избыточный блок, но пусть остается для соответствия ТЗ
        IsRelative = true;

        if( (RateKind == RATE_KIND_MARKET) or (RateKind == RATE_KIND_MARKET_TAX) )
          CurRate = Rates.SecCurrencyId;
        end;
      end;

      if( ImportOneCourse( Rates.SecurityId,        // Код ФИ (Базовый ФИ)
                           Код_на_СПБ_ФинИн,        // Вид кода ФИ (FICK_...)
                           RateKind,                // Вид курса
                           IsRelative,              // Признак относительной котировки
                           IsDominant,              // Признак основного курса
                           false,                   // Признак обратной котировки
                           1,                       // Масштаб курса
                           Rates.Decimals,          // Количество значащих цифр
                           imp_date,                // Дата установки курса
                           CurRate,                 // Код валюты котировки (Котируемый ФИ)
                           Код_на_СПБ_ФинИн,        // Вид кода валюты котировки (FICK_...)
                           "ПАО СПБ",               // Код торговой площадки
                           Код_на_СПБ_Субъект,      // Вид кода субъекта торговой площадки (PTCK_...)
                           0,                       // Сектор торговой площадки
                           RateValue,               // Значение курса
                           null,                    // Возможность надежного определения справедливой стоимости
                           null                     // Rates.BoardID            // Режима торгов
                         ) == false )
        replacemacro("msgbox");
        errrecs = errrecs + 1;
        result_protocol.AddString(errrecs + ". Ошибка загрузки котировки " + Rates.SecurityId + ": " + msgboxu_str);
        return 1;
      end;     
      replacemacro("msgbox");
    end;
    recs = recs + 1;
    return 0;

  OnError(ErObj)
    Error( "Модуль: " + string(ErObj.Module) + "\nСтрока: " + string(ErObj.Line) + "\nКод ошибки: " + string(ErObj.Code) + "\n" + ErObj.Message );
    if(ErObj.Code == CtrlBrkErr)
      FlagCtrlBrk = true;
    else
        recs = recs + 1;
        errrecs = errrecs + 1;
        result_protocol.AddString(errrecs + ". Модуль: " + string(ErObj.Module) + "\nСтрока: " + string(ErObj.Line) + "\nКод ошибки: " + string(ErObj.Code) + "\n" + ErObj.Message);
    end;
    return ErObj.Code;
  END;

  PRIVATE MACRO ImpNomForIndexNom(result_protocol:@TStrCollector, recs:@integer, errrecs:@integer, errmsg:@string):INTEGER
    var imp_date;

    if( Rates.TradeDate != date(0,0,0) )
      imp_date = Rates.TradeDate;
    else
      imp_date = ImpDate();
    end;

    InstLoadModule("gtdlfun.mac");
    ErrMsg = "";
    if( ExecMacro2("ЗагрузитьНоминалДляОФЗИНЗаДату", m_BaseAvoir, Rates.FaceValue, imp_date, @ErrMsg) != 0 ) 
      errrecs = errrecs + 1;
      result_protocol.AddString(errrecs + ". Ошибка загрузки номинала за дату по ц/б с кодом \""+ ПолучитьКодФинИн(m_BaseAvoir.rec.FIID)+"\"."+ErrMsg);
    elif( ErrMsg != "" )
      if((index(ErrMsg, "установлено значение номинальной стоимости") > 0) or
         (index(ErrMsg, "уже введено значение номинальной стоимости") > 0))
        result_protocol.AddString("Предупреждение: " + ErrMsg);
      else
        errrecs = errrecs + 1;
        result_protocol.AddString(errrecs + ". Ошибка: " + ErrMsg);
      end;
    end;
    recs = recs + 1;
    return 0;

  OnError(ErObj)
    if(ErObj.Code == CtrlBrkErr)
      FlagCtrlBrk = true;
    else
      RemProgress();
      recs = recs + 1;
      errrecs = errrecs + 1;
      result_protocol.AddString(errrecs + ". Модуль: " + string(ErObj.Module) + "\nСтрока: " + string(ErObj.Line) + "\nКод ошибки: " + string(ErObj.Code) + "\n" + ErObj.Message);
    end;
    return ErObj.Code;
  END;

  MACRO PrepareImport(errmsg:@string):BOOL
     m_AllRecords = 0;
     m_RatesCount = 0;
     m_ErrorCount = 0;
     m_WarnCount  = 0;
     m_ExecuteTime = time(0,0,0);
     m_RateParm  = TRecHandler("rateparm");
     m_RateType  = TArray();
     m_BaseFI    = TRecHandler("fininstr.dbt");
     m_BaseAvoir = TRecHandler("avoiriss.dbt");
     m_fideriv   = TBFile("fideriv.dbt");

     VAR RS = TRsbDataSet("SELECT t_Type, t_TypeName, t_IsMarketPlace FROM dratetype_dbt");
     m_RateType.Size = 0;
     while( RS.MoveNext() )
        m_RateType[int(SQL_ConvTypeInteger(RS.type))] = RateType(SQL_ConvTypeStr(RS.TypeName), SQL_ConvTypeStr(RS.IsMarketPlace));
     end;

     m_IsCreateReport = DL_РежимСверкиКотировок(@errmsg);
     if(errmsg != "")
        return false;        
     end;

     return true;
  END;

  MACRO RunImportSPBP(result_protocol:@TStrCollector, recs:@integer, errrecs:@integer, errmsg:@string):bool
     var Synonim = "";
     var NameDate = FileDateInName(ImpDate());
     var stat = 0;
     var query, cmd, ds, NRec = 0;
     var ReportFileName, OldOutPut;
     var i:integer = 0;
     var hour, min, sec;
     var Progress = TProgressBar;
     var IsExitWarning = false;
    
     TimeSplit(Time(), hour, min, sec);
    
     var namef = NameDate + string(Time());
     ReportFileName = GetTxtFileName("SCImpRateSPB21uPM_" + NameDate + "_" + hour + min + sec);
    
     if(ImpDate() > {curdate})
        errmsg = "Дата операции больше операционного дня";
        return false;
     end;

     Synonim = GetShemePathGATE();
     if(Synonim == "")
        errmsg = "Не найден схема Payments";
        return false;
     end;
    
     Progress.Init(4, "Выполняется обработка данных", "Просмотр записей котировок...");
     OldOutPut = SetOutput( ReportFileName, TRUE );

     stat = CheckFileUpload(Synonim, "SPB21", ImpDate(), @errmsg);

     Message("Очистка таблицы SPB21");
     println("Начало очистки таблицы SPB21 " + time());
     if(stat == 0)
        stat = DelSPB21(@errmsg);
     end;
     println("Конец очистки таблицы SPB21 " + time());
     Progress.Use();

     println( "Начало заполнения SPB21 " + time() );
     Message("Заполнение таблицы SPB21");
     if(stat == 0)
        stat = FillSPB21(Synonim, ImpDate(), @errmsg);
     end;
     Progress.Use();
     println( "Конец заполнения SPB21 " + time() );

     SetOutput( OldOutPut, TRUE );
     if(stat)
        return false;
     else
        Rates.Init();
        stat = GetFileName(synonim, "D_SPB21_TMP", @m_ImpFileName, @errmsg);
        if(stat)
          return false;      
        end;

        MsgBox("Используются файлы: \n" + m_ImpFileName);
        Message("Обработка данных SPB21");

        Query = "SELECT NVL(T.T_TRADEDATE, TO_DATE('01.01.0001', 'DD.MM.YYYY')) TRADEDATE, "            
              + "       NVL(T.T_BOARDID, CHR(1)) BOARDID, "             
              + "       NVL(T.T_SECURITYID, CHR(1)) SECURITYID, "               
              + "       NVL(T.T_FACEVALUE, 0) FACEVALUE, "
              + "       NVL(T.T_SECCURRENCYID, CHR(1)) SECCURRENCYID, "            
              + "       NVL(T.T_SECURITYTYPE, CHR(1)) SECURITYTYPE, "            
              + "       NVL(T.T_DECIMALS, 0) DECIMALS, "             
              + "       NVL(T.T_CURRENCYID, CHR(1)) CURRENCYID, "                
              + "       NVL(T.T_ACCRUEDINTEREST, 0) ACCRUEDINTEREST, "                 
              + "       NVL(T.T_TOTALAMOUNT, 0) TOTALAMOUNT, "                 
              + "       NVL(T.T_MAXDEALPRICE, 0) MAXDEALPRICE, "
              + "       NVL(T.T_MINDEALPRICE, 0) MINDEALPRICE, "                 
              + "       NVL(T.T_WAPRICE, 0) WAPRICE, "                  
              + "       NVL(T.T_MARKETPRICE3, 0) MARKETPRICE3 "              
              + "  FROM D_SPB21_TMP T "
              + " ORDER BY T.T_ID_SPB_SPB21";

        cmd = DL_RSDCommand(Query);
        NRec = cmd.GetCount();

        if((stat == 0) AND (NRec > 0))
           if(GetDialogFlag())
              InitProgress(NRec, "Загрузка внешнего файла котировок", "ОБРАБОТКА ВХОДНЫХ ДАННЫХ SPB21");
           end;
           OldOutPut = SetOutput( ReportFileName, TRUE );
           println( "Начало обработки данных из таблицы SPB21 " + time() );
           SetOutput( OldOutPut, TRUE );   

           ds = cmd.execute();
           while(ds.MoveNext)
              IsExitWarning = false;

              Rates.InitRecords();
              Rates.TradeDate       = ds.TRADEDATE;
              Rates.BoardID         = ds.BOARDID;
              Rates.SecurityID      = ds.SECURITYID; 
              Rates.FaceValue       = ds.FACEVALUE;
              Rates.SecCurrencyID   = ds.SECCURRENCYID; 
              Rates.SecurityType    = ds.SECURITYTYPE;
              Rates.Decimals        = ds.DECIMALS;
              Rates.CurrencyID      = ds.CURRENCYID; 
              Rates.AccruedInterest = ds.ACCRUEDINTEREST;
              Rates.TotalAmount     = ds.TOTALAMOUNT;
              Rates.MaxDealPrice    = ds.MAXDEALPRICE;  
              Rates.MinDealPrice    = ds.MINDEALPRICE; 
              Rates.WAPrice         = ds.WAPRICE;
              Rates.MarketPrice3    = ds.MARKETPRICE3;

              if(ПолучитьФинИн( Rates.SecurityID, m_BaseFI, m_BaseAvoir, NULL, NULL, Код_на_СПБ_ФинИн ) != 0)/*не считаем ошибкой*/
                 if(ПолучитьФинИн( Rates.SecurityID, m_BaseFI, m_BaseAvoir, NULL, NULL, FICK_ISIN ) != 0)               
                    MsgBox( "WARNING: В ГКБО не найден ФИ с кодом \"" + Rates.SecurityId + "\" вида " + Код_на_СПБ_ФинИн );
                    IsExitWarning = true; 
                 end;
              end;

              if((m_BaseFI.rec.FI_Kind == FIKIND_DERIVATIVE) and (not IsExitWarning))
                 m_fideriv.clear();  
                 m_fideriv.rec.FIID = m_BaseFI.rec.FIID;
                 if(m_fideriv.GetEQ() == false)/*не считаем ошибкой*/
                    MsgBox( "WARNING: Производный инструмент с FIID = " + string(m_BaseFI.rec.FIID) + " не найден в справочнике");
                    IsExitWarning = true; 
                 end;
              end;

              if((Rates.BoardID != NULL) and (not IsExitWarning))
                 var NumInList = "";
                 var AttrID = ПолучитьЗначениеКатегории( m_BaseAvoir, 36, OBJTYPE_AVOIRISS );
              
                 if( not GetMainObjAttr( null, OBJTYPE_AVOIRISS, UniID(m_BaseAvoir, OBJTYPE_AVOIRISS), 36, AttrID, null, NumInList ) )
                    NumInList = "";
                 end;
                 if( (NumInList == "1"/*EQCC*/) and (Rates.BoardID == "EQCC") )
                    /* загружаем */
                 elif( (NumInList == "2"/*EQQI*/) and (Rates.BoardID == "EQQI") )
                    /* загружаем */
                 elif( (NumInList == "3"/*EQDP*/) and (Rates.BoardID == "EQDP") )
                    /* загружаем */
                 elif( (NumInList == ""/*не задано*/) and (Rates.BoardID != "EQCC") and (Rates.BoardID != "EQQI") and (Rates.BoardID != "EQDP") )
                    /* загружаем */
                 else
                    /* НЕ загружаем */
                    MsgBox( "WARNING: Неверный режим торгов для финансового инструмента с кодом \"" + Rates.SecurityID + "\"" );
                    IsExitWarning = true; 
                 end;
              end;

              RunImp(RATE_KIND_MARKET,     Rates.MarketPrice3,    @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);
              RunImp(RATE_KIND_MIN,        Rates.MinDealPrice,    @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);
              RunImp(RATE_KIND_MAX,        Rates.MaxDealPrice,    @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);
              RunImp(RATE_KIND_WA,         Rates.WAPrice,         @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);
              RunImp(RATE_KIND_NKD1SEC,    Rates.AccruedInterest, @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);
              RunImp(RATE_KIND_VOLUME,     Rates.TotalAmount,     @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);                 
              RunImp(RATE_KIND_MARKET_TAX, Rates.MarketPrice3,    @result_protocol, @recs, @errrecs, @errmsg, IsExitWarning);

              ImpNomForIndexNom(@result_protocol, @recs, @errrecs, @errmsg);
               
              i = i + 1;
              if(GetDialogFlag())
                 UseProgress(i);
              end;
              if(FlagCtrlBrk == true)
                 break;
              end;
           end;
           if(GetDialogFlag())
              RemProgress(); 
           end;
           OldOutPut = SetOutput( ReportFileName, TRUE );
           println( "Конец обработки данных из таблицы SPB21 " + time() );
        end;
        Progress.Use();
     end;

     if(m_IsCreateReport)
        println( "Начало формирования отчета по SPB21 " + time() );
        Message("Формирование отчета по SPB21");
        RunSCImpRateCompReport(date(), ImpDate());
        Progress.Use();
        println( "Конец формирования отчета по SPB21 " + time() );
        SetOutput( OldOutPut, TRUE );
     end;

     Progress.Remove();
     return true;
  OnError(ErObj)
     errmsg = "Модуль: " + string(ErObj.Module) + "\nСтрока: " + string(ErObj.Line) + "\nКод ошибки: " + string(ErObj.Code) + "\n" + ErObj.Message;
     return false;
  END;
END;

macro RunU_PM(imp_date:date, result_protocol:@TStrCollector, recs:@integer, errrecs:@integer, errmsg:@string):bool
  var Rate = SC_ImportRateSPB21uPM(imp_date);

  if(not Rate.PrepareImport(@errmsg))
    return false;
  end;

  if(not Rate.RunImportSPBP(@result_protocol, @recs, @errrecs, @errmsg))
    return false;
  end;

  return true;
end;
