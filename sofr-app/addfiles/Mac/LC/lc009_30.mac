/*
  $Name:        lc009_30.mac
  $Module:      Документарные аккредитивы
  $Description: Макрос шага
*/

// --------------------------------------------------------------------
//         Автоматизированная банковская система RS-Bank v6.0
//                 Copyright (c) R-Style Software Lab
//
//  Назначение  : Макрос шага
//
//  Описание    : Операция - 3411   - "Аккредитив"
//                Блок     - 341009 - "Сделка МБК RS-Dealing"
//                Шаг      - 30     - "Ожидание зачисления привлеченных средств"
//
//  Программист : Чукина Т.А.
//
//  Создан      : 12.07.2013
//
// --------------------------------------------------------------------

IMPORT LCInter, lc_common, OprInter, "pm_const.mac", BankInter;

var LCDocObj:RsbLetterOfCredit;

private macro IsPaymentInCurrentLcdocObj(PaymentID : integer) : bool
  var Pays : RsbLCPay = LCDocObj.Pays(),
      RecLcpay : TRecHandler = TRecHandler("lcpay");

  var IsFoundPay : bool = ( Pays.First(RecLcpay) == 0 );
  while(IsFoundPay)
    if(RecLcpay.rec.PaymentID == PaymentID)
      return TRUE;
    end;

    IsFoundPay = ( Pays.Next(RecLcpay) == 0 );
  end;

  return FALSE;
end;

private macro GetPmByLcpay(RecLcpay : TRecHandler, PaymCount : @integer) : integer
  PaymCount = 0;
  var PaymentID : integer = 0;

  var DealID : integer = IfThenElse( RecLcpay.rec.DealID > 0, 
                                     RecLcpay.rec.DealID,
                                     LCDocObj.DealID );

  // В SQL-запросе исключаем из проверки выплаты текущего аккредитива, т.к.
  // с ними работаем через сервис ввода, и там могут быть изменения, еще 
  // не отраженные в БД. Поэтому проверку выплат текущего аккредитива
  // делаем отдельно по сервису ввода (IsPaymentInCurrentLcdocObj)
  var SelectFrom : string = 
    "select pm.t_PaymentID "
    "  from dpmpaym_dbt pm ";

  var Where : string = 
    " where pm.t_BaseAmount = :ClaimAmount "
    "   and pm.t_Purpose = :Purpose "
    "   and not exists ( select 1   " +
    "                      from dlcpay_dbt lcp "
    "                     where lcp.t_LcdocID <> :CurLcdocID "
    "                       and lcp.t_PaymentID = pm.t_PaymentID ) "
    "   and pm.t_DocKind = :DL_IBCDOC "
    "   and pm.t_DocumentID = :LnkObjID "
    "   and pm.t_IsFactPaym = 'X' ";

  var rs : RsdRecordset = execSQLselectPrm
    ( SelectFrom + Where,
      SQLParam("ClaimAmount", RecLcpay.rec.ClaimAmount),
      SQLParam("Purpose", PM_PURP_LCCOMP),
      SQLParam("CurLcdocID", RecLcpay.rec.LcdocID),
      SQLParam("DL_IBCDOC", DL_IBCDOC),
      SQLParam("LnkObjID", DealID)
    );

  while(rs and rs.moveNext())
    if( not IsPaymentInCurrentLcdocObj(rs.value(0)) )
      PaymCount = PaymCount + 1;
      PaymentID = rs.value(0);
    end;
  end;

  if(PaymCount != 1)
    PaymentID = 0;
  end;

  return PaymentID;
end;

private macro GetPaymentID(RecLcpay : TRecHandler) : integer
  if(RecLcpay.rec.PaymentID > 0)
    return RecLcpay.rec.PaymentID;
  end;

  // Если в выплате не указан платеж lcdoc.PaymentID, попытаться найти его

  var PaymentID : integer = 0;
  var PaymCount : integer = 0;

  PaymentID = GetPmByLcpay(RecLcpay, @PaymCount);

  // Если найден 1 платеж, записать его в Lcpay.PaymentID
  if(PaymCount == 1)
    RecLcpay.rec.PaymentID = PaymentID;

    if( LCDocObj.Pays().Update(RecLcpay) != 0 )
      RunError("Ошибка при записи идентификатора платежа в выплату");
    end;
  else
    PaymentID = 0;
  end;

  return PaymentID;
end;

// Обрабатываем эту выплату на шаге?
macro NeedProcessLcpay_09_30(RecLcpay : TRecHandler) : bool
  if(RecLcpay.rec.State == LCPAY_COMPENSATION_STATUS_TOTRANSFER) // к перечислению
    return TRUE;
  end;

  return FALSE;
end;

private class (TLcpayPaymChecker) TPaymChecker(p_Pays : RsbLCPay)
  private var UnconfirmedPays : string = "";

  InitTLcpayPaymChecker(p_Pays);

  private var 
    OffBalanceAccounting : integer = LC_GetOffBalanceAccounting(),
    CreateDoc : bool = InList(OffBalanceAccounting, 1, 3),
    CreateGuaranty : bool = InList(OffBalanceAccounting, 2, 3);

  private macro NeedCheckPayment(RecLcpay : TRecHandler) : bool
    return NeedProcessLcpay_09_30(RecLcpay);
  end;

  private macro GetPaymentID(RecLcpay : TRecHandler) : integer
    return RecLcpay.rec.PaymentID;
  end;

  private macro GetPaymPurpose() : string
    return "по перечислению возмещения";
  end;

  private macro GetContinueCond() : string
    return "только после того, как возмещение будет перечислено";
  end;

  private macro PreCheck(PaymentID : integer) : integer
    // Проверить привязку платежа к выплате
    if(PaymentID <= 0)
      msgbox("Не определен платеж, на основании которого производится перечисление возмещения, по одной или нескольким выплатам. Выполнение шага невозможно");
      return 1;
    end;

    return 0;
  end;

  private macro ProcessFinishedPayment(RecLcpay : TRecHandler) : integer
    RecLcpay.rec.State = LCPAY_COMPENSATION_STATUS_TRANSFERRED; // возмещение перечислено
    if( LCDocObj.Pays().Update(RecLcpay) != 0 )
      msgbox("Ошибка при изменении статуса возмещения выплаты");
      return 1;
    end;

    var stat : integer = 0;
    if( CreateDoc )
      stat = CreateMultiDoc_NonBalance_ForLcpay(LCDocObj, RecLcpay);
      if(stat)
        return stat;
      end;
    end;

    if( CreateGuaranty )
      stat = CreateMultiDoc_Guaranty_ForLcpay(LCDocObj, RecLcpay);
      if(stat)
        return stat;
      end;
    end;

    return 0;
  end;

  private macro GetPaymInfo
  ( PaymentID : integer, 
    IsPlanPaym : @bool, 
    IsFactPaym : @bool, 
    PaymStatus : @integer
  )
    var rs = execSQLselect
      ( "select t_IsPlanPaym, t_IsFactPaym, t_PaymStatus "
        "  from dpmpaym_dbt "
        " where t_PaymentID = :PaymentID ",
        SQLParam("PaymentID", PaymentID)
      );

    if(rs and rs.moveNext())
      if( rs.value("t_IsPlanPaym") == "X" )
        IsPlanPaym = true;
      else
        IsPlanPaym = false;
      end;

      if( rs.value("t_IsFactPaym") == "X" )
        IsFactPaym = true;
      else
        IsFactPaym = false;
      end;

      PaymStatus = rs.value("t_PaymStatus");

    else
      RunError("Платеж, указанный в выплате, не найден в таблице платежей");
    end;
  end;

  private macro GetLnkPaymentID(PaymentID : integer) : integer
    var LnkPaymentID : integer = 0;
    
    var rs = execSQLselect
      ( "select pmpaym.t_PaymentID "
        "  from dpmlink_dbt pmlink, dpmpaym_dbt pmpaym "
        " where pmlink.t_InitialPayment = :PaymentID "
        "   and pmlink.t_LinkKind = " + PMLINK_KIND_KVITING +
        "   and pmpaym.t_PaymentID = pmlink.t_PurposePayment "
        "   and pmpaym.t_PrimDocKind = " + DOC_BO_PAYMENT,
        SQLParam( "PaymentID", PaymentID )
      );

    if(rs and rs.moveNext())
      LnkPaymentID = rs.value("t_PaymentID");
    end;

    return LnkPaymentID;
  end;

  private macro ExistsPmAccTrn(PaymentID : integer) : bool
    var rs = execSQLselect
    ( "select acctrn.t_AccTrnID "
      "  from dpmdocs_dbt pmdocs, dacctrn_dbt acctrn "
      " where pmdocs.t_PaymentID = :PaymentID "
      "   and acctrn.t_AccTrnID = pmdocs.t_AccTrnID "
      "   and acctrn.t_State = " + TRN_STATE_FACT,
      SQLParam( "PaymentID", PaymentID )
    );

    if(rs and rs.moveNext())
      return TRUE;
    end;

    return FALSE;
  end;

  private macro CheckPaymState(PaymentID : integer, RecLcpay : TRecHandler) : integer
    var IsPlanPaym : bool = false, IsFactPaym : bool = false,
        PaymStatus : integer = 0;
    GetPaymInfo(PaymentID, @IsPlanPaym, @IsFactPaym, @PaymStatus);

    if(IsPlanPaym)
      msgbox("Не завершена обработка платежа(ей) по перечислению возмещения, операция не может быть продолжена");
      return 1;
    end;

    if(IsFactPaym)
      var LnkPaymentID : integer = GetLnkPaymentID(PaymentID);

      if(LnkPaymentID > 0)
        // Вызываем родительский метод проверки состояния платежа
        return CheckPaymState(LnkPaymentID, RecLcpay);
      else
        if( ExistsPmAccTrn(PaymentID) )//!!!!!!
          return 0;
        elif(PaymStatus != PM_FINISHED)
          msgbox("Не завершена обработка платежа(ей) по перечислению возмещения, операция не может быть продолжена");
          return 1;
        else
          if(UnconfirmedPays)
            UnconfirmedPays = UnconfirmedPays + ", ";
          end;

          UnconfirmedPays = UnconfirmedPays + RecLcpay.rec.Trn;

          return 0;
        end;
      end;
    end;

    // Непредусмотренная ситуация
    msgbox("Не удалось выяснить состояние платежа");
    return 1;
  end;

  private macro HandleUnconfirmedPays : integer
    var ErrMsg : string = 
      "Для платежа(ей) по сделке МБК, указанного для выплаты (выплат) " + 
      UnconfirmedPays + 
      " отсутствует подтверждение исполнения (нет ни связанного платежа, ни связанной проводки). ";

    if(not IsOprMultiExec())
      if( GetTrue( false, ErrMsg + "|Продолжить обработку?" ) == false )
        return 1;
      end;
    else
      msgbox(ErrMsg + "Для продолжения операции подтвердите обработку выплат в индивидуальном режиме");
      return 1;
    end;

    return 0;
  end;

  macro Check() : integer
    // Вызываем родительский метод проверки
    var stat : integer = Check();

    if( not stat and (UnconfirmedPays != "") )
      stat = HandleUnconfirmedPays();
    end;

    return stat;
  end;
end;

private macro GetPmPayerAccount(PaymentID : integer) : string
  var query : string = 
    "select t_PayerAccount "
    "  from dpmpaym_dbt "
    " where t_PaymentID = :PaymentID ";

  var rs : RsdRecordset = execSQLselectPrm(query, SQLParam("PaymentID", PaymentID));
  if(rs and rs.moveNext())
    return rs.value(0);
  end;

  RunError("Не найден платеж с идентификатором " + PaymentID);
end;

private macro CheckPayerAccounts
  var TrnList : string = "";

  var RecLcpay : TRecHandler = TRecHandler("lcpay");
  var Pays : RsbLCPay = LCDocObj.Pays();
  var IsFoundPay : bool = ( LCDocObj.Pays().First(RecLcpay) == 0 );

  while(IsFoundPay)
    if( NeedProcessLcpay_09_30(RecLcpay) )
      var PmPayerAccount : string = GetPmPayerAccount(RecLcpay.rec.PaymentID);

      if(PmPayerAccount != LCDocObj.LCaccount)
        if(TrnList)
          TrnList = TrnList + ", ";
        end;

        TrnList = TrnList + RecLcpay.rec.Trn;
      end;
    end;

    IsFoundPay = ( LCDocObj.Pays().Next(RecLcpay) == 0 );
  end;

  if(TrnList)
    var ErrMsg : string = 
      "На основании платежа по перечислению возмещения для выплаты (выплат) " + 
      TrnList + " не было выполнено списание средств со счета требований " +
      LCDocObj.LcAccount + ". ";

    if(not IsOprMultiExec())
      if( GetTrue( false, ErrMsg + "|Продолжить обработку?" ) == false )
        RunError("Выполнение шага прервано пользователем");
      end;
    else
      RunError(ErrMsg + "Для продолжения операции подтвердите обработку выплат в индивидуальном режиме");
    end;
  end;
end;

MACRO ExecuteStep()
  var RecLcpay : TRecHandler = TRecHandler("lcpay"),
      PaymentID : integer = 0, 
      NeedPaymLinkManual : bool = false, 
      LcpayIDs : TArray = TArray(); // выплаты, обрабатываемые на текущем шаге операции

  // Привязать платежи к выплатам (где они еще не привязаны)
  var IsFoundPay : bool = ( LCDocObj.Pays().First(RecLcpay) == 0 );
  while(IsFoundPay)

    if( NeedProcessLcpay_09_30(RecLcpay) )
      LcpayIDs[ LcpayIDs.size ] = RecLcpay.rec.LcpayID;

      PaymentID = GetPaymentID(RecLcpay);

      if(PaymentID <= 0)
        if(not IsOprMultiExec())
          NeedPaymLinkManual = true;
        else
          msgbox("Не определен платеж, на основании которого производится перечисление возмещения, по одной или нескольким выплатам. Запустите шаг в индивидуальном режиме и выполните привязку платежей вручную");
          return 1;
        end;
      end;

    end;

    IsFoundPay = ( LCDocObj.Pays().Next(RecLcpay) == 0 );
  end;

  if(NeedPaymLinkManual)
    LcpayLinkPaymScrol(LCDocObj, LcpayIDs, LCPAY_PAYMENTS_SCR_MODE_WAIT_DEALMBK);
  end;

  // Проверить привязку, реквизиты и состояние платежей
  CheckPayerAccounts();
  var PaymChecker : TPaymChecker = TPaymChecker( LCDocObj.Pays() );
  if( PaymChecker.Check() != 0 )
    return 1;
  end;

  return 0;

OnError(er);
  MsgBox( RsbGetError(er) );
  return 1;
END;
