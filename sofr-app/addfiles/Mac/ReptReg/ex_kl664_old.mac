/*
$Name: ex_kl664_old.mac
$Module: Регламентируемая отчетность
$Description: Экспорт для формы 664
*/

/* ──────────────────────────────────────────────────────────────────────────┐
   RS-Bank 6.0                                      R-Style Software Lab Ltd
   Файл подсистемы "Регламентируемая отчетность"

   Экспорт значений переменных Формы 664 в текстовый файл для программы
   kliko.exe до введения в действие 1747-У

   CREATED : 15.07.2005 Лузгин

   MODIFICATIONS: 16.04.2007 Малахова
   NOTES: Переименовала из ex_kl664.mac в ex_kl664_old.mac

└────────────────────────────────────────────────────────────────────────── */

IMPORT logfile, lib_exp, com_f664, c_f664v1, c_f664v2, c_f664v3;

/* ------------------------------------------------------------------------ */
/*                             Настройки                                    */

CONST ДиректорияПротоколаРаботы   = ReturnDirString( "TEXTDIR", "TXTFILE" );
CONST ИмяПротоколаРаботы          = "ekli_f664.log";

/* ============================= Декларации =============================== */

/* ------------------------ Файлы, структуры, диалоги --------------------- */


FILE wrk () txt write;      // Файл экспорта
FILE tout () txt;           // Для вывода протокола

/* ------------------------- Переменные и константы ----------------------- */

CONST csBlock = "<F664";
VAR exponame;               // Имя файла экспорта
VAR errorvar;               // Ошибка чтения переменных
VAR count = 0;              // Счетчик экспортированных строк

/* ====================== Вывод строки в файл экспорта ==================== */
private
MACRO PrintExpString()
    var str = "";
    var param, i = 0;
    while( GetParm(i, param) )
        if( ValType(param) != V_STRING )
            param = string( param:0:3 );
        end;
        str = str + ",\"" + param + "\"";
        i = i + 1;
    end;
    str = SubStr( str, 2 );
    insert( wrk, str );
    count = count + 1;
END;


/* ================== Выгрузка данных по первому разделу ================== */
private
MACRO ExportSection1()

    message( "Чтение значений переменных 1-го раздела..." );
    errorvar = Variables1.LoadAll();
    message( "Экспорт переменных 1-го раздела..." );

/* ---------- Получение данных по существующим валютам -------------------- */

    var str, rs;

    var CurrArr = TArray;           // Массив ID существующих валют
    var CurrCodes = TArray;         // Массив кодов сущесвующих валют
    var CurrStr = TArray;           // Массив наименований существующих валют
    var i = 0;
    while( i < Variables1.Currs.size )
        if( Variables1.Currs[i] != NULL )
            CurrCodes[CurrArr.size] = Variables1.Currs[i];
            CurrArr[CurrArr.size] = i;
        end;
        i = i + 1;
    end;
  if( CurrArr.size > 0 )
    str = StrAssemble( CurrArr, "," );
    rs = SQL_ExecuteAndGetRs( "SELECT t_Name FROM dfininstr_dbt WHERE t_FIID IN (" + str + ") ORDER BY t_FIID" );
    i = 0;
    while( rs and rs.MoveNext() )
    CurrStr[i] = rs.Value(0);
    i = i + 1;
    end;
  end;

/* ---------- Цикл экспорта по видам счетов ------------------------------- */

    var kind_str, curr, code;
    var temp_0, temp_1, temp_2, CodeArr = TArray;
    var ind, kind = 0;                  // Инкрементные переменные
    str = csBlock + "1>";               // Формирование наименования блока (только для вида "ТР")
    while( kind < Variables1.Kinds.size )
        kind_str = Variables1.Kinds[kind];
        insert( wrk, str );
        str = csBlock + "1" + string(kind+2) + ">";
        rs = GetValidCodes( 1, kind_str );
        i = 0;
        CodeArr.size = 0;
        while( rs and rs.MoveNext() )
            CodeArr[i] = rs.Value(0);
            i = i + 1;
        end;
        ind = 0;                    // Индекс валюты (в массивах CurrArr, CurrCodes, CurrStr)
        while( ind < CurrArr.size )
            curr = CurrArr[ind];    // FIID валюты
            if( Variables1.GetName( kind, curr, 0 ) != NULL )
                ПрочитатьПеременную2( temp_0, temp_1, ДатаОтчета, ПредДатаОтчета, formID, Variables1.GetName( kind, curr, 0 ) );
                if( temp_1 == NULL )
                    temp_1 = 0.0;
                end;
            else temp_1 = 0.0;
            end;
            if( Variables1.GetName( kind, curr, 1 ) != NULL )
                ПрочитатьПеременную2( temp_0, temp_2, ДатаОтчета, ПредДатаОтчета, formID, Variables1.GetName( kind, curr, 1 ) );
                if( temp_2 == NULL )
                    temp_2 = 0.0;
                end;
            else temp_2 = 0.0;
            end;
            if( (temp_1 != 0) or (temp_2 != 0) or (Variables1.Get(kind, curr, 2, 0) != 0) or (Variables1.Get(kind, curr, 3, 0) != 0) )
                PrintExpString( kind_str, CurrCodes[ind], CurrStr[ind], "Всего", temp_1, temp_2,
                                Variables1.Get(kind, curr, 2, 0), Variables1.Get(kind, curr, 3, 0), "2","1","" );
                if( (temp_1 != 0) or (temp_2 != 0) )
                    i = 0;
                    while( i < CodeArr.size )
                        code = CodeArr[i];
                        temp_0 = FindVal( Variables1.Codes[0][kind], code );    // Находим индекс кода в соответствующем массиве,
                                                                                //  если нет - значение отрицательное, обнуляем
                        if (temp_0 < 0) temp_0 = 0.0; else temp_0 = Variables1.Get(kind, curr, 0, temp_0); end;
                        temp_1 = FindVal( Variables1.Codes[1][kind], code );
                        if (temp_1 < 0) temp_1 = 0.0; else temp_1 = Variables1.Get(kind, curr, 1, temp_1); end;
                        if( (temp_0 != 0) or (temp_1 != 0) )
                            PrintExpString( kind_str, "", "", code, temp_0, temp_1, "", "", "2", "0", "1" );
                        end;
                        i = i + 1;
                    end;
                end;
            end;
            ind = ind + 1;
        end;
        kind = kind + 1;
    end;

END;

/* ================== Выгрузка данных по второму разделу ================== */
private
MACRO ExportSection2()

    message( "Чтение значений переменных 2-го раздела..." );
    errorvar = Variables2.LoadAll();
    message( "Экспорт переменных 2-го раздела..." );

    var CodeArr = TArray;
    var rs = GetValidCodes( 2 );            // От вида не зависит, используем единый список кодов
    var i = 0;
    CodeArr.size = 0;
    while( rs and rs.MoveNext() )
        CodeArr[i] = rs.Value(0);
        i = i + 1;
    end;

/* ---------- Цикл экспорта по видам счетов ------------------------------- */

    var kind_str, code;
    var summa, temp_0, temp = TArray;
    var ind, type, kind = 0;                // Индексные переменные
    var str = csBlock + "2>";               // Формирование наименования блока (только для вида "БН")
    while( kind < Variables2.Kinds.size )
        kind_str = Variables2.Kinds[kind];
        insert( wrk, str );

        // Чтение переменных "Всего" и экспорт соответствующей строки, если есть ненулевые значения
        summa = 0;
        type = 0;
        while( type < Variables2.Types.size )
            ind = type * 2;
            ПрочитатьПеременную2( temp_0, temp[ind], ДатаОтчета, ПредДатаОтчета, formID, Variables2.GetName( kind, type, 0 ) );
            if( temp[ind] == NULL )
                temp[ind] = 0.0;
            end;
            if( summa == 0 )
                summa = summa + temp[ind];
            end;
            ind = ind + 1;
            ПрочитатьПеременную2( temp_0, temp[ind], ДатаОтчета, ПредДатаОтчета, formID, Variables2.GetName( kind, type, 1 ) );
            if( temp[ind] == NULL )
                temp[ind] = 0.0;
            end;
            if( summa == 0)
                summa = summa + temp[ind];
            end;
            type = type + 1;
        end;
        if (summa)
            str = "PrintExpString( kind_str, \"Всего\", temp[0]";
            ind = 1;
            while( ind < (Variables2.Types.size * 2) )
                str = str + ", temp[" + string(ind) + "]";
                ind = ind + 1;
            end;
            ExecExp( str + ", \"2\", \"1\", \"\" )" );
        end;

        // Экспорт строки остатков на начало отчетного периода, если есть ненулевые
        type = 0;
        while( type < Variables2.Types.size )
            temp[type] = Variables2.Get( kind, type, 2, 0 );
            type = type + 1;
        end;
        if( (temp[0] != 0) or (temp[1] != 0) or (temp[2] != 0) or (temp[3] != 0) or (temp[4] != 0) or (temp[5] != 0) )
            PrintExpString( kind_str, "Остатки на начало отч. периода", "",
                            temp[0], "", temp[1], "", temp[2], "", temp[3], "", temp[4], "", temp[5], "2", "2", "" );
        end;

        // Экспорт строки остатков на конец отчетного периода, если есть ненулевые
        type = 0;
        while( type < Variables2.Types.size )
            temp[type] = Variables2.Get( kind, type, 3, 0 );
            type = type + 1;
        end;
        if( (temp[0] != 0) or (temp[1] != 0) or (temp[2] != 0) or (temp[3] != 0) or (temp[4] != 0) or (temp[5] != 0) )
            PrintExpString( kind_str, "Остатки на конец отч. периода", "",
                            temp[0], "", temp[1], "", temp[2], "", temp[3], "", temp[4], "", temp[5], "2", "3", "" );
        end;

        // Экспорт расшифровок по кодам операций
        if (summa)
            i = 0;
            while( i < CodeArr.size )
                code = CodeArr[i];
                summa = 0;
                type = 0;
                while( type < Variables2.Types.size )
                    ind = type * 2;
                    temp[ind] = FindVal( Variables2.Codes[0][type], code ); // Находим индекс кода в соответствующем массиве,
                                                                            //  если нет - значение отрицательное, обнуляем
                    if (temp[ind] < 0) temp[ind] = 0.0; else temp[ind] = Variables2.Get(kind, type, 0, temp[ind]); end;
                    if( summa == 0)
                        summa = summa + temp[ind];
                    end;
                    ind = ind + 1;
                    temp[ind] = FindVal( Variables2.Codes[1][type], code );
                    if (temp[ind] < 0) temp[ind] = 0.0; else temp[ind] = Variables2.Get(kind, type, 1, temp[ind]); end;
                    if( summa == 0)
                        summa = summa + temp[ind];
                    end;
                    type = type + 1;
                end;
                if (summa)
                    str = "PrintExpString( kind_str, code, temp[0]";
                    ind = 1;
                    while( ind < (Variables2.Types.size * 2) )
                        str = str + ", temp[" + string(ind) + "]";
                        ind = ind + 1;
                    end;
                    ExecExp( str + ", \"2\", \"0\", \"3\" )" );
                end;
                i = i + 1;
            end;
        end;
        str = csBlock + "2" + string(kind+2) + ">"; // Наименование блока для kind != 0 (в текущих условиях только для "ЮФ")
        kind = kind + 1;
    end;

END;

/* ================== Выгрузка данных по третьему разделу ================== */
private
MACRO ExportSection3()

    message( "Чтение значений переменных 3-го раздела..." );
    errorvar = Variables3.LoadAll();
    message( "Экспорт переменных 3-го раздела..." );

    insert( wrk, csBlock + "3>" );

    var temp_SS, temp_SZ, temp_NS, temp_NZ; // временные переменные
    var rs, code, country = 1;              // ID стран в dcountry_dbt начинаются с единицы
    while( country < Variables3.Countries.size )
        if( Variables3.Countries[country][3] == 1 )
            PrintExpString( Variables3.Countries[country][0], Variables3.Countries[country][1], "", "", "", "", "", "2", "1", "" );
            rs = GetValidCodes( 3, Variables3.Countries[country][0] );
            while( rs and rs.MoveNext() )
                code = rs.Value(0);
                temp_SS = FindVal( Variables3.Codes[0][6], code );  // Находим индекс кода в соответствующем массиве,
                                                                    //  если нет - значение переменной отрицательное, обнуляем
                if (temp_SS < 0) temp_SS = 0.0; else temp_SS = Variables3.Get(country, 6, 0, temp_SS); end;
                temp_SZ = FindVal( Variables3.Codes[1][6], code );
                if (temp_SZ < 0) temp_SZ = 0.0; else temp_SZ = Variables3.Get(country, 6, 1, temp_SZ); end;
                temp_NS = FindVal( Variables3.Codes[0][5], code );
                if (temp_NS < 0) temp_NS = 0.0; else temp_NS = Variables3.Get(country, 5, 0, temp_NS); end;
                temp_NZ = FindVal( Variables3.Codes[1][5], code );
                if (temp_NZ < 0) temp_NZ = 0.0; else temp_NZ = Variables3.Get(country, 5, 1, temp_NZ); end;
                if( (temp_SS != 0) or (temp_SZ != 0) or (temp_NS != 0) or (temp_NZ != 0) )
                    PrintExpString( "", "", code, temp_SS, temp_SZ, temp_NS, temp_NZ, "2", "0", "1" );
                end;
            end;
        end;
        country = country + 1;
    end;

END;

/* ================== Процедура экспорта ================================== */
private
MACRO Export( )


    // В протокол
    printDebugString( string( date ) + " Экспорт переменных 664 формы ", TPS_TOPIC );
    printDebugString( "за " + ОтчетныйПериод( ) + ".", TPS_DETAILS );
    printDebugString( "Для использования в программе kliko.exe.", TPS_DETAILS );

    // Экспорт
    ExportSection1();
    ExportSection2();
    ExportSection3();

    printDebugString( "Экспорт завершен.", TPS_TOPIC );
    printDebugString( "Файл: " + exponame, TPS_DETAILS );
    printDebugString( "Выгружено строк: " + string( count ), TPS_MESSAGE );

END;


/* ============================= Точка входа ============================== */

if ( РасчетВКопейках )
    msgbox("Данные для экспорта в kliko.exe должны быть представлены в тысячах");
    exit(1);
end;

exponame = substr( string(ДатаОтчета:f), 1, 2 ) +
            substr( string(ДатаОтчета), 4, 2 ) +
            substr( string(ДатаОтчета), 7, 4 ) + ".664";

if( not GetExpFileName( exponame ) )
    exit(1);
end;

if( not open( wrk, exponame ) )
    msgBox("Невозможно открыть файл экспорта|" + exponame );
    exit(1);
end;
setOutput( ДиректорияПротоколаРаботы + ИмяПротоколаРаботы, FALSE);

Export();

close(wrk);
open( tout, setoutput( NULL, TRUE ) );
RepTxtFilesQueue().add(setoutput( NULL, TRUE ));
viewFile( tout );
exit(1);

/* EoF */