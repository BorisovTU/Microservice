/*
$Name:        calc_f634com.mac
$Module:      Регламентируемая отчетность
$Description: Общие классы
*/

/*─────────────────────────────────────────────────────────────────────────────────────────────────┐
  RS-Bank V6                                                                        R-Style Softlab
  Файл подсистемы "Регламентируемая отчетность"

  Расчет формы 634. Общее

  Создан: 25.07.2007 - ABP
└─────────────────────────────────────────────────────────────────────────────────────────────────*/

import com_f634;
import BankInter;

/**
 *  Константы
 */
const RATETYPE_CB = 7;

/**
 *  Ошибка вставки записи во временную таблицу
 */
private class (TException) TInsertTempTableException(tableName)
    initTException("Ошибка вставки записи во временную таблицу '" + tableName + "'");
end;

/**
 *  Объект, реализующий связь между временной таблицей и источником данных
 */
private class TDataMapper(tableName : String)
    private var m_tableName : String;

    macro addLink()
        throw(TPureVirtualMethodCallException("TDataMapper::addLink"));
    end;

    macro getMapper()
        throw(TPureVirtualMethodCallException("TDataMapper::getMapper"));
    end;

    private macro constructorTDataMapper(tableName : String)
        m_tableName = tableName;
    end;

    constructorTDataMapper(tableName);
end;

/**
 *  Объект, реализующий связь между временной таблицей и sql-запросом
 */
private class (TDataMapper) TDataMapperSql(tableName : String)
    private var m_fieldList : String;
    private var m_insertClause : String;
    private var m_selectClause : String;

    macro setDataSource(dataSource)
        m_insertClause = "INSERT INTO " + m_tableName + " (" + subStr(m_fieldList, 2) + ")"
                + "\n" + "SELECT " + subStr(m_selectClause, 2)
                + "\n" + "  FROM (" + dataSource.getDataSource() + ")";
    end;

    macro addLink(objectFieldName : String, tableFieldName : String)
        m_fieldList = m_fieldList + "," + tableFieldName;
        m_selectClause = m_selectClause + "," + tableFieldName;//objectFieldName;
    end;

    macro getMapper()
        return this;
    end;

    macro getClause()
        return m_insertClause;
    end;

    private macro constructorTDataMapperSql(tableName : String)
        initTDataMapper(tableName);

        m_insertClause = "";
        m_selectClause = "";
        m_fieldList = "";
    end;

    constructorTDataMapperSql(tableName);
end;

/**
 *  Объект, реализующий связь между временной таблицей и vox-объектом
 */
private class (TDataMapper) TDataMapperVox(tableName : String)
    private var m_container : Object;

    macro setDataSource(dataSource)
        // do nothing
    end;

    macro addLink(objectFieldName : String, tableFieldName : String)
        return m_container.addLink(objectFieldName, tableFieldName);
    end;

    macro getMapper()
        return m_container;
    end;

    private macro constructorTDataMapperVox(tableName : String)
        m_container = TRsVoxMapper(tableName);
    end;

    constructorTDataMapperVox(tableName);
end;

/**
 *  Временная таблица. Поддерживает методы для заполнения
 */
private class TTempTable(tableName : String, mapper : Object)
    private var m_tableName;

    private var m_inserter;
    private var m_inserterClause;
    private var m_inserterData;

    private var m_fieldsCount;
    private var m_fieldsList;

    private var m_mapper;

    private macro createMapper()
        var rs = RsdRecordset("SELECT * FROM " + m_tableName + " WHERE 0 = 1");

        rs.moveNext();

        var i  = 0;
        var n  = rs.fldCount;
        var fn = null;

        while (i < n)
            fn = strLwr(rs.fld(i).name);
            m_mapper.addLink(ternary(index(fn, "t_") == 1, substr(fn, 3), fn), fn);
            i = i + 1;
        end;
    end;

    macro saveObject(obj, mapper)
        obj.toTable(mapper);
        sql_execute("COMMIT");
    end;

    private macro getLength(dataArray)
        var maxLength = 0;
        var length = 0;

        if (valtype(dataArray[0]) != V_STRING)
            return null;
        end;

        for (var i, dataArray)
            length = strlen(i);
            if (length > maxLength)
                maxLength = length;
            end;
        end;

        return maxLength + 1;
    end;

    macro insert(dataSource : Object)
        if (m_mapper != null)
            saveObject(dataSource.object(), m_mapper.getMapper());
        else
            var i, j;
            var recordsCount;

            i = 0;
            while (i < m_fieldsCount)
                m_inserterData[i] = TArray(100, 100);
                i = i + 1;
            end;

            var dataset = dataSource.getDataSource();
            recordsCount = 0;
            while (dataset.next())
                j = 0;
                while (j < m_inserterData.size)
                    m_inserterData[j][recordsCount] = execExp("dataset." + m_fieldsList[j]);
                    j = j + 1;
                end;
                recordsCount = recordsCount + 1;
            end;

            if (recordsCount > 0)
                m_inserter = RsbSqlInsert(m_inserterClause, m_fieldsCount, recordsCount);

                i = 0;
                while (i < m_fieldsCount)
                    m_inserter.addParam(valType(m_inserterData[i][0]), m_inserterData[i], getLength(m_inserterData[i]));
                    i = i + 1;
                end;

                if (not m_inserter.insert())
                    throw(TInsertTempTableException());
                end;
            end;

            sql_execute("COMMIT");
        end;
    end;

    macro truncate()
        SQL_Truncate(m_tableName);
    end;

    macro getTableName()
        return m_tableName;
    end;

    private macro createInserter()
        var i;
        var fn;
        var rs;

        var valuesClause = "VALUES(";
        var inserterClause = "INSERT INTO " + m_tableName + " (";

        rs = RsdRecordset("SELECT * FROM " + m_tableName + " WHERE 0 = 1");
        rs.moveNext();

        m_fieldsCount = rs.fldCount;
        m_fieldsList = TArray(m_fieldsCount);

        i = 0;
        while (i < m_fieldsCount)
            fn = rs.fld(i).name;

            m_fieldsList[i] = fn;

            valuesClause = valuesClause + "?, ";
            inserterClause = inserterClause + fn + ", ";

            i  = i + 1;
        end;

        valuesClause = substr(valuesClause, 1, strlen(valuesClause) - 2) + ")";
        inserterClause = substr(inserterClause, 1, strlen(inserterClause) - 2) + ")";
        inserterClause = inserterClause + " " + valuesClause;

        m_inserterClause = inserterClause;
        m_inserterData = TArray(m_fieldsCount);
    end;

    private macro constructorTTempTable(tableName : String, mapper : Object)
        m_tableName = tableName;

        m_mapper = mapper;
        if (m_mapper != null)
            createMapper();
        else
            createInserter();
        end;
    end;

    constructorTTempTable(tableName, mapper);
end;

/**
 *  Временная таблица ГКБО
 */
class (TTempTable) TTempTableCb
    private macro constructorTTempTableCb()
        initTTempTable("df634cb_tmp", TDataMapperSql("df634cb_tmp"));
    end;

    constructorTTempTableCb();
end;

/**
 *  Временная таблица Loans
 */
class (TTempTable) TTempTableLn
    private macro constructorTTempTableLn()
//        initTTempTable("df634ln_tmp", TDataMapperVox("df634ln_tmp"));
//        initTTempTable("df634ln_tmp", TDataMapperSql("df634ln_tmp"));
        initTTempTable("df634ln_tmp");
    end;

    constructorTTempTableLn();
end;

/**
 *  Временная таблица счетов, учтенных при расчете по Loans
 */
class (TTempTable) TTempTableLnAccount
    private macro constructorTTempTableLnAccount()
//        initTTempTable("drcbBackOfficeAccount_tmp", TDataMapperVox("drcbBackOfficeAccount_tmp"));
        initTTempTable("drcbBackOfficeAccount_tmp", TDataMapperSql("drcbBackOfficeAccount_tmp"));
    end;

    constructorTTempTableLnAccount();
end;

/**
 *  Временная таблица по резервам МБК
 */
class (TTempTable) TTempTableMmdReserves
    private macro constructorTTempTableLnAccount()
        initTTempTable("df634MmdReserves_tmp", TDataMapperSql("df634MmdReserves_tmp"));
    end;

    constructorTTempTableLnAccount();
end;

/**
 *  Временная таблица по обеспечениям МБК
 */
class (TTempTable) TTempTableMmdGuarantee
    private macro constructorTTempTableLnAccount()
        initTTempTable("df634MmdGuaranty_tmp", TDataMapperSql("df634MmdGuaranty_tmp"));
    end;

    constructorTTempTableLnAccount();
end;

/**
 *  Источник данных, базовый (почти абстрактный) класс.
 */
class TDataSource(backOffice : Integer, parameters : TParameters)
    private const BACK_OFFICE = backOffice;
    private var m_parameters;

    macro getParameters()
        return m_parameters;
    end;

    macro getBackOffice()
        return BACK_OFFICE;
    end;

    macro getDataSource()
        throw(TPureVirtualMethodCallException("TDataSource::getDataSource"));
    end;

    macro moveNext()
        throw(TPureVirtualMethodCallException("TDataSource::moveNext"));
    end;

    private macro constructorTDataSource(parameters : TParameters)
        defaultParm(parameters, TParameters(RcbApplication().currentReport));

        m_parameters = parameters;
    end;

    constructorTDataSource(parameters);
end;

/**
 * Источник данных. Базовый класс, реализующий навигацию по ИД и сохранение данных во временную таблицу
 */
class (TDataSource) TDataSourceBase(backOffice : Integer, parameters : TParameters)
    private var m_container;
    private var m_reportDate;
    private var m_position;

    macro object()
        return this;
    end;

    macro toTable(mapper)
        mapper.setDataSource(this);
        sql_execute(mapper.getClause());
    end;

    macro getDataSource()
        return m_container[m_position];
    end;

    macro next()
        var result;

        m_position = m_position + 1;
        result = ternary(m_position < m_container.size, true, false);

        return result;
    end;

    macro moveNext()
        return next();
    end;

    private macro constructorTDataSourceBase(backOffice : Integer, parameters : TParameters)
        initTDataSource(backOffice, parameters);

        m_reportDate = parameters.getEndDate();
        m_position = -1;
        m_container = TArray();
    end;

    constructorTDataSourceBase(backOffice, parameters);
end;

/**
 *  Извлекатель данных
 */
class TDataExtractant(tempTable, dataSource)
    private var m_tempTable;
    private var m_dataSource;

    macro extract()
        while (m_dataSource.next())
            m_tempTable.insert(m_dataSource);
        end;
    end;

    private macro constructor(tempTable, dataSource)
        m_tempTable  = tempTable;
        m_dataSource = dataSource;

        m_tempTable.truncate();
    end;

    constructor(tempTable, dataSource);
end;
