/*───────────────────────────────────────────────────────────────────────────┐
  RS-Bank 5.00                                           R-Style Software Lab
  Файл подсистемы "Отчеты ЦБ"

  Печать формы 664 "Отчёт о валютных операциях, осуществляемых по банковским
  счетам клиентов в уполномоченных банках".

CREATED: 21.10.2004 Кац
MODIFICATIONS:  12.07.2005 Лузгин
        Печать третьего раздела формы
                15.07.2005 Лузгин
        Вынесение чаcти общих функций в com_f664 (например, для
            использования в процедуре экспорта
                
COMMENTS:   
└───────────────────────────────────────────────────────────────────────────*/

IMPORT ReptCbInter, param, com_f664, c_f664v1, c_f664v2, c_f664v3, treport;

private var Currs;          // имеющиеся валюты для 1 раздела
private var Section1Width;  // ширина 1-го раздела
private var Section3Width;                                      // ширина 3-го раздела
private const Section2Width = 17 + 1 + 6 * 2 * ( 16 + 1 ) + 1;  // ширина 2-го раздела
private const MaxHeaderWidth = 180;
private const MinHeaderWidth = 50;
private var HeaderWidth;

private var TableSect3 = CTableReport( 0, false, false );   // отчетная таблица для 3-го раздела

// Возвращает массив с непустыми валютами для 1-го раздела
private MACRO GetCurrsFor1Sect( )
    var arr = TArray;
    var i = 0;
    while( i < Variables1.Currs.size )
        if( Variables1.Currs[i] != NULL )
            arr[arr.size] = i;
        end;
        i = i + 1;
    end;

    return arr;
END;

// Вывод вида счёта 1 раздела
private MACRO Section1Kind( kind )
    var kindstr = Variables1.Kinds[kind];
    var flagEmpty = IsEmpty( 1, kindstr );
    var rs, currstr;
    println( Right( "┌───────────┬─────────────────────────┐", HeaderWidth ) );
    println( Right( "Вид счета │" + Center( kindstr, 11 ) + "│" + Center( flagEmpty, 25 ) + "│", HeaderWidth ) );
    println( Right( "└───────────┴─────────────────────────┘", HeaderWidth ) );
    println( Right( " обозначение признак отсутствия данных ", HeaderWidth ) );
    if( flagEmpty )
        return;
    end;

    println( );
    println( Right( "в тысячах единиц иностранной валюты", Section1Width ) );

    var curr;
    /* 1 */
    println( Left( "┌─────────────────┬", Section1Width - 1, "─" ), "┐" );
    /* 2 */
    println( "│Код вида операции│", Center( "Сумма операции", Section1Width - 20 ), "│" );
    /* 3 */
    print( "│                 ├" );
    curr = 0;
    while( curr < Currs.size )
        print( mkstr( "─", 2 * 16 + 1 ) );
        if( curr != Currs.size - 1 )
            print( "┬" );
        else
            println( "┤" );
        end;
        curr = curr + 1;
    end;
    /* 4 */
    print( "│                 │" );
    curr = 0;
    while( curr < Currs.size )
        rs = SQL_ExecuteAndGetRs( "SELECT t_FI_Code, t_Name FROM dfininstr_dbt WHERE t_FIID = " + Currs[curr] );
        rs.MoveNext( );
        currstr = rs.Value( "t_Name" ) + " (" + rs.Value( "t_FI_Code" ) + ")";
        print( Center( currstr, 2 * 16 + 1 ) );
        print( "│" );
        curr = curr + 1;
    end;
    println( );
    /* 5 */
    print( "│                 ├" );
    curr = 0;
    while( curr < Currs.size )
        print( mkstr( "─", 16 ), "┬", mkstr( "─", 16 ) );
        if( curr != Currs.size - 1 )
            print( "┼" );
        else
            println( "┤" );
        end;
        curr = curr + 1;
    end;
    /* 6 */
    print( "│                 │" );
    curr = 0;
    while( curr < Currs.size )
        print( "    списание    │   зачисление   │" );
        curr = curr + 1;
    end;
    println( );
    /* 7 */
    print( "├─────────────────┼" );
    curr = 0;
    while( curr < Currs.size )
        print( "────────────────┼────────────────" );
        if( curr != Currs.size - 1 )
            print( "┼" );
        else
            println( "┤" );
        end;
        curr = curr + 1;
    end;
    /* 8 */
    print( "│        1        │" );
    curr = 0;
    while( curr < Currs.size )
        print( Center( string( 2 * ( curr + 1 ) ), 16 ), "│" );
        print( Center( string( 2 * ( curr + 1 ) + 1 ), 16 ), "│" );
        curr = curr + 1;
    end;
    println( );
    /* Вывод строк кодов операций */
    // Здесь "знаем", что dir == 0 - это списание, а dir == 1 - зачисление. Иначе слишком сложно получается.
    var code0 = 0;      // индекс в Variables1.Codes[0][kind]
    var code1 = 0;      // индекс в Variables1.Codes[1][kind]
    var code0val = Variables1.Codes[0][kind][0];
    var code1val = Variables1.Codes[1][kind][0];
    var codeval;        // собственно значение текущего кода операции
    var varval;         // значение рассматриваемой переменной
    while( ( code0val != NULL ) or ( code1val != NULL ) )
        // минимум из не NULL значений
        codeval  = min( code0val, code1val );

        if( not IsEmpty( 1, kindstr, codeval ) )
            /* Разделительная строка */
            print( "├─────────────────┼" );
            curr = 0;
            while( curr < Currs.size )
                print( "────────────────┼────────────────" );
                if( curr != Currs.size - 1 )
                    print( "┼" );
                else
                    println( "┤" );
                end;
                curr = curr + 1;
            end;

            /* Основная строка */
            print( "│", Center( codeval, 17 ), "│" );
            curr = 0;
            while( curr < Currs.size )
                varval = Ternary( code0val == codeval, Variables1.Get( kind, Currs[curr], 0, code0 ) );
                print( Ternary( varval != NULL, varval, 0.0 ):16:3, "│" );
                varval = Ternary( code1val == codeval, Variables1.Get( kind, Currs[curr], 1, code1 ) );
                print( Ternary( varval != NULL, varval, 0.0 ):16:3, "│" );
                curr = curr + 1;
            end;
            println( );
        end;

        // Инициализация значений для след. итерации
        // Если вышли за границу, соотв. codeXval будет равно NULL
        if( code0val == codeval )
            code0 = code0 + 1;
            code0val = Ternary( code0 < Variables1.Codes[0][kind].size, Variables1.Codes[0][kind][code0] );
        end;
        if( code1val == codeval )
            code1 = code1 + 1;
            code1val = Ternary( code1 < Variables1.Codes[1][kind].size, Variables1.Codes[1][kind][code1] );
        end;
    end;

    /* Разделитель */
    print( "├─────────────────┼" );
    curr = 0;
    while( curr < Currs.size )
        print( "────────────────┼────────────────" );
        if( curr != Currs.size - 1 )
            print( "┼" );
        else
            println( "┤" );
        end;
        curr = curr + 1;
    end;

    /* Всего */
  if( kind != 5 )       // для вида счета "ФЛ" общих переменных нет (SCR 72106)
    print( "│Всего            │" );
    curr = 0;
    while( curr < Currs.size )
        // Эти переменные не были прочитаны, т.к. они вычисляемые,
        // и класс VariablesArray для них не предназначен, но GetName его потомка умеет.
        ПрочитатьПеременную2( code0val, varval, ДатаОтчета, ПредДатаОтчета, formID, Variables1.GetName( kind, Currs[curr], 0 ) );
        print( Ternary( varval != NULL, varval, 0.0 ):16:3, "│" );
        ПрочитатьПеременную2( code1val, varval, ДатаОтчета, ПредДатаОтчета, formID, Variables1.GetName( kind, Currs[curr], 1 ) );
        print( Ternary( varval != NULL, varval, 0.0 ):16:3, "│" );

        curr = curr + 1;
    end;
    println( );
  end;

    /* Остатки с разделителями */
    var moment = 0;
    while( moment < Variables1.Moments.size )
        /* Разделитель */
        print( "├─────────────────┼" );
        curr = 0;
        while( curr < Currs.size )
            print( "────────────────", Ternary( moment == 0, "┴", "─" ), "────────────────" );
            if( curr != Currs.size - 1 )
                print( "┼" );
            else
                println( "┤" );
            end;
            curr = curr + 1;
        end;
        /* Первая строка остатков */
        print( "│Остатки на ", Right( Variables1.MomentComments[moment], 6 ), "│" );
        curr = 0;
        while( curr < Currs.size )
            varval = Variables1.Get( kind, Currs[curr], Variables1.Dirs.size + moment, 0 );
            print( Ternary( varval != NULL, varval, 0.0 ):16:3, mkstr( " ", 16 + 1 ), "│" );
            curr = curr + 1;
        end;
        println( );
        /* Вторая строка остатков */
        print( "│отчетного периода│" );
        curr = 0;
        while( curr < Currs.size )
            print( mkstr( " ", 16 * 2 + 1 ), "│" );
            curr = curr + 1;
        end;
        println( );
        moment = moment + 1;
    end;
    /* Последняя строка */
    print( "└─────────────────┴" );
    curr = 0;
    while( curr < Currs.size )
        print( mkstr( "─", 16 * 2 + 1 ) );
        if( curr != Currs.size - 1 )
            print( "┴" );
        else
            println( "┘" );
        end;
        curr = curr + 1;
    end;
END;

// Вывод 1 раздела
private MACRO Section1( )
    println( Center( "Раздел I. Операции по банковским валютным счетам резидентов", HeaderWidth ) );
    var flagEmpty = IsEmpty( 1 );
    println( Right( "┌─────┐", HeaderWidth ) );
    println( Right( "Признак отсутствия данных по разделу I │" + Center( flagempty, 5 ) + "│", HeaderWidth ) );
    println( Right( "└─────┘", HeaderWidth ) );
    if( flagEmpty )
        return;
    end;

    var kind = 0;
    while( kind < Variables1.Kinds.size )
        Section1Kind( kind );
        kind = kind + 1;
    end;
END;

// Возвращает массив строк, состоящих из кодов операций.
// 1-ое измерение - по направлениям, второе - по типам.
private MACRO Section2CodesStrings( )
    var arr = TArray;
    var type;
    var dir = 0;
    while( dir < Variables2.Dirs.size )
        arr[dir] = TArray;
        type = 0;
        while( type < Variables2.Types.size )
            arr[dir][type] = StrAssemble( Variables2.Codes[dir][type], "|" );

            type = type + 1;
        end;

        dir = dir + 1;
    end;

    return arr;
END;

// Вывод вида счёта 2 раздела
private MACRO Section2Kind( kind )
    var kindstr = Variables2.Kinds[kind];
    var flagEmpty = IsEmpty( 2, kindstr );
    var rs, currstr;
    println( Right( "┌───────────┬─────────────────────────┐", HeaderWidth ) );
    println( Right( "Вид счета │" + Center( kindstr, 11 ) + "│" + Center( flagEmpty, 25 ) + "│", HeaderWidth ) );
    println( Right( "└───────────┴─────────────────────────┘", HeaderWidth ) );
    println( Right( " обозначение признак отсутствия данных ", HeaderWidth ) );
    if( flagEmpty )
        return;
    end;

    println( );
    println( Right( "в тысячах рублей", Section2Width ) );

    [┌─────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐];
    [│Код вида операции│                                                                                             Сумма операций                                                                                                │];
    [│                 ├─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────┤];
    [│                 │                                                                               по специальным банковским счетам нерезидентов                                             │по банковским счетам нерезидентов│];
    [│                 │                                                                                                                                                                         │  в валюте Российской Федерации, │];
    [│                 ├─────────────────────────────────┬─────────────────────────────────┬─────────────────────────────────┬─────────────────────────────────┬─────────────────────────────────┤    не являющимся специальными   │];
    [│                 │            Счет "С"             │            Счет "А"             │            Счет "О"             │           Счет "В1"             │           Счет "В2"             │        банковскими счетами      │];
    [│                 ├────────────────┬────────────────┼────────────────┬────────────────┼────────────────┬────────────────┼────────────────┬────────────────┼────────────────┬────────────────┼────────────────┬────────────────┤];
    [│                 │    списание    │   зачисление   │    списание    │   зачисление   │    списание    │   зачисление   │    списание    │   зачисление   │    списание    │   зачисление   │    списание    │   зачисление   │];
    [├─────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┤];
    [│       1         │        2       │        3       │        4       │        5       │        6       │        7       │        8       │        9       │       10       │       11       │       12       │       13       │];
    [├─────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┤];

    /* Вывод строк кодов операций */
    var rscodes = GetValidCodes( 2, kindstr );
    var codestrs = Section2CodesStrings( );
    var code;           // текущий код
    var arr = TArray;   // временный массив для конкретных данных для строки.
    var type;           // переменная цикла
    var temp;
    // !Здесь закладываемся на то, что порядок типов в Variables2.Types такой же, как в отчёте.
    while( rscodes and rscodes.MoveNext( ) )
        arr.size = 0;
        code = rscodes.Value( 0 );
        type = 0;
        while( type < Variables2.Types.size )
            temp = index( codestrs[0][type], code );
            if( temp > 0 )
                temp = Variables2.Get( kind, type, 0, temp / 6 );   // 6 - длина всех кодов + 1;
                arr[arr.size] = Ternary( temp != NULL, temp, 0.0 );
            else
                arr[arr.size] = 0.0;
            end;
            temp = index( codestrs[1][type], code );
            if( temp > 0 )
                temp = Variables2.Get( kind, type, 1, temp / 6 );   // 6 - длина всех кодов + 1;
                arr[arr.size] = Ternary( temp != NULL, temp, 0.0 );
            else
                arr[arr.size] = 0.0;
            end;

            type = type + 1;
        end;
        print( "│", Center( code, 17 ), "│" );
        type = 0;
        while( type < Variables2.Types.size )
            print( arr[type * 2]:16:3, "│", arr[type * 2 + 1]:16:3, "│" );
            type = type + 1;
        end;
        println( );
        [├─────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┼────────────────┤];
    end;

    /* Всего */
    print( "│Всего            │" );
    type = 0;
    while( type < Variables2.Types.size )
        // Эти переменные не были прочитаны, т.к. они вычисляемые,
        // и класс VariablesArray для них не предназначен, но GetName его потомка умеет.
        ПрочитатьПеременную2( temp, arr[0], ДатаОтчета, ПредДатаОтчета, formID, Variables2.GetName( kind, type, 0 ) );
        if( arr[0] == NULL )
            arr[0] = 0.0;
        end;
        ПрочитатьПеременную2( temp, arr[1], ДатаОтчета, ПредДатаОтчета, formID, Variables2.GetName( kind, type, 1 ) );
        if( arr[1] == NULL )
            arr[1] = 0.0;
        end;
        print( arr[0]:16:3, "│", arr[1]:16:3, "│" );

        type = type + 1;
    end;
    println( );
    /* Остатки с разделителями */
    var moment = 0;
    while( moment < Variables1.Moments.size )
        /* Разделитель */
        print( "├─────────────────┼" );
        type = 0;
        while( type < Variables2.Types.size )
            print( "────────────────", Ternary( moment == 0, "┴", "─" ), "────────────────" );
            if( type != Variables2.Types.size - 1 )
                print( "┼" );
            else
                println( "┤" );
            end;
            type = type + 1;
        end;
        /* Первая строка остатков */
        print( "│Остатки на ", Right( Variables1.MomentComments[moment], 6 ), "│" );
        type = 0;
        while( type < Variables2.Types.size )
            temp = Variables2.Get( kind, type, Variables2.Dirs.size + moment, 0 );
            print( Ternary( temp != NULL, temp, 0.0 ):16:3, mkstr( " ", 16 + 1 ), "│" );
            type = type + 1;
        end;
        println( );
        /* Вторая строка остатков */
        [│отчетного периода│                                 │                                 │                                 │                                 │                                 │                                 │];

        moment = moment + 1;
    end;
        [└─────────────────┴─────────────────────────────────┴─────────────────────────────────┴─────────────────────────────────┴─────────────────────────────────┴─────────────────────────────────┴─────────────────────────────────┘];
END;

// Вывод 2 раздела
private MACRO Section2( )
    println( Center( "Раздел II. Операции по банковским счетам нерезидентов в валюте Российской Федерации", HeaderWidth ) );
    var flagEmpty = IsEmpty( 2 );
    println( Right( "┌─────┐", HeaderWidth ) );
    println( Right( "Признак отсутствия данных по разделу II │" + Center( flagempty, 5 ) + "│", HeaderWidth ) );
    println( Right( "└─────┘", HeaderWidth ) );
    if( flagEmpty )
        return;
    end;

    var kind = 0;
    while( kind < Variables2.Kinds.size )
        Section2Kind( kind );
        kind = kind + 1;
    end;
END;

// Вывод 3 раздела.
private MACRO Section3( ) 
    if( IsEmpty( 3 ) ) return;
    end;

    TableSect3.AddColumn( "1", 5, AL_LEFT );        // Определение колонок таблицы
    TableSect3.AddColumn( "2", 13, AL_CENTER );
    TableSect3.AddColumn( "3", 41, AL_CENTER );
    TableSect3.AddColumn( "4", 17, AL_CENTER );
    TableSect3.AddColumn( "5", 24, AL_CENTER );
    TableSect3.AddColumn( "6", 24, AL_CENTER );
    TableSect3.AddColumn( "7", 24, AL_CENTER );
    TableSect3.AddColumn( "8", 24, AL_CENTER );
    Section3Width = TableSect3.GetSumLen( );
  if (U_1579)
    println( Center( "Раздел III. Структура операций, осуществляемых по банковским счетам нерезидентов в валюте Российской Федерации, по странам", HeaderWidth ) );
  else
    println( Center( "Раздел III. Структура операций между резидентами и нерезидентами, осуществляемых по", HeaderWidth ) );
    println( Center( "банковским счетам нерезидентов в валюте Российской Федерации, по странам", HeaderWidth ) );     
  end;
    println( );
    println( Right( "в тысячах рублей", Section3Width ) );
    [┌───────┬───────────────┬───────────────────────────────────────────┬───────────────────┬─────────────────────────────────────────────────────┬─────────────────────────────────────────────────────┐];
    [│ Номер │  Код страны   │          Наименование страны              │ Код вида операции │           Суммы операций по специальным             │ Суммы опрераций по банковским счетам нерезидентов,  │];
    [│  п/п  │ нерезидента - │                                           │                   │           банковским счетам нерезидентов            │   не являющимся специальными банковскими счетами    │];
    [│       │   владельца   │                                           │                   │                                                     │                                                     │];
    [│       │    счета      │                                           │                   │                                                     │                                                     │];
    [│       │               │                                           │                   ├──────────────────────────┬──────────────────────────┼──────────────────────────┬──────────────────────────┤];
  if (U_1579)
    [│       │               │                                           │                   │         Списано          │        Зачислено         │         Списано          │        Зачислено         │];
  else
    [│       │               │                                           │                   │Списано в пользу резидента│  Зачислено от резидента  │Списано в пользу резидента│  Зачислено от резидента  │];
  end;
    [├───────┼───────────────┼───────────────────────────────────────────┼───────────────────┼──────────────────────────┼──────────────────────────┼──────────────────────────┼──────────────────────────┤];
    [│   1   │       2       │                      3                    │         4         │            5             │            6             │            7             │            8             │];
    [├───────┼───────────────┼───────────────────────────────────────────┼───────────────────┼──────────────────────────┼──────────────────────────┼──────────────────────────┼──────────────────────────┤];
    
    var Ind_5, Ind_6, Ind_7, Ind_8;     // индексы кодов операций для соответствующих колонок
    var Val_5, Val_6, Val_7, Val_8;     // значения сумм для соответствующих колонок
    var rs, country, code, numstr, subnumstr;
    var j, i = 1, count = 1;                    // инкрементные перменные

    while( i < Variables3.Countries.size )
    if( Variables3.Countries[i][3] == 1 )
        numstr = string( count ) + ".";
        country = Variables3.Countries[i][0];
        TableSect3.PrintString( numstr, country, Variables3.Countries[i][1], "X", "X", "X", "X", "X" );
        TableSect3.PrintSeparator( );
        rs = GetValidCodes( 3, country );
        j = 1;
        while( rs and rs.MoveNext( ) )
        subnumstr = numstr + string( j ) + ".";
        code = rs.Value( 0 );
        Ind_5 = FindVal( Variables3.Codes[0][6], code );
        if (Ind_5 >= 0) 
            Val_5 = string( Variables3.Get( i, 6, 0, Ind_5 ):0:3 );
        else
            Val_5 = "0.000";
        end;
        Ind_6 = FindVal( Variables3.Codes[1][6], code );
        if (Ind_6 >= 0)
            Val_6 = string( Variables3.Get( i, 6, 1, Ind_6 ):0:3 );
        else
            Val_6 = "0.000";
        end;
        Ind_7 = FindVal( Variables3.Codes[0][5], code );
        if (Ind_7 >= 0)
            Val_7 = string( Variables3.Get( i, 5, 0, Ind_7 ):0:3 );
        else
            Val_7 = "0.000";
        end;
        Ind_8 = FindVal( Variables3.Codes[1][5], code );
        if (Ind_8 >= 0)
            Val_8 = string( Variables3.Get( i, 5, 1, Ind_8 ):0:3 );
        else
            Val_8 = "0.000";
        end;
        
        TableSect3.PrintString( subnumstr, "X", "X", code, Val_5, Val_6, Val_7, Val_8 );  
                TableSect3.PrintSeparator( );
        
        j = j + 1;
        end;

        count = count + 1;
    end; 

    i = i + 1;
    end;                 
    TableSect3.PrintBottom( );
    println( );
    println( ); 
END;

// Весь вывод
private MACRO Main( )
    if ( not ( {Название отчета} == "Форма 664" ) )
        msgbox( string( "Макрос реализован только для приложения \"", "Форма 664", "\"" ) );
        Exit( 1 );
    end;

    message( "Чтение значений переменных..." );
    var errorvars1 = Variables1.LoadAll( );
    var errorvars2 = Variables2.LoadAll( );
    var errorvars3 = Variables3.LoadAll( );
/* Похоже, это не непрочитанные переменные, а неинициализированные, но это не ошибка.
    if( ( errorvars1 != "" ) and ( errorvars2 != "" ) )
        errorvars1 = errorvars1 + ", ";
    end;
    var errorvars = errorvars1 + errorvars2;

    if( errorvars != "" )
        msgbox( "Не удалось прочесть значения переменных:|", errorvars );
    end;
*/

    message( "Печать..." );

    Currs = GetCurrsFor1Sect( );
    Section1Width = 19 + Currs.size * 2 * ( 16 + 1 );
    HeaderWidth = max( min( Section1Width, MaxHeaderWidth ), MinHeaderWidth );

    println( );
    println( Right( "Банковская отчетность ", HeaderWidth ) );
    println( Right( "┌───────────────┬───────────────────────────────────────────────────────────────┐", HeaderWidth ) );
    println( Right( "│      Код      │       Код кредитной организации (филиала)                     │", HeaderWidth ) );
    println( Right( "│   территории  ├─────────┬────────────────────────┬───────────────┬────────────┤", HeaderWidth ) );
    println( Right( "│    по ОКАТО   │ по ОКПО │основной государственный│Регистрационный│    БИК     │", HeaderWidth ) );
    println( Right( "│               │         │  регистрационный номер │    номер      │            │", HeaderWidth ) );
    println( Right( "├───────────────┼─────────┼────────────────────────┼───────────────┼────────────┤", HeaderWidth ) );
    println( Right( "│" + Center( Код_СОАТО, 15 ) + "│" + Center( Код_ОКПО, 9 ) + "│" + Center( ОГРН, 24 ) + "│" + Center( РегНомерБанка, 15 ) + "│" + Center( {MFO_Bank}, 12 ) + "│" , HeaderWidth ) );
    println( Right( "└───────────────┴─────────┴────────────────────────┴───────────────┴────────────┘", HeaderWidth ) );
    println( );
    println( Center( "ОТЧЕТ О ВАЛЮТНЫХ ОПЕРАЦИЯХ,", HeaderWidth ) );
    println( Center( "ОСУЩЕСТВЛЯЕМЫХ ПО БАНКОВСКИМ СЧЕТАМ КЛИЕНТОВ В УПОЛНОМОЧЕННЫХ БАНКАХ", HeaderWidth ) );
    println( );
    println( Center( "за " + ОтчетныйПериод( ), HeaderWidth ) );
    println( );
    println( "Наименование уполномоченного банка (его филиала)  " + {Name_Bank}:w );
    println( "Почтовый адрес  " + {Post_Addr}:l );
    println( );
    println( Right( "Код формы 0409664 ", HeaderWidth ) );
    println( Right( "Месячная ", HeaderWidth ) );
    var flagEmpty = IsEmpty( );
    println( Right( "┌─────┐", HeaderWidth ) );
    println( Right( "Признак отчета с нулевыми показателями│" + Center( flagEmpty, 5 ) + "│", HeaderWidth ) );
    println( Right( "└─────┘", HeaderWidth ) );

    if( not flagEmpty )
        Section1( );
        println( );
        println( );
        Section2( );
    println( );
        println( );
        Section3( );
    end;                

[                                                                                        ];
[   #                               ###################################    (Ф.И.О.)      ]( {Name_Boss}:l, {FIO_Boss}:l );
if( not U_1579 )
[   #                               ###################################    (Ф.И.О.)      ]( {Name_Book}:l, {FIO_Book}:l );
end;
[   М.П.];
[   Исполнитель                     ###################################    (Ф.И.О.)      ]( Исполнитель:l );
[   телефон:                        ###################################                  ]( Номер_телефона:l );
[   #г.                                                                                  ]( {curdate} );
END; /*Main*/

Main( );
