/******************************************************************************
    Библиотека классов и функций для работы с лицевым счетом
******************************************************************************/
IMPORT FIInter, CurrInter, CTInter, PTInter, globals, objconst, rcbconst, cb_sql,
       lib_arr, res_fun, res_calc;
IMPORT DepartmentFilter;

import param;

VAR  УчитыватьЧастичныйАрест;
GetRegistryValue( "REPTREG\\REP_GROUPS\\РАСШИФРОВКИ\\УЧИТЫВАТЬ ЧАСТИЧНЫЙ АРЕСТ",
                  V_BOOL, УчитыватьЧастичныйАрест, NULL );

/* Коды стран "из группы развитых" */
VAR СтраныИзГруппыРазвитых = "";
GetRegistryValue( "REPTREG\\REP_GROUPS\\MARKET_RISK\\СПИСОК СТРАН ИЗ ГРУППЫ РАЗВИТЫХ",
                   V_STRING, СтраныИзГруппыРазвитых, NULL );

CONST MIN_DOC_SUM = -99999999999999.99;

CONST Активна  = 1,
      Изменена = 2;

VAR iRealPlanNum = ПолучитьРеальныйНомерПлана( ЛогическийПланСчетов, "А");

VAR  ptkind   = TBFile( "ptkind.dbt" );

CONST _REGPT_CENTRALBANK = 45;
/*
    Вспомогательные константы для класса КСубъект.
*/

// Виды обеспечения - константы должны быть общими для всех БО, поэтому они здесь.
CONST ВО_НЕТ            = NULL;
CONST ВО_ДРУГОЕ         = 0;
CONST ВО_ПОРУЧИТЕЛЬСТВО = 1;
CONST ВО_ЦЕННЫЕ_БУМАГИ  = 2;
CONST ВО_ИМУЩЕСТВО      = 3;
CONST ВО_ГАРАНТИЯ       = 4;
CONST ВО_ТОВАРЫ         = 5;
CONST ВО_ДРАГ_МЕТАЛЛЫ   = 6;
CONST ВО_ДЕПОЗИТ        = 7;

/* Следующие массивы предназначены для вызова как функции (с параметром в круглых
   скобках). В дальнейшем они могут стать настоящими функциями.*/
CONST ГруппаРискаПоКлассуОбеспечения = ArrCreate( 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5 );
CONST ГруппаРискаПоКлассуЗаемщика    = ArrCreate( 2, 3, 3, 3, 3, 3, 4, 4, 5 );
CONST КоэффРискаПоГруппеРиска        = ArrCreate( 0.0, 0.0, 0.1, 0.2, 0.5, 1.0 );

/* Для 135 формы. Размещено здесь из-за тесной связи с предыдущим.
   Вообще, "классы" обеспечений и заемщиков введены исключительно ради 135 формы.
*/
CONST РасшифровкаПоКлассуОбеспечения = ArrCreate( 8973, 8917, 8975, 8976, 8976, 8913, 8959, 8974, 8978, 8978, 8945, 8945 );
CONST РасшифровкаПоКлассуЗаемщика    = ArrCreate( 8960, 8932, 8923, 8923 );
CONST ПринадлежностьЗаемщикаПоКлассу = ArrCreate( RCB_PTK_MINFIN, RCB_PTK_INSURANCE, RCB_PTK_STATE_BODY,
    RCB_PTK_STATE_BODY_SUBJECT, RCB_PTK_BANK, RCB_PTK_MBR, RCB_PTK_BANK, RCB_PTK_BANK );
CONST ВидОбеспеченияПоКлассу         = ArrCreate( ВО_ГАРАНТИЯ, ВО_ГАРАНТИЯ, ВО_ДРАГ_МЕТАЛЛЫ, ВО_ГАРАНТИЯ,
    ВО_ЦЕННЫЕ_БУМАГИ, ВО_ГАРАНТИЯ, ВО_ГАРАНТИЯ, ВО_ЦЕННЫЕ_БУМАГИ, ВО_ЦЕННЫЕ_БУМАГИ, ВО_ЦЕННЫЕ_БУМАГИ,
    ВО_ДЕПОЗИТ, ВО_ЦЕННЫЕ_БУМАГИ );
CONST ВидЭмитентаПоКлассуОбеспечения = ArrCreate( RCB_PTK_STATE_BODY, RCB_PTK_STATE_BODY, NULL, RCB_PTK_MBR, RCB_PTK_MBR,
    RCB_PTK_STATE_BODY_SUBJECT, RCB_PTK_BANK, RCB_PTK_STATE_BODY, RCB_PTK_STATE_BODY_SUBJECT, RCB_PTK_LOCAL_BODY );

/******************************************************************************
    Класс "Субъект"
*******************************************************************************/
CLASS КСубъект( )

    VAR /* свойства клиента из party.dbt */
     АНашБанк           = NULL,
     АФизЛицо           = NULL,
     АНерезидент        = NULL,
     АЗакрыт            = NULL,
     АНаименование      = NULL,
     АСуществует        = NULL,
     АОтозванаЛицензия  = NULL,
     АСтранаНерезидента = NULL,
     АРейтингAttrID     = NULL,
     АРейтингNumInList  = NULL,
     АГВЗAttrID         = NULL,
     АГВЗNumInList      = NULL,
     АГВЗ               = NULL

     ;

     private var    /* свойства, введённые для оптимизации*/
     АUniID_
     ;

    VAR /* вспомогательные свойства */
        ErrorStr = "";

    private VAR
        fininstr:TBFile,
        acc_R:TBFile,
        acc_V:TBFile,
        prt:TBFile,
        party:TBFile,
        objkdoc:TBFile,  /* виды рег. документов */
        objrgdoc:TBFile, /* данные о регистрации */
/*        partyreg:TBFile,*/ 
/*        dk_reg:TBFile,*/
        acc:TBFile;

    /************************************************************************
      Макросы, реализующие механизм получения данных по необходимости - для оптимизации
    ************************************************************************/
    private MACRO АUniID
        if( АUniID_ == NULL )
            АUniID_ = UniID( party, OBJTYPE_PARTY );
        end;
        return АUniID_;
    END;

    /************************************************************************
      Метод инициализации свойств субъекта
    ************************************************************************/
    MACRO Инициализация( НомерСубъекта )

        АСуществует = FALSE;
        АUniID_ = NULL;
        if( НомерСубъекта == {OurBank} )
          НомерСубъекта = {OurBank};
        end;
        /* читаем запись из БД */
        party.Rec.PartyID  = НомерСубъекта;
        АСуществует = party.GetEQ();
        if( АСуществует )
          /* Определяем все атрибуты */
          АФизЛицо      = ( party.Rec.LegalForm == 2 );
          АЗакрыт       = ( trim( party.Rec.Locked ) != "" );
          АНерезидент   = ( trim( party.Rec.NotResident ) != "" );
          АНаименование      = party.Rec.Name;
          АОтозванаЛицензия  = NULL;
          АСтранаНерезидента = NULL;
          АРейтингAttrID     = NULL;
          АРейтингNumInList  = NULL;
          АГВЗAttrID         = NULL;
          АГВЗNumInList      = NULL;
          АГВЗ               = NULL;

          if( НомерСубъекта == {OurBank})
              АНашБанк = true;
          else
              АНашБанк = false;
          end;
          /*04.10.2007 Malakhova 110424*/
          /*Историзация кодов*/
//          ErrorStr = String( "Субъект ", АНаименование, ", код ", ПолучитьКодСубъекта( party.Rec.PartyID, PTCK_CLIENT ) );
          ErrorStr = String( "Субъект ", АНаименование, ", код ", repGetPartyCode( party.Rec.PartyID, PTCK_CLIENT ) );
        else
          ErrorStr = String( "Субъект не найден" );
          /*ErrorStr = String( "Ошибка инициализации субъекта ID = ", НомерСубъекта );*/
        end;
        Return АСуществует;
    END;

    /************************************************************************
     Проверяет, имеет ли субъект указанное значение принадлежности  
    ************************************************************************/

    MACRO Является( Вид )
        if( ВидСубъекта( party.rec.PartyID, Вид, NULL ) )
          return true;
        else
          if ( Вид != 0 )
            ptkind.rec.PartyKind  = Вид;
            if( ptkind.GetEQ() )
              ErrorStr = String( ErrorStr, "Субъект не является ", ptkind.rec.Name);
            else
              ErrorStr = String( ErrorStr, "Субъект не имеет указанную принадлежность.");
            end;
          else
            ErrorStr = String( ErrorStr, "Принадлежность не задана");
          end;
          /*ErrorStr = String( ErrorStr, "Субъект не имеет принадлежность ", Вид );*/
          return false;
        end;
    END;
        
    /************************************************************************
     Метод определяет, отозвана ли у субъекта лицензия
     (как правило, такая проверка запускается только для банков) на дату 
    ************************************************************************/
    MACRO ОтозванаЛицензия(Дата)
      if( АЗакрыт ) /* Субъект закрыт */
        АОтозванаЛицензия = true;
        ErrorStr = String( ErrorStr, " Отозвана лицензия" );
        return true;
      else       
        objkdoc.rec.ObjectType = OBJTYPE_PARTY;      // key 1
        objkdoc.rec.Name = "Генеральная лицензия";
        if (not objkdoc.GetEQ())
          ErrorStr = String( ErrorStr, " Не найден вид документов регистрации ЦБ РФ \"Генеральная лицензия\"" );
          АОтозванаЛицензия = false;
          return false;
        end;

        objrgdoc.rec.ObjectType   = OBJTYPE_PARTY;    // key 1
        objrgdoc.rec.RegPartyKind = _REGPT_CENTRALBANK; /*ЦБ РФ*/
        objrgdoc.rec.RegDocKind   = objkdoc.rec.RegDocKind; /* вид документов регистрации ЦБ РФ Генеральная лицензия */
        objrgdoc.rec.ObjectID     = party.rec.PartyID;

        if (objrgdoc.GetEQ())
          if ((objrgdoc.rec.FinishDate != date(0,0,0)) and (objrgdoc.rec.FinishDate <= Дата))
            if (Дата == ДатаОтчета)
              АЗакрыт = true;
              АОтозванаЛицензия = true;
            end;
            ErrorStr = String( ErrorStr, " Отозвана лицензия" );
            return true;
          else
            if (Дата == ДатаОтчета)
              АОтозванаЛицензия = false;
              return false;
            end;
          end;
        else
          АОтозванаЛицензия = false;
          return false;
        end;
      end;
    END;

    /************************************************************************
      Метод получения кода страны нерезидента
    ************************************************************************/
    MACRO СтранаНерезидента( )
     АСтранаНерезидента = trim( party.rec.NRCountry );
     if( АНерезидент )
      if( АСтранаНерезидента == "" )
         ErrorStr = String( ErrorStr, " !ОШИБКА: Для нерезидента не указана страна" );
      end;
     else
      if( АСтранаНерезидента != "" )
         ErrorStr = String( ErrorStr, " !ВНИМАНИЕ: Не установлен признак нерезидента, задана страна нерезидента" );
      end;
     end;
     return АСтранаНерезидента;
    END; 

    /************************************************************************
      Метод возвращает значение инвестиционного рейтинга субъекта
      заданного типа на дату 
    ************************************************************************/
    MACRO Рейтинг(Дата, Тип) 
     var first, last,
         Minfirst  = 0,
         Minlast   = 0,
         NumInList = "",
         AttrBuff  = TRecHandler ( "objattr.dbt", "bank.def" ),
         ObjID     = АUniID;

      if ( ObjAttr_FindFirst( AttrBuff, OBJTYPE_PARTY, ObjId, OBJ_PARTY_GROUP_RATING ) == 0 )
        first = AttrBuff.Rec.AttrID / 100;
        last  = mod( AttrBuff.Rec.AttrID, 100 );
        Minfirst  = first;
        Minlast   = last;
        NumInList = AttrBuff.Rec.NumInList;
        while ( ObjAttr_FindNext(AttrBuff) == 0 )
          first = AttrBuff.Rec.AttrID / 100;
          last  = mod( AttrBuff.Rec.AttrID, 100 );
          if( ( last < Minlast ) or ( ( last == Minlast ) and ( first < Minfirst ) ) )
            Minfirst  = first;
            Minlast   = last;
            NumInList = AttrBuff.Rec.NumInList;
          end;
        end;
      end;
      ObjAttr_FindClose();

      if( Minfirst > 0 )
         АРейтингAttrID = int(Minfirst * 100 + Minlast);
         АРейтингNumInList = NumInList;
        if( Тип == AttrID )
         return АРейтингAttrID;
        else
         return АРейтингNumInList;
        end;
      else
        ErrorStr = String( ErrorStr, " Не указан рейтинг" );
        Return NULL;
      end;

    END;

    /************************************************************************
      Метод возвращает группу взаимосвязанных заемщиков заданного типа, к которой принадлежит
      субъект на дату . 
    ************************************************************************/
    MACRO ГВЗ(Дата, Тип)
      var l, Attr, NumInList;

        if( GetMainObjAttr( l, OBJTYPE_PARTY, АUniID,
                          OBJ_PARTY_GROUP_GVZ, Attr, NULL, NumInList,
                          Дата, NULL ) and ( l == 0 ))
          АГВЗAttrID = Attr;
          АГВЗNumInList = NumInList;
          АГВЗ = TRUE;
          if( Тип == AttrID )
           return АГВЗAttrID;
          else
           return АГВЗNumInList;
          end;
        else
          ErrorStr = String( ErrorStr, " Не входит в группу взаимосвязанных заемщиков." );
          АГВЗ = FALSE;
          return NULL;
        end;

    END;

    /************************************************************************
      Метод определяет, имеет ли субъект характер отношений с банком,
      установленный в параметре <"Характер отношений">. 
    ************************************************************************/
    MACRO ОтношенияСБанком( Character, Дата ) 
      var l;
      CheckObjAttrPresence( l, OBJTYPE_PARTY, АUniID,
                            OBJ_PARTY_GROUP_CHARACTER, null, "", Character);
      if ( l )
        return true;
      else
      /*  ErrorStr = String( ErrorStr, " Не установлен характер отношений с банком." );*/
        return false;
      end;

    END;

    /************************************************************************
      Метод возвращает долю уставного капитала субъекта, которая принадлежит
      нашему банку. Метод возвращает значение примечания "Доля в УК",
      действовавшее на дату.
    ************************************************************************/
    MACRO ДоляУК( Дата ) 
      var S, ДатаУстановки = NULL;
      S = readNoteForObject( OBJTYPE_PARTY, АUniID,
                             NOTEKIND_PART_UK, Дата, ДатаУстановки );
      if( ДатаУстановки == "" ) 
        ErrorStr = String( ErrorStr, " Не задана доля банка в Уставном капитале." );
      end;
      return S;

    END;

    /************************************************************************
      Метод возвращает долю уставного капитала субъекта, которая принадлежит
      нашему банку. Метод возвращает значение примечания "Доля в УК",
      действовавшее на дату.
    ************************************************************************/
    MACRO СобственныеСредства( Дата ) 
      var S, ДатаУстановки = NULL;
      S = readNoteForObject( OBJTYPE_PARTY, АUniID,
                             NOTEKIND_CAPITAL_215P, Дата, ДатаУстановки );
      if( ДатаУстановки == "" ) 
        ErrorStr = String( ErrorStr, " Не задано примечание \"Собственные средства (капитал) согл 215-П\"." );
      end;
      return S;

    END;

    /* Класс обеспечения - зависит от вида обеспечения и его эмитента.
       Метод размещён именно здесь, т.к. рез-т зависит от разных св-в эмитента.
       Метод должен вызываться для эмитента обеспечения.
       Метод предназначен для вызова напрямую только для 135 формы. Для остальных
       форм достаточно метода ГруппаРискаОбеспечения.
       Параметры - вид обеспечения (см. константы выше) и дата, за кот. берётся
       рейтинг эмитента (по умолчанию ДатаОтчета).
    */
    MACRO КлассОбеспечения( вид, дата )
        if( дата == NULL )
            дата = ДатаОтчета;
        end;

        var rating;
        if  ( вид == ВО_ГАРАНТИЯ )
            if( Является( RCB_PTK_MBR ) )
                return 3;
            end;
            if( АНерезидент )
                if( Является( RCB_PTK_STATE_BODY ) and ( index( СтраныИзГруппыРазвитых, СтранаНерезидента ) > 0 ) )
                    return 1;
                end;
                if( Является( RCB_PTK_BANK ) and ( index( СтраныИзГруппыРазвитых, СтранаНерезидента ) > 0 ) )
                    rating = Рейтинг( дата, AttrID );
                    if( ( rating != NULL ) and ( mod( rating, 100 ) <= 19 ) )
                        return 6;
                    end;
                end;
            else    // резидент
                if( Является( RCB_PTK_STATE_BODY ) )
                    return 0;
                end;
                if( Является( RCB_PTK_STATE_BODY_SUBJECT ) )
                    return 5;
                end;
            end;
        elif( вид == ВО_ЦЕННЫЕ_БУМАГИ )
            if( Является( RCB_PTK_MBR ) )
                return 4;
            end;
            if( not АНерезидент )
                if( Является( RCB_PTK_STATE_BODY ) )
                    return 7;
                end;
                if( Является( RCB_PTK_STATE_BODY_SUBJECT ) )
                    return 8;
                end;
                if( Является( RCB_PTK_LOCAL_BODY ) )
                    return 9;
                end;
            end;
            if( АНашБанк )
                return 11;
            end;
        elif( вид == ВО_ДРАГ_МЕТАЛЛЫ )
            return 2;
        elif( вид == ВО_ДЕПОЗИТ )
            return 10;
        end;

        // Любое другое обеспечение.
        return 12;
    END;

    /* Группа риска обеспечения по эмитенту и виду. Считается через КлассОбеспечения
       (см. описание выше).
       Для получения коэфф. риска для рез-та нужно вызвать КоэффРискаПоГруппеРиска.
    */
    MACRO ГруппаРискаОбеспечения( вид, дата )
        return ГруппаРискаПоКлассуОбеспечения( КлассОбеспечения( вид, дата ) );
    END;

    /*
       Метод предназначен для вызова напрямую только для 135 формы. Для остальных
       форм достаточно метода ГруппаРискаЗаемщика.
       Параметр - срок размещения средств (в днях или объект класса CPeriod).
    */
    MACRO КлассЗаемщика( срок )
        if( ValType( срок ) != V_INTEGER )  // CPeriod
            срок = срок.GetDays( );
        end;

        if( АНерезидент )
            if( index( СтраныИзГруппыРазвитых, СтранаНерезидента ) > 0 )
                if( Является( RCB_PTK_INSURANCE ) )
                    return 1;
                end;
                if( Является( RCB_PTK_BANK ) )
                    if( срок <= 90 )
                        return 4;
                    else
                        return 6;
                    end;
                end;
            end;
            if( Является( RCB_PTK_MBR ) )
                return 5;
            end;
        else    // резидент
            if( Является( RCB_PTK_MINFIN ) )
                return 0;
            end;
            if( Является( RCB_PTK_STATE_BODY ) )
                return 2;
            end;
            if( Является( RCB_PTK_STATE_BODY_SUBJECT ) )
                return 3;
            end;
            if( Является( RCB_PTK_BANK ) and ( срок <= 30 ) )
                return 7;
            end;
        end;

        return 8;   // все остальные
    END;
    
    /* Группа риска заемщика по заемщику и сроку. Считается через КлассЗаемщика
       (см. описание выше).
       Для получения коэфф. риска для рез-та нужно вызвать КоэффРискаПоГруппеРиска.
    */
    MACRO ГруппаРискаЗаемщика( срок )
        return ГруппаРискаПоКлассуЗаемщика( КлассЗаемщика( срок ) );
    END;

    // Код ОКАТО
    MACRO ОКАТО
        var NumInList, l_res;

        if( getMainObjAttr( l_res, OBJTYPE_PARTY, АUniID, RCB_OBJGROUP_PT_OKATO, NULL, NULL, NumInList )
            and ( NumInList != "" )
        )
            return NumInList;
        else
            return NULL;
        end;
    END;

    // Код ОКОНХ
    MACRO ОКОНХ
        var NumInList, l_res;

        if( getMainObjAttr( l_res, OBJTYPE_PARTY, АUniID, RCB_OBJGROUP_PT_OKONH, NULL, NULL, NumInList )
            and ( NumInList != "" )
        )
            return NumInList;
        else
            return NULL;
        end;
    END;

    // Код ОКВЭД
    MACRO ОКВЭД
        var code, l_res;

        if( getMainObjAttr( l_res, OBJTYPE_PARTY, АUniID, RCB_OBJGROUP_PT_OKVED, NULL, code )
            and ( code != "" )
        )
            return code;
        else
            return NULL;
        end;
    END;

    /************************************************************************
     Метод определяет, является ли субъект частным предпринимателем
    ************************************************************************/
    MACRO Предприниматель
        if( not АФизЛицо )
            return false;
        end;
        var persn = TBFile( "persn.dbt", "R", 0, "persn.dbt", "bank.def" );
        persn.Rec.PersonId = party.Rec.PartyId;
        if( persn.GetEQ( ) and ( trim( persn.Rec.IsEmployer ) != "" ) )
            return true;
        end;
        return false;
    END;

    /************************************************************************
      Конструктор класса
    ************************************************************************/
    party    = TBFile( "party.dbt",    "R", 0, "party.dbt",    "bank.def" );
/*    partyreg = TBFile( "partyreg.dbt", "R", 2, "partyreg.dbt", "bank.def" ); */
/*    dk_reg   = TBFile( "dk_reg.dbt",   "R", 1, "dk_reg.dbt",   "bank.def" ); */
    objrgdoc = TBFile( "objrgdoc.dbt", "R", 1, "objrgdoc.dbt", "bank.def" );
    objkdoc  = TBFile( "objkdoc.dbt",  "R", 1, "objkdoc.dbt",  "bank.def" );

    OnError( er )
    Exit( 1 );
END; /*CLASS Субъект*/

/******************************************************************************
    Класс "Финансовый инструмент"
*******************************************************************************/
CLASS КФинИнстр( )

    VAR /* свойства финансового инструмента из записи fininstr.dbt */
        АСуществует,
        АНаименование,
        АКод,
        АЭмитент = КСубъект();

    private VAR
        fininstr:TBFile;

    VAR /* вспомогательные свойства */
        ErrorStr = "";
    /************************************************************************
      Метод инициализации свойств финансового инструмента
    ************************************************************************/
    MACRO Инициализация( Код )

        АСуществует = FALSE;
        /* читаем запись из БД */
        fininstr.rec.FIID  = Код;
        АСуществует = fininstr.GetEQ();
        if( АСуществует )
          /* Определяем все атрибуты */
          АНаименование = fininstr.rec.Name;
          АКод          = Код;
          АЭмитент.Инициализация ( fininstr.rec.Issuer );
        else
          ErrorStr = String( "Финансовый инструмент не найден" );
          /*ErrorStr = String( "Ошибка инициализации финансового инструмента ID = ", Код );*/
        end;
        Return АСуществует;

    END;

    /************************************************************************
      Вид ценной бумаги
    ************************************************************************/
    MACRO АВид

        if( fininstr.rec.FI_Kind == /*RCB_FIKIND_ALLAVOIRISS*/ 2 )
          return fininstr.rec.AvoirKind;
        else
          return NULL;
        end;

    END;

    /************************************************************************
      Конструктор класса
    ************************************************************************/
    fininstr = TBFile( "fininstr.dbt", "R", 0, "fininstr.dbt", "bank.def" );
    OnError( er )
    Exit( 1 );
END; /*CLASS КФинИнстр*/
/*
VAR КП;
*/
/******************************************************************************
    Класс "Лицевой счет"
*******************************************************************************/
CLASS КЛицевойСчет( )
    
    VAR /* свойства счета из записи счета account.dbt */
        АНомерЛицевого      = "",
        АНомерСчетаПокрытия = "",
        АНомерБалансового,
        АДатаОткрытия,
        АОстаток = NULL,
        АГлава     = 1,
        АВалютаID  = 0,
        АВалютаISO = string({ISONatCur}),
        АВалютаВСчете = "810",
        АФинИнстр  = КФинИнстр(),
        АКлиент    = КСубъект(),
        АКлиентID  = 0,
        АСуществует,
        АДатаНачалаОп,
        АСрок,
        АВидСчета,
        ААрестДт;

    private VAR /*Свойства, которые вычисляются один раз и запоминаются - для оптимизации.
          Буква М (русская) в начале означает, что далее идёт имя соответствующего макроса.
          Буква Н (русская) в начале показывает, что это флаг; если он true - значит,
          запомненное значение переменной, начинающейся с М, равно NULL.
        */
        МДатаНачалаОп, НДатаНачалаОп,
        МСчетОбеспечения,   // это массив, поэтому NULL означает первое обращение
        МЗалогДляСчета,     // это массив, поэтому NULL означает первое обращение
        МСчетПроцентов,     // это массив, поэтому NULL означает первое обращение
        МПроцентыДляСчета,  // это массив, поэтому NULL означает первое обращение
        МПросроченоСоСчета, НПросроченоСоСчета,
        МОстатокСоСроком,   // это деньги, NULL быть не может
        АUniID_,
        МАрест_ДатаОтчета,  // это true/false, NULL быть не может
        МСуммаАреста,       // это деньги, NULL быть не может
        МДатаОбеспеч, МСтоимОбеспечРВП, МСтоимОбеспечРВПС   // роль флага играет дата
        ;

    VAR /* вспомогательные свойства */
        Type_Balance,       // может передаваться в Инициализация для оптимизации
        ErrorStr = ""/*,
        Nomes = TRUE*/;

    private VAR
        arhdocV   :TBFile,
        arhdocR   :TBFile,
        objlink   :TBFile,
        fininstr  :TBFile,
        balance   :TBFile,  // нужна только для ТипБалансового и только, когда не задан параметр  Инициализации
        acc_R     :TBFile,
        acc_V     :TBFile,
        prt       :TBFile,
        party     :TBFile,
        acc       :TBFile;
    
    // Из-за ошибки в RSL (#59738) приходится писать var вместо const
    private var rurID = 0;
    /*//05 Jun 07 Malakhova Irina 107762, 107763*/
    /*Перенесла выше описание флага, определяющего, создавался ли для текущего л/с объект ReserveCalculator */
    private var ReserveCalculatorFlag;

    // Обнуление вспомогательных данных.
    private MACRO SetAllNull( )
        МДатаНачалаОп = NULL;
        НДатаНачалаОп = NULL;
        МСчетОбеспечения = NULL;
        МЗалогДляСчета = NULL;
        МСчетПроцентов = NULL;
        МПроцентыДляСчета = NULL;
        МПросроченоСоСчета = NULL;
        НПросроченоСоСчета = NULL;
        МОстатокСоСроком = NULL;
        АUniID_ = NULL;
        МАрест_ДатаОтчета = NULL;
        МСуммаАреста = NULL;
        МДатаОбеспеч = NULL;
        МСтоимОбеспечРВП = NULL;
        МСтоимОбеспечРВПС = NULL;
        АФинИнстр = КФининстр();
        /*//05 Jun 07 Malakhova Irina 107762, 107763*/
        /*Добавила обнуление флага*/
        ReserveCalculatorFlag = NULL;
    END;
    
    /************************************************************************
      Макросы, реализующие механизм получения данных по необходимости - для оптимизации
    ************************************************************************/
    private MACRO АUniID
        if( АUniID_ == NULL )
            АUniID_ = UniID( acc, OBJTYPE_ACCOUNT );
        end;
        return АUniID_;
    END;

    /************************************************************************
     Метод, доступный в том числе вне сущности [КЛицевойСчет].
     Определяет существование лицевого счета по заданным параметрам и
     инициализирует  значения атрибутов. В теле метода определяются значения
     атрибутов [КЛицевойСчет]
     Последний параметр - тип балансового счёта - необязательный, служит для
     оптимизации (если он не задан, функция ТипБалансового лезет за данными
     в таблицу балансовых счетов, которая, кстати, ни за чем другим не нужна).
     !!! ВНИМАНИЕ! Есть ещё метод ИнициализацияАльтернативная (см. ниже)!
     ************************************************************************/
    MACRO Инициализация( Account, Balance, Chapter, _Type_Balance )
         /* Счет рублевого покрытия */
         MACRO IsRubCover( Сч )
           if (    ( index( Сч.Rec.Type_Account, "П" ) > 0 )
                or ( index( Сч.Rec.Type_Account, "Н" ) > 0 )
                or ( index( Сч.Rec.Type_Account, "М" ) > 0 )
              )
             return TRUE;
           end;

           return FALSE;
         END;

        var accountFilter;

        Type_Balance = _Type_Balance;   // неважно, NULL или нет
        ErrorStr = string( "Л/с ", Account:a );
       /* Название = "";*/
        АСуществует = FALSE;

        /* обрабатываем параметры метода */
        АНомерЛицевого = trim( Account );

        if( ValType( Chapter ) == V_UNDEF )
            АГлава = 1;
        else
            АГлава = Chapter;
        end;

        /* читаем счет из БД */
        if( АНомерЛицевого != "" )
            acc_R.Rec.Chapter       = АГлава;
            acc_R.Rec.Account       = АНомерЛицевого;
            АСуществует = acc_R.GetEQ();
            if ( АСуществует )
                /* Фильтрация по ТС/РС */
                accountFilter = RcbAccountFilter();
                if ( not accountFilter.IsSuitable( acc_R  ) )
                    АСуществует = FALSE;
                end;
            end;
        else
            АСуществует = FALSE;
        end;

        if( not АСуществует )  return false; end;

        if(IsRubCover( acc_R ) )
          acc_V.KeyNum = 7;
          acc_V.Rec.Connect_Chapter   = АГлава;
          acc_V.Rec.Connect_Currency  = 0;
          acc_V.Rec.Connect_Account   = АНомерЛицевого;
          if( not acc_V.GetEQ() )
            ErrorStr = String( ErrorStr," Не найден валютный счет для счета покрытия: ", Account );
            АСуществует = FALSE;
            return false;
          end;
          АНомерСчетаПокрытия = АНомерЛицевого;
          АНомерЛицевого      = acc_V.Rec.Account;
          acc                 = acc_V;
        else
          АНомерСчетаПокрытия = "";
          acc                 = acc_R;
        end;
        АВалютаID = acc.Rec.Code_Currency;
        АКлиентID = acc.Rec.Client;
        АВидСчета = acc.Rec.Kind_Account;
        АСрок     = acc.Rec.DaysToEnd;

        /* Системный тип "Арест на дебет"*/
        ААрестДт  = index( acc.Rec.Type_Account, "Т" ) > 0;

        АКлиент.Инициализация( acc.Rec.Client );
        if( ( valtype(Balance) != V_undef ) and ( trim(Balance) != "" ) )
         АНомерБалансового = Balance;
        else
         АНомерБалансового = acc.rec.Balance;
        end;
        if( АВалютаID != 0 )/* Не рубли */
         fininstr.KeyNum = 0;
         fininstr.Rec.FIID = АВалютаID;
         if( fininstr.GetEQ() )
          АВалютаISO = fininstr.Rec.FI_Code;
          АВалютаВСчете = fininstr.Rec.codeInAccount;
         else
           ErrorStr = String( ErrorStr," ошибка инициализации валюты ID ", АВалютаID );
         end;
        else
          АВалютаISO = string({ISONatCur});
          АВалютаВСчете = "810";
        end;
        АДатаОткрытия = acc.rec.Open_Date;
        if( acc.rec.OperationDate != date( 0, 0, 0 ) )
            АДатаНачалаОп = acc.Rec.OperationDate;
        end;

        ErrorStr = String(ErrorStr, " валюта ", АВалютаВСчете);

        // обнуление вспомогательных переменных
        SetAllNull( );

        Return АСуществует;
    END;

    /* Изначально метод Инициализация был выполнен не в соответствии ТЗ:
       в частности, в него никак нельзя передать валютный счёт.
       Нетривиальный вопрос к тому же, что делать со счетами покрытия:
       надо создавать класс для основного счёта или для счёта покрытия?
       Здесь в этом случае создаётся класс для счёта покрытия.

       Вероятно, пока следует оставить два метода инициализации.
    */
    MACRO ИнициализацияАльтернативная( account, currency, chapter )
        var accountFilter;

        ErrorStr = string( "Л/с ", Account:a );
        /* Название = "";*/
        АСуществует = FALSE;

        /* обрабатываем параметры метода */
        АНомерЛицевого = trim( account );

        if( chapter == null )
            chapter = 1;
        end;
        АГлава = chapter;

        if( currency == NULL )
            currency = rurID;
        end;
        АВалютаID = currency;
        
        if( currency == rurID )
            acc = acc_R;
        else
            acc = acc_V;
        end;
        
        /* читаем счет из БД */
        if( АНомерЛицевого != "" )
            acc.Rec.Chapter         = АГлава;
            acc.Rec.Account         = АНомерЛицевого;
            acc.Rec.Code_Currency   = АВалютаID;

            АСуществует = acc.GetEQ();
            if ( АСуществует )
                /* Фильтрация по ТС/РС */
                accountFilter = RcbAccountFilter();
                if ( not accountFilter.IsSuitable( acc ) )
                    АСуществует = FALSE;
                end;
            end;
        else
            АСуществует = FALSE;
        end;




        if( not АСуществует )  return false; end;

        if( АВалютаID != rurID )    // ищем счёт покрытия
            АНомерСчетаПокрытия = acc.Rec.Connect_Account;
        else
            АНомерСчетаПокрытия = "";
        end;

        АКлиентID = acc.Rec.Client;
        АВидСчета = acc.Rec.Kind_Account;
        АСрок     = acc.Rec.DaysToEnd;

        /* Системный тип "Арест на дебет"*/
        ААрестДт  = index( acc.Rec.Type_Account, "Т" ) > 0;

        АКлиент.Инициализация( acc.Rec.Client );

        /*!!! Вероятно, это неправильно! Номер балансового надо искать в таблице
              accblnc с учётом iRealPlanNum.
        */
        АНомерБалансового = acc.rec.Balance;

        if( АВалютаID != 0 )/* Не рубли */
            fininstr.KeyNum = 0;
            fininstr.Rec.FIID = АВалютаID;
            if( fininstr.GetEQ() )
                АВалютаISO = fininstr.Rec.FI_Code;
                АВалютаВСчете = fininstr.Rec.codeinAccount;
            else
                ErrorStr = String( ErrorStr," ошибка инициализации валюты ID ", АВалютаID );
            end;
        else
            АВалютаISO = string({ISONatCur});
            АВалютаВСчете = "810";
        end;
        АДатаОткрытия = acc.rec.Open_Date;
        if( acc.rec.OperationDate != date( 0, 0, 0 ) )
            АДатаНачалаОп = acc.Rec.OperationDate;
        end;

        ErrorStr = String(ErrorStr, " валюта ", АВалютаВСчете);

        // обнуление вспомогательных переменных
        SetAllNull( );
        Type_Balance = NULL;    // в методе Инициализация он задаётся, а здесь нет.

        Return АСуществует;
    END;
    
    /*************************************************************
     Метод определяет - был ли ЛС в состоянии "ОТКРЫТ"        
     на Дату1                                                   
     Если заданы Дата1 и Дата2, то проверяется был ли счет в    
     состоянии "ОТКРЫТ" (хотя бы один день) в течение периода   
     с Даты1 до Даты2 включительно                              
     Дата2 - необязательный параметр                            
     Условие: Дата2 >= Дата1                                    
    *************************************************************/
    MACRO Открыт( Дата1, Дата2)
       VAR
          ДатаОткрытия = acc.rec.Open_Date,
          ДатаЗакрытия = acc.rec.Close_Date;
     
       /* проверка на непротиворечивость дат в счете*/
       if ( (acc.rec.Open_Close != "") AND (ДатаЗакрытия < ДатаОткрытия) )
          ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Дата Закрытия счета МЕНЬШЕ Даты Открытия" );
          RETURN False;
       end;
       
       /* проверка состояния счета на дату и в течение периода*/
       if (ValType(Дата2) == V_UNDEF) /* Дата2 НЕ задана*/
          /* проверяем состояние счета на Дату*/
          if (ДатаОткрытия > Дата1) RETURN False; end;    /* счет был ОТКРЫТ ПОЗЖЕ  Даты1*/
          if (acc.rec.Open_Close != "") /* счет находится в списке закрытых*/
             if (ДатаЗакрытия <= Дата1) RETURN False; end; /* счет был ЗАКРЫТ РАНЬШЕ Даты1*/
          end;
       else  /* задан период Дата1 и Дата2*/
          /* проверяем состояние счета в течение периода с Даты1 по Дату2*/
          if (ДатаОткрытия > Дата2) RETURN False; end;    /* счет был ОТКРЫТ ПОЗЖЕ  Даты2*/
          if (acc.rec.Open_Close != "") /* счет находится в списке закрытых*/
             if (ДатаЗакрытия < Дата1) RETURN False; end; /* счет был ЗАКРЫТ РАНЬШЕ Даты1*/
          end;
       end;
       RETURN True;
    END;

    /************************************************************************
     Метод возвращает остаток лицевого счета за дату
    ************************************************************************/
    MACRO Остаток( Дата, Валюта )

     if( Валюта == 0 ) Валюта = NULL end;

     if( ValType( Валюта ) != V_Undef )
        АОстаток = restAC( АНомерЛицевого, Валюта, Дата, Null, АГлава ); 
     else
      if( АВалютаID != 0 ) /* Валютный счет */
        АОстаток = restA( АНомерСчетаПокрытия, Дата, Null, АГлава ); 
      else
        АОстаток = restA( АНомерЛицевого,      Дата, Null, АГлава ); 
      end;
     end;

     if(АВидСчета == "А")
        АОстаток = -АОстаток;
     end;

     return АОстаток;
    END;

    /************************************************************************
     Метод определяет, является ли счет арестованным на дату 
    ************************************************************************/
    MACRO Арест( Дата, Nomes )
      if( ( Дата == ДатаОтчета ) and ( МАрест_ДатаОтчета != NULL ) )
        return МАрест_ДатаОтчета;
      end;

      var S = $0;
      var data = TRsbDataSet("SELECT clst.T_CURRENTAMOUNT "+
                             " FROM  dacclaim_dbt cl, dacclaimstate_dbt clst "+
                             "WHERE  cl.T_CHAPTER=  " + АГлава +
                             "  AND  cl.T_ACCOUNT= '" + АНомерЛицевого + "'" +
                             "  AND  cl.T_FIID=     " + АВалютаID +
                             "  AND  cl.T_CLAIMKIND=" + ACCLAIM_KIND_ARREST +//Арест
                             "  AND  cl.T_RESTKIND=" + ACCLAIM_TYPE_AMOUNT +//На сумму
                             "  AND  clst.T_CLAIMID=cl.T_CLAIMID " +
                             "  AND  clst.T_STATEDATE=" + GetSQLDate(Дата) +
                             "  AND  (clst.T_STATE=" + Активна +
                             "     OR clst.T_STATE=" + Изменена + ")" //Активна или изменена
                            );
      if(data.MoveNext()) 
       S = data.T_CURRENTAMOUNT; 
       if((S == NULL)or(S >= Остаток(Дата)))
        ErrorStr = String( ErrorStr," Счет арестован полностью." );
       else
        ErrorStr = String( ErrorStr," Счет арестован частично." );
       end;
       return TRUE;
      else
       return FALSE;
      end;

    END;

    /************************************************************************
     Метод определяет величину суммы ареста по счету, определенную на дату 
    ************************************************************************/
    MACRO СуммаАреста( Дата )
      if( ( Дата == NULL ) and ( МСуммаАреста != NULL ) )
        return МСуммаАреста;
      end;

      var S = $0;
      var data = TRsbDataSet("SELECT clst.T_CURRENTAMOUNT "+
                             " FROM  dacclaim_dbt cl, dacclaimstate_dbt clst "+
                             "WHERE  cl.T_CHAPTER=  " + АГлава +
                             "  AND  cl.T_ACCOUNT= '" + АНомерЛицевого + "'" +
                             "  AND  cl.T_FIID=     " + АВалютаID +
                             "  AND  cl.T_CLAIMKIND=" + ACCLAIM_KIND_ARREST +//Арест
                             "  AND  cl.T_RESTKIND=" + ACCLAIM_TYPE_AMOUNT +//На сумму
                             "  AND  clst.T_CLAIMID=cl.T_CLAIMID " +
                             "  AND  clst.T_STATEDATE=" + GetSQLDate(Дата) +
                             "  AND  (clst.T_STATE=" + Активна +
                             "     OR clst.T_STATE=" + Изменена + ")" +//Активна или изменена
                             "  AND  clst.T_CURRENTAMOUNT IS NOT NULL" +
                             "  AND  clst.T_CURRENTAMOUNT<" + Остаток(Дата)
                            );
      if(data.MoveNext()) 
       S = data.T_CURRENTAMOUNT; 
       ErrorStr = String( ErrorStr," Счет арестован частично." );
      end;
      return S;
    END;

    /************************************************************************
     Метод возвращает дебетовые обороты лицевого счета за период
    ************************************************************************/
    MACRO Дебет( ДатаНачала, ДатаОкончания, Валюта )
     if( ValType( Валюта ) != V_Undef )
        return DebetAC( АНомерЛицевого, Валюта, ДатаНачала, ДатаОкончания, АГлава ); 
     else
      if( АВалютаID != 0 ) /* Валютный счет */
        return DebetA( АНомерСчетаПокрытия, ДатаНачала, ДатаОкончания, АГлава ); 
      else
        return DebetA( АНомерЛицевого, ДатаНачала, ДатаОкончания, АГлава ); 
      end;
     end;
    END;

    /************************************************************************
     Метод возвращает кредитовые обороты лицевого счета за период
    ************************************************************************/
    MACRO Кредит( ДатаНачала, ДатаОкончания, Валюта )
     if( ValType( Валюта ) != V_Undef )
        return KreditAC( АНомерЛицевого, Валюта, ДатаНачала, ДатаОкончания, АГлава ); 
     else
      if( АВалютаID != 0 ) /* Валютный счет */
        return KreditA( АНомерСчетаПокрытия, ДатаНачала, ДатаОкончания, АГлава ); 
      else
        return KreditA( АНомерЛицевого, ДатаНачала, ДатаОкончания, АГлава ); 
      end;
     end;
    END;
    /************************************************************************
     Метод определяет величину неснижаемого остатка по счету,
     определенную на дату
    ************************************************************************/
    MACRO ОстатокНесниж( Дата )
      var S = $0;
        S = readNoteForObject( OBJTYPE_ACCOUNT, АUniID,
                               NOTEKIND_REST_NOT_DOWN, Дата, NULL );
      return S;
    END;

    /************************************************************************
     Курс валюты p_id за дату p_date 
    ************************************************************************/
   MACRO CurrRate( p_id, p_date )
      RECORD _rec( ratedef );

      if( ПолучитьКурс( _rec, 0, p_id ) != 0 )
        return 0;
      end;

      if( ПолучитьЗначениеКурса( _rec, p_date ) != 0 )
        return 0;
      end;
      return ( _rec.Rate /( _rec.Scale * int( pow( 10, _rec.Point ) ) ) );
    END;

    /************************************************************************
     Метод определяет величину рыночной стоимость для учитываемых на счете
     средств, заданную на дату 
    ************************************************************************/
    MACRO РынСтоимость( Дата )
      var S = $0, Курс, ДатаУстановки;
        S = readNoteForObject( OBJTYPE_ACCOUNT, АUniID,
                               NOTEKIND_CURR_MARKET_COST, Дата, ДатаУстановки );
      if( ( ДатаУстановки != "" ) and ( S != $0 ) )

       if( АВалютаID != 0 ) /* Валютный счет */
        Курс = CurrRate( АВалютаID, ДатаОтчета );
        ErrorStr = String( ErrorStr," Текущая рыночная стоимость = ", S, " пересчитана по курсу ", Курс );
        S = S * Курс;
       end;
      else
       S = Остаток(Дата);
       ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не указана текущая рыночная стоимость. Для расчета взят остаток." );
      end;

      return S;
    END;

    MACRO ТипБалансового( Тип )
     var rs;
     /* Этот if - для случая, когда в Инициализацию не передан этот параметр.*/
     if( Type_Balance == NULL )
        rs = SQL_ExecuteSimple( balance, "t_Type_Balance",
                "t_Chapter = " + АГлава + " and t_iNumPlan = " + iRealPlanNum
                + " and t_Balance = '" + АНомерБалансового + "'" );
        if( rs and rs.MoveNext( ) ) 
            Type_Balance = rs.Value( 0 );
        else    // ошибка!!!
            return NULL;
        end;
     end;
     return index( Type_Balance, Тип ) > 0;
    END;

    /************************************************************************
     Метод определяет, является ли лицевой счет счетом по учету средств
     физических лиц 
    ************************************************************************/
    MACRO СчетФизЛица()
     if(ТипБалансового( Тип_Физ_Лица ) )
       if( not АКлиент.АФизЛицо )
        ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Указан Бал.счет физ.лица. Клиент не является физ.лицом." );
       end;
       return true;
     elif( АКлиент.АФизЛицо )
       return true;
     end;

     ErrorStr = String( ErrorStr,"  На счете не учитываются срества физ.лиц." );
     return false;
    END;
    
    /************************************************************************
     Метод определяет, является ли лицевой счет счетом по учету средств
     нерезидентов
    ************************************************************************/
    MACRO СчетНерезидента()
     if(ТипБалансового( Тип_Нерез ) )
       if( not АКлиент.АНерезидент )
        ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Указан Бал.счет нерезидента. Клиент не является нерезидентом." );
       end;
       return "X";
     elif( АКлиент.АНерезидент )
       return "X";
     end;
     ErrorStr = String( ErrorStr," Клиент не является нерезидентом." );
     return "";
    END;

    /************************************************************************
     Метод определяет финансовый инструмент, для которого открыт КЛицевойСчет.
     Возвращает значение типа [КФинИнстр]
    ************************************************************************/
    MACRO ФинИнстр()
     var l, id,
         FinBuff = TRecHandler ( "fininstr.dbt", "bank.def" );

     // Чтобы только один раз это делать
     if( АФининстр.АСуществует == NULL )    // после Инициализации либо true, либо false, но не NULL
         l = GetLinkedObject( OBJROLE_FININSTR, OBJTYPE_ACCOUNT, АUniID,
                          OBJTYPE_AVOIRISS, FinBuff, NULL );
         if( l != 0 )
           ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не найдено значение связанного объекта \"Финансовый инструмент\"." );
           return NULL;
         end;

         id = FinBuff.Rec.FIID;
         АФинИнстр.Инициализация( id );
     else
        id = АФинИнстр.АКод;
     end;

     if( not АФининстр.АСуществует )
          if( id == NULL ) id = ""; end;
          ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не найдено значение связанного объекта \"Финансовый инструмент\" ID ",id );
          return NULL;
     end;
     return АФинИнстр;
    END;

    MACRO ПолучитьСвязанныйОбъект( OBJROLE, Строка1, Строка2 )
     var l, aR,
         AccBuff = TRecHandler ( "account.dbt", "bank.def" );

      l = GetLinkedObject( OBJROLE, OBJTYPE_ACCOUNT, АUniID,
                           OBJTYPE_ACCOUNT, AccBuff, NULL );
      if( l == 0 )
         aR = КЛицевойСчет;
         if( not aR.Инициализация(AccBuff.rec.Account, AccBuff.rec.Balance, AccBuff.rec.Chapter)
            )
          ErrorStr = String( ErrorStr, Строка2 );
          return NULL;
         end;
         ErrorStr = String( ErrorStr, Строка1 );
         return aR;
      else
          ErrorStr = String( ErrorStr, Строка2 );
          return NULL;
      end;
    END;

    /************************************************************************
     Метод определяет лицевой счет резерва, для КЛицевойСчет.
     Возвращает значение типа [КЛицевойСчет].
    ************************************************************************/
    MACRO СчетРезерва( )
        var res = КЛицевойСчет;
        var acc = GetAccCaseReserveAccount( АГлава, АВалютаID, АНомерЛицевого );
        // По умолчанию: всегда рублёвый и по 1 главе
        if( ( acc == NULL ) or not res.Инициализация( acc ) )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не найдено значение категории учета \"Резерв, л/с\" или значение связанного объекта \"Счет резерва\".";
            return NULL;
        end;
        return res;
    END;

    /************************************************************************
     Метод определяет лицевой счет амортизации, для КЛицевойСчет.
     Возвращает значение типа [КЛицевойСчет].
    ************************************************************************/
    MACRO СчетАмортизации()
     return ПолучитьСвязанныйОбъект( OBJROLE_ACC_AMORTIZ, "", " !ВНИМАНИЕ: Сообщение_ИнформацияОСчете. Не указан связанный объект \"Счет амортизации\"." );
    END;

    /* Сумма амортизации по счёту.*/
    MACRO СумАморт( дата )
        var amacc = СчетАмортизации();
        if( amacc == NULL )
            // сообщение об ошибке выводится в функции СчетАмортизации
            return $0;
        end;
        return amacc.Остаток( дата );
    END;

    /************************************************************************
     Метод определяет группу риска, заданную для КЛицевойСчет на дату 
    ************************************************************************/
    MACRO ГруппаРиска( Дата, Nomes )
     var l, GrRisk, ДатаУстановки;

      if( GetMainObjAttr( l, OBJTYPE_ACCOUNT, АUniID,
                          OBJ_ACCOUNT_GROUP_RISK, NULL, NULL, GrRisk, Дата, NULL )
                          and ( l == 0 ))
        return GrRisk;
      else
            ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Для счета не задана группа риска." );
          return NULL;
      end;
    END;

    /************************************************************************
     Метод определяет основание повышения ККС 
    ************************************************************************/
    MACRO ОснованиеПовышенияККС ( )
      if( CheckObjAttrPresence( NULL, OBJTYPE_ACCOUNT, АUniID,
                          OBJ_ACCOUNT_GROUP_REP, NULL, "", "3.10" ) )
        return "3.10";
      elif( CheckObjAttrPresence( NULL, OBJTYPE_ACCOUNT, АUniID,
                          OBJ_ACCOUNT_GROUP_REP, NULL, "", "3.14.3" ) )
        return "3.14.3";
      else
        return "";
      end;
    END;

    // Группа риска для счёта по оффшору
    /* Считаем, что вызывается она только для нерезидентов с заданной страной нерезидента.*/
    MACRO ГруппаРискаОФШ( дата )
        дата = string( "'", дата:f, "'" );
        var country = "'" + АКлиент.СтранаНерезидента( ) + "'";
        var rs = SQL_ExecuteSimple( "dcountry_dbt c, dofshhist_dbt ofh", "t_OffshoreGroup",
                 "c.t_CodeLat3 = " + country
               + " and c.t_CountryID = ofh.t_CountryID"
               + " and ofh.t_DateStart >= " + дата
               + " and (ofh.t_DateFinish <= " + дата + " or ofh.t_DateFinish < ofh.t_DateStart )"
               );
        if( rs and rs.MoveNext( ) )
            return rs.Value( 0 );
        end;
        return NULL;
    END;
    
    /************************************************************************
     Метод определяет процент РВП, заданный для КЛицевойСчет на дату 
    ************************************************************************/
    MACRO ПроцентРезерваРВП( дата )
        var res = GetProcentOfReserve( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( res != NULL )
            return res;
        end;

        ErrorStr = ErrorStr + " !ВНИМАНИЕ: Не задан процент резерва для счета.";
        var rgroup = ГруппаРиска( дата );
        if( rgroup == NULL )
            return NULL;
        end;
        res = GetMinReserveProcent( rgroup );
        if( res == NULL )
            ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не задан минимальный процент РВП для ", rgroup, " группы риска." );
            return NULL;
        end;
        ErrorStr = ErrorStr + " Взят min для группы риска.";
        return res;
    END;

    /************************************************************************
     Метод определяет процент РВПС, заданный для КЛицевойСчет на дату 
    ************************************************************************/
    MACRO ПроцентРезерваРВПС( дата )
        var res = GetProcentOfReserve( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( res != NULL )
            return res;
        end;

        ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не задан процент резерва для счета." );
        var rgroup = ГруппаРиска( дата );
        if( rgroup == NULL )
            return NULL;
        end;
        res = GetMinReserveProcentLoans( rgroup );
        if( res == NULL )
            ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не задан минимальный процент РВПС для ", rgroup, " группы риска." );
            return NULL;
        end;
        ErrorStr = ErrorStr + " Взят min для группы риска.";
        return res;
    END;

    /************************************************************************
     Метод определяет процент резерва по оффшору, заданный для КЛицевойСчет на дату 
    ************************************************************************/
    MACRO ПроцентРезерваОФШ( Дата )
        var res = GetProcentOfReserveOffshore( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( res != NULL )
            return res;
        end;

        ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не задан процент резерва по оффшору для счета." );
        var rgroup = ГруппаРискаОФШ( дата );
        if( rgroup == NULL )
            return NULL;
        end;
        res = GetMinReserveProcentOffshore( rgroup );
        if( res == NULL )
            ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Не задан минимальный процент РОФШ для ", rgroup, " группы риска." );
            return NULL;
        end;
        ErrorStr = ErrorStr + " Взят min для группы риска.";
        return res;
    END;

    /************************************************************************
     Метод определяет набор лицевых счетов обеспечения, для КЛицевойСчет.
     Возвращает массив значений типа [КЛицевойСчет] 
    ************************************************************************/
    MACRO СчетОбеспечения() 
     VAR l, i = 0,
         AccBuff = TRecHandler ( "account.dbt", "bank.def" );
     if( МСчетОбеспечения == NULL )
         МСчетОбеспечения = TArray;
         while( i < 10 )
            l = GetLinkedObject( OBJROLE_ACC_SECURITY + i, OBJTYPE_ACCOUNT, АUniID,
                             OBJTYPE_ACCOUNT, AccBuff, NULL );
            if( l == 0 )
                МСчетОбеспечения( МСчетОбеспечения.size ) = КЛицевойСчет;
                if( not МСчетОбеспечения( МСчетОбеспечения.size - 1 ).Инициализация( AccBuff.Rec.Account, AccBuff.Rec.Balance, AccBuff.Rec.Chapter ) )
                    МСчетОбеспечения.size = МСчетОбеспечения.size - 1;
                else
                    ErrorStr = String( ErrorStr," Л/с ", МСчетОбеспечения( МСчетОбеспечения.size - 1 ).АНомерЛицевого, " указан как обеспечение." );
                end;
            end;
            i = i + 1;
        end;
     end;
     if( МСчетОбеспечения.size == 0 )
       ErrorStr = String( ErrorStr," !ОШИБКА: Не найдено значение связанного объекта \"Счет обеспечения\"." );
       return NULL;
     else
       return МСчетОбеспечения;
     end;
    END;

    /************************************************************************
     Метод определяет лицевой счет залога, для КЛицевойСчет 
    ************************************************************************/
    MACRO СчетЗалога()
     return ПолучитьСвязанныйОбъект( OBJROLE_ACC_GUARANTEE, " Средства на счете находятся в залоге.", "" );
    END;
      
    /************************************************************************
     Метод определяет лицевые счета, для которых КЛицевойСчет указан как счет
     залога. Возвращает массив значений типа [КЛицевойСчет]. 
    ************************************************************************/
    MACRO ЗалогДляСчета()
        VAR l, rs,
            AccBuff = TRecHandler ( "account.dbt", "bank.def" );

        if( МЗалогДляСчета == NULL )
            МЗалогДляСчета = TArray;

            rs = SQL_ExecuteSimple( objlink, "t_ObjectID",
                     "t_ObjectType = " + OBJTYPE_ACCOUNT
                   + " and t_GroupID = " + OBJROLE_ACC_GUARANTEE
                   + " and t_AttrType = " + OBJTYPE_ACCOUNT
                   + " and t_AttrID = '" + АUniID + "'" );

            while( rs.MoveNext( ) )
                RestoreFromUniID( rs.Value( 0 ), AccBuff, OBJTYPE_ACCOUNT );
                МЗалогДляСчета( МЗалогДляСчета.size ) = КЛицевойСчет;
                if( not МЗалогДляСчета( МЗалогДляСчета.size - 1 ).Инициализация( AccBuff.Rec.Account, AccBuff.Rec.Balance, AccBuff.Rec.Chapter ) )
                    МЗалогДляСчета.size = МЗалогДляСчета.size - 1;
                else
                    ErrorStr = String( ErrorStr," Л/с ", МЗалогДляСчета( МЗалогДляСчета.size - 1 ).АНомерЛицевого, " указан как счет залога." );
                end;
            end;
        end;

        if( МЗалогДляСчета.size == 0 )
            ErrorStr = String( ErrorStr," !ОШИБКА: Счет ", АНомерЛицевого, " не указан в связанном объекте \"Счет залога\" ни для одного счета." );
            return NULL;
        else
            return МЗалогДляСчета;
        end;
    END;

    /************************************************************************
     Метод определяет лицевой счет процентов, для КЛицевойСчет.
     Возвращает значение типа [КЛицевойСчет].
    ************************************************************************/
    MACRO СчетПроцентов()
        VAR l, i = 0,
            AccBuff = TRecHandler ( "account.dbt", "bank.def" );;
        if( МСчетПроцентов == NULL )
            МСчетПроцентов = TArray;
            while( i < 3 )
                l = GetLinkedObject( OBJROLE_ACC_PERCENT + i, OBJTYPE_ACCOUNT, АUniID,
                            OBJTYPE_ACCOUNT, AccBuff, NULL );
                if( l == 0 )
                    МСчетПроцентов( МСчетПроцентов.size ) = КЛицевойСчет;
                    if( not МСчетПроцентов( МСчетПроцентов.size - 1 ).Инициализация( AccBuff.Rec.Account, AccBuff.Rec.Balance,AccBuff.Rec.Chapter ) )
                        МСчетПроцентов.size = МСчетПроцентов.size - 1;
                    else
                        ErrorStr = String( ErrorStr," Л/с ", МСчетПроцентов( МСчетПроцентов.size - 1).АНомерЛицевого, " указан как счет процентов." );
                    end;
                end;
                i = i + 1;
            end;
        end;

        if( МСчетПроцентов.size == 0 )
            ErrorStr = String( ErrorStr," !ОШИБКА: Не найдено значение связанного объекта \"Счет процентов\"." );
            return NULL;
        else
            return МСчетПроцентов;
        end;
    END;

    /************************************************************************
     Метод определяет лицевые счета, для которых КЛицевойСчет указан как счет
     процентов. Возвращает массив значений типа [КЛицевойСчет].
    ************************************************************************/
    MACRO ПроцентыДляСчета()
     VAR l, rs, i = 0,
         AccBuff = TRecHandler ( "account.dbt", "bank.def" );
     if( МПроцентыДляСчета == NULL )
        МПроцентыДляСчета = TArray;
        while( i < 3 )
            rs = SQL_ExecuteSimple( objlink, "t_ObjectID",
                     "t_ObjectType = " + OBJTYPE_ACCOUNT
                   + " and t_GroupID = " + OBJROLE_ACC_PERCENT + i
                   + " and t_AttrType = " + OBJTYPE_ACCOUNT
                   + " and t_AttrID = '" + АUniID + "'" );

            while( rs.MoveNext( ) )
                RestoreFromUniID( rs.Value( 0 ), AccBuff, OBJTYPE_ACCOUNT );
                МПроцентыДляСчета( МПроцентыДляСчета.size ) = КЛицевойСчет;
                if( not МПроцентыДляСчета( МПроцентыДляСчета.size - 1 ).Инициализация( AccBuff.Rec.Account, AccBuff.Rec.Balance, AccBuff.Rec.Chapter ) )
                    МПроцентыДляСчета.size = МПроцентыДляСчета.size - 1;
                end;
            end;

            i = i + 1;
        end;
     end;

     if( МПроцентыДляСчета.size == 0 )
         ErrorStr = String( ErrorStr," !ОШИБКА: Счет ", АНомерЛицевого, " не указан в связанном объекте \"Счет процентов\" ни для одного счета." );
         return NULL;
     else
         return МПроцентыДляСчета;
     end;
    END;

    /************************************************************************
     Метод определяет является ли лицевой счет накопительным или нет. 
    ************************************************************************/
    MACRO НакопительныйСчет()
     var Is_N;
      CheckObjAttrPresence( Is_N, OBJTYPE_ACCOUNT, АUniID,
                            OBJ_ACCOUNT_GROUP_KIND, Null, "", "N" );
      if( Is_N or ( index( acc.Rec.Type_Account, "L" ) > 0 ) )
        ErrorStr = String( ErrorStr," Накопительный счет." );
        return true;
      end;
      return false;
    END;

    /******************************************************************************
     Метод определяет дату начала операции по счету 
      *******************************************************************************/
    MACRO ДатаНачалаОп()

    if( МДатаНачалаОп != NULL )
            return МДатаНачалаОп;
        end;

        if( АДатаНачалаОп != NULL )
            МДатаНачалаОп = АДатаНачалаОп;
        else
            МДатаНачалаОп = АДатаОткрытия;
        end;

        return МДатаНачалаОп;
    END;

    /******************************************************************************
     Метод определяет количество пролонгаций (переносов срока погашения) 
     на дату
    *******************************************************************************/
    macro КоличествоПролонгаций(Дата)
        var rez = 0;
   
        macro getCount(UniID, dat)

            var dataSet = TRsbDataSet("SELECT count(*) count                          " +
                                      "  FROM dnotetext_dbt                           " +
                                      " WHERE  t_ObjectType = " + OBJTYPE_ACCOUNT       +
                                      "   AND  t_DocumentID = '" + UniID + "'         " +
                                      "   AND  t_NoteKind   = " + NOTEKIND_DATE_PAYING  +
                                      "   AND  t_ValidToDate<=" + GetSQLDate( dat));
            if (dataSet.MoveNext())
                return dataSet.count;
            end;
            return 0;        
        end;

        // Получение счетов пролонгации (если есть).
        macro getCountLinkedAccount(dat, account)
            var filter, thisAccount, otherAccount;

            if(АВидСчета == "П")
                thisAccount  = "t_Account_Receiver";
                otherAccount = "t_Account_Payer";
            else
                thisAccount  = "t_Account_Payer";
                otherAccount = "t_Account_Receiver";
            end;

            filter = "t_Chapter = " + АГлава + " and t_Code_Currency = " + АВалютаID
                   + " and " + thisAccount + " = '" + account + "'"
                   + " and t_date_Carry < " + GetSQLDate( dat);

            var table;
            if(АВалютаID != 0) /* не рубли */
                table = arhdocV;
            else
                table = arhdocR;
            end;

            var dataSet = TRsbDataSet("   SELECT " + otherAccount + " OtherAccount,"+
                                      "              t_date_Carry     date_Carry   "+
                                      "   FROM " + SQL_GetTableName(table)          +
                                      "   WHERE " + filter                          );

            var result, bal1;   // вспомог. перем.

            if(dataSet.MoveNext())
                bal1 = substr(dataSet.OtherAccount, 1, 3);
                if( (bal1 != "203") and (bal1 != "474") and (bal1 == substr(account, 1, 3 )) )
                    result = КЛицевойСчет( );
                    if( result.ИнициализацияАльтернативная(dataSet.OtherAccount, АВалютаID, АГлава) )
                          rez = rez + GetCount(result.АUniID, dat);
                          GetCountLinkedAccount(dataSet.date_Carry, dataSet.OtherAccount);
                    end;
                end;
            end;
            
            return rez;
        end;

        return ( getCount(АUniID, Дата) + getCountLinkedAccount(Дата) );
    end;

    /******************************************************************************
     Метод определяет дату погашения по счету, действующую на дату  
    *******************************************************************************/
    MACRO ДатаПогашения(Дата, Nomes)
     var ДатаУстановки,
         val_date = readNoteForObject( OBJTYPE_ACCOUNT, АUniID,
                               NOTEKIND_DATE_PAYING, Дата, ДатаУстановки );
      if( ( ДатаУстановки != "" ) and ( val_date != date(0,0,0) ) )
       return val_date;
      else
       val_date = ДатаНачалаОп();
       if( ( valtype(val_date) != V_Undef ) and ( val_date != date(0,0,0) ) )
        return val_date + АСрок;
       else
        if( Nomes == NULL )
         ErrorStr = String( ErrorStr," !ОШИБКА: Не заданы: Дата начала операции счета или примечание \"Дата погашения\"." );
        end;
        return NULL;
       end;
      end;
    END;

    /******************************************************************************
     Метод определяет срок, на который размещены средства на счете,
     определенный на дату  
    *******************************************************************************/
    MACRO Срок(Дата, Nomes)
        var dateRepayment;
        var val_date = readNoteForObject( OBJTYPE_ACCOUNT, АUniID, NOTEKIND_DATE_PAYING, Дата, dateRepayment );
           
        if( (dateRepayment != "") and (val_date != date(0,0,0)) )
            return (ДатаПогашения(Дата, TRUE) + 1) - ДатаНачалаОп();
        elif( АСрок != 0 )
            return АСрок;
        else
            if( Nomes == NULL )
                ErrorStr = String( ErrorStr," !ОШИБКА: Не заданы: Срок или примечание \"Дата погашения\" для счета." );
            end;
            return NULL;
        end;
    END;

    /******************************************************************************
     Метод определяет лицевой счет, с которого перенесены средства
     на просрочку. Как правило, данный метод будет вызываться для счетов
     просрочки и служит для того, чтобы определить счет, на котором учитывался
     основной долг до нарушения срока. Возвращает значение типа [КЛицевойСчет].
    *******************************************************************************/
    MACRO ПросроченоСоСчета( )
        /* Вспомогательный макрос, находящий первую проводку (на самом деле любую за первую дату)
           и берущую из неё (если есть) номер кредитуемого счёта.
        */
        MACRO GetReceiverAccount( table )
            var filter = "t_Chapter = " + АГлава + " and t_Code_Currency = " + АВалютаID
                       + " and t_Account_Payer = '" + АНомерЛицевого + "'";
            var rs = SQL_ExecuteSimple( table, "min( t_Date_Carry )", filter );
            var dat;
            if( rs and rs.MoveNext( ) and ( rs.Value( 0 ) != NULL ) )
                DtTmSplit( rs.Value( 0 ), dat );
            else
                return NULL;
            end;

            filter = string( filter, " and t_Date_Carry = '", dat:f, "'" );
            rs = SQL_ExecuteSimple( table, "t_Account_Receiver", filter );
            if( rs and rs.MoveNext( ) )
                return rs.Value( 0 );
            end;
            return NULL;
        END;

        if( НПросроченоСоСчета )
            return NULL;
        end;
        if( МПросроченоСоСчета != NULL )
            return МПросроченоСоСчета;
        end;
        
        var doc, account, aR = КЛицевойСчет;

        if( АВидСчета == "А" )
            if( АВалютаID != 0 ) /* не рубли */
                doc = arhdocV;
            else
                doc = arhdocR;
            end;

            account = GetReceiverAccount( doc );
            if( account == NULL )
                ErrorStr = String( ErrorStr," Не найден документ по выносу средств на просрочку." );
                НПросроченоСоСчета = true;
            else
                aR.Инициализация( account, NULL, АГлава );
                МПросроченоСоСчета = aR;
            end;
        else /* Пассивный счет */
            ErrorStr = String( ErrorStr," !ОШИБКА: Попытка определить счет кредитных требований с пассивного счета." );
            НПросроченоСоСчета = true;
        end;
        
        return МПросроченоСоСчета;
    END;

    /******************************************************************************
     Метод определяет срок оставшийся до погашения на дату на счете в днях
    *******************************************************************************/
    macro ОстатокСрокаДо(Дата)
      var val_date = ДатаПогашения(Дата, TRUE);
      if( valtype(val_date) != V_Undef )
       ErrorStr = String( ErrorStr," Срок, оставшийся до погашения на ", Дата, " = ", val_date - Дата );
       return val_date - Дата;
      else  
       return NULL;
      end;
    end;

    /******************************************************************************
     Метод определяет, является ли лицевой счет счетом до востребования. 
    *******************************************************************************/
    MACRO СчетДВ()
     if(ТипБалансового( Тип_ДВ ) )
       if( ДатаНачалаОп() == date(0,0,0) )
        ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Для счета д/в не определена дата начала операции." );
       end;
       if( Срок(ДатаОтчета, TRUE) != 0 )
        ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Для счета д/в указан срок." );
       end;
       return true;
     else
       if( ДатаНачалаОп() == date(0,0,0) )
        ErrorStr = String( ErrorStr," !ОШИБКА: Для счета не определена дата начала операции." );
        return false;
       elif( Срок(ДатаОтчета, TRUE) )   // проверка на != NULL and != 0
        return false;
       end;
       return true;
     end;
    END;

    /******************************************************************************
     Метод определяет срок исполнения обязательств после дня востребования в днях.
     Возвращает значение примечания "Срок исполнения после востребования",
     действовавшее на дату, или 0, если примечание не задано.
    *******************************************************************************/
    MACRO СрокПослеВостр( Дата )
     var ДатаУстановки,
         val_date = readNoteForObject( OBJTYPE_ACCOUNT, АUniID,
                                      NOTEKIND_DAY_AFTER_DENAND, Дата, ДатаУстановки );
      if( ДатаУстановки != "" )
        if( val_date > 1 )
          ErrorStr = String( ErrorStr," Срок исполнения обязательств по счетам д/в после дня востребования превышает 1 день" );
        end;
        return val_date;
      else
        return 0;
      end;
    END;

    /******************************************************************************
     Метод определяет сумму средств на счете на дату, срок нахождения
     которой на балансе не превышает <КоличествоДней>.
    *******************************************************************************/
    MACRO ОстатокСоСроком( Дата, КоличествоДней )
        // Вспомогательный макрос, берущий нужное значение по таблице.
        MACRO GetSumInTable( table, date1, date2 )
            var filter;
            if( АВидСчета == "П" )
                filter  = "t_Account_Receiver";
            else
                filter  = "t_Account_Payer";
            end;
            filter = "t_Chapter = " + АГлава + " and t_Code_Currency = " + АВалютаID
               + " and " + filter + " = '" + АНомерЛицевого + "'";
            if( ( date1 != NULL ) and (date2 != NULL ) )
                filter = string( filter, " and t_Date_Carry >= '", date1:f, "'",
                       " and t_Date_Carry <= '", date2:f, "'" );
            end;

            var rs = SQL_ExecuteSimple( table, "t_Sum", filter );
            if( rs == NULL )
                return $0;
            end;

            var sum = $0;
            while( rs.MoveNext( ) )
                sum = sum + rs.Value( 0 );
            end;
            return sum;
        END;

        if( МОстатокСоСроком != NULL )
            return МОстатокСоСроком;
        end;
        
        var doc, DateBegin = Дата - КоличествоДней;

        if( АВалютаID != 0 ) /* не рубли */
            doc = arhdocV;
        else
            doc = arhdocR;
        end;
     
        МОстатокСоСроком = GetSumInTable( doc, DateBegin, Дата );
     
        МОстатокСоСроком = max( МОстатокСоСроком, Остаток(Дата) );
        return МОстатокСоСроком;
    END;

    /******************************************************************************
     Метод определяет учитываются ли на лицевом счете суммы, задепонированные
     в Банке России для получения следующим днем наличных денежных средств. 
    *******************************************************************************/
    MACRO ЗадепонированоЦБ( Дата )
      var Is_A;
      CheckObjAttrPresence( Is_A, OBJTYPE_ACCOUNT, АUniID,
                                   OBJ_ACCOUNT_GROUP_REP, null, "", "ЗадепЦБ", Дата, NULL );
      if( Is_A )
        return TRUE;
      else
        ErrorStr = String( ErrorStr," Для счета не задано значение \"Задепонировано в ЦБ\" категории \"Категория для отчетности\"." );
        return FALSE;
      end;
    END;

    /******************************************************************************
     Метод определяет учитываются ли на лицевом счете суммы, предоставленные
     для гарантийного беспечения расчетов по поручению нерезиентов на ОРЦБ. 
    *******************************************************************************/
    MACRO ГарантОбеспечРасчНерез( Дата )
      var Is_A;
      CheckObjAttrPresence( Is_A, OBJTYPE_ACCOUNT, АUniID,
                                   OBJ_ACCOUNT_GROUP_REP, null, "", "ГарНер", Дата, NULL );
      if( Is_A )
        return TRUE;
      else
        ErrorStr = String( ErrorStr," Для счета не задано значение \"Гарантийное обеспечение расчетов нерезидентов\" категории \"Категория для отчетности\"." );
        return FALSE;
      end;
    END;

    /* Метод определяет учитываются ли на лицевом нематериальные активы. */
    MACRO НМА( Дата )
      var Is_A;
      CheckObjAttrPresence( Is_A, OBJTYPE_ACCOUNT, АUniID,
                                   OBJ_ACCOUNT_GROUP_REP, null, "", "НМА", Дата, NULL );
      if( Is_A )
        ErrorStr = String( ErrorStr," На счете учитываются НМА." );
        return TRUE;
      end;
      return FALSE;
    END;

    /* Метод определяет соответствует ли цель приобретения бумаг, учитываемых
       на лицевом счете указанной в параметре Цель. */
    MACRO ЦельПриобретенияЦб( Цель, Дата )
      var Is_A, purpose, l;
      CheckObjAttrPresence( Is_A, OBJTYPE_ACCOUNT, АUniID,
                                   OBJ_ACCOUNT_GROUP_REP, null, "", Цель, Дата, NULL );
      if( Is_A )
        return TRUE;
      else
        if( GetMainObjAttr( l, OBJTYPE_ACCOUNT, АUniID,
                          OBJ_ACCOUNT_GROUP_PURPOSE, purpose, NULL, NULL,
                          Дата, NULL ) and ( l == 0 ))
           ErrorStr = String( ErrorStr," Цель приобретения бумаг не соответствует ", Цель, ". Указано  ", purpose,"." );
        else
           ErrorStr = String( ErrorStr," Не указана Цель приобретения бумаг." );
        end;
        return FALSE;
      end;
    END;

    /* Метод определяет классификацию МБК */
    MACRO КлассификацияМБК( Значение, Дата )
      var Is_A, l, Значение1;
      CheckObjAttrPresence( Is_A, OBJTYPE_ACCOUNT, АUniID,
                                   OBJ_ACCOUNT_GROUP_REP, null, "", Значение, Дата, NULL );
      if( Is_A )
        return TRUE;
      else
        if( GetMainObjAttr( l, OBJTYPE_ACCOUNT, АUniID,
                          OBJ_ACCOUNT_GROUP_REP, Значение1, NULL, NULL,
                          Дата, NULL ) and ( l == 0 ))
           ErrorStr = String( ErrorStr," Классификация МБК не соответствует ", Значение, ". Указано  ", Значение1,"." );
        else
           ErrorStr = String( ErrorStr," Не указана Классификация МБК." );
        end;
        return FALSE;
      end;
    END;

    /* Метод определяет риск по условным обязательствам кредитного характера,
       который установлен для лицевого счета */
    MACRO КРВ( Дата, Тип)
     var i = 0, j = 1, l,
         MinAttrID = 0,
         RetVal = FALSE,
         NumInList = "",
         AttrBuff = TRecHandler ( "objattr.dbt", "bank.def" ),
         ObjID = АUniID;
      if ( ObjAttr_FindFirst( AttrBuff, OBJTYPE_ACCOUNT, ObjID, OBJ_ACCOUNT_GROUP_REP, Дата, NULL ) == 0 )
       if( AttrBuff.Rec.ParentID == 11 )
        ObjAttr_FindClose();
        if( Тип == AttrID )
         return AttrBuff.Rec.AttrID;
        else
         return trim( AttrBuff.Rec.NumInList );
        end;
        while ( ObjAttr_FindNext(AttrBuff) == 0 )
         if( AttrBuff.Rec.ParentID == 11 )
          ObjAttr_FindClose();
          if( Тип == AttrID )
           return AttrBuff.Rec.AttrID;
          else
           return trim( AttrBuff.Rec.NumInList );
          end;
         end;
        end;
       end;
      end;
      ObjAttr_FindClose();
      ErrorStr = String( ErrorStr, " Для счета не задано значение кредитного риска по внеб. категории \"Категория для отчетности\"." );
      Return NULL;

    END;

    /* Определяет кто является страховщиком средств на счете.
       Возвращает значение [КСубъект].*/
    MACRO Страховщик()
     var l, cl = КСубъект,
         PtBuff = TRecHandler ( "party.dbt", "bank.def" );

     l = GetLinkedObject( OBJROLE_INSURER, OBJTYPE_ACCOUNT, АUniID,
                          OBJTYPE_PARTY, PtBuff, NULL );
     if( l != 0 )
       ErrorStr = String( ErrorStr," Не найдено значение связанного объекта \"Страховщик\"." );
       return NULL;
     end;
     if( cl.Инициализация( PtBuff.Rec.partyID ) and
       not cl.Является(ВидСубъекта_СтраховаяКомпания) )
       ErrorStr = String( ErrorStr," !ВНИМАНИЕ: Указан связанный объект \"Страховщик\". Не установлена принадлежность \"Страховая компания\"." );
     end;
     return cl;
    END;

    // Классификация РВП счёта
    MACRO КлассифРВП( дата )
        var res = GetClassifReserve( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( ( res == NULL ) or ( res == "" ) )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение классификации РВП.";
            return NULL;
        end;
        return res;
    END;
    
    // Классификация РВПС счёта
    MACRO КлассифРВПС( дата )
        var res = GetClassifReserveLoans( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( ( res == NULL ) or ( res == "" ) )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение классификации РВПС.";
            return NULL;
        end;
        return res;
    END;
    
    // Классификация РОФШ счёта
    MACRO КлассифРОФШ( дата )
        var res = GetClassifReserveOffshore( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( ( res == NULL ) or ( res == "" ) )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение классификации РОФШ.";
            return NULL;
        end;
        return res;
    END;
    
    // Категория обеспечения (вызывается и для основного счёта, и для счетов обеспечения)
    // Второй параметр, когда равен true, показывает, что вызывается для "основного" счёта,
    // иначе для счёта обеспечения.
    MACRO КатегорОбеспеч( дата, осн )
        var res = GetCategoryOfEnsuring( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( res == NULL )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не найдено значение примечания \"Категория качества обеспечения\"";
            if( осн != true )
                ErrorStr = ErrorStr + " связанного объекта \"Счет обеспечения\"";
            end;
            ErrorStr = ErrorStr + ".";
            return NULL;
        end;
        return int( res );
    END;
    
    // Дата обращения взыскания (вызывается для счетов обеспечения).
    MACRO ДатаОбращВзыскНаЗалог( )
        var res = GetPawnCollectionDate( АГлава, АВалютаID, АНомерЛицевого );
        if( res == NULL )
            ErrorStr = ErrorStr + "!ОШИБКА: Сообщение_ИнформацияОСчете. Не найдено значение примечания \"Дата обращения взыскания\" связанного объекта \"Счет обеспечения\".";
        end;
        return res;
    END;
    
    // Коэффициент, с которым учитывается обеспечение (вызывается для счетов обеспечения).
    MACRO КоэфОбеспеч( дата )
        var res = GetCoefficientOfEnsuring( КатегорОбеспеч( дата ), NVL(ДатаОбращВзыскНаЗалог( ), дата), дата );
        if( res == NULL )   
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение коэффициента обеспечения.";
        end;
        return res;
    END;

    /* Вспомогательная функция, чтобы считать две стоимости обеспечения вместе,
       а не повторять проход по счетам обеспечения в этих функциях.
    */
    private MACRO СтоимостьОбеспечения( дата )
        if( МДатаОбеспеч == дата )  // это уже посчитано
            return;
        end;

        МДатаОбеспеч = дата;
        var ensur = СчетОбеспечения( );
        var i = 0, category, market, coeff;
        МСтоимОбеспечРВП = $0;
        МСтоимОбеспечРВПС = $0;
        if( ensur != NULL )
            while( i < ensur.size )
                category = ensur[i].КатегорОбеспеч( дата );
                market = ensur[i].РынСтоимость( дата );
                if( market == NULL ) market = $0; end;
                coeff = ensur[i].КоэфОбеспеч( дата );
                if( coeff == NULL ) coeff = $0; end;
                if( category == 1 )
                    МСтоимОбеспечРВП = МСтоимОбеспечРВП + market;
                end;
                МСтоимОбеспечРВПС = МСтоимОбеспечРВПС + market * coeff;
            i = i + 1;
            end;
        end;
    END;

    // Оценка стоимости обеспечения, используемая в расчёте РВП
    MACRO СтоимостьОбеспеченияРВП( дата )
        СтоимостьОбеспечения( дата );
        return МСтоимОбеспечРВП;
    END;
    
    // Оценка стоимости обеспечения, используемая в расчёте РВПС
    MACRO СтоимостьОбеспеченияРВПС( дата )
        СтоимостьОбеспечения( дата );
        return МСтоимОбеспечРВПС;
    END;
    
    // Вспомогательные переменные для следующей функции
    /*//05 Jun 07 Malakhova Irina 107762, 107763*/
    /*Перенесла объявление флага ReserveCalculatorFlag выше*/
    private var ReserveCalculator;
    // Заполнение класса CalcReserve.
    // Здесь этот класс создаётся, здесь контролируется и отсюда возвращается.
    private MACRO КлассВычисленияРезерва( дата )
        if( ReserveCalculatorFlag == false )    // пытались создать, но не смогли
            return NULL;
        elif( ReserveCalculatorFlag == true )   // класс уже создан
            return ReserveCalculator;
        end;

        // ( ReserveCalculatorFlag == NULL )
        ReserveCalculator = CalcReserve;
        ReserveCalculator.DateReserve = дата;
        ReserveCalculator.RsvClass = КлассифРВП( дата );
        ReserveCalculator.RsvClassLoans = КлассифРВПС( дата );
        ReserveCalculator.RsvClassOffshore = КлассифРОФШ( дата );
        ReserveCalculator.GroupRisk = ГруппаРиска( дата );
        ReserveCalculator.Rest = Остаток( дата );   // не м.б. NULL
        if( ReserveCalculator.RsvClass != NULL )
            ReserveCalculator.ProcentReserve = ПроцентРезерваРВП( дата );
        else
            ReserveCalculator.ProcentReserve = ПроцентРезерваРВПС( дата );
        end;
        ReserveCalculator.ProcentReserveOffshore = ПроцентРезерваОФШ( дата );

        if (ReserveCalculator.ProcentReserve == NULL)
            ReserveCalculator.ProcentReserve = 0.0;
        end;

        if (ReserveCalculator.ProcentReserveOffshore == NULL)
            ReserveCalculator.ProcentReserveOffshore = 0.0;
        end;

        var ruracc = АНомерЛицевого;
        if( АВалютаID != rurID )
            ruracc = АНомерСчетаПокрытия;
        end;
        if( ( ruracc != NULL ) and ( ruracc != "" ) )
            ReserveCalculator.MaxRest = GetMaxAccRest( АГлава, ruracc, ПредДатаОтчета, ДатаОтчета );
            ReserveCalculator.DebetTurn = GetAverageAccDebetTurn( АГлава, ruracc, /*ПредДатаОтчета,*/ ДатаОтчета );
            ReserveCalculator.MaxRest30WorkDay = GetMaxAbsAcc30DayRest(АГлава, ruracc, ДатаОтчета);
            ReserveCalculator.DebetTurn30Day = GetAverageAccDebetTurn30Day(АГлава, ruracc, ДатаОтчета);
        end;
        ReserveCalculator.MarketCost = РынСтоимость( дата );
        ReserveCalculator.RestAmortization = СумАморт( дата );
        ReserveCalculator.EnsuringCategory = КатегорОбеспеч( дата, true );

        ReserveCalculator.MarketCostSecurity = СтоимостьОбеспеченияРВП( дата );
        ReserveCalculator.MarketCostSecurityByCategory = СтоимостьОбеспеченияРВПС( дата );

        ReserveCalculatorFlag = true;
        return ReserveCalculator;
    END;

    // Величина расчётного резерва на возможные потери для счёта.
    MACRO РасчетРезервРВП( дата )
        var rc = КлассВычисленияРезерва( дата );
        var res;

        if( rc != NULL )
            res = rc.CalcReserveLoss( );
        end;
        if( res == NULL )
            res = $0;
        end;
        return res;

        OnError( er )
        // Никаких сообщений не надо, всё уже выведено при попытке получить
        // необходимые параметры, из-за отсутствия которых и ошибка
        return $0;
    END;

    // Величина расчётного резерва на возможные потери для счёта.
    MACRO РасчетРезервРВПС( дата )
        var rc = КлассВычисленияРезерва( дата );
        var res;

        if( rc != NULL )
            res = rc.CalcReserveLoans( );
        end;
        if( res == NULL )
            res = $0;
        end;
        return res;

        OnError( er )
        // Никаких сообщений не надо, всё уже выведено при попытке получить
        // необходимые параметры, из-за отсутствия которых и ошибка
        return $0;
    END;

    // Величина расчётного резерва на возможные потери для счёта.
    MACRO РасчетРезервРОФШ( дата )
        var rc = КлассВычисленияРезерва( дата );
        var res;

        if( rc != NULL )
            res = rc.CalcReserveOffshore( );
        end;
        if( res == NULL )
            res = $0;
        end;
        return res;

        OnError( er )
        // Никаких сообщений не надо, всё уже выведено при попытке получить
        // необходимые параметры, из-за отсутствия которых и ошибка
        return $0;
    END;

    // Общий расчётный резерв для счёта.
    MACRO РасчетРезерв( дата )
        var rc = КлассВычисленияРезерва( дата );
        var res;

        if( rc != NULL )
            rc.CalcReserveLoss( );
            rc.CalcReserveLoans( );
            rc.CalcReserveOffshore( );
            res = rc.CalcReserve( );
        end;
        if( res == NULL )
            res = $0;
        end;
        return res;

        OnError( er )
        // Никаких сообщений не надо, всё уже выведено при попытке получить
        // необходимые параметры, из-за отсутствия которых и ошибка
        return $0;
    END;

    // Величина фактического резерва на возможные потери для счёта.
    MACRO ФактРезервРВП( дата, учетПортфеля )
        var res, resdate, rest, caseid;
        var resacc = КЛицевойСчет;
        var case = GenObject( "КПортфель" );

        if( учетПортфеля == NULL )
            учетПортфеля = false;
        end;

        if( учетПортфеля )
            caseid = GetCaseOfAccount( АГлава, АВалютаID, АНомерЛицевого, дата );
            if( caseid == NULL );
            else
                res = GetReserveAccount( caseid );
                if( (res == NULL) or not resacc.ИнициализацияАльтернативная( res, NATCUR, BalanceChapter ) )
                    return $0;
                else
                    resdate = resacc.ДатаПоследнейОперации( дата );
                    case.Инициализация( caseid, resdate );
                    rest = case.Остаток( resdate );
                    if( (rest == NULL) or (rest == 0) )
                        return $0;
                    end;
                    res = GetFactReserve( res, дата, КлассифРВП( дата ) );
                    if( res == NULL )
                        ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного РВП.";
                        return $0;
                    end;
                    return abs( res * Остаток(resdate) / rest );
                end;
            end;
        end;

        resacc = СчетРезерва();
        if( resacc == NULL )
            return $0;
        end;
        res = GetFactReserve( resacc.АНомерЛицевого, дата, КлассифРВП( дата ) );
        if( res == NULL )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного РВП.";
            return $0;
        end;

        return abs( res );
    END;

    // Величина фактического резерва на возможные потери по ссудам для счёта.
    MACRO ФактРезервРВПС( дата, учетПортфеля )
        var res, resdate, rest, caseid;
        var resacc = КЛицевойСчет;
        var case = GenObject( "КПортфель" );

        if( учетПортфеля == NULL )
            учетПортфеля = false;
        end;

        if( учетПортфеля )
            caseid = GetCaseOfAccount( АГлава, АВалютаID, АНомерЛицевого, дата );
            if( caseid == NULL );
            else
                res = GetReserveAccount( caseid );
                if( (res == NULL) or not resacc.ИнициализацияАльтернативная( res, NATCUR, BalanceChapter ) )
                    return $0;
                else
                    resdate = resacc.ДатаПоследнейОперации( дата );
                    case.Инициализация( caseid, resdate );
                    rest = case.Остаток( resdate );
                    if( (rest == NULL) or (rest == 0) )
                        return $0;
                    end;
                    res = GetFactReserveLoans( res, дата, КлассифРВПС( дата ) );
                    if( res == NULL )
                        ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного РВПС.";
                        return $0;
                    end;
                    return abs( res * Остаток(resdate) / rest );
                end;
            end;
        end;

        resacc = СчетРезерва();
        if( resacc == NULL )
            return $0;
        end;
        res = GetFactReserveLoans( resacc.АНомерЛицевого, дата, КлассифРВПС( дата ) );
        if( res == NULL )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного РВПС.";
            return $0;
        end;

        return abs( res );
    END;

    // Величина фактического резерва по оффшору для счёта.
    MACRO ФактРезервРОФШ( дата, учетПортфеля )
        var res, resdate, rest, caseid;
        var resacc = КЛицевойСчет;
        var case = GenObject( "КПортфель" );

        if( учетПортфеля == NULL )
            учетПортфеля = false;
        end;

        if( учетПортфеля )
            caseid = GetCaseOfAccount( АГлава, АВалютаID, АНомерЛицевого, дата );
            if( caseid == NULL );
            else
                res = GetReserveAccount( caseid );
                if( (res == NULL) or not resacc.ИнициализацияАльтернативная( res, NATCUR, BalanceChapter ) )
                    return $0;
                else
                    resdate = resacc.ДатаПоследнейОперации( дата );
                    case.Инициализация( caseid, resdate );
                    rest = case.Остаток( resdate );
                    if( (rest == NULL) or (rest == 0) )
                        return $0;
                    end;
                    res = GetFactReserveOffshore( res, дата, КлассифРОФШ( дата ),
                        КлассифРВП( дата ), КлассифРВПС( дата ) );
                    if( res == NULL )
                        ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного РОФШ.";
                        return $0;
                    end;
                    return abs( res * Остаток(resdate) / rest );
                end;
            end;
        end;

        resacc = СчетРезерва();
        if( resacc == NULL )
            return $0;
        end;
        res = GetFactReserveOffshore( resacc.АНомерЛицевого, дата, КлассифРОФШ( дата ),
                КлассифРВП( дата ), КлассифРВПС( дата ) );
        if( res == NULL )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного РОФШ.";
            return $0;
        end;

        return abs( res );
    END;

    // Возвращает дату последней операции до параметра дата.
    /* Вспомогательная функция для ФактРезерв, но публичная, т.к. вызывается для
       другого счёта.
       Вычисляется как дата последнего изменения остатка до заданной даты.
       Возможно, это неправильно, и надо вычислять по проводкам.
    */  
    MACRO ДатаПоследнейОперации( дата )
        var rs = SQL_ExecuteAndGetRs( "SELECT max( t_Date_Value ) maxDate FROM dRestDate_dbt"
            + " WHERE t_Date_Value <= '" + string( дата:f ) + "'" );
        if( rs.MoveNext( ) )
            return SQL_ConvSpec( rs.Value( "maxDate" ) );   // DTTM->DATE
        else
            return Date( 0, 0, 0 );
        end;
    END;
    
    // Величина фактического резерва для счёта.
    MACRO ФактРезерв( дата )
        MACRO ErrVal( )
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Не определено значение фактически созданного резерва.";
            return $0;
        END;

        var res, case, resacc, resdate;
        var caseID = GetCaseOfAccount( АГлава, АВалютаID, АНомерЛицевого, дата );
        if( caseID == NULL )  // счёт не входит ни в какой портфель
            res = СчетРезерва( );
            if( res == NULL )
                return ErrVal( );
            end;
            res = res.Остаток( дата );
        else
            res = GetReserveAccount( caseID );
            if( res == NULL )
                return ErrVal( );
            end;
            // Потому что определён он ниже.
            case = GenObject( "КПортфель" );
            if( not case.Инициализация( caseID, дата ) )
                return ErrVal( );
            end;
            resacc = КЛицевойСчет;
            if( not resacc.Инициализация( res ) )
                return ErrVal( );
            end;

            // Находим дату создания резерва.
            resdate = resacc.ДатаПоследнейОперации( дата );

            res = resacc.Остаток( дата ) * ( Остаток( resdate ) / case.Остаток( resdate ) );
        end;

        return res;
    END;

    /* Определяет, является ли лицевой счет текущим в рамках валютного контроля.*/
    MACRO ТекущийСчет( )
        if( index( acc.rec.Type_Account, "X" ) > 0 )
            return true;
        else
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Счет не является текущим.";
            return false;
        end;
    END;

    /* Определяет, является ли лицевой счет транзитным в рамках валютного контроля.*/
    MACRO ТранзитныйСчет( )
        if( index( acc.rec.Type_Account, "Y" ) > 0 )
            return true;
        else
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Счет не является транзитным.";
            return false;
        end;
    END;

    /* Определяет, является ли лицевой счет специальным банковским счетом
       в рамках валютного контроля.*/
    MACRO СпециальныйБанковскийСчет( )
        if( index( acc.rec.Type_Account, "Я" ) > 0 )
            return true;
        else
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Счет не является специальным банковским.";
            return false;
        end;
    END;

    /* Определяет, является ли лицевой счет специальным брокерским счетом
       в рамках валютного контроля.*/
    MACRO СпециальныйБрокерскийСчет( )
        if( index( acc.rec.Type_Account, "Q" ) > 0 )
            return true;
        else
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Счет не является специальным брокерским.";
            return false;
        end;
    END;

    /* Определяет, является ли лицевой счет специальным банковким счетом "X"
       в рамках валютного контроля. X задаётся в параметре.*/
    private MACRO СпецБанкСчетX( X )
        var attrconst = ExecExp( "ВидСчета_Спецбанковский" + X );
        var res;
        CheckObjAttrPresence( res, OBJTYPE_ACCOUNT, АUniID, OBJ_ACCOUNT_GROUP_KIND, 0, "", attrconst );
        if( res )
            return true;
        else
            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОСчете. Счет не является специальным банковским счетом \"" + X + "\".";
            return false;
        end;
    END;

    MACRO СпецБанкСчетФ( )
        return СпецБанкСчетX( "Ф" );
    END;

    MACRO СпецБанкСчетР1( )
        return СпецБанкСчетX( "Р1" );
    END;

    MACRO СпецБанкСчетР2( )
        return СпецБанкСчетX( "Р2" );
    END;

    MACRO СпецБанкСчетС( )
        return СпецБанкСчетX( "С" );
    END;

    MACRO СпецБанкСчетА( )
        return СпецБанкСчетX( "А" );
    END;

    MACRO СпецБанкСчетО( )
        return СпецБанкСчетX( "О" );
    END;

    MACRO СпецБанкСчетВ1( )
        return СпецБанкСчетX( "В1" );
    END;

    MACRO СпецБанкСчетВ2( )
        return СпецБанкСчетX( "В2" );
    END;

    /************************************************************************
      Конструктор класса                              
    ************************************************************************/
    acc_R     = TBfile( "account.dbt",  "R", 0, "account.dbt",  "bank.def" );
    acc_V     = TBfile( "account$.dbt", "R", 0, "account$.dbt", "bank.def" );
    fininstr  = TBFile( "fininstr.dbt", "R", 0, "fininstr.dbt", "bank.def" );
    // нужна только для ТипБалансового и только, когда не задан параметр  Инициализации
    balance   = TBFile( "balance.dbt",  "R", 0, "balance.dbt",  "bank.def" );
    objlink   = TBFile( "objlink.dbt",  "R", 1, "objlink.dbt",  "bank.def" );
    arhdocV   = TBFile( "arhdoc$.dbt",  "R", 0, "arhdoc$.dbt",  "bank.def" );
    arhdocR   = TBFile( "arhdoc.dbt",   "R", 0, "arhdoc.dbt",   "bank.def" );

    OnError( er );
    Exit( 1 );
END; /*CLASS ЛицевойСчет*/

/******************************************************************************
    Класс "Портфель однородных требований"
*******************************************************************************/
CLASS КПортфель( )
    VAR
        АСуществует,
        АНаименование,
        АНомер,
        АМаскиЛС,
        АКлассифРВП,
        АКлассифРВПС,
        АГруппаРиска;

    private VAR МДата;                  // дата, к которой относятся запомненные параметры
    private VAR МОстаток;               // запоминаем остаток, чтобы не вычислять повторно
    private VAR МОбеспРВП, МОбеспРВПС;  // запоминаем, чтобы не вычислять повторно

    private var m_reservePercent;  /*//15 Jun 07 Fri 13:50:56 Malakhova Irina 107642*/
                                   /*Добавила свойство класса - процент резервирования портфеля*/
    private var m_errorString = "";

    // Классификация резервов на возможные потери: поле t_List в dllvalues_dbt
    private CONST РезВозПот = 1030;
    // Классификация резервов на возможные потери по ссудам: поле t_List в dllvalues_dbt
    private CONST РезСсуд   = 1033;

    private var CaseRecord; // recordset из одной записи, соответствующий портфелю

    MACRO Инициализация( id, dat )
        var reservePercentValueFromParameter;
        var errorCode;
        var result;

        m_errorString = "";

        if( ( id == NULL ) or ( dat == NULL ) )
            АСуществует = false;
            return false;
        end;

        CaseRecord = TRsbDataSet("SELECT accase.t_Name,"
                        + "\n" + "       accase.t_CaseId,"
                        + "\n" + "       accase.t_ReserveKind,"
                        + "\n" + "       accasepm.t_AccountMask,"
                        + "\n" + "       accasepm.t_RiskGroup,"
                        + "\n" + "       accaseit.t_ReserveType,"
/*//15 Jun 07 Fri 13:44:21 Malakhova Irina 107642*/
/*Добавила в выборку поле со значением процента резервирования из таблички параметров портфеля daccasepm_dbt*/
                        + "\n" + "       accasepm.t_ReservePercent"
                        + "\n" + "  FROM daccase_dbt   accase,"
                        + "\n" + "       daccasepm_dbt accasepm,"
                        + "\n" + "       daccaseit_dbt accaseit"
                        + "\n" + " WHERE accase.t_CaseID   = " + id
                        + "\n" + "   AND accasepm.t_CaseID = " + id
                        + "\n" + "   AND accaseit.t_CaseID = " + id
                        + "\n" + "   AND accasepm.t_DateFrom <= " + GetSqlDate(dat)
                        + "\n" + "   AND (    accasepm.t_DateTo >= " + GetSqlDate(dat)
                        + "\n" + "         OR accasepm.t_DateTo <  accasepm.t_DateFrom)"
                        + "\n" + "   AND accaseit.t_CaseID = " + id
                        + "\n" + "   AND accaseit.t_DateFrom <= " + GetSqlDate(dat)
                        + "\n" + "   AND (    accaseit.t_DateTo >= " + GetSqlDate(dat)
                        + "\n" + "         OR accaseit.t_DateTo <  accaseit.t_DateFrom)");

        if( ( CaseRecord == NULL ) or not CaseRecord.MoveNext( ) )
            АСуществует = false;
            return false;
        end;

        АНаименование = CaseRecord.Name;
        АНомер = CaseRecord.CaseID;
        АМаскиЛС = CaseRecord.t_AccountMask;
       
        // Классификация РВП/РВПС
        var temp;
        if( CaseRecord.ReserveKind == 1 )
            temp = РезВозПот;
        else
            temp = РезСсуд;
        end;

        var rs = SQL_ExecuteSimple( "dllvalues_dbt", "t_Code",
                 "t_List = " + temp + " and t_Element = " + CaseRecord.ReserveType);
        if ( ( rs == NULL ) or not rs.MoveNext( ) )
            АСуществует = false;
            return false;
        end;
        if( temp == РезВозПот )
            АКлассифРВП = rs.Value( 0 );
        else
            АКлассифРВПС = rs.Value( 0 );
        end;

        АГруппаРиска = Int( CaseRecord.RiskGroup);

        /*Процент резервирования*/
        if(CaseRecord.ReservePercent != NULL)
            m_reservePercent = CaseRecord.ReservePercent;
        else
            m_errorString = string(m_errorString," !ВНИМАНИЕ: Не задан процент резерва для портфеля.");
            result = GetMinReserveProcentLoans(АГруппаРиска);
            if (result == NULL)
                m_errorString = string(m_errorString,
                                       " !ВНИМАНИЕ: Не задан минимальный процент РВПС для ", 
                                       АГруппаРиска, 
                                       " группы риска.");
                m_reservePercent = NULL;
            else
                m_reservePercent = result;
                m_errorString = string(m_errorString," Взят min для группы риска."); 
            end;
        end;

        МДата = Date(0, 0, 0);

        МОстаток   = $0;
        МОбеспРВП  = $0; 
        МОбеспРВПС = $0;

        АСуществует = true;
        return true;
    END;

    /*Функция возвращает процент резервирования для портфеля*/
    macro ПроцентРезерваРВПС()

        if (m_errorString != "")
            msgbox(m_errorString);
        end;

        return m_reservePercent;
    end;

    // Счета в составе портфеля.
    private MACRO getAccounts( дата )
        дата = "'" + string( дата:f ) + "'";
        return SQL_ExecuteSimple( "daccaseit_dbt",
               "t_AccountChapter, t_AccountFI, t_Account",
               "t_CaseID = " + Аномер
             + " and " + дата + " >= t_DateFrom"
             + " and ( " + дата + " <= t_DateTo or t_DateTo < t_DateFrom )"
               );
    end;

    // Остаток портфеля - сумма по счетам портфеля.
    MACRO Остаток( дата )
        if( МДата == дата )
            return МОстаток;
        end;

        МДата = дата;
        МОстаток = $0;
        var rs = getAccounts( дата );
        var acc = КЛицевойСчет;
        while( rs and rs.MoveNext( ) )
            acc.ИнициализацияАльтернативная( rs.Value( "t_Account" ),
                    rs.Value( "t_AccountFI" ), rs.Value( "t_AccountChapter" ) );
            МОстаток = МОстаток + acc.Остаток( дата, rs.Value( "t_AccountFI" ) );
        end;

        return МОстаток;
    END;

    // Получить значения тех параметров, которые рассчитываются как сумма по счетам
    // Все параметры, кроме даты, выходные: остаток, рын. стоимость, сумма амортизации,
    // стоимость обеспечения для РВП, стоимость обеспечения для РВПС.
    private MACRO ЗначенияПоСчетам( дата, rest, market, amort, obesploss, obesploans )
        if( МДата != дата )
            МОстаток = NULL;
            МОбеспРВП = NULL;
            МОбеспРВПС = NULL;
        end;

        rest = $0;
        market = $0;
        amort = $0;
        obesploss = $0;
        obesploans = $0;

        var rs = getAccounts( дата );
        var acc = КЛицевойСчет;
        while( rs and rs.MoveNext( ) )
            acc.ИнициализацияАльтернативная( rs.Value( "t_Account" ),
                    rs.Value( "t_AccountFI" ), rs.Value( "t_AccountChapter" ) );
            if( МОстаток == NULL )
                rest = rest + acc.Остаток( дата );
            end;
            if( МОбеспРВП == NULL )
                obesploss = obesploss + acc.СтоимостьОбеспеченияРВП( дата );
            end;
            if( МОбеспРВПС == NULL )
                obesploans = obesploans + acc.СтоимостьОбеспеченияРВПС( дата );
            end;
            market = market + acc.РынСтоимость( дата );
            amort = amort + acc.СумАморт( дата );
        end;

        if( МОстаток == NULL )
            МОстаток = rest;
        end;
        if( МОбеспРВП == NULL )
            МОбеспРВП = obesploss;
        end;
        if( МОбеспРВПС == NULL )
            МОбеспРВПС = obesploans;
        end;

        МДата = дата;
        SetParm( 1, МОстаток );
        SetParm( 2, market );
        SetParm( 3, amort );
        SetParm( 4, obesploss );
        SetParm( 5, obesploans );
    END;

    // Оценка стоимости обеспечения, используемая в расчёте РВП
    MACRO СтоимостьОбеспеченияРВП( дата )
        if( дата != МДата )
            ЗначенияПоСчетам( дата );
        end;
        return МОбеспРВП;
    END;
    
    // Оценка стоимости обеспечения, используемая в расчёте РВП
    MACRO СтоимостьОбеспеченияРВПС( дата )
        if( дата != МДата )
            ЗначенияПоСчетам( дата );
        end;
        return МОбеспРВПС;
    END;
    
    // Вспомогательные переменные для следующей функции
    private var ReserveCalculator, ReserveCalculatorFlag;
    // Заполнение класса CalcReserve.
    // Здесь этот класс создаётся, здесь контролируется и отсюда возвращается.
    private MACRO КлассВычисленияРезерва( дата )
        if( ReserveCalculatorFlag == false )    // пытались создать, но не смогли
            return NULL;
        elif( ReserveCalculatorFlag == true )   // класс уже создан
            return ReserveCalculator;
        end;

        // ( ReserveCalculatorFlag == NULL )
        ReserveCalculator = CalcReserve;
        ReserveCalculator.DateReserve = дата;
        ReserveCalculator.RsvClass = АКлассифРВП;
        ReserveCalculator.RsvClassLoans = АКлассифРВПС;
// Для портфеля не вычисляем резерв по оффшору
//        ReserveCalculator.RsvClassOffshore = КлассифРОФШ( дата );
        ReserveCalculator.GroupRisk = АГруппаРиска;
        ReserveCalculator.ProcentReserve = CaseRecord.ReservePercent;
// Для портфеля не вычисляем резерв по оффшору
//        ReserveCalculator.ProcentReserveOffshore = ПроцентРезерваОФШ( дата );

// Для портфеля не вычисляем резерв по оффшору
/*
        var ruracc = АНомерЛицевого;
        if( АВалютаID != rurID )
            ruracc = АНомерСчетаПокрытия;
        end;
        if( ( ruracc != NULL ) and ( ruracc != "" ) )
            ReserveCalculator.MaxRest = GetMaxAccRest( АГлава, ruracc, ПредДатаОтчета, ДатаОтчета );
            ReserveCalculator.DebetTurn = GetAverageAccDebetTurn( АГлава, ruracc, /*ПредДатаОтчета,*/ ДатаОтчета );
        end;
*/
        ЗначенияПоСчетам( дата, ReserveCalculator.Rest, ReserveCalculator.MarketCost,
                ReserveCalculator.RestAmortization, ReserveCalculator.MarketCostSecurity,
                ReserveCalculator.MarketCostSecurityByCategory );

// На самом деле это свойство вообще не нужно.
//        ReserveCalculator.EnsuringCategory = КатегорОбеспеч( дата, true );

        ReserveCalculatorFlag = true;
        return ReserveCalculator;
    END;

    // Величина расчётного резерва на возможные потери для портфеля.
    MACRO РасчетРезервРВП( дата )
        var rc = КлассВычисленияРезерва( дата );
        var res;

        if( rc != NULL )
            res = rc.CalcReserveLoss( );
        end;
        if( res == NULL )
            res = $0;
        end;
        return res;

        OnError( er )
        // Никаких сообщений не надо, всё уже выведено при попытке получить
        // необходимые параметры, из-за отсутствия которых и ошибка
        return $0;
    END;

    // Величина расчётного резерва на возможные потери для портфеля.
    MACRO РасчетРезервРВПС( дата )
        var rc = КлассВычисленияРезерва( дата );
        var res;

        if( rc != NULL )
            res = rc.CalcReserveLoans( );
        end;
        if( res == NULL )
            res = $0;
        end;
        return res;

        OnError( er )
        // Никаких сообщений не надо, всё уже выведено при попытке получить
        // необходимые параметры, из-за отсутствия которых и ошибка
        return $0;
    END;

    // Величина фактического резерва на возможные потери для портфеля.
    MACRO ФактРезервРВП( дата )
        var res = GetReserveAccount( АНомер );
        if( res == NULL )
            // Тут тоже надо бы отругаться.
            return $0;
        end;
        res = GetFactReserve( res, дата, АКлассифРВП );
        if( res == NULL )
// Для портфеля у нас нет ErrorStr (пока).
//            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОПортфеле. Не определено значение фактически созданного РВП.";
            return $0;
        end;
        return abs( res );
    END;

    // Величина фактического резерва на возможные потери по ссудам для портфеля.
    MACRO ФактРезервРВПС( дата )
        var res = GetReserveAccount( АНомер );
        if( res == NULL )
            // Тут тоже надо бы отругаться.
            return $0;
        end;
        res = GetFactReserveLoans( res, дата, АКлассифРВПС );
        if( res == NULL )
// Для портфеля у нас нет ErrorStr (пока).
//            ErrorStr = ErrorStr + " !ОШИБКА: Сообщение_ИнформацияОПортфеле. Не определено значение фактически созданного РВПС.";
            return $0;
        end;
        return abs( res );
    END;
END;

/******************************************************************************
    Класс "Проводка"
*******************************************************************************/
/*CLASS КПроводка( )

    VAR 
        АСуществует,
        АСумма,
        АДата,
        АСчетДт = КЛицевойСчет(),
        АСчетКт = КЛицевойСчет();

    private VAR
        doc       :TBFile,
        arhdocV   :TBFile,
        arhdocR   :TBFile;

    VAR /* вспомогательные свойства */
        ErrorStr = "";
    /************************************************************************
      Метод инициализации свойств финансового инструмента
    ************************************************************************/
    MACRO Инициализация( АНомерЛицевого, АГлава, АВалютаID, АВидСчета, АДата )

        АСуществует = FALSE;
        /* читаем запись из БД */
        if( АВалютаID != 0 ) /* не рубли */
         doc = arhdocV;
        else
         doc = arhdocR;
        end;
        if( АВидСчета == "П" )
          doc.Keynum = 3;
          doc.Rec.Account_Receiver = АНомерЛицевого;
        else
          doc.Keynum = 2;
          doc.Rec.Account_Payer    = АНомерЛицевого;
        end;
        doc.Rec.Chapter = АГлава;
        doc.Rec.Code_Currency = АВалютаID;
        doc.Rec.Date_Carry = АДата;

        АСуществует = doc.GetEQ() and
                      ( doc.Rec.Chapter == АГлава ) and
                      ( doc.Rec.Code_Currency == АВалютаID ) and
                      ( ( ( АВидСчета == "П" ) and
                          ( doc.Rec.Account_Receiver == АНомерЛицевого ) ) or
                        ( ( АВидСчета == "А" ) and
                          ( doc.Rec.Account_Payer == АНомерЛицевого ) ) );
        if( not АСуществует )
           ErrorStr = String( "Ошибка инициализации проводки лицевого ", АНомерЛицевого );
        else
          /* Определяем все атрибуты */
         if( not АСчетДт.Инициализация( doc.Rec.Account_Payer,    NULL, АГлава ) or
             not АСчетКт.Инициализация( doc.Rec.Account_Receiver, NULL, АГлава ) )
          АСуществует = FALSE;
          ErrorStr = String( "Ошибка инициализации проводки лицевого ", АНомерЛицевого );
          return FALSE;

         end;
        end;
        Return АСуществует;

    END;

    /************************************************************************
      Конструктор класса
    ************************************************************************/
    arhdocV   = TBFile( "arhdoc$.dbt",  "R", 0, "arhdoc$.dbt",  "bank.def" );
    arhdocR   = TBFile( "arhdoc.dbt",   "R", 0, "arhdoc.dbt",   "bank.def" );
    OnError( er )
    msgbox( er.Message, "|Модуль:", er.Module, "|Строка:", er.Line );
    Exit( 1 );
END; /*CLASS КПроводка*/

КП = КПроводка;
  */
