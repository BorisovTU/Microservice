/*
$Name:          TBalanceData.mac
$Module:        Регламентируемая отчетность
$Description:   Фор. Класс получения данных баланса
*/

/*─────────────────────────────────────────────────────────────────────────────────────────────────┐
  RS-Bank V6                                                                        R-Style Softlab
  Файл подсистемы "Регламентируемая отчетность"

  Класс получения данных баланса

  Создан: 20.04.2007 - Ser.
└─────────────────────────────────────────────────────────────────────────────────────────────────*/

import rcw;
import balanceAttribute;

private const ZERO_DATE = Date(0,0,0);

macro isLess(v1 : Variant, v2 : Variant) : Integer
    var v1Date = Date(v1);

    if (v1Date != ZERO_DATE)
        var v2Date = Date(v2);
        if (v2Date != ZERO_DATE)
            v1 = v1Date;
            v2 = v2Date;
        end;
    end;

    if (v1 < v2)
        return -1;
    elif (v1 == v2)
        return 0;
    end;

    return 1;
end;

class TBalanceData()
    private var m_report            : Object = RcbApplication().currentReport;

    private var m_balanceReportPool = RcbArray();

    private var m_errorMesssage = "";

    private var m_isCalculated : Bool = null;

    local class TDataStruct(balance : String, restDate : Date, roubleRest : Money, currencyRest : Money, roubleScaledRest : Double, currencyScaledRest : Double)

        var m_balance            : String = balance;
        var m_restDate           : Date   = restDate;
        var m_roubleRest         : Money  = roubleRest;
        var m_roubleScaledRest   : Money  = roubleScaledRest;
        var m_currencyRest       : Money  = currencyRest;
        var m_currencyScaledRest : Money  = currencyScaledRest;

        macro getBalance()
            return m_balance;
        end;

        macro getRestDate()
            return m_restDate;
        end;

        macro getRoubleRest()
            return m_roubleRest;
        end;

        macro getRoubleScaledRest()
            return m_roubleScaledRest;
        end;

        macro getCurrencyRest()
            return m_currencyRest;
        end;

        macro getCurrencyScaledRest()
            return m_currencyScaledRest;
        end;
    end;

    macro isWorkDate(day : Date) : Bool
        var serviceKind;
        var isBalance = false;
        var res;

        if (global.parameters.isCalendarWeekends())
            return isWorkDayBranch(day, m_report.context.departmentCode) == 1;
        else
            res = getDateAttr(day, serviceKind, isBalance, m_report.context.departmentCode);
            return isBalance;
        end;
    end;

    private macro createPreviouseBalanceReport(dimension)
        var context = m_report.context;
        var d, m, y;
        var prevEndDate;
        var prevBeginDate;
        var balanceReport;

        prevEndDate = global.parameters.getBeginDate() - 1;
        DateSplit(prevEndDate, d, m, y);
        prevBeginDate = Date(1, m, y);

        DateSplit(global.parameters.getBeginDate(), d, m, y);

        var dataset = TRsbDataset("SELECT t_bdPrevDate AS t_beginDate,"
                         + "\n" + "       t_bdRepDate  AS t_endDate"
                         + "\n" + "  FROM dcy_rdate_dbt rdate,"
                         + "\n" + "       dcy_forms_dbt forms"
                         + "\n" + " WHERE forms.t_szFormName  = 'Балансовые счета'"
                         + "\n" + "   AND rdate.t_organizationStructure = " + context.organizationStructure
                         + "\n" + "   AND rdate.t_issueMode   = " + context.issueMode
                         + "\n" + "   AND rdate.t_isSummary   = " + rcbSqlBool(context.isSummaryMode)
                         + "\n" + "   AND rdate.t_iFormId     = forms.t_iFormId"
                         + "\n" + "   AND rdate.t_iNumDprt    = " + context.departmentCode
                         + "\n" + "   AND rdate.t_cVarKind    = CHR(0)"
                         + "\n" + "   AND rdate.t_bdRepDate   = " + getSqlDate(context.period.beginDate - 1)
                         //если отчетный период месяц или ДНОП является первым днем месяца и ДООП не является последним днем месяца - ищем баланс за месяц,
                         //если нет - любой баланс с ДООП = (ДНОП ФОР) - 1
                         + "\n" + ternary(   global.reportingPeriodIsEqualMonth
                                          or (global.parameters.isBeginDateFallsOnFirstDayInMonth() and not global.parameters.isEndDateFallsOnLastDayInMonth()),
                                          "   AND rdate.t_bdPrevDate  = " + getSqlDate(prevBeginDate),
                                          "")
                         + "\n" + " ORDER BY t_bdPrevDate ASC");

        dataset.setFieldType("beginDate", V_DATE);
        dataset.setFieldType("endDate",   V_DATE);

        while (dataset.next())
            balanceReport = rcbApplication.objectFactory.createReport("Балансовые счета", RcbReportContext(RcbPeriod(Date(dataset.beginDate),
                                                                                                                     Date(dataset.endDate)),
                                                                                                           context.departmentCode,
                                                                                                           context.issueMode,
                                                                                                           context.organizationStructure,
                                                                                                           context.isSummaryMode));
            if (TBaseBalanceAttribute("БАЛАНС", balanceReport).isBalanceCalculated(1, dimension))
                return balanceReport;
            end;
        end;

        return rcbApplication.objectFactory.createReport("Балансовые счета", RcbReportContext(RcbPeriod(ternary(    global.reportingPeriodIsEqualMonth
                                                                                                                or (global.parameters.isBeginDateFallsOnFirstDayInMonth() and not global.parameters.isEndDateFallsOnLastDayInMonth()),
                                                                                                                prevBeginDate,
                                                                                                                Date(0, 0, 0)
                                                                                                               ),
                                                                                                        prevEndDate),
                                                                                              context.departmentCode,
                                                                                              context.issueMode,
                                                                                              context.organizationStructure,
                                                                                              context.isSummaryMode));
    end;

    private macro initializeBalanceReportPool()
        var dateCount = ternary(global.reportingPeriodIsEqualMonth == true,
                                global.parameters.getPeriod().daysQuantity,
                                global.parameters.getPeriod().daysQuantity + 1);    //если период рассчета ФОР != месяц, то создаем баланс за каждый рабочий день (включаяя ДООП)
        var i = 0;
        var d, m, y;
        var beginDate;

        var context      = null;
        var currentDate  = null;
        var report       = null;
        var br;

        while (i < dateCount)
            currentDate = global.parameters.getBeginDate() + i;
            // 29.05.2014 ABP Балансы формируем за каждый день отчетного периода, кроме последнего дня
            context = RcbReportContext(RcbPeriod(currentDate, currentDate),
                                       m_report.context.departmentCode,
                                       m_report.context.issueMode,
                                       m_report.context.organizationStructure,
                                       m_report.context.isSummaryMode);

            report = RcbApplication().objectFactory.createReport(m_report.form.id, context);
            m_balanceReportPool.push_back(report.createOtherReport("Балансовые счета"));

            i = i + 1;
        end;

        //если отчетный период == месяц, то создаем баланс с ДНОП по ДООП
        if (global.reportingPeriodIsEqualMonth)
            br = m_report.createOtherReport("Балансовые счета");
            m_balanceReportPool.push_back(br);
        //если ДООП - последний день месяца, то создаем баланс с 1-го числа по ДООП
        elif (    global.parameters.isEndDateFallsOnLastDayInMonth()
              and not global.parameters.isBeginDateFallsOnFirstDayInMonth())

            DateSplit(global.parameters.getBeginDate(), d, m, y);
            beginDate = Date(1, m, y);
            context = RcbReportContext(RcbPeriod(beginDate, global.parameters.getEndDate()),
                                       m_report.context.departmentCode,
                                       m_report.context.issueMode,
                                       m_report.context.organizationStructure,
                                       m_report.context.isSummaryMode);
            report = RcbApplication().objectFactory.createReport(m_report.form.id, context);
            m_balanceReportPool.push_back(report.createOtherReport("Балансовые счета"));
        end;

        //создаем баланс за предыдущий период (месяц или не месяц)
        m_balanceReportPool.push_back(createPreviouseBalanceReport(m_report.dimension));
    end;

    macro isCalculated()
        if (m_isCalculated != null)
            return m_isCalculated;
        end;

        if (m_balanceReportPool.isEmpty())
            initializeBalanceReportPool();
        end;

        m_isCalculated = true;

        m_balanceReportPool.moveFirst();
        while (m_balanceReportPool.moveNext())
            // 29.05.2014 ABP Проверяем рассчитанность балансов для периода, равного периоду расчета ФОР
            //                и периода, примыкающего к периоду расчета ФОР
            // сюда же попадет проверка рассчитанности баланса за ДООП при условии период расчета != месяц
            if (in(m_balanceReportPool.getCurrentItem().context.period.endDate,
                   m_report.context.period.beginDate - 1,
                   m_report.context.period.endDate
                  )
               )
                if (not TBaseBalanceAttribute("БАЛАНС", m_balanceReportPool.getCurrentItem()).isBalanceCalculated(1, m_report.dimension))
                    m_errorMesssage = "Отсутствует рассчитанная форма \"Балансовые счета\" за период "
                                      + ternary(m_balanceReportPool.getCurrentItem().context.period.beginDate != Date(0, 0, 0),
                                                "с " + String(m_balanceReportPool.getCurrentItem().context.period.beginDate:f) + " ",   //вариант: период рассчета == месяц, баланса нет
                                                ""                                                                                      //вариант: период рассчета != месяц, баланса нет
                                               )
                                      + "по " + String(m_balanceReportPool.getCurrentItem().context.period.endDate:f);
                    m_isCalculated = false;
                    break;
                end;
            else
                // 29.05.2014 ABP Проверяем рассчитанность балансов для каждого рабочего (с точки зрения алгоритма ФОР) дня
                //                периода, кроме последнего дня
                if (not isWorkDate(m_balanceReportPool.getCurrentItem().context.period.endDate))
                    continue;
                end;

                if (not TBaseBalanceAttribute("БАЛАНС", m_balanceReportPool.getCurrentItem()).isBalanceCalculated(1, m_report.dimension))
                    m_errorMesssage = "Отсутствует рассчитанная форма \"Балансовые счета\" за "
                                     + String(m_balanceReportPool.getCurrentItem().context.period.endDate:f);
                    m_isCalculated = false;
                    break;
                end;
            end;
        end;

        return m_isCalculated;
    end;

    macro hasData(inRestDate : Date) : bool
        m_balanceReportPool.moveFirst();
        while (m_balanceReportPool.moveNext())
            if (    (m_balanceReportPool.getCurrentItem().context.period.endDate == inRestDate - 1)
                and (TBaseBalanceAttribute("БАЛАНС", m_balanceReportPool.getCurrentItem()).isBalanceCalculated(1, m_report.dimension)))
                return true;
            end;
        end;

        return false;
    end;

    macro getErrorMessage()
        return m_errorMesssage;
    end;

    private macro getBalanceReport(outRestDate : Date) : RcbReport
        if (m_balanceReportPool.isEmpty())
            initializeBalanceReportPool();
        end;

        m_balanceReportPool.moveFirst();
        while (m_balanceReportPool.moveNext())
            if (m_balanceReportPool.getCurrentItem().context.period.endDate == outRestDate)
                return m_balanceReportPool.getCurrentItem();
            end;
        end;

        return null;
    end;

    macro getBalanceReports()
        if (isCalculated())
            var result = TArray(m_balanceReportPool.size);

            m_balanceReportPool.moveFirst();
            while (m_balanceReportPool.moveNext())
                result[result.size] = m_balanceReportPool.getCurrentItem();
            end;

            return result;
        end;

        return null;
    end;

    macro getValues(balance : String, inRestDate : Date)

        var roubleRest           : Money  = $0.0;
        var roubleScaledRest     : Double = 0.0;
        var currencyRest         : Money  = $0.0;
        var currencyScaledRest   : Double = 0.0;
        var currencyDebet        : Money  = $0.0;
        var scaledCurrencyDebet  : Double = 0.0;
        var currencyCredit       : Money  = $0.0;
        var scaledCurrencyCredit : Double = 0.0;
        var roubleDebet          : Money  = $0.0;
        var scaledRoubleDebet    : Double = 0.0;
        var roubleCredit         : Money  = $0.0;
        var scaledRoubleCredit   : Double = 0.0;

        var balanceAttribute;
        var attributeValueA : Object = NULL;
        var attributeValueP : Object = NULL;
        var balanceReport;

        while (inRestDate > m_report.context.period.beginDate)
            if (hasData(inRestDate))
                break;
            else
                inRestDate = inRestDate - 1;
            end;
        end;
        balanceReport = getBalanceReport(inRestDate - 1);

        if (isCalculated() and (balanceReport != null))

            balanceAttribute = TBalanceAttribute("БАЛАНС",  balanceReport);
            balanceAttribute.getBalanceAttribute(1, balance, false);

            if (balanceAttribute.getKindBalance() == "П")
                attributeValueP = balanceAttribute.getOutRestPassive();
            else
                attributeValueA = balanceAttribute.getOutRestActive();
            end;

            if   (attributeValueA != NULL)
                currencyRest       = balanceAttribute.getOutRestCurActive().exact;
                currencyScaledRest = balanceAttribute.getOutRestCurActive().scaled;
                roubleRest         = balanceAttribute.getOutRestNatCurActive().exact;
                roubleScaledRest   = balanceAttribute.getOutRestNatCurActive().scaled;
            elif (attributeValueP != NULL)
                currencyRest       = balanceAttribute.getOutRestCurPassive().exact;
                currencyScaledRest = balanceAttribute.getOutRestCurPassive().scaled;
                roubleRest         = balanceAttribute.getOutRestNatCurPassive().exact;
                roubleScaledRest   = balanceAttribute.getOutRestNatCurPassive().scaled;
            else
                /*Если переменная не найдена, то возвращаем нулевые значения*/
                return TDataStruct(balance, inRestDate, roubleRest, currencyRest, roubleScaledRest, currencyScaledRest);
            end;

            currencyDebet        = balanceAttribute.getDebetCur().exact;
            scaledCurrencyDebet  = balanceAttribute.getDebetCur().scaled;

            currencyCredit       = balanceAttribute.getCreditCur().exact;
            scaledCurrencyCredit = balanceAttribute.getCreditCur().scaled;

            roubleDebet          = balanceAttribute.getDebetNatCur().exact;
            scaledRoubleDebet    = balanceAttribute.getDebetNatCur().scaled;

            roubleCredit         = balanceAttribute.getCreditNatCur().exact;
            scaledRoubleCredit   = balanceAttribute.getCreditNatCur().scaled;
        end;

        return TDataStruct(balance, inRestDate, roubleRest, currencyRest, roubleScaledRest, currencyScaledRest);
    end;
end;

class TBalanceData_4217()
    private var m_jvm : Object;

    private var m_report : Object;
    private var m_balanceReportPool : Object;
    private var m_balanceReportArray : TArray;
    private var m_errorMessage : String;
    private var m_isCalculated : Bool;
    private var m_workDates : Object;

    class TBoolean(_value)
        var value : Bool = _value;
    end;

    class TDataStruct(balance : String, restDate : Date, roubleRest : Money, currencyRest : Money, roubleScaledRest : Double, currencyScaledRest : Double)
        private const m_balance            : String = balance;
        private const m_restDate           : Date   = restDate;
        private const m_roubleRest         : Money  = roubleRest;
        private const m_roubleScaledRest   : Money  = roubleScaledRest;
        private const m_currencyRest       : Money  = currencyRest;
        private const m_currencyScaledRest : Money  = currencyScaledRest;

        macro getBalance()
            return m_balance;
        end;

        macro getRestDate()
            return m_restDate;
        end;

        macro getRoubleRest()
            return m_roubleRest;
        end;

        macro getRoubleScaledRest()
            return m_roubleScaledRest;
        end;

        macro getCurrencyRest()
            return m_currencyRest;
        end;

        macro getCurrencyScaledRest()
            return m_currencyScaledRest;
        end;
    end;

    macro isOperDay(day : Date) : Bool
        var dataset = TRsbDataset("SELECT 1"
                         + "\n" + "  FROM dCurDate_dbt curDate "
                         + "\n" + " WHERE curDate.t_curDate = " + getSqlDate(day)
                         + "\n" + "   AND curDate.t_branch    = " + m_report.context.departmentCode
                                 );
        return dataset.next();
    end;

    macro isWorkDate(day : Date) : Bool
        var serviceKind;
        var isBalance = false;
        var res       = null;

        res = m_workDates.get(day);
        if (res == null)
            res = isOperDay(day);
            m_workDates.put(day, TBoolean(res));
        else
            res = res.value
        end;

        return res;
    end;

    macro isFirstDayInMonth(day : Date)
        var d;
        dateSplit(day, d);

        return d == 1;
    end;

    macro isLastDayInMonth(day : Date)
        var m;
        var y;
        dateSplit(day, NULL, m, y);

        if (m == 12)
            m = 1;
            y = y + 1;
        else
            m = m + 1;
        end;

        return day == Date(1, m, y) - 1;
    end;

    // 16.02.2017 ABP Отличается от аналогичной функции в ф.345 - может вернуть текущую дату, если день рабочий
    macro getNearPreviosWorkDay(day : Date)
        var previosWorkDay = day;

        while (not isWorkDate(previosWorkDay))
            previosWorkDay = previosWorkDay - 1;
        end;

        return previosWorkDay;
    end;

    // Формирование пула балансовых отчетов.
    // При расчете по данным баланса в пуле должны оказаться:
    // 1. Балансы за каждый рабочий день периода
    // 2. Для ОП ФОР с ДООП равной последнему календарному дню месяца:
    //    - месячный баланс, если он рассчитан
    //    - ежедневный баланс за ДООП, если он рассчитан и при этом не рассчитан месячный баланс
    // При расчете без данных баланса в пуле должны оказаться:
    // 1. Баланс за ближайший меньший к ДООП или равный ей рабочий день, если:
    //    - ДООП не приходится на последний календарный день месяца
    //    - за ДООП нет ни месячного, ни ежедневного рассчитанных балансов
    // 2. Для ОП ФОР с ДООП равной последнему календарному дню месяца:
    //    - месячный баланс, если он рассчитан
    //    - ежедневный баланс за ДООП, если он рассчитан и при этом не рассчитан месячный баланс
    private macro initializeBalanceReportPool()
        const endDate = global.parameters.getEndDate();
        const isEndDateFallsOnLastDayInMonth = global.parameters.isEndDateFallsOnLastDayInMonth();
        var context = null;

        m_balanceReportPool.clear();

        var currentDate;
        if (global.parameters.isDataBalance()) //При расчёте по данным баланса формируем отчеты за каждый рабочий день отчетного периода
            currentDate = global.parameters.getBeginDate();
        elif (not isEndDateFallsOnLastDayInMonth)
            currentDate = getNearPreviosWorkDay(endDate);
        else //Если расчет без данных баланса и ДООП приходится на последний день месяца, то баланс не формируем
            currentDate = endDate + 1;
        end;

        while (currentDate <= endDate)
            if (not isWorkDate(currentDate))
                currentDate = currentDate + 1;
                continue;
            end;

            context = RcbReportContext(RcbPeriod(currentDate, currentDate),
                                       m_report.context.departmentCode,
                                       m_report.context.issueMode,
                                       m_report.context.organizationStructure,
                                       m_report.context.isSummaryMode);

            m_balanceReportPool.put(currentDate, RcbApplication().objectFactory.createReport("Балансовые счета", context));

            currentDate = currentDate + 1;
        end;

        //если ДООП приходится на последний день месяца, то добавляем _рассчитанный_ баланс за этот месяц
        if (isEndDateFallsOnLastDayInMonth)
            var month;
            var year;
            dateSplit(endDate, null, month, year);

            context = RcbReportContext(RcbPeriod(Date(1, month, year), endDate),
                                       m_report.context.departmentCode,
                                       m_report.context.issueMode,
                                       m_report.context.organizationStructure,
                                       m_report.context.isSummaryMode);

            var balanceReport = RcbApplication().objectFactory.createReport("Балансовые счета", context);

            if (TBaseBalanceAttribute("БАЛАНС", balanceReport, TBalanceAttributeMode().READ_ONLY).isBalanceCalculated(1, m_report.dimension))
                m_balanceReportPool.put(endDate, balanceReport);
            else
                balanceReport = m_balanceReportPool.get(endDate);
                if (balanceReport == null)
                    context = RcbReportContext(RcbPeriod(endDate, endDate),
                                               m_report.context.departmentCode,
                                               m_report.context.issueMode,
                                               m_report.context.organizationStructure,
                                               m_report.context.isSummaryMode);
                    balanceReport = RcbApplication().objectFactory.createReport("Балансовые счета", context);
                end;
                if (TBaseBalanceAttribute("БАЛАНС", balanceReport, TBalanceAttributeMode().READ_ONLY).isBalanceCalculated(1, m_report.dimension))
                    m_balanceReportPool.put(endDate, balanceReport);
                else
                    m_balanceReportPool.remove(endDate);
                end;
            end;

            //Если за ДООП нет ни месячного, ни ежедневного баланса, то обязательно должен быть рассчитанный баланс за ближайший рабочий день
            if (m_balanceReportPool.get(endDate) == null)
                currentDate = getNearPreviosWorkDay(endDate);
                if (m_balanceReportPool.get(currentDate) == null)
                    context = RcbReportContext(RcbPeriod(currentDate, currentDate),
                                               m_report.context.departmentCode,
                                               m_report.context.issueMode,
                                               m_report.context.organizationStructure,
                                               m_report.context.isSummaryMode);
                    m_balanceReportPool.put(currentDate, RcbApplication().objectFactory.createReport("Балансовые счета", context));
                end;
            end;
        end;
    end;

    macro isCalculated()
        macro getErrorMessage(period : Object)
            var msg : String;
            if (period.endDate == period.beginDate)
                msg = String(period.endDate:f);
            else
                msg = "период с " + String(period.beginDate:f) + " по " + String(period.endDate:f);
            end;
            return msg;
        end;

        if (m_isCalculated != null)
            return m_isCalculated;
        end;

        if (m_balanceReportPool.isEmpty())
            initializeBalanceReportPool();
        end;

        m_isCalculated = true;
        var errors = RcbArray();
        var balanceReportIterator = m_balanceReportPool.values().iterator();
        while (balanceReportIterator.hasNext())
            var balanceReport = balanceReportIterator.next();
            if (not TBaseBalanceAttribute("БАЛАНС", balanceReport, TBalanceAttributeMode().READ_ONLY).isBalanceCalculated(1, m_report.dimension))
                errors.push_back(getErrorMessage(balanceReport.context.period));
                m_isCalculated = false;
            end;
        end;

        if (errors.size > 0)
            m_errorMessage = "Отсутствует рассчитанная форма \"Балансовые счета\" за:";
            qSort(errors, "isLess");
            for (var error, errors)
                m_errorMessage = m_errorMessage + "\n\t" + error;
            end;
        end;

        return m_isCalculated;
    end;

    macro getErrorMessage()
        return m_errorMessage;
    end;

    macro getBalanceReports()
        if (not isCalculated())
            return null;
        end;

        if (m_balanceReportArray != null)
            return m_balanceReportArray;
        end;

        m_balanceReportArray = TArray();
        var balanceReportIterator = m_balanceReportPool.values().iterator();
        while (balanceReportIterator.hasNext())
            m_balanceReportArray[m_balanceReportArray.size] = balanceReportIterator.next();
        end;

        return m_balanceReportArray;
    end;

    macro hasData(restDate : Date) : Bool
        if (not isCalculated())
            return false;
        end;

        return true;
    end;

    macro getValues(balance : String, restDate : Date)
        var roubleRest         : Money  = $0.0;
        var roubleScaledRest   : Double = 0.0;
        var currencyRest       : Money  = $0.0;
        var currencyScaledRest : Double = 0.0;

        var balanceAttribute;
        var balanceReport;

        if (isCalculated())
            balanceReport = null;
            while (restDate >= m_report.context.period.beginDate)
                balanceReport = m_balanceReportPool.get(restDate);

                if (balanceReport == null)
                    restDate = restDate - 1;
                else
                    break;
                end;
            end;

            if (balanceReport == null)
                var context;
                var hasCalculatedBalance = false;
                restDate = m_report.context.period.beginDate - 1;
                while (not hasCalculatedBalance)
                    if (isLastDayInMonth(restDate))
                        var month;
                        var year;
                        dateSplit(restDate, null, month, year);
                        context = RcbReportContext(RcbPeriod(Date(1, month, year), restDate),
                                                   m_report.context.departmentCode,
                                                   m_report.context.issueMode,
                                                   m_report.context.organizationStructure,
                                                   m_report.context.isSummaryMode);
                        balanceReport = RcbApplication().objectFactory.createReport("Балансовые счета", context);
                        hasCalculatedBalance = TBaseBalanceAttribute("БАЛАНС", balanceReport, TBalanceAttributeMode().READ_ONLY).isBalanceCalculated(1, m_report.dimension);
                    end;

                    if (not hasCalculatedBalance)
                        context = RcbReportContext(RcbPeriod(restDate, restDate),
                                                   m_report.context.departmentCode,
                                                   m_report.context.issueMode,
                                                   m_report.context.organizationStructure,
                                                   m_report.context.isSummaryMode);
                        balanceReport = RcbApplication().objectFactory.createReport("Балансовые счета", context);
                        hasCalculatedBalance = TBaseBalanceAttribute("БАЛАНС", balanceReport, TBalanceAttributeMode().READ_ONLY).isBalanceCalculated(1, m_report.dimension);
                    end;

                    restDate = restDate - 1;
                end;
                m_balanceReportPool.put(m_report.context.period.beginDate, balanceReport);
            end;

            if (balanceReport != null)
                balanceAttribute = TBalanceAttribute("БАЛАНС", balanceReport, TBalanceAttributeMode.READ_ONLY);
                if (balanceAttribute.getBalanceAttribute(1, balance, false) != null)
                    currencyRest       = balanceAttribute.getOutRestCur().exact;
                    currencyScaledRest = balanceAttribute.getOutRestCur().scaled;
                    roubleRest         = balanceAttribute.getOutRestNatCur().exact;
                    roubleScaledRest   = balanceAttribute.getOutRestNatCur().scaled;
                end;
            end;
        end;

        return TDataStruct(balance, restDate, roubleRest, currencyRest, roubleScaledRest, currencyScaledRest);
    end;

    private macro constructorTBalanceData_4217()
        m_jvm = CreateObject("rsjvm", "TJavaHost", "GlobalJavaHost");

        m_report = RcbApplication().currentReport;
        m_balanceReportPool = m_jvm.createJavaObject("java.util.HashMap", "<init>");
        m_balanceReportArray = null;
        m_errorMessage = "";
        m_isCalculated = null;
        m_workDates = m_jvm.createJavaObject("java.util.HashMap", "<init>");
    end;

    constructorTBalanceData_4217();
end;

/*Создаем единственный экземпляр класса*/
if (RcbApplication().currentReport.context.period.endDate >= RCB_I4217_DATE)
    global.balanceData = TBalanceData_4217();
else
    global.balanceData = TBalanceData();
end;
