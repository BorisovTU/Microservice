 /*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 4.3                                          R-Style Software Lab

  File Name   : form603.mac                               December 22,1997
  Programmer  : Чепелева Л.
  Description : Сведения об открытых корреспондентских счетах
                и остатках средств на них  N 603

  Comment     :   При формировании отчета учитываются остатки и обороты
                лицевых счетов, принадлежащих балансовым счетам из массива
                Bal1 ( по плану счетов 1998 года ).
                Есть возможность задать маски для номеров лицевых счетов с
                помощью массива MaskAccount1 ( в маске  "*" - любой символ ).
                 При выборе вида сумм "в тысячах рублей" для валютных счетов
                обороты и остатки получаются путем пересчета
                в рубли по курсу на соответствующую дату.
                 В настройках макроса необходимо определить номера планов
                счетов НомерПлана (рублевых) и НомерПланаВал (валютных),
                а также значения флага ПечатьНулевых - печати счетов при
                нулевых суммах.
                 Для клиентов с признаком "Нерезидент" вместо рег.номера
                и кода в соответствующие колонки выводится название страны и
                ее код.
                 В макросе Mac\cb\param.mac следует настроить
                дополнительные параметры банка ( рег.код, код ОКПО и т.д.).

  Modify: 27.02.98  Добавлен флаг "СортировкаКлиентов", который может принимать
               значения: ПоКодуКлиента и ПоКраткомуНазванию( в последнем случае
               в наименовании клиента выводится и его краткое название),
                    флаг "ПечатьРублевыхОтдельно", при значении TRUE
               которого печатаются сначала рублевые счета с группировкой по
               клиентам, затем валютные, при значении FALSE - печать
               счетов одного клиента рублевых и валютных вместе,
                    флаг "ТолькоОткрытые" - печать только открытых на
               отчетный период лицевых счетов (включая открытые и закрытые
               в течение этого периода счета).
                    Обеспечена сходимость по строке после округления остатков
               и оборотов корректировкой оборотов.

         30.01.02 LCh  Добавлен флаг ВалютаПоПокрытию, по умолчанию TRUE -
               для валютных счетов определение рублевых сумм по счетам покрытий,
               иначе пересчетом за каждый день периода.

         13.02.02 Зорина
               Вынесение настроек из макросов в справочник настроек
         03.09.04 Саркисова
               Учет исправительных оборотов

  Note        : Для получения правильных входящих остатков в рублях для
               валютных счетов для 1 месяца и 1 квартала 1998 года входящий
               курс на 01.01.98 делится на 1000.

          17.03.98  LCh  Наведен порядок с оборотами за период
    25.07.2005 BugZ SCR 69375 Фильтрация по ТС/РС.
└───────────────────────────────────────────────────────────────────────────*/
import  FIInter, CurrInter, param, rep_lib, lib_exp, cb_sql, form_exp, ReptCBInter, ReptCbCommon, PTInter, Chk_regD, cb_SQL, CTInter, rcb_date;
import balanceInter;
import rcbCoreInter;
import DepartmentFilter;

import param;

FILE pt     (party);                 /* Справочник субъектов    */
FILE ptown  (partyown) key 1;        /* Принадлежность субъектов к видам*/
//FILE objcod (objcode);               /* Коды субъектов*/

file clc  (country,"rsrfdb.def") key 2; /* Справочник стран            */
file bank (bankdprt);     /* Справочник отделений банков */
//FILE pers ( "person.dbt");     /* Справочник операционистов */

file acR (account);          /* Лицевые счета          */
file acC ("account$.dbt");   /* Лицевые валютные счета */
private var accountFilter = RcbAccountFilter();
file abR (accblnc);          /* Лицевые счета в плане балансовых */
file abC ("accblnc$.dbt");   /* Лицевые валютные счета в плане балансовых */

file balance ( balance);

/*file temp( "acc_clnt.dbt" ) write; /* Врем.файл */ */
file temp    ( "temp_501.tmp", "rcb_tmp.def" ) Normal; /* Врем.файл */
file temp_err( "acc_clnt.tmp" ) write; /* Врем.файл */


const  KindCODE  = 1,     /* Код */
       KindBIC = 3,       /* БИК */
       KindREGNUM = 13,   /* Рег.номер банка */
       KIND_OWN_CLIENT = 1;   /* Клиент */

const  ПоКодуКлиента = 1,
       ПоКраткомуНазванию = 2,
       Делитель = 1000.0; /* копейки в тысячи рублей */

const НеОпределено = 0,
      loro  = 1,
      kliko = 2;

private var isNormalizedData = false;
/*------------------ Настройка -----------------------------------*/
var ПечатнаяФорма,
    Экспорт,
    ЭкспортВ = НеОпределено,
    Контроль,
    First = true,
/*    NameDirExp = "",*/
            /* Текстовый файл отчета */
  NameFileRep = ReturnDirString("TEXTDIR", "TXTFILE") + "f603rep."+ trim(string( UserNumber:3:l:t )),
           /* Текстовый файл протокола контроля */
  NameFileCnt = ReturnDirString("TEXTDIR", "TXTFILE") + "f603cnt." + trim(string( UserNumber:3:l:t )),

  NameFileErr  = GetWorkFileName( "tmp_501e" );

           /* Текстовый файл протокола экспорта */
  NameFilePrt = ReturnDirString("TEXTDIR", "TXTFILE") + "f603prt." + trim(string( UserNumber:3:l:t ));

  MAXLEN   = 254;            /*Максимальная длина строки экспорта*/



VAR ДАТА1376У;

GetRegDate(  ДАТА1376У, "ДАТА_1376У");
if(  ДАТА1376У == DATE (0, 0, 0) )
  ДАТА1376У = date( 1, 4, 2004 );
end;

getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\КОНТРОЛЬ",
                  V_BOOL, Контроль, NULL );

var   НомерПлана     = ПолучитьРеальныйНомерПлана( ЛогическийПланСчетов, "А"),
/*      НомерПланаВал  = 0,        Номер плана валютных лиц/счетов    */
      ПечатьНулевых,   /* Печать счетов при нулевых значениях сумм  */
      ТолькоОткрытые,    /* Печать только открытых счетов      */
      ПечатьРублевыхОтдельно,
      ПечатьОтдельноПоРезидентности,
      ФормаНулевая = TRUE;
                                /* Флаг сортировки клиентов */
var  СортировкаКлиентов = ПоКраткомуНазванию, /* ПоКодуКлиента ;*/
     СортировкаПоБалансовым;

getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\ПЕЧАТЬ НУЛЕВЫХ",
                  V_BOOL, ПечатьНулевых, NULL );
getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\ТОЛЬКО ОТКРЫТЫЕ",
                  V_BOOL, ТолькоОткрытые, NULL );
getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\ПЕЧАТЬ РУБЛЕВЫХ ОТДЕЛЬНО",
                  V_BOOL, ПечатьРублевыхОтдельно, NULL );
getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\ОТДЕЛЬНО ПО РЕЗИДЕНТНОСТИ",
                  V_BOOL, ПечатьОтдельноПоРезидентности, NULL );
getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\АПОСТРОФЫ",
                  V_BOOL, Апострофы, NULL );
getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\СОРТИРОВКА\\ПО КЛИЕНТАМ",
                  V_INTEGER, СортировкаКлиентов, NULL );
getRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 603\\СОРТИРОВКА\\ПО БАЛАНСОВЫМ",
                  V_BOOL, СортировкаПоБалансовым, NULL );

array Bal1,         /* Список номеров балансовых счетов */
      MaskAccount1; /* Маски номеров лиц.счетов для каждого бал.счета */

  Bal1(0)  = "30109";  MaskAccount1(0)  = "*********";
  Bal1(1)  = "30110";  MaskAccount1(1)  = "*********";
  Bal1(2)  = "30111";  MaskAccount1(2)  = "*********";
  Bal1(3)  = "30112";  MaskAccount1(3)  = "*********";
  Bal1(4)  = "30113";  MaskAccount1(4)  = "*********";
  Bal1(5)  = "30114";  MaskAccount1(5)  = "*********";
  Bal1(6)  = "30115";  MaskAccount1(6)  = "*********";
  Bal1(7)  = "30116";  MaskAccount1(7)  = "*********";
  Bal1(8)  = "30117";  MaskAccount1(8)  = "*********";
  Bal1(9)  = "30118";  MaskAccount1(9)  = "*********";
  Bal1(10) = "30119";  MaskAccount1(10) = "*********";
  Bal1(11) = "30122";  MaskAccount1(11) = "*********";
  Bal1(12) = "30123";  MaskAccount1(12) = "*********";

array
   RestInBal,    RestInBalTh,    БС_RestInBalTh,
   RestOutBal,   RestOutBalTh,   БС_RestOutBalTh,
   KreditBal,    KreditBalTh,    БС_KreditBalTh,
   DebetBal,     DebetBalTh,     БС_DebetBalTh,
   RestInBal_C,  RestInBalTh_C,  БС_RestInBalTh_C,
   RestOutBal_C, RestOutBalTh_C, БС_RestOutBalTh_C,
   KreditBal_C,  KreditBalTh_C,  БС_KreditBalTh_C,
   DebetBal_C,   DebetBalTh_C,   БС_DebetBalTh_C;

/*----------------------------------------------------------------*/
var RE;

Var
  NumBal = asize(Bal1),
  СуммыВРублях = TRUE,
  NotResident = "",
  BegDat,  EndDat,
  InDat,   RepDat;

const
  FLAG_ALL = 0,
  FLAG_RUB = 1,
  FLAG_CUR = 2;

var  count = 0,
     RegNumber = "", BIC = "",
     RestIn, Debet, Kredit, RestOut; /* Суммы по текущему лиц.счету */

var First1 = true,
    First2 = true,
    БалансРассчитан,
    WasHeadNorm = false,
    first_err_th = true,
    first_err_rub = true;
/***************************************************************************************************
 *  Константы
 **************************************************************************************************/
private const CHAPTER_LEVEL = 0;
private const BALANCE_LEVEL = 1;
private const ACCOUNT_LEVEL = 2;

/***************************************************************************************************
 *  Глобальные переменные
 **************************************************************************************************/

private class TGlobal()
    /*
     *  Перменная хранит ссылку на балансовый отчет за текуцщий период.
     *  Используется для процедуры нормализации.
     */
    var balanceReport = NULL;
end;

private var global = TGlobal();
/***************************************************************************************************
 *  Класс получения данных баланса
 **************************************************************************************************/
private class TBalanceData()

    local class TDataStruct(balance : String, inRestA : Money, inRestP : Money, debet : Money, credit : Money, outRestA : Money, outRestP : Money,
                            inRestAV : Money, inRestPV : Money, debetV : Money, creditV : Money, outRestAV : Money, outRestPV : Money,
                            inRestAR : Money, inRestPR : Money, debetR : Money, creditR : Money, outRestAR : Money, outRestPR : Money)

        var m_balance   : String = balance;
        var m_inRestA   : Money  = inRestA;
        var m_inRestP   : Money  = inRestP;
        var m_debet     : Money  = debet;
        var m_credit    : Money  = credit;
        var m_outRestA  : Money  = outRestA;
        var m_outRestP  : Money  = outRestP;

        var m_inRestAV  : Money  = inRestAV;
        var m_inRestPV  : Money  = inRestPV;
        var m_debetV    : Money  = debetV;
        var m_creditV   : Money  = creditV;
        var m_outRestAV : Money  = outRestAV;
        var m_outRestPV : Money  = outRestPV;

        var m_inRestAR  : Money  = inRestAR;
        var m_inRestPR  : Money  = inRestPR;
        var m_debetR    : Money  = debetR;
        var m_creditR   : Money  = creditR;
        var m_outRestAR : Money  = outRestAR;
        var m_outRestPR : Money  = outRestPR;
    end;

    macro getValues(balance : String)

        var inRestThA     : Money = $0.0;
        var outRestThA    : Money = $0.0;
        var inRestThP     : Money = $0.0;
        var outRestThP    : Money = $0.0;
        var debetTh       : Money = $0.0;
        var creditTh      : Money = $0.0;
        var tempInRestTh  : Money = $0.0;

        var inRestThAV    : Money = $0.0;
        var outRestThAV   : Money = $0.0;
        var inRestThPV    : Money = $0.0;
        var outRestThPV   : Money = $0.0;
        var debetThV      : Money = $0.0;
        var creditThV     : Money = $0.0;
        var tempInRestThV : Money = $0.0;

        var inRestThAR    : Money = $0.0;
        var outRestThAR   : Money = $0.0;
        var inRestThPR    : Money = $0.0;
        var outRestThPR   : Money = $0.0;
        var debetThR      : Money = $0.0;
        var creditThR     : Money = $0.0;
        var tempInRestThR : Money = $0.0;

        var attributeValueA : Object = NULL;
        var attributeValueP : Object = NULL;


        attributeValueA = global.balanceReport.AttributeValue("Бн" + balance + "__А");
        attributeValueP = global.balanceReport.AttributeValue("Бн" + balance + "__П");

        if   (attributeValueA != NULL)
            outRestThA = attributeValueA.scaled;
            outRestThAV = global.balanceReport.AttributeValue("Бн" + balance + "ПоА").scaled;
            outRestThAR = global.balanceReport.AttributeValue("Бн" + balance + "РуА").scaled;
        elif (attributeValueP != NULL)
            outRestThP = attributeValueP.scaled;
            outRestThPV = global.balanceReport.AttributeValue("Бн" + balance + "ПоП").scaled;
            outRestThPR = global.balanceReport.AttributeValue("Бн" + balance + "РуП").scaled;
        end;

        debetTh   = global.balanceReport.AttributeValue("Бн" + balance + "__Д").scaled;
        debetThV  = global.balanceReport.AttributeValue("Бн" + balance + "ПоД").scaled;
        debetThR  = global.balanceReport.AttributeValue("Бн" + balance + "РуД").scaled;
        creditTh  = global.balanceReport.AttributeValue("Бн" + balance + "__К").scaled;
        creditThV = global.balanceReport.AttributeValue("Бн" + balance + "ПоК").scaled;
        creditThR = global.balanceReport.AttributeValue("Бн" + balance + "РуК").scaled;

        tempInRestTh  = (outRestThP - outRestThA) + (debetTh - creditTh);
        tempInRestThV = (outRestThPV - outRestThAV) + (debetThV - creditThV);
        tempInRestThR = (outRestThPR - outRestThAR) + (debetThR - creditThR);

        if (tempInRestTh < 0)
            inRestThA  = -tempInRestTh;
            inRestThAV = -tempInRestThV;
            inRestThAR = -tempInRestThR;
        else
            inRestThP  =  tempInRestTh;
            inRestThPV =  tempInRestThV;
            inRestThPR =  tempInRestThR;
        end;


        return TDataStruct(balance, inRestThA, inRestThP, debetTh, creditTh, outRestThA, outRestThP,
                           inRestThAV, inRestThPV, debetThV, creditThV, outRestThAV, outRestThPV,
                           inRestThAR, inRestThPR, debetThR, creditThR, outRestThAR, outRestThPR);
    end;

    macro getSums()
        var sumDebet    : Money = $0.0;
        var sumCredit   : Money = $0.0;
        var sumInRestA  : Money = $0.0;
        var sumInRestP  : Money = $0.0;
        var sumOutRestA : Money = $0.0;
        var sumOutRestP : Money = $0.0;

        var sumDebetV    : Money = $0.0;
        var sumCreditV   : Money = $0.0;
        var sumInRestAV  : Money = $0.0;
        var sumInRestPV  : Money = $0.0;
        var sumOutRestAV : Money = $0.0;
        var sumOutRestPV : Money = $0.0;

        var sumDebetR    : Money = $0.0;
        var sumCreditR   : Money = $0.0;
        var sumInRestAR  : Money = $0.0;
        var sumInRestPR  : Money = $0.0;
        var sumOutRestAR : Money = $0.0;
        var sumOutRestPR : Money = $0.0;

        var query = "SELECT DISTINCT  t_balance"+
        "\n " +     "  FROM " + SQL_GetTableName(temp);

        var balanceData : Object = NULL;
        var dataSet = TrsbDataSet(query);

        while (dataSet.moveNext())
            balanceData = getValues(dataSet.balance);

            sumDebet    = sumDebet    +  balanceData.m_debet();
            sumCredit   = sumCredit   +  balanceData.m_credit();
            sumInRestA  = sumInRestA  +  balanceData.m_inRestA();
            sumInRestP  = sumInRestP  +  balanceData.m_inRestP();
            sumOutRestA = sumOutRestA +  balanceData.m_outRestA();
            sumOutRestP = sumOutRestP +  balanceData.m_outRestP();

            sumDebetV    = sumDebetV    +  balanceData.m_debetV();
            sumCreditV   = sumCreditV   +  balanceData.m_creditV();
            sumInRestAV  = sumInRestAV  +  balanceData.m_inRestAV();
            sumInRestPV  = sumInRestPV  +  balanceData.m_inRestPV();
            sumOutRestAV = sumOutRestAV +  balanceData.m_outRestAV();
            sumOutRestPV = sumOutRestPV +  balanceData.m_outRestPV();


            sumDebetR    = sumDebetR    +  balanceData.m_debetR();
            sumCreditR   = sumCreditR   +  balanceData.m_creditR();
            sumInRestAR  = sumInRestAR  +  balanceData.m_inRestAR();
            sumInRestPR  = sumInRestPR  +  balanceData.m_inRestPR();
            sumOutRestAR = sumOutRestAR +  balanceData.m_outRestAR();
            sumOutRestPR = sumOutRestPR +  balanceData.m_outRestPR();
        end;

        return TDataStruct("Root", sumInRestA, sumInRestP, sumDebet, sumCredit, sumOutRestA, sumOutRestP,
                           sumInRestAV, sumInRestPV, sumDebetV, sumCreditV, sumOutRestAV, sumOutRestPV,
                           sumInRestAR, sumInRestPR, sumDebetR, sumCreditR, sumOutRestAR, sumOutRestPR);
    end;
end;
/***************************************************************************************************
 *  Процедуры нормализации
 **************************************************************************************************/
macro getQueryForLoadProc()
    var query = " INSERT INTO ddatnorm5_tmp(t_chapter, t_balance, t_kind_account, t_inactive, t_inactiver,      " +
    "\n" +      "                           t_inactivev, t_inpassive, t_inpassiver, t_inpassivev, t_debet,      " +
    "\n" +      "                           t_debetr, t_debetv, t_credit, t_creditr, t_creditv, t_outactive,    " +
    "\n" +      "                           t_outactiver, t_outactivev, t_outpassive, t_outpassiver,            " +
    "\n" +      "                           t_outpassivev, t_inactiveth, t_inactivethr, t_inactivethv,          " +
    "\n" +      "                           t_inpassiveth, t_inpassivethr, t_inpassivethv, t_debetth,           " +
    "\n" +      "                           t_debetthr, t_debetthv, t_creditth, t_creditthr, t_creditthv,       " +
    "\n" +      "                           t_outactiveth, t_outactivethr, t_outactivethv, t_outpassiveth,      " +
    "\n" +      "                           t_outpassivethr, t_outpassivethv)                                   " +
    "\n" +      " SELECT acc.t_chapter,                                                                         " + /* chapter       */
    "\n" +      "        tmp.t_account,                                                                         " + /* balance       */
    "\n" +      "        acc.t_kind_Account,                                                                    " + /* kindAccount   */
    "\n" +      "        DECODE(acc.t_kind_Account, 'А', ABS(tmp.t_restIn), 0),                                 " + /* inActive      */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'А' AND INSTR( acc.t_type_Account, 'П' ) = 0)           " +
    "\n" +      "                THEN ABS(tmp.t_restIn)                                                         " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* inActiveR     */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'А' AND INSTR( acc.t_type_Account, 'П' ) <> 0)          " +
    "\n" +      "                THEN ABS(tmp.t_restIn)                                                         " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* inActiveV     */
    "\n" +      "        DECODE(acc.t_kind_Account, 'П', ABS(tmp.t_restIn), 0),                                 " + /* inPassive     */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'П' AND INSTR( acc.t_type_Account, 'П' ) = 0)           " +
    "\n" +      "                THEN ABS(tmp.t_restIn)                                                         " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* inPassiveR    */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'П' AND INSTR( acc.t_type_Account, 'П' ) <> 0)          " +
    "\n" +      "                THEN ABS(tmp.t_restIn)                                                         " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* inPassiveV    */
    "\n" +      "        ABS(tmp.t_debet),                                                                      " + /* debet         */
    "\n" +      "        DECODE(INSTR( acc.t_type_Account, 'П' ), 0, ABS(tmp.t_debet), 0),                      " + /* debetR        */
    "\n" +      "        DECODE(INSTR( acc.t_type_Account, 'П' ), 0, 0, ABS(tmp.t_debet)),                      " + /* debetV        */
    "\n" +      "        ABS(tmp.t_kredit),                                                                     " + /* credit        */
    "\n" +      "        DECODE(INSTR( acc.t_type_Account, 'П' ), 0, ABS(tmp.t_kredit), 0),                     " + /* creditR       */
    "\n" +      "        DECODE(INSTR( acc.t_type_Account, 'П' ), 0, 0, ABS(tmp.t_kredit)),                     " + /* creditV       */
    "\n" +      "        DECODE(acc.t_kind_Account, 'А', ABS(tmp.t_restOut), 0),                                " + /* outActive     */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'А' AND INSTR( acc.t_type_Account, 'П' ) = 0)           " +
    "\n" +      "                THEN ABS(tmp.t_restOut)                                                        " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* outActiveR    */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'А' AND INSTR( acc.t_type_Account, 'П' ) <> 0)          " +
    "\n" +      "                THEN ABS(tmp.t_restOut)                                                        " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* outActiveV    */
    "\n" +      "        DECODE(acc.t_kind_Account, 'П', ABS(tmp.t_restOut), 0),                                " + /* outPassive    */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'П' AND INSTR( acc.t_type_Account, 'П' ) = 0)           " +
    "\n" +      "                THEN ABS(tmp.t_restOut)                                                        " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* outPassiveR   */
    "\n" +      "        CASE                                                                                   " +
    "\n" +      "            WHEN (acc.t_kind_Account = 'П' AND INSTR( acc.t_type_Account, 'П' ) <> 0)          " +
    "\n" +      "                THEN ABS(tmp.t_restOut)                                                        " +
    "\n" +      "            ELSE 0                                                                             " +
    "\n" +      "        END,                                                                                   " + /* outPassiveV   */
    "\n" +      "        0,                                                                                     " + /* inActiveTh    */
    "\n" +      "        0,                                                                                     " + /* inActiveThR   */
    "\n" +      "        0,                                                                                     " + /* inActiveThV   */
    "\n" +      "        0,                                                                                     " + /* inPassiveTh   */
    "\n" +      "        0,                                                                                     " + /* inPassiveThR  */
    "\n" +      "        0,                                                                                     " + /* inPassiveThV  */
    "\n" +      "        0,                                                                                     " + /* debetTh       */
    "\n" +      "        0,                                                                                     " + /* debetThR      */
    "\n" +      "        0,                                                                                     " + /* debetThV      */
    "\n" +      "        0,                                                                                     " + /* credit        */
    "\n" +      "        0,                                                                                     " + /* creditThR     */
    "\n" +      "        0,                                                                                     " + /* creditThV     */
    "\n" +      "        0,                                                                                     " + /* outActiveTh   */
    "\n" +      "        0,                                                                                     " + /* outActiveThR  */
    "\n" +      "        0,                                                                                     " + /* outActiveThV  */
    "\n" +      "        0,                                                                                     " + /* outPassiveTh  */
    "\n" +      "        0,                                                                                     " + /* outPassiveThR */
    "\n" +      "        0                                                                                      " + /* outPassiveThV */
    "\n" +      "   FROM " + SQL_GetTableName(temp) + " tmp, daccount_dbt acc                                   " +
    "\n" +      "  WHERE tmp.t_account = acc.t_account                                                          " +
    "\n" +      "    AND acc.t_chapter = 1                                                                      ";
    return query;
end;

macro loadProcForRouble()
    var query = getQueryForLoadProc() + " AND INSTR( acc.t_type_Account, 'П' ) = 0";

    SQL_Execute(query);
end;

macro loadProcForCurrency()
    var query = getQueryForLoadProc() + " AND INSTR( acc.t_type_Account, 'П' ) <> 0";

    SQL_Execute(query);
end;

macro saveProc()
    SQL_Execute("UPDATE " + SQL_GetTableName(temp) + "  tmp                                                    " +
         "\n" + "   SET (tmp.t_restIn, tmp.t_debet, tmp.t_kredit, tmp.t_restOut) =                             " +
         "\n" + "                     (SELECT DECODE(nrm.t_kind_Account, 'А', nrm.t_inActiveTh,                " +
         "\n" + "                                                        'П', nrm.t_inPassiveTh, 0)*1000,      " +
         "\n" + "                             nrm.t_debetTh * 1000,                                            " +
         "\n" + "                             nrm.t_creditTh * 1000,                                           " +
         "\n" + "                             DECODE(nrm.t_kind_Account, 'А', nrm.t_outActiveTh,               " +
         "\n" + "                                                        'П', nrm.t_outPassiveTh, 0)*1000      " +
         "\n" + "                        FROM ddatnorm5_tmp nrm                                                " +
         "\n" + "                       WHERE nrm.t_balance      = tmp.t_account)                              " +
         "\n" + " WHERE EXISTS (SELECT 1 FROM ddatnorm5_tmp nrm WHERE nrm.t_balance = tmp.t_account)           ");
end;

macro defLevelProc(account : String)
    const CHAPTER_LENGTH = 1;
    const MAXIMUM_BALANCE_LENGTH = 10;
    var length = strLen(account);

    if   (length == CHAPTER_LENGTH)         return CHAPTER_LEVEL;
    elif (length <= MAXIMUM_BALANCE_LENGTH) return BALANCE_LEVEL;
    end;

    return ACCOUNT_LEVEL;
end;

macro defTopBalanceProc(chapter : Integer, node : String, level : Integer)

    level = level - 1;

    if   (level == ACCOUNT_LEVEL) return node;
    elif (level == BALANCE_LEVEL) return subStr(node, 1, 5);
    elif (level == CHAPTER_LEVEL) return "А";
    end;

    return "";
end;

macro afterRoundProcForRouble(datnorm5 : Object, level : Integer)
    macro substituteData(balanceData)
        datnorm5.ldInActiveTh     = balanceData.m_inRestAR();
        datnorm5.ldOutActiveTh    = balanceData.m_outRestAR();
        datnorm5.ldInPassiveTh    = balanceData.m_inRestPR();
        datnorm5.ldOutPassiveTh   = balanceData.m_outRestPR();
        datnorm5.ldDebetTh        = balanceData.m_debetR();
        datnorm5.ldCreditTh       = balanceData.m_creditR();

        datnorm5.ldInActiveThV    = $0;
        datnorm5.ldOutActiveThV   = $0;
        datnorm5.ldInPassiveThV   = $0;
        datnorm5.ldOutPassiveThV  = $0;
        datnorm5.ldDebetThV       = $0;
        datnorm5.ldCreditThV      = $0;

        datnorm5.ldInActiveThR    = balanceData.m_inRestAR;
        datnorm5.ldOutActiveThR   = balanceData.m_outRestAR;
        datnorm5.ldInPassiveThR   = balanceData.m_inRestPR;
        datnorm5.ldOutPassiveThR  = balanceData.m_outRestPR;
        datnorm5.ldDebetThR       = balanceData.m_debetR;
        datnorm5.ldCreditThR      = balanceData.m_creditR;
    end;

    if (datnorm5.balance == "Root")
        substituteData(TBalanceData().getSums());
    elif ((level == CHAPTER_LEVEL) and (datnorm5.balance == "А"))
        substituteData(TBalanceData().getSums());
    elif (level == BALANCE_LEVEL)
        substituteData(TBalanceData().getValues(datnorm5.balance));
    end;

end;

macro afterRoundProcForCurrency(datnorm5 : Object, level : Integer)
    macro substituteData(balanceData)
        datnorm5.ldInActiveTh     = balanceData.m_inRestAV();
        datnorm5.ldOutActiveTh    = balanceData.m_outRestAV();
        datnorm5.ldInPassiveTh    = balanceData.m_inRestPV();
        datnorm5.ldOutPassiveTh   = balanceData.m_outRestPV();
        datnorm5.ldDebetTh        = balanceData.m_debetV();
        datnorm5.ldCreditTh       = balanceData.m_creditV();

        datnorm5.ldInActiveThV    = balanceData.m_inRestAV();
        datnorm5.ldOutActiveThV   = balanceData.m_outRestAV();
        datnorm5.ldInPassiveThV   = balanceData.m_inRestPV();
        datnorm5.ldOutPassiveThV  = balanceData.m_outRestPV();
        datnorm5.ldDebetThV       = balanceData.m_debetV();
        datnorm5.ldCreditThV      = balanceData.m_creditV();

        datnorm5.ldInActiveThR    = $0;
        datnorm5.ldOutActiveThR   = $0;
        datnorm5.ldInPassiveThR   = $0;
        datnorm5.ldOutPassiveThR  = $0;
        datnorm5.ldDebetThR       = $0;
        datnorm5.ldCreditThR      = $0;
    end;

    if (datnorm5.balance == "Root")
        substituteData(TBalanceData().getSums());
    elif ((level == CHAPTER_LEVEL) and (datnorm5.balance == "А"))
        substituteData(TBalanceData().getSums());
    elif (level == BALANCE_LEVEL)
        substituteData(TBalanceData().getValues(datnorm5.balance));
    end;

end;

/***************************************************************************************************
 *  Класс корректировки оборотов, после нормализации
 **************************************************************************************************/
private class TCashTurnsCorrecter()
    private const CONDITION_FOR_ROUBLE   = "AND instr( acc.t_Type_Account, 'П' ) = 0";
    private const CONDITION_FOR_CURRENCY = "AND instr( acc.t_Type_Account, 'П' ) > 0";

    private macro increaseCashTurns(balance : String)
        var query = "SELECT tmp.t_debet, tmp.t_kredit                                                                 " +
            "\n" +  "  FROM " + SQL_GetTableName(temp) +  " tmp                                                       " +
            "\n" +  " WHERE tmp.t_account = (SELECT account                                                           " +
            "\n" +  "                          FROM (SELECT   t_balance account, (nrm.t_debetTh * 1000 - nrm.t_debet) " +
            "\n" +  "                                    FROM ddatnorm5_tmp nrm                                       " +
            "\n" +  "                                   WHERE SUBSTR(nrm.t_balance, 1, 5) = '" + balance +          "'" +
            "\n" +  "                                ORDER BY (nrm.t_debetTh * 1000 - nrm.t_debet))                   " +
            "\n" +  "                         WHERE ROWNUM < 2) ";

        var inserter = TRsbDataSet(query, RSDVAL_CLIENT, RSDVAL_STATIC);

        if (inserter.moveNext())
            inserter.edit();

            inserter.debet  = inserter.debet  + 1000;
            inserter.kredit = inserter.kredit + 1000;

            inserter.update();
        end;
    end;

    private macro decreaseCashTurns(balance : String)
        var query = "SELECT tmp.t_debet, tmp.t_kredit                                                                 " +
            "\n" +  "  FROM " + SQL_GetTableName(temp) +  " tmp                                                       " +
            "\n" +  " WHERE tmp.t_account = (SELECT account                                                           " +
            "\n" +  "                          FROM (SELECT   t_balance account, (nrm.t_debetTh * 1000 - nrm.t_debet) " +
            "\n" +  "                                    FROM ddatnorm5_tmp nrm                                       " +
            "\n" +  "                                   WHERE SUBSTR(nrm.t_balance, 1, 5) = '" + balance +          "'" +
            "\n" +  "                                ORDER BY (nrm.t_debetTh * 1000 - nrm.t_debet) DESC)              " +
            "\n" +  "                         WHERE ROWNUM < 2) ";

        var inserter = TRsbDataSet(query, RSDVAL_CLIENT, RSDVAL_STATIC);

        if (inserter.moveNext())
            inserter.edit();

            inserter.debet  = inserter.debet  - 1000;
            inserter.kredit = inserter.kredit - 1000;

            inserter.update();
        end;
    end;

    private macro getFormData(condition : String)

        var query = "SELECT   tmp.t_balance, SUM(tmp.t_restIn)/1000 inRest, SUM(tmp.t_debet)/1000 debet, SUM(tmp.t_kredit)/1000 credit, SUM(tmp.t_restOut)/1000 outRest"+
        "\n" +   "     FROM daccount_dbt acc," + SQL_GetTableName(temp) + " tmp" +
        "\n" +   "    WHERE acc.t_account = tmp.t_account " +
        "\n" +   "      AND acc.t_chapter = 1 " +
        "\n" +              condition +
        "\n" +   " GROUP BY tmp.t_balance";

        return TrsbDataSet(query);
    end;

    macro correctRoubleData()
        var isCorrect = false;
        var dataSet = getFormData(CONDITION_FOR_ROUBLE);

        while (not isCorrect)
            isCorrect = true;
            while (dataSet.moveNext())
                if (dataSet.debet > TBalanceData().getValues(dataSet.balance).m_debetR)
                    decreaseCashTurns(dataSet.balance);
                    isCorrect = false;
                elif (dataSet.debet < TBalanceData().getValues(dataSet.balance).m_debetR)
                    increaseCashTurns(dataSet.balance);
                    isCorrect = false;
                end;
            end;
        end;
    end;

    macro correctCurrencyData()
        var isCorrect = false;
        var dataSet = getFormData(CONDITION_FOR_CURRENCY);

        while (not isCorrect)
            isCorrect = true;
            while (dataSet.moveNext())
                if (dataSet.debet > TBalanceData().getValues(dataSet.balance).m_debetV)
                    decreaseCashTurns(dataSet.balance);
                    isCorrect = false;
                elif (dataSet.debet < TBalanceData().getValues(dataSet.balance).m_debetV)
                    increaseCashTurns(dataSet.balance);
                    isCorrect = false;
                end;
            end;
        end;
    end;

end;
/***************************************************************************************************
 *  Нормализация
 **************************************************************************************************/
macro normalizeData()
    var context = rcbApplication().currentReport().context;

    macro printErrorMessage(context : Object)
        var messageString = "Отсутствует расчитанный баланс за период | с " + context.period.beginDate +
                            " по " + context.period.endDate + "|Нормализация с данными баланса не проводится";
        msgBox(messageString);
    end;


    macro executeNormalize5(loadProc : String, afterRoundProc : String)

        record norm ("prmnorm5.rec");

        norm.LoadProc           = loadProc;
        norm.SaveProc           = "saveProc";
        norm.DefLevelProc       = "defLevelProc";
        norm.DefTopBalanceProc  = "defTopBalanceProc";
        norm.AfterRoundProc     = afterRoundProc;
        norm.RoundTerm          = 1000;
        norm.FaultToBalances    = "";
        norm.BalancesToExclude  = "";
        norm.FaultToConstituent = 0;
        norm.AddSumsToParent    = "X";
        norm.UsePrevPeriodRests = "";
        norm.NormalizeTurns     = "X";
        normalize5( norm );
    end;

    global.balanceReport = rcbApplication().objectFactory().createReport("Балансовые счета", context);

    if (not global.balanceReport.isCalculated)
        printErrorMessage(context);
        return;
    end;

    executeNormalize5("loadProcForCurrency", "afterRoundProcForCurrency");
    TCashTurnsCorrecter().correctCurrencyData();
    executeNormalize5("loadProcForRouble", "afterRoundProcForRouble");
    TCashTurnsCorrecter().correctRoubleData();

    global.balanceReport = NULL;
end;
/****************************************************************************************************/

/*-----------------------------------------------*/
MACRO PrSumTh( Sum )         /* Вывод сумм в тысячах */
    if ( Апострофы )    return string(Sum:0:0:a);
    else                return string(Sum:0:0);
    end;
END;

macro PutDate( dat )
  var str = string( dat:m);
  if ( substr(str, 1, 1) == " " )
    return "\"0" + substr(str, 2, 1) + "\"" + substr(str, 3);
  else
    return "\"" + substr(str, 1, 2) + "\"" + substr(str, 3);
  end;
end;

/*-------------------------------------------*/
/* Имя исполнителя      */
macro GetNameOper( )
  pers.Oper = {oper};
  if ( getEQ( pers ) )
          return pers.Name;
  else    return "";
  end;
end;
/* ----------------------------------------------------- */
/* Найти № балансового счета в массиве     */
macro DefNum( val )
 var i = 0;
 while( i < NumBal )
  if( Bal1(i) == val ) return i; end;
  i = i + 1;
 end;
 return -1;
end;

/* ----------------------------------------------------- */
/* Найти клиента в справочнике субъектов          */
macro GetRecParty( PartyID )
  pt.PartyID = PartyID;
  if ( not getEQ( pt ) )
    RE.MessError( "В справочнике нет клиента с номером " + String( PartyID ) );
    return FALSE;
  end;
  return TRUE;
end;
/*-------------------------------------------*/
/* Код страны нерезидента    */
MACRO КодСтраныНерезидента
 clc.CodeLat3 = pt.NRCountry;
 if( getEQ( clc ) )
  return clc.CodeNum3; /* Код страны нерезидента */
 else
  if ( pt.NRCountry == "" )
    RE.MessError( " Не заполнена страна нерезидента " + pt.ShortName );
  else
    RE.MessError( " Не найдена страна нерезидента " + pt.ShortName + " с кодом " + pt.NRCountry );
  end;
  return "";
 end;
END;

/*-------------------------------------------*/
/* Код клиента    */
macro GetCodParty(PartyID, CodeKind)
 var cod;
/*  keynum(ptcod, 0);

  ptcod.PartyID  = PartyID;
  ptcod.CodeKind = CodeKind;
  if ( getEQ(ptcod) )  return ptcod.Code;
  else     return "";
  end;  */
  /* 04.10.2007 Malakhova 110424*/
  cod = repGetPartyCode( PartyID, CodeKind );
//  cod = ПолучитьКодСубъекта( PartyID, CodeKind );
  if( cod == NULL )
   return "";
  else
   return cod;
  end;
end;

/*-----------------------------------------------------------------------*/
macro GetOwnParty( PartyID, PartyKind )
  ptown.PartyKind = PartyKind;
  ptown.PartyID = PartyID;
  return   getEQ(ptown);
end;


/*-----------------------------------------------------------------------*/
/*  Фильтр лиц.счетов по маске номера счета  */
macro FiltrMask( Account, Mask )
  var i = 1,  ch;
  while ( ( i <= strlen( Mask ) ) and ( i <= strlen( Account ) ) )
      ch = substr( Mask, i, 1 );
      if ( ( ch != "*" ) and ( ch != substr( Account, i, 1 ) ) )
        return FALSE;
      end;
      i = i + 1;
  end;
  return TRUE;
end;

/* ----------------------------------------------------- */
/* Название страны нерезидента */
macro GetNameCountry( Country )
   clc.CodeLat3 = Country;
   if ( getEQ( clc ) ) return  clc.Name;
   else
    RE.MessError( "В справочнике нет страны  с кодом " + String( Country) );
    return "";
   end;
end;

/* ----------------------------------------------------- */
/* Признак нерезидентности клиента */
macro IsNotResident( pt )
  if ( pt.NotResident > 0 ) return TRUE;
  else          return FALSE;
  end;
end;

/*-----------------------------------------------------------------------*/
MACRO  PrintHeader()  /* Напечатать заголовок */
  if( ДатаОтчета < ДАТА1376У )
[                                                                                                                                                                      ];
[                                                                                                                                                Банковская отчетность ];
[                                                                                                                                  Код формы документа по ОКУД 0409603 ];
[                                                                                                             ┌───────────────┬───────────────────────────────────────┐];
[                                                                                                             │      Код      │       Код кредитной организации       │];
[                                                                                                             │   территории  ├──────────┬───────────────┬────────────┤];
[                                                                                                             │    по ОКАТО   │ по ОКПО  │Регистрационный│    БИК     │];
[                                                                                                             │               │          │    номер      │            │];
[                                                                                                             ├───────────────┼──────────┼───────────────┼────────────┤];
[                                                                                                             │###############│##########│###############│############│]( Код_СОАТО:c, Код_ОКПО:c, РегНомерБанка:c, {MFO_Bank}:c );
[                                                                                                             └───────────────┴──────────┴───────────────┴────────────┘];
  else
[                                                                                                                                                                            ];
[                                                                                                                                                      Банковская отчетность ];
[                                                                                                    ┌───────────────┬──────────────────────────────────────────────────────┐];
[                                                                                                    │      Код      │          Код кредитной организации (филиала)         │];
[                                                                                                    │   территории  ├─────────┬───────────────┬───────────────┬────────────┤];
[                                                                                                    │    по ОКАТО   │ по ОКПО │   Основной    │Регистрационный│    БИК     │];
[                                                                                                    │               │         │государственный│    номер      │            │];
[                                                                                                    │               │         │регистрационный│(/порядковый   │            │];
[                                                                                                    │               │         │    номер      │    номер)     │            │];
[                                                                                                    ├───────────────┼─────────┼───────────────┼───────────────┼────────────┤];
[                                                                                                    │        #      │     #   │       #       │       #       │      #     │]( Код_СОАТО:c, Код_ОКПО:c, ОГРН:c, РегНомерБанка:c, {MFO_Bank}:c );
[                                                                                                    └───────────────┴─────────┴───────────────┴───────────────┴────────────┘];
  end;
[                                                                                                                                                                      ];
[                                        СВЕДЕНИЯ ОБ ОТКРЫТЫХ КОРРЕСПОНДЕНТСКИХ СЧЕТАХ И ОСТАТКАХ СРЕДСТВ НА НИХ                                                       ];
[                                                     по состоянию на ############################                                                                     ]( PutDate(RepDat) );
[                                                                                                                                                                      ];
[##################################################################################################################################################################### ]( "Наименование кредитной организации  " + {Name_Bank}:w);
[Почтовый адрес  #                                                                                                                                                     ]( {Post_Addr}:l);
[                                                                                                                                                                      ];
  if( ДатаОтчета < ДАТА1376У )
[                                                                                                                                                           ФОРМА  603 ];
[                                                                                                                                                             Месячная ];
   if ( СуммыВРублях )
[                                                                                                                                                             тыс.руб. ];
   else
[                                                                                                                                                        тыс.ед.валюты ];
   end;
  else
[                                                                                                                                                          Код формы 0409603 ];
[                                                                                                                                                                   Месячная ];
   if ( СуммыВРублях )
[                                                                                                                                                                   тыс.руб. ];
   else
[                                                                                                                                                              тыс.ед.валюты ];
   end;
  end;
END;

/*-----------------------------------------------------------------------*/

macro  IsNullTemp(temp)
  if (   ( temp.RestIn == $0 ) and ( temp.RestOut == $0 )
      and ( temp.Debet == $0 ) and ( temp.Kredit == $0 )
     )  return TRUE;
  else return FALSE;
  end;
end;

macro Contr_1( a, NSec, prim )

//  ClearRecord( temp_err );
  temp_err.chapter     = NSec;
  temp_err.Balance     = a.Balance;
  temp_err.Account     = a.Account;
  temp_err.NameAccount = prim;
   if ( not insert( temp_err ) )
     RE.MessError( "Не внесена запись в временный файл ошибок для ЛС " + temp.Account );
     return FALSE;
   end;

end;

/*-----------------------------------------------------------------------*/
macro PrintAccount(a)
  var NameClient;
  var bal2 = TArray;
      bal2(0) = "30110";
      bal2(1) = "30114";
      bal2(2) = "30115";
      bal2(3) = "30118";
      bal2(4) = "30119";
  macro Ind()
    var i = 0;
    while(i < bal2.size)
     if(bal2(i) == SubStr(a.Account, 1, 5))
      return true;
     end;
     i = i + 1;
    end;
    return false;
  end;

  macro СчетКонтрагента()
   var str;
   var data = TRsbDataSet("SELECT t_coraccount " +
                          "  FROM dcorschem_dbt" +
                          " WHERE t_account='" + a.Account +"'"
                          "   AND t_fiid=(SELECT t_fiid " +
                          "                 FROM dfininstr_dbt "
                          "                WHERE t_fi_code='" + SubStr(a.Account, 6, 3) +
                                        "')"
                         );
   if(data.Next())
     return data.t_coraccount;
   else
   str="Для лицевого счета № "+a.Account+" не задана схема расчетов.";
   Contr_1(a, 1, str);
   end;
   return "";
  end;

  var Acc;
  if( Ind() )
   Acc = СчетКонтрагента();
  else
   Acc = a.Account;
  end;
  count = count + 1;/*счетчик*/

    if ( СортировкаКлиентов == ПоКраткомуНазванию )
/*    NameClient = pt.ShortName+" ("+pt.Name+")";*/
      NameClient = temp.Name_Client+" ("+temp.Name+")";
    else
      NameClient = temp.Name;
    end;
    if( ДатаОтчета < ДАТА1376У )
[├────────────────────────────┼──────────┼─────────┼────────────┼─────────────────────────┼──────────────────┼──────────────────┼──────────────────┼──────────────────┤];
[│ ###########################│##########│#########│############│#########################│##################│##################│##################│##################│]
(  NameClient:w, RegNumber:c:w, BIC:c, a.Balance:c, PrAccount(Acc):c, PrSumTh(RestIn):r, PrSumTh(Debet):r, PrSumTh(Kredit):r, PrSumTh(RestOut):r );
    else
[├─────┼────────────────────────────┼──────────┼─────────┼────────────┼─────────────────────────┼──────────────────┼──────────────────┼──────────────────┼──────────────────┤];
[│#####│ ###########################│##########│#########│############│#########################│##################│##################│##################│##################│]
( count:c, NameClient:w, RegNumber:c:w, BIC:c, a.Balance:c, PrAccount(Acc):c, PrSumTh(RestIn):r, PrSumTh(Debet):r, PrSumTh(Kredit):r, PrSumTh(RestOut):r );
    end;

end;

macro Head( str )
   PrintLn( str );
  if( ДатаОтчета < ДАТА1376У )
[┌────────────────────────────┬──────────┬─────────┬────────────┬─────────────────────────┬──────────────────┬─────────────────────────────────────┬──────────────────┐];
[│ Наименование кредитной     │  Рег.N   │   БИК   │ Номер      │           Номер         │    Остаток       │ Обороты по корреспондентским счетам │    Остаток       │];
[│ организации корреспондента │          │         │ бал.счета  │    корреспондентского   │    на начало     │         за отчетный месяц           │    на конец      │];
[│                            │          │         │            │           счета         │    месяца        ├──────────────────┬──────────────────┤    месяца        │];
[│                            │          │         │            │                         │                  │    дебетовый     │    кредитовый    │                  │];
[├────────────────────────────┼──────────┼─────────┼────────────┼─────────────────────────┼──────────────────┼──────────────────┼──────────────────┼──────────────────┤];
[│             1              │    2     │    3    │     4      │            5            │        6         │        7         │        8         │         9        │];
  else
[┌─────┬────────────────────────────┬──────────┬─────────┬────────────┬─────────────────────────┬──────────────────┬─────────────────────────────────────┬──────────────────┐];
[│Номер│ Наименование кредитной     │Регистра- │Код стра-│ Номер      │          Номер          │    Остаток       │ Обороты по корреспондентским счетам │    Остаток       │];
[│ п/п │ организации-корреспондента │ционный   │ны нахож-│ балансового│    корреспондентского   │    на начало     │         за отчетный месяц           │    на конец      │];
[│     │                            │номер (код│дения    │ счета      │          счета          │    месяца        │                                     │    месяца        │];
[│     │                            │СВИФТ)    │кредитной│            │                         │                  │                                     │                  │];
[│     │                            │          │организа-│            │                         │                  ├──────────────────┬──────────────────┤                  │];
[│     │                            │          │ции      │            │                         │                  │    дебетовый     │    кредитовый    │                  │];
[├─────┼────────────────────────────┼──────────┼─────────┼────────────┼─────────────────────────┼──────────────────┼──────────────────┼──────────────────┼──────────────────┤];
[│  1  │            2               │    3     │    4    │     5      │            6            │        7         │        8         │        9         │        10        │];
  end;
end;

macro HeadExp()
end;

macro Footer()
  if( ДатаОтчета < ДАТА1376У )
[└────────────────────────────┴──────────┴─────────┴────────────┴─────────────────────────┴──────────────────┴──────────────────┴──────────────────┴──────────────────┘];
  else
[└─────┴────────────────────────────┴──────────┴─────────┴────────────┴─────────────────────────┴──────────────────┴──────────────────┴──────────────────┴──────────────────┘];
  end;
end;

macro FooterExp()
end;

/*-----------------------------------------------------------------------*/
macro PrintFooter()
[                                                                            ];
[   #                                   #                           (Ф.И.О.) ]( {Name_Boss}:l, {FIO_Boss}:l );
[                                                                            ];
[   #                                   #                           (Ф.И.О.) ]( {Name_Book}:l, {FIO_Book}:l );
[                                                                            ];
[   М.П.                                                                     ];
[                                                                            ];
[   Исполнитель                         #                           (Ф.И.О.) ]( GetNameOper() );
[                                                                            ];
[   телефон                             #                                    ]( Номер_телефона:l );
[                                                                            ];
[   #                                                                        ]( PutDate({curdate}) );
end;

/*-----------------------------------------------------------------------*/
/* Дебетовый оборот счета за период  Dat1...Dat2 с учетом исправительных оборотов */
macro DebetAcc( Account, Code_Currency, Dat1, Dat2, DebetCorr )

    var
      tablename = "",
      DateCompString = "",
      Rs,
      Debet     = $0;

    DebetCorr = $0;


    macro Query( tablename, dateString )
      var QueryDoc = "";

      QueryDoc = " SELECT SUM(                                                     " +
                 "               CASE                                              " +
                 "                   WHEN INSTR(t_TypeDocument,'И') > 0 THEN t_Sum " +
                 "                   WHEN INSTR(t_TypeDocument,'С') > 0 THEN t_Sum " +
                 "                   ELSE                                    0     " +
                 "               END                                               " +
                 "           ) t_SumCorr,                                          " +
                 "        SUM(                                                     " +
                 "               CASE                                              " +
                 "                   WHEN INSTR(t_TypeDocument,'И') > 0 THEN 0     " +
                 "                   WHEN INSTR(t_TypeDocument,'С') > 0 THEN 0     " +
                 "                   ELSE                                    t_Sum " +
                 "               END                                               " +
                 "           ) t_SumDebt                                           " +
                 " FROM " + tablename                                                +
                 " WHERE      t_Chapter        = 1                                 " +
                 "        AND t_Code_Currency  = " + Code_Currency                   +
                 "        AND t_Account_Payer  = " + GetSQLString( Account )         +
                 dateString                                                          +
                 " GROUP BY t_Chapter, t_Code_Currency, t_Account_Payer            " ;

      Rs = TRsbDataSet(QueryDoc);
      if( Rs.MoveNext() )

        Debet     = Debet     + Rs.value( "t_SumDebt", null, V_MONEY );
        DebetCorr = DebetCorr + Rs.value( "t_SumCorr", null, V_MONEY );
      end;

    end;

    if( Code_Currency == 0 )
      tablename = "darhdoc_dbt";
    else
      tablename = "darhdoc$_dbt";
    end;
    DateCompString = "        AND t_Date_Carry    >= " + GetSQLDate( Dat1 )+
                     "        AND t_Date_Carry    <= " + GetSQLDate( Dat2 );
    Query( tablename, DateCompString);

    SetParm( 4, DebetCorr );

    return Debet;
end;


/* Кредитовый оборот счета за период  Dat1...Dat2 с учетом исправительных оборотов */
macro KreditAcc( Account, Code_Currency, Dat1, Dat2, KreditCorr )
    var
      tablename = "",
      DateCompString = "",
      Rs,
      Kredit    = $0;

    KreditCorr = $0;


    macro Query( tablename, dateString )
      var QueryDoc = "";

      QueryDoc = " SELECT SUM(                                                     " +
                 "               CASE                                              " +
                 "                   WHEN INSTR(t_TypeDocument,'И') > 0 THEN t_Sum " +
                 "                   WHEN INSTR(t_TypeDocument,'С') > 0 THEN t_Sum " +
                 "                   ELSE                                    0     " +
                 "               END                                               " +
                 "           ) t_SumCorr,                                          " +
                 "        SUM(                                                     " +
                 "               CASE                                              " +
                 "                   WHEN INSTR(t_TypeDocument,'И') > 0 THEN 0     " +
                 "                   WHEN INSTR(t_TypeDocument,'С') > 0 THEN 0     " +
                 "                   ELSE                                    t_Sum " +
                 "               END                                               " +
                 "           ) t_SumKred                                           " +
                 " FROM " + tablename                                                +
                 " WHERE      t_Chapter        = 1                                 " +
                 "        AND t_Code_Currency  = " + Code_Currency                   +
                 "        AND t_Account_Receiver  = " + GetSQLString( Account )      +
                 dateString                                                          +
                 " GROUP BY t_Chapter, t_Code_Currency, t_Account_Receiver         " ;

      Rs = TRsbDataSet(QueryDoc);
      if( Rs.MoveNext() )

        Kredit     = Kredit     + Rs.value( "t_SumKred", null, V_MONEY );
        KreditCorr = KreditCorr + Rs.value( "t_SumCorr", null, V_MONEY );
      end;

    end;

    if( Code_Currency == 0 )
      tablename = "darhdoc_dbt";
    else
      tablename = "darhdoc$_dbt";
    end;
    DateCompString = "        AND t_Date_Carry    >= " + GetSQLDate( Dat1 )+
                     "        AND t_Date_Carry    <= " + GetSQLDate( Dat2 );
    Query( tablename, DateCompString);

    SetParm( 4, KreditCorr );

    return Kredit;
end;

/* Остаток счета на дату Dat с учетом исправительных оборотов */
macro RestAcc( Account, Code_Currency, Dat1, Dat2 )
  var
    Rest = $0,
    Debet,  DebetCorr,
    Kredit, KreditCorr;

  if ( Code_Currency == 0 )
    Rest = RestA ( Account, Dat2  );
  else
    Rest = RestAC( Account, Code_Currency, Dat2  );
  end;

  if( ( Dat1 != NULL ) and ( Dat1 <= Dat2 ) )
    Debet  = DebetAcc ( Account, Code_Currency, Dat1, Dat2, DebetCorr );
    Kredit = KreditAcc( Account, Code_Currency, Dat1, Dat2, KreditCorr);
    Rest   = Rest + ( DebetCorr - KreditCorr );
  end;

  return Rest;
end;

/*--------------------------------------------------------------------*/
macro GetAcnt( a, ab )
   a.Chapter = ab.Chapter;
   a.Account = ab.Account;
   if ( not getEQ(a) )
        RE.MessError( "Не найдена запись в файле лицевых счетов для ЛС " + ab.Account );
        return FALSE;
   else return TRUE;
   end;
end;

macro GetAcntC( a, ab )
   a.Chapter = ab.Chapter;
   a.Account = ab.Account;
   a.Code_Currency = ab.Code_Currency;
   if ( not getEQ(a) )
        RE.MessError( "Не найдена запись в файле лицевых счетов для ЛС " + ab.Account );
        return FALSE;
   else return TRUE;
   end;
end;

/*  Фильтр открытых на отчетный период лиц.счетов  */
macro FiltrOpen( a )
   if ( not ТолькоОткрытые ) return TRUE;
   elif ( a.Open_Date > EndDat )
         return FALSE;   /* открыт после отчетной даты */
   elif ( ( a.Open_Close == "З" ) and ( a.Close_Date < BegDat ) )
         return FALSE;   /* закpыт до отчетного периода */
   else  return TRUE;
   end;
end;


/*--------------------------------------------------------------------*/
macro  IsAccVal(ac)
   if ( ( ac.Code_Currency == 0 )     /* Рублевое покрытие */
   and  ( ( index( ac.Type_Account, "П" ) > 0 )
      or  ( index( ac.Type_Account, "Н" ) > 0 )
      or  ( index( ac.Type_Account, "М" ) > 0 ) ) )
        return TRUE;
   else return FALSE;
   end;
end;

/*--------------------------------------------------------------------*/
macro ControlTemp(a)  /* сообщения в протокол контроля */
 var str, nerr = 0, i;


   i = DefNum( a.Balance );
   if ( IsNotResident( pt ) )
      if (( i == 0 ) or ( i == 7 ) or ( i == 9 ) )
            str = "Клиент " + pt.ShortName + " является НЕрезидентом";
            Contr_1( a, 1, str );
      end;

      if ( pt.NrCountry == "" )
            str = "Для клиента-нерезидента " + pt.ShortName + " не указана страна нерезидента";
            Contr_1( a, 1, str );
      end;
   else
      if (( i >= 2 ) and ( i <= 6 ) or ( i == 8 ) or ( i >= 10 ) and ( i <= 12 ) )
            str = "Клиент " + pt.ShortName + " НЕ является нерезидентом";
            Contr_1( a, 1, str );
      end;
   end;

   if ( a.RestOut != (a.RestIn - a.Debet + a.Kredit) )

     First2 = false;
     str = "Факт. исх. остаток " + string(abs(a.RestOut)) +
           ", рассчит.исх.остаток " + string(abs(a.RestIn - a.Debet + a.Kredit)) +
           ", сумма несоответствия " + string(abs( a.RestOut - (a.RestIn - a.Debet + a.Kredit) ));
            Contr_1( a, 2, str );

   end;

end;


/*-----------------------------------------------------------------------*/
macro InsertTempRec( temp )

   message( temp.Balance, " ", temp.Account);

   ControlTemp(temp);  /* сообщения в протокол контроля */

   if ( not insert( temp ) )
     RE.MessError( "Не внесена запись во временный файл для ЛС " + temp.Account );
     return FALSE;
   end;

   return TRUE;
end;

/*--------------------------------------------------------------------*/
macro InitTempRec( a, Balance, FlagCur)    /* Новая запись во временный файл */
  var  iDat, D, str,
       DebetCorr, KreditCorr;

   temp.Chapter = FlagCur;    /* Все/Рубли/Валюта*/
   temp.Balance = Balance;

   if( not GetRecParty( a.Client ) )  return;  end;

   if( IsNotResident( pt ) )
     temp.Kind_Account   = "N";
   else
     temp.Kind_Account   = "";
   end;
   temp.Account        = a.Account;
   temp.Client         = pt.PartyID;
   temp.Name_Client    = pt.ShortName;
   temp.Name           = pt.Name;
   temp.Code_Client    = GetCodParty(pt.PartyID, KindCODE);
   temp.Code_Currency  = a.Code_Currency;

  if ( (temp.Code_Currency > 0 ) and СуммыВРублях )

      temp.Debet   = DebetAcc( a.Connect_Account, 0, BegDat, EndDat, DebetCorr);
      temp.Kredit  = KreditAcc( a.Connect_Account, 0, BegDat, EndDat, KreditCorr );
      temp.RestOut = RestAcc( a.Connect_Account, 0, a.Open_Date, EndDat );
      temp.RestIn  = RestAcc( a.Connect_Account, 0, a.Open_Date, InDat );

  else
   temp.Debet   = DebetAcc( a.Account, a.Code_Currency, BegDat, EndDat, DebetCorr );
   temp.Kredit  = KreditAcc( a.Account, a.Code_Currency, BegDat, EndDat, KreditCorr );
   temp.RestOut = RestAcc( a.Account, a.Code_Currency, a.Open_Date, EndDat );
   temp.RestIn  = RestAcc( a.Account, a.Code_Currency, a.Open_Date, InDat );
   /*if ( InDat  == date( 33, 12, 1997 ) )
        temp.RestIn  = temp.RestIn/1000; /* Учет старого масштаба курса до деноминации */
   end; */
/*   temp.RestIn  = temp.RestOut + temp.Debet - temp.Kredit;*/
  end;

  if ( IsNullTemp(temp) )
   if ( not ПечатьНулевых ) return TRUE;   end;
  else
     ФормаНулевая = FALSE;
  end;

  return InsertTempRec( temp );

end;

macro Conv( Sum )
   return floor( Sum/Делитель + 0.5);
end;

macro Округлить( temp)
   var D;

    RestIn  = Conv( doubleL(temp.RestIn) );
    RestOut = Conv( doubleL(temp.RestOut) );
    Kredit  = Conv( doubleL(temp.Kredit) );
    Debet   = Conv( doubleL(temp.Debet) );
    if (not isNormalizedData)
            /* сходимость по строке после округления - корректировка оборотов */
        D = RestOut - RestIn + Debet - Kredit;
        if   ( D > 0 )
               Kredit  = Kredit + abs(D);
        elif ( D < 0 )
               Debet   = Debet  + abs(D);
        end;
        RestIn  = abs( RestIn );
        RestOut = abs( RestOut );
    end;
    if ( ПечатьНулевых )  return TRUE;
    elif ( (RestIn != 0) or (RestOut != 0) or (Debet != 0) or (Kredit != 0))
          return TRUE;
    else  return FALSE;
    end;
end;

/*-----------------------------------------------------------------------*/
macro  CheckOneBal( i,
               Bal,
               RestIn,
               RestOut,
               Debet,
               Kredit,
               cur_rub,   /* валюта */
               rub_th    /* в тысячах */
               )
 var
  Cur, val, valT;

 macro CheckEQ(v1, v2)
   if( rub_th )
    return abs( v1 - abs(v2) ) >= $0.01;
   else
    return abs( v1 - abs(v2) ) >= 0.000000001;
   end;
 end;

 macro ins_err(Num : Integer, val : Money, val_bal : Money)
 Var prim = "Сумма ";


  if( rub_th and first_err_rub )
   first_err_rub = false;
  elif( ( not rub_th ) and first_err_th )
   first_err_th = false;
  end;

  if  ( Num == 1 )
   prim = prim + " вх. ост. по б/с";
  elif( Num == 2 )
   prim = prim + " исх. ост. по б/с";
  elif( Num == 3 )
   prim = prim + " Дт.об. по б/с";
  elif( Num == 4 )
   prim = prim + " Кт.об. по б/с";
  end;

  if( cur_rub == 0 )
   prim = prim + " (рубли) ";
  else
   prim = prim + " (валюта) ";
  end;
  prim = prim + string( abs(val) )+
         ", по балансу " + string(val_bal) + ", разность " + string((abs(val) - abs(val_bal))) ;

  ClearRecord( temp_err );
  if ( rub_th )
    temp_err.chapter = 3;
  else
    temp_err.chapter = 4;
  end;
  temp_err.Balance     = Bal;
  temp_err.NameAccount = prim;
   if ( not insert( temp_err ) )
     RE.MessError( "Не внесена запись в временный файл ошибок для ЛС " + temp.Account );
     return FALSE;
   end;

 end;


  balance.iNumPlan = НомерПлана;
  balance.Balance = Bal;
  balance.Chapter = 1;
  if( not getEQ( balance ) )
   msgbox( "Не найден балансовый ", Bal, " в файле балансовых счетов!" );
   return;
  end;
  if( cur_rub == 1 )
    Cur = "По";
  elif( cur_rub == 0 )
    Cur = "Ру";
  end;
   /*1*/
  if (not ПрочитатьПеременную2( val, valT, EndDat, BegDat, "Балансовые счета","Бн" + Bal + Cur + balance.Kind_Account ))
      msgBox("Не найдена расчитанная переменная " + "Бн" + Bal + Cur + balance.Kind_Account +
             " формы \"Балансовые счета\" \nза период с " + BegDat + " по " + EndDat);
      exit(1);
  else
      if( cur_rub == 0 )
       БС_RestOutBalTh(i) = valT;
      elif( cur_rub == 1 )
       БС_RestOutBalTh_C(i) = valT;
      end;
      if( rub_th and CheckEQ( val, RestOut) )
        ins_err( 2, RestOut, val );
      elif( ( not rub_th ) and CheckEQ( valT, RestOut) )
        ins_err( 2, RestOut, valT );
      end;
  end;
  /*2*/
  if (not ПрочитатьПеременную2( val, valT, EndDat, BegDat, "Балансовые счета", "Бн" + Bal + Cur + "Д" ))
      msgBox("Не найдена расчитанная переменная " + "Бн" + Bal + Cur + "Д" +
             " формы \"Балансовые счета\" \nза период с " + BegDat + " по " + EndDat);
      exit(1);
  else
      if( cur_rub == 0 )
       БС_DebetBalTh(i) = valT;
      elif( cur_rub == 1 )
       БС_DebetBalTh_C(i) = valT;
      end;
      if( rub_th and CheckEQ( val, Debet ) )
        ins_err( 3, Debet, val );
      elif( ( not rub_th ) and CheckEQ( valT, Debet) )
        ins_err( 3, Debet, valT );
      end;
  end;
  /*3*/
  if (not ПрочитатьПеременную2( val, valT, EndDat, BegDat, "Балансовые счета", "Бн" + Bal + Cur + "К" ))
      msgBox("Не найдена расчитанная переменная " + "Бн" + Bal + Cur + "К" +
             " формы \"Балансовые счета\" \nза период с " + BegDat + " по " + EndDat);
      exit(1);
  else
      if( cur_rub == 0 )
       БС_KreditBalTh(i) = valT;
      elif( cur_rub == 1 )
       БС_KreditBalTh_C(i) = valT;
      end;
      if( rub_th and CheckEQ( val, Kredit ) )
        ins_err( 4, Kredit, val );
      elif( ( not rub_th ) and CheckEQ( valT, Kredit ) )
        ins_err( 4, Kredit, valT );
      end;
  end;
end;

/*-----------------------------------------------------------------------*/
/* Проверка на соответствие данных формы данным баланса
   по счетам второго порядка */

macro Control_Balance()
 var i = 0, l_next;

  message( "Контроль с балансовыми счетами..." );

  while( i < NumBal )
   RestInBal(i)  = $0;  RestInBalTh(i)  = 0;
   RestOutBal(i) = $0;  RestOutBalTh(i) = 0;
   DebetBal(i)   = $0;  DebetBalTh(i)   = 0;
   KreditBal(i)  = $0;  KreditBalTh(i)  = 0;
   RestInBal_C(i)  = $0;  RestInBalTh_C(i)  = 0;
   RestOutBal_C(i) = $0;  RestOutBalTh_C(i) = 0;
   DebetBal_C(i)   = $0;  DebetBalTh_C(i)   = 0;
   KreditBal_C(i)  = $0;  KreditBalTh_C(i)  = 0;
   i = i + 1;
  end;
  i = 0;

 rewind( temp );
 keynum( temp, 2 );

 while( i < NumBal )
  temp.Balance = Bal1(i);
  temp.Name_Client = "";
  l_next = getGE( temp );

  while( l_next and ( temp.Balance == Bal1(i) ) )
   RestIn  = Conv( doubleL(temp.RestIn) );
   RestOut = Conv( doubleL(temp.RestOut) );
   Debet   = Conv( doubleL(temp.Debet) );
   Kredit  = Conv( doubleL(temp.Kredit) );

   if( temp.Code_Currency == 0 )
    RestInBal(i)    = RestInBal(i)    + temp.RestIn;
    RestOutBal(i)   = RestOutBal(i)   + temp.RestOut;
    DebetBal(i)     = DebetBal(i)     + temp.Debet;
    KreditBal(i)    = KreditBal(i)    + temp.Kredit;

    RestInBalTh(i)  = RestInBalTh(i)  + RestIn;
    RestOutBalTh(i) = RestOutBalTh(i) + RestOut;
    DebetBalTh(i)   = DebetBalTh(i)   + Debet;
    KreditBalTh(i)  = KreditBalTh(i)  + Kredit;
   else
    RestInBal_C(i)    = RestInBal_C(i)    + temp.RestIn;
    RestOutBal_C(i)   = RestOutBal_C(i)   + temp.RestOut;
    DebetBal_C(i)     = DebetBal_C(i)     + temp.Debet;
    KreditBal_C(i)    = KreditBal_C(i)    + temp.Kredit;

    RestInBalTh_C(i)  = RestInBalTh_C(i)  + RestIn;
    RestOutBalTh_C(i) = RestOutBalTh_C(i) + RestOut;
    DebetBalTh_C(i)   = DebetBalTh_C(i)   + Debet;
    KreditBalTh_C(i)  = KreditBalTh_C(i)  + Kredit;
   end;
   l_next = next( temp );
  end;

  CheckOneBal( i, Bal1(i),
               RestInBal(i),
               RestOutBal(i),
               DebetBal(i),
               KreditBal(i),
               0,   /* рубли */
               true /* в копейках */
               );
  CheckOneBal( i, Bal1(i),
               RestInBal_C(i),
               RestOutBal_C(i),
               DebetBal_C(i),
               KreditBal_C(i),
               1,   /* валюта */
               true /* в копейках */
               );

  CheckOneBal( i, Bal1(i),
               RestInBalTh(i),
               RestOutBalTh(i),
               DebetBalTh(i),
               KreditBalTh(i),
               0,   /* рубли */
               false /* в тысячах */
               );
  CheckOneBal( i, Bal1(i),
               RestInBalTh_C(i),
               RestOutBalTh_C(i),
               DebetBalTh_C(i),
               KreditBalTh_C(i),
               1,   /* валюта */
               false /* в тысячах */
               );

  i = i + 1;
 end;
 if( not first_err_rub )
     ClearRecord( temp_err );
     temp_err.chapter     = 3;
     temp_err.Balance     = "999999";
     temp_err.NameAccount = "!Ошибка: Данные формы отличаются от данных баланса в рублях.\n" +
                            " Нормализация с балансом не может быть проведена.";
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок" );
     end;
     temp_err.chapter     = 3;
     temp_err.Balance     = "9999999";
     temp_err.NameAccount = " Проверьте правильность составления отчета.";
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок" );
     end;
     return false;
 end;
 if( not first_err_th )
     ClearRecord( temp_err );
     temp_err.chapter     = 4;
     temp_err.Balance     = "999999";
     temp_err.NameAccount = "!Внимание: Округленные данные формы отличаются от данных баланса.\n" +
                            " Возможна нормализация формы с балансом.";
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок" );
     end;
 end;
 return true;
end;

/*-----------------------------------------------------------------------*/
/* Печать протокола контроля из временного файла ошибок                                */
macro PrintErr( )
Var Sec = 0,   nsec = 0,  ns = 1,
    Bal_Prev = "",  Acc_Prev = "",
    ЕстьОшибки = False;

Var NameSec = TARRAY;
NameSec(1) = "I. Логический контроль.";
NameSec(2) = "II. Контроль на балансирование счетов.";
NameSec(3) = "III. Контроль на соответствие с данными баланса в рублях.";
NameSec(4) = "IV. Контроль на соответствие с данными баланса в тысячах.";

  setoutput( NameFileCnt );

println( "Форма 603. Сведения об открытых корреспондентских счетах и остатках средств на них" );
println( "Протокол контроля" );
println( "Период отчета с ", ПредДатаОтчета, " по ", ДатаОтчета );
println( "Исполнитель: ", GetNameOper );
println( "Дата и время выпуска отчета ", date(), "   ", time(),"\n" );

    if (Nrecords( temp_err ) == 0 )
        println( "Контроль проведен успешно, ошибок в отчете не обнаружено." );
        return;
    end;


    rewind( temp_err );
    keynum( temp_err, 3 );
[

 ┌──────┬──────────────────────────┬──────────────────────────────────────────────────┐
 │№ БС  │ № лицевого счета         │  Примечание                                      │
 └──────┴──────────────────────────┴──────────────────────────────────────────────────┘
];


while ( next( temp_err ) )
  if ( not first_err_rub and ( temp_err.Chapter == 4 ) );
  else
       if( temp_err.Chapter != Sec )
         while( ns <= temp_err.Chapter )
            if ( ns > 1 )
               [ Всего ошибок: ####### ]( nsec );
               if ( nsec > 0 ) nsec = 0; end;
            end;
            println( "\n ", NameSec( ns ));
            ns = ns + 1;
         end;
         Sec  = temp_err.Chapter;
         nsec = 0;
       end;
       if ( ( temp_err.Balance == "9999999" ) and
            (( temp_err.Chapter == 2 ) or ( temp_err.Chapter == 3 ))
           )
            ЕстьОшибки = True;
       end;

       if ( ( temp_err.Balance != "999999" ) and ( temp_err.Balance != "9999999" ) )
         nsec = nsec + 1; /* cчетчик ошибок по разделу */
       end;

      if( temp_err.Balance == "999999" )
           [ Всего ошибок: #######  ]( nsec );
           [
             #
           ] (temp_err.NameAccount:w);
           nsec = 0;
      elif( temp_err.Balance == "9999999" )
           [ #] (temp_err.NameAccount:w);
      else
        if (( temp_err.Account == Acc_Prev ) and  ( temp_err.Balance == Bal_Prev ) )
[                                    #################################################
]( temp_err.NameAccount:w );
        else
[ #####  ##########################  #################################################
]( temp_err.Balance, temp_err.Account:f, temp_err.NameAccount:w );
         Acc_Prev = temp_err.Account;
         Bal_Prev = temp_err.Balance;
        end;

      end;

 end;
end; /*while next  */

         if ( nsec > 0 )
[ Всего ошибок: #######                            ]( nsec );
         end;
     if ( not ЕстьОшибки )
         while( ns <= 4 )
            println( "\n ", NameSec( ns ));
            [ Всего ошибок: 0 ];
            ns = ns + 1;
         end;
     end;
[──────────────────────────────────────────────────────────────────────────────────────
];

 setoutput( Null, TRUE );
end;

/*-----------------------------------------------------------------------*/
/* Создание временного файла по л/счетам                                 */
macro CreateTemp( )
   var i, j, FirstAb = TRUE, НомерПоля, FlagCur,
      stat = TRUE;

   macro NextAb(ab,Balance)
     if ( FirstAb )
       FirstAb = False;
       ab( НомерПоля ) = Balance;
       ab.Account = "";
       ab.Chapter = 1;
       return  getGE( ab )
               and ( ab( НомерПоля) == Balance )
               and ( ab.Chapter == 1 );
     else
       return  next( ab )
               and ( ab( НомерПоля ) == Balance )
               and ( ab.Chapter == 1 );
     end;
   end;

   macro DoTempOneBalance( a, ab, Balance, Mask )
     var stat1 = TRUE;
     FirstAb = TRUE;
     while( stat1 and NextAb(ab,Balance) )
        i = i + 1;
        UseProgress( i );
        /* Фильтрация по ТС/РС */
        if ( GetAcnt( a, ab ) and FiltrOpen(a) and GetOwnParty( a.Client, KIND_OWN_CLIENT) )
          if ( not IsAccVal(a) and FiltrMask( a.Account, Mask ) and accountFilter.IsSuitable( a ) )
            stat1 = InitTempRec( a, Balance, FlagCur );
          end;
        end;
     end;
     return stat1;
   end;

    /*------ Открыть врем.файл ошибок--------*/
   SQL_Truncate(temp_err);
    /*------ По рублевым счетам --------*/

    if ( ПечатьРублевыхОтдельно )    FlagCur = FLAG_RUB;
    else                             FlagCur = FLAG_ALL;
    end;

    i = 0; j = 0;
    keynum( abR, НомерПлана );
    НомерПоля = НомерПлана + 2;
    InitProgress( NRecords(abR), "", "Создание временного файла - рублевые счета" );
    while( stat and (j < NumBal) )
      stat = DoTempOneBalance( acR, abR, Bal1(j), MaskAccount1(j) );
      j = j + 1;
    end;
    RemProgress;

    if ( not stat ) return FALSE; end;

    /*------ По валютным счетам --------*/

    ReplaceMacro( "GetAcnt", "GetAcntC" );

    if ( ПечатьРублевыхОтдельно )    FlagCur = FLAG_CUR;
    else                             FlagCur = FLAG_ALL;
    end;
    i = 0; j = 0;
    keynum( abC, НомерПлана );
    НомерПоля = НомерПлана + 2;
    InitProgress( NRecords(abC), "", "Создание временного файла - валютные счета" );
    while( stat and (j < NumBal) )
      stat = DoTempOneBalance( acC, abC, Bal1(j), MaskAccount1(j) );
      j = j + 1;
    end;
    RemProgress;

    ReplaceMacro( "GetAcnt" );


    if (  not ПроверитьСохраненнДаты( НомерПодразделения,
                                 "Балансовые счета",
                                 {Вид переменной},
                                 EndDat,
                                 BegDat) )
     БалансРассчитан = false;
     ClearRecord( temp_err );
     temp_err.chapter     = 2;
     temp_err.Balance     = "999999";
     temp_err.NameAccount = string( "!Внимание: Расчет баланса за период с ", BegDat, " по ", EndDat,
               " отсутствует. ");
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок для ЛС " + temp.Account );
     end;
     temp_err.Balance     = "9999999";
     temp_err.NameAccount = string( "Контроль соответствия данных формы 603 данным баланса производиться не будет!");
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок для ЛС " + temp.Account );
     end;
/*     PrintErr();*/
    return stat;
    end;

    if (  not ПроверитьСохраненнДаты( НомерПодразделения,
                                 "Балансовые счета",
                                 {Вид переменной},
                                 EndDat,
                                 BegDat) )
     БалансРассчитан = false;
     ClearRecord( temp_err );
     temp_err.chapter     = 2;
     temp_err.Balance     = "999999";
     temp_err.NameAccount = string( "!Внимание: Расчет баланса за период с ", BegDat, " по ", EndDat,
               " отсутствует. ");
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок для ЛС " + temp.Account );
     end;
     temp_err.Balance     = "9999999";
     temp_err.NameAccount = string( "Контроль соответствия данных формы 603 данным баланса производиться не будет!");
     if ( not insert( temp_err ) )
        RE.MessError( "Не внесена запись в временный файл ошибок для ЛС " + temp.Account );
     end;
/*     PrintErr();*/
    return stat;
    end;

    БалансРассчитан = true;
    if( not Control_Balance() )
/*      PrintErr();*/
      return stat;
    end;

  /*  PrintErr();*/
    if( not First2 or not first_err_th )
     if( not getTrue( TRUE, "Проводить процедуру нормализации с балансом?" ) )
      return stat;
     end;
     normalizeData();
     isNormalizedData = true;
    end;

   return stat;
end;


/*-----------------------------------------------------------------------*/
macro ServClientBIC()
  var PartyID, RegNumber_0, BIC_0, prim, str;

  var partyIdBuffer;
  var bicBuffer;

  pt.PartyID = temp.Client;
  getEQ( pt );
  if ( IsNotResident( pt ) )
       BIC = КодСтраныНерезидента;
   if( ДатаОтчета < ДАТА1376У )
       RegNumber = GetNameCountry( pt.NRCountry );
   else
       RegNumber = GetCodParty( pt.PartyID, PTCK_SWIFT );
   end;
  else /*Клиент - резидент*/
    if( ДатаОтчета < ДАТА1376У )
     BIC_0     = GetCodParty( pt.PartyID, PTCK_BIC );
    else
     BIC       = "643";/*Код России*/
    end;
    RegNumber_0 = GetCodParty( pt.PartyID, KindREGNUM );

    if( pt.Superior > -1 ) /* В анкете клиента указана вышестоящая организация */
      pt.PartyID = pt.Superior;

      if( not getEQ( pt ) )
       /* В протокол - нет такой вышестоящей организации */
       if( ДатаОтчета < ДАТА1376У )
        BIC       = BIC_0;
       end;
       RegNumber = RegNumber_0;
       prim = "В анкете клиента указана несуществующая головная организация";
       Contr_1( temp, 1, prim )
      else
        if( ДатаОтчета < ДАТА1376У )
         BIC       = GetCodParty( pt.PartyID, PTCK_BIC );/*Бик вышестоящей организации*/
        end;
        RegNumber = GetCodParty( pt.PartyID, KindREGNUM );/*Рег.номер вышестоящей организации*/
      end;
    else  /* В анкете клиента не указана вышестоящая организация */
         /*Регистрационный номер имеет вид "XXXX/N*" - для филиала */
      if( ( strlen( RegNumber_0 ) > 4 ) and ( substr( RegNumber_0, 5,1 ) == "/" ) )
          RegNumber = substr( RegNumber_0, 1, 4 );/*Рег.номер головной организации*/
          /* 02.10.2007 Malakhova 110424*/
          /*Историзация кодов*/
          partyIdBuffer = repGetPartyCode(RegNumber, KindREGNUM);

          if (partyIdBuffer != NULL)/*Ищем по рег.номеру головную организацию*/
            PartyID = partyIdBuffer;
            bicBuffer = repGetPartyCode(PartyID, PTCK_BIC);

            if (bicBuffer != "")

             if( ДатаОтчета < ДАТА1376У )
              BIC = bicBuffer; /*Бик головной организации*/
             end;
             prim = "Клиент-резидент " + pt.ShortName +" имеет рег. номер филиала " +
             RegNumber_0 + ". Рекомендуется указать вышестоящую организацию";
             Contr_1( temp, 1, prim );
            else
            /*В протокол - не задан Бик головной организации*/
             if( ДатаОтчета < ДАТА1376У )
              BIC       = BIC_0;
              RegNumber = RegNumber_0;
              prim = "Головн. орг-ция, найденная по рег. номеру, не имеет БИК. В отчете будут указаны данные филиала";
              Contr_1( temp, 1, prim );
             end;
            end;
          else
          /*В протокол - не нашли организацию с таким рег.номером*/
             if( ДатаОтчета < ДАТА1376У )
              BIC       = BIC_0;
             end;
             RegNumber = RegNumber_0;
             prim = "По рег. номеру не найдена головн. орг-ция. В отчете будут указаны данные филиала";
             Contr_1( temp, 1, prim );
          end;
      else /*Регистрационный номер не имеет вид "XXXX/N*" - для филиала */
       if( ДатаОтчета < ДАТА1376У )
        BIC       = BIC_0;
       end;
       RegNumber = RegNumber_0;
      end;
    end;
  end;

  if ( RegNumber == "")
      str="Для клиента " + pt.shortName + " не указан регистрационный номер";
      Contr_1(temp, 1, str);
  end;
end;

/*-----------------------------------------------------------------------*/

macro  ServClient( Client, FlagCur )

  macro ServAccount( temp )
    if ( not Округлить(temp) ) return; end;

    PrintAccount( temp );
  end;

  temp.Chapter  = FlagCur;
  temp.Client   = Client;
  temp.Code_Currency = 0;
  temp.Account  = "";
  if ( getGE(temp) and ( temp.Chapter == FlagCur) and ( temp.Client == Client) )
    if ( ( not ПечатьОтдельноПоРезидентности )
      or ( temp.Kind_Account == NotResident ) )

      if ( GetRecParty( Client ) )
        ServClientBIC();
        ServAccount( temp );
        while ( next(temp) and ( temp.Chapter == FlagCur) and ( temp.Client == Client) )
          ServAccount( temp );
        end;
      end;
    end;
  end;
end;

/*-----------------------------------------------------------------------*/
macro  ScanPTNAME( FlagCur, strMain)
  var  Nrec = 0,
  ptpos, ptkey;

  InitProgress( NRecords( pt ),"", strMain);
  rewind(pt);
  keynum( pt, 1 ); /* по названию */
  while ( next(pt) )
    if ( GetOwnParty( pt.PartyID, KIND_OWN_CLIENT) )
        /* Сохранить текущее состояние файла  */
      ptpos   = GetPos(pt);
      ptkey   = KeyNum(pt);

      ServClient( pt.PartyID, FlagCur);

      /* Восстановить предыдущее состояние файла  */
      KeyNum(pt,ptkey);
      GetDirect(pt,ptpos);

    end;
    Nrec = Nrec + 1;
    UseProgress( Nrec );
  end;
  RemProgress();
end;

macro  ScanPTCODE(  FlagCur,strMain)
  var  Nrec = 0, cont,
       ptpos, ptkey;

  /* 04.10.2007 Malakhova 110424*/
  /*Переписала на TRsbDataSet*/

  var filterString;
  var queryText;
  var data;

  InitProgress(-1,"", strMain);

  if (getObjcodeDate() != NULL) /*Если задана дата отчета - то ищем на нее*/
      filterString = setFilterForCodeDate("obj", getObjCodeDate(), 1);
  else /*Если дата отчета не задана, то рассматриваем только активные коды*/
      filterString = setFilterForCodeDate("obj", NULL, 1);
  end;

  queryText =          "SELECT * "
              + "\n" + "  FROM dobjcode_dbt obj"
              + "\n" + " WHERE obj.t_codeKind    = " + KindCODE
              + "\n" + "   AND obj.t_objectType  = " + OBJTYPE_PARTY
              + "\n" + "   AND " + filterString;

  data = TRsbDataSet(queryText);

  while(data.next())
     if ((data.CodeKind == KindCODE) and (data.ObjectType == OBJTYPE_PARTY))
         if (GetOwnParty(data.ObjectID, KIND_OWN_CLIENT))
           ServClient(data.ObjectID, FlagCur);
         end;
         Nrec = Nrec+1;
         UseProgress(Nrec);
     end;
  end;

  RemProgress();

end;

macro  ScanPTOWN(  FlagCur,strMain )
  var  Nrec = 0, cont;

  InitProgress( NRecords( ptown ),"",  strMain);
  keynum(ptown, 1);
  ptown.PartyKind = KIND_OWN_CLIENT;
  ptown.PartyID = 0;
  cont = getGE(ptown);
  while (cont and (ptown.PartyKind == KIND_OWN_CLIENT))
    ServClient( ptown.PartyID,  FlagCur);
    Nrec = Nrec+1;
    UseProgress(Nrec);
    cont = next(ptown);
  end;
  RemProgress();

end;
/*------------------------------------------------------------------------*/
macro  ScanTEMP( FlagCur, strMain)
  var  Nrec = 0,
       firstCln = TRUE,
       client = -1;

  macro ServAccount( temp )
    if ( not Округлить(temp) ) return; end;

    PrintAccount( temp );
  end;

  InitProgress( NRecords( temp ),"", strMain);
  rewind(temp);
  while ( next(temp) )
   if( temp.Chapter == FlagCur)
    if( ( not ПечатьОтдельноПоРезидентности ) or
        ( temp.Kind_Account == NotResident ) )
     if( client != temp.Client )
      client = temp.Client;
      firstCln = TRUE;
      ServClientBIC();
     end;
     ServAccount( temp );
    end;
   end;
   Nrec = Nrec + 1;
   UseProgress( Nrec );
  end;
  RemProgress();
end;

/*-----------------------------------------------------------------------*/
macro  ServCur( FlagCur, strMain )
 var   rub,
       str = "",
       strM = strMain;

  if ( Nrecords( temp ) == 0 )
    return;
  end;
  if( FlagCur == FLAG_RUB)
       rub  = "Рублевые счета";
  elif( FlagCur == FLAG_ALL )
       rub  = "Рублевые и валютные счета";
  elif( FlagCur == FLAG_CUR )
       rub  = "Валютные счета";
  end;
  if( ПечатьОтдельноПоРезидентности )
      NotResident = "";
      str = "\nПо кредитным организациям резидентам ( " + rub + " )\n" ;
      strM = strMain + " - резидентам";
  elif( ПечатьРублевыхОтдельно )
      str = "\n " + rub + "\n";
  end;
  Head( str );
  if ( СортировкаКлиентов == ПоКраткомуНазванию )
   if ( СортировкаПоБалансовым )
     keynum( temp, 2 );
   else
     keynum( temp, 0 );
   end;
  elif ( СортировкаКлиентов == ПоКодуКлиента )
   if ( СортировкаПоБалансовым )
     keynum( temp, 3 );
   else
     keynum( temp, 1 );
   end;
  end;

  ScanTEMP( FlagCur,strM );

  Footer();

  if( ПечатьОтдельноПоРезидентности )
   NotResident = "N";
   str = "\nПо кредитным организациям нерезидентам ( " + rub + " )\n" ;
   strM = strMain + " - нерезидентам";
   Head( str );

   if ( СортировкаКлиентов == ПоКраткомуНазванию )
    if ( СортировкаПоБалансовым )
     keynum( temp, 2 );
    else
     keynum( temp, 0 );
    end;
   elif ( СортировкаКлиентов == ПоКодуКлиента )
    if ( СортировкаПоБалансовым )
     keynum( temp, 3 );
    else
     keynum( temp, 1 );
    end;
   end;

   ScanTEMP( FlagCur,strM );

   Footer();
  end;
end;

/*-----------------------------------------------------------------------*/
/* печать отчета  */
macro PrintReport

  PrintHeader();
  if( not ФормаНулевая )
   if ( ПечатьРублевыхОтдельно )
    ServCur( FLAG_RUB, "Печать отчета по клиентам (рубли)" );
    ServCur( FLAG_CUR, "Печать отчета по клиентам (валюта)" );
   else
    ServCur( FLAG_ALL, "Печать отчета по клиентам" );
   end;
  else
   println("Данные отсутствуют");
  end;
  PrintFooter();
  PrintErr();

end;
/*-----------------------------------------------------------------------*/
macro InitParm ()

   Clone(temp);
   Clone(temp_err);

   BegDat  = ПредДатаОтчета;
   EndDat  = ДатаОтчета;
   RepDat  = GetCorrectPrnRepDate();

   InDat   = BegDat-1;

   if ( BegDat > {curdate} )
       msgbox("Отчетный период еще не наступил"); exit(1);
   end;

end;

/*=================================================*/
/*    Функции для экспорта данных в текстовый файл */
/*=================================================*/
macro DDMM( dat )
   var D, M;
   datesplit( dat, D, M );
   return repLZ(D,2) + repLZ(M,2);
end;

macro MM( dat )
   var  D, M;
   datesplit( dat, D, M );
   return  repLZ(M,2);
end;

macro YYYYMMDD( dat )
   var D, M, Y;
   datesplit( dat, D, M, Y );

   if( ЭкспортВ == loro )
     return string(Y)  + repLZ(M,2) + repLZ(D,2);
   elif( ЭкспортВ == kliko )
     return repLZ(D,2)  + repLZ(M,2) + repLZ(Y,4);
   end;

end;

macro PutAccountExp( temp )

    var  RegNumber8,
         RegNumber3;
    var  Nm;

    if( ЭкспортВ == loro )
      RE.AddExp1( "\""+ temp.Name +"\",");
      RE.AddExp1( "\""+ RegNumber +"\",");
      RE.AddExp1( "\""+ BIC +"\",");
      RE.AddExp1( "\""+ temp.Balance +"\",");
      RE.AddExp1( "\""+ temp.Account +"\",");
      RE.AddExp1( "\"\",");
      RE.AddExp1( string(RestIn:0:0) +",");
      RE.AddExp1( string(Debet:0:0) +",");
      RE.AddExp1( string(Kredit:0:0) +",");
      RE.AddExp1( string(RestOut:0:0) );
      RE.PutStrExp;

    elif( ЭкспортВ == kliko )

      if( First )
        RE.AddExp1( "<F603M>");
        RE.PutStrExp;
        First = false;
      end;

      Nm = temp.Name;
      while(Index(Nm, "\""))
       StrSet(Nm, Index(Nm, "\""), "'");
      end;

      RE.AddExp1( "\""+ Nm +"\",");

      pt.PartyID = temp.Client;
      getEQ( pt );
      if ( (IsNotResident( pt )) and (strlen(RegNumber) == 11) )
        RegNumber3 = substr( RegNumber, 9, 3);
        RegNumber8 = substr( RegNumber, 1, 8);
      else
        RegNumber3 = "";
        RegNumber8 = RegNumber;
      end;

      RE.AddExp1( "\""+ RegNumber8 +"\",");
      RE.AddExp1( "\""+ RegNumber3 +"\",");
      RE.AddExp1( "\""+ BIC +"\",");
      RE.AddExp1( "\""+ temp.Balance +"\",");
      RE.AddExp1( "\""+ temp.Account +"\",");
      RE.AddExp1( "\""+string(RestIn:0:0) +"\",");
      RE.AddExp1( "\""+string(Debet:0:0)  +"\",");
      RE.AddExp1( "\""+string(Kredit:0:0) +"\",");
      RE.AddExp1( "\""+string(RestOut:0:0)+"\"," );
      RE.AddExp1( "\"\"," );
      if( IsNotResident( pt ) )
        RE.AddExp1( "\"2\"," );
      else
        RE.AddExp1( "\"1\"," );
      end;
      RE.AddExp1( "\"1\",\"1\",\"\"" );
      RE.PutStrExp;
    end;
end;

/*  Если надо выгружать счета в том же порядке, что и в отчете */
macro  PutExport_603

  ReplaceMacro( "Head", "HeadExp" );
  ReplaceMacro( "PrintAccount", "PutAccountExp" );
  ReplaceMacro( "Footer", "FooterExp" );

  if ( ПечатьРублевыхОтдельно )
    ServCur( FLAG_RUB, "Выгрузка в экспортный файл (рубли)" );
    ServCur( FLAG_CUR, "Выгрузка в экспортный файл (валюта)" );
  else
    ServCur( FLAG_ALL, "Выгрузка в экспортный файл" );
  end;

  ReplaceMacro( "Head" );
  ReplaceMacro( "PrintAccount" );
  ReplaceMacro( "Footer" );
end;

/* Иначе -
macro  PutExport_603
  var  i = NRecords( temp);

  InitProgress( i,"", "Выгрузка в экспортный файл");
  keynum( temp, 1 );
  keynum( pt, 0 );

  i = 0;
  rewind( temp);
  while ( next(temp)  )
    if ( GetRecParty( temp.Client ) )
      if ( Округлить(temp) )
        ServClientBIC();
        PutAccountExp( temp );
      end;
    end;
    i = i+1;
    UseProgress( i);
  end;

  RemProgress;
end;
*/
macro PutExport

var MesEnd;

  datesplit(NULL, MesEnd, NULL);

  if( ЭкспортВ == loro )
      return RE.ServOneExportFile( "603" + repLZ(MesEnd,2) + ".txt",
                                 @PutExport_603 );

  elif( ЭкспортВ == kliko )
    return RE.ServOneExportFile( YYYYMMDD( ДатаОтчета ) + ".603",
                                   @PutExport_603 );
  end;

end;


/*=================================================*/
/*    Выполнение                                   */
/*=================================================*/
MACRO Main()
  InitParm;    /* Ввод параметров */

  RE = ReportAndExport( ПечатнаяФорма,Экспорт, Контроль,
                        NameFileRep,  NameFilePrt, NameFileCnt );

  МаскаНомераЛицевого( );

  RE.RunProc( "603 на "+string(RepDat), /* название формы в протоколе */
               @CreateTemp,  /* подготовка данных + контроль*/
               @PrintReport, /* печать отчета  */
               @PutExport ); /* выгрузка в файл экспорта */

  exit(1);
END;

MACRO ПечатьФормы()
   ПечатнаяФорма = true;
   Экспорт       = false;
   ЭкспортВ      = НеОпределено;
   Main();
END;

MACRO ПечатьИЭкспортВоВсе()
   ПечатнаяФорма = true;
   Экспорт       = true;
   ЭкспортВ      = loro;
   Main();
END;

MACRO ЭкспортВ_loro()
   ПечатнаяФорма = false;
   Экспорт       = true;
   Контроль      = false;
   ЭкспортВ      = loro;
   Main();
END;

MACRO ЭкспортВ_kliko()
   if( ДатаОтчета < ДАТА1376У )
     msgbox("Процедура экспорта в kliko.exe для периода до даты 1376-У не реализована");
     exit(1);
   else
     Экспорт       = true;
     Контроль      = false;
     ЭкспортВ      = kliko;
     ПечатнаяФорма = false;
     Main();
   end;
END;