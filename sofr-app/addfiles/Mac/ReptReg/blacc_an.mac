/*────────────────────────────────────────────────────────────────────────────────┐
  RS-Bank 5.00                                           R-Style Software Lab
  Файл подсистемы "Отчеты ЦБ"

  Анализ присутствия лицевых счетов на балансовых разного порядка.

CREATED : 06.11.01 - Sal.
COMMENT :
MODIFICATIONS:
  26.06.2006 ABP Переделал на использование SQL. 
                 Криво получилось, но работает, в отличие от предыдущего варианта.
                 Если кто-нибудь разродится PL/SQL-аналогами для функций
                 ПолучитьРеальныйНомерПлана() и БалансовыйПредыдущегоПорядка(), то
                 можно будет все переписать на один запрос к БД.
└─────────────────────────────────────────────────────────────────────────────────*/
import ReptCBInter, cb_sql;

Const
  КоличествоГлав = 5;

Var
  Глава = 1,
  ПланСчетов = 0,
  БСПредПор = "",
  ЕстьОшибки = false;

MACRO ЕстьБСПредПорядка( БС, Глава )
  var BalanceCmdText = "SELECT 1 "                                           + "\n" +
                       "  FROM dcx_mbl98_dbt "                               + "\n" +
                       " WHERE t_NumDprt = " + НомерПодразделения            + "\n" +
                       "   AND t_bdRepDate = " + GetSqlDate(ДатаОтчета)      + "\n" +
                       "   AND t_bdPrevDate = " + GetSqlDate(ПредДатаОтчета) + "\n" +
                       "   AND t_iRegCode = " + 0                            + "\n" +
                       "   AND t_iNumPlan = " + ПланСчетов                   + "\n" +
                       "   AND t_Balance = " + GetSqlString(БС)              + "\n" +
                       "   AND t_iChapter = " + Глава                        + "\n",

      Balance = TRsbDataSet(BalanceCmdText);
      
  return Balance.Next();
END;

/*******************************************************************************
                                Точка входа
*******************************************************************************/
var BalanceCmdText, Balance;

const DESCRIPTION_LABEL = "-desc:";

var descriptionLabelIndex = index(cmdArgs, DESCRIPTION_LABEL);

var chapter;

if (descriptionLabelIndex == 0)
    chapter = 0;
else
    chapter = int(substr(cmdArgs, descriptionLabelIndex + strlen(DESCRIPTION_LABEL)));
end;

Глава = 1;
while ( Глава <= КоличествоГлав )
  ПланСчетов = ПолучитьРеальныйНомерПлана( ЛогическийПланСчетов, Глава );

  if ((chapter == 0) or (Глава == chapter))
      BalanceCmdText = "SELECT * "                                           + "\n" +
                       "  FROM dcx_mbl98_dbt "                               + "\n" +
                       " WHERE t_NumDprt = " + НомерПодразделения            + "\n" +
                       "   AND t_bdRepDate = " + GetSqlDate(ДатаОтчета)      + "\n" +
                       "   AND t_bdPrevDate = " + GetSqlDate(ПредДатаОтчета) + "\n" +
                       "   AND t_iRegCode = " + 0                            + "\n" +
                       "   AND t_iNumPlan = " + ПланСчетов                   + "\n" +
                       "   AND t_iChapter = " + Глава                        + "\n";
    
      Balance = TRsbDataSet(BalanceCmdText);
    
      while ( Balance.Next() )
          Message( "Анализ балансового счета \"", Balance.Balance, "\"" );
          БСПредПор = БалансовыйПредыдущегоПорядка( Balance.Balance, Глава );
    
          if ( ЕстьБСПредПорядка( БСПредПор, Глава ) )
            println("***********************************************************************");
            println(" Предупреждение для балансового счета \"", БСПредПор, "\":\n");
            println(" На балансовом счёте \"", БСПредПор, "\" открыты лицевые, но он имеет");
            println(" балансовый счет низшего порядка \"", Balance.Balance, "\", поэтому данные лицевых");
            println(" счетов, открытых непосредственно на \"", БСПредПор, "\" учтены не были.\n");
            ЕстьОшибки = true;
          end;
      end;
  end;

  Глава = Глава + 1;
End;

if ( not ЕстьОшибки ) 
  УстановитьФлагВозврата( OK_MACRO_FLAG); /* Успешное завершение макроса */
  exit(1);
end;

/* EOF */