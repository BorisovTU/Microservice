/*───────────────────────────────────────────────────────────────────────────┐
  RS-Bank 6.0                                            R-Style Software Lab
  Файл подсистемы "Регламентируемая отчетность"

  VariablesArray - Класс для вычисления и хранения значений переменных (в т.ч. структурных).
  CStructVar     - Класс структурной переменной, предназначенный для
                   хранения в VariablesArray.

FILENAME: lib_vars.mac
CREATED:  Кац
└───────────────────────────────────────────────────────────────────────────*/
import ReptCBInter, ReptCBCommon, lib_arr, rcb_bo, cy_find, treport;

//////////////////////Массив переменных с инициализацией///////////////////
// Класс, агрегирующий массив переменных. Основная причина оформления в класс -
// необходимость скрыть структуру массива из-за возможных её изменений, а
// заодно ограничить набор операций. Также позволяет скрыть инициализацию.
// Если в переменную не происходит записи/добавления, она считается неиспользуемой
// и никуда не записывается.
// В конструктор передаются размерности измерений (пока последнее не используется,
// но это связано с конкретной реализацией).
// !!! Пока считаем, что измерения всегда 4. В дальнейшем несложно переделать
//     под переменное число измерений.
// Переменная может представляться как элементарным значением, так и объектом
// (для структурных). В последнем случае этот объект должен реализовывать все
// основные операции с переменной: Add, Save и другие, совпадающие по именам
// с методами этого класса - точнее, их используемое подмножество.
class VariablesArray( nstr, nboff, nkind, ncol )
/* !!! Kats: закомментировано из-за проблем инструмента: см. SCR 60202*/
    /*private*/ var arr = TArray;   // собственно массив

    // Получить значение
    MACRO Get( строка, бэк_офис, вид, графа )
        return arr[строка][бэк_офис][вид][графа];
    END;

    // Задать значение
    MACRO Set( строка, бэк_офис, вид, графа, значение )
        arr[строка][бэк_офис][вид][графа] = значение;
    END;

    // Добавить к значению.
    // Если значение объектного типа - тип должен реализовывать метод Add с одним параметром.
    // Считаем, что для любого X X + NULL = X.
    MACRO Add( строка, бэк_офис, вид, графа, значение )
        if( значение == NULL )
            return;
        end;
        
        var val = get( строка, бэк_офис, вид, графа );
        if( val == NULL )
            val = значение;
        elif( ValType( val ) == V_GENOBJ )
            val.Add( значение );
        else
            val = val + значение;
        end;

        set( строка, бэк_офис, вид, графа, val );
    END;

    // Получить имя переменной
    // !!! Чисто виртуальный метод
    MACRO GetName
        msgbox( "Ошибка программирования!|Метод GetName класса VariablesArray необходимо переопределять!" );
        exit( 1 );
    END;

    // Сохранить значение переменной (с проверкой, используется ли)
    // Если значение объектного типа - тип должен реализовывать метод Save с параметром-именем.
    // !!! Считаем, что в СохранитьПеременную параметры всегда именно такие.
    //     Если нет - надо изменить алгоритм.
    MACRO Save( строка, бэк_офис, вид, графа )
        var val  = Get( строка, бэк_офис, вид, графа );
        var name;
        if( val != NULL )
            name = GetName( строка, бэк_офис, вид, графа );
            if( name == NULL )
                return;
            elif( ValType( val ) == V_GENOBJ )
                val.Save( name );
            else
                СохранитьПеременную2( val, NULL, ДатаОтчета, ПредДатаОтчета, {Название Отчета}, name );
            end;
        end;
    END;

    // Сохранить значения всех используемых переменных
    MACRO SaveAll( )
        var i = 0, j, k, l;
        while( i < arr.size )       // строки
            j = 0;
            while( j < arr[i].size )    // бэк-офисы
                k = 0;
                while( k < arr[i][j].size )     // виды
                    l = 0;
                    while( l < arr[i][j][k].size )  // графы
                        Save( i, j, k, l );
                        l = l + 1;
                    end;
                    k = k + 1;
                end;
                j = j + 1;
            end;
            i = i + 1;
        end;
    END;

    // Прочитать значение переменной.
    // форма (необяз.) - имя или ID формы, если не задано - берётся текущая (можно задавать ID для оптимизации).
    // единицы (необяз.) - true означает, что загружать в единицах валюты, false - в единицах формы (по умолч.).
    // Если GetName для таких параметров возвращает NULL, загрузка не производится,
    // возвращается NULL. Иначе возвращается признак успешности загрузки
    // (см. описание ПрочитатьПеременную2).
    // !!! Пока только для элементарных значений!
    MACRO Load( строка, бэк_офис, вид, графа, форма, единицы )
        var name = GetName( строка, бэк_офис, вид, графа );
        if( name == NULL )
            return NULL;
        end;
        if( форма == NULL )
            форма = {Название отчета};
        end;
        var val, valT;
        message( "Чтение значения переменной " + name );
        var res = ПрочитатьПеременную2( val, ValT, ДатаОтчета, ПредДатаОтчета, форма, name );
        if( not единицы )
            val = valT;
        end;
        Set( строка, бэк_офис, вид, графа, val );

        return res;
    END;

    // Описание параметров - см. метод Load; однако задание ID формы не даёт выигрыша в производительности.
    // Возвращает список переменных, загруженных неуспешно (через запятую).
    // В случае невозможности найти форму, возвращает имя формы.
    MACRO LoadAll( форма, единицы )
        var retval = "";
        var res;
        if( форма == NULL )
            форма = {Название отчета};
        end;
        if( ValType( форма ) == V_STRING )
            res = НайтиИдентификаторОтчетаПоНазванию( форма );
            if( res < 0 )
                return форма;
            end;
            форма = res;
        end;

        var i = 0, j, k, l;
        while( i < arr.size )       // строки
            j = 0;
            while( j < arr[i].size )    // бэк-офисы
                k = 0;
                while( k < arr[i][j].size )     // виды
                    l = 0;
                    while( l < arr[i][j][k].size )  // графы
                        res = Load( i, j, k, l, форма, единицы );
                        if( res == false )
                            if( retval != "" )
                                retval = retval + ", ";
                            end;
                            retval = retval + GetName( i, j, k, l );
                        end;

                        l = l + 1;
                    end;
                    k = k + 1;
                end;
                j = j + 1;
            end;
            i = i + 1;
        end;

        return retval;
    END;

    // Вывод информации о переменной в текущий файл вывода.
    // Если неопр == true, то печатаются и неопределённые переменные (по умолч. не печатаются).
    // Если значение объектного типа - тип должен реализовывать метод Dump с параметром-именем.
    MACRO Dump( строка, бэк_офис, вид, графа, неопр )
        var name = GetName( строка, бэк_офис, вид, графа );
        var val;
        if( name == NULL )
            println( "Несуществующая переменная!" );
        else
            val = Get( строка, бэк_офис, вид, графа );
            if( ValType( val ) == V_GENOBJ )
                val.Dump( name );
            elif( неопр or ( val != NULL ) )
                println( name, " \t = ", val );
            end;
        end;
    END;

    // Вывод информации о переменных в текущий файл вывода.
    // Если неопр == true, то печатаются и неопределённые переменные (по умолч. не печатаются).
    MACRO DumpAll( неопр )
        var i = 0, j, k, l;
        while( i < arr.size )       // строки
            j = 0;
            while( j < arr[i].size )    // бэк-офисы
                k = 0;
                while( k < arr[i][j].size )     // виды
                    l = 0;
                    while( l < arr[i][j][k].size )  // графы
                        if( GetName( i, j, k, l ) != NULL )
                            Dump( i, j, k, l, неопр );
                        end;
                        l = l + 1;
                    end;
                    k = k + 1;
                end;
                j = j + 1;
            end;
            i = i + 1;
        end;
    END;

    // Проверить на пустоту.
    // Все параметры необязательные; если какой-нибудь из них не задан, проход по всем значениям.
    MACRO IsEmpty( строка, бэк_офис, вид, графа )
        MACRO Ternary( _if, _then, _else )
            if( _if )
                return _then;
            end;
            return _else;
        END;

        var j, k, l;
        var i = Ternary( строка == NULL, 0, строка );
        while( ( i == строка ) or ( i < arr.size ) )        // строки
            j = Ternary( бэк_офис == NULL, 0, бэк_офис );
            while( ( j == бэк_офис ) or ( j < arr[i].size ) )       // бэк-офисы
                k = Ternary( вид == NULL, 0, вид );
                while( ( k == вид ) or ( k < arr[i][j].size ) )     // виды
                    l = Ternary( графа == NULL, 0, графа );
                    while( ( l == графа ) or ( l < arr[i][j][k].size ) )    // графы
                        if( Get( i, j, k, l ) != NULL )
                            return false;
                        end;

                        l = l + 1;
                    end;
                    k = k + 1;
                end;
                j = j + 1;
            end;
            i = i + 1;
        end;

        return true;
    END;
    
    private MACRO Init( nstr, nboff, nkind, ncol )
        var i = 0, j, k;
        while( i < nstr )     // первое измерение - по строкам
            arr[i] = TArray;
            j = 0;
            while( j < nboff )    // второе - по бэк-офисам
                arr[i][j] = TArray;
                k = 0;
                while( k < nkind )  // третье - по видам
                    arr[i][j][k] = TArray;
                    arr[i][j][k].size = ncol;
                    k = k + 1;
                end;
                j = j + 1;
            end;
            i = i + 1;
        end;
    END;

    Init( nstr, nboff, nkind, ncol );
END;

/* Класс структурной переменной, реализующий все необходимые методы для
       использования в VariablesArray.
   Параметры конструктора:
   meta - ссылка на класс "метаинформации" со свойствами-массивами:
       FieldNames  - имена полей.
       FieldSizes  - размеры (в символах) полей (для метода Dump).
       GroupFields - индексы полей группировки (в массиве FieldNames).
           Если вызывается Add, и новое значение совпадает по полям группировки
           с одним из старых, то оно к нему прибавляется, иначе создаётся новое.
           Может быть равно NULL.
           ВНИМАНИЕ! Если есть поля группировки, все остальные должны быть суммируемыми!
   [val] - массив значений в порядке, определённом meta.
   [parent] - ID значения-родителя, по умолчанию 0.
*/
CLASS CStructVar( meta, val, parent )
    // Оба данных-члена публичные, т.к. они нужны для чтения и интерпретации значений.
    var MetaInfo = meta;
    var ParentID = parent;
    var Values = TArray;    // собственно значения (двумерный массив)

    /* Текст команд вызова функций для сохранения/загрузки значения.
       При записи ожидается, что значение (одно) находится в переменной с именем
          CurVal, при чтении оно туда заносится.
       Ожидается, что заполненная структура (первый параметр СохранитьСтруктурноеЗначение
          или ПрочитатьСтруктурноезначение) называется rec_mcomp.
    */
    private var saveCmd, loadCmd;

    // Добавить одно значение. Параметр - массив значений в порядке, определённом metaInfo.
    private MACRO AddValue( val )
        var i = 0, j, group, idx;
        if( ( MetaInfo.GroupFields != NULL ) and ( MetaInfo.GroupFields.size > 0 ) )
            while( i < Values.size )
                j = 0;
                group = true;
                while( j < MetaInfo.GroupFields.size )
                    idx = MetaInfo.GroupFields[j];
                    if( Values[i][idx] != val[idx] )
                        group = false;
                    end;
                    j = j + 1;
                end;

                if( group )
                    // Подготовка: обнуление полей группировки, чтобы их отличать.
                    j = 0;
                    while( j < MetaInfo.GroupFields.size )
                        idx = MetaInfo.GroupFields[j];
                        val[idx] = NULL;
                        j = j + 1;
                    end;

                    // Собственно суммирование.
                    j = 0;
                    while( j < val.size )
                        if( val[j] != NULL )
                            Values[i][j] = Values[i][j] + val[j];
                        end;

                        j = j + 1;
                    end;

                    // Все необходимые действия произведены.
                    return;
                end;

                i = i + 1;
            end;
        end;

        // Либо нет группировки, либо оказалось не с чем группировать - добавляем.
        Values[Values.size] = val;
    END;

    // Добавить другую структурную переменную. Параметр - объект класса CStructVar.
    // "Метаинформация" суммируемых объектов должна совпадать.
    MACRO Add( strvar )
        var i = 0;
        while( i < strvar.Values.size )
            AddValue( strvar.Values[i] );
            i = i + 1;
        end;
    END;

    // Сохранить переменную. Параметр - имя.
    // Предполагается, что все параметры должны быть именно такими, иначе надо менять алгоритм.
    // !!! В дальнейшем будет реализована функция СохранитьСтруктурноеЗначение2,
    //     причём с возможностью задать значения в виде массива.
    MACRO Save( name )
        record rec_mcomp( "cy_mcomp.dbt", "cy_files.def");
        rec_mcomp.bdRepDate  = ДатаОтчета;
        rec_mcomp.bdPrevDate = ПредДатаОтчета; 
        rec_mcomp.iFormId    = НайтиИдентификаторОтчетаПоНазванию( {Название отчета} );
        rec_mcomp.iVarId     = НайтиИдентификаторПеременнойПоНазванию( name, rec_mcomp.iFormId );
        rec_mcomp.iKeyId     = -1;
        if( ParentID != NULL )
            rec_mcomp.iParentID = ParentID;
        end;

        var i = 0, j;
        var CurVal = TArray;    // для saveCmd

        while( i < Values.size )
            // Пока нет СохранитьСтруктурноеЗначение2, приходится копировать и самостоятельно звать RCB_FloorTerm
            j = 0;
            while( j < Values[i].size )
                CurVal[j] = Values[i][j];
                if( ValType( CurVal[j] ) == V_MONEY )
                    CurVal[j] = RCB_FloorTerm( CurVal[j] );
                end;
                j = j + 1;
            end;
            if( not ExecExp( saveCmd ) )
                MsgBox( "Ошибка сохранения структурного значения переменной " + name );
            end;

            i = i + 1;
        end;
    END;

    // Сохранить переменную, предварительно отсортировав значения в соответствии с заданной
    // функцией сравнения. Второй параметр - текстовое имя функции сравнения. Должна принимать
    // два значения (массивы, определяемые метаинформацией) и возвращать 0, если первое
    // значение меньше второго, иначе 1.
    MACRO SaveSorted( name, compare )

        var inserted, j, i = 0;
        var CurVal = TArray;
        var IndexArr = TArray;

        macro InsertIndex()
            var k = IndexArr.size;
            while( k > j )
                IndexArr[k] = IndexArr[k-1];
                k = k - 1;
            end;
            IndexArr[j] = i;
            inserted = true;
            j = 1;
        end;

        while( i < Values.size )
            CurVal = Values[i];
            inserted = false;
            j = IndexArr.size;      // = i, но это особенность реализации
            while( j > 0 )
                if( ExecMacro2( compare, CurVal, Values[ IndexArr[j-1] ] ) )
                    InsertIndex();
                end;
                j = j - 1;
            end;
            if (not inserted)
                InsertIndex();
            end;
            i = i + 1;
        end;
        CurVal = TArray;
        i = 0;
        record rec_mcomp( "cy_mcomp.dbt", "cy_files.def");
        rec_mcomp.bdRepDate  = ДатаОтчета;
        rec_mcomp.bdPrevDate = ПредДатаОтчета; 
        rec_mcomp.iFormId    = НайтиИдентификаторОтчетаПоНазванию( {Название отчета} );
        rec_mcomp.iVarId     = НайтиИдентификаторПеременнойПоНазванию( name, rec_mcomp.iFormId );
        rec_mcomp.iKeyId     = -1;
        if( ParentID != NULL )
            rec_mcomp.iParentID = ParentID;
        end;
        while( i < IndexArr.size )
            j = 0;
            while( j < Values[ IndexArr[i] ].size )
                CurVal[j] = Values[ IndexArr[i] ][j];
                if( ValType( CurVal[j] ) == V_MONEY )
                    CurVal[j] = RCB_FloorTerm( CurVal[j] );
                end;
                j = j + 1;
            end;
            if( not ExecExp( saveCmd ) )
                MsgBox( "Ошибка сохранения структурного значения переменной " + name );
            end;

            i = i + 1;
        end;
    END;


    // Прочитать значение переменной. Параметр - имя.
    // Предполагается, что все параметры должны быть именно такими, иначе надо менять алгоритм.
    // !!! В дальнейшем будет реализована функция ПрочитатьСтруктурноеЗначение2,
    //     причём с возможностью получить значения в виде массива.
    // !!! Сейчас будут читаться все значения подряд по номерам, невзирая на
    //     иерархию. В дальнейшем, возможно, надо будет изменить это.
    MACRO Load( name, DatPrev, Dat )

        if( DatPrev == NULL )
            DatPrev = ПредДатаОтчета;
        end;
        if( Dat == NULL )
            Dat = ДатаОтчета;
        end;


        record rec_mcomp( "cy_mcomp.dbt", "cy_files.def");
        rec_mcomp.bdRepDate  = Dat;
        rec_mcomp.bdPrevDate = DatPrev; 
        rec_mcomp.iFormId    = НайтиИдентификаторОтчетаПоНазванию( {Название отчета} );
        rec_mcomp.iVarId     = НайтиИдентификаторПеременнойПоНазванию( name, rec_mcomp.iFormId );

        rec_mcomp.iKeyId     = 1;
        var CurVal = TArray;    // для loadCmd
        while( ExecExp( loadCmd ) )
            Values[rec_mcomp.iKeyId-1] = CurVal;
            rec_mcomp.iKeyId = rec_mcomp.iKeyId + 1;
            CurVal = TArray;
        end;
    END;

    // Вывести значения переменной. Параметр - имя.
    MACRO Dump( name )
        if( Values.size == 0 )
            println( name, ": пусто" );
            return;
        end;

        println( name, ":" );
        var rep = CTableReport;
        var i = 0;
        while( i < MetaInfo.FieldNames.size )
            rep.AddColumn( MetaInfo.FieldNames[i], MetaInfo.FieldSizes[i] );
            i = i + 1;
        end;
        rep.PrintHead( );
        i = 0;
        while( i < Values.size )
            rep.PrintStringTransferByWord( Values[i] );
            i = i + 1;
        end;
        rep.PrintBottom( );
    END;

    // конструктор
    local MACRO Constructor( val )
        if( val != NULL )
            values[0] = val;
        end;

        // Создание команд сохранения и загрузки значения
        saveCmd = "СтруктурноеЗначение( rec_mcomp";
        var i = 0;
        while( i < MetaInfo.FieldNames.size )
            saveCmd = saveCmd + ", \"" + MetaInfo.FieldNames[i] + "\", CurVal[" + i + "]";
            i = i + 1;
        end;
        saveCmd = saveCmd + " )";
        // окончательное создание команд
        loadCmd = "Прочитать" + saveCmd;
        saveCmd = "Сохранить" + saveCmd;
    END;

    Constructor( val );
END;
