/*
$Name:          f501Normalizer.mac
$Module:        Регламентируемая отчетность
$Description:   Форма 501. Нормализатор
*/

import rcbimport;
import ReptcbCommon;
import rsbDataSet;
import ReportNormalizer;
import ReportLinearRelation;
import RcbCoreINter;
import balanceAttribute;
import com_f501;
import arraylib;

const PART_1 = 1; /*1-ый раздел отчета*/
const PART_2 = 2; /*2-ой раздел отчета*/
const PART_3 = 3; /*3-ий раздел отчета*/

macro StringToArrayWithLongDelim(A, str, delim)
   var i = 0;
   var lenDelim = strLen(delim);
   var posStartDelim;
   var posEndDelim;

   If  (ValType(A) == V_Array)
    ASize(A, 0);
   Elif(ValType(A) == V_GenObj) 
    A.Size = 0;
   Else
    Return;
   End;

   posStartDelim = Index(str, delim);
   posEndDelim   = posStartDelim + lenDelim - 1;

   If (lenDelim > 1)
    while(posStartDelim != 0)
      A(i) = SubStr(str, 1, posStartDelim - 1);
      str  = SubStr(str, posEndDelim + 1);
      i = i + 1;

      posStartDelim = Index(str, delim);
      If (posStartDelim != 0)
          posEndDelim = posStartDelim + lenDelim - 1;
      End;
    end;
   Else
    while(posStartDelim != 0)
      A(i) = SubStr(str, 1, posStartDelim - 1);
      str  = SubStr(str, posEndDelim + 1);
      i = i + 1;

      posStartDelim = Index(str, delim);
      posEndDelim   = posStartDelim;
    end;
   End;

   if(str != "")
    A(i) = str;
    i = i + 1;    
   end;

   return i;
end;

class (TProtocolView) F501NormalizationProtocolView()
    initTProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ", RcbApplication().currentReport.form.id);

    private var m_isHeadPrinted      = false;
    private var m_isSaparatorPrinted = false;

    macro printNullData()
        [    Корректировок округленных значений символов не потребовалось.];
    end;

    macro beginProtocol()
        setProtocolOutput();
        printHead();
    end;

    macro printSeparatorLine()
        if(m_isSaparatorPrinted)
            [├───────────────────────────────┼────────────────┼─────────────┼─────────────────┼──────────┤];
        end;
    end;

    macro endProtocol()
        if (m_isHeadPrinted)
            [└───────────────────────────────┴────────────────┴─────────────┴─────────────────┴──────────┘];
            [ ];
        end;
        if (m_isEmpty)
            printNullData();
        end;
        resetProtocolOutput();
    end;

    macro printReportAbsence(formName, report)
        if ((report.context.period.beginDate != "") and (report.context.period.endDate != ""))
            printLine("Отсутствует рассчитанная форма " + formName + " за период " + report.context.period.beginDate + " - " + report.context.period.endDate,
                      "В процессе нормализации сходимость с данными этой формы не реализована.",
                      "");
        end;
    end;

    macro printString(str : String, exact : Money, scaled : Double)
        var floored = floor(Double(exact) / rcbApplication.currentReport.multiplier + 0.5);

        if (not m_isHeadPrinted)
            [┌───────────────────────────────┬───────────────────────────────────────────────────────────┐];
            [│                               │                          Значение                         │];
            [│               л./с.           ├────────────────┬─────────────┬─────────────────┬──────────┤];
            [│                               │ Действительное │ Округленное │ Нормализованное │ Разность │];
            [├───────────────────────────────┼────────────────┼─────────────┼─────────────────┼──────────┤];
            m_isHeadPrinted = true;
            m_isSaparatorPrinted = true;
        end;

        [│###############################│################│#############│#################│##########│]
        (str, exact, floored : 0 : 0, scaled : 0 : 0, abs(floored - scaled) : 0 : 0);

        m_isEmpty = false;
    end;
end;

class (ReportNormalizer) F501NormalizerBase(protocolView)

    initReportNormalizer(rcbApplication.currentReport.multiplier);

    private var m_report;
    private var m_balanceReport;
    private var m_previousReport;

    private var m_protocolView  = protocolView;

    private var m_balanceAttribute;

    private var m_jvm : Object     = null;

    class TSorter()
        macro isLess(v1, v2)
            return (   (v1.fieldValue("НомБС").current < v2.fieldValue("НомБС").current)
                    or (    (v1.fieldValue("НомБС").current == v2.fieldValue("НомБС").current)
                        and (v1.fieldValue("ПризнакИП").current > v2.fieldValue("ПризнакИП").current)
                       )
                   );
        end;

    end;

    class TFilter()
        macro isSuitable(v : Object)
            return in(v.fieldValue("ТипЛС").exact, "1");
        end;
    end;

    private macro makeAttributeKey(clientCode : String, account : String)
        return clientCode + account;
    end;

    private macro getRcbAttributeFromHashMap(clientCode : String, account : String, javaHashMap : Object)
        return javaHashMap.get(makeAttributeKey(clientCode, account));
    end;

    private macro initialize()
        m_report           = rcbApplication.currentReport;
        m_previousReport   = m_report.createPreviousReport();
        m_balanceReport    = m_report.createOtherReport("Балансовые счета");

        m_balanceAttribute = TBalanceAttribute("БАЛАНС",  m_balanceReport);

        m_jvm              = CreateObject("rsjvm", "TJavaHost", "GlobalJavaHost");
    end;

    private macro initializeNode(currentNode, id, exact, scaled)

        var node = currentNode.addNode(id);

        node.setExact(exact);

        if (scaled == null)
            node.recalculateScaled();
        else
            node.setScaled(scaled);
        end;

        return node;
    end;

    private macro getBalanceAttribute(balanceAcc, type)
        m_balanceAttribute.getBalanceAttribute(1, balanceAcc, false);

        if(type == "out")
            return m_balanceAttribute.getOutRest();
        elif(type == "credit")
            return m_balanceAttribute.getCredit();
        elif(type == "debet")
            return m_balanceAttribute.getDebet();
        elif(type == "in")
            return m_balanceAttribute.getInRest();
        end;

        msgBox("Переменная для балансового счета " + balanceAcc + " не существует!!!");
    end;

    private macro addRuleForBalance(attribute)
        var inRestNode, outRestNode, creditNode, debetNode;
        var tempId, balanceAttribute;

        tempId = "outPut" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "out");

        outRestNode = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        outRestNode.setDef(0.5);

        tempId = "credit" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "credit");

        creditNode = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        creditNode.setDef(0.5);

        tempId = "debet" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "debet");

        debetNode = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        debetNode.setDef(0.5);

        tempId = "inPut" + attribute.fieldValue("НомБС").exact;
        if (attribute.fieldValue("ВидЛС").exact == "А")
            inRestNode = initializeNode(this, tempId, outRestNode.getExact() - debetNode.getExact() + creditNode.getExact(), outRestNode.getScaled() - debetNode.getScaled() + creditNode.getScaled());
        else
            inRestNode = initializeNode(this, tempId, outRestNode.getExact() + debetNode.getExact() - creditNode.getExact(), outRestNode.getScaled() + debetNode.getScaled() - creditNode.getScaled());
        end;

        inRestNode.setDef(0.5);
    end;

    private macro addRuleForAccount(attribute, balanceNumber)
        var tempId;
        var tempNode;
        var relation = ReportLinearRelation(RCB_RS_EQUAL);
    
        tempId = "outPut" + attribute.fieldValue("НомЛС").exact;

        if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact))
            tempNode = initializeNode(node("outPut" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОстИсход").exact);
        else
            tempNode = initializeNode(this, tempId, attribute.fieldValue("ОстИсход").exact);
        end;

        tempNode.setLevel(10);
        relation.lhs.plus(tempNode);

        tempId = "inPut" + attribute.fieldValue("НомЛС").exact;

        if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact))
            tempNode = initializeNode(node("inPut" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОстВход").exact);
        else
            tempNode = initializeNode(this, tempId, attribute.fieldValue("ОстВход").exact);
        end;

        tempNode.setLevel(5);
        relation.rhs.plus(tempNode);

        var kindAccount =  attribute.fieldValue("ВидЛС").exact;

        if (kindAccount == "А")
            tempId = "debet" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact))
                tempNode = initializeNode(node("debet" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбДебет").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбДебет").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.plus(tempNode);

            tempId = "credit" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact))
                tempNode = initializeNode(node("credit" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбКредит").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбКредит").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.minus(tempNode);

        else
            tempId = "debet" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact))
                tempNode = initializeNode(node("debet" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбДебет").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбДебет").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.minus(tempNode);

            tempId = "credit" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact))
                tempNode = initializeNode(node("credit" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбКредит").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбКредит").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.plus(tempNode);
        end;

        this.addRelation(relation);
    end;

    private macro addRulesByPreviousReport(previousReportAttribute)
        var previousReportOutPutNode;
        var tempId;
        var relation = ReportLinearRelation(RCB_RS_EQUAL);

        tempId = "previosReportOutPut" + previousReportAttribute.fieldValue("НомЛС").exact;
        previousReportOutPutNode = initializeNode(this, tempId, previousReportAttribute.fieldValue("ОстИсход").exact, 
                                                                previousReportAttribute.fieldValue("ОстИсход").scaled);
        previousReportOutPutNode.setDef(0.5);

        relation.lhs.plus(previousReportOutPutNode);
        relation.rhs.plus(node("inPut" + previousReportAttribute.fieldValue("НомЛС").exact));

        this.addRelation(relation);
    end;

    private macro addRules(part)
        var iterator;
        var iteratorByPreviousReport;
        var balanceNumberWhereExistCorrect = "";
        var javaHashMap                    = null;

        if (part == PART_1)
            iterator = m_report.attributeValue("Ф501_1").createValueIterator();
        else
            iterator = m_report.attributeValue("Ф501_2").createValueIterator();
        end;

        if (m_previousReport.isCalculated())
            javaHashMap = m_jvm.createJavaObject("java.util.HashMap", "<init>");

            if (part == PART_1)
                iteratorByPreviousReport = m_previousReport.attributeValue("Ф501_1").createValueIterator();
            else
                iteratorByPreviousReport = m_previousReport.attributeValue("Ф501_2").createValueIterator();
            end;

            iteratorByPreviousReport.moveFirst();
            while(not iteratorByPreviousReport.isDone())
                var attributeKey = makeAttributeKey(iteratorByPreviousReport.currentItem.fieldValue("КодКО").exactAsString,
                                                    iteratorByPreviousReport.currentItem.fieldValue("НомЛС").exactAsString);
                javaHashMap.put(attributeKey, iteratorByPreviousReport.currentItem);
                iteratorByPreviousReport.moveNext();
            end;
        end;

        iterator.setSortOrder(TSorter());
        iterator.setFilter(TFilter());

        iterator.moveFirst();
        while (not iterator.isDone())

            if (m_balanceReport.isCalculated)
                if ((iterator.currentItem.fieldValue("ПризнакИП").exact != 1) and (iterator.currentItem.fieldValue("НомБС").exact != balanceNumberWhereExistCorrect))
                    addRuleForBalance(iterator.currentItem);
                elif(iterator.currentItem.fieldValue("ПризнакИП").exact == 1)
                    balanceNumberWhereExistCorrect = iterator.currentItem.fieldValue("НомБС").exact;
                    m_protocolView.printLine("Лицевой счет " + iterator.currentItem.fieldValue("НомЛС").exact + " имеет исправительные проводки, поэтому сходимость с формой \"Балансовые счета\" для соответствующего балансового счета не обеспечена.");
                end;
            end;

            addRuleForAccount(iterator.currentItem, balanceNumberWhereExistCorrect);

            if (javaHashMap != null)
                var currentAccPrevousReport = getRcbAttributeFromHashMap(iterator.currentItem.fieldValue("КодКО").exactAsString,
                                                                         iterator.currentItem.fieldValue("НомЛС").exactAsString,
                                                                         javaHashMap);
                if (currentAccPrevousReport != null)
                    addRulesByPreviousReport(currentAccPrevousReport);
                end;
            end;

            iterator.moveNext();
        end;
    end;

    private macro saveScaledValue(attribute, value)
        if (ValType(attribute.scaled) == V_DOUBLE)
            attribute.scaled = double(value);
        elif (ValType(attribute.scaled) == V_MONEY)
            attribute.scaled = money(value);
        else
            attribute.scaled = int(value);
        end;
    end;

    private macro save(part)
        var iterator, tempNode;

        if (part == PART_1)
            iterator = m_report.attributeValue("Ф501_1").createValueIterator();
        else
            iterator = m_report.attributeValue("Ф501_2").createValueIterator();
        end;

        iterator.setSortOrder(TSorter());
        iterator.setFilter(TFilter());

        iterator.moveFirst();
        while (not iterator.isDone())

            m_protocolView.printSeparatorLine();

            tempNode = node("inPut" + iterator.currentItem.fieldValue("НомЛС").exact);
            saveScaledValue(iterator.currentItem.fieldValue("ОстВход"), tempNode.getScaled());
            m_protocolView.printString("ОстВход(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());

            tempNode = node("debet" + iterator.currentItem.fieldValue("НомЛС").exact);
            saveScaledValue(iterator.currentItem.fieldValue("ОбДебет"), tempNode.getScaled());
            m_protocolView.printString("ОбДебет(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());

            tempNode = node("credit" + iterator.currentItem.fieldValue("НомЛС").exact);
            saveScaledValue(iterator.currentItem.fieldValue("ОбКредит"), tempNode.getScaled());
            m_protocolView.printString("ОбКредит(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());

            tempNode = node("outPut" + iterator.currentItem.fieldValue("НомЛС").exact);
            saveScaledValue(iterator.currentItem.fieldValue("ОстИсход"), tempNode.getScaled());
            m_protocolView.printString("ОстИсход(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());

            iterator.moveNext();
        end;
    end;

    macro showProtocol()
        var protocol = TSummaryProtocolView();

        var protocolDescription = "ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ";

        protocol.add(TProtocolView(protocolDescription));

        protocol.show();
    end;

    macro execute()
        m_protocolView.beginProtocol();

        if (not m_balanceReport.isCalculated())
            m_protocolView.printReportAbsence("Балансовые счета", m_balanceReport);
        end;

        if (not m_previousReport.isCalculated())
            m_protocolView.printReportAbsence("501", m_previousReport);
        end;

        addRules(PART_1);
        addRules(PART_2);

        normalize();

        if (not isNormalized())
            m_protocolView.printLine("Данные нормализовать не удалось(см. протокол " + getLogFilePath() + ").");
            m_protocolView.endProtocol();
            showProtocol();
            return;
        end;

        save(PART_1);
        save(PART_2);

        m_protocolView.endProtocol();

        RcbApplication.TransactionManager.commit();

        showProtocol();
    end;

    initialize();
end;

class (F501NormalizerBase) F501Normalizer_I5456(protocolView, dateForTuneTable)
    private var m_dateForTuneTable;

    private macro addRuleForAccount(attribute, balanceNumber, isNeedNormalizeByRests, isNeedNormalizeByTurns)
        var tempId;
        var tempNode;
        var relation = ReportLinearRelation(RCB_RS_EQUAL);
    
        tempId = "outPut" + attribute.fieldValue("НомЛС").exact;

        if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact) and (isNeedNormalizeByRests))
            tempNode = initializeNode(node("outPut" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОстИсход").exact);
        else
            tempNode = initializeNode(this, tempId, attribute.fieldValue("ОстИсход").exact);
        end;

        tempNode.setLevel(10);
        relation.lhs.plus(tempNode);

        tempId = "inPut" + attribute.fieldValue("НомЛС").exact;

        if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact) and (isNeedNormalizeByRests))
            tempNode = initializeNode(node("inPut" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОстВход").exact);
        else
            tempNode = initializeNode(this, tempId, attribute.fieldValue("ОстВход").exact);
        end;

        tempNode.setLevel(5);
        relation.rhs.plus(tempNode);

        var kindAccount =  attribute.fieldValue("ВидЛС").exact;

        if (kindAccount == "А")
            tempId = "debet" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact) and (isNeedNormalizeByTurns))
                tempNode = initializeNode(node("debet" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбДебет").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбДебет").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.plus(tempNode);

            tempId = "credit" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact) and (isNeedNormalizeByTurns))
                tempNode = initializeNode(node("credit" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбКредит").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбКредит").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.minus(tempNode);

        else
            tempId = "debet" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact) and (isNeedNormalizeByTurns))
                tempNode = initializeNode(node("debet" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбДебет").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбДебет").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.minus(tempNode);

            tempId = "credit" + attribute.fieldValue("НомЛС").exact;

            if ((m_balanceReport.isCalculated) and (balanceNumber != attribute.fieldValue("НомБС").exact) and (isNeedNormalizeByTurns))
                tempNode = initializeNode(node("credit" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОбКредит").exact);
            else
                tempNode = initializeNode(this, tempId, attribute.fieldValue("ОбКредит").exact);
            end;

            tempNode.setLevel(15);
            relation.rhs.plus(tempNode);
        end;

        this.addRelation(relation);
    end;

    private macro addRuleForPart3Account(attribute)
        // При наличии рассчитанной формы "Балансовые счета",
        // и необходимости в обеспечении сходимости по входящему и исходящему остатку б/с
        // и данным раздела 3 формы 501
        var tempId;

        tempId = "outPut" + attribute.fieldValue("НомЛС").exact;
        initializeNode(node("outPut" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОстИсход").exact);

        tempId = "inPut" + attribute.fieldValue("НомЛС").exact;
        initializeNode(node("inPut" + attribute.fieldValue("НомБС").exact), tempId, attribute.fieldValue("ОстВход").exact);
    end;

    private macro addRuleForBalanceByRests(attribute)
        var tempId, balanceAttribute, node;

        tempId = "outPut" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "out");
        node = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        node.setDef(0.5);

        tempId = "inPut" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "in");
        node = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        node.setDef(0.5);
    end;

    private macro addRuleForBalanceByTurns(attribute)
        var tempId, balanceAttribute, node;

        tempId = "credit" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "credit");
        node = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        node.setDef(0.5);

        tempId = "debet" + attribute.fieldValue("НомБС").exact;
        balanceAttribute = getBalanceAttribute(attribute.fieldValue("НомБС").exact, "debet");
        node = initializeNode(this, tempId, balanceAttribute.exact, balanceAttribute.scaled);
        node.setDef(0.5);
    end;

    private macro addRulesByPreviousReport(previousReportAttribute, attribute)
        var tempNode;
        var tempId;
        var relation = ReportLinearRelation(RCB_RS_EQUAL);

        tempId   = "previosReportOutPut" + previousReportAttribute.fieldValue("НомЛС").exact;
        tempNode = initializeNode(this, tempId, previousReportAttribute.fieldValue("ОстИсход").exact, 
                                                previousReportAttribute.fieldValue("ОстИсход").scaled);
        tempNode.setDef(0.5);

        relation.lhs.plus(tempNode);

        if (node("inPut" + previousReportAttribute.fieldValue("НомЛС").exact) != null)
            relation.rhs.plus(node("inPut" + previousReportAttribute.fieldValue("НомЛС").exact));
        else
            tempId   = "inPut" + attribute.fieldValue("НомЛС").exact;
            tempNode = initializeNode(this, tempId, attribute.fieldValue("ОстВход").exact);
            relation.rhs.plus(tempNode);
        end;

        this.addRelation(relation);
    end;

    private macro getPreparedArrayBalanceAcc(A : TArray, part)
        // переменная A - это массив массивов 
        // внутренний массив имеет три элемента
        // 1 - номер б/с
        // 2 - если true - по л/с счетам входящим в б/с будет обеспечиваться сходимость с формой 
        // "Балансовые счета" по входящим и исходящим остаткам, если false - не будет
        // 3 - если true - по л/с счетам входящим в б/с будет обеспечиваться сходимость с формой 
        // "Балансовые счета" по дебетовым и кредитовым оборотам, если false - не будет (для раздела 3 всегда false)

        var iterator;
        var i  = 0;
        A.size = 0;

        if   (part == PART_1)
            iterator = m_report.attributeValue("Ф501_1").createValueIterator();
        elif (part == PART_2)
            iterator = m_report.attributeValue("Ф501_2").createValueIterator();
        elif ((part == PART_3) and (m_report.attributeValue("Ф501_3") != null))
            iterator = m_report.attributeValue("Ф501_3").createValueIterator();
        else
            iterator = null;
        end;
        
        if (iterator == null)
            return;
        end;

        iterator.setSortOrder(TSorter());
        iterator.setFilter(TFilter());

        A[0]    = TArray;
        A[0][0] = iterator.currentItem.fieldValue("НомБС").exact;
        A[0][1] = true;
        A[0][2] = ternary(part == PART_3, false, true);

        iterator.moveNext();
        while (not iterator.isDone())
            i           = 0;
            var needAdd = true;
            while(i < A.size())
                if (A[i][0] == iterator.currentItem.fieldValue("НомБС").exact)
                    needAdd = false;
                    break;
                end;
                i = i + 1;
            end;

            if (needAdd)
                A[i] = TArray;
                A[i][0] = iterator.currentItem.fieldValue("НомБС").exact;
                A[i][1] = true;
                A[i][2] = ternary(part == PART_3, false, true);
            end;

            iterator.moveNext();
        end;

        i = 0;
        while (i < A.size())
            var mask    = A[i][0];
            var inRest  = $0.0;
            var outRest = $0.0;
            var debet   = $0.0;
            var credit  = $0.0;

            iterator.moveFirst();
            while (not iterator.isDone())
                if (subStr(iterator.currentItem.fieldValue("НомБС").exact, 1, strLen(mask)) == mask)
                    if (iterator.currentItem.fieldValue("ПризнакИП").exact == 1)
                        break;
                    end;
                    inRest  = inRest  + iterator.currentItem.fieldValue("ОстВход").exact;
                    outRest = outRest + iterator.currentItem.fieldValue("ОстИсход").exact;
                    if (part != PART_3)
                        debet  = debet  + iterator.currentItem.fieldValue("ОбДебет").exact;
                        credit = credit + iterator.currentItem.fieldValue("ОбКредит").exact;
                    end;
                end;
                iterator.moveNext();
            end;

            // Если все элементы итератора не пройдены, значит был осуществлен выход по инструкции break из цикла
            // это означает, что по анализируемому на конкретном шаге б/с был найден л/с на котором есть исправительные проводки
            // по б/с с таким л/с в любом случае не будет проверяться сходимость с формой "Балансовые счета" поэтому что бы немного
            // оптимизировать данный алгоритм, б/с с такими л/с будут сразу помечаться как б/с по которым не будет обеспечена сходимость с формой "Балансовые счета"
            if (not iterator.isDone())
                A[i][1] = false;
                A[i][2] = false;
            else
                // если же все элементы итератора были пройдены полностью, то производится проверка на равенство точных значений сумм входящих и исходящих остатков,
                // дебетовых и кредитовых оборотов по всем лицевым счетам, одного б/с, которые попали в конкретный раздел формы 501 
                // и точных значений входящих и исходящих остатков, дебетовых и кредитовых оборотов по б/с из формы "Балансовые счета"
                var balanceInRest  = round(getBalanceAttribute(mask, "in").exact, 2);
                inRest             = round(inRest, 2);
                var balanceOutRest = round(getBalanceAttribute(mask, "out").exact, 2);
                outRest            = round(outRest, 2);
                if ((balanceInRest != inRest) or (balanceOutRest != outRest))
                    A[i][1] = false;
                end;
                var balanceDebet  = round(getBalanceAttribute(mask, "debet").exact, 2);
                debet             = round(debet, 2);
                var balanceCredit = round(getBalanceAttribute(mask, "credit").exact, 2);
                credit            = round(credit, 2);
                if ((part != PART_3) and ((balanceDebet != debet) or (balanceCredit != credit)))
                    A[i][2] = false;
                end;
            end;
            i = i + 1;
        end;
    end;

    private macro addRules(part)
        var iterator;
        var iteratorByPreviousReport;
        var balanceNumberWhereExistCorrect  = "";
        var javaHashMap                     = null;
        var arrayBalanceAcc : TArray        = TArray;

        if   (part == PART_1)
            iterator = m_report.attributeValue("Ф501_1").createValueIterator();
        elif (part == PART_2)
            iterator = m_report.attributeValue("Ф501_2").createValueIterator();
        elif ((part == PART_3) and (m_report.attributeValue("Ф501_3") != null))
            iterator = m_report.attributeValue("Ф501_3").createValueIterator();
        else
            iterator = null;
        end;

        if (m_previousReport.isCalculated())
            javaHashMap = m_jvm.createJavaObject("java.util.HashMap", "<init>");

            if   (part == PART_1)
                iteratorByPreviousReport = m_previousReport.attributeValue("Ф501_1").createValueIterator();
            elif (part == PART_2)
                iteratorByPreviousReport = m_previousReport.attributeValue("Ф501_2").createValueIterator();
            elif ((part == PART_3) and (m_previousReport.attributeValue("Ф501_3") != null))
                iteratorByPreviousReport = m_previousReport.attributeValue("Ф501_3").createValueIterator();
            else
                iteratorByPreviousReport = null;
            end;

            if (iteratorByPreviousReport != null)
                iteratorByPreviousReport.moveFirst();
                while(not iteratorByPreviousReport.isDone())
                    var attributeKey = makeAttributeKey(iteratorByPreviousReport.currentItem.fieldValue("КодКО").exactAsString,
                                                        iteratorByPreviousReport.currentItem.fieldValue("НомЛС").exactAsString);
                    javaHashMap.put(attributeKey, iteratorByPreviousReport.currentItem);
                    iteratorByPreviousReport.moveNext();
                end;
            end;
        end;

        const IS_RESTS = 1;
        const IS_TURNS = 2;
        private macro isNeedNorzmalize(balanceAcc, typeData)
            if (arrayBalanceAcc.size() != null)
                for (var balanceAccElement, arrayBalanceAcc)
                    if (balanceAccElement[0] == subStr(balanceAcc, 1, strLen(balanceAccElement[0])))
                        return balanceAccElement[typeData];
                    end;
                end;
            end;
            return true;
        end;

        // Если форма "Балансовые счета" рассчитана, необходимо подготовить массив с данными о необходимости включения в нормализацию
        // входящих и исходящих остатков, дебетовых и кредитовых оборотов по данным формы 501
        if (m_balanceReport.isCalculated())
            getPreparedArrayBalanceAcc(arrayBalanceAcc, part);
        end;

        if (iterator != null)
            iterator.setSortOrder(TSorter());
            iterator.setFilter(TFilter());

            iterator.moveFirst();
            var currentBalanceAcc      = "";
            var isNeedNormalizeByRests = true;
            var isNeedNormalizeByTurns = true;
            while (not iterator.isDone())
                if (m_balanceReport.isCalculated())
                    if   (    (iterator.currentItem.fieldValue("ПризнакИП").exact != 1) 
                          and (iterator.currentItem.fieldValue("НомБС").exact     != balanceNumberWhereExistCorrect)
                          and (iterator.currentItem.fieldValue("НомБС").exact     != currentBalanceAcc)
                         )
                        currentBalanceAcc      = iterator.currentItem.fieldValue("НомБС").exact;
                        isNeedNormalizeByRests = isNeedNorzmalize(iterator.currentItem.fieldValue("НомБС").exact, IS_RESTS);
                        isNeedNormalizeByTurns = isNeedNorzmalize(iterator.currentItem.fieldValue("НомБС").exact, IS_TURNS);
                        if (isNeedNormalizeByRests)
                            addRuleForBalanceByRests(iterator.currentItem);
                        end;
                        if ((isNeedNormalizeByTurns) and (part != PART_3))
                            addRuleForBalanceByTurns(iterator.currentItem);
                        end;
                    elif (iterator.currentItem.fieldValue("ПризнакИП").exact == 1)
                        balanceNumberWhereExistCorrect = iterator.currentItem.fieldValue("НомБС").exact;
                        m_protocolView.printLine("Лицевой счет " + iterator.currentItem.fieldValue("НомЛС").exact + " имеет исправительные проводки, поэтому сходимость с формой \"Балансовые счета\" для соответствующего балансового счета не обеспечена.");
                    end;
                end;

                if (part != PART_3)
                    addRuleForAccount(iterator.currentItem, balanceNumberWhereExistCorrect, isNeedNormalizeByRests, isNeedNormalizeByTurns);
                end;

                if ((m_balanceReport.isCalculated()) and (part == PART_3) and (isNeedNormalizeByRests))
                    addRuleForPart3Account(iterator.currentItem);
                end;

                if (javaHashMap != null)
                    var currentAccPrevousReport = getRcbAttributeFromHashMap(iterator.currentItem.fieldValue("КодКО").exactAsString,
                                                                             iterator.currentItem.fieldValue("НомЛС").exactAsString,
                                                                             javaHashMap);
                    if (currentAccPrevousReport != null)
                        addRulesByPreviousReport(currentAccPrevousReport, iterator.currentItem);
                    end;
                end;

                iterator.moveNext();
            end;
        end;
    end;

    private macro save(part)
        var iterator, tempNode;

        if   (part == PART_1)
            iterator = m_report.attributeValue("Ф501_1").createValueIterator();
        elif (part == PART_2)
            iterator = m_report.attributeValue("Ф501_2").createValueIterator();
        elif ((part == PART_3) and (m_report.attributeValue("Ф501_3") != null))
            iterator = m_report.attributeValue("Ф501_3").createValueIterator();
        else
            iterator = null;
        end;

        if (iterator != null)
            iterator.setSortOrder(TSorter());
            iterator.setFilter(TFilter());

            iterator.moveFirst();
            while (not iterator.isDone())

                m_protocolView.printSeparatorLine();

                if (node("inPut" + iterator.currentItem.fieldValue("НомЛС").exact) != null)
                    tempNode = node("inPut" + iterator.currentItem.fieldValue("НомЛС").exact);
                    saveScaledValue(iterator.currentItem.fieldValue("ОстВход"), tempNode.getScaled());
                    m_protocolView.printString("ОстВход(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());
                else
                    m_protocolView.printString("ОстВход(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", iterator.currentItem.fieldValue("ОстВход").exact, iterator.currentItem.fieldValue("ОстВход").scaled);
                end;

                if (part != PART_3)
                    tempNode = node("debet" + iterator.currentItem.fieldValue("НомЛС").exact);
                    saveScaledValue(iterator.currentItem.fieldValue("ОбДебет"), tempNode.getScaled());
                    m_protocolView.printString("ОбДебет(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());

                    tempNode = node("credit" + iterator.currentItem.fieldValue("НомЛС").exact);
                    saveScaledValue(iterator.currentItem.fieldValue("ОбКредит"), tempNode.getScaled());
                    m_protocolView.printString("ОбКредит(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());
                end;

                if (node("outPut" + iterator.currentItem.fieldValue("НомЛС").exact) != null)
                    tempNode = node("outPut" + iterator.currentItem.fieldValue("НомЛС").exact);
                    saveScaledValue(iterator.currentItem.fieldValue("ОстИсход"), tempNode.getScaled());
                    m_protocolView.printString("ОстИсход(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", tempNode.getExact(), tempNode.getScaled());
                else
                    m_protocolView.printString("ОстИсход(" + iterator.currentItem.fieldValue("НомЛС").exact + ")", iterator.currentItem.fieldValue("ОстИсход").exact, iterator.currentItem.fieldValue("ОстИсход").scaled);
                end;

                iterator.moveNext();
            end;
        end;
    end;

    macro execute()
        m_protocolView.beginProtocol();

        if (not m_balanceReport.isCalculated())
            m_protocolView.printReportAbsence("Балансовые счета", m_balanceReport);
        end;

        if (not m_previousReport.isCalculated())
            m_protocolView.printReportAbsence("501", m_previousReport);
        end;

        addRules(PART_1);
        addRules(PART_2);
        addRules(PART_3);

        normalize();

        if (not isNormalized())
            m_protocolView.printLine("Данные нормализовать не удалось(см. протокол " + getLogFilePath() + ").");
            m_protocolView.endProtocol();
            showProtocol();
            return;
        end;

        save(PART_1);
        save(PART_2);
        save(PART_3);

        m_protocolView.endProtocol();

        RcbApplication.TransactionManager.commit();

        showProtocol();
    end;

    macro constructor(protocolView, dateForTuneTable)
        initF501NormalizerBase(protocolView);
        initialize();

        m_dateForTuneTable = dateForTuneTable;
    end;

    constructor(protocolView, dateForTuneTable);
end;

macro executeNormalizationOperation()
    if (   (rcbApplication().currentReport().context.period.EndDate >= RCB_I5456_DATE) 
        or (is5456RSHBChangesProject() and (rcbApplication().currentReport().context.period.EndDate >= RCB_I5456_DATE_F501)))
        F501Normalizer_I5456(F501NormalizationProtocolView(), RCB_I5456_DATE).execute();
    else
        F501NormalizerBase(F501NormalizationProtocolView()).execute();
    end;
end;

macro showProtocolView()
    F501NormalizerBase(F501NormalizationProtocolView()).showProtocol();
end;

установитьФлагВозврата(OK_MACRO_FLAG);
exit(1);
