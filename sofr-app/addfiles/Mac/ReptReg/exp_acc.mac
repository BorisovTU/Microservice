/*
$Name: exp_acc.mac
$Module: Регламентируемая отчетность
$Description: Выгрузка данных по б/с глав А-Д для импорта в программу Balance.exe
*/

/*───────────────────────────────────────────────────────────────────────────┐

 * Выгрузка данных по б/с глав А-Д для импорта в программу Balance.exe.     *
 * Отчеты ЦБ 4.31.076 / Balance.exe от 02.02.1998 Титаров П.(TPS), 23.04.98 *

 MODIFICATIONS: 05.10.98 Сабитов Переход на cy_*.dbt
                18.10.99 LA      Корректировка в соответствии с
                                 ТЗ 171-03-101, перевод на 5.1
    26.07.2001 - Sal.  SCR 22873
      Данные для экспорта в balance.exe должны быть представлены в тысячах
└───────────────────────────────────────────────────────────────────────────*/

import cb_sql;
IMPORT reptCBInter, cy_find, logfile, lib_exp;
import RcbWebCommon;

/* ------------------------------------------------------------------------ */
/*                             Настройки                                    */

/*CONST ДиректорияИмпортаBalanceEXE = ReturnDirString( "TEXTDIR", "TXTFILE" );*/
CONST ДиректорияПротоколаРаботы   = ReturnDirString( "TEXTDIR", "TXTFILE" );
CONST ИмяПротоколаРаботы          = "expbal.log";

VAR
 ВыгрузкаПоРабПлану;

getRegistryValue( "REPTREG\\REP_GROUPS\\BALANCE_ACCOUNTS\\ЭКСПОРТ ПО РАБОЧЕМУ ПЛАНУ",
                  V_BOOL, ВыгрузкаПоРабПлану, NULL );
       /* Если значение настройки равно TRUE, то выгружать па варианту 1,
          если FALSE, то по 2-му варианту.
          Вариант 1:
          Передаются данные по всем балансовым счетам,
          для которых есть переменные в форме "Балансовые счета".
          При этом предполагается, что банк перешел на "рабочий план" счетов
          и в списке переменных данной формы присутствуют все счета,
          утвержденные как работающие в целом по кредитной организации.
          Вариант 2:
          Передаются данные только по тем счетам, по которым хотя бы одно из
          значений (остатки и обороты) не нулевое.*/

/* ============================= Декларации =============================== */

/* ------------------------ Файлы, структуры, диалоги --------------------- */

FILE vd ( cy_varsd, "cy_files.def" ) KEY 2; /* KEY = iFormId + szVarName */

FILE b  ( balance );

FILE l () txt write;    /* Файл экспорта */

FILE tout () txt;

/* ------------------------- Переменные и константы ----------------------- */

/* --- Для формирования имен переменных --- */

/* Принадлежность */
CONST TPS_РУБЛИ = 0;
CONST TPS_ПОКР  = 1;
CONST TPS_ИТОГО = 2;

array TPS_Принадлежность;
TPS_Принадлежность(0) = "Ру";
TPS_Принадлежность(1) = "По";
TPS_Принадлежность(2) = "__";

/* Вид */
CONST TPS_АКТИВ  = 0;
CONST TPS_ПАССИВ = 1;
CONST TPS_ДЕБЕТ  = 2;
CONST TPS_КРЕДИТ = 3;

array TPS_Вид;
TPS_Вид(0) = "А";
TPS_Вид(1) = "П";
TPS_Вид(2) = "Д";
TPS_Вид(3) = "К";

/* --- Меню --- */
array MenuItem;
MenuItem(0) = "Балансовые счета";
MenuItem(1) = "Счета доверительного управления";
MenuItem(2) = "Внебалансовые счета";
MenuItem(3) = "Счета срочных операций";
MenuItem(4) = "Счета ДЕПО";
MenuItem(5) = "Все главы";

VAR choice;
VAR counter;
VAR i;

/* --- Выбор имени файла экспорта --- */
VAR exponame;   /* Имя файла экспорта           */
VAR expomask;   /* Маска имени файла экспорта   */


/* --- Идентификатор формы --- */
VAR _formID = "";

/* Определены ли переменные формы */
VAR undef = TRUE,
    VarUndef = FALSE;

/* ===================== Получение идентификатора отчета ================== */
MACRO formID
 if( valType( _formID ) == V_INTEGER )
  return _formID;
 end;

 _formID = НайтиИдентификаторОтчетаПоНазванию ({Название Отчета});
 return _formID;
END;

private macro isWorkableVariable(szVarName)
    var cmd =    "SELECT null"
        + "\n" + "  FROM dcy_varsd_dbt"
        + "\n" + " WHERE t_iFormId   = " + formID()
        + "\n" + "   AND t_szVarName = '" + szVarName + "'"
        + "\n" + "   AND t_bdInclude <= " + GetSQLDate(ДатаОтчета)
        + "\n" + "   AND t_bdExclude >= " + GetSQLDate(ПредДатаОтчета);
    var dataSet = TRsbDataSet(cmd);

    if (dataSet.next())
        return true;
    end;
    return false;
end;

private macro readVariableValue(result, szVarName)
    var cmd =    "SELECT null"
        + "\n" + "  FROM dcy_varsd_dbt"
        + "\n" + " WHERE t_iFormId    = " + formID()
        + "\n" + "   AND t_szVarName  = '" + szVarName + "'";
    var dataSet = TRsbDataSet(cmd);

    if (dataSet.next())
        cmd =        "SELECT mr.t_mean2"
            + "\n" + "  FROM dcy_varsd_dbt vd,"
            + "\n" + "       dcy_mreal_dbt mr"
            + "\n" + " WHERE vd.t_iFormId    = " + formID()
            + "\n" + "   AND vd.t_szVarName  = '" + szVarName + "'"
            + "\n" + "   AND mr.t_iNumDprt   = " + НомерПодразделения
            + "\n" + "   AND mr.t_isSummary  = " + GetSqlChar( RcbIsSummaryMode )
            + "\n" + "   AND mr.t_OrganizationStructure = " +  RcbOrganizationStructure
            + "\n" + "   AND mr.t_IssueMode  = " + RcbIssueMode
            + "\n" + "   AND mr.t_bdRepDate  = " + GetSQLDate(ДатаОтчета)
            + "\n" + "   AND mr.t_bdPrevDate = " + GetSQLDate(ПредДатаОтчета)
            + "\n" + "   AND mr.t_iFormId    = " + formID()
            + "\n" + "   AND mr.t_iVarId     = vd.t_iVarId";
        dataSet = TRsbDataSet(cmd);

        if (dataSet.next())
            setParm(0, dataSet.mean2 / 1000);
            return true;
        else
            if (not isWorkableVariable(szVarName))
                setParm(0, 0);
                return true;
            end;
        end;
    end;

    return false;
end;

/* ====================== Получение значения переменной =================== */
MACRO getBalanceVariable( балансовый, вид, принадлежность,
                          вернуть_имя_переменной )
    VAR result  = 0,
    varname = "Бн" + балансовый + TPS_Принадлежность( принадлежность ) + TPS_Вид( вид );

    vd.iFormId   = formID;
    vd.szVarName = varname;

    if( getEQ( vd ) )
        VarUndef = false;/* Есть такая переменная в базе */

        if (not readVariableValue(result, vd.szVarName))
            if( MeanUndefByZero != 0 ) /* Если установлен флаг "При печати и сведении полагать
                                          неопределенные значения равными 0"*/
                result = 0;
            else
                msgbox(" Не определена переменная ",{Название Отчета}, ".", vd.szVarName, "|Экспорт не произведен." );
                exit(1);
            end;

        else
            undef = FALSE;
        end;

    else
        VarUndef = true;/* Нет такой переменной в базе */
    end;

    if( not VarUndef )
        VarUndef = not(isWorkableVariable(varname));
    end;

    setParm( 3, varname );
    return result;
END;

/* ================== Выгрузка данных по балансовым счетам ================ */
MACRO exportBalanceAccount( balance, kind, p_DEPO )
 VAR inRestRub,  debitRub,  creditRub,  outRestRub,   /* Рубли     */
     inRestCur,  debitCur,  creditCur,  outRestCur,   /* Покрытие  */
     inRestBoth, debitBoth, creditBoth, outRestBoth,  /* Всего     */
     found = FALSE;

 /* Получить входящий и исходящий остатки, дебет и кредит заданного типа
    ( рубли, покрытие, всего ) */
 MACRO get4( p_kind,   rp_inRest, rp_debit, rp_credit, rp_outRest )
  VAR res = FALSE,
      varNameActive, varNamePassive,
      l_restA, l_restP,
      l_err = "";

  res = ((  l_restA  = getBalanceVariable( balance, TPS_АКТИВ,  p_kind, varNameActive  )) != 0 ) or
          res;
  res = ((  l_restP  = getBalanceVariable( balance, TPS_ПАССИВ, p_kind, varNamePassive )) != 0 ) or
          res;
  res = (( rp_debit  = getBalanceVariable( balance, TPS_ДЕБЕТ,  p_kind )) != 0 ) or
          res;
  res = (( rp_credit = getBalanceVariable( balance, TPS_КРЕДИТ, p_kind )) != 0 ) or
          res;

  if( ( l_restA > 0 ) and
      ( l_restP > 0 ) )
   printDebugString( "Возможно, неверно рассчитано значение переменных "+
                     varNameActive + " и " + varNamePassive, TPS_WARNING );
   printDebugString( varNameActive    + "=" + string( l_restA ),TPS_DETAILS );
   printDebugStringLn( varNamePassive + "=" + string( l_restP ),TPS_DETAILS );
  end;

  rp_outRest = l_restP - l_restA;
  rp_inRest  = rp_outRest  - rp_credit + rp_debit;

  if( kind == "А" )
   rp_outRest = - rp_outRest;
   rp_inRest  = - rp_inRest;
  end;

  if( p_kind == TPS_РУБЛИ )
   l_err = " в рублях ";

  elif( p_kind == TPS_ПОКР )
   l_err = " покрытия ";

  elif( p_kind == TPS_ИТОГО )
   l_err = " итого ";
  end;

  if( rp_inRest < 0 )
   printDebugString( "Тип входящего остатка" + l_err + "по счету " +
                     balance + " не соответствует типу счета", TPS_ERROR );
  end;

  if( rp_outRest < 0 )
   printDebugString( "Тип исходящего остатка" + l_err + "по счету " +
                      balance + " не соответствует типу счета", TPS_ERROR );
  end;

  setParm( 1, rp_inRest );
  setParm( 2, rp_debit );
  setParm( 3, rp_credit );
  setParm( 4, rp_outRest );
/*  msgbox( res or ( ВыгрузкаПоРабПлану and (not VarUndef ) ) );*/
  return res or ( ВыгрузкаПоРабПлану and ( not VarUndef ) );
 END;

 message("Балансовый счет ~" + balance + "~");

 /* ----- Определение необходимых значений ----- */

 if( not p_DEPO ) /* обрабатываем обычный счет (не ДЕПО) */
  /* Рубли */
  found = ( ( get4( TPS_РУБЛИ, inRestRub,  debitRub,  creditRub,  outRestRub ) ) or
            ( found ));

  /* Покрытие */
  found = ( ( get4( TPS_ПОКР,  inRestCur,  debitCur,  creditCur,  outRestCur ) ) or
            ( found ));
 end;

 /* Итого  */
 found = ( ( get4( TPS_ИТОГО, inRestBoth, debitBoth, creditBoth, outRestBoth ) ) or
           ( found ));

 /* ----- Выгрузка в выходной файл ----- */
 if( found )
  if( p_DEPO )
   l.str = balance + "     " +
           kind +
           string( 0 :13:0 ) +
           string( 0 :13:0 ) +
           string( inRestBoth :13:0 ) + "     " +
           string( 0 :13:0 ) +
           string( 0 :13:0 ) +
           string( debitBoth  :13:0 ) + "     " +
           string( 0 :13:0 ) +
           string( 0 :13:0 ) +
           string( creditBoth :13:0 ) + "     " +
           string( 0 :13:0 ) +
           string( 0 :13:0 ) +
           string( outRestBoth:13:0 );
  else
   l.str = balance + "     " +
           kind +
           string( inRestRub  :13:0 ) +
           string( inRestCur  :13:0 ) +
           string( inRestBoth :13:0 ) + "     " +
           string( debitRub   :13:0 ) +
           string( debitCur   :13:0 ) +
           string( debitBoth  :13:0 ) + "     " +
           string( creditRub  :13:0 ) +
           string( creditCur  :13:0 ) +
           string( creditBoth :13:0 ) + "     " +
           string( outRestRub :13:0 ) +
           string( outRestCur :13:0 ) +
           string( outRestBoth:13:0 );
  end;
/*   msgbox(l.str);*/
  if( insert(l) )
/*   msgbox("insert");*/
   counter = counter + 1;
  else
   printDebugString( "Ошибка при записи строки " + l.str, TPS_ERROR );
  end;
 end;
END;

/* ================== Выгрузка данных по заданной главе =================== */
MACRO exportChapter( p_chaptN )
 VAR l_name, /* название экспортируемой главы */
     l_DEPO, /* параметр, определяющий, обрабатываем ли счета ДЕПО */
     l_bAcc, /* номер текущего балансового счета */
     cont;

 /* Определить название главы */
 if( p_chaptN == 1 )
  l_name = "А   Балансовые счета";
 elif( p_chaptN == 2 )
  l_name = "Б   Счета доверительного управления";
 elif( p_chaptN == 3 )
  l_name = "В   Внебалансовые счета";
 elif( p_chaptN == 4 )
  l_name = "Г   Счета срочных операций";
 elif( p_chaptN == 5 )
  l_name = "Д   Счета ДЕПО";
 else
  msgBox("Неправильный параметр p_chaptN в функции exportChapter");
  exit(1);
 end;

 l_DEPO = ( p_chaptN == 5 );

 /* Протокол */
 printDebugString( string( date ) + " Экспорт данных главы " + l_name, TPS_TOPIC );
 printDebugString( "За период с " + string( ПредДатаОтчета ) + " по " + string( ДатаОтчета ), TPS_DETAILS );


 /* Экспорт */
 b.Chapter = p_chaptN;
 b.iNumPlan = 0;
 b.Balance  = "";

 cont = ( ( getGE( b ) ) and
          ( b.Chapter == p_chaptN ) and
          ( b.iNumPlan == 0 ) );
 while( cont )
  l_bAcc = trim( b.Balance );
  if( strlen( l_bAcc ) == 5 )
   exportBalanceAccount( l_bAcc, trim( b.Kind_Account ), l_DEPO );
  end;

  cont = ( ( next( b ) ) and
           ( b.Chapter == p_chaptN ) and
           ( b.iNumPlan == 0 ) );
 end;

 close(l);

 if( counter == 0 )
  delFile( exponame );

  if( not undef )
   printDebugString( "Данные по всем счетам главы нулевые. Файл экспорта не сформирован.",
                     TPS_DETAILS );
  else
   printDebugString( "Данные по всем счетам главы не определены. Файл экспорта не сформирован.",
                     TPS_DETAILS );
  end;

 else
  printDebugString( "Файл: " + exponame, TPS_DETAILS );
  printDebugString( "Выгружено строк: " + string( counter ), TPS_MESSAGE );
 end;

 printDebugStringLn( "Окончание экспорта данных главы " + l_name, TPS_TOPIC );
END;

/* =================== Формирование имени файла экспорта ================== */
MACRO buildFileName( choice )
 VAR day, month, year;

 datesplit( ДатаОтчета, day, month, year );

 month = string( month );
 month = mkStr( "0", 2 - strlen( month ) ) + month;

 return ( "bl" + string( choice + 1 ) + "_" + month +
          substr( string( year ), 3,2 ) + ".txt" );
END;

/* ============================= Точка входа ============================== */

if ( РасчетВКопейках )
 msgbox("Данные для экспорта в balance.exe должны быть представлены в тысячах");
 exit(1);
end;

/* Выбор экспортируемых данных */
if( ( choice = menu( menuItem,
                     "Выберите вид выгружаемой информации",
                     "Экспорт данных")) < 0 )
 exit(1);
end;

/* Выбор имени файла  */
if( choice == 5 ) /*Все главы*/
 i = 0;
 while( i < 5 )
   exponame = buildFileName( i );

   if( not GetExpFileName( exponame ) )
    exit(1);
   end;

   if( not open( l, exponame ) )
    msgBox("Невозможно открыть файл экспорта|" + exponame );
    exit(1);
   end;

   setOutput( ДиректорияПротоколаРаботы + ИмяПротоколаРаботы, FALSE);

   counter   = 0;

   exportChapter( i + 1 );

   i = i + 1;
 end;
else

  exponame = /*ДиректорияИмпортаBalanceEXE + */buildFileName( choice );

  if( not GetExpFileName( exponame ) )
   exit(1);
  end;
/*if( not selectFile( exponame, expomask, "Введите имя файла экспорта" ))
 exit(1);
end;
*/
  if( not open( l, exponame ) )
   msgBox("Невозможно открыть файл экспорта|" + exponame );
   exit(1);
  end;

  setOutput( ДиректорияПротоколаРаботы + ИмяПротоколаРаботы, FALSE
/*           not getTrue( FALSE, "Очистить файл протокола?" ) */);
  counter   = 0;

/* Собственно экспорт */
  exportChapter( choice + 1 );
end;

open( tout, setoutput( NULL, TRUE ) );
RepTxtFilesQueue().add(setoutput( NULL, TRUE ));
viewFile( tout );
exit(1);

/* EoF */