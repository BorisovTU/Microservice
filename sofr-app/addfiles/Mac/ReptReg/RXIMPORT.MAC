/*───────────────────────────────────────────────────────────────────────────┐
  RS-Bank version 4.31                                   R-Style Software Lab
  Файл подсистемы "Отчеты ЦБ"

  Импорт переменных заданного вида в отчет

  Импорт производится всегда по текущей отчетной дате или диапазону дат.
  При импорте производятся соответствующие проверки на соответствие
  текущих параметров файла текущим параметрам.

FILENAME: RXIMPORT.MAC
CREATED: 19.07.96 Молоков С.
MODIFICATIONS:
  08.12.96 Поддержка сохранения 2-х дат
  16.06.97 Мол.
     Изменен формат строки сигнатуры, введены RSL-функции распознавания
     этой строки. В соответствии с этим макрос скорректирован.
     Примечание : оставлена совместимость по чтению со старым форматом.
  23.06.97 Мол.
     Исправлен алгоритм импорта. Теперь осуществляется проверка наличия
     записи с предыдущими данными.
  08.07.97 Мол. Переход на встроенные функции
  21.11.97 Мол.
    Корректировка проверки вида переменных для версии 1 формата
    импортируемого файла
  06.10.98 Сабитов Переход на cy_*.dbt
  11.12.98 Мол. Ограничения на использование формата импортируемых данных

NOTES:
  1.
  При импорте данные обновляются ПОЛНОСТЬЮ, включая те данные, которые
  обычно защищены от обновления и не могут быть обработаны программой.
  Единственная особенность, которую надо учитывать : если переменная
  защищена от записи, и определена, и, при этом, в файле импорта
  не определено значение такой переменной, значение такой переменной
  остается без изменения.
  При реальной работе такой ситуации быть не должно, так как, как правило,
  данные экспортируются тогда, когда отчет полностью закончен, и,
  следовательно, все данные определены.
  2.
  Поддерживаются форматы 1.00 и 2.00.
  Для форматов 3.00 и выше требуется системная функция

└───────────────────────────────────────────────────────────────────────────*/

IMPORT ReptCBInter, RX_Exchange, cy_find, vuse_lib;

var
   viewRezult = false,
   ИдентификаторОтчета,
   {NumDprt};

CONST
     РасширениеИмени = ".IMP",
     Ограничитель    = "│"; /* Разделитель данных */

FILE ФайлИмпорта() TXT;
FILE Отчеты( cy_forms, "cy_files.def" ) KEY 0 WRITE; /*KEY=iFormName*/

/* --------------------- */

MACRO PrintError( str)
  println( str);
  viewRezult = true;
END;

MACRO GenError( ИмяФайла, Текст)
VAR
   MSG,
   stat = Status( MSG);

  MsgBox( string( Текст, "|", MSG, "|\"" + ИмяФайла + "\"|", "статус ", stat));
  Exit( 1);
END;

MACRO ОткрытьФайлИмпорта()
VAR
   ImportFileName;

  /* Имя файла экспорта */

  Отчеты.iFormId = ИдентификаторОтчета;

  if ( not GetEQ( Отчеты) )
    GenError( FileName( Отчеты), "Не найдено описание формы или ошибка системы");
  end;

  if ( not Отчеты.iMultiKind )
    {Вид переменной} = "";
  end;

  /* Имя файла экспорта
    0 - Имя файла + расширение (возвращаемая строка)
    1 - Номер отделения
    2 - Название формы
    3 - Вид переменных
    4 - Дата отчета
    5 - TRUE - экспорт, FALSE - импорт
  */
  if ( not ИмяФайлаОбменаДанными( ImportFileName,
                                  {NumDprt},
                                  {Название отчета},
                                  {Вид переменной},
                                  ДатаОтчета,
                                  ПредДатаОтчета,
                                  FALSE) )
    MsgBox( "Ошибка формирования имени файла экспорта");
    Exit( 1);
  end;

  if ( not SelectFile( ImportFileName, ImportFileName, "Имя файла для импорта"))
    Exit( 1);
  end;

  if ( not Open( ФайлИмпорта, ImportFileName) )
    GenError( ImportFileName, "Ошибка открытия файла");
  end;

  SetDelim( Ограничитель);
END;

/* Формат : Подразделение, Отчет, Дата */
MACRO ПроверитьЗаголовок()
var
   _Подразделение,
   _Отчет,
   _Вид,
   _ОбеДаты,
   _ПредДата,
   _Дата,
   str, ver;

  if ( not next( ФайлИмпорта))
     GenError( FileName( ФайлИмпорта), "Ошибка навигации или файл пуст");
  end;

  ver = РаскрытьОпределениеФайлаЭкспорта( ФайлИмпорта.str,
     _Подразделение, _Отчет, _Вид, _ОбеДаты, _ПредДата, _Дата);

  /* Проверки абсолютные */

  if ( not (_Отчет == {Название отчета}) )
    MsgBox( string( "Данные для другого отчета (\"", _Отчет, "\")|",
                    "Импорт невозможен"));
    Exit( 1);
  end;

  if ( ver > 2.00 )
    MsgBox( "Форматы версии выше 2.00 не поддерживаются !|"+
            "Используйте для импорта системную операцию No 31002");
  end;

  if ( ver == 1.00 ) /* В 1-й версии данные не различались по видам переменных */
    _Вид = {Вид переменной};
  end;

  if ( not (_Вид == {Вид переменной}) )
    MsgBox( string( "Неверный вид переменных (\"", _Вид, "\")|",
                    "Импорт невозможен"));
    Exit( 1);
  end;

  /* Проверки условные */

  if ( not (_Подразделение == НомерПодразделения) )
    if ( not GetTrue( True, string( "Данные чужого подразделения (",_Подразделение,"). Продолжить ?")) )
      Exit( 1);
    end;
  end;

  if ( _ОбеДаты )
    if (    (not (_Дата == ДатаОтчета))
         or (not (_ПредДата == ПредДатаОтчета))
       )
      if ( not GetTrue( True, string( "Данные за другой период (",_ПредДата,"..",_Дата,"). Продолжить ?")) )
        Exit( 1);
      end;
    end;
  else
    if ( not (_Дата == ДатаОтчета) )
      if ( not GetTrue( True, string( "Данные за другое число (",_Дата,"). Продолжить ?")) )
        Exit( 1);
      end;
    end;
  end;
END;

MACRO ИмпортироватьДанные()
var
   _Перем,
   Строка = 1,
   msg,
   ДатаАнонса,
   ОбновитьЗапись = False;

  /*keynum( Переменные, 0); -*KEY = szFormName+szVarName*/

  VU_InitImportReportM();

  while ( next( ФайлИмпорта) )
    if ( not СтрокаИмпортаВЗначение( ФайлИмпорта.str) )
      MsgBox( ПоследняяОшибкаЭкспИмп() );
      Exit( 1);
    end;

    Строка = Строка+1;
  end;

  VU_DoneImportReportM();

  if ( not АнонсироватьДаты( НомерПодразделения, {Название отчета}, {Вид переменной}, ДатаОтчета, ПредДатаОтчета) )
    GenError( "Анонс дат", "Ошибка регистрации вычисленных значений");
  end;
END;

MACRO УдалениеДанных()
/*Подтвердить удаление данных и удалить*/
  VAR DeletePrev = false, retCode;
  if ( ПроверитьСохраненнДаты( НомерПодразделения, {Название отчета}, {Вид переменной}, ДатаОтчета, ПредДатаОтчета) )
    if ( not GL_FLG_REC )
      /* Есть данные - удалять ? */
      if ( not GetTrue( DeletePrev, "Уже есть данные. Удалить ?") )
        УстановитьФлагВозврата(OK_MACRO_FLAG); /* Успешное завершение макроса */
        exit( 1);
      end;
      message( "Удаление предыдущих данных. Ждите...");
      
      if ( not ( {Вид переменной} == "" ) )
        retCode = УдалитьЗначенияПеременных( ДатаОтчета, ПредДатаОтчета, {Название отчета}, {Вид переменной}, 2);
      else /* Для всех переменных */
        retCode = УдалитьЗначенияПеременных( ДатаОтчета, ПредДатаОтчета, {Название отчета}, "\"", 2);
      end;
    
      if ( not retCode )
        MsgBox( "Ошибка удаления предыдущих значений переменных");
        Exit( 1);
      else
        ДенонсироватьДаты( НомерПодразделения, {Название отчета}, {Вид переменной}, ДатаОтчета, ПредДатаОтчета);
      end;
    else
        /* При рекурсивном пересчете не выдается запрос на подтверждение,
           данные не удаляются */
        УстановитьФлагВозврата(OK_MACRO_FLAG); /* Успешное завершение макроса */
        exit( 1);
    end;
  end;
END;

/*═══════════════════════════════╕
│    Точка входа в программу     │
╘═══════════════════════════════*/

ИдентификаторОтчета = НайтиИдентификаторОтчетаПоНазванию ({Название отчета});

ОткрытьФайлИмпорта();
ПроверитьЗаголовок();

УдалениеДанных();

ИмпортироватьДанные();

УстановитьФлагВозврата( OK_MACRO_FLAG); /* Успешное завершение макроса */
Exit( 1); /* Окончание работы макроса без вывода на экран */

/*eof*/