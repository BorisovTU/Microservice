/*
$Name:          balanceNormalizerMmb.mac
$Module:        Регламентируемая отчетность
$Description:   Форма Балансовые счета. Нормализатор с контролем погрешности
*/

import RepCache;
import RcbClassLibInter;
import RcbCoreInter;
import rcbconst;
import lib_lang;
import repException;
import ReportNormalizer;
import ReportLinearRelation;
import controlExcludedAccounts;
import RcbProtocolView;
import balanceAttribute;
import balanceNormalizerParameters;
import balanceCheck;

import testLib;

private const MONEY_PRECISION = $0.000001;

private class (TProtocolView) TProtocol(description : String)
    private var m_table = CTableReport();

    initTProtocolView(description);

    macro constructor()
        m_table.addColumn("Код узла нормализации", 28);
        m_table.addColumn("Точное значение|в нац. валюте", 25);
        m_table.addColumn("Округленное значение|в тысячах");
        m_table.addColumn("Нормализованное значение|в тысячах");
        m_table.addColumn("Погрешность|в тысячах");
        m_table.addColumn("Предупреждение");
    end;

    macro printDescription()
        setProtocolOutput();
        printHead();
        resetProtocolOutput();
    end;

    macro printHeadTable(chapter : String)
        setProtocolOutput(true);
        m_table.printHead();
        resetProtocolOutput();
    end;

    macro printString(variableName, exactValue, oldValue, newValue, def, warning)
        setProtocolOutput(true);
        m_table.printStringTransferByWord(variableName, exactValue, oldValue, newValue, def, warning);
        resetProtocolOutput();
    end;

    macro printStringExt(str : String)
        setProtocolOutput(true);
        m_table.printStringExt(str, m_table.getAColumns().size);
        resetProtocolOutput();
    end;

    macro printSeparator(isTop : Bool)
        setProtocolOutput(true);
        m_table.printSeparatorExt(true, isTop, m_table.getAColumns().size);
        resetProtocolOutput();
    end;

    macro printBottomTable()
        setProtocolOutput(true);
        m_table.printBottom();
        resetProtocolOutput();
    end;

    macro printLine(str)
        setProtocolOutput(true);
        printLine(str);
        resetProtocolOutput();
    end;

    constructor();
end;

private var m_parameters = null;
private class (TNormalizerParametersBase) TParametersImpl()
    private var m_isEnableUserPriority;
    private var m_isEnableUserPriorityForChapter;
    private var m_userPriority_0;
    private var m_userPriority_100;

    private var m_isExcludeAccounts;
    private var m_isExcludeAccountsForChapter;
    private var m_excludedAccountsRouble;
    private var m_excludedAccountsForeign;
    private var m_excludedAccountsTotal;

    private var m_maximumSolvingDuration;

    private var m_maximumPermissibleDecisionsAmount;

    private var m_maximumError;
    private var m_maximumTurnsRoundingError;
    private var m_maximumChapterTurnsRoundingError;
    private var m_maximumErrorAccounts;

    private var m_multiplierForChapter5;

    macro isEnableUserPriority()
        return m_isEnableUserPriority;
    end;

    macro isEnableUserPriorityForChapter(chapter)
        return m_isEnableUserPriorityForChapter[chapter];
    end;

    macro getUserPriority_0(chapter)
        return m_userPriority_0[chapter];
    end;

    macro getUserPriority_100(chapter)
        return m_userPriority_100[chapter];
    end;

    macro isExcludeAccounts()
        return m_isExcludeAccounts;
    end;

    macro isExcludeAccountsForChapter(chapter)
        return m_isExcludeAccountsForChapter[chapter];
    end;

    macro getExcludedAccountsRouble(chapter)
        return m_excludedAccountsRouble[chapter];
    end;

    macro getExcludedAccountsForeign(chapter)
        return m_excludedAccountsForeign[chapter];
    end;

    macro getExcludedAccountsTotal(chapter)
        return m_excludedAccountsTotal[chapter];
    end;

    macro getMaximumError(chapter)
        return m_maximumError[chapter];
    end;

    macro getMaximumSolvingDuration()
        return m_maximumSolvingDuration;
    end;

    macro getMaximumPermissibleDecisionsAmount()
        return m_maximumPermissibleDecisionsAmount * 1000.0;
    end;

    macro getMaximumTurnsRoundingError(chapter)
        return m_maximumTurnsRoundingError[chapter];
    end;

    macro setMaximumTurnsRoundingError(value, chapter)
        m_maximumTurnsRoundingError[chapter] = value;
    end;

    macro getMaximumChapterTurnsRoundingError(chapter)
        return m_maximumChapterTurnsRoundingError[chapter];
    end;

    macro setMaximumChapterTurnsRoundingError(value, chapter)
        m_maximumChapterTurnsRoundingError[chapter] = value;
    end;

    macro getMaximumErrorAccounts(chapter)
        return m_maximumErrorAccounts[chapter];
    end;

    macro getMultiplierForChapter5()
        return m_multiplierForChapter5;
    end;

    macro isOptimalDecision()
        return getMaximumPermissibleDecisionsAmount() == 0.0;
    end;

    macro printReport(protocol, chapter)
        printLine(protocol, "Начальные значения настроек:");
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ВКЛЮЧИТЬ КОНТРОЛЬ ПОГРЕШНОСТИ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "/ПРИОРИТЕТ 0", "\tПРИОРИТЕТ 0")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "/ПРИОРИТЕТ 100", "\tПРИОРИТЕТ 100")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/РУБЛИ", "\tРУБЛИ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ВАЛЮТА", "\tВАЛЮТА")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ИТОГ", "\tИТОГ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНОЕ ВРЕМЯ РЕШЕНИЯ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ")));

        if (chapter == 5)
            printLine(protocol, makeTabbedString(getReportString("REPTREG/REP_GROUPS/BALANCE_ACCOUNTS/ТОЧНОСТЬ ДЛЯ ГЛАВЫ Д")));
        end;
    end;

    macro printFactReport(protocol, chapter)
        printLine(protocol, "Фактические значения настроек:");
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ВКЛЮЧИТЬ КОНТРОЛЬ ПОГРЕШНОСТИ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "/ПРИОРИТЕТ 0", "\tПРИОРИТЕТ 0")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "/ПРИОРИТЕТ 100", "\tПРИОРИТЕТ 100")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/РУБЛИ", "\tРУБЛИ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ВАЛЮТА", "\tВАЛЮТА")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ИТОГ", "\tИТОГ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНОЕ ВРЕМЯ РЕШЕНИЯ")));
        printLine(protocol, makeTabbedString(getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ")));
        printLine(protocol, makeTabbedString("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ" + " = " + String(getMaximumChapterTurnsRoundingError(chapter) : * : 5)));
        printLine(protocol, makeTabbedString("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ" + " = " + String(getMaximumTurnsRoundingError(chapter) : * : 5)));

        if (chapter == 5)
            printLine(protocol, makeTabbedString(getReportString("REPTREG/REP_GROUPS/BALANCE_ACCOUNTS/ТОЧНОСТЬ ДЛЯ ГЛАВЫ Д")));
        end;
    end;

    private macro constructorTParametersImpl()
        initTNormalizerParametersBase("НАСТРОЙКИ_НОРМАЛИЗАТОРА_ММБ");

        var path : String = "";
        var rootPath : String = "";

        m_isEnableUserPriorityForChapter = RcbArray();
        m_userPriority_0 = RcbArray();
        m_userPriority_100 = RcbArray();
        m_isExcludeAccountsForChapter = RcbArray();
        m_excludedAccountsRouble = RcbArray();
        m_excludedAccountsForeign = RcbArray();
        m_excludedAccountsTotal = RcbArray();
        m_maximumError = RcbArray();
        m_maximumTurnsRoundingError = RcbArray();
        m_maximumChapterTurnsRoundingError = RcbArray();
        m_maximumErrorAccounts = RcbArray();

        rootPath = path = "REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ";
        getValue(path, V_BOOL, m_isEnableUserPriority, false);

        var i;
        if (m_isEnableUserPriority)
            i = 1;
            while (i <= 5)
                path = rootPath + "/ГЛАВА " + i;
                getValue(path, V_BOOL, m_isEnableUserPriorityForChapter[i], false);
                if (m_isEnableUserPriorityForChapter[i])
                    getValue(path + "/ПРИОРИТЕТ 0", V_STRING, m_userPriority_0[i], "");
                    getValue(path + "/ПРИОРИТЕТ 100", V_STRING, m_userPriority_100[i], "");
                    if ((m_userPriority_0[i] == "") and (m_userPriority_100[i] == ""))
                        m_isEnableUserPriorityForChapter[i] = false;
                    end;
                end;
                i = i +1;
            end;
        end;

        rootPath = path = "REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА";
        getValue(path, V_BOOL, m_isExcludeAccounts, false);
        if (m_isExcludeAccounts)
            i = 1;
            while (i <= 5)
                path = rootPath + "/ГЛАВА " + i;
                getValue(path, V_BOOL, m_isExcludeaccountsForChapter[i], false);
                if (m_isExcludeaccountsForChapter[i])
                    getValue(path + "/РУБЛИ", V_STRING, m_excludedAccountsRouble[i], "");
                    getValue(path + "/ВАЛЮТА", V_STRING, m_excludedAccountsForeign[i], "");
                    getValue(path + "/ИТОГ", V_STRING, m_excludedAccountsTotal[i], "");
                    if ((m_excludedAccountsRouble[i] == "") and (m_excludedAccountsForeign[i] == "") and (m_excludedAccountsTotal[i] == ""))
                        m_isExcludeaccountsForChapter[i] = false;
                    end;
                end;
                i = i +1;
            end;
        end;

        getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНОЕ ВРЕМЯ РЕШЕНИЯ", V_INTEGER, m_maximumSolvingDuration, 120);
        getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ", V_DOUBLE, m_maximumPermissibleDecisionsAmount, 50.0);

        i = 1;
        while (i <= 5)
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ  ПОГРЕШНОСТЬ/ГЛАВА " + i, V_DOUBLE, m_maximumError[i], 1.0);
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ/ГЛАВА " + i, V_DOUBLE, m_maximumChapterTurnsRoundingError[i], 1.0);
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА " + i, V_DOUBLE, m_maximumTurnsRoundingError[i], 1.0);
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/СЧЕТА С МАКС-НОЙ ПОГРЕШНОСТЬЮ/ГЛАВА " + i, V_STRING, m_maximumErrorAccounts[i], 1.0);
            i = i +1;
        end;

        m_multiplierForChapter5 = int("1" + mkstr("0", m_chapter5Precision));
    end;

    constructorTParametersImpl();
end;

private macro TParameters(forceNewInstance : bool)
    if (forceNewInstance)
        m_parameters = null;
    end;

    if (m_parameters == null)
        m_parameters = TParametersImpl();
    end;

    return m_parameters;
end;

private class TNormalizerContext(_caption, _isExcludeZeroTurns, _isNormalizeZeroTurns, _isNormalizeExactlyRoundedRests)
    var isNormalized = false;
    var caption = _caption;

    var isExcludeZeroTurns = _isExcludeZeroTurns;
    var isNormalizeZeroTurns = _isNormalizeZeroTurns;
    var isNormalizeExactlyRoundedRests = _isNormalizeExactlyRoundedRests;
end;

private class TChapterTotalTurnsData(multiplier, precision)
    var debitTotal : TValue = TValue($0, 0.0, multiplier, precision);
    var debitRouble : TValue = TValue($0, 0.0, multiplier, precision);
    var debitForeign : TValue = TValue($0, 0.0, multiplier, precision);
    var creditTotal : TValue = TValue($0, 0.0, multiplier, precision);
    var creditRouble : TValue = TValue($0, 0.0, multiplier, precision);
    var creditForeign : TValue = TValue($0, 0.0, multiplier, precision);

    macro add(_debitTotal, _debitRouble, _debitForeign, _creditTotal, _creditRouble, _creditForeign)
        debitTotal.plus(TValue(_debitTotal.exact, _debitTotal.scaled));
        debitRouble.plus(TValue(_debitRouble.exact, _debitRouble.scaled));
        debitForeign.plus(TValue(_debitForeign.exact, _debitForeign.scaled));
        creditTotal.plus(TValue(_creditTotal.exact, _creditTotal.scaled));
        creditRouble.plus(TValue(_creditRouble.exact, _creditRouble.scaled));
        creditForeign.plus(TValue(_creditForeign.exact, _creditForeign.scaled));
    end;

    macro recalculateScaled()
        debitTotal.recalculateScaled();
        debitRouble.recalculateScaled();
        debitForeign.recalculateScaled();
        creditTotal.recalculateScaled();
        creditRouble.recalculateScaled();
        creditForeign.recalculateScaled();
    end;

    macro clear()
        debitTotal.exact = $0;
        debitTotal.scaled = 0.0;

        debitRouble.exact = $0;
        debitRouble.scaled = 0.0;

        debitForeign.exact = $0;
        debitForeign.scaled = 0.0;

        creditTotal.exact = $0;
        creditTotal.scaled = 0.0;

        creditRouble.exact = $0;
        creditRouble.scaled = 0.0;

        creditForeign.exact = $0;
        creditForeign.scaled = 0.0;
    end;
end;

private class TNodeData(_id : String, _value : Object)
    var id = _id;
    var value = _value;

    macro makeId(name : String, rowKind : String, columnKind : String) : String
        return toANSI(name, true) + rowKind + columnKind;
    end;
end;

private class TUniversalPool(initialSize : Integer)
    private var m_pool : TRepCache;

    macro createValue(key)
        return TRcbPair(key, null);
    end;

    macro createKey(value)
        return value.first;
    end;

    macro clear()
        m_pool.clear();
        return this;
    end;

    macro add(key, value)
        var _key = key;
        return m_pool.add(_key, TRcbPair(_key, value));
    end;

    macro get(key)
        var _key = key;
        return m_pool.get(_key).second;
    end;

    private macro constructor(initialSize)
        defaultParm(initialSize, 24);
        m_pool = TRepCache(CACHE_MODE_DISORDERED, initialSize, r2m(this, "createValue"), r2m(this, "createKey"));
    end;

    constructor(initialSize);
end;

private class TNormalizerBase(chapter : Integer, multiplier : Double, additionalMultiplier : Double, precision : Integer)
    private const CONSTANT = "const";

    private var m_normalizer;

    private var m_relationsPool : TUniversalPool;

    private var m_chapter;
    private var m_protocol;
    private var m_isPreviousDataExists;
    private var m_chapterData;

    private var m_nodeDataPool : RcbArray;

    private var m_passiveChapterTurns : TChapterTotalTurnsData;
    private var m_activeChapterTurns : TChapterTotalTurnsData;

    private var m_multiplier;
    private var m_additionalMultiplier;
    private var m_precision;

    private var m_isExcludeZeroTurns;
    private var m_isNormalizeZeroTurns;
    private var m_isNormalizeExactlyRoundedRests;

    private var m_hasNonZeroAccounts;

    // 25.03.2014 ABP Подпорка под нормализатор - компенсирует отсутствие метода ReportNode::getLevel
    private var m_levels : TUniversalPool;

    private macro constructorTNormalizerBase(chapter : Integer, multiplier : Double, additionalMultiplier : Integer, precision : Integer)
        defaultParm(precision, RcbApplication().currentReport.form.attribute("БАЛАНС").structure.field("restActive").precision);

        m_multiplier = nvl(multiplier, balanceGlobal().getRcbReport().multiplier);
        m_additionalMultiplier = nvl(additionalMultiplier, 1);
        m_precision = precision;

        m_chapter = chapter;

        m_protocol = TProtocol("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ " + string(m_chapter) + " ГЛАВЫ");
// 15.04.2014 ABP При использовании reload() все ссылки на контейнеры RcbCore изменяются, поэтому на каждой итерации нормализации
//                переменную нужно обновлять
//        m_chapterData = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE).getCompositeValue("ГЛАВА" + m_chapter, m_chapter);


        m_relationsPool = TUniversalPool();
        m_isPreviousDataExists = (balanceGlobal().getRcbReport().previousPeriod.endDate != Date(0,0,0)) and
                                (TBaseBalanceAttribute("БАЛАНС", balanceGlobal().getPreviousReport(), TBalanceAttributeMode().READ_ONLY).isBalanceCalculated(chapter, RcbApplication().currentReport.dimension));

        m_passiveChapterTurns = TChapterTotalTurnsData(m_multiplier, m_precision);
        m_activeChapterTurns = TChapterTotalTurnsData(m_multiplier, m_precision);

        m_nodeDataPool = RcbArray();

        m_levels = TUniversalPool();
    end;

    private macro createAndInitializeNormalizer()
        m_chapterData = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE).getCompositeValue("ГЛАВА" + m_chapter, m_chapter);

        m_normalizer = ReportNormalizer(m_multiplier);

        m_relationsPool.clear();
        var rowKind = TRowKind().kindArray;
        var columnKind = TColumnKind().kindArray;
        var i = 0;
        while (i < columnKind.size)
            if (m_isPreviousDataExists and ((columnKind[i] == TColumnKind().ACTIVE_IN_REST) or (columnKind[i] == TColumnKind().PASSIVE_IN_REST)))
                i = i + 1;
                continue;
            end;

            var j = 0;
            while (j < rowKind.size)
                m_relationsPool.add(TNodeData().makeId("", rowKind[j], columnKind[i]), ReportLinearRelation(RCB_RS_EQUAL));
                j = j + 1;
            end;
            i = i + 1;
        end;

        m_normalizer.setMaxNumberOfDecision(TParameters().getMaximumPermissibleDecisionsAmount());
        m_normalizer.setIsOptimalDecision(TParameters().isOptimalDecision());

        if (TParameters().getMaximumSolvingDuration() != 0)
            m_normalizer.setTimeLimit(TParameters().getMaximumSolvingDuration());
        end;

        m_passiveChapterTurns.clear();
        m_activeChapterTurns.clear();
        m_nodeDataPool.clear();
        m_levels.clear();
    end;

    // 25.03.2014 ABP Подпорка под нормализатор - компенсирует отсутствие метода ReportNode::getLevel
    //                Действует до удаления java-нормализатора из дистрибутива
    private macro getParentLevel(parent, id, level)
        if (NormalizationAlgorithm.getReportNormalizationAlgorithm() != JAVA_MMB_NORMALIZER)
            if (parent != null)
                level = parent.getLevel();
            else
                level = null;
            end;
        else
            if (parent != null)
                level = m_levels.get(parent.code);
            else
                m_levels.add(id, nvl(level, 0));
                level = null;
            end;
        end;

        return level;
    end;

    private macro getNodeCount()
        return m_nodeDataPool.getCount();
    end;

    private macro addSpecialBalanceConstraints()
        throw(TPureVirtualMethodCallException("TNormalizerBase::addSpecialBalanceConstraints"));
    end;

    private macro setNodeValue(name, rowKind, columnKind, value, idx)
        var node;

        if (valType(name) == V_GENOBJ)
            node = name;
            value = rowKind;
            idx = columnKind;
        else
            node = m_normalizer.node(TNodeData().makeId(name, rowKind, columnKind));
        end;

        if (node != null)
            node.setExact(value.exact * m_additionalMultiplier);
            node.setScaled(value.scaled * m_additionalMultiplier);

            if (idx != null)
                m_nodeDataPool(idx).value.exact = value.exact;
                m_nodeDataPool(idx).value.scaled = value.scaled;
            else
                var id = node.getCode();
                m_nodeDataPool.moveFirst();

                while (m_nodeDataPool.moveNext())
                    if (m_nodeDataPool.getCurrentItem().id == id)
                        m_nodeDataPool.getCurrentItem().value.exact = value.exact;
                        m_nodeDataPool.getCurrentItem().value.scaled = value.scaled;

                        break;
                    end;
                end;
            end;
        end;

        return node;
    end;

    private macro addNode(name, rowKind, columnKind, value, level)
        var relation;
        var pos = index(name, CONSTANT);
        if (pos != 0)
            m_relationsPool.get(TNodeData().makeId("", rowKind, columnKind)).rhs.plus(value.scaled);
            name = substr(name, 1, pos-1) + substr(name, pos+strlen(CONSTANT));
            m_nodeDataPool.push_back(TNodeData(TNodeData().makeId(name, rowKind, columnKind), value));
            return;
        end;

        var id = TNodeData().makeId(name, rowKind, columnKind);

        var idx = null;
        var node = m_normalizer.node(id);
        var parent = m_normalizer.node(TNodeData().makeId(m_chapterData.fieldValue("balance").currentAsString, rowKind, columnKind));

        if (node == null)
//            var parent = m_normalizer.node(TNodeData().makeId(m_chapterData.fieldValue("balance").currentAsString, rowKind, columnKind));
            m_nodeDataPool.push_back(TNodeData(id, value));
            idx = m_nodeDataPool.getCount() - 1;

            node = m_normalizer.addNode(id);
            node.setLevel(nvl(level, nvl(getParentLevel(parent, id, level), 0) * 10));

            var priority;
            if (    TParameters().isEnableUserPriorityForChapter(m_chapter)
                and (compareStrWithMasks(TParameters().getUserPriority_0(m_chapter), name) == 0)
               )
                priority = 0;
            elif (    TParameters().isEnableUserPriorityForChapter(m_chapter)
                  and (compareStrWithMasks(TParameters().getUserPriority_100(m_chapter), name) == 0)
                 )
                priority = 100;
            else
                if (rowKind == TRowKind().TOTAL)
                    priority = 100;
                elif (rowKind == TRowKind().ROUBLE)
                    priority = 50;
                else
                    priority = 0;
                end;
            end;
            node.setUserPriority(priority);
        end;

        node = setNodeValue(node, value, idx);
        // Установка допустимой погрешности для точно округляемых остатков
        // Погрешность может быть изменена при построении дерева нормализации
        if (    m_isNormalizeExactlyRoundedRests
            and (   (columnKind == TColumnKind().PASSIVE_IN_REST)
                 or (columnKind == TColumnKind().PASSIVE_OUT_REST)
                 or (columnKind == TColumnKind().ACTIVE_IN_REST)
                 or (columnKind == TColumnKind().ACTIVE_OUT_REST)
                )
            and (mod(Double(node.getExact()), (m_multiplier * m_additionalMultiplier)) == 0.0)
            and (node.getExact() != $0)
           )
            node.setDef(1.0);
        end;

        relation = m_relationsPool.get(TNodeData().makeId("", rowKind, columnKind));
        if (parent != null)
            relation.rhs.plus(node);
        else
            relation.lhs.plus(node);
        end;

        return node;
    end;

    private macro addChapterTotalsNodes()
        var name = m_chapterData.fieldValue("balance").currentAsString;

        var tempNode = null;
        // 20.03.2014 ABP Плохо обращатся непосредственно к структурной переменной, минуя TBalanceAttribute.
        //                Еще хуже обращаться напрямую к полям структурной переменной.
        //                Однако иначе никак, TBalanceAtribute не работает с данными по главе.
        tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().PASSIVE_OUT_REST, m_chapterData.fieldValue("restPassive"),       4);
        if (tempNode != null)
            tempNode.setDef(0.5);
        end;
        addNode(name, TRowKind().ROUBLE,   TColumnKind().PASSIVE_OUT_REST, m_chapterData.fieldValue("restNatCurPassive"), 5);
        addNode(name, TRowKind().CURRENCY, TColumnKind().PASSIVE_OUT_REST, m_chapterData.fieldValue("restCurPassive"),    6);

        tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().ACTIVE_OUT_REST, m_chapterData.fieldValue("restActive"),       4);
        if (tempNode != null)
            tempNode.setDef(0.5);
        end;
        addNode(name, TRowKind().ROUBLE,   TColumnKind().ACTIVE_OUT_REST, m_chapterData.fieldValue("restNatCurActive"), 5);
        addNode(name, TRowKind().CURRENCY, TColumnKind().ACTIVE_OUT_REST, m_chapterData.fieldValue("restCurActive"),    6);

        if (not m_isPreviousDataExists)
            tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().PASSIVE_IN_REST, m_chapterData.fieldValue("restInPassive"),       1);
            if (tempNode != null)
                tempNode.setDef(0.5);
            end;
            addNode(name, TRowKind().ROUBLE,   TColumnKind().PASSIVE_IN_REST, m_chapterData.fieldValue("restInNatCurPassive"), 2);
            addNode(name, TRowKind().CURRENCY, TColumnKind().PASSIVE_IN_REST, m_chapterData.fieldValue("restInCurPassive"),    3);

            tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().ACTIVE_IN_REST, m_chapterData.fieldValue("restInActive"),       1);
            if (tempNode != null)
                tempNode.setDef(0.5);
            end;
            addNode(name, TRowKind().ROUBLE,   TColumnKind().ACTIVE_IN_REST, m_chapterData.fieldValue("restInNatCurActive"), 2);
            addNode(name, TRowKind().CURRENCY, TColumnKind().ACTIVE_IN_REST, m_chapterData.fieldValue("restInCurActive"),    3);
        end;

        var maximumError = TParameters().getMaximumChapterTurnsRoundingError(m_chapter);
        tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().PASSIVE_DEBET, m_passiveChapterTurns.debitTotal,   7);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().ROUBLE,   TColumnKind().PASSIVE_DEBET, m_passiveChapterTurns.debitRouble,  8);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().CURRENCY, TColumnKind().PASSIVE_DEBET, m_passiveChapterTurns.debitForeign, 9);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;

        tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().PASSIVE_CREDIT, m_passiveChapterTurns.creditTotal,   7);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().ROUBLE,   TColumnKind().PASSIVE_CREDIT, m_passiveChapterTurns.creditRouble,  8);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().CURRENCY, TColumnKind().PASSIVE_CREDIT, m_passiveChapterTurns.creditForeign, 9);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;

        tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().ACTIVE_DEBET, m_activeChapterTurns.debitTotal,   7);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().ROUBLE,   TColumnKind().ACTIVE_DEBET, m_activeChapterTurns.debitRouble,  8);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().CURRENCY, TColumnKind().ACTIVE_DEBET, m_activeChapterTurns.debitForeign, 9);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;

        tempNode = addNode(name, TRowKind().TOTAL,    TColumnKind().ACTIVE_CREDIT, m_activeChapterTurns.creditTotal,   7);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().ROUBLE,   TColumnKind().ACTIVE_CREDIT, m_activeChapterTurns.creditRouble,  8);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
        tempNode = addNode(name, TRowKind().CURRENCY, TColumnKind().ACTIVE_CREDIT, m_activeChapterTurns.creditForeign, 9);
        if (tempNode != null)
            tempNode.setDef(maximumError);
        end;
    end;

    private macro setRowConstraint(name, kind, rowKind)
        var relation = ReportLinearRelation(RCB_RS_EQUAL);

        var restInColumnKind;
        var restOutColumnKind;
        var debitColumnKind;
        var creditColumnKind;

        if (kind == KIND_PASSIVE)
            restInColumnKind = TColumnKind().PASSIVE_IN_REST;
            restOutColumnKind = TColumnKind().PASSIVE_OUT_REST;
            debitColumnKind = TColumnKind().PASSIVE_DEBET;
            creditColumnKind = TColumnKind().PASSIVE_CREDIT;
        else
            restInColumnKind = TColumnKind().ACTIVE_IN_REST;
            restOutColumnKind = TColumnKind().ACTIVE_OUT_REST;
            debitColumnKind = TColumnKind().ACTIVE_DEBET;
            creditColumnKind = TColumnKind().ACTIVE_CREDIT;
        end;

        var restInNode;
        if (m_isPreviousDataExists)
            var attributeValue = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE).getBalanceAttributeValue(m_chapter, name, restInColumnKind, rowKind);

            if (attributeValue == null)
                var fieldName = "";

                if ((kind == KIND_PASSIVE) and (rowKind == TRowKind().TOTAL))
                    fieldName = "restInPassive";
                elif ((kind == KIND_PASSIVE) and (rowKind == TRowKind().ROUBLE))
                    fieldName = "restInNatCurPassive";
                elif ((kind == KIND_PASSIVE) and (rowKind == TRowKind().CURRENCY))
                    fieldName = "restInCurPassive";
                elif ((kind == KIND_ACTIVE) and (rowKind == TRowKind().TOTAL))
                    fieldName = "restInActive";
                elif ((kind == KIND_ACTIVE) and (rowKind == TRowKind().ROUBLE))
                    fieldName = "restInNatCurActive";
                elif ((kind == KIND_ACTIVE) and (rowKind == TRowKind().CURRENCY))
                    fieldName = "restInCurActive";
                end;

                attributeValue = m_chapterData.fieldValue(fieldName);
            end;
            restInNode = attributeValue.scaled * m_additionalMultiplier;
        else
            restInNode = m_normalizer.node(TNodeData().makeId(name, rowKind, restInColumnKind));
        end;

        var restOutNode = m_normalizer.node(TNodeData().makeId(name, rowKind, restOutColumnKind));
        var debitNode = m_normalizer.node(TNodeData().makeId(name, rowKind, debitColumnKind));
        var creditNode = m_normalizer.node(TNodeData().makeId(name, rowKind, creditColumnKind));

        relation.rhs.plus(restOutNode);
        if (kind == KIND_PASSIVE)
            relation.lhs.plus(restInNode).minus(debitNode).plus(creditNode);
        else
            relation.lhs.plus(restInNode).plus(debitNode).minus(creditNode);
        end;

        m_normalizer.addRelation(relation);

        return this;
    end;

    private macro setComponentsConstraint(name, colunmKind)
        var relation = ReportLinearRelation(RCB_RS_EQUAL);

        var totalNode = m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, colunmKind));
        var roubleNode = m_normalizer.node(TNodeData().makeId(name, TRowKind().ROUBLE, colunmKind));
        var foreignNode = m_normalizer.node(TNodeData().makeId(name, TRowKind().CURRENCY, colunmKind));

        relation.lhs.plus(totalNode);
        relation.rhs.plus(roubleNode).plus(foreignNode);

        m_normalizer.addRelation(relation);

        return this;
    end;

    private macro excludeBalanceNodes(name, columnKind)
        if (    TParameters().isExcludeAccountsForChapter(m_chapter)
            and (compareStrWithMasks(TParameters().getExcludedAccountsTotal(m_chapter), name) == 0)
           )
            m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, columnKind)).setDef(0.5);
        elif (    TParameters().isExcludeAccountsForChapter(m_chapter)
              and (compareStrWithMasks(TParameters().getExcludedAccountsRouble(m_chapter), name) == 0)
             )
            m_normalizer.node(TNodeData().makeId(name, TRowKind().ROUBLE, columnKind)).setDef(0.5);
        elif (    TParameters().isExcludeAccountsForChapter(m_chapter)
              and (compareStrWithMasks(TParameters().getExcludedAccountsForeign(m_chapter), name) == 0)
             )
            m_normalizer.node(TNodeData().makeId(name, TRowKind().CURRENCY, columnKind)).setDef(0.5);
        end;
    end;

    private macro isZeroTurnsAccount(balanceIterator)
        return (    (abs(balanceIterator.getDebet().exact) <= MONEY_PRECISION)
                and (abs(balanceIterator.getDebetNatCur().exact) <= MONEY_PRECISION)
                and (abs(balanceIterator.getDebetCur().exact) <= MONEY_PRECISION)
                and (abs(balanceIterator.getCredit().exact) <= MONEY_PRECISION)
                and (abs(balanceIterator.getCreditNatCur().exact) <= MONEY_PRECISION)
                and (abs(balanceIterator.getCreditCur().exact) <= MONEY_PRECISION)
               );
    end;

    private macro isExcludeZeroTurnsAccount(balanceIterator)
        return (m_isPreviousDataExists and m_isExcludeZeroTurns);
    end;

    private macro addBalanceNodes(kind)
        private macro getMaximumError(value, maximumError)
            if (m_isNormalizeZeroTurns)
                return maximumError;
            end;

            if (value == $0)
                return 0.5;
            end;

            return maximumError;
        end;

        var hasNonZeroAccounts = false;

        var chapterName = m_chapterData.fieldValue("balance").currentAsString;
        var restOutColumnKind;
        var restInColumnKind;
        var debitColumnKind;
        var creditColumnKind;

        if (kind == KIND_PASSIVE)
            restOutColumnKind = TColumnKind().PASSIVE_OUT_REST;
            restInColumnKind = TColumnKind().PASSIVE_IN_REST;
            debitColumnKind = TColumnKind().PASSIVE_DEBET;
            creditColumnKind = TColumnKind().PASSIVE_CREDIT;
        else
            restOutColumnKind = TColumnKind().ACTIVE_OUT_REST;
            restInColumnKind = TColumnKind().ACTIVE_IN_REST;
            debitColumnKind = TColumnKind().ACTIVE_DEBET;
            creditColumnKind = TColumnKind().ACTIVE_CREDIT;
        end;

        var rowKindTotal = TRowKind().TOTAL;
        var rowKindRouble = TRowKind().ROUBLE;
        var rowKindForeign = TRowKind().CURRENCY;

        var maximumError = TParameters().getMaximumTurnsRoundingError(m_chapter);
        var it = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
//        it.createBalanceIterator(m_chapter, kind, false, true, false);
        it.createBalanceIterator(m_chapter, kind, false, false, false);
        while (it.next())
            if (    (abs(it.getOutRest().exact) <= MONEY_PRECISION)
                and (abs(it.getOutRestNatCur().exact ) <= MONEY_PRECISION)
                and (abs(it.getOutRestCur().exact ) <= MONEY_PRECISION)
                and (abs(it.getDebet().exact ) <= MONEY_PRECISION)
                and (abs(it.getDebetNatCur().exact ) <= MONEY_PRECISION)
                and (abs(it.getDebetCur().exact ) <= MONEY_PRECISION)
                and (abs(it.getCredit().exact ) <= MONEY_PRECISION)
                and (abs(it.getCreditNatCur().exact ) <= MONEY_PRECISION)
                and (abs(it.getCreditCur().exact ) <= MONEY_PRECISION)
                and (abs(it.getInRest().scaled ) <= MONEY_PRECISION)
                and (abs(it.getInRestNatCur().scaled ) <= MONEY_PRECISION)
                and (abs(it.getInRestCur().scaled ) <= MONEY_PRECISION)
               )
                continue;
            end;

            hasNonZeroAccounts = true;

            var tempNode = null;

            if (isZeroTurnsAccount(it) and m_isPreviousDataExists)
                it.getOutRest().scaled = it.getInRest().scaled * m_additionalMultiplier;
                it.getOutRestNatCur().scaled = it.getInRestNatCur().scaled * m_additionalMultiplier;
                it.getOutRestCur().scaled = it.getInRestCur().scaled * m_additionalMultiplier;

                if (isExcludeZeroTurnsAccount(it))
                    addNode(it.getBalance()+CONSTANT, rowKindTotal, restOutColumnKind, it.getOutRest());
                    addNode(it.getBalance()+CONSTANT, rowKindRouble, restOutColumnKind, it.getOutRestNatCur());
                    addNode(it.getBalance()+CONSTANT, rowKindForeign, restOutColumnKind, it.getOutRestCur());

                    continue;
                end;
            end;

            if (not m_isPreviousDataExists)
               addNode(it.getBalance(), rowKindTotal, restInColumnKind, it.getInRest());
               addNode(it.getBalance(), rowKindRouble, restInColumnKind, it.getInRestNatCur());
               addNode(it.getBalance(), rowKindForeign, restInColumnKind, it.getInRestCur());
            end;

            addNode(it.getBalance(), rowKindTotal, restOutColumnKind, it.getOutRest());
            addNode(it.getBalance(), rowKindRouble, restOutColumnKind, it.getOutRestNatCur());
            addNode(it.getBalance(), rowKindForeign, restOutColumnKind, it.getOutRestCur());

            tempNode = addNode(it.getBalance(), rowKindTotal, debitColumnKind, it.getDebet());
            if (tempNode != null)
                tempNode.setDef(getMaximumError(it.getDebet().exact, maximumError));
            end;
            tempNode = addNode(it.getBalance(), rowKindRouble, debitColumnKind, it.getDebetNatCur());
            if (tempNode != null)
                tempNode.setDef(getMaximumError(it.getDebetNatCur().exact, maximumError));
            end;
            tempNode = addNode(it.getBalance(), rowKindForeign, debitColumnKind, it.getDebetCur());
            if (tempNode != null)
                tempNode.setDef(getMaximumError(it.getDebetCur().exact, maximumError));
            end;

            tempNode = addNode(it.getBalance(), rowKindTotal, creditColumnKind, it.getCredit());
            if (tempNode != null)
                tempNode.setDef(getMaximumError(it.getCredit().exact, maximumError));
            end;
            tempNode = addNode(it.getBalance(), rowKindRouble, creditColumnKind, it.getCreditNatCur());
            if (tempNode != null)
                tempNode.setDef(getMaximumError(it.getCreditNatCur().exact, maximumError));
            end;
            tempNode = addNode(it.getBalance(), rowKindForeign, creditColumnKind, it.getCreditCur());
            if (tempNode != null)
                tempNode.setDef(getMaximumError(it.getCreditCur().exact, maximumError));
            end;

            ternary(kind == KIND_ACTIVE,
                    m_activeChapterTurns,
                    m_passiveChapterTurns).add(it.getDebet(),  it.getDebetNatCur(),  it.getDebetCur(),
                                               it.getCredit(), it.getCreditNatCur(), it.getCreditCur()
                                              );

            setRowConstraint(it.getBalance(), kind, rowKindTotal);
            setRowConstraint(it.getBalance(), kind, rowKindRouble);
            setRowConstraint(it.getBalance(), kind, rowKindForeign);

            if (not m_isPreviousDataExists)
                setComponentsConstraint(it.getBalance(), restInColumnKind);
            end;
            setComponentsConstraint(it.getBalance(), restOutColumnKind);
            setComponentsConstraint(it.getBalance(), debitColumnKind);
            setComponentsConstraint(it.getBalance(), creditColumnKind);

            // 03.06.2015 ABP Исключаются только исходящие остатки
            excludeBalanceNodes(it.getBalance(), restOutColumnKind);
        end;

        return hasNonZeroAccounts;
    end;

    private macro setChapterTotalsValues()
        var name = m_chapterData.fieldValue("balance").currentAsString;

        m_passiveChapterTurns.recalculateScaled();
        m_activeChapterTurns.recalculateScaled();

        setNodeValue(name, TRowKind().TOTAL,    TColumnKind().PASSIVE_DEBET, m_passiveChapterTurns.debitTotal  );
        setNodeValue(name, TRowKind().ROUBLE,   TColumnKind().PASSIVE_DEBET, m_passiveChapterTurns.debitRouble );
        setNodeValue(name, TRowKind().CURRENCY, TColumnKind().PASSIVE_DEBET, m_passiveChapterTurns.debitForeign);

        setNodeValue(name, TRowKind().TOTAL,    TColumnKind().PASSIVE_CREDIT, m_passiveChapterTurns.creditTotal  );
        setNodeValue(name, TRowKind().ROUBLE,   TColumnKind().PASSIVE_CREDIT, m_passiveChapterTurns.creditRouble );
        setNodeValue(name, TRowKind().CURRENCY, TColumnKind().PASSIVE_CREDIT, m_passiveChapterTurns.creditForeign);

        setNodeValue(name, TRowKind().TOTAL,    TColumnKind().ACTIVE_DEBET, m_activeChapterTurns.debitTotal  );
        setNodeValue(name, TRowKind().ROUBLE,   TColumnKind().ACTIVE_DEBET, m_activeChapterTurns.debitRouble );
        setNodeValue(name, TRowKind().CURRENCY, TColumnKind().ACTIVE_DEBET, m_activeChapterTurns.debitForeign);

        setNodeValue(name, TRowKind().TOTAL,    TColumnKind().ACTIVE_CREDIT, m_activeChapterTurns.creditTotal  );
        setNodeValue(name, TRowKind().ROUBLE,   TColumnKind().ACTIVE_CREDIT, m_activeChapterTurns.creditRouble );
        setNodeValue(name, TRowKind().CURRENCY, TColumnKind().ACTIVE_CREDIT, m_activeChapterTurns.creditForeign);
    end;

    private macro addTotalsConstraint()
        var relation = ReportLinearRelation(RCB_RS_EQUAL);
        var name = m_chapterData.fieldValue("balance").currentAsString;

        relation.lhs.plus(m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, TColumnKind.ACTIVE_DEBET)));
        relation.lhs.plus(m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, TColumnKind.PASSIVE_DEBET)));

        relation.rhs.plus(m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, TColumnKind.ACTIVE_CREDIT)));
        relation.rhs.plus(m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, TColumnKind.PASSIVE_CREDIT)));

        m_normalizer.addRelation(relation);

        return this;
    end;

    private macro setChapterTotalsRowConstraint(kind)
        var name = m_chapterData.fieldValue("balance").currentAsString;

        var restOutColumnKind;
        var restInColumnKind;
        var debitColumnKind;
        var creditColumnKind;

        if (kind == KIND_PASSIVE)
            restOutColumnKind = TColumnKind().PASSIVE_OUT_REST;
            restInColumnKind = TColumnKind().PASSIVE_IN_REST;
            debitColumnKind = TColumnKind().PASSIVE_DEBET;
            creditColumnKind = TColumnKind().PASSIVE_CREDIT;
        else
            restOutColumnKind = TColumnKind().ACTIVE_OUT_REST;
            restInColumnKind = TColumnKind().ACTIVE_IN_REST;
            debitColumnKind = TColumnKind().ACTIVE_DEBET;
            creditColumnKind = TColumnKind().ACTIVE_CREDIT;
        end;

        setRowConstraint(name, kind, TRowKind().TOTAL   );
        setRowConstraint(name, kind, TRowKind().ROUBLE  );
        setRowConstraint(name, kind, TRowKind().CURRENCY);

// 11.04.2014 ABP В ТЗ этих ограничений нет. Да и не всегда с ними нормализуется
//        if (not m_isPreviousDataExists)
//            setComponentsConstraint(name, restInColumnKind);
//        end;
//        setComponentsConstraint(name, restOutColumnKind);
//        setComponentsConstraint(name, debitColumnKind);
//        setComponentsConstraint(name, creditColumnKind);
    end;

    private macro addColumnConstraint()
        var rowKind = TRowKind().kindArray;
        var columnKind = TColumnKind().kindArray;
        var rowKindSize = rowKind.size;
        var columnKindSize = columnKind.size;

        var i = 0;
        while (i < columnKindSize)
            var j = 0;
            while (j < rowKindSize)
                var relation = m_relationsPool.get(TNodeData().makeId("", rowKind[j], columnKind[i]));
//println("rowKind = ", rowKind[j], "\t\t", "columnKind = ", columnKind[i], "\t\t", "relation = ", relation);
                if ((relation != null) and (toOEM(relation.toString(), true) != "Линейное отношение не задано"))
                    m_normalizer.addRelation(relation);
                end;
                j = j + 1;
            end;
            i = i + 1;
        end;
    end;

    private macro makeNormalizationTree()
        addChapterTotalsNodes();

        var hasNonZeroActiveAccounts = addBalanceNodes(KIND_ACTIVE);
        var hasNonZeroPassiveAccounts = addBalanceNodes(KIND_PASSIVE);

        m_hasNonZeroAccounts = hasNonZeroActiveAccounts or hasNonZeroPassiveAccounts;

        if (not m_hasNonZeroAccounts)
            return;
        end;

        addSpecialBalanceConstraints();

        setChapterTotalsValues();

        addTotalsConstraint();

// 11.04.2014 ABP С точки зрения математики нет необходимости в ограничении сходимости по строке для итогов главы.
//                Сходимость автоматически достигается при выполнении сходимости по строке для каждого б/с
//        setChapterTotalsRowConstraint(KIND_ACTIVE);
//        setChapterTotalsRowConstraint(KIND_PASSIVE);

        addColumnConstraint();
    end;

    private macro getScaledAsString(value)
        return String(Int(value));
    end;

    private macro saveNormalizedValues()
        m_nodeDataPool.moveFirst();
        while (m_nodeDataPool.moveNext())
            var node = m_normalizer.node(m_nodeDataPool.getCurrentItem().id);
            var normalized;

            if (node != null)
                normalized = node.getScaledInDoubleFormat() / m_additionalMultiplier;
            else
                normalized = m_nodeDataPool.getCurrentItem().value.scaled / m_additionalMultiplier;
            end;

            m_nodeDataPool.getCurrentItem().value.scaled = normalized;
        end;
    end;

    /**
     * Нормализация одной главы
     */
    macro execute()
        var contexts = RcbArray();
        contexts.push_back(TNormalizerContext("Нормализация остатков, округляемых с погрешностью", true, false, false));
        contexts.push_back(TNormalizerContext("Нормализация остатков, округляемых без погрешности", true, false, true));
        contexts.push_back(TNormalizerContext("Внимание! Режим отнесения погрешности на нулевые обороты", false, true, true));

        m_protocol.printDescription();

        m_protocol.printLine("┌──────────────────────────────────────────────────────────────────────────────────────────┐");
        m_protocol.printLine("│--------------------------------------ГЛАВА " + m_chapter + "---------------------------------------------│");
        m_protocol.printLine("└──────────────────────────────────────────────────────────────────────────────────────────┘");

        TParameters(true).printReport(m_protocol, m_chapter);
        m_protocol.printLine("");

        var isExistConflictingSetting = ExcludedAccountsController().isExistConflictingSetting(m_chapter, m_protocol,
                                                                                               getSqlString(TParameters().getExcludedAccountsRouble(m_chapter)),
                                                                                               getSqlString(TParameters().getExcludedAccountsForeign(m_chapter)),
                                                                                               getSqlString(TParameters().getExcludedAccountsTotal(m_chapter)),
                                                                                               ternary(TParameters().isExcludeAccounts(), 1, 0),
                                                                                               ternary(TParameters().isExcludeAccountsForChapter(m_chapter), 1, 0)
                                                                                              );
        m_protocol.printLine("");

        if (isExistConflictingSetting)
            return;
        end;

        m_protocol.printLine("НОРМАЛИЗАЦИЯ ГЛАВЫ " + m_chapter);

        var defaultChapterTurnsRoundingError = TParameters().getMaximumChapterTurnsRoundingError(m_chapter);
        var defaultTurnsRoundingError = TParameters().getMaximumTurnsRoundingError(m_chapter);

        var isNormalized = false;
        for (var context, contexts)
            var normalizerLogs = RcbArray();
            m_isExcludeZeroTurns = context.isExcludeZeroTurns;
            m_isNormalizeZeroTurns = context.isNormalizeZeroTurns;
            m_isNormalizeExactlyRoundedRests = context.isNormalizeExactlyRoundedRests;

            m_protocol.printLine("");
            m_protocol.printLine(context.caption);
            m_protocol.printLine(ternary(TParameters().isOptimalDecision(), "Поиск оптимального решения", "Поиск допустимого решения"));

            var delta = 0.1;
            var chapterTurnsRoundingError;
            var turnsRoundingError;

            if (NormalizationAlgorithm.getReportNormalizationAlgorithm() == JAVA_SM_NORMALIZER)
                chapterTurnsRoundingError = defaultChapterTurnsRoundingError;
            else
                chapterTurnsRoundingError = ternary(defaultChapterTurnsRoundingError < 0.5, defaultChapterTurnsRoundingError, 0.5);
            end;

            while (not isNormalized and (chapterTurnsRoundingError <= defaultChapterTurnsRoundingError))
                TParameters().setMaximumChapterTurnsRoundingError(chapterTurnsRoundingError, m_chapter);
                if (NormalizationAlgorithm.getReportNormalizationAlgorithm() == JAVA_SM_NORMALIZER)
                    turnsRoundingError = defaultTurnsRoundingError;
                else
                    turnsRoundingError = ternary(defaultTurnsRoundingError < 0.99999, defaultTurnsRoundingError, 0.99999);
                end;

                while (not isNormalized and (turnsRoundingError <= defaultTurnsRoundingError))
                    TParameters().setMaximumTurnsRoundingError(turnsRoundingError, m_chapter);

                    createAndInitializeNormalizer();
                    makeNormalizationTree();

                    if (m_hasNonZeroAccounts)
                        m_normalizer.normalize();
                        isNormalized = context.isNormalized = m_normalizer.isNormalized();

                        if (isNormalized)
                            saveNormalizedValues();

                            var checker = TBalanceChecker(m_chapter);
                            checker.execute(true, m_multiplier, m_precision);
                            isNormalized = isNormalized and (not checker.hasDifference());
                        end;
                    else
                        isNormalized = context.isNormalized = true;
                    end;

                    if (not isNormalized)
                        RcbApplication().transactionManager.rollback();
                        // 15.04.2014 ABP rollback некорректно восстанавливает значения переменных, поэтому требуется явно подчитывать из БД
                        //                После исправления убрать reload() и перенести инициализацию m_chapterData из createAndInitializeNormalizer()
                        //                в конструктор.
                        RcbApplication().currentReport.reload();
                        normalizerLogs.push_back(m_normalizer.getLogFilePath());
                    end;

                    turnsRoundingError = turnsRoundingError + delta;
                end;

                if (chapterTurnsRoundingError <= 0.5)
                    chapterTurnsRoundingError = 0.99999;
                else
                    chapterTurnsRoundingError = chapterTurnsRoundingError + delta;
                end;
            end;

            m_protocol.printLine("Количество узлов нормализации: " + getNodeCount());

            if (isNormalized)
                var normalizationDuaration = "";
                if (m_hasNonZeroAccounts)
                    normalizationDuaration = m_normalizer.getTimeNormalizationAsString();
                else
                    normalizationDuaration = "00:00:00:000";
                end;

                m_protocol.printLine("Нормализация выполнена успешно");
                m_protocol.printLine("\tлог-файл: " + m_normalizer.getLogFilePath());
                m_protocol.printLine("Время нормализации (мс): " + normalizationDuaration);
                TParameters().printFactReport(m_protocol, m_chapter);
                m_protocol.printHeadTable();

                m_nodeDataPool.moveFirst();
                while (m_nodeDataPool.moveNext())
                    var normalized;
                    var scaled;
                    var exact;

                    normalized = m_nodeDataPool.getCurrentItem().value.scaled;
                    scaled = TValue(m_nodeDataPool.getCurrentItem().value.exact, null, m_multiplier, m_precision).recalculateScaled().scaled;
                    exact = m_nodeDataPool.getCurrentItem().value.exact;

                    if (scaled != normalized)
                        var def = abs(exact / m_multiplier - normalized);
                        m_protocol.printString(toOEM(m_nodeDataPool.getCurrentItem().id, true),
                                               exact,
                                               getScaledAsString(scaled),
                                               getScaledAsString(normalized),
                                               String(def:0:5),
                                               ternary(def >= 1.0, "Внимание!!! Большая погрешность!", "")
                                              );
                    end;
                end;

                m_protocol.printBottomTable(m_chapter);
                m_protocol.printLine("");

                RcbApplication().transactionManager.commit();

                break;
            else
                m_protocol.printLine("Не удалось выполнить нормализацию, дополнительная информация в лог-файлах:");
                for (var it, normalizerLogs)
                    m_protocol.printLine("\t" + it);
                end;
            end;
        end;

        if (not isNormalized)
            m_protocol.printLine("");
            m_protocol.printLine("Рекомендуется воспользоваться алгоритмом нормализации без контроля погрешности.");
        end;
    end;

    constructorTNormalizerBase(chapter, multiplier, additionalMultiplier, precision);
end;

private class (TNormalizerBase) TNormalizerChapter1()
    private macro constructor()
        initTNormalizerBase(1);
    end;

    private macro addSpecialBalanceConstraints()
        return;
    end;

    constructor();
end;

private class (TNormalizerBase) TNormalizerChapter2()
    private macro constructor()
        initTNormalizerBase(2);
    end;

    private macro addSpecialBalanceConstraints()
        return;
    end;

    constructor();
end;

private class (TNormalizerBase) TNormalizerChapter3()
    private macro constructor()
        initTNormalizerBase(3);
    end;

    private macro isExcludeZeroTurnsAccount(balanceIterator)
        return false;
    end;

    private macro addSpecialBalanceConstraints()
        private macro add(offsettingAccountNumber, offsettingAccountColumnKind, iterator, iteratorColumnKind, excludedAccount)
            var chapterName = m_chapterData.fieldValue("balance").currentAsString;

            var relation = ReportLinearRelation(RCB_RS_EQUAL);
            var node = m_normalizer.node(TNodeData().makeId(offsettingAccountNumber, TRowKind().TOTAL, offsettingAccountColumnKind));

            if (node == null)
                return;
            end;

            relation.lhs.plus(node);

            while (iterator.next())
                if (iterator.getBalance() == excludedAccount)
                    continue;
                end;

                var lhsNode = m_normalizer.node(TNodeData().makeId(iterator.getBalance(), TRowKind().TOTAL, iteratorColumnKind));
                if (lhsNode != null)
                    relation.rhs.plus(lhsNode);
                end;
            end;

            m_normalizer.addRelation(relation);
        end;

        private macro add1(activeAccountNumber, passiveAccountNumber, iteratorActive, iteratorPassive)
            var chapterName = m_chapterData.fieldValue("balance").currentAsString;

            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            var nodeActive  = m_normalizer.node(TNodeData().makeId(activeAccountNumber, TRowKind().TOTAL, TColumnKind().ACTIVE_OUT_REST));
            var nodePassive = m_normalizer.node(TNodeData().makeId(passiveAccountNumber, TRowKind().TOTAL, TColumnKind().PASSIVE_OUT_REST));

            var activeSumRest  = 0.0;
            var passiveSumRest = 0.0;

            var activeSum  = 0.0;
            var passiveSum = 0.0;

            if ((nodeActive == null) or (nodePassive == null))
                return;
            end;

            relation.lhs.plus(nodeActive);
            relation.lhs.plus(nodePassive);

            var rhsNode = null;
            while (iteratorActive.next())
                if (iteratorActive.getBalance() == activeAccountNumber)
                    activeSum = iteratorActive.getValue().fieldValue("restActive").exact;

                    continue;
                end;

                rhsNode = m_normalizer.node(TNodeData().makeId(iteratorActive.getBalance(), TRowKind().TOTAL, TColumnKind().ACTIVE_OUT_REST));
                if (rhsNode != null)
                    relation.rhs.plus(rhsNode);
                end;

                activeSumRest = activeSumRest + iteratorActive.getValue().fieldValue("restActive").exact;
            end;

            while (iteratorPassive.next())
                if (iteratorPassive.getBalance() == passiveAccountNumber)
                    passiveSum = iteratorPassive.getValue().fieldValue("restPassive").exact;

                    continue;
                end;

                rhsNode = m_normalizer.node(TNodeData().makeId(iteratorPassive.getBalance(), TRowKind().TOTAL, TColumnKind().PASSIVE_OUT_REST));
                if (rhsNode != null)
                    relation.rhs.plus(rhsNode);
                end;

                passiveSumRest = passiveSumRest + iteratorPassive.getValue().fieldValue("restPassive").exact;
            end;

            if ((activeSumRest + passiveSumRest) == (activeSum + passiveSum))
                m_normalizer.addRelation(relation);
            end;
        end;

        var iterator;
        iterator = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
        iterator.createBalanceIterator(m_chapter, KIND_PASSIVE, false, true, false);
        add("99998", TColumnKind().ACTIVE_OUT_REST, iterator, TColumnKind().PASSIVE_OUT_REST, "99999");
        if (not m_isPreviousDataExists)
            iterator.rewind();
            add("99998", TColumnKind().ACTIVE_IN_REST, iterator, TColumnKind().PASSIVE_IN_REST, "99999");
        end;

        iterator = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
        iterator.createBalanceIterator(m_chapter, KIND_ACTIVE, false, true, false);
        add("99999", TColumnKind().PASSIVE_OUT_REST, iterator, TColumnKind().ACTIVE_OUT_REST, "99998");
        if (not m_isPreviousDataExists)
            iterator.rewind();
            add("99999", TColumnKind().PASSIVE_IN_REST, iterator, TColumnKind().ACTIVE_IN_REST, "99998");
        end;

        var iteratorActive  = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
        var iteratorPassive = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);

        iteratorActive.createBalanceIterator(m_chapter, KIND_ACTIVE, false, true, false);
        iteratorPassive.createBalanceIterator(m_chapter, KIND_PASSIVE, false, true, false);

        add1("99998", "99999", iteratorActive, iteratorPassive);
    end;

    constructor();
end;

private class (TNormalizerBase) TNormalizerChapter4()
    private macro constructor()
        initTNormalizerBase(4);
    end;

    private macro isExcludeZeroTurnsAccount(balanceIterator)
        return false;
    end;

    private macro addSpecialBalanceConstraints()
        private macro add(offsettingAccountNumber, offsettingAccountColumnKind, iterator, iteratorColumnKind, excludedAccount)
            var chapterName = m_chapterData.fieldValue("balance").currentAsString;

            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            var node = m_normalizer.node(TNodeData().makeId(offsettingAccountNumber, TRowKind().TOTAL, offsettingAccountColumnKind));

            if (node == null)
                return;
            end;

            relation.lhs.plus(node);

            while (iterator.next())
                if (iterator.getBalance() == excludedAccount)
                    continue;
                end;

                var lhsNode = m_normalizer.node(TNodeData().makeId(iterator.getBalance(), TRowKind().TOTAL, iteratorColumnKind));
                if (lhsNode != null)
                    relation.rhs.plus(lhsNode);
                end;
            end;

            m_normalizer.addRelation(relation);
        end;

        private macro add1(activeAccountNumber, passiveAccountNumber, iteratorActive, iteratorPassive)
            var chapterName = m_chapterData.fieldValue("balance").currentAsString;

            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            var nodeActive  = m_normalizer.node(TNodeData().makeId(activeAccountNumber, TRowKind().TOTAL, TColumnKind().ACTIVE_OUT_REST));
            var nodePassive = m_normalizer.node(TNodeData().makeId(passiveAccountNumber, TRowKind().TOTAL, TColumnKind().PASSIVE_OUT_REST));

            var activeSumRest  = 0.0;
            var passiveSumRest = 0.0;

            var activeSum  = 0.0;
            var passiveSum = 0.0;

            if ((nodeActive == null) or (nodePassive == null))
                return;
            end;

            relation.lhs.plus(nodeActive);
            relation.lhs.plus(nodePassive);

            var rhsNode = null;
            while (iteratorActive.next())
                if (iteratorActive.getBalance() == activeAccountNumber)
                    activeSum = iteratorActive.getValue().fieldValue("restActive").exact;

                    continue;
                end;

                rhsNode = m_normalizer.node(TNodeData().makeId(iteratorActive.getBalance(), TRowKind().TOTAL, TColumnKind().ACTIVE_OUT_REST));
                if (rhsNode != null)
                    relation.rhs.plus(rhsNode);
                end;

                activeSumRest = activeSumRest + iteratorActive.getValue().fieldValue("restActive").exact;
            end;

            while (iteratorPassive.next())
                if (iteratorPassive.getBalance() == passiveAccountNumber)
                    passiveSum = iteratorPassive.getValue().fieldValue("restPassive").exact;

                    continue;
                end;

                rhsNode = m_normalizer.node(TNodeData().makeId(iteratorPassive.getBalance(), TRowKind().TOTAL, TColumnKind().PASSIVE_OUT_REST));
                if (rhsNode != null)
                    relation.rhs.plus(rhsNode);
                end;

                passiveSumRest = passiveSumRest + iteratorPassive.getValue().fieldValue("restPassive").exact;
            end;

            if ((activeSumRest + passiveSumRest) == (activeSum + passiveSum))
                m_normalizer.addRelation(relation);
            end;
        end;

        if (balanceGlobal().getRcbReport().context.period.beginDate < RCB_I3107_DATE)
            return;
        end;

        var iterator;
        iterator = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
        iterator.createBalanceIterator(m_chapter, KIND_PASSIVE, false, true, false);
        add("99996", TColumnKind().ACTIVE_OUT_REST, iterator, TColumnKind().PASSIVE_OUT_REST, "99997");
        if ((not m_isPreviousDataExists) and (balanceGlobal().getRcbReport().previousPeriod.endDate >= RCB_I3107_DATE))
            iterator.rewind();
            add("99996", TColumnKind().ACTIVE_IN_REST, iterator, TColumnKind().PASSIVE_IN_REST, "99997");
        end;

        iterator = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
        iterator.createBalanceIterator(m_chapter, KIND_ACTIVE, false, true, false);
        add("99997", TColumnKind().PASSIVE_OUT_REST, iterator, TColumnKind().ACTIVE_OUT_REST, "99996");
        if ((not m_isPreviousDataExists) and (balanceGlobal().getRcbReport().previousPeriod.endDate >= RCB_I3107_DATE))
            iterator.rewind();
            add("99997", TColumnKind().PASSIVE_IN_REST, iterator, TColumnKind().ACTIVE_IN_REST, "99996");
        end;

        var iteratorActive  = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);
        var iteratorPassive = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode().MODIFY_FIELD_VALUE);

        iteratorActive.createBalanceIterator(m_chapter, KIND_ACTIVE, false, true, false);
        iteratorPassive.createBalanceIterator(m_chapter, KIND_PASSIVE, false, true, false);

        add1("99996", "99997", iteratorActive, iteratorPassive);
    end;

    constructor();
end;

private class (TNormalizerBase) TNormalizerChapter5()
    private macro constructor()
        initTNormalizerBase(5, 1, TParameters().getMultiplierForChapter5(), TParameters().getChapter5Precision());
    end;

    private macro getScaledAsString(value)
        return String(value:0:*,TParameters().getChapter5Precision());
    end;

    private macro addSpecialBalanceConstraints()
        return;
    end;

    private macro setRowConstraint(name, kind, rowKind)
        if (rowKind == TRowKind().TOTAL)
            return setRowConstraint(name, kind, rowKind);
        else
            return this;
        end;
    end;

    private macro setComponentsConstraint(name, colunmKind)
        return this;
    end;

    private macro addNode(name, rowKind, columnKind, value, level)
        if (rowKind == TRowKind().TOTAL)
            return addNode(name, rowKind, columnKind, value, level);
        else
            return null;
        end;
    end;

    private macro excludeBalanceNodes(name, columnKind)
        if (    TParameters().isExcludeAccountsForChapter(m_chapter)
            and (compareStrWithMasks(TParameters().getExcludedAccountsTotal(m_chapter), name) == 0)
           )
            m_normalizer.node(TNodeData().makeId(name, TRowKind().TOTAL, columnKind)).setDef(0.5);
        end;
    end;

    private macro setNodeValue(name, rowKind, columnKind, value, idx)
        if (   (valType(rowKind) == V_GENOBJ)
            or (rowKind == TRowKind().TOTAL)
           )
            return setNodeValue(name, rowKind, columnKind, value, idx);
        else
            return null;
        end;
    end;

    constructor();
end;

private class TController(chapter)
    private var m_chapter;

    private macro constructorTController(chapter)
        m_chapter = chapter;
    end;

    macro execute()
        if (m_chapter == 0)
            var i = 1;

            for(i, 1, TBalanceParameters().getChaptersCountForCalculate())
                var obj = genObject("TNormalizerChapter" + i);
                execMacro(r2m(obj, "execute"));
            end;
        elif (m_chapter == 1)
            TNormalizerChapter1().execute();
        elif (m_chapter == 2)
            TNormalizerChapter2().execute();
        elif (m_chapter == 3)
            TNormalizerChapter3().execute();
        elif (m_chapter == 4)
            TNormalizerChapter4().execute();
        elif (m_chapter == 5)
            TNormalizerChapter5().execute();
        end;
    end;

    constructorTController(chapter);
end;

// Выполненение нормализации
macro execute(chapter)
    TController(chapter).execute();
end;

УстановитьФлагВозврата(OK_MACRO_FLAG);
exit(1);
