/*
$Name:          balanceAlternativNormalizer.mac
$Module:        Регламентируемая отчетность
$Description:   Форма Балансовые счета. Альтернативный нормализатор
*/

import RcbClassLibInter;
import rcbCoreInter;
import rcbconst;
import cb_sql;
import lib_lang;
import ReportNormalizer;
import ReptCbInter;
import ReportLinearRelation;
import controlExcludedAccounts;
import RcbProtocolView;
import testLib;
import RcbClassLibInter;
import balanceAttribute;
import balanceNormalizerParameters;


private class globalClass
    var currentReport : RcbReport = balanceGlobal().getRcbReport();

    var previousReport : RcbReport = balanceGlobal().getPreviousReport();

    var variable = null;
end;

private var global = globalClass();

private var m_parameters = null;
private class (TNormalizerParametersBase) TParametersImpl()
    private var m_isEnableUserPriority;
    private var m_isEnableUserPriorityForChapter;
    private var m_userPriority_0;
    private var m_userPriority_100;

    private var m_isExcludeAccounts;
    private var m_isExcludeAccountsForChapter;
    private var m_excludedAccountsRouble;
    private var m_excludedAccountsForeign;
    private var m_excludedAccountsTotal;

    private var m_maximumSolvingDuration;

    private var m_maximumPermissibleDecisionsAmount;

    private var m_maximumError;
    private var m_maximumTurnsRoundingError;
    private var m_maximumChapterTurnsRoundingError;
    private var m_maximumErrorAccounts;

    private var m_multiplierForChapter5;

    private var m_chapterOutRestRoubleComponentError;
    private var m_chapterOutRestCurrencyComponentError;

    private var m_balanceAccountRestMaxError;
    private var m_balanceAccountTurnMaxError;

    macro isEnableUserPriority()
        return m_isEnableUserPriority;
    end;

    macro isEnableUserPriorityForChapter(chapter)
        return m_isEnableUserPriorityForChapter[chapter];
    end;

    macro getUserPriority_0(chapter)
        return m_userPriority_0[chapter];
    end;

    macro getUserPriority_100(chapter)
        return m_userPriority_100[chapter];
    end;

    macro isExcludeAccounts()
        return m_isExcludeAccounts;
    end;

    macro isExcludeAccountsForChapter(chapter)
        return m_isExcludeAccountsForChapter[chapter];
    end;

    macro getExcludedAccountsRouble(chapter)
        return m_excludedAccountsRouble[chapter];
    end;

    macro getExcludedAccountsForeign(chapter)
        return m_excludedAccountsForeign[chapter];
    end;

    macro getExcludedAccountsTotal(chapter)
        return m_excludedAccountsTotal[chapter];
    end;

    macro getMaximumError(chapter)
        return m_maximumError[chapter];
    end;

    macro getMaximumSolvingDuration()
        return m_maximumSolvingDuration;
    end;

    macro getMaximumPermissibleDecisionsAmount()
        return m_maximumPermissibleDecisionsAmount * 1000.0;
    end;

    macro getMaximumTurnsRoundingError(chapter)
        return m_maximumTurnsRoundingError[chapter];
    end;

    macro setMaximumTurnsRoundingError(value, chapter)
        m_maximumTurnsRoundingError[chapter] = value;
    end;

    macro getMaximumChapterTurnsRoundingError(chapter)
        return m_maximumChapterTurnsRoundingError[chapter];
    end;

    macro setMaximumChapterTurnsRoundingError(value, chapter)
        m_maximumChapterTurnsRoundingError[chapter] = value;
    end;

    macro getMaximumErrorAccounts(chapter)
        return m_maximumErrorAccounts[chapter];
    end;

    macro getChapter5Precision()
        return m_chapter5Precision;
    end;

    macro getMultiplierForChapter5()
        return m_multiplierForChapter5;
    end;

    macro shouldShowProtocol()
        return m_shouldShowProtocol;
    end;

    macro isOptimalDecision()
        return getMaximumPermissibleDecisionsAmount() == 0.0;
    end;

    macro getChapterOutRestRoubleComponentError(chapter)
        return m_chapterOutRestRoubleComponentError[chapter];
    end;

    macro getChapterOutRestCurrrencyComponentError(chapter)
        return m_chapterOutRestCurrencyComponentError[chapter];
    end;

    macro getBalanceAccountRestMaxError(chapter)
        return m_balanceAccountRestMaxError[chapter];
    end;

    macro getBalanceAccountTurnMaxError(chapter)
        return m_balanceAccountTurnMaxError[chapter];
    end;

    macro printReport(protocol, chapter)
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ВКЛЮЧИТЬ КОНТРОЛЬ ПОГРЕШНОСТИ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "/ПРИОРИТЕТ 0", "\tПРИОРИТЕТ 0"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "/ПРИОРИТЕТ 100", "\tПРИОРИТЕТ 100"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/РУБЛИ", "\tРУБЛИ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ВАЛЮТА", "\tВАЛЮТА"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ИТОГ", "\tИТОГ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ  ПОГРЕШНОСТЬ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ  ПОГРЕШНОСТЬ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНОЕ ВРЕМЯ РЕШЕНИЯ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ"));
        var recommendationNote = ternary((global.previousReport.normalizationAlgorithm != RCB_NA_MMB) and (global.previousReport.isCalculated()), " (рекомендуемое значение 5.0)", "");
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ") + recommendationNote);
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ"));
        printLine(protocol, getReportString("REPORT/FLOOR/НАСТРОЙКА ММБ/СЧЕТА С МАКС-НОЙ ПОГРЕШНОСТЬЮ/ГЛАВА " + chapter, "REPORT/FLOOR/НАСТРОЙКА ММБ/СЧЕТА С МАКС-НОЙ ПОГРЕШНОСТЬЮ"));
        printLine(protocol, getReportString("Погрешность для рублевой составляющей итогов по главе " + chapter, "Погрешность для рублевой составляющей итогов по главе"));
        printLine(protocol, getReportString("Погрешность для валютной составляющей итогов по главе " + chapter, "Погрешность для валютной составляющей итогов по главе"));
        printLine(protocol, getReportString("Максимальная погрешность для рублевой и валютной составляющей остатков б/с главы " + chapter, "Максимальная погрешность для рублевой и валютной составляющей остатков б/с"));
        printLine(protocol, getReportString("Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с главы " + chapter, "Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с"));

        if (chapter == 5)
            printLine(protocol, getReportString("REPTREG/REP_GROUPS/BALANCE_ACCOUNTS/ТОЧНОСТЬ ДЛЯ ГЛАВЫ Д"));
        end;
    end;

    private macro constructorTParametersImpl()
        initTNormalizerParametersBase("НАСТРОЙКИ_НОРМАЛИЗАТОРА_ММБ");

        var path : String = "";

        m_isEnableUserPriorityForChapter = RcbArray();
        m_userPriority_0 = RcbArray();
        m_userPriority_100 = RcbArray();
        m_isExcludeAccountsForChapter = RcbArray();
        m_excludedAccountsRouble = RcbArray();
        m_excludedAccountsForeign = RcbArray();
        m_excludedAccountsTotal = RcbArray();
        m_maximumError = RcbArray();
        m_maximumTurnsRoundingError = RcbArray();
        m_maximumChapterTurnsRoundingError = RcbArray();
        m_maximumErrorAccounts = RcbArray();

        path = "REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ";
        getValue(path, V_BOOL, m_isEnableUserPriority, false);
        var i;
        if (m_isEnableUserPriority)
            i = 1;
            while (i <= 5)
                path = path + "/ГЛАВА " + i;
                getValue(path, V_BOOL, m_isEnableUserPriorityForChapter[i], false);
                if (m_isEnableUserPriorityForChapter[i])
                    getValue(path + "/ПРИОРИТЕТ 0", V_STRING, m_userPriority_0[i], "");
                    getValue(path + "/ПРИОРИТЕТ 100", V_STRING, m_userPriority_100[i], "");
                    if ((m_userPriority_0[i] == "") and (m_userPriority_100[i] == ""))
                        m_isEnableUserPriorityForChapter[i] = false;
                    end;
                end;
                i = i +1;
            end;
        end;

        path = "REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА";
        getValue(path, V_BOOL, m_isExcludeAccounts, false);
        if (m_isExcludeAccounts)
            i = 1;
            while (i <= 5)
                path = path + "/ГЛАВА " + i;
                getValue(path, V_BOOL, m_isExcludeaccountsForChapter[i], false);
                if (m_isExcludeaccountsForChapter[i])
                    getValue(path + "/РУБЛИ", V_STRING, m_excludedAccountsRouble[i], "");
                    getValue(path + "/ВАЛЮТА", V_STRING, m_excludedAccountsForeign[i], "");
                    getValue(path + "/ИТОГ", V_STRING, m_excludedAccountsTotal[i], "");
                    if ((m_excludedAccountsRouble[i] == "") and (m_excludedAccountsForeign[i] == "") and (m_excludedAccountsTotal[i] == ""))
                        m_isExcludeaccountsForChapter[i] = false;
                    end;
                end;
                i = i +1;
            end;
        end;

        getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНОЕ ВРЕМЯ РЕШЕНИЯ", V_INTEGER, m_maximumSolvingDuration, 120);
        getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ", V_DOUBLE, m_maximumPermissibleDecisionsAmount, 50.0);

        i = 1;
        while (i <= 5)
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ  ПОГРЕШНОСТЬ/ГЛАВА " + i, V_DOUBLE, m_maximumError[i], 1.0);
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГР. ОКРУГЛ. ИТОГОВЫХ ОБОРОТОВ/ГЛАВА " + i, V_DOUBLE, m_maximumChapterTurnsRoundingError[i], 1.0);
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА " + i, V_DOUBLE, m_maximumTurnsRoundingError[i], 1.0);
            getValue("REPORT/FLOOR/НАСТРОЙКА ММБ/СЧЕТА С МАКС-НОЙ ПОГРЕШНОСТЬЮ/ГЛАВА " + i, V_STRING, m_maximumErrorAccounts[i], 1.0);
            i = i +1;
        end;

        _getRegistryValue("REPTREG/REP_GROUPS/BALANCE_ACCOUNTS/ТОЧНОСТЬ ДЛЯ ГЛАВЫ Д", V_INTEGER, m_chapter5Precision, 0);
        m_multiplierForChapter5 = int("1" + mkstr("0", m_chapter5Precision));

        m_chapterOutRestRoubleComponentError = RcbArray();
        m_chapterOutRestCurrencyComponentError = RcbArray();

        initializeParameterValue("Погрешность для рублевой составляющей итогов по главе 1", m_chapterOutRestRoubleComponentError[1], 1.5);
        initializeParameterValue("Погрешность для рублевой составляющей итогов по главе 2", m_chapterOutRestRoubleComponentError[2], 1.5);
        initializeParameterValue("Погрешность для рублевой составляющей итогов по главе 3", m_chapterOutRestRoubleComponentError[3], 1.5);
        initializeParameterValue("Погрешность для рублевой составляющей итогов по главе 4", m_chapterOutRestRoubleComponentError[4], 1.5);
        initializeParameterValue("Погрешность для рублевой составляющей итогов по главе 5", m_chapterOutRestRoubleComponentError[5], 1.5);

        initializeParameterValue("Погрешность для валютной составляющей итогов по главе 1", m_chapterOutRestCurrencyComponentError[1], 1.5);
        initializeParameterValue("Погрешность для валютной составляющей итогов по главе 2", m_chapterOutRestCurrencyComponentError[2], 1.5);
        initializeParameterValue("Погрешность для валютной составляющей итогов по главе 3", m_chapterOutRestCurrencyComponentError[3], 1.5);
        initializeParameterValue("Погрешность для валютной составляющей итогов по главе 4", m_chapterOutRestCurrencyComponentError[4], 1.5);
        initializeParameterValue("Погрешность для валютной составляющей итогов по главе 5", m_chapterOutRestCurrencyComponentError[5], 1.5);

        m_balanceAccountRestMaxError = RcbArray();
        m_balanceAccountTurnMaxError = RcbArray();

        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей остатков б/с главы 1", m_balanceAccountRestMaxError[1], 2.5);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей остатков б/с главы 2", m_balanceAccountRestMaxError[2], 2.5);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей остатков б/с главы 3", m_balanceAccountRestMaxError[3], 2.5);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей остатков б/с главы 4", m_balanceAccountRestMaxError[4], 2.5);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей остатков б/с главы 5", m_balanceAccountRestMaxError[5], 2.5);

        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с главы 1", m_balanceAccountTurnMaxError[1], 3.0);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с главы 2", m_balanceAccountTurnMaxError[2], 3.0);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с главы 3", m_balanceAccountTurnMaxError[3], 3.0);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с главы 4", m_balanceAccountTurnMaxError[4], 3.0);
        initializeParameterValue("Максимальная погрешность для рублевой и валютной составляющей оборотов по б/с главы 5", m_balanceAccountTurnMaxError[5], 3.0);
    end;

    constructorTParametersImpl();
end;

private macro TParameters()
    if (m_parameters == null)
        m_parameters = TParametersImpl();
    end;

    return m_parameters;
end;

private macro isBalanceWithoutFirstLevel(balanceNumber)
    return    (balanceNumber == "99996")
           or (balanceNumber == "99997")
           or (balanceNumber == "99998")
           or (balanceNumber == "99999");
end;

/**
 * Протокол.
 */
private class (TProtocolView) TBalanceProtocolView(description : String)
    private var m_table = CTableReport();

    initTProtocolView(description);

    macro constructor()
        m_table.addColumn("Код узла нормализации", 28);
        m_table.addColumn("Точное значение|в нац. валюте", 25);
        m_table.addColumn("Округленное значение|в тысячах");
        m_table.addColumn("Нормализованное значение|в тысячах");
        m_table.addColumn("Погрешность|в тысячах");
        m_table.addColumn("Предупреждение");
    end;

    macro printDescription()
        setProtocolOutput();
        printHead();
        resetProtocolOutput();
    end;

    macro printHeadTable(chapter : String)
        setProtocolOutput(true);
        m_table.printHead();
        resetProtocolOutput();
    end;

    macro printString(variableName, exactValue, oldValue, newValue, def, warning)
        setProtocolOutput(true);
        m_table.printStringTransferByWord(variableName, exactValue, oldValue, newValue, def, warning);
        resetProtocolOutput();
    end;

    macro printStringExt(str : String)
        setProtocolOutput(true);
        m_table.printStringExt(str, m_table.getAColumns().size);
        resetProtocolOutput();
    end;

    macro printSeparator(isTop : Bool)
        setProtocolOutput(true);
        m_table.printSeparatorExt(true, isTop, m_table.getAColumns().size);
        resetProtocolOutput();
    end;

    macro printBottomTable()
        setProtocolOutput(true);
        m_table.printBottom();
        resetProtocolOutput();
    end;

    macro printLine(str)
        setProtocolOutput(true);
        printLine(str);
        resetProtocolOutput();
    end;

    constructor();
end;

private class TColumnKind
    const ACTIVE_IN_REST   : String = "ActiveInRest";
    const PASSIVE_IN_REST  : String = "PassiveInRest";

    const DEBET            : String = "Debet";
    const CREDIT           : String = "Credit";

    const ACTIVE_DEBET     : String = "ActiveDebet";
    const ACTIVE_CREDIT    : String = "ActiveCredit";

    const PASSIVE_DEBET    : String = "PassiveDebet";
    const PASSIVE_CREDIT   : String = "PassiveCredit";

    const ACTIVE_OUT_REST  : String = "ActiveOutRest";
    const PASSIVE_OUT_REST : String = "PassiveOutRest";
end;

private class TRowKind
    const TOTAL    : String = "Total";
    const ROUBLE   : String = "Rouble";
    const CURRENCY : String = "Currency";
end;


private class TChapter(chapter : Integer)

    private var m_chapter = chapter;

    const COLUMN_KIND = TColumnKind();

    const ROW_KIND = TRowKind();

    macro getName() : String
        return "Chapter_" + m_chapter;
    end;

    macro getChapter() : Integer
        return m_chapter;
    end;

    macro isTerminalBalance(balanceNumber : String) : Bool
        if (balanceNumber == getName())
            return false;
        end;

        return true;
    end;

    macro getTopBalance(balanceNumber : String)

        if (balanceNumber == getName())
            return "Root";
        end;

        if ((strLen(balanceNumber) == 5) and not isBalanceWithoutFirstLevel(balanceNumber))
            return substr(balanceNumber, 1, 3);
        end;

        return getName();
    end;

end;

private class BalanceValue()
    private const ROW_KIND = TRowKind();

    private var m_rouble = 0.0;
    private var m_currency = 0.0;
    private var m_total = 0.0;

    macro plus(rowKind : String, value : Variant)
        if (rowKind == ROW_KIND.TOTAL)
            m_total = m_total + value;
        elif (rowKind == ROW_KIND.ROUBLE)
            m_rouble = m_rouble + value;
        elif (rowKind == ROW_KIND.CURRENCY)
            m_currency = m_currency + value;
        end;
        return this;
    end;

    macro get(rowKind : String)
        if (rowKind == ROW_KIND.TOTAL)
            return m_total;
        elif (rowKind == ROW_KIND.ROUBLE)
            return m_rouble;
        elif (rowKind == ROW_KIND.CURRENCY)
            return m_currency;
        end;
    end;
end;

private class Variable(chapter : Integer)
    private var m_report = global.currentReport;
    private var m_chapter = chapter;

    private var m_previousReport = global.previousReport;

    private const COLUMN_KIND = TColumnKind();

    private const ROW_KIND = TRowKind();

    private var m_attributeValue;
    private var m_previousReport_attributeValue;

    m_attributeValue  = TBalanceAttribute("БАЛАНС", m_report, TBalanceAttributeMode.MODIFY_FIELD_VALUE);
    m_previousReport_attributeValue  = TBalanceAttribute("БАЛАНС", m_previousReport, TBalanceAttributeMode.MODIFY_FIELD_VALUE);

    macro getBalanceValue(balanceNumber : String, columnKind : String, rowKind : String, isExact : Bool)
        var av;

        if ((columnKind == COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == COLUMN_KIND.PASSIVE_IN_REST))
            if (m_previousReport.isCalculated())
                av = TBalanceAttribute("БАЛАНС", m_previousReport, TBalanceAttributeMode.MODIFY_FIELD_VALUE).getBalanceAttributeValue(m_chapter, balanceNumber,
                                                                                            ternary(columnKind == COLUMN_KIND.ACTIVE_IN_REST,
                                                                                                                  COLUMN_KIND.ACTIVE_OUT_REST,
                                                                                                                  COLUMN_KIND.PASSIVE_OUT_REST), rowKind );

                if ((av == null) or (av.exact == null))
                    return $0.0;
                end;

                if(m_chapter == 5)
                    return ternary(isExact, av.exact, av.scaled) * TParameters().getMultiplierForChapter5();
                else
                    return ternary(isExact, av.exact, av.scaled);
                end;

            elif (columnKind == COLUMN_KIND.ACTIVE_IN_REST)
                return getBalanceValue(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, rowKind, isExact)
                     - getBalanceValue(balanceNumber, COLUMN_KIND.DEBET, rowKind, isExact)
                     + getBalanceValue(balanceNumber, COLUMN_KIND.CREDIT, rowKind, isExact);
            else
                return getBalanceValue(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, rowKind, isExact)
                     + getBalanceValue(balanceNumber, COLUMN_KIND.DEBET, rowKind, isExact)
                     - getBalanceValue(balanceNumber, COLUMN_KIND.CREDIT, rowKind, isExact);
            end;
        end;

        av = m_attributeValue.getBalanceAttributeValue(m_chapter, balanceNumber, columnKind, rowKind);

        if ((av == null) or (av.exact == null))
            return $0.0;
        end;

        if(m_chapter == 5)
            return ternary(isExact, av.exact, av.scaled) * TParameters().getMultiplierForChapter5();
        else
            return ternary(isExact, av.exact, av.scaled);
        end;

    end;

    macro getValue(balanceNumber : String, columnKind : String, rowKind : String)
        return m_attributeValue.getBalanceAttributeValue(m_chapter, balanceNumber, columnKind, rowKind );
    end;

    macro getExact(balanceNumber : String, columnKind : String, rowKind : String) : Money
        return getBalanceValue(balanceNumber, columnKind, rowKind, TRUE);
    end;

    macro getScaled(balanceNumber : String, columnKind : String, rowKind : String) : Double
        return getBalanceValue(balanceNumber, columnKind, rowKind, FALSE);
    end;


    macro recalculateScaled(balanceNumber : String, columnKind : String, rowKind : String)
        var av = getValue(balanceNumber, columnKind, rowKind);

        if (av == null)
            return;
        end;

        av.recalculateScaled();
    end;

    macro setExact(balanceNumber : String, columnKind : String, rowKind : String, value : Money)
        var av = getValue(balanceNumber, columnKind, rowKind);

        if (av == null)
            return;
        end;
        av.exact = value;
    end;

    macro setScaled(balanceNumber : String, columnKind : String, rowKind : String, value : Double)
        var av = getValue(balanceNumber, columnKind, rowKind);

        if (av == null)
            return;
        end;
        av.scaled = value;
    end;

end;

private class (ReportNormalizer) TBalanceChapterNormalizer(multipliyer : Double, chapter : Integer, isCalculateInRest : Bool)
    initReportNormalizer(multipliyer);
    var count = 0;

    private var m_chapterActiveInRestValue = BalanceValue();
    private var m_chapterPassiveInRestValue = BalanceValue();
    private var m_activeBalanceSet = TRcbSet();
    private var m_passiveBalanceSet = TRcbSet();



    private const COLUMN_KIND = TColumnKind();

    private const ROW_KIND = TRowKind();

    private var  m_report : RcbReport = global.currentReport;

    private var m_previousReport = global.previousReport;

    /**
     * Признак нормализации итоговых значений
     */
    private var m_isTotal = null;

    /**
     * Считать входящие остатки
     */
     var m_isCalculateInRest = isCalculateInRest;

    /**
     * Глава по каторой мы производим нормализацию.
     */
    private var m_chapter : TChapter = TChapter(chapter);

    /**
     * Последнее значенее группы для входящих остатков. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastGroupForInPutNodes = 3;
    /**
     * Последнее значенее группы для активных исходящих остатков и оборотов. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastGroupForOtherActiveNodes = 203;
    /**
     * Последнее значенее группы для пассивных исходящих остатков и оборотов. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastGroupForOtherPassiveNodes = 204;
    /**
     * Последнее значенее балансового счета первого порядка. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastFistBalance = "";
    /**
     * Дополнительные условия для счетов 99998 и 99999 главы 3
     */
    private var m_relationFor99998InputTotal;
    private var m_relationFor99999InputTotal;
    private var m_relationFor99998OutputTotal;
    private var m_relationFor99999OutputTotal;

    /**
     * Дополнительные условия для счетов 99996 и 99997 главы Г
     */
    private var m_relationFor99996InputTotal;
    private var m_relationFor99997InputTotal;
    private var m_relationFor99996OutputTotal;
    private var m_relationFor99997OutputTotal;

    global.variable = Variable(chapter);

    private macro addRelationsForLoroAccounts(accounts : TArray)
        for (var it, accounts)
            if ((it != null) and (toOEM(it.toString(), true) != "Линейное отношение не задано"))
                this.addRelation(it);
            end;
        end;
    end;

    private macro initRelationsForAccounts99998And99999(chapter : Integer)
        if (chapter == 3)
            m_relationFor99998InputTotal     = ReportLinearRelation(RCB_RS_EQUAL);
            m_relationFor99999InputTotal     = ReportLinearRelation(RCB_RS_EQUAL);
            m_relationFor99998OutputTotal    = ReportLinearRelation(RCB_RS_EQUAL);
            m_relationFor99999OutputTotal    = ReportLinearRelation(RCB_RS_EQUAL);
        end;
    end;

    macro addRelationsForLoroAccountsChapter3()
        var accounts = RcbArray().initialize(m_relationFor99998InputTotal,
                                             m_relationFor99999InputTotal,
                                             m_relationFor99998OutputTotal,
                                             m_relationFor99999OutputTotal
                                            );
        addRelationsForLoroAccounts(accounts);
    end;

    private macro initRelationsForAccounts99996And99997(chapter : Integer)
        if (chapter == 4)
            m_relationFor99996InputTotal = ReportLinearRelation(RCB_RS_EQUAL);
            m_relationFor99997InputTotal = ReportLinearRelation(RCB_RS_EQUAL);
            m_relationFor99996OutputTotal = ReportLinearRelation(RCB_RS_EQUAL);
            m_relationFor99997OutputTotal = ReportLinearRelation(RCB_RS_EQUAL);
        end;
    end;

    macro addRelationsForLoroAccountsChaper4()
        var accounts = RcbArray().initialize(m_relationFor99996OutputTotal, m_relationFor99997OutputTotal);

        // 10.02.2014 ABP Ограничение на входящие остатки действует только в тех периодах, где они уже есть
        if (global.currentReport.previousPeriod.endDate >= RCB_I3107_DATE)
            accounts.push_back(m_relationFor99996InputTotal);
            accounts.push_back(m_relationFor99997InputTotal);
        end;

        addRelationsForLoroAccounts(accounts);
    end;

    macro getIsTotal() : Bool
        return m_isTotal;
    end;

    macro setIsTotal(isTotal : Bool)
        m_isTotal = isTotal;
    end;



    macro getNodeName(balanceNumber : String, columnKind : String, rowKind : String)
        return balanceNumber + columnKind + rowKind;
    end;

    /**
     * Возвращает верхний логический узел, для заданного узла.
     */
    private macro getTopNode(balanceNumber : String, columnKind : String, rowKind : String)
        if (   (balanceNumber == m_chapter.getName())
            or (columnKind == m_chapter.COLUMN_KIND.DEBET)
            or (columnKind == m_chapter.COLUMN_KIND.CREDIT))
            return this.node(getNodeName(balanceNumber, columnKind, rowKind));
        end;

        return this.node(getNodeName(m_chapter.getName(), columnKind, rowKind));
    end;

    /**
     * Возвращает верхний уровень нормализации, для заданного узла.
     */
    private macro addTopNode(balanceNumber : String, columnKind : String, rowKind : String)
        if (   (balanceNumber == m_chapter.getName())
            or (columnKind == m_chapter.COLUMN_KIND.DEBET)
            or (columnKind == m_chapter.COLUMN_KIND.CREDIT))
            return this.addNode(getNodeName(balanceNumber, columnKind, rowKind));
        end;

        //Метод addNode не добавляет новый узел, если он уже содержится в нормализаторе.
        return this.addNode(getNodeName(m_chapter.getName(), columnKind, rowKind));
    end;

    macro getChapter()
        return m_chapter;
    end;

    macro getNode(balanceNumber : String, columnKind : String, rowKind : String) : Variant
        //Если предыдущий период рассчитан, то возвращаем константное значение входящего остатка умноженное на множитель
        if (not m_isCalculateInRest)
            if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST))
                var scaledValue = global.variable.getScaled(balanceNumber, columnKind, rowKind);
                var valueId = balanceNumber + rowKind;

                if (strLen(balanceNumber) == 5)
                    if (columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST)

                        if (not m_activeBalanceSet.find(valueId).isValid())
                            m_chapterActiveInRestValue.plus(rowKind, scaledValue);
                        end;
                        m_activeBalanceSet.insert(valueId);
                    elif (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST)

                        if (not m_passiveBalanceSet.find(valueId).isValid())
                            m_chapterPassiveInRestValue.plus(rowKind, scaledValue);
                        end;

                        m_passiveBalanceSet.insert(valueId);
                    end;
                elif (balanceNumber == m_chapter.getName())
                    if (columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST)
                        return m_chapterActiveInRestValue.get(rowKind);
                    elif (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST)
                        return m_chapterPassiveInRestValue.get(rowKind);
                    end;
                    return;
                end;

                return scaledValue;
            end;

        end;

        if (not getIsTotal() and (rowKind == m_chapter.ROW_KIND.TOTAL))
            return global.variable.getScaled(balanceNumber, columnKind, rowKind);
        end;


        var topNode = addTopNode(balanceNumber, columnKind, rowKind);
        var node;
        if (balanceNumber != getChapter().getName())
            node = topNode.addNode(getNodeName(balanceNumber, columnKind, rowKind));
        else
            node = topNode;
        end;

        return node;
    end;

    macro returnNode(balanceNumber : String, columnKind : String, rowKind : String)
        return this.node(getNodeName(balanceNumber, columnKind, rowKind));
    end;


    macro setNodeGroupAndPriority(balanceNumber : String, currentRecord, columnKind : String, rowKind : String)
        count = count + 1;
        var node = this.node(getNodeName(balanceNumber, columnKind, rowKind));

        var group;
        if (balanceNumber == m_chapter.getName())
            if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST))

                if (m_isCalculateInRest)
                    node.setGroup(0);
                    group = this.getGroup(0);

                    if(rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(100.0);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        node.setUserPriority(50.0);
                    else
                        node.setUserPriority(0.0);
                    end;
                end;
            elif ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST))
                if(rowKind == m_chapter.ROW_KIND.TOTAL)
                    node.setGroup(200);
                    node.setDef(0.5);
                    node.setUserPriority(100.0);
                elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                    node.setGroup(201);
                    node.setUserPriority(90.0);
                    group = this.getGroup(201);
                    group.setIsAdditionalCheck(true);
                    node.setDef(TParameters().getChapterOutRestRoubleComponentError(getChapter().getChapter()));
                else
                    node.setGroup(201);
                    node.setUserPriority(0.0);
                    node.setDef(TParameters().getChapterOutRestCurrencyComponentError(getChapter().getChapter()));
                end;
            else
                node.setDef(TParameters().getMaximumChapterTurnsRoundingError(getChapter().getChapter()));
                node.setGroup(202);
                group = this.getGroup(202);
                if (m_chapter.getChapter() == 1)
                    group.setIsSeparateOnSubgroups(true);
                    group.setIsOptimalDecision(false);
                    group.setMaxNumberOfDecision(int(TParameters().getMaximumPermissibleDecisionsAmount()));
                end;
                group.setIsAdditionalCheck(true);

                if (rowKind == m_chapter.ROW_KIND.TOTAL)
                    node.setUserPriority(100.0);
                elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                    node.setUserPriority(50.0);
                else
                    node.setUserPriority(0.0);
                end;
            end;

        elif (isBalanceWithoutFirstLevel(balanceNumber) or (m_chapter.getChapter() == 5))
            if (columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST)
                node.setGroup(1);

                group = this.getGroup(1);

                if (m_isCalculateInRest)
                    group.setIsOptimalDecision(false);
                    group.setMaxNumberOfDecision(int(TParameters().getMaximumPermissibleDecisionsAmount()));

                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            elif (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST)
                node.setGroup(2);

                group = this.getGroup(2);

                if (m_isCalculateInRest)
                    group.setIsOptimalDecision(false);
                    group.setMaxNumberOfDecision(int(TParameters().getMaximumPermissibleDecisionsAmount()));

                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            else
                node.setGroup(202);

                if ((columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST)or(columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST))
                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        if(currentRecord.isTotalExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        if(currentRecord.isRoubleExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);
                    else
                        if(currentRecord.isCurrencyExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);
                    end;
                else
                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
                node.setDef(TParameters().getChapterOutRestRoubleComponentError(getChapter().getChapter()));
            end;
        else
            if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST))

                if (m_lastFistBalance == "")
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                elif (subStr(balanceNumber, 1, 3) != m_lastFistBalance)
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                    m_lastGroupForInPutNodes = m_lastGroupForInPutNodes + 1;
                    m_lastGroupForOtherActiveNodes = m_lastGroupForOtherActiveNodes + 2;
                    m_lastGroupForOtherPassiveNodes = m_lastGroupForOtherPassiveNodes + 2;
                end;

                node.setGroup(m_lastGroupForInPutNodes);

                group = this.getGroup(m_lastGroupForInPutNodes);

                if (m_isCalculateInRest)
                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            else
                if (m_lastFistBalance == "")
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                elif (subStr(balanceNumber, 1, 3) != m_lastFistBalance)
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                    m_lastGroupForInPutNodes = m_lastGroupForInPutNodes + 1;
                    m_lastGroupForOtherActiveNodes = m_lastGroupForOtherActiveNodes + 2;
                    m_lastGroupForOtherPassiveNodes = m_lastGroupForOtherPassiveNodes + 2;
                end;

                if (    (columnKind == m_chapter.COLUMN_KIND.ACTIVE_DEBET) or (columnKind == m_chapter.COLUMN_KIND.ACTIVE_CREDIT)
                     or  (columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST))
                    node.setGroup(m_lastGroupForOtherActiveNodes);
                else
                    node.setGroup(m_lastGroupForOtherPassiveNodes);
                end;

                if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST))
                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        if(currentRecord.isTotalExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        if(currentRecord.isRoubleExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);
                    else
                        if(currentRecord.isCurrencyExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);
                    end;
                else
                    if (rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            end;
        end;

        if ((node != null) and (node.exact == 0.0) and (node.getDef() > 1.0))
            node.setDef(1.0);
        end;

    end;

    macro setNodeValue(currentRecord, columnKind : String, rowKind : String, exactValue : Money, scaledValue : Double)
        var node = getNode(currentRecord.balance, columnKind, rowKind);

        var value : Double = nvl(exactValue, 0.0);
        var topNode;

        if (   (columnKind == m_chapter.COLUMN_KIND.DEBET)
            or (columnKind == m_chapter.COLUMN_KIND.CREDIT))
            node.setExact(value);

            if (scaledValue == null)
                node.recalculateScaled();
            else
                node.setScaled(int(scaledValue));
            end;
        else
            topNode = getTopNode(currentRecord.balance, columnKind, rowKind);

            var def = topNode.getDef();

            if (currentRecord.balance != getChapter().getName())
                node.setExact(value);
            end;
            topNode.setExact(topNode.getExact() + double(value));

            if (scaledValue == null)
                node.recalculateScaled();
                topNode.recalculateScaled();
            else
                node.setScaled(int(scaledValue));
                topNode.setScaled(int(topNode.getScaledInDoubleFormat()) + int(scaledValue));
            end;

            topNode.setDef(def);
        end;

        if ((strLen(currentRecord.balance) == 3)and((columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST)))
            node.setDef(2.0);
        end;

        if ((    (columnKind == m_chapter.COLUMN_KIND.ACTIVE_DEBET) or (columnKind == m_chapter.COLUMN_KIND.ACTIVE_CREDIT)
              or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_DEBET) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_CREDIT)
              or (columnKind == m_chapter.COLUMN_KIND.DEBET) or (columnKind == m_chapter.COLUMN_KIND.CREDIT)))
            if(m_chapter.getChapter() == 1)
                node.setDef(TParameters().getMaximumTurnsRoundingError(1));
            elif(m_chapter.getChapter() == 2)
                node.setDef(TParameters().getMaximumTurnsRoundingError(2));
            elif(m_chapter.getChapter() == 3)
                node.setDef(TParameters().getMaximumTurnsRoundingError(3));
            elif(m_chapter.getChapter() == 4)
                node.setDef(TParameters().getMaximumTurnsRoundingError(4));
            elif(m_chapter.getChapter() == 5)
                node.setDef(TParameters().getMaximumTurnsRoundingError(5));
            end;
        end;

        setNodeGroupAndPriority(currentRecord.balance, currentRecord, columnKind, rowKind);
    end;
    /**
     * Добавляем ограничения по строке ВхОстаток = ИсхОстаток +/- Обороты.
     */
    private macro addRowConstraint(balanceNumber : String, kindAccount : String, rowKind : String)
        var activeInRestNode;
        var passiveInRestNode;

        var activeOutRestNode;
        var passiveOutRestNode;

        var activeDebetNode;
        var passiveDebetNode;

        var activeCreditNode;
        var passiveCreditNode;

        var debetNode;
        var creditNode;

        var relation1;
        var relation2;
        var relation3;
        var relation4;
        var relation5;

        if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))

            activeInRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST,  rowKind);
            passiveInRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, rowKind);

            activeOutRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST,  rowKind);
            passiveOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, rowKind);

            activeDebetNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET,  rowKind);
            passiveDebetNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, rowKind);

            activeCreditNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT,  rowKind);
            passiveCreditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, rowKind);

                relation1 = ReportLinearRelation(RCB_RS_EQUAL);
                relation1.lhs.plus(activeInRestNode).plus(activeDebetNode).minus(activeCreditNode);
                relation1.rhs.plus(activeOutRestNode);
                this.addRelation(relation1);

                relation2 = ReportLinearRelation(RCB_RS_EQUAL);
                relation2.lhs.plus(passiveInRestNode).plus(passiveCreditNode).minus(passiveDebetNode);
                relation2.rhs.plus(passiveOutRestNode);
                this.addRelation(relation2);

            if (kindAccount == "АП")
                debetNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.DEBET,  rowKind);
                creditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, rowKind);

                relation3 = ReportLinearRelation(RCB_RS_EQUAL);
                relation3.lhs.plus(activeDebetNode).plus(passiveDebetNode);
                relation3.rhs.plus(debetNode);
                this.addRelation(relation3);

                relation4 = ReportLinearRelation(RCB_RS_EQUAL);
                relation4.lhs.plus(activeCreditNode).plus(passiveCreditNode);
                relation4.rhs.plus(creditNode);
                this.addRelation(relation4);
            elif ((balanceNumber == m_chapter.getName()) and (rowKind == m_chapter.ROW_KIND.TOTAL))

                relation3 = ReportLinearRelation(RCB_RS_EQUAL);
                relation3.lhs.plus(passiveInRestNode);
                relation3.rhs.plus(activeInRestNode);
                this.addRelation(relation3);

                relation4 = ReportLinearRelation(RCB_RS_EQUAL);
                relation4.lhs.plus(activeOutRestNode);
                relation4.rhs.plus(passiveOutRestNode);
                this.addRelation(relation4);

                relation5 = ReportLinearRelation(RCB_RS_EQUAL);
                relation5.lhs.plus(activeDebetNode).plus(passiveDebetNode);
                relation5.rhs.plus(activeCreditNode).plus(passiveCreditNode);
                this.addRelation(relation5);
            end;

        elif (kindAccount == "А")
            activeInRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, rowKind);
            activeOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, rowKind);
            activeDebetNode   = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, rowKind);
            activeCreditNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, rowKind);

            relation1 = ReportLinearRelation(RCB_RS_EQUAL);

            if ((activeDebetNode.exact == 0.0) and (activeCreditNode.exact == 0.0))
                relation1.lhs.plus(activeInRestNode);
                activeOutRestNode.setDef(TParameters().getBalanceAccountRestMaxError(getChapter().getChapter()));
            else
                relation1.lhs.plus(activeInRestNode).plus(activeDebetNode).minus(activeCreditNode);
            end;
            relation1.rhs.plus(activeOutRestNode);


            this.addRelation(relation1);
        else
            passiveInRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, rowKind);
            passiveOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, rowKind);
            passiveDebetNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, rowKind);
            passiveCreditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, rowKind);

            relation2 = ReportLinearRelation(RCB_RS_EQUAL);

            if ((passiveCreditNode.exact == 0.0) and (passiveDebetNode.exact == 0.0))
                relation2.lhs.plus(passiveInRestNode);
                passiveOutRestNode.setDef(TParameters().getBalanceAccountRestMaxError(getChapter().getChapter()));
            else
                relation2.lhs.plus(passiveInRestNode).plus(passiveCreditNode).minus(passiveDebetNode);
            end;

            relation2.rhs.plus(passiveOutRestNode);

            this.addRelation(relation2);
        end;
    end;

    /**
     * Проверяем наличие счетов с равными остатками. Причем остатки должны округляться без погрешности.
     */
    private macro checkEqualRests(balanceNumber : String, kindAccount : String, rowKind : String)
        var activeInRestNode;
        var passiveInRestNode;

        var activeOutRestNode;
        var passiveOutRestNode;

        var activeDebetNode;
        var passiveDebetNode;

        var activeCreditNode;
        var passiveCreditNode;

        if (not m_isCalculateInRest)
            return;
        end;


        if (kindAccount == "А")
            activeInRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, rowKind);
            activeOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, rowKind);
            activeDebetNode   = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, rowKind);
            activeCreditNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, rowKind);

            if ((activeInRestNode.getExact() == activeOutRestNode.getExact()) and (activeOutRestNode.getDef() == 0.5))
                activeDebetNode.setGroup(202);
                activeCreditNode.setGroup(202);
            end;
        elif (kindAccount == "П")
            passiveInRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, rowKind);
            passiveOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, rowKind);
            passiveDebetNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, rowKind);
            passiveCreditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, rowKind);

            if ((passiveInRestNode.getExact() == passiveOutRestNode.getExact()) and (passiveOutRestNode.getDef() == 0.5))
                passiveDebetNode.setGroup(202);
                passiveCreditNode.setGroup(202);
            end;
        end;
    end;

     /**
     * Добавляем ограничения, по итогам Рубли + Валюта = Итог.
     */
    private macro addTotalConstraints(balanceNumber : String, columnKind : String)
        var totalNode    = getNode(balanceNumber, columnKind, m_chapter.ROW_KIND.TOTAL);
        var roubleNode   = getNode(balanceNumber, columnKind, m_chapter.ROW_KIND.ROUBLE);
        var currencyNode = getNode(balanceNumber, columnKind, m_chapter.ROW_KIND.CURRENCY);

        var relation = ReportLinearRelation(RCB_RS_EQUAL);

        relation.lhs.plus(roubleNode).plus(currencyNode);
        relation.rhs.plus(totalNode);
        this.addRelation(relation);

        if (not in(valType(totalNode), V_MONEY, V_DOUBLE))
            totalNode.exclude();
        end;
    end;
    /**
     * Добавляем ограничения для корреспонденских счетов 99998 и 99999 главы В.
     */
    private macro addConstraintForLoroAccount(balanceNumber : String, kindAccount : String)
        var inRestNodeTotal;
        var inRestNodeCurrency;
        var inRestNodeRouble;

        var outRestNodeTotal;
        var outRestNodeCurrency;
        var outRestNodeRouble;

        if (kindAccount == "А")
            inRestNodeTotal      = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL);
            outRestNodeTotal     = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL);
        elif (kindAccount == "П")
            inRestNodeTotal      = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL);
            outRestNodeTotal     = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL);
        end;

        if (balanceNumber == "99998")
            m_relationFor99998InputTotal.lhs.plus(inRestNodeTotal);
            m_relationFor99998OutputTotal.lhs.plus(outRestNodeTotal);
        elif (balanceNumber == "99999")
            m_relationFor99999InputTotal.lhs.plus(inRestNodeTotal);
            m_relationFor99999OutputTotal.lhs.plus(outRestNodeTotal);
        elif (kindAccount == "А")
            m_relationFor99999InputTotal.rhs.plus(inRestNodeTotal);
            m_relationFor99999OutputTotal.rhs.plus(outRestNodeTotal);
        elif (kindAccount == "П")
            m_relationFor99998InputTotal.rhs.plus(inRestNodeTotal);
            m_relationFor99998OutputTotal.rhs.plus(outRestNodeTotal);
        end;
    end;

    /**
     * Добавляем ограничения для корреспонденских счетов 99996 и 99997 главы Г.
     */
    private macro addConstraintForLoroAccountChapter4(balanceNumber : String, kindAccount : String)
        var inRestNodeTotal;
        var inRestNodeCurrency;
        var inRestNodeRouble;

        var outRestNodeTotal;
        var outRestNodeCurrency;
        var outRestNodeRouble;

        if (kindAccount == "А")
            inRestNodeTotal      = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL);
            outRestNodeTotal     = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL);
        elif (kindAccount == "П")
            inRestNodeTotal      = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL);
            outRestNodeTotal     = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL);
        end;

        if (balanceNumber == "99996")
            m_relationFor99996InputTotal.lhs.plus(inRestNodeTotal);
            m_relationFor99996OutputTotal.lhs.plus(outRestNodeTotal);
        elif (balanceNumber == "99997")
            m_relationFor99997InputTotal.lhs.plus(inRestNodeTotal);
            m_relationFor99997OutputTotal.lhs.plus(outRestNodeTotal);
        elif (kindAccount == "А")
            m_relationFor99997InputTotal.rhs.plus(inRestNodeTotal);
            m_relationFor99997OutputTotal.rhs.plus(outRestNodeTotal);
        elif (kindAccount == "П")
            m_relationFor99996InputTotal.rhs.plus(inRestNodeTotal);
            m_relationFor99996OutputTotal.rhs.plus(outRestNodeTotal);
        end;
    end;

    /**
     * Добавляем ограничения.
     */
    macro addBalance(balanceNumber : String, kindAccount : String)

        if (getIsTotal())
            addRowConstraint(balanceNumber, kindAccount, m_chapter.ROW_KIND.TOTAL);
        else
            if (getChapter().getChapter() != 5)
                addRowConstraint(balanceNumber, kindAccount, m_chapter.ROW_KIND.ROUBLE);
                addRowConstraint(balanceNumber, kindAccount, m_chapter.ROW_KIND.CURRENCY);

                if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST);
                elif (kindAccount == "А")
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST);
                else
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST);
                end;

                if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET);

                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT);

                    if (kindAccount == "АП")
                        addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.CREDIT);
                        addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.DEBET);
                    end;
                elif (kindAccount == "А")
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT);
                else
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT);
                end;

                if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST);
                elif (kindAccount == "А")
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST);
                else
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST);
                end;
            end;
        end;

        if (strLen(balanceNumber) == 5)
            if (getIsTotal())
                checkEqualRests(balanceNumber, kindAccount, m_chapter.ROW_KIND.TOTAL);

                if (m_chapter.getChapter() == 3)
                    addConstraintForLoroAccount(balanceNumber, kindAccount);
                end;

                if (m_chapter.getChapter() == 4)
                    addConstraintForLoroAccountChapter4(balanceNumber, kindAccount);
                end;
            else
                checkEqualRests(balanceNumber, kindAccount, m_chapter.ROW_KIND.ROUBLE);
                checkEqualRests(balanceNumber, kindAccount, m_chapter.ROW_KIND.CURRENCY);
            end;
        end;

    end;

    /**
     * Устанавливаем уровени для каждой вершины данног счета.
     */

    macro setLevelForNode(balanceNumber : String, kindAccount : String)
        var node;

        if((strLen(balanceNumber) == 3) or isBalanceWithoutFirstLevel(balanceNumber) or (m_chapter.getChapter() == 5))
            if (kindAccount == "А")
                if (m_isCalculateInRest)

                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));
                        node.setLevel(3);
                    else
                        if (getChapter().getChapter() != 5)
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));
                            node.setLevel(8);
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));
                            node.setLevel(13);
                        end;
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(23);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(28);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(33);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;
            elif(kindAccount == "П")
                if (m_isCalculateInRest)

                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));
                        node.setLevel(3);
                    else
                        if (getChapter().getChapter() != 5)
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));
                            node.setLevel(8);
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));
                            node.setLevel(13);
                        end;
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(23);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(28);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(33);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;
            elif(kindAccount == "АП")
                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));
                        node.setLevel(3);
                    else
                        if (getChapter().getChapter() != 5)
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));
                            node.setLevel(8);
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));
                            node.setLevel(13);
                        end;
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(23);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(28);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(33);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));
                        node.setLevel(3);
                    else
                        if (getChapter().getChapter() != 5)
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));
                            node.setLevel(8);
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));
                            node.setLevel(13);
                        end;
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(23);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(28);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(33);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(53);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(58);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(63);
                    end;
                end;
            end;
        elif (strLen(balanceNumber) == 5)
            if (kindAccount == "А")
                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));
                        node.setLevel(83);
                    else
                        if (getChapter().getChapter() != 5)
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));
                            node.setLevel(88);
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));
                            node.setLevel(93);
                        end;
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(103);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(108);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(113);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(133);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(138);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(143);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(133);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(138);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(143);
                    end;
                end;
            elif(kindAccount == "П")
                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));
                        node.setLevel(83);
                    else
                        if (getChapter().getChapter() != 5)
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));
                            node.setLevel(88);
                            node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));
                            node.setLevel(93);
                        end;
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(103);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(108);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(113);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(133);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(138);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(143);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));
                    node.setLevel(133);
                else
                    if (getChapter().getChapter() != 5)
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));
                        node.setLevel(138);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));
                        node.setLevel(143);
                    end;
                end;
            end;
        end;
    end;

    macro addAdditionalConstraints(balanceNumber : String, kindAccount : String)
        /***********************************************************************************************************************
        * Перед проведением нормализации определяются счета, нормализация которых производится по особым правилам.             *
        * К таким счетам относятся счета, для которых одновременно выполняются два условия:                                    *
        *    Одна из составляющих исходящего остатка (рубли или валюта) нулевая,                                               *
        *    Обороты по ненулевой составляющей исходящего остатка нулевые.                                                     *
        *                                                                                                                      *
        * Из этих условий следует, что сумма итогового исходящего остатка должна быть равна сумме ненулевой составляющей       *
        * исходящего остатка и равна этой же составляющей входящего остатка. Отсюда следует, что независимо от того с какой    *
        * погрешностью было получено рассматриваемое значение составляющей входящего остатка, такое же значение присваивается  *
        * итоговому исходящему остатку и это значение фиксируется. Надо понимать, что на втором этапе это же значение получит  *
        * ненулевая  составляющая итогового исходящего.                                                                        *
        ************************************************************************************************************************/

        macro addConstraint(node : Object, value : Double, sign : Integer)
            var relation = ReportLinearRelation(nvl(sign, RCB_RS_EQUAL));

            relation.lhs.plus(node);
            relation.rhs.plus(value);

            this.addRelation(relation);
        end;

        //Если предыдущий не расчитан, то выходим, так как входящие остатки можно корректировать
        if (not m_previousReport.isCalculated())
            return;
        end;


        var outRestKind = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST);

        var debetKind   = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.COLUMN_KIND.ACTIVE_DEBET);

        var creditKind  = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.COLUMN_KIND.ACTIVE_CREDIT);

        var inRestKind  = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.COLUMN_KIND.ACTIVE_IN_REST);

        var totalOutRestNode = this.node(getNodeName(balanceNumber, outRestKind, m_chapter.ROW_KIND.TOTAL));

        //При нулевых значениях итогового значения, состовляющие по рублям и валюте будут тоже нулевыми
        if (totalOutRestNode.exact == $0.0)
           return;
        end;

        var roubleOutRestExactValue    = global.variable.getExact(balanceNumber, outRestKind, m_chapter.ROW_KIND.ROUBLE);
        var roubleOutRestScaledValue   = global.variable.getScaled(balanceNumber, outRestKind, m_chapter.ROW_KIND.ROUBLE);

        var currencyOutRestExactValue  = global.variable.getExact(balanceNumber, outRestKind, m_chapter.ROW_KIND.CURRENCY);
        var currencyOutRestScaledValue = global.variable.getScaled(balanceNumber, outRestKind, m_chapter.ROW_KIND.CURRENCY);

        //Если рублевая и валютная составляющая отличны от нуля, то это тоже не наш случай
        if ((roubleOutRestExactValue != 0) and (currencyOutRestExactValue != 0))
            return;
        end;

        var roubleDebetExactValue    = global.variable.getExact(balanceNumber, debetKind, m_chapter.ROW_KIND.ROUBLE);
        var roubleDebetScaledValue   = global.variable.getScaled(balanceNumber, debetKind, m_chapter.ROW_KIND.ROUBLE);

        var currencyDebetExactValue  = global.variable.getExact(balanceNumber, debetKind, m_chapter.ROW_KIND.CURRENCY);
        var currencyDebetScaledValue = global.variable.getScaled(balanceNumber, debetKind, m_chapter.ROW_KIND.CURRENCY);


        var roubleCreditExactValue    = global.variable.getExact(balanceNumber, creditKind, m_chapter.ROW_KIND.ROUBLE);
        var roubleCreditScaledValue   = global.variable.getScaled(balanceNumber, creditKind, m_chapter.ROW_KIND.ROUBLE);

        var currencyCreditExactValue  = global.variable.getExact(balanceNumber, creditKind, m_chapter.ROW_KIND.CURRENCY);
        var currencyCreditScaledValue = global.variable.getScaled(balanceNumber, creditKind, m_chapter.ROW_KIND.CURRENCY);

        //Если по одной из составляющих все значения нулевые, то значения оставшейся составляющей будет полностью равно итоговой
        if (   ((roubleOutRestExactValue == 0.0) and (roubleCreditExactValue == 0.0) and (roubleDebetExactValue == 0.0))
            or
               ((currencyOutRestExactValue == 0.0) and (currencyCreditExactValue == 0.0) and (currencyDebetExactValue == 0.0)))

            return;
        end;

        var roubleInRestScaledValue = global.variable.getScaled(balanceNumber, inRestKind, m_chapter.ROW_KIND.ROUBLE);
        var currencyInRestScaledValue = global.variable.getScaled(balanceNumber, inRestKind, m_chapter.ROW_KIND.CURRENCY);

        var totalDebetNode  = this.node(getNodeName(balanceNumber, debetKind, m_chapter.ROW_KIND.TOTAL));
        var totalCreditNode = this.node(getNodeName(balanceNumber, creditKind, m_chapter.ROW_KIND.TOTAL));

        if ((roubleOutRestExactValue != 0.0) and (roubleCreditExactValue == 0.0) and (roubleDebetExactValue == 0.0))
            addConstraint(totalOutRestNode, roubleInRestScaledValue);

            totalOutRestNode.setDef(TParameters().getBalanceAccountRestMaxError(getChapter().getChapter()));
            totalCreditNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
            totalDebetNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
        end;

        if ((currencyOutRestExactValue != 0.0) and (currencyCreditExactValue == 0.0) and (currencyDebetExactValue == 0.0))
            addConstraint(totalOutRestNode, currencyInRestScaledValue);

            totalOutRestNode.setDef(TParameters().getBalanceAccountRestMaxError(getChapter().getChapter()));
            totalCreditNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
            totalDebetNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
        end;

        /***********************************************************************************************************************
        *  второй особый случай, т.е. еще одну поверку для нормализации по особым правилам.                                    *
        *    К таким счетам относятся счета, для которых одновременно выполняются два условия:                                 *
        *       Одна из составляющих исходящего остатка (рубли или валюта) нулевая, во входящем остатке эта составляющая       *
        *      ненулевая.                                                                                                      *
        *       Один из оборотов по этой составляющей нулевой, а во втором вторая составляющая - нулевая (т.е. в одном         *
        *      обороте одна составляющая нулевая, а во втором обороте - другая)                                                *
        *                                                                                                                      *
        *  Из этих условий следует, что сумма итогового оборота (в котором ненулевой оборот по рассматриваемой нами            *
        *  составляющей) должна быть равна сумме ненулевой составляющей входящего остатка и сумме ненулевой составляющей       *
        *  по этому же обороту.  Соответственно, вторая составляющая должна остаться нулевой.                                  *
        *                                                                                                                      *
        ************************************************************************************************************************/

        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue == 0) and (currencyCreditExactValue != 0) and (roubleCreditExactValue == 0))
            addConstraint(totalCreditNode, currencyInRestScaledValue);
            totalDebetNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
        end;

        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue != 0) and (currencyCreditExactValue == 0) and (roubleDebetExactValue == 0))
            addConstraint(totalDebetNode, currencyInRestScaledValue);
            totalCreditNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue == 0) and (roubleCreditExactValue != 0) and (currencyCreditExactValue == 0))
            addConstraint(totalCreditNode, roubleInRestScaledValue);
            totalDebetNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue != 0) and (roubleCreditExactValue == 0) and (currencyDebetExactValue == 0))
            addConstraint(totalDebetNode, roubleInRestScaledValue);
            totalCreditNode.setDef(TParameters().getBalanceAccountTurnMaxError(getChapter().getChapter()));
        end;
        /***********************************************************************************************************************
        *
        * Третий особый случай. Определяем счета, для которых одновременно выполняются два условия:
        * Одна из составляющих исходящего остатка (рубли или валюта) нулевая, во входящем остатке эта составляющая ненулевая.
        * Один из оборотов по этой составляющей нулевой, вторая составляющая по этому обороту ненулевая.
        *
        * Сумма  ненулевой составляющей  оборота  должна быть равна сумме ненулевой составляющей входящего остатка по этой же составляющей.
        * Но, поскольку при выполнении первого этапа нормализуются только итоговые значения, то задать в качестве константы значение
        * для составляющей невозможно, поэтому  условие, налагаемое на первый этап, будет следующим:
        * сумма итогового оборота (того, в котором ненулевая составляющая рассматриваемого счета) должна быть больше или равна сумме
        * составляющей входящего остатка.
        *
        * Условие равенства составляющей входящего остатка и составляющей оборота будет выполнено автоматически на втором этапе,
        * т.к. исходящая составляющая и составляющая второго оборота нулевые.
        *
        * пятую проверку в if добавил от себя, чтобы не трогать уже обработанные вторым особым случаем счета
        *************************************************************************************************************************/
        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue == 0) and (currencyCreditExactValue != 0) and (roubleCreditExactValue != 0))
            addConstraint(totalCreditNode, currencyInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;

        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue != 0) and (currencyCreditExactValue == 0) and (roubleDebetExactValue != 0))
            addConstraint(totalDebetNode, currencyInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue == 0) and (roubleCreditExactValue != 0) and (currencyCreditExactValue != 0))
            addConstraint(totalCreditNode, roubleInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue != 0) and (roubleCreditExactValue == 0) and (currencyDebetExactValue != 0))
            addConstraint(totalDebetNode, roubleInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;
    end;

    initRelationsForAccounts99998And99999(chapter);
    initRelationsForAccounts99996And99997(chapter);
end;

private class TNormalizeBalanceController(chapter, isRecalculateIfNotNormalized)

    private var  m_report : RcbReport = global.currentReport;

    private var m_previousReport = global.previousReport;

    private const COLUMN_KIND = TColumnKind();

    private const ROW_KIND = TRowKind();

    private var m_protocolView;

    private var m_normalizer;

    /**
     Данная переменная показывает какие главы необходимо нормализовать
     0 - все главы
     1 - 1 глава
     2 - 2 глава
     3 - 3 глава
     4 - 4 глава
     5 - 5 глава
    */
    private var  m_chapter = chapter;

    /**
        Данная переменная показывает текущую главу, по которой происходит нормализация
     */
    private var  m_currentChapter;

    private var m_isRecalculateIfNotNormalized = nvl(isRecalculateIfNotNormalized, false);

    private macro initProtocolView(chapter);
        m_protocolView = TBalanceProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ " + String(chapter) + " ГЛАВЫ");
    end;

    class BalanceInfo(chapter : Integer, balanceNumber : String, kindAccount: String, record_ : Object)

        private var m_balanceNumber = balanceNumber;
        private var m_kindAccount = kindAccount;
        private var m_record = record_;
        private var m_chapter = chapter;

        macro getRecord()
            return m_record;
        end;

        macro getChapter()
            return m_chapter;
        end;

        macro getBalanceNumber()
            return m_balanceNumber;
        end;

        macro getKindAccount()
            return m_kindAccount;
        end;
    end;

    private macro loadValue(currentRecord : Object, columnKind : String)
        if ((columnKind == COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == COLUMN_KIND.PASSIVE_IN_REST))

            if (m_previousReport.isCalculated())

                return;
            end;

        end;

        if (m_normalizer.getIsTotal())
            if (   (columnKind == COLUMN_KIND.DEBET)
                or (columnKind == COLUMN_KIND.CREDIT)
                or (currentRecord.balance != m_normalizer.getChapter().getName())
               )
                m_normalizer.setNodeValue(currentRecord,
                                        columnKind,
                                        ROW_KIND.TOTAL,
                                        global.variable.getExact(currentRecord.balance, columnKind, ROW_KIND.TOTAL));
            else
                m_normalizer.setNodeValue(currentRecord,
                                        columnKind,
                                        ROW_KIND.TOTAL,
                                        $0.0);
            end;
        else
            if (m_normalizer.getChapter().getChapter() != 5)
                if (   (columnKind == COLUMN_KIND.DEBET)
                    or (columnKind == COLUMN_KIND.CREDIT)
                    or (currentRecord.balance != m_normalizer.getChapter().getName())
                   )
                    m_normalizer.setNodeValue(currentRecord,
                                            columnKind,
                                            ROW_KIND.ROUBLE,
                                            global.variable.getExact(currentRecord.balance, columnKind, ROW_KIND.ROUBLE));

                    m_normalizer.setNodeValue(currentRecord,
                                            columnKind,
                                            ROW_KIND.CURRENCY,
                                            global.variable.getExact(currentRecord.balance, columnKind, ROW_KIND.CURRENCY));
                else
                    m_normalizer.setNodeValue(currentRecord,
                                            columnKind,
                                            ROW_KIND.ROUBLE,
                                            $0.0);

                    m_normalizer.setNodeValue(currentRecord,
                                            columnKind,
                                            ROW_KIND.CURRENCY,
                                            $0.0);
                end;
            end;
        end;
    end;

    private macro loadBalance(currentRecord)

        if (currentRecord.kindAccount == "А")
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_IN_REST);
        elif (currentRecord.kindAccount == "П")
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_IN_REST);
        else
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_IN_REST);
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_IN_REST);
        end;

        if (currentRecord.kindAccount == "А")
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_DEBET);
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_CREDIT);
        elif (currentRecord.kindAccount == "П")
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_DEBET);
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_CREDIT);
        else
            loadValue(currentRecord, COLUMN_KIND.DEBET);
            loadValue(currentRecord, COLUMN_KIND.CREDIT);

            loadValue(currentRecord, COLUMN_KIND.ACTIVE_DEBET);
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_CREDIT);

            loadValue(currentRecord, COLUMN_KIND.PASSIVE_DEBET);
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_CREDIT);
        end;

        if (currentRecord.kindAccount == "А")
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_OUT_REST);


        elif (currentRecord.kindAccount == "П")
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_OUT_REST);

        else
            loadValue(currentRecord, COLUMN_KIND.ACTIVE_OUT_REST);
            loadValue(currentRecord, COLUMN_KIND.PASSIVE_OUT_REST);
        end;

        m_normalizer.addBalance(currentRecord.balance, currentRecord.kindAccount);
        m_normalizer.setLevelForNode(currentRecord.balance, currentRecord.kindAccount);

        // 27.07.2015 ABP В главе Д ненулевой может быть только итоговая составляющая, поэтому
        //                все спец. ограничения не имеют смысла для этой главы
        if (m_normalizer.getChapter().getChapter() != 5)
            m_normalizer.addAdditionalConstraints(currentRecord.balance, currentRecord.kindAccount);
        end;

    end;

    private macro recalculateValue(balanceNumber : String, columnKind : String, rowKind : String)
        var exactValue;

        if(m_currentChapter == 5)
            exactValue = global.variable.getExact(balanceNumber, columnKind, rowKind);
            global.variable.setScaled(balanceNumber, columnKind, rowKind, floor(exactValue) / TParameters().getMultiplierForChapter5());
        else
            global.variable.recalculateScaled(balanceNumber, columnKind, rowKind);
        end;
    end;

    private macro returnStr(value)
        return execExp("String(value:0:" + TParameters().getChapter5Precision() + ")");
    end;

    private macro setMaxError(currentRecord : Object)

        var node = null;

        if (currentRecord.kindAccount == "П")
            node = m_normalizer.returnNode(currentRecord.balance, COLUMN_KIND.PASSIVE_OUT_REST, ROW_KIND.TOTAL);
        else
            node = m_normalizer.returnNode(currentRecord.balance, COLUMN_KIND.ACTIVE_OUT_REST, ROW_KIND.TOTAL);
        end;

        if (node.exact != $0.0)
            if (currentRecord.maxErrorValue != null)
                node.setDef(currentRecord.maxErrorValue);
            end;
        end;
    end;


    private macro saveValue(balanceNumber : String, kindAccount : String, columnKind : String, rowKind : String)

        var name = balanceNumber + columnKind + rowKind;

        var av = global.variable.getValue(balanceNumber, columnKind, rowKind );

        if (av == null)
            return;
        end;

        var node = null;

        if ((columnKind == COLUMN_KIND.DEBET) and m_normalizer.getIsTotal())
            if (kindAccount == "А")
                node = m_normalizer.returnNode(balanceNumber, COLUMN_KIND.ACTIVE_DEBET, rowKind);
            elif(kindAccount == "П")
                node = m_normalizer.returnNode(balanceNumber, COLUMN_KIND.PASSIVE_DEBET, rowKind);
            else
                node = m_normalizer.returnNode(balanceNumber, columnKind, rowKind);
            end;
        elif ((columnKind == COLUMN_KIND.CREDIT) and m_normalizer.getIsTotal())
            if (kindAccount == "А")
                node = m_normalizer.returnNode(balanceNumber, COLUMN_KIND.ACTIVE_CREDIT, rowKind);
            elif(kindAccount == "П")
                node = m_normalizer.returnNode(balanceNumber, COLUMN_KIND.PASSIVE_CREDIT, rowKind);
            else
                node = m_normalizer.returnNode(balanceNumber, columnKind, rowKind);
            end;
        else
            node = m_normalizer.returnNode(balanceNumber, columnKind, rowKind);
        end;

        var exact = av.exact;
        var scaled;
        var normalized;
        var avIn;

        if(m_currentChapter == 5)
            scaled = double(floor(av.exact * TParameters().getMultiplierForChapter5()));
            av.scaled = scaled/TParameters().getMultiplierForChapter5();
        else
            av.recalculateScaled();
            scaled = av.scaled;
        end;

        if (node != null)
            normalized = node.getScaledInDoubleFormat();
        else
            normalized = scaled;
        end;


        if (scaled != normalized)

            var warning : STRING = "Внимание!!! Большая погрешность!";

            if(m_currentChapter == 5)
                av.scaled = normalized / TParameters().getMultiplierForChapter5();

                var def = abs (exact - av.scaled);

                if (def < 1.)
                    warning = "";
                end;


                m_protocolView.printString(name,
                                           exact,
                                           string(floor(exact * TParameters().getMultiplierForChapter5())/TParameters().getMultiplierForChapter5()),
                                           returnStr(av.scaled),
                                           string(def:0:5),
                                           warning
                                          );
            else
                def = abs (exact/1000 - normalized);

                if (def < 1.)
                    warning = "";
                end;

                av.scaled = normalized;
                m_protocolView.printString(name,
                                           exact,
                                           string((exact/1000):30:0:l),
                                           string(normalized:30:0:l),
                                           string(def:0:5),
                                           warning);
            end;


        end;
    end;

    private macro saveColumn(balanceNumber : String, kindAccount : String, columnKind : String)
        if (m_normalizer.getIsTotal())
            if(m_normalizer.isNormalized())
                saveValue(balanceNumber, kindAccount, columnKind, ROW_KIND.TOTAL);
            else
                recalculateValue(balanceNumber, columnKind, ROW_KIND.TOTAL);

                if (m_normalizer.getChapter().getChapter() != 5)
                    recalculateValue(balanceNumber, columnKind, ROW_KIND.ROUBLE);
                    recalculateValue(balanceNumber, columnKind, ROW_KIND.CURRENCY);
                end;
            end;
        else
            if (m_normalizer.getChapter().getChapter() != 5)
                if(m_normalizer.isNormalized())
                    saveValue(balanceNumber, kindAccount, columnKind, ROW_KIND.ROUBLE);
                    saveValue(balanceNumber, kindAccount, columnKind, ROW_KIND.CURRENCY);
                else
                    recalculateValue(balanceNumber, columnKind, ROW_KIND.ROUBLE);
                    recalculateValue(balanceNumber, columnKind, ROW_KIND.CURRENCY);
                end;
            end;
        end;
    end;

    private macro saveBalance(balInfo : BalanceInfo)

        if (balInfo.getKindAccount() == "А")
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.ACTIVE_IN_REST);
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.ACTIVE_OUT_REST);
        elif (balInfo.getKindAccount() == "П")
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.PASSIVE_IN_REST);
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.PASSIVE_OUT_REST);
        else
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.ACTIVE_IN_REST);
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.PASSIVE_IN_REST);

            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.ACTIVE_OUT_REST);
            saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.PASSIVE_OUT_REST);
        end;

        saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.DEBET);
        saveColumn(balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.CREDIT);
    end;

    private macro isExistsBalanceData(balanceNumber : String, kindAccount: String ) : Bool
        var inRestA   = $0.0;
        var outRestA  = $0.0;
        var inRestP   = $0.0;;
        var outRestP  = $0.0;;
        var debet     = $0.0;;
        var credit    = $0.0;;

        if (kindAccount == "А")
            inRestA  = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST,  ROW_KIND.TOTAL);
            outRestA = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, ROW_KIND.TOTAL);
        elif (kindAccount == "П")
            inRestP  = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST,  ROW_KIND.TOTAL);
            outRestP = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, ROW_KIND.TOTAL);
        else
            inRestA  = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST,  ROW_KIND.TOTAL);
            outRestA = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, ROW_KIND.TOTAL);

            inRestP  = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST,  ROW_KIND.TOTAL);
            outRestP = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, ROW_KIND.TOTAL);
        end;

        debet  = global.variable.getExact(balanceNumber, COLUMN_KIND.DEBET,  ROW_KIND.TOTAL);
        credit = global.variable.getExact(balanceNumber, COLUMN_KIND.CREDIT, ROW_KIND.TOTAL);

        if (   (inRestA != $0.0)
            or (outRestA != $0.0)
            or (inRestP != $0.0)
            or (outRestP != $0.0)
            or (debet != $0.0)
            or (credit != $0.0))
            return true;
        end;

        return false;
    end;

    private macro loadOneBalance(balInfo : BalanceInfo)

        macro loadRow(balanceNumber : String, columnKind : String, rowKind : String)

            if (m_previousReport.isCalculated() and in(columnKind, COLUMN_KIND.PASSIVE_IN_REST, COLUMN_KIND.ACTIVE_IN_REST))
                return;
            end;

            var node = m_normalizer.addNode(m_normalizer.getNodeName(balanceNumber, columnKind, rowKind));

            node.setExact(global.variable.getExact(balanceNumber, columnKind, rowKind));
            node.recalculateScaled();

            if (in(columnKind, COLUMN_KIND.PASSIVE_IN_REST, COLUMN_KIND.ACTIVE_IN_REST, COLUMN_KIND.PASSIVE_OUT_REST, COLUMN_KIND.ACTIVE_OUT_REST))
                node.setDef(TParameters().getBalanceAccountRestMaxError(balInfo.getChapter()));
            else
                node.setDef(TParameters().getBalanceAccountTurnMaxError(balInfo.getChapter()));
            end;

            if ((node != null) and (node.exact == 0.0) and (node.getDef() > 1.0))
                node.setDef(0.5);
            end;

        end;

        macro loadColumn(balanceNumber : String, columnKind : String)
            loadRow(balanceNumber, columnKind, ROW_KIND.ROUBLE);
            loadRow(balanceNumber, columnKind, ROW_KIND.CURRENCY);
        end;

        macro setRowConstraint(balInfo : BalanceInfo, rowKind : String)

            var inRestNode  = null;
            var outRestNode = null;
            var debetNode   = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, rowKind));
            var creditNode  = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, rowKind));

            macro setUserPriority(node : @Variant, priority : Integer, level : Integer)
                const MAX_USER_PRIORITY = 100;

                if (not in(ValType(node), V_DOUBLE, V_MONEY))

                    node.setUserPriority(priority);

                    node.setLevel(level);

                    if ((node.exact == 0.0) and (node.getDef() > 1.0))
                        node.setUserPriority(1);
                    end;
                end;
            end;

            if (m_previousReport.isCalculated())
                if (balInfo.getKindAccount() == "П")
                    inRestNode = global.variable.getScaled(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_IN_REST, rowKind);
                else
                    inRestNode = global.variable.getScaled(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_IN_REST, rowKind);
                end;
            else
                if (balInfo.getKindAccount() == "П")
                    inRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_IN_REST, rowKind));
                else
                    inRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_IN_REST, rowKind));
                end;
            end;

            if (balInfo.getKindAccount() == "П")
                outRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_OUT_REST, rowKind));
            else
                outRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_OUT_REST, rowKind));
            end;

//Расстановка приоритетов отнесения погрешности

            IF (rowKind == ROW_KIND.ROUBLE)
                setUserPriority(@inRestNode,  100, 1);
                setUserPriority(@outRestNode, 100, 1);

                setUserPriority(@debetNode,  5, 5000);
                setUserPriority(@creditNode, 5, 5000);
            else
                setUserPriority(@inRestNode, 90, 100);
                setUserPriority(@outRestNode,90, 100);

                setUserPriority(@debetNode,  1, 50000);
                setUserPriority(@creditNode, 1, 50000);
            end;

//Добавляем ограничения на итоги
            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            if (balInfo.getKindAccount() == "П")
                relation.lhs.plus(inRestNode).minus(debetNode).plus(creditNode);
                relation.rhs.plus(outRestNode);
            else
                relation.lhs.plus(inRestNode).plus(debetNode).minus(creditNode);
                relation.rhs.plus(outRestNode);
            end;

            m_normalizer.addRelation(relation);
        end;

        macro setTotalConstraint(balanceNumber : String, columnKind : String)
            var rouble   = null;
            var currency = null;
            var total    = global.variable.getScaled(balInfo.getBalanceNumber(), columnKind, ROW_KIND.TOTAL);

            if (m_previousReport.isCalculated() and in(columnKind, COLUMN_KIND.PASSIVE_IN_REST, COLUMN_KIND.ACTIVE_IN_REST))
                rouble   = global.variable.getScaled(balInfo.getBalanceNumber(), columnKind, ROW_KIND.ROUBLE);
                currency = global.variable.getScaled(balInfo.getBalanceNumber(), columnKind, ROW_KIND.CURRENCY);
            else
                rouble   = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), columnKind, ROW_KIND.ROUBLE));
                currency = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), columnKind, ROW_KIND.CURRENCY));
            end;


            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            relation.lhs.plus(rouble).plus(currency);
            relation.rhs.plus(total);

            m_normalizer.addRelation(relation);
        end;

        macro excludeBalance(balInfo : BalanceInfo, isRouble : Bool)
            var rowKind = ternary(isRouble, ROW_KIND.ROUBLE, ROW_KIND.CURRENCY);

            if (ternary(isRouble, balInfo.getRecord().isRoubleExcluded, balInfo.getRecord().isCurrencyExcluded))
                if (not m_previousReport.isCalculated())
                    if (balInfo.getKindAccount() == "П")
                        m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_IN_REST, rowKind)).setDef(0.5);
                    else
                        m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_IN_REST, rowKind)).setDef(0.5);
                    end;
                end;

                if (balInfo.getKindAccount() == "П")
                    m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_OUT_REST, rowKind)).setDef(0.5);
                else
                    m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_OUT_REST, rowKind)).setDef(0.5);
                end;
            end;
        end;

        var balanceNumber = balInfo.getBalanceNumber();
//Загружаем данные баланса

        if (not m_previousReport.isCalculated())
            if (balInfo.getKindAccount() == "П")
                loadColumn(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST);
            else
                loadColumn(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST);
            end;
        end;

        loadColumn(balanceNumber, COLUMN_KIND.DEBET);
        loadColumn(balanceNumber, COLUMN_KIND.CREDIT);

        if (balInfo.getKindAccount() == "П")
            loadColumn(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST);
        else
            loadColumn(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST);
        end;

//Задаем ограничения по строке

        setRowConstraint(balInfo, ROW_KIND.ROUBLE);
        setRowConstraint(balInfo, ROW_KIND.CURRENCY);

//Задаем ограничения по итогам

        if (balInfo.getKindAccount() == "П")
            setTotalConstraint(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST);
        else
            setTotalConstraint(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST);
        end;

        setTotalConstraint(balanceNumber, COLUMN_KIND.DEBET);
        setTotalConstraint(balanceNumber, COLUMN_KIND.CREDIT);

        if (balInfo.getKindAccount() == "П")
            setTotalConstraint(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST);
        else
            setTotalConstraint(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST);
        end;

//Задаем счета исключения для входящих и исходящих остатков

        excludeBalance(balInfo, true);
        excludeBalance(balInfo, false);
    end;

    private macro isZeroTurns(balInfo : BalanceInfo) : Bool
        var isZero = false;
        var roubleDedetNode    = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.ROUBLE));
        var currencyDedetNode  = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.CURRENCY));
        var roubleCreditNode   = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.ROUBLE));
        var currencyCreditNode = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.CURRENCY));

        if ((roubleDedetNode.exact == 0.0) and (roubleCreditNode.exact == 0.0))
            isZero = true;
        end;

        if ((currencyDedetNode.exact == 0.0) and (currencyCreditNode.exact == 0.0))
            isZero = true;
        end;

        return isZero;
    end;

    private macro setCorrectZeroValue(balInfo : BalanceInfo)
        var roubleDedetNode    = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.ROUBLE));
        var currencyDedetNode  = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.CURRENCY));
        var roubleCreditNode   = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.ROUBLE));
        var currencyCreditNode = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.CURRENCY));

        if ((roubleDedetNode.exact == 0.0) and (roubleCreditNode.exact == 0.0))
            roubleDedetNode.setDef(1.);
            roubleCreditNode.setDef(1.);
        end;

        if ((currencyDedetNode.exact == 0.0) and (currencyCreditNode.exact == 0.0))
            currencyDedetNode.setDef(1.);
            currencyCreditNode.setDef(1.);
        end;
    end;

    private macro normalizeOneBalance(balInfo : BalanceInfo) : Bool
        var chapter = m_normalizer.getChapter().getChapter();

        if (chapter == 5)
            m_normalizer = TBalanceChapterNormalizer(1,                   chapter, not m_previousReport.isCalculated());
        else
            m_normalizer = TBalanceChapterNormalizer(m_report.multiplier, chapter, not m_previousReport.isCalculated());
        end;

        m_normalizer.setIsTotal(false);

        m_normalizer.setIsOptimalDecision(true);

        loadOneBalance(balInfo);

        m_normalizer.normalize();

        if (not m_normalizer.isNormalized() and not m_normalizer.isErrorExact() and isZeroTurns(balInfo))

            if (chapter == 5)
                m_normalizer = TBalanceChapterNormalizer(1,                   chapter, not m_previousReport.isCalculated());
            else
                m_normalizer = TBalanceChapterNormalizer(m_report.multiplier, chapter, not m_previousReport.isCalculated());
            end;

            m_normalizer.setIsTotal(false);

            m_normalizer.setIsOptimalDecision(true);

            loadOneBalance(balInfo);

            setCorrectZeroValue(balInfo);

            m_protocolView.printSeparator(true);
            m_protocolView.printStringExt("Внимание! Установлен режим корректировки нулевых оборотов для балансового счета " + balInfo.getBalanceNumber() + ".");
            m_protocolView.printSeparator(false);
            m_normalizer.normalize();
        end;

        if (m_normalizer.isNormalized())
            saveBalance(balInfo, false);
        else
            m_protocolView.printSeparator(true);
            if (m_normalizer.isErrorExact())
                m_protocolView.printStringExt("Ошибки на неокругленных значениях!");
            end;
            m_protocolView.printStringExt("Не удалось нормализовать значения по счету: " + balInfo.getBalanceNumber());
            m_protocolView.printStringExt("лог-файл:" + m_normalizer.getLogFilePath());
            m_protocolView.printSeparator(false);
            return false;
        end;

        return true;
    end;

    private macro normilizeChapterByParts(chapter, isOptimal, isNormalizeByGroup, isMaxError : Bool)
        isMaxError = nvl(isMaxError, false);

        m_currentChapter = chapter;

        if (not isMaxError)
            initProtocolView(chapter);
            m_protocolView.printDescription();

            TParameters().printReport(m_protocolView, m_currentChapter);

            m_protocolView.printLine("┌──────────────────────────────────────────────────────────────────────────────────────────┐");
            m_protocolView.printLine("│--------------------------------------ГЛАВА " + chapter + "---------------------------------------------│");
            m_protocolView.printLine("└──────────────────────────────────────────────────────────────────────────────────────────┘");

            var isExistConflictingSetting = ExcludedAccountsController().isExistConflictingSetting(chapter, m_protocolView,
                                                                                                   getSqlString(TParameters().getExcludedAccountsRouble(chapter)),
                                                                                                   getSqlString(TParameters().getExcludedAccountsForeign(chapter)),
                                                                                                   getSqlString(TParameters().getExcludedAccountsTotal(chapter)),
                                                                                                   ternary(TParameters().isExcludeAccounts(), 1, 0),
                                                                                                   ternary(TParameters().isExcludeAccountsForChapter(chapter), 1, 0)
                                                                                                  );
            if (isExistConflictingSetting)
                return;
            end;
        end;

        if (chapter == 5)
            m_normalizer = TBalanceChapterNormalizer(1,                   chapter, not m_previousReport.isCalculated());
        else
            m_normalizer = TBalanceChapterNormalizer(m_report.multiplier, chapter, not m_previousReport.isCalculated());
        end;


        private var balanceList = TRcbSet();

        balanceList.clear();

        var dataSet = TRsbDataSet(
                                  "WITH tabcoff AS(SELECT " + getSqlString(TParameters().getUserPriority_0(chapter)) + " t_balancelist,"
                    +"\n"+        "                       0 t_k"
                    +"\n"+        "                  FROM DUAL"
                    +"\n"+        "                 UNION ALL"
                    +"\n"+        "                 SELECT " + getSqlString(TParameters().getUserPriority_100(chapter)) + ","
                    +"\n"+        "                       100"
                    +"\n"+        "                  FROM DUAL"
                    +"\n"+        "               ),"
                    +"\n"+        "  tabexclbal AS(SELECT --+inline"
                    +"\n"+        "                       " + getSqlString(TParameters().getExcludedAccountsRouble(chapter)) + " t_roublebalancelist,"
                    +"\n"+        "                       " + getSqlString(TParameters().getExcludedAccountsForeign(chapter)) + " t_currencybalancelist,"
                    +"\n"+        "                       " + getSqlString(TParameters().getExcludedAccountsTotal(chapter)) + " t_totalbalancelist"
                    +"\n"+        "                  FROM DUAL),"
                    +"\n"+        "  tabuse     AS(SELECT --+inline"
                    +"\n"+        "                       " + ternary(TParameters().isEnableUserPriority(), 1, 0) + " t_isusepriority,"
                    +"\n"+        "                       " + ternary(TParameters().isEnableUserPriorityForChapter(chapter), 1, 0) + " t_isusepriorityforchapter,"
                    +"\n"+        "                       " + ternary(TParameters().isExcludeAccounts(), 1, 0) + " t_isuseexclude,"
                    +"\n"+        "                       " + ternary(TParameters().isExcludeAccountsForChapter(chapter), 1, 0) + " t_isuseexcludeforchapter"
                    +"\n"+        "                  FROM DUAL),"
                    +"\n"+        "  balanceMaxErrorList AS (SELECT --+inline"
                    +"\n"+        "                                 " + getSqlString(TParameters().getMaximumErrorAccounts(chapter)) + " t_list,"
                    +"\n"+        "                                 " + getSqlString(TParameters().getMaximumError(chapter)) + " t_value"
                    +"\n"+        "                            FROM dual)"
                    +"\n"+        "SELECT t_balance,"
                    +"\n"+        "       t_maxErrorValue,"
                    +"\n"+        "       t_kindaccount,"
                    +"\n"+        "       t_k,"
                    +"\n"+        "       t_isRoubleExcluded,"
                    +"\n"+        "       t_isCurrencyExcluded,"
                    +"\n"+        "       t_isTotalExcluded"
                    +"\n"+        "  FROM (SELECT " + getSqlString(m_normalizer.getChapter().getName()) + " t_balance, NULL t_maxErrorValue, NULL t_kindaccount, 100 t_k, 0 t_isRoubleExcluded, 0 t_isCurrencyExcluded, 0 t_isTotalExcluded"
                    +"\n"+        "          FROM DUAL"
                    +"\n"+        "         WHERE " + ternary (m_previousReport.isCalculated(), "1=1", "1=0")
                    +"\n"+        "        UNION ALL"
                    +"\n"+        "        SELECT bal.t_balance,"
                    +"\n"+        "               CASE"
                    +"\n"+        "                   WHEN regexp_like((SELECT t_list FROM balanceMaxErrorList), '([^[:digit:]]|^)(' || bal.t_balance || ')([^[:digit:]]|$)')"
                    +"\n"+        "                       THEN (SELECT t_value FROM balanceMaxErrorList)"
                    +"\n"+        "                   ELSE NULL"
                    +"\n"+        "               END t_maxErrorValue,"
                    +"\n"+        "               CASE"
                    +"\n"+        "                  WHEN LENGTH (bal.t_balance) = 3"
                    +"\n"+        "                       THEN CASE"
                    +"\n"+        "                            WHEN t_all = t_a"
                    +"\n"+        "                               THEN 'А'"
                    +"\n"+        "                            WHEN t_a IS NULL"
                    +"\n"+        "                               THEN 'П'"
                    +"\n"+        "                            ELSE 'АП'"
                    +"\n"+        "                         END"
                    +"\n"+        "                  ELSE DECODE (bal.t_kind_account, '0', 'А', bal.t_kind_account)"
                    +"\n"+        "               END AS t_kindaccount,"
                    +"\n"+        "               NVL((SELECT t_k"
                    +"\n"+        "                      FROM tabcoff"
                    +"\n"+        "                     WHERE (SELECT 1"
                    +"\n"+        "                              FROM tabuse"
                    +"\n"+        "                             WHERE t_isusepriority = 1"
                    +"\n"+        "                               AND t_isusepriorityforchapter =1) = 1"
                    +"\n"+        "                       AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                       AND REGEXP_LIKE (tabcoff.t_balancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')"
                    +"\n"+        "                       AND ROWNUM < 2), 50) t_k,"
                    +"\n"+        "               NVL ((SELECT 1"
                    +"\n"+        "                       FROM tabexclbal"
                    +"\n"+        "                      WHERE (SELECT 1"
                    +"\n"+        "                               FROM tabuse"
                    +"\n"+        "                              WHERE t_isuseexclude = 1"
                    +"\n"+        "                                AND t_isuseexcludeforchapter =1) = 1"
                    +"\n"+        "                        AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                        AND REGEXP_LIKE (tabexclbal.t_roublebalancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')), 0) t_isroubleexcluded,"
                    +"\n"+        "               NVL ((SELECT 1"
                    +"\n"+        "                       FROM tabexclbal"
                    +"\n"+        "                      WHERE (SELECT 1"
                    +"\n"+        "                               FROM tabuse"
                    +"\n"+        "                              WHERE t_isuseexclude = 1"
                    +"\n"+        "                                AND t_isuseexcludeforchapter =1) = 1"
                    +"\n"+        "                        AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                        AND REGEXP_LIKE (tabexclbal.t_currencybalancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')), 0) t_iscurrencyexcluded,"
                    +"\n"+        "               NVL ((SELECT 1"
                    +"\n"+        "                       FROM tabexclbal"
                    +"\n"+        "                      WHERE (SELECT 1"
                    +"\n"+        "                               FROM tabuse"
                    +"\n"+        "                              WHERE t_isuseexclude = 1"
                    +"\n"+        "                                AND t_isuseexcludeforchapter =1) = 1"
                    +"\n"+        "                        AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                        AND REGEXP_LIKE (tabexclbal.t_totalbalancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')), 0) t_istotalexcluded"
                    +"\n"+        "          FROM dbalance_dbt bal,"
                    +"\n"+        "               (SELECT SUBSTR(t_balance, 1, 3) t_balance,"
                    +"\n"+        "                       COUNT(*) t_all"
                    +"\n"+        "                  FROM dbalance_dbt"
                    +"\n"+        "                 WHERE t_balance NOT LIKE '%ОВП%'"
                    +"\n"+        "                   AND t_chapter = " + chapter
                    +"\n"+        "                   AND t_inumplan = 0"
                    +"\n"+        "                   AND LENGTH(t_balance) = 5"
                    +"\n"+        "                   AND INSTR(t_type_balance, 'T') = 0"
                    +"\n"+        "              GROUP BY SUBSTR(t_balance, 1, 3)) dall,"
                    +"\n"+        "               (SELECT SUBSTR(t_balance, 1, 3) t_balance,"
                    +"\n"+        "                       COUNT(*) t_a"
                    +"\n"+        "                  FROM dbalance_dbt"
                    +"\n"+        "                 WHERE t_balance NOT LIKE '%ОВП%'"
                    +"\n"+        "                   AND t_chapter = " + chapter
                    +"\n"+        "                   AND t_inumplan = 0"
                    +"\n"+        "                   AND LENGTH(t_balance) = 5"
                    +"\n"+        "                   AND INSTR(t_type_balance, 'T') = 0"
                    +"\n"+        "                   AND (t_kind_account = '0' OR t_kind_account = 'А')"
                    +"\n"+        "              GROUP BY SUBSTR(t_balance, 1, 3)) da"
                    +"\n"+        "         WHERE bal.t_chapter = " + chapter
                    +"\n"+        "           AND bal.t_balance NOT LIKE '%ОВП%'"
                    +"\n"+        "           AND bal.t_inumplan = 0"
                    +"\n"+        "           AND (LENGTH(bal.t_balance) = 5)"
                    +"\n"+        "           AND INSTR(bal.t_type_balance, 'T') = 0"
                    +"\n"+        "           AND bal.t_balance = dall.t_balance(+)"
                    +"\n"+        "           AND bal.t_balance = da.t_balance(+))"
                    +"\n"+        "ORDER BY CASE"
                    +"\n"+        "             WHEN INSTR(t_balance, " + getSqlString(m_normalizer.getChapter().getName()) + ") != 0 THEN 999999"
                    +"\n"+        "             ELSE LENGTH(t_balance)"
                    +"\n"+        "         END,"
                    +"\n"+        "         t_balance");

        dataset.setFieldType("t_balance", V_STRING);
        dataset.setFieldType("t_maxErrorValue", V_DOUBLE);
        dataset.setFieldType("t_kindAccount", V_STRING);
        dataset.setFieldType("t_k", V_INTEGER);
        dataset.setFieldType("t_isRoubleExcluded", V_INTEGER);
        dataset.setFieldType("t_isCurrencyExcluded", V_INTEGER);
        dataset.setFieldType("t_isTotalExcluded", V_INTEGER);

        var i = 0;
        var isExist = false;
        var av = TBalanceAttribute("БАЛАНС", null, TBalanceAttributeMode.MODIFY_FIELD_VALUE);
        var chapterNumber = m_normalizer.getChapter().getChapter();
        var chapterName = m_normalizer.getChapter().getName();

        m_normalizer.setIsTotal(true);

        while (dataSet.moveNext())

            var balanceValue = av.getBalanceAttribute(chapterNumber, dataSet.balance, false);
            if (    (balanceValue != null)
                and (   (balanceValue.fieldValue("restActive").exact != $0)
                     or (balanceValue.fieldValue("restPassive").exact != $0)
                     or (balanceValue.fieldValue("restNatCurActive").exact != $0)
                     or (balanceValue.fieldValue("restNatCurPassive").exact != $0)
                     or (balanceValue.fieldValue("restCurActive").exact != $0)
                     or (balanceValue.fieldValue("restCurPassive").exact != $0)
                     or (balanceValue.fieldValue("debet").exact != $0)
                     or (balanceValue.fieldValue("credit").exact != $0)
                     or (balanceValue.fieldValue("restInActive").scaled != $0)
                     or (balanceValue.fieldValue("restInPassive").scaled != $0)
                     or (balanceValue.fieldValue("restInNatCurActive").scaled != $0)
                     or (balanceValue.fieldValue("restInNatCurPassive").scaled != $0)
                     or (balanceValue.fieldValue("restInCurActive").scaled != $0)
                     or (balanceValue.fieldValue("restInCurPassive").scaled != $0)
                    )
               )
//            if (av.isExistsNonZeroAttribute(chapterNumber, dataSet.balance))
                balanceList.insert(BalanceInfo(chapterNumber, dataSet.balance, dataSet.kindaccount, dataSet.getRecord()));
                loadBalance(dataSet, true);
                isExist = true;
            end;

            if ((dataSet.balance == chapterName) and isExist)
                loadValue(dataSet, COLUMN_KIND.ACTIVE_IN_REST);
                loadValue(dataSet, COLUMN_KIND.PASSIVE_IN_REST);
                loadValue(dataSet, COLUMN_KIND.DEBET);
                loadValue(dataSet, COLUMN_KIND.CREDIT);
                loadValue(dataSet, COLUMN_KIND.ACTIVE_DEBET);
                loadValue(dataSet, COLUMN_KIND.ACTIVE_CREDIT);
                loadValue(dataSet, COLUMN_KIND.PASSIVE_DEBET);
                loadValue(dataSet, COLUMN_KIND.PASSIVE_CREDIT);
                loadValue(dataSet, COLUMN_KIND.ACTIVE_OUT_REST);
                loadValue(dataSet, COLUMN_KIND.PASSIVE_OUT_REST);

                m_normalizer.addBalance(dataSet.balance, null);
            end;

            i = i + 1;
        end;

        if (isExist)
            if (chapter == 3)
                m_normalizer.addRelationsForLoroAccountsChapter3()
            end;

            if (chapter == 4)
                m_normalizer.addRelationsForLoroAccountsChaper4();
            end;
        end;

        message("нормализация итоговых значений главы " + m_normalizer.getChapter().getChapter());

        if (isOptimal == false)
            m_normalizer.setIsOptimalDecision(false);
        end;

        if (not TParameters().isOptimalDecision())
            m_normalizer.setMaxNumberOfDecision(TParameters().getMaximumPermissibleDecisionsAmount());
            m_normalizer.setIsOptimalDecision(false);
        end;

        if (isNormalizeByGroup)
            m_normalizer.setIsNormalizeByGroup(true);
        end;

        m_normalizer.setTimeLimit(TParameters().getMaximumSolvingDuration());

        var iterator;

        if (isMaxError)
            m_protocolView.printLine("ВНИМАНИЕ!Нормализация по главе " + chapter + " производится c отнесением погрешности на исходящие остатки (алгоритм СЧЕТА С МАКСИМАЛЬНОЙ ПОГРЕШНОСТЬЮ)");

            iterator = balanceList.createIterator();

            iterator.moveFirst();

            while (not iterator.isDone())
                setMaxError(iterator.getCurrentItem().getRecord());

                iterator.moveNext();
            end;
        end;

        m_normalizer.normalize();

        if (not isMaxError and not m_normalizer.isNormalized() and not m_normalizer.isErrorExact())
            normilizeChapterByParts(chapter, isOptimal, isNormalizeByGroup, true);
            return;
        end;

        m_protocolView.printLine("НОРМАЛИЗАЦИЯ ГЛАВЫ " + chapter);

        m_protocolView.printLine("Период отчета:" + m_report.context.period.beginDate + " - " + m_report.context.period.endDate);

        m_protocolView.printLine("Количество узлов нормализации: " + m_normalizer.count);

        if (not m_normalizer.isNormalized())
            if (m_normalizer.isErrorExact())
                m_protocolView.printLine("Ошибки на неокругленных значениях!");
            end;

            m_protocolView.printLine("Не удалось выполнить нормализацию по главе " + chapter + "(смотри лог-файл:" + m_normalizer.getLogFilePath() + ").");

            if(m_isRecalculateIfNotNormalized)

                iterator = balanceList.createIterator();

                iterator.moveFirst();

                while (not iterator.isDone())
                    saveBalance(iterator.getCurrentItem());

                    iterator.moveNext();
                end;

                RcbApplication.TransactionManager.commit();
            end;

            return;
        end;

        m_protocolView.printLine("\nНормализация итоговых значений выполнена");
        m_protocolView.printLine("лог-файл:" + m_normalizer.getLogFilePath());
        m_protocolView.printLine("Время нормализации (мс): " + m_normalizer.getTimeNormalizationAsString());
        m_protocolView.printLine("\nПротокол нормализации итоговых значений");
        m_protocolView.printHeadTable();

        iterator = balanceList.createIterator();

        iterator.moveFirst();

        i = 0;
        while (not iterator.isDone())
            saveBalance(iterator.getCurrentItem(), true);

            i = i + 1;

            iterator.moveNext();
        end;

        m_protocolView.printBottomTable(chapter);
        m_protocolView.printLine("");

        if (chapter != 5)
            iterator = balanceList.createIterator();

            iterator.moveFirst();

            m_protocolView.printLine("\nПротокол нормализации значений по отдельным балансовым счетам");
            m_protocolView.printHeadTable();

            i = 0;
            while (not iterator.isDone())
                normalizeOneBalance(iterator.getCurrentItem());

                i = i + 1;

                iterator.moveNext();
            end;

            m_protocolView.printBottomTable(chapter);
            m_protocolView.printLine("");
        end;

        RcbApplication.TransactionManager.commit();
    end;

    macro execute()
        if((m_chapter == 0)or(m_chapter == ""))
            normilizeChapterByParts(1, true, false);
            normilizeChapterByParts(2, true, false);
            normilizeChapterByParts(3, true, false);
            normilizeChapterByParts(4, true, false);
            normilizeChapterByParts(5, true, false);
        else
            normilizeChapterByParts(m_chapter, true, false);
        end;
    end;
end;

// 04.02.2015 ABP Устарело. Не использовать. Не модифицировать.
private macro showNormalizationProtocol(commandLineArguments : String)
    defaultParm(commandLineArguments, cmdArgs());

    const DESCRIPTION_LABEL = "-desc:";

    var descriptionLabelIndex = index(commandLineArguments, DESCRIPTION_LABEL);

    if (descriptionLabelIndex == 0)
        return;
    end;

    var chapter = substr(commandLineArguments, descriptionLabelIndex + strlen(DESCRIPTION_LABEL));

    var protocol = TSummaryProtocolView();

    if (chapter == 0)
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 1 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 2 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 3 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 4 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 5 ГЛАВЫ"));
    else
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ " + String(chapter) + " ГЛАВЫ"));
    end;

    protocol.show();
end;

private macro executeNormalization(chapter : Integer)
    TNormalizeBalanceController(chapter, true).execute();
end;

// 04.02.2015 ABP Устарело. Не использовать. Не модифицировать.
private macro executeNormalizationAndShowProtocol()
    if (global.currentReport.normalizationAlgorithm == RCB_NA_MMB)
        var profiler = TSQLProfiler(getTxtFileName("!BalanceNormalizeProfile"));
        profiler.clear();
        profiler.on();

        /*Нормализация всех глав*/
        TNormalizeBalanceController(0, true).execute();

        var protocol = TSummaryProtocolView();

        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 1 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 2 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 3 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 4 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 5 ГЛАВЫ"));

        protocol.show();
    end;
end;
