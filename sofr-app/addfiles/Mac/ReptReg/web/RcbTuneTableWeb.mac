/*
$Name: RcbTuneTableWeb.mac
$Module: Отчеты ЦБ
$Description: Сервис для веб-интефейса для работы с настроечными таблицами.
*/

import Cb_Sql;
import Ws_DataFilter;
import XmlRpcInter, ServiceAction;
import RcbCoreInter;
import ReptCbInter;
import Reporting;
import Rcb_Lib;
import RcbWebCommon;
import RcbGeneratedDataSource;
import RcbConst;
import RcbTuneTable;

                                /****************************\
                                 *        КОНСТАНТЫ         *
                                \****************************/

/**
 * Тип элемента дерева. Указание.
 */
const RCBTUNETABLETYPEOBJECTTREE_DESIGNATION = 1;
/**
 * Тип элемента дерева. Раздел.
 */
const RCBTUNETABLETYPEOBJECTTREE_PART = 2;
/**
 * Префикс параметров пункта меню. Наименование формы.
 */
const PREFIX_PARAMETER_MENU_FORM = "-fn:";
/**
 * Наимение макроса. Создание объекта (экземпляра класса) настроечной таблицы.
 */
const NAME_GET_CREATE_TUNE_TABLE = "getObjectTuneTableWeb";
/**
 * Наимение макроса. Получить список указаний\разделов.
 */
const NAME_GET_DESTINATION_TUNE_TABLE = "getDestinationTuneTableWeb";

                                /****************************\
                                 *         СТРУКТУРЫ        *
                                \****************************/

/**
 * Класс-структура. Элементы дерева.
 */
class TRcbTuneTableItemTree()
     /**
      * Наименование объекта, в зависимости от типа.
      */
     var nameObject: String = "";
     /**
      * Наименование указания
      */
     var nameDesignation: String = "";
     /**
      * Тип элемента (указание или раздел).
      */
     var type: Integer = 0;
     /**
      * Дочерние элементы.
      */
     var children: Variant = NULL;
end;

                                /****************************\
                                 *    ЛОКАЛЬНЫЕ ФУНКЦИИ     *
                                \****************************/

/**
 * Получить наименование формы из параметров, переданных через пункт меню
 *
 * @param parameter Параметры пункта меню
 *
 * @return String Наименование формы.
 */
private macro getNameForm(parameter: String): String
    /**
     * Индекс префикса
     */
    var formLabelIndex: Integer = 0;
    /**
     * Рабочая строка.
     */
    var workString: String = "";
    /**
     * Индекс начала наименования формы.
     */
    var openQuoteIndex: Integer = 0;
    /**
     * Индекс окончания наименования формы.
     */
    var closeQuoteIndex: Integer = 0;
    /**
     * Результат - наимнование формы.
     */
    var result: String = "";

    formLabelIndex = index(parameter, PREFIX_PARAMETER_MENU_FORM);
    if (formLabelIndex == 0)
        RunError("Наименование формы не указано в параметрах пункта меню ");
    end;
    workString      = substr(parameter, formLabelIndex + strlen(PREFIX_PARAMETER_MENU_FORM));
    openQuoteIndex  = index(workString, "\"");
    closeQuoteIndex = openQuoteIndex + index(substr(workString, openQuoteIndex  + 1), "\"");
    result          = substr(workString, openQuoteIndex + 1, closeQuoteIndex - 2);
    if (strLen(result) == 0)
        RunError("Наименование формы не указано в параметрах пункта меню ");
    end;
    return result;
end;

/**
 * Получить наименование макроса настроечной таблицы.
 *
 * @param parameter Параметр пункта меню. Должен содержать название формы.
 *
 * @return String Наименование макроса или пустая строка, в случае отсутствия формы
 */
private macro getNameMacroOrNil(parameter: String): String
    /**
     * Результат - наименование макроса.
     */
    var result: String = "";
    /**
     * Наименование формы.
     */
    var nameForm: String = getNameForm(parameter);

    if (nameForm == NAME_FORM_110)
        result = "f110TuneTable";
    elif (nameForm == NAME_FORM_115)
        result = "f115TuneTable";
    elif (nameForm == NAME_FORM_118)
        result = "f118TuneTable";
    elif (nameForm == NAME_FORM_119)
        result = "f119TuneTable";
    elif (nameForm == NAME_FORM_123)
        result = "f123TuneTable";
    elif (nameForm == NAME_FORM_125)
        result = "f125TuneTable";
    elif (nameForm == NAME_FORM_128)
        result = "c_f128tune";
    elif (nameForm == NAME_FORM_129)
        result = "f129TuneTable";
    elif (nameForm == NAME_FORM_155)
        result = "f155TuneTable";
    elif (nameForm == NAME_FORM_251)
        result = "calc_f251tune";
    elif (nameForm == NAME_FORM_301)
        result = "f301TuneTable";
    elif (nameForm == NAME_FORM_302)
        result = "calc_f302tune";
    elif (nameForm == NAME_FORM_303)
        result = "f303TuneTable";
    elif (nameForm == NAME_FORM_345)
        result = "f345TuneTable";
    elif (nameForm == NAME_FORM_401)
        result = "f401TuneTable";
    elif (nameForm == NAME_FORM_501)
        result = "c_f501tune";
    elif (nameForm == NAME_FORM_601)
        result = "f601TuneTable";
    elif (nameForm == NAME_FORM_603)
        result = "f603TuneTable";
    elif (nameForm == NAME_FORM_652)
        result = "f652TuneTable";
    elif (nameForm == NAME_FORM_664)
        result = "f664TuneTable";
    elif (nameForm == NAME_FORM_CASH)
        result = "CFTuneTable";
    elif (nameForm == NAME_FORM_FOR)
        result = "TTuneTable";
    elif (nameForm == NAME_FORM_APPENDIX6)
        result = "fAppendix6TuneTable";
    elif (nameForm == NAME_FORM_OFR)
        result = "OfrTuneTable";
    elif (nameForm == NAME_FORM_COMMON)
        result = "RcbArTuneTableWeb";
    else
        result = "";
    end;

    return result;
end;

/**
 * Получить наименование макроса настроечной таблицы.
 * В случае отсутствия класса настроечной таблицы возникает исключительная ситуация.
 *
 * @param parameter Параметр пункта меню. Должен содержать название формы.
 *
 *
 * @return String Наименование макроса или пустая строка, в случае отсутствия формы
 */
private macro getNameMacro(parameter: String): String
    /**
     * Результат - наименование макроса.
     */
    var result: String = "";

    result = getNameMacroOrNil(parameter);

    if (result == "")
        RunError("Не указано наименование класса настроечной таблицы.");
    end;

    return result;
end;

/**
 * Фильтр для записи скроллинга
 *
 * @param recordData Запись скроллинга
 * @param filter Условия фильтрации
 *
 * @return TRUE - если запись удовлетворяет фильтру, иначе - FALSE
 */
private macro isFilteredRecord(
            recordData:   TArray,
            filter:       TArray): Bool
    /**
     * Условие фильтра
     */
    var condition: Object = NULL;
    /**
     * Результат
     */
    var result: Bool = TRUE;
    /**
     * Результат одного условия
     */
    var resultCondition: Bool = FALSE;
    /**
     * Значение поля
     */
    var valueField: String = "";
    /**
     * Значение фильтра
     */
    var valueCondition: String = "";

    for (condition, filter)
        valueField     = recordData[condition.id];
        valueCondition = condition.value[0];
        // строки
        if (condition.valueType == FilterParameterType_String)
            if (condition.condition == FilterCondition_Equal)
                resultCondition = (valueField == valueCondition);
            elif (condition.condition == FilterCondition_Include)
                resultCondition = (index(valueField, valueCondition) != 0);
            elif (condition.condition == FilterCondition_StartWith)
                resultCondition = (index(valueField, valueCondition) == 1);
            elif (condition.condition == FilterCondition_Null)
                resultCondition = ((valueField == "") OR (valueField == NULL));
            else
                runError("Не предусмотрена обработа данного условия фильтра");
            end;
        // бэк-офис
        elif (condition.valueType == FilterParameterType_CheckList)
            if (condition.value.size > 0)
                for (valueCondition, condition.value)
                    if (valueCondition == valueField)
                        resultCondition = TRUE;
                    end;
                end;
            else
                resultCondition = TRUE;
            end;
        else
            runError("Не предусмотрена обработа данного типа фильтра");
        end;

        if (condition.isNot)
            result = (result AND (NOT resultCondition));
        else
            result = (result AND resultCondition);
        end;
        if (NOT result)
            break;
        end;
    end;

    return result;
end;

                                /****************************\
                                 *         СЕРВИСЫ          *
                                \****************************/

/**
 * @brief Получить список элементов для дерева
 *
 * @param parameter Строка параметров, переданная через меню. Должна содержать наименование формы.
 *
 * @return Массив элементов TRcbTuneTableItemTree.
 */
macro getItemTreeList(parameter: String)
    /**
     * Результат.
     */
    var result: Variant = NULL;
    /**
     * Текущее указание.
     */
    var currentDestination: Variant = NULL;
    /**
     * Текущий раздел.
     */
    var currentPart: Variant = NULL;
    /**
     * Массив указаний\разделов.
     */
    var destinationList: Variant = NULL;
    /**
     * Массив указаний\разделов в формате xml.
     */
    var destinationListXml: String = "";
    /**
     * Счетчик.
     */
    var i: Integer = 0;
    /**
     * Счетчик.
     */
    var j: Integer = 0;
    /**
     * Список разделов.
     */
    var partList: Variant = NULL;

    if (parameter == null)
        RunError("Не задан обязательный параметр функции: параметры пункта меню ");
    end;
    /**
     * Наименование отчетной формы.
     * Логический идентификатор.
     */
    var nameForm: String = getNameForm(parameter);
    /**
     * Указание
     */
    var destination: String = "";

    destinationListXml = ExecMacroFile(getNameMacro(parameter), NAME_GET_DESTINATION_TUNE_TABLE);
    ConvertToRSL(destinationListXml, destinationList);

    if (destinationList == NULL)
        RunError("Ошибка формирования массива указаний\разделов");
    end;

    if (destinationList.size == 0)
        return TArray();
    end;

    result = TArray();
    i = 0;
    while (i < destinationList.size)
        if (valType(destinationList[i]) == V_STRING)
            currentDestination                 = TRcbTuneTableItemTree();
            currentDestination.nameObject      = destinationList[i];
            currentDestination.nameDesignation = destinationList[i];
            currentDestination.type            = RCBTUNETABLETYPEOBJECTTREE_DESIGNATION;
            currentDestination.children        = NULL;
            result[result.size] = currentDestination;
            destination = destinationList[i];
        elif (isEqClass("TArray",destinationList[i]))
            j = 0;
            partList = TArray();
            while (j < destinationList[i].size)
                currentPart                 = TRcbTuneTableItemTree();
                currentPart.nameObject      = destinationList[i][j];
                currentPart.nameDesignation = destination;
                currentPart.type            = RCBTUNETABLETYPEOBJECTTREE_PART;
                currentPart.Children        = NULL;
                partList[partList.size]     = currentPart;
                j = j + 1;
            end;
            result[result.size - 1].children = partList;
        end;
        i = i + 1;
    end;

    return result;

    onError(errorObject)
        rcbRunError(errorObject);
end;

/**
 * @brief Получить метаинформацию для скроллинга
 *
 * @param attribute Текущий (выделенный) элемент в дереве.
 * @param parameter Параметры пункта меню
 *
 * @return Массив объектов TMetaInformation
 */
macro getMetadata(
          attribute /* : TRcbTuneTableItemTree */,
          parameter: String) /* : TArray */
    /**
     * Результат - массив данных.
     */
    var result: TArray = TArray();
    /**
     * Список метаинформации.
     */
    var metadataList: Variant = NULL;
    /**
     * Объект настроечной таблицы
     */
    var tuneTable: Object = NULL;
    /**
     * Объект настроечной таблицы в формате xml
     */
    var tuneTableXml: String = NULL;
    /**
     * Наименование формы.
     */
    var nameForm: String = getNameForm(parameter);
    /**
     * Счетчик
     */
    var i: Integer = 0;

    if (parameter == NULL)
        RunError("Не указан обязательный параметр сервиса: parameter");
    end;

    tuneTableXml = ExecMacroFile(getNameMacro(parameter), NAME_GET_CREATE_TUNE_TABLE, attribute);
    ConvertToRSL(tuneTableXml, tuneTable);

    if (tuneTable == NULL)
        RunError("Ошибка формирования списка метаинформации \"" + tuneTableXml + "\"");
    end;

    metadataList = tuneTable.m_metadataList;

    i = 0;
    result = TArray();
    /**
     * Элемент (колонка) метаинформации
     */
    var itemMetadata: Variant = NULL;

    while (i < metadataList.size)
        // класс metadataList, сформированный из xml, доступен только для чтения
        itemMetadata           = TMetaInformation();
        itemMetadata.id        = metadataList[i].id;
        itemMetadata.nameHead  = metadataList[i].nameHead;
        itemMetadata.name      = strUpr(metadataList[i].name);
        itemMetadata.field     = strUpr(metadataList[i].field);
        itemMetadata.type      = metadataList[i].type;
        itemMetadata.isVisible = metadataList[i].isVisible;

        // если доступа на редактирование нет, то устанавливаем все поля только на чтение
        if (NOT RcbApplication.accessControlSystem.formEditPrivilege.isAccessableTo(nameForm))
            itemMetadata.isReadOnly = TRUE;
        else
            itemMetadata.isReadOnly = metadataList[i].isReadOnly;
        end;

        result[result.size] = itemMetadata;
        i = i + 1;
    end;

    return result;

    onError(errorObject)
        rcbRunError(errorObject);
end;

/**
 * Получить данные для динамического скроллинга.
 *
 * @param attribute Текущий (выделенный) элемент в дереве.
 * @param parameter Параметры пункта меню
 * @param filter Фильтр
 *
 * @return Массив данных (TArray).
 */
macro getData(
          attribute: Object /* : TRcbTuneTableItemTree */,
          parameter: String,
          filter: TArray) : TArray
    /**
     * Генерируемый класс для динамического скроллинга.
     */
    var generateClass: Variant = NULL;
    /**
     * Результат - массив данных.
     */
    var result: TArray = TArray();
    /**
     * Результат - xml строка.
     */
    var resultXml: Variant = NULL;
    /**
     * Двумерный массив данных настроечной таблицы.
     */
    var tuneTableDataList: Variant = NULL;
    /**
     * Объект настроечной таблицы.
     */
    var tuneTable: Variant = NULL;
    /**
     * Объект настроечной таблицы в формате xml.
     */
    var tuneTableXml: String = "";
    /**
     * Счетчик
     */
    var i: Integer = 0;

    if (attribute == NULL)
        // если данный атрибут не указан, значит в дереве ничего не выбрано
        return TArray();
    end;
    if (parameter == NULL)
        RunError("Не указан обязательный параметр сервиса: parameter");
    end;

    tuneTableXml = ExecMacroFile(getNameMacro(parameter), NAME_GET_CREATE_TUNE_TABLE, attribute);
    ConvertToRSL(tuneTableXml, tuneTable);

    if (tuneTable == NULL)
        RunError("Ошибка формирования объекта настроечной таблицы");
    end;

    tuneTableDataList = tuneTable.m_dataList;

    generateClass = TGenerateClass("RcbTuneTableGenerate", "RcbTuneTableGenerate");
    generateClass.addProperty(getMetadata(attribute, parameter));

    while (i < tuneTableDataList.size)
        if ((filter.size == 0) OR (isFilteredRecord(tuneTableDataList[i], filter)))
            generateClass.addRecord(tuneTableDataList[i]);
        end;
        i = i + 1;
    end;

    generateClass.generate();
    resultXml = generateClass.getGeneratedDataSource();

    if (resultXml == "")
        RunError("Ошибка выполнения сгенерированного класса RcbTuneTableGenerate ");
    end;

    ConvertToRSL(resultXml, result);
    return result;

    onError(errorObject)
        rcbRunError(errorObject);
end;

/**
 * Получить количество записей для динамического скроллинга.
 *
 * @param attribute Текущий (выделенный) элемент в дереве.
 * @param parameter Параметры пункта меню
 * @param filter Фильтр
 *
 * @return Integer Количество записей
 */
macro getCountData(
          attribute: Object /* : TRcbTuneTableItemTree */,
          parameter: String,
          filter:    TArray) : Integer
    /**
     * Результат
     */
    var result: Integer = 0;
    /**
     * Записи для скроллинга
     */
    var dataTuneTable: TArray = null;

    dataTuneTable = getData(attribute, parameter, filter);
    if (dataTuneTable == NULL)
        result = 0;
    else
        result = dataTuneTable.size;
    end;

    return result;

    onError(errorObject)
        rcbRunError(errorObject);
end;

/**
 * Изменить значение записи скроллинга
 *
 * @param newRecord Значение для сохранения (новое значение).
 * @param oldRecord Значение для поиска записи (старое значение).
 * @param attribute Текущий (выделенный) элемент в дереве.
 * @param parameter Параметры пункта меню
 */
macro editRecord(
          newRecord /* :RsDynamicModel */,
          oldRecord /* :RsDynamicModel */,
          attribute /* : TRcbTuneTableItemTree */,
          parameter: String) /* : TArray */
    /**
     * Запрос sql.
     */
    var query: String = "";
    /**
     * Набор данных.
     */
    var dataSet: Variant = NULL;
    /**
     * Метаданные.
     */
    var metadataList: Variant = NULL;
    /**
     * Объект настроечной таблицы.
     */
    var tuneTable: Variant = NULL;
    /**
     * Объект настроечной таблицы в формате xml.
     */
    var tuneTableXml: String = "";
    /**
     * Счетчик.
     */
    var i: Integer = 0;
    /**
     * Строка sql с полями для обновления.
     */
    var updateFieldSql: String = "";
    /**
     * Строка sql с условиями отбора - секция WHERE.
     */
    var whereFieldSql: String = "";
    /**
     * Новое значение ячейки.
     */
    var newColumnValue: String = "";
    /**
     * Старое значение ячейки.
     */
    var oldColumnValue: String = "";
    /**
     * Фильтр по дате указания.
     */
    var filterInstructionDate: String = "";

    tuneTableXml = ExecMacroFile(getNameMacro(parameter), NAME_GET_CREATE_TUNE_TABLE, attribute);
    ConvertToRSL(tuneTableXml, tuneTable);

    if (tuneTable == NULL)
        RunError("Ошибка формирования объекта настроечной таблицы");
    end;

    metadataList = getMetadata(attribute, parameter);

    // преобразуем значение бэк-офиса из строкого значения в ключевое
    i = 0;
    while (i < metadataList.size)

        if (metadataList[i].field == tuneTable.nameColumnBackOffice)

            query =  "SELECT rcbValues.t_element"
            + "\n" + "  FROM dllValues_dbt rcbValues"
            + "\n" + " WHERE rcbValues.t_list = " + RCB_OBJTYPE_NT_BACKOFFICE
            + "\n" + "   AND rcbValues.t_name = '" + execExp("NewRecord." + tuneTable.nameColumnBackOffice) + "'";
            dataSet = TRsbDataSet(query);
            dataSet.setFieldType("t_element",   V_INTEGER);
            if (dataSet.moveNext())
                execExp("NewRecord." + tuneTable.nameColumnBackOffice + " = \"" + dataSet.t_element + "\"");
            end;

            query =  "SELECT rcbValues.t_element"
            + "\n" + "  FROM dllValues_dbt rcbValues"
            + "\n" + " WHERE rcbValues.t_list = " + RCB_OBJTYPE_NT_BACKOFFICE
            + "\n" + "   AND rcbValues.t_name = '" + execExp("OldRecord." + tuneTable.nameColumnBackOffice) + "'";
            dataSet = TRsbDataSet(query);
            dataSet.setFieldType("t_element",   V_INTEGER);
            if (dataSet.moveNext())
                execExp("OldRecord." + tuneTable.nameColumnBackOffice + " = \"" + dataSet.t_element + "\"");
            end;

        elif (metadataList[i].field == tuneTable.nameColumnBackOfficeDistributive)

            query =  "SELECT rcbValues.t_element"
            + "\n" + "  FROM dllValues_dbt rcbValues"
            + "\n" + " WHERE rcbValues.t_list = " + RCB_OBJTYPE_NT_BACKOFFICE
            + "\n" + "   AND rcbValues.t_name = '" + execExp("NewRecord." + tuneTable.nameColumnBackOfficeDistributive) + "'";
            dataSet = TRsbDataSet(query);
            dataSet.setFieldType("t_element",   V_INTEGER);
            if (dataSet.moveNext())
                execExp("NewRecord." + tuneTable.nameColumnBackOfficeDistributive + " = \"" + dataSet.t_element + "\"");
            end;

            query =  "SELECT rcbValues.t_element"
            + "\n" + "  FROM dllValues_dbt rcbValues"
            + "\n" + " WHERE rcbValues.t_list = " + RCB_OBJTYPE_NT_BACKOFFICE
            + "\n" + "   AND rcbValues.t_name = '" + execExp("OldRecord." + tuneTable.nameColumnBackOfficeDistributive) + "'";
            dataSet = TRsbDataSet(query);
            dataSet.setFieldType("t_element",   V_INTEGER);
            if (dataSet.moveNext())
                execExp("OldRecord." + tuneTable.nameColumnBackOfficeDistributive + " = \"" + dataSet.t_element + "\"");
            end;
        end;

        i = i + 1;
    end;

    filterInstructionDate = tuneTable.m_instructionFilter;

    i = 0;
    whereFieldSql  = " 1 = 1 ";

    while (i < metadataList.size)
        newColumnValue = string(execExp("NewRecord." + metadataList[i].Field));
        oldColumnValue = string(execExp("OldRecord." + metadataList[i].Field));
        if (i == 0)
            updateFieldSql = updateFieldSql +           metadataList[i].Field + " = '" + newColumnValue + "'";
        else
            updateFieldSql = updateFieldSql + ", "    + metadataList[i].Field + " = '" + newColumnValue + "'";
        end;
        if (oldColumnValue != "")
            whereFieldSql  = whereFieldSql  + " AND " + metadataList[i].Field + " = '" + oldColumnValue + "'";
        end;
        i = i + 1;
    end;

    if (filterInstructionDate != "")
        whereFieldSql = whereFieldSql + " AND " + filterInstructionDate;
    end;

    if (i == 0)
        RunError("Нет метаданных для сохранения значения ");
    end;

    query =  "UPDATE " + tuneTable.m_name + " " + tuneTable.m_alias
    + "\n" + "   SET " + updateFieldSql
    + "\n" + " WHERE " + whereFieldSql;

    if (sql_execute(query))
        return true;
    else
        return false;
    end;

    onError(errorObject)
        rcbRunError(errorObject);
end;

/**
 * Проверить доступность настроечной таблицы.
 *
 * @param parameter Параметры пункта меню
 *
 * @return TRcbResult result.valueInteger: 0 - успешно(можно работать с НТ), 1 - не реализовано, 2 - нет доступа к форме
 */
macro isAvailableTuneTable(parameter: String): Object
    /**
     * Есть доступ (успешно)
     */
    const TUNE_TABLE_SUCCESSFULLY = 0;
    /**
     * Не реализовано
     */
    const TUNE_TABLE_NOT_IMPLEMENTATION = 1;
    /**
     * Нет доступа
     */
    const TUNE_TABLE_NOT_ACCESS = 2;
    /**
     * Наименование формы.
     */
    var nameForm: String = getNameForm(parameter);
    /**
     * Наименование настроечной таблицы
     */
    var nameTuneTable: String = getNameMacroOrNil(parameter);
    /**
     * Результат.
     */
    var result: Object = TRcbResult();

    // Существует ли реализация?
    if (nameTuneTable == "")
        result.valueInteger = TUNE_TABLE_NOT_IMPLEMENTATION;

    // Есть ли доступ? На редактирование проверяется в формировании метаинформации.
    elif ((NOT RcbApplication.accessControlSystem.formEditPrivilege.isAccessableTo(nameForm)) AND
          (NOT RcbApplication.accessControlSystem.formViewPrivilege.isAccessableTo(nameForm)))
        result.valueInteger = TUNE_TABLE_NOT_ACCESS;
    else
        result.valueInteger = TUNE_TABLE_SUCCESSFULLY;
    end;

    result.refreshProtocolAndMessage();

    return result;

    onError(errorObject)
        rcbRunError(errorObject);
end;

/**
 * Получить наименование колонок бэк-офисов
 *
 * @param attribute Текущий (выделенный) элемент в дереве.
 * @param parameter Параметры пункта меню
 *
 * @return TArray Массив данных.
 */
macro getNameColumnsBackOffice(
          attribute /* : TRcbTuneTableItemTree */,
          parameter: String) /* : TArray */
    /**
     * Список наименований бэк-офисов
     * Должно быть два:
     *     первый элемент - наименование бэк-офиса,
     *     второй элемент - наименование дистрибутивног бэк-офиса.
     */
    var result: TArray = TArray();
    /**
     * Объект настроечной таблицы.
     */
    var tuneTable: Variant = NULL;
    /**
     * Объект настроечной таблицы в формате xml.
     */
    var tuneTableXml: String = "";

    tuneTableXml = ExecMacroFile(getNameMacro(parameter), NAME_GET_CREATE_TUNE_TABLE, attribute);
    ConvertToRSL(tuneTableXml, tuneTable);

    result[result.size] = tuneTable.nameColumnBackOffice;
    result[result.size] = tuneTable.nameColumnBackOfficeDistributive;

    return result;

    onError(errorObject)
        rcbRunError(errorObject);
end;
