/*───────────────────────────────────────────────────────────────────────────┐
  RS-Bank 6.0                                            R-Style Software Lab
  Файл подсистемы "Регламентируемая отчетность"

  Рассчёт значений переменных 1 раздела 664 формы и вывод протокола.

FILENAME: c_f664_1.mac
CREATED:  Кац 12.10.04
MODIFICATIONS:
COMMENTS:
└───────────────────────────────────────────────────────────────────────────*/

import acc_lib, cb_sql, com_f664, c_f664v1, c_f664p;

// Проверка принадлежности видам ТР, ТЕ и ФЛ.
// private закомментировано из-за проблемы инструмента: ExecExp не находит то, что private.
/*private*/ MACRO GetAccKindClient( acc )
    var arr = TArray;
    if( acc.ТранзитныйСчет( ) )
        arr[arr.size] = "ТР";
    end;
    if( acc.ТекущийСчет( ) )
        arr[arr.size] = "ТЕ";
    end;
    if( not acc.СпециальныйБанковскийСчет( ) and acc.СчетФизЛица( )
            and not acc.СчетНерезидента( ) )
        arr[arr.size] = "ФЛ";
    end;
    return arr;
END;

// Проверка л/с на принадлежность к спецбанковским определённого вида.
private MACRO GetAccKindSpecial( acc, kind )
    var arr = TArray;
    if( ExecExp( "acc.СпецБанкСчет" + kind ) )
        arr[0] = kind;
    end;
    return arr;
END;

// private закомментировано из-за проблемы инструмента: ExecExp не находит то, что private.
/*private*/ MACRO GetAccKindSpecialФ( acc )
    return GetAccKindSpecial( acc, "Ф" );
END;

// private закомментировано из-за проблемы инструмента: ExecExp не находит то, что private.
/*private*/ MACRO GetAccKindSpecialР1( acc )
    return GetAccKindSpecial( acc, "Р1" );
END;

// private закомментировано из-за проблемы инструмента: ExecExp не находит то, что private.
/*private*/ MACRO GetAccKindSpecialР2( acc )
    return GetAccKindSpecial( acc, "Р2" );
END;

// Вставить запись во временный файл
private MACRO InsertAccTemp( acc, kinds )
    var i = 0;
    while( i < kinds.size )
        TempInserter.AddNew( );
        TempInserter.Value( "t_Chapter" )   = acc.АГлава;
        TempInserter.Value( "t_Account" )   = acc.АНомерЛицевого;
        TempInserter.Value( "t_CurrCode" )  = acc.АВалютаID;
        TempInserter.Value( "t_Kind" )      = kinds[i];
        TempInserter.Value( "t_Type" )      = "";   // type используется только во 2 разделе
        TempInserter.Value( "t_RestIn" )    = acc.Остаток( ПредДатаОтчета - 1, acc.АВалютаID );
        TempInserter.Value( "t_RestOut" )   = acc.Остаток( ДатаОтчета, acc.АВалютаID );
        TempInserter.Update( );

        i = i + 1;
    end;
END;

// Создание части временного файла по лицевым счетам.
// masks - маски счетов, getAccKindFuncName - функция, вычисляющая вид счёта (TArray),
// msg - сообщение для пользователя.
private MACRO CreateAccTempPart( masks, getAccKindFuncName, msg )
    var filter = ConvertMaskToSQLFormat( masks, "a.t_Account" );
    if( filter != "" )
        filter = "( " + filter + " ) and ";
    end;
    filter = filter + "not " + IsAccVal( "a" );

    message( "Выбор лицевых счетов" );
    var acccount = SQL_GetNRecsWhere( "daccount$_dbt a", "where " + filter );
    var rs = SQL_ExecuteSimple( "daccount$_dbt a", "a.t_Chapter, a.t_Account, a.t_Code_Currency",
                filter, "a.t_Account" );
    InitProgress( acccount, "", msg );
    var acc = КЛицевойСчет;
    var i = 0;
    while( rs and rs.MoveNext( ) )
        message( rs.Value( "t_Account" ) );
        acc.ИнициализацияАльтернативная( rs.Value( "t_Account" ), rs.Value( "t_Code_Currency" ), rs.Value( "t_Chapter" ) );
        if( acc.АСуществует and acc.Открыт( ПредДатаОтчета, ДатаОтчета ) )
            InsertAccTemp( acc, ExecExp( getAccKindFuncName + "( acc )" ) );
        end;

        i = i + 1;
        UseProgress( i );
    end;
    RemProgress( );
END;

// Создание временного файла по лицевым счетам.
private MACRO CreateAccTemp( )
    var masks;
    MACRO CreateAccTempSpecial( kind )
        const setting = SpecialAccSetting + kind;
        if ( not getRegistryValue( setting, V_STRING, masks, NULL ) or ( ValType( masks ) != V_STRING ) )
            msgbox( "Ошибка! Не задана или неправильно задана настройка|" + setting );
            exit( 1 );
        end;
        CreateAccTempPart( masks, "GetAccKindSpecial" + kind, "Выбор лицевых счетов по 1 разделу, вид " + kind );
    END;

    if ( not getRegistryValue( ClientAccSetting, V_STRING, masks, NULL )
            or ( ValType( masks ) != V_STRING ) )
        msgbox( "Ошибка! Не задана или неправильно задана настройка|" + ClientAccSetting );
        exit( 1 );
    end;
    CreateAccTempPart( masks, "GetAccKindClient", "Выбор лицевых счетов по 1 разделу, виды ТР, ТЕ и ФЛ" );
    CreateAccTempSpecial( "Ф" );
    CreateAccTempSpecial( "Р1" );
    CreateAccTempSpecial( "Р2" );
END;

// Получение Recordset'а с документами
// kind - вид счёта. dir - "С" (списание) или "З" (зачисление)
private MACRO GetMainDocRecordset( kind, dir )
    const validCodes = StrAssemble( Variables1.Codes[dir][kind], "|" );
    kind = Variables1.Kinds[kind];
    dir  = Variables1.Dirs[dir];
    var accfield, dirstr;
    if( dir == "С" )
        accfield = "t_Account_Payer";
        dirstr = "списание";
    else
        accfield = "t_Account_Receiver";
        dirstr = "зачисление";
    end;
    const fields = "tmp.t_CurrCode"
                 + ", doc.t_Sum, doc.t_Date_Carry, doc.t_Account_Payer, doc.t_Account_Receiver, doc.t_Numb_Document"
                 + ", rep_doc.GetCurrOperCodeChecked( doc.t_iApplicationKind, doc.t_ApplicationKey, doc.t_Ground, '" + validCodes +"' ) opcode";
    const order  = "t_CurrCode, opcode, " + accfield + ", t_Date_Carry, t_Sum";
    const filter = "tmp.t_Kind = '" + kind + "'"
                 + " and tmp.t_Account = doc." + accfield
                 + " and tmp.t_Chapter = doc.t_Chapter"
                 + " and tmp.t_CurrCode = doc.t_Code_Currency"
                 + " and " + string( "doc.t_Date_Carry between '", ПредДатаОтчета:f, "' and '", ДатаОтчета:f, "'" );

    var cmdstr = "SELECT " + fields + " FROM " + TempTableName + " tmp, darhdoc$_dbt  doc" + " WHERE " + filter + " ORDER BY " + order;

    return SQL_ExecuteAndGetRs( cmdstr, "Выбор документов по счетам вида " + kind + ", " + dirstr );
END;

// Работает с документом: использует в вычислениях и отдаёт на печать протокола расчёта.
private MACRO ProcessDocument( rs, kind, currindex, dir );
    // вычисления
    var codeidx = FindVal( Variables1.Codes[dir][kind], rs.Value( "opcode" ) );
    if (codeidx < 0)
        return;
    end;
    Variables1.Add( kind, currindex, dir, codeidx, rs.Value( "t_Sum" ) );
    // в протокол расчёта
    PrintProtocolLine( 1, Variables1.Kinds[kind], Variables1.Currs[currindex], Variables1.Dirs[dir], rs );
END;

// Основной макрос
private MACRO Расчёт( )
    // Получить минимальный номер валюты по recordset'ам
    MACRO GetMinCurrency( rss )
        var i = 0;
        var curr;
        while( i < rss.size )
            if( ( rss[i] != NULL ) and ( ( curr == NULL ) or ( rss[i].Value( "t_CurrCode" ) < curr ) ) )
                curr = rss[i].Value( "t_CurrCode" );
            end;

            i = i + 1;
        end;

        return curr;
    END;

    TruncateAccTemp( );
    CreateAccTemp( );   // Создать временный файл по лицевым счетам

    var dir, curr;
    // Придётся брать данные для спис. и зач. одновременно:
    // из-за того, что сортировка в протоколе сначала по валюте, потом по спис./зач.
    var rss = TArray;
    var kind = 0;
    var rscount = 0;    // количество рекордсетов, которые ещё не кончились
    while( kind < Variables1.Kinds.size )
        dir = 0;
        // Получаем Recordset'ы
        while( dir < Variables1.Dirs.size )
            // получить recordset с документами
            rss[dir] = GetMainDocRecordset( kind, dir );
            if( not rss[dir].MoveNext( ) )
                rss[dir] = NULL;
            else
                rscount = rscount + 1;
            end;

            dir = dir + 1;
        end;

        while( rscount > 0 )
            // Выберем новую валюту.
            curr = GetMinCurrency( rss );
            Variables1.Currs[curr] = GetCurrISO( curr );
            // Теперь в каждом Recordset'е пройдёмся по этой валюте.
            dir = 0;
            while( dir < Variables1.Dirs.size )
                while( ( rss[dir] != NULL ) and ( rss[dir].Value( "t_CurrCode" ) == curr ) )
                    ProcessDocument( rss[dir], kind, curr, dir );
                    if( not rss[dir].MoveNext( ) )
                        rss[dir] = NULL;
                        rscount = rscount - 1;
                    end;
                end;

                dir = dir + 1;
            end;
        end;

        kind = kind + 1;
    end;

    // Теперь входящие и исходящие остатки
    var rs;
    kind = 0;
    rs = GetAccRemainder( true );
    while( rs and rs.MoveNext( ) )
        if( Variables1.Kinds[kind] != rs.Value( "t_Kind" ) )
            kind = FindVal( Variables1.Kinds, rs.Value( "t_Kind" ) );
        end;
        if( Variables1.Currs[rs.Value( "t_CurrCode" )] == NULL )
            if( ( RCB_FloorTerm( rs.Value( "t_RestIn" ) ) != $0 ) or ( RCB_FloorTerm( rs.Value( "t_RestOut" ) ) != $0 ) )
                // Случай, когда есть остатки по счетам, но нет документов.
                Variables1.Currs[rs.Value( "t_CurrCode" )] = GetCurrISO( rs.Value( "t_CurrCode" ) );
                Variables1.Set( kind, rs.Value( "t_CurrCode" ), Variables1.Dirs.size + 0, 0, rs.Value( "t_RestIn" ) );
                Variables1.Set( kind, rs.Value( "t_CurrCode" ), Variables1.Dirs.size + 1, 0, rs.Value( "t_RestOut" ) );
            end;
        else
            // В этом случае и нулевые остатки тоже заносим.
            Variables1.Set( kind, rs.Value( "t_CurrCode" ), Variables1.Dirs.size + 0, 0, rs.Value( "t_RestIn" ) );
            Variables1.Set( kind, rs.Value( "t_CurrCode" ), Variables1.Dirs.size + 1, 0, rs.Value( "t_RestOut" ) );
        end;
    end;

    PrintRestsProtocol( 1, true );

    TruncateAccTemp( );
END;

// Основная функция расчёта 1-го раздела
MACRO Main1( )
    Расчёт( );
    message( "Создание переменных" );
    Variables1.CreateAll( );
    message( "Сохранение переменных" );
    Variables1.SaveAll( );
END;
