private class F118Filter(partId : String, attributeId : String)
    var m_partId      = partId;
    var m_attributeId = attributeId;

    macro isSuitable(v)
        return     (v.fieldValue("part").currentAsString   == m_partId)
               and (v.fieldValue("column").currentAsString == m_attributeId);
    end;
end;

private class F118ItogFilter(partId : String, attributeId : String)
    var m_partId      = partId;
    var m_attributeId = attributeId;

    macro isSuitable(v)
        return     (v.fieldValue("part").currentAsString   == m_partId)
               and (v.fieldValue("column").currentAsString == m_attributeId)
               and (v.fieldValue("debtorsGroup").currentAsString == v.fieldValue("debtor").currentAsString);
    end;
end;

private class F118Sorter(itogIterator : RcbValueIterator)
    private var m_itogValueIterator = itogIterator;

    private macro getItog(cv : RcbCompositeValue)
        m_itogValueIterator.moveFirst();

        while (not m_itogValueIterator.isDone())
            if (m_itogValueIterator.currentItem.fieldValue("debtorsGroup").exact == cv.fieldValue("debtorsGroup").exact)
                return m_itogValueIterator.currentItem.fieldValue("moneyValue").exact;
            end;

            m_itogValueIterator.moveNext();
        end;

        return $0.0;
    end;

    private macro getMoneyValue(cv)
        const MAX_VALUE = $9999999999999999999999999;
        
        if (cv.fieldValue("debtorsGroup").exact == cv.fieldValue("debtor").exact)
            return MAX_VALUE;
        end;

        if (cv.fieldValue("debtor").exact == "Прочие")
            return - MAX_VALUE;
        end;

        return cv.fieldValue("moneyValue").exact;
    end;

    macro isLess(lhs, rhs)
        return not ( (getItog(lhs) < getItog(rhs))
                
                or (    (getItog(lhs) == getItog(rhs))
                    and (lhs.fieldValue("debtorsGroup").exact < rhs.fieldValue("debtorsGroup").exact))

                or (    (lhs.fieldValue("debtorsGroup").exact == rhs.fieldValue("debtorsGroup").exact)
                    and (getMoneyValue(lhs) < getMoneyValue(rhs))))

    end;
end;

class (RcbAttributeBase) F118Attribute(id : String, part : RcbPartBase, compositeValue : Object /*RcbCompositeValue или RcbAttributeValue*/)
    initRcbAttributeBase(id, part, compositeValue);

    class TKeyValue(debtorsGroup_ : String, debtor_ : String)
        var debtorsGroup = debtorsGroup_;
        var debtor       = debtor_;
    end;

    private macro getValueField(valueType : Integer) : String
        if   (RCB_VT_MONEY  == valueType)
            return "moneyValue";
        elif (RCB_VT_ITEM   == valueType)
            return "itemValue";
        elif (RCB_VT_STRING == valueType)
            return "stringValue";
        end;

        return null;
    end;
    
    private macro getDebtorsGroupCompositeValue(debtorsGroup : String, debtor : String, valueType : Integer, isFind : Bool) : RcbCompositeValue
        var poolKey = nvl(debtorsGroup, "") + "$DELIMETR$" + nvl(debtor, "");

        m_compositeValuePool.moveFirst();
        while (m_compositeValuePool.moveNext())
            if (m_compositeValuePool.getCurrentItem().first == poolKey)
                return m_compositeValuePool.getCurrentItem().second;
            end;
        end;

        var keyValue = m_attributeCompositeValue.createKeyValue();

        keyValue.fieldValue("part")         = m_part.getId();
        keyValue.fieldValue("column")       = getId();
        keyValue.fieldValue("debtorsGroup") = debtorsGroup;
        keyValue.fieldValue("debtor")       = nvl(debtor, "");

        var compositeValue = m_attributeCompositeValue.findVAlue(keyValue);

        if (compositeValue != null)
            m_compositeValuePool.push_back(TRcbPair(poolKey, compositeValue));
            return compositeValue;
        elif (isFind)
            return null;
        end;

        if (valueType == null)
            runError("Не задан тип значения");
        end;

        compositeValue = m_attributeCompositeValue.addValue();
    
        compositeValue.reset();

        compositeValue.fieldValue("part").exact         = m_part.getId();
        compositeValue.fieldValue("column").exact       = getId();
        compositeValue.fieldValue("debtorsGroup").exact = debtorsGroup;
        compositeValue.fieldValue("debtor").exact       = nvl(debtor, "");
        compositeValue.fieldValue("valuetype").exact    = valueType;

        m_compositeValuePool.push_back(TRcbPair(poolKey, compositeValue));
        
        return compositeValue;
    end;

    macro getKeyValuePool() : RcbArray
        const SUMMARY_ATTRIBUTE_ID = ternary(getPart().getId() == 1, "6", "5");    

        var iterator = m_attributeCompositeValue.createValueIterator();

        var itogIterator = m_attributeCompositeValue.createValueIterator();

        itogIterator.setFilter(F118ItogFilter(getPart().getId(), SUMMARY_ATTRIBUTE_ID));

        iterator.setFilter(F118Filter(getPart().getId(), SUMMARY_ATTRIBUTE_ID));

        iterator.setSortOrder(F118Sorter(itogIterator));
        
        var keyValuePool = RcbArray();

        iterator.moveFirst();
        while (not iterator.isDone())
            keyValuePool.push_back(TKeyValue(iterator.currentItem.fieldValue("debtorsGroup").currentAsString,
                                             iterator.currentItem.fieldValue("debtor").currentAsString));

            iterator.moveNext();
        end;

        return keyValuePool;
    end;
    
    private macro getRcbValue(debtorsGroup : String, debtor : String, valueType : Integer, isFind : Bool) : RcbValue
        var compositeValue = getDebtorsGroupCompositeValue(debtorsGroup, debtor, valueType, isFind);

        if (isFind and (compositeValue == null))
            return null;
        end;

        return compositeValue.fieldValue(getValueField(compositeValue.fieldValue("valuetype").current));
    end;

    macro getValue(debtorsGroup : String, debtor : String, valueType : Integer) /*тип определяется параметром valueType*/
        return getRcbValue(debtorsGroup, debtor, valueType).exact;
    end;

    macro getScaledValue(debtorsGroup : String, debtor : String, valueType : Integer) /*тип определяется параметром valueType*/
        return getRcbValue(debtorsGroup, debtor, valueType).scaled;
    end;

    macro findValue(debtorsGroup : String, debtor : String, valueType : Integer) /*тип определяется параметром valueType*/
        var val = getRcbValue(debtorsGroup, debtor, valueType, true);

        if (val == null)
            return null;
        end;

        return val.exact;
    end;

    macro findScaledValue(debtorsGroup : String, debtor : String, valueType : Integer) /*тип определяется параметром valueType*/
        var val = getRcbValue(debtorsGroup, debtor, valueType, true);

        if (val == null)
            return null;
        end;

        return val.scaled;
    end;

    macro getValueAsString(debtorsGroup : String, debtor : String) : String
        var val = getRcbValue(debtorsGroup, debtor, null, true);

        if ((val == null) or val.isUndefined())
            return null;
        end;

        return val.currentAsString;
    end;

    macro setValue(debtorsGroup : String, debtor : String, value : Variant, valueType : Integer) /*тип определяется параметром valueType*/
        var val = getRcbValue(debtorsGroup, debtor, valueType);

        if (isEqClass("TValue", value))
            val.exact  = value.exact;
            val.scaled = value.scaled;
        else
            if (value != null)
                val.exact = value;
                val.recalculateScaled();
            else
                val.setUndefined;
            end;
        end;
        
        return this;
    end;

    /** 
     * установить округленное значение
     *
     * @param keyValue  ключевое значение атрибута
     * @param value     значение для присваивания
     * @return ссылка на себя
     * @See RcbAttributeBase
     */
    macro setScaledValue(keyValue : Object, value : Double) : RcbAttributeBase
        getRcbValue(keyValue.debtorsGroup, keyValue.debtor, RCB_VT_MONEY).scaled = value;

        return this;
    end;

    //пришлось ввести дополнительный метод, так как иначе при обращении к plus() внутри переопределенного метода, вызывается метод базового класса
    private macro plus_(debtorsGroup : String, debtor : String, value : Variant) : RcbAttributeBase
        var val = getRcbValue(debtorsGroup, debtor);

        if (isEqClass("TValue", value))
            val.exact  = val.exact + value.exact;
            val.scaled = val.exact + value.scaled;
        else
            val.exact = val.exact + value;
            val.recalculateScaled();
        end;

        if (debtorsGroup != debtor)
            plus_(debtorsGroup, debtorsGroup, value);
        end;
        
        return this;
    end;

    macro plus(debtorsGroup : String, debtor : String, value : Variant) : RcbAttributeBase
        return plus_(debtorsGroup, debtor, value);
    end;

    macro minus(debtorsGroup : String, debtor : String, value) : RcbAttributeBase
        var val = getRcbValue(debtorsGroup, debtor);

        if (isEqClass("TValue", value))
            plus(debtorsGroup, debtor, TValue(-value.exact, -value.scaled));
        else
            plus(debtorsGroup, debtor, -value);
        end;
        
        return this;
    end;
end;