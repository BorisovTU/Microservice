/*
$Name: ex_kl501.mac
$Module: Регламентируемая отчетность
$Description: Форма 501. Экспорт.
*/

/*─────────────────────────────────────────────────────────────────────────────────────────────────┐
  RS-Bank V6                                                                        R-Style Softlab
  Файл подсистемы "Регламентируемая отчетность"

  Экспорт в kliko.exe для формы 501.

  Создан: 17.10.2006 - Ser.
└─────────────────────────────────────────────────────────────────────────────────────────────────*/
/*
 *  Общебанковские интеры и модули
 */

/*
 *  Интеры и модели подсистемы
 */
import rcbCoreInter;
import ReptcbInter;

import rsbDataSet;
import param;

import logfile;/*10 May 07 Thu 10:11:50 Malakhova Irina 104212*/
import lib_exp;
import rcbconst;
import RcbWebCommon;

import RcbKlikoView;
import RcbProtocolView;

import p_f501;      //для совместного использования классов фильтрации и сортировки

private const PROTOCOL_NAME = "f501.txt";

/***************************************************************************************************
 *  Класс экспорта отчета в kliko.exe
 **************************************************************************************************/
/*10 May 07 Thu 13:19:58 Malakhova Irina 104212*/
private class TExportProtocol(dateAndTimeOfExportBeginning,
                              dateAndTimeOfExportEnding,
                              numberOfExportStrings,
                              numberOfExportSpecialStrings,
                              exportFileName,
                              descriptorInfo)

    private var m_protocolName;
    private var m_protocolFolder;
    private var m_dateAndTimeOfExportBeginning;
    private var m_dateAndTimeOfExportEnding;
    private var m_numberOfExportStrings;
    private var m_exportFileName;
    private var m_numberOfExportSpecialStrings;
    private var m_descriptorInfo;

    local macro constructor(dateAndTimeOfExportBeginning,
                            dateAndTimeOfExportEnding,
                            numberOfExportStrings,
                            numberOfExportSpecialStrings,
                            exportFileName,
                            descriptorInfo)

        m_protocolName                 = PROTOCOL_NAME;
        m_protocolFolder               = ReturnDirString( "TEXTDIR", "TXTFILE" );
        m_dateAndTimeOfExportBeginning = dateAndTimeOfExportBeginning;
        m_dateAndTimeOfExportEnding    = dateAndTimeOfExportEnding;
        m_numberOfExportStrings        = numberOfExportStrings;
        m_numberOfExportSpecialStrings = numberOfExportSpecialStrings;
        m_exportFileName               = exportFileName;
        m_descriptorInfo               = descriptorInfo;
    end;

    macro execute()
        var protocolView  = TProtocolView("ПРОТОКОЛ ЭКСПОРТА В KLIKO.EXE", RcbApplication().currentReport.form.id);
        protocolView.setProtocolOutput();
        protocolView.printHead();
        protocolView.printLine("Файл описателя: " + m_descriptorInfo);
        protocolView.printLine("Файл экспорта: " + m_exportFileName + "\n");
        protocolView.printLine("Выгружено строк: " + String(m_numberOfExportStrings + m_numberOfExportSpecialStrings) + ", в т.ч.:");
        protocolView.printLine("    количество служебных строк: " + String(m_numberOfExportSpecialStrings));
        protocolView.printLine("    количество содержательных строк: " + String(m_numberOfExportStrings));
        protocolView.resetProtocolOutput();
        protocolView.show();
    end;

    constructor(dateAndTimeOfExportBeginning,
                dateAndTimeOfExportEnding,
                numberOfExportStrings,
                numberOfExportSpecialStrings,
                exportFileName,
                descriptorInfo);
end;

FILE exportFile() txt write;

private class ExportKlikoReport501()
    private var m_dateAndTimeOfExportBeginning;
    private var m_dateAndTimeOfExportEnding;
    private var m_numberOfExportStrings = 0;
    private var numberOfExportSpecialStrings = 0;

    private macro incNumberOfExportStrings()
        m_numberOfExportStrings = m_numberOfExportStrings + 1;
    end;

    macro getDescriptorInfo()
        return "f501_15.pak от 30.06.2010";
    end;

    macro getNumberOfExportSpecialStrings()
        return numberOfExportSpecialStrings;
    end;

    macro getNumberOfExportStrings()
        return m_numberOfExportStrings;
    end;

    private macro setDateAndTimeOfExportBeginning()
         var timeString;
         /*делаем дату с ведущим нулем*/
         timeString = trim(subStr(string(Time():f), 1, strlen(string(Time():f)) - 3));
         if (strLen(timeString) == 4)
             timeString = "0" + timeString;
         end;
         m_dateAndTimeOfExportBeginning = string(date():f) + " " + timeString;
    end;

    macro getDateAndTimeOfExportBeginning()
        return m_dateAndTimeOfExportBeginning;
    end;

    private macro setDateAndTimeOfExportEnding()
         var timeString;

         timeString = trim(subStr(string(Time():f), 1, strlen(string(Time():f)) - 3));
         if (strLen(timeString) == 4)
             timeString = "0" + timeString;
         end;

         m_dateAndTimeOfExportEnding = string(date():f) + " " + timeString;
    end;

    macro getDateAndTimeOfExportEnding()
        return m_dateAndTimeOfExportEnding;
    end;

    private macro getPathAndNameFiles()

        private macro getFileName()
            var exportFileName;
            var day;
            var month;
            var year;

            dateSplit((RcbApplication().currentReport.context.period.EndDate + 1), day, month, year);

            exportFileName = получитьКаталогЭкспорта() + "\\" + strLpad(String(day),   2, "0")
                                                       + strLpad(String(month), 2, "0")
                                                       + String(year)
                                                       + "Kliko"
                                                       + "." + strsubst(RcbApplication().currentReport.form.id, "Форма ", "");

            return exportFileName;
        end;

        return ( getFileName() );
    end;

    /*сделала видимую обертку*/
    macro getExportFileName()
        return getPathAndNameFiles();
    end;

    private macro printHeader(serviceString : string)
        defaultParm(serviceString, "<F501>");
        numberOfExportSpecialStrings = numberOfExportSpecialStrings + 1;
        insert(exportFile, serviceString);
    end;

    private macro printProtocolWithError(errorMessage)
        var nextDate;

        nextDate       = string((RcbApplication().currentReport.context.period.EndDate + 1):f);

        printLn("Дата и время начала выгрузки: " + m_dateAndTimeOfExportBeginning + " Протокол экспорта данных формы 501 на " + nextDate);
        printLn("Ошибка выгрузки: " + errorMessage);
    end;

    private macro getRepo(isrepoaccount)
        if(isrepoaccount == 0)
            return "";
        else
            return "*";
        end;
    end;

    private macro getDate(perfDate)
        var day, month, year;
        var dayStr, monthStr, yearStr;

        if   (perfDate == "")
            return "0";
        elif (perfDate == "д/в")
            return "-1";
        else
            DateSplit(Date(trim(perfDate)), day, month, year);
            dayStr   = String(day:2:o);
            monthStr = String(month:2:o);
            yearStr  = String(year:4:o);
            return yearStr+monthStr+dayStr;
        end;
    end;

    private macro toBracet(value, isFirst)
        if (isFirst)
            return ("\"" + string(value) + "\"");
        else
            return (", " + "\"" + string(value) + "\"");
        end;
    end;

    private macro outputString()/* список входящих параметров определяется вызовом */
        var strForExport = "";
        var i = 1;
        var value, isResident;
        var isFirst = true;

        while(getParm(i, value))
            if(i == 15)
                getParm(4, isResident);
                if(isResident == 643)
                    value = "1";
                else
                    value = "2";
                end;
            end;
            strForExport = strForExport + toBracet(value, isFirst);
            isFirst = false;
            i = i + 1;
        end;

        numberOfExportSpecialStrings = numberOfExportSpecialStrings + 1;
        insert(exportFile, strForExport);
    end;

    private macro printString(num, shortName, regNumber, codeCountry, balance, account, beginRest, debet, credit, endRest, perfDate, rate, isRepoAccount)

        outputString( shortName,
                      subStr(regNumber, 1, 9),
                      subStr(regNumber, 9, 3),
                      codeCountry,
                      getRepo(isrepoaccount),
                      balance,
                      account,
                      beginRest,
                      debet,
                      credit,
                      endRest,
                      getDate(perfDate),
                      rate,
                      "","","1","1","");/*кол-во параметров стандартно(для kliko.exe), поэтому передаем пустые строки*/

        incNumberOfExportStrings();
    end;

    private macro outputPartData(partNumber:integer)
        var varName  = "Ф501_" + string(partNumber);
        var iterator = rcbApplication().currentReport().attributeValue(varName).createValueIterator();

        iterator.setFilter(TFilter());
        iterator.setSortOrder(TSorter());
        iterator.moveFirst();
        var i = 0, structValue;
        while (not iterator.isDone())
            structValue = iterator.currentItem();
            i = i + 1;
            printString(i,
                        strsubst(structValue.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                        structValue.fieldValue("РегНом").currentAsString,
                        structValue.fieldValue("КодСтр").currentAsString,
                        structValue.fieldValue("НомБС").currentAsString,
                        structValue.fieldValue("ОтчНомЛС").currentAsString,
                        structValue.fieldValue("ОстВход").currentAsString,
                        structValue.fieldValue("ОбДебет").currentAsString,
                        structValue.fieldValue("ОбКредит").currentAsString,
                        structValue.fieldValue("ОстИсход").currentAsString,
                        structValue.fieldValue("ДатаИспОб").currentAsString,
                        structValue.fieldValue("ПрСтавка").current,
                        Int(structValue.fieldValue("ПризнакРЕПО").exact));
            iterator.moveNext();
        end;
        return (i != 0);
    end;

    private macro isEmptyReport()
        var iterator1 = rcbApplication().currentReport().attributeValue("Ф501_1").createValueIterator();
        var iterator2 = rcbApplication().currentReport().attributeValue("Ф501_2").createValueIterator();

        iterator1.setFilter(TFilter());
        iterator2.setFilter(TFilter());

        return ((iterator1.count + iterator2.count) == 0);
    end;

    macro execute()
        var exportFileName;

        exportFileName = getPathAndNameFiles();

        setDateAndTimeOfExportBeginning();

        if(not open(exportFile, exportFileName))
            printProtocolWithError("Невозможно открыть файл экспорта" + exportFileName);
            exit(0);
        end;

        printHeader();

        if (isEmptyReport())
            numberOfExportSpecialStrings = numberOfExportSpecialStrings + 1;
            insert(exportFile, "Нет данных для экспорта");
        else
            outputPartData(1);
            outputPartData(2);
        end;

        close(exportFile);

        setDateAndTimeOfExportEnding();
    end;
end;

private class (ExportKlikoReport501) ExportKlikoReport501_2332()
    initExportKlikoReport501();

    private macro getSign(isSign)
        if(isSign == 1)
            return "*";
        else
            return "";
        end;
    end;

    private macro outputString()/* список входящих параметров определяется вызовом */
        var strForExport = "";
        var i            = 1;
        var isFirst      = true;
        var value, isResident;

        while(getParm(i, value))
            strForExport = strForExport + toBracet(value, isFirst);
            isFirst = false;
            i = i + 1;
        end;
        insert(exportFile, strForExport);
    end;

    private macro printString(num, shortName, regNumber, codeCountry, balance, account, beginRest, debet, credit, endRest, perfDate, rate, isRepoAccount, isGD, singDepending, prolongationAmount, explanation)
        outputString( shortName,
                      subStr(regNumber, 1, 8),
                      subStr(regNumber, 9, 3),
                      codeCountry,
                      getSign(isRepoAccount),
                      getSign(isGD),
                      ternary((singDepending == "Undefined"), "", singDepending),
                      prolongationAmount,
                      ternary((explanation == "Undefined"), "", explanation),
                      balance,
                      account,
                      beginRest,
                      debet,
                      credit,
                      endRest,
                      getDate(perfDate),
                      ternary((isGD == 1), "", rate),
                      "","");/*кол-во параметров стандартно(для kliko.exe), поэтому передаем пустые строки*/

        incNumberOfExportStrings();
    end;

    private macro outputPartData(partNumber:integer)
        var varName             = "Ф501_" + string(partNumber);
        var varNameManualInput  = "Ф501_" + string(partNumber) + "ввод";
        var iterator            = rcbApplication().currentReport().attributeValue(varName).createValueIterator();
        var iteratorManualInput = rcbApplication().currentReport().attributeValue(varNameManualInput).createValueIterator();

        iterator.setFilter(TFilter());
        iterator.setSortOrder(TSorter());
        iterator.moveFirst();

        iteratorManualInput.setFilter(TFilterManualInput());
        iteratorManualInput.setSortOrder(TSorterManualInput());
        iteratorManualInput.moveFirst();

        var i = 0, structValue;
        while (not iterator.isDone())
            structValue = iterator.currentItem();

            i = i + 1;
            printString(i,
                        strsubst(structValue.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                        structValue.fieldValue("РегНом").currentAsString,
                        structValue.fieldValue("КодСтр").currentAsString,
                        structValue.fieldValue("НомБС").currentAsString,
                        structValue.fieldValue("НомЛС").currentAsString,
                        structValue.fieldValue("ОстВход").currentAsString,
                        structValue.fieldValue("ОбДебет").currentAsString,
                        structValue.fieldValue("ОбКредит").currentAsString,
                        structValue.fieldValue("ОстИсход").currentAsString,
                        structValue.fieldValue("ДатаИспОб").currentAsString,
                        structValue.fieldValue("ПрСтавка").current,
                        Int(structValue.fieldValue("ПризнакРЕПО").exact),
                        Int(structValue.fieldValue("ПризнакГД").exact),
                        structValue.fieldValue("ПризнакЗависимости").currentAsString,
                        ternary((Int(structValue.fieldValue("КолПролонгаций").exact) < 0) or (Int(structValue.fieldValue("КолПролонгаций").exact) > 32767), "", Int(structValue.fieldValue("КолПролонгаций").exact)),
                        structValue.fieldValue("Пояснения").currentAsString);
            iterator.moveNext();
        end;
        var structValueManualInput;
        while (not iteratorManualInput.isDone())
            structValueManualInput = iteratorManualInput.currentItem();
            i = i + 1;
            printString(i,
                        strsubst(structValueManualInput.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                        structValueManualInput.fieldValue("РегНом").currentAsString,
                        structValueManualInput.fieldValue("КодСтр").currentAsString,
                        structValueManualInput.fieldValue("НомБС_ввод").currentAsString,
                        structValueManualInput.fieldValue("НомЛС_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОстВход_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОбДебет_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОбКредит_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОстИсход_ввод").currentAsString,
                        structValueManualInput.fieldValue("ДатаИспОб_ввод").currentAsString,
                        structValueManualInput.fieldValue("ПрСтавка_ввод").current,
                        0,
                        0,
                        ternary(structValueManualInput.fieldValue("ххх_ввод").currentAsString == "***", "*", ""),
                        Int(NVL(structValueManualInput.fieldValue("КолПролонгаций_ввод").exact, 0)),
                        structValueManualInput.fieldValue("Пояснения_ввод").currentAsString);
            iteratorManualInput.moveNext();
        end;
        return (i != 0);
    end;
end;

private class (ExportKlikoReport501_2332) ExportKlikoReport501_4212()
    initExportKlikoReport501_2332();

    macro getDescriptorInfo()
        return "F501_19.pak от 31.01.2017";
    end;

    private macro printString(num, shortName, regNumber, codeCountry, balance, account, beginRest, debet, credit, endRest, perfDate, rate,
                              isRepoAccount, isGD, isClientResident, singDepending, prolongationAmount, explanation,
                              onerousClaim,identifier,onerousClaimCategory,restLinkedAccount,redemptionDate,
                              onerousSign,swiftDepartment,conditionalCode,otherDecoding)
        outputString( shortName,
                      subStr(regNumber, 1, 8),
                      subStr(regNumber, 9, 3),
                      codeCountry,
                      getSign(isRepoAccount),
                      getSign(isGD),
//                      ternary((singDepending == "Undefined"), "", singDepending),
//                      prolongationAmount,
                      ternary((explanation == "Undefined"), "", explanation),
                      balance,
                      account,
                      beginRest,
                      debet,
                      credit,
                      endRest,
                      getDate(perfDate),
                      ternary((isGD == 1), "", rate),
                      onerousSign,
                      conditionalCode,
                      onerousClaim,
                      identifier,
                      swiftDepartment,
                      onerousClaimCategory,
                      otherDecoding,
                      restLinkedAccount,
                      redemptionDate,
                      "",
                      ternary(isClientResident == 1, "1", "2"));/*кол-во параметров стандартно(для kliko.exe), поэтому передаем пустые строки*/

        incNumberOfExportStrings();
    end;

    private macro outputPartData(partNumber:integer)
        var varName             = "Ф501_" + string(partNumber);
        var varNameManualInput  = "Ф501_" + string(partNumber) + "ввод";
        var iterator            = rcbApplication().currentReport().attributeValue(varName).createValueIterator();
        var iteratorManualInput = rcbApplication().currentReport().attributeValue(varNameManualInput).createValueIterator();

        iterator.setFilter(TFilter());
        iterator.setSortOrder(TSorter());
        iterator.moveFirst();

        iteratorManualInput.setFilter(TFilterManualInput());
        iteratorManualInput.setSortOrder(TSorterManualInput());
        iteratorManualInput.moveFirst();

        var onerousClaim         = "";
        var identifier           = "";
        var onerousClaimCategory = "";
        var restLinkedAccount    = "";
        var redemptionDate       = "";

        var onerousSign     = "";
        var swiftDepartment = "";
        var conditionalCode = "";
        var otherDecoding   = "";

        var i = 0, structValue;
        while (not iterator.isDone())
            structValue = iterator.currentItem();
            i = i + 1;

            if (partNumber == 1)
                onerousClaim         = structValue.fieldValue("ЛицоПоОбрем").currentAsString;
                identifier           = structValue.fieldValue("ИдентификаторОбрем").currentAsString;
                onerousClaimCategory = structValue.fieldValue("ВидОбрем").currentAsString;
                restLinkedAccount    = structValue.fieldValue("ОстатокПоСчетуОбрем").currentAsString;
                redemptionDate       = structValue.fieldValue("ДатаПогашения").currentAsString;

                onerousSign          = structValue.fieldValue("ПризнакОбременения").currentAsString;
                swiftDepartment      = structValue.fieldValue("ФилиалСВИФТ").currentAsString;
                conditionalCode      = structValue.fieldValue("УсловныйКод").currentAsString;
                otherDecoding        = structValue.fieldValue("ИноеРасшифровка").currentAsString;
            end;

            printString(i,
                        strsubst(structValue.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                        structValue.fieldValue("РегНом").currentAsString,
                        structValue.fieldValue("КодСтр").currentAsString,
                        structValue.fieldValue("НомБС").currentAsString,
                        structValue.fieldValue("НомЛС").currentAsString,
                        structValue.fieldValue("ОстВход").currentAsString,
                        structValue.fieldValue("ОбДебет").currentAsString,
                        structValue.fieldValue("ОбКредит").currentAsString,
                        structValue.fieldValue("ОстИсход").currentAsString,
                        structValue.fieldValue("ДатаИспОбKliko").currentAsString,
                        structValue.fieldValue("ПрСтавка").current,
                        Int(structValue.fieldValue("ПризнакРЕПО").exact),
                        Int(structValue.fieldValue("ПризнакГД").exact),
                        Int(NVL(structValue.fieldValue("ПризнакРезидентности").exact, ternary(structValue.fieldValue("КодСтр").currentAsString == "643", 1, 0))),
                        structValue.fieldValue("ПризнакЗависимости").currentAsString,
                        ternary((Int(structValue.fieldValue("КолПролонгаций").exact) < 0) or (Int(structValue.fieldValue("КолПролонгаций").exact) > 32767), "", Int(structValue.fieldValue("КолПролонгаций").exact)),
                        structValue.fieldValue("Пояснения").currentAsString,

                        onerousClaim,
                        identifier,
                        onerousClaimCategory,
                        ternary(restLinkedAccount == "0", "", restLinkedAccount),
                        redemptionDate,

                        onerousSign,
                        swiftDepartment,
                        conditionalCode,
                        otherDecoding);
            iterator.moveNext();
        end;

        var structValueManualInput;
        while (not iteratorManualInput.isDone())
            structValueManualInput = iteratorManualInput.currentItem();
            i = i + 1;

            if (partNumber == 1)
                onerousClaim         = structValueManualInput.fieldValue("ЛицоПоОбрем_ввод").currentAsString;
                identifier           = structValueManualInput.fieldValue("ИдентификаторОбрем_ввод").currentAsString;
                onerousClaimCategory = structValueManualInput.fieldValue("ВидОбрем_ввод").currentAsString;
                restLinkedAccount    = structValueManualInput.fieldValue("ОстатокПоСчетуОбрем_ввод").currentAsString;
                redemptionDate       = structValueManualInput.fieldValue("ДатаПогашения_ввод").currentAsString;

                onerousSign          = structValueManualInput.fieldValue("ПризнакОбременения_ввод").currentAsString;
                swiftDepartment      = structValueManualInput.fieldValue("ФилиалСВИФТ_ввод").currentAsString;
                conditionalCode      = structValueManualInput.fieldValue("УсловныйКод_ввод").currentAsString;
                otherDecoding        = structValueManualInput.fieldValue("ИноеРасшифровка_ввод").currentAsString;
            end;

            printString(i,
                        strsubst(structValueManualInput.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                        structValueManualInput.fieldValue("РегНом").currentAsString,
                        structValueManualInput.fieldValue("КодСтр").currentAsString,
                        structValueManualInput.fieldValue("НомБС_ввод").currentAsString,
                        structValueManualInput.fieldValue("НомЛС_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОстВход_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОбДебет_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОбКредит_ввод").currentAsString,
                        structValueManualInput.fieldValue("ОстИсход_ввод").currentAsString,
                        structValueManualInput.fieldValue("ДатаИспОб_ввод").currentAsString,
                        structValueManualInput.fieldValue("ПрСтавка_ввод").current,
                        0,
                        0,
                        Int(NVL(structValueManualInput.fieldValue("ПризнакРезидентности").exact, ternary(structValueManualInput.fieldValue("КодСтр").currentAsString == "643", 1, 0))),
                        ternary(structValueManualInput.fieldValue("ххх_ввод").currentAsString == "***", "*", ""),
                        Int(NVL(structValueManualInput.fieldValue("КолПролонгаций_ввод").exact, 0)),
                        structValueManualInput.fieldValue("Пояснения_ввод").currentAsString,

                        onerousClaim,
                        identifier,
                        onerousClaimCategory,
                        ternary(restLinkedAccount == "0", "", restLinkedAccount),
                        redemptionDate,

                        onerousSign,
                        swiftDepartment,
                        conditionalCode,
                        otherDecoding);

            iteratorManualInput.moveNext();
        end;

        return (i != 0);
    end;
end;

private class (ExportKlikoReport501_4212) ExportKlikoReport501_Т1_30_1_01_72551()
    initExportKlikoReport501_4212();

    macro getDescriptorInfo()
        return "F501_20.pak от 30.06.2017";
    end;

    private macro printString(num, shortName, regNumber, codeCountry, balance, account, beginRest, debet, credit, endRest, perfDate, rate,
                              isRepoAccount, isGD, isClientResident, singDepending, prolongationAmount, explanation,
                              onerousClaim,identifier,onerousClaimCategory,restLinkedAccount,redemptionDate,
                              onerousSign,swiftDepartment,conditionalCode,otherDecoding)
        var filialCode;
        var klikoRegNumber;
        var posHyphen;
        var posSlash;

        if (isClientResident == 1)
            posHyphen = index(regNumber, "-");

            if (posHyphen)
                klikoRegNumber = subStr(regNumber, 1, posHyphen - 1);

                posSlash = index(regNumber, "/");
                if (posSlash)
                    filialCode = subStr(regNumber, posHyphen + 1, (posSlash - 1) - posHyphen);
                else
                    filialCode = subStr(regNumber, posHyphen + 1, strLen(regNumber) - posHyphen);
                end;
            else
                klikoRegNumber = regNumber;
                filialCode     = "";
            end;
        else
            klikoRegNumber = subStr(regNumber, 1, 8);
            filialCode     = subStr(regNumber, 9, 3);
        end;

        outputString(shortName,
                     klikoRegNumber,
                     filialCode,
                     codeCountry,
                     getSign(isRepoAccount),
                     getSign(isGD),
                     ternary((explanation == "Undefined"), "", explanation),
                     balance,
                     account,
                     beginRest,
                     debet,
                     credit,
                     endRest,
                     getDate(perfDate),
                     ternary((isGD == 1), "", rate),
                     onerousSign,
                     conditionalCode,
                     onerousClaim,
                     identifier,
                     swiftDepartment,
                     onerousClaimCategory,
                     otherDecoding,
                     restLinkedAccount,
                     redemptionDate,
                     "",
                     ternary(isClientResident == 1, "1", "2"),
                     "S",
                     "1",
                     "1",
                     "");

        incNumberOfExportStrings();
    end;
end;

private class (ExportKlikoReport501_Т1_30_1_01_72551) ExportKlikoReport501_Т1_30_1_01_81913()
    initExportKlikoReport501_Т1_30_1_01_72551();

    macro getDescriptorInfo()
        return "F501_21.pak от 25.07.2017";
    end;

    private macro printString(num, shortName, regNumber, codeCountry, balance, account, beginRest, debet, credit, endRest, perfDate, rate,
                              isRepoAccount, isGD, isClientResident, singDepending, prolongationAmount, explanation,
                              onerousClaim,identifier,onerousClaimCategory,restLinkedAccount,redemptionDate,
                              onerousSign,swiftDepartment,conditionalCode,otherDecoding)
        var filialCode;
        var klikoRegNumber;
        var posHyphen;
        var posSlash;

        if (isClientResident == 1)
            posHyphen = index(regNumber, "-");

            if (posHyphen)
                klikoRegNumber = subStr(regNumber, 1, posHyphen - 1);

                posSlash = index(regNumber, "/");
                if (posSlash)
                    filialCode = subStr(regNumber, posHyphen + 1, (posSlash - 1) - posHyphen);
                else
                    filialCode = subStr(regNumber, posHyphen + 1, strLen(regNumber) - posHyphen);
                end;
            else
                klikoRegNumber = regNumber;
                filialCode     = "";
            end;
        else
            klikoRegNumber = subStr(regNumber, 1, 8);
            filialCode     = subStr(regNumber, 9, 3);
        end;

        outputString(shortName,
                     klikoRegNumber,
                     filialCode,
                     codeCountry,
                     getSign(isRepoAccount),
                     getSign(isGD),
                     ternary((explanation == "Undefined"), "", explanation),
                     balance,
                     account,
                     beginRest,
                     debet,
                     credit,
                     endRest,
                     getDate(perfDate),
                     ternary((isGD == 1), "", rate),
                     onerousSign,
                     conditionalCode,
                     onerousClaim,
                     ternary(swiftDepartment != "", substr(identifier, 1, 8), identifier),
                     swiftDepartment,
                     onerousClaimCategory,
                     otherDecoding,
                     restLinkedAccount,
                     redemptionDate,
                     "",
                     ternary(isClientResident == 1, "1", "2"),
                     "S",
                     "1",
                     "1",
                     "");

        incNumberOfExportStrings();
    end
end;

private class (ExportKlikoReport501_Т1_30_1_01_81913) ExportKlikoReport501_Т1_77_1_01_117760()
    initExportKlikoReport501_Т1_30_1_01_81913();

    macro getDescriptorInfo()
        return "F501_24.pak от 29.10.2018";
    end;

    private macro outputString()
        var strForExport = "";
        var i            = 1;
        var isFirst      = true;
        var value;

        while(getParm(i, value))
            strForExport = strForExport + toBracet(ternary(valType(value) == V_STRING, strsubst(value, "\"", "~^"), value), isFirst);
            isFirst = false;
            i = i + 1;
        end;
        insert(exportFile, strForExport);
    end;
end;

private class (ExportKlikoReport501_Т1_77_1_01_117760) ExportKlikoReport501_5586()
    initExportKlikoReport501_Т1_77_1_01_117760();

    macro getDescriptorInfo()
        return "F501_25a.pak от 12.02.2021";
    end;
end;

private class (ExportKlikoReport501_5586) ExportKlikoReport501_5456()
    initExportKlikoReport501_5586();

    macro getDescriptorInfo()
        return "F501_04_for.pak от 16.02.2020";
    end;

    private macro isEmptyReport()
        var iterator1 = rcbApplication().currentReport().attributeValue("Ф501_1").createValueIterator();
        var iterator2 = rcbApplication().currentReport().attributeValue("Ф501_2").createValueIterator();
        var iterator3 = rcbApplication().currentReport().attributeValue("Ф501_3").createValueIterator();

        iterator1.setFilter(TFilter());
        iterator2.setFilter(TFilter());
        iterator3.setFilter(TFilter());

        return ((iterator1.count + iterator2.count + iterator3.count) == 0);
    end;

    macro execute()
        var exportFileName;

        exportFileName = getPathAndNameFiles();

        setDateAndTimeOfExportBeginning();

        if(not open(exportFile, exportFileName))
            printProtocolWithError("Невозможно открыть файл экспорта" + exportFileName);
            exit(0);
        end;

        printHeader();

        if (isEmptyReport())
            numberOfExportSpecialStrings = numberOfExportSpecialStrings + 1;
            insert(exportFile, "Нет данных для экспорта");
        else
            outputPartData(1);
            outputPartData(2);
            printHeader("<F501_R3>");
            outputPartData(3);
        end;

        close(exportFile);

        setDateAndTimeOfExportEnding();
    end;

    private macro getDate(perfDate, partNumber)
        var day, month, year;
        var dayStr, monthStr, yearStr;

        if   (partNumber == 3)
            return "";
        elif (perfDate == "")
            return "0";
        elif (perfDate == "д/в")
            return "-1";
        else
            DateSplit(Date(trim(perfDate)), day, month, year);
            dayStr   = String(day:2:o);
            monthStr = String(month:2:o);
            yearStr  = String(year:4:o);
            return yearStr+monthStr+dayStr;
        end;
    end;

    private macro printString(num, partNumber, shortName, regNumber, codeCountry, balance, account, beginRest, debet, credit, endRest, perfDate, rate,
                              isRepoAccount, isGD, isClientResident, singDepending, prolongationAmount, explanation,
                              onerousClaim,identifier,onerousClaimCategory,restLinkedAccount,redemptionDate,
                              onerousSign,swiftDepartment,conditionalCode,otherDecoding)
        var filialCode;
        var klikoRegNumber;
        var posHyphen;
        var posSlash;

        if (isClientResident == 1)
            posHyphen = index(regNumber, "-");

            if (posHyphen)
                klikoRegNumber = subStr(regNumber, 1, posHyphen - 1);

                posSlash = index(regNumber, "/");
                if (posSlash)
                    filialCode = subStr(regNumber, posHyphen + 1, (posSlash - 1) - posHyphen);
                else
                    filialCode = subStr(regNumber, posHyphen + 1, strLen(regNumber) - posHyphen);
                end;
            else
                klikoRegNumber = regNumber;
                filialCode     = "";
            end;
        else
            klikoRegNumber = subStr(regNumber, 1, 8);
            filialCode     = subStr(regNumber, 9, 3);
        end;

        outputString(shortName,
                     klikoRegNumber,
                     filialCode,
                     codeCountry,
                     getSign(isRepoAccount),
                     getSign(isGD),
                     ternary((explanation == "Undefined"), "", explanation),
                     balance,
                     account,
                     beginRest,
                     debet,
                     credit,
                     endRest,
                     getDate(perfDate, partNumber),
                     ternary((isGD == 1), "", rate),
                     onerousSign,
                     conditionalCode,
                     onerousClaim,
                     ternary(swiftDepartment != "", substr(identifier, 1, 8), identifier),
                     swiftDepartment,
                     onerousClaimCategory,
                     otherDecoding,
                     restLinkedAccount,
                     redemptionDate,
                     ternary(partNumber == 3, "3",""),
                     ternary(partNumber == 3, "1", ternary(isClientResident == 1, "1", "2")),
                     "S",
                     "1",
                     "1",
                     "");

        incNumberOfExportStrings();
    end;

    private macro outputPartData(partNumber:integer)
        var varName             = "Ф501_" + string(partNumber);
        var iterator            = rcbApplication().currentReport().attributeValue(varName).createValueIterator();

        iterator.setFilter(TFilter());
        iterator.setSortOrder(TSorter());
        iterator.moveFirst();

        if (partNumber != 3)
            var varNameManualInput  = "Ф501_" + string(partNumber) + "ввод";
            var iteratorManualInput = rcbApplication().currentReport().attributeValue(varNameManualInput).createValueIterator();

            iteratorManualInput.setFilter(TFilterManualInput());
            iteratorManualInput.setSortOrder(TSorterManualInput());
            iteratorManualInput.moveFirst();
        end;

        var onerousClaim         = "";
        var identifier           = "";
        var onerousClaimCategory = "";
        var restLinkedAccount    = "";
        var redemptionDate       = "";

        var onerousSign     = "";
        var swiftDepartment = "";
        var conditionalCode = "";
        var otherDecoding   = "";

        var i = 0, structValue;
        while (not iterator.isDone())
            structValue = iterator.currentItem();
            i = i + 1;

            if (partNumber == 1)
                onerousClaim         = structValue.fieldValue("ЛицоПоОбрем").currentAsString;
                identifier           = structValue.fieldValue("ИдентификаторОбрем").currentAsString;
                onerousClaimCategory = structValue.fieldValue("ВидОбрем").currentAsString;
                restLinkedAccount    = structValue.fieldValue("ОстатокПоСчетуОбрем").currentAsString;
                redemptionDate       = structValue.fieldValue("ДатаПогашения").currentAsString;

                onerousSign          = structValue.fieldValue("ПризнакОбременения").currentAsString;
                swiftDepartment      = structValue.fieldValue("ФилиалСВИФТ").currentAsString;
                conditionalCode      = structValue.fieldValue("УсловныйКод").currentAsString;
                otherDecoding        = structValue.fieldValue("ИноеРасшифровка").currentAsString;
            end;

            if (partNumber != 3)
                printString(i,
                            partNumber,
                            strsubst(structValue.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                            structValue.fieldValue("РегНом").currentAsString,
                            structValue.fieldValue("КодСтр").currentAsString,
                            structValue.fieldValue("НомБС").currentAsString,
                            structValue.fieldValue("НомЛС").currentAsString,
                            structValue.fieldValue("ОстВход").currentAsString,
                            structValue.fieldValue("ОбДебет").currentAsString,
                            structValue.fieldValue("ОбКредит").currentAsString,
                            structValue.fieldValue("ОстИсход").currentAsString,
                            structValue.fieldValue("ДатаИспОбKliko").currentAsString,
                            structValue.fieldValue("ПрСтавка").current,
                            Int(structValue.fieldValue("ПризнакРЕПО").exact),
                            Int(structValue.fieldValue("ПризнакГД").exact),
                            Int(NVL(structValue.fieldValue("ПризнакРезидентности").exact, ternary(structValue.fieldValue("КодСтр").currentAsString == "643", 1, 0))),
                            structValue.fieldValue("ПризнакЗависимости").currentAsString,
                            ternary((Int(structValue.fieldValue("КолПролонгаций").exact) < 0) or (Int(structValue.fieldValue("КолПролонгаций").exact) > 32767), "", Int(structValue.fieldValue("КолПролонгаций").exact)),
                            structValue.fieldValue("Пояснения").currentAsString,

                            onerousClaim,
                            identifier,
                            onerousClaimCategory,
                            ternary(restLinkedAccount == "0", "", restLinkedAccount),
                            redemptionDate,

                            onerousSign,
                            swiftDepartment,
                            conditionalCode,
                            otherDecoding);
            else
                printString(i,
                            partNumber,
                            strsubst(structValue.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                            structValue.fieldValue("РегНом").currentAsString,
                            structValue.fieldValue("КодСтр").currentAsString,
                            structValue.fieldValue("НомБС").currentAsString,
                            structValue.fieldValue("НомЛС").currentAsString,
                            structValue.fieldValue("ОстВход").currentAsString,
                            "",
                            "",
                            structValue.fieldValue("ОстИсход").currentAsString,
                            "",
                            "",
                            Int(structValue.fieldValue("ПризнакРЕПО").exact),
                            "",
                            Int(NVL(structValue.fieldValue("ПризнакРезидентности").exact, ternary(structValue.fieldValue("КодСтр").currentAsString == "643", 1, 0))),
                            "",
                            "",
                            structValue.fieldValue("Пояснения").currentAsString,
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "");
            end;

            iterator.moveNext();
        end;

        if (partNumber != 3)
            var structValueManualInput;
            while (not iteratorManualInput.isDone())
                structValueManualInput = iteratorManualInput.currentItem();
                i = i + 1;

                if (partNumber == 1)
                    onerousClaim         = structValueManualInput.fieldValue("ЛицоПоОбрем_ввод").currentAsString;
                    identifier           = structValueManualInput.fieldValue("ИдентификаторОбрем_ввод").currentAsString;
                    onerousClaimCategory = structValueManualInput.fieldValue("ВидОбрем_ввод").currentAsString;
                    restLinkedAccount    = structValueManualInput.fieldValue("ОстатокПоСчетуОбрем_ввод").currentAsString;
                    redemptionDate       = structValueManualInput.fieldValue("ДатаПогашения_ввод").currentAsString;

                    onerousSign          = structValueManualInput.fieldValue("ПризнакОбременения_ввод").currentAsString;
                    swiftDepartment      = structValueManualInput.fieldValue("ФилиалСВИФТ_ввод").currentAsString;
                    conditionalCode      = structValueManualInput.fieldValue("УсловныйКод_ввод").currentAsString;
                    otherDecoding        = structValueManualInput.fieldValue("ИноеРасшифровка_ввод").currentAsString;
                end;

                printString(i,
                            partNumber,
                            strsubst(structValueManualInput.fieldValue("НаимКО").currentAsString, "\"", "~^"),
                            structValueManualInput.fieldValue("РегНом").currentAsString,
                            structValueManualInput.fieldValue("КодСтр").currentAsString,
                            structValueManualInput.fieldValue("НомБС_ввод").currentAsString,
                            structValueManualInput.fieldValue("НомЛС_ввод").currentAsString,
                            structValueManualInput.fieldValue("ОстВход_ввод").currentAsString,
                            structValueManualInput.fieldValue("ОбДебет_ввод").currentAsString,
                            structValueManualInput.fieldValue("ОбКредит_ввод").currentAsString,
                            structValueManualInput.fieldValue("ОстИсход_ввод").currentAsString,
                            structValueManualInput.fieldValue("ДатаИспОб_ввод").currentAsString,
                            structValueManualInput.fieldValue("ПрСтавка_ввод").current,
                            0,
                            0,
                            Int(NVL(structValue.fieldValue("ПризнакРезидентности").exact, ternary(structValueManualInput.fieldValue("КодСтр").currentAsString == "643", 1, 0))),
                            ternary(structValueManualInput.fieldValue("ххх_ввод").currentAsString == "***", "*", ""),
                            Int(NVL(structValueManualInput.fieldValue("КолПролонгаций_ввод").exact, 0)),
                            structValueManualInput.fieldValue("Пояснения_ввод").currentAsString,

                            onerousClaim,
                            identifier,
                            onerousClaimCategory,
                            ternary(restLinkedAccount == "0", "", restLinkedAccount),
                            redemptionDate,

                            onerousSign,
                            swiftDepartment,
                            conditionalCode,
                            otherDecoding);

                iteratorManualInput.moveNext();
            end;
        end;

        return (i != 0);
    end;
end;

/***************************************************************************************************
 *  Точка входа для выполнения экспорта в клико
 **************************************************************************************************/
macro exportToKliko()
    var exportKlikoReport:ExportKlikoReport501;
    var exportProtocol:TExportProtocol;

    if   (   (rcbApplication().currentReport().context.period.EndDate >= RCB_I5456_DATE) 
          or (is5456RSHBChangesProject() and (rcbApplication().currentReport().context.period.EndDate >= RCB_I5456_DATE_F501)))
        exportKlikoReport = ExportKlikoReport501_5456();
    elif (rcbApplication().currentReport().context.period.EndDate >= RCB_I5586_DATE)
        exportKlikoReport = ExportKlikoReport501_5586();
    elif (rcbApplication().currentReport().context.period.EndDate >= RCB_Т1_77_1_01_117760_DATE)
        exportKlikoReport = ExportKlikoReport501_Т1_77_1_01_117760();
    elif (rcbApplication().currentReport().context.period.EndDate >= RCB_Т1_30_1_01_81913_DATE)
        exportKlikoReport = ExportKlikoReport501_Т1_30_1_01_81913();
    elif (rcbApplication().currentReport().context.period.EndDate >= RCB_Т1_30_1_01_72551_DATE)
        exportKlikoReport = ExportKlikoReport501_Т1_30_1_01_72551();
    elif (rcbApplication().currentReport().context.period.EndDate >= RCB_I4212_DATE)
        exportKlikoReport = ExportKlikoReport501_4212();
    elif (rcbApplication().currentReport().context.period.EndDate >= RCB_I2332_DATE)
        exportKlikoReport = ExportKlikoReport501_2332();
    else
        exportKlikoReport = ExportKlikoReport501();
    end;

    if (not rcbApplication().currentReport.isCalculated)
        var m_protocolView  = TProtocolView("ПРОТОКОЛ ЭКСПОРТА В Kliko.exe", RcbApplication().currentReport.form.id);
        m_protocolView.checkCalculateReport("kliko.exe");
        установитьФлагВозврата(STOP_PROC_FLG);
        exit(1);
    end;

    exportKlikoReport.execute();
    exportProtocol = TExportProtocol(exportKlikoReport.getDateAndTimeOfExportBeginning(),
                                     exportKlikoReport.getDateAndTimeOfExportEnding(),
                                     exportKlikoReport.getNumberOfExportStrings(),
                                     exportKlikoReport.getNumberOfExportSpecialStrings(),
                                     exportKlikoReport.getExportFileName(),
                                     exportKlikoReport.getDescriptorInfo());
    exportProtocol.execute();
end;

/***************************************************************************************************
 *  Точка входа для печати протокола экспорта
 **************************************************************************************************/
macro showKlikoExportProtocol()
    file protocolFile () txt;

    if (existFile(PROTOCOL_NAME, 0))
        if (open(protocolFile, PROTOCOL_NAME))
            RepTxtFilesQueue().add(PROTOCOL_NAME);
            viewFile(protocolFile);
            close(protocolFile);
        else
            RepErrorsQueue().add(0, string("Ошибка открытия файла:\n", PROTOCOL_NAME));
            msgbox("Ошибка открытия файла:|", PROTOCOL_NAME);
        end;
    else
        RepErrorsQueue().add(0, string("Не найден файл протокола:\n", PROTOCOL_NAME));
        msgbox("Не найден файл протокола:|", PROTOCOL_NAME);
    end;
end;

УстановитьФлагВозврата( OK_MACRO_FLAG);
exit(1);