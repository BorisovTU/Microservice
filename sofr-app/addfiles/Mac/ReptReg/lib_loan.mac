/*            
    Классы-обёртки для RSCOM-объектов Loans. Доступ к свойствам и методам
    соответствующих классов производится через свойство Obj обёрток.
    Также есть свойство Parent, указывающее на объект предыдущего уровня
    (это объект одного из классов, описанных здесь).
*/

import FIInter, SbCrdInter, lib_date, lib_arr, rcbconst, acc_lib;
import rsbObjFactory;
// Вспомогательная функция конвертации из валюты в рубли с выдачей ошибки, если невозможно.
// sum - сумма, curr - валюта, dat - дата, на которую конвертируем.
// !!! Должна быть общей
MACRO ConvertToRoubles( sum, curr, dat )
    var ret;
    // Если ошибка - вызываем RunError
    if( ConvSum( ret, sum, dat, curr ) != 0 )
        RunError( "|Ошибка конвертации суммы из валюты " + curr + " в нац. валюту"
                + "|Вероятно, не задан курс валюты на дату" + dat );
    end;
    return ret;
END;

// Кредитный договор (RSCOMCredit).
// ВНИМАНИЕ! В конструктор передаётся неинициализированный объект (до начала навигации).
// ВНИМАНИЕ! Для расчёта сумм т/о по видам в целях разбиения резервов необходимо
// вызвать функцию РассчитатьСуммыТребОбяз. Это необходимо сделать ДО
// вызова методов расчёта резерва для других объектов по этому договору.
CLASS ККредитныйДоговор( _obj )
    var Obj = _obj;     // агрегированный объект

    // Обёртки для свойств
    MACRO НомерДоговора         return Obj.Number;                          END;
    MACRO ДатаОткрытия          return Obj.BegDate;                         END;
    MACRO ДатаОкончания         return Obj.CloseDate;                       END;
    MACRO ТипДоговора           return Obj.Type;                            END;
    MACRO КолвоПролонгаций      return Obj.CountProl;                       END;
    MACRO КолвоУвЛимита         return Obj.CountLim;                        END;

    MACRO СуммаРВПС( dat )      return ConvertToRoubles( Obj.RezRVPS, Obj.CurRVPS, dat );       END;
    MACRO СуммаРВПС_Проср( dat )return ConvertToRoubles( Obj.RezExpRVPS, Obj.CurExpRVPS, dat ); END;

    MACRO СуммаРВП( dat )           return ConvertToRoubles( Obj.RezRVP,  Obj.CurRVP, dat ); END;
    MACRO СуммаРасчетногоРВП( dat ) return ConvertToRoubles( Obj.CalcRVP, Obj.CurRVP, dat ); END;

    // ID контрагента - для записи во врем. файл нужен именно он, а не весь субъект.
    MACRO НомерКонтрагента      return Obj.ClientID_Ref;                    END;

    // Контрагент по договору (объект класса КСубъект)
    MACRO Контрагент
        var ret = КСубъект;
        ret.Инициализация( НомерКонтрагента );
        return ret;
    END;
    /*временное решение пока не починят clearSortOrder()*/
    private macro getCredit(creditId : Integer)
        var credit = RsbObjectFactory().getObject("RcbCredit");

        credit.setFilter("id = " + obj.creditNumber);
        credit.next();
        return credit;
    end;

    // Открыт ли договор в рамках данного периода
    MACRO Открыт( date1, date2 )
        if( date2 != null )
            return ( ДатаОткрытия <= date2 ) and ( ( ДатаОкончания >= date1 ) or ( ДатаОкончания < ДатаОткрытия ) );
        else
            return ( ДатаОткрытия <= date1 ) and ( ( ДатаОкончания > date1 ) or ( ДатаОкончания < ДатаОткрытия ) );
        end;
    END;

    // Является ли овердрафтом
    MACRO Овердрафт( )
        return Obj.Type == I_OVERDRAFT;
    END;

    // Процент резервирования (если не задан, считаем равным 0).
    MACRO ПроцентРезервирования( dat )
        return getCredit().rvpsReservePercent;
/*
        var risk = Obj.CatState;
        risk.SetFilter( "ChangeDate <= " + dat );
        risk.clearSortOrder();
        risk.addSortFld("ChangeDate", false);
        risk.ApplyFilter( );
        if( risk.next( ) )
            return risk.PercRez;
        end;
        return 0.0;
*/
    END;

    // Категория качества ссуды (если не задана, считаем равной 0).
    MACRO ККС( dat )
        return getCredit().riskGroup;
/*
        var risk = Obj.CatState;
        risk.SetFilter( "ChangeDate <= " + dat );
        risk.clearSortOrder();
        risk.addSortFld("ChangeDate", false);
        risk.ApplyFilter( );
        if( risk.next( ) )
            return risk.Category;
        end;
        return 0;
*/
    END;

    // Процент резервирования РВП (если не задан, считаем равным 0).
    MACRO ПроцентРезервированияРВП( dat )
        return getCredit().rvpReservePercent;
/*
        var risk = Obj.RiskRVP;
        risk.SetFilter("DateRVP <= " + dat + " and (ObjectTypeID = "+I_CREDIT+" or ObjectTypeID = "+I_OVERDRAFT+")");
        risk.clearSortOrder();
        risk.addSortFld("DateRVP", false);
        risk.ApplyFilter();
        if (risk.next())
            return risk.PercReserve;
        end;
        return 0.0;
*/
    END;

    // Группа риска РВП (если не задана, считаем равной 0).
    MACRO ГруппаРискаРВП(dat)
        return getCredit().riskGroupRvp;
/*
        var risk = Obj.RiskRVP;
        risk.SetFilter("DateRVP <= " + dat + " and (ObjectTypeID = "+I_CREDIT+" or ObjectTypeID = "+I_OVERDRAFT+")");
        risk.clearSortOrder();
        risk.addSortFld("DateRVP", false);
        risk.ApplyFilter();
        if (risk.next())
            return risk.RiskGroup;
        end;
        return 0;
*/
    END;

    // По ней поймём, меняли ли объект. Врем. реш.: надо делать полноценную обёртку.
    // NULL - т.к. объект неинициализированный.
    private var CreditID = NULL;
    // Массив сумм т/о по классам, индексируемый классами.
    private var DemandSums = TArray;

    // Проверяем, не меняли ли объект, и, если меняли, всё зануляем. Врем. реш.: надо делать полноценную обёртку.
    private MACRO UpdateInternalData( )
        if( CreditID != Obj.CreditNumber )
            CreditID = Obj.CreditNumber;
            DemandSums.size = 0;
        end;
    END;

    // Рассчитать суммы т/о по классам для целей разбиения резервов.
    // Параметр - разбиение договора на части, массив экземпляров класса
    // КЧастьДоговора, результат работы КДоговорПоЧастям::РазбитьДоговорНаЧасти.
    MACRO РассчитатьСуммыТребОбяз( parts )
        UpdateInternalData( );
        DemandSums.size = 0;    // надо продублировать для случая повторного вызова

        var i = 0;
        var cl;
        while( i < parts.size )
            if( parts[i].Договор.Obj.CreditNumber != Obj.CreditNumber )
                RunError( "|Ошибка программирования|Части разбиения договора относятся к другому договору" );
            end;
            cl = parts[i].КлассТребОбяз;
            if( DemandSums[cl] == NULL )
                DemandSums[cl] = $0;
            end;
            DemandSums[cl] = DemandSums[cl] + parts[i].Сумма;

            i = i + 1;
        end;
    END;
    
    // Получить сумму т/о по заданному классу.
    // ВНИМАНИЕ! Сначала эта сумма должна быть рассчитана при помощи РассчитатьСуммыТребОбяз.
    // ВНИМАНИЕ! Эту функцию нельзя вызывать для т/о, по кот. не создаётся резерв.
    //  Для этого можно проверять условие РезервДляКлассаТребОбяз( cl ) == $0.
    MACRO СуммаТребОбяз( cl )
        UpdateInternalData( );
        var sum = DemandSums[cl];
        if( sum == NULL )
            RunError( "|Ошибка программирования|До разбиения резервов необходимо вызвать ККредитныйДоговор::РассчитатьСуммыТребОбяз" );
        end;
        return sum;
    END;

    // Получение значения резерва по договору, соответствующего виду (классу) т/о.
    MACRO РезервДляКлассаТребОбяз( cl, dat )
        if( cl == 0 )       // Срочное требование
            return СуммаРВПС( dat );
        end;
        if( cl == 1 )       // Просроченная задолженность
            return СуммаРВПС_Проср( dat );
        end;
        if( cl == 2 )       // По неиспользуемым лимитам (различным)
            return СуммаРВП( dat );
        end;
        return $0;
    END;
END;

// Транш (RSCOMTranches)
// _parent - объект класса ККредитныйДоговор
CLASS КТранш( _obj, _parent )
    var Obj = _obj;
    var Parent = _parent;

    // Обёртки для свойств
    MACRO Договор               return Parent;                              END;
    MACRO ДатаПервойВыдачи      return Obj.BegDate;                         END;
    MACRO ДатаВыдачи            return Obj.PayDate;                         END;
    MACRO ДатаОкончания         return Obj.EndDate;                         END;
    MACRO СрокТранша            return CPeriod( ДатаВыдачи, Obj.Period );   END;
    MACRO ОбщийСрок             return CPeriod( ДатаВыдачи, ДатаОкончания );END;
    MACRO НомерСчетаГК          return Obj.ODBAccount;                      END;
    MACRO НомерСчетаЛоанс       return Obj.Account;                         END;
    MACRO Валюта                return Obj.CurDem;                          END;

    /*временное решение пока не починят clearSortOrder()*/
    private macro getTranche(kind : Integer, number : Integer)
        var tranche = RsbObjectFactory().getObject("RcbCredit");

        tranche.setFilter("kind = " + obj.objectId + " AND number = " + obj.objectNumber);
        tranche.next();
        return tranche;
    end;

    // Открыт ли транш в рамках данного периода
    MACRO Открыт( date1, date2 )
        if( date2 != null )
            return ( ДатаВыдачи <= date2 ) and ( ( ДатаОкончания >= date1 ) or ( ДатаОкончания < ДатаВыдачи ) );
        else
            return ( ДатаВыдачи <= date1 ) and ( ( ДатаОкончания > date1 ) or ( ДатаОкончания < ДатаВыдачи ) );
        end;
    END;

    // Номер б/с, на кот. учитывается транш
    MACRO НомерБалСчета( )
        return substr( НомерСчетаГК, 1, 5 );
    END;

    // Сумма начисленных процентов на дату
    MACRO СуммаНачисленныхПроцентов( dat )
        return ConvertToRoubles( Obj.SumDem, Obj.CurDem, dat );
    END;

    // Сумма выдачи в валюте транша
    MACRO ВалСуммаВыдачи( )
        var RetVal = $0;
        var operation = Obj.Operation;
        operation.SetFilter("OPERTYPE=" + CS_PAY + " OR OPERTYPE=" + CS_PROL);/*Выдача, Пролонгация*/
        operation.ApplyFilter();
        while( operation.Next() )
           RetVal = RetVal + operation.OPERSUM;
        end;            

        return RetVal;
    END;

    MACRO СуммаВыдачи( dat )
        return ConvertToRoubles( ВалСуммаВыдачи, Валюта, dat );
    END;

    // Количество улучшений процентных ставок за период
    MACRO КолвоУлучшенийПроцСтавок( date1, date2 )
      var Rate_Old   = 0;
      var Rate_First = 0;
      var Improvements = 0;

      Obj.HistPercRate.SetFilter("RestDate >= " + date1 + " and RestDate <= " + date2 );
      Obj.HistPercRate.ApplyFilter();

      if( Obj.HistPercRate.next() )
        Rate_First = Obj.HistPercRate.Rate;
        Rate_Old = Obj.HistPercRate.Rate;
      end;

      while( Obj.HistPercRate.Next() )
        if( Obj.HistPercRate.Rate > Rate_Old )
          Improvements = Improvements + 1;
          Rate_Old = Obj.HistPercRate.Rate;
        end;
      end;

      Obj.HistPercRate.SetFilter("RestDate < " + date1 );
      Obj.HistPercRate.clearSortOrder();
      Obj.HistPercRate.addSortFld("RestDate", false);
      Obj.HistPercRate.ApplyFilter();
      if( Obj.HistPercRate.next() )
        if( Rate_First < Obj.HistPercRate.Rate )
          Improvements = Improvements + 1;
        end;
      end;

      return Improvements;
    END;

    MACRO ПервоначальнаяПроцентнаяСтавка( )
      var HistPercRate = Obj.HistPercRate;

      HistPercRate.SetFilter("RestDate <= " + Obj.PayDate);
      HistPercRate.clearSortOrder();
      HistPercRate.addSortFld("RestDate", false);
      HistPercRate.ApplyFilter(  );

      if( HistPercRate.next() )
        return HistPercRate.Rate;
      end;

      return 0.0;
    END;

    MACRO ДатаПогашенияПроцентов()
        return Obj.DateDem;
    END;

    MACRO ОстатокСрокаДоПогашенияПроцентов(currentDate : Date)
        return CPeriod(currentDate, ДатаПогашенияПроцентов());
    END;
END;

/* Предназначено для использования в качестве вспомогательной функции.*/
var ВидТребОбязПоКлассу = ArrCreate( I_REQUIR, I_EXP_DEBTS, I_LIMIT_PAY, I_LIMIT_DUTY, I_PAY_GUARANT );

// Требование/обязательство (RSCOMDemand)
// _parent - объект класса КТранш
CLASS КТребованиеОбязательство( _obj, _parent )
    var Obj = _obj;
    var Parent = _parent;

    // Обёртки для свойств
    MACRO Договор               return Parent.Parent;                       END;
    MACRO ДатаВозникновения     return Parent.Obj.PayDate;                  END;
    MACRO ДатаВыдачи            return Obj.PayDate;                         END;
    MACRO ДатаОкончания         return Obj.EndDate;                         END;
    MACRO ВалютаОстатка         return Obj.CurCode;                         END;
    MACRO ОбщийСрок             return Parent.ОбщийСрок;                    END;
    MACRO ВидТребОбяз           return Obj.Kind;                            END;
    MACRO НомерСчетаГК          return Obj.ODBAccount;                      END;
    MACRO НомерСчетаЛоанс       return Obj.Account;                         END;

    MACRO Срок                  return CPeriod( ДатаВыдачи, Obj.Duration ); END;

    // Открыто ли треб/обяз в рамках данного периода
    MACRO Открыт( date1, date2 )
        if( date2 != null )
            return ( ДатаВыдачи <= date2 ) and ( ( ДатаОкончания >= date1 ) or ( ДатаОкончания < ДатаВыдачи ) );
        else
            return ( ДатаВыдачи <= date1 ) and ( ( ДатаОкончания > date1 ) or ( ДатаОкончания < ДатаВыдачи ) );
        end;
    END;

    // Если т/о не является просроченным, не задано (NULL).
    MACRO ДатаВыносаНаПросрочку
        if( ( Obj.Kind == I_EXP_DEBTS ) or ( Obj.Kind == I_EXP_PERC ) )
            return ДатаВыдачи;
        end;
        return NULL;
    END;

    // Исходящий остаток за дату в своей валюте
    MACRO ВалИсходящийОстатокЗа( dat )
        macro getRest(restHist : Object)
            var rest = $0;
            while (restHist.next())
                rest = restHist.rest;
            end;
            return rest;
        end;

        var rest = Obj.RestHist;
        rest.SetFilter( "RestDate <= " + dat );
/*
        rest.clearSortOrder();
        rest.addSortFld("RestDate", false);
        rest.ApplyFilter( );
        if( rest.next( ) )
            return rest.Rest;
        else
            return $0;
        end;
*/      return getRest(rest);
    END;

    // Исходящий остаток за дату в рублях
    MACRO ИсходящийОстатокЗа( dat )
        return ConvertToRoubles( ВалИсходящийОстатокЗа( dat ), ВалютаОстатка, dat );
    END;

    // Входящий остаток на дату в рублях
    MACRO ВходящийОстатокНа( dat )
        return ИсходящийОстатокЗа( dat - 1 );
    END;

    // Номер б/с, на кот. учитывается т/о
    MACRO НомерБалСчета( )
        return substr( НомерСчетаГК, 1, 5 );
    END;

    // Относится ли т/о к овердрафту
    MACRO Овердрафт( )
        return Parent.Parent.Овердрафт( );
    END;

    // Относится ли к кредиту до востребования
    MACRO КредитДоВостр( )
        return Obj.Duration == 0;
    END;

    // Остаток срока до погашения на заданную дату
    MACRO ОстатокСрокаДо( dat )
        if ( ДатаОкончания >= DateMin )
            return CPeriod( dat, ДатаОкончания );
        else
            return NULL;
        end;
    END;

    // Срок просрочки, начиная от заданной даты
    // Если т/о не является просроченным, то 0
    MACRO СрокПросрочки( dat )
        var temp = ДатаВыносаНаПросрочку;
        if( temp != NULL )
            return CPeriod( temp, dat );
        end;
        return CPeriod( dat );  // нулевой срок; неважно, откуда отсчитывать
    END;

    // "Класс" т/о, который участвует в алгоритме разделения договора на части.
    // Если т/о не относится к участвующим классам, возвращается NULL.
    MACRO КлассТребОбяз
        if  ( ВидТребОбяз == I_REQUIR )     // Срочное требование
            return 0;
        elif( ВидТребОбяз == I_EXP_DEBTS )  // Просроченная задолженность
            return 1;
        elif( ВидТребОбяз == I_LIMIT_PAY )  // Неиспользованные КЛ
            return 2;
        elif( ВидТребОбяз == I_LIMIT_DUTY ) // Неиспользованные лимиты по овердрафтным кредитам и под лимит задолженности
            return 3;
        elif( ВидТребОбяз == I_PAY_GUARANT )// Гарантия выданная
            return 4;
        end;
    END;

    // Резерв, соответствующий этому т/о.
    MACRO СуммаРезерва( dat )
        var credit = Parent.Parent;
        var fullres = credit.РезервДляКлассаТребОбяз( КлассТребОбяз, dat );
        if( fullres == $0 )
            return $0;
        end;
        return fullres * ИсходящийОстатокЗа( dat ) / credit.СуммаТребОбяз( КлассТребОбяз );
    END;

    // Сумма выдачи в валюте.
    MACRO ВалСуммаВыдачи
        return ВалИсходящийОстатокЗа( ДатаВыдачи );
    END;

    // Сумма выдачи в рублях по курсу за заданную дату (по умолчанию за дату выдачи)
    MACRO СуммаВыдачи( dat )
        if( dat == NULL )
            dat = ДатаВыдачи;
        end;
        return ConvertToRoubles( ВалСуммаВыдачи, ВалютаОстатка, dat );
    END;

    //Договорной срок, на который выдано кредитное требование.
    macro СрокРазмещения()
        return CPeriod(parent.ДатаПервойВыдачи(), parent.ДатаОкончания());
    end;

END;

//Для отчетных форм, где пролонгация рассматривается как новый кредит(форма 401)
// Требование/обязательство (RSCOMDemand)
// _parent - объект класса КТранш
class (КТребованиеОбязательство)КТребованиеОбязательство_401( _obj, _parent )
    //Договорной срок, на который выдано кредитное требование.
    macro СрокРазмещения() 
       return Parent.СрокТранша;  
    end;
end;

// Обеспечение( RSCOMEnscontr )
// _parent - объект класса ККредитныйДоговор
CLASS КОбеспечение( _obj, _parent )
    var Obj = _obj;
    var Parent = _parent;

    // Обёртки для свойств
    MACRO ВидОбеспечения                return Obj.EnsSysType;              END;
    MACRO ВалСтоимостьОбеспечения       return Obj.RatingSum;               END;
    MACRO ВалютаСтоимостиОбеспечения    return Obj.RatingCurCode;           END;

    // Эмитент обеспечения - объект класса КСубъект
    MACRO ЭмитентОбеспечения
        var ret = КСубъект;
        ret.Инициализация( Obj.IssuerParty );
        return ret;
    END;

    // Эмитент обеспечения-ценной бумаги
    // !!! Временное решение
    MACRO ЭмитентЦеннойБумаги
        return Obj.IssuerEns;
    END;

    // Стоимость обеспечения за дату
    MACRO СтоимостьОбеспечения( dat )
        return ConvertToRoubles( ВалСтоимостьОбеспечения, ВалютаСтоимостиОбеспечения, dat );
    END;

    // "Класс" обеспечения. Соответствует классу обеспечения, описанному в acc_lib.mac.
    // Считается частично отдельно, т.к. эмитент обеспечения-ц.б. определяется нестандартно.
    MACRO КлассОбеспечения( дата )
        var subj = ЭмитентОбеспечения( );
        if( ВидОбеспечения == TE_GUARANT )                  // Гарантия
            return subj.КлассОбеспечения( ВО_ГАРАНТИЯ, дата );
        elif( ВидОбеспечения == TE_PREC_METALS )            // ДрагМеталлы
            return subj.КлассОбеспечения( ВО_ДРАГ_МЕТАЛЛЫ, дата );
        elif( ВидОбеспечения == TE_BAIL_CAPITAL )           // Ценные бумаги
            if( StrLwr( ЭмитентЦеннойБумаги ) == "7) международный банк развития" )
                return 4;
            end;
            if( StrLwr( ЭмитентЦеннойБумаги ) == "2) правительство рф" )
                return 7;
            end;
            if( StrLwr( ЭмитентЦеннойБумаги ) == "3) субъект рф или орган местного самоуправления" )
                return 8;
            end;
            if( StrLwr( ЭмитентЦеннойБумаги ) == "1) наш банк" )
                return 11;
            end;
            return 12;
        /* elif( ВидОбеспечения == Депозит ) - в Loans такого не бывает */
        else  // Любое другое обеспечение
            return subj.КлассОбеспечения( ВО_ДРУГОЕ, дата );
        end;
    END;

    // Группа риска актива.
    // Параметр - либо "класс" обеспечения, либо дата, на кот. его надо вычислить.
    // Если задан "класс" обеспечения - эффективнее.
    MACRO ГруппаРиска( ensclass )
        if( ( ensclass == NULL ) or ( ValType( ensclass ) == V_DATE ) )
            ensclass = КлассОбеспечения( ensclass );
        end;
        return ГруппаРискаПоКлассуОбеспечения[ensclass];
    END;

    // Коэфф. риска актива.
    // Параметр - либо группа риска, либо дата, на кот. её надо вычислить.
    // Если задана группа риска - эффективнее.
    MACRO КоэффРиска( rgroup )
        if( ( rgroup == NULL ) or ( ValType( rgroup ) == V_DATE ) )
            rgroup = ГруппаРиска( rgroup );
        end;
        return КоэффРискаПоГруппеРиска[rgroup];
    END;
END;

// Часть договора: состоит из части требования/обязательства и части обеспечения
// равной стоимости (обеспечение может отсутствовать).
// Заполняется в классе КДоговорПоЧастям.
CLASS КЧастьДоговора( dcl, ecl, sum, ddata, edata, credit )
    var КлассТребОбяз   = dcl;      // Класс требования/обязательства
    var КлассОбесп      = ecl;      // Класс обеспечения
    var Сумма           = sum;      // Сумма обесп. = сумма т/о
    var ДанныеТребОбяз  = ddata;    // Результат DemandFunc (см. КДоговорПоЧастям)
    var ДанныеОбесп     = edata;    // Результат EnsFunc; NULL, если обесп. отсутствует (см. КДоговорПоЧастям)
    var Договор         = credit;   // Экземпляр класса ККредитныйДоговор

    // Резерв, соответствующий этой части.
    MACRO СуммаРезерва( dat )
        var fullres = Договор.РезервДляКлассаТребОбяз( КлассТребОбяз, dat );
        if( (fullres == $0) or (Сумма == $0) )
            return $0;
        end;
        return fullres * Сумма / Договор.СуммаТребОбяз( КлассТребОбяз );
    END;

    private var АКлассЗаемщика; // буферизуемые данные
    /* Вычисление класса заёмщика - см. КСубъект::КлассЗаемщика. Только для 135 формы.
       !!! ВНИМАНИЕ! Здесь считаем, что Loans не используется для межбанковского
       кредитования, поэтому срок не влияет на класс заёмщика. На всякий случай
       передаём побольше.
    */
    MACRO КлассЗаемщика( )
        if( АКлассЗаемщика == NULL )
            АКлассЗаемщика = Договор.Контрагент.КлассЗаемщика( 500 );
        end;
        return АКлассЗаемщика;
    END;

    /* Группа риска заемщика. Считается через КлассЗаемщика (см. описание выше).
       Для получения коэфф. риска для рез-та нужно вызвать КоэффРискаПоГруппеРиска.
    */
    MACRO ГруппаРискаЗаемщика( )
        return ГруппаРискаПоКлассуЗаемщика( КлассЗаемщика( ) );
    END;
END;

// Разбиение договора по частям по "классам" обеспечения и требований/обязательств
// Не основывается на RSCOM-объекте.
// Параметры конструктора:
//   _credit - объект класса ККредитныйДоговор
//   _date - дата, на которую берутся все остатки, а также всё остальное.
//   _demandFunc, _ensFunc - функции, вычисляющие данные по треб./обяз. и обесп.
//      соответственно. Каждая из них получает объект соотв. класса и возвращает
//      данные, нужные для данной формы, которые будут сохранены в части договора.
//      Кроме этого, в части договора сохраняется только сумма и классы т/о и обесп.
//      Если какая-то функция не задана, сейчас не будет ничего запоминаться.
//      В дальнейшем необходимо сделать, чтобы запоминались Bookmark'и (когда
//      они будут реализованы для соотв. RSCOM-классов).
//      Сохранять ссылки на соотв. объекты можно и сейчас, но это будет неэффективно.
CLASS КДоговорПоЧастям( _credit, _date, _demandFunc, _ensFunc )
    private var Credit = _credit;
    private var Dat = _date;
    private var DemandFunc = _demandFunc;
    private var EnsFunc = _ensFunc;

    private var Demands = TArray;   // вспомогательный массив требований/обязательств
    private var Ensurs  = TArray;   // вспомогательный массив обеспечений

    // Добавить т/о в список участвующих в разделении договора на части.
    // Параметр - экземпляр класса КТребованиеОбязательство.
    MACRO ДобавитьТребОбяз( demand )
        var cl = demand.КлассТребОбяз;
        if( cl == NULL )    // т.е. не участвует в алгоритме
            return;
        end;
        if( Demands[cl] == NULL )
            Demands[cl] = TArray;
        end;
        var data = ExecMacro2( DemandFunc, demand );
        Demands[cl][Demands[cl].size] = ArrCreate( demand.ИсходящийОстатокЗа( Dat ), data );
    END;

    // Добавить обесп. в список участвующих в разделении договора на части.
    // Параметр - экземпляр класса КОбеспечение.
    MACRO ДобавитьОбесп( ensur )
        var cl = ensur.КлассОбеспечения( dat );
        if( ( cl == NULL ) or ( ГруппаРискаПоКлассуОбеспечения( cl ) == 5 ) ) // т.е. не участвует в алгоритме
            return;
        end;
        if( Ensurs[cl] == NULL )
            Ensurs[cl] = TArray;
        end;
        var data = ExecMacro2( EnsFunc, ensur );
        Ensurs[cl][Ensurs[cl].size] = ArrCreate( Ensur.СтоимостьОбеспечения( Dat ), data );
    END;

    // Очистка внутренних данных, приведение объекта в изначальное состояние.
    MACRO Очистить( )
        Demands.size = 0;
        Ensurs.size = 0;
    END;
    
    // Основная функция - собирает обеспечения и разбивает договор на части.
    // Возвращает массив экземпляров класса КЧастьДоговора.
    MACRO РазбитьДоговорНаЧасти( )
        // Собираем обеспечения.
        var ensur = Credit.Obj.Enscontr;
        ensur.ApplyFilter( );
        while( ensur.Next( ) )
            ДобавитьОбесп( КОбеспечение( ensur, Credit ) );
        end;
        
        // Сначала уберём лишние NULL'ы, чтобы потом было проще.
        var i = 0;
        while( i < Demands.size )
            if( Demands[i] == NULL )
                Demands[i] = TArray;
            end;
            i = i + 1;
        end;
        i = 0;
        while( i < Ensurs.size )
            if( Ensurs[i] == NULL )
                Ensurs[i] = TArray;
            end;
            i = i + 1;
        end;

        // Теперь основной алгоритм.
        var dcl = 0, d;     // индексы по классу т/о и по т/о внутри класса
        var parts = TArray, part;
        var demand;
        var demsum, enssum, sum;
        // сначала обеспеченные
        var ecl = 0, e = 0; // индексы по классу обесп. и по обесп. внутри класса
        // Пропускаем пустые классы обеспечений.
        while( ( ecl < Ensurs.size ) and ( Ensurs[ecl].size == 0 ) )
            ecl = ecl + 1;
        end;
        while( ( dcl < Demands.size ) and ( ecl < Ensurs.size ) )
            d = 0;
            while( ( d < Demands[dcl].size ) and ( ecl < Ensurs.size )  )
                if( demsum == NULL )
                    demsum = Demands[dcl][d][0];
                end;
                if( enssum == NULL )
                    enssum = Ensurs[ecl][e][0];
                end;
                sum = min( demsum, enssum );
                parts[parts.size] = КЧастьДоговора( dcl, ecl, sum, Demands[dcl][d][1], Ensurs[ecl][e][1], Credit );
                demsum = demsum - sum;
                enssum = enssum - sum;
                if( enssum <= $0 )  // берём след. обесп.
                    enssum = NULL;
                    e = e + 1;
                    while( ( ecl < Ensurs.size ) and ( e == Ensurs[ecl].size ) )
                        ecl = ecl + 1;
                        e = 0;
                    end;
                end;
                if( demsum <= $0 )  // берём след. т/о
                    demsum = NULL;
                    d = d + 1;
                end;
            end;
            if( d >= Demands[dcl].size )
                dcl = dcl + 1;
            end;
        end;
        // а теперь необеспеченные
        if( d == NULL )   // обеспеченных нет
            d = 0;
        end;
        while( dcl < Demands.size )
            while( d < Demands[dcl].size )
                if( demsum != NULL )    // частично необеспеченное т/о
                    sum = demsum;
                    demsum = NULL;
                else
                    sum = Demands[dcl][d][0];
                end;
                /* !!! Не самое лучшее решение. Здесь возвращаем наихудший класс
                   обеспечения, т.к. он не отличается от отсутствия обеспечения.
                   Было бы неплохо передавать NULL, но тогда его нужно везде
                   отдельно проверять (им нельзя индексировать массивы).
                */
                parts[parts.size] = КЧастьДоговора( dcl, ГруппаРискаПоКлассуОбеспечения.size - 1, sum, Demands[dcl][d][1], NULL, Credit );
                d = d + 1;
            end;
            dcl = dcl + 1;
            d = 0;
        end;

        return parts;
    END;
END;
