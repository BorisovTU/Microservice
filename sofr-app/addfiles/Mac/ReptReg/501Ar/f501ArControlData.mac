/*
$Name:          f501ArControlData.mac
$Module:        Отчеты ЦБ
$Description:   Форма 501Ar. Контроль данных
*/
import acc_lib;

class TControlData()
    private const errorNote = "!Ошибка: Данные формы отличаются от данных баланса в рублях. " +
                              "Нормализация с балансом не может быть проведена. Проверьте "+
                              "правильность составления отчета";

    private const errorNote603 = "!Ошибка: Данные форм отличаются от данных баланса в рублях." +
                                 "Проверьте правильность составления отчета";

    var typeAccount : string;
    var kindAccount : string;
    var balance : string;
    var restIn : money;
    var restOut : money;
    var debet : money;
    var credit : money;
    var restInBal : money;
    var restOutBal : money;
    var debetBal : money;
    var creditBal : money;

    macro ControlValues(protocol:CTableReport)
        private var errorCounter = 0;
        private macro checkData(valuesBal:money, values:money)
            if ( (balance == "20317") OR (balance == "20318") )
                if ( (valuesBal - values) >= 0 )
                    return true;
                end;
            else
                if (typeAccount == 1)
                    if ( abs(valuesBal - values) <= 2 )
                        return true;
                    end;
                else
                    if ((valuesBal - values) == 0)
                        return true;
                    end;
                end;
            end;
            return false;
        end;

        var m_protocol = protocol;

        if ( not checkData(restInBal,  restIn) )
                m_protocol.memStringTransferByWord("!",
                                                   "Входящие остатки по б/с " + balance,
                                                   restIn,
                                                   "Бн" + balance + "__" + kindAccount,
                                                   restInBal,
                                                   (restInBal - restIn),
                                                   ternary(typeAccount == 1, errorNote, errorNote603) );
        errorCounter = errorCounter + 1;
        end;

        if ( not checkData(restOutBal, restOut) )
                m_protocol.memStringTransferByWord("!",
                                                   "Исходящие остатки по б/с " + balance,
                                                   restOut,
                                                   "Бн" + balance + "__" + kindAccount,
                                                   restOutBal,
                                                   (restOutBal - restOut),
                                                   ternary(typeAccount == 1, errorNote, errorNote603) );
        errorCounter = errorCounter + 1;
        end;

        if ( not checkData(debetBal,   debet) )
                m_protocol.memStringTransferByWord("!",
                                                   "Дебетовые обороты по б/с " + balance,
                                                   debet,
                                                   "Бн"+balance+"__Д",
                                                   debetBal,
                                                   (debetBal - debet),
                                                   ternary(typeAccount == 1, errorNote, errorNote603) );
        errorCounter = errorCounter + 1;
        end;

        if ( not checkData(creditBal,  credit) )
                m_protocol.memStringTransferByWord("!",
                                                   "Кредитовые обороты по б/с " + balance,
                                                   credit,
                                                   "Бн"+balance+"__К",
                                                   creditBal,
                                                   (creditBal - credit),
                                                   ternary(typeAccount == 1, errorNote, errorNote603) );
        errorCounter = errorCounter + 1;
        end;
        return errorCounter;
    end;
end;

/***************************************************************************************************
 *  Класс межформенного контроля
 **************************************************************************************************/
class TF501ArInterControlDataController()
    private var protocol = CTableReport();
    private var errorCounter = 0;
    private var report: object;
    private var context:object;
    private var balanceReport:object;
    private var previousBalanceReport:object;
    private var f603Report:object;
    private var m_balanceAttribute;
    private var m_currentBalanceReport;

    private macro constructor()
        var dummyReport;

        report = rcbApplication().currentReport();
        context = report.context;

        // 16.09.2011 ABP Отчет за дату, предшествующую ДНОП. Нужен для создания баланса за ДНОП-1
        dummyReport = RcbApplication().objectFactory.createReport(report.form.id,
                                                                  RcbReportContext(RcbPeriod(context.period.beginDate-1,
                                                                                             context.period.beginDate-1
                                                                                            ),
                                                                                   context.departmentCode,
                                                                                   context.issueMode,
                                                                                   context.organizationStructure,
                                                                                   context.isSummaryMode
                                                                                  )
                                                                 );
        balanceReport = report.createBalanceReport();
        previousBalanceReport = dummyReport.createBalanceReport(RCB_CBR_IS_ANY_BEGINNING_DATE);

        f603Report = report.createOtherReport("Форма 603");

        protocol.AddColumn("!", 3);
        protocol.AddColumn("Объект проверки", 15);
        protocol.AddColumn("Значение объекта проверки", 15);
        protocol.AddColumn("Обект сравнения", 15);
        protocol.AddColumn("Значение объекта сравнения", 15);
        protocol.AddColumn("Расхождение", 15);
        protocol.AddColumn("Примечание", 35);

    end;


    private macro getPathAndNameFiles()
        return getNameLog(strsubst(RcbApplication().currentReport.form.id, " ", "_") + "ПРОТОКОЛ МЕЖФОРМЕННОГО КОНТРОЛЯ");
    end;

    private macro setBeginPrint()
        setoutput(getPathAndNameFiles());
    end;

    private macro setEndPrint()
        file tout() txt;
        Open( tout, SetOutput( NULL ) );
          RepTxtFilesQueue().add(SetOutput( NULL ));
          viewFile( tout );
        Close( tout );
    end;

    private macro printHeaderProtocol();
        var beginDate = RcbApplication().currentReport.context.period.beginDate;
        var endDate = RcbApplication().currentReport.context.period.endDate;
        var dataSet = TRsbDataSet("SELECT t_Oper Oper, t_Name Name FROM dperson_dbt WHERE t_Oper = " + {Oper});
        DataSet.Next;
        var formName = TRsbDataset("SELECT REPLACE(t_szComment, 'Форма 501. ', '') t_name FROM dcy_forms_dbt WHERE t_szFormName = " + getSqlString(RcbApplication().currentReport.form.id));
        formName.next();
        [                                                                                      ];
        [ Форма 501. #                                                                         ](formName.t_name);
        [ Протокол межформенного контроля                                                      ];
        [ Период отчета с #          по #                                                      ]( string(beginDate):l, string(endDate):l );
        [ Дата и время выпуска отчета:  #           #                                          ]( string(date()):l, string(time()):l );
        [ Исполнитель: #     #                                                                 ]({Oper}:l, dataSet.name:l);
        [                                                                                      ];
    end;

    private macro printBottomProtocol();
        [                                                                                      ];
        [ Всего ошибок: #                                                                      ](errorCounter);
    end;

    private macro printNoError()
        [                                                                                      ];
        [ Контроль проведен успешно, ошибок не обнаружено                                      ];
    end;


    private macro checkBalanceReport()
        private macro printNoBalanceReport(beginDate:date, endDate:date)
            [ !!!Расчет формы "Балансовые счета" за период с ########## по ########## отсутствует.](beginDate, endDate);
        end;

        private macro printErrorString()
            [ Контроль соответствия данных формы 501 данным баланса производиться не будет!                ];
        end;

        var counter = 0;
        if ((not balanceReport.isCalculated) or (balanceReport.dimension != report.dimension))
            printNoBalanceReport(balanceReport.context.period.beginDate,
                                 balanceReport.context.period.endDate );
            counter = counter + 1;
        end;

        if ((not previousBalanceReport.isCalculated) or (previousBalanceReport.dimension != report.dimension))
            printNoBalanceReport(previousBalanceReport.context.period.beginDate,
                                 previousBalanceReport.context.period.endDate );
            counter = counter + 1;
        end;

        if (counter >0)
            printErrorString();
            return false;
        end;

        return true;
    end;

    private macro checkForm603Report()

        if (not f603Report.isCalculated)
            [ Отсутствуют рассчитанные данные формы 603. Контроль с балансом произведен без учета данных формы 603.];
            return false;
        end;

        return true;

    end;

    private macro getF603Value(useF603Data:bool, balance:string, column:integer) : money

        macro isSuitable(v)
            return (v.fieldValue("balance").exact == balance) and (v.fieldValue("column").exact == column);
        end;

        var value = $0;

        if (not useF603Data)
            return $0;
        end;

        var valueIterator = f603Report.attributeValue("ДанныеОтчета").createValueIterator();
        valueIterator.setFilter(@isSuitable);

        valueIterator.first();
        while (not valueIterator.isDone())
            value = value + valueIterator.currentValue.fieldValue("money").exact;
            valueIterator.next();
        end;

        return value;

    end;

    private macro getBalanceAttribute(balance, type)
        m_balanceAttribute.getBalanceAttribute(1, balance, false);
        var typeName : String;
        var value;

        if(type == "out")
            value = m_balanceAttribute.getOutRest();
            typeName = "Исходящий остаток";
        elif(type == "credit")
            value = m_balanceAttribute.getCredit();
            typeName = "Оборот по кредиту";
        elif(type == "debet")
            typeName = "Оборот по дебету";
            value = m_balanceAttribute.getDebet();
        else
            msgBox("Переменная для балансового счета " + balance + " не существует!!!");
            return;
        end;

        if (valType(value) == V_UNDEF)
            msgBox("Переменная для балансового счета " + balance +
                   " формы Балансовые счета за период с " + m_currentBalanceReport.context.period.beginDate +
                   " по " + m_currentBalanceReport.context.period.endDate + "не существует!!! Будет использоваться нулевое значение!");

            value = TValue();
        elif (valType(value.exact) == V_UNDEF)
            msgBox("Значение \"" + typeName + "\" для балансового " + balance +
                   " формы Балансовые счета за период с " + m_currentBalanceReport.context.period.beginDate +
                   " по " + m_currentBalanceReport.context.period.endDate + "не определено! Будет использоваться нулевое значение!");

            value = TValue();
        end;

        return value;
    end;


    private macro checkPartData(partNumber:integer, useF603Data:bool)
        defaultParm(useF603Data, false);
        var iterator = rcbApplication().currentReport().attributeValue("Ф501_" + string(partNumber)).createValueIterator();

        macro IsLess(v1, v2)/* функция для сортировки (оператор меньше) */
            return (v1.fieldValue("НомБС").exact < v2.fieldValue("НомБС").exact);
        end;

        macro isSuitableCreditDeposit(v)
            return in(v.fieldValue("ТипЛС").exact, "1");
        end;

        macro isSuitableCorrAccounts(v)
            return in(v.fieldValue("ТипЛС").exact, "2");
        end;

        if (useF603Data)
            iterator.setFilter(@isSuitableCorrAccounts);
        else
            iterator.setFilter(@isSuitableCreditDeposit);
        end;

        iterator.setSortOrder(@IsLess);
        iterator.moveFirst();
        var dataArray = TArray();
        var tmpRestIn = $0.0, tmpRestOut = $0.0, tmpDebet = $0.0, tmpCredit = $0.0;
        var tmpKindAccount = "", tmpBalance = "", tmpTypeAccount = "";
        var isFirst = true;
        var i = 0, structValue;
        iterator.moveFirst();

        while (not iterator.isDone())
            structValue = iterator.currentItem();

            if ( (not isFirst) AND (tmpBalance != structValue.fieldValue("НомБС").exact) )
                dataArray(i) = TControlData();
                dataArray(i).balance = tmpBalance;
                dataArray(i).restIn  = tmpRestIn ;
                dataArray(i).restOut = tmprestOut;
                dataArray(i).debet   = tmpDebet  ;
                dataArray(i).credit  = tmpCredit ;
                dataArray(i).kindAccount = tmpKindAccount;
                dataArray(i).typeAccount = tmpTypeAccount;
                tmpRestIn  = $0.0;
                tmpRestOut = $0.0;
                tmpDebet   = $0.0;
                tmpCredit  = $0.0;
                i = i + 1;
            end;
            tmpKindAccount = structValue.fieldValue("ВидЛС").exact;
            tmpTypeAccount = structValue.fieldValue("ТипЛС").exact;
            tmpBalance = structValue.fieldValue("НомБС").exact;
            tmpRestIn  = tmpRestIn + structValue.fieldValue("ОстВход").exact + getF603Value(useF603Data, tmpBalance, 7);
            tmpRestOut = tmpRestOut + structValue.fieldValue("ОстИсход").exact + getF603Value(useF603Data, tmpBalance, 10);
            tmpDebet   = tmpDebet + structValue.fieldValue("ОбДебет").exact + getF603Value(useF603Data, tmpBalance, 8);
            tmpCredit  = tmpCredit +  structValue.fieldValue("ОбКредит").exact + getF603Value(useF603Data, tmpBalance, 9);

            iterator.moveNext();
            isFirst = false;
        end;

        i = 0;
        m_balanceAttribute = TBalanceAttribute("БАЛАНС",  balanceReport);
        m_currentBalanceReport = balanceReport;

        while( i < dataArray.size)
            dataArray(i).restOutBal = getBalanceAttribute(dataArray(i).balance, "out").exact;
            dataArray(i).debetBal   = getBalanceAttribute(dataArray(i).balance, "debet").exact;
            dataArray(i).creditBal  = getBalanceAttribute(dataArray(i).balance, "credit").exact;;
            i = i + 1;
        end;

        i = 0;
        m_balanceAttribute = TBalanceAttribute("БАЛАНС",  previousBalanceReport);
        m_currentBalanceReport = previousBalanceReport;

        while( i < dataArray.size)
            dataArray(i).restInBal = getBalanceAttribute(dataArray(i).balance, "out").exact;
            i = i + 1;
        end;

        i = 0;
        while( i < dataArray.size)
            errorCounter  = errorCounter + dataArray(i).ControlValues(protocol);
            i = i + 1;
        end;
    end;

    macro execute()
        private const PART_1 = 1;
        private const PART_2 = 2;

        setBeginPrint();
        printHeaderProtocol();
        if ( not checkBalanceReport() )
            setEndPrint();
        else
            protocol.printFreeString("Контроль формы 501 с формой \"Балансовые счета\"");
            protocol.memHead();
            checkPartData(PART_1);
            checkPartData(PART_2);

            if (errorCounter > 0)
                protocol.printMemStr();
                protocol.printBottom();
                printBottomProtocol() ;
            else
                protocol.resetMemStr();
                printNoError();
            end;

            if (checkForm603Report())
                errorCounter = 0;
                protocol.printFreeString("");
                protocol.printFreeString("Контроль форм 501 и 603 с формой \"Балансовые счета\"");
                protocol.memHead();
                checkPartData(PART_1, true);
                checkPartData(PART_2, true);

                if (errorCounter > 0)
                    protocol.printMemStr();
                    protocol.printBottom();
                    printBottomProtocol() ;
                else
                    protocol.resetMemStr();
                    printNoError();
                end;
            end;

            setEndPrint();
        end;

        RepTxtFilesQueue().add(getPathAndNameFiles());
    end;

    macro viewProtocolFile()
        viewFileLog(getPathAndNameFiles());
    end;

    constructor();
end;

class TF501ArIntraControlDataController()
    private var protocol = CTableReport();
    private var errorCounter = 0;

    private macro constructor()
        protocol.AddColumn("!", 3);
        protocol.AddColumn("Объект проверки", 30);
        protocol.AddColumn("Примечание", 70);
    end;

    private macro getPathAndNameFiles()
        return getNameLog(strsubst(RcbApplication().currentReport.form.id, " ", "_") + "ПРОТОКОЛ ВНУТРИФОРМЕННОГО КОНТРОЛЯ");
    end;

    private macro setBeginPrint()
        setoutput(getPathAndNameFiles);
    end;

    private macro setEndPrint()
        file tout() txt;
        Open( tout, SetOutput( NULL ) );
        RepTxtFilesQueue().add(SetOutput( NULL ));
        viewFile( tout );
        Close( tout );
    end;

    private macro printHeaderProtocol();
        private var beginDate = RcbApplication().currentReport.context.period.beginDate;
        private var endDate = RcbApplication().currentReport.context.period.endDate;
        private var dataSet = TRsbDataSet("SELECT t_Oper Oper, t_Name Name FROM dperson_dbt WHERE t_Oper = " + {Oper});
        DataSet.Next;
        var formName = TRsbDataset("SELECT REPLACE(t_szComment, 'Форма 501. ', '') t_name FROM dcy_forms_dbt WHERE t_szFormName = " + getSqlString(RcbApplication().currentReport.form.id));
        formName.next();
        [                                                                                      ];
        [ Форма 501. #                                                                         ](formName.t_name);
        [ Протокол внутриформенного контроля                                                   ];
        [ Период отчета с #          по #                                                      ]( string(beginDate):l, string(endDate):l );
        [ Дата и время выпуска отчета:  #           #                                          ]( string(date()):l, string(time()):l );
        [ Исполнитель: #     #                                                                 ]({Oper}:l, dataSet.name:l);
    end;

    private macro printBottomProtocol();
        [                                                                                      ];
        [ Всего ошибок: #                                                                      ](errorCounter);
    end;

    private macro printNoError()
        [                                                                                      ];
        [ Контроль проведен успешно, ошибок не обнаружено                                      ];
    end;

    private macro checkBalance(account:string, balance:string)
        private const maskString = "30110, 30114, 30118, 30119";
        private var conditionString = (subStr(account, 1, 5) != balance);

        if (CompareStrWithMasks(maskString, account) AND conditionString)
            return false;
        end;
        return true;
    end;

    private macro isResident(account:string)
        private const maskString = "20315*, 20317*, 313*, 31702*, 320* & !32015*, 322* & !32211*, 32401*, 30109*, 30110*, 30116*, 30118*, 30119*, 30230*, 30231*";
        private var dataSet = TRsbDataSet("SELECT prt.t_notResident                " +
                                "\n"+     "  FROM daccount_dbt acc, dparty_dbt prt " +
                                "\n"+     " WHERE acc.t_client = prt.t_partyId     " +
                                "\n"+     "   AND acc.t_account = '" + account + "'" +
                                "\n"+     "   AND acc.t_chapter = 1                ");
        dataSet.Next();

        if ( (not CompareStrWithMasks(maskString, account)) AND (dataSet.notResident == "X") )
            return false;
        end;
        return true;
    end;

    private macro isNotResident(account:string)
        private const maskString = "20316*, 20318*, 314*, 316*, 31703*, 321* & !32115*, 323* & !32311*, 32402*, 30111*, 30114*, 30117*, 30119*, 30122*, 30123*, 30230*, 30231*";
        private var dataSet = TRsbDataSet("SELECT prt.t_notResident                " +
                                "\n"+     "  FROM daccount_dbt acc, dparty_dbt prt " +
                                "\n"+     " WHERE acc.t_client = prt.t_partyId     " +
                                "\n"+     "   AND acc.t_account = '" + account + "'" +
                                "\n"+     "   AND acc.t_chapter = 1                ");
        dataSet.Next();

        if ( (not CompareStrWithMasks(maskString, account)) AND (dataSet.notResident == "") )
            return false;
        end;
        return true;
    end;

    private macro checkPerfomanseDate(account:string)
        file acc ("account.dbt");
        acc.account = account;
        acc.chapter = 1;
        acc.code_currency = -9999;
        if (not getGE(acc))
//            msgBox("запись не найдена");
            msgBox("запись не найдена", "|", account);
        end;
        private var PerfomanceDate = readNoteForObject( OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ),
                                                         NOTEKIND_DATE_PAYING, rcbApplication().currentReport().context.period.endDate );
        private var conditionString = ( (subStr(account, 4, 2) != "01") AND (perfomanceDate == "")
                                    AND (acc.operationDate == "") AND (acc.daysToEnd == 0) );
        if (conditionString)
            return false;
        end;
        return true;
    end;

    private macro checkNotResidentCountry(account:string)
        private var dataSet = TRsbDataSet("SELECT prt.t_notResident, prt.t_nrCountry " +
                                "\n"+     "  FROM daccount_dbt acc, dparty_dbt prt " +
                                "\n"+     " WHERE acc.t_client = prt.t_partyId     " +
                                "\n"+     "   AND acc.t_account = '" + account + "'" +
                                "\n"+     "   AND acc.t_chapter = 1                ");
        dataSet.Next();
        if ( (dataSet.notResident == "X") AND (dataSet.nrCountry == "") )
            return false;
        end;
        return true;
    end;

    private macro checkNullRestOut(restIn:money, restOut:money, debet:money, credit:money, perfomanceDate:string)
        private var conditionString = ( (restIn != 0) OR (debet != 0) OR (credit !=0));
        private var endDate = rcbApplication().currentReport().context.period.endDate;
        if ( (restOut == 0) AND conditionString)
            if ( perfomanceDate > endDate )
                return false;
            end;
        end;
        return true;
    end;

    private macro checkIrReducibleRest(account:string, kindAccount:integer)
        file acc ("account.dbt");
        var irReducibleRest = true;
        acc.account = account;
        acc.chapter = 1;
        acc.code_currency = -9999;
        if (not getGE(acc))
//            msgBox("запись не найдена");
            msgBox("запись не найдена", "|", account);
        end;
        private var noteIrReducibleRest = ReadNoteForObject ( OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ), 14, rcbApplication().currentReport().context.period.endDate );
        private var noteRate = ReadNoteForObject ( OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ), 19, rcbApplication().currentReport().context.period.endDate );

        GetRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 501\\НЕСНИЖАЕМЫЙ ОСТАТОК",V_BOOL, irReducibleRest, NULL );
        if ( irReducibleRest AND (kindAccount == 2) )
            if ( (noteIrReducibleRest != 0.0) OR (noteRate != 0.0) )
                if   (noteIrReducibleRest == 0.0)
                    return "неснижаемый остаток";
                elif (noteRate == 0.0)
                    return "процентная ставка";
                end;
            end;
        end;
        return "true";
    end;

    private macro checkRestOut(partNumber:integer, restIn:money, restOut:money, debet:money, credit:money)
        private var calculateRestOut = $0.0;
        if (partNumber == 1)
            calculateRestOut = restIn + debet - credit;
        else
            calculateRestOut = restIn - debet + credit;
        end;
        return (restOut - calculateRestOut);
    end;



    private macro checkPartData(partNumber:integer)
        private var iterator = rcbApplication().currentReport().attributeValue("Ф501_" + string(partNumber)).createValueIterator();
        private var tmpValue = $0.0;
        private var tmpStr = "";

        private macro IsLess(v1, v2)/* функция для сортировки (оператор меньше) */
            return (v1.fieldValue("КодКО").exact < v2.fieldValue("КодКО").exact);
        end;

        iterator.setSortOrder(@IsLess);
        iterator.moveFirst();

        var i = 0, structValue;
        iterator.moveFirst();
        while (not iterator.isDone())
            structValue = iterator.currentItem();
            i = i + 1;

            if ( not checkBalance( structValue.fieldValue("НомЛС").exact, structValue.fieldValue("НомБС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль соответствия первых пяти позиций " +
                                                 "номера лицевого счета номеру балансового счета",
                                                 "Ошибка. Для лицевого счета "  + structValue.fieldValue("ОтчНомЛС").exact +
                                                 " баласнсовый счет " + structValue.fieldValue("НомБС").exact +
                                                 " не соответствует требуемому");
            errorCounter = errorCounter + 1;
            end;

            if ( not isResident( structValue.fieldValue("НомЛС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль допустимости введенного балансового счета второго порядка для резидента",
                                                 "Ошибка. Клиент "  + structValue.fieldValue("НаимКО").exact +
                                                 " является нерезидентом");
            errorCounter = errorCounter + 1;
            end;

            if ( not isNotResident( structValue.fieldValue("НомЛС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль допустимости введенного балансового счета второго порядка для нерезидента",
                                                 "Ошибка. Клиент "  + structValue.fieldValue("НаимКО").exact +
                                                 " не является нерезидентом");
            errorCounter = errorCounter + 1;
            end;

            if (NOT TF501ArSettings().isUseMmDealsData())
                if ( not checkPerfomanseDate( structValue.fieldValue("НомЛС").exact) )
                    protocol.memStringTransferByWord("!",
                                                     "Контроль даты погашения",
                                                     "Ошибка. По л/счету "  + structValue.fieldValue("НомЛС").exact +
                                                     " не задана дата погашения");
                errorCounter = errorCounter + 1;
                end;
            end;

            if ( not checkNotResidentCountry( structValue.fieldValue("НомЛС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль данных нерезидента",
                                                 "Ошибка. Не определена страна нерезидента, клиент " +
                                                 structValue.fieldValue("НаимКО").exact);
            errorCounter = errorCounter + 1;
            end;

            if ( not checkNullRestOut(structValue.fieldValue("ОстВход").exact,
                                      structValue.fieldValue("ОстИсход").exact,
                                      structValue.fieldValue("ОбДебет").exact,
                                      structValue.fieldValue("ОбКредит").exact,
                                      structValue.fieldValue("ДатаИспОб").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль нулевого исходящего остатка",
                                                 "Ошибка. Исходящий остаток по л/счету "  + structValue.fieldValue("НомЛС").exact +
                                                 "  = 0. Дата погашения должна быть больше или равна дате окончания отчетного периода");
            errorCounter = errorCounter + 1;
            end;

            tmpStr = checkIrReducibleRest(structValue.fieldValue("НомЛС").exact, structValue.fieldValue("ТипЛС").exact);
            if ( tmpStr != "true")
                protocol.memStringTransferByWord("!",
                                                 "Объект проверки - \"Контроль неснижаемого остатка\"",
                                                 "Ошибка. Для лицевого счета "  + structValue.fieldValue("НомЛС").exact +
                                                 " не определено значение примечания " + tmpStr );
            errorCounter = errorCounter + 1;
            end;

            tmpValue = checkRestOut(partNumber,
                                    structValue.fieldValue("ОстВход").exact,
                                    structValue.fieldValue("ОстИсход").exact,
                                    structValue.fieldValue("ОбДебет").exact,
                                    structValue.fieldValue("ОбКредит").exact);
            if ( tmpValue != 0)
                protocol.memStringTransferByWord("!",
                                                 "Построчный контроль (входящие остатки плюс обороты равны исходящим",
                                                 "Ошибка. Для лицевого счета "  + structValue.fieldValue("НомЛС").exact +
                                                 " факт исх. остаток " + structValue.fieldValue("ОстИсход").exact +
                                                 ", рассчит. исх. остаток " +
                                                 string(structValue.fieldValue("ОстИсход").exact + tmpValue) +
                                                 ", сумма несоответствия " + abs(tmpValue) );
            errorCounter = errorCounter + 1;
            end;

            iterator.moveNext();
        end;

    end;

    macro execute()
        private const PART_1 = 1;
        private const PART_2 = 2;

        setBeginPrint();
        printHeaderProtocol();
        protocol.memHead();
        checkPartData(PART_1);
        checkPartData(PART_2);

        if (errorCounter > 0)
            protocol.printMemStr();
            protocol.printBottom();
            printBottomProtocol()
        else
            protocol.resetMemStr();
            printNoError();
        end;
        setEndPrint();

        RepTxtFilesQueue().add(getPathAndNameFiles());
    end;

    macro viewProtocolFile()
        viewFileLog(getPathAndNameFiles());
    end;

    constructor();
end;