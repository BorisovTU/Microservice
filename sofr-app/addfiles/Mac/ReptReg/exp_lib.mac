/* ---------------------------------------------------------------------------

               Вспомогательные функции для макросов экспорта
                      Приложений 17-й инструкции



printMessage( p_msg, p_type ) -
    Распечатать сообщение p_str заданного типа p_type. Параметр p_type
    может принимать одно из следующих значений:
    TPS_ERROR   - cообщение об ошибке
    TPS_WARNING - предупреждение
    TPS_MESSAGE - информационное сообщение
    TPS_DETAILS - продолжение предыдущего сообщения
    TPS_TOPIC   - начало / конец раздела


printMessageLn( p_msg, p_type ) -
    То же, что и printMessage, но после распечатки сообщения выводит 
    пустую строку.


writeFormData( p_num, p_fileName ) -
    Нужно ли экспортировать данные по заданной форме.
     return V_BOOL


writeData( p_size, p_dataMacro, p_errorMacro ) -
    Записать данные, хранимые в массиве размера p_size, получаемые
    функцией p_dataMacro, строками длины < _maxSTRLEN в выходной файл
    Процедура p_dataMacro должна принимать на входе единственный параметр -
    индекс элемента в массиве данных и возвращать строковое значение
    В случае ошибки записи вызывается процедура p_errorMacro, 
    которой в качестве параметра передается незаписанная строка


writeRekw -
    Проверить реквизиты на наличие и по необходимости записать


getFileName( p_dir, p_date, p_prefix ) -
    Получить имя файла экспорта (параметры - директория экспорта, дата, префикс)
     return V_STRING

 --------------------------------------------------------------------------- */   

/*                             Настройка                                     */

var _maxSTRLEN = 200; /* Максимальная длина строки с данными */

/* ----------------------------------------------------------------------------
 ------------------------------------------------------------------------------    

  LIBRARY TEXT FOLLOWS. DO NOT EDIT.

 ------------------------------------------------------------------------------
 --------------------------------------------------------------------------- */

IMPORT reptCBInter, param, lib_exp, file_lib; /* ...; Для кодов СОАТО, БИК и т.п. */

import rcbCoreInter;
import rcbconst;
import logfile;

FILE pers   ( person   );       /* Справочник операционистов */
FILE dprt_   ( dp_dep   );       /* Справочник отделений банка */
FILE bnkd   ( bankdprt );       /* Параметры банков */
FILE f_vars ( cy_varsd, "cy_files.def" ) KEY 2; /* KEY = iFormId + szVarName */

/* ----------------------------- CLASSES ----------------------------------- */

/* Запись по реквизиту */
CLASS CrekwRec( p_name )
 var 
  v_name = p_name,
  v_val  = "",
  v_real = "";
END;

/* Запись по переменной */
CLASS CvarRec( p_name, p_value )
 var
  v_name  = p_name,
  v_value = p_value;
END;

/* ----------------------------- GLOBALS ----------------------------------- */

var _rekwSTR = "[REKW]",
    _dprtSTR = "[R003]",

   _rekw     = TArray;

_rekw(0)  = CrekwRec( "ADDRESS" );
_rekw(1)  = CrekwRec( "BIC" );
_rekw(2)  = CrekwRec( "DOL_PR" );
_rekw(3)  = CrekwRec( "FIO_BG" );
_rekw(4)  = CrekwRec( "FIO_PR" );
_rekw(5)  = CrekwRec( "KT" );
_rekw(6)  = CrekwRec( "NAME" );
_rekw(7)  = CrekwRec( "NF" );
_rekw(8)  = CrekwRec( "OKPO" );
_rekw(9)  = CrekwRec( "PF" );
_rekw(10) = CrekwRec( "PG" );
_rekw(11) = CrekwRec( "REGN" );
_rekw(12) = CrekwRec( "SOATO" );

var _dprt    = TArray; /* Специальный массив для хранения реквизитов, относящихся к R003 */
_dprt(0) = CrekwRec( "FIO_IS" );
_dprt(1) = CrekwRec( "TEL_IS" );/* хранится 2м для удобства: количество записей в этом массиве явл.переменным */

var S_SEPARATOR = ".",/* разделитель для внутренних целей (поддержка множества-строки) */
   _dprt_val   = S_SEPARATOR; /* строка для накопления считанных из файла кодов фиилалов */

var varsList  = TArray, /* Список значений переменных формы */
    undefList = TArray; /* Список переменных, значение которых не определено */

/* ......... переменные для вывода протокола по форме ... */

/* Типы сообщений */
/*var TPS_ERROR     = 0,
    TPS_WARNING   = 1,
    TPS_MESSAGE   = 2,
    TPS_DETAILS   = 3,
    TPS_TOPIC     = 4,
*/
var _msgType = TArray;
_msgType(0) = "!!! ";
_msgType(1) = "??? ";
_msgType(2) = "    ";
_msgType(3) = "       ";
_msgType(4) = "*** ";

/* ----------------------------- MACROS ------------------------------------ */

/* ......................................................................... 

   Макросы для вывода протокола

   ......................................................................... */

MACRO printMessage( p_msg, p_type )
 var type;

 if( type != TPS_DETAILS )
  println( _msgType( p_type ), time, " ", p_msg );
 else
  println( _msgType( p_type ), p_msg );
 end;
END;

MACRO printMessageLn( p_msg, p_type )
 printMessage( p_msg, p_type );
 println;
END;    

/* ......................................................................... 

   Далее - макросы для обработки данных

   ......................................................................... */

/* Получить и записать значения переменных. Переменные с нулевым значением
   не заносятся ни в один массив */
MACRO getVarValues
 var l_res = FALSE, /* была ли прочитана хотя бы одна переменная */
     l_formID,
     l_name,
     l_value,
     cont;

 RECORD formParams( cy_forms, "cy_files.def" );
 l_formID = -1;

 if( СвойстваОтчетнойФормы( {Название Отчета}, formParams ) )
  l_formID = formParams.iFormId;
 else
  msgBox("Не удалось получить идентификатор отчета.");
  exit(1);
 end;

 f_vars.iFormId = l_formID;

 cont = ( ( getGE( f_vars ) ) and
          ( f_vars.iFormId == l_formID ) );

 while( cont )
  l_name = trim( f_vars.szVarName );
  message("Идет получение данных по переменной ~", l_name, "~");

  if( ПрочитатьПеременную( l_value, ДатаОтчета, ПредДатаОтчета,
                           {Название Отчета}, l_name )) 
    l_res = TRUE;
    if ( f_vars.cFormat == "%" )
      l_value = l_value * 100;
    end;
    if( l_value != 0 )
      varsList( varsList.Size ) = CvarRec( l_name, l_value ); 
    end;
  else
    undefList( undefList.Size ) = l_name;
  end;

  cont = ( ( next( f_vars ) ) and
           ( f_vars.iFormId == l_formID ) );
 end;
 return l_res;
END;

/* ......................................................................... */

/* ФИО исполнителя */
MACRO operName
 pers.Oper = {oper};
 if( not getEQ( pers ) )
  return "";
 end;
 return trim( pers.Name );
END;

/* ......................................................................... */

/* Записывать ли данные по заданной форме в файл */
MACRO writeFormData( p_num, p_fileName )
 var l_read,
     l_found,
     l_name;

 /* Первым делом проверим, определены ли переменные формы */
 l_read = getVarValues;

 if( not l_read )
  msgBox("Значения всех переменных формы не определены.|Экспорт не будет произведен.");
  exit(1);
 end;

 /* Далее */
 p_num   = string( p_num );

 l_found = _find( "[F" + p_num + "]", TRUE );

 if( l_found ) 
  if( not getTrue( TRUE, "В файле экспорта |" + p_fileName +"|есть данные по форме "+ p_num+ ".|Перезаписать данные по переменным формы?" ) );
   return FALSE;
  end;

  message( "Удаление предыдущих данных..." );

  _delete;
  while( ( _next ) and
         ( index( _get, "[" ) == 0 ) )
   _delete; 
  end;
  _prev; 

 elif( _find( _rekwSTR, TRUE ) )
  _prev;
 end; 

 l_name = operName;

 _insert( "[F" + p_num + "]" );

 if( p_num != "115" )
  _insert( "FIO_IS {" + l_name + "} TEL_IS {" + Номер_телефона + "}" );
 else
  _insert( "FIO {" + Руководитель_СлужбыКонтроля + "} FIO_IS {" + l_name +
           "} TEL_IS {" + Номер_телефона + "}" );
 end;

 return TRUE;
END;

/* ......................................................................... */

/* Номер первого реквизита в массиве, имя которого содержится в строке */
MACRO findFirst( p_str )
 var i = 0,
     n = _rekw.Size;

 while( i < n )
  if( index( p_str, _rekw(i).v_name ) != 0 )
   return i;
  end;

  i = i+1;
 end;
 return -1;
END;

/* ......................................................................... */

/* Выудить первое от начала значение реквизита из строки */
MACRO extractValue( p_str, p_ind )
 var l_p0,
     l_p1,
     l_res;

 p_str = trim( p_str );
 if( _rekw(p_ind).v_name != "NF" )
  l_p0 = strbrk( p_str, "{" );
  l_p1 = strbrk( p_str, "}" );
 else
  l_p0 = strbrk( p_str, " " );
  l_p1 = strbrk( substr( p_str, l_p0 + 1 ), " " ) + l_p0;
 end;

 if( ( l_p0 == 0 ) or
     ( l_p1 == 0 ) )
  return "";
 end;

 l_res = trim( substr( p_str, l_p0 + 1, l_p1 - l_p0 - 1 ) );
 setparm( 0, substr( p_str, l_p1 + 1 ) );
 return l_res;
END;

/* ......................................................................... */

/* Считать реквизиты из текстового файла */
MACRO readRekw
 var l_str,
     l_ind,
     l_p,
     l_name;

 if( not _find( _rekwSTR, TRUE ) )
  return FALSE;
 end; 

 /* Секция [REKW] */
 l_str = "";
 while( ( l_str != _dprtSTR ) and
        ( l_str != "[R015]" ) and
        ( _next             ) )

  l_str = _get;
  l_ind = findFirst( l_str );

  while( l_ind != -1 )
   _rekw(l_ind).v_val = extractValue( l_str, l_ind );

   l_ind = findFirst( l_str ); 
  end;
 end;

 if( l_str != _dprtSTR )/* нет секции R003 */
  return TRUE;
 end;

 /* Секция [R003] */
 while( ( l_str != "[R015]" ) and
        ( _next             ) )
  l_str = _get;

  l_p = strbrk( l_str, "{" );
  while( l_p != 0 )
   l_name = trim( substr( l_str, 1, l_p - 1 ) );
   if  ( l_name == _dprt(0).v_name ) /* 0,1 - стандартные реквизиты, записанные в R003 */
    _dprt(0).v_val = extractValue( l_str, 0 );
   elif( l_name == _dprt(1).v_name )
    _dprt(1).v_val = extractValue( l_str, 1 );
   else /* коды филиалов */
    _dprt_val = _dprt_val + extractValue( l_str, 0 ) + S_SEPARATOR;
   end;

   l_p = strbrk( l_str, "{" );
  end;
 end;

 return TRUE;
END;
/*............................................................................*/
/* 16.10.2007 Malakhova 110424*/
/*Функция получения БИК "нашего" банка на заданную дату
(для замены константы {MFO_Bank})
Под "нашим" банком понимаем филиал, которому подчиняется подразделение, выпускающее отчет
Если выпускаем отчет в филиале, то ищем БИК этого филиала
Если ничего не нашли, то возвращаем ""*/
MACRO rcbGetBic()
    var branch;
    var organizationStructure;
    var reportDate;

    var report;
    var data;

    var resultBic;

    report = RcbApplication().currentReport;

    branch                = report.context.departmentCode;
    organizationStructure = report.context.organizationStructure;
    reportDate            = report.context.period.endDate; 

    var queryText =           "SELECT rsb_rep_pt.get_partyCode(" + RCB_PTCK_BIC +            ", "
                     + "\n" + "                                 rsb_rep_pt.GetPartyIdByBranch(" + branch + ", "
                     + "\n" + "                                                               " + organizationStructure
                     + "\n" + "                                                              ), "
                     + "\n" + "                                " + getSqlDate(reportDate)  + ", "
                     + "\n" + "                                1"/*пока сделаем поиск с рекурсией по вышестоящим*/
                     + "\n" + "                                ) bic FROM DUAL";

    data = TRsbDataSet(queryText); 

    if (data.next())
        if ((data.bic != NULL) and (valType(data.bic) != V_UNDEF))
            resultBic = data.bic;
        else
            resultBic = "";
        end;
        
    else
        resultBic = "";
    end;

    return resultBic;
END;
/* ......................................................................... */

/* p_regN = TRUE, если изменился со сводного на обычный или наоборот */
MACRO diffRekw( p_regN )
 var l_n,
     l_dif,
     l_str,
     l_str1,
     l_str2,
     l_p,
     i,
     n;

 /* Получить реальные значения реквизитов и собрать данные по филиалам */
 _rekw(0).v_real  = trim( {Post_Addr} );
 _rekw(1).v_real  = trim( rcbGetBic() );  /* 17.10.2007 Malakhova 110424 - заменила {MFO_Bank} на rcbGetBic()*/
 _rekw(2).v_real  = trim( {Name_Boss} );
 _rekw(3).v_real  = trim( {FIO_Book}  );
 _rekw(4).v_real  = trim( {FIO_Boss}  );
 _rekw(5).v_real  = "";   /* Код ГУ ЦБ */
 _rekw(6).v_real  = trim( {Name_Bank} );
 _rekw(7).v_real  = 0;   /* количество открытых филиалов */
 _rekw(8).v_real  = string( Код_ОКПО  );
 _rekw(9).v_real  = "0"; /* признак наличия филиалов */
 _rekw(10).v_real = "0"; /* признак включения филиалов */
 _rekw(11).v_real = string( РегНомерБанка );
 _rekw(12).v_real = string( Код_СОАТО );

 if( НомерПодразделения != 32752 ) /* отчет не сводный */
  _rekw(11).v_real = _rekw(11).v_real + "/" + string( НомерПодразделения );
 end;

 _dprt(0).v_real = operName;
 _dprt(1).v_real = trim( Номер_телефона );

 if( НомерПодразделения == {NumDprt} )/* это не филиал (ГК) */
  rewind( dprt_ );
  while( next( dprt_ ) )
   if( ( dprt_.CloseDate == date( 0,0,0 ) ) or
       ( dprt_.CloseDate  > ДатаОтчета    ) ) /* филиал открыт на дату отчета */
    _rekw(7).v_real = _rekw(7).v_real + 1;

    if( trim( dprt_.cRX_UseSum ) != "" )/* признак включения */
     _rekw(10).v_real = "1";

     l_n = _dprt.Size;
     _dprt(l_n) = CrekwRec( string( l_n - 1, ":R2" ) );
     _dprt(l_n).v_real = trim( dprt_.Name );
    end;
   end;
  end;/*while next*/
 end;/*if ГК*/

 if( _rekw(7).v_real > 0 )
  _rekw(9).v_real = "1";
 end;
 _rekw(7).v_real = string( _rekw(7).v_real );

 /* Номер ГУ ЦБ */
 bnkd.PartyID = {OurBank};
 if( getEQ( bnkd ) )
  _rekw(5).v_real = "11" + trim( bnkd.Region );
 end;

 /* Сравнить с прочитанными */

 /* Секция [REKW] */
 i = 0;
 n = _rekw.Size;
 l_dif = FALSE;
 while( ( i < n ) and
        ( not l_dif ) )

  if( _rekw(i).v_val != _rekw(i).v_real )
   l_dif = TRUE;

   if( _rekw(i).v_name == "REGN" ) /* обрабатываем рег.номер */

    if( НомерПодразделения == 32752 ) /* сводный */
     l_str1 = _rekw(i).v_val;
     l_str2 = _rekw(i).v_real;
    else
     l_str1 = _rekw(i).v_real;
     l_str2 = _rekw(i).v_val;
    end;
    l_p = strbrk( l_str1, "/" );

    if( l_str2 == substr( l_str1, 1, l_p - 1 ) )
     l_dif = FALSE;
     setparm( 0, TRUE );
    else
     setparm( 0, FALSE );
    end;
   end;
  end;

  i = i+1;
 end;

 if( l_dif )
  return l_dif;
 end;

 /* Секция [R003] */
 if( НомерПодразделения != {NumDprt} )
  return _find( _dprtSTR, TRUE );
 end;

 if( ( _dprt(0).v_val != _dprt(0).v_real ) or
     ( _dprt(1).v_val != _dprt(1).v_real ) )
  return TRUE;
 end;

 /* Проверить филиалы */
 i = 2; /* начальный номер любого кода филиала, если он существует в списке */
 n = _dprt.size;
 while( i < n )
  if( index( _dprt_val, S_SEPARATOR + _dprt(i).v_real + S_SEPARATOR ) != 0 ) /* элемент принадлежит множеству */
   l_p = index( _dprt_val, _dprt(i).v_real + S_SEPARATOR );
   _dprt_val = substr( _dprt_val, 1, l_p - 1 ) +
               substr( _dprt_val, l_p + strlen( _dprt(i).v_real + S_SEPARATOR ) );

  else /* элемент отсутствует в списке */
   return TRUE;
  end;

  i = i+1;
 end;

 return ( _dprt_val != S_SEPARATOR );/* все элементы списка содержатся в массиве */
END;

/* ......................................................................... */

MACRO writeData( p_size, p_dataMacro, p_errorMacro, p_dprt )
 if( p_size == 0 )
  return;
 end;

 if( valtype( p_dprt ) != V_BOOL )
  p_dprt = FALSE;
 end;

 var i = 0,
     l_str = "",
     l_data = execMacro2( p_dataMacro, 0, p_dprt );

 while( i < p_size )

  if( strlen( l_str + l_data ) < _maxSTRLEN )
   l_str = l_str + l_data;
   i = i+1;

   if( i < p_size )
    l_data = execMacro2( p_dataMacro, i, p_dprt );
   else
    l_data = "";
   end;

  elif( l_str != "" )

   if( not _insert( l_str ) )
    execMacro( p_errorMacro, l_str );
   end;

   l_str = "";

  else
   msgBox( "Ошибка записи данных:|Параметр _maxSTRLEN ( файл exp_lib.mac, п.Настройка ) слишком мал.|Для корректной работы макросов экспорта необходимо |увеличить значение параметра минимум до ",
           strlen( l_data ), "." );
   printMessage( "Ошибка записи данных:", TPS_ERROR );
   printMessage( "Параметр _maxSTRLEN ( файл exp_lib.mac, п.Настройка ) слишком мал.", TPS_ERROR );
   printMessage( "Данные по форме могли быть некорректно записаны.", TPS_DETAILS );
   printMessage( "При последующем запуске рекомендуется перезаписать данные по форме.", TPS_DETAILS );
   printMessageLn( "Экспорт прерван.", TPS_TOPIC );
   _close;
   exit(0);
  end;
 end;

 if( ( l_str != "" ) and
     ( not _insert( l_str ) ) )
  execMacro( p_errorMacro, l_str );
 end;
END;

/* ......................................................................... */
/* Макросы для writeRekw */

MACRO _WR_getData( p_ind, p_dprt )
 var l_data = "",
     l_list;

 if( not p_dprt )
  l_list = _rekw;
 else
  l_list = _dprt;

  if( p_ind == 1 ) /* этот элемент в _dprt должен печататься последним */
   return l_data;

  elif( p_ind == _dprt.size )/* специальная уловка для последнего реквизита */
   p_ind = 1;
  end;
 end;

 if( l_list(p_ind).v_real != "" )
  if( l_list(p_ind).v_name != "NF" )
   l_data = l_list(p_ind).v_name + " {" + l_list(p_ind).v_real + "} ";
  else
   l_data = l_list(p_ind).v_name + " " + l_list(p_ind).v_real + " ";
  end;
 end;

 return l_data;
END;

MACRO _WR_error( p_str )
 printMessage( "Ошибка записи строки ", TPS_ERROR );
END;

/* ......................................................................... */

MACRO writeRekw
 var l_read,
     l_regN,
     l_diff;

 l_read = readRekw;
 l_diff = diffRekw( l_regN );

 if( ( ( l_read ) and
       ( l_diff ) and
       ( not getTrue( TRUE, "Реквизиты изменены. Перезаписать?" ) ) ) or

     ( ( l_read ) and
       ( not l_diff ) and
       ( not l_regN ) ) )
/*  _close;*/
  return;
 end;

 /* [REKW] */
 if( _find( _rekwSTR, TRUE ) )
  
  while( ( _next                        ) and
         ( index( _get, "[R015]" ) == 0 ) )
   _delete;
  end;
 else
  if( _find( "[R015]", TRUE ) )
   _prev;
  end;
  _insert( _rekwSTR );
 end; 

 if( _find( "[R015]", TRUE ) )
  _prev;
 end;

 writeData( _rekw.Size, @_WR_getData, @_WR_error );

 /* [R003] */
 if( НомерПодразделения != {NumDprt} ) /* это не главная контора */
/*  _close;*/
  return;
 end;

 if( _find( _dprtSTR, TRUE ) )
  
  while( ( _next                        ) and
         ( index( _get, "[R015]" ) == 0 ) )
   _delete;
  end;
 else
  if( _find( "[R015]", TRUE ) )
   _prev;
  end;
  _insert( "" );
  _insert( _dprtSTR );
  _insert( "" );
 end; 
 _prev;
 writeData( _dprt.Size + 1, @_WR_getData, @_WR_error, TRUE );
/* _close;*/
END;

/* ......................................................................... */

/* Формирование имени файла экспорта */
MACRO getFileName( /*p_dir, */p_date, p_prefix )
 var day, month, year,
     l_fName;

 datesplit( p_date, day, month, year );
 month = string( month );
 year  = string( year );

 l_fName = ( p_prefix + "_" + mkStr( "0", 2 - strlen( month ) ) + month +
            subStr( year, 3,2 ) + ".txt" );

  if( not GetExpFileName( l_fName ) )
   exit(1);
  end;
 /* Выбор имени файла 
 if( not selectFile( l_fName, p_dir + l_fName, "Введите имя файла экспорта" ))
  exit(1);
 end;
 */
 if( not _open( l_fName ) ) 
  msgBox("Невозможно открыть файл экспорта|" + l_fName );
  exit(1);
 end;

 return l_fName;
END;

/* EoF */
