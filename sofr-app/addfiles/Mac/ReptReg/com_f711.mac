/*
$Name:          com_f711.mac
$Module:        Регламентируемая отчетность
$Description:   Форма 711. Общие данные
*/

/* ──────────────────────────────────────────────────────────────────────────┐
   RS-Bank V6                                                 R-Style Softlab
   Файл подсистемы "Регламентированная отчетность"

   Общие данные формы 711

   CREATED : 09.09.05   Лузгин

   MODIFICATIONS:
   NOTES:

└─────────────────────────────────────────────────────────────────────────- */

import lib_vars;
import param;
import DepartmentFilter;
import log_lib;
import param; /* 19.09.2007 Malakhova 110424*/
import RepException;

/* ============================= Декларации =============================== */

/* ------------------------- Настройки и константы ------------------------ */

//CONST   MaxColumn_1 = ternary(RcbApplication().currentReport.context.period.endDate < RCB_I2055_DATE2, 15, 17);  // Количество граф в первом разделе
//CONST   MaxColumn_1_1 = ternary(RcbApplication().currentReport.context.period.endDate < RCB_I2055_DATE2, 9, 10); // Количество граф в первой таблице первого раздела
CONST   MaxColumn_1   = 15;  // Количество граф в первом разделе
CONST   MaxColumn_1_1 = 9;   // Количество граф в первой таблице первого раздела
CONST   FormID = НайтиИдентификаторОтчетаПоНазванию({Название отчета});
CONST   ConstName = "Ф711_";       // Для образования имен переменных
CONST   ИмяФайлаПротокола = GetNameLog( "711c" );
CONST   OurBank = {OurBank};

var m_is4927ChangesProject;

macro is4927ChangesProject()
    if (m_is4927ChangesProject == NULL)
        m_is4927ChangesProject = ternary(RcbApplication.currentReport.form.name == "Форма 711 по Пр. изм. 4927-У", true, false);
    end;

    return m_is4927ChangesProject;
end;

/* ------------------------ Файлы, структуры, диалоги --------------------- */

/* -------------------------- Классы, переменные -------------------------- */
/*//24 May 07 Thu 16:31:36 Malakhova Irina 101982*/
/*Изменила метаинформация в соответствии со значениями в dcy_strud_dbt*/
CLASS CStructMetaInfo711_2            // Метаинформация структуры переменных 2-го раздела
    var FieldNames  = ArrCreate( "Наименование депозитария", "Лицензия участника ОРЦБ",
        "Признак депозитария", "Междепозитарный счет", "Количество ц/б на счете" );
    var FieldSizes  = ArrCreate( 61, 16, 8, 36, 32 );
    var GroupFields = TArray;
END;

CLASS CStructMetaInfo711_3_1            // Метаинформация структуры переменной Ф711_3_1
    var FieldNames  = ArrCreate( "Эмитент", "ИНН эмитента", "Код типа ц/б", "Идентификатор ц/б",
        "Валюта ц/б", "Номинал ц/б", "Графа 32", "Графа 33", "Графа 34", "Графа 35", "Графа 36",
        "Графа 37", "Графа 38", "Графа 39", "Графа 40", "Графа 41", "Графа 42", "Графа 43",
        "Тип эмитента", "Способ заполнения номера" );
    var FieldSizes  = ArrCreate( 321, 36, 30, 26, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 3, 2 );
    var GroupFields = TArray;
END;

CLASS CStructMetaInfo711_3_2            // Метаинформация структуры переменной Ф711_3_2
    var FieldNames  = ArrCreate( "Эмитент", "ИНН эмитента", "Код типа ц/б",
        "Идентификатор ц/б", "Валюта ц/б", "Номинал ц/б", "Графа 50",
        "Графа 51", "Графа 52", "Графа 53", "Графа 54", "Графа 55",
        "Тип эмитента", "Способ заполнения номера" );
    var FieldSizes  = ArrCreate( 321, 36, 30, 26, 32, 32, 32, 32, 32, 32, 32, 32, 3, 2 );
    var GroupFields = TArray;
END;

VAR SortIndex_3 = ArrCreate( 0, 2, 3, 4, 5 );   // Последовательность сортировки для третьего раздела

/* ========================= Вспомогательные функции ====================== */

MACRO GetVarName( dep, i )
    if( dep == 1 )
        return ConstName + "Гр" + string(i);
    else
        return ConstName + string(dep) + "_" + string(i);
    end;
END;

MACRO GetCountryCode( CodeLat3 )
    var rs = TRsbDataSet( "SELECT t_CodeNum3 FROM dcountry_dbt WHERE t_CodeLat3 = '" + CodeLat3 + "'" );
    if( rs and rs.MoveNext() )
        return rs.CodeNum3;
    else
        return "";
    end;
END;

MACRO GetLicenseNumber( PartyId );
/* 19.09.2007 Malakhova 110424*/
/*Историзация кодов*/
    var code;

    code = repGetPartyCode(partyId, 17);

    return code;
END;

/**
 *  Структура элементов списка сегментов сортировки, используется в классе сортировки данных
 *  @since 6.00.020.29
 *  @author ABP
 */
private class TSegmentListElement(_name, _modifier)
    var name = _name;
    var modifier = _modifier;
end;

/**
 *  Базовый класс сортировки данных
 *  @since 6.00.020.29
 *  @author ABP
 */
private class TSorter()

    private macro isLess();
        throw(TPureVirtualMethodCallException("TSorter::isLess"));
    end;

    /**
     *  Поразрядная (лексикографическая) операция "меньше"
     *  Порядок элементов списка segmentList важен!!! Он должен соответствовать порядку полей сортировки
     */
    private macro isLessLexical(val1, val2, segmentList)

        var isLess = true;
        var isEqual = true;

        var i;

        var value1;
        var value2;

        i = 0;
        while ((i < segmentList.size) and isEqual)

            if (   (valType(segmentList[i].modifier) == V_STRING) and (segmentList[i].modifier != "")
                or (valType(segmentList[i].modifier) == V_PROC)
                or (valType(segmentList[i].modifier) == V_R2M)
               )
                value1 = execMacro2(segmentList[i].modifier, val1.fieldValue(segmentList[i].name).exact);
                value2 = execMacro2(segmentList[i].modifier, val2.fieldValue(segmentList[i].name).exact);
            else
                value1 = val1.fieldValue(segmentList[i].name).exact;
                value2 = val2.fieldValue(segmentList[i].name).exact;
            end;

            if (value1 < value2)
                isLess = true;
                isEqual = false;
            elif (value1 == value2)
                isLess = false;
                isEqual = true;
            else
                isLess = false;
                isEqual = false;
            end;

            i = i + 1;

        end;

        return isLess;

    end;

end;

/**
 *  Сортировка данных подраздела 1.2.1
 *  @since 6.00.020.29
 *  @author ABP
 */
class TSubpartition21ValuesSorter()
    macro isLess(val1, val2)
        return strUpr(val1.fieldValue("Наименование депозитария").exact) < strUpr(val2.fieldValue("Наименование депозитария").exact);
    end;
end;

/**
 *  Сортировка данных подраздела 1.2.2
 *  @since 6.00.020.29
 *  @author ABP
 */
class TSubpartition22ValuesSorter()
    macro isLess(val1, val2)
        return TSubpartition21ValuesSorter().isLess(val1, val2);
    end;
end;

/**
 *  Сортировка данных подраздела 1.3.1
 *  @since 6.00.020.29
 *  @author ABP
 */
class (TSorter) TSubpartition31ValuesSorter()
    private var m_segmentList = arrCreate(TSegmentListElement("Эмитент", "strUpr"),
                                          TSegmentListElement("Код типа ц/б", "strUpr"),
                                          TSegmentListElement("Идентификатор ц/б", "strUpr"),
                                          TSegmentListElement("Валюта ц/б"),
                                          TSegmentListElement("Номинал ц/б")
                                         );

    macro isLess(val1, val2)
        return isLessLexical(val1, val2, m_segmentList);
    end;
end;

/**
 *  Сортировка данных подраздела 1.3.2
 *  @since 6.00.020.29
 *  @author ABP
 */
class TSubpartition32ValuesSorter()
    macro isLess(val1, val2)
        return TSubpartition31ValuesSorter().isLess(val1, val2);
    end;
end;

/**
 *  Сортировка данных подраздела 1.4
 *  @since 6.00.020.29
 *  @author ABP
 */
class TSubpartition4ValuesSorter()
    macro isLess(val1, val2)
        return val1.fieldValue("okatoCode").exact < val2.fieldValue("okatoCode").exact;
    end;
end;

/**
 *  Сортировка данных подраздела 2.1
 *  @since 6.00.020.29
 *  @author ABP
 */
class (TSorter) TSection2Part1ValuesSorter()
    private var m_segmentList = arrCreate(TSegmentListElement("issuerName", "strUpr"),
                                          TSegmentListElement("series", "strUpr"),
                                          TSegmentListElement("number", "strUpr"),
                                          TSegmentListElement("issueDate", "date")
                                         );

    macro isLess(val1, val2)
        return isLessLexical(val1, val2, m_segmentList);
    end;
end;

/**
 *  Сортировка данных подраздела 2.2
 *  @since 6.00.020.29
 *  @author ABP
 */
class (TSorter) TSection2Part2ValuesSorter()
    private var m_segmentList = arrCreate(TSegmentListElement("series", "strUpr"),
                                          TSegmentListElement("number", "strUpr"),
                                          TSegmentListElement("issueDate", "date")
                                         );
    macro isLess(val1, val2)
        return isLessLexical(val1, val2, m_segmentList);
    end;
end;

/**
 *  Сортировка данных подраздела 2.3
 *  @since 6.00.020.29
 *  @author ABP
 */
class (TSorter) TSection2Part3ValuesSorter()
    private var m_segmentList = arrCreate(TSegmentListElement("issuerName", "strUpr"),
                                          TSegmentListElement("series", "strUpr"),
                                          TSegmentListElement("number", "strUpr"),
                                          TSegmentListElement("issueDate", "date")
                                         );

    macro isLess(val1, val2)
        return isLessLexical(val1, val2, m_segmentList);
    end;
end;

/**
 *  Контейнер для хранения объектов.
 *  @since 6.00.020.29
 *  @author ABP
 */
class TObjectDescriptor(_name, _object)
    var name = _name;
    var object = _object;
end;

/**
 *  Базовый класс ИД процедуры расчета
 *  @since 6.00.020.29
 *  @author ABP
 *  @commnet Годится на роль универсального ИД-контейнера для объектов с итератором next() и доступом к полям value("имя")
 */
class TDataSource()
    private var m_container : TArray;
    private var m_position : Integer;
    private var m_dataSource : Object;

    private macro nextContainer()
        var result = false;

        m_position = m_position + 1;
        result = ternary(m_position < m_container.size, true, false);

        if (result)
            m_dataSource = m_container[m_position];
        end;

        return result;
    end;

    macro add(name, object)
        m_container[m_container.size] = TObjectDescriptor(name, object);
    end;

    macro next()
        var result = true;

        if ((m_position == -1) or (not m_dataSource.object.next()))
            result = nextContainer();
            result = ternary(result, m_dataSource.object.next(), result);
        end;

        return result;
    end;

    macro getValue(attributeName)
        return execExp("m_dataSource.object." + attributeName);

        onError(error)
            exceptionMessage(error);
            exit(1);
//            return null;
    end;

    macro isExistsProtocol() : Bool
        return false;
    end;

    macro getProtocolTableName() : String
        return "";
    end;

    macro getProtocolData() : TArray
        return NULL;
    end;

    macro getProtocolFieldsList()
        return NULL;
    end;

    private macro constructorTDataSource()
        m_container = TArray();
        m_position = -1;
    end;

    constructorTDataSource();
end;

private class TStringProcessor
    private macro CHR10(str)
        return strSubst(str, "\n", "\" + strFor(10) + \"");
    end;

    macro process(str)
        return CHR10(strSubst(strSubst(str, "\\", "\\\\"), "\"", "\\\""));
    end;
end;

/**
 *  Печатное представление
 *  @author ABP
 *  @since 6.00.020.29
 */
class TPartView()
    private const MINIMAL_COLUMN_WIDTH = 14;
    private var m_table : CTableReport;
    private var m_dataSource : Object;
    private var m_binds : Object;

    /**
     * Количество пробельных символов слева.
     */
    private var m_countSpaceLeft: Integer = 0;

    /**
     * Количество пробельных символов справа.
     */
    private var m_countSpaceRight: Integer = 0;

    /**
     * Ширина основной части колонки.
     * По факту является минимальной шириной колонки.
     */
    private var m_widthBodyColumn: Integer = MINIMAL_COLUMN_WIDTH;

    /**
     * Максимальная ширина колонки.
     */
    private var m_maxWidthColumnNominalSum: Integer = 0;

    /**
     * Ширина, которую необходимо установить для колонки.
     */
    private var m_widthColumnNominalSum: Integer = 0;

    /**
     * Ошибка чтения настройки реестра.
     */
    var err_code;

    /**
     * Значение настройки реестра "максимальная ширина колонки номинальной суммы"
     */
    var val_type = getRegistryValue("REPTREG\\REP_GROUPS\\ФОРМА 711\\МАКСИМАЛЬНАЯ ШИРИНА ПОЛЯ", V_INTEGER, m_maxWidthColumnNominalSum, err_code);

    if ( (err_code != 0) or (val_type != V_INTEGER) )
        m_maxWidthColumnNominalSum = 14;
    end;

    macro printHeader()
        throw(TPureVirtualMethodCallException("TPartView::printHeader"))
    end;

    macro printFooter()
        m_table.printBottom();
    end;

    macro printEmptyData()
        m_table.printFreeString("Нет данных");
    end;

    macro getPart(partNumber)
        return this;
    end;

    macro getWidth()
        return m_table.getSumLen();
    end;

    macro addColumn(bindName, caption, width, align)
        m_table.addColumn(caption, double(width), align);
        m_binds[m_binds.size] = bindName;
    end;

    private macro convertZero(value)
        if (valType(value) == V_STRING)
            return ternary(value == "0", "", value);
        else
            return ternary(value == 0, "", value);
        end;
    end;

    private macro truncZero(value)
        if (valType(value) == V_STRING)
            return value;
        elif (valType(value) == V_MONEY)
            return ternary(double(value) - floor(double(value)) > 0.0, value, string(value:0:0));
        else
            return ternary(value - floor(value) > 0.0, value, string(value:0:0));
        end;
    end;

    private macro getCommandString(dataPool : TArray) : String
        var stringProcessor = TStringProcessor();
        var commandString : String = "";

        var i = 0;

        while (i < dataPool.size)
            dataPool[i] = nvl(dataPool[i], "");
            dataPool[i] = ternary(dataPool[i] == null, "", dataPool[i]);
            dataPool[i] = truncZero(dataPool[i]);
            dataPool[i] = convertZero(dataPool[i]);

            commandString = commandString + ", "
                          +  ternary(valType(dataPool[i]) == V_STRING,
                                     "\"" + stringProcessor.process(dataPool[i]) + "\"",
                                     ternary(valType(dataPool[i]) == V_MONEY, "Money("+dataPool[i]+")", dataPool[i])
                                    );
            i = i + 1;
        end;

        commandString = "m_table.printStringTransferByWord(" + subStr(commandString, 2) + ");";
        return commandString;
    end;

    private macro printString(dataPool : TArray)
        execExp(getCommandString(dataPool));
    end;

    private macro configureDataSource(dataSource : Object) : Object
        throw(TPureVirtualMethodCallException("TPartView::configureDataSource"));
    end;

    private macro makeData(dataSource : Object) : Object
        var current = dataSource.currentItem;
        var data = TArray();
        var i;

        for (i, m_binds)
            data[data.size] = current.fieldValue(i).current;
        end;

        return data;
    end;

    macro printData(dataSource : Object)
        dataSource = configureDataSource(dataSource);
        dataSource.first();

        while (not dataSource.isDone())
            printString(makeData(dataSource));
            dataSource.next();
        end;
    end;

    /**
     * Обрезать нули в конце строки.
     * @param str Исходная строка
     * @return String Обрезанная строка
     */
    macro trimNullsOnEnd(str: String)
        var i = strlen(str);
        while (substr(str, i, 1) == "0")
            i = i - 1;
            str = substr(str, 1, i);
        end;
        return str;
    end;

    /**
     * Расчитать ширину колонки "Номинальная стоимость".
     */
    private macro calcWidthColumnNominalSum(attributeName: String, faceValueField : String, faceValuePrecisionField : Variant, headerWidth : Integer, useNewAlg : Bool)
        defaultParm(faceValueField, "Номинал ц/б");
        defaultParm(faceValuePrecisionField, "Точность номинала ц/б");
        defaultParm(headerWidth, MINIMAL_COLUMN_WIDTH);
        defaultParm(useNewAlg, false);

        m_widthBodyColumn = headerWidth;

        var iterator = RcbApplication().currentReport.attributeValue(attributeName).createValueIterator();
        var currentValue: String = "";
        var currentWidth: Integer = 0;
        iterator.moveFirst();

        while (not iterator.isDone())
            var precision;
            if (valType(faceValuePrecisionField) == V_STRING)
                precision = iterator.currentItem.fieldValue(faceValuePrecisionField).exact;
            else
                precision = faceValuePrecisionField;
            end;

            if (not useNewAlg)
                currentValue = trimNullsOnEnd(iterator.currentItem.fieldValue(faceValueField).scaledAsString);
            else
                currentValue = string(iterator.currentItem.fieldValue(faceValueField).exact : 0 : *, precision);
            end;

            currentWidth = strlen(currentValue)
                           + precision
                           - strlen(substr(currentValue, index(currentValue, ".") + 1));

            if (m_widthColumnNominalSum < currentWidth)
                m_widthColumnNominalSum = currentWidth;
            end;
            iterator.moveNext();
        end;

        if ((m_maxWidthColumnNominalSum != 0) and (m_widthColumnNominalSum > m_maxWidthColumnNominalSum))
            m_widthColumnNominalSum = m_maxWidthColumnNominalSum;
        end;
        if (m_widthColumnNominalSum < m_widthBodyColumn)
            m_widthColumnNominalSum = m_widthBodyColumn;
        end;

        while (m_countSpaceLeft + m_widthBodyColumn + m_countSpaceRight < m_widthColumnNominalSum)
            m_countSpaceLeft = m_countSpaceLeft + 1;
            if (m_countSpaceLeft + m_widthBodyColumn + m_countSpaceRight == m_widthColumnNominalSum)
                break;
            end;
            m_countSpaceRight = m_countSpaceRight + 1;
        end;

        m_countSpaceLeft  = m_countSpaceLeft  + 1;
        m_countSpaceRight = m_countSpaceRight + 1;
    end;

    /**
     * Напечатать символы заполнения. Слева.
     */
    private macro printFillLeft(str)
        var i = 0;
        while (i < m_countSpaceLeft)
            print(str);
            i = i + 1;
        end;
    end;

    /**
     * Напечатать символы заполнения. Справа.
     */
    private macro printFillRight(str)
        var i = 0;
        while (i < m_countSpaceRight)
            print(str);
            i = i + 1;
        end;
    end;

    private macro constructorTPartView()
        m_table = CTableReport();
        m_binds = TArray();
    end;

    constructorTPartView();
end;

/**
 *  Печатное представление подраздела
 *  @author ABP
 *  @since 6.00.020.29
 */
class (TPartView) TSubpartView_I2055(header : String, footer : String, part : Object)
    private var m_part : TArray;
    private var m_header : String;
    private var m_footer : String;

    macro printHeader()
        print(m_header);
    end;

    macro printFooter()
        print(m_footer);
    end;

    macro getPart(partNumber)
        return m_part[partNumber - 1];
    end;

    macro getWidth()
        var i;
        var width = 0;

        i = 0;
        while (i < m_part.size)
            width = max(width, m_part[i].getWidth());
            i = i + 1;
        end;

        return width;
    end;

    private macro constructorTSubpartView_I2055(header : String, footer : String, part : Object)
        initTPartView();

        m_part = part;
        m_header = header;
        m_footer = footer;
    end;

    constructorTSubpartView_I2055(header, footer, part);
end;

/**
 *  Печатное представление подраздела (обертка)
 *  @author ABP
 *  @since 6.00.020.29
 */
class (TSubpartView_I2055) TSubpartView(header : String, footer : String, part : Object)
    initTSubpartView_I2055(header, footer, part)
end;

/**
 *  Ошибка вставки записи во временную таблицу
 */
private class (TException) TInsertTempTableException(tableName : String)
    initTException("Ошибка вставки записи во временную таблицу '" + tableName + "'");
end;

/**
* Класс вставки данных протокола во временные таблицы
*/
class TProtocolDataInserter(tableName : String, fieldsArray : TArray)
    private var m_inserterData = TArray();
    private var m_fieldsArray = TArray();

    private var m_inserterClause : String;
    private var m_tableName = tableName;
    private var m_fieldsCount = 0;
    private var m_recordsCount = 0;

    macro addData(dataArray : TArray)
        var i = 0;

        if (dataArray.size == 0)
            return;
        end;


        while (i < m_fieldsCount)
            m_inserterData[i][m_recordsCount] = dataArray[i];

            if (valtype(dataArray[i]) == V_STRING)
                if (nvl(m_fieldsArray[i][1], 0) < strLen(dataArray[i]) + 1)
                    m_fieldsArray[i][1] = strLen(dataArray[i]) + 1;
                end;
            else
                m_fieldsArray[i][1] = NULL;
            end;

            i = i + 1;
        end;

        m_recordsCount = m_recordsCount + 1;
    end;

    macro isExistsData()
        return ternary(m_recordsCount > 0, true, false);
    end;

    macro insertData()
        if (not isExistsData())
            return;
        end;

        var i = 0;
        var inserter = RsbSqlInsert(m_inserterClause, m_fieldsCount, m_recordsCount);

        while (i < m_fieldsCount)
            inserter.addParam(valType(m_inserterData[i][0]), m_inserterData[i], m_fieldsArray[i][1]);
            i = i + 1;
        end;

        if (not inserter.insert())
            throw(TInsertTempTableException(m_tableName));
        end;

        sql_execute("COMMIT");
    end;

    private macro setInserterClause(tableName : String, fieldsArray : TArray)
        var valuesClause = "";
        var i = 0;

        m_inserterClause = "INSERT INTO " + tableName + " (";

        while(i < m_fieldsCount)
            m_inserterClause = m_inserterClause + m_fieldsArray[i][0] +  ", ";
            valuesClause = valuesClause + "?, ";
            i = i + 1;
        end;

        valuesClause = substr(valuesClause, 1, strlen(valuesClause) - 2) + ")";
        m_inserterClause = substr(m_inserterClause, 1, strlen(m_inserterClause) - 2) + ")";
        m_inserterClause = m_inserterClause + " VALUES (" + valuesClause;
    end;

    private macro initFieldsArray(fieldsArray : TArray)
        var i = 0;

        while (i < fieldsArray.size)
            m_fieldsArray[i] = TArray(2);
            m_fieldsArray[i][0] = fieldsArray[i];

            m_inserterData[i] = TArray();
            i = i + 1;
        end;

        m_fieldsCount = m_fieldsArray.size;
    end;

    private macro constructorTProtocolData(tableName : String, fieldsArray : TArray)
        SQL_Truncate(tableName);

        initFieldsArray(fieldsArray);

        setInserterClause(tableName);
    end;

    constructorTProtocolData(tableName, fieldsArray);
end;
