/*
$Name: ctrl_intra501.mac
$Module: Регламентируемая отчетность
$Description: Форма 501.
*/

/*─────────────────────────────────────────────────────────────────────────────────────────────────┐
  RS-Bank V6                                                                        R-Style Softlab
  Файл подсистемы "Регламентируемая отчетность"

  Внутриформенный контроль формы 501.

  Создан: 18.10.2006 - Ser.
└─────────────────────────────────────────────────────────────────────────────────────────────────*/
/*
 *  Общебанковские интеры и модули
 */
import rsbDataSet;
import bankInter;
import acc_lib;
/*
 *  Интеры и модели подсистемы
 */
import rcbCoreInter;
import RcbWebCommon;
import c_f501;

/***************************************************************************************************
 *  Класс внутриформенного контроля
 **************************************************************************************************/
private class TIntraFormControl()
    private var protocol = CTableReport();
    private var errorCounter = 0;

    private macro constructor()
        protocol.AddColumn("!", 3);
        protocol.AddColumn("Объект проверки", 30);
        protocol.AddColumn("Примечание", 70);
    end;

    private macro getPathAndNameFiles()
        return getNameLog(strsubst(RcbApplication().currentReport.form.id, " ", "_") + "_intra_");
    end;

    private macro setBeginPrint()
        setoutput(getPathAndNameFiles);
    end;

    private macro setEndPrint()
        file tout() txt;
        Open( tout, SetOutput( NULL ) );
        RepTxtFilesQueue().add(SetOutput( NULL ));
        viewFile( tout );
        Close( tout );
    end;

    private macro printHeaderProtocol();
        private var beginDate = RcbApplication().currentReport.context.period.beginDate;
        private var endDate = RcbApplication().currentReport.context.period.endDate;
        private var dataSet = TRsbDataSet("SELECT t_Oper Oper, t_Name Name FROM dperson_dbt WHERE t_Oper = " + {Oper});
        DataSet.Next;
        [                                                                                      ];
        [Форма 501.                                                                            ];
        [Протокол внутриформенного контроля                                                    ];
        [Период отчета с #          по #                                                       ]( string(beginDate):l, string(endDate):l );
        [Дата и время выпуска отчета:  #           #                                           ]( string(date()):l, string(time()):l );
        [Исполнитель: #     #                                                                  ]({Oper}:l, dataSet.name:l);
    end;

    private macro printBottomProtocol();
        [                                                                                      ];
        [Всего ошибок: #                                                                       ](errorCounter);
    end;

    private macro printNoError()
        [                                                                                      ];
        [Контроль проведен успешно, ошибок не обнаружено                                       ];
    end;

    private macro checkBalance(account:string, balance:string)
        private const maskString = "30110, 30114, 30118, 30119";
        private var conditionString = (subStr(account, 1, 5) != balance);

        if (CompareStrWithMasks(maskString, account) AND conditionString)
            return false;
        end;
        return true;
    end;

    private macro isResident(account:string)
        private const maskString = "20315*, 20317*, 313*, 31702*, 320* & !32015*, 322* & !32211*, 32401*, 30109*, 30110*, 30116*, 30118*, 30119*, 30230*, 30231*";
        private var dataSet = TRsbDataSet("SELECT prt.t_notResident                " +
                                "\n"+     "  FROM daccount_dbt acc, dparty_dbt prt " +
                                "\n"+     " WHERE acc.t_client = prt.t_partyId     " +
                                "\n"+     "   AND acc.t_account = '" + account + "'" +
                                "\n"+     "   AND acc.t_chapter = 1                ");
        dataSet.Next();

        if ( (not CompareStrWithMasks(maskString, account)) AND (dataSet.notResident == "X") )
            return false;
        end;
        return true;
    end;

    private macro isNotResident(account:string)
        private const maskString = "20316*, 20318*, 314*, 316*, 31703*, 321* & !32115*, 323* & !32311*, 32402*, 30111*, 30114*, 30117*, 30119*, 30122*, 30123*, 30230*, 30231*";
        private var dataSet = TRsbDataSet("SELECT prt.t_notResident                " +
                                "\n"+     "  FROM daccount_dbt acc, dparty_dbt prt " +
                                "\n"+     " WHERE acc.t_client = prt.t_partyId     " +
                                "\n"+     "   AND acc.t_account = '" + account + "'" +
                                "\n"+     "   AND acc.t_chapter = 1                ");
        dataSet.Next();

        if ( (not CompareStrWithMasks(maskString, account)) AND (dataSet.notResident == "") )
            return false;
        end;
        return true;
    end;

    private macro checkPerfomanseDate(account:string)
        file acc ("account.dbt");
        acc.account = account;
        acc.chapter = 1;
        acc.code_currency = -9999;
        if (not getGE(acc))
//            msgBox("запись не найдена");
            msgBox("запись не найдена", "|", account);
        end;
        private var PerfomanceDate = readNoteForObject( OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ),
                                                         NOTEKIND_DATE_PAYING, rcbApplication().currentReport().context.period.endDate );
        private var conditionString = ( (subStr(account, 4, 2) != "01") AND (perfomanceDate == "")
                                    AND (acc.operationDate == "") AND (acc.daysToEnd == 0) );
        if (conditionString)
            return false;
        end;
        return true;
    end;

    private macro checkNotResidentCountry(account:string)
        private var dataSet = TRsbDataSet("SELECT prt.t_notResident, prt.t_nrCountry " +
                                "\n"+     "  FROM daccount_dbt acc, dparty_dbt prt " +
                                "\n"+     " WHERE acc.t_client = prt.t_partyId     " +
                                "\n"+     "   AND acc.t_account = '" + account + "'" +
                                "\n"+     "   AND acc.t_chapter = 1                ");
        dataSet.Next();
        if ( (dataSet.notResident == "X") AND (dataSet.nrCountry == "") )
            return false;
        end;
        return true;
    end;

    private macro checkNullRestOut(restIn:money, restOut:money, debet:money, credit:money, perfomanceDate:string)
        private var conditionString = ( (restIn != 0) OR (debet != 0) OR (credit !=0));
        private var endDate = rcbApplication().currentReport().context.period.endDate;
        if ( (restOut == 0) AND conditionString)
            if ( perfomanceDate > endDate )
                return false;
            end;
        end;
        return true;
    end;

    private macro checkIrReducibleRest(account:string, kindAccount:integer)
        file acc ("account.dbt");
        var irReducibleRest = true;
        acc.account = account;
        acc.chapter = 1;
        acc.code_currency = -9999;
        if (not getGE(acc))
//            msgBox("запись не найдена");
            msgBox("запись не найдена", "|", account);
        end;
        private var noteIrReducibleRest = ReadNoteForObject ( OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ), 14, rcbApplication().currentReport().context.period.endDate );
        private var noteRate = ReadNoteForObject ( OBJTYPE_ACCOUNT, UniID( acc, OBJTYPE_ACCOUNT ), 19, rcbApplication().currentReport().context.period.endDate );

        GetRegistryValue( "REPTREG\\REP_GROUPS\\ФОРМА 501\\НЕСНИЖАЕМЫЙ ОСТАТОК",V_BOOL, irReducibleRest, NULL );
        if ( irReducibleRest AND (kindAccount == 2) )
            if ( (noteIrReducibleRest != 0.0) OR (noteRate != 0.0) )
                if   (noteIrReducibleRest == 0.0)
                    return "неснижаемый остаток";
                elif (noteRate == 0.0)
                    return "процентная ставка";
                end;
            end;
        end;
        return "true";
    end;

    private macro checkRestOut(partNumber:integer, restIn:money, restOut:money, debet:money, credit:money)
        private var calculateRestOut = $0.0;
        if (partNumber == 1)
            calculateRestOut = restIn + debet - credit;
        else
            calculateRestOut = restIn - debet + credit;
        end;
        return round(restOut - calculateRestOut, 2);
    end;



    private macro checkPartData(partNumber:integer)
        private var iterator = rcbApplication().currentReport().attributeValue("Ф501_" + string(partNumber)).createValueIterator();
        private var tmpValue = $0.0;
        private var tmpStr = "";

        private macro IsLess(v1, v2)/* функция для сортировки (оператор меньше) */
            return (v1.fieldValue("КодКО").exact < v2.fieldValue("КодКО").exact);
        end;

        iterator.setSortOrder(@IsLess);
        iterator.moveFirst();

        var i = 0, structValue;
        iterator.moveFirst();
        while (not iterator.isDone())
            structValue = iterator.currentItem();
            i = i + 1;

            if ( not checkBalance( structValue.fieldValue("НомЛС").exact, structValue.fieldValue("НомБС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль соответствия первых пяти позиций " +
                                                 "номера лицевого счета номеру балансового счета",
                                                 "Ошибка. Для лицевого счета "  + structValue.fieldValue("ОтчНомЛС").exact +
                                                 " баласнсовый счет " + structValue.fieldValue("НомБС").exact +
                                                 " не соответствует требуемому");
            errorCounter = errorCounter + 1;
            end;

            if ( not isResident( structValue.fieldValue("НомЛС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль допустимости введенного балансового счета второго порядка для резидента",
                                                 "Ошибка. Клиент "  + structValue.fieldValue("НаимКО").exact +
                                                 " является нерезидентом");
            errorCounter = errorCounter + 1;
            end;

            if ( not isNotResident( structValue.fieldValue("НомЛС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль допустимости введенного балансового счета второго порядка для нерезидента",
                                                 "Ошибка. Клиент "  + structValue.fieldValue("НаимКО").exact +
                                                 " не является нерезидентом");
            errorCounter = errorCounter + 1;
            end;

            if (NOT TParameters().m_isMmData)
                if ( not checkPerfomanseDate( structValue.fieldValue("НомЛС").exact) )
                    protocol.memStringTransferByWord("!",
                                                     "Контроль даты погашения",
                                                     "Ошибка. По л/счету "  + structValue.fieldValue("НомЛС").exact +
                                                     " не задана дата погашения");
                errorCounter = errorCounter + 1;
                end;
            end;

            if ( not checkNotResidentCountry( structValue.fieldValue("НомЛС").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль данных нерезидента",
                                                 "Ошибка. Не определена страна нерезидента, клиент " +
                                                 structValue.fieldValue("НаимКО").exact);
            errorCounter = errorCounter + 1;
            end;

            if ( not checkNullRestOut(structValue.fieldValue("ОстВход").exact,
                                      structValue.fieldValue("ОстИсход").exact,
                                      structValue.fieldValue("ОбДебет").exact,
                                      structValue.fieldValue("ОбКредит").exact,
                                      structValue.fieldValue("ДатаИспОб").exact) )
                protocol.memStringTransferByWord("!",
                                                 "Контроль нулевого исходящего остатка",
                                                 "Ошибка. Исходящий остаток по л/счету "  + structValue.fieldValue("НомЛС").exact +
                                                 "  = 0. Дата погашения должна быть больше или равна дате окончания отчетного периода");
            errorCounter = errorCounter + 1;
            end;

            tmpStr = checkIrReducibleRest(structValue.fieldValue("НомЛС").exact, structValue.fieldValue("ТипЛС").exact);
            if ( tmpStr != "true")
                protocol.memStringTransferByWord("!",
                                                 "Объект проверки - \"Контроль неснижаемого остатка\"",
                                                 "Ошибка. Для лицевого счета "  + structValue.fieldValue("НомЛС").exact +
                                                 " не определено значение примечания " + tmpStr );
            errorCounter = errorCounter + 1;
            end;

            tmpValue = checkRestOut(partNumber,
                                    structValue.fieldValue("ОстВход").exact,
                                    structValue.fieldValue("ОстИсход").exact,
                                    structValue.fieldValue("ОбДебет").exact,
                                    structValue.fieldValue("ОбКредит").exact);
            if ( tmpValue != 0)
                protocol.memStringTransferByWord("!",
                                                 "Построчный контроль (входящие остатки плюс обороты равны исходящим",
                                                 "Ошибка. Для лицевого счета "  + structValue.fieldValue("НомЛС").exact +
                                                 " факт исх. остаток " + structValue.fieldValue("ОстИсход").exact +
                                                 ", рассчит. исх. остаток " +
                                                 string(structValue.fieldValue("ОстИсход").exact + tmpValue) +
                                                 ", сумма несоответствия " + abs(tmpValue) );
            errorCounter = errorCounter + 1;
            end;

            iterator.moveNext();
        end;

    end;

    macro execute()
        private const PART_1 = 1;
        private const PART_2 = 2;

        setBeginPrint();
        printHeaderProtocol();
        protocol.memHead();
        checkPartData(PART_1);
        checkPartData(PART_2);

        if (errorCounter > 0)
            protocol.printMemStr();
            protocol.printBottom();
            printBottomProtocol()
        else
            protocol.resetMemStr();
            printNoError();
        end;
        setEndPrint();

        RepTxtFilesQueue().add(getPathAndNameFiles());
    end;

    macro viewProtocolFile()
        viewFileLog(getPathAndNameFiles());
    end;

    constructor();
end;

/***************************************************************************************************
 *  Функция для вывода протокола внутриформенного контроля
 **************************************************************************************************/
private macro viewProtocolFile()
    TIntraFormControl().viewProtocolFile();
end;

/***************************************************************************************************
 *  Основная функция
 **************************************************************************************************/
private macro main()
    TIntraFormControl().execute();
end;
/***************************************************************************************************
 *  Вызов осуществляется системной операцией
 **************************************************************************************************/
УстановитьФлагВозврата( OK_MACRO_FLAG);
exit(1);
