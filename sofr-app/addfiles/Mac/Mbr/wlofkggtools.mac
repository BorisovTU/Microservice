/*
 $Name:        wlofkggtools.mac
 $Module:      Межбанковские расчеты
 $Description: Общие константы и вспомогательные функции для работы с ГИС ГМП
*/

import "xmlmestools.mac";

//Найти все исходящие сообщения ГИС ГМП по референсу
macro FindOutMesGG( MesID:TArray, TpSchemID:integer, Value:string, findOutMesPack:bool ):bool

  var parm:TArray = makeArray( SQLParam("TpSchemID", TpSchemID), SQLParam("SearchStr", Value) );

  var select = " SELECT outmes.t_MesID ";
  if( findOutMesPack )
    select = select + "   ,sess.t_SessUID as t_Reference ";
  else
    select = select + "   ,outmes.t_RelatedRef as t_Reference ";
  end;
  select = select + "   FROM dwlmes_dbt outmes ";
  if( findOutMesPack )
    select = select + ", dwlsess_dbt sess ";
  end;
  select = select + "  WHERE     outmes.t_Direct = CHR(0) "
                    "        AND outmes.t_TpSchemID = :TpSchemID ";
  if( findOutMesPack )
    select = select + " AND outmes.t_SessionID = sess.t_SessionID "
                      " AND sess.t_SessUID  = :SearchStr ";
  else
    select = select + " AND outmes.t_RelatedRef = :SearchStr ";
  end;

  var rs = execSQLselect( select, parm, FALSE );
  var finded = false;
  while( rs.moveNext() )
    finded = true;
    MesID[MesID.size] = rs.value(0);
    if( not findOutMesPack )
      break;
    end;
  end;

  return finded;
end;


/* Ищет дочерний узел в рамках узла. В дочерние входит только в рамках указанного пути */
macro FindChildNode( node:object, nodeName, path )   

   var i, child:object;
   var result = "", chName;

   if( index( path, "/") == 0 )
     chName = path;
   else
     chName = substr( path, 1, index( path, "/" ) - 1 );
   end;

   i = 0;
   while( i < node.childNodes.length )
     child = node.childNodes.item( i );
       if( child and ( child.nodeType == CHILD_NODE ) and ( GetNodeName( child.NodeName ) == chName ) )
         if( index( path, "/" ) == 0 )
           return FindChildNode( child, nodeName, "" );
         else
           return FindChildNode( child, nodeName, substr( path, index( path, "/" ) + 1 ) );
         end;
       end;
     i = i + 1;
   end;
   i = 0;
   while( i < node.childNodes.length )
     child = node.childNodes.item( i );
     if( child and ( child.nodeType == CHILD_NODE ) )
       if ( GetNodeName( child.NodeName ) == nodeName )
         return true;
       end;
     end;
     i = i + 1;
   end;

   return false;
end;

/* Ищет значение узла. В дочерние входит только в рамках указанного пути */
macro ReadValue( node:object, attrName, path )  
 
  var i, child:object;
  var result = "", chName;

  if( index( path, "/" ) == 0 )
    chName = path;
  else
    chName = substr( path, 1, index( path, "/" ) - 1 );
  end;

  i = 0;
  while( i < node.childNodes.length )
    child = node.childNodes.item( i );
    if( child and ( child.nodeType == CHILD_NODE ) and ( GetNodeName( child.NodeName ) == chName ) )
      if( index( path, "/" ) == 0 )
        return ReadValue( child, attrName, "" );
      else
        return ReadValue( child, attrName, substr( path, index( path, "/" ) + 1 ) );
      end;
    end;
    i = i + 1;
  end;
  i = 0;
  while( i < node.childNodes.length )
    child = node.childNodes.item( i );
    if( child and ( child.nodeType == TEXT_NODE ) )
      i = node.attributes.length;
      result = child.nodeValue;
    end;
    i = i + 1;
  end;

  return result;
end;
