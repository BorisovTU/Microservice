/*
  $Name:         ufgd101.mac
  $Module:       Межбанковские расчеты
  $Description:  Генерация платежей по сообщениям УФЭБС ED101
*/

/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/* Генерация платежей по сообщениям УФЭБС ED101                             */
/*                                                                          */
/* Имя файла: ufgd101.mac                                                   */
/* Создан:    07.10.04                                             BARS     */
/****************************************************************************/
import "ufgendoc.mac", "akkrtls.mac";

RECORD wl_akkr(pmakkr);

const ED101 = "ED101",
      ED102 = "ED102",
      ED103 = "ED103",
      ED104 = "ED104",
      ED105 = "ED105",
      ED110 = "ED110";

private macro FillPmProp( xml, pmpaym, pmprop, Side, tagName )

  InitPMPROP( pmprop );
  pmprop.DebetCredit = Side;

  pmprop.PayFIID   = 0;
  pmprop.CodeKind  = PTCK_BIC;
  pmprop.BankCode  = ReadAttribute( xml, "BIC", tagName + "/Bank" );

  if( pmpaym.ValueDate == date(0, 0, 0) )
    pmprop.TransferDate = {curdate};
  else
    pmprop.TransferDate = pmpaym.ValueDate;
  end;

end;

macro GenDoc( addrMes, type, ver_st )
  var xml:object = ActiveX( "MSXML.DOMDocument" );
  var Строка, Сумма, Corschem, Currency, Error, TagPayer, TagPayee, PaytKind;
  var DebetCredit = PRT_Credit;

  /*Для аккредитивов*/
  var Representation  :string,      /*Платеж по представлению*/
      AddCondition    :string,      /*Дополнительные условия*/
      PayCondition    :string,      /*Условия оплаты*/
      AkkrCover       :string,      /*Покрытие*/
      AkkrAccount     :string,      /*счет получателя*/
      AkkrType        :string,      /*Тип аккредитива*/
      AkkrExpire      :string,      /*Срок действия аккредитива*/
      AcptAccNo       :string;      /*Номер счёта по учёту аккредитивов*/

  SetBuff( wlmes, addrMes );

  PrintLog( 2, "Генерация платежа по " + type );

  ClearRecord( wlpmpaym );
  ClearRecord( wlpmpropdeb );
  ClearRecord( wlpmpropcred );
  ClearRecord( wlpmrmprop );
  ClearRecord(wl_akkr);

  if( not СчитатьПоле( XMLField, Строка ) )
    return FALSE;
  end;

  if ( not xml.loadXML(Строка) )
     println( string( "Неверный формат сообщения по форме " + type ) );
     return false;
  end;
  if( Type == ED110 )
      TagPayer = "PayerBrf";
      TagPayee = "PayeeBrf";
  else
      TagPayer = "Payer";
      TagPayee = "Payee";
  end;

  /* Заполнение учетных буферов */
  Сумма = ReadAttribute(xml,"Sum");
  wlpmpaym.Amount     = moneyL( Сумма )/100;
  wlpmpaym.PayAmount  = wlpmpaym.Amount;
  wlpmpaym.BaseAmount = wlpmpaym.Amount;

  if( СчитатьПоле( NodePacketDate, Строка ) AND (Строка!="") )
     wlpmpaym.ValueDate = ToDate(Строка);
  else
     wlpmpaym.ValueDate = wlmes.OutsideAbonentDate;
  end;

  wlpmpaym.FIID              = 0;
  wlpmpaym.PayFIID           = wlpmpaym.FIID;

  wlpmpaym.ReceiverBankMarkDate = ToDate(ReadOptinalAttribute(xml,"ReceiptDateCollectBank"));

  if ( type==ED105 )
     wlpmpaym.PartPaymNumber = ReadOptinalAttribute(xml,"PaytNo","PartialPayt");
     wlpmpaym.PartPaymShifrMain = ReadOptinalAttribute(xml,"TransKind","PartialPayt");
     wlpmpaym.PartPaymRestAmountMain = moneyL( doubleL( ReadOptinalAttribute(xml,"SumResidualPayt","PartialPayt") ) )/100;
     wlpmpaym.PartPaymNumMain = ReadOptinalAttribute(xml,"AccDocNo","PartialPayt/AccDoc");
     wlpmpaym.PartPaymDateMain = ToDate( ReadOptinalAttribute(xml,"AccDocDate","PartialPayt/AccDoc") );
  end;

  if ( type==ED103 )
    ClearRecord(wlpmdemand);
    PayCondition   = ReadAttribute(xml,"PaytCondition");/*Условия оплаты*/
    wlpmdemand.AcceptTerm = GetAcceptTermByPaytCond(PayCondition);
    wlpmdemand.Accept = PM_DEMAND_ACCEPT_NONE;
  end;

  wlpmpaym.PayerAccount      = ReadOptinalAttribute(xml,"PersonalAcc", TagPayer);
  if ( type==ED102 )
      /*Для аккредитивов*/
      Representation = ReadNodeText(xml,"DocRequired");          /*Платеж по представлению*/
      AddCondition   = ReadNodeText(xml,"AdditionalConditions", false); /*Дополнительные условия*/
      PayCondition   = ReadAttribute(xml,"PaytCondition");/*Условия оплаты*/
      if((PayCondition != 1) And (PayCondition != 2))
         std.msg("Неверно заполнен атрибут 'PaytCondition'(должно быть 1 или 2)" );
         return FALSE;
      end;
      AkkrCover      = ReadAttribute(xml,"DocCreditReimbursement");      /*Покрытие*/
      if((AkkrCover != 1) And (AkkrCover != 2))
         std.msg("Неверно заполнен атрибут 'DocCreditReimbursement'(должно быть 1 или 2)" );
         return FALSE;
      end;
      AkkrAccount    = ReadAttribute(xml,"BeneficiaryAccNo" );      /*счет получателя*/
      AkkrType       = ReadAttribute(xml,"DocCreditForm" );      /*Тип аккредитива*/
      AkkrExpire     = ReadAttribute(xml,"ExpiryDate" );      /*Срок действия аккредитива*/
      if((AkkrType != 1) And (AkkrType != 2))
         std.msg("Неверно заполнен атрибут 'DocCreditForm'(должно быть 1 или 2)" );
         return FALSE;
      end;

      AcptAccNo = ReadOptinalAttribute(xml,"AcptAccNo");
      if ( AkkrCover==1 )
         if(AcptAccNo != "")
         wlpmpaym.ReceiverAccount   = ReadOptinalAttribute(xml,"AcptAccNo" );           
         else
            std.msg("Aтрибут 'AcptAccNo' обязательно должен быть заполнен для покрытых аккредитивов");
            return FALSE;
         end;
      else
         if(AcptAccNo != "")
            std.msg("Aтрибут 'AcptAccNo' не заполняется для непокрытых аккредитивов");
            return FALSE;
         end;
     end;
  else
     wlpmpaym.ReceiverAccount   = ReadOptinalAttribute(xml,"PersonalAcc", TagPayee);  
     /*на счет наличия поля PayeePersonalAcc для сообщений ED103 - так сказал аналитик, SCR№98195*/
     if( wlpmpaym.ReceiverAccount == "" )
        wlpmpaym.ReceiverAccount   = ReadOptinalAttribute(xml,"PayeePersonalAcc", TagPayee);  
     end;
  end;


  
  FillPmProp( xml, wlpmpaym, wlpmpropdeb , 0, TagPayer );
  FillPmProp( xml, wlpmpaym, wlpmpropcred, 1, TagPayee );

  Corschem = ПолучитьКорсхемуПоУмолчанию( wlmes.OutsideAbonentID, 0, 1, "К", -1, -1, 0, -1, "", NULL, false, wlmes.TpSchemID );
  if( Corschem == -1 )
    std.msg( "Не определена схема расчетов для респондента в рублях" );
    return FALSE;
  end;

  var PayerBankBIC : string = wlpmpropdeb.BankCode; // атрибут Payer\Bank\BIC из сообщения
  var PayerBankID : integer = ПолучитьКодСубъекта(PayerBankBIC, PTCK_BIC);
  if( InList(Type, ED103, ED104) and PM_IsBankInTS(PayerBankID, true) )
    DebetCredit = PRT_Debet;
  else
    DebetCredit = PRT_Credit;
  end;

  if( DebetCredit == PRT_Credit )
    wlpmpropdeb.Group = PAYMENTS_GROUP_EXTERNAL;
    wlpmpropdeb.IsSender = "X";
    wlpmpropdeb.Corschem    = Corschem;
    wlpmpropdeb.CorrPosType = PM_CORRPOS_TYPE_USER;
  else
    wlpmpropcred.Group = PAYMENTS_GROUP_EXTERNAL;
    wlpmpropcred.IsSender = "X";
    wlpmpropcred.Corschem    = Corschem;
    wlpmpropcred.CorrPosType = PM_CORRPOS_TYPE_USER;
  end;

  var DetailsDateCr = ReadOptinalAttribute(xml,"CreditDate", "ProcessingDetails");
  var DetailsDateDb = ReadOptinalAttribute(xml,"DebitDate", "ProcessingDetails");
  if( (Type == ED101) or (Type == ED105) )
    if( strlen(DetailsDateCr) != 0 )
      wlpmpropdeb.TransferDate = ToDate(DetailsDateCr);
      wlpmpaym.ValueDate = ToDate(DetailsDateCr);
    end;
  elif( (Type == ED103) or (Type == ED104) )
    if( strlen(DetailsDateCr) != 0 )
      if( wlpmpropdeb.IsSender == "X" )
        wlpmpropdeb.TransferDate = ToDate(DetailsDateCr);
        wlpmpaym.ValueDate = ToDate(DetailsDateCr);
      end;
    end;
    if( strlen(DetailsDateDb) != 0 )
      if( wlpmpropcred.IsSender == "X" )
        wlpmpropcred.TransferDate = ToDate(DetailsDateDb);
        wlpmpaym.ValueDate = ToDate(DetailsDateDb);
      end;
    end;
  end;
      
  /* Реквизиты платежа, характерные для R-макета */
  wlpmrmprop.Number = ReadAttribute(xml,"AccDocNo", "AccDoc");

  wlpmrmprop.Date = ToDate(ReadAttribute(xml,"AccDocDate", "AccDoc"));

  // Дата поступления в банк плательщика  
  wlpmpaym.PayerBankEnterDate      = ToDate(ReadOptinalAttribute(xml,"ReceiptDate"));

  // Дата помещения в картотеку
  wlpmpaym.I2PlaceDate             = ToDate(ReadOptinalAttribute(xml,"FileDate"));

  wlpmrmprop.PayerINN              = ConstructINN( ReadOptinalAttribute(xml,"INN", TagPayer), ReadOptinalAttribute(xml,"KPP", TagPayer) );
  wlpmrmprop.ReceiverINN           = ConstructINN( ReadOptinalAttribute(xml,"INN", TagPayee), ReadOptinalAttribute(xml,"KPP", TagPayee) );

  if ( type!=ED110 )
     wlpmrmprop.PayerName             =  ReadNodeText(xml,TagPayer + "/Name");
     wlpmrmprop.ReceiverName          =  ReadNodeText(xml,TagPayee + "/Name");
  end;

  if ( type==ED102 )
     wlpmrmprop.Ground                = ReadNodeText(xml,"GoodsDescription");
  elif(type != ED110)
     wlpmrmprop.Ground                = ReadNodeText(xml,"Purpose");
  end;

  wlpmrmprop.TaxAuthorState  = ReadOptinalAttribute(xml, "DrawerStatus", "DepartmentalInfo");
  wlpmrmprop.BttTICode       = ReadOptinalAttribute(xml, "CBC",          "DepartmentalInfo");

  wlpmrmprop.OKATOCode       = ReadOptinalAttribute(xml, "OKATO",        "DepartmentalInfo");
  wlpmrmprop.TaxPmGround     = ReadOptinalAttribute(xml, "PaytReason",   "DepartmentalInfo");
  wlpmrmprop.TaxPmPeriod     = ReadOptinalAttribute(xml, "TaxPeriod",    "DepartmentalInfo");
  wlpmrmprop.TaxPmNumber     = ReadOptinalAttribute(xml, "DocNo",        "DepartmentalInfo");
  wlpmrmprop.TaxPmDate       = ReadOptinalAttribute(xml, "DocDate",      "DepartmentalInfo");
  wlpmrmprop.TaxPmType       = ReadOptinalAttribute(xml, "TaxPaytKind",  "DepartmentalInfo");    
 
  wlpmrmprop.PayerChargeOffDate = ToDate(ReadOptinalAttribute(xml,"ChargeOffDate"));

  wlpmrmprop.DocDispatchDate =  ToDate(ReadOptinalAttribute(xml,"DocDispatchDate"));

  wlpmpaym.ReceiverBankMarkDate = {curdate};  

  if ( type!=ED102 )
     wlpmrmprop.Priority              = int( ReadAttribute(xml,"Priority") );
  end;

  if( (type == ED110) and (ver_st >= 2016) )
    wlpmrmprop.PaymentKind = PM_GetDefaultPaymentKind(WL_INDOC);
  else
    PaytKind = int(ReadOptinalAttribute(xml,"PaytKind"));
    if( type == ED110 )
      if((PaytKind != 0) AND (PaytKind != 2) AND (PaytKind != 3))
        std.msg( "|Недопустимое значение атрибута 'PaytKind'" );
        return FALSE;
      end;
    elif((type == ED102) or (type == ED105))
      if((PaytKind < 0) or (PaytKind > 3))
        std.msg( "|Недопустимое значение атрибута 'PaytKind'" );
        return FALSE;
      end;
    else
      if((PaytKind < 0) or (PaytKind > 5))
        std.msg( "|Недопустимое значение атрибута 'PaytKind'" );
        return FALSE;
      end;
    end;
  
    wlpmrmprop.PaymentKind           = PaytKindToPaymentKind(PaytKind);
  end;

  wlpmrmprop.ProcessKind           = " 1";
  wlpmrmprop.ShifrOper             = ReadAttribute(xml,"TransKind");

  wlpmrmprop.PayerCorrAccNostro    = ReadOptinalAttribute(xml,"CorrespAcc", TagPayer + "/Bank");
  wlpmrmprop.ReceiverCorrAccNostro = ReadOptinalAttribute(xml,"CorrespAcc", TagPayee + "/Bank");

  if( (type==ED101) or (type==ED105) )
    wlpmrmprop.reference = wlmes.relatedRef;
  end;

  wlpmrmprop.UIN = ReadOptinalAttribute(xml,"PaymentID");

  var pist:SetPISetting = SetPISetting(); // Параметры выполнения функции SetPI.
  pist.INN = false; // ИНН в SetPI заполнять не надо.

  if( InList( type, ED101, ED103, ED104, ED105 ) and ver_st == 3 )
    wlpmrmprop.Precedence = ReadOptinalAttribute( xml, "PaymentPrecedence");
    wlpmrmprop.SettlementTime = GetSettlementTime( xml, wlmes, wlpmrmprop.SettlementTime );
  end;

  if ( type==ED102  /* Аккредитив */)
    /*условия представления */
    if( Representation ) wl_akkr.Representation  = Representation; end;  
    /*дополнительные условия */
    if( AddCondition )   wl_akkr.AddCondition    = AddCondition;   end;  
    
    /*условия оплаты*/
    wl_akkr.PayCondition = int(PayCondition) - 1;  
    
    wl_akkr.Type = ПроставитьОтзывностьИПокрытие(AkkrType, AkkrCover);

    /*счет получателя */
    if( AkkrAccount )    wl_akkr.AccRealReceiver = AkkrAccount;    end;  

    if( AkkrExpire )     wl_akkr.Date            = ToDate(AkkrExpire); end;

    if ( (wlpmpropdeb.BankCode!="") AND (wlpmpropcred.BankCode!="") )
       ПользовательскаяДоработкаПлатежа( wlmes, wlpmpaym, wlpmpropdeb, wlpmpropcred, wlpmrmprop );
          if( not ВставитьПлатеж( wlpmpaym, wlpmpropdeb, wlpmpropcred, wlpmrmprop, PRT_Credit, 0, wl_akkr ) )
         std.msg( "Ошибка при вставке платежа" );
         return FALSE;
       end;
    elif ( wlpmpropdeb.BankCode!="" )
       ПользовательскаяДоработкаПлатежа( wlmes, wlpmpaym, wlpmpropdeb, 0, wlpmrmprop );
          if( not ВставитьПлатеж( wlpmpaym, wlpmpropdeb, 0, wlpmrmprop, PRT_Credit, 0, wl_akkr ) )
         std.msg( "Ошибка при вставке платежа" );
         return FALSE;
       end;
    else
          std.msg( "Аккредитив не может быть дебетовым платежом" );
    end;  
  /*Иначе вставляем нормальный платеж*/
  else
    ПользовательскаяДоработкаПлатежа( wlmes, wlpmpaym, wlpmpropdeb, wlpmpropcred, wlpmrmprop );
    if( not ВставитьПлатеж( wlpmpaym, wlpmpropdeb, wlpmpropcred, wlpmrmprop, DebetCredit, IfThenElse(type==ED103, wlpmdemand, 0) ) )
      std.msg( "Ошибка при вставке платежа" );
      return FALSE;
    end;
  end;
  
  pist = NULL; // Возвращаем параметры в исходное состояние

  return TRUE;

  OnError(er) /* Обработка ошибок времени выполонения */
    std.msg(String(er.Message, "|Модуль: ", er.Module, " Строка: ", er.Line));
    return FALSE;
end;

macro GenDoc101( addrMes )
   return GenDoc( addrMes, ED101, 1 );
end;

macro GenDoc102( addrMes )
   return GenDoc( addrMes, ED102, 1 );
end;

macro GenDoc103( addrMes )
   return GenDoc( addrMes, ED103, 1 );
end;

macro GenDoc104( addrMes )
   return GenDoc( addrMes, ED104, 1 );
end;

macro GenDoc105( addrMes )
   return GenDoc( addrMes, ED105, 1 );
end;

macro GenDoc110( addrMes )
   return GenDoc( addrMes, ED110, 1 );
end;

macro GenDoc101V2( addrMes )
   return GenDoc( addrMes, ED101, 2 );
end;

macro GenDoc102V2( addrMes )
   return GenDoc( addrMes, ED102, 2 );
end;

macro GenDoc103V2( addrMes )
   return GenDoc( addrMes, ED103, 2 );
end;

macro GenDoc104V2( addrMes )
   return GenDoc( addrMes, ED104, 2 );
end;

macro GenDoc105V2( addrMes )
   return GenDoc( addrMes, ED105, 2 );
end;

macro GenDoc110V2( addrMes )
   return GenDoc( addrMes, ED110, 2 );
end;

macro GenDoc110v2016( addrMes )
   return GenDoc( addrMes, ED110, 2016 );
end;

macro GenDoc101V3( addrMes )
  return GenDoc( addrMes, ED101, 3 );
end;

macro GenDoc103V3( addrMes )
  return GenDoc( addrMes, ED103, 3 );
end;

macro GenDoc104V3( addrMes )
  return GenDoc( addrMes, ED104, 3 );
end;

macro GenDoc105V3( addrMes )
  return GenDoc( addrMes, ED105, 3 );
end;

