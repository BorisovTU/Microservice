 /*
 $Name: swiftin.mac
 $Module: Межбанковские расчеты
 $Description: Импорт сообщений
 */
/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/*                          Импорт  сообщений                               */
/*                                                                          */
/*  Имя файла: swiftin.mac                                                  */
/*  Создан:  03.03.00                                         Бабин А.П.    */
/****************************************************************************/

import "swtools.mac", "wlimport.mac";

/* Вид используемого терминала SWIFT */
var ВидТерминала:string;

 /* Общие глобализмы */
var ВсеПоляСчитаны = FALSE;    /* Устанавливается в TRUE если обработано поле MFIELDS */
var СтрокаСчитана  = FALSE;    /* флаг "из файла считана строка, но не обработана" */
var СчитаннаяСтрока = "";      /* считанная и необработанная строка */
ARRAY СтрокиПоля;              /* Массив строк многострочного поля */
var СтандартУстановлен = FALSE; /* Устанвливать в TRUE, если стандарт определен по 3 блоку */

const ДлинаСтроки = 75;
const МаксимальнаяДлинаСтроки = 1024;
const ДлинаСтрокиПоля = 70;

const Len_NumForm = 3,
      Len_Time = 4,
      Len_Date = 6;

array ИмяПеременнойБлока;
array ЗначениеПеременнойБлока;

var isNDC = FALSE;

macro IsFieldInRls( TpFieldID, RlsFormID )
  var select = "select *"+
                 "from dwlmesfld_dbt "+ 
                "where t_RlsFormID=:RlsFormID "+
                  "and t_TpFieldID=:TpFieldID ";
  var params = makeArray( SQLParam("RlsFormID", RlsFormID),
                          SQLParam("TpFieldID", TpFieldID));
  var rs = execSQLselect( select, params, FALSE );
  return rs.moveNext();
end;

private macro ParseSendDate( Date )
  var day   = "",
      month = "",
      year  = "";
  day = substr(Date, 5, 2);
  month = substr(Date, 3, 2);
  year = substr(Date, 1, 2);
  
  return day + month + year;
  
end;

macro УдалитьПеременныеБлока( )
   asize( ИмяПеременнойБлока, 0 );
   asize( ЗначениеПеременнойБлока, 0 );
   СтандартУстановлен = FALSE;
end;

macro ДобавитьПеременнуюБлока( Имя, Значение )
   var ind = asize( ИмяПеременнойБлока );
   ИмяПеременнойБлока(ind) = Имя;
   ЗначениеПеременнойБлока(ind) = Значение;
end;

macro НайтиПеременуюБлока( Имя, Значение )
   var i = 0, n = asize(ИмяПеременнойБлока), find;
   find = FALSE;
   while( i<n )
      if ( ИмяПеременнойБлока(i)==Имя )         
         Значение = ЗначениеПеременнойБлока(i);
         i = n;
         find = TRUE;
      end;
      i = i+1;
   end;
   if ( find==TRUE )
      SetParm( 1, Значение );
   else
      return 0; /* Переменная не найдена */
   end;
   return 1; 
end;

/***************************************************************************/
/*  Функция считывания заголовка файла со SWIFT сообщением                 */
/***************************************************************************/
macro СчитатьЗаголовок( Отправитель, Получатель, ДатаОтправки )
  if ( ВидТерминала == TPFRMT_TURBOSWIFT )
    if( not СчитатьБлок( strlen(FormatCode) ) )
       ErrImport( "Ошибка при чтении кода формата" );
       return FALSE;
    end;
  end;
  return TRUE;
end;

/***************************************************************************/
/* Функция считывания кода конца файла сообщения                           */
/***************************************************************************/
macro СчитатьКонцовку()
  return TRUE;
end;

/***************************************************************************/
/*             Считываем заголовок по формату TURBOSWIFT                   */
/***************************************************************************/
macro СчитатьAAIHeader(КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока)
    var header = "", длина, строка, DepName, QueueName, continue0 = true;
    if( ВидТерминала == TPFRMT_TURBOSWIFT )
        if ( (valtype(КодНачалаБлокаПрочитан)==V_BOOL) AND КодНачалаБлокаПрочитан==true )
           header = СчитанныйКодНачалаБлока;
        end;
        длина = 72 - strlen(header);
        header = header + СчитатьБлок( длина );
        if( (длина == КонецФайла) OR (strlen(header)<72) )
           ErrImport( "Неожиданный конец файла" );
           return false;
        end;
        SetParm( 0, false );
        /* На случай если рамер 210 */
        while(continue0)
          длина = 1;       
          строка = СчитатьБлок( длина );
          if( длина == КонецФайла )
             ErrImport( "Неожиданный конец файла" );
             return false;
          end;
          if( строка == КодНачалаБлока )
             SetParm( 0, TRUE );
             if ( valtype(СчитанныйКодНачалаБлока)!=V_UNDEF )
                SetParm( 1, строка );
             end;
             continue0 = false;
          else
             header = header + строка;
          end;
        end;
        /* Теперь разбираем заголовок */
        DepName   = substr( header, 29, 8 ); /* Department Name */
        QueueName = substr( header, 37, 8 ); /* Queue Name */
    end;
    return true;
end;

/***************************************************************************/
/* Функция считывает код начала сообщения                                  */
/***************************************************************************/
macro СчитатьКодНачалаСообщения(КодНачалаБлокаПрочитан)
 var строка, длина;

 if( ВидТерминала == TPFRMT_PCC )

    if( (valtype(КодНачалаБлокаПрочитан) == V_BOOL) AND
        (КодНачалаБлокаПрочитан == TRUE) )
       SetParm( 0, FALSE );
       return TRUE;
    end;
    длина = strlen( КодНачалаСообщения );
    строка = СчитатьБлок( длина );
    if( (длина == КонецФайла) OR (длина == 0) )
       ErrImport("Конец файла - Не найден код начала сообщения");
       return FALSE;
    end;
    if( строка != КодНачалаСообщения )
       ErrImport("Не найден код начала сообщения");
       return FALSE;
    end;
 end;

 return TRUE;
end;

macro СчитатьПеременнуюБлока( Номер, Значение )
  var строка, длина, continue0;
  длина = strlen(КодНачалаБлока);
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport("Конец файла - Не найдено начало Переменной Блока"); return -1; end;
  if( строка == КодКонцаБлока ) return 1; end; /* найден конец всего блока */
  /*printlog(1,string(CodeFor(строка)));*/
  if( строка != КодНачалаБлока ) ErrImport("Неверный символ - Не найдено начало Переменной Блока"); return -1; end; /* найдена левая туфта */
  длина = strlen(НомерПоляMUR);
  Номер = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport("Не найден Номер Переменной Блока"); return -1; end;
  длина = strlen(КодРазделительНомера);
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport("Не найден Код Разделитель Номера Переменной Блока"); return -1; end;
  continue0 = TRUE;
  Значение = "";
  длина = 1;
  while(continue0)
    строка = СчитатьБлок( длина );
    if( длина == КонецФайла ) ErrImport("Не найдено завершение Переменной Блока"); return -1; end;
    if(строка == КодКонцаБлока)
      continue0 = FALSE;
    else
      Значение = Значение + строка;
    end;
  end;
  SetParm(0,Номер);
  SetParm(1,Значение);
  return 0;
end;

macro СчитатьНачалоБлока( КодНачалаБлокаПрочитан )
  var строка, длина, НомерБлока;
  if((valtype(КодНачалаБлокаПрочитан)!=V_BOOL) OR (КодНачалаБлокаПрочитан == FALSE) )
    длина = strlen(КодНачалаБлока);
    строка = СчитатьБлок( длина );
    
    while(строка == "\n")
      длина = strlen(КодНачалаБлока);
      строка = СчитатьБлок( длина );
    end;

    if( (длина == КонецФайла) OR (длина == 0) )
      return КонецФайла;
    end;
    if(строка != КодНачалаБлока)
       ErrImport( "Не найден Код Начала Блока" );
       return "";
    end;
  end;
  длина = strlen(НомерБлокаBasicHeader);
  НомерБлока = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Не найден Номер блока" ); return ""; end;
  длина = strlen(КодРазделительНомера);
  строка = СчитатьБлок( длина );
  if( (длина == КонецФайла) OR (строка != КодРазделительНомера) ) ErrImport( "Не найден Код Разделитель Номера" ); return ""; end;
  return НомерБлока;
end;

macro СчитатьBasicHeaderBlock(КодНачалаБлокаПрочитан, Получатель, НомерПриложения)
  var строка, длина,;
  строка = СчитатьНачалоБлока(КодНачалаБлокаПрочитан);
  if((valtype(строка)==V_INTEGER) AND (строка == КонецФайла))
    return КонецФайла;
  end;
  if( строка == "" ) return FALSE; end;
  if( строка != НомерБлокаBasicHeader) ErrImport("Пропущен блок 1 - Basic Header"); return FALSE; end;
  длина = strlen(КодПриложенияFIN);
  строка = СчитатьБлок( длина );
  if( (длина == КонецФайла) OR (строка != КодПриложенияFIN) ) ErrImport( "Блок 1: Не найден Код Приложения FIN" ); return FALSE; end;
  длина = strlen(НомерПриложенияFIN);
  строка = СчитатьБлок( длина );
  if( (длина == КонецФайла) OR ((строка != НомерПриложенияFIN) AND (строка != НомерПриложенияFINСервис)) ) ErrImport( "Блок 1: Не найден Номер Приложения FIN" ); return FALSE; end;
  НомерПриложения = строка;
  длина = Len_BIC_Destination;
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 1: Не найден BIC Destination Получателя" ); return FALSE; end;
  Получатель = строка;
  длина = Len_BIC_LTCode;
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 1: Не найден Код Логического Терминала Получателя" ); return FALSE; end;
  длина = Len_BIC_BranchCode;
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 1: Не найден Код Отделения Получателя" ); return FALSE; end;
  if(строка==КодОтделенияПоУмолчанию) строка = ""; end;
  Получатель = Получатель + строка;
  длина = strlen(НомерСессииПоУмолчанию);
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 1: Не найден Номер Сессии Получателя" ); return FALSE; end;
  длина = strlen(ISNПоУмолчанию);
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 1: Не найден ISN Получателя" ); return FALSE; end;
  длина = strlen(КодКонцаБлока);
  строка = СчитатьБлок( длина );

  if( (длина == КонецФайла) OR ( строка != КодКонцаБлока ) ) ErrImport( "Блок 1: Не найден Код Конца Блока" ); return FALSE; end;
  КодНачалаБлокаПрочитан = FALSE;
  SetParm(0,КодНачалаБлокаПрочитан);
  SetParm(1,Получатель);
  SetParm(2,НомерПриложения);
  return TRUE;
end;

/* Начиная с версии SWIFTAlliance 4.1 исходящие из SWIFT сообщения (output messages) экспортируются 
   во внешние приложения как UAK - подтверждения пользователя, т.е. надо прочитать блоки 1 и 4, 
   а затем уже само сообщение */
macro СчитатьBasicHeaderBlockAck(КодНачалаБлокаПрочитан, Получатель, НомерПриложения, Block177, Block451, Block405, BlockMUR )
 var строка, длина, result, continue0, stat, НомерПеременной, ЗначениеПеременной;

 result = СчитатьBasicHeaderBlock(КодНачалаБлокаПрочитан, Получатель, НомерПриложения);
 if((valtype(result)==V_INTEGER) AND (result == КонецФайла)) return FALSE; end;
 if( not result ) return FALSE; end;
 if( НомерПриложения != НомерПриложенияFINСервис ) 
   SetParm(0,КодНачалаБлокаПрочитан);
   SetParm(1,Получатель); 
   SetParm(2,НомерПриложения); 
   return FALSE; 
 end;

 строка = СчитатьНачалоБлока(КодНачалаБлокаПрочитан);
 if((valtype(строка)==V_INTEGER) AND (строка == КонецФайла))
   return КонецФайла;
 end;
 if( строка == "" ) return FALSE; end;
 if( строка != НомерБлокаText) ErrImport("Пропущен блок 4 - Text"); return FALSE; end;

 continue0 = TRUE;
 while(continue0)
   stat = СчитатьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
   if(stat==0) /* считана переменная */
     if( НомерПеременной == НомерПоля177 ) /* Date and time, local to the user, at which the SP safe stored the acknowledged message (whether the acknowledgement is an ACK or a NAK). */
       Block177 = ЗначениеПеременной;
     elif( НомерПеременной == НомерПоля451 ) /* Accepted or rejected, where: 0 = accepted, 1 = rejected */
       Block451 = ЗначениеПеременной;
     elif( НомерПеременной == НомерПоля405 ) /* Reason for rejection. See the FIN Error Codes module for the full set of error codes. */
       Block405 = ЗначениеПеременной;
     elif( НомерПеременной == НомерПоляMUR ) /* MUR as used in the header of the original message. */
       BlockMUR = ЗначениеПеременной;
     end;
   elif(stat==1) /* найден конец всего блока */
     continue0 = FALSE;
   else
     return FALSE;
   end;
 end;

 КодНачалаБлокаПрочитан = FALSE;
 SetParm(0,КодНачалаБлокаПрочитан);
 SetParm(1,Получатель); 
 SetParm(2,НомерПриложения); 
 SetParm(3,Block177); 
 SetParm(4,Block451);
 SetParm(5,Block405);
 SetParm(6,BlockMUR);

 return TRUE;
end;

macro СчитатьApplicationHeaderBlockMOR(Отправитель, ДатаОтправки, НомерФормы, Приоритет, FlagACK)
  var строка, длина;
  строка = СчитатьНачалоБлока();
  if( строка == "" ) return FALSE; end;
  if( строка != НомерБлокаApplicationHeader) ErrImport("Пропущен блок 2 - Application Header"); return FALSE; end;
  длина = strlen(КодВходящего);
  строка = СчитатьБлок( длина );
  if( (длина == КонецФайла) OR ( (строка!=КодВходящего) AND (строка!=КодИсходящего) ) ) ErrImport( "Блок 2: Не найден Код Входящего Соообщения" ); return FALSE; end;
  if ( строка==КодИсходящего )
     FlagACK = true;
  else
     FlagACK = false;
  end;
  длина = Len_NumForm;
  НомерФормы = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден Номер Формы" ); return FALSE; end;
  if ( FlagACK==false )
     длина = Len_Time;
     строка = СчитатьБлок( длина );
     if( длина == КонецФайла ) ErrImport( "Блок 2: Не найдено Время Отправления" ); return FALSE; end;
     длина = Len_Date;
     ДатаОтправки = ParseSendDate( СчитатьБлок( длина ) );
     if( длина == КонецФайла ) ErrImport( "Блок 2: Не найдена Дата Отправления" ); return FALSE; end;
  else
     ДатаОтправки = date(0,0,0);
  end;
  длина = Len_BIC_Destination;
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден BIC Destination Отправителя" ); return FALSE; end;
  Отправитель = строка;
  длина = Len_BIC_LTCode;
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден Код Логического Терминала Отправителя" ); return FALSE; end;
  длина = Len_BIC_BranchCode;
  строка = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден Код Отделения Отправителя" ); return FALSE; end;
  //if(строка==КодОтделенияПоУмолчанию) строка = ""; end;
  Отправитель = Отправитель + строка;
  if ( FlagACK==false )
     длина = strlen(НомерСессииПоУмолчанию);
     строка = СчитатьБлок( длина );
     if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден Номер Сессии Отправителя" ); return FALSE; end;
  
     длина = strlen(ISNПоУмолчанию);
     строка = СчитатьБлок( длина );
     if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден ISN Отправителя" ); return FALSE; end;
     длина = Len_Date;
     строка = СчитатьБлок( длина );
     if( длина == КонецФайла ) ErrImport( "Блок 2: Не найдена Дата Получения" ); return FALSE; end;
     длина = Len_Time;
     строка = СчитатьБлок( длина );
     if( длина == КонецФайла ) ErrImport( "Блок 2: Не найдено Время Получения" ); return FALSE; end;
  end;
  длина = strlen(КодПриоритетНормальный);
  Приоритет = СчитатьБлок( длина );
  if( длина == КонецФайла ) ErrImport( "Блок 2: Не найден Код Приоритета" ); return FALSE; end;  
  длина = strlen(КодКонцаБлока);
  строка = СчитатьБлок( длина );
  if( (длина != КонецФайла) AND ( строка != КодКонцаБлока ) ) 
      /* Значит был delivery notification */
      длина = strlen(КодКонцаБлока);
      строка = СчитатьБлок( длина );

       // msgbox(длина,"===",КонецФайла,"==",КодКонцаБлока);

      if( (длина == КонецФайла) OR ( строка != КодКонцаБлока ) ) ErrImport( "Блок 2: Не найден Код Конца Блока !!" ); return FALSE; end;
  elif( длина == КонецФайла) 
      ErrImport( "Блок 2: Не найден Код Конца Блока !" ); 
      return FALSE;
  end;
  SetParm(0,Отправитель);
  SetParm(1,ДатаОтправки);
  SetParm(2,НомерФормы);
  SetParm(3,Приоритет);
  SetParm(4,FlagACK);
  return TRUE;
end;

macro СчитатьUserHeaderBlock(НомерБлока, НомерФормы)
  var строка, длина, continue0, stat, НомерПеременной, ЗначениеПеременной;
  НомерБлока = СчитатьНачалоБлока();
  if( НомерБлока == "" ) return FALSE; end;
  if( НомерБлока != НомерБлокаUserHeader)
    /* блок необязательный printlog(1,"Пропущен блок 3 - User Header");*/
    SetParm(0,НомерБлока); /* возвращаем номер чужого блока */
    return TRUE;
  else
    НомерБлока = "";
    SetParm(0,НомерБлока);
  end;
  continue0 = TRUE;
  while(continue0)
    stat = СчитатьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
    if(stat==0) /* считана переменная */
      std.out(3,"Считана переменная блока 3: "+НомерПеременной+" "+ЗначениеПеременной);
      if(НомерПеременной==НомерПоляMUR)
         ДобавитьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
      end;
      if( (НомерПеременной==НомерПоляStandart) )
         ДобавитьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
      end;
      if( (НомерПеременной==НомерПоляSTP) )
         if(Index(ЗначениеПеременной, "COV") != 0)
           НомерФормы = "202COV";
           setParm(1, НомерФормы);
         end;
         ДобавитьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
      end;
    elif(stat==1) /* найден конец всего блока */
      continue0 = FALSE;
    else
      return FALSE;
    end;
  end;
  return TRUE;
end;

/* Устанавливает контекст для поля */
macro УстановитьКонтекстДляПоляРелиза( РелизФормы, ИмяБлокаSt, ИмяБлокаEnd, TpFieldID, error )
   var res;
   res = RlsContext.SetContext( TpFieldID, ИмяБлокаSt, ИмяБлокаEnd, error );
   SetParm( 4, error );
   return res;
end;

macro ВстретиласьКопияСообщения(строка)
   /*   Таблица переходов */
   var Table = TArray;
   var state = 1, c, count=0, i, flagEasy=true;
             /*  1  2  3    4      5    */
             /*  {  }  :  DIGIT  OTHER  */
   Table( 1 ) = "20111";     /* до появления { */
   Table( 2 ) = "00030";     /* после первой { */
   Table( 3 ) = "00430";     /* после цифры */
   Table( 4 ) = "65044";     /* после : */
   Table( 5 ) = "20000";     /* после }, вышли на 0 уровень */
   Table( 6 ) = "67666";     /* после повторной { */
   Table( 7 ) = "65000";     /* после соответств. } */

   i=1; 
   while( i<=strlen(строка) )
       c = substr( строка, i, 1 );
       if ( c==КодНачалаБлока )
          if ( state==6 )
             count=count+1;
          end;
          state = int(substr(Table(state),1,1));
       elif ( c==КодКонцаБлока )          
          if ( (not count) or (state!=6) )
             state = int(substr(Table(state),2,1));
          end;
          if ( state==6 )
             count=count-1;
          end;
       elif ( c==КодРазделительНомера )
          state = int(substr(Table(state),3,1));
       elif ( (c>="0") and (c<="9") )
          state = int(substr(Table(state),4,1));
       else
          state = int(substr(Table(state),5,1));
       end;
       if ( state==0 )
          return false;
       elif ( state==5 )
          flagEasy = false;
       end;

       i=i+1;
   end;

   if ( flagEasy )
      return false;
   end;

   IsFullCopyMessage = true;

   return true;
end;

/***************************************************************************/
/*  Функция считывания поля SWIFT сообщением                               */
/*  Передаваемые параметры:                                                */
/*        ВидСообщения - вид сообщения в соответствии с SWIFT стандартом   */
/*  Возвращаемые значения:                                                 */
/*            КодПоля         - код поля в соответствии с SWIFT стандартом */
/*            ЧислоСтрок      - число считанных строк                      */
/*                                                                         */
/*  Возвращает:                                                            */
/*            0  - все ОК                                                  */
/*            1  - поле не найдено                                         */
/*            2  - неизвестный код поля                                    */
/*            3  - строка поля не считана                                  */
/*            4  - неверный формат поля                                    */
/*            5  - документ выписки                                        */
/*            6  - найден конец сообщения                                  */
/*            7  - прочитано последнее поле в сообщении                    */
/*            8  - Уже прочитано и обработано последнее поле               */
/*            9  - Пропустить поле (для НДЦ)                               */
/***************************************************************************/
macro СчитатьПолеИзФайла( РелизФормы, КодПоля, ЧислоСтрок, IsSaveDelive )
 var   continue0;      /* флаг "продолжать цикл */
 var   длина;         /* длина считанной строки */
 var   строка,        /* считанная строка */
       предстрока,    /* предыдущая считанная строка */
       строка1;
 var   позиция;       /* номер символа в строке */
 var   count;         /* счетчик числа считанных строк */
 var   EndOfMess = FALSE; /* найден конец сообщения */
 var   retval = 0, error, TpFieldID, cont2; 
 var   ИмяБлокаSt, ИмяБлокаEnd;
 var   IsIgnore;


 /* Находим первую строку поля */
 if ( ВсеПоляСчитаны == TRUE ) return 8; end;
 continue0 = 1;
 while( continue0 )
    if( СтрокаСчитана )
       строка = String( СчитаннаяСтрока );
       СтрокаСчитана = FALSE;
    else
       длина = strlen(КодКонцаТекстовогоБлока+КодКонцаБлока);
       строка1 = СчитатьБлок( длина );
       if( длина == КонецФайла ) return 3; end;
       if( строка1 == (КодКонцаТекстовогоБлока+КодКонцаБлока) )
         return 1;
       else
         длина = МаксимальнаяДлинаСтроки;
         строка = СчитатьСтроку( длина );
         if( длина == КонецФайла ) return 3; end;
         строка = строка1+строка;
       end;
    end;
    printlog(2,строка);
    if( SubString( строка, 1, 1 ) == КодНачалаПоля )   
        continue0 = 0;
    elif ( (not IsSaveDelive) and ВстретиласьКопияСообщения(строка) and (not ReadingCopyInitMes))
        continue0 = 0;
        ReadingCopyInitMes = true;
    else 
        return 4; /* Неверный формат поля */
    end;
 end;
 count = 1;
 
 IsIgnore = false;

 if ( (not ReadingCopyInitMes) and (not IsSaveDelive) )
    /* Получаем код поля (все между ':') */
    КодПоля = SubString( строка, 2, index(SubString( строка, 2 ), КодРазделительНомера)-1 );
    /* Возвращаем код поля */
    SetParm( 1, КодПоля );

    /* определяем максимальное число строк поля */
    ЧислоСтрок = ЧислоСтрокПоля( КодПоля, TpFieldID );
    
    if( ЧислоСтрок == 0 ) 
      if(isNDC) 
        retval = 9;
        IsIgnore = true;
      else
        return 2;
      end;
    end;

    if ( КодПоля==StartOfBlock )
       ИмяБлокаSt = SubString( строка, index(SubString(строка, 2), КодРазделительНомера)+2 );
    else
       ИмяБлокаSt = "";
    end;

    if ( КодПоля==EndOfBlock )
       ИмяБлокаEnd = SubString( строка, index(SubString(строка, 2), КодРазделительНомера)+2 );
    else
       ИмяБлокаEnd = "";
    end;

    
    if( (not IsIgnore) and (not IsFieldInRls( TpFieldID, РелизФормы )) and isNDC )
      IsIgnore = true;
      retval = 9;
    end;
    
    if ( (not IsIgnore) and (not УстановитьКонтекстДляПоляРелиза( РелизФормы, ИмяБлокаSt, ИмяБлокаEnd, TpFieldID, error )) )
       if( RlsContext.IsExistMFields )
          ReadingCopyInitMes = true;       
       else
          return 2;
       end;
    end;
 end;

 if ( ReadingCopyInitMes OR IsSaveDelive )
     ЧислоСтрок = ЧислоСтрокПоля( CopyMandatoryFields, TpFieldID );
     if( ЧислоСтрок == 0 ) return 2; end;
     if ( not УстановитьКонтекстДляПоляРелиза( РелизФормы, "", "", TpFieldID, error ) )
        return 2;
     end;
     КодПоля = CopyMandatoryFields;
     SetParm( 1, КодПоля );
     предстрока = строка;
     СтрокиПоля(0) = предстрока;     
 else
     /* Отбрасываем код начала поля */
     строка = SubString( строка, 2 );
     /* отбрасываем маркеры поля */
     позиция = Index( строка, КодРазделительНомера ) + 1;
     if( позиция <= 1 )   return 4; end;

     строка = SubStr( строка, позиция );
     предстрока = строка;
     СтрокиПоля(0) = предстрока;
 end;

 /* считываем последовательно оставшиеся строки поля */
 if( ЧислоСтрок > 1 )
    continue0 = 1;
    while( continue0 )
      длина = strlen( КодКонцаТекстовогоБлока );
      строка1 = СчитатьБлок( длина );      
      if( (длина > 0) and (строка1 == КодКонцаТекстовогоБлока) )
        длина = strlen( КодКонцаБлока );
        строка1 = строка1 + СчитатьБлок( длина );      
      end;

      if( длина == КонецФайла )
        EndOfMess = TRUE;
        continue0 = 0;
        retval = 3;
      elif( (строка1==КодКонцаТекстовогоБлока+КодКонцаБлока) AND (not IsFullCopyMessage) )
        continue0 = 0;
        retval = 7;
      else
        if ( строка1==КодКонцаТекстовогоБлока+КодКонцаБлока )
           IsFullCopyMessage = false;
        end;
        длина = МаксимальнаяДлинаСтроки;
        строка = СчитатьСтроку( длина );

        if( длина == КонецФайла )
          EndOfMess = TRUE;
          continue0 = 0;
          retval = 3;
        else
          строка1 = строка1+строка;
          cont2 = 1;
          while ( cont2 )
             if ( index(строка1,strfor(10)) )
                строка = substr( строка1, 1, index(строка1,strfor(10)) );
                строка1 = substr( строка1, index(строка1,strfor(10))+1 );
             elif ( index(строка1,"\n") )
                строка = substr( строка1, 1, index(строка1,"\n") );
                строка1 = substr( строка1, index(строка1,"\n")+1 );
             else
                строка = строка1;
                cont2 = 0;
             end;
             if( (строка==КодКонцаТекстовогоБлока+КодКонцаБлока) AND (not IsFullCopyMessage) )
                continue0 = 0;
                retval = 7;             
             else
               if ( строка==КодКонцаТекстовогоБлока+КодКонцаБлока )
                  IsFullCopyMessage = false;
               end;
               if( trim( строка ) == "" )
                 continue0 = 0;
               elif( (Substr(строка,1,1) == КодРазделительНомера) and (not ReadingCopyInitMes) and (not IsSaveDelive) )
                 /* найдено начало следующего поля */
                 СчитаннаяСтрока = строка;
                 СтрокаСчитана = TRUE;
                 continue0 = 0;
               elif ( (not IsSaveDelive) and ВстретиласьКопияСообщения(строка) and (not ReadingCopyInitMes) )
                 СчитаннаяСтрока = строка;
                 СтрокаСчитана = TRUE;
                 continue0 = 0;
               else
                 printlog(2,строка);
                 СтрокиПоля( count)  =  строка;
                 /* записываем предыдущую строку */
                 СтрокиПоля( count-1 ) = предстрока;
                 предстрока = строка;
                 count = count + 1;
                 if( (count >= ЧислоСтрок) and (not IsSaveDelive) )
                   continue0 = 0;
                 end;
               end;
             end;
           end;
         end;
       end;
    end; /* while */
 end; 

 if (IsSaveDelive)
    count = 0;
    if ( asize(СтрокиПоля)>0 )
       continue0 = 1;
    else
       continue0 = 0;
    end;
    while( continue0 )
       if ( substr(СтрокиПоля(count), 1, 4)==(КодНачалаПоля+TransactionReferenceNumberField+КодНачалаПоля) )
          wlmes.RelatedRef = substr( СтрокиПоля(count), 5 );
          wlmes.Trn = "ACK"+wlmes.RelatedRef;
          ОбновитьЗапись( wlmes );
       else
          if ( strlen(СтрокиПоля(count))>35 )
               СтрокиПоля(count) = substr(СтрокиПоля(count),1,32)+"...";
          end;          
       end;
       count=count+1;
       if ( count==asize(СтрокиПоля) )
           continue0 = 0;
       end;
    end;    
    if ( asize(СтрокиПоля)>55 )
        СтрокиПоля(54)="...";
        count = 55;
    end;
 end;

 SetParm( 2, count );

 return retval;

end;

/* Выбираем параметр обмена в соответствии со стандартом */
macro ВыбратьПараметрОбмена( RlsName, Стандарт )
   if( (Стандарт=="") OR (valtype(Стандарт)==V_UNDEF) )
     /* Теперь нет причин отказываться от этого параметра обмена */
      if( not index(RlsName,"RUR"))
        std.out(3, "     TRUE        " + RlsName );
        return TRUE;      
      else
        std.out(3, "     FALSE       " + RlsName );
        return FALSE;
      end;

/*     return TRUE;      */
   else
      std.out(3, "             " );
      if( substr(RlsName,strlen(RlsName)-strlen(Стандарт)+1,strlen(Стандарт))==Стандарт )
        std.out(3, "     TRUE        " + RlsName );
        return TRUE;
      else
        std.out(3, "     FALSE       " + RlsName );
        return FALSE;
      end;
   end;   
end;

/***************************************************************************/
/*  Функция записи многострочного поля в форматированную часть             */
/*  Строки записываем с символом перевода строки                           */
/*  Возвращает:                                                            */
/*            TRUE или FALSE                                               */
/***************************************************************************/
macro ЗаписатьМногострочноеПоле( кодПоля, числоСтрок )
 var СтрокаПоля = 0;
 var поле = "", Стандарт, РелизФормы;

 while( СтрокаПоля < числоСтрок )
    if(   СтрокаПоля == 0 ) поле = поле + String(       СтрокиПоля(0) );
    else                    поле = поле + String( "\n", СтрокиПоля(СтрокаПоля) );
    end;
 СтрокаПоля = СтрокаПоля + 1;
 end;

 if ( (кодПоля==TransactionReferenceNumberField) OR 
      ((кодПоля==SendersReferenceField) and (wlmes.TRN=="") and 
        (substr(поле,2,4)=="SEME")) )
    if ( кодПоля==TransactionReferenceNumberField )
       wlmes.TRN = поле;
    else
       wlmes.TRN = substr(поле, 8);
    end;

    if ( (СтандартУстановлен == FALSE) AND ((substr(wlmes.TRN, 1, 1)==RUR4_CHAR) OR (substr(wlmes.TRN, 1, 1)!=RUR5_CHAR)) )
       if ( substr(wlmes.TRN, 1, 1)==RUR4_CHAR )
          Стандарт = ЗначениеRUR4;
       else
          Стандарт = "";
       end;
       TpShem.TpShemID = wlmes.TpSchemID;
       if ( GetEQ(TpShem) )
          Релизы.RlsFormID = wlmes.RlsFormID;
          if ( GetEQ(Релизы) )
             wlmes.TpSchemID = ОпределитьТранспортнуюСхему( wlmes.OutsideAbonentID, -1, -1, TpShem.TpID, Релизы.FormID, РелизФормы, "ВыбратьПараметрОбмена", Стандарт, wlsess.TpFrmtID );
             if ( wlmes.TpSchemID == -1 ) return FALSE; end;
             wlmes.RlsFormID = РелизФормы;
          end;
       end;
    end;

    ОбновитьЗапись( wlmes );
 end;
 if ( кодПоля == RelatedReferenceField )
    wlmes.RelatedRef = поле;
    ОбновитьЗапись( wlmes );
 end;

 if ( (кодПоля==SenderToReceiverInformationField) AND 
      index(поле, string(SYMB_SLASH, Field72CodesEARLY, SYMB_SLASH)) )
    wlmes.Importance = 1;
    ОбновитьЗапись( wlmes );
 end;

 if( not ЗаписатьПоле( кодПоля, поле ) ) return FALSE; end;

 return TRUE;
end;

macro ОбработатьПоле( кодПоля, числоСтрок )
   if ( ЗаписатьМногострочноеПоле( кодПоля, числоСтрок ) )
      ЗаписаноПоле( кодПоля );
      return TRUE;
   else
      return FALSE;
   end;
end;

/* прочитать текстовый блок неизвестной формы */
/* 0 - OK  */
/* 1 - EOF */
macro ReadUnknownMsg( )
  var   длина;         /* длина считанной строки */
  var   строка,        /* считанная строка */
        строка1;  

  while( TRUE )
    длина = strlen(КодКонцаТекстовогоБлока+КодКонцаБлока);
    строка1 = СчитатьБлок( длина );
    if( длина == КонецФайла ) return 1; end;
    if( строка1 == КодКонцаТекстовогоБлока+КодКонцаБлока )
      return 0;
    else
      длина = ДлинаСтроки;
      строка = СчитатьСтроку( длина );
      if( длина == КонецФайла ) return 1; end;
      строка = строка1+строка;      
    end;    

    printlog(2,строка);
  end;
end;

macro СчитатьTextBlock( НомерБлока, SWIFTвидСообщения, Отправитель, ДатаОтправки, Получатель, Приоритет,
                        НомерПриложения, Block177, Block451, Block405, BlockMUR, FlagACK )
  var строка, длина, continue0, stat, НомерПеременной, ЗначениеПеременной ;
  var НомерФормы = 0, continue2, result;
  var кодПоля, числоСтрок, РелизФормы, TpShemID, error, ВидСообщения, Стандарт, STP;
  var TextACK = "UAK", RespID;
  var Валюта = "", Сумма = $0, IsSaveDelive=false;

  if((НомерБлока!="")  /* заголовок блока был прочитан ранее */
     AND (НомерБлока != НомерБлокаText))
    ErrImport("Пропущен блок 4 - Text");
    return -1;
  elif(НомерБлока == "")
    НомерБлока = СчитатьНачалоБлока();
    if( НомерБлока == "" ) return -1; end;
    if( НомерБлока != НомерБлокаText)
      ErrImport("Пропущен блок 4 - Text");
      SetParm(0,НомерБлока);
      return -1;
    else
      НомерБлока = "";
      SetParm(0,НомерБлока);
    end;
  end;

  длина = 70;
  строка = СчитатьСтроку( длина );
  if( длина == КонецФайла ) ErrImport("Не найдено завершение Блока 4"); return -1; end;
  if( строка != "" ) ErrImport( "После начала Блока 4 строка непустая"); return -1; end;

  /* VD 02.08.02 изменения под SWIFTAlliance 4.1
     Для ответных сообщений насильно проставляем НомерПриложенияFIN, чтобы считывать их из UAK,
     но UNK надо пропускать. Нигде не написано, что они не могут вывалиться к нам из терминала.
  */
  if((НомерПриложения == НомерПриложенияFINСервис) OR (Block451 == КодПоля451NAK) OR (FlagACK==true) )

    if ( FlagACK )
      if( Block451 == КодПоля451NAK)
        TextACK = "NAK";
      else
        TextACK = "ACK"
      end;
    else
      if( Block451 == КодПоля451NAK)
        TextACK = "UNK";
      else
        TextACK = "UAK"
      end;
    end;

    НомерФормы = -1;
    SetParm(1,НомерФормы);
    std.out(1,"Прочитан "+TextACK+" {"+НомерПоля177+":"+Block177+"}");
    if(valtype(Block405)==V_INTEGER) std.out(1,"{"+НомерПоля405+":"+Block405+"}"); end;
    if(valtype(BlockMUR)==V_INTEGER) std.out(1,"{"+НомерПоляMUR+":"+BlockMUR+"}"); end;
    if ( ДатаОтправки==date(0,0,0) )
       std.out(1,"на сообщение MT "+SWIFTвидСообщения+" от "+Отправитель );
    else
       std.out(1,"на сообщение MT "+SWIFTвидСообщения+" от "+Отправитель+" датой "+ДатаОтправки);
    end;

    if ( (not FlagACK) OR (Block451==КодПоля451NAK) )
       return ReadUnknownMsg();
    else
       IsSaveDelive = true;
    end;

  end;

  if ( not IsSaveDelive )
     std.out(1,"Прочитано сообщение MT "+SWIFTвидСообщения+" от "+Отправитель
               +/*" к "+Получатель+*/" датой "+ДатаОтправки);
  else
     SWIFTвидСообщения = "ACK";
     ВидСообщения = MESKIND_CNFDLVR;
     Стандарт = "";
  end;

  НомерФормы = ОпределитьФорму( Транспорт, SWIFTвидСообщения, ВидСообщения );
  if ( НомерФормы == -1 )
     SetParm( 1, НомерФормы );
     ErrImport( string("Не определен номер формы - ",SWIFTвидСообщения,", сообщение игнорируется") );
     return ReadUnknownMsg();
  end;

  if ( not IsSaveDelive )
     if ( not НайтиПеременуюБлока(НомерПоляStandart, Стандарт) )
       Стандарт = "";
     else
       if( (Стандарт==ЗначениеRUR5) OR (Стандарт==ЗначениеRUR6) )
         СтандартУстановлен = TRUE;
       end;
     end;

     if ( (НайтиПеременуюБлока(НомерПоляSTP, STP)) AND (STP == ЗначениеSTP) )
       Стандарт = НазваниеФормы103Plus_CHAR;
       СтандартУстановлен = TRUE;
     end;
  end;

  RespID = ПолучитьКодСубъекта( Отправитель, ВидКодаТранспорта, error );
  if ( error )
    error = 0;
    if((strlen(Отправитель) == (Len_BIC_Destination + Len_BIC_BranchCode)) and (substr(Отправитель, Len_BIC_Destination + 1, Len_BIC_BranchCode) == КодОтделенияПоУмолчанию ))
      RespID = ПолучитьКодСубъекта( substr(Отправитель, 1, Len_BIC_Destination), ВидКодаТранспорта, error );
      if(error)
       ErrImport( "Не найден код субъекта" );
       return -1;
      end;
    else
     ErrImport( "Не найден код субъекта" );
     return -1;
    end;
  end;

  TpShemID = ОпределитьТранспортнуюСхему( RespID, -1, -1, Транспорт, НомерФормы, РелизФормы, "ВыбратьПараметрОбмена", Стандарт, wlsess.TpFrmtID );
  if ( TpShemID == -1 ) return -1; end;

  ClearRecord( wlmes );
  wlmes.TpSchemID = TpShemID;
  wlmes.RlsFormID = РелизФормы;
  wlmes.OutsideAbonentID = RespID;
  wlmes.AgentID = wlmes.OutsideAbonentID;
  FillMesCode( TRANSP_SWIFT, wlmes );
  wlmes.Kind = ВидСообщения;
  wlmes.Importance = Приоритет;
  wlmes.Date = ДатаОтправки;
  if ( not СоздатьЗапись( wlmes ) )
     ErrImport( "Невозможно создать запись по форме MT "+SWIFTвидСообщения );
     return -1;
  end;
  ИнициализацияМассиваПолей(РелизФормы);

  /*printlog(1,"Последовательно читаем поля:");*/
  /* Последовательно читаем поля сообщения */
  СтрокаСчитана = FALSE;
  ВсеПоляСчитаны = FALSE;
  continue0 = 1;
  while( continue0 )
     stat = СчитатьПолеИзФайла( РелизФормы, кодПоля, числоСтрок, IsSaveDelive );
     if( stat == 1 )
        result = 0;
     elif( stat == 2 )
        ErrUnknownField( кодПоля );
        result = -1;
     elif( stat == 3 )
        ErrImport("Неожиданный конец файла");
        result = -1;
     elif( stat == 4 )
        ErrImport("Неверный формат поля");
        result = -1;
     elif( stat == 5 )
        result = 0;
     elif( stat == 6 )
        result = 1;
     elif( stat == 7 )
        result = 0;
     elif( stat == 8 )
        result = 0;
     elif( stat == 9 )
        result = 0;
     end;
     if( stat and ( stat != 9))
        continue0 = 0;
     end;
     if( (stat == 0) OR (stat == 7) )
        if( not ОбработатьПоле( кодПоля, числоСтрок ) )
           ErrImport("Не обработали поле: " + кодПоля);
           continue0 = 0;
           result = -1;
        end;
        // Для платежей заполняем в отчете сумму и валюту
        if( (ВидСообщения == MESKIND_PAYMENT) AND (кодПоля == ValueDateCurrencyCodeAmountField_A) )
          Валюта = SubStr(string(СтрокиПоля(0)),7,3);
          Сумма = SubStr(string(СтрокиПоля(0)),10);
          if( SubStr(Сумма,strlen(Сумма)) == ",")
            Сумма = moneyL(Сумма);
          else
            Сумма = moneyL(Сумма)/100;
          end;
        end;
     end;
     asize( СтрокиПоля, 0 );
  end;

  AddRepElem(wlmes.Kind, string( "MT " + SWIFTвидСообщения), Валюта, Сумма);
  return result;
end;

macro СчитатьTrailerBlock( НомерБлока )
  var строка, длина, continue0, stat, НомерПеременной, ЗначениеПеременной;
  НомерБлока = СчитатьНачалоБлока();
  if( НомерБлока == "" ) return FALSE; end;
  if( НомерБлока != НомерБлокаTrailer)
    /* блок необязательный */
    /*printlog(1,"Пропущен блок 5 - Trailer");*/
    SetParm(0,НомерБлока); /* возвращаем номер чужого блока */
    return TRUE;
  else
    НомерБлока = "";
    SetParm(0,НомерБлока);
  end;
  continue0 = TRUE;
  while(continue0)
    stat = СчитатьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
    if(stat==0) /* считана переменная */

    elif(stat==1) /* найден конец всего блока */
      continue0 = FALSE;
    else
      return FALSE;
    end;
  end;
  return TRUE;
end;

macro СчитатьTrailerBlockIFT( СчитанныйБлок )
 var строка, длина, continue0, stat, НомерПеременной, ЗначениеПеременной, НомерБлока;

 /* Теперь считаем, что этот блок может присутствовать и в других форматах */
 /*if( ВидТерминала == TPFRMT_PCC )*/
    длина = strlen( КодНачалаБлока );
    строка = СчитатьБлок( длина );
    if( (длина == КонецФайла) OR (длина == 0) )
       return TRUE;
    end;
    if( строка != КодНачалаБлока )
       SetParm( 0, Строка);
       return TRUE;
    end;
    длина = strlen( НомерБлокаTrailerIFT );
    НомерБлока = СчитатьБлок( длина );
    if( (длина == КонецФайла) OR (длина == 0) )
       ErrImport( "Не найден Номер блока" );
       return FALSE;
    end;
    if( НомерБлока != НомерБлокаTrailerIFT )
       ErrImport( "Неизвестный номер блока " + НомерБлока );
       return FALSE;
    end;
    длина = strlen(КодРазделительНомера);
    строка = СчитатьБлок( длина );
    if( (длина == КонецФайла) OR (строка != КодРазделительНомера) )
       ErrImport( "Не найден Код Разделитель Номера" );
       return FALSE;
    end;

    continue0 = TRUE;
    while(continue0)
      stat = СчитатьПеременнуюБлока( НомерПеременной, ЗначениеПеременной );
      if(stat==0) /* считана переменная */      
      elif(stat==1) /* найден конец всего блока */
        continue0 = FALSE;
      else
        return FALSE;
      end;
    end;
/* end;*/

 return TRUE;
end;

macro СчитатьКодКонцаСообщения( СчитанныйБлок )
 var строка, длина;

 if( ВидТерминала == TPFRMT_PCC )
    if( valtype(СчитанныйБлок) == V_STRING )
       строка = СчитанныйБлок;
    else
       длина = strlen( КодКонцаСообщения );
       строка = СчитатьБлок( длина );
       if( (длина == КонецФайла) OR (длина == 0) )
          ErrImport( "Конец файла - Не найден код конца сообщения" );
          return FALSE;
       end;
    end;
    if( строка != КодКонцаСообщения )
       ErrImport( "Не найден код конца сообщения" );
       return FALSE;
    end;
 end;

 return TRUE;
end;

/***************************************************************************/
/*  Функция считывания сообщения SWIFT                                     */
/*  Возвращает:                                                            */
/*             0 - все ОК                                                  */
/*             1 - сообщение не найдено                                    */
/*             2 - найден разделитель сообщений                            */
/*             3 - найден конец файла                                      */
/*            -1 - ошибка при обработке сообщения (ругается сама)          */
/***************************************************************************/
macro ОбработатьСообщение( КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока, Отправитель, Получатель, ДатаОтправки )
  /* Вспомогательные переменные */
  var НомерФормы, НомерБлока, Приоритет, result, СчитанныйБлок, Вид;
  var НомерПриложения, Block177, Block451, Block405, BlockMUR, FlagACK = false;

  УдалитьПеременныеБлока();
  if( not СчитатьAAIHeader(КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока) ) return -1; end;
  if( not СчитатьКодНачалаСообщения(КодНачалаБлокаПрочитан) ) return -1; end;
  
  if( (not СчитатьBasicHeaderBlockAck(КодНачалаБлокаПрочитан, Получатель, НомерПриложения, Block177, Block451, Block405, BlockMUR ))
      AND (НомерПриложения != НомерПриложенияFIN) ) return -1; end;
  
  /* второй раз читать Basic Header Block надо только для ACK/NAK, UAK/UNK */
  if(НомерПриложения == НомерПриложенияFINСервис)
     /*printlog(1,"СчитатьBasicHeaderBlock");*/
     result = СчитатьBasicHeaderBlock(КодНачалаБлокаПрочитан, Получатель, НомерПриложения);
     if((valtype(result)==V_INTEGER) AND (result == КонецФайла)) return 3; end;
     if( not result ) return -1; end;
  end;

  if( not СчитатьApplicationHeaderBlockMOR(Отправитель, ДатаОтправки, НомерФормы, Приоритет, FlagACK) ) return -1; end;
  if( not СчитатьUserHeaderBlock          (НомерБлока, НомерФормы) ) return -1; end;
  result = СчитатьTextBlock(НомерБлока, НомерФормы, Отправитель, ДатаОтправки, Получатель, Приоритет, НомерПриложения, Block177, Block451, Block405, BlockMUR, FlagACK);
  if( result == 0 )
     if( not СчитатьTrailerBlock(НомерБлока) ) return -1; end;
     if( not СчитатьTrailerBlockIFT(СчитанныйБлок) ) return -1; end;
     if( not СчитатьКодКонцаСообщения(СчитанныйБлок) ) return -1; end;
  end;
  if( НомерФормы == -1 ) return 0; end; /* пропускаем неизвестные формы */
  if( result == 1 )
    result = 2;
  elif( result ) return result; end;

  if ( wlmes.RlsFormID<=0 )
     ErrImport( "Не найдена форма сообщения" );
     return FALSE;
  end;
  if( not ПроверкаПолейСообщения( wlmes.RlsFormID, 0 ) ) return -1; end;

   SetParm(1,Отправитель);
   SetParm(2,Получатель);
   return result;
end;

macro СчитатьРазделительСообщений( КодНачалаБлокаПрочитан, Symbol )
 var строка, длина;
 if( ВидТерминала == TPFRMT_PCC )
    while( TRUE )
       длина = StrLen(КодНачалаСообщения);
       строка = СчитатьБлок( длина );       
       if( (длина == КонецФайла) OR (длина == 0) )
          return 1;
       end;
       if( строка == КодНачалаСообщения )
          SetParm( 0, TRUE );
          if ( valtype(Symbol)!=V_UNDEF )
             SetParm( 1, строка );
          end;
          return 0;
       end;
    end;
 elif ( ВидТерминала == TPFRMT_RJE )
    /* Экспорт TURBOSWIFT: разделитель сообщений - пустые строки */
    while(TRUE)
       длина = 1;       
       строка = СчитатьСтроку( длина );
       if( длина == КонецФайла )
          return 1;
       end;
       if( строка == КодНачалаБлока )
          SetParm( 0, TRUE );
          if ( valtype(Symbol)!=V_UNDEF )
             SetParm( 1, строка );
          end;
          return 0;
       end;
    end;
 else
    /* Импорт TURBOSWIFT: разделитель сообщений - пустые строки */
    while(TRUE)
       длина = 1;       
       строка = СчитатьСтроку( длина );
       if( длина == КонецФайла )
          return 1;
       end;
       if( ((строка>="0") AND (строка<="9")) OR ((строка>="A") AND (строка<="F")) OR ((строка>="a") AND (строка<="f")) )
          SetParm( 0, TRUE );
          if ( valtype(Symbol)!=V_UNDEF )
             SetParm( 1, строка );
          end;
          return 0;
       end;
    end;
 end;
end;

/* Процедура импорта сообщений */
macro SWIFTInProc( TpID, importFileName, addrSess )
   var КодНачалаБлокаПрочитан, Отправитель, Получатель, ДатаОтправки, stat;
   var continue0, Документов = 0;
   var СчитанныйКодНачалаБлока = "";

   SetBuff( wlsess, addrSess );
   
   isNDC = false;
   Транспорт = TpID;
   ВидКодаТранспорта = PTCK_SWIFT;

   if( ((ОпределитьФорматТранспорта( TpID, ВидТерминала )) == 0) OR (ВидТерминала == "" ) )
     ErrImport( string("Не найден формат по умолчанию для траснпорта № ", TpID) );
     return false;
   end;

   ПерейтиВНачалоФайла();

   /* Считываем заголовок файла */
   if( not СчитатьЗаголовок( Отправитель, Получатель, ДатаОтправки ) )
     return FALSE;
   end;

   continue0 = TRUE;
   while( continue0 )
      stat = ОбработатьСообщение( КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока, Отправитель, Получатель, ДатаОтправки );
      if( stat == 1 )
        continue0 = FALSE;
      elif( stat == 3 ) /* найден конец файла */
        continue0 = FALSE;
      elif( stat == -1 )
        return FALSE;
      elif( stat == 0 )
        stat = СчитатьРазделительСообщений(КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока);
        if( stat == 1 )
          continue0 = FALSE;
        elif( stat == -1 )
          return FALSE;
        end;
      end;
      Документов = Документов + 1;
      message("Идет прием сообщений. Обработано: ", Документов );
   end;

   /* Считываем код конца файла */
   if( not СчитатьКонцовку() )
      return FALSE;
   end;

   // PrintImportReport();
   return true;
end;

macro SwNDCInProc(TpID, importFileName, addrSess)
   var КодНачалаБлокаПрочитан, Отправитель, Получатель, ДатаОтправки, stat;
   var continue0, Документов = 0;
   var СчитанныйКодНачалаБлока = "";

   SetBuff( wlsess, addrSess );
 
   isNDC = true;
   
   Транспорт = TpID;
   ВидКодаТранспорта = PTCK_SWIFT;

   ВидТерминала = TPFRMT_RJE;

   ПерейтиВНачалоФайла();

   /* Считываем заголовок файла */
   if( not СчитатьЗаголовок( Отправитель, Получатель, ДатаОтправки ) )
     return FALSE;
   end;

   continue0 = TRUE;
   while( continue0 )
      stat = ОбработатьСообщение( КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока, Отправитель, Получатель, ДатаОтправки );
      if( stat == 1 )
        continue0 = FALSE;
      elif( stat == 3 ) /* найден конец файла */
        continue0 = FALSE;
      elif( stat == -1 )
        return FALSE;
      elif( stat == 0 )
        stat = СчитатьРазделительСообщений(КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока);
        if( stat == 1 )
          continue0 = FALSE;
        elif( stat == -1 )
          return FALSE;
        end;
      end;
      Документов = Документов + 1;
      message("Идет прием сообщений. Обработано: ", Документов );
   end;

   /* Считываем код конца файла */
   if( not СчитатьКонцовку() )
      return FALSE;
   end;

   PrintImportReport();
   return true;
end;