/****************************************************************************/
/*                   R-Style Software Lab, RS-Bank v6                       */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/*                      Импорт сообщений SWIFT-SB                           */
/*                                                                          */
/*  Имя файла: swsbout.mac                                                  */
/*  Создан:  12.03.04                                         Панов А.Б.    */
/****************************************************************************/
import "swiftin.mac", "swsbtls.mac", "swparser.mac", cryptdlm;

const CONTEXTID_INSERT_SIGN_SWSB = "ТранспортМБР|8|Макрос";

var КодПодтипСообщения;  /* Подтип сообщения (S, N, I) */
var ВидСообщения;
var этоКвитанцияОдоставке = false ;

/* Частичное решение проблемы загрузки нескольких сообщений 
   за исключением проблем подписывания Бикриптом: */
/* класс чтения блоков из текстового файла с 
   возможностью временного хранения прочтенной информации */
class Блок
  
  private var str:string;
  private var otkat:integer;
  private var maxlen:integer;
  /*Статистика для maxlen*/
  private var statlen:integer;
  
  macro Считать(len: integer):string
    var otkat2:integer = otkat; 

    /*Складываем прочтенное с сохраненным*/
    if(otkat < len)
       str = str + СчитатьБлок(int(len - otkat));
    end;
    /*стараемся работать с небольшими строками*/
    if(StrLen(str) > maxlen)
       str = SubStr(str, StrLen(str) - maxlen + 1/* * */);
    end;
    /*при если отлаживаюся ошибки класса*/
    /*if(statlen<StrLen(str)) statlen = StrLen(str); end;*/
    
    /*Думаем чего возращать*/
    if(otkat < len)
       /*искомые len символов - в конце строки*/
       otkat = 0;
       return SubStr(str, Strlen(str) - len   + 1/* * */ );
    else   
       /*искомые len символов начинаются на расстоянии otkat от конца строки
         - поступлений же новых символов не было*/
       otkat = otkat - len;
       return SubStr(str, StrLen(str) - otkat2/* ** */ + 1/* * */, len );
    end;
    /* где: 
       * =  потому, что с единицы считается позиция в строках 
       ** = необходима, чтобы вернуть правильные значения */

  end;

  /*Чтобы голова не болела от соместного использования класса и функций СчитатьБлок и СчитатьСтроку*/
  macro Обнулить():string
    if(otkat)
       /*Ругаемся на весьма вероятную ошибку - обнуление класса при незавершенном откате*/
       std.out( 1, string( "Ошибка использования класса Блок:" +
                           "Обнуление при незавершенном откате" ) );
       return false;
    else
       str = "";
       otkat = 0;
    end;
  end;
  
  macro Откатить(len: integer):bool 
    /*Проверяем на ограничения*/
    if(len > maxlen)
       /*невозможно использование класса без увеличения maxlen; превышен допустимый размер отката*/
       std.out( 1, string( "Ошибка использования класса Блок:" +
                           "невозможно использование класса без увеличения maxlen" ) );
       return false;
    elif( len > StrLen(str))
       /*Ругаемся на неточность программиста, в большинстве случаев - это ошибка*/
       std.out( 1, string( "Ошибка использования класса Блок:" +
                           "так далеко откатывать еще нельзя" ) );
       return false;
    elif(otkat)
       /*Ругаемся на повторный откат, т.к. это скорее всего признак ошибки и вообще*/
       /*алгоритмически нехорошая ситуация.*/
       std.out( 1, string( "Ошибка использования класса Блок:" +
                           "откат во время отката - запрещен" ) );
       return false;
    end;
    /*откатываем на len символов*/
    otkat = len;
    return true;
  end;

  str = "";
  otkat = 0;
  /*Чтобы класс не работал со слишком большими строками*/
  maxlen = 64;
  statlen = 0;

end; /* Блок */

/*Создаем единственный объект типа "Блок"*/
var BlockSWSB: Блок;

/* Выбираем параметр обмена в соответствии с подтипом сообщения (S, N, I) */
macro ВыбратьПараметрОбменаSB(RlsName, КодПодтипСообщения)

  if( (valtype(КодПодтипСообщения)==V_UNDEF) OR (КодПодтипСообщения=="") OR (КодПодтипСообщения=="I") )
    КодПодтипСообщения = "";    
  end;

  std.out(3, "             ");
  if (substr(RlsName, 4, 1) == КодПодтипСообщения)
    std.out(3, "     true        " + RlsName);
    return true;
  else
    std.out(3, "     false       " + RlsName);
    return false;
  end;
end;

macro СчитатьНачалоБлокаSB(КодНачалаБлокаПрочитан, str, NameLen)
  var строка, длина, НомерБлока;

  if (ValType(NameLen) == V_UNDEF)
    NameLen = 1;
  end;

  str = "";
  
  if ((valtype(КодНачалаБлокаПрочитан) != V_BOOL) OR (КодНачалаБлокаПрочитан == false))
    длина = strlen(КодНачалаБлока);
    строка = BlockSWSB.Считать(длина);
    if ((длина == КонецФайла) OR (длина == 0))
      return КонецФайла;
    end;
    if (строка != КодНачалаБлока)
      ErrImport("Не найден Код Начала Блока");
      return "";
    end;
    str = str + строка;
  end;

  длина = NameLen;
  НомерБлока = BlockSWSB.Считать(длина);
  if (длина == КонецФайла)
    ErrImport("Не найден Номер блока"); 
    return ""; 
  end;
  str = str + НомерБлока;
  
  длина = strlen(КодРазделительНомера);
  строка = BlockSWSB.Считать(длина);
  if ((длина == КонецФайла) OR (строка != КодРазделительНомера)) 
    ErrImport("Не найден Код Разделитель Номера"); 
    return ""; 
  end;
  str = str + строка;
  
  SetParm(1, str);
  return НомерБлока;
end;

macro СчитатьБлокСлужебнойИнформацииСМФР(КодНачалаБлокаПрочитан, КодНазначениеСообщения,
                                         Отправитель, Получатель, 
                                         АбонентОтправитель, АбонентПолучатель, 
                                         ДатаОтправки, ВремяОтправки, Ключ, ДлинаКлюча, ДатаКлюча)
  var строка, длина, ДатаКлючевания, str;

  /*КодНачалаБлокаПрочитан - изначально неопределен*/
  if( (valtype(КодНачалаБлокаПрочитан) == V_BOOL) AND (КодНачалаБлокаПрочитан == true) )
     длина = 11;
  else
     длина = 12;
  end;

  /*Отделяем бизнес-сообщения от квитанций*/
  строка = BlockSWSB.Считать(длина);
  if( substr(строка,длина,1) == КодКонцаБлока )
     этоКвитанцияОдоставке = true;
  else
     этоКвитанцияОдоставке = false;
  end; 
  if(not BlockSWSB.Откатить(длина)) return false; end;

  строка = СчитатьНачалоБлокаSB(КодНачалаБлокаПрочитан, str, strlen(НомерБлокаСлужебнойИнформацииСМФР));
  if ((valtype(строка) == V_INTEGER) AND (строка == КонецФайла))
     return КонецФайла;
  end;

  if (строка == "") return false; end;
  if (строка != НомерБлокаСлужебнойИнформацииСМФР) 
     ErrImport("Пропущен блок SB - Служебная информация СМФР"); 
     return false; 
  end;

  длина = strlen(КодВерсииФормата);
  строка = BlockSWSB.Считать(длина);
  if ((длина == КонецФайла) OR (строка != КодВерсииФормата)) 
     ErrImport("Блок SB: Не найден Код Версии Формата");
     return false; 
  end;

  if(not этоКвитанцияОдоставке) 
     длина = ДлинаКодПодтипСообщения;
     строка = BlockSWSB.Считать(длина);
     if ((длина == КонецФайла) OR 
        ((строка != КодПодтипСообщения_СМФР) AND
        (строка != КодПодтипСообщения_КорСчет) AND
        (строка != КодПодтипСообщения_Общий))) 
        
        ErrImport("Блок SB: Не найден Код Подтипа Сообщения"); 
        return false; 
     end;
     КодПодтипСообщения = строка;

     длина = ДлинаКодНазначениеСообщения;
     строка = BlockSWSB.Считать(длина);
     if ((длина == КонецФайла) OR
        ((строка != КодНазначениеСообщения_Общий) AND
        (строка != КодНазначениеСообщения_МТ910_Платеж) AND
        (строка != КодНазначениеСообщения_МТ910_Подтверждение)))
        
        ErrImport("Блок SB: Не найден Код Назначения Сообщения"); 
        return false; 
     end;
     
     КодНазначениеСообщения = строка;

     длина = ДлинаКодСМФР;
     строка = BlockSWSB.Считать(длина);
   
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найден Код СМФР Отправителя"); 
        return false; 
     end;
     Отправитель = строка;

     длина = ДлинаКодСМФР;
     строка = BlockSWSB.Считать(длина);
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найден Код СМФР Получателя"); 
        return false; 
     end;
     Получатель = строка;

     длина = Len_Date;
     строка = BlockSWSB.Считать(длина);
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найдена Дата Отправки Сообщения"); 
        return false; 
     end;
     ДатаОтправки = строка;
     
     длина = Len_Time;
     строка = BlockSWSB.Считать(длина);
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найдено Время Отправки Сообщения"); 
        return false; 
     end;
     ВремяОтправки = строка;
     end;

     длина = ДлинаКодАбонента;
     строка = BlockSWSB.Считать(длина);
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найден Код Абонента-Отправителя"); 
        return false; 
     end;
     АбонентОтправитель = строка;

     длина = ДлинаКодАбонента;
     строка = BlockSWSB.Считать(длина);
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найден Код Абонента-Получателя"); 
        return false; 
     end;
     АбонентПолучатель = строка;

     if(not этоКвитанцияОдоставке) 
     длина = Len_Date;
     строка = BlockSWSB.Считать(длина);
     if (длина == КонецФайла) 
        ErrImport("Блок SB: Не найдена Дата Ключевания Сообщения"); 
        return false; 
     end;
     ДатаКлючевания = строка;
  else
     КодПодтипСообщения = "";
  end;

  длина = strlen(КодКонцаБлока);
  строка = BlockSWSB.Считать(длина);
  if (длина == КонецФайла)
     ErrImport("Блок SB: Не найден Код Конца Блока"); 
     return false; 
  end;
  if (строка != КодКонцаБлока)
     ДлинаКлюча = 0;
     Ключ = "";
     while(строка != КодКонцаБлока)
        Ключ = Ключ + строка;
        ДлинаКлюча = ДлинаКлюча + 1;
        длина = 1;
        строка = BlockSWSB.Считать(длина);
        if (длина == КонецФайла)
           ErrImport("Блок SB: Не найден Код Конца Блока"); 
           return false; 
        end;
     end;
  end;

  /*Ограничиваем использование класса Блок из-за функции СчитатьСтроку()*/
  BlockSWSB.Обнулить();
  
  КодНачалаБлокаПрочитан = false;

  SetParm(0, КодНачалаБлокаПрочитан);
  SetParm(1, КодНазначениеСообщения);
  SetParm(2, Отправитель);
  SetParm(3, Получатель);
  SetParm(4, АбонентОтправитель);
  SetParm(5, АбонентПолучатель);
  SetParm(6, ДатаОтправки);
  SetParm(7, ВремяОтправки);
  SetParm(8, Ключ);
  SetParm(9, ДлинаКлюча);
  SetParm(10, ДатаКлючевания);
  
  return true;
end;

var ДополнительныйТекстовыйБлокБуфер = TArray;

macro ОчиститьДополнительныйТекстовыйБлокБуфер()
  ДополнительныйТекстовыйБлокБуфер.Size = 0;
end;

macro СчитатьДополнительныйТекстовыйБлокБуфер(КодНачалаБлокаПрочитан)
  var str, str2, len, i = 0, НомерБлока;

  НомерБлока = СчитатьНачалоБлокаSB(КодНачалаБлокаПрочитан, str, strlen(НомерДополнительногоТекстовогоБлока));
  /*Потому, что СчитатьНачалоБлокаSB использует класс Блок*/
  BlockSWSB.Обнулить();
  if (НомерБлока != НомерДополнительногоТекстовогоБлока)
    ErrImport("Пропущен блок 4+ - Дополнительный Текстовый Блок");
    return -1;
  end;
  ДополнительныйТекстовыйБлокБуфер(i) = str; i = i + 1;

  if(этоКвитанцияОдоставке) 
     str2 = СчитатьБлок(1);  str = "";
     while ( (str2 != КодКонцаБлока) AND (str2 != "" ) ) 
        str = str + str2;
        str2 = СчитатьБлок(1);
     end;
     if( str2 == КодКонцаБлока )
        ДополнительныйТекстовыйБлокБуфер(i) = str;
        str = СчитатьБлок(1);
        if (str == КодНачалаБлока)
           SetParm(0, true);
           return 0;
        else
           ErrImport("Не найдено начало блока базового заголовка"); 
           return -1;
        end;
     end;
  end;

  len = 70;
  str = СчитатьСтроку(len);
  if (len == КонецФайла) ErrImport("Не найдено завершение Блока 4+"); return -1; end;
  if (str != "") ErrImport("После начала Блока 4+ строка непустая"); return -1; end;
  len = 70;
  str = СчитатьБлок(2);
  while((str != "") AND (substr(str, 1, 1) != КодКонцаТекстовогоБлока) AND (len != КонецФайла))
    len = 70;
    str = str + СчитатьСтроку(len);
    ДополнительныйТекстовыйБлокБуфер(i) = str; i = i + 1;
    str = СчитатьБлок(2);
  end;  
  if ((len == КонецФайла) OR 
      (str == "") OR 
      (substr(str, 1, 2) != string(КодКонцаТекстовогоБлока,КодКонцаБлока)))
    ErrImport("Не найдено завершение Блока 4+"); 
    return -1; 
  end;
  ДополнительныйТекстовыйБлокБуфер(i) = str;
  str = СчитатьБлок(1);
  if (str == КодНачалаБлока)
     SetParm(0, true);
  elif(str == "\n")
     ;
  else
     len = 70;
     str = СчитатьСтроку(len);
  end;
  return 0;
end;

/***************************************************************************/
/*  Функция записи многострочного поля в форматированную часть             */
/*  Строки записываем с символом перевода строки                           */
/*  Возвращает: true или false                                             */
/***************************************************************************/
macro ЗаписатьМногострочноеПолеSB( кодПоля, числоСтрок )
 var СтрокаПоля = 0;
 var поле = "", Стандарт, РелизФормы;

 while(СтрокаПоля < числоСтрок)
    if (СтрокаПоля == 0) 
      поле = поле + String(СтрокиПоля(0));
    else
      поле = поле + String("\n", СтрокиПоля(СтрокаПоля));
    end;
 СтрокаПоля = СтрокаПоля + 1;
 end;

 if (кодПоля == УникальныйНомерСообщенияСМФР)
   wlmes.TRN = поле;
   ОбновитьЗапись(wlmes);
 end;
 if (кодПоля == НомерСвязанногоСообщенияСМФР)
   wlmes.RelatedRef = поле;
   ОбновитьЗапись(wlmes);
 end;
 if ( (кодПоля==SenderToReceiverInformationField) AND 
      (not index(поле, string(SYMB_SLASH, Field72CodesEARLY, SYMB_SLASH))) AND wlmes.Importance )
    wlmes.Importance = 0;
    ОбновитьЗапись( wlmes );
 end;
 поле = ToOEM(поле, true);
 if (not ЗаписатьПоле(кодПоля, поле)) return false; end;

 return true;
end;

macro ОбработатьПолеSB( кодПоля, числоСтрок )
   if ( ЗаписатьМногострочноеПолеSB( кодПоля, числоСтрок ) )
      ЗаписаноПоле( кодПоля );
      return true;
   else
      return false;
   end;
end;

/* Функция аналогична СчитатьПолеИзФайла(РелизФормы, кодПоля, числоСтрок), */
/* но используется при чтении ОДНОСТРОЧНОГО поля из буфера, а не из файла. */
/* В настоящий момент зачитываются поля блока 4+                           */
/***************************************************************************/
/*  Передаваемые параметры:                                                */
/*   РелизФормы - вид сообщения (релиз) SWIFT-SB                           */
/*       строка - строка из буфера                                         */
/*  Возвращаемые значения:                                                 */
/*      КодПоля - код поля SWIFT-SB                                        */
/*                                                                         */
/*  Возвращает:                                                            */
/*            0  - все ОК                                                  */
/*            2  - неизвестный код поля                                    */
/*            4  - неверный формат поля                                    */
/***************************************************************************/
macro СчитатьПолеИзБуфера(РелизФормы, КодПоля, строка)
  var позиция, error, TpFieldID, ЧислоСтрок; 
  
  /* Получаем код поля (все между ':') */
  КодПоля = SubString(строка, 2, index(SubString(строка, 2), КодРазделительНомера)-1);
  /* Возвращаем код поля */
  SetParm(1, КодПоля);

  /* определяем ID поля, а заодно и максимальное число строк поля */
  ЧислоСтрок = ЧислоСтрокПоля(КодПоля, TpFieldID); 
  if (ЧислоСтрок == 0) return 2; end;

  /* проверяем наличие поля релиза в текущем контексте */ 
  if( not RlsContext.SetContext( TpFieldID, "", "", error ) ) return 2; end;

  /* Отбрасываем код начала поля */
  строка = SubString(строка, 2);
  /* отбрасываем маркеры поля */
  позиция = index(строка, КодРазделительНомера) + 1;
  if (позиция <= 1)  return 4; end;
  СтрокиПоля(0) = SubStr(строка, позиция);

  return 0;
end;

macro СчитатьДополнительныйТекстовыйБлок(SWIFTвидСообщения, РелизФормы, Отправитель, ДатаОтправки, Приоритет)
  var строка, continue0, stat;
  var НомерФормы = 0, result;
  var кодПоля, TpShemID, error;
  var RespID;
  var i, РазмерДополнительныйТекстовыйБлокБуфер;

  if (КодПодтипСообщения == КодПодтипСообщения_Общий) КодПодтипСообщения = ""; end;

  std.out(1,"Прочитано сообщение MT "+SWIFTвидСообщения+КодПодтипСообщения+" от "+Отправитель +" датой "+ДатаОтправки);

  НомерФормы = ОпределитьФорму(Транспорт, SWIFTвидСообщения, ВидСообщения);
  if (НомерФормы == -1)
    SetParm(0, НомерФормы);
    ErrImport(string("Не определен номер формы - ",SWIFTвидСообщения+КодПодтипСообщения,
              ", сообщение игнорируется"));
    return ReadUnknownMsg();
  end;

  СтандартУстановлен = false;

  /*Более удобного места определить ВидКодаТранспорта не нашел. GVR*/
  ВидКодаТранспорта = PTCK_SMFR;
  RespID = ПолучитьКодСубъекта(Отправитель, ВидКодаТранспорта, error);
  std.out(1, Отправитель);
  if (error)
    ErrImport("Не найден код субъекта. Подробности:");
    ErrImport(string("Отправитель: ", Отправитель, ", Вид кода транспорта: ", ВидКодаТранспорта, ", Ошибка:", error));
    return -1;
  end;

  TpShemID = ОпределитьТранспортнуюСхему(RespID, -1, -1, Транспорт, НомерФормы, РелизФормы, "ВыбратьПараметрОбменаSB", КодПодтипСообщения, wlsess.TpFrmtID);
  if (TpShemID == -1) return -1; end;

  ClearRecord(wlmes);
  wlmes.TpSchemID = TpShemID;
  wlmes.RlsFormID = РелизФормы;
  wlmes.OutsideAbonentID = RespID;
  wlmes.AgentID = wlmes.OutsideAbonentID;
  FillMesCode(TRANSP_SWIFTSB, wlmes);
  wlmes.Kind = ВидСообщения;
  if ( Приоритет==КодПриоритетСрочный )
     wlmes.Importance = 1;
  end;
  if (not СоздатьЗапись(wlmes))
    ErrImport("Невозможно создать запись по форме MT "+SWIFTвидСообщения);
    return -1;
  end;
  
  ИнициализацияМассиваПолей(РелизФормы);

  /* Последовательно читаем поля из буфера Дополнительного Текстового Блока */
  РазмерДополнительныйТекстовыйБлокБуфер = ДополнительныйТекстовыйБлокБуфер.Size;
  i = 1;
  continue0 = 1;
  while((i < РазмерДополнительныйТекстовыйБлокБуфер-1) and continue0)
     строка = ДополнительныйТекстовыйБлокБуфер(i);
     stat = СчитатьПолеИзБуфера(РелизФормы, кодПоля, строка);

     if (stat == 2)
       //ErrUnknownField(кодПоля);
       //result = -1;
       result = 0;
     elif (stat == 4)
       ErrImport("Неверный формат поля");
       result = -1;
     end;

     if (stat)
       continue0 = 0;
     end;

     if (stat == 0)
       if (not ОбработатьПолеSB(кодПоля, 1))
         ErrImport("Не обработали поле: " + кодПоля);
         continue0 = 0;
         result = -1;
       end;
     end;
     asize(СтрокиПоля, 0);
     i = i + 1;
  end;

  SetParm(1, РелизФормы);
  return result;
end;

macro СчитатьДополнительныйТекстовыйБлокКвитанции(SWIFTвидСообщения, РелизФормы, АбонентОтправитель, ДатаОтправки, Приоритет)
  var строка, continue0, stat;
  var НомерФормы = 0, result;
  var TpShemID, error;
  var RespID;
  var i, РазмерДополнительныйТекстовыйБлокБуфер;

  std.out(1,"Прочитана квитация "+ SWIFTвидСообщения+" от " +АбонентОтправитель +" датой ");

  НомерФормы = ОпределитьФорму(Транспорт, SWIFTвидСообщения, ВидСообщения);
  if (НомерФормы == -1)
    SetParm(0, НомерФормы);
    ErrImport(string("Не определен номер формы - ",SWIFTвидСообщения+КодПодтипСообщения,
              ", сообщение игнорируется"));
    return ReadUnknownMsg();
  end;

  СтандартУстановлен = false;

  /*Более удобного места переопределить ВидКодаТранспорта не нашел. GVR*/
  ВидКодаТранспорта = PTCK_SBRF;
  RespID = ПолучитьКодСубъекта(АбонентОтправитель, ВидКодаТранспорта, error);
  std.out(1, АбонентОтправитель);
  if (error)
     ErrImport("Не найден код субъекта. Подробности:");
     ErrImport(string("Отправитель: ", АбонентОтправитель, ", Вид кода транспорта: ", ВидКодаТранспорта, ", Ошибка:", error));
     return -1;
  end;

  TpShemID = ОпределитьТранспортнуюСхему(RespID, -1, -1, Транспорт, НомерФормы, РелизФормы, "ВыбратьПараметрОбменаSB", КодПодтипСообщения);
  if (TpShemID == -1) return -1; end;

  ClearRecord(wlmes);
  wlmes.TpSchemID = TpShemID;
  wlmes.RlsFormID = РелизФормы;
  wlmes.OutsideAbonentID = RespID;
  wlmes.AgentID = wlmes.OutsideAbonentID;
  FillMesCode(TRANSP_SWIFTSB, wlmes);
  wlmes.Kind = ВидСообщения;
  if ( Приоритет==КодПриоритетСрочный )
     wlmes.Importance = 1;
  end;
  if (substr(ДополнительныйТекстовыйБлокБуфер(1),1,3)=="SN:")
     wlmes.RelatedRef = substr(ДополнительныйТекстовыйБлокБуфер(1),4);
  else
     ErrUnknownField(substr(ДополнительныйТекстовыйБлокБуфер(1),1,2));
     return -1;
  end;
  if (not СоздатьЗапись(wlmes))
     ErrImport("Невозможно создать запись по форме MT "+SWIFTвидСообщения);
     return -1;
  end;
  
  SetParm(1, РелизФормы);
  return result;
end;

macro СчитатьTextBlockSB(НомерБлока, НомерФормы, РелизФормы, Отправитель, ДатаОтправки,
                         НомерПриложения, Block177, Block451, Block405, BlockMUR, FlagACK)
  var строка, длина, continue0, stat, result;
  var кодПоля, числоСтрок, error;
  var TextACK = "UAK";
  var Валюта = "", Сумма = $0;

  if((НомерБлока!="")  /* заголовок блока был прочитан ранее */
     AND (НомерБлока != НомерБлокаText))
    ErrImport("Пропущен блок 4 - Text");
    return -1;
  elif(НомерБлока == "")
    НомерБлока = СчитатьНачалоБлока();
    if( НомерБлока == "" ) return -1; end;
    if( НомерБлока != НомерБлокаText)
      ErrImport("Пропущен блок 4 - Text");
      SetParm(0,НомерБлока);
      return -1;
    else
      НомерБлока = "";
      SetParm(0,НомерБлока);
    end;
  end;

  длина = 70;
  строка = СчитатьСтроку( длина );
  if( длина == КонецФайла ) ErrImport("Не найдено завершение Блока 4"); return -1; end;
  if( строка != "" ) ErrImport( "После начала Блока 4 строка непустая"); return -1; end;

  /* VD 02.08.02 изменения под SWIFTAlliance 4.1
     Для ответных сообщений насильно проставляем НомерПриложенияFIN, чтобы считывать их из UAK,
     но UNK надо пропускать. Нигде не написано, что они не могут вывалиться к нам из терминала.
  */
  if((НомерПриложения == НомерПриложенияFINСервис) OR (Block451 == КодПоля451NAK) OR (FlagACK==true) )

    if ( FlagACK )
      if( Block451 == КодПоля451NAK)
        TextACK = "NAK";
      else
        TextACK = "ACK"
      end;
    else
      if( Block451 == КодПоля451NAK)
        TextACK = "UNK";
      else
        TextACK = "UAK"
      end;
    end;

    НомерФормы = -1;
    SetParm(1,НомерФормы);
    std.out(1,"Прочитан "+TextACK+" {"+НомерПоля177+":"+Block177+"}");
    if(valtype(Block405)==V_INTEGER) std.out(1,"{"+НомерПоля405+":"+Block405+"}"); end;
    if(valtype(BlockMUR)==V_INTEGER) std.out(1,"{"+НомерПоляMUR+":"+BlockMUR+"}"); end;
    std.out(1,"на полученное сообщение MT "+НомерФормы+" от "+Отправитель+" датой "+ДатаОтправки);
    return ReadUnknownMsg;
  end;

  /* Последовательно читаем поля сообщения */
  СтрокаСчитана = false;
  ВсеПоляСчитаны = false;
  continue0 = 1;
  while( continue0 )
     stat = СчитатьПолеИзФайла( РелизФормы, кодПоля, числоСтрок );
     if( stat == 1 )
        result = 0;
     elif( stat == 2 )
        ErrUnknownField( кодПоля );
        result = -1;
     elif( stat == 3 )
        ErrImport("Неожиданный конец файла");
        result = -1;
     elif( stat == 4 )
        ErrImport("Неверный формат поля");
        result = -1;
     elif( stat == 5 )
        result = 0;
     elif( stat == 6 )
        result = 1;
     elif( stat == 7 )
        result = 0;
     elif( stat == 8 )
        result = 0;
     end;
     if( stat )
        continue0 = 0;
     end;
     if( (stat == 0) OR (stat == 7) )
        if( not ОбработатьПолеSB( кодПоля, числоСтрок ) )
           ErrImport("Не обработали поле: " + кодПоля);
           continue0 = 0;
           result = -1;
        end;
        // Для платежей заполняем в отчете сумму и валюту
        if ((ВидСообщения == MESKIND_PAYMENT) AND (кодПоля == ValueDateCurrencyCodeAmountField_A))
          Валюта = SubStr(string(СтрокиПоля(0)),7,3);
          Сумма = SubStr(string(СтрокиПоля(0)),10);
          if( SubStr(Сумма,strlen(Сумма)) == ",")
            Сумма = moneyL(Сумма);
          else
            Сумма = moneyL(Сумма)/100;
          end;
        end;
     end;
     asize( СтрокиПоля, 0 );
  end;

  AddRepElem(wlmes.Kind, string("MT "+НомерФормы+КодПодтипСообщения), Валюта, Сумма);
  return result;
end;

macro СчитатьПоляКвитанции()
  var длина:integer = 300;
  var старт:integer;
  var неуспешность:integer;
  var строка:string;
  
  строка = СчитатьСтроку( длина );
  
  if( длина == КонецФайла ) ErrImport("Не найдено завершение Блока 4"); return -1; end;

  старт = 1; длина = strlen(КодНачалаБлока+НомерПоля177+КодРазделительНомера);
  if(substr(строка,старт,длина) == КодНачалаБлока+НомерПоля177+КодРазделительНомера )
     старт = старт + длина; длина = strlen("ddmmyyhhmi");
     /*Здесь должна считываться дата*/
     старт = старт + длина; длина = strlen(КодКонцаБлока);
     if(substr(строка,старт,длина) != КодКонцаБлока)
        return -1;
     end; 
  else
     return -1; 
  end;
  старт = старт + длина; длина = strlen(КодНачалаБлока+НомерПоля451+КодРазделительНомера);
  if(substr(строка,старт,длина) == КодНачалаБлока+НомерПоля451+КодРазделительНомера )
     старт = старт + длина; длина = strlen("1");
     неуспешность = substr(строка,старт,длина);
     старт = старт + длина; длина = strlen(КодКонцаБлока);
     if(substr(строка,старт,длина) != КодКонцаБлока)
        return -1;
     end; 
  else
     return -1; 
  end;
  старт = старт + длина; длина = strlen(КодНачалаБлока+НомерПоля405+КодРазделительНомера);
  if(substr(строка,старт,длина) == КодНачалаБлока+НомерПоля405+КодРазделительНомера )
     старт = старт + длина;
     длина = Index( SubStr(строка,старт), КодКонцаБлока )-1;
     wlmes.RespProcessingDescr = substr(строка,старт,длина);
     старт = старт + длина; длина = strlen(КодКонцаБлока);
     if(substr(строка,старт,длина) != КодКонцаБлока)
        return -1;
     end;
     старт = старт + длина; длина = strlen(КодНачалаБлока+НомерПоляMUR+КодРазделительНомера);
     if(substr(строка,старт,длина) == КодНачалаБлока+НомерПоляMUR+КодРазделительНомера )
        старт = старт + длина;
        длина = Index( SubStr(строка,старт), КодКонцаБлока )-1;
        /*Здесь должна быть обработка поля 108,но мы ее игнорируем*/
        старт = старт + длина; длина = strlen(КодКонцаБлока);
        if(substr(строка,старт,длина) != КодКонцаБлока)
           return -1;
        end;
     end;
  elif(substr(строка,старт,длина) == КодНачалаБлока+НомерПоляMUR+КодРазделительНомера )
     if(неуспешность)
        return -1;
     else
        старт = старт + длина;
        длина = Index( SubStr(строка,старт), КодКонцаБлока )-1;
        /*Здесь должна быть обработка поля 108,но мы ее игнорируем*/
        старт = старт + длина; длина = strlen(КодКонцаБлока);
        if(substr(строка,старт,длина) != КодКонцаБлока)
           return -1;
        end;
        
        wlmes.RespProcessingDescr = "000";
     end
  else
     return -1;
  end;
  старт = старт + длина; длина = strlen(КодКонцаБлока);
  if(substr(строка,старт,длина) != КодКонцаБлока);
     return -1;
  end;
  
  ОбновитьЗапись(wlmes);
  return 0;
end;


/***************************************************************************/
/*  Функция считывания сообщения SWIFT-SB                                  */
/*  Возвращает:                                                            */
/*             0 - все ОК                                                  */
/*             1 - сообщение не найдено                                    */
/*             2 - найден разделитель сообщений                            */
/*             3 - найден конец файла                                      */
/*            -1 - ошибка при обработке сообщения (ругается сама)          */
/***************************************************************************/
macro ОбработатьСообщениеSB( КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока, Отправитель, Получатель, ДатаОтправки, AddSign:bool )

  /* Вспомогательные переменные */
  var НомерФормы, РелизФормы, НомерБлока, Приоритет, result, СчитанныйБлок, Вид;
  var НомерПриложения, Block177, Block451, Block405, BlockMUR, FlagACK = false;
  var КодНазначениеСообщения, АбонентОтправитель, АбонентПолучатель, 
      ВремяОтправки, Ключ, ДлинаКлюча, ДатаКлюча, rsms;
  var tmp1, tmp2, tmp3;
  var CryptoAPI = RsCryptoAPI();

  УдалитьПеременныеБлока();
  ОчиститьДополнительныйТекстовыйБлокБуфер();
  if(not СчитатьБлокСлужебнойИнформацииСМФР(КодНачалаБлокаПрочитан, КодНазначениеСообщения, Отправитель, Получатель, АбонентОтправитель, АбонентПолучатель, ДатаОтправки, ВремяОтправки, Ключ, ДлинаКлюча, ДатаКлюча)) return -1; end;
  if(СчитатьДополнительныйТекстовыйБлокБуфер(КодНачалаБлокаПрочитан)) return -1; end;
  if((not СчитатьBasicHeaderBlockAck(КодНачалаБлокаПрочитан, tmp1, НомерПриложения, Block177, Block451, Block405, BlockMUR))
      AND (НомерПриложения != НомерПриложенияFIN) ) return -1; end;
  
  /* второй раз читать Basic Header Block надо только для ACK/NAK, UAK/UNK */
  if(НомерПриложения == НомерПриложенияFINСервис)
     result = СчитатьBasicHeaderBlock(КодНачалаБлокаПрочитан, tmp1, НомерПриложения);
     if((valtype(result)==V_INTEGER) AND (result == КонецФайла)) return 3; end;
     if( not result ) return -1; end;
  end;

  if (not этоКвитанцияОдоставке) 
  if (not СчитатьApplicationHeaderBlockMOR(tmp1, tmp2, НомерФормы, Приоритет, FlagACK) ) return -1; end;
  if (not СчитатьUserHeaderBlock          (НомерБлока) ) return -1; end;
  if (СчитатьДополнительныйТекстовыйБлок(НомерФормы, РелизФормы, Отправитель, ДатаОтправки, Приоритет)) return -1; end;
  if( НомерФормы == -1 ) return 0; end; /* пропускаем неизвестные формы */
     result = СчитатьTextBlockSB(НомерБлока, НомерФормы, РелизФормы, Отправитель, ДатаОтправки, НомерПриложения, Block177, Block451, Block405, BlockMUR, FlagACK);
  else
     НомерФормы = "0SA"; Приоритет = "N";
     РелизФормы = "0SA";/*!!!*/
     if (СчитатьДополнительныйТекстовыйБлокКвитанции(НомерФормы, РелизФормы, АбонентОтправитель, ДатаОтправки, Приоритет)) return -1; end;
     if (not СчитатьUserHeaderBlock          (НомерБлока) ) return -1; end;
     result = СчитатьПоляКвитанции();
     AddRepElem(wlmes.Kind, string("MT "+НомерФормы+КодПодтипСообщения), "", $0);
  end;
  
  if( НомерФормы == -1 ) return 0; end; /* пропускаем неизвестные формы */
  if( result == 1 )
    result = 2;
  elif( result ) return result; end;

  if ( wlmes.RlsFormID<=0 )
     ErrImport( "Не найдена форма сообщения" );
     return false;
  end;

  /* Считываем и сохраняем ЭЦП сообщения */
  if( (AddSign == true) AND (Ключ != "") )
    rsms = RsbMessage( wlmes.MesID );
    if( not CryptoAPI.InsertExternal( CONTEXTID_INSERT_SIGN_SWSB, rsms, Ключ, "", 0 ))
      ErrImport( String("Ошибка при сохранении ЭЦП сообщения|", +GetErrMsg()) );
      return -1;
    end;
    wlmes.Signed = SET_CHAR;
    ОбновитьЗапись(wlmes);
  end;

  if( not ПроверкаПолейСообщения( wlmes.RlsFormID, 0 ) ) return -1; end;

   SetParm(2,Отправитель);
   SetParm(3,Получатель);
   return result;
end;

/* Инструкция №518-4-р: cообщения в транспортном файле разделяются последовательностью символов CR\LF */
macro СчитатьРазделительСообщенийSB(КодНачалаБлокаПрочитан, Symbol)
  var строка, длина;

   /* SCR 90532, т.к. файл может быть подписан Бикриптом, то система может пытаться 
      распознать в наложенной ЭЦП очередное сообщение. 
      Пока временно считаем, что один файл == одно сообщение */
   /*  return 1; *//*Запрос 72855 закрыт*/  

   while(true)
     длина = 1;       

     строка = СчитатьСтроку( длина );
     if( длина == КонецФайла )
       return 1;
     end;
     if( строка == КодНачалаБлока )
       SetParm( 0, true );
       if ( valtype(Symbol)!=V_UNDEF )
          SetParm( 1, строка );
       end;
       return 0;
     end;
   end;
end;

macro SWIFTSBInProc(TpID, importFileName, addrSess)
   var КодНачалаБлокаПрочитан, Отправитель, Получатель, ДатаОтправки, stat;
   var continue0, Документов = 0;
   var СчитанныйКодНачалаБлока = "";
   var InsertSign, CryptoAPI = RsCryptoAPI(); 

   SetBuff( wlsess, addrSess );

   Транспорт = TpID;

   ПерейтиВНачалоФайла();

   /* Считываем заголовок файла */
   if (not СчитатьЗаголовок(Отправитель, Получатель, ДатаОтправки))
     return false;
   end;

   /* Считываем один раз настройку необходимости сохранения ЭЦП сообщений */
   InsertSign = CryptoAPI.IsCryptoActionNeeded( CONTEXTID_INSERT_SIGN_SWSB, 370 );

   continue0 = true;
   while(continue0)
      stat = ОбработатьСообщениеSB(КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока, Отправитель, Получатель, ДатаОтправки, InsertSign);
      if( stat == 1 )
        continue0 = false;
      elif( stat == 3 ) /* найден конец файла */
        continue0 = false;
      elif( stat == -1 )
        return false;
      elif( stat == 0 )
        stat = СчитатьРазделительСообщенийSB(КодНачалаБлокаПрочитан, СчитанныйКодНачалаБлока);
        if( stat == 1 )
          continue0 = false;
        elif( stat == -1 )
          return false;
        end;
      end;
      Документов = Документов + 1;
      message("Идет прием сообщений. Обработано: ", Документов );
   end;

   /* Считываем код конца файла */
   if (not СчитатьКонцовку())
      return false;
   end;

   PrintImportReport();
   return true;
end;
