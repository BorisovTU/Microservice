/*
  $Name: xmlmestools.mac
  $Module: Межбанковские расчеты
  $Description: Функции для сообщений в формате XML
*/

//-----------------------------------------------------------------------------
//          Автоматизированная банковская система RS-Bank               
//                 Copyright (c) R-Style Software Lab
//
// Подсистема   : Межбанковские расчеты
//
// Описание     : Функции для сообщений в формате XML
//
// Программист  : Чукина Т.А.
//
// Создан       : 14.05.2014
//
//-----------------------------------------------------------------------------

import "wlgenmes.mac", "wlexport.mac", "wlcaches.mac";

const beginField  = "_begin";
const endField    = "_end";

const INVALID_NODE                = 0;
const CHILD_NODE                  = 1;
const ATTR_NODE                   = 2;
const TEXT_NODE                   = 3;
const CDATA_SECTION_NODE          = 4;
const ENTITY_REFERENCE_NODE       = 5;
const ENTITY_NODE                 = 6;
const PROCESSING_INSTRUCTION_NODE = 7;
const COMMENT_NODE                = 8;
const DOCUMENT_NODE               = 9;
const DOCUMENT_TYPE_NODE          = 10;
const DOCUMENT_FRAGMENT_NODE      = 11;
const NOTATION_NODE               = 12;

macro GetNodeName( name )
   return substr(name, index(name,":")+1);
end;


//----------------------------------------------------------------------------------
// Запись данных при генерации сообщения
//----------------------------------------------------------------------------------

macro StartBlockLogXML(BlockName : string)
  if( BlockName )
    УстановитьКонтекстБлокаЛог( BlockName );
    ЗаписатьПолеЛог( beginField, BlockName );
  end;
end;

macro FinishBlockLogXML(BlockName : string)
  if( BlockName )
    ЗаписатьПолеЛог( endField, BlockName ) ;
    УстановитьКонтекстБлокаЛог( ".." );
  end;
end;

macro WriteFieldLogXML(FieldName : string, FieldValue : string, IsTextNode : bool)

  if(FieldName and FieldValue)
    if( IsTextNode )
      StartBlockLogXML( FieldName );
    end;
    
    ЗаписатьПолеЛог(FieldName, FieldValue);
    
    if( IsTextNode )
      FinishBlockLogXML( FieldName );
    end;    
  end;

end;


//----------------------------------------------------------------------------------
// Экспорт в XML
//----------------------------------------------------------------------------------

class TFldExportHandler

  // true - нужно записывать поле в сообщение
  // false - не нужно записывать поле в сообщение
  // если ошибка критичная и надо прерывать экспорт - выбросить RunError или RsbThrow
  macro ProcessFld(FieldName : @string, FieldValue : @string) : bool

    if( FieldName == "IncludeWaitForSettle" )  
      FieldName = "IncludeWaitForSettlementFlag";      
    end;

    return true;
  end;
end;

private macro SetTextOrAttribute(CurNode, XmlObj, FieldName, FieldValue, FldHandler)

  if( FieldName == CurNode.nodeName )
    CurNode.appendChild( XmlObj.createTextNode(FieldValue) );
  else
    if( FldHandler.ProcessFld(@FieldName, @FieldValue) == true )
      CurNode.SetAttribute(FieldName, FieldValue);
    end;
  end;

end;

macro ExportMesToXmlNode
(
  FirstNode : @object, // если не создан заранее, то будет создан по названию верхнего блока
  wlmes : StrucRef,
  AllFldsAreRead : @bool,
  FldHandler : TFldExportHandler // необязательный
  
) : bool

  if(FldHandler == null)
    FldHandler = TFldExportHandler();
  end;

  var FieldName : string = "", FieldValue : string = "";
  var XmlObj : object = ActiveX("Microsoft.XMLDOM"),
      CurNode : object = FirstNode,
      IsReadingStopped : bool = false;

  AllFldsAreRead = false;
  while( СчитатьПоле( FieldName, FieldValue ) )

    if( FirstNode == null )
      if(FieldName == beginField)
        FirstNode = XmlObj.createElement(FieldValue);
        CurNode = FirstNode;
      else
        ErrExport("Нарушена структура сообщения " + wlmes.Trn);
        return FALSE;
      end;

    elif( FieldName == beginField ) // новый блок
      CurNode = CurNode.appendChild( XmlObj.createElement(FieldValue) );

    elif( FieldName == endField )   // конец блока
      if( FieldValue == CurNode.nodeName)
        if(CurNode.parentNode != null)
          // завершение текущего блока
          CurNode = CurNode.parentNode;
        else
          // закончилась последовательность полей, отражающих XML-структуру;
          // оставшиеся поля должны быть прочитаны и обработаны вне этого алгоритма
          IsReadingStopped = true;
          break;
        end;
      else
        ErrExport("Нарушена структура сообщения " + wlmes.Trn);
        return FALSE;
      end;

    else                            // внутри блока
      SetTextOrAttribute(CurNode, XmlObj, FieldName, FieldValue, FldHandler);
    end;

  end;

  if(not IsReadingStopped)
    AllFldsAreRead = true;
  end;

  if(CurNode.nodeName != FirstNode.nodeName)
    ErrExport("Нарушена структура сообщения " + wlmes.Trn);
    return FALSE;
  end;

  return TRUE;
end;


//----------------------------------------------------------------------------------
// Импорт из XML
//----------------------------------------------------------------------------------

class TFldImportHandler
  macro ProcessAttr( FieldName : string, FieldValue : string )
  end;

  macro ProcessAttrNm( FieldName : @string )
  end;
  macro ProcessNodeNm( NodeName : @string )
  end;
end;

private macro WriteAttrToField
( elem : object, 
  attrName : string, 
  FldHandler : TFldImportHandler
)

  if(not elem.attributes)
    return;
  end;

  var i : integer = 0, child : object = null;

  while( i < elem.attributes.length )
    child = elem.attributes.item(i);

    if( child and (child.nodeType==ATTR_NODE) )
      var FieldName : string = GetNodeName(child.nodeName),
          FieldValue : string = child.nodeValue;

      FldHandler.ProcessAttrNm(@FieldName);

      if(FieldName == attrName)
        FldHandler.ProcessAttr(FieldName, FieldValue);
        ЗаписатьПоле(FieldName, FieldValue);
        break;
      end;
    end;

    i=i+1;
  end;

end;

private var RlsFldCache : TRlsFldsByMaster = TRlsFldsByMaster();

private macro GetRlsFlds(Master : integer) : TArray
  var RlsFlds : TArray = null;

  if( not RlsFldCache.Get(Master, @RlsFlds) )
    RunError("В релизе сообщения не найдены поля блока " + Master);
  end;

  return RlsFlds;
end;

private macro ImportItems
( Master : integer, 
  node : object, 
  FldHandler : TFldImportHandler
)

  var RlsFldList : TArray = GetRlsFlds(Master);

  for(var RlsFld : TRlsFld, RlsFldList)
    if(RlsFld.BlockFlag == "X")
      // Составной элемент
      var i : integer = 0;
      var child : object = null;

      while( (child = node.childNodes().item(i)) != null )
        var childNodeName = GetNodeName(child.nodeName);
        FldHandler.ProcessNodeNm( @childNodeName );
        if( (child.nodeType == CHILD_NODE) and 
            (childNodeName == RlsFld.BlockName)
          )
          StartBlockLogXML(RlsFld.BlockName);

          // Записать вложенные элементы и атрибуты блока
          ImportItems(RlsFld.FieldID, child, FldHandler);

          FinishBlockLogXML(RlsFld.BlockName);
        end;

        i = i + 1;
      end;

    elif( (RlsFld.Name == GetNodeName(node.nodeName)) and (node.childNodes.length != 0) and (strlen(node.childNodes().item(0).nodeValue) > 0) ) // Если название поля в релизе равно названию текущего узла(это значит, что мы наткнулись 
      // Текстовый элемент                                                                                    //  на текстовый элемент), то дополнительно проверим длинну текста этого узла. Если оказывается, 
      if( strlen(node.childNodes().item(0).nodeValue) > 2000 )                                                // что длинна текста внутри нулевая, то считаем, что это атрибут и уходим в ветку атрибута
        var NodeArr = StrSplit2(node.childNodes().item(0).nodeValue, 2000, true);
        var str = ""; var StrCount = 0;
        for( str, NodeArr )
          if( StrCount != 0 )
            StartBlockLogXML(RlsFld.Name);
          end;
          ЗаписатьПоле( RlsFld.Name, NodeArr[StrCount] );
          if( StrCount != (NodeArr.size - 1) )
            FinishBlockLogXML(RlsFld.Name);
          end;
          StrCount = StrCount + 1;
        end;
      else
        ЗаписатьПоле( RlsFld.Name, node.childNodes().item(0).nodeValue );
      end;
    elif( not InList(RlsFld.Name, beginField, endField) )
      // Атрибут
      WriteAttrToField(node, RlsFld.Name, FldHandler);
    end;
  end;

end;

macro ImportXmlNodeToMes
( node : object,
  RlsFormID : integer,
  FldHandler : TFldImportHandler
)
  if(FldHandler == null)
    FldHandler = TFldImportHandler();
  end;

  RlsFldCache.SetRlsFormID(RlsFormID);

  ImportItems(0, node, FldHandler);
end;


//----------------------------------------------------------------------------------
// Чтение данных из XML
//----------------------------------------------------------------------------------

/* Ищет атрибут в рамках узла. В дочерние входит только в рамках указанного пути */
macro ReadAttribute( node:object, attrName, path, IsMandatory )   
   var i, child:object;
   var result = "", chName;

   if ( valtype(path)==V_UNDEF )
      path = "";
   end;

   if ( valtype(IsMandatory)==V_UNDEF )
      IsMandatory = true;
   end;

   if ( node.NodeType==DOCUMENT_NODE )
      i=0;
      while( i < node.childNodes.length )
        child = node.childNodes.item(i);
        if( child and (child.nodeType==CHILD_NODE) )
           return ReadAttribute( child, attrName, path, IsMandatory );
        end;
        i = i+1;
      end;
      if ( IsMandatory )
        if ( path!="" )
           path = path + "/";
        end;
        RunError( "Не найден обязательный тег " + path + attrName  );
      end;
      return "";
   end;

   if ( path!="" )
      if ( index(path,"/")==0 )
         chName = path;
      else
         chName = substr(path,1,index(path,"/")-1);
      end;

      i=0;
      while( i < node.childNodes.length )
        child = node.childNodes.item(i);
        if( child and (child.nodeType==CHILD_NODE) and (GetNodeName(child.NodeName)==chName) )
          if ( index(path,"/")==0 )
             return ReadAttribute( child, attrName, "", IsMandatory );
          else
             return ReadAttribute( child, attrName, substr(path,index(path,"/")+1), IsMandatory);
          end;
        end;
        i=i+1;
      end;

      if ( IsMandatory )
        if ( path!="" )
           path = path + "/";
        end;
        RunError( "Не найден обязательный тег " + path + attrName + " в узле " + node.NodeName );
      end;
      return "";
   end;

   i=0;
   while( i < node.attributes.length )
     child = node.attributes.item(i);
     if( child and (child.nodeType==ATTR_NODE) )
        if ( GetNodeName(child.NodeName)==attrName )
          i = node.attributes.length;
          result = child.nodeValue;
        end;
     end;
     i=i+1;
   end;

   if ( IsMandatory and (result=="") )
      RunError( "Не найден обязательный тег " + attrName + " в узле " + node.NodeName );
   end;

   return result;
end;

macro ReadOptinalAttribute( node:object, attrName, path )   
   if ( valtype(path)==V_UNDEF )
      path = "";
   end;
   return ReadAttribute( node, attrName, path, false );
end;

//Существует ли такой дочерний узел? 
macro IsChildNode(ParentNode : object, ChildNodeName : string) : bool
  var node : object = ParentNode;
  if( ParentNode.nodeType == DOCUMENT_NODE )
    node = ParentNode.DocumentElement;
  end;

  var i : integer = 0;
  var child:object;
  
  while( i < node.childNodes.length )
    child = node.childNodes.item(i);
    if( child and (child.nodeType==CHILD_NODE) )    
      if( GetNodeName(child.NodeName) == ChildNodeName )
        return true;
      end;
    end;
    i=i+1;
  end;

  return false;  

end;

macro GetChildNode(node : object, ChildNodeName : string) : object
  var i : integer = 0;
  var child : object = null;
  
  while( i < node.childNodes.length )
    child = node.childNodes.item(i);

    if( child and (child.nodeType == CHILD_NODE) )    
      if( (GetNodeName(child.NodeName) == ChildNodeName) )
        return child;
      end;
    end;
    
    i=i+1;
  end;

  return null;  

end;

macro GetChildNodeConsideringHierarchy( node : object, ChildNodeName : string ) : object
  if( ( GetNodeName( node.NodeName ) == ChildNodeName ) )
    return node;
  end;
  
  var i : integer = 0;
  var child : object = null;
  var resNode : object = null;
  
  while( i < node.childNodes.length )
    child = node.childNodes.item(i);

    if( child and (child.nodeType == CHILD_NODE) )    
      resNode = GetChildNodeConsideringHierarchy( child, ChildNodeName );
      if( resNode != null )
        return resNode;
      end;
    end;
    
    i=i+1;
  end;

  return null;
end;

/* Читает текст поля */
macro ReadNodeText( node:object, fullPath:string, IsMandatory:bool ):string
  var chName, i:integer, child:object, textNode:string;

  if( valtype(IsMandatory) == V_UNDEF )
    IsMandatory = true;
  end;

  if( node.NodeType==DOCUMENT_NODE )
     i=0;
     while( i < node.childNodes.length )
       child = node.childNodes.item(i);
       if( child and (child.nodeType==CHILD_NODE) )
         textNode = ReadNodeText( child, fullPath, false );
         if( textNode != "" ) 
           return textNode; 
         end; 
       end;
       i = i+1;
     end;
     if ( IsMandatory )
       RunError( "Не найден обязательный тег " + fullPath  );
     end;
     return "";
  end;

  if ( index(fullPath,"/")==0 )
     chName = fullPath;
  else
     chName = substr(fullPath,1,index(fullPath,"/")-1);
  end;

  i=0;
  while( i < node.childNodes.length )
    child = node.childNodes.item(i);
    if( child and (child.nodeType==CHILD_NODE) )    
      if( (GetNodeName(child.NodeName) == chName) )      
        if(index(fullPath,"/")==0 )
           return child.Text;
        else
           textNode = ReadNodeText( child, substr(fullPath,index(fullPath,"/")+1), false);
           if( textNode != "" ) 
             return textNode; 
           end; 
        end;
      end;
    end;
    i=i+1;
  end;

  if( IsMandatory )
    RunError( "Не найден обязательный тег " + fullPath + " в узле " + node.NodeName );
  end;

  return "";
end;

macro ReadOptinalNodeText( node:object, fullPath, IsMandatory )
   return ReadNodeText( node, fullPath, false );
end;

class XmlAttrsElems( _ElementID, _BlockName, _FieldName, _FieldValue, _NodeType, _ParentID )
  var ElementID:  integer,
      BlockName:  string,
      FieldName:  string,
      FieldValue: string,
      NodeType:   integer,
      ParentID:   integer;
 
  macro Construct( _ElementID, _BlockName, _FieldName, _FieldValue, _NodeType, _ParentID )
    ElementID = NodeType = ParentID = 0;
    BlockName = FieldName = FieldValue = "";
    if( valtype( ElementID ) != V_UNDEF )
      ElementID = _ElementID;
    end;
    if( valtype( BlockName ) != V_UNDEF )
      BlockName = string( _BlockName );
    end;
    if( valtype( FieldName ) != V_UNDEF )
      FieldName = string( _FieldName );
    end;
    if( valtype( FieldValue ) != V_UNDEF )
      FieldValue = string( _FieldValue );
    end;
    if( valtype( NodeType ) != V_UNDEF )
      NodeType = _NodeType;
    end;
    if( valtype( ParentID ) != V_UNDEF )
      ParentID = _ParentID;
    end;            
  end;

  Construct( _ElementID, _BlockName, _FieldName, _FieldValue, _NodeType, _ParentID );
end;

// Макрос 
// Входные параметры:
// Возвращаемое значение:
macro GetXMLElementsAndAttributesArray( node : object, XmlAttrsElemsArray : @TArray, FormName : string, blockName : string ) : bool
  var i : integer = 0;
  var child : object = null;
  var stat : bool = false;
  var attrsParentID : integer = 0;
  var tmpBlockName : string = "";
  var needSkipFormBlockName = false;

  if( not XmlAttrsElemsArray )
    XmlAttrsElemsArray = TArray()
  end;

  if( node == null )
    return false;                           
  end;

  if( (valtype(FormName) != V_UNDEF) and (FormName != "") and (node.BaseName() == FormName) )
    needSkipFormBlockName = true;
  end;

  if( (node.NodeType == CHILD_NODE) and (not needSkipFormBlockName) )
    if( (valtype(blockName) != V_UNDEF) and (blockName != "") )
      tmpBlockName = blockName + "\\";
    end;
    tmpBlockName = tmpBlockName + substr( node.NodeName, index( node.NodeName,":" ) + 1 );
  end;
                      
  if( (node.NodeType == CHILD_NODE) and (not needSkipFormBlockName) )
    XmlAttrsElemsArray[XmlAttrsElemsArray.size] = XmlAttrsElems( XmlAttrsElemsArray.size, 
                                                                 tmpBlockName, 
                                                                 beginField, 
                                                                 "", 
                                                                 -1, 
                                                                 attrsParentID );
  end;
                                                                   
  if( node.attributes )
    attrsParentID = XmlAttrsElemsArray.size - 1;
    i = 0;
    child = null;
    while( i < node.attributes.length )
      child = node.attributes.item(i);

      if( child and (child.nodeType == ATTR_NODE) )
        XmlAttrsElemsArray[XmlAttrsElemsArray.size] = XmlAttrsElems( XmlAttrsElemsArray.size, 
                                                                     tmpBlockName, 
                                                                     substr( child.NodeName, index( child.NodeName,":" ) + 1 ), 
                                                                     child.NodeValue, 
                                                                     child.NodeType, 
                                                                     attrsParentID );
      end;
      i=i+1;
    end;
  end;

  i = 0;
  child = null;
  stat = false;

  while( i < node.childNodes.length )
    child = node.childNodes.item(i);
    if( child and (child.nodeType == CHILD_NODE) )    
      stat = GetXMLElementsAndAttributesArray( child, @XmlAttrsElemsArray, FormName, tmpBlockName );
    elif( child and (child.nodeType == TEXT_NODE) )
      XmlAttrsElemsArray[XmlAttrsElemsArray.size] = XmlAttrsElems( XmlAttrsElemsArray.size, 
                                                                   tmpBlockName, 
                                                                   substr( node.NodeName, index( node.NodeName,":" ) + 1 ), 
                                                                   child.Text, 
                                                                   child.NodeType, 
                                                                   attrsParentID );
      end;
    
    i=i+1;
  end;

  if( (node.NodeType == CHILD_NODE) and (not needSkipFormBlockName) )
    XmlAttrsElemsArray[XmlAttrsElemsArray.size] = XmlAttrsElems( XmlAttrsElemsArray.size, 
                                                                 tmpBlockName, 
                                                                 endField, 
                                                                 "", 
                                                                 -1, 
                                                                 attrsParentID );
  end;

  return true;
end;
