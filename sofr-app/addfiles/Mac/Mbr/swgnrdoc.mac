/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/* Константы и вспомогательные функции для генерации учетных объектов по    */
/* сообщениям SWIFT стандарту RUR5                                          */
/*                                                                          */
/*  Имя файла: swgnrdoc.mac                                                 */
/*  Создан:    07.09.00                                        Бабин А.П.   */
/****************************************************************************/

import "swgendoc.mac";

const
   LEX_SEP     = "/",
   LEX_NEWLINE = "//";

/* Список лексем, информация которых подлежит транслитерации (заключать лексемы в слеши) */
array LexemeYesTranslat;
LexemeYesTranslat(0)= LEX_SEP + Field72CodesNZP + LEX_SEP;


macro DeterminLexeme( str )
   var Lex="", i;
   if ( substr(str,1,1)==LEX_SEP )
      i=2;
      while( i<=10 )  /* 8 - максимальная длина лексемы + 2 слеша */
          if ( subStr(str,i,1)==LEX_SEP )
             Lex = subStr( str, 1, i );
             i==10; /* Останавливаем цикл */
          end;
          i = i+1;
      end;
   end;
   return Lex;
end;

macro StrRestoreCharset(
                         srcStr,    /* входной поток */
                         srcSet,    /* входной чарсет */
                         dstStr,    /* выходной поток */
                         dstSet,    /* выходной чарсет */
                         separate,  /* символ переключения клавиатуры */
                         IsKeepAcc, /* Может ли входной поток содержать счет */
                         MacroTransliter, /* Макрос транслитерации (если необходимо осуществить более сложную транслитерацию) */
                         userData,  /* Дополнительные данные для макроса транслитерации */
                         TranslitAlwaysSet ) // Всегда транслитерируемые символы (даже внутри ограничителей separate)
   /* На сегодняшний день реализован самый простой вариант этой фунции:
      дешифровка осуществляется при равных размерах чарсетов */
   /* Набор символов, заключенных между символами separate, сохраняется без изменений,
      за исключением символов, входящих в строку TranslitAlwaysSet */
   var alt = 0, n, i, ind, Ibegin, count, j=0, Lex, Translat=1, loop, PrevLex="";
   array dest;

   n = strlen(srcStr);
   /* Первым делом разбиваем исходную запись на подстроки */
   Ibegin=1;
   count=0;
   i=1;
   while( i<=n )
      if ( subStr(srcStr,i,1)!="\n" )
         count=count+1;
      else
         dest(j)=subStr(srcStr,Ibegin,count+1);
         j=j+1;
         Ibegin = Ibegin+count+1;
         count=0;
      end;   
      i=i+1;
   end;
 
   if ( count )
      dest(j)=substr(srcStr,Ibegin);
   end;
   /* dest - хранит подстроки */
 
   j=0;
   dstStr = "";
   while( j<Asize(dest) )
      /* Определяем лексему текущей строки */
      Lex = DeterminLexeme( dest(j) );
      /* Определяем нужно-ли переводить информацию идущую
            после данной лексемы */
      if ( Lex=="" )
         if ( (substr(dest(j), 1, 1)==LEX_SEP) AND IsKeepAcc )
            Translat = 0;
         else
            Translat = 1;
         end;
      elif ( Lex!=LEX_NEWLINE )
         count = 0;
         Translat = 0;
         while( count<Asize(LexemeYesTranslat) )
            if ( Lex==LexemeYesTranslat(count) )
               Translat = 1;
               count=Asize(LexemeYesTranslat);
            end;
            count = count+1;
         end;
      elif ( (Lex==LEX_NEWLINE) AND (j==0) AND (IsKeepAcc) )
         Translat = 0;
      end;
      if ( Translat==0 )
         /* Переводить не нужно, копируем строку как есть */
         dstStr = dstStr +  dest(j);
      else
         /* Добавляем в выходной поток лексему */
         dstStr = dstStr + Lex;
         if ( Lex==LEX_SEP+Field72CodesNZP+LEX_SEP )
            /* Если лексема NZP (т.е это продолжение какого-то поля), то
               следует определить "язык" первого шрифта (надо помнить, что
               символ separate - переключатель регистра, поэтому следут определить
               не переключен-ли регистр первого символа, ведь эта строка
               является продолжением некого поля) */
            loop=1;
            count = 0;
            alt = 0;
            while( loop )
                i=1+StrLen(DeterminLexeme( dest(j+count) ));
                while( i<=strLen(dest(j+count)) )
                   if ( substr(dest(j+count),i,strlen(separate))==separate )
                      if ( alt ) alt = 0;
                      else alt = 1;
                      end;
                   end;
                   i=i+1;
                end;
                count = count + 1;
                if ( DeterminLexeme( dest(j+count) )!=LEX_NEWLINE )
                   loop = 0;
                end;
            end;
         elif ( (Lex!=LEX_NEWLINE) AND (PrevLex!="") )
            alt = 0;
         end;
         /* Осуществим перевод текущей строки */
         if ( (valtype(MacroTransliter)==V_UNDEF) OR (MacroTransliter=="") )
            /* Осуществляем "простую" транслитерацию по чарсетам */
            i=1+strlen(Lex);
            while( i<=strLen(dest(j)) )
               var curr_symb = substr( dest(j), i, 1 );
               if ( curr_symb == separate )
                  if ( alt ) alt = 0;
                  else alt = 1;
                  end;
               else
                  if ( (alt == 0)
                       or 
                       ( (valtype(TranslitAlwaysSet) == V_STRING) and 
                         index(TranslitAlwaysSet, curr_symb) )
                     )
                    ind = Index( srcSet, curr_symb );
                  else 
                    ind = 0;
                  end;
                  if ( ind == 0 )
                     dstStr = dstStr + curr_symb;
                  else
                     dstStr = dstStr + substr( dstSet, ind, 1 );
                  end;
               end;
               i = i+1;
            end;
         else
            /* Даем возможность пользователю функции осуществить более сложную транслитерацию */
            i=1+strlen(Lex);
            dstStr = dstStr + ExecMacro2( MacroTransliter, substr(dest(j), i), alt, separate, userData );
         end;
      end;
      PrevLex=Lex;
      j = j + 1;
   end;
 
 
   SetParm( 2, dstStr );
end; 

/* Макрос транслитерации по RUR4 (на руссий язык) */
macro MacroTransliterRUR4( srcStr, alt, separate )
    var dstStr = "", i, j, NSeq, wasSeq, ind, rstSeq;
    
    srcStr = StrUpr( srcStr );
    NSeq = asize(SeqRUR4);
    i = 1;
    while( i<=strlen(srcStr) )
       /*Проверим на наличие комбинаций */ 
       j = 0;
       wasSeq = 0;
       while( (wasSeq==0) AND (j<NSeq) )
          rstSeq = SeqRUR4(j).RestoreSeq(substr(srcStr,i), alt);
          if ( rstSeq!="" )
             dstStr = dstStr + rstSeq;
             wasSeq = 1;
          else 
             j = j + 1;
          end;
       end;
       if ( wasSeq )
          i = i + SeqRUR4(j).SizeRstSeq();
       else
          /* Последовательности не было */
          if ( substr( srcStr, i, strlen(separate) )==separate )
             if ( alt ) alt = 0;
             else alt = 1;
             end;
             i = i+strlen(separate);
          else
             if ( alt == 0 )
               ind = Index( RusRUR4XSet, substr( srcStr, i, 1 ) );
             else ind = 0;
             end;
             if ( ind == 0 )
               dstStr = dstStr + substr( srcStr, i, 1 );
             else
               dstStr = dstStr + substr( RusRUR4Set, ind, 1 );
             end;
             i = i+1;
          end;
       end;
    end;
    SetParm( 1, alt );
    return dstStr;
end;

macro StrRestoreStandart( srcStr, /* входной поток */
                          dstStr, /* выходной поток */
                          standart,
                          IsKeepAcc,/* Может ли входной поток содержать счет */
                          passVOCode // Передать код ВО из начала строки
                        )
  if ( valtype(IsKeepAcc)==V_UNDEF ) IsKeepAcc = 1; end;

  if ( (standart==ST_RUR5) OR (standart==ST_RUR6) )
    var VOCode = "";
    if(passVOCode)
      // Проверяется, что в начале строки, с первой позиции, имеется код вида 
      // "'(VOnnnnn)'" или "'(VOnnnnnPSnnnnnnnn/nnnn/nnnn/n/n)'"
      if( (SubStr(srcStr, 1, 4) == "'(VO") and
          ( (SubStr(srcStr, 10, 2) == ")'") or (SubStr(srcStr, 35, 2) == ")'") )
        )
        var ind = index(srcStr, ")'");
        VOCode = "{VO" + SubStr(srcStr, 5, ind - 5) + "}";
        srcStr = SubStr(srcStr, ind + 2);
      end;
    end;     
    StrRestoreCharset( srcStr, RusRUR5XSet, dstStr, RusRUR5Set, RUR5_SETSWITCH, IsKeepAcc, null, null, RUR6TranslitAlwaysSet );
    dstStr = VOCode + dstStr;
  elif ( standart==ST_RUR4 )
    StrRestoreCharset( srcStr, "", dstStr, "", RUR4_SETSWITCH, IsKeepAcc, "MacroTransliterRUR4" );
  else 
    dstStr = srcStr;
  end;

  SetParm( 1, dstStr );
end;

macro ДоопределитьСтандарт( TRN )
   var standart;
   if ( substr(TRN, 1, 1 )==RUR5_CHAR )
      standart = ST_RUR5;
   elif ( substr(TRN, 1, 1 )==RUR4_CHAR )
      standart = ST_RUR4;
   else standart = ST_UNDEF;
   end; 
   return standart;
end;