 /*
 $Name: WLTOOLS.MAC
 $Module: Межбанковские расчеты
 $Description: Общие константы и вспомогательные функции для МБР
 */

/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/* Общие константы и вспомогательные функции                                */
/*                                                                          */
/*  Имя файла: wltools.mac                                                  */
/*  Создан:  24.01.00                                        Алешин А.В.    */
/****************************************************************************/

import rsd,oralib,likepy,cb_sql, CTInter, "lib_lang.mac", MesInter, globals, WldInter, FIInter, PTInter;

const Свой_МФО     = {MFO_Bank};
const Свой_Корсчет = {CORAC_Bank};
const Свой_Регион  = substr( Свой_МФО, 3, 2 ); /* для России так */

// Виды кодов в wlcodes.dbt
const TYPE_CODE_UFBS_ED203    = 42,
      TYPE_CODE_UFBS_ED243    = 49,
      TYPE_CODE_SBRF_KVITCODE = 50,
      TYPE_CODE_UFBS_KVITCODE = 51,
      TYPE_CODE_UFBS_ED244    = 52,
      TYPE_CODE_FNS_RPO       = 55,
      TYPE_CODE_UFBS_ED274    = 58,
      TYPE_CODE_UFBS_ED206    = 60,
      TYPE_CODE_UFBS_ED573    = 64,
      TYPE_CODE_FNS_CODEDEC2  = 77,
      TYPE_CODE_UFBS_ED807_CREATIONREASON    = 80,
      TYPE_CODE_UFBS_ED807_INFOTYPECODE      = 81,
      TYPE_CODE_UFBS_ED806_REQUESTCODE       = 82,
      TYPE_CODE_UFBS_ED801_INFOTYPECODE      = 83, // Вид представления информации
      TYPE_CODE_UFBS_ED8NN_LIMITCHANGETYPE   = 84, // Вид изменения лимита
      TYPE_CODE_UFBS_ED8NN_LIMITTYPE         = 85, // Тип лимита
      TYPE_CODE_UFBS_ED8NN_CLEARINGCIRCUIT   = 86, // Клиринговая схема
      TYPE_CODE_UFBS_ED802_CREATIONREASON    = 87, // Код причины формирования ЭСИС
      TYPE_CODE_UFBS_ED802_ACCOUNTCHANGETYPE = 88, // Тип изменения режима работы счета
      TYPE_CODE_UFBS_ED802_GROUPCODE         = 89, // Код группы
      TYPE_CODE_UFBS_ED808_CREATIONREASONCODE = 90,
      TYPE_CODE_UFBS_ED808_EVENTCODE = 91,
      TYPE_CODE_UFBS_ED8NN_QUEUETYPE = 92,
      TYPE_CODE_UFBS_ED805_QUEUINGREASONCODE = 93,
      TYPE_CODE_UFBS_ED245_RECEIVERTYPECODE = 95;

/* Стандарты */
const ST_UNDEF = 0, /* Нет стандарта транслитерации */
      ST_NONTR = 1, /* Не использовать транслитерацию*/
      ST_RUR4  = 4, /* Стандарт транститерации - RUR4 */
      ST_RUR5  = 5, /* Стандарт транститерации - RUR5 */
      ST_RUR6  = 6; /* Стандарт транслитерации SWIFT RUR6 совпадает с RUR5*/

const /* типы символов */
      TS_NUM    = 1,
      TS_ALPHA  = 2,
      TS_ALPNUM = 3,
      TS_XSET   = 4,
      TS_YSET   = 5,
      TS_HEX    = 6,
      TS_SIGN   = 7,
      TS_BLANK  = 8,
      TS_DIGIT  = 9,
      TS_RUSBIG = 10,
      TS_XSETRUSBIG   = 11,
      TS_ALLSET       = 12;

const /* типы длин */
      TL_FIXED = 1,
      TL_MAX   = 2,
      TL_BLOCK = 3,
      TL_RANGE = 4;

const WLD_DIRECT_ALL = 1, /* Все сообщения */ 
      WLD_DIRECT_OUT = 2, /* Исходящие сообщения */
      WLD_DIRECT_IN  = 3; /* Входящие сообщения */

const /* таблицы перекодировки */
RusSet    = "АБВГДЕЁ Ж ЗИЙКЛМНОПРСТУФХЦ Ч Ш Щ   ЪЫЬЭЮ Я абвгдеё ж зийклмнопрстуфхц ч ш щ   ъыьэю я abcdefghijklmnoprqstuxyvwz_\"",
/*RusXSet   = "ABVGDEYOZHZIJKLMNOPRSTUFHTSCHSHSHCH'Y'EYUYAabvgdeyozhzijklmnoprstufhtschshshch'y'eyuya";*/
RusXSet   = "ABVGDEYOZHZIJKLMNOPRSTUFHTSCHSHSHCH'Y'EYUYAABVGDEYOZHZIJKLMNOPRSTUFHTSCHSHSHCH'Y'EYUYAABCDEFGHIJKLMNOPRQSTUXYVWZ-'",

RusRUR5Set    = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ!№$%&'()*/;<=>@[]^_`{|}~#\"\\",
RusRUR5XSet   = "ABVGDEoJZIiKLMNOPRSTUFHCcQqxYXeuabnspdj()f/v(r)f()fzj(/)fnm/",
RusRUR4Set    = "'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ/ - _ : ? , ( ) + ",
RusRUR4XSet   = "'ABVGDEEJZI)KLMNOPRSTUFH+(,?'YXWQCWXQXQXCXAXEXIXOXUX",
RUR5_SETSWITCH = "'",
RUR4_SETSWITCH = "YX";

const /* символьные таблицы */
NumSet    = "0123456789",
AlphaSet  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
AlphaNumSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
/* дополнительно в X set входит <CrLf> */
XSet      = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789/-?:().,'+ ",
YSet      = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,-()/='+:?!\"%&*;<>",
HexSet    = "ABCDEF0123456789",
SignSet   = "+-",
BlankSet  = " ",
DigitSet  = "0123456789,",
RusBigSet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЧЦШЩЬЫЪЭЮЯ",
XSetRusBig= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789/-?:().,'+ АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЧЦШЩЬЫЪЭЮЯ",
RUR6TranslitAlwaysSet = "jnpdbsvzrmf";

const SYMB_SLASH  = "/",
      SYMB_DSLASH = "//",
      SYMB_ENDL   = "\n",
      SYMB_BLANK  = " ";

const WLD_REQ_SEPARATE = "\x01";


class TMesField(field_name : string, field_value : string, block_name : string)
  var FieldName  : string = "";
  var FieldValue : string = "";
  var BlockName : string = "";// необязательный

  // constructor
  FieldName  = field_name;
  FieldValue = field_value;
  if(block_name)
    BlockName = block_name;
  end;
end;


/* Проверяет, является ли FIID рублевой валютой. Нужно, если нац.валюта - не рубли */
macro IsRUR(FIID : integer):bool
  file f_i ( fininstr ) key 0;
  f_i.FIID = FIID;
  if( GetEQ(f_i) and (f_i.ISO_Number == "643") )
    return true;
  end;
  return false;
end;

/* Класс последовательности транслитерации на RUR4 */
class TSeqRUR4( _BeginSeq, _EndAltSeq, _EndSeq )
    var BeginSeq = "", EndAltSeq = "", EndSeq = "";

    macro Init( _BeginSeq, _EndAltSeq, _EndSeq )
       BeginSeq  = _BeginSeq;
       EndAltSeq = _EndAltSeq;
       EndSeq    = _EndSeq;
    end;

    macro SizeRstSeq
       return strLen(BeginSeq);
    end;

    macro SizeTrsSeq( alt )
       if ( (valtype(alt)==V_UNDEF) OR (alt==0) ) 
          return strLen(EndSeq);
       else
          return strLen(EndAltSeq);
       end;
    end;

    macro TranslateSeq( _seq, alt )
       var seq = subStr( _seq, 1, SizeTrsSeq( alt ) );
       if ( alt==0 )
          if ( seq==EndSeq )
             return BeginSeq;
          else
             return "";
          end;
       else
          if ( seq==EndAltSeq )
             return BeginSeq;
          else
             return "";
          end;
       end;
    end;

    macro RestoreSeq( _seq, alt )
       var seq = subStr( _seq, 1, SizeRstSeq() );
       if ( seq==BeginSeq )
          if ( alt==0 )
             return EndSeq;
          else 
             return EndAltSeq;
          end;
       else
          return "";
       end;
    end;

    Init( _BeginSeq, _EndAltSeq, _EndSeq );
end;

/* Набор последовательностей на RUR4 */
array SeqRUR4;
SeqRUR4(0)  = TSeqRUR4("YXYX", "YX", "ЫЬ");
SeqRUR4(1)  = TSeqRUR4("WXWX", "WX", "ЭЬ");
SeqRUR4(2)  = TSeqRUR4("QXQX", "QX", "ЮЬ");
SeqRUR4(3)  = TSeqRUR4("CXCX", "CX", "ЯЬ");
SeqRUR4(4)  = TSeqRUR4("AXAX", "AX", "АЬ");
SeqRUR4(5)  = TSeqRUR4("EXEX", "EX", "ЕЬ");
SeqRUR4(6)  = TSeqRUR4("IXIX", "IX", "ИЬ");
SeqRUR4(7)  = TSeqRUR4("OXOX", "OX", "ОЬ");
SeqRUR4(8)  = TSeqRUR4("UXUX", "UX", "УЬ");
SeqRUR4(9)  = TSeqRUR4( "WX" , "/" , "/" );
SeqRUR4(10) = TSeqRUR4( "QX" , "-" , "-" );
SeqRUR4(11) = TSeqRUR4( "CX" , ":" , ":" );
SeqRUR4(12) = TSeqRUR4( "AX" , "?" , "?" );
SeqRUR4(13) = TSeqRUR4( "EX" , "," , "," );
SeqRUR4(14) = TSeqRUR4( "IX" , "(" , "(" );
SeqRUR4(15) = TSeqRUR4( "OX" , ")" , ")" );
SeqRUR4(16) = TSeqRUR4( "UX" , "+" , "+" );

macro ValidateSymb( ch, CharSet )
  return index(CharSet,ch);
end;

macro ValidateSet( ch, TypeSet )
  if( TypeSet == TS_NUM )
    return ValidateSymb(ch, NumSet);
  elif( TypeSet == TS_ALPHA )
    return ValidateSymb(ch, AlphaSet);
  elif( TypeSet == TS_ALPNUM )
    return ValidateSymb(ch, AlphaNumSet);
  elif( TypeSet == TS_XSET )
    return ValidateSymb(ch, XSet);
  elif( TypeSet == TS_YSET )
    return ValidateSymb(ch, YSet);
  elif( TypeSet == TS_HEX )
    return ValidateSymb(ch, HexSet);
  elif( TypeSet == TS_SIGN )
    return ValidateSymb(ch, SignSet);
  elif( TypeSet == TS_BLANK )
    return ValidateSymb(ch, BlankSet);
  elif( TypeSet == TS_DIGIT ) /* проверка на число должна быть сложнее */
    return ValidateSymb(ch, DigitSet);
  elif( TypeSet == TS_RUSBIG )
    return ValidateSymb(ch, RusBigSet);
  elif( TypeSet == TS_XSETRUSBIG )
    return ValidateSymb(ch, XSetRusBig);
  elif( TypeSet == TS_ALLSET )
    return true;
  end;
end;

/* Транслитерация некторых последовательностей символов на RUR4 */
macro TransSeqRUR4
(
    srcStr,  /* Исходная последовательность */
    dstStr,  /* Создаваемая последовательность */
    Alt,     /* Флаг переключения клавиатуры */
    size     /* Размер переведенной исходной последовательность */
)
    var NSeq = asize(SeqRUR4), i, trsSeq, result = FALSE;
    i = 0;
    size = 0;
    while( i<NSeq )
        trsSeq = SeqRUR4(i).TranslateSeq(srcStr,Alt);
        if ( trsSeq!="" )
           size = SeqRUR4(i).SizeTrsSeq(Alt);
           dstStr = dstStr + trsSeq;
           i=NSeq;
           result = TRUE;
        else 
           i = i + 1;
        end;
    end;
    SetParm( 1, dstStr );
    SetParm( 3, size );
    return result;
end;

/* функция преобразования строки с одним набором символов в другой набор символов */
/* Используется для преобразования кирилицы в чарсеты SWIFT */
macro StrChangeCharset(
 srcStr, /* входной поток */
 srcSet, /* входной чарсет */
 dstStr, /* выходной поток */
 dstSet, /* выходной чарсет */
 AltChar,/* - символ переключения клавиатуры (по умалчанию "") */
 macroTransSeq, /* Макрос перевода последовательности */
 IsAltRus       /* выделять AltCharами русский текст (для НДЦ)*/
)

 /* поиск символа в чарсете */
 macro InCharset(
   ch:string, /* искомый символ */
   CharSet:string,   /* чарсет */
   n:integer,        /* позиция символа в чарсете */
   nlen:integer      /* длина строки перекодировки символа */
 )
   n = index( CharSet, ch );
   nlen = 1;

   if( n > 0 )
     /* установление длины строки перекодировки по количеству ведомых пробелов */
     while( TRUE )
       if( SubStr( CharSet, n+nlen, 1 ) == SYMB_BLANK )
         nlen = nlen + 1;
       else
         SetParm( 2, n );    /* передаем позицию символа в чарсете */
         SetParm( 3, nlen ); /* передаем длину строки перекодировки символа */
         return TRUE;        /* символ найден в чарсете */
       end;
     end;
   else
     return FALSE; /* символ не найден в чарсете */
   end;

 end; /* macro InCharset */

  macro IsDelimiter(ch:string) : bool
    return (ch==SYMB_BLANK) OR (ch=="\r") OR (ch==SYMB_ENDL) OR (ch=="\t");
  end;

  var srcLen = strlen(srcStr),
      dstSetlen = strlen(dstSet);

  // символ подлежит транслитерации
  macro MustBeTransl(ch : string) : bool
    var n : integer = 0, nlen : integer = 0;

    if( InCharset( ch, srcSet, n, nlen ) // есть в наборе исходных символов для транслитерации
        AND (n+nlen-1 <= dstSetLen) AND (SubStr(dstSet,n,nlen)!=AltChar) // эта проверка делается перед перекодировкой символа по выходному чарсету. Видимо, для чего-то нужна
      )
      // если перекодированный символ отличается от исходного
      if( SubStr(dstSet,n,nlen) != ch )
        return true;
      end;

      // это чтобы работал пример из ТЗ для SWIFT RUR
      /*
        :50К:/BE12345678900987
        'PHILIPS MARK'//'LOW STREET 7
        223344 BRUSSELS BELGIUM'//
      */
      if( (AltChar == RUR5_SETSWITCH) and (ch == "/") )
        return true;
      end;
    end;

    return false;
  end;


  var
  i = 1,
  ch:string,
  n=0,
  nlen=0,
  AltSwitch=0,
  size,j;

  if ( ValType(AltChar)==V_UNDEF )
     AltChar = string("");
  end;

  if ( ValType(IsAltRus)==V_UNDEF )
     IsAltRus = false;
  end;

  
  dstStr = "";

  while( i <= srcLen )
    ch = SubStr( srcStr, i, 1 );
    
    if(not IsAltRus)
      if ( (AltSwitch==1) AND (ValidateSet( StrUpr(ch), TS_RUSBIG ) or MustBeTransl(ch)) )
        AltSwitch=0;
        dstStr = dstStr + AltChar;
      elif( (AltSwitch==0) AND (ValidateSet( StrUpr(ch), TS_ALPHA )) )
        AltSwitch=1;
        dstStr = dstStr + AltChar;
      end;
    else
      if ( (AltSwitch==0) AND (ValidateSet( StrUpr(ch), TS_RUSBIG )) )
        AltSwitch=1;
        dstStr = dstStr + AltChar;
      elif( (AltSwitch==1) AND (ValidateSet( StrUpr(ch), TS_ALPHA )) )
        AltSwitch=0;
        dstStr = dstStr + AltChar;
      end;
    end;

    if ( (valtype(macroTransSeq)!=V_UNDEF) AND (macroTransSeq!="") AND (ExecMacro2(macroTransSeq,SubStr(srcStr,i),dstStr,AltSwitch,size)==TRUE) )
       i = i + size;
    else
       if( (ch != SYMB_BLANK) AND ((ch!=AltChar) or (not IsAltRus)) AND InCharset( ch, srcSet, n, nlen )
           AND ( not AltChar or ((ch != ")") and (ch != "}") and (ch != "\"") or IsAltRus) )
           AND (n+nlen-1 <= dstSetLen) AND (SubStr(dstSet,n,nlen)!=AltChar) )
         /* перекодируем по выходному чарсету */
         dstStr = dstStr + SubStr(dstSet,n,nlen);
       elif ( IsDelimiter(ch)
              OR (AltChar and ((ch == ")") or (ch == "}") or (ch == "\"")) and not IsAltRus) )
         if( AltSwitch==1 )
           if(not IsAltRus)
             j = i;

             while((not ValidateSet( StrUpr(ch), TS_ALPNUM/*TS_ALPHA*/ )) and (not ValidateSet( StrUpr(ch), TS_RUSBIG )) and (not (srcLen < j)))
               ch = SubStr( srcStr, j, 1 );
               if ( ValidateSet( StrUpr(ch), TS_RUSBIG ) or (srcLen <= j) )
                 AltSwitch = 0;
                 dstStr = dstStr + AltChar;
               end;
               j = j + 1;
             end;

             ch = SubStr( srcStr, i, 1 );
           else
             j = i;

             while((not ValidateSet( StrUpr(ch), TS_ALPNUM/*TS_ALPHA*/ )) and (not ValidateSet( StrUpr(ch), TS_ALPHA )) and (not (srcLen < j)))
               ch = SubStr( srcStr, j, 1 );
               if ( ValidateSet( StrUpr(ch), TS_ALPHA ) )
                  AltSwitch = 0;
                  dstStr = dstStr + AltChar;
               end;
               j = j + 1;
             end;

             ch = SubStr( srcStr, i, 1 );
           end;
         end;
         
         if( not IsDelimiter(ch) and not IsAltRus AND InCharset(ch, srcSet, n, nlen) )
           ch = SubStr(dstSet,n,nlen);
         end;
         dstStr = dstStr + ch;
       elif ( (ValidateSet( ch, TS_XSET )) AND (ch!=AltChar) )
         dstStr = dstStr + StrUpr(ch);
       end;
       i = i + 1;
    end;
  end;

  if ( AltSwitch==1 ) dstStr = dstStr + AltChar; end;
  SetParm( 2, dstStr ); /* передаем выходной поток */

end; /* macro StrChangeCharset */

/* Функция преобразования кирилицы в X-set SWIFT */
/* Передаваемые параметры */
/* 1. srcStr - входной поток (обязательный) */
/* 2. dstSrc - выходной поток (обязательный) */
macro StrChangeRusXSet( srcStr, dstSrc, standart, IsSwitchRus, passVOCode )
  if ( (valtype(standart)==V_UNDEF) OR (standart==ST_UNDEF) );
     StrChangeCharset( srcStr, RusSet, dstSrc, RusXSet );
  elif ( standart==ST_NONTR );
     dstSrc = srcStr;
  elif ((standart==ST_RUR5) OR (standart==ST_RUR6))
     srcStr = Trim(StrUpr(srcStr));
     var VOCode = "";
     if(passVOCode)
       // указан ли в начале исходной строки код вида 
       // {VOnnnnn} или {VOnnnnnPSnnnnnnnn/nnnn/nnnn/n/n}
       if( (SubStr(srcStr, 1, 3) == "{VO") and
           ( (SubStr(srcStr, 9, 1) == "}") or (SubStr(srcStr, 33, 1) == "}") )
         )
         var ind = index(srcStr, "}");
         VOCode = "'(VO" + SubStr(srcStr, 4, ind - 4) + ")'";
         srcStr = SubStr(srcStr, ind + 1);
       end;
     end;
     StrChangeCharset( srcStr, RusRUR5Set, dstSrc, RusRUR5XSet, RUR5_SETSWITCH, NULL, IsSwitchRus);
     dstSrc = VOCode + dstSrc;
  elif (standart==ST_RUR4)
     srcStr = StrUpr(srcStr);
     StrChangeCharset( srcStr, RusRUR4Set, dstSrc, RusRUR4XSet, RUR4_SETSWITCH, "TransSeqRUR4" );
  else
     StrChangeCharset( srcStr, RusSet, dstSrc, RusXSet );
  end;
  SetParm( 1, dstSrc );
end; /* macro StrChangeRusXSet */

/* Макрос проверки и доработки места разрыва слова по стандарту RUR4 */
/* Возвращает количество символов на который следует перенести перенос в лево */
macro CheckBreakRUR4( Str,  /* Строка */
                      ind ) /* Номер символа в строке после которого должен быть разрыв */
   var size = asize(SeqRUR4), i, j, SizeSeq, Sequence, continue0 = 1;
   /* Проверим, что бы не было развыров в "кодовых" последовательностях */
   i = -1;
   while( i<size )
      if ( i<0 )         
        Sequence = RUR4_SETSWITCH;
      else
        Sequence = SeqRUR4(i).BeginSeq;
      end;
      SizeSeq = strlen(Sequence);
      if ( SizeSeq>1 )
          j = 1;
          continue0 = 1;
          while( continue0 AND (j <= SizeSeq) )
             if ( subStr(Str, ind-j+1, SizeSeq)==Sequence )
                continue0 = 0;
                i = size;
             else
                j = j + 1;
             end;
          end;
      end;
      i = i+1;
   end;
   if ( continue0==0 )
      return j;
   else
      return 0;
   end;
end;

macro StrMultyToFormatExt(
   mltStr,    /* многострочное поле */
   frmStr,    /* форматированное поле - фиксированный сегмент */
   frmWidth,  /* ширина сегмента */
   frmHeight, /* высота сегмента */
   Stat,      /* массив индексов в исходной строке,
                 после которых нельзя cтавить перенос */
   macroCheckBreak /* Необязательный параметр: макрос проверки места разрыва слова */
   )
   var sizeStat = Asize( Stat ), shift,
   i = 0,
   j = 0,
   fW = 0, /* количество символов в текущей строке */
   fH = 0, /* количество считанных строк в форм. поле */
   mLen = StrLen(mltStr),
   ch:string,
   count = 0,
   loop = TRUE;
   frmStr = "";

   while( (loop==TRUE) AND (i<mLen) )
      ch = SubStr( mltStr, i+1, 1 );
      if ( (ch == SYMB_BLANK) OR (ch == SYMB_ENDL) )
         if ( ch == SYMB_ENDL )
            if ( fH < frmHeight-1 )
               frmStr = frmStr + ch;
            end;
            fW = 0;
            fH = fH + 1;
            i = i + 1;
         else
            frmStr = frmStr + ch;
            i = i + 1;
            fW = fW + 1;
            if ( (fW == frmWidth) and (SubStr( mltStr, i+1, 1 ) != SYMB_ENDL))
                frmStr = frmStr + SYMB_ENDL;
                fW = 0;
                fH = fH + 1;
            end;
         end;
      else
         j = i+1;
         ch = SubStr( mltStr, j+1, 1 );
         while( (ch != SYMB_BLANK) AND (ch != SYMB_ENDL) AND (j<mLen) )
            j = j+1;
            ch = SubStr( mltStr, j+1, 1 );
         end;
         if ( fW + (j-i) <= frmWidth )
            frmStr = frmStr + SubStr( mltStr, i+1, j-i );
            fW = fW + j - i;
            if ( (fW == frmWidth) and (SubStr( mltStr, j+1, 1 ) != SYMB_ENDL) )
                frmStr = frmStr + SYMB_ENDL;
                fW = 0;
                fH = fH + 1;
            end;
         elif ( ((j-i)<=frmWidth) AND ( (count >= sizeStat) OR (Stat(count)==0) ) )
            Stat(count) = 0;
            count = count + 1;
            sizeStat = Asize( Stat );
            frmStr = frmStr + SYMB_ENDL;
            fH = fH + 1;
            j = i;
            fW = 0;
         elif ( ((j-i)<=frmWidth) AND (Stat(count)==1) )
            count = count + 1;
            if ( (valtype(macroCheckBreak)!=V_UNDEF) AND (macroCheckBreak!="") )
                shift = ExecMacro2( macroCheckBreak, mltStr, i + frmWidth - fW );
            else shift = 0;
            end;
            frmStr = frmStr + SubStr( mltStr, i+1, frmWidth - fW - shift);
            frmStr = frmStr + SYMB_ENDL;
            j = i + frmWidth - fW - shift;
            fH = fH + 1;
            fW = 0;
         else
            if ( (valtype(macroCheckBreak)!=V_UNDEF) AND (macroCheckBreak!="") )
                shift = ExecMacro2( macroCheckBreak, mltStr, i + frmWidth - fW );
            else shift = 0;
            end;
            frmStr = frmStr + SubStr( mltStr, i+1, frmWidth - fW - shift );
            frmStr = frmStr + SYMB_ENDL;
            j = i + frmWidth - fW - shift;
            fH = fH + 1;
            fW = 0;
         end;
         i = j;
      end;
      if ( fH == frmHeight )
         loop = FALSE;
      end;
   end;
   /* Если последний символ - символ перехода строки и заполнены все строки, 
      то удаляем этот символ                                                 */
   if ( (SubStr(frmStr, strlen(frmStr), 1)==SYMB_ENDL) AND (fH==frmHeight) )      
      frmStr = SubStr(frmStr, 1, strlen(frmStr)-1);
   end;
   SetParm( 1, frmStr );
   return mLen - i;
end;

/* Макрос делает массив Stat по Code */
/* Возвращает число разрывов слов (единиц в Stat) */
macro MadeStatFromCode( Stat, Code:integer )
   var i=0;
   var break0 = 0;
   while( i < Asize(Stat) )
      Stat(i) = Code - (int(Code/2))*2;
      Code = int (Code / 2);
      break0 = break0 + Stat(i);
      i = i + 1;
   end;
   return break0;
end;

/* Данный макрос раставляет переносы таким образом, что бы при
   минимальном количестве разрывов в словах в сегмент вмещалось
   максимальное количество символов строки mltStr (BARS 19.10.99)
   ( Применяется для высоты сегмента менее 20 строк, иначе
     применять функцию StrMultyToFormatQuick )                   */
macro StrMultyToFormatBest(
  mltStr,    /* многострочное поле */
  frmStr,    /* форматированное поле - фиксированный сегмент */
  frmWidth,  /* ширина сегмента */
  frmHeight, /* высота сегмента */
  macroCheckBreak /* Необязательный параметр: макрос проверки места разрыва слова */
)
   var N, loop = TRUE, Size;
   var Code : integer, R_Code : integer;
   var min_ost, ost, R_break = 0, break0 = 0;
   array Stat;
   Code = 0;
   R_Code = 0;
   min_ost = StrLen( mltStr );
   ost = min_ost;
   while( loop )
      N = StrMultyToFormatExt( mltStr, frmStr, frmWidth, frmHeight, Stat, macroCheckBreak );
      Size = Asize(Stat);

      if ( N < min_ost )
         min_ost = N;
         R_Break = break0;
         R_Code = Code;
      elif ( (N == min_ost) AND (break0<R_Break) )
         R_Break = break0;
         R_Code = Code;
      end;

      if ( (R_Break == 0) AND (min_ost == 0) )
         loop = FALSE;
      else
         Code = Code + 1;
         if ( Code == Pow( 2, Size ) )
            loop = FALSE;
         else
            break0 = MadeStatFromCode( Stat, Code );
         end;
      end;

   end;
   if ( Code != R_Code )
      MadeStatFromCode( Stat, R_Code );
      N = StrMultyToFormatExt( mltStr, frmStr, frmWidth, frmHeight, Stat, macroCheckBreak );
   end;
   SetParm( 1, frmStr );
   return SubStr( mltStr, StrLen(mltStr)-N+1, N );
end;

/* Данный макрос раставляет переносы таким образом, что бы сегмент вмещалось
   максимальное количество символов строки mltStr (BARS 11.11.99), при этом
   число разрывов в словах меньше или равно максимальному возможному количеству.
   ( Имеет смысл для высоты сегмента более 15 строк, иначе лучше
     применять функцию StrMultyToFormatBest )                   */
macro StrMultyToFormatQuick(
  mltStr,    /* многострочное поле */
  frmStr,    /* форматированное поле - фиксированный сегмент */
  frmWidth,  /* ширина сегмента */
  frmHeight, /* высота сегмента */
  macroCheckBreak /* Необязательный параметр: макрос проверки места разрыва слова */
)
   var N, loop = TRUE, Size, i;
   array Stat;

   while( loop )
      N = StrMultyToFormatExt( mltStr, frmStr, frmWidth, frmHeight, Stat, macroCheckBreak );
      Size = Asize(Stat);

      if ( N == 0 )
         /* Строка полностью вместилась */
         loop = false;
      else
         i = 0;
         while( (i<Size) AND Stat(i)==1 )
            i = i + 1;
         end;
         if ( i == Size )
            /* Везде где только можно уже поставлены разрывы, но строка не влезла */
            loop = false;
         else
            Stat( i ) = 1;
         end;
      end;
   end;
   SetParm( 1, frmStr );
   return SubStr( mltStr, StrLen(mltStr)-N+1, N );
end;

macro StrMultyToFormat(
  mltStr,    /* многострочное поле */
  frmStr,    /* форматированное поле - фиксированный сегмент */
  frmWidth,  /* ширина сегмента */
  frmHeight, /* высота сегмента */
  macroCheckBreak /* Необязательный параметр: макрос проверки места разрыва слова */
)
  var strOst;
  if ( strlen(mltStr)>frmWidth*12 )
     strOst = StrMultyToFormatQuick( mltStr, frmStr, frmWidth, frmHeight, macroCheckBreak );
  else 
     strOst = StrMultyToFormatBest( mltStr, frmStr, frmWidth, frmHeight, macroCheckBreak );
  end;
  SetParm( 1, frmStr );
  return strOst;
end;

macro StrmGetLexeme(
  Stream,
  Count,
  StrBuf,
  TypeSymb,
  TypeLen,
  Len1,
  Len2
)
 var i = 0, /* кол-во символов в строке */
     n = 0, /* кол-во строк */
     c = 0, /* кол-во считанных символов */
     loop = TRUE,
     ch = "";

 StrBuf = "";

 /* фиксированная длина */
 if( TypeLen == TL_FIXED )
   while( i < Len1 )
     ch = SubStr(Stream, Count+i, 1);
     if( ValidateSet(ch, TypeSymb) )
       StrBuf = StrBuf + ch;
       i = i + 1;
     else
       SetParm( 2, "" );    /* return StrBuf */
       return FALSE;
     end;
   end;
   Count = Count + i;
   SetParm( 1, Count ); /* return Count */ /* запись в 1-й аргумент!*/
   SetParm( 2, StrBuf );    /* return StrBuf */
   return TRUE;

 /* максимальная длина */
 elif( TypeLen == TL_MAX )
   while( loop AND (i < Len1) )
     ch = SubStr(Stream, Count+i, 1);
/*     ParsStrLog("StrmGetLexeme i + ch: "+string(i)+" "+ch);*/
     if( ValidateSet(ch, TypeSymb) )
       StrBuf = StrBuf + ch;
       i = i + 1;
     else
       loop = FALSE;
     end;
   end;
   Count = Count + i;
   SetParm( 1, Count ); /* return Count */ /* запись в 1-й аргумент!*/
   SetParm( 2, StrBuf );    /* return StrBuf */
   return TRUE;

 /* максимальное кол-во строк на макс. длину строки */
 elif( TypeLen == TL_BLOCK )
   i = 0;
   n = 0;
   c = 0;
   while( loop AND (n < Len1) AND (i <= Len2) )
     ch = SubStr(Stream, Count+c, 1);
     if((ch == SYMB_ENDL) OR (ch == ""))
       i = 0;
       n = n + 1;
       if(ch != "")
         StrBuf = StrBuf + ch;
         c = c + 1;
       end;
     elif( ValidateSet(ch, TypeSymb) )
       StrBuf = StrBuf + ch;
       i = i + 1;
       c = c + 1;
       /* проверка на слишком длинные строки */
       ch = SubStr(Stream, Count+c, 1);
       if( (i == Len2) AND (ch != "") AND (ch != SYMB_ENDL) )
/*         ParsStrErr(1,"Строка "+string(n+1)+" превышает "+string(Len2)+" символа!");*/
         return FALSE;
       end;
     else
       loop = FALSE;
     end;
   end;
/*   ParsStrLog(3, "StrmGetLexeme TL_BLOCK: "+string(Count)+" + "+string(c)+" = "+string(Count+c));*/
   Count = Count + c;
   SetParm( 1, Count ); /* return Count */ /* запись в 1-й аргумент!*/
   SetParm( 2, StrBuf );    /* return StrBuf */
   return TRUE;

 /* минимальная и макс. длина строки */
 elif( TypeLen == TL_RANGE )
 end;

end;

/***************************************************************************/
/* Разбить исходную строку source на nstr подстрок длиной len              */
/* и записать в массив dest                                                */
/***************************************************************************/
macro РазбитьНаСтроки( source, dest, len, nstr )
  var slen = strlen(source),
      i = 0,
      n = 1, ns,nl,
      ln = 0,
      ch = "";
  asize(dest,0);
  if(valtype(nstr)!=V_INTEGER)
    nstr = 65535;
  end;
  while( i < nstr )
    if(n>slen)
      if(nstr == 65535)
        i = 65535;
      else
        dest(i) = "";
      end;
    else
      ns = 0;
      ch = " ";
      while( (ns <= len) AND (ch != "\n") AND (ch != "") )
        ch = substr( source, n+ns, 1 );
        ns = ns + 1;
      end;
      if( (ns>=len) AND (ch != "\n") AND (ch != "") )
        nl = ns;
//        ns = ns - 1;
      else
        nl = ns-1;
      end;
      dest(i) = substr(source, n, nl);
      n = n + ns;// + 1;
    end;
    i = i + 1;
  end;
end; /* macro РазбитьНаСтроки */

/*
Pad = 
1 - Именительный
2 - Родительный
3 - Дательный
4 - Винительный
5 - Творительный
6 - Предложный
*/
macro ПолучитьМесяцПоПадежу(Number, Pad)      
   var mon;
   mon = MonName(Number);
   if (not mon)
      return mon; 
   end;
   if (Pad == 2)                                        
      if ((SubStr(mon, strlen(mon)) == "ь") or (SubStr(mon, strlen(mon)) == "й")) 
         StrSet(mon,strlen(mon), "я");
      else
         mon = string(mon, "а");
      end;
   end;
   if (Pad == 3)                                        
      if ((SubStr(mon, strlen(mon)) == "ь") or (SubStr(mon, strlen(mon)) == "й")) 
         StrSet(mon,strlen(mon), "ю");
      else
         mon = string(mon, "у");
      end;
   end;
   if (Pad == 5)                                        
      if ((SubStr(mon, strlen(mon)) == "ь") or (SubStr(mon, strlen(mon)) == "й")) 
         StrSet(mon,strlen(mon), "е");
         mon = string(mon, "м");
      else
         mon = string(mon, "ом");
      end;
   end;
   if (Pad == 6)                                        
      if ((SubStr(mon, strlen(mon)) == "ь") or (SubStr(mon, strlen(mon)) == "й")) 
         StrSet(mon,strlen(mon), "е");
      else
         mon = string(mon, "е");
      end;
   end;
   return mon;
end; 

macro GetllValueElement( List, CodeOrElement, error )
    var select:string;
    var rs:object;
    var params:TArray;

    if ( valtype(codeOrElement)==V_INTEGER )
       select = "select t_Code from dllvalues_dbt where t_List=:List and t_Element=:codeOrElement";       
       params = makeArray( SQLParam("List", List  ),
                           SQLParam("codeOrElement", codeOrElement));
       rs = execSQLselect( select, params, FALSE );
       if ( rs.MoveNext() )
          SetParm( 2, 0 );
          return rs.value(0);
       else
          SetParm( 2, 1 );
          return "";
       end;
    elif ( valtype(codeOrElement)==V_STRING )
       select = "select t_Element from dllvalues_dbt where t_List=:List and t_Code=:codeOrElement";
       params = makeArray( SQLParam("List", List  ),
                           SQLParam("codeOrElement", codeOrElement));
       rs = execSQLselect( select, params, FALSE );
       if ( rs.MoveNext() )
          SetParm( 2, 0 );
          return rs.value(0);
       else
          SetParm( 2, 1 );
          return -1;
       end;
    else
        SetParm( 2, 1 );
    end;
end;

macro GetFormIDByName(InitFormName, TpID)
  var select:string;
  var rs:object;
  var params:TArray;

  select = "select t_FormID from dwlmesfrm_dbt where t_Name=:Name and t_TpID=:TpID";       
  params = makeArray( SQLParam("Name", InitFormName  ),
                      SQLParam("TpID", TpID));
  rs = execSQLselect( select, params, FALSE );
  if ( rs.MoveNext() )
    return rs.value(0);
  else
    select = "select t_FormID from dwlmesfrm_dbt where t_Name=:Name";       
    params = makeArray( SQLParam("Name", InitFormName));
    rs = execSQLselect( select, params, FALSE );
    if ( rs.MoveNext() )
      return rs.value(0);
    else
      return 0;
    end;
  end;

  return 0;
end;

macro GetFormIDByRlsID(RlsFormID : integer) : integer
  var strSQL : string = "select rls.t_FormID " +
                        "  from dwlmesrls_dbt rls" +
                        " where rls.t_RlsFormID = :RlsFormID ";

  var rs = execSQLselect( strSQL, makeArray( SQLParam("RlsFormID", RlsFormID) ) );

  if ( rs and rs.moveNext() )
    return rs.value(0);
  end;

  return 0;
end;

MACRO GetElementAndNoteLLVALUES(List, Code, Element, Note, Name)
  var select:string;
  var rs:object;
  var params:TArray;
  
  select = "select t_Element, t_Note, t_Name from dllvalues_dbt where t_List=:List and t_Code=:Code";
  params = makeArray( SQLParam("List", List  ),
                      SQLParam("Code", Code  ));
  rs = execSQLselect( select, params, FALSE );
  if ( rs.MoveNext() )
    SetParm( 2, rs.value(0));
    SetParm( 3, rs.value(1));
    SetParm( 4, rs.value(2));
    return true;
  else
    return false;
  end;
END;

//Возвращает код субъекта (в формате <код>(<вид кода>) ), заданный по умолчанию для данного вида транспорта 
//Параметры - транспортная схема, PartyID
macro ПолучитьКодСубъектаПоУмолчанию(TpShemID, PartyID): string
  var rset:object = NULL;
  var query:string;

  query = " SELECT objcode.t_Code, objkcode.t_Name"
           " FROM"
           "   dwltpshem_dbt tpshem,"
           "   dwltpcode_dbt wltpcode,"
           "   dobjcode_dbt objcode,"
           "   dobjkcode_dbt objkcode "
           " WHERE"
           "   tpshem.t_TpShemID(+) = ? AND"
           "   wltpcode.t_TpID(+) = tpshem.t_TpID AND"
           "   wltpcode.t_Primary(+) = 'X' AND"
           "   objcode.t_CodeKind = NVL(wltpcode.t_CodeKind, 3) AND "
           "   objcode.t_ObjectID = ? AND"
           "   objcode.t_ObjectType = ? AND"
           "   objcode.t_State = 0 AND"
           "   objkcode.t_ObjectType = objcode.t_ObjectType AND"
           "   objkcode.t_CodeKind = objcode.t_CodeKind";
           

  var params:TArray = makeArray( SQLParam( "", TpShemID ), 
                                   SQLParam( "", PartyID ),
                                   SQLParam( "",OBJTYPE_PARTY)); 

  rset = execSQLselect( query, params, TRUE );                               

  if( rset and rset.moveNext() )
     return string(rset.value(0)) + " (" + string(rset.value(1)) + ") ";
  else
    return "";
  end;

end;

macro ПолучитьОписаниеЗапросаОтвета(wlreq) : string
  var Narrative = "",   // поле "Описание" в панели запроса/ответа
      Description = ""; // поле "Дополнительная информация" в панели запроса/ответа
  ПрочитатьТекстЗапроса_Ответа(wlreq, Narrative, Description);
  return Narrative;
end;

macro IsLinkedWlreq
( ReqID : integer, 
  ObjID : integer, 
  ObjKind : integer, 
  ObjDirect : string
) : bool

  var s = "select 1 " +
          "  from dwlreqlnk_dbt " +
          " where t_ReqID     = :ReqID " +
          "   and t_ObjID     = :ObjID " +
          "   and t_ObjKind   = :ObjKind " +
          "   and t_ObjDirect = " + IfThenElse(ObjDirect == "X", " 'X' ", " chr(0) ");

  var params = makeArray( SQLParam("ReqID", ReqID),
                          SQLParam("ObjID", ObjID),
                          SQLParam("ObjKind", ObjKind) );

  var rs : RsdRecordset = execSQLselect(s, params);

  if(rs and rs.moveNext())
    return TRUE;
  end;

  return FALSE;
end;

macro GetFldValue( MesID, FieldName )
    var query:string = "select val.T_VALUE " +
                        " from dwlmesval_dbt val, " +
                             " dwltpfld_dbt  fld  " +
                       " where val.t_MesID = :MesID " +
                        " and fld.t_TpFieldID = val.t_TpFieldID " +
                        " and fld.t_Name = :FieldName " + 
                        " order by val.t_index";

    var params:TArray = makeArray( SQLParam( "MesID"    , MesID ), 
                                   SQLParam( "FieldName", FieldName ) );

    var rs:RsdRecordset = execSQLselect( query, params, true );

    if( rs.moveNext() )
      return rs.value(0);
    else
      return "";
    end;
end;

macro GetPartyCode( PartyID:integer, CodeKind:integer ):string
  var params:TArray = NULL;
  var retval:integer = 0;
  params = makeArray( SQLParam( "p_PartyID"    , PartyID              ),
                      SQLParam( "p_CodeKind"   , CodeKind             ),
                      SQLParam( "p_Code"       , V_STRING , RSDBP_OUT ),
                      SQLParam( "p_CodeOwnerID", V_INTEGER, RSDBP_OUT )
                    );
  retval = execStoredFunc( "RSI_RSBPARTY.PT_GetPartyCodeEx", V_INTEGER, params );
  if( retval == 0 )
    return params.Value(2).value;
  end;
  return "";
end;

macro GetPartyCodeOnDate( PartyID:integer, CodeKind:integer, OnDate:date ):string
  var params:TArray = NULL;
  var retval:string = "";
  params = makeArray( SQLParam( "p_PartyID"    , PartyID              ),
                      SQLParam( "p_CodeKind"   , CodeKind             ),
                      SQLParam( "p_Date"       , OnDate               ),
                      SQLParam( "p_Owner"      , V_INTEGER, RSDBP_OUT )
                    );
  retval = execStoredFunc( "RSI_RSBPARTY.GetPartyCodeOnDate", V_STRING, params );
  return retval;
end;

// Находит первое вхождение какого-л. кода из справочника algnum в строке search_str
// Если ничего не находит, возвращает 0, иначе номер символа в строке search_str
macro index_wlcode(search_str : string, algnum : integer, code_found : @string) : integer
  code_found = "";
  var ind : integer = 0;

  var select = "select t_code from dwlcodes_dbt where t_algnum = :algnum";
  var rs = execSQLselect( select, makeArray( SQLParam("algnum", algnum) ), false );
  while( rs and rs.MoveNext() )    
    ind = Index(search_str, rs.value(0));
    if( ind )
      code_found = rs.value(0);
      return ind;
    end;
  end;

  return 0;
end;

macro getTpIDofTpSchem(TpSchemID : integer): integer
  var strSQL = "Select t_TpID from dwltpshem_dbt where t_TpShemID = :TpSchemID";
  var rs : RsdRecordset = execSQLselect( strSQL, 
                                         makeArray( SQLParam("TpSchemID", TpSchemID) ) );
  if(rs and rs.moveNext)
    return rs.value(0);
  end;
  return 0;
end;

macro GetWlcodeDescription(AlgNum : integer, Code : string) : string
  var select = "Select t_Description " +
               "  from dwlcodes_dbt " +
               " where t_AlgNum = :AlgNum " +
               "   and t_Code = :Code ";
  var params = makeArray( SQLParam("AlgNum", AlgNum),
                          SQLParam("Code",   Code) );
  var rs = execSQLselect(select, params);
  if(rs and rs.moveNext)
    return rs.value("t_Description");
  end;

  return "";
end;

macro StrSplit2ByDelimiter (source:string, delimiter:string) : TArray
  var arr : TArray = TArray();

  var delim_pos = 0, item_str = "";
  source = StrSubst(source, "\n", delimiter);
  while (source)
    delim_pos = index(source, delimiter);
    if (delim_pos)
      item_str = substr(source, 1, delim_pos - 1);
      source   = substr(source, delim_pos + 1);
    else
      item_str = source;
      source   = "";
    end;
    item_str = Trim(item_str);
    if(item_str)
      arr[ arr.size ] = item_str;
    end;
  end;

  return arr;
end;

/*
    Как использовать:

  1. Создать кдасс-наследник
  2. Переопределить метод OnProcessRecord
      2.1. Чтобы передать данные в OnProcessRecord или получить данные оттуда, можно 
    использовать данные-члены класса-наследника
      2.2. Если внутри OnProcessRecord становится ясно, что оставшиеся записи можно
    не обрабатывать, то вызвать метод Finish
  3. Создать экземпляр класса-наследника и вызвать для него метод Go

*/
CLASS TRsbAddFldIterator(p_AddFldObj : RsbAddFld)

  private var AddFldObj : RsbAddFld = p_AddFldObj,
              IsFinished : bool = false;

  private macro OnProcessRecord(FldRec : TRecHandler)
    PureVirtualFunc();
  end;

  macro Finish()
    IsFinished = true;
  end;

  macro Go()
    var AddFldRec : TRecHandler = TRecHandler("wladdfld.dbt");
    var stat : integer = 0;

    IsFinished = false;
    stat = AddFldObj.First(AddFldRec);

    while(not stat and not IsFinished)
      OnProcessRecord(AddFldRec);

      if(not IsFinished)
        stat = AddFldObj.Next(AddFldRec);
      end;
    end;
  end;

END;

/* Определяет принадлежит ли счет нашему банку или нет */
macro IsOwnerAccOwnBank( bankCode, FIID, acc )  
  FILE wlaccount( account ) key 0;

   if ( Trim(bankCode)=={MFO_Bank} )
      ClearRecord(wlaccount);
      wlaccount.Chapter = 1;
      wlaccount.Code_Currency = FIID;
      wlaccount.Account = Trim(acc);         
      if ( getEQ(wlaccount) )            
         if ( (wlaccount.Client=={OurBank}) OR (wlaccount.Client==0) )
            return true;               
         end
      end;
   end;
   return false;
end;

macro GetObjIDByMesLink(MesID : integer, ObjKind : integer, Direct : string) : integer
  var q : string =
    "select t_ObjID "
    "  from dwlmeslnk_dbt "
    " where t_MesID = :MesID "
    "   and t_ObjKind = :ObjKind ";

  if(Direct != null)
    if(Direct == "X")
      q = q + " and t_Direct = 'X' ";
    else
      q = q + " and t_Direct = chr(0) ";
    end;
  end;

  var params : TArray = makeArray( SQLParam("MesID", MesID),
                                   SQLParam("ObjKind", ObjKind) );

  var rs : RsdRecordset = execSQLselect(q, params);

  if(rs and rs.moveNext())
    return rs.value("t_ObjID");
  end;

  return 0;
end;

macro FindWldMesByLink
( ObjID : integer, 
  ObjKind : integer, 
  Direct : string, // "X" или ""
  wlmes  // RECORD, TRecHandler
) : bool

  var rs = execSQLselectPrm
  ( "Select mes.* "
    "  from dwlmeslnk_dbt lnk, dwlmes_dbt mes "
    " where lnk.t_ObjID = :ObjID "
    "   and lnk.t_ObjKind = :ObjKind "
    "   and lnk.t_Direct = " + IfThenElse(Direct == "X", "'X' ", "chr(0) ") +
    "   and mes.t_MesID = lnk.t_MesID "
    " order by mes.t_MesID desc ",

    SQLParam("ObjID", ObjID),
    SQLParam("ObjKind", ObjKind)
  );

  if(rs and rs.moveNext())
    CopyRSetToFBuff(wlmes, rs);
    return TRUE;
  end;

  return FALSE;
end;

macro FindWldMesByPaym
( PaymentID : integer, 
  Direct : string, // "X" или ""
  TpID : integer, // м.б. 0
  wlmes // RECORD, TRecHandler

) : bool

  var query : string = 
    "Select mes.* "
    "  from dwlpm_dbt wlpm, dwlmeslnk_dbt lnk, dwlmes_dbt mes " + 
    IfThenElse(TpID, ", dwltpshem_dbt tpshem ", "") +
    " where wlpm.t_PaymentID = :PaymentID "
    "   and wlpm.t_WlPmNum = 0 "
    "   and lnk.t_ObjID = wlpm.t_WlPmID "
    "   and lnk.t_ObjKind =  " + OBJTYPE_PAYMENT +
    "   and lnk.t_Direct = " + IfThenElse(Direct == "X", "'X' ", "chr(0) ") +
    "   and mes.t_MesID = lnk.t_MesID " +
    IfThenElse( TpID, "and tpshem.t_TpShemID = mes.t_TpSchemID "
                      "and tpshem.t_TpID = :TpID ",
                      ""
              ) +
    " order by mes.t_MesID desc ";
  var params : TArray = makeArray( SQLParam("PaymentID", PaymentID) );
  if(TpID)
    params[params.size] = SQLParam("TpID", TpID);
  end;

  var rs = execSQLselect(query, params);
  if(rs and rs.moveNext())
    CopyRSetToFBuff(wlmes, rs);
    return TRUE;
  end;

  return FALSE;
end;

macro GetTpFrmtIDBySessID(SessID : integer) : integer
  var TpFrmtID : integer = 0;

  var q : string = "select t_TpFrmtID "
                   "  from dwlsess_dbt "
                   " where t_SessionID = :SessID ";
  var rs : RsdRecordset = execSQLselect( q, makeArray( SQLParam("SessID", SessID) ) );
  if(rs and rs.moveNext())
    TpFrmtID = rs.value("t_TpFrmtID");
  else
    RunError("Не найден сеанс экспорта/импорта с ИД = " + SessID);
  end;

  return TpFrmtID;
end;

macro GetFormatFileBySess(Sess : variant) : integer
  var FormatFile : integer = -1;

  var TpFrmtID : integer = 0;

  if( ValType(Sess) == V_INTEGER )
    TpFrmtID = GetTpFrmtIDBySessID(Sess);
  elif( (ValType(Sess) == V_STRUC) or (ValType(Sess) == V_FILE) )
    TpFrmtID = Sess.TpFrmtID;
  elif( (ValType(Sess) == V_GENOBJ) and
        (IsEqClass("TRecHandler", Sess) or IsEqClass("TbFile", Sess))
      )
    TpFrmtID = Sess.rec.TpFrmtID;
  else
    RunError("Ошибка программирования: неверный тип параметра Sess");
  end;

  var q : string = "select t_FormatFile "
                   "  from dwltpfrmt_dbt "
                   " where t_TpFrmtID = :TpFrmtID ";
  var rs : RsdRecordset = execSQLselect(q, makeArray( SQLParam("TpFrmtID", TpFrmtID) ));
  if(rs and rs.moveNext())
    FormatFile = rs.value("t_FormatFile");
  else
    RunError("Не найден формат транспорта " + TpFrmtID);
  end;

  return FormatFile;
end;

macro GetSessBankDate(wlmes) : date
  var rs = execSQLselect( "select t_BankDate " +
                          "  from dwlsess_dbt " +
                          " where t_SessionID = :SessionID ",
                          makeArray( SQLParam("SessionID", wlmes.SessionID) )
                        );

  if(rs and rs.moveNext())
    return date(rs.value(0));
  end;

  return date(0, 0, 0);
end;

macro GetSessSysDate(wlmes) : date
  var rs = execSQLselect( "select t_SysDate " +
                          "  from dwlsess_dbt " +
                          " where t_SessionID = :SessionID ",
                          makeArray( SQLParam("SessionID", wlmes.SessionID) )
                        );

  if(rs and rs.moveNext())
    return date(rs.value(0));
  end;

  return date(0, 0, 0);
end;

// Денежная сумма в копейках
macro MoneyKopStr(Amount : money) : string
  return string( (Amount * 100):0:0 );
end;

macro GetWlinfoStrID(InfoID : integer) : string
  RECORD wlinfo(wlinfo);
  wlinfo.InfoID = InfoID;

  return UniID(wlinfo, OBJTYPE_INFO);
end;

macro GetBICofCorschemDepartment(CorsNumber : integer, CorsFIID : integer): string
  var BIC = "";

  var rs : RsdRecordset = execSQLselect
                          ( "select dp.t_PartyID " +
                            "  from ddp_dep_dbt dp, dcorschem_dbt cs " +
                            " where cs.t_Number  = :Num " +
                            "   and cs.t_FIID    = :FIID " +
                            "   and cs.t_FI_Kind = :FI_Kind " +
                            "   and dp.t_Code    = cs.t_Department ",
                            makeArray( SQLParam("Num",  CorsNumber),
                                       SQLParam("FIID",    CorsFIID),
                                       SQLParam("FI_Kind", FIKIND_CURRENCY)
                                     )
                          );
  if(rs and rs.moveNext())
    var PartyID : integer = rs.value("t_PartyID");
    BIC = ПолучитьКодСубъекта (PartyID, PTCK_BIC);
  end;

  return BIC;
end;

/*********************************************************************/
/*            Вернуть ID платежа по сообщению                        */
/*********************************************************************/
macro GetMesPaymentID (MesID : integer) : integer
  var select : string = 
    " select wlpm.t_PaymentID  " +
    "   from dwlmeslnk_dbt lnk, dwlpm_dbt wlpm "+
    "  where lnk.t_MesID   = :MesID "+
    "    and lnk.t_ObjKind = :OBJTYPE_PAYMENT "
    "    and wlpm.t_WlPmID = lnk.t_ObjID ";

  var params : TArray = makeArray( SQLParam("MesID", MesID),
                                   SQLParam("OBJTYPE_PAYMENT", OBJTYPE_PAYMENT) );
  var rs : RsdRecordset = execSQLselect( select, params );
  if( rs.MoveNext() )
    return rs.value(0);
  end;

  return 0;
end;

macro GetAnswerIdLinkedWithRequest(RequestMesID : integer, AnswerState : @integer) : integer
  var s = "select wlreq.t_ReqID, wlreq.t_State "  
          "  from dwlreq_dbt wlreq, dwlmeslnk_dbt wlmeslnk, dwlreqlnk_dbt wlreqlnk " 
          " where wlmeslnk.t_MesID = :MesID " 
          "   and wlmeslnk.t_ObjKind = :ObjType " 
          "   and wlmeslnk.t_Direct = 'X' /* WLD_MES_IN */ "
          "   and wlreqlnk.t_ObjID = wlmeslnk.t_ObjID "
          "   and wlreqlnk.t_ObjKind = wlmeslnk.t_ObjKind "
          "   and wlreqlnk.t_ObjDirect = wlmeslnk.t_Direct "
          "   and wlreqlnk.t_ReqID = wlreq.t_ReqID "
          "   and wlreq.t_Kind = :MesKind ";

  var rs = execSQLselect( s, makeArray( SQLParam("MesID",   RequestMesID),
                                        SQLParam("ObjType", OBJTYPE_REQ),
                                        SQLParam("MesKind", MESKIND_ANSWER) )
                        );

  if(rs and rs.moveNext())
    AnswerState = rs.value("t_State");
    return rs.value("t_ReqID");
  end;

  return 0;
end;

macro GetOutMesIdInOperDprt(TpID, RefTrn : string) : integer
  var MesID : integer = 0;

  var select : string = 
    "select mes.t_MesID " +
    "  from dwlmes_dbt mes, dwltpshem_dbt tpshem " + 
    " where mes.t_Direct = chr(0) /* WLD_MES_OUT */ "+
    "   and mes.T_Department = :OperD "+
    "   and mes.t_TRN = :RefTrn "+
    "   and tpshem.t_TpShemID = mes.t_TpSchemID ";

  if( ValType(TpID) == V_INTEGER )
    select = select +
    "   and tpshem.t_TpID = :TpID ";
  else // TArray
    select = select +
    "   and tpshem.t_TpID in ( " + join(TpID, ", ") + " ) ";
  end;

  var params : TArray = makeArray
    ( SQLParam("OperD", {OperDprt}),
      SQLParam("RelatedRef", RefTrn)
    );

  if( ValType(TpID) == V_INTEGER )
    params[ params.size ] = SQLParam("TpID", TpID);
  end;

  var rs = execSQLselect( select, params );

  if ( rs.MoveNext() )
    MesID = rs.value(0);
  end;

  return MesID;
end;

// Если поле должно быть на верхнем уровне (в "нулевом блоке"), то BlockName передать = ".."
macro WlMes_GetFieldValue( MesID:integer, FieldName:string, BlockName:string ):string

  var query = " select wlmesval.t_Value "
              "   from dwlmesval_dbt wlmesval, dwltpfld_dbt wltpfld  ";
  if( BlockName )
    query = query + ", dwlmesfld_dbt wlmesfld ";

    if(BlockName != "..")
      query = query+", dwlmesfld_dbt masterfld ";
    end;
  end;

  query = query + 
              "  where wlmesval.t_MesID = :MesID "
              "    AND wlmesval.t_TpFieldID = wltpfld.t_TpFieldID "
              "    AND wltpfld.t_Name = :FieldName ";
              
  if( BlockName )
    query = query + 
              "    AND wlmesfld.t_FieldID = wlmesval.t_FieldID ";

    if(BlockName != "..")
      query = query + 
              "    AND wlmesfld.t_Master = masterfld.t_FieldID "
              "    AND masterfld.t_BlockName = :BlockName ";
    else
      query = query + 
              "    AND wlmesfld.t_Master = 0 ";
    end;
  end;

  var params : TArray = makeArray( SQLParam("MesID", MesID),
                                   SQLParam("FieldName", FieldName) );
  if( BlockName and (BlockName != "..") )
    params[ params.size ] = SQLParam("BlockName", BlockName);
  end;

  var rs = execSQLselect( query, params );
                             
  if( rs and rs.moveNext() )
    return rs.Value(0);
  end;    

  return "";
end;

macro WldSetStateStamp(rec, State : integer)
  rec.State = State;
  rec.BankDate = {curdate};
  rec.SysDate = date();
  rec.SysTime = time();
  rec.UserID = {oper};
end;

macro GetPaymentIDFromMesWCount( MesID : integer, PaymentsCount : @integer ) : integer
  var PaymentID = 0;
  var pmcount = 0;
  var select : string = 
    " select wlpm.t_PaymentID as t_PaymentID " +
    "   from dwlmeslnk_dbt lnk, dwlpm_dbt wlpm "+
    "  where lnk.t_MesID   = :MesID "+
    "    and lnk.t_ObjKind = :OBJTYPE_PAYMENT "
    "    and wlpm.t_WlPmID = lnk.t_ObjID ";

  var params : TArray = makeArray( SQLParam("MesID", MesID),
                                   SQLParam("OBJTYPE_PAYMENT", OBJTYPE_PAYMENT) );
  var rs : RsdRecordset = execSQLselect( select, params );
  while( rs.MoveNext() )
    PaymentID = rs.value( "t_PaymentID" );
    pmcount = pmcount + 1;
  end;

  if( valtype( PaymentsCount ) != V_UNDEF )
    PaymentsCount = pmcount;
  end;

  return PaymentID;
end;
