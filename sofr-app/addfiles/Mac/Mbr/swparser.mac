/*
$Name: swparser.mac
$Module: Межбанковские расчеты
$Description: В модуле нельзя подключать функции из WldInter, так как макрос
              используется дилинговыми приложениями, которые линкуют только MesInter
*/

import "swtools.mac", "wltools.mac", FIInter, "pmlib.mac", "wllog.mac", "wlglobal.mac";

/* глобальный список полей формы сообщения */
var ПоляФормы = Tarray;

/* глобальный список кодов поля */
var КодыПоля = Tarray;

const THISFLD = "this"; 

class ТПолеФормы( _name, _mandatory_flag, _read_fun, _fill_fun, _block_fun, repeatWithField )
  var Name:string,
      MandatoryFlag:string,
      ReadFun:string,
      FillFun:string,
      BlockFun:string,
      repeatWith:integer,
      UID:integer;

  Name          = _name;
  MandatoryFlag = _mandatory_flag;
  ReadFun       = _read_fun;
  FillFun       = _fill_fun;
  BlockFun      = _block_fun;
  UID           = ПоляФормы.Size;
  if ( valtype(repeatWithField)==V_UNDEF )
     repeatWith = -1;
  elif ( (valtype(repeatWithField)==V_STRING) and (repeatWithField==THISFLD) )
     repeatWith = ПоляФормы.Size;
  elif ( (valtype(repeatWithField)==V_STRING) )
     repeatWith = -1;
  else
     repeatWith = repeatWithField.UID;
  end;

  /* Добавляем поле в список полей формы */
  ПоляФормы(ПоляФормы.Size) = this;

  macro ОбработатьПолеФормы( stream )
    if( (ReadFun != "") AND (stream != "") )
      return ExecMacro2( ReadFun, stream, 1, FillFun );
    else
      return TRUE;
    end;
  end;
  
  macro ВыполнитьФункцияБлока
    if( BlockFun != "" )
      return ExecMacro2( BlockFun );
    else
      return TRUE;
    end;
  end;

  macro ПолеОбязательно
    if( MandatoryFlag == FIELD_MANDATORY )
      return TRUE;
    else
      return FALSE;
    end;
  end;

end; /* class ТПолеФормы */

class ТКодПоля( _name, _value )
  var Name :string,
      Value:string;

  /* Добавляем кодовое слово в список */
  КодыПоля(КодыПоля.Size) = this;

  Name = _name;

  if(valtype(_value)==V_STRING)
    if ( _value!="" )
       Value = _value;
    else
       Value = NOTEXT_VALUE;
    end;
  else
    Value = "";
  end;

  /*MsgBox( "ТКодПоля : Name :", Name, " Value :", Value );*/

end; /* class ТКодПоля */

macro СчитатьКодПоля( Name )
  var arsize = КодыПоля.Size, i = 0, obj;

  while( i < arsize )
    obj = КодыПоля(i);
    if( obj.Name == Name )
      return obj.Value
    end;
    i = i + 1;
  end;

  return "";
end;

macro YYMMDD2Date(Str)
  var Year;

  if( (Str == "") OR (Str == "000000") OR (Str == "0000") )
    return Date(0,0,0);
  end;

  Year = int(SubStr(Str,1,2)); /* YY */
  if( Year > 79 ) /* в соответствии с рекомендациями SWIFT-RUR 5 1.5.1 */
    Year = Year + 1900;
  else
    Year = Year + 2000;
  end;
  return date(int(SubStr(Str,5,2)),  /* DD */
                  int(SubStr(Str,3,2)),  /* MM */
                  Year);
end;

macro HHMMSSTime(Str)
  var Year;

  if( (Str == "") OR (Str == "000000") )
    return Time(0,0,0);
  end;

  return time(int(SubStr(Str,1,2)),  /* HH */
              int(SubStr(Str,3,2)),  /* MM */
              int(SubStr(Str,5,2))); /* SS */
end;

class TBnfCode( pCode, str )
    var CodeForCompare = pCode, Code, Ind;    

    macro CalcIndex( str )
       var i;

       code = CodeForCompare;
       Ind = Index( str, SYMB_SLASH + code + SYMB_SLASH );
       i = 0;
       while( (not Ind) AND (i<=strlen(CodeForCompare)) )
          if ( i==0 )
              code = SYMB_ENDL + CodeForCompare;
          else
              code = substr( CodeForCompare, 1, i );
              code = code + SYMB_ENDL;
              code = code + substr( CodeForCompare, i+1 );
          end;
          Ind = Index( str, SYMB_SLASH + code + SYMB_SLASH );
          i = i + 1;
       end;
    end;

    macro CmpCode( pCode )
        if ( pCode==CodeForCompare )
           return true;
        else
           return false;
        end;
    end;

    CalcIndex(str);
end;

/* :70: ------------- Информация Бенефициару ------------- */
class TBnfInfo( pStr )
var
  Str       :string,    /* Текст */
  RFB       :string,    /* Ссылка для Бенефициара */
  INV       :String,
  ROC       :String,
  IPI       :string,
  text      :String;

  if(valtype(pStr)==V_STRING)
    Str = pStr;
  else
    Str = "";
  end;

  macro SeparateString
      macro Sort( point )
          var i, j;
          var temp : TBnfCode;
          i = 0;
          while( i < point.size-1 )
              j = i+1;
              while( j < point.size )
                 if ( point(i).ind>point(j).ind )
                     temp = point(i);
                     point(i) = point(j);
                     point(j) = temp;
                 end;
                 j = j + 1;
              end;
              i = i + 1;
          end;
      end;

      var temp, Code, i, temp2, count;
      var point = TArray;
      var BnfCode;
      BnfCode = TBnfCode( Field70CodesRFB, str );
      if ( BnfCode.Ind )
         point(point.size) = BnfCode;
      end;
      BnfCode = TBnfCode( Field70CodesINV, str );
      if ( BnfCode.Ind )
         point(point.size) = BnfCode;
      end;
      BnfCode = TBnfCode( Field70CodesROC, str );
      if ( BnfCode.Ind )
         point(point.size) = BnfCode;
      end;      
      BnfCode = TBnfCode( Field70CodesIPI, str );
      if ( BnfCode.Ind )
         point(point.size) = BnfCode;
      end;      

      RFB = "";
      INV = "";
      ROC = "";
      IPI = "";
      temp = str;
      if ( point.size )
          Sort( point );
          i = 0;
          while( i < point.size )
              if ( i<(point.size-1) )
                  code = substr( str, point(i).Ind + strlen(point(i).Code) + 2, point(i+1).Ind - point(i).Ind - strlen(point(i).Code) - 2 );                  
              else
                  count = point(i).Ind;
                  while( ((substr(str, count, 1)!=SYMB_ENDL) OR (count==int(count/36)*36)) AND (count<=strlen(str)) )
                      count = count + 1;
                  end;                  
                  code = substr( str, point(i).Ind + strlen(point(i).Code) + 2, count - point(i).Ind - strlen(point(i).Code) - 1 );
              end;
              if ( (Index(temp, code)-strlen(point(i).Code)-2-1)>0 )
                  temp2 = substr( temp, 1, Index(temp, code)-strlen(point(i).Code)-2-1 );
              else
                  temp2 = "";
              end;
              temp2 = temp2 + substr( temp, Index(temp, code)+strlen(Code) );
              temp = temp2;
              /* Удаляем переносы строки */
              while( Index(code, SYMB_ENDL) )
                  temp2 = substr( code, 1, Index(code, SYMB_ENDL)-1 );
                  temp2 = temp2 + substr( code, Index(code, SYMB_ENDL)+1 );
                  code = temp2;
              end;
              /*Заменяем двойные слеши переносами строк*/
              while( Index(code, SYMB_DSLASH) )
                  temp2 = substr( code, 1, Index(code, SYMB_DSLASH)-1 );
                  temp2 = temp2 + SYMB_ENDL;
                  temp2 = temp2 + substr( code, Index(code, SYMB_DSLASH)+2 );
                  code = temp2;
              end;
              if ( substr(code, strlen(code), 1)==SYMB_ENDL )
                   code = substr(code, 1, strlen(code)-1 );
              end;
              if ( point(i).CmpCode(Field70CodesRFB) )
                   RFB = Code;
              end;
              if ( point(i).CmpCode(Field70CodesINV) )
                   INV = Code;
              end;
              if ( point(i).CmpCode(Field70CodesROC) )
                   ROC = Code;
              end;
              if ( point(i).CmpCode(Field70CodesIPI) )
                   IPI = Code;
              end;
              i = i + 1;
          end;
      end;
      text = str;
  end;

  SeparateString();

end;

macro ReadCodeWord( Stream, Count, Narrative, NumStr, LenStr, LenCode )
  var Str = "",
      CodeWord = "",
      ch = "",
      Info = "",
      StrmLen = StrLen(Stream),
      i=0,n=0,
      err=FALSE;
  КодыПоля = Tarray;
  while((NOT err) AND (n<NumStr) ) 
    /* первый символ в строке - слэш "/" */
    if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) )
      Count = Count + 1;
      /* считываем кодовое слово */
      if( (Count<StrmLen)
         AND StrmGetLexeme( Stream, Count, CodeWord, TS_ALPHA, TL_MAX, LenCode )
         AND (CodeWord!="")
        )
        /* кодовое слово должно завершаться слэшем */
        if( (Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_SLASH) )
          Count = Count + 1;
          /* считываем additional information - эту же строку до конца */
          if( (Count<=StrmLen)
             AND StrmGetLexeme( Stream, Count, Info, TS_XSETRUSBIG, TL_MAX, LenStr-2 )
            )

            if(SubStr(Stream, Count, 1) == SYMB_ENDL)
              /* пропуск CrLf */
              Count = Count + 1;
              n = n + 1;
            end;

            /* считываем строки с continuational information - добавочные строки, начинаются с двойного слэша */
            if( Count <= StrmLen )
              i=0;
              while(i<NumStr)
                if( (Count<=StrmLen) AND (SubStr(Stream, Count, 2) == "//") )
                  Count = Count + 2;
                  if( (Count<=StrmLen) AND StrmGetLexeme( Stream, Count, Str, TS_XSETRUSBIG, TL_MAX, LenStr-2 ) )
                      Info = Info + BNC_INFO_SEPARATOR + Str;
                    if(Count>StrmLen)
                      i=NumStr-1; /* поток прочитан */
                      n=NumStr; /* все лексемы прочитаны */
                    elif(SubStr(Stream, Count, 1) == SYMB_ENDL)
                      /* пропуск CrLf */
                      Count = Count + 1;
                      n = n + 1;
                    end;
                  else
                    PrintLog(1, "строка "+(n+2)+": Отсутствует информация на строке продолжения!");
                    err=TRUE;
                    i=5;
                  end;
                else
                  i=5; /* завершение считывания лексемы */
                end;
                i=i+1;
              end;
            end;

            PrintLog(3,"ReadCodeWord: /"+CodeWord+SYMB_SLASH+Info);
            GenObject( "ТКодПоля", CodeWord, Info );
          else
            /* указано только ключевое слово */
            PrintLog(3,"ReadCodeWord: empty /"+CodeWord+SYMB_SLASH);
            /* Обязательно должно присутствовать, а ТКодПоля сам решит, что с этим делать */
            GenObject( "ТКодПоля", CodeWord, "" );
          end;

          if(Count>StrmLen)
            n=6; /* все лексемы прочитаны */
          elif(SubStr(Stream, Count, 1) == SYMB_ENDL)
            /* пропуск CrLf */
            Count = Count + 1;
          else
            /*println(SubStr(Stream, Count, 1));*/
          end;
        else
          PrintLog(1, "строка "+(n+2)+": Неверное ключевое слово!");
          /*println("Осталось:",SubStr(Stream, Count, StrmLen-Count+1));*/
          err=TRUE;
        end;
      else
        PrintLog(1, "строка "+(n+2)+": Отсутствует ключевое слово!");
        err=TRUE;
      end;
    else
      /* VD 22.03.99 это плохо, но в 72 может и не быть ключевых слов - narrative text only */
      Info = SubStr(Stream,Count,StrmLen-Count+1);
      Count = StrmLen+1;
      SetParm(2,Info);
      n = NumStr;
    end;
  end; /* цикл по лексемам */

  if(NOT err)
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  end;

  return (NOT err);
end;

macro РазобратьЛексемуRPP( ЛексемаRPP, RPP_Number, RPP_Date, RPP_Priority, RPP_PaymentKind, RPP_DateCarry, RPP_ShifrOper )
   var ind, ind1, i, obj;
   RPP_Number = "";
   RPP_Date = date(0,0,0);
   RPP_Priority = PM_DefaultMaxPriority();/*SCR 32536, 192560 */
   RPP_PaymentKind = "";
   RPP_DateCarry  = date(0,0,0);
   RPP_ShifrOper = "01";

   if ( ЛексемаRPP!="" )
      ind = Index(ЛексемаRPP, ".");
      RPP_Number = substr( ЛексемаRPP, 1, ind-1 );  
      RPP_Date = YYMMDD2Date( substr(ЛексемаRPP, ind+1, 6) );

      ind = Index( ЛексемаRPP, ".", ind + 1 );
      ind1 = Index( ЛексемаRPP, ".", ind + 1 );
      RPP_Priority = int( substr(ЛексемаRPP, ind+1, ind1-1 - ind) );

      RPP_PaymentKind = substr(ЛексемаRPP, ind1+1, 4);
      if ( RPP_PaymentKind=="POST" )
         RPP_PaymentKind = "П";
      elif ( RPP_PaymentKind=="TELG" )
         RPP_PaymentKind = "Т";
      elif ( RPP_PaymentKind=="ELEK" )
        RPP_PaymentKind = "Э";
      elif ( RPP_PaymentKind=="BESP" )
        RPP_PaymentKind = "С";
      else 
        RPP_PaymentKind = "";
      end;      
      /* Следующая ситуация характерна для RUR4 */
      if ( RPP_PaymentKind=="" )
         i = 0;
         while( i<КодыПоля.Size )
            obj = КодыПоля(i);
            if ( obj.Name==Field72CodesELEC )
               RPP_PaymentKind = "Э";
            elif ( obj.Name==Field72CodesPHON )
               RPP_PaymentKind = "Т";
            elif ( obj.Name==Field72CodesTELEX )
               RPP_PaymentKind = "Т";
            end;
            if ( RPP_PaymentKind!="" )
               i = КодыПоля.Size;
            else 
               i = i + 1;
            end;
         end;
      end;
      
      ind = Index( ЛексемаRPP, ".", ind1 + 1 );
      ind1 = Index( ЛексемаRPP, ".", ind + 1 );
      if ( ind and ind1 and (ind1 - ind == 7))
        RPP_DateCarry = YYMMDD2Date( substr(ЛексемаRPP, ind+1, 6) );
        ind = ind1;//если есть дата, то считываем шифр из 6 поля
      end;
      if ( ind )
        RPP_ShifrOper = substr(ЛексемаRPP, ind+1, 2);
      end;
   end;

   SetParm( 1, RPP_Number );
   SetParm( 2, RPP_Date );
   SetParm( 3, RPP_Priority );
   SetParm( 4, RPP_PaymentKind );
   SetParm( 5, RPP_DateCarry );
   SetParm( 6, RPP_ShifrOper );

   return TRUE;

   OnError(er) /* обработка ошибок времени выполнения */
     std.msg(er.Message + " Не удалось определить часть реквизитов расчетного документа из поля RPP. Будут использованы значения по умолчанию.");
     SetParm( 1, RPP_Number );
     SetParm( 2, RPP_Date );
     SetParm( 3, RPP_Priority );
     SetParm( 4, RPP_PaymentKind );
     SetParm( 5, RPP_DateCarry );
     SetParm( 6, RPP_ShifrOper );
     return FALSE;
end;

macro ДобавитьНачальнуюКавычку( str : string )
  var i = 1,
      count:integer = 0;
  
  while( i < strlen(str) )
    if( substr(str,i,1) == "'" )
      count = count + 1;
    end;
    i = i+1;
  end;
  
  if( (count/2)*2 == count )
    return str;
  else
    return "'" + str;
  end;
end;

/* :72: ------------- Информация Получателю ------------- */
/* лексемы 72 пока нигде не используются, кроме BNF, RCB, ACC */
class TRcvInfo100( pStr, pNarrative )
 var
  Str       :string, /* общий буфер */
  /* Информация участникам перевода */
  REC       :string, /* Информация Получателю */
  INT       :string, /* Информация Посреднику */
  ACC       :string, /* Информация Банку Бенефициара (?) */
  BNF       :string, /* Информация Бенефициару (в МТ100 для хвоста основания) можно и не хранить, стыкуется к BnfInfo */
  NZP       :string,
  /* Извещение Посредника */
  TELEIBK   :string,
  PHONIBK   :string,
  /* Извещение Банка Бенефициара */
  TELE      :string,
  PHON      :string,
  /* Извещение Бенефициара */
  PHONEBEN  :string,
  TELEBEN   :string,

  BENONLY   :string, /* Выплатить лично Бенефициару */
  CHEQUE    :string, /* Выплатить чеком */
  CORPTRAD  :string,
  HOLD      :string, /* Удерживать до извещения Бенефициара (?) */
  INS       :string, /* Инструктирующий банк */
  INTRACOM  :string, /* Расчеты внутри компании(корпорации) */
  RCB       :string, /* Корреспондент получателя */ 
  DAS       :date,   /* Дата списания денежных средств со счета Плательщика */
  Narrative :string, /* словесное описание */
  /* Реквизиты платежного поручения */
  RPP_Number     :string,  /* Номер платежного поручения */
  RPP_Date       :date,    /* Дата платежного поручения */
  RPP_Priority   :integer, /* Очередность */
  RPP_PaymentKind:string,  /* Вид платежа */
  RPP_DateCarry  :date,    /* Дата проведения */
  RPP_ShifrOper  :string,  /* Шифр операции */
  UIP: string; /*Уникальный идентификатор*/

  var Count;

  if(valtype(pStr)==V_STRING)
    Str = pStr;
  else
    Str = "";
  end;

  if(valtype(pNarrative)==V_STRING)
    Narrative = pNarrative;
  else
    Narrative = "";
  end;

  Count = 1;
  ReadCodeWord( Str, Count, Narrative, 6, 35, 8 );

  BENONLY  = СчитатьКодПоля( Field72CodesBENONLY );
  CHEQUE   = СчитатьКодПоля( Field72CodesCHEQUE );
  CORPTRAD = СчитатьКодПоля( Field72CodesCORPTRAD );
  HOLD     = СчитатьКодПоля( Field72CodesHOLD );
  INTRACOM = СчитатьКодПоля( Field72CodesINTRACOM );
  PHON     = СчитатьКодПоля( Field72CodesPHON );
  PHONEBEN = СчитатьКодПоля( Field72CodesPHONBEN );
  PHONIBK  = СчитатьКодПоля( Field72CodesPHONIBK );
  TELE     = СчитатьКодПоля( Field72CodesTELE );
  TELEBEN  = СчитатьКодПоля( Field72CodesTELEBEN );
  TELEIBK  = СчитатьКодПоля( Field72CodesTELEIBK );
  UIP = СчитатьКодПоля( Field72CodesUIP );
  RCB = СчитатьКодПоля( Field72CodesRCB );
  REC = СчитатьКодПоля( Field72CodesREC );
  INS = СчитатьКодПоля( Field72CodesINS );
  ACC = СчитатьКодПоля( Field72CodesACC );
  INT = СчитатьКодПоля( Field72CodesINT );
  NZP = ДобавитьНачальнуюКавычку(СчитатьКодПоля( Field72CodesNZP ));
  BNF = СчитатьКодПоля( Field72CodesBNF );
  DAS = YYMMDD2Date(СчитатьКодПоля( Field72CodesDAS ));
  РазобратьЛексемуRPP( СчитатьКодПоля(Field72CodesRPP), RPP_Number, RPP_Date, RPP_Priority, RPP_PaymentKind, RPP_DateCarry, RPP_ShifrOper );
end;  /* class TRcvInfo100 */

/* ------------- Баланс ------------- */
class Balance( pDKFlag, pDate, pCurrency, pAmount )
  /* инициализация */
 var
  DKFlag   :string,   /* Признак дебета/кредита */
  DateBal  :date,     /* Дата */
  FIID     :integer,  /* Финансовый инструмент */
  Amount   :moneyl;   /* Сумма */

  /* инициализация */
  if(valtype(pDKFlag)==V_STRING)
    DKFlag = pDKFlag;
  else
    pDKFlag = DEBET_ACCOUNT;
  end;

  if(valtype(pDate)==V_DATE)
    DateBal = pDate;
  elif(valtype(pDate)==V_STRING)
    DateBal = YYMMDD2Date(pDate);
  else
    DateBal = {curdate};
  end;

  if(valtype(pCurrency)==V_INTEGER)
    FIID = pCurrency;
  elif(valtype(pCurrency)==V_STRING)
    if( not ПолучитьФинИнПоISO( pCurrency, wlfininstr ) )
      std.err( 1, "Не определена валюта балансового остатка по коду ISO :" +  pCurrency );
    end;
    FIID = wlfininstr.FIID;
  else
    FIID = 0;
  end;

  if((valtype(pAmount)==V_MONEY) OR (valtype(pAmount)==V_MONEYL))
    Amount = pAmount;
  elif((valtype(pAmount)==V_DOUBLE) OR (valtype(pAmount)==V_DOUBLEL))
    Amount = moneyl(pAmount);
  else
     Amount = moneyl(0);
  end;

end;

/* --------Документ выписки ------------- */
class StatementLine( pDateVal, pDateInp, pDKFlag, pAmount, pTypeOper, pRef, pAccRef, pDetails )
  /* инициализация */
 var
  DateVal  :date,     /* Дата валютирования */
  DateInp  :date,     /* Дата ввода */
  DKFlag   :string,   /* Признак дебета/кредита */
  Amount   :moneyl,   /* Сумма */
  TypeOper :string,   /* Тип операции */
  Ref      :string,   /* Ссылка для владельца счета */
  AccRef   :string,   /* Ссылка для банка, обслуживающего счет */
  Details  :string;   /* Детали */

  /* инициализация */
  if(valtype(pDateVal)==V_DATE)
    DateVal = pDateVal;
  elif(valtype(pDateVal)==V_STRING)
    DateVal = YYMMDD2Date(pDateVal);
  else
    DateVal = {curdate};
  end;

  if(valtype(pDateInp)==V_DATE)
    DateInp = pDateInp;
  elif(valtype(pDateInp)==V_STRING)
    DateInp = date(int(SubStr(pDateInp,3,2)), int(SubStr(pDateInp,1,2)) );
  else
    DateInp = {curdate};
  end;

  if(valtype(pDKFlag)==V_STRING)
    DKFlag = pDKFlag;
  else
    pDKFlag = DEBET_ACCOUNT;
  end;

  if((valtype(pAmount)==V_MONEY) OR (valtype(pAmount)==V_MONEYL))
    Amount = pAmount;
  elif((valtype(pAmount)==V_DOUBLE) OR (valtype(pAmount)==V_DOUBLEL))
    Amount = moneyl(pAmount);
  else
    Amount = moneyl(0);
  end;

  if(valtype(pTypeOper)==V_STRING)
     TypeOper = pTypeOper;
  else
     TypeOper= "";
  end;

  if(valtype(pRef)==V_STRING)
    Ref = pRef;
  else
    Ref = "";
  end;

  if(valtype(pAccref)==V_STRING)
    Accref = pAccref;
  else
    Accref = "";
  end;

  if(valtype(pDetails)==V_STRING)
    Details = pDetails;
  else
    Details = "";
  end;

  macro IsSet()
    return NOT((Ref=="")AND(AccRef=="")AND(Amount==$0)AND(Details==""));
  end;
end;

/* Остатки по счету */
class FloorLimit
   var FIID, DKFlag, Amount;
   macro Set( pCurrency, pDKFlag, pAmount )
      if(valtype(pCurrency)==V_INTEGER)
         FIID = pCurrency;
      elif(valtype(pCurrency)==V_STRING)
         if( not ПолучитьФинИнПоISO( pCurrency, wlfininstr ) )
           std.msg( "Не определена валюта балансового остатка по коду ISO :" +  pCurrency );
         end;
         FIID = wlfininstr.FIID;
      else
         FIID = 0;
      end;
      DKFlag = pDKFlag;
      Amount = pAmount;
   end;
   macro IsSet
      if ( FIID==-1 )
         return FALSE;
      end;
      return TRUE;
   end;
   FIID   = -1;
   DKFlag = "";
   Amount = 0;
end; /* Class FloorLimit */


class NumberSumma
   var FIID, Number, Amount;
   macro Set( pCurrency, pNumber, pAmount )
      if(valtype(pCurrency)==V_INTEGER)
         FIID = pCurrency;
      elif(valtype(pCurrency)==V_STRING)
         if( not ПолучитьФинИнПоISO( pCurrency, wlfininstr ) )
           std.msg( "Не определена валюта балансового остатка по коду ISO :" +  pCurrency );
         end;
         FIID = wlfininstr.FIID;
      else
         FIID = 0;
      end;
      Number = pNumber;
      Amount = pAmount;
   end;
   macro IsSet
      if ( FIID==-1 )
         return FALSE;
      end;
      return TRUE;
   end;
   FIID   = -1;
   Number = 0;
   Amount = 0;
end; /* Class NumberSumma */

macro Read90( Stream, Count, MacroFill )
   var numSum : NumberSumma;
   var Currency, Number, Amount, поле, позиция=1, str;
   if( StrmGetLexeme( Stream, Count, str, TS_XSET, TL_MAX, 23 ) )
       PrintLog(3,"Read90: "+ str);
       SetParm( 1, Count ); /* запись в 1-й аргумент!*/
       поле = СчитатьСтрокуЦифр( str );
       if( поле == "" )
          std.msg("Не указано количество документов в поле '90'");
          return FALSE;
       elif( StrLen( поле ) > 5 )
          std.msg("Неверная длина поля количество документов");
          return FALSE;
       else
          Number = int(поле);
          позиция = позиция + StrLen( поле );
       end;
       /* Код валюты */
       Currency = SubStr( str, позиция, 3 );
       позиция = позиция + 3;
       поле = SubStr( str, позиция );
       if( not ( позиция = Index( поле, "," ) ) )
          std.msg( "В поле '90' не указан обязательный разделитель ','" );
          return FALSE;
       end;
       StrSet( поле, позиция, "." );
       Amount = MoneyL( doubleL( поле ) );
       numSum.Set( Currency, Number, Amount );
       return ExecMacro2( MacroFill, numSum );
   end;
   return FALSE;
end;

macro Read34F( Stream, Count, MacroFill )
  var str="", CodeCur, позиция = 1;
  var Limit : FloorLimit;
  var DKFlag="", Amount, поле;
  
  if( StrmGetLexeme( Stream, Count, str, TS_XSET, TL_MAX, 19 ) )
    PrintLog(3,"Read34F: "+ str);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    CodeCur = SubStr( str, позиция, 3 );
    позиция = позиция + 3;
    /* Признак дебета/кредита */
    if( SubStr( str, позиция, 1 ) == DEBET_ACCOUNT )
       позиция = позиция + 1;
       DKFlag = DEBET_ACCOUNT;
    elif( SubStr( str, позиция, 1 ) == CREDIT_ACCOUNT )
       позиция = позиция + 1;
       DKFlag = CREDIT_ACCOUNT;
    end;
    поле = SubStr( str, позиция );
    if( not ( позиция = Index( поле, "," ) ) )
       std.msg( "В поле Нижняя граница сумм | не указан обязательный разделитель ','" );
       return FALSE;
    end;
    StrSet( поле, позиция, "." );
    Amount = MoneyL( doubleL( поле ) );
    Limit.Set( CodeCur, DKFlag, Amount );
    return ExecMacro2( MacroFill, Limit );
  end;
  
  return FALSE;
end;

/* YYMMDD */
macro ReadDateYYMMDD( Stream, Count, DateValue )
  var Str = "",
      DateSrc = date(0,0,0),
      Year = 0;

  if( StrmGetLexeme( Stream, Count, Str, TS_NUM, TL_FIXED, 6 ) )
    DateSrc = YYMMDD2Date(Str);
    PrintLog(3,"ReadDate: "+string(DateSrc));
    SetParm( 1, Count );
    SetParm( 2, DateSrc);
    return TRUE;
  end;
  return FALSE;
end;

/* YYYYMMDD */
macro ReadDateYYYYMMDD(
  Stream,
  Count,
  DateValue
)
  var Str = "",
      DateSrc = date(0,0,0),
      Year = 0;

  if( StrmGetLexeme( Stream, Count, Str, TS_NUM, TL_FIXED, 8 ) )
    DateSrc = date(int(SubStr(Str,7,2)),   /* DD */
                   int(SubStr(Str,5,2)),   /* MM */
                   int(SubStr(Str,1,4)));  /* YYYY */
    SetParm( 1, Count ); 
    SetParm( 2, DateSrc);
    return TRUE;
  end;
  return FALSE;
end;

macro ReadFullDate( stream, Count, MacroFill )
  var DateScr;

  if( ReadDateYYYYMMDD(stream, Count, DateScr)  )
    return ExecMacro2( MacroFill, DateScr );
  else
    return FALSE;
  end;
end;

macro ReadTimeHHMMSS( Stream, Count, TimeValue )
  var Str = "",
      TimeSrc = time(0,0,0);

  if( StrmGetLexeme( Stream, Count, Str, TS_NUM, TL_FIXED, 6 ) )
    TimeSrc = HHMMSSTime(Str);
    PrintLog(3,"ReadTime: "+string(TimeSrc));
    SetParm( 1, Count );
    SetParm( 2, TimeSrc);
    return TRUE;
  end;
  return FALSE;
end;


/* MMDD */
macro ReadDateMMDD(
  Stream,
  Count,
  DateValue
)
  var Str = "",
      DateSrc = date(0,0,0),
      Year = 0;

  if( StrmGetLexeme( Stream, Count, Str, TS_NUM, TL_FIXED, 4 ) )
    DateSrc =  date(int(SubStr(Str,3,2)),  /* DD */
                    int(SubStr(Str,1,2)));  /* MM */
    PrintLog(3,"ReadDate: "+string(DateSrc));
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    SetParm( 2, DateSrc);
    return TRUE;
  end;
  return FALSE;
end;

/* поствалидация на допустимую длину дробной части для данной валюты не производится! */
macro ReadSum(
  Stream,
  Count,
  Summ
)
  var Str = "",
      SepPos = 0,
      Sum = 0;

  if( StrmGetLexeme( Stream, Count, Str, TS_DIGIT, TL_MAX, 15 ) )
    SepPos = Index(Str,","); /* позиция разделителя */
    if( SepPos != 0 )
      StrSet(Str,SepPos,"."); /* замена разделителя SWIFT (запятая) на разделитель RS-Bank (точка) */

      Sum=moneyl(Str);
      PrintLog(3,"ReadSum: "+string(Sum));
      SetParm( 1, Count ); /* запись в 1-й аргумент!*/
      SetParm( 2, Sum );
      return TRUE;
    else
      std.err(1,"В строке Суммы "+Str+" не найден обязательный разделитель \",\" (запятая)!");
      return FALSE;
    end;
  end;
  return FALSE;
end;

/* Разбор поля 61 */
macro Read61( Stream, Count, MacroFill )
  var Line:StatementLine, StrmLen = StrLen(Stream), позиция, Sum:moneyl, pos;

  /* MsgBox("Read61: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* Дата валютирования в формате ISO (ГГММДД) */
  if( not ReadDateYYMMDD( Stream, Count, Line.DateVal ) )
    return FALSE;
  end;

  /* MsgBox("Read61 DateInp: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* Дата ввода в сокращенном формате ISO (ММДД) */
  if( not ReadDateMMDD( Stream, Count, Line.DateInp ) )
    Line.DateInp = date(0,0,0);
  end;

  /* MsgBox("Read61 DKFlag: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* Признак дебета/кредита. Возможные значения: D - дебет, C - кредит, */
  /* RC - отмена кредита(ввод дебета), RD - отмена дебета(ввод кредита) */
  Line.DKFlag = SubStr( Stream, Count, 1 );
  Count = Count + 1;
  if( Line.DKFlag == "R" )
    Line.DKFlag = Line.DKFlag + SubStr( Stream, Count, 1 );
    Count = Count + 1;
  elif( (Line.DKFlag != DEBET_ACCOUNT) AND (Line.DKFlag != CREDIT_ACCOUNT))
    std.err( 1, "Не указан признак дебета/кредита");
    return FALSE;
  end;

  /* MsgBox("Read61 Cur: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* Код средств, содержащий третий символ кода валюты */
  if( not Index( DigitSet, SubStr( Stream, Count, 1) ) )
    Count = Count + 1;
  end;

  /* MsgBox("Read61 Sum: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* Сумма */
  if( not ReadSum(Stream, Count, Sum) )
    std.err( 1, "Не указана сумма");
    return FALSE;
  end;
  Line.Amount = Sum;

  /* MsgBox("Read61 TypeOper: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen ); */

  /* Идентификатор типа операции */
  if( Count <= StrmLen )
    Line.TypeOper = SubStr( Stream, count, 4 );
    Count = Count + 4;
    std.out(2,"Тип операции "+Line.TypeOper);
  else
    std.err( 1, "Не указан тип операции" );
    return FALSE;
  end;

  /* MsgBox("Read61 Ref: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen ); */

  /* Ссылка для владельца счета */
  if( Count <= StrmLen )
    позиция = Index( SubStr( Stream, Count), SYMB_DSLASH );
    if( позиция == 0 )
       pos = Index( SubStr( Stream, Count), SYMB_ENDL );
       if( pos == 0 )
         Line.Ref = SubStr( Stream, Count );
       else
         Line.Ref = SubStr( Stream, Count, pos-1 ); 
       end;
    else
       Line.Ref = SubStr( Stream, Count, позиция-1 );
    end;
    if( Line.Ref == "" )
      std.err( 1, "Не указана ссылка для владельца счета" );
      return FALSE;
    end;
    if( pos == 0 )
      Count = Count + StrLen( Line.Ref ) + StrLen(SYMB_DSLASH);
    else
      Count = Count + StrLen( Line.Ref );      
    end;
    std.out(2,"Ссылка для владельца счета "+Line.Ref);
  else
    std.err( 1, "Не указана ссылка для владельца счета" );
    return FALSE;
  end;

  /* MsgBox("Read61 AccRef: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen ); */

  /* Ссылка для банка, обслуживающего счет */
  if( (Count <= StrmLen) AND StrmGetLexeme( Stream, Count, Line.AccRef, TS_XSET, TL_MAX, 16 ) )
    std.out(2,"Ссылка для банка, обслуживающего счет "+Line.AccRef);
  end;

  /* MsgBox("Read61 Details: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen ); */

  /* Дополнительная информация */
  if( (Count <= StrmLen) AND (SubStr( Stream, Count, 1) == SYMB_ENDL) )
    Count = Count + 1;
    Line.Details = SubStr( Stream, Count );
    std.out(2,"Дополнительная информация "+Line.Details);
    Count = Count + StrLen( Line.Details );
  end;

  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  return ExecMacro2( MacroFill, Line );
end;

/* Время со смещением */
class TGMT
  var LocalTime:time,
      Sign     :string, 
      OffSet   :time;

  macro Set( pTime:time, pSign:string, pOffSet:time )
    LocalTime = pTime;
    OffSet    = pOffSet;
    Sign      = pSign;
  end;

  LocalTime = time( 0,0,0 );
  Sign      = "";
  OffSet    = time( 0,0,0 );
end;

class TDateTime
  var LocalDate:date;
  var LocalTime:TGMT;

  macro Set( pDate:date, pTime:time, pSign:string, pOffSet:time )
     LocalDate = pDate;
     LocalTime.Set( pTime, pSign, pOffSet );
  end;

  LocalDate = date( 0,0,0 );
  LocalTime.Set( time( 0,0,0 ), "", time( 0,0,0 ) );
end;

macro Read13( Stream, Count, MacroFill )
  var str;
  var LocalDate   : date;
  var LocalTime   : time;
  var DateTimeInd : TDateTime;
  
  if( StrmGetLexeme( Stream, Count, str, TS_XSET, TL_MAX, 10 ) )
      PrintLog(3,"Read13: "+ str);
      SetParm( 1, Count ); /* запись в 1-й аргумент!*/
      LocalDate = YYMMDD2Date( str );
      LocalTime = time( int(substr(str,7,2)), int(substr(str,9,2)), 0 );
      DateTimeInd.Set( LocalDate, LocalTime, "", time(0,0,0) );
      return ExecMacro2( MacroFill, DateTimeInd );
  end;
   
  return FALSE;
end;

macro ReadTRF( Stream, Count, MacroFill )
  var TRF = "";
  if( StrmGetLexeme( Stream, Count, TRF, TS_XSET, TL_MAX, 16 ) )
    PrintLog(3,"ReadTRF: "+TRF);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, TRF );
  end;
  return FALSE;
end;

macro Read16( Stream, Count, MacroFill )
  var BlockName = "";
  if( StrmGetLexeme( Stream, Count, BlockName, TS_XSET, TL_MAX, 16 ) )
    PrintLog(3,"Read16: "+BlockName);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, BlockName );
  end;
  return FALSE;
end;

macro Read20C( Stream, Count, MacroFill )
  var Qualifer = "", Refer="";
  if( StrmGetLexeme( Stream, Count, Qualifer, TS_XSET, TL_FIXED, 7 ) )
    Qualifer = substr(Qualifer,2,4);
    StrmGetLexeme( Stream, Count, Refer, TS_XSET, TL_MAX, 16 );
    PrintLog(3,"Read20C: "+Qualifer);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Qualifer, Refer );
  end;
  return FALSE;
end;

macro Read98A( Stream, Count, MacroFill )
  var code, DateScr;
  if( StrmGetLexeme( Stream, Count, code, TS_XSET, TL_FIXED, 7 ) )
    code = substr(code,2,4);
    if ( ReadDateYYYYMMDD(stream, Count, DateScr) )
       PrintLog(3,"Read98A: "+Code);
       SetParm( 1, Count ); /* запись в 1-й аргумент!*/
       return ExecMacro2( MacroFill, Code, DateScr, time(0,0,0) );
    end;
  end;
  PrintLog(3,"Read98A: Ошибка формата");
  return FALSE;
end;

macro Read98B( Stream, Count, MacroFill )
  var Qualif, Scheme= "", DateCode;
  if( StrmGetLexeme( Stream, Count, Qualif, TS_XSET, TL_FIXED, 6 ) )
    Qualif = substr(Qualif,2,4);
    if ( substr(Stream, Count, 1)!=SYMB_SLASH )
      if( not StrmGetLexeme( Stream, Count, Scheme, TS_ALPNUM, TL_MAX, 8 ) )
         PrintLog(3,"Read98B: Ошибка формата");
         return false;
      end;
    end;
    if ( substr(Stream, Count, 1)==SYMB_SLASH )
       /* Пропускаем слеш */
       Count = Count+1;
       if ( StrmGetLexeme( Stream, Count, DateCode, TS_XSET, TL_FIXED, 4) )
          PrintLog(3,"Read98B: "+Qualif);
          SetParm( 1, Count ); /* запись в 1-й аргумент!*/
          return ExecMacro2( MacroFill, Qualif, Scheme, DateCode );
       end;
    end;
  end;
  PrintLog(3,"Read98B: Ошибка формата");
  return FALSE;
end;

macro Read98C( Stream, Count, MacroFill )
  var code, DateScr, TimeScr;
  if( StrmGetLexeme( Stream, Count, code, TS_XSET, TL_FIXED, 7 ) )
    code = substr(code,2,4);
    if ( ReadDateYYYYMMDD(stream, Count, DateScr) )
       if ( ReadTimeHHMMSS(stream, Count, TimeScr) )
          PrintLog(3,"Read98C: "+Code);
          SetParm( 1, Count ); /* запись в 1-й аргумент!*/
          return ExecMacro2( MacroFill, Code, DateScr, TimeScr );
       end;
    end;
  end;
  PrintLog(3,"Read98C: Ошибка формата");
  return FALSE;
end;

macro Read22FH( Stream, Count, MacroFill )
  var Qualifier, Scheme="", Indicator;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 6 ) )
      Qualifier = substr(Qualifier,2,4);
      if ( substr(Stream, Count, 1)!=SYMB_SLASH )
         if( not StrmGetLexeme( Stream, Count, Scheme, TS_ALPNUM, TL_MAX, 8 ) )
             PrintLog(3,"Read22F(H): Ошибка формата" );
             return false;
         end;
      end;
      if ( substr(Stream, Count, 1)==SYMB_SLASH )
         /* Пропускаем слеш */
         Count = Count+1;
         if( StrmGetLexeme( Stream, Count, Indicator, TS_ALPNUM, TL_FIXED, 4 ) )
            PrintLog(3,"Read22F(H): " + Qualifier );
            SetParm( 1, Count ); /* запись в 1-й аргумент!*/
            return ExecMacro2( MacroFill, Qualifier, Scheme, Indicator );
         end;
      end;
  end;
  PrintLog(3,"Read22F(H): Ошибка формата" );
  return false;
end;

macro Read13A( Stream, Count, MacroFill )
  var str, Qualifier, Number;
  if( StrmGetLexeme( Stream, Count, str, TS_XSET, TL_FIXED, 10 ) )
     Qualifier = substr(str, 2,4);
     Number = substr(str, 8);
     PrintLog(3,"Read13A: " + Qualifier );
     SetParm( 1, Count ); /* запись в 1-й аргумент!*/
     return ExecMacro2( MacroFill, Qualifier, Number );
  end;
  PrintLog(3,"Read13A: Ошибка формата" );
  return false;
end;

macro Read13B( Stream, Count, MacroFill )
  /* Реально пока не используется, пропускаем */
  return true;
end;

macro Read13K( Stream, Count, MacroFill )
  /* Реально пока не используется, пропускаем */
  return true;
end;

macro ReadCode( Stream, Count, MacroFill )
  var Code = "", Value = "";
  if( StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_FIXED, 4 ) )
    if ( substr(Stream, Count, 1)==SYMB_SLASH )
        Count = Count + 1;
        StrmGetLexeme( Stream, Count, Value, TS_XSET, TL_MAX, 30 )
    end;
    PrintLog(3,"ReadCode: "+Code);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Code, Value );
  end;
  return FALSE;
end;

macro ReadCode7( Stream, Count, MacroFill )
  var Code = "";
  if( StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_FIXED, 7 ) )
    PrintLog(3,"ReadCode7: "+Code);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Code );
  end;
  return FALSE;
end;

macro ReadSymbol( Stream, Count, MacroFill )
  var Symbol = "";
  if( StrmGetLexeme( Stream, Count, Symbol, TS_XSET, TL_FIXED, 1 ) )
    PrintLog(3,"ReadSymbol: "+Symbol);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Symbol );
  end;
  return FALSE;
end;

macro ReadType( Stream, Count, MacroFill )
  /*MsgBox("ReadTRF: ", "Stream ", Stream, "Count ", Count );*/
  var Type = "";
  if( StrmGetLexeme( Stream, Count, Type, TS_XSET, TL_FIXED, 3 ) )
    PrintLog(3,"ReadType: "+Type);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Type );
  end;
  return FALSE;
end;

macro ReadRate( Stream, Count, MacroFill )
  var Rate = 0, SepPos, Str, Negative = FALSE;

  /* Первым символом может быть символ "N" */
  if( SubStr( Stream, 1, 1 ) == NEGATIVE_SYMB )
    Count = Count + 1;
    Negative = TRUE;
  end;
  if( StrmGetLexeme( Stream, Count, Str, TS_DIGIT, TL_MAX, 12 ) )
    SepPos = Index(Str,","); /* позиция разделителя */
    if( SepPos != 0 )
       StrSet(Str,SepPos,"."); /* замена разделителя SWIFT (запятая) на разделитель RS-Bank (точка) */
       Rate = DoubleL(Str);
       SetParm( 1, Count ); 
       return ExecMacro2( MacroFill, Rate, Negative, Str );
    else
       std.err(1,"В строке "+Str+" не найден обязательный разделитель \",\" (запятая)!");
       return FALSE;
    end;
  end;
  return FALSE;
end;

/* GMT */
macro ReadGMT( Stream, Count, GMT:TGMT )
  var Str = "", Sign, LocalTime, OffSet, Indic:TGMT;

  if( StrmGetLexeme( Stream, Count, Str, TS_NUM, TL_FIXED, 4 ) )
    LocalTime = time( int(substr(str,1,2)), int(substr(str,3,2)), 0 );
    if( StrmGetLexeme( Stream, Count, Sign, TS_SIGN, TL_FIXED, 1 ) )
      if( StrmGetLexeme( Stream, Count, Str, TS_NUM, TL_FIXED, 4 ) )
        OffSet = time( int(substr(str,1,2)), int(substr(str,3,2)), 0 );
        Indic.Set( LocalTime, Sign, OffSet );
        SetParm( 1, Count ); /* запись в 1-й аргумент!*/
        SetParm( 2, Indic );
        return TRUE;
      end;
    end;
  end;
  std.err(1, "Неверный формат (GMT) времени");
  return FALSE;
end;

macro Read13C( Stream, Count, MacroFill )
  var Code, GMT:TGMT;

  if( SubStr(Stream, count, 1) == SYMB_SLASH )
    count = count + 1;
    if( StrmGetLexeme( Stream, Count, Code, TS_ALPHA, TL_MAX, 8 ) )
      if( SubStr(Stream, count, 1) == SYMB_SLASH )
        count = count + 1;
        if( ReadGMT( Stream, Count, GMT ) )
          SetParm( 1, Count );
          return ExecMacro2( MacroFill, Code, GMT );
        end;
      end;
    end;
  end;
  std.err(1,"Неверный формат поля 13С");
  return FALSE;
end;

macro Read13D( Stream, Count, MacroFill )
  var GMT:TGMT, DateScr;
  var DateTimeInd : TDateTime;

  if( ReadDateYYMMDD(stream, Count, DateScr)  )
    if( ReadGMT( Stream, Count, GMT ) )
      SetParm( 1, Count );
      DateTimeInd.Set( DateScr, GMT.LocalTime, GMT.Sign, GMT.OffSet );
      return ExecMacro2( MacroFill, DateTimeInd );
    end;
  end;
  std.err(1,"Неверный формат поля 13D");
  return FALSE;
end;


macro Read11( Stream, Count, MacroFill )
  /*MsgBox("ReadTRF: ", "Stream ", Stream, "Count ", Count );*/
  var str = "", InitDate, FormName, SessNum="", ISN="";
  if( StrmGetLexeme( Stream, Count, str, TS_NUM, TL_BLOCK, 3, 10 ) )
    PrintLog(3,"Read11: "+str);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    FormName = substr( str, 1, 3 );
    InitDate = YYMMDD2Date( substr(str,5,6) );    
    if ( strlen(str)>11 )
       SessNum = substr( str, 12, 4 );
       ISN = substr( str, 16, 6 );
    end;
    return ExecMacro2( MacroFill, FormName, InitDate, SessNum, ISN );
  end;
  return FALSE;
end;

/* поствалидация на наличие в справочниках не производится! */
macro ReadCur(
  Stream,
  Count,
  Cur
)
  var Str = "";

  /*MsgBox("ReadCur: ", "Stream ", Stream, "Count ", Count );*/

  if( StrmGetLexeme( Stream, Count, Str, TS_ALPHA, TL_FIXED, 3 ) )
    PrintLog(3,"ReadCur: "+Str);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    SetParm( 2, Str );
    return TRUE;
  end;
  return FALSE;
end;

macro Read30( stream, Count, MacroFill )
  var DateScr;

  if( ReadDateYYMMDD(stream, Count, DateScr)  )
    return ExecMacro2( MacroFill, DateScr );
  else
    return FALSE;
  end;
end;

/* YYMMDDMMSS */
macro ReadDateTime( stream, Count, MacroFill )
  var LocalDate, TimeStr;
  var LocalTime;

  if( ReadDateYYMMDD(stream, Count, LocalDate)  )
    if( StrmGetLexeme( stream, Count, TimeStr, TS_NUM, TL_FIXED, 4 ) )
      LocalTime = time( int(substr(TimeStr,1,2)), int(substr(TimeStr,3,2)), 0 );
      return ExecMacro2( MacroFill, LocalDate, LocalTime );
    end;
  end;
  return FALSE;
end;

/* Считать сумму */
macro ReadAmount( stream, Count, MacroFill )
  var Sum;

  if( ReadSum(stream, Count, Sum) )
    return ExecMacro2( MacroFill, Sum );
  else
    return FALSE;
  end;
end;

macro Read32A( stream, Count, MacroFill )
  var DateScr, Cur, Sum;

  /*MsgBox("Read32A: ", "Stream ", Stream, "Count ", Count );*/

  if( ReadDateYYMMDD(stream, Count, DateScr) AND ReadCur(stream, Count, Cur) AND ReadSum(stream, Count, Sum) )
    return ExecMacro2( MacroFill, DateScr, Cur, Sum );
  else
    return FALSE;
  end;
end;

macro Read32B( stream, Count, MacroFill )
  var Cur, Sum;

  if( ReadCur(stream, Count, Cur) AND ReadSum(stream, Count, Sum) )
    return ExecMacro2( MacroFill, Cur, Sum );
  else
    return FALSE;
  end;
end;

macro ReadCurSum( stream, Count, MacroFill )
  var Cur, Sum, Negative = FALSE;

  /* Первым символом может быть символ "N" */
  if( SubStr( Stream, 1, 1 ) == NEGATIVE_SYMB )
    Count = Count + 1;
    Negative = TRUE;
  end;

  if( ReadCur(stream, Count, Cur) AND ReadSum(stream, Count, Sum) )
    return ExecMacro2( MacroFill, Cur, Sum, Negative );
  else
    return FALSE;
  end;
end;


macro ReadAccNumb(
  Stream,
  Count,
  Account
)
  var AccNumb = "";

  /*MsgBox("ReadAccNumb: ", "Stream ", Stream, " Count ", Count );*/

  if( StrmGetLexeme( Stream, Count, AccNumb, TS_XSET, TL_MAX, 34, 0 ) )
    SetParm( 1, Count );
    SetParm( 2, AccNumb );
    return TRUE;
  end;
  return FALSE;
end;

macro ReadAccNumbEx(
  Stream,
  Count,
  Account
)
  var AccNumb = "";

  /*MsgBox("ReadAccNumbEx: ", "Stream ", Stream, " Count ", Count );*/

  /* Поля типа Account Identificator длиной _35x_ */
  if( StrmGetLexeme( Stream, Count, AccNumb, TS_XSET, TL_MAX, 35, 0 ) )
    SetParm( 1, Count );
    SetParm( 2, AccNumb );
    return TRUE;
  end;
  return FALSE;
end;
macro ReadCliring(
  Stream,
  Count,
  System,
  Code,
  Account
)
  var value = "";

  /*MsgBox("ReadCliring: ", "Stream ", Stream, " Count ", Count );*/

  if( StrmGetLexeme( Stream, Count, value, TS_XSET, TL_FIXED, 2 ) )
    SetParm( 1, Count );
    SetParm( 2, value );
    if( StrmGetLexeme( Stream, Count, value, TS_XSET, TL_MAX, 35, 0 ) )
      SetParm( 1, Count );
      if(index(value, "."))
          SetParm( 3, substr(value,1,(index(value, ".")-1)) );      
          SetParm( 4, substr(value,(index(value, "."))+1) );      
          return true;
      else
         SetParm( 3, value );      
      end;
      return TRUE;
    end;
  end;
  return FALSE;
end;

macro ReadNameAddress(
  Stream,
  Count,
  Address,
  INN
)
var NameAddress = "";
  var loc, KPPIndex = 0;
  /*MsgBox("ReadNameAddress: ", "Stream ", Stream, " Count ", Count );*/

  if( StrmGetLexeme( Stream, Count, NameAddress, TS_XSET, TL_BLOCK, 4, 35 ) )
    SetParm( 1, Count );        

    if(ValType(INN) != V_UNDEF)
    if ( substr(NameAddress, 1,3)=="INN" )       
       if ( Index(NameAddress, "\n") OR Index(NameAddress, " ") )
          if ( (Index(NameAddress, "\n")>0) AND 
               ( (Index(NameAddress, " ")==0) OR (Index(NameAddress, "\n")<Index(NameAddress, " ")) ) )
             loc = Index(NameAddress, "\n") - 1;
          else
             loc = Index(NameAddress, " ") - 1;
          end;
       else
          loc = strlen(NameAddress);
       end;              
       INN = substr( NameAddress, 4, loc-3 );
       NameAddress = substr( NameAddress, loc+2 );
    else 
       INN = "";
    end;
    SetParm( 2, NameAddress );
    KPPIndex = Index(INN, ".");
    if (KPPIndex > 0)
      INN = string(substr(INN, 1, KPPIndex-1), SYMB_SLASH, substr(INN, KPPIndex+4, loc-KPPIndex-6));
    end;
    SetParm( 3, INN );
    else
      SetParm( 2, NameAddress );
    end;

    return TRUE;
  end;
  return FALSE;
end;

macro Read25( Stream, Count, MacroFill )
  var Account = "";
  if( ReadAccNumbEx( Stream, Count, Account ) )
    return ExecMacro2( MacroFill, Account );
  end;
  return FALSE;
end;

macro Read28( Stream, Count, MacroFill )
  var Number = "", Page = 1, позиция;
  позиция = Index( Substr(Stream, Count), SYMB_SLASH );
  if( not позиция )
     Number = SubStr( Stream, Count, 5 );
     Page = 1;
  else
     Number = SubStr( Stream, Count, позиция-1 );
     Page = int( SubStr( Stream, позиция + 1, 5 ) );
  end;
  return ExecMacro2( MacroFill, Number, Page );
end;

macro ReadC( stream, Count, MacroFill )
  var StrmLen = StrLen(Stream), Account = "", System = "", Code = "";

  /* первый символ в строке - слэш "/" или двойной слэш "//" */
  if( (Count<=StrmLen) AND (SubStr(Stream, Count, 2) == SYMB_DSLASH) )
    Count = Count + 2;
    ReadCliring( Stream, Count, System, Code, Account  );
  elif( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) )
    Count = Count + 1;
    ReadAccNumb( Stream, Count, Account );
  end;

  SetParm( 1, Count );
  /*MsgBox( "Account :", Account, " System ", System, " Code ", Code ); */
  return ExecMacro2( MacroFill, Account, System, Code );
end;

macro ReadD( stream, Count, MacroFill )
  var StrmLen = StrLen(Stream), Address, Account, System, Code, INN = "", DKFlag = "D";
  
  /*MsgBox("ReadD: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* первый символ в строке - слэш "/" */
  if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) )
    Count = Count + 1;
    if( ((SubStr(Stream, Count, 1) == CREDIT_ACCOUNT) OR (SubStr(Stream, Count, 1) == DEBET_ACCOUNT)) AND
         (SubStr(Stream, Count+1, 1) == SYMB_SLASH) )
      DKFlag = SubStr(Stream, Count, 1);
      Count = Count + 1;
      if( (Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_SLASH) )
        Count = Count + 1;
        ReadAccNumb( Stream, Count, Account );
      end;
    elif( SubStr(Stream, Count, 1) == SYMB_SLASH )
      Count = Count + 1;
      ReadCliring( Stream, Count, System, Code, Account );
    else
      ReadAccNumb( Stream, Count, Account );
    end;
    if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_ENDL) )
      Count = Count + 1;
      ReadNameAddress( Stream, Count, Address, INN );
    end;
  else
    ReadNameAddress( Stream, Count, Address, INN );
  end;
  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  return ExecMacro2( MacroFill, Address, Account, System, Code, INN, DKFlag );
end;

macro ReadD_( stream, Count, MacroFill )
  var StrmLen = StrLen(Stream), Address, Account, System, Code, DKFlag = "D";
  /*MsgBox("ReadD: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* первый символ в строке - слэш "/" */
  if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) )
    Count = Count + 1;
    if( ((SubStr(Stream, Count, 1) == CREDIT_ACCOUNT) OR (SubStr(Stream, Count, 1) == DEBET_ACCOUNT)) AND
         (SubStr(Stream, Count+1, 1) == SYMB_SLASH) )
      DKFlag = SubStr(Stream, Count, 1);
      Count = Count + 1;
      if( (Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_SLASH) )
        Count = Count + 1;
        ReadAccNumb( Stream, Count, Account );
      end;
    elif( SubStr(Stream, Count, 1) == SYMB_SLASH )
      Count = Count + 1;
      ReadCliring( Stream, Count, System, Code, Account );
    else
      ReadAccNumb( Stream, Count, Account );
    end;
    if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_ENDL) )
      Count = Count + 1;
      ReadNameAddress( Stream, Count, Address );
    end;
  else
    ReadNameAddress( Stream, Count, Address );
  end;
  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  return ExecMacro2( MacroFill, Address, Account, System, Code, "", DKFlag );
end;

macro ReadBIC( Stream, Count, CodeBIC )
 var
  BankBIC     = "",
  CountryBIC  = "",
  LocationBIC = "",
  BranchBIC   = "",
  BIC         = "";

  if( StrmGetLexeme( Stream, Count, BankBIC, TS_ALPHA, TL_FIXED, 4 )
      AND StrmGetLexeme( Stream, Count, CountryBIC, TS_ALPHA, TL_FIXED, 2 )
      AND StrmGetLexeme( Stream, Count, LocationBIC, TS_ALPNUM, TL_FIXED, 2 )
    )
    BIC = BankBIC + CountryBIC + LocationBIC;
    if( StrmGetLexeme( Stream, Count, BranchBIC, TS_ALPNUM, TL_FIXED, 3 )
        /*AND (BranchBIC != КодОтделенияПоУмолчанию ) */
    )
      BIC = BIC + BranchBIC;
    end;

    SetParm( 1, Count );
    SetParm( 2, BIC );
    return TRUE;
  end;
  return false;
end;

macro ReadBEI( stream, Count, MacroFill )
  var BEI;
  if( ReadBIC( Stream, Count, BEI ) )
    SetParm( 1, Count ); 
    return ExecMacro2( MacroFill, BEI );
  else
    return FALSE;
  end;
end;

macro ReadA( stream, Count, MacroFill )
  var StrmLen = StrLen(Stream), BIC, Account, System, Code, DKFlag = "D";

  /* MsgBox("ReadA: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen ); */

  /* первый символ в строке - слэш "/" */
  if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) )
    Count = Count + 1;
    if( ((SubStr(Stream, Count, 1) == CREDIT_ACCOUNT) OR (SubStr(Stream, Count, 1) == DEBET_ACCOUNT)) AND
         (SubStr(Stream, Count+1, 1) == SYMB_SLASH) )
      DKFlag = SubStr(Stream, Count, 1);
      Count = Count + 1;
      if( (Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_SLASH) )
        Count = Count + 1;
        ReadAccNumb( Stream, Count, Account );
      end;
    elif( SubStr(Stream, Count, 1) == SYMB_SLASH )
      Count = Count + 1;
      ReadCliring( Stream, Count, System, Code, Account );
    else
      ReadAccNumb( Stream, Count, Account );
    end;
    if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_ENDL) )
      Count = Count + 1;
      ReadBIC( Stream, Count, BIC )
    end;
  else
    ReadBIC( Stream, Count, BIC );
  end;
  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  return ExecMacro2( MacroFill, BIC, Account, System, Code, DKFlag );
end;

macro ReadF( stream, Count, MacroFill )
  var Len = StrLen(Stream), Name = "", buf = "", Account, ind = 0;
  if( (Count<=Len) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) ) //если первая строка начинается с "/" получаем счет
    Count = Count + 1;
    ReadAccNumb( Stream, Count, Account );
    Count = Count + 1;
  end;
  if( Index(substr(stream, count ), "1/") ) //если нашли строку, начинающуюся с  "1/"
   
    buf = substr(stream, count);  //Обрезаем все, что идет до "1/"

    while ((ind = index (buf, SYMB_ENDL)) AND (index(substr(buf,1,1),"1"))) //Пока строка не последняя и начинается на "1"
        name = name + substr(buf, 3 , ind-3) + " ";                         //Плюсуем к наим. все в этой строке, идущее после "1/"
        buf = substr(buf, ind + 1);                                         //Обрезаем эту строку
    end;

    if(ind = Index(substr(buf, 1, 2), "1/"))    //Если последняя строка начинается с "1/"
      name = name + substr(buf, ind + 2);                                                 //Добавляем к наим. все оставшееся     
    end;                                                                 

  end;
  trim(Name);
  SetParm (1, Count);
  return ExecMacro2( MacroFill, Name, Account); 
end;

macro ReadBranch( Stream, Count, CodeBranch )
  var Branch = "";
  /* здесь стоит считывание блока из 1-й строки, чтобы подключить проверку на слишком длинную строку */
  if( StrmGetLexeme( Stream, Count, Branch, TS_XSET, TL_BLOCK, 1, 35 )  )
    SetParm( 1, Count );
    SetParm( 2, Branch );
    return TRUE;
  end;
end;

macro ReadB( stream, Count, MacroFill )
  var StrmLen = StrLen(Stream), Branch, Account, System, Code, DKFlag = "D";

  /*MsgBox("ReadB: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* первый символ в строке - слэш "/" */
  if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_SLASH) )
    Count = Count + 1;
    if( ((SubStr(Stream, Count, 1) == CREDIT_ACCOUNT) OR (SubStr(Stream, Count, 1) == DEBET_ACCOUNT)) AND
         (SubStr(Stream, Count+1, 1) == SYMB_SLASH) )
      DKFlag = SubStr(Stream, Count, 1);
      Count = Count + 1;
      if( (Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_SLASH) )
        Count = Count + 1;
        ReadAccNumb( Stream, Count, Account );
      end;
    elif( SubStr(Stream, Count, 1) == SYMB_SLASH )
      Count = Count + 1;
      ReadCliring( Stream, Count, System, Code, Account );
    else
      ReadAccNumb( Stream, Count, Account );
    end;
    if( (Count<=StrmLen) AND (SubStr(Stream, Count, 1) == SYMB_ENDL) )
      Count = Count + 1;
      ReadBranch( Stream, Count, Branch )
    end;
  else
    ReadBranch( Stream, Count, Branch );
  end;
  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  return ExecMacro2( MacroFill, Branch, Account, System, Code, DKFlag );
end;

macro ReadJ( stream, Count, MacroFill )
  var StrmLen = StrLen(Stream), BIC, Account, System = "", Code, Narrative, Name;

  /*MsgBox("ReadB: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  if( StrmGetLexeme( Stream, Count, Narrative, TS_XSET, TL_BLOCK, 5, 40 ) )
    PrintLog(3,"ReadJ: " + Narrative);
    ReadCodeWord( Stream, Count, Narrative, 5, 40, 4 );
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    BIC     = СчитатьКодПоля( OptionJCodesABIC );
    if( (BIC != "") AND (BIC == CodeUnknownBIC) )
      BIC = "";
    end;
    Account = СчитатьКодПоля( OptionJCodesACCT );
    Name    = СчитатьКодПоля( OptionJCodesNAME );

    Code    = СчитатьКодПоля( OptionJCodesUSFW ); 
    if( Code != "" )
      System = CODEWORLD_FEDWIRE;
    else
      Code   = СчитатьКодПоля( OptionJCodesUSCH );
    end;
    return ExecMacro2( MacroFill, BIC, Name, Account, System, Code );
  end;
  return FALSE;
end;

macro Read70( Stream, Count, MacroFill )
  var Str = "";
  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 4, 35 ) )
    PrintLog(3,"Read70: "+Str);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read72( Stream, Count, MacroFill )
  var Str = "", Narrative = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 6, 35 ) )
    PrintLog(3,"Read72: "+Str);
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str, Narrative );
  end;
  return FALSE;
end;

macro Read75_76( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 6, 35 ) )
    PrintLog(3,"Read75: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read77A( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 20, 35 ) )
    PrintLog(3,"Read77A: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read77B( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 3, 35 ) )
    PrintLog(3,"Read77B: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read77E( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 125, 78 ) )
    PrintLog(3,"Read77E: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read77T( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 150, 60 ) )
    PrintLog(3,"Read77T: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read79( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 35, 50 ) )
    PrintLog(3,"Read79: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro ReadMFIELDS( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 35, 55 ) )
    PrintLog(3,"MFIELDS: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read86( Stream, Count, MacroFill )
  var Str = "";

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 6, 65 ) )
    PrintLog(3,"Read86: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read71A( Stream, Count, MacroFill )
  var ComissCharges;
   ComissCharges = SubStr( Stream, Count, 3 );
    Count = Count + 3;
  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
  return ExecMacro2( MacroFill, GetCommisNum(ComissCharges) );
end;

macro Read71B( Stream, Count, MacroFill )
  var Str;

  if( StrmGetLexeme( Stream, Count, Str, TS_XSET, TL_BLOCK, 6, 35 ) )
    PrintLog(3,"Read71B: "+Str);
    Count = 1;
    SetParm( 1, Count ); /* запись в 1-й аргумент!*/
    return ExecMacro2( MacroFill, Str );
  end;
  return FALSE;
end;

macro Read94B( Stream, Count, MacroFill )
  var Qualifier, Scheme="", PlaceCode, Narrative = "";  
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 6 ) )
     Qualifier = substr(Qualifier,2,4);     
     if ( substr(Stream, Count, 1)!=SYMB_SLASH )
        if( not StrmGetLexeme( Stream, Count, Scheme, TS_ALPNUM, TL_MAX, 8 ) )
            PrintLog(3,"Read94B: Ошибка формата" );
            return false;
        end;
     end;     
     if ( substr(Stream, Count, 1)==SYMB_SLASH )
       /* Пропускаем слеш */
       Count = Count+1;                                   
       if( StrmGetLexeme( Stream, Count, PlaceCode, TS_ALPNUM, TL_FIXED, 4 ) )
          if ( substr(Stream, Count, 1)==SYMB_SLASH )
             /* Пропускаем слеш */
             Count = Count+1;
             if( not StrmGetLexeme( Stream, Count, Narrative, TS_XSET, TL_MAX, 30 ) )
                 PrintLog(3,"Read94B: Ошибка формата" );
                 return false;
             end;
          end;           
          PrintLog(3,"Read94B: " + Qualifier );
          SetParm( 1, Count ); /* запись в 1-й аргумент!*/
          return ExecMacro2( MacroFill, Qualifier, Scheme, PlaceCode, Narrative );
       end;
     end;
  end;
  PrintLog(3,"Read94B: Ошибка формата" );
  return false;
end;

macro Read94F( Stream, Count, MacroFill )
  var Qualifier, PlaceCode, BIC;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);     
     if( StrmGetLexeme( Stream, Count, PlaceCode, TS_ALPNUM, TL_FIXED, 4 ) )
         if ( substr(Stream, Count, 1)==SYMB_SLASH )
            /* Пропускаем слеш */
            Count = Count+1;
            if( not StrmGetLexeme( Stream, Count, BIC, TS_ALPNUM, TL_MAX, 11 ) )
                PrintLog(3,"Read94F: Ошибка формата" );
                return false;
            end;
            PrintLog(3,"Read94F: " + Qualifier );
            SetParm( 1, Count ); /* запись в 1-й аргумент!*/
            return ExecMacro2( MacroFill, Qualifier, PlaceCode, BIC );
         end;
      end;
  end;
  PrintLog(3,"Read94F: Ошибка формата" );
  return false;
end;

macro Read90A( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read90B( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read99A( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read12A( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read12B( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read12C( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read11A( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read17B( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read19A( Stream, Count, MacroFill )
   var Qualifier, Sign=false, Cur, Sum;

   if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);     
     if ( substr(Stream, Count, 1)=="N" )
       if( not StrmGetLexeme( Stream, Count, Cur, TS_ALPHA, TL_MAX, 4 ) )
          PrintLog(3,"Read19A: Ошибка формата" );
          return false;
       end;
       if ( strlen(Cur)==4 )
          Sign = true;
          Cur = substr(Cur,2);
       elif ( strlen(Cur)<3 )
          PrintLog(3,"Read19A: Ошибка формата" );
          return false;
       end;
     else
       if ( not ReadCur(stream, Count, Cur) )
          PrintLog(3,"Read19A: Ошибка формата" );
          return false;
       end;
     end;

     if ( ReadSum(stream, Count, Sum) )
         PrintLog(3,"Read19A: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, Sign, Cur, Sum );
     end;
   end;
   PrintLog(3,"Read19A: Ошибка формата" );
   return false;
end;

macro Read70C( Stream, Count, MacroFill )
  var Qualifier, Narrative;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);
     if( StrmGetLexeme( Stream, Count, Narrative, TS_XSET, TL_BLOCK, 4, 35 ) )
         PrintLog(3,"Read70C: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, Narrative );
     end;
  end;
  PrintLog(3,"Read70C: Ошибка формата" );
  return false;
end;

macro Read70D( Stream, Count, MacroFill )
  var Qualifier, Narrative;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);
     if( StrmGetLexeme( Stream, Count, Narrative, TS_XSET, TL_BLOCK, 6, 35 ) )
         PrintLog(3,"Read70D: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, Narrative );
     end;
  end;
  PrintLog(3,"Read70D: Ошибка формата" );
  return false;
end;

macro Read70E( Stream, Count, MacroFill )
  var Qualifier, Narrative;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);
     if( StrmGetLexeme( Stream, Count, Narrative, TS_XSET, TL_BLOCK, 10, 35 ) )
         PrintLog(3,"Read70E: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, Narrative );
     end;
  end;
  PrintLog(3,"Read70E: Ошибка формата" );
  return false;
end;

macro Read92A( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read92B( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read92C( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read95C( Stream, Count, MacroFill )
  var Qualifier, CountryCode;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);
     if( StrmGetLexeme( Stream, Count, CountryCode, TS_ALPHA, TL_FIXED, 2 ) )
         PrintLog(3,"Read95C: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, CountryCode );
     end;
  end;
  PrintLog(3,"Read95C: Ошибка формата" );
  return false;
end;

macro Read95P( Stream, Count, MacroFill )
  var Qualifier, BIC;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);
     if( StrmGetLexeme( Stream, Count, BIC, TS_ALPNUM, TL_MAX, 11 ) )
         PrintLog(3,"Read95P: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, BIC );
     end;
  end;
  PrintLog(3,"Read95P: Ошибка формата" );
  return false;
end;

macro Read95R( Stream, Count, MacroFill )
  var Qualifier, Scheme="", PropCode;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 6 ) )
     Qualifier = substr(Qualifier,2,4);
     if ( substr(Stream, Count, 1)!="/" )
         if( not StrmGetLexeme( Stream, Count, Scheme, TS_ALPNUM, TL_MAX, 8 ) )
             PrintLog(3,"Read95R: Ошибка формата" );
             return false;
         end;
     end;
     if ( substr(Stream, Count, 1)=="/" )
        count = count + 1;
        if( StrmGetLexeme( Stream, Count, PropCode, TS_XSET, TL_MAX, 34 ) )
            PrintLog(3,"Read95R: " + Qualifier );
            SetParm( 1, Count ); /* запись в 1-й аргумент!*/
            return ExecMacro2( MacroFill, Qualifier, Scheme, PropCode );
        end;
     end;
  end;
  PrintLog(3,"Read95R: Ошибка формата" );
  return false;
end;

macro Read95Q( Stream, Count, MacroFill )
  var Qualifier, Address;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
     Qualifier = substr(Qualifier,2,4);
     if( StrmGetLexeme( Stream, Count, Address, TS_XSET, TL_BLOCK, 4, 35 ) )
         PrintLog(3,"Read95Q: " + Qualifier );
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, Address );
     end;
  end;
  PrintLog(3,"Read95Q: Ошибка формата" );
  return false;
end;

macro Read95S( Stream, Count, MacroFill )
  var Qualifier, Scheme="", TypeID, CountryCode, AlternateID;
  if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 6 ) )
     Qualifier = substr(Qualifier,2,4);
     if ( substr(Stream, Count, 1)!="/" )
         if( not StrmGetLexeme( Stream, Count, Scheme, TS_ALPNUM, TL_MAX, 8 ) )
             PrintLog(3,"Read95S: Ошибка формата" );
             return false;
         end;
     end;
     if ( substr(Stream, Count, 1)=="/" )
        count = count + 1;
        if( StrmGetLexeme( Stream, Count, TypeID, TS_XSET, TL_FIXED, 4 ) )
            count = count + 1;
            if( StrmGetLexeme( Stream, Count, CountryCode, TS_ALPHA, TL_FIXED, 2 ) )
               count = count + 1;
               if( StrmGetLexeme( Stream, Count, AlternateID, TS_XSET, TL_MAX, 30 ) )               
                  PrintLog(3,"Read95S: " + Qualifier );
                  SetParm( 1, Count ); /* запись в 1-й аргумент!*/
                  return ExecMacro2( MacroFill, Qualifier, Scheme, TypeID, CountryCode, AlternateID );
                end;
            end;
        end;
     end;
  end;
  PrintLog(3,"Read95S: Ошибка формата" );
  return false;
end;

macro Read99B( Stream, Count, MacroFill )
   /* Пока не используется, пропускаем */
   return true;
end;

macro Read35B( Stream, Count, MacroFill )
   var ISIN = "", Description="";
   if ( substr(Stream, Count, 4)=="ISIN" )
      Count = Count+4;
      if( not StrmGetLexeme(Stream, Count, ISIN, TS_XSET, TL_FIXED, 13) )
         PrintLog(3,"Read35B: Ошибка формата" );
         return false;
      end;
   end;
   StrmGetLexeme( Stream, Count, Description, TS_XSET, TL_BLOCK, 4, 35 );
   PrintLog(3,"Read35B");
   SetParm( 1, Count ); /* запись в 1-й аргумент!*/
   return ExecMacro2( MacroFill, ISIN, Description );
end;

macro Read36B( Stream, Count, MacroFill )
   var Qualifier, Code, Sum;
   if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
      Qualifier = substr(Qualifier,2,4);
      if( StrmGetLexeme( Stream, Count, Code, TS_ALPNUM, TL_FIXED, 4 ) )
        Count = Count + 1;
        if ( ReadSum(Stream, Count, Sum) )
           PrintLog(3,"Read36B:" + Qualifier);
           SetParm( 1, Count ); /* запись в 1-й аргумент!*/
           return ExecMacro2( MacroFill, Qualifier, Code, Sum );
        end;
      end;
   end;
   PrintLog(3,"Read36B: Ошибка формата");
   return false;
end;

macro Read97A( Stream, Count, MacroFill )
   var Qualifier, Account;
   if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 7 ) )
      Qualifier = substr(Qualifier,2,4);
      if( StrmGetLexeme( Stream, Count, Account, TS_XSET, TL_MAX, 35 ) )
         PrintLog(3,"Read97A:"+Qualifier);
         SetParm( 1, Count ); /* запись в 1-й аргумент!*/
         return ExecMacro2( MacroFill, Qualifier, Account );
      end;
   end;
   PrintLog(3,"Read97A: Ошибка формата");
   return false;
end;

macro Read97B( Stream, Count, MacroFill )
   var Qualifier, Scheme="", CodeType, Account;
   if( StrmGetLexeme( Stream, Count, Qualifier, TS_XSET, TL_FIXED, 6 ) )
      Qualifier = substr(Qualifier,2,4);
      if ( substr(Stream, Count, 1)!="/" )
         if( not StrmGetLexeme( Stream, Count, Scheme, TS_ALPNUM, TL_MAX, 8 ) )
            PrintLog(3,"Read97B: Ошибка формата");
            return false;
         end;
      end;
      if ( substr(Stream, Count, 1)=="/" )
         count = count + 1;
         if( StrmGetLexeme( Stream, Count, CodeType, TS_ALPNUM, TL_FIXED, 4 ) )
            if( StrmGetLexeme( Stream, Count, Account, TS_XSET, TL_MAX, 35 ) )
               PrintLog(3,"Read97B:"+Qualifier);
               SetParm( 1, Count ); /* запись в 1-й аргумент!*/
               return ExecMacro2( MacroFill, Qualifier, Scheme, CodeType, Account );
            end;
         end;
      end;
   end;
   PrintLog(3,"Read97B: Ошибка формата");
   return false;
end;

macro ReadBal( Stream, Count, MacroFill )
  var DKFlag = "", DateBal, Cur, Sum, StrmLen = StrLen(Stream);

  /*MsgBox("ReadBal: ", "Stream ", Stream, " Count ", Count, " StrmLen: ",  StrmLen );*/

  /* Признак дебета/кредита. Возможные значения: D - дебет, C - кредит, */
  if( (SubStr( Stream, Count, 1 ) == CREDIT_ACCOUNT) OR
      (SubStr( Stream, Count, 1 ) == DEBET_ACCOUNT) )
     DKFlag = SubStr( Stream, Count, 1 );
     Count = Count + 1;
  end;
  if( ReadDateYYMMDD(Stream, Count, DateBal) AND ReadCur(Stream, Count, Cur) AND ReadSum(Stream, Count, Sum) )
    /*MsgBox("DKFlag ", DKFlag, " DateBal :", DateBal, " Cur :", Cur, "Sum :", Sum);*/
    return ExecMacro2( MacroFill, DKFlag, DateBal, Cur, Sum );
  else
    return FALSE;
  end;
end;

/* Класс разбора сообщения в своем формате */
class TPrpMes( MesType, str )
    var Type, Message;
    /* Здесь следует добавить ряд переменных, необходимых для
       сообщения в собственном формате */

    macro FieldFields
        /* Здесь можно заполнить поля сообщения по собственному формату */
    end;

    macro IsSet
       /* Возвращает TRUE если сообщение заполнено верно */
       return TRUE;
    end;

    /* Инициализация */
    if ( valtype(MesType)==V_UNDEF )
       Type = "";
    else
       Type = MesType;
    end;

    if ( valtype(str)==V_UNDEF )
       Message = "";
    else
       Message = str;
    end;
    FieldFields();
end;

macro Parse26T_Tax(Str)
  var Code="";

  if (Str != "")
    Code = substr(Str, 2);
  end;

  return Code;
end;

macro Parce77B_Tax(Str, BttTICode, OKATOCode, TaxPmGround, TaxPmPeriod, 
                        TaxPmNumber, TaxPmDate, TaxPmType)
  var i, j;
  var TaxPmProp = TArray(7);

  /* Первым делом вырезаем SYMB_ENDL */
  i = Index(Str, SYMB_ENDL);
  while (i != 0)
    Str = substr(Str, 1, i-1) + substr(Str, i+1);
    i = Index(Str, SYMB_ENDL);
  end;
  Str = Str + SYMB_SLASH; /* чтобы прочитать последнее значение */

  i = Index(Str, SYMB_SLASH);
  j = 0;
  while (i != 0)
    /* Вырезаем код */
    Str = substr(Str, i+1);
    i = Index(Str, SYMB_SLASH);
    Str = substr(Str, i+1);

    /* Получаем значение */
    i = Index(Str, SYMB_SLASH);
    TaxPmProp(j) = substr(Str, 1, i-1);
   /* #146858. 
    Хотят, чтобы если 0, то 0 и проставился. По крайней мере, так должно быть для TaxPmNumber. Для других параметров, скорее всего, не будет некорректно
    if (TaxPmProp(j) == "0")
      TaxPmProp(j) = "";
    end;
   */
    j = j + 1;
  end;
  
  j = 1;
  while (j < 7)
    SetParm(j, TaxPmProp(j));
    j = j + 1;
  end;

  SetParm(7, TaxPmProp(0));
end;

macro Read50F(stream, Count, MacroFill)
  var StrmLen = StrLen(Stream), Account = "", CodeKind = 0, Code = "", _Code = "", INN = "", Name = "", str6 = "", str8 = "", Temp = "";
  var KPPIndex = 0;
  
  
  if((Count<=StrmLen) AND ( SubStr(Stream, Count, 5) == "CUST/") )
    CodeKind = PTCK_CLIENT;  
  elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 5) == "EMPL/") )
    CodeKind = PTCK_EIN;
  elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 5) == "IBEI/") )
    CodeKind = PTCK_IBEI;
  elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 5) == "NIDN/") )
    CodeKind = PTCK_NATCOD;
  elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 5) == "SOSE/") )
    CodeKind = PTCK_SSN;
  elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 5) == "TXID/") )
    CodeKind = PTCK_INN;
  elif( (Count<=StrmLen) AND 
        ((SubStr(Stream, Count, 5) == "ARNU/") OR 
         (SubStr(Stream, Count, 5) == "CCPT/") OR
         (SubStr(Stream, Count, 5) == "DRLC/")))
    CodeKind = 0;
    StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_MAX, 30 );
    Code = "";
  elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_SLASH) )
    Count = Count + 1;
    ReadAccNumb( Stream, Count, Account );
  else
    return false;
  end;

  if(CodeKind != 0)
    Count = Count + 5;
    if((SubStr(Stream, Count, 3) == "RU/"))
      Count = Count + 3;
      StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_MAX, 27 );
    elif(CodeKind == PTCK_IBEI)
      StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_MAX, 30 );
    else
      CodeKind = 0;
      StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_MAX, 30 );
      Code = "";
    end;
  end;
 
  if((Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_ENDL))
    Count = Count + 1;
  end;

  while((Count<=StrmLen))
    Temp = "";
    if  ( SubStr(Stream, Count, 2) == "1/" )
      Count = Count + 2;
      StrmGetLexeme( Stream, Count, Temp, TS_XSET, TL_MAX, 33 );
      
      if( substr(Temp, 1,3) == "INN" )
        CodeKind = PTCK_INN;
        KPPIndex = Index(Temp, ".");
        if( KPPIndex != 0 )
          Code = substr(Temp, KPPIndex+4);
          if (Code == "000000000")
            Code = "0";
          end;
          Code = string(substr(Temp, 4, KPPIndex-4), SYMB_SLASH, Code);
        else
          Code = substr(Temp, 4);
        end;
      else
        Name = Name + Temp;
      end;
    elif( ( SubStr(Stream, Count, 2) == "2/") or ( SubStr(Stream, Count, 2) == "3/") or ( SubStr(Stream, Count, 2) == "4/") or ( SubStr(Stream, Count, 2) == "5/"))
      Count = Count + 2;
      StrmGetLexeme( Stream, Count, Temp, TS_XSET, TL_MAX, 33 );
    elif( SubStr(Stream, Count, 2) == "6/" )
      Count = Count + 2;
      StrmGetLexeme( Stream, Count, Temp, TS_XSET, TL_MAX, 33 );      
      str6 = str6 + Temp;
    elif( SubStr(Stream, Count, 2) == "7/" )
      Count = Count + 2;
      if((SubStr(Stream, Count, 3) == "RU/") and (CodeKind == 0))
        Count = Count + 3;
        CodeKind = PTCK_NATCOD;
        StrmGetLexeme( Stream, Count, Code, TS_XSET, TL_MAX, 27 );    
      else
        StrmGetLexeme( Stream, Count, Temp, TS_XSET, TL_MAX, 33 );
      end;
    elif((Count<=StrmLen) AND ( SubStr(Stream, Count, 2) == "8/"))
      Count = Count + 2;
      StrmGetLexeme( Stream, Count, str8, TS_XSET, TL_MAX, 33 );
      if( Account != "" )
        Account = Account + str8;
      elif( Code != "" )
        Code = Code + str8;
      end;
    else
      return false;
    end;
    if((Count<=StrmLen) AND ( SubStr(Stream, Count, 1) == SYMB_ENDL))
      Count = Count + 1;
    end;
  end;
  
  if( (str6 != "") and (SubStr(str6, 1, 3) == "RU/") and (CodeKind == 0))
    str6 = substr(str6,4);    
    if( index(str6,SYMB_SLASH) )
      CodeKind = PTCK_CLIENT;
      Code = substr(str6,index(str6,SYMB_SLASH)+1);
    end;
  end;
  
  return ExecMacro2( MacroFill, Account, CodeKind, Code, Name);
end;



macro startsWithSYMB_SLASH( strVal )
  return SubStr(strVal, 1, 1) == SYMB_SLASH;
end;

macro startsWithSYMB_DSLASH( strVal )
  return SubStr(strVal, 1, 2) == SYMB_DSLASH;
end;

macro notStartsWithSYMB_SLASH( strVal )
  return not startsWithSYMB_SLASH( strVal );
end;

macro startsWithINN( strVal )
  return SubStr(strVal, 1, 3) == "INN";
end;

macro notStartsWithINN( strVal )
  return not startsWithINN( strVal );
end;

macro ReadBlock57a( option, isRUR, stream, Count, MacroFill )

  var lineFieldArray;
  var StrmLen = StrLen(stream);
  var BIC, Name, Account, CliringSystem, CliringCode, INN;
  
  if( startsWithSYMB_DSLASH( stream ) )
    Count = Count + 2;
    ReadCliring( Stream, Count, CliringSystem, CliringCode, Account );

  elif( startsWithSYMB_SLASH( stream ) )
    
    if( InList(SubStr(stream, 1, 3), SYMB_SLASH+CREDIT_ACCOUNT+SYMB_SLASH, SYMB_SLASH+DEBET_ACCOUNT+SYMB_SLASH) )
      Count = Count + 3;
    else
      Count = Count + 1;
    end;

    ReadAccNumb( stream, Count, Account );

  end;
  
  // Следующий символ вполне может быть переводом строки, поэтому надо стать на следующий
  if((Count<=StrmLen) AND (SubStr(stream, Count, 1) == SYMB_ENDL))
    Count = Count + 1;
  end;

  if( option == SWIFT_Tag_A )

    ReadBIC( stream, Count, BIC );
  
  elif( option == SWIFT_Tag_B )
    
    lineFieldArray = split( stream, SYMB_ENDL ); // массив строк поля
    lineFieldArray = filter( lineFieldArray, "notStartsWithSYMB_SLASH" ); // удаляем из массива все строки, которые начинается с слеша
    Name = join( lineFieldArray,  SYMB_ENDL );

  elif( (option == SWIFT_Tag_C) and not startsWithSYMB_SLASH( stream ) and not startsWithSYMB_DSLASH( stream ) )

    ReadBIC( stream, Count, BIC );

  elif( option == SWIFT_Tag_D )
    
    lineFieldArray = split( stream, SYMB_ENDL ); // массив строк поля

    lineFieldArray = filter( lineFieldArray, "notStartsWithSYMB_SLASH" ); // удаляем из массива все строки, которые начинается с слеша

    if(isRUR)
      var INNline = filter( lineFieldArray, "startsWithINN" ); 
      
      if( INNline.size() > 0 )
        INN = SubStr(INNline[0], 4);
        lineFieldArray = filter( lineFieldArray, "notStartsWithINN" ); // Удаляем строку с INN
      end;
      
      Name = join( lineFieldArray,  SYMB_ENDL );
    else
      Name = join( lineFieldArray,  SYMB_ENDL );
    end;
  end; 
  
  return ExecMacro2( MacroFill, BIC, Name, Account, CliringSystem, CliringCode, INN );
end;


macro ReadBlock57aTag_A( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_A, false, stream, Count, MacroFill )
end;

macro ReadBlock57aTag_B( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_B, false, stream, Count, MacroFill )
end;

macro ReadBlock57aTag_C( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_C, false, stream, Count, MacroFill )
end;

macro ReadBlock57aTag_D( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_D, false, stream, Count, MacroFill )
end;

macro ReadBlock57aTag_A_RUR( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_A, true, stream, Count, MacroFill )
end;

macro ReadBlock57aTag_B_RUR( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_B, true, stream, Count, MacroFill )
end;

macro ReadBlock57aTag_D_RUR( stream, Count, MacroFill )
  return ReadBlock57a( SWIFT_Tag_D, true, stream, Count, MacroFill )
end;

