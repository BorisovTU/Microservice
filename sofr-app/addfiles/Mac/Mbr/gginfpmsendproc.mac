/*
  $Name:         gginfpmsendproc.mac
  $Module:       Межбанковские расчеты
  $Description:  Функции взаимодействия RS-Banking с RS-Connect по сообщениям в ГИС ГМП
*/

//-----------------------------------------------------------------------------
//          Автоматизированная банковская система RS-Bank               
//                 Copyright (c) R-Style Software Lab
//
// Подсистема   : Межбанковские расчеты
//
// Описание     : Функции взаимодействия RS-Banking с RS-Connect по сообщениям в ГИС ГМП
//
// Программист  : Kolyakin V.V.
//
// Создан       : 21.08.2018
//
//-----------------------------------------------------------------------------

import PTInter, CTInter, likepy, oralib, wltools, bnk_dttmfrmt, bnk_ptlib, bnk_dttmfrmt, bnk_common, wltools, PaymInter, pm_common, wluftool, gginfpmsendconst, gginfpmsendrep, ws_gmp_sendpayment;

private const SET_CHAR = "X";
private const UNSET_CHAR = "";

macro ClearLogGGPIPmSend
  execStoredFunc( "WLD_GGPMSEND.ClearLogGGPIPmSend", V_UNDEF, null );
end;

macro AddRecLogGGPIPmSend(PmsendID : integer)
  var params : TArray = makeArray( SQLParam("p_PmsendID", PmsendID) );
  execStoredFunc( "WLD_GGPMSEND.AddRecLogGGPIPmSend", V_UNDEF, params );
end;


// Данные для транзакции                                                                                                            
class ProcessTrnParm( _ggcp, _PmSendIDs, _ActionParam, _gisgmpmsg, _RS_Connect_URL:string, _SenderID:string, _Department:string, _Branch:string, _BeginDate:date, _EndDate:date )
  
  var RS_Connect_Url = null;
  var SenderID:string = "";
  var PmSendIDs = null;
  var gisgmpmsg = null;
  var ggcp = 0;
  var ActionParam = 0;

  var Department:string = ""; 
  var Branch:string = "";
  var BeginDate:date = date(0,0,0);
  var EndDate:date = date(0,0,0);

  macro Construct( _ggcp, _PmSendIDs, _ActionParam, _gisgmpmsg, _RS_Connect_URL:string, _SenderID:string, _Department:string, _Branch:string, _BeginDate:date, _EndDate:date )
    RS_Connect_Url = _RS_Connect_Url;
    SenderID = _SenderID;
    PmSendIDs = _PmSendIDs;
    gisgmpmsg = _gisgmpmsg;
    ggcp = _ggcp;
    ActionParam = _ActionParam;
    Department = _Department;
    Branch = _Branch;
    BeginDate = _BeginDate;
    EndDate = _EndDate;
  end;

  Construct( _ggcp, _PmSendIDs, _ActionParam, _gisgmpmsg, _RS_Connect_URL, _SenderID, _Department, _Branch, _BeginDate, _EndDate );
end;

// Глобализм в котором хранятся параметры транзакции
private var g_TrnParm:ProcessTrnParm = null;

private var FlagCtrlBrk:bool = false;
private var CtrlBrkErr = 17;

private macro getRSConnectUrl(RS_Connect_URL:@string) : integer

  var err = 0;

  var RS_Connect_URL_Path = "RS-CONNECT\\ГИС_ЖКХ\\URL";
  GetRegistryValue( RS_Connect_URL_Path, V_STRING, RS_Connect_URL, err );
  if( ( err != 0 ) )
    CreateErrMsg( BNK_ERROR_MACROS_STR, "Ошибка при получении значения настройки: " + RS_Connect_URL_Path );
  end;
  if( RS_Connect_URL == "" )
    CreateErrMsg( BNK_ERROR_MACROS_STR, "Отсутствует значение настройки: " + RS_Connect_URL_Path );
    err = 1;
  end;
  return err;
end;

private macro getSenderID(SenderID:@string) : integer

  var err = 0;

  var SenderID_Path = "RS-CONNECT\\SENDERID\\BANKING";
  GetRegistryValue( SenderID_Path, V_STRING, SenderID, err );
  if( ( err != 0 ) )
    CreateErrMsg( BNK_ERROR_MACROS_STR, "Ошибка при получении значения настройки: " + SenderID_Path );
  end;
  if( SenderID == "" )
    CreateErrMsg( BNK_ERROR_MACROS_STR, "Отсутствует значение настройки: " + SenderID_Path );
    err = 1;
  end;
  return err;
end;

macro PaymsBdTransfsSelection( gisgmpmsg:TRecHandler ):RsdRecordSet

  var tmpStateCode = "";

  var select = " ( " + 
                    " select pm.t_PaymentID as t_ObjectID, :ObjectTypePayment as t_ObjectType, pm.t_Department as t_Department, pm.t_OperNode as t_Branch " +
                    "  from dpmpaym_dbt pm, dpmrmprop_dbt rm                            "  +
                    " where pm.t_PaymentID = rm.t_PaymentID                                 " +
                    "   and pm.t_BaseFIID = :BaseFIID                                       " +
                    "   and rm.t_PayerChargeOffDate <> to_date('0001-01-01','yyyy-mm-dd')   " +
                    "   and pm.t_DocKind IN ( select oprd.t_DocKind from doprkdoc_dbt oprd  " +
                    "                         start with oprd.t_DocKind = 29          " +
                    "              connect by prior oprd.t_DocKind = oprd.t_ParentDockind ) " +
                    "  and pm.t_DocKind NOT IN ( 400, 286, 311, 320, 322 )                  " +
                    "  and EXISTS ( select t_orderid from dpspayord_dbt where               " +
                    "               t_orderid = pm.t_PaymentID and                          " +
                    "               t_DocKind not in (:PSPOKIND_DEMAND, :PSPOKIND_AKKREDITIV, :PSPOKIND_CASH_REQUEST ) ) " +
                    "  and NOT EXISTS ( select 1 from dbdtransf_dbt bdtransf                " +
                    "                  where bdtransf.t_CoverPaymentID = pm.t_PaymentID )   ";

  var params : TArray = makeArray( SQLParam( "ObjectTypePayment",     OBJTYPE_PAYMENT ),
                                   SQLParam( "BaseFIID",              NATCUR ),
                                   SQLParam( "PSPOKIND_DEMAND",       PSPOKIND_DEMAND ),
                                   SQLParam( "PSPOKIND_AKKREDITIV",   PSPOKIND_AKKREDITIV ),
                                   SQLParam( "PSPOKIND_CASH_REQUEST", PSPOKIND_CASH_REQUEST )
                                 );

  // Филиал                             
  if( gisgmpmsg.rec.Deps != "" )
    select = select + " and pm.t_StartDepartment in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( gisgmpmsg.rec.Deps ) + " ) ) "; 
  end;

  // ВСП
  if( gisgmpmsg.rec.Branches != "" )
    select = select + " and pm.t_OperNode in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( gisgmpmsg.rec.Branches ) + " ) ) "; 
  end;

  // Дата значения
  if( GetCurDateFlag( gisgmpmsg.rec.Date ) == SET_CHAR )
    select = select + " and pm.t_ValueDate = :PaymentValueDate ";
    params[params.size] = SQLParam( "PaymentValueDate", GetDateAfterWorkDays( {curdate}, GetOffSet( gisgmpmsg.rec.Date ) ) );
  else
    select = select + " and pm.t_ValueDate between :PaymentValueDateBegin and :PaymentValueDateEnd ";
    params[params.size] = SQLParam( "PaymentValueDateBegin", GetMinDate( gisgmpmsg.rec.Date ) );
    params[params.size] = SQLParam( "PaymentValueDateEnd", GetMaxDate( gisgmpmsg.rec.Date ) );
  end;

  // Cчет плательщика
  if( InList( gisgmpmsg.rec.PayerAccountCond, "=", SET_CHAR ) )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentPayerAccountMask, pm.t_PayerAccount ) = 1 ";
    params[params.size] = SQLParam( "PaymentPayerAccountMask", gisgmpmsg.rec.PayerAccount );
  end;
  if( gisgmpmsg.rec.PayerAccountCond == "!" )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentPayerAccountMask, pm.t_PayerAccount ) <> 1 ";
    params[params.size] = SQLParam( "PaymentPayerAccountMask", gisgmpmsg.rec.PayerAccount );
  end;

  // БИК банка получателя
  if( (gisgmpmsg.rec.ReceiverBICCond == SET_CHAR) and (gisgmpmsg.rec.ReceiverBIC != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentReceiverBIC, RSI_RSBPARTY.PT_GetPartyCode( pm.t_ReceiverBankID, :PaymentReceiverCodeKind ) ) = 1 ";
    params[params.size] = SQLParam( "PaymentReceiverBIC", gisgmpmsg.rec.ReceiverBIC );
    params[params.size] = SQLParam( "PaymentReceiverCodeKind", PTCK_BIC );
  end;

  // Cчет получателя
  if( InList( gisgmpmsg.rec.ReceiverAccountCond, "=", SET_CHAR ) )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentReceiverAccountMask, pm.t_ReceiverAccount ) = 1 ";
    params[params.size] = SQLParam( "PaymentReceiverAccountMask", gisgmpmsg.rec.ReceiverAccount );
  end;
  if( gisgmpmsg.rec.ReceiverAccountCond == "!" )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentReceiverAccountMask, pm.t_ReceiverAccount ) <> 1 ";
    params[params.size] = SQLParam( "PaymentReceiverAccountMask", gisgmpmsg.rec.ReceiverAccount );
  end;

  // КБК
  if( (gisgmpmsg.rec.BTTTICodeCond == SET_CHAR) and (gisgmpmsg.rec.BTTTICode != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentBTTTICode, rm.t_BTTTICode ) = 1 ";
    params[params.size] = SQLParam( "PaymentBTTTICode", gisgmpmsg.rec.BTTTICode );
  end;

  // Пачка
  if( (gisgmpmsg.rec.NumberPackCond == SET_CHAR) and (gisgmpmsg.rec.NumberPack != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentNumberPack, pm.t_NumberPack ) = 1 ";
    params[params.size] = SQLParam( "PaymentNumberPack", gisgmpmsg.rec.NumberPack );
  end;

  // Назначение платежа
  if( (gisgmpmsg.rec.GroundCond == SET_CHAR) and (gisgmpmsg.rec.Ground != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :PaymentGround, rm.t_Ground ) = 1 ";
    params[params.size] = SQLParam( "PaymentGround", gisgmpmsg.rec.Ground );
  end;

  // Статус платежа
  if( (gisgmpmsg.rec.StateCond != "") and (gisgmpmsg.rec.State != "") )
    tmpStateCode = gisgmpmsg.rec.StateCond;
    if( tmpStateCode == "!" )
      tmpStateCode = "<>";
    elif( tmpStateCode == "}" )
      tmpStateCode = ">=";
    elif( tmpStateCode == "{" )
      tmpStateCode = "<=";
    end;
    select = select + " and pm.t_PaymStatus " + tmpStateCode + " " + gisgmpmsg.rec.State;
  end;

  select = select + " ) ";

  select = select + " union ";

  select = select + " ( ";

  select = select + " select bd.t_BdTransfID as t_ObjectID, :ObjectTypeBdTransf as t_ObjectType, bd.t_Department as t_Department, bd.t_Branch as t_Branch " +
                    "   from dbdtransf_dbt bd, dpmrmprop_dbt rm, dpmpaym_dbt pm                                 " +
                    "  where bd.t_CoverPaymentID = rm.t_PaymentID                                               " + 
                    "    and bd.t_CoverPaymentID = pm.t_PaymentID                                               " +
                    "    and rm.t_PayerChargeOffDate <> to_date('0001-01-01','yyyy-mm-dd')                      " + 
                    "    and exists ( select 1 from dpmpaym_dbt pm where pm.t_PaymentID = bd.t_CoverPaymentID ) ";

  params[params.size] = SQLParam( "ObjectTypeBdTransf", OBJTYPE_BDTRANSF );                    

  // Филиал                             
  if( gisgmpmsg.rec.Deps != "" )
    select = select + " and bd.t_Department in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( gisgmpmsg.rec.Deps ) + " ) ) "; 
  end;

  // ВСП
  if( gisgmpmsg.rec.Branches != "" )
    select = select + " and bd.t_Branch in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( gisgmpmsg.rec.Branches ) + " ) ) "; 
  end;

  // Дата значения
  if( GetCurDateFlag( gisgmpmsg.rec.Date ) == SET_CHAR )
    select = select + " and pm.t_ValueDate = :BdTransfValueDate ";
    params[params.size] = SQLParam( "BdTransfValueDate", GetDateAfterWorkDays( {curdate}, GetOffSet( gisgmpmsg.rec.Date ) ) );
  else
    select = select + " and pm.t_ValueDate between :BdTransfValueDateBegin and :BdTransfValueDateEnd ";
    params[params.size] = SQLParam( "BdTransfValueDateBegin", GetMinDate( gisgmpmsg.rec.Date ) );
    params[params.size] = SQLParam( "BdTransfValueDateEnd", GetMaxDate( gisgmpmsg.rec.Date ) );
  end;
  
  // Cчет плательщика
  if( InList( gisgmpmsg.rec.PayerAccountCond, "=", SET_CHAR ) )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfPayerAccountMask, bd.t_PayerAccount ) = 1 ";
    params[params.size] = SQLParam( "BdTransfPayerAccountMask", gisgmpmsg.rec.PayerAccount );
  end;
  if( gisgmpmsg.rec.PayerAccountCond == "!" )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfPayerAccountMask, bd.t_PayerAccount ) <> 1 ";
    params[params.size] = SQLParam( "BdTransfPayerAccountMask", gisgmpmsg.rec.PayerAccount );
  end;

  // БИК банка получателя
  if( (gisgmpmsg.rec.ReceiverBICCond == SET_CHAR) and (gisgmpmsg.rec.ReceiverBIC != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfReceiverBIC, RSI_RSBPARTY.PT_GetPartyCode( pm.t_ReceiverBankID, :BdTransfReceiverCodeKind ) ) = 1 ";
    params[params.size] = SQLParam( "BdTransfReceiverBIC", gisgmpmsg.rec.ReceiverBIC );
    params[params.size] = SQLParam( "BdTransfReceiverCodeKind", PTCK_BIC );
  end;

  // Cчет получателя
  if( InList( gisgmpmsg.rec.ReceiverAccountCond, "=", SET_CHAR ) )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfReceiverAccountMask, bd.t_ReceiverAccount ) = 1 ";
    params[params.size] = SQLParam( "BdTransfReceiverAccountMask", gisgmpmsg.rec.ReceiverAccount );
  end;
  if( gisgmpmsg.rec.ReceiverAccountCond == "!" )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfReceiverAccountMask, bd.t_ReceiverAccount ) <> 1 ";
    params[params.size] = SQLParam( "BdTransfReceiverAccountMask", gisgmpmsg.rec.ReceiverAccount );
  end;

  // КБК
  if( (gisgmpmsg.rec.BTTTICodeCond == SET_CHAR) and (gisgmpmsg.rec.BTTTICode != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfBTTTICode, bd.t_BTTTICode ) = 1 ";
    params[params.size] = SQLParam( "BdTransfBTTTICode", gisgmpmsg.rec.BTTTICode );
  end;

  // Пачка
  if( (gisgmpmsg.rec.NumberPackCond == SET_CHAR) and (gisgmpmsg.rec.NumberPack != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfNumberPack, bd.t_NumberPack ) = 1 ";
    params[params.size] = SQLParam( "BdTransfNumberPack", gisgmpmsg.rec.NumberPack );
  end;

  // Назначение платежа
  if( (gisgmpmsg.rec.GroundCond == SET_CHAR) and (gisgmpmsg.rec.Ground != "") )
    select = select + " and RSI_RSB_MASK.CompareStringWithMask( :BdTransfGround, bd.t_Ground ) = 1 ";
    params[params.size] = SQLParam( "BdTransfGround", gisgmpmsg.rec.Ground );
  end;

  // Статус платежа
  if( (gisgmpmsg.rec.StateCond != "") and (gisgmpmsg.rec.State != "") )
    tmpStateCode = gisgmpmsg.rec.StateCond;
    if( tmpStateCode == "!" )
      tmpStateCode = "<>";
    elif( tmpStateCode == "}" )
      tmpStateCode = ">=";
    elif( tmpStateCode == "{" )
      tmpStateCode = "<=";
    end;
    select = select + " and pm.t_PaymStatus " + tmpStateCode + " " + gisgmpmsg.rec.State;
  end;

  select = select + " ) ";

  return execSQLselect( select, params, true );
end;

private macro IsGGPIPmSendExists( ObjectID:integer, ObjectType:integer ):bool
  var query : string = " select 1 " +
                       " from dpmsend_dbt " +
                       " where t_ObjectID   = :ObjectID " +
                       "   and t_ObjectType = :ObjectType ";

  var rs : RsdRecordset = execSQLselectPrm( query,
                                            SQLParam( "ObjectID",  ObjectID ),
                                            SQLParam( "ObjectType", ObjectType ) );

  if( rs and rs.moveNext() )
    return true;
  end;

  return false;
end;

private macro GetPmSendID( ObjectID:integer, ObjectType:integer ):integer
  var PmSendID : integer = 0;
  var query : string = " select t_ID " +
                       " from dpmsend_dbt " +
                       " where t_ObjectID   = :ObjectID " +
                       "   and t_ObjectType = :ObjectType ";

  var rs : RsdRecordset = execSQLselectPrm( query,
                                            SQLParam( "ObjectID",  ObjectID ),
                                            SQLParam( "ObjectType", ObjectType ) );

  if( rs and rs.moveNext() )
    PmSendID = rs.value("t_ID");
  end;

  return PmSendID;
end;

private macro GetPmSendAction( PmSendID:integer ):integer
  var Action = 0;
  var query : string = " select t_Action " +
                       " from dpmsend_dbt " +
                       " where t_ID = :PmSendID ";

  var rs : RsdRecordset = execSQLselectPrm( query, SQLParam( "PmSendID",  PmSendID ) );

  if( rs and rs.moveNext() )
    Action = rs.Value( "t_Action" );
  end;

  return Action;
end;

private macro GetFirstDate_Carry( PaymentID:integer ):date
  var Date_Carry = date(0,0,0);
  var query : string = " select trn.t_Date_Carry " +
                     "   from dpmdocs_dbt doc, dacctrn_dbt trn "
                     "  where doc.t_PaymentID = :PaymentID "
                     "    and doc.t_AccTrnID = trn.t_AccTrnID "
                     "    and trn.t_Chapter = 1 "
                     "  order by doc.t_AutoKey asc ";

  var rs : RsdRecordset = execSQLselectPrm( query, SQLParam( "PaymentID",  PaymentID ) );

  if( rs and rs.moveNext() )
    Date_Carry = ToDate( rs.Value( "t_Date_Carry" ) );
  end;

  return Date_Carry;
end;

private macro GetDepPartyID(Branch : integer) : integer
  var rs : RsdRecordset = execSQLselectPrm
  ( "select t_PartyID "
    "  from ddp_dep_dbt "
    " where t_NodeType = 1 /* DEPARTMENT_TYPE_FILIAL */ "
    " start with t_Code = :Branch "
    " connect by t_Code = prior t_ParentCode ",
    SQLParam("Branch", Branch)
  );

  if(rs and rs.moveNext())
    return rs.value("t_PartyID");
  end;

  return 0;
end;

private macro GetDpDepName( PartyID:integer ):string
  var Name = "";
  var query : string = " select t_Name " +
                       " from ddp_dep_dbt " +
                       " where t_PartyID = :PartyID ";

  var rs : RsdRecordset = execSQLselectPrm( query, SQLParam( "PartyID",  PartyID ) );

  if( rs and rs.moveNext() )
    Name = rs.Value( "t_Name" );
  end;

  return Name;
end;

private macro GetTransKind( TransKind ):string
  if( not InList( TransKind, "01", "06", "16" ) )
    return "";
  end;
  return TransKind;
end;

private macro GetTaxAuthorState( TaxAuthorState ):string
  if( not InList( TaxAuthorState, "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28" ) )
    return "";
  end;
  return TaxAuthorState;
end;

private macro GetPaytReason( PaytReason ):string
  if( not InList( PaytReason, "ТП", "ЗД", "БФ", "ТР", "РС", "ОТ", "РТ", "ПБ", "ПР", "АП", "АР", "ИН", "ТЛ", "ЗТ", "ДЕ", "ПО", "КТ", "ИД", "ИП", "ТУ", "БД", "КП", "ВУ", "ДК", "ПК", "КК", "ТК", "ПД", "КВ" "00", "0" ) )
    return "";
  end;
  return PaytReason;
end;

private macro UpdatePmSendSysDateAndTime( PmSendID, sysdate, systime )

  var params;
  var update;
  
  if( PmSendID > 0)      
    update = "update dpmsend_dbt sd set sd.t_SysDate = :Sys_Date, sd.t_SysTime = :SysTime "
              " where sd.t_ID = :pmsendID RETURNING sd.t_ID into :OutPmsendID;";              
   
    params = makeArray( SQLParam( "SysDate", sysdate ),
                        SQLParam( "SysTime", systime ),
                        SQLParam( "pmsendID", PmSendID ),
                        SQLParam( "OutPmsendID", V_INTEGER, RSDBP_OUT )
                       );

    var rs = execSQL( update, params, true );
    AddRecLogGGPIPmSend( rs.param("OutPmsendID").value ); // OutPmsendID        
  end;

end;

private macro UpdatePmSendState( PmSendID, State )

  var params;
  var update;
  
  if( (PmSendID > 0) and (State >= 0) )      
    update = "update dpmsend_dbt sd set sd.t_State = :State "
              " where sd.t_ID = :pmsendID RETURNING sd.t_ID into :OutPmsendID;";              
   
    params = makeArray( SQLParam( "State", State ),
                        SQLParam( "pmsendID", PmSendID ),
                        SQLParam( "OutPmsendID", V_INTEGER, RSDBP_OUT )
                       );

    var rs = execSQL( update, params, true );
    AddRecLogGGPIPmSend( rs.param("OutPmsendID").value ); // OutPmsendID        
  end;

end;

private macro GetPmSendBlob( PmSendID : integer, sLen : integer ) : string
  if( not (PmSendID > 0) )
    return "";
  end;
  
  var stat : integer = 0;
  var blob : string = "";  
  
  var cmd = RsdCommand(
                        " DECLARE " +
                        "    l_clob           CLOB := CHR(1);" +
                        "    l_blob           BLOB;" +
                        "    l_dest_offsset   INTEGER := 1;" +
                        "    l_src_offsset    INTEGER := 1;" +
                        "    l_lang_context   INTEGER := DBMS_LOB.default_lang_ctx;" +
                        "    l_warning        INTEGER;" +
                        " BEGIN" +
                        "    SELECT t_FMTBLOBDATA_XXXX" +
                        "      INTO l_blob" +
                        "      FROM dpmsend_dbt" +
                        "     WHERE t_ID = ? ;" +
                        "    IF l_blob IS NOT NULL" +
                        "    THEN" +
                        "       DBMS_LOB.createTemporary (l_clob, FALSE);" +
                        "       DBMS_LOB.converttoclob (l_clob," +
                        "                               l_blob," +
                        "                               DBMS_LOB.lobmaxsize," +
                        "                               l_dest_offsset," +
                        "                               l_src_offsset," +
                        "                               DBMS_LOB.default_csid," +
                        "                               l_lang_context," +
                        "                               l_warning);" +
                        "       ? := l_clob;" +
                        "    END IF;" +
                        " EXCEPTION " +
                        " WHEN NO_DATA_FOUND THEN " +
                        "   ? := 1; " +
                        " END; "
                      );
                      
  cmd.addParam("", RSDBP_IN,  PmSendID );
  cmd.addParam("", RSDBP_OUT, V_STRING, 30000);
  cmd.addParam("", RSDBP_OUT, V_INTEGER);
  
  cmd.execute();
  
  if((cmd.value(2) == 0) and (valtype(cmd.value(1)) == V_STRING))
    blob = cmd.value(1);
  end;
  
  if( (valtype(sLen) != V_UNDEF) and ( sLen > 0 ) )
    blob = SubStr( blob, 1, sLen );
  end;

  return blob;
end;

private macro GetPmSendsRs( ObjectID:integer, ObjectType:integer ):RsdRecordSet
  var params;
  var select;
  var rs;

  if( (ObjectType > 0) and (ObjectID > 0) )
    select = " select t_ID " +
             " from dpmsend_dbt " +
             " where t_ObjectID = :ObjectID " +
             "   and t_ObjectType = :ObjectType ";
   
    params = makeArray( SQLParam( "ObjectID", ObjectID ),
                        SQLParam( "ObjectType", ObjectType )
                       );

    rs = execSQLselect( select, params, true );
  else
    rs = null;
  end;
  return rs;
end;

private macro GetProcessingPmSendID( PmSendIDs:TArray, ObjectID:integer, ObjectType:integer ):integer
  var procPmSendID : integer = 0;
  var rs : RsdRecordSet = GetPmSendsRs( ObjectID, ObjectType );
  if( PmSendIDs and (PmSendIDs.size > 0) and rs )
    while( rs and rs.MoveNext() )
      for( var pmsendid, PmSendIDs )
        if( pmsendid == rs.Value( "t_ID" ) )
          procPmSendID = pmsendid;
        end;
      end;
    end;
  else
    procPmSendID = 0;
  end;
  return procPmSendID;
end;

private macro GetGGPIPmSendData( PmSendID : integer, ObjectID : @integer, ObjectType : @integer, Department : @integer, Branch : @integer, Description : @string ):bool
  const maxStringLen = 3000;
  var query : string = " select pmsend.t_ObjectID as t_ObjectID, pmsend.t_ObjectType as t_ObjectType, " +
                       "        pmsend.t_Description as t_Description, " +
                       " case " +
                       "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                       "     pmpaym.t_Department " +
                       "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                       "     bdtransf.t_Department " +
                       "   else " +
                       "     0 " +
                       " end as t_Department, " +
                       " case " +
                       "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                       "     pmpaym.t_OperNode " +
                       "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                       "     bdtransf.t_Branch " +
                       "   else " +
                       "     0 " +
                       " end as t_Branch " +
                       " from dpmsend_dbt pmsend " +
                       " left outer join dbdtransf_dbt bdtransf on bdtransf.t_BdTransfID = pmsend.t_ObjectID and pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ " +
                       " left outer join dpmpaym_dbt pmpaym on pmpaym.t_PaymentID = pmsend.t_ObjectID and pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ " +
                       " where pmsend.t_ID = :PmSendID ";

  var params : TArray = makeArray( SQLParam( "PmSendID", PmSendID ) );

  var rs : RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
    if( valtype( ObjectID ) != V_UNDEF )
      ObjectID = rs.value("t_ObjectID");
    end;
    if( valtype( ObjectType ) != V_UNDEF )
      ObjectType = rs.value("t_ObjectType");
    end;
    if( valtype( Department ) != V_UNDEF )    
      Department = rs.value("t_Department");
    end;
    if( valtype( Branch ) != V_UNDEF )
      Branch = rs.value("t_Branch");
    end;
    if( valtype( Description ) != V_UNDEF )
      if( (valtype(rs.value("t_Description")) == V_STRING) and (rs.value("t_Description") != "") )
        Description = rs.value("t_Description");
      else
        Description = GetPmSendBlob( PmSendID, maxStringLen );
      end;
      
    end;
    return true;
  end;
  return false;
end;

private macro ProcessGGPIResponse( Response, PmSendIDs ):bool
  private macro ParseDocumentID( DocumentID : string, ObjectID : @integer, ObjectType : @integer ):bool
    if( strlen( DocumentID ) and Index( DocumentID, "_" ) )
      ObjectType = int( SubStr( DocumentID, 1, Index( DocumentID, "_" ) - 1 ) );
      ObjectID = int( SubStr( DocumentID, Index( DocumentID, "_" ) + 1 ) );
      return true;
    end;
    return false;
  end;

  var OutPmSendID : integer = 0;
  var ProcessingPmSendID : integer = 0;

  var params;
  var update;
  var rs;
  var cmd;

  var idx = 1;
  var result = 0;
  var size_of_blob = 29999; /* Размер BLOB-а c-структуры - 1*/

  var tmpObjectID : integer = 0, tmpObjectType : integer = 0, tmpDepartment : integer = 0, tmpBranch : integer = 0;

  var tmpErrorText = "";
  var blob = false;

  if( Response and Response.ResponseConnectData )
    if( Response.ResponseConnectData.ObjectError )
      if( PmSendIDs and (PmSendIDs.size > 0) )
        var PmSendCond = "";
        if( PmSendIDs.size() < 1000 ) // В конструкцию IN в Oracle нельзя запихнуть более 1000 значений
          PmSendCond = "sd.t_ID in ( " + join( PmSendIDs, "," ) + " ) ";
        else // Если же кто-то очень умный передал более 1000 идентификаторов - делаем магию
          PmSendCond = "(sd.t_ID,0) in ( (" + join( PmSendIDs, ",0),(" ) + ",0) ) ";
        end;

        tmpErrorText = "";
        blob = IfThenElse( Response.ResponseConnectData.ObjectError.ErrorText.size == 1, false, true );
        for( var errstr, Response.ResponseConnectData.ObjectError.ErrorText )
          if( tmpErrorText != "" )
            tmpErrorText = tmpErrorText + "\n";
          end;
          tmpErrorText = tmpErrorText + errstr;
        end;

        idx = 1;
        result = 0;

        update = " DECLARE " +
                 "    l_blob          BLOB; " +
                 IfThenElse( blob, 
                             " l_clob CLOB := ?; ", 
                             " l_clob CLOB := chr(1); " 
                           ) +                 
                 "    l_amt           INTEGER := DBMS_LOB.lobmaxsize; " +
                 "    l_dest_offset   INTEGER := 1; " +
                 "    l_src_offset    INTEGER := 1; " +
                 "    l_csid          INTEGER := DBMS_LOB.default_csid; " +
                 "    l_ctx           INTEGER := DBMS_LOB.default_lang_ctx; " +
                 "    l_warn          INTEGER; " +
                 " BEGIN " +
                 "    DBMS_LOB.createTemporary (l_blob, FALSE); " +
                 "    DBMS_LOB.convertToBlob (l_blob, " +
                 "                            l_clob, " +
                 "                            l_amt, " +
                 "                            l_dest_offset, " +
                 "                            l_src_offset, " +
                 "                            l_csid, " +
                 "                            l_ctx, " +
                 "                            l_warn); " +
                 "    update dpmsend_dbt sd set sd.t_State            = ? " + // State
                 "                            , sd.t_ProcessCode      = ? " + // ProcessCode
                 IfThenElse( blob, 
                             " , sd.t_FMTBLOBDATA_XXXX = l_blob ", 
                             " , sd.t_FMTBLOBDATA_XXXX = empty_blob() " 
                           );                 
        if( blob )         
          update = update + " , sd.t_Description = chr(1) "; // Description
        else
          update = update + " , sd.t_Description = ? "; // Description
        end;
        update = update + "    where " + PmSendCond + " ;" +
                 " END; ";
        
        cmd = RsdCommand( update );
                              
        // Обрезаем до размера блоба
        tmpErrorText = SubStr(tmpErrorText, (idx - 1 ) * size_of_blob + 1, size_of_blob);

        if( blob )
          cmd.addParam("", RSDBP_IN, tmpErrorText );
        end;
        cmd.addParam("", RSDBP_IN, WLD_STATUS_PMSEND_SENDERROR );
        cmd.addParam("", RSDBP_IN, Response.ResponseConnectData.ObjectError.ErrorCode );
        if( not blob )
          cmd.addParam("", RSDBP_IN, tmpErrorText );
        end;
        
        cmd.execute();
          
        for( var pmsendID, PmSendIDs ) // Заполняем таблицу с данными для протокола здесь
          tmpObjectID = 0;
          tmpObjectType = 0;
          tmpDepartment = 0;
          tmpBranch = 0;
          var Descr = "";
          GetGGPIPmSendData( pmsendID, @tmpObjectID, @tmpObjectType, @tmpDepartment, @tmpBranch, @Descr );
          InsertGGRepData( tmpObjectID, tmpObjectType, tmpDepartment, tmpBranch, pmsendID, SubStr(tmpErrorText, 1, 200) );
        end;
      end;
    elif( Response.ResponseConnectData.ObjectStatusList and (Response.ResponseConnectData.ObjectStatusList.ObjectStatus.size > 0) )
      for( var ObjectStatus, Response.ResponseConnectData.ObjectStatusList.ObjectStatus )
        var ObjectID = 0, ObjectType = 0;     
        if( ParseDocumentID( ObjectStatus.DocumentID, @ObjectID, @ObjectType ) )
          ProcessingPmSendID = GetProcessingPmSendID( PmSendIDs, ObjectID, ObjectType );
        end;

        if( ProcessingPmSendID != 0 )
          var needUpdateState : bool = false;
          if( ObjectStatus.ObjectError )
            if( GetElementAndNoteLLVALUES( OBJTYPE_GISGMP_SENDERROR, ObjectStatus.ObjectError.ErrorCode ) )
              needUpdateState = true;
            end;
          else
            needUpdateState = true;
          end;

          if( ((valtype(ObjectStatus.PaymentID) == V_STRING) and (ObjectStatus.PaymentID != "")) 
           or ((valtype(ObjectStatus.ObjectID ) == V_STRING) and (ObjectStatus.ObjectID  != "")) )
            update = " update dpmsend_dbt sd set " + 
                       IfThenElse( ((valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID != "") ), 
                                              " sd.t_ExtObjectID = :ExtObjectID  ", 
                                              "                                  " ) +
                       IfThenElse( ((valtype(ObjectStatus.PaymentID) == V_STRING) and (ObjectStatus.PaymentID != "")
                               and  (valtype(ObjectStatus.ObjectID ) == V_STRING) and (ObjectStatus.ObjectID  != "")), 
                                              " , ", 
                                              "   " ) +
                       IfThenElse( ((valtype(ObjectStatus.PaymentID) == V_STRING) and (ObjectStatus.PaymentID != "") ), 
                                              " sd.t_UIP = :UIP ", 
                                              "                 " ) +
                       IfThenElse( ((valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID != "") and needUpdateState ), 
                                              ", sd.t_State = :State ", 
                                              "                      " ) +
                     " where sd.t_ID = :PmSendID; ";
           
            params = TArray();
            if( (valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID != "") )
              params[params.size] = SQLParam( "ExtObjectID", ObjectStatus.ObjectID )
            end;
            if( (valtype(ObjectStatus.PaymentID) == V_STRING) and (ObjectStatus.PaymentID != "") )
              params[params.size] = SQLParam( "UIP", ObjectStatus.PaymentID );
            end;
            if( (valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID != "") and needUpdateState )
              params[params.size] = SQLParam( "State", WLD_STATUS_PMSEND_SEND );
            end;
            params[params.size] = SQLParam( "PmSendID", ProcessingPmSendID );

            rs = execSQL( update, params, true );
            
            AddRecLogGGPIPmSend( ProcessingPmSendID ); // OutPmsendID        
          end;
        end;

        if( ObjectStatus.ObjectError and (ProcessingPmSendID != 0) )
          var tmpState = -1;
          if( ((valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID == "")) or (ObjectStatus.ObjectID == null) or (valtype(ObjectStatus.ObjectID) != V_STRING) )
            if( GetElementAndNoteLLVALUES( OBJTYPE_GISGMP_PROCESSERROR, ObjectStatus.ObjectError.ErrorCode ) )
              tmpState = WLD_STATUS_PMSEND_FINISHED;
            else
              tmpState = WLD_STATUS_PMSEND_SENDERROR;
            end;
          end;
          
          var needUpdateRequisites : bool = false;
          if( ObjectStatus.ObjectError )
          if( ( ((valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID == "")) or (valtype(ObjectStatus.ObjectID) != V_STRING) )
           or ( (valtype(ObjectStatus.ObjectID) == V_STRING) and (ObjectStatus.ObjectID != "") and (not GetElementAndNoteLLVALUES( OBJTYPE_GISGMP_SENDERROR, ObjectStatus.ObjectError.ErrorCode )) ) 
            )
              needUpdateRequisites = true;
            end;
          else
            needUpdateRequisites = true;
          end;

          tmpErrorText = "";
          blob = IfThenElse( ObjectStatus.ObjectError.ErrorText.size == 1, false, true );
          for( var errstrn, ObjectStatus.ObjectError.ErrorText )
            if( tmpErrorText != "" )
              tmpErrorText = tmpErrorText + "\n";
            end;
            tmpErrorText = tmpErrorText + errstrn;
          end;


          idx = 1;
          result = 0;

          if( (tmpState != -1) or needUpdateRequisites )
            update = " DECLARE " +
                     "    l_blob          BLOB; " +
                     IfThenElse( blob, 
                                 " l_clob CLOB := ?; ", 
                                 " l_clob CLOB := chr(1); " 
                               ) +                 
                     "    l_amt           INTEGER := DBMS_LOB.lobmaxsize; " +
                     "    l_dest_offset   INTEGER := 1; " +
                     "    l_src_offset    INTEGER := 1; " +
                     "    l_csid          INTEGER := DBMS_LOB.default_csid; " +
                     "    l_ctx           INTEGER := DBMS_LOB.default_lang_ctx; " +
                     "    l_warn          INTEGER; " +
                     " BEGIN " +
                     "    DBMS_LOB.createTemporary (l_blob, FALSE); " +
                     "    DBMS_LOB.convertToBlob (l_blob, " +
                     "                            l_clob, " +
                     "                            l_amt, " +
                     "                            l_dest_offset, " +
                     "                            l_src_offset, " +
                     "                            l_csid, " +
                     "                            l_ctx, " +
                     "                            l_warn); " +
                     "    update dpmsend_dbt sd set " +
                     IfThenElse( tmpState != -1, " sd.t_State = ?, ", " " ) +
                     IfThenElse( needUpdateRequisites, 
                                 " sd.t_ProcessCode = ? " + 
                                 IfThenElse( blob, 
                                             ", sd.t_FMTBLOBDATA_XXXX = l_blob ", 
                                             ", sd.t_FMTBLOBDATA_XXXX = empty_blob() " 
                                           ) +
                                 IfThenElse( blob, 
                                             ", sd.t_Description = chr(1) ", 
                                             ", sd.t_Description = ? " 
                                           ), 
                                 "" 
                               ) +
                     "    where sd.t_ID = ?; " + // PmSendID
                     " END; ";
            
            cmd = RsdCommand( update );
                                  
            // Обрезаем до размера блоба
            tmpErrorText = SubStr(tmpErrorText, (idx - 1 ) * size_of_blob + 1, size_of_blob);

            if( blob )
              cmd.addParam("", RSDBP_IN, tmpErrorText );
            end;
            if( tmpState != -1 )
              cmd.addParam("", RSDBP_IN, tmpState );
            end;
            if( needUpdateRequisites )
              cmd.addParam("", RSDBP_IN, ObjectStatus.ObjectError.ErrorCode );
              if( not blob )
                cmd.addParam("", RSDBP_IN, tmpErrorText );
              end;
            end;
            cmd.addParam("", RSDBP_IN, ProcessingPmSendID );
           
            cmd.execute();

          end;

          AddRecLogGGPIPmSend( ProcessingPmSendID ); // OutPmsendID
        end;

        tmpObjectID = 0;
        tmpObjectType = 0;
        tmpDepartment = 0;
        tmpBranch = 0;
        var Description : string = "";
        GetGGPIPmSendData( ProcessingPmSendID, @tmpObjectID, @tmpObjectType, @tmpDepartment, @tmpBranch, @Description );
        InsertGGRepData( tmpObjectID, tmpObjectType, tmpDepartment, tmpBranch, ProcessingPmSendID, IfThenElse( Description != "", SubStr(Description, 1, 200), "Сведения для ГИС ГМП переданы успешно" ) );
      end;
    end;
  else
    return false;
  end;

  return true;
end;

private macro CreateGGPIImportedPayment( rs:RsdRecordset )
   
  record pmpaym( pmpaym );

  var ImportedPayment = ImportedPaymentType();

  ImportedPayment.DocumentID = rs.value("t_ObjectType") + "_" + rs.value("t_ObjectID");

  // ImportedPayment.NoticeID по ФТ есть, но мы не заполняем

  if( rs.value("t_UIP") != "" )
    ImportedPayment.PaymentID = rs.value("t_UIP");
  end;

  // Сведения о статусе платежа и основаниях его изменения
  ImportedPayment.ChangeStatus = ChangeStatusType();
  if( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_CREATE )
    ImportedPayment.ChangeStatus.Meaning = "1";
  elif( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_REFINEMENT )
    ImportedPayment.ChangeStatus.Meaning = "2";
  elif( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_ANNULATE )
    ImportedPayment.ChangeStatus.Meaning = "3";
  elif( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_DEANNULATE )
    ImportedPayment.ChangeStatus.Meaning = "4";
  else
    ImportedPayment.ChangeStatus.Meaning = "0";
  end;
  ImportedPayment.ChangeStatus.Reason = rs.value("t_Ground");
  if( ImportedPayment.ChangeStatus.Reason == "" )
    if( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_REFINEMENT )
      ImportedPayment.ChangeStatus.Reason = Bnk_GetRegistryValue( RegPath_ChangeReason_ChangeStatus_2, V_STRING, "Уточнение реквизитов платежа" );
    elif( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_ANNULATE )
      ImportedPayment.ChangeStatus.Reason = Bnk_GetRegistryValue( RegPath_ChangeReason_ChangeStatus_3, V_STRING, "Отмена исполнения платежа" );
    elif( rs.value("t_Action") == WLD_ACTION_PMSEND_GG_DEANNULATE )
      ImportedPayment.ChangeStatus.Reason = Bnk_GetRegistryValue( RegPath_ChangeReason_ChangeStatus_4, V_STRING, "Возобновление исполнения платежа" );
    end;
  end;

  if( rs.value("t_SupplierBillID") != "" )
    ImportedPayment.SupplierBillID = rs.value("t_SupplierBillID");
  elif( (rs.value("t_SupplierBillID") == "") and CompareStrWithMasks( "40302*", rs.value("t_PayeeAccount") ) )
    ImportedPayment.SupplierBillID = "0";
  end;
    
  if( rs.value("t_Purpose") != "" )
    ImportedPayment.Purpose = rs.value("t_Purpose");
  else
    ImportedPayment.Purpose = "0";
  end;

  ImportedPayment.Amount = moneyL( rs.value("t_Amount") ) * 100;

  var tmpPaymentDate : date = date(0,0,0);
  if( rs.value("t_ObjectType") == OBJTYPE_BDTRANSF )
    tmpPaymentDate = date( rs.value("t_PaymentDate") );
  else
    pmpaym.PaymentID = int(rs.value("t_PaymentID"));
    var strPaymentID = makeObjectID(OBJTYPE_PAYMENT, NULL, pmpaym);
    var note = ReadNoteForObject(OBJTYPE_PAYMENT, strPaymentID, PM_NOTEKIND_PAYM_ACCEPTUATEDATE);
    tmpPaymentDate = ToDateYYYY_MM_DD( SubStr(note, 1, 10) );
  end;
  if( tmpPaymentDate == date(0,0,0) )
    tmpPaymentDate = GetFirstDate_Carry( int(rs.value("t_PaymentID")) );
  end;
  if( tmpPaymentDate != date(0,0,0) )
    ImportedPayment.PaymentDate = tmpPaymentDate;
  end;
  
  var tmpReceiptDate = date( rs.value("t_ReceiptDate") );
  if( tmpReceiptDate == date(0,0,0) )
    tmpReceiptDate = GetFirstDate_Carry( int(rs.value("t_PaymentID")) );
  end;
  if( tmpReceiptDate != date(0,0,0) )
    ImportedPayment.ReceiptDate = tmpReceiptDate;
  end;

  if( rs.value("t_KBK") != "" )
    ImportedPayment.KBK = rs.value("t_KBK");
  elif( (rs.value("t_KBK") == "") and CompareStrWithMasks( "40302*", rs.value("t_PayeeAccount") ) )
    ImportedPayment.KBK = "0";
  end;

  if( rs.value("t_OKTMO") != "" )
    ImportedPayment.OKTMO = rs.value("t_OKTMO");
  elif( (rs.value("t_OKTMO") == "") and ( (not CompareStrWithMasks( "40101*", rs.value("t_PayeeAccount") )) or (not CompareStrWithMasks( "40302*", rs.value("t_PayeeAccount") )) ) )
    ImportedPayment.OKTMO = "0";
  end;

  if( date( rs.value("t_DeliveryDate") ) != date(0,0,0) )
    ImportedPayment.DeliveryDate = date( rs.value("t_DeliveryDate") );
  end;

  if( GetTransKind( rs.value("t_TransKind") ) != "" )
    ImportedPayment.TransKind = GetTransKind( rs.value("t_TransKind") );
  end;

  ImportedPayment.PaymentOrg = PaymentOrgType(); // Данные организации, принявшей платеж
  ImportedPayment.PaymentOrg.Bank = BankWithDepType(); // Реквизиты структурного подразделения кредитной организации, принявшего платеж
  if( rs.value("t_PayerBankName") != "" )
    ImportedPayment.PaymentOrg.Bank.Name = rs.value("t_PayerBankName");
  end;
  ImportedPayment.PaymentOrg.Bank.BIK = rs.value("t_PayerBankBIK");

  var BankCodeKindInPaymentID = Bnk_GetRegistryValue( RegPath_BankCodeKindInPaymentID, V_INTEGER, 0 );
  var BankCode = "";
  if( BankCodeKindInPaymentID > 0 )
    var tmpDocDate = rs.value("t_AccDocDate");
    if( tmpDocDate == date(0,0,0) )
      tmpDocDate = {curdate};
    end;
    BankCode = GetPartyCodeOnDate( GetDepPartyID( int(rs.value("t_Department")) ), BankCodeKindInPaymentID, tmpDocDate );
  end;
  if( (BankCodeKindInPaymentID <= 0) or (BankCode == "") )
    BankCode = GetDpDepName( int(rs.value("t_PayerBankID")) );
  end;
  if( BankCode != "" )
    if( strlen(BankCode) < 6 )
      while( strlen(BankCode) < 6 )
        BankCode = "0" + BankCode;
      end;  
    else  
      BankCode = substr(BankCode, 1, 6);
    end;
  end;
  if( BankCode != "" )
    ImportedPayment.PaymentOrg.Bank.Department = BankCode;
  end;

  if( rs.value("t_PayerCorrespBankAccount") != "" )
    ImportedPayment.PaymentOrg.Bank.CorrespondentBankAccount = rs.value("t_PayerCorrespBankAccount");
  end;

  ImportedPayment.Payer = PayerType(); // Сведения о плательщике
  var tmpPayerIdentifier : string = "";
  if( rs.value("t_ObjectType") == OBJTYPE_BDTRANSF )
    tmpPayerIdentifier = rs.value("t_PayerIdentifier");
  elif( rs.value("t_ObjectType") == OBJTYPE_PAYMENT )  
    tmpPayerIdentifier = PayerIDForm( rs.value("t_Payer"), rs.value("t_TaxDocNumber"), null, true );
  end;
  if( tmpPayerIdentifier != "" )
    ImportedPayment.Payer.PayerIdentifier = tmpPayerIdentifier;
  elif( (tmpPayerIdentifier == "") and CompareStrWithMasks( "40302*", rs.value("t_PayeeAccount") ) )
    ImportedPayment.Payer.PayerIdentifier = "0";
  end;
  if( rs.value("t_PayerName") != "" )
    ImportedPayment.Payer.PayerName = rs.value("t_PayerName");
  end;
  if( rs.value("t_PayerAccount") != "" )
    ImportedPayment.Payer.PayerAccount = rs.value("t_PayerAccount");
  end;

  ImportedPayment.Payee = PayeeType(); // Сведения о получателе средств
  ImportedPayment.Payee.PayeeName = rs.value("t_PayeeName");
  ImportedPayment.Payee.PayeeINN = rs.value("t_PayeeINN");
  ImportedPayment.Payee.PayeeKPP = IfThenElse( rs.value("t_PayeeKPP") != "", rs.value("t_PayeeKPP"), "0" );
  if( (rs.value("t_ObjectType") == OBJTYPE_PAYMENT) and (rs.value("t_PayeeOGRN") != "") )
    ImportedPayment.Payee.PayeeOGRN = rs.value("t_PayeeOGRN");
  end;
  ImportedPayment.Payee.PayeeAccount = IfThenElse( rs.value("t_PayeeAccount") != "", rs.value("t_PayeeAccount"), "00000000000000000000" );

  ImportedPayment.Payee.Bank = BankType(); // Данные банка, в котором открыт счет
  if( rs.value("t_ReceiverBankName") != "" )
    ImportedPayment.Payee.Bank.Name = rs.value("t_ReceiverBankName");
  end;
  ImportedPayment.Payee.Bank.BIK = rs.value("t_ReceiverBankBIK");
  if( rs.value("t_PayeeCorrespBankAccount") != "" )
    ImportedPayment.Payee.Bank.CorrespondentBankAccount = rs.value("t_PayeeCorrespBankAccount");
  end;

  ImportedPayment.BudgetIndex = BudgetIndexType(); // Данные налогового платежа
  ImportedPayment.BudgetIndex.Status = GetTaxAuthorState( rs.value("t_Status") );
  ImportedPayment.BudgetIndex.PaytReason = GetPaytReason( rs.value("t_PaytReason") );
  if( ImportedPayment.BudgetIndex.PaytReason == "" )
    ImportedPayment.BudgetIndex.PaytReason = "0";
  end;
  ImportedPayment.BudgetIndex.TaxPeriod = IfThenElse( rs.value("t_TaxPeriod") != "", rs.value("t_TaxPeriod"), "0" );
  ImportedPayment.BudgetIndex.TaxDocNumber = IfThenElse( rs.value("t_TaxDocNumber") != "", rs.value("t_TaxDocNumber"), "0" );
  ImportedPayment.BudgetIndex.TaxDocDate = IfThenElse( ( (rs.value("t_TaxDocDate") != "") and (rs.value("t_TaxDocDate") != "01.01.0001") ), rs.value("t_TaxDocDate"), "0" );
                                                       
  ImportedPayment.AccDoc = AccDocType(); // Реквизиты платежного документа
  if( rs.value("t_AccDocNo") != "" )
    ImportedPayment.AccDoc.AccDocNo = substr( rs.value("t_AccDocNo"), 1, 6);
  end;

  ImportedPayment.AccDoc.AccDocDate = date( rs.value("t_AccDocDate") );

  if( (rs.value("t_ObjectType") == OBJTYPE_PAYMENT) and (int(rs.value("t_PartPaymNumber")) != 0) ) // Заполняется только для частичных оплат
    ImportedPayment.PartialPayt = PartialPaytType();
    ImportedPayment.PartialPayt.TransKind = GetTransKind( rs.value("t_PartialPaytTransKind") );
    if( int(rs.value("t_PartPaymNumber")) != 0 )
      ImportedPayment.PartialPayt.PaytNo = int(rs.value("t_PartPaymNumber"));
    end;
    ImportedPayment.PartialPayt.TransContent = IfThenElse( ImportedPayment.PartialPayt.PaytNo != "", GetContentOperationString( pmpaym.ContentOperation, pmpaym, false ), "" );
    if( moneyL( rs.value("t_SumResidualPayt") ) != 0 )
      ImportedPayment.PartialPayt.SumResidualPayt = moneyL( rs.value("t_SumResidualPayt") ) * 100;
    end;
    ImportedPayment.PartialPayt.AccDoc = AccDocType();
    if( rs.value("t_PartialPaytAccDocNo") != "" )
      ImportedPayment.PartialPayt.AccDoc.AccDocNo = substr( rs.value("t_PartialPaytAccDocNo"), 1, 6);
    end;
    ImportedPayment.AccDoc.AccDocDate = date( rs.value("t_PartialPaytAccDocDate") );
  end;

  if( (rs.value("t_ESIA_ID") != "") and RegExMatch( rs.value("t_ESIA_ID"), "\\d{3,10}" ) )
    ImportedPayment.ESIA_ID = rs.value("t_ESIA_ID");
  end;

  return ImportedPayment;
end;

macro GGPIPmSendReqsTransferTRN()


  var MaxPaymentPackage = Bnk_GetRegistryValue( RegPath_MaxPaymentPackage, V_INTEGER, 1000 );

  var PmSendCond = "";
  // Отбираем только определенные записи pmsend
  if( (g_TrnParm.PmSendIDs != null) and (valtype( g_TrnParm.PmSendIDs ) != V_UNDEF) and (IsEqClass( "TArray", g_TrnParm.PmSendIDs ) and (g_TrnParm.PmSendIDs.size() > 0)) ) // Если переданы идентификаторы dpmsend_dbt.t_ID
    if( g_TrnParm.PmSendIDs.size() < 1000 ) // В конструкцию IN в Oracle нельзя запихнуть более 1000 значений
      PmSendCond = "pmsend.t_ID in ( " + join( g_TrnParm.PmSendIDs, "," ) + " ) ";
    else // Если же кто-то очень умный передал более 1000 идентификаторов - делаем магию
      PmSendCond = "(pmsend.t_ID,0) in ( (" + join( g_TrnParm.PmSendIDs, ",0),(" ) + ",0) ) ";
    end;
  elif( (valtype( g_TrnParm.gisgmpmsg ) != V_UNDEF) and (IsEqClass("TReqHandler", g_TrnParm.gisgmpmsg) // Если передана запись dgisgmpmsg_dbt,
                                                      or IsEqClass("TbFile", g_TrnParm.gisgmpmsg)      // то накладываем условия на связанный платеж или перевод
                                                      or (valtype( g_TrnParm.gisgmpmsg ) == V_GENOBJ)
                                                        ) 
      )   
    var DepsCond = "";                                                                                  
    var BranchesCond = "";
    var DateCond = "";
    if( g_TrnParm.gisgmpmsg.rec.Deps != "" )
      DepsCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "        and pm.t_StartDepartment in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.gisgmpmsg.rec.Deps ) + " ) ) " +
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "          and bd.t_Department in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.gisgmpmsg.rec.Deps ) + " ) ) " +
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    end;

    if( g_TrnParm.gisgmpmsg.rec.Branches != "" )
      BranchesCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "        and pm.t_OperNode in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.gisgmpmsg.rec.Branches ) + " ) ) "
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "        and bd.t_Branch in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.gisgmpmsg.rec.Branches ) + " ) ) "
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    end;

    if( GetCurDateFlag( g_TrnParm.gisgmpmsg.rec.Date ) == SET_CHAR )
      DateCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "          and pm.t_ValueDate = :PaymentValueDate " +
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd, dpmpaym_dbt pm " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "          and pm.t_PaymentID = bd.t_CoverPaymentID " +
                   "          and pm.t_ValueDate = :BdTransfValueDate " +
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    else
      DateCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "          and pm.t_ValueDate between :PaymentValueDateBegin and :PaymentValueDateEnd " +
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd, dpmpaym_dbt pm " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "          and pm.t_PaymentID = bd.t_CoverPaymentID " +
                   "          and pm.t_ValueDate between :BdTransfValueDateBegin and :BdTransfValueDateEnd " +
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    end;    

    if( (DepsCond != "") and (BranchesCond != "") )
      PmSendCond = " ( " + DepsCond + " or " + BranchesCond + " ) ";
    elif( DepsCond != "" )
      PmSendCond = " ( " + DepsCond + " ) ";
    elif( BranchesCond != "" )
      PmSendCond = " ( " + BranchesCond + " ) ";
    end;

    PmSendCond = IfThenElse( PmSendCond != "", " ( " + PmSendCond + " and " + DateCond + " ) ", " ( " + DateCond + " ) " );
  end;

  // Основной запрос
  var select : string = " select t.*, pmsendl.t_ID as t_PmSendID, count(1) over() as t_CountRow " +
                        " from ( " +
                          " select pmsend.t_ID as t_ID, " +
                          "        pmsend.t_ObjectType as t_ObjectType, " +
                          "        pmsend.t_ObjectID as t_ObjectID, " +
                          "        pmsend.t_UIP as t_UIP, " +
                          "        pmsend.t_Action as t_Action, " +
                          "        pmsend.t_Ground as t_Ground, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_UIN " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_UIN " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_SupplierBillID, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_Ground " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_Ground " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_Purpose, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_BaseAmount " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_Amount " +
                          "   else " +
                          "     0 " +
                          " end as t_Amount, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     to_date('0001-01-01','yyyy-mm-dd') " + // Дату приема к исполнению распоряжения плательщика будем искать при формировании пакета, там еще Date_Carry придется смотреть
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_Date " + // Еще Date_Carry придется смотреть
                          "   else " +
                          "     to_date('0001-01-01','yyyy-mm-dd') " +
                          " end as t_PaymentDate, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PayerBankEnterDate " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_Date " +
                          "   else " +
                          "     to_date('0001-01-01','yyyy-mm-dd') " +
                          " end as t_ReceiptDate, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_BTTTICode " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_BTTTICode " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_KBK, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_OKATOCode " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_OKATOCode " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_OKTMO, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_DocDispatchDate " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_DocDispatchDate from dpmrmprop_dbt where t_PaymentID = bdtransf.t_CoverPaymentID) " +
                          "   else " +
                          "     to_date('0001-01-01','yyyy-mm-dd') " +
                          " end as t_DeliveryDate, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_ShifrOper " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_ShifrOper from dpmrmprop_dbt where t_PaymentID = bdtransf.t_CoverPaymentID) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_TransKind, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_PayerBankName " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_PayerBankName from dpmrmprop_dbt where t_PaymentID = bdtransf.t_CoverPaymentID) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayerBankName, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     NVL(RSI_RSBPARTY.PT_GetPartyCode( pmpaym.t_PayerBankID, 3/*PM_COMMON.PTCK_BIC*/ ), chr(1)) " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     NVL(RSI_RSBPARTY.PT_GetPartyCode( (select t_PayerBankID from dpmpaym_dbt where t_PaymentID = bdtransf.t_CoverPaymentID), 3/*PM_COMMON.PTCK_BIC*/ ), chr(1)) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayerBankBIK, " +
                          " case " + // Код/номер подразделения банка будем определять при формировании пакета, поэтому пока берем PaymentID
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PaymentID " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_CoverPaymentID " +
                          "   else " +
                          "     0 " +
                          " end as t_PaymentID, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     (select t_CorAcc from dbankdprt_dbt where t_PartyID = pmpaym.t_PayerBankID) " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_CorAcc from dbankdprt_dbt where t_PartyID = (select t_PayerBankID from dpmpaym_dbt where t_PaymentID = bdtransf.t_CoverPaymentID)) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayerCorrespBankAccount, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     chr(1) " + // Единый или альтернативный идентификатор плательщика из платежа будем формировать при формировании пакета
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_TaxPersonRef " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayerIdentifier, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_Payer " + // Нужно для идентификатор плательщика из платежа будем формировать при формировании пакета
                          "   else " +
                          "     0 " +
                          " end as t_Payer, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_PayerName " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_PayerName " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayerName, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PayerAccount " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_PayerAccount " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayerAccount, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_ReceiverName " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_ReceiverName " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayeeName, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     NVL(PM_SCRHLP.GetINN( rm.t_ReceiverINN ), chr(1))" +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     NVL(PM_SCRHLP.GetINN( bdtransf.t_ReceiverINN ), chr(1)) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayeeINN, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     NVL(PM_SCRHLP.GetKPP( rm.t_ReceiverINN ), chr(1))" +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     NVL(PM_SCRHLP.GetKPP( bdtransf.t_ReceiverINN ), chr(1)) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayeeKPP, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     NVL(PM_COMMON.GetPartyCodeOnDateWOutOwner( pmpaym.t_Receiver, 27/*PM_COMMON.PTCK_OGRN*/, rm.t_Date ), chr(1)) " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     chr(1) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayeeOGRN, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_ReceiverAccount " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_ReceiverAccount " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayeeAccount, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_ReceiverBankName " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     NVL(PM_COMMON.GetCodeOwnerName( 3/*PM_COMMON.PTCK_BIC*/, bdtransf.t_ReceiverBankCode ), chr(1)) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_ReceiverBankName, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     NVL(PM_COMMON.FindPartCode( pmpaym.t_ReceiverBankID, 3/*PM_COMMON.PTCK_BIC*/ ), chr(1)) " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_ReceiverBankCode " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_ReceiverBankBIK, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     NVL(PM_COMMON.GetCodeOwnerCorAcc( 3/*PM_COMMON.PTCK_BIC*/, PM_COMMON.FindPartCode( pmpaym.t_ReceiverBankID, 3/*PM_COMMON.PTCK_BIC*/ ), null ), chr(1)) " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     NVL(PM_COMMON.GetCodeOwnerCorAcc( 3/*PM_COMMON.PTCK_BIC*/, bdtransf.t_ReceiverBankCode, null ), chr(1)) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PayeeCorrespBankAccount, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_TaxAuthorState " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_TaxAuthorState " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_Status, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_TaxPmGround " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_TaxPmGround " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PaytReason, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_TaxPmPeriod " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_TaxPmPeriod " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_TaxPeriod, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_TaxPmNumber " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_TaxPmNumber " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_TaxDocNumber, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_TaxPmDate " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     to_char(bdtransf.t_TaxPmDate, 'DD.MM.YYYY') " + /*Тут у нас беда, поле rm.t_TaxPmDate текстовое, поэтому возвращать будем тоже varchar2*/
                          "   else " +
                          "     chr(1) " +
                          " end as t_TaxDocDate, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_Number " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_Number from dpmrmprop_dbt where t_PaymentID = bdtransf.t_CoverPaymentID) " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_AccDocNo, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     rm.t_Date " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_Date from dpmrmprop_dbt where t_PaymentID = bdtransf.t_CoverPaymentID) " +
                          "   else " +
                          "     to_date('0001-01-01','yyyy-mm-dd') " +
                          " end as t_AccDocDate, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PartPaymShifrMain " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PartialPaytTransKind, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PartPaymNumber " +
                          "   else " +
                          "     0 " +
                          " end as t_PartPaymNumber, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     chr(1) " + // Содержание операции будем заполнять при формировании пакета
                          "   else " +
                          "     chr(1) " +
                          " end as t_TransContent, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PartPaymRestAmountMain " +
                          "   else " +
                          "     0 " +
                          " end as t_SumResidualPayt, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PartPaymNumMain " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_PartialPaytAccDocNo, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PartPaymDateMain " +
                          "   else " +
                          "     to_date('0001-01-01','yyyy-mm-dd') " +
                          " end as t_PartialPaytAccDocDate, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     chr(1) " + // Значение примечания "Идентификатор плательщика в ЕСИА" будем заполнять при формировании пакета
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_ESIAPersonRef " +
                          "   else " +
                          "     chr(1) " +
                          " end as t_ESIA_ID, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_Department " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     bdtransf.t_Department " +
                          "   else " +
                          "     0 " +
                          " end as t_Department, " +
                          " case " +
                          "   when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                          "     pmpaym.t_PayerBankID " +
                          "   when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                          "     (select t_PayerBankID from dpmpaym_dbt where t_PaymentID = bdtransf.t_CoverPaymentID) " +
                          "   else " +
                          "     0 " +
                          " end as t_PayerBankID " +
                          " from dpmsend_dbt pmsend " +
                          " left outer join dbdtransf_dbt bdtransf on bdtransf.t_BdTransfID = pmsend.t_ObjectID and pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ " +
                          " left outer join dpmpaym_dbt pmpaym on pmpaym.t_PaymentID = pmsend.t_ObjectID and pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ " +
                          " left outer join dpmrmprop_dbt rm on rm.t_PaymentID = pmpaym.t_PaymentID and pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ " +
                          " where pmsend.t_Action in ( :ActionCreate, :ActionRefinement, :ActionAnnulate, :ActionDeannulate ) " +
                          "   and pmsend.t_State = :State ";

  var params : TArray = makeArray( SQLParam( "ActionCreate",     WLD_ACTION_PMSEND_GG_CREATE ),
                                   SQLParam( "ActionRefinement", WLD_ACTION_PMSEND_GG_REFINEMENT ),
                                   SQLParam( "ActionAnnulate",   WLD_ACTION_PMSEND_GG_ANNULATE ),
                                   SQLParam( "ActionDeannulate", WLD_ACTION_PMSEND_GG_DEANNULATE ),
                                   SQLParam( "State",            WLD_STATUS_PMSEND_READY )
                                 );

  if( PmSendCond != "" )
    select = select + " and " + PmSendCond;
    if( Index( PmSendCond, ":PaymentValueDate" ) and (not Index( PmSendCond, ":PaymentValueDateBegin" )) )
      params[params.size] = SQLParam( "PaymentValueDate", GetDateAfterWorkDays( {curdate}, GetOffSet( g_TrnParm.gisgmpmsg.rec.Date ) ) );
    end;
    if( Index( PmSendCond, ":PaymentValueDateBegin" ) )
      params[params.size] = SQLParam( "PaymentValueDateBegin", GetMinDate( g_TrnParm.gisgmpmsg.rec.Date ) );
    end;
    if( Index( PmSendCond, ":PaymentValueDateEnd" ) )
      params[params.size] = SQLParam( "PaymentValueDateEnd", GetMaxDate( g_TrnParm.gisgmpmsg.rec.Date ) );
    end;

    if( Index( PmSendCond, ":BdTransfValueDate" ) and (not Index( PmSendCond, ":BdTransfValueDateBegin" )) )
      params[params.size] = SQLParam( "BdTransfValueDate", GetDateAfterWorkDays( {curdate}, GetOffSet( g_TrnParm.gisgmpmsg.rec.Date ) ) );
    end;
    if( Index( PmSendCond, ":BdTransfValueDateBegin" ) )
      params[params.size] = SQLParam( "BdTransfValueDateBegin", GetMinDate( g_TrnParm.gisgmpmsg.rec.Date ) );
    end;
    if( Index( PmSendCond, ":BdTransfValueDateEnd" ) )
      params[params.size] = SQLParam( "BdTransfValueDateEnd", GetMaxDate( g_TrnParm.gisgmpmsg.rec.Date ) );
    end;
  end;
  
  select = select + " and not exists ( select 1 " +
                    "                  from dpmsend_dbt pmsend1 " +
                    "                  where pmsend1.t_ID < pmsend.t_ID " +
                    "                    and pmsend1.t_State in ( :pmsend1State1, :pmsend1State2 ) " +
                    "                    and pmsend1.t_ObjectID = pmsend.t_ObjectID " +
                    "                    and pmsend1.t_ObjectType = pmsend.t_ObjectType " +
                    "                ) ";
  params[params.size] = SQLParam( "pmsend1State1", WLD_STATUS_PMSEND_READY );
  params[params.size] = SQLParam( "pmsend1State2", WLD_STATUS_PMSEND_SENDERROR );
  
  select = select + " ) t, dpmsend_dbt pmsendl " +
                    " where pmsendl.t_ID = t.t_ID ";
  select = select + IfThenElse( MaxPaymentPackage > 0, "and ROWNUM <= " + MaxPaymentPackage, ""); // Отбираем максимальное количество для формирования пакета
  select = select + " FOR UPDATE OF pmsendl.t_ID SKIP LOCKED "; // Сразу же лочим, что можно залочить
  
  var rs : RsdRecordset = execSQLselect( select, params, true );

  var systime = GetSysTime();
  var sysdate = date();   
  var i = 0;

  var Request = GMPPaymentSendRequestType(); // Создаём пакет для отправки в RS-Connect
  Request.RequestHeader = RequestHeaderType();
  Request.RequestHeader.ReqID = SubStr(CreateGUID(), 2, 36);
  Request.RequestHeader.SenderID = g_TrnParm.SenderID;
  Request.RequestData = RequestDataType();
  Request.RequestData.PaymentsPackage = PaymentsPackageType();
  Request.RequestData.PaymentsPackage.ImportedPayment = TArray();

  var PmSendIDs = TArray();

  while( rs and rs.moveNext() )
    Request.RequestData.PaymentsPackage.ImportedPayment[Request.RequestData.PaymentsPackage.ImportedPayment.size] = CreateGGPIImportedPayment( rs );
    UpdatePmSendSysDateAndTime( rs.value("t_PmSendID"), sysdate, systime );
    PmSendIDs[PmSendIDs.size] = rs.value("t_PmSendID"); // Нам нужно знать какие записи pmsend обновлять, если придет ошибка
  end;

  if( Request and (Request.RequestData.PaymentsPackage.ImportedPayment.size > 0) )
    var Response = callPaymentSendRequest( Request, g_TrnParm.RS_Connect_URL );
    if( Response )
      ProcessGGPIResponse( Response, PmSendIDs );
    end;
  end;

  return true;
  
onerror(x)
  if( x.Code == CtrlBrkErr )
    FlagCtrlBrk = true;
    CreateErrMsg( BNK_ERROR_MACROS_STR, x.Message );
  else  
    if(IsEqClass ("TRsbError", x.err) and (strlen(x.err.ToString()) > 0) )
      CreateErrMsg( BNK_ERROR_MACROS_STR, x.err.ToString() );
    else
      CreateErrMsg( BNK_ERROR_MACROS_STR, x.Message );
    end;
    AbortTrn();
  end;
end;

// Процедура передачи сведений для ГИС ГМП в RS-Connect

macro GGPIPmSendReqsTransfer( ggcp, PmSendIDs, ActionParam, gisgmpmsg, ReportFileName )


  const prmReportFileName = 4;

  if( ActionParam != 2/*WlGGPaymInfModuleAction_Transfer*/ ) // Только передаём, значит какие-то данные уже должны быть :)
    execSQL( "delete from dggrep_tmp" );
  end;

  var stat = 0;
  var v_gisgmpmsg = TRecHandler("gisgmpmsg.dbt");
  var OK : bool = true,
      ErrorMsg : string = "";
 
  if( ( (PmSendIDs == null) or (valtype(PmSendIDs) == V_UNDEF) or ( IsEqClass( "TArray", PmSendIDs ) and (PmSendIDs.size() <= 0) ) ) 
  and (valtype(gisgmpmsg) == V_UNDEF) 
    )
    GisGmpMsgParmsDefinition( ggcp, v_gisgmpmsg ); // Определение параметров для отбора платежей и переводов в бюджет
  elif( (valtype( gisgmpmsg ) != V_UNDEF) and (IsEqClass("TReqHandler", gisgmpmsg) or IsEqClass("TbFile", gisgmpmsg) or (valtype( gisgmpmsg ) == V_GENOBJ)) )
    copy( v_gisgmpmsg, gisgmpmsg );
  end;

  g_TrnParm = ProcessTrnParm( ggcp, PmSendIDs, ActionParam, v_gisgmpmsg );

  OK = (getRSConnectUrl(@g_TrnParm.RS_Connect_Url) == 0 );

  if(OK)
    OK = (getSenderID(@g_TrnParm.SenderID) == 0 );
  end;

  if(not OK)
    ErrorMsg = GetErrMsg();
  end;  

  ClearLogGGPIPmSend();

  if( not ProcessTrn( null,  "GGPIPmSendReqsTransferTRN" ) ) 
    OK = false;
    ErrorMsg = GetErrMsg();
    break;
  end;


  // Формируем итоговый протокол
  if( OK )
    // Формирование итогового протокола
    var Report : TGGPIPmSendReqsGeneratingReport = TGGPIPmSendReqsGeneratingReport( GGPIPmSendReqsGeneratingReportType_Transfer );
    var tmpReportFileName : string = "";
    tmpReportFileName = Report.GetReportFileName();
    var SwitchOutput : TSwitchOutputGisGmp = TSwitchOutputGisGmp( tmpReportFileName );
    Report.PrintReport();
    SetParm( prmReportFileName, tmpReportFileName );
  end;

  if( (not OK) and (ErrorMsg != "") )
    RunError( ErrorMsg, ErrorMsg );
  end;

  return IfThenElse( OK, 0, 1 );
  
OnError(er)
  ExeptionMessage(er); 
  return 1;
end;

// Процедура формирования запросов для передачи информации для ГИС ГМП в RS-Connect
macro GGPIPmSendReqsGenerating( ggcp, ActionParam, NeedTransfer, ReportFileName, pnl_gisgmpmsg )

  const prmReportFileName = 3;
  
  var stat = 0;
  var gisgmpmsg = TRecHandler("gisgmpmsg.dbt");

  execSQL( "delete from dggrep_tmp" );

  // Определение параметров для отбора платежей и переводов в бюджет
  if( (ggcp == GGMPDCallPoint_PaymInfPnl) and (valtype( pnl_gisgmpmsg ) == V_UNDEF) )
    RunError( "Нет данных для отбора платежей в ГИС ГМП", "Нет данных для отбора платежей в ГИС ГМП" ); // Если вызываем из панели, но по каким-либо причинам не передаем буфер
  elif( (ggcp == GGMPDCallPoint_PaymInfPnl) and ((valtype( pnl_gisgmpmsg ) != V_UNDEF) and (IsEqClass("TReqHandler", pnl_gisgmpmsg) 
                                                                                         or IsEqClass("TbFile", pnl_gisgmpmsg) 
                                                                                         or (valtype( pnl_gisgmpmsg ) == V_GENOBJ)
                                                                                           )
                                                ) 
      ) 
    copy( gisgmpmsg, pnl_gisgmpmsg ); // Если вызываем из панели, то берем данные из нее, т.к. они, возможно, не сохранены
  else
    GisGmpMsgParmsDefinition( ggcp, gisgmpmsg );
  end;

  // Отбор платежей и переводов в бюджет
  var rs : RsdRecordset = PaymsBdTransfsSelection( gisgmpmsg );

  // Процесс формирования запросов к внешней системе
  while( rs and rs.MoveNext() )
    var isGGPIPmSendCreated = false;
    var errMes = "";
    var insertedGGPIPmSendID : integer = 0;
    if( IsGGPIPmSendExists( rs.value( "t_ObjectID" ), int(rs.value( "t_ObjectType" )) ) )
      var PreviuosGGPIReqAction = GetPmSendAction( GetPreviousGGPIRequest( rs.value( "t_ObjectID" ), int(rs.value( "t_ObjectType" )) ) );
      if( PreviuosGGPIReqAction == WLD_ACTION_PMSEND_GG_ANNULATE )
        var RepitCancelMessage = Bnk_GetRegistryValue( RegPath_RepitCancelMessage, V_INTEGER, 0 );
        if( RepitCancelMessage == RepitCancelMessage_DeannulatePrevious )
          insertedGGPIPmSendID = InsertGGPIPmSend( rs.value( "t_ObjectID" ), int(rs.value( "t_ObjectType" )), WLD_ACTION_PMSEND_GG_DEANNULATE, "", @errMes );
          if( insertedGGPIPmSendID > 0 )
            isGGPIPmSendCreated = true;
          end;
        elif( RepitCancelMessage == RepitCancelMessage_CreateNew )
          insertedGGPIPmSendID = InsertGGPIPmSend( rs.value( "t_ObjectID" ), int(rs.value( "t_ObjectType" )), WLD_ACTION_PMSEND_GG_CREATE, "", @errMes );
          if( insertedGGPIPmSendID > 0 )
            isGGPIPmSendCreated = true;
          end;
        end;
      end;
    else
      insertedGGPIPmSendID = InsertGGPIPmSend( rs.value( "t_ObjectID" ), int(rs.value( "t_ObjectType" )), WLD_ACTION_PMSEND_GG_CREATE, "", @errMes );
      if( insertedGGPIPmSendID > 0 )
        isGGPIPmSendCreated = true;
      end;
    end;
    // Если создавалась запись pmsend, то формируется запись протокола ggrep
    if( isGGPIPmSendCreated )
      var Result : string = "";
      if( insertedGGPIPmSendID )
        Result = "Запрос для передачи сведений в RS-Connect для ГИС ГМП создан успешно";
      else
        Result = errMes;
      end;
      InsertGGRepData( rs.value( "t_ObjectID" ), int(rs.value( "t_ObjectType" )), rs.value( "t_Department" ), rs.value( "t_Branch" ), insertedGGPIPmSendID, SubStr(Result, 1, 200) );
    end;
  end;

  // Процесс передачи информации для ГИС ГМП в RS-Connect
  if( ((ggcp == GGMPDCallPoint_Sheduler) and (ActionParam == 3)) 
   or ((ggcp == GGMPDCallPoint_ReqJournal) and (NeedTransfer == true)) 
   or ((ggcp == GGMPDCallPoint_PaymInfPnl) and (NeedTransfer == true))
    )
    stat = GGPIPmSendReqsTransfer( ggcp, null, ActionParam, gisgmpmsg );
  end;
  
  // Формирование итогового протокола
  var Report : TGGPIPmSendReqsGeneratingReport = TGGPIPmSendReqsGeneratingReport( GGPIPmSendReqsGeneratingReportType_Generating );
  var tmpReportFileName : string = "";
  tmpReportFileName = Report.GetReportFileName();
  var SwitchOutput : TSwitchOutputGisGmp = TSwitchOutputGisGmp( tmpReportFileName );
  Report.PrintReport();
  SetParm( prmReportFileName, tmpReportFileName );

  return 0;

OnError(er)
  ExeptionMessage(er); 
end;

// Процедура повторной отправки для ГИС ГМП в RS-Connect
macro GGPIPmSendReqsResending( AddrPmsend, PmSendIDNeedToProc, GErrMes ):integer


  record pmsend(pmsend);
  SetBuff( pmsend, AddrPmsend );

  const prmPmSendIDNeedToProc = 1;
  const prmGErrMes = 2;

  var stat = true;
  var ErrMes = "";
  var PmSendIDs = TArray();

  execSQL( "delete from dggrep_tmp" );
  
  if( pmsend.State != WLD_STATUS_PMSEND_SENDERROR )
    ErrMes = "Повторная отправка возможна только для запросов, сведения по которым ранее не были приняты RS-Connect, т.е. со статусом \"Ошибка передачи\"";
    stat = false;
  end;

  if( stat )
    var select = " select 1 " +
                 " from dpmsend_dbt pmsend1 " +
                 " where pmsend1.t_ID > :PmSendID " +
                 "   and pmsend1.t_ObjectID = :PmSendObjectID " +
                 "   and pmsend1.t_ObjectType = :PmSendObjectType " +
                 "   and pmsend1.t_State in ( :pmsend1State1, :pmsend1State2 ) ";
    var params : TArray = makeArray( SQLParam( "PmSendID",         pmsend.ID ),
                                     SQLParam( "PmSendObjectID",   pmsend.ObjectID ),
                                     SQLParam( "PmSendObjectType", pmsend.ObjectType ),
                                     SQLParam( "pmsend1State1",    WLD_STATUS_PMSEND_SEND ),
                                     SQLParam( "pmsend1State2",    WLD_STATUS_PMSEND_RECANSWER )
                                   );
    var rs : RsdRecordset = execSQLselect( select, params, true );

    if( rs and rs.MoveNext )
      ErrMes = "Есть более поздние запросы по тому же платежу, принятые RS-Connect. Повторная отправка не допускается";
      stat = false;
    end;
  end;

  if( stat )
    UpdatePmSendState( pmsend.ID, WLD_STATUS_PMSEND_READY );
    var lastUPReqID = GetLastUnprocessedGGPIRequest( pmsend.ObjectID, pmsend.ObjectType );
    if( (lastUPReqID <= 0) or (lastUPReqID == pmsend.ID) )
      PmSendIDs[PmSendIDs.size] = pmsend.ID;
    else
      ErrMes = "Запрос будет отправлен в порядке очереди";
      stat = false;
    end;
  end;

  if( (PmSendIDs.size() > 0) )
    SetParm(prmPmSendIDNeedToProc, PmSendIDs[0]);
  end;

  if( not IsOprMultiExec() )
    if( stat and (PmSendIDs.size > 0) )
      GGPIPmSendReqsTransfer( GGMPDCallPoint_PaymInfPnl, PmSendIDs );
    end;
  end;

  if( (not stat) and (ErrMes != "") )
    if( not IsOprMultiExec() )
      msgbox( ErrMes );
    else
      SetParm( PrmGErrMes, ErrMes );
    end;
  end;
  
  return IfThenElse( stat, 0, 1 );

OnError(er)
  ExeptionMessage(er); 
end;


// Процедура уточнения информации для ГИС ГМП
macro GGPIPmSendReqsRefinement( AddrPmsend, ChngGrnd )


  record pmsend(pmsend);
  SetBuff( pmsend, AddrPmsend );

  var stat = true;
  var ErrMes = "";
  var PmSendIDs = TArray();
  var ChangeGround = "";

  execSQL( "delete from dggrep_tmp" );
  
  var PmSend1ID = GetPreviousGGPIRequest( pmsend.ObjectID, pmsend.ObjectType );
  var tmpObjectID : integer = 0, tmpObjectType : integer = 0, tmpDepartment : integer = 0, tmpBranch : integer = 0;
  var insertedGGPIPmSendID = 0;
  var pmSendAction = GetPmSendAction( PmSend1ID );
  GetGGPIPmSendData( PmSend1ID, @tmpObjectID, @tmpObjectType );

  if( pmSendAction == WLD_ACTION_PMSEND_GG_ANNULATE )
    ErrMes = "Сообщение по платежу аннулировано (создан запрос об аннулировании). Уточнение аннулированных сообщений для ГИС ГМП не допускается";
    stat = false;
  elif( InList( pmSendAction, WLD_ACTION_PMSEND_GG_CREATE, WLD_ACTION_PMSEND_GG_REFINEMENT, WLD_ACTION_PMSEND_GG_DEANNULATE ) )
    if( IsOprMultiExec() and ((valtype(ChngGrnd) == V_STRING) and (ChngGrnd != "")))
      ChangeGround = ChngGrnd;
    else
      ChangeGround = GGPIFillChangeGround( "Вы не указали основание изменения ранее направленных сведений по платежу. Использовать значение по умолчанию из настройки", RegPath_ChangeReason_ChangeStatus_2 );
    end;
    if( ChangeGround == "" )
      stat = false;
    end;
  else
    stat = false;
  end;

  var InsertedPmSend : integer = 0;

  if( stat )
    var pStat = 0;
    InsertedPmSend = InsertGGPIPmSend( tmpObjectID, tmpObjectType, WLD_ACTION_PMSEND_GG_REFINEMENT, ChangeGround, @ErrMes, pStat );
    stat = not pStat;
  end;
  
  if( stat )
    var lastUPReqID = GetLastUnprocGGPIRequestWOI( tmpObjectID, tmpObjectType, InsertedPmSend );

    if( (lastUPReqID <= 0) and (InsertedPmSend > 0) )
      PmSendIDs[PmSendIDs.size] = InsertedPmSend;
    else
      ErrMes = "Запрос на уточнение информации по платежу создан и будет отправлен в порядке очереди";
      stat = false;
    end;
  end;

  if( stat and (PmSendIDs.size > 0) )
    GGPIPmSendReqsTransfer( GGMPDCallPoint_PaymInfPnl, PmSendIDs );
  end;

  if( (not stat) and (ErrMes != "") )
    msgbox( ErrMes );
  end;
  
  return IfThenElse( stat, 0, 1 );
  
OnError(er)
  ExeptionMessage(er); 
end;

// Процедура аннулирования информации для ГИС ГМП
macro GGPIPmSendReqsAnnulate( AddrPmsend, ChngGrnd, PmSendIDNeedToProc, GErrMes )


  record pmsend(pmsend);
  SetBuff( pmsend, AddrPmsend );

  const prmPmSendIDNeedToProc = 2;
  const prmGErrMes = 3;

  var stat = true;
  var ErrMes = "";
  var PmSendIDs = TArray();
  var ChangeGround = "";

  execSQL( "delete from dggrep_tmp" );
  
  var PmSend1ID = GetPreviousGGPIRequest( pmsend.ObjectID, pmsend.ObjectType );
  var tmpObjectID : integer = 0, tmpObjectType : integer = 0, tmpDepartment : integer = 0, tmpBranch : integer = 0;
  var insertedGGPIPmSendID = 0;
  var pmSendAction = GetPmSendAction( PmSend1ID );
  GetGGPIPmSendData( PmSend1ID, @tmpObjectID, @tmpObjectType );

  if( pmSendAction == WLD_ACTION_PMSEND_GG_ANNULATE )
    ErrMes = "Сообщение по платежу уже аннулировано (создан запрос об аннулировании)";
    stat = false;
  elif( InList( pmSendAction, WLD_ACTION_PMSEND_GG_CREATE, WLD_ACTION_PMSEND_GG_REFINEMENT, WLD_ACTION_PMSEND_GG_DEANNULATE ) )
    if( IsOprMultiExec() and ((valtype(ChngGrnd) == V_STRING) and (ChngGrnd != "")))
      ChangeGround = ChngGrnd;
    else
      ChangeGround = GGPIFillChangeGround( "Вы не указали основание аннулирования ранее направленных сведений по платежу(ам). Использовать значение по умолчанию из настройки", RegPath_ChangeReason_ChangeStatus_3 );
    end;
    if( ChangeGround == "" )
      stat = false;
    end;
  else
    stat = false;
  end;

  var InsertedPmSend : integer = 0;

  if( stat )
    var pStat = 0;
    InsertedPmSend = InsertGGPIPmSend( tmpObjectID, tmpObjectType, WLD_ACTION_PMSEND_GG_ANNULATE, ChangeGround, @ErrMes, pStat );
    stat = not pStat;
  end;

  if( stat )
    var lastUPReqID = GetLastUnprocGGPIRequestWOI( tmpObjectID, tmpObjectType, InsertedPmSend );

    if( (lastUPReqID <= 0) and (InsertedPmSend > 0) )
      PmSendIDs[PmSendIDs.size] = InsertedPmSend;
    else
      ErrMes = "Запрос на аннулирование информации по платежу создан и будет отправлен в порядке очереди";
      stat = false;
    end;
  end;

  SetParm( prmPmSendIDNeedToProc, InsertedPmSend );

  if( not IsOprMultiExec() )
    if( stat and (PmSendIDs.size > 0) )
      GGPIPmSendReqsTransfer( GGMPDCallPoint_PaymInfPnl, PmSendIDs );
    end;
  end;

  if( (not stat) and (ErrMes != "") )
    if( not IsOprMultiExec() )
      msgbox( ErrMes );
    else
      SetParm( PrmGErrMes, ErrMes );
    end;
  end;

  // В пакетном режиме отчет по F5
  
  return IfThenElse( stat, 0, 1 );

OnError(er)
  ExeptionMessage(er); 
end;

// Процедура деаннулирования информации для ГИС ГМП
macro GGPIPmSendReqsDeannulate( AddrPmsend, ChngGrnd, PmSendIDNeedToProc, GErrMes )


  record pmsend(pmsend);
  SetBuff( pmsend, AddrPmsend );

  const prmPmSendIDNeedToProc = 2;
  const prmGErrMes = 3;

  var stat = true;
  var ErrMes = "";
  var PmSendIDs = TArray();
  var ChangeGround = "";

  execSQL( "delete from dggrep_tmp" );
  
  var PmSend1ID = GetPreviousGGPIRequest( pmsend.ObjectID, pmsend.ObjectType );
  var tmpObjectID : integer = 0, tmpObjectType : integer = 0, tmpDepartment : integer = 0, tmpBranch : integer = 0;
  var insertedGGPIPmSendID = 0;
  var pmSendAction = GetPmSendAction( PmSend1ID );
  GetGGPIPmSendData( PmSend1ID, @tmpObjectID, @tmpObjectType );

  if( InList( pmSendAction, WLD_ACTION_PMSEND_GG_REFINEMENT, WLD_ACTION_PMSEND_GG_DEANNULATE ) )
    ErrMes = "Последнее сообщение для ГИС ГМП, отправленное (готовое к отправке) по платежу, не является сообщением об аннулировании. Деаннулирование не допускается";
    stat = false;
  elif( pmSendAction == WLD_ACTION_PMSEND_GG_ANNULATE ) 
    if( IsOprMultiExec() and ((valtype(ChngGrnd) == V_STRING) and (ChngGrnd != "")))
      ChangeGround = ChngGrnd;
    else
      ChangeGround = GGPIFillChangeGround( "Вы не указали основание деаннулирования ранее направленных сведений по платежу(ам). Использовать значение по умолчанию из настройки", RegPath_ChangeReason_ChangeStatus_4 );
    end;
    if( ChangeGround == "" )
      stat = false;
    end;
  else
    stat = false;
  end;

  var InsertedPmSend : integer = 0;

  if( stat )
    var pStat = 0;
    InsertedPmSend = InsertGGPIPmSend( tmpObjectID, tmpObjectType, WLD_ACTION_PMSEND_GG_DEANNULATE, ChangeGround, @ErrMes, pStat );
    stat = not pStat;
  end;

  if( stat )
    var lastUPReqID = GetLastUnprocGGPIRequestWOI( tmpObjectID, tmpObjectType, InsertedPmSend );

    if( (lastUPReqID <= 0) and (InsertedPmSend > 0) )
      PmSendIDs[PmSendIDs.size] = InsertedPmSend;
    else
      ErrMes = "Запрос на деаннулирование информации по платежу создан и будет отправлен в порядке очереди";
      stat = false;
    end;
  end;

  SetParm( prmPmSendIDNeedToProc, InsertedPmSend );

  if( not IsOprMultiExec() )
    if( stat and (PmSendIDs.size > 0) )
      GGPIPmSendReqsTransfer( GGMPDCallPoint_PaymInfPnl, PmSendIDs );
    end;
  end;

  if( (not stat) and (ErrMes != "") )
    if( not IsOprMultiExec() )
      msgbox( ErrMes );
    else
      SetParm( PrmGErrMes, ErrMes );
    end;
  end;


  // В пакетном режиме отчет по F5
  
  return IfThenElse( stat, 0, 1 );

OnError(er)
  ExeptionMessage(er); 
end;


private macro ProcessGGNSRResponse( Response, PmSendIDs ):bool
  private macro ParseDocumentID( DocumentID : string, ObjectID : @integer, ObjectType : @integer ):bool
    if( strlen( DocumentID ) and Index( DocumentID, "_" ) )
      ObjectType = int( SubStr( DocumentID, 1, Index( DocumentID, "_" ) - 1 ) );
      ObjectID = int( SubStr( DocumentID, Index( DocumentID, "_" ) + 1 ) );
      return true;
    end;
    return false;
  end;

  var params;
  var update;

  if( Response )
    if( Response.ResponseConnectData and Response.ResponseConnectData.ObjectError )
      return false;
    end;

    if( not Response.ResponseServiceData )
     return false;
    end;

    if( Response.ResponseServiceData and Response.ResponseServiceData.ResponseContent and Response.ResponseServiceData.ResponseContent.StatusInfoList )
      var ProcessedPmSendIDs = TArray();
      var isDupl:bool = false;
      var tmpProcID = 0;

      var PmSendCond = "";
      if( PmSendIDs and (PmSendIDs.size > 0) )
        if( PmSendIDs.size() < 1000 ) // В конструкцию IN в Oracle нельзя запихнуть более 1000 значений
          PmSendCond = "pmsend.t_ID in ( " + join( PmSendIDs, "," ) + " ) ";
        else // Если же кто-то очень умный передал более 1000 идентификаторов - делаем магию
          PmSendCond = "(pmsend.t_ID,0) in ( (" + join( PmSendIDs, ",0),(" ) + ",0) ) ";
        end;
      end;

      var query : string = "";
      var rs;

      var tmpObjectID : integer = 0, tmpObjectType : integer = 0, tmpDepartment : integer = 0, tmpBranch : integer = 0;
      var Description : string = "";

      for( var StatusInfo, Response.ResponseServiceData.ResponseContent.StatusInfoList.StatusInfo )
        var tmpPmSendIDs = TArray();
        
        var tmpAction = 0;
        if( StatusInfo.ChangeStatus != "" )
          if( StatusInfo.ChangeStatus == "1" )
            tmpAction = WLD_ACTION_PMSEND_GG_CREATE;
          elif( StatusInfo.ChangeStatus == "2" )
            tmpAction = WLD_ACTION_PMSEND_GG_REFINEMENT;
          elif( StatusInfo.ChangeStatus == "3" )
            tmpAction = WLD_ACTION_PMSEND_GG_ANNULATE;
          elif( StatusInfo.ChangeStatus == "4" )
            tmpAction = WLD_ACTION_PMSEND_GG_DEANNULATE;
          end;
        end;

        var needChStAnalyse = false;

        if( (valtype(StatusInfo.ObjectID) == V_STRING) and (StatusInfo.ObjectID != "") )
          query = " select pmsend.t_ID as t_ID, pmsend.t_Action as t_Action " +
                  " from dpmsend_dbt pmsend " +
                  " where pmsend.t_ExtObjectID = :ExtObjectID ";
          if( PmSendCond != "" )
            query = query + " and " + PmSendCond; // Только для находящихся в переданном процедуре разбора массиве, т.е. для залоченных процедурой
          end;
          rs = execSQLselectPrm( query, SQLParam( "ExtObjectID", StatusInfo.ObjectID ) );

          needChStAnalyse = false;
          if( (rs != null) and (rs.RecCount > 1) and (tmpAction != 0) )
            needChStAnalyse = true;
          end;

          while( rs and rs.moveNext() )
            if( (not needChStAnalyse) or ( needChStAnalyse and (tmpAction == rs.value("t_Action")) ) )
              tmpPmSendIDs[tmpPmSendIDs.size] = rs.value("t_ID");
              isDupl = false;
              tmpProcID = 0;
              for( tmpProcID, ProcessedPmSendIDs )
                if( tmpProcID == rs.value("t_ID") )
                  isDupl = true;
                end;
              end;
              if( not isDupl )
                ProcessedPmSendIDs[ProcessedPmSendIDs.size] = rs.value("t_ID");
              end;
            end;
          end;          
        end;        
        
        var ObjectID = 0, ObjectType = 0;     
        if( (tmpPmSendIDs.size == 0) and ((valtype(StatusInfo.DocumentID) == V_STRING) and (StatusInfo.DocumentID != "")) and ParseDocumentID( StatusInfo.DocumentID, @ObjectID, @ObjectType ) )
          query = " select pmsend.t_ID as t_ID, pmsend.t_Action as t_Action " +
                  " from dpmsend_dbt pmsend " +
                  " where pmsend.t_ObjectID   = :ObjectID " +
                  "   and pmsend.t_ObjectType = :ObjectType ";
          if( PmSendCond != "" )
            query = query + " and " + PmSendCond; // Только для находящихся в переданном процедуре разбора массиве, т.е. для залоченных процедурой
          end;
          rs  = execSQLselectPrm( query,
                                  SQLParam( "ObjectID",  ObjectID ),
                                  SQLParam( "ObjectType", ObjectType ) );

          needChStAnalyse = false;
          if( (rs != null) and (rs.RecCount > 1) and (tmpAction != 0) )
            needChStAnalyse = true;
          end;

          while( rs and rs.moveNext() )
            if( (not needChStAnalyse) or ( needChStAnalyse and (tmpAction == rs.value("t_Action")) ) )
              tmpPmSendIDs[tmpPmSendIDs.size] = rs.value("t_ID");
              isDupl = false;
              tmpProcID = 0;
              for( tmpProcID, ProcessedPmSendIDs )
                if( tmpProcID == rs.value("t_ID") )
                  isDupl = true;
                end;
              end;
              if( not isDupl )
                ProcessedPmSendIDs[ProcessedPmSendIDs.size] = rs.value("t_ID");
              end;
            end;
          end;          
        end;
        
        var tmpPmSendCond = "";
        if( tmpPmSendIDs and (tmpPmSendIDs.size > 0) )
          if( tmpPmSendIDs.size() < 1000 ) // В конструкцию IN в Oracle нельзя запихнуть более 1000 значений
            tmpPmSendCond = "pmsend.t_ID in ( " + join( tmpPmSendIDs, "," ) + " ) ";
          else // Если же кто-то очень умный передал более 1000 идентификаторов - делаем магию
            tmpPmSendCond = "(pmsend.t_ID,0) in ( (" + join( tmpPmSendIDs, ",0),(" ) + ",0) ) ";
          end;
        end;

        var tmpState = WLD_STATUS_PMSEND_DEFER;
        if( StatusInfo.StatusCode and (valtype(StatusInfo.StatusCode) == V_STRING) )
          var FinishStatus = Bnk_GetRegistryValue( RegPath_StatusNotice_FinishStatus, V_STRING, "" );
          var RejectStatus = Bnk_GetRegistryValue( RegPath_StatusNotice_RejectStatus, V_STRING, "" );        
          if( Index( FinishStatus, StatusInfo.StatusCode ) )
            tmpState = WLD_STATUS_PMSEND_FINISHED;
          elif( Index( RejectStatus, StatusInfo.StatusCode ) )
            tmpState = WLD_STATUS_PMSEND_NOTRECEIVE;
          end;
        end;


        update = " update dpmsend_dbt pmsend set " +
                 IfThenElse( ((valtype(StatusInfo.StatusCode) == V_STRING) and (StatusInfo.StatusCode != "")), 
                                               " pmsend.t_ExtState = :ExtState  ", 
                                               "                                " 
                           ) +
                 IfThenElse( ((valtype(StatusInfo.StatusCode) == V_STRING) and (StatusInfo.StatusCode != "")), 
                                               " ,  ", 
                                               "    " 
                           ) +
                 IfThenElse( ((valtype(StatusInfo.StatusText) == V_STRING) and (StatusInfo.StatusText != "")), 
                                               " pmsend.t_ExtStateDescr = :ExtStateDescr  ", 
                                               "                                          " 
                           ) +
                 IfThenElse( (((valtype(StatusInfo.StatusCode) == V_STRING) and (StatusInfo.StatusCode != "")) 
                           or ((valtype(StatusInfo.StatusText) == V_STRING) and (StatusInfo.StatusText != ""))), 
                                               " ,  ", 
                                               "    " 
                           ) +
                 IfThenElse( ((valtype(StatusInfo.TimeStamp) == V_STRING) and (StatusInfo.TimeStamp != "")), 
                                               " pmsend.t_ExtStateDate = :ExtStateDate, pmsend.t_ExtStateTime = :ExtStateTime ", 
                                               "                                                                              " ) +
                 IfThenElse( ((((valtype(StatusInfo.StatusCode) == V_STRING) and (StatusInfo.StatusCode != "")) 
                            or ((valtype(StatusInfo.StatusText) == V_STRING) and (StatusInfo.StatusText != ""))
                            or ((valtype(StatusInfo.TimeStamp ) == V_STRING) and (StatusInfo.TimeStamp  != ""))) and ( StatusInfo.ObjectError or StatusInfo.ExternalError )), 
                                               " ,  ", 
                                               "    " 
                           ) +
                 IfThenElse( ( StatusInfo.ObjectError or StatusInfo.ExternalError ), 
                                               " pmsend.t_ProcessCode = :ProcessCode, pmsend.t_Description = :Description ", 
                                               "                                                                          " 
                           );

        if( tmpState != WLD_STATUS_PMSEND_DEFER )
          update = update + "                   , pmsend.t_State = :State ";
        end;
        update = update + " where " + IfThenElse( tmpPmSendCond != "", tmpPmSendCond, " 1 = 0 " );

        update = update + " ; ";

        var tmpCode : string = "";
        if( StatusInfo.ExternalError )
          if( StatusInfo.ExternalError.ExternalSource == 1 )
            tmpCode = "СМЭВ_";
          elif( StatusInfo.ExternalError.ExternalSource == 2 )
            tmpCode = "ГИСГМП_";
          end;
          if( StatusInfo.ExternalError.ExternalCode != "" )
            tmpCode = tmpCode + StatusInfo.ExternalError.ExternalCode;
          end;
        end;
       
        params = TArray();
        if( (valtype(StatusInfo.StatusCode) == V_STRING) and (StatusInfo.StatusCode != "") )
          params[params.size] = SQLParam( "ExtState", StatusInfo.StatusCode );
        end;
        if( (valtype(StatusInfo.StatusText) == V_STRING) and (StatusInfo.StatusText != "") )
          params[params.size] = SQLParam( "ExtStateDescr", StatusInfo.StatusText );
        end;
        if( (valtype(StatusInfo.TimeStamp) == V_STRING) and (StatusInfo.TimeStamp != "") )
          var tmpDate : date = date(0,0,0);
          var tmpTime : time;
          var tmpTimeStr = "", tmpDateStr = "";
          var DelTimeInd = Index( StatusInfo.TimeStamp, " " );
          tmpDateStr = SubStr( StatusInfo.TimeStamp, 1, DelTimeInd - 1 );
          tmpTimeStr = SubStr( StatusInfo.TimeStamp, DelTimeInd + 1 );
          tmpDate = date(tmpDateStr);
          tmpTime = hhmmssToTime( @tmpTimeStr );
          params[params.size] = SQLParam( "ExtStateDate",  tmpDate );
          params[params.size] = SQLParam( "ExtStateTime",  tmpTime );
        end;
        if( StatusInfo.ObjectError or StatusInfo.ExternalError )
          params[params.size] = SQLParam( "ProcessCode", IfThenElse( (StatusInfo.ObjectError and (not StatusInfo.ExternalError)), 
                                                                      StatusInfo.ObjectError.ErrorCode, 
                                                                      tmpCode 
                                                                   ) );
          params[params.size] = SQLParam( "Description", IfThenElse( (StatusInfo.ObjectError and (not StatusInfo.ExternalError)), 
                                                                      IfThenElse( StatusInfo.ObjectError.ErrorText.size > 0,  StatusInfo.ObjectError.ErrorText[0], "" ), 
                                                                      StatusInfo.ExternalError.ExternalText 
                                                                   ) );
        end;
        
        if( tmpState != WLD_STATUS_PMSEND_DEFER )
          params[params.size] = SQLParam( "State", tmpState );
        end;

        rs = execSQL( update, params, true );

        if( rs ) // если всё нормально, то обновились данные запросов с идентификаторами из tmpPmSendIDs
          for( var procid, tmpPmSendIDs )  
            AddRecLogGGPIPmSend( procid ); // OutPmsendID                  

            tmpObjectID = 0;
            tmpObjectType = 0;
            tmpDepartment = 0;
            tmpBranch = 0;
            Description = "";
            GetGGPIPmSendData( procid, @tmpObjectID, @tmpObjectType, @tmpDepartment, @tmpBranch, @Description );
            InsertGGRepData( tmpObjectID, tmpObjectType, tmpDepartment, tmpBranch, procid, SubStr(Description, 1, 200) );
          end;
        end;
      end;

      var notProcessedPmSendIDs = TArray();

      if( ProcessedPmSendIDs.size != PmSendIDs.size ) // Если из Rs-Connect пришли данные не по всем запросам
          var exists = false;
          for( var pmsendid, PmSendIDs )
            exists = false;
            for( var processedid, ProcessedPmSendIDs )
              if( pmsendid == processedid )
                exists = true;
              end;
            end;
            if( not exists )
              notProcessedPmSendIDs[notProcessedPmSendIDs.size] = pmsendid;
            end;
          end;
      end;

      if( notProcessedPmSendIDs and (notProcessedPmSendIDs.size > 0) )
        tmpObjectID = 0;
        tmpObjectType = 0;
        tmpDepartment = 0;
        tmpBranch = 0;
        Description = "";
        for( pmsendid, notProcessedPmSendIDs )
          GetGGPIPmSendData( pmsendid, @tmpObjectID, @tmpObjectType, @tmpDepartment, @tmpBranch, @Description );
          InsertGGRepData( tmpObjectID, tmpObjectType, tmpDepartment, tmpBranch, pmsendid, "Статус извещения в RS-Connect не был обновлен" );
        end;
      end;

    else
      return false;
    end;
  else
    return false;
  end;

  return true;
end;

macro GGPmSendNotificationStatusRequestTRN()


  var stat = true;

  var MaxPaymentPackage = Bnk_GetRegistryValue( RegPath_MaxPaymentPackage, V_INTEGER, 1000 );

  var PmSendCond = "";
  // Отбираем только определенные записи pmsend
  if( (g_TrnParm.PmSendIDs != null) and (valtype( g_TrnParm.PmSendIDs ) != V_UNDEF) and (IsEqClass( "TArray", g_TrnParm.PmSendIDs ) and (g_TrnParm.PmSendIDs.size() > 0)) ) // Если переданы идентификаторы dpmsend_dbt.t_ID
    if( g_TrnParm.PmSendIDs.size() < 1000 ) // В конструкцию IN в Oracle нельзя запихнуть более 1000 значений
      PmSendCond = "pmsend.t_ID in ( " + join( g_TrnParm.PmSendIDs, "," ) + " ) ";
    else // Если же кто-то очень умный передал более 1000 идентификаторов - делаем магию
      PmSendCond = "(pmsend.t_ID,0) in ( (" + join( g_TrnParm.PmSendIDs, ",0),(" ) + ",0) ) ";
    end;
  else
    var DepsCond = "";                                                                                  
    var BranchesCond = "";
    var DateCond = "";
    if( g_TrnParm.Department != "" )
      DepsCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "        and pm.t_StartDepartment in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.Department ) + " ) ) " +
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "          and bd.t_Department in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.Department ) + " ) ) " +
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    end;
    if( g_TrnParm.Branch != "" )
      BranchesCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "        and pm.t_OperNode in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.Branch ) + " ) ) "
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "        and bd.t_Branch in ( select t_code from ddp_dep_dbt where t_Name in ( " + ConvertInCondToSQLFormat( g_TrnParm.Branch ) + " ) ) "
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    end;

    if( (g_TrnParm.BeginDate != date(0,0,0)) and (g_TrnParm.EndDate != date(0,0,0)) )
      DateCond = " ( " +
                   " ( " +
                   "   case " +
                   "     when pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ then " +
                   "      ( select 1 " +
                   "        from dpmpaym_dbt pm " +
                   "        where pm.t_PaymentID = pmsend.t_ObjectID " +
                   "          and pm.t_ValueDate between :PaymentValueDateBegin and :PaymentValueDateEnd " +
                   "      ) " +
                   "     when pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ then " +
                   "      ( select 1 " +
                   "        from dbdtransf_dbt bd, dpmpaym_dbt pm " +
                   "        where bd.t_BdTransfID = pmsend.t_ObjectID " +
                   "          and pm.t_PaymentID = bd.t_CoverPaymentID " +
                   "          and pm.t_ValueDate between :BdTransfValueDateBegin and :BdTransfValueDateEnd " +
                   "      ) " +
                   "     else " +
                   "      0 " +
                   "     end " +
                   " ) = 1 " +
                 " ) ";
    end;    

    if( (DepsCond != "") and (BranchesCond != "") )
      PmSendCond = " ( " + DepsCond + " or " + BranchesCond + " ) ";
    elif( DepsCond != "" )
      PmSendCond = " ( " + DepsCond + " ) ";
    elif( BranchesCond != "" )
      PmSendCond = " ( " + BranchesCond + " ) ";
    end;
    if( DateCond != "" )
      PmSendCond = IfThenElse( PmSendCond != "", " ( " + PmSendCond + " and " + DateCond + " ) ", " ( " + DateCond + " ) " );
    end;
  end;

  // Основной запрос
  var select : string = " select t.*, pmsendl.t_ID as t_PmSendID, count(1) over() as t_CountRow " +
                        " from ( " +
                          " select pmsend.t_ID as t_ID, " +
                          "        pmsend.t_ObjectType as t_ObjectType, " +
                          "        pmsend.t_ObjectID as t_ObjectID, " +
                          "        pmsend.t_UIP as t_UIP, " +
                          "        pmsend.t_Action as t_Action, " +
                          "        pmsend.t_Ground as t_Ground, " +
                          "        pmsend.t_ExtObjectID as t_ExtObjectID " +
                          " from dpmsend_dbt pmsend" +
                          " left outer join dbdtransf_dbt bdtransf on bdtransf.t_BdTransfID = pmsend.t_ObjectID and pmsend.t_ObjectType = 536/*OBJTYPE_BDTRANSF*/ " +
                          " left outer join dpmpaym_dbt pmpaym on pmpaym.t_PaymentID = pmsend.t_ObjectID and pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ " +
                          " left outer join dpmrmprop_dbt rm on rm.t_PaymentID = pmpaym.t_PaymentID and pmsend.t_ObjectType = 501/*OBJTYPE_PAYMENT*/ " +
                          " where pmsend.t_Action in ( :ActionCreate, :ActionRefinement, :ActionAnnulate, :ActionDeannulate ) " +
                          "   and pmsend.t_State = :State ";

  var params : TArray = makeArray( SQLParam( "ActionCreate",     WLD_ACTION_PMSEND_GG_CREATE ),
                                   SQLParam( "ActionRefinement", WLD_ACTION_PMSEND_GG_REFINEMENT ),
                                   SQLParam( "ActionAnnulate",   WLD_ACTION_PMSEND_GG_ANNULATE ),
                                   SQLParam( "ActionDeannulate", WLD_ACTION_PMSEND_GG_DEANNULATE ),
                                   SQLParam( "State",            WLD_STATUS_PMSEND_SEND )
                                 );
                                 
  if( PmSendCond != "" )
    select = select + " and " + PmSendCond;
    if( Index( PmSendCond, ":PaymentValueDateBegin" ) )
      params[params.size] = SQLParam( "PaymentValueDateBegin", g_TrnParm.BeginDate );
    end;
    if( Index( PmSendCond, ":PaymentValueDateEnd" ) )
      params[params.size] = SQLParam( "PaymentValueDateEnd", g_TrnParm.EndDate );
    end;

    if( Index( PmSendCond, ":BdTransfValueDateBegin" ) )
      params[params.size] = SQLParam( "BdTransfValueDateBegin", g_TrnParm.BeginDate );
    end;
    if( Index( PmSendCond, ":BdTransfValueDateEnd" ) )
      params[params.size] = SQLParam( "BdTransfValueDateEnd", g_TrnParm.EndDate );
    end;
  end;

  select = select + " ) t, dpmsend_dbt pmsendl " +
                    " where pmsendl.t_ID = t.t_ID ";
  select = select + IfThenElse( MaxPaymentPackage > 0, "and ROWNUM <= " + MaxPaymentPackage, ""); // Отбираем максимальное количество для формирования пакета
  select = select + " FOR UPDATE OF pmsendl.t_ID SKIP LOCKED "; // Сразу же лочим, что можно залочить

  var rs : RsdRecordset = execSQLselect( select, params, true );

  var systime = GetSysTime();
  var sysdate = date();   
  var i = 0;

  var Request = GMPPaymentGetAnswerRequestType(); // Создаём пакет для отправки в RS-Connect
  Request.RequestHeader = RequestHeaderType();
  Request.RequestHeader.ReqID = SubStr(CreateGUID(), 2, 36);
  Request.RequestHeader.SenderID = g_TrnParm.SenderID;
  Request.RequestData = GetAnswerRequestDataType();
  Request.RequestData.ObjectIDList = ObjectIDListType();
  Request.RequestData.ObjectIDList.Object = TArray();

  var PmSendIDs = TArray();                     

  while( rs and rs.moveNext() )
    Request.RequestData.ObjectIDList.Object[Request.RequestData.ObjectIDList.Object.size] = ObjectType();
    Request.RequestData.ObjectIDList.Object[Request.RequestData.ObjectIDList.Object.size - 1].ObjectID = rs.value("t_ExtObjectID");
    PmSendIDs[PmSendIDs.size] = rs.value("t_PmSendID"); // Нам нужно знать какие записи pmsend обновлять, если придет ошибка
  end;

  if( Request and (Request.RequestData.ObjectIDList.Object.size > 0) )
    var Response = callPaymentGetAnswer( Request, g_TrnParm.RS_Connect_URL );
    if( Response )
      stat = ProcessGGNSRResponse( Response, PmSendIDs );
    else
      RunError( "Из Rs-Connect не пришёл ответ" );
      stat = false;
    end;
  end;
  
  return stat;
  
onerror(x)
  if( x.Code == CtrlBrkErr )
    FlagCtrlBrk = true;
    CreateErrMsg( BNK_ERROR_MACROS_STR, x.Message );
  else  
    if(IsEqClass ("TRsbError", x.err) and (strlen(x.err.ToString()) > 0) )
      CreateErrMsg( BNK_ERROR_MACROS_STR, x.err.ToString() );
    else
      CreateErrMsg( BNK_ERROR_MACROS_STR, x.Message );
    end;
    AbortTrn();
  end;
end;

// Процедура запроса статуса извещения по платежу в RS-Connect

macro GGPmSendNotificationStatusRequest( ggcp, PmSendIDs, Department:string, Branch:string, BeginDate:date, EndDate:date, ReportFileName:string )


  const prmReportFileName = 6;

  execSQL( "delete from dggrep_tmp" );

  var stat = 0;
  var OK : bool = true,
      ErrorMsg : string = "";

  g_TrnParm = ProcessTrnParm( ggcp, PmSendIDs, null, null, null, null, Department, Branch, BeginDate, EndDate );
  
  OK = (getRSConnectUrl(@g_TrnParm.RS_Connect_Url) == 0 );

  if(OK)
    OK = (getSenderID(@g_TrnParm.SenderID) == 0 );
  end;

  if(not OK)
    ErrorMsg = GetErrMsg();
  end;  

  ClearLogGGPIPmSend();

  if( not ProcessTrn( null,  "GGPmSendNotificationStatusRequestTRN" ) ) 
    OK = false;
    ErrorMsg = GetErrMsg();
  end;
  
  // Формируем итоговый протокол
  if( OK )
    // Формирование итогового протокола
    var Report : TGGPmSendNotificationStatusRequestReport = TGGPmSendNotificationStatusRequestReport();
    var tmpReportFileName : string = "";
    tmpReportFileName = Report.GetReportFileName();
    var SwitchOutput : TSwitchOutputGisGmp = TSwitchOutputGisGmp( tmpReportFileName );
    Report.PrintReport();
    SetParm( prmReportFileName, tmpReportFileName );
  end;

  if( (not OK) and (ErrorMsg != "") )
    RunError( ErrorMsg, ErrorMsg );
  end;

  return IfThenElse( OK, 0, 1 );

OnError(er)
  ExeptionMessage(er); 
  return 1'
end;

