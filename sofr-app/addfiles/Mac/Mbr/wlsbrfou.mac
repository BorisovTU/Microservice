/****************************************************************************/
/*                   R-Style SoftWare Lab, RS-Bank 5.1                      */
/****************************************************************************/
/*                  Подсистема "Межбанковские расчеты"                      */
/*               Экспорт сообщений СМБР в формате СБРФ3                     */
/*                                                                          */
/*  Имя файла: swiftout.mac                                                 */
/*  Создан:  11.07.00                                            AAV        */
/****************************************************************************/

import "wlexport.mac", "wlsbrftl.mac", "sbblock.mac", cryptdlm;

var MessageStr;

const CONTEXTID_NEED_SIGN_SBRF3 = "ТранспортМБР|4|Формирование_транспортного_файла";

/*Процедура формирования строки выписки*начало****************/
const ЧислоПолей = 40, ЧислоБлоков = 6;
var Ar0B9 = TArray(2*ЧислоПолей);
Ar0B9( 0) = "PA";          Ar0B9( 1) = "Отправитель         ";
Ar0B9( 2) = "RC";          Ar0B9( 3) = SYMB_ENDL + "Получатель          ";
Ar0B9( 4) = "VT";          Ar0B9( 5) = SYMB_ENDL + "Тип выписки         ";
Ar0B9( 6) = "VCODE";       Ar0B9( 7) = SYMB_ENDL + "Код выписки         ";
Ar0B9( 8) = "VNUM";        Ar0B9( 9) = SYMB_ENDL + "Номер выписки       ";
Ar0B9(10) = "CU";          Ar0B9(11) = SYMB_ENDL + "Код валюты          ";
Ar0B9(12) = "DATEIN";      Ar0B9(13) = SYMB_ENDL + "За период           ";
Ar0B9(14) = "DATEOUT";     Ar0B9(15) = " ";
Ar0B9(16) = "PVB";         Ar0B9(17) = SYMB_ENDL + "Дата предыд.выписки ";
Ar0B9(18) = "VDATE";       Ar0B9(19) = SYMB_ENDL + "Отчет сформирован   ";
Ar0B9(20) = "VTIME";       Ar0B9(21) = " ";
Ar0B9(22) = "A\\ACC";      Ar0B9(23) = SYMB_ENDL + "Счет №              ";
Ar0B9(24) = "A\\INBL";     Ar0B9(25) = SYMB_ENDL + "Входящее сальдо                                                            ";
Ar0B9(26) = "A\\DOC\\DOC"; Ar0B9(27) = SYMB_ENDL + "№      Вид оп. Кл.№   Кл.дата    Корреспондир.счет    Счет получателя      Д/К              Сумма Платежный документ       Тип  Уч.-пол.   Дата проводки Примечание";
Ar0B9(28) = "A\\DAM";      Ar0B9(29) = SYMB_ENDL + "Операции по дебету                                                             ";
Ar0B9(30) = "A\\DNUM";     Ar0B9(31) = " ";
Ar0B9(32) = "A\\KAM";      Ar0B9(33) = SYMB_ENDL + "Операции по кредиту                                                            ";
Ar0B9(34) = "A\\KNUM";     Ar0B9(35) = Ar0B9(31);
Ar0B9(36) = "A\\OUTBL";    Ar0B9(37) = SYMB_ENDL + "Исходящее сальдо                                                           ";
Ar0B9(38) = "B\\ACC";      Ar0B9(39) = Ar0B9(23);
Ar0B9(40) = "B\\INBL";     Ar0B9(41) = Ar0B9(25);
Ar0B9(42) = "B\\DOC\\DOC"; Ar0B9(43) = Ar0B9(27);
Ar0B9(44) = "B\\DAM";      Ar0B9(45) = Ar0B9(29);
Ar0B9(46) = "B\\DNUM";     Ar0B9(47) = Ar0B9(31);
Ar0B9(48) = "B\\KAM";      Ar0B9(49) = Ar0B9(33);
Ar0B9(50) = "B\\KNUM";     Ar0B9(51) = Ar0B9(35);
Ar0B9(52) = "B\\OUTBL";    Ar0B9(53) = Ar0B9(37);
Ar0B9(54) = "C\\DOC\\DOC"; Ar0B9(55) = SYMB_ENDL + "№      Дата приема Время Кл.№   Кл.дата    Д/К              Сумма Платежный документ       Тип  Примечание";
Ar0B9(56) = "C\\DAM";      Ar0B9(57) = SYMB_ENDL + "Операции по дебету                             ";
Ar0B9(58) = "C\\DNUM";     Ar0B9(59) = Ar0B9(31);
Ar0B9(60) = "C\\KAM";      Ar0B9(61) = SYMB_ENDL + "Операции по кредиту                            ";
Ar0B9(62) = "C\\KNUM";     Ar0B9(63) = Ar0B9(35);
Ar0B9(64) = "D\\DOC\\DOC"; Ar0B9(65) = SYMB_ENDL + "№      Дата приема Время Кл.№   Кл.дата                 Сумма Платежный документ       Тип";                    
Ar0B9(66) = "D\\AM";       Ar0B9(67) = SYMB_ENDL + "Всего документов";
Ar0B9(68) = "D\\NUM";      Ar0B9(69) = Ar0B9(31);
Ar0B9(70) = "E\\DOC\\DOC"; Ar0B9(71) = SYMB_ENDL + "№      Дата приема Время Кл.№   Кл.дата                 Сумма Платежный документ";                  
Ar0B9(72) = "E\\AM";       Ar0B9(73) = Ar0B9(67);
Ar0B9(74) = "E\\NUM";      Ar0B9(75) = Ar0B9(69);
Ar0B9(76) = "F\\DOC\\DOC"; Ar0B9(77) = SYMB_ENDL + "№      Дата приема Время Информационный документ  Уч.-пол.   Тип";                                     ;
Ar0B9(78) = "F\\NUM";      Ar0B9(79) = Ar0B9(67);

/*Блоки*/
var Ar0B9Block = TArray(2*ЧислоБлоков);
Ar0B9Block( 0) = "A"; Ar0B9Block( 1) = SYMB_ENDL + SYMB_ENDL + "Раздел 1. Выписка по пассивному счету";
Ar0B9Block( 2) = "B"; Ar0B9Block( 3) = SYMB_ENDL + SYMB_ENDL + "Раздел 2. Выписка по активному счету";
Ar0B9Block( 4) = "C"; Ar0B9Block( 5) = SYMB_ENDL + SYMB_ENDL + "Раздел 3. Ожидающие проводки документы";
Ar0B9Block( 6) = "D"; Ar0B9Block( 7) = SYMB_ENDL + SYMB_ENDL + "Раздел 4. Не принятые к обработке документы";
Ar0B9Block( 8) = "E"; Ar0B9Block( 9) = SYMB_ENDL + SYMB_ENDL + "Раздел 5. Обработанные требования-поручения";
Ar0B9Block(10) = "F"; Ar0B9Block(11) = SYMB_ENDL + SYMB_ENDL + "Раздел 6. Обработанные сообщения участнику";                    

/*Для работы с двухмерными массивами*/
macro ind2(i, j)  return 2*i + j; end;

/*Агоритм основан на взаимотражении итератора списка MesVal (СчитатьПоле) и процедурных индексов
  i - индекса массива полей Ar0B9 и k - индекса массива разделов Ar0B9Block
  Определенная сложность состоит в том, что итерации индекса i не всегда следует выборка значения из 
  списка MesVal и наоборот, а индекс k служит для независимости вывода общей информации о блоке
  (например, названия блока) от присутствия в писке MesVal полей данного блока*/
macro СоздатьВыписку(): bool
   var i = 0, k = 0;
   var field = "", buff, block = "";
   var шапкаНапечатана, раздел, шапка, конецВыписки = false;
   
   /*Печатаем заголовок выписки*/
   СчитатьПоле( field, buff, block );
   while(block == "")
      if(field == Ar0B9(ind2(i, 0))) /*Поле может быть необязательным*/
         MessageStr = MessageStr + Ar0B9(ind2(i, 1)) + buff;
         /*обработали текущую - переходим на следующую запись*/
         конецВыписки = not СчитатьПоле( field, buff, block ); 
      end;
      i = i + 1;
      if(i>ЧислоПолей) return false end;
   end;
   
   field = block + "\\" + field; /*Так устроен алгоритм, см. массив Ar0B9*/

   /*Печатаем разделы выписки*/
   while(k < ЧислоБлоков)
      шапкаНапечатана = false;
      раздел = Ar0B9Block(ind2(k, 1)); /*название заголовка блока*/
        
      /*Если раздел есть*/
      if(Ar0B9Block(ind2(k, 0)) == SubStr( field, 1, 1 ))
         MessageStr = MessageStr + раздел;
         while((Ar0B9Block(ind2(k, 0)) == SubStr( field, 1, 1 )) and (not конецВыписки) )
            if(field == Ar0B9(ind2(i, 0))) /*Поле может отсутствовать*/
            /*Выводим поля с учетом формата:*/
            /*Мы попали в подраздел "\DOC"*/
               if(Index ( field, "\\DOC\\" ))
                  if(not шапкаНапечатана)
                     /*шапка, которая принадлежит повторяющемуся полю = таблице*/
                     шапка = Ar0B9(ind2(i, 1));  
                     MessageStr = MessageStr + шапка + SYMB_ENDL + buff;
                     шапкаНапечатана = true; 
                  else
                     MessageStr = MessageStr + SYMB_ENDL + buff;
                  end;
                  /*обработали текущую - переходим на следующую запись*/
                  конецВыписки = not СчитатьПоле( field, buff, block ); 
                  field = block + "\\" + field;
            /*Поправим формат сальдо*/
               elif(index(field, "INBL") or index(field, "OUTBL"))
                  MessageStr = MessageStr + Ar0B9(ind2(i, 1)) + SubStr(buff,1,1) + "  " + SubStr(buff,2);
                  i = i + 1;
                  /*обработали текущую - переходим на следующую запись*/
                  конецВыписки = not СчитатьПоле( field, buff, block ); 
                  field = block + "\\" + field;
            /*Все остальные случаи*/
               else
                  MessageStr = MessageStr + Ar0B9(ind2(i, 1)) + buff;
                  i = i + 1;
                  /*обработали текущую - переходим на следующую запись*/
                  конецВыписки = not СчитатьПоле( field, buff, block ); 
                  field = block + "\\" + field;
               end;
            else  /*Если поле отсутствует или мы сходим с поля "\DOC", продолжаем последовательный перебор массива Ar0B9*/
               /*Если отсутствующее поле - подраздел "\DOC" - надо напечатать шапку.
                 Если мы сходим с поля "\DOC" (шапкаНапечатана == true), ничего выводить не надо*/
               if( Index ( Ar0B9(ind2(i, 0)), "\\DOC\\" ) AND ( Not шапкаНапечатана ) ) 
                  шапка = Ar0B9(ind2(i, 1));  
                  MessageStr = MessageStr + шапка;
               end;
               i = i + 1;
            end;    
            if(i>ЧислоПолей) return false end;
         end;
      /*Если раздела нет*/
      else
         /*перематываем индекс i, чтобы перескочить полностью отсутствующий раздел (- гадкий случай)*/
         while( SubStr( field, 1, 1 ) != SubStr( Ar0B9(ind2(i, 0)), 1, 1 ) ) 
            i = i + 1;
            if(i>ЧислоПолей) return false end;
         end;  
      end;
      /*переходим к следующущему разделу*/
      k = k + 1;
   end;

   if(i != ЧислоПолей) /*Был сбой в построении строки выписки MessageStr*/
      return false;
   else 
      MessageStr = MessageStr + SYMB_ENDL;
      return true;
   end;
end;
/*Процедура формирования строки выписки*конец*****************/

/***************************************************************************/
/* Сформировать идентификатор сообщения                                    */
/***************************************************************************/
macro ЗаписатьИдентификатор()
  if( not DefineFormExport( wlmes.RlsFormID ) )
    return FALSE;
  end;
  
  if ( ФормаЭкспорт.Name == sign_0SA )
     MessageStr = String( ФормаЭкспорт.Name );
  elif(ФормаЭкспорт.Name == sign_0B6 )
     MessageStr = String( ФормаЭкспорт.Name, wlmes.RelatedRef );
  else
     MessageStr = String( ФормаЭкспорт.Name, wlmes.TRN );     
  end;

  return TRUE;
end;

/* Последовательно считываем и записываем поля сообщения */
macro ЗаписатьПоляСообщения( IsPIB )
  var field, buff, err;
  
  if(ФормаЭкспорт.Name != sign_0B9)  
  while( СчитатьПоле( field, buff ) )  
    if( ((IsPIB == true) OR (ФормаЭкспорт.Name==sign_0SA)) AND (field == SB_Tag_PIB) )
      MessageStr = MessageStr + buff;
    else
      MessageStr = MessageStr + MakeFieldSBRF3( field, buff, false, false );
    end;
  end;
  else  
    if(not СоздатьВыписку())
       ErrExport( "Ошибка формирования файла выписки 0B9" );
       return false;
    end;
  end;

  return true;
end;
                                           
/***************************************************************************/
/* Сформировать поля сообщения                                             */
/***************************************************************************/
macro ЗаписатьБлокЦелевойИнформации( IsPIB, SetSign )
  var StrForSign = "", Signature = "", CryptoAPI = RsCryptoAPI(), rsms;

  if( not ЗаписатьПоляСообщения(IsPIB) )
    return FALSE;
  end;

  /* Записываем ключ сообщения - только если есть настройка и сообщения по данной форме подписываются */
  if( (SetSign == TRUE) AND SB_FormNeedSing( ФормаЭкспорт.Name ) )
     /* Формирование блока данных */
     if( not FormingDataInit( wlmes, MessageStr, StrForSign ) )
        ErrExport( "Ошибка при формировании блока данных" );
        return false;
     end;

     /* Подписываем сообщение с использованием криптоплагина */
     rsms = RsbMessage( wlmes.MesID );
     rsms.PIB = StrForSign;
     if( not CryptoAPI.ExecCryptoAction( CONTEXTID_NEED_SIGN_SBRF3, rsms ))
       ErrExport( String("Ошибка при расчете ключа сообщения", +GetErrMsg()) );
       return false;
     end;
     
     /* В подписи определяем ключ */
     Signature = SubStr( CryptoAPI.GetLastSignature(), 1, SB_Tag_KeyField_len );
     if( Signature == "" )
       ErrExport( "Ошибка при расчете ключа сообщения" );
       return false;
     end;

     MessageStr = MessageStr + MakeFieldSBRF3( SB_Tag_KeyField, Signature, false, false );
  end;

  MessageStr = ToANSI(MessageStr, true);

  if ( ФормаЭкспорт.Name != sign_0SA )
     if( not ЗаписатьБлок( SB_Indention + MessageStr ) )
        ErrExport("Ошибка записи сообщения" );
        return false;
     end;

     if( ФормаЭкспорт.Name != sign_0B9 )
     /* Записываем конец сообщения */
     if( not ЗаписатьСтроку( string(SB_DelimiterS, SB_Tag_EndField, SB_DelimiterE) ) )
       ErrExport("Ошибка записи поля сообщения: " + SB_Tag_EndField);
       return false;
     end;
     end;
  else
     if( not ЗаписатьСтроку( SB_Indention + MessageStr ) )
        ErrExport("Ошибка записи сообщения" );
        return false;
     end;
  end;
  return TRUE;
end;

/***************************************************************************/
/*  Функция формирования сообщения в формате СБРФ3                         */
/*  Возвращает: TRUE или FALSE                                             */
/***************************************************************************/
macro ЗаписатьСообщение( IsPIB, SetSign )

  if( not ЗаписатьИдентификатор        () )               return false; end;
  if( not ЗаписатьБлокЦелевойИнформации(IsPIB, SetSign) ) return false; end;

  return TRUE;
end;

/***************************************************************************/
/* Функция формирования заголовка файла сообщения                          */
/***************************************************************************/
macro ЗаписатьЭтикетку()
  var error, СвойКодУчастника, КодУчастникаКорр;

  СвойКодУчастника = ПолучитьОткрытыйКодСубъекта( {OurBank}, PTCK_SBRF, error );
  if( error )
    ErrExport("не задан код абонента СБ РФ нашего банка");
    return FALSE;
  end;
 
  if ( (wlmes.OutsideAbonentCodeKind==PTCK_SBRF) AND (wlmes.OutsideAbonentCode!="") )
     КодУчастникаКорр = wlmes.OutsideAbonentCode;
     error = 0;
  else
     КодУчастникаКорр = ПолучитьОткрытыйКодСубъекта( wlmes.OutsideAbonentID, PTCK_SBRF, error );
  end;
  if( error )
    ErrExport( "не найден код абонента СБ РФ получателя" );
    return FALSE;
  end;
  if( not ЗаписатьСтроку( string(FileSBRF3Head, КодУчастникаКорр, СвойКодУчастника) ) );
    ErrExport( "не удалось записать этикетку сообщения" );
    return FALSE;
  end;

  return TRUE;
end;

/***************************************************************************/
/* Функция формирования кода конца файла сообщения                         */
/***************************************************************************/
macro ЗаписатьКонцовку()
  if( not ЗаписатьСтроку( FileSBRF3Foot ) )
    ErrExport( "Ошибка при записи конца сообщения" );
    return FALSE;
  end;

  return TRUE;
end;

/***************************************************************************/
/* Макрос экспорта сообщений СБРФ                                          */
/***************************************************************************/
macro SBRF3OutProcExec( ExportFileName, IsPIB )
  var continue0 = 1, Документов = 0, err, NeedSign = false, CryptoAPI = RsCryptoAPI();

  /* Определяем, есть ли сообщения, подлежащие выгрузке */
  if( not СчитатьЗапись( wlmes, err ) )
    if ( not err )
       std.msg("Не найдено ни одного сообщения для отправки");
    else
       std.msg("Ошибка чтения сообщения");
    end;
    return false;
  end;

  if( not ЗаписатьЭтикетку() )
    return FALSE;
  end;

  /* Считываем один раз настройку необходимости ключевания сообщений */
  if( ФормаЭкспорт.Name != sign_0B9 )
  NeedSign = CryptoAPI.IsCryptoActionNeeded( CONTEXTID_NEED_SIGN_SBRF3, 370 );
  end;

  /* Последовательно считываем сообщения и формируем файл экспорта */
  while( continue0 )
    if( not ЗаписатьСообщение(IsPIB, NeedSign) )
      return false;
    end;
    if( not СчитатьЗапись( wlmes, err, false ) )
      if ( not err )
         continue0 = 0;
      else
         ErrExport("Ошибка чтения сообщения");
         return false;
      end;
    end;
    Документов = Документов + 1;
    Message( "Идет выгрузка документов. Отправлено: ", Документов );
  end;

  if( not ЗаписатьКонцовку() )
    return false;
  end;

  return true;
end;

/***************************************************************************/
/* Макрос экспорта для релизов сообщений, хранящих тэги в отдельных полях  */
/***************************************************************************/
macro SBRF3OutProc( ExportFileName )
  return SBRF3OutProcExec( ExportFileName, false );
end;

/***************************************************************************/
/* Макрос экспорта для релизов сообщений, хранящих тэги в одном поле       */
/***************************************************************************/
macro SBRF3OutProcPIB( ExportFileName )
  return SBRF3OutProcExec( ExportFileName, true );
end;
