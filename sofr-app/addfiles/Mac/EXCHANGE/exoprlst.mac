/*
  -RSL---------------------------------------- R-Style Software Lab --
  =======================  Обменный пункт  ===========================
  -------------- Печать протокола операций дня(смены) ----------------

    Список операций Обменного пункта в порядке их совершения,
  расположенный по группам операций.

   Задается промежуток дат (по умолчанию - текущий день), для
 пользователей с любым статусом, кроме "Кассир" ("Операционист"),
 можно задать пользователя, по которому будет выпущен отчет или 
 0 - для всех. Для Кассира(Операциониста) отчет выпускается ТОЛЬКО
 по своим операциям.
   Группировка операций задана по образцу Мурманского СБ, но может
 быть изменена на любую произвольную в макросе FilterOnGroup.

   В протокол попадают все операции с состоянием "Завершена" и 
 "В реестре". Попадание других операций, например сторнированных,
 также можно настроить - макрос FilterOnOperState.
   Можно настроить обязательную печать каждой группы отчета, независимо 
 от того, есть ли по ней документы - переменная PrintNecessarily.

  14-19.06.2000 VS Создан
  18.10.2000 VS Создана группа для конверсии и проверки на подлинность.
*/
import ExchangeInter, BankInter, "define.mac";

const V_PROC = valtype( @AddZero ); /* !!! Ссылка на макрос;
                                           пока такой константы нет, используем первый же макрос из define.mac. */
const InsolventGroup      = -114, /* Мнимый код группы операций, введенный для Мурманска. */
      OtherOperationGroup = -115; /* Мнимый код группы для прочих операций% конверсия и проверка подлинности. */
const CASHIER = "К";   /* Доступ "Кассир" */
              /*  "О";   /* Для RS-Bank - "Операционист" */
                  ???    Выяснить, как на самом деле. */

file   oper        ( "operat.dbt",   "exchange.def" ) key 2;
/* структуры для доступа к полю ExtInfo структуры операции */
record avanceop    ( "avance.str"  , "exchange.def" );
record paydocop    ( "paydocop.str", "exchange.def" );
record incassop    ( "incasso.str" , "exchange.def" );
record retincassop ( "retincas.str", "exchange.def" );
record card        ( "card_opr.str", "exchange.def" );

var {curdate},
    DateStart,               /* Дата отчета, по умолчанию текущая. */
    exoper     = {exoper},   /* Операционист, операции по которому попадут в отчет. 0 - по всем. */
    Group,                   /* Здесь будет размещен класс для печати отчета. */
    RecFilter;               /* Здесь будет размещен класс для фильтров записей операций. */

/*-- Инструментальные функции ----------------------------------------------*/

/* Класс для макросов отчета и вспомогательных переменных при группировке операций. */
Class clGroup()
  var Current = 0,   /* Текущая группа операций */
      Counter = 0,   /* Счетчик количества операций в группе */
      Header,        /* Макросы: вывода шапки отчета для этой группы */
      PrintLine,     /*          печати одной строки                 */
      Footer;        /*          печати подвала                      */
  var PrintNecessarily = False;  /* Признак обязательной печати раздела,
                                    даже если в нем нет ни одной записи. */

  /* !!! сюда можно добавить дополнительные переменные для учета различных итогов по группе */
  var SumInRub = $0, /* Сумма по группе в рублях */
      SumInCur = $0, /* Сумма по группе в валюте */
      FormOut  = 0,   /* Всего продано бланков ПД          */
      PayDocSumOut = $0;  /* Общая сумма проданных бланков ПД  */

  /* Метод РЕинициализации класса. */
  macro Init()
    Header   = PrintLine = Footer = NULL;
    Counter  = 0;
    SumInRub = SumInCur = $0;
  end;

  /* Непосредственно инициализация. */
  Init();
end;

/* Класс для обслуживания произвольного набора функций-фильтров. Для
   этого они помещаются в массив, вызывается же всегда одна и та же 
   функция класса, возвращающая True, если прошли все фильтры и False
   при непрохождении первого же из них.
     Функции фильтров лучше задавать ссылками.
*/
Class clFilter( /* [fproc1], [fproc2], ...*/ )
  var arFilter = Tarray( 3, 1 ),  /* массив фильтров */
      parm, i = 1;

  /* Поиск в массиве функций-фильтров фильтра fproc. 
     Возвращает индекс или -1, если не найдено. */
  macro FindProc( fproc )
    var size = arFilter.size,
        k    = 0,
        find = -1;
    while( (k < size) and (find < 0) )
      if( arFilter(k) == fproc )
        find = k;
      end;
      k = k + 1;
    end;
    return find;
  end;

  /* Поиск в массиве функций пустого места. 
     Возвращает индекс или -1, если не найдено. */
  macro FindNull( fproc )
    var size = arFilter.size,
        k    = 0,
        find = -1;
    while( (k < size) and (find < 0) )
      if( valtype(arFilter(k)) == V_UNDEF )
        find = k;
      end;
      k = k + 1;
    end;
    return find;
  end;

  /* Добавить в массив функций-фильтров фильтр fproc. 
     Макрос можно задать именем или ссылкой, лучше - ссылкой. */
  macro Add( fproc )
    var n    = FindNull(),
        type = valtype( fproc );
    if( (type == V_PROC) or (type == V_STRING) )
      if( n >= 0 )
        arFilter( n ) = fproc;
      else
        arFilter( arFilter.size ) = fproc;
      end;
    else
      msgbox( "Попытка добавить неверную функцию фильтра: ", fproc );
    end;
  end;

  /* Удалить из массива указанный фильтр */
  macro Remove( fproc )
    var n = FindProc( fproc );
    if( n >= 0 )
      arFilter(n) = null;
    end;
  end;

  /* Фильтр, обслуживающий массив фильтров */
  macro Filter( arg )
    var k = 0, RetVal = True;

    while( (k < arFilter.size) and RetVal )
      if( valtype(arFilter(k)) != V_UNDEF )
        RetVal = ExecMacro2( arFilter(k), arg );
      end;
      k = k + 1;
    end;
    if( k == 0 ) return False; end;
    return RetVal;
  end;

  /* init class */
  while( getparm( i, parm ) )
    Add( parm );
    i = i + 1;
  end;
end;

/* Является ли параметр ссылкой на процедуру. Возвращает True/False. */
macro IsProcRef( procref )
  var type = valtype( procref );
  if(  (type == V_PROC) or
      ((type == V_STRING) and (procref != "")) )
    return True;
  end;
  return False;
end;
/*-- Конец инструмента -----------------------------------------------------*/

/*-- Вспомогательные функции -----------------------------------------------*/

/* Найти первую операцию за заданную дату. */
macro FindFirstOper( dat )
  ClearRecord( oper );
  oper.Date = dat;
  return getGE( oper );    
end;

/* Фильтр по дате операции. */
macro FilterOnDate()
  return oper.Date == DateStart;
end;

/* Фильтр на операции по сотруднику. */
macro FilterOnEmp()
  return oper.Emp_Ref == exoper;
end;

/* Фильтр по состоянию операции. */
macro FilterOnOperState()
  var State_Ref = oper.State_Ref;
  return ((State_Ref == CDF_OperCompleted) or /* Завершена   */
          (State_Ref == CDF_OperInReestr ));  /* В реестре   */
end;

/* Ключевой фильтр отбора записей. 
   !!! При необходимости может быть расширен с помощью замены макроса
       на набор макросов класса clFilter. */
macro KeyFilter()
  return FilterOnDate();
end;

/* Фильтр на группы операций. Определяет отношение операций к определенным группам. 
   !!! При желании сделать свою группировку, отличную от стандартной, необходимо 
       откорректировать этот макрос и головной, вызывающий сканирование по группам. 
*/
macro FilterOnGroup( Group )
  var RetVal = False,
      Code   = oper.Oper_Ref;

  if  ( Group == CDF_OperCurrChange )  /* Операции обмена валюты */
    if( /*(Code == CDF_OperUnpayCurrBuy  ) or*/   /* Покупка неплатежеспособной валюты за рубли */
        (Code == CDF_OperCurrBuy       ) or   /* Покупка платежеспособной валюты за рубли */
        (Code == CDF_OperCurrSale      ) /*or*/   /* Продажа платежеспособной валюты за рубли */
      )
      RetVal = True;
    end;
  elif( Group == CDF_OperPayDoc )     /* Операции покупки/продажи платежных документов */
    if( (Code == CDF_OperPayDocBuy     ) or   /* Покупка платежного документа за рубли  */
        (Code == CDF_OperPayDocSale    ) or   /* Продажа платежного документа за рубли  */
        (Code == CDF_OperPayDocBuyCurr ) or   /* Покупка платежного документа за валюту */
        (Code == CDF_OperPayDocSaleCurr)      /* Продажа платежного документа за валюту */
      )
      RetVal = True;
    end;
  /* !!! Special for Murmansk */
  elif( Group == InsolventGroup ) /* Операции по неплатежеспособным купюрам */
    if( (Code == CDF_OperUnpayCurrBuy  ) or   /* Покупка неплатежеспособной валюты за рубли */
        (Code == CDF_OperChange      )        /* Замена неплатежеспособной валюты */
      )
      RetVal = True;
    end;
/* для Мурманска выкинем
  elif( Group == CDF_OperSplitChange ) /* Операции размена или замены */
    if( (Code == CDF_OperSplit       ) or     /* Размен валюты */
        (Code == CDF_OperChange      )        /* Замена неплатежеспособной валюты */
      )
      RetVal = True;
    end;
*/
  elif( Group == CDF_OperTreasure )    /* Операции передачи ценностей */
    if( /*(Code == CDF_OperTransfer) or */        /* Передача ценности между кассирами */
        (Code == CDF_OperAvance  ) or         /* Получение аванса */
        (Code == CDF_OperCashOut )            /* Сдача кассы */
     /* Выравнивание пока не включаем
     CDF_OperEvenRests           /* Выравнивание остатков с Кассой Retail */
     */
      )
      RetVal = True;
    end;
  elif( Group == CDF_OperIncassoExpert ) /* Операции приема на инкассо или экспертизу */
    if( (Code == CDF_OperIncasso            ) or  /* Прием на инкассо        */
        (Code == CDF_OperExpert             ) or  /* Прием на экспертизу     */
        (Code == CDF_OperReturnIncasso      ) or  /* Возврат с инкассо       */
        (Code == CDF_OperReturnExpert       ) or  /* Возврат с экспертизы    */
        (Code == CDF_OperPayDocIncasso      ) or  /* Прием ПД на инкассо     */
        (Code == CDF_OperPayDocExpert       ) or  /* Прием ПД на экспертизу  */
        (Code == CDF_OperPayDocReturnIncasso) or  /* Возврат ПД с инкассо    */
        (Code == CDF_OperPayDocReturnExpert )     /* Возврат ПД с экспертизы */
      )
      RetVal = True;
    end;
  elif( Group == CDF_OperCard        ) /* Операции по картам */
    if( (Code == CDF_OperCardTake ) or        /* Начисление на карту */
        (Code == CDF_OperCardGive )           /* Снятие с карты      */
      )
      RetVal = True;
    end;
  elif( Group == OtherOperationGroup ) /* Операции по картам */
    if( (Code == CDF_OperCheck              ) or  /* Проверка на подлинность */
        (Code == CDF_OperCurrConversion     )     /* Конверсия */
      )
      RetVal = True;
    end;
  end;

  return RetVal;
end;

/* Сканирование операций данной группы и вызов макросов Группы. */
macro ScanGroupOperations
( 
   OperationGroup, /* Код группы операций. Принадлежность группе определяется FilterOnGroup */
   Header,         /* Макросы: вывода шапки отчета для этой группы */
   PrintLine,      /*          печати одной строки                 */
   Footer          /*          печати подвала                      */
)
  var Loop  = True,
      First = True;

  if( not FindFirstOper( DateStart ) ) return False; end;

  /* Если уже была группа ДО этой или если нужно всегда, напечатаем по ней подвал. */
  if( Group.Current and (Group.Counter or Group.PrintNecessarily) )
    if( IsProcRef( Group.Footer ) )
      ExecMacro2( Group.Footer, Group.Current );
    end;
  end;

  /* переинициализация класса */
  Group.Init();
  /* Установим новую текущую группу операций. */
  Group.Current   = OperationGroup;
  Group.Header    = Header;
  Group.PrintLine = PrintLine;
  Group.Footer    = Footer;

  /* Печать шапки, если она нужна в любом случае. */
  if( Group.PrintNecessarily and IsProcRef( Header ) )
    ExecMacro2( Header, OperationGroup );
  end;

  while( KeyFilter() and Loop )
/*[-попали в запись ID= ###########](oper.ID);*/
    if( RecFilter.Filter( OperationGroup ) )
      /* Для первой записи в группе проверим шапку. */
      if( First )
        /* Если задан макрос шапки, напечатаем шапку. */
        if( IsProcRef( Header ) and not Group.PrintNecessarily )
          ExecMacro2( Header, OperationGroup );
        end;
        First = False;
      end;

      /* Вызовем макрос для печати одной строки этой группы. */
      Group.Counter = Group.Counter + 1;
      if( IsProcRef( PrintLine ) ) ExecMacro2( PrintLine ); end;

    end; /* on filter */
    Loop = next( oper );
  end;

  return True;
end;

/* Вытащить ФИО из записи операции */
macro GetFIOfromOper()   /* заимствовано из f0406007.mac */
  var str = Oper.DocInfo,
      nn = strbrk( str, "." );
  while( nn != 0 )
    str = substr( str, 1, nn-1 ) + substr( str, nn+1) ;
    nn  = strbrk( str, "." );
  end;
  return str;
end;

/* Информация о документе, удостоверяющем личность клиента. */
macro MakeClientDocInfo()
  var FullInfo = "";
  FullInfo = GetNameCodif( Oper.Type_Ref, CDF_PersonDoc ) + " " +
             Oper.DocSeria + " " + Oper.DocNumb;
  /*if( Oper.DocInfo ) FullInfo = FullInfo + ", "+ Oper.DocInfo; end;*/
  return FullInfo;
end;

/* Доступ сотрудника. Возвращает буквенное обозначение доступа (см.typeac.dbt), 
   соответствующее коду операциониста, заданному в параметре, а при отсутствии 
   параметра -- текущего операциониста. 
*/
macro Access( /*[Code]*/ )
  file pers ( "person.dbt", "bank.def" );  /* Совместимо и с Retail. */
  var Code;
  if( not getparm( 0, Code ) ) Code = {exoper}; end;
  pers.Oper = Code;
  if( getEQ( pers ) ) return pers.cTypePerson; end;
  return "";
end;

/*-- Конец вспомогательных -------------------------------------------------*/

/*== Функции для отчета ====================================================*/
/* Функции-шаблоны для новых групп опраций. */
macro Header()
[
     Печать шапки группы ####]( Group.Current );
end;
macro PrintLine() 
[ Печать строки группы ###]( Group.Current );
end;
macro Footer()
[ Печать подвала группы ### 
  всего записей - ###
]( Group.Current, Group.Counter );
end;


macro HeaderAvance()
[  По инкассации ];
[┌───┬────────────────────────────────────────┬───┬─────────────────┬──────────────┬────────┬──────┐];
[│ N │       Содержание операции              │Код│  Сумма рублевой │  Сумма вал.  │ Время  │ Код  │];
[│   │                                        │вал│    операции     │   операции   │операции│польз.│];
[├───┼────────────────────────────────────────┼───┼─────────────────┼──────────────┼────────┼──────┤];
end;
macro PrintLineAvance()
  var Code    = oper.Oper_Ref,
      OperationName = GetNameCodif( Code, CDF_Oper ),
      TrsCode = oper.IncomeTrs_Ref,   /* По умолчанию - валюта прихода */
      CodeCur = oper.IncomeCurr_Ref,  
      SumRub  = oper.IncomeAmount,
      SumCur  = $0;

  if( Code == CDF_OperAvance )         /* Получение аванса */
    ;
  else /* (Code == CDF_OperCashOut ) */     /* Сдача кассы */
    TrsCode = oper.OutTrs_Ref;
    CodeCur = oper.OutCurr_Ref;
    SumRub  = oper.OutAmount;
  end;

  SetRecordAddr( avanceop, oper, 0, FldOffset( oper, "ExtInfo" ), True );

  if( (oper.IncomeCurr_Ref == ANY_CURR) and  /* Операция со справками */
      (oper.OutCurr_Ref    == ANY_CURR) 
    )
    if( avanceop.SprAmountIn )
      OperationName = OperationName + " справок ф.0406007";
    elif( avanceop.Spr31AmountIn )
      OperationName = OperationName + " справок ф.31";
    end;
    CodeCur = "";

  elif( (TrsCode != TrsCash) and (TrsCode != TrsMonet) )
    SumCur = SumRub;
    SumRub = $0;
    if  ( TrsCode == TrsValForm     ) OperationName = OperationName + " ценных бланков";
    elif( TrsCode == TrsCheck       ) OperationName = OperationName + " чеков";
    elif( TrsCode == TrsAccreditive ) OperationName = OperationName + " аккредитивов";
    end;

  elif( CodeCur == {NationalCur} )  /* Операция с нац.валютой. */
    CodeCur = "";   /* !!! Код рублей они почему-то не любят. */
    OperationName = OperationName + " наличных рублей";

  else                              /* Операция с валютой */
    SumCur = SumRub;
    SumRub = $0;
    OperationName = OperationName + " наличной валюты";  
  end;

[│###│########################################│###│#################│##############│########│ #### │]
( Group.Counter, OperationName, CodeCur, SumRub, SumCur, oper.Time, oper.Emp_Ref );
end;
macro FooterAvance()
[└───┴────────────────────────────────────────┴───┴─────────────────┴──────────────┴────────┴──────┘];
[                     Всего операций: #### ]( Group.Counter );
end;


macro HeaderBuySale()
[                            ];
[  По покупке/продаже валюты ];
[┌───┬────────┬────┬────────────────┬──────────────────┬───────────────┬─────────────────────┬────────┬──────┐];
[│ N │Операция│Код │  Сумма валюты  │   Сумма рублей   │ Комисс. сбор  │  Ф.И.О. клиента     │ Время  │ Код  │];
[│   │        │вал.│                │                  │ Сумма    │вал.│                     │операции│польз.│];
[├───┼────────┼────┼────────────────┼──────────────────┼──────────┼────┼─────────────────────┼────────┼──────┤];
end;                                                                                                        
macro PrintLineBuySale() 
  var Code          = oper.Oper_Ref,
      OperationName = "Покупка",
      CodeCur       = oper.IncomeCurr_Ref,  /* По умолчанию - валюта прихода */
      SumCur        = oper.IncomeAmount,
      SumRub        = oper.OutAmount,
      ComissCur     = "руб";

  if( Code == CDF_OperCurrBuy )    /* Покупка платежеспособной валюты за рубли */
    ;
  else /* (Code == CDF_OperCurrSale ) */  /* Продажа платежеспособной валюты за рубли */
    OperationName = "Продажа";
    CodeCur = oper.OutCurr_Ref;
    SumCur  = oper.OutAmount;
    SumRub  = oper.IncomeAmount;
  end;

  if( oper.ComCurr_Ref != {NationalCur} ) ComissCur = "вал"; end;

[│###│########│### │################│##################│##########│### │ ####################│########│ #### │]
( Group.Counter, OperationName, CodeCur, SumCur, SumRub, oper.ComAmount, ComissCur, GetFIOfromOper(), oper.Time, oper.Emp_Ref );
end;
macro FooterBuySale()
[└───┴────────┴────┴────────────────┴──────────────────┴──────────┴────┴─────────────────────┴────────┴──────┘];
[                     Всего операций: #### ]( Group.Counter );
end;


macro HeaderInsolvent()
[                                  ];
[   По неплатежеспособным купюрам  ];
[┌───┬─────┬──────────┬────────────────┬────────────┬─────────────────────┬────────┬──────┐];
[│ N │ Код │Сумма вал.│       Купюра   │     В чем  │     Ф.И.О. клиента  │ Время  │ Код  │];
[│   │вал. │          │   Номер  │Серия│  выплата   │                     │операции│польз.│];
[├───┼─────┼──────────┼──────────┼─────┼────────────┼─────────────────────┼────────┼──────┤];
end;
macro PrintLineInsolvent() 
  var Code     = oper.Oper_Ref,
      OutSumIn = "Все в рублях",
      CodeCur  = oper.IncomeCurr_Ref,  /* Тут всегда валюта прихода */
      SumCur   = oper.IncomeAmount,
/* !!! Это пока неоткуда брать */
      Seria    = "",
      Number   = "";

    if( Code == CDF_OperUnpayCurrBuy )  /* Покупка неплатежеспособной валюты за рубли */
      ;
    else /* ( Code == CDF_OperChange ) */       /* Замена неплатежеспособной валюты */
      OutSumIn = "Все в валюте";
    end;

/* !!! Пока не сделаны серии-номера */
/*    if( not GetNomialInfo() )
      ClearRecord( trsattr );
    end;
*/
[│###│ ### │##########│##########│ ### │############│ ####################│########│ #### │]
( Group.Counter, CodeCur, SumCur, "", "", OutSumIn, GetFIOfromOper(), oper.Time, oper.Emp_Ref );
end;
macro FooterInsolvent()
[└───┴─────┴──────────┴──────────┴─────┴────────────┴─────────────────────┴────────┴──────┘];
[                     Всего операций: #### ]( Group.Counter );
end;


macro HeaderPayDocs()
[                            ];
[   По платежным документам  ];
[┌───┬──────────────────────┬───┬────────┬──────────────────────────────────┬───────────────────────────┬────────┬──────┐];
[│   │                      │Код│        │    Характеристики пачки ПД       │         Клиент            │ Время  │ Код  │];
[│ N │ Наименование операции│вал│  Курс  ├────────┬────────┬─────┬──────────┼───────────────────────────┤        │      │];
[│   │                      │   │        │ N 1-го │  Цена  │ Кол.│ Стоимость│Резидент, Ф.И.О., документ │операции│польз.│];
[├───┼──────────────────────┼───┼────────┼────────┼────────┼─────┼──────────┼───────────────────────────┼────────┼──────┤];
end;
macro PrintLinePayDocs() 
  file trsattr ( "trsattr.dbt", "exchange.def"  ) key 1; /* Для состава номиналов */
  var Code       = oper.Oper_Ref,
      CodeCur    = oper.OutCurr_Ref,  /* По умолчанию - валюта расхода */
      OperationName = "",
      Amount     = 0,    /* Количество бланков ПД */
      OperSum    = oper.IncomeAmount,   /* Сумма операции        */
      IsTrsAttr  = False,/* Есть ли разбивка по номиналам   */ 
      NominalSum = $0,   /* Сумма всех номиналов ПД         */
      NominalStr = "",   /* Строка номиналов  */
      QuantStr   = "",   /* Строка количеств  */
      FirstPDnum = "",   /* № 1-го документа в пачке ПД     */
      ClientInfo = "",   /* Информация о клиенте            */
      FormOut    = "";   /* Количество проданных бланков ПД */

  macro GetPayDocName( ID )
    file paydoc ( "paydoc.dbt", "exchange.def" );
    paydoc.ID = ID;
    if( getEQ( paydoc ) )
      return paydoc.Name;
    end;
    return "";
  end;
  macro GetNomialInfo()
    trsattr.Oper_Ref  = oper.ID;
    trsattr.State_Ref = 0;
    IsTrsAttr = ( getGE( trsattr ) and (trsattr.Oper_Ref == oper.ID) );
    return IsTrsAttr;
  end;
  /* Вызывается после GetNomialInfo() */
  macro GetNominalSum()
    var Sum  = $0;

    if( IsTrsAttr )      
      Sum        = Sum + trsattr.Quantum * trsattr.Nominal;
      /* Соберем дополнительные данные */
      FirstPDnum = trsattr.Seria + " " + trsattr.Numb; 
      NominalStr = string( trsattr.Nominal );
      QuantStr   = string( trsattr.Quantum );
      while( next( trsattr ) and (trsattr.Oper_Ref == oper.ID) )
        Sum = Sum + trsattr.Quantum * trsattr.Nominal;
        /* Еще в дополнительные */
        FirstPDnum = FirstPDnum + "\n" + trsattr.Seria + " " + trsattr.Numb;
        NominalStr = NominalStr + "\n" + string( trsattr.Nominal );
        QuantStr   = QuantStr   + "\n" + string( trsattr.Quantum );
      end;
    end;
    return Sum;
  end;

  SetRecordAddr( paydocop, oper, 0, FldOffset( oper, "ExtInfo" ), True );
  OperationName = GetNameCodif( Code, CDF_Oper ) + "\n" +
                  GetPayDocName( paydocop.PayDoc_Ref );
  Amount        = paydocop.Amount;
  ClientInfo    = GetFIOfromOper() + "\n" + MakeClientDocInfo();

  if( GetNomialInfo() )
    FirstPDnum = trsattr.Seria + " " + trsattr.Numb;
    NominalSum = GetNominalSum();
  end;

  if( (Code == CDF_OperPayDocBuy     ) or   /* Покупка платежного документа за рубли  */
      (Code == CDF_OperPayDocBuyCurr )      /* Покупка платежного документа за валюту */
    )
    CodeCur = oper.IncomeCurr_Ref;
  end;

  if( (Code == CDF_OperPayDocSale    ) or   /* Продажа платежного документа за рубли  */
      (Code == CDF_OperPayDocSaleCurr)      /* Продажа платежного документа за валюту */
    )
    FormOut = Amount;
    OperSum = oper.OutAmount;
    Group.FormOut      = Group.FormOut + FormOut; 
    Group.PayDocSumOut = Group.PayDocSumOut + NominalSum; 
  end;

[│###│ #####################│###│########│########│########│#####│##########│# #########################│########│ #### │]
( Group.Counter, OperationName:w, CodeCur, oper.Kurs:4, FirstPDnum:w, NominalStr:w:r, QuantStr:w:r, OperSum, oper.Resident, ClientInfo:w, oper.Time, oper.Emp_Ref );
end;
macro FooterPayDocs()
[└───┴──────────────────────┴───┴────────┴────────┴────────┴─────┴──────────┴───────────────────────────┴────────┴──────┘];
[               Продано чеков на общую сумму: #######      ]( int(double(Group.PayDocSumOut/100)) );
[                        Всего бланков чеков:    #### шт.  ]( Group.FormOut );     
end;


macro HeaderCard()
[                          ];
[   По пластиковым картам  ];                                                                        
[┌───┬────────────────────┬────────────────────────┬─────────────────────────────────┬────────┬──────┐];
[│   │                    │       Карта            │          Операция               │ Время  │ Код  │];
[│ N │     Операция       ├────────────────────┬───┼────────────┬───┬────────────┬───┤операции│польз.│];
[│   │                    │   эмитент/номер    │вал│   Сумма    │вал│  Комиссия  │вал│        │      │];
[├───┼────────────────────┼────────────────────┼───┼────────────┼───┼────────────┼───┼────────┼──────┤];
end;
macro PrintLineCard() 
  var Code     = oper.Oper_Ref,
      OperationName = "Начисление на карту",  /* по умолчанию */
      CodeCur  = oper.IncomeCurr_Ref, /* по умолчанию - приход */
      OperSum  = oper.IncomeAmount;

  SetRecordAddr( card, oper, 0, FldOffset( oper, "ExtInfo" ), True );

  if( Code == CDF_OperCardTake )        /* Начисление на карту */
    ;
  else /* ( Code == CDF_OperCardGive ) */       /* Снятие с карты      */
    OperationName = "Снятие с карты";
    CodeCur = oper.OutCurr_Ref;
    OperSum = oper.OutAmount;
  end;
[│###│####################│####################│###│############│###│############│###│########│ #### │
│   │                    │####################│   │            │   │            │   │        │      │]
( Group.Counter, OperationName, card.IssuerName, card.Curr_Ref, OperSum, CodeCur, oper.ComAmount, oper.ComCurr_Ref, oper.Time, oper.Emp_Ref,
                 card.CardNumb );
end;
macro FooterCard()
[└───┴────────────────────┴────────────────────┴───┴────────────┴───┴────────────┴───┴────────┴──────┘];
[                     Всего операций: #### ]( Group.Counter );
end;


macro HeaderIncasso()
[                        ];
[   По операциям инкассо ];
[┌───┬─────────────────────────┬─────────────────────────────────────────────────────────────┬────────────┬────────┬──────┐];
[│   │                         │                       Ценность                              │            │ Время  │ Код  │];
[│ N │  Содержание операции    ├──────────────────────────────┬───┬─────┬────────────────────┤   Сумма    │операции│      │];
[│   │                         │    Наименование              │Вал│Серия│    Номер           │            │        │польз.│];
[├───┼─────────────────────────┼──────────────────────────────┼───┼─────┼────────────────────┼────────────┼────────┼──────┤];
end;
macro PrintLineIncasso() 
  var Code          = oper.Oper_Ref,
      OperationName = GetNameCodif( Code, CDF_Oper ),
      TreasureName  = "",
      TrsCode       = 0,
      FlagPD        = 0, /* Флаг операции с платежным докумектом */
      CodeCur       = 0,
      Seria         = "",
      Number        = "",
      OperSum       = $0;

  if( (Code == CDF_OperIncasso            ) or  /* Прием на инкассо        */
      (Code == CDF_OperExpert             ) or  /* Прием на экспертизу     */
      (Code == CDF_OperPayDocIncasso      ) or  /* Прием ПД на инкассо     */
      (Code == CDF_OperPayDocExpert       )     /* Прием ПД на экспертизу  */
    )
    SetRecordAddr( incassop, oper, 0, FldOffset( oper, "ExtInfo" ), True );
    TreasureName  = incassop.TrsName;
    CodeCur       = incassop.Curr_Ref;
    Seria         = incassop.Seria;
    Number        = incassop.Numb;
    OperSum       = oper.IncomeAmount;

  elif(((Code == CDF_OperReturnIncasso      ) or  /* Возврат с инкассо       */
        (Code == CDF_OperReturnExpert       ))    /* Возврат с экспертизы    */
         or
       ((Code == CDF_OperPayDocReturnIncasso) or  /* Возврат ПД с инкассо    */
        (Code == CDF_OperPayDocReturnExpert ) and /* Возврат ПД с экспертизы */
        (FlagPD = True))
    )
    SetRecordAddr( retincassop, oper, 0, FldOffset( oper, "ExtInfo" ), True );
    TrsCode       = retincassop.PayDoc_Ref;
    CodeCur       = oper.OutCurr_Ref;
    /* ??? Можно попробовать искать квитанцию по приему на инкассо и брать реквизиты из нее */
/*    Seria         = .Seria;
    Number        = .Numb;
*/
    OperSum       = oper.OutAmount;
    if( FlagPD )
      TreasureName = GetNamePayDoc( TrsCode );
    else
      TreasureName = GetNameCurr( oper.OutCurr_Ref );
    end;

  end;

[│###│#########################│##############################│###│#####│####################│############│########│ #### │]
( Group.Counter, OperationName, TreasureName, CodeCur, Seria, Number, OperSum, oper.Time, oper.Emp_Ref );
end;
macro FooterIncasso()
[└───┴─────────────────────────┴──────────────────────────────┴───┴─────┴────────────────────┴────────────┴────────┴──────┘];
[                     Всего операций: #### ]( Group.Counter );
end;


macro HeaderOther()
[                    ];
[   Прочие операции  ];                                                                        
[┌───┬────────────────────┬────────────────┬────────────────┬────────┬──────┐];
[│   │                    │     Приход     │     Расход     │ Время  │ Код  │];
[│ N │     Операция       ├────────────┬───┼────────────┬───┤операции│польз.│];
[│   │                    │   Сумма    │вал│   Сумма    │вал│        │      │];
[├───┼────────────────────┼────────────┼───┼────────────┼───┼────────┼──────┤];
end;
macro PrintLineOther() 
  var Code          = oper.Oper_Ref,
      OperationName = GetNameCodif( Code, CDF_Oper ),
      IncomeSum     = oper.IncomeAmount,
      IncomeCur     = oper.IncomeCurr_Ref,
      OutSum        = oper.OutAmount,
      OutCur        = oper.OutCurr_Ref;

  if  ( Code == CDF_OperCurrConversion )    /* Конверсия */
    ; 
  elif( Code == CDF_OperCheck          )    /* Проверка на подлинность */
    ;
  end;

[│###│####################│############│###│############│###│########│ #### │]
( Group.Counter, OperationName, IncomeSum, IncomeCur, OutSum, OutCur, oper.Time, oper.Emp_Ref );
end;
macro FooterOther()
[└───┴────────────────────┴────────────┴───┴────────────┴───┴────────┴──────┘];
[                     Всего операций: #### ]( Group.Counter );
end;
/*== Конец функций отчета ==================================================*/

/* Задать параметры отчета. */
macro GetReportParms()
  var RetVal = False;
  DateStart = date()/*{curdate} по вкусу*/;

  if( getdate( DateStart, "Введите дату начала смены:" ) )
/* !!!??? */  
    if( Access != CASHIER ) 
      if( getint( exoper, "Введите № операциониста, 0 - все:", 4 ) )
        if( exoper < 0 )
          exoper = {exoper};
          msgbox( "Код операциониста не может быть отрицательным!|" + 
                         "Назначен операционист ", exoper );
        end;
        RetVal = True;
      end;  
    else
      exoper = {exoper};
      RetVal = True;
    end;
  end;
  return RetVal;
end;

/****************************************************************************
                            ГОЛОВНАЯ ПРОГРАММА
*****************************************************************************/

if( GetReportParms() )
  if( FindFirstOper( DateStart ) )

    Group     = clGroup();
    RecFilter = clFilter( @FilterOnGroup, @FilterOnOperState );
/*    Group.PrintNecessarily = True; /* !!! Удобно для отладки */
*/
    /* Для конкретного сотрудника добавим фильтр по сотруднику. */
    if( exoper ) 
      RecFilter.Add( @FilterOnEmp );
    end;

    /* Здесь, если надо, печать общей шапки отчета. */
[                        ПРОТОКОЛ ПРОВЕДЕННЫХ ОПЕРАЦИЙ (Дата: ##########)  ](DateStart);
[                      ====================================================                 
   ];
    
    /* Последовательное сканирование операций за заданную дату и вывод информации
       в отчет с группировкой операций.
       Группировка в последовательности Мурманского СБ РФ. 
    */                                           
             /* Операции передачи ценностей */
    ScanGroupOperations( CDF_OperTreasure     , @HeaderAvance,    @PrintLineAvance,    @FooterAvance );
             /* Операции обмена валюты */
    ScanGroupOperations( CDF_OperCurrChange   , @HeaderBuySale,   @PrintLineBuySale,   @FooterBuySale );
             /* Операции по неплатежеспособным купюрам */
    ScanGroupOperations( InsolventGroup       , @HeaderInsolvent, @PrintLineInsolvent, @FooterInsolvent );
             /* Операции размена или замены */
 /*   ScanGroupOperations( CDF_OperSplitChange  , @Header,          @PrintLine,          @Footer );*/
             /* Операции покупки/продажи платежных документов */
    ScanGroupOperations( CDF_OperPayDoc       , @HeaderPayDocs,   @PrintLinePayDocs,   @FooterPayDocs );
             /* Операции приема на инкассо или экспертизу */
    ScanGroupOperations( CDF_OperIncassoExpert, @HeaderIncasso,   @PrintLineIncasso,   @FooterIncasso );
             /* Операции по картам */
    ScanGroupOperations( CDF_OperCard         , @HeaderCard,      @PrintLineCard,      @FooterCard );
             /* Прочие операции: конверсия и проверка подлинности */
    ScanGroupOperations( OtherOperationGroup  , @HeaderOther,     @PrintLineOther,     @FooterOther );

    /* Печать подвала для последней группы. */
    if( Group.Current and (Group.Counter or Group.PrintNecessarily) )
      if( IsProcRef( Group.Footer ) )
        ExecMacro2( Group.Footer, Group.Current );
      end;
    end;

    /* Здесь, если надо, печать подвала отчета. */

  else 
    msgbox( "За дату ", DateStart, " не найдено ни одной операции!" );
  end;
else msgbox("False");
end;
