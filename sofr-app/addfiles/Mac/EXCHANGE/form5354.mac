/*
                       Обменный пункт

    Печать ордеров ф.53,54,63 на операцию в две колонки.

  Две колонки занимают 100 символов. Макрос может вызываться независимо.

  20-29.06.2000 VS Создан
*/
import ExchangeInter, BankInter, "define.mac";
import "rstrfunc.mac";

/* Глобальные переменные. Можно потом убрать в структуру. */
var OperIncomeAmount,  /* "Очищенные" от комиссий суммы  */
    OperOutAmount;     /*  прихода и расхода по операции */

var OperCode,      /* Тип обрабатываемой операции         */
    OrderTurnType, /* Тип обрабатываемого оборота         */
    OrderForm,     /* № формы ордера по этому обороту     */
    OrderDate,     /* Дата ордера      */
    OrderCur,      /* Валюта ордера    */
    OrderSum,      /* Сумма ордера     */
    OrderCurStr,   /* Строковое представление кода валюты */
    OrderSumStr,   /* Строковое представление суммы       */
    OrderGround,   /* Основание ордера */
        /* !!! Данные для второй колонки. Бывают НЕ ВСЕГДА */
    OrderSum2,     /* Сумма во второй колонке ордера.                           */
    OrderCurStr2,  /* Строковое представление для кода валюты во второй колонке */

    OrderRateDiff, /* Флаг выпуска ордера на сумму по разнице курсов */
    GrComis1,      /* Промежуточная для подготовки основания по комиссии. */
    GrRateDiff1;     /* промежуточная для подготовки основания по разнице курсов. */

var {Post_Addr};

macro mod( arg1, arg2 )         /* Остаток от деления arg1 на arg2 */
  return arg1 - (arg1/arg2)*arg2;
end;

/*========================================================================*/
/*== Менеджер вывода отчетов в несколько колонок =========================*/
/*========================================================================*/
var NCOLUMNS    = 2,       /* !!! Число колонок отчетов. */
    ColumnTotal = 0,       /* Всего отчетов(колонок) для вывода */
    ColumnCount = 0,       /* Порядковый номер отчета(колонки) */
    CurColumn   = 0,       /* № текущей колонки */
    FlushFlag   = False;   /* Флаг насильного вывода буфера колонок.
                              Используется для окончания печати. */

macro nextcolumn( n )           /* Номер следующей колонки для n-й по порядку формы. */
  var rest = mod( n, NCOLUMNS );
  if( rest == 0 ) rest = NCOLUMNS; end;
  return rest;
/*  return mod( n+1, 2 ) + 1; /* подходит только для NCOLUMNS = 2 */
*/
end;

/* Установить количество документов, выводимых в данной порции. */
macro SetTotalColumn( Total )
  ColumnTotal = Total;
  ColumnCount = 0;
end;

/* Менеджер вывода по колонкам, слегка модифицированный под конкретные нужды.    */
/* Last - признак обязательного вывода (для последнего отчета). */
macro SetNextColumn()/*PrintToNextColumn( NecessarilyOut, UserMacro, UserData )*/
  ColumnCount = ColumnCount + 1;

  if( OrderForm == 63 )
    CurColumn = 1;
    FlushFlag = True;
  else
    CurColumn = nextcolumn( CurColumn + 1 );
    if( CurColumn == NCOLUMNS ) FlushFlag = True; end;
  end;
  if( ColumnCount == ColumnTotal ) FlushFlag = True; end;

  SetColumn( CurColumn );
end;
/*  ExecMacro( UserMacro, UserData );*/
macro EndColumn()
  if( FlushFlag )
    FlushColumn();
    CurColumn = 0; FlushFlag = False;
  end;
end;

/*========================================================================*/
/*== Макросы печати ордеров для СБ =======================================*/
/*========================================================================*/

/* Печать ордера 53/54 СБ. Приспособлена для печати в 2 колонки. */
macro PrintOrder53_54( Form, DateDoc, Sum, SumStr, CurStr, Ground /*, [Sum2, CurStr2] */ )
  var Sum2, CurStr2; /* Для печати одновременно сумм прихода и расхода. */
  array arSum, arGround;
  strsplit( SumStr, arSum,    45-1, 45-1, 2 ); /* !!! В версии 876 strsplit врет на 1 символ */
  strsplit( Ground, arGround, 42-1, 42-1, 3 ); 
  if( arSum(1) == "" ) arSum(1) = "_"; end;

[                                                  ];
[                                         Форма N##]( Form );
[  #                                               ]( {ExName_Bank} );
[  Код ОКПО #                                      ]( {OKPO} );
[  Регистрационный номер N #                       ]( {ExRegNumber} );
[  #                                               ]( {Post_Addr} );
[                                                  ];
[                     КАССОВЫЙ ОРДЕР               ];
[                                                 #]( DateDoc:m:r );
[                                                  ];
    if( not getParm( 6, Sum2 )    or (Sum2 == $0) ) Sum2    = ""; end;
    if( not getParm( 7, CurStr2 ) or (Sum2 == "") ) CurStr2 = ""; end;

    if( Form == 53 )
[      ПРИНЯТЬ наличными    |    ВЫДАТЬ ценности   ];
[                           |                      ];
[               # #         |           #          ]( Sum, CurStr, Sum2 );
    else /* Form == 54 */
[      ВЫДАТЬ наличными     |    ПРИНЯТЬ ценности  ];
[                           |                      ];
[               # #         |           # #        ]( Sum2, CurStr2, Sum, CurStr );
    end;
    
[     #____________________________________________]( arSum(0) );
[     #____________________________________________]( arSum(1) );
[                  (сумма прописью)                ];
[                                                  ];
[     | #########################################  ]( arGround(0) );
[     | #########################################  ]( arGround(1) );
[     | #########################################  ]( arGround(2) );
[                                                  ];
[    Контролер______________ Кассир _______________];
[     Деньги                                       ];
[    в суммме руб._________________________________];
[                          (прописью)              ];
[    Получил_______________________________________];
[                                                  ];
[    Дебет счета     N                             ];
[    Кредит счета    N                             ];
[    Приход по счету N                             ];
[                                                  ];
[    Гл.(ст.) бухгалтер_______________________     ];
[                                                  ];
[--------------------------------------------------];
end;

macro PrintOrder63( DateDoc, Sum, SumStr, CurStr, Ground )
  array arGround;
  strsplit( Ground, arGround, 42-1, 42-1, 3 ); /* !!! В версии 876 strsplit врет на 1 символ */

[                                                                   Форма N63 ];
[ #                                                                           ]( {ExName_Bank} );
[ Код ОКПО #                                                                  ]( {OKPO} );
[ Регистрационный номер N #                                                   ]( {ExRegNumber} );
[ #                                                                           ]( {Post_Addr} );
[                                                                             ];
[                                #                                            ]( DateDoc:m );
[ На сумму #                                                                  ]( string(Sum) +" "+ CurStr );
[          #_________________________________________________________________ ]( SumStr );
[                            (сумма цифрами и прописью)                       ];
[    | ##########################################                             ]( arGround(0) );
[    | ##########################################                             ]( arGround(1) );
[    | ##########################################                             ]( arGround(2) );
[                                                                             ];
[ Управляющий отделением             Гл.бухгалтер                             ];
[ ----------------------------------------------------------------------------];
[                          Отметки бухгалтерии:                               ];
[         Начальная проводка:          |       Ответная проводка:             ];
[ Дебет счета  N                       |Дебет счета  N                        ];
[ Кредит счета N                       |Кредит счета N                        ];
[ Гл.бухгалтер_________________________|"___"__________ ____г. Гл.бухг._______];
[                                                                             ];
[ ----------------------------------------------------------------------------];
end;


/*========================================================================*/

/* Вывод стандартных форм в 2 колонки. Вся печать накапливается в буфере.
   Вывод буфера в файл идет, если колонка вторая или единственная (AllColumn == CurColumn).
*/
macro PrintStandartForm( 
  Form,                  /* № формы документа   */
  DateDoc,               /* Дата документа      */
  Sum,                   /* Сумма               */
  SumStr,                /* Строковое представление суммы       */
  CurStr,                /* Строковое представление кода валюты */
  Ground                 /* Основание документа */
/*, [[Sum2], [CurStr2]] */
)
  var Sum2, CurStr2;
  var NeedMessage = False;
  if( not getParm( 6, Sum2 )    or (Sum2 == $0) ) Sum2    = ""; end;
  if( not getParm( 7, CurStr2 ) or (Sum2 == "") ) CurStr2 = ""; end;

  /* Если данных нет - ничего не печатаем, остаемся в той же колонке. */
  if( Sum or Sum2 )
    SetNextColumn();
    if( (Form == 53) or (Form == 54) )
      PrintOrder53_54( Form, DateDoc, Sum, SumStr, CurStr, Ground, Sum2, CurStr2 );
    elif( Form == 63 )
      PrintOrder63( DateDoc, Sum, SumStr, CurStr, Ground );
    else
      NeedMessage = True;
    end;
    EndColumn();
  else NeedMessage = True;
  end;

  if( NeedMessage )
    msgbox( "Печать стандартных ф.", Form, " по операциям |\"", 
            GetNameCodif( OperCode, CDF_Oper ), "\"|",
            "по обороту \"" + GetNameCodif( OrderTurnType, CDF_Turn ) + "\"|",
            "пока не реализована!" );
  end;
end;

/*========================================================================*/
/*== Вспомогательные инструментальные функции =============================*/
/*========================================================================*/

/* Перевод суммы 232.80 в вид "Двести тридцать два рубля - 80" */
macro InsMinusInSumStr( sum, CodeCurrency )
  var str, 
      pos,
      kop;
  str = CurToStrAlt( sum, null, kop, CodeCurrency );
  pos = index( str, kop );
  str = substr( str, 1, pos-1 ) + "- " + kop;
  return str;
end;

/* Найти Короткое наименование валюты по ее строковому ISO коду. 
   Возвращает найденное наименование или "".
*/
macro GetShortNameCurr( ISO )
  file cur ( "curr.dbt", "exchange.def" ) key 1; 
  ClearRecord( cur );
  cur.ISO = string(ISO);
  if( getEQ( cur ) )
    return cur.ShortName;
  end;
  return "";
end;

/* Найти строковый ISO-код валюты по ее цифровому ISO коду. 
   Возвращает строковый ISO-код или "". 
*/
macro GetISOCurbyDigitCode( DigitCode )
  file iso ( "isocur.dbt", "exchange.def" ) key 1;
  DigitCode = string( DigitCode );
  Digitcode = mkstr( "0", 3 - strlen(DigitCode) ) + DigitCode;
  ClearRecord( iso );
  iso.NumberCode = DigitCode;
  if( getEQ( iso ) )
    return iso.ISOCode;
  end;
  return "";
end;

/* Получить наименование валюты в родительном падеже */
macro GetCurrencyCase( CodeCurrency )
  var buf,
      kop,              /* падеж управляется суммой: 1, 2, 5 */
      str = CurToStrAlt( $5, buf, kop, CodeCurrency ),
      pos = index( str, kop );
  return substr( substr( str, 1, pos-2 ), strlen(buf) + 2 ) ;
end;

/* Подготовить курс(любое число) для печати с указанным числом знаков после точки. 
   Возвращает подготовленную строку.
*/
macro PrepareRateForPrint( rate, point )
  var strrate = string(rate),
      pos = index( strrate, "." );
  if( pos ) 
    if( point == 0 ) point = -1; end;  /* Уберем точку */
    strrate = substr( strrate, 1, pos+ point ); 
    pos = index( strrate, ".0000" ); /* по умолчанию в запись об операции ставится 4 знака, */
    if( pos ) strrate = substr( strrate, 1, strlen(strrate)-2 ); end;  /* а они не нужны. Оставим 2. */
  end;
  return strrate;
end;

/* Удаление указанного символа symb с конца строки word количеством не более, 
   чем numb. Если numb не указан, удаляются все такие символы.
   Возвращается итоговая строка.
   Предназначена для печати чисел без конечных нулей, но с указанным числом 
   знаков после точки.
*/
macro DelLastSymb( word, symb /*, numb*/ )
  var len   = strlen( word ),
      last  = substr( word, len ),
      count = 0,
      numb;
  if( not getparm( 2, numb ) ) numb = 1024; /* !!! max длина строки в RSL */ end;

  while( (last == symb) and (count < numb) )
    count = count + 1;
    word  = substr( word, 1, len-1 );
    len   = len - 1;
    last  = substr( word, len );
  end;
  return word;
end;

/* Подготовить процентную ставку для печати: убрать все лишние нули после запятой,
   но оставив указанное количество знаков; для целых процентов убираем и саму запятую.
   Возвращает подготовленную строку.
*/
macro PreparePercentForPrint( Percent /*, [point]*/)
  var point,
      IsPoint = getparm( 1, point );
  if( IsPoint )
    return PrepareRateForPrint( Percent, point );
  elif( Percent - int(Percent) )
    return DelLastSymb( string(Percent), "0" )
  else 
    return PrepareRateForPrint( Percent, 0 );
  end;
end;
/*========================================================================*/

/*file oper    ( "operat.dbt",   "exchange.def" );*/
record oper    ( "operat.dbt",   "exchange.def" ); /* !!! Для вызова в контексте выполняемой программы. */
/*file   turn    ( "turnover.dbt", "exchange.def" ) key 0;*/ /* Задан в rstrfunc.mac */
file   operset ( "operset.dbt",  "exchange.def" );
/*file offadd  ( "offadd.dbt",   "exchange.def" );*/

const cdf_IncomeTax = -1,  /* Для обозначения мнимого оборота по подоходному налогу.
                              Налог сейчас записывается ТОЛЬКО в запись операции. */
      cdf_RateDifferent = -2; /* Для обозначения мнимого оборота на разницу курсов. */

/* Получить настройку операции */
macro GetOperSet( OperID )
  operset.Oper_Ref = OperID;
  return getEQ( operset );
end;
/* Получить дополнительные настройки обменного пункта. */
/*macro GetOfficeAdd()       /* !!! Обеспечить соответствие дополнительных настроек по ключу */
  offadd.ExBankNumber = 0;/*{ExBankNumber};*/
  return getGE( offadd );/*getEQ( offadd );*/
end;
*/
/* Подготовить данные по конкретному обороту */
macro PrepareDataForOrders( TurnType )
  var Percent  = 0.0,
      strPerc,
      RateDiff = $0;
  var GroundAdd = "", Rate, pos;

/* !!! Для отладки */
/*[    ### ## ############################## # ### ############################ ### ############ #]
( turn.Oper_Ref, turn.Type, GetNameCodif( turn.Type, CDF_Turn ):w, turn.Cash, turn.Curr_Ref, 
  GetNameCodif(turn.Trs_Ref, TrsRoot):w, turn.SubTrs_Ref, turn.Sum, turn.Insolvent );
*/
  OrderForm     = 0;   /* № формы документа   */
  OrderTurnType = turn.Type; /* Тип обрабатываемого оборота         */
  OrderSum      = $0;  /* Сумма               */
  OrderSumStr   = "";  /* Строковое представление суммы       */
  OrderCurStr   = "";  /* Строковое представление кода валюты */
  OrderGround   = "";  /* Основание документа */
  OrderSum2     = $0;  /* Сумма во второй колонке ордера. Проставляется НЕ ВСЕГДА.  */
  OrderCurStr2  = "";  /* Строковое представление для кода валюты во второй колонке */

  if( TurnType == CDF_TurnIncome )    /* Полученная от клиента сумма */
    if( TurnType == CDF_TurnIncome )
      OrderForm   = 54; 
      OrderCur    = oper.IncomeCurr_Ref;
      OrderSum    = OperIncomeAmount; /*oper.IncomeAmount;*/

      if( OperCode == CDF_OperIncasso )           /* Прием валюты на инкассо */
        OrderGround = "Принятие на инкассо" + " валюты: " + GetCurrencyCase( OrderCur );
      elif( OperCode == CDF_OperPayDocIncasso )   /* Прием ПД на инкассо     */
        OrderGround = "Принятие на инкассо" + " чека";
      elif( OperCode == CDF_OperExpert   )        /* Прием валюты на экспертизу */
        OrderGround =  "Принят на экпертизу" + " денежный билет";
      elif( OperCode == CDF_OperPayDocExpert )    /* Прием ПД на экспертизу */
        OrderGround = "Принят на экпертизу" + " ПД"; /* ??? название, серия, № и т.п.? */
      elif( OperCode == CDF_OperChange        )   /* Замена неплатежеспособной валюты */
        OrderGround = "Замена неплатежных " + GetCurrencyCase( OrderCur ) + " на платежные";
        OrderSum2   = OrderSum; 
        OrderCurStr2 = GetShortNameCurr( GetISOCurbyDigitCode( OrderCur ) );
      elif( OperCode == CDF_OperUnpayCurrBuy  )   /* Покупка неплатежеспособной валюты за рубли */
        OrderGround = "Покупка неплатежной валюты " + GetCurrencyCase( OrderCur ) + 
                     " по курсу покупки " + PrepareRateForPrint( oper.Kurs, oper.Point );
        OrderSum2    = money( OrderSum * oper.Kurs ); 
        OrderSumStr  = InsMinusInSumStr( OrderSum2, {NationalCur} );
        OrderCurStr2 = GetShortNameCurr( GetISOCurbyDigitCode( {NationalCur} ) );
      elif( OperCode == CDF_OperPayDocSale    )   /* Продажа платежного документа за рубли */
        OrderForm   = 53; 
        OrderGround = "Продажа ПД за рубли";    /* Количество бланков получим в OrderSum2 */
        ПолучитьСтрокуСерийНомеровПД_2( oper.ID, OrderSum2 );
      elif( OperCode == CDF_OperPayDocSaleCurr )  /* Продажа платежного документа за валюту */
        OrderForm   = 53; 
        OrderGround = "Продажа ПД за валюту";   /* Количество бланков получим в OrderSum2 */
        ПолучитьСтрокуСерийНомеровПД_2( oper.ID, OrderSum2 );
      end;
    end;

  elif( TurnType == CDF_TurnOut   )   /* Выданная клиенту сумма      */
    if( (OperCode == CDF_OperPayDocSale     ) or /* Продажа платежного документа за рубли  */
        (OperCode == CDF_OperPayDocSaleCurr )    /* Продажа платежного документа за валюту */
      )
      OrderForm   = 54; 
      OrderCur    = turn.Curr_Ref;
      OrderSum    = abs(turn.Sum);
      OrderGround = "Приняты ";

      OrderGround = OrderGround + "дорожные чеки" + " для продажи";
    end;

  elif( (TurnType == CDF_TurnCom) or  /* Общая комиссия              */
        (TurnType == CDF_TurnFix)     /* Фиксированная комиссия      */
      )
    OrderForm   = 53; 
    OrderCur    = turn.Curr_Ref;
    OrderSum    = turn.Sum;
    OrderGround = "Комиссия ";

    Percent = $0;
    if( turn.Type == CDF_TurnFix ) 
      Percent   = operset.FixSum; 
      GroundAdd = " " + GetShortNameCurr( GetISOCurbyDigitCode( operset.FixCurr_Ref ) );
      if( OperCode == CDF_OperPayDocSaleCurr )   /* Продажа платежного документа за валюту */
        Rate= turn.Sum / operset.FixSum;
        pos = index( GrComis1, "курс" );
        if( pos )
          strset( GrComis1, pos, "курс - " + PrepareRateForPrint( turn.Sum/operset.FixSum, oper.Point ) );
        end;
      end;
    end;
    strPerc = string( Percent );
    OrderGround = OrderGround + strPerc;
    if( GroundAdd ) OrderGround = OrderGround + GroundAdd; end;
    if( GrComis1  ) OrderGround = OrderGround + GrComis1;  end;

  elif( (TurnType == CDF_TurnTaxWithCom) or /* Налог с учетом комиссии     */
        (TurnType == CDF_TurnTaxWithoutCom) /* Налог без учета комиссии    */
      )
    OrderForm   = 53; 
    OrderCur    = turn.Curr_Ref;
    OrderSum    = turn.Sum;
    OrderGround = "Налог ";

    Percent = {SellTaxRate} * 100.;
    strPerc = PreparePercentForPrint( Percent );
    OrderGround = OrderGround + strPerc + "%";
    if( GrComis1 ) OrderGround = OrderGround + GrComis1; end;

  elif( (TurnType == CDF_TurnPComInc) or /* Сумма процентной комиссии от полученной суммы */
        (TurnType == CDF_TurnPComOut)    /* Сумма процентной комиссии от выданной суммы   */
      )
    OrderForm   = 53; 
    OrderCur    = oper.ComCurr_Ref;
    OrderSum    = oper.ComAmount;
    OrderGround = "Комиссия ";

    if( turn.Type == CDF_TurnPComInc ) Percent = operset.IncomePercent;
    else                               Percent = operset.OutPercent;
    end;
    strPerc = PreparePercentForPrint( Percent );
    OrderGround = OrderGround + strPerc + "%";
    if( GrComis1 ) OrderGround = OrderGround + GrComis1; end;

  elif( TurnType == cdf_IncomeTax )  /* Мнимый оборот по подоходному налогу */
    OrderForm   = 53;
    OrderSum    = oper.IncTaxValue;
    OrderCur    = {NationalCur};
    OrderGround = "Налог ";

    if( oper.Resident ) Percent = /*offadd.*/{IncTaxResident};
    else                Percent = /*offadd.*/{IncTaxNonResident};
    end;
    strPerc = PreparePercentForPrint( Percent );
    OrderGround = OrderGround + strPerc + "%";
    if( GrComis1 ) OrderGround = OrderGround + GrComis1; end;

  elif( TurnType == cdf_RateDifferent ) /* Мнимый оборот на разницу курсов */
/*[Готовим данные на Мнимый оборот на разницу курсов];*/
    OrderCur    = {NationalCur};
    OrderGround = "Разница между курсом ";
    if( OperCode == CDF_OperUnpayCurrBuy  )   /* Покупка неплатежеспособной валюты за рубли */
      OrderForm   = 63;
      RateDiff    = oper.CBRate - oper.Kurs;
      OrderSum    = money( OperIncomeAmount/*oper.IncomeAmount*/ * RateDiff );
      OrderGround = OrderGround + "покупки " + PrepareRateForPrint( oper.Kurs, oper.Point );
      GrComis1    = " при покупке неплатежных " + GetCurrencyCase( oper.IncomeCurr_Ref );
    else /*if( OperCode == CDF_OperPayDocSale    )*/   /* Продажа платежного документа за рубли */
      OrderForm   = 53;
      RateDiff    = oper.Kurs - oper.CBRate;
      OrderSum    = money( /*oper.OutAmount*/OperOutAmount * RateDiff );
      OrderGround = OrderGround + "продажи " + PrepareRateForPrint( oper.Kurs, oper.Point );
      GrComis1    = " при продаже ПД за рубли";
    end;
    GrRateDiff1 = " и курсом ЦБ " + PrepareRateForPrint( oper.CBRate, 2 );
    OrderGround = OrderGround + GrRateDiff1 + GrComis1;
  end;

  OrderCurStr = GetShortNameCurr( GetISOCurbyDigitCode( OrderCur ) );
  if( OrderSumStr == "" )
    OrderSumStr = InsMinusInSumStr( OrderSum, OrderCur );
  end;

  return True;
end;

/* Подготовить данные, общие для всей операции */
macro PrepareDataOfOperation()
  OperCode      = oper.Oper_Ref;
  OrderDate     = oper.Date;
  OrderRateDiff = False;

/*  if( not GetOfficeAdd() ) 
    ClearRecord( offadd );  /* !!! проценты по подоходному будут нулевыми. */
    msgbox( "Ошибка получения дополнительных настроек ОП!" ); 
  end;
*/
  /* Приведем суммы к "чистым" - без учета комиссии. Ф-ция из rstrfunc.mac. */
  copy( СоставРеестра, oper );
  OperIncomeAmount = oper.IncomeAmount;
  OperOutAmount    = oper.OutAmount;
  УчетНекассовыхОборотов( "По операции", OperIncomeAmount, OperOutAmount );

  GrComis1 = "";
  if  ( OperCode == CDF_OperIncasso       )   /* Прием валюты на инкассо */
    GrComis1 = " при приеме на инкассо " + GetCurrencyCase( oper.IncomeCurr_Ref );
  elif( OperCode == CDF_OperPayDocIncasso )   /* Прием ПД на инкассо     */
    GrComis1 = " при приеме на инкассо чека";
  elif( OperCode == CDF_OperChange        )   /* Замена неплатежеспособной валюты */
    GrComis1 = " при замене неплатежных " + GetCurrencyCase( oper.IncomeCurr_Ref ) + " на платежные";
  elif( OperCode == CDF_OperUnpayCurrBuy  )   /* Покупка неплатежеспособной валюты за рубли */
    GrComis1 = " при покупке неплатежных " + GetCurrencyCase( oper.IncomeCurr_Ref ) + 
               " курс " + PrepareRateForPrint( oper.Kurs, oper.Point );
  elif( OperCode == CDF_OperPayDocSale    )   /* Продажа платежного документа за рубли */
    GrComis1 = " от продажи ПД за рубли";
  elif( OperCode == CDF_OperPayDocSaleCurr)   /* Продажа платежного документа за валюту */
    GrComis1 = " от продажи ПД за валюту, курс - " + PrepareRateForPrint( /*oper.IncomeAmount*/OperIncomeAmount, oper.Point );
  elif( OperCode == CDF_OperCheck         )   /* Проверка на подлинность */
    GrComis1 = " при проверке на подлинность";
  end;
end;

macro FilterTurnOnOperRef()
  return ( (turn.Emp_Ref  == {exoper}       ) and
           (turn.Sess_Ref == {SessionNumber}) and
           (turn.Oper_Ref == oper.ID        )
         );
end;
macro GetFirstTurn()
   ClearRecord( turn );
   turn.Emp_Ref  = {exoper};
   turn.Sess_Ref = {SessionNumber};
   turn.Oper_Ref = oper.ID;
   if( getGE( turn ) ) return FilterTurnOnOperRef(); end;
   return False;
end;

macro FilterOnTurnKind()
  var RetVal = False,
      Kind   = turn.Type;

  /* все обороты по комиссиям допустимы */
  if( (Kind == CDF_TurnCom          ) or /* Общая комиссия             */
      (Kind == CDF_TurnFix          ) or /* Фиксированная комиссия     */
      (Kind == CDF_TurnTaxWithCom   ) or /* Налог с учетом комиссии  */
      (Kind == CDF_TurnTaxWithoutCom) or /* Налог без учета комиссии */
      (Kind == CDF_TurnPComInc      ) or /* Сумма процентной комиссии от полученной суммы*/
      (Kind == CDF_TurnPComOut      )    /* Сумма процентной комиссии от выданной суммы*/
    )
    RetVal = True;
  end;

  if( not RetVal )
    if( (OperCode == CDF_OperIncasso      ) or /* Прием валюты на инкассо */
        (OperCode == CDF_OperPayDocIncasso)    /* Прием ПД на инкассо */
      )
      if( Kind == CDF_TurnIncome )             /* Полученная от клиента сумма */
        RetVal = True;
      end;
    elif( (OperCode == CDF_OperExpert       ) or /* Прием на экспертизу */
          (OperCode == CDF_OperPayDocExpert )    /* Прием ПД на экспертизу */
      )
      if( Kind == CDF_TurnIncome )             /* Полученная от клиента сумма */
        RetVal = True;
      end;
    elif( OperCode == CDF_OperChange        )   /* Замена неплатежеспособной валюты */
        RetVal = True;
        /* Исключим обороты по отдаваемой ценности - печатается в том же ордере. */
        if( turn.Sum < 0 ) RetVal = False; end;
    elif( OperCode == CDF_OperUnpayCurrBuy  )   /* Покупка неплатежеспособной валюты за рубли */
        RetVal = True;
        if( Kind == CDF_TurnOut )              /* Выданная клиенту сумма      */
          RetVal = False;
        end;
    elif( OperCode == CDF_OperPayDocSale    )   /* Продажа платежного документа за рубли */
        RetVal = True;
    elif( OperCode == CDF_OperPayDocSaleCurr)   /* Продажа платежного документа за валюту */
        RetVal = True;
    end;
  end;

/* !!! Для отладки */
/*if(RetVal)
[    ### ## ############################## # ### ############################ ### ############ #]
( turn.Oper_Ref, turn.Type, GetNameCodif( turn.Type, CDF_Turn ):w, turn.Cash, turn.Curr_Ref, 
  GetNameCodif(turn.Trs_Ref, TrsRoot):w, turn.SubTrs_Ref, turn.Sum, turn.Insolvent );
end;
*/
  return RetVal;
end;

/* Узнать количество оборотов по операции */
macro CalcNumberOperationTurns()
  var loop  = GetFirstTurn(),
      count = 0;
  while( loop )
    /* Будем считать только нужные обороты */
    if( FilterOnTurnKind() ) count = count + 1; end;
    loop = next( turn ) and FilterTurnOnOperRef();
  end;
  if( count ) GetFirstTurn(); end;
  return count;
end;

/* Вызов процедуры пользователя при проходе по оборотам текущей операции */
macro CicleOnOperationTurns(/* UserMacro, UserData */)
  var NumTurns = CalcNumberOperationTurns(),
      loop     = GetFirstTurn(),
      Column   = 1;

  /* Для операций "Покупка неплатежной валюты" и "Продажа ПД за рубли" 
     добавим оборот на разницу между курсами операции и ЦБ. */
  if( ((oper.Oper_Ref == CDF_OperUnpayCurrBuy) or 
       (oper.Oper_Ref == CDF_OperPayDocSale  )) 
      and (oper.Kurs != oper.CBRate)
    )
    OrderRateDiff = True;
    NumTurns = NumTurns + 1;
  end;
  /* Если есть подоходный, добавим его к числу оборотов(ордеров) */
  if( oper.IncTaxValue ) NumTurns = NumTurns + 1; 
  end;

  if( NumTurns ) 
    SetTotalColumn( NumTurns );
    while( loop )
      if( FilterOnTurnKind() and PrepareDataForOrders( turn.Type ) )
        PrintStandartForm( 
              OrderForm,     /* № формы документа   */
              OrderDate,     /* Дата документа      */
              OrderSum,      /* Сумма               */
              OrderSumStr,   /* Строковое представление суммы       */
              OrderCurStr,   /* Строковое представление кода валюты */
              OrderGround,   /* Основание документа */
              OrderSum2,     /* Сумма во второй колонке ордера. Проставляется НЕ ВСЕГДА.  */
              OrderCurStr2   /* Строковое представление для кода валюты во второй колонке */
              );
        ;
      end;
      loop = next( turn ) and FilterTurnOnOperRef();
    end;

    /* Если нужно, выпустим ордер на разницу курсов. */
    if( OrderRateDiff and PrepareDataForOrders( cdf_RateDifferent ) )
       PrintStandartForm( OrderForm, OrderDate, OrderSum, OrderSumStr, OrderCurStr, OrderGround );
    end;
    /* Если есть подоходный, сформируем по нему ордер. */
    if( oper.IncTaxValue and PrepareDataForOrders( cdf_IncomeTax ) ) 
       PrintStandartForm( OrderForm, OrderDate, OrderSum, OrderSumStr, OrderCurStr, OrderGround );
    end;
  end;
end;

/* Фильтр по видам операций, на которые выпускаются ордера ф.53,54,63. */
macro FilterOnOperationKind( Code )
  if( (Code == CDF_OperIncasso       ) or  /* Прием на инкассо       */
      (Code == CDF_OperPayDocIncasso ) or  /* Прием ПД на инкассо    */
      (Code == CDF_OperExpert        ) or  /* Прием на экспертизу    */
      (Code == CDF_OperPayDocExpert  ) or  /* Прием ПД на экспертизу */
      (Code == CDF_OperChange        ) or  /* Замена неплатежеспособной валюты           */
      (Code == CDF_OperUnpayCurrBuy  ) or  /* Покупка неплатежеспособной валюты за рубли */
      (Code == CDF_OperPayDocSale    ) or  /* Продажа платежного документа за рубли      */
      (Code == CDF_OperPayDocSaleCurr)     /* Продажа платежного документа за валюту     */
   or (Code == CDF_OperCheck         )     /* Проверка на подлинность */
    )
    return True;
  end;
  return False;
end;

/*
var StartDate = date();

if( getDate( StartDate, "Введите дату операций:" ) )
  while( next( oper ) )
    if( oper.Date >= StartDate )

/* !!! Для отладки */
/*[
#### ## ########## ######## ##################################  ### ### ############  ### ### ############]
(oper.ID, oper.Oper_Ref, oper.Date, oper.Time, GetNameCodif(oper.Oper_Ref, CDF_Oper),
 oper.IncomeTrs_Ref, oper.IncomeCurr_Ref, oper.IncomeAmount,
 oper.OutTrs_Ref,    oper.OutCurr_Ref,    oper.OutAmount );
*/
      if( FilterOnOperationKind( oper.Oper_Ref ) and GetOperSet( oper.Oper_Ref ) )
        PrepareDataOfOperation();
        CicleOnOperationTurns( /*@PrintStandartForm*/ );
      end;
    end;
  end;
end;
*/
