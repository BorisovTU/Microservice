/*-RSL---------------------------------------- R-Style Software Lab --*/
/*----------------- Выгрузка информации в транспортные файлы----------*/
/*--------------------------------------------------------------------*/
/* RS-Bank      подсистема Обменный пункт            AV  13-04-98     */
/* История:                                                           */
/*    AV  8-05-98 добавил выгрузку информации о комиссии по реестрам  */
/*    AV 19-08-98 комиссии выгружаются в виде реестров в транспортный */
/*  файл реестров.  Типы реестров:                                    */
/*   "98" - фиксированная комиссия  "99" - процентная комиссия        */
/*    AV  5-11-98 добавил выгрузку доп. информации в desk_rec.dbt     */
/*    AV 20-11-98 добавил выгрузку во внебаланс информации об         */
/*                 инкасации и авансировании                          */
/*    RA 11-03-99 теперь транспорт выгружается в директорию           */
/*                экспорта (EXPORTMESDIR - exchange.ini)              */
/*             и если надо архивируется (ARCHTRANSPORT - exchange.ini)*/
/* 10.07.2000 VS Добавлено заполнение поля FileDescription, исправлено 
                 количество записей файла ***11 в info-файле.
   9-11.10.2000 VS Добавил заполнение при выгрузке файла сессий Retail.
    2.11.2000 VS Файл ??????11.dbt по внебалансу больше не нужен.
    RA 27-11-00  Добавлен файл ??????09.dbt по конверсии валютной мелочи
   31.10.14 удаление таблицы ddesk_rec_dbt по ##197859, 198467
            макрос все равно не компилируется, так что закомментирую его весь
// 
*/
/*
IMPORT ExchangeInter, 
       BankInter,       /* Для GetIniString */
       DeprIntr,        /* Для FormApplicationKey */
       "define.mac",
       "rstrfunc.mac";  /* Для работы с оборотами */

FILE InfoFile  ("sb_infss.dbt", "sbbank.def"  ) write;
FILE RstrFile  ("sbreestr.dbt", "sbbank.def"  ) write;
/*FILE NBDataFile("nb_data.dbt",  "sbbank.def"  ) write;*/
/*FILE DskRecFile("desk_rec.dbt", "sbbank.def"  ) write;*/
FILE CnvFile   ("pay_doc.dbt" , "sbbank.def"  ) write; /* RA 27-11-00 */
FILE Reestr    ("reestr.dbt"  , "exchange.def") key 2;
FILE Spravka   ("sprav.dbt"   , "exchange.def") key 1;/* Oper-State */
FILE Operat    ("operat.dbt"  , "exchange.def") key 1;/* Emloyee-SessNumber */
/* AV 8-05-98 файл оборотов по реестрам */
FILE Turn_Rstr ("turnrstr.dbt", "exchange.def") key 1; /* Oper-Date-Time */
/* AV 19-11-98*/
/*FILE PayDoc    ("paydoc.dbt",   "exchange.def") key 0; /* ID */     не нужен */
/* AV 23-11-98 справочник валют Retail */
FILE CurrRetail("currency.dbt", "sbbank.def"  ) key 1; /* ExternalCode */

/* глобальная структура с информацией об ОП */
RECORD Office  ( office, "exchange.def" );
/* глобальная структура с информацией о смене, по которой происходит выгрузка */
RECORD Sess    ( session,"exchange.def" );

/*RECORD DskRecBuff("desk_rec.dbt", "sbbank.def"  );*/
RECORD CnvBuff   ("pay_doc.cnv" , "sbbank.def"  ); /* RA 30-11-00 */

/* AV 19-11-98*/
/* структура для доступа к полю ExtInfo структуры операции с плат.документами */
/*RECORD paydocop ("paydocop.str","exchange.def"); RA 01-12-00 импортим из RSTRFUNC.MAC */

/* структура для доступа к полю ExtInfo структуры операции по                */
/*  авансу/передаче/возврату плат.документов                                 */
RECORD avanceop ("avance.str"  ,"exchange.def");
/* структура для доступа к полю ExtInfo структуры операции по                */
/*  учету излишков или недостачи                                             */
RECORD deficitop("deficit.str" ,"exchange.def");

ARRAY  ArrayPD,          /* массив ПД используемых в смене*/
       ArrayBuyNumPD,    /* сумма купленных ПД для каждого кода */
       ArraySaleNumPD,   /* сумма проданных ПД для каждого кода */
       ArrayRestNumPD,   /* сумма оставшихся ПД для каждого кода*/
       ArrayAvanceNumPD, /* сумма авансированных ПД для каждого кода */
       ArrayDetectOverplusNumPD,   /* сумма отраженных  излишков  ПД для каждого кода */
       ArrayGiveOutOverplusNumPD,  /* сумма выданных    излишков  ПД для каждого кода */
       ArrayDetectDeficitNumPD,    /* сумма отраженной  недостачи ПД для каждого кода */
       ArrayCompensateDeficitNumPD;/* сумма возмещенной недостачи ПД для каждого кода */

VAR  NumberPD  = 0; /* количество разновидностей ПД за смену */

ARRAY  ArrayCurr,          /* массив валют используемых в смене */
       ArrayAvanceSumCurr, /* сумма авансированной валюты для каждого кода  */
       ArrayIncassSumCurr, /* сумма инкассированной валюты для каждого кода */
       ArrayDetectOverplusSumCurr,   /* сумма отраженных  излишков  валюты для каждого кода */  
       ArrayGiveOutOverplusSumCurr,  /* сумма выданных    излишков  валюты для каждого кода */    
       ArrayDetectDeficitSumCurr,    /* сумма отраженной  недостачи валюты для каждого кода */ 
       ArrayCompensateDeficitSumCurr;/* сумма возмещенной недостачи валюты для каждого кода */

VAR  NumberCurr  = 0; /* количество используемых валют за смену */


const NumExchangeApp    = 0,  /* номер приложения "Обменный пункт" */
      NumExchRstrFile   = 14, /* номер файла с реестрами ОП в системе передачи данных в Retail */
/*      NumExchNBDataFile = 11, /* номер файла внебаланса в системе передачи данных в Retail */
*/
      NumExchDskRecFile = 16, /* номер файла с дополнительной информацией по внебалансу */
      NumExchCnvFile    = 09, /* номер файла c информацией по конверсии валютной мелочи */

      /* значение полей для: NB_DATA.DBT и DESK_REC.DBT */
      /* значение соответствующих полей для справок БСО */
      RefValue        = 6,
      TypeValue       = 2,
      CodIntValue     = 6,
      /* значение соответствующих полей для уничтоженных справок БСО */
      RefValue_kill   = 7,
      TypeValue_kill  = 2,
      CodIntValue_kill= 7,
      /* значение соответствующих полей для платежных документов */
      RefValuePD      = 0,
      TypeValuePD     = 4,
      /* значение соответствующих полей для валют */
      RefValueCurr    = 0,
      TypeValueCurr   = 1,
      /* значение поля Operation в файле desk_rec.dbt */
      OperationIncass = 3, /* инкассация(возврат) */
      OperationAvance = 4, /* аванс  */
      OperationDebet  = 5, /* расход */
        SubOperGiveOutOverplus   = 1, /* Выдача излишков      (расход)*/
        SubOperDetectDeficit     = 2, /* Отражение недостачи  (расход)*/
      OperationKredit = 6, /* приход */
        SubOperDetectOverplus    = 1, /* Отражение излишков   (приход)*/
        SubOperCompensateDeficit = 2; /* Возмещение недостачи (приход)*/

/*AV 19-08-98*/
const TypeReestrFixCom  = "98", /* тип реестра - фиксированная комиссия */
      TypeReestrPercCom = "99", /* тип реестра - процентная комиссия    */
      Oper_Ref_FixCom   =  98 , /* "операция" - фиксированная комиссия  */
      Oper_Ref_PercCom  =  99 ; /* "операция" - процентная комиссия     */

/* флаги дебет - кредит - для поля DskRecFile.IsDebCred */
const FlagKredit = 1, FlagDebet = 2;

/* для выгрузки конверсии валютной мелочи */
const NEED_PAYRATE     =   0,
      NEED_SALERATE    =   1,
      CO_Conversion    =  31, /* Кассовая операция - Конверсия                      */
      CNV_SB_CASHOPERT = 200, /* Документ по кассовой операции - для Application    */
      CVT_NONCASH_EXCH =   7; /* Вид конверсии - Б/н конвертация по операциям ОП    */

/* шаблоны для названий транспортных файлов*/
var  TemplInfoFile   = "??????99.dbt", /* информационный файл */
     TemplRstrFile   = "??????14.dbt", /* транспортный файл с реестрами */
/*     TemplNBDataFile = "??????11.dbt", /* транспортный файл с информацией по внебалансу */
*/
     TemplDskRecFile = "??????16.dbt", /* транспортный файл с доп.инф-ей по внебалансу  */
     TemplCnvFile    = "??????09.dbt", /* транспортный файл c информацией по конверсии валютной мелочи */
/* названия транспортных файлов */
     NameInfoFile   = "",
     NameRstrFile   = "",
/*     NameNBDataFile = "",*/
     NameDskRecFile = "",
     NameCnvFile    = "";

var RetailSession;  /* 11.10.2000 VS Класс для работы с сессией выгрузки Retail. */

/****************************************************************************/
/* Макрос архивации     RA 11-03-99    Взял из depositr\arc_sess.mac        */
/****************************************************************************/
file ArcList() txt;

MACRO ArcSession( Branch, SessionNum )
  
  const
    ListFname = "arclist.txt",
    ArcExt    = ".arj",
    ArcMask   = "*" + ArcExt,
    DbMask    = "*.dbt",
    ArcCmd    = "arj m -e -g",
    ExtrCmd   = "arj x -g";
  
  var
    ExportDir = GetIniString( "EXPORTMESDIR", "exchange.ini", TRUE ),
    ComSpec;
  
  var
    ArcName = "000000",
    BrStr   = String( Branch ),
    NumStr  = String( SessionNum ),
    Pwd     = String( SessionNum * Branch );
  
    StrSet( ArcName, 3 - StrLen( BrStr ), BrStr );
    StrSet( ArcName, 7 - StrLen( NumStr ), NumStr );
  
    Run( ComSpec, "/C " + ArcCmd + Pwd + " " + ExportDir + ArcName + ArcExt +
         " " + ExportDir + DbMask + " >nul" );
END;

/****************************************************************************/
/* Функция вставки записи в файл, с проверкой                               */
/****************************************************************************/
MACRO InsertWithCheck( PtrFile, NameFile, NumRec )
 var ercode, ertext, BreakLoop;
 if( NOT Insert( PtrFile, null, True ) )
    ercode = status(ertext);
    println( "Ошибка ", ercode," ", ertext, ": " + NameFile );
    BreakLoop = FALSE;
 else
    NumRec = NumRec + 1;
 end;
 return NumRec;
END;
/****************************************************************************/
/* Функция считает количество справок с определенным статусом для операции  */
/****************************************************************************/
MACRO CalcSprv( OperID, state )
  var Num = 0;
  Spravka.Oper_Ref  = OperID;
  Spravka.State_Ref = state;
  if( GetEQ( Spravka ) )
     Num = Num + 1;
     While( Next(Spravka) AND (Spravka.Oper_Ref == OperID) AND (Spravka.State_Ref == state) )
        Num = Num + 1;
     end;
  end;
  return Num;
END;
/****************************************************************************/
/* Функция получает внутренний код валюты Retail по внешнему коду           */
/****************************************************************************/
MACRO GetCurrRetail( ExternalCode )
   ClearRecord( CurrRetail );
   CurrRetail.ExternalCode = ExternalCode;
   if( GetEQ(CurrRetail) )
      return CurrRetail.Code_Currency;
   else
      return ANY_CURR;
   end;
END;
/****************************************************************************/
/* Функция заносит стандартную информацию в запись файла с инф-ей по        */
/*   внебалансу                                                             */
/****************************************************************************/
/*MACRO StandartInfoToNBDataFile
   NBDataFile.Date        = Sess.StopDate;/* дата завершения смены в ОП */
   NBDataFile.IsCur       = 1;            /* признак валютной ценности  */
   NBDataFile.CurRest     = NBDataFile.PrevRest = 0;
   NBDataFile.FNCash      = Office.ID;    /* номер ОП в банке */
   NBDataFile.NumSession  = NBDataFile.Brigade = Sess.Number; /* номер смены */
END;
*/
/****************************************************************************/
/* Функция заносит стандартную информацию в запись файла с доп. инф-ей      */
/*   структура - desk_rec.dbt                                               */
/****************************************************************************/
/*  
MACRO StandartInfoToDskRecBuff( )
   DskRecBuff.IsCur      =  1;
   DskRecBuff.Branch     = Office.ID; /*NumFNCash();/* номер филиала */ */
   DskRecBuff.Brigade    = Sess.Number;
   DskRecBuff.Date       = Sess.StopDate;
   DskRecBuff.ApplicationKind = SB_NOTBALANCE;
   DskRecBuff.ApplicationKey  = FormApplicationKey( SB_NOTBALANCE ); 
END;*/
/****************************************************************************/
/*  Процедура заполняет и заносит запись с доп. инф-ей в файл DskRecFile    */
/*   структура - desk_rec.dbt                                               */
/****************************************************************************/
/*MACRO RecordToDskRecFile( NumItems, Sum, Operation, TypeValue, CodIntValue, RefValue, SubOper, FlagDebCredOper, NumRec )

    ClearRecord(DskRecBuff);
    StandartInfoToDskRecBuff();
    DskRecBuff.NumItems    = NumItems;    /* количество ценностей - в штуках*/
    DskRecBuff.Sum         = Sum;         /* сумма ценностей                */
    DskRecBuff.Operation   = Operation;   /* вид операции        */
    DskRecBuff.TypeValue   = TypeValue;   /* тип ценности        */
    DskRecBuff.CodIntValue = CodIntValue; /* код валюты ценности */
    DskRecBuff.ValueRef    = RefValue;    /* ссылка на ценность  */
    DskRecBuff.SubOper     = SubOper;
    DskRecBuff.IsDebCred   = FlagDebCredOper;

    Copy( DskRecFile, DskRecBuff );
    /* занесем запись в файл (с проверкой) */
    return InsertWithCheck( DskRecFile, NameDskRecFile, NumRec );
END; */
/****************************************************************************/
/* Функция заносит общую информацию о транспортном файле в файл с           */
/*  информацией о выгрузке                                                  */
/****************************************************************************/
MACRO UpdateInfoFile( TR_NameFile, NumFile, NumRec, Comment )
 var ercode, ertext;
 if( NumRec != 0 )
    ClearRecord( InfoFile );
    InfoFile.FNcash          = office.ID;
    InfoFile.NumSession      = RetailSession.Number; /*Sess.Number; 2.11.2000 VS */
    InfoFile.ApplFile        = NumExchangeApp;  /* номер приложения - "ОП"    */
    InfoFile.NumFile         = NumFile;         /* файл с инфой о реестрах ОП */
    InfoFile.DBTNameFile     = "";
    InfoFile.TR_NameFile     = TR_NameFile;
    InfoFile.ColRecord       = NumRec;
    InfoFile.FileDescription = Comment;
    if( NOT Insert(InfoFile) )
       ercode = status(ertext);
       println( "Ошибка ", ercode, " ", ertext, ": " + NameInfoFile );
       return FALSE;
    else
       return TRUE;
    end;
 else
    return FALSE;
 end;
END;
/****************************************************************************/
/* Функция формирует имя транспортного файла, создает и открывает его       */
/****************************************************************************/
MACRO CreateTransportFile( PtrFile, Template, NameFile )
 var StrNumExchange = AddZero( Office.ID,   2 ),
 /*  StrNumSession  = AddZero( Sess.Number, 4 ); */
     NumSession     = RetailSession.Number,
     StrNumSession  = "";
 var ExportDir = GetIniString( "EXPORTMESDIR", "exchange.ini", TRUE);

 if( SubStr( ExportDir, StrLen( ExportDir ), 1 ) != "\\" )
    ExportDir = ExportDir + "\\";
 end;

 /* нормируем № файла в диапазон 0-9999 */
 while( NumSession >= 10000 )
    NumSession = NumSession - 10000;
 end;
 StrNumSession = AddZero( NumSession, 4 );
 
 StrSet( Template, 1, StrNumExchange );
 StrSet( Template, 3, StrNumSession  );

 if( Clone( PtrFile, ExportDir+Template, FALSE ) AND Open( PtrFile, ExportDir+Template ) )
   println(" Транспортный файл " + Template + " создан");
   SetParm( 2, Template );
   return True;
 else
   return False;
 end;
END;
/****************************************************************************/
/* Функция для удаления пустых транспортных файлов                          */
/****************************************************************************/
MACRO DelTransportFile( PtrFile )
 var StrNameFile = FileName( PtrFile);
     Close(PtrFile);
     if( NOT DelFile( StrNameFile ) )
        println("Ошибка удаления транспортного файла: " + StrNameFile);
     else
        println("Транспортный файл " + StrNameFile + " удален");
     end;
END;
/****************************************************************************/
/* Функция реакции на ошибку при создании транспортного файла               */
/****************************************************************************/
MACRO ReActionForErrorCreate( PtrFile, NameFile )
    if( NameFile == "" )
       println("Ошибка при создании транспортного файла" + NameFile );
    else
       DelTransportFile( PtrFile );
    end;
END;
/***************************************************************************/
/* ОСНОВНЫЕ ПРОЦЕДУРЫ ВЫГРУЗКИ ИНФОРМАЦИИ В ТРАНСПОРТНЫЕ ФАЙЛЫ             */
/***************************************************************************/
/***************************************************************************/
/* Процедура заполняет запись Reestr на основании записи Turnover(оборот)  */
/***************************************************************************/
MACRO TurnoverToReestr( Turn_Rstr )
   RstrFile.ExchangeNumber = office.ID;
   RstrFile.Emp_Ref        = Turn_Rstr.Emp_Ref;
   RstrFile.Sess_Ref       = Turn_Rstr.Sess_Ref;
   RstrFile.IncomeTrs_Ref  = Turn_Rstr.Trs_Ref;
   RstrFile.IncomeCurr_Ref = Turn_Rstr.Curr_Ref;
   RstrFile.IncomeSum      = Turn_Rstr.Sum;
   RstrFile.Date           = Turn_Rstr.Date;
   RstrFile.Time           = Turn_Rstr.Time;

   /* ссылка на реестр, по которому суммируются в данный оборот комиссии */
   RstrFile.State_Ref      = Turn_Rstr.Oper_Ref;

   /* Признак открыт\закрыт */
   if( Turn_Rstr.Noncompleted == UNSET_CHAR )
     RstrFile.OpenClose    = SET_CHAR;    /* закрыт */
   else
     RstrFile.OpenClose    = UNSET_CHAR;
   end;

   /* определение типа реестра */
   if( Turn_Rstr.Type == CDF_TurnFix )
      RstrFile.Type_Ref = TypeReestrFixCom; /*"98"*/
      RstrFile.Oper_Ref = Oper_Ref_FixCom;  /* 98 */
   else
      RstrFile.Type_Ref = TypeReestrPercCom;/*"99"*/
      RstrFile.Oper_Ref = Oper_Ref_PercCom; /* 99 */
   end;
END;
/****************************************************************************/
/* Процедура формирует уникальный ключ для реестра с комиссиями             */
/****************************************************************************/
MACRO CalcRegNumbForComis( Rstr, Type_Ref, Rate_Ref )
  /* Длина UserRegNumb 25 символов!!! */

  return string( Rstr.AutoKey )            + "." +
         string( Type_Ref )                + "." +
         string( Rstr.Type_Ref )           + "." +
         MakeCodeCurr(Rstr.IncomeCurr_Ref);
         /*AV 13-10-98*/
         /*string( Rate_Ref )                +*/
         /*string( Rstr.Emp_Ref )            +*/
         /*string( Rstr.Sess_Ref );           */

/*11.98.810.999.9999.999*/
END;
/***************************************************************************/
/* Процедура заполняет запись RstrFile на основании записи Operat          */
/***************************************************************************/
MACRO OperToReestr()
   RstrFile.ExchangeNumber = office.ID;
   RstrFile.Emp_Ref        = Operat.Emp_Ref;
   RstrFile.Sess_Ref       = Operat.Sess_Ref;
/* RstrFile.Type_Ref - отдельно для каждой операции*/
   RstrFile.IncomeTrs_Ref  = Operat.IncomeTrs_Ref;
   RstrFile.OutTrs_Ref     = Operat.OutTrs_Ref;
   RstrFile.IncomeCurr_Ref = Operat.IncomeCurr_Ref;
   RstrFile.OutCurr_Ref    = Operat.OutCurr_Ref;
   RstrFile.Rate_Ref       = Operat.Rate_Ref;
   RstrFile.Rate           = Operat.Kurs;
   RstrFile.CBRate         = Operat.CBRate;
/* RstrFile.Scale     */   
/* RstrFile.Point     */   
/* RstrFile.OutRate   */   
/* RstrFile.UserRegNumb - отдельно для каждой операции */
/* RstrFile.State_Ref   - не используется ?*/
   RstrFile.Date           = Operat.Date;
   RstrFile.Time           = Operat.Time;
   RstrFile.IncomeSum      = Operat.IncomeAmount;
   RstrFile.OutSum         = Operat.OutAmount;
   if( ( Operat.State_Ref == CDF_OperCompleted ) OR
       ( Operat.State_Ref == CDF_OperInReestr  ) )
     RstrFile.OpenClose    = SET_CHAR;
   else
     RstrFile.OpenClose    = UNSET_CHAR;
   end;
   RstrFile.Oper_Ref       = Operat.Oper_Ref;
/* RstrFile.TaxSum    */
/* RstrFile.IncTaxSum */
   RetailSession.SetMinMaxDate();
END;
/****************************************************************************/
/* Процедура заносит код ПД в запись RstrFile                               */
/* Вместо кода второй валюты. Безумие.                                      */
/* 20.10.2000 VS Вместо безумия сделаем пока заполнение поля кода ПД.       */
/****************************************************************************/
MACRO AddPD_Ref()
   SetRecordAddr( paydocop, Operat, 0, FldOffset( Operat,"ExtInfo"),True);
   if(
         ( Operat.Oper_Ref == CDF_OperPayDocBuy      ) OR
         ( Operat.Oper_Ref == CDF_OperPayDocBuyCurr  )
     )
       /* RstrFile.OutCurr_Ref = paydocop.PayDoc_Ref; */
      RstrFile.IncomePayDoc_Ref = paydocop.PayDoc_Ref;
   elif(
         ( Operat.Oper_Ref == CDF_OperPayDocSale     ) OR
         ( Operat.Oper_Ref == CDF_OperPayDocSaleCurr )
       )
       /* RstrFile.IncomeCurr_Ref = paydocop.PayDoc_Ref; */
      RstrFile.OutPayDoc_Ref = paydocop.PayDoc_Ref;
   end;
END;
/****************************************************************************/
/* Процедура формирует уникальный ключ для реестра - операции               */
/****************************************************************************/
MACRO CalcRegNumbForOperat( Rstr, Operat_AutoKey )
  /* Длина UserRegNumb 25 символов!!! */

  return          string( Rstr.AutoKey   )           + "." +
                  string( Operat_AutoKey )           + "." +
                  string( Rstr.Type_Ref  )           + "." +
                  MakeCodeCurr(Rstr.IncomeCurr_Ref);
END;
/***************************************************************************/
/*процедура заносит информацию о комиссии по реестрам в транспорт.файл     */
/* AV 19-08-98 : занесение в виде специальных типов реестров               */
/* 98 - фиксированная комиссия  99 - процентная комиссия                   */
/***************************************************************************/
MACRO  DnLoadComisForRetail( NumRec )
  var BreakLoop1, BreakLoop2, ercode, ertext;
  /* для поиска реестров текущего кассира текущей смены */
  Reestr.ExchangeNumber = office.ID;
  Reestr.Emp_Ref        = Sess.Emp_Ref;
  Reestr.Sess_Ref       = Sess.Number;
  Reestr.Type_Ref       = "";
  Reestr.OutCurr_Ref = Reestr.IncomeCurr_Ref = Reestr.Rate_Ref = 0;
 
  BreakLoop1 = GetGE( Reestr );
  /* цикл по реестрам */
  While( (BreakLoop1 == True) AND (Reestr.Emp_Ref == Sess.Emp_Ref ) AND (Reestr.Sess_Ref== Sess.Number) )
     /* для поиска оборотов комиссии по текущему реестру */
     Turn_Rstr.Oper_Ref = Reestr.AutoKey;
     BreakLoop2 = GetGE(Turn_Rstr);
     /* цикл по оборотам */
     While( (BreakLoop2 == True) AND (Turn_Rstr.Oper_Ref == Reestr.AutoKey) )
        /* если оборот по комиссии - заносим его в транспортный файл */
        if( (Turn_Rstr.Type == CDF_TurnFix    ) OR /* фиксированная   */
            (Turn_Rstr.Type == CDF_TurnPComInc) OR /* % от полученной */
            (Turn_Rstr.Type == CDF_TurnPComOut) )  /* % от выданной   */
           ClearRecord( RstrFile );
           /* оборот конвертируем в реестр */
           TurnoverToReestr( Turn_Rstr );
           /* формируем уникальный ключ для реестра по комиссии */
           RstrFile.UserRegNumb = CalcRegNumbForComis( RstrFile,
                                                       Reestr.AutoKey,
                                                       Reestr.Type_Ref,
                                                       Reestr.Rate_Ref );
           if( NOT Insert( RstrFile ) )
              ercode = status(ertext);
              println( "Ошибка ", ercode, " ", ertext, ": " + NameRstrFile );
              BreakLoop2 = FALSE;
              BreakLoop1 = FALSE;
           else
              NumRec = NumRec + 1;
           end;
        end;
        if(BreakLoop2) BreakLoop2 = Next( Turn_Rstr ); end;
     end;
     if(BreakLoop1) BreakLoop1 = Next( Reestr ); end;
  end;
 
  return NumRec;
END;
/***************************************************************************/
/* процедура заносит информацию об операциях определенного типа            */
/* в виде специальных типов реестров                                       */
/***************************************************************************/
MACRO DnLoadOperForRetail( TypeOper, NumRec )
 var BreakLoop, ercode, ertext;

 ClearRecord( Operat );
 Operat.Emp_Ref        = Sess.Emp_Ref;
 Operat.Sess_Ref       = Sess.Number;
 Operat.Oper_Ref       = TypeOper;
                                          
 BreakLoop = GetGE( Operat );            
 While( ( BreakLoop       == True         ) AND
        ( Operat.Emp_Ref  == Sess.Emp_Ref ) AND
        ( Operat.Sess_Ref == Sess.Number  ) AND
        ( Operat.Oper_Ref == TypeOper     )   )

    if( (Operat.State_Ref == CDF_OperCompleted) OR (Operat.State_Ref == CDF_OperInReestr) )                                            
       ClearRecord( RstrFile );
       /* операцию конвертируем в реестр */
       OperToReestr();
       /* вставляем код ПД */
       AddPD_Ref();
       /* формируем уникальный ключ */
       RstrFile.UserRegNumb = CalcRegNumbForOperat( RstrFile, Operat.ID );
                                                    
       if( NOT Insert( RstrFile ) )
          ercode = status(ertext);
          println("Ошибка ", ercode," ", ertext, ": " + NameRstrFile );
          BreakLoop = FALSE;
       else
          NumRec = NumRec + 1;
       end;
    end;
    if(BreakLoop) BreakLoop = Next( Operat ); end;

 end;

 return NumRec;
END;
/***************************************************************************/
/* процедура заносит информацию об операциях инкассо\экспертизы            */
/* в виде специальных типов реестров                                       */
/***************************************************************************/
MACRO DnLoadIncassExpertForRetail( NumRec )
 NumRec = DnLoadOperForRetail( CDF_OperIncasso,             NumRec ); /* Прием вал. на инкассо     */
 NumRec = DnLoadOperForRetail( CDF_OperExpert,              NumRec ); /* Прием вал. на экспертизу  */
 NumRec = DnLoadOperForRetail( CDF_OperReturnIncasso,       NumRec ); /* Возврат вал. с инкассо    */
 NumRec = DnLoadOperForRetail( CDF_OperReturnExpert,        NumRec ); /* Возврат вал. с экспертизы */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocIncasso,       NumRec ); /* Прием ПД на инкассо       */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocExpert,        NumRec ); /* Прием ПД на экспертизу    */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocReturnIncasso, NumRec ); /* Возврат ПД с инкассо      */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocReturnExpert,  NumRec ); /* Возврат ПД с экспертизы   */
/* 16.10.2000 VS Операции с ПД контируются по РЕЕСТРАМ, по операциям их выгружать НЕ нужно. */
/* 20.10.2000 VS Пока еще оставим, а после того, как сделаем опциональное формирование реестров, уберем. */
/* 21.11.2000 VS Реализовано опциональное формирование реестров по ПД и карточкам. Убрана выгрузка по операциям.
 NumRec = DnLoadOperForRetail( CDF_OperPayDocBuy,           NumRec ); /* Покупка ПД за рубли       */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocSale,          NumRec ); /* Продажа ПД за рубли       */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocBuyCurr,       NumRec ); /* Покупка ПД за валюту      */
 NumRec = DnLoadOperForRetail( CDF_OperPayDocSaleCurr,      NumRec ); /* Продажа ПД за валюту      */
*/
 return NumRec;
END;

/****************************************************************************/
/* процедура заполняет данные по конвертации валютной мелочи                */
/****************************************************************************/
MACRO FillCnvCoinFile()

  var ConvSum    = $0.0;
  var ConvSumRUR = $0.0;
  var ConvCurr   = ANY_CURR;
  var Skip       = True;

  copy( Реестр, Reestr );/* GetTurnReestr() и GetNextTurnReestr() используют Реестр */

  if( GetTurnReestr( CDF_TurnCnvCoins ) )
    if  (   (TurnReestr.Cash     == UNSET_CHAR   )
        AND (TurnReestr.Curr_Ref != {NationalCur})
        )
      ConvSum    = abs(TurnReestr.Sum);
      ConvCurr   = abs(TurnReestr.Curr_Ref);
    elif(   (TurnReestr.Cash     == SET_CHAR     )
        AND (TurnReestr.Curr_Ref == {NationalCur})
        )
      ConvSumRUR = abs(TurnReestr.Sum);
    end;
    if( GetNextTurnReestr( CDF_TurnCnvCoins ) )
      if  (   (TurnReestr.Cash     == UNSET_CHAR   )
          AND (TurnReestr.Curr_Ref != {NationalCur})
          )
        ConvSum    = abs(TurnReestr.Sum);
        ConvCurr   = abs(TurnReestr.Curr_Ref);
      elif(   (TurnReestr.Cash     == SET_CHAR     )
          AND (TurnReestr.Curr_Ref == {NationalCur})
          )
        ConvSumRUR = abs(TurnReestr.Sum);
      end;
    end;
  end;

  /* Вставка документа на сумму конвертации */
  if( ConvSum )
    SetRecordAddr( CnvBuff, CnvFile, 0, 0, True );
    ClearRecord( CnvBuff );
    CnvBuff.FNCash              = Office.ID;
    CnvBuff.IsCur               = 1; /* валютный     мож, дефайн какой есть? */
    CnvBuff.GroupOpert          = CO_Conversion;
    CnvBuff.Oper                = {exoper};
    CnvBuff.InSum               = ConvSumRUR;
    CnvBuff.VydachSum           = ConvSumRUR;
    CnvBuff.KonvertSum          = ConvSum;
    CnvBuff.ApplType            = FlagDebet;
    CnvBuff.Yield               = Money(ConvSum * Reestr.CBRate - ConvSumRUR);
    CnvBuff.Rate                = Reestr.Rate;
    CnvBuff.CBRate              = Reestr.CBRate;
    CnvBuff.FlagCredit          = StrFor( FlagDebet );
    CnvBuff.Date_Document       = Reestr.Date;
    CnvBuff.NumOpert            = CVT_NONCASH_EXCH;
    CnvBuff.KonvertCodCur       = GetCurrRetail( ConvCurr );
    /* непонятно, чем эти поля заполнить
    CnvBuff.ClientLastName    
    CnvBuff.ClientFirstName   
    CnvBuff.ClientSecondName  
    CnvBuff.SocialNumber      
    CnvBuff.PersIDType        
    CnvBuff.PassportSer       
    CnvBuff.PassportNumb      
    CnvBuff.PassportIssuer    
    CnvBuff.PassportDate      
    CnvBuff.ReceiverCod       
    CnvBuff.RecipientBankName 
    CnvBuff.RecipientBankMFO  
    CnvBuff.CorAcc_Recipient  
    CnvBuff.Account_Recipient 
    */
    CnvBuff.Ground              = "Безналичная конвертация по операции " + GetNameCodif( Reestr.Oper_Ref, CDF_Oper );

    CnvBuff.iApplicationKind    = CNV_SB_CASHOPERT;
    CnvBuff.ApplicationKey      = Reestr.UserRegNumb;

    Skip = False;
  end;

  return Skip;
END;

/****************************************************************************/
/* процедура заносит информацию по реестрам ОП для Retail в транспорт.файлы */
/****************************************************************************/
MACRO DnLoadRstrForRetail()
  var NumRec = 0, BreakLoop = TRUE, ercode, ertext;
  /* поиск и запись реестров текущего кассира текущей смены */
  Reestr.ExchangeNumber = office.ID;
  Reestr.Emp_Ref        = Sess.Emp_Ref;
  Reestr.Sess_Ref       = Sess.Number;
  if( GetGE( Reestr ) )
    While( BreakLoop
           AND (Reestr.Emp_Ref == Sess.Emp_Ref)
           AND (Reestr.Sess_Ref== Sess.Number )
         )
       Copy( RstrFile, Reestr );
       if( NOT Insert(RstrFile) )
          ercode = status(ertext);
          println("Ошибка ", ercode," ", ertext, ": " + NameRstrFile );
          BreakLoop = FALSE;
       else
          NumRec = NumRec + 1;
          BreakLoop = Next( Reestr );
       end;
    end;
  end;
 
  /* AV 19-08-98 : заносим в виде специальных реестров "98" и "99" */
  /* информацию о суммарных фиксированной и процентной комиссиях   */
  NumRec = DnLoadComisForRetail( NumRec );
 
  /* RA 10-11-99 : заносим в виде специальных реестров */
  /* информацию об операциях инкассо\экспертизы        */
  NumRec = DnLoadIncassExpertForRetail( NumRec );
 
  return NumRec;

END;
/****************************************************************************/
/* процедура заносит информацию по справкам ОП для Retail в транспорт.файлы */
/* - NumDeskRecords используется для возврата кол-ва записей в DskRecFile   */
/****************************************************************************/
/*
MACRO DnLoadSprvForRetail( /*NumDeskRecords*/ )
  VAR NumGetOutSprv = 0, NumKillSprv = 0,
      NumAvanceSprv = CalcTransferBSO( Sess.Emp_Ref, Sess.Number, CDF_OperAvance   ),
      NumTransfSprv = CalcTransferBSO( Sess.Emp_Ref, Sess.Number, CDF_OperTransfer ),
      NumReturnSprv = CalcTransferBSO( Sess.Emp_Ref, Sess.Number, CDF_OperCashOut  ),
      AllDebetSprv  = 0, AllKreditSprv = 0,
      NumRec        = 0,
      BreakLoop     = TRUE, 
      ercode, ertext,
      TmpVar,
      NumDskRec = 0;/* выгружено записей в DskRecFile (desk_rec.dbt) */

  if( GetParm( 0, TmpVar ) )
     NumDskRec = TmpVar;
  end;

  /* поиск и запись операций текущего кассира текущей смены */
  ClearRecord( Operat );
  Operat.Emp_Ref  = Sess.Emp_Ref;
  Operat.Sess_Ref = Sess.Number;
  if( GetGE( Operat ) )
    While( BreakLoop
           AND ( Operat.Emp_Ref == Sess.Emp_Ref )
           AND ( Operat.Sess_Ref== Sess.Number  )
         )
      if( (Operat.State_Ref == CDF_OperCompleted) OR (Operat.State_Ref == CDF_OperInReestr) )
         /* подсчет выданных справок */
         NumGetOutSprv = NumGetOutSprv + CalcSprv( Operat.ID, CDF_SprvGetOut );
         /* подсчет уничтоженных справок */
         NumKillSprv   = NumKillSprv   + CalcSprv( Operat.ID, CDF_SprvKill   );
         RetailSession.SetMinMaxDate();
      end;
      if( (Operat.Emp_Ref != Sess.Emp_Ref) OR (Operat.Sess_Ref != Sess.Number) )
         BreakLoop = False;/* для ускорения работы макроса */
      else
         BreakLoop = Next( Operat );
      end;
    end;
  end;
  /* всего израсходовано справок за смену */
  AllDebetSprv  = NumTransfSprv + NumReturnSprv + NumGetOutSprv + NumKillSprv;
  /* всего получено справок за смену */
  AllKreditSprv = AllDebetSprv - NumTransfSprv;
  /* если операционист получал во время смены справки БСО */
 
  if( AllKreditSprv )
     /* заполнение записи по справкам БСО */
/*     StandartInfoToNBDataFile();
     NBDataFile.RefValue    = RefValue;
     NBDataFile.TypeValue   = TypeValue;
     NBDataFile.CodIntValue = CodIntValue;
     /* всего выдано справок за смену */
     NBDataFile.DebCol      = Money(NumGetOutSprv * 100);
*/
     if( NumGetOutSprv )
        NumDskRec = RecordToDskRecFile( NumGetOutSprv, 0, OperationDebet, TypeValue, CodIntValue, RefValue, 0, FlagDebet, NumDskRec );
     end;
     /* кол-во справок полученных за смену */
/*     NBDataFile.AdvCol      = Money(AllKreditSprv * 100);*/
     if( AllKreditSprv )
        NumDskRec = RecordToDskRecFile( AllKreditSprv, 0, OperationAvance, TypeValue, CodIntValue, RefValue, 0, FlagKredit, NumDskRec );
     end;
     /* кол-во справок оставшихся в конце смены (возврат) */
/*     NBDataFile.IncasCol    = Money(NumReturnSprv * 100);*/
     if( NumReturnSprv )
        NumDskRec = RecordToDskRecFile( NumReturnSprv, 0, OperationIncass, TypeValue, CodIntValue, RefValue, 0, FlagDebet, NumDskRec );
     end;
/*     NumRec = InsertWithCheck( NBDataFile, NameNBDataFile, NumRec );*/
  end;
  /* заполнение записи по испорченным справкам БСО */
/*  if( NumKillSprv )
     StandartInfoToNBDataFile();
     NBDataFile.RefValue    = RefValue_kill;
     NBDataFile.TypeValue   = TypeValue_kill;
     NBDataFile.CodIntValue = CodIntValue_kill;
     NBDataFile.AdvCol      = 0;
     NBDataFile.IncasCol    = 0;
     /* кол-во уничтоженных справок */
     NBDataFile.DebCol = Money(NumKillSprv * 100);
 
     NumDskRec = RecordToDskRecFile( NumKillSprv, 0, OperationDebet, TypeValue_kill, CodIntValue_kill, RefValue_kill, 0, FlagDebet, NumDskRec );
     NumRec = InsertWithCheck( NBDataFile, NameNBDataFile, NumRec );
  end;
*/
  SetParm( 0, NumDskRec );
 
 return NumRec;

END;
*/
/*AV 20-11-98*/
/***************************************************************************/
/* процедура заносит информацию по ПЛАТЕЖНЫМ ДОКУМЕНТАМ в транспорт.файлы  */
/*  - NumDeskRecords используется для возврата кол-ва записей в DskRecFile */
/***************************************************************************/
/*
MACRO DnLoadPayDocForRetail( /*NumDeskRecords*/ )
  VAR NumRec    = 0,
      BreakLoop = TRUE,
      ercode, ertext,
      TmpVar, Amount,
      NumDskRec = 0,/* выгружено записей в DskRecFile (desk_rec.dbt) */
      NumPD     = 0,
      i;

    /* инициализация всех массивов сумм ПД - для ПД с определенным кодом */
    MACRO InitArraysPD( NumPD )
       if( ValType( ArraySaleNumPD(NumPD) ) == V_UNDEF )
          ArraySaleNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayBuyNumPD(NumPD) ) == V_UNDEF )
          ArrayBuyNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayRestNumPD(NumPD) ) == V_UNDEF )
          ArrayRestNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayAvanceNumPD(NumPD) ) == V_UNDEF )
          ArrayAvanceNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayDetectOverplusNumPD(NumPD) ) == V_UNDEF )
          ArrayDetectOverplusNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayGiveOutOverplusNumPD(NumPD) ) == V_UNDEF )
          ArrayGiveOutOverplusNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayDetectDeficitNumPD(NumPD) ) == V_UNDEF )
          ArrayDetectDeficitNumPD(NumPD) = 0;
       end;
       if( ValType( ArrayCompensateDeficitNumPD(NumPD) ) == V_UNDEF )
          ArrayCompensateDeficitNumPD(NumPD) = 0;
       end;
    END;
    /* обновление массивов с информацией о ПД */
    MACRO IncArrayPD( ArrPD, ArrNumPD, AllNumber, InOut, Transfer )
       VAR NumPayDoc, PD_ID;
       if( Transfer )/* признак операции аванс/передача/возврат */
          PD_ID = avanceop.PayDoc_Ref;
/*       else          /* валюто-обменная операция */
          PD_ID = paydocop.PayDoc_Ref;*/
       else          /* признак операции учета излишков/недостачи */
          PD_ID = deficitop.PD_Ref
       end;

       NumPayDoc = PutNumberInArray( ArrPD, PD_ID, AllNumber );
       SetParm( 2, AllNumber );
       if( ValType( ArrNumPD( NumPayDoc ) ) == V_UNDEF )
          ArrNumPD(NumPayDoc) = 0;
       end;
       /* учет суммы */
       if( InOut == FlagKredit )
          ArrNumPD(NumPayDoc) = ArrNumPD(NumPayDoc) + Operat.IncomeAmount;
       else
          ArrNumPD(NumPayDoc) = ArrNumPD(NumPayDoc) + Operat.OutAmount;
       end;
       /* инициализируем все массивы с суммами ПД */
       InitArraysPD( NumPayDoc );
       RetailSession.SetMinMaxDate();

       return NumPayDoc;
    END;

    if( GetParm( 0, TmpVar ) )
       NumDskRec = TmpVar;
    end;

 /* поиск и запись операций текущего кассира текущей смены */
 ClearRecord( Operat );
 Operat.Emp_Ref  = Sess.Emp_Ref;
 Operat.Sess_Ref = Sess.Number;

 if( GetGE( Operat ) )

   While( BreakLoop
          AND ( Operat.Emp_Ref   == Sess.Emp_Ref )
          AND ( Operat.Sess_Ref  == Sess.Number  )
        )
     if( (Operat.State_Ref == CDF_OperCompleted) OR (Operat.State_Ref == CDF_OperInReestr) )

        if(  /* любая валютно-обменная операция с ПД */
             ( Operat.Oper_Ref == CDF_OperPayDocBuy      ) OR
             ( Operat.Oper_Ref == CDF_OperPayDocSale     ) OR
             ( Operat.Oper_Ref == CDF_OperPayDocBuyCurr  ) OR
             ( Operat.Oper_Ref == CDF_OperPayDocSaleCurr )
          )
           /* наложение структуры paydocop на поле Operat.ExtInfo */
           SetRecordAddr( paydocop, Operat, 0, FldOffset( Operat, "ExtInfo" ), True );
        elif(
             ( Operat.Oper_Ref == CDF_OperAvance   ) OR
             ( Operat.Oper_Ref == CDF_OperCashOut  ) OR
             ( Operat.Oper_Ref == CDF_OperTransfer )
          )
           /* наложение структуры avanceop на поле Operat.ExtInfo */
           SetRecordAddr( avanceop, Operat, 0, FldOffset( Operat, "ExtInfo" ), True );
        elif( 
             ( Operat.Oper_Ref == CDF_OperDetectOverplus    ) OR
             ( Operat.Oper_Ref == CDF_OperDetectDeficit     ) OR
             ( Operat.Oper_Ref == CDF_OperGiveOutOverplus   ) OR
             ( Operat.Oper_Ref == CDF_OperCompensateDeficit )
          )
           /* наложение структуры deficit на поле Operat.ExtInfo */
           SetRecordAddr( deficitop, Operat, 0, FldOffset( Operat, "ExtInfo" ), True );
        end;
   
        /* аванс ПД */
        if(    ( Operat.Oper_Ref == CDF_OperAvance ) AND
               (
                  ( Operat.IncomeTrs_Ref == TrsCheck )       OR
                  ( Operat.IncomeTrs_Ref == TrsAccreditive )
               )
          )
            NumPD = IncArrayPD( ArrayPD, ArrayAvanceNumPD, NumberPD, FlagKredit, 1 ); 
        end;

        /* возврат ПД */
        if(    (
                  ( Operat.Oper_Ref == CDF_OperCashOut  ) OR
                  ( Operat.Oper_Ref == CDF_OperTransfer )
               ) AND
               (
                  ( Operat.OutTrs_Ref == TrsCheck )       OR
                  ( Operat.OutTrs_Ref == TrsAccreditive )
               )
          )
            NumPD = IncArrayPD( ArrayPD, ArrayRestNumPD, NumberPD, FlagDebet, 1 );
        end;

        /* обнаружение излишков */
        if(    (    Operat.Oper_Ref == CDF_OperDetectOverplus ) AND
               (
                  ( Operat.IncomeTrs_Ref == TrsCheck )       OR
                  ( Operat.IncomeTrs_Ref == TrsAccreditive )
               )
          )
            NumPD = IncArrayPD( ArrayPD, ArrayDetectOverplusNumPD, NumberPD, FlagKredit, 0 );
        end;

        /* возмещение недостачи */
        if(    (    Operat.Oper_Ref == CDF_OperCompensateDeficit ) AND
               (
                  ( Operat.IncomeTrs_Ref == TrsCheck )       OR
                  ( Operat.IncomeTrs_Ref == TrsAccreditive )
               )
          )
            NumPD = IncArrayPD( ArrayPD, ArrayCompensateDeficitNumPD, NumberPD, FlagKredit, 0 );
        end;
   
        /* выдача излишков */
        if(    (    Operat.Oper_Ref == CDF_OperGiveOutOverplus ) AND
               (
                  ( Operat.OutTrs_Ref == TrsCheck )       OR
                  ( Operat.OutTrs_Ref == TrsAccreditive )
               )
          )
            NumPD = IncArrayPD( ArrayPD, ArrayGiveOutOverplusNumPD, NumberPD, FlagDebet, 0 );
        end;

        /* отражение недостачи */
        if(    (    Operat.Oper_Ref == CDF_OperDetectDeficit ) AND
               (
                  ( Operat.OutTrs_Ref == TrsCheck )       OR
                  ( Operat.OutTrs_Ref == TrsAccreditive )
               )
          )
            NumPD = IncArrayPD( ArrayPD, ArrayDetectDeficitNumPD, NumberPD, FlagDebet, 0 );
        end;
   
        /*покупка ПД*/
        /*if( (                                                          */
        /*       ( Operat.Oper_Ref == CDF_OperPayDocBuy     ) OR         */
        /*       ( Operat.Oper_Ref == CDF_OperPayDocBuyCurr )            */
        /*    ) AND                                                      */
        /*    ( Operat.State_Ref == CDF_OperInReestr )                   */
        /*  )                                                            */
        /*    NumPD = IncArrayPD( ArrayPD, ArrayBuyNumPD, NumberPD, FlagKredit, 0 );*/
        /*end;                                                           */
   
        /*продажа ПД*/
        /*if( (                                                          */
        /*       ( Operat.Oper_Ref == CDF_OperPayDocSale     ) OR        */
        /*       ( Operat.Oper_Ref == CDF_OperPayDocSaleCurr )           */
        /*    ) AND                                                      */
        /*    ( Operat.State_Ref == CDF_OperInReestr )                   */
        /*  )                                                            */
        /*    NumPD = IncArrayPD( ArrayPD, ArraySaleNumPD, NumberPD, FlagDebet, 0 );*/
        /*end;                                                           */
     end;

     if( (Operat.Emp_Ref != Sess.Emp_Ref) OR (Operat.Sess_Ref != Sess.Number) )
        BreakLoop = False;/* для ускорения работы макроса */
     else
        BreakLoop = Next( Operat );
     end;

   end; /* while */
 end;

 /* если операционист покупал/продавал во время смены ПД */
 if( NumberPD )
    i = 0;
    While( i < NumberPD )
       /* заполнение записи по внебалансу для ПД данного вида */
/*       StandartInfoToNBDataFile();
       NBDataFile.RefValue    = RefValuePD;
       NBDataFile.TypeValue   = TypeValuePD;
       NBDataFile.CodIntValue = ArrayPD( i );/* код ПД */
*/
       /*всего продано ПД такого вида за смену - сумма*/
       /*NBDataFile.DebCol      = ArraySaleNumPD( i );               */
       /*if( NBDataFile.DebCol )                                     */
       /*   NumDskRec = RecordToDskRecFile( 0, NBDataFile.DebCol, OperationDebet, TypeValuePD, ArrayPD( i ), ArrayPD( i ), 0, FlagDebet, NumDskRec );*/
       /*end;                                                        */
       /*всего куплено/получено ПД такого вида за смену - сумма*/
       /*NBDataFile.KredCol      = ArrayBuyNumPD( i );               */
       /*if( NBDataFile.KredCol )                                    */
       /*   NumDskRec = RecordToDskRecFile( 0, NBDataFile.AdvCol, OperationKredit, TypeValuePD, ArrayPD( i ), ArrayPD( i ), 0, FlagKredit, NumDskRec );*/
       /*end;                                                        */

       /* сумма ПД, оставшихся в конце смены (возврат) */
/*       NBDataFile.IncasCol    = ArrayRestNumPD( i );
       if( NBDataFile.IncasCol )
          NumDskRec = RecordToDskRecFile( 0, NBDataFile.IncasCol, OperationIncass, TypeValuePD, ArrayPD( i ), ArrayPD( i ), 0, FlagDebet, NumDskRec );
       end;
       /* сумма ПД, авансированных за смену (аванс) */
       NBDataFile.AdvCol    = ArrayAvanceNumPD( i );
       if( NBDataFile.AdvCol )
          NumDskRec = RecordToDskRecFile( 0, NBDataFile.AdvCol, OperationAvance, TypeValuePD, ArrayPD( i ), ArrayPD( i ), 0, FlagKredit, NumDskRec );
       end;
*/
       /* сумма отраженных излишков ПД  (в NBData не заносим) */
       Amount = ArrayDetectOverplusNumPD( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationKredit, TypeValuePD, ArrayPD( i ), ArrayPD( i ), SubOperDetectOverplus, FlagKredit, NumDskRec );
       end;
       /* сумма возмещенной недостачи ПД  (в NBData не заносим) */
       Amount = ArrayCompensateDeficitNumPD( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationKredit, TypeValuePD, ArrayPD( i ), ArrayPD( i ), SubOperCompensateDeficit, FlagKredit, NumDskRec );
       end;
       /* сумма выданных излишков ПД (в NBData не заносим) */
       Amount = ArrayGiveOutOverplusNumPD( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationDebet, TypeValuePD, ArrayPD( i ), ArrayPD( i ), SubOperGiveOutOverplus, FlagDebet, NumDskRec );
       end;
       /* сумма отраженной недостачи ПД   (в NBData не заносим) */
       Amount = ArrayDetectDeficitNumPD( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationDebet, TypeValuePD, ArrayPD( i ), ArrayPD( i ), SubOperDetectDeficit, FlagDebet, NumDskRec );
       end;

/*       NumRec = InsertWithCheck( NBDataFile, NameNBDataFile, NumRec );*/
       i = i + 1;
    end;
 end;

 SetParm( 0, NumDskRec );

 return NumRec;
END; */
/*AV 20-11-98*/
/***************************************************************************/
/* процедура заносит информацию по АВАНСУ и ИНКАССАЦИИ ВАЛЮТ в транс.файлы */
/* - NumDeskRecords используется для возврата кол-ва записей в DskRecFile  */
/***************************************************************************/
MACRO DnLoadAvanceIncassCurrForRetail( /*NumDeskRecords*/ )
  VAR NumRec = 0,
      BreakLoop = TRUE, ercode, ertext,
      TmpVar, Amount,
      NumDskRec = 0,/* выгружено записей в DskRecFile (desk_rec.dbt) */
      NumCurr = 0,
      i;
  
    /* инициализация всех массивов сумм аванса и инкассо для определ. валюты */
    MACRO InitArraysCurr( Num )
       if( ValType( ArrayAvanceSumCurr(Num) ) == V_UNDEF )
          ArrayAvanceSumCurr(Num) = 0;
       end;
       if( ValType( ArrayIncassSumCurr(Num) ) == V_UNDEF )
          ArrayIncassSumCurr(Num) = 0;
       end;
       if( ValType( ArrayDetectOverplusSumCurr(Num) ) == V_UNDEF )
          ArrayDetectOverplusSumCurr(Num) = 0;
       end;
       if( ValType( ArrayGiveOutOverplusSumCurr(Num) ) == V_UNDEF )
          ArrayGiveOutOverplusSumCurr(Num) = 0;
       end;
       if( ValType( ArrayDetectDeficitSumCurr(Num) ) == V_UNDEF )
          ArrayDetectDeficitSumCurr(Num) = 0;
       end;
       if( ValType( ArrayCompensateDeficitSumCurr(Num) ) == V_UNDEF )
          ArrayCompensateDeficitSumCurr(Num) = 0;
       end;
    END;
    /* обновление массивов с информацией о суммах аванса/инкассации */
    MACRO IncArrayCurr( ArrCurr, ArrSumCurr, AllNumber, InOut )
       VAR Num, CurrRef;
       if( InOut == FlagKredit )
          CurrRef = Operat.IncomeCurr_Ref;
       else
          CurrRef = Operat.OutCurr_Ref;
       end;
       Num = PutNumberInArray( ArrCurr, CurrRef, AllNumber );
       SetParm( 2, AllNumber );
       if( ValType( ArrSumCurr( Num ) ) == V_UNDEF )
          ArrSumCurr(Num) = 0;
       end;
       /* учет суммы */
       if( InOut == FlagKredit )
          ArrSumCurr(Num) = ArrSumCurr(Num) + Operat.IncomeAmount;
       else
          ArrSumCurr(Num) = ArrSumCurr(Num) + Operat.OutAmount;
       end;
       /* инициализируем все массивы с суммами аванса-возврата валют */
       InitArraysCurr( Num );
       RetailSession.SetMinMaxDate();

       return NumCurr;
    END;

    if( GetParm( 0, TmpVar ) )
       NumDskRec = TmpVar;
    end;

 /* поиск и запись операций текущего кассира текущей смены */
 ClearRecord( Operat );
 Operat.Emp_Ref  = Sess.Emp_Ref;
 Operat.Sess_Ref = Sess.Number;

 if( GetGE( Operat ) )
  While( BreakLoop
         AND ( Operat.Emp_Ref   == Sess.Emp_Ref )
         AND ( Operat.Sess_Ref  == Sess.Number  )
       )

     if( (Operat.State_Ref == CDF_OperCompleted) OR (Operat.State_Ref == CDF_OperInReestr) )
        /* аванс валюты */
        if(    ( Operat.Oper_Ref == CDF_OperAvance ) AND
               (
                  ( Operat.IncomeTrs_Ref == TrsCash )       OR
                  ( Operat.IncomeTrs_Ref == TrsMonet )
               )
          )
            NumCurr = IncArrayCurr( ArrayCurr, ArrayAvanceSumCurr, NumberCurr, FlagKredit );
        end;
        /* возврат валюты */
        if(    (
                  ( Operat.Oper_Ref == CDF_OperCashOut  ) OR
                  ( Operat.Oper_Ref == CDF_OperTransfer )
               ) AND
               (
                  ( Operat.OutTrs_Ref == TrsCash )       OR
                  ( Operat.OutTrs_Ref == TrsMonet )
               )
          )
            NumCurr = IncArrayCurr( ArrayCurr, ArrayIncassSumCurr, NumberCurr, FlagDebet );
        end;
        /* отражение излишков */
        if(    ( Operat.Oper_Ref == CDF_OperDetectOverplus ) AND
               (
                  ( Operat.IncomeTrs_Ref == TrsCash )       OR
                  ( Operat.IncomeTrs_Ref == TrsMonet )
               )
          )
            NumCurr = IncArrayCurr( ArrayCurr, ArrayDetectOverplusSumCurr, NumberCurr, FlagKredit );
        end;
        /* возмещение недостачи */
        if(    ( Operat.Oper_Ref == CDF_OperCompensateDeficit ) AND
               (
                  ( Operat.IncomeTrs_Ref == TrsCash )       OR
                  ( Operat.IncomeTrs_Ref == TrsMonet )
               )
          )
            NumCurr = IncArrayCurr( ArrayCurr, ArrayCompensateDeficitSumCurr, NumberCurr, FlagKredit );
        end;
        /* выдача излишков */
        if(    ( Operat.Oper_Ref == CDF_OperGiveOutOverplus ) AND
               (
                  ( Operat.OutTrs_Ref == TrsCash )       OR
                  ( Operat.OutTrs_Ref == TrsMonet )
               )
          )
            NumCurr = IncArrayCurr( ArrayCurr, ArrayGiveOutOverplusSumCurr, NumberCurr, FlagDebet );
        end;
        /* отражение недостачи */
        if(    ( Operat.Oper_Ref == CDF_OperDetectDeficit ) AND
               (
                  ( Operat.OutTrs_Ref == TrsCash )       OR
                  ( Operat.OutTrs_Ref == TrsMonet )
               )
          )
            NumCurr = IncArrayCurr( ArrayCurr, ArrayDetectDeficitSumCurr, NumberCurr, FlagDebet );
        end;
     end;

     if( (Operat.Emp_Ref != Sess.Emp_Ref) OR (Operat.Sess_Ref != Sess.Number) )
        BreakLoop = False;/* для ускорения работы макроса */
     else
        BreakLoop = Next( Operat );
     end;

  end;
 end;
 /* если операционист получал/сдавал валюту во время смены */
/*
 if( NumberCurr )
    i = 0;
    While( i < NumberCurr )
       /* заполнение записи по внебалансу для данной валюты */
       StandartInfoToNBDataFile();
       NBDataFile.RefValue    = RefValueCurr;
       NBDataFile.TypeValue   = TypeValueCurr;
       /* внутренний код валюты Retail */
       NBDataFile.CodIntValue = GetCurrRetail( ArrayCurr( i ) );

       /* сумма, инкассированная за смену (возврат) */
       NBDataFile.IncasCol    = ArrayIncassSumCurr( i );
       if( NBDataFile.IncasCol )
          NumDskRec = RecordToDskRecFile( 0, NBDataFile.IncasCol, OperationIncass, TypeValueCurr, NBDataFile.CodIntValue, ArrayCurr( i ), 0, FlagDebet, NumDskRec );
       end;
       /* сумма, авансированная за смену (аванс) */
       NBDataFile.AdvCol    = ArrayAvanceSumCurr( i );
       if( NBDataFile.AdvCol )
          NumDskRec = RecordToDskRecFile( 0, NBDataFile.AdvCol, OperationAvance, TypeValueCurr, NBDataFile.CodIntValue, ArrayCurr( i ), 0, FlagKredit, NumDskRec );
       end;
       /* сумма отраженных излишков валюты    (в NBData не заносим) */
       Amount = ArrayDetectOverplusSumCurr( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationKredit, TypeValueCurr, NBDataFile.CodIntValue, ArrayCurr( i ), SubOperDetectOverplus, FlagKredit, NumDskRec );
       end;
       /* сумма возмещенной недостачи валюты  (в NBData не заносим) */
       Amount = ArrayCompensateDeficitSumCurr( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationKredit, TypeValueCurr, NBDataFile.CodIntValue, ArrayCurr( i ), SubOperCompensateDeficit, FlagKredit, NumDskRec );
       end;
       /* сумма выданных излишков валюты      (в NBData не заносим) */
       Amount = ArrayGiveOutOverplusSumCurr( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationDebet, TypeValueCurr, NBDataFile.CodIntValue, ArrayCurr( i ), SubOperGiveOutOverplus, FlagDebet, NumDskRec );
       end;
       /* сумма отраженной недостачи валюты   (в NBData не заносим) */
       Amount = ArrayDetectDeficitSumCurr( i );
       if( Amount )
          NumDskRec = RecordToDskRecFile( 0, Amount, OperationDebet, TypeValueCurr, NBDataFile.CodIntValue, ArrayCurr( i ), SubOperDetectDeficit, FlagDebet, NumDskRec );
       end;

       NumRec = InsertWithCheck( NBDataFile, NameNBDataFile, NumRec );
       i = i + 1;
    end;
 end;
*/
 SetParm( 0, NumDskRec );

 return NumRec;
END;

/* конверсия валютной мелочи */
MACRO DnLoadCnvForRetail()

  var NumRec = 0, BreakLoop = TRUE, ercode, ertext, Skip;
  /* поиск реестров текущего кассира текущей смены */
  ClearRecord( Reestr );
  Reestr.ExchangeNumber = office.ID;
  Reestr.Emp_Ref        = Sess.Emp_Ref;
  Reestr.Sess_Ref       = Sess.Number;

  if( GetGE( Reestr ) )
    While( BreakLoop
           AND (Reestr.Emp_Ref == Sess.Emp_Ref)
           AND (Reestr.Sess_Ref== Sess.Number )
         )

       Skip = FillCnvCoinFile(); /* заполним данные по конвертации валютной мелочи */

       if( NOT Skip )
         if( NOT Insert(CnvFile) )
           ercode = status(ertext);
           println("Ошибка ", ercode," ", ertext, ": " + NameCnvFile );
           BreakLoop = FALSE;
         else
           NumRec = NumRec + 1;
           BreakLoop = Next( Reestr );
         end;
       else
         BreakLoop = Next( Reestr );
       end;

    end;
  end;

  return NumRec;
END;

/***************************************************************************/
/* Функция формирует транспортные файлы с информацией о смене session      */
/*   для Retail                                                            */
/*   транспортные файлы:                                                   */
/* NN 9999 99.dbt - файл с описанием выгружаемых dbt-файлов                */
/* NN 9999 16.dbt - файл с информацией по реестрам одной смены             */
/* NN 9999 11.dbt - файл с информацией по внебалансу                       */
/* NN   - номер ОП                                                         */
/* 9999 - циклический номер рабочей смены в ОП, при превышении 9999 отсчет */
/*        начинается сначала (0001)                                        */
/***************************************************************************/
MACRO DnLoadInfoForRetail()
 VAR NumRec    = 0, /* количество записей в info-файле */
     NumRstr   = 0, /* количество выгруженных реестров                 */
     NumNBData = 0, /* количество выгруженных внебалансовых записей    */
     NumDskRec = 0, /* количество записей по справкам БСО и ПД         */
     NumCnv    = 0; /* количество записей по конверсии валютной мелочи */

 if( (CreateTransportFile( InfoFile,   TemplInfoFile,   NameInfoFile   ) == True) AND
     (CreateTransportFile( RstrFile,   TemplRstrFile,   NameRstrFile   ) == True) AND
     /*(CreateTransportFile( DskRecFile, TemplDskRecFile, NameDskRecFile ) == True) AND*/
     (CreateTransportFile( CnvFile,    TemplCnvFile,    NameCnvFile    ) == True)
   )
/*     (CreateTransportFile( NBDataFile, TemplNBDataFile, NameNBDataFile ) == True ) )*/

    /* баланс - реестры о/п */
    NumRstr    =   DnLoadRstrForRetail();
    /* в инфо-файл о выгрузке */
    UpdateInfoFile( NameRstrFile, NumExchRstrFile, NumRstr, "Реестры ОП" );

    /* реестры */
    if( NumRstr == 0 )
       println( "Не выгружено ни одной записи по реестрам." );
       DelTransportFile( RstrFile );
    else
       NumRec = NumRec + 1;
       println( NameRstrFile + " (реестры) "
                + " выгружено записей: " + string(NumRstr) );
    end;

    /* внебаланс - справки БСО */
    /*NumNBData  = NumNBData + DnLoadSprvForRetail( NumDskRec );*/
    /* AV 20-11-98 */
    /* внебаланс - ПД - авансы и инкассация */
    NumNBData  = NumNBData + DnLoadPayDocForRetail( NumDskRec );
    /* внебаланс - валюты - авансы и инкассация */
    NumNBData  = NumNBData + DnLoadAvanceIncassCurrForRetail( NumDskRec );
    /* в инфо-файл о выгрузке */
/*    UpdateInfoFile( NameDskRecFile, NumExchDskRecFile, NumDskRec, "ОП: справки БСО и ПД" );*/
/*    UpdateInfoFile( NameNBDataFile, NumExchNBDataFile, NumNBData, "ОП: дополн-ный внебаланс" );*/

    /* внебаланс */
/*    if( NumNBData == 0 )
       println("Не выгружено ни одной записи по справкам.");
       DelTransportFile( NBDataFile );
    else
       NumRec = NumRec + 1;
       println( NameNBDataFile + " (внебаланс) "
                + " выгружено записей: " + string(NumNBData) );
    end;
*/
    /* дополнительная информация по внебалансу */
/*
    if( NumDskRec == 0 )
       println("Не выгружено ни одной записи desk_rec.dbt",);
       DelTransportFile( DskRecFile );
    else
       NumRec = NumRec + 1;
       println( NameDskRecFile + " (доп. по внебалансу) "
                + " выгружено записей: " + string(NumDskRec) );
    end;
*/

    /* конверсия валютной мелочи */
    NumCnv = DnLoadCnvForRetail();
    UpdateInfoFile( NameCnvFile, NumExchCnvFile, NumCnv, "ОП: конверсия мелочи" );

    if( NumCnv == 0 )
       println( "Не выгружено ни одной записи по конверсии валютной мелочи" );
       DelTransportFile( CnvFile );
    else
       NumRec = NumRec + 1;
       println( NameCnvFile + " (конв. мелочи) "
                + " выгружено записей: " + string(NumCnv) );
    end;

    /* инфо-файл с иформацией о выгрузке */
    if( (NumNBData == 0) AND (NumRstr == 0) AND (NumCnv == 0) )
       println("Не выгружено ни одной записи в файл с информацией о выгрузке " + NameInfoFile);
       DelTransportFile( InfoFile );
    else
       println( NameInfoFile + " (информация о выгрузке) "
                + " выгружено записей: ", NumRec );
    end;
    Close( InfoFile   );
    Close( RstrFile   );
/*    Close( NBDataFile );*/
/*    Close( DskRecFile );*/
    Close( CnvFile    );
 else
    ReActionForErrorCreate( InfoFile,    NameInfoFile   );
    ReActionForErrorCreate( RstrFile,    NameRstrFile   );
/*    ReActionForErrorCreate( NBDataFile,  NameNBDataFile );*/
/*    ReActionForErrorCreate( DskRecFile,  NameDskRecFile );*/
    ReActionForErrorCreate( CnvFile,     NameCnvFile    );
 end;

 return NumRstr + NumNBData + NumCnv;
END;

/* 11.10.2000 VS Вынес в класс ф-ции работы с сессией Retail. */
class clRetailSession()
  /* private */
  var sb_sess = TBFile( "sb_sesn.dbt", "W", 0, NULL, "sbbank.def" );

  const SESSION_INITIALIZED = 0,
        SESSION_CREATED     = 1,
        SESSION_SENDED      = 2,
        SESSION_CONFIRMED   = 3;

  var MinDocDate = date(),       /* Min и max даты документов, входящих */
      MaxDocDate = date(0,0,0);  /* в выгружаемую сессию Retail.        */

  /* public  */
  var RetVal;
  var Number = 0;

  macro SetMinMaxDate()
    if( operat.date < this.MinDocDate ) this.MinDocDate = operat.date; end;
    if( operat.date > this.MaxDocDate ) this.MaxDocDate = operat.date; end;
  end;

  /* Завершение сессии */
  macro Complete()
    sb_sess.rec.StateSess    = SESSION_SENDED; /* Состояние сессии      */
    sb_sess.rec.MinSBDocDate = MinDocDate;     /* Диапазон              */
    sb_sess.rec.MaxSBDocDate = MaxDocDate;     /*      дат документов   */

    if( not (RetVal = update( sb_sess )) )
      msgbox( "Ошибка при завершении сессии Retail № ", this.Number, "!" );
    end;
    return RetVal;
  end;

  /* Конструктор */
  if( nrecords( sb_sess ) )
    if( (Retval = prev(sb_sess)) )
      Number = sb_sess.rec.NumSession + 1;
    else
      msgbox( "Ошибка при получении последней сессии выгрузки Retail!" );
      return;
    end;
  end;

  ClearRecord( sb_sess );
  sb_sess.rec.NumSession   = this.Number;         /* Номер сессии          */
  sb_sess.rec.FNcash       = Office.ID;           /* Номер филиала         */
  sb_sess.rec.Sesdate      = date();              /* Дата создания сессии  */
  sb_sess.rec.Sestime      = time();              /* Время создания сессии */
  sb_sess.rec.StateSess    = SESSION_INITIALIZED; /* Состояние сессии      */

  if( not (RetVal = insert( sb_sess )) )
    msgbox( "Ошибка при создании записи о ", this.Number, " сесии Retail!" );
  end;

end;

/****************************************************************************/
/*  Процедура вызывается из СИ для выгрузки информации по смене в транспорт.*/
/*   файлы                                                                  */
/****************************************************************************/
MACRO DnLoad( SessAddr )
  SetBuff( Sess, SessAddr ); /* Sess указывает на текущую смену */

  /* 11.10.2000 VS !Все это только ради записи сессии в файл Retail. */
  if( not( ExInRetail and {UseRetailBase} ) )
     msgbox( "Выгрузка в транспортные файлы Retail осуществляется ТОЛЬКО|" +
             "в ОП, собранном для Retail, при установке настройки" + 
             "\"Работа на общих базах\"!" + 
             "Проверьте Ваши настройки или исправьте макрос transprt.mac." 
           );
     return;
  end;

  RetailSession = clRetailSession();
  if( not RetailSession.RetVal )
     return;
  end;

  /* выгрузка информации для Retail */
  if( DnLoadInfoForRetail() == 0 )
     MsgBox( "Информации для выгрузки в транспортные файлы нет!" );
  else
     /* 9.10.2000 VS Добавим запись в справочник сессий выгрузки. */
     if( RetailSession.Complete() )
        if( GetIniString( "ARCHTRANSPORT", "exchange.ini", FALSE ) == "ON" )
           ArcSession( Office.ID, Sess.Number );
        end;
     end;
  end;
END;
*/