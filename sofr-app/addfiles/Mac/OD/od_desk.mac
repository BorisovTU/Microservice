
/*
**  Опердневник ф.24. Работа с кассой
**
*/

import od_com, od_total, cvsettng, docbunch, sqlconv;

class TDesk

  var
    safe, 
    cashAcc = TBFile( "sb_casac.dbt", "r", 2 ), 
    cashLink = TBFile( "sb_casln.dbt", "r", 1 ), 
    cashVal = TBFile( "sb_casvl.dbt", "r" ), 
    deskSubj = TBFile( "desksubj.dbt", "r", 0 ), 
    cashDoc = TBFile( "sb_casdc.dbt", "r" ), 
    subOp = TBFile( "dsuboper.dbt", "r", 0 ), 
    bunch = TDocBunch; 

  macro getSubOpName
  
    subOp.rec.Branch = NumFNcash();
    subOp.rec.OperType = cashDoc.rec.NumOper;
    subOp.rec.Type = cashDoc.rec.SubOper;
    if ( subOp.getEQ )
      return " (" + subOp.rec.Name + ")";
    else
      return "";
    end;
  end;

  macro findDeskSubj( name )

    deskSubj.rec.Branch = branch;
    deskSubj.rec.Name = name;
    return deskSubj.getEQ;
  end; 

  macro findCashValueForRef( ref )

    cashVal.keyNum = 0;
    cashVal.rec.RefValue = ref;
    return cashVal.getEQ;
  end;  

  macro findCashValueForCode( type, vType, vCode )

    cashVal.keyNum = 1;
    cashVal.rec.Type = type;
    cashVal.rec.TypeValue = vType;
    cashVal.rec.CodIntValue = vCode;
    return cashVal.getEQ;
  end;

  macro getNativeGroupAndSafe
  
    safe = "";
    if ( findGroup( operBrigade ) )
      if ( group.rec.Mode != GRM_IMMEDIATE )
        safe = group.rec.SafeID; 
        if ( not findDeskSubj( safe ) )
          exitOnError( "Не найден сейф: " + safe );
        end;           
      end;
    else
      exitOnError( "Не найдена смена №" + OperBrigade );
    end;
  end;

  macro valIsShown

    record tmpCashVal( "sb_casvl.dbt" );

    copy( tmpCashVal, cashVal.rec );
    if ( not findCVSettings( tmpCashVal ) )
      return true;
    end;
    return cvSettings.Form24 != strFor( 0 );
  end;
  
  macro valIsKept
  
    record tmpCashVal( "sb_casvl.dbt" );

    copy( tmpCashVal, cashVal.rec );
    if ( not findCVSettings( tmpCashVal ) )
      return true;
    end;
    return cvSettings.KeepRests != strFor( 0 );
  end;
  
  macro shouldAddValRestToTotals( isPrev )
  
    var
      shown,
      kept;
  
    record tmpCashVal( "sb_casvl.dbt" );

    copy( tmpCashVal, cashVal.rec );
    if ( not findCVSettings( tmpCashVal ) )
      return true;
    end;
  
    shown = cvSettings.Form24 != StrFor( 0 );
    kept  = cvSettings.KeepRests != StrFor( 0 ); 
  
    if ( not shown )
      return false;
    end;
  
    if ( kept )
      return true;
    else
      if ( isPrev )
        return false;
      else
        return true;
      end; 
    end;
  end;              

  macro makeValRestsExistCond

     return  "exists ( select a.t_Branch from dsb_casac_dbt a " + 
             " where a.t_Branch = " + string( Branch ) + 
	     "   and a.t_CashOper = " + GetSQLString( safe ) + 
	     "   and a.t_SubAccount = " + GetSQLString( "" ) +
	     "   and a.t_RefValue = t.t_RefValue )";
  end;

  macro getValNativeCurr
  
    var                
      sk, pos, 
      nativeCurr;
  
    if ( cashVal.rec.TypeValue == TYPERES_CURRENCY )
      nativeCurr = cashVal.rec.CodIntValue;
    else
      if ( cashVal.rec.GroupValue == 0 )
        nativeCurr = NATIONAL_CURR;
      else       
        pos = cashVal.getPos;
        sk = cashVal.keyNum;
        if ( not findCashValueForRef( cashVal.rec.GroupValue ) )
          exitOnBtError( "Не найдена ценность с кодом " + cashVal.rec.GroupValue )
        end; 
        if ( cashVal.rec.TypeValue == TYPERES_CURRENCY )
          nativeCurr = cashVal.rec.CodIntValue;
        elif( cashVal.rec.TypeValue == TYPERES_PAYDOC )
          pd.rec.ID = cashVal.rec.CodIntValue;
          if( pd.getEQ )
            nativeCurr = pd.rec.Curr_Ref; 
          else
            exitOnBtError( "Не найден платежный документ с кодом " + cashVal.rec.CodIntValue );
          end;
        else
          nativeCurr = NATIONAL_CURR;
        end;       
        cashVal.keyNum = sk;
        cashVal.getDirect( pos );
      end;                  
    end;

    return nativeCurr;
  end;

  macro getValNativeCurr2( ref )

    if ( findCashValueForRef( ref ) )
      return getValNativeCurr;
    end;
    return ANY_CURR; 
  end;

  macro getValRest( date, isPrev )
  
    var 
      rest = $0;

    if ( isPrev and mode )
      date = date + 1;
    end; 
 
    if ( shouldAddValRestToTotals( isPrev ) )
      cashAcc.addFilter( "t.t_Branch = " + string( Branch ) + 
			 " and t.t_CashOper = " + GetSQLString( safe ) + 
			 " and t.t_SubAccount = " + GetSQLString( "" ) +
			 " and t.t_RefValue = " + string(cashVal.rec.RefValue) );
      cashAcc.clear;
      cashAcc.rec.Branch = Branch;
      cashAcc.rec.CashOper = safe;
      cashAcc.rec.SubAccount = "";
      cashAcc.rec.RefValue = cashVal.rec.RefValue;
      cashAcc.rec.Date     = date;
      if ( cashAcc.getLE
        and ( cashAcc.rec.Branch == Branch )
        and ( cashAcc.rec.CashOper == safe )
        and ( cashAcc.rec.SubAccount == "" )
        and ( cashAcc.rec.RefValue == cashVal.rec.RefValue ) )
        if ( cashAcc.rec.RestMoney != $0 ) 
          rest = cashAcc.rec.RestMoney;
        else
          rest = $1 * cashAcc.rec.RestCol;
        end;
      end;
      cashAcc.dropFilter();
    end;
  
    return rest;
  end;

  macro getMoneyRestForType( vType, type, date, isPrev, rest )

    var
      recFound;
      
    rest = $0;
  
    if ( vType == TYPERES_CURRENCY )
      if( findCashValueForCode( type, vType, currency.rec.Code_Currency ) )
        rest = getValRest( date, isPrev );
      end;
    elif ( vType == TYPERES_PAYDOC )
      cashVal.keyNum = 3;
      cashVal.clear;
      cashVal.rec.Type = type;
      cashVal.rec.TypeValue = vType;

      cashVal.addFilter( "t_Type = " + string( type ) +
                         " and t_TypeValue = " + string( vType ) );

      recFound = cashVal.getGE;
      while ( recFound
        and ( cashVal.rec.Type == type )
        and ( cashVal.rec.TypeValue == vType ) )
        cashVal.AddFilter("");
        if ( getValNativeCurr == currency.rec.Code_Currency )
          rest = rest + getValRest( date, IsPrev );
        end; 
        cashVal.dropFilter;
        RecFound = cashVal.next;
      end;
      cashVal.dropFilter;
    end;
    setParm( 5, rest );
  end;

  macro getMoneyRestInCoins( date, IsPrev, rest )
  
    var
      recFound;

    cashVal.keyNum = 3;
    cashVal.clear;
    cashVal.rec.Type = TYPE_RES_PAY;
    cashVal.rec.TypeValue = TYPERES_MINCAPISSUE + CI_COIN;

    cashVal.addFilter( "t_Type = " + string( TYPE_RES_PAY ) +
                       " and t_TypeValue = " + string( TYPERES_MINCAPISSUE + CI_COIN ) +
                       " and " + makeValRestsExistCond );

    recFound = cashVal.getGE;
    while ( recFound
      and ( cashVal.rec.Type == TYPE_RES_PAY )
      and ( cashVal.rec.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) )
      if ( not isCoinOld( cashVal.rec.CodIntValue ) )
        rest = rest + getValRest( date, IsPrev );
      end;
      RecFound = cashVal.next;
    end;
    cashVal.dropFilter;
    setParm( 3, rest );
  end; 

  macro getMoneyRest( type, date, isPrev, rest, coinRest )
  
    var
      tmp;

    rest = $0;
    coinRest = $0;
      
    if( type == TYPE_RES_PAY )
      getMoneyRestForType( TYPERES_CURRENCY, TYPE_RES_PAY, date, isPrev, tmp );
      rest = rest + tmp;
      getMoneyRestForType( TYPERES_PAYDOC, TYPE_RES_PAY, date, isPrev, tmp );
      rest = rest + tmp;
      if ( currency.rec.Code_Currency == 0 )
        getMoneyRestInCoins( date, IsPrev, coinRest );
        rest = rest + coinRest;
      end;
    else
      getMoneyRestForType( TYPERES_CURRENCY, TYPE_RES_NOPAY, date, isPrev, tmp );
      rest = rest + tmp;
      getMoneyRestForType( TYPERES_PAYDOC, TYPE_RES_NOPAY, date, isPrev, tmp );
      rest = rest + tmp;
      /* RA 31-07-02 SCR 9585
      getMoneyRestForType( TYPERES_PAYDOC, TYPE_RES_PDNAT, date, isPrev, tmp );
      rest = rest + tmp;
      getMoneyRestForType( TYPERES_PAYDOC, TYPE_RES_PDCUR, date, isPrev, tmp );
      rest = rest + tmp;
      getMoneyRestForType( TYPERES_PAYDOC, TYPE_RES_PD   , date, isPrev, tmp );
      rest = rest + tmp;
      */
    end;
    setParm( 4, rest );
    setParm( 5, coinRest );
  end;

  macro isVal

    if ( cashVal.rec.TypeValue == TYPERES_CURRENCY )
      if ( ( cashVal.rec.Type == TYPE_RES_PAY ) 
        or ( cashVal.rec.Type == TYPE_RES_NOPAY ) ) 
        return false;
      end;
    elif ( cashVal.rec.TypeValue == TYPERES_PAYDOC )
      if ( ( cashVal.rec.Type == TYPE_RES_NOPAY ) 
        or ( cashVal.rec.Type == TYPE_RES_PAY   ) 
        /* RA 31-07-02 SCR 9585
        or ( cashVal.rec.Type == TYPE_RES_PDNAT )  
        or ( cashVal.rec.Type == TYPE_RES_PDCUR ) 
        or ( cashVal.rec.Type == TYPE_RES_PD    ) ) */
       /* KIN 11-03-04 - все вернул назад - чеки дор. неправильно считаются */
        or ( cashVal.rec.Type == TYPE_RES_PDNAT )  
        or ( cashVal.rec.Type == TYPE_RES_PDCUR ) 
        or ( cashVal.rec.Type == TYPE_RES_PD    ) ) 

        return false;
      end;
    elif ( cashVal.rec.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) 
      if ( not isCoinOld( cashVal.rec.CodIntValue ) )
        return false;
      end;
    end;
    return true;
  end;

  macro getValuesTurnsForOp( appKind, appKey, credit, debet, creditCV, debetCV )
  
    macro thereAreNoBetterPrimary( appKind, appKey, 
                                   headAppKind, headAppKey,  
                                   primAppKind, primAppKey );
    
      /* Документ-родитель - лучший primary */

      if ( ( appKind == primAppKind ) and ( appKey == primAppKey ) )
        return true;
      end;
    
      /* Если есть документ_БП-родитель,  то он есть better primary */
  
      cashLink.rec.ApplicationKind2 = appKind;
      cashLink.rec.ApplicationKey2 = appKey;
      cashLink.rec.RefValue2 = 0;
      if ( cashLink.getEQ )
        return false;
      end;

      /* Если существует документ БП во главе связки - всех бездомных относим к нему */

      cashLink.rec.ApplicationKind2 = headAppKind;
      cashLink.rec.ApplicationKey2 = headAppKey;
      cashLink.rec.RefValue2 = 0;
      if ( cashLink.getEQ )
        return ( headAppKind == primAppKind ) and ( headAppKey == primAppKey );
      end;

      return true;
    end;

    var          
      recFound,
      cred, deb;

    credit = debet = creditCV = debetCV = $0;
  
    bunch._init( appKind, appKey );
    cashDoc.keyNum = 7;
    cashLink.keyNum = 1;

    recFound = bunch.firstDoc; 
    while ( recFound )
      if ( bunch.docValueRef
           and thereAreNoBetterPrimary( bunch.docAppKind, bunch.docAppKey, 
                                        bunch.headAppKind, bunch.headAppKey, 
                                        appKind, appKey ) )
        cashDoc.rec.ApplicationKind = bunch.docAppKind;
        cashDoc.rec.ApplicationKey = bunch.docAppKey;
        cashDoc.rec.RefValue = bunch.docValueRef;
        if ( cashDoc.getEQ )
          if( cashDoc.rec.TypeDoc == TYPEDOC_CARRYON )
            if ( not findCashValueForRef( cashDoc.rec.RefValue ) )
              exitOnBtError( "Не найдена ценность с кодом " + cashDoc.rec.RefValue );
            end;
            if ( isVal ) 
              if ( valIsShown )
                cred = deb = $0;
                if ( cashDoc.rec.FlagDebCredOper == FLAGDEBCRED_IN )
                  if ( cashVal.rec.UnitMeas == RESMESUNIT_POINT )
                    cred = $1 * cashDoc.rec.ValueCol;
                  else
                    cred = cashDoc.rec.ValueMoney;
                  end;
                else
                  if ( cashVal.rec.UnitMeas == RESMESUNIT_POINT )
                    deb = $1 * cashDoc.rec.ValueCol;
                  else
                    deb = cashDoc.rec.ValueMoney;
                  end;
                end;
                if ( ( cashDoc.rec.NumOper == CASHOP_CHVALUE )
                  or ( cashDoc.rec.NumOper == CASHOP_CHVALUE_1 ) )
                  creditCV = creditCV + cred; 
                  debetCV = debetCV + deb;
                else
                  credit = credit + cred; 
                  debet = debet + deb;
                end;
              end;
            end;
          end;
        end;
      end; 
      recFound = bunch.nextDoc;
    end;

    SetParm( 3, credit );
    SetParm( 4, debet );
    SetParm( 5, creditCV );
    SetParm( 6, debetCV );
  end;

  macro getValuesRest( date, isPrev, rest )

    message( "Сбор данных: Остатки Кассы" );

    rest = $0;

    cashVal.keyNum = 0;
    cashVal.rewind;
    cashVal.addFilter( makeValRestsExistCond );
    while ( cashVal.Next )
      if ( isVal )
        rest = rest + getValRest( date, IsPrev );
      end;
    end;
    cashVal.dropFilter;
    setParm( 3, rest );

    message( "" );
  end; 

  macro writeMoneyRestsForType( oper, unpay )

    var
      v = TRecHandler( "od_data.2" );

    var
      rest, 
      coinRest,  
      stOfs = 0,
      rType = TYPE_RES_PAY;

    if ( unpay )
      stOfs = ODSTT_UNPAY_OFFS;
      rType = TYPE_RES_NOPAY;
    end;

    v.setRecordAddr( odData );
        
    getMoneyRest( rType, {curdate} - 1, true, rest, coinRest );
    if ( rest != $0 )
      initDataRec( ODT_TOTAL, stOfs + ODSTT_PREV_REST, currency.rec.Code_Currency );
      v.clear;
      v.rec.Credit = rest;
      if ( currency.rec.Code_Currency != 0 ) 
        v.rec.CreditR = cur2rub( rest );
      end;
      odData.insert( v.recSize );
    
      if ( not unpay )
        initDataRec( ODT_TOTAL, stOfs + ODSTT_PREV_COIN_REST, currency.rec.Code_Currency );
        v.clear;
        v.rec.Credit = coinRest;
        odData.insert( v.recSize );
      end;
    end;
     
    getMoneyRest( rType, {curdate}, false, rest, coinRest );
    if ( rest != $0 )
      initDataRec( ODT_TOTAL, stOfs + ODSTT_REST, currency.rec.Code_Currency, oper );
      v.clear;
      v.rec.Credit = rest;
      if ( currency.rec.Code_Currency != 0 ) 
        v.rec.CreditR = cur2rub( rest );
      end;
      odData.insert( v.recSize );
    
      if ( not unpay )
        initDataRec( ODT_TOTAL, stOfs + ODSTT_COIN_REST, currency.rec.Code_Currency, oper );
        v.clear;
        v.rec.Credit = coinRest;
        odData.insert( v.recSize );
      end;
    end;
  end;

  macro writeMoneyRests( oper )

    writeMoneyRestsForType( oper, false );    
    writeMoneyRestsForType( oper, true );    
  end;

  macro writeValuesRests( oper )

    var
      v = TRecHandler( "od_data.3" );

    var
      rest; 

    v.setRecordAddr( odData );
        
    getValuesRest( {curdate} - 1, true, rest );
    if ( rest != $0 )
      initDataRec( ODT_VAL_TOTAL, ODSTT_PREV_REST, 0, oper );
      v.clear;
      v.rec.Credit = rest;
      odData.insert( v.recSize );
    end;

    getValuesRest( {curdate}, false, rest );
    if ( rest != $0 )
      initDataRec( ODT_VAL_TOTAL, ODSTT_REST, 0, oper );
      v.clear;
      v.rec.Credit = rest;
      odData.insert( v.recSize );
    end; 
  end;
end;

var
  desk = TDesk;

class ( TDataCollector ) TDC_Desk( _oper, _operForTotals )

  var
    deskTotals = TSubTotals( _operForTotals ), 
    deskTotalsU = TSubTotals( _operForTotals );

  macro makeGround
  
    var
      valName, 
      ground;  
  
    ground = getAlgName( 803, desk.cashDoc.rec.numOper ) + desk.getSubOpName;
    ground = ground + ": ";
    ground = ground + desk.cashVal.rec.NameValue; 
      
    if ( desk.cashVal.rec.Type != TYPE_RES_PAY )
      ground = ground + " (" + getAlgName( 811, desk.cashVal.rec.Type ) + ")";
    end;

    if ( desk.cashDoc.rec.Ground != "" )
      ground = ground + " " + desk.cashDoc.rec.Ground;
    end;

    return ground;
  end;

 
  macro processDoc

    var
      v = TRecHandler( "od_data.1" );

    var
      ground,
      sum, 
      debCred, 
      val, 
      unpay = false; 
  
    ground = makeGround;

    debCred = desk.cashDoc.rec.FlagDebCredOper;
    if ( desk.cashDoc.rec.cashPatern == desk.safe )
      if ( ( desk.cashDoc.rec.NumOper != CASHOP_CHVALUE ) and ( desk.cashDoc.rec.NumOper != CASHOP_CHVALUE_1 ) )  
        if ( debCred == FLAGDEBCRED_IN )
          debCred = FLAGDEBCRED_OUT; 
        else
          debCred = FLAGDEBCRED_IN; 
        end;
      end; 
    end;

    val = desk.isVal;
   
    if ( desk.cashVal.rec.Type != TYPE_RES_PAY )
      unpay = true;
    end;

    if ( desk.cashVal.rec.UnitMeas != RESMESUNIT_POINT )
      sum = desk.cashDoc.rec.ValueMoney;
    else
      sum = $1 * desk.cashDoc.rec.ValueCol;
    end;

    if ( sum == $0 )
      return;
    end;

    v.setRecordAddr( odData );

    initDataRec( ODT_OPERATION, ODSTO_OTHER_OP, 
                 currency.rec.Code_Currency, oper, 
                 getDocumentTime( desk.cashDoc.rec.ApplicationKey ) );

    if ( oper )
      odData.rec.Processing = PROC_SUM_UP;
    end;
    odData.rec.Label = "oth:";

    v.clear;

    v.rec.ground = ground;

    if ( debCred == FLAGDEBCRED_IN )
      if ( val )
        v.rec.ValCredit = sum;
        deskTotals.ValCredit = deskTotals.ValCredit + sum;  
      else
        v.rec.Credit = sum;
        if ( unpay )
          deskTotalsU.Credit = deskTotalsU.Credit + sum;  
        else
          deskTotals.Credit = deskTotals.Credit + sum;  
        end;
        if ( isCur )
          v.rec.CreditR = cur2rub( sum );
          if ( unpay )
            deskTotalsU.CreditR = deskTotalsU.CreditR + v.rec.CreditR;  
          else
            deskTotals.CreditR = deskTotals.CreditR + v.rec.CreditR;  
          end;
        end;
      end;
    else
      if ( val )
        v.rec.ValDebet = sum;
        deskTotals.ValDebet = deskTotals.ValDebet + sum;  
      else
        v.rec.Debet = sum;
        if ( unpay )
          deskTotalsU.Debet = deskTotalsU.Debet + sum;  
        else
          deskTotals.Debet = deskTotals.Debet + sum;  
        end;
        if ( isCur )
          v.rec.DebetR = cur2rub( sum );
          if ( unpay )
            deskTotalsU.DebetR = deskTotalsU.DebetR + v.rec.DebetR;  
          else
            deskTotals.DebetR = deskTotals.DebetR + v.rec.DebetR;  
          end; 
        end;
      end;
    end;

    odData.insert( v.recSize );
  end;

  macro filter

    if (  ( desk.cashDoc.rec.ApplicationKind != SB_INCASH )
      and ( desk.cashDoc.rec.ApplicationKind != SB_EXTCASH ) )
      return false;  
    end;

    if ( ( desk.cashDoc.rec.NumOper == CASHOP_REINFORCE )
      or ( desk.cashDoc.rec.NumOper == CASHOP_RETURN )
      or ( desk.cashDoc.rec.NumOper == CASHOP_REMOVE )
      or ( desk.cashDoc.rec.NumOper == CASHOP_REMOVE_1 ) )
      return false;
    end;

    if ( desk.getValNativeCurr != currency.rec.Code_Currency )
      return false;
    end;

    return true;
  end;

  macro getFilterCond

    return "( t.t_ApplicationKind = " + string( SB_INCASH ) + 
           "  or t.t_ApplicationKind = " + string( SB_EXTCASH ) + " )" +
           " and t.t_NumOper != " + string( CASHOP_REINFORCE ) +
           " and t.t_NumOper != " + string( CASHOP_RETURN ) +
           " and t.t_NumOper != " + string( CASHOP_REMOVE ) +
           " and t.t_NumOper != " + string( CASHOP_REMOVE_1 );
  end;

  macro processDocs
  
    var
      recFound;
  
    desk.cashDoc.keyNum = 8;
    desk.cashDoc.addFilter("t.t_Branch = " + string( branch ) + 
			   " and t.t_CashDateDoc = " + sqlDateToStr({curdate}) +
			   " and t.t_TypeDoc = " + string( TYPEDOC_CARRYON ) +
			   " and " + getFilterCond );
    desk.cashDoc.clear;
    desk.cashDoc.rec.Branch = branch;
    desk.cashDoc.rec.CashDateDoc = {curdate};
    desk.cashDoc.rec.TypeDoc = TYPEDOC_CARRYON;
    recFound = desk.cashDoc.getGE;
    while ( recFound
      and ( desk.cashDoc.rec.Branch == branch )
      and ( desk.cashDoc.rec.CashDateDoc == {curdate} )
      and ( desk.cashDoc.rec.TypeDoc == TYPEDOC_CARRYON ) )
      if ( desk.findCashValueForRef( desk.cashDoc.rec.RefValue ) and filter )
        processDoc;
      end;
      recFound = desk.cashDoc.next;
    end;
    desk.cashDoc.dropFilter();
  end;

  InitTDataCollector( _oper );
end;

class ( TDC_Desk ) TOperDC_Desk( _oper )

  macro filter

    if ( not filter )
      return false;
    end;

    if ( desk.cashDoc.rec.Brigade != operBrigade )
      return false;
    end;

    if ( desk.cashDoc.rec.CashOper != getWorkDeskName( oper, operBrigade ) )
      return false;
    end;

    if ( desk.cashDoc.rec.Mode != mode )
      return false;
    end;

    if ( ( desk.cashDoc.rec.NumOper == CASHOP_CREDIT ) 
      and ( desk.cashDoc.rec.SubOper == CASHOP_CREDIT_OVERPLUS ) )
      return false;
    end;

    if ( ( desk.cashDoc.rec.NumOper == CASHOP_DEBIT ) 
      and ( desk.cashDoc.rec.SubOper == CASHOP_DEBET_SHORTAGE ) )
      return false;
    end;

    if ( not desk.valIsShown )
      return false;
    end;

    return true; 
  end;

  macro getFilterCond

    return getFilterCond + 
           " and t.t_Brigade = " + string( operBrigade ) +
           " and t.t_CashOper = " + GetSQLString( getWorkDeskName( oper, operBrigade ) ) +    
           " and t.t_Mode = " + string( mode );
  end;
  
  macro proceed

    message( string( oper ) + ": Сбор данных: Прочие операции" );
    deskTotals.reset;
    deskTotalsU.reset;

    processDocs;

    message( "" );
  end;

  InitTDC_Desk( _oper, _oper );
end;

class ( TDC_Desk ) TBrigadeDC_Desk

  macro makeGround;

    var  
      ground = makeGround;

    if ( ( desk.cashDoc.rec.NumOper == CASHOP_CREDIT )
      or ( desk.cashDoc.rec.NumOper == CASHOP_DEBIT ) )
      desk.deskSubj.getPos;
      if ( desk.findDeskSubj( desk.cashDoc.rec.CashOper ) )
        ground = ground + " операционист " + desk.deskSubj.rec.Owner; 
      end;
      desk.deskSubj.getDirect;
    end;

    return ground;
  end; 

  macro filter

    macro isWorkDeskShortageOverplus

      var
        stat = true;  

      if ( desk.cashDoc.rec.NumOper == CASHOP_CREDIT ) 
        if ( desk.cashDoc.rec.SubOper != CASHOP_CREDIT_OVERPLUS )
          return false;
         end;
      elif ( desk.cashDoc.rec.NumOper == CASHOP_DEBIT ) 
        if ( desk.cashDoc.rec.SubOper != CASHOP_DEBET_SHORTAGE ) 
          return false;
        end;
      else
        return false;   
      end;

      desk.deskSubj.getPos;
      if ( not desk.findDeskSubj( desk.cashDoc.rec.CashOper ) )
        if ( desk.deskSubj.rec.Group != operBrigade )
          stat = false;
        end; 
      end;
      desk.deskSubj.getDirect;

      return stat;
    end;

    if ( not filter )
      return false;
    end;

    if ( desk.cashDoc.rec.Brigade != operBrigade )
      return false;
    end;

    if ( desk.cashDoc.rec.CashPatern != desk.safe )
      if ( not isWorkDeskShortageOverplus )
        return false;
      end;
    end;

    if ( desk.cashDoc.rec.Mode != mode )
      return false;
    end;

    if ( not desk.valIsShown )
      return false;
    end;

    return true; 
  end;

  macro getFilterCond

    return getFilterCond + 
           " and t.t_Brigade = " + string( operBrigade ) +
           " and t.t_Mode = " + string( mode );
  end;

  macro proceed

    message( "Сбор данных: Операции Оперкассы" );
    deskTotals.reset;
    deskTotalsU.reset;

    processDocs;

    updateGlobalTotals( deskTotals );
    updateGlobalTotalsU( deskTotalsU );
    deskTotals.writeAsGlobal( ODSTT_TURNS_OTHER ); 
    deskTotalsU.writeAsGlobal( ODSTT_UNPAY_OFFS + ODSTT_TURNS_OTHER ); 

    deskTotals.add( deskTotalsU );
    deskTotals.write( ODSTO_OTHER_TOT );

    message( "" );
  end;

  InitTDC_Desk( 0, noOper );
end;

class ( TDataCollector ) TOperDC_ValuesOnAccount( _oper )

  macro getTurns( debet, credit, rest )

    credit = debet = rest = $0;

    desk.cashAcc.rec.Branch = branch;
    desk.cashAcc.rec.CashOper = getWorkDeskName( oper, operBrigade );
    desk.cashAcc.rec.SubAccount = "";
    desk.cashAcc.rec.RefValue = desk.cashVal.rec.RefValue;
    desk.cashAcc.rec.Date = {curdate};
    if ( desk.cashAcc.getEQ )
      if ( desk.cashVal.rec.UnitMeas == RESMESUNIT_POINT )
        debet = $1 * desk.cashAcc.rec.DebCol;
        credit = $1 * desk.cashAcc.rec.KredCol;
        rest = $1 * desk.cashAcc.rec.RestCol;
      else
        debet = desk.cashAcc.rec.DebMoney;
        credit = desk.cashAcc.rec.KredMoney;
        rest = desk.cashAcc.rec.RestMoney;
      end;
    end;

    setParm( 1, debet );
    setParm( 2, credit );
    setParm( 3, rest );
  end; 

  macro proceed

    var
      v = TRecHandler( "od_data.4" );

    var
      debet, credit, rest; 

    message( string( oper ) + ": Сбор данных: Ресурсы, выданные под отчет" );

    desk.cashVal.keyNum = 0;
    desk.cashVal.rewind;
    while ( desk.cashVal.next )
      if ( desk.valIsShown )
        getTurns( debet, credit, rest );
        if ( ( debet != $0 ) or ( credit != $0 ) or ( rest != $0 ) )
          v.setRecordAddr( odData );
      
          initDataRec( ODT_ON_ACC, desk.cashVal.rec.TypeValue, 
                       0, oper );
      
          v.clear;
          v.rec.ValName = desk.cashVal.rec.NameValue;
          if ( desk.cashVal.rec.Type != TYPE_RES_PAY )
            v.rec.ValName = v.rec.ValName + " (" + getAlgName( 811, desk.cashVal.rec.Type ) + ")";
          end;
          v.rec.Credit = credit;
          v.rec.Debet = debet;
          v.rec.Rest = rest;

          odData.insert( v.recSize );
        end; 
      end; 
    end;                                                  
    message( "" );
  end;

  InitTDataCollector( _oper );
end;