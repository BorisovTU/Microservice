
/*
**  Опердневник ф.24. Сбор данных по операциям. Вклады
**
09.01.2004 KIN - добавлена печать № валютной справки в дневнике ф.24
*/

import od_com, od_total, od_trn, operCode, isSrvDoc, sqlconv, rsd;

/* 09.01.2004 KIN*/
import "FindNumBSO.mac";

class ( TDataCollector ) TBaseDC_Dep( _oper )

  var
    dd = TBFile( "sbdepdoc.dbt", "r", 0 ),
    cl = TClientList,
    depTotals = TSubTotals( _oper );

  macro depDocFilter

    if ( not isServDoc( dd.rec ) )
      return false;
    end;

    return true;
  end;

  macro AddCondition( SQLString )
    if ( {MakeDeskDocs} )
       SQLString = SQLString + " and (dd.T_NOTCONFIRM=chr(0) or dd.T_FLAGSTORN!=chr(0)) ";
    end;
    return SQLString;
  end;

  macro findDepClient( code )

    var
      cln;

    if ( not cl.GetRecord( code ) )
      cln = cl.curRec;
      cln.rec.Name1 = "???";
      cln.rec.Name2 = "???";
      cln.rec.Name3 = "???";
    end;
  end;

  macro getOpNameForDepDoc( complexOper )

    depOpTypes.rec.IsCur = dd.rec.IsCur;
    depOpTypes.rec.Kind = dd.rec.Type_Account;
    if ( complexOper )
      depOpTypes.rec.NumOpert = dd.rec.TypeComplexOper;
    else
      depOpTypes.rec.NumOpert = dd.rec.TypeOper;
    end;
    if ( depOpTypes.getEQ )
      return depOpTypes.rec.czNameAlg;
    else
      return "[Неизвестная операция]";
    end;
  end;

  macro getSubOpNameForDepDoc

    depSubOpTypes.keyNum = 1;
    depSubOpTypes.rec.IsCur = dd.rec.IsCur;
    depSubOpTypes.rec.Kind = dd.rec.Type_Account;
    depSubOpTypes.rec.OperType = dd.rec.TypeOper;
    depSubOpTypes.rec.Type = dd.rec.ApplType;
    if ( depSubOpTypes.getEQ )
      return " (" + depSubOpTypes.rec.Name +")";
    end;
  end;

  macro makeDepDocGround

    var
      ground = "", fio;
    /* 09.01.2004 KIN*/
    var strNumBSO = "";

    ground = dd.rec.Ground;

    if ( trim( ground ) == "" )
      ground = getOpNameForDepDoc( false ) + getSubOpNameForDepDoc;
    end;

    findDepClient( dd.rec.CodClient );
    findDep( dd.rec.Referenc );

    if ( cl.curRec.rec.SpecialAccess or dep.rec.specialAccess )
      fio = dd.rec.Type_Account;
    else
      fio = cl.curRec.convertFio;
    end;

    /* 09.01.2004 KIN*/
    /*получения номера справки*/
    strNumBSO  = Find_Cas_Doc(dd.rec,6);
    if (strNumBSO != "")
       return ground + " " + fio + "\n" + "Справка №: " + strNumBSO;
    else
        return ground + " " + fio;
    end;
    /*return ground + "\n" + fio;*/

  end;

  macro processDepDoc
  end;

  macro processDepDocs;

    var SQLString, 
      recFound,  cmd, rs;


    var fName=string( "d", StrSubst(dd.FileName, ".", "_") );

    SQLString = string( "select dd.T_REFERENC as REFERENC, ",
                        "       dd.T_NUMDAYDOC as NUMDAYDOC, ",                                
                        "       dd.T_TYPE_ACCOUNT as TYPE_ACCOUNT, ",
                        "       dd.T_FNCASH as FNCASH, ",
                        "       dd.T_ACCOUNT as ACCOUNT, ",
                        "       dd.T_DATE_DOCUMENT as DATE_DOCUMENT, ",
                        "       dd.T_CODE_CURRENCY as CODE_CURRENCY, ",
                        "       dd.T_OPER as OPER, ",
                        "       dd.T_VIDDOC as VIDDOC, ",
                        "       dd.T_APPLTYPE as APPLTYPE, ",
                        "       dd.T_NDOC as NDOC, ",
                        "       dd.T_NPACK as NPACK, ",
                        "       dd.T_KINDOP as KINDOP, ",
                        "       dd.T_INSUM as INSUM, ",
                        "       dd.T_OUTSUM as OUTSUM, ",
                        "       dd.T_REST as REST, ",
                        "       dd.T_PERCOPRSUM as PERCOPRSUM, ",
                        "       dd.T_PERCREST as PERCREST, ",
                        "       dd.T_ARDATE as ARDATE, ",
                        "       dd.T_FLAGSTORN as FLAGSTORN, ",
                        "       dd.T_FLAGREZID as FLAGREZID, ",
                        "       dd.T_YESSBOOK as YESSBOOK, ",
                        "       dd.T_YESFORM as YESFORM, ",
                        "       dd.T_IAPPLICATIONKIND as IAPPLICATIONKIND, ",
                        "       dd.T_APPLICATIONKEY as APPLICATIONKEY, ",
                        "       dd.T_LISTTRANSFER as LISTTRANSFER, ",
                        "       dd.T_CODCLIENT as CODCLIENT, ",
                        "       dd.T_TYPEOPER as TYPEOPER, ",
                        "       dd.T_NOTCONFIRM as NOTCONFIRM, ",
                        "       dd.T_TYPECOMPLEXOPER as TYPECOMPLEXOPER, ",
                        "       dd.T_CODCASHIER as CODCASHIER, ",
                        "       dd.T_AUTHOR as AUTHOR, ",
                        "       dd.T_NUMSESSION as NUMSESSION, ",
                        "       dd.T_ACTION as ACTION, ",
                        "       dd.T_OBJECTPERC as OBJECTPERC, ",
                        "       dd.T_DEPDATE_DOCUMENT as DEPDATE_DOCUMENT, ",
                        "       dd.T_ISCONTROL as ISCONTROL, ",
                        "       dd.T_BRIGADE as BRIGADE, ",
                        "       dd.T_FLAGNONCARRY as FLAGNONCARRY, ",
                        "       dd.T_GROUND as GROUND, ",
                        "       dd.T_UNIONPART as UNIONPART, ",
                        "       dd.T_ARDATEPCCALC as ARDATEPCCALC, ",
                        "       dd.T_MODE as MDE, ",
                        "       dd.T_SOURCE as SOURCE, ",
                        "       dd.T_ORDERCOUNT as ORDERCOUNT, ",
                        "       dd.T_FLAGS as FLAGS, ",
                        "       dd.T_KNFCODE as KNFCODE, ",
                        "       dd.T_REALFNCASH as REALFNCASH, ",
                        "       dd.T_ISSUSPENDED as ISSUSPENDED, ",
                        "       dd.T_FLAGS2 as FLAGS2 ",
                        " from ", fName, " dd ",
                        " where dd.t_isCur = :isCur and ",
                        "       dd.t_FNcash = :FNcash and ",
                        "       dd.t_Date_Document = :Date_Document and ",
                        "       dd.t_Mode = :Mde and ",
                        "       dd.t_Code_Currency = :Code_Currency " );    

    SQLString = AddCondition( SQLString );

    cmd = RsdCommand( NULL,  SQLString );

    rs = RsdRecordset( cmd );

    cmd.addParam( "isCur", RSDBP_IN );
    cmd.addParam( "FNcash", RSDBP_IN );
    cmd.addParam( "Date_Document", RSDBP_IN );
    cmd.addParam( "Mde", RSDBP_IN );
    cmd.addParam( "Code_Currency", RSDBP_IN );

    cmd.value( "isCur" ) = isCur;
    cmd.value( "FNcash" ) = branch;
    cmd.value( "Date_Document" ) = {curdate};
    cmd.value( "Mde" ) = mode;
    cmd.value( "Code_Currency" ) = currency.rec.Code_Currency;
    cmd.execute;

    
    dd.clear;
    
    while ( rs.moveNext() )
      dd.rec.REFERENC = rs.value("REFERENC");
      dd.rec.NUMDAYDOC = rs.value("NUMDAYDOC");
      dd.rec.TYPE_ACCOUNT = rs.value("TYPE_ACCOUNT");
      dd.rec.FNCASH = rs.value("FNCASH");
      dd.rec.ACCOUNT = rs.value("ACCOUNT");
      dd.rec.DATE_DOCUMENT = rs.value("DATE_DOCUMENT");
      dd.rec.CODE_CURRENCY = rs.value("CODE_CURRENCY");
      dd.rec.OPER = rs.value("OPER");
      dd.rec.VIDDOC = rs.value("VIDDOC");
      dd.rec.APPLTYPE = rs.value("APPLTYPE");
      dd.rec.NDOC = rs.value("NDOC");
      dd.rec.NPACK = rs.value("NPACK");
      dd.rec.KINDOP = rs.value("KINDOP");
      dd.rec.INSUM = rs.value("INSUM");
      dd.rec.OUTSUM = rs.value("OUTSUM");
      dd.rec.REST = rs.value("REST");
      dd.rec.PERCOPRSUM = rs.value("PERCOPRSUM");
      dd.rec.PERCREST = rs.value("PERCREST");
      dd.rec.ARDATE = rs.value("ARDATE");
      dd.rec.FLAGSTORN = rs.value("FLAGSTORN");
      dd.rec.FLAGREZID = rs.value("FLAGREZID");
      dd.rec.YESSBOOK = rs.value("YESSBOOK");
      dd.rec.YESFORM = rs.value("YESFORM");
      dd.rec.IAPPLICATIONKIND = rs.value("IAPPLICATIONKIND");
      dd.rec.APPLICATIONKEY = rs.value("APPLICATIONKEY");
      dd.rec.LISTTRANSFER = rs.value("LISTTRANSFER");
      dd.rec.CODCLIENT = rs.value("CODCLIENT");
      dd.rec.TYPEOPER = rs.value("TYPEOPER");
      dd.rec.NOTCONFIRM = rs.value("NOTCONFIRM");
      dd.rec.TYPECOMPLEXOPER = rs.value("TYPECOMPLEXOPER");
      dd.rec.CODCASHIER = rs.value("CODCASHIER");
      dd.rec.AUTHOR = rs.value("AUTHOR");
      dd.rec.NUMSESSION = rs.value("NUMSESSION");
      dd.rec.ACTION = rs.value("ACTION");
      dd.rec.OBJECTPERC = rs.value("OBJECTPERC");
      dd.rec.DEPDATE_DOCUMENT = rs.value("DEPDATE_DOCUMENT");
      dd.rec.ISCONTROL = rs.value("ISCONTROL");
      dd.rec.BRIGADE = rs.value("BRIGADE");
      dd.rec.FLAGNONCARRY = rs.value("FLAGNONCARRY");
      dd.rec.GROUND = rs.value("GROUND");
      /* Поля типа raw RSL не умеет обрабатывать. Возникает исключение */
      /*dd.rec.UNIONPART = rs.value("UNIONPART");*/
      dd.rec.ARDATEPCCALC = rs.value("ARDATEPCCALC");
      dd.rec.MODE = rs.value("MDE");
      dd.rec.SOURCE = rs.value("SOURCE");
      dd.rec.ORDERCOUNT = rs.value("ORDERCOUNT");
      dd.rec.FLAGS = rs.value("FLAGS");
      dd.rec.KNFCODE = rs.value("KNFCODE");
      dd.rec.REALFNCASH = rs.value("REALFNCASH");
      dd.rec.ISSUSPENDED = rs.value("ISSUSPENDED");
      dd.rec.FLAGS2 = rs.value("FLAGS2");
      if ( depDocFilter )
        processDepDoc;
      end;
    end;
  end;

  macro proceed

  end;

  initTDataCollector( _oper );
end;

class ( TBaseDC_Dep ) TOperDC_Dep( _oper )

  macro depDocFilter

    if ( not depDocFilter )
      return false;
    end;

    if ( getBitFlag( dd.rec.Flags, BIT_FLAG_UNCASH ) )
      return false;
    end;

    return true;
  end;

  macro AddCondition( SQLString )

    SQLString = AddCondition(SQLString);

    SQLString = SQLString + string(" and dd.T_BRIGADE=", operBrigade, " and dd.T_Oper=", oper );

    SQLString = SQLString + string(" and (dd.T_RealFNCash=0 or dd.T_RealFNCash=", branch,") ");
    
    return SQLString;
  end;

  macro processDepDoc

    var
      v = TRecHandler( "od_data.1" );

    var
      d1 = TRecHandler( "sbdepdoc.1" ),
      valCredit, valDebet, valCreditCV, valDebetCV,
      d;

    v.setRecordAddr( odData );

    desk.getValuesTurnsForOp( dd.rec.iApplicationKind,
                              dd.rec.ApplicationKey,
                              valCredit,
                              valDebet,
                              valCreditCV,
                              valDebetCV );
    if ( dd.rec.FlagStorn != StrFor(0) )
      if ( min( dd.rec.InSum, dd.rec.OutSum ) < 0 )
        valCredit = valDebet = $0;
        valCreditCV = valDebetCV = $0;
      end;
    end;
    if ( ( dd.rec.InSum != $0 ) or ( dd.rec.OutSum != $0 )
      or ( valCredit != $0 ) or ( valDebet != $0 ) or ( valCreditCV != $0 ) or ( valDebetCV != $0 )
      or ( dd.rec.TypeComplexOper == Открытие_Наличными )
      or ( dd.rec.TypeComplexOper == Открытие_Безналичными )
      or ( dd.rec.TypeComplexOper == Закрытие_Наличными )
      or ( dd.rec.TypeComplexOper == Закрытие_Безналичными ) )

      initDataRec(
        ODT_OPERATION,
        ODSTO_DEP_OP,
        currency.rec.Code_Currency,
        oper,
        getDocumentTime( dd.rec.applicationKey ) );

      v.clear;
      v.rec.Account = dd.rec.Account;
      v.rec.Ground = makeDepDocGround;

      if ( dd.rec.VidDoc != 0 ) /* Наличный */
        v.rec.Credit = dd.rec.InSum;
        v.rec.Debet = dd.rec.OutSum;
        depTotals.credit = depTotals.credit + v.rec.Credit;
        depTotals.debet = depTotals.debet + v.rec.Debet;
        if ( dd.rec.Code_Currency != NATIONAL_CURR )
          v.rec.CreditR = cur2rub( dd.rec.InSum );
          v.rec.DebetR = cur2rub( dd.rec.OutSum );
          depTotals.creditR = depTotals.creditR + v.rec.CreditR;
          depTotals.debetR = depTotals.debetR + v.rec.DebetR;
        end;
      else                              /* Безналичный */
        if ( ( dd.rec.TypeComplexOper == Безналичная_Конверсия )
          and ( dd.rec.Code_Currency == NATIONAL_CURR ) )
          d1.setRecordAddr( dd, 0, 0, true );
          if ( dd.rec.InSum != $0 )
            v.rec.MemCredit = dd.rec.InSum /* SCR9795 d1.rec.CurrencyBought * d1.rec.PercTrnAlt */;
/*          SCR9795
            d = dd.rec.InSum - v.MemCredit;
            if ( d > 0 )
              v.MemCreditRDiff = d;
            else
              v.MemDebetRDiff = -d;
            end;
*/
          elif ( dd.rec.OutSum != $0 )
            v.rec.MemDebet = dd.rec.OutSum /* SCR9795 d1.rec.CurrencyBought * d1.rec.PercTrnAlt */;
/*          SCR9795
            d = dd.rec.OutSum - v.MemDebet;
            if ( d > 0 )
              v.MemDebetRDiff = d;
            else
              v.MemCreditRDiff = -d;
            end;
*/
          end;
        else
          v.rec.MemCredit = dd.rec.InSum;
          v.rec.MemDebet = dd.rec.OutSum;
          if ( dd.rec.Code_Currency != NATIONAL_CURR )
            v.rec.MemCreditR = cur2rub( dd.rec.InSum );
            v.rec.MemDebetR = cur2rub( dd.rec.OutSum );
          end;
        end;
        depTotals.memCredit = depTotals.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff */;
        depTotals.memDebet = depTotals.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff */;
        if ( dd.rec.Code_Currency != NATIONAL_CURR )
          depTotals.memCreditR = depTotals.memCreditR + v.rec.MemCreditR;
          depTotals.memDebetR = depTotals.memDebetR + v.rec.MemDebetR;
        end;
      end;

      v.rec.ValCredit = valCredit;
      v.rec.ValDebet = valDebet;
      v.rec.ValCreditCV = valCreditCV;
      v.rec.ValDebetCV = valDebetCV;
      depTotals.valCredit = depTotals.valCredit + valCredit;
      depTotals.valDebet = depTotals.valDebet + valDebet;
      depTotals.valCreditCV = depTotals.valCreditCV + valCreditCV;
      depTotals.valDebetCV = depTotals.valDebetCV + valDebetCV;

      odData.insert( v.recSize );
    end;
  end;

  macro processGroupPayments;

    var
      trn = TOperDC_Trn( oper, false );

    trn.proceed;
    depTotals.add( trn.trnTotals );
  end;

  macro proceed

    message( string( oper ) + ": Сбор данных: Вклады" );
    depTotals.reset;
    processDepDocs;
    processGroupPayments;
    depTotals.write( ODSTO_DEP_TOT );
    depTotals.writeAsGlobal( ODSTT_TURNS_DEP );
    updateGlobalTotals( depTotals );
    message( "" );
  end;

  initTBaseDC_Dep( _oper );
end;

class ( TBaseDC_Dep ) TFBIDC_Dep

  private var
    includeTrns,
    branchSubTotals = TSetOfBranchSubTotals( noOper2 );

  macro depDocFilter

    if ( not depDocFilter )
      return false;
    end;

    if ( getBitFlag( dd.rec.Flags, BIT_FLAG_UNCASH ) )
      if ( not includeTrns )
        return false;
      end;
    end;

    return true;
  end;

  macro AddCondition( SQLString )

    SQLString = AddCondition(SQLString);

    SQLString = SQLString + string(" and dd.T_RealFNCash!=0 and dd.T_RealFNCash!=", branch );
    
    return SQLString;
  end;

  macro makeDepDocGround

    var
      branchName = "* филиал не найден *";

    getBranchParams( dd.rec.RealFNCash, branchName );
    return branchName + " " + makeDepDocGround;
  end;

  macro processDepDoc

    var
      v = TRecHandler( "od_data.1" );

    var
      d1 = TRecHandler( "sbdepdoc.1" ),
      valCredit, valDebet, valCreditCV, valDebetCV,
      d,
      bst;

    v.setRecordAddr( odData );

    if ( ( dd.rec.InSum != $0 ) or ( dd.rec.OutSum != $0 )
      or ( dd.rec.TypeComplexOper == Открытие_Наличными )
      or ( dd.rec.TypeComplexOper == Открытие_Безналичными )
      or ( dd.rec.TypeComplexOper == Закрытие_Наличными )
      or ( dd.rec.TypeComplexOper == Закрытие_Безналичными ) )

      initDataRec(
        ODT_OPERATION,
        ODSTO_FBID_OP,
        currency.rec.Code_Currency,
        oper,
        getDocumentTime( dd.rec.applicationKey ) );

      v.clear;
      v.rec.Account = dd.rec.Account;
      v.rec.Ground = makeDepDocGround;

      if ( ( dd.rec.TypeComplexOper == Безналичная_Конверсия )
        and ( dd.rec.Code_Currency == NATIONAL_CURR ) )
        d1.setRecordAddr( dd, 0, 0, true );
        if ( dd.rec.InSum != $0 )
          v.rec.MemCredit = dd.rec.InSum /* SCR9795 d1.rec.CurrencyBought * d1.rec.PercTrnAlt */;
/*        SCR9795
          d = dd.rec.InSum - v.MemCredit;
          if ( d > 0 )
            v.MemCreditRDiff = d;
          else
            v.MemDebetRDiff = -d;
          end;
*/
        elif ( dd.rec.OutSum != $0 )
          v.rec.MemDebet = dd.rec.OutSum /* SCR9795 d1.rec.CurrencyBought * d1.rec.PercTrnAlt */;
/*        SCR9795
          d = dd.rec.OutSum - v.MemDebet;
          if ( d > 0 )
            v.MemDebetRDiff = d;
          else
            v.MemCreditRDiff = -d;
          end;
*/
        end;
      else
        v.rec.MemCredit = dd.rec.InSum;
        v.rec.MemDebet = dd.rec.OutSum;
        if ( dd.rec.Code_Currency != NATIONAL_CURR )
          v.rec.MemCreditR = cur2rub( dd.rec.InSum );
          v.rec.MemDebetR = cur2rub( dd.rec.OutSum );
        end;
      end;

      bst = branchSubTotals.get( dd.rec.RealFNCash );

      depTotals.memCredit = depTotals.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff */;
      depTotals.memDebet = depTotals.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff*/;
      bst.memCredit = bst.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff*/;
      bst.memDebet = bst.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff*/;
      if ( dd.rec.Code_Currency != NATIONAL_CURR )
        depTotals.memCreditR = depTotals.memCreditR + v.rec.MemCreditR;
        depTotals.memDebetR = depTotals.memDebetR + v.rec.MemDebetR;
        bst.memCreditR = bst.memCreditR + v.rec.MemCreditR;
        bst.memDebetR = bst.memDebetR + v.rec.MemDebetR;
      end;

      odData.insert( v.recSize );
    end;
  end;

  macro proceed

    message( "Сбор данных: Вклады - операции, выполненные в других филиалах" );
    includeTrns = getRegSetting( V_INTEGER, "ВКЛАДЫ\\ОТЧЕТ_ПО_ОПЕР_В_ДР_ФИЛИАЛАХ\\ВКЛЮЧАТЬ_ПАК_ЗАЧИСЛЕНИЯ" ) == 1;
    branchSubTotals.reset;
    depTotals.reset;
    processDepDocs;
    branchSubTotals.write( ODSTO_FBID_BR_TOT_BASE );
    depTotals.write( ODSTO_FBID_TOT );
    message( "" );
  end;

  initTBaseDC_Dep( noOper2 );
end;


