
/*
**  Опердневник ф.24. Ценные бумаги и ценности
**
*/

import od_com, 
       od_total, 
       ogsz_rep, 
       lot_rep, 
       cert_rep, 
       ovz_rep, 
       coin_rep, 
       ing_rep, 
       misc_rep,
       sqlconv;

class ( TSubTotals ) TCISubTotals( _oper, _type )

  var
    type = _type;

  macro write

    write( ODSTO_CI_TOT_BASE + type );
  end;

  InitTSubTotals( _oper );
end;

class ( TDataCollector ) TOperDC_CI( _oper )

  var
    ciDoc = TBfile( "ci_doc.dbt", "r", 6 ), 
    ciRecGens = TArray, 
    ciTypeSubTotals = TArray;

  macro getTypeSubTotals( type )

    if ( ciTypeSubTotals[type] == null )
      ciTypeSubTotals[type] = TCISubTotals( oper, type );
    end;
    return ciTypeSubTotals[type];
  end;

  macro writeTypeSubTotals

    var
      i = 0, t;

    while ( i < ciTypeSubTotals.size )
      t = ciTypeSubTotals[i];
      if ( t != null ) 
        t.write;
      end; 
      i = i + 1;
    end;
  end;

  macro resetTypeSubTotals

    var
      i = 0;

    while ( i < ciTypeSubTotals.size )
      if ( ciTypeSubTotals[i] != null ) 
        ciTypeSubTotals[i].reset;
      end; 
      i = i + 1;
    end;
  end;

  macro isCreditOp( type, op )
  
    if ( type == CI_OGSZ )
      if ( ( op == O_OGSZ_SELL ) or ( op == O_OGSZ_SELL_ACC ) )
        return true;
      end;
    elif ( ( type == CI_LOTTERY ) or ( type == CI_ORVVZ ) )
      if ( ( op == O_LOTTERY_SELL ) or ( op == O_LOTTERY_SELL_ACC ) )
        return true;
      end;
    elif ( type == CI_CERT )
      if ( ( op == O_CERT_SELL ) or ( op == O_CERT_SELL_ACC ) )
        return true;
      end;
    elif ( ( type == CI_MISC ) or ( type == CI_COIN ) )
      if ( ( op == O_MISC_SELL ) or ( op == O_MISC_SELL_ACC ) )
        return true;
      end;
    elif ( type == CI_INGOT )
      if ( ( op == O_INGOT_SELL ) or ( op == O_INGOT_SELL_ACC ) )
        return true;
      end;
    end;
    return false;
  end;
  
  macro isCashOp( type, op )
  
    if ( type == CI_OGSZ )
      if ( op == O_OGSZ_SELL_ACC )
        return false;
      end;
    elif ( ( type == CI_LOTTERY ) or ( type == CI_ORVVZ ) )
      if ( op == O_LOTTERY_SELL_ACC )
        return false;
      end;
    elif ( type == CI_CERT )
      if ( op == O_CERT_SELL_ACC )
        return false;
      end;
    elif ( ( type == CI_MISC ) or ( type == CI_COIN ) )
      if( op == O_MISC_SELL_ACC )
        return false;
      end;
    elif ( type == CI_INGOT )
      if ( op == O_INGOT_SELL_ACC )
        return false;
      end;
    end;
    return true;
  end;

  macro writeLineAndUpdateTotals( type, processing, lSubType, op, ground, time, sum, coinSum, 
                                  valCredit, valDebet, valCreditCV, valDebetCV )

    var
      v = TRecHandler( "od_data.1" );

    var
      isCredit = isCreditOp( type, op ), 
      isCash = isCashOp( type, op ),  
      typeTotals = getTypeSubTotals( type );

    v.setRecordAddr( odData );

    initDataRec( ODT_OPERATION, 
                 ODSTO_OTHER_OP, 
                 currency.rec.Code_Currency, 
                 oper, 
                 time );

    odData.rec.Processing = processing;
    odData.rec.Label = "cis:" + type + ":" + lSubType + ":" + op;

    v.clear;

    v.rec.ground = ground;

    if ( isCash )
      if ( isCredit )
        v.rec.Credit = sum;
      else
        v.rec.Debet = sum;
      end;
    else
      if ( isCredit )
        v.rec.MemCredit = sum;
      else
        v.rec.MemDebet = sum;
      end;
    end;

    if ( isCredit )
      v.rec.Debet = coinSum;
    else
      v.rec.Credit = coinSum;
    end;

    v.rec.ValCredit = valCredit;
    v.rec.ValDebet = valDebet;
    v.rec.ValCreditCV = valCreditCV;
    v.rec.ValDebetCV = valDebetCV;

    typeTotals.credit = typeTotals.credit + v.rec.Credit;
    typeTotals.debet = typeTotals.debet + v.rec.Debet;
    typeTotals.memCredit = typeTotals.memCredit + v.rec.MemCredit;
    typeTotals.memDebet = typeTotals.memDebet + v.rec.MemDebet;
    typeTotals.valCredit = typeTotals.valCredit + v.rec.ValCredit;
    typeTotals.valDebet = typeTotals.valDebet + v.rec.ValDebet;
    typeTotals.valCreditCV = typeTotals.valCreditCV + v.rec.ValCreditCV;
    typeTotals.valDebetCV = typeTotals.valDebetCV + v.rec.ValDebetCV;

    odData.insert( v.recSize );
  end;

  macro makeDocGround

    var
      info, 
      ground = ""; 
  
    if ( ciDoc.rec.Type == CI_OGSZ )
      info = TRecHandler( "ci_doc.1" );  
    elif ( ciDoc.rec.Type == CI_CERT )
      info = TRecHandler( "ci_doc.3" );  
    elif ( ciDoc.rec.Type == CI_INGOT )
      info = TRecHandler( "ci_doc.4" );  
    else
      info = TRecHandler( "ci_doc.2" );  
    end;
    
    info.setRecordAddr( ciDoc, 0, ciDoc.fldOffset( "Info" ), true );

    if ( findCIOperation( ciDoc.rec.Type, ciDoc.rec.Operation ) )
      ground = ground + ciOper.rec.Name + ": ";
    end;

    if ( ciDoc.rec.Type == CI_OGSZ )
      ground = ground + "ОГСЗ серии " + info.rec.Series +
        ", номинал " + info.rec.Par;
    elif ( ciDoc.rec.Type == CI_CERT )
      ground = ground + "Сбер.сертификат " + info.rec.Year + "г, номинал " +
        info.rec.Par;
    else
      ground = ground + info.rec.Name;
    end;
  
    if ( ciDoc.rec.Action == D_STORN )
      if ( ciDoc.rec.Sum >= 0 )
        ground = ground + " (сторнирован)";
      else
        ground = ground + " (сторнирующ.)";
      end;
    end;
  
    return ground;
  end;

  macro processDoc

    var
      lSubType,  
      info, 
      coinSum = $0, 
      valCredit, valDebet, valCreditCV, valDebetCV;
        

    desk.getValuesTurnsForOp( ciDoc.rec.ApplicationKind, 
                              ciDoc.rec.ApplicationKey, 
                              valCredit, 
                              valDebet, 
                              valCreditCV, 
                              valDebetCV );

    if ( ( ciDoc.rec.Type == CI_COIN ) and ( not isCoinOld( ciDoc.rec.Issue ) ) )
      info = TRecHandler( "ci_doc.2" );
      info.setRecordAddr( ciDoc, 0, ciDoc.fldOffset( "Info" ), true );
      coinSum = info.rec.Par * info.rec.NumItems;
    end;

    if ( ciDoc.rec.Type == CI_CERT )
      info = TRecHandler( "ci_doc.3" );
      info.setRecordAddr( ciDoc, 0, ciDoc.fldOffset( "Info" ), true );
      lSubType = info.rec.Year;
    else
      lSubType = ciDoc.rec.Issue; 
    end;

    writeLineAndUpdateTotals( ciDoc.rec.Type, PROC_SUM_UP, lSubType, ciDoc.rec.Operation, 
                              makeDocGround, getDocumentTime( ciDoc.rec.ApplicationKey ),
                              ciDoc.rec.Sum, coinSum, 
                              valCredit, valDebet, valCreditCV, valDebetCV );
  end;

  macro filter

    if ( ciDoc.rec.Oper != oper )
      return false;
    end;

    if ( ciDoc.rec.Brigade != operBrigade )
      return false;
    end;

    if ( ciDoc.rec.Mode != mode )
      return false;
    end;

    if ( ciDoc.rec.Action != D_STORN ) 
      if ( not isConfirmed( not ciDoc.rec.IsConfirmed ) )
        return false;
      end;
    end;

    if ( ciDoc.rec.Action == D_DELETE )
      return false;
    end;

    /* Непроведенный документ */
    if ( ( ciDoc.rec.IsSuspended != "" ) and ( ciDoc.rec.IsSuspended != "X" ) )
      return false;
    end;

    if ( ciRecGens[ciDoc.rec.Type] != null )
      if ( ciRecGens[ciDoc.rec.Type].isOpIncluded( ciDoc.rec.Issue, 
                                                       ciDoc.rec.Operation ) )
        return false;
      end; 
    end;

    return true;
  end;

  macro processDocs

    var
      recFound;

    ciDoc.addFilter("t.t_Branch = " + string( branch ) + 
		    " and t.t_isCur = " + string(isCur) + 
		    " and t.t_curCode = " + string(currency.rec.Code_Currency) + 
		    " and t.t_Date = " + sqlDateToStr({curdate}) +
		    " and t.t_Oper = " + string( oper ) +
		    " and t.t_Brigade = " + string( operBrigade ) +
		    " and t.t_Mode = " + string( mode ) );
    ciDoc.clear;
    ciDoc.rec.Branch = branch;
    ciDoc.rec.isCur = isCur;
    ciDoc.rec.curCode = currency.rec.Code_Currency;
    ciDoc.rec.Date = {curdate};
    recFound = ciDoc.getGE;
    while ( recFound 
      and ( ciDoc.rec.Branch == branch )
      and ( ciDoc.rec.isCur == isCur )
      and ( ciDoc.rec.curCode == currency.rec.Code_Currency )
      and ( ciDoc.rec.Date == {curdate} ) )
      if ( filter )
        processDoc;
      end;       
      recFound = ciDoc.next;
    end;
    ciDoc.dropFilter();
  end;

  macro processRecsOfType( type )

    if ( ciRecGens[type] != null )
      ciRecGens[type].proceed;
    end;
  end;

  macro processRecs
  
    var
      i = 0;

    while ( i < ciRecGens.size )
      if ( ciRecGens[i] != null )
        processRecsOfType( i );
      end;
      i = i + 1;
    end; 
  end;

  macro proceed

    message( string( oper ) + ": Сбор данных: Ценные бумаги и ценности" );
    resetTypeSubTotals;

    processDocs;
    processRecs;
    writeTypeSubTotals;
    message( "" );
  end; 

  /* ручками удалим ссылки на себя (см. внизу "this").
     иначе не вызываются деструкторы. SCR10801 */
  macro beforeDestructor
    var i = 0;

    while ( i < ciRecGens.size )
      if ( ciRecGens[i] != null )
        ciRecGens[i].beforeDestructor();
      end;
      i = i + 1;
    end;
  end;

  InitTDataCollector( _oper );

  ciRecGens[CI_OGSZ] = TOGSZRecGenerator( _oper, false, this ); 
  ciRecGens[CI_LOTTERY] = TLotteryRecGenerator( _oper, false, this );
  ciRecGens[CI_CERT] = TCertRecGenerator( _oper, false, this ); 
  ciRecGens[CI_ORVVZ] = TORVVZRecGenerator( _oper, false, this ); 
  ciRecGens[CI_COIN] = TCoinRecGenerator( _oper, false, this ); 
  ciRecGens[CI_INGOT] = TIngotRecGenerator( _oper, false, this ); 
  ciRecGens[CI_MISC] = TMiscRecGenerator( _oper, false, this ); 
end;
