
/*
**  Опердневник ф. 24. Голова
**
*/

import od_com, 
       od_total, 
       od_desk, 
       od_rep, 
       od_dep, 
       od_other, 
       od_exch, 
       od_brcol,
       chkprn, 
       rsd;

/* Базовый класс */

class TDiary( _oper )

  var
    dontSetDataReady = false, 
    collectors : TSet,  
    oper = _oper;

  macro setupPrinter

    var
      regPath = "RS-RETAIL\\ПЕЧАТИ\\ФОРМА_24",
      Type = V_STRING;

    checkPrinter( regPath, strFor( 0 ), "ШИРОКИЙ" );
/*    setPrintPort( "ШИРОКИЙ" ); */
  end;

  macro collectDataForCurr

    var
      i = 0;

    getRate;  

    while ( i < collectors.size )
      collectors.value( i ).proceed;
      i = i + 1;
    end;      
  end;

  macro collectData
    
    var i = 0;

    cleanupDataFile( oper );
    isCur = 0;
    currency.clear;
    currency.rec.Code_Currency = NATIONAL_CURR;
    if ( currency.getEQ )
      collectDataForCurr; 
    end;
    
    isCur = 1;
/*    currency.rewind;
    while ( currency.next )
      if (  ( currency.rec.Code_Currency != ANY_CURR      )
        and ( currency.rec.Code_Currency != NATIONAL_CURR )
        and ( currency.rec.CrDifrRate                     )
         )
        collectDataForCurr; 
      end;
    end;*/
    while (i < currencyList.size)
      currency.clear;
      currency.rec.Code_Currency = currencyList(i);
      if ( currency.getEQ )
        collectDataForCurr; 
      end;
      i = i + 1;
    end;
  end;

  macro report
  end;

  macro isDataReady

    return false;
  end;

  macro setDataReady( isReady )
  end; 

  macro proceed

    setupPrinter; 
    openDataFile;

    if ( newDataFile )
      setDataReady( false );
    end;

    if ( not isDataReady )
      collectData;
      if ( not dontSetDataReady )
        setDataReady( true );
      end;
    end;
    report;
  end;

  macro setupCurrencyList

    var i = 0;

    if (not currencyListCreated)
      currency.rewind;
      while ( currency.next )
        if (  ( currency.rec.Code_Currency != ANY_CURR      )
          and ( currency.rec.Code_Currency != NATIONAL_CURR )
          and ( currency.rec.CrDifrRate                     )
           )
          currencyList(i) = currency.rec.Code_Currency;
          i = i + 1;
        end;
      end;
      currencyListCreated = true;
    end;
  end;
  
  setupCurrencyList();
end;

/* Детальный ОД */

class ( TDiary ) TOperDiary( _oper, _showRests, _brigadeMode )

  var
    showRests = _showRests,
    brigadeMode = false;

  if( _brigadeMode != null )
    brigadeMode = _brigadeMode;
  end;

  macro collectDataForCurr
 
    totals.reset;
    totalsU.reset;

    collectDataForCurr;
    if ( ( showRests != null ) and showRests ) 
      desk.writeMoneyRests( oper );
    end;

    totals.write( oper );
    totalsU.write( oper );
  end;

/* RA 29-09-03 платы по ВОО обрабатываем наравне со всеми    
  macro prepareExRegPayments

    var  
      prepDC = TOperDC_ExchRegPayPrep( oper );

    prepDC.proceed; 
  end;
*/

  macro collectData

    var
      voa; 

    valTotals.reset;
/*  prepareExRegPayments; */
    collectData;
    valTotals.write( oper );

    if ( ( showRests != null ) and showRests ) 
      desk.writeValuesRests( oper );
    end; 
    if ( ( group.rec.Mode == GRM_IMMEDIATE ) and ( mode == 0 ) )
      voa = TOperDC_ValuesOnAccount( oper );
      voa.proceed;  
    end; 
  end;

  macro isDataReady
    if(
        (not newDataFile) and
        (
          grpMember.rec.ODIssued != ""
        )
      )
      return true;
    else
      return false;
    end;
  end;

  macro setDataReady( isReady )
    var cmd = RsdCommand( NULL, string("update dgroupmem_dbt gr set gr.t_ODIssued=:val where ",
                                    " gr.T_BRANCH=:branch and gr.T_DATE=:inDate and ",
                                    " gr.T_GROUP=:operBrigade and gr.T_OPER=:opr" ) );

    cmd.addParam( "val", RSDBP_IN );
    cmd.addParam( "branch", RSDBP_IN );
    cmd.addParam( "inDate", RSDBP_IN );
    cmd.addParam( "operBrigade", RSDBP_IN );
    cmd.addParam( "opr", RSDBP_IN );

    if ( isReady )
       cmd.value( "val" ) = "X";
    else
       cmd.value( "val" ) = strFor( 0 );
    end;
    cmd.value( "branch" ) = grpMember.rec.branch;
    cmd.value( "inDate" ) = grpMember.rec.Date;
    cmd.value( "operBrigade" ) = grpMember.rec.GROUP;
    cmd.value( "opr" ) = grpMember.rec.OPER;

    cmd.execute();
  end; 

  macro report

    var
      reporter = TOperReporter( oper, showRests );

    reporter.print; 
  end;

  findGroupMember( _oper );

  findGroup( operBrigade );
  initTDiary( _oper );
  collectors.insert( TOperDC_Dep( _oper ) );
  collectors.insert( TOperDC_Other( _oper, brigadeMode ) ); 
  if( brigadeMode ) /* RA 10-09-02 (SCR 9795) */
    collectors.insert( TOperDC_Exch( _oper, brigadeMode ) );
  end;
  desk.getNativeGroupAndSafe;
end;

/* Сводный ОД */

class ( TDiary ) TBrigadeDiary

  macro rubOdShouldBeIssued

    return ( group.rec.Mode == GRM_IMMEDIATE ) or ( index( desk.deskSubj.rec.Reports, "R" ) != 0 );
  end;
 
  macro curOdShouldBeIssued

    return ( group.rec.Mode == GRM_IMMEDIATE ) or ( index( desk.deskSubj.rec.Reports, "C" ) != 0 );
  end;
 
  macro odShouldBeIssued

    return rubOdShouldBeIssued or curOdShouldBeIssued;
  end;

  macro collectDataForCurr

    var
      deskOps = TBrigadeDC_Desk, 
      i = 0;

    if ( currency.rec.Code_Currency == 0 )
      if (  not rubOdShouldBeIssued )
        return;
      end; 
    else
      if ( not curOdShouldBeIssued )
        return;
      end; 
    end;

    getRate;

    totals.reset;
    totalsU.reset;
    deskOps.proceed;   
    totals.write( noOper );
    totalsU.write( noOper );

    collectDataForCurr;

    desk.writeMoneyRests;
  end;

  macro collectDataForMember

    var
      md = TOperDiary( grpMember.rec.Oper, false, true );

    if ( not md.isDataReady )
      group.rec.ODIssued = "";
      if ( not group.Update( ) )
        MsgBox( "err" );
      end;

      md.collectData;
      md.setDataReady( true );
    end;
  end;

  macro unsetDataReadyForGrpMembers
    
    var
      recFound;

    var cmd = RsdCommand( NULL, string("update dgroupmem_dbt gr set gr.t_ODIssued=chr(0) where ",
                                    " gr.T_BRANCH=:branch and gr.T_DATE=:inDate and ",
                                    " gr.T_GROUP=:operBrigade" ) );

    cmd.addParam( "branch", RSDBP_IN );
    cmd.addParam( "inDate", RSDBP_IN );
    cmd.addParam( "operBrigade", RSDBP_IN );

    cmd.value( "branch" ) = branch;
    cmd.value( "inDate" ) = {curdate};
    cmd.value( "operBrigade" ) = operBrigade;

    cmd.execute();


    /*var cmd, rs;

    cmd = RsdCommand( NULL, String("select gr.T_BRANCH as BRANCH, ",
                                   "       gr.T_DATE as   GRDATE, ",
                                   "       gr.T_GROUP as  GRGROUP, ",
                                   "       gr.T_OPER as   OPER, ",
                                   "       gr.T_LINKED as LINKED, ",
                                   "       gr.T_VKL_NAC as VKL_NAC, ",
                                   "       gr.T_VKL_FOR as VKL_FOR, ",
                                   "       gr.T_ANOTH_NAC as ANOTH_NAC, ",
                                   "       gr.T_ANOTH_FOR as ANOTH_FOR, ",
                                   "       gr.T_CEN_BUMAG as CEN_BUMAG, ",
                                   "       gr.T_VOO as VOO, ",
                                   "       gr.T_ODISSUED as ODISSUED, ",
                                   "       gr.T_DAYCLOSED as DAYCLOSED, ",
                                   "       rtg.T_HEADID as HEADID, ",
                                   "       rtg.T_SAFEID as SAFEID, ",
                                   "       rtg.T_ISACTIVE as ISACTIVE, ",
                                   "       rtg.T_DESC as T_DESC, ",
                                   "       rtg.T_CURR as CURR, ",
                                   "       rtg.T_MODE as T_MODE, ",
                                   "       rtg.T_ODISSUED as ODISSUED, ",
                                   "from dgroupmem_dbt gr, drtgroup_dbt rtg ",
                                   "where gr.T_BRANCH=:branch and gr.T_DATE=:inDate and gr.T_GROUP=:operBrigade ",
                                   "      and rtg.T_BRANCH=gr.T_GROUP and rtg.T_TYPE=1 and rtg.T_Date=gr.T_DATE and rtg.T_ID=gr.T_GROUP" ) );

    rs = RsdRecordset( cmd );

    cmd.addParam( "branch", RSDBP_IN );
    cmd.addParam( "inDate", RSDBP_IN );
    cmd.addParam( "operBrigade", RSDBP_IN );

    cmd.value( "branch" ) = branch;
    cmd.value( "inDate" ) = {curdate};
    cmd.value( "operBrigade" ) = operBrigade;

    cmd.execute;

    while ( rs.moveNext() )
      grpMember.rec.BRANCH = rs.value("BRANCH");
      grpMember.rec.Date = rs.value("GRDATE");
      grpMember.rec.GROUP = rs.value("GRGROUP");
      grpMember.rec.OPER = rs.value("OPER");
      grpMember.rec.LINKED = rs.value("LINKED");
      grpMember.rec.VKL_NAC = rs.value("VKL_NAC");
      grpMember.rec.VKL_FOR = rs.value("VKL_FOR");
      grpMember.rec.ANOTH_NAC = rs.value("ANOTH_NAC");
      grpMember.rec.ANOTH_FOR = rs.value("ANOTH_FOR");
      grpMember.rec.CEN_BUMAG = rs.value("CEN_BUMAG");
      grpMember.rec.VOO = rs.value("VOO");
      grpMember.rec.ODISSUED = rs.value("ODISSUED");
      grpMember.rec.DAYCLOSED = rs.value("DAYCLOSED");
      group.rec.BRANCH = grpMember.rec.BRANCH;
      group.rec.Date = grpMember.rec.Date;
      group.rec.Type = 1;
      group.rec.ID = grpMember.rec.GROUP;
      group.rec.HEADID = rs.value("HEADID");
      group.rec.SAFEID = rs.value("SAFEID");
      group.rec.ISACTIVE = rs.value("ISACTIVE");
      group.rec.DESC = rs.value("T_DESC");
      group.rec.CURR = rs.value("CURR");
      group.rec.MODE = rs.value("T_MODE");
      group.rec.ODISSUED = rs.value("ODISSUED");

      TOperDiary( grpMember.rec.Oper, false, true ).setDataReady(false);  
    end;*/
  end;

  macro collectDataForGrpMembers
    
    var
      recFound;

    if ( newDataFile )
    /*if ( newDataFile ) RA 10-09-02 (SCR 9795)
    если сводный ОД формируется после детального, то данные нужно собрать заново */
      group.rec.ODIssued = ""; // При проведениии операции поле обнуляется только у groupmem
      if ( not group.Update( ) )
        MsgBox( "err" );
      end;

      unsetDataReadyForGrpMembers; 
    /*end;*/
    end;

    grpMember.clear;
    grpMember.rec.Branch = branch;
    grpMember.rec.Date = {curdate};
    grpMember.rec.Group = operBrigade;
    recFound = grpMember.getGE;
    while ( recFound 
      and ( grpMember.rec.Branch == branch )
      and ( grpMember.rec.Date == {curdate} )
      and ( grpMember.rec.Group == operBrigade ) )
      collectDataForMember;
      recFound = grpMember.next;
    end;
  end;

  macro collectData

    var
      valTurns = TBrigadeDC_ValTurns;

    /* Сначала собрать данные по всем членам смены */
//    if ( odShouldBeIssued )  
//      collectDataForGrpMembers;
//    end;

    cleanupDataFile( noOper ); 
    valTotals.reset;
    collectData;
    valTotals.write( noOper );

    valTurns.proceed;

    if ( odShouldBeIssued )  
      desk.writeValuesRests;
    end;
  end;

  macro report

    var
      reporter,
      recFound;
    
    if ( odShouldBeIssued )
      if (EXPANDED_BRIGADE_REPORT)
        grpMember.clear;
        grpMember.rec.Branch = branch;
        grpMember.rec.Date = {curdate};
        grpMember.rec.Group = operBrigade;
        recFound = grpMember.getGE;
        while ( recFound 
          and ( grpMember.rec.Branch == branch )
          and ( grpMember.rec.Date == {curdate} )
          and ( grpMember.rec.Group == operBrigade ) )
            reporter = TOperReporter( grpMember.rec.Oper, false );
            reporter.print; 
          recFound = grpMember.next;
        end;
      end;

      reporter = TBrigadeReporter;
      reporter.print; 
    end; 
  end;

  macro isDataReady

    return ( (group.rec.ODIssued != "") and (not newDataFile) );
  end;

  macro setDataReady( isReady )

    if ( isReady )
      group.rec.ODIssued = "X";
    else
      group.rec.ODIssued = "";
    end;
    group.update;
  end; 

  macro proceed
   
    if ( desk.safe )
      if ( not desk.findDeskSubj( desk.safe ) )
        exitOnError( "Не найден субъект кассы: " + desk.safe );
      end;
    end;
    if ( odShouldBeIssued )  
      openDataFile;
      collectDataForGrpMembers;
    end;
    proceed;
  end;

  macro setupCurrencyList

    var i = 0;
    var cmd, rs;

    if (not currencyListCreated)
      cmd = RsdCommand( NULL, string(
        "select CodeCurr from ( ",
        "  select t_Code_Currency as CodeCurr from dsbdepdoc_dbt ",
        "    where t_FNCash = :branch and t_Date_Document = :docDate and t_IsCur = 1 and t_Code_Currency not in (0, -1) and t_Brigade = :brigade ",
        "  union ",
        "  select t_CodCur as CodeCurr from dpay_doc_dbt ",
        "    where t_FNCash = :branch and t_Date_Document = :docDate and t_IsCur = 1 and t_CodCur not in (0, -1) and t_Brigade = :brigade ",
        "  union ",
        "  select vl.t_CodIntValue as CodeCurr from dsb_casdc_dbt dc, dsb_casvl_dbt vl ", 
        "    where vl.t_RefValue = dc.t_RefValue and vl.t_TypeValue = 1 ",
        "      and dc.t_Branch = :branch and dc.t_CashDateDoc = :docDate and vl.t_CodIntValue not in (0, -1) and dc.t_Brigade = :brigade ",
        "  union ",
        "  select t_IncomeCodIntValue as CodeCurr from dexoperat_dbt ",
        "    where t_Branch = :branch and t_Date = :docDate and t_IncomeTypeValue = 1 and t_IncomeCodIntValue not in (0, -1) and t_Brigade = :brigade ",
        "  union ",
        "  select t_OutCodIntValue as CodeCurr from dexoperat_dbt ",
        "    where t_Branch = :branch and t_Date = :docDate and t_OutTypeValue = 1 and t_OutCodIntValue not in (0, -1) and t_Brigade = :brigade ",
        "  union ",
        "  select t.t_Code_Currency as CodeCurr from dtrn_payf_dbt t, dgroupmem_dbt g ",
        "    where g.t_Date = t_DateDocumentFilial and g.t_Oper = t.t_Oper and g.t_Branch = t.t_FNCash ",
        "      and t.t_FNCash = :branch and t_DateDocumentFilial = :docDate and t.t_FlagCur = 1 and t.t_Code_Currency not in (0, -1) and g.t_Group = :brigade ",
        "  union ",
        "  select vl.t_CodIntValue as CodeCurr from dsb_casac_dbt ac, dsb_casvl_dbt vl ",
        "    where vl.t_RefValue = ac.t_RefValue and vl.t_TypeValue = 1 ",
        "      and ac.t_Branch = :branch and ac.t_Date = :docDate and vl.t_CodIntValue not in (0, -1) and ac.t_CashOper = /*:cashOper*/ " + GetSQLString( desk.safe ) +
        "      and ac.t_RestMoney != 0 ",
        ") d, dcurrency_dbt c ",
        "  where d.CodeCurr = c.t_Code_Currency and c.t_CrDifrRate != chr(0) " ));

      cmd.addParam( "branch", RSDBP_IN );
      cmd.addParam( "docDate", RSDBP_IN );
      cmd.addParam( "brigade", RSDBP_IN );
//      cmd.addParam( "cashOper", RSDBP_IN );

      cmd.value( "branch" ) = branch;
      cmd.value( "docDate" ) = {curdate};
      cmd.value( "brigade" ) = operBrigade;
//      cmd.value( "cashOper" ) = desk.safe;

      cmd.execute();

      rs = RsdRecordset( cmd );
      while ( rs.moveNext() )
        currencyList(i) = rs.value("CodeCurr");
        i = i + 1;
      end;
      currencyListCreated = true;
    end;
  end;
  
  findGroup( operBrigade );
  desk.getNativeGroupAndSafe;
  initTDiary( 0 );
  collectors.insert( TBrigadeDC_Dep );
  collectors.insert( TBrigadeDC_Other );
  collectors.insert( TBrigadeDC_Exch );
  collectors.insert( TBrigadeDC_Conv );
  collectors.insert( TBrigadeDC_FBDep );
  collectors.insert( TBrigadeDC_MoneyTurns );
end;

/* По вкладным операциям, инициированным другими филиалами */

class ( TDiary ) TFBIDepDiary

  macro report

    var
      reporter = TFBIDepReporter;

    reporter.print; 
  end;

  macro proceed

    operBrigade = 0;
    proceed; 
    operBrigade = getOperBrigade; 
  end;

  initTDiary( noOper2 );
  collectors.insert( TFBIDC_Dep ); 
end;
