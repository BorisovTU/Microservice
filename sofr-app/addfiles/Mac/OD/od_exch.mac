
/*
**  Опердневник ф.24. Валютообменные операции
**
*/

import exchangeInter, od_com, od_total;

const
  ATT_TO_CREDIT = 1, 
  ATT_TO_DEBET = 2; 

const
  EXPT_COMMISSION = 1,   
  EXPT_TAX = 2, 
  EXPT_INCTAX = 3;

var
  exPay, 
  operset = TBFile( "exopset.dbt", "r", 0, null, "exchange.def" );

macro findExchOp( branch, op, subOp )

  operset.clear;
  operset.rec.Branch    = branch;
  operset.rec.Kind_Oper = op;
  operset.rec.SubOper   = subOp;

  if ( operset.getEQ )
    return true;
  end;
  operset.rec.Branch    = 0;
  return operset.getEQ;
end;

macro isIncomingValueUnpayable( op )

  return ( op == CDF_OperUnpayCurrBuy )
      or ( op == CDF_OperPayDocBuy )
      or ( op == CDF_OperPayDocBuyAcc )
      or ( op == CDF_OperExpert )
      or ( op == CDF_OperIncasso )
      or ( op == CDF_OperPayDocExpert )
      or ( op == CDF_OperPayDocIncasso )
      or ( op == CDF_OperPayDocBuyCurr )
      or ( op == CDF_OperPayDocBuyCurrAcc )
      or ( op == CDF_OperChange );
end;

class ( TDataCollector ) TOperBaseRegDC_Exch( _oper )

  var
    r = TBFile( "reestr.dbt", "r", 4, null, "exchange.def" ), 
    exOp = TBFile( "exoperat.dbt", "r", 6, null, "exchange.def" );

  macro filter

    if ( r.rec.Brigade != operBrigade )
      return false;
    end;

    if ( r.rec.Oper != oper )
      return false;
    end;

    if ( r.rec.State_Ref == CDF_ReestrStorno )
      return false;
    end;

    if ( ( r.rec.Kind_Oper == CDF_OperCardGive ) 
      or ( r.rec.Kind_Oper == CDF_OperCardTake ) )
      return false;
    end;

    return true;
  end;

  macro filterExOp

    if ( exOp.rec.Action != D_STORN ) 
      if ( not isConfirmed( not exOp.rec.NotConfirmed ) )
        return false;
      end;
    end;

    if ( exOp.rec.Action == D_DELETE )
      return false;
    end;

    /* Непроведенный документ */
    if ( ( exOp.rec.IsSuspended != "" ) and ( exOp.rec.IsSuspended != "X" ) )
      return false;
    end;

    return true;
  end;

  macro makeGround
    
    if ( findExchOp( r.rec.Branch, r.rec.Kind_Oper, r.rec.SubOper ) )
      return operset.rec.Name;
    end;
    return "* Неизвестная операция *";  
  end;

  macro processRegister
  end;

  macro processRegisters
    
    var
      recFound;

    r.clear;
    r.rec.Branch  = branch;
    r.rec.CurDate = {curdate};

    r.addFilter( "t_Branch = " + string( branch ) +
                 " and t_CurDate = " + sqlDateToStr( {curdate} ) );

    recFound = r.getGE;
    while ( recFound
      and ( r.rec.Branch == branch )
      and ( r.rec.CurDate == {curdate} ) )
      if ( filter )
        processRegister;
      end; 
      recFound = r.next;
    end;
    r.dropFilter;
  end;

  initTDataCollector( _oper );
end;

class ( TOperBaseRegDC_Exch ) TOperDC_Exch( _oper )

  var
    exchTotals = TSubTotals( _oper ), 
    exchTotalsU = TSubTotals( _oper );
  
  macro getValTurns( valCredit, valDebet, valCreditCV, valDebetCV )

    var
      cred, deb, credCV, debCV,
      recFound;

    valCredit = valDebet = valCreditCV = valDebetCV = $0;

    exOp.clear;
    exOp.rec.Branch = branch;
    exOp.rec.Reestr_Ref = r.rec.ID;

    exOp.addFilter( "t_Branch = " + string( branch ) +
                    " and t_Reestr_Ref = " + string( r.rec.ID ) +
                    " and t_Action != 2 " +
                    " and (t_Action = 11 or 1 = " + string(boolToInt(not {MakeDeskDocs})) + " or t_NotConfirmed = chr(0)) " +
                    " and t_IsSuspended in (chr(0), 'X')" );

    recFound = exOp.getGE;
    while ( recFound
      and ( exOp.rec.Branch == branch )
      and ( exOp.rec.Reestr_Ref == r.rec.ID ) )
      if ( filterExOp )
        desk.getValuesTurnsForOp( exOp.rec.ApplicationKind, 
                                  exOp.rec.ApplicationKey, 
                                  cred, deb, credCV, debCV );
/* 23.12.03 KIN обнуляем количество дорожных чеков при оплате */       
        
        if( ( exOp.rec.Kind_Oper == CDF_OperPayDocBuy )        or 
            ( exOp.rec.Kind_Oper == CDF_OperPayDocBuyCurr )    or
            ( exOp.rec.Kind_Oper == CDF_OperPayDocBuyAcc )     or
            ( exOp.rec.Kind_Oper == CDF_OperPayDocBuyCurrAcc )
          )

          cred = 0;
        
        end;
/* End correct */        

        valCredit = valCredit + cred;  
        valDebet = valDebet + deb;  
        valCreditCV = valCreditCV + credCV;  
        valDebetCV = valDebetCV + debCV;  
      end;
      recFound = exOp.next;
    end;
    exOp.dropFilter;

    setParm( 1, valCredit );
    setParm( 2, valDebet );
    setParm( 3, valCreditCV );
    setParm( 4, valDebetCV );
  end;

  macro getValTurnsAttachment

    if ( ( r.rec.IncomeSum == $0 ) and ( r.rec.OutSum != $0 ) )
       return ATT_TO_DEBET;
    end;
    return ATT_TO_CREDIT;
  end;

  macro processRegister
    
    var
      v = TRecHandler( "od_data.1" );

    var
      d, 
      att, 
      currIn = desk.getValNativeCurr2( r.rec.IncomeRefVal ), 
      currOut  = desk.getValNativeCurr2( r.rec.OutRefVal ), 
      valCredit, valDebet, valCreditCV, valDebetCV;

    if ( ( currency.rec.Code_Currency != currOut ) and ( currency.rec.Code_Currency != currIn ) ) 
      return;
    end;

    v.setRecordAddr( odData );

    initDataRec( ODT_OPERATION, 
                 ODSTO_EXCHANGE_OP, 
                 currency.rec.Code_Currency, 
                 oper, 
                 maxTime );

    v.clear;

    v.rec.ground = makeGround;

    if ( currency.rec.Code_Currency == currOut )
      if ( not desk.isVal( r.rec.OutRefVal ) )
        if ( currOut != NATIONAL_CURR )
          v.rec.Debet = r.rec.OutSum;
          v.rec.DebetR = cur2rub( v.rec.Debet );
        else
          /*if ( bankStd )*/
            v.rec.Debet = r.rec.OutSum;
          /* RA 10-09-02 (SCR 9795)
          else
            if ( r.rec.Rate < r.rec.CBRate ) /* RA 29-07-02 SCR 7830 */
              v.rec.Debet = Sumconv( r.rec.IncomeSum, r.rec.Rate );
              d = r.rec.OutSum - Sumconv( r.rec.IncomeSum, r.rec.CBRate );
              if ( d > 0 )
                v.rec.MemDebetRDiff = d;
              else
                v.rec.MemCreditRDiff = -d;
              end;
            else
              v.rec.Debet = Sumconv( r.rec.IncomeSum, r.rec.CBRate );
              d = r.rec.OutSum - v.rec.Debet;
              if ( d > 0 )
                v.rec.DebetRDiff = d;
              else
                v.rec.CreditRDiff = -d;
              end;
            end;
          end; 
          */
        end;
      end;
      if ( ( r.rec.Kind_Oper == CDF_OperPayDocSale        ) or 
           ( r.rec.Kind_Oper == CDF_OperPayDocSaleCurr    )
         )
        v.rec.Credit = r.rec.OutSum;
        if ( currOut != NATIONAL_CURR )
          v.rec.CreditR = cur2rub( v.rec.Credit );
        end;
      elif ( ( r.rec.Kind_Oper == CDF_OperPayDocSaleAcc     ) or  
             ( r.rec.Kind_Oper == CDF_OperPayDocSaleCurrAcc )
         )
        v.rec.Debet = v.rec.DebetR = $0;
      end;
    end;

    if ( currency.rec.Code_Currency == currIn )
      if ( not desk.isVal( r.rec.OutRefVal ) )
        if ( currIn != NATIONAL_CURR )
          v.rec.Credit = r.rec.IncomeSum;
          v.rec.CreditR = cur2rub( v.rec.Credit );
        else
          /*if ( bankStd )*/
            v.rec.Credit = r.rec.IncomeSum;
          /* RA 10-09-02 (SCR 9795)
          else
            if ( r.rec.Rate < r.rec.CBRate ) /* RA 29-07-02 SCR 7830 */
              v.rec.Credit = Sumconv( r.rec.OutSum, r.rec.Rate );
              d = r.rec.IncomeSum - Sumconv( r.rec.OutSum, r.rec.CBRate );
              if ( d > 0 )
                v.rec.MemCreditRDiff = d;
              else
                v.rec.MemDebetRDiff = -d;
              end;
            else
              v.rec.Credit = Sumconv( r.rec.OutSum, r.rec.CBRate );
              d = r.rec.IncomeSum - v.rec.Credit;
              if ( d > 0 )
                v.rec.CreditRDiff = d;
              else
                v.rec.DebetRDiff = -d;
              end;
            end;
          end;
          */
        end;
      end;
      /* RA 17-01-02 */
      if ( ( r.rec.Kind_Oper == CDF_OperPayDocSaleCurr    )
         )
        v.rec.Credit = r.rec.IncomeSum * 2; /* приход валюты + приход ПД (получились из бланков) */
        if ( currOut != NATIONAL_CURR )
          v.rec.CreditR = cur2rub( v.rec.Credit );
        end;
      /* RA 31-07-02 SCR 9585 */
      elif ( ( r.rec.Kind_Oper == CDF_OperPayDocBuy        ) or 
             ( r.rec.Kind_Oper == CDF_OperPayDocBuyCurr    ) or
             ( r.rec.Kind_Oper == CDF_OperPayDocBuyAcc     ) or
             ( r.rec.Kind_Oper == CDF_OperPayDocBuyCurrAcc )
            )

/*        v.rec.Credit = v.rec.CreditR = $0; */

/* 23.12.03 KIN считаем обороты по дор. чекам */      
     
          if ( currOut != NATIONAL_CURR )
            v.rec.CreditR = cur2rub( v.rec.Credit );
          end;
      
        /* End correct */
      end;
    end;

    if ( isIncomingValueUnpayable( r.rec.Kind_Oper ) and ( currency.rec.Code_Currency == currIn ) )
      exchTotalsU.credit = exchTotalsU.credit + v.rec.Credit + v.rec.CreditRDiff;
      if ( currIn != NATIONAL_CURR )
        exchTotalsU.creditR = exchTotalsU.creditR + v.rec.CreditR;
      end; 
    else
      exchTotals.credit = exchTotals.credit + v.rec.Credit + v.rec.CreditRDiff;
      if ( currIn != NATIONAL_CURR )
        exchTotals.creditR = exchTotals.creditR + v.rec.CreditR;
      end; 
    end; 

    exchTotals.debet = exchTotals.debet + v.rec.Debet + v.rec.DebetRDiff;
    if ( currOut != NATIONAL_CURR )
      exchTotals.debetR = exchTotals.debetR + v.rec.DebetR;
    end;

    att = getValTurnsAttachment;

    if ( ( ( att == ATT_TO_CREDIT ) and ( currency.rec.Code_Currency == currIn ) )
      or ( ( att == ATT_TO_DEBET )  and ( currency.rec.Code_Currency == currOut ) ) )
      getValTurns( valCredit, valDebet, valCreditCV, valDebetCV );

      v.rec.ValCredit = valCredit;
      v.rec.ValDebet = valDebet;
      v.rec.ValCreditCV = valCreditCV;
      v.rec.ValDebetCV = valDebetCV;

      exchTotals.valCredit = exchTotals.valCredit + valCredit;
      exchTotals.valDebet = exchTotals.valDebet + valDebet;
      exchTotals.valCreditCV = exchTotals.valCreditCV + valCreditCV;
      exchTotals.valDebetCV = exchTotals.valDebetCV + valDebetCV;
    end;

    if ( ( v.rec.Credit != 0 ) or ( v.rec.Debet != 0  )
      or ( v.rec.ValCredit != 0 ) or ( v.rec.ValDebet != 0  )
      or ( v.rec.ValCreditCV != 0 ) or ( v.rec.ValDebetCV != 0  ) )
      odData.insert( v.recSize );
    end;
  end;

  macro proceed
                    
    message( string( oper ) + ": Сбор данных: Валютообменные операции" );
    exchTotals.reset;
    exchTotalsU.reset;

    processRegisters;

    exchTotals.writeAsGlobal( ODSTT_TURNS_EXCHANGE );
    updateGlobalTotals( exchTotals );
    exchTotalsU.writeAsGlobal( ODSTT_UNPAY_OFFS + ODSTT_TURNS_EXCHANGE );
    updateGlobalTotalsU( exchTotalsU );

    exchTotals.add( exchTotalsU );
    exchTotals.write( ODSTO_EXCHANGE_TOT );

    message( "" );
  end;

  initTOperBaseRegDC_Exch( _oper );
end;

/* RA 29-09-03 платы по ВОО обрабатываем наравне со всеми    
class ( TOperBaseRegDC_Exch ) TOperDC_ExchRegPayPrep( _oper )

  var
    payDoc = TBFile( "pay_doc.dbt", "r", 2 ), 
    payKind = TBFile( "pay_kind.dbt", "r", 0 );

  macro findPayDoc( appKind, appKey )

    payDoc.rec.iApplicationKind = appKind;
    payDoc.rec.ApplicationKey = appKey;
    return payDoc.getEQ;
  end;

  macro findPayKind

    payKind.rec.IsCur = payDoc.rec.IsCur;
    payKind.rec.GroupOpert = payDoc.rec.GroupOpert;
    payKind.rec.NumOperat = payDoc.rec.NumOpert;
    return payKind.getEQ;
  end;

  macro getValTurns( valCredit, valDebet, valCreditCV, valDebetCV )

    var
      recFound, 
      cred, deb, credCV, debCV, 
      bunch = TDocBunch( exOp.rec.ApplicationKind, exOp.rec.ApplicationKey );

    valCredit = valDebet = valCreditCV = valDebetCV = $0;

    desk.cashLink.keyNum =  1;

    recFound = bunch.firstDoc; 
    while ( recFound )
      if ( ( bunch.docValueRef == 0 ) and ( bunch.docAppKind == SB_CASHOPERT ) )
        if ( findPayDoc( bunch.docAppKind, bunch.docAppKey ) )
          if ( findPayKind )
            if ( payKind.rec.Type_Comis == 0 )
              cred = deb = credCV = debCV = $0;
              desk.getValuesTurnsForOp( payDoc.rec.iApplicationKind, 
                                        payDoc.rec.ApplicationKey, 
                                        cred, 
                                        deb, 
                                        credCV, 
                                        debCV );
              valCredit = valCredit + cred;
              valDebet = valDebet + deb;
              valCreditCV = valCreditCV + credCV;
              valDebetCV = valDebetCV + debCV;
            end;  
          end;
        end;
      end; 
      recFound = bunch.nextDoc;
    end;

    setParm( 1, valCredit );
    setParm( 2, valDebet );
    setParm( 3, valCreditCV );
    setParm( 4, valDebetCV );
  end;

  macro findRec( type, currCode )

    exPay.clear;
    exPay.rec.CurrCode = currCode;
    exPay.rec.RegID = r.rec.ID;       
    exPay.rec.PaymentType = type;
    return exPay.getEQ;
  end;

  macro writeRec( type, currCode, sum, valCredit, valDebet, valCreditCV, valDebetCV )

    var
      inCurrName = "", outCurrName = "", currNames; 

    if ( r.rec.IncomeRefVal != 0 )
      if ( desk.findCashValueForRef( r.rec.IncomeRefVal ) ) 
        if ( desk.cashVal.rec.CodIntValue != 0 )
          inCurrName = desk.cashVal.rec.NameValue;
        end;  
      else
        inCurrName = "???";
      end;
    end; 

    if ( r.rec.OutRefVal != 0 )
      if ( desk.findCashValueForRef( r.rec.OutRefVal ) ) 
        if ( desk.cashVal.rec.CodIntValue != 0 )
          outCurrName = desk.cashVal.rec.NameValue;
        end; 
      else
        outCurrName = "???";
      end;
    end; 

    if ( ( inCurrName != "" ) and ( outCurrName != "" ) )
      currNames = outCurrName + " -> " + inCurrName;  
    elif ( inCurrName != "" )
      currNames = inCurrName;
    else
      currNames = outCurrName;
    end;

    exPay.clear;
    exPay.rec.CurrCode = currCode;
    exPay.rec.RegID = r.rec.ID;       
    exPay.rec.PaymentType = type;
    exPay.rec.Sum = sum;
    exPay.rec.ValCredit = valCredit;
    exPay.rec.ValDebet = valDebet;
    exPay.rec.ValCreditCV = valCreditCV;
    exPay.rec.ValDebetCV = valDebetCV;
    exPay.rec.Desc = makeGround + " (" + currNames + "): ";
    if ( type == EXPT_COMMISSION )
      exPay.rec.Desc = exPay.rec.Desc + "комиссия";
    elif ( type == EXPT_TAX )
      exPay.rec.Desc = exPay.rec.Desc + "налог";
    elif ( type == EXPT_INCTAX )
      exPay.rec.Desc = exPay.rec.Desc + "подоход. налог";
    else
      exPay.rec.Desc = exPay.rec.Desc + "???";
    end;
    exPay.insert;
  end;

  macro addToRec( type, currCode, sum, valCredit, valDebet, valCreditCV, valDebetCV )

    if ( findRec( type, currCode ) )
      exPay.rec.Sum = exPay.rec.Sum + sum;
      exPay.rec.ValCredit = exPay.rec.ValCredit + valCredit;
      exPay.rec.ValDebet = exPay.rec.ValDebet + valDebet;
      exPay.rec.ValCreditCV = exPay.rec.ValCreditCV + valCreditCV;
      exPay.rec.ValDebetCV = exPay.rec.ValDebetCV + valDebetCV;
      exPay.update; 
    else
      writeRec( type, currCode, sum, valCredit, valDebet, valCreditCV, valDebetCV );
    end;       
  end;

  macro processCommissions

    var
      currCode, 
      valCredit = $0, valDebet = $0, valCreditCV = $0, valDebetCV = $0, 
      recFound;

    exOp.clear;
    exOp.rec.Branch = branch;
    exOp.rec.Reestr_Ref = r.rec.ID;
    recFound = exOp.getGE;
    while ( recFound
      and ( exOp.rec.Branch == branch )
      and ( exOp.rec.Reestr_Ref == r.rec.ID ) )
      if ( filterExOp )
        if ( exOp.rec.ComAmount != $0 )
          if ( desk.findCashValueForRef( exOp.rec.ComCurrRefVal ) )
            currCode = desk.cashVal.rec.CodIntValue;
            getValTurns( valCredit, valDebet, valCreditCV, valDebetCV );
            addToRec( EXPT_COMMISSION, currCode, exOp.rec.ComAmount, valCredit, valDebet, valCreditCV, valDebetCV );
          end;
        end;
      end;
      recFound = exOp.next;
    end;
  end;

  macro processRegister

    if( r.rec.TaxSum != $0 )
      writeRec( EXPT_TAX, NATIONAL_CURR, r.rec.TaxSum, $0, $0, $0, $0 );
    end; 
    if( r.rec.IncTaxSum != $0 )
      writeRec( EXPT_INCTAX, NATIONAL_CURR, r.rec.IncTaxSum, $0, $0, $0, $0 );
    end;
    processCommissions;
  end;

  macro cleanupExPay
  
    exPay.rewind;
    while ( exPay.next )
      exPay.delete;   
    end;
  end; 

  macro proceed

    var
      pathname = workDir + "od_expay." + {CNum}, 
      mode = "w", 
      exPayNeedsCleanup = false;              
                    
    message( string( oper ) + ": Сбор данных: Валютообменные операции - комиссии и налоги" );

    if ( not existFile( pathname ) )
      mode = mode + "c+";
    else
      exPayNeedsCleanup = true;
    end;

    exPay = TBFile( "od_expay.dbt", mode, 0, pathname );
    if ( exPayNeedsCleanup )
      cleanupExPay;  
    end;
      
    processRegisters;

    message( "" );
  end;
         
  initTOperBaseRegDC_Exch( _oper );
end;
*/

class ( TDataCollector ) TOperDC_ExchOther( _oper )

  var
    exOp = TBFile( "exoperat.dbt", "r", 4, null, "exchange.def" ), 
    exchOtherTotals = TSubTotals( _oper ), 
    exchOtherTotalsU = TSubTotals( _oper );

  macro filter

    if ( operset.rec.ReestrType )
      return false;
    end;
   
    if ( exOp.rec.Action != D_STORN ) 
      if ( not isConfirmed( not exOp.rec.NotConfirmed ) )
        return false;
      end;
    end;

    if ( exOp.rec.Action == D_DELETE )
      return false;
    end;

    /* Непроведенный документ */
    if ( ( exOp.rec.IsSuspended != "" ) and ( exOp.rec.IsSuspended != "X" ) )
      return false;
    end;

    return true;
  end;

  macro makeGround

    return trim( operset.rec.Name + " " + 
                 makeFio( exOp.rec.Sname, exOp.rec.Name, exOp.rec.Pname ) );
  end;

  macro getValTurnsAttachment

    if ( ( exOp.rec.IncomeAmount == $0 ) and ( exOp.rec.OutAmount != $0 ) )
       return ATT_TO_DEBET;
    end;
    return ATT_TO_CREDIT;
  end;

  macro processDoc

    var
      v = TRecHandler( "od_data.1" );

    var
      att, 
      currIn = desk.getValNativeCurr2( exOp.rec.IncomeRefVal ), 
      currOut  = desk.getValNativeCurr2( exOp.rec.OutRefVal ), 
      valCredit, valDebet, valCreditCV, valDebetCV;

    if ( ( currency.rec.Code_Currency != currOut ) and ( currency.rec.Code_Currency != currIn ) ) 
      return;
    end;

    v.setRecordAddr( odData );

    initDataRec( ODT_OPERATION, 
                 ODSTO_OTHER_OP, 
                 currency.rec.Code_Currency, 
                 oper, 
                 getDocumentTime( exOp.rec.ApplicationKey ) );

    odData.rec.Processing = PROC_SUM_UP;
    odData.rec.Label = "oth:";

    v.clear;

    v.rec.ground = makeGround;

    if ( currency.rec.Code_Currency == currOut )
      if ( not desk.isVal( exOp.rec.OutRefVal ) )
        v.rec.Debet = exOp.rec.OutAmount;
        if ( currOut != NATIONAL_CURR )
          v.rec.DebetR = cur2rub( v.rec.Debet );
        end;
        if ( ( exOp.rec.Kind_Oper == CDF_OperPayDocSale        ) or 
             ( exOp.rec.Kind_Oper == CDF_OperPayDocSaleCurr    )
           )
          v.rec.Credit = exOp.rec.OutAmount;
          if ( currOut != NATIONAL_CURR )
            v.rec.CreditR = cur2rub( v.rec.Credit );
          end;
        end;
      end;
    end;

    if ( currency.rec.Code_Currency == currIn )
      if ( not desk.isVal( exOp.rec.OutRefVal ) )
        v.rec.Credit = exOp.rec.IncomeAmount;
        if ( currIn != NATIONAL_CURR )
          v.rec.CreditR = cur2rub( v.rec.Credit );
        end;
      end;
    end;

    if ( isIncomingValueUnpayable( exOp.rec.Kind_Oper ) )
      exchOtherTotalsU.credit = exchOtherTotalsU.credit + v.rec.Credit;
      if ( currIn != NATIONAL_CURR )
        exchOtherTotalsU.creditR = exchOtherTotalsU.creditR + v.rec.CreditR;
      end; 
    else
      exchOtherTotals.credit = exchOtherTotals.credit + v.rec.Credit;
      if ( currIn != NATIONAL_CURR )
        exchOtherTotals.creditR = exchOtherTotals.creditR + v.rec.CreditR;
      end; 
    end; 

    exchOtherTotals.debet = exchOtherTotals.debet + v.rec.Debet;
    if ( currIn != NATIONAL_CURR )
      exchOtherTotals.debetR = exchOtherTotals.debetR + v.rec.DebetR;
    end;

    att = getValTurnsAttachment;

    if ( ( ( att == ATT_TO_CREDIT ) and ( currency.rec.Code_Currency == currIn ) )
      or ( ( att == ATT_TO_DEBET )  and ( currency.rec.Code_Currency == currOut ) ) )

      desk.getValuesTurnsForOp( exOp.rec.ApplicationKind, 
                                exOp.rec.ApplicationKey, 
                                valCredit, valDebet, valCreditCV, valDebetCV );

      v.rec.ValCredit = valCredit;
      v.rec.ValDebet = valDebet;
      v.rec.ValCreditCV = valCreditCV;
      v.rec.ValDebetCV = valDebetCV;

      exchOtherTotals.valCredit = exchOtherTotals.valCredit + valCredit;
      exchOtherTotals.valDebet = exchOtherTotals.valDebet + valDebet;
      exchOtherTotals.valCreditCV = exchOtherTotals.valCreditCV + valCreditCV;
      exchOtherTotals.valDebetCV = exchOtherTotals.valDebetCV + valDebetCV;
    end;

    if ( ( v.rec.Credit != 0 ) or ( v.rec.Debet != 0  )
      or ( v.rec.ValCredit != 0 ) or ( v.rec.ValDebet != 0  )
      or ( v.rec.ValCreditCV != 0 ) or ( v.rec.ValDebetCV != 0  ) )
      odData.insert( v.recSize );
    end;
  end;

  macro processDocuments

    var
      recFound;

    exOp.clear;
    exOp.rec.Branch = branch;
    exOp.rec.CurDate = {curdate};
    exOp.rec.Brigade = operBrigade;
    exOp.rec.Oper = oper;

    exOp.addFilter( "t.t_Branch = " + string( branch ) +
                    " and t.t_CurDate = " + sqlDateToStr( {curdate} ) +
                    " and t.t_Brigade = " + string( operBrigade ) +
                    " and t.t_Oper = " + string( oper ) +
                    " and ( 0 = ( select o.t_ReestrType " +
                    "             from dexopset_dbt o " +
                    "             where o.t_Branch = " + string( branch ) +
                    "               and o.t_Kind_Oper = t.t_Kind_Oper" +
                    "               and o.t_SubOper = t.t_SubOper )" +
                    "    or 0 = ( select o.t_ReestrType " +
                    "             from dexopset_dbt o " +
                    "             where o.t_Branch = 0 " +  
                    "               and o.t_Kind_Oper = t.t_Kind_Oper" +
                    "               and o.t_SubOper = t.t_SubOper ) )" );

    recFound = exOp.getGE;
    while ( recFound
      and ( exOp.rec.Branch == branch )
      and ( exOp.rec.CurDate == {curdate} )
      and ( exOp.rec.Brigade == operBrigade )
      and ( exOp.rec.Oper == oper ) )
      if ( not findExchOp( exOp.rec.Branch, exOp.rec.Kind_Oper, exOp.rec.SubOper ) )
        exitOnBtError( "Не найдена валютообменная операция с кодом " + exOp.rec.Kind_Oper + "." + exOp.rec.SubOper );
      end;
      if ( filter )
        processDoc;
      end;
      recFound = exOp.next;
    end;

    exOp.dropFilter;
  end;

  macro proceed

    exchOtherTotals.reset;
    exchOtherTotalsU.reset;
    processDocuments;
  end;

  InitTDataCollector( _oper );
end;

/*
**  Платы по ВОО - сбор по заранее подготовленному файлу
*/

/* RA 29-09-03 платы по ВОО обрабатываем наравне со всеми    
class ( TDataCollector ) TOperDC_ExchRegPay( _oper )

  var
    exchPayTotals = TSubTotals( _oper );

  macro processRecs;

    record v( "od_data.1" );

    var
      recFound;

    exPay.clear;
    exPay.rec.CurrCode = currency.rec.Code_Currency;
    recFound = exPay.getGE;
    while ( recFound and ( exPay.rec.CurrCode == currency.rec.Code_Currency ) )
      setRecordAddr( v, odData );

      initDataRec( ODT_OPERATION, 
                   ODSTO_OTHER_OP, 
                   currency.rec.Code_Currency, 
                   oper, 
                   maxTime );

      odData.rec.Processing = PROC_SUM_UP;
      odData.rec.Label = "oth:";

      clearRecord( v );
  
      v.Credit = exPay.rec.Sum;
      v.ValCredit = exPay.rec.ValCredit;
      v.ValDebet = exPay.rec.ValDebet;
      v.ValCreditCV = exPay.rec.ValCreditCV;
      v.ValDebetCV = exPay.rec.ValDebetCV;
      v.Ground = exPay.rec.Desc;

      exchPayTotals.credit = exchPayTotals.credit + v.Credit;

      if ( currency.rec.Code_Currency != NATIONAL_CURR )
        v.CreditR = cur2rub( v.Credit );
        exchPayTotals.creditR = exchPayTotals.creditR + v.CreditR;
      end; 

      exchPayTotals.valCredit = exchPayTotals.valCredit + v.ValCredit;
      exchPayTotals.valDebet = exchPayTotals.valDebet + v.ValDebet;
      exchPayTotals.valCreditCV = exchPayTotals.valCreditCV + v.ValCreditCV;
      exchPayTotals.valDebetCV = exchPayTotals.valDebetCV + v.ValDebetCV;

      insert( odData, getRecordSize( v ) );
      recFound = exPay.next;  
    end;
  end;

  macro proceed

    exchPayTotals.reset;
    processRecs;
  end;

  InitTDataCollector( _oper );
end;*/