
/*
**  Опердневник ф.24. Хранение итоговых сумм
**
*/

/* Базовый класс итогов */

class TTotals

  var
    credit = $0, debet = $0, 
    memCredit = $0, memDebet = $0, 
    creditR = $0, debetR = $0, 
    memCreditR = $0, memDebetR = $0;

  macro reset

    credit = debet = memCredit = memDebet
      = creditR = debetR = memCreditR = memDebetR 
      = $0;
  end;

  macro write( oper )
  end;
end;

/* Итоги ОД по деньгам */

class ( TTotals ) TGlobalMoneyTotals( _unpay )

  var
    unpay = _unpay;
  
  macro write( oper )

    var
      v = TRecHandler( "od_data.2" );

    var
      subType = ODSTT_TURNS_TOTAL; 

    if ( ( credit == $0 ) and ( debet == $0 ) and ( memCredit == $0 ) and ( memDebet == $0 )
      and ( creditR == $0 ) and ( debetR == $0 ) and ( memCreditR == $0 ) and ( memDebetR == $0 ) )
      return;
    end; 

    if ( unpay )
      subType = subType +  ODSTT_UNPAY_OFFS;
    end;
      
    v.setRecordAddr( odData );

    initDataRec( ODT_TOTAL, subType, currency.rec.Code_Currency, oper );

    v.clear;
    v.rec.Credit = credit;
    v.rec.Debet = debet;
    v.rec.MemCredit = memCredit;
    v.rec.MemDebet = memDebet;
    v.rec.CreditR = creditR;
    v.rec.DebetR = debetR;
    v.rec.MemCreditR = memCreditR;
    v.rec.MemDebetR = memDebetR;
                          
    odData.insert( v.recSize );
  end;          
 
  initTTotals;
end;

class ( TTotals ) TValTotals( _subType )

  var
    subType = _subType;

  macro write( oper )

    var
      v = TRecHandler( "od_data.3" );

    if ( ( credit == $0 ) and ( debet == $0 ) )
      return;
    end; 

    v.setRecordAddr( odData );

    initDataRec( ODT_VAL_TOTAL, subType, 0, oper );

    v.clear;
    v.rec.Credit = credit;
    v.rec.Debet = debet;

    odData.insert( v.recSize );
  end;

  InitTTotals;
end;

/* Итоги ОД по ценностям */

class ( TTotals ) TGlobalValTotals

  var
    subTotalArray = TArray;

  macro addToSubType( subTotals, subType )

    var
      sz = subTotalArray.size, 
      found = false, 
      i = 0;

    while ( ( i < sz ) and ( not found ) )
      if ( subTotalArray[i].subType == subType )
        found = true;
      else
        i = i + 1;
      end;
    end;

    if ( not found )
      subTotalArray[i] = TValTotals( subType );
    end;

    subTotalArray[i].credit = subTotalArray[i].credit + subTotals.valCredit + subTotals.valCreditCV;
    subTotalArray[i].debet = subTotalArray[i].debet + subTotals.valDebet + subTotals.valDebetCV;
  end;

  macro write( oper )

    var
      i = 0;

    var
      v = TRecHandler( "od_data.3" );

    while ( i < subTotalArray.size )
      subTotalArray[i].write( oper );
      i = i + 1;
    end;

    if ( ( credit == $0 ) and ( debet == $0 ) )
      return;
    end; 

    v.setRecordAddr( odData );

    initDataRec( ODT_VAL_TOTAL, ODSTT_TURNS_TOTAL, 0, oper );

    v.clear;
    v.rec.Credit = credit;
    v.rec.Debet = debet;

    odData.insert( v.recSize );
  end;

  macro reset

    var
      i = 0;

    while ( i < subTotalArray.size )
      subTotalArray[i].reset;
      i = i + 1;
    end;

    reset;
  end;

  initTTotals;
end;

var
  totals = TGlobalMoneyTotals( false ), 
  totalsU = TGlobalMoneyTotals( true ), 
  valTotals = TGlobalValTotals;

/* Подытог по операциям */

class ( TTotals ) TSubTotals( _oper, _ground )

  var
    valCredit = $0, valDebet = $0, valCreditCV = $0, valDebetCV = $0, 
    oper = _oper, 
    ground = _ground;

  macro reset

    reset;
    valCredit = valDebet = valCreditCV = valDebetCV = $0;
  end;

  macro write( subType )

    var
      v = TRecHandler( "od_data.1" );

    if ( ( credit == $0 ) and ( debet == $0 ) and ( memCredit == $0 ) and ( memDebet == $0 )
      and ( creditR == $0 ) and ( debetR == $0 ) and ( memCreditR == $0 ) and ( memDebetR == $0 ) 
      and ( valCredit == $0 ) and ( valDebet == $0 ) and ( valCreditCV == $0 ) and ( valDebetCV == $0 ) )
      return;
    end; 

    v.setRecordAddr( odData );

    initDataRec( ODT_OPERATION, subType, currency.rec.Code_Currency, oper );

    v.clear;
    if ( ground )
      v.rec.ground = ground;
    end;
    v.rec.Credit = credit;
    v.rec.Debet = debet;
    v.rec.MemCredit = memCredit;
    v.rec.MemDebet = memDebet;
    v.rec.CreditR = creditR;
    v.rec.DebetR = debetR;
    v.rec.MemCreditR = memCreditR;
    v.rec.MemDebetR = memDebetR;
    v.rec.ValCredit = valCredit;
    v.rec.ValDebet = valDebet;
    v.rec.ValCreditCV = valCreditCV;
    v.rec.ValDebetCV = valDebetCV;

    odData.insert( v.recSize );
  end;

  macro writeMoneyAsGlobal( subType )

    var
      v = TRecHandler( "od_data.2" );

    if ( ( credit == $0 ) and ( debet == $0 ) and ( memCredit == $0 ) and ( memDebet == $0 )
      and ( creditR == $0 ) and ( debetR == $0 ) and ( memCreditR == $0 ) and ( memDebetR == $0 ) )
      return;
    end; 

    v.setRecordAddr( odData );

    initDataRec( ODT_TOTAL, subType, currency.rec.Code_Currency, oper );

    v.clear;
    v.rec.Credit = credit;
    v.rec.Debet = debet;
    v.rec.MemCredit = memCredit;
    v.rec.MemDebet = memDebet;
    v.rec.CreditR = creditR;
    v.rec.DebetR = debetR;
    v.rec.MemCreditR = memCreditR;
    v.rec.MemDebetR = memDebetR;
                             
    odData.insert( v.recSize );
  end; 

  macro writeAsGlobal( subType )

    writeMoneyAsGlobal( subType );
    valTotals.addToSubType( this, subType );
  end;          

  macro add( subTotals )

    credit = credit + subTotals.credit;
    debet = debet + subTotals.debet;
    memCredit = memCredit + subTotals.memCredit;
    memDebet = memDebet + subTotals.memDebet;
    creditR = creditR + subTotals.creditR;
    debetR = debetR + subTotals.debetR;
    memCreditR = memCreditR + subTotals.memCreditR;
    memDebetR = memDebetR + subTotals.memDebetR;
    valCredit = valCredit + subTotals.valCredit;
    valDebet = valDebet + subTotals.valDebet;
    valCreditCV = valCreditCV + subTotals.valCreditCV;
    valDebetCV = valDebetCV + subTotals.valDebetCV;    
  end;

  initTTotals;
  if ( oper == null )
    oper = 0;
  end;
end;

class ( TSubTotals ) TBranchSubTotals( _branch, _oper )

  var
    branchName = "* Не найден *", 
    branch = _branch;

  macro write( base )

    write( base + branch );
  end;

  getBranchParams( branch, branchName );
  initTSubTotals( _oper, "  - по филиалу " + branchName + ":" );
end;

class ( TArray ) TSetOfBranchSubTotals( _oper )

  var
    oper = _oper;

  macro get( branch )

    var
      found = false,  
      i;

    i = 0;
    while ( ( i < size ) and ( not found ) )
      if ( value( i ) and ( value( i ).branch == branch ) )
        found = true;
      else
        i = i + 1; 
      end;
    end;  
    if ( found )
      return value( i );
    end; 
    return value( size ) = TBranchSubTotals( branch, oper );  
  end;

  macro reset

    var
      i = 0;

    while ( i < size )
      if ( value( i ) )
        value( i ) = null;  
      end; 
      i = i + 1;   
    end; 
  end;
  
  macro write( base )

    var
      i = 0;

    while ( i < size )
      if ( value( i ) )
        value( i ).write( base );  
      end;
      i = i + 1;   
    end; 
  end;
  
  initTArray; 
end;

macro addSubTotalsToGlobTotals( globTotals, subTotals )

  globTotals.credit = globTotals.credit + subTotals.credit;
  globTotals.debet = globTotals.debet + subTotals.debet;
  globTotals.memCredit = globTotals.memCredit + subTotals.memCredit;
  globTotals.memDebet = globTotals.memDebet + subTotals.memDebet;
  globTotals.creditR = globTotals.creditR + subTotals.creditR;
  globTotals.debetR = globTotals.debetR + subTotals.debetR;
  globTotals.memCreditR = globTotals.memCreditR + subTotals.memCreditR;
  globTotals.memDebetR = globTotals.memDebetR + subTotals.memDebetR;
  
  valTotals.credit = valTotals.credit + subTotals.valCredit + subTotals.valCreditCV;
  valTotals.debet = valTotals.debet + subTotals.valDebet + subTotals.valDebetCV;
end;

macro updateGlobalTotals( subTotals )

  addSubTotalsToGlobTotals( totals, subTotals );  
end;

macro updateGlobalTotalsU( subTotals )

  addSubTotalsToGlobTotals( totalsU, subTotals );  
end;


