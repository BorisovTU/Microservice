
/*
**  Опердневник ф.24. Налично-кассовые операции, коммунальные платежи, платы
**
*/

import od_com, od_total, sqlconv;

class ( TSubTotals ) TCPLineHolder( _oper, _kkmNo, _kind )

  var
    kkmNo = _kkmNo, 
    kind = _kind;

  macro update( cred, memCred, valCred, valDeb, valCredCV, valDebCV )

    credit = credit + cred;
    memCredit = memCredit + memCred;
    valCredit = valCredit + valCred;
    valDebet = valDebet + valDeb;
    valCreditCV = valCreditCV + valCredCV;
    valDebetCV = valDebetCV + valDebCV;
  end;

  InitTSubTotals( _oper );
end; 

class ( TDataCollector ) TOperDC_Pay( _oper, _brigadeMode )

  var
    payKind = TBFile( "pay_kind.dbt", "r", 0 ),       /* Виды платежей       */
    payCsOp = TBFile( "pay_csop.dbt", "r", 0 ),       /* Подвиды платежей    */
    payDoc  = TBFile( "pay_doc.dbt", "r", 5 ), 
    PmntProp= TBFile( "RTPaymentProp.dbt","r",0), 
    payDocCP= TBFile( "pay_doc_cp.dbt", "r", 0 ), 
    cplink  = TBFile( "rtcp_link.dbt", "r", 0 ), 
    cptype  = TBFile( "rtcp_type.dbt", "r", 0 ), 
    payDoc71 = TRecHandler( "pay_doc.n71" ), 
    payTotals = TSubTotals( _oper ), 
    convTotals = TSubTotals( _oper ),
    foreignTotals = TSubTotals( _oper ), 
    fbSubTotals = TSetOfBranchSubTotals( _oper ), 
    brigadeMode   = false, 
    cpLines = TArray,
    prevGround = "";

  if( _brigadeMode != null )
    brigadeMode = _brigadeMode;
  end;
  
  macro findPayKind
  
    var stat;
  
    payKind.rec.IsCur = payDoc.rec.IsCur;
    payKind.rec.GroupOpert = payDoc.rec.GroupOpert;
    payKind.rec.NumOperat  = payDoc.rec.NumOpert;
    return payKind.getEQ;
  end;
  
  macro findPayKindCP
    
    payDocCP.rec.ApplKind = payDoc.rec.iApplicationKind;
    payDocCP.rec.ApplKey = payDoc.rec.ApplicationKey;
    if( payDocCP.getEQ )
      cplink.rec.Id = payDocCP.rec.CPLinkId;
      if( cplink.getEQ )
        cptype.rec.Id = cplink.rec.TypeId;
        return cptype.getEQ;
      end;
    end;
  
    return false;
  end;

  macro findPayCsOp
  
    if ( payDoc.rec.ApplType > 0 )
      payCsOp.rec.IsCur     = payDoc.rec.IsCur;
      payCsOp.rec.GroupType = payDoc.rec.GroupOpert;
      payCsOp.rec.NumOperat = payDoc.rec.NumOpert;
      payCsOp.rec.ApplType  = payDoc.rec.ApplType;
      return payCsOp.getEQ;
    end;
    return false;
  end;
  
  macro getDepOpType

    depOpTypes.rec.IsCur = payDoc.rec.IsCur;
    depOpTypes.rec.Kind = dep.rec.Type_Account;
    depOpTypes.rec.NumOpert = payDoc.rec.NumOpert;
    if ( depOpTypes.getEQ )
      return depOpTypes.rec.czNameAlg;
    else
      return "[Неизвестная операция]"; 
    end; 
  end;

  macro getDepSubOpType

    depSubOpTypes.rec.IsCur = payDoc.rec.IsCur;
    depSubOpTypes.rec.OperType = payDoc.rec.NumOpert;
    depSubOpTypes.rec.Type = payDoc.rec.ApplType;
    if ( depSubOpTypes.getEQ )
      return " (" + depSubOpTypes.rec.Name +")";
    end;
    return "";
  end; 
  
  macro makeGround
  
    var 
      clnt, 
      branchName = "* Не найден *", 
      ground = "";
  
    if ( payDoc.rec.GroupOpert == CO_OTHERBRANCH )
      payDoc71.setRecordAddr( payDoc, 0, 0, true );
      getBranchParams( payDoc71.rec.FNCashAcc, branchName );
      ground = getDepOpType + getDepSubOpType + " за филиал " + branchName; 
    elif ( payDoc.rec.Ground == "" )
      /* ------------------- Коммунальные платежи ------------------- */
      if ( payDoc.rec.GroupOpert == CO_COMMPAY )
        /* Название получателя */
        ground = PmntProp.rec.Name;
      /* ------------- Наличные перечисления и выплаты -------------- */
      elif ( ( payDoc.rec.GroupOpert == CO_NALPER ) or ( payDoc.rec.GroupOpert == CO_PAYED ) )
        /* Вид платежа */
        if ( findPayKind )
          ground = payKind.rec.szNameAlg + " ";
        end;
        /* Подвид платежа */
        if ( findPayCsOp )
          ground = ground + "(" + payCsOp.rec.NameCompType + ") ";
        end;
        /* Счет */
        ground = ground + PmntProp.rec.Account;
      /* ------------------------- Комиссии ------------------------- */
      elif ( payDoc.rec.GroupOpert == CO_COMMISSION )
        /* Вид платежа */
        if ( findPayKind )
          ground = payKind.rec.szNameAlg;
        end;
      /* ------------------------ Конверсии ------------------------- */
      elif ( payDoc.rec.GroupOpert == CO_CONVERSION )
        /* Вид платежа */
        if ( findPayKind )
          ground = payKind.rec.szNameAlg;
        end;
      /* ------------------- Безналичные платежи -------------------- */
      elif ( payDoc.rec.GroupOpert == CO_TRN )
        /* Вид платежа */
        if ( findPayKind )
          ground = payKind.rec.szNameAlg;
        end;
      end;
    else
      ground = trim( payDoc.rec.Ground ) + " ";
    end;
  
    if ( ( payDoc.rec.GroupOpert == CO_NALPER ) and ( payDoc.rec.CodClient ) )
      clnt = TClientList;
      clnt.GetRecord( payDoc.rec.CodClient );
      clnt = clnt.CurRec;
      ground = ground + "от " + makeFio( payDoc.rec.ClientLastName, 
                                       payDoc.rec.ClientFirstName, 
                                       payDoc.rec.ClientSecondName ) + " для " + clnt.ConvertFIO;
    else
      ground = ground + " " + makeFio( payDoc.rec.ClientLastName, 
                                       payDoc.rec.ClientFirstName, 
                                       payDoc.rec.ClientSecondName );
    end;

    ground = trim( ground );
  
    if ( payDoc.rec.Action == D_STORN )
      if ( payDoc.rec.InSum >= 0 )
        ground = ground + " (сторнирован)";
      else
        ground = ground + " (сторнирующ.)";
      end;
    end;
  
    return ground;
  end;
  
  macro writeLineAndUpdateTotals( group, label1, account, ground, time, 
                                  credit, debet, memCredit, memDebet, 
                                  valCredit, valDebet, valCreditCV, valDebetCV,
                                  creditRDiff, debetRDiff, memCreditRDiff, memDebetRDiff )

    var
      v = TRecHandler( "od_data.1" );

    var
      bst, 
      subType;

    if ( ( credit == $0 ) and ( debet == $0 ) and ( memCredit == $0 ) and ( memDebet == $0 )
      and ( valCredit == $0 ) and ( valDebet == $0 ) and ( valCreditCV == $0 ) and ( valDebetCV == $0 ) 
      and ( creditRDiff == $0 ) and ( debetRDiff == $0 ) and ( memCreditRDiff == $0 ) and ( memDebetRDiff == $0 ) )
      return;
    end; 

    v.setRecordAddr( odData );

    if ( group == CO_CONVERSION )
      subType = ODSTO_CONV_OP;
    elif ( group == CO_OTHERBRANCH )
      subType = ODSTO_FBDEP_OP;
    else
      subType = ODSTO_OTHER_OP;
    end; 

    initDataRec( ODT_OPERATION, subType, currency.rec.Code_Currency, oper, time );

    if ( group == CO_OTHERBRANCH )
      odData.rec.Processing = PROC_SUM_UP;
      odData.rec.Label = "fbd:" + label1; 
      bst = fbSubTotals.get( label1 );
    else
      odData.rec.Processing = PROC_SUM_UP;
      odData.rec.Label = "oth:" + label1; 
    end;

    v.clear;

    if ( account )
      v.rec.Account = account;  
    end;
    v.rec.Ground = ground;

    v.rec.Credit = credit;
    v.rec.Debet = debet;
    v.rec.MemCredit = memCredit;
    v.rec.MemDebet = memDebet;
    v.rec.CreditRDiff = creditRDiff;
    v.rec.DebetRDiff = debetRDiff;
    v.rec.MemCreditRDiff = memCreditRDiff;
    v.rec.MemDebetRDiff = memDebetRDiff;

    if ( group == CO_CONVERSION )
      convTotals.credit = convTotals.credit + v.rec.Credit/* SCR9795 + v.CreditRDiff*/;
      convTotals.debet = convTotals.debet + v.rec.Debet/* SCR9795 + v.DebetRDiff*/;
      convTotals.memCredit = convTotals.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff*/;
      convTotals.memDebet = convTotals.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff*/;
    elif ( group == CO_OTHERBRANCH )
      foreignTotals.credit = foreignTotals.credit + v.rec.Credit/* SCR9795 + v.CreditRDiff*/;
      foreignTotals.debet = foreignTotals.debet + v.rec.Debet/* SCR9795 + v.DebetRDiff*/;
      foreignTotals.memCredit = foreignTotals.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff*/;
      foreignTotals.memDebet = foreignTotals.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff*/;
      bst.credit = bst.credit + v.rec.Credit/* SCR9795 + v.CreditRDiff*/;
      bst.debet = bst.debet + v.rec.Debet/* SCR9795 + v.DebetRDiff*/;
      bst.memCredit = bst.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff*/;
      bst.memDebet = bst.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff*/;
    else
      payTotals.credit = payTotals.credit + v.rec.Credit/* SCR9795 + v.CreditRDiff*/;
      payTotals.debet = payTotals.debet + v.rec.Debet/* SCR9795 + v.DebetRDiff*/;
      payTotals.memCredit = payTotals.memCredit + v.rec.MemCredit/* SCR9795 + v.MemCreditRDiff*/;
      payTotals.memDebet = payTotals.memDebet + v.rec.MemDebet/* SCR9795 + v.MemDebetRDiff*/;
    end;

    if ( currency.rec.Code_Currency != NATIONAL_CURR )
      v.rec.CreditR = cur2rub( credit );
      v.rec.DebetR = cur2rub( debet );
      v.rec.MemCreditR = cur2rub( memCredit );
      v.rec.MemDebetR = cur2rub( memDebet );
      if ( group == CO_CONVERSION )
        convTotals.creditR = convTotals.creditR + v.rec.CreditR;
        convTotals.debetR = convTotals.debetR + v.rec.DebetR;
        convTotals.memCreditR = convTotals.memCreditR + v.rec.MemCreditR;
        convTotals.memDebetR = convTotals.memDebetR + v.rec.MemDebetR;
      elif ( group == CO_OTHERBRANCH )
        foreignTotals.creditR = foreignTotals.creditR + v.rec.CreditR;
        foreignTotals.debetR = foreignTotals.debetR + v.rec.DebetR;
        foreignTotals.memCreditR = foreignTotals.memCreditR + v.rec.MemCreditR;
        foreignTotals.memDebetR = foreignTotals.memDebetR + v.rec.MemDebetR;
        bst.creditR = bst.creditR + v.rec.CreditR;
        bst.debetR = bst.debetR + v.rec.DebetR;
        bst.memCreditR = bst.memCreditR + v.rec.MemCreditR;
        bst.memDebetR = bst.memDebetR + v.rec.MemDebetR;
      else
        payTotals.creditR = payTotals.creditR + v.rec.CreditR;
        payTotals.debetR = payTotals.debetR + v.rec.DebetR;
        payTotals.memCreditR = payTotals.memCreditR + v.rec.MemCreditR;
        payTotals.memDebetR = payTotals.memDebetR + v.rec.MemDebetR;
      end;
    end;

    v.rec.ValCredit = valCredit;
    v.rec.ValDebet = valDebet;
    v.rec.ValCreditCV = valCreditCV;
    v.rec.ValDebetCV = valDebetCV;
    if ( group == CO_CONVERSION )
      convTotals.valCredit = convTotals.valCredit + v.rec.ValCredit;
      convTotals.valDebet = convTotals.valDebet + v.rec.ValDebet;
      convTotals.valCreditCV = convTotals.valCreditCV + v.rec.ValCreditCV;
      convTotals.valDebetCV = convTotals.valDebetCV + v.rec.ValDebetCV;
    elif ( group == CO_OTHERBRANCH )
      foreignTotals.valCredit = foreignTotals.valCredit + v.rec.ValCredit;
      foreignTotals.valDebet = foreignTotals.valDebet + v.rec.ValDebet;
      foreignTotals.valCreditCV = foreignTotals.valCreditCV + v.rec.ValCreditCV;
      foreignTotals.valDebetCV = foreignTotals.valDebetCV + v.rec.ValDebetCV;
      bst.valCredit = bst.valCredit + v.rec.ValCredit;
      bst.valDebet = bst.valDebet + v.rec.ValDebet;
      bst.valCreditCV = bst.valCreditCV + v.rec.ValCreditCV;
      bst.valDebetCV = bst.valDebetCV + v.rec.ValDebetCV;
    else
      payTotals.valCredit = payTotals.valCredit + v.rec.ValCredit;
      payTotals.valDebet = payTotals.valDebet + v.rec.ValDebet;
      payTotals.valCreditCV = payTotals.valCreditCV + v.rec.ValCreditCV;
      payTotals.valDebetCV = payTotals.valDebetCV + v.rec.ValDebetCV;
    end;

    odData.insert( v.recSize );
  end;

  macro addCP( ground, credit, memCredit, valCredit, valDebet, valCreditCV, valDebetCV )
  
    var 
      kind = "", 
      i = 0, 
      found = false; 
  
    if ( CP_FLAG == 1 )
      if ( ( prevGround == "" )  or  ( prevGround != ground ) )
        if ( prevGround == "" )
          cpLines.value( 0 ) = TCPLineHolder( oper, payDoc.rec.KKMFactoryNum );
        else
          writeLineAndUpdateTotals( CO_COMMPAY, cpLines.value( 0 ).kkmNo, null, cpLines.value( 0 ).kind, maxTime, 
            cpLines.value( 0 ).credit, cpLines.value( 0 ).debet, 
            cpLines.value( 0 ).memCredit, cpLines.value( 0 ).memDebet, 
            cpLines.value( 0 ).valCredit, cpLines.value( 0 ).valDebet, 
            cpLines.value( 0 ).valCreditCV, cpLines.value( 0 ).valDebetCV,
            $0, $0, $0, $0 );
          cpLines.value( 0 ).reset;
        end;
        prevGround = ground;
      end; 
      cpLines.value( 0 ).update( credit, memCredit, valCredit, valDebet, valCreditCV, valDebetCV ); 
    else
      if ( findPayKindCP )
        kind = cptype.rec.Name;
      else
        kind = "Платеж без договора";
      end;

      while ( ( i < cpLines.size ) and ( not found ) )
        if ( cpLines.value( i ).kind == kind )
          found = true;
        else
          i = i + 1;
        end;
      end;

      if ( not found )
        cpLines( i ) = TCPLineHolder( oper, payDoc.rec.KKMFactoryNum, kind );
      end;
        
      cpLines.value( i ).update( credit, memCredit, valCredit, valDebet, valCreditCV, valDebetCV ); 
    end;
  end;
  
  macro writeCP
  
    var 
      i = 0;
  
    if ( CP_FLAG == 0 )
      return;
    elif ( CP_FLAG == 1 )
      writeLineAndUpdateTotals( CO_COMMPAY, cpLines.value( 0 ).kkmNo, null, prevGround, maxTime,  
        cpLines.value( 0 ).credit, cpLines.value( 0 ).debet, 
        cpLines.value( 0 ).memCredit, cpLines.value( 0 ).memDebet, 
        cpLines.value( 0 ).valCredit, cpLines.value( 0 ).valDebet, 
        cpLines.value( 0 ).valCreditCV, cpLines.value( 0 ).valDebetCV,
        $0, $0, $0, $0 );
    else
      while( i < cpLines.size )
        writeLineAndUpdateTotals( CO_COMMPAY, cpLines.value( i ).kkmNo, null, cpLines.value( i ).kind, maxTime, 
          cpLines.value( i ).credit, cpLines.value( i ).debet, 
          cpLines.value( i ).memCredit, cpLines.value( i ).memDebet, 
          cpLines.value( i ).valCredit, cpLines.value( i ).valDebet, 
          cpLines.value( i ).valCreditCV, cpLines.value( i ).valDebetCV,
          $0, $0, $0, $0 );
        i = i + 1;
      end;
    end;
  end;

  macro processDoc( isCur )
  
    var
      payDocConv = TRecHandler( "pay_doc.cnv" ), 
      d, 
      account, 
      ground,
      label1, 
      debCred = CI_CREDIT, 
      credit = $0, debet = $0,  
      memCredit = $0, memDebet = $0, memCreditRDiff = $0, memDebetRDiff = $0,
      valCredit = $0, valDebet = $0, valCreditCV = $0, valDebetCV = $0;

    desk.getValuesTurnsForOp( payDoc.rec.iApplicationKind, 
                              payDoc.rec.ApplicationKey, 
                              valCredit, 
                              valDebet, 
                              valCreditCV, 
                              valDebetCV );

    /*LAA для включенного режимо работы с овердрафтами по Вологодской схеме:
      1. Настройка ОБСЛУЖИВАНИЕ ФИЗ ЛИЦ-ПЛАСТ КАРТЫ- ВИДЫ ПЛАТАЖЕЙ - ВИДЫ ОВЕР КРЕДИТОВ
         введены 92 и 93 
      2. В настройки операции 92 и 93 для всех МПК введены в шаг ДОКУМЕНТ ОВЕРДР КРЕДИТОВАНИЯ
         соотвествующие типы 

         формируются в PAY_DOC операции с номером 92 и 93 и типом 61.
         Тип 61 описан в OD_COMM.mac как CO_OVERCRED дистрибутивно

         тикае записи не должны попадать  дневник
    */
    if (((payDoc.rec.NumOpert == 92) or 
         (payDoc.rec.NumOpert == 93) or 
         (payDoc.rec.NumOpert == 94) or
         (payDoc.rec.NumOpert == 96)
        ) and
        (payDoc.rec.GroupOpert == CO_OVERCRED)
       )
        return;
    end;

    if ( payDoc.rec.GroupOpert == CO_CONVERSION )
      payDocConv.setRecordAddr( payDoc, 0, 0, true );
      if ( currency.rec.Code_Currency == NATIONAL_CURR ) /* Взгляд со стороны рублей */
        if ( payDoc.rec.ApplType == FLAGDEBCRED_IN )     
          credit = payDoc.rec.InSum;
/*        SCR9795
          d = credit - Sumconv( payDocConv.rec.KonvertSum, payDocConv.rec.CBRate / 100 );
          if ( d > 0 )
            memCreditRDiff = d;
          else
            memDebetRDiff = -d;
          end; 
*/
        else
          debet = payDoc.rec.InSum;
/*        SCR9795
          d = debet - Sumconv( payDocConv.rec.KonvertSum, payDocConv.rec.CBRate / 100 );
          if ( d > 0 )
            memDebetRDiff = d;
          else
            memCreditRDiff = -d;
          end; 
*/
        end;
/* SCR 12845
      elif ( payDocConv.rec.KonvertCodCur == currency.rec.Code_Currency ) // Конвертация ЭТОЙ валюты
        if ( payDoc.rec.ApplType == FLAGDEBCRED_IN )     
          memDebet = payDocConv.rec.KonvertSum;
        else
          memCredit = payDocConv.rec.KonvertSum;
        end;
*/
      end; 
    else                /* не конверсия */
      if ( payDoc.rec.GroupOpert == CO_PAYED )
        debCred = CI_DEBET;
      elif ( ( payDoc.rec.GroupOpert == CO_OTHERBRANCH ) or ( payDoc.rec.GroupOpert == CO_TRN ) )
        debCred = payDoc.rec.DebetCredit;
      end;  

      if ( debCred == CI_CREDIT )
        if ( payDoc.rec.VidDoc == StrFor( 0 ) )
          credit = payDoc.rec.InSum;
        else
          memCredit = payDoc.rec.InSum;
        end;
      else
        if ( payDoc.rec.VidDoc == StrFor( 0 ) )
          debet = payDoc.rec.InSum;
        else
          memDebet = payDoc.rec.InSum;
        end;
      end;
    end;
  
    if ( payDoc.rec.GroupOpert == CO_OTHERBRANCH )
      payDoc71.setRecordAddr( payDoc, 0, 0, true );
      if ( findDep( payDoc71.rec.Referenc ) )
        account = dep.rec.Account;
      end;    
      label1 = payDoc71.rec.FNCashAcc;
    else
      label1 = payDoc.rec.KKMFactoryNum;
    end;

    ground = makeGround;

    if ( ( not isCur ) and ( payDoc.rec.GroupOpert == CO_COMMPAY ) and ( CP_FLAG != 0 ) )
      addCP( ground, credit, memCredit, valCredit, valDebet, valCreditCV, valDebetCV );
    else
      writeLineAndUpdateTotals( payDoc.rec.GroupOpert, label1, account, ground, getDocumentTime( payDoc.rec.ApplicationKey ), 
                                credit, debet, memCredit, memDebet, 
                                valCredit, valDebet, valCreditCV, valDebetCV,
                                $0, $0, memCreditRDiff, memDebetRDiff );
    end;
  end;

  macro isIncludedInExReg
 
    var
      payDocComm = TRecHandler( "pay_doc.com" );

    payDocComm.setRecordAddr( payDoc, 0, 0, true ); 
    return payDocComm.rec.Register != strFor( 0 );
  end;

  macro filter

    if ( payDoc.rec.Oper != oper )
      return false;
    end;

    if ( payDoc.rec.Brigade != operBrigade )
      return false;
    end;

    if ( payDoc.rec.Mode != mode )
      return false;
    end;

    if ( payDoc.rec.Action != D_STORN ) 
      if ( not isConfirmed( not payDoc.rec.NotConfirm ) )
        return false;
      end;
    end;

    if ( payDoc.rec.Action == D_DELETE )
      return false;
    end;

    /* Непроведенный документ */
    if ( ( payDoc.rec.IsSuspended != "" ) and ( payDoc.rec.IsSuspended != "X" ) )
      return false;
    end;

    if ( payDoc.rec.GroupOpert == CO_COMMISSION )
      if ( isIncludedInExReg and (not brigadeMode) )
        return false;
      end;
    end;

    if ( payDoc.rec.GroupOpert == CO_METALACCOUNT )
      return false;
    end;

    
    return true;
  end;
  
  macro proceedForCurrMode( isCur )
  
    var 
      saveKey, 
      recFound;

    payDoc.addFilter("t.t_FNCash = " + string(branch) + 
		     " and t.t_IsCur = " + string(isCur) + 
		     " and t.t_CodCur = " + string(currency.rec.Code_Currency) +
		     " and t.t_Date_Document = " + sqlDateToStr({curdate}) +
		     " and t.t_Oper = " + string( oper ) +
		     " and t.t_Brigade = " + string( operBrigade ) +
		     " and t.t_Mode = " + string( mode ) );  
    payDoc.clear;
    payDoc.rec.FNCash = branch;
    payDoc.rec.IsCur  = isCur;
    payDoc.rec.CodCur = currency.rec.Code_Currency;
    payDoc.rec.Date_Document = {curdate};
    recFound = payDoc.getGE;
    while ( recFound
      and ( payDoc.rec.FNCash == branch )
      and ( payDoc.rec.IsCur  == isCur )
      and ( payDoc.rec.CodCur == currency.rec.Code_Currency )
      and ( payDoc.rec.Date_Document == {curdate} ) )
      if ( filter )
        processDoc( isCur );
      end;
      recFound = payDoc.next;
    end;
    payDoc.dropFilter();  
    if ( not isCur )
      writeCP;
    elif ( currency.rec.Code_Currency != NATIONAL_CURR )  /* Поищем подходящие конверсии */
      saveKey = payDoc.keyNum; 
      payDoc.keyNum = 0;
      payDoc.addFilter( "t.t_IsCur = " + string(isCur) + 
			" and t.t_FNCash = " + string(branch) + 
  			" and t.t_GroupOpert = " + string(CO_CONVERSION) + 
			" and t.t_Oper = " + string( oper ) +
  			" and t.t_Date_Document = " + sqlDateToStr({curdate}) );  
      payDoc.clear;
      payDoc.rec.IsCur = isCur;
      payDoc.rec.FNCash = branch;
      payDoc.rec.GroupOpert = CO_CONVERSION;
      payDoc.rec.Oper = oper;
      payDoc.rec.Date_Document = {curdate};
      recFound = payDoc.getGE;
      while ( recFound
        and ( payDoc.rec.IsCur == isCur )
        and ( payDoc.rec.FNCash == branch )
        and ( payDoc.rec.GroupOpert == CO_CONVERSION )
        and ( payDoc.rec.Oper == oper )
        and ( payDoc.rec.Date_Document == {curdate} ) )
        if ( filter )
          processDoc( isCur );
        end;
        recFound = payDoc.next;
      end;
      payDoc.dropFilter();  
      payDoc.keyNum = saveKey;
    end;
  end;

  macro proceed

    message( string( oper ) + ": Сбор данных: Налично-кассовые операции, коммунальные платежи и платы" );
    payTotals.reset;
    convTotals.reset;
    foreignTotals.reset;
    fbSubTotals.reset;

    proceedForCurrMode( 0 );
    proceedForCurrMode( 1 );

    updateGlobalTotals( convTotals );
    convTotals.write( ODSTO_CONV_TOT );
    convTotals.writeAsGlobal( ODSTT_TURNS_CONV );

    foreignTotals.write( ODSTO_FBDEP_TOT );
    foreignTotals.writeAsGlobal( ODSTT_TURNS_FBDEP );
    fbSubTotals.write( ODSTO_FBDEP_BR_TOT_BASE );
    updateGlobalTotals( foreignTotals );

    message( "" );
  end;

  InitTDataCollector( _oper );
end;
