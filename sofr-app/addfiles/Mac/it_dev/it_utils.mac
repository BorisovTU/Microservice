/*
$Name:        it_utils.mac
$Module:      Ценные бумаги
$Description: Библиотека макросов

  # changelog
  |date       |author         |tasks                                                   |note                                                        
  |-----------|---------------|--------------------------------------------------------|-------------------------------------------------------------
  |2022.08.17 |Зыков М.В.     |                                                        | Создание

*/
import dv_fun,dl_xml,dlQuery,dlutils;

PRIVATE CONST BUFFER_STRLEN = 32767 ;

// Путь к каталоку TxtFile
macro IT_GetPatchTxtFile(isRemote:bool)
  var Path = "";
  var startPos = 1;
  var lastPos = 1;
  if (valtype( isRemote ) == V_UNDEF)
   isRemote = (not isStandAlone()) ;
  end;
  if (isRemote)
    Path = GetCurDir(true)+"\\txtfile";
  else
    Path = GetCurDir(false) ;
    while (true)
      startPos = Index (Path, "\\", lastPos+1);
      if (startPos > 0)
       lastPos = startPos ; 
      else
        break ;
      end;
    end; 
    Path = substr(Path,1,lastPos)+"txtfile";    
  end;
  return Path ; 
end;


class (DL_XML)IT_XMLReader()
   macro Load(xml_str) : bool
      m_xml = CreateXMLObj();
      var stat;
      if (m_xml != null)
         stat = m_xml.loadXML(xml_str);
      else
         stat = false;
      end;
      return stat;
   end;

   macro GetXml()
      return m_xml;
   end;

   macro Construct();
      CreateXML("utf-8");
   end;

   this.Construct();
END;

// Очистка буфера 
MACRO IT_ClearBufer
   var   sql =  " begin it_rsl_string.clear; end; ";
   var  exec = RSDCommand(sql);
   exec.execute();
END;


// Сохранение CLOB таблицы(select) в буфер
macro IT_ClobDataBufer(field, FromWhere)
 var Rsd = RsdCommand(" declare v_clob clob; "+
                   " begin select "+field+" into v_clob from "+ FromWhere+" ;"+
                   " it_rsl_string.clear;"+
                   " it_rsl_string.set_clob(v_clob) ;"+
                   " end;" );
  Rsd.execute();
end;

// Чтение части CLOB из буфера
private macro get_varchar_buffer(idx, keepBuffer)
  var Rsd = RsdCommand(" declare v_str varchar2(32767) ; begin v_str := it_rsl_string.get_varchar(?,32767); "+
                       " ? := v_str ; "+ IIF(not keepBuffer, "if v_str is null or length(v_str) < 32767 then it_rsl_string.clear; end if;", "") + "  end;" );
    Rsd.addParam("p_index",RSDBP_IN,idx);
    Rsd.addParam("v_result",RSDBP_OUT,V_STRING, 32768);
    Rsd.execute();
    return (Rsd.value("v_result"));
end;

// Возврвщает CLOB из буфера
macro IT_GetClobBufer
  var idx, resultStr, resultClob ="";
  idx = 1;
  while(true)
    resultStr = get_varchar_buffer(idx, false);
    if (StrLen (resultStr ) > 0 )
      resultClob = resultClob+resultStr;
    end;
    if (StrLen (resultStr ) < 32767 )
      break;
    end;
    idx = idx + 1;
  end;
  return (resultClob);
end;

// Сохраняет  строку в буфер
macro IT_SetClobBufer(str_to_buf)
 var Rsd,N = 1, sub_str ;
 for   
    sub_str = substr(str_to_buf,(((N-1)*BUFFER_STRLEN)+1),BUFFER_STRLEN);
    if (StrLen(sub_str) == 0)
       if (N == 1)
          IT_ClearBufer;
       end;
       break;
    end;
    Rsd = RsdCommand(" begin  if ? = 1 then it_rsl_string.clear; end if; "+
                     " it_rsl_string.append_varchar(?) ;  end;" );
    Rsd.addParam("",RSDBP_IN,N);
    Rsd.addParam("",RSDBP_IN,sub_str);
    Rsd.execute();
    N=N+1 ;
  end ;
end;



// Возврвщает CLOB из таблицы(select)
macro IT_GetClobData(field, FromWhere)
  IT_ClobDataBufer(field, FromWhere);
  return (IT_GetClobBufer());
end;

// Сохраняет буфер в файл на диск
// если split = true, делит файл на несколько частей по ~ <size>*32767 байт/символов, возвращает массив имен файлов
macro IT_StoreClobBufer(IsAnsi, FileName, FileType, split, size, append, keepbuffer)
  var idx, resultStr,strm , len, rest="", files = TArray, iFile, f_path, f_name, f_ext, bufkeep = false;
  var openFlag = "C";

  macro IndexLastRowEnd
    var _i=1, pos;
    while((len-_i*10>0) and not (pos=Index(SubStr(resultStr,len-_i*10),"\n") ))
      _i=_i+1;
    end;
    if(pos)
      return len - _i*10 + pos;
    else
      return 0;
    end;
  end;

  if (valtype( FileType ) == V_UNDEF)
   FileType ="CSV" ;
  end;

  if (valtype( split ) == V_UNDEF)
    split = false;
  end;

  if ((ValType(append) == V_BOOL) and (append == true))
    openFlag = "A";
  end;

  if ((ValType(keepbuffer) == V_BOOL) and (keepbuffer == true))
    bufkeep = true;
  end;

  if (split)
    if (split and (valtype( size ) == V_UNDEF))
      size = 10;
    end;

    f_path = SplitFile(FileName, f_name, f_ext);
  else
    strm = TStream(FileName, openFlag);
  end;
  idx = 1;

  while(true)
    resultStr = get_varchar_buffer(idx, bufkeep);
    len = StrLen(resultStr);

    if (StrLen (resultStr ) > 0 )
      if (split)
        if (mod(idx-1,size) == 0)
          if (strm)
            strm.Flush();
          end;
          iFile = files.Size;
          files[iFile]= MergeFile(f_path, f_name+"_"+(iFile+1), f_ext);
          strm = TStream(files[iFile], openFlag);
          resultStr = rest + resultStr;
        elif (mod(idx-1,size) == size - 1)
          var lre = IndexLastRowEnd;
          if (lre)
            rest = SubStr(resultStr, lre);
            resultStr = SubStr(resultStr, 1, lre-1)
          end;
        end;
      end;

      var toWrite = resultStr;
      if (IsAnsi)
        toWrite = ToANSI(resultStr,true);
      end;
      strm.write(toWrite);
    end;
    if (len < 32767)
      break;
    end;
    idx = idx + 1;
  end;

  if (strm)
    if ((FileType =="CSV") and (idx==1) and (StrLen (resultStr ) == 0))
      strm.write(" ;\n");
    end;
    strm.Flush();
  end;

  return files;
end;

// Сохраняет буфер в ANSI файл на диск
// если split = true, делит файл на несколько частей по ~ <size>*32767 байт/символов, возвращает массив имен файлов
macro IT_StoreClobBuferANSI(FileName, FileType, split, size, append, keepbuffer)
  return IT_StoreClobBufer(true, FileName, FileType, split, size, append, keepbuffer);
end;

// Сохраняет CLOB таблицы(select) в ANSI файл на диск
macro IT_StoreClobDataANSI(field, FromWhere,FileName,FileType, split, size)
  IT_ClobDataBufer(field, FromWhere);
  return IT_StoreClobBuferANSI(FileName,FileType, split, size);
end;

// Импорт в шаблон XLS CSV файла 
macro IT_FILE_CSVtoXLS(id_file,Template,BodyLine,msq:@string,XLSFileDir)
  var XLSfile ,XLSfileName ,XLSPath,XLStable,tmp;
  var CreateOnTerm = (not isStandAlone());
  var CSVFileDir = IT_GetPatchTxtFile(false)+"\\";
  
  // SplitFile ( Template, @XLSfileName,@XLSfileExt ):
  if (valtype( XLSFileDir ) == V_UNDEF)
    XLSFileDir = IT_GetPatchTxtFile(CreateOnTerm)+"\\";
  end;
  var Dt = TRsbDataSet("select file_name from itt_file where id_file = "+String(id_file));
  if (Dt.movenext() and (StrLen(Dt.File_Name) > 0))
    var arrayFiles = IT_StoreClobDataANSI("file_clob",("itt_file where id_file = "+id_file),(CSVFileDir+Dt.File_Name), null, true, 50);
    
    XLSfile = CTemplateSXLSX();
    XLSfile.OpenTemplate(Template, false);//имя шаблона
    XLSfile.SetXLSXFormat();
    XLStable = XLSfile.RegisterTable(BodyLine);
    XLSfile.SetValue_NameCell(BodyLine);
    XLStable.FillTabelFromCSV(arrayFiles);
    XLStable.EndTable();
    SplitFile( (Dt.File_Name), XLSfileName );
    XLSfile.SaveAsTemplate(XLSfileName,false);
    XLSfile.close();

    XLSfileName = XLSfile.ReportFileName_xls ;
    XLSPath = XLSfile.ReportPath + IIF(SubStr(XLSfile.ReportPath, StrLen(XLSfile.ReportPath)) == "\\", "", "\\");
    if (XLSfile.Application) XLSfile.Application.Quit; end;
    XLSfile.Close ;
    XLStable = null;
    XLSfile = null; 

    RemoveFile ((CSVFileDir+Dt.File_Name));

    if (StrUpr(XLSFileDir) != StrUpr(XLSPath))
      if ( not CopyFile((IIF(CreateOnTerm,"$")+XLSPath+XLSfileName), (IIF(CreateOnTerm,"$")+XLSFileDir+XLSfileName),true,("Копирование "+XLSfileName)))
        msq = "ОШИБКА КОПИРОВАНИЯ ФАЙЛА В "+XLSFileDir+" ( "+XLSPath+XLSfileName+" сохранен ) ";
        return false;
      else
        RemoveFile (XLSPath+XLSfileName);
      end;
    end;

    msq = "Excel файл "+XLSFileDir+XLSfileName+" сохранен ";
  else
    msq = " ОШИБКА id_file = "+id_file+" НЕ НАЙДЕН В ITT_FILE ";
    return (false);
  end;
  return (true);
 onError(er)
   msq = "ОШИБКА ИМПОРТА В EXCEL :"+ er.Message ; 
   return (false);
end;

// Импорт в шаблон XLS CSV файла и возвращает ссылку на XLS 
macro IT_FILE_CSVgetXLSfile(id_file,Template,BodyLine,msq:@string,XLSFileDir,SaveTemp)
  var XLSfile ,XLSfileName ,XLStable,tmp;
  var CSVFileDir = IT_GetPatchTxtFile(false)+"\\";
  
  if (valtype( XLSFileDir ) == V_UNDEF)
    XLSFileDir = IT_GetPatchTxtFile()+"\\";
  end;
  var Dt = TRsbDataSet("select file_name from itt_file where id_file = "+String(id_file));
  if (Dt.movenext() and (StrLen(Dt.File_Name) > 0))
    BegAction(10, "Выгрузка CSV файла "+(CSVFileDir+Dt.File_Name));
    IT_StoreClobDataANSI("file_clob",("itt_file where id_file = "+id_file),(CSVFileDir+Dt.File_Name));
    EndAction();
    
    BegAction(10, "Импорт CSV "+(CSVFileDir+Dt.File_Name)+" в XLS ");    
    XLSfile = CTemplateXLS();
    XLSfile.OpenTemplate(Template, false);//имя шаблона
    XLSfile.SetXLSXFormat();
    XLStable  = XLSfile.RegisterTable(BodyLine);
    XLSfile.SetValue_NameCell(BodyLine);
    XLStable.FillTabelFromCSV((CSVFileDir+Dt.File_Name));
    XLStable.EndTable();
    SplitFile( (Dt.File_Name), XLSfileName );

    if (SaveTemp != false)
      XLSfile.SaveAsTemplate(XLSfileName,true);
    end;

    RemoveFile ((CSVFileDir+Dt.File_Name));
    EndAction();

    return (XLSfile) ;
  else
    msq = " ОШИБКА id_file = "+id_file+" НЕ НАЙДЕН В ITT_FILE ";
    return (false);
  end;
 onError(er)
   msq = "ОШИБКА ИМПОРТА В EXCEL :"+ er.Message ; 
   return (false);
end;







private macro set_q_in_buffer(messbody:string ,XMLmessmeta:string ) 
var Rsd,N = 1, body, meta ;
 for   
    body = substr(messbody,(((N-1)*BUFFER_STRLEN)+1),BUFFER_STRLEN);
    meta = substr(XMLmessmeta,(((N-1)*BUFFER_STRLEN)+1),BUFFER_STRLEN);
    if ((StrLen(body) == 0) and (StrLen(meta) == 0))
       if (N == 1)
          Rsd = RsdCommand(" begin it_rs_q_utils.clear_data_buffer; end;" );
          Rsd.execute();
       end;
       break;
    end;
    Rsd = RsdCommand(" begin  if ? = 1 then it_rs_q_utils.clear_data_buffer; end if; "+
                     " it_rs_q_utils.append_in_data_buffer(p_in_messbody => ? , p_in_messmeta => ? ) ;  end;" );
    Rsd.addParam("",RSDBP_IN,N);
    Rsd.addParam("",RSDBP_IN,body);
    Rsd.addParam("",RSDBP_IN,meta);
    Rsd.execute();
    N=N+1 ;
  end ;
end;

private macro get_q_out_buffer(messbody:@string  
                              ,XMLmessmeta:@string ) 
  var Rsd,N = 1, body, meta ;
  messbody = "" ;
  XMLmessmeta = "" ;
  for   
    Rsd = RsdCommand(" declare v_result integer; v_body varchar2(32767) ; v_meta varchar2(32767) ; "+
                        " begin v_result := it_rs_q_utils.get_out_data_buffer(p_index => ?  "+       
                                                                        " ,o_out_messbody => v_body "+ 
                                                                        " ,o_out_messmeta => v_meta "+
                                                                        " ,p_len_str => 32767); "+
                       " ? :=v_result ; ? := v_body ; ? := v_meta ; if v_result = 0  then it_rs_q_utils.clear_data_buffer; end if;  end;" );
    Rsd.addParam("",RSDBP_IN,N);
    Rsd.addParam("p_result",RSDBP_OUT,V_INTEGER);
    Rsd.addParam("p_body",RSDBP_OUT,V_STRING, BUFFER_STRLEN+1);
    Rsd.addParam("p_meta",RSDBP_OUT,V_STRING, BUFFER_STRLEN+1);
    Rsd.execute();
    body = Rsd.value("p_body") ;
    meta = Rsd.value("p_meta") ;
    if (ValType(body) == V_STRING)
      messbody = messbody + body ;
    end ;
    if (ValType(meta) == V_STRING)
      XMLmessmeta = XMLmessmeta + meta;
    end ;
    if (Rsd.value("p_result") == 0) 
     break;
    end ;
    N=N+1;
  end ;
end;



// Запуск синхронного сервиса  
macro ITQ_DO_S_SERVICE(errtxt:@string           // Текст ошибки 
                     , servicename:string       // Имя сервиса (Бизнес-процесс)
                     , messbody:string          // сообщение
                     , XMLmessmeta:string       // Метаданные
                     , answerbody:@string       // ответ
                     , XMLanswermeta:@string    // Метаданные ответа
                     , timeout:integer          // таймаут в секундах (не указан то по настройкам QManager)
                     , corrmsgid:string         // GUID исходногоо сообщения
                     , receiver:string          // Система-получатель
                     , msgid:@string            // GUID  сообщения (если пусто присвоит система ) 
                     , answerid:@string         // GUID  ответа 
                     , priority:string          // приоритет сообщения N/F
                     ,comment:string            // коментарии в лог.
                       ):integer
  Var Rsd,v_priority,v_result=0;
  if ((ValType(priority) != V_UNDEF) and( priority == "F") )
     v_priority = "F";
  else
     v_priority ="N";
  end;
  errtxt ="" ;
  if (ValType(servicename) == V_UNDEF) errtxt = " Укажите ServiceName (имя сервиса)"; return - 1; end;  
  if (ValType(messbody) == V_UNDEF) messbody = ""; end;
  if (ValType(XMLmessmeta) == V_UNDEF) XMLmessmeta = ""; end;
  if (ValType(answerbody) == V_UNDEF) answerbody = "" ; end;
  if (ValType(XMLanswermeta) == V_UNDEF)XMLanswermeta = "" ; end;
  if (ValType(timeout) == V_UNDEF) timeout = null ; end;
  if (ValType(corrmsgid) == V_UNDEF) corrmsgid = "" ;  end;
  if (ValType(receiver) == V_UNDEF) receiver = "" ;  end;
  if (ValType(msgid) == V_UNDEF)   msgid = "" ;  end;
  if (ValType(answerid) == V_UNDEF)   answerid = "" ;  end;
  if (ValType(comment) == V_UNDEF)   comment = "" ;  end;
  if ((StrLen(messbody) > BUFFER_STRLEN) or (StrLen(XMLmessmeta) > BUFFER_STRLEN) )
    set_q_in_buffer(messbody,XMLmessmeta);
    Rsd = RsdCommand(" declare v_msgid    itt_q_message_log.msgid%type ; "+
                             " v_answerid itt_q_message_log.msgid%type ; "+
                             " v_errtxt   varchar2(3000) ; " +   
                     " begin v_msgid := ?; "+
                            " ? := it_rs_q_utils.do_s_service(p_use_in_buffer => true "+
                                                          " p_servicename => ? " +
                                                          " ,p_receiver    => ? " +
                                                          " ,p_priority    => ? " +
                                                          " ,p_corrmsgid   => ? " +
                                                          " ,p_comment     => ? " +
                                                          " ,p_timeout     => ? " +
                                                          " ,io_msgid      => v_msgid " + 
                                                          " ,o_answerid    => v_answerid " +
                                                          " ,o_errtxt      => v_errtxt ) ; "+
                            " ?:= v_msgid ; ?:= v_answerid ; ?:= v_errtxt;  end;" );
    Rsd.addParam("",RSDBP_IN,msgid);
    Rsd.addParam("p_result",RSDBP_OUT,V_INTEGER);
    Rsd.addParam("",RSDBP_IN,servicename);
    Rsd.addParam("",RSDBP_IN,receiver);
    Rsd.addParam("",RSDBP_IN,v_priority);
    Rsd.addParam("",RSDBP_IN,corrmsgid);
    Rsd.addParam("",RSDBP_IN,comment);
    Rsd.addParam("",RSDBP_IN,timeout,V_INTEGER);
    Rsd.addParam("p_msgid",RSDBP_OUT,V_STRING,200);
    Rsd.addParam("p_answerid",RSDBP_OUT,V_STRING,200);
    Rsd.addParam("p_errtxt",RSDBP_OUT,V_STRING,3000);
  else
    Rsd = RsdCommand(" declare v_msgid    itt_q_message_log.msgid%type ; "+
                             " v_answerid itt_q_message_log.msgid%type ; "+
                             " v_errtxt   varchar2(3000) ; " +   
                     " begin v_msgid := ?; "+
                            " ? := it_rs_q_utils.do_s_service(p_use_in_buffer => false "+
                                                          " ,p_servicename => ? " +
                                                          " ,p_messbody    => ? " +        
                                                          " ,p_messmeta    => ? " +
                                                          " ,p_receiver    => ? " +
                                                          " ,p_priority    => ? " +
                                                          " ,p_corrmsgid   => ? " +
                                                          " ,p_comment     => ? " +
                                                          " ,p_timeout     => ? " +
                                                          " ,io_msgid      => v_msgid " + 
                                                          " ,o_answerid    => v_answerid " +
                                                          " ,o_errtxt      => v_errtxt ) ; "+
                            " ?:= v_msgid ; ?:= v_answerid ; ?:= v_errtxt;  end;" );
    Rsd.addParam("",RSDBP_IN,msgid);
    Rsd.addParam("p_result",RSDBP_OUT,V_INTEGER);
    Rsd.addParam("",RSDBP_IN,servicename);
    Rsd.addParam("",RSDBP_IN,messbody);
    Rsd.addParam("",RSDBP_IN,XMLmessmeta);
    Rsd.addParam("",RSDBP_IN,receiver);
    Rsd.addParam("",RSDBP_IN,v_priority);
    Rsd.addParam("",RSDBP_IN,corrmsgid);
    Rsd.addParam("",RSDBP_IN,comment);
    Rsd.addParam("",RSDBP_IN,timeout,V_INTEGER);
    Rsd.addParam("p_msgid",RSDBP_OUT,V_STRING,200);
    Rsd.addParam("p_answerid",RSDBP_OUT,V_STRING,200);
    Rsd.addParam("p_errtxt",RSDBP_OUT,V_STRING,3000);
  end;
  BegAction (500,"Выполнение сервиса ["+servicename+"]| Ждите ...."); 
  Rsd.execute();
  EndAction ;
  v_result = Rsd.value("p_result");
  errtxt = Rsd.value("p_errtxt");
  if (v_result == 0 )
    msgid = Rsd.value("p_msgid");
    answerid = Rsd.value("p_answerid");
    get_q_out_buffer(@answerbody,@XMLanswermeta);
  else
    msgid = null ;
    answerid = null ;
    answerbody = null ;
    XMLanswermeta = null ;
  end;
  return v_result;
end;

// Запуск Асинхронного сервиса  
macro ITQ_DO_A_SERVICE(errtxt:@string           // Текст ошибки 
                     , servicename:string       // Имя сервиса (Бизнес-процесс)
                     , msgid:@string            // GUID  сообщения (если пусто присвоит система ) 
                     , messbody:string          // сообщение
                     , XMLmessmeta:string       // Метаданные
                     , corrmsgid:string         // GUID исходногоо сообщения
                     , receiver:string          // Система-получатель
                     , num_thread:integer       // Номер потока исполнения
                     , comment:string            // коментарии в лог.
                       ):integer
  Var Rsd,v_num_thread,v_result=0;
  if (ValType(num_thread) != V_UNDEF) 
     v_num_thread = num_thread;
  else
     v_num_thread = 0;
  end;
  errtxt ="" ;
  if (ValType(servicename) == V_UNDEF) errtxt = " Укажите ServiceName (имя сервиса)"; return - 1; end;  
  if (ValType(msgid) == V_UNDEF)   msgid = "" ;  end;                                      
  if (ValType(messbody) == V_UNDEF) messbody = ""; end;
  if (ValType(XMLmessmeta) == V_UNDEF) XMLmessmeta = ""; end;
  if (ValType(corrmsgid) == V_UNDEF) corrmsgid = "" ;  end;
  if (ValType(receiver) == V_UNDEF) receiver = "" ;  end;                                  
  if (ValType(comment) == V_UNDEF)   comment = "" ;  end;                                  
  if ((StrLen(messbody) > BUFFER_STRLEN) or (StrLen(XMLmessmeta) > BUFFER_STRLEN) )
    set_q_in_buffer(messbody,XMLmessmeta);                                                   
    Rsd = RsdCommand(" declare v_msgid    itt_q_message_log.servicename%type ; "+            
                             " v_errtxt   varchar2(3000) ; " +   
                     " begin v_msgid := ?; "+
                            " ? := it_rs_q_utils.do_s_service( p_use_in_buffer => true "+
                                                          " ,p_servicename => ? " +                
                                                          " ,p_receiver    => ? " +
                                                          " ,p_corrmsgid   => ? " +
                                                          " ,p_num_thread  => ? " +
                                                          " ,p_comment     => ? " +
                                                          " ,io_msgid      => v_msgid " + 
                                                          " ,o_errtxt      => v_errtxt ) ; "+
                            " ?:= v_msgid ; ?:= v_errtxt;  end;" );
    Rsd.addParam("",RSDBP_IN,msgid);
    Rsd.addParam("p_result",RSDBP_OUT,V_INTEGER);
    Rsd.addParam("",RSDBP_IN,servicename);
    Rsd.addParam("",RSDBP_IN,receiver);
    Rsd.addParam("",RSDBP_IN,corrmsgid);
    Rsd.addParam("",RSDBP_IN,v_num_thread);
    Rsd.addParam("",RSDBP_IN,comment);
    Rsd.addParam("p_msgid",RSDBP_OUT,V_STRING,200);
    Rsd.addParam("p_errtxt",RSDBP_OUT,V_STRING,3000);
  else
    Rsd = RsdCommand(" declare v_msgid    itt_q_message_log.servicename%type ; "+            
                             " v_errtxt   varchar2(3000) ; " +   
                     " begin v_msgid := ?; "+
                            " ? := it_rs_q_utils.do_s_service( p_use_in_buffer => false "+
                                                          " ,p_servicename => ? " +
                                                          " ,p_messbody    => ? " +        
                                                          " ,p_messmeta    => ? " +
                                                          " ,p_receiver    => ? " +
                                                          " ,p_corrmsgid   => ? " +
                                                          " ,p_num_thread  => ? " +
                                                          " ,p_comment     => ? " +
                                                          " ,io_msgid      => v_msgid " + 
                                                          " ,o_errtxt      => v_errtxt ) ; "+
                            " ?:= v_msgid ; ?:= v_errtxt;  end;" );
    Rsd.addParam("",RSDBP_IN,msgid);
    Rsd.addParam("p_result",RSDBP_OUT,V_INTEGER);
    Rsd.addParam("",RSDBP_IN,servicename);
    Rsd.addParam("",RSDBP_IN,messbody);
    Rsd.addParam("",RSDBP_IN,XMLmessmeta);
    Rsd.addParam("",RSDBP_IN,receiver);
    Rsd.addParam("",RSDBP_IN,corrmsgid);
    Rsd.addParam("",RSDBP_IN,v_num_thread);
    Rsd.addParam("",RSDBP_IN,comment);
    Rsd.addParam("p_msgid",RSDBP_OUT,V_STRING,200);
    Rsd.addParam("p_errtxt",RSDBP_OUT,V_STRING,3000);
  end;
  Rsd.execute();
  v_result = Rsd.value("p_result");
  errtxt = Rsd.value("p_errtxt");
  if (v_result == 0 )
    msgid = Rsd.value("p_msgid");
  else
    msgid = null ;
  end;
  return v_result;
end;

CLASS (TRsbPanel) GetPeriodPanel(p_Caption:string, p_BeginDate:date,p_EndDate:date) 
  private var FT_DATE = 9;

  private var F2 = 316,
              F3 = 317;
  InitTRsbPanel();
  Caption = p_Caption;         
  Status = "F2 - Продолжить  F3 - Календарь  ESC - Выход";
  setSize(29,6); 
  setPosition(15,8); 
  var BDate:Date = p_BeginDate; 
  var EDate:Date = p_EndDate;
  var m_EditField1:TRsbEditField = TRsbEditField(FT_DATE); 
  var m_EditField2:TRsbEditField = TRsbEditField(FT_DATE);
  var m_LabelBeginDate:TRsbLabel = TRsbLabel(3, 2, "Начало периода:"); 
  var m_LabelEndDate:TRsbLabel = TRsbLabel(3, 4,  " Конец периода:");
  addLabel(m_LabelBeginDate);
  addLabel(m_LabelEndDate);
  m_EditField1.bindValue(this, "BDate", 10);
  m_EditField1.Name = "BeginDate";
  m_EditField1.setPosition(17,2); 
  m_EditField1.setSize(10,1); 
  addControl(m_EditField1);
  m_EditField2.bindValue(this, "EDate", 10);
  m_EditField2.Name = "EndDate"; 
  m_EditField2.setPosition(17,4); 
  m_EditField2.setSize(10,1); 
  addControl(m_EditField2);
  addEventHandler(RSB_EV_KEY_PRESSED,R2M(this,"KeyPressed"));   
  macro KeyPressed(RsbEvent:Object)
    var focusedControl;      
    if (rsbEvent.KeyCode == F3)                
      focusedControl = this.focusedControl();                    
      if ((focusedControl.Name == "BeginDate") or (focusedControl.Name == "EndDate"))
        focusedControl.Value = GetDateByCalendar(focusedControl.Value);                
      end;
    elif (rsbEvent.KeyCode == F2)
      if ((m_EditField1.Value == date(0,0,0)) or
          (m_EditField1.Value == date(0,0,0)) or
          (m_EditField1.Value > m_EditField2.Value))
        Msgbox("Укажите правильный период!");
        return false;
      end;
      this.Close(1);
    end; 
    return true;
  end;
end;

macro IT_parallel_exec_clear_calc(v_calc_id)
  var Rsd = RsdCommand(" begin it_parallel_exec.clear_calc("+string(v_calc_id)+");  end;" );
  Rsd.execute();
end;


macro IT_log(p_text:string,p_macfile:string,p_clob:string)
  var CallStack = GetCallStack,query;
  if ((ValType(p_macfile) == V_UNDEF) or (StrLen (p_macfile ) == 0) and (Asize(CallStack) > 1))
    p_macfile = "" ;
    for ( var n, 2, Min ( 4, Asize(CallStack)-1),1)
      p_macfile = CallStack(n)+"/"+p_macfile;
    end;
  else
    p_macfile = p_macfile+"/"
  end ;
  
  var object = p_macfile+CallStack(1) ;

  if (StrLen(object)>100)
    object = ".."+substr(object,StrLen(object)-97);
  end;
  
  if (StrLen (p_clob ) > 32767 )
    IT_SetClobBufer(p_clob) ;
    query = "begin " +
                " it_log.log_handle(p_object   => :object, " +
                                  " p_msg      => :msg, " +
                                  " p_msg_type => it_log.c_msg_type__debug,"
                                  " p_msg_clob => it_rsl_string.get_clob); " +
                "end;";
    execSQL(query, makeArray(SQLParam("object", object),
                             SQLParam("msg", SubStr(p_text,1,4000))
                             ));

  else
    query = "begin " +
                " it_log.log_handle(p_object   => :object, " +
                                  " p_msg      => :msg, " +
                                  " p_msg_type => it_log.c_msg_type__debug,"
                                  " p_msg_clob => :clob); " +
                "end;";
    execSQL(query, makeArray(SQLParam("object", object),
                             SQLParam("msg", SubStr(p_text,1,4000)),
                             SQLParam("clob", p_clob)
                             ));
  end;
end;

macro IT_logError(p_text:string,p_macfile:string,p_clob:string)
  var CallStack = GetCallStack,query;

  if ((ValType(p_macfile) == V_UNDEF) or (StrLen (p_macfile ) == 0) and (Asize(CallStack) > 1) )
    p_macfile = "" ;
    for ( var n, 2, Min ( 4, Asize(CallStack)-1),1)
      p_macfile = CallStack(n)+"/"+p_macfile;
    end;
  else
    p_macfile = p_macfile+"/"
  end ;

  var object = p_macfile+CallStack(1);

  if (StrLen(object)>100)
    object = ".."+substr(object,StrLen(object)-97);
  end;

  if (StrLen (p_clob ) > 32767 )
    IT_SetClobBufer(p_clob) ;
    query = "begin " +
                " it_log.log_error(p_object   => :object, " +
                                  " p_msg      => :msg, " +
                                  " p_msg_clob => it_rsl_string.get_clob); " +
                "end;";
    execSQL(query, makeArray(SQLParam("object", object),
                             SQLParam("msg", SubStr(p_text,1,4000))
                             ));

  else
    query = "begin " +
                " it_log.log_error(p_object   => :object, " +
                                 " p_msg      => :msg, " +
                                 " p_msg_clob => :clob); " +
                "end;";
    execSQL(query, makeArray(SQLParam("object", object),
                               SQLParam("msg", SubStr(p_text,1,4000)),
                               SQLParam("clob", p_clob)
                               ));
  end;
end;

MACRO IT_Protocol(object,msg)
  var query = "begin " +
                " it_log.log_handle(p_object   => :object, " +
                                  " p_msg      => :msg, " +
                                  " p_msg_type => it_log.C_MSG_TYPE__MSG); " +
                "end;";
  execSQL(query, makeArray(SQLParam("object", object),
                             SQLParam("msg", SubStr(msg,1,4000))
                             ));
END;

MACRO IT_ProtocolError(object,msg)
  var query = "begin " +
                " it_log.log_error(p_object   => :object, " +
                                 " p_msg      => :msg); " +
                "end;";
  execSQL(query, makeArray(SQLParam("object", object),
                             SQLParam("msg", SubStr(msg,1,4000))
                             ));
END;



