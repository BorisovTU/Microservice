/*
$Name:               CASELIB.mac
$Module:            Кридитование
$Description:      Библиотека функций для работы с портфелями
*/
/*
 ╔════════════════════════════════════════════════════════════════════╗
 ║ RS-LOANS                                                           ║
 ║                                                                    ║
 ║ Библиотека функций для работы с портфелями                         ║
 ║ Импортируется в s_dcase.mac и в sdcase2.mac                        ║
 ╟────────────────────────────────────────────────────────────────────╢
 │ Date      : 30.09.2008                                             │
 └────────────────────────────────────────────────────────────────────┘
 */
IMPORT "total.mac";//,"deprIntr.mac" ;

PRIVATE RECORD credit_c ("credit_c.dbt");          // текущий буфер ОБЯЗАТЕЛЬСТВА
PRIVATE RECORD UniformBuf ("lbrf_uniformity.dbt"); // буфер признаков однородности портфеля
PRIVATE VAR    ErrManager :CErrManager;            // менеджер ошибок. Выдает сообщение о ошибке если такая имела место при отборе КД для привязки
PRIVATE CONST  ALTF9      :integer = 368;          // режим привязки с более жосткими ограничениями, учитывающий при отборе КД предлагающихся для привязки - свободный объем портфеля
PRIVATE CONST  F9         :integer = 323;

// Глобальные переменные, значения устанавливаются из скроллинга
//╔═══════════════════════════════════════════════════════════════════════════╗

   VAR lbrfcase = TRecHandler("lbrfcase.dbt", "loans.def"); // Буфер портфеля
   VAR OperDate: date;              // Дата операции

   // Флаги однородности Портфеля.
   VAR xTypeCredit        : string = "", // Вид кредита
       xCurCode           : string = "", // Валюта
       xTypeContract      : string = "", // Тип договора
       xPeriodFirst       : string = "", // Дата начала периода
       xTypeDebtor        : string = "", // Дата окончания периода
       xUserTypeCrd       : string = "", // Вид кредита
       xPeriodLast        : string = "", // Дата окончания периода
       xPrivilege         : string = "", // Льгот
       xInsider           : string = "", // Инсайдер
       xSecure            : string = "", //
       xSecuredCredits    : string = "", // Обеспеченные кредиты
       xNotSecuredCredits : string = "", // Необеспеченные кредиты
       xDV                : string = "",
       xAccLB             : string = "";

   VAR LOW_MODE      : bool   = FALSE; // Флаг "мягкого" режима отбора ОБЯЗАТЕЛЬСТВ

   VAR CurSumCase    : integer = 0; // Валюта портфеля из настроек
   VAR MaxSumCase    : money   =$0; // Максимальная сумма портфеля
   VAR MaxSumDuty    : money   =$0; // Максимальная сумма обязательства
   VAR CurSumClient  : integer = 0;
   VAR MaxSumClient  : money   =$0;
   VAR CheckSumCase  : bool    = TRUE; // Проверять величину портфеля
   VAR CheckSumDuty  : bool    = TRUE; // Проверять величину обязательства
   VAR checkSumClient: bool    = FALSE;
   VAR OperType      : integer = 0;
   VAR key_mode      : integer = 0;
   VAR SMP           : string  = ""; // признак кредитов СМП

   // #202786
   VAR FreeCaseVoluem : money = $0;            // свободный объем портфеля (макс_сумма - тек_сумма ПФ)
   VAR SumSelCrdToBind : money = $0;           // сумма отобранных КД для привязки
   VAR CrdArr = TArray;                        // массив обработанных КД
   VAR exitflag :integer = 0;                  // флаг выхода если не найдены признаки однородности портфеля
//└───────────────────────────────────────────────────────────────────────────┘

CONST AttachNewLoan = 1, // Привязка новых ссуд
      UntieLoan     = 2, // Отвязать ссуду
      TransferLoan  = 3, // Перевести ссуду
      TransferLoanFromGroup = 4, // Перевод ссуд из групп
      TransferLoanFromCase  = 5; // Перевод ссуд из портфеля

// СуммаПортфеля (НомерПортфеля : INTEGER, [ДатаРасчета : DATE], [НомерРегистра : INTEGER]) : MONEYL
MACRO CalcFreeCaseVoluem(caseid :integer)
   var cmd;
   var CurrentCaseVoluem :money = $0;
   var retval :money = $0;

   cmd = RsdCommand(RslDefCon, "begin ? := NVL(LoansKernel.getCaseSum(?, ?, ?, ?), 0); end;");
   cmd.addParam("retval", RSDBP_RETVAL, V_MONEY);
   cmd.addParam("caseid", RSDBP_IN);  cmd.value("caseid") = caseid;
   cmd.addParam("opdate", RSDBP_IN);  cmd.value("opdate") = date(20,6,2013);
   cmd.addParam("regid",  RSDBP_IN);  cmd.value("regid")  = 0;  // по всем регистрам
   cmd.addParam("dutcnt", RSDBP_OUT, V_INTEGER);

   cmd.execute();
   CurrentCaseVoluem = cmd.value ("retval");
   FreeCaseVoluem = MaxSumCase - CurrentCaseVoluem;
END;

//Возращает TRUE если КД обеспечено, иначе FALSE
//алгоритм определения описан в PRJ_001121_Портфели.doc#72
MACRO КД_ОБЕСПЕЧЕН(CreditNumber:integer,OperDate:date)
     var count:integer;
     count = CRSDCommand ("select count(*) " +
                                " from " +
                                "( " +
                                    "select hquality.* " +
                                    "from denscontr_dbt enscontr , dens_crd_dbt ens_crd, dhquality_dbt hquality " +
                                    "where ENS_CRD.T_CREDITNUMBER_REF = ? " +
                                    "AND ENSCONTR.T_ENSCONTRACTID = ENS_CRD.T_ENSCONTRACTID_REF " +
                                    "AND ENSCONTR.T_ENSSYSTYPE = 1 " +
                                    "AND HQUALITY.T_OBJECTTYPEID = 4 " +
                                    "AND HQUALITY.T_OBJECTNUMBER = enscontr.T_ENSCONTRACTID " +
                                    "union " +
                                    "select hquality.* " +
                                    "from denscontr_dbt enscontr , dens_crd_dbt ens_crd, dhquality_dbt hquality, decn_eob_dbt ecn_eob " +
                                    "where ENS_CRD.T_CREDITNUMBER_REF = ? " +
                                    "AND ENSCONTR.T_ENSCONTRACTID = ENS_CRD.T_ENSCONTRACTID_REF "+
                                    "AND " +
                                    "( " +
                                        "ENSCONTR.T_ENSSYSTYPE != 1 " +
                                        "AND ECN_EOB.T_ENSCONTRACTID_REF = ENSCONTR.T_ENSCONTRACTID " +
                                        "AND HQUALITY.T_OBJECTTYPEID = 5 " +
                                        "AND HQUALITY.T_OBJECTNUMBER = ECN_EOB.T_ENSOBJECTID_REF " +
                                    ") " +
                                ")  hquality_temp " +
                                "where " +
                                "hquality_temp.T_QUALITYID IN (1,2) " +
                                "and hquality_temp.T_DATE <= ?",
            "", CreditNumber ,
            "", CreditNumber ,            
            "", OperDate,
            V_INTEGER);
   IF (count == 0)
      RETURN FALSE;
   ELSE
      RETURN TRUE;
   END;              
END;
// Фильтр ОБЯЗАТЕЛЬСТВ
MACRO CheckRecord(curReccord)

   VAR RSDcmd;
   VAR SumDuty       : money = $0;
   VAR SumClient     : money = $0;
   VAR Insider       : bool    = FALSE;
   VAR Found         : bool    = FALSE;
   VAR Period        : integer = 0;
   VAR I             : integer = 0;
   VAR count         : integer = 0;
   VAR EnsQuality    : integer = 0;
   VAR CategorySMP   : integer = 0;
   VAR CategoryDV    : integer = 0;
   VAR ObjID         : integer = 0;
   
   IF (exitflag == 1)
      RETURN FALSE; // если признаки однородности не найдены, значит нечего нам тут делать выходим
   END;

   setBuff(credit_c, curReccord);
   
   IF (lbrfcase.rec.ReferenceID == 0) 
      ObjID = lbrfcase.rec.BriefcaseID;
   ELSE 
      ObjID = lbrfcase.rec.ReferenceID;  // используем ID портфеля для поиска признаков однородности если привязка деламе из ГОТ, т.к. признаки хранятся только по портфелю
   END;

   CalcFreeCaseVoluem(ObjID);
   
   IF (not Loans_FindCaseUniformity(ObjID, UniformBuf))
      msgbox("Признаки однородности портфеля не найдены!");
      exitflag = 1;

      RETURN FALSE;        
   END;

   IF (lbrfcase.rec.type == 0)
      IF ((credit_c.crd_kind == 1)          AND
          (credit_c.paytype  != CF_CRLIN)   AND
          (credit_c.paytype  != CF_CRLINNO) AND
          (credit_c.paytype  != CF_CRLINNEW))

         RETURN FALSE;
      END;
   END;

   IF((OperType == 0) OR
      (OperType == AttachNewLoan)
     )
       RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansKernel.DutyInCases(?,?,?,?); end;");
       RSDcmd.addParam("retval",   RSDBP_RETVAL, V_INTEGER);
       RSDcmd.addParam("objid",    RSDBP_IN); RSDcmd.value   ("objid")    = 0;
       RSDcmd.addParam("objn",     RSDBP_IN); RSDcmd.value   ("objn")     = credit_c.CreditNumber;
       RSDcmd.addParam("dt",       RSDBP_IN); RSDcmd.value   ("dt")       = OperDate;
       RSDcmd.addParam("casetype", RSDBP_IN); RSDcmd.value   ("casetype") = lbrfcase.rec.Type;

       RSDcmd.execute();

       // Договор привязан к портфелю :(
       IF (RSDcmd.value("retval") != 0)
          RETURN FALSE;
       END;
   END;

   IF (LOW_MODE)
      RETURN TRUE;
   END;

   IF (CheckSumDuty OR CheckSumCase)
      SumDuty = ОстатокРегистраДляЭлементаРасчетнойБазы(credit_c.crd_kind, credit_c.CreditNumber, credit_c.paytype, OperDate, lbrfcase.rec.type);
      IF (credit_c.CurCode > 0)
         RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansKernel.RateCB(?,?); end;");
         RSDcmd.addParam("retval",  RSDBP_RETVAL, V_NUMERIC);
         RSDcmd.addParam("cbdate",  RSDBP_IN); RSDcmd.value("cbdate")  = OperDate;
         RSDcmd.addParam("curcode", RSDBP_IN); RSDcmd.value("curcode") = credit_c.CurCode;
         RSDcmd.execute();
         SumDuty = SumDuty * RSDcmd.Value(0);
      END;

      IF (((SumDuty > MaxSumDuty) AND CheckSumDuty) OR ((SumDuty > MaxSumCase) AND CheckSumCase))
         RETURN FALSE;
      END;
   END;

   SumClient = CRSDCommand("SELECT /*+ RESULT_CACHE */ SUM(LoansKernel.GetCaseDutySum(T_CRD_KIND, T_CREDITNUMBER, ?, 0, ?) * LoansKernel.RateCB(?, T_CURCODE)) as s " + 
                           " FROM DCREDIT_C_DBT WHERE T_CLIENTID_REF = ?", 
                             "p1", OperDate,
                             "p2", lbrfcase.rec.type,
                             "p3", OperDate,
                             "p4", credit_c.ClientID_Ref,
                           V_MONEY);

   //SVS 210041 
   //Отключаю фильтр на ограничение по сумме
   /*
   IF ((MaxSumClient != 0) and (SumClient > MaxSumClient))
      RETURN FALSE;
   END;
   */
   IF (credit_c.fncash != lbrfcase.rec.fncash)
      RETURN FALSE;
   END;

   /* 1: Вид кредита */
   IF (Trim(xTypeCredit) == "X")
      count = CRSDCommand("SELECT /*+ RESULT_CACHE */ COUNT(1) FROM DCASE_TCR_DBT WHERE T_BRIEFCASEID_REF = ? AND T_CREDITTYPEID_REF = ?", 
                          "p1", ObjID,
                          "p2", credit_c.CreditTypeID_Ref,
                          V_INTEGER);
      IF (count == 0)
         RETURN FALSE;
      END;
   END;

   /* 2: Валюта  */
   IF ((Trim(xCurCode) == "X") AND 
       (credit_c.CurCode  != Uniformbuf.CurCode))
      RETURN FALSE;
   END;

   /* 3: Вид объекта */
   IF (Trim(xTypeContract) == "X")
      IF ((UniformBuf.TypeContract == CASE_UNI_TC_StandartCredit) OR (UniformBuf.TypeContract == CASE_UNI_TC_CessionCredit))
         IF (credit_c.Crd_kind != LO_CREDIT)
            RETURN FALSE;
         ELSE
            var isPurchased: bool = CRSDCommand ("SELECT COUNT(ROWNUM) " +
                                                   "FROM DCRDLINK_DBT WHERE " + 
                                                        "T_OBJECTNUMBER = ? " +
                                                    "AND T_OBJECTTYPEID = ? " +
                                                    "AND T_TYPEPARENT IN (?, ?, ?)",
                                                      "objnum", credit_c.CreditNumber,
                                                      "objtid", LO_CREDIT,
                                                      "inprm1", LO_DOGCREDCLAIMCESSION,
                                                      "inprm2", LO_DOGCREDCLAIMBUYBACK,
                                                      "inprm3", LO_DOGCREDCLAIMBUY,
                                                     V_INTEGER);
 
            IF ((UniformBuf.TypeContract == CASE_UNI_TC_StandartCredit) AND isPurchased)
               RETURN FALSE;

            ELIF ((UniformBuf.TypeContract == CASE_UNI_TC_CessionCredit) AND NOT isPurchased)
               RETURN FALSE

            END;
         END;
      ELSE 
         IF (UniformBuf.TypeContract == CASE_UNI_TC_GUARANTEE)
            IF (credit_c.Crd_kind != LO_GUARANTEE)
               RETURN FALSE;

            END;
         ELSE 
            IF (UniformBuf.TypeContract == CASE_UNI_TC_OVERDRAFT)
               IF (credit_c.Crd_kind != LO_OVERDRAFT)
                  RETURN FALSE;

               END;
            ELSE 
               IF (UniformBuf.TypeContract = CASE_UNI_TC_Karta)
                  IF (credit_c.Crd_kind != LO_KARTA)
                     RETURN FALSE;

                  END;
               END;
            END;
          END;
      END; 
   END;

   // Тип заемщика
   IF (lbrfcase.rec.type == 1)
       var isEmp = 0;
      // портфель ссуд
      IF (credit_c.TypeDebtor != lbrfcase.rec.TypeDebtor)
         IF ((credit_c.TypeDebtor == 2) AND (lbrfcase.rec.TypeDebtor == 1))  //  необходимо учесть физ.лица ИП (в частности для учета кредитов СМП)
            isEmp = CRSDCommand("SELECT /*+ RESULT_CACHE */ 1 FROM DCREDIT_C_DBT C, DPERSN_DBT PERSN " +
                                " WHERE C.T_CLIENTID_REF = PERSN.T_PERSONID AND PERSN.T_ISEMPLOYER = 'X' AND  C.T_CLIENTID_REF = ?",
                                "p1", credit_c.clientID_Ref, 
                               V_INTEGER);
            IF (isEmp == 0)
               RETURN FALSE;  // если портфель юр.лиц, а субьект КД физ.лицо и не является ИП тогда пропускаем данный КД
            END;
         ELSE
            RETURN FALSE;
         END;
     END;
   ELSE
      // портфель условных обязательств
      IF ((Trim(xTypeDebtor)  == "X") AND
          (credit_c.TypeDebtor != lbrfcase.rec.TypeDebtor))
         RETURN FALSE;
      END;
   END;

   /* 5: Пользовательский вид кредита */
   IF (Trim(xUserTypeCrd) == "X")

      IF (Trim(UniformBuf.UserKindCredit) == "")
         IF (Trim(credit_c.UserType) != "")
            RETURN FALSE;
         END;
      ELSE
         I     = 0;
         Found = FALSE;
         WHILE ((I < StrLen(UniformBuf.UserKindCredit)) AND (NOT Found))
            IF (Index(credit_c.UserType, SubStr(UniformBuf.UserKindCredit, I+1, 1)) != 0)
               Found = TRUE;
            END;
            I = I + 1;
         END;

         IF (NOT Found)
            RETURN FALSE;
         END;
      END;
   END;

   /* 6: Льготный кредит */
   IF (Trim(xPrivilege) == "X")
      var isPrivileged: bool;
      var isGracePeriod: string;

      isGracePeriod = CRsdCommand( "SELECT /*+ RESULT_CACHE */ T_ISGRACEPERIOD FROM DTYPE_CRD_DBT WHERE " +
                                   " T_CREDITTYPEID = ?", 
                                   "objn", credit_c.credittypeid_ref, 
                                  V_STRING);
 
      IF ((credit_c.TypeDebtor == 2) AND ((credit_c.crd_kind == LO_CREDIT) AND (credit_c.PrivilegeFlag == "X")))
         isPrivileged = TRUE;
      ELIF ((credit_c.crd_kind == LO_KARTA) AND
            (isGracePeriod == "X"))
         isPrivileged = TRUE;
      ELSE
         isPrivileged = FALSE;
      END;

      IF (UniformBuf.PrivilageFlag == "X")
         IF (NOT isPrivileged)
            RETURN FALSE;
         END;
      ELSE
         IF (isPrivileged)
            RETURN FALSE;
         END;
      END;
   END;

   /* 7: Кредиты инсайдерам */
   IF (Trim(xInsider)           == "X")
      Insider = IsInsider(credit_c.ClientID_Ref);

      IF (UniformBuf.InsiderFlag == "X")
         IF (NOT Insider)
            RETURN FALSE;
         END;
      ELSE
         IF (Insider)
            RETURN FALSE;
         END;
      END;
   END;

   /* Срок договора от... */
   IF (Trim(xPeriodFirst) == "X")
      Period = credit_c.ReturnDate - credit_c.RegDate;
      IF (UniformBuf.TypePeriodFirst == CF_MONTH)
         IF ((Period / 30) < UniformBuf.PeriodFirst)
            RETURN FALSE;
         END;
      ELSE
         IF (Period < UniformBuf.PeriodFirst)
            RETURN FALSE;
         END;
      END;
   END;

   /* Срок договора до... */
   IF (Trim(xPeriodLast) == "X")
      Period = credit_c.ReturnDate - credit_c.RegDate;

      IF (UniformBuf.TypePeriodLast == CF_MONTH)
         IF ((Period / 30) > UniformBuf.PeriodLast)
            RETURN FALSE;
         END;
      ELSE
         IF (Period > UniformBuf.PeriodLast)
            RETURN FALSE;
         END;
      END;
   END;

   /* Обеспеченность */
   IF (Trim(xSecure) == "X")

      var flag = КД_ОБЕСПЕЧЕН(credit_c.CreditNumber, OperDate);
      IF ((Trim(xSecuredCredits) == "X") and  (flag == FALSE))
        RETURN FALSE;
      END;

      IF ((Trim(xNotSecuredCredits) == "X") and (flag == TRUE))
        RETURN FALSE;  
      END;
   END;

   IF (Trim(SMP) == "X")
      CategorySMP = CRSDCommand ("select /*+ RESULT_CACHE */ " +
                "rsb_rep_ac.CheckObjAttrPresenceByNum (?, ?, ?, " + 
                "rcb_objattr.makePartyId(?), ?) " +
                "from dual",
                "objtype", 3,
                "groupid", 39,
                "numinlist", "МСП",
                "objid", credit_c.ClientID_Ref,
                "dat", OperDate,
                V_INTEGER);
      IF (CategorySMP == 0)
         RETURN FALSE;
      END;
   END;

   IF (Trim(xDV) == "X")
      IF ((UniformBuf.DATEISSUEOF != date(0,0,0)) OR (UniformBuf.DATEISSUESO != date(0,0,0)) )
         var cs;  
         var DateCrdOp;
         
         IF (credit_c.CRD_KIND == 21) //LO_GUARANTEE)
           cs =45;// CS_GUARPAYM;
         ELSE
           cs=CS_PAY;
         END;
         
         IF (credit_c.CRD_KIND > 0)
            DateCrdOp = LnSelectValue("SELECT T_CREDOPERDATE FROM DCRD_OP_DBT WHERE T_OBJECTTYPEID_REF = ? AND T_OBJECTID_REF = ? AND T_SYSTEMOPERATIONID = ? AND T_ISDELETED = 0", 
                                      "p1", credit_c.crd_kind,
                                      "p2", credit_c.CreditNumber,
                                      "p3", cs,
                                     V_DATE);
            IF (DateCrdOp=="")
               RETURN FALSE;
            END;

            IF (UniformBuf.DateIssueOf   != date(0,0,0))
               IF (DateCrdOp < UniformBuf.DATEISSUEOF)
                  RETURN FALSE;
               END;
            END;              
            IF (UniformBuf.DateIssueSo  != date(0,0,0))
               IF (UniformBuf.DateIssueSo < DateCrdOp)
                  RETURN FALSE;
               END;
           END;
         END; 
      ELSE 
        RETURN FALSE;
      END;
   END;

   IF (Trim(xAccLB) == "X")
      var RetailResponse;
      var CoreResponse;

      CoreResponse= ClientHasSalaryAccount(credit_c.CLIENTID_REF);
      var stat = IsExistSalaryAcc(credit_c.CLIENTID_REF,RetailResponse); 
  
      IF (UniformBuf.AccLB ==0 )
         IF (NOT((CoreResponse == FALSE)  AND (RetailResponse==0)))
            RETURN FALSE;
         END;
      ELSE
         IF (UniformBuf.AccLB ==1)
            IF (NOT((CoreResponse == TRUE) OR (RetailResponse==1)))
               RETURN FALSE;
            END;
         END;
      END;
   END;

   // #202787
   // режим привязки Alt-F9 
   // если с учетом суммы тек. КД. общая сумма всех отобранных КД для привязки, далее СуммаОтобранныхКД,  превышает свободный размер портфеля
   // то данный КД не отбираем в скроллинг привязки
   // Тоесть, необходимо, что бы выполнялось условие СуммаОтобранныхКД  <=  СвободныйРазмерПФ.  СвободныйРазмерПФ = МаксРазмерПФ - ТекущРазмерПФ.
   // Поскольку макрос запускается для каждого КД несколько раз то сумму КД необходимо включить в общую сумму всех уже рассмотренных КД, всего один раз.
   // И поэтому данный участок кода фильтрует КД сумма которых уже учтена. ID рассмотренных КД хранятся в массиве

   IF (key_mode == ALTF9)
      IF (MaxSumCase != 0)   // если макс. сумма ПФ MaxSumCase не задана то данное ограничение, согласно документации, не учитываем вообще ни при каких обстоятельствах

         // ищем текущий договор в массиве рассмотренных договоров. Если такоей есть, то далее его пропускаем
         var j = 0,  isProcessed = 0;
         WHILE (j < CrdArr.Size)
            IF (CrdArr[j] == credit_c.creditnumber)
               isProcessed = 1; 
               break;
            END;
            j = j + 1;
         END;

         IF (isProcessed == 0)                      
            CrdArr[CrdArr.Size] = credit_c.creditnumber;  // включаем договор в массив уже рассмотренных 
            
            IF ((SumSelCrdToBind + SumDuty) > FreeCaseVoluem)  // Если сумма текущего сформированного отбора договоров с учетом суммы очередного договора - больше свободного размера портфеля то пропускаем данный договор
               RETURN FALSE;            
            ELSE
               SumSelCrdToBind = SumSelCrdToBind + SumDuty;     // DEBUG msgbox("FreeCaseVoluem = ", FreeCaseVoluem, "|SumSelCrdToBind = ", SumSelCrdToBind,  "| SumDuty = ", SumDuty);
            END;
         END; 
      END;
   END;
   
   RETURN TRUE;

   onError(err)
      IF (ValType(err.Err) == V_INTEGER)
         ErrManager.SetError(err.Err, err.Message);
      ELSE
         ErrManager.SetError(err.Code, err.Message);
      END;

      println("err.Message=",err.Message);
      RETURN FALSE;
END;