/*
$Name:             ora_func.mac
$Module:           Кредитование
$Description:      Макрос общих функций для работы с Ораклом
*/
/*------------------------------------------------------------------------------
                     Библиотека интерпретируемых модулей

 Filename    : ora_func.mac                                              22.01.18
 Description : Макрос общих функций для работы с Ораклом

 Programmer  : TFS
 22.01.18    : Создан
------------------------------------------------------------------------------
*/

Import rsd;

MACRO LnGetRecordSet(Query, MsgPrint)
    VAR i = 0;
    VAR rs = NULL, RSDcmd = NULL;

    trace(Query);
    RSDcmd = RsdCommand(RslDefCon, Query);
    IF (RSDcmd != NULL)
       rs  = RsdRecordset(RSDcmd);
    END;
    RSDcmd.execute;
    RETURN rs;

    onError(er)
      WHILE( i < RslDefEnv.ErrorCount )
        IF (MsgPrint)
           println(RslDefEnv.error(i).descr);
        END;
        trace(RslDefEnv.error(i).descr);
        i = i + 1;
      END;
      RETURN NULL;
END;

/*Функция выполнения sql-команды без получения данных (recordSet) */
MACRO LnSqlExec(CmdText, MsgPrint)
    VAR i = 0, RSDcmd = NULL;

    trace(CmdText);
    RSDcmd = RsdCommand(RslDefCon, CmdText);
    IF (RSDcmd != NULL)
       RSDcmd.execute;
    END;
    RETURN TRUE;

    onError(er)
      WHILE( i < RslDefEnv.ErrorCount )
        IF (MsgPrint)
           println(RslDefEnv.error(i).descr);
        END;
        trace(RslDefEnv.error(i).descr);
        i = i + 1;
      END;
      RETURN FALSE;
END;


PRIVATE MACRO FileNameSQL(table_id)
   VAR flName = FileName(table_id);
   IF (isSQL)
      RETURN "d"+ strsubst(flName, ".", "_");
   END;
END;

/*
Запуск хранимой функции.
   1. ProcName   - имя хранимой процедуры (с названием пакета)
   2. RetValType - тип возвращаемого значения
   3. RetValSize - размер буфера возвращаемого значения (для типов STRING)
   4-й и т.д. - параметры, передаваемые в хранимую функцию. Все параметры должны быть строго входящими (IN)
Возвращает значение, возвращаемое хранимой функцией
*/
MACRO RunStoredFunc(ProcName, RetValType, RetValSize)
   VAR ParmNum = 3, ParmVal = NULL, RSDcmd = NULL, i = 0, ParmArr : TArray = Tarray();
   VAR cmdText = "begin ? := " + ProcName + "(";

   trace(ProcName);
   WHILE (GetParm(ParmNum, ParmVal))
      ParmArr[ParmArr.size] = ParmVal;
      trace("Parm"+ string(ParmNum-3) + " = " + ParmVal);
      IF (ParmNum == 3)
         cmdText = cmdText + "?";
      ELSE
         cmdText = cmdText + ", ?";
      END;
      ParmNum = ParmNum + 1;
   END;
   cmdText = cmdText + "); end;";

   RSDcmd = RsdCommand(RslDefCon, cmdText);
   IF (RSDcmd == NULL)
      RETURN NULL;
   END;

   IF (RetValSize != NULL)
      RSDcmd.AddParam("retval", RSDBP_RETVAL, RetValType, RetValSize);
   ELSE
      RSDcmd.AddParam("retval", RSDBP_RETVAL, RetValType            );
   END;

   ParmNum = 1;
   WHILE(ParmNum <= ParmArr.size)
     RSDcmd.AddParam(string(ParmNum), RSDBP_IN, ParmArr[ParmNum - 1]);
     ParmNum = ParmNum + 1;
   END;

   RSDcmd.execute;
   RETURN RSDcmd.value(0);

   onError(er)
     WHILE( i < RslDefEnv.ErrorCount )
       trace(RslDefEnv.error(i).descr);
       i = i + 1;
     END;
     RETURN FALSE;
END;


/* Удаление строк таблицы
   TabName   название таблицы
   WereCond  условие отбора удаляемых строк. Если NULL - удаляются все строки
   MsgPrint  TRUE - печатает запрос в стандартный поток вывода, FALSE - не печатает (по умолчанию)*/
MACRO ClearTable (TabName, WhereCond, MsgPrint)
   VAR WhereStr = "";

   IF (WhereCond != NULL)
      WhereStr = " WHERE " + WhereCond;
   END;

   RETURN LnSqlExec("DELETE FROM " + TabName + WhereStr);
END;

/* Функция для замены Nrecords */
MACRO NrecSQL(table_id)
   VAR rs = NULL;

   rs = LnGetRecordset("SELECT count(*) FROM " + FileNameSQL(table_id));
   IF (rs == NULL)  RETURN 0           END;
   IF (rs.MoveNext) RETURN rs.value(0, NULL, V_INTEGER) END;

   RETURN 0;
END;

MACRO SQLDate(d:date)

   IF ((ValType(d) == V_UNDEF) or (d == date(0,0,0)))
      RETURN "TO_DATE('1.1.1', 'dd.mm.yyyy')"
   END;

   RETURN "TO_DATE('" + d + "', 'dd.mm.yyyy')";
END;

MACRO SQLString(str:string)
    if (str == "")
        return "chr(0)";
    else
        return "'" + str + "'";
    end;
END;

PRIVATE MACRO Ret0(ValueType : integer)

   if   (ValueType == V_INTEGER)
      return int(0);
   elif (ValueType == V_DOUBLE)
      return double(0);
   elif (ValueType == V_DOUBLEL)
      return doublel(0);
   elif (ValueType == V_STRING)
      return "";
   elif (ValueType == V_MONEY)
      return money(0);
   elif ((ValueType == V_DATE) OR (ValueType == V_DTTM))
      return date(0,0,0);
   elif (ValueType == V_TIME)
      return time(0,0,0);
   end;

   return null;
END;

/* Получить результат выполнения SQL запроса */
MACRO LnSelectValue(Query : string, ValueType : integer, ndx : integer)

   VAR rs = NULL;

   IF (ValType(ndx) == V_UNDEF)
      ndx = 0;
   END;

   rs = LnGetRecordset(Query, TRUE);

   IF(rs != NULL)
       rs.Command.NullConversion = TRUE;
   END;

   IF ((rs != NULL) AND rs.MoveNext AND (rs.value(ndx, NULL, ValueType) != NullVal) AND (ValType(rs.value(ndx, NULL, ValueType)) != V_UNDEF))
      RETURN rs.value(ndx, NULL, ValueType);
   END;

   RETURN Ret0(ValueType);
END;

/* Получить значение поля ndx первой строки рекордсета rs. Вернуть значение типа ValueType  */
macro rsSelectValue(rs : object, ValueType : integer, ndx : integer)

   if (ValType(ndx) == V_UNDEF)
      ndx = 0;
   end;

   if(rs != null)
       rs.Command.NullConversion = true;
   end;

   if ((rs != null) and rs.MoveNext and (rs.value(ndx, null, ValueType) != NullVal) and
         (ValType(rs.value(ndx, null, ValueType)) != V_UNDEF) )
      return rs.value(ndx, null, ValueType);
   end;

   return Ret0(ValueType);
end;


// Преобразование типов данных, возвращаемых SQL запросами
MACRO SQL_NVL(val, type)
   VAR dt: date;

   // Тип datetime => date
   IF ((ValType(val) == V_DTTM) AND (type == V_DATE))
      DtTmSplit(val, dt);

      IF (
          (
           (dt == DATE(0,0,0))
           OR
           ((dt - 1) == DATE(0,0,0))
          )
         )
         RETURN DATE(0,0,0);
      END;


      RETURN dt;
   END;

   // ORACLE Любит даты 01.01.0001
   IF ((ValType(val) == V_DATE) AND (type == V_DATE) AND 
       (
        (val == DATE(0,0,0))
        OR
        ((val - 1) == DATE(0,0,0))
       )
      )
      RETURN DATE(0,0,0);
   END;

   IF ((ValType(val) == V_DOUBLE) AND (type == V_INTEGER))
      RETURN int(val);
   END;

   IF ((ValType(val) == V_STRING) AND (CodeFor(val) == 1))
      val = "";
   END;

   IF((ValType(val) != type) OR (ValType(val) == V_UNDEF))
      RETURN Ret0(type);
   END;

   RETURN Val;
END;

const V_GENOBJ_RsdCommand = -1;
// Функция выполнения параметризованных запросов
MACRO CRSDcommand(query: string)

   VAR index = 0, parm1, parm2, FLAG: BOOL = FALSE;
   VAR rs    = NULL, RSDcmd = NULL;

   RSDcmd = NULL;
   RSDcmd = RsdCommand(RslDefCon, query);
   IF (RSDcmd == NULL)
      RETURN FALSE;
   END;

   WHILE (GetParm(index + 1, parm1))
      // Имя поля
      IF (ValType(parm1) == V_STRING)
         IF (ValType(GetParm(index + 2, parm2)) == V_UNDEF)
            RETURN FALSE;
         END;

         RSDcmd.addParam(parm1, RSDBP_IN, parm2);

         index = index + 2;
      ELSE
         rs = RsdRecordset(RSDcmd);
         RSDcmd.execute();

         IF (parm1 == V_GENOBJ)
            RETURN rs;
         END;

         IF (parm1 == V_GENOBJ_RsdCommand)
            RETURN RSDcmd;
         END;         
         
         IF (RS AND RS.MoveNext() AND (ValType(RS.Value(0, FLAG, parm1)) == parm1) AND (FLAG == FALSE))
            RETURN RS.Value(0, NULL, parm1);
         END;

         RETURN SQL_NVL(NULL, parm1);
      END;
   END;

   RETURN FALSE;
END;
