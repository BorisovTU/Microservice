/*------------------------------------------------------------------------------
                      Проверки параметров входящих сервисов         
 Filename    : rsbus_check.mac                                              
 Description : Вспомогательный макрос, содержащий функции проверки значений параметров и поиска

 Programmer  : Melnik Andrey
 03.03.12    : Создан
------------------------------------------------------------------------------*/
import TOTAL;
const SKIP_CREDIT_ID_CHECK = false;          //проверка существования кредитного договора(лучше не отключать)
const SKIP_CURRENCY_CHECK = false;           //проверка корректности заданной валюты
const SKIP_CLIENT_CHECK   = false;           //проверка существования субъекта(зарегистрированного клиента)
const SKIP_BANKID_CHECK   = false;           //проверка существования банка по ID субъекта
const SKIP_DEPARTMENT_CHECK = false;         //проверка существования филиала
const SKIP_ACCOUNT_TYPE_CHECK = false;       //проверка наличия в БД типа счета
const SKIP_CRED_ACCOUNT_TYPE_CHECK = false;  //проверка наличия типа счета по КД
const SKIP_CURCODE_CHECK = false;            //проверка наличия кодов валют ОО в справочнике инструментов
const SKIP_USFIELD_CHECK = false;            //проверка привязки пользовательского поля к объекту системы

var aSynchAcc = TArray();      // массив КУ
aSynchAcc[0] = 1;              // текущий ссудный счет
aSynchAcc[1] = 117;            // рассчетный счет клиента




private const ФИЛИАЛ_АКТИВИРОВАН = 2;
private const ФИЛИАЛ = 1;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//функция возвращает 1й параметр, если он !=NULL, 2й параметр, в случае, если первый = NULL
macro rsbus_NVL(value, defValue)
   if (ValType(value) == V_UNDEF)
      return defValue;
   end;
   return value;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//функция осуществляет проверку существования заданного одним из параметров КД, заполняя при этом, в случае 
//существования КД,  буффер соответстующей записью record(credit_c). В случае, если задан только 2й параметр, 1й заполняется соответсвующим значением
macro FindCrd(creditID:@integer, userCreditNumber:string, buffer)
   if (ValType(creditID) != V_UNDEF)
      if (NOT Loans_FindCrdContract(creditID, buffer))
         RunError("Кредитный договор не зарегистрирован", 18541);
      end;
   else                    
      if ((Valtype(userCreditNumber)!=V_UNDEF) AND (Trim(userCreditNumber)!=""))
        if(Loans_FindUsCrdContract(LO_CREDIT,userCreditNumber, {OperDprt}, buffer ))
           creditID = buffer.creditNumber;
        else
           RunError("Кредитный договор не зарегистрирован", 18541);
        end;

      else
         RunError("Кредитный договор не зарегистрирован", 18541);
      end;
   end;

   if (buffer.typedebtor!=PTLEGF_PERSN)
      RunError("Заемщиком по договору должно быть физическое лицо", 18771);
   end;

    
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//функция осуществляет проверку существования заданного одним из параметров ДО, а также номером КД, заполняя при этом, в случае 
//существования ДО,  буффер соответстующей записью record(enscontr). В случае, если задан только 2й параметр, 1й заполняется соответсвующим значением
macro FindEns(ensID:@integer, ensNumber:string, creditID:integer)
   var query:string, rs:object, one:integer;
   if (ValType(ensID) != V_UNDEF)
      query = "SELECT 1 FROM dtype_ens_dbt e, dens_crd_dbt t, denscontr_dbt d WHERE (d.t_enssystype = e.t_typeensid)AND(e.t_systypeensid_ref IN (3, 4))AND(t.t_CreditNumber_Ref = ?)AND(? = d.t_enscontractid)AND(t.t_EnsContractID_Ref = ?)";
      one = CRSDCommand(query, "", creditID, "", ensID, "", ensID, V_INTEGER);
      if (one != 1)
         RunError("Договор залога не найден", 18602);
      end;
   else                    
      if ((Valtype(ensNumber)!=V_UNDEF) AND (Trim(ensNumber)!=""))
         query = "SELECT t.t_EnsContractID_REF FROM dtype_ens_dbt e, dens_crd_dbt t, denscontr_dbt d WHERE (d.t_enssystype = e.t_typeensid)AND(e.t_systypeensid_ref IN (3, 4))AND(t.t_CreditNumber_Ref = ?)AND(d.t_EnsContractNumber = ?)AND(t.t_EnsContractID_Ref = d.t_enscontractid)";
         one = CRSDCommand(query, "", creditID, "", ensNumber, V_INTEGER);
         if (one)
            ensID = one;        
         else
            RunError("Договор залога не найден", 18602);
         end;
      else
         RunError("Договор залога не задан", 18601);
      end;
   end;
   return true;
   end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка наличия типа счета в igtypacc.dbt
macro AccTypeCheck(accType:integer, buffer)  //в случае нахождения записывает в buffer найденную строку таблицы  
   var igtypacc = TBFile ("igtypacc.dbt", "r", 0);
   igtypacc.rec.TypeAccID = accType;
   if ( NOT igtypacc.getEQ() )       
      return false;
   end;
   buffer = igtypacc.rec;
   return true;
ONERROR(error)
   RunError(error.message, error.code);
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка существования субьекта
macro SubjectCheck(partyid:integer)     //Возвращает обьект RSBParty в случае успеха, NULL - в случае, если обьект с таким ID не найден
   var partyObj = RSBParty(partyid);
   if (partyObj.PartyID>0)
      return partyObj;
   else
      return NULL;
   end;
ONERROR(error)
   return NULL;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка существования филиала
macro DepartmentCheck(depID:integer) //в случае успеха возвращает ID субьекта, иначе - 0
   var query:string, rs:object;
   query = "SELECT t.t_partyid PartyID FROM ddp_dep_dbt t WHERE t.t_code=? AND t.t_status=? AND t.t_nodeType=?";
   rs = CRSDCommand(query, "",depID, "", ФИЛИАЛ_АКТИВИРОВАН, "", ФИЛИАЛ, V_GENOBJ);
   if ( rs AND rs.MoveNext)
      return rs.Value("PartyID");
   end;
   return false;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//поиск кода банка по ID  и  типу кода
macro FindBankCodeByCodeKind( BankID:integer, CodeKind:integer ):string   //возвращает код банка в случае успеха, пустую строку, если код банка не найден
   var query      :string;
   var RSDCmd   :object;
   var BankCode :string = "";

   query = "BEGIN ? := RSI_RSBPARTY.GetPartyCode(?,?); END;";

   RSDCmd = RSDCommand(RslDefCon, query);
   RSDCmd.AddParam("RetVal", RSDBP_RETVAL, V_STRING);
   RSDCmd.AddParam("BankID", RSDBP_IN); RSDCmd.Value("BankID")=BankID;
   RSDCmd.AddParam("CodeKind", RSDBP_IN); RSDCmd.Value("CodeKind")=CodeKind;
   RSDCmd.Execute;

   BankCode = RSDCmd.Value("RetVal");
   return BankCode;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//поиск ID банка по филиалу
macro GetPartyIDByDepart( Department:integer )//возвращает ID субъекта 
   var partyID :integer;
   var query   :string;
   
   query = "SELECT t.t_partyid FROM ddp_dep_dbt t where t.t_code = ?;";
   partyID = CRSDCommand(query, "Department", Department, V_INTEGER);
   return partyid;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка существования типа счета по договору
macro AccountTypeCheck(accType)
   record accTypeRec(taccred);
   if ( (NOT SKIP_CRED_ACCOUNT_TYPE_CHECK) AND (NOT Loans_FindTypeAcCred(accType, accTypeRec)))
      RunError("Не найден тип счета по договору", 18156);
   end;
   return true;
end;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Проверка счета для сервисов изменения КД и открытия счетов
macro CheckLoansAccount(LoansAccount:TArray)
   var error:integer;
   var i:integer, j:integer;
   var AccCateg:integer;

   for(i, 0, LoansAccount.size - 1, 1)
      if(Trim(LoansAccount[i].AccountNumber) == "")
         RunError("Для категории счета №"+ LoansAccount[i].AccCategID +" не передан атрибут !Номер счета!", 18561);
      end;

      for(j, 0, LoansAccount.size - 1, 1)
         if( i != j )
            if(LoansAccount[i].AccCategID == LoansAccount[j].AccCategID )
               RunError("Ошибка! Открывается несколько счетов по категории №"+ LoansAccount[i].AccCategID+" ", 18562);
            end;
         end;
      end;
      
      if((LoansAccount[i].CurCode != "")AND(LoansAccount[i].CurCode != NULL)AND(LoansAccount[i].Curcode != NULLVAL))
           LoansAccount[i].CurCode = ПолучитьКодФинИн (LoansAccount[i].CurCode, error,FICK_ISONUMBER);
         if(error)
            RunError("Валюта задана некорректно"+" ", error);
         end;
      end;
      if((LoansAccount[i].ODBCurCode != "")AND(LoansAccount[i].ODBCurCode != NULL)AND(LoansAccount[i].ODBCurcode != NULLVAL))
         LoansAccount[i].ODBCurCode = getCurISOl(LoansAccount[i].ODBCurCode, error);
         if(error)
            RunError("Неправильно задана валюта для счета категории №"+LoansAccount[i].AccCategID+" ", error);
         end;
      end;
   end;
  
   return true;
end;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка наличия финансового инструмента для кода валюты
macro FinInstrCheck(curCode:string)
   var err:integer, result:integer;
   if (NOT SKIP_CURCODE_CHECK)
      result = ПолучитьКодФинИн(curCode, err,FICK_ISONUMBER);
      if (err)
         RunError("Не найден финансовый инструмент с кодом"+string(curCode), 7984);
      end;
   end;
   return result;
end;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка привязки пользователького поля к обьекту системы "Объект обеспечения"
macro UsFieldCheck(ensID:integer, UsFieldID:integer)
   var found:integer, query:string;
   if (SKIP_USFIELD_CHECK)
      return true;
   end;
   query = "SELECT t.t_usfobjtypeid FROM (SELECT lo.t_objectid FROM  dlobject_dbt lo, densobj_dbt o WHERE O.T_ENSOBJECTID = ? AND lo.t_parentid = 5 AND lo.t_referens = O.T_ENSTYPEID_REF) k, dlufotype_dbt t WHERE (t.t_usfieldid_ref = ?) AND (t.t_objectid_ref = k.t_objectid)";
   found = CRSDCommand(query, "", ensID, "", UsFieldID, V_INTEGER);
   if (NOT found)
      RunError("Пользовательское поле №"+ UsFieldID +" не привязано к объекту обеспечения заданного вида обеспечения", 18646);
   end;
   return found;
end;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//проверка существования ОО, привязанного  к заданному КД
macro EnsObjectCheck(EnsObjectID:@integer, EnsObjectName, EnsContractID)  //в случае, если данные по объекту обеспечения не найдены, возвращает false. Если все гуд - возвращает true:)
   record ensObj(ensobj);
   var query:string, found;
   if (ValType(EnsObjectID) != V_UNDEF)
      query = "SELECT t.t_ensobjectid FROM densobj_dbt t, decn_eob_dbt d WHERE t.t_ensobjectid = ? AND t.t_ensobjectid = d.t_ensobjectid_ref AND d.t_enscontractid_ref = ?";
      found = CRSDCommand(query, "", EnsObjectID, "", EnsContractID, V_INTEGER);
      if (NOT found)   
         return false;
      end;
   elif (ValType(EnsObjectName) != V_UNDEF)
      query = "SELECT t.t_ensobjectid FROM densobj_dbt t, decn_eob_dbt d WHERE t.t_ensobjectname = ? AND t.t_ensobjectid = d.t_ensobjectid_ref AND d.t_enscontractid_ref = ?";
      if (((ValType( EnsObjectID = CRSDCommand(query, "objname", EnsObjectName, "", EnsContractID, V_INTEGER) )) == V_UNDEF) OR (EnsObjectID == 0))
         return false;
      end;
   else
      RunError("Объект обеспечения не задан", 18642);
   end;
   return true;
end;



