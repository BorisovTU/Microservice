/*
$Name:        CaseLimitCalcRep.mac
$Module:      Кредитование
$Description: CaseLimitCalcRep.mac
*/

import RSD, TOTAL, PTInter;
   
// Вид ограничения
private const 
 EN_CASE   = 1, //Портфель
 EN_DUTY   = 2, //Обязательство/Требование
 EN_CLIENT = 3; //Все обязательства/требования заемщика

//Способ задания ограничения Абс.знач, %от К, Не задан
private const    
 EN_ABS   = 1,
 EN_PERC  = 2,
 EN_EMPTY = 3;

// Тип ограничения
private const 
 USER_LIMIT = 1, //пользовательский вид ограничения
 NORM_LIMIT = 2; //нормативный вид ограничения 

private const NATCUR = 0;

class TOutCaseLimitValues
   var
   sum:money,
   cur:integer;
end;

class TClientData
   var
   clientid:integer,
   sum:money;
end;


private var CapitalSize:money = $0;
private var RepDate:date = {curdate};

// исходящие данные отчета
var 
   M1:integer = 0,
   S1:string = "",
   S2:string = "",
   S3:string = "",
   S4:string = "";

//----------------------------------------------------------------------------------------------
MACRO GetCurrentCaseSize (caseid :integer, regid:integer)
   var cmd;

   if (regid == NULL)
      regid = 0;
   end;

   cmd = RsdCommand(RslDefCon, "begin ? := NVL(LoansKernel.getCaseSum(?, ?, ?, ?), 0); end;");
   cmd.addParam("retval", RSDBP_RETVAL, V_MONEY);
   cmd.addParam("caseid", RSDBP_IN);  cmd.value("caseid") = caseid;
   cmd.addParam("opdate", RSDBP_IN);  cmd.value("opdate") = RepDate;
   cmd.addParam("regid",  RSDBP_IN);  cmd.value("regid")  = regid;  // regid = 0 - по всем регистрам
   cmd.addParam("dutcnt", RSDBP_OUT, V_INTEGER);

   cmd.execute();
   return cmd.value ("retval");
END;

//--------------------------------------GetCapitalSize--------------------------------------
MACRO GetCapitalSize
   var party, ptnote;
   var partyid = {OurBank};
      party  = RsbParty(partyid);
      ptnote = party.PartyNote(); // экземпляр класса partynote
   if (ptnote.Readnote(19, RepDate) == NULL)
		return 0;
	else
   return ptnote.Readnote(19, RepDate);
   end;
END;

//--------------------------------------GetCurrencyRate----------------------------------------
MACRO GetCurrencyRate (fiid:integer, otherfi:integer)
   var cmd;
      cmd = RsdCommand(RslDefCon, "begin ? := loanskernel.getcurrencyrate(?, ?, ?); end;");
      cmd.addParam("recalcsum", RSDBP_RETVAL, V_MONEY);
      cmd.addParam("date",    RSDBP_IN);  cmd.value("date")    = RepDate;
      cmd.addParam("fiid",    RSDBP_IN);  cmd.value("fiid")    = fiid;
      cmd.addParam("otherfi", RSDBP_IN);  cmd.value("otherfi") = otherfi;
   cmd.execute();
   return cmd.value ("recalcsum");
END;

//--------------------------------------GetSumCredit-------------------------------------------
MACRO GetSumCredit (crdkind:integer, crdnum:integer, curcode:integer)
   var cmd;
      cmd = RsdCommand(RslDefCon, "begin ? := loansuserfunction.getsumcredit(?, ?, ?, ?, ?); end;");
      cmd.addParam("crdsum",  RSDBP_RETVAL, V_MONEY);
      cmd.addParam("crdkind", RSDBP_IN); cmd.value("crdkind") = crdkind;
      cmd.addParam("crdnum",  RSDBP_IN); cmd.value("crdnum")  = crdnum;
      cmd.addParam("curcode", RSDBP_IN); cmd.value("curcode") = curcode;
      cmd.addParam("natcur",  RSDBP_IN); cmd.value("natcur")  = NATCUR;
      cmd.addParam("date",    RSDBP_IN); cmd.value("date")    = RepDate;
      cmd.execute();
   return cmd.value("crdsum");
END;

//-------------------------------------GetCaseLimitValue--------------------------------------
// Алгоритм расчета ограничений портфеля
// limittype = ФАКТ ИЛИ НОРМАТИВ
// dragkind  = ПОРТФЕЛЬ, ОБЯЗАТЕЛЬСТВО, ВСЕ ОБЯЗАТЕЛЬСТВА
//--------------------------------------------------------------------------------------------
MACRO GetCaseLimitValues (caseid:integer, dragkind:integer, limittype:integer, calcdate:integer,OutValues:@TOutCaseLimitValues)
   var lcparm:object;
   //var OutValues :TOutCaseLimitValues;
   var limitsum:money = $0, limitcur:integer = 0;
   var Rate:integer = 0;
   //выборка параметров портфеля
   lcparm = CRsdCommand("SELECT * FROM DBRFCPARM_DBT "+
                        "WHERE T_BRIEFCASEID_REF = ? "+
                          "AND T_DRAGKIND = ?",
                        "", caseid,
                        "", dragkind,
                        V_GENOBJ
                       );
   if(not lcparm.MoveNext)
      return 0;
   end;

   //в зависимости от вида ограничения: пользовательское или нормативное, - извлекаются соответствующие значения
   if (limittype == USER_LIMIT)
      limitcur = lcparm.value("t_curcode");

      if (lcparm.Value("t_assignmentmethod") == EN_PERC)  //способ задания
         CapitalSize = GetCapitalSize(); 
         limitsum = CapitalSize * lcparm.value("t_perc") / 100;

         if (limitcur != NATCUR)
            Rate = GetCurrencyRate(limitcur, NATCUR);
            if (Rate > 0)
               limitsum = limitsum / Rate;
               Rate = 0;
            end;
         end;
      elif (lcparm.Value("t_assignmentmethod") == EN_ABS)
         limitsum = lcparm.value("t_value");       
      else
         return 0; 	  
      end;

   elif (limittype == NORM_LIMIT)
      limitcur = lcparm.value("t_curcodenorm");
            
       if (lcparm.Value("t_assignmentmethodnorm") == EN_PERC)  //способ задания
         CapitalSize = GetCapitalSize(); 
         limitsum = CapitalSize * lcparm.value("t_perc") / 100;

         if (limitcur != NATCUR)
            Rate = GetCurrencyRate(limitcur, NATCUR);
            if (Rate > 0)
               limitsum = limitsum / Rate;
            end;
         end;
      elif (lcparm.Value("t_assignmentmethodnorm") == EN_ABS)
         limitsum = lcparm.value("t_valuenorm");         
      else
         return 0;          
      end;
   else
      println("Не верно задан тип ограничения (Пользоватеслький:Нормативный)");
      return 0;
   end;

   OutValues.sum = money(round(limitsum));
   OutValues.cur = limitcur;
   return 1;//OutValues;
END;

//-----------------------------------------------------------------------------------------------
MACRO CaseLimitCalcReport
   var lctable :object, crdtable:object, crdduties:object;
   var CaseLimitValues:TOutCaseLimitValues;  // состоит из значений суммы и валюты ограничения

   if(not GetDate(RepDate, "Отчет на дату:", 5))
     exit(1);
   end;

   // выборка портфелей на дату отчета
   var sql_str =
   " SELECT *"+
       " FROM (SELECT * /*выбираем отрытые портфели*/"+
               " FROM DLBRFCASE_DBT BFC "+
              " WHERE     BFC.T_BEGINDATE <= :RepDate"+
                    " AND BFC.T_REFERENCEID = 0"+
                    " AND BFC.T_BRIEFCASESTATE = 'О' "+
                    " AND (NOT EXISTS"+
                                " (SELECT 1"+
                                   " FROM dcrd_op_dbt crdop "+
                                  " WHERE     crdop.T_ISDELETED = 0"+
                                        " AND crdop.T_STAGEID_REF = 99"+
                                        " AND crdop.t_correctoperation = 0"+
                                        " AND crdop.t_operationtype != 'И'"+
                                        " AND crdop.t_operationtype != 'C'"+
                                        " AND crdop.t_credoperdate <= :RepDate"+
                                        " AND crdop.t_objecttypeid_ref = 17 /*портфель*/"+
                                        " AND crdop.t_opertypenumber_ref = 167 /*закрытие портфеля*/"+
                                        " AND bfc.t_briefcaseid = crdop.t_objectid_ref))"+
             " UNION ALL"+
             " SELECT * /*выбираем закрытые портфели*/"+
               " FROM DLBRFCASE_DBT BFC"+
              " WHERE     BFC.T_BEGINDATE <= :RepDate"+
                    " AND BFC.T_REFERENCEID = 0"+
                    " AND BFC.T_BRIEFCASESTATE = 'З'"+
                    " AND (EXISTS"+
                            " (SELECT 1"+
                               " FROM dcrd_op_dbt crdop"+             
                              " WHERE     bfc.t_briefcaseid = crdop.t_objectid_ref"+
                                    " AND crdop.t_objecttypeid_ref = 17 /*портфель*/"+
                                    " AND crdop.t_isdeleted = 0"+
                                    " AND crdop.t_opertypenumber_ref = 167 /*закрытие портфеля*/"+
                                    " AND crdop.t_credoperdate >= :RepDate)))"+
   " ORDER BY T_TYPE DESC, T_BEGINDATE, T_USERNUMBER";
lctable = CRsdCommand(sql_str,"RepDate", RepDate,V_GENOBJ);

					  
   println;
   println;
   println("                                       Нарушение ограничений в портфелях на ", RepDate);
   println;
   [╓──────────┬───────────────────────────┬───────────────────────────┬──────────────────┬─────────────────────────────────────╖];
   [║   Вид    │         Название          │                 Вид       │    Превышение    │ Номер договора                      ║];
   [║ портфеля │         портфеля          │             ограничения   │ ограничения, руб │ или ФИО заемщ.                      ║];
   [╟──────────┼───────────────────────────┼───────────────────────────┼──────────────────┼─────────────────────────────────────╢];
   
             
   while (lctable.MoveNext)
      var limitnum:integer, deltalimit:money;
      var caseid = lctable.value("t_briefcaseid");
      var CurrentCaseSize:money = $0;          //текущий (фактический) размер ПФ
      var M1_Case:money = -1;//$0;
      var M1_Duty:money = $0;
      var M1_Client:money = $0;
      var Rate:integer = 0;
      var sql;

      //CurrentCaseSize = GetCurrentCaseSize(caseid, 1);                   // два вызова GetCurrentCaseSize необходимы, что бы получит размер портфеля в рублях. 
      //CurrentCaseSize = CurrentCaseSize + GetCurrentCaseSize(caseid, 2); //т.к., если один вызов,- с regid = 0, то суммируются рублевые, и ин.валютные суммы и на выходе получаем не рублевый размер портфеля
      if (lctable.value("t_type") == 0) 
         S1 = "ПОУО";
      else 
         S1 = "ПОC";       
      end;
      S2 = lctable.value("t_briefcasename");

      FOR (limitnum, 1, 3)
         // рассчитываем каждый раз сумму ограничения для соотв. типа ограничения значению которого соотв. limitnum
         if (GetCaseLimitValues (caseid, limitnum, USER_LIMIT, RepDate,@CaseLimitValues)==1)

             if ((CaseLimitValues.cur != -1) and (CaseLimitValues.cur != NATCUR))
                Rate = GetCurrencyRate(CaseLimitValues.cur, NATCUR);
                if (Rate > 0)
                   CaseLimitValues.sum = money(round(CaseLimitValues.sum / Rate)); // корректировка суммы ограничения
                end;
             end;
         
             IF (limitnum == EN_CASE)   // EN_CASE  ограничение Портфель
					M1_Case = /*CurrentCaseSize - */CaseLimitValues.sum;  //M1 = max(0, Pогр - Pфакт).
					/*
	        if (M1_Case > 0) // если размер ограничения меньше факта то превышения есть
                     S3 = "Портфель"; S4 = "";
                     // строка отчета для EN_CASE
                     [║   ####   │ ######################### │ ######################### │##################│ ################################### ║] (S1:c, S2:c, S3:c, M1_Case:r, S4);
                 end;
					*/
   
             ELIF (limitnum == EN_DUTY)     // EN_DUTY  Обязательство/Требование
                M1_Duty = CaseLimitValues.sum;

             ELIF (limitnum == EN_CLIENT)   // EN_CLIENT Все обязательства/требования заемщика
                // выборка КД привязаных к ПФ
                // сформированы два множества операций с КД по ПФ. 1е-все операции формирования ПФ, 2е-все операции расформирования ПФ
                // и объедененны таким образом, что остаются только те операции формирования ID которых больше ID операций расформирования
                // то есть, остаются те КД которые не были отвязаны(расформированы) от ПФ
                 sql = "SELECT * FROM DCREDIT_C_DBT C "+
                          "WHERE t_creditnumber IN "+
                            "(SELECT sys36.t_creditnumber "+
                              " FROM "+
                               "(SELECT bf_crd.t_objectnumber t_creditnumber, "+  
                                        "MAX (crdop.t_credoperid) credoperid "+
                                  "FROM  dlbfrccrd_dbt bf_crd "+
                                        "INNER JOIN "+
                                           "dcrd_op_dbt crdop "+
                                        "ON bf_crd.t_credoperid_ref = "+
                                                 "crdop.t_credoperid "+
                                  "WHERE  bf_crd.t_briefcaseid_ref = ? "+
                                        "AND crdop.t_isdeleted = 0 "+
                                        "AND crdop.t_stageid_ref = 99 "+ 
                                        "AND crdop.t_systemoperationid = 36 "+
                                        "AND crdop.t_credoperdate <= ? "+
                                                 "GROUP BY bf_crd.t_objectnumber, "+
                                                          "bf_crd.t_objecttypeid "+
                            ") sys36 "+
                         "LEFT JOIN "+  
                            "(SELECT bf_crd.t_objectnumber t_creditnumber, "+
                                     "MAX (crdop.t_credoperid) credoperid  "+
                               "FROM dlbfrccrd_dbt bf_crd "+
                                     "INNER JOIN "+
                                        "dcrd_op_dbt crdop "+
                                     "ON bf_crd.t_credoperid_ref = "+
                                          "crdop.t_credoperid "+
                               "WHERE  bf_crd.t_briefcaseid_ref = ? "+
                                     "AND crdop.t_isdeleted = 0 "+
                                     "AND crdop.t_stageid_ref = 99 "+
                                     "AND crdop.t_systemoperationid = 37 "+
                                     "AND crdop.t_credoperdate <= ? "+
                                              "GROUP BY bf_crd.t_objectnumber, "+
                                                       "bf_crd.t_objecttypeid "+
                            ") sys37 "+
                            "ON sys36.t_creditnumber = sys37.t_creditnumber "+
                               "WHERE (sys36.credoperid > sys37.credoperid OR sys37.t_creditnumber IS  NULL)) ORDER BY c.t_clientid_ref";

                crdtable = CRsdCommand(sql, "",caseid, "",RepDate, "",caseid, "",RepDate, V_GENOBJ); 
 
                var isExistsCrdInCase:bool = false;
                var MaxAllDutySumClientArray = TArray();
                while (crdtable.MoveNext)
                   var CrdSum:money = $0;
                   var CrdID:integer = crdtable.value("t_creditnumber");

                   isExistsCrdInCase = true;

                   CrdSum = GetSumCredit(crdtable.value("t_crd_kind"), CrdID, crdtable.value("t_curcode")); 
					   
                   CurrentCaseSize = CrdSum + CurrentCaseSize;
					   
                   deltalimit = CrdSum - M1_Duty; //M1 = max(0, ОТогр - SДог)
    
                   // строка отчета для EN_DUTY
                   if (deltalimit > 0)
                        S4 = crdtable.value("t_uscreditnumber");
                        S3 = "Об/тр."; 
                        [║   ####   │ ######################### │ ######################### │##################│ ################################### ║] (S1:c, S2:c, S3:c, deltalimit:r, S4);
                   end;
               
                   // ведем подсчет сумм всех обязательств заемщика в рублях(поскольку CrdSum - в рублях) 
                   var ClientData:TClientData;
                   var сurrclient = 0;
                   var curcode    = 0;
                   var clientid   = 0;
      
                   clientid = crdtable.value("t_clientid_ref");
                   curcode  = crdtable.value("t_curcode");

                   // сумму всех кд заемщика можно было бы получить из запросов с использованием агрегатных функций и группировок. Но, при этом нужно еще получить и номер кд и клиента и другие данные из запроса.
                   // и эти данные кроме суммы, не попадают под параметры группировки, и необходимо много "телодвижений" с запросами, что бы вытянуть все необходимые данные.
                   // по этому используем  массивы. По сгрупированному запросу вытягиваем нужные данные и заганяем в массив.

                   if (MaxAllDutySumClientArray.Size == 0)
                      ClientData.sum      = CrdSum;
                      ClientData.clientid = clientid;
                      MaxAllDutySumClientArray[0] = ClientData;
                      ClientData = NULL;
    
                   elif (MaxAllDutySumClientArray.Size > 0)
                      var lastindx = MaxAllDutySumClientArray.Size-1;
                     
                      // по одному и тому же клиенту значения суммируются в том же елементе массива, а для следующего(отличного от текущего) клиента создается новый элемент массива.
                      if (clientid == MaxAllDutySumClientArray[lastindx].clientid)
                         MaxAllDutySumClientArray[lastindx].sum = MaxAllDutySumClientArray[lastindx].sum + CrdSum;
                      else
                         ClientData.sum      = CrdSum;
                         ClientData.clientid = clientid;
                         MaxAllDutySumClientArray[lastindx+1] = ClientData;
                         ClientData = NULL;
                      end;
                   end;
                end; // end while

                if (isExistsCrdInCase)
                   // строка отчета для EN_CLIENT
                   if (MaxAllDutySumClientArray.Size > 0)
                      var index = 0;
                      while (index < MaxAllDutySumClientArray.Size)
                         M1_Client = MaxAllDutySumClientArray[index].sum - CaseLimitValues.sum;    // M1 = max(0, ОТКогр - SЗаемщ)
      
                         if (M1_Client > 0)
                             S3 = "Все об/тр. заемщ.";
                             S4 = LnSelectValue("select t_name from dparty_dbt where t_partyid = "+ MaxAllDutySumClientArray[index].clientid, V_STRING); 
                            [║   ####   │ ######################### │ ######################### │##################│ ################################### ║] (S1:c, S2:c, S3:c, M1_Client:r, S4);
		         end;
                         index = index + 1;
                      end; // end while
                  end;
                  isExistsCrdInCase = false;
                  end;
                 IF (M1_Case != -1)   // если ограничение есть
                      M1_Case = CurrentCaseSize - M1_Case;  //M1 = max(0, Pогр - Pфакт).
			
                      if (M1_Case > 0) // если размер ограничения меньше факта то превышения есть
                          S3 = "Портфель"; S4 = "";
                          // строка отчета для EN_CASE
                          [║   ####   │ ######################### │ ######################### │##################│ ################################### ║] (S1:c, S2:c, S3:c, M1_Case:r, S4);
                      end;			
                end;			
             END;
         END;		
      END; // end for
   end;
  [╚══════════╧═══════════════════════════╧═══════════════════════════╧══════════════════╧═════════════════════════════════════╝];  
END;

CaseLimitCalcReport;