/*
$Name:             total.mac                                              
$Module:           Кредитование
$Description:      Макрос общих функций для Кредитного бухгалтера
*/
/*------------------------------------------------------------------------------
                     Библиотека интерпретируемых модулей

 Filename    : total.mac                                              22.12.98
 Description : Макрос общих функций для Кредитного бухгалтера

 Programmer  : ROV
 22.12.98    : Создан
------------------------------------------------------------------------------
*/

Import SbCrdInter, BankInter, FIInter, CTInter, PTInter, LoansFind, "lclient.mac", rsd, "globals.mac", Календарь, LoansGUI, ora_func;

VAR DepClnt = TLoansClient;      /* клиенты                                 */

FILE TypeCrd      ("type_crd.dbt", "loans.def");       /* виды кредитов                           */
FILE EnsFieldVal  ("ensfval.dbt",  "loans.def");       /* значение доп. поля                      */
FILE ИсторияРиска ("crdrghb.dbt",  "loans.def");       /* история групп риска                     */
FILE Счета        ("acc_crd.dbt",  "loans.def") key 1; /* счета по договору                       */
FILE EnsCont      ("enscontr.dbt", "loans.def") key 3; /* договора обеспечений                    */
FILE EnsObj       ("ensobj.dbt",   "loans.def") key 1;
FILE TypeOp       ("type_op.dbt",  "loans.def") key 1;
FILE HDCLNT       ("h_dclnt.dbt",  "loans.def");
FILE EnsType      ("enstype.dbt",  "loans.def");
FILE Duty         ("duty_crd.dbt", "loans.def");

/* файлы для поиска курса валюты */
FILE ExchCurr ("curr.dbt", "exchange.def");
/* банковские файлы */
VAR cd, cr;

PRIVATE VAR ЮрЛицо;

PRIVATE VAR {RSL_TOOLS_VERSION};

PRIVATE FILE lufield    ("lufield.dbt",  "loans.def");
PRIVATE FILE lufvalue   ("lufvalue.dbt", "loans.def");
PRIVATE FILE lufotype   ("lufotype.dbt", "loans.def") key 1;
PRIVATE FILE lufvalue_w ("lufvalue.dbt", "loans.def") write key 0;
PRIVATE FILE lufotype_w ("lufotype.dbt", "loans.def") write;
PRIVATE FILE passport   ("namealg.dbt",  "bank.def"); /* Справочник удостоверений личности*/
PRIVATE FILE Договор    ("credit_c.dbt", "loans.def");
PRIVATE FILE AcCrd      ("acc_crd.dbt",  "loans.def") key 1;
PRIVATE FILE crd_op     ("crd_op.dbt",   "loans.def") key 0;
PRIVATE FILE   CrdOp    ("crd_op.dbt",   "loans.def") key 2;
PRIVATE RECORD ExpOp    ("EXPOP.",       "loans.def");
PRIVATE FILE CopStage ("copstage.dbt", "loans.def") key 1;

PRIVATE VAR ErrCode, МинимальнаяПенсияД/*:doubleL = 0.0*/;
PRIVATE VAR objatcor:object = NULL, objattr:object = NULL;

VAR Duty_SQL = TBFile ("duty_crd.dbt", "r", 0, "duty_crd.dbt", "loans.def");
PRIVATE VAR perc_day = TBFile ("perc_day.dbt", "r", 1, "perc_day.dbt", "loans.def");
PRIVATE VAR paym     = TBFile ("pmpaym.dbt",   "r", 0, "pmpaym.dbt",   "bank.def");
PRIVATE VAR Graph    = TBFile ("planpay.dbt", "r", 0);
PRIVATE VAR ens_crd  = TBFile ("ens_crd.dbt", "r", 0);
PRIVATE VAR econtr   = TBFile ("enscontr.dbt", "r", 0);
private var mcper    = TBFile ("mcperiod.dbt", "r", 3);
private var mcperi   = TBFile ("mcperiod.dbt", "r", 0);

VAR Ecneob   = TBFile ("ecn_eob.dbt",  "r", 0);

private CONST TMCPERIOD_DAY   = 1,
              TMCPERIOD_MONTH = 2,
              TMCPERIOD_YEAR  = 3;

CONST
      АдресМестаРаботы                              =  8,
      ВаловыйДоходПоОМР                             =  9,
      УдержаниеИзOД_ПодоходныйНалог                 = 10,
      УдержаниеИзOД_ВзносыВПФ                       = 11,
      УдержаниеИзOД_СтраховыеВзносы                 = 12,
      УдержаниеИзOД_Прочие                          = 13,
      ВаловыйДоходПоДМР                             = 14,
      УдержаниеИзДД_ПодоходныйНалог                 = 15,
      УдержаниеИзДД_ВзносыВПФ                       = 16,
      УдержаниеИзДД_СтраховыеВзносы                 = 17,
      УдержаниеИзДД_Прочие                          = 18,
      ВаловыйДоходСозаемщика                        = 19,
      УдержаниеИзДС_ПодоходныйНалог                 = 20,
      УдержаниеИзДС_ВзносыВПФ                       = 21,
      УдержаниеИзДС_СтраховыеВзносы                 = 22,
      УдержаниеИзДС_Прочие                          = 23,
      ОбязательстваПоПредоставленнымПоручительствам = 24,
      ОбязательстваПоПолученнымРанееКредитам        = 25,
      ВаловыйДоход12месПоОМР                        = 26,
      Удержания12месИзОД_ПодоходныйНалог            = 27,
      Удержания12месИзОД_ВзносыВПФ                  = 28,
      Удержания12месИзОД_СтраховыеВзносы            = 29,
      Удержания12месИзОД_Прочие                     = 30,
      ВаловыйСреднемесячныйДоходЗаФОВ               = 31, // ФОВ - фактически отработанное время
      УдержанияЗаФОВ_ПодоходныйНалог                = 32,
      УдержанияЗаФОВ_ВзносыВПФ                      = 33,
      УдержанияЗаФОВ_СтраховыеВзносы                = 34,
      УдержанияЗаФОВ_Прочие                         = 35,
      СемейноеПоложение                             = 36,
      Стаж                                          = 37,
      ДоходыСемьиЧистые                             = 38,
      Образование                                   = 39,
      СтатусСозаемщика                              = 40,
      МестоРаботыСозаемщика                         = 41,
      ДолжностьСозаемщика                           = 42,
      ДолговыеОбязательстваПрочие                   = 43,
      ЕжемесячныеРасходы                            = 51,
      ЖилищныеРасходы                               = 52,
      КоличествоРаботающих                          = 53,
      ВсегоИждевенцев                               = 54,
      КоличествоДетейДо18лет                        = 55,
      СтатусИмеющегосяЖилья                         = 56,
      СтатусМестаРаботы                             = 57,
      ЗаработнаяПлата                               = 58,
      ЕжемесячныйДоходОтПодсобногоХозяйства         = 59,
      ДругиеЕжемесячныеДоходы                       = 60,
      ПризнакИнсайдера                              = 61,
      Пол                                           = 62,
      Пенсия                                        = 63,
      ПредметИпотеки                                = 67,
      ДатаПриемаНаРаботу                            = 68,
      НерегулярностьВыплатыЗарплаты                 = 69,
      РазовыеВыплаты                                = 70,
      Доход12месПоОМР                               = 71,
      ТарифЗаОбслуживание                           = 71,
      Удержания12месИзОД                            = 72,
      НаселенныйПункт                               = 72,
      ФИОКредитора                                  = 73,
      ДолжностьКредитора                            = 74,
      ОснованиеКредитора                            = 75,

      /* Пенсионный возраст */
      ПенсионныйВозрастМ       = 60,
      ПенсионныйВозрастЖ       = 55;

class CErrManager ()
   private var errCode:integer = 0;
   private var errMess:string = "";
   
   macro GetErrCode()
      return errCode;
   end;

   macro GetErrMess()
      return errMess;
   end;

   macro SetErrCode(errCode_:integer)
      errCode = errCode_;
   end;

   macro SetErrMess(errMess_:string)
      errMess = errMess_;
   end;

   macro SetError(errCode_:integer, errMess_:string)
      errCode = errCode_;
      errMess = errMess_;
   end;

   macro RunErr()
      RunError(errMess, errCode);
   end;

end;

MACRO pow10 (val1);
   RETURN Pow (10, val1);
END;

MACRO Floorl (sum)
  RETURN Money(sum);
END;

/* Определить текущий статус операции */
MACRO GetCopStage (CredOperID)
    VAR    crd_op = TBFile ("crd_op.dbt", "r", 0, "crd_op.dbt", "loans.def");
    crd_op.rec.CredOperID = CredOperID;
    IF (crd_op.getEQ())
        RETURN crd_op.rec.StageID_Ref;
    END;
    RETURN 0;
END;

/*Проверка, что обязательство принадлежит истории обязательства*/
MACRO CheckDutyID_Hist(DutyID:integer, DutyID_Op:integer)
    RECORD d("duty_crd.dbt", "loans.def");

    WHILE(Loans_FindDuty(DutyID, d))
        IF (d.DutyID == DutyID_Op)
            RETURN TRUE;
        END;

        IF (Loans_FindParentDuty(d.DutyID, d))
            DutyID = d.DutyID;
        ELSE
            RETURN FALSE;
        END;
    END;

    RETURN FALSE;
END;

/*
Получение ставки тарифа по объекту
   ObjID    - ID вида объекта
   ObjN     - ID экземпляра объекта
   TrffType - вид ставки тарифа
   CalcDate - дата, на которую нужно получить ставку
*/
macro ПолучитьСтавкуТарифа (ObjID, ObjN, TrffType, CalcDate)
   var TrffRate :numeric = 0.0;
   var cmd = null;

   cmd = RsdCommand (RslDefCon, "BEGIN ? := RSI_Loans_TrffAlg.GetTrffRate(?, ?, ?, ?); END;");

   cmd.addParam ("TrffRate", RSDBP_RETVAL, V_NUMERIC);
   cmd.addParam ("ObjID",    RSDBP_IN); cmd.value ("ObjID")    = ObjID;
   cmd.addParam ("ObjN",     RSDBP_IN); cmd.value ("ObjN")     = ObjN;
   cmd.addParam ("TrffType", RSDBP_IN); cmd.value ("TrffType") = TrffType;
   cmd.addParam ("CalcDate", RSDBP_IN); cmd.value ("CalcDate") = CalcDate;

   cmd.execute();
   TrffRate = cmd.value ("TrffRate");
   return TrffRate;
end;

/*
Процентная ставка по объекту
   ObjectTypeID - ID вида объекта
   ObjectNumber - ID экземпляра объекта
   RateTypeID   - вид ставки
   Дата         - дата, на которую нужно получить ставку
*/
macro ПроцСтавка (ObjectTypeID, ObjectNumber, RateTypeID, Дата)
   return Loans_FindRateVal (ObjectTypeID, ObjectNumber, RateTypeID, Дата); 
      end;

/*
   процентная ставка по договору
   Тип  - Тип группы риска (РВПС / РВП)
   Flag - Если не определен или 0, возвращаем группу риска
          Если 1 - Процентную ставку
          Если 2 - Процент резерва по оффшорам
*/
MACRO ГруппаРиска (ВидОбъекта, НомерОбъекта, Тип, Дата, Flag)
  VAR rs_0: string = "",
      rs_1: string = "",
      rs_2: string = "",
      rs = NULL;

    rs_0 = string("(t_ObjectNumber = " + НомерОбъекта + ")" +
                  " AND (t_ObjectTypeID = " + ВидОбъекта + ")" +
                  " AND (t_Type = "+ Тип + ")"
                 );
    rs_1 = string("(SELECT max(t_Date) FROM dcrdrghb_dbt WHERE " + rs_0 + " AND (t_Date <= " + SQLDate(Дата) +"))");
    IF ((Flag == 0) OR (ValType(Flag) == V_UNDEF))
       rs_2 = string("SELECT t_iRiskGroup FROM dcrdrghb_dbt WHERE " + rs_0 + " AND (t_Date = "+rs_1+")");
    ELIF (Flag == REZ_RVPS)
       rs_2 = string("SELECT t_PercentReserve FROM dcrdrghb_dbt WHERE " + rs_0 + " AND (t_Date = "+rs_1+")");
    ELIF (Flag == REZ_RVP)
       rs_2 = string("SELECT t_PercentReserveO FROM dcrdrghb_dbt WHERE " + rs_0 + " AND (t_Date = "+rs_1+")");
    END;
    rs = LnGetRecordset(rs_2);
    IF (rs == NULL)  RETURN 0;          END;
    IF (rs.MoveNext) RETURN rs.value(0) END;
    RETURN 0;
END;

/* курс ЦБ из банка */
MACRO GetOfRate (Cur, dat)

  RETURN 1.0; // Из 5.0 курсы больше не берем
END;


/* курс валюты */
MACRO GetRate (Dd, CurCode)
  IF (CurCode == NATCUR)
     RETURN 1.0;
  END;

  RETURN double (GetMarkRate (CurCode, Dd));
END;

/* Выдача сообщения об ошибке при открытии файла */
MACRO OpenErrMes( fileName )
   println( "Ошибка при открытии файла ", fileName );
END;

/* Короткое название валюты */
MACRO FindShortName (Curr)
    VAR fi = TRecHandler("fininstr.dbt", "bank.def");
    IF ( ПолучитьФинИн(Curr, fi) == 0 )
        RETURN fi.rec.Ccy;
    ELSE
        RETURN "";
  END;
END;

/* Полное название валюты */
MACRO FindFullName (Curr)
    VAR fi = TRecHandler("fininstr.dbt", "bank.def");
    IF ( ПолучитьФинИн(Curr, fi) == 0 )
        RETURN fi.rec.Name;
    ELSE
        RETURN "";
  END;
END;

/* Внешний код валюты */
MACRO FindExtCode (Curr)
    VAR fi = TRecHandler("fininstr.dbt", "bank.def");
    IF ( ПолучитьФинИн(Curr, fi) == 0 )
        RETURN fi.rec.FI_Code;
    ELSE
        RETURN "";
  END;
END;

/* Нахождение ставки рефинансирования*/
MACRO СтавкаРефинансирования (Валюта, Дата);
  VAR rs = NULL;
  rs = LnGetRecordSet(" SELECT t_rate FROM dcbrfrate_dbt" +
                      " WHERE t_effectivedate <= " + SQLDate(Дата) +
                      " AND t_fiid = " + Валюта +
                      " order by  t_effectivedate desc");

  IF (rs == NULL)  RETURN 0;          END;
  IF (rs.MoveNext()) RETURN rs.value(0) END;
  RETURN 0;
END;

// значение ставки НДС с видом "Основная" на дату 
// из справочника ставок НДС ГК
macro GetMainNDS (
   OpDate : date
)
   var RSDcmd = null;
   var RetRate : numeric = 0.0;

   RSDcmd = RsdCommand (RslDefCon, "BEGIN ? := LoansKernel.bb_get_main_nds (?); END;");

   RSDcmd.addParam ("RetRate", RSDBP_RETVAL, V_NUMERIC);
   RSDcmd.addParam ("OpDate", RSDBP_IN); RSDcmd.value ("OpDate") = OpDate;

   RSDcmd.execute ();
   RetRate = RSDcmd.value ("RetRate");

   return RetRate;
end;

/* Название вида кредита */
MACRO FindTypeCrd (TypeID)
  TypeCrd.CreditTypeID = TypeID;
  IF ( getEQ(TypeCrd) )  RETURN TypeCrd.CreditTypeName;
  ELSE RETURN "";
  END;
END;

/* Полное имя клиента (инициалы имени и отчества) */
MACRO FindClient (Client, Kind)
   IF (DepClnt.GetRecord(Client))
      IF (Depclnt.LegalForm == 2)
         RETURN DepClnt.ConvertFIO();
      ELSE
         RETURN DepClnt.ShortName;
      END;
   ELSE
      RETURN "";
   END;
END;

/* Полное имя клиента */
MACRO FindFullClient (Client, Kind)
   IF (DepClnt.GetRecord(Client))
      IF (Depclnt.LegalForm == 2)
         RETURN DepClnt.ConvertFIOFull();
      ELSE
         RETURN DepClnt.Name;
      END;
   ELSE
     RETURN "";
   END;
END;

/* Ввод даты отчета, в Date передается текущая дата */
MACRO ВвестиДатуОтчета (CDate)
  VAR RepDate;
  RepDate = CDate;
  IF ( NOT getdate( RepDate, "Введите дату отчета: ") )
    RETURN date (0,0,0);
  END;
  IF ( RepDate > CDate )
    msgbox("Дата превышает текущую" );
    RETURN date (0,0,0);
  ELSE
    RETURN RepDate;
  END;
END;

MACRO GetOperation(ObjectType, ObjectNumber, crd_op:@TBFile, SystType, FromBegin, CurCode, stageOp, CredOperID:@integer, CURR_OBJ_ONLY:bool);
   VAR  rs = NULL, NextOpStr:string = "", FrstDutyID_Ref = 0, cmdStr = "", MinMaxStr:string = "", ObjSrchStr = "", ObjectStr = "";

   IF (stageOp == NULL)
      stageOp = CF_COMPLIT;
   END;

   IF (ValType(CURR_OBJ_ONLY) == V_UNDEF)
      CURR_OBJ_ONLY = FALSE;
   END;

   ObjSrchStr = " = " + ObjectNumber;
   IF (ObjectType == LO_DUTY)
      // Поиск по обязательству учитывает все предыдущие обязательство в его линии пролонгации
      FrstDutyID_Ref = LnSelectValue("SELECT T_FIRSTDUTYID_REF FROM DDUTY_CRD_DBT WHERE T_DUTYID = " + ObjectNumber, V_INTEGER);

      // Операции искать будем среди всех обязательств в линии пролонгации
      ObjSrchStr = "IN (SELECT T_DUTYID FROM DDUTY_CRD_DBT WHERE T_FIRSTDUTYID_REF = " + FrstDutyID_Ref + ")";
   END;

   IF ((CredOperID == 0) or (ValType(CredOperID) == V_UNDEF))
   // Первый поиск операции
      NextOpStr = "";
   ELSE
   // Продолжение поиска операции
      IF (FromBegin)
         NextOpStr = " AND T_CREDOPERID > " + CredOperID;
      ELSE
         NextOpStr = " AND T_CREDOPERID < " + CredOperID;
      END;
   END;

   IF (FromBegin)
      MinMaxStr = " NVL(min(T_CREDOPERID),0) ";
   ELSE
      MinMaxStr = " NVL(max(T_CREDOPERID),0) ";
   END;

   IF (((ObjectType == LO_CREDIT) AND (NOT CURR_OBJ_ONLY)) OR
        (ObjectType == LO_KARTA) OR
        (ObjectType == LO_GUARANTEE))
      ObjectStr = " T_CREDITNUMBER_REF = " + ObjectNumber;
   ELSE
      ObjectStr = " T_OBJECTTYPEID_REF = " + string(ObjectType) +
              " AND T_OBJECTID_REF   "     + ObjSrchStr;
   END;

   cmdStr = string("SELECT " + string(MinMaxStr) + " FROM DCRD_OP_DBT WHERE " + ObjectStr +
                                " AND T_ISDELETED        = 0 " + string(NextOpStr) +
                                " AND T_SYSTEMOPERATIONID  = " + string(SystType)  +
                                " AND T_STAGEID_REF        = " + string(stageOp)   +
                                " AND T_CORRECTOPERATION   = 0 " +
                                " AND T_OPERATIONTYPE NOT IN('И', 'С')");

   crd_op.KeyNum = 0;
   crd_op.rec.CredOperID = LnSelectValue(cmdStr, V_INTEGER);
   IF (crd_op.GetEQ)
      CredOperID = crd_op.rec.CredOperID;
      RETURN TRUE;
   END;

   RETURN FALSE;
END;


MACRO NextOpSystType (FirstSOp, ObjectNumber, Операции:@TBFile, SystType, Направление, CurCode, ObjectType, StageOp, CredOperID:@integer, CURR_OBJ_ONLY:bool)
   IF (ValType(ObjectType) == V_UNDEF)
      ObjectType = LO_CREDIT;
   END;

   IF (ValType(CurCode) == V_UNDEF)
      CurCode = 0;
   END;

   IF (ValType(StageOp) == V_UNDEF)
      StageOp = CF_COMPLIT;
   END;

   IF (ValType(CURR_OBJ_ONLY) == V_UNDEF)
      CURR_OBJ_ONLY = FALSE;
   END;

   RETURN GetOperation(ObjectType, ObjectNumber, @Операции, SystType, Направление, CurCode, StageOp, @CredOperID, CURR_OBJ_ONLY);
END;

// Дата последней операции
macro LastOpDate (
   ObjK   : integer,
   ObjN   : integer,
   OpSyst : integer,
   OpType : integer,
   OpDate : date,
   OpID   : integer
)
   var lOpSyst : integer = 0;
   var lOpType : integer = 0;
   var lOpDate : date = date (1, 1, 2);
   var lOpID : integer = 0;

   var RSDcmd = null;
   var RetDate : date = date (0,0,0);

   if (ValType(OpSyst) == V_INTEGER)
      lOpSyst = OpSyst;
   end;

   if (ValType(OpType) == V_INTEGER)
      lOpType = OpType;
   end;
   
   if (ValType(OpDate) == V_DATE)
      lOpDate = OpDate;
   end;

   if (ValType(OpID) == V_INTEGER)
      lOpID = OpID;
   end;

   RSDcmd = RsdCommand (RslDefCon, "BEGIN ? := LoansKernel.LastOpDate (?, ?, ?, ?, ?, ?); END;");

   RSDcmd.addParam ("RetDate", RSDBP_RETVAL, V_DATE);
                                                            
   RSDcmd.addParam ("ObjK",   RSDBP_IN); RSDcmd.value ("ObjK")   = ObjK;
   RSDcmd.addParam ("ObjN",   RSDBP_IN); RSDcmd.value ("ObjN")   = ObjN;
   RSDcmd.addParam ("OpSyst", RSDBP_IN); RSDcmd.value ("OpSyst") = lOpSyst;
   RSDcmd.addParam ("OpType", RSDBP_IN); RSDcmd.value ("OpType") = lOpType;
   RSDcmd.addParam ("OpDate", RSDBP_IN); RSDcmd.value ("OpDate") = lOpDate;
   RSDcmd.addParam ("OpID",   RSDBP_IN); RSDcmd.value ("OpID")   = lOpID;

   RSDcmd.execute ();

   RetDate = RSDcmd.value ("RetDate");

   return RetDate;
end;

MACRO GetHistoryClient (CodClient, HDate)
  FILE party        ("party.dbt",    "loans.def");              /* Справочник субъектов*/
  VAR Work :string = "";

  party.PartyID = CodClient;
  Work = readNoteForObject(OBJTYPE_PERSN, UniID( party, OBJTYPE_PARTY ), 68, Hdate );

  IF(( Work == "") or ( ValType( Work ) == V_UNDEF ))
      RETURN "";
  ELSE
      IF (date(StrSubst(Work," ","0")) <= HDate)
          RETURN "X";
  ELSE
     RETURN "";
  END;
END;
  RETURN "";
END;


/*
Функция возвращает значение пользовательского поля объекта. 16.08.2002 TT
Входные параметры:
    ObjectType     - тип объекта,
    ObjectID       - ID объекта,
    FieldType      - ID поля,
    Дата           - дата значения,
    GroupNum       - номер группы

12.05.2003 TT: 1. Перед возвратом из функции полученное значение преобразовывается к нужному типу.
               2. Если требуется вернуть значение доп. поля для клиента - обращаемся к примечаниям клиента
*/
MACRO GetUsFieldValue(ObjectType, ObjectID, FieldType, Дата, GroupNum:integer)
   VAR fType = 0, result = "";
   VAR RSDcmd;

   IF (valType(Дата) == V_UNDEF)
      Дата = date(31,12,9999);
   END;

   IF (valType(GroupNum) == V_UNDEF)
      GroupNum = 0;
   END;

   RSDcmd = RsdCommand(RslDefCon, "begin ? := LOANSUSERFUNCTION.GETUSFIELDVALUE(?, ?, ?, ?, ?, ?); end;");
   RSDcmd.addParam("retv",      RSDBP_RETVAL, V_STRING, 501);
   RSDcmd.addParam("fieldtype", RSDBP_IN); RSDcmd.Value ("fieldtype") = FieldType;
   RSDcmd.addParam("opdate",    RSDBP_IN); RSDcmd.Value ("opdate") = Дата;
   RSDcmd.addParam("objk",      RSDBP_IN); RSDcmd.Value ("objk") = ObjectType;
   RSDcmd.addParam("objn",      RSDBP_IN); RSDcmd.Value ("objn") = ObjectID;
   RSDcmd.addParam("rettype",   RSDBP_OUT, V_INTEGER);
   RSDcmd.addParam("grpnum",    RSDBP_IN); RSDcmd.Value ("grpnum") = GroupNum;

   IF (RSDcmd != NULL)
      RSDcmd.execute;
   END;

   ftype  = RSDcmd.Value (5);
   result = TRIM(RSDcmd.value(0));

   IF (ValType (ftype) == 26)
      ftype = 666;
   END;

   IF (fType == 0)   // INT
      RETURN int(result);
   ELIF (fType == 1) // LONG
      RETURN int(result);
   ELIF ((fType >= 2) AND (fType <= 3))
      RETURN double(result);
   ELIF ((fType >= 4) AND (fType <= 6))
      RETURN double(result);
   ELIF (fType == 7)
      RETURN result;
   ELIF (fType == 8)
      RETURN result;
   ELIF (fType == 9)
      RETURN Date(result);
   ELIF ((fType == 10) or (fType == 11))
      RETURN Time(result);
   ELIF (fType == 12)
      RETURN Substr(result, 1, 1);
   ELIF (fType == 13)
      RETURN Substr(result, 1, 1);
   ELIF ((fType == 14) or (fType == 15) or (fType == 25))
      RETURN MoneyL(result);
   ELIF ((fType == 16) or (fType == 17))
      RETURN doubleL(result);
   ELIF (fType == 18)
      RETURN result;
   elif (fType == 666)
      return NULL;
   END;

   RETURN result;
END;

/*
Транзакция вставки значения доп. поля для функции SetUsFieldValue(...)
Функция должна быть глобальной.
*/
MACRO SetUsFieldValue_insTrn()
   IF (NOT Insert(lufotype_w))
      aborttrn;
   END;

   lufvalue_w.UsFObjTypeID_Ref = lufotype_w.UsFObjTypeID;
   IF (NOT Insert(lufvalue_w))
      aborttrn;
   END;
END;


/*
Функция устанавливает значение пользовательского поля объекта на дату. 16.08.2002 TT
Если на заданную дату уже установлено значение, оно обновляется.
Входные параметры:
    ObjectType     - тип объекта,
    ObjectID       - ID объекта,
    FieldType      - тип поля,
    FieldValue     - значение поля,
    IsOperating    - признак значения доп. поля: TRUE - Действует, FALSE - отложен
    Дата           - дата значения
Возвращает TRUE в случае успешной вставки/обновления, FALSE - в противном случае.
*/
MACRO SetUsFieldValue(ObjectType, ObjectID, FieldType, GroupNum, FieldValue, IsOperating:bool, Дата:date)
   VAR LastID, IsOperatingStr = "", RSDcmd;

   IF (valType(Дата)        == V_UNDEF)   Дата = date(0,0,0) END;
   IF (valType(IsOperating) == V_UNDEF)   IsOperating = TRUE END;
   IF (valType(FieldValue)  == V_UNDEF)   FieldValue = ""    END;
   IF (valType(GroupNum)    == V_UNDEF)   GroupNum = 0       END;    

   IF (IsOperating)
      IsOperatingStr = "X";
   ELSE
      IsOperatingStr = "";
   END;

   RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansUserFunction.setmacrousfieldvalue(?,?,?,?,?,?,?); end;");

   RSDcmd.addParam("retval",   RSDBP_RETVAL, V_INTEGER);

   RSDcmd.addParam("objid",     RSDBP_IN, ObjectType        );
   RSDcmd.addParam("objn",      RSDBP_IN, ObjectID          );
   RSDcmd.addParam("fieldtype", RSDBP_IN, FieldType         );
   RSDcmd.addParam("fieldgr",   RSDBP_IN, GroupNum          );
   RSDcmd.addParam("strvalue",  RSDBP_IN, string(FieldValue));
   RSDcmd.addParam("isop",      RSDBP_IN, IsOperatingStr    );
   RSDcmd.addParam("opdate",    RSDBP_IN, Дата              );

   RSDcmd.execute();
   IF (RSDcmd.Value(0) == 0)
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END;
END;

/*
   Получить значение пользовательского поля клиента SAE 01.12.00
   Входные параметры:
      CodClient - ID клиента;
      UsFieldID - ID пользовательского поля
   Изменения:
      TT 16.08.02  - добавлен необязательный параметр Дата
*/
MACRO GetClientUsFieldValue (CodClient, UsFieldID, Дата)

    VAR result = "";

    IF (valType(Дата) == V_UNDEF)
       Дата = date(31,12,9999);
    END;

    IF (DepClnt.GetRecord(CodClient))
        IF (Depclnt.LegalForm == PTLEGF_PERSN)
           result = DepClnt.GetProperty(UsFieldID, 8/*OBJTYPE_PERSN*/, Дата);
        ELIF (Depclnt.LegalForm == PTLEGF_INST)
           result = DepClnt.GetProperty(UsFieldID, 3/*OBJTYPE_PARTY*/, Дата);
        ELSE
           result = "";
        END;
    END;

    IF (ValType(result) == V_UNDEF)
       result = "";
    END;

    RETURN result;
END;

/*
   Получение значения дополнительного поля объекта обеспечения. SAE 05.12.00
   Входные параметры:
      EnsObjectID - ID объекта обеспечения;
      EnsFieldID  - ID доп. поля
*/
MACRO GetEnsFieldValue (EnsObjectID, EnsFieldID)
   ClearRecord (EnsFieldVal);
   EnsFieldVal.EnsObjectID_Ref = EnsObjectID;
   EnsFieldVal.EnsFieldID_Ref  = EnsFieldID;
   IF (GetEQ (EnsFieldVal))
      RETURN EnsFieldVal.EnsFieldValue;
   ELSE
      RETURN "_________";
   END;
END;

/*
   Получение стоимости обеспечения по кредитному договору. SAE 06.12.00
   Входные параметры:
      НомерДоговора           - номер кредитного договора;
      СистемныйВидОбеспечения - системный вид обеспечения
      Тип                     - договор - 0, заявка - 1;
      Дата                    - дата, на которую рассчитывается сумма обеспечения

   Изменения:
      22.05.03 - 1. Добавил необязательный параметр "Дата"
                 2. Системный вид обеспечения может быть равен нулю - тогда вычисляется сумма
                    всех обеспечений независимо от типа обеспечения.
*/
MACRO СуммаОбеспечения (НомерДоговора, СистемныйВидОбеспечения, Тип, Дата)
   VAR Сумма = $0, СуммаРасчет = $0,
       rs_1 = NULL,
       query = "";

   IF (ValType(Дата) == V_UNDEF)
      Дата = date(31,12,9999);
   END;

   IF (Тип == 1) /* По заявке */
       query = " SELECT t_enscontractsum, t_enscontractcur FROM denscontr_dbt WHERE t_claimid_ref = " + НомерДоговора;

   ELSE          /*По договору */
       query = "SELECT t_EnsContractSum, t_EnsContractCur FROM denscontr_dbt, dens_crd_dbt ";
       query = query + "WHERE t_EnsContractid = t_EnsContractId_Ref AND t_CreditNumber_Ref = " + НомерДоговора;

   END;

   IF (СистемныйВидОбеспечения != 0)
       query = query + " AND t_EnsSysType = " + СистемныйВидОбеспечения;
          END;

   rs_1 = LnGetRecordSet(query);
   IF (rs_1 == NULL) RETURN 0; END;
   WHILE(rs_1.MoveNext())
         ConvSum(СуммаРасчет, rs_1.Value("t_EnsContractSum"), Дата, rs_1.Value("t_EnsContractCur"), NATCUR);
         Сумма = Сумма + СуммаРасчет;
   END;
   RETURN Сумма;
END;

MACRO __GetLastCredOperID_ForPlanPay (DutyID:integer, DutyForm:@integer, ObjID:@integer, ObjN:@integer)

    FILE duty_crd ("duty_crd.dbt", "loans.def") key 0;
    FILE credit_c ("credit_c.dbt", "loans.def") key 0;

    VAR  Операции = TBFile ("crd_op.dbt", "r", 0, "crd_op.dbt", "loans.def");
    VAR  CredOperID = 0;

    VAR  DutyForm_ = DF_BY_TRANCHES,
         RSDcmd = NULL,
         rs = NULL;

    duty_crd.DutyID = DutyID;
    IF (NOT GetEQ(duty_crd))
       RETURN 0;
    END;

    credit_c.CreditNumber = duty_crd.CreditNumber_Ref;
    IF (NOT GetEQ(credit_c))
       RETURN 0;
    END;

    RSDcmd = RsdCommand(RslDefCon, "select T.t_Duty from dparmdemandline_dbt T where t.t_ObjectTypeID = ? and t.t_ObjectNumber = ?");
    RSDcmd.addParam("t.t_ObjectTypeID", RsdBp_in); RSDcmd.value(0) = credit_c.Crd_Kind;
    RSDcmd.addParam("t.t_ObjectNumber", RsdBp_in); RSDcmd.value(1) = credit_c.CreditNumber;
    RSDcmd.execute;
  
    rs = RsdRecordset(RSDcmd);
    if (rs.moveNext)
        DutyForm_ = rs.value(0, NULL, V_INTEGER);
    end;
    
    SetParm(1, DutyForm_);

    if(DutyForm_ == DF_BY_ACCOUNT)
        CredOperID = GetLastCredOperID_ForPlanPay (credit_c.CreditNumber, credit_c.Crd_Kind);
        SetParm(2, credit_c.Crd_Kind);
        SetParm(3, credit_c.CreditNumber);
    else
    WHILE (GetOperation (LO_DUTY, DutyID, @Операции, CS_RECALCGPAY, FALSE, credit_c.CurCode, CF_COMPLIT, @CredOperID)
           AND (CredOperID == 0))
    END;
        SetParm(2, LO_DUTY);
        SetParm(3, DutyID);
    end;

    RETURN CredOperID;
END;

MACRO _GetLastCredOperID_ForPlanPay (DutyID:integer)
    VAR  DutyForm:integer = 0, ObjID:integer = 0, ObjN:integer = 0;

    return __GetLastCredOperID_ForPlanPay (DutyID, DutyForm, ObjID, ObjN);
END;

/*
   Получение суммы единовременного платежа. SAE 14.12.00
   Входные параметры:
      ID вида объекта
      ID объекта
   Для аннуитеного СО сумма = общей сумме (аннуитету)
*/
MACRO СуммаЕдиновременногоПлатежа (IDВидаОбъекта, IDОбъекта)

   VAR Сумма = $0, CredOperID = 0;
   VAR stat  = FALSE, str = "";
   VAR objid_ :integer = IDВидаОбъекта,
       objn_ :integer = IDОбъекта,
       RSDcmd = NULL,
       LRSDBP_IN_OUT = 3; // Замена отсутствующему RSDBP_IN_OUT

   IF(IDВидаОбъекта == LO_DUTY)
       Duty.DutyID = IDОбъекта;
       IF (NOT GetEQ (Duty))
           MsgBox ("Не найдено срочное обязательство ID = "+IDОбъекта);
           RETURN $0;
       END;
   ELSE
       Договор.CreditNumber = IDОбъекта;
       IF(NOT GetEQ(Договор))
           MsgBox ("Не найден договор ID = "+IDОбъекта);
           RETURN $0;
       END;
   END;

   
   RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansUserFunction.getlastcredopid_forplpay_out (?,?,?); end;");

   RSDcmd.AddParam("credoperid", RSDBP_RETVAL, V_INTEGER);
   RSDcmd.addParam("objid",      LRSDBP_IN_OUT); RSDcmd.value ("objid")     = objid_;
   RSDcmd.addParam("objn",       LRSDBP_IN_OUT); RSDcmd.value ("objn")      = objn_;
   RSDcmd.addParam("graphtype",  RSDBP_IN);      RSDcmd.value ("graphtype") = 1;
   RSDcmd.execute();

   CredOperID = RSDcmd.value("credoperid", NULL, V_INTEGER);
   objid_     = RSDcmd.value("objid",      NULL, V_INTEGER);
   objn_      = RSDcmd.value("objn",       NULL, V_INTEGER);

   IF (CredOperID == 0)
     IF(objid_ == LO_DUTY)
         str = "срочного обязательства";
     ELIF(objid_ == LO_CREDIT)
         str = "договора";
     END;
     MsgBox ("Не найдена запись в графике погашения|для " + str + " ID = "+objn_);
     Сумма = $0;   
   ELSE
    Сумма = LnSelectValue("select case T_ANNUIT " +
                                    "when chr(88) then T_SUM " +
                                    "else T_PAY_DUTYPAYMENTSUM " +
                                    "end "
                                    "from dlgpayop_dbt "
                                    "where T_CREDOPERID_REF = " + CredOperID +
                                    " and T_TYPE = 1 ", V_MONEY);    
   END;
   RETURN Сумма;
END;

/*
   Получение суммы последнего платежа. TT 27.12.00
   Входные параметры:
      IDОбязательства - ID СО
   Для аннуитеного СО сумма = общей сумме (аннуитету)
*/
MACRO СуммаПоследнегоПлатежа (IDОбязательства)
   VAR Сумма = $0, CredOperID = 0, objid = 0, objn = 0, DutyForm = 0;
   VAr rs = NULL;
   var RSDcmd = NULL,
   LRSDBP_IN_OUT = 3;
   Duty.DutyID = IDОбязательства;
   IF (NOT GetEQ (Duty))
      MsgBox ("Не найдено срочное обязательство ID = "+IDОбязательства);
      RETURN $0;
   END;

   Договор.CreditNumber = Duty.CREDITNUMBER_REF;
   IF(NOT GetEQ(Договор))
       MsgBox ("Не найден договор ID = "+Duty.CREDITNUMBER_REF);
       RETURN $0;
   END;
   
   objn = IDОбязательства;
   IF (Договор.crd_kind == LO_GUARANTEE)
    objid = LO_BANKGUARANTEE;
   ELSE 
    objid = LO_DUTY;
   END; 
   
   RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansUserFunction.getlastcredopid_forplpay_out (?,?,?); end;");

   RSDcmd.AddParam("credoperid", RSDBP_RETVAL, V_INTEGER);
   RSDcmd.addParam("objid",      LRSDBP_IN_OUT); RSDcmd.value ("objid")     = objid;
   RSDcmd.addParam("objn",       LRSDBP_IN_OUT); RSDcmd.value ("objn")      = objn;
   RSDcmd.addParam("graphtype",  RSDBP_IN);      RSDcmd.value ("graphtype") = 1;
   RSDcmd.execute();

   CredOperID = RSDcmd.value("credoperid", NULL, V_INTEGER);
   objid     = RSDcmd.value("objid",      NULL, V_INTEGER);
   objn      = RSDcmd.value("objn",       NULL, V_INTEGER);   
   
Сумма = LnSelectValue(
                        "with lgpayop_t as " + 
                        "( " +
                        "select distinct case T_ANNUIT " +
                        "         WHEN chr(88) then T_TYPE " +
                        "         ELSE 1  " + // если не ануитет то берем только ОД
                        "         END as T_type_target " +
                        "         , T_CREDOPERID_REF  " +
                        "from dlgpayop_dbt " +
                        "where  " +
                        "T_CREDOPERID_REF = " + CredOperID +
                        " ), " +
                        "planpay_t as " +
                        "( " +
                        "select sum(T_PLANNEDPAYSUM) as summ , T_PLANNEDPAYDATE " +
                        "from dplanpay_dbt planpay join lgpayop_t lgpayop on (planpay.T_CREDOPERID_REF = lgpayop.T_CREDOPERID_REF  and planpay.T_TYPE = T_type_target ) " +
                        "where  planpay.T_TYPE in (1,2) " + // нас интерисуют только ОД и проценты 
                        "group by T_PLANNEDPAYDATE " +
                        "order by T_PLANNEDPAYDATE desc " +
                        ") " +
                        "select cast(summ  as number(32,12)) " +
                        "from planpay_t " +
                        "where rownum = 1 ", V_MONEY) ;   
   
   
   rs = LnGetRecordSet(  " SELECT  dplanpay_dbt.t_plannedpaysum, dplanpay_dbt.t_plannedpercentsum " +
                         " FROM  dplanpay_dbt " +
                         " WHERE dplanpay_dbt.t_ObjectTypeId_Ref = " + objid +
                         " AND dplanpay_dbt.t_CredoperId_Ref = " + CredOperID  +
                         " AND dplanpay_dbt.t_type in (1,2)" +
                         " AND dplanpay_dbt.t_objectid_ref = " + objn);

   IF (rs == NULL)  RETURN 0;   END;
   IF (rs.MoveNext() == 0)
     MsgBox ("Не найдена запись в графике погашения|для срочного обязательства ID = "+IDОбязательства);
     RETURN $0;
   END;
   RETURN Сумма;
END;

/*
   Определение пола клиента SAE 09.02.01
   Анализируется первый символ доп.поля "пол"
   Входные параметры:
      CodClient - ID клиента
*/
MACRO GetClientSex (CodClient)
   IF (NOT Depclnt.GetRecord(CodClient))
       RETURN "";
   END;
   IF (trim(Depclnt.IsMale) != "")
       RETURN "муж.";
   ELSE
       RETURN "жен.";
   END;
END;

/*
   Определение признака инсайдера SAE 11.04.01
   Входные параметры:
      CodClient - ID клиента
*/
MACRO IsInsider (CodClient)
   VAR retval;
   PRIVATE VAR party:TBFile;
   VAR OBJ_PARTY_GROUP_CHARACTER  = 2;   /* Характер отношений с банком */
   party    = TBFile( "party.dbt",    "R", 0, "party.dbt",    "bank.def" );

   party.Rec.PartyID  = CodClient;
   IF(party.GetEQ())
       IF((GetMainObjAttr(retval, OBJTYPE_PARTY, UniID(party,OBJTYPE_PARTY ),
                      OBJ_PARTY_GROUP_CHARACTER) == TRUE) AND
          (retval == 0))
           RETURN TRUE;
       END;
   END;

   RETURN FALSE;
END;


/* Tsibulsky A.V.:
Определение настройки на виде кредита "Доначисление комиссий"
*/
MACRO GetKomissType(ObjectTypeID: integer, ObjectNumber: integer, KomissType: string)
   VAR retval: integer = -1;

   SetParm(2, "OFF");

   IF   ((ObjectTypeID == LO_CREDIT) OR (ObjectTypeID == LO_KARTA) OR (ObjectTypeID == LO_GUARANTEE))
      retval = LnSelectValue("SELECT T_Komiss FROM DTYPE_CRD_DBT tcr, DCREDIT_C_DBT crd WHERE " +
                                            " crd.T_CREDITTYPEID_REF = tcr.T_CREDITTYPEID AND " +
                                            " crd.T_CREDITNUMBER = " + ObjectNumber, V_INTEGER);
   ELIF  (ObjectTypeID == LO_DUTY)
      retval = LnSelectValue("SELECT T_Komiss FROM DTYPE_CRD_DBT tcr, DCREDIT_C_DBT crd, DDUTY_CRD_DBT duty WHERE " +
                                            " crd.T_CREDITTYPEID_REF = tcr.T_CREDITTYPEID      AND " +
                                            " crd.T_CREDITNUMBER     = duty.T_CREDITNUMBER_REF AND " +
                                            " duty.T_DUTYID = " + ObjectNumber, V_INTEGER);
   ELSE
      RETURN FALSE;
   END;

   IF   (retval == 88)
      SetParm(2, "ON");
      RETURN TRUE;
   ELIF ((retval == 0) OR (retval == 32))
      RETURN TRUE;
   END;
   RETURN FALSE;
END;

/* TFS:
      Определения настройки "RT-LOANS\\НАЧИСЛ_ПРОЦ_ПЕРЕД_ОПЛАТОЙ"
      Параметр берется из Вида Кредита
   Параметры:
 (in)  ObjectTypeID - Вид объекта (LO_CREDIT, LO_KARTA, LO_DUTY)
       ObjectNumber - Номер объекта

 (out) PercChargeType - Настрока ('X', '')
   Возвращаемые значения:
       TRUE  - Успешно
       FALSE - ОШИБКА
 */
MACRO GetPercChargeType(ObjectTypeID: integer, ObjectNumber: integer, PercChargeType: string)
   VAR retval: integer = -1;

   SetParm(2, "OFF");

   IF   ((ObjectTypeID == LO_CREDIT) OR (ObjectTypeID == LO_KARTA) OR (ObjectTypeID == LO_GUARANTEE) OR (ObjectTypeID == LO_OVERDRAFT))
      retval = LnSelectValue("SELECT T_PaymFromCharged FROM DTYPE_CRD_DBT tcr, DCREDIT_C_DBT crd WHERE " +
                                            " crd.T_CREDITTYPEID_REF = tcr.T_CREDITTYPEID AND " +
                                            " crd.T_CREDITNUMBER = " + ObjectNumber, V_INTEGER);
   ELIF  (ObjectTypeID == LO_DUTY)
      retval = LnSelectValue("SELECT T_PaymFromCharged FROM DTYPE_CRD_DBT tcr, DCREDIT_C_DBT crd, DDUTY_CRD_DBT duty WHERE " +
                                            " crd.T_CREDITTYPEID_REF = tcr.T_CREDITTYPEID      AND " +
                                            " crd.T_CREDITNUMBER     = duty.T_CREDITNUMBER_REF AND " +
                                            " duty.T_DUTYID = " + ObjectNumber, V_INTEGER);


   ELSE
      RETURN FALSE;
   END;

   IF   (retval == 88)
      SetParm(2, "ON");
      RETURN TRUE;
   ELIF ((retval == 0) OR (retval == 32))
      RETURN TRUE;
   END;
   RETURN FALSE;
END;

/*    Определения параметра Погашение начисленных %%
      (Параметр берется из Вида Кредита - PayChargePercent)
   Параметры:
 (in)  ObjectTypeID - Вид объекта (LO_CREDIT, LO_KARTA, LO_DUTY, ...)
       ObjectNumber - Номер объекта

 (out) PayChargePercent - Настрока ('X', '')
   Возвращаемые значения:
       TRUE  - Успешно
       FALSE - ОШИБКА
 */
/*
MACRO GetPayChargePercent(ObjectTypeID: integer, ObjectNumber: integer, PayChargePercent: string)
   VAR retval: integer = -1;

   SetParm(2, "OFF");

   IF   ((ObjectTypeID == LO_CREDIT) OR (ObjectTypeID == LO_KARTA) OR (ObjectTypeID == LO_GUARANTEE) OR (ObjectTypeID == LO_OVERDRAFT))
      retval = LnSelectValue("SELECT T_PayChargePercent FROM DTYPE_CRD_DBT tcr, DCREDIT_C_DBT crd WHERE " +
                                            " crd.T_CREDITTYPEID_REF = tcr.T_CREDITTYPEID AND " +
                                            " crd.T_CREDITNUMBER = " + ObjectNumber, V_INTEGER);
   ELIF  (ObjectTypeID == LO_DUTY)
      retval = LnSelectValue("SELECT T_PayChargePercent FROM DTYPE_CRD_DBT tcr, DCREDIT_C_DBT crd, DDUTY_CRD_DBT duty WHERE " +
                                            " crd.T_CREDITTYPEID_REF = tcr.T_CREDITTYPEID      AND " +
                                            " crd.T_CREDITNUMBER     = duty.T_CREDITNUMBER_REF AND " +
                                            " duty.T_DUTYID = " + ObjectNumber, V_INTEGER);


   ELSE
      RETURN FALSE;
   END;

   IF   (retval == 88)
      SetParm(2, "ON");
      RETURN TRUE;
   ELIF ((retval == 0) OR (retval == 32))
      RETURN TRUE;
   END;
   RETURN FALSE;
END;
*/

/*
   Поиск счёта по договору SAE 11.04.01
   Входные параметры:
      CreditNumber - номер договора;
      CurCode      - код валюты договора;
      AccountType  - тип счёта.
      ObjectTypeID - вид объекта, по которому нужно получить номер счета
   Выходные параметры - номер счёта
*/
MACRO НомерСчета (ObjectNumber, CurCode, AccountType, ObjectTypeID)
  VAR OldKey = 0;

  IF (ValType(ObjectTypeID) == V_UNDEF)
      ObjectTypeID = LO_CREDIT;
  END;

  /* Для ссудного счёта по договору возвращаем ссудный счёт в 1-ом открытом СО */
  IF ((AccountType == CRD_ACC) AND (ObjectTypeID == LO_CREDIT))
    OldKey = KeyNum (Duty, 1);
    Duty.CreditNumber_Ref = ObjectNumber;
    Duty.DutyType = 0;
    Duty.DutyState        = CF_OPEN;
    IF (GetEQ (Duty))
      ObjectNumber = Duty.DutyID;
      ObjectTypeID = LO_DUTY;
    END;
    KeyNum(Duty, OldKey);
  END;

   RETURN CRSDCommand(
   "SELECT a.T_ACCOUNTNUMBER_REF "+
     "FROM DACC_CRD_DBT a "+
    "WHERE a.T_CURCODE = ? "+
      "AND a.t_creditaccounttype = ? "+
      "AND a.T_OBJECTID = ? "+
      "AND a.T_OBJECTNUMBER = ? "+
   "ORDER BY a.T_ACCOUNTSTATE ASC ",
   "p1", CurCode,
   "p2", AccountType,
   "p3", ObjectTypeID,
   "p4", ObjectNumber,
  V_STRING);

END;

/* Получить качество обеспечения ссуды на дату SAE 11.04.01 */
MACRO КачествоОбеспечения (CreditNumber, EnsureDate)
  VAR rs;
  FILE Credit ("credit_c.dbt", "loans.def");

    Credit.CreditNumber = CreditNumber;
    IF (NOT GetEQ (Credit))
      PrintLn ("Качество обеспечения: не найден кредитный договор с ID = "+CreditNumber);
      RETURN -1;
    END;

    rs = LnGetRecordSet(  " SELECT t_TypeEnsure FROM densure_dbt " +
                          " WHERE  t_CreditNumber = " + CreditNumber +
                          " AND t_date <= " + SQLDate(EnsureDate) +
                          " order by t_date desc");

    IF (rs == NULL) RETURN 0; END;
    IF (rs.MoveNext())
        RETURN rs.Value(0);
  ELSE
    PrintLn ("Не определено качество обеспечения по кредитному договору/карте "+Credit.UsCreditNumber+" на дату "+EnsureDate);
    RETURN -1;
  END;
END;

/*
   Определение количества переоформлений кредитного договора SAE 11.04.01
   Входные параметры:
      CreditNumber - номер договора;
      IDate        - дата, на которую определяем.
   Выходные параметры:
      OutParm1 - количество переоформлений с изменением условий договора;
      OutParm2 - количество переоформлений без изменением условий договора.
*/
MACRO КоличествоПереоформлений (CreditNumber, IDate, OutParm1, OutParm2)

  VAR Parm1 = 0, Parm2 = 0;
  VAR rs = NULL;

  rs = LnGetRecordSet(  " SELECT t_IsChangeContract FROM dchange_t_dbt " +
                        " WHERE  t_CreditNumber_Ref = " + CreditNumber +
                        " AND t_RebillingDate <= " + SQLDate(IDate));
  IF (rs == NULL) RETURN 0; END;
  WHILE(rs.MoveNext())
      IF (rs.Value(0) == "X")
        Parm1 = Parm1 + 1;
      ELSE
        Parm2 = Parm2 + 1;
      END;
  END;
  SetParm (2, Parm1);
  SetParm (3, Parm2);
END;


/*
Функция возвращает сумму остатков (ТипОстатка) по всем открытым обязательствам
кредитного договора на дату (аналог ОстатокСО(...))
*/
MACRO ОстатокКД (CreditNumber, ТипОстатка, Дата)

    VAR Сумма:moneyL = $0, oldkey, stat = FALSE;

    oldkey = Duty_SQL.Keynum;
    Duty_SQL.Keynum = 1;
    Duty_SQL.Clear;
    Duty_SQL.rec.CreditNumber_Ref = CreditNumber;
    Duty_SQL.rec.DutyType         = 0;
    Duty_SQL.rec.DutyState        = "";
    Duty_SQL.AddFilter("t_CreditNumber_Ref = " + CreditNumber + " AND t_DutyType = 0 ");
    stat = Duty_SQL.GetGE AND (Duty_SQL.rec.CreditNumber_Ref == CreditNumber)
                      AND (Duty_SQL.rec.DutyType         == 0);
    WHILE (stat AND (Duty_SQL.rec.CreditNumber_Ref == CreditNumber)
                AND (Duty_SQL.rec.DutyType == 0))

        Сумма = Сумма + ОстатокСО(Duty_SQL.rec.DutyID, ТипОстатка, Дата);
        stat = Duty_SQL.next;
    END;

    Сумма = Сумма + ОстатокРегистра( LO_CREDIT, CreditNumber, ТипОстатка, Дата );

    Duty_SQL.DropFilter;
    Duty_SQL.Keynum = oldkey;

    RETURN Сумма;
END;


//Если функция вызвана для КД, то возращает суммарный остаток по всем регистрам RegTypeID КД и всех его СО
//Если функция вызвана по другому виду объекта - возвращает остаток регистра на дату.
MACRO GetAllRegRest(ObjectTypeID, ObjectID, RegTypeID, Дата)
   VAR duty_crd = TBFile ("duty_crd.dbt", "r", 1);
   VAR RestSum  = $0, stat = FALSE;

   RestSum = ОстатокРегистра(ObjectTypeID, ObjectID, RegTypeID, Дата);

   // Если ищем остаток по регистру ОД - присуммируем к нему остатки по тем же регистрам СО
   IF (ObjectTypeID == LO_CREDIT)
      duty_crd.Clear;
      duty_crd.AddFilter("t_CreditNumber_Ref = " + ObjectID + " AND t_DutyType = 0 ");
      duty_crd.rec.CreditNumber_Ref = ObjectID;
      duty_crd.rec.DutyType         = 0;
      duty_crd.rec.DutyState        = "";
      stat = duty_crd.GetGE;
      WHILE (stat)
         RestSum = RestSum + ОстатокРегистра(LO_DUTY, duty_crd.rec.DutyID, RegTypeID, Дата);
         stat    = duty_crd.Next;
      END;
      Duty_crd.DropFilter;
   END;
   RETURN RestSum;
END;


/*Функция возвращает фактическую сумму операции CredOperID по виду задолженности ds_type*/
PRIVATE MACRO GetOpFactSum(CredOperID, ds_type)

   RETURN LnSelectValue("SELECT t_ActualAmount FROM dplanfact_dbt WHERE t_CredOperID_Ref = " + CredOperID +
                              " AND t_DutyStageID_Ref = " + ds_type, V_MONEY);
END;


/*
   Определение количества дней просрочки ОД и % обязательства TT 11.04.01
   Входные параметры:
      DutyID       - ID обязательства;
      IDate        - дата, на которую определяем.
   Выходные параметры:
      OutParm1 - количество дней просрочки ОД;
      OutParm2 - количество дней просрочки %.

   Количество дней считается с даты образования НЕнулевого остатка на регистре просрочки
   ОД или процентов
*/
MACRO КоличествоДнейПросрочкиСО (DutyID, IDate, OutParm1:@integer, OutParm2:@integer, ДатаОД:@date, ДатаПроц:@date)

  VAR CrdOp = TBFile ("crd_op.dbt", "r", 3);
  VAR CredOperID = 0, FindOD = FALSE, FindPerc = FALSE;
  VAR SumRegRest : money = $0,
      SumRegPerc : money = $0;

  // определим состояние регистров
  SumRegRest = GetAllRegRest (LO_DUTY, DutyID, TDR_EXPREST, IDate);
  SumRegPerc = GetAllRegRest (LO_DUTY, DutyID, TDR_EXPPERC, IDate);

  // если есть просрочка
  IF ((SumRegRest != 0) OR
      (SumRegPerc != 0))
     // Будем перебирать все операции просрочки по КД и всем СО начиная с последней
     // Остановимся на той, которая перенесла договор в разряд просроченных
     // (т.е. до нее остатки по всем регистрам просрочки были нулевыми)
     CredOperID = 0;
     WHILE (NextOpSystType(TRUE, DutyID, @CrdOp, CS_EXP, FALSE, 0, LO_DUTY, CF_COMPLIT, @CredOperID, TRUE)
             AND ((NOT FindOD) or (NOT FindPerc)))
        // если есть просрочка ОД
        IF (SumRegRest != 0)
           IF (GetOpFactSum(CredOperID, DS_DUTY) != 0)
              IF (GetAllRegRest(LO_DUTY, DutyID, TDR_EXPREST, crdOp.rec.CredOperDate - 1) == 0)
                 ДатаОД = crdOp.rec.CredOperDate;
                 FindOD = TRUE;
              END;
           END;
        END;
        // если есть просрочка %
        IF (SumRegPerc != 0)
           IF ((GetOpFactSum(CredOperID, DS_PERC) != 0) OR (GetOpFactSum(CredOperID, DS_ADDPERC) != 0))
              IF (GetAllRegRest(LO_DUTY, DutyID, TDR_EXPPERC, crdOp.rec.CredOperDate - 1) == 0)
                 ДатаПроц = crdOp.rec.CredOperDate;
                 FindPerc = TRUE;
              END;
           END;
        END;
     END;
  END;

  IF (FindOD)
     OutParm1 = IDate - ДатаОД;
  ELSE
     OutParm1 = 0;
  END;

  IF (FindPerc)
     OutParm2 = IDate - ДатаПроц;
  ELSE
     OutParm2 = 0;
  END;

  SetParm (2, OutParm1);
  SetParm (3, OutParm2);
END;


/*
   Определение количества дней просрочки ОД и % кредитного договора SAE 11.04.01
   Входные параметры:
      ObjectNumber - номер объекта;
      CurCode      - параметр не используется
      IDate        - дата, на которую определяем.
      ObjectID     - вид объекта;
      WithoutDuty  - параметр не используется
   Выходные параметры:
      ExpDaysOD   - количество дней просрочки ОД;
      ExpDaysPerc - количество дней просрочки %.

   Количество дней считается с даты образования НЕнулевого
   остатка по одному из регистров просрочки данного КД или одного из его срочных обязательств
*/
MACRO КоличествоДнейПросрочки (ObjectNumber, CurCode, IDate, ExpDaysOD:integer, ExpDaysPerc:integer, ExpRestDate:@date, ExpPercDate:@date, ObjectID, WithoutDuty)

  VAR RSDcmd = null;

  ExpDaysOD   = ExpDaysPerc = 0;
  ExpRestDate = ExpPercDate = date(0,0,0);


  RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansUserFunction.CalcExpDaysOD (?,?,?,?); end;");

  RSDcmd.AddParam("expdays", RSDBP_RETVAL,   V_INTEGER);
  RSDcmd.addParam("objid",   RSDBP_IN, ObjectID    );
  RSDcmd.addParam("objn",    RSDBP_IN, ObjectNumber);
  RSDcmd.addParam("calcdate",RSDBP_IN, IDate       );
  RSDcmd.addParam("expdate", RSDBP_OUT,      V_DATE);
  RSDcmd.execute();

  ExpDaysOD   = RSDcmd.value("expdays", NULL, V_INTEGER);
  ExpRestDate = RSDcmd.value("expdate", NULL, V_DATE);

  RSDcmd = null;

  RSDcmd = RsdCommand(RslDefCon, "begin ? := LoansUserFunction.CalcExpDaysPerc (?,?,?,?); end;");

  RSDcmd.AddParam("expdays", RSDBP_RETVAL,   V_INTEGER);
  RSDcmd.addParam("objid",   RSDBP_IN, ObjectID    );
  RSDcmd.addParam("objn",    RSDBP_IN, ObjectNumber);
  RSDcmd.addParam("calcdate",RSDBP_IN, IDate       );
  RSDcmd.addParam("expdate", RSDBP_OUT,      V_DATE);
  RSDcmd.execute();

  ExpDaysPerc = RSDcmd.value("expdays", NULL, V_INTEGER);
  ExpPercDate = RSDcmd.value("expdate", NULL, V_DATE);

  SetParm (3, ExpDaysOD);
  SetParm (4, ExpDaysPerc);

END;

MACRO КоличествоДнейПросрочки_ГОТ (ObjectID, ObjectNumber, CurCode, IDate)
   var ExpDaysOD:integer, ExpDaysPerc:integer;

   ExpDaysOD   = RunStoredFunc("LoansUserFunction.CalcExpDaysOD",   V_INTEGER, NULL, ObjectID, ObjectNumber, IDate);
   ExpDaysPerc = RunStoredFunc("LoansUserFunction.CalcExpDaysPerc", V_INTEGER, NULL, ObjectID, ObjectNumber, IDate);
   
   if (ExpDaysOD >= ExpDaysPerc)
      return ExpDaysOD;
   else
      return ExpDaysPerc;
   end;
END;

/*
   Определение суммы выданного кредита SAE 19.04.01
   Входные параметры:
      CreditNumber - номер договора;
      CurCode      - код валюты договора;
      FirstDate    - начало периода;
      LastDate     - конец периода.
   Выходные параметры - сумма выданного кредита

   Сумма документов всех операций по договору с системным типом "выдача"
   и статусом "выполнена" в диапазоне дат.
*/
MACRO СуммаВыданногоКредита (CreditNumber, CurCode, FirstDate, LastDate)
    var rs = null;

    VAR RSDcmd = RsdCommand(RslDefCon, "SELECT NVL( SUM(p.T_PAYSUM), 0 ) " +
                                       "  FROM DLPAYOP_DBT p INNER JOIN DCRD_OP_DBT op ON p.t_CredOperID_Ref = op.T_CREDOPERID " +
                                       " WHERE op.T_STAGEID_REF =                                                              " + CF_COMPLIT +
                                       "   AND op.t_IsDeleted        = 0 "                                                       +
                                       "   AND op.T_CREDOPERDATE BETWEEN ? AND ?                                               " +
                                       "   AND op.t_CreditNumber_Ref = ?                                                       ");

    RSDcmd.addParam("FirstDate",RSDBP_IN, FirstDate   );
    RSDcmd.addParam("LastDate", RSDBP_IN, LastDate    );
    RSDcmd.addParam("CrdNum",   RSDBP_IN, CreditNumber);
    rs = RsdRecordset(RSDcmd);
    RSDcmd.execute();

    return rsSelectValue(rs, V_MONEY, 0);
END;


/*
   Определение погашенной суммы кредита SAE 08.08.01
   Входные параметры:
      CreditNumber - номер договора;
      CurCode      - код валюты договора;
      FirstDate    - начало периода;
      LastDate     - конец периода.
   Выходные параметры - погашенная сумма кредита

   Сумма погашенного основного долга по договору с системным типом "погашение"
   и статусом "выполнена" в диапазоне дат.
*/
MACRO ПогашеннаяСуммаКредита (CreditNumber, CurCode, FirstDate, LastDate)

    var rs = null;

    VAR RSDcmd = RsdCommand(RslDefCon, "select sum(pf.t_actualamount) "     +
                                       "  from dplanfact_dbt pf INNER JOIN dcrd_op_dbt op ON pf.t_CredOperID_Ref = op.t_CredOperID " +
                                       " where (pf.t_dutystageid_ref  = "   + DS_DUTY + " OR pf.t_dutystageid_ref = " + DS_NOOVCRD + ") " +
                                       "   AND  op.t_CreditNumber_Ref = ? " +
                                       "   AND  op.T_CREDOPERDATE BETWEEN ? AND ?                                               " +
                                       "   AND  op.t_IsDeleted        = 0 " +
                                       "   AND  op.t_StageID_Ref      =   " + CF_COMPLIT +
                                       "   AND (op.t_SystemOperationID = "  + CS_DUTY    + " OR op.t_SystemOperationID = " + CS_GUARDUTY + ")");

    RSDcmd.addParam("CrdNum",   RSDBP_IN, CreditNumber);
    RSDcmd.addParam("FirstDate",RSDBP_IN, FirstDate);
    RSDcmd.addParam("LastDate", RSDBP_IN, LastDate);
    rs = RsdRecordset(RSDcmd);
    RSDcmd.execute();

    return rsSelectValue(rs, V_MONEY, 0);
END;

/*Цикл по объектам обеспечения*/
//После завершения работы с этой функции необходимо DropFilter для EnsObj

MACRO GoNextEnsObj(FirstObj, EnsContract)
   IF (FirstObj)
       Ecneob.AddFilter("T_EnsContractId_Ref = " + EnsContract);
       Ecneob.rec.EnsContractId_Ref = EnsContract;
       Ecneob.rec.EnsObjectId_Ref = 0;
       IF ((GetGE (Ecneob)) AND (Ecneob.rec.EnsContractId_Ref == EnsContract))
            RETURN Loans_FindEnsObject (Ecneob.rec.EnsObjectId_Ref, EnsObj);
       END;
   ELSE
       IF (next((Ecneob) AND (Ecneob.rec.EnsContractId_Ref == EnsContract)))
           RETURN Loans_FindEnsObject (Ecneob.rec.EnsObjectId_Ref, EnsObj);
       END;
   END;
   RETURN FALSE;
END;

MACRO FindEnsType (EnsTypeID)
  EnsType.EnsTypeID = EnsTypeID;
  IF (GetEQ(EnsType))
    RETURN EnsType.EnsTypeName;
  ELSE
    RETURN "";
  END;
END;


/* История лимита выдачи (задолженности) */
MACRO GetLimRest (CreditNumber, Type, D)

    if(Type == TCLTR_LIMPAY)
        Type = TDR_LIMPAY;
    elif (Type == TCLTR_LIMDUTY)
        Type = TDR_LIMDUTY;
    end;
    RETURN LnSelectValue("SELECT t_Rest FROM dchlimhis_dbt a "
                                " WHERE a.t_CreditNumber_Ref = " + CreditNumber +
                                  " AND a.t_Type = " + Type +
                                  " AND a.t_Date = (SELECT max(t_Date) FROM dchlimhis_dbt b " +
                                                          " WHERE b.t_CreditNumber_Ref = " + CreditNumber +
                                                            " AND b.t_Type = "  + Type +
                                                            " AND b.t_Date <= " + SQLDate(D) + ")" +
                                  " AND a.t_CredOperID_Ref = (SELECT max(t_CredOperID_Ref) FROM dchlimhis_dbt c " +
                                                          " WHERE c.t_CreditNumber_Ref = " + CreditNumber +
                                                            " AND c.t_Type = "  + Type +
                                                            " AND c.t_Date <= " + SQLDate(D) + ")", V_MONEY);

END;


MACRO GetStrPart(s, n)
  VAR Res, Ind, Prom = TRIM(s), i = 1;
  WHILE (i < n)
    Ind = INDEX(Prom, ";");
    IF (Ind > 0)
      Prom = SUBSTR(Prom, Ind+1)
    ELSE
      Prom = ""
    END;
    i = i + 1
  END;
  Ind = INDEX(Prom, ";");
  IF (Ind > 0)
    Res = SUBSTR(Prom, 1, Ind-1)
  ELSE
    Res = Prom
  END;
  RETURN Res
END;

MACRO CalcLastPercDate(f, DutyID, Credit, ObjID, ObjN, RegID, TypeRateID)

    VAR Операции = TBFile ("crd_op.dbt",   "r", 1, "crd_op.dbt",   "loans.def");
    FILE CopStage ("copstage.dbt", "loans.def") key 1;
    RECORD d("duty_crd.dbt", "loans.def");

    VAR FoundPay:bool     = FALSE;
    VAR rs = NULL, cmd = NULL;
    VAR LastPercDate:date = Credit.RegDate;
    VAR ID_Ref:integer = 0;
    VAR RateID_Ref:integer = 0;
    VAR FlagBreak:bool = TRUE;

    VAR cmdStr = string("SELECT t_ID  FROM dlcusreg_dbt WHERE t_ObjectTypeID = " + string(ObjID) +
                                 " AND t_ObjectNumber  =  " + string(ObjN) +
                                 " AND t_RegID  = " + string(RegID));

    ID_Ref = LnSelectValue(cmdStr, V_INTEGER);
    LastPercDate = LnSelectValue("SELECT max(t_RestDate) FROM ddutyrest_dbt WHERE t_ID_REF =" + ID_Ref, V_DATE);

    IF (NOT FoundPay) RETURN LastPercDate END;

    FlagBreak = TRUE;

    ClearRecord(Duty);
    Duty.DutyID = DutyID;

    IF (NOT GetEQ(Duty))
        RETURN LastPercDate;
    END;

    cmd = RsdCommand(RslDefCon, "begin ? := loanskernel.getusrateid_forobject (?,?,?); end;" );

    cmd.addParam( "retval", RSDBP_RETVAL, V_INTEGER );

    cmd.addParam("objecttypeid", RSDBP_IN);
    cmd.addParam("objectnumber", RSDBP_IN);
    cmd.addParam("typerateid",   RSDBP_IN);
    
    cmd.Value("objecttypeid") = ObjID;
    cmd.Value("objectnumber") = ObjN;
    cmd.Value("typerateid")   = TypeRateID;
    
    cmd.execute();
    
    RateID_Ref = cmd.value(0);

    WHILE(GetEQ(Duty) AND FlagBreak)
        cmdStr = "SELECT max(t_PercDate) FROM dperc_day_dbt WHERE t_ID_REF =" + ID_Ref + " AND t_RATEID = " + RateID_Ref;
        LastPercDate = LnSelectValue(cmdStr, V_DATE);

        IF (Loans_FindParentDuty(Duty.DutyID, d))
            Duty.DutyID = d.DutyID;
        ELSE
            FlagBreak = FALSE;
        END;
    END;

    RETURN LastPercDate;
END;

/* Функция возвращает название удостоверения личности*/
MACRO GetPassportName(PassportType)
   ClearRecord(passport);
   passport.ITypeAlg = 938;
   passport.iNumberAlg = PassportType;
   IF (GetEQ(passport))
      RETURN trim(passport.szNameAlg);
   ELSE
      RETURN "";
   END;
END;


/* Функция возращает сумму прописью в формате:
   Сумма_цифрами (Сумма_основных_единиц_прописью) валюта_суммы сумма_дробных_единиц_цифрами название_дробных_единиц
   Если количество дробных единиц равно нулю, то сумма и название дробных единиц не выводится */
MACRO MoneyToMString(Sum:moneyL, SumExtCurCode)
   VAR rubkop= "", rub = "", kop = "", Srub= "", Skop= "", result = "";

   IF (ValType(SumExtCurCode) == V_UNDEF)
      RETURN "";
   END;

   result = int(double(Sum));
   /* Сумма прописью кредитного договора */
   rubkop = CurToStrAlt (Sum, rub, kop, SumExtCurCode);
   result = result + " (" + rub + ") ";

   Srub = Substr(rubkop, strlen(rub) + 2, Index(rubkop,kop) - strlen(rub) - 3);
   Skop = SubStr(rubkop, Index(rubkop,kop) + strlen(kop) + 1);

   IF (kop == "00") /* Если копеек ноль, то не выводим их*/
      kop = "";
      Skop = "";
   END;
   /* Название валюты */
   result = result + Srub + " " + kop + " " + Skop;

   RETURN result;
END;


/* Функция по полному имени возвращает сокращенное:
   Фамилия Имя Отчество --> Фамилия И. О.*/
MACRO GetShortFIO(FullFIO)
   VAR FullF = "", ShortFIO = "", ShortIO, ind = 0;

   IF (trim(FullFIO) == "")
      RETURN "";
   END;

   FullFIO = trim(FullFIO);
   ind = INDEX(FullFIO, " ");
   IF (ind > 0)
      FullF = Substr(FullFIO, 1, ind - 1);
      FullFIO = Substr(FullFIO, ind + 1);
   ELSE
      RETURN FullFIO;
   END;


   FullFIO = trim(FullFIO);
   IF (FullFio == "")
      RETURN FullF;
   END;

   ShortFIO = FullF;
   WHILE (FullFIO != "")
       ShortIO = Substr(FullFIO, 1, 1);
       ShortFIO = ShortFIO + " " + ShortIO + ".";
       ind = INDEX(FullFIO, " ");
       IF (ind > 0)
          FullFIO = Substr(FullFIO, ind);
          FullFIO = trim(FullFIO);
       ELSE
          FullFIO = "";
       END;
   END;

   RETURN ShortFIO;
END;


/* Функция возращает сумму прописью в формате:
   Сумма_цифрами (Сумма_прописью)
   Сумма_цифрами - округленная сумма с точностью до 2-х знаков */
MACRO NumAndStr(Num:moneyL, prec:integer)

   IF (ValType(prec) == V_UNDEF)
      prec = 2;
   END;

   IF (FloorL(Num) == Num) /* Целое число */
      RETURN string(int(Num)) + " (" + NumToStr(Num, "","","", TRUE, 0) + ")";
   END;
   /* Не целое число */
   RETURN string(Round(Num, prec):6:2) + " (" + NumToStr(Num, "","","", FALSE, prec) + ")";
END;



MACRO Int2Str(n, len)
   VAR s,s1;

   s = MkStr("0", len);
   s1 = String(n);
   StrSet(s,len-StrLen(s1)+1,s1);
   RETURN s;
END;


/* Функция получения ID аттрибута (значения группы GroupID), действующего по объекту на дату */
MACRO GetAttrID (ObjectType, ObjectID, GroupID, Дата)
    VAR sObjectID:string = Int2Str(ObjectID, 10);
    VAR rs = NULL;

    IF (ValType(Дата) == V_UNDEF)
       Дата = date(31,12,9999);
    END;

    rs = LnGetRecordSet(" SELECT t_attrid FROM dobjatcor_dbt" +
                        " WHERE t_objecttype = " + ObjectType +
                        " AND t_object = " + sObjectID +
                        " AND t_groupid = " + GroupID +
                        " AND t_general = 'X'" +
                        " AND t_validfromdate <= " + SQLDate(Дата) +
                        " order by t_validfromdate desc");
    IF (rs == NULL)  RETURN 0;    END;
    IF (rs.MoveNext())
        RETURN rs.value(0)
    END;
    RETURN 0;
END;

/*До этой функции можно не вызывать GetAttrID, поскольку она сама все может вычислять.
В таком случае параметр attrid надо или не передавать совсем. или передавать -1*/
MACRO GetNameAttr(objecttype, objectid, groupid, dt, attrid)
   VAR cmd;
   
   IF (VALTYPE(AttrID) == V_UNDEF)
       AttrID = -1;
   END;
   cmd = RsdCommand(RslDefCon, "begin ? := LoansKernel.getnameattr ( ?,?,?,?,? ); end;" );

   cmd.addParam( "retval", RSDBP_RETVAL, V_STRING );

   cmd.addParam("objecttype", RSDBP_IN);
   cmd.addParam("objectid",   RSDBP_IN);
   cmd.addParam("groupid",    RSDBP_IN);
   cmd.addParam("dt",         RSDBP_IN);
   cmd.addParam("attrid",     RSDBP_IN);

   cmd.Value("objecttype") = objecttype;
   cmd.Value("objectid")   = objectid;
   cmd.Value("groupid")    = groupid;
   cmd.Value("dt")         = dt;
   cmd.Value("attrid")     = attrid;

   cmd.execute();

   RETURN trim(cmd.value(0));
END;

/* Функция возвращает название организационно-правовой формы собственности
   на дату */
MACRO НазваниеОПФС(ClientID, Дата)
   return GetNameAttr(3, ClientID, 4, Дата);
END;


/* Функция возвращает название отрасли экономики на дату */
MACRO НазваниеОЭ(ClientID, Дата)
   return GetNameAttr(3, ClientID, 6, Дата);
END;

/* Функция возвращает количество полных месяцев между датами date1 и date2
   Если date1 < date2, то возвращаемое значение >= 0, иначе <=0 */
MACRO КоличествоМесяцев(date1, date2)

    VAR  months:integer = 0, d1:integer = 0, d2:integer = 0, m1:integer = 0, m2:integer = 0,
         y1:integer = 0, y2:integer = 0;

    DateSplit(Date1,  d1, m1, y1);
    DateSplit(Date2,  d2, m2, y2);

    months = (y2 - y1) * 12 + (m2 - m1);
    IF (d1 > d2) /* Последний месяц неполный, его не учитываем */
        months = months - 1;
    END;

    RETURN months;

END;

/* Возвращает название объекта аттрибута из группы GroupID, установленного по ObjectType, ObjectID на дату
   AttrID уже может быть задан, его можно не искать, а использовать переданный
*/
MACRO GetNameObject (ObjectType, ObjectID, GroupID, Дата, AttrID)
   return GetNameAttr(objecttype, objectid, groupid, Дата, AttrID);
END;

/*
Функция возвращает переменную часть операции формирования графика погашения.
Поиск операции может выполняться как по договору, так и по обязательству
*/
MACRO GetCalcGPay(ObjectType, ObjectID, CurCode, calcgpay)

   VAR calcgpayTmp = TRecHandler ("lgpayop.dbt", "loans.def");
   VAR crd_op      = TBFile      ("crd_op.dbt",  "r", 0, "crd_op.dbt", "loans.def");

   IF ((ValType(calcgpay) != V_STRUC) AND
       (ValType(calcgpay) != V_GENOBJ))
      RETURN FALSE;
   END;

   ClearRecord(calcgpay);
   ClearRecord(calcgpayTmp);

   IF ((ObjectType != LO_CREDIT) AND (ObjectType != LO_DUTY))
       RETURN FALSE;
   END;

   IF (NextOpSystType (TRUE, ObjectID, @crd_op, CS_RECALCGPAY, FALSE, CurCode, ObjectType, CF_COMPLIT))

      Loans_FindGPayOp(crd_op.rec.CredOperID, 0, calcgpayTmp);

      IF (Copy(calcgpay, calcgpayTmp))
         RETURN TRUE;
      END;

   END;

   RETURN FALSE;
END;

/*
Функция возвращает дату выноса на просрочку для последнего графика по
 обязательству или договору
   PayType = 0, для графика по ОД
   PayType = 1, для графика по %%
*/
MACRO GetArrearDate(ObjectType, ObjectID, CurCode, PayType)
   VAR   calcgpay = TRecHandler  ("lgpayop.dbt", "loans.def");

   IF (NOT GetCalcGPay(ObjectType, ObjectID, CurCode, calcgpay))
       RETURN 0;
   END;

   IF (PayType == 0)
      RETURN calcgpay.rec.PAY_ArrearDate;
   ELIF (PayType == 1)
      RETURN calcgpay.rec.PERC_ArrearDate;
   END;
   RETURN 0;
END;

/*
Функция возвращает дату первого платежа последнего графика по
обязательству или договору
   PayType = 0, дата первого платежа по ОД
   PayType = 1, дата первого платежа по %%
*/
MACRO GetPlanFirstDate(ObjectType, ObjectID, CurCode, PayType)

   VAR calcgpay = TRecHandler ("lgpayop.dbt", "loans.def");

   IF (NOT GetCalcGPay(ObjectType, ObjectID, CurCode, @calcgpay))
       RETURN date(0,0,0);
   END;

   IF (PayType == 0)
      RETURN calcgpay.rec.PAY_PlanFirstDate;
   ELIF (PayType == 1)
      RETURN calcgpay.rec.PERC_PlanFirstDate;
   END;
   RETURN date(0,0,0);
END;

// ОСТАТОК НА РЕГИСТРЕ
MACRO ОстатокНаРегистре(ВидОбъекта, НомерОбъекта, Тип, Дата)

   IF (ValType(Дата) == V_UNDEF)
       Дата = {curdate};
   END;

   // Лимит выдачи+задолженности ИЛИ Невозобновляемая КЛ ИЛИ Под лимит задолженности
   IF ((Тип == CF_CRLIN) OR (Тип == CF_CRLINNO) OR (Тип == CF_CRLINNEW))
      RETURN ОстатокРегистра(ВидОбъекта, НомерОбъекта, TDR_AVAILABLELIMIT,  Дата);
   ELIF ((ВидОбъекта == LO_KARTA)    OR
         (ВидОбъекта == LO_OVERDRAFT))
      RETURN ОстатокРегистра(ВидОбъекта, НомерОбъекта, TCLTR_LIMDUTY, Дата);
   // Гарантия ИЛИ Контргарантия
   ELIF ((Тип == CF_GUARANTEE) OR (Тип == CF_GUARANTEELINE))
      RETURN ОстатокРегистра(ВидОбъекта, НомерОбъекта, TDR_PAYEDGUARANTEE, Дата);
   END;

   RETURN $0;
END;

/* Количество дней с момента первого оборота по реистру */
MACRO CountDay(ObjectID, ObjectNumber, RegID, DateOp, Count)
   VAR lcusreg  = TBFile("lcusreg.dbt",  "r", 1, "lcusreg.dbt",  "loans.def");
   VAR dutyrest = TBFile("dutyrest.dbt", "r", 0, "dutyrest.dbt", "loans.def");

   lcusreg.Rewind();
   lcusreg.AddFilter("T_OBJECTTYPEID = " + ObjectID + " AND T_OBJECTNUMBER = " + ObjectNumber + " AND T_REGID = " + RegID);
   lcusreg.rec.OBJECTTYPEID = ObjectID;
   lcusreg.rec.OBJECTNUMBER = ObjectNumber;
   lcusreg.rec.REGID        = RegID;
   IF (lcusreg.GetEQ())
      dutyrest.Rewind();
      dutyrest.AddFilter("T_ID_REF = " + lcusreg.rec.ID);
      dutyrest.rec.ID_REF   = lcusreg.rec.ID;
      dutyrest.rec.RESTDATE = date(0,0,0);
      IF (dutyrest.GetGE())
         IF ((dutyrest.rec.RESTDATE + 1 - DateOp) > Count)
            RETURN TRUE;
         END;
      END;
      dutyrest.DropFilter();
   END;

   lcusreg.DropFilter();
   RETURN FALSE;
END;

/*  */
MACRO ФинПоложениеЗаемщика(ClientID : integer, FromDate : date)
   VAR party = TBFile("party.dbt", "r", 0, "party.dbt", "bank.def" );
   VAR OBJ_PARTY_GROUP_CHARACTER = 22;   /* Характер отношений с банком */
   VAR retval;
   VAR AttrID = 0;

   party.Rewind();
   party.Rec.PartyID = ClientID;
   IF (NOT party.GetEQ())
      RETURN 0;
   END;

   IF (valType(FromDate) == V_UNDEF)
       FromDate = date(31,12,9999);
   END;

   IF (NOT GetMainObjAttr(retval, OBJTYPE_PARTY, UniID(party, OBJTYPE_PARTY), OBJ_PARTY_GROUP_CHARACTER, AttrID, 0, 0, FromDate))
      RETURN 0;
   END;
   RETURN AttrID;
END;

/*  */
MACRO КачествоОбслуживанияДолга (ObjectNumber, OperDate)
   PRIVATE FILE Credit  ("credit_c.dbt", "loans.def");
   PRIVATE VAR {GROUP_MODE};

   VAR Value: integer;

   Value =
   CRSDCommand("SELECT l1.T_VALUE FROM DLHQUASRV_DBT l1 WHERE l1.T_CREDITNUMBER_REF = ? AND l1.T_DATE = " +
              "(SELECT MAX(l2.T_DATE) FROM DLHQUASRV_DBT l2 WHERE l2.T_CREDITNUMBER_REF = ? AND l2.T_DATE <= ?)",             
              "a1", ObjectNumber,
              "a2", ObjectNumber,
              "a3", OperDate,
              V_INTEGER);

   IF (Value > 0)
      RETURN Value;
   ELSE
      credit.CreditNumber = ObjectNumber;
      IF (NOT GetEQ (credit))
         PrintLn ("Качество обслуживания: не найден кредитный договор с ID = "+ObjectNumber);
      ELSE
         IF (NOT {GROUP_MODE})
            PrintLn ("Не определено качество обслуживания по кредитному договору/карте "+credit.UsCreditNumber+" на дату "+OperDate);
         END;
      END;
   END;

   RETURN -1;
END;

/* Получить вид объекта, алгоритм различен для 4го и 20го релиза */
MACRO GetObjectID_FromCrdKind(Crd_kind: integer)
   RETURN Crd_kind;
END;


/*
Функция возвращает сумму недоплат по операции
   CredOperID - ID операции
   DS_Type    - вид задолженности
*/
MACRO НедоплатыПоОперации(CredOperID, DS_Type)

   RETURN LnSelectValue("SELECT t_UnderPaySum FROM dplanfact_dbt WHERE t_CredOperID_Ref = " + CredOperID + " AND t_DutyStageID_Ref = " + DS_Type, V_MONEY);
END;


/*
Функция проверки вхождения пользователя в группу и филиал
   iGroupNum - номер группы
   iFnCash   - номер филиала
   iOper     - номер пользователя
Возвращает:
   TRUE      - если пользователь входит в группу iGroupNum
   FALSE     - пользователь не входит в группу iGroupNum
Проверки выполняются только для пользователя с правом доступа Операционист и Начальник отдела.
Для начальник отдела учитывает диапазон групп его операционистов.

ПРИМЕЧАНИЕ. Проверка вхождения в филиал отключена (см. ф-цию LoansUserFilter.CheckUserAccess)
*/
MACRO CheckUserAccess(iGroupNum, iFnCash, iOper)

   RETURN (RunStoredFunc("LoansUserFilter.CheckUserAccess", V_INTEGER, NULL, iGroupNum, iFnCash, iOper) != 0);
END;



/*
Функция поиска недоплат по последней выполненной операции погашения или просрочки
    ObjectType   - Вид объекта
    ObjectNumber - ID объекта
    DS_type      - Вид задолженности по процентам
Возвращает сумму недоплат по процентам
*/
MACRO НедоплатыПроцентов(ObjectType, ObjectNumber, DS_Type)
   VAR DS_PercType = 0;

   IF (DS_Type == DS_ADDPERC)
      DS_PercType = DS_PERC;
   ELIF (DS_Type == DS_ADDNOOVCRDPERCENT)
      DS_PercType = DS_NOOVCRDPERCENT;
   END;

   RETURN LnSelectValue("SELECT t_UnderPaySum FROM DPLANFACT_DBT " +
                                "WHERE   t_ObjectTypeID_Ref = " + ObjectType +
                                    "AND t_ObjectNumber_Ref = " + ObjectNumber +
                                    "AND ( (t_DutyStageID_Ref  = " + DS_Type +
                                    "       AND (t_SystemOperationID_Ref = " + CS_DUTY +
                                    "         or t_SystemOperationID_Ref = " + CS_EXP + ") " +
                                    "      )" +
                                    "    OR (t_SystemOperationID_Ref = " + CS_PERC +
                                            "AND t_DutyStageID_Ref = " + DS_PercType +
                                            ")" +
                                         ")" +
                                    "ORDER BY t_CredOperID_Ref DESC", V_MONEY);
END;

MACRO GetAccNumEx(ClientID: integer, DateOper: date, AttrID, LegalForm, IsEmployer, PartyName, PropertyForm)
   VAR accnum = -1;

   IF (LegalForm == 2)
      /* индивидуальный предприниматель */
      IF (trim(IsEmployer) == "X")
          PropertyForm = 15;
      END;
   END;

   /* форма собственности */
   if (VALTYPE(PropertyForm) == V_UNDEF)
       PropertyForm = int(GetNameObject(3, ClientID, 1, DateOper, AttrID));
   END;

   IF (PropertyForm == 0)
      LoansError("Не задана форма собственности! " + PartyName);
      RETURN 0;
   END;

   IF (PropertyForm < 14)
      accnum = (PropertyForm - 1); //0..12
   ELIF (PropertyForm == 14)
      accnum = 15;
   ELIF (PropertyForm == 15)
      accnum = 13;
   ELIF (PropertyForm == 16)
      accnum = 16;
   ELIF (PropertyForm == 17)
      accnum = 14;
   END;

   RETURN accnum;
END;

/*
   Функция возвращает форму собстенности заемщика
 */
MACRO GetAccNum(ClientID: integer, DateOper: date, accnum: integer)
   VAR party = TBFile ("party.dbt", 0, "r");
   var cmdstr:string;
   var RSDcmd : object = null;
   var rs : object = null;

cmdstr =
"SELECT TO_NUMBER(DECODE (propform, " +
"               '14', '16'," +
"               '15', '14', " +
"               '16', '17', " +
"               '17', '15', " +
"               propform    " +
"              )) - 1 as propform " +
"  FROM (SELECT NVL "+
"                  ((SELECT DECODE (t_notresident, "+
"                                   'X', '16', "+
"                                   DECODE (t_isemployer, 'X', '15', '17') "+
"                                  ) AS propform "+
"                      FROM dparty_dbt, dpersn_dbt "+
"                     WHERE t_partyid = ? "+
"                       AND t_legalform = 2 "+
"                       AND t_personid = t_partyid), "+
"                   (SELECT TRIM (t_nameobject) AS propform "+
"                      FROM dobjattr_dbt atr, dobjatcor_dbt cor "+
"                     WHERE atr.t_objecttype = 3 "+
"                       AND atr.t_groupid = 1 "+
"                       AND atr.t_attrid = cor.t_attrid "+
"                       AND cor.t_attrid BETWEEN 1 AND 17 "+
"                       AND cor.t_objecttype = atr.t_objecttype "+
"                       AND cor.t_object = TRIM (TO_CHAR (?, '0000000000')) "+
"                       AND cor.t_groupid = atr.t_groupid "+
"                       AND ? BETWEEN cor.t_validfromdate "+
"                                  AND cor.t_validtodate "+
"                       AND cor.t_general = 'X') "+
"                  ) as propform "+
"          FROM DUAL) ";


   RSDcmd = RsdCommand (RslDefCon, cmdstr);
   RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value (0) = ClientID;
   RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value (1) = ClientID;
   RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value (2) = DateOper;

   rs = RsdRecordset (RSDcmd);
   RSDcmd.execute();

   if ((rs != null) and (rs.MoveNext()) and (rs.value(0, null, V_INTEGER) != null))
      SetParm(2, rs.value(0, null, V_INTEGER));
   else        
   party.rec.PartyID = ClientID;
   IF (NOT party.GetEQ())
      LoansError("Не найден заемщик: №" + ClientID);
      END;      
      RETURN FALSE;
   end;
   RETURN TRUE;
END;
////////////////////////////////////////////////////////////////////////////////

MACRO DutyInCases(ObjectID, ObjectNumber, OperDate, Type, CaseNumber)

   VAR cmd;

   if (VALTYPE(CaseNumber) == V_UNDEF)
        CaseNumber = -1;
   end;

   cmd = RsdCommand(RslDefCon, "begin ? := LoansKernel.dutyincases ( ?,?,?,?,? ); end;" );

   cmd.addParam( "retval", RSDBP_RETVAL, V_INTEGER );

   cmd.addParam("ObjectID",     RSDBP_IN, ObjectID    );
   cmd.addParam("ObjectNumber", RSDBP_IN, ObjectNumber);
   cmd.addParam("OperDate",     RSDBP_IN, OperDate    );
   cmd.addParam("Type",         RSDBP_IN, Type        );
   cmd.addParam("CaseNumber",   RSDBP_IN, -1          );

   cmd.execute();

   RETURN cmd.value(0);
END;


MACRO ОстатокРегистраДляЭлементаРасчетнойБазы(ВидОбъекта, НомерОбъекта, ТипВыдачи, Дата, ТипПортфеля)

   IF(ТипПортфеля == 1)
       IF(ВидОбъекта == LO_CREDIT)
           IF((ТипВыдачи == CF_CRLIN) OR (ТипВыдачи == CF_CRLINNEW))
               RETURN ОстатокРегистра(ВидОбъекта, НомерОбъекта, TCLTR_LIMDUTY, Дата);
           ELSE
               RETURN ОстатокРегистра(ВидОбъекта, НомерОбъекта, TDR_MAINREST, Дата) +
                      ОстатокРегистра(ВидОбъекта, НомерОбъекта, TDR_EXPREST, Дата) +
                      ОстатокОткрытыхСО (НомерОбъекта, TDR_MAINREST, Дата)+
                      ОстатокОткрытыхСО (НомерОбъекта, TDR_EXPREST, Дата);
           END;
       ELIF((ВидОбъекта == LO_KARTA) OR
            (ВидОбъекта == LO_OVERDRAFT))
           RETURN KartaLimit(ВидОбъекта, НомерОбъекта, Дата);
       ELIF(ВидОбъекта == LO_GUARANTEE)
           RETURN ОстатокРегистра(ВидОбъекта, НомерОбъекта, TDR_PAYEDGUARANTEE, Дата);;
       END;
   ELSE
       ОстатокНаРегистре(ВидОбъекта, НомерОбъекта, ТипВыдачи, Дата);
   END;

   RETURN $0;
END;

MACRO КоличественныеОграничения(ObjectNumber, OperDate)
   VAR cmd;

   cmd = RsdCommand(RslDefCon, "begin ? := LoansKernel.numlimitation ( ?,? ); end;" );

   cmd.addParam( "retval", RSDBP_RETVAL, V_INTEGER );

   cmd.addParam("ObjectNumber", RSDBP_IN, ObjectNumber);
   cmd.addParam("OperDate",     RSDBP_IN, OperDate    );

   cmd.execute();

   RETURN cmd.value(0);
end;

/////////////////////////////////////////////////////////////////////////////////
MACRO НадежныйДоговор( ObjectNumber: integer, ObjectType: integer, DateOP: date)
   VAR cmd;

   cmd = RsdCommand(RslDefCon, "{ ? = CALL LoansKernel.reliableobject ( ?,?,? ) }" );

   cmd.addParam( "retval", RSDBP_RETVAL, V_INTEGER );

   cmd.addParam("objtype",     RSDBP_IN, ObjectType  );
   cmd.addParam("objn" ,       RSDBP_IN, ObjectNumber);
   cmd.addParam("dt",          RSDBP_IN, DateOP      );

   cmd.execute();

   RETURN cmd.value(0);
END;
///////////////////////////////////////////////////////////////////////////////////
macro IsLastWorkDay (check_date:date)
   var cmd;

   cmd = RsdCommand(RslDefCon, "{ ? = CALL LoansKernel.IsLastWorkDay (?) }" );

   cmd.addParam("retval", RSDBP_RETVAL, V_INTEGER);
   cmd.addParam("check_date", RSDBP_IN, check_date);

   cmd.execute();

   return cmd.value(0);

end;
///////////////////////////////////////////////////////////////////////////////////
macro ReliableKKS (KKS: integer)
   var isReliableKKS : bool = false;
   var cmd;

   cmd = RsdCommand(RslDefCon, "{ ? = CALL LoansKernel.ReliableKKS (?) }" );

   cmd.addParam("retval", RSDBP_RETVAL, V_INTEGER);
   cmd.addParam("KKS", RSDBP_IN, KKS);

   cmd.execute();

   if (cmd.value(0) == 1)
      isReliableKKS = true;
   else
      isReliableKKS = false;
   end;

   return isReliableKKS;
end;
///////////////////////////////////////////////////////////////////////////////////

MACRO CheckMCPeriod(HighBound, HighBoundUnit, IsHighInclude, BegDate, EndDate, PeriodEndDate:@date, ErrState:@bool, flag)
    VAR FoundPeriod = false;
    var BegDateD : integer, BegDateM: integer, BegDateY: integer;

    DateSplit(BegDate, BegDateD, BegDateM, BegDateY);
    PeriodEndDate = BegDate;

    if  (HighBoundUnit == TMCPERIOD_YEAR)
         BegDateY = BegDateY + HighBound;
         if ((BegDateM == 2) and (BegDateD == 29 ))
              BegDateD=1;
              BegDateM=3;
              PeriodEndDate = Date (BegDateD, BegDateM, BegDateY);
                 else                                                  
            PeriodEndDate = Date (BegDateD, BegDateM, BegDateY);
             end;
                 
    elif (HighBoundUnit == TMCPERIOD_MONTH)
         PeriodEndDate = DateAfterCalenMonths(BegDate, HighBound);
    elif (HighBoundUnit == TMCPERIOD_DAY)
         PeriodEndDate = PeriodEndDate + HighBound;
    else
         ErrState = true;
    end;

    if (trim(IsHighInclude) == "")
         PeriodEndDate = PeriodEndDate - 1;
    end;

    if (PeriodEndDate >= EndDate)
        FoundPeriod = true;
    end;

    if(flag)
        if(FoundPeriod)
            DateSplit(EndDate, BegDateD, BegDateM, BegDateY);
            PeriodEndDate = EndDate;

            if  (HighBoundUnit == TMCPERIOD_YEAR)
                 BegDateY = BegDateY - HighBound;
                 PeriodEndDate = Date (BegDateD, BegDateM, BegDateY);
            elif (HighBoundUnit == TMCPERIOD_MONTH)
                 PeriodEndDate = DateAfterCalenMonths(EndDate, -HighBound);
            elif (HighBoundUnit == TMCPERIOD_DAY)
                 PeriodEndDate = PeriodEndDate - HighBound;
            end;

            if (trim(IsHighInclude) == "")
                 PeriodEndDate = PeriodEndDate + 1;
            end;

            if (PeriodEndDate < BegDate)
                PeriodEndDate = BegDate;
            end;
        else
            PeriodEndDate = BegDate;
        end;
    end;
    return FoundPeriod;
END;

MACRO GetPeriodEndDateReport(ID, GrpUrgent, RegDate, ReturnDate)
    VAR PeriodEndDate:date = date(0,0,0);
    VAR stat = 0;
    VAR FoundPeriod = false;
    VAR ErrState = false;

    if (VALTYPE(ID) == V_UNDEF)
        ID = 0;
    end;

    if (VALTYPE(GrpUrgent) == V_UNDEF)
        GrpUrgent= 0;
    end;

    if(ID == 0)
        mcper.Clear;
        mcper.AddFilter("t_GroupNum = " + GrpUrgent);
        mcper.rec.GroupNum = GrpUrgent;
        stat = mcper.GetGE;
        while((stat) and (not FoundPeriod))
            if (mcper.rec.HighBound != 0)
                FoundPeriod = CheckMCPeriod(mcper.rec.HighBound, mcper.rec.HighBoundUnit, mcper.rec.IsHighInclude, RegDate, ReturnDate, @PeriodEndDate, @ErrState, true);
            else // Верхняя граница периода не задана, период подходит (для всех типов выдач)
                FoundPeriod = true;
                PeriodEndDate = RegDate;
            end;
            if(not FoundPeriod)
                stat = mcper.next;
            end;
        end;
        mcper.DropFilter;
    else
        mcperi.Clear;
        mcperi.AddFilter("t_ID = " + ID);
        mcperi.rec.ID = ID;
        stat = mcperi.GetEQ;
        if(stat)
            FoundPeriod = CheckMCPeriod(mcperi.rec.HighBound, mcperi.rec.HighBoundUnit, mcperi.rec.IsHighInclude, RegDate, ReturnDate, @PeriodEndDate, @ErrState, true);
        end;
        mcperi.DropFilter;
    end;

    return PeriodEndDate;
END;

MACRO ОрганизационноПравоваяФормаИлиФормаСобственности(ClientID : integer, FromDate: date, OPF: bool)
   VAR party = TBFile("party.dbt", "r", 0, "party.dbt", "bank.def" );
   VAR retval;
   VAR AttrID = 0;
   VAR RSDcmd, rs;
   VAR OBJ_PARTY_GROUP_CHARACTER;

   party.Rewind();
   party.Rec.PartyID = ClientID;
   IF (NOT party.GetEQ())
      RETURN 0;
   END;

   IF (valType(FromDate) == V_UNDEF)
       FromDate = date(31,12,9999);
   END;

   IF(OPF)
       OBJ_PARTY_GROUP_CHARACTER = 4;
   ELSE
       OBJ_PARTY_GROUP_CHARACTER = 3;
   END;

   IF ((GetMainObjAttr(retval, OBJTYPE_PARTY, UniID(party, OBJTYPE_PARTY), OBJ_PARTY_GROUP_CHARACTER, AttrID, 0, 0, FromDate)) and (retval == 0))
         return GetNameAttr(OBJTYPE_PARTY, 0, OBJ_PARTY_GROUP_CHARACTER, FromDate, AttrID);
   END;
   RETURN "";
END;

// TFS. преобразование даты для XML
MACRO Cvt(Dt)
   VAR strOpDate = "", v1, v2, v3, sv1, sv2;
   DateSplit(Dt, v1, v2, v3);
   IF (v1 < 10)
      sv1 = "0"+v1;
   ELSE
      sv1 = v1;
   END;

   IF (v2 < 10)
      sv2 = "0"+v2;
   ELSE
      sv2 = v2;
   END;

   RETURN v3+"-"+sv2+"-"+sv1+"Z";
END;

MACRO RSL_РасчетГрафикаПроцентов(RateID: integer, bd: date, ed: date, Rate: doubleL, ObjectTypeID: integer, ObjectID: integer, RoundOffError)
   VAR CMD = NULL;

   cmd = RsdCommand(RslDefCon, "BEGIN ? := LoansPercent.RSO_CalcPlanPay ( ?,?,?,?,?,?,?,? ); END;" );

   cmd.addParam("retval",  RSDBP_RETVAL, V_NUMERIC); 
   cmd.addParam("rateid",  RSDBP_IN);    cmd.value ("rateid")  = RateID;
   cmd.addParam("bd",      RSDBP_IN);    cmd.value ("bd")      = bd;
   cmd.addParam("ed",      RSDBP_IN);    cmd.value ("ed")      = ed;
   cmd.addParam("rateval", RSDBP_IN);    cmd.value ("rateval") = Rate;
   cmd.addParam("objid",   RSDBP_IN);    cmd.value ("objid")   = ObjectTypeID;
   cmd.addParam("objn",    RSDBP_IN);    cmd.value ("objn")    = ObjectID;
   cmd.addParam("INR",     RSDBP_IN);    cmd.value ("INR")     = RoundOffError;
   cmd.addParam("OUTR",    RSDBP_OUT, V_DECIMAL); cmd.value ("OUTR") = RoundOffError;

   cmd.execute;

   RoundOffError = cmd.Value(8, NULL, V_DECIMAL);

   setParm(6, RoundOffError);

   RETURN cmd.Value(0, NULL, V_MONEY);
END;

// Преобразования в XML
MACRO XMLIsBool(VAL)
   IF (ValType(VAL) == V_BOOL) 
      IF (Val == TRUE)
         RETURN "true";
      ELSE
         RETURN "false";
      END;
   ELSE
      RETURN "<NULL/>";
   END;
END;

MACRO XMLisDate(VAL)
   VAR day = 0, mon = 0, year = 0,
       s_day = "00", s_mon = "00";

   IF ((ValType(VAL) != V_DATE) OR (VAL == date(0,0,0)))
      RETURN "<NULL/>";
   ELSE
      DateSplit ( VAL, day, mon, year );
      IF (DAY < 10)
         s_day = "0" + day;
      ELSE
         s_day = day;
      END;

      IF (mon < 10)
         s_mon = "0" + mon;
      ELSE
         s_mon = mon;
      END;

      RETURN "<date>" + YEAR + "-" + s_mon + "-" + s_day + "Z</date>"
   END;
END;

MACRO XMLisDouble(VAL: double)
   VAR iVal = int(VAL), S: string = VAL, i = 0;

   IF (iVal == VAL)
      RETURN iVal;
   END;
   // Отбрасываем нули справа
   FOR (I, StrLen(string(VAL)), 0, -1)
      // Ищем первый не нулевой символ
      IF (SubStr(S, I, 1) != "0")
         BREAK;
      END;
   END;

   RETURN SubStr(S, 1, I);
END;

// Добавляем нолики
MACRO XMLisMoney(VAL: money)
   RETURN VAL+"00";
END;

macro GetOptnOpForObject(objid:integer, objn:integer, typeop:integer, dutystage:integer)
            var RSDcmd = RsdCommand (RslDefCon, "BEGIN ? := RSI_Loans_Additional_Algo.getoptnop_rec ( ?,?,?,?,? ); END;");
            RSDcmd.addParam ("stat", RSDBP_RETVAL, V_INTEGER);
            RSDcmd.addParam ("ObjK",   RSDBP_IN); RSDcmd.value ("ObjK")   = objid;
            RSDcmd.addParam ("ObjN",   RSDBP_IN); RSDcmd.value ("ObjN")   = objn;
            RSDcmd.addParam ("TypeOp", RSDBP_IN); RSDcmd.value ("TypeOp") = typeop;
            RSDcmd.addParam ("DS",   RSDBP_IN);   RSDcmd.value ("DS")     = dutystage;
            RSDcmd.addParam ("OptnOpID",   RSDBP_OUT, V_INTEGER);  
            RSDcmd.execute ();

            return RSDcmd.value ("OptnOpID");
onError()
return 0;
end;

/* 
 Функция получения типа остатка тарифа. Если передан экземпяр тарифа то используем его.
 Если передан вид тарифа то используем его для поиска экземляра. 
Возвращает 1 - входящий остаток, 2 - исходящий. 
*/
macro ПолучитьТипОстаткаТарифа(ObjID, ObjN, TrffID, TrffTypeID)
   var TypeRest = 0;

   if (TrffTypeID != null)
      // третий параметр игнорируем и и спользуем TrffTypeID для поиска экземпляра тарифа
      TrffID = CRsdCommand ("select t_rateid_ref  " + 
                           "   from dlcusrate_dbt " +
                            " where t_objectid_ref   = ? and " +
                                  " t_credobjid_ref  = ? and "+
                                  " t_typerateid_ref = ? ",
                             "p1", ObjID,
                             "p2", ObjN,
                             "p3", TrffTypeID,
                           V_INTEGER
                          );
   end;

   TypeRest = CRsdCommand ("select lctu.t_typerest " + 
                           "  from dlcusrate_dbt lcur, " +
                                 " dlctypuse_dbt lctu  " +
                           " where lcur.t_rateid_ref = ? and " +
                                 " lcur.t_typerateid_ref = lctu.t_typerateid and "+
                                 " lcur.t_credobjid_ref  = ? and "+
                                 " lcur.t_objectid_ref   = ? ",
                             "p1", TrffID,
                             "p2", ObjID,
                             "p3", ObjN,
                           V_INTEGER
                          );
   return TypeRest;  
end;

macro ПолучитьТипАлгоритмаТарифа(Date, TrffID)
   var Calendar = 0;

   Calendar = CRsdCommand ("select t_calendar from dtrffvalue_dbt " +
                           " where t_trffvalueid = " + 
                                 " (select t_id " +
                                    " from (select t_id from dlchistry_dbt " +
                                           " where t_rateid_ref = ? and " +
                                                 " t_ratedate  <= ? and " +
                                                 " t_ratestate  = ? order by t_id desc "+
                                           ") " + 
                                   " where rownum = 1) ",
                           "p1", TrffID,        
                           "p2", Date,
                           "p3", CF_CARRY,
                           V_INTEGER
                          );

   return Calendar;
end;

MACRO CalcGroupPercent(OpDate: date, CalcEndDate: date, CalcGraph: integer)
   VAR RSDcmd;

   BegAction(1, "Расчет задолженности. Ждите, это может занять несколько минут.", false);

   // Основной долг рассчитывается теперь отдельно от всех остальных ВЗ
   RSDcmd = RsdCommand(RslDefCon, "begin Loansfillpayment.CalcPercentGroup (?, ?, ?); end;");
   RSDcmd.addParam("opdate",  RSDBP_IN);  RSDcmd.value("opdate") = OpDate;
   RSDcmd.addParam("cldate",  RSDBP_IN);  RSDcmd.value("cldate") = CalcEndDate;
   RSDcmd.addParam("graph",   RSDBP_IN);  RSDcmd.value("graph")  = CalcGraph;

   RSDcmd.execute();
   RSDcmd = null;

   EndAction(1);
END;
//Преобразование валюты для RS-BURS
//При необходимости корректировать для использования FI_CODE|ISO_NUMBER
macro getCurISOl( id,err)
var iso;
var isIntMode = false;
err = 0;   
VAR rs = NULL;
if(VALTYPE(id)== V_INTEGER)
        isIntMode = true;
        rs = LnGetRecordset("SELECT FIN.T_ISO_NUMBER  FROM dfininstr_dbt fin   WHERE  FIN.T_FIID = " +id, TRUE);
        IF(rs != NULL)
               rs.Command.NullConversion = TRUE;
       END;
        IF ((rs != NULL) AND rs.MoveNext AND (rs.value(0, NULL, V_STRING) != NullVal) AND (ValType(rs.value(0, NULL, V_STRING)) != V_UNDEF))
           iso =  rs.value(0, NULL, V_STRING);
       else
          iso =""; err = -1;
        END;
end;
if(VALTYPE(id)== V_STRING)
       isIntMode = false;
        rs = LnGetRecordset("SELECT FIN.T_FIID  FROM dfininstr_dbt fin   WHERE  FIN.T_ISO_NUMBER = '" +trim(id)+"'", TRUE);
        IF(rs != NULL)
               rs.Command.NullConversion = TRUE;
       END;
        IF ((rs != NULL) AND rs.MoveNext AND (rs.value(0, NULL, V_INTEGER) != NullVal) AND (ValType(rs.value(0, NULL, V_INTEGER)) != V_UNDEF))
           iso =  rs.value(0, NULL, V_INTEGER);
       else
          iso =-1; err = -1;
        END;
end;
return iso;
onError
    err = -1;
    if( isIntMode)
            return -1;
    else
            return "";
    end; 
end;


// Добавляет записи во временную таблицу
MACRO ДобавитьПараметры(OperNumber, ParmName: string, Values)
   VAR RS;

   IF (ValType(Values) == V_DATE)
      // Дату приводим к формату
      RS = RSDCommand(RslDefCon, "INSERT INTO DPARAM_TMP (T_OPERNUMBER, T_PARMNAME, T_TYPE, T_VALUE) VALUES (?, ?, ?, UTL_RAW.CAST_TO_RAW(TO_CHAR(?, 'dd.mm.yyyy')))");
   ELSE
      RS = RSDCommand(RslDefCon, "INSERT INTO DPARAM_TMP (T_OPERNUMBER, T_PARMNAME, T_TYPE, T_VALUE) VALUES (?, ?, ?, UTL_RAW.CAST_TO_RAW(?))");
   END;

   // Тип BOOL преобразуем в INT
   IF (ValType(Values) == V_BOOL)
      IF (Values)
         Values = 1;
      ELSE
         Values = 0;
      END;
   END;

   RS.AddParam("p1", RSDBP_IN); RS.Value("p1") = OperNumber;
   RS.AddParam("p2", RSDBP_IN); RS.Value("p2") = ParmName;
   RS.AddParam("p3", RSDBP_IN); RS.Value("p3") = ValType(Values);
   RS.AddParam("p4", RSDBP_IN); RS.Value("p4") = Values;

   RS.Execute();
END;

// превращает сумму Summ в строку, с учетом необязательных параметров:
// Precision - количество знаков после запятой (0 .. 4)
// Scale - масштаб
// NeedApostrophe - необходимость вывода апострофа
macro MoneyToString( Summ:money, Precision:integer, 
                     Scale:integer, NeedApostrophe:bool ):string
   var StrOut = "";

   if( ValType( Precision ) == V_UNDEF ) 
      Precision = 2;
   end;

   if( ValType( Scale ) == V_UNDEF ) 
      Scale = 1;
   end;

   if( ValType( NeedApostrophe ) == V_UNDEF ) 
      NeedApostrophe = false;
   end;
   if( NeedApostrophe )
      if( Precision == 0 )
         StrOut = String( double( Summ ) / ( Scale ):0:0:a );
      elif( Precision == 1 )
         StrOut = String( double( Summ ) / ( Scale ):0:1:a );
      elif( Precision == 2 )
         StrOut = String( double( Summ ) / ( Scale ):0:2:a );
      elif( Precision == 3 )
         StrOut = String( double( Summ ) / ( Scale ):0:3:a );
      elif( Precision >= 4 )
         StrOut = String( double( Summ ) / ( Scale ):0:4:a );
      end;
   else                        
      if( Precision == 0 )
         StrOut = String( double( Summ ) / ( Scale ):0:0 );
      elif( Precision == 1 )
         StrOut = String( double( Summ ) / ( Scale ):0:1 );
      elif( Precision == 2 )
         StrOut = String( double( Summ ) / ( Scale ):0:2 );
      elif( Precision == 3 )
         StrOut = String( double( Summ ) / ( Scale ):0:3 );
      elif( Precision >= 4 )
         StrOut = String( double( Summ ) / ( Scale ):0:4 );
      end;
   end;

   return StrOut;
end;

//Вызов функции расчет графика
//ObjID тип объекта
//ObjN номер объекта
//GraphKindIdRef индификатор графика
//OperDate дата операции
//Контекст
//ContextType всегда должен быть CN_Graph
MACRO CalcGraph(ObjID,ObjN,GraphKindIdRef,OperDate,ContextB,ContextType)
   VAR retval = 0;
   var RSDcmd = RsdCommand(RslDefCon, "BEGIN ?:= RSI_LOANSGRAPHKIND.CalcPlanPay(?, ?, ?, ?, ?, ?); END;");
   RSDcmd.addParam("retval", RSDBP_OUT, retval);
    
   RSDcmd.addParam("ObjID",           RSDBP_IN, ObjID);
   RSDcmd.addParam("ObjN",            RSDBP_IN, ObjN);
   RSDcmd.addParam("GraphKindIdRef",  RSDBP_IN, GraphKindIdRef);
   RSDcmd.addParam("OperDate",        RSDBP_IN, OperDate);
   RSDcmd.addParam("ContextB",        RSDBP_IN, 0);
   RSDcmd.addParam("ContextType",     RSDBP_IN, CN_Graph);  

   RSDcmd.execute();
   return retval;
END;

//Коректировака дат с учетом выходных
//expday 
// 1 любой
//2 следующий рабочий 
//3 предыдущий рабочий 
 
//dateOp для коректировки
 macro CorrectDateOnWork(expday,dateOp)
              var retval = date(0,0,0);
              var RSDcmd = RsdCommand(RslDefCon, "BEGIN ?:= loanskernel.CorrectDateOnWork(?, ?); END;");
               RSDcmd.addParam ("retval", RSDBP_RETVAL, V_DATE);
               RSDcmd.addParam("expday",           RSDBP_IN, expday);
               RSDcmd.addParam("dateOp",           RSDBP_IN, dateOp);
               RSDcmd.execute();
               retval = RSDcmd.value ("retval");
               return retval;
end; //CorrectDateOnWork