import TOTAL, RSBUS_CHECK,"rsbus_structs.mac","rsbus_checkusr.mac";


// Флаг, отключающий проверку переданных данных

//private const SKIP_CHECK = FALSE;

//номер сервиса согласно списоку сервисов описананых в rsbus_checkusr.mac
private const NumServ:integer = NumServ_InsertPayPlan; 

var credID:integer, OpDate:date, PlanPay:TArray = TArray(), Comiss:TArray = TArray();
private var ErrManager:CErrManager;
private record credContr(credit_c);

macro ReadBusObj(BusTPay:TArray, BusTComiss:TArray)
   var i:integer, j:integer;
   var PlanPayRec:TPay;
   var ComissRec:TComiss, ComissPay:TComissPay;

   // Заполним данные по ГП
   PlanPay.size = 0;
   IF ((BusTPay != NULL) AND (BusTPay[0] != NULL))
      FOR (i, 0, BusTPay.size - 1, 1)
         PlanPayRec = TPay();

         PlanPayRec.payDate    = BusTPay[i].payDate;

         PlanPayRec.expDate    = BusTPay[i].expDate;
         IF ((PlanPayRec.expDate == NULL) OR (PlanPayRec.expDate == date(0,0,0)))
            PlanPayRec.expDate  =  PlanPayRec.payDate;
         END;
         PlanPayRec.paySum     = BusTPay[i].paySum;
         PlanPayRec.percentSum = BusTPay[i].percentSum;

         PlanPay[i] = PlanPayRec;
      END;
   END;   

   // Заполним данные по графикам комиссий
   Comiss.size = 0;
   IF ((BusTComiss != NULL) AND (BusTComiss[0] != NULL))
      FOR (i, 0, BusTComiss.size - 1, 1)
         ComissRec = TComiss();
         ComissRec.type = BusTComiss[i].type;
         ComissRec.sum  = BusTComiss[i].sum;
         ComissRec.comissPay.size = 0;

         j = 0;
         IF ((BusTComiss[i].comissPay != NULL) AND (BusTComiss[i].comissPay[0] != NULL))
            WHILE (j < BusTComiss[i].comissPay.size)   
               ComissPay = TComissPay();

               ComissPay.payDate   = BusTComiss[i].comissPay[j].payDate;
               ComissPay.expDate   = BusTComiss[i].comissPay[j].expDate;
               IF ((ComissPay.expDate == NULL) OR (ComissPay.expDate == date(0,0,0)))
                  ComissPay.expDate  =  ComissPay.payDate;
               END;
               ComissPay.comissSum = BusTComiss[i].comissPay[j].comissSum;

               ComissRec.comissPay[j] = ComissPay;
              
               j = j + 1;
            END;
         END;

         //если не переданы записи по датам, график должен быть построен на основе ГП суммами ComissRec.sum.
         IF ((j == 0) OR (BusTComiss[i].comissPay[0] == NULL))
            IF ((ComissRec.sum != NULL) AND (ComissRec.sum >= 0))
               FOR (j, 0, PlanPay.size - 1, 1)
                  ComissPay = TComissPay();
                  ComissPay.payDate   = PlanPay[j].payDate;
                  ComissPay.expDate   = PlanPay[j].expDate;
                  ComissPay.comissSum = ComissRec.sum;

                  ComissRec.comissPay[j] = ComissPay;   
               END;
            END;         
         END;

         Comiss[i] = ComissRec;
      END;
   END;
END;

private macro CheckData()
   var ComissTypeID:integer;
   var i:integer, j:integer, k:integer;
   var RSDCmd,rs ;

   // проверки для ГП
   FOR (i, 0, PlanPay.size - 1, 1)
      IF ((PlanPay[i].payDate == NULL) OR (PlanPay[i].payDate == date(0,0,0)))
         RunError("Не задана дата платежа в графике", 18549);
      END;

      IF (((PlanPay[i].paySum == NULL)     OR (PlanPay[i].paySum == 0)) AND
         ((PlanPay[i].percentSum == NULL) OR (PlanPay[i].percentSum == 0)) 
        )
         RunError("Не задана сумма в графике погашения кредита", 18542);
      END;

      FOR (j, 0, PlanPay.size - 1, 1)
         IF ( i!=j )
            IF (PlanPay[i].payDate == PlanPay[j].payDate )
               RunError("Дублируются даты платежей в графике погашения кредита", 18543);
            END;
         END;
      END;
   END;

   // Проверки для графиков комиссий
   FOR (i, 0, Comiss.size - 1, 1)
      if (ValType(Comiss[i].type) == V_UNDEF)
         RunError("Не передан обязательный параметр: Тип комиссии", 18703);
      end;
      RSDCmd = RsdCommand ("SELECT T_dutystageid FROM ddutstage_dbt WHERE T_dutystageid = ?");
      RSDcmd.addParam ("dutystageid", RSDBP_IN); 
      RSDcmd.value ("dutystageid") = Comiss[i].type;
      rs = RsdRecordset(RSDcmd);
      IF (rs.MoveNext()==false)     
         RunError("Тип комиссии " + Comiss[i].type + " указан неверно", 18544);
      END;

      FOR (j, 0, Comiss[i].comissPay.size - 1, 1)
         IF ((Comiss[i].comissPay[j].payDate == NULL) OR (Comiss[i].comissPay[j].payDate == date(0,0,0)))
            RunError("Не задана дата платежа в графике", 18549);
         END;

         FOR (k, 0, Comiss[i].comissPay.size - 1, 1)
            IF ( j != k )
               IF (Comiss[i].comissPay[j].payDate  == Comiss[i].comissPay[k].payDate)
                  RunError("Дублируются даты платежей в графике по комиссии " + Comiss[i].type +" ", 18545);   
               END;
            END;
       
            IF (Comiss[i].comissPay[j].ComissSum==NULL)
               RunError("Не задана сумма в графике погашения комиссии " + Comiss[i].type + " ",18550);
            END;
         END;
      END;
      
      // 2.3.2 Если график платежей комиссии (массив элементов Comiss[i].comissPay) пуст, то должно быть заполнено значение Comiss[i].sum
      IF (Comiss[i].comissPay.size == 0)
         IF ((Comiss[i].Sum == NULL) OR (Comiss[i].Sum < 0))
            RunError("Суммы и даты платежей комиссии " + Comiss[i].type +" не заданы", 18548);   
         END;
      END;
   END;
  
   RETURN TRUE;
END;


macro InsPlanPay(ObjID:integer, ObjN:integer, DateOp:date, GPlanPay:TArray)
   record LGPAYOP    ("LGPAYOP.DBT", "loans.def");
   record PlanPayRec ("plan_pay.tmp");
   var crdop:integer, i:integer;

   LGPAYOP.CREDOPERID_REF      = 0;
   LGPAYOP.PAY_PLANFIRSTDATE   = date(0,0,0);
   LGPAYOP.PAY_PLANLASTDATE    = date(0,0,0);
   LGPAYOP.PAY_PLANCOUNTPAY    = 0;
   LGPAYOP.PAY_DUTYPAYMENTSUM  = $0;
   LGPAYOP.PAY_TYPEPERIOD      = 0;
   LGPAYOP.PAY_PERIOD          = 0;
   LGPAYOP.PAY_ARREARDATE      = 0;
   LGPAYOP.PAY_EXPDAY          = 0;
   LGPAYOP.PAY_POSTEXPDAY      = 0;
   LGPAYOP.PERC_PLANFIRSTDATE  = date(0,0,0);
   LGPAYOP.PERC_PLANLASTDATE   = date(0,0,0);
   LGPAYOP.PERC_PLANCOUNTPAY   = 0;
   LGPAYOP.PERC_TYPEPERIOD     = 0;
   LGPAYOP.PERC_PERIOD         = 0;
   LGPAYOP.PERC_ARREARDATE     = 0;
   LGPAYOP.PERC_EXPDAY         = 0;
   LGPAYOP.PERC_POSTEXPDAY     = 0;
   LGPAYOP.SUM                 = $0;
   LGPAYOP.SUMEX               = $0;
   LGPAYOP.TYPE                = 0;
   LGPAYOP.CASHINADVANCE       = StrFOR (0);
   LGPAYOP.PAY_PAYDAY          = 0;
   LGPAYOP.EXP_PAYDAY          = 0;
   LGPAYOP.EXP_CALCEXPPERCDATE = 0;
   LGPAYOP.ISPRIVELEGE         = StrFOR (0);

   // LPS SCR 181300
   // Очистка временной таблицы
   CRSDCommand("DELETE FROM DPLAN_PAY_TMP", V_GENOBJ);
   RSL_BatchInit();

   FOR (i, 0, PlanPay.size - 1, 1)

      PlanPayRec.OBJECTID_REF     = objn;
      PlanPayRec.OBJECTTYPEID_REF = objid;
      PlanPayRec.CREDOPERID_REF   = 0;
      PlanPayRec.TYPE             = 0;
      PlanPayRec.PLANNEDPAYDATE   = PlanPay[i].payDate;
      PlanPayRec.PLANNEDEXPDATE   = PlanPay[i].expDate;
      IF (PlanPay[i].paySum != NULL)
         PlanPayRec.PLANNEDPAYSUM = PlanPay[i].paySum;
         LGPAYOP.PERC_PLANCOUNTPAY    = LGPAYOP.PERC_PLANCOUNTPAY + 1; // Кол-во периодов

         IF (LGPAYOP.PAY_PLANFIRSTDATE == date(0,0,0))
             LGPAYOP.PAY_PLANFIRSTDATE = PlanPayRec.PLANNEDPAYDATE;
         END;

         LGPAYOP.PAY_PLANLASTDATE     = MAX(LGPAYOP.PAY_PLANLASTDATE,  PlanPayRec.PLANNEDPAYDATE);
         LGPAYOP.PAY_PLANFIRSTDATE    = MIN(LGPAYOP.PAY_PLANFIRSTDATE, PlanPayRec.PLANNEDPAYDATE);
         LGPAYOP.SUM                  = LGPAYOP.SUM + PlanPayRec.PLANNEDPAYSUM;
      END;

      IF (PlanPay[i].percentSum != NULL)
         PlanPayRec.PLANNEDPERCENTSUM = PlanPay[i].percentSum;
         LGPAYOP.PAY_PLANCOUNTPAY     = LGPAYOP.PAY_PLANCOUNTPAY  + 1; // Кол-во периодов

         IF (LGPAYOP.PERC_PLANFIRSTDATE == date(0,0,0))
             LGPAYOP.PERC_PLANFIRSTDATE = PlanPayRec.PLANNEDPAYDATE;
         END;

         LGPAYOP.PERC_PLANLASTDATE    = MAX(LGPAYOP.PERC_PLANLASTDATE,  PlanPayRec.PLANNEDPAYDATE);
         LGPAYOP.PERC_PLANFIRSTDATE   = MIN(LGPAYOP.PERC_PLANFIRSTDATE, PlanPayRec.PLANNEDPAYDATE);
      END;

      RSL_BatchAdd (PlanPayRec);
   END;
   RSL_BatchInsert();

   crdop = MakeOperation(ObjN, ObjID, CF_RECALCGPAY, 0, DateOp, LGPAYOP, GPAY_SIMPLELOAD, 2);

   IF (GetMO_ErrorID != 0)
      RunError("Ошибка в операции создания графика погашения:|" + GetMO_LoansError(), 18546);
   END;

   RETURN TRUE;
END;

macro InsPlanComiss(ObjID:integer, ObjN:integer, DateOp:date, GComiss:TComiss)
   record LGPAYOP   ("LGPAYOP.DBT", "loans.def");
   record PlanPayRec("plan_pay.tmp");
   var crdop:integer, i:integer;

   LGPAYOP.CREDOPERID_REF      = 0;
   LGPAYOP.PAY_PLANFIRSTDATE   = date(0,0,0);
   LGPAYOP.PAY_PLANLASTDATE    = date(0,0,0);
   LGPAYOP.PAY_PLANCOUNTPAY    = 0;
   LGPAYOP.PAY_DUTYPAYMENTSUM  = $0;
   LGPAYOP.PAY_TYPEPERIOD      = 0;
   LGPAYOP.PAY_PERIOD          = 0;
   LGPAYOP.PAY_ARREARDATE      = 0;
   LGPAYOP.PAY_EXPDAY          = 0;
   LGPAYOP.PAY_POSTEXPDAY      = 0;
   LGPAYOP.PERC_PLANFIRSTDATE  = date(0,0,0);
   LGPAYOP.PERC_PLANLASTDATE   = date(0,0,0);
   LGPAYOP.PERC_PLANCOUNTPAY   = 0;
   LGPAYOP.PERC_TYPEPERIOD     = 0;
   LGPAYOP.PERC_PERIOD         = 0;
   LGPAYOP.PERC_ARREARDATE     = 0;
   LGPAYOP.PERC_EXPDAY         = 0;
   LGPAYOP.PERC_POSTEXPDAY     = 0;
   LGPAYOP.SUM                 = $0;
   LGPAYOP.SUMEX               = $0;
   LGPAYOP.TYPE                = GComiss.type;
   LGPAYOP.CASHINADVANCE       = StrFOR (0);
   LGPAYOP.PAY_PAYDAY          = 0;
   LGPAYOP.EXP_PAYDAY          = 0;
   LGPAYOP.EXP_CALCEXPPERCDATE = 0;
   LGPAYOP.ISPRIVELEGE         = StrFOR (0);

   // Очистка временной таблицы
   CRSDCommand("DELETE FROM DPLAN_PAY_TMP", V_GENOBJ);
   RSL_BatchInit();

   FOR (i, 0, GComiss.comissPay.size - 1, 1)
      PlanPayRec.OBJECTID_REF      = objn;
      PlanPayRec.OBJECTTYPEID_REF  = objid;
      PlanPayRec.CREDOPERID_REF    = 0;
      PlanPayRec.TYPE              = GComiss.type;
      PlanPayRec.PLANNEDPAYDATE    = GComiss.comissPay[i].payDate;
      PlanPayRec.PLANNEDEXPDATE    = GComiss.comissPay[i].expDate;
      IF (GComiss.comissPay[i].comissSum != NULL)
         PlanPayRec.PLANNEDPERCENTSUM = GComiss.comissPay[i].comissSum;
      END;
      RSL_BatchAdd (PlanPayRec);
   END;
   RSL_BatchInsert();

   crdop = MakeOperation(ObjN, ObjID, CF_KOMISSGRAPH, 0, DateOp, LGPAYOP, GPAY_SIMPLELOAD);

   IF (GetMO_ErrorID != 0)
      RunError("Ошибка в операции создания графика погашения комиссий вида " + GComiss.type + " :| " + GetMO_LoansError(), 18547);
   END;

   RETURN TRUE;
END;

macro InsertPayPlanTRN()
   var rs, RSDCmd;
   var crdop:integer=0, i:integer;
   var ObjN:integer  = 0;
  
   ObjN = credID;
   // Вставим ГП
   IF (PlanPay.size > 0)
      IF (NOT InsPlanPay(LO_CREDIT, ObjN, OpDate, PlanPay))
         RETURN FALSE;
      END;
   END;

   // Вставим графики комиссий
   FOR (i, 0, Comiss.size - 1, 1)
      IF (NOT InsPlanComiss(LO_CREDIT, ObjN, OpDate, Comiss[i]))
         RETURN FALSE;
      END;
   END;
 
   RETURN TRUE;   
   
   //сюда попадем, если было выброшено исключение.
   OnError(err)
      IF (ValType(err.Err) == V_INTEGER)
         ErrManager.SetError(err.Err, err.Message);
      END;
      RunError();
END;

macro InsertPayPlan(creditId:integer, creditNumber:string, operdate:date, BusTPay, BusTComiss)
   FindCrd(@creditID, creditNumber, credContr); 
   credID = creditID;
       
   OpDate = operdate;
   IF ((OpDate == NULL) OR (OpDate == date(0,0,0)))
      OpDate = {curdate};    
   END;

   // Инициализируем наши объекты тем, что пришло из ТК
   ReadBusObj(BusTPay, BusTComiss);
   
   // Выполним обязательные проверки
   IF (NOT CheckData())      
      RETURN FALSE;
   END;
    
   // Если нужно, то проверим пользовательской функцией
   if(NOT skip_user_chec.InsertPayPlan)
      if(NOT InsertPayPlanUserCheck(NumServ,PlanPay,Comiss))
         return 0;
      end;
   end;
   

   IF (RtTrn("InsertPayPlanTRN"))
      RETURN TRUE;
   END;
   
   // Если в транзакции возникла ошибка, выбросим ее в ТК
   IF (ErrManager.GetErrCode() != 0) 
      //ErrManager.RunErr();
      RunError();
   END;

   RETURN FALSE;
END;