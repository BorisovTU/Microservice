/*
$Name:             planpay.mac                                              
$Module:           Кредитование
$Description:      Графики
*/
/*------------------------------------------------------------------------------
                     Библиотека интерпретируемых модулей

 Filename    : planpay.mac
 Description : Формирование графика по параметрам обязательства

 Programmer  : ROV
------------------------------------------------------------------------------*/
Import SbCrdInter, ПроцентыБухгалтер, Total, Календарь, "macperc.mac", RsbDataSet, crdRunGroupOp, lgo_opstruct, ACTIVEX;
import planpay_attr;

record Обязательство ("duty_crd.dbt", "loans.def"); /* текущий буфер обязательства */
record Договор       ("credit_c.dbt", "loans.def"); /* текущий буфер договора      */
record calcgpay      ("lgpayop.dbt",  "loans.def"); /* буфер параметров графика    */
file   График        ("plan_pay.tmp", "loans.def") write;
file   ГрафикTmp     ("planmac.tmp",  "loans.def") write;

private file   dutyrest    ("dutyrest.dbt",    "loans.def");
private file   dutyrest_sd ("svdrestview.dbt", "loans.def") key 1;
private file   lpayop      ("lpayop.dbt",      "loans.def");

private record payoffop ("doc_duty.dbt", "loans.def");
private record lcusreg  ("lcusreg.dbt",  "loans.def");
private record solcusreg  ("lcusreg.dbt",  "loans.def");
private record rlcusrate("lcusrate.dbt", "loans.def");
private record sorlcusrate("lcusrate.dbt", "loans.def");
private record lcpermit ("lcpermit.dbt", "loans.def");
private record lcalghis   ("lctypuse.dbt", "loans.def");

private VAR ErrCode, CheckPlanPay_LastDate;

private VAR  Операции     = TBFile ("crd_op.dbt",   "r", 1, "crd_op.dbt",   "loans.def");
private VAR  planpay_tmp  = TBFile ("planpay.tmp",  "w", 1, "planpay.tmp",  "loans.def");
private VAR  type_crd_dbt = TBFile ("type_crd.dbt", "r", 1, "type_crd.dbt", "loans.def");

private VAR {RSL_TOOLS_VERSION};

VAR Rasnost_Period : integer = 0;

VAR AnnuitTRN: bool = false; // нужна для передачи параметра в функцию транзакции

IF (GetRegistryValue ("RS-LOANS\\CHECK_PLANPAY_LASTDATE", V_BOOL, CheckPlanPay_LastDate, ErrCode) != V_BOOL)
    msgBox(ErrCode);
    RETURN true;
END;

class KDODGrafType
   VAR plannedPayDate: date;
   VAR plannedExpDate: date;
   VAR plannedPaySum : money;
END;

class PercObject
   VAR ObjectID     :integer;
   VAR ObjectNumber :integer;
   VAR RateID       :integer;
   VAR AlgID        :integer;
   VAR regID          :integer;
   VAR ODGraf       :TArray = TArray();

   MACRO AddODGrafRec(paysum : money)
      ODGraf(ODGraf.size) = paysum;
   END;

   MACRO GetODGrafSum(index : integer)
      IF ((index < 0) OR (index >= ODGraf.size))
         RETURN 0;
      END;

      RETURN ODGraf(index);
   END;
END;

VAR ReCalc:bool;
private VAR WayRecalculation:integer = GR_BY_FIRST;//Способ перерасчета графика ОД (параметр в ВК) - с первого платежа
private VAR SuperDuty: bool = false;
private VAR ToAbsolu: bool = false;
private VAR НедоплатаПроцентов = $0;
private VAR ObjectTypeID:integer;
private VAR ObjectID:integer;
private VAR TypeGr:integer;

private VAR AnnuitInCycle:bool = FALSE;
private VAR FindGoodPayGraph:bool = FALSE;
class CNewAnnuit( _AnnuitPeriodCount, FunctionRef )
   // NewAnnuitAlg
   VAR  Id:Integer = 0,         // ID
        Step:Integer = 0,       // Шаг увеличения периодов
        Quantyti:Integer = 0,   // Начальное число периодов
        Iterate:Integer = 0,    // Количество попыток
        curPeriodCount  = 0,    // Текущее число периодов(пререданное из функции)
        NewAnnuitMode:bool   = false,       // Флаг означает, что работает новый алгоритм расчета аннуитетных графиков (всегда в ручном режиме просто с рекурсией)
        NoNewAnnuit:bool   = false,         // Флаг означает, что даже в случае если ДОЛЖЕН включится новый алгоримт работать по старому!
        ShowAnnuitGraphAnyway:bool = false, // Флаг означает, что выдать график даже с нарушениями!
        ManualAnnuitNeed:bool = false,      // Флаг означает, что выбрали мануальный режим
        ManualAnnuitNeedRetValue:Integer = 0, // Возвращаемое значение для корректного запуска мануального режима:ManualAnnuitConst+ID параметров графика
        ManualAnnuitConst:Integer = 1048576,  // Константа, к которой прибавляется ID выбранной записи параметров графиков погашения
        GetPayGrapgError:bool = false,        // Флаг означает: при расчете графика аннуитета были найдены нарушения, цикл расчета можно прервать
        CalcNewGraph,                         // Виртуальная функция, которая подменит собой "СформироватьГрафик" объявленный ниже
        TotalPeriodsSum = 0.0,                // Сумма всех оплаченых ОД по всем периодам периодов перед последним
        CurPeriodPayedSum = 0.0,              // Сумма всех оплаченых ОД до текущего периода
        PeriodInterval:Double,                // Временной диапазон
        LstPeriodInterval,                    // Длительность последнего временного диапазона
        PreviusPeriodSum = 0.0;               // Сумма Аннуитета предыдущего ПП

   VAR  sqlForPRMGRAPH = " SELECT * FROM DPRMGRAPH_DBT WHERE :1 BETWEEN T_BEGDATE AND T_ENDDATE AND "+
                         "(( :2 > T_MINIMALRATE AND T_INCLUDEMIN != :3 AND  :2 < T_MAXIMALRATE AND T_INCLUDEMAX != :3 ) OR   "
                         " ( :2 >= T_MINIMALRATE AND T_INCLUDEMIN = :3 AND  :2 < T_MAXIMALRATE AND T_INCLUDEMAX != :3 ) OR   "
                         " ( :2 >= T_MINIMALRATE AND T_INCLUDEMIN = :3 AND  :2 < = T_MAXIMALRATE AND T_INCLUDEMAX = :3 ) OR  "
                         " ( :2 > T_MINIMALRATE AND T_INCLUDEMIN != :3 AND  :2 < = T_MAXIMALRATE AND T_INCLUDEMAX = :3 ))";
        

   MACRO FirstPeriodCheck(PlanPayDate,CalcStartDate) //  проверка первого периода (а будет ли новый аннуитет) NoNewAnnuit TRUE/FALSE
      VAR FirstPeriod,mon,year;
      IF ( NOT(NoNewAnnuit) ) // Проверяем только длину 1го платежного периода
          FirstPeriod = PlanPayDate-CalcStartDate;
          IF ((FirstPeriod > 31) AND (calcgpay.IsPrivelege != "X") ) // - Льготный период! ТОЛЬКО для 2028 и выше
            IF (GetTrue( True, string( "Продолжительность первого платежного периода не равна периоду погашения продолжить?")))
                NoNewAnnuit = true;
                RETURN FALSE;
            ELSE
              RETURN TRUE;
            END;
          END;
      END;
   END ;

   MACRO isChekSumFail(AnnuitSum, PrecSum, stepNum) // Проверка сумм при расчете аннуитета (Сумма процентов не больше суммы рассчитанного аннуитета) NewAnnuitMode TRUE/FALSE
      IF ((AnnuitSum < PrecSum) AND (NOT(NoNewAnnuit)) AND ((StepNum > 1) OR (calcgpay.IsPrivelege == 0)))
        GetPayGrapgError = TRUE;
        RETURN TRUE;
      END;
      RETURN FALSE;
   END;

   MACRO GetPrmGraph(Date, Rate) //  Получить данные по параметрам графика погашения(найти данные) may be NoNewAnnuit TRUE/FALSE
      VAR rs,RSDcmd;

      RSDcmd = RSDCommand(RslDefCon, sqlForPRMGRAPH);
    
      RSDcmd.addParam("1",  RSDBP_IN); RSDcmd.value("1") = Date;
      RSDcmd.addParam("2",  RSDBP_IN); RSDcmd.value("2") = Rate;
      RSDcmd.addParam("3",  RSDBP_IN); RSDcmd.value("3") = "X";
      
      rs = RsdRecordset(RSDcmd);
      RSDcmd.execute;

      IF((rs != NULL) AND (rs.MoveNext()))
        Id = rs.Value("T_ID");
        Step = rs.Value("T_STEP");
        Quantyti = rs.Value("T_QUANTITY");
        Iterate = rs.Value("T_ITERATE");
        ManualAnnuitNeedRetValue = ManualAnnuitConst+Id; // ЗАПОЛНЯЕТСЯ ТУТ!
        IF  (curPeriodCount == 0)
          curPeriodCount = Quantyti;
        END;
      ELSE
        RETURN FALSE;
      END;
      RETURN TRUE;
   END;

   MACRO IsNeedExit()        //  Покинуть ли данный цикл расчета
      IF (NewAnnuitMode AND ShowAnnuitGraphAnyway AND not AnnuitInCycle)
          RETURN FALSE;
      END;
      IF (GetPayGrapgError)
          RETURN TRUE;
      END;
      RETURN FALSE;
   END;

   //  Выдать сообщение о невозможности построить график ShowAnnuitGraphAnyway TRUE/FALSE ManualAnnuitNeed TRUE/FALSE
   MACRO ImpossibleRirghtGraph(ObjID:integer, ObjN:integer, _typegr:integer, Sum:moneyl, _ReCalc_: bool, type:integer, Rate : DoubleL, buff , ForDeltaSum: bool, annuit)
      VAR msg;
      msg = string( "График аннуитетных платежей с уменьшающимися размерами платежей построить не удалось! | "
                   +"Запустить расчет графика погашения с выводом на экран каждого этапа расчета? ");
      //ShowAnnuitGraphAnyway = TRUE;
      IF (GetTrue( True, msg))
          ManualAnnuitNeed = TRUE;
      ELSE
        RETURN TRUE;
      END;

      IF (ManualAnnuitNeed) // Если захотели ручной режим
          AnnuitInCycle = FALSE;
          ExecMACRO( CalcNewGraph, ObjID, ObjN, _typegr, Sum, _ReCalc_, type, Rate, buff, ForDeltaSum, annuit, Quantyti);
          RETURN ManualAnnuitNeedRetValue;
      END;
      RETURN 0; // Если не захотели :) (Выходим из макроса, график построен, все ОК!)
   END;

   MACRO CalcCurPeriodSum(remaining_OD,PeriodDate)  // Расчет суммы текущего(i-го) периода!
      VAR  AnnuitSum,pyear,S,P,B;
      /* Годовая % ставка по ОД на дату погашения */
      P = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, PeriodDate, false);
      /* Фактическое кол-во дней в году */
      DateSplit (calcgpay.PAY_PlanFirstDate, null, null, pyear);

      Loans_FindLCTU(TRU_CRD, lcalghis);
      IF (lcalghis.Calendar == 1)   // (День)
          B = lcalghis.T_VALUEBASE;
      ELIF (lcalghis.Calendar == 2) // (Месяц)
          B = 28;
      ELIF (lcalghis.Calendar == 3) // (Квартал)
          B = 90;
      ELIF (lcalghis.Calendar == 4) // (Год)
          B = 365;
      END;

      S = remaining_OD-CurPeriodPayedSum;
      AnnuitSum = ROUND((S*P*31)/(100*B),2);
      RETURN AnnuitSum;
   END;

   MACRO CalcLstPeriodSum(remaining_OD,PeriodDate, LstPayPeriodsCount)  // Расчет суммы последнего периода
      VAR  AnnuitSum,pyear,S,P,T,r,t1,t2,t3;
      /* Годовая % ставка по ОД на дату погашения */
      P = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, PeriodDate, false);
      r = P / (12.0*100);
      S = remaining_OD-TotalPeriodsSum; // Остаток ОД - минус сумма всех периодов
      T = LstPayPeriodsCount;
      AnnuitSum = Floorl ((S * r) / (1 - (1/Pow (1+r, T))));
      RETURN Floorl(round(AnnuitSum));
   END;

   MACRO IsThisLastPayPeriod(curIteration, allPeriodsCount, curPayPeriods)
      VAR lastPeriodSince,   // Итерация, с которой начинается последний период
          Sum = 0;

      IF (NoNewAnnuit OR not NewAnnuitMode) RETURN FALSE; END;

      PeriodInterval = Floor(Double(allPeriodsCount/curPayPeriods));
      LstPeriodInterval = periodInterval+allPeriodsCount-periodInterval*curPayPeriods;
      lastPeriodSince = allPeriodsCount-lstPeriodInterval+1;
      IF (curIteration >=lastPeriodSince)
        RETURN TRUE;
      END;
      RETURN FALSE;
   END;

   MACRO CalcPeriodSum(remaining_OD,PeriodDate, curIteration, allPeriodsCount, curPayPeriods,srcSum)  // Расчет суммы текущего(i-го) периода!
      VAR periodInterval,PeriodChanged,SUM;

      periodInterval = Floor(Double(allPeriodsCount/curPayPeriods));
      IF (periodInterval == 0 ) // есди количество диапазонов после вычисления равно нулю - работает только старый алгоритм! 3я проверка
          NoNewAnnuit = TRUE;
          RETURN srcSum;
      END;

      PeriodChanged = curIteration > PeriodInterval;

      // Если период изменился уменьшаем сумму остатка ОД
      IF (PeriodChanged)
          CurPeriodPayedSum = TotalPeriodsSum;
      END;

      IF (IsThisLastPayPeriod(curIteration, allPeriodsCount, curPayPeriods))
        Sum = CalcLstPeriodSum(remaining_OD, PeriodDate, LstPeriodInterval);
      ELSE
        Sum = CalcCurPeriodSum(remaining_OD, PeriodDate );
      END;

      // Проверка, что каждая следующая сумма аннуитета не больше предыдущей
      IF (PreviusPeriodSum == 0)
          PreviusPeriodSum = Sum;
      END;
      IF (IsThisLastPayPeriod(curIteration, allPeriodsCount, curPayPeriods))
        IF (PreviusPeriodSum < Sum)
            GetPayGrapgError = TRUE; // ОШИБКА 4й проверки
        END;
      ELSE
        IF (PeriodChanged)
            IF (PreviusPeriodSum < Sum)
              GetPayGrapgError = TRUE; // ОШИБКА 4й проверки
            ELSE
              PreviusPeriodSum = Sum;
            END;
        END;

      END;

      RETURN Sum;
   END;

   MACRO СформироватьГрафик (ObjID:integer, ObjN:integer, _typegr:integer, Sum:moneyl, _ReCalc_: bool, type:integer, Rate : DoubleL, buff , ForDeltaSum: bool, Annuit, AnnuitPeriodCount, DateOp :date)

      VAR iter,curPeriodCount,retVal;
      NewAnnuitMode = TRUE;
      iter = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, calcgpay.PAY_PlanFirstDate, false);
      IF (GetPrmGraph(calcgpay.PAY_PlanFirstDate,iter))
          iter = 1;
          curPeriodCount = Quantyti;
          AnnuitInCycle = TRUE;
          WHILE ( iter <= Iterate )
              GetPayGrapgError = FALSE;
              retVal = ExecMACRO( CalcNewGraph, ObjID, ObjN, _typegr, Sum, _ReCalc_, type, Rate, buff, ForDeltaSum, Annuit, curPeriodCount );
              IF ( FindGoodPayGraph )
                  iter = Iterate+1; // ПОКИДАЕМ ЦИКЛ
              ELSE
                  iter = iter+1;
                  curPeriodCount = Quantyti+(iter-1)*Step; // Возвращаемся на новый круг
              END;
          END;
          AnnuitInCycle = FALSE;

          // ТУТ ВЫДАТЬ СООБЩЕНИЕ О МАНУАЛЬНОМ РЕЖИМЕ (И ПОТОМ ПОСТРОИТЬ ГРАФИК С ПЕРВОЙ ИТЕРАЦИЕЙ)
          IF (not FindGoodPayGraph) // Если вышли из цикла, но так и не построили график
              ImpossibleRirghtGraph(ObjID, ObjN, _typegr, Sum, _ReCalc_, type, Rate, buff, ForDeltaSum, Annuit);
          END;

          IF (ManualAnnuitNeed) // Если захотели ручной режим
              RETURN ManualAnnuitNeedRetValue;
          END;
          RETURN 0; // Если не захотели :) (Выходим из макроса, график построен, все ОК!)
      END; // GetPrmGraph
   END;

   /**
    * Ищет параметры настройки расчета аннуитетных графиков.
    * @return Возвращает признак найдены/не найдены
    *
    */
   MACRO FindParmzForAnnuitGrph()

      VAR rs,Rate;
      VAR RSDcmd;

      Rate = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, calcgpay.PAY_PlanFirstDate, false);

      RSDcmd = RSDCommand(RslDefCon, sqlForPRMGRAPH);

      RSDcmd.addParam("1",  RSDBP_IN); RSDcmd.value("1") = calcgpay.PAY_PlanFirstDate;
      RSDcmd.addParam("2",  RSDBP_IN); RSDcmd.value("2") = Rate;
      RSDcmd.addParam("3",  RSDBP_IN); RSDcmd.value("3") = "X";
      
      rs = RsdRecordset(RSDcmd);
      RSDcmd.execute;

      IF((rs != NULL) AND (rs.MoveNext()))
          RETURN TRUE;
      ELSE
          RETURN FALSE;
      END;

   END;

   // Конструктор
   IF (_AnnuitPeriodCount > 0)
      NewAnnuitMode = TRUE;
      ShowAnnuitGraphAnyway = TRUE; // в мануальном режиме мы всегда строим графики
   ELSE
      IF ((calcgpay.PAY_Period != 1) OR (calcgpay.PAY_TypePeriod != CF_MONTH))
          CalcNewGraph = FunctionRef;
          NoNewAnnuit = TRUE;
      END;
   END;

END;

MACRO OneStep(First:bool, f, PayDate:Date, _TypeGr: integer, CredOperID: integer, StartExpDate: date, WayRecalc)

   VAR CredOperID_Ref: integer = 0,
      _TypeGraph    : integer = TypeGr,
      _StartExpDate : date = date(0,0,0),
      STAT: BOOL = TRUE;

   IF (ValType(CredOperID) == V_INTEGER)
      CredOperID_Ref = CredOperID;
   END;

   IF (ValType(_TypeGr) == V_INTEGER)
      _TypeGraph = _TypeGr;
   END;

   IF (ValType(StartExpDate) == V_DATE)
      _StartExpDate = StartExpDate;
   END;

   IF (First)
      SetParm(0, False);
      f.ObjectTypeID_Ref = ObjectTypeID;
      f.ObjectID_Ref     = ObjectID;
      f.Type             = _TypeGraph;
      f.CredOperID_Ref   = CredOperID_Ref;
      IF (WayRecalc == GR_BY_FIRST)
         f.PlannedPayDate   = PayDate;
      ELSE
         f.PlannedPayDate   = date(31,12,9999);
      END;
      f.PlannedExpDate   = _StartExpDate;

      IF (WayRecalc == GR_BY_FIRST)
         STAT = GetGE(f);
      ELSE 
         STAT = GetLE(f);
         IF (STAT)
            STAT = f.PlannedPayDate >= PayDate;
         END;
      END;

      IF (STAT AND
             (f.ObjectTypeID_Ref == ObjectTypeID) AND
             (f.ObjectID_Ref     == ObjectID)     AND
             (f.Type             == _TypeGraph)   AND
             (f.CredOperID_Ref   == CredOperID_Ref))
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END;
   ELSE
      RETURN ( (((WayRecalc == GR_BY_FIRST) AND (Next(f))) OR ((WayRecalc != GR_BY_FIRST) AND (Prev(f)) AND (f.PlannedPayDate >= PayDate))) AND
           (f.ObjectTypeID_Ref == ObjectTypeID) AND
           (f.ObjectID_Ref     == ObjectID)     AND
           (f.Type             == _TypeGraph)   AND
           (f.CredOperID_Ref   == CredOperID_Ref));
   END;
END;


MACRO TrnInsGPayDuty()
   VAR str:string = "";
   VAR rs = null;

   str = "delete dplan_pay_tmp WHERE t_objectid_ref = " + string(ObjectID);
   str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
   str = str + " AND t_type = " + string(TypeGr);
   str = str + " AND t_credoperid_ref = 0";

   rs = LnGetRecordset(str);
   IF (rs == NULL)
       RETURN false;
   END;

   str = "INSERT INTO dplan_pay_tmp (T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM) " +
                           " SELECT T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM FROM dplanmac_tmp WHERE t_objectid_ref = " + string(ObjectID);
   str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
   str = str + " AND t_type = " + string(TypeGr);
   str = str + " AND t_credoperid_ref = 0";    

   rs = LnGetRecordset(str);
   IF (rs == NULL)
       RETURN false;
   END;


   IF (NOT AnnuitTRN)
      str = "update dplan_pay_tmp set t_plannedpercentsum = 0";
      str = str + " WHERE t_objectid_ref = " + string(ObjectID);
      str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
      str = str + " AND t_type = " + string(TypeGr);
      str = str + " AND t_credoperid_ref = 0";

      rs = LnGetRecordset(str);
      IF (rs == NULL)
          RETURN false;
      END;
   END;
   RETURN true;
END;

MACRO TrnInsGPayKomiss()
    VAR str:string = "";
    VAR rs = null;

    str = "delete dplan_pay_tmp WHERE t_objectid_ref = " + string(ObjectID);
    str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
    str = str + " AND t_type = " + string(TypeGr);
    str = str + " AND t_credoperid_ref = 0";

    rs = LnGetRecordset(str);
    IF (rs == NULL)
        RETURN false;
    END;

    str = "INSERT INTO dplan_pay_tmp (T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM) " +
                            " SELECT T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM FROM dplanmac_tmp";

    rs = LnGetRecordset(str);
    IF (rs == NULL)
        RETURN false;
    END;
    RETURN true;
END;

MACRO AddPercDataToGraph()
   ReWind(График);
   next(График);

   ReWind(ГрафикTmp);
   WHILE (next(ГрафикTmp))
      График.ObjectTypeID_Ref = ГрафикTmp.ObjectTypeID_Ref;
      График.ObjectID_Ref     = ГрафикTmp.ObjectID_Ref;
      График.Type             = ГрафикTmp.Type;
      График.CredOperID_Ref   = ГрафикTmp.CredOperID_Ref;
      График.PlannedPayDate   = ГрафикTmp.PlannedPayDate;
      График.PlannedExpDate   = ГрафикTmp.PlannedExpDate;
      IF (GetEQ(График))
         График.PlannedPercentSum = ГрафикTmp.PlannedPercentSum;
         IF (NOT Update(График))
            RETURN false;
         END;
      ELSE
         Copy(График, ГрафикTmp);
         IF (NOT Insert(График))
            RETURN false;
         END;
      END;
   END;
   RETURN true;
END;

MACRO TrnInsGPayPerc()
   VAR str:string = "";
   VAR rs = null;
   VAR GrType = TypeGr;

   IF (SuperDuty)
      IF (ToAbsolu)
         GrType = DS_PERC;
      END;

      IF (GrType == DS_PERC)
         str = "delete dplan_pay_tmp WHERE t_objectid_ref = " + string(ObjectID);
         str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
         str = str + " AND t_type = " + string(GrType);
         str = str + " AND t_credoperid_ref = 0";

         rs = LnGetRecordset(str);
         IF (rs == NULL)
             RETURN false;
         END;
      END;

      IF ((ToAbsolu) OR (GrType != DS_PERC))
         AddPercDataToGraph();
      ELSE
         str = "INSERT INTO DPLAN_PAY_TMP (T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM) " +
                                  " SELECT T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM FROM DPLANMAC_TMP";

         rs = LnGetRecordset(str);
         IF (rs == NULL)
            RETURN FALSE;
         END;
      END;
   ELSE
      str = "delete dplan_pay_tmp WHERE t_objectid_ref = " + string(ObjectID);
      str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
      str = str + " AND t_type = " + string(TypeGr);
      str = str + " AND t_plannedpaysum = 0 AND t_credoperid_ref = 0";

      rs = LnGetRecordset(str);
      IF (rs == NULL)
         RETURN false;
      END;

      str = "update dplan_pay_tmp set t_plannedpercentsum = 0";
      str = str + " WHERE t_objectid_ref = " + string(ObjectID);
      str = str + " AND t_objecttypeid_ref = " + string(ObjectTypeID);
      str = str + " AND t_type = " + string(TypeGr);
      str = str + " AND t_credoperid_ref = 0";

      rs = LnGetRecordset(str);
      IF (rs == NULL)
         RETURN false;
      END;

      RETURN AddPercDataToGraph();
   END;

   RETURN true;
   /*END;*/
END;

// Функция расчета аннуитета для панели параметров расчета аннуитетного графика погашения
MACRO CalcAnnuit(ObjectTypeID, ObjectID, PlanCountPay, PlanFirstDate, PlanLastDate, TypePeriod, Period, Recalc, IsPrivelege)
   record rcredit ("credit_c.dbt", "loans.def");
   record rdutycrd ("duty_crd.dbt", "loans.def");

   VAR AnnuitSum:money = $0,
       S = $0,
       n = 0,
       R:double = 0.0,
       m1, m2, DT, d1, d2 = $0;
   VAR TypeRateuse; // процентная ставка

   n = PlanCountPay;

   // Льготный период не учитываем в расчете аннуитета
   IF (IsPrivelege)
       n = n-1;
   END;

   Rasnost_Period = n;

   IF (n == 0)
       RETURN AnnuitSum;
   END;

   IF ((ObjectTypeID == LO_GUARANTEE) OR (ObjectTypeID == LO_BANKGUARANTEE))
        TypeRateuse = TRU_PAYMGUAR;
   ELSE
     TypeRateuse = TRU_CRD;
   END;
   

   R = Loans_FindRateVal(ObjectTypeID, ObjectID, TypeRateuse, PlanFirstDate, false) / 100;   

   // Определим тим базы
   // Для этого возьмем значение тарифа
   VAR Var1 = 0, Var2 = 0;
   VAR RSDcmd = RsdCommand(RslDefCon, 
   " DECLARE " +
     " retty NUMBER; " +
     " TrffVal DTRFFVALUE_DBT%ROWTYPE; " +
   " BEGIN  " +
      " retty := RSI_Loans_TrffAlg.GetTrffValue(TrffVal, :1, :2, :3, :4); " +
      " " +
      " :5 := TrffVal.T_CALENDAR; " +
      " :6 := TrffVal.T_VALUEBASE; " +
   " END; ");
   RSDcmd.addParam("objid", RSDBP_IN, ObjectTypeID);
   RSDcmd.addParam("objn",  RSDBP_IN, ObjectID);
   RSDcmd.addParam("trff",  RSDBP_IN, TypeRateuse);
   RSDcmd.addParam("date",  RSDBP_IN, PlanFirstDate);

   RSDcmd.addParam("calendar",  3, Var1);
   RSDcmd.addParam("valuebase", 3, Var2);

   RSDcmd.execute();

   VAR calendar  = RSDcmd.value("calendar",  NULL, V_INTEGER);
   VAR valuebase = RSDcmd.value("valuebase", NULL, V_INTEGER);

   IF     (calendar == 2) // Месяц
      R = R * 365.25 / (valuebase * 30.4375); // Хитрое число дней в году и число дней в месяце
   ELIF (calendar == 3) // Квартал
      R = R * 365.25 / (valuebase * 91.5); // Хитрое число дней в году и число дней в квартале
   ELIF (calendar == 1) // День
      R = R * 365.25 / (valuebase);
   END;
   // <==

   IF (R != 0.0)
      DateSplit (PlanFirstDate, null, null, m1);
      m2 = m1+1;

      DT = NDays(date(1,1,m2)) - NDays(date(1,1,m1));

      IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
           Loans_FindDuty(ObjectID, rdutycrd);
           Loans_FindCrdContract(rdutycrd.CreditNumber_Ref, rcredit);
      ELSE
           Loans_FindCrdContract(ObjectID, rcredit);
      END;

      IF ((ExistsOperation(ObjectTypeID, ObjectID, CS_PAY) != 0) OR
          (rcredit.Crd_kind == LO_KARTA))
          S = ОстатокРегистра(ObjectTypeID, ObjectID, TDR_MAINREST, {curdate});
      ELSE
          IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
              S = rcredit.CreditSum;
          ELSE
              S = rdutycrd.DutySum;
          END;
      END;

      IF (TypePeriod == 0)
         R = Period * R / 12;
      ELSE
         R = Period * R / DT;
      END;

      d1 = pow ((doubleL(1 + R)), (doubleL(n)));
      d1 = 1 / d1;
      d1 = 1 - d1;
      d1 = (doubleL(R)) / d1;
      d1 = (doubleL(S)) * d1;
      AnnuitSum = round(d1, 2);
   END;

   RETURN AnnuitSum;
END;

// Функция расчета процентов для первого периода в графике погашения при ПЕРЕрасчете графика
// Учитывает недоплаты, начисленные проценты, последний расчет процентов разными операциями и т.п.
private MACRO CalcFirstPeriodInterest (ObjID, ObjN, EndDate:date, RoundOffError)
   VAR lcusrate = TRecHandler("lcusrate.dbt");
   VAR lcusreg  = TRecHandler("lcusreg.dbt");
   VAR RSDcmd   = NULL;

   const LRSDBP_IN_OUT = 3; // Замена отсутствующему RSDBP_IN_OUT

   VAR SystemOperationID = 0,
       НачислПроц        = "",
       ДоначПроц         = "",
       TypeRegID         = 0,
       TypeRateID        = 0,
       BegDate           = date(0,0,0),
       Sum      : numeric = $0.0;

   //Получим ставку и регистр для срочных процентов
   LnSqlExec("delete FROM dpercpay_tmp");

   RSDcmd = RsdCommand(RslDefCon, "begin ?:= Loanspercent.CalcPercForGraph(?,?,?); END;");
   RSDcmd.addParam("summ",    LRSDBP_IN_OUT, Sum);
   RSDcmd.addParam("objid",             RSDBP_IN,      ObjID);
   RSDcmd.addParam("objn",              RSDBP_IN,      ObjN);
   RSDcmd.addParam("opdate",            RSDBP_IN,      EndDate);

   RSDcmd.execute();
   Sum   = RSDcmd.value("summ", NULL, V_NUMERIC); //Начисленные

   //Рассчитаем доначисленные проценты

   IF (ValType(RoundOffError) != V_UNDEF)
      RoundOffError = 
      CRSDCommand("SELECT T_ROUNDOFFERROR FROM DPERCPAY_TMP WHERE T_DUTYSTAGE = ? AND T_OBJECTTYPEID = ? AND T_OBJECTNUMBER = ? AND T_BEGINDATE = "
                  "(SELECT MAX(T_BEGINDATE) FROM DPERCPAY_TMP WHERE T_DUTYSTAGE = ? AND T_OBJECTTYPEID = ? AND T_OBJECTNUMBER = ?)", 
                  "p1", DS_PERC,
                  "p2", ObjID,
                  "p3", ObjN,
                  "p4", DS_PERC,
                  "p5", ObjID,
                  "p6", ObjN,
                 V_NUMERIC);
      SetParm(3, RoundOffError);
   END;

   RETURN Sum;

   OnError
      RETURN $0;
END;

/**
*    Функция определяет, были ли выдачи по объекту.
*    Для СО учитываются пролонгации.
*/
PRIVATE MACRO isWasPayForObject(ObjID:integer, ObjN:integer)
   VAR RSDcmd:object = null, rs:object = null;
   VAR isWasPay:bool = false;
   
   IF((ObjID == LO_DUTY)OR(ObjID == LO_BANKGUARANTEE))
       RSDcmd = RsdCommand (RslDefCon," SELECT d1.t_dutyid "+
                                      "   FROM dduty_crd_dbt d1, dduty_crd_dbt d2 "+
                                      "  WHERE d2.t_dutyid = ? "+
                                      "    AND d1.t_creditnumber_ref = d2.t_creditnumber_ref "+
                                      "    AND d1.t_firstdutyid_ref = d2.t_firstdutyid_ref "+
                                      "    AND d1.t_dutytype = d2.t_dutytype "+
                                      "    AND d1.t_systtype = d2.t_systtype "+
                                      "    AND d1.t_dutyid <= d2.t_dutyid ");
       RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjN;
      
       rs = null;
       rs = RsdRecordset (RSDcmd);
       RSDcmd.execute();
      
       WHILE ((rs != null) AND (not isWasPay) AND (rs.MoveNext()))
           IF (ExistsOperation(ObjID, rs.Value("t_dutyid"), CS_PAY) > 0)
               isWasPay = true;
           END;
       END;
   ELSE
       IF (ExistsOperation(ObjID, ObjN, CS_PAY) > 0)
           isWasPay = true;
       END;
   END;

   RETURN isWasPay;

   OnError
      RETURN false;
END;

/**
*    Если первая дата ОД по графику меньше, чем первая дата процентов, то функция возвращает дату ОД.
*    Иначе - date(0,0,0)
*/

PRIVATE MACRO isDutyLessThenPerc(ObjID:integer, ObjN:integer, Exp_CalcExpPercDate:integer, TypeGr: integer)
   VAR RSDcmd:object = null, rs:object = null;
   VAR isWasPay:bool = false;
   VAR FirstDutyDate:date = date(0,0,0), 
       FirstPercDate:date = date(0,0,0);

   IF (ValType(TypeGr) != V_INTEGER)
      TypeGr = 0;
   END;

   // Из графика погашения ОД найдем дату первого погашения ОД
   FirstDutyDate = CRSDCommand(" SELECT CASE ? "+
                                        "      WHEN 1 THEN MIN (t_PlannedPayDate) "+ //Расчет %% по дату платежа
                                        "      ELSE MIN (t_PlannedExpDate) "+
                                        "   END DT "+ 
                                        "  FROM dplan_pay_tmp " +
                                        " WHERE t_credoperid_ref = ? " +
                                        "   AND t_type = ? " +
                                        "   AND t_objecttypeid_ref = ? " +
                                        "   AND t_objectid_ref = ? ",
                           "p1", Exp_CalcExpPercDate, 
                           "p4", 0,
                           "p5", 0,
                           "p2", ObjID, 
                           "p3", ObjN, 
                            V_DATE);
  
   IF (TypeGr == 0)
      // Из графика погашения %% найдем дату первого погашения %%
      FirstPercDate = CRSDCommand(" SELECT CASE ? "+
                                        "      WHEN 1 THEN MIN (t_PlannedPayDate) "+ //Расчет %% по дату платежа
                                        "      ELSE MIN (t_PlannedExpDate) "+
                                        "   END DT "+ 
                                        "  FROM dplanmac_tmp " +
                                        " WHERE t_credoperid_ref = 0 " +
                                        "   AND t_objecttypeid_ref = ? " +
                                        "   AND t_objectid_ref = ? ",

                           "p1", Exp_CalcExpPercDate, 
                           "p2", ObjID, 
                           "p3", ObjN, 
                            V_DATE);
   ELSE
      FirstPercDate = CRSDCommand(" SELECT CASE ? "+
                                        "      WHEN 1 THEN MIN (t_PlannedPayDate) "+ //Расчет %% по дату платежа
                                        "      ELSE MIN (t_PlannedExpDate) "+
                                        "   END DT "+ 
                                        "  FROM dplan_pay_tmp " +
                                        " WHERE t_credoperid_ref = ? " +
                                        "   AND t_type = ? " +
                                        "   AND t_objecttypeid_ref = ? " +
                                        "   AND t_objectid_ref = ? ",
                           "p1", Exp_CalcExpPercDate, 
                           "p4", 0,
                           "p5", TypeGr,
                           "p2", ObjID, 
                           "p3", ObjN, 
                            V_DATE);

   END;

   IF (FirstDutyDate < FirstPercDate)
       RETURN FirstDutyDate;
   END;

   RETURN date(0,0,0);

   OnError
      RETURN date(0,0,0);
END; 

/* Функция расчета аннуитета по буферу операции расчета графика */
private MACRO РассчитатьАннуитет(ObjectTypeID:integer, ObjectID:integer, _calcgpay, Перерасчет:bool)
   RETURN CalcAnnuit(ObjectTypeID,
                     ObjectID,
                    _calcgpay.PAY_PlanCountPay,
                    _calcgpay.PAY_PlanFirstDate,
                    _calcgpay.PAY_PlanLastDate,
                    _calcgpay.PAY_TypePeriod,
                    _calcgpay.PAY_Period,
                      Перерасчет,
                    _calcgpay.IsPrivelege)
END;

// The function emits an exception when error occurs
PRIVATE MACRO Loans_IsHoliday(testdt: date)
   const FAULTFLAG: integer = -1;

   VAR ihol = IsHoliday(testdt);
   IF (ihol == FAULTFLAG)
      // Oops! something going wrong
      RunError("Ошибка при работе с календарем");
   END;

   RETURN ihol;
END;

/*
  Параметры для аннуитетного графика:
  r - процентная ставка за период погашения в долях от годовой;
  P - годовая процентная ставка;
  D - фактическое кол-во дней в году;
  A - сумма ежемесячного платежа (аннуитет);
*/

MACRO СформироватьГрафик (ObjID, ObjN, _typegr, Sum, _ReCalc_, type, Rate, buff, ForDeltaSum, Annuit, AnnuitPeriodCount : integer, Opdate: date, Privilege: bool)
  VAR mon, year,
      TmpIns: bool,
      Rest:moneyl,
      paydate:date,            /* дата планового платежа */
      tmpdate:date,
      DT:date,
      First:bool = true,
      FirstG:bool = true,
      FirstGT:bool = true,
      Flag:integer = 0,
      FlagG:bool = true,
      FlagGT:bool = true,
      FirstPercPay:bool = true,
      stat:bool = false,
      ForSum         : bool    = false,
      IsPay:bool = false,
      RateID:integer = 0,
      RateID_Ref:integer = 0,
      OpExp:integer = 0,
      OpDuty:integer = 0,
      OpPerc:integer = 0,
      TypeGr_:integer= 0,
      IsUpd : bool = true,
      tmpObjectID:integer,
      tmpObjectTypeID:integer,
      SOIDstr: string,
      VOCO  : bool = false,
      VOKD  : bool = true,
      PercObjList : TArray = TArray(),
      KDODGraf : TArray = TArray(),
      ODGraf : TArray = TArray(),
      Si : money, Sin : money, Sodj : money, Skj : money,
      fori : integer = 0, 
      forj : integer = 0, 
      forn : integer = 0, 
      fork : integer = 0,
      RoundOffError: moneyL = 0.0,
      SumFromPlanPay: money = 0,
      RsDutyRest = NULL,
      i = 1,
      RealArrearDate,
      СуммаПлатежа = $0, СуммаПроцентов = $0, D : Integer, pyear : Integer, k : DoubleL, P:DoubleL,
      ЕжегоднаяПролонгация : bool = false,
      НарушениеАннуитета   : bool = false,
      ДатаПоследнегоПлатежа  : date = date(0,0,0),
      ДатаПоследнейПросрочки : date = date(0,0,0),
      СуммаПоследнегоПлатежа : numeric = $0,
      extpays                : integer =  0,
      plpay_sel              : object  = null,
      FirstPayDate           : date    = null,
      plRestSum              : numeric = $0,
      Переплата              : numeric = $0,
      r : DoubleL, ti : Integer, _PrevDate_, TotSum = $0, PercRateID, PercRateType;

     VAR TypePercRate = 0; // тип процентной ставки
     VAR PlannedPayDate: date;
     VAR {PercOut};        /* НАЧИСЛ_ИСХ_ПРАВУЮ_ВКЛЮЧАТЬ */
     VAR CredOperID = 0;
     VAR DutyForm = DF_BY_TRANCHES; // формирование СО = по траншам

     VAR ST1: bool = false,
         ST2: bool = false;

     VAR FirstPay = $0;

     VAR NewAnnuitAlg,iter,curPeriodCount,retVal;
     VAR RSDcmd : object = null, RSDcmd1 : object = null,;
     VAR rs;
     VAR SD:money, SP:money;

     VAR isStartNewAnnuit:bool = false; //Если нет подходящих параметров настройки аннуитетных графиков, то новый режим расчета не включается

   /* SAE 04.11.00 */
   /* Получение следующего рабочего дня, вслед за выходным */
   MACRO GetDay (ExpDay:integer, dt:date)
      VAR ODate = dt;
      VAR LastDate  : date,
          FirstDate : date;

      IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
         FirstDate = Обязательство.DutyFirstDate;
         LastDate  = Обязательство.DutyLastDate;
      ELSE
         FirstDate = Договор.RegDate;
         LastDate  = Договор.ReturnDate;
      END;

      /* Поиск следующего рабочего */
      IF (ExpDay == EXP_WORKNEXT)
         WHILE (Loans_IsHoliday (ODate))
            ODate = ODate + 1;
         END;

         IF (CheckPlanPay_LastDate)
            IF (ODate > LastDate)    /* Вышли за конец обязательства */
               ODate = dt;
               WHILE (Loans_IsHoliday (ODate))  /* Идём назад */
                  ODate = ODate - 1;
               END;

               IF (ODate < FirstDate) /* Вышли за начало обязательства */
                  ODate = dt;
               END;
            END;
         END;

      /* Поиск предыдущего рабочего */
      ELIF (ExpDay == EXP_WORKPREV)
         WHILE (Loans_IsHoliday (ODate))
            ODate = ODate - 1;
         END;

         IF (ODate < FirstDate)  /* Вышли за начало обязательства */
            ODate = dt;
            WHILE (Loans_IsHoliday (ODate)) /* Идём вперёд */
               ODate = ODate + 1;
            END;

            IF (ODate > LastDate) /* Вышли за конец обязательства */
               ODate = dt;
            END;
         END;
      END;

      RETURN ODate;
   END;

   /* Расчет даты начала периода, с учетом выходных дней
      Параметры:
         i             - Номер платежного периода
         PlanFirstDate - Дата первого платежа для графика
         PlanLastDate  - Дата последнего платежа для графика
         PlanCountPay  - Количество плановых платежей
         TypePeriod    - Тип периода
         Period        - Период погашения для графика
         ArrearDate    - Не позднее
         ExpDay        - День выноса на просрочку     (любой/...)
   */
   MACRO CalcPayDate(i          : integer,
                     FirstDate  : date,
                     LastDate   : date,
                     CountPay   : integer,
                     TypePeriod : integer,
                     Period     : integer,
                     ArrearDate : integer,
                     ExpDay     : integer,
                     OpDuty     : integer,
                     OpExp      : integer
                     )

      IF (ValType(OpDuty) == V_UNDEF)
          OpDuty = CS_DUTY;
      END;

      IF (ValType(OpExp) == V_UNDEF)
          OpExp = CS_EXP;
      END;

      /* Если первый период */
      IF (i == 1)
         paydate = FirstDate;

         _PrevDate_ = date(0,0,0);

         IF (Rate == 0.0)
            CredOperID = 0;
            IF (NextOpSystType(First, ObjectID, Операции, OpDuty, false, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID))
               _PrevDate_ = Операции.rec.CredOperDate;
            END;

            First = true;
            CredOperID = 0;
            WHILE (NextOpSystType(First, ObjectID, Операции, OpExp, true, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID))
               IF (Операции.rec.CredOperDate > _PrevDate_)
                  _PrevDate_ = Операции.rec.CredOperDate;
               END;
            END;
         END;

         IF (_PrevDate_ == date(0,0,0))
            IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
               _PrevDate_ = Обязательство.DutyFirstDate;
            ELSE
               _PrevDate_ = Договор.RegDate;
            END;
         END;
      // Если последний платеж //
      ELSE
         IF (TypePeriod == 0)
            mon = mon + Period;
            IF ( mon > 12 )
              mon = mon - 12;
              year = year + 1;
            END;
            /*добавлено формир графика по последнему раб.дню месяца*/
            RealArrearDate = ДеньВыносаНаПросрочку(ArrearDate, Date(1,mon,year));
            paydate = Date( RealArrearDate, mon, year );
         ELSE
            paydate = paydate + Period;
         END;
      END;

      IF (paydate > LastDate)
         paydate = LastDate;
      END;

      IF ((ExpDay != EXP_ANY) AND Loans_IsHoliday (paydate))
         paydate = GetDay (ExpDay, paydate);
      END;

      RETURN paydate;
   END;

// функция для вставки записи во временную таблицу planpay_tmp
   MACRO InsertPlanPayTmp (Rate_:integer, Rest_:money, Date_:date, Marker_:string)
      planpay_tmp.Clear();
      planpay_tmp.Rec.RateID = Rate_;
      planpay_tmp.Rec.Rest   = Rest_;
      planpay_tmp.Rec.Date   = Date_;
      planpay_tmp.Rec.Marker = Marker_;
      planpay_tmp.Insert();
   END;

///////////////////////////////////////////////////////////////////////////////////////
   // ДЕПОЗИТЫ: график выплаты/причисления %%
   MACRO CalcGraphDepPerc (ObjType, ObjNum, TypeGraph, SumGraph, RateVal)     
      VAR NumPeriod : integer = 1; // номер расчетного периода
      VAR BegDateCalcPerc : date    = date (0,0,0); // дата начала расчета поцентов
      VAR lcusreg  = TRecHandler("lcusreg.dbt");
      const LRSDBP_IN_OUT = 3; // Замена отсутствующему RSDBP_IN_OUT
      VAR rs = null, rs2 = null;
      VAR RSDcmd = null, RSDcmd2 = null;
      VAR addperc:bool = false; //причисление процентов
      VAR  SystemOperationID = 0;
      VAR  TypeRegID         = 0;
      VAR  TypeRateID        = 0;
      VAR  Sum      : numeric = $0.0;
      VAR  PaySum   : numeric = $0.0;
      VAR  RestNoPay: numeric = $0.0;
      VAR  RoundOffError: NUMERIC = $0.0;

      RSDcmd = RsdCommand (RslDefCon," delete FROM dplan_pay_tmp" +
         " WHERE t_credoperid_ref = ?" +
         " AND t_type = ?" +
         " AND t_objecttypeid_ref = ?" +
         " AND t_objectid_ref = ?"
      );
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = 0;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = 0;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = ObjType;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(3) = ObjNum;
      rs  = RsdRecordset (RSDcmd);
      RSDcmd.execute;

      BegDateCalcPerc = Договор.Regdate;

      ClearRecord (График);
      График.ObjectTypeID_Ref = ObjType;
      График.ObjectID_Ref     = ObjNum;
      График.CredOperID_ref   = 0;
      График.Type             = TypeGraph;
      График.PlannedPaySum    = SumGraph;

      // инициализация глобальных переменных для CalcPayDate
      DateSplit (calcgpay.PERC_PlanFirstDate, null, mon, year);

      RSDcmd2 = RsdCommand (RslDefCon," SELECT t_addpercent FROM dparmdepo_dbt" +
         " WHERE t_objecttypeid = ?" +
         " AND t_objectnumber = ?"
      );
      RSDcmd2.addParam ("", RSDBP_IN); RSDcmd2.value(0) = ObjType;
      RSDcmd2.addParam ("", RSDBP_IN); RSDcmd2.value(1) = ObjNum;
      rs = null;
      rs = RsdRecordset (RSDcmd2);
      RSDcmd2.execute();
      IF ((rs != null) AND (rs.MoveNext()))
         IF (rs.value(0, null, V_STRING) == "X")
            addperc = true;
         END;
      END;

      WHILE (NumPeriod <= CalcGPay.PERC_PlanCountPay)

         График.PlannedPayDate = CalcPayDate (NumPeriod,
            calcgpay.PERC_PlanFirstDate,
            calcgpay.PERC_PlanLastDate,
            calcgpay.PERC_PlanCountPay,
            calcgpay.PERC_TypePeriod,
            calcgpay.PERC_Period,
            calcgpay.PERC_ArrearDate,
            calcgpay.Pay_PayDay
         );
         График.PlannedPayDate = min (График.PlannedPayDate, calcgpay.PERC_PlanLastDate);

         IF (
              (NumPeriod == 1)  AND
              (ExistsOperationForCredNum(Договор.CreditNumber, CS_DEPOPAYM) > 0)
             )

            SystemOperationID = cs_recalcgpay;
            TypeRegID  = tdr_depohist;

            IF (not Loans_FindLCURG(ObjType, ObjNum, TypeRegID, 0, lcusreg))
              RETURN $0;
            END;

            BegDateCalcPerc = RunStoredFunc("Loansfillpayment.calcbegpercdate", V_DATE, NULL, ObjType, ObjNum, TDR_DEPOHIST, TRU_DEPOPERC);

            LnSqlExec("delete FROM dpercpay_tmp");

            RSDcmd = RsdCommand(RslDefCon, "begin Loansfillpayment.ds_dep48_mac(?,?,?,?,?,?,?,?,?,?,?,?,?); END;");
            RSDcmd.addParam("objid",             RSDBP_IN,       ObjType);
            RSDcmd.addParam("objn",              RSDBP_IN,       ObjNum);
            RSDcmd.addParam("opdate",            RSDBP_IN,       График.PlannedPayDate);
            RSDcmd.addParam("regid",             RSDBP_IN,       lcusreg.rec.RegID);
            RSDcmd.addParam("rateid",            RSDBP_IN,       RateID);
            RSDcmd.addParam("begdate",           LRSDBP_IN_OUT,  BegDateCalcPerc);
            RSDcmd.addParam("enddate",           RSDBP_IN,       График.PlannedPayDate);
            RSDcmd.addParam("summ",              LRSDBP_IN_OUT,  Sum);
            RSDcmd.addParam("paysum",            LRSDBP_IN_OUT,  PaySum);
            RSDcmd.addParam("restnopay",         LRSDBP_IN_OUT,  RestNoPay);
            RSDcmd.addParam("systemoperationid", RSDBP_IN,       SystemOperationID);
            RSDcmd.addParam("anticipatory",      RSDBP_IN,       0);
            RSDcmd.addParam("RateVal",           RSDBP_IN,       RateVal);

            RSDcmd.execute();

            График.PlannedPercentSum   = RSDcmd.value("summ", NULL, V_NUMERIC); //Начисленные

            RoundOffError = 
            LnSelectValue("SELECT T_ROUNDOFFERROR FROM DPERCPAY_TMP WHERE T_RATEID = " + RateID +  " AND T_BEGINDATE = "
                "(SELECT MAX(T_BEGINDATE) FROM DPERCPAY_TMP WHERE T_RATEID = " + RateID + ")", V_NUMERIC);
         ELSE
            RSDcmd = null;
            RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplanpay_tmp ");
            RSDcmd.execute;

            InsertPlanPayTmp (RateID, График.PlannedPaySum, BegDateCalcPerc, "");
            InsertPlanPayTmp (RateID, 0, График.PlannedPayDate, "X");

            График.PlannedPercentSum = Money(RSL_РасчетГрафикаПроцентов(RateID, BegDateCalcPerc, График.PlannedPayDate, RateVal, ObjType, ObjNum, RoundOffError));
         END;
         IF (addperc)
            График.PlannedPaySum = Money(График.PlannedPaySum + График.PlannedPercentSum);
         END;
         Insert (График);

         BegDateCalcPerc = График.PlannedPayDate;
         NumPeriod = NumPeriod + 1;
      END;
   END; // CalcGraphDepPerc
///////////////////////////////////////////////////////////////////////////////////////////
   ObjectTypeID = ObjID;
   ObjectID = ObjN;
   TypeGr   = _typegr;
   SetBuff(calcgpay, buff);
   AnnuitTRN = Annuit;

   RSDcmd = RsdCommand(RslDefCon, "SELECT T.t_Duty FROM dparmdemandline_dbt T WHERE t.t_ObjectTypeID = ? AND t.t_ObjectNumber = ?");
   RSDcmd.addParam("t.t_ObjectTypeID", RsdBp_in); RSDcmd.value(0) = Договор.Crd_Kind;
   RSDcmd.addParam("t.t_ObjectNumber", RsdBp_in); RSDcmd.value(1) = Договор.CreditNumber;
   RSDcmd.execute;

   rs = RsdRecordset(RSDcmd);
   IF (rs.moveNext)
       DutyForm = rs.value(0, NULL, V_INTEGER);
   END;

   // режим работы со срочниками
   IF ((ObjectTypeID == LO_CREDIT) AND (DutyForm == DF_BY_ACCOUNT))
       SuperDuty = true;
   END;

   IF (_ReCalc_ == 2)
      FindGoodPayGraph = TRUE;
      RETURN 0;
   ELIF (_ReCalc_ == 0)
      ReCalc = false;
   ELIF (_ReCalc_ == 1)
      ReCalc = true;
   ELSE
      ReCalc = false;
   END;

   RSDcmd = null;
   RSDcmd = RsdCommand (RslDefCon, " delete FROM dplanmac_tmp ");
   RSDcmd.execute;

   IF (ObjectTypeID != LO_DEPOSIT)
      IF ((ObjectTypeID != LO_GUARANTEE)AND(ObjectTypeID != LO_BANKGUARANTEE))
          /*поиск использования регистра*/
          Loans_FindLCURG(ObjectTypeID, ObjectID, TDR_MAINREST, 0, lcusreg);
 
          /*поиск использования ставки*/
          Loans_FindLCUR(ObjectTypeID, ObjectID, TRU_CRD, 0, rlcusrate);
      ELSE
          /*поиск использования регистра*/
          Loans_FindLCURG(ObjectTypeID, ObjectID, TDR_PAYMGUARANTEE, 0, lcusreg);
 
          /*поиск использования ставки*/
          Loans_FindLCUR(ObjectTypeID, ObjectID, TRU_PAYMGUAR, 0, rlcusrate);
      END;
   ELSE
       // поиск использования ставки
       Loans_FindLCUR (ObjectTypeID, ObjectID, TRU_DEPOPERC, 0, rlcusrate);
   END;

   // Стандартная ставка и алгоритм
   RateID = rlcusrate.RateID_Ref;
   IF (
      (type == GPAY_PERC) // расчет %%
      OR
      (type == GPAY_PERCEQDUTY) // %% == ОД
     )
      IF (calcgpay.PERC_PlanFirstDate == date(0,0,0))
          calcgpay.PERC_PlanFirstDate = opdate;
      END;

      IF (SuperDuty)
         // Если это КД, то пробежимся всем его СО, вдруг ставки-алгоритмы заданы там
         IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
            // Если это КД, то перебрать все его со, может ставки-алгоритмы заданы по СО.
            rs = CRSDCommand("SELECT T_DUTYID FROM DDUTY_CRD_DBT WHERE T_CREDITNUMBER_REF = ? ORDER BY T_DUTYID",
                             "p1", ObjectID,
                             V_GENOBJ);
            WHILE (rs.moveNext())
               RateID = 0;

               // поиск использования ставки
               IF (Loans_FindLCUR(ObjectTypeID, rs.value(0, NULL, V_INTEGER), TRU_CRD, 0, sorlcusrate))
                  RateID = sorlcusrate.RateID_Ref;
               END;
               
               IF (solcusreg.ID)
                  i = PercObjList.Size;
                  PercObjList(i)              = PercObject();
                  PercObjList(i).ObjectID     = ObjectTypeID;
                  PercObjList(i).ObjectNumber = rs.value(0, NULL, V_INTEGER);
                  PercObjList(i).RegID        = solcusreg.ID;
 
                  // Если к СО привязана ставка, то используем её, иначе использовать ставку из КД
                  IF (RateID != 0)
                     VOCO = true;
                  ELSE
                     RateID = rlcusrate.RateID_Ref;
                  END;
                  PercObjList(i).RateID = RateID;
               END;
            END; // WHILE(rs.moveNext())
 
            // если ни по одному СО не задана индивидуальная ставки или алгоритм, то считать надо по КД
            // для этого очистим массив объектов-ставок-алгоритмов и добавим в него одну запись соответствующую КД
            IF (VOCO == false)
               PercObjList.Size = 0;
               // если по КД задана ставка
               IF (VOKD)
                  i = PercObjList.Size;
                  PercObjList(i)              = PercObject();
                  PercObjList(i).ObjectID     = ObjectTypeID;
                  PercObjList(i).ObjectNumber = ObjectID;
                  PercObjList(i).RateID       = rlcusrate.RateID_Ref;
                  PercObjList(i).RegID        =  lcusreg.ID;
               END; // IF (VOKD)
            END; // IF (VOCO == false)
         END; // IF (ObjectTypeID != LO_DUTY)
      ELSE // IF (superduty)
         IF (VOKD)
            i = PercObjList.Size;
            PercObjList(i)              = PercObject();
            PercObjList(i).ObjectID     = ObjectTypeID;
            PercObjList(i).ObjectNumber = ObjectID;
            PercObjList(i).RateID       = rlcusrate.RateID_Ref;
            PercObjList(i).RegID        = lcusreg.ID;
         END;
      END;  // IF (superduty)

      // Если ни по одному объекту ставок не найдено
      IF (PercObjList.Size == 0)
         MsgBox ("По объекту не заданы алгоритмы расчета процентов!");
         RETURN 1;
      END;
   END;
 
   Операции.rewind();
   First = true;
   CredOperID = 0;
 
   IF (ObjectTypeID != LO_DEPOSIT)
      IF ((ObjectTypeID != LO_GUARANTEE)AND(ObjectTypeID != LO_BANKGUARANTEE))
         OpDuty = CS_PAY;
      ELSE
         OpDuty = CS_GUARPAY;
      END;
 
      WHILE (NextOpSystType(First, ObjectID, Операции, OpDuty, true, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID) AND not IsPay)
         IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
            IF (GetCopStage (Операции.rec.CredOperID) == CF_COMPLIT)
               IsPay = true;
            END;
         ELSE
            IF (CheckDutyID_Hist(Обязательство.DutyID, Операции.rec.ObjectID_Ref) AND
               (GetCopStage (Операции.rec.CredOperID) == CF_COMPLIT))
               IsPay = true;
            END;
         END;
      END;
 
      IF ((Договор.FullDuration > КоличествоМесяцев(Договор.RegDate, Договор.ReturnDate))
           AND (Договор.PrivilegeFlag == "X")
           AND (Договор.PayType == CF_NONREP))
         ЕжегоднаяПролонгация = true;
         calcgpay.PAY_PlanCountPay  = calcgpay.PAY_PlanCountPay + 1;
         calcgpay.PERC_PlanCountPay = calcgpay.PERC_PlanCountPay + 1;
      END;
   END;
 
   IF (type == GPAY_DEP_PERC) // ДЕПОЗИТЫ: график выплаты/причисления %%
      CalcGraphDepPerc (ObjID, ObjN, _typegr, Sum, Rate);
      RETURN 0;
   END;
 
   /* Основной долг в конце срока */
   IF (type == GPAY_DUTYLAST)
      IF (calcgpay.GraphLim == "X")
          RETURN 0;
      END;
 
      ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
      ГрафикTmp.ObjectTypeID_Ref = ObjectTypeID;
      ГрафикTmp.ObjectID_Ref     = ObjectID;
      ГрафикTmp.Type             = TypeGr;
 
      IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
         ГрафикTmp.PlannedPayDate = Обязательство.DutyLastDate;
         paydate = Обязательство.DutyFirstDate;
      ELSE
         ГрафикTmp.PlannedPayDate = Договор.ReturnDate;
         paydate = Договор.RegDate;
      END;
      ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate;
 
      IF (calcgpay.VID == GS_ABSOLU)/*ГП в абсолютных суммах*/
         /*SCR 10001 */
         ГрафикTmp.PlannedPaySum  = Sum;
         IF (Sum == $0)
            IF (SuperDuty)
               ГрафикTmp.PlannedPaySum = GetDutyRestForGraph(ObjectTypeID, Договор.CreditNumber, Договор.ReturnDate);
            ELSE
               IF (/*ReCalc AND*/ IsPay)
                  IF (ObjectTypeID != LO_GUARANTEE)
                     ГрафикTmp.PlannedPaySum  = ОстатокСО(Обязательство.DutyID, TDR_MAINREST, ГрафикTmp.PlannedPayDate) + ОстатокРегистра(LO_CREDIT, Договор.CreditNumber, TDR_MAINREST, ГрафикTmp.PlannedPayDate);
                  ELSE
                     ГрафикTmp.PlannedPaySum  = ОстатокРегистра(LO_GUARANTEE, Договор.CreditNumber, TDR_PAYMGUARANTEE, ГрафикTmp.PlannedPayDate);
                  END;
               ELSE
                  IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
                     ГрафикTmp.PlannedPaySum  = Обязательство.DutySum;
                  ELSE
                     ГрафикTmp.PlannedPaySum  = Договор.CreditSum;
                  END;
               END;
            END;
         END;
         calcgpay.Sum = ГрафикTmp.PlannedPaySum;
      ELSE
          IF (calcgpay.VID == GS_PART) /*ГП в долях*/
              ГрафикTmp.ShareSum = 1;
          ELSE
              ГрафикTmp.ShareSum = 100; /*ГП в %%*/
          END;
      END;
 
      calcgpay.PAY_PlanLastDate = ГрафикTmp.PlannedPayDate;
 
      IF (Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
         ГрафикTmp.PlannedPayDate = GetDay (EXP_WORKNEXT, ГрафикTmp.PlannedPayDate);
      END;
 
      IF (Loans_IsHoliday (ГрафикTmp.PlannedExpDate))
         ГрафикTmp.PlannedExpDate = GetDay (EXP_WORKNEXT, ГрафикTmp.PlannedExpDate);
      END;
 
      Insert(ГрафикTmp);
 
      IF (NOT RtTrn("TrnInsGPayDuty"))
          MsgBox("Ошибка при расчете графика погашения");
          RETURN 1;
      END;
 
   // Проценты в конце срока F11
   ELIF (type == GPAY_PERCLAST)

      IF (SuperDuty)
         tmpObjectTypeID = ObjectTypeID;
         tmpObjectID     = ObjectID;

         IF (ObjectTypeID == LO_CREDIT)
            CRSDCommand("UPDATE DPLAN_PAY_TMP SET T_PLANNEDPERCENTSUM = 0 WHERE " +
                        " T_OBJECTTYPEID_REF = ? AND T_OBJECTID_REF = ? ",
              "p1", ObjectTypeID,
              "p2", ObjectID,
              V_GENOBJ);
         END;

         RS = CRSDCommand(
         "SELECT * FROM DLCUSRATE_DBT LR WHERE (LR.T_OBJECTID_REF, LR.T_CREDOBJID_REF) IN " +
         "( " +
           "SELECT ?, ? FROM DUAL " +
           "UNION ALL " +
           "SELECT ?, T_DUTYID FROM DDUTY_CRD_DBT dc WHERE DC.T_CREDITNUMBER_REF = ? " +
         ") " +
         "AND LR.T_TYPERATEID_REF = ? " +
         "ORDER BY 1 DESC, 2 ASC",
         "p1", ObjectTypeID, "p2", ObjectID,
         "p3", LO_DUTY,      "p4", ObjectID,
         "p5", LO_CREDIT, 
          V_GENOBJ);

         WHILE (RS.MoveNext())
            IF (RS.Value("T_OBJECTID_REF", NULL, V_INTEGER) == LO_DUTY)
               // 1. Отключаем супер режим.
               SuperDuty = false;

               CRSDCommand("DELETE  FROM DPLAN_PAY_TMP WHERE T_OBJECTTYPEID_REF = ? AND T_OBJECTID_REF = ? ",
                 "p1", RS.Value("T_OBJECTID_REF",  NULL, V_INTEGER),
                 "p2", RS.Value("T_CREDOBJID_REF", NULL, V_INTEGER),
                 V_GENOBJ);

               // 2. Делаем дубликат ГП ОД для СО
               CRSDCommand("INSERT INTO DPLAN_PAY_TMP " +
               "(" +
                 "T_OBJECTTYPEID_REF, T_OBJECTID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, " +
                 "T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM " +
               ")" + 
               " SELECT " + 
                 "?,  ?, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, " +
                 " T_PLANNEDPAYSUM, 0, 0, T_TYPE, T_SHARESUM FROM DPLAN_PAY_TMP WHERE " +
                 " T_OBJECTID_REF = ? AND T_OBJECTTYPEID_REF = ?",
                 "p1", RS.Value("T_OBJECTID_REF",  NULL, V_INTEGER),
                 "p2", RS.Value("T_CREDOBJID_REF", NULL, V_INTEGER),
                 "p3", ObjectID,
                 "p4", ObjectTypeID,
                 V_GENOBJ);

                 Loans_FindDuty(RS.Value("T_CREDOBJID_REF", NULL, V_INTEGER), Обязательство);

               СформироватьГрафик (RS.Value("T_OBJECTID_REF",  NULL, V_INTEGER), 
                                   RS.Value("T_CREDOBJID_REF", NULL, V_INTEGER), 
                                  _typegr, 
                                   Sum, 
                                  _ReCalc_, 
                                   type, 
                                   RS.Value("T_RATEID_REF", NULL, V_INTEGER), 
                                   buff, 
                                   ForDeltaSum, 
                                   Annuit, 
                                   AnnuitPeriodCount, 
                                   Opdate,
                                   Privilege);

               // Перенести данные в ГП по КД
               CRSDCommand(
               "MERGE INTO DPLAN_PAY_TMP R1 " + 
               "USING (SELECT * FROM DPLAN_PAY_TMP WHERE T_OBJECTTYPEID_REF = ? AND T_OBJECTID_REF = ?) R2 " + 
               "ON (R1.T_PLANNEDPAYDATE = R2.T_PLANNEDPAYDATE " + 
               "AND R1.T_PLANNEDEXPDATE = R2.T_PLANNEDEXPDATE " + 
               "AND R1.T_OBJECTID_REF     = ?  " + 
               "AND R1.T_OBJECTTYPEID_REF = ?) " + 
               "WHEN MATCHED     THEN " + 
                  " UPDATE SET R1.T_PLANNEDPERCENTSUM = R1.T_PLANNEDPERCENTSUM + R2.T_PLANNEDPERCENTSUM " + 
               "WHEN NOT MATCHED THEN " + 
                  " INSERT " + 
               "(" +
                 "T_OBJECTID_REF,  T_OBJECTTYPEID_REF, T_CREDOPERID_REF, T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, " +
                 "T_PLANNEDPAYSUM, T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, T_SHARESUM " +
               ")" + 
               " VALUES " + 
               "(  ?,  ?, R2.T_CREDOPERID_REF, R2.T_PLANNEDPAYDATE, R2.T_PLANNEDEXPDATE, R2.T_PLANNEDPAYSUM, " + 
                 " R2.T_PLANNEDPERCENTSUM, R2.T_PLANNEDPAYSUMEX, R2.T_TYPE, R2.T_SHARESUM " +
               ")",
                 "p1", RS.Value("T_OBJECTID_REF",  NULL, V_INTEGER),
                 "p2", RS.Value("T_CREDOBJID_REF", NULL, V_INTEGER),
                 "p3", tmpObjectID,
                 "p4", tmpObjectTypeID,
                 "p5", tmpObjectID,
                 "p6", tmpObjectTypeID,
                 V_GENOBJ);

               CRSDCommand("DELETE  FROM DPLAN_PAY_TMP WHERE T_OBJECTTYPEID_REF = ? AND T_OBJECTID_REF = ?",
                 "p1", RS.Value("T_OBJECTID_REF",  NULL, V_INTEGER),
                 "p2", RS.Value("T_CREDOBJID_REF", NULL, V_INTEGER),
                 V_GENOBJ);
            ELSE
               IF (SuperDuty == FALSE)
                  RETURN 0;
               ELSE
                  SuperDuty = TRUE;
                  BREAK;
               END;
            END;
         END;
                          
         IF (SuperDuty == FALSE)
            RETURN 0;
         END;
      END;

      LnSqlExec ("delete FROM dplan_pay_tmp WHERE t_objectid_ref = " + string(ObjectID) +
              " AND t_objecttypeid_ref = " + string(ObjectTypeID) +
              " AND t_type = " + string(TypeGr) +
              " AND t_PlannedPaySum = 0");
 
      RSDcmd = null;
      RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplanpay_tmp ");
      RSDcmd.execute;
 
      ClearRecord (ГрафикTmp);   /*чистим буфер для новой записи*/
      ГрафикTmp.ObjectTypeID_Ref = ObjectTypeID; /*тип объекта*/
      ГрафикTmp.ObjectID_Ref     = ObjectID;     /*номер объекта*/
      ГрафикTmp.Type             = TypeGr;
      CredOperID  = 0;                          /*id операции*/
 
      IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
         ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate = Обязательство.DutyLastDate;
         paydate = Обязательство.DutyFirstDate;
      ELSE
         ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate = Договор.ReturnDate;
         paydate = Договор.RegDate;
      END;
 
      // Если не определен расчет просрочки %% по дату (платежа/просрочки)
      IF (calcgpay.Exp_CalcExpPercDate == 0)
         type_crd_dbt.Rewind();
         WHILE ((calcgpay.Exp_CalcExpPercDate == 0) AND type_crd_dbt.Next()) /*ищем по типу кредита*/
            IF (type_crd_dbt.Rec.CreditTypeID == Договор.CreditTypeID_Ref)
               IF (type_crd_dbt.Rec.CalcExpPercDate != 0)
                   calcgpay.Exp_CalcExpPercDate = type_crd_dbt.Rec.CalcExpPercDate;
               ELSE // по умолчанию расчитываем по дату платежа
                   calcgpay.Exp_CalcExpPercDate = 1;
               END;
            END;
         END;
      END;
 
      IF ((calcgpay.VID == GS_ABSOLU) AND (calcgpay.GraphLim != "X"))/*ГП в абсолютных суммах и не по графику ЛЗ*/
         IF (calcgpay.Sum == 0)// определяем сумму задолженности
            IF (SuperDuty)
                Rest = GetDutyRestForGraph(ObjectTypeID, Договор.CreditNumber, Договор.ReturnDate);
            ELSE
               IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
                  Rest = Обязательство.DutySum; // сумма СО
               ELSE
                  Rest = Договор.CreditSum; // сумма КД
               END;
            END;
         ELSE
            Rest = calcgpay.Sum;
         END;
 
         IF ((ObjectTypeID != LO_GUARANTEE)AND(ObjectTypeID != LO_BANKGUARANTEE))
            OpDuty = CS_DUTY;
            OpExp  = CS_EXP;
            OpPerc = DS_ADDPERC;
         ELSE
            OpDuty = CS_GUARDUTY;
            OpExp  = CS_GUAREXP;
            OpPerc = DS_PAYMGUARADDPERC;
         END;
 
         IF (ReCalc) /*если перерасчет графика*/
            CredOperID = 0;
            WHILE (NextOpSystType(true, ObjectID, Операции, OpDuty, false, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID))
               paydate = Операции.rec.CredOperDate;
            END;
 
            CredOperID = 0;
            WHILE (NextOpSystType(true, ObjectID, Операции, OpExp, true, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID))
               IF (Операции.rec.CredOperDate > paydate)
                  paydate = Операции.rec.CredOperDate;
               END;
            END;
         ELSE /*учтем недоплаты процентов*/
            CredOperID = 0;
            NextOpSystType(true, ObjectID, Операции, OpDuty, false, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID)
         END;
 
         IF (_ReCalc_)
            ГрафикTmp.PlannedPercentSum = CalcFirstPeriodInterest(ObjectTypeID, ObjectID, paydate);
         END;
 
         TmpIns       = false; /*флаг о произведенной вставки записи в planpay_tmp */
         First        = true;  /*флаг первой записи графика ОД*/
         FirstPercPay = true;  /*флаг первой записи для заполнения planpay_tmp*/
         WHILE (OneStep(First, График, date(0,0,0), 0, 0, date(0,0,0), WayRecalculation))
            IF (FirstPercPay) /*первая запись*/
               FirstPercPay = false;
               // Найдем дату последнего изменения остатка по СО
               IF (SuperDuty)
                  ClearRecord(dutyrest_sd);
                  dutyrest_sd.CreditNumber = Договор.CreditNumber;
                  dutyrest_sd.RegID        = TDR_MAINREST;
                  dutyrest_sd.RestDate     = paydate;
                  stat = GetGE(dutyrest_sd);
                  IF (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                           AND (dutyrest_sd.RegID        == TDR_MAINREST)
                           AND (dutyrest_sd.RestDate < График.PlannedPayDate))
                      // Учтем все изменения ОД по СО до первого погашения ОД по графику
                      WHILE (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                                  AND (dutyrest_sd.RegID == TDR_MAINREST)
                                  AND (dutyrest_sd.RestDate < График.PlannedPayDate))
                         paydate = dutyrest_sd.RestDate;

                         InsertPlanPayTmp (RateID, dutyrest_sd.RestSum, dutyrest_sd.RestDate, "");
                         stat = next (dutyrest_sd);
                      END;
                  ELSE
                     InsertPlanPayTmp (RateID, Rest, paydate, "");
                  END;
               ELSE
                  ClearRecord(dutyrest);
                  dutyrest.ID_Ref   = lcusreg.ID;
                  dutyrest.RestDate = paydate;
                  stat = GetGE(dutyrest);
                  IF (stat AND (dutyrest.ID_Ref == lcusreg.ID)
                          AND (dutyrest.RestDate < График.PlannedPayDate))
                     // Учтем все изменения ОД по СО до первого погашения ОД по графику
                     WHILE (stat AND (dutyrest.ID_Ref == lcusreg.ID)
                                 AND (dutyrest.RestDate < График.PlannedPayDate))
                        Rest    = dutyrest.RestSum;
                        paydate = dutyrest.RestDate;
                        InsertPlanPayTmp (RateID, Rest, dutyrest.RestDate, "");
                        stat = next (dutyrest);
                     END;
                  ELSE
                     InsertPlanPayTmp (RateID, Rest, paydate, "");
                  END;
               END;
            END;
            /*вторая и далее записи*/
            IF ((calcgpay.Exp_CalcExpPercDate == 1) AND /*расчет по дату платежа*/
                (paydate < График.PlannedPayDate)   AND (paydate <= ГрафикTmp.PlannedPayDate) AND
                (Rest > 0))
               Rest = Rest - График.PlannedPaySum;
               InsertPlanPayTmp (RateID, Rest, График.PlannedPayDate, "");
               paydate = График.PlannedPayDate;
 
            ELIF ((calcgpay.Exp_CalcExpPercDate == 2) AND /*расчет по дату просрочки*/
                  (paydate < График.PlannedExpDate)   AND (paydate <= ГрафикTmp.PlannedExpDate) AND
                  (Rest > 0))
               Rest = Rest - График.PlannedPaySum;
               InsertPlanPayTmp (RateID, Rest, График.PlannedExpDate, "");
               paydate = График.PlannedExpDate;
 
            END;
 
            TmpIns = true;
         END;//WHILE
 
         IF (TmpIns)
            LnSqlExec("update dplanpay_tmp set t_marker ='X' WHERE t_date = (SELECT max(t_date) FROM dplanpay_tmp)");
            /*определим дату начала рассчета %*/
            IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
                paydate = Обязательство.DutyFirstDate;
            ELSE
                paydate = Договор.RegDate;
            END;
            РасчетГрафикаПроцентов(RateID, paydate, ГрафикTmp.PlannedPayDate, 0.0, false, ObjectTypeID, ObjectID);
            LnSqlExec("update dplanpay_tmp set t_date = to_date ('" + ГрафикTmp.PlannedPayDate +"', 'dd.mm.yyyy') WHERE t_marker = 'X'");
            planpay_tmp.Clear();
            planpay_tmp.Rec.RateID = RateID;
            planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
            planpay_tmp.Rec.Marker = "X";
 
            IF (planpay_tmp.GetEQ())
               ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum + planpay_tmp.Rec.CalcPercent;
               Insert (ГрафикTmp);
            END;
         END;
      ELSE
          Insert (ГрафикTmp);
      END;
 
      IF (NOT RtTrn("TrnInsGPayPerc"))
          MsgBox("Ошибка при расчете графика погашения");
          RETURN 1;
      END;
 
   // Проценты F6
   ELIF (type == GPAY_PERC)
      // Заполнение массива сумм погашения ОД по КД, надо для генерации графика ОД по СО
      IF (SuperDuty AND (VOCO == TRUE)) // Расчет ГП ОД по СО включенным в КД в рамках 58 заявки
         // Найдем все записи в ГП ОД КД
         rs = CRsdCommand (" SELECT T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM FROM DPLAN_PAY_TMP WHERE " +
                                  " T_CREDOPERID_REF = ? " +
                              " AND T_TYPE = ? " +
                              " AND T_OBJECTTYPEID_REF = ? " +
                              " AND T_OBJECTID_REF = ? " +
                           " ORDER BY T_PLANNEDPAYDATE",
                           "p1", 0, 
                           "p2", 0,
                           "p3", Договор.Crd_kind,
                           "p4", Договор.CreditNumber,
                           V_GENOBJ);
 
         WHILE (rs.MoveNext)
            // заполнение массива сумм погашения ОД по КД
            forn = KDODGraf.size;
            KDODGraf(forn) = KDODGrafType();
            KDODGraf(forn).plannedPayDate = rs.value("T_PLANNEDPAYDATE", FALSE, V_DATE);
            KDODGraf(forn).plannedExpDate = rs.value("T_PLANNEDEXPDATE", FALSE, V_DATE);
            KDODGraf(forn).plannedPaySum  = rs.value("T_PLANNEDPAYSUM",  FALSE, V_MONEY);
         END; // WHILE (rs.MoveNext)
      END; // IF (SuperDuty AND (VOCO == true))
 
      // цикл по СО
      tmpObjectTypeID = ObjectTypeID;
      tmpObjectID     = ObjectID;
      SOIDStr = "";
      FOR (forj, 0, PercObjList.size-1, 1)
         LnSQLExec("DELETE FROM DPLANPAY_TMP");
 
         ObjectTypeID = PercObjList(forj).objectID;
         ObjectID     = PercObjList(forj).objectNumber;
       
         // поиск обязательства
         IF ((VOCO == true) AND ((PercObjList(forj).objectID == LO_DUTY)OR(PercObjList(forj).objectID == LO_BANKGUARANTEE)))
            IF (NOT Loans_FindDuty(PercObjList(forj).objectNumber, Обязательство))
               RETURN;
            END;

            IF (strlen(SOIDStr) > 0)
               SOIDStr = SOIDStr + ",";
            END;
            SOIDStr = SOIDStr + string(PercObjList(forj).objectNumber);
         END;

         // построение графика ОД по СО
         IF (SuperDuty AND (VOCO == true) AND (forn > 0)) // Расчет ГП ОД по СО включенным в КД в рамках 58 заявки
            // цикл по платежным периодам
            FOR (fori, 0, forn/*calcgpay.PAY_PlanCountPay-1*/, 1)
               // получение Sin
               Sin = 0;
               FOR (forn, 0, forj-1, 1)
                  Sin = Sin + PercObjList(forn).GetODGrafSum(fori);
               END; // for(forn, 0, forj-1)
 
               // получение Skj
               Skj = 0;
               FOR (fork, 0, fori-1, 1)
                  Skj = Skj + PercObjList(forj).GetODGrafSum(fork);
               END; // for(fork, 0, fori-1)
 
               Si = KDODGraf(fori).plannedPaySum; // сумма погашения в i-том платежном периоде ГП ОД по КД
 
               Sodj = ОстатокРегистра(PercObjList(forj).objectID, PercObjList(forj).objectNumber, TDR_MAINREST, Opdate);// остаток регистра <История ОД> j-го СО
 
               // сумма погашения по j-му СО в i-том платежном периоде
               PercObjList(forj).AddODGrafRec(min(Si-Sin, Sodj-Skj));
 
               // вставим запись в график ОД по СО
               ClearRecord (ГрафикTmp);
               ГрафикTmp.ObjectTypeID_Ref = PercObjList(forj).objectID;
               ГрафикTmp.ObjectID_Ref     = PercObjList(forj).objectNumber;
               ГрафикTmp.Type             = 0;
               ГрафикTmp.PlannedPayDate   = KDODGraf(fori).PlannedPayDate;
               ГрафикTmp.PlannedExpDate   = KDODGraf(fori).PlannedExpDate;
               ГрафикTmp.PlannedPaySum    = PercObjList(forj).GetODGrafSum(fori);
               Insert(ГрафикTmp);
            END; // for(fori, 0, PercObjList.size-1)
 
            // сохранение ГП обязательства
            IF (NOT RtTrn("TrnInsGPayDuty"))
               MsgBox("Ошибка при расчете графика погашения");
               RETURN 1;
            END;
         END; // IF (SuperDuty AND (VOCO == true))
         DateSplit( calcgpay.PERC_PlanFirstDate, null, mon, year);
 
         i = 1;
         WHILE (i <= calcgpay.PERC_PlanCountPay)
            ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
            ГрафикTmp.ObjectTypeID_Ref = PercObjList(forj).objectID;
            ГрафикTmp.ObjectID_Ref     = PercObjList(forj).objectNumber;
            ГрафикTmp.Type             = TypeGr;
            ГрафикTmp.PlannedPayDate   = CalcPayDate(i,
                                                     calcgpay.PERC_PlanFirstDate,
                                                     calcgpay.PERC_PlanLastDate,
                                                     calcgpay.PERC_PlanCountPay,
                                                     calcgpay.PERC_TypePeriod,
                                                     calcgpay.PERC_Period,
                                                     calcgpay.PERC_ArrearDate,
                                                     calcgpay.Exp_PayDay,
                                                     OpDuty,
                                                     OpExp);
   
            ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate + calcgpay.PERC_PostExpDay;
   
            IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
                IF (ГрафикTmp.PlannedExpDate > Договор.ReturnDate)
                   ГрафикTmp.PlannedExpDate = Договор.ReturnDate;
                END;
                IF (ГрафикTmp.PlannedPayDate > Договор.ReturnDate)
                   ГрафикTmp.PlannedPayDate = Договор.ReturnDate;
                END;
            ELSE
                IF (ГрафикTmp.PlannedExpDate > Обязательство.DutyLastDate)
                   ГрафикTmp.PlannedExpDate = Обязательство.DutyLastDate;
                END;
                IF (ГрафикTmp.PlannedPayDate > Обязательство.DutyLastDate)
                   ГрафикTmp.PlannedPayDate = Обязательство.DutyLastDate;
                END;
            END;
   
   
            IF (
                 ( (ГрафикTmp.PlannedPayDate == Обязательство.DutyLastDate) AND ((PercObjList(forj).objectID == LO_DUTY)OR(PercObjList(forj).objectID == LO_BANKGUARANTEE)) )
               OR
                 ( (ГрафикTmp.PlannedExpDate == Договор.ReturnDate) AND ((PercObjList(forj).objectID != LO_DUTY)AND(PercObjList(forj).objectID != LO_BANKGUARANTEE)) )
               )
               IF (Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
                  ГрафикTmp.PlannedPayDate = GetDay (EXP_WORKNEXT, ГрафикTmp.PlannedPayDate);
               END;
            END;
   
            IF ((calcgpay.EXP_PayDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
               ГрафикTmp.PlannedPayDate = GetDay (calcgpay.EXP_PayDay, ГрафикTmp.PlannedPayDate);
            END;
   
            IF ((calcgpay.PERC_ExpDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedExpDate))
               ГрафикTmp.PlannedExpDate = GetDay (calcgpay.PERC_ExpDay, ГрафикTmp.PlannedExpDate);
            END;
   
            Insert(ГрафикTmp);
            i = i + 1;
         END;
 
         // Найдем все записи в ГП ОД после последней записи в ГП процентов. Каждую из них тоже добавим в ГП процентов
         RSDcmd = RsdCommand (RslDefCon, " SELECT * FROM dplan_pay_tmp " +
                                         " WHERE t_credoperid_ref = 0 " +
                                         "   AND t_type = 0 " +
                                         "   AND t_objecttypeid_ref = ? " +
                                         "   AND t_objectid_ref = ? " +
                                         "   AND (T_PLANNEDPAYSUM > 0 OR  T_SHARESUM > 0)" +
                                         "   AND T_PLANNEDPAYDATE > ? ");
   
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = PercObjList(forj).objectID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = PercObjList(forj).objectNumber;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = ГрафикTmp.PlannedPayDate;
   
         plpay_sel = null;
         plpay_sel = TRsbDataSet(RSDCmd, RSDVAL_CLIENT, RSDVAL_STATIC);
   
         WHILE (plpay_sel.Next)
             ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
             ГрафикTmp.ObjectTypeID_Ref = PercObjList(forj).objectID;
             ГрафикTmp.ObjectID_Ref     = PercObjList(forj).objectNumber;
             ГрафикTmp.Type             = TypeGr;
             ГрафикTmp.PlannedPayDate   = plpay_sel.t_plannedPayDate;
   
             ГрафикTmp.PlannedExpDate = plpay_sel.t_plannedExpDate;
             Insert(ГрафикTmp);
         END;
         plpay_sel = null;
         RSDcmd    = null;
      
         IF ((calcgpay.VID == GS_ABSOLU) AND (calcgpay.GraphLim != "X")) /*ГП в абсолютных суммах и не по графику изменения ЛЗ*/
            IF ((PercObjList(forj).objectID != LO_DUTY)AND(PercObjList(forj).objectID != LO_BANKGUARANTEE))
               paydate = Договор.RegDate;
            ELSE
               paydate = Обязательство.DutyFirstDate;
            END;
    
            // определяем сумму задолженности
            IF (calcgpay.Sum == 0)
               IF (SuperDuty AND (VOCO == false)) // Расчет ГП по КД в рамках 58 заявки
                  Rest = GetDutyRestForGraph(PercObjList(forj).objectID, Договор.CreditNumber, Договор.ReturnDate);
               ELSE
                  IF ((PercObjList(forj).objectID == LO_DUTY)OR(PercObjList(forj).objectID == LO_BANKGUARANTEE))
                     Rest = Обязательство.DutySum; // сумма СО
                  ELSE
                     Rest = Договор.CreditSum; // сумма КД
                  END;
               END;
            ELSE
               Rest = calcgpay.Sum;
            END;
    
            FirstG = true;
            DT = date(0,0,0);
            IF (OneStep(FirstG, График, DT, 0, 0, date(0,0,0), WayRecalculation))
               // Найдем дату последнего изменения остатка по СО
               IF (SuperDuty AND (VOCO == false))
                  ClearRecord(dutyrest_sd);
                  dutyrest_sd.CreditNumber = Договор.CreditNumber;
                  dutyrest_sd.RegID        = TDR_MAINREST;
                  dutyrest_sd.RestDate     = paydate;
                  stat = GetGE(dutyrest_sd);
                  IF (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                           AND (dutyrest_sd.RegID == TDR_MAINREST)
                           AND (dutyrest_sd.RestDate < График.PlannedPayDate))
                      /* Учтем все изменения ОД по СО до первого погашения ОД по графику*/
                      WHILE (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                                  AND (dutyrest_sd.RegID == TDR_MAINREST)
                                  AND (dutyrest_sd.RestDate < График.PlannedPayDate))
                          paydate = dutyrest_sd.RestDate;
                          InsertPlanPayTmp (PercObjList(forj).RateID, dutyrest_sd.RestSum, dutyrest_sd.RestDate, "");
                          stat = next (dutyrest_sd);
                      END;
                  ELSE
                     InsertPlanPayTmp (PercObjList(forj).RateID, Rest, paydate, "");
                  END;
               ELSE
                  ClearRecord(dutyrest);
                  dutyrest.ID_Ref   = PercObjList(forj).regID;
                  dutyrest.RestDate = paydate;
                  stat = (GetGE(dutyrest) AND (dutyrest.ID_Ref == PercObjList(forj).regID));
                  IF (stat AND (dutyrest.ID_Ref == PercObjList(forj).regID)
                           AND (dutyrest.RestDate < График.PlannedPayDate))
                     // Учтем все изменения ОД по СО до первого погашения ОД по графику
                     WHILE (stat AND (dutyrest.ID_Ref == PercObjList(forj).regID)
                                 AND (dutyrest.RestDate < График.PlannedPayDate))
                        InsertPlanPayTmp (RateID, dutyrest.RestSum, dutyrest.RestDate, "");
                        Rest    = dutyrest.RestSum;
                        paydate = dutyrest.RestDate;
                        stat    = next (dutyrest);
                     END;
                  ELSE
                     InsertPlanPayTmp (PercObjList(forj).RateID, Rest, paydate, "");
                  END;

                  // SCR 175181 
                  IF (paydate == График.PlannedPayDate)
                     CRSDCommand("UPDATE DPLANPAY_TMP SET T_MARKER = 'X', T_REST = T_REST - ? WHERE T_RATEID = ? AND T_DATE = ?",
                                 "p0", График.PlannedPaySum,
                                 "p1", PercObjList(forj).RateID,
                                 "p2", График.PlannedPayDate,
                                V_GENOBJ);
                  END;
               END;
            ELSE
               InsertPlanPayTmp (PercObjList(forj).RateID, Rest, paydate, "");
            END;
       
            // Готовим виртуальную историю остатков ОД для расчета графика процентов
            FirstG = true;
            WHILE (OneStep(FirstG, График, DT, 0, 0, date(0,0,0), WayRecalculation))
               Rest = Rest - График.PlannedPaySum;
               IF (calcgpay.Exp_CalcExpPercDate == 1)//по дату платежа
                  DT = График.PlannedPayDate;
               ELSE//по дату просрочки
                  DT = График.PlannedExpDate;
               END;
               InsertPlanPayTmp (PercObjList(forj).RateID, Rest, DT, "");
            END;
    
            DT = date(0,0,0);
            FirstG = true;
            planpay_tmp.keynum = 0;
            WHILE (OneStep(FirstG, ГрафикTmp, DT, 0, 0, date(0,0,0), WayRecalculation))
               planpay_tmp.Rec.RateID = PercObjList(forj).RateID;
               IF (calcgpay.Exp_CalcExpPercDate == 1)//по дату платежа
                  planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
               ELSE //по дату просрочки
                  planpay_tmp.Rec.Date   = ГрафикTmp.PlannedExpDate;
               END;
    
               IF (planpay_tmp.GetLE AND (planpay_tmp.Rec.RateID == PercObjList(forj).RateID))
                  IF (((calcgpay.Exp_CalcExpPercDate == 1) AND (planpay_tmp.Rec.Date == ГрафикTmp.PlannedPayDate)) OR
                      ((calcgpay.Exp_CalcExpPercDate == 2) AND (planpay_tmp.Rec.Date == ГрафикTmp.PlannedExpDate)))
    
                     planpay_tmp.Rec.Marker = "X";
                     planpay_tmp.Update();
                  ELSE
                     IF (calcgpay.Exp_CalcExpPercDate == 1)//по дату платежа
                        planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
                     ELSE//по дату просрочки
                        planpay_tmp.Rec.Date   = ГрафикTmp.PlannedExpDate;
                     END;
    
                     planpay_tmp.Rec.Marker = "X";
                     planpay_tmp.Insert();
                  END;
               END;
            END;
            planpay_tmp.keynum = 1;

            FirstPayDate = isDutyLessThenPerc(PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber, calcgpay.Exp_CalcExpPercDate); 
            // Если дата первого погашения ОД наступает раньше даты первого погашения процентов, 
            // то надо рассчитать проценты з период между датами
            IF (FirstPayDate > date(0,0,0))
                CRSDCommand("UPDATE dplanpay_tmp SET t_marker = 'X' WHERE t_date = ? ",
                            "DT", FirstPayDate, V_GENOBJ);
            END;
            // рассчет обычного графика
            РасчетГрафикаПроцентов(PercObjList(forj).RateID, paydate, calcgpay.PERC_PlanLastDate, 0.0, false, PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber, PercObjList(forj).RegID);
            ReWind(ГрафикTmp);
            Rest = $0;
    
            // Учет переплат
            SD = GetAllRegRest(PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber, TDR_IFP_PERC,     {curdate});
            SP = GetAllRegRest(PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber, TDR_OVERPAYMPERC, {curdate});
            IF (i != 2)
               FirstPercPay = true;
               WHILE (next(ГрафикTmp))
                  planpay_tmp.Clear();
                  planpay_tmp.Rec.RateID = PercObjList(forj).RateID;
                  IF (calcgpay.Exp_CalcExpPercDate == 1)//по дату платежа
                     planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
                  ELSE //по дату просрочки
                     planpay_tmp.Rec.Date   = ГрафикTmp.PlannedExpDate;
                  END;
       
                  planpay_tmp.Rec.Marker = "X";
                  stat = planpay_tmp.GetEQ();
                  IF (stat)
                     IF (SuperDuty AND (VOCO == false))
                        IF (FirstPercPay AND (ExistsOperationForCredNum(Договор.CreditNumber, CS_PAY) > 0))
                           RSDcmd = RsdCommand (RslDefCon," SELECT t_DutyID FROM dduty_crd_dbt " +
                                                          " WHERE t_CreditNumber_Ref = ?" +
                                                          " AND t_SystType = ? " +
                                                          " AND t_DutyType = ? " +
                                                          " AND t_DutyState = ? ");
                           RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = Договор.CreditNumber;
                           RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = 0;
                           RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = 0;
                           RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(3) = CF_OPEN;
       
                           rs = null;
                           rs = RsdRecordset (RSDcmd);
                           RSDcmd.execute();
       
                           WHILE ((rs != null) AND (rs.MoveNext()))
                               Loans_FindDuty(rs.Value("t_DutyID"), Обязательство);
                               Rest = Rest + CalcFirstPeriodInterest(LO_DUTY, rs.Value("t_DutyID"), planpay_tmp.Rec.Date) +
                                               CalcFirstPeriodInterest(LO_BANKGUARANTEE, rs.Value("t_DutyID"), planpay_tmp.Rec.Date);
                           END;
                           // Недоплаченные ранее проценты учитываем в первом периоде погашения %%
                           ГрафикTmp.PlannedPercentSum = Rest;
       
                           // учет переплат
                           IF (ГрафикTmp.PlannedPercentSum > SD)
                              ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                              SD = 0;
       
                              IF (ГрафикTmp.PlannedPercentSum > SP)
                                 ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                                 SP = 0;
                              ELSE
                                 SP = SP - ГрафикTmp.PlannedPercentSum;
                                 ГрафикTmp.PlannedPercentSum = 0;
                              END;
                           ELSE
                              SD = SD - ГрафикTmp.PlannedPercentSum;
                              ГрафикTmp.PlannedPercentSum = 0;
                           END;
       
                           FirstPercPay = false;
                        ELSE
                           ГрафикTmp.PlannedPercentSum = planpay_tmp.Rec.CalcPercent;
       
                           // учет переплат
                           IF (ГрафикTmp.PlannedPercentSum > SD)
                              ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                              SD = 0;
       
                              IF (ГрафикTmp.PlannedPercentSum > SP)
                                 ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                                 SP = 0;
                              ELSE
                                 SP = SP - ГрафикTmp.PlannedPercentSum;
                                 ГрафикTmp.PlannedPercentSum = 0;
                              END;
                           ELSE
                              SD = SD - ГрафикTmp.PlannedPercentSum;
                              ГрафикTmp.PlannedPercentSum = 0;
                           END;
                        END;
                     ELSE
                         IF (FirstPercPay)
                            IF (isWasPayForObject(PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber))
                            // Недоплаченные ранее проценты учитываем в первом периоде погашения %%
                            IF(FirstPayDate > date(0,0,0))
                                //#168750 Проценты, рассчитанные за период между датой первого погашения ОД и первого погашения %%
                                // сложим с процентами, рассчитанными видами задолженности
                                ГрафикTmp.PlannedPercentSum = planpay_tmp.Rec.CalcPercent + CalcFirstPeriodInterest(PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber, FirstPayDate);
                            ELSE
                                ГрафикTmp.PlannedPercentSum = CalcFirstPeriodInterest(PercObjList(forj).ObjectID, PercObjList(forj).ObjectNumber, planpay_tmp.Rec.Date);
                            END;
                            ELSE
                               ГрафикTmp.PlannedPercentSum = CRSDCommand("SELECT SUM(T_CALCPERCENT) FROM DPLANPAY_TMP WHERE T_RATEID = ? AND T_DATE <= ? AND T_MARKER = ?",
                                                                  "p1", planpay_tmp.Rec.RateID,
                                                                  "p2", planpay_tmp.Rec.Date,
                                                                  "p3", "X",
                                                                  V_MONEY);
                            END;
       
                            // учет переплат
                            IF (ГрафикTmp.PlannedPercentSum > SD)
                               ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                               SD = 0;
       
                               IF (ГрафикTmp.PlannedPercentSum > SP)
                                  ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                                  SP = 0;
                               ELSE
                                  SP = SP - ГрафикTmp.PlannedPercentSum;
                                  ГрафикTmp.PlannedPercentSum = 0;
                               END;
                            ELSE
                               SD = SD - ГрафикTmp.PlannedPercentSum;
                               ГрафикTmp.PlannedPercentSum = 0;
                            END;
       
                            FirstPercPay = false;
                         ELSE
                            ГрафикTmp.PlannedPercentSum = planpay_tmp.Rec.CalcPercent;
       
                            // учет переплат
                            IF (ГрафикTmp.PlannedPercentSum > SD)
                               ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                               SD = 0;
       
                               IF (ГрафикTmp.PlannedPercentSum > SP)
                                  ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                                  SP = 0;
                               ELSE
                                  SP = SP - ГрафикTmp.PlannedPercentSum;
                                  ГрафикTmp.PlannedPercentSum = 0;
                               END;
                            ELSE
                               SD = SD - ГрафикTmp.PlannedPercentSum;
                               ГрафикTmp.PlannedPercentSum = 0;
                            END;
                         END;
                     END;
                     Update(ГрафикTmp);
                  END;
               END;
            ELSE
               IF (next(ГрафикTmp))
                  ГрафикTmp.PlannedPercentSum = $0;
                  planpay_tmp.Clear();
                  planpay_tmp.Rec.RateID = PercObjList(forj).RateID;
                  IF (calcgpay.Exp_CalcExpPercDate == 1)//по дату платежа
                     planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
                  ELSE//по дату просрочки
                     planpay_tmp.Rec.Date   = ГрафикTmp.PlannedExpDate;
                  END;
                  planpay_tmp.Rec.Marker = "X";
                  stat = planpay_tmp.GetLE();
                  WHILE (stat)
                     ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum + planpay_tmp.Rec.CalcPercent;
    
                     // Учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
    
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
    
                     Update(ГрафикTmp);
                     stat = planpay_tmp.Prev();
                  END;
               END;
            END;
         ELSE
            // SCR. 165351 
            // Удаление записей по ОД, должен остаться только ГП прцентов
            CRSDCommand("DELETE FROM DPLANMAC_TMP WHERE T_TYPE = ?", "p1", 0, V_GENOBJ);
         END;
      END; // for(i, 0, PercObjList.size-1)

      ObjectTypeID = tmpObjectTypeID;
      ObjectID     = tmpObjectID;
 
      // Если расчет велся отдельно по каждому СО
      IF (VOCO == true)
         // Удаление записей по КД
         RSDcmd = RsdCommand (RslDefCon,"DELETE FROM DPLANMAC_TMP WHERE T_OBJECTID_REF = ? AND T_OBJECTTYPEID_REF = ?");
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjectID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
         RSDcmd.execute();
  
         // Группировка графиков СО в график КД
         RSDcmd = RsdCommand (RslDefCon,
         " INSERT INTO dplanmac_tmp (T_CREDOPERID_REF, " +
                                   " T_OBJECTID_REF,     " +
                                   " T_OBJECTTYPEID_REF, " +
                                   " T_PLANNEDEXPDATE,   " +
                                   " T_PLANNEDPAYDATE,   " +
                                   " T_PLANNEDPAYSUM,    " +
                                   " T_PLANNEDPERCENTSUM," +
                                   " T_PLANNEDPAYSUMEX,  " +
                                   " T_SHARESUM,         " +
                                   " T_TYPE)             " +
         "(SELECT 0, " +
                " ?, " +
                " ?, " +
                " t_plannedexpdate, " +
                " t_plannedpaydate, " +
                " T_PLANNEDPAYSUM,  " +
                " T_PLANNEDPERCENTSUM, " +
                " 0, " +
                " 0, " +
                " T_TYPE " +
         "  FROM (  SELECT SUM (t_plannedpaysum) t_plannedpaysum,         " +
         "                 SUM (t_plannedpercentsum) t_plannedpercentsum, " +
         "                 t_plannedexpdate, " +
         "                 t_plannedpaydate, " +
         "                 T_TYPE " +          
         "            FROM DPLANMAC_TMP " +
         "           WHERE     T_CREDOPERID_REF = 0 " +
         "                 AND T_OBJECTID_REF IN (" + SOIDStr + ")" +
         "                 AND T_OBJECTTYPEID_REF = ? " +
         "        GROUP BY t_plannedexpdate, t_plannedpaydate, T_TYPE));");
  
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjectID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = LO_DUTY;
         RSDcmd.execute();
  
         // Удаление графиков СО
         RSDcmd = RsdCommand (RslDefCon,"DELETE FROM dplanmac_tmp WHERE T_OBJECTID_REF IN (" + SOIDStr + ") AND T_OBJECTTYPEID_REF = ?");
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = LO_DUTY;
         RSDcmd.execute();
      END; // IF (VOCO == true)

      IF (NOT RtTrn("TrnInsGPayPerc"))
         MsgBox("Ошибка при расчете графика погашения");
         RETURN 1;
      END;

   // Основной долг                                                            */
   ELIF (type == GPAY_DUTY)
      RSDcmd = null;
      RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplanpay_tmp ");
      RSDcmd.execute;
 
      NewAnnuitAlg =  CNewAnnuit( AnnuitPeriodCount, @СформироватьГрафик);
      NewAnnuitAlg.CalcNewGraph = @СформироватьГрафик;
 
      isStartNewAnnuit = NewAnnuitAlg.FindParmzForAnnuitGrph();   


      IF (calcgpay.GraphLim != "X") /*не по графику изменения ЛЗ*/
         IF (calcgpay.VID == GS_ABSOLU)/*ГП в абсолютных суммах*/
            /* SCR 10001  */
            Rest = Sum;
            IF (Rest == $0)
               IF (SuperDuty)
                  Rest = GetDutyRestForGraph(ObjectTypeID, Договор.CreditNumber, Договор.ReturnDate);
               ELSE
                  IF (/* ReCalc AND */ IsPay)
                     IF (ObjectTypeID == LO_DUTY)
                         Rest = ОстатокСО(Обязательство.DutyID, TDR_MAINREST, Обязательство.DutyLastDate);
                     ELIF (ObjectTypeID == LO_CREDIT)
                         Rest = ОстатокРегистра(ObjectTypeID, Договор.CreditNumber, TDR_MAINREST, Договор.ReturnDate);
                     ELIF (ObjectTypeID == LO_GUARANTEE)
                         Rest = ОстатокРегистра(ObjectTypeID, Договор.CreditNumber, TDR_PAYMGUARANTEE, Договор.ReturnDate);
                     ELIF (ObjectTypeID == LO_BANKGUARANTEE)
                         Rest = ОстатокСО(Обязательство.DutyID, TDR_PAYMGUARANTEE, Обязательство.DutyLastDate);
                     END;
                  ELSE
                     IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
                         Rest  = Договор.CreditSum;
                     ELSE
                         Rest = Обязательство.DutySum;
                     END;
                  END;
               END;
            END;
 
            IF (ForDeltaSum)/*Для расчета суммы Дельта надо брать сумму СО, а не остаток*/
               IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
                   Rest = Договор.CreditSum;
               ELSE
                   Rest = Обязательство.DutySum;
               END;
            END;
 
            calcgpay.Sum = Rest;
         ELSE
            P = 0.0; /*сюда будем записывать суммы по всем платежным периодам для расчета ГП по долям и %%*/
         END;
 
         DateSplit( calcgpay.PAY_PlanFirstDate, null, mon, year);
         FirstPay = Rest;
         extpays  =  0;
 
         IF (Annuit)
            // Для расчета аннуитета проверим ставку
            P= 0.0;
            IF (ObjectTypeID != LO_DEPOSIT)
                IF ((ObjectTypeID != LO_GUARANTEE)AND(ObjectTypeID != LO_BANKGUARANTEE))
            P = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, calcgpay.PAY_PlanFirstDate, false) / 100.0;
                ELSE
                    P = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_PAYMGUAR, calcgpay.PAY_PlanFirstDate, false) / 100.0;
                END;
             ELSE
                 P = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_DEPOPERC, calcgpay.PAY_PlanFirstDate, false) / 100.0;
             END;
    //        P = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, calcgpay.PAY_PlanFirstDate, false) / 100.0;
            IF (P == 0.0)
               MsgBox ("Не определена % ставка по основному долгу на дату "+calcgpay.PAY_PlanFirstDate+"|График погашения не сформирован!");
               RETURN 0;
            END;
 
            СуммаПлатежа = calcgpay.PAY_DutyPaymentSum;
         END;
 
         // Учет переплат
         SD = GetAllRegRest(ObjectTypeID, ObjectID, TDR_IFP_PERC,     {curdate});
         SP = GetAllRegRest(ObjectTypeID, ObjectID, TDR_OVERPAYMPERC, {curdate});
 
         WHILE ( i <= calcgpay.PAY_PlanCountPay )
            ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
            ГрафикTmp.ObjectTypeID_Ref = ObjectTypeID;
            ГрафикTmp.ObjectID_Ref     = ObjectID;
            ГрафикTmp.Type             = TypeGr;
            ГрафикTmp.PlannedPayDate   = CalcPayDate(i,
                                                     calcgpay.PAY_PlanFirstDate,
                                                     calcgpay.PAY_PlanLastDate,
                                                     calcgpay.PAY_PlanCountPay,
                                                     calcgpay.PAY_TypePeriod,
                                                     calcgpay.PAY_Period,
                                                     calcgpay.PAY_ArrearDate,
                                                     calcgpay.PAY_PayDay,
                                                     OpDuty,
                                                     OpExp);

            ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate + calcgpay.PAY_PostExpDay;
 
            IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
               IF (ГрафикTmp.PlannedExpDate > Договор.ReturnDate)
                  ГрафикTmp.PlannedExpDate = Договор.ReturnDate;
               END;

               IF (ГрафикTmp.PlannedPayDate > Договор.ReturnDate)
                  ГрафикTmp.PlannedPayDate = Договор.ReturnDate;
               END;
            ELSE
               IF (ГрафикTmp.PlannedExpDate > Обязательство.DutyLastDate)
                  ГрафикTmp.PlannedExpDate = Обязательство.DutyLastDate;
               END;

               IF (ГрафикTmp.PlannedPayDate > Обязательство.DutyLastDate)
                  ГрафикTmp.PlannedPayDate = Обязательство.DutyLastDate;
               END;
            END;
 
            IF (
                 ( (ГрафикTmp.PlannedPayDate == Обязательство.DutyLastDate) AND ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE)) )
               OR
                 ( (ГрафикTmp.PlannedExpDate == Договор.ReturnDate) AND ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE)) )
               )
               IF (Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
                  ГрафикTmp.PlannedPayDate = GetDay (EXP_WORKNEXT, ГрафикTmp.PlannedPayDate);
               END;
            END;
 
            IF ((calcgpay.PAY_PayDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
               ГрафикTmp.PlannedPayDate = GetDay (calcgpay.PAY_PayDay, ГрафикTmp.PlannedPayDate);
            END;
 
            IF ((calcgpay.PAY_ExpDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedExpDate))
               ГрафикTmp.PlannedExpDate = GetDay (calcgpay.PAY_ExpDay, ГрафикTmp.PlannedExpDate);
            END;
 
 //           IF (NewAnnuitAlg.FirstPeriodCheck(ГрафикTmp.PlannedPayDate,_PrevDate_)) RETURN 0; END;// Выйти из расчета так как первый Пер. Погаш. более 31 дня
 
            IF (calcgpay.VID == GS_ABSOLU)/*ГП в абсолютных суммах*/
               /* Суммы для обычного графика */
               IF (not Annuit)
                  IF (i == calcgpay.PAY_PlanCountPay)
                     /* Последний платёж */
                     IF (ЕжегоднаяПролонгация)
                        ГрафикTmp.PlannedPaySum = Rest - Договор.CreditSum  / Договор.FullDuration * (calcgpay.PAY_PlanCountPay - 1);
                     ELSE
                        ГрафикTmp.PlannedPaySum = Rest - calcgpay.PAY_DutyPaymentSum * (calcgpay.PAY_PlanCountPay - 1);
                     END;
                     ГрафикTmp.PlannedPaySum = money(round(ГрафикTmp.PlannedPaySum));
                  ELSE
                     /* Ежемесячный платёж */
                     IF (ЕжегоднаяПролонгация)
                        ГрафикTmp.PlannedPaySum = money(round(Договор.CreditSum  / Договор.FullDuration));
                     ELSE
                        ГрафикTmp.PlannedPaySum = calcgpay.PAY_DutyPaymentSum;
                     END;
                  END;
               /* Суммы для аннуитетного графика */
               ELSE
                  // проценты нужно рассчитывать видами задолженности, чтобы учесть все предыдущие расчеты, недоплаты и т.п.
                  // Переплаты процентов, превышающие размер аннуитета, не учитываются
                    IF ((i == 1)  AND isWasPayForObject(ObjectTypeID, ObjectID))
                     СуммаПроцентов = CalcFirstPeriodInterest(ObjectTypeID, ObjectID, ГрафикTmp.PlannedPayDate, RoundOffError);
                     ГрафикTmp.PlannedPercentSum = СуммаПроцентов;
 
                     // учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
 
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
                  ELSE
                     /* Фактическое кол-во дней в i-ом платеже */
                     ti = ГрафикTmp.PlannedPayDate - _PrevDate_;
                     InsertPlanPayTmp(RateID, FirstPay, _PrevDate_, "");
                     InsertPlanPayTmp(RateID, FirstPay, ГрафикTmp.PlannedPayDate, "X");
 
                     // SCR 179277
                     СуммаПроцентов = RSL_РасчетГрафикаПроцентов(RateID, _PrevDate_, ГрафикTmp.PlannedPayDate, Double(Rate*100), ObjectTypeID, ObjectID, RoundOffError);

                     ГрафикTmp.PlannedPercentSum = СуммаПроцентов;
 
                     // учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
 
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
 
                     RSDcmd = null;
                     RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplanpay_tmp ");
                     RSDcmd.execute;
                  END;
 
                  IF ( NewAnnuitAlg.NewAnnuitMode AND (not NewAnnuitAlg.NoNewAnnuit))
                    СуммаПлатежа = NewAnnuitAlg.CalcPeriodSum(Rest, ГрафикTmp.PlannedPayDate, i, calcgpay.PAY_PlanCountPay, AnnuitPeriodCount, СуммаПлатежа);
                  END;
 
                  IF ((i==1) AND (calcgpay.IsPrivelege == "X"))
                     ГрафикTmp.PlannedPaySum = $0;
                  ELSE
                     ГрафикTmp.PlannedPaySum = max(0, СуммаПлатежа - СуммаПроцентов);
                     IF (СуммаПроцентов > СуммаПлатежа) // Запомним этот факт, потом выдадим сообщение
                         НарушениеАннуитета = true;
                     END;
                  END;
 
                  FirstPay   = FirstPay - ГрафикTmp.PlannedPaySum;
                  _PrevDate_ = ГрафикTmp.PlannedPayDate;
 
                  // NEW ANNUITE CHECK
                  IF (isStartNewAnnuit AND (NewAnnuitAlg.isChekSumFail(СуммаПлатежа, СуммаПроцентов, i)))
                     IF (NOT(NewAnnuitAlg.NewAnnuitMode)) // Если изначально был обычный режим, а не ручной(ну ичтобы небыло рекурсии)
                        RETURN NewAnnuitAlg.СформироватьГрафик(ObjID, ObjN, _typegr, Sum, _ReCalc_, type, Rate, buff, ForDeltaSum, Annuit);
                     ELSE // Если изначально уже был либо ручной режим, либо мы ищем график в цикле!
                        IF ( NewAnnuitAlg.NewAnnuitMode AND (not NewAnnuitAlg.NoNewAnnuit) AND NewAnnuitAlg.ShowAnnuitGraphAnyway)
                           // Убираем минусы в графике
                           СуммаПроцентов = СуммаПроцентов + ГрафикTmp.PlannedPaySum;
                           ГрафикTmp.PlannedPaySum = 0;
                        END;
                     END;
                  END;

                  IF (NewAnnuitAlg.IsNeedExit()) // Проверка перехода к следующиму цыклу расчетов (или просто выхода)
                    RETURN 1; // Переходим в следующий цикл с ошибкой
                  END;
 
                  // Подсчет суммы погашенного ОД до последнего платежного периода
                  IF (NOT(NewAnnuitAlg.IsThisLastPayPeriod(i, calcgpay.PAY_PlanCountPay, AnnuitPeriodCount)))
                     NewAnnuitAlg.TotalPeriodsSum = NewAnnuitAlg.TotalPeriodsSum + ГрафикTmp.PlannedPaySum;
                  END;
                  // NEW ANNUITE CHECK
 
                  TotSum  = TotSum  + ГрафикTmp.PlannedPaySum;
 
                  // Послединй период расчета: кинем на него все, что осталось
                  // Для остальных периодов - контролируем перебор суммы
                  IF ((i == calcgpay.PAY_PlanCountPay) or (TotSum > Rest))
                     ГрафикTmp.PlannedPaySum   = max(0, ГрафикTmp.PlannedPaySum + Rest - TotSum);
                  END;
 
               END;
            ELSE /*ГП НЕ в абсолютных суммах*/
               IF (i == calcgpay.PAY_PlanCountPay)
                  /* Последний платёж */
                  IF (calcgpay.VID == GS_PART) /*ГП в долях*/
                     ГрафикTmp.ShareSum = round(1-P, 4);
                  ELSE
                     ГрафикTmp.ShareSum = round(100-P, 4); /*ГП в %% - здесь ранее было округление до 2х знаков после запятой*/
                  END;
               ELSE /* Ежемесячный платёж */
                  IF (calcgpay.VID == GS_PART) /*ГП в долях*/
                     ГрафикTmp.ShareSum = double(floor(10000 * 1.0/calcgpay.PAY_PlanCountPay)/10000); /*Округлить значение в меньшую сторону до четырех знаков*/
                  ELSE /*ГП в %%*/
                     ГрафикTmp.ShareSum = double(floor(10000 * 100.0/calcgpay.PAY_PlanCountPay)/10000); /*Округлить значение в меньшую сторону до (ранее было двух) четырех знаков*/
                  END;
                  P = P + ГрафикTmp.ShareSum;
               END;
            END;
            //вставляем только записи, в которых есть хоть что-то больше нуля (первую запись всегда вставляем)
            IF ((i == 1) OR (ГрафикTmp.PlannedPaySum > $0) OR (ГрафикTmp.PlannedPercentSum > $0) OR (ГрафикTmp.ShareSum > 0))
               Insert(ГрафикTmp);
            ELSE
               // если запись оказалась нулевой, значит цикл пора заканчивать
               break;
            END;
 
            IF ((ГрафикTmp.PlannedPayDate >= calcgpay.PAY_PlanLastDate) OR (ГрафикTmp.PlannedExpDate >= calcgpay.PAY_PlanLastDate))
               extpays = extpays + 1; // посчитаем количество платежных периодов, вылезших за разрешенную дату последнего платежа
            END;
 
            i = i + 1;
         END; // While

         IF (НарушениеАннуитета)
             MsgBox("Внимание! Сформированный аннуитетный график содержит неаннуитетные платежи.");
         END;
      ELSE //по графику изменения ЛЗ
      /*начиная со второй записи графика изменения ЛЗ создавать записи в графике погашения ОД
        с датой погашения на день меньшей даты изменения лимита.
        DPLANPAY_DBT.T_PLANNEDPAYDATE=T_PLANNEDEXPDATE=DGRAPHLIM_DBT.T_DATE - 1
        DPLANPAY_DBT.T_PLANNEDPAYSUM =T_PLANNEDPERCENTSUM = 0
        Дата последнего платежа рассчитывается как дата, предшествующая дате записи графика снижения лимита, в которой сумма лимита =0.
        Если такой записи в графике нет, то дата окончания платежей = дате окончания договора - 1 день.
      */
         First = true;
         rs = null;
 
         ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
 
         RSDcmd = RsdCommand (RslDefCon,
         " SELECT * FROM dgraphlim_dbt WHERE t_ObjectTypeID = ? AND t_ObjectNumber = ? AND t_Type = ? AND t_CredOperID = ? ORDER BY t_Date "
                             );
         RSDcmd.addParam("", RSDBP_IN); RSDcmd.value (0) = ObjectTypeID;
         RSDcmd.addParam("", RSDBP_IN); RSDcmd.value (1) = ObjectID;
         RSDcmd.addParam("", RSDBP_IN); RSDcmd.value (2) = GRAPH_LIM_DUTY;
         RSDcmd.addParam("", RSDBP_IN); RSDcmd.value (3) = GetLastGraphLimOpID(ObjectTypeID, ObjectID, GRAPH_LIM_DUTY);
 
         rs  = RsdRecordset (RSDcmd, RSDVAL_CLIENT, RSDVAL_STATIC);
         RSDcmd.execute;
 
         IF (rs != null)
            rs.MoveNext; //первую запись пропускаем;
 
            WHILE ((rs.MoveNext) AND (First))
                ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
                ГрафикTmp.ObjectTypeID_Ref = ObjectTypeID;
                ГрафикTmp.ObjectID_Ref     = ObjectID;
                ГрафикTmp.Type             = TypeGr;
                ГрафикTmp.PlannedPayDate   = rs.value("t_Date", false, V_DATE) - 1;
 
                IF ((calcgpay.PAY_PayDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
                   ГрафикTmp.PlannedPayDate = GetDay (calcgpay.PAY_PayDay, ГрафикTmp.PlannedPayDate);
                END;
 
                ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate;
                Insert(ГрафикTmp);
                IF (rs.value("t_Sum", false, V_MONEY) == $0)
                   First = false;
                END;
            END; // While
 
            IF (First == true) // в графике ЛЗ не нашлось записи с нулевой суммой
               /*ну а вдруг последний период в получившемся графике итак та самая дата окончания договора минус 1 день - зачем же дублить*/
               _PrevDate_ = Договор.ReturnDate;
               IF (Loans_IsHoliday (_PrevDate_))
                   _PrevDate_ = GetDay (EXP_WORKNEXT, _PrevDate_);
               END;
 
               IF (ГрафикTmp.PlannedPayDate != _PrevDate_)
                   ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
                   ГрафикTmp.ObjectTypeID_Ref = ObjectTypeID;
                   ГрафикTmp.ObjectID_Ref     = ObjectID;
                   ГрафикTmp.Type             = TypeGr;
                   ГрафикTmp.PlannedPayDate   = _PrevDate_;
                   ГрафикTmp.PlannedExpDate   = ГрафикTmp.PlannedPayDate;
                   Insert(ГрафикTmp);
               END;
            END;
         END;
      END;

      IF (NOT RtTrn("TrnInsGPayDuty"))
         MsgBox("Ошибка при расчете графика погашения");
         RETURN 1;
      END;
 
      IF (Annuit)
         calcgpay.PERC_PlanCountPay    = calcgpay.PAY_PlanCountPay;
         calcgpay.PERC_PlanFirstDate   = calcgpay.PAY_PlanFirstDate;
         calcgpay.PERC_PlanLastDate    = calcgpay.PAY_PlanLastDate;
         calcgpay.PERC_Period          = calcgpay.PAY_Period;
         calcgpay.PERC_TypePeriod      = calcgpay.PAY_TypePeriod;
         calcgpay.PERC_ArrearDate      = calcgpay.PAY_ArrearDate;
 
         IF ((not ReCalc))
            ReWind(ГрафикTmp);
            IF (next(ГрафикTmp) AND Privilege AND (calcgpay.IsPrivelege == "X"))
               calcgpay.PAY_PlanCountPay = i - 1; // для аннуитетного графика с льготным периодом сохраняем количество аннуитетных периодов
               IF (next(ГрафикTmp))
                  calcgpay.PAY_PlanFirstDate = ГрафикTmp.PlannedPayDate;
               END;
            ELSE
               calcgpay.PAY_PlanCountPay = calcgpay.PAY_PlanCountPay;
               calcgpay.PAY_PlanFirstDate = ГрафикTmp.PlannedPayDate;
            END;
         END;
      END;
   /* %% = ОД F12 */
   ELIF (type == GPAY_PERCEQDUTY)
      IF ((calcgpay.VID == GS_ABSOLU) AND (calcgpay.GraphLim != "X"))/*ГП в абсолютных суммах и не по графику ЛЗ*/
         CRsdCommand (" DELETE FROM DPLAN_PAY_TMP WHERE " + 
                             " T_OBJECTID_REF = ? " +
                         " AND T_OBJECTTYPEID_REF = ?" +
                         " AND T_TYPE = ? " +
                         " AND T_PLANNEDPAYSUM  = ? " +
                         " AND T_CREDOPERID_REF = ? ",
                         "p1", ObjectID,
                         "p2", ObjectTypeID,
                         "p3", TypeGr,
                         "p4", 0, "p5", 0,
                         V_GENOBJ);
 
         LnSQLExec ("DELETE FROM DPLANPAY_TMP");
      END;

      // 1!!!
      // Заполнение массива сумм погашения ОД по КД, надо для генерации графика ОД по СО
      IF (SuperDuty AND (VOCO == TRUE)) // Расчет ГП ОД по СО включенным в КД в рамках 58 заявки
         // Найдем все записи в ГП ОД КД
         rs = CRsdCommand (" SELECT T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM FROM DPLAN_PAY_TMP WHERE " +
                                  " T_CREDOPERID_REF = ? " +
                              " AND T_TYPE = ? " +
                              " AND T_OBJECTTYPEID_REF = ? " +
                              " AND T_OBJECTID_REF = ? " +
                           " ORDER BY T_PLANNEDPAYDATE",
                           "p1", 0, 
                           "p2", 0,
                           "p3", Договор.Crd_kind,
                           "p4", Договор.CreditNumber,
                           V_GENOBJ);
 
         WHILE (rs.MoveNext)
            // заполнение массива сумм погашения ОД по КД
            forn = KDODGraf.size;
            KDODGraf(forn) = KDODGrafType();
            KDODGraf(forn).plannedPayDate = rs.value("T_PLANNEDPAYDATE", FALSE, V_DATE);
            KDODGraf(forn).plannedExpDate = rs.value("T_PLANNEDEXPDATE", FALSE, V_DATE);
            KDODGraf(forn).plannedPaySum  = rs.value("T_PLANNEDPAYSUM",  FALSE, V_MONEY);
         END; // WHILE (rs.MoveNext)
      END; // IF (SuperDuty AND (VOCO == true))
 
      // цикл по СО
      tmpObjectTypeID = ObjectTypeID;
      tmpObjectID     = ObjectID;
      SOIDStr = "";

      IF (NOT(((calcgpay.VID == GS_ABSOLU) AND (calcgpay.GraphLim != "X")))) // ГП в абсолютных суммах и не по графику ЛЗ
         CRSDCommand(
         "INSERT INTO DPLANMAC_TMP ( " + 
         " T_OBJECTID_REF,      T_OBJECTTYPEID_REF, T_CREDOPERID_REF, " + 
         " T_PLANNEDPAYDATE,    T_PLANNEDEXPDATE, T_TYPE,  T_PLANNEDPAYSUM,  " +
         " T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX,   T_SHARESUM) " +
         " SELECT " + 
           " pp.T_OBJECTID_REF,      pp.T_OBJECTTYPEID_REF, pp.T_CREDOPERID_REF, " + 
           " pp.T_PLANNEDPAYDATE,    pp.T_PLANNEDEXPDATE, " +
           " ?, " +
           " 0, 0,  0, 0 " + 
         " FROM DPLAN_PAY_TMP pp WHERE " + 
           " pp.T_OBJECTID_REF = ? " +
       " AND pp.T_OBJECTTYPEID_REF = ? " +
       " AND pp.T_CREDOPERID_REF = ? "
       " AND pp.T_TYPE = ?",
            "p4", TypeGr, "p5", tmpObjectID, "p6", tmpObjectTypeID, "p7", 0, "p8", TypeGr, V_GENOBJ);

         IF (NOT RtTrn("TrnInsGPayPerc"))
            MsgBox("Ошибка при расчете графика погашения");
            RETURN 1;
         END;

         RETURN 0;
      END;

      FOR (forj, 0, PercObjList.size-1, 1)
         LnSQLExec("DELETE FROM DPLANPAY_TMP");
 
         ObjectTypeID = PercObjList(forj).objectID;
         ObjectID     = PercObjList(forj).objectNumber;
       
         // поиск обязательства
         IF ((VOCO == true) AND ((PercObjList(forj).objectID == LO_DUTY)OR(PercObjList(forj).objectID == LO_BANKGUARANTEE)))
            IF (NOT Loans_FindDuty(PercObjList(forj).objectNumber, Обязательство))
               RETURN;
            END;

            IF (strlen(SOIDStr) > 0)
               SOIDStr = SOIDStr + ",";
            END;
            SOIDStr = SOIDStr + string(PercObjList(forj).objectNumber);
         END;

         // построение графика ОД по СО
         IF (SuperDuty AND (VOCO == true)) // Расчет ГП ОД по СО включенным в КД в рамках 58 заявки
            // цикл по платежным периодам
            FOR (fori, 0, forn, 1)
               // получение Sin
               Sin = 0;
               FOR (forn, 0, forj-1, 1)
                  Sin = Sin + PercObjList(forn).GetODGrafSum(fori);
               END; // for(forn, 0, forj-1)
 
               // получение Skj
               Skj = 0;
               FOR (fork, 0, fori-1, 1)
                  Skj = Skj + PercObjList(forj).GetODGrafSum(fork);
               END; // for(fork, 0, fori-1)
 
               Si = KDODGraf(fori).plannedPaySum; // сумма погашения в i-том платежном периоде ГП ОД по КД
 
               Sodj = ОстатокРегистра(PercObjList(forj).objectID, PercObjList(forj).objectNumber, TDR_MAINREST, Opdate);// остаток регистра <История ОД> j-го СО
 
               // сумма погашения по j-му СО в i-том платежном периоде
               PercObjList(forj).AddODGrafRec(min(Si - Sin, Sodj - Skj));
 
               // вставим запись в график ОД по СО
               ClearRecord (ГрафикTmp);
               ГрафикTmp.ObjectTypeID_Ref = PercObjList(forj).objectID;
               ГрафикTmp.ObjectID_Ref     = PercObjList(forj).objectNumber;
               ГрафикTmp.Type             = 0;
               ГрафикTmp.PlannedPayDate   = KDODGraf(fori).PlannedPayDate;
               ГрафикTmp.PlannedExpDate   = KDODGraf(fori).PlannedExpDate;
               ГрафикTmp.PlannedPaySum    = PercObjList(forj).GetODGrafSum(fori);
               Insert(ГрафикTmp);
            END; // for(fori, 0, PercObjList.size-1)
 
            // сохранение ГП обязательства
            IF (NOT RtTrn("TrnInsGPayDuty"))
               MsgBox("Ошибка при расчете графика погашения");
               RETURN 1;
            END;
         ELSE // IF (SuperDuty AND (VOCO == true))
             CRSDCommand(
            "INSERT INTO DPLANMAC_TMP ( " + 
            " T_OBJECTID_REF,      T_OBJECTTYPEID_REF, T_CREDOPERID_REF, " + 
            " T_PLANNEDPAYDATE,    T_PLANNEDEXPDATE,   T_PLANNEDPAYSUM,  " +
            " T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX,  T_TYPE, T_SHARESUM) " +
            " SELECT " + 
              " ?, ?, ?, " + 
              " pp.T_PLANNEDPAYDATE,    pp.T_PLANNEDEXPDATE,  pp.T_PLANNEDPAYSUM,  " +
              " pp.T_PLANNEDPERCENTSUM, pp.T_PLANNEDPAYSUMEX, ?, pp.T_SHARESUM " + 
            " FROM DPLAN_PAY_TMP pp WHERE " + 
              " pp.T_OBJECTID_REF = ? " +
          " AND pp.T_OBJECTTYPEID_REF = ? " +
          " AND pp.T_CREDOPERID_REF = ? "
          " AND pp.T_TYPE = ?",
               "p1", ObjectID,
               "p2", ObjectTypeID,
               "p3", 0,
               "p4", TypeGr,
               "p5", tmpObjectID,
               "p6", tmpObjectTypeID,
               "p7", 0,
               "p8", 0,
               V_GENOBJ);
         END;

         DateSplit( calcgpay.PERC_PlanFirstDate, null, mon, year);

         IF (calcgpay.VID != GS_ABSOLU)
            CRSDCommand("UPDATE DPLANMAC_TMP SET T_PLANNEDPAYSUM = ?, T_PLANNEDPERCENTSUM = ?, T_PLANNEDPAYSUMEX = ?, T_SHARESUM = ? " +
                        " WHERE " + 
                        " T_OBJECTID_REF = ? " +
                    " AND T_OBJECTTYPEID_REF = ? " +
                    " AND T_CREDOPERID_REF = ? "
                    " AND T_TYPE = ?",
            "p1", 0, "p2", 0, "p3", 0, "p4", 0,
            "p5", ObjectID,
            "p6", ObjectTypeID,
            "p7", 0,
            "p8", TypeGr,
            V_GENOBJ);
         END;

         // Определим сумму задолженности
         LnSQLExec ("DELETE FROM DPLANPAY_TMP");
 
         IF (calcgpay.Sum == 0)
            IF (SuperDuty)
               Rest = GetDutyRestForGraph(ObjectTypeID, Договор.CreditNumber, Договор.ReturnDate);
            ELSE
               IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
                  Rest = Обязательство.DutySum; // сумма СО
               ELSE
                  Rest = Договор.CreditSum; // сумма КД
               END;
            END;
         ELSE
             Rest = calcgpay.Sum;
         END;
 
         IF (ObjectTypeID != LO_GUARANTEE)
            OpDuty = CS_DUTY;
            OpExp  = CS_EXP;
            OpPerc = DS_ADDPERC;
         ELSE
            OpDuty = CS_GUARDUTY;
            OpExp  = CS_GUAREXP;
            OpPerc = DS_PAYMGUARADDPERC;
         END;
 
         // определим дату начала расчета %
         IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
             paydate = Обязательство.DutyFirstDate;
         ELSE
             paydate = Договор.RegDate;
         END;
         tmpdate = paydate;
 
         FirstPercPay = First = FirstG = FirstGT = FlagG = FlagGT = true;
         DT = date(0,0,0);
         IF (OneStep(FirstG, ГрафикTmp, date(0,0,0), 0, 0, date(0,0,0), WayRecalculation) AND OneStep(FirstGT, График, DT, 0, 0, date(0,0,0), WayRecalculation))
            WHILE (First)
               IF (FirstPercPay) // первая запись
                  FirstPercPay = FALSE;
                  // Найдем дату последнего изменения остатка по СО
                  IF ((SuperDuty) AND (VOCO == false))
                     ClearRecord(dutyrest_sd);
                     dutyrest_sd.CreditNumber = Договор.CreditNumber;
                     dutyrest_sd.RegID        = TDR_MAINREST;
                     dutyrest_sd.RestDate     = paydate;
                     stat = GetGE(dutyrest_sd);
                     IF (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                              AND (dutyrest_sd.RegID == TDR_MAINREST)
                              AND (dutyrest_sd.RestDate < График.PlannedPayDate))
                        // Учтем все изменения ОД по СО до первого погашения ОД по графику
                        WHILE (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                                    AND (dutyrest_sd.RegID == TDR_MAINREST)
                                    AND (dutyrest_sd.RestDate < График.PlannedPayDate))
                           paydate = dutyrest_sd.RestDate;
                           tmpdate = paydate;
                           InsertPlanPayTmp (PercObjList(i).RateID, dutyrest_sd.RestSum, dutyrest_sd.RestDate, "");
                           stat = next (dutyrest_sd);
                        END;
                     ELSE
                        InsertPlanPayTmp (PercObjList(i).RateID, Rest, paydate, "");
                     END;
                     // Если 
                  ELSE
                     stat = 1;
                     RsDutyRest = CRSDCommand("SELECT T_RESTDATE, T_RESTSUM FROM DDUTYREST_DBT WHERE T_ID_REF = ? AND T_RESTDATE < ? ORDER BY T_RESTDATE",
                                              "p1", PercObjList(forj).regID,
                                              "p2", График.PlannedPayDate,
                                              V_GENOBJ);
                     // Учтем все изменения ОД по СО до первого погашения ОД по графику
                     WHILE (RsDutyRest.MoveNext())
                        InsertPlanPayTmp (PercObjList(i).RateID, SQL_NVL(RsDutyRest.Value(1, NULL, V_MONEY), V_MONEY), SQL_NVL(RsDutyRest.Value(0, NULL, V_DATE), V_DATE), "");

                        Rest    = SQL_NVL(RsDutyRest.Value(1, NULL, V_MONEY), V_MONEY);
                        paydate = SQL_NVL(RsDutyRest.Value(0, NULL,  V_DATE), V_DATE);
                        tmpdate = paydate;
                           
                        stat    = 0;
                     END;

                     IF (stat)
                        InsertPlanPayTmp (PercObjList(i).RateID, Rest, paydate, "");
                     END;

                     // SCR 175181 
                     IF (paydate == График.PlannedPayDate)
                        CRSDCommand("UPDATE DPLANPAY_TMP SET T_MARKER = 'X', T_REST = T_REST - ? WHERE T_RATEID = ? AND T_DATE = ?",
                                    "p0", График.PlannedPaySum,
                                    "p1", PercObjList(i).RateID,
                                    "p2", График.PlannedPayDate,
                                   V_GENOBJ);
                        Rest = Rest - График.PlannedPaySum;
                     END;
                  END;
               END;

               // вторая и далее записи
               IF ((tmpdate < График.PlannedPayDate) AND (tmpdate <= ГрафикTmp.PlannedPayDate) AND
                   (Rest > 0))
                  Rest = Rest - График.PlannedPaySum;
                  InsertPlanPayTmp (PercObjList(i).RateID, Rest, График.PlannedPayDate, "X");
                  tmpdate = График.PlannedPayDate;
               END;
               IF (FlagG)
                  IF (График.PlannedPayDate <= ГрафикTmp.PlannedPayDate)
                     IF (not OneStep(FirstG, График, DT, 0, 0, date(0,0,0), WayRecalculation))
                        FlagG = false;
                     END;
                  END;
               END;

               IF (FlagGT)
                  IF (((График.PlannedPayDate >= ГрафикTmp.PlannedPayDate) AND FlagG) or not FlagG)
                     Update(ГрафикTmp);
                     IF (not OneStep(FirstGT, ГрафикTmp, date(0,0,0), 0, 0, date(0,0,0), WayRecalculation))
                        FlagGT = false;
                     END;
                  END;
               END;

               IF (NOT FlagG AND NOT FlagGT)
                  First = false;
               END;
            END;
         END;
 
         РасчетГрафикаПроцентов(PercObjList(i).RateID, paydate, ГрафикTmp.PlannedPayDate, 0.0, false, ObjectTypeID, ObjectID);
         FirstPercPay = true;
         Rest = $0;
         ReWind(ГрафикTmp);
 
         // Учет переплат
         SD = GetAllRegRest(ObjectTypeID, ObjectID, TDR_IFP_PERC,     {curdate});
         SP = GetAllRegRest(ObjectTypeID, ObjectID, TDR_OVERPAYMPERC, {curdate});
 
         WHILE (next(ГрафикTmp))
            planpay_tmp.Clear();
            planpay_tmp.Rec.RateID = PercObjList(i).RateID;
            planpay_tmp.Rec.Date = ГрафикTmp.PlannedPayDate;
            planpay_tmp.Rec.Marker = "X";
            stat = planpay_tmp.GetEQ();
            IF (stat)
               IF (SuperDuty)
                  IF (FirstPercPay AND (ExistsOperationForCredNum(Договор.CreditNumber, CS_PAY) > 0))
                     RSDcmd = RsdCommand (RslDefCon," SELECT t_DutyID FROM dduty_crd_dbt " +
                                                      " WHERE t_CreditNumber_Ref = ?" +
                                                      " AND t_SystType = ? " +
                                                      " AND t_DutyType = ? " +
                                                      " AND t_DutyState = ? ");
                     RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = Договор.CreditNumber;
                     RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = 0;
                     RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = 0;
                     RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(3) = CF_OPEN;

                     rs = null;
                     rs = RsdRecordset (RSDcmd);
                     RSDcmd.execute();

                     WHILE ((rs != null) AND (rs.MoveNext()))
                           Rest = Rest + CalcFirstPeriodInterest(LO_DUTY, rs.Value("t_DutyID"), planpay_tmp.Rec.Date)+
                                          CalcFirstPeriodInterest(LO_BANKGUARANTEE, rs.Value("t_DutyID"), planpay_tmp.Rec.Date);
                     END;
                     
                     // Недоплаченные ранее проценты учитываем в первом периоде погашения %%
                     ГрафикTmp.PlannedPercentSum = Rest;
                    // ГрафикTmp.PlannedPercentSum = Rest;
                     // учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
 
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
 
                     FirstPercPay = false;
                  ELSE
                     ГрафикTmp.PlannedPercentSum = planpay_tmp.Rec.CalcPercent;
 
                     // учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
 
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
                  END;
               ELSE
                  IF (FirstPercPay)
                     IF (isWasPayForObject(ObjectTypeID, ObjectID))
                     // Недоплаченные ранее проценты учитываем в первом периоде погашения %%
                     ГрафикTmp.PlannedPercentSum = CalcFirstPeriodInterest(ObjectTypeID, ObjectID, planpay_tmp.Rec.Date);
                     ELSE
                        ГрафикTmp.PlannedPercentSum = CRSDCommand("SELECT SUM(T_CALCPERCENT) FROM DPLANPAY_TMP WHERE T_RATEID = ? AND T_DATE <= ? AND T_MARKER = ?",
                                                                  "p1", PercObjList(i).RateID,
                                                                  "p2", planpay_tmp.Rec.Date,
                                                                  "p3", "X",
                                                                  V_MONEY);
                     END;
 
                     // учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
 
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
 
                     FirstPercPay = false;
                  ELSE
                     ГрафикTmp.PlannedPercentSum = planpay_tmp.Rec.CalcPercent;
 
                     // учет переплат
                     IF (ГрафикTmp.PlannedPercentSum > SD)
                        ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                        SD = 0;
 
                        IF (ГрафикTmp.PlannedPercentSum > SP)
                           ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                           SP = 0;
                        ELSE
                           SP = SP - ГрафикTmp.PlannedPercentSum;
                           ГрафикTmp.PlannedPercentSum = 0;
                        END;
                     ELSE
                        SD = SD - ГрафикTmp.PlannedPercentSum;
                        ГрафикTmp.PlannedPercentSum = 0;
                     END;
                  END;
               END;
               Update(ГрафикTmp);
               stat = planpay_tmp.next();
            END;
         END;
      END;

      ObjectTypeID = tmpObjectTypeID;
      ObjectID     = tmpObjectID;
 
      // Если расчет велся отдельно по каждому СО
      IF (VOCO == true)
         // Удаление записей по КД
         CRsdCommand ("DELETE FROM DPLANMAC_TMP WHERE T_OBJECTID_REF = ? AND T_OBJECTTYPEID_REF = ?",
                      "p1", ObjectID,
                      "p2", ObjectTypeID,
                      V_GENOBJ);
  
         // Группировка графиков СО в график КД
         RSDcmd = RsdCommand (RslDefCon,
         " INSERT INTO dplanmac_tmp (T_CREDOPERID_REF, " +
                                   " T_OBJECTID_REF,     " +
                                   " T_OBJECTTYPEID_REF, " +
                                   " T_PLANNEDEXPDATE,   " +
                                   " T_PLANNEDPAYDATE,   " +
                                   " T_PLANNEDPAYSUM,    " +
                                   " T_PLANNEDPERCENTSUM," +
                                   " T_PLANNEDPAYSUMEX,  " +
                                   " T_SHARESUM,         " +
                                   " T_TYPE)             " +
         "(SELECT 0, " +
                " ?, " +
                " ?, " +
                " t_plannedexpdate, " +
                " t_plannedpaydate, " +
                " T_PLANNEDPAYSUM,  " +
                " T_PLANNEDPERCENTSUM, " +
                " 0, " +
                " 0, " +
                " T_TYPE " +
         "  FROM (  SELECT SUM (t_plannedpaysum) t_plannedpaysum,         " +
         "                 SUM (t_plannedpercentsum) t_plannedpercentsum, " +
         "                 t_plannedexpdate, " +
         "                 t_plannedpaydate, " +
         "                 T_TYPE " +          
         "            FROM DPLANMAC_TMP " +
         "           WHERE     T_CREDOPERID_REF = 0 " +
         "                 AND T_OBJECTID_REF IN (" + SOIDStr + ")" +
         "                 AND T_OBJECTTYPEID_REF = ? " +
         "        GROUP BY t_plannedexpdate, t_plannedpaydate, T_TYPE));");
  
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjectID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = LO_DUTY;
         RSDcmd.execute();
  
         // Удаление графиков СО
         RSDcmd = RsdCommand (RslDefCon,"DELETE FROM dplanmac_tmp WHERE T_OBJECTID_REF IN (" + SOIDStr + ") AND T_OBJECTTYPEID_REF = ?");
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = LO_DUTY;
         RSDcmd.execute();
      END; // IF (VOCO == true)

      IF (NOT RtTrn("TrnInsGPayPerc"))
          MsgBox("Ошибка при расчете графика погашения");
          RETURN 1;
      END;
    /*пересчет в абсолютные суммы*/
   ELIF (type == GPAY_TOABSOLU)
      IF (NOT SuperDuty)
          RETURN 0;
      END;
 
      IF (calcgpay.VID == GS_ABSOLU)/*ГП в абсолютных суммах*/
      /*для этого случая в качестве входящего параметра Sum приходит сумма переплаты
        (SП = просуммировать все записи в текущем ГП и отнять остаток ссудной задолженности на дату перерасчета)
      */
 
         // зачистить график от периодов, дата платежа которых меньше даты операции перерасчета ГП
         RSDcmd = null;
         RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplan_pay_tmp       " +
                                         "   WHERE T_OBJECTID_REF = ?     " +
                                         "     AND T_OBJECTTYPEID_REF = ? " +
                                         "     AND T_CREDOPERID_REF = 0   " +
                                         "     AND T_PLANNEDPAYDATE < ?   ");
 
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjectID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = OpDate;
         RSDcmd.execute;
 
         // зачистить график от периодов, дата платежа которых меньше даты операции перерасчета ГП
         RSDcmd = null;
         RSDcmd = RsdCommand (RslDefCon, " SELECT NVL(Sum(T_PlannedPaySum), 0) PlPaySum FROM dplan_pay_tmp " +
                                         "   WHERE T_OBJECTID_REF = ?     " +
                                         "     AND T_OBJECTTYPEID_REF = ? " +
                                         "     AND T_CREDOPERID_REF =   ? " +
                                         "     AND T_PLANNEDPAYDATE >=  ? ");
 
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjectID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = calcgpay.CredOperId_ref;
         RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(3) = OpDate;
 
         // ОСЗ
         plRestSum = GetAllRegRest(ObjectTypeID, ObjectID, TDR_MAINREST, OpDate);
 
         plpay_sel = null;
         plpay_sel = TRsbDataSet(RSDCmd, RSDVAL_CLIENT, RSDVAL_STATIC);
         IF (plpay_sel.Next)
            // Сумма переплаты ОД
            Sum = plpay_sel.plPaySum - GetAllRegRest(ObjectTypeID, ObjectID, TDR_MAINREST, OpDate);
         ELSE
            Sum = 0;
         END;
         plpay_sel = null;
         RSDcmd    = null;
 
         RSDcmd = RsdCommand(RslDefCon, "SELECT T.t_WayRecalculation FROM dtype_crd_dbt T WHERE t.t_CreditTypeID = ?");
         RSDcmd.addParam("t.t_CreditTypeID", RsdBp_in); RSDcmd.value(0) = Договор.CreditTypeID_Ref;
         RSDcmd.execute;
 
         rs = RsdRecordset(RSDcmd);
         IF (rs.moveNext)
             WayRecalculation = rs.value(0, NULL, V_INTEGER);
         END;
 
         First = true;
         Rest = СуммаПлатежа = $0;
 
         paydate = OpDate;
         WHILE (OneStep(First, График, paydate, 0, 0, paydate, WayRecalculation))
             ClearRecord (ГрафикTmp);  /*чистим буфер для новой записи*/
             Copy(ГрафикTmp, График);
             ГрафикTmp.Type = TypeGr;
             СуммаПлатежа = ГрафикTmp.PlannedPaySum;
             ГрафикTmp.PlannedPaySum = ГрафикTmp.PlannedPaySum - max(min(ГрафикTmp.PlannedPaySum, Sum - Rest),0);
             Rest = Rest + СуммаПлатежа;
             Insert(ГрафикTmp);
         END;
      ELSE
         First = true;
         Rest = $0;
         
         // Разбить остаток ссудной задолженности по графику погашения
         IsUpd = false;
         WHILE (OneStep(First, График, OpDate, 0, 0, date(0,0,0), WayRecalculation))
             IsUpd = true;
             ClearRecord (ГрафикTmp);  // чистим буфер для новой записи
             Copy(ГрафикTmp, График);
             
             // Тип графика
             ГрафикTmp.Type = TypeGr;

             IF (calcgpay.VID == GS_PART) /*ГП в долях*/
                 ГрафикTmp.PlannedPaySum = round(ГрафикTmp.ShareSum * calcgpay.Sum, 2);
             ELSE /*ГП в %%*/
                 ГрафикTmp.PlannedPaySum = round((ГрафикTmp.ShareSum * calcgpay.Sum)/100.0, 2);
             END;
             ГрафикTmp.ShareSum = 0;
             Rest = Rest + ГрафикTmp.PlannedPaySum;
             Insert(ГрафикTmp);
         END;
         
         /*у последней записи выравниваем сумму*/
         IF (IsUpd)
            Rest = Rest - ГрафикTmp.PlannedPaySum; //сумма записей в ГП за исключением последнего периода
            ГрафикTmp.PlannedPaySum = calcgpay.Sum - Rest;
            Update(ГрафикTmp);
         END;
      END;

      IF (NOT RtTrn("TrnInsGPayDuty"))
          MsgBox("Ошибка при расчете графика погашения");
          RETURN 1;
      END;
 
      IF (calcgpay.VID != GS_ABSOLU)/*ГП в абсолютных суммах*/
         plRestSum = calcgpay.Sum;
      END;
 
      // необходимо рассчитать %%
      LnSQLExec("TRUNCATE TABLE DPLANPAY_TMP");
      LnSQLExec("TRUNCATE TABLE DPLANMAC_TMP");
 
      IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
         paydate = Договор.RegDate;
      ELSE
         paydate = Обязательство.DutyFirstDate;
      END;
 
      FirstG = true;
      DT = opdate;
      Rest = plRestSum;
      IF (OneStep(FirstG, График, DT, 0, 0, date(0,0,0), WayRecalculation))
         // Найдем дату последнего изменения остатка по СО
         ClearRecord(dutyrest_sd);
         dutyrest_sd.CreditNumber = Договор.CreditNumber;
         dutyrest_sd.RegID        = TDR_MAINREST;
         dutyrest_sd.RestDate     = max(paydate, opdate);
         stat = GetGE(dutyrest_sd);
         IF (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                  AND (dutyrest_sd.RegID == TDR_MAINREST)
                  AND (dutyrest_sd.RestDate < График.PlannedPayDate))
            // Учтем все изменения ОД по СО до первого погашения ОД по графику
            WHILE (stat AND (dutyrest_sd.CreditNumber == Договор.CreditNumber)
                        AND (dutyrest_sd.RegID        == TDR_MAINREST)
                        AND (dutyrest_sd.RestDate < График.PlannedPayDate))
               paydate = dutyrest_sd.RestDate;
               InsertPlanPayTmp (RateID, dutyrest_sd.RestSum, dutyrest_sd.RestDate, "");
               stat = next (dutyrest_sd);
            END;
         ELSE
            InsertPlanPayTmp (RateID, Rest, paydate, "");
         END;
      ELSE
         InsertPlanPayTmp (RateID, Rest, paydate, "");
      END;
 
      First = true;
      Rest = plRestSum; //calcgpay.Sum;
 
      plpay_sel = CRSDcommand (" SELECT T_PLANNEDPAYDATE, SUM(T_PLANNEDPAYSUM) AS T_PLANNEDPAYSUM FROM DPLAN_PAY_TMP WHERE " + 
                                     " T_OBJECTID_REF     = ? " +
                                 " AND T_OBJECTTYPEID_REF = ? " +
                                 " AND T_CREDOPERID_REF   = ? " +
                                 " AND T_TYPE = ? "
                                 " GROUP BY T_PLANNEDPAYDATE ORDER BY T_PLANNEDPAYDATE ASC", 
                                 "p1", ObjectID,
                                 "p2", ObjectTypeID,
                                 "p3", 0,
                                 "p4", 0,
                                 V_GENOBJ);
 
      WHILE (plpay_sel.MoveNext())
         Rest = Rest - plpay_sel.Value("T_PLANNEDPAYSUM", V_MONEY);
         InsertPlanPayTmp (RateID, Rest, plpay_sel.Value("T_PLANNEDPAYDATE", V_DATE), "");
      END;

      plpay_sel = null;
      RSDcmd    = null;
 
      IF (calcgpay.VID == GS_ABSOLU)/*ГП в абсолютных суммах*/
         TypeGr_ = 0;
      ELSE
         TypeGr_ = DS_PERC;
      END;
 
      RSDcmd = RsdCommand (RslDefCon, "MERGE INTO dplanpay_tmp pt " +
      " USING ( " +
      " SELECT t_paydate FROM " +
       " ( " +     
        " SELECT DECODE(?, " +
                        " 1, pd.t_plannedpaydate, " +
                        " 2, pd.t_plannedexpdate, " +
                           " pd.t_plannedpaydate) t_paydate " +
                           " FROM DPLAN_PAY_TMP pd WHERE " + 
                           " pd.t_objecttypeid_ref = ? " +
                       " AND pd.t_objectid_ref = ? " +
                       " AND pd.t_type = ? " +
                       " AND pd.t_credoperid_ref = ? " +
                       " AND pd.t_PlannedPayDate >= ? " +
        " ) GROUP BY t_paydate ) r " +
      " ON (r.t_paydate = pt.t_date AND pt.t_rateid = ?) " +
      " WHEN MATCHED THEN " +
                         " UPDATE SET pt.t_marker = 'X' " +
      " WHEN NOT MATCHED THEN " +
                         " INSERT (t_rateid, t_rest, t_date, t_marker, t_calcpercent) " +
                         " VALUES (?, 0, r.t_paydate, 'X', 0) ");
 
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = calcgpay.Exp_CalcExpPercDate;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = ObjectID;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(3) = TypeGr_;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(4) = 0;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(5) = OpDate;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(6) = RateID;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(7) = RateID;
      RSDcmd.execute;
 
      Rest = plRestSum;//calcgpay.Sum;

      FirstPayDate = isDutyLessThenPerc(ObjectTypeID, ObjectID, calcgpay.Exp_CalcExpPercDate, DS_PERC); 
      // Если дата первого погашения ОД наступает раньше даты первого погашения процентов, 
      // то надо рассчитать проценты з период между датами
      IF (FirstPayDate > date(0,0,0))
         CRSDCommand("UPDATE dplanpay_tmp SET t_marker = 'X' WHERE t_date = ? ",
                     "DT", FirstPayDate, V_GENOBJ);
      END;
 
      РасчетГрафикаПроцентов(RateID, Договор.RegDate, calcgpay.PERC_PlanLastDate, 0.0, false, ObjectTypeID, ObjectID);
 
      RSDcmd = RsdCommand (RslDefCon, " SELECT * FROM DPLANPAY_TMP WHERE T_RATEID = ? AND T_MARKER = 'X' ORDER BY T_DATE ASC ");
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = RateID;
 
      plpay_sel = null;
      plpay_sel = TRsbDataSet(RSDCmd, RSDVAL_CLIENT, RSDVAL_STATIC);
 
      IF (plpay_sel.Next)
         FirstPayDate = date(plpay_sel.t_Date); // дата первого платежа по процентам
      END;
      plpay_sel = null;
      RSDcmd    = null;
 
      // Учет переплат
      SD = GetAllRegRest(ObjectTypeID, ObjectID, TDR_IFP_PERC,     {curdate});
      SP = GetAllRegRest(ObjectTypeID, ObjectID, TDR_OVERPAYMPERC, {curdate});
 
      // Перепишем расчитанный график в dplan_pay_tmp
      planpay_tmp.keynum = 1;
      First = FirstPercPay = true;
      Rest = $0;
      WHILE (OneStep(First, График, OpDate, TypeGr_, 0, date(0,0,0), GR_BY_FIRST))
         ClearRecord (ГрафикTmp);  /*чистим буфер для новой записи*/
         Copy(ГрафикTmp, График);
 
         ГрафикTmp.Type = TypeGr;
 
         planpay_tmp.Clear();
         planpay_tmp.Rec.RateID = RateID;
         IF (calcgpay.Exp_CalcExpPercDate == 1)//по дату платежа
             planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
         ELIF (calcgpay.Exp_CalcExpPercDate == 2)//по дату просрочки
             planpay_tmp.Rec.Date   = ГрафикTmp.PlannedExpDate;
         ELSE
             planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
         END;
 
         planpay_tmp.Rec.Marker = "X";
         stat = planpay_tmp.GetEQ();
         IF (stat)
            IF (FirstPercPay)
               IF  /* AND (planpay_tmp.Rec.Date == FirstPayDate) */ (ExistsOperationForCredNum(Договор.CreditNumber, CS_PAY) > 0)
                  RSDcmd = RsdCommand (RslDefCon," SELECT t_DutyID FROM dduty_crd_dbt " +
                                                 " WHERE t_CreditNumber_Ref = ?" +
                                                 " AND t_SystType = ? " +
                                                 " AND t_DutyType = ? " +
                                                 " AND t_DutyState = ? ");
                  RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = Договор.CreditNumber;
                  RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = 0;
                  RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = 0;
                  RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(3) = CF_OPEN;
 
                  rs = null;
                  rs = RsdRecordset (RSDcmd);
                  RSDcmd.execute();
      
                  IF (FirstPayDate > date(0,0,0))
                     Rest = Rest + planpay_tmp.Rec.CalcPercent;
                     WHILE ((rs != null) AND (rs.MoveNext()))
                        Rest = Rest + CalcFirstPeriodInterest(LO_DUTY, rs.Value("t_DutyID"), FirstPayDate)+
                                       CalcFirstPeriodInterest(LO_BANKGUARANTEE, rs.Value("t_DutyID"), FirstPayDate);
                     END;
                  ELSE
                     WHILE ((rs != null) AND (rs.MoveNext()))
                        Rest = Rest + CalcFirstPeriodInterest(LO_DUTY, rs.Value("t_DutyID"), planpay_tmp.Rec.Date)+
                                       CalcFirstPeriodInterest(LO_BANKGUARANTEE, rs.Value("t_DutyID"), planpay_tmp.Rec.Date);
                     END;
                  END;
               ELSE
                  // SCR 
                  Rest = Rest + 
                  CRSDCommand("SELECT SUM(T_CALCPERCENT) FROM DPLANPAY_TMP WHERE " +
                                 "T_RATEID = ? AND T_DATE <= ? ",
                                "p1", planpay_tmp.Rec.RateID,
                                "p2", planpay_tmp.Rec.Date,
                                V_MONEY);
               END;
               
               // Недоплаченные ранее проценты учитываем в первом периоде погашения %%
               ГрафикTmp.PlannedPercentSum = Rest;
 
               // учет переплат
               IF (ГрафикTmp.PlannedPercentSum > SD)
                   ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                  SD = 0;
 
                  IF (ГрафикTmp.PlannedPercentSum > SP)
                     ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                     SP = 0;
                  ELSE
                     SP = SP - ГрафикTmp.PlannedPercentSum;
                     ГрафикTmp.PlannedPercentSum = 0;
                  END;
               ELSE
                  SD = SD - ГрафикTmp.PlannedPercentSum;
                  ГрафикTmp.PlannedPercentSum = 0;
               END;
            ELSE
               ГрафикTmp.PlannedPercentSum = max(planpay_tmp.Rec.CalcPercent - Переплата, 0);
               // учет переплат
               IF (ГрафикTmp.PlannedPercentSum > SD)
                   ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SD;
                  SD = 0;
 
                  IF (ГрафикTmp.PlannedPercentSum > SP)
                     ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum - SP;
                     SP = 0;
                  ELSE
                     SP = SP - ГрафикTmp.PlannedPercentSum;
                     ГрафикTmp.PlannedPercentSum = 0;
                  END;
               ELSE
                  SD = SD - ГрафикTmp.PlannedPercentSum;
                  ГрафикTmp.PlannedPercentSum = 0;
               END;
            END;

            IF (planpay_tmp.Rec.Date > FirstPayDate)
               FirstPercPay = FALSE;
            END;
         END;
         Insert(ГрафикTmp);
      END;
 
      ToAbsolu = true;
 
      IF (NOT RtTrn("TrnInsGPayPerc"))
          MsgBox("Ошибка при расчете графика погашения");
          RETURN 1;
      END;
 
      // зачистить график от записей с нулевыми суммами
      RSDcmd = null;
      RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplan_pay_tmp       " +
                                      "   WHERE T_OBJECTID_REF = ?     " +
                                      "     AND T_OBJECTTYPEID_REF = ? " +
                                      "     AND T_CREDOPERID_REF = 0   " +
                                      "     AND T_PLANNEDPAYSUM  = 0   "
                       "     AND T_PLANNEDPERCENTSUM  = 0");
 
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(0) = ObjectID;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(1) = ObjectTypeID;
      RSDcmd.addParam ("", RSDBP_IN); RSDcmd.value(2) = OpDate;
      RSDcmd.execute;
 
   ELIF (type == GPAY_KOMISS)
      RSDcmd = null;
      RSDcmd = RsdCommand (RslDefCon, " DELETE FROM dplanpay_tmp ");
      RSDcmd.execute;
 
      DateSplit( calcgpay.PAY_PlanFirstDate, null, mon, year);
 
      WHILE ( i <= calcgpay.PAY_PlanCountPay )
         ClearRecord (ГрафикTmp);      /*чистим буфер для новой записи*/
         ГрафикTmp.ObjectTypeID_Ref = ObjectTypeID;
         ГрафикTmp.ObjectID_Ref     = ObjectID;
         ГрафикTmp.Type             = TypeGr;
         ГрафикTmp.PlannedPayDate   = CalcPayDate(i,
                                                  calcgpay.PAY_PlanFirstDate,
                                                  calcgpay.PAY_PlanLastDate,
                                                  calcgpay.PAY_PlanCountPay,
                                                  calcgpay.PAY_TypePeriod,
                                                  calcgpay.PAY_Period,
                                                  calcgpay.PAY_ArrearDate,
                                                  calcgpay.PAY_PayDay,
                                                  OpDuty,
                                                  OpExp);
        
         ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate + calcgpay.PAY_PostExpDay;
                                                  
         IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
            IF (ГрафикTmp.PlannedExpDate > Договор.ReturnDate)
               ГрафикTmp.PlannedExpDate = Договор.ReturnDate;
            END;
        
            IF (ГрафикTmp.PlannedPayDate > Договор.ReturnDate)
               ГрафикTmp.PlannedPayDate = Договор.ReturnDate;
            END;
         ELSE
            IF (ГрафикTmp.PlannedExpDate > Обязательство.DutyLastDate)
               ГрафикTmp.PlannedExpDate = Обязательство.DutyLastDate;
            END;
        
            IF (ГрафикTmp.PlannedPayDate > Обязательство.DutyLastDate)
               ГрафикTmp.PlannedPayDate = Обязательство.DutyLastDate;
            END;
         END;
        
         IF ((calcgpay.PAY_PayDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedPayDate))
            ГрафикTmp.PlannedPayDate = GetDay (calcgpay.PAY_PayDay, ГрафикTmp.PlannedPayDate);
         END;
   
         IF ((calcgpay.PAY_ExpDay != EXP_ANY) AND Loans_IsHoliday (ГрафикTmp.PlannedExpDate))
            ГрафикTmp.PlannedExpDate = GetDay (calcgpay.PAY_ExpDay, ГрафикTmp.PlannedExpDate);
         END;

         // Дата просрочки меньше даты платежа. Так быть не может, должны быть равны
         IF (ГрафикTmp.PlannedExpDate < ГрафикTmp.PlannedPayDate)
             ГрафикTmp.PlannedExpDate = ГрафикTmp.PlannedPayDate;
         END;
        
         Insert(ГрафикTmp);
         i = i + 1;
      END;
 
      DateSplit( calcgpay.PERC_PlanFirstDate, null, mon, year);
 
      FirstPercPay = true;
      First        = true;
      CredOperID   = 0;
      IF (NextOpSystType(First, ObjectID, Операции, OpDuty, false, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID))
          IF (ObjectTypeID != LO_GUARANTEE)
              НедоплатаПроцентов = НедоплатыПроцентов(ObjectTypeID, ObjectID, DS_ADDPERC);
          ELSE
              НедоплатаПроцентов = НедоплатыПроцентов(ObjectTypeID, ObjectID, DS_PAYMGUARADDPERC);
          END;
      END;
 
      DT   = date(0,0,0);
      Rest = calcgpay.Sum;
      IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
         paydate = Договор.RegDate;
      ELSE
         paydate = Обязательство.DutyFirstDate;
      END;
 
      IF (paydate == date(0,0,0))
         IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
            paydate = Договор.RegDate;
         ELSE
            paydate = Обязательство.DutyFirstDate;
         END;
      END;
 
      First = FirstG = FirstGT = FlagG = FlagGT = true;
      Flag  = 0;
 
      IF   (Type == DS_LOANACCOPKOMISS)
         // TDR_LOANACCEXPKOMISS
         RateID_Ref = TRU_CRD;
      ELIF (Type == DS_CREDLINEOPENLIMITKOMISS)
         // TDR_OPENLIMITEXPKOMISS
         RateID_Ref = TRU_CREDLINEOPENLIMPAY;
      ELIF (Type == DS_NOLIMITKOMISS)
         // TDR_NOLIMITEXPKOMISS
         RateID_Ref = TRU_NOLIMIT;
      ELIF (Type == DS_RESOURCERESERVKOMISS)
         // TDR_RESOURCERESERVEXPKOMISS
         RateID_Ref = TRU_RESOURCERESERVKOMISS;
      END;
      /* Поиск использования ставки */
      Loans_FindLCUR(ObjectTypeID, ObjectID, RateID_Ref, 0, rlcusrate);
      RateID = rlcusrate.RateID_Ref;
 
      NextOpSystType(false, ObjectID, Операции, CS_RECALCGPAY, false, Договор.CurCode, ObjectTypeID, CF_COMPLIT, @CredOperID);
 
      ST1 = OneStep(FirstG, ГрафикTmp, date(0,0,0), TypeGR, 0, date(0,0,0), WayRecalculation);
      ST2 = OneStep(FirstGT, График, DT, 0, CredOperID, date(0,0,0), WayRecalculation);
      IF (ST1 AND ST2 AND (CredOperID > 0))
         WHILE (First)
            IF (FirstPercPay)
               // Недоплаченные ранее проценты учитываем в первом периоде погашения %%
               ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum + НедоплатаПроцентов;
               IF (ГрафикTmp.PlannedPercentSum < $0)
                  НедоплатаПроцентов = ГрафикTmp.PlannedPercentSum;
                  ГрафикTmp.PlannedPercentSum = $0;
               ELSE
                  НедоплатаПроцентов = $0;
               END;
 
               FirstPercPay = false;
               // Найдем дату последнего изменения остатка по СО
               ClearRecord(dutyrest);
               dutyrest.ID_Ref   = lcusreg.ID;
               dutyrest.RestDate = paydate;
               stat = GetGE(dutyrest);
               // Учтем все изменения ОД по СО до первого погашения ОД по графику
               WHILE (stat AND (dutyrest.ID_Ref == lcusreg.ID)
                           AND (dutyrest.RestDate < График.PlannedPayDate))
 
                  InsertPlanPayTmp (RateID, Rest, dutyrest.RestDate, "X");
 
                  Rest    = dutyrest.RestSum;
                  paydate = dutyrest.RestDate;
                  stat = next (dutyrest);
               END;
            END;
 
            IF ((НедоплатаПроцентов < $0) AND (FirstPercPay == false))
               ГрафикTmp.PlannedPercentSum = ГрафикTmp.PlannedPercentSum + НедоплатаПроцентов;
            END;
 
            IF (ГрафикTmp.PlannedPercentSum < $0)
               НедоплатаПроцентов = ГрафикTmp.PlannedPercentSum;
               ГрафикTmp.PlannedPercentSum = $0;
            ELSE
               НедоплатаПроцентов = $0;
            END;
 
            IF ((paydate < График.PlannedPayDate) AND (paydate <= ГрафикTmp.PlannedPayDate))
               IF (График.PlannedPayDate <= ГрафикTmp.PlannedPayDate)
                  Rest = Rest - График.PlannedPaySum;
                  InsertPlanPayTmp (RateID, Rest, График.PlannedPayDate, "X");
                  paydate = График.PlannedPayDate;
               ELSE
                  Loans_FindLCTU(rlcusrate.TypeRateID_Ref, lcalghis);
 
                  IF ((lcalghis.TypeRest == PC_OUT_REST) AND
                      ({PercOut} == 1))
                     PlannedPayDate = ГрафикTmp.PlannedPayDate + 1;
                  ELSE
                     PlannedPayDate = ГрафикTmp.PlannedPayDate;
                  END;
                  InsertPlanPayTmp (RateID, Rest, PlannedPayDate, "X");
                  paydate = ГрафикTmp.PlannedPayDate;
               END;
            END;
 
            IF (FlagG AND (Flag == 0))
               IF (График.PlannedPayDate <= ГрафикTmp.PlannedPayDate)
                  Flag   = 1;
                  IF (NOT OneStep(FirstG, График, DT, 0, CredOperID, date(0,0,0), WayRecalculation))
                     FlagG = false;
                  END;
               END;
            END;
 
            IF (FlagGT)
               IF (Flag == 0)
                  Flag = 2;
               END;
               IF ((((График.PlannedPayDate >= ГрафикTmp.PlannedPayDate) AND FlagG) or not FlagG) AND (Flag == 2))
                  Update(ГрафикTmp);
                  Flag   = 0;
 
                  IF (not OneStep(FirstGT, ГрафикTmp, date(0,0,0), TypeGR, 0, date(0,0,0), WayRecalculation))
                     FlagGT = false;
                  END;
               END;
 
               IF (Flag == 1)
                  Flag = 2;
               ELSE
                  Flag = 0;
               END;
            END;
            IF (not FlagG AND not FlagGT)
               First = false;
            END;
         END;
      END;
      
      IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
          paydate = Договор.RegDate;
      ELSE
          paydate = Обязательство.DutyFirstDate;
      END;

      ReWind(ГрафикTmp);
      WHILE (next(ГрафикTmp))
          planpay_tmp.Clear();
          planpay_tmp.Rec.RateID = RateID;
          planpay_tmp.Rec.Date   = ГрафикTmp.PlannedPayDate;
          planpay_tmp.Rec.Marker = "X";
          stat = planpay_tmp.GetEQ();
          IF (stat)
              ГрафикTmp.PlannedPercentSum = planpay_tmp.Rec.CalcPercent;
              Update(ГрафикTmp);
              stat = planpay_tmp.next();
          END;
      END;
 
      IF (NOT RtTrn("TrnInsGPayKomiss"))
          MsgBox("Ошибка при расчете графика комиссий");
          RETURN 1;
      END;
 
      IF (Annuit)
         calcgpay.PERC_PlanCountPay    = calcgpay.PAY_PlanCountPay;
         calcgpay.PERC_PlanFirstDate   = calcgpay.PAY_PlanFirstDate;
         calcgpay.PERC_PlanLastDate    = calcgpay.PAY_PlanLastDate;
         calcgpay.PERC_Period          = calcgpay.PAY_Period;
         calcgpay.PERC_TypePeriod      = calcgpay.PAY_TypePeriod;
         calcgpay.PERC_ArrearDate      = calcgpay.PAY_ArrearDate;
 
         IF ((not ReCalc))
            ReWind(ГрафикTmp);
            next(ГрафикTmp);
            IF (Privilege)
                calcgpay.PAY_PlanCountPay = calcgpay.PAY_PlanCountPay - 1;
                next(ГрафикTmp);
                calcgpay.PAY_PlanFirstDate = ГрафикTmp.PlannedPayDate;
            ELSE
                calcgpay.PAY_PlanCountPay = calcgpay.PAY_PlanCountPay;
                calcgpay.PAY_PlanFirstDate = ГрафикTmp.PlannedPayDate;
            END;
         END;
      END;
   END;
 
   FindGoodPayGraph = TRUE;
   RETURN 0;
   
   onError(fault)
      LoansError(fault.message);
      RETURN 1;
      
END;
 
////////////////////////////////////////////////////////////////////////////////
// ДЛЯ ОВЕРДРАФТА
/*
MACRO СформироватьГрафикПогашенияОвердрафта (ObjID:integer, ObjN:integer, OperDate: date, buff, buff1)
   RECORD Буффер   ("lpayop.dbt");
   RECORD credit_c ("credit_c.dbt");

   VAR    График = TBFile("planpay.dbt", "w", 0, "planpay.dbt", "loans.def");
   VAR    CrdOP  = TBFile("crd_op.dbt",  "r", 0, "crd_op.dbt",  "loans.def");

   VAR    IsPay  = FALSE;
   VAR    stat   = FALSE;

   VAR    rs = NULL;
   VAR    QUERY      : string = "",
          SQL_INSERT : string = "";
 
   VAR    Perc_Date  : date = date(0,0,0);
   VAR    mon, year, day, RealArrearDate, Period;
   VAR GRAPHOBJECT_ID = 0;
   VAR T_GRAPHPARM_ID = 0;
   MACRO UpdPlanPay (GrType, ExpDate, Summ, SumExx,GRAPHPARM_ID)
       // Из актуального графика, на момент проведения операции, скопируем все записи в новый
      QUERY = SQL_INSERT + "SELECT ";
      QUERY = QUERY + "T_OBJECTID_REF,T_OBJECTTYPEID_REF,0,T_PLANNEDPAYDATE,T_PLANNEDEXPDATE,";
      QUERY = QUERY + "T_PLANNEDPAYSUM,T_PLANNEDPERCENTSUM,T_PLANNEDPAYSUMEX,T_TYPE,T_SHARESUM, " + GRAPHPARM_ID ;
      QUERY = QUERY + "FROM DPLANPAY_DBT WHERE T_CREDOPERID_REF = " + CrdOp.rec.CredOperID;
      QUERY = QUERY + " AND T_TYPE = " + GrType;

      rs = LnGetRecordSet(QUERY);

      // Просмотр, существует ли запись в графике для новой даты выноса на просрочку
      QUERY = "SELECT T_OBJECTID_REF, T_OBJECTTYPEID_REF FROM DPLAN_PAY_TMP ";
      QUERY = QUERY + " WHERE ";
      QUERY = QUERY + "T_OBJECTID_REF      = " + ObjN  + " AND ";
      QUERY = QUERY + "T_OBJECTTYPEID_REF  = " + ObjID + " AND ";
      QUERY = QUERY + "T_CREDOPERID_REF    = 0 AND ";
      QUERY = QUERY + "T_PLANNEDPAYDATE    = " + SQLDate(ExpDate) + " AND ";
      QUERY = QUERY + "T_PLANNEDEXPDATE    = " + SQLDate(ExpDate) + " AND ";
      QUERY = QUERY + "T_TYPE              = " + GrType;

      rs = LnGetRecordSet(QUERY);

      IF ((rs != NULL) AND (rs.MoveNext()) AND (ValType(rs.Value(0, NULL, V_INTEGER)) != V_UNDEF))
         // Если нашли, обновим иначе вставим новую запись
         IF (GrType != DS_PERC)
             QUERY = "UPDATE DPLAN_PAY_TMP SET T_PLANNEDPAYSUM = T_PLANNEDPAYSUM + " + Summ;
             QUERY = QUERY + ", T_PLANNEDPAYSUMEX = T_PLANNEDPAYSUMEX + "           + SumExx;
             QUERY = QUERY + " WHERE T_CREDOPERID_REF = 0 AND T_TYPE = " + GrType + " AND ";
             QUERY = QUERY + "T_ObjectTypeID_Ref = " + ObjID          + " AND ";
             QUERY = QUERY + "T_ObjectID_Ref     = " + ObjN           + " AND ";
             QUERY = QUERY + "T_PLANNEDPAYDATE = " + SQLDate(ExpDate) + " AND ";
             QUERY = QUERY + "T_PLANNEDEXPDATE = " + SQLDate(ExpDate);

             rs = LnGetRecordSet(QUERY);
         END;
         RETURN TRUE;
      END;
      RETURN FALSE; //это значит, что график нам надо вставлять свой
   END;

   MACRO InsPlanPay (GrType, ExpDate, Summ, SumExx,GRAPHPARM_ID)
      QUERY = SQL_INSERT + " VALUES (";
      QUERY = QUERY  + ObjN  + ",";            // T_OBJECTID_REF
      QUERY = QUERY  + ObjID + ",";            // T_OBJECTTYPEID_REF
      QUERY = QUERY  + "0, ";                  // T_CREDOPERID_REF
      QUERY = QUERY  + SQLDate(ExpDate) + ","; // T_PLANNEDPAYDATE
      QUERY = QUERY  + SQLDate(ExpDate) + ","; // T_PLANNEDEXPDATE
      QUERY = QUERY  + Summ + ",";             // T_PLANNEDPAYSUM
      QUERY = QUERY  + "0,";                   // T_PLANNEDPERCENTSUM
      QUERY = QUERY  + SumExx + ",";           // T_PLANNEDPAYSUMEX
      QUERY = QUERY  + GrType + ",";           // T_TYPE
      QUERY = QUERY  + " 0 ,";                  // T_REZERV
      QUERY = QUERY  + GRAPHPARM_ID + ")";     //T_GRAPHPARM_ID

      rs = LnGetRecordSet(QUERY);
   END;

   MACRO ProcessPlanPay(GrType, ExpDate, Summ, SumExx,GRAPHPARM_ID)
      stat = FALSE;
      
      // Если есть более ранний график, обновим его
      IF (IsPay)
         stat = UpdPlanPay(GrType, ExpDate, Summ, SumExx,GRAPHPARM_ID);
         IF ((ObjID != LO_OVERDRAFT) AND (stat == TRUE))
             RETURN stat;
         END;
      END;

       // Иначе просто добавим новую запись
      IF (NOT stat)
       InsPlanPay(GrType, ExpDate, Summ, SumExx,GRAPHPARM_ID);
      END;

      RETURN TRUE;
   END;

   MACRO INS_DPLANLINK(ObjID,ObjN, GrType ): integer
     VAR SQL_get = "SELECT NVL(T_ID,0) ";
        SQL_get = SQL_get + " FROM DGRAPHTREEPARM_dbt ";
        SQL_get = SQL_get + " WHERE ";
        SQL_get = SQL_get + " T_GRAPHOBJECT_ID_REF IN ( SELECT T_ID  FROM DGRAPHOBJECT_DBT WHERE T_OBJECTID = " + ObjID + " AND T_OBJECTNUMBER = " + ObjN+ " ) ";
        SQL_get = SQL_get + " AND T_GRAPHKIND_ID_REF = " + GrType ;
        SQL_get = SQL_get + " ORDER BY T_GRAPHKIND_ID_REF ";
     VAR  GRAPHID  = 0;
     GRAPHID = LnSelectValue(SQL_get, V_INTEGER);
     IF (GRAPHID != 0)
        SQL_get = "INSERT INTO DPLANLINK_TMP(T_NUM,T_GRAPHID) VALUES(" + GrType + "," + GRAPHID + ")";
        rs = LnGetRecordSet(SQL_get);
     END;
     RETURN GRAPHID;
   END;
   
   SetBuff(Буффер, buff);
   SetBuff(calcgpay, buff1);

   GRAPHOBJECT_ID = LnSelectValue(" SELECT T_ID  FROM DGRAPHOBJECT_DBT WHERE T_OBJECTID = " + ObjID + " AND T_OBJECTNUMBER = " + ObjN, V_INTEGER);   
   
   IF (NOT Loans_FindCrdContract(ObjN, credit_c))
      RETURN FALSE;
   END;

   // Удалим все старые записи
   LnGetRecordSet("DELETE FROM DPLAN_PAY_TMP WHERE T_CREDOPERID_REF = 0 AND T_ObjectTypeID_Ref = "+ObjID+" AND T_ObjectID_Ref= "+ObjN);

   // Поиск операции возникновения овердрафта
   IF (NextOpSystType (FALSE, ObjN, CrdOp, CS_PAY, FALSE, 0, ObjID))
      Rewind(lpayop);
      lpayop.CredOperID_Ref = CrdOP.rec.CredOperID;
      IF (getEQ(lpayop) AND lpayop.CredOperID_Ref == CrdOP.rec.CredOperID)
         IsPay = true; // Нашли
      END;
   END;

   SQL_INSERT = "INSERT INTO DPLAN_PAY_TMP (T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF,";
   SQL_INSERT = SQL_INSERT + "T_PLANNEDPAYDATE, T_PLANNEDEXPDATE,T_PLANNEDPAYSUM,T_PLANNEDPERCENTSUM,";
   SQL_INSERT = SQL_INSERT + "T_PLANNEDPAYSUMEX,T_TYPE,T_SHARESUM,T_GRAPHPARM_ID)";

   T_GRAPHPARM_ID  = INS_DPLANLINK(ObjID,ObjN,1);
   IF (T_GRAPHPARM_ID != 0) 
    stat = ProcessPlanPay(1, calcgpay.PAY_PlanFirstDate, Буффер.PaySum, Буффер.PayLimSum,T_GRAPHPARM_ID);
   ELSE 
      STAT = FALSE;
   END;
   
   // График погашение процентов
   IF ((ObjID == LO_OVERDRAFT) AND (stat == TRUE))
      T_GRAPHPARM_ID  = INS_DPLANLINK(ObjID,ObjN,2); 
      IF (T_GRAPHPARM_ID != 0)
         stat = ProcessPlanPay(2, calcgpay.PERC_PlanFirstDate, $0, $0,T_GRAPHPARM_ID);
         IF ((calcgpay.PAY_PlanFirstDate > calcgpay.PERC_PlanFirstDate) )
            IF ((credit_c.repdate > date(0,0,0)) AND (credit_c.dutyday > 0))
               Perc_Date = calcgpay.PERC_PlanFirstDate;
      
               Period = 1;
               IF (credit_c.typerepdate != 1)
                  Period = 3;
               END;
               datesplit(calcgpay.PERC_PlanFirstDate, day, mon, year);
      
               //достроим еще периодов для графика погашения процентов
               WHILE (Perc_Date < calcgpay.PAY_PlanFirstDate)
                  mon = mon + Period;
                  IF ( mon > 12 )
                    mon = mon - 12;
                    year = year + 1;
                  END;
                  RealArrearDate = ДеньВыносаНаПросрочку(day, Date(1,mon,year));
                  Perc_Date = Date( RealArrearDate, mon, year );
                  stat = ProcessPlanPay(2, Perc_Date, $0, $0,T_GRAPHPARM_ID);
               END;
            END
         END;
      ELSE 
         stat = false;
      END;
   END;
  // RunScroll (RSDRecordset(RsdCommand(RslDefCon, "SELECT * FROM DPLAN_PAY_TMP"), RSDVAL_CLIENT, RSDVAL_STATIC), null, null, null, null, "", null, true); 
   RETURN stat;
END;
*/

/*Расчет количества платежных периодов на основании суммы платежа*/
MACRO PSum_In_CountPay(ObjectTypeID, PAY_PlanFirstDate, PAY_TypePeriod, PAY_Period, PAY_DutyPaymentSum, Privilege, SumCalc, Annuit)
   VAR Rate = 0.0, Anuitet = 0.0, count:integer = 0, ObjectID;
   VAR EndDate = date(0,0,0), Sum = $0, m1 = date(0,0,0), m2 = date(0,0,0);
   VAR DT = 0, year, RegID = TDR_MAINREST;

   IF ((ObjectTypeID != LO_DUTY)AND(ObjectTypeID != LO_BANKGUARANTEE))
      ObjectID = Договор.CreditNumber;
      EndDate = Договор.ReturnDate;
      Sum = Договор.CreditSum;
      IF ((ObjectTypeID == LO_GUARANTEE)OR
          (ObjectTypeID == LO_BANKGUARANTEE))
         RegID = TDR_PAYMGUARANTEE;
      END;
   ELSE
      ObjectID = Обязательство.DutyID;
      EndDate = Обязательство.DutyLastDate;
      Sum = Обязательство.DutySum;
   END;

   IF (Sum == $0)
      Sum = ОстатокРегистра(ObjectTypeID, ObjectID, RegID, EndDate);
   END;

   // Переданная сумма
   IF ((ValType(SumCalc) != V_UNDEF) AND (SumCalc > 0) /*AND (Sum == 0)*/)
      Sum = SumCalc;
   END;

   IF (PAY_DutyPaymentSum == 0)
      RETURN 0;
   END;

   IF (Annuit)
      Rate = Loans_FindRateVal(ObjectTypeID, ObjectID, TRU_CRD, {curdate}, false)/100;

      IF (Rate != 0.0)
            DateSplit(PAY_PlanFirstDate, NULL, NULL, year);
            m1 = date(1,1,year);
            m2 = date(1,1,year+1);
            DT = NDays(m2) - NDays(m1);

            IF (PAY_TypePeriod == 0)
                Rate = PAY_Period * Rate / 12;
            ELSE
                Rate = PAY_Period * Rate / DT;
            END;
      END;

      IF ((Rate != 0.0) AND (double(round(PAY_DutyPaymentSum - Sum * Rate)) != 0.0))
         Anuitet = (double(PAY_DutyPaymentSum))/(double(PAY_DutyPaymentSum) - double(Sum * Rate));

         IF(Anuitet <= 0)
            MsgBox("При заданной сумме аннуитета количество платежей определить невозможно");
            RETURN 0;
         END;         

         count = floor(log10(Anuitet)/log10(1+Rate));
      END;

      count = int(count);
      count = count + 1;
      IF (Privilege)
            count = count + 1;
      END;
   ELSE
      count = floor(double(Sum)/double(PAY_DutyPaymentSum))+1;
   END;
   count = int(count);
   RETURN count;
END;

MACRO CalcPlanCountPay (FirstDate, LastDate, Period, ArrearDate, day_pay,typeperiod)
VAR pdate = FirstDate, temp_date = pdate, CountPay = 1, day, mon, year;

   DateSplit(pdate, day, mon, year);

   IF ((day == 0) OR (mon == 0) OR (year == 0) OR (FirstDate > LastDate))
       RETURN 0;
   END;

   IF (FirstDate == LastDate)
       RETURN 1;
   END;

   WHILE (pdate < LastDate)
      IF(typeperiod == CF_DAY)
         pdate = DateAfterCalenDays(FirstDate, CountPay * Period);
      ELSE
         pdate = DateAfterCalenMonths(FirstDate, CountPay * Period);
         DateSplit(pdate, day, mon, year);
         day = ДеньВыносаНаПросрочку(ArrearDate,pdate);
         pdate = date(day, mon, year);
      END;
      IF (pdate >= LastDate)
         RETURN CountPay + 1;
      END;

      CountPay = CountPay + 1;
      IF ((Loans_IsHoliday(pdate)) AND (day_pay == EXP_WORKNEXT))  //выходной И "Если выходной - следующий рабочий"
         temp_date = pdate;
         WHILE (Loans_IsHoliday(pdate))
            pdate = GetDateAfterWorkDays(pdate, 0);
         END;

         IF (pdate == LastDate)
            RETURN CountPay/* + 1*/; // SCR 174953
         ELSE
            pdate = temp_date;
         END;
      END;
   END;

   RETURN CountPay + 1;

   onError
      RETURN 0;
END;

MACRO ReCalcPlanCountPay (ObjectTypeID, ModeRecalc, buff, OpDate)
   SetBuff(calcgpay, buff);
   IF ((ModeRecalc == INIT_PERC) OR (ModeRecalc == RECALC_PERC))
      IF (calcgpay.PERC_TypePeriod == CF_MONTH)
         RETURN CalcPlanCountPay (calcgpay.PERC_PlanFirstDate, calcgpay.PERC_PlanLastDate, calcgpay.PERC_Period, calcgpay.PERC_ArrearDate, calcgpay.Pay_PayDay);
      ELSE
         IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
            RETURN ((NDays(Обязательство.DutyLastDate) - NDays(calcgpay.PERC_PlanFirstDate)) / calcgpay.PERC_Period + 1);
         ELSE
            IF ((ModeReCalc == INIT_PERC) AND ((Договор.PayType == CF_POSTERESTANTE) OR (Договор.PayType == CF_BEFOREMATURITY)))
               RETURN 1;
            ELSE
               RETURN ((NDays(Договор.ReturnDate) - NDays(calcgpay.PERC_PlanFirstDate)) / calcgpay.PERC_Period + 1);
            END;
         END;
      END;
   ELIF ((ModeRecalc == INIT_DUTY) OR (ModeRecalc == RECALC_DUTY))
      IF (calcgpay.PAY_TypePeriod == CF_MONTH)
         RETURN CalcPlanCountPay (calcgpay.PAY_PlanFirstDate, calcgpay.PAY_PlanLastDate, calcgpay.PAY_Period, calcgpay.PAY_ArrearDate, calcgpay.Pay_PayDay);
      ELSE
         IF ((ObjectTypeID == LO_DUTY)OR(ObjectTypeID == LO_BANKGUARANTEE))
            RETURN ((NDays(Обязательство.DutyLastDate) - NDays(calcgpay.PAY_PlanFirstDate)) / calcgpay.PAY_Period + 1);
         ELSE
            IF ((ModeReCalc == INIT_DUTY) AND ((Договор.PayType == CF_POSTERESTANTE) OR (Договор.PayType == CF_BEFOREMATURITY)))
               RETURN 1;
            ELSE
               RETURN ((NDays(Договор.ReturnDate) - NDays(calcgpay.PAY_PlanFirstDate)) / calcgpay.PAY_Period + 1);
            END;
         END;
      END;
   END;
   RETURN 0;
END;

// Пакетный перерасчет графиков погашения
MACRO FillFileGroupRecalcGPay(OpDate: date, CurCode: integer, TypeOper: integer, UserType: string, FNCash: integer, ViewScroll: bool)
   VAR workMode = GROUPOP_WM_USECNV,
       OpInitStruct = NULL, R, ConvID = 0, stat = 0, t1,
       obj = RecalcGraphConvParams(), rs = NULL;

   IF (ViewScroll)
      workMode = GROUPOP_WM_INONESESSION;
   END;

   BegAction(1, "Выполнение операции. Ждите, это может занять время.", false);
   
   OpInitStruct = GroupOpInitStruct(workMode, true, true);

   obj.OperType      = TypeOper;
   obj.OperDate      = OpDate;
   obj.UserCreditKind= UserType;
   obj.CurCode       = CurCode;
   obj.FnCash        = FnCash;
   obj.CreditKind    = TArray();
   obj.InitStruct    = OpInitStruct;

   rs = TRsbDataSet("SELECT T_CREDITTYPEID_REF FROM DSET_TCR_TMP WHERE T_SETFLAG = 'X'");
   WHILE (rs.moveNext())
      obj.CreditKind[obj.CreditKind.size] = rs.credittypeid_ref;
   END;

   GetRegistryValue("RS-LOANS\\ПАКЕТНЫЕ ОПЕРАЦИИ\\ПЕРЕРАСЧЕТ ГРАФИКА ПОГАШЕНИЯ\\ВИД_ЗАПУСКА", V_INTEGER, ConvID, stat);
   IF ((stat != 0) OR (ConvID == 0))
      LoansError("Не задано значение настройки реестра\n'RS-LOANS\\ПАКЕТНЫЕ ОПЕРАЦИИ\\ПЕРЕРАСЧЕТ ГРАФИКА ПОГАШЕНИЯ\\ВИД_ЗАПУСКА'!");
      EndAction(1);
      RETURN 1;
   END;

   PrintLn("Пакетный перерасчет графиков погашения");
   PrintLn("Дата ", OpDate);
   t1 = time;

   R = RunGroupOp(ConvID, obj, OpInitStruct);

   IF (R > 0)
      PrintLn("\nПроцедура завершена успешно!");
   ELSE
      PrintLn("\nПроцедура завершена с ошибками!");
   END;
   
   PrintLn("Время работы: ", (time - t1), " сек");

   EndAction(1);

   RETURN R;
OnError(err)
   IF (ValType(err.Err) == V_INTEGER)
      LoansError(err.Err + " " + err.Message);
   ELSE
      LoansError("18644. Ошибка выполнения операции");
   END;

   EndAction(1);
   RETURN 0;    
END;

MACRO CalcPlanCountPayDepo(FirstDate, LastDate, Period, ArrearDate, day_pay, typeperiod)
   RETURN CalcPlanCountPay (FirstDate, LastDate, Period, ArrearDate, day_pay, typeperiod);
END;

// Досрочное погашение в графиках GraphContext.Early_pay
const   Early_pay_NOT = 0,    // не досрочное погашение
        Early_pay_ReducePeriod = 1,    // уменьшение периода
        Early_pay_ReduceSum = 2,    // уменьшение суммы записи
        Early_pay_Nextpay = 3;    // погашение ближайших записей    

/*
* Формирование ГП
* ObjID - Вид объекта
* ObjN  - Номер объекта
* GraphKindIdRef - ID графика
* OperDate       - Дата 
* OpType         - Номер операции
* isEarlyPay     - Досрочное погашение
* isReducePer    - Уменьшение срока
* isReduceSumPer - Уменьшение суммы записи
* isPayClosePay  - Погашение ближайших платежей
*/
MACRO CalcPlanPay(ObjID, ObjN, GraphKindIdRef, OperDate, OpType, isEarlyPay, isReducePer, isReduceSumPer, isPayClosePay)
   VAR retval = 0;
   VAR EarlyPay = Early_pay_NOT;
   // Обнулим контекст графика     
   LnSqlExec("BEGIN LoansFillpayment.Clear_ContextGraph; END;");

   // Определим тип контекста
   IF (isEarlyPay == 88)
      IF (isReducePer == 88)
         EarlyPay = Early_pay_ReducePeriod;
      ELIF (isReduceSumPer == 88)
         EarlyPay = Early_pay_ReduceSum;    
      ELSE
         EarlyPay = Early_pay_Nextpay;
      END;
      // Установим контекст погашения   
      LnSqlExec("BEGIN LoansFillpayment.PUT_ContextGraph_Early_pay("+EarlyPay+"); END;");
   END;    


   VAR cmd1;
   VAR cnt  = LnSelectValue("SELECT count(1)  " +
   "FROM DKINDGRAPHS_TMP "
    "WHERE T_GRAPHTREEPARM_ID_REF IN ( SELECT T_ID "+
                                       "FROM DGRAPHTREEPARM_TMP GRAPHTREEPARM " +
                                       "WHERE GRAPHTREEPARM.T_ID = " + GraphKindIdRef + " OR GRAPHTREEPARM.T_PARENTID = "+ GraphKindIdRef +" ) " , V_INTEGER);
   IF (cnt == 0)
        cmd1 = RsdCommand(RslDefCon, 
       "INSERT INTO DKINDGRAPHS_TMP (T_GRAPHTREEPARM_ID_REF) " +
       "SELECT T_ID " +
       "FROM DGRAPHTREEPARM_TMP GRAPHTREEPARM " +
       "WHERE (GRAPHTREEPARM.T_ID = " + GraphKindIdRef + " OR GRAPHTREEPARM.T_PARENTID = "+ GraphKindIdRef +" ) " );
       cmd1.execute();  
   ELSE
      IF (EarlyPay > 0)
         cmd1 = RsdCommand(RslDefCon, 
         "delete FROM DKINDGRAPHS_TMP "+
         " WHERE T_GRAPHTREEPARM_ID_REF IN "+ 
         " (  "+
         " SELECT T_GRAPHTREEPARM_ID_REF "+
         " FROM DGRAPHKINDPARM_tmp "+
         " WHERE "+
         " T_GRAPHTREEPARM_ID_REF IN "+
         " (SELECT T_ID "+ 
         " FROM DGRAPHTREEPARM_tmp GRAPHTREEPARM "+ 
         " WHERE GRAPHTREEPARM.T_ID = " + GraphKindIdRef + " OR GRAPHTREEPARM.T_PARENTID = " + GraphKindIdRef + " ) "+
         " AND T_FLAGTYPEGRAPH = chr(88)  "+
         " AND T_TYPEGRAPH = 1     "+          //loansconst.GRA_DUTY
         " AND T_SUBTYPEGRAPH = 0    "+       // loansconst.VGS_Duty
         " ) "
         );
         cmd1.execute();

         cmd1 = RsdCommand(RslDefCon, 
         "INSERT INTO DKINDGRAPHS_TMP (T_GRAPHTREEPARM_ID_REF) " +
         "SELECT T_GRAPHTREEPARM_ID_REF "+
              " FROM DGRAPHKINDPARM_tmp "+
              " WHERE "+
              " T_GRAPHTREEPARM_ID_REF IN "+
              " (SELECT T_ID "+ 
              " FROM DGRAPHTREEPARM_tmp GRAPHTREEPARM "+ 
              " WHERE GRAPHTREEPARM.T_ID = " + GraphKindIdRef + " OR GRAPHTREEPARM.T_PARENTID = " + GraphKindIdRef + " ) "+
              " AND T_FLAGTYPEGRAPH = chr(88)  "+
              " AND T_TYPEGRAPH = 1     "+          //loansconst.GRA_DUTY
              " AND T_SUBTYPEGRAPH = 0    " );     // loansconst.VGS_Duty
         cmd1.execute();
      END;    
   END;   

   retval = CalcGraph(ObjID,ObjN,GraphKindIdRef,OperDate,0,CN_Graph);

   IF (ObjID != LO_CLAIM)
      IF(ppattredit(ObjID, ObjN, GraphKindIdRef, OperDate))
        /*Отказ от построения графика*/
        RETURN;
      ELSE
          retval = CalcGraph(ObjID,ObjN,GraphKindIdRef,OperDate,0,CN_Graph);
      END;
   END;    
END;


////////////////////////////////////////////////////////////////////////////////
// ДЛЯ ОВЕРДРАФТА
MACRO СформироватьГрафикПогашенияОвердрафта (ObjID:integer, ObjN:integer, OperDate: date, buff, buff1)

   RECORD Буффер   ("lpayop.dbt");
   RECORD credit_c ("credit_c.dbt");

   VAR GRAPHOBJECT_ID = 0;
   VAR cmd = null;
   VAR rs = null;
   VAR retval = 0;
   VAR stat   = true;
   //Произведем заполнение
   GRAPHOBJECT_ID = LnSelectValue(" SELECT T_ID  FROM DGRAPHOBJECT_DBT WHERE T_OBJECTID = " + ObjID + " AND T_OBJECTNUMBER = " + ObjN, V_INTEGER);   
   IF (GRAPHOBJECT_ID > 0)
       cmd = RsdCommand (RslDefCon, "BEGIN  ? := RSI_LOANSGRAPHKIND.FillTable(?); END;");
       cmd.addParam("rv",             RSDBP_OUT, retval);
       cmd.addParam("GRAPHOBJECT_ID", RSDBP_IN); cmd.value ("GRAPHOBJECT_ID")    = GRAPHOBJECT_ID;
       stat = cmd.execute();

       VAR cmd2 = RsdCommand(RslDefCon,  "delete FROM DPLANLINK_TMP");
       cmd2.execute();
       
      //Формирование ГП
      rs = LnGetRecordSet( " SELECT T_ID " +
                           " FROM DGRAPHTREEPARM_tmp " + 
                           " WHERE " +
                           " T_GRAPHOBJECT_ID_REF = " + GRAPHOBJECT_ID +
                           " AND T_GRAPHKIND_ID_REF = 12 " );
       IF (rs == NULL) stat = FALSE; END;
       IF (rs.MoveNext()) 
          VAR GRAPHTREEPARM_ID =  rs.Value(0);
          stat = CalcPlanPay(ObjID, ObjN, GRAPHTREEPARM_ID, OperDate);
          
          cmd = RsdCommand (RslDefCon, "BEGIN RSI_LOANSGRAPHKIND.Fill_planOB(?,?,?); END;");
          cmd.addParam ("ObjectTypeID",    RSDBP_IN); cmd.value ("ObjectTypeID")    = ObjID;       
          cmd.addParam ("ObjectNumber",    RSDBP_IN); cmd.value ("ObjectNumber")    = ObjN;       
          cmd.addParam ("GraphID",    RSDBP_IN); cmd.value ("GraphID")    = GRAPHTREEPARM_ID;
          stat = cmd.execute();                    
       END;  
   END;
   
   RETURN 1;
END;

// Функция заполнения временной таблицы
MACRO FillFile(ObjID, ObjN, CredOperId, GRAPHOBJECT_ID_REF)
   //чистим временую таблицу
   VAR cmd2 = RsdCommand(RslDefCon,  "delete FROM DKINDGRAPHS_TMP");
   cmd2.execute();
   
   VAR retval = 0;
   //для заявки ищем ВК.
   VAR ObjID_IN = ObjID;
   VAR ObjN_IN = ObjN;

   // Есть записи
   VAR ID = 0;
   IF ((GRAPHOBJECT_ID_REF == 0) or  (ValType(GRAPHOBJECT_ID_REF) == V_UNDEF)) 
       ID = 
   CRSDCommand("SELECT T_ID FROM DGRAPHOBJECT_DBT WHERE T_OBJECTID = ? AND T_OBJECTNUMBER = ?",
               "p1", ObjID_IN,
               "p2", ObjN_IN,
              V_INTEGER);
    ELSE
       ID =  GRAPHOBJECT_ID_REF;
    END;                  

   IF (ID != 0)
      VAR RSDcmd = RsdCommand(RslDefCon, "BEGIN ? := RSI_LOANSGRAPHKIND.FillTable(?, ?, ?); END; "); 
      RSDcmd.addParam("rv", RSDBP_OUT, retval);
      RSDcmd.addParam("id", RSDBP_IN, ID);
      RSDcmd.addParam("Many", RSDBP_IN, 0);      
      RSDcmd.addParam("CredOperId", RSDBP_IN, CredOperId);      
      RSDcmd.Execute();

      RETURN (retval == 0);
   ELSE   
      VAR max_objId = CRSDCommand("SELECT DGRAPHOBJECT_DBT_SEQ.NEXTVAL FROM DUAL", V_INTEGER);

      RSDcmd = RsdCommand(RslDefCon, "INSERT INTO DGRAPHOBJECT_TMP (T_ID, T_OBJECTID, T_OBJECTNUMBER, T_MACRO, T_ISUSERPROC, T_USERPROC) "
                                     "VALUES (?, ?, ?, 'treemacros.mac', CHR(0), CHR(1))");
      RSDcmd.addParam("maxid", RSDBP_IN, max_objId);
      RSDcmd.addParam("objid", RSDBP_IN, ObjID);
      RSDcmd.addParam("objn",  RSDBP_IN, ObjN);
      RSDcmd.Execute();
   END;

   RETURN TRUE;
END;

MACRO Print_gr(OBJECTTYPEID_REF,OBJECTID_REF,GRAPHPARM_ID)
   VAR query,cmd;  
   VAR sum = $0;
   CaptureOutput;
   [
         SELECT T_PLANNEDPAYDATE, T_PLANNEDPAYSUM
         FROM DPLAN_PAY_TMP
         WHERE T_OBJECTTYPEID_REF = ?
             AND T_OBJECTID_REF     = ?
             AND T_GRAPHPARM_ID     = ?;     
   ];
   query = StopCaptureOutput;
   cmd = CRsdCommand(query ,"OBJECTTYPEID_REF",OBJECTTYPEID_REF,"OBJECTID_REF",OBJECTID_REF, "GRAPHPARM_ID", GRAPHPARM_ID, V_GENOBJ_RsdCommand);

   VAR sql_r = TRsbDataSet(cmd);
   IF (valtype(sql_r) != V_UNDEF ) 
      WHILE (sql_r.movenext())
         [│  ########## │#########################│]
             (
             SQL_NVL(sql_r.T_PLANNEDPAYDATE , V_DATE ),
             SQL_NVL(sql_r.T_PLANNEDPAYSUM , V_MONEY ):a
             ); 
         sum = sum + SQL_NVL(sql_r.T_PLANNEDPAYSUM , V_MONEY )
      END; 
   END;
   PrintLn("Итого: ", sum);      
END;

MACRO GET_IDGRAPH(GraphID,isOD,isGroup)
    VAR query;
    VAR ID;
    CaptureOutput;
    IF (isGroup == 88)
        [
            SELECT graphkindparm.t_graphtreeparm_id_ref
            FROM DGRAPHTREEPARM_tmp GRAPHTREEPARM join  dgraphkindparm_tmp graphkindparm ON (GRAPHTREEPARM.T_ID = graphkindparm.t_graphtreeparm_id_ref )
            WHERE GRAPHTREEPARM.T_PARENTID = ?
            AND T_FLAGTYPEGRAPH = chr(88)
            AND T_SUBTYPEGRAPH = ?
            AND T_TYPEGRAPH = 1
        ];
    ELSE
        [      
            SELECT graphkindparm.t_graphtreeparm_id_ref
            FROM  dgraphkindparm_tmp graphkindparm
            WHERE graphkindparm.t_graphtreeparm_id_ref  = ?
            AND T_FLAGTYPEGRAPH = chr(88)
            AND T_SUBTYPEGRAPH = ?
            AND T_TYPEGRAPH = 1
        ];    
    END;
    query = StopCaptureOutput;
    ID = CRsdCommand(query,"GraphID",GraphID,"isOD",isOD, V_INTEGER );
    RETURN ID;
END;

//Для заявки
MACRO CalcPlan(parm_calc:@Tddition_parm_calc_graph, test_mode )
   VAR objID; 
   VAR objNum; 
   VAR query;
   VAR cmd;
   VAR GraphID_OD;
   VAR GraphID_perc;
   VAR isGroup;
   IF (parm_calc.objNum <= 0) // заявки ещё нет в базе.
      objID = LO_TYPECREDIT;
      objNum = parm_calc.RecClaim.rec.CreditTypeID_Ref;
   ELSE
      CaptureOutput;
      [
            SELECT T_CREDITTYPEID, T_OBJECTTYPEID
            FROM dclaim_dbt , dtype_crd_dbt
            WHERE T_CLAIMID = ?
            AND T_CREDITTYPEID_REF = T_CREDITTYPEID;     
      ];
      query = StopCaptureOutput;
      cmd = CRsdCommand(query ,"CLAIMID", parm_calc.objNum, V_GENOBJ_RsdCommand);
      VAR sql_r = TRsbDataSet(cmd);
      IF (sql_r.movenext())
         objNum = SQL_NVL(sql_r.CREDITTYPEID , V_INTEGER );
         objID = SQL_NVL(sql_r.OBJECTTYPEID , V_INTEGER );
      ELSE 
         RunError("Для заявки не найден вид кредита!");
      END;
   END; 

   // заполняем таблицу с вида кредита
   FillFile(objID, objNum, 0);
   CaptureOutput;
   [ 
    update DGRAPHOBJECT_tmp set T_OBJECTID = ?, T_OBJECTNUMBER = ? WHERE T_OBJECTID = ? AND T_OBJECTNUMBER = ?
   ];
   query = StopCaptureOutput;
   cmd = CRsdCommand(query ,"OBJECTID",parm_calc.objID ,"T_OBJECTNUMBER", parm_calc.objNum ,"OBJ",objID, "OBJECTNUM", objNum , V_GENOBJ_RsdCommand);
  
   //Определим группа это или нет
   CaptureOutput;
   [
    SELECT T_ISGROUP
    FROM DGRAPHTREEPARM_TMP GRAPHTREEPARM join  dgraphkind_dbt graphkind ON (GRAPHTREEPARM.T_GRAPHKIND_ID_REF = graphkind.T_ID )
    WHERE GRAPHTREEPARM.T_ID = ?
   ];
   query = StopCaptureOutput;
   isGroup = CRsdCommand(query,"GraphID",parm_calc.GraphID, V_INTEGER );
  
   //Найдем график ОД 
   GraphID_OD = GET_IDGRAPH(parm_calc.GraphID,0,isGroup);
   //Найдем график процентов
   GraphID_perc = GET_IDGRAPH(parm_calc.GraphID,1,isGroup);
    
   VAR cmd1 = RsdCommand(RslDefCon, 
   "INSERT INTO DKINDGRAPHS_TMP (T_GRAPHTREEPARM_ID_REF) " +
   "SELECT T_ID " +
   "FROM DGRAPHTREEPARM_TMP GRAPHTREEPARM " +
   "WHERE (GRAPHTREEPARM.T_ID = " + parm_calc.GraphID + " OR GRAPHTREEPARM.T_PARENTID = "+ parm_calc.GraphID +" ) " );
   cmd1.execute();
    
   IF ((valtype(GraphID_OD) != V_UNDEF) )
      CaptureOutput;
      [
        update DKINDGRAPHS_TMP
        set 
        T_TOTALSUMMA = ?, 
        T_DateBegin = ? , 
        T_DURATION = ?, 
        T_TYPEDURATION = ?,
        T_TypeCred = ?
        WHERE T_GRAPHTREEPARM_ID_REF = ?
      ];
      query = StopCaptureOutput;
      cmd = CRsdCommand(query  ,"TOTALSUMMA",parm_calc.TOTALSUMMA, "DateBegin",parm_calc.DateBegin ,"DURATION",parm_calc.DURATION, "TYPEDURATION",parm_calc.TYPEDURATION, "TypeCred",parm_calc.RecClaim.rec.CreditTypeID_Ref,"GRAPHTREEPARM_ID_REF",GraphID_OD, V_GENOBJ_RsdCommand);
      
      CaptureOutput;
      [
        update DGRAPHKINDPARM_TMP
        set 
          T_PERIODAMT = ?,
          T_PERIOD = ?,
          T_DAY = ?
        WHERE T_GRAPHTREEPARM_ID_REF = ?
      ];
      query = StopCaptureOutput;
      cmd = CRsdCommand(query  ,"PERIODAMT",parm_calc.PERIODAMT_OD, "PERIOD",parm_calc.PERIOD_OD ,"DAY",parm_calc.DAY_OD,"GRAPHTREEPARM_ID_REF",GraphID_OD, V_GENOBJ_RsdCommand);
   END; 
  
   IF ((valtype(GraphID_perc) != V_UNDEF) )
      CaptureOutput;
      [
        update DKINDGRAPHS_TMP
        set 
        T_TOTALSUMMA = ?, 
        T_DateBegin = ? , 
        T_DURATION = ?, 
        T_TYPEDURATION = ?,
        T_RATE = ?,
        T_TypeCred = ?
        WHERE T_GRAPHTREEPARM_ID_REF = ?
      ];
      query = StopCaptureOutput;
      cmd = CRsdCommand(query  ,"TOTALSUMMA",parm_calc.TOTALSUMMA, "DateBegin",parm_calc.DateBegin ,"DURATION",parm_calc.DURATION, "TYPEDURATION",parm_calc.TYPEDURATION,"RATE",parm_calc.RATE, "TypeCred",parm_calc.RecClaim.rec.CreditTypeID_Ref,"GRAPHTREEPARM_ID_REF",GraphID_perc, V_GENOBJ_RsdCommand);
      
      CaptureOutput;
      [
        update DGRAPHKINDPARM_TMP
        set 
          T_PERIODAMT = ?,
          T_PERIOD = ?,
          T_DAY = ?
        WHERE T_GRAPHTREEPARM_ID_REF = ?
      ];
      query = StopCaptureOutput;
      cmd = CRsdCommand(query  ,"PERIODAMT",parm_calc.PERIODAMT_Perc, "PERIOD",parm_calc.PERIOD_Perc ,"DAY",parm_calc.DAY_Perc,"GRAPHTREEPARM_ID_REF",GraphID_perc, V_GENOBJ_RsdCommand);
   END;   
  
   CalcPlanPay(parm_calc.objID, parm_calc.objNum, parm_calc.GraphID, {curdate});
  
   IF (test_mode == 1)
      CaptureOutput;
      [
        SELECT kindgraphs.t_graphtreeparm_id_ref, graphkind.T_SHORTNAME
        FROM DKINDGRAPHS_TMP kindgraphs join  dgraphkindparm_tmp graphkindparm ON (kindgraphs.t_graphtreeparm_id_ref = graphkindparm.t_graphtreeparm_id_ref )
                             join dgraphtreeparm_tmp graphtreeparm ON(GRAPHTREEPARM.T_ID = kindgraphs.t_graphtreeparm_id_ref), dgraphkind_dbt graphkind
        WHERE graphkindparm.T_FLAGTYPEGRAPH = chr(88)  AND graphkindparm.T_TYPEGRAPH = 1
        AND graphkind.T_ID = graphtreeparm.T_GRAPHKIND_ID_REF        
      ];         
      query = StopCaptureOutput;
      cmd = CRsdCommand(query , V_GENOBJ_RsdCommand);

      sql_r = TRsbDataSet(cmd);
      IF (valtype(sql_r) != V_UNDEF ) 
         WHILE (sql_r.movenext())
            PrintLn(SQL_NVL(sql_r.T_SHORTNAME, V_STRING ));
            Print_gr(parm_calc.objID,parm_calc.objNum,SQL_NVL(sql_r.t_graphtreeparm_id_ref, V_INTEGER ));
         END; 
      END;  
   END;  
END;

MACRO GraphLoad(buff, ObjID, ObjN, OperDate, FileName, Path)
   RECORD graphtreeparm ("graphtreeparm.dbt");
   SetBuff(graphtreeparm, buff);
   PrintLn("Протокол загрузки");
   LnSQLExec("DELETE FROM DPLAN_PAY_TMP");

   IF (NOT OpenExcelFile (FileName, FALSE, TRUE, Path))
      RETURN;     
   END;
   VAR ExcludeFirstRow = FALSE; // Исключить первую строку
   VAR IncludeDateExp  = FALSE; // Есть дата просрочки
   VAR ColStart = 2; // Столбец с цифрами

   VAR ActSheet = ExcelApplication.ActiveSheet; /*Активная страница*/

   // Общий массив дат
   VAR MasGlobGraph = TArray;

   VAR Col = 0; VAR R = 2;
   WHILE (TRUE)
      Col = Col + 1;
      IF (ValType(ActSheet.Cells(1, Col).Value) == V_UNDEF)
         Col = Col - 1;
         BREAK;
      END;

      // Общий массив сумм
      VAR MasGraphich = TArray;

      MasGlobGraph(MasGlobGraph.Size) = MasGraphich;
   END;

   IF (Col < 2)
      PrintLn("Ошибка: Минимальное число столбцов равно 2");
      RETURN;
   END;

   VAR Row = 0; VAR I = 0;
   WHILE (TRUE)
      Row = Row + 1;
      IF (ValType(ActSheet.Cells(Row, 1).Value) == V_UNDEF)
         Row = Row - 1;
         BREAK;
      END;

      // В первой строке могут быть надписи
      IF ((Row == 1) AND (ValType(ActSheet.Cells(1, 1).Value) == V_STRING))
         ExcludeFirstRow = TRUE;
      END;

      // Дальше только данные
      IF (((Row == 1) AND (NOT ExcludeFirstRow) OR (Row > 1)))
         IF (ValType(ActSheet.Cells(Row, 1).Value) != V_DATE)
            PrintLn("Ошибка: В первом столбце должны быть даты!. ["+Row+", 1]" + ActSheet.Cells(Row, 1).Value);
            RETURN;
         END;

         // Дата погашения
         MasGlobGraph(0)[I] = ActSheet.Cells(Row, 1).Value;

         // Есть дата просрочки
         IF (ValType(ActSheet.Cells(Row, 2).Value) == V_DATE)
            MasGlobGraph(1)[I] = ActSheet.Cells(Row, 2).Value;
            IncludeDateExp     = TRUE;
         ELSE
            MasGlobGraph(1)[I] = ActSheet.Cells(Row, 1).Value;
         END;

         // Старт проверки сумм
         IF (IncludeDateExp)
            ColStart = 3;
         ELSE
            ColStart = 2;
         END;

         R = 2;
         FOR (VAR J, ColStart, Col)
            IF (ValType(ActSheet.Cells(Row, J).Value) != V_DOUBLE)
               PrintLn("Ошибка: Сумма задана корректно! ["+Row+","+J+"]."+ActSheet.Cells(Row, J).Value);
               RETURN;
            ELSE
               MasGlobGraph(R)[I] = ActSheet.Cells(Row, J).Value;
               R = R + 1;
            END;
         END;
         I = I + 1;
      END;
   END;

   IF (Row < 1)
      PrintLn("Ошибка: Минимальное число строк равно 1");
      RETURN;
   END;

   // Группа/не группа
   VAR GK = 
   CRsdCommand("SELECT C2.T_ISGROUP, C2.T_NUM, C2.T_NAME FROM DGRAPHKIND_DBT c2 WHERE c2.T_ID = ?",
               "p1", graphtreeparm.graphkind_id_ref,
              V_GENOBJ);
   GK.MoveNext();

   IF (GK.Value("T_ISGROUP", V_STRING) == "X")
      // Группа
      VAR RS_GR = 
      CRsdCommand(
      "SELECT C2.T_NUM, C1.T_ID, C2.T_NAME "
        "FROM DGRAPHTREEPARM_TMP C1 JOIN DGRAPHKIND_DBT C2 ON (C1.T_GRAPHKIND_ID_REF = C2.T_ID) WHERE PRIOR C1.T_ID = ? "+
       "START WITH C1.T_PARENTID = 0 "+
     "CONNECT BY C1.T_PARENTID = PRIOR C1.T_ID ORDER SIBLINGS BY C1.T_ID",
      "p1", graphtreeparm.id,
     V_GENOBJ);

      R = 2;
      WHILE (RS_GR.MoveNext())
         PrintLn("Загрузка графика: " + RS_GR.Value("T_NAME", V_STRING)  + "/" + GK.Value("T_NAME", V_STRING));

         FOR (I, 0, MasGlobGraph(0).Size - 1)
            CRsdCommand(
            "INSERT INTO DPLAN_PAY_TMP "+
            "("+
             "T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, "+
             "T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, " +
             "T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, "      +
             "T_SHARESUM, T_FACT, T_GRAPHPARM_ID"+
            ")"+
            "VALUES"+
            "("+
              "?, ?, 0, ?, ?, ?, 0, 0, ?, 0, CHR(0), ?"+
            ")",
            "p1", ObjN,
            "p2", ObjID,
            "p3", MasGlobGraph(0)[I],
            "p4", MasGlobGraph(1)[I],
            "p5", MasGlobGraph(R)[I],
            "p6", RS_GR.Value("T_NUM", V_INTEGER),
            "p7", RS_GR.Value("T_ID",  V_INTEGER),
           V_GENOBJ);
         END;
         R = R + 1;
      END;
   ELSE
      PrintLn("Загрузка графика: " + GK.Value("T_NAME", V_STRING));

      // Одиночный график
      FOR (I, 0, MasGlobGraph(0).Size - 1)
         CRsdCommand(
         "INSERT INTO DPLAN_PAY_TMP "+
         "("+
          "T_OBJECTID_REF, T_OBJECTTYPEID_REF, T_CREDOPERID_REF, "+
          "T_PLANNEDPAYDATE, T_PLANNEDEXPDATE, T_PLANNEDPAYSUM, " +
          "T_PLANNEDPERCENTSUM, T_PLANNEDPAYSUMEX, T_TYPE, "      +
          "T_SHARESUM, T_FACT, T_GRAPHPARM_ID"+
         ")"+
         "VALUES"+
         "("+
           "?, ?, 0, ?, ?, ?, 0, 0, ?, 0, CHR(0), ?"+
         ")",
         "p1", ObjN,
         "p2", ObjID,
         "p3", MasGlobGraph(0)[I],
         "p4", MasGlobGraph(1)[I],
         "p5", MasGlobGraph(2)[I],
         "p6", GK.Value("T_NUM", V_INTEGER),
         "p7", graphtreeparm.ID,
        V_GENOBJ);
      END;
   END;

   PrintLn("Путь: " + Path + "\\" + FileName);

   ExcelApplication.ActiveWorkbook.Close;

END;