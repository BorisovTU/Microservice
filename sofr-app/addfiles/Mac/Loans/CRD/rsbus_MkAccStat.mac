 /*------------------------------------------------------------------------------
                     Сервис выписки по счету по кредитному договору
 Filename    : rsbus_MkAccStat.mac
 Description : Реализация реализация сервиса выписки по счету по кредитному договору для RS-Bus,
       вызываемого из Фронт-офиса.            

 Programmer  : Melnik Andrey
 21.02.12    : Создан
------------------------------------------------------------------------------*/

import TOTAL, RSBUS_CHECK,"rsbus_checkusr.mac";

//номер сервиса согласно списоку сервисов описананых в rsbus_checkusr.mac
private const NumServ:integer = NumServ_MakeAccountStatement; 

private const DEF_ROW_LIMIT = 1000;


private var credID, usCredNumber, accType, stateType, opBeginDate, opEndDate, opRowLimit;
private var CurCode:integer;
private var AccountNumber:string;

private record credContr(credit_c);
private record sbAccRec(sb_acc);
private record accRec(acc_crd);



class TStatementRow(pCarryDate:date, pInputRest:money, pTurnType:integer,
         pCarrySum:money, pOutRest:money, pTypeOperNumber:integer,
         pTypeOperName:string, pGround:string
         )
var CarryDate:date, InputRest:money, TurnType:integer,
   CarrySum:money, OutRest:money, TypeOperNumber:integer,
   TypeOperName:string, Ground:string;

   CarryDate      = pCarryDate;
   InputRest      = pInputRest;
   TurnType    = pTurnType;
   CarrySum       = pCarrySum;
   OutRest     = pOutRest;
   TypeOperNumber = pTypeOperNumber;
   TypeOperName   = pTypeOperName;
   Ground      = pGround;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class TEmptyAccountStatement 
   var RowCount:integer,
       InputRest:money,
       OutRest:money,
       TypeAccountRest:string;
   macro SetVals(rCount:integer, iRest:money, oRest:money, iTypeAccountRest:string)
      RowCount = rCount;
      InputRest = iRest;
      OutRest = oRest;
      TypeAccountRest = iTypeAccountRest;
   end;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class (TEmptyAccountStatement)TAccountStatement 
   var Documents:TArray = TArray(TStatementRow);
end;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private macro SetVals(creditId:integer,            //Id КД (CreditNumber)
         UsCreditNumber:string,     //Пользовательский номер КД (UsCreditNumber)
         AccountType:integer,       //Номер категории учета для счета (справочник LOANS)
         StatementType:integer,     //Тип выписки. Допустимые значения: 0 - краткая, 1 - полная
         BeginDate:date,         //Дата начала периода формирования выписки.
         EndDate:date,           //Дата окончания периода формирования выписки.
         RowLimit:integer        //Максимально допустимое количесто строк в выписке.
         )
   credID         = creditID;
   usCredNumber   = usCreditNumber;
   accType        = AccountType;
   stateType      = StatementType;
   opBeginDate    = BeginDate;
   opEndDate      = EndDate;
   opRowLimit     = RowLimit;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private macro CheckData()

//существование КД
FindCrd(@credID, usCredNumber, credContr);

//account type
AccountTypeCheck(accType);

   //statement type
   if ( (stateType != 1) AND (stateType != 0) )
      RunError("Неизвестный тип выписки", 18594);
   end;

   //проверка наличия связи между обьектом КД и счетом
   var mydate = date(01,01,2001);
   if ( NOT Loans_FindAcCrd(1, LO_CREDIT, credID, "",accType,
            credContr.CurCode,  "", myDate, accRec))
      RunError("Не найден счет по договору", 18597);
   end;

   curCode = accRec.CurCode; 
   AccountNumber = accRec.AccountNumber_Ref;

   //проверка дат
   if (ValType(opEndDate) == V_UNDEF)
      if ( sbAccRec.AccountState != CF_CLOSE )
         opEndDate = {curdate};
      else

         opEndDate = sbAccRec.CloseDate;
      end;
   end;
   if (ValType(opBeginDate) == V_UNDEF)
      opBeginDate = DateAfterCalenMonths(opEndDate, -1);
   end;
   if (opBeginDate>opEndDate)
      RunError("Дата начала периода не может быть больше даты окончания периода", 18595);
   end;

   //проверка лимита количества строк в отчете
   if (ValType(opRowLimit) == V_UNDEF)
      opRowLimit = DEF_ROW_LIMIT;
   else
      if (opRowLimit <= 0)
         RunError("Недопустимое максимальное количество строк в выписке", 18599);
      end;
   end;

   return true;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private macro FormReport
   var TypeAccountRest: string;
   var inBalance : numeric = 0;
   var retArray = TArray;
   var statementRow:TStatementRow;

   var RSDCmd = RsdCommand(RslDefCon, " SELECT da.T_ACCOUNTTYPE  FROM dsb_acc_dbt da "+
                               "  WHERE     DA.T_OPERDPRT  = ? AND DA.T_CURCODE  = ?  "+
                               "  AND DA.T_ACCOUNTNUMBER = ? ");
       RSDcmd.addParam ("OPERDPRT",     RSDBP_IN);
       RSDcmd.value ("OPERDPRT") = {operdprt};
       RSDcmd.addParam ("CURCODE",    RSDBP_IN);
       RSDcmd.value ("CURCODE") = curCode;
       RSDcmd.addParam ("ACCOUNTNUMBER",    RSDBP_IN);
       RSDcmd.value ("ACCOUNTNUMBER") = AccountNumber;
       var rs = RsdRecordset(RSDcmd);
       RSDcmd.execute;
       if(rs.MoveNext)
          if ( rs.value("T_ACCOUNTTYPE") ==StrFor(1))
             TypeAccountRest="";
          else
             TypeAccountRest = rs.value("T_ACCOUNTTYPE");
             if (TypeAccountRest == "О")
                TypeAccountRest = "АП";
             end;
          end;
       else
          RunError("Не найден счет по договору", 18597);
       end;
   //определение остатка
   var query = "BEGIN ?:=LoansKernel.GetAccRest ( ?,?,?,? ); END;" ;
   var cmd = RSDCommand(RslDefCon, query);
   cmd.addParam( "retval", RSDBP_RETVAL, V_NUMERIC );
   cmd.addParam("accNum",  RSDBP_IN); cmd.Value("accNum") = accRec.AccountNumber_ref;
   cmd.addParam("curcode", RSDBP_IN); cmd.Value("curcode") = accRec.Curcode;
   cmd.addParam("opdate",  RSDBP_IN); cmd.Value("opDate") = opBeginDate-1;
   cmd.addParam("dprt",    RSDBP_IN); cmd.Value("dprt") = credContr.FNCash;
   cmd.Execute;
   inBalance =  cmd.Value("retval");

   query = "SELECT t.t_Debit, t.t_Credit, t.t_carrySum, t.t_carryDate, t.t_operTypeNumber_Ref, d.t_typeOperName, t.t_ground  FROM  ddoc_acc_dbt t, dtype_op_dbt d WHERE (d.t_typeOperNumber = t.t_operTypeNumber_Ref)AND(((t.t_Debit=?)AND(t.t_curCode=?))OR((t.t_Credit=?)AND(t.t_curcodecredit=?)))AND(t.t_carryDate BETWEEN ? AND ?)AND(t.t_isdeleted=0)AND(t.t_state IN (2,3,4)) ORDER BY t.t_carryDate ASC, t.t_docAccID ASC";
   RSDCmd = RSDCommand(RslDefCon, query);
   RSDCmd.AddParam("",null, accRec.AccountNumber_Ref);
   RSDCmd.AddParam("",null, accRec.CurCode);
   RSDCmd.AddParam("",null, accRec.AccountNumber_Ref);
   RSDCmd.AddParam("",null, accRec.CurCode);
   RSDCmd.AddParam("",null, opBeginDate);
   RSDCmd.AddParam("",null, opEndDate);
   RSDCmd.execute;

   rs = RSDRecordSet(RSDCmd);
   if (rs == NULL)
      RunError("При формировании выписки по счету произошла непредвиденная ошибка", 18596);
   end;
   var i=0, CalcSum:money=0;
   var  CurrentSum = 0, IncRest:numeric = inBalance, OutRest:numeric = inBalance, turnType:integer = -1;
   while (rs.MoveNext)
      IncRest = OutRest; // Входящий остаток для следующей записи равен исходящему предыдущей
      CurrentSum = 0;
      if (rs.Fld("t_credit").Value == accRec.AccountNumber_Ref)
         CurrentSum = rs.Fld("t_carrySum").Value;
         turnType=1;
      else
         CurrentSum = -rs.Fld("t_carrySum").Value;
         turnType=0;
      end;
      OutRest = IncRest + CurrentSum; // исходящий остаток равен входящему измененному на сумму оборотов
      if (stateType == 0)
         retArray(i) = TStatementRow(rs.Fld("t_carryDate").Value, IncRest, turnType,
                        rs.Fld("t_carrySum").Value, OutRest, null,
                    null, null);
      else
         retArray(i) = TStatementRow(rs.Fld("t_carryDate").Value, IncRest, turnType,
         rs.Fld("t_carrySum").Value, OutRest, rs.Fld("t_operTypeNumber_Ref").Value,
         rs.Fld("t_typeOperName").Value, rs.Fld("t_ground").Value);
      end;
      i=i+1;
   end;
   var retVal;
   if (retArray.size>0)
      retVal = TAccountStatement;
      if (retArray.size-opRowLimit>0)
         retVal.Documents.size = 0;
         for (i,retArray.size-opRowLimit, retArray.size-1, 1)
            retVal.Documents[retVal.Documents.size] = retArray[i];
         end;
      else
         retVal.Documents = retArray;         
      end;
   else
      retVal = TEmptyAccountStatement;
   end;
   retVal.SetVals(retArray.size, inBalance, OutRest, TypeAccountRest);
   return retVal;
end;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
macro MakeAccountStatement(creditId:integer,          //Id КД (CreditNumber)
               UsCreditNumber:string,     //Пользовательский номер КД (UsCreditNumber)
               AccountType:integer,       //Номер категории учета для счета (справочник LOANS)
               StatementType:integer,     //Тип выписки. Допустимые значения: 0 - краткая, 1 - полная
               BeginDate:date,         //Дата начала периода формирования выписки.
               EndDate:date,           //Дата окончания периода формирования выписки.
               RowLimit:integer        //Максимально допустимое количесто строк в выписке.
              )
   SetVals( creditId, UsCreditNumber, AccountType, StatementType, BeginDate, EndDate, RowLimit);
   if (NOT CheckData)
      return false;
   end;
   
   // Если нужно, то проверим пользовательской функцией
   if(NOT skip_user_chec.MakeAccountStatement)
      if(NOT MakeAccountStatementUserCheck(NumServ,credContr,AccountType,BeginDate,EndDate))
         return 0;
      end;
   end;
   
   return FormReport;
end;

