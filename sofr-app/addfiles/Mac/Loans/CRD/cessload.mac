import GLOBALS,CTInter,SbCrdInter,total;

const INVALID_NODE                = 0;
const CHILD_NODE                  = 1;
const ATTR_NODE                   = 2;
const TEXT_NODE                   = 3;
const CDATA_SECTION_NODE          = 4;
const ENTITY_REFERENCE_NODE       = 5;
const ENTITY_NODE                 = 6;
const PROCESSING_INSTRUCTION_NODE = 7;
const COMMENT_NODE                = 8;
const DOCUMENT_NODE               = 9;
const DOCUMENT_TYPE_NODE          = 10;
const DOCUMENT_FRAGMENT_NODE      = 11;
const NOTATION_NODE               = 12;

var XMLFileName:string;

PRIVATE MACRO InsErrorMessage(message:  string, MOMode: bool)
var mes: string;

  mes = message;

  if(MOMode)
     mes = mes + ": " + GetMO_LoansError();
  end;

  MsgBox(mes + "\n");
END;

// Получить значение тэга
macro ReadTagText(node:object, DataType:integer, retval)
var ret;

  if ((node.text == NULL) or (node.text == "") or (node.text == StrFor(0)) or (node.text == StrFor(1)))
    return false;
  end;

  if(DataType == V_DATE)
     ret = date(node.text);
  elif(DataType == V_INTEGER)
     ret = int(node.text);
  elif(DataType == V_MONEY)
     ret = money(node.text);
  elif(DataType == V_DOUBLE)
     ret = double(node.text);
  elif(DataType == V_STRING)
     ret = node.text;
  end;

  setparm(2, ret);
  return true;

  //LoansError(string(XMLFileName, ": Поле ", node.tagname, " заполнено некорректно"));
  //return false;
end;

// Получить значение атрибута тэга
macro ReadTagAttribut(node:object, name:string, DataType:integer, retval)
var ret;
var i:integer;
var child:object;
   i=0;
   while( i < node.attributes.length )
     child = node.attributes.item(i);
     if( child and (child.nodeType == ATTR_NODE) )
        if ( StrUpr(child.NodeName) == name )
           if(DataType == V_DATE)
              ret = date(child.nodeValue);
           elif(DataType == V_INTEGER)
              ret = int(child.nodeValue);
           elif(DataType == V_MONEY)
              ret = money(child.nodeValue);
           elif(DataType == V_DOUBLE)
              ret = double(child.nodeValue);
           elif(DataType == V_STRING)
              ret = child.nodeValue;
           end;

           setparm(3, ret);
           return true;
        end;
     end;
     i= i + 1;
   end;
//LoansError(string(XMLFileName, ": Поле ", node.tagname, " заполнено некорректно"));

  return false;
end;


class CClient
   var LEGALFORM    :integer;
   var NAME         :string;
   var inn          :string;
   var NAME1        :string;
   var NAME2        :string;
   var NAME3        :string;
   var BORN         :date;
end;

class CPlanPayRec
   var PLANNEDPAYDATE   :date;
   var PLANNEDEXPDATE   :date;
   var PLANNEDPAYSUM    :money;
end;

class CPlanpay
   var TYPE             :integer;
   var PAY_PERIOD       :integer;
   var TYPEPERIOD       :integer;
   var ANNUIT           :integer;
   var POSTEXPDAY       :integer;
   var ARREARDATE       :integer;
   var PAYDAY           :integer;
   var EXPDAY           :integer;
   var PLANFIRSTDATE    :date;
   var PLANLASTDATE     :date;
   var DUTYPAYMENTSUM   :money;
   var PLANCOUNTPAY     :integer;
   var PLANPAYREC       = Tarray; // CPlanPayRec;
end;

class CRateHist
   var RATEDATE     :date;
   var VALUE        :double;
end;

class CRate
   var TYPERATEID   :integer;
   var RATE_HIST    = Tarray; // CRateHist;
end;

class CDutyCrd
   var DutyID       :integer;
   var USERNUMBER    :string;
   var DUTYFIRSTDATE :date;
   var DUTYLASTDATE  :date;
   var DUTYSUM       :money;
   var PAYSUM        :money;
   var MAINREST      :money;
   var EXPREST       :money;
   var CLAIM         :money;
   var EXPPERC       :money;
   var PENALTI_PERC  :money;
   var PENALTI_CRD   :money;
   var ANNUIT        :integer;
   var PLANPAY       = Tarray; // CPlanpay;
   var PLANPAYPerc   = Tarray; // CPlanpay;
   var RATE          = Tarray; // CRate;
end;

class CEnsObj
   var ENSTYPEID        :integer;
   var ENSOBJECTNAME    :string;
   var COUNTUNIT        :integer;
   var TYPECOUNTUNIT    :integer;
   var RATINGSUM        :money;
   var MARKETSUM        :money;
   var REZSUM           :money;
   var ENSOBJECTCUR     :integer;
   var QUALITYID        :integer;
   var FLAG_RVPS        :string;
end;

class CEnsContr
   var ENSCONTRACTNUMBER    :string;
   var ENSCONTRACTFIRSTDATE :date;
   var ENSCONTRACTLASTDATE  :date;
   var ENSSYSTYPE           :integer;
   var ENSCONTRACTSUM       :money;
   var ENSCONTRACTCUR       :integer;
   var ENSCATEGORY          :integer;
   var DISCOUNT             :integer;
   var QUALITYID            :integer;
   var FLAG_RVPS            :string;
   var ENSCONTRACTPERSON    :CClient;
   var ENSOBJ           = Tarray; // CEnsObj;
end;

class CCreditContr
   var USCREDITNUMBER   :string;
   var REGDATE             :date;
   var RETURNDATE       :date;
   var CLIENT           :CClient;
   var CREDITSUM        :money;
   var CURCODE             :integer;
   var PAYSUM           :money;
   var USERTYPE            :string;
   var CREDITTYPEID     :integer;
   var PAYTYPE          :integer;
   var MAINREST         :money;
   var EXPREST          :money;
   var CLAIM            :money;
   var EXPPERC          :money;
   var PENALTI_PERC     :money;
   var PENALTI_CRD      :money;
   var LIMDUTY          :money;
   var LIMPAY           :money;
   var NOTUSLIMDUTY     :money;
   var NOTUSLIMPAY      :money;
   var PRICE            :money;
   var ANNUIT           :integer;
   var PLANPAY          = Tarray; // CPlanpay;
   var PLANPAYPerc      = Tarray; // CPlanpay;
   var RATE             = Tarray; // CRate;
   var DUTYCRD          = Tarray; // CDutyCrd;
   var ENSCONTR         = Tarray; // CEnsContr;
end;

class CTransportFile
   var OperDate         :date;
   var ID_sender        :string;
   var Name_sender      :string;
   var crd_kind         :string;
   var UscreditNumber   :string;
   var date_cess        :date; 
   var CreditContr      :CCreditContr;
end;

VAR CrdData:CCreditContr, opdate:date, IDCess:integer, CESSTYPE:string, TFile:CTransportFile;

macro GetTagClient(node:object, retval:CClient)
var Client: CClient;
   Client.LEGALFORM = 2;
/*
   if((ReadTagAttribut(node, "LEGALFORM", V_INTEGER, Client.LEGALFORM) == false) or
      (ReadTagAttribut(node, "NAME", V_STRING, Client.NAME) == false) or
      (ReadTagAttribut(node, "INN", V_STRING, Client.inn) == false) or
      (ReadTagAttribut(node, "NAME1", V_STRING, Client.NAME1) == false) or
      (ReadTagAttribut(node, "NAME2", V_STRING, Client.NAME2) == false) or
      (ReadTagAttribut(node, "NAME3", V_STRING, Client.NAME3) == false) or
      (ReadTagAttribut(node, "BORN", V_DATE, Client.BORN) == false))

      return false;
   end;
*/
   if (ReadTagAttribut(node, "LEGALFORM", V_INTEGER, Client.LEGALFORM) == false)
    InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле LEGALFORM не заполнено") , false);
      return false;
   end;

   if ((Client.LEGALFORM == 0) or (Client.LEGALFORM > 2))
    InsErrorMessage(string(XMLFileName, ": Поле LEGALFORM заполнено некорректно") , false);
    return false;
   end;

   if (Client.LEGALFORM == 1)
    if (ReadTagAttribut(node, "NAME", V_STRING, Client.NAME) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле NAME не заполнено") , false);
        return false;
    end;
        if (ReadTagAttribut(node, "INN", V_STRING, Client.inn) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле INN не заполнено") , false);
        return false;
    end;
   end;

   if (Client.LEGALFORM == 2)
    if (ReadTagAttribut(node, "NAME1", V_STRING, Client.NAME1) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле NAME1 не заполнено") , false);
        return false;
    end;
        if (ReadTagAttribut(node, "NAME2", V_STRING, Client.NAME2) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле NAME2 не заполнено") , false);
        return false;
    end;
        if (ReadTagAttribut(node, "NAME3", V_STRING, Client.NAME3) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле NAME3 не заполнено") , false);
        return false;
    end;
        if (ReadTagAttribut(node, "BORN", V_DATE, Client.BORN) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле BORN не заполнено") , false);
        return false;
    end;
   end;

   setParm(1, Client);
   return true;
end;

// SEG_PLANPAY
macro GetRecPlanPay(node:object, retval:CPlanPay)
   var BLOCK_PARAM:bool = false, BLOCK_PLANPAY:bool = false;
   var PlanPay: CPlanPay, PlanPayRec:CPlanPayRec;
   var child:object, rec:object, i:integer, j:integer;

   PlanPay.PlanPayRec.size = 0;
   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "BLOCK_PARAM")
            if(BLOCK_PARAM)
               InsErrorMessage(string(XMLFileName, ": Блок SEG_PLANPAY\R\BLOCK_PARAM должен присутствовать в ТФ в единственном экземпляре") , false);
               return false;
            end;
            BLOCK_PARAM = true;
/*
            if((ReadTagAttribut(child, "TYPE", V_INTEGER, PlanPay.TYPE) == false) or
               (ReadTagAttribut(child, "PAY_PERIOD", V_INTEGER, PlanPay.PAY_Period) == false) or
               (ReadTagAttribut(child, "TYPEPERIOD", V_INTEGER, PlanPay.TYPEPERIOD) == false) or
               (ReadTagAttribut(child, "ANNUIT", V_INTEGER, PlanPay.ANNUIT) == false) or
               (ReadTagAttribut(child, "POSTEXPDAY", V_INTEGER, PlanPay.POSTEXPDAY) == false) or
               (ReadTagAttribut(child, "ARREARDATE", V_INTEGER, PlanPay.ARREARDATE) == false) or
               (ReadTagAttribut(child, "PAYDAY", V_INTEGER, PlanPay.PAYDAY) == false) or
               (ReadTagAttribut(child, "EXPDAY", V_INTEGER, PlanPay.EXPDAY) == false) or
               (ReadTagAttribut(child, "PLANFIRSTDATE", V_DATE, PlanPay.PLANFIRSTDATE) == false) or
               (ReadTagAttribut(child, "PLANLASTDATE", V_DATE, PlanPay.PLANLASTDATE) == false) or
               (ReadTagAttribut(child, "DUTYPAYMENTSUM", V_MONEY, PlanPay.DUTYPAYMENTSUM) == false) or
               (ReadTagAttribut(child, "PLANCOUNTPAY", V_INTEGER, PlanPay.PLANCOUNTPAY) == false))
               return false;
            end;
*/
            if (ReadTagAttribut(child, "TYPE", V_INTEGER, PlanPay.TYPE) == false)
               InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле TYPE не заполнено") , false);
           return false;
            end;
            if (ReadTagAttribut(child, "PAY_PERIOD", V_INTEGER, PlanPay.PAY_Period) == false)
               InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле PAY_PERIOD не заполнено") , false);
           return false;
            end;
            if (ReadTagAttribut(child, "TYPEPERIOD", V_INTEGER, PlanPay.TYPEPERIOD) == false)
               InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле TYPEPERIOD не заполнено") , false);
           return false;
            end;
            ReadTagAttribut(child, "ANNUIT", V_INTEGER, PlanPay.ANNUIT);
            ReadTagAttribut(child, "POSTEXPDAY", V_INTEGER, PlanPay.POSTEXPDAY);
            ReadTagAttribut(child, "ARREARDATE", V_INTEGER, PlanPay.ARREARDATE);
            ReadTagAttribut(child, "PAYDAY", V_INTEGER, PlanPay.PAYDAY);
            ReadTagAttribut(child, "EXPDAY", V_INTEGER, PlanPay.EXPDAY);
            ReadTagAttribut(child, "PLANFIRSTDATE", V_DATE, PlanPay.PLANFIRSTDATE);
            ReadTagAttribut(child, "PLANLASTDATE", V_DATE, PlanPay.PLANLASTDATE);
            ReadTagAttribut(child, "DUTYPAYMENTSUM", V_MONEY, PlanPay.DUTYPAYMENTSUM);
            ReadTagAttribut(child, "PLANCOUNTPAY", V_INTEGER, PlanPay.PLANCOUNTPAY);
         end;

         if(child.tagname == "BLOCK_PLANPAY")
            if(BLOCK_PLANPAY)
               InsErrorMessage(string(XMLFileName, ": Блок SEG_PLANPAY\R\BLOCK_PLANPAY должен присутствовать в ТФ в единственном экземпляре") , false);
               return false;
            end;

            j = 0;
            BLOCK_PLANPAY = true;
            while(j<child.childNodes.length)
               rec = child.childNodes.item(j);
               if(rec and (rec.nodeType==CHILD_NODE) )
                  if(rec.tagname == "RECORD")
                     PlanPayRec = CPlanPayRec();
/*
                     if((ReadTagAttribut(rec, "PLANNEDPAYDATE", V_DATE,  PlanPayRec.PLANNEDPAYDATE) == false) or
                        (ReadTagAttribut(rec, "PLANNEDEXPDATE", V_DATE,  PlanPayRec.PLANNEDEXPDATE) == false) or
                        (ReadTagAttribut(rec, "PLANNEDPAYSUM",  V_MONEY, PlanPayRec.PLANNEDPAYSUM) == false))
                        return false;
                     end;
*/
                     ReadTagAttribut(rec, "PLANNEDPAYDATE", V_DATE,  PlanPayRec.PLANNEDPAYDATE);
                     ReadTagAttribut(rec, "PLANNEDEXPDATE", V_DATE,  PlanPayRec.PLANNEDEXPDATE);
                     ReadTagAttribut(rec, "PLANNEDPAYSUM",  V_MONEY, PlanPayRec.PLANNEDPAYSUM);
                     PlanPay.PlanPayRec[PlanPay.PlanPayRec.size] = PlanPayRec;
                  end;
               end;
               j = j + 1;
            end;
         end;
      end;
      i = i + 1;
   end;
   setParm(1, PlanPay);
   return true;
end;


macro GetTagPlanPay(node:object, retval:TArray, retvalperc:TArray)
var Planpay: CPlanpay;
var child:object, i:integer;

   retval.size = 0;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "R")
            Planpay = CPlanpay();
            if(GetRecPlanPay(child, PlanPay) == false)
               return false;
            end;
            if(PlanPay.type == 1) 
               retval[retval.size] = PlanPay;
            else
               retvalperc[retvalperc.size] = PlanPay;
            end;
         end;
      end;
      i = i + 1;
   end;

   if(retval.size != retvalperc.size)
      InsErrorMessage(string(XMLFileName, ": Количество графиков % не соответствует количеству графиков ОД") , false);
      return false;
   end;

   return true;
end;

// SEG_RATE
macro GetRecRate(node:object, retval:CRate)
   var TYPERATEID:bool=false;
   var Rate: CRate, RATE_HIST:CRateHist;
   var child:object, i:integer;

   Rate.RATE_HIST.size = 0;
   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "TYPERATEID")
            if(TYPERATEID)
               InsErrorMessage(string(XMLFileName, ": Блок TYPERATEID должен присутствовать в ТФ в единственном экземпляре") , false);
               return false;
            end;
            TYPERATEID = true;
/*
         if(ReadTagText(child, V_INTEGER, Rate.TYPERATEID) == false)
               return false;
            end;
*/
           ReadTagText(child, V_INTEGER, Rate.TYPERATEID);
         end;

         if(child.tagname == "BLOCK_RATE_HIST")
            RATE_HIST = CRateHist();
/*
            if((ReadTagAttribut(child, "RATEDATE", V_DATE, RATE_HIST.RATEDATE) == false) or
               (ReadTagAttribut(child, "VALUE", V_DOUBLE, RATE_HIST.VALUE) == false))
               return false;
            end;
*/
            ReadTagAttribut(child, "RATEDATE", V_DATE, RATE_HIST.RATEDATE);
            ReadTagAttribut(child, "VALUE", V_DOUBLE, RATE_HIST.VALUE);
            Rate.RATE_HIST[Rate.RATE_HIST.size] = RATE_HIST;
         end;
      end;
      i = i + 1;
   end;
   setParm(1, Rate);
   return true;
end;

macro GetTagRate(node:object, retval:TArray)
   var child:object, i:integer;
   var Rate: CRate;
   retval.size = 0;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "BLOCK_RATE")
             Rate = CRate();
             if(GetRecRate(child, Rate) == false)
               return false;
            end;
            retval[retval.size] = Rate;
         end;
      end;
      i = i + 1;
   end;
   return true;
end;

// SEG_DUTYCRD
macro GetRecDutyCrd(node:object, retval:CDutyCrd)
   var USERNUMBER:bool = false,DUTYFIRSTDATE:bool = false,DUTYLASTDATE:bool = false,DUTYSUM:bool = false,PAYSUM:bool = false,MAINREST:bool = false,
       EXPREST:bool = false,CLAIM:bool = false,EXPPERC:bool = false,PENALTI_PERC:bool = false,PENALTI_CRD:bool = false,ANNUIT:bool = false,
       SEG_PLANPAY:bool = false,SEG_RATE:bool = false;
   var DutyCrd: CDutyCrd;
   var child:object, i:integer;

   DutyCrd.USERNUMBER = "";
   DutyCrd.ANNUIT = 0;
   DutyCrd.MAINREST = DutyCrd.EXPREST = DutyCrd.CLAIM = DutyCrd.EXPPERC = DutyCrd.PENALTI_PERC = DutyCrd.PENALTI_CRD =
   DutyCrd.DUTYSUM = DutyCrd.PAYSUM =  $0;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )

        if(child.tagname == "USERNUMBER")
          if(USERNUMBER)
             InsErrorMessage(string(XMLFileName, ": Блок USERNUMBER должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          USERNUMBER = true;
          if(ReadTagText(child, V_STRING, DutyCrd.USERNUMBER) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле USERNUMBER не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "DUTYFIRSTDATE")
          if(DUTYFIRSTDATE)
             InsErrorMessage(string(XMLFileName, ": Блок DUTYFIRSTDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          DUTYFIRSTDATE = true;
          if(ReadTagText(child, V_DATE, DutyCrd.DUTYFIRSTDATE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле DUTYFIRSTDATE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "DUTYLASTDATE")
          if(DUTYLASTDATE)
             InsErrorMessage(string(XMLFileName, ": Блок DUTYLASTDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          DUTYLASTDATE = true;
          if(ReadTagText(child, V_DATE, DutyCrd.DUTYLASTDATE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле DUTYLASTDATE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "DUTYSUM")
          if(DUTYSUM)
             InsErrorMessage(string(XMLFileName, ": Блок DUTYSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          DUTYSUM = true;
          if(ReadTagText(child, V_MONEY, DutyCrd.DUTYSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле DUTYSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "PAYSUM")
          if(PAYSUM)
             InsErrorMessage(string(XMLFileName, ": Блок PAYSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PAYSUM = true;
          if(ReadTagText(child, V_MONEY, DutyCrd.PAYSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле PAYSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "MAINREST")
          if(MAINREST)
             InsErrorMessage(string(XMLFileName, ": Блок MAINREST должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          MAINREST = true;
/*
          if(ReadTagText(child, V_MONEY, DutyCrd.MAINREST) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, DutyCrd.MAINREST);
        end;

        if(child.tagname == "EXPREST")
          if(EXPREST)
             InsErrorMessage(string(XMLFileName, ": Блок EXPREST должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          EXPREST = true;
/*
          if(ReadTagText(child, V_MONEY, DutyCrd.EXPREST) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, DutyCrd.EXPREST);
        end;

        if(child.tagname == "CLAIM")
          if(CLAIM)
             InsErrorMessage(string(XMLFileName, ": Блок CLAIM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          CLAIM = true;
/*
          if(ReadTagText(child, V_MONEY, DutyCrd.CLAIM) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, DutyCrd.CLAIM);
        end;

        if(child.tagname == "EXPPERC")
          if(EXPPERC)
             InsErrorMessage(string(XMLFileName, ": Блок EXPPERC должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          EXPPERC = true;
/*
          if(ReadTagText(child, V_MONEY, DutyCrd.EXPPERC) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, DutyCrd.EXPPERC);
        end;

        if(child.tagname == "PENALTI_PERC")
          if(PENALTI_PERC)
             InsErrorMessage(string(XMLFileName, ": Блок PENALTI_PERC должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PENALTI_PERC = true;
/*
          if(ReadTagText(child, V_MONEY, DutyCrd.PENALTI_PERC) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, DutyCrd.PENALTI_PERC);
        end;

        if(child.tagname == "PENALTI_CRD")
          if(PENALTI_CRD)
             InsErrorMessage(string(XMLFileName, ": Блок PENALTI_CRD должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PENALTI_CRD = true;
/*
          if(ReadTagText(child, V_MONEY, DutyCrd.PENALTI_CRD) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, DutyCrd.PENALTI_CRD);
        end;

        if(child.tagname == "ANNUIT")
          if(ANNUIT)
             InsErrorMessage(string(XMLFileName, ": Блок ANNUIT должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ANNUIT = true;
/*
          if(ReadTagText(child, V_INTEGER, DutyCrd.ANNUIT) == false)
             return false;
          end;
*/
          ReadTagText(child, V_INTEGER, DutyCrd.ANNUIT);
        end;


        if(child.tagname == "SEG_PLANPAY")
          if(SEG_PLANPAY)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_PLANPAY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_PLANPAY = true;

           if(GetTagPlanPay(child, DutyCrd.PLANPAY, DutyCrd.PLANPAYPerc) == false)
              return false;
           end;
        end;

        if(child.tagname == "SEG_RATE")
          if(SEG_RATE)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_RATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_RATE = true;

           if(GetTagRate(child, DutyCrd.RATE) == false)
              return false;
           end;
        end;

      end;
      i = i + 1;
   end;
   setParm(1, DutyCrd);
   return true;
end;


macro GetTagDutyCrd(node:object, retval:TArray)
var DutyCrd: CDutyCrd;
var child:object, i:integer;

   retval.size = 0;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "R")
            DutyCrd = CDutyCrd();
            if(GetRecDutyCrd(child, DutyCrd) == false)
               return false;
            end;
            retval[retval.size] = DutyCrd;
         end;
      end;
      i = i + 1;
   end;
   return true;
end;


// SEG_ENSOBJ
macro GetRecEnsObj(node:object, retval:CEnsObj)
   var ENSTYPEID:bool = false,COUNTUNIT:bool = false,TYPECOUNTUNIT:bool = false,RATINGSUM:bool = false,MARKETSUM:bool = false,REZSUM:bool = false,
       ENSOBJECTCUR:bool = false,QUALITYID:bool = false,FLAG_RVPS:bool = false,ENSOBJECTNAME:bool = false;
   var EnsObj: CEnsObj;
   var child:object, i:integer;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
        if(child.tagname == "ENSTYPEID")
          if(ENSTYPEID)
             InsErrorMessage(string(XMLFileName, ": Блок ENSTYPEID должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSTYPEID = true;
          if(ReadTagText(child, V_INTEGER, EnsObj.ENSTYPEID) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSTYPEID не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSOBJECTNAME")
          if(ENSOBJECTNAME)
             InsErrorMessage(string(XMLFileName, ": Блок ENSOBJECTNAME должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSOBJECTNAME = true;
          if(ReadTagText(child, V_STRING, EnsObj.ENSOBJECTNAME) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSOBJECTNAME не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "COUNTUNIT")
          if(COUNTUNIT)
             InsErrorMessage(string(XMLFileName, ": Блок COUNTUNIT должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          COUNTUNIT = true;
          if(ReadTagText(child, V_INTEGER, EnsObj.COUNTUNIT) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле COUNTUNIT не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "TYPECOUNTUNIT")
          if(TYPECOUNTUNIT)
             InsErrorMessage(string(XMLFileName, ": Блок TYPECOUNTUNIT должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          TYPECOUNTUNIT = true;
          if(ReadTagText(child, V_INTEGER, EnsObj.TYPECOUNTUNIT) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле TYPECOUNTUNIT не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "RATINGSUM")
          if(RATINGSUM)
             InsErrorMessage(string(XMLFileName, ": Блок RATINGSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          RATINGSUM = true;
          if(ReadTagText(child, V_MONEY, EnsObj.RATINGSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле RATINGSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "MARKETSUM")
          if(MARKETSUM)
             InsErrorMessage(string(XMLFileName, ": Блок MARKETSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          MARKETSUM = true;
          if(ReadTagText(child, V_MONEY, EnsObj.MARKETSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле MARKETSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "REZSUM")
          if(REZSUM)
             InsErrorMessage(string(XMLFileName, ": Блок REZSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          REZSUM = true;
          if(ReadTagText(child, V_MONEY, EnsObj.REZSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле REZSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSOBJECTCUR")
          if(ENSOBJECTCUR)
             InsErrorMessage(string(XMLFileName, ": Блок ENSOBJECTCUR должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSOBJECTCUR = true;
          if(ReadTagText(child, V_INTEGER, EnsObj.ENSOBJECTCUR) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSOBJECTCUR не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "QUALITYID")
          if(QUALITYID)
             InsErrorMessage(string(XMLFileName, ": Блок QUALITYID должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          QUALITYID = true;
          if(ReadTagText(child, V_INTEGER, EnsObj.QUALITYID) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле QUALITYID не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "FLAG_RVPS")
          if(FLAG_RVPS)
             InsErrorMessage(string(XMLFileName, ": Блок FLAG_RVPS должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          FLAG_RVPS = true;
/*
          if(ReadTagText(child, V_STRING, EnsObj.FLAG_RVPS) == false)
             return false;
          end;
*/
          ReadTagText(child, V_STRING, EnsObj.FLAG_RVPS)
        end;
      end;
      i = i + 1;
   end;
   setParm(1, EnsObj);
   return true;
end;


macro GetTagEnsObj(node:object, retval:TArray)
var EnsObj: CEnsObj;
var child:object, i:integer;

   retval.size = 0;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "R")
            EnsObj = CEnsObj();
            if(GetRecEnsObj(child, EnsObj) == false)
               return false;
            end;
            retval[retval.size] = EnsObj;
         end;
      end;
      i = i + 1;
   end;
   return true;
end;


// SEG_ENSCONTR
macro GetRecEnsContr(node:object, retval:CEnsContr)
   var ENSCONTRACTNUMBER:bool = false,ENSCONTRACTFIRSTDATE:bool = false,ENSCONTRACTLASTDATE:bool = false,ENSSYSTYPE:bool = false,ENSCONTRACTSUM:bool = false,
    ENSCONTRACTCUR:bool = false,ENSCATEGORY:bool = false,DISCOUNT:bool = false,QUALITYID:bool = false,FLAG_RVPS:bool = false,ENSCONTRACTPERSON:bool = false,
       SEG_ENSOBJ:bool = false;
   var EnsContr: CEnsContr;
   var child:object, i:integer;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )

        if(child.tagname == "ENSCONTRACTNUMBER")
          if(ENSCONTRACTNUMBER)
             InsErrorMessage(string(XMLFileName, ": Блок ENSCONTRACTNUMBER должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSCONTRACTNUMBER = true;
          if(ReadTagText(child, V_STRING, EnsContr.ENSCONTRACTNUMBER) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSCONTRACTNUMBER не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSCONTRACTFIRSTDATE")
          if(ENSCONTRACTFIRSTDATE)
             InsErrorMessage(string(XMLFileName, ": Блок ENSCONTRACTFIRSTDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSCONTRACTFIRSTDATE = true;
          if(ReadTagText(child, V_DATE, EnsContr.ENSCONTRACTFIRSTDATE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSCONTRACTFIRSTDATE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSCONTRACTLASTDATE")
          if(ENSCONTRACTLASTDATE)
             InsErrorMessage(string(XMLFileName, ": Блок ENSCONTRACTLASTDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSCONTRACTLASTDATE = true;
          if(ReadTagText(child, V_DATE, EnsContr.ENSCONTRACTLASTDATE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSCONTRACTLASTDATE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSSYSTYPE")
          if(ENSSYSTYPE)
             InsErrorMessage(string(XMLFileName, ": Блок ENSSYSTYPE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSSYSTYPE = true;
          if(ReadTagText(child, V_INTEGER, EnsContr.ENSSYSTYPE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSSYSTYPE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSCONTRACTSUM")
          if(ENSCONTRACTSUM)
             InsErrorMessage(string(XMLFileName, ": Блок ENSCONTRACTSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSCONTRACTSUM = true;
          if(ReadTagText(child, V_MONEY, EnsContr.ENSCONTRACTSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSCONTRACTSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSCONTRACTCUR")
          if(ENSCONTRACTCUR)
             InsErrorMessage(string(XMLFileName, ": Блок ENSCONTRACTCUR должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSCONTRACTCUR = true;
          if(ReadTagText(child, V_INTEGER, EnsContr.ENSCONTRACTCUR) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSCONTRACTCUR не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "ENSCATEGORY")
          if(ENSCATEGORY)
             InsErrorMessage(string(XMLFileName, ": Блок ENSCATEGORY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ENSCATEGORY = true;
/*
          if(ReadTagText(child, V_INTEGER, EnsContr.ENSCATEGORY) == false)
             return false;
          end;
*/
          ReadTagText(child, V_INTEGER, EnsContr.ENSCATEGORY);
        end;

        if(child.tagname == "DISCOUNT")
          if(DISCOUNT)
             InsErrorMessage(string(XMLFileName, ": Блок DISCOUNT должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          DISCOUNT = true;
/*
          if(ReadTagText(child, V_INTEGER, EnsContr.DISCOUNT) == false)
             return false;
          end;
*/
          ReadTagText(child, V_INTEGER, EnsContr.DISCOUNT);
        end;

        if(child.tagname == "QUALITYID")
          if(QUALITYID)
             InsErrorMessage(string(XMLFileName, ": Блок QUALITYID должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          QUALITYID = true;
          if(ReadTagText(child, V_INTEGER, EnsContr.QUALITYID) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле QUALITYID не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "FLAG_RVPS")
          if(FLAG_RVPS)
             InsErrorMessage(string(XMLFileName, ": Блок FLAG_RVPS должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          FLAG_RVPS = true;
/*
          if(ReadTagText(child, V_STRING, EnsContr.FLAG_RVPS) == false)
             return false;
          end;
*/
          ReadTagText(child, V_STRING, EnsContr.FLAG_RVPS);
        end;

        if(child.tagname == "ENSCONTRACTPERSON")
           if(ENSCONTRACTPERSON)
              InsErrorMessage(string(XMLFileName, ": Блок ENSCONTRACTPERSON должен присутствовать в ТФ в единственном экземпляре") , false);
              return false;
           end;
           ENSCONTRACTPERSON = true;
           if(GetTagClient(child, EnsContr.ENSCONTRACTPERSON) == false)
              InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ENSCONTRACTPERSON не заполнено") , false);
              return false;
           end;
        end;

        if(child.tagname == "SEG_ENSOBJ")
          if(SEG_ENSOBJ)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_ENSOBJ должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_ENSOBJ = true;
/*
           if(GetTagEnsObj(child, EnsContr.ENSOBJ) == false)
              return false;
           end;
*/
          GetTagEnsObj(child, EnsContr.ENSOBJ);
        end;

      end;
      i = i + 1;
   end;
   setParm(1, EnsContr);
   return true;
end;


macro GetTagEnsContr(node:object, retval:TArray)
var EnsContr: CEnsContr;
var child:object, i:integer;

   retval.size = 0;

   i = 0;
   while( i < node.childNodes.length )
      child = node.childNodes.item(i);
      if( child and (child.nodeType==CHILD_NODE) )
         if(child.tagname == "R")
            EnsContr = CEnsContr();
            if(GetRecEnsContr(child, EnsContr) == false)
               return false;
            end;
            retval[retval.size] = EnsContr;
         end;
      end;
      i = i + 1;
   end;
   return true;
end;


macro GetTagCredit(node:object, CreditContr:CCreditContr)
var USCREDITNUMBER:bool = false,REGDATE:bool = false,RETURNDATE:bool = false,SEG_CLIENT:bool = false,CREDITSUM:bool = false,CURCODE:bool = false,PAYSUM:bool = false,
    USERTYPE:bool = false,CREDITTYPEID:bool = false,PAYTYPE:bool = false,MAINREST:bool = false,EXPREST:bool = false,CLAIM:bool = false,EXPPERC:bool = false,
    PENALTI_PERC:bool = false,PENALTI_CRD:bool = false,LIMDUTY:bool = false,LIMPAY:bool = false,NOTUSLIMDUTY:bool = false,NOTUSLIMPAY:bool = false,
    PRICE:bool = false,ANNUIT:bool = false,SEG_PLANPAY:bool = false,SEG_RATE:bool = false,SEG_DUTYCRD:bool = false,SEG_ENSCONTR:bool = false;
var child:object, i:integer;

  CreditContr.USCREDITNUMBER = "";
  CreditContr.PAYTYPE = 0;
  CreditContr.CREDITSUM = CreditContr.MAINREST = CreditContr.EXPREST = CreditContr.CLAIM = CreditContr.EXPPERC = CreditContr.PENALTI_PERC = CreditContr.PENALTI_CRD =
  CreditContr.PAYSUM = CreditContr.LIMPAY = CreditContr.NOTUSLIMPAY = CreditContr.LIMDUTY = CreditContr.NOTUSLIMDUTY = CreditContr.PAYSUM = CreditContr.PRICE = $0;
  CreditContr.ANNUIT = 0;

  CreditContr.PLANPAY.size = 0;
  CreditContr.RATE.size = 0;
  CreditContr.DUTYCRD.size = 0;
  CreditContr.ENSCONTR.size = 0;

  i = 0;
  while( i < node.childNodes.length )
     child = node.childNodes.item(i);
     if( child and (child.nodeType==CHILD_NODE) )
        if(child.tagname == "USCREDITNUMBER")
          if(USCREDITNUMBER)
             InsErrorMessage(string(XMLFileName, ": Блок USCREDITNUMBER должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          USCREDITNUMBER = true;
          if(ReadTagText(child, V_STRING, CreditContr.USCREDITNUMBER) == false)
         InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле USCREDITNUMBER не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "REGDATE")
          if(REGDATE)
             InsErrorMessage(string(XMLFileName, ": Блок REGDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          REGDATE = true;
          if(ReadTagText(child, V_DATE, CreditContr.REGDATE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле REGDATE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "RETURNDATE")
          if(RETURNDATE)
             InsErrorMessage(string(XMLFileName, ": Блок RETURNDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          RETURNDATE = true;
          if(ReadTagText(child, V_DATE, CreditContr.RETURNDATE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле RETURNDATE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "SEG_CLIENT")
           if(SEG_CLIENT)
              InsErrorMessage(string(XMLFileName, ": Блок SEG_CLIENT должен присутствовать в ТФ в единственном экземпляре") , false);
              return false;
           end;
           SEG_CLIENT = true;
           if(GetTagClient(child, CreditContr.CLIENT) == false)
              return false;
           end;
        end;
 
        if(child.tagname == "CREDITSUM")
          if(CREDITSUM)
             InsErrorMessage(string(XMLFileName, ": Блок CREDITSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          CREDITSUM = true;
          if(ReadTagText(child, V_MONEY, CreditContr.CREDITSUM) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле CREDITSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "CURCODE")
          if(CURCODE)
             InsErrorMessage(string(XMLFileName, ": Блок CURCODE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          CURCODE = true;
          if(ReadTagText(child, V_INTEGER, CreditContr.CURCODE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле CURCODE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "PAYTYPE")
          if(PAYTYPE)
             InsErrorMessage(string(XMLFileName, ": Блок PAYTYPE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PAYTYPE = true;
          if(ReadTagText(child, V_INTEGER, CreditContr.PAYTYPE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле PAYTYPE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "PAYSUM")
          if(PAYSUM)
             InsErrorMessage(string(XMLFileName, ": Блок PAYSUM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PAYSUM = true;
          if((ReadTagText(child, V_MONEY, CreditContr.PAYSUM) == false) and (CreditContr.PAYTYPE >= 3) and (CreditContr.PAYTYPE <= 5))
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле PAYSUM не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "USERTYPE")
          if(USERTYPE)
             InsErrorMessage(string(XMLFileName, ": Блок USERTYPE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          USERTYPE = true;
          if(ReadTagText(child, V_STRING, CreditContr.USERTYPE) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле USERTYPE не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "CREDITTYPEID")
          if(CREDITTYPEID)
             InsErrorMessage(string(XMLFileName, ": Блок CREDITTYPEID должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          CREDITTYPEID = true;
          if(ReadTagText(child, V_INTEGER, CreditContr.CREDITTYPEID) == false)
             InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле CREDITTYPEID не заполнено") , false);
             return false;
          end;
        end;

        if(child.tagname == "MAINREST")
          if(MAINREST)
             InsErrorMessage(string(XMLFileName, ": Блок MAINREST должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          MAINREST = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.MAINREST) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.MAINREST);
        end;

        if(child.tagname == "EXPREST")
          if(EXPREST)
             InsErrorMessage(string(XMLFileName, ": Блок EXPREST должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          EXPREST = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.EXPREST) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.EXPREST);
        end;

        if(child.tagname == "CLAIM")
          if(CLAIM)
             InsErrorMessage(string(XMLFileName, ": Блок CLAIM должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          CLAIM = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.CLAIM) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.CLAIM);
        end;

        if(child.tagname == "EXPPERC")
          if(EXPPERC)
             InsErrorMessage(string(XMLFileName, ": Блок EXPPERC должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          EXPPERC = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.EXPPERC) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.EXPPERC);
        end;

        if(child.tagname == "PENALTI_PERC")
          if(PENALTI_PERC)
             InsErrorMessage(string(XMLFileName, ": Блок PENALTI_PERC должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PENALTI_PERC = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.PENALTI_PERC) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.PENALTI_PERC);
        end;

        if(child.tagname == "PENALTI_CRD")
          if(PENALTI_CRD)
             InsErrorMessage(string(XMLFileName, ": Блок PENALTI_CRD должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PENALTI_CRD = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.PENALTI_CRD) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.PENALTI_CRD);
        end;

        if(child.tagname == "LIMDUTY")
          if(LIMDUTY)
             InsErrorMessage(string(XMLFileName, ": Блок LIMDUTY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          LIMDUTY = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.LIMDUTY) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.LIMDUTY);
        end;

        if(child.tagname == "LIMPAY")
          if(LIMPAY)
             InsErrorMessage(string(XMLFileName, ": Блок LIMPAY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          LIMPAY = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.LIMPAY) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.LIMPAY);
        end;

        if(child.tagname == "NOTUSLIMDUTY")
          if(NOTUSLIMDUTY)
             InsErrorMessage(string(XMLFileName, ": Блок NOTUSLIMDUTY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          NOTUSLIMDUTY = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.NOTUSLIMDUTY) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.NOTUSLIMDUTY);
        end;

        if(child.tagname == "NOTUSLIMPAY")
          if(NOTUSLIMPAY)
             InsErrorMessage(string(XMLFileName, ": Блок NOTUSLIMPAY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          NOTUSLIMPAY = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.NOTUSLIMPAY) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.NOTUSLIMPAY);
        end;

        if(child.tagname == "PRICE")
          if(PRICE)
             InsErrorMessage(string(XMLFileName, ": Блок PRICE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          PRICE = true;
/*
          if(ReadTagText(child, V_MONEY, CreditContr.PRICE) == false)
             return false;
          end;
*/
          ReadTagText(child, V_MONEY, CreditContr.PRICE);
        end;

        if(child.tagname == "ANNUIT")
          if(ANNUIT)
             InsErrorMessage(string(XMLFileName, ": Блок ANNUIT должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          ANNUIT = true;
/*
          if(ReadTagText(child, V_INTEGER, CreditContr.ANNUIT) == false)
             return false;
          end;
*/
          ReadTagText(child, V_INTEGER, CreditContr.ANNUIT);
        end;


        if(child.tagname == "SEG_PLANPAY")
          if(SEG_PLANPAY)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_PLANPAY должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_PLANPAY = true;

           if(GetTagPlanPay(child, CreditContr.PLANPAY, CreditContr.PLANPAYPerc) == false)
              return false;
           end;
         end;

        if(child.tagname == "SEG_RATE")
          if(SEG_RATE)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_RATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_RATE = true;

           if(GetTagRate(child, CreditContr.RATE) == false)
              return false;
           end;
        end;

        if(child.tagname == "SEG_DUTYCRD")
          if(SEG_DUTYCRD)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_DUTYCRD должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_DUTYCRD = true;

           if(GetTagDutyCrd(child, CreditContr.DUTYCRD) == false)
              return false;
           end;
        end;

        if(child.tagname == "SEG_ENSCONTR")
          if(SEG_ENSCONTR)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_ENSCONTR должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          SEG_ENSCONTR = true;

           if(GetTagEnsContr(child, CreditContr.ENSCONTR) == false)
              return false;
           end;
        end;
     end;
     i = i + 1;
  end;

  if((PRICE == false) or (CreditContr.PRICE == $0)) 
     InsErrorMessage(string(XMLFileName, ": Не указана цена приобретения кредитного договора") , false);
     return false;
  end;

  return true;
end;

macro FindPartiID(client:CClient, ErrMsg:string)
var partyID:integer = 0;
   if(client.LEGALFORM == 1)
      if(client.inn == "")
         InsErrorMessage(string(XMLFileName, ": Не указан ИНН заемщика") , false);
      end;

      partyID = LnSelectValue (
         "select p.t_partyid from dparty_dbt p, dpartcode_dbt c " +
           "where p.t_partyid = c.t_PartyID and " +
                 "c.t_CodeKind  = 16 and " +
                 "c.t_Code =  '" + client.inn + "' and " +
                 "p.t_LEGALFORM = " + client.LEGALFORM + " and " +
                 "p.t_NAME = '" + client.NAME + "'",
         V_INTEGER);
   else
      partyID = LnSelectValue (
         "select p.t_partyid from dparty_dbt p, dpersn_dbt s " +
           "where p.t_partyid = s.t_Personid and "
                 "p.t_LEGALFORM = " + client.LEGALFORM + " and " +
                 "s.t_NAME1 = '" + client.NAME1 + "' AND "
                 "s.t_NAME2 = '" + client.NAME2 + "' AND "
                 "s.t_NAME3 = '" + client.NAME3 + "' AND "
                 "s.t_born  = " + SQLDate(client.born),
         V_INTEGER);
   end;

   if(partyID == 0)
      InsErrorMessage(string(XMLFileName, ": " + ErrMsg) , false);
   end;

   return partyID;
end;

MACRO FindFIID(FI_Code)
VAR fininstr = TBFile ("fininstr.dbt", "R", 1, "fininstr.dbt", "bank.def");
   fininstr.rec.FI_Code = FI_Code;
   IF (fininstr.getEQ())
      RETURN fininstr.rec.FIID;
   END;

   RETURN -1;
END;

macro InsertPlanPay(PlanPayOD:TArray, PlanPayPerc:TArray, objid:integer, objn:integer, opdate:date, curcode:integer)
var i:integer, j:integer, opid:integer;
record LGPAYOP ("LGPAYOP.DBT", "loans.def");
file PLANPAY ("actual_planpay.dbt", "loans.def") write;

   j = 0;
   while(j < PlanPayOD.size)
      LGPAYOP.CREDOPERID_REF     = 0;
      LGPAYOP.SUM                = PlanPayOD[j].DUTYPAYMENTSUM;
      LGPAYOP.SUMEX              = $0;
      LGPAYOP.TYPE               = 0;
      LGPAYOP.CASHINADVANCE      = "";
      LGPAYOP.ISPRIVELEGE        = "";
      LGPAYOP.PAY_PLANFIRSTDATE  = PlanPayOD[j].PLANFIRSTDATE;
      LGPAYOP.PAY_PLANLASTDATE   = PlanPayOD[j].PLANLASTDATE;
      LGPAYOP.PAY_DUTYPAYMENTSUM = Money(Round((PlanPayOD[j].DUTYPAYMENTSUM / PlanPayOD[j].PLANCOUNTPAY), 2));
      LGPAYOP.PAY_PLANCOUNTPAY   = PlanPayOD[j].PLANCOUNTPAY;
      LGPAYOP.PAY_TYPEPERIOD     = PlanPayOD[j].TYPEPERIOD;
      LGPAYOP.PAY_PERIOD         = PlanPayOD[j].PAY_PERIOD;
      LGPAYOP.PAY_ARREARDATE     = PlanPayOD[j].ARREARDATE;
      LGPAYOP.PAY_EXPDAY         = PlanPayOD[j].EXPDAY;
      LGPAYOP.PAY_POSTEXPDAY     = PlanPayOD[j].POSTEXPDAY;
      LGPAYOP.PAY_PAYDAY         = PlanPayOD[j].PAYDAY;
      LGPAYOP.PERC_PLANFIRSTDATE = PlanPayPerc[j].PLANFIRSTDATE;
      LGPAYOP.PERC_PLANLASTDATE  = PlanPayPerc[j].PLANLASTDATE;
      if (not PlanPayPerc[j].PLANCOUNTPAY)
         LGPAYOP.PERC_PLANCOUNTPAY = 0;
      else
         LGPAYOP.PERC_PLANCOUNTPAY  = PlanPayPerc[j].PLANCOUNTPAY;
      end;
      LGPAYOP.PERC_TYPEPERIOD    = PlanPayPerc[j].TYPEPERIOD;
      LGPAYOP.PERC_PERIOD        = PlanPayPerc[j].PAY_PERIOD;
      LGPAYOP.PERC_ARREARDATE    = PlanPayPerc[j].ARREARDATE;
      LGPAYOP.PERC_EXPDAY        = PlanPayPerc[j].ARREARDATE;
      LGPAYOP.PERC_POSTEXPDAY    = PlanPayPerc[j].POSTEXPDAY;
      LGPAYOP.EXP_PAYDAY         = PlanPayPerc[j].PAYDAY;

      opid = MakeOperation(objn, objid, CF_RECALCGPAY, 0, opdate, LGPAYOP, GPAY_PERC, 2);

      i = 0;
      while(i < PlanPayOD[j].PLANPAYREC.size)
         clearrecord(PLANPAY);
      PLANPAY.OBJECTID_REF     = objn;
         PLANPAY.OBJECTTYPEID_REF = objid;
      PLANPAY.CREDOPERID_REF   = opid;
      PLANPAY.PLANNEDPAYSUMEX  = 0;
      PLANPAY.TYPE             = 0;
         PLANPAY.PLANNEDPAYDATE   = PlanPayOD[j].PLANPAYREC[i].PLANNEDPAYDATE;
         PLANPAY.PLANNEDEXPDATE   = PlanPayOD[j].PLANPAYREC[i].PLANNEDEXPDATE;

         IF (GetEQ(PLANPAY))
            PLANPAY.PLANNEDPAYSUM = PlanPayOD[j].PLANPAYREC[i].PLANNEDPAYSUM;
            IF(NOT Update(PLANPAY))
               InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения"), false);
               return false;
            END;
         ELSE
            PLANPAY.PLANNEDPAYSUM = PlanPayOD[j].PLANPAYREC[i].PLANNEDPAYSUM;
            IF (NOT Insert(PLANPAY))
               InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения"), false);
               return false;
            END;
         END;

         i = i + 1;
      end;

      i = 0;
      while(i < PlanPayPerc[j].PLANPAYREC.size)
         clearrecord(PLANPAY);
      PLANPAY.OBJECTID_REF     = objn;
         PLANPAY.OBJECTTYPEID_REF = objid;
      PLANPAY.CREDOPERID_REF   = opid;
      PLANPAY.TYPE             = 0;
         PLANPAY.PLANNEDPAYDATE   = PlanPayPerc[j].PLANPAYREC[i].PLANNEDPAYDATE;
         PLANPAY.PLANNEDEXPDATE   = PlanPayPerc[j].PLANPAYREC[i].PLANNEDEXPDATE;

         IF (GetEQ(PLANPAY))
         PLANPAY.PLANNEDPAYSUMEX  = 0;
            PLANPAY.PLANNEDPERCENTSUM = PlanPayPerc[j].PLANPAYREC[i].PLANNEDPAYSUM;
            IF(NOT Update(PLANPAY))
               InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения"), false);
               return false;
            END;
         ELSE
            PLANPAY.PLANNEDPAYSUMEX  = 0;
            PLANPAY.PLANNEDPERCENTSUM = PlanPayPerc[j].PLANPAYREC[i].PLANNEDPAYSUM;
            IF (NOT Insert(PLANPAY))
               InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения"), false);
               return false;
            END;
         END;

         i = i + 1;
      end;


      if(opid == 0)
         InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения") , true);
         return false;
      else
          LnSqlExec("UPDATE dlgpayop_dbt set T_SUM = " + PlanPayOD[j].DUTYPAYMENTSUM +
                      " WHERE T_CREDOPERID_REF =" + opid +
                      " AND T_TYPE = 0");

          // для того, чтобы увидеть графики
          i = 0;
          while(i < PlanPayOD[j].PLANPAYREC.size)
             clearrecord(PLANPAY);
             PLANPAY.OBJECTID_REF     = objn;
             PLANPAY.OBJECTTYPEID_REF = objid;
             PLANPAY.CREDOPERID_REF   = 0;
             PLANPAY.TYPE             = 0;
             PLANPAY.PLANNEDPAYDATE   = PlanPayOD[j].PLANPAYREC[i].PLANNEDPAYDATE;
             PLANPAY.PLANNEDEXPDATE   = PlanPayOD[j].PLANPAYREC[i].PLANNEDEXPDATE;

             IF (GetEQ(PLANPAY))
                PLANPAY.CREDOPERID_REF = opid;
                IF(NOT Update(PLANPAY))
                   InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения"), false);
                   return false;
                END;
             END;
    
             i = i + 1;
          end;
    
          i = 0;
          while(i < PlanPayPerc[j].PLANPAYREC.size)
             clearrecord(PLANPAY);
             PLANPAY.OBJECTID_REF     = objn;
             PLANPAY.OBJECTTYPEID_REF = objid;
             PLANPAY.CREDOPERID_REF   = 0;
             PLANPAY.TYPE             = 0;
             PLANPAY.PLANNEDPAYDATE   = PlanPayPerc[j].PLANPAYREC[i].PLANNEDPAYDATE;
             PLANPAY.PLANNEDEXPDATE   = PlanPayPerc[j].PLANPAYREC[i].PLANNEDEXPDATE;

             IF (GetEQ(PLANPAY))
                PLANPAY.CREDOPERID_REF = opid;
                IF(NOT Update(PLANPAY))
                   InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию перерасчета графика погашения"), false);
                   return false;
                END;
             END;
    
             i = i + 1;
          end;
      end;

      j = j + 1;
   end;
   return true;
end;

macro InsertRateHistory(ObjID:integer, ObjN:integer, CurCode:integer, OpDate:date, Rate:CRate)
VAR RateCredit = TArray(0), i:integer, stat:integer = 0;
   i = 0;
   while(i < Rate.RATE_HIST.size)
      RateCredit(RateCredit.Size) = Rate.TYPERATEID;
      RateCredit(RateCredit.Size) = Rate.RATE_HIST[i].RATEDATE;
      RateCredit(RateCredit.Size) = 0;
      RateCredit(RateCredit.Size) = 0;
      RateCredit(RateCredit.Size) = 0;
      RateCredit(RateCredit.Size) = "";
      RateCredit(RateCredit.Size) = string(Rate.RATE_HIST[i].VALUE);
            i = i + 1;
   end;

   stat = MakeOperation(objn, objid, CF_RATE, 0, OpDate,RateCredit);

   if ((stat == 0)and(GetMO_ErrorID != 0))
      InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию изменения процентной ставки"), true);
      return false;
   end;

   return true
end;

macro InsertPercDay(ObjID:integer, ObjN:integer, RegID:integer, RateType:integer, OpDate:date, MainRest:money, Claim:money)
file   percday  ("perc_day.dbt", "loans.def") write;
record rlcusrate("lcusrate.dbt", "loans.def");
record rlcusreg ("lcusreg.dbt",  "loans.def");

   IF(Loans_FindLCURG(ObjID, ObjN, RateType, 0, rlcusreg))
      percday.id_ref      = rlcusreg.ID;//rlcusreg.RegID;
   else
      return false;
   END;

   IF(Loans_FindLCUR(ObjID, ObjN, RateType, 0, rlcusrate))
      percday.rateid      = rlcusrate.RateID_Ref;
   else 
      return false;
   END;

   percday.percdate       = OpDate;
   percday.credopid_ref = 0;
   percday.rest           = MainRest;
   percday.percsum        = Claim;
   percday.firstid_ref    = percday.id_ref;

   if (ObjID != LO_DUTY)
      percday.firstrateid    = percday.rateid;
   else
      percday.firstrateid = CRsdCommand ("SELECT usr.t_RateID_Ref FROM DLCUSRATE_DBT usr, DDUTY_CRD_DBT dcr " +
                            "WHERE usr.t_ObjectID_Ref = ?" + 
            " AND usr.t_CredObjID_Ref = dcr.t_FirstDutyID_Ref" + 
            " AND usr.t_TypeRateID_Ref = ?" +
            " AND dcr.t_DutyID = ?",
            "p1", ObjID,
            "p2", RateType,
            "p3", ObjN,
            V_INTEGER);
      if (not percday.firstrateid)
        percday.firstrateid = percday.rateid;
      end;
   end;

   if( not insert(percday))
      return false;
   end;
   return true;
end;
                 
macro InsertPay(ObjID, ObjN, CurCode, OpDate, Sum)
var opid;
var paysum;
   paysum = LnSelectValue(  "SELECT NVL (SUM (t_paysum), 0)                  " +
                            "  FROM dlpayop_dbt                              " +
                            " WHERE t_credoperid_ref IN (                    " +
                            "          SELECT t_credoperid                   " +
                            "            FROM dcrd_op_dbt                    " +
                            "           WHERE t_objectid_ref =     " + ObjN    +
                            "             AND t_objecttypeid_ref = " + ObjID   +
                            "             AND t_isdeleted = 0                " +
                            "             AND t_stageid_ref = 99             " +
                            "             AND t_systemoperationid IN (2, 74))", V_MONEY);

   opid = MakeOperation(ObjN, ObjID, CF_PAY_EXTERIOR_CONTR, CurCode, OpDate, 0,"" , "", Sum - paysum);
   if(opid == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию выдачи") , true);
      return false;
   end;

   return true;
end;
                   
macro InsertDutyCrd(DutyData:CDutyCrd, crednum: integer, opdate:date, dutynum:integer, CreditTypeID:integer, CurCode:integer)
var crdop:integer=0, i:integer;
file dutycrd ("duty_crd.dbt", "loans.def") write;
   clearrecord(dutycrd);
   dutycrd.creditnumber_ref = crednum;
   dutycrd.DUTYNUMBER = dutynum;                 
   dutycrd.USERNUMBER = DutyData.USERNUMBER;
   dutycrd.DUTYFIRSTDATE = DutyData.DUTYFIRSTDATE;
   dutycrd.DUTYLASTDATE = DutyData.DUTYLASTDATE;
   dutycrd.DURATION = DutyData.DUTYLASTDATE - DutyData.DUTYFIRSTDATE;
   dutycrd.DUTYSUM = DutyData.DUTYSUM;
   if(DutyData.ANNUIT == 1) dutycrd.ANNUIT = "X"; end;
   dutycrd.DUTYSTATE = "О";
   dutycrd.DATETRANSFERREST = date(0,0,0);
   dutycrd.USERFIELD = "";
   dutycrd.CLOSEREASON = "";
   dutycrd.RETAILACCPAY_REF = 0;
   dutycrd.RETAILACCDUTY_REF = 0;
   dutycrd.DUTYTYPE = 0;
   insert(dutycrd);
   crdop = MakeOperation(crednum, LO_DUTY, CF_DUTYOPEN, 0, opdate,dutycrd , 1, 0);

   if(crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть срочное обязательство по кредитному договору") , true);
      return false;
   end;

   DutyData.DutyID = dutycrd.dutyid;

   // заимствование алгоритмов
/*   crdop = makeoperation(dutycrd.dutyid, LO_DUTY, CF_ALGS, CurCode, opdate, CreditTypeID, LO_TYPECREDIT, DutyData.DUTYLASTDATE);
   if (crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось заимствовать алгоритмы") , true);
      return false;
   end;
*/

   crdop = makeoperation(dutycrd.dutyid, LO_DUTY, CF_RATE, CurCode, opdate, 0, CreditTypeID, LO_TYPECREDIT);
   if (crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию изменения тарифа") , true);
      return false;
   end;
   
   i = 0;
   while(i < DutyData.Rate.size)
      if(InsertRateHistory(LO_DUTY, dutycrd.dutyid, CurCode, opdate, DutyData.Rate[i]) == false)
         return false;
      end;
      i = i + 1;
   end;
  
   if(not InsertPlanPay(DutyData.PlanPay, DutyData.PlanPayPerc, LO_DUTY, dutycrd.dutyid, opdate))
      return false;
   end;
   
   if(DutyData.CLAIM > 0)
      if(not InsertPercDay(LO_DUTY, dutycrd.dutyid, TDR_MAINREST, TRU_CRD, opdate, DutyData.Mainrest, DutyData.Claim) )
         InsErrorMessage(string(XMLFileName, ": Не удалось начислить проценты"), false);
         return false;
      end;
   end;
   
   return true;
end;

macro InsertEnsObj(EnsObj:CEnsObj, enscontr: integer, opdate:date)
file eobj ("ensobj.dbt", "loans.def") write;
file ecneob ("ecn_eob.dbt", "loans.def") write;
file hcosteob ("HCOSTEOB.DBT", "loans.def") write;
file eoverval ("EOVERVAL.DBT", "loans.def") write;
file hqual    ("HQUALITY.DBT", "loans.def") write;

   clearrecord(eobj);
   eobj.ENSTYPEID_REF = EnsObj.ENSTYPEID;
   eobj.COUNTUNIT    = EnsObj.COUNTUNIT;
   eobj.TYPECOUNTUNIT = EnsObj.TYPECOUNTUNIT;
   eobj.ENSOBJECTSUM  = EnsObj.RATINGSUM;
   eobj.ENSOBJECTCUR  = FindFIID(EnsObj.ENSOBJECTCUR);
   eobj.QUALITYID_REF = EnsObj.QUALITYID;
   eobj.Flag_Rvps     = EnsObj.FLAG_RVPS;
   if( not insert(eobj))
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть объект обеспечения") , false);
      return false;
   end;

   if(EnsObj.QUALITYID != 0)
      clearrecord(hqual);
      hqual.OBJECTTYPEID = LO_ENSOBJECT;
      hqual.OBJECTNUMBER = eobj.ensobjectid;
      hqual.DATE         = opdate;
      hqual.QUALITYID    = EnsObj.QUALITYID;
      if( not insert(hqual))
         InsErrorMessage(string(XMLFileName, ": Не удалось открыть объект обеспечения") , false);
         return false;
      end;
   end;

   clearrecord(ecneob);
   ecneob.ENSCONTRACTID_REF = enscontr;
   ecneob.ENSOBJECTID_REF   = eobj.ensobjectid;
   ecneob.RATINGSUM         = EnsObj.RATINGSUM;
   ecneob.RATINGCURCODE     = FindFIID(EnsObj.ENSOBJECTCUR);
   ecneob.MARKETSUM         = EnsObj.MARKETSUM;
   ecneob.MARKETCURCODE     = FindFIID(EnsObj.ENSOBJECTCUR);
   ecneob.REZSUM            = EnsObj.REZSUM;
   ecneob.REZCURCODE        = FindFIID(EnsObj.ENSOBJECTCUR);
   if( not insert(ecneob))
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть объект обеспечения") , false);
      return false;
   end;

   clearrecord(eoverval);
   eoverval.ENSOBJECTID_REF = eobj.ensobjectid;
   eoverval.IOPER           = {oper};
   eoverval.DATE            = opdate;
   eoverval.SUM             = EnsObj.RATINGSUM;
   eoverval.CURCODE         = FindFIID(EnsObj.ENSOBJECTCUR);
   eoverval.NOTE            = "";
   eoverval.MARKETSUM       = EnsObj.MARKETSUM;
   eoverval.MARKETCURCODE   = FindFIID(EnsObj.ENSOBJECTCUR);
   eoverval.REZSUM          = EnsObj.REZSUM;
   eoverval.REZCURCODE      = FindFIID(EnsObj.ENSOBJECTCUR);
   if( not insert(eoverval))
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть объект обеспечения") , false);
      return false;
   end;

   clearrecord(hcosteob);
   hcosteob.OVERVALUEID   = eoverval.OVERVALUEID;
   hcosteob.ENSCONTRACTID = enscontr;
   hcosteob.ENSOBJECTID   = eobj.ensobjectid;
   hcosteob.DATE          = opdate;
   hcosteob.RATINGSUM     = EnsObj.RATINGSUM;
   hcosteob.RATINGCURCODE = FindFIID(EnsObj.ENSOBJECTCUR);
   hcosteob.MARKETSUM     = EnsObj.MARKETSUM;
   hcosteob.MARKETCURCODE = FindFIID(EnsObj.ENSOBJECTCUR);
   hcosteob.REZSUM        = EnsObj.REZSUM;
   hcosteob.REZCURCODE    = FindFIID(EnsObj.ENSOBJECTCUR);
   if( not insert(hcosteob))
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть объект обеспечения") , false);
      return false;
   end;

   return true;
end;

macro InsertEnsContr(EnsContr:CEnsContr, crednum: integer, opdate:date)
var i:integer;
var crdop:integer;
file enscont ("enscontr.dbt", "loans.def") write;
file hcostecr ("HCOSTECR.DBT", "loans.def") write;
   clearrecord(enscont);
   enscont.ENSCONTRACTPERSONID_REF = FindPartiID(EnsContr.ENSCONTRACTPERSON, "Данные о контрагенте ДО N" + EnsContr.ENSCONTRACTNUMBER + " не найдены");
   enscont.ENSCONTRACTNUMBER       = EnsContr.ENSCONTRACTNUMBER;
   enscont.ENSCONTRACTFIRSTDATE    = EnsContr.ENSCONTRACTFIRSTDATE;
   enscont.ENSCONTRACTLASTDATE     = EnsContr.ENSCONTRACTLASTDATE;
   enscont.ENSSYSTYPE              = EnsContr.ENSSYSTYPE;
   enscont.ENSCONTRACTSUM          = EnsContr.ENSCONTRACTSUM;
   enscont.ENSCONTRACTCUR          = FindFIID(EnsContr.ENSCONTRACTCUR);
   enscont.ENSCONTRACTSTATUS       = 1;
   enscont.ENSCATEGORY             = EnsContr.ENSCATEGORY;
   enscont.DISCOUNT                = EnsContr.DISCOUNT;
   enscont.QUALITYID_REF           = EnsContr.QUALITYID;
   enscont.FLAG_RVPS               = EnsContr.FLAG_RVPS;
   enscont.FNCASH              = {OperDprt};

   crdop = MakeOperation(crednum, LO_ENSCONTR, CF_INSERT_ENS, 0, opdate,enscont , 1, 0);
   if(crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть договор обеспечения") , true);
      return false;
   end;

   crdop = LnSelectValue ("select t_objectid_ref from dcrd_op_dbt where t_credoperid = " + crdop, V_INTEGER);

   clearrecord(hcostecr);
   hcostecr.ENSCONTRACTID = crdop;
   hcostecr.CREDITNUMBER  = crednum;
   hcostecr.DATE          = opdate;
   hcostecr.RATINGSUM     = EnsContr.ENSCONTRACTSUM;
   hcostecr.RATINGCURCODE = FindFIID(EnsContr.ENSCONTRACTCUR);
   hcostecr.MARKETSUM     = EnsContr.ENSCONTRACTSUM;
   hcostecr.MARKETCURCODE = FindFIID(EnsContr.ENSCONTRACTCUR);
   hcostecr.REZSUM        = EnsContr.ENSCONTRACTSUM;
   hcostecr.REZCURCODE    = FindFIID(EnsContr.ENSCONTRACTCUR);
   if( not insert(hcostecr))
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть договор обеспечения") , false);
      return false;
   end;

   i = 0;
   while(i < EnsContr.EnsObj.size)
      if(not InsertEnsObj(EnsContr.EnsObj[i], crdop, opdate))
         return false;
      end;
      i = i + 1;
   end;

   return true;
end;
             
macro LinkCessioContract(CrdData:CCreditContr, credit, IDCess:integer, CESSTYPE:string, OpDate: date)
var i:integer;
var crdop:integer;
file payment ("payment.tmp", "loans.def") write;
file chlimhis ("chlimhis.dbt", "loans.def") write;
macro InsRegSum (objid:integer, objn:integer, Regtype:integer, sum:money, ds:integer)
   if(sum > $0)
      clearrecord(payment);
      payment.ObjID     = objid;
      payment.ObjN      = objn;
      payment.regid     = regtype;
      payment.paysum    = sum;
      payment.reference = ds;
      payment.parentid  = 1;
      insert(payment);
   end;
end;
macro InsLimSum (crdnum:integer, LimType:integer, sum:money, opdate:date)
   if(sum > $0)
      clearrecord(chlimhis);
      chlimhis.CreditNumber_ref = crdnum;
      chlimhis.Type             = limtype;
      chlimhis.Date             = opdate;
      chlimhis.Rest             = sum;
      chlimhis.Ground           = "";
      chlimhis.CredOperID_Ref   = 0;
      chlimhis.PlannedLimit     = 0;
      insert(chlimhis);
   end;
end;

   InsLimSum(credit.creditnumber, 25, CrdData.LIMPAY,  OpDate);
   InsLimSum(credit.creditnumber, 26, CrdData.LIMDUTY, OpDate);

   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_MAINREST,     CrdData.MAINREST,     DS_DUTY);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_EXPREST,      CrdData.EXPREST,      DS_EXPDUTY);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_CLAIM,        CrdData.CLAIM,        DS_PERC);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_EXPPERC,      CrdData.EXPPERC,      DS_EXPPERC);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_PENALTI_PERC, CrdData.PENALTI_PERC, DS_EXPPERCFINE);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_PENALTI_CRD,  CrdData.PENALTI_CRD,  DS_EXPDUTYFINE);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_LIMPAY,       CrdData.LIMPAY,       -10);
   InsRegSum(LO_CREDIT, credit.creditnumber, TCLTR_LIMPAY,     CrdData.NOTUSLIMPAY,  -11);
   InsRegSum(LO_CREDIT, credit.creditnumber, TDR_LIMDUTY,      CrdData.LIMDUTY,      -12);
   InsRegSum(LO_CREDIT, credit.creditnumber, TCLTR_LIMDUTY,    CrdData.NOTUSLIMDUTY, -13);

   i = 0;
   while(i < CrdData.DutyCrd.size)
      InsRegSum(LO_DUTY, CrdData.DutyCrd[i].DutyID, TDR_MAINREST,     CrdData.DutyCrd[i].MAINREST,     DS_DUTY);
      InsRegSum(LO_DUTY, CrdData.DutyCrd[i].DutyID, TDR_EXPREST,      CrdData.DutyCrd[i].EXPREST,      DS_EXPDUTY);
      InsRegSum(LO_DUTY, CrdData.DutyCrd[i].DutyID, TDR_CLAIM,        CrdData.DutyCrd[i].CLAIM,        DS_PERC);
      InsRegSum(LO_DUTY, CrdData.DutyCrd[i].DutyID, TDR_EXPPERC,      CrdData.DutyCrd[i].EXPPERC,      DS_EXPPERC);
      InsRegSum(LO_DUTY, CrdData.DutyCrd[i].DutyID, TDR_PENALTI_PERC, CrdData.DutyCrd[i].PENALTI_PERC, DS_EXPPERCFINE);
      InsRegSum(LO_DUTY, CrdData.DutyCrd[i].DutyID, TDR_PENALTI_CRD,  CrdData.DutyCrd[i].PENALTI_CRD,  DS_EXPDUTYFINE);
      i = i + 1;
   end;

   crdop = MakeOperation(IDCess, credit.creditnumber, CF_BIND_BUY, credit.curcode, OpDate, 0, 1, 0, CrdData.Price);
   if(crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию привязки кредитного договора к договору приобретения прав требования") , true);
      return false;
   end;

   return true;
end;
        
macro InsertCreditContractTRN()
var crdop:integer=0, i:integer;
record credit ("credit_c.dbt", "loans.def");
  
   credit.USCREDITNUMBER = CrdData.USCREDITNUMBER;
   credit.REGDATE = CrdData.REGDATE;
   credit.RETURNDATE = CrdData.RETURNDATE;
   credit.CREDITSUM = CrdData.CREDITSUM;
   credit.CURCODE = FindFIID(CrdData.CURCODE);
   credit.clientid_ref = FindPartiID(CrdData.CLIENT, "Данные о заемщике не найдены");
   credit.CREDITTYPEID_REF = CrdData.CREDITTYPEID;
   credit.USCREDITNUMBER = CrdData.USCREDITNUMBER;
   credit.PAYTYPE = CrdData.PAYTYPE;
   credit.DURATION = CrdData.RETURNDATE - CrdData.REGDATE;
   credit.TYPEDURATION = 1;
   credit.CRD_KIND = LO_CREDIT;
   credit.CREDITSTATE = "О";
   credit.FNCASH = {OperDprt};
   credit.TERRITORIALSTRUCT = {OperDprtNode};
   credit.LEGALFORM = CrdData.CLIENT.LEGALFORM;
   credit.TypeDebtor = CrdData.CLIENT.LEGALFORM;
   if(CrdData.ANNUIT == 1) credit.ANNUIT = "X"; end;

   crdop = MakeOperation(0, 0, CF_OPCRD, 0, opdate, Credit);
      
   if(crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось открыть кредитный договор") , true);
      return false;
   end;

   credit.creditnumber = LnSelectValue ("select t_creditnumber_ref from dcrd_op_dbt where t_credoperid = " + crdop, V_INTEGER);

   // заимствование алгоритмов
 /*  crdop = makeoperation(credit.creditnumber, LO_CREDIT, CF_ALGS, credit.CURCODE, opdate, credit.CREDITTYPEID_REF, LO_TYPECREDIT, credit.RETURNDATE);
   if(crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось заимствовать алгоритмы") , true);
      return false;
   end;
*/

   crdop = MakeOperation(credit.creditnumber, LO_CREDIT, CF_RATE, credit.CURCODE, opdate,0, credit.CREDITTYPEID_REF, LO_TYPECREDIT);
   if(crdop == 0)
      InsErrorMessage(string(XMLFileName, ": Не удалось выполнить операцию изменения тарифа") , true);
      return false;
   end;

   i = 0;
   while(i < CrdData.Rate.size)
      if(InsertRateHistory(LO_CREDIT, credit.creditnumber, credit.CURCODE, opdate, CrdData.Rate[i]) == false)
         return false;
      end;
      i = i + 1;
   end;

   if(not InsertPlanPay(CrdData.PlanPay, CrdData.PlanPayPerc, LO_CREDIT, credit.creditnumber, opdate))
      return false;
   end;

   i = 0;
   while(i < CrdData.DutyCrd.size)
      if(not InsertDutyCrd(CrdData.DutyCrd[i], credit.creditnumber, opdate, i+1, credit.CREDITTYPEID_REF, credit.CURCODE))
         return false;
      end;
      i = i + 1;
   end;
   
   if(not LinkCessioContract(CrdData, credit, IDCess, CESSTYPE, opdate))
      return false;
   end;
   
   i = 0;
   while(i < CrdData.EnsContr.size)
      if(not InsertEnsContr(CrdData.EnsContr[i], credit.creditnumber, opdate))
         return false;
      end;
      i = i + 1;
   end;

   if(CrdData.CLAIM > 0)
      if(not InsertPercDay(LO_CREDIT, credit.creditnumber, TDR_MAINREST, TRU_CRD, opdate, CrdData.Mainrest, CrdData.Claim) )
         InsErrorMessage(string(XMLFileName, ": Не удалось начислить проценты"), false);
         return false;
      end;
   end;       
            
   if(CrdData.PAYSUM > 0)
      if(not InsertPay(LO_CREDIT, credit.creditnumber, credit.CurCode, OpDate, CrdData.PaySum) )
         InsErrorMessage(string(XMLFileName, ": Не удалось произвести выдачу"), false);
         return false;
      end;
   end;
   
   i = 0;
   while(i < CrdData.DutyCrd.size)
      if(CrdData.DutyCrd[i].PAYSUM > 0)
         if(not InsertPay(LO_DUTY, CrdData.DutyCrd[i].DutyID, credit.CurCode, opdate, CrdData.DutyCrd[i].PaySum) )
            InsErrorMessage(string(XMLFileName, ": Не удалось произвести выдачу"), false);
            return false;
         end;
      end;
      i = i + 1;
   end;
              
   return true;
end;

macro UpdateCreditContractTRN()
var rs = NULL, rs2 = NULL, dutyid: integer, crdid:integer, crdtypeid:integer, curcode:integer, i:integer, operid:integer, duid:integer,
sender_idnm:string, sender_onm:string, srv_loan:string;
record credit ("credit_c.dbt", "loans.def");

   rs = LnGetRecordSet(
            "SELECT f.t_fi_code, c.t_creditnumber, c.t_CREDITTYPEID_REF, c.t_CURCODE FROM DCREDIT_C_DBT c, dfininstr_dbt f WHERE " +
            " c.T_CRD_KIND = " + LO_CREDIT+ " AND" +
                  " c.t_curcode = f.t_fiid and" +
            " c.T_USCREDITNUMBER = '" + CrdData.UsCreditNumber + "' and" +
            " c.T_FNCASH = " + {OperDprt});

   if(rs == NULL or not rs.MoveNext())  
      InsErrorMessage(string(XMLFileName, ": Не найден кредитный договор обратного выкупа") , false);
      return false;
   end;

   if(rs.Value("t_fi_code", NULL, V_STRING) != CRDData.curcode)
      InsErrorMessage(string(XMLFileName, ": Валюта кредитного договора не совпадает с валютой договора обратного выкупа") , false);
      return false;
   end;

   crdid =     rs.Value("t_creditnumber", NULL, V_INTEGER);
   crdtypeid = rs.Value("t_CREDITTYPEID_REF", NULL, V_INTEGER);
   curcode =   rs.Value("t_CURCODE", NULL, V_INTEGER);

   operid = CRsdCommand ("SELECT MAX (cop.t_CredOperID) FROM DCRD_OP_DBT cop WHERE cop.t_CreditNumber_Ref = ?" + 
            " AND cop.t_SystemOperationID = ? AND cop.t_OperTypeNumber_Ref = ?" + 
            " AND cop.t_IsDeleted = 0" +
            " AND NOT EXISTS (SELECT * FROM DCRD_OP_DBT cp WHERE cp.t_CreditNumber_Ref = ?" + 
                    " AND cp.t_SystemOperationID = ? AND cp.t_OperTypeNumber_Ref = ? " +
                    " AND cp.t_IsDeleted = 0" +
                    " AND cp.t_CredOperDate > cop.t_CredOperDate)",
            "p1", crdid,
            "p2", CS_BIND_CESS,
            "p3", CF_BIND_CESS,
            "p4", crdid,
            "p5", CS_BIND_CESS,
            "p6", CF_BIND_BUY_BACK,
            V_INTEGER);

   if ((operid == NULL) or (operid == 0) or (ValType(operid) == 26))
    InsErrorMessage (string(XMLFileName, ": У кредитного договора некорректный список операций"), false);
    return false;
   end;

   duid = CRsdCommand ("SELECT t_parentid FROM DCRDLINK_DBT WHERE t_TypeParent = ? AND t_ObjectNumber = ?",
            "p1", LO_DOGCREDCLAIMCESSION,
            "p2", crdid,
            V_INTEGER);

   rs2 = CRsdCommand ("SELECT pc.t_Code as Code, party.t_ShortName as SName FROM DPARTY_DBT party, DPARTCODE_DBT pc, DCREDIT_C_DBT crd WHERE party.t_PartyID = pc.t_PartyID " +
            " AND party.t_PartyID = crd.t_ClientID_Ref AND crd.t_CreditNumber = ? AND pc.t_CodeKind = ?", "p1", duid, "p2", 1, V_GENOBJ);

   rs2.moveNext();

   sender_idnm = rs2.Value("Code", NULL, V_STRING);
   sender_onm  = rs2.Value("SName", NULL, V_STRING);

   if ((TFile.ID_sender != sender_idnm) or (TFile.Name_sender != sender_onm))
    InsErrorMessage (string(XMLFileName, ": Клиент кредитного договора не совпадает с отправителеем ТФ"), false);
    return false;
   end;

   srv_loan = CRsdCommand ("SELECT t_ServiceLoan FROM DASGMTPARM_DBT WHERE t_CreditNumber = ?", "p1", duid, V_STRING);

   if (srv_loan == "X")
    InsErrorMessage (string(XMLFileName, ": Для кредитного договора установлен флаг \x22Обслуживание кредитов после уступки прав требования\x22"), false);
    return false;
   end;

   i = 0;
   while(i < CrdData.DutyCrd.size)
      dutyid = 0;
      dutyid = LnSelectValue(
                "SELECT t_dutyid FROM DDUTY_CRD_DBT WHERE t_usernumber = '" + CrdData.DutyCrd[i].USERNUMBER + "' and t_creditnumber_ref = " + crdid, V_INTEGER);

      if(dutyid == 0)  
         dutyid = LnSelectValue("SELECT count(t_dutyid) FROM DDUTY_CRD_DBT where t_creditnumber_ref = " + crdid, V_INTEGER) + 1;
         if(not InsertDutyCrd(CrdData.DutyCrd[i], crdid, opdate, dutyid, crdtypeid, curcode))
            return false;
         end;
      else
          CrdData.DutyCrd[i].DutyID = dutyid;
      end;
      i = i + 1;
   end;

   credit.creditnumber = crdid;
   credit.curcode = curcode;

   if(not LinkCessioContract(CrdData, credit, IDCess, CESSTYPE, opdate))
      return false;
   end;
 
   return true;
end;

macro InsertCreditContract(C:CCreditContr, D:date, I:integer, T:string)
   CrdData = C;
   opdate  = D; 
   IDCess  = I;
   CESSTYPE= T;

   return RtTrn("InsertCreditContractTRN");
end;

macro UpdateCreditContract(C:CCreditContr, D:date, I:integer, T:string, TF:CTransportFile)
   CrdData = C;
   opdate  = D; 
   IDCess  = I;
   CESSTYPE= T;
   TFile = TF;

   return RtTrn("UpdateCreditContractTRN");
end;

macro ЗагрузкаСтороннегоКредита(FName:string, OpDate:date)
var i;
var s:string;
var client:integer = 0;
var OD:bool = false, SR:bool = false, SC:bool = false, CRD:bool = false;
file party ("party.dbt",    "bank.def")  key 0;
var xml:object = ActiveX( "MSXML.DOMDocument" ), child:object, node:object, root:object;
var TransportFile: CTransportFile;
var ID_Cession:integer = 0;
var stat:bool;

  XMLFileName = FName;
  if( not xml.load(XMLFileName) )
    InsErrorMessage( string( "Неверный формат файла импорта|", XMLFileName, "|Невозможно загрузить xml-документ" ) , false);
    return false;
  end;

  i = 0;
  root = xml.DocumentElement;
  while( i < root.childNodes.length )
     child = root.childNodes.item(i);
     if( child and (child.nodeType==CHILD_NODE) )

        if(child.tagname == "OPERDATE")
          if(OD)
             InsErrorMessage(string(XMLFileName, ": Блок OPERDATE должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;
          OD = true;
          if(ReadTagText(child, V_DATE, TransportFile.OperDate) == false)
             return false;
          end;
        end;

        if(child.tagname == "SENDER")
          if(SR)
             InsErrorMessage(string(XMLFileName, ": Блок SENDER должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;

          SR = true;
/*
          if((ReadTagAttribut(child, "ID_NM", V_STRING, TransportFile.ID_sender) == false) or
          (ReadTagAttribut(child, "O_NM", V_STRING, TransportFile.Name_sender) == false))
             return false;
          end;
*/
          if(ReadTagAttribut(child, "ID_NM", V_STRING, TransportFile.ID_sender) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ID_NM не заполнено") , false);
      end;
          if(ReadTagAttribut(child, "O_NM", V_STRING, TransportFile.Name_sender) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле O_NM не заполнено") , false);
      end;
        end;

        if(child.tagname == "SEG_CESSION")
          if(SC)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_CESSION должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;

          SC = true;
/*
       if((ReadTagAttribut(child, "CRD_KIND", V_STRING, TransportFile.crd_kind) == false) or
          (ReadTagAttribut(child, "USCREDITNUMBER", V_STRING, TransportFile.UscreditNumber) == false) or
          (ReadTagAttribut(child, "DATE", V_DATE, TransportFile.date_cess) == false))
             return false;
          end;
*/
          if(ReadTagAttribut(child, "CRD_KIND", V_STRING, TransportFile.crd_kind) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле CRD_KIND не заполнено") , false);
                return false;
      end;
          if(ReadTagAttribut(child, "USCREDITNUMBER", V_STRING, TransportFile.UscreditNumber) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле ID_NM не заполнено") , false);
                return false;
      end;
          if(ReadTagAttribut(child, "DATE", V_DATE, TransportFile.date_cess) == false)
        InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле DATE не заполнено") , false);
                return false;
      end;
        end;

        if(child.tagname == "SEG_CREDIT")
          if(CRD)
             InsErrorMessage(string(XMLFileName, ": Блок SEG_CREDIT должен присутствовать в ТФ в единственном экземпляре") , false);
             return false;
          end;

          CRD = true;
          if(GetTagCredit(child, TransportFile.CreditContr) == false)
             return false;
          end;
        end;
     end;
     i = i + 1;
  end;

  if(not OD) 
     InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле OPERDATE не заполнено") , false);
     return false;
  end;
  if(not SR) 
     InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле SENDER не заполнено") , false);
     return false;
  end;
  if(not SC) 
     InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле SEG_CESSION не заполнено") , false);
     return false;
  end;
  if(not CRD) 
     InsErrorMessage(string(XMLFileName, ": Обязательное для заполнения поле SEG_CREDIT не заполнено") , false);
     return false;
  end;

  // Поиск отправителя
  ClearRecord(party);
  party.PartyID = LnSelectValue (
         "select p.t_partyid from dparty_dbt p, dpartcode_dbt c " +
           "where p.t_partyid = c.t_PartyID and " +
                 "c.t_CodeKind  = 1 and " +
                 "c.t_Code =  '" + TransportFile.ID_sender + "'", V_INTEGER);

  if (not SR or not GetEQ(party))
     InsErrorMessage(string(XMLFileName, ": В справочнике субъектов не найден отправитель ТФ") , false);
     return false;
  end;

  client = FindPartiID(TransportFile.CreditContr.CLIENT, "Данные о заемщике не найдены");

  // поиск договора цессии
  ID_cession = LnSelectValue (
     "select decode(t_clientid_ref, " + client + ", -1, t_creditnumber)" +
     " from dcredit_c_dbt crd, DLOBJECT_DBT lo " +
     "  where crd.T_CRD_KIND = lo.t_OBJECTID and " +
     "       crd.T_FNCASH = " + {OperDprt} + " and " +
     "       lo.t_SHORTNAME = '" + TransportFile.crd_kind + "' and " +
     "        crd.T_USCREDITNUMBER = '" + TransportFile.UsCreditNumber + "'",
     V_INTEGER);

  if(not SC or ID_cession == 0)
     InsErrorMessage(string(XMLFileName, ": Не найден договор цессии"), false);
     return false;
  elif(ID_cession == -1)
     InsErrorMessage(string(XMLFileName, ": Заемщик КД совпадает с клиентом договора Цессии"), false);
     return false;
  end;

  if(TransportFile.crd_kind != "ДВ")
     // вставка кредитного договора
     stat = InsertCreditContract(TransportFile.CreditContr, OpDate/*TransportFile.OperDate*/, ID_cession, TransportFile.crd_kind);
  else
     // обновление кредитного договора
     stat = UpdateCreditContract(TransportFile.CreditContr, OpDate/*TransportFile.OperDate*/, ID_cession, TransportFile.crd_kind, TransportFile);
  end;

  if(stat == true)
     InsErrorMessage(string(XMLFileName, ": Успешно загружен") , false);
  else
     InsErrorMessage(string(XMLFileName, ": Загрузка невозможна") , false);
  end;

  return stat;
end;
