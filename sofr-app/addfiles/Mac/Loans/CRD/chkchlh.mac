/*
 $Name: chkchlh.mac
 $Module: Кредитование
 $Description: Макрос проверки при проведении операции по изменению лимита
*/

import LoansFind, SbCrdInter, Total;

record Договор     ("credit_c.dbt", "loans.def"); /* Текущий буфер КД */
record genag       ("credit_c.dbt", "loans.def"); /* Генсоглашение */
RECORD ВидКредита     ("Type_Crd.dbt", "loans.def"); /* Вид кредита */

MACRO CheckChlhOp(RestDate: date, Rest: money, Type: integer)
VAR SummaGA:money = $0;
VAR Summa:money = Rest;
VAR Sum:money = $0;
VAR rs = null;
VAR PayType:integer = 0;

   /*if((Договор.GeneralAgreement_Ref) AND (Договор.Crd_kind != LO_OVERDRAFT))
       if(NOT Loans_FindCrdContract(Договор.GeneralAgreement_Ref, genag)) return false; end;

       if(((Type == TDR_LIMPAY)  AND ((genag.PayType == CF_CRLINNO)  OR (genag.PayType == CF_CRLIN))) OR
          ((Type == TDR_LIMDUTY) AND ((genag.PayType == CF_CRLINNEW) OR (genag.PayType == CF_CRLIN)))
         )
           SummaGA = ОстатокРегистра(LO_GENAGGR, Договор.GeneralAgreement_Ref, Type, RestDate, Договор.CurCode);
           ConvSum(Summa, Summa, RestDate, Договор.CurCode, genag.CurCode);

           if(Type == TDR_LIMPAY)
               //сумма лимитов по договорам
               rs = LnGetRecordSet("select T_CreditNumber, T_PayType, T_CreditSum, t_CurCode from dcredit_c_dbt where t_GeneralAgreement_Ref = " + Договор.GeneralAgreement_Ref +
                                   " and t_CreditNumber <> " + Договор.CreditNumber);
               if(rs == null) return 0; end; 

               while (rs.MoveNext())
                   PayType = rs.value(1, null, V_INTEGER);
                   if((PayType == CF_NONREP) OR
                      (PayType == CF_REP)    OR
                      (PayType == CF_POSTERESTANTE) OR
                      (PayType == CF_BEFOREMATURITY)
                     )
                       Sum = rs.value(2, null, V_MONEY);
                   else
                       Sum = ОстатокРегистра(Договор.Crd_kind, rs.value(0, null, V_INTEGER), Type, RestDate);
                   end;
                   ConvSum(Sum, Sum, RestDate, rs.value(3, null, V_INTEGER), genag.CurCode);

                   Summa = Summa + Sum;
                   Sum = $0;
               end;   
           end;
           if(Summa > SummaGA)
               if(Type == TDR_LIMPAY)
                   msgbox("Сумма лимитов выдачи по договорам превышает лимит по ген. соглашению!");
               else
                   msgbox("Сумма лимита превышает лимит по ген. соглашению!");
               end;
               return 1;
           end;
       end;
   end;
*/
   if (NOT Loans_FindTypeCrd(0, "", 0, Договор.CreditTypeID_Ref, ВидКредита))
       msgbox("Не найден вид кредита!");
       return 1;
   end;
   
   if ((Договор.Crd_kind == LO_CREDIT) OR ((Договор.Crd_kind == LO_KARTA) AND (Договор.PayType == CF_CREDKARTA)))
       SummaGA = ОстатокОткрытыхСО(Договор.CreditNumber, TDR_MAINREST, RestDate);
   elif((Договор.Crd_kind == LO_KARTA) AND (Договор.PayType == CF_CALCKARTA))
       SummaGA = ОстатокРегистра(LO_KARTA, Договор.CreditNumber, TDR_MAINREST);
   end;
   /* Для кредитного договора, если не установлен признак "Превышение Лимита"*/
   if ((Договор.Crd_kind == LO_CREDIT) AND
       (((ВидКредита.TypeOverdraft != CF_NONREP) AND (ВидКредита.credit_overdraft != "X")) OR
        (ВидКредита.TypeOverdraft == CF_NONREP)) AND
       (Rest < SummaGA)
      )
       LoansError (18057);
       return 1;
   end;
   
   /* Для банковской карты, если не установлен признак "Превышение Лимита"*/
   if ((Договор.Crd_kind == LO_KARTA) AND
       (ВидКредита.credit_overdraft != "X") AND
       (Rest < SummaGA)
      )
       LoansError(18057);
       return 1;
   end;

   if (Договор.Crd_kind == LO_GUARANTEE)
       if (Rest <
           (ОстатокОткрытыхСО(Договор.CreditNumber, TDR_PAYMGUARANTEE, RestDate) +
            ОстатокОткрытыхСО(Договор.CreditNumber, TDR_PAYEDGUARANTEE, RestDate) +
            ОстатокОткрытыхСО(Договор.CreditNumber, TDR_EXPPAYMGUARANTEE, RestDate))
          )
           LoansError(18384);
           return 1;
       end;
   end;
   
   return 0;
END;