/*
$Name: spdb_30.mac
$Module: Депозитарий
$Description: Книжный перевод эмиссионных ценных бумаг - шаг Отражение операции по счетам
*/
import InsCarryDoc, OprInter, PaymInter, "dlcarry.inc", dpmassexec;

/* Буферы ПД, заполняемые из операции */
record Pm_paym( pmpaym );    /*основной платеж*/
record Pm_prop_deb( pmprop ); /*св-ва платежа банка-плательщика*/
record Pm_prop( pmprop );    /*св-ва платежа*/
record Pm_rmprop( pmrmprop ); /*платеж по ценным бумагам*/


macro ExecuteStep( d, spdraft )
  var carryDate, AinPEnabled, accTrn, PayerFaceAccount = "", ReceiverFaceAccount = "", err = 0;
  var ground = "Внутридепозитарный перевод ценных бумаг";
  record spdraft_buf(spdraft);
  var errmsg="";

  if( DP_CheckRejectedDepoDraft( spdraft, Pm_paym, err ) ) return err; end;


  SetBuff( Doc, d ); /* документ проводки */
  SetBuff( spdraft_buf, spdraft );

  if (Pm_paym.ValueDate<{curdate})
      carryDate = Pm_paym.ValueDate;
  else
      carryDate = {curdate};
  end;


  if( Pm_paym.IndoorStorage == 0 ) /* Если проводка по открытому хранению */
    PayerFaceAccount = GetAccountByPart(Pm_paym.FIID, Pm_paym.PayerDpNode, Pm_paym.ValueDate);
    if(PayerFaceAccount == "")
      PayerFaceAccount = InputAccountByDepoAcc( Pm_paym.PayerDpNode, DP_OPRACC_PAYER, spdraft, DP_SPDRAFT_OPERATION, err );
    end;
    if( PayerFaceAccount == "" ) /* Была ошибка */
      if(err == DP_GETACC_ESC) /* прерывание пользователя */
        return err;
      end;
      err = 1;
    end;
    
    if( NOT err )
      ReceiverFaceAccount = GetAccountByPart(Pm_paym.FIID, Pm_paym.ReceiverDpNode, Pm_paym.ValueDate);
      if(ReceiverFaceAccount == "")
        ReceiverFaceAccount = InputAccountByDepoAcc( Pm_paym.ReceiverDpNode, DP_OPRACC_RECEIVER, spdraft, DP_SPDRAFT_OPERATION, err );
      end;
      if( ReceiverFaceAccount == "" ) /* Была ошибка */
        if(err == DP_GETACC_ESC) /* прерывание пользователя */
          return err;
        end;
        err = 1;
      end;
    end;
    
    if((not err) and (not CheckAcRestWriteOff(@errmsg, PayerFaceAccount, Pm_paym.PayerDpNode, ReceiverFaceAccount, Pm_paym.ReceiverDpNode, Pm_paym.FIID, carryDate, Pm_paym.Amount)))
      DPError.SetErr( errmsg );
      err = 1;
    end;


    if( (NOT err) AND ( DocCarry( true,                    /* счета проводки - валюта (false - валюта с покрытием)*/                
                                  5,                       /*Глава*/
                                  Pm_paym.FIID,            /*Валюта*/
                                  PayerFaceAccount,        /*Плательшик*/
                                  ReceiverFaceAccount,     /*Получатель*/
                                  Pm_paym.Amount,          /*сколько*/
                                  CarryDate,               /*дата*/
                                  0,                       /*Результат проводки*/
                                  ground,
                                  Pm_paym.PaymentID,
                                  PMMET_ID,
                                  accTrn,
                                  18                       /*Шифр операции*/
                                )
                      )
      )
      DPError.SetErr( "Ошибка при вставке проводки" );
      err = 1;
    end;
    
    /* Обработаем проводки по субсчетам учета Актива в Пассиве */
    if( NOT err )
      if( GetAinPAccState( AinPEnabled ) != 0 )
        err = 1;
      else
        if( AinPEnabled ) /* и включен режим учета Актива в Пассиве */
          if( ExecuteSubAccCarry( false, accTrn.AccTrnID, Pm_paym.PayerDpNode, Pm_paym.ReceiverDpNode, PayerFaceAccount, ReceiverFaceAccount, Pm_paym.FIID, Pm_paym.Amount, carryDate, Pm_paym.PaymentID, DPSubAccData(Pm_paym, spdraft, NULL, NULL) ) )
            err = 1;
          end;
        end;
      end;
    end;

  else /* проводка по Закрытому хранению */

    err = ExecuteIndoorStorageCarry( spdraft, Pm_paym.PaymentID, Pm_paym.PayerDpNode, Pm_paym.ReceiverDpNode, Pm_paym.FIID, carryDate, ground );
    if(err == DP_GETACC_ESC) /* прерывание пользователя */
       return err;
    end;

  end;

  if( ( err == 0 ) and ( DefineKindOperation( Pm_paym.PayerDpNode, Pm_paym.ReceiverDpNode ) == KINDOPER_TRANSFER ) )
    err = DP_AddToGrRep( spdraft_buf.SPGroundID, Pm_paym.Payer, spdraft_buf.Kind, spdraft_buf.AutoKey, CodeFor("E"), false );

    if( err == 0 )
      err = DP_AddToGrRep( spdraft_buf.SPGroundID, Pm_paym.Receiver, spdraft_buf.Kind, spdraft_buf.AutoKey, CodeFor("E"), false );
    end;
  end;

  RsbPayment( Pm_paym.PaymentID ).PaymStatus = PM_FINISHED;

  if(not err)
    err = DP_RegDraftMagNumber(spdraft_buf.AutoKey);
  end;

  /* осуществляем экспорт в БОЦБ */
  if( (NOT err) and (spdraft_buf.ToBO == "X") )
    err = ExecMacroFile("dpexpsecur.mac", "ExpToSecur", spdraft_buf, Pm_paym);
  end;

  if(not err)
    err = RegAllExtGroundToGrRep(spdraft);
  end;

  if( err )
    err = RejectDepoDraftYesNo( spdraft, DP_SPDRAFT_OPERATION );
  end;

  return err;
end;


MACRO MassExecuteStep()
  var cmd, query, DataSet;
  var r_spdraft= TRecHandler("spdraft.dbt");
  var r_paym   = TRecHandler( "pmpaym.dbt" );  
  var r_debet  = TRecHandler( "pmprop.dbt" );  
  var r_credit = TRecHandler( "pmprop.dbt" );  
  var r_rmprop = TRecHandler( "pmrmprop.dbt" );

  var pmobj = NULL, DpNode, err = 0, stat = 0, ErrStr;
  var OprStatus = 0;
  FILE DepoAcc( depoacnt ) key 2;  /* по короткому коду + номер отделения */
  var CorrAccDpNode = 0;
  var carryDate, AinPEnabled, accTrn, PayerFaceAccount = "", ReceiverFaceAccount = "";
  var ground = "Внутридепозитарный перевод ценных бумаг";
  var errmsg = "";
  var batchTrn = DP_BatchPaymTrn();

  if(DP_MassCheckRejectedDepoDraft() != 0)
    return 1;
  end;

  if(GetAinPAccState( AinPEnabled ) != 0)
    return 1;
  end;

  var pointName = DP_SqlSavePoint();

  query =   " select dr.*, mv.t_PaymentID, oprtemp.t_ID_Operation, oprtemp.t_ID_Step "
          + "   from DOPRTEMP_VIEW oprtemp, dspdraft_dbt dr, dspdrmove_dbt mv "
          + "  where dr.t_AutoKey = oprtemp.t_OrderID "
          + "    and mv.t_DraftID = dr.t_AutoKey ";

  cmd = DL_RSDCommand(query);
   
  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    stat = 0;
    
    DataSet.GetRecord().CopyTo( r_spdraft.rec );
    
    pmobj = RsbPayment( DataSet.PaymentID );

    Copy(r_paym,   pmobj.GetPM_PAYM());
    Copy(r_rmprop, pmobj.GetPMRMPROP());
    Copy(r_debet,  pmobj.GetDEBET());
    Copy(r_credit, pmobj.GetCREDIT());

    if(r_paym.rec.ValueDate < {curdate})
      carryDate = r_paym.rec.ValueDate;
    else
      carryDate = {curdate};
    end;

    batchTrn.SetContextParams(r_spdraft, NULL, r_paym, r_debet, r_credit, r_rmprop, DataSet.ID_Operation, DataSet.ID_Step);

    if( r_paym.rec.IndoorStorage == 0 ) /* Если проводка по открытому хранению */
      PayerFaceAccount = GetAccountByPart(r_paym.rec.FIID, r_paym.rec.PayerDpNode, r_paym.rec.ValueDate);
      if(PayerFaceAccount == "")
        PayerFaceAccount = InputAccountByDepoAcc( r_paym.rec.PayerDpNode, DP_OPRACC_PAYER, NULL, DP_SPDRAFT_OPERATION, stat, null, false, batchTrn.DraftAllParms() );
      end;
      if( PayerFaceAccount == "" ) /* Была ошибка */
        if(stat == DP_GETACC_ESC) /* прерывание пользователя */
          return stat;
        end;
        stat = 1;
        DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, DPError.GetErr() );
      end;

      if( NOT stat )
        ReceiverFaceAccount = GetAccountByPart(r_paym.rec.FIID, r_paym.rec.ReceiverDpNode, r_paym.rec.ValueDate);
        if(ReceiverFaceAccount == "")
          ReceiverFaceAccount = InputAccountByDepoAcc( r_paym.rec.ReceiverDpNode, DP_OPRACC_RECEIVER, NULL, DP_SPDRAFT_OPERATION, stat, null, false, batchTrn.DraftAllParms() );
        end;
        if( ReceiverFaceAccount == "" ) /* Была ошибка */
          if(stat == DP_GETACC_ESC) /* прерывание пользователя */
            return stat;
          end;
          stat = 1;
          DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, DPError.GetErr() );
        end;
      end;

      if(not stat)
        stat = batchTrn.AddOneAccTrnByPaym(carryDate, PayerFaceAccount, ReceiverFaceAccount, ground);
        if(stat)
          DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, "Ошибка при вставке проводки" );        
        end;
      end;

    else /* проводка по Закрытому хранению */

      stat = ExecuteIndoorStorageCarry( NULL, r_paym.rec.PaymentID, r_paym.rec.PayerDpNode, r_paym.rec.ReceiverDpNode, r_paym.rec.FIID, carryDate, ground, batchTrn );
      if(stat == DP_GETACC_ESC) /* прерывание пользователя */
         return stat;
      end;

    end;

  end;

  if( (not err) and (batchTrn.Execute() != 0))
    DPError.SetErr( "Ошибка при исполнении проводок" );
    err = 1;
  end;
  
  if(not err)
    err = DP_MassChangePaymStatus();
  end;

  if(not err)
    err = DP_MassGenerateDraftOprXid();
  end;

  if(not err)
    err = DP_MassAddAllOwnerToGrRep();
  end;

  if(not err)
    err = DP_MassRegExtGroundToGrRep();
  end;

  if(not err)
    err = DP_MassExpToSecur();
  end;

  if(err)
    DP_SqlRollBackPoint(pointName);
    //ставим отметку об ошибке выполнения всем поручениям пачки
    DP_SetErrorOprTemp(0, err, "Ошибка при пакетном выполнении шага");
  end;

  return 0;

OnError(er)
  if((ValType(pointName) != V_UNDEF) and pointName != "")
    DP_SqlRollBackPoint(pointName);
  end;

  DP_SetErrorOprTemp(0, 1, er.module+ " "+er.line+" "+er.message);
  return 0;
END;
