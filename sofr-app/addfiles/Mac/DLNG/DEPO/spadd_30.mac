/*
$Name: spadd_30.mac
$Module: Депозитарий
$Description: Зачисление безналичных ценных бумаг. Шаг "Зачисление на счет депонента"
*/
import OprInter, PTInter, InsCarryDoc, PaymInter, "dlcarry.inc", makenum, dpmassexec;

/* Буферы ПД, заполняемые из операции */
record Pm_paym( pmpaym );    /*основной платеж*/
record Pm_prop_deb( pmprop ); /*св-ва платежа банка-плательщика*/
record Pm_prop( pmprop );    /*св-ва платежа*/
record Pm_rmprop( pmrmprop ); /*платеж по ценным бумагам*/


MACRO ExecuteStep( d, spdraft )
  var stat = 0, CustAccount = "", CustAccountID = 0, NumberCorschem = 0, DpNode, 
      carryDate, AinPEnabled, accTrn, DwNodeID, BnNodeID, errstr = "",
      PayerFaceAccount = "", ReceiverFaceAccount = "", err = 0;
  var ground = "Зачисление безналичных ценных бумаг на счет депонента";
  var errmsg = "";
  var CorrAccDpNode = 0;

  FILE DepoAcc( depoacnt ) key 2;  /* по короткому коду + номер отделения */
  record spdraft_buf("spdraft.dbt");


  if( DP_CheckRejectedDepoDraft( spdraft, Pm_paym, err ) ) return err; end;

  SetBuff( spdraft_buf, spdraft );

  SetBuff( Doc, d ); /* документ проводки */

  if(Pm_paym.ValueDate<{curdate})
      carryDate = Pm_paym.ValueDate;
  else
      carryDate = {curdate};
  end;

  if( (spdraft_buf.SendInstruction != "") and (spdraft_buf.FromTransitAccount != "X") )
    if( not DP_SpdraftIsBothDepart(spdraft_buf) )
      if( not FindDpMessageByDraft(spdraft_buf.AutoKey) )
        DPError.SetErr( "На шаге \"Создание сообщения\" сообщение не было сформировано или было удалено. Продолжение невозможно" );
        err = 1;
      end;
    end;
  end;

  DwNodeID = Pm_paym.PayerDpNode;

  /* проверка наличия транзитного счета */
  if( (not err) and (spdraft_buf.FromTransitAccount == "X") and (GetTransitAccount( DepoAcc )) )
    err = 1;
  end;

  /* проверим по дебету */
  if( (spdraft_buf.FromTransitAccount != "X") and (not err) and (pm_paym.PayerBankID != {OurBank}))
    if( Pm_prop_deb.Corschem != -1 ) /* Проверим наличие с/р и корсчета */
      DepoAcc.BriefCode = GetCorAcc( Pm_prop_deb.PayFIID, Pm_prop_deb.Corschem, CORS_ACC_ACCOUNT );
      DepoAcc.Department = {OperDprt};
      if( not getEQ( DepoAcc ) )
        if ( DepoAcc.BriefCode != "")
          DPError.SetErr( "Не найден корреспондентский счет депо :", DepoAcc.BriefCode );
        else
          DPError.SetErr( "Не найден корреспондентский счет депо" );
        end;
        err = 1;
      end;
    else
      DPError.SetErr( "Не задана схема расчетов!" );
      err = 1;
    end;
  end;

  
  if( Pm_paym.ReceiverBankID == {OurBank} ) /*счет депонента - депозитарий наш банк*/
     BnNodeID = Pm_paym.ReceiverDpNode;
  else /*счет депонента - депозитарий НЕ наш банк */
     /* Определим корсчет */
     if( Pm_prop.Corschem != -1 )
       DepoAcc.BriefCode = GetCorAcc( Pm_prop.PayFIID, Pm_prop.Corschem, CORS_ACC_ACCOUNT );
       DepoAcc.Department = {OperDprt};
   
       if( not getEQ( DepoAcc ) )
         if ( DepoAcc.BriefCode != "")
           DPError.SetErr( "Не найден корреспондентский счет депо :", DepoAcc.BriefCode );
         else
           DPError.SetErr( "Не найден корреспондентский счет депо" );
         end;
         err = 1;
       else
         BnNodeID = DepoAcc.AutoKey;
       end;
     else
       DPError.SetErr( "Не задана схема расчетов!" );
       err = 1;
     end;
  end;


  if(NOT err)
    if( Pm_paym.IndoorStorage == 0 ) /* Если проводка по открытому хранению */
      PayerFaceAccount = GetAccountByPart(Pm_paym.FIID, DwNodeID, Pm_paym.ValueDate);
      if(PayerFaceAccount == "")
        PayerFaceAccount = InputAccountByDepoAcc( DwNodeID, DP_OPRACC_PAYER, spdraft, DP_SPDRAFT_OPERATION, err, null, DP_IIF(spdraft_buf.FromTransitAccount == "X", true, false) );
        if( PayerFaceAccount == "" ) /* Была ошибка */
          if(err == DP_GETACC_ESC) /* прерывание пользователя */
            return err;
          end;
          err = 1;
        end;
      end;

      if(NOT err)
        ReceiverFaceAccount = GetAccountByPart(Pm_paym.FIID, Pm_paym.ReceiverDpNode, Pm_paym.ValueDate);
        if(ReceiverFaceAccount == "")
          ReceiverFaceAccount = InputAccountByDepoAcc( Pm_paym.ReceiverDpNode, DP_OPRACC_RECEIVER, spdraft, DP_SPDRAFT_OPERATION, err );
          if( ReceiverFaceAccount == "" ) /* Была ошибка */
            if(err == DP_GETACC_ESC) /* прерывание пользователя */
              return err;
            end;
            err = 1;
          end;
        end;
      end;

      if((not err) and (not CheckAcRestWriteOff(@errmsg, PayerFaceAccount, DwNodeID, ReceiverFaceAccount, Pm_paym.ReceiverDpNode, Pm_paym.FIID, carryDate, Pm_paym.Amount)))
        DPError.SetErr( errmsg );
        err = 1;
      end;


      if( (NOT err) AND ( DocCarry( true,                    /* счета проводки - валюта (false - валюта с покрытием)*/                
                                    5,                       /*Глава*/
                                    Pm_paym.FIID,            /*Валюта*/
                                    PayerFaceAccount,        /*Плательшик*/
                                    ReceiverFaceAccount,     /*Получатель*/
                                    Pm_paym.Amount,          /*сколько*/
                                    carryDate,               /*дата*/
                                    0,                       /*Результат проводки*/
                                    ground,
                                    Pm_paym.PaymentID,
                                    PMMET_ID,
                                    accTrn,
                                    18                       /*Шифр операции*/
                                  ) 
                        )
        )
        DPError.SetErr( "Ошибка при вставке проводки" );
        err = 1;
      end;

      /* Обработаем проводки по субсчетам учета Актива в Пассиве */
      if(NOT err)
        if( GetAinPAccState( AinPEnabled ) != 0 )
          err = 1;
        else
          if( AinPEnabled ) /* и включен режим учета Актива в Пассиве */
            if( ExecuteSubAccCarry( false, accTrn.AccTrnID, DwNodeID, BnNodeID, PayerFaceAccount, ReceiverFaceAccount, Pm_paym.FIID, Pm_paym.Amount, carryDate, Pm_paym.PaymentID, DPSubAccData(Pm_paym, spdraft, DP_OPRACC_PAYER, Pm_prop_deb.Corschem) ) )
              err = 1;
            end;
          end;
        end;
      end;

    else /* проводка по Закрытому хранению */

      err = ExecuteIndoorStorageCarry( spdraft, Pm_paym.PaymentID, DwNodeID, BnNodeID, Pm_paym.FIID, carryDate, ground );
      if(err == DP_GETACC_ESC) /* прерывание пользователя */
         return err;
      end;
    end;
  end;

  /*Изменяем статус платежа на "завершенный платеж" */
  RsbPayment( Pm_paym.PaymentID ).PaymStatus = PM_FINISHED;

  if(not err)
    err = DP_RegDraftMagNumber(spdraft_buf.AutoKey);
  end;

  /* осуществляем экспорт в БОЦБ */
  if( (NOT err) and (spdraft_buf.ToBO == "X") )
    err = ExecMacroFile("dpexpsecur.mac", "ExpToSecur", spdraft_buf, Pm_paym);
  end;

  if(not err)
    err = RegAllExtGroundToGrRep(spdraft);
  end;

  if( err )
    err = RejectDepoDraftYesNo( spdraft, DP_SPDRAFT_OPERATION );
  end;

  return err;
END;



MACRO MassExecuteStep()
  var cmd, query, DataSet;
  var r_spdraft= TRecHandler("spdraft.dbt");
  var r_paym   = TRecHandler( "pmpaym.dbt" );  
  var r_debet  = TRecHandler( "pmprop.dbt" );  
  var r_credit = TRecHandler( "pmprop.dbt" );  
  var r_rmprop = TRecHandler( "pmrmprop.dbt" );

  var pmobj = NULL, DwNodeID, BnNodeID, err = 0, stat = 0, ErrStr;
  var OprStatus = 0;
  FILE DepoAcc( depoacnt ) key 2;  /* по короткому коду + номер отделения */
  var CorrAccDpNode = 0;
  var carryDate, AinPEnabled, accTrn, PayerFaceAccount = "", ReceiverFaceAccount = "";
  var ground = "Зачисление безналичных ценных бумаг на счет депонента";
  var errmsg = "";
  
  var batchTrn = DP_BatchPaymTrn();
   

  if(DP_MassCheckRejectedDepoDraft() != 0)
    return 1;
  end;

  if(DP_MassCheckDepoMessage() != 0)
    return 1;
  end;

  if(DP_MassCheckTransitAccount() != 0)
    return 1;
  end;

  if(DP_MassCheckCorschem(true) != 0)
    return 1;
  end;

  if(GetAinPAccState( AinPEnabled ) != 0)
    return 1;
  end;

  var pointName = DP_SqlSavePoint();

  query =   " select dr.*, mv.t_PaymentID, oprtemp.t_ID_Operation, oprtemp.t_ID_Step "
          + "   from DOPRTEMP_VIEW oprtemp, dspdraft_dbt dr, dspdrmove_dbt mv "
          + "  where dr.t_AutoKey = oprtemp.t_OrderID "
          + "    and mv.t_DraftID = dr.t_AutoKey ";

  cmd = DL_RSDCommand(query);
   
  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    stat = 0;
    
    DataSet.GetRecord().CopyTo( r_spdraft.rec );
    
    pmobj = RsbPayment( DataSet.PaymentID );

    Copy(r_paym,   pmobj.GetPM_PAYM());
    Copy(r_rmprop, pmobj.GetPMRMPROP());
    Copy(r_debet,  pmobj.GetDEBET());
    Copy(r_credit, pmobj.GetCREDIT());

    if(Pm_paym.ValueDate<{curdate})
      carryDate = r_paym.rec.ValueDate;
    else
      carryDate = {curdate};
    end;

    DwNodeID = r_paym.rec.PayerDpNode;

    if( r_paym.rec.ReceiverBankID == {OurBank} ) /*счет депонента - депозитарий наш банк*/
       BnNodeID = r_paym.rec.ReceiverDpNode;
    else /*счет депонента - депозитарий НЕ наш банк */
       /* Определим корсчет */
       if( r_credit.rec.Corschem != -1 )
         var AcntNodeID = DP_GetCorAcc( r_credit.rec.Corschem, r_credit.rec.PayFIID );
         if( AcntNodeID == 0 )
           stat = 1;
           DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, "Не найден корреспондентский счет депо" );
         else
           BnNodeID = AcntNodeID;
         end;
       else
         stat = 1;
         DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, "Не задана схема расчетов!" );
       end;
    end;

    if(NOT stat)
      batchTrn.SetContextParams(r_spdraft, NULL, r_paym, r_debet, r_credit, r_rmprop, DataSet.ID_Operation, DataSet.ID_Step);

      if( r_paym.rec.IndoorStorage == 0 ) /* Если проводка по открытому хранению */
        PayerFaceAccount = GetAccountByPart(r_paym.rec.FIID, DwNodeID, r_paym.rec.ValueDate, DP_IIF(r_spdraft.rec.FromTransitAccount == "X", true, false));
        if(PayerFaceAccount == "")
          PayerFaceAccount = InputAccountByDepoAcc( DwNodeID, DP_OPRACC_PAYER, NULL, DP_SPDRAFT_OPERATION, stat, null, DP_IIF(r_spdraft.rec.FromTransitAccount == "X", true, false), batchTrn.DraftAllParms() );
          if( PayerFaceAccount == "" ) /* Была ошибка */
            if(stat == DP_GETACC_ESC) /* прерывание пользователя */
              return stat;
            end;
            stat = 1;
            DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, DPError.GetErr() );
          end;
        end;

        if(NOT stat)
          ReceiverFaceAccount = GetAccountByPart(r_paym.rec.FIID, r_paym.rec.ReceiverDpNode, r_paym.rec.ValueDate);
          if(ReceiverFaceAccount == "")
            ReceiverFaceAccount = InputAccountByDepoAcc( r_paym.rec.ReceiverDpNode, DP_OPRACC_RECEIVER, NULL, DP_SPDRAFT_OPERATION, stat, null, false, batchTrn.DraftAllParms() );
            if( ReceiverFaceAccount == "" ) /* Была ошибка */
              if(stat == DP_GETACC_ESC) /* прерывание пользователя */
                return stat;
              end;
              stat = 1;
              DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, DPError.GetErr() );
            end;
          end;
        end;

        if(not stat)
          stat = batchTrn.AddOneAccTrnByPaym(carryDate, PayerFaceAccount, ReceiverFaceAccount, ground);
          if(stat)
            DP_SetErrorOprTemp( r_paym.rec.PaymentID, stat, "Ошибка при вставке проводки" );        
          end;
        end;

      else /* проводка по Закрытому хранению */

        err = ExecuteIndoorStorageCarry( NULL, r_paym.rec.PaymentID, DwNodeID, BnNodeID, r_paym.rec.FIID, carryDate, ground, batchTrn );
        if(err == DP_GETACC_ESC) /* прерывание пользователя */
           return err;
        end;
      end;
    end;

  end;
  
  if( (not err) and (batchTrn.Execute() != 0))
    err = 1;
  end;
  
  if(not err)
    err = DP_MassChangePaymStatus();
  end;
  
  if(not err)
    err = DP_MassGenerateDraftOprXid();
  end;
  
  if(not err)
    err = DP_MassRegExtGroundToGrRep();
  end;
  
  if(not err)
    err = DP_MassExpToSecur();
  end;

  if(err)
    DP_SqlRollBackPoint(pointName);
    //ставим отметку об ошибке выполнения всем поручениям пачки
    DP_SetErrorOprTemp(0, err, "Ошибка при пакетном выполнении шага");
  end;

  return 0;

OnError(er)
  if((ValType(pointName) != V_UNDEF) and pointName != "")
    DP_SqlRollBackPoint(pointName);
  end;

  DP_SetErrorOprTemp(0, 1, er.module+ " "+er.line+" "+er.message);
  return 0;
END;