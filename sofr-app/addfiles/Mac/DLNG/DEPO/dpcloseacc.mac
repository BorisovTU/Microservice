/*
$Name: dpcloseacc.mac
$Module: Депозитарий
$Description: Процедура закрытия нулевых лицевых счетов депо
*/

import DPInter, "secinter.mac", "dpstdrep.mac", "fi.mac";
import RsbDataSet;

private const SC_SPDRAFT_STATUS_PREP  = 1;  /* отложенное */
private const SC_SPDRAFT_STATUS_OPEN  = 2;  /* открытое   */
private const SC_SPDRAFT_STATUS_CLOSE = 3;  /* закрытое   */

private const CHAPT5 = 5; //глава л/с депо

private const PRT_CLOSEACC   = 1; //строка в протоколе для закрытого счета
private const PRT_NOCLOSEACC = 2; //строка в протоколе для не закрытого счета
private const PRT_CLOSEFI    = 3; //строка в протоколе для закрытого ФИ
private const PRT_NOCLOSEFI  = 4; //строка в протоколе для не закрытого ФИ


private const TRN_STATE_FACT = 1; // состояние проводки - фактическая

PRIVATE CLASS (DL_CReportTemplate) DP_CloseAccRep

  PRIVATE MACRO PrintMode():INTEGER
    return DL_OUTREPORT_EXCEL;
  END;

  PRIVATE MACRO BeginReport()
    CreateTotalBook();
    SetActiveSheet( "Протокол" );
    DP_StdHeaderLO_Ex( null, null, "Протокол процедуры закрытия лицевых счетов с нулевым остатком и финансовых инструментов по НЭЦБ", 0, 0, false, {curdate}, {curdate}, 100, null, null, this, "N1_" );
  END;

  PRIVATE MACRO EndReport()
    SaveTotalBook();
  END;

  PRIVATE MACRO Create()
    var count = DP_ProtocolGetCount(), countacc = 0;
    var StrType;
    var isRegCloseAccTable = false, isRegNoCloseAccTable = false, isRegCloseFITable = false;
    var Account = "", FICode = "", OpenDate = "", BriefCode = "", Reason = "", AvrKindName = "", FIName = "";
    var i = 0;

    if(count > 0)
      InitProgress ( count, "Идет печать протокола...", "Протокол процедуры закрытия лицевых счетов депо и финансовых инструментов");
      while( DP_ProtocolGetNext(2/*сортировка текста asc*/) )
        StrType = DP_ProtocolGetNextFld();

        if(StrType == PRT_CLOSEACC)
          if(isRegCloseAccTable == false)
            CopyAllSheetInTotalBook( NULL, false, "N1_TableCloseAccHeader", 1 );

            RegisterTable( "N1_TableCloseAcc", NULL,
                           "N1_A1",
                           "N1_A2",
                           "N1_A3",
                           "N1_A4"
                        );

            isRegCloseAccTable = true;
          end;

          Account   = DP_ProtocolGetNextFld();
          FICode    = DP_ProtocolGetNextFld();
          OpenDate  = DP_ProtocolGetNextFld();
          BriefCode = DP_ProtocolGetNextFld();

          PrintTableLine( "N1_A1",  Account,   null,
                          "N1_A2",  FICode,    null,
                          "N1_A3",  OpenDate,  null,
                          "N1_A4",  BriefCode, null
                        );

        elif(StrType == PRT_NOCLOSEACC)
          if(isRegNoCloseAccTable == false)
            if(isRegCloseAccTable == true) //завершим предыдущую таблицу
              EndTable();
              CopyAllSheetInTotalBook( NULL, false, GetTableRange(), 0 );
            end;

            CopyAllSheetInTotalBook( NULL, false, "N1_TableNoCloseAccHeader", 1 );

            RegisterTable( "N1_TableNoCloseAcc", NULL,
                           "N1_B1",
                           "N1_B2"
                        );

            isRegNoCloseAccTable = true;
          end;

          Account = DP_ProtocolGetNextFld();
          Reason  = DP_ProtocolGetNextFld();

          PrintTableLine( "N1_B1",  Account,   null,
                          "N1_B2",  Reason,    null
                        );
        elif(StrType == PRT_CLOSEFI)
          if(isRegCloseFITable == false)
            if((isRegCloseAccTable == false) and (isRegNoCloseAccTable == false))
              PrintFormatString( NULL, "N1_MsgNotCloseAcc", "Лицевые счета не закрывались");
              CopyAllSheetInTotalBook( NULL, false, "N1_MsgNotCloseAcc", 0 );
            end;
            
            if((isRegNoCloseAccTable == true) or (isRegCloseAccTable == true)) //завершим предыдущую таблицу
              EndTable();
              CopyAllSheetInTotalBook( NULL, false, GetTableRange(), 0 );
            end;

            CopyAllSheetInTotalBook( NULL, false, "N1_TableCloseFIHeader", 1 );

            RegisterTable( "N1_TableCloseFI", NULL,
                           "N1_C1",
                           "N1_C2",
                           "N1_C3"
                        );

            isRegCloseFITable = true;
          end;

          AvrKindName = DP_ProtocolGetNextFld();
          FICode      = DP_ProtocolGetNextFld();
          FIName      = DP_ProtocolGetNextFld();

          PrintTableLine( "N1_C1",  AvrKindName, null,
                          "N1_C2",  FICode,      null,
                          "N1_C3",  FIName,      null
                        );
        end;

        UseProgress(i = i +1);
      end;

      RemProgress();

      if((isRegNoCloseAccTable == true) or (isRegCloseAccTable == true) or (isRegCloseFITable == true)) //завершим таблицу
        EndTable();
        CopyAllSheetInTotalBook( NULL, false, GetTableRange(), 0 );
      end;
    else
      PrintFormatString( NULL, "N1_MsgNotCloseAcc", "Лицевые счета не закрывались");
      CopyAllSheetInTotalBook( NULL, false, "N1_MsgNotCloseAcc", 0 );  
    end;

    DP_StdAuthPerson_Ex(null, null, this, "N1_");
    DP_StdDeposInfo_Ex(null, null, 0, this, "N1_");
    DP_StdExecReport_Ex(null, null, NULL, NULL, 0, this, "N1_");

  END;

  initDL_CReportTemplate( NULL, "dpcloseacc.xls" );

END;

private macro CheckAdmoprForAccount(acc, CheckDate:date)
  var query, Select, DataSet;
  var cnt = 0;

  query =   " select count(1) as cnt from ddepoadmo_dbt adm "
          + "  where adm.t_AdmoprID = rsb_depo.GetObjNextAdmoprOnDate(0, ? /*1*/, ? /*2*/, ? /*3*/) ";

  Select = RSDCommand( query );

  Select.AddParam("FIID",     RSDBP_IN, acc.rec.Code_Currency );  /*1*/
  Select.AddParam("Account",  RSDBP_IN, acc.rec.Account  );       /*2*/
  Select.AddParam("OperDate", RSDBP_IN, CheckDate        );       /*3*/

  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    cnt = DataSet.cnt;
  end;

  return cnt;
end;

private macro AddAccToProtocol(acc)
  var query, Select, DataSet;
  var BriefCode = "", FICode = "";

  query =   " select acnt.t_BriefCode,"
          + "        ( case when avr.t_LSIN <> CHR(1) THEN avr.t_LSIN "
          + "               when avr.t_ISIN <> CHR(1) THEN avr.t_ISIN "
          + "               when (NOT oc.t_Code IS NULL) AND oc.t_Code <> CHR(1) THEN oc.t_Code "
          + "               else fin.t_FI_Code end) as FICode "
          + "   from daccount_dbt acc, ddepoacnt_dbt acnt, dfininstr_dbt fin, davoiriss_dbt avr, dobjcode_dbt oc "
          + "  where acc.t_AccountID = ? /*1*/"
          + "    and acnt.t_AutoKey (+)= acc.t_DepoAcc " //л/с депо в Главной книге могут быть не привязаны к счетам депо (хотя такого быть не должно)
          + "    and fin.t_FIID = acc.t_Code_Currency "
          + "    and avr.t_FIID = fin.t_FIID "
          + "    and oc.t_ObjectType (+)= " + OBJTYPE_FININSTR
          + "    and oc.t_CodeKind (+)= " + FICK_CFIC
          + "    and oc.t_ObjectID (+)= avr.t_FIID ";

  Select = RSDCommand( query );

  Select.AddParam("AccountID",  RSDBP_IN, acc.rec.AccountID   );  /*1*/
  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    BriefCode = DataSet.BriefCode;
    FICode    = DataSet.FICode;
  end;

  DP_ProtocolAddStr(PRT_CLOSEACC, acc.rec.Account, FICode, string(acc.rec.Open_Date:f), BriefCode);

end;

private macro AddFIToProtocol(fin)
  var query, Select, DataSet;
  var AvrkName = "";

  query =   " select t_Name"
          + "   from davrkinds_dbt "
          + "  where t_FI_Kind = ? "
          + "    and t_AvoirKind = ?";

  Select = DL_RSDCommand( query );

  Select.AddParam(fin.rec.FI_Kind); 
  Select.AddParam(fin.rec.AvoirKind);

  DataSet = Select.Execute();

  if(DataSet.moveNext())
    AvrkName = DataSet.Name;
  end;

  DP_ProtocolAddStr(PRT_CLOSEFI, AvrkName, fin.rec.FI_Code, fin.rec.Name);

end;

// Получить по счету самую позднюю дату проводки, выполненной позднее текущей опердаты, если таковой нет - возвращает текущую дату, чтобы не возникало ошибки
private macro GetFinalDate(acc)
  var query, Select, DataSet;
  var Final_Date = {curdate};

  query =   " SELECT NVL(MAX(t_Date_Carry), TO_DATE('01.01.0001', 'DD.MM.YYYY')) t_Final_Date " +
            "   FROM dacctrn_dbt " +
            "  WHERE ((t_Account_Payer = ? AND t_FIID_Payer = ?) OR (t_Account_Receiver = ? AND t_FIID_Receiver = ?)) " +
            "    AND t_Chapter = ? " +
            "    AND t_State = ? " +
            "    AND t_Date_Carry > ? ";

  Select = RSDCommand( query );

  Select.AddParam("Account_Payer",  RSDBP_IN, acc.rec.Account );
  Select.AddParam("FIID_Payer",  RSDBP_IN, acc.rec.Code_Currency );
  Select.AddParam("Account_Receiver",  RSDBP_IN, acc.rec.Account );
  Select.AddParam("FIID_Receiver",  RSDBP_IN, acc.rec.Code_Currency );
  Select.AddParam("Chapter",  RSDBP_IN, acc.rec.Chapter );
  Select.AddParam("State",  RSDBP_IN, TRN_STATE_FACT );
  Select.AddParam("Date_Carry",  RSDBP_IN, {curdate} );
  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if((DataSet.moveNext()) AND (date(DataSet.Final_Date) != date(0,0,0)) )
    Final_Date = date(DataSet.Final_Date);
  end;

  return Final_Date;
end;

macro CloseZeroAccounts()
  var acc = TRecHandler("account");
  var fin = TRecHandler("fininstr");
  var query, DataSet;
  var CntPrep = 0, CntOpen = 0, CntDraft = 0, CntGlob = 0;
  var mesState = "", mesOpKind = "", mess = "";
  var BegDate = date(0,0,0), EndDate = date(0,0,0);
  var ZeroAccDays:integer = 0, ZeroAccCalend:bool = false;
  var count = 0, i = 0;
  var err = 0;
  var NeedCloseAcc = true;
  var NeedCloseCertFI = true;

  //Если процедура запущена в безынтерфейсном режиме, запрос пользователю не выдаётся, выполняется переход к следующему этапу процедуры
  if( (GetDialogFlag()) and (not IsShedulerRunning()) )
    //2.1.    Выполняется поиск отложенных или открытых поручений на инвентарные операции, глобальных операций "Депозитария",
    //в которых дата валютирования (т.е. дата формирования проводок по лицевым счетам депо) меньше или равна дате запуска процедуры
    query =   " select  "
            + "        (select count(1) from dspdraft_dbt draft "
            + "          where draft.t_Status = "+SC_SPDRAFT_STATUS_PREP
            + "            and draft.t_Date <= " + GetSQLDate({curdate})
            + "        ) as CntDraftPrep, "
            + "        (select count(1) from dspdraft_dbt draft "
            + "          where draft.t_Status = "+SC_SPDRAFT_STATUS_OPEN
            + "            and draft.t_Date <= " + GetSQLDate({curdate})
            + "        ) as CntDraftOpen,"
            + "        (select count(1) from ddpcorpop_dbt crp "
            + "          where crp.t_DocKind in ("+DP_DEPOPER_CONVERT+", "+DP_DEPOPER_REPAY+", "+DP_DEPOPER_BONEMISS+") "
            + "            and crp.t_State = "+SC_SPDRAFT_STATUS_PREP
            + "            and crp.t_ValueDate <= " + GetSQLDate({curdate})
            + "        ) as CntGlobPrep, "
            + "        (select count(1) from ddpcorpop_dbt crp "
            + "          where crp.t_DocKind in ("+DP_DEPOPER_CONVERT+", "+DP_DEPOPER_REPAY+", "+DP_DEPOPER_BONEMISS+") "
            + "            and crp.t_State = "+SC_SPDRAFT_STATUS_OPEN
            + "            and crp.t_ValueDate <= " + GetSQLDate({curdate})
            + "        ) as CntGlobOpen "
            + "   from dual ";

    DataSet = TRsbDataSet(query);
    if((DataSet.moveNext()) and ((DataSet.CntDraftPrep > 0) OR (DataSet.CntDraftOpen > 0) OR (DataSet.CntGlobPrep > 0) OR (DataSet.CntGlobOpen > 0)))
      //2.1.1.    Если такие операции найдены, пользователю выдаётся предупреждение
      CntPrep  = DataSet.CntDraftPrep + DataSet.CntGlobPrep;
      CntOpen  = DataSet.CntDraftOpen + DataSet.CntGlobOpen;
      CntDraft = DataSet.CntDraftPrep + DataSet.CntDraftOpen;
      CntGlob  = DataSet.CntGlobPrep  + DataSet.CntGlobOpen;

      if((CntPrep > 0) and (CntOpen > 0))
        mesState = "отложенные и открытые";
      elif(CntPrep > 0)
        mesState = "отложенные";
      else
        mesState = "открытые";
      end;

      if((CntDraft > 0) and (CntGlob > 0))
        mesOpKind = "инвентарные и глобальные";
      elif(CntDraft > 0)
        mesOpKind = "инвентарные";
      else
        mesOpKind = "глобальные";
      end;

      mess = "Найдены "+mesState+" "+mesOpKind+" операции, которые могут изменить остатки по лицевым счетам за "+string({curdate}:f)+". Запустить процедуру закрытия лицевых счетов и фин. инструментов?";
      if(false == GetTrue(false, mess))
        return; //2.1.1.2.    Если выбран ответ "Нет" - работа процедуры завершается без формирования протокола
      end;
    else
      //2.1.2.  Если операции не найдены, пользователю выдаётся запрос
      mess = "Запустить процедуру закрытия нулевых счетов депо за "+string({curdate}:f)+"?";
      if(false == GetTrue(false, mess))
        //2.1.2.2.  Если получен ответ "Нет", выполняется переход к этапу отбора финансовых инструментов по НЭЦБ
        NeedCloseAcc = false; 
      end;
    end;
  end;

  DP_ProtocolClear();

  DP_StartUseTechAuto(TECHAUTODOC_CLOSEACC);

  EndDate = {curdate}; //окончание периода - дата запуска процедуры

  if(NeedCloseAcc == true)
    //3.  Выполняется отбор открытых лицевых счетов депо, на которых нулевой остаток сохраняется указанное
    //в настройке "Допустимое число дней с нулевым остатком" количество дней.
    //Использовать при вычислениях рабочие или календарные дни - определяется настройкой "Использование календарных дней".
    GetRegistryValue("DEPO\\ZERO_ACC_DAYS", V_INTEGER, ZeroAccDays, err);
    if( err != 0 )
      msgbox("Ошибка поиска значения настройки \"Допустимое число дней с нулевым остатком\"");
      return;
    end;

    GetRegistryValue("DEPO\\ZERO_ACC_CALEND", V_BOOL, ZeroAccCalend, err);
    if( err != 0 )
      msgbox("Ошибка поиска значения настройки \"Использование календарных дней\"");
      return;
    end;

    //Если значение настройки равно нулю - процедурой закрываются все лицевые счета депо, имеющие на момент запуска процедуры нулевой остаток.
    //Если задано число больше нуля - отбираются для закрытия такие лицевые счета, по которым нулевой остаток сохраняется указанное в настройке количество дней

    if(ZeroAccDays == 0)
      //т.о. получается, что в данном случае значение 0 и 1 равноценны, т.к. 0 - закрыть все с нулевым остатком на текущий момент,
      //а 1 - закрыть все, на которых нулевой остаток больше либо равен 1 дню, т.е. опять же как минимум в настоящий момент (т.е. сегодня, 1 день) на счете 0
      ZeroAccDays = 1; //поэтому сделаем так
    end;

    if(ZeroAccCalend == true)
      //использование календарных дней
      BegDate = EndDate - ZeroAccDays + 1; //добавим 1, чтобы не учитывался лишний день
    else
      //использование рабочих дней
      BegDate = GetDateAfterWorkDays(EndDate, -ZeroAccDays + 1); //добавим 1, чтобы не учитывался лишний день
    end;

    query =   " select acc.* "
            + "   from daccount_dbt acc "
            + "  where acc.t_Chapter = " + CHAPT5         //по 5-й главе
            + "    and acc.t_Open_Close = CHR(0) "  //со статусом "Открыт"
            + "    and acc.t_Open_Date <= " + GetSQLDate(BegDate)
            + "    and 0 = rsb_account.restac(acc.t_Account, acc.t_Code_Currency, " + GetSQLDate(EndDate) + ", acc.t_Chapter, null) "
            + "    and 0 = (select NVL(sum(abs(r.t_Rest)), 0) "
            + "               from drestdate_dbt r "
            + "              where r.t_AccountID = acc.t_AccountID "
            + "                and r.t_RestDate >= " + GetSQLDate(BegDate)
            + "                and r.t_RestDate <= " + GetSQLDate(EndDate)
            + "             ) "; //если за каждый день периода не было остатка, то и суммарный остаток по дням этого периода будет нулевым

    count = SQL_GetNRecs(query);
    if( count > 0 )
      InitProgress ( count, "Идет обработка лицевых счетов...", "Процедура закрытия лицевых счетов депо");

      DataSet = TRsbDataSet(query);
      while( DataSet.moveNext() )
        DataSet.GetRecord().CopyTo(acc.rec);

        //4.1.    Если для лицевого счёта существуют АО открытия или закрытия за даты, большие даты запуска процедуры -
        //обработка текущего лицевого счёта прекращается, в протокол ошибок для данного лицевого счёта выводится сообщение
        if(CheckAdmoprForAccount(acc, {curdate})) //есть АО позже даты процедуры
          DP_ProtocolAddStr(PRT_NOCLOSEACC, acc.rec.Account, "Для счёта существуют административные операции за более поздние даты. Счёт не закрыт");
        else
          //4.2.  Если по лицевому счёту существуют проводки в дату, большую даты запуска процедуры,
          //обработка текущего лицевого счёта прекращается, в протокол ошибок выводится сообщения
          if(GetFinalDate(acc) > {curdate}) //проверяем поле "дата последней проводки" из анкеты лицевого счёта
            DP_ProtocolAddStr(PRT_NOCLOSEACC, acc.rec.Account, "Для счёта существуют проводки за более поздние даты. Счёт не закрыт");
          else
            if(CB_CloseAccount(acc.rec.Chapter, acc.rec.Code_Currency, acc.rec.Account) == 0) //успешно закрыли
              AddAccToProtocol(acc);
            else
              DP_ProtocolAddStr(PRT_NOCLOSEACC, acc.rec.Account, "Ошибка при закрытии счета. Счёт не закрыт");
            end;
          end;
        end;

        UseProgress(i = i + 1);
      end;
      RemProgress();
    end;
  end;
  
  GetRegistryValue("DEPO\\CLOSECERTFI", V_BOOL, NeedCloseCertFI, err);
  if( err != 0 )
    NeedCloseCertFI = false;
  end;

  if(NeedCloseCertFI == true)
    mess = "Запустить процедуру закрытия финансовых инструментов по НЭЦБ, снятым с хранения за "+string({curdate}:f)+"?";
    if(false == GetTrue(false, mess))
      NeedCloseCertFI = false; 
    end;
  end;

  if(NeedCloseCertFI == true)
    query =   " select fin.* "
            + "   from dfininstr_dbt fin, davrkinds_dbt avrk "
            + "  where fin.t_IsClosed = CHR(0) "
            + "    and not Exists(select 1 from daccount_dbt acc where acc.t_Code_Currency = fin.t_FIID and acc.t_Open_Close = CHR(0)) "
            + "    and Exists(select 1 from daccount_dbt acc where acc.t_Code_Currency = fin.t_FIID and acc.t_Open_Close <> CHR(0)) "
            + "    and Exists(select 1 from dv_ficert_dbt ficert where ficert.t_FIID = fin.t_FIID )"
            + "    and avrk.t_FI_Kind = fin.t_FI_Kind "
            + "    and avrk.t_AvoirKind = fin.t_AvoirKind "
            + "    and avrk.t_GenNefiMode = 4"; // в разрезе сертификатов

    count = SQL_GetNRecs(query);
    if( count > 0 )
      i = 0;
      InitProgress ( count, "Идет обработка лицевых счетов...", "Процедура закрытия лицевых счетов депо");
      
      DataSet = TRsbDataSet(query);
      while( DataSet.moveNext() )
        DataSet.GetRecord().CopyTo(fin.rec);
        if(FI_CloseAvoirIss( fin ) == 0)
          AddFIToProtocol(fin);
        else
          DP_ProtocolAddStr(PRT_NOCLOSEFI, fin.rec.FIID, "Ошибка при закрытии ФИ. ФИ не закрыт");
        end;
        
        UseProgress(i = i + 1);
      end;
      RemProgress();
    end;
  end;

  DP_EndUseTechAuto();

  if((NeedCloseAcc == true) or (NeedCloseCertFI == true))
    DP_CloseAccRep().Run();
  end;
end;

CloseZeroAccounts();
