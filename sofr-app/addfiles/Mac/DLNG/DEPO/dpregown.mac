/*
$Name:         dpregown.mac
$Module:       Депозитарий
$Description:  Отчет "Список владельцев именных ц/б"
*/
/*
Программист:   Chernov Anton
Создан:        24-01-03
*/

import deposerv, CurrInter, SfInter, CTInter, "pt_lib.mac", "dprstrsc.mac", "spacform.mac", "dlquery.mac";
import RsbDataSet;

private const DP_DEPOPER_DIVIDEND = 4780; // Уведомление о начислении дивидендов

private const PM_PURP_SECUR_INCOME = 45;  // Выплата доходов по цб

private const DepoChapter = 5; // Глава учета ценных бумаг

private const SYS_ANL_AINPACCOUNTING = 2; // Аналитика "Учет актива в пассиве"

private const SIDEBALANCE_ACTIVE     = 1; // Активный

private const DEPOATTR_ATTNUM_BLOCK = 6; /* Блокировка ц/б */

private const PW_OUTPAYMENT   = "O";  // Переводом, внешн.
private const PW_INPAYMENT    = "I";  // Переводом, внутр.
private const PW_CONSOLIDATED = "S";  // Переводом, сводн.

var OwnersLegalList = TArray,
    OwnersHumanList = TArray;

var _group_by_avoir,
    _split_group,
    _show_reg,
    _show_group_total,
    _show_list_total,
    _count_record,
    _show_depoacc,
    is_ap,
    _condition_date,
    _LogoprID,
    DepoAcc_ID;

var OwnerMaxPoint = 0;
var AvoirMaxPoint = 0;
var TotalMaxPoint = 0;

var HeadTableHuman;
var HeadTableLegal;
var tablewidth;
var Rep = CMakeReport();
const RepFontStyleTitel =  "ex_FS(b)";

file depoacnt("depoacnt");

class Owners( _FIID, _OwnerID, _DepoAccID, _Quantity, _BurdenedQuantity )
var FIID,
    OwnerID,
    DepoAccID,
    Quantity,
    BurdenedQuantity;

    FIID     = _FIID;
    OwnerID  = _OwnerID;
    DepoAccID = _DepoAccID;
    Quantity = _Quantity;
    BurdenedQuantity = _BurdenedQuantity;
end;


/* взятие первого элемента списка по выпуску */
macro GetFirstByAvoir( OwnersList, FIID, Elem:Owners )
 var i = 0;

 while ( i < OwnersList.Size )
   
   if ( ( OwnersList[i].FIID > 0 ) and ( ( FIID == -1 ) or ( FIID == OwnersList[i].FIID ) ) )
     Elem = OwnersList[i];
     SetParm( 2, OwnersList[i] );
     OwnersList[i].FIID = -1*OwnersList[i].FIID;
     return true;
   end;

   i = i + 1;
 end;

 return false;
end;

/* взятие след. элемента списка по выпуску */
macro GetNextByAvoir( OwnersList, FIID, Elem:Owners )
 var i = 0;

 while ( i < OwnersList.Size )

   if ( ( OwnersList[i].FIID > 0 ) and ( OwnersList[i].FIID == FIID ) )
     Elem = OwnersList[i];
     SetParm( 2, OwnersList[i] );
     OwnersList[i].FIID = -1*OwnersList[i].FIID;
     return true;
   end;

   i = i + 1;
 end;

 return false;
end;


/* взятие первого элемента списка по владельцу */
macro GetFirstByOwner( OwnersList, OwnerID, DepoAccID, Elem:Owners )
 var i = 0;

 while ( i < OwnersList.Size )

   if ( ( OwnersList[i].OwnerID > 0 ) and 
        ( ( OwnerID == -1 ) or ( OwnerID == OwnersList[i].OwnerID ) ) and 
        ( ( DepoAccID == -1 ) or ( DepoAccID == OwnersList[i].DepoAccID ) ) )
     Elem = OwnersList[i];
     SetParm( 3, OwnersList[i] );
     OwnersList[i].OwnerID = -1*OwnersList[i].OwnerID;
     return true;
   end;

   i = i + 1;
 end;

 return false;
end;

/* взятие след. элемента списка по владельцу */
macro GetNextByOwner( OwnersList, OwnerID, DepoAccID, Elem:Owners )
 var i = 0;

 while ( i < OwnersList.Size )

   if ( ( OwnersList[i].OwnerID > 0 ) and 
        ( OwnersList[i].OwnerID == OwnerID ) and
        ( OwnersList[i].DepoAccID == DepoAccID ) )
     Elem = OwnersList[i];
     SetParm( 3, OwnersList[i] );
     OwnersList[i].OwnerID = -1*OwnersList[i].OwnerID;
     return true;
   end;

   i = i + 1;
 end;

 return false;
end;


macro getIssue( FIID )
  file avoiriss("avoiriss");

  avoiriss.FIID = FIID;
  if ( GetEQ( avoiriss ) )
    return avoiriss.Issue;
  else
    MsgBox("Не найдена ц/б с номером = " + FIID );
  end;

  return "";
end;


/* получить сведения о регистрации субъекта */
macro GetPartyReg( cParty )
  var str = cParty.Name();

  if( _show_reg )
    str = str + "\n" + cParty.PaperKindName() + "\n" + cParty.PaperSeries()  + "\n" + cParty.PaperNumber()
              + "\n" + DateToStr(date(cParty.PaperIssuedDate()), true) + "\n" + cParty.PaperIssuerName();
  end;

  return str;
end;


/* получить страну субъекта */
macro GetPartyICountry( cParty )
  file   country("country","rsrfdb.def") key 2;

  if(cParty.NotResident() == "X" )
    country.CodeLat3 = cParty.NRCountry();
    if( getEQ(country) )
      return country.Name;
    else 
      MsgBox("Не найдена страна с кодом = " + country.CodeLat3 ); 
    end
  else
    return "Россия";
  end;

  return "";
end;

private macro AddElement( stringBuffer, newElement )
 var result:string; 
 if( strlen(stringBuffer) == 0 ) 
   result = newElement;
 else 
   result = stringBuffer + ", " + newElement;
 end;
 return result;
end;

/*****************************************************************************/
private macro MakeAddress( cParty, adress )

  var Result:string = "";
  var Kladr = false, stat, status_ = -1;

  file country("country.dbt") key 2;

  adress.PostIndex = cParty.Index();
  adress.Country = cParty.Country();
  adress.CodeRegion = cParty.Region();
  adress.Region = cParty.RegionName();
  adress.CodeProvince = cParty.CodeProvince();
  adress.Province = cParty.Province();
  adress.CodeDistrict = cParty.CodeDistrict();
  adress.District = cParty.District();
  adress.CodePlace = cParty.CodePlace();
  adress.Place = cParty.Place();
  adress.CodeStreet = cParty.CodeStreet();
  adress.Street = cParty.Street();
  adress.House = cParty.House();
  adress.NumCorps = cParty.NumCorps();
  adress.Flat = cParty.Flat();

 /* 2. Почтовый индекс */
 if( adress.PostIndex != "" ) Result = AddElement( Result, adress.PostIndex ); end;

 /* 3. Название государства */
 if(( adress.Country != "" ) and ( adress.Country != {ResidentCountryCode} ))
    country.CodeLat3 = adress.Country;
    if( GetEQ(country) )
      Result = AddElement( Result, country.Name ); 
    end;
 end;

 /* 4. название региона */
 if(( status_ != 2 ) and ( status_ != 3 ) and ( status_ != 5 ) and ( adress.Region != "" ) and ( adress.CodeRegion != "" )) 
   if(( adress.CodeRegion == "г." ) or ( adress.CodeRegion == "г" ))
     Result = AddElement( Result, adress.CodeRegion + " " + adress.Region ); 
   else
     Result = AddElement( Result, adress.Region + " " + adress.CodeRegion ); 
   end;
 end;

 /* 5. название района */
 if(( status_ != 1 ) and ( status_ != 3 ) and ( status_ != 4 ) and ( status_ != 5 ) and ( adress.Province != "" ) and ( adress.CodeProvince != "" )) 
   if(( adress.CodeProvince == "г." ) or ( adress.CodeProvince == "г" ))
     Result = AddElement( Result, adress.CodeProvince + " " + adress.Province ); 
   else
     Result = AddElement( Result, adress.Province + " " + adress.CodeProvince ); 
   end;
 end;

 /* 6. название города */
 if(( adress.District != "" ) and ( adress.CodeDistrict != "" )) 
   if(( adress.CodeDistrict == "г." ) or ( adress.CodeDistrict == "г" ))
     Result = AddElement( Result, adress.CodeDistrict + " " + adress.District ); 
   else
     Result = AddElement( Result, adress.District + " " + adress.CodeDistrict ); 
   end;
 end;

 /* 7. название населенного пункта */
 if(( adress.Place != "" ) and ( adress.CodePlace != "" )) 
   if(( adress.CodePlace == "г." ) or ( adress.CodePlace == "г" ))
     Result = AddElement( Result, adress.CodePlace + " " + adress.Place ); 
   else
     Result = AddElement( Result, adress.Place + " " + adress.CodePlace ); 
   end;
 end;

 /* 8. Название улицы */
 if(( adress.Street != "" ) and ( adress.CodeStreet != "" )) 
   Result = AddElement( Result, adress.CodeStreet + " " + adress.Street ); 
 end;

 /* 9. Дом, квартира и тд */
 if( adress.House != "" ) 
   Result = AddElement( Result, "д. " + adress.House ); 
 end;
 if( adress.NumCorps != "" ) 
   Result = AddElement( Result, "корп. " + adress.NumCorps ); 
 end;
 if( adress.Flat != "" ) 
   Result = AddElement( Result, "кв. " + adress.Flat ); 
 end;

 adress.adress = Result;
END;


/* получить адрес субъекта */
macro GetPartyAdress( cParty, AdressType )
  record party("party");
  record RecordAdress ( adress );

  ClearRecord(RecordAdress);

  if(AdressType == PTADDR_LEGAL)
    MakeAddress( cParty, RecordAdress );
  else
    RecordAdress.Adress = cParty.Adress();
  end;

  return RecordAdress.Adress;
end;


/* печать общей секции */
macro printCommonSection( ConditionDate, IssuerID, DomiciliateID )
  var i = 0,
      curLen;

  var Nostro;
  var query;
  var buf_str = "", acc_str = "";
  var cDomiciliate, cIssuer;

  Rep.AddEmptyStr();
  cDomiciliate = CDPParty(DomiciliateID, ConditionDate);
  buf_str = "Домицилиат "+ cDomiciliate.ShortName() + " счета НОСТРО в нашей кодировке: ";
  curLen = strlen(buf_str);

  query =   " select distinct t_DepoRoot from daccount_dbt account, ddpreglin_tmp reglin "
          + " where account.t_Account = reglin.t_LAccount ";
  Nostro = TRsbDataSet(query);

  while( Nostro.moveNext() )
    depoacnt.AutoKey = Nostro.DepoRoot;
    if ( getEQ(depoacnt) )
      if(acc_str != "")
        acc_str = acc_str + ", ";
        curLen = curLen + 2;
      end;
      if ( (curLen + strlen( depoacnt.BriefCode ) + 2) > tablewidth )
        acc_str = acc_str + "\n";
        curLen = 0;
      end;
      acc_str = acc_str + depoacnt.BriefCode;
      curLen = curLen + strlen( depoacnt.BriefCode );
    else
      MsgBox( "Не найден счет депо с номером = " + depoacnt.AutoKey );
    end;
    i = i + 1;
  end;
  DP_AddPrintCell( Rep,  buf_str+acc_str, tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
  Rep.AddStr();
  Rep.AddEmptyStr();

  cIssuer = CDPParty(IssuerID, ConditionDate);

  Rep.AddEmptyStr();
  DP_AddPrintCell( Rep,  "Эмитент: " + cIssuer.Name(), tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
  Rep.AddStr();
  DP_AddPrintCell( Rep,  "Юридический адрес: " + GetPartyAdress(cIssuer, PTADDR_LEGAL), tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
  Rep.AddStr();
  DP_AddPrintCell( Rep,  "ИНН: " + cIssuer.CodeINN(), tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
  Rep.AddStr();
end;


private macro GetLenTotal()
  var len_t_n;

  len_t_n = 22+1+15+1+24+1+30; // длина Наименование+Юрисдикция+Адрес+Способ выплаты + разделители
  if(_count_record)
    len_t_n = len_t_n + 5 + 1; // длина № п/п + разделитель
  end;

  if(_show_depoacc)
    len_t_n = len_t_n + 28 + 1; // длина Счет депо + разделитель
  end;

  return len_t_n;
end;


private macro GetLenTotalAmount()
  var len_t = 16; // длина Количество

 return len_t;
end;

private macro GetLenTotalBurdened()
  var len_t = 18; // длина Обременено

 return len_t;
end;


/* печать одного выпуска */
macro printOneAvoirissection( FIIDfrom, Elem : Owners, condition_date )
   var FIID, lsin, avoiriss, issue, code_currency, FaceValue, Quantity:double = 0.0, BurdenedQuantity:double = 0.0;
   var point = AVOIRISS_SUM_PRECISION;
   record fins("fininstr");

   if ( Elem != null )
     FIID = abs(Elem.FIID);
     Quantity = double(Elem.Quantity);
     BurdenedQuantity = double(Elem.BurdenedQuantity);
   else
     FIID = FIIDfrom;
   end;

   lsin = GetFICode( FIID, null, FICK_LSIN );
   avoiriss = getAVOIRISS( FIID );
   issue = getIssue( FIID );

   if ( not ПолучитьФинИн( FIID, fins ) )
     code_currency = GetFICode( fins.FaceValueFI, null, FICK_ISOSTRING );
     point = fins.SumPrecision;

     if(OwnerMaxPoint < point)
       OwnerMaxPoint = point;
     end;
   else
     code_currency = "";
   end;

   FaceValue = GetFaceValue(FIID, condition_date);

   if ( Elem != null )
     DP_AddPrintCell( Rep,  lsin, 15, 0, "l:" + RepFontStyleTitel + "ex_B(l)", is_ap, REP_ELEM_STR );
   else
     DP_AddPrintCell( Rep,  lsin, 15, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   end;
   DP_AddPrintCell( Rep,  " ", 1, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  avoiriss, 20, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  " ", 1, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  issue, 5, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  "  ", 2, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  FaceValue, 19, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  " ", 1, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   DP_AddPrintCell( Rep,  code_currency, 3, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
   if ( Elem != null )
     DP_AddPrintCell( Rep,  " ", GetLenTotal()-(15+1+20+1+5+2+19+1+3)+1, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  Quantity, 17, DP_GetPrecision(Quantity, point), "r:" + RepFontStyleTitel + "ex_B(rl)", is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  BurdenedQuantity, 19, DP_GetPrecision(BurdenedQuantity, point), "r:" + RepFontStyleTitel + "ex_B(rl)", is_ap, REP_ELEM_STR );
   end;
   Rep.AddStr();
end;


/* печать секции выпусков */
macro printAvoirissection(condition_date)
   var query, Avoir;
   var reglin = TBFile("dpreglin.tmp");

   query = " select distinct t_FIIDFrom from ddpreglin_tmp ";
   if(DepoAcc_ID > 0)
     query = query + " Where t_HolderAccID =  " + DepoAcc_ID;
   end;        

   Avoir = TRsbDataSet(query);

   if ( reglin.nrecords > 0 )
     Rep.AddEmptyStr();
     DP_AddPrintCell( Rep,  "Выпуски:", 10, 0, "l:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     Rep.AddStr();
     //DP_AddPrintCell( Rep,  "LSIN           Вид ц/б              Выпуск Номинал             Валюта ", tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  "LSIN", 15, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  "Вид ц/б", 21, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  "Выпуск", 7, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  "Номинал", 20, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  "Валюта", 7, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
     Rep.AddStr();
   end;

   while ( Avoir.moveNext() )
     printOneAvoirissection( Avoir.FIIDfrom, null, condition_date );
   end;
end;


// Получить данные СПИ по выплате дивидендов для заданных Счета (договора обслуживания), Эмитента, Вида ц/б, самой ц/б
private macro GetSettAccbyDLSSI(DepoAccID, 
                                Issuer, 
                                AvoirKind, 
                                FIID,
                                Account:@variant, 
                                BankID:@variant, 
                                BankCode:@variant, 
                                BankCodeKind:@variant, 
                                CorrAcc:@variant
                               )
  var query, DataSet;
  var Select;
  var stat = false;
  Select = DL_RSDCommand();

  query = " SELECT sa.t_Account Account, sa.t_BankID BankID, sa.t_BankCode BankCode, sa.t_BankCodeKind BankCodeKind, sa.t_CorrAcc CorrAcc " +
          "   FROM dsettacc_dbt sa " +
          "  WHERE sa.t_settaccid = " +
          "          (SELECT t_settaccid " +
          "             FROM (SELECT si.t_settaccid " +
          "           FROM ddlssi_dbt si, ddepoacnt_dbt ac, dsfcontr_dbt sf " +
          "          WHERE ac.t_AutoKey = ? " +
          "            AND sf.t_ServKind = " + PTSK_DEPOS + // PTSK_DEPOS = 7 вид обслуживания Депозитарное
          "            AND sf.t_ObjectType = " + SF_DEPOACC + // SF_DEPOACC = 2 объект договора счет депо
          "            AND sf.t_FIID = 0 " + // ФИ для договора депо не задается
          "            AND sf.t_Object = ac.t_Code " +
          "            AND si.t_ConID = sf.t_ID ";

  Select.AddParam(DepoAccID);

  if(Issuer)
    query = query + " AND si.t_Issuer = ? ";
    Select.AddParam(Issuer);
  end;

  if(AvoirKind != -1)
    query = query + " AND si.t_AvoirKind = ? ";
    Select.AddParam(AvoirKind);
  end;

  if(FIID)
    query = query + " AND si.t_FIID = ? ";
    Select.AddParam(FIID);
  end;

  query = query + "      ORDER BY si.t_Order ) " +
                  " WHERE ROWNUM <= 1 ) ";

  DataSet = Select.Execute(query);

  if(DataSet.moveNext())
    Account = string(DataSet.Account);
    BankID = DataSet.BankID;
    BankCode = string(DataSet.BankCode);
    BankCodeKind = DataSet.BankCodeKind;
    CorrAcc = string(DataSet.CorrAcc);
    stat = true;
  end;

  return stat;
end;


private macro DefineSutableSSI(FIID, 
                               Issuer, 
                               OwnerID, 
                               OwnerShortName,
                               DepoAccID, 
                               Account:@variant, 
                               BankID:@variant, 
                               BankCode:@variant, 
                               BankCodeKind:@variant, 
                               CorrAcc:@variant,
                               PaymentWay:@variant
                              )
  var stat = true, found, PW = "";
  var query, DataSet, subquery;
  var Select;
  var NumFI = 1, IsOneRootAvrk = true;

  Account = "";
  BankID = UnknownParty;
  BankCode = "";
  BankCodeKind = PTCK_ALL;
  CorrAcc = "";
  PaymentWay = "";

  if(NOT DepoAccID) // Счет депо не задан (вывод по депонентам), проверим, может быть у него всего один счет в реестре
    Select = DL_RSDCommand();

    query = " SELECT DISTINCT rl.t_HolderAccID DepoAccID " +
            "   FROM ddpreglin_tmp rl " +
            "  WHERE rl.t_HolderID = ? /*1*/ ";

    Select.AddParam(OwnerID);

    DataSet = Select.Execute(query);

    if(DataSet.moveNext())
      DepoAccID = DataSet.DepoAccID; // Если счет окажется единственным - будем искать СПИ по его договору
    else
      // Хотя бы один счет должен был быть
      MsgBox("Для депонента " + OwnerShortName + " не найдено ни одного счета депо");
      stat = false;
    end;

    // Если у депонента больше одного счета - не знаем по какому договору СПИ брать
    if(DataSet.moveNext())
      MsgBox("У депонента " + OwnerShortName + " открыто несколько счетов депо. Невозможно однозначно определить СПИ для выплаты дивидендов.");
      stat = false;
    end;
  end;

  if((stat) AND (DepoAccID))
    Select = DL_RSDCommand();

    query = " select NVL(tac.t_Type_Account, CHR(0)) PW, NVL(tac.t_contens, CHR(1) ) PaymentWay, ac.t_BriefCode BriefCode " +
            " from dtypeac_dbt tac, ddepoacnt_dbt ac " +
            " where tac.t_INUMTYPE(+) = " + TA_INC_DEL +
            "   and tac.t_Type_Account(+) = ac.t_DIDELIVERY " +
            "   and ac.t_AutoKey = ? ";

    Select.AddParam(DepoAccID);

    DataSet = Select.Execute(query);

    if(DataSet.moveNext())
      PW = string(DataSet.PW);
      PaymentWay = string(DataSet.PaymentWay);
      
      if(PW == "")
        MsgBox("У счета депо " + string(DataSet.BriefCode) + " не задан способ выплаты доходов по умолчанию.");
        stat = false; // способ выплат не задан, платежные реквизиты не нужны
      elif((PW != PW_INPAYMENT) AND (PW != PW_OUTPAYMENT) AND (PW != PW_CONSOLIDATED))
        stat = false; // не банковские переводы, платежные реквизиты не нужны
      end;
    else
      MsgBox("Ошибка поиска способа выплаты доходов по умолчанию для счета депо с ID = " + DepoAccID);
      stat = false; 
    end;
  end;

  if((stat) AND (FIID == ALLFININSTR)) // ц/б не задана - посмотрим сколько их на счете и какие они
    Select = DL_RSDCommand();

    query = " SELECT COUNT(fi.t_FIID) NumFI, ak.t_Root RootAvoirKind " +
            "   FROM dfininstr_dbt fi, davrkinds_dbt ak " +
            "  WHERE fi.t_FIID IN ( SELECT DISTINCT rl.t_FIIDFrom " +
            "                         FROM ddpreglin_tmp rl " +
            "                        WHERE rl.t_HolderAccID = ? " +
            "                     ) " +
            "    AND ak.t_FI_Kind = fi.t_FI_Kind " +
            "    AND ak.t_AvoirKind = fi.t_AvoirKind " +
            "  GROUP BY ak.t_Root ";

    Select.AddParam(DepoAccID);

    DataSet = Select.Execute(query);

    if(DataSet.moveNext())
      NumFI = DataSet.NumFI; // Если первый корневой вид ц/б окажется единственным - будем смотреть сколько ФИ с ним у депонента
    else
      // Хотя бы один вид ц/б должен был быть
      MsgBox("Для депонента " + OwnerShortName + " не найдено ни одного вида ц/б");
      stat = false;
    end;

    if(DataSet.moveNext())
      IsOneRootAvrk = false; // Коренных видов ц/б больше одного
    else
      if(NumFI == 1)
        // Определим единственную ФИ
        Select = DL_RSDCommand();

        query = " SELECT DISTINCT rl.t_FIIDFrom FIID " +
                "   FROM ddpreglin_tmp rl " +
                "  WHERE rl.t_HolderAccID = ? ";

        Select.AddParam(DepoAccID);

        DataSet = Select.Execute(query);

        if(DataSet.moveNext())
          FIID = DataSet.FIID;
        else
          MsgBox("Для счета c ID " + DepoAccID + " депонента " + OwnerShortName + " не найден ФИ");
          stat = false;
        end;
      end;
    end;
  end;

  if(stat)
    found = false;

    if(IsOneRootAvrk)
      if(NumFI > 1) // ц/б много, но они одного коренного вида, ищем СПИ по всем _общим_ нижележащим узлам этого коренного, начиная от первого общего родителя снизу вверх к корню

        Select = DL_RSDCommand();

        subquery = " SELECT DISTINCT fi.t_AvoirKind t_AvoirKind " +
                   "   FROM dfininstr_dbt fi " +
                   "  WHERE fi.t_FIID IN ( SELECT DISTINCT rl.t_FIIDFrom " +
                   "                        FROM ddpreglin_tmp rl " +
                   "                       WHERE rl.t_HolderAccID = ? ) ";

        query = " WITH Q AS ( select t_AvoirKind, COUNT(DISTINCT t_AvoirKind) OVER () t_Cnt from ( " + subquery + " ) ) " +
                " SELECT ak.t_AvoirKind, MIN(LEVEL) t_Lev, COUNT(*) FROM davrkinds_dbt ak " +
                " WHERE ak.t_FI_Kind = " + FIKIND_AVOIRISS + 
                " START WITH ak.t_FI_Kind = " + FIKIND_AVOIRISS + " AND ak.t_AvoirKind IN ( SELECT t_AvoirKind FROM Q ) " +
                " CONNECT BY PRIOR ak.t_Parent = ak.t_AvoirKind AND PRIOR ak.t_FI_Kind = ak.t_FI_Kind " +
                " GROUP BY ak.t_AvoirKind " +
                " HAVING COUNT(*) = ( SELECT t_Cnt FROM Q WHERE ROWNUM = 1 ) " +
                " ORDER BY t_Lev ";

        Select.AddParam(DepoAccID); // для подзапроса

        DataSet = Select.Execute(query);

        while((NOT found) AND (DataSet.moveNext()))
          // ищем для заданного счета депо, эмитента, вида ц/б без самой ц/б
          found = GetSettAccbyDLSSI(DepoAccID, Issuer, DataSet.AvoirKind, ALLFININSTR, @Account, @BankID, @BankCode, @BankCodeKind, @CorrAcc);
        end;

      else // ц/б одна 
        // Ищем СПИ в рамках этой ц/б
        // Выбираем все виды ц/б от ФИ и до корневого
        Select = DL_RSDCommand();

        query = " SELECT ak.t_AvoirKind AvoirKind " + 
                "   FROM davrkinds_dbt ak " +
                "  WHERE ak.t_FI_Kind = " + FIKIND_AVOIRISS + 
                "  START WITH ak.t_AvoirKind = (SELECT fi.t_AvoirKind FROM dfininstr_dbt fi WHERE fi.t_FIID = ? ) " +
                "CONNECT BY ak.t_AvoirKind = PRIOR ak.t_Parent " + 
                "  ORDER BY ak.t_Root, ak.t_Parent DESC ";

        Select.AddParam(FIID);

        DataSet = Select.Execute(query);

        while((NOT found) AND (DataSet.moveNext()))
          // ищем для заданного счета депо, эмитента, вида ц/б и самой ц/б
          found = GetSettAccbyDLSSI(DepoAccID, Issuer, DataSet.AvoirKind, FIID, @Account, @BankID, @BankCode, @BankCodeKind, @CorrAcc);

          if(NOT found) // ищем для заданного счета депо, эмитента, вида ц/б без самой ц/б
            found = GetSettAccbyDLSSI(DepoAccID, Issuer, DataSet.AvoirKind, ALLFININSTR, @Account, @BankID, @BankCode, @BankCodeKind, @CorrAcc);
          end;

          if(NOT found) // ищем для заданного счета депо, без эмитента, вида ц/б без самой ц/б
            found = GetSettAccbyDLSSI(DepoAccID, UnknownParty, DataSet.AvoirKind, ALLFININSTR, @Account, @BankID, @BankCode, @BankCodeKind, @CorrAcc);
          end;
        end;
      end;
    end;

    // Если ничего выше не нашли или у счета несколько ц/б различных коренных видов - ищем совсем общие
    if(NOT found) // ищем для заданного счета депо, эмитента
      found = GetSettAccbyDLSSI(DepoAccID, Issuer, FIKIND_ALLAVOIRISS, ALLFININSTR, @Account, @BankID, @BankCode, @BankCodeKind, @CorrAcc);
    end;
    
    if(NOT found) // последняя попытка, ищем для заданного счета депо
      found = GetSettAccbyDLSSI(DepoAccID, UnknownParty, FIKIND_ALLAVOIRISS, ALLFININSTR, @Account, @BankID, @BankCode, @BankCodeKind, @CorrAcc);
    end;
  end;

  return stat;
end;


/* печать секции владельцев */
macro printOwnersSection( condition_date, issuer_id, Elem, iCount )
  var HolderName = "",
      name_reg   = "",
      INN        = "",
      legal_adress     = "",
      post_adress     = "",
      adress = "",
      Account    = "",
      Acc = "",
      BankID = UnknownParty,
      Quantity, BurdenedQuantity, 
      BankCode = "",
      BankCodeKind = PTCK_BIC,
      CorrAcc = "",
      PaymentWay = "";
  var DataSet, query, Select;
  var point = AVOIRISS_SUM_PRECISION;
  record fins("fininstr");
  var cParty = CDPParty(abs(Elem.OwnerID), condition_date);
  var cDepoAcc;
  var stat;

  name_reg = GetPartyReg( cParty );
  INN      = GetPartyICountry( cParty ) + "\n" + cParty.CodeINN();
  legal_adress  = GetPartyAdress( cParty, PTADDR_LEGAL );
  post_adress   = GetPartyAdress( cParty, PTADDR_POST);

  if(_group_by_avoir)
    stat = DefineSutableSSI(abs(Elem.FIID), 
                            issuer_id, 
                            abs(Elem.OwnerID), 
                            cParty.ShortName(), 
                            abs(Elem.DepoAccID), 
                            @Acc, 
                            @BankID, 
                            @BankCode, 
                            @BankCodeKind, 
                            @CorrAcc,
                            @PaymentWay
                           );
  else
    stat = DefineSutableSSI(ALLFININSTR, 
                            issuer_id, 
                            abs(Elem.OwnerID), 
                            cParty.ShortName(), 
                            abs(Elem.DepoAccID), 
                            @Acc, 
                            @BankID, 
                            @BankCode, 
                            @BankCodeKind, 
                            @CorrAcc,
                            @PaymentWay
                           );
  end;
  
  Account = PaymentWay;

  if(stat) // Искали СПИ, значит банковские переводы
    if(Acc != "") // И нашли
      if(BankCode == "")
        if(BankCodeKind == PTCK_ALL)
          BankCodeKind = PTCK_BIC;
        end;
        BankCode = ПолучитьКодСубъекта(BankID, BankCodeKind);
      end;

      Account = Account + "\n" + Acc + " в " +
                GetPartyShortName( BankID ) + " БИК " + BankCode + " к/с " + CorrAcc;
    end;
  end;

  if( _group_by_avoir )
    Quantity = double(Elem.Quantity);
    BurdenedQuantity = double(Elem.BurdenedQuantity);
    if( not ПолучитьФинИн( abs(Elem.FIID), fins ) )
      point = fins.SumPrecision;
    end;

    if(OwnerMaxPoint < point)
      OwnerMaxPoint = point;
    end;
  else
    Quantity = "";
    BurdenedQuantity = "";
  end;

  adress = legal_adress+"\n\n"+post_adress;



  if ( _count_record )
    DP_AddPrintCell( Rep,  (iCount)+".", 5, 0, "c:" + RepFontStyleTitel );
  end;
  DP_AddPrintCell( Rep,  name_reg, 22, 0, "l:w:" + RepFontStyleTitel );
  DP_AddPrintCell( Rep,  INN, 15, 0, "l:w:" + RepFontStyleTitel );
  DP_AddPrintCell( Rep,  adress, 24, 0, "l:w:" + RepFontStyleTitel );
  DP_AddPrintCell( Rep,  Account, 30, 0, "l:w:" + RepFontStyleTitel );
  if(_show_depoacc)
    cDepoAcc = DepoInfo(Elem.DepoAccID, condition_date);
    DP_AddPrintCell( Rep, cDepoAcc.DepoRec.BriefCode+"\n"+cDepoAcc.DepoRec.Name, 28, 0, "l:w:" + RepFontStyleTitel );
  end;
  DP_AddPrintCell( Rep,  Quantity, GetLenTotalAmount(), DP_GetPrecision(Quantity, point), "r:" + RepFontStyleTitel, is_ap );
  DP_AddPrintCell( Rep,  BurdenedQuantity, GetLenTotalBurdened(), DP_GetPrecision(Quantity, point), "r:" + RepFontStyleTitel, is_ap );
  Rep.AddStr();

end;


/* печать итогов по физ./юр. лицам */
macro printTotalSection( islegal, TotalQuantity:double, TotalBurdenedQuantity:double, iCount )
  var name_legal;

  if( not islegal )
    name_legal = "физическим";
  else
    name_legal = "юридическим";
  end;

  DP_AddPrintCell( Rep,  "Итого по " + name_legal + " лицам\n" + iCount, GetLenTotal(), 0, "l:" + RepFontStyleTitel );
  DP_AddPrintCell( Rep,  TotalQuantity, GetLenTotalAmount(), DP_GetPrecision(TotalQuantity,OwnerMaxPoint), "r:" + RepFontStyleTitel, is_ap );
  DP_AddPrintCell( Rep,  TotalBurdenedQuantity, GetLenTotalBurdened(), DP_GetPrecision(TotalBurdenedQuantity,OwnerMaxPoint), "r:" + RepFontStyleTitel, is_ap );
  Rep.AddStr();

end;


/* печать итогов по выпуску */
macro printAvoirTotalSection( TotalAvoiriss:double, TotalBurdenedQuantity:double, iCount )

  DP_AddPrintCell( Rep,  "Итого по выпуску\n" + iCount, GetLenTotal(), 0, "l:" + RepFontStyleTitel );
  DP_AddPrintCell( Rep,  TotalAvoiriss, GetLenTotalAmount(), DP_GetPrecision(TotalAvoiriss, AvoirMaxPoint), "r:" + RepFontStyleTitel, is_ap );
  DP_AddPrintCell( Rep,  TotalBurdenedQuantity, GetLenTotalBurdened(), DP_GetPrecision(TotalBurdenedQuantity, AvoirMaxPoint), "r:" + RepFontStyleTitel, is_ap );
  Rep.AddStr();

end;


/* печать итогов по списку */
macro printTotalListSection( TotaliList, TotalBurdenedQuantity:double, TotalList:double )

  DP_AddPrintCell( Rep,  "Итого по списку\n" + TotaliList, GetLenTotal(), 0, "l:" + RepFontStyleTitel );
  DP_AddPrintCell( Rep,  TotalList, GetLenTotalAmount(), DP_GetPrecision(TotalList, TotalMaxPoint), "r:" + RepFontStyleTitel, is_ap );
  DP_AddPrintCell( Rep,  TotalBurdenedQuantity, GetLenTotalBurdened(), DP_GetPrecision(TotalBurdenedQuantity, TotalMaxPoint), "r:" + RepFontStyleTitel, is_ap );
  Rep.AddStr();

end;


private macro InsertOrUpdate(arr, add)
  var i = 0, found = -1;

  while((i < arr.Size) AND (found == -1))
    if((arr(i).FIID == add.FIID) AND
       (arr(i).OwnerID == add.OwnerID) AND
       (arr(i).DepoAccID == add.DepoAccID))
      found = i;
    else
      i = i + 1;
    end;
  end;

  if(found != -1) // Такая запись есть, нужно просто увеличить сумму ФИ у владельца на счете депо
    arr(found).Quantity = arr(found).Quantity + add.Quantity;
    arr(found).BurdenedQuantity = arr(found).BurdenedQuantity + add.BurdenedQuantity;
  else // Такой комбинации нет - вставляем новую запись
    arr(arr.Size) = add;
  end;

end;

/* заполнение списка владельцев */
macro AddOwner( Account, FIID, condition_date, Quantity, BurdenedQuantity )
  file account_t("account") key 0;
  record party("party");
  var    Add : Owners;

  account_t.Chapter       = DepoChapter;
  account_t.Account       = Account;
  account_t.Code_Currency = FIID;
  if ( ( getEQ(account_t) ) and ( account_t.Open_Date <= condition_date ) )

    if ( ПолучитьСубъекта( account_t.Client, party ) )
      MsgBox("Не найден субъект с номером = " + account_t.Client );
      ClearRecord(party);
    end;
    if(_show_depoacc)
      Add = Owners( account_t.Code_Currency, account_t.Client, account_t.DepoRoot, Quantity, BurdenedQuantity );
    else
      Add = Owners( account_t.Code_Currency, account_t.Client,                  0, Quantity, BurdenedQuantity );
    end;
    if ( party.LegalForm == PTLEGF_PERSN )
      InsertOrUpdate(OwnersHumanList, Add);
    else
      InsertOrUpdate(OwnersLegalList, Add);
    end;
  else
    MsgBox( "не найден лицевой счет " + Account );
  end;
end;


/* формирование списка владельцев выпусков */
macro FillPassiveList( condition_date, Progress )
  var iCount = 0,
      stat,
      sub_stat,
      Quantity = $0;
  var cmd, query, BurdenedQuantity = 0.0;

  var reglin, Select, SqlQuery;             //DataSet
  SqlQuery = "Select * from ddpreglin_tmp where t_hrest > 0 ";
  if(DepoAcc_ID > 0)
   SqlQuery = SqlQuery + " And t_HolderAccID =  " + DepoAcc_ID;
  end;        
  Select = RSDCommand( SqlQuery );

  Select.Execute();                                                               
  reglin = TRSBDataSet(Select);       //DataSet
  while(reglin.MoveNext())

      BurdenedQuantity = 0.0;

      query =   " select 1"
              + "   from ddepoatvl_dbt atvl, dllclsval_dbt clsval "
              + "  where atvl.t_ID = ? "
              + "    and atvl.t_IsType = CHR(0) "
              + "    and atvl.t_AttrNum = " + DEPOATTR_ATTNUM_BLOCK
              + "    and clsval.t_Classificator = " + LLCLASS_KIND_BLOCK_CB_BURDENED
              + "    and TO_CHAR(clsval.t_Element) = atvl.t_Value ";

      cmd = DL_RSDCommand(query);

      cmd.AddParam(reglin.HolderPartID);

      if(cmd.GetCount() > 0)
        BurdenedQuantity = reglin.HRest;
      end;

      AddOwner( reglin.HAccount, reglin.FIIDfrom, condition_date, reglin.HRest, BurdenedQuantity );
    iCount = Progress.Use();
  end;
  return iCount;
end;

/* печать отчета с группировкой по выпускам */
macro PrintByAvoirGroup(
                         condition_date   : date,
                         issuer_id        : integer,
                         domiciliate_id   : integer
                       )
  var stat,
      i = 0,
      TotalQuantity = 0,
      TotalBurdenedQuantity = 0,
      TotalAvoiriss = 0,
      TotalList     = 0, TotalBurdenedList = 0,
      TotaliAvoir   = 0,
      Elem : Owners,
      IsHumanAbsent = false,
      FIID,
      IsPrintedHead = false;

  
  /*переберем всех физ. лиц */  
  stat = GetFirstByAvoir( OwnersHumanList, -1, Elem );
  if ( ( not stat ) and ( OwnersLegalList.Size > 0 ) )
    IsHumanAbsent = true; /* физ. лиц нет, попробуем распечатать юр. лиц */
    stat = GetFirstByAvoir( OwnersLegalList, -1, Elem );
  end;
  TotalMaxPoint = 0;
  while ( stat )
    Rep.AddEmptyStr();
    Rep.AddEmptyStr();
    DP_AddPrintCell( Rep,  "Владельцы ц/б выпуска " + GetFICode( abs(Elem.FIID), null, FICK_LSIN ), tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
    Rep.AddStr();
    TotaliAvoir = 0;
    if ( stat and ( not IsHumanAbsent ) )
      Rep.AddEmptyStr();
      if ( _split_group )
        DP_AddPrintCell( Rep,  "Физические лица", tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
        Rep.AddStr();
        Rep.AutoScan("[\n"+HeadTableHuman+"]" );
      end;
    end;
    TotalQuantity = 0;
    TotalBurdenedQuantity = 0;
    OwnerMaxPoint = 0;
    AvoirMaxPoint = 0;
    i = 0;
    while ( stat and ( not IsHumanAbsent ) ) 
      // Если отчет без разбивки по формам субъектов - общий список выводится с заголовком для юридических лиц
      if((NOT _split_group) AND (NOT IsPrintedHead))
        Rep.AutoScan("[\n"+HeadTableLegal+"]" );
        IsPrintedHead = true;
      end;
      i = i + 1;
      printOwnersSection( condition_date, issuer_id, Elem, i );
      TotalQuantity = TotalQuantity + Elem.Quantity;
      TotalBurdenedQuantity = TotalBurdenedQuantity + Elem.BurdenedQuantity;
      TotalBurdenedList = TotalBurdenedList + Elem.BurdenedQuantity;
      TotalAvoiriss = TotalAvoiriss + Elem.Quantity;
      TotaliAvoir = TotaliAvoir + 1;
      stat = GetNextByAvoir( OwnersHumanList, abs(Elem.FIID), Elem );
    end;
    if ( _show_group_total and _split_group and ( TotalQuantity > 0 ) )
      printTotalSection( false, TotalQuantity, TotalBurdenedQuantity, i );
    end;

    if(AvoirMaxPoint < OwnerMaxPoint)
      AvoirMaxPoint = OwnerMaxPoint;
    end;

    /* переберем всех юр. лиц по тому же выпуску */ 
    if ( IsHumanAbsent )
      FIID = -1;
      IsHumanAbsent = false;
    else
      FIID = abs(Elem.FIID);
      stat = GetFirstByAvoir( OwnersLegalList, FIID, Elem );
    end;
    if ( stat ) 
      if ( _split_group )
        Rep.AddEmptyStr();
        DP_AddPrintCell( Rep,  "Юридические лица", tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
        Rep.AddStr();
        Rep.AutoScan("[\n"+HeadTableLegal+"]" );
        i = 0;
      end;
    end;
    TotalQuantity = 0;
    TotalBurdenedQuantity = 0;
    while ( stat ) 
      // Если отчет без разбивки по формам субъектов - общий список выводится с заголовком для юридических лиц
      if((NOT _split_group) AND (NOT IsPrintedHead))
        Rep.AutoScan("[\n"+HeadTableLegal+"]" );
        IsPrintedHead = true;
      end;
      i = i + 1;
      printOwnersSection( condition_date, issuer_id, Elem, i );
      TotalQuantity = TotalQuantity + Elem.Quantity;
      TotalBurdenedQuantity = TotalBurdenedQuantity + Elem.BurdenedQuantity;
      TotalAvoiriss = TotalAvoiriss + Elem.Quantity;
      TotalBurdenedList = TotalBurdenedList + Elem.BurdenedQuantity;
      TotaliAvoir = TotaliAvoir + 1;
      stat = GetNextByAvoir( OwnersLegalList, abs(Elem.FIID), Elem );
    end;
    if ( _show_group_total and _split_group and ( TotalQuantity > 0 ) )
      printTotalSection( true, TotalQuantity, TotalBurdenedQuantity, i );
    end;

    if(AvoirMaxPoint < OwnerMaxPoint)
      AvoirMaxPoint = OwnerMaxPoint;
    end;

    printAvoirTotalSection( TotalAvoiriss, TotalBurdenedQuantity, TotaliAvoir );
    TotalList = TotalList + TotalAvoiriss;
    TotalAvoiriss = 0;

    stat = GetFirstByAvoir( OwnersHumanList, -1, Elem );/*берем следующий выпуск */
    if ( ( not stat ) and ( OwnersLegalList.Size > 0 ) )
      IsHumanAbsent = true; /* физ. лиц нет, попробуем распечатать юр. лиц */
      stat = GetFirstByAvoir( OwnersLegalList, -1, Elem );
    end;
    IsPrintedHead = false;

    if(TotalMaxPoint < OwnerMaxPoint)
      TotalMaxPoint = OwnerMaxPoint;
    end;
  end;

  if ( _show_list_total and ( (OwnersLegalList.Size + OwnersHumanList.Size) > 0 ) )
    printTotalListSection( OwnersLegalList.Size + OwnersHumanList.Size, TotalBurdenedList, TotalList );
  end;

end;

/* печать отчета без группировки по выпускам */
macro PrintByAvoirUnGroup(
                           condition_date   : date,
                           issuer_id        : integer,
                           domiciliate_id   : integer
                         )
  var stat,
      i = 0,
      TotalQuantity = 0,
      TotalBurdenedQuantity = 0,
      TotalList     = 0, TotalBurdenedList = 0,
      TotaliList    = 0,
      addNum        = false,
      IsPrintedHead = false,
      Elem : Owners;

  /* переберем всех физ. лиц */  
  stat = GetFirstByOwner( OwnersHumanList, -1, -1, Elem );
  if ( stat )
    Rep.AddEmptyStr();
    if ( _split_group )
      DP_AddPrintCell( Rep,  "Физические лица", tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
      Rep.AddStr();
      Rep.AutoScan("[\n"+HeadTableHuman+"]" );
    end;
  end;
  TotalQuantity = 0;
  TotalBurdenedQuantity = 0;
  OwnerMaxPoint = 0;
  while ( stat )
    // Если отчет без разбивки по формам субъектов - общий список выводится с заголовком для юридических лиц
    if((NOT _split_group) AND (NOT IsPrintedHead))
      Rep.AutoScan("[\n"+HeadTableLegal+"]" );
      IsPrintedHead = true;
    end;
    i = i + 1;
    TotaliList = TotaliList + 1;
    printOwnersSection( condition_date, issuer_id, Elem, i );
    while ( stat ) 
      printOneAvoirissection( 0, Elem, condition_date );
      TotalQuantity = TotalQuantity + Elem.Quantity;
      TotalBurdenedQuantity = TotalBurdenedQuantity + Elem.BurdenedQuantity;
      TotalList = TotalList + Elem.Quantity;
      TotalBurdenedList = TotalBurdenedList + Elem.BurdenedQuantity; 
      stat = GetNextByOwner( OwnersHumanList, abs(Elem.OwnerID), abs(Elem.DepoAccID), Elem );
    end;

    stat = GetFirstByOwner( OwnersHumanList, -1, -1, Elem );
  end;
  if ( _show_group_total and _split_group and ( TotalQuantity > 0 ) )
    printTotalSection( false, TotalQuantity, TotalBurdenedQuantity, i );
  end;

  if(TotalMaxPoint < OwnerMaxPoint)
    TotalMaxPoint = OwnerMaxPoint;
  end;

  /* переберем всех юр. лиц */
  OwnerMaxPoint = 0;
  stat = GetFirstByOwner( OwnersLegalList, -1, -1, Elem );
  if ( stat )
    if ( _split_group )
      Rep.AddEmptyStr();
      DP_AddPrintCell( Rep,  "Юридические лица", tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
      Rep.AddStr();
      Rep.AutoScan("[\n"+HeadTableLegal+"]" );
      i = 0;
    end;
  end;
  TotalQuantity = 0;
  TotalBurdenedQuantity = 0;
  while ( stat )
    // Если отчет без разбивки по формам субъектов - общий список выводится с заголовком для юридических лиц
    if((NOT _split_group) AND (NOT IsPrintedHead))
      Rep.AutoScan("[\n"+HeadTableLegal+"]" );
      IsPrintedHead = true;
    end;
    i = i + 1;
    TotaliList = TotaliList + 1;
    printOwnersSection( condition_date, issuer_id, Elem, i );
    while ( stat ) 
      printOneAvoirissection( 0, Elem, condition_date );
      TotalQuantity = TotalQuantity + Elem.Quantity;
      TotalBurdenedQuantity = TotalBurdenedQuantity + Elem.BurdenedQuantity;
      TotalList = TotalList + Elem.Quantity;
      TotalBurdenedList = TotalBurdenedList + Elem.BurdenedQuantity;
      stat = GetNextByOwner( OwnersLegalList, abs(Elem.OwnerID), abs(Elem.DepoAccID), Elem );
    end;

    stat = GetFirstByOwner( OwnersLegalList, -1, -1, Elem );
  end;
  if ( _show_group_total and _split_group and ( TotalQuantity > 0 ) )
    printTotalSection( true, TotalQuantity, TotalBurdenedQuantity, i );
  end;

  if(TotalMaxPoint < OwnerMaxPoint)
    TotalMaxPoint = OwnerMaxPoint;
  end;

  if ( _show_list_total and ( (OwnersLegalList.Size + OwnersHumanList.Size) > 0 ) )
    printTotalListSection( TotaliList, TotalBurdenedList, TotalList );
  end;

end;

private macro CreateEmptyRep()

  DP_StdHeaderLO_Ex( Rep, RepFontStyleTitel, "Список владельцев именных ц/б", _LogOprID, 0, false, _condition_date, NULL, tablewidth );
  Rep.AddEmptyStr();
  DP_AddPrintCell( Rep,  "Нет данных, удовлетворяющих параметрам отчета.", tablewidth, 0, "l:w:" + RepFontStyleTitel, is_ap, REP_ELEM_STR );
  Rep.AddEmptyStr();
  DP_StdFooter_Ex(Rep, RepFontStyleTitel, NULL, NULL, tablewidth);
end;


macro RegisterOwners ( iDepart          : integer,
                       condition_date   : date,
                       issuer_id        : integer,
                       domiciliate_id   : integer,
                       LogOprID         : integer,
                       DepoAccID        : integer,
                       group_by_avoir   : bool,
                       split_group      : bool,
                       show_group_total : bool,
                       show_list_total  : bool,
                       count_record     : bool,
                       show_depoacc     : bool,
                       ToExcel          : bool,
                       is_app           : bool
                     )

  var i = 0, iCount = 0;
  var Elem : Owners;
  var reglin = TBFile("dpreglin.tmp");
  var Progress = CProgressBar;
  var CR = TArray, CE = TArray, NN = TArray, LN = TArray, NC = TArray, LJ = TArray, AC = TArray, AE = TArray;
  var Counter, DepoAcc;
  Dl_CallInsertStat( IIF( ToExcel, DL_OUTREPORT_EXCEL, DL_OUTREPORT_STD ) );

  CR(CR.Size) = "┌─────┬";
  CR(CR.Size) = "│№ п/п│";
  CR(CR.Size) = "│     │";
  CR(CR.Size) = "├─────┼";

  CE(CE.Size) = "┌";
  CE(CE.Size) = "│";
  CE(CE.Size) = "│";
  CE(CE.Size) = "├";

  NN(NN.Size) = "──────────────────────┬";
  NN(NN.Size) = "       Имя/           │";
  NN(NN.Size) = "       документ       │";
  NN(NN.Size) = "──────────────────────┼";

  LN(LN.Size) = "──────────────────────┬";
  LN(LN.Size) = "    Наименование/     │";
  LN(LN.Size) = "    регистрация       │";
  LN(LN.Size) = "──────────────────────┼";

  NC(NC.Size) = "───────────────┬";
  NC(NC.Size) = "Гражданство/ИНН│";
  NC(NC.Size) = "               │";
  NC(NC.Size) = "───────────────┼";

  LJ(LJ.Size) = "───────────────┬";
  LJ(LJ.Size) = "Юрисдикция/ИНН │";
  LJ(LJ.Size) = "               │";
  LJ(LJ.Size) = "───────────────┼";

  AC(AC.Size) = "────────────────────────────┬";
  AC(AC.Size) = "         Счет депо/         │";
  AC(AC.Size) = "         название           │";
  AC(AC.Size) = "────────────────────────────┼";

  AE(AE.Size) = "";
  AE(AE.Size) = "";
  AE(AE.Size) = "";
  AE(AE.Size) = "";

  DP_BeginProtocol();  //начать протоколирование - подмена MsgBox

  _group_by_avoir   = group_by_avoir ;
  _split_group      = split_group;
  _show_reg         = true;
  _show_group_total = show_group_total;
  _show_list_total  = show_list_total;
  _count_record     = count_record;
  _show_depoacc      = show_depoacc;
  is_ap             = is_app;
  _LogOprID         = LogOprID;
  _condition_date   = condition_date;
  DepoAcc_ID        = DepoAccID;
  if ( _count_record )
    Counter = CR;
  else
    Counter = CE;
  end;

  if( _show_depoacc )
    DepoAcc = AC;
  else
    DepoAcc = AE;
  end;

  HeadTableHuman = Counter(0) + NN(0) + NC(0) + "────────────────────────┬──────────────────────────────┬" + DepoAcc(0) + "────────────────┬──────────────────┐\n"+
                   Counter(1) + NN(1) + NC(1) + "Адрес регистрации/      │Способ выплаты дохода/        │" + DepoAcc(1) + "Количество      │Из них обременено:│\n"+
                   Counter(2) + NN(2) + NC(2) + "      почтовый          │реквизиты                     │" + DepoAcc(2) + "                │      кол-во      │\n"+
                   Counter(3) + NN(3) + NC(3) + "────────────────────────┼──────────────────────────────┼" + DepoAcc(3) + "────────────────┼──────────────────┤";  
                                                                                                                                                                 
  HeadTableLegal = Counter(0) + LN(0) + LJ(0) + "────────────────────────┬──────────────────────────────┬" + DepoAcc(0) + "────────────────┬──────────────────┐\n"+
                   Counter(1) + LN(1) + LJ(1) + "Адрес регистрации/      │Способ выплаты дохода/        │" + DepoAcc(1) + "Количество      │Из них обременено:│\n"+
                   Counter(2) + LN(2) + LJ(2) + "      почтовый          │реквизиты                     │" + DepoAcc(2) + "                │      кол-во      │\n"+
                   Counter(3) + LN(3) + LJ(3) + "────────────────────────┼──────────────────────────────┼" + DepoAcc(3) + "────────────────┼──────────────────┤";  


  tablewidth = Index(HeadTableHuman, "\n");

  Progress.Init( reglin.nrecords(), "Идет подготовка отчета...", "Список владельцев именных ц/б" );

  OwnersHumanList.Size = 0;
  OwnersLegalList.Size = 0;
  FillPassiveList( condition_date, Progress );
  Progress.Remove();

  if ( ( OwnersHumanList.Size > 0 ) or ( OwnersLegalList.Size > 0 ) )
    DP_StdHeaderLO_Ex( Rep, RepFontStyleTitel, "Список владельцев именных ц/б", LogOprID, 0, false, condition_date, NULL, tablewidth );
    printCommonSection( condition_date, issuer_id, domiciliate_id );
    if ( group_by_avoir )
      printAvoirissection(condition_date);
      PrintByAvoirGroup( condition_date, issuer_id, domiciliate_id );
    else
      PrintByAvoirUnGroup( condition_date, issuer_id, domiciliate_id );
    end;
    Rep.AddEmptyStr();
    DP_StdFooter_Ex(Rep, RepFontStyleTitel, NULL, NULL, tablewidth);
  end;

  DP_AddProtocol(Rep, "protocol");  //добавим протокол к уже сформированному отчету
  DP_EndProtocol();                 //закончить протоколирование

  return DP_StdReportControl( _LogOprID, iif((( OwnersHumanList.Size <= 0 ) and ( OwnersLegalList.Size <= 0 )), 0, 1), @CreateEmptyRep, 0, ToExcel, Rep );
end;
