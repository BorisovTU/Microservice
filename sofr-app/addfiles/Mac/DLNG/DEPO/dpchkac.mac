/******************************************************************/
/*            Автоматизированная банковская система RS-Bank       */
/*               Copyright (c) R-Style SoftLab 2010               */
/*                                                                */
/*  Имя файла        : dpchkac.mac                                */
/*  Описание         : Макрос проверки счета/раздела счета депо   */
/*                     при автоматическом поиске/открытии раздела */
/*  Программист      : Alex V. Mishin 30-06-10                    */
/*                                                                */
/******************************************************************/
import DPInter;

private const SPSK_NOTDEFINED = -1,
              SPSK_OPEN = 0,
              SPSK_CLOSE = 1,
              SPSK_LOCKED = 2,
              SPSK_PLANE = 3,
              SPSK_NEW = 4;

private const DP_OPRACC_RECEPTION = 1,
              DP_OPRACC_WRITINGOFF = 2;

private const OBJTYPE_TRN_CONT_NOLIMIT = 19;

// Определяет, были ли события изменения статуса счета/раздела счета депо между
// датами проводки и текущим оперднем
private macro FindAnyDPACNTStatusChanges( DateCarry, dpacc )
  var StatusWasChanged = false;
  var query, DataSet;
  var Select;
  var i;
  var Params = TArray;

  query = " select t_AdmoprID " +
          " from ddepoadmo_dbt " +
          " where t_OperDate >= ? /*1*/ "
          " AND t_OperDate <= ? /*2*/ " +
          " AND ( t_OperKind = " + SPAO_CON_CLOSING + 
          "    OR t_OperKind = " + SPAO_CON_LOCKING + 
          "    OR t_OperKind = " + SPAO_CON_UNLOCKING + " ) "
          " AND t_PartyID = ? /*3*/ " +
          " AND t_DepoAcc = ? /*4*/ " +
          " AND t_Item = ? /*5*/ ";

  Params(Params.Size) = DateCarry; /*1*/
  Params(Params.Size) = {curdate}; /*2*/
  Params(Params.Size) = dpacc.Owner; /*3*/
  Params(Params.Size) = dpacc.Root; /*4*/

  if(dpacc.SKind == DEPO_ACCOUNT)
    Params(Params.Size) = SPDP_DEPO_ACCOUNT; /*5*/
  else
    Params(Params.Size) = SPDP_DEPO_PARTITION; /*5*/
    query = query + " AND t_DepoPart = ? /*6*/ ";
    Params(Params.Size) = dpacc.AutoKey; /*6*/
  end;

  Select = RSDCommand( query );

  i = 0;
  while(i < Params.Size)
    Select.AddParam("", RSDBP_IN, Params(i) );
    i = i + 1;
  end;

  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    StatusWasChanged = true;
  end;
  
  return StatusWasChanged;
end;


// Определить статус узла счета депо
private macro GetDEPOACNTCurrentStatus( AutoKey )
  var Status = SPSK_NOTDEFINED;

  var query, DataSet;
  var Select;
  var i;
  var Params = TArray;

  query = " select t_Status " +
          " from ddepoacnt_dbt " +
          " where t_AutoKey = ? /*1*/ ";

  Params(Params.Size) = AutoKey; /*1*/

  Select = RSDCommand( query );

  i = 0;
  while(i < Params.Size)
    Select.AddParam("", RSDBP_IN, Params(i) );
    i = i + 1;
  end;

  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    Status = DataSet.Status;
  end;

  return Status;
end;


// Точка входа в макрос
// Проверить статус раздела счета депо на валидность, с учетом дат
// Возвращает код ошибки или DP_GETDPAC_OK, если все хорошо
// В дистрибутивном варианте - запрещается списание с блокированного счета/раздела, а также с разделов счета в состоянии "Новый"
macro CheckDPACNTStatus(TypeDepoOp, v_sa, DateCarry, KindAccOperation, v_dpacc )
  var stat = DP_GETDPAC_OK;
  var Product = 0;
  var StatusWasChanged;

  var query, DataSet;
  var Select;
  var i;
  var Params = TArray;
  
  record spdraft("spdraft.dbt");
  record corpop("dpcorpop.dbt");
  record dpacc("depoacnt.dbt");

  SetBuff( dpacc, v_dpacc );

  if( TypeDepoOp == DP_SPDRAFT_OPERATION )
    SetBuff( spdraft, v_sa );
    Product = spdraft.Product;
  elif( TypeDepoOp == DP_GLOBOP_OPERATION )
    SetBuff( corpop, v_sa );
    Product = corpop.Product;
  end;

  if( DateCarry == {curdate} ) // Проводка выполняется текущей датой
    if( ( (KindAccOperation == DP_OPRACC_WRITINGOFF) AND (dpacc.Status != SPSK_OPEN) ) OR
        ( (KindAccOperation == DP_OPRACC_RECEPTION) AND (dpacc.Status == SPSK_CLOSE) ) )
      stat = DP_GETDPAC_WRONG_DPAC_STATUS;
    end;
  else // архивной
    StatusWasChanged = FindAnyDPACNTStatusChanges( DateCarry, dpacc );

    if( (dpacc.Status != SPSK_OPEN) OR (StatusWasChanged) )
      stat = DP_GETDPAC_WRONG_DPAC_STATUS;
    end;

    if( (stat == DP_GETDPAC_OK) AND (DateCarry < dpacc.OpenDate) )
      stat = DP_GETACC_DPACNEWER;
    end;

    if(stat = DP_GETDPAC_OK )
      query = " select t_AdmoprID " +
              " from ddepoadmo_dbt " +
              " where t_DepoAcc = ? /*1*/ "
              " AND t_OperDate > ? /*2*/ ";

      Params(Params.Size) = dpacc.AutoKey; /*1*/
      Params(Params.Size) = DateCarry; /*2*/

      if((KindAccOperation == DP_OPRACC_WRITINGOFF) AND (Product != OBJTYPE_TRN_CONT_NOLIMIT))
        // Найдем операцию - АО блокирования В04, разблокирования В05, закрытия В03 
        query = query + " AND ( t_OperKind = " + SPAO_CON_CLOSING +
                        "    OR t_OperKind = " + SPAO_CON_LOCKING + 
                        "    OR t_OperKind = " + SPAO_CON_UNLOCKING + " ) ";
      else
        // Найдем операцию - АО закрытия В03 
        query = query + " AND t_OperKind = " + SPAO_CON_CLOSING;
      end;

      Select = RSDCommand( query );

      i = 0;
      while(i < Params.Size)
        Select.AddParam("", RSDBP_IN, Params(i) );
        i = i + 1;
      end;

      Select.Execute();

      DataSet = TRsbDataSet(Select);
      if(DataSet.moveNext())
        stat = DP_GETDPAC_WRONG_DPAC_STATUS;
      end;
    end;
  end;

  if( (stat == DP_GETDPAC_OK) AND ( KindAccOperation == DP_OPRACC_WRITINGOFF ) AND (Product != OBJTYPE_TRN_CONT_NOLIMIT) )
    if( dpacc.Status == SPSK_NEW ) 
      stat = DP_GETDPAC_WRONG_DPAC_STATUS;
    end;
    if( stat = DP_GETDPAC_OK ) 
      //проверим статус головы счета
      //если он "новый", то списывать нельзя
      if( GetDEPOACNTCurrentStatus( dpacc.Root ) == SPSK_NEW )
        stat = DP_GETDPAC_NOKORRECTSTATUS;
      end;
    end;
  else
    if( (stat == DP_GETDPAC_OK) AND (dpacc.Status != SPSK_OPEN) AND (dpacc.Status != SPSK_LOCKED) AND (dpacc.Status != SPSK_NEW) )
      stat = DP_GETDPAC_WRONG_DPAC_STATUS;
    end;
  end;

  return stat;
end;
