/*
$Name: dpposord.mac
$Module: Депозитарий
$Description: Отчет "Позиционирование ц/б по заданному счету/разделу"
*/

import deposerv, CurrInter;
import RsbDataSet;

const в_активе  = "активе",
      в_пассиве = "пассиве",
      активный =  "А",
      пассивный = "П",
      депонент       = "депонента ",
      домицилиат     = "домицилиата ",
      место_хранения = "места хранения ";

private const IRCAG_ROLE_PAWNER = 7, IRCAG_ROLE_DEBTOR = 16;


const DepoChapter            = 5; /* Глава учета ценных бумаг */
const SYS_ANL_AINPACCOUNTING = 2; /* Аналитика "Учет актива в пассиве" */
const SIDEBALANCE_ACTIVE     = 1; /* активный */

var account;
file accvanl("accvanl");
file accsub("accsub");
file depoacnt("depoacnt") key 0;

var first_count_print = true;
var first_part_print = true;
var RootBriefCode,RootName;
var PartBriefCode,PartName;
var MAX_T_POINT = 0;



var HeadTable = "┌───────────────────────────────┬──────────────────────┬─────────────┬─────────────────────┬────────────────────┐\n"+
                "│Эмитент                        │Ц/б                   │LSIN         │ИК                   │Кол-во              │\n"+
                "├───────────────────────────────┼──────────────────────┼─────────────┼─────────────────────┼────────────────────┤";
                
var tablewidth = Index(HeadTable, "\n");
var Rep = CMakeReport(HeadTable);
const RepFontStyleTitel =  "ex_FS(b)";

var DepoRootList = TArray,
    DepoAccList  = TArray,
    IssuerList   = TArray,
    DepoAvoir    = TArray,
    DepoRestAvoir= TArray,
    XidIKList    = TArray;

var IsPrintIssuerHeader = true,
    IsPrintAvoidHeader  = true,
    IsPrintLSINHeader   = true;

var _group_by_partition; /* группировать по разделам */

var iCount = 0,
    TotalPartition = 0,
    TotalAccount   = 0;


private macro GetBaseFiIssuer(FIID):integer
  var query, DataSet;
  var Select;
  var Issuer = -1;

  query = " SELECT NVL ((SELECT parentfin.t_issuer "
        + "              FROM dfininstr_dbt fin, "
        + "                   dfininstr_dbt parentfin  "
        + "             WHERE fin.t_FIID = ? "
        + "               AND parentfin.t_FIID = fin.t_ParentFI), -1) Issuer FROM DUAL ";

  Select = RSDCommand( query );

  Select.AddParam("FIID",   RSDBP_IN, FIID );  /*1*/

  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    Issuer = DataSet.Issuer
  end;

  return Issuer;
end;


/* добавление счета депо в список */
macro AddToDepoList( DepoRoot, DepoAcc, FIID, Rest, Xid, Issuer, condition_date )
  record avoiriss("avoiriss");     
  record fininstr("fininstr");
  var i = 0;
  var findavr = false;
  
  //если уже есть в массиве запись для ц/б на данном счете, то суммируем остатки
  if( Xid == "")
    while(i<DepoRootList.Size)

      if((DepoRootList[i] == DepoRoot) and (DepoAccList[i] == DepoAcc) and (DepoAvoir[i] == FIID) and (XidIKList[i] == ""))
        findavr = true;
        break;
      end;
    
      i = i + 1;
    end;
  end;

  if(findavr)    
    DepoRestAvoir[i] = DepoRestAvoir[i] + double(Rest);
  else
    DepoRootList[DepoRootList.Size]   = DepoRoot;
    DepoAccList[DepoAccList.Size]     = DepoAcc;
    DepoAvoir[DepoAvoir.Size]         = FIID;    
    DepoRestAvoir[DepoRestAvoir.Size] = double(Rest);
    XidIKList[XidIKList.Size]         = Xid;

    if(ValType(Issuer) == V_UNDEF)
      if( ПолучитьФинИн( FIID, fininstr, avoiriss ) )
         MsgBox("не найден финансовый инструмент FIID = " + FIID );
         IssuerList[IssuerList.Size] = -1; //Неизвестный субъект
      else
         if(FI_AvrKindsEQ( FIKIND_AVOIRISS, AVOIRISSKIND_DEPOSITORY_RECEIPT, fininstr.AvoirKind ))//депозитарная расписка
           IssuerList[IssuerList.Size] = GetBaseFiIssuer(FIID);
         else                          
           IssuerList[IssuerList.Size] = FI_GetIssuerOnDate( fininstr, condition_date ); 
         end;
      end;
    else
      IssuerList[IssuerList.Size] = Issuer;
    end;
  end;
end;

/* поиск лицевого счета */
macro FindAccount( Account, FIID, condition_date, Rest, Xid, Issuer )
  file account_t("account") key 0;
  var foundAccount:bool = false; 
  
  if(Rest)
    account_t.Chapter       = DepoChapter;
    account_t.Account       = Account;
    account_t.Code_Currency = FIID; 

    foundAccount = getEQ(account_t); 

    if ( not foundAccount )
      MsgBox( "не найден лицевой счет " + Account );
    elif( account_t.Open_Date <= condition_date )
      AddToDepoList( account_t.DepoRoot, account_t.DepoAcc, account_t.Code_Currency, Rest, Xid, Issuer, condition_date );
    end;
  end;
end;

/* поиск лицевого счета */
macro FindAccountID( AccountID, FIID, condition_date, Rest, Xid, Issuer )
  file account_t("account") key 1;
  var foundAccount:bool = false; 
  
  if(Rest)
    account_t.AccountID     = AccountID;
    foundAccount = getEQ(account_t); 

    if ( not foundAccount )
      MsgBox( "не найден лицевой счет c ID " + AccountID );
    elif( account_t.Open_Date <= condition_date )
      AddToDepoList( account_t.DepoRoot, account_t.DepoAcc, account_t.Code_Currency, Rest, Xid, Issuer, condition_date );
    end;
  end;
end;


PRIVATE MACRO GetMortIssuerRole()
  var Role = IRCAG_ROLE_DEBTOR, mortgageIssuerPawner = 0, err;

  GetRegistryValue( "DEPO\\MORTGAGEISSUER", V_INTEGER, mortgageIssuerPawner, err );

  if(mortgageIssuerPawner)
    Role = IRCAG_ROLE_PAWNER;
  end;

  return Role;
END;

PRIVATE MACRO GetAgentNames(AvoirKind, BCID):string
  var AgentRole = GetMortIssuerRole(); 
  var query, cmd, DataSet;                     
  var AgentNames = "";                     
                       
  query =  " SELECT LTRIM(MAX(SYS_CONNECT_BY_PATH (t_AgentName, ', ')), ' ,') as AgentNames"
         + "   FROM (SELECT t_AgentName, ROW_NUMBER () OVER (ORDER BY t_AgentName) rn "
         + "           FROM dvsircag_dbt "
         + "          WHERE t_AvoirKind = ? /*1*/ and t_BCID = ?/*2*/ and t_AgentRole = ? /*3*/) "
         + "          START WITH rn = 1 "
         + "          CONNECT BY PRIOR rn = rn - 1 ";
 
  cmd = DL_RSDCommand(query);
  
  cmd.AddParam(AvoirKind);  /*1*/
  cmd.AddParam(BCID);       /*2*/
  cmd.AddParam(AgentRole);  /*3*/
  DataSet = cmd.Execute();

  if(DataSet.moveNext())
    AgentNames = DataSet.AgentNames;
  end;

  return AgentNames;
END;

/* перебор ИК */
macro CertifRest( AccountID, KindAcc, FIID, condition_date )

   var stat, mstat;
   var IKdebet,  /* Обороты по карточке по дебету */
       IKkredit, /* Обороты по карточке по кредиту */
       IKrest,   /* Остаток на карточке на начало периода */
       IKLrest;  /* Остаток на карточке на окончание периода */
   var Gfirst_date, Glast_date;
   var tAccountID, Issuer;
   var query;
   
   var  invcard, cmd; 
   var  invchng, cmd1;

   var AgentRole = GetMortIssuerRole();

   Gfirst_date = condition_date;
   Glast_date  = condition_date;

   cmd = DL_RSDCommand(  " select ic.*, vficert.t_Issuer, vficert.t_CertID, vficert.t_AvoirKind, "
                       + "        (SELECT COUNT (1) "
                       + "           FROM dvsircag_dbt "
                       + "          WHERE t_AvoirKind = vficert.t_AvoirKind and t_BCID = vficert.t_CertID and t_AgentRole = ? /*1*/) as CntAgents"
                       + "   from dinvcard_dbt ic, dv_ficert_dbt vficert "
                       + "  where vficert.t_FiCertID = ic.t_FiCertID "
                       + "    and vficert.t_FIID = ? /*2*/ "
                       + "    and (   ( ic.t_LAccountID = ? /*3*/ or ic.t_HAccountID = ? /*4*/ )"
                       + "          or ( ic.t_InvCardID in ( select ch.t_InvCardID from dinvchng_dbt ch where ch.t_LAccountID = ? /*5*/ or ch.t_HAccountID = ? /*6*/) )"
                       + "        ) "
                      );
   
   cmd.AddParam(AgentRole); /*1*/
   cmd.AddParam(FIID);      /*2*/
   cmd.AddParam(AccountID); /*3*/
   cmd.AddParam(AccountID); /*4*/
   cmd.AddParam(AccountID); /*5*/
   cmd.AddParam(AccountID); /*6*/

   invcard = cmd.Execute();

   while(invcard.moveNext())
         IKrest  = 0; 
         IKdebet = 0; 
         IKkredit= 0; 
         IKLrest = 0;
         tAccountID = 0;
         
         InvCardRestAndOverturnByAcc(invcard.InvCardID, AccountID, condition_date, condition_date, @IKrest, @IKdebet, @IKkredit, @IKLrest);

         /* определим место хранения или владельца */
         if ( abs(IKLrest) ) /* выводим только ненулевые остатки */
           if(invcard.ChangeDate <= condition_date) //актуальное состояние в ИК
             if ( KindAcc != активный )
               tAccountID = invcard.LAccountID;
             else
               tAccountID = invcard.HAccountID;
             end;
           else
             cmd1 = DL_RSDCommand(  " select * "
                                  + "   from dinvchng_dbt "
                                  + "  where t_InvCardID = ? "
                                  + "    and t_ChangeDate <= ? "
                                  + " order by t_ChangeDate DESC, t_InvChngID DESC" 
                                 );
             cmd1.AddParam(invcard.InvCardID);
             cmd1.AddParam(condition_date);
             
             invchng = cmd1.Execute();
             if(invchng.moveNext())
               if ( KindAcc != активный )
                 tAccountID = invchng.LAccountID;
               else
                 tAccountID = invchng.HAccountID;
               end;
             end;
           end;

           if ( tAccountID )
             if(invcard.Issuer == -1)
               if(invcard.CntAgents == 1)
                 var cmd2 = DL_RSDCommand("select t_Agent from dvsircag_dbt where t_AvoirKind = ? and t_BCID = ? and t_AgentRole = ?") ;
                 
                 cmd2.AddParam(invcard.AvoirKind);
                 cmd2.AddParam(invcard.CertID);
                 cmd2.AddParam(AgentRole);

                 var DS = cmd2.Execute();
                 if(DS.moveNext())
                   issuer = int(DS.Agent);
                 end;
               elif(invcard.CntAgents > 1)
                 issuer = GetAgentNames(invcard.AvoirKind, invcard.CertID);
               else
                 issuer = invcard.Issuer;
               end;
             else
               issuer = invcard.Issuer;
             end;


             FindAccountID( tAccountID, FIID, condition_date, abs(IKLrest), invcard.Number, Issuer );
           end;
         end;
   end;
end;


/* формирование списка актива */
macro FillActiveList( condition_date, depoacc_id )
  var i = 0,
      stat,
      sub_stat,
      rest = $0;
  var query;

  KeyNum( accvanl, 1 );
  ClearRecord( accvanl );

  KeyNum( accsub, 0 );
  ClearRecord( accsub );

  //если мы сюда зашли, то значит хоть один счет уже найден, тогда
  stat = account.MoveFirst();

  if ( stat )
    DepoRootList.Size  = 0;
    DepoAccList.Size   = 0;
    IssuerList.Size    = 0;
    DepoAvoir.Size     = 0;
    DepoRestAvoir.Size = 0;
    XidIKList.Size     = 0;
  end;

  while( stat )
    if ( ( not index(account.Type_Account, "I") ) and ( account.HaveSubAccounts == "X" ) and 
         ( account.Kind_Account == пассивный ) and ( account.Open_Date <= condition_date ) ) 
      /* перебор субсчетов */
      accvanl.FIID        = account.Code_Currency;
      accvanl.Chapter     = DepoChapter;
      accvanl.Account     = account.Account;
      accvanl.AnaliticsID = SYS_ANL_AINPACCOUNTING;

      if( getEQ(accvanl) )
        accsub.AccAnaliticsID = accvanl.AccAnaliticsID;
        accsub.SubAccountCode = "";
        sub_stat = getGE(accsub);
        while( sub_stat )
          if ( accsub.SpecialType == 0 )
            FindAccount( accsub.SubAccountCode, accvanl.FIID, condition_date, RestSubAcc( accsub.AccAnaliticsID, accsub.SubAccountID, condition_date ), "" );
          end;

          sub_stat = next(accsub) and ( accsub.AccAnaliticsID == accvanl.AccAnaliticsID );
        end;
      else
        MsgBox( "не найден субсчет лицевого счета " + account.Account + account.Code_Currency );
      end;
    elif ( ( account.Kind_Account == пассивный ) and ( account.Open_Date <= condition_date ) and ( index(account.Type_Account, "I") ) )
      /* перебор ИК */
      CertifRest( account.AccountID, account.Kind_Account, account.Code_Currency, condition_date );
    end;

    UseProgress( iCount = iCount + 1 );
    stat = account.MoveNext();
  end;

end;


/* формирование списка пассива */
macro FillPassiveList( condition_date, depoacc_id )
  var i = 0,
      stat,
      sub_stat,
      rest = $0;

  KeyNum( accvanl, 0 );
  ClearRecord( accvanl );

  KeyNum( accsub, 3 );
  ClearRecord( accsub );
 //если мы сюда зашли, то значит хоть один счет уже найден, тогда
  stat = account.MoveFirst();

  if ( stat )
    DepoRootList.Size  = 0;
    DepoAccList.Size   = 0;
    IssuerList.Size    = 0;
    DepoAvoir.Size     = 0;
    DepoRestAvoir.Size = 0;
  end;

  while( stat )
    if ( ( not index(account.Type_Account, "I") and ( account.Kind_Account == активный ) and ( account.Open_Date <= condition_date ) ) )
      /* перебор субсчетов */
      accsub.AnaliticsID    = SYS_ANL_AINPACCOUNTING;
      accsub.SubAccountCode = account.Account;
      sub_stat = getEQ(accsub);
      while( sub_stat )
        if ( accsub.SpecialType == 0 ) 
          accvanl.AccAnaliticsID = accsub.AccAnaliticsID;

          if( getEQ(accvanl) )
            FindAccount( accvanl.Account, accvanl.FIID, condition_date, 
                         RestSubAcc( accsub.AccAnaliticsID, accsub.SubAccountID, condition_date ), "" );
          else
            MsgBox( "не найден лицевой счет " + accvanl.Account );
          end;
        end;

        sub_stat = next(accsub) and ( accsub.AnaliticsID == SYS_ANL_AINPACCOUNTING ) and ( accsub.SubAccountCode == account.Account );
      end;
    elif ( ( account.Kind_Account == активный ) and ( account.Open_Date <= condition_date ) and ( index(account.Type_Account, "I") ) )
      /* перебор ИК */
      CertifRest( account.AccountID, account.Kind_Account, account.Code_Currency, condition_date );
    end;

    UseProgress( iCount = iCount + 1 );
    stat = account.MoveNext();
  end;
                
end;


/* подсчет записей */
macro GetCount( depoacc_id )
  var iCount:integer = 0,
      stat;
  var query;

  //выберем все счета терминальных разделов указанного счета/раздела
  query =   " select * from daccount_dbt "
          + " where t_DepoAcc in "
          + "        ( select da.t_AutoKey from ddepoacnt_dbt da"
          + "           where da.t_AutoKey not in "
          + "                 ( select t_superior from ddepoacnt_dbt where t_Superior != 0 and t_Root = da.t_Root) "
          + "           START WITH da.t_AutoKey = " + depoacc_id
          + "           CONNECT BY PRIOR da.t_Autokey  =  da.t_Superior" 
          + "        )";

  account = TRsbDataSet(query, RSDVAL_CLIENT, RSDVAL_STATIC);
  account.MoveLast();
  iCount = account.GetRecCount();
  
  return iCount;
end;



/* печать общей секции */
macro printCommonSection( condition_date, depoacc_id, deponent_id )
  var i = 0,
      DeponentName = GetPartyName( deponent_id ),
      AccKind,
      UpperName;

  if ( depoacnt.Kind == SIDEBALANCE_ACTIVE )
    AccKind = в_пассиве;
  else
    AccKind = в_активе;
  end;

  if( depoacnt.Kind == SIDEBALANCE_ACTIVE ) 
    UpperName =  место_хранения;
  else
    UpperName = депонент;
  end;

  Rep.AddEmptyStr();
  DP_AddPrintCell( Rep,  "На счете/разделе", 17, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
  DP_AddPrintCell( Rep,  depoacnt.BriefCode + " " + UpperName + DeponentName, tablewidth-17, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
  Rep.AddStr();
  DP_AddPrintCell( Rep,  "учитывались ц/б, отражавшиеся на следующих счетах в", 52, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
  DP_AddPrintCell( Rep,  AccKind + " баланса:", tablewidth-52, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
  Rep.AddStr();
  Rep.AddEmptyStr();
  Rep.AddEmptyStr();
end;

macro FindNextDepoRoot()
  var i = 0;
  while( i < DepoRootList.Size )
    if ( DepoRootList[i] > 0 )
      return i;
    end;
    i = i + 1;
  end;

  return -1;
end;


macro ContinueDepoRoot( i, Root )
  while ( i < DepoRootList.Size )
    if ( DepoRootList[i] == Root )
      return i;
    end;
    i = i + 1;
  end;

  return -1;
end;

macro FindNextDepoPart( DepoRoot )
  var i = 0;

  while( i < DepoAccList.Size )
    if ( ( DepoAccList[i] > 0 ) and ( DepoRoot == DepoRootList[i] ) )
      return i;
    end;
    i = i + 1;
  end;

  return -1;
end;


macro ContinueDepoPart( DepoRoot, i, Part )
  while ( i < DepoAccList.Size )
    if ( ( DepoAccList[i] == Part ) and ( DepoRoot == DepoRootList[i]) )
      return i;
    end;
    i = i + 1;
  end;

  return -1;
end;


macro ContinueIssuer( DepoRoot, DepoPart, i, Issuer )
  while ( i < IssuerList.Size )
    if ( ( IssuerList[i] == Issuer ) and  ( DepoRoot == DepoRootList[i]) and 
         ( ( _group_by_partition and ( DepoAccList[i] == DepoPart ) ) or ( not _group_by_partition ) ) )
      return i;
    end;
    i = i + 1;
  end;

  return -1;
end;


macro ContinueAvoir( DepoRoot, DepoPart, Issuer, i, FIID )
  while ( i < DepoAvoir.Size )
    if ( ( DepoAvoir[i] == FIID ) and ( IssuerList[i] == Issuer ) and ( DepoRoot == DepoRootList[i] ) and
         ( ( _group_by_partition and ( DepoAccList[i] == DepoPart ) ) or ( not _group_by_partition ) )
       )
      return i;
    end;
    i = i + 1;
  end;

  return -1;
end;


/* печать секции выпуска */
macro printAvoiriss( DepoRoot, DepoPart, Issuer, i )
  var FIKindName,
      IssuerName, LSIN;


  record avoiriss("avoiriss");     
  record fininstr("fininstr");


  if ( DepoAvoir[i] < 0 ) /* ц/б уже напечатана */
    return;
  end;
              
  while ( i != -1 )
   if(DepoRestAvoir[i] != 0)

    if( ПолучитьФинИн( DepoAvoir[i], fininstr, avoiriss ) )
       MsgBox("не найден финансовый инструмент FIID = " + DepoAvoir[i] );
    end;

    if ( ( Issuer != -1 ) and ( IsPrintIssuerHeader ) )
      if(ValType(Issuer) == V_STRING)
        IssuerName = Issuer;
      else
        IssuerName = GetPartyName( Issuer );
      end;
      IsPrintIssuerHeader = false;
    else
      IssuerName = "";
    end;

    if ( IsPrintAvoidHeader )
      FIKindName = getAVOIRISS( DepoAvoir[i] );
      IsPrintAvoidHeader = false;
    else
      FIKindName = "";
    end;

    if( IsPrintLSINHeader )
      LSIN = avoiriss.LSIN;
      IsPrintLSINHeader = false;
    else
      LSIN = "";
    end;

    if(first_count_print)
       DP_AddPrintCell( Rep,  "Счет депо:", 15, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
       DP_AddPrintCell( Rep,  RootBriefCode + "   " + RootName, 100, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
       Rep.AddStr();
       first_count_print = false;
    end; 

    if ( _group_by_partition AND first_part_print)
       DP_AddPrintCell( Rep,  "   Раздел:", 15, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
       DP_AddPrintCell( Rep,  PartBriefCode + "   " + PartName, 100, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
       Rep.AddStr();
       first_part_print = false;
    end;      



    DP_AddPrintCell( Rep,  IssuerName,       0, 0, "l:" + RepFontStyleTitel );
    DP_AddPrintCell( Rep,  FIKindName,       0, 0, "l:" + RepFontStyleTitel );
    DP_AddPrintCell( Rep,  LSIN,             0, 0, "l:" + RepFontStyleTitel );
    DP_AddPrintCell( Rep,  XidIKList[i],     0, 0, "l:" + RepFontStyleTitel );
    DP_AddPrintCell( Rep,  DepoRestAvoir[i], 0, DP_GetPrecision(DepoRestAvoir[i], fininstr.SumPrecision), "r:" + RepFontStyleTitel );
    Rep.AddStr();

    if(fininstr.SumPrecision > MAX_T_POINT)
       MAX_T_POINT = fininstr.SumPrecision;
    end;

    TotalPartition = TotalPartition + DepoRestAvoir[i];
    TotalAccount   = TotalAccount + DepoRestAvoir[i];
  end; 
    DepoAvoir[i]    = -1*DepoAvoir[i];
    DepoRootList[i] = -1*DepoRootList[i];
    DepoAccList[i]  = -1*DepoAccList[i];
    if(ValType(IssuerList[i]) == V_STRING)
      IssuerList[i]   = "-1"+IssuerList[i];
    else
      IssuerList[i]   = -1*IssuerList[i];
    end;

    i = ContinueAvoir( DepoRoot, DepoPart, Issuer, i, -1*DepoAvoir[i] );
  end;
end;


/* печать секции эмитента */
macro printIssuerSection( DepoRoot, DepoPart, i )

  IsPrintAvoidHeader = true;
  IsPrintLSINHeader  = true;

  while ( i != -1 )
    printAvoiriss( DepoRoot, DepoPart, IssuerList[i], i ); 
    IsPrintAvoidHeader = true;
    IsPrintLSINHeader  = true;
    if(ValType(IssuerList[i]) == V_STRING)
      i = ContinueIssuer( DepoRoot, DepoPart, i, "-1"+IssuerList[i] );
    else
      i = ContinueIssuer( DepoRoot, DepoPart, i, -1*IssuerList[i] );
    end;
  end;
end;


/* печать секции разделов депо */
macro printDepoPartSection( DepoRoot, i )
//  var PartBriefCode,
//      PartName;

  MAX_T_POINT = 0;

  while ( i != -1 )

    /* распечатаем раздел счета депо */
    depoacnt.AutoKey = DepoAccList[i]; 

    if ( getEQ(depoacnt) )
      PartBriefCode = depoacnt.BriefCode;
      PartName      = depoacnt.Name;
    else
      MsgBox( "не найден счет депо c номером = " + DepoAccList[i] );
    end;

/*    if ( _group_by_partition )

     DP_AddPrintCell( Rep,  "   Раздел:", 15, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
     DP_AddPrintCell( Rep,  PartBriefCode + "   " + PartName, tablewidth-15, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
     Rep.AddStr();
    end;
*/

    first_part_print = true;

    IsPrintIssuerHeader = true;

    while ( i != -1 )
      printIssuerSection( DepoRoot, DepoAccList[i], i );
      IsPrintIssuerHeader = true;
      i = ContinueDepoPart( DepoRoot, i, -1*DepoAccList[i] );
    end;

    if ( _group_by_partition AND TotalPartition != 0)

      DP_AddPrintCell( Rep,  "Итого по разделу", Rep.GetColWidthTable(0)+Rep.GetColWidthTable(1)+Rep.GetColWidthTable(2)+Rep.GetColWidthTable(3)+3, 0, "l:" + RepFontStyleTitel );
      DP_AddPrintCell( Rep,  TotalPartition, Rep.GetColWidthTable(4), DP_GetPrecision(TotalPartition, MAX_T_POINT), "r:" + RepFontStyleTitel );
      Rep.AddStr();
    end;
    TotalPartition = 0;

    i = FindNextDepoPart( DepoRoot );
  end;
end;


/* печать секции счетов депо */
macro printDepoRootSection()
  var i = 0;
      //RootBriefCode,
      //RootName;

  i = 0;
  while ( i != -1 )

    IsPrintIssuerHeader   = true;
    IsPrintAvoidHeader    = true;
    IsPrintLSINHeader     = true;
    TotalAccount = 0;

    /* распечатаем счет депо */
    depoacnt.AutoKey = DepoRootList[i]; 

    if ( getEQ(depoacnt) )
      RootBriefCode = depoacnt.BriefCode;
      RootName      = depoacnt.Name;
    else
      MsgBox( "не найден счет депо c номером = " + DepoRootList[i] );
    end;

//      DP_AddPrintCell( Rep,  "Счет депо:", 15, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
//      DP_AddPrintCell( Rep,  RootBriefCode + "   " + RootName, tablewidth-15, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR );
//      Rep.AddStr();
    first_count_print = true;
     

    /* попытаеммя найти записи с таким же счетом */
    while ( i != -1 )
      printDepoPartSection( DepoRootList[i], i );
      
      i = ContinueDepoRoot( i, -1*DepoRootList[i] ); 
    end;

    if( TotalAccount != 0)
    DP_AddPrintCell( Rep,  "Итого по счету", Rep.GetColWidthTable(0)+Rep.GetColWidthTable(1)+Rep.GetColWidthTable(2)+Rep.GetColWidthTable(3)+3, 0, "l:" + RepFontStyleTitel );
    DP_AddPrintCell( Rep,  TotalAccount, Rep.GetColWidthTable(4), DP_GetPrecision(TotalAccount, MAX_T_POINT), "r:" + RepFontStyleTitel );
    Rep.AddStr();
    TotalAccount = 0;

    Rep.AddEmptyStr();
    end;

    i = FindNextDepoRoot();
  end;
end;

                      
macro PositionOrder( iDepart            : integer,
                     condition_date     : date,
                     depoacc_id         : integer,
                     deponent_id        : integer,
                     group_by_partition : bool,
                     ToExcel            : bool
                   )

  Dl_CallInsertStat( IIF( ToExcel, DL_OUTREPORT_EXCEL, DL_OUTREPORT_STD ) );

  DP_BeginProtocol();  //начать протоколирование - подмена MsgBox

  var StdRep = Depo_StdRepSection( "Позиционирование ц/б по заданному счету/разделу", "", condition_date );
  var i = 0;
  var nrec = 0;
  _group_by_partition = group_by_partition;

  depoacnt.AutoKey = depoacc_id;
  if ( not getEQ(depoacnt) )
    DP_EndProtocol();                 //закончить протоколирование
    MsgBox( "не найден счет депо, указанный в фильтре" );
    return;
  end;
  nrec = GetCount(depoacc_id);
  InitProgress( nrec, "Идет подготовка отчета...", "Позиционирование ц/б по заданному счету/разделу");
  if( nrec > 0 )
    if ( depoacnt.Kind ==  SIDEBALANCE_ACTIVE )
      FillPassiveList( condition_date, depoacc_id );
    else
      FillActiveList( condition_date, depoacc_id ); 
    end;
  end;

  if ( DepoRootList.Size > 0 )
    DP_StdHeaderLO_Ex( Rep, RepFontStyleTitel, "Позиционирование ц/б по заданному счету/разделу", 0, 0, false, condition_date, condition_date, tablewidth );
    printCommonSection( condition_date, depoacc_id, deponent_id );
    printDepoRootSection();

    DP_StdFooter_Ex(Rep, RepFontStyleTitel, NULL, NULL, tablewidth);

    DP_AddProtocol(Rep, "protocol");  //добавим протокол к уже сформированному отчету
    DP_EndProtocol();                 //закончить протоколирование

    if( ToExcel )
      Rep.PrintWinRep();
      Rep.ShowWinRep();
    else
      Rep.PrintRep();
    end;
  else
    if(not DP_ProtocolIsEmpty())
      DP_AddPrintCell(Rep, "Не найдено данных, удовлетворяющих параметрам отчета", 55, 0, "l:" + RepFontStyleTitel, false, REP_ELEM_STR);
      Rep.AddStr();

      DP_AddProtocol(Rep, "protocol");  //добавим протокол к уже сформированному отчету
      DP_EndProtocol();                 //закончить протоколирование

      if( ToExcel )
        Rep.PrintWinRep();
        Rep.ShowWinRep();
      else
        Rep.PrintRep();
      end;
    else
      DP_EndProtocol();                 //закончить протоколирование
    end;

    MsgBox( "Не найдено данных, удовлетворяющих параметрам отчета" );
  end;

end;
