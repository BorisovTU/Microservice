/*******************************************************************************
 FILE         :   dp_util.mac

 DESCRIPTION  :   Общие процедуры

 PROGRAMMED BY:   

 CREATION DATE:   19.05.03
*******************************************************************************/


/*
  Макрос для сортировки массива TArray. Массив может содержать как
  данные нативных типов, так и объекты. Во втором случае в макрос
  TArray_QSort передаются названия полей, по которым должна
  осуществляется сортировка.
*/
macro TArray_QSort(arr:TArray/* ,field:string, direct:integer */)
      class CField(_field:string, _direct:integer)
            Var field:string   = _field,
                direct:integer = _direct;
      end;
      /* ---------------------------------------- */
      Var fldArr:TArray = TArray(1, 1);
      Var commonDirect:integer = 1;


      macro CmpFields(obj1, obj2, cmpObj:CField)
            Var p1 = obj1, p2 = obj2;

            if(cmpObj.field)
                p1 = GenGetProp(obj1, cmpObj.field);
                p2 = GenGetProp(obj2, cmpObj.field);
            end;

            if(p1 < p2)   return -1*cmpObj.direct;
            elif(p1 > p2) return  1*cmpObj.direct;
            else          return  0;
            end;
      end;
      macro CmpObjects(obj1, obj2):integer
            Var count:integer = 1, cmp:integer = 0,
                retCmp:integer = 0;

            if(not fldArr.Size())
                return CmpFields(obj1, obj2, CField("", commonDirect));
            else
                retCmp = CmpFields(obj1, obj2, fldArr[0]);
            end;

            if(retCmp) return retCmp; end;

            while(count < fldArr.Size())
                 cmp = CmpFields(obj1, obj2, fldArr[count]);
                 if(cmp != retCmp) return cmp; end;
                 count = count + 1;
            end;

            return retCmp;
      end;
      macro QuickSort(left:integer, right:integer)
            Var i:integer = left, j:integer = right, flag:bool = TRUE,
                swap,
                test = arr[Int((left+right)/2.0)];

            while(flag)
                 while(CmpObjects(arr[i], test) < 0) i=i+1; end; /* < */
                 while(CmpObjects(test, arr[j]) < 0) j=j-1; end; /* < */

                 if(i <= j)
                     swap = arr[i]; arr[i] = arr[j]; arr[j] = swap;
                     i=i+1; j=j-1;
                 end;

                 if(i > j) flag = FALSE; end;
            end;

            if(left < j)  QuickSort(left, j);  end;
            if(i < right) QuickSort(i, right); end;
     end;

     /* Формируем массив полей */
     Var i:integer = 1, field1, field2;

     while(GetParm(i, field1))
          if(field1)
              if((ValType(field1) == V_INTEGER) and (i == 1))
                  commonDirect = field1;
              elif(ValType(field1) == V_STRING)
                  if(GetParm(i + 1, field2) and (ValType(field2) == V_INTEGER))
                      fldArr[fldArr.Size()] = CField(field1, field2);
                      i = i + 1;
                  else
                      fldArr[fldArr.Size()] = CField(field1, commonDirect);
                  end;
              end;
          end;
          i = i + 1;
     end;

     if(arr.Size() > 1) QuickSort(0, arr.Size()-1); end;
end; /* TArray_QSort */



macro GetHeadAccForAcc(Node)
  var dpacnt = TBfile("depoacnt");

  dpacnt.Clear();
  dpacnt.rec.AutoKey = Node;
  if(dpacnt.GetEQ())
    if(dpacnt.rec.AutoKey != dpacnt.rec.Root) /*Если он сам не является головой*/
       dpacnt.rec.AutoKey = dpacnt.rec.Root;
       dpacnt.GetEQ();
       return dpacnt.rec.Code;
    end;
  end;
  return "";
end;
