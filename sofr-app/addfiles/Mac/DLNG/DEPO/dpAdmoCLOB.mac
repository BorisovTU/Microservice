/*
$Name: dpAdmoCLOB.mac
$Module: Депозитарий
$Description: Работа с CLOB-данными административных операций
*/

import XmlRpcInter, serviceaction, RsbDataSet, DPInter, CTInter, FIInter, PTInter;
import dlquery, cb_sql;

private const SPDP_CLIENT         =  10, // Анкета депонента
              SPDP_OURDEPOSITARY  =  20, // Анкета нашего депозитария
              SPDP_STORAGEPLACE   =  30, // Анкета места хранения
              SPDP_GUARDIAN       =  40, // Анкета попечителя
              SPDP_OPERATOR       =  50, // Анкета оператора
              SPDP_MANAGER        =  60, // Анкета распорядителя
              SPDP_DEPOCORR       =  65, // Анкета депозитария-корреспондента
              SPDP_AVOIRIS        =  70, // Анкета ценной бумаги
              SPDP_DEPO_ACCOUNT   =  80, // Анкета счета депо
              SPDP_ACCMANAGER     =  90, // Анкета распорядителя счета депо
              SPDP_DEPO_PARTITION = 100, // Анкета раздела счета депо
              SPDP_PARTMANAGER    = 110, // Анкета распорядителя счета депо
              SPDP_FACE_ACCOUNT   = 120, // Анкета лицевого счета
              SPDP_INVCARD        = 130, // Анкета инв. карточки
              SPDP_DEPODRAFT      = 140; // Анкета поручения депо (резерв.)

private const UNDEF_I = -1,
              SET_CHAR = "X",
              UNSET_CHAR = "";

var clobData = null;

/* Аналог оператора ?: в си. */
private macro IIF(condition, value_true, value_false)
   if( condition )
      return value_true;
   else
      return value_false;
   end;
end;

/*Базовый класс */
class TDepoAdmoCLOB
  // записи
  var oldData = null, // старый буфер
      newData = null; // новый буфер

  /* Конвертация из объекта XML в наш*/
  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
  end;

  macro CreateTData()
    return null;
  end;
  /* копирование данных из newData в oldData */
  macro CopyNewData()
    oldData = null;
    oldData = CreateTData();
    ConvertFromXmlObjectData(oldData, this, "newData");
  end;

  /*Методы, которые надо перегружать*/
  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    if ("copyNewData" == tableName)
      CopyNewData();
    end;
  end;
  /* Отличаются ли буферы?*/
  macro IsChanges()
    return false;
  end;
  /* Конвертация полученных данных из объекта XML в наши*/
  macro ConvertFromXmlObject(xmlObj)
    ConvertFromXmlObjectData(oldData, xmlObj, "oldData");
    ConvertFromXmlObjectData(newData, xmlObj, "newData");
  end;

  /* идентификатор данных */
  macro GetReqID()
    return "DepoAdmo";
  end;
  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
  end;

  private macro CopyValue(oldData:object, newData:object, nameField:string,
                          saveB:TRecHandler, recB:TRecHandler, nameFieldB:string,
                          overwrite:integer, isUndef:bool)
    if (overwrite != 0)
      if (ValType(recB) != V_UNDEF)
        GenSetProp(newData, nameField, GenGetProp(recB.rec, nameFieldB));
      end;
      if (ValType(saveB) != V_UNDEF)
        GenSetProp(oldData, nameField, GenGetProp(saveB.rec, nameFieldB));
      end;
    else
      var oldD = GenGetProp(oldData, nameField),
          newD = GenGetProp(newData, nameField);
      if ( (((ValType(oldD) == V_INTEGER) and (oldD == IIF(isUndef, UNDEF_I, 0))) and
            ((ValType(newD) == V_INTEGER) and (newD == IIF(isUndef, UNDEF_I, 0)))   ) or
           (((ValType(oldD) == V_STRING) and (oldD == "")) and
            ((ValType(newD) == V_STRING) and (newD == ""))   )        or
           (((ValType(oldD) == V_DATE) and (oldD == Date(0,0,0))) and
            ((ValType(newD) == V_DATE) and (newD == Date(0,0,0)))   ) or
           (((ValType(oldD) == V_BOOL) and (oldD == false)) and
            ((ValType(newD) == V_BOOL) and (newD == false))   )       or
           (((ValType(oldD) == V_NUMERIC) and (oldD == $0.0)) and
            ((ValType(newD) == V_NUMERIC) and (newD == $0.0))   )     or
           (((ValType(oldD) == V_DOUBLE) and (oldD == 0.0)) and
            ((ValType(newD) == V_DOUBLE) and (newD == 0.0))   )
         )
        if (ValType(recB) != V_UNDEF)
          GenSetProp(newData, nameField, GenGetProp(recB.rec, nameFieldB));
        end;
        if (ValType(saveB) != V_UNDEF)
          GenSetProp(oldData, nameField, GenGetProp(saveB.rec, nameFieldB));
        end;
      end;
    end;
    onError(er)
      ;// блокируем ошибку
  end;

  /* Получение значение поля xmlObj и установка в поле объекта obj*/
  /* просто равенство не может быть, ибо в xmlObj может не быть поля */
  private macro CopyValueFromXmlObjToObj(obj:object, xmlObj:object, nameField:string, defaultValue:variant)
    // obj.nameField должен быть!
    var val = GenGetProp(xmlObj, nameField);

    if(ValType(val) == V_UNDEF)
      val = defaultValue;
    end;

    GenSetProp(obj, nameField, val);
    OnError(er)
      ;
  end;
  /* Объект - массив TArray? */
  private macro IsTArrayObj(obj):bool
    return ((ValType(obj) == V_GENOBJ) and (StrUpr(GenClassName(obj)) == "TARRAY"));
  end;
  /* Аналог CopyValueFromXmlObjToObj, но копирует массив */
  private macro CopyArrayFromXmlObjToObj(obj:object, xmlObj:object, nameField:string, CreateCopyElemMethod:MethodRef)
    // obj.nameField должен быть!
    var value = GenGetProp(xmlObj, nameField);

    // если массив пришел, то  коипруем как массив
    if (IsTArrayObj(value))
      var dataArr = GenGetProp(obj, nameField); // массив в Data
      if (IsTArrayObj(dataArr))
        for (var elem, value)
          dataArr[dataArr.size] = CallR2M(CreateCopyElemMethod, elem);
        end;
      end;
    end;
    OnError(er)
      ;
  end;

  private macro GenGetPropDefault(obj:object, nameField:string, defaultValue:variant):variant
    return GenGetProp(obj, nameField);
    onError(er)
      return defaultValue;
  end;
  /* Установить результаты в массивы*/
  private macro SetArrayForm(nameStr:string, oldValue:string, newValue:string, name:TArray, old:TArray, new:TArray)
    var size = name.size;
    name[size] = nameStr;
    if (ValType(old) != V_UNDEF)
      old[size] = oldValue;
    end;
    if (ValType(new) != V_UNDEF)
      new[size] = newValue;
    end;
  end;

  /* Выполнить SELECT и вернуть рузультат select'a
     Параметры:
        value         [&out] - результат выполнения (возвращает результат в алиасе t_retValue)
        query         [in]   - запрос, вида SELECT t_name AS T_RETVALUE FROM dtable_dbt WHERE t_ID=? AND t_type=?
        params [0..1] [in]   - параметры, которые передаются в запросе. Равны кол-ву ? запросе. В данном примере 1202,31
        errMsg        [out]  - сообщение об ошибке. Если "", то ошибки нет
     Return: true - запись найдена, false - ошибка
  */
  macro SQL_ExecuteSelect(value:@variant, query:string /*params..., errMsg*/ ):bool
    var flagFind:bool = false;
    var cmd, dataSet;
    cmd = DL_RSDCommand(query);

    var i:integer;
    var countParm:integer = Parmcount();
    for(i, 3, countParm-2)//последним аргументом идет errMsg
      var parm:variant;
      if (GetParm(i, parm))
        cmd.addParam(parm);
      else
        SetParm(countParm-1, "Ошибка получения аргумета функции SQL_ExecuteSelect");
        return false;
      end;
    end;
    dataSet = cmd.execute();

    flagFind = dataSet.moveNext();
    if (flagFind)
      value = DataSet.RetValue;
    end;
    return flagFind;

    OnError(er)
      SetParm(countParm-1, cmd.GetErrorString(er)); // Если ошибка не SQL, то вернется er.message
      return false;
  end;
  /* Получить значение из dnamealg_dbt*/
  private macro name_alg(Type, Number)
    var nameAlg:string = "";
    SQL_ExecuteSelect(@nameAlg, "SELECT t_szNameAlg as t_retValue FROM dnamealg_dbt WHERE t_iTypeAlg = ? AND t_iNumberAlg = ?", Type, Number, null);
    return nameAlg;
  end;
  private macro GetKindValue(Kind:integer):string
    if (Kind == DP_SIDEBALANCE_ACTIVE)
      return name_alg(3106,1); // активный
    else
      return name_alg(3106,2); // пассивный
    end;
  end;
  private macro GetTypeValue(type:integer, iRep:integer):string
    var cmd, dataSet;
    cmd = DL_RSDCommand("SELECT t_shortName, t_name FROM ddepoac_dbt WHERE T_ID = ?");

    cmd.addParam(type);
    dataSet = cmd.execute();

    if (dataSet.moveNext())
      if (iRep != 0)
        return dataSet.Name;
      else
        return dataSet.ShortName;
      end;
    end;
    OnError(er)
      return "Ошибка при поиске Типа";
  end;
  /* Получить запись ddepoacnt_dbt*/
  private macro GetDacnt(autoKey:integer):TRecHandler
    var f_depoacnt = TBFile("depoacnt.dbt", "r", 0);
    var rec = TRecHandler("depoacnt.dbt");

    rec.clear();

    f_depoacnt.rec.AutoKey = autoKey;
    if (f_depoacnt.getEQ())
      copy(rec, f_depoacnt);
    end;

    return rec;
  end;

  private macro GetNameLLVALUES(list:integer, elem:integer, notFoundStr:string):string
    var name:string = "";
    var errMSg:string = "";
    if (SQL_ExecuteSelect(@name, "SELECT t_name as t_retValue FROM dllvalues_dbt WHERE t_List = ? and t_Element = ?", list, elem, errMSg))
      return name;
    end;

    if (errMSg != "")
      msgbox(errMSg);
    end;
    return notFoundStr;
  end;
  /* Наименование вида ЦБ*/
  private macro GetAvoirKindName(fiid:integer):string
    var name:string = "";
    var errMSg:string = "";
    if (SQL_ExecuteSelect(@name, "SELECT kind.t_Name as t_retValue FROM davrkinds_dbt kind, dfininstr_dbt fin WHERE kind.T_FI_KIND = fin.t_FI_Kind and kind.t_AvoirKind=fin.t_AvoirKind and fin.t_FIID = ?",
                          fiid, errMSg))
      return name;
    end;

    if (errMSg != "")
      msgbox(errMSg);
    end;
    return "";
  end;
  /* Получить наименование типа */
  private macro GetNameTypeAccount(numType:integer, typeAcc:string):string
    var name:string = "";
    var errMSg:string = "";
    if (SQL_ExecuteSelect(@name, "SELECT t_Name_Type as t_retValue FROM dtypeac_dbt WHERE t_iNumType = ? AND t_Type_Account = ?", numType, typeAcc, errMSg))
      return name;
    end;

    if (errMSg != "")
      msgbox(errMSg);
    end;
    return "";
  end;
  /* Формирует полную расшифровку ценной бумаги */
  private macro WriteFullFIAdmo(fiid:integer, isEmissive:bool, iRep:integer, operdate:date)
    var str:string = "";
    if (DP_WriteFullFIAdmo(fiid, isEmissive, iRep, operdate, str) == 0)
      return str;
    end;
    return "";
  end;
  /* Формирует полную расшифровку субъекта */
  private macro WriteFullParty(partyID:integer, iRep:integer, operdate:date):string
    var str:string = "";
    if (DP_WriteFullPartyAdmo(partyID, iRep, operdate, str) == 0)
      return str;
    end;
    return "";
  end;
  /* */
  private macro WriteDelivery(type:integer, delivery:string, iRep:integer):string
    var str = "";
    if (iRep != 0)
      var i = 1, lenDelivery = StrLen(delivery);
      while (i <= lenDelivery)
        if (i != 1)
          str = str + ", ";
        end;
        str = str + GetNameTypeAccount(type, SubStr(delivery, i, 1));
        i = i + 1;
      end;
    else
      str = delivery;
    end;
    return str;
  end;
  /* Функции для работы с массивами */
  /* Поиск элемента в массиве по ID
     -1 - не найден, иначе - индекс в массиве */
  macro FindElemInArray(arr:TArray, id:integer):integer
    var i = 0;
    while (i < arr.size)
      if (arr[i].IsEqualElem(id))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  end;
  /* Есть ли элемент с ID в массиве? */
  macro IsElemInArrData(arr:TArray, ID:integer):bool
    return (FindElemInArray(arr, ID) != -1);
  end;

end;
/* ф-ция для сортировки массива с данными TAcapAuthData */
macro cmdAcapAuth(lobj, robj)
  if( lobj.AUNodeID > robj.AUNodeID ) return  1; end;
  if( lobj.AUNodeID < robj.AUNodeID ) return -1; end;
  return 0;
end;

/* ********************************************* */
/* анкета счета депо           SPDP_DEPO_ACCOUNT */
/* ********************************************* */
class (TDepoAdmoCLOB) TDepoAdmoClobDACNT
  class TData
    var AutoKey:integer          = 0,        // Автоинкремент
        Code:string              = "",       // Код счета/раздела
        BriefCode:string         = "",       // Короткий код
        Kind:integer             = 0,        // Вид счета(активный/пассивный)
        Type:integer             = 0,        // Тип счета(ЛОРО, НОСТРО и т.д.)
        CorAccount:string        = "",       // Корсчет, открытый у корреспондента
        IsBase:string            = "",       // Расчетные/базовые коротношения
        Owner:integer            = UNDEF_I,  // Номер владельца счета
        IncomeDelivery:string    = "",       // Способ получения доходов
        OrderDelivery:string     = "",       // Способ приема поручений
        StatementDelivery:string = "",       // Способ передачи информации
//        Operator:integer         = UNDEF_I,  // Оператор счета
//        C      = UNDEF_I,  // Попечитель счета
        Status:integer           = UNDEF_I;  // Статус счета(открыт/закрыт)
//        NumRights         = 0,        // Количество записей с правами оператора //151
//        NumSETTACC        = 0;        // Количество записей с платежными инструкциями
    var SettAcc = TArray();                  // Список СПИ
    var Acap = TArray();                     // Уполномоченные лица

//    macro Copy(data)
//      this.AutoKey           = data.AutoKey;
//      this.Code              = data.Code;
//      this.BriefCode         = data.BriefCode;
//      this.Kind              = data.Kind;
//      this.Type              = data.Type;
//      this.CorAccount        = data.CorAccount;
//      this.IsBase            = data.IsBase;
//      this.Owner             = data.Owner;
//      this.IncomeDelivery    = data.IncomeDelivery;
//      this.OrderDelivery     = data.OrderDelivery;
//      this.StatementDelivery = data.StatementDelivery;
//      this.Status            = data.Status;

//      var i = 0;
//      while (i < data.SetAcc)
//        this.SetAcc[i] = TSettAccData;
//        this.SetAcc[i].Copy(elem);
//      end;

//      i = 0;
//    end;
  end;
  // Параметры СПИ
  class TSettAccData(buff:variant)
    var SettAccID:integer        = UNDEF_I, //Уникальный идентификатор
        ShortName:string         = "",      //Короткое описание СПИ
        BeneficiaryID:integer    = UNDEF_I, //Идентификатор владельца счета
        RecName:string           = "",      //Название бенифициара
        CodeKind:integer         = 0,       //Вид кода получателя
        Code:string              = "",      //Код получателя
        INN:string               = "",      //ИНН бенифициара
        Chapter:integer          = 0,       //Глава счетов
        Account:string           = "",      //Счет куда перечисляются средства
        FIID:integer             = UNDEF_I, //Идентификатор ФИ (валюты)
        BankID:integer           = UNDEF_I, //Идент-р банка куда пер-ся средства
        BankName:string          = "",      //Наименование банка
        BankCodeKind:integer     = 0,       //Вид кода банка
        BankCode:string          = "",      //Код банка
        CorrAcc:string           = "",      //Корсчет
        BankCorrID:integer       = UNDEF_I, //Идентификатор корреспондента банка
        BankCorrName:string      = "",      //Наименование корреспондента банка
        BankCorrCodeKind:integer = 0,       //Вид кода корреспондента банка
        BankCorrCode:string      = "";      //Код корреспондента банка

    macro FillFromBuff(buff:variant)
      SettAccID        = buff.rec.SettAccID;
      ShortName        = buff.rec.ShortName;
      BeneficiaryID    = buff.rec.BeneficiaryID;
      RecName          = buff.rec.RecName;
      CodeKind         = buff.rec.CodeKind;
      Code             = buff.rec.Code;
      INN              = buff.rec.INN;
      Chapter          = buff.rec.Chapter;
      Account          = buff.rec.Account;
      FIID             = buff.rec.FIID;
      BankID           = buff.rec.BankID;
      BankName         = buff.rec.BankName;
      BankCodeKind     = buff.rec.BankCodeKind;
      BankCode         = buff.rec.BankCode;
      CorrAcc          = buff.rec.CorrAcc;
      BankCorrID       = buff.rec.BankCorrID;
      BankCorrName     = buff.rec.BankCorrName;
      BankCorrCodeKind = buff.rec.BankCorrCodeKind;
      BankCorrCode     = buff.rec.BankCorrCode;
    end;
    // одинаковы ли объекты?
    macro IsEqual(elem)
      return ((this.SettAccID        == elem.SettAccID       ) and
              (this.ShortName        == elem.ShortName       ) and
              (this.BeneficiaryID    == elem.BeneficiaryID   ) and
              (this.RecName          == elem.RecName         ) and
              (this.CodeKind         == elem.CodeKind        ) and
              (this.Code             == elem.Code            ) and
              (this.INN              == elem.INN             ) and
              (this.Chapter          == elem.Chapter         ) and
              (this.Account          == elem.Account         ) and
              (this.FIID             == elem.FIID            ) and
              (this.BankID           == elem.BankID          ) and
              (this.BankName         == elem.BankName        ) and
              (this.BankCodeKind     == elem.BankCodeKind    ) and
              (this.BankCode         == elem.BankCode        ) and
              (this.CorrAcc          == elem.CorrAcc         ) and
              (this.BankCorrID       == elem.BankCorrID      ) and
              (this.BankCorrName     == elem.BankCorrName    ) and
              (this.BankCorrCodeKind == elem.BankCorrCodeKind) and
              (this.BankCorrCode     == elem.BankCorrCode    )
             );
    end;
    // Тот ли элемент (проверка по ИД)?
    macro IsEqualElem(settAccID_:integer):bool
      return (this.SettAccID == settAccID_);
    end;

//    macro Copy(data)
//      this.SettAccID        = data.SettAccID;
//      this.ShortName        = data.ShortName;
//      this.BeneficiaryID    = data.BeneficiaryID;
//      this.RecName          = data.RecName;
//      this.CodeKind         = data.CodeKind;
//      this.Code             = data.Code;
//      this.INN              = data.INN;
//      this.Chapter          = data.Chapter;
//      this.Account          = data.Account;
//      this.FIID             = data.FIID;
//      this.BankID           = data.BankID;
//      this.BankName         = data.BankName;
//      this.BankCodeKind     = data.BankCodeKind;
//      this.BankCode         = data.BankCode;
//      this.CorrAcc          = data.CorrAcc;
//      this.BankCorrID       = data.BankCorrID;
//      this.BankCorrName     = data.BankCorrName;
//      this.BankCorrCodeKind = data.BankCorrCodeKind;
//      this.BankCorrCode     = data.BankCorrCode;
//    end;

    if (ValType(buff) != V_UNDEF)
      FillFromBuff(buff);
    end;
  end;

  // Блок Полномочия
// 2-ая очередь
//  class TAcapAuthData(nodeID:integer, kind:integer)
//    var AUNodeID:integer = 0, // Узел счета депо, где назначено полномочие
//        AuthKind:integer = 0; // Вид полномочия

//    macro IsEqual(elem):bool
//      return ((this.AUNodeID == elem.AUNodeID) and
//              (this.AuthKind == elem.AuthKind)
//             );
//    end;
//    // Тот ли элемент (проверка по ИД)?
//    macro IsEqualElem(AUNodeID_:integer):bool
//      return (this.AUNodeID == AUNodeID_);
//    end;
//    // инициализация
//    macro Init(nodeID:integer, kind:integer)
//      this.AUNodeID = nodeID;
//      this.AuthKind = kind;
//    end;

//    if ((ValType(nodeID) == V_INTEGER) and (ValType(kind)==V_INTEGER))
//      Init(nodeID, kind);
//    end;
//  end;

  // Блок Уполномоченные лица
  class TAcapData(buff:variant)
    var APID:integer         = 0,       // Идентификатор УЛ, НЕ из БД (для внутреннего использования в АО)
        APartyID:integer     = UNDEF_I, // Уполномоченное лицо
        Role:integer         = 0,       // Роль
        APartyGround:integer = 0;       // Документ/доверенность

    // 2-ая очередь var Auth:TArray = TArray();; // массив полномочий

    macro FillFromBuff(buff:variant)
      this.APID         = buff.rec.APID;
      this.APartyID     = buff.rec.APartyID;
      this.Role         = buff.rec.Role;
      this.APartyGround = buff.rec.APartyGround;
    end;
    macro IsEqual(elem):bool
      var stat = ((this.APID         == elem.APID        ) and
                  (this.APartyID     == elem.APartyID    ) and
                  (this.Role         == elem.Role        ) and
                  (this.APartyGround == elem.APartyGround)
                 );
// 2-ая очередь
//      if (stat)
//        // проверить полномочия
//        var authThis, authElem;
//        var i = 0;
//        var isEqual = false;

//        // ищем в нашем отличный от нашего
//        for (authThis, this.Auth)
//          isEqual = false;
//          for (authElem, elem.Auth)
//            if (authThis.isEqual(authElem))
//              isEqual = true;
//              break;
//            end;
//          end;
//          if (not isEqual)
//            stat = false;
//            break;
//          end;
//        end;

//        // в пришедшем ищем новую аутентификацию
//        if (stat)
//          for (authElem, elem.Auth)
//            isEqual = false;
//            for (authThis, this.Auth)
//              if (authElem.isEqual(authThis))
//                isEqual = true;
//                break;
//              end;
//            end;
//            if (not isEqual)
//              stat = false;
//              break;
//            end;
//          end;
//        end;
//      end;
      return stat;
    end;
    // Тот ли элемент (проверка по ИД)?
    macro IsEqualElem(APID_:integer):bool
      return (this.APID == APID_);
    end;

    if (ValType(buff) != V_UNDEF)
      FillFromBuff(buff);
    end;
  end;

  macro CreateTData()
    return TData();
  end;

  private macro FillFromDEPOACNT(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("depoacnt.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("depoacnt.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "AutoKey",           saveBuff, recBuff, "AutoKey",           overwrite);
    CopyValue(oldData, newData, "Code",              saveBuff, recBuff, "Code",              overwrite);
    CopyValue(oldData, newData, "BriefCode",         saveBuff, recBuff, "BriefCode",         overwrite);
    CopyValue(oldData, newData, "Kind",              saveBuff, recBuff, "Kind",              overwrite);
    CopyValue(oldData, newData, "Type",              saveBuff, recBuff, "Type",              overwrite);
    CopyValue(oldData, newData, "IncomeDelivery",    saveBuff, recBuff, "IncomeDelivery",    overwrite);
    CopyValue(oldData, newData, "OrderDelivery",     saveBuff, recBuff, "OrderDelivery",     overwrite);
    CopyValue(oldData, newData, "StatementDelivery", saveBuff, recBuff, "StatementDelivery", overwrite);
    CopyValue(oldData, newData, "Owner",             saveBuff, recBuff, "Owner",             overwrite, true);
    CopyValue(oldData, newData, "Status",            saveBuff, recBuff, "Status",            overwrite, true);
  end;

  private macro FillFromCORSCHEM(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("corschem.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("corschem.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "CorAccount", saveBuff, recBuff, "CorAccount", overwrite);
    CopyValue(oldData, newData, "IsBase",     saveBuff, recBuff, "IsBase",     overwrite);
  end;
  /* Вставка нового СПИ в массив */
  private macro InsertOneElemStAc(buff:variant, arr:TArray)
    // дубль не вставляем
    //if (IsSettAccInData(arr, buff.rec.SettAccID))
    if (IsElemInArrData(arr, buff.rec.SettAccID))
      return;
    end;
    // добавяляем элемент
    arr[arr.size] = TSettAccData(buff);
  end;

  private macro FillFromSETTACC(saveBuff:variant, recBuff:variant, overwrite:integer)
    if (saveBuff != null) // overwrite?
      InsertOneElemStAc(saveBuff, oldData.SettAcc);
    end;
    if (recBuff != null)
      InsertOneElemStAc(recBuff, newData.SettAcc);
    end;
  end;
  private macro FillFromSETTACCAddrBuff(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("settacc.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("settacc.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    FillFromSETTACC(saveBuff, recBuff, overwrite);
  end;

  private macro FillFromAllSETTACC(depoAcc:integer)
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT settacc.* "
                       +"  FROM dsettacc_dbt settacc "
                       +" WHERE settacc.t_SettAccID IN (SELECT sfssi.t_SetAccID "
                       +"                                 FROM dsfcontr_dbt c1, ddepoacnt_dbt d1, dsfssi_dbt sfssi "
                       +"                                WHERE d1.t_AutoKey=? "
                       +"                                  AND c1.t_Object=d1.t_Code "
                       +"                                  AND c1.t_ServKind= "+ String(PTSK_DEPOS)
                       +"                                  AND TO_NUMBER(sfssi.t_ObjectID)=c1.t_ID "
                       +"                                  AND sfssi.t_ObjectType= " + String(OBJTYPE_SFCONTR) + ") "
                       +"    OR settacc.t_SettAccID IN (SELECT dlssi.t_SettAccID "
                       +"                                 FROM dsfcontr_dbt c1, ddepoacnt_dbt d2, ddlssi_dbt dlssi "
                       +"                                WHERE d2.t_AutoKey=? "
                       +"                                  AND c1.t_Object=d2.t_Code "
                       +"                                  AND c1.t_ServKind="+ String(PTSK_DEPOS)
                       +"                                  AND TO_NUMBER(dlssi.t_ConID)=c1.t_ID)"
                       );
    cmd.addParam(depoAcc);
    cmd.addParam(depoAcc);

    dataSet = cmd.execute();

    while (dataSet.moveNext())
      FillFromSETTACC(null, dataSet, 0);
    end;

    onError(er)
      msgbox(cmd.GetErrorString(er));
  end;

  /* Блок Полномочия */
// 2-ая очередь
//  private macro FillFromACAPAU(buff:variant)
//    var acap:TAcapData;
//    var i = 0;

//    if ((oldData.Acap.size != 0) and (buff.rec.Action != 1)) /*DPACAP_INSERT*/
//      acap = oldData.Acap[oldData.Acap.size-1];
//      acap.Auth[acap.Auth.size] = TAcapAuthData(buff.rec.AUNodeID_From, buff.rec.AuthKind_From);
//    end;
//    if ((newData.Acap.size != 0) and (buff.rec.Action != 3))/*DPACAP_DELETE*/
//      acap = newData.Acap[newData.Acap.size-1];
//      acap.Auth[acap.Auth.size] = TAcapAuthData(buff.rec.AUNodeID, buff.rec.AuthKind);
//    end;
//  end;
//  private macro FillFromACAPAU_TMP(apID:integer)
//    var cmd, dataSet;

//    cmd = DL_RSDCommand("SELECT * FROM ddpacapau_tmp WHERE T_APID = ?");

//    cmd.AddParam(apID);
//
//    dataSet = cmd.execute();

//    while (dataSet.moveNext())
//      FillFromACAPAU(dataSet);
//    end;

//    onError(er)
//      msgbox(cmd.GetErrorString(er));
//  end;

  /* Блок Уполномоченные лица */
//  private macro FillFromACAP(buff:variant)
//    var oldI = oldData.Acap.size,
//        newI = newData.Acap.size;

//    if (buff.rec.Action != 1) /*DPACAP_INSERT*/
//      oldData.Acap[oldI] = TAcapData;
//      oldData.Acap[oldI].APID         = buff.rec.APID;//_From;
//      oldData.Acap[oldI].APartyID     = buff.rec.APartyID_From;
//      oldData.Acap[oldI].Role         = buff.rec.Role_From;
//      oldData.Acap[oldI].APartyGround = buff.rec.APartyGround_From;
//    end;
//    if (buff.rec.Action != 3)/*DPACAP_DELETE*/
//      newData.Acap[newI] = TAcapData;
//      newData.Acap[newI].APID         = buff.rec.APID;
//      newData.Acap[newI].APartyID     = buff.rec.APartyID;
//      newData.Acap[newI].Role         = buff.rec.Role;
//      newData.Acap[newI].APartyGround = buff.rec.APartyGround;
//    end;
//    // полномочия
//    // 2-ая очередь FillFromACAPAU_TMP(buff.rec.APID);
//  end;

//  private macro FillFromACAP_TMP(saveAddr:memaddr, recAddr:memaddr, overwrite)
//    var cmd, dataSet;

//    cmd = DL_RSDCommand("SELECT acap.* FROM ddpacap_tmp acap");

//    dataSet = cmd.execute();

//    while (dataSet.moveNext())
//      FillFromACAP(dataSet);
//    end;

//    onError(er)
//      msgbox(cmd.GetErrorString(er));
//  end;
  private macro InsertOneElemAcap(buff:variant, arr:TArray)
    // добавяляем элемент
    arr[arr.size] = TAcapData(buff);
  end;

  private macro FillFromACAP(saveBuff:variant, recBuff:variant)
    if (saveBuff != null) // overwrite?
      InsertOneElemAcap(saveBuff, oldData.Acap);
    end;
    if (recBuff != null)
      if (saveBuff != null) // если буфер сохраненной записи заполнен, то возьмем у него APID
        recBuff.rec.APID = saveBuff.rec.APID;
      end;
      InsertOneElemAcap(recBuff, newData.Acap);
    end;
  end;

  private macro FillFromACAPAddrBuff(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("dpacap.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("dpacap.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    FillFromACAP(saveBuff, recBuff);
  end;

  private macro FillFromEqACAP(overwrite:integer)
    const DPACAP_NOACTION = 0,
          DPACAP_INSERT   = 1,
          DPACAP_UPDATE   = 2,
          DPACAP_DELETE   = 3,
          DPACAP_CANCEL   = 4, // прекращение полномочий
          DPACAP_RESTORE  = 5; // восстановление полномочий

    var buff = TRecHandler("dpacap.dbt");
    var cmd, dataSet;
    cmd = DL_RSDCommand("SELECT acap.* FROM ddpacap_tmp acap");

    dataSet = cmd.execute();

    while (dataSet.moveNext())
      if (dataSet.Action == DPACAP_NOACTION)
        // для сохранения одинаковых буферов берем старый буфер, ибо в нем ID корректный
        buff.clear();
        buff.rec.APID         = dataSet.APID_From;
        buff.rec.APNodeID     = dataSet.APNodeID_From;
        buff.rec.APartyID     = dataSet.APartyID_From;
        buff.rec.Role         = dataSet.Role_From;
        buff.rec.Principal    = dataSet.Principal_From;
        buff.rec.FromDate     = dataSet.FromDate_From;
        buff.rec.ToDate       = dataSet.ToDate_From;
        buff.rec.APartyGround = dataSet.APartyGround_From;
        buff.rec.IsAllFI      = dataSet.IsAllFI_From;

        FillFromACAP(buff, buff); // одинаковые записи, одинаковый буфер
      elif ((dataSet.Action == DPACAP_INSERT) or ((dataSet.Action == DPACAP_UPDATE) and (dataSet.t_APID_From == 0)))
        //обновить APID на реальный
        var i = FindElemInArray(newData.Acap, dataSet.APID);
        if((i > -1) and
           (newData.Acap[i].IsEqual(dataSet))
          )
          //ищем в постоянном файле по альтернативному ключу
          var cmdacap = DL_RSDCommand(  " select t_APID "
                                      + "   from ddpacap_dbt "
                                      + "  where t_ApNodeID = ? "
                                      + "    and t_APartyID = ? "
                                      + "    and t_Role = ? "
                                      + "    and t_FromDate = ?"
                                     );
          cmdacap.AddParam(dataSet.ApNodeID);
          cmdacap.AddParam(dataSet.APartyID);
          cmdacap.AddParam(dataSet.Role);
          cmdacap.AddParam(dataSet.FromDate);

          var ds = cmdacap.Execute();
          if(ds.moveNext())
            newData.Acap[i].APID = ds.APID;
          end;
        end;

      elif ((dataSet.Action == DPACAP_UPDATE) or (dataSet.Action == DPACAP_DELETE) or (dataSet.Action == DPACAP_CANCEL))
        // надо сохранить старую запись до изменений, если она еще не вставлена в массив УЛ
        if (not IsElemInArrData(oldData.Acap, dataSet.APID_From))
          buff.clear();
          buff.rec.APID         = dataSet.APID_From;
          buff.rec.APNodeID     = dataSet.APNodeID_From;
          buff.rec.APartyID     = dataSet.APartyID_From;
          buff.rec.Role         = dataSet.Role_From;
          buff.rec.Principal    = dataSet.Principal_From;
          buff.rec.FromDate     = dataSet.FromDate_From;
          buff.rec.ToDate       = dataSet.ToDate_From;
          buff.rec.APartyGround = dataSet.APartyGround_From;
          buff.rec.IsAllFI      = dataSet.IsAllFI_From;

          FillFromACAP(buff, buff); // одинаковые записи, одинаковый буфер
        end;
      elif (dataSet.Action == DPACAP_RESTORE)
        // надо сохранить старую запись до изменений, если она еще не вставлена в массив УЛ
        if (not IsElemInArrData(oldData.Acap, dataSet.APID_From))
          buff.clear();
          buff.rec.APID         = dataSet.APID_From;
          buff.rec.APNodeID     = dataSet.APNodeID_From;
          buff.rec.APartyID     = dataSet.APartyID_From;
          buff.rec.Role         = dataSet.Role_From;
          buff.rec.Principal    = dataSet.Principal_From;
          buff.rec.FromDate     = dataSet.FromDate_From;
          buff.rec.ToDate       = dataSet.ToDate; // Действие ДО берем из нового!
          buff.rec.APartyGround = dataSet.APartyGround_From;
          buff.rec.IsAllFI      = dataSet.IsAllFI_From;

          FillFromACAP(buff, buff); // одинаковые записи, одинаковый буфер
        end;
      end;
    end;

    onError(er)
      msgbox(cmd.GetErrorString(er));
  end;

  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    FillFromBuffs(tableName, saveAddr, recAddr, overwrite); // базовый

    if ("depoacnt" == tableName)
      FillFromDEPOACNT(saveAddr, recAddr, overwrite);
    elif ("corschem" == tableName)
      FillFromCORSCHEM(saveAddr, recAddr, overwrite);
    elif ("settacc" == tableName)
      FillFromSETTACCAddrBuff(saveAddr, recAddr, overwrite);
    elif ("settaccAll" == tableName)
      FillFromAllSETTACC(overwrite); // В данном случае overwrite = DepoAcc
    elif ("dpacap" == tableName)
      FillFromACAPAddrBuff(saveAddr, recAddr, overwrite);
    elif ("dpacEQ" == tableName)
      FillFromEqACAP(overwrite);
//    elif ("copyNewData" == tableName)
//      CopyNewData();
    end;
  end;

  /* Отличаются ли буферы?*/
  macro IsChanges()
    var stat = ((oldData.AutoKey           != newData.AutoKey          ) or
                (oldData.Code              != newData.Code             ) or
                (oldData.BriefCode         != newData.BriefCode        ) or
                (oldData.Kind              != newData.Kind             ) or
                (oldData.Type              != newData.Type             ) or
                (oldData.CorAccount        != newData.CorAccount       ) or
                (oldData.IsBase            != newData.IsBase           ) or
                (oldData.Owner             != newData.Owner            ) or
                (oldData.IncomeDelivery    != newData.IncomeDelivery   ) or
                (oldData.OrderDelivery     != newData.OrderDelivery    ) or
                (oldData.StatementDelivery != newData.StatementDelivery) or
//                (oldData.Operator          != newData.Operator         ) or
//                (oldData.Curator           != newData.Curator          ) or
                (oldData.Status            != newData.Status           )
//                (oldData.NumRights         != newData.NumRights        ) or
//                (oldData.NumSETTACC        != newData.NumSETTACC       )
               );
    // проверим массивы
    // СПИ
    var i = 0;
    if (not stat)
      var elem:TSettAccData;
      i = 0;
      // ищем старого в новом и сверяем данные
      for (elem, oldData.SettAcc)
        //i = FindSettAcc(newData.SettAcc, elem.SettAccID);
        i = FindElemInArray(newData.SettAcc, elem.SettAccID);
        stat = ((i==-1) or (not elem.IsEqual(newData.SettAcc[i])));
        if (stat)
          break;
        end;
      end;
      // ищем нового в старом и если не найден, то отличается
      if (not stat)
        for (elem, newData.SettAcc)
          //stat = (not IsSettAccInData(oldData.SettAcc, elem.SettAccID));
          stat = (not IsElemInArrData(oldData.SettAcc, elem.SettAccID));
          if (stat)
            break;
          end;
        end;
      end;
    end;

    // УЛ
    if (not stat)
      var acap:TAcapData;
      i = 0;
      // ищем старого в новом и сверяем данные
      for (acap, oldData.Acap)
        i = FindElemInArray(newData.Acap, acap.APID);
        stat = ((i==-1) or (not acap.IsEqual(newData.Acap[i])));
        if (stat)
          break;
        end;
      end;
      // ищем нового в старом и если не найден, то отличается
      if (not stat)
        for (acap, newData.Acap)
          stat = (not IsElemInArrData(oldData.Acap, acap.APID));
          if (stat)
            break;
          end;
        end;
      end;
    end;

    return stat;
  end;
  /* Создает объект TSettAccData (СПИ) из xml-объекта*/
  macro CreateCopySettAcc(elem):TSettAccData
    var stac = TSettAccData;
    stac.SettAccID        = GenGetPropDefault(elem, "SettAccID",        stac.SettAccID       );
    stac.ShortName        = GenGetPropDefault(elem, "ShortName",        stac.ShortName       );
    stac.BeneficiaryID    = GenGetPropDefault(elem, "BeneficiaryID",    stac.BeneficiaryID   );
    stac.RecName          = GenGetPropDefault(elem, "RecName",          stac.RecName         );
    stac.CodeKind         = GenGetPropDefault(elem, "CodeKind",         stac.CodeKind        );
    stac.Code             = GenGetPropDefault(elem, "Code",             stac.Code            );
    stac.INN              = GenGetPropDefault(elem, "INN",              stac.INN             );
    stac.Chapter          = GenGetPropDefault(elem, "Chapter",          stac.Chapter         );
    stac.Account          = GenGetPropDefault(elem, "Account",          stac.Account         );
    stac.FIID             = GenGetPropDefault(elem, "FIID",             stac.FIID            );
    stac.BankID           = GenGetPropDefault(elem, "BankID",           stac.BankID          );
    stac.BankName         = GenGetPropDefault(elem, "BankName",         stac.BankName        );
    stac.BankCodeKind     = GenGetPropDefault(elem, "BankCodeKind",     stac.BankCodeKind    );
    stac.BankCode         = GenGetPropDefault(elem, "BankCode",         stac.BankCode        );
    stac.CorrAcc          = GenGetPropDefault(elem, "CorrAcc",          stac.CorrAcc         );
    stac.BankCorrID       = GenGetPropDefault(elem, "BankCorrID",       stac.BankCorrID      );
    stac.BankCorrName     = GenGetPropDefault(elem, "BankCorrName",     stac.BankCorrName    );
    stac.BankCorrCodeKind = GenGetPropDefault(elem, "BankCorrCodeKind", stac.BankCorrCodeKind);
    stac.BankCorrCode     = GenGetPropDefault(elem, "BankCorrCode",     stac.BankCorrCode    );
    return stac;
  end;
  /* Создает объект TAcapAuthData (Полномочия) из xml-объекта*/
//  macro CreateCopyAcapAuth(elem):TAcapAuthData
//    var auth = TAcapAuthData;

//    auth.AUNodeID = GenGetPropDefault(elem, "AUNodeID", auth.AUNodeID);
//    auth.AuthKind = GenGetPropDefault(elem, "AuthKind", auth.AuthKind);
//    return auth;
//  end;
  /* Создает объект TAcapData (УЛ) из xml-объекта*/
  macro CreateCopyAcap(elem):TAcapData
    var acap = TAcapData;

    acap.APID         = GenGetPropDefault(elem, "APID",         acap.APID        );
    acap.APartyID     = GenGetPropDefault(elem, "APartyID",     acap.APartyID    );
    acap.Role         = GenGetPropDefault(elem, "Role",         acap.Role        );
    acap.APartyGround = GenGetPropDefault(elem, "APartyGround", acap.APartyGround);

    // 2-ая очередь CopyArrayFromXmlObjToObj(acap, elem, "Auth", R2M(this, "CreateCopyAcapAuth"));
    return acap;
  end;

  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
    var obj;
    obj = GenGetProp(xmlObj, xmlObjName);
    CopyValueFromXmlObjToObj(data, obj, "AutoKey"          );
    CopyValueFromXmlObjToObj(data, obj, "Code"             );
    CopyValueFromXmlObjToObj(data, obj, "BriefCode"        );
    CopyValueFromXmlObjToObj(data, obj, "Kind"             );
    CopyValueFromXmlObjToObj(data, obj, "Type"             );
    CopyValueFromXmlObjToObj(data, obj, "CorAccount"       );
    CopyValueFromXmlObjToObj(data, obj, "IsBase"           );
    CopyValueFromXmlObjToObj(data, obj, "Owner"            );
    CopyValueFromXmlObjToObj(data, obj, "IncomeDelivery"   );
    CopyValueFromXmlObjToObj(data, obj, "OrderDelivery"    );
    CopyValueFromXmlObjToObj(data, obj, "StatementDelivery");
    //CopyValueFromXmlObjToObj(data, obj, "Operator"         );
    //CopyValueFromXmlObjToObj(data, obj, "Curator"          );
    CopyValueFromXmlObjToObj(data, obj, "Status"           );

    CopyArrayFromXmlObjToObj(data, obj, "SettAcc", R2M(this, "CreateCopySettAcc"));
    CopyArrayFromXmlObjToObj(data, obj, "Acap",    R2M(this, "CreateCopyAcap"   ));
    // нет объекта. Заглушка
    onError(er)
      ;
  end;

  // идентификатор данных
  macro GetReqID()
    return "DepoAccount";
  end;
  // ---------------------------------------
  // Методы для вывода на экран
  private macro GetIsBaseValue(Kind:integer, CorAccount:string, IsBase:string):string
    var retVal = "";
    if (Kind == DP_SIDEBALANCE_ACTIVE)
      if (CorAccount != "")
        retVal = "Ностро " + IIF(IsBase == "", "расчетный", "базовый");;
      end;
    else
      if (CorAccount != "")
        retVal = "Лоро " + IIF(IsBase == "", "расчетный", "базовый");
      end;
    end;
    return retVal;
  end;

  private macro GetObjKCodeName(codekind:integer):string
    var name:string = "";
    var errMSg:string = "";
    if (SQL_ExecuteSelect(@name, "SELECT t_name as t_retValue FROM dobjkcode_dbt WHERE T_OBJECTTYPE = 3 AND T_CODEKIND = ?", codeKind, errMSg))
      return name;
    end;

    if (errMSg != "")
      msgbox(errMSg);
    end;
    return "";
  end;

  private macro GetChapterName(chapter:integer):string
    var name:string = "";
    var errMSg:string = "";
    if (SQL_ExecuteSelect(@name, "SELECT t_name as t_retValue FROM dobchaptr_dbt WHERE t_Chapter = ?", chapter, errMSg))
      return name;
    end;

    if (errMSg != "")
      msgbox(errMSg);
    end;
    return "";
  end;

  private macro WriteOnePI(nameArr:TArray, oldArr:TArray, newArr:TArray, oldData_:TSettAccData, newData_:TSettAccData)
    // создадим объекты, ибо можно передать null, а разыменование null'я - ошибка
    var oldData:TSettAccData, newData:TSettAccData;

    if (oldData_ == null)
      oldData = TSettAccData;
    else
      oldData = oldData_;
    end;
    if (newData_ == null)
      newData = TSettAccData;
    else
      newData = newData_;
    end;
    SetArrayForm("СПИ",                           IIF(oldData!=null, oldData.ShortName, ""),
                                                  IIF(newData!=null, newData.ShortName, ""), nameArr, oldArr, newArr);
    SetArrayForm("Название получателя",           IIF(oldData!=null, oldData.RecName, ""),
                                                  IIF(newData!=null, newData.RecName, ""), nameArr, oldArr, newArr);
    SetArrayForm("Вид кода получателя",           IIF(oldData!=null, GetObjKCodeName(oldData.CodeKind), ""),
                                                  IIF(newData!=null, GetObjKCodeName(newData.CodeKind), ""), nameArr, oldArr, newArr);
    SetArrayForm("Код получателя",                IIF(oldData!=null, oldData.Code, ""),
                                                  IIF(newData!=null, newData.Code, ""), nameArr, oldArr, newArr);
    SetArrayForm("ИНН получателя",                IIF(oldData!=null, oldData.INN, ""),
                                                  IIF(newData!=null, newData.INN, ""), nameArr, oldArr, newArr);
    SetArrayForm("Глава счетов",                  IIF(oldData!=null, GetChapterName(oldData.Chapter), ""),
                                                  IIF(newData!=null, GetChapterName(newData.Chapter), ""), nameArr, oldArr, newArr);
    SetArrayForm("Счет",                          IIF(oldData!=null, oldData.Account, ""),
                                                  IIF(newData!=null, newData.Account, ""), nameArr, oldArr, newArr);
    SetArrayForm("Валюта",                        IIF(oldData!=null, ПолучитьИмяФинИн(oldData.FIID), ""),
                                                  IIF(newData!=null, ПолучитьИмяФинИн(newData.FIID),""), nameArr, oldArr, newArr);
    SetArrayForm("Банк получателя",               IIF(oldData!=null, oldData.BankName, ""),
                                                  IIF(newData!=null, newData.BankName, ""), nameArr, oldArr, newArr);
    SetArrayForm("Вид кода банка получателя",     IIF(oldData!=null, GetObjKCodeName(oldData.BankCodeKind), ""),
                                                  IIF(newData!=null, GetObjKCodeName(newData.BankCodeKind), ""), nameArr, oldArr, newArr);
    SetArrayForm("Код банка получателя",          IIF(oldData!=null, oldData.BankCode, ""),
                                                  IIF(newData!=null, newData.BankCode, ""), nameArr, oldArr, newArr);
    SetArrayForm("Корсчет",                       IIF(oldData!=null, oldData.CorrAcc, ""),
                                                  IIF(newData!=null, newData.CorrAcc, ""), nameArr, oldArr, newArr);
    SetArrayForm("Корреспондент банка",           IIF(oldData!=null, oldData.BankCorrName, ""),
                                                  IIF(newData!=null, newData.BankCorrName, ""), nameArr, oldArr, newArr);
    SetArrayForm("Вид кода корреспондента банка", IIF(oldData!=null, GetObjKCodeName(oldData.BankCorrCodeKind), ""),
                                                  IIF(newData!=null, GetObjKCodeName(newData.BankCorrCodeKind), ""), nameArr, oldArr, newArr);
    SetArrayForm("Код корреспондента банка",      IIF(oldData!=null, oldData.BankCorrCode, ""),
                                                  IIF(newData!=null, newData.BankCorrCode, ""), nameArr, oldArr, newArr);
  end;
  /* Блок СПИ */
  private macro WriteSetAccArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    if ((oldData.SettAcc.size != 0) or (newData.SettAcc.size != 0))
      // по старой ищем новую и добавляем
      var stac:TSettAccData;
      var i = 0;
      var flag:bool = false;

      for (stac, oldData.SettAcc)
        if (not flag)
          // вставляем разделитель для отделения СПИ друг от друга
          SetArrayForm("Банковские реквизиты:", " ", " ", nameArr, oldArr, newArr);
          flag = true;
        else
          SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
        end;
        //i = FindSettAcc(newData.SettAcc, stac.SettAccID);
        i = FindElemInArray(newData.SettAcc, stac.SettAccID);
        var newStAc:TSettAccData = null;
        if (i != -1)
          newStAc = newData.SettAcc[i];
        end;

        WriteOnePI(nameArr, oldArr, newArr, stac, newStAc);
      end;
      // по новому массиву ищем записи, у которых нет парной в старой
      for (stac, newData.SettAcc)
        //if (not IsSettAccInData(oldData.SettAcc, stac.SettAccID))
        if (not IsElemInArrData(oldData.SettAcc, stac.SettAccID))
          if (not flag)
            // вставляем разделитель для отделения СПИ друг от друга
            SetArrayForm("Банковские реквизиты:", " ", " ", nameArr, oldArr, newArr);
            flag = true;
          else
            SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
          end;
          WriteOnePI(nameArr, oldArr, newArr, null, stac);
        end;
      end;
    end;
  end;

  /*Получить строку Документ/Доверенность УЛ*/
  private macro GetSpGroundForWrite(Role:integer, partyGround:integer):string
    var str:string = "";

    if (partyGround != 0)
      var errMSg:string = "";
      if(Role == DEPOACAPROLE_MORTGAGEE)
        if (SQL_ExecuteSelect(@str, "SELECT TRIM(spg.t_Xld||' '||to_Char(spg.t_RegistrDate, 'DD.MM.YYYY')) as t_retValue FROM dspground_dbt spg WHERE spg.t_SPgroundID = ?",
                              partyGround, errMSg))
          return str;
        end;
      else

        if (SQL_ExecuteSelect(@str, "SELECT TRIM(spg.t_Xld||' '||to_Char(spg.t_RegistrDate, 'DD.MM.YYYY')) as t_retValue FROM ddpprocur_dbt pp, dspground_dbt spg WHERE pp.t_ProcurID = ? AND spg.t_SPgroundID = pp.t_SPgroundID",
                              partyGround, errMSg))
          return str;
        end;
      end;

      if (errMSg != "")
        msgbox(errMSg);
      end;
      return "";
    end;
    return str;
  end;
// 2-ая очередь
//  private macro GetAuthName(arr:TArray, i:@integer):string
//    var authKind:string = "";
//    var saveAuthNodeID = arr[i].AUNodeID;

//    while (i < arr.size)
//      if (arr[i].AUNodeID != saveAuthNodeID)
//        i = i - 1; // вернемся на пред. состояние
//        break;
//      else
//        if (authKind != "")
//          authKind = authKind + ",";
//        end;
//        authKind = authKind + arr[i].AuthKind;
//      end;
//      i = i + 1;
//    end;

//    var str:string = "";

//    if (authKind != "")
//      var errMSg:string = "";
//      if (SQL_ExecuteSelect(@str, "SELECT CAST(wm_concat(t_Name) as VARCHAR2(511)) as t_RetValue FROM dllvalues_dbt WHERE t_List = 1211 AND t_Element IN("+authKind+") GROUP BY t_List", errMSg))
//        return str;
//      end;

//      if (errMSg != "")
//        msgbox(errMSg);
//      end;
//    end;

//    return "";
//  end;
//  /* Полномочия */
// 2-ая очередь
//  private macro WriteAcapAuth(nameArr:TArray, oldArr:TArray, newArr:TArray, oldInd:@integer, newInd:@integer, oldAuth:TArray, newAuth:TArray)
////    Код узла
////    Полномочия
//    var AUNodeID = 0;
//    if (oldInd != -1)
//      AUNodeID = oldAuth[oldInd].AUNodeID;
//    elif (newInd != -1)
//      AUNodeID = newAuth[newInd].AUNodeID;
//    end;
//    if (AUNodeID != 0)
//      var nodeCode = GetDacnt(AUNodeID).rec.BriefCode;
//      var oldAuthName = "",
//          newAuthName = "";
//      if (oldInd != -1)
//        oldAuthName = GetAuthName(oldAuth, @oldInd);
//      end;
//      if (newInd != -1)
//        newAuthName = GetAuthName(newAuth, @newInd);
//      end;
//
//      SetArrayForm("Код узла",   IIF(oldAuthName=="", "", nodeCode), IIF(newAuthName=="", "", nodeCode), nameArr, oldArr, newArr);
//      SetArrayForm("Полномочия", oldAuthName, newAuthName, nameArr, oldArr, newArr);
//    end;
//  end;
// 2-ая очередь
//  private macro WriteAcapAuthArray(nameArr:TArray, oldArr:TArray, newArr:TArray, oldAcap:TAcapData, newAcap:TAcapData, iRep:integer, operdate:date)
//    var auth:TAcapAuthData;
//    var i = 0, j = 0;
//    var flag:bool = false;

//    // отсортируем массивы по возрастанию AUNodeID
//    qsort(oldAcap.Auth, "cmdAcapAuth");
//    qsort(newAcap.Auth, "cmdAcapAuth");

//    j = 0;
//    while (j < oldAcap.Auth.size)
//      if (not flag)
//        // вставляем разделитель для отделения блока УЛ друг от друга
//        SetArrayForm("Полномочия:", " ", " ", nameArr, oldArr, newArr);
//        flag = true;
//      else
//        SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
//      end;
//      i = FindElemInArray(newAcap.Auth, oldAcap.Auth[j].AUNodeID);

//      WriteAcapAuth(nameArr, oldArr, newArr, @j, @i, oldAcap.Auth, newAcap.Auth);
//      j = j + 1;
//    end;
//    // по новому массиву ищем записи, у которых нет парной в старой
//    j = 0;
//    while (j < newAcap.Auth.size)
//      if (not IsElemInArrData(oldAcap.Auth, newAcap.Auth[j].AUNodeID))
//        if (not flag)
//          // вставляем разделитель для отделения блока УЛ друг от друга
//          SetArrayForm("Полномочия:", " ", " ", nameArr, oldArr, newArr);
//          flag = true;
//        else
//          SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
//        end;
//        WriteAcapAuth(nameArr, oldArr, newArr, -1, @j, null, newAcap.Auth);
//      end;
//      j = j + 1;
//    end;
//  end;
/*
  private macro WriteOneAcap(nameArr:TArray, oldArr:TArray, newArr:TArray, oldData_:TAcapData, newData_:TAcapData, iRep:integer, operdate:date)
    // создадим объекты, ибо можно передать null, а разыменование null'я - ошибка
    var oldData:TAcapData, newData:TAcapData;

    if (oldData_ == null)
      oldData = TAcapData;
    else
      oldData = oldData_;
    end;
    if (newData_ == null)
      newData = TAcapData;
    else
      newData = newData_;
    end;
    SetArrayForm("Субъект",               IIF(oldData_!=null, WriteFullParty(oldData.APartyID, iRep, operdate), ""),
                                          IIF(newData_!=null, WriteFullParty(newData.APartyID, iRep, operdate), ""), nameArr, oldArr, newArr);
    SetArrayForm("Роль",                  IIF(oldData_!=null, name_alg(3266 /*ALG_DEPOACAPROLE*/, oldData.Role), ""),
                                          IIF(newData_!=null, name_alg(3266 /*ALG_DEPOACAPROLE*/, newData.Role), ""), nameArr, oldArr, newArr);
    SetArrayForm("Документ/Доверенность", IIF(oldData_!=null, GetSpGroundForWrite(oldData.APartyGround), ""),
                                          IIF(newData_!=null, GetSpGroundForWrite(newData.APartyGround), ""), nameArr, oldArr, newArr);
    // полномочия
    // 2-ая очередь WriteAcapAuthArray(nameArr, oldArr, newArr, oldData, newData, iRep, operdate);
  end;
*/
  private macro WriteOneAcap(nameArr:TArray, oldArr:TArray, newArr:TArray, oldData_:TAcapData, newData_:TAcapData, iRep:integer, operdate:date, flag:@bool)
    // создадим объекты, ибо можно передать null, а разыменование null'я - ошибка
    var oldData:TAcapData, newData:TAcapData;

    if (oldData_ == null)
      oldData = TAcapData;
    else
      oldData = oldData_;
    end;
    if (newData_ == null)
      newData = TAcapData;
    else
      newData = newData_;
    end;
    if (not flag)
      // вставляем разделитель для отделения блока УЛ друг от друга
      SetArrayForm("Уполномоченные лица:", " ", " ", nameArr, oldArr, newArr);
      flag = true;
    else
      SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
    end;

    SetArrayForm("Субъект",               IIF(oldData_!=null, WriteFullParty(oldData.APartyID, iRep, operdate), ""),
                                          IIF(newData_!=null, WriteFullParty(newData.APartyID, iRep, operdate), ""), nameArr, oldArr, newArr);
    SetArrayForm("Роль",                  IIF(oldData_!=null, name_alg(3266 /*ALG_DEPOACAPROLE*/, oldData.Role), ""),
                                          IIF(newData_!=null, name_alg(3266 /*ALG_DEPOACAPROLE*/, newData.Role), ""), nameArr, oldArr, newArr);
    SetArrayForm("Документ/Доверенность", IIF(oldData_!=null, GetSpGroundForWrite(oldData.Role, oldData.APartyGround), ""),
                                          IIF(newData_!=null, GetSpGroundForWrite(newData.Role, newData.APartyGround), ""), nameArr, oldArr, newArr);
    // полномочия
    // 2-ая очередь WriteAcapAuthArray(nameArr, oldArr, newArr, oldData, newData, iRep, operdate);
  end;
  /* Блок Уполномоченные лица */
  private macro WriteAcapArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    if ((oldData.Acap.size != 0) or (newData.Acap.size != 0))
      // по старой ищем новую и добавляем
      var acap:TAcapData;
      var i = 0;
      var flag:bool = false;

      // 1. выведем те записи, у которых есть связь между старой и новой
      // 2. выведем записи, которые удалены
      // 3. выведем записи, которые добавлены

      // 1. существующие и в old и new
      for (acap, oldData.Acap)
        i = FindElemInArray(newData.Acap, acap.APID);

        if (i != -1)
          WriteOneAcap(nameArr, oldArr, newArr, acap, newData.Acap[i], iRep, operdate, @flag);
        end;
      end;
      // 2. удаленные
      for (acap, oldData.Acap)
        if (not IsElemInArrData(newData.Acap, acap.APID))
          WriteOneAcap(nameArr, oldArr, newArr, acap, null, iRep, operdate, @flag);
        end;
      end;
      // по новому массиву ищем записи, у которых нет парной в старой
      for (acap, newData.Acap)
        if (not IsElemInArrData(oldData.Acap, acap.APID))
          WriteOneAcap(nameArr, oldArr, newArr, null, acap, iRep, operdate, @flag);
        end;
      end;
    end;
  end;

  /* Блок Уполномоченные лица */
/*  private macro WriteAcapArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    if ((oldData.Acap.size != 0) or (newData.Acap.size != 0))
      // по старой ищем новую и добавляем
      var acap:TAcapData;
      var i = 0;
      var flag:bool = false;

      for (acap, oldData.Acap)
        if (not flag)
          // вставляем разделитель для отделения блока УЛ друг от друга
          SetArrayForm("Уполномоченные лица:", " ", " ", nameArr, oldArr, newArr);
          flag = true;
        else
          SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
        end;
        i = FindElemInArray(newData.Acap, acap.APID);
        var newAcap:TAcapData = null;
        if (i != -1)
          newAcap = newData.Acap[i];
        end;

        WriteOneAcap(nameArr, oldArr, newArr, acap, newAcap, iRep, operdate);
      end;
      // по новому массиву ищем записи, у которых нет парной в старой
      for (acap, newData.Acap)
        if (not IsElemInArrData(oldData.Acap, acap.APID))
          if (not flag)
            // вставляем разделитель для отделения блока УЛ друг от друга
            SetArrayForm("Уполномоченные лица:", " ", " ", nameArr, oldArr, newArr);
            flag = true;
          else
            SetArrayForm(" ", " ", " ", nameArr, oldArr, newArr);
          end;
          WriteOneAcap(nameArr, oldArr, newArr, null, acap, iRep, operdate);
        end;
      end;
    end;
  end; */
  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    // 1. name по индексу соответсвует old и new
    // 2. если name пустой, то в интерфейс не выводим
    // 3. если old или new пустой, то не задан

    SetArrayForm("AutoKey", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Номер", oldData.Code, newData.Code, nameArr, oldArr, newArr);
    SetArrayForm("Короткий номер", oldData.BriefCode, newData.BriefCode, nameArr, oldArr, newArr);
    SetArrayForm("Вид", GetKindValue(oldData.Kind), GetKindValue(newData.Kind), nameArr, oldArr, newArr);
    SetArrayForm("Тип", GetTypeValue(oldData.Type, iRep), GetTypeValue(newData.Type, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Код у корреспондента", oldData.CorAccount, newData.CorAccount, nameArr, oldArr, newArr);
    SetArrayForm("Тип у корреспондента", GetIsBaseValue(oldData.Kind, oldData.CorAccount, oldData.IsBase), GetIsBaseValue(newData.Kind, newData.CorAccount, newData.IsBase),            nameArr, oldArr, newArr);
    SetArrayForm("Владелец", WriteFullParty(oldData.Owner, iRep, operdate), WriteFullParty(newData.Owner, iRep, operdate), nameArr, oldArr, newArr);
    SetArrayForm("Способы получения доходов", WriteDelivery(151/*TA_INC_DEL*/, oldData.IncomeDelivery, iRep),
                                              WriteDelivery(151/*TA_INC_DEL*/, newData.IncomeDelivery, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Способы приема поручений", WriteDelivery(152/*TA_ORD_DEL*/, oldData.OrderDelivery, iRep),
                                             WriteDelivery(152/*TA_ORD_DEL*/, newData.OrderDelivery, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Способы передачи информации", WriteDelivery(152/*TA_STAT_DEL*/, oldData.StatementDelivery, iRep),
                                                WriteDelivery(152/*TA_STAT_DEL*/, newData.StatementDelivery, iRep), nameArr, oldArr, newArr);
//    SetArrayForm("Оператор", WriteFullParty(oldData.Operator, iRep, operdate), WriteFullParty(newData.Operator, iRep, operdate), nameArr, oldArr, newArr);
//    SetArrayForm("Попечитель", WriteFullParty(oldData.Curator, iRep, operdate), WriteFullParty(newData.Curator, iRep, operdate), nameArr, oldArr, newArr);
    SetArrayForm("Статус",                     name_alg(3103, oldData.Status), name_alg(3103, newData.Status), nameArr, oldArr, newArr);
//    SetArrayForm("", oldData.NumRights, newData.NumRights, nameArr, oldArr, newArr);

    // SettAcc - СПИ
    WriteSetAccArray(nameArr, oldArr, newArr, iRep, operdate);
    // Acap - Уполномоченные лица
    WriteAcapArray(nameArr, oldArr, newArr, iRep, operdate);
  end;

  /* Получить идентификатор отмененного полномочия */
  macro GetCancelAcapID()
    for (var acap, oldData.Acap)
      if (not IsElemInArrData(newData.Acap, acap.APID))
        return acap.APID;
      end;
    end;

    return 0;
  end;

  macro GetAcapRole()
    for (var acap, newData.Acap)
      if (IsElemInArrData(newData.Acap, acap.APID))
        return acap.Role;
      end;
    end;

    return 0;
  end;

  macro GetAcapPartyID()
    for (var acap, newData.Acap)
      if (IsElemInArrData(newData.Acap, acap.APID))
        return acap.APartyID;
      end;
    end;

    return 0;
  end;

  InitTDepoAdmoCLOB;
  // записи
  oldData = TData;
  newData = TData;
end;

/* ********************************************* */
/* раздел счета депо         SPDP_DEPO_PARTITION */
/* ********************************************* */
class (TDepoAdmoCLOB) TDepoAdmoClobDPART
  class TData
    var AutoKey           = 0,        // Автоинкремент
        Root              = 0,        // ИД счета-родителя
        RootType          = 0,        // Тип счета-родителя
        Kind              = 0,        // Вид счета(активный/пассивный)
        Owner             = UNDEF_I,  // Номер владельца счета
        BriefCode         = "",       // Короткий код
        IncomeDelivery    = "",       // Способ получения доходов
        OrderDelivery     = "",       // Способ приема поручений
        StatementDelivery = "",       // Способ передачи информации
        //Operator          = UNDEF_I,  // Оператор счета
        AvoirStatus       = UNDEF_I,  // Вид блокировки
        Status            = UNDEF_I,  // Статус счета(открыт/закрыт)
        PawnRightMeeting     = 0,           // Право на участие в собрании акционеров принадлежит
        PawnRightIncome      = 0,           // Право на получение дохода по ценным бумагам принадлежит
        PawnRightGlobal      = 0,           // Права, приобретённые в результате КД, не требующего участия акционера (конвертация, сплит, дробление, консолидация, бонусная эмиссия и др.), принадлежат
        PawnAssignmentRights = 0,           // Уступка Залогодержателем прав по договору залога ценных бумаг без согласия Залогодателя
        PawnSubsequent       = 0,           // Последующий залог ценных бумаг без согласия залогодержателя
        PawnRecoveryKind     = 0,           // Обращение взыскания на заложенные ценные бумаги
        PawnRecoveryDate     = date(0,0,0), // Дата, начиная с которой залогодержатель вправе обратить взыскание (с правом подавать в Депозитарий подписанные Залогодержателем поручения)
        PawnAddConditions    = "",          // Дополнительные условия залога
        NumRights         = 0;        // Количество записей с правами оператора
  end;

  macro CreateTData()
    return TData();
  end;

  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    FillFromBuffs(tableName, saveAddr, recAddr, overwrite); // базовый

    if ("depoacnt" == tableName)
      var saveBuff:TRecHandler = null,
          recBuff:TRecHandler  = null;

      if (ValType(saveAddr) == V_MEMADDR)
        saveBuff = TRecHandler("depoacnt.dbt");
        saveBuff.SetRecordAddr(saveAddr);
      end;
      if (ValType(recAddr) == V_MEMADDR)
        recBuff = TRecHandler("depoacnt.dbt");
        recBuff.SetRecordAddr(recAddr);
      end;
      CopyValue(oldData, newData, "AutoKey",           saveBuff, recBuff, "AutoKey",           overwrite);
      CopyValue(oldData, newData, "Root",              saveBuff, recBuff, "Root",              overwrite);
      CopyValue(oldData, newData, "Kind",              saveBuff, recBuff, "Kind",              overwrite);
      CopyValue(oldData, newData, "BriefCode",         saveBuff, recBuff, "BriefCode",         overwrite);
      CopyValue(oldData, newData, "IncomeDelivery",    saveBuff, recBuff, "IncomeDelivery",    overwrite);
      CopyValue(oldData, newData, "OrderDelivery",     saveBuff, recBuff, "OrderDelivery",     overwrite);
      CopyValue(oldData, newData, "StatementDelivery", saveBuff, recBuff, "StatementDelivery", overwrite);
      CopyValue(oldData, newData, "AvoirStatus",       saveBuff, recBuff, "AvoirStatus",       overwrite);
      CopyValue(oldData, newData, "Owner",             saveBuff, recBuff, "Owner",             overwrite, true);
      CopyValue(oldData, newData, "Status",            saveBuff, recBuff, "Status",            overwrite, true);
      CopyValue(oldData, newData, "PawnRightMeeting",    saveBuff, recBuff, "PawnRightMeeting",    overwrite);
      CopyValue(oldData, newData, "PawnRightIncome",     saveBuff, recBuff, "PawnRightIncome",     overwrite);
      CopyValue(oldData, newData, "PawnRightGlobal",     saveBuff, recBuff, "PawnRightGlobal",     overwrite);
      CopyValue(oldData, newData, "PawnAssignmentRights",saveBuff, recBuff, "PawnAssignmentRights",overwrite);
      CopyValue(oldData, newData, "PawnSubsequent",      saveBuff, recBuff, "PawnSubsequent",      overwrite);
      CopyValue(oldData, newData, "PawnRecoveryKind",    saveBuff, recBuff, "PawnRecoveryKind",    overwrite);
      CopyValue(oldData, newData, "PawnRecoveryDate",    saveBuff, recBuff, "PawnRecoveryDate",    overwrite);
      CopyValue(oldData, newData, "PawnAddConditions",   saveBuff, recBuff, "PawnAddConditions",   overwrite);

      if (overwrite != 0)
        if (recBuff != null)
          newData.RootType = GetDacnt(recBuff.rec.Root).rec.Type;
        end;
        if (saveBuff != null)
          oldData.RootType = GetDacnt(saveBuff.rec.Root).rec.Type;
        end;
      else
        if ((newData.RootType == 0) and (oldData.RootType == 0))
          if (recBuff != null)
            newData.RootType = GetDacnt(recBuff.rec.Root).rec.Type;
          end;
          if (saveBuff != null)
            oldData.RootType = GetDacnt(saveBuff.rec.Root).rec.Type;
          end;
        end;
      end;
    end;
  end;

  /* Отличаются ли буферы?*/
  macro IsChanges()
    return ((oldData.AutoKey           != newData.AutoKey          ) or
            (oldData.Root              != newData.Root             ) or
            (oldData.RootType          != newData.RootType         ) or
            (oldData.Kind              != newData.Kind             ) or
            (oldData.Owner             != newData.Owner            ) or
            (oldData.BriefCode         != newData.BriefCode        ) or
            (oldData.IncomeDelivery    != newData.IncomeDelivery   ) or
            (oldData.OrderDelivery     != newData.OrderDelivery    ) or
            (oldData.StatementDelivery != newData.StatementDelivery) or
            //(oldData.Operator          != newData.Operator         ) or
            (oldData.AvoirStatus       != newData.AvoirStatus      ) or
            (oldData.Status            != newData.Status           ) or
            (oldData.PawnRightMeeting     != newData.PawnRightMeeting     ) or
            (oldData.PawnRightIncome      != newData.PawnRightIncome      ) or
            (oldData.PawnRightGlobal      != newData.PawnRightGlobal      ) or
            (oldData.PawnAssignmentRights != newData.PawnAssignmentRights ) or
            (oldData.PawnSubsequent       != newData.PawnSubsequent       ) or
            (oldData.PawnRecoveryKind     != newData.PawnRecoveryKind     ) or
            (oldData.PawnRecoveryDate     != newData.PawnRecoveryDate     ) or
            (oldData.PawnAddConditions    != newData.PawnAddConditions    ) or
            (oldData.NumRights         != newData.NumRights        )
           );
  end;

  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
    var obj;
    obj = GenGetProp(xmlObj, xmlObjName);
    CopyValueFromXmlObjToObj(data, obj, "AutoKey"          );
    CopyValueFromXmlObjToObj(data, obj, "Root"             );
    CopyValueFromXmlObjToObj(data, obj, "RootType"         );
    CopyValueFromXmlObjToObj(data, obj, "Kind"             );
    CopyValueFromXmlObjToObj(data, obj, "Owner"            );
    CopyValueFromXmlObjToObj(data, obj, "BriefCode"        );
    CopyValueFromXmlObjToObj(data, obj, "IncomeDelivery"   );
    CopyValueFromXmlObjToObj(data, obj, "OrderDelivery"    );
    CopyValueFromXmlObjToObj(data, obj, "StatementDelivery");
    //CopyValueFromXmlObjToObj(data, obj, "Operator"         );
    CopyValueFromXmlObjToObj(data, obj, "AvoirStatus"      );
    CopyValueFromXmlObjToObj(data, obj, "Status"           );
    CopyValueFromXmlObjToObj(data, obj, "PawnRightMeeting"    );
    CopyValueFromXmlObjToObj(data, obj, "PawnRightIncome"     );
    CopyValueFromXmlObjToObj(data, obj, "PawnRightGlobal"     );
    CopyValueFromXmlObjToObj(data, obj, "PawnAssignmentRights");
    CopyValueFromXmlObjToObj(data, obj, "PawnSubsequent"      );
    CopyValueFromXmlObjToObj(data, obj, "PawnRecoveryKind"    );
    CopyValueFromXmlObjToObj(data, obj, "PawnRecoveryDate", date(0,0,0) );
    CopyValueFromXmlObjToObj(data, obj, "PawnAddConditions"   );
    CopyValueFromXmlObjToObj(data, obj, "NumRights"        );
    // нет объекта. Заглушка
    onError(er)
      ;
  end;
  // идентификатор данных
  macro GetReqID()
    return "DepoPartition";
  end;
  // ---------------------------------------
  // Методы для вывода на экран

  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    // 1. name по индексу соответсвует old и new
    // 2. если name пустой, то в интерфейс не выводим
    // 3. если old или new пустой, то не задан

    SetArrayForm("AutoKey", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Счет депо", GetDacnt(oldData.Root).rec.Code, GetDacnt(newData.Root).rec.Code, nameArr, oldArr, newArr);
    SetArrayForm("Тип счета депо", GetTypeValue(oldData.RootType, iRep), GetTypeValue(newData.RootType, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Вид", GetKindValue(oldData.Kind), GetKindValue(newData.Kind), nameArr, oldArr, newArr);
    SetArrayForm("Владелец", WriteFullParty(oldData.Owner, iRep, operdate), WriteFullParty(newData.Owner, iRep, operdate), nameArr, oldArr, newArr);
    SetArrayForm("Номер раздела", oldData.BriefCode, newData.BriefCode, nameArr, oldArr, newArr);
    SetArrayForm("Способы получения доходов", WriteDelivery(151/*TA_INC_DEL*/, oldData.IncomeDelivery, iRep),
                                              WriteDelivery(151/*TA_INC_DEL*/, newData.IncomeDelivery, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Способы приема поручений", WriteDelivery(152/*TA_ORD_DEL*/, oldData.OrderDelivery, iRep),
                                             WriteDelivery(152/*TA_ORD_DEL*/, newData.OrderDelivery, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Способы передачи информации", WriteDelivery(152/*TA_STAT_DEL*/, oldData.StatementDelivery, iRep),
                                                WriteDelivery(152/*TA_STAT_DEL*/, newData.StatementDelivery, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Блокировка", GetNameLLVALUES(OBJTYPE_KIND_BLOCK_CB, oldData.AvoirStatus, "Не задана"),
                               GetNameLLVALUES(OBJTYPE_KIND_BLOCK_CB, newData.AvoirStatus, "Не задана"), nameArr, oldArr, newArr);
    SetArrayForm("Статус", name_alg(3103, oldData.Status), name_alg(3103, newData.Status), nameArr, oldArr, newArr); // ALG_STATUS_KIND

    if((oldData.PawnRightMeeting > 0) or (newData.PawnRightMeeting > 0) or
       (oldData.PawnRightIncome > 0) or (newData.PawnRightIncome > 0) or
       (oldData.PawnRightGlobal > 0) or (newData.PawnRightGlobal > 0) or
       (oldData.PawnAssignmentRights > 0) or (newData.PawnAssignmentRights > 0) or
       (oldData.PawnSubsequent > 0) or (newData.PawnSubsequent > 0) or
       (oldData.PawnRecoveryKind > 0) or (newData.PawnRecoveryKind > 0) or
       (oldData.PawnRecoveryDate > date(0,0,0)) or (newData.PawnRecoveryDate > date(0,0,0)) or
       (oldData.PawnAddConditions != "") or (newData.PawnAddConditions != "")
      )

      SetArrayForm("Основные условия залога", " ", " ", nameArr, oldArr, newArr);
      SetArrayForm("Право на участие в собрании акционеров принадлежит",
                   name_alg(3269, oldData.PawnRightMeeting),
                   name_alg(3269, newData.PawnRightMeeting), nameArr, oldArr, newArr); // ALG_PAWNRIGHTOWNER
      SetArrayForm("Право на получение дохода по ценным бумагам принадлежит",
                   name_alg(3269, oldData.PawnRightIncome),
                   name_alg(3269, newData.PawnRightIncome), nameArr, oldArr, newArr); // ALG_PAWNRIGHTOWNER
      SetArrayForm("Права, приобретённые в результате КД, не требующего участия акционера (конвертация, сплит, дробление, консолидация, бонусная эмиссия и др.), принадлежат",
                   name_alg(3269, oldData.PawnRightGlobal),
                   name_alg(3269, newData.PawnRightGlobal), nameArr, oldArr, newArr); // ALG_PAWNRIGHTOWNER
      SetArrayForm("Уступка Залогодержателем прав по договору залога ценных бумаг без согласия Залогодателя",
                   name_alg(3270, oldData.PawnAssignmentRights),
                   name_alg(3270, newData.PawnAssignmentRights), nameArr, oldArr, newArr); // ALG_PAWNSOLVE
      SetArrayForm("Последующий залог ценных бумаг без согласия Залогодержателя",
                   name_alg(3270, oldData.PawnSubsequent),
                   name_alg(3270, newData.PawnSubsequent), nameArr, oldArr, newArr); // ALG_PAWNSOLVE
      SetArrayForm("Обращение взыскания на заложенные ценные бумаги",
                   name_alg(3271, oldData.PawnRecoveryKind),
                   name_alg(3271, newData.PawnRecoveryKind), nameArr, oldArr, newArr); // ALG_PAWNRECOVERY
      SetArrayForm("Дата, начиная с которой залогодержатель вправе обратить взыскание (с правом подавать в Депозитарий подписанные Залогодержателем поручения)",
                   oldData.PawnRecoveryDate, newData.PawnRecoveryDate, nameArr, oldArr, newArr);
      SetArrayForm("Дополнительные условия залога", oldData.PawnAddConditions, newData.PawnAddConditions, nameArr, oldArr, newArr);
    end;
  end;

  InitTDepoAdmoCLOB;
  // записи
  oldData = TData;
  newData = TData;
end;

/* ********************************************* */
/* раздел лицевой счет        SPDP_FACE_ACCOUNT */
/* ********************************************* */
class (TDepoAdmoCLOB) TDepoAdmoClobACC
  class TData
    var DepoRoot:integer        = 0,       // Корневой счет депо
        DepoRootType:integer    = 0,       // Тип Корневой счет депо
        DepoAcc:integer         = 0,       // Терминальный раздле счета депо
        Kind_Account:string     = "",      // Вид счета
        Client:integer          = UNDEF_I, // Код клиента
        Account:string          = "",      // Номер лицевого счета
        IsEmissiveCurrency:bool = false,   // Эмиссионная ц/б
        Code_Currency:integer   = UNDEF_I, // Код валюты
        Block:integer           = UNDEF_I, // блокировка
        Balance:string          = "",      // Балансовый счет
        IndoorStorage:integer   = 0,       // Закрытое хранение
        Open_Close:string       = "";      // Флаг "Открыт-Закрыт"
  end;

  macro CreateTData()
    return TData();
  end;

  private macro FillFromACCOUNT(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("account.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("account.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "DepoRoot", saveBuff, recBuff, "DepoRoot", overwrite);
    CopyValue(oldData, newData, "DepoAcc", saveBuff, recBuff, "DepoAcc", overwrite);
    CopyValue(oldData, newData, "Kind_Account", saveBuff, recBuff, "Kind_Account", overwrite);
    CopyValue(oldData, newData, "Client", saveBuff, recBuff, "Client", overwrite, true);
    CopyValue(oldData, newData, "Account", saveBuff, recBuff, "Account", overwrite);
    CopyValue(oldData, newData, "Code_Currency", saveBuff, recBuff, "Code_Currency", overwrite);
    CopyValue(oldData, newData, "Balance", saveBuff, recBuff, "Balance", overwrite);
    CopyValue(oldData, newData, "Open_Close", saveBuff, recBuff, "Open_Close", overwrite);

    if (overwrite != 0)
      if (recBuff != null)
        if (recBuff.rec.Code_Currency != 0)
          newData.IsEmissiveCurrency = not НеэмиссионныйФинИн(recBuff.rec.Code_Currency);
        end;
        newData.DepoRootType = GetDacnt(recBuff.rec.DepoRoot).rec.Type;
        newData.IndoorStorage = IIF(index(recBuff.rec.Type_Account, "I")!=-1, 1, 0);
      end;
      if (saveBuff != null)
        if (saveBuff.rec.Code_Currency != 0)
          oldData.IsEmissiveCurrency = not НеэмиссионныйФинИн(saveBuff.rec.Code_Currency);
        end;
        oldData.DepoRootType = GetDacnt(saveBuff.rec.DepoRoot).rec.Type;
        oldData.IndoorStorage = IIF(index(saveBuff.rec.Type_Account, "I")!=-1, 1, 0);
      end;
    else
      if (recBuff != null)
        if (not newData.IsEmissiveCurrency and not oldData.IsEmissiveCurrency)
          if (recBuff.rec.Code_Currency != 0)
            newData.IsEmissiveCurrency = not НеэмиссионныйФинИн(recBuff.rec.Code_Currency);
          end;
        end;
        if ((newData.DepoRootType == 0) and (oldData.DepoRootType == 0))
          newData.DepoRootType = GetDacnt(recBuff.rec.DepoRoot).rec.Type;
        end;
        if (not newData.IndoorStorage and not oldData.IndoorStorage)
          newData.IndoorStorage = IIF(index(recBuff.rec.Type_Account, "I")!=-1, 1, 0);
        end;
      end;
      if (saveBuff != null)
        if (not newData.IsEmissiveCurrency and not oldData.IsEmissiveCurrency)
          if (saveBuff.rec.Code_Currency != 0)
            oldData.IsEmissiveCurrency = not НеэмиссионныйФинИн(saveBuff.rec.Code_Currency);
          end;
        end;
        if ((newData.DepoRootType == 0) and (oldData.DepoRootType == 0))
          oldData.DepoRootType = GetDacnt(saveBuff.rec.DepoRoot).rec.Type;
        end;
        if (not newData.IndoorStorage and not oldData.IndoorStorage)
          oldData.IndoorStorage = IIF(index(saveBuff.rec.Type_Account, "I")!=-1, 1, 0);
        end;
      end;
    end;
  end;

  private macro FillFromACCATTR(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("accattr.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("accattr.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    CopyValue(oldData, newData, "Block", saveBuff, recBuff, "Value", overwrite);
  end;
  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    FillFromBuffs(tableName, saveAddr, recAddr, overwrite); // базовый
    if ("account" == tableName)
      FillFromACCOUNT(saveAddr, recAddr, overwrite);
    elif( "accattr" == tableName)
      FillFromACCATTR(saveAddr, recAddr, overwrite);
    end;
  end;

  /* Отличаются ли буферы?*/
  macro IsChanges()
    return ((oldData.DepoRoot           != newData.DepoRoot          ) or
            (oldData.DepoRootType       != newData.DepoRootType      ) or
            (oldData.DepoAcc            != newData.DepoAcc           ) or
            (oldData.Kind_Account       != newData.Kind_Account      ) or
            (oldData.Client             != newData.Client            ) or
            (oldData.Account            != newData.Account           ) or
            (oldData.IsEmissiveCurrency != newData.IsEmissiveCurrency) or
            (oldData.Code_Currency      != newData.Code_Currency     ) or
            (oldData.Block              != newData.Block             ) or
            (oldData.Balance            != newData.Balance           ) or
            (oldData.IndoorStorage      != newData.IndoorStorage     ) or
            (oldData.Open_Close         != newData.Open_Close        )
           );
  end;

  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
    var obj;
    obj = GenGetProp(xmlObj, xmlObjName);
    CopyValueFromXmlObjToObj(data, obj, "DepoRoot"          );
    CopyValueFromXmlObjToObj(data, obj, "DepoRootType"      );
    CopyValueFromXmlObjToObj(data, obj, "DepoAcc"           );
    CopyValueFromXmlObjToObj(data, obj, "Kind_Account"      );
    CopyValueFromXmlObjToObj(data, obj, "Client"            );
    CopyValueFromXmlObjToObj(data, obj, "Account"           );
    CopyValueFromXmlObjToObj(data, obj, "IsEmissiveCurrency");
    CopyValueFromXmlObjToObj(data, obj, "Code_Currency"     );
    CopyValueFromXmlObjToObj(data, obj, "Block"             );
    CopyValueFromXmlObjToObj(data, obj, "Balance"           );
    CopyValueFromXmlObjToObj(data, obj, "IndoorStorage"     );
    CopyValueFromXmlObjToObj(data, obj, "Open_Close"        );
    // нет объекта. Заглушка
    onError(er)
      ;
  end;

  // идентификатор данных
  macro GetReqID()
    return "FaceAccoount";
  end;
  // ---------------------------------------
  // Методы для вывода на экран

  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    // 1. name по индексу соответсвует old и new
    // 2. если name пустой, то в интерфейс не выводим
    // 3. если old или new пустой, то не задан

    SetArrayForm("Счет депо", GetDacnt(oldData.DepoRoot).rec.Code, GetDacnt(newData.DepoRoot).rec.Code, nameArr, oldArr, newArr);
    SetArrayForm("Тип счета депо", GetTypeValue(GetDacnt(oldData.DepoRoot).rec.Type, iRep),
                                   GetTypeValue(GetDacnt(newData.DepoRoot).rec.Type, iRep), nameArr, oldArr, newArr);
    SetArrayForm("Раздел", GetDacnt(oldData.DepoAcc).rec.BriefCode, GetDacnt(newData.DepoAcc).rec.BriefCode, nameArr, oldArr, newArr);
    SetArrayForm("Вид", GetKindValue(oldData.Kind_Account), GetKindValue(newData.Kind_Account), nameArr, oldArr, newArr);
    SetArrayForm("Владелец", WriteFullParty(oldData.Client, iRep, operdate), WriteFullParty(newData.Client, iRep, operdate), nameArr, oldArr, newArr);
    SetArrayForm("Номер", oldData.Account, newData.Account, nameArr, oldArr, newArr);
    SetArrayForm("Эмиссионная", name_alg(905,IIF(oldData.IsEmissiveCurrency, 1, 0)),
                                name_alg(905,IIF(newData.IsEmissiveCurrency, 1, 0)), nameArr, oldArr, newArr);
    SetArrayForm("Выпуск", WriteFullFIAdmo(oldData.Code_Currency, oldData.IsEmissiveCurrency, iRep, operdate),
                           WriteFullFIAdmo(newData.Code_Currency, newData.IsEmissiveCurrency, iRep, operdate), nameArr, oldArr, newArr);
    SetArrayForm("Блокировка", GetNameLLVALUES(OBJTYPE_KIND_BLOCK_CB, oldData.Block, "Не задана"),
                               GetNameLLVALUES(OBJTYPE_KIND_BLOCK_CB, newData.Block, "Не задана"), nameArr, oldArr, newArr);
    SetArrayForm("Балансовый счет", oldData.Balance, newData.Balance, nameArr, oldArr, newArr);
    SetArrayForm("Режим хранения", GetNameLLVALUES(OBJTYPE_MODE_STORE_KIND, oldData.IndoorStorage, "Не задан"),
                                   GetNameLLVALUES(OBJTYPE_MODE_STORE_KIND, newData.IndoorStorage, "Не задан"), nameArr, oldArr, newArr);
    SetArrayForm("Статус", name_alg(709,IIF(oldData.Open_Close=="З", 1, 0)),
                           name_alg(709,IIF(newData.Open_Close=="З", 1, 0)), nameArr, oldArr, newArr);
  end;

  InitTDepoAdmoCLOB;
  // записи
  oldData = TData;
  newData = TData;
end;

/* ********************************************* */
/* анкета выпуска                   SPDP_AVOIRIS */
/* ********************************************* */
class (TDepoAdmoCLOB) TDepoAdmoClobAVOIR
  class TData
    var FIID:integer         = UNDEF_I,    // Идентификатор финансового инстр.           FININSTR
        AvoirKind:integer    = UNDEF_I,    // Подвид финансового инструмента             FININSTR
        ISIN:string          = "",         // Международный идентиф.номер (ISIN)         AVOIRISS
        LSIN:string          = "",         // Номер гос. регистрации                     AVOIRISS
        Name:string          = "",         // Название                                   FININSTR
        Issuer:integer       = UNDEF_I,    // Эмитент                                    FININSTR
        Issued:date          = Date(0,0,0),// Дата выпуска                               FININSTR
        FaceValue:numeric    = $0.0,       // Номинальная стоимость,кол-во баз. ФИ       FININSTR
        FaceValueFI:integer  = 0,          // Валюта(ФИ) номинала, базы                  FININSTR
        Qty:numeric          = $0.0,       // Объем выпуска                              AVOIRISS
        DrawingDate:date     = Date(0,0,0),// Дата погашения, валютирования              FININSTR
        IncomeRate:double    = 0.0,        // Ставка дохода                              AVOIRISS
        IncomeVolume:numeric = $0.0,       // Доход                                      AVOIRISS
        ServiceState:integer = 0;          // Признак - данный ФИ не используется        AVOIRSRV
  end;

  macro CreateTData()
    return TData();
  end;

  private macro FillFromFININSTR(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("fininstr.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("fininstr.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "FIID",        saveBuff, recBuff, "FIID",        overwrite);
    CopyValue(oldData, newData, "AvoirKind",   saveBuff, recBuff, "AvoirKind",   overwrite);
    CopyValue(oldData, newData, "Name",        saveBuff, recBuff, "Name",        overwrite);
    CopyValue(oldData, newData, "Issuer",      saveBuff, recBuff, "Issuer",      overwrite, true);
    CopyValue(oldData, newData, "Issued",      saveBuff, recBuff, "Issued",      overwrite);
    CopyValue(oldData, newData, "FaceValue",   saveBuff, recBuff, "FaceValue",   overwrite);
    CopyValue(oldData, newData, "FaceValueFI", saveBuff, recBuff, "FaceValueFI", overwrite);
    CopyValue(oldData, newData, "DrawingDate", saveBuff, recBuff, "DrawingDate", overwrite);
  end;
  private macro FillFromAVOIRISS(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("avoiriss.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("avoiriss.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "ISIN",         saveBuff, recBuff, "ISIN",         overwrite);
    CopyValue(oldData, newData, "LSIN",         saveBuff, recBuff, "LSIN",         overwrite);
    CopyValue(oldData, newData, "Qty",          saveBuff, recBuff, "Qty",          overwrite);
    CopyValue(oldData, newData, "IncomeRate",   saveBuff, recBuff, "IncomeRate",   overwrite);
    CopyValue(oldData, newData, "IncomeVolume", saveBuff, recBuff, "IncomeVolume", overwrite);
  end;
  private macro FillFromAVOIRSRV(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("avoirsrv.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("avoirsrv.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "ServiceState", saveBuff, recBuff, "ServiceState", overwrite);
  end;
  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    FillFromBuffs(tableName, saveAddr, recAddr, overwrite); // базовый
    if ("fininstr" == tableName)
      FillFromFININSTR(saveAddr, recAddr, overwrite);
    elif ("avoiriss" == tableName)
      FillFromAVOIRISS(saveAddr, recAddr, overwrite);
    elif ("avoirsrv" == tableName)
      FillFromAVOIRSRV(saveAddr, recAddr, overwrite);
    end;
  end;

  /* Отличаются ли буферы?*/
  macro IsChanges()
    return ((oldData.FIID         != newData.FIID        ) or
            (oldData.AvoirKind    != newData.AvoirKind   ) or
            (oldData.ISIN         != newData.ISIN        ) or
            (oldData.LSIN         != newData.LSIN        ) or
            (oldData.Name         != newData.Name        ) or
            (oldData.Issuer       != newData.Issuer      ) or
            (oldData.Issued       != newData.Issued      ) or
            (oldData.FaceValue    != newData.FaceValue   ) or
            (oldData.FaceValueFI  != newData.FaceValueFI ) or
            (oldData.Qty          != newData.Qty         ) or
            (oldData.DrawingDate  != newData.DrawingDate ) or
            (oldData.IncomeRate   != newData.IncomeRate  ) or
            (oldData.IncomeVolume != newData.IncomeVolume) or
            (oldData.ServiceState != newData.ServiceState)
           );
  end;

  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
    var obj;
    obj = GenGetProp(xmlObj, xmlObjName);
    CopyValueFromXmlObjToObj(data, obj, "FIID"        );
    CopyValueFromXmlObjToObj(data, obj, "AvoirKind"   );
    CopyValueFromXmlObjToObj(data, obj, "ISIN"        );
    CopyValueFromXmlObjToObj(data, obj, "LSIN"        );
    CopyValueFromXmlObjToObj(data, obj, "Name"        );
    CopyValueFromXmlObjToObj(data, obj, "Issuer"      );
    CopyValueFromXmlObjToObj(data, obj, "Issued"      );
    CopyValueFromXmlObjToObj(data, obj, "FaceValue"   );
    CopyValueFromXmlObjToObj(data, obj, "FaceValueFI" );
    CopyValueFromXmlObjToObj(data, obj, "Qty"         );
    CopyValueFromXmlObjToObj(data, obj, "DrawingDate" );
    CopyValueFromXmlObjToObj(data, obj, "IncomeRate"  );
    CopyValueFromXmlObjToObj(data, obj, "IncomeVolume");
    CopyValueFromXmlObjToObj(data, obj, "ServiceState");
    // нет объекта. Заглушка
    onError(er)
      ;
  end;

  // идентификатор данных
  macro GetReqID()
    return "DepoAvoiriss";
  end;
  // ---------------------------------------
  // Методы для вывода на экран

  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    // 1. name по индексу соответсвует old и new
    // 2. если name пустой, то в интерфейс не выводим
    // 3. если old или new пустой, то не задан
    var IssuerLabel = "Эмитент";
    if(FI_IsInvestmentShare(oldData.FIID) or FI_IsInvestmentShare(newData.FIID))
      IssuerLabel = "Управляющая компания";
    elif(FI_IsHypothecaryCert(oldData.FIID) or FI_IsHypothecaryCert(newData.FIID))
      IssuerLabel = "Управляющий ипотечным покрытием";
    end;

    SetArrayForm("FIID", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Вид ценной бумаги", GetAvoirKindName(oldData.FIID), GetAvoirKindName(newData.FIID), nameArr, oldArr, newArr);
    SetArrayForm("ISIN", oldData.ISIN, newData.ISIN, nameArr, oldArr, newArr);
    SetArrayForm("№ гос. регистрации", oldData.LSIN, newData.LSIN, nameArr, oldArr, newArr);
    SetArrayForm("Наименование", oldData.Name, newData.Name, nameArr, oldArr, newArr);
    SetArrayForm(IssuerLabel, WriteFullParty(oldData.Issuer, iRep, operdate), WriteFullParty(newData.Issuer, iRep, operdate), nameArr, oldArr, newArr);
    SetArrayForm("Дата регистрации эмиссии", oldData.Issued, newData.Issued, nameArr, oldArr, newArr);
    SetArrayForm("Номинал", oldData.FaceValue, newData.FaceValue, nameArr, oldArr, newArr);
    SetArrayForm("Валюта номинала", ПолучитьКодФинИн(oldData.FaceValueFI, null, FICK_USERCODE),
                                    ПолучитьКодФинИн(newData.FaceValueFI, null, FICK_USERCODE), nameArr, oldArr, newArr);
    SetArrayForm("Объем эмиссии", oldData.Qty, newData.Qty, nameArr, oldArr, newArr);
    SetArrayForm("Дата погашения", oldData.DrawingDate, newData.DrawingDate, nameArr, oldArr, newArr);
    SetArrayForm("Статус", name_alg(3217, oldData.ServiceState), name_alg(3217, newData.ServiceState), nameArr, oldArr, newArr);

    SetArrayForm("Ставка", IIF(oldData.IncomeRate!=0.0, String(oldData.IncomeRate)+" %%", IIF(oldData.IncomeVolume!=$0.0, oldData.IncomeVolume, "")),
                           IIF(newData.IncomeRate!=0.0, String(newData.IncomeRate)+" %%", IIF(newData.IncomeVolume!=$0.0, newData.IncomeVolume, "")),
                           nameArr, oldArr, newArr);
    SetArrayForm("Тип ставки", IIF(oldData.IncomeRate!=0.0, "Процентная", IIF(oldData.IncomeVolume!=$0.0, "Дисконтная", "")),
                               IIF(newData.IncomeRate!=0.0, "Процентная", IIF(newData.IncomeVolume!=$0.0, "Дисконтная", "")),
                               nameArr, oldArr, newArr);
  end;

  InitTDepoAdmoCLOB;
  // записи
  oldData = TData;
  newData = TData;
end;

/* ********************************************* */
/* анкета инв. карточки             SPDP_INVCARD */
/* ********************************************* */
class (TDepoAdmoCLOB) TDepoAdmoClobINVCARD
  class TData
    var InvCardID:integer   = 0,                       //Идентификатор ИК
        Status:integer      = INVCARD_STATUS_UNKNOWN;  //Статус
  end;

  macro CreateTData()
    return TData();
  end;

  private macro FillFromINVCARD(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("invcard.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("invcard.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "InvCardID",   saveBuff, recBuff, "InvCardID",   overwrite);
    CopyValue(oldData, newData, "Status",      saveBuff, recBuff, "Status",      overwrite);
  end;

  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    if ("invcard" == tableName)
      FillFromINVCARD(saveAddr, recAddr, overwrite);
    end;
  end;

  /* Отличаются ли буферы?*/
  macro IsChanges()
    return ((oldData.InvCardID   != newData.InvCardID  ) or
            (oldData.Status      != newData.Status     )
           );
  end;

  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
    var obj;
    obj = GenGetProp(xmlObj, xmlObjName);
    CopyValueFromXmlObjToObj(data, obj, "InvCardID"  );
    CopyValueFromXmlObjToObj(data, obj, "Status"     );
    // нет объекта. Заглушка
    onError(er)
      ;
  end;

  // идентификатор данных
  macro GetReqID()
    return "DepoInvCard";
  end;
  // ---------------------------------------
  // Методы для вывода на экран

  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    // 1. name по индексу соответсвует old и new
    // 2. если name пустой, то в интерфейс не выводим
    // 3. если old или new пустой, то не задан

    SetArrayForm("InvCardID", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Состояние", name_alg(5211, oldData.Status), name_alg(5211, newData.Status), nameArr, oldArr, newArr);
  end;

  InitTDepoAdmoCLOB;
  // записи
  oldData = TData;
  newData = TData;
end;

/* *************************************************** */
/* Данные по субъекту:                                 */
/*    Анкета депонента                     SPDP_CLIENT */
/*    Анкета нашего депозитария     SPDP_OURDEPOSITARY */
/*    Анкета места хранения          SPDP_STORAGEPLACE */
/*    Анкета попечителя                  SPDP_GUARDIAN */
/*    Анкета оператора                   SPDP_OPERATOR */
/*    Анкета распорядителя                SPDP_MANAGER */
/*    Анкета депозитария-корреспондента  SPDP_DEPOCORR */
/* *************************************************** */
class (TDepoAdmoCLOB) TDepoAdmoClobPARTY
  class TData
    var PartyID:integer       = UNDEF_I,     // Внутренний идентификатор                      party
        LegalForm:integer     = 0,           // Вид (1-организация, 2-физ.лицо)               party
        ShortName:string      = "",          // Сокращенное название                          party
        Name:string           = "",          // Полное наименование                           party
        Born:date             = Date(0,0,0), // Дата рождения                                 persn
        BirsPlase:string      = "",          // Место рождения                                persn
        IsMale:string         = "",          // Пол (Х - мужской)                             persn
        CodeINN:string        = "",          // ИНН                                           partcode.Code
        CodeDepos:string      = "",          // Регистрационный номер депозитария             partcode
        CodeBank:string       = "",          // Номер банковской лицензии                     partcode
        PaperKind:integer     = 0,           // Вид документа, удост. личность                persn
        PaperSeries:string    = "",          // Серия документа удост. личность               persn
        PaperNumber:string    = "",          // Номер документа, удост. личность              persn
        PaperIssuer:string    = "",          // Наименование орг-и выдавшей документ          persn
        PaperIssuerID:integer = UNDEF_I,     // ИД орг-и выдавшей документ                    partyreg
        PaperIssuedDate:date  = Date(0,0,0), // Дата выдачи документа, удост. личн.           persn
        RegNumber:string      = "",          // Регистрационный номер                         partyreg  //829
        // Юридический адрес
        Index:string          = "",          // почтовый индекс                               adress
        Country:string        = "",          // Код страны                                    adress
        Region:string         = "",          // Код региона                                   adress
        CodeProvince:string   = "",          // Номер кода области                            adress
        Province:string       = "",          // Область                                       adress
        CodeDistrict:string   = "",          // Код района                                    adress
        District:string       = "",          // Район                                         adress
        CodePlace:string      = "",          // Код населенного пункта                        adress
        Place:string          = "",          // Населенный пункт                              adress
        CodeStreet:string     = "",          // Код улицы                                     adress
        Street:string         = "",          // Улица (к адресу)                              adress
        House:string          = "",          // Дом                                           adress
        NumCorps:string       = "",          // Корпус                                        adress
        Flat:string           = "",          // Квартира                                      adress
        PostIndex:string      = "",          // Почтовый индекс                               adress
        Address:string        = "",          // Почтовый адрес                                party
        PhoneNumber:string    = "",          // Номер телефона                                party         //Для совместимости
        PhoneNumber2:string   = "",          // Дополнительный номер  телефона                party         //Для совместимости
        Fax:string            = "",          // Факс                                          party  //1804 //Для совместимости
        Telegraph:string      = "",          // Телеграф                                      adress        //Для совместимости
        TelexNumber:string    = "",          // Телекс                                        adress        //Для совместимости
        E_Mail:string         = "",          // Адрес электронной почты                       party  //1918 //Для совместимости

        NotResident:string    = "",          // Признак нерезидентности                       party
        NRCountry:string      = "",          // Код страны нерезидента                        party

        Status:integer        = UNDEF_I;     // Признак Депонента (работающего в Депозитарии) party + servkind 1935

    var Persons:TArray       = TArray();     // Массив первых\вторых лиц
    var Contacts:TArray      = TArray();     // Массив способов связи
  end;

  class TPerson(offID:integer, persID:integer, isFirstPer:string)
    var OfficerID:integer    = offID,       // Идентификатор записи о сотруднике в dofficer_dbt
        PersonID:integer     = persID,      // Идентификатор физлица
        IsFirstPerson:string = isFirstPer;  // Признак первого [X], второго [] лица
    // одинаковы ли объекты?
    macro IsEqual(elem)
      return ((this.OfficerID     == elem.OfficerID    ) and
              (this.PersonID      == elem.PersonID     ) and
              (this.IsFirstPerson == elem.IsFirstPerson)
             );
    end;
  end;

  class TContact(_ContactID:integer, _PartyID:integer, _AddressType:integer, _ContactKind: integer, _ContactType:integer, _Value:string, _IsMain:string)
    var ContactID:integer    = _ContactID,   // ID записи
        PartyID:integer      = _PartyID,     // ID субъекта
        AddressType:integer  = _AddressType,  // Тип адреса
        ContactKind: integer = _ContactKind, // Вид способа связи
        ContactType:integer  = _ContactType, // Тип способа связи
        Value:string         = _Value,       // Значение
        IsMain:string        = _IsMain;      // Признак основного способа

    // одинаковы ли объекты?
    macro IsEqual(elem)
      return ((this.ContactID   == elem.ContactID  ) and
              (this.PartyID     == elem.PartyID    ) and
              (this.AddressType == elem.AddressType) and
              (this.ContactKind == elem.ContactKind) and
              (this.ContactType == elem.ContactType) and
              (this.Value       == elem.Value      ) and
              (this.IsMain      == elem.IsMain     )
             );
    end;
  end;

  macro CreateTData()
    return TData();
  end;

  /* Поиск сотрудника в массиве
     -1 - не найден, иначе - индекс в массиве */
  private macro FindPersons(arrPersons:TArray, offID:integer):integer
    var i = 0;
    while (i < arrPersons.size)
      if (arrPersons[i].OfficerID == offID)
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  end;
  /* Есть сотрудник в массиве */
  private macro IsPersonInData(arrPersons:TArray, offID:integer):bool
    return (FindPersons(arrPersons, offID) != -1);
  end;

  /* Поиск способа связи в массиве
     -1 - не найден, иначе - индекс в массиве */
  private macro FindContacts(arrContacts:TArray, ContactID:integer, AddressType:integer, ContactKind:integer, ContactType:integer, IsMain:string):integer
    var i = 0;
    while (i < arrContacts.size)
      if ((arrContacts[i].ContactID == ContactID) AND
          (arrContacts[i].AddressType == AddressType) AND
          (arrContacts[i].ContactKind == ContactKind) AND
          (arrContacts[i].ContactType == ContactType) AND
          (arrContacts[i].IsMain == IsMain)
         )
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  end;
  /* Есть способ связи в массиве */
  private macro IsContactInData(arrContacts:TArray, ContactID:integer, AddressType:integer, ContactKind:integer, ContactType:integer, IsMain:string):bool
    return (FindContacts(arrContacts, ContactID, AddressType, ContactKind, ContactType, IsMain) != -1);
  end;

  private macro FillFromPARTY(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("party.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("party.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "PartyID", saveBuff, recBuff, "PartyID", overwrite);
    CopyValue(oldData, newData, "LegalForm", saveBuff, recBuff, "LegalForm", overwrite);
    if ((recAddr != null) and (recBuff.rec.LegalForm == PTLEGF_INST))
      CopyValue(oldData, newData, "ShortName", saveBuff, recBuff, "ShortName", overwrite);
    end;
    CopyValue(oldData, newData, "Name", saveBuff, recBuff, "Name", overwrite);
    CopyValue(oldData, newData, "NotResident", saveBuff, recBuff, "NotResident", overwrite);
    CopyValue(oldData, newData, "NRCountry", saveBuff, recBuff, "NRCountry", overwrite);

    if ((overwrite != 0) or ((newData.Status == UNDEF_I) and (oldData.Status == UNDEF_I)))
      if(recBuff != null)
        newData.Status = IIF(recBuff.rec.Locked == "", 1, 0);
      end;
      if(saveBuff != null)
        oldData.Status = IIF(saveBuff.rec.Locked == "", 1, 0);
      end;
    end;
  end;
  private macro FillFromADRESS(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("adress.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("adress.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    var oldDataPostIndex = oldData.PostIndex,
        oldDataAddress = oldData.Address;

    if ((saveBuff != null) and (saveBuff.rec.Type == PTADDR_LEGAL))
      CopyValue(oldData, newData, "Index",        saveBuff, null, "PostIndex",    overwrite);
      CopyValue(oldData, newData, "Country",      saveBuff, null, "Country",      overwrite);
      CopyValue(oldData, newData, "Region",       saveBuff, null, "Region",       overwrite);
      CopyValue(oldData, newData, "CodeProvince", saveBuff, null, "CodeProvince", overwrite);
      CopyValue(oldData, newData, "Province",     saveBuff, null, "Province",     overwrite);
      CopyValue(oldData, newData, "CodeDistrict", saveBuff, null, "CodeDistrict", overwrite);
      CopyValue(oldData, newData, "District",     saveBuff, null, "District",     overwrite);
      CopyValue(oldData, newData, "CodePlace",    saveBuff, null, "CodePlace",    overwrite);
      CopyValue(oldData, newData, "Place",        saveBuff, null, "Place",        overwrite);
      CopyValue(oldData, newData, "CodeStreet",   saveBuff, null, "CodeStreet",   overwrite);
      CopyValue(oldData, newData, "Street",       saveBuff, null, "Street",       overwrite);
      CopyValue(oldData, newData, "House",        saveBuff, null, "House",        overwrite);
      CopyValue(oldData, newData, "NumCorps",     saveBuff, null, "NumCorps",     overwrite);
      CopyValue(oldData, newData, "Flat",         saveBuff, null, "Flat",         overwrite);
    end;
    if ((recBuff != null) and (recBuff.rec.Type == PTADDR_LEGAL))
      CopyValue(oldData, newData, "Index",        null, recBuff, "PostIndex",    overwrite);
      CopyValue(oldData, newData, "Country",      null, recBuff, "Country",      overwrite);
      CopyValue(oldData, newData, "Region",       null, recBuff, "Region",       overwrite);
      CopyValue(oldData, newData, "CodeProvince", null, recBuff, "CodeProvince", overwrite);
      CopyValue(oldData, newData, "Province",     null, recBuff, "Province",     overwrite);
      CopyValue(oldData, newData, "CodeDistrict", null, recBuff, "CodeDistrict", overwrite);
      CopyValue(oldData, newData, "District",     null, recBuff, "District",     overwrite);
      CopyValue(oldData, newData, "CodePlace",    null, recBuff, "CodePlace",    overwrite);
      CopyValue(oldData, newData, "Place",        null, recBuff, "Place",        overwrite);
      CopyValue(oldData, newData, "CodeStreet",   null, recBuff, "CodeStreet",   overwrite);
      CopyValue(oldData, newData, "Street",       null, recBuff, "Street",       overwrite);
      CopyValue(oldData, newData, "House",        null, recBuff, "House",        overwrite);
      CopyValue(oldData, newData, "NumCorps",     null, recBuff, "NumCorps",     overwrite);
      CopyValue(oldData, newData, "Flat",         null, recBuff, "Flat",         overwrite);
    end;
    if ((saveBuff != null) and (saveBuff.rec.Type == PTADDR_POST))
      if ((overwrite) or ((newData.PostIndex == "") and (oldDataPostIndex == "")))
        oldData.PostIndex = saveBuff.rec.PostIndex;
      end;
      if ((overwrite) or ((newData.Address == "") and (oldDataAddress == "")))
        oldData.Address = saveBuff.rec.Adress;
      end;
    end;
    if ((recBuff != null) and (recBuff.rec.Type == PTADDR_POST))
      if ((overwrite) or ((newData.PostIndex == "") and (oldDataPostIndex == "")))
        newData.PostIndex = recBuff.rec.PostIndex;
      end;
      if ((overwrite) or ((newData.Address == "") and (oldDataAddress == "")))
        newData.Address = recBuff.rec.Adress;
      end;
    end;
  end;

  /* Вставка нового способа связи в массив */
  private macro InsertNewContact(buff:variant,    // Буфер contact.dbt (может быть TRecHandler или DataSet)
                                 contacts:TArray) // Массив способов связи для добавления
    if(buff.rec.AddressType == PTADDR_LEGAL)
      if (IsContactInData(contacts, buff.rec.RecID, buff.rec.AddressType, buff.rec.ContactKind, buff.rec.ContactType, buff.rec.IsMain))
        return;
      end;
      // Добавляем в конец массива
      contacts[contacts.size] = TContact(buff.rec.RecID, buff.rec.PartyID, buff.rec.AddressType, buff.rec.ContactKind, buff.rec.ContactType, buff.rec.Value, buff.rec.IsMain);
    end;
  end;

  private macro FillFromCONTACT(saveBuff:variant, recBuff:variant, overwrite:integer)
    if ((saveBuff != NULL) and
        ((overwrite != 0) or IsContactInData(oldData.Contacts, saveBuff.rec.RecID, savebuff.rec.AddressType, savebuff.rec.ContactKind, savebuff.rec.ContactType, savebuff.rec.IsMain))
       )
      InsertNewContact(saveBuff, oldData.Contacts);
    end;

    if(recBuff != NULL)
      InsertNewContact(recBuff, newData.Contacts);
    end;
  end;

  private macro FillFromCONTACTAddrBuff(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("contact.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("contact.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    FillFromCONTACT(saveBuff, recBuff, overwrite);
  end;

  private macro FillFromAllCONTACT(dummy1, dummy2, partyID:integer)
    //последующие не слишком адекватные действия вызваны тем, что сервисы во временном файле officer
    //после синхронизации новых записей вместо нового ID пишут отрицательные индексы
    //альтернативного ключа там нет, поэтому как-то обработать такие записи традиционным функционалом АО
    //не представляется возможным
    //поэтому поступаем так
    //вычищаем все записи из состояния ПОСЛЕ с отрицательными ID лиц (т.е. новых) (они нам там были нужны, чтобы были зафиксированы изменения)
    //а затем перебирая уже живую базу смотрим, если записи с таким ID не было в состоянии ДО, то значит это новая записиь
    //и её мы уже добавим внутри FillFromOFFICER
    //остальное работает без заморочек
    //если когда-нибудь в contact появится альтернативный ключ, то от этой схемы можно будет отказаться

    var correctContacts:TArray = TArray();
    //1. Необходимо вычистить все временные способы связи (новые) с отрицательными ID из состояния ПОСЛЕ
    for (var conts, newData.Contacts)
      if (conts.ContactID > 0)
        correctContacts[correctContacts.size] = TContact(conts.ContactID, conts.PartyID, conts.AddressType, conts.ContactKind, conts.ContactType, conts.Value, conts.IsMain);
      end;
    end;
    newData.Contacts.size = 0;
    newData.Contacts = correctContacts;

    //2. теперь же добавим неизменившихся и новых из реальной базы
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT * FROM dcontact_dbt WHERE t_PartyID = ?");
    cmd.addParam(PartyID);

    dataSet = cmd.execute();

    while (dataSet.moveNext())
      FillFromCONTACT(null, dataSet, 0);
    end;

    onError(er)
      msgbox(cmd.GetErrorString(er));
  end;

  private macro FillFromCLIENT(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("client.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("client.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    if ((overwrite != 0) or ((newData.Status == UNDEF_I) and (oldData.Status == UNDEF_I)))
      if(recBuff != null)
        newData.Status = IIF(recBuff.rec.FinishDate == Date(0,0,0), 1, 0);
      end;
      if(saveBuff != null)
        oldData.Status = IIF(saveBuff.rec.FinishDate == Date(0,0,0), 1, 0);
      end;
    end;
  end;

  private macro FillFromOBJCODE(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("objcode.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("objcode.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    var codeKind:integer = 0;

    if ((recBuff != null) and (recBuff.rec.CodeKind != 0))
      codeKind = recBuff.rec.CodeKind;
    elif ((saveBuff != null) and (saveBuff.rec.CodeKind != 0))
      codeKind = saveBuff.rec.CodeKind;
    end;

    if (PTCK_INN == codeKind)
      CopyValue(oldData, newData, "CodeINN", saveBuff, recBuff, "Code", overwrite);
    elif (PTCK_DEPOREGN == codeKind)
      CopyValue(oldData, newData, "CodeDepos", saveBuff, recBuff, "Code", overwrite);
    elif (PTCK_BANKLICENSE == codeKind)
      CopyValue(oldData, newData, "CodeBank", saveBuff, recBuff, "Code", overwrite);
    end;
  end;

  private macro FillFromPERSN(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("persn.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("persn.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "Born", saveBuff, recBuff, "Born", overwrite);
    CopyValue(oldData, newData, "BirsPlase", saveBuff, recBuff, "BirsPlase", overwrite);
    CopyValue(oldData, newData, "IsMale", saveBuff, recBuff, "IsMale", overwrite);
  end;

  private macro FillFromPERSNIDC(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("persnidc.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("persnidc.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;
    CopyValue(oldData, newData, "PaperKind", saveBuff, recBuff, "PaperKind", overwrite);
    CopyValue(oldData, newData, "PaperSeries", saveBuff, recBuff, "PaperSeries", overwrite);
    CopyValue(oldData, newData, "PaperNumber", saveBuff, recBuff, "PaperNumber", overwrite);
    CopyValue(oldData, newData, "PaperIssuer", saveBuff, recBuff, "PaperIssuer", overwrite);
    CopyValue(oldData, newData, "PaperIssuedDate", saveBuff, recBuff, "PaperIssuedDate", overwrite);
  end;

  private macro FillFromOBJRGDOC(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("objrgdoc.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("objrgdoc.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    if ((oldData.LegalForm == PTLEGF_INST) or (newData.LegalForm == PTLEGF_INST))
      CopyValue(oldData, newData, "PaperKind", saveBuff, recBuff, "RegDocKind", overwrite);
      CopyValue(oldData, newData, "PaperSeries", saveBuff, recBuff, "Series", overwrite);
      CopyValue(oldData, newData, "PaperNumber", saveBuff, recBuff, "Number", overwrite);
      CopyValue(oldData, newData, "PaperIssuerID", saveBuff, recBuff, "RegPartyID", overwrite);
      CopyValue(oldData, newData, "PaperIssuedDate", saveBuff, recBuff, "DocDate", overwrite);
    end;
  end;

  /* Вставка нового сотрудника в массив */
  private macro InsertNewPerson(buff:variant,   // Буфер officer.dbt (может быть TRecHandler или DataSet)
                                persons:TArray/*,     // Массив сотрудников для добавления
                                pairPersons:TArray*/) // Парный массив сотрудников (для поиска дублежа)
    // Ищем переданный элемент в парном списке - если нашли - в наш список вставлять не будем
    /*if (IsPersonInData(pairPersons, buff.rec.AutoInc))
      return;
    end;*/
    // дубль не вставляем
    if (IsPersonInData(persons, buff.rec.AutoInc))
      return;
    end;
    // Добавляем в конец массива
    persons[persons.size] = TPerson(buff.rec.AutoInc, buff.rec.PersonID, buff.rec.IsFirstPerson);
  end;

  private macro FillFromOFFICER(saveBuff:variant, recBuff:variant, overwrite:integer)
    //только если был, есть или будет первым или вторым лицом
    if (((saveBuff != NULL) and ((saveBuff.rec.IsFirstPerson == SET_CHAR) or (saveBuff.rec.IsSecondPerson == SET_CHAR))) or
        ((recBuff  != NULL) and ((recBuff.rec.IsFirstPerson  == SET_CHAR) or (recBuff.rec.IsSecondPerson  == SET_CHAR)))
       )
      if ((saveBuff != NULL) and
          ((overwrite != 0) or IsPersonInData(oldData.Persons, saveBuff.rec.AutoInc)) and
          ((saveBuff.rec.IsFirstPerson == SET_CHAR) or (saveBuff.rec.IsSecondPerson == SET_CHAR))
         )
        InsertNewPerson(saveBuff, oldData.Persons/*, newData.Persons*/);
      end;

      if ( (recBuff != NULL) and ((recBuff.rec.IsFirstPerson == SET_CHAR) or (recBuff.rec.IsSecondPerson == SET_CHAR)))
        InsertNewPerson(recBuff, newData.Persons/*, oldData.Persons*/);
      end;
    end;
  end;

  private macro FillFromOFFICERAddrBuff(saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    var saveBuff:TRecHandler = null,
        recBuff:TRecHandler  = null;

    if (ValType(saveAddr) == V_MEMADDR)
      saveBuff = TRecHandler("officer.dbt");
      saveBuff.SetRecordAddr(saveAddr);
    end;
    if (ValType(recAddr) == V_MEMADDR)
      recBuff = TRecHandler("officer.dbt");
      recBuff.SetRecordAddr(recAddr);
    end;

    FillFromOFFICER(saveBuff, recBuff, overwrite);
    //только если был, есть или будет первым или вторым лицом
//    if (((saveBuff != NULL) and ((saveBuff.rec.IsFirstPerson == SET_CHAR) or (saveBuff.rec.IsSecondPerson == SET_CHAR))) or
//        ((recBuff  != NULL) and ((recBuff.rec.IsFirstPerson  == SET_CHAR) or (recBuff.rec.IsSecondPerson  == SET_CHAR)))
//       )
//      if ((saveBuff != NULL) and
//          ((overwrite != 0) or IsPersonInData(oldData, saveBuff.rec.AutoInc)) and
//          ((saveBuff.rec.IsFirstPerson == SET_CHAR) or (saveBuff.rec.IsSecondPerson == SET_CHAR))
//         )
//        InsertNewPerson(saveBuff, oldData.Persons/*, newData.Persons*/);
//      end;

//      if ( (recBuff != NULL) and ((recBuff.rec.IsFirstPerson == SET_CHAR) or (recBuff.rec.IsSecondPerson == SET_CHAR)))
//        InsertNewPerson(recBuff, newData.Persons, oldData.Persons);
//      end;
//    end;
  end;

  private macro FillFromAllOFFICER(dummy1, dummy2, partyID:integer)
    //N.E.
    //последующие не слишком адекватные действия вызваны тем, что сервисы во временном файле officer
    //после синхронизации новых записей вместо нового ID пишут 0
    //альтернативного ключа там нет, поэтому как-то обработать такие записи традиционным функционалом АО
    //не представляется возможным
    //поэтому поступаем так
    //вычищаем все записи из состояния ПОСЛЕ с отрицательными ID лиц (т.е. новых) (они нам там были нужны, чтобы были зафиксированы изменения)
    //а затем перебирая уже живую базу смотрим, если записи с таким ID не было в состоянии ДО, то значит это новая записиь
    //и её мы уже добавим внутри FillFromOFFICER
    //остальное работает без заморочек
    //если когда-нибудь в officer появится альтернативный ключ, то от этой схемы можно будет отказаться
    var correctPersons:TArray = TArray();
    //1. Необходимо вычистить всех временных (новых) лиц (с отрицательными ID) из состояния ПОСЛЕ
    for (var pers, newData.Persons)
      if (pers.OfficerID > 0)
        correctPersons[correctPersons.size] = TPerson(pers.OfficerID, pers.PersonID, pers.IsFirstPerson);
      end;
    end;
    newData.Persons.size = 0;
    newData.Persons = correctPersons;

    //2. теперь же добавим неизменившихся и новых из реальной базы
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT * FROM dofficer_dbt WHERE t_PartyID = ?");
    cmd.addParam(partyID);

    dataSet = cmd.execute();

    while (dataSet.moveNext())
      if ((dataSet.rec.IsFirstPerson == SET_CHAR) or (dataSet.rec.IsSecondPerson == SET_CHAR))
        FillFromOFFICER(null, dataSet, 0);
      end;
    end;

    onError(er)
      msgbox(cmd.GetErrorString(er));
  end;
  /* заполнение из буферов */
  macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
    FillFromBuffs(tableName, saveAddr, recAddr, overwrite); // базовый
    if ("party" == tableName)
      FillFromPARTY(saveAddr, recAddr, overwrite);
    elif ("adress" == tableName)
      FillFromADRESS(saveAddr, recAddr, overwrite);
    elif ("contact" == tableName)
      FillFromCONTACTAddrBuff(saveAddr, recAddr, overwrite);
    elif ("contactAll" == tableName)
      FillFromAllCONTACT(saveAddr, recAddr, overwrite); // В данном случае overwrite = PartyID
    elif ("client" == tableName)
      FillFromCLIENT(saveAddr, recAddr, overwrite);
    elif ("objcode" == tableName)
      FillFromOBJCODE(saveAddr, recAddr, overwrite);
    elif ("persn" == tableName)
      FillFromPERSN(saveAddr, recAddr, overwrite);
    elif ("persnidc" == tableName)
      FillFromPERSNIDC(saveAddr, recAddr, overwrite);
    elif ("objrgdoc" == tableName)
      FillFromOBJRGDOC(saveAddr, recAddr, overwrite);
    elif ("officer" == tableName)
      FillFromOFFICERAddrBuff(saveAddr, recAddr, overwrite);
    elif ("officerAll" == tableName)
      FillFromAllOFFICER(saveAddr, recAddr, overwrite); // В данном случае overwrite = PartyID
    end;
  end;

  /* Отличаются ли буферы?*/
  macro IsChanges()
    var stat = ((oldData.PartyID         != newData.PartyID        ) or
                (oldData.LegalForm       != newData.LegalForm      ) or
                (oldData.ShortName       != newData.ShortName      ) or
                (oldData.Name            != newData.Name           ) or
                (oldData.Born            != newData.Born           ) or
                (oldData.BirsPlase       != newData.BirsPlase      ) or
                (oldData.IsMale          != newData.IsMale         ) or
                (oldData.CodeINN         != newData.CodeINN        ) or
                (oldData.CodeDepos       != newData.CodeDepos      ) or
                (oldData.CodeBank        != newData.CodeBank       ) or
                (oldData.PaperKind       != newData.PaperKind      ) or
                (oldData.PaperSeries     != newData.PaperSeries    ) or
                (oldData.PaperNumber     != newData.PaperNumber    ) or
                (oldData.PaperIssuer     != newData.PaperIssuer    ) or
                (oldData.PaperIssuerID   != newData.PaperIssuerID  ) or
                (oldData.PaperIssuedDate != newData.PaperIssuedDate) or
                (oldData.RegNumber       != newData.RegNumber      ) or
                (oldData.Index           != newData.Index          ) or
                (oldData.Country         != newData.Country        ) or
                (oldData.Region          != newData.Region         ) or
                (oldData.CodeProvince    != newData.CodeProvince   ) or
                (oldData.Province        != newData.Province       ) or
                (oldData.CodeDistrict    != newData.CodeDistrict   ) or
                (oldData.District        != newData.District       ) or
                (oldData.CodePlace       != newData.CodePlace      ) or
                (oldData.Place           != newData.Place          ) or
                (oldData.CodeStreet      != newData.CodeStreet     ) or
                (oldData.Street          != newData.Street         ) or
                (oldData.House           != newData.House          ) or
                (oldData.NumCorps        != newData.NumCorps       ) or
                (oldData.Flat            != newData.Flat           ) or
                (oldData.PostIndex       != newData.PostIndex      ) or
                (oldData.Address         != newData.Address        ) or
                (oldData.PhoneNumber     != newData.PhoneNumber    ) or
                (oldData.PhoneNumber2    != newData.PhoneNumber2   ) or
                (oldData.Fax             != newData.Fax            ) or
                (oldData.Telegraph       != newData.Telegraph      ) or
                (oldData.TelexNumber     != newData.TelexNumber    ) or
                (oldData.E_Mail          != newData.E_Mail         ) or
                (oldData.NotResident     != newData.NotResident    ) or
                (oldData.NRCountry       != newData.NRCountry      ) or
                (oldData.Status          != newData.Status         )
               );

    var i = 0;

    if (not stat)
      // проверим массивы
      var pers:TPerson;
      // ищем старого в новом и сверяем данные
      for (pers, oldData.Persons)
        i = FindPersons(newData.Persons, pers.OfficerID);
        stat = ((i==-1) or (not pers.IsEqual(newData.Persons[i])));
        if (stat)
          break;
        end;
      end;
      // ищем нового в старом и если не найден, то отличается
      if (not stat)
        for (pers, newData.Persons)
          stat = (not IsPersonInData(oldData.Persons, pers.OfficerID));
          if (stat)
            break;
          end;
        end;
      end;
    end;
    if (not stat)
      // проверим массивы
      var contact:TContact;
      // ищем старого в новом и сверяем данные
      for (contact, oldData.Contacts)
        i = FindContacts(newData.Contacts, contact.ContactID, contact.AddressType, contact.ContactKind, contact.ContactType, contact.IsMain);
        stat = ((i==-1) or (not contact.IsEqual(newData.Contacts[i])));
        if (stat)
          break;
        end;
      end;
      // ищем нового в старом и если не найден, то отличается
      if (not stat)
        for (contact, newData.Contacts)
          stat = (not IsContactInData(oldData.Contacts, contact.ContactID, contact.AddressType, contact.ContactKind, contact.ContactType, contact.IsMain));
          if (stat)
            break;
          end;
        end;
      end;
    end;

    return stat;
  end;
  macro CreateCopyPerson(elem):TPerson
    var pers = TPerson();
    pers.OfficerID = GenGetPropDefault(elem, "OfficerID", pers.OfficerID);
    pers.PersonID = GenGetPropDefault(elem, "PersonID", pers.PersonID);
    pers.IsFirstPerson = GenGetPropDefault(elem, "IsFirstPerson", pers.IsFirstPerson);
    return pers;
  end;

  macro CreateCopyContact(elem):TContact
    var contact = TContact();
    contact.ContactID   = GenGetPropDefault(elem, "ContactID",   contact.ContactID  );
    contact.PartyID     = GenGetPropDefault(elem, "PartyID",     contact.PartyID    );
    contact.AddressType = GenGetPropDefault(elem, "AddressType", contact.AddressType);
    contact.ContactKind = GenGetPropDefault(elem, "ContactKind", contact.ContactKind);
    contact.ContactType = GenGetPropDefault(elem, "ContactType", contact.ContactType);
    contact.Value       = GenGetPropDefault(elem, "Value",       contact.Value      );
    contact.IsMain      = GenGetPropDefault(elem, "IsMain",      contact.IsMain     );

    return contact;
  end;

  macro ConvertFromXmlObjectData(data, xmlObj, xmlObjName)
    var obj;
    obj = GenGetProp(xmlObj, xmlObjName);
    CopyValueFromXmlObjToObj(data, obj, "PartyID"        );
    CopyValueFromXmlObjToObj(data, obj, "LegalForm"      );
    CopyValueFromXmlObjToObj(data, obj, "ShortName"      );
    CopyValueFromXmlObjToObj(data, obj, "Name"           );
    CopyValueFromXmlObjToObj(data, obj, "Born"           );
    CopyValueFromXmlObjToObj(data, obj, "BirsPlase"      );
    CopyValueFromXmlObjToObj(data, obj, "IsMale"         );
    CopyValueFromXmlObjToObj(data, obj, "CodeINN"        );
    CopyValueFromXmlObjToObj(data, obj, "CodeDepos"      );
    CopyValueFromXmlObjToObj(data, obj, "CodeBank"       );
    CopyValueFromXmlObjToObj(data, obj, "PaperKind"      );
    CopyValueFromXmlObjToObj(data, obj, "PaperSeries"    );
    CopyValueFromXmlObjToObj(data, obj, "PaperNumber"    );
    CopyValueFromXmlObjToObj(data, obj, "PaperIssuer"    );
    CopyValueFromXmlObjToObj(data, obj, "PaperIssuerID"  );
    CopyValueFromXmlObjToObj(data, obj, "PaperIssuedDate");
    CopyValueFromXmlObjToObj(data, obj, "RegNumber"      );
    CopyValueFromXmlObjToObj(data, obj, "Index"          );
    CopyValueFromXmlObjToObj(data, obj, "Country"        );
    CopyValueFromXmlObjToObj(data, obj, "Region"         );
    CopyValueFromXmlObjToObj(data, obj, "CodeProvince"   );
    CopyValueFromXmlObjToObj(data, obj, "Province"       );
    CopyValueFromXmlObjToObj(data, obj, "CodeDistrict"   );
    CopyValueFromXmlObjToObj(data, obj, "District"       );
    CopyValueFromXmlObjToObj(data, obj, "CodePlace"      );
    CopyValueFromXmlObjToObj(data, obj, "Place"          );
    CopyValueFromXmlObjToObj(data, obj, "CodeStreet"     );
    CopyValueFromXmlObjToObj(data, obj, "Street"         );
    CopyValueFromXmlObjToObj(data, obj, "House"          );
    CopyValueFromXmlObjToObj(data, obj, "NumCorps"       );
    CopyValueFromXmlObjToObj(data, obj, "Flat"           );
    CopyValueFromXmlObjToObj(data, obj, "PostIndex"      );
    CopyValueFromXmlObjToObj(data, obj, "Address"        );
    CopyValueFromXmlObjToObj(data, obj, "PhoneNumber"    );
    CopyValueFromXmlObjToObj(data, obj, "PhoneNumber2"   );
    CopyValueFromXmlObjToObj(data, obj, "Fax"            );
    CopyValueFromXmlObjToObj(data, obj, "Telegraph"      );
    CopyValueFromXmlObjToObj(data, obj, "TelexNumber"    );
    CopyValueFromXmlObjToObj(data, obj, "E_Mail"         );
    CopyValueFromXmlObjToObj(data, obj, "NotResident"    );
    CopyValueFromXmlObjToObj(data, obj, "NRCountry"      );
    CopyValueFromXmlObjToObj(data, obj, "Status"         );

    // копируем массив первых\вторых лиц
    CopyArrayFromXmlObjToObj(data, obj, "Persons", R2M(this, "CreateCopyPerson"));

    // копируем массив способов связи
    CopyArrayFromXmlObjToObj(data, obj, "Contacts", R2M(this, "CreateCopyContact"));

    // нет объекта. Заглушка
    onError(er)
      ;
  end;

  // идентификатор данных
  macro GetReqID()
    return "DepoParty";
  end;
  // ---------------------------------------
  // Методы для вывода на экран

  private macro GetPaperName(kind:integer):string
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT t_Name FROM dpaprkind_dbt WHERE t_PaperKind = ?");
    cmd.addParam(kind);

    dataSet = cmd.execute();

    if (dataSet.moveNext())
      return dataSet.Name;
    end;

    return "";

    onError(er)
      return "";
  end;
  private macro GetRegDocName(kind:integer):string
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT t_Name FROM dobjkdoc_dbt WHERE t_ObjectType = 3 AND t_RegDocKind = ?");
    cmd.addParam(kind);

    dataSet = cmd.execute();

    if (dataSet.moveNext())
      return dataSet.Name;
    end;

    return "";

    onError(er)
      return "";
  end;
  private macro GetPartyName(partyID:integer, iRep:integer):string
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT t_Name, t_ShortName FROM dparty_dbt WHERE t_PartyID = ?");
    cmd.addParam(partyID);

    dataSet = cmd.execute();

    if (dataSet.moveNext())
      if (iRep != 0)
        return dataSet.Name;
      else
        return dataSet.ShortName;
      end;
    end;

    return "";

    onError(er)
      return "";
  end;
  private macro GetCountryName(country:string):string
    var cmd, dataSet;

    if(country != "")
      cmd = DL_RSDCommand("SELECT t_Name FROM dcountry_dbt WHERE t_CodeLat3 = ?");
      cmd.addParam(country);

      dataSet = cmd.execute();

      if (dataSet.moveNext())
        return dataSet.Name;
      end;
    end;

    return "";

    onError(er)
      return "";
  end;
  private macro GetAdmTerrName(place:string, LevelSQL:string, iRep:integer):string
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT t_NamePlace, t_Place FROM dadmterr_dbt WHERE t_Place = ? AND " + LevelSQL);
    cmd.addParam(place);

    dataSet = cmd.execute();

    if (dataSet.moveNext())
      if (iRep != 0)
        return dataSet.NamePlace;
      else
        return dataSet.Place;
      end;
    end;

    return "";

    onError(er)
      return "";
  end;

  private macro GetContactKind(ContactKind)
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT t_Name FROM dcontactkind_dbt WHERE t_Kind = ?");
    cmd.addParam(ContactKind);

    dataSet = cmd.execute();

    if (dataSet.moveNext())
      return dataSet.Name;
    end;

    return "";

    onError(er)
      return "";
  end;

  private macro GetContactType(ContactType, ContactKind)
    var cmd, dataSet;

    cmd = DL_RSDCommand("SELECT t_Name FROM dcontacttype_dbt WHERE t_Type = ? and t_Kind = ?");
    cmd.addParam(ContactType);
    cmd.addParam(ContactKind);

    dataSet = cmd.execute();

    if (dataSet.moveNext())
      return dataSet.Name;
    end;

    return "";

    onError(er)
      return "";
  end;

  /* Составить массивы операций "до" и "после" */
  macro WriteToArray(nameArr:TArray, oldArr:TArray, newArr:TArray, iRep:integer, operdate:date)
    // 1. name по индексу соответсвует old и new
    // 2. если name пустой, то в интерфейс не выводим
    // 3. если old или new пустой, то не задан

    // ВНИМАНИЕ!!! Индексы массивов используюстя в сишнике. Не путать!!

    SetArrayForm("PartyID", "", "", nameArr, oldArr, newArr);
    SetArrayForm("LegalForm", "", "", nameArr, oldArr, newArr);
    if ((oldData.LegalForm == PTLEGF_PERSN) or (newData.LegalForm == PTLEGF_PERSN)) // ИЛИ, т.к. может чего-то не быть, а форма старого состояния отличаться от нового состояния не будет
      SetArrayForm("Сокращенное  наименование", "", "", nameArr, oldArr, newArr);
      SetArrayForm("Наименование", oldData.Name, newData.Name, nameArr, oldArr, newArr);

      SetArrayForm("Дата рождения", oldData.Born, newData.Born, nameArr, oldArr, newArr);
      SetArrayForm("Место рождения", oldData.BirsPlase, newData.BirsPlase, nameArr, oldArr, newArr);
      SetArrayForm("Пол", name_alg(2708, IIF(oldData.IsMale==SET_CHAR, 1, 2)),
                          name_alg(2708, IIF(newData.IsMale==SET_CHAR, 1, 2)), nameArr, oldArr, newArr);
      SetArrayForm("ИНН", oldData.CodeINN, newData.CodeINN, nameArr, oldArr, newArr);
      SetArrayForm("Регистрационный номер депозитария", oldData.CodeDepos, newData.CodeDepos, nameArr, oldArr, newArr);
      SetArrayForm("Номер банковской лицензии", oldData.CodeBank, newData.CodeBank, nameArr, oldArr, newArr);

      SetArrayForm("Вид документа", GetPaperName(oldData.PaperKind), GetPaperName(newData.PaperKind), nameArr, oldArr, newArr);
      SetArrayForm("Серия документа", oldData.PaperSeries, newData.PaperSeries, nameArr, oldArr, newArr);
      SetArrayForm("Номер документа", oldData.PaperNumber, newData.PaperNumber, nameArr, oldArr, newArr);
      SetArrayForm("Кем выдан", oldData.PaperIssuer, newData.PaperIssuer, nameArr, oldArr, newArr);
      SetArrayForm("Когда выдан", oldData.PaperIssuedDate, newData.PaperIssuedDate, nameArr, oldArr, newArr);
      SetArrayForm("Регистрационный номер", "", "", nameArr, oldArr, newArr);
    else
      SetArrayForm("Сокращенное  наименование", oldData.ShortName, newData.ShortName, nameArr, oldArr, newArr);
      SetArrayForm("Наименование", oldData.Name, newData.Name, nameArr, oldArr, newArr);
      SetArrayForm("Дата рождения", "", "", nameArr, oldArr, newArr);
      SetArrayForm("Место рождения", "", "", nameArr, oldArr, newArr);
      SetArrayForm("Пол", "", "", nameArr, oldArr, newArr);
      SetArrayForm("ИНН", oldData.CodeINN, newData.CodeINN, nameArr, oldArr, newArr);
      SetArrayForm("Регистрационный номер депозитария", oldData.CodeDepos, newData.CodeDepos, nameArr, oldArr, newArr);
      SetArrayForm("Номер банковской лицензии", oldData.CodeBank, newData.CodeBank, nameArr, oldArr, newArr);

      SetArrayForm("Вид документа", GetRegDocName(oldData.PaperKind), GetRegDocName(newData.PaperKind), nameArr, oldArr, newArr);
      SetArrayForm("Серия документа", oldData.PaperSeries, newData.PaperSeries, nameArr, oldArr, newArr);
      SetArrayForm("Номер документа", oldData.PaperNumber, newData.PaperNumber, nameArr, oldArr, newArr);
      SetArrayForm("Кем выдан", GetPartyName(oldData.PartyID, iRep), GetPartyName(newData.PartyID, iRep), nameArr, oldArr, newArr);
      SetArrayForm("Когда выдан", oldData.PaperIssuedDate, newData.PaperIssuedDate, nameArr, oldArr, newArr);
      SetArrayForm("Регистрационный номер", oldData.RegNumber, newData.RegNumber, nameArr, oldArr, newArr);
    end;
    // для всех
    SetArrayForm("Индекс", oldData.Index, newData.Index, nameArr, oldArr, newArr);
    SetArrayForm("Страна", GetCountryName(oldData.Country), GetCountryName(newData.Country), nameArr, oldArr, newArr);
    SetArrayForm("Регион", oldData.Region, newData.Region, nameArr, oldArr, newArr);
    SetArrayForm("CodeProvince", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Область", Trim(oldData.Province+" "+GetAdmTerrName(oldData.CodeProvince, "t_ProvinceLevel = 'X'", iRep)),
                            Trim(newData.Province+" "+GetAdmTerrName(newData.CodeProvince, "t_ProvinceLevel = 'X'", iRep)),  nameArr, oldArr, newArr);
    SetArrayForm("CodeDistrict", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Район", Trim(oldData.District+" "+GetAdmTerrName(oldData.CodeDistrict, "t_DistrictLevel = 'X'", iRep)),
                          Trim(newData.District+" "+GetAdmTerrName(newData.CodeDistrict, "t_DistrictLevel = 'X'", iRep)),  nameArr, oldArr, newArr);
    SetArrayForm("CodePlace", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Населенный пункт", Trim(GetAdmTerrName(oldData.CodePlace, "t_PlaceLevel = 'X'", iRep)+" "+oldData.Place),
                                     Trim(GetAdmTerrName(newData.CodePlace, "t_PlaceLevel = 'X'", iRep)+" "+newData.Place),  nameArr, oldArr, newArr);
    SetArrayForm("CodeStreet", "", "", nameArr, oldArr, newArr);
    SetArrayForm("Улица", Trim(GetAdmTerrName(oldData.CodeStreet, "t_StreetLevel = 'X'", iRep)+" "+oldData.Street),
                          Trim(GetAdmTerrName(newData.CodeStreet, "t_StreetLevel = 'X'", iRep)+" "+newData.Street),  nameArr, oldArr, newArr);
    SetArrayForm("Дом", oldData.House, newData.House, nameArr, oldArr, newArr);
    SetArrayForm("Корпус", oldData.NumCorps, newData.NumCorps, nameArr, oldArr, newArr);
    SetArrayForm("Квартира", oldData.Flat, newData.Flat, nameArr, oldArr, newArr);
    SetArrayForm("Почтовый индекс", oldData.PostIndex, newData.PostIndex, nameArr, oldArr, newArr);
    SetArrayForm("Почтовый адрес", oldData.Address, newData.Address, nameArr, oldArr, newArr);
    SetArrayForm("Телефон", oldData.PhoneNumber, newData.PhoneNumber, nameArr, oldArr, newArr);
    SetArrayForm("Дополнительный телефон", oldData.PhoneNumber2, newData.PhoneNumber2, nameArr, oldArr, newArr);
    SetArrayForm("Факс", oldData.Fax, newData.Fax, nameArr, oldArr, newArr);
    SetArrayForm("Телеграф", oldData.Telegraph, newData.Telegraph, nameArr, oldArr, newArr);
    SetArrayForm("Телекс", oldData.TelexNumber, newData.TelexNumber, nameArr, oldArr, newArr);
    SetArrayForm("e-mail", oldData.E_Mail, newData.E_Mail, nameArr, oldArr, newArr);
    SetArrayForm("Нерезидент", oldData.NotResident, newData.NotResident, nameArr, oldArr, newArr);
    SetArrayForm("Юрисдикция", GetCountryName(oldData.NRCountry), GetCountryName(newData.NRCountry), nameArr, oldArr, newArr);
    //..статус
    SetArrayForm("Статус", IIF(oldData.Status != -1, name_alg(3243, IIF(oldData.Status == 1, 0, 1)), ""),
                           IIF(newData.Status != -1, name_alg(3243, IIF(newData.Status == 1, 0, 1)), ""), nameArr, oldArr, newArr);

    var i = 0;
    var oldStr = "", newStr = "";

    // Persons
    if ((oldData.Persons.size != 0) or (newData.Persons.size != 0))
      // по старой ищем новую и добавляем
      var pers:TPerson;
      for (pers, oldData.Persons)
        newStr = "";
        i = FindPersons(newData.Persons, pers.OfficerID);
        // может возникнуть ситуация - у субъекта есть сотрудник, который и есть сам субъект
        // что бы не искать адм. операцию для сотрудника и тем самым не вызвать зацикливание
        // проверим что сотрудник не является субъектом по текущей адм. операции
        // если это не один и тот же субъект, то будем искать для него адм. операцию и брать оттуда данные
        // иначе мы и так уже находимся в нужной нам адм. операции по сотруднику-субъекту
        // просто возьмем из неё данные
        if(pers.PersonID != newData.PartyID)
          oldStr = WriteFullParty(pers.PersonID, iRep, operdate);
        else
          oldStr = IIF((oldData.LegalForm == PTLEGF_PERSN) or (newData.LegalForm == PTLEGF_PERSN), oldData.Name, oldData.ShortName);
        end;
        if (i != -1)
          // см. выше
          if(newData.Persons[i].PersonID != newData.PartyID)
            newStr = WriteFullParty(newData.Persons[i].PersonID, iRep, operdate);
          else
            newStr = IIF((oldData.LegalForm == PTLEGF_PERSN) or (newData.LegalForm == PTLEGF_PERSN), newData.Name, newData.ShortName);
          end;
        end;
        SetArrayForm(IIF((pers.IsFirstPerson == SET_CHAR) or ((i != -1) and (newData.Persons[i].IsFirstPerson == SET_CHAR)), "Первое лицо", "Второе лицо"),
                     oldStr, newStr, nameArr, oldArr, newArr);
      end;
      // по новому массиву ищем записи, у которых нет парной в старой
      for (pers, newData.Persons)
        if (not IsPersonInData(oldData.Persons, pers.OfficerID))
          // см. выше
          if(pers.PersonID != newData.PartyID)
            newStr = WriteFullParty(pers.PersonID, iRep, operdate);
          else
            newStr = IIF((oldData.LegalForm == PTLEGF_PERSN) or (newData.LegalForm == PTLEGF_PERSN), newData.Name, newData.ShortName);
          end;
          SetArrayForm(IIF(pers.IsFirstPerson == SET_CHAR, "Первое лицо", "Второе лицо"), "", newStr, nameArr, oldArr, newArr);
        end;
      end;
    end;

    // Contacts
    if ((oldData.Contacts.size != 0) or (newData.Contacts.size != 0))
      // по старой ищем новую и добавляем
      var contact:TContact;
      var ContactType = "", ContactKind = "";
      for (contact, oldData.Contacts)
        oldStr = "";
        newStr = "";
        i = FindContacts(newData.Contacts, contact.ContactID, contact.AddressType, contact.ContactKind, contact.ContactType, contact.IsMain);

        ContactKind = GetContactKind(contact.ContactKind);
        ContactType = GetContactType(contact.ContactType, contact.ContactKind);
        oldStr = contact.Value;
        if (i != -1)
          newStr = newData.Contacts[i].Value;
        end;
        SetArrayForm(ContactKind + IIF(ContactType != "", " ("+ContactType+")", "") + IIF(contact.IsMain == SET_CHAR, " осн.", " доп."),
                     oldStr, newStr, nameArr, oldArr, newArr);
      end;
      // по новому массиву ищем записи, у которых нет парной в старой
      for (contact, newData.Contacts)
        if (not IsContactInData(oldData.Contacts, contact.ContactID, contact.AddressType, contact.ContactKind, contact.ContactType, contact.IsMain))
          newStr = contact.Value;

          ContactKind = GetContactKind(contact.ContactKind);
          ContactType = GetContactType(contact.ContactType, contact.ContactKind);
          SetArrayForm(ContactKind + IIF(ContactType != "", " ("+ContactType+")", "") + IIF(contact.IsMain == SET_CHAR, " осн.", " доп."),
                       "", newStr, nameArr, oldArr, newArr);
        end;
      end;
    end;
  end;

  InitTDepoAdmoCLOB;
  // записи
  oldData = TData;
  newData = TData;
end;

/* Инициализация форм */
macro InitForms(item:integer)
  clobData  = null;
  if (SPDP_DEPO_ACCOUNT == item)
    clobData = TDepoAdmoClobDACNT;
  elif (SPDP_DEPO_PARTITION == item) // раздел счета депо
    clobData = TDepoAdmoClobDPART;
  elif (SPDP_FACE_ACCOUNT == item) // лицевой счет
    clobData = TDepoAdmoClobACC;
  elif (SPDP_AVOIRIS == item) // Ц\б
    clobData = TDepoAdmoClobAVOIR;
  elif (SPDP_INVCARD == item)
    clobData = TDepoAdmoClobINVCARD;
  elif ((SPDP_CLIENT        == item) or
        (SPDP_OURDEPOSITARY == item) or
        (SPDP_STORAGEPLACE  == item) or
        (SPDP_GUARDIAN      == item) or
        (SPDP_OPERATOR      == item) or
        (SPDP_MANAGER       == item) or
        (SPDP_DEPOCORR      == item)
       )
    clobData = TDepoAdmoClobPARTY;
  else
    msgbox("Неизвестная административная операция");
    clobData = TDepoAdmoCLOB;
  end;
end;
/**************************************************************************************************/
/* Методы, вызываемые из системы                                                                  */

/* Инициализация форм */
macro FillFromBuffs(tableName:string, saveAddr:memaddr, recAddr:memaddr, overwrite:integer)
  clobData.FillFromBuffs(tableName, saveAddr, recAddr, overwrite);
end;

/* Есть ли отличия? */
macro IsChanges():bool
  return clobData.IsChanges();
end;

/* Сохранение CLOB-данных во временной таблице */
macro SaveClobDataTMP(id:integer):integer
  var stat = 0;
  var xmlData:string = "";

  stat = ConvertToXML(clobData, clobData.GetReqID(), xmlData);

  if (stat == 0)
    SQL_Execute( "DELETE FROM DDEPOADMOCLOB_TMP WHERE T_ADMOPRID = "+String(id));
  end;

  if (stat == 0)
    var cmd = RSDCommand( "INSERT INTO DDEPOADMOCLOB_TMP (T_ADMOPRID, T_FMTCLOBDATA_XXXX)"
                         +"            VALUES  (?, ?)");

    cmd.NullConversion = true;
    cmd.addParam( "", RSDBP_IN, id      );
    cmd.addParam( "", RSDBP_IN, xmlData );
    cmd.execute();
  else
    MsgBox("Ошибка при конвретации в xml");
  end;

  return stat;
  OnError(er)
    msgbox(er.message);
end;

/* Получение Clob-данных из временной таблицы */
macro GetClobDataFromTMP(id:integer, type:integer):integer
  var xmlData = "";
  var cmdLength = RSDCommand("SELECT NVL(DBMS_LOB.GETLENGTH(T_FMTCLOBDATA_XXXX), 0) as t_lengthClob FROM "+IIF(id<0, "DDEPOADMOCLOB_TMP", "DDEPOADMO_DBT")+" WHERE T_ADMOPRID = ?");
  var dataSetLength;
  var stat = 0;

  cmdLength.addParam("", RSDBP_IN, id);
  cmdLength.execute();
  dataSetLength = TRsbDataSet(cmdLength);

  if (dataSetLength.moveNext())
    var lengthClob = Int(dataSetLength.lengthClob);
    if (lengthClob != 0)
      var cmd = RSDCommand( " DECLARE  "
                           +"  v_clobData CLOB; "
                           +" BEGIN "
                           +"   select T_FMTCLOBDATA_XXXX into v_clobData FROM "+IIF(id<0, "DDEPOADMOCLOB_TMP", "DDEPOADMO_DBT")
                           +"    WHERE T_ADMOPRID = ?;"
                           +"   ? := v_clobData;"
                           +" END;");
      cmd.addParam("", RSDBP_IN, id );
      cmd.addParam("", RSDBP_OUT, V_STRING, lengthClob+1);
      cmd.execute();

      xmlData = cmd.value(1);

      var xmlObj = null;
      stat = ConvertToRSL(xmlData, xmlObj);

      if (stat == 0)
         InitForms(type);
         clobData.ConvertFromXmlObject(xmlObj);
         xmlObj = null;
      else
        MsgBox("Ошибка при конвертации XML-документа в RSL-объект");
      end;

    end;
  end;

  return stat;
end;

/* вытащить из АО clob */
macro LoadClobDataByAdmo(AdmoprID:integer)

  var stat = 0;
  var TableName = IIF(AdmoprID < 0, "DDEPOADMO_TMP", "DDEPOADMO_DBT");
  var cmdLength = DL_RSDCommand("SELECT NVL(DBMS_LOB.GETLENGTH(T_FMTCLOBDATA_XXXX), 0) as t_lengthClob FROM "+TableName+" WHERE T_ADMOPRID = ?");
  var dataSetLength;
  var xmlData = "";
  var type = 0;

  cmdLength.addParam(AdmoprID);
  dataSetLength = cmdLength.execute();
  if(dataSetLength.moveNext())
    var lengthClob = Int(dataSetLength.lengthClob);
    if (lengthClob != 0)
      var cmd = RSDCommand( " DECLARE  "
                           +"  v_clobData CLOB; "
                           +"  v_item NUMBER; "
                           +" BEGIN "
                           +"   select T_FMTCLOBDATA_XXXX, T_ITEM into v_clobData, v_item FROM "+TableName+" WHERE T_ADMOPRID = ?;"
                           +"   ? := v_clobData;"
                           +"   ? := v_item;"
                           +" END;");
      cmd.addParam("", RSDBP_IN, AdmoprID );
      cmd.addParam("", RSDBP_OUT, V_STRING, lengthClob+1);
      cmd.addParam("", RSDBP_OUT, V_INTEGER);
      cmd.execute();

      xmlData = cmd.value(1);
      type = cmd.value(2);

      var xmlObj = null;
      stat = ConvertToRSL(xmlData, xmlObj);

      if (stat == 0)
         InitForms(type);
         clobData.ConvertFromXmlObject(xmlObj);
         xmlObj = null;
      else
        MsgBox("Ошибка при конвертации XML-документа в RSL-объект");
      end;
    else
      //msgbox("Нет данных для показа");
      stat = 1;
    end;
  end;

  return stat;
end;

macro WriteToForm(nameArr:@TArray, oldArr:@TArray, newArr:@TArray, iRep:integer, operdate:date, id:integer):integer
  var stat = 0;

  stat = LoadClobDataByAdmo(id);

  if((stat == 0) and (clobData))
    clobData.WriteToArray(nameArr, oldArr, newArr, iRep, operdate);
  end;

  return stat;
end;

/* получить значение из переменной части АО (до или после) */
macro GetParmValue(parmName:string, AdmoprID:integer, IsTo:bool)
  var val = NULL;
  var stat = 0;

  if(clobData == NULL)
    LoadClobDataByAdmo(AdmoprID);
  end;

  if(clobData)
    // получить отмененное УЛ
    if ("GetCancelAcap" == parmName)
      if ("TDEPOADMOCLOBDACNT" == GenClassName(clobData))
        val = clobData.GetCancelAcapID();
      end;
    elif ("GetAcapRole" == parmName)
      if ("TDEPOADMOCLOBDACNT" == GenClassName(clobData))
        val = clobData.GetAcapRole();
      end;
    elif ("GetAcapPartyID" == parmName)
      if ("TDEPOADMOCLOBDACNT" == GenClassName(clobData))
        val = clobData.GetAcapPartyID();
      end;
    else // другие параметры
      val = GenGetProp(IIF(IsTo, clobData.newData, clobData.oldData), parmName);
    end;
  end;

  return val;

OnError(er)
  msgbox("Ошибка определения параметра \""+parmName+"\" АО");
end;

/* Обновить объекты в переменных частях АО */
macro UpdateObjDpadm(id:integer,
                     type:integer,
                     OperKind:integer,
                     PartyID:integer,
                     DepoAcc:integer,
                     DepoPart:integer,
                     FIID:integer,
                     Account:string,
                     InvCardID:integer,
                     ItemOnly:integer)
  var stat = 0;
  var dpac = TBFile("depoacnt.dbt");

  stat = GetClobDataFromTMP(id, type);

  if(not stat)

    if((type == SPDP_CLIENT) OR
       (type == SPDP_OURDEPOSITARY) OR
       (type == SPDP_STORAGEPLACE) OR
       (type == SPDP_GUARDIAN) OR
       (type == SPDP_OPERATOR) OR
       (type == SPDP_MANAGER) OR
       (type == SPDP_DEPOCORR) )

        if( OperKind != SPAO_CON_REGISTERING )
          clobData.oldData.PartyID = PartyID;
        end;

        clobData.newData.PartyID = PartyID;

    elif(type == SPDP_AVOIRIS)

      if( OperKind != SPAO_CON_REGISTERING )
        clobData.oldData.FIID = FIID;
      end;
      clobData.newData.FIID = FIID;

    elif(type == SPDP_DEPO_ACCOUNT)

      if( OperKind != SPAO_CON_REGISTERING )
        clobData.oldData.AutoKey = DepoAcc;
        if( ItemOnly )
          clobData.oldData.Owner = PartyID;
        end;
      end;

      clobData.newData.AutoKey = DepoAcc;
      if( ItemOnly )
        clobData.newData.Owner = PartyID;
      end;
    elif(type == SPDP_DEPO_PARTITION)

      if( OperKind != SPAO_CON_REGISTERING )
        clobData.oldData.AutoKey = DepoPart;

        if( ItemOnly )
          clobData.oldData.Root  = DepoAcc;
          clobData.oldData.Owner = PartyID;
        end;
      end;

      clobData.newData.AutoKey = DepoPart;

      if( ItemOnly )
        clobData.newData.Root  = DepoAcc;
        clobData.newData.Owner = PartyID;
      end;

    elif(type == SPDP_FACE_ACCOUNT)

      if( OperKind != SPAO_CON_REGISTERING )
        clobData.oldData.Code_Currency = FIID;
        if(Account != NULL)
          clobData.oldData.Account = Account;
        else
          clobData.oldData.Account = "";
        end;

        if( ItemOnly )
          clobData.oldData.DepoRoot = DepoAcc;

          dpac.rec.AutoKey = DepoAcc;
          if(not dpac.GetEQ())
            clobData.oldData.DepoRootType = 0;
          else
            clobData.oldData.DepoRootType = dpac.rec.Type;
          end;
          clobData.oldData.DepoAcc = DepoPart;
          clobData.oldData.Client  = PartyID;
        end;
      end;

      clobData.newData.Code_Currency = FIID;
      if(Account != NULL)
        clobData.newData.Account = Account;
      else
        clobData.newData.Account = "";
      end;

      if( ItemOnly )
        clobData.newData.DepoRoot = DepoAcc;

        dpac.rec.AutoKey = DepoAcc;
        if(not dpac.GetEQ())
          clobData.newData.DepoRootType = 0;
        else
          clobData.newData.DepoRootType = dpac.rec.Type;
        end;
        clobData.newData.DepoAcc = DepoPart;
        clobData.newData.Client  = PartyID;
      end;
    elif(type == SPDP_INVCARD)

      if( OperKind != SPAO_CON_REGISTERING)
        clobData.oldData.InvCardID = InvCardID;
      end;
      clobData.newData.InvCardID = InvCardID;
    end;

    stat = SaveClobDataTMP(id);
  end;

  return stat;
end;

/* объединить переменные части двух АО */
macro CombineDepoAdmo(BaseAdmOprID:integer, CombineAdmOprID:integer, IsTo:bool)
  var stat = 0;
  var BasePart;

  stat = LoadClobDataByAdmo(BaseAdmOprID);
  if((not stat) and (clobData))
    BasePart = IIF(IsTo, clobData.newData, clobData.oldData);

    stat = LoadClobDataByAdmo(CombineAdmOprID);

    if((not stat) and (clobData))
      if(IsTo)
        clobData.newData = BasePart;
      else
        clobData.oldData = BasePart;
      end;

      stat = SaveClobDataTMP(CombineAdmOprID);
    end;
  end;

  return stat;
end;
