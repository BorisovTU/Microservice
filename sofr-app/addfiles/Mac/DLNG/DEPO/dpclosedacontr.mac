/*
$Name: dpclosedacontr.mac
$Module: Депозитарий
$Description: Закрытие счетов депо Депозитарием по уведомлениям
*/

Import rsd;
import DPInter, "secinter.mac", "dpstdrep.mac", "fi.mac", "ws_validation.mac", "spserv.mac";
import RsbDataSet;
import FIInter, CurrInter, CTInter, secinter, deposerv;

private const CHAPT5 = 5; //глава л/с депо
var N = 0;
var err = 0;          
GetRegistryValue("DEPO\\DAYS_FROM_NOTICE", V_INTEGER, N, err);

var HeadTable = "┌─────────────────────────┬─────────────────┬─────────────────┬─────────────────┬───────────────┬─────────────────────────┬────────────────────────┐\n"+
                "│     Номер счёта депо    │  Наименование   │  Наименование   │   Код анкеты    │ Дата открытия │       Номер раздела     │ Дата открытия раздела  │\n"+
                "│                         │  счета депо     │   Депонента     │    депонента    │     счета     │        счета депо       │     счета депо         │\n"+
                "├─────────────────────────┼─────────────────┼─────────────────┼─────────────────┼───────────────┼─────────────────────────┼────────────────────────┤";

var tablewidth = Index(HeadTable, "\n");
var Rep = CMakeReport(HeadTable);
var RepHead = CMakeReport("заголовок");
var   HeaderStr = "Протокол процедуры закрытия пассивных счетов депо при расторжении Депозитарного договора в одностороннем порядке путем направления Депоненту соответствующего уведомления о расторжении за " + N +  " дней";
const RepFontStyleTitel =  "ex_FS(b)";
var  _is_ap;
var HeadDate = "за <"+date_as_string(1,{Curdate},false)+">";
DP_StdHeaderLO_Ex( RepHead, RepFontStyleTitel, HeaderStr, 0, 0, false, null, null, tablewidth );
DP_AddPrintCell( RepHead, headDate, 140, 0, "r:" + RepFontStyleTitel,_is_ap, REP_ELEM_STR );
   RepHead.AddStr();

var HeadTable1 = "┌─────────────────────────┬─────────────────┬─────────────────┬─────────────────┬───────────────────────┬──────────────────────────────────────────┐\n"+
                 "│     Номер счёта депо    │  Наименование   │  Наименование   │   Код анкеты    │      Номер раздела    │                Причина                   │\n"+
                 "│                         │  счета депо     │   Депонента     │    депонента    │       счета депо      │                                          │\n"+
                 "├─────────────────────────┼─────────────────┼─────────────────┼─────────────────┼───────────────────────┼──────────────────────────────────────────┤";

var tablewidth1 = Index(HeadTable1, "\n");
var Rep1 = CMakeReport(HeadTable1);
const RepFontStyleTitel1 =  "ex_FS(b)";

var Rep2 = CMakeReport(HeadTable1);

VAR CountErr = 0, CountMes = 0, CountErrNotNull = 0;

macro PrintStr(CodeDA, NameDA, NameDep, CodeDep,
               OpenDateDA, CodeDP, OpenDateDP)

   DP_AddPrintCell( Rep, CodeDA, 0, 0, "l:w" + RepFontStyleTitel );
   DP_AddPrintCell( Rep, NameDA, 0, 0, "l:w" + RepFontStyleTitel );
   DP_AddPrintCell( Rep, NameDep, 0, 0, "l:w" + RepFontStyleTitel );
   DP_AddPrintCell( Rep, CodeDep, 0, 0, "l:w" + RepFontStyleTitel );
   DP_AddPrintCell( Rep, OpenDateDA, 0, 0, "l:w" + RepFontStyleTitel );
   DP_AddPrintCell( Rep, CodeDP, 0, 0, "l:w" + RepFontStyleTitel );
   DP_AddPrintCell( Rep, OpenDateDP, 0, 0, "r:w" + RepFontStyleTitel );
   Rep.AddStr();
end;
	
macro PrintStr1(CodeDA, NameDA, NameDep, CodeDep,
               CodeDP, Mes)

   DP_AddPrintCell( Rep1, CodeDA, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep1, NameDA, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep1, NameDep, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep1, CodeDep, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep1, CodeDP, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep1, Mes, 0, 0, "l:w" + RepFontStyleTitel1 );
   Rep1.AddStr();
end;

macro PrintStr2(CodeDA, NameDA, NameDep, CodeDep,
               CodeDP, Mes)

   DP_AddPrintCell( Rep2, CodeDA, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep2, NameDA, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep2, NameDep, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep2, CodeDep, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep2, CodeDP, 0, 0, "l:w" + RepFontStyleTitel1 );
   DP_AddPrintCell( Rep2, Mes, 0, 0, "l:w" + RepFontStyleTitel1 );
   Rep2.AddStr();
end;

// проверка счета депо на открытые лицевые счета
PRIVATE MACRO IsCloseAcc(dpacc)

  var query, Select, DataSet;
  var closed = 0;
  var  CodeDA = "", NameDA = "", NameDep = "", CodeDep = "" , CodeDP = "", Mes = "";
  CodeDA = dpacc.rec.Code;
  NameDA = dpacc.rec.Name;
  CodeDep = ПолучитьКодСубъекта(dpacc.rec.Owner,1);
  NameDep = GetPartyName(dpacc.rec.Owner, PTKN_FULLNAME);
  Mes = "Необходимо запустить закрытие нулевых лицевых счетов";

  query = " SELECT acnt.t_code, count(ACNT.t_autokey) "
        + " FROM daccount_dbt acc, ddepoacnt_dbt acnt "
        + " WHERE acc.t_chapter = 5 "
        + " AND acc.t_open_close = chr(0) "
        + " AND acc.t_deporoot = ? "
        + " AND acnt.t_autokey = acc.t_depoacc " 
        + " GROUP BY acnt.t_code ";
  Select = RSDCommand( query );
  Select.AddParam("Deporoot",  RSDBP_IN, dpacc.rec.Autokey );
  Select.Execute();
  DataSet = TRsbDataSet(Select);
  while(DataSet.moveNext())            //CodeDep??
    closed = closed +1 ;
    CodeDP = DataSet.Code;
    PrintStr1(CodeDA, NameDA, NameDep, CodeDep, CodeDP, Mes);

  end;

return closed;
END;

// заполнение массива 
PRIVATE MACRO FillOpClose(dpacc,OpClose:@TArray)
  var query, Select, DataSet;
  var i = 0;
  query = " SELECT acnt.* "
        + " FROM ddepoacnt_dbt acnt"
        + " WHERE acnt.t_root = ? "               
        + " ORDER BY acnt.t_autokey ";
  Select = RSDCommand( query );

  Select.AddParam("Root",  RSDBP_IN, dpacc.rec.autokey  );  /*0*/
  Select.Execute();

  DataSet = TRsbDataSet(Select);
  while(DataSet.moveNext())
    OpClose[i] = DataSet.Status;
    i = i+1;
  end;


END;

// вывод в протокол инф. о закрытых счета/ разделах депо
PRIVATE MACRO PrintRepRoot(dpacc,OpClose)
  var query, Select, DataSet;
  var i = 0;
  var  CodeDA = "", NameDA = "", NameDep = "", CodeDep = "" , OpenDateDA, CodeDP = "", OpenDateDP , Mes = "";
  CodeDA = dpacc.rec.Code;
  NameDA = dpacc.rec.Name;
  CodeDep = ПолучитьКодСубъекта(dpacc.rec.Owner,1);
  NameDep = GetPartyName(dpacc.rec.Owner, PTKN_FULLNAME);
  OpenDateDA = date_as_string(1,dpacc.rec.OpenDate,false);

  query = " SELECT acnt.* "
        + " FROM ddepoacnt_dbt acnt"
        + " WHERE acnt.t_root = ? "               
        + " ORDER BY acnt.t_autokey ";

  Select = RSDCommand( query );

  Select.AddParam("Root",  RSDBP_IN, dpacc.rec.autokey  );  /*0*/
  Select.Execute();

  DataSet = TRsbDataSet(Select);
  while(DataSet.moveNext())
    if(not(DataSet.Autokey==DataSet.Root))
      CodeDP = DataSet.Code;
      OpenDateDP = date_as_string(1,DataSet.OpenDate,false);	
    end;
    if( not (OpClose[i]==1))
      PrintStr(CodeDA, NameDA, NameDep, CodeDep, OpenDateDA, CodeDP, OpenDateDP);
    end;
    i = i+1;
  end;

END;

PRIVATE MACRO  CheckAdmoprForDepoAcc(dpacc)
  Var quer, Sel, DataS, Dpar = -1, DparTemp = -1, count = 0 ;
  var  CodeDA1 = "", NameDA1 = "", NameDep1 = "", CodeDep1 = "" , CodeDP1 = "", Mes = "";

  quer = " select admo.t_DepoPart as DepoPart, acnt.t_code as Code "
       + " from ddepoadmo_dbt admo, ddepoacnt_dbt acnt "
       + " Where admo.t_operdate > ? "
       + " and admo.t_depoacc = ? "
       + " and acnt.t_Autokey(+) = admo.t_DepoPart "        
       + " order by admo.t_depopart";
  Sel = RSDCommand( quer );
  Sel.AddParam("OperDate", RSDBP_IN, {CurDate}        );       /*0*/
  Sel.AddParam("DEPOACC",  RSDBP_IN, dpacc.rec.autokey  );  /*1*/
  Sel.Execute();

  DataS = TRsbDataSet(Sel);
  while(DataS.moveNext())
    Dpar = DataS.DepoPart;
    if(Dpar != DparTemp)
      CodeDA1 = dpacc.rec.Code;
      NameDA1 = dpacc.rec.Name;
      CodeDep1 = ПолучитьКодСубъекта(dpacc.rec.Owner,1);
      NameDep1 = GetPartyName(dpacc.rec.Owner, PTKN_FULLNAME);
      if(DataS.DepoPart >0)
        CodeDP1 = DataS.Code ;
      end;
      if(Dpar==0)
        mes = "Для счета депо существуют административные операции за более поздние даты. Счет не закрыт";
      else
        mes = "Для раздела счета депо существуют административные операции за более поздние даты. Счет не закрыт";
      end;
      DparTemp = Dpar;                                                                            	
      PrintStr1(CodeDA1, NameDA1, NameDep1, CodeDep1, CodeDP1, Mes);
    end;
    count = count +1;
  end;
  return count;
END;

PRIVATE MACRO  CheckNullAcc(dpacc)
  Var quer, Select, DataSet, count = 0 ;
  var  CodeDA1 = "", NameDA1 = "", NameDep1 = "", CodeDep1 = "" , CodeDP1 = "", Mes = "";
  quer  = " select distinct acnt.t_code as code "         //нулевые остатки на всех (на закрытых они нулевые)
        + " from daccount_dbt acc , ddepoacnt_dbt acnt " 
        + " where acc.t_Chapter =  "+ CHAPT5
        + " and acc.t_Open_Date <= " + GetSQLDate({curdate})    //открыт ранее текущей даты
        + " and 0 <> rsb_account.restall(acc.T_ACCOUNT,acc.T_CHAPTER,acc.T_CODE_CURRENCY,"+ GetSQLDate({curdate}) +")"  
        + " and ACNT.T_AUTOKEY =  acc.t_depoacc "
        + " and ACC.T_DEPOroot = ? "
        ;
  Select = RSDCommand( quer );
  Select.AddParam("DEPOACC",  RSDBP_IN, dpacc.rec.autokey  );  /*0*/
  Select.Execute();

  DataSet = TRsbDataSet(Select);
  while(DataSet.moveNext())
    CodeDA1 = dpacc.rec.Code;
    NameDA1 = dpacc.rec.Name;
    CodeDep1 = ПолучитьКодСубъекта(dpacc.rec.Owner,1);
    NameDep1 = GetPartyName(dpacc.rec.Owner, PTKN_FULLNAME);
    CodeDP1 = DataSet.Code ;

    mes = "Наличие ненулевых остатков на счете депо. Счёт не закрыт. Необходимо осуществить списание ц/б со счета и повторить процедуру закрытия счетов.";
    PrintStr2(CodeDA1, NameDA1, NameDep1, CodeDep1, CodeDP1, Mes);
    CountErrNotNull = CountErrNotNull +1;
    count = count + 1;
  end;
  return count;
END;


// Получить по счету самую позднюю дату проводки, выполненной позднее текущей опердаты, если таковой нет - возвращает текущую дату, чтобы не возникало ошибки
private macro GetFinalDate(Account, Code_Currency, Chapter)
  var query, Select, DataSet;
  var Final_Date = {curdate};

  query =   " SELECT NVL(MAX(t_Date_Carry), TO_DATE('01.01.0001', 'DD.MM.YYYY')) t_Final_Date " +
            "   FROM dacctrn_dbt " +
            "  WHERE ((t_Account_Payer = ? AND t_FIID_Payer = ?) OR (t_Account_Receiver = ? AND t_FIID_Receiver = ?)) " +
            "    AND t_Chapter = ? " +
            "    AND t_State = ? " +
            "    AND t_Date_Carry > ? ";

  Select = RSDCommand( query );

  Select.AddParam("Account_Payer",    RSDBP_IN, Account );
  Select.AddParam("FIID_Payer",       RSDBP_IN, Code_Currency );
  Select.AddParam("Account_Receiver", RSDBP_IN, Account );
  Select.AddParam("FIID_Receiver",    RSDBP_IN, Code_Currency );
  Select.AddParam("Chapter",          RSDBP_IN, Chapter );
  Select.AddParam("State",            RSDBP_IN, TRN_STATE_FACT );
  Select.AddParam("Date_Carry",       RSDBP_IN, {curdate} );
  Select.Execute();

  DataSet = TRsbDataSet(Select);
  if((DataSet.moveNext()) AND (date(DataSet.Final_Date) != date(0,0,0)) )
    Final_Date = date(DataSet.Final_Date);
  end;

  return Final_Date;
end;

private macro GetFinalDateDEPO(dpacc)
  var acc = TRecHandler("account");
  var count = 0 ;
  var query, Select, DataSet;
  var  CodeDA1 = "", NameDA1 = "", NameDep1 = "", CodeDep1 = "" , CodeDP1 = "", Mes = "";
  var IDtmp = -1; 
    query =   " select acc.*, acnt.t_code  "
            + " from daccount_dbt acc, ddepoacnt_dbt acnt "
            + " where acc.t_Chapter = " + CHAPT5         //по 5-й главе
            + " and acc.t_DEPOACC  IN  (SELECT t_AutoKey FROM ddepoacnt_dbt "
            + " START WITH t_autokey = ? CONNECT BY PRIOR t_autokey = t_superior )"
            + " AND acnt.t_autokey = acc.t_depoacc " 
            ;

   Select = RSDCommand( query );

   Select.AddParam("Autokey", RSDBP_IN, dpacc.rec.autokey );  

   Select.Execute();                                                               

   DataSet = TRsbDataSet(Select);

   while( DataSet.moveNext() )
     DataSet.GetRecord().CopyTo(acc.rec);
       if(GetFinalDate(DataSet.Account, DataSet.Code_Currency, DataSet.Chapter) > {curdate}) //проверяем поле "дата последней проводки" из анкеты лицевого счёта
         if( not (DataSet.depoacc == IDtmp))
           CodeDA1 = dpacc.rec.Code;
           NameDA1 = dpacc.rec.Name;
           CodeDep1 = ПолучитьКодСубъекта(dpacc.rec.Owner,1);
           NameDep1 = ПолучитьКороткоеИмяСубъекта( dpacc.rec.Owner);
           CodeDP1 = DataSet.Code ;
           Mes = "Для счета существуют проводки за более поздние даты. Счет не закрыт";
           PrintStr1(CodeDA1, NameDA1, NameDep1, CodeDep1, CodeDP1, Mes);
           IDtmp = DataSet.depoacc;
         end;
         count = count + 1;         
       end;
   end; 
  return count;  
end;
	
MACRO  CloseDPAccContr()

  var query, Select, DataSet, queryInv, queryGlob;
  var count = 0;
  var CntPrep = 0, CntOpen = 0;
  var dt;
  var closed;   //статус лицевого счета 
  var acc = TRecHandler("account");
  var dpacc = TRecHandler("depoacnt");
  var TestDate ;
  var mess = "", mesState = "";
  var stat = 0;
  var OpClose = TArray;   //массив открытых/закрытых разделов счета депо

  var  CodeDA = "", NameDA = "", NameDep = "", CodeDep = "" , OpenDateDA , CodeDP = "", OpenDateDP, Mes = "";


  if( (GetDialogFlag()) and (not IsShedulerRunning()) )

    GetRegistryValue("DEPO\\DAYS_FROM_NOTICE", V_INTEGER, N, err);
    if( err != 0 )
      msgbox("Ошибка поиска значения настройки \"Уведомление Депонентов о закрытии счетов депо с остатками\"");
      return;
    end;
  
  end;

  DP_StartUseTechAuto(TECHAUTODOC_CLOSEDPACC_CONTR);
  TestDate = {curdate} - N;  
  query = " SELECT acnt.* "
        + " FROM ddepoacnt_dbt acnt"
        + " WHERE acnt.t_autokey = acnt.t_root "             //корневой
        + " AND acnt.t_kind = 2 "                            //пассивные
        + " AND acnt.T_NOTICEDATE < " + GetSQLDate(TestDate) //дата фиксации счета депо на закрытие меньше (текущей + N )
        + " AND acnt.T_NOTICEDATE <> " + GetSQLDate(ZeroDate) //дата фиксации счета депо на закрытие не равня нулевой
        + " AND acnt.t_status <> 1 "                        // незакрытый
        + " ORDER BY acnt.t_autokey";
  
  
  count = SQL_GetNRecs(query);
  var queryStr  = " INSERT INTO ddepoacnt_tmp "
                + " ( t_DepoacntID, t_Root, t_BriefCode, t_Superior ) "    
                + " SELECT acnt.t_AutoKey, acnt.t_Root, acnt.t_BriefCode, acnt.t_Superior "
                + " FROM ddepoacnt_dbt acnt "
                + " WHERE acnt.t_autokey = acnt.t_root "             //корневой
                + " AND acnt.t_kind = 2 "                            //пассивные
                + " AND acnt.T_NOTICEDATE <= " + GetSQLDate(TestDate) //дата фиксации счета депо на закрытие меньше (текущей + N )      // меньше/равно??
                + " AND acnt.T_NOTICEDATE <> " + GetSQLDate(ZeroDate) //дата фиксации счета депо на закрытие не равня нулевой
                + " AND acnt.t_status <> 1 "                          //незакрытый
                + " ORDER BY acnt.t_autokey";

  SQL_Execute(queryStr);  
  queryInv = " select  "
           + "        (select count(1) from dspdraft_dbt draft, dspdrmove_dbt mv, dpmpaym_dbt pm, ddepoacnt_tmp acnt"
           + "          where draft.t_Status = 1"
           + "            and mv.t_DraftID = draft.T_AUTOKEY "
           + "            and pm.T_PaymentID = mv.t_PaymentID "
           + "            and (acnt.t_DEPOACNTID = pm.T_PAYERDPNODE or acnt.t_DEPOACNTID = pm.T_RECEIVERDPNODE )    "
           + "            and rownum = 1 "
           + "        ) as CntDraftPrep "
           + "       , (select count(1) from dspdraft_dbt draft, dspdrmove_dbt mv, dpmpaym_dbt pm, ddepoacnt_tmp acnt "
           + "          where draft.t_Status = 2"
           + "            and mv.t_DraftID = draft.T_AUTOKEY "
           + "            and pm.T_PaymentID = mv.t_PaymentID   "
           + "            and (acnt.t_DEPOACNTID = pm.T_PAYERDPNODE or acnt.t_DEPOACNTID = pm.T_RECEIVERDPNODE )    "
           + "            and rownum = 1 "
           + "        ) as CntDraftOpen"
           + "   from dual ";
  DataSet = TRsbDataSet(queryInv);
  if((DataSet.moveNext()) and ((DataSet.CntDraftPrep > 0) OR (DataSet.CntDraftOpen > 0) ))
    CntPrep  = DataSet.CntDraftPrep ;
    CntOpen  = DataSet.CntDraftOpen ;

    if((CntPrep > 0) and (CntOpen > 0))
      mesState = "отложенные и открытые";
    elif(CntPrep > 0)
      mesState = "отложенные";
    else
      mesState = "открытые";
    end;

    mess = "Найдены "+mesState +" инвентарные  операции, которые могут изменить остатки по лицевым счетам за "+string({curdate}:f)+". Запустить процедуру закрытия выбранных счетов депо (по поручению Депонентов)?";
    if(false == GetTrue(false, mess))
      return; 
    end;
  end;
  CntPrep = CntOpen = 0;

  queryGlob = " select  "
            + "        (select count(1) from ddpcorpop_dbt crp , ddpregstr_dbt str, ddpreglin_dbt lin, ddepoacnt_tmp  "
            + "          where crp.t_DocKind in ( "+DP_DEPOPER_CONVERT+", "+DP_DEPOPER_REPAY+", "+DP_DEPOPER_BONEMISS+" ) "
            + "            and crp.t_State = 1 "
            + "            and str.t_DOCUMENTID  = crp.t_DOCUMENTID  "
            + "            and str.t_REGISTERID = lin.t_REGISTERID "
            + "            and ddepoacnt_tmp.t_DEPOACNTID = lin.t_HOLDERACCID  "
            + "            and rownum = 1 "
            + "        ) as CntGlobPrep, "
            + "        (select count(1) from ddpcorpop_dbt crp , ddpregstr_dbt str, ddpreglin_dbt lin, ddepoacnt_tmp "
            + "          where crp.t_DocKind in ( "+DP_DEPOPER_CONVERT+", "+DP_DEPOPER_REPAY+", "+DP_DEPOPER_BONEMISS+" ) "
            + "            and crp.t_State = 2 "
            + "            and str.t_DOCUMENTID  = crp.t_DOCUMENTID  "
            + "            and str.t_REGISTERID = lin.t_REGISTERID "
            + "            and ddepoacnt_tmp.t_DEPOACNTID = lin.t_HOLDERACCID  "
            + "            and rownum = 1 "
            + "        ) as CntGlobOpen "
            + "   from dual ";
  DataSet = TRsbDataSet(queryGlob);
  if((DataSet.moveNext()) and ((DataSet.CntGlobPrep > 0) OR (DataSet.CntGlobOpen > 0) ))
    CntPrep  = DataSet.CntGlobPrep ;
    CntOpen  = DataSet.CntGlobOpen ;

    if((CntPrep > 0) and (CntOpen > 0))
      mesState = "отложенные и открытые";
    elif(CntPrep > 0)
      mesState = "отложенные";
    else
      mesState = "открытые";
    end;

    mess = "Найдены "+mesState +" глобальные операции, которые могут изменить остатки по лицевым счетам за "+string({curdate}:f)+". Запустить процедуру закрытия выбранных счетов депо (по поручению Депонентов)?";
    if(false == GetTrue(false, mess))
      return; 
    end;
  end;
  if( count > 0 )
    InitProgress ( count, "Идет обработка счетов депо...", "Процедура закрытия счетов депо");
    DataSet = TRsbDataSet(query);
    while( DataSet.moveNext() )
  
      OpClose.size = 0;
      closed = 0;   //статус лицевого счета 
      DataSet.GetRecord().CopyTo(dpacc.rec);
      CodeDA = dpacc.rec.Code;
      NameDA = dpacc.rec.Name;
      CodeDep = ПолучитьКодСубъекта(dpacc.rec.Owner,1);
      NameDep = GetPartyName(dpacc.rec.Owner, PTKN_FULLNAME);
      OpenDateDA = date_as_string(1,dpacc.rec.OpenDate,false);
      if( not CheckNullAcc (dpacc))
        if(CheckAdmoprForDepoAcc(dpacc))
          CountErr = CountErr +1;
        elif(GetFinalDateDEPO(dpacc))
          CountErr = CountErr +1;
        else
          FillOpClose(dpacc,@OpClose);
          stat = DP_CloseDpContrMas(dpacc.rec.autokey, true);    
          if(stat == 0)
            PrintRepRoot(dpacc,OpClose);
            CountMes = CountMes +1;
            OpClose.size = 0;
          elif(stat > 0)
            Mes = GetErrorMsg(stat);
            PrintStr1(CodeDA, NameDA, NameDep, CodeDep, CodeDP, Mes);
            CountErr = CountErr +1;
          end;
        end;
      end;
    end;
  end;
    //печать протокола
    if((CountMes+CountErr+CountErrNotNull))
      if(not CountErrNotNull)
        DP_AddPrintCell( RepHead, "Счета депо, имеющие ненулевые остатки, отсутствуют", 50, 0, "r:" + RepFontStyleTitel,_is_ap, REP_ELEM_STR );
        RepHead.AddStr();
      end;
      if(not CountMes)
        DP_AddPrintCell( RepHead, "Счета депо не закрывались", 0, 0, "r:" + RepFontStyleTitel,_is_ap, REP_ELEM_STR );
        RepHead.AddStr();
      end;
      RepHead.PrintRep();

      if(CountErrNotNull)
        [Перечень незакрытых  счетов депо,];
        [имеющих ненулевые остатки:];
        if( (CountErr == 0) and (CountMes == 0) )
          DP_StdFooter_Ex(Rep2, RepFontStyleTitel1, NULL, NULL, tablewidth1);              
        end;
        Rep2.PrintRep();
      end;

      if(CountErr)
        [Перечень незакрытых  счетов депо,];
        [имеющих нулевые остатки:];
        if(CountMes == 0)
          DP_StdFooter_Ex(Rep1, RepFontStyleTitel1, NULL, NULL, tablewidth1);              
        end;
        Rep1.PrintRep();
      end;

      if(CountMes)
        [Перечень закрытых счетов и разделов счета депо:];
        DP_StdFooter_Ex(Rep, RepFontStyleTitel, NULL, NULL, tablewidth);               
        Rep.PrintRep();
      end;
  
    else    //если нет никаких таблиц

      DP_AddPrintCell( RepHead, "Счета депо не закрывались", 0, 0, "r:"/* + RepFontStyleTitel*/,_is_ap, REP_ELEM_STR );
      RepHead.AddStr();
      DP_AddPrintCell( RepHead, "Счета депо, имеющие ненулевые остатки, отсутствуют", 100,0, "l:"/* + RepFontStyleTitel*/,_is_ap, REP_ELEM_STR );
      RepHead.AddStr();
      DP_StdFooter_Ex(RepHead, RepFontStyleTitel, NULL, NULL, tablewidth);               
      RepHead.PrintRep();

    end;
  

  SQL_Execute("DELETE FROM ddepoacnt_tmp");  
  DP_EndUseTechAuto();
 
END;

CloseDPAccContr()
