/*
   Макрос предназначен для обновления типов счетов ДЕПО  
   при переходе на очередную сборку.
*/

file dpac( "depoac.dbt" ) write;
file dpatvl( "depoatvl.dbt" ) key 6 write;
file dpacnt ("depoacnt.dbt")  ;
file curacc("account.dbt")  ;


file dpac_dst( "depoac.dbt" ) key 1;
file dpatvl_dst( "depoatvl.dbt" ) key 6;

const DEPOS_DPDPAC_MAXSYSNUM = 1000;

/* Управляющие переменные */
var WorkUpgrade = TRUE; /* Режим работы макроса - обновление (TRUE)/сканирование(FALSE) */
var DPACNumber = 0; /* Номер системного типа счета для сканирования, 0 - все системные счета */


macro BerrText( bftext )
  return bftext;
end;

macro InsDPAC()
  return string(dpac.ID);
end;

macro MyWontInsert( FilePtrName, AdditionalText, SecAdditionalText )
  if( WorkUpgrade )
    println("%WARNINGЗапись в файле "+FilePtrName+", "+AdditionalText+" НЕ ДОБАВЛЕНА (включая разделы), т.к. существует запись "+SecAdditionalText);
  else
    println("Запись в файле "+FilePtrName+", "+AdditionalText+" НЕ БУДЕТ ДОБАВЛЕНА (включая разделы), т.к. существует запись "+SecAdditionalText);
  end;
end;


macro MyInsert( FilePtr, FilePtrName, AdditionalText, UserCallBack )
  var stat = TRUE;
  var bftext;
  var AddStr="";

  if(WorkUpgrade)
    stat = Insert(FilePtr);
  end;

  if( Valtype(UserCallBack) != V_UNDEF )
    AddStr = ExecMacro2(UserCallBack);
  end;

  if( stat )
    if(WorkUpgrade)
      println("Добавлена запись в файл "+FilePtrName+", "+AdditionalText+AddStr);
    else
      println("Будет добавлена запись в файл "+FilePtrName+", "+AdditionalText+AddStr);
    end;
  else
    Status(bftext);
    println("Ошибка добавления записи в файл "+FilePtrName+", "+AdditionalText+AddStr+" ,"+BerrText( bftext ));
  end;

  return stat;
end;


macro MyWontUpdate( FilePtrName, AdditionalText, SecAdditionalText )
  if( WorkUpgrade )
    println("%WARNINGЗапись в файле "+FilePtrName+", "+AdditionalText+" НЕ ОБНОВЛЕНА (включая разделы), т.к. существует запись "+SecAdditionalText);
  else
    println("Запись в файле "+FilePtrName+", "+AdditionalText+" НЕ БУДЕТ ОБНОВЛЕНА (включая разделы), т.к. существует запись "+SecAdditionalText);
  end;
end;


macro MyUpdate( FilePtr, FilePtrName, AdditionalText )
  var stat = TRUE;
  var bftext;

  if(WorkUpgrade)
    stat = Update(FilePtr);
  end;

  if( stat )
    if(WorkUpgrade)
      println("Обновлена запись в файле "+FilePtrName+", "+AdditionalText);
    else
      println("Будет обновлена запись в файле "+FilePtrName+", "+AdditionalText);
    end;
  else
    Status(bftext);
    println("Ошибка обновления записи в файле "+FilePtrName+", "+AdditionalText+" ,"+BerrText( bftext ));
  end;

  return stat;
end;


macro MyDelete( FilePtr, FilePtrName, AdditionalText )
  var stat = TRUE;
  var bftext;

  if(WorkUpgrade)
    stat = Delete(FilePtr);
  end;

  if( stat )
    if(WorkUpgrade)
      println("Удалена запись в файле "+FilePtrName+", "+AdditionalText);
    else
      println("Будет удалена запись в файле "+FilePtrName+", "+AdditionalText);
    end;
  else
    Status(bftext);
    println("Ошибка удаления записи в файле "+FilePtrName+", "+AdditionalText+" ,"+BerrText( bftext ));
  end;

  return stat;
end;



var ContinueModifyDEPOAC;

macro ModifyDEPOAC( FilePtr, MacroFun, Root )
  var SaveKeyNumber;
  var SavePos;
  var stat = TRUE;
  var bstat;
  var bftext;
  var cycle = TRUE;
  
  SaveKeyNumber = KeyNum( FilePtr, 4 );
  SavePos = GetPos(FilePtr);

  if( SavePos )
    ContinueModifyDEPOAC = TRUE;
    FilePtr.Root = Root;
    stat = GetGE(FilePtr);
    while( (cycle) AND (stat) AND (ContinueModifyDEPOAC) )
      if( FilePtr.Root == Root )
        stat = ExecMacro2( MacroFun );
        if( (stat) AND (ContinueModifyDEPOAC) )
          stat = Next(FilePtr);
        end;
      else
        cycle = FALSE;
      end;
    end;
    if( not stat )
      bstat = Status(bftext);
      if((bstat) AND (bstat!=9) AND (bstat!=4))
        println( "Ошибка поиска записи в файле depoac.dbt\n"+BerrText( bftext ) );
        stat = FALSE;
      else
        stat = TRUE;
      end;
    end;
    if(stat)
      KeyNum( FilePtr, SaveKeyNumber );
      stat = GetDirect(FilePtr, SavePos);
      if(not stat )
        status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+FilePtr.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;
  
  return stat;
end;

var ContinueModifyDEPOACByTree;
var ModifyDEPOACByTreeEntrance = 0;

macro ModifyDEPOACByTree( FilePtr, MacroFun )
  var stat = TRUE; 
  var bstat;
  var bftext;
  var Level = FilePtr.ID;
  var bfstatus;
  var SavePos;
  var SaveKeyNumber;

  if( ModifyDEPOACByTreeEntrance == 0 )
    ContinueModifyDEPOACByTree = TRUE;
  end;
  ModifyDEPOACByTreeEntrance = ModifyDEPOACByTreeEntrance+1;
  
  SaveKeyNumber = KeyNum( FilePtr, 1 );
  SavePos = GetPos(FilePtr);
  if( SavePos == 0)
    status(bftext);
    println( "Ошибка сохранения позиции записи в файле depoac.dbt, ID =" + Level+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;

  dpac.Parent = Level;
  dpac.Number = 0;

  bstat = GetGE(FilePtr);
  while( (stat == TRUE) AND (bstat == TRUE) AND ( ContinueModifyDEPOACByTree ) )
    if( FilePtr.Parent == Level )
      stat = ModifyDEPOACByTree( FilePtr, MacroFun );
      if( (stat) AND (ContinueModifyDEPOACByTree) )
        bstat = Next(FilePtr);
      end;
    else
      bstat = FALSE;
    end;
  end;

  if( (stat) AND (bstat == FALSE))
    bfstatus = Status(bftext);
    if((bfstatus) AND (bfstatus!=9) AND (bfstatus!=4))
      println( "Ошибка поиска записи в файле depoac.dbt\n"+BerrText( bftext ) );
      stat = FALSE;
    end;
  end;

  if( stat )
    KeyNum( FilePtr, SaveKeyNumber );
    if( GetDirect( FilePtr, SavePos ) AND (ContinueModifyDEPOACByTree))
      stat = ExecMacro2( MacroFun );
    else
      status(bftext);
      println( "Ошибка поиска записи в файле depoac.dbt, RecPos =" + SavePos+"\n"+BerrText( bftext ) );
      stat = FALSE;
    end;
  end;
  
  ModifyDEPOACByTreeEntrance = ModifyDEPOACByTreeEntrance-1;

  return stat;
end;


macro FindDEPOACbyShortName( FilePtr, Parent, ShortName )
  var stat;
  var SaveKeyNumber;
  
  SaveKeyNumber = KeyNum( FilePtr, 2 );
  FilePtr.Parent = Parent;
  FilePtr.ShortName = ShortName;
  stat = GetEQ(FilePtr);
  KeyNum( FilePtr, SaveKeyNumber );
  return stat;
end;


macro FindDEPOAC( FilePtr, Parent, Number )
  var stat;
  var SaveKeyNumber;
  
  SaveKeyNumber = KeyNum( FilePtr, 1 );
  FilePtr.Parent = Parent;
  FilePtr.Number = Number;
  stat = GetEQ(FilePtr);
  KeyNum( FilePtr, SaveKeyNumber );
  return stat;
end;


macro FindDEPOACbyID( FilePtr, ID )
  var stat;
  var SaveKeyNumber;
  
  SaveKeyNumber = KeyNum( FilePtr, 0 );
  FilePtr.ID = ID;
  stat = GetEQ(FilePtr);
  KeyNum( FilePtr, SaveKeyNumber );
  return stat;
end;


/* Перенести все характеристики из дистрибутивного файла в пользовательский от 
типа счета/раздела IDdst для типа счета/раздела ID */
macro AddDEPOATVLToUser( ID, Parent, IDdst, IsType )
  var stat;
  var bstat;
  var bftext;
  var cycle = TRUE;
  
  dpatvl_dst.IsType = "X";
  dpatvl_dst.ID = IDdst;
  dpatvl_dst.AttrNum = 0;

  stat = GetGE(dpatvl_dst);
  while( (cycle) AND (stat) )
    if( (dpatvl_dst.IsType == "X") AND (dpatvl_dst.ID == IDdst) )
      Copy( dpatvl, dpatvl_dst );
      dpatvl.ID = ID;
      dpatvl.Parent = Parent;
      dpatvl.IsType = IsType;
      stat = MyInsert( dpatvl, "depoatvl.dbt", "ID="+string(ID)+" IsType=\""+string(IsType)+"\" AttrNum="+string(dpatvl.AttrNum) );
      if( stat )
        stat = Next(dpatvl_dst);
      end;
    else
      cycle = FALSE;
    end;
  end;
  if( not stat )
    bstat = Status();
    if((bstat) AND (bstat!=9) AND (bstat!=4))
      println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
      stat = FALSE;
    else
      stat = TRUE;
    end;
  end;
  
  return stat;
end;


macro FindIndexInArray( Arr, Total, number )
  var i = 0;
  while(i<Total)
    if( Arr(i) == number )
      return i;  
    end;
    i=i+1;
  end;
  return -1;
end;


macro FindDEPOATVL( FilePtr, IsType, ID, AttrNum )
  var stat;
  var SaveKeyNumber;
  
  SaveKeyNumber = KeyNum( FilePtr, 6 );
  FilePtr.IsType = IsType;
  FilePtr.ID = ID;
  FilePtr.AttrNum = AttrNum;
  stat = GetEQ(FilePtr);
  KeyNum( FilePtr, SaveKeyNumber );
  return stat;
end;

macro ResetIsMain( ID, IsCurrent, IsType )
  var stat;
  file depoatvl("depoatvl") key 1 write;

  depoatvl.IsMain    = "X";
  depoatvl.IsCurrent = IsCurrent;
  depoatvl.IsType    = IsType;
  depoatvl.ID        = ID;

  stat = GetEQ(depoatvl);
  if( stat )
    depoatvl.IsMain = "";
    stat = MyUpdate( depoatvl, "depoatvl.dbt", "ID="+string(ID)+" IsType=\""+string(IsType)+"\" AttrNum="+string(depoatvl.AttrNum) );
  else
    stat = true;
  end;

  return stat;
end;

macro UpdateDEPOATVL(ID, Parent, IDdst, IsType)
  var stat;
  var bstat;
  var bftext;
  var cycle = TRUE;
  var SaveID;
  var SaveParent;
  var SaveIsType;
  var SaveValue;
  var SaveIsMain;
  var TotalDpatvl;
  var i;
  array DpatvlNum, DpatvlDstExist;
  
  /* Просканируем все имеющиеся характеристики */
  dpatvl.IsType = IsType;
  dpatvl.ID = ID;
  dpatvl.AttrNum = 0;

  TotalDpatvl = 0;
  stat = GetGE(dpatvl);
  while( (cycle) AND (stat) )
    if( (dpatvl.IsType == IsType) AND (dpatvl.ID == ID) )
      DpatvlNum(TotalDpatvl) = dpatvl.AttrNum;
      DpatvlDstExist(TotalDpatvl) = FALSE; /* Первоначально флажки сбрасываем */
      TotalDpatvl = TotalDpatvl + 1;
      stat = Next(dpatvl);
    else
      cycle = FALSE;
    end;
  end;
  if( not stat )
    bstat = Status(bftext);
    if((bstat) AND (bstat!=9) AND (bstat!=4))
      println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
      stat = FALSE;
    else
      stat = TRUE;
    end;
  end;

  if(stat)
    /* Добавим/обновим из дистрибутива */
    dpatvl_dst.IsType = "X";
    dpatvl_dst.ID = IDdst;
    dpatvl_dst.AttrNum = 0;

    cycle = TRUE;
    stat = GetGE(dpatvl_dst);
    while( (cycle) AND (stat) )
      if( (dpatvl_dst.IsType == "X") AND (dpatvl_dst.ID == IDdst) )
        /* Не обрабатываем характеристики СЛЕДУЮЩЕГО уровня для СЧЕТОВ депо 
           Соответственно, в СЧЕТА новые хар-ки след. уровня не добавятся, а существующие
           не будут обновлены и отмечены в массиве DpatvlDstExist, в результате чего 
           они будут удалены ниже */
        if ( ( IsType == "X" ) OR
             ( ( IsType == "" ) AND ( dpatvl_dst.IsCurrent == "X" ) ) )
          stat = FindDEPOATVL( dpatvl, IsType, ID, dpatvl_dst.AttrNum );
          if( (stat == FALSE) AND (Status() == 4) ) /* Нет записи - добавим */
            Copy( dpatvl, dpatvl_dst );
            dpatvl.ID = ID;
            dpatvl.Parent = Parent;
            dpatvl.IsType = IsType;
            stat = MyInsert( dpatvl, "depoatvl.dbt", "ID="+string(ID)+" IsType=\""+string(IsType)+"\" AttrNum="+string(dpatvl.AttrNum) );
          elif( stat ) /* Обновим */
            SaveID = dpatvl.ID;
            SaveParent = dpatvl.Parent;
            SaveIsType = dpatvl.IsType;
            if( (SaveIsType != "X") AND (dpatvl_dst.ExpandByNodes == "X") )
              SaveValue = dpatvl.Value; 
            end;  
            SaveIsMain = dpatvl.IsMain;
            Copy( dpatvl, dpatvl_dst );
            dpatvl.ID = SaveID;
            dpatvl.Parent = SaveParent;
            dpatvl.IsType = SaveIsType;
            if( (SaveIsType != "X") AND (dpatvl_dst.ExpandByNodes == "X") )
              dpatvl.Value = SaveValue; 
            end; 
            if( (SaveIsMain != "X") AND (dpatvl.IsMain == "X") )
              stat = ResetIsMain( ID, dpatvl.IsCurrent, dpatvl.IsType );
            end;
            if( stat )
              stat = MyUpdate( dpatvl, "depoatvl.dbt", "ID="+string(ID)+" IsType=\""+string(IsType)+"\" AttrNum="+string(dpatvl.AttrNum) );
            end;
            if( stat )
              i = FindIndexInArray( DpatvlNum, TotalDpatvl, dpatvl_dst.AttrNum );
              if(i>=0)
                DpatvlDstExist(i) = TRUE;
              else
                stat = FALSE;
                println("(4)Не найден элемент массива TotalDpatvl");
              end;
            end;
          else
            Status(bftext);
            println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
          end;
        end;
        if( stat )
          stat = Next(dpatvl_dst);
        end;
      else
        cycle = FALSE;
      end;
    end;
    if( not stat )
      bstat = Status(bftext);
      if((bstat) AND (bstat!=9) AND (bstat!=4))
        println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
        stat = FALSE;
      else
        stat = TRUE;
      end;
    end;
  end;


  /* Удалим все характеристики, отсутствующие в дистрибутиве */
  i = 0;
  while( ( stat ) AND (i < TotalDpatvl))
    if( DpatvlDstExist(i) == FALSE )
      stat = FindDEPOATVL( dpatvl, IsType, ID, DpatvlNum(i) );
      if(stat)
        stat = MyDelete( dpatvl, "depoatvl.dbt", "ID="+string(ID)+" IsType=\""+string(IsType)+"\" AttrNum="+string(DpatvlNum(i)) );
      else
        Status(bftext);
        println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
      end;
    end;
    i = i + 1;
  end;
  
  return stat;
end;

macro UpdateDEPOATVLToUser( ID, Parent, IDdst )
  var stat;
  var SaveKeyNumber;
  var bstat;
  var bftext;
  var cycle = TRUE;


  stat = UpdateDEPOATVL( ID, Parent, IDdst, "X" );
  if(stat)
    /* Обновим/добавим характистики у счетов ДЕПО */  
    SaveKeyNumber = KeyNum( dpacnt, 6 );
    dpacnt.Type = ID;
    dpacnt.Owner = 0;
    stat = GetGE(dpacnt);
    while( (cycle) AND (stat) )
      if( dpacnt.Type == ID )
        stat = UpdateDEPOATVL(dpacnt.AutoKey, dpacnt.Superior, IDdst, "");
        if( stat )
          stat = Next(dpacnt);
        end;
      else
        cycle = FALSE;
      end;
    end;
    if( not stat )
      bstat = Status();
      if((bstat) AND (bstat!=9) AND (bstat!=4))
        println( "Ошибка поиска записи в файле depoacnt.dbt\n"+BerrText( bftext ) );
        stat = FALSE;
      else
        stat = TRUE;
      end;
    end;
    KeyNum( dpacnt, SaveKeyNumber );
  end;
  
  return stat;
end;

var NumTreeElems = 0;
array DstID, DstParent, NewID;

macro ScanDEPOACDST()
  DstID(NumTreeElems) = dpac_dst.ID;
  DstParent(NumTreeElems) = dpac_dst.Parent;
  NumTreeElems = NumTreeElems+1;
  return TRUE;
end;


macro FindNewParent( IDdst, Parent )
  var stat, i;

  i = FindIndexInArray(DstID, NumTreeElems, IDdst);

  if(i>=0)
    if( DstParent(i) == 0 )
      SetParm(1, 0);
      return TRUE;
    end;
    i = FindIndexInArray( DstID, NumTreeElems, DstParent(i) );
    if(i>=0)
      SetParm(1, NewID(i));
      return TRUE;
    else
      stat = FALSE;
      println("(2)Не найден элемент массива DstID");
    end;
  else
    stat = FALSE;
    println("(1)Не найден элемент массива DstID");
  end;
  return stat;
end;

var NewRoot;

/* Добавляет в пользовательский файл очередной тип счета/раздела */
macro AddDEPOACToUser()
  var stat;
  var bftext;
  var CurTreeElem;
  
  Copy(dpac, dpac_dst);
  dpac.ID = 0;
  if(dpac_dst.Parent != 0)
    dpac.Root = NewRoot;
  end;
  stat = FindNewParent(dpac_dst.ID, dpac.Parent);
  if( stat )
    stat = MyInsert( dpac, "depoac.dbt", "ID=", @InsDPAC );
    if(stat)
      if( dpac_dst.Parent == 0 ) /* Вставляем тип счета */
        dpac.Root = dpac.ID;
        dpac.Upgrade = "X";
        NewRoot = dpac.ID;
        stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID) );
      end;
      if( stat )
        CurTreeElem = FindIndexInArray( DstID, NumTreeElems, dpac_dst.ID );
        if(CurTreeElem>=0)
          NewID(CurTreeElem) = dpac.ID;
          stat = AddDEPOATVLToUser( dpac.ID, dpac.Parent, dpac_dst.ID, "X" );
        else
          stat = FALSE;
          println("(3)Не найден элемент массива DstID");
        end;
      end;
    end;
  end;
  
  return stat;
end;


/* Определяет есть ли в пользовательской базе тип счета с аналогичным 
   вставляемому/обновляемому дистрибутивному Коротким именем,
   При этом, естественно, не учитывается существование типа с дистрибутивным номером */
macro IsSuchShortNameCln( DstNumber, ShortName, IsSuchName, UsrID, UsrNumber )
  var stat;
  var bstat;
  var SaveKeyNumber;
  var SavePos;
  var bftext;


  SetParm( 2, FALSE );
  SetParm( 3, 0 );
  SetParm( 4, -1 );
  
  SaveKeyNumber = KeyNum( dpac );
  SavePos = GetPos(dpac);

  if( SavePos )
    stat = FindDEPOACbyShortName( dpac, 0, ShortName );
    if(stat == FALSE)
      bstat = Status();
      if(bstat ==4) /* Записи в пользовательском файле нет */
        stat = TRUE;
      else
        println("Ошибка поиска записи в файле dpac.dbt");
      end;
    else
      /* Запись в пользовательском файле нашли */
      if( dpac.Number != DstNumber ) /* Действительно есть, т.к. не нашего номера */
        SetParm( 2, TRUE );
        SetParm( 3, dpac.ID );
        SetParm( 4, dpac.Number );
      end;
    end;
    if(stat)   
      KeyNum( dpac, SaveKeyNumber );
      stat = GetDirect(dpac, SavePos);
      if(not stat )
        status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+dpac.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;
  
  return stat;
end;


macro AddDEPOAC( ID )
  var stat;
  var IsSuchName;
  var UsrID;
  var usrNumber;

  stat = IsSuchShortNameCln( dpac_dst.Number, dpac_dst.ShortName, IsSuchName, UsrID, UsrNumber );
  if( stat )
    if( IsSuchName )
      MyWontInsert( "depoac.dbt", "Parent ="+string(dpac_dst.Parent)+" Number ="+string(dpac_dst.Number)+" ShortName ="+dpac_dst.ShortName, 
                                  "ID="+string(UsrID)+" Parent ="+string(dpac_dst.Parent)+" Number ="+string(UsrNumber)+" ShortName ="+dpac_dst.ShortName );
      return stat;
    end;
    stat = ModifyDEPOAC( dpac_dst, @ScanDEPOACDST, ID );
    if( stat )
      stat = ModifyDEPOAC( dpac_dst, @AddDEPOACToUser, ID );
      /* Обнулим массивы */
      NumTreeElems = 0;
      Asize( DstID, NumTreeElems);
      Asize( DstParent, NumTreeElems);
      Asize( NewID, NumTreeElems);
    end;
  end;
  
  return stat;
end;

/* Проверка на существование хотя бы одного счета ДЕПО по заданному типу */
macro IsDEPOACNTExist( ID, result )
  var stat;
  var bstat;
  var bftext;
  var SaveKeyNumber;
  
  SaveKeyNumber = KeyNum( dpacnt, 6 );
  dpacnt.Type = ID;
  dpacnt.Owner = 0;
  stat = GetGE(dpacnt);
  KeyNum( dpacnt, SaveKeyNumber );
  if((stat) AND (dpacnt.Type == ID) )
    SetParm(1, TRUE);
    return TRUE;
  end;
  if(stat)
    SetParm(1, FALSE);
    return TRUE;
  end;
  bstat = Status(bftext);
  if((bstat) AND ((bstat==9) OR (bstat==4)))
    SetParm(1, FALSE);
    return TRUE;
  else
    println( "Ошибка поиска записи в файле depoacnt.dbt\n"+BerrText( bftext ) );
  end;
  
  return FALSE;
end;


macro FindAnyAcc( DepoAcc, result )
  var stat;
  var bstat;
  var bftext;
  var SaveKeyNumber;
  
  SaveKeyNumber = KeyNum( curacc, 3 );
  curacc.DepoAcc = DepoAcc;
  stat = GetGE(curacc);
  KeyNum( curacc, SaveKeyNumber );
  if((stat) AND (curacc.DepoAcc == DepoAcc) )
    SetParm(1, TRUE);
    return TRUE;
  end;
  if(stat)
    SetParm(1, FALSE);
    return TRUE;
  end;
  bstat = Status(bftext);
  if((bstat) AND ((bstat==9) OR (bstat==4)))
    SetParm(1, FALSE);
    return TRUE;
  else
    println( "Ошибка поиска записи в файле account.dbt\n"+BerrText( bftext ) );
  end;
  return FALSE;
end;

/* Проверка есть ли хотя бы один л/с на хотя бы одном счете ДЕПО по заданному типу */
macro TestDEPOACNT( ID, result )
  var stat;
  var bstat;
  var bftext;
  var SaveKeyNumber;
  var loc_result;
  var cycle = TRUE;
  
  SetParm(1, TRUE);
  
  SaveKeyNumber = KeyNum( dpacnt, 6 );
  dpacnt.Type = ID;
  dpacnt.Owner = 0;
  stat = GetGE(dpacnt);
  while( (cycle) AND (stat) )
    if( dpacnt.Type == ID )
      stat = FindAnyAcc( dpacnt.AutoKey, loc_result );
      if(stat)
        if(loc_result)
          SetParm(1, FALSE);
          stat = FALSE;
        end;
        if( stat )
          stat = Next(dpacnt);
        end;
      end;
    else
      cycle = FALSE;
    end;
  end;
  if( not stat )
    bstat = Status();
    if((bstat) AND (bstat!=9) AND (bstat!=4))
      println( "Ошибка поиска записи в файле depoacnt.dbt\n"+BerrText( bftext ) );
      stat = FALSE;
    else
      stat = TRUE;
    end;
  end;
  KeyNum( dpacnt, SaveKeyNumber );
  
  return stat;
end;


macro CheckDEPOATVLForUpdate( ID, IDdst, LocResult )
  var SaveKeyNumber;
  var stat;
  var bstat;
  var bftext;
  var cycle = TRUE;

  SetParm(2, TRUE);
  
  SaveKeyNumber = KeyNum( dpatvl_dst, 4 ); 
  dpatvl_dst.IsOwn = "X";
  dpatvl_dst.IsCurrent = "X";
  dpatvl_dst.IsType = "X";
  dpatvl_dst.ID = IDdst;
  
  stat = GetGE(dpatvl_dst);
  while( (cycle) AND (stat) )
    if( (dpatvl_dst.IsOwn == "X") AND
        (dpatvl_dst.IsCurrent == "X") AND
        (dpatvl_dst.IsType == "X") AND
        (dpatvl_dst.ID == IDdst) )
      if( dpatvl_dst.ExpandByNodes == "X" )
        stat = FindDEPOATVL( dpatvl, "X", ID, dpatvl_dst.AttrNum );
        if( stat == FALSE )
          if( Status() == 4 )
            SetParm(2, FALSE);
            KeyNum( dpatvl_dst, SaveKeyNumber ); 
            return TRUE;
          else
            Status(bftext);
            println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
          end;
        end;
        if( (stat) AND (dpatvl.ExpandByNodes != "X") )
          SetParm(2, FALSE);
          KeyNum( dpatvl_dst, SaveKeyNumber ); 
          return TRUE;
        end;
      end;
      if( stat )
        stat = Next(dpatvl_dst);
      end;
    else
      cycle = FALSE;
    end;
  end;
  if( not stat )
    bstat = Status();
    if((bstat) AND (bstat!=9) AND (bstat!=4))
      println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
      stat = FALSE;
    else
      stat = TRUE;
    end;
  end;

  KeyNum( dpatvl_dst, SaveKeyNumber ); 
end;


macro FindChild( FilePtr, Child )
  var SaveKeyNumber;
  var SavePos;
  var stat = TRUE;
  var bstat;
  var bftext;

  SetParm(1, FALSE);

  SaveKeyNumber = KeyNum( FilePtr, 1 );
  SavePos = GetPos(FilePtr);

  if( SavePos )
    FilePtr.Parent = FilePtr.ID;
    FilePtr.Number = 0;
    stat = GetGE(FilePtr);
    if(stat)
      if( FilePtr.Parent == FilePtr.ID )
        SetParm(1, TRUE);
      end;
    else
      bstat = status(bftext);
      if( (bstat==4) OR (bstat==9) )
        stat = TRUE;
      else
        println( "Ошибка поиска записи в файле depoac.dbt, ID ="+FilePtr.ID+"\n"+BerrText( bftext ) );
      end;
    end;
    if(stat)
      KeyNum( FilePtr, SaveKeyNumber );
      stat = GetDirect(FilePtr, SavePos);
      if(not stat )
        status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+FilePtr.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;
  
  return stat;
end;

macro FindDPACNodebyNode( NodeID, FindDstByUsr, NodeBuf, Children, ParentNodeBuf )
  var SaveKeyNumberUp;
  var SavePosUp;
  var SaveKeyNumberDn;
  var SavePosDn;
  var stat = TRUE;
  var bstat = 0;
  var bftext;
  var FileUp;
  var FileDn; 
  array NodePath;
  var NodeNum = 0;
  var CurNode;
  var ID;
  var ChildUp;
  var ChildDn;

  if( FindDstByUsr )
    FileUp = dpac;
    FileDn = dpac_dst;
  else
    FileUp = dpac_dst;
    FileDn = dpac;
  end;

  SaveKeyNumberUp = KeyNum( FileUp, 0 );
  SavePosUp = GetPos(FileUp);
  if( SavePosUp )
    SaveKeyNumberDn = KeyNum( FileDn, 1 );
    SavePosDn = GetPos(FileDn);
    if( SavePosDn )
      /* Поднимаемся по ветке вверх, записывая путь  */
      ID = NodeID;
      while( stat )
        stat = FindDEPOACbyID( FileUp, ID );
        if(stat)
          if( ID == NodeID )
            stat = FindChild( FileUp, ChildUp );
          end;
          if(stat)
            NodePath(NodeNum) = FileUp.Number;
            NodeNum = NodeNum+1;
            if( FileUp.Parent )
              ID = FileUp.Parent;
            else
              stat = FALSE;
            end;
          end;
        else
          bstat = Status(bftext);
          if((bstat == 4) OR (bstat == 9))
            bstat = 0;
          else
            println( "Ошибка поиска записи в файле depoac.dbt\n"+BerrText( bftext ) );
          end;
        end;
      end; /* end while */
      if( (not stat) AND bstat == 0 )
        stat = TRUE;
      end;
      /* Спускаемся по ветке вниз в другом файле */
      CurNode = NodeNum - 1;
      ID = 0;
      while( (stat) AND (CurNode >= 0) )
        stat = FindDEPOAC( FileDn, ID, NodePath(CurNode) );
        if( stat )
          if( CurNode == 0 )
            Copy( NodeBuf, FileDn );
            stat = FindChild( FileDn, ChildDn );
            if( not stat )
              bstat = 1;
            end;
            stat = FALSE;
          else
            ID = FileDn.ID;
            CurNode = CurNode - 1;
          end;
        else
          bstat = Status(bftext);
          if((bstat == 4) OR (bstat == 9))
            bstat = 0;
            ClearRecord( NodeBuf ); /* Не нашли аналогичную запись */
            if( ValType(FileDn) != V_UNDEF )
              Copy(ParentNodeBuf, FileDn);
            end;
          else
            println( "Ошибка поиска записи в файле depoac.dbt\n"+BerrText( bftext ) );
          end;
        end;
      end; /* end while */
      if( (not stat) AND bstat == 0 )
        stat = TRUE;
      end;
      if(stat)
        KeyNum( FileDn, SaveKeyNumberDn );
        stat = GetDirect(FileDn, SavePosDn);
        if(not stat )
          status(bftext);
          println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePosDn+"\n"+BerrText( bftext ) );
        end;
      end;
    else
      status(bftext);
      println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+FileDn.ID+"\n"+BerrText( bftext ) );
      stat = FALSE;
    end; /* if( SavePosDn ) */
    if(stat)
      KeyNum( FileUp, SaveKeyNumberUp );
      stat = GetDirect(FileUp, SavePosUp);
      if(not stat )
        status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePosUp+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+FileUp.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;

  if( (ChildUp == FALSE) AND (ChildDn == FALSE) )
    SetParm(3, 0);
  elif( (ChildUp == FALSE) AND (ChildDn == TRUE) )
    SetParm(3, 1);
  elif( (ChildUp == TRUE) AND (ChildDn == FALSE) )
    SetParm(3, 2);
  else
    SetParm(3, 3);
  end;
  
  return stat;
end;

var CheckDEPOACResult;

/* Проверка текущего (при обегании ветки) типа счета/раздела на возможность изменения */
macro CheckDEPOAC()
  var stat;
  var result;
  var children;
  RECORD dpbuf("depoac.dbt");

  /* Находим парный нашему узлу в дистриб. базе */
  stat = FindDPACNodebyNode( dpac.ID, 1, dpbuf, children );
  if(stat)
    stat = IsDEPOACNTExist( dpac.ID, result );
    if(stat)
      if(dpbuf.ID == 0) /* В новой базе такого узла нет */
        if(result) /* Есть счет депо */
          CheckDEPOACResult = FALSE;
          ContinueModifyDEPOAC = FALSE; /* Прерываем обход */
        end;
      else /* В новой базе такой узел есть */
        if(result) /* Есть счет депо */
          stat = CheckDEPOATVLForUpdate(dpac.ID, dpac_dst.ID, result);
          if(stat)
            if( not result)
              CheckDEPOACResult = FALSE;
              ContinueModifyDEPOAC = FALSE; /* Прерываем обход */
            else /* Если польз. узел крайний, а у дистрибутивного есть потомки */
              if(children == 1)
                stat = TestDEPOACNT( dpac.ID, result );
                if(stat)
                  if(not result)
                    CheckDEPOACResult = FALSE;
                    ContinueModifyDEPOAC = FALSE; /* Прерываем обход */
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  return stat;
end;


/* Проверить тип счета на возможность обновления */
macro CheckDEPOACForUpdate( result )
  var stat;
  var IsDPACNT;
  var LocResult;
  var IsSuchName;
  var UsrNumber;
  var UsrID;
  
  SetParm(0, TRUE);

  /* Если уже существует другой тип с аналогичным коротким именем */
  stat = IsSuchShortNameCln( dpac_dst.Number, dpac_dst.ShortName, IsSuchName, UsrID, UsrNumber );
  if( stat )
    if( IsSuchName )
      MyWontUpdate( "depoac.dbt", "ID="+string(dpac.ID)+" Parent = "+string(dpac.Parent)+" Number ="+string(dpac.Number)+" ShortName ="+dpac.ShortName, 
                                  "ID="+string(UsrID)+" Parent = "+string(dpac.Parent)+" Number ="+string(UsrNumber)+" ShortName ="+dpac_dst.ShortName );
      SetParm(0, FALSE); /* обновлять нельзя */
      return stat;
    end;
    /* Если есть хоть один счет */
    stat = IsDEPOACNTExist(dpac.ID, IsDPACNT );
    if(stat)
      if( IsDPACNT AND ( (dpac.Kind != dpac_dst.Kind) OR (dpac.Chapter != dpac_dst.Chapter) ) ) /* И у него не совпадает или глава или вид */
        SetParm(0, FALSE); /* обновлять нельзя */
        return stat;
      end;
      CheckDEPOACResult = TRUE;
      stat = ModifyDEPOAC( dpac, @CheckDEPOAC, dpac.ID );
      if(stat)
        if( CheckDEPOACResult == FALSE )
          SetParm(0, FALSE); /* тип менять нельзя - выходим */
          return stat;
        end;
      end;
    end;
  end;
  
  return stat;
end;


var UpdateRoot;

macro UpdateDEPOACWithTree()
  var SaveKeyNumber;
  var SavePos;
  var stat;
  var bstat;
  var bftext;
  var children;
  Record dpbuf("depoac.dbt");
  Record dpparent("depoac.dbt");
  
  SaveKeyNumber = KeyNum( dpac );
  SavePos = GetPos(dpac);
  if( SavePos )
    /* Находим парный нашему узлу в польз. базе */
    stat = FindDPACNodebyNode( dpac_dst.ID, 0, dpbuf, children, dpparent );
    if(stat)
      if( dpbuf.ID ) /* Узел существует */
        stat = FindDEPOACbyID(dpac, dpbuf.ID);
        if( stat )
          Copy( dpac, dpac_dst );
          dpac.ID = dpbuf.ID;
          dpac.Parent = dpbuf.Parent;
          dpac.Root = dpbuf.Root;
          stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID) );
          if(stat)
            stat = UpdateDEPOATVLToUser( dpac.ID, dpac.Parent, dpac_dst.ID );
          end;
        else
          bstat = Status(bftext);
          if((bstat == 4) OR (bstat == 9))
            bstat = 0;
          else
            println( "Ошибка поиска записи в файле depoac.dbt\n"+BerrText( bftext ) );
          end;
        end;
      else /* Узла нет - добавляем */
        Copy( dpac, dpac_dst );
        dpac.ID = 0;
        dpac.Parent = dpparent.ID;
        dpac.Root = UpdateRoot;
        stat = MyInsert( dpac, "depoac.dbt", "ID=", @InsDPAC );
        if(stat) /* Копируем характеристики этого узла */
          stat = AddDEPOATVLToUser( dpac.ID, dpac.Parent, dpac_dst.ID, "X" );
        end;
      end;
    end;
    if(stat)
      KeyNum( dpac, SaveKeyNumber );
      stat = GetDirect(dpac, SavePos);
      if(not stat )
        status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+dpac.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;
    
  return stat;
end;


/* Обновить польз. тип счета ДЕПО из дистрибутива
запись на польз. тип счета спозиционирована */
macro UpdateDEPOAC( IDdst )
  var stat;
  var result;
  
  if( dpac.DontUpdate == "X" ) /* Если пользователь запретил обновление - просто выходим */
    return TRUE;
  else
    stat = CheckDEPOACForUpdate( result );
    if((stat) AND (result))
      /* Можно обновлять */
      UpdateRoot = dpac.ID;
      stat = ModifyDEPOAC( dpac_dst, @UpdateDEPOACWithTree, dpac_dst.ID );
      if(stat)
        dpac.Upgrade = "X";
        stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID)+" поставлен признак \"Обновлен\"" );
      end;
    elif( (stat) AND (not result))
      /* Обновлять нельзя - поставим крестик */
      dpac.DontUpdate = "X";
      stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID)+" тип счета нельзя обновлять, поставлен признак \"Не обновлять при переходе на следующую сборку\"" );
    else
      return stat;
    end;
  end;
  return stat;
end;

macro AddOrChangeDPAC(Number)
  var stat;
  var bstat;
  var SaveKeyNumber;
  var SavePos;
  var bftext;
  var ID;
  
  SaveKeyNumber = KeyNum( dpac_dst );
  SavePos = GetPos(dpac_dst);

  if( SavePos )
    stat = FindDEPOAC( dpac, 0, Number );
    if(stat == FALSE)
      bstat = Status();
      if(bstat ==4) /* Записи в пользовательском файле нет - надо вставить весь тип счета */
        stat = AddDEPOAC( dpac_dst.ID );
      else
        println("Ошибка поиска записи в файле dpac.dbt");
      end;
    else
      /* Запись в пользовательском файле нашли - надо попытаться обновить */
      stat = UpdateDEPOAC( dpac_dst.ID );
    end;
    if(stat)   
      KeyNum( dpac_dst, SaveKeyNumber );
      stat = GetDirect(dpac_dst, SavePos);
      if(not stat )
        status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+dpac_dst.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;
  
  return stat;
end;


macro DeleteDEPOATVLToUser( ID )
  var stat;
  var bstat;
  var bftext;
  var cycle = TRUE;

  /* Удалим все предыдущие характеристики */
  dpatvl.IsType = "X";
  dpatvl.ID = ID;
  dpatvl.AttrNum = 0;

  stat = GetGE(dpatvl);
  while( (cycle) AND (stat) )
    if( (dpatvl.IsType == "X") AND (dpatvl.ID == ID) )
      stat = MyDelete( dpatvl, "depoatvl.dbt", "ID="+string(ID)+" IsType=\"X\" AttrNum="+string(dpatvl.AttrNum) );
      if(stat)
        stat = Next(dpatvl);
      end;
    else
      cycle = FALSE;
    end;
  end;
  if( not stat )
    bstat = Status();
    if((bstat) AND (bstat!=9) AND (bstat!=4))
      println( "Ошибка поиска записи в файле depoatvl.dbt\n"+BerrText( bftext ) );
      stat = FALSE;
    else
      stat = TRUE;
    end;
  end;
  
  return stat;
end;


macro DeleteSubtree()
  var stat;
  stat = DeleteDEPOATVLToUser(dpac.ID);
  if(stat)
    stat = MyDelete( dpac, "depoac.dbt", "ID="+string(dpac.ID) );
  end;
  return stat;
end;

macro SetRootUpdate()
  var stat;
  var bstat;
  var bftext;
  var Savepos;
  
  SavePos = GetPos(dpac);

  if( SavePos )
    stat = FindDEPOACbyID(dpac, dpac.Root);
    if(stat)
      dpac.Upgrade = "X";
      stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID)+" поставлен признак \"Обновлен\"" );
    else
      bstat = Status(bftext);
      if((bstat == 4) OR (bstat == 9))
        bstat = 0;
      else
        println( "Ошибка поиска записи в файле depoac.dbt\n"+BerrText( bftext ) );
      end;
    end;
    if(stat)
      stat = GetDirect(dpac, SavePos);
      if(not stat )
        Status(bftext);
        println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
      end;
    end;
  else
    Status(bftext);
    println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+dpac.ID+"\n"+BerrText( bftext ) );
    stat = FALSE;
  end;
  return stat;
end;

macro CheckDeleteSubtree()
  var stat;
  var children;
  Record dpbuf("depoac.dbt");

  /* Находим парный нашему узлу в дистриб. базе */
  stat = FindDPACNodebyNode( dpac.ID, 1, dpbuf, children );
  if(stat)
    if(dpbuf.ID == 0) /* Такого нет - удаляем */
      if( dpac.Parent != 0 ) /* Удаляем подветку, надо поставить крестик в корне */
        stat = SetRootUpdate();
      end;
      if(stat)
        stat = ModifyDEPOACByTree( dpac, @DeleteSubtree );
      end;
    end;
  end;
  return stat;
end;

macro RemoveDPAC(Number)
  var stat = TRUE;
  var result = TRUE;
  var bstat;
  var SaveKeyNumber;
  var SavePos;
  var bftext;
  var ID;

  if(WorkUpgrade == FALSE)
    stat = CheckDEPOACForUpdate( result );
  end;

  if( (stat) AND (dpac.DontUpdate != "X") AND (result))
  
    SaveKeyNumber = KeyNum( dpac );
    SavePos = GetPos( dpac );

    if( SavePos )
      stat = ModifyDEPOAC( dpac, @CheckDeleteSubtree, dpac.ID );
      if(stat)   
        KeyNum( dpac, SaveKeyNumber );
        stat = GetDirect(dpac, SavePos);
        if(not stat )
          status(bftext);
          println( "Ошибка восстановления позиции в файле depoac.dbt, SavePos ="+SavePos+"\n"+BerrText( bftext ) );
        end;
      end;
    else
      status(bftext);
      println( "Ошибка сохранения позиции в файле depoac.dbt, ID ="+dpac_dst.ID+"\n"+BerrText( bftext ) );
      stat = FALSE;
    end;
  end;
  return stat;
end;


macro ConvertDepoac()
  var stat = TRUE, bstat, bftext;

  if(WorkUpgrade)
    println( "Сконвертированы записи:\n" );
  else
    println( "Будут изменены записи:\n" );
  end;

  /* Снимаем признак Upgrade с типов счетов */
  if( stat )
    if( DPACNumber )
      if( (DPACNumber >0) AND (DPACNumber < DEPOS_DPDPAC_MAXSYSNUM) )
        bstat = FindDEPOAC(dpac, 0, DPACNumber );
        if(bstat)
          if( dpac.Upgrade == "X" )
            dpac.Upgrade = "";
            stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID)+" снят признак \"Обновлен\"" );
          end;
        else
          if(bstat == FALSE)
            bstat = Status();
            if( (bstat != 9) AND (bstat != 4) )
              status(bftext);
              println( "\nОшибка поиска записи\n"+BerrText( bftext ) );
              stat = FALSE;
            end;
          end;
        end;
      else
        println("\nНомер типа счета выходит за диапазон системных номеров!");
        stat = false;
      end;
    else
      KeyNum( dpac, 1 );
      rewind( dpac );
      while( (stat) AND (bstat = Next( dpac )) 
              AND (dpac.Parent == 0) 
              AND (dpac.Number < DEPOS_DPDPAC_MAXSYSNUM) ) /* Если это системный тип _счета_ депо */
        if( dpac.Upgrade == "X" )
          dpac.Upgrade = "";
          stat = MyUpdate( dpac, "depoac.dbt", "ID="+string(dpac.ID)+" снят признак \"Обновлен\"" );
        end;
      end;
      if(bstat == FALSE)
        bstat = Status();
        if( (bstat != 9) AND (bstat != 4) )
          status(bftext);
          println( "\nОшибка поиска записи\n"+BerrText( bftext ) );
          stat = FALSE;
        end;
      end;
    end;
  end;

  /* Добавляем и обновляем (если можно) старые типы счетов */
  if(stat)
    if( DPACNumber )
      bstat = FindDEPOAC(dpac_dst, 0, DPACNumber );
      if(bstat)
        stat = AddOrChangeDPAC(dpac_dst.Number);
      else
        if(bstat == FALSE)
          bstat = Status();
          if( (bstat != 9) AND (bstat != 4) )
            status(bftext);
            println( "\nОшибка поиска записи\n"+BerrText( bftext ) );
            stat = FALSE;
          end;
        end;
      end;
    else
      KeyNum( dpac_dst, 1 );
      rewind( dpac_dst );
      while( (stat) AND (bstat = Next( dpac_dst )) 
              AND (dpac_dst.Parent == 0) 
              AND (dpac_dst.Number < DEPOS_DPDPAC_MAXSYSNUM) ) /* Если это системный тип _счета_ депо */
        stat = AddOrChangeDPAC(dpac_dst.Number);
      end;

      if(bstat == FALSE)
        bstat = Status();
        if( (bstat != 9) AND (bstat != 4) )
          status(bftext);
          println( "\nОшибка поиска записи\n"+BerrText( bftext ) );
          stat = FALSE;
        end;
      end;
    end;
  end;


  /* Удаляем (если можно) старые типы счетов, не имеющие аналогов в новой базе */
  if( stat )
    if( DPACNumber )
      bstat = FindDEPOAC(dpac, 0, DPACNumber );
      if(bstat)
        stat = RemoveDPAC(dpac.Number);
      else
        if(bstat == FALSE)
          bstat = Status();
          if( (bstat != 9) AND (bstat != 4) )
            status(bftext);
            println( "\nОшибка поиска записи\n"+BerrText( bftext ) );
            stat = FALSE;
          end;
        end;
      end;
    else
      KeyNum( dpac, 1 );
      rewind( dpac );
      while( (stat) AND (bstat = Next( dpac )) 
              AND (dpac.Parent == 0) 
              AND (dpac.Number < DEPOS_DPDPAC_MAXSYSNUM) ) /* Если это системный тип _счета_ депо */
        stat = RemoveDPAC(dpac.Number);
      end;

      if(bstat == FALSE)
        bstat = Status();
        if( (bstat != 9) AND (bstat != 4) )
          status(bftext);
          println( "\nОшибка поиска записи\n"+BerrText( bftext ) );
          stat = FALSE;
        end;
      end;
    end;
  end;

  if( stat )
    if(WorkUpgrade)
      println( "\nКонвертирование произведено без ошибок" );
    else
      println( "\nСканирование произведено без ошибок" );
    end;
  else
    if(WorkUpgrade)
      println( "\nОшибки при конвертации" );
    else
      println( "\nОшибки при сканировании" );
    end;
  end;

  return stat;
end;


macro UpdateFiles( p_distDir, p_clnDir )
  var stat = FALSE;

  if( substr(p_clnDir, strlen(p_clnDir)) != "\\" )
    p_clnDir = p_clnDir + "\\";
  end;

  if( substr(p_distDir, strlen(p_distDir)) != "\\" )
    p_distDir = p_distDir + "\\";
  end;

  if( not open( dpac, p_clnDir + "depoac.dbt" ) )
    println( "Ошибка открытия файла " + p_clnDir + " depoac.dbt" );
    return false;
  end;

  if( not open( dpatvl, p_clnDir + "depoatvl.dbt" ) )
    println( "Ошибка открытия файла " + p_clnDir + " depoatvl.dbt" );
    return false;
  end;
  
  if( not open( dpacnt, p_clnDir + "depoacnt.dbt" ) )
    println( "Ошибка открытия файла " + p_clnDir + " depoacnt.dbt" );
    return false;
  end;

  if( not open( curacc, p_clnDir + "account.dbt" ) )
    println( "Ошибка открытия файла " + p_clnDir + " account.dbt" );
    return false;
  end;

  if( not open( dpac_dst, p_distDir + "depoac.dbt" ) )
    println( "Ошибка открытия файла " + p_distDir + " depoac.dbt" );
    return false;
  end;

  if( not open( dpatvl_dst, p_distDir + "depoatvl.dbt" ) )
    println( "Ошибка открытия файла " + p_distDir + " depoac.dbt" );
    return false;
  end;
  
  stat = ConvertDepoac();

  return stat;
end;

