/*
$Name:         dprests.mac
$Module:       Депозитарий
$Description:  Отчет "Планируемые остатки на аналитическом узле"
*/

import Globals, BankInter, OprInter, PaymInter, FIInter, DPInter, "cb_sql.mac", "deposerv.mac", "spserv.mac";

private const
  SIDEBALANCE_ACTIVE   = 1, /* активный */
  SIDEBALANCE_PASSIVE  = 2; /* пассивный */

/* Виды операций */
private const
  KINDOPER_NOTDEFINED = 0,
  KINDOPER_ENROLMENT  = 1, /* Зачисление */
  KINDOPER_WRITINGOFF = 2, /* Списание */
  KINDOPER_TRANSFER   = 3, /* Перевод */
  KINDOPER_MOVEMENT   = 4; /* Перемещение (смена места хранения) */

private const
  ALG_DEPO_WHATPAYMENTS  = 3238,
  SYS_ANL_AINPACCOUNTING = 2; /* Аналитика "Учет Актива в Пассиве" */

private const
  V_UNDEF = "не определен";

private var
  ColumnDate = TArray,
  vDateArray = TArray;

private var
  IsUnknownPaymHeaderPrinted = false,
  _SelfID = {OurBank};

private const
  FontStyleTitel =  "ex_FS(b)",
  FontStyleHead0 =  "ex_FS(b):ex_FZ(12)",
  FontStyleHead1 =  "ex_FS(b):ex_FZ(11)";

private var
  Rep;

private var TableWidth = 174;  /* Ширина таблицы недетализированных платежей */
var HeadTable0 = "┌───────────────────────────────────────────┬───────────────────────────────────────────┬───────────────────────────────────────────┬──────────────────────────┬──────────────────────┬";
var HeadTable1H= "│         Счет/раздел счета депонента       │           Раздел счета хранения           │          Счет депо места хранения         │                          │ Фактический остаток  │";
var HeadTable1L= "│         Счет/раздел счета хранения        │           Раздел счета депонента          │            Счет депо депонента            │                          │ Фактический остаток  │";
var HeadTable2 = "│                                           │                                           │                                           │   Выпуск ценых бумаг     │        (t+0)         │";
var HeadTable3 = "├────────────────────┬──────────────────────┼────────────────────┬──────────────────────┼────────────────────┬──────────────────────┤                          │                      ├";
var HeadTable4 = "│         Код        │     Наименование     │         Код        │     Наименование     │         Код        │     Наименование     │                          │                      │";
var HeadTable5 = "├────────────────────┴──────────────────────┴────────────────────┴──────────────────────┴────────────────────┴──────────────────────┴──────────────────────────┼──────────────────────┼";

private var
  HeaderTable = CHeader();

private const TableWidthUnkn = 174;  /* Ширина таблицы недетализированных платежей */
var HeadTableUnkn = "┌────────────────────────────────────────┬────────────────────────────────────────┬──────────────────────────┬──────────────────────────┬───────────────────┬──────────────────┐\n"+
                    "│Платеж                                  │Основание                               │Обобщенный выпуск ц/б     │Фактический выпуск ц/б    │Количество ц/б     │Дата валютирования│\n"+
                    "├────────────────────────────────────────┼────────────────────────────────────────┼──────────────────────────┼──────────────────────────┼───────────────────┼──────────────────┤\n"+
                    "│                   1                    │                   2                    │             3            │             4            │         5         │         6        │\n"+
                    "├────────────────────────────────────────┼────────────────────────────────────────┼──────────────────────────┼──────────────────────────┼───────────────────┼──────────────────┤";

/* Аналог оператора ?: в си. */
private macro IIF( condition, value_true, value_false )
   if( condition )
      return value_true;
   else
      return value_false;
   end;
end;

private macro __NameAlg(Type, Number)
  file NameAlg("NameAlg");

  NameAlg.iTypeAlg = Type;
  NameAlg.iNumberAlg = Number;
  if( GetEQ(NameAlg) )
    return NameAlg.szNameAlg;
  end;
  return " Не определен ";
end;

class CData
  var iNumDprt      : integer,
      iAccKind      : integer,
      iDeponent     : integer,
      iDepoAcc      : integer,
      iDepoPart     : integer,
      iFIGen        : integer,
      iFI           : integer,
      iDay          : integer,
      iWhatPayments : integer,
      iIsGenFIID    : bool,
      iShowDeponent : bool,
      iShowPaym     : bool,
      iToExcel      : bool,
      iIsApp        : bool;

  macro Init(_iNumDprt      : integer,
             _iAccKind      : integer,
             _iDeponent     : integer,
             _iDepoAcc      : integer,
             _iDepoPart     : integer,
             _iFIGen        : integer,
             _iFI           : integer,
             _iDay          : integer,
             _iWhatPayments : integer,
             _iIsGenFIID    : bool,
             _iShowDeponent : bool,
             _iShowPaym     : bool,
             _iToExcel      : bool,
             _iIsApp        : bool)

    iNumDprt      = _iNumDprt;
    iAccKind      = _iAccKind;
    iDeponent     = _iDeponent;
    iDepoAcc      = _iDepoAcc;
    iDepoPart     = _iDepoPart;
    iFIGen        = _iFIGen;
    iFI           = _iFI;
    iDay          = _iDay;
    iWhatPayments = _iWhatPayments;
    iIsGenFIID    = _iIsGenFIID;
    iShowDeponent = _iShowDeponent;
    iShowPaym     = _iShowPaym;
    iToExcel      = _iToExcel;
    iIsApp        = _iIsApp;
  end;
end;

private var
  Data = CData;

/*создание временной таблицы отчета*/
macro CreateTempTable()
  var sql;

  /* в случае изменения структуры таблиц, в апгрейдере необходимо добавить строчку удаления таблицы */
  /* данные в таблице хранятся в разрезе депонентов и места хранения, т.е. так, как нужно выводить в отчет */
  sql = "DECLARE \n"
      +  " v_err EXCEPTION; \n"
      +  " PRAGMA EXCEPTION_INIT( v_err, -955 );\n"
      + "BEGIN EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE ddp_plan_rests_tmp"
      + " ( t_HDepAcc  NUMBER(10), " /* счет депо депонента */
      +   " t_HDepPart NUMBER(10), " /* раздел счета депо депонента */
      +   " t_LDepAcc  NUMBER(10), " /* счет депо места хранения */
      +   " t_LDepPart NUMBER(10), " /* раздел счета депо места хранения */
      +   " t_HAccount VARCHAR2(25), " /* л/с депонента */
      +   " t_LAccount VARCHAR2(25), " /* л/с места хранения */
      +   " t_GenFIID NUMBER(10), " /* обобщенный выпуск */
      +   " t_FIID NUMBER(10), " /* ц/б */
      +   " t_Over NUMBER(32,12), " /* оборот на дату */
      +   " t_Date DATE, " /* дата */
      +   " t_DocKind NUMBER(10), " /* вид перв. документа (из платежа) */
      +   " t_DocID   NUMBER(10), " /* ИД перв. документа (из платежа) */
      +   " t_IsDetail CHAR(1) ) ON COMMIT PRESERVE ROWS';\n"  /* признак детализированности поручения */
      + "EXCEPTION WHEN v_err THEN NULL; \n"
      + "END; \n";
  SQL_Execute(sql,"Создание временной таблицы", false);

  sql = "DECLARE \n"
      +  " v_err EXCEPTION; \n"
      +  " PRAGMA EXCEPTION_INIT( v_err, -955 );\n"
      + "BEGIN\n"
      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx0 ON ddp_plan_rests_tmp"
      + " (t_HDepAcc)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx1 ON ddp_plan_rests_tmp"
      +  " (t_LDepAcc)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx2 ON ddp_plan_rests_tmp"
      +  " (t_HAccount)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx3 ON ddp_plan_rests_tmp"
      +  " (t_LAccount)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx4 ON ddp_plan_rests_tmp"
      +  " (t_GenFIID)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx5 ON ddp_plan_rests_tmp"
      +  " (t_FIID)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx6 ON ddp_plan_rests_tmp"
      +  " (t_Date)';\n"

      +  " EXECUTE IMMEDIATE 'CREATE INDEX ddp_plan_rests_tmp_idx7 ON ddp_plan_rests_tmp"
      +  " (t_DocKind, t_DocID)';\n"

      + "EXCEPTION WHEN v_err THEN NULL; \n"
      + "END; \n";
  SQL_Execute(sql,"Создание индексов временной таблицы", false);

  SQL_Execute("TRUNCATE TABLE ddp_plan_rests_tmp", "Очистка временной таблицы", false);
end;

/* вставить запись во временную таблицу */
macro AddRecTempTable( HDepPart, /* раздел счета депо депонента */
                       LDepPart, /* раздел счета депо места хранения */
                       HAcc,     /* л/с депонента */
                       LAcc,     /* л/с места хранения */
                       GenFIID,  /* обобщенный выпуск */
                       FIID,     /* фактический выпуск */
                       Over,     /* обороты счета на дату Date */
                       Date,     /* дата оборотов */
                       DocKind,
                       DocID,
                       IsDetail )
  var sql, HDepAcc, LDepAcc;

  macro GetDpRoot( DPID )
    var sql, rsd;

    sql = " SELECT t_Root "
        +   " FROM ddepoacnt_dbt "
        +  " WHERE t_AutoKey = " + DPID;
    rsd = TRsbDataSet(sql);
    if( rsd.MoveNext() )
      return rsd.Root;
    end;

    return 0;
  end;

  HDepAcc = GetDpRoot(HDepPart);
  LDepAcc  = GetDpRoot(LDepPart);

  sql = " INSERT INTO ddp_plan_rests_tmp  "
      + " ( t_HDepAcc, "
      +   " t_HDepPart, "
      +   " t_LDepAcc, "
      +   " t_LDepPart, "
      +   " t_HAccount, "
      +   " t_LAccount, "
      +   " t_GenFIID, "
      +   " t_FIID, "
      +   " t_Over, "
      +   " t_Date, "
      +   " t_DocKind, "
      +   " t_DocID, "
      + "   t_IsDetail )  VALUES ("
      + HDepAcc + ", "
      + HDepPart + ", "
      + LDepAcc + ", "
      + LDepPart + ", "
      + "'" + HAcc + "', "
      + "'" + LAcc + "', "
      + GenFIID + ", "
      + FIID + ", "
      + Over + ", "
      + GetSqlDate(Date) + ", "
      + DocKind + ", "
      + DocID + ", "
      + IIF(IsDetail, "'X'", "CHR(0)") + ") ";

  SQL_Execute(sql,"Заполнение временной таблицы отчета", false);
end;

private macro FindDEPOACNT( Autokey, Buff_DepoAcnt )
   file DepoAcnt( depoacnt );

   DepoAcnt.Autokey = Autokey;
   if( GetEQ(DepoAcnt) )
     Copy( Buff_DepoAcnt, DepoAcnt );
     return true;
   else
     return false;
   end;
end;

private macro FindDEPOACNTbyBriefCode( BriefCode, Department, Buff_DepoAcnt )
   file DepoAcnt( depoacnt ) key 2;

   DepoAcnt.BriefCode = BriefCode;
   DepoAcnt.Department = Department;
   if( GetEQ(DepoAcnt) )
     Copy( Buff_DepoAcnt, DepoAcnt );
     return true;
   else
     return false;
   end;
end;

/* получить ИД счета депо по его лицевику */
macro GetDPACbyACC( Account, FIID )
  var sql, rsd;

  sql = " SELECT t_DepoAcc "
      +   " FROM daccount_dbt "
      +  " WHERE t_Account = '" + Account + "'"
      +    " AND t_Chapter = " + 5 /*CHAPT5*/
      +    " AND t_Code_Currency = " + FIID;

  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    return rsd.DepoAcc;
  end;

  return 0;
end;

/* проверить, входит ли указанный счет в иерархию */
macro CheckDPACCByID( iDepoAcc, iDepoPart, CheckDPID )
  var sql, rsd;

  sql = " SELECT da.t_AutoKey "
      +   " FROM ddepoacnt_dbt da "
      +  " WHERE da.t_AutoKey = " + string(CheckDPID)
      + " START WITH da.t_AutoKey  = " + IIF(iDepoPart > 0, string(iDepoPart), string(iDepoAcc))
      + " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey";

  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    return true;
  end;

  return false;
end;

/* получить остаток по выпуску (если задан) или обобщенному и по всем подразделам*/
macro GetRest(vDate, GenFIID, FIID, HDepPart, HDepAcc)
  var sql, rsd;

  sql = " select nvl(sum(rsb_account.restac( a.t_Account, a.t_Code_Currency, " + GetSQLDate(vDate) + ", a.t_Chapter, null )),0) as Rest"
      +   " from daccount_dbt a"
      +  " where ( a.t_DepoAcc = " + string(HDepPart)
      +       " or a.t_DepoAcc IN ( SELECT da.t_AutoKey " /* а также все нижележищие */
      +                             " FROM ddepoacnt_dbt da "
      +                       " START WITH da.t_AutoKey  = " + string(HDepPart)
      +                       " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey )) "
      +    " and a.t_DepoRoot = " + string(HDepAcc);

  if( FIID > 0 )
    /*  если фактический выпуск известен, то берем все остатки по нему */
    sql = sql
        +    " and a.t_Code_Currency = " + string(FIID);
  elif( GenFIID > 0 )
    /* пытаем взять остатки по обобщеному выпуску, точнее по все фактическим данного обобщеннго */
    sql = sql
        +    " and a.t_Code_Currency IN ("
        +        " select f.t_fiid "
        +          " from dfininstr_dbt f "
        +         " where f.t_GeneralizedFIID = " + string(GenFIID) + ") ";

  else
    /*даже и не будем пытаться считать остатки*/
    return 0;
  end;

  rsd = TrsbDataSet(sql);
  if( rsd.MoveNext() )
    return rsd.Rest;
  end;

  return 0;
end;

/* определить кол-во столбцов с будущими датами */
macro GetFutureDateColumn()
  var sql, rsd;

  sql = "SELECT t_Date "
      +  " FROM ddp_plan_rests_tmp "
      + " WHERE t_IsDetail = 'X' "
      + " GROUP BY t_Date "
      + " ORDER BY t_Date ";
  rsd = TRsbDataSet(sql);
  while( rsd.MoveNext() )
    if( date(rsd.Date) <= ({curdate} + Data.iDay) )
      ColumnDate[ColumnDate.Size] = date(rsd.Date);
      vDateArray[vDateArray.Size] = 0;
    else
      break;
    end
  end;
end;

/* получить номер столбца по дате */
macro GetIndexDateColumn(vDate)
  var iCount = 0;

  while( iCount < ColumnDate.Size )
    if( ColumnDate[iCount] == vDate )
      return iCount;
    end;
    iCount = iCount + 1;
  end;

  /*если так и не нашли, значит искомая дата лежит за пределами массива*/
  return IIF(ColumnDate.Size > 0, ColumnDate.Size-1, 0);
end;

/* сформировать шапку основной таблицы */
macro FormMainHeader( iAccKind )
  var iCount = 0, HeadTable = "";
  var tDateStr = "", tNumDateStr = "", tiCountStr1 = "", tiCountStr2 = "8";

/* нужно добавить вот такую новую колонку
┬─────────────────────────────────────────────┬
│            Фактический остаток              │
│                    (t+0)                    │
┼──────────────────────┬──────────────────────┼
│        оборот        │        остаток       │
┼──────────────────────┼──────────────────────┼
│          9           │          10          │
┼──────────────────────┼──────────────────────┼
*/

  while( iCount < ColumnDate.Size )
    tDateStr = string(date(ColumnDate[iCount]));
    while( strlen(tDateStr) < 10 )
      tDateStr = tDateStr + " ";
    end;

    tNumDateStr = "(t + " + string((date(ColumnDate[iCount])-{curdate}):3) + ")";

    tiCountStr1 = string((int(tiCountStr2))+1:3);
    tiCountStr2 = string((int(tiCountStr1)+1):3);

    HeadTable0  = HeadTable0  + "─────────────────────────────────────────────" + IIF(iCount == (ColumnDate.Size+1),"┬", "┐");
    HeadTable1H = HeadTable1H + "                  " + tDateStr + "                 │";
    HeadTable1L = HeadTable1L + "                  " + tDateStr + "                 │";
    HeadTable2  = HeadTable2  + "                   " + tNumDateStr + "                 │";
    HeadTable3  = HeadTable3  + "──────────────────────┬──────────────────────" + IIF(iCount == (ColumnDate.Size+1),"┼", "┤");
    HeadTable4  = HeadTable4  + "        оборот        │        остаток       │";
    HeadTable5  = HeadTable5  + "──────────────────────┼──────────────────────" + IIF(iCount == (ColumnDate.Size+1),"┼", "┤");

    iCount = iCount + 1;
  end;

  TableWidth = strlen(HeadTable0)-1;

  HeadTable = HeadTable0 + "\n";
  if( iAccKind == SIDEBALANCE_PASSIVE )
    HeadTable = HeadTable + HeadTable1H + "\n";
  else
    HeadTable = HeadTable + HeadTable1L + "\n";
  end;
  HeadTable = HeadTable + HeadTable2 + "\n" + HeadTable3 + "\n" + HeadTable4 + "\n" + HeadTable5 + "\n";

  HeaderTable.ParcelHeader(HeadTable);

  HeadTable = HeaderTable.CreateHeader(NUMBER_LINE);

  return HeadTable;
end;

macro PrintTableHeader( iGenFIID, iFIID, iIsGenFIID, iDeponent, iShowDeponent, iKind )
  var AccCode1, AccCode2, FIName;
  var sql, rsd;
  var head;
  var HeadTable;
  var partyreg = TRecHandler("objrgdoc");
  record party("party");

  GetFutureDateColumn();

  HeadTable = FormMainHeader(iKind);

  sql = " SELECT da.t_BriefCode tCode "
      +   " FROM ddepoacnt_dbt da "
      +  " WHERE da.t_AutoKey = " + Data.iDepoAcc;
  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    AccCode1 = rsd.tCode;
  else
    AccCode1 = "";
  end;

  sql = " SELECT da.t_BriefCode tCode "
      +   " FROM ddepoacnt_dbt da "
      +  " WHERE da.t_AutoKey = " + Data.iDepoPart;
  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    AccCode2 = rsd.tCode;
  else
    AccCode2 = "";
  end;

  sql = " SELECT fin.t_FI_Code, fin.t_Name, avrk.t_ShortName avrkName "
      +   " FROM dfininstr_dbt fin, davrkinds_dbt avrk "
      +  " WHERE fin.t_FIID = " + IIF(iFIID > 0, iFIID, iGenFIID)
      +    " AND avrk.t_FI_Kind = 2 "
      +    " AND avrk.t_AvoirKind = fin.t_AvoirKind ";
  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    FIName = rsd.avrkName + " " + rsd.Name + " (" + rsd.FI_Code + ") " + IIF(iFIID <= 0, " - ОБОБЩЕННЫЙ", "");
  else
    FIName = "";
  end;

  head = "Ведомость о планируемых остатках";
  if( AccCode2 != "" )
    head = head + " на разделе " + AccCode2;
  end;
  head = head + " счета депо " + AccCode1;

  if ( ПолучитьСубъекта( iDeponent, party ) != 0 )
    ClearRecord(party);
  end;

  Rep = CMakeReport();

  DP_StdHeaderLO_Ex( Rep, FontStyleHead1, head, 0, 0, false, {curdate}, null, TableWidth );

  if( FIName != "" )
    DP_AddPrintCell( Rep,  "Отчет по выпуску "+FIName, TableWidth, 0, "l:" + FontStyleHead1, Data.iIsApp, REP_ELEM_STR );
    Rep.AddStr();
  end;

  DP_AddPrintCell( Rep,  "Обобщенные выпуски "+IIF(iIsGenFIID,"учитываются","не учитываются"), TableWidth, 0, "l:" + FontStyleHead1, Data.iIsApp, REP_ELEM_STR );
  Rep.AddStr();

  if( iShowDeponent and (party.PartyID > 0) )
    DP_AddPrintCell( Rep, "Владелец счета депо: " + GetPartyName(iDeponent) + " ИНН " + GetPartyINN(iDeponent), TableWidth, 0, "l:" + FontStyleHead1, Data.iIsApp, REP_ELEM_STR);
    Rep.AddStr();

    if( DP_GetRegistry( iDeponent, REGPT_TAXINSTITUTE, OBJKDOC_EVIDENCE_GOS_REG, partyreg ) )
      DP_AddPrintCell( Rep, "документ: " + "" + " серия " + partyreg.rec.Series + " №" + partyreg.rec.Number, TableWidth, 0, "l:" + FontStyleHead1, Data.iIsApp, REP_ELEM_STR);
      Rep.AddStr();
      DP_AddPrintCell( Rep, "выдан: " + DateToStr(partyreg.rec.StartDate, true) + " " + GetPartyName(partyreg.rec.RegPartyID), TableWidth, 0, "l:w:" + FontStyleHead1, Data.iIsApp, REP_ELEM_STR);
      Rep.AddStr();
    end;
  end;

  DP_AddPrintCell( Rep,  "Планируемые остатки с оборотами по "+__NameAlg(ALG_DEPO_WHATPAYMENTS, Data.iWhatPayments), TableWidth, 0, "l:" + FontStyleHead1, Data.iIsApp, REP_ELEM_STR );
  Rep.AddStr();

  Rep.AutoScan("[\n"+HeadTable+"]" );
end;

/* напечатать заголовок таблицы недетализированных платежей */
macro PrintUnknownPaymHeader()
  if( not IsUnknownPaymHeaderPrinted )
    Rep.AddStr();
    Rep.AddEmptyStr();
    DP_AddPrintCell( Rep, "Недетализированные платежи", 40, 0, "l", Data.iIsApp, REP_ELEM_STR);
    Rep.AutoScan("[\n"+HeadTableUnkn+"]" );

    IsUnknownPaymHeaderPrinted = true;
  end;
end;

macro PrintEmpty( str )
  if( str == "" )
    str = "-";
  elif( (str == 0) or (str == $0) or (str == 0.0) )
    str = "";
  end;

  return str;
end;

macro GetPoint( iFIID, iGenFIID )
  var sql, rsd;

  sql = " select t_SumPrecision "
          " from dfininstr_dbt "
         " where t_FIID = " + IIF(iFIID > 0, iFIID, iGenFIID);
  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
     return int(rsd.SumPrecision);
  end;

  return AVOIRISS_SUM_PRECISION;
end;

/* напечатать строку абсолютной позиции*/
macro PrintHeadLine(IsColorLine,  /*нужно ли раскрашивать строку*/
                    IsBold,       /*выводить строку жирным шрифтом*/
                    DepoPart,     /*раздел счета депо, относительно которого строим отчет*/
                    DepoCorrPart, /*раздел корреспондирующего счета депо*/
                    DepoCorrAcc,  /*корреспондирующий счет депо*/
                    GenFIID,
                    FIID )
  var iCount = 0;
  var sql, rsd;
  var DepoPartCode, DepoPartName,
      DepoCorrCode, DepoCorrName ,
      DepoCorrAcCode, DepoCorrAcName;
  var finname;

  macro GetCodeName( DPID, DepoPartCode, DepoPartName )
    var sql, rsd;

    sql = " SELECT ac.t_BriefCode, ty.t_ShortName "
        +   " FROM ddepoacnt_dbt ac, ddepoac_dbt ty "
        +  " WHERE ac.t_AutoKey = " + DPID
        +    " AND ty.t_ID = ac.t_Type ";
    rsd = TRsbDataSet(sql);
    if( rsd.MoveNext() )
      DepoPartCode = rsd.BriefCode;
      DepoPartName = rsd.ShortName;
    else
      DepoPartCode = "";
      DepoPartName = "";
    end;

    SetParm(1, DepoPartCode);
    SetParm(2, DepoPartName);
  end;

  GetCodeName( DepoPart, DepoPartCode, DepoPartName );
  GetCodeName( DepoCorrPart, DepoCorrCode, DepoCorrName );
  GetCodeName( DepoCorrAcc, DepoCorrAcCode, DepoCorrAcName );

  sql = " SELECT fin.t_FI_Code, fin.t_Name, avrk.t_ShortName avrkName "
      +   " FROM dfininstr_dbt fin, davrkinds_dbt avrk "
      +  " WHERE fin.t_FIID = " + IIF(FIID > 0, FIID, GenFIID)
      +    " AND avrk.t_FI_Kind = 2 "
      +    " AND avrk.t_AvoirKind = fin.t_AvoirKind ";
  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    finname = rsd.avrkName + " " + rsd.Name + " (" + rsd.FI_Code + ") " + IIF(FIID <= 0, " - ОБОБЩЕННЫЙ", "");
  else
    finname = "";
  end;

  DP_AddPrintCell( Rep, PrintEmpty(DepoPartCode), 20, 0, IIF(PrintEmpty(DepoPartCode)=="-", "c:ex_B(l)", "l:ex_B(l)")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","") );
  DP_AddPrintCell( Rep, PrintEmpty(DepoPartName), 22, 0, IIF(PrintEmpty(DepoPartName)=="-", "c:ex_B()","l:ex_B()")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","") );
  DP_AddPrintCell( Rep, PrintEmpty(DepoCorrCode), 20, 0, IIF(PrintEmpty(DepoCorrCode)=="-","c:ex_B()","l:ex_B()")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","") );
  DP_AddPrintCell( Rep, PrintEmpty(DepoCorrName), 22, 0, IIF(PrintEmpty(DepoCorrName)=="-","c:ex_B()","l:ex_B()")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","") );
  DP_AddPrintCell( Rep, PrintEmpty(DepoCorrAcCode), 20, 0, IIF(PrintEmpty(DepoCorrAcCode)=="-","c:ex_B()","l:ex_B()")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","") );
  DP_AddPrintCell( Rep, PrintEmpty(DepoCorrAcName), 22, 0, IIF(PrintEmpty(DepoCorrAcName)=="-","c:ex_B()","l:ex_B()")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","") );
  DP_AddPrintCell( Rep, PrintEmpty(finname), 26, 0, IIF(PrintEmpty(finname)=="-","c:ex_B(r)","l:ex_B(r)")+IIF(IsColorLine, ":ex_BC(12632256)", "") );

  while( iCount < vDateArray.Size )
    vDateArray[iCount] = 0;
    iCount = iCount + 1;
  end;
end;

/* получить название и основание платежа*/
macro GetPaymProps(DocKind, DocID, PaymName:@variant, PaymGround:@variant)
  var sql, rsd;
  var Oper = "";

  if( (DocKind == SP_DEPOPER_BOOKORDER /*SP_DEPOPER_UNIVOPERATION*/) or
      (DocKind == SP_DEPOPER_TRANSFERORDER) or
      (DocKind == SP_DEPOPER_ENROLMENT) or
      (DocKind == SP_DEPOPER_RECORDER) or
      (DocKind == SP_DEPOPER_WITHDRORDER) )
    PaymName = "ДЕПО: ";

    sql = " SELECT op.t_Name OperName, "
        +        " gr.t_Xld DraftNum, "
        +        " gr.t_RegistrDate DraftDate, "
        +        " NVL((SELECT llv.t_Name||' №'||ground.t_Xld||' от '||TO_CHAR(ground.t_RegistrDate,'DD.MM.YYYY')"
        +               " FROM dspgrdoc_dbt grdoc, "
        +                    " dspground_dbt ground, "
        +                    " dllvalues_dbt llv "
        +              " WHERE grdoc.t_SourceDocKind = dr.t_Kind "
        +                " AND grdoc.t_SourceDocID = dr.t_Autokey "
        +                " AND ground.t_SPGroundID = grdoc.t_SPGroundID "
        +                " AND llv.t_List = " + OBJTYPE_KINDDOC
        +                " AND llv.t_Element = ground.t_Kind "
        +                " AND ROWNUM = 1), CHR(1)) AddDoc "
        +   " FROM dspdraft_dbt dr, "
        +        " dspground_dbt gr, "
        +        " doprkoper_dbt op "
        +  " WHERE dr.t_AutoKey = " + string(DocID)
        +    " AND op.t_Kind_Operation = dr.t_Kind_Operation "
        +    " AND gr.t_SPGroundID = dr.t_SPGroundID ";

    rsd = TRsbDataSet(sql);
    if( rsd.MoveNext() )
      PaymName = PaymName +
             string(rsd.OperName) +
             " №" + string(rsd.DraftNum) +
             " от " + date(rsd.DraftDate);
      if( string(rsd.AddDoc) != "" )
        PaymGround = "основание: " + string(rsd.AddDoc);
      end;
    else
      PaymName = PaymName + string(DocID);
    end;
  elif( (DocKind == DL_SECURITYDOC) or
        (DocKind == DL_RETIREMENT) or
        (DocKind == DL_SETTLEMENT) or
        (DocKind == DL_AVRWRT) or
        (DocKind == DL_NTGSEC) )
    PaymName = "БОЦБ: ";

    sql = " SELECT Tick.t_DealCode, "
        +        " Tick.t_DealDate, "
        +        " Opr.t_Name OperName, "
        +        " NVL((SELECT llv.t_Name||' №'||ground.t_Xld||' от '||TO_CHAR(ground.t_RegistrDate,'DD.MM.YYYY')"
        +               " FROM dspgrdoc_dbt grdoc, "
        +                    " dspground_dbt ground, "
        +                    " dllvalues_dbt llv "
        +              " WHERE grdoc.t_SourceDocKind = tick.t_BOfficeKind "
        +                " AND grdoc.t_SourceDocID = tick.t_DealID "
        +                " AND ground.t_SPGroundID = grdoc.t_SPGroundID "
        +                " AND llv.t_List = " + OBJTYPE_KINDDOC
        +                " AND llv.t_Element = ground.t_Kind "
        +                " AND ROWNUM = 1), CHR(1)) AddDoc "
        +   " FROM ddl_tick_dbt Tick, "
        +        " (SELECT t_Name, t_Kind_Operation, t_DocKind, rsb_secur.get_OperationGroup(t_SysTypes) oGrp "
        +           " FROM doprkoper_dbt) Opr "
        +  " WHERE Tick.t_DealID = " + string(DocID)
        +    " AND Tick.t_BOfficeKind = " + string(DocKind)
        +    " AND Opr.t_Kind_Operation = Tick.t_DealType "
        +    " AND Opr.t_DocKind = Tick.t_BOfficeKind ";

    rsd = TRsbDataSet(sql);
    if( rsd.MoveNext() )
      PaymName = PaymName +
             string(rsd.OperName) +
             " №" + string(rsd.DealCode) +
             " от " + date(rsd.DealDate);
      if( string(rsd.AddDoc) != "" )
        PaymGround = "основание: " + string(rsd.AddDoc);
      end;
    else
      PaymName = PaymName + string(DocID);
    end;
  else
    PaymName = "Операция ИД = " + string(DocID);
  end;

end;

/* напечатать строку детализированной операции*/
macro PrintOperLine(IsColorLine, vRsd)
  var iCount = 0;
  var sql, rsd;
  var Oper = "", PaymName = "", PaymGround = "";

  GetPaymProps( int(vRsd.DocKind), int(vRsd.DocID), @PaymName, @PaymGround);

  Oper = PaymName;
  if( PaymGround != "" )
    Oper = Oper
         + ", " + PaymGround;
  end;

  DP_AddPrintCell( Rep, Oper, 20+
                         22+
                         20+
                         22+
                         20+
                         22+
                         26+6, 0, "l:ex_B(lr)"+IIF(IsColorLine, ":ex_BC(12632256)", ""));

  while( iCount < vDateArray.Size )
    vDateArray[iCount] = 0;
    iCount = iCount + 1;
  end;
end;

/* заполнить массив с оборотами на дату */
macro PrepareLineRest( vDate, Over )
  vDateArray[GetIndexDateColumn(vDate)] = Over;
end;

/* Напечатать строку с остатками и оборотами*/
macro PrintRestOverLine( iFIID, iGenFIID, IsColorLine, IsBold, currRest, IsCalc, isFirst )
  var Rest = currRest, iCount = 0;
  var Point = GetPoint(iFIID, iGenFIID);

  DP_AddPrintCell( Rep, PrintEmpty(Rest), 22, DP_GetPrecision(Rest, Point), "r"+IIF(IsFirst,"ex_B(rlb)" , "")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","")+IIF(Data.iIsApp,":a","") );

  while( iCount < vDateArray.Size )
    if( IsCalc )
      Rest = Rest + vDateArray[iCount];
    else
      Rest = 0;
    end;
    DP_AddPrintCell( Rep, PrintEmpty(vDateArray[iCount]), 22, 0, "r"+IIF(IsFirst,"ex_B(rlb)" , "")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","")+IIF(Data.iIsApp,":a","") );
    DP_AddPrintCell( Rep, PrintEmpty(Rest), 22, DP_GetPrecision(Rest, Point), "r"+IIF(IsFirst,"ex_B(rlb)" , "")+IIF(IsColorLine, ":ex_BC(12632256)", "")+IIF(IsBold,":ex_FS(b)","")+IIF(Data.iIsApp,":a","") );
    iCount = iCount + 1;
  end;

  Rep.AddStr();
end;

/* Посчитать остатки и обороты по всем датам*/
macro CalcOverLine( vRsd, iAccKind )
  var sql, rsd;

  sql = " SELECT SUM(r.t_Over) t_Over, r.t_Date "
      +   " FROM ddp_plan_rests_tmp r "
      +  " WHERE r.t_GenFIID = " + string(vRsd.GenFIID);

  if( int(vRsd.FIID) > 0 )
    /*если задан факт. выпуск, то выбираем по нему, иначе берем все*/
    sql = sql
        + " AND r.t_FIID = " + string(vRsd.FIID);
  end;

  if( iAccKind == SIDEBALANCE_PASSIVE )
    sql = sql
        + " AND r.t_HDepAcc = " + string(vRsd.HDepAcc)
        + " AND ( r.t_HDepPart = " + string(vRsd.HDepPart) /* по всем данным и нижележащим подразделам */
        + "   OR  r.t_HDepPart IN ( SELECT da.t_AutoKey "
        +                           " FROM ddepoacnt_dbt da "
        +                     " START WITH da.t_AutoKey  = " + string(vRsd.HDepPart)
        +                     " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey )) ";

    if( int(vRsd.LDepAcc) > 0 )
      /*если указан счет корреспонденции, то берем по нему, иначе выбираем все*/
      sql = sql
          + " AND r.t_LDepAcc = " + string(vRsd.LDepAcc);
      if( int(vRsd.LDepPart) > 0 )
        /*если указан раздел счета корреспонденции, то берем по нему и всем нижележащим, иначе выбираем все*/
        sql = sql
            + " AND ( r.t_LDepPart = " + string(vRsd.LDepPart)
            +    " OR r.t_LDepPart IN ( SELECT da.t_AutoKey "
            +                           " FROM ddepoacnt_dbt da "
            +                     " START WITH da.t_AutoKey  = " + string(vRsd.LDepPart)
            +                     " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey )) ";
      end;
    end;
  else
    sql = sql
        + " AND r.t_LDepAcc = " + string(vRsd.LDepAcc)
        + " AND ( r.t_LDepPart = " + string(vRsd.LDepPart) /* по всем данным и нижележащим подразделам */
        + "   OR  r.t_LDepPart IN ( SELECT da.t_AutoKey "
        +                           " FROM ddepoacnt_dbt da "
        +                     " START WITH da.t_AutoKey  = " + string(vRsd.LDepPart)
        +                     " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey )) ";

    if( int(vRsd.HDepAcc) > 0 )
      /*если указан счет корреспонденции, то берем по нему, иначе выбираем все*/
      sql = sql
          + " AND r.t_HDepAcc = " + string(vRsd.HDepAcc);
      if( int(vRsd.HDepPart) > 0 )
        /*если указан раздел счета корреспонденции, то берем по нему и всем нижележащим, иначе выбираем все*/
        sql = sql
            + " AND ( r.t_HDepPart = " + string(vRsd.HDepPart)
            +    " OR r.t_HDepPart IN ( SELECT da.t_AutoKey "
            +                           " FROM ddepoacnt_dbt da "
            +                     " START WITH da.t_AutoKey  = " + string(vRsd.HDepPart)
            +                     " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey )) ";
      end;
    end;
  end;

  sql = sql
      + " GROUP BY r.t_Date "
      + " ORDER BY r.t_Date ";

  rsd = TRsbDataSet(sql);
  while( rsd.MoveNext() )
    PrepareLineRest(date(rsd.Date), rsd.Over);
  end;
end;

/* напечатать строку недетализированных платежей */
macro PrintUnkPaymLine( vRsd , isFirst)
  var PaymName = "", PaymGround = "", Format, Point = AVOIRISS_SUM_PRECISION;

  macro GetFinName( FIID )
    var sql, rsd;

    sql = " SELECT fin.t_FI_Code, fin.t_Name, avrk.t_ShortName avrkName "
        +   " FROM dfininstr_dbt fin, davrkinds_dbt avrk "
        +  " WHERE fin.t_FIID = " + FIID
        +    " AND avrk.t_FI_Kind = 2 "
        +    " AND avrk.t_AvoirKind = fin.t_AvoirKind ";
    rsd = TRsbDataSet(sql);
    if( rsd.MoveNext() )
      return string(rsd.avrkName) + " " + string(rsd.Name) + " (" + string(rsd.FI_Code) + ") ";
    end;

    return "";
  end;
  if(isFirst)
    Format ="ex_B(rlb)";
  else
    Format ="";
  end;

  GetPaymProps( int(vRsd.DocKind), int(vRsd.DocID), @PaymName, @PaymGround);

  Point = GetPoint(int(vRsd.FIID), int(vRsd.GenFIID));

  DP_AddPrintCell( Rep, PrintEmpty(PaymName), 40, 0, "l" + Format);
  DP_AddPrintCell( Rep, PrintEmpty(PaymGround), 40, 0, "l" + Format);
  DP_AddPrintCell( Rep, PrintEmpty(GetFinName(int(vRsd.GenFIID))), 26, 0, "l" + Format);
  DP_AddPrintCell( Rep, PrintEmpty(GetFinName(int(vRsd.FIID))), 26, 0, "l" + Format);
  DP_AddPrintCell( Rep, PrintEmpty(vRsd.Over), 19, DP_GetPrecision(vRsd.Over, Point), "r"+IIF(Data.iIsApp,":a","") + Format);
  DP_AddPrintCell( Rep, date(vRsd.Date), 18, 0, "l");

  Rep.AddStr();
end;

macro PrintReport( iGenFIID, iFIID, iIsGenFIID, iDeponent, iShowDeponent, iShowPaym, iAccKind )
  var sql_dpacc, sql_genf, sql_fins, sql_dpac2, sql_line,
      rsd_dpacc, rsd_genf, rsd_fins, rsd_dpac2, rsd_line;
  var sql, rsd;

  var progress = CProgressBar;
  var IsColorLine = false, IsBold = false;
  var currDepAcc = -2,  /* счет, относительно которго строим отчет*/
      currDepPart = -2, /* раздел счета, относительно которго строим отчет*/
      currDepAcc1 = -2, /* корреспондирующий счет */
      currDepPart1 = -2,/* корреспондирующий раздел */
      currGenFIID = -2,
      currFIID = -2,
      prevDepAcc = 0,
      prevDepPart = 0,
      prevDepAcc1 = 0,
      prevDepPart1 = 0,
      prevGenFIID = 0,
      prevFIID = -1,
      isFirst;

  PrintTableHeader(iGenFIID, iFIID, iIsGenFIID, iDeponent, iShowDeponent, iAccKind);
  isFirst = true;

  /* Детализированные платежи */
  /* Группируем по счетам/разделам счета */
  if( iAccKind == SIDEBALANCE_PASSIVE )
    sql_dpacc = " SELECT r.t_HDepAcc as DepAcc, "
              +        " r.t_HDepPart as DepPart "
              +   " FROM ddp_plan_rests_tmp r "
              +  " WHERE r.t_IsDetail = 'X' "
              + " GROUP BY r.t_HDepAcc, "
              +          " r.t_HDepPart "
              + " ORDER BY r.t_HDepAcc, "
              +          " r.t_HDepPart ";
  else
    sql_dpacc = " SELECT r.t_LDepAcc as DepAcc, "
              +        " r.t_LDepPart as DepPart "
              +   " FROM ddp_plan_rests_tmp r "
              +  " WHERE r.t_IsDetail = 'X' "
              + " GROUP BY r.t_LDepAcc, "
              +          " r.t_LDepPart "
              + " ORDER BY r.t_LDepAcc, "
              +          " r.t_LDepPart ";
  end;

  rsd_dpacc = TRsbDataSet(sql_dpacc);
  progress.Init( -1, "Печать отчета" );

  while( rsd_dpacc.MoveNext() )

    /*группируем по обобщенным выпускам*/
    if( iAccKind == SIDEBALANCE_PASSIVE )
      sql_genf = " SELECT r.t_GenFIID "
                +   " FROM ddp_plan_rests_tmp r "
                +  " WHERE r.t_IsDetail = 'X' "
                +    " AND r.t_HDepAcc = " + string(rsd_dpacc.DepAcc)
                +    " AND r.t_HDepPart = " + string(rsd_dpacc.DepPart)
                + " GROUP BY r.t_GenFIID "
                + " ORDER BY r.t_GenFIID ";
    else
      sql_genf = " SELECT r.t_GenFIID "
                +   " FROM ddp_plan_rests_tmp r "
                +  " WHERE r.t_IsDetail = 'X' "
                +    " AND r.t_LDepAcc = " + string(rsd_dpacc.DepAcc)
                +    " AND r.t_LDepPart = " + string(rsd_dpacc.DepPart)
                + " GROUP BY r.t_GenFIID "
                + " ORDER BY r.t_GenFIID ";
    end;

    rsd_genf = TRsbDataSet(sql_genf);
    while( rsd_genf.MoveNext() )
      /*группируем по выпускам*/
      if( iAccKind == SIDEBALANCE_PASSIVE )
        sql_fins = " SELECT r.t_FIID "
                  +   " FROM ddp_plan_rests_tmp r "
                  +  " WHERE r.t_IsDetail = 'X' "
                  +    " AND r.t_HDepAcc = " + string(rsd_dpacc.DepAcc)
                  +    " AND r.t_HDepPart = " + string(rsd_dpacc.DepPart)
                  +    " AND r.t_GenFIID = " + string(rsd_genf.GenFIID)
                  + " GROUP BY r.t_FIID "
                  + " ORDER BY r.t_FIID ";
      else
        sql_fins = " SELECT r.t_FIID "
                  +   " FROM ddp_plan_rests_tmp r "
                  +  " WHERE r.t_IsDetail = 'X' "
                  +    " AND r.t_LDepAcc = " + string(rsd_dpacc.DepAcc)
                  +    " AND r.t_LDepPart = " + string(rsd_dpacc.DepPart)
                  +    " AND r.t_GenFIID = " + string(rsd_genf.GenFIID)
                  + " GROUP BY r.t_FIID "
                  + " ORDER BY r.t_FIID ";
      end;

      rsd_fins = TRsbDataSet(sql_fins);
      while( rsd_fins.MoveNext() )
        /*группируем по корреспондирующим счетам/разделам*/
        if( iAccKind == SIDEBALANCE_PASSIVE )
          sql_dpac2 = " SELECT r.t_LDepAcc as DepAcc1, "
                    +        " r.t_LDepPart as DepPart1 "
                    +   " FROM ddp_plan_rests_tmp r "
                    +  " WHERE r.t_IsDetail = 'X' "
                    +    " AND r.t_HDepAcc = " + string(rsd_dpacc.DepAcc)
                    +    " AND r.t_HDepPart = " + string(rsd_dpacc.DepPart)
                    +    " AND r.t_GenFIID = " + string(rsd_genf.GenFIID)
                    +    " AND r.t_FIID = " + string(rsd_fins.FIID)
                    + " GROUP BY r.t_LDepAcc, "
                    +          " r.t_LDepPart "
                    + " ORDER BY r.t_LDepAcc, "
                    +          " r.t_LDepPart ";

        else
          sql_dpac2 = " SELECT r.t_HDepAcc as DepAcc1, "
                    +        " r.t_HDepPart as DepPart1 "
                    +   " FROM ddp_plan_rests_tmp r "
                    +  " WHERE r.t_IsDetail = 'X' "
                    +    " AND r.t_LDepAcc = " + string(rsd_dpacc.DepAcc)
                    +    " AND r.t_LDepPart = " + string(rsd_dpacc.DepPart)
                    +    " AND r.t_GenFIID = " + string(rsd_genf.GenFIID)
                    +    " AND r.t_FIID = " + string(rsd_fins.FIID)
                    + " GROUP BY r.t_HDepAcc, "
                    +          " r.t_HDepPart "
                    + " ORDER BY r.t_HDepAcc, "
                    +          " r.t_HDepPart ";
        end;

        rsd_dpac2 = TRsbDataSet(sql_dpac2);
        while( rsd_dpac2.MoveNext() )
          /* печатаем строчку отчета */
          if( iAccKind == SIDEBALANCE_PASSIVE )
            sql_line = " SELECT r.* "
                      +   " FROM ddp_plan_rests_tmp r "
                      +  " WHERE r.t_IsDetail = 'X' "
                      +    " AND r.t_HDepAcc = " + string(rsd_dpacc.DepAcc)
                      +    " AND r.t_HDepPart = " + string(rsd_dpacc.DepPart)
                      +    " AND r.t_GenFIID = " + string(rsd_genf.GenFIID)
                      +    " AND r.t_FIID = " + string(rsd_fins.FIID)
                      +    " AND r.t_LDepAcc = " + string(rsd_dpac2.DepAcc1)
                      +    " AND r.t_LDepPart = " + string(rsd_dpac2.DepPart1)
                      + " ORDER BY r.t_Date ";

          else
            sql_line = " SELECT r.* "
                      +   " FROM ddp_plan_rests_tmp r "
                      +  " WHERE r.t_IsDetail = 'X' "
                      +    " AND r.t_LDepAcc = " + string(rsd_dpacc.DepAcc)
                      +    " AND r.t_LDepPart = " + string(rsd_dpacc.DepPart)
                      +    " AND r.t_GenFIID = " + string(rsd_genf.GenFIID)
                      +    " AND r.t_FIID = " + string(rsd_fins.FIID)
                      +    " AND r.t_HDepAcc = " + string(rsd_dpac2.DepAcc1)
                      +    " AND r.t_HDepPart = " + string(rsd_dpac2.DepPart1)
                      + " ORDER BY r.t_Date ";
          end;

          rsd_line = TRsbDataSet(sql_line);
          while( rsd_line.MoveNext() )

            currDepAcc   = IIF(iAccKind == SIDEBALANCE_PASSIVE, int(rsd_line.HDepAcc),  int(rsd_line.LDepAcc));
            currDepPart  = IIF(iAccKind == SIDEBALANCE_PASSIVE, int(rsd_line.HDepPart), int(rsd_line.LDepPart));
            currDepAcc1  = IIF(iAccKind == SIDEBALANCE_PASSIVE, int(rsd_line.LDepAcc),  int(rsd_line.HDepAcc));
            currDepPart1 = IIF(iAccKind == SIDEBALANCE_PASSIVE, int(rsd_line.LDepPart), int(rsd_line.HDepAcc));
            currGenFIID  = int(rsd_line.GenFIID);
            currFIID     = int(rsd_line.FIID);

            /* Как только изменился один из параметров, нужно напечатать строчку абсолютной позиции */
            if( (currDepAcc != prevDepAcc) or
                (currDepPart != prevDepPart) or
                (currDepAcc1 != prevDepAcc1) or
                (currDepPart1 != prevDepPart1) or
                (currGenFIID != prevGenFIID) or
                (currFIID != prevFIID) )
              IsColorLine = not IsColorLine;
              IsBold = true;

              prevDepAcc   = currDepAcc;
              prevDepPart  = currDepPart;
              prevDepAcc1  = currDepAcc1;
              prevDepPart1 = currDepPart1;
              prevGenFIID  = currGenFIID;
              prevFIID     = currFIID;

              PrintHeadLine(IsColorLine,
                            IsBold,
                            currDepPart,
                            currDepPart1,
                            currDepAcc1,
                            currGenFIID,
                            currFIID);
              CalcOverLine(rsd_line, iAccKind);
              PrintRestOverLine(currFIID, currGenFIID, IsColorLine, IsBold, GetRest({curdate}, currGenFIID, currFIID, currDepPart, currDepAcc), true, isFirst);
              isFirst = false;
            end;

            IsBold = false;

            /* Печатаем строчки операций */
            if( (int(rsd_line.DocKind) != 0) and iShowPaym )
              PrintOperLine(IsColorLine, rsd_line);
              PrepareLineRest(date(rsd_line.Date), rsd_line.Over);
              PrintRestOverLine(currFIID, currGenFIID, IsColorLine, IsBold, 0, false, isFirst);
            end;

            progress.Use();
          end;
        end;
      end;
    end;
  end;

  /* Недетализированные платежи */
  if( iShowPaym )
    sql = " SELECT r.* "
        +   " FROM ddp_plan_rests_tmp r "
        +  " WHERE r.t_IsDetail = CHR(0) "
        +    " AND r.t_DocKind > 0 " /* фиктивные не печатаем */
        + " ORDER BY r.t_Date, "
        +          " r.t_DocKind ";

    rsd = TRsbDataSet(sql);

    while( rsd.MoveNext() )
      if(IsUnknownPaymHeaderPrinted)
        isFirst = false;
      else
        isFirst = true;
      end;

      PrintUnknownPaymHeader();

      PrintUnkPaymLine(rsd, isFirst);

      progress.Use();
    end;
  end;

  progress.Remove();

  DP_StdFooter_Ex(Rep, "", null, null, TableWidth);

  DP_AddProtocol(Rep, "protocol");  //добавим протокол к уже сформированному отчету
  DP_EndProtocol();                 //закончить протоколирование

  if( Data.iToExcel )
    Rep.SetZoomType( ZOOM_TYPE_A4L );// альбомная ориентация

    Rep.PrintWinRep();
    Rep.ShowWinRep();
  else
    Rep.PrintRep();
  end;
end;

private class ExecuteSubAccData()
  var PayerDpNode;
  var ReceiverDpNode;
  var FIID;
  var Amount;
  var ValueDate;
  var DocKind;
  var DocumentID;
end;

/* Макрос проводки по субсчетам при операции перевода (Дб.П - Кр.П) */
private macro ExecuteSubAccTransfer( subaccdata:ExecuteSubAccData, GenFIID, iDepoAcc, iDepoPart, PayerAccount )
  var ReceiverDPAcc, stat;

  var f_accsub = TBFile( "accsub.dbt" );
  FILE f_accvanl( accvanl ) key 1;

  /* пытаемся найти по данному счету активные счета места хранения */
  f_accvanl.FIID        = subaccdata.FIID;
  f_accvanl.Chapter     = 5; /*CHAPT5*/
  f_accvanl.Account     = PayerAccount;
  f_accvanl.AnaliticsID = SYS_ANL_AINPACCOUNTING;
  if( GetEQ(f_accvanl) )
    f_accsub.AddFilter(" t_AccAnaliticsID = " + f_accvanl.AccAnaliticsID + " and t_SpecialType = 0 " );
    while( f_accsub.next() )
      ReceiverDPAcc = GetDPACbyACC(f_accsub.rec.SubAccountCode, subaccdata.FIID);

      if( CheckDPACCByID( iDepoAcc, iDepoPart, subaccdata.PayerDpNode ) )
        AddRecTempTable( subaccdata.PayerDpNode,
                         ReceiverDPAcc,
                         PayerAccount,
                         f_accsub.rec.SubAccountCode,
                         GenFIID,
                         subaccdata.FIID,
                         -subaccdata.Amount,
                         subaccdata.ValueDate,
                         subaccdata.DocKind,
                         subaccdata.DocumentID,
                         true );
      end;

      if( CheckDPACCByID( iDepoAcc, iDepoPart, ReceiverDPAcc ) )
        AddRecTempTable( subaccdata.PayerDpNode,
                         ReceiverDPAcc,
                         PayerAccount,
                         f_accsub.rec.SubAccountCode,
                         GenFIID,
                         subaccdata.FIID,
                         subaccdata.Amount,
                         subaccdata.ValueDate,
                         subaccdata.DocKind,
                         subaccdata.DocumentID,
                         true );
      end;
    end;
  else
    if( CheckDPACCByID( iDepoAcc, iDepoPart, subaccdata.PayerDpNode ) )
      AddRecTempTable( subaccdata.PayerDpNode,
                       0,
                       PayerAccount,
                       V_UNDEF,
                       GenFIID,
                       subaccdata.FIID,
                       -subaccdata.Amount,
                       subaccdata.ValueDate,
                       subaccdata.DocKind,
                       subaccdata.DocumentID,
                       true );
    else
      /* такая запись не должна попадать в отчет, т.к.*/
      /* корреспонденция, отностительно кот. строим очет, */
      /* осталась не выяснена */
    end;
  end;

  return 0;
end;

/* Макрос проводки по субсчетам при операции перемещения (Дб.А - Кр.А) */
private macro ExecuteSubAccMovement( subaccdata:ExecuteSubAccData, GenFIID, iDepoAcc, iDepoPart, ReceiverAccount )
  var PayerDPAcc;
  var stat;

  var f_accsub = TBFile("accsub.dbt");
  FILE f_accvanl(accvanl);

  f_accsub.AddFilter(" t_AnaliticsID = " + SYS_ANL_AINPACCOUNTING +
                     " and t_SubAccountCode = '" + ReceiverAccount +"' "
                     " and t_SpecialType = 0 " );
  stat = f_accsub.next();
  if( stat )
    while( stat )
      f_accvanl.AccAnaliticsID = f_accsub.rec.AccAnaliticsID;
      if( not GetEQ(f_accvanl) )
        f_accvanl.Account = "";
      end;

      PayerDPAcc = GetDPACbyACC(f_accvanl.Account, subaccdata.FIID);

      if( CheckDPACCByID( iDepoAcc, iDepoPart, subaccdata.ReceiverDpNode ) )
        AddRecTempTable( PayerDPAcc,
                         subaccdata.ReceiverDpNode,
                         f_accvanl.Account,
                         ReceiverAccount,
                         GenFIID,
                         subaccdata.FIID,
                         subaccdata.Amount,
                         subaccdata.ValueDate,
                         subaccdata.DocKind,
                         subaccdata.DocumentID,
                         true );
      end;

      if( CheckDPACCByID( iDepoAcc, iDepoPart, PayerDPAcc ) )
        AddRecTempTable( PayerDPAcc,
                         subaccdata.ReceiverDpNode,
                         f_accvanl.Account,
                         ReceiverAccount,
                         GenFIID,
                         subaccdata.FIID,
                         -subaccdata.Amount,
                         subaccdata.ValueDate,
                         subaccdata.DocKind,
                         subaccdata.DocumentID,
                         true );
      end;

      stat = f_accsub.next();
    end;
  else
    if( CheckDPACCByID( iDepoAcc, iDepoPart, subaccdata.ReceiverDpNode ) )
      AddRecTempTable( 0,
                       subaccdata.ReceiverDpNode,
                       V_UNDEF,
                       ReceiverAccount,
                       GenFIID,
                       subaccdata.FIID,
                       subaccdata.Amount,
                       subaccdata.ValueDate,
                       subaccdata.DocKind,
                       subaccdata.DocumentID,
                       true );
    else
      /* такая запись не должна попадать в отчет, т.к.*/
      /* корреспонденция, отностительно кот. строим очет, */
      /* осталась не выяснена */
    end;

  end;

  return 0;
end;

private macro DefineKindOperation( DwNodeID, BnNodeID )

  RECORD DwNode( depoacnt );
  RECORD BnNode( depoacnt );

  if( not FindDEPOACNT(DwNodeID, DwNode) )
    return KINDOPER_NOTDEFINED;
  end;

  if( not FindDEPOACNT(BnNodeID, BnNode) )
    return KINDOPER_NOTDEFINED;
  end;

  /* Определяем вид операции
     А->П - Зачисление
     П->А - Списание
     П->П - Перевод
     А->А - Перемещение (смена места хранения)
  */
  if(   ( DwNode.Kind == SIDEBALANCE_ACTIVE  ) AND ( BnNode.Kind == SIDEBALANCE_PASSIVE ) ) /* А->П - Зачисление */
    return KINDOPER_ENROLMENT;
  elif( ( DwNode.Kind == SIDEBALANCE_PASSIVE ) AND ( BnNode.Kind == SIDEBALANCE_ACTIVE  ) ) /* П->А - Списание */
    return KINDOPER_WRITINGOFF;
  elif( ( DwNode.Kind == SIDEBALANCE_PASSIVE ) AND ( BnNode.Kind == SIDEBALANCE_PASSIVE ) ) /* П->П - Перевод */
    return KINDOPER_TRANSFER;
  elif( ( DwNode.Kind == SIDEBALANCE_ACTIVE  ) AND ( BnNode.Kind == SIDEBALANCE_ACTIVE  ) ) /* А->А - Перемещение (смена места хранения) */
    return KINDOPER_MOVEMENT;
  end;

end;

/* определить вид сцелки БОЦБ (покупка/продажа) */
macro DefineSecurDealType( rq )
  var sql, rsd, Sign = 0;

  sql = " SELECT (CASE WHEN ((Rsb_Secur.IsBuy(Opr.oGrp)=1 OR "
      +                     " Rsb_Secur.IsAvrWrtIn(Opr.oGrp)=1 OR "
      +                     " (Rsb_Secur.IsLoan(Opr.oGrp)=1 AND Rsb_Secur.IsBuy(Opr.oGrp)=1)) AND "
      +                     "  Rsb_Secur.IsBackSale(Opr.oGrp)<>1 AND "
      +                     "  Rsb_Secur.IsRepo(Opr.oGrp)<>1) OR "
      +                     "  (Rsb_Secur.IsBuy(Opr.oGrp)=1 AND "
      +                     "  Rsb_Secur.IsRepo(Opr.oGrp)=1) OR "
      +                     "  (Rsb_Secur.IsBuy(Opr.oGrp)=1 AND "
      +                     "   Rsb_Secur.IsBackSale(Opr.oGrp)=1 AND "
      +                     "  Rsb_Secur.IsRepo(Opr.oGrp)<>1 AND "
      +                        string(rq.rec.DealPart) + " = 1) OR "
      +                     "  (((Rsb_Secur.IsSale(Opr.oGrp)=1 AND Rsb_Secur.IsBackSale(Opr.oGrp)=1) OR "
      +                     "   Rsb_Secur.check_GroupStr(Opr.oGrp,'100')=1 OR "
      +                     "  Rsb_Secur.check_GroupStr(Opr.oGrp,'200')=1) AND "
      +                     "  Rsb_Secur.IsRepo(Opr.oGrp)<>1 AND "
      +                        string(rq.rec.DealPart) + " = 2) "
      +                     "  THEN 1  "
      +                     "  ELSE 0 "
      +         " END) IsBuy, " /*это покупка*/
      +         " (CASE WHEN ((Rsb_Secur.IsSale(Opr.oGrp)=1 OR "
      +                      " Rsb_Secur.IsAvrWrtOut(Opr.oGrp)=1 OR "
      +                      " Rsb_Secur.check_GroupStr(Opr.oGrp,'800')=1 OR "
      +                      " (Rsb_Secur.IsLoan(Opr.oGrp)=1 AND Rsb_Secur.IsSale(Opr.oGrp)=1)) AND "
      +                     " Rsb_Secur.IsBackSale(Opr.oGrp)<>1 AND "
      +                     " Rsb_Secur.IsRepo(Opr.oGrp)<>1) OR "
      +                    " (Rsb_Secur.IsSale(Opr.oGrp)=1 AND "
      +                    "  Rsb_Secur.IsRepo(Opr.oGrp)=1) OR "
      +                    " (Rsb_Secur.IsBuy(Opr.oGrp)=1 AND "
      +                     " Rsb_Secur.IsBackSale(Opr.oGrp)=1 AND "
      +                     " Rsb_Secur.IsRepo(Opr.oGrp)<>1 AND "
      +                       string(rq.rec.DealPart) + " = 2) OR "
      +                    " (((Rsb_Secur.IsSale(Opr.oGrp)=1 AND Rsb_Secur.IsBackSale(Opr.oGrp)=1) OR "
      +                      " Rsb_Secur.check_GroupStr(Opr.oGrp,'100')=1 OR "
      +                      " Rsb_Secur.check_GroupStr(Opr.oGrp,'200')=1) AND "
      +                     " Rsb_Secur.IsRepo(Opr.oGrp)<>1 AND "
      +                       string(rq.rec.DealPart) + " = 1) "
      +                    " THEN 1  "
      +                   "  ELSE 0 "
      +          " END) IsSale " /*это продажа*/

      +   " FROM ddl_tick_dbt Tick, "
      +        " ddl_leg_dbt Leg, "
      +        " (SELECT t_Kind_Operation, t_DocKind, rsb_secur.get_OperationGroup(t_SysTypes) oGrp "
      +           " FROM doprkoper_dbt) Opr "
      +  " WHERE Tick.t_DealID = " + string(rq.rec.DocID)
      +    " AND Tick.t_BOfficeKind = " + string(rq.rec.DocKind)
      +    " AND Opr.t_Kind_Operation = Tick.t_DealType "
      +    " AND Opr.t_DocKind = Tick.t_BOfficeKind "
      +    " AND Leg.t_DealID = Tick.t_DealID "
      +    " AND Leg.t_LegID = 0 "
      +    " AND Leg.t_LegKind = DECODE(" + string(rq.rec.DealPart) + ", 1, 0, 2) ";

  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    if( int(rsd.IsBuy) == 1 )
      Sign = 1;
    else
      Sign = -1;
    end;
  else
    Sign = 0;
  end;

  return Sign;
end;

/* Заполнить временный файл отчета */
/* Здесь заполняем абсолютные позиции отчета */
macro FillTempTable( pmpaym, GenFIID, iDepoAcc, iDepoPart, PayerAccount, ReceiverAccount )

  var KindOpr;
  var Over = 0;
  var subaccdata;

  RECORD dacnt( depoacnt );

  KindOpr = DefineKindOperation( pmpaym.rec.PayerDPnode, pmpaym.rec.ReceiverDPNode );
  if(   KindOpr == KINDOPER_ENROLMENT )
    /* смотрим, на какой стороне баланса находится наш счет берем остатки нужного счета и знака*/
    if( CheckDPACCByID( iDepoAcc, iDepoPart, pmpaym.rec.ReceiverDpNode ) )
      AddRecTempTable( pmpaym.rec.ReceiverDpNode, /*депонент*/
                       pmpaym.rec.PayerDpNode,    /*хранилище*/
                       ReceiverAccount,
                       PayerAccount,
                       GenFIID,
                       pmpaym.rec.FIID,
                       pmpaym.rec.Amount,
                       pmpaym.rec.ValueDate,
                       pmpaym.rec.DocKind,
                       pmpaym.rec.DocumentID,
                       true );
    end;

    if( CheckDPACCByID( iDepoAcc, iDepoPart, pmpaym.rec.PayerDpNode ) )
      AddRecTempTable( pmpaym.rec.ReceiverDpNode, /*депонент*/
                       pmpaym.rec.PayerDpNode,    /*хранилище*/
                       ReceiverAccount,
                       PayerAccount,
                       GenFIID,
                       pmpaym.rec.FIID,
                       -pmpaym.rec.Amount,
                       pmpaym.rec.ValueDate,
                       pmpaym.rec.DocKind,
                       pmpaym.rec.DocumentID,
                       true );
    end;
  elif( KindOpr == KINDOPER_WRITINGOFF )
    if( CheckDPACCByID( iDepoAcc, iDepoPart, pmpaym.rec.PayerDpNode ) )
      AddRecTempTable( pmpaym.rec.PayerDpNode,    /*депонент*/
                       pmpaym.rec.ReceiverDpNode, /*хранилище*/
                       PayerAccount,
                       ReceiverAccount,
                       GenFIID,
                       pmpaym.rec.FIID,
                       -pmpaym.rec.Amount,
                       pmpaym.rec.ValueDate,
                       pmpaym.rec.DocKind,
                       pmpaym.rec.DocumentID,
                       true );
    end;

    if( CheckDPACCByID( iDepoAcc, iDepoPart, pmpaym.rec.ReceiverDpNode ) )
      AddRecTempTable( pmpaym.rec.PayerDpNode,    /*депонент*/
                       pmpaym.rec.ReceiverDpNode, /*хранилище*/
                       PayerAccount,
                       ReceiverAccount,
                       GenFIID,
                       pmpaym.rec.FIID,
                       pmpaym.rec.Amount,
                       pmpaym.rec.ValueDate,
                       pmpaym.rec.DocKind,
                       pmpaym.rec.DocumentID,
                       true );
    end;
  elif( KindOpr == KINDOPER_TRANSFER )
    subaccdata = ExecuteSubAccData();
    subaccdata.PayerDpNode    = pmpaym.rec.PayerDpNode;
    subaccdata.ReceiverDpNode = pmpaym.rec.ReceiverDpNode;
    subaccdata.FIID           = pmpaym.rec.FIID;
    subaccdata.Amount         = pmpaym.rec.Amount;
    subaccdata.ValueDate      = pmpaym.rec.ValueDate;
    subaccdata.DocKind        = pmpaym.rec.DocKind;
    subaccdata.DocumentID     = pmpaym.rec.DocumentID;
    ExecuteSubAccTransfer( subaccdata, GenFIID, iDepoAcc, iDepoPart, PayerAccount );
  elif( KindOpr == KINDOPER_MOVEMENT )
    subaccdata = ExecuteSubAccData();
    subaccdata.PayerDpNode    = pmpaym.rec.PayerDpNode;
    subaccdata.ReceiverDpNode = pmpaym.rec.ReceiverDpNode;
    subaccdata.FIID           = pmpaym.rec.FIID;
    subaccdata.Amount         = pmpaym.rec.Amount;
    subaccdata.ValueDate      = pmpaym.rec.ValueDate;
    subaccdata.DocKind        = pmpaym.rec.DocKind;
    subaccdata.DocumentID     = pmpaym.rec.DocumentID;
    ExecuteSubAccMovement( subaccdata, GenFIID, iDepoAcc, iDepoPart, ReceiverAccount );
  else
    /* одна из сторон баланса не определена */
    if( FindDEPOACNT(pmpaym.rec.PayerDPnode, dacnt) and
        CheckDPACCByID( iDepoAcc, iDepoPart, pmpaym.rec.PayerDPnode ) )

      /*направление проводки узанем по виду платежа*/
      if( (pmpaym.rec.DocKind == SP_DEPOPER_BOOKORDER) or
          (pmpaym.rec.DocKind == SP_DEPOPER_TRANSFERORDER) or
          (pmpaym.rec.DocKind == SP_DEPOPER_ENROLMENT) or
          (pmpaym.rec.DocKind == SP_DEPOPER_RECORDER) or
          (pmpaym.rec.DocKind == SP_DEPOPER_WITHDRORDER) )
        if( dacnt.Kind == SIDEBALANCE_PASSIVE )

          AddRecTempTable( pmpaym.rec.PayerDpNode,
                           0,
                           PayerAccount,
                           V_UNDEF,
                           GenFIID,
                           pmpaym.rec.FIID,
                           -pmpaym.rec.Amount,
                           pmpaym.rec.ValueDate,
                           pmpaym.rec.DocKind,
                           pmpaym.rec.DocumentID,
                           true );
        else

          AddRecTempTable( 0,
                           pmpaym.rec.PayerDpNode,
                           V_UNDEF,
                           PayerAccount,
                           GenFIID,
                           pmpaym.rec.FIID,
                           -pmpaym.rec.Amount,
                           pmpaym.rec.ValueDate,
                           pmpaym.rec.DocKind,
                           pmpaym.rec.DocumentID,
                           true );
        end;
      end;
    end;
    if( FindDEPOACNT(pmpaym.rec.ReceiverDPnode, dacnt) and
        CheckDPACCByID( iDepoAcc, iDepoPart, pmpaym.rec.ReceiverDpNode )  )

      /*направление проводки узанем по виду платежа*/
      if( (pmpaym.rec.DocKind == SP_DEPOPER_BOOKORDER) or
          (pmpaym.rec.DocKind == SP_DEPOPER_TRANSFERORDER) or
          (pmpaym.rec.DocKind == SP_DEPOPER_ENROLMENT) or
          (pmpaym.rec.DocKind == SP_DEPOPER_RECORDER) or
          (pmpaym.rec.DocKind == SP_DEPOPER_WITHDRORDER) )
        if( dacnt.Kind == SIDEBALANCE_PASSIVE )

          AddRecTempTable( pmpaym.rec.ReceiverDpNode,
                           0,
                           ReceiverAccount,
                           V_UNDEF,
                           GenFIID,
                           pmpaym.rec.FIID,
                           pmpaym.rec.Amount,
                           pmpaym.rec.ValueDate,
                           pmpaym.rec.DocKind,
                           pmpaym.rec.DocumentID,
                           true );
        else

          AddRecTempTable( 0,
                           pmpaym.rec.ReceiverDpNode,
                           V_UNDEF,
                           ReceiverAccount,
                           GenFIID,
                           pmpaym.rec.FIID,
                           pmpaym.rec.Amount,
                           pmpaym.rec.ValueDate,
                           pmpaym.rec.DocKind,
                           pmpaym.rec.DocumentID,
                           true );
        end;
      end;
    end;
  end;
end;

/* Заполнить временный файл отчета */
/* Здесь заполняем абсолютные позиции отчета */
macro FillTempTableRQ( rq, PayerDPnode, ReceiverDPNode, GenFIID, iDepoAcc, iDepoPart, PayerAccount, ReceiverAccount )

  var KindOpr;
  var Over = 0, IsKnown = true;
  var subaccdata;

  RECORD dacnt( depoacnt );

  KindOpr = DefineKindOperation( PayerDPnode, ReceiverDPNode );
  if(   KindOpr == KINDOPER_ENROLMENT )
    /* смотрим, на какой стороне баланса находится наш счет берем остатки нужного счета и знака*/
    if( CheckDPACCByID( iDepoAcc, iDepoPart, ReceiverDpNode ) )
      AddRecTempTable( ReceiverDpNode, /*депонент*/
                       PayerDpNode,    /*хранилище*/
                       ReceiverAccount,
                       PayerAccount,
                       GenFIID,
                       rq.rec.FIID,
                       rq.rec.Amount,
                       rq.rec.PlanDate,
                       rq.rec.DocKind,
                       rq.rec.DocID,
                       true );
    end;

    if( CheckDPACCByID( iDepoAcc, iDepoPart, PayerDpNode ) )
      AddRecTempTable( ReceiverDpNode, /*депонент*/
                       PayerDpNode,    /*хранилище*/
                       ReceiverAccount,
                       PayerAccount,
                       GenFIID,
                       rq.rec.FIID,
                       -rq.rec.Amount,
                       rq.rec.PlanDate,
                       rq.rec.DocKind,
                       rq.rec.DocID,
                       true );
    end;
  elif( KindOpr == KINDOPER_WRITINGOFF )
    if( CheckDPACCByID( iDepoAcc, iDepoPart, PayerDpNode ) )
      AddRecTempTable( PayerDpNode,    /*депонент*/
                       ReceiverDpNode, /*хранилище*/
                       PayerAccount,
                       ReceiverAccount,
                       GenFIID,
                       rq.rec.FIID,
                       -rq.rec.Amount,
                       rq.rec.PlanDate,
                       rq.rec.DocKind,
                       rq.rec.DocID,
                       true );
    end;

    if( CheckDPACCByID( iDepoAcc, iDepoPart, ReceiverDpNode ) )
      AddRecTempTable( PayerDpNode,    /*депонент*/
                       ReceiverDpNode, /*хранилище*/
                       PayerAccount,
                       ReceiverAccount,
                       GenFIID,
                       rq.rec.FIID,
                       rq.rec.Amount,
                       rq.rec.PlanDate,
                       rq.rec.DocKind,
                       rq.rec.DocID,
                       true );
    end;
  elif( KindOpr == KINDOPER_TRANSFER )
    subaccdata = ExecuteSubAccData();
    subaccdata.PayerDpNode    = PayerDpNode;
    subaccdata.ReceiverDpNode = ReceiverDpNode;
    subaccdata.FIID           = rq.rec.FIID;
    subaccdata.Amount         = rq.rec.Amount;
    subaccdata.ValueDate      = rq.rec.PlanDate;
    subaccdata.DocKind        = rq.rec.DocKind;
    subaccdata.DocumentID     = rq.rec.DocID;
    ExecuteSubAccTransfer( subaccdata, GenFIID, iDepoAcc, iDepoPart, PayerAccount );
  elif( KindOpr == KINDOPER_MOVEMENT )
    subaccdata = ExecuteSubAccData();
    subaccdata.PayerDpNode    = PayerDpNode;
    subaccdata.ReceiverDpNode = ReceiverDpNode;
    subaccdata.FIID           = rq.rec.FIID;
    subaccdata.Amount         = rq.rec.Amount;
    subaccdata.ValueDate      = rq.rec.PlanDate;
    subaccdata.DocKind        = rq.rec.DocKind;
    subaccdata.DocumentID     = rq.rec.DocID;
    ExecuteSubAccMovement( subaccdata, GenFIID, iDepoAcc, iDepoPart, ReceiverAccount );
  else
    /* одна из сторон баланса не определена */
    if( FindDEPOACNT(PayerDPnode, dacnt) and
        CheckDPACCByID( iDepoAcc, iDepoPart, PayerDPnode ) )

      if( dacnt.Kind == SIDEBALANCE_PASSIVE )
        Over = -DefineSecurDealType( rq );
      else
        Over = DefineSecurDealType( rq );
      end;

      if( Over == 0 )
        /*так и не смогли понять, что это. В нераспознаные*/
        IsKnown = false;
      else
        Over = Over * rq.rec.Amount;
        if( dacnt.Kind == SIDEBALANCE_PASSIVE )

          AddRecTempTable( PayerDpNode,
                           0,
                           PayerAccount,
                           V_UNDEF,
                           GenFIID,
                           rq.rec.FIID,
                           Over,
                           rq.rec.PlanDate,
                           rq.rec.DocKind,
                           rq.rec.DocID,
                           true );
        else

          AddRecTempTable( 0,
                           PayerDpNode,
                           V_UNDEF,
                           PayerAccount,
                           GenFIID,
                           rq.rec.FIID,
                           Over,
                           rq.rec.PlanDate,
                           rq.rec.DocKind,
                           rq.rec.DocID,
                           true );
        end;
      end;
    end;
    if( FindDEPOACNT(ReceiverDPnode, dacnt) and
        CheckDPACCByID( iDepoAcc, iDepoPart, ReceiverDpNode )  )

      if( dacnt.Kind == SIDEBALANCE_PASSIVE )
        Over = DefineSecurDealType( rq );
      else
        Over = -DefineSecurDealType( rq );
      end;

      if( Over == 0 )
        /*так и не смогли понять, что это. В нераспознаные*/
        IsKnown = false;
      else
        Over = Over * rq.rec.Amount;
        if( dacnt.Kind == SIDEBALANCE_PASSIVE )

          AddRecTempTable( 0,
                           ReceiverDpNode,
                           V_UNDEF,
                           ReceiverAccount,
                           GenFIID,
                           rq.rec.FIID,
                           Over,
                           rq.rec.PlanDate,
                           rq.rec.DocKind,
                           rq.rec.DocID,
                           true );
        else

          AddRecTempTable( ReceiverDpNode,
                           0,
                           ReceiverAccount,
                           V_UNDEF,
                           GenFIID,
                           rq.rec.FIID,
                           Over,
                           rq.rec.PlanDate,
                           rq.rec.DocKind,
                           rq.rec.DocID,
                           true );
        end;
      end;
    end;
    if( not IsKnown )
      /* ни одна из сторон баланса не определена */
      AddRecTempTable( 0,
                       0,
                       V_UNDEF,
                       V_UNDEF,
                       GenFIID,
                       rq.rec.FIID,
                       rq.rec.Amount,
                       rq.rec.PlanDate,
                       rq.rec.DocKind,
                       rq.rec.DocID,
                       false );
    end;
  end;
end;

/* выполнить дозаполнение абсолютными позициями */
/* вставить обобщающие строки по группам выпусков с незаполненной корреспонденцией*/
/* вставить обобщающие строки по обобщенным выпускам с незаполненной корреспонденцией */
macro AddFillTable( iAccKind )
  var sql, sql1, rsd, rsd1;
  var progress = CProgressBar;

  /* по группам фактических выпусков добавим объединяющую строчку с отсутствующей корреспонденцией*/
  if( iAccKind == SIDEBALANCE_PASSIVE )
    sql = " SELECT r.t_HDepAcc as DepAcc, "
        +        " r.t_HDepPart as DepPart, "
        +        " r.t_GenFIID as GenFIID, "
        +        " r.t_FIID, "
        +        " r.t_LDepAcc as DepAcc1, "
        +        " r.t_LDepPart as DepPart1 "
        +   " FROM ddp_plan_rests_tmp r "
        +  " WHERE r.t_IsDetail = 'X' "
        + " GROUP BY r.t_HDepAcc, "
        +          " r.t_HDepPart, "
        +          " r.t_GenFIID, "
        +          " r.t_FIID, "
        +          " r.t_LDepAcc, "
        +          " r.t_LDepPart ";
  else
    sql = " SELECT r.t_LDepAcc as DepAcc, "
        +        " r.t_LDepPart as DepPart, "
        +        " r.t_GenFIID as GenFIID, "
        +        " r.t_FIID, "
        +        " r.t_HDepAcc as DepAcc1, "
        +        " r.t_HDepPart as DepPart1 "
        +   " FROM ddp_plan_rests_tmp r "
        +  " WHERE r.t_IsDetail = 'X' "
        + " GROUP BY r.t_LDepAcc, "
        +          " r.t_LDepPart, "
        +          " r.t_GenFIID, "
        +          " r.t_FIID, "
        +          " r.t_HDepAcc, "
        +          " r.t_HDepPart ";
  end;

  rsd = TRsbDataSet(sql);
  progress.Init( -1, "Формирование данных для отчета" );

  while( rsd.MoveNext() )

    if( iAccKind == SIDEBALANCE_PASSIVE )
      sql1 = " SELECT r.t_Over "
           +   " FROM ddp_plan_rests_tmp r "
           +  " WHERE r.t_IsDetail = 'X' "
           +    " AND r.t_HDepAcc = " + string(rsd.DepAcc)
           +    " AND r.t_HDepPart = " + string(rsd.DepPart)
           +    " AND r.t_LDepAcc = 0 "
           +    " AND r.t_LDepPart = 0 "
           +    " AND r.t_FIID = " + string(rsd.FIID)
           +    " AND r.t_GenFIID = " + string(rsd.GenFIID);
    else
      sql1 = " SELECT r.t_Over "
           +   " FROM ddp_plan_rests_tmp r "
           +  " WHERE r.t_IsDetail = 'X' "
           +    " AND r.t_LDepAcc = " + string(rsd.DepAcc)
           +    " AND r.t_LDepPart = " + string(rsd.DepPart)
           +    " AND r.t_HDepAcc = 0 "
           +    " AND r.t_HDepPart = 0 "
           +    " AND r.t_FIID = " + string(rsd.FIID)
           +    " AND r.t_GenFIID = " + string(rsd.GenFIID);
    end;

    rsd1 = TRsbDataSet(sql1);
    if( not rsd1.MoveNext() )
      AddRecTempTable( IIF(iAccKind == SIDEBALANCE_PASSIVE, rsd.DepPart, 0),
                       IIF(iAccKind == SIDEBALANCE_PASSIVE, 0, rsd.DepPart),
                       V_UNDEF,
                       V_UNDEF,
                       rsd.GenFIID,
                       rsd.FIID,
                       0,
                       {curdate},
                       0,
                       0,
                       true );
    end;

    /* если есть обобщенный выпуск, то добавим группу и по нему */
    if(  int(rsd.GenFIID) > 0 )
      if( iAccKind == SIDEBALANCE_PASSIVE )
        sql1 = " SELECT r.t_Over "
             +   " FROM ddp_plan_rests_tmp r "
             +  " WHERE r.t_IsDetail = 'X' "
             +    " AND r.t_HDepAcc = " + string(rsd.DepAcc)
             +    " AND r.t_HDepPart = " + string(rsd.DepPart)
             +    " AND r.t_LDepAcc = 0 "
             +    " AND r.t_LDepPart = 0 "
             +    " AND r.t_FIID = -1 "
             +    " AND r.t_GenFIID = " + string(rsd.GenFIID);
      else
        sql1 = " SELECT r.t_Over "
             +   " FROM ddp_plan_rests_tmp r "
             +  " WHERE r.t_IsDetail = 'X' "
             +    " AND r.t_LDepAcc = " + string(rsd.DepAcc)
             +    " AND r.t_LDepPart = " + string(rsd.DepPart)
             +    " AND r.t_HDepAcc = 0 "
             +    " AND r.t_HDepPart = 0 "
             +    " AND r.t_FIID = -1 "
             +    " AND r.t_GenFIID = " + string(rsd.GenFIID);
      end;

      rsd1 = TRsbDataSet(sql1);
      if( not rsd1.MoveNext() )
        AddRecTempTable( IIF(iAccKind == SIDEBALANCE_PASSIVE, rsd.DepPart, 0),
                         IIF(iAccKind == SIDEBALANCE_PASSIVE, 0, rsd.DepPart),
                         V_UNDEF,
                         V_UNDEF,
                         rsd.GenFIID,
                         -1,
                         0,
                         {curdate},
                         0,
                         0,
                         true );
      end;
    end;

    progress.Use();
  end;

  progress.Remove();

end;

/* проверить валидность платеж условиям фильтра */
macro Confirm( DPNode, iAccKind, iDeponent, iDepoPart )

  var sql, rsd;

  sql = " SELECT part.t_AutoKey "
      +   " FROM ddepoacnt_dbt part, "
      +        " ddepoacnt_dbt acc "
      +  " WHERE part.t_AutoKey = " + DPNode
      +    " AND part.t_Kind = " + iAccKind
      +    " AND part.t_Owner = " + iDeponent;

  sql = sql
      +    " AND acc.t_AutoKey = part.t_Root "
      + " AND EXISTS( SELECT da.t_AutoKey "
      +               " FROM ddepoacnt_dbt da ";

  if( iDepoPart > 0 )
    sql = sql
        + " WHERE da.t_AutoKey = " + iDepoPart;
  end;

  sql = sql
      + " START WITH da.t_AutoKey  = part.t_AutoKey "
      + " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey )";
  rsd = TRsbDataSet(sql);
  if( rsd.MoveNext() )
    return true;
  end;

  return false;
end;

/* Отчет "Планируемые остатки на аналитическом узле" */
macro GenRep ( iNumDprt      : integer,
               iAccKind      : integer,
               iDeponent     : integer,
               iDepoAcc      : integer,
               iDepoPart     : integer,
               iFIGen        : integer,
               iFI           : integer,
               iDay          : integer,
               iWhatPayments : integer,
               iIsGenFIID    : bool,
               iShowDeponent : bool,
               iShowPaym     : bool,
               iToExcel      : bool,
               iIsApp        : bool
             )

  var err, AinPEnabled = false;
  var sql_sub, sql =  "", rsd;
  var dplist;
  var PayerAccount = "", ReceiverAccount = "", PayerDPNode = 0, ReceiverDPNode = 0, Type;
  var pmpaym = TRecHandler("pmpaym");
  var progress = CProgressBar;
  RECORD dpacnt( depoacnt );
  var rq = TRecHandler("dlrq.dbt");
  var rqacc = TRecHandler("dlrqacc.dbt");
  var AccountBuff = TRecHandler("account.dbt");

  var stat = 0;
  file BankMSG("bank.msg");

  Dl_CallInsertStat( IIF( iToExcel, DL_OUTREPORT_EXCEL, DL_OUTREPORT_STD ) );

  DP_BeginProtocol();  //начать протоколирование - подмена MsgBox

  GetRegistryValue( "DEPO\\AINPACCOUNTING", V_BOOL, AinPEnabled, err );

  if( err or (not AinPEnabled) )
    DP_EndProtocol();                 //закончить протоколирование
    msgbox("Учет Актива в Пассиве не ведется. Выпуск отчета невозможен");
    return;
  end;

  _SelfID = DP_GetSelfId(iNumDprt);

  Data.Init(iNumDprt,
            iAccKind ,
            iDeponent,
            iDepoAcc,
            iDepoPart,
            iFIGen,
            iFI,
            iDay,
            iWhatPayments,
            iIsGenFIID,
            iShowDeponent,
            iShowPaym,
            iToExcel,
            iIsApp);

  /* предварительно сформируем список ИД всех разделов заданного счета */
  sql = " SELECT da.t_AutoKey "
      +   " FROM ddepoacnt_dbt da "
      +  " START WITH da.t_AutoKey  = " + iDepoAcc
      +  " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey ";
  rsd = TRsbDataSet(sql);

  dplist = "(0";
  while( rsd.MoveNext() )
    dplist = dplist
           + ", " + string(rsd.AutoKey);
  end;
  dplist = dplist
         + ")";
  sql = "";
  rsd = null;

  CreateTempTable();

  //Шаг 0. Сначала соберем остатки на сегодняшний день по счету
  sql_sub = " SELECT da.t_AutoKey "
         +   " FROM ddepoacnt_dbt da "
         +  " WHERE NOT Exists( SELECT da1.t_AutoKey FROM ddepoacnt_dbt da1 WHERE da1.t_Superior = da.t_AutoKey) "
         +  " START WITH da.t_AutoKey  = " + iDepoAcc
         +  " CONNECT BY da.t_Superior = PRIOR da.t_AutoKey ";


  if( iAccKind == SIDEBALANCE_PASSIVE )
    sql =   " SELECT accP.t_DepoAcc as PayerDpNode, accA.t_DepoAcc as ReceiverDpNode, "
          + "        accP.t_Account as PayerAccount, accA.t_Account as ReceiverAccount, "
          + "        NVL(rsi_rsb_account.restsa(sub.t_AccAnaliticsID,sub.t_SubAccountID,"+GetSQLDate({curdate}+iDay)+",1), 0) as Rest, "
          + "        van.t_FIID as FIID, NVL(fin.t_GeneralizedFIID, -1) GenFIID "
          + " FROM daccount_dbt accP, daccvanl_dbt van, daccsub_dbt sub, daccount_dbt accA, dfininstr_dbt fin "
          + " WHERE accP.t_DepoAcc IN ("+sql_sub+") "
          + "   AND van.t_Account = accP.t_Account "
          + "   AND van.t_Chapter = accP.t_Chapter "
          + "   AND van.t_FIID = accP.t_Code_Currency "
          + "   AND sub.t_AccAnaliticsID = van.t_AccAnaliticsID "
          + "   AND sub.t_AnaliticsID = van.t_AnaliticsID "
          + "   AND sub.t_SpecialType = " + ACCSUB_SPECTYPE_NONE
          + "   AND accA.t_Account = sub.t_SubAccountCode "
          + "   AND accA.t_Chapter = accP.t_Chapter "
          + "   AND accA.t_Code_Currency = accP.t_Code_Currency "
          + "   AND fin.t_FIID(+) = van.t_FIID ";
  else
    sql =   " SELECT accP.t_DepoAcc as PayerDpNode, accA.t_DepoAcc as ReceiverDpNode, "
          + "        accP.t_Account as PayerAccount, accA.t_Account as ReceiverAccount, "
          + "        NVL(rsi_rsb_account.restsa(sub.t_AccAnaliticsID,sub.t_SubAccountID,"+GetSQLDate({curdate}+iDay)+",1), 0) as Rest, "
          + "        van.t_FIID as FIID, NVL(fin.t_GeneralizedFIID, -1) GenFIID "
          + " FROM daccount_dbt accP, daccvanl_dbt van, daccsub_dbt sub, daccount_dbt accA, dfininstr_dbt fin "
          + " WHERE accA.t_DepoAcc IN ("+sql_sub+") "
          + "   AND sub.t_SubAccountCode = accA.t_Account "
          + "   AND sub.t_SpecialType = " + ACCSUB_SPECTYPE_NONE
          + "   AND van.t_AccAnaliticsID = sub.t_AccAnaliticsID "
          + "   AND van.t_AnaliticsID = sub.t_AnaliticsID "
          + "   AND accP.t_Account = van.t_Account "
          + "   AND accP.t_Chapter = van.t_Chapter "
          + "   AND accP.t_Code_Currency = van.t_FIID "
          + "   AND fin.t_FIID(+) = van.t_FIID ";
   end;

  sql =   " select q.* "
        + "   from ("+sql+") q "
        + "  where q.Rest <> 0 ";

  rsd = TRsbDataSet(sql);
  while(rsd.MoveNext())

    AddRecTempTable( rsd.PayerDpNode,    /*депонент*/
                     rsd.ReceiverDpNode, /*хранилище*/
                     rsd.PayerAccount,
                     rsd.ReceiverAccount,
                     rsd.GenFIID,
                     rsd.FIID,
                     0,
                     {curdate},
                     0,
                     0,
                     false );
  end;

  sql = "";
  rsd = null;

  /*Шаг 1. Выбираем все необходимые платежи*/

  /* сначала отбираем все платежи с общими параметрами */
  sql_sub = " SELECT /*+INDEX (pm dpmpaym_dbt_idxc)*/ pm.* "
          +   " FROM dpmpaym_dbt pm "
          +  " WHERE (pm.t_PaymStatus < " + string(PM_REJECTED)
          +      " OR (pm.t_PaymStatus > " + string(PM_CLOSED_W_M_MOVEMENT)
          +      " AND pm.t_PaymStatus < " + string(PM_FINISHED) + ")) "
          +    " AND pm.t_DocKind IN (" + SP_DEPOPER_BOOKORDER /*SP_DEPOPER_UNIVOPERATION*/ + ", "
                                        + SP_DEPOPER_TRANSFERORDER + ", "
                                        + SP_DEPOPER_ENROLMENT + ", "
                                        + SP_DEPOPER_RECORDER + ", "
                                        + SP_DEPOPER_WITHDRORDER + " ) "
          +    " AND pm.t_Purpose = " + BAi
          +    " AND pm.t_Department = " + iNumDprt
          +    " AND pm.t_ValueDate <= " + GetSQLDate({curdate}+iDay)
          +    " AND ( pm.t_PayerDpNode IN " + dplist
          +      " OR  pm.t_ReceiverDpNode IN " + dplist + ") ";

  /* теперь отбираем платежи с индивидуальными для Депозитария и БОЦБ параметрами */
  /* iWhatPayments == 0 - Все платежи
     iWhatPayments == 1 - платежи в расчетах. Все платежи по БОЦБ и все платежи Депозитария, сформированные по БОЦБ
     iWhatPayments == 2 - по поручениям в расчетах. Все платежи Депозитария, сформированные по БОЦБ
     iWhatPayments == 3 - по зарегистрированным поручениям. Все зарегистрированные платежи Депозитария */

  if( (iWhatPayments == 0) or (iWhatPayments == 3) )
    /* все платежи */
    sql = sql
        +  " SELECT pm.*, "
        +         " NVL(fin.t_GeneralizedFIID, -1) GenFIID, "
        +         " pm.t_FIID FactFIID "
        +   " FROM (" + sql_sub + ") pm, "
        +         " dspdrmove_dbt move, "
        +         " dspdraft_dbt draft, "
        +         " dspground_dbt spgr, "
        +         " dfininstr_dbt fin "
        +  " WHERE pm.t_DocKind IN (" + SP_DEPOPER_BOOKORDER /*SP_DEPOPER_UNIVOPERATION*/ + ", "
                                      + SP_DEPOPER_TRANSFERORDER + ", "
                                      + SP_DEPOPER_ENROLMENT + ", "
                                      + SP_DEPOPER_RECORDER + ", "
                                      + SP_DEPOPER_WITHDRORDER + " ) "
        + " AND move.t_PaymentID = pm.t_PaymentID "
        + " AND draft.t_AutoKey = move.t_DraftID "
        + " AND spgr.t_SPgroundID = draft.t_SPgroundID "
        + " AND fin.t_FIID(+) = pm.t_FIID"
        + " AND ( (draft.t_GeneralizedFIID > 0 AND rsb_fiinstr.FI_IsSecurIndividual(draft.t_GeneralizedFIID) = 0) OR "
        +       " (pm.t_FIID > 0 AND rsb_fiinstr.FI_IsSecurIndividual(pm.t_FIID) = 0) ) ";
    /* только зарегистрированные */
    if( iWhatPayments == 3 )
      sql = sql
          + " AND spgr.t_Xld <> CHR(1) ";
    end;
  elif( (iWhatPayments == 1) or (iWhatPayments == 2) )
    /* только импортированные платежи из БОЦБ */
    sql = sql
        + " SELECT pm.*, "
        +        " NVL(fin.t_GeneralizedFIID, -1) GenFIID, "
        +        " pm.t_FIID FactFIID "
        +   " FROM (" + sql_sub + ") pm, "
        +         " dspdrmove_dbt move, "
        +         " dspdraft_dbt draft, "
        +         " dfininstr_dbt fin "
        +  " WHERE pm.t_DocKind IN (" + SP_DEPOPER_BOOKORDER /*SP_DEPOPER_UNIVOPERATION*/ + ", "
                                      + SP_DEPOPER_TRANSFERORDER + ", "
                                      + SP_DEPOPER_ENROLMENT + ", "
                                      + SP_DEPOPER_RECORDER + ", "
                                      + SP_DEPOPER_WITHDRORDER + " ) "
        +    " AND pm.t_PaymStatus < " + PM_FINISHED
        +    " AND move.t_PaymentID = pm.t_PaymentID "
        +    " AND draft.t_AutoKey = move.t_DraftID "
        +    " AND Exists(select 1 from dspdrprop_dbt sp "
        +    "             where sp.t_DocumentKind IN (" + DL_SECURITYDOC + ", "
                                                         + DL_RETIREMENT + ", "
                                                         + DL_SETTLEMENT + ", "
                                                         + DL_AVRWRT + ", "
                                                         + DL_NTGSEC + ") "
        +    "               and sp.t_DraftID = draft.t_AutoKey) "
        + " AND fin.t_FIID(+) = pm.t_FIID"
        + " AND ( (draft.t_GeneralizedFIID > 0 AND rsb_fiinstr.FI_IsSecurIndividual(draft.t_GeneralizedFIID) = 0) OR "
        +       " (pm.t_FIID > 0 AND rsb_fiinstr.FI_IsSecurIndividual(pm.t_FIID) = 0) ) ";
  end;
  if( iFIGen > 0 )
    sql = sql
        + " AND draft.t_GeneralizedFIID = " + iFIGen
        + " AND fin.t_GeneralizedFIID(+) = " + iFIGen;
  end;
  if( iFI > 0 )
    sql = sql
        + " AND (pm.t_FIID = " + iFI
        +      " OR pm.t_FIID = -1)";
  else
    if( not iIsGenFIID )
      sql = sql
          + " AND pm.t_FIID <> -1";
    end;
  end;

  /* распечатка готового запроса */
  /*println(sql);*/

  progress.Init( -1, "Формирование данных для отчета" );
  rsd = TRsbDataSet(sql);
  while(rsd.MoveNext())
    rsd.GetRecord().CopyTo(pmpaym.rec);

    /* для тех платежей, у кот. FIID не факт. выпуск, пытаемся выполнить подмену для возможности дальнейшего позиционирования*/
    if( (rsd.FactFIID != -1) and (pmpaym.rec.FIID != rsd.FactFIID) )
      pmpaym.rec.FIID = rsd.FactFIID;
    end;

    /* просроченные платежи выводим в колонке (t+0) */
    if( pmpaym.rec.ValueDate < {curdate} )
      pmpaym.rec.ValueDate = {curdate};
    end;

    /*Шаг 2. Позиционируем и уточняем терминальные и лицевые счета */
    stat = DP_PosPaym(pmpaym, PayerAccount, ReceiverAccount);

    if(stat)
      BankMSG.number = stat;

      if(GetEQ(BankMSG))
        msgbox(BankMSG.contents);
      end;

      InitError();
    end;

    /*Шаг 3. Отфильтровываем все лишнее */
    if( Confirm( pmpaym.rec.PayerDPNode,    iAccKind, iDeponent, iDepoPart ) or
        Confirm( pmpaym.rec.ReceiverDPNode, iAccKind, iDeponent, iDepoPart ) )

      /*Шаг 4. Выполним разноску по субсчетам и заполним временный файл */
      FillTempTable( pmpaym, int(rsd.GenFIID), iDepoAcc, iDepoPart, PayerAccount, ReceiverAccount );
    end;

    progress.Use();
  end;
  progress.Remove();

  rsd = null;
  //ТО БОЦБ
  if( (iWhatPayments == 0) or (iWhatPayments == 1) )
    sql =   " select rq.*, NVL(fin.t_GeneralizedFIID, -1) GenFIID, tick.t_ClientID as DealClientID, "
          + "        (select count(sp.t_DraftID) from dspdrprop_dbt sp where sp.t_PaymentID = rq.t_ID and sp.t_DocumentKind = rq.t_DocKind and sp.t_DocumentID = rq.t_DocID) as CntDraft "
          + "   from ddlrq_dbt rq, dfininstr_dbt fin, ddl_tick_dbt tick, ddl_leg_dbt leg "
          + "  where rq.t_State <> " + DLRQ_STATE_EXEC
          + "    and rq.t_SubKind = " + DLRQ_SUBKIND_AVOIRISS
          + "    and rq.t_PlanDate <= " + GetSQLDate({curdate}+iDay)
          + "    and fin.t_FIID = rq.t_FIID "
          + "    and tick.t_DealID = rq.t_DocID "
          + "    and tick.t_BOfficeKind = rq.t_DocKind "
          + "    and tick.t_Department = " + iNumDprt
          + "    and leg.t_DealID = tick.t_DealID "
          + "    and leg.t_LegID = 0 "
          + "    and leg.t_LegKind = DECODE(rq.t_DealPart, 1, 0, 2)";

    if( iFIGen > 0 )
      sql = sql
          + " AND rq.t_FIID = " + iFIGen
          + " AND fin.t_GeneralizedFIID(+) = " + iFIGen;
    end;
    if( iFI > 0 )
      sql = sql
          + " AND (leg.t_DeliveringFIID = " + iFI
          +      " OR leg.t_DeliveringFIID = -1)";
    else
      if( not iIsGenFIID )
        sql = sql
            + " AND leg.t_DeliveringFIID <> -1";
      end;
    end;

    progress.Init( -1, "Формирование данных для отчета по ТО" );
    rsd = TRsbDataSet(sql);
    while(rsd.MoveNext())
      rsd.GetRecord().CopyTo(rq.rec);

      ПолучитПлатежныеРеквизитыПоТО(rq, rqacc);

      PayerDPNode = 0;
      ReceiverDPNode = 0;

      if(rq.rec.Kind == DLRQ_KIND_COMMIT) //обязательство контрагента
        if((ПолучитьСчетПоПлатежнымРеквизитам(rqacc, AccountBuff) == 0) and (FindDEPOACNTbyBriefCode( AccountBuff.rec.Account, iNumDprt, dpacnt )))
          PayerDPNode = dpacnt.AutoKey;
        end;
      else
        if((ПолучитьСчетПоПлатежнымРеквизитам(rqacc, AccountBuff) == 0) and (FindDEPOACNTbyBriefCode( AccountBuff.rec.Account, iNumDprt, dpacnt )))
          ReceiverDPNode = dpacnt.AutoKey;
        end;
      end;

      /*Шаг 3. Отфильтровываем все лишнее */
      if( Confirm( PayerDPNode,    iAccKind, iDeponent, iDepoPart ) or  //Счет в ТО совпадает
          Confirm( ReceiverDPNode, iAccKind, iDeponent, iDepoPart )
        )

        /*Шаг 4. Выполним разноску по субсчетам и заполним временный файл */
        FillTempTableRQ( rq, PayerDPNode, ReceiverDPNode, int(rsd.GenFIID), iDepoAcc, iDepoPart, NULL, NULL );
      end;

      if( (iDeponent == {OurBank}) and (ПолучитьТипСчетаПоНазначению(iDepoAcc, Type) == 0) and (Type == OBJTYPE_DEPOKINDTYPE_DEPONENT) and (int(rsd.DealClientID) == -1) //Собственные сделки, если указан счет нашего банка в параметрах запуска
        )
        if(rq.rec.Kind == DLRQ_KIND_COMMIT) //обязательство контрагента
          ReceiverDPNode = iDepoAcc;
        else
          PayerDPNode = iDepoAcc;
        end;

        /*Шаг 4. Выполним разноску по субсчетам и заполним временный файл */
        FillTempTableRQ( rq, PayerDPNode, ReceiverDPNode, int(rsd.GenFIID), iDepoAcc, iDepoPart, NULL, NULL );
      end;

      if( (iAccKind == SIDEBALANCE_ACTIVE) and (rqacc.rec.ID == 0) and (int(rsd.CntDraft) == 0))
        if(rq.rec.Kind == DLRQ_KIND_COMMIT) //обязательство контрагента
          ReceiverDPNode = iDepoAcc;
        else
          PayerDPNode = iDepoAcc;
        end;

        /*Шаг 4. Выполним разноску по субсчетам и заполним временный файл */
        FillTempTableRQ( rq, PayerDPNode, ReceiverDPNode, int(rsd.GenFIID), iDepoAcc, iDepoPart, NULL, NULL );
      end;

      progress.Use();
    end;
    progress.Remove();

  end;

  /* Выполним дозаполнение группирующими абсолютными позициями */
  AddFillTable(iAccKind);

  /*Печатаем отчет*/
  PrintReport(iFIGen, iFI, iIsGenFIID, iDeponent, iShowDeponent, iShowPaym, iAccKind);

  /*- DP_AddProtocol(Rep, "protocol");  //добавим протокол к уже сформированному отчету
    - DP_EndProtocol();                 //закончить протоколирование
    Вызываются в фун-и PrintReport()
  */

end;
