import  dlcontrfunc;
import "fm_util.mac";
import "or_rep_h.mac";
import Календарь;

private var Rep;

/**
 @brief Первый вызов. Создание шапки отчета, определение класса отчета CMakeReport
*/
MACRO First_Call()

  var StrHeader:string =
                                                                                                                              
"┌─────────────────────────┬─────────────────────┬──────────────┬──────────────────────┬─────────────────┬───────────────────────────────────┬─────────────────────────────────┬────────────────────────────────────┬───────────────────────────────────────────────┬─────────────────────┬──────────────┐\n"+
"│ Номер счета             │ ФИО клиента по счету│ Валюта счета │Остаток               │Наличие оборотов │ Номер договора                    │ наименование счета до изменения │ наименование счета после изменения │ Номер ДБО по которому открывается новый счет  │ номер нового счета  │ Тип клиента  │\n"+
"├─────────────────────────┼─────────────────────┼──────────────┼──────────────────────┼─────────────────┼───────────────────────────────────┬─────────────────────────────────┬────────────────────────────────────┬───────────────────────────────────────────────┬─────────────────────┬──────────────┤";

  /* Создадим объект класса CMakeReport */
  Rep = CMakeReport(StrHeader);

END;

/**
 @brief Циклический вызов макроса, для формирования таблицы с данным
 @param[in] Account Номер счета
 @param[in] ClientName ФИО клиента по счету
 @param[in] Ccy Валюта счета	
 @param[in] Rest Остаток
 @param[in] Turnover Наличие оборотов	
 @param[in] RigthNmuber Номер договора	
 @param[in] BeforeNameAccount Наименование счета до изменения	
 @param[in] AfterNameAccount Наименование счета после изменения	
 @param[in] WrongNumber Номер ДБО по которому открывается новый счет	
 @param[in] NewAccount Номер нового счета	
 @param[in] TypeClient Тип клиента
*/
MACRO PrintLine_Alg(Account, ClientName, Ccy, Rest, Turnover, RigthNmuber, BeforeNameAccount, AfterNameAccount, WrongNumber, NewAccount, TypeClient)

  Rep.AddPrintCell(Account);
  Rep.AddPrintCell(ClientName);
  Rep.AddPrintCell(Ccy);
  Rep.AddPrintCell(Rest);
  Rep.AddPrintCell(Turnover);
  Rep.AddPrintCell(RigthNmuber);
  Rep.AddPrintCell(BeforeNameAccount);
  Rep.AddPrintCell(AfterNameAccount);
  Rep.AddPrintCell(WrongNumber);
  Rep.AddPrintCell(NewAccount);
  Rep.AddPrintCell(TypeClient);
  Rep.AddStr();

END;

/**
 @brief Последний вызов макроса для печати и визуализации отчета
*/
MACRO Last_Call()

  /* Печатаем, только если есть хоть одна запись */
  if(Rep.IsDataExist())
     Rep.PrintRep();
     /* Печатаем отчет в Excel */
     Rep.PrintWinRep(1, "Sheet"); 
     /* Делаем окно с Excel активным */
     Rep.ShowWinRep();   
  end;
END;

/**
 @brief Создать ексель файл 
*/
MACRO contentDataReport()
  var  CurrCmd, CurrData, typeClient;
  CurrCmd = DL_RSDCommand("SELECT * FROM DDACCOUNTCORRECTION_TMP order by T_ACCOUNT ");
  CurrData = CurrCmd.Execute();
  First_Call();
    while(CurrData.moveNext())   
        if(СубъектЮЛ_ИП(CurrData.t_wrongclientid))
          typeClient = "ЮЛ";
        else
          typeClient = "ФЛ";
        end;
        
        PrintLine_Alg(CurrData.ACCOUNT, 
                      CurrData.RIGHTCLIENTNAME, 
                      CurrData.CCYACC, 
                      CurrData.REST, 
                      CurrData.TURNOVER, 
                      CurrData.RIGHTROOTNUMBER, 
                      CurrData.BEFORENAMEACCOUNT, 
                      CurrData.AFTERNAMEACCOUNT, 
                      CurrData.WRONGSUBNUMBER, 
                      CurrData.NEWACCOUNT,
                      typeClient);  
    end;

    Rep.AddPrintCell("* - Такие счета получаются по текущему принципу автоматического открытия счетов, так как по данному договору уже есть правильные счета с таким окончанием счета в других валютах");
    Rep.AddStr();
    Rep.AddPrintCell("** - Не удается автоматически открыть новый счет( формируемый счет закрыт)");
    Rep.AddStr();
    Rep.AddPrintCell("*** - Счет не открыт. Договор обслуживания закрыт");
    Rep.AddStr();
    Rep.AddPrintCell("**** - Счет в Юанях не открыт. Договор обслуживания принадлежит ЮЛ  и по этому договору нет открытого счета 306* в Юанях");
    
  Last_Call();
end;


/**
 @brief Обновить временную таблицу, поле t_newaccount - новый номер счета для неверного субдоговора
 @param[in] NewAccount новый номер счета
 @param[in] Account прежний номер счета, к которму было привязано, используется как некий первичный ключ
 @param[in] Currency валюта счета
*/
MACRO updateNewAccount(NewAccount:String,Account:String,Currency:integer)

    var sql,cmdnew;
   
    sql =   "  update DDACCOUNTCORRECTION_TMP d "
          + "     set d.t_newaccount = :newaccount "
          + "   where d.t_account = :account "
          + "     and d.t_currencyacc = :currency";
    cmdnew = RSDCommand(sql);

      
   cmdnew.AddParam("newaccount", RSDBP_IN, NewAccount);
   cmdnew.AddParam("account", RSDBP_IN, Account);
   cmdnew.AddParam("currency", RSDBP_IN, Currency);

   cmdnew.Execute();
  
end;

/**
 @brief Открыть новый аккаунт для неверно привязанного субдоговора
 @param[in] Account_ номер счета
 @param[in] PartyId ИД клиента 
 @param[in] SubContrId ИД субдоговора
 @param[in] DateBegin дата открытия договора 
 @param[in] Currency ИД валюты
*/
MACRO openAccount(Account_, PartyId, SubContrId, DateBegin, Currency)
    var BackOutAccount = false, ChangeOpenDate  = false, IsMass = 1;
    var sql:String,cmd,rs;
    record AccBuf( account );
    ClearRecord(AccBuf);
    var FindAccount:string = "";
    var vOpenDate:date; 
    var CatCode:String = "+РасчетыКомисс1";
    var accountOpenCNY = true;

  
  if(СубъектЮЛ_ИП(partyId))
   vOpenDate = {curdate};

    //Если валюта Юань
    if(Currency == 11)
      sql =
            " WITH cat AS ( SELECT t_ID FROM dmccateg_dbt WHERE  t_Code = 'ДС клиента, ц/б' )  "
          + "         SELECT count(*) as cnt  "
          + "           FROM dmcaccdoc_dbt mc, daccount_dbt acc, dsfcontr_dbt sf, cat "
          + "          WHERE mc.t_CatID = cat.t_ID "
          + "            AND mc.t_iscommon = 'X' "
          + "            AND mc.t_Owner = sf.t_PartyID  "
          + "            AND mc.t_ClientContrID = sf.t_ID  "
          + "            AND acc.t_Account = mc.t_Account  "
          + "            AND acc.t_Chapter = mc.t_Chapter  "
          + "            AND acc.t_Code_Currency = mc.t_Currency  "
          + "            AND acc.t_Code_Currency = 11 "
          + "            AND sf.t_id = :contr "
          + "            AND mc.t_Owner = :client "
          + "            AND acc.t_Open_Date <= SYSDATE  "
          + "            AND acc.t_Close_Date = TO_DATE('01.01.0001','DD.MM.YYYY') ";


          cmd = RsdCommand(sql);
          cmd.addParam( "contr" ,  RSDBP_IN, SubContrId);
          cmd.addParam( "client" , RSDBP_IN, PartyId);

          cmd.execute();
          rs = RsdRecordset(cmd); 

          if (rs and rs.MoveNext())
             //Если нет счетов открытых 306*, то запоминаем
              if(rs.value(0) == 0)
                accountOpenCNY = false;
              end; 
          end;
    end;
  else
    sql =
      "  declare " +
      "  begin " +
      "   ?:= RSB_CORRECT_ACCOUNT.getNextCurDate(?, ?);  " + 
      "  end; ";

    cmd = RsdCommand(sql);
    cmd.addParam( "OutDate",  RSDBP_OUT, V_DATE);
    cmd.addParam( "Date" ,    RSDBP_IN, DateBegin);
    cmd.addParam( "Branch" ,  RSDBP_IN, int({OperDprt}));
    cmd.execute();
    vOpenDate  = cmd.value("OutDate");
  end;

  if(accountOpenCNY)
    var FD = DL_SubContrFD(subContrId);
    MC_GetAccountOpenParms( CatCode, @BackOutAccount, @ChangeOpenDate );

    FindAccount = MC_FindAndOpenAccount (
          CatCode,
          FD,
          {curdate},
          IsMass, 
          MC_OPENACC_CREATE,
          AccBuf,  Currency, NULL, NULL, NULL, FIROLE_BA, NULL, NULL, NULL, NULL, vOpenDate,
          BackOutAccount, 
          ChangeOpenDate 
      );

    cmd = null; 
    //проверить привязку после пересоздания нового счета к прежнему
    sql =
      "   select  count(*) as cnt  " +
      "     FROM dmcaccdoc_dbt d  " +
      "    WHERE d.t_CatID = 818  " +
      "      AND d.t_account = :acc  " +
      "      AND d.t_owner = :party " +
      "      AND d.t_clientcontrid = :contr ";
    
    cmd = RsdCommand(sql);
    cmd.addParam( "acc" ,    RSDBP_IN, Account_);
    cmd.addParam( "party" ,  RSDBP_IN, PartyId);
    cmd.addParam( "contr" ,  RSDBP_IN, SubContrId);
    cmd.execute();
    rs = RsdRecordset(cmd); 

    if (rs and rs.MoveNext())
      if(rs.value(0) > 0)
          FindAccount = Account_ + "*";
      end;  
    end;

  else 
   FindAccount = "****";
  end;

  //если ничего не создалось, то скорее всего у клиента уже есть закрытый счет 
  if(FindAccount == "")
    cmd = null; rs = null;
    sql =
        "      SELECT acc.t_account, decode(acc.t_Close_Date,to_date('01010001','ddmmyyyy'),'X') as isOpenAcc "
      + "       FROM dmcaccdoc_dbt mc, daccount_dbt acc, dsfcontr_dbt sf "
      + "      WHERE mc.t_CatID = 818 "
      + "        AND mc.t_iscommon = 'X' "
      + "        AND mc.t_Owner = sf.t_PartyID "
      + "        AND mc.t_ClientContrID = sf.t_ID "
      + "        AND acc.t_Account = mc.t_Account "
      + "        AND acc.t_Chapter = mc.t_Chapter "
      + "        AND acc.t_Code_Currency = mc.t_Currency "
      + "        AND acc.t_Code_Currency = :cur  "
      + "        AND sf.t_id = :contr  "
      + "        AND mc.t_Owner = :client ";


      cmd = RsdCommand(sql);
      cmd.addParam( "cur",     RSDBP_IN, Currency);
      cmd.addParam( "contr" ,  RSDBP_IN, SubContrId);
      cmd.addParam( "client" , RSDBP_IN, PartyId);

      cmd.execute();
      rs = RsdRecordset(cmd); 

      if (rs and rs.MoveNext())
          if((rs.value(0) > 0) and (rs.value(1) == "X"))
            FindAccount = rs.value(0);
	        else 
            FindAccount = "**";
          end;
      end;

  end;


  if(FindAccount != "")
    updateNewAccount(FindAccount,Account_,Currency);
  end;
end;

/**
 @brief Обновление наименования аккаунта. Обновляем в таблицах daccount_dbt и во временной DDACCOUNTCORRECTION_TMP
 @param[in] NameAccount Новое имя аккаунта
 @param[in] Account Номер счета, который следует обновить
*/
MACRO updateNameAccount(NameAccount:String,Account:String)
    
  var sql,cmdaccu;


  sql =    "  update daccount_dbt acc "
         + "     set acc.t_nameaccount = ?  "
         + "   where acc.t_account = ? ";
  cmdaccu = RSDCommand(sql);

      
   cmdaccu.AddParam("nameaccount", RSDBP_IN, NameAccount);
   cmdaccu.AddParam("account", RSDBP_IN, Account);
   cmdaccu.Execute();  

   cmdaccu = NULL;      

  sql =   "  update DDACCOUNTCORRECTION_TMP d "
        + "     set d.T_AFTERNAMEACCOUNT = :nameaccount "
        + "   where d.t_account = :account ";


  cmdaccu = RSDCommand(sql);

      
   cmdaccu.AddParam("nameaccount", RSDBP_IN, NameAccount);
   cmdaccu.AddParam("account", RSDBP_IN, Account);
   cmdaccu.Execute(); 
  
  end;

/**
 @brief Переименование аккаунта для каждого субдоговора
 @param[in] Account номер счета
 @param[in] DLContrID ИД ДБО
 @param[in] ClientName ФИО клиента
 @param[in] UserTypeAcc Пользовательский тип счета 
 @param[in] SfNumber Номер договора 
 @param[in] ContrDate Дата начала действия договора
*/
MACRO renameNameAccount(Account, DLContrID, PartyId, ClientName, UserTypeAcc, SfNumber, ContrDateBegin)
  
  var ЕКК, KindAcc, nameaccount;  
  var cmdSub, dataSub, sql, stat;

  cmdSub = DL_RSDCommand();

  sql =  
         "    with t_sf as "
       + "    (select mc.t_clientcontrid  as sf_id "
       + "      from dmcaccdoc_dbt mc "
       + "      where mc.t_account = ? "
       + "       and mc.t_catid = 818) "
       + " select sf.t_servkindsub,  "
       + "        sf.t_servkind, "
       + "        mp.t_marketid  " 
       + " from ddlcontrmp_dbt mp  left join ddlcontr_dbt dl on dl.t_dlcontrid = mp.t_dlcontrid "
       + "                         left join dsfcontr_dbt sf on sf.t_id = mp.t_sfcontrid "
       + " where dl.t_dlcontrid = ?  "
       + "   and sf.t_id in (select sf_id from t_sf)";

   cmdSub.AddParam(Account);
   cmdSub.AddParam(DLContrID);
  
  dataSub = cmdSub.Execute(sql);

  if(cmdSub.GetCount(sql))
    dataSub = cmdSub.Execute(sql);
    stat = dataSub.moveNext();

    while(stat)

      ЕКК = DL_GetDlObjCodeOnDate(OBJTYPE_BROKERCONTR_DL, DLCCK_USC, DLContrID);

      if(not IsPartyInst(partyId))
        if (index(UserTypeAcc,"Е") > 0)
          KindAcc = "ЕДП";
        elif(dataSub.servkindsub == 9)
          KindAcc = "внебиржевой рынок";
        end;
      else
        if(dataSub.servkindsub == 9)
          KindAcc = "внебиржевой рынок";
        else
            if(dataSub.servkind == 1)
              if(dataSub.MarketID == MMVB_ID())
                KindAcc = "ФР ММВБ";
              elif(dataSub.MarketID == SPB_ID())
                KindAcc = "ФР СПБ";
              end;
            elif(dataSub.servkind == 21)
              KindAcc = "ВР ММВБ";
            elif(dataSub.servkind == 15)
              KindAcc = "СР ММВБ";
            end;
        end;
      end;

      if(KindAcc) 
        KindAcc = " ("+ KindAcc +")";
      else
        KindAcc = "";
      end;


      nameaccount =  "Треб. по брокерским операциям. " + ClientName +" Дог. № "+ SfNumber +" от "+string(ContrDateBegin)+". ЕКК - "+ ЕКК + KindAcc;

      updateNameAccount(nameaccount, Account);	

      stat = dataSub.moveNext();

    end;
  end;
end;

/**
 @brief Проверка на открытие договора
 @param[in] WrongSfId ID неверно приаязанного субдоговора
*/
MACRO isOpenContr(WrongSfId):Integer

var cmdSub, dataSub, sql;

  cmdSub = DL_RSDCommand();

  sql =  
        " SELECT * "
      + "  FROM dsfcontr_dbt d "
      + " WHERE d.t_id  = ? "
      + "   AND d.t_dateclose = to_date('01010001','ddmmyyyy') ";

  cmdSub.AddParam(WrongSfId);
  
  dataSub = cmdSub.Execute(sql);

  if(cmdSub.GetCount(sql))
    return 1;
  end;

  return 0;

END;

/**
 @brief Удаление неправильных привязок в категориях ЛС
 @param[in] Account Номер счета по которому требуется изменение
 @param[in] WrongClinetId ИД клиента, который неверно привязан к данному счету 
 @param[in] SubContr ИД неверного субдоговора
*/
MACRO deleteMcAcc(Account, WrongClinetId, SubContr)

  var sql,cmdMc;

  sql =    " DELETE FROM dmcaccdoc_dbt d "
         + "  WHERE d.t_CatID = 818 "
         + "    AND d.t_account = ? "
         + "    AND d.t_owner = ?"
         + "    AND d.t_clientcontrid = ? ";


  cmdMc = RSDCommand(sql);
 
  
  cmdMc.AddParam("account", RSDBP_IN, Account);
  cmdMc.AddParam("wrongclient", RSDBP_IN, WrongClinetId);
  cmdMc.AddParam("clientcontr", RSDBP_IN, SubContr);
  cmdMc.Execute();  

END;

 /**
 @brief Основная процедура для запуска корректировки счетов
*/
MACRO MainCorrectAcc()

 var sql:String,
     query:String,
     errMsg:String,
     exec;
  var cmd, DataSet;
  var cnt:integer = 0, i:integer = 0;

  InitProgress(-1, "Отбор некорректных счетов", "Отбор счетов, привязанных к нескольким договорам"); 
  sql =  "DECLARE "
         + "BEGIN "
         + "    rsb_correct_account.CreateActiveAcc; "
         + "END; ";

  exec = DL_RSDCommand(sql);
  exec.ExecuteCMD();
  RemProgress();

  query = "select * from DDACCOUNTCORRECTION_TMP order by T_ACCOUNT ";
  cmd = DL_RSDCommand();
  cnt = cmd.GetCount(query);
   
  if(cnt > 0)
    InitProgress(cnt, "Корректировка отобранных счетов", "Выполнение мероприятий по корректировке отобранных счетов");
    DataSet = cmd.Execute(query) ;
    while(DataSet.moveNext())
      if(Dataset.rest == 0)
        renameNameAccount(DataSet.account,
                          DataSet.RIGHTDLCONTRID, 
                          DataSet.rightclientid, 
                          DataSet.rightclientname, 
                          DataSet.usertypeaccount, 
                          DataSet.RIGHTROOTNUMBER, 
                          DataSet.RIGHTROOTDATEBEGIN);

        deleteMcAcc(DataSet.account, DataSet.WRONGCLIENTID, DataSet.WRONGSFID);

        if(isOpenContr(DataSet.WRONGSFID) == 1)
          openAccount(DataSet.account, 
                      DataSet.WRONGCLIENTID,
                      DataSet.WRONGSFID,
                      DataSet.WRONGROOTDATEBEGIN, 
                      DataSet.CURRENCYACC);
        else
          updateNewAccount("***",DataSet.account,DataSet.CURRENCYACC);
        end;   
      end;        
      UseProgress(i = i + 1);
    end;
    RemProgress();
  end; 

  InitProgress(-1, "Формирование протокола", "Формирование протокола работы процедуры корректировки"); 
  contentDataReport();
  RemProgress();

 onError(erru)
    errMsg = "onError: " + erru.message + " (модуль " + erru.module + ", строка " + erru.line + ")";
    msgbox(errMsg);
    RemProgress();                                                           
end; 

MainCorrectAcc();
