/*
$Name:        dvOperSt.mac
$Module:      ФИСС и КО
$Description: Функции шагов операции расчетов
*/
import InsCarryDoc, DVInter, "dvserv.mac", "dv_fun.mac", "dv_carop.mac", "dv_comiss.mac";

PRIVATE MACRO SayError( StrErr:string ):integer
  if( StrErr )
     MsgBox( StrErr );
  end;
  RemProgress();
  return 0;
END;

macro ВыполнитьРасчетИтоговыхCуммПоПозиции( oper/*RECORD DVOPER*/ ):integer

  record party(party);
  record pos(dvfipos);

  var turn:variant;
  var FD_Pos:DVFirstDocPos;
  var Count:integer;
  var Query:string = "", QueryDeal:string = "", Data:variant, DealByPos:variant, cmd2:variant, T:variant;
  var СС_н:money = $0, ССп:money = $0, ССи:money = $0, v_Netto:money = $0;
  var v_BuySum:money = $0, v_SaleSum:money = $0;
  var v_CalcFairValue:integer = 0;
  var P:double = 0.0, Pп:double = 0.0, CourseKind:integer = -1, PFI:integer = 0;
  var VM:money = $0, Sd:money = $0, Рpr:double = 0.0;
  var ExecDealPrice:money = $0, Nе:money = $0, ExecDealPosition:integer = 0, Ve:money = $0;
  var Pstep:double = 1.0, Pstep_NatCur:double = 1.0, R:double = 1.0;
  var Пl:money = $0, Пs:money = $0, Пlpr:money = $0, Пspr:money = $0;
  var Sс:money = $0, Spr:money = $0, Pc:double = 0.0, Ppr:double = 0.0;
  var v_CalcSum:integer;
  var v_BuyCost:money = $0, v_SaleCost:money = $0;
  var RunFromTRUST = false; /*операция ДУ*/
  var SinceDateP:date = Date(0,0,0);

  var РасчетИтоговыхСуммСделокПИ:integer = ВыполнятьРасчетИтоговыхСумм(oper.Party);

  if( oper.DocKind == DL_DVOPER_TRUST )
     RunFromTRUST = true;
  end;

  Query = "SELECT T_ID FROM ddvfipos_dbt POS WHERE T_STATE != " + String(DVPOS_CLOSE) + " AND " + PositionOpenOnOperationDate( oper );

  Data  = TRsbDataSet(Query);      
  if( Data )           

     Count = 0;
     InitProgress( SQL_GetNRecs( Query ), "Расчет итоговых сумм по позициям", "Выполнение..." );

     while( Data.MoveNext() )

        UseProgress(Count = Count + 1);

        VM = $0;
        v_CalcFairValue = 0;

        FD_Pos = DVFirstDocPos(DL_DVFIPOS, Data.ID);
        copy(pos, FD_Pos.DVPos);

        Pstep = 1.0;
        if( FD_Pos.Fideriv.rec.PriceMode == DERIVATIVE_MODE_TICKFI )
           /* Получим значение курса вида "Стоимость минимального шага цены" на день операции */
           Pstep = DV_TickCost(FD_Pos.FI.rec.FIID, oper.Date);
           if( Pstep <= 0.0 )
              SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FD_Pos.FI.rec.FI_Code + " на дату: " + string(oper.Date));
              return 1;
           end;

           /* Сконвертируем Pstep в национальную валюту */
           if( FD_Pos.FI.rec.ParentFI != NATCUR )
              if( NOT DV_SmartConvertSum(Pstep_NatCur, money(Pstep), oper.Date, FD_Pos.FI.rec.ParentFI, NATCUR) )
                 SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(FD_Pos.FI.rec.ParentFI) + " в рубли на дату " + String(oper.Date) );
                 return 1;
              end;
           else
              Pstep_NatCur = Pstep;
           end;
        end;

        if( РасчетИтоговыхСуммСделокПИ == 1 )

           /*вычисление вариационной маржи для ПИ*/
           VM = $0;

           if( ( FD_Pos.FI.rec.AvoirKind == DERIVATIVE_FUTURES ) and 
               ( FD_Pos.Fideriv.rec.PriceMode == DERIVATIVE_MODE_TICKFI ) )

              /* минимальный шаг цены FIID->DFIDERIV.T_TICK */
              if( FD_Pos.fideriv.rec.Tick > 0 )
                 R = FD_Pos.fideriv.rec.Tick;
              else
                 R = 1.;
              end;

              /*на дату операции есть сделка исполнения фьючерсного контракта*/
              if( ПолучитьОперациюИсполненияПоПозиции( oper.Date, pos, @ExecDealPrice, @Nе, @ExecDealPosition, @Ve ) == true )
                 /*
                  VM = Ve - Рpr * Nе * Pstep /R, где
                  -  Ve = DDVDEAL.T_POSITIONCOST  
                  -  Nе - количество исполненных контрактов DDVDEAL.T_AMOUNT
                  -  Рpr - значение курса вида "Расчетная цена" фьючерса по позиции T_FIID за день, предшествующий дню операции (должен быть задан),
                  -  Pstep - стоимость минимального шага цены DV_TickCost инструмента  T_FIID за день операции (должен быть задан),
                  -  R -минимальный шаг цены FIID-> DFIDERIV.T_TICK,
                 */
                 SinceDateP = Date(0,0,0);
                 Рpr = 0.0;
                 if( (ПолучитьКурсЗаданногоTипа(@Рpr, FD_Pos.FI.rec.FIID, FD_Pos.Fideriv.rec.TickFIID, RATETYPE_CALC_PRICE, oper.Date-1, true, @SinceDateP) == false) or (Рpr <= 0.0) )
                    SayError("Не задан курс \"Расчетная цена\" | для фьючерса " + FD_Pos.FI.rec.FI_Code + " на дату: " + string(oper.Date-1) );
                    return 1;
                 end;

                 VM = Money( Round( (Ve - Рpr * Nе * Pstep / R), 2 ) );
                 /*если позиция короткая - берем с минусом*/   
                 if( ExecDealPosition == DV_POSITION_SHORT ) /*короткая*/
                    VM = -VM;   
                 end;
              else
                 /*вычислим маржу по сделкам*/
                 Sd = ПосчитатьМаржуПоСделкамПозиции( oper.Date, pos );  

                 /*
                 "  Sс = (Пl - Пs) * Pc * Pstep / R, округлив до 2 знаков:
                 "  Spr = (Пlpr - Пspr) * Ppr * Pstep / R, округлив до 2 знаков
                 "  VМ = Sс - Spr + Sd
                 */
                 if( ПолучитьИтогиПоПозицииНаДату( pos, oper.Date, @turn, " <= "  ) == true )
                    Пs =  turn.ShortPosition;
                    Пl =  turn.LongPosition;
                 else
                    Пs = Пl = $0;
                 end;      

                 if( ПолучитьИтогиПоПозицииНаДату( pos, oper.Date, @turn, " < "  ) == true )
                    Пspr =  turn.ShortPosition;
                    Пlpr =  turn.LongPosition;                       
                 else
                    Пspr = Пlpr = $0;
                 end;

                 SinceDateP = Date(0,0,0);
                 Pc = 0.0;
                 /*Получим курс "Расчетная цена" для фьючерса на день операции*/
                 if( (ПолучитьКурсЗаданногоTипа(@Pc, FD_Pos.FI.rec.FIID, FD_Pos.Fideriv.rec.TickFIID, RATETYPE_CALC_PRICE, oper.Date, true, @SinceDateP) == false) or (Pc <= 0.0) )
                    SayError("Не задан курс \"Расчетная цена\" | для фьючерса " + FD_Pos.FI.rec.FI_Code + " на дату: " + string(oper.Date) );
                    return 1;
                 end;

                 if( Пlpr != Пspr )
                    SinceDateP = Date(0,0,0);
                    Ppr = 0.0;
                    /*Получим курс "Расчетная цена" для фьючерса на предыдущий день*/
                    if( (ПолучитьКурсЗаданногоTипа(@Ppr, FD_Pos.FI.rec.FIID, FD_Pos.Fideriv.rec.TickFIID, RATETYPE_CALC_PRICE,oper.Date-1, true, @SinceDateP) == false) or (Ppr <= 0.0) )
                       SayError("Не задан курс \"Расчетная цена\" | для фьючерса " + FD_Pos.FI.rec.FI_Code + " на дату: " + string(oper.Date-1) );
                       return 1;
                    end;
                 else
                    Ppr = 0.0;
                 end;

                 Sс  = Money( Round( ((Пl - Пs) * Pc * Pstep / R), 2 ) );
                 Spr = Money( Round( ((Пlpr - Пspr) * Ppr * Pstep / R), 2 ) );
                 VM = Sс - Spr + Sd;
              end;
           end;   
        end;

        /* расчет СС для не ДУ */
        if( (RunFromTRUST == false) and (pos.Client == -1) )
/*           if( FD_Pos.PositionByFutures() ) !!! Не удалять. Формулы перенесут во вторую очередь реализации  
              CourseKind = ВИД_КУРСА_ДЛЯ_ОЦЕНКИ_СС_ФЬЮЧЕРСА();
              PFI = FD_Pos.Fideriv.rec.TickFIID;
           else
              CourseKind = ВИД_КУРСА_ДЛЯ_ОЦЕНКИ_СС_ОПЦИОНА();
              PFI = FD_Pos.Fideriv.rec.StrikeFIID;
           end;

           SinceDateP = Date(0,0,0);
           P = 0.0;
           if( ПолучитьКурсЗаданногоTипа(@P, FD_Pos.FI.rec.FIID, PFI, CourseKind, oper.Date, true, @SinceDateP) and (P > 0.0) )/* курс, действующий на дату <= */
              v_CalcFairValue = 1;

              QueryDeal = "SELECT NVL(SUM(DEAL.T_POSITIONCOST), 0) BuySum FROM ddvdeal_dbt DEAL WHERE " + 
                          DealByPosition( pos ) + 
                          " AND DEAL.T_DATE = " + GetSQLDate(oper.Date) + " AND DEAL.T_TYPE = 'B';";
              DealByPos = TRsbDataSet(QueryDeal);
              if( DealByPos.MoveNext() )
                 v_BuySum = money(DealByPos.BuySum);
              else
                 v_BuySum = $0;
              end;

              QueryDeal = "SELECT NVL(SUM(DEAL.T_POSITIONCOST), 0) SaleSum FROM ddvdeal_dbt DEAL WHERE " + 
                          DealByPosition( pos ) + 
                          " AND DEAL.T_DATE = " + GetSQLDate(oper.Date) + " AND DEAL.T_TYPE = 'S';";
              DealByPos = TRsbDataSet(QueryDeal);
              if( DealByPos.MoveNext() )
                 v_SaleSum = money(DealByPos.SaleSum);
              else
                 v_SaleSum = $0;
              end;

              /* переведём v_BuySum и v_SaleSum из валюты стоимости позиции(ParentFI) в национальную */
              if( FD_Pos.FI.rec.ParentFI != NATCUR )
                 if( NOT DV_SmartConvertSum(v_BuySum, v_BuySum, oper.Date, FD_Pos.FI.rec.ParentFI, NATCUR) )
                    SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(FD_Pos.FI.rec.ParentFI) + " в рубли на дату " + String(oper.Date) );
                    return 1;
                 end;

                 if( NOT DV_SmartConvertSum(v_SaleSum, v_SaleSum, oper.Date, FD_Pos.FI.rec.ParentFI, NATCUR) )
                    SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(FD_Pos.FI.rec.ParentFI) + " в рубли на дату " + String(oper.Date) );
                    return 1;
                 end;
              end;

              cmd2 = RsdCommand( "SELECT TURN.* " +
                                   "FROM ddvfiturn_dbt TURN " +
                                  "WHERE " + TurnByPosition( Pos, null, null ) + 
                                   " AND TURN.T_DATE = " + GetSQLDate(oper.Date));

              cmd2.execute();
              T = TRsbDataSet(cmd2);

              if( T.MoveNext() )
                 if( FD_Pos.Fideriv.rec.PriceMode == DERIVATIVE_MODE_TICKFI )
                    v_BuyCost  = P * money(T.Buy)  * /*Pstep*/Pstep_NatCur / FD_Pos.fideriv.rec.Tick;
                    v_SaleCost = P * money(T.Sale) * /*Pstep*/Pstep_NatCur / FD_Pos.fideriv.rec.Tick;
                 else
                    v_BuyCost  = P * money(T.Buy);
                    v_SaleCost = P * money(T.Sale);
                 end;
              else
                 v_BuyCost  = $0;
                 v_SaleCost = $0;
              end;

              ССп = v_BuyCost - v_BuySum - v_SaleCost + v_SaleSum;

              cmd2 = RsdCommand( "SELECT max(TURN.t_Date) PrevDate " +
                                   "FROM ddvfiturn_dbt TURN " +
                                  "WHERE " + TurnByPosition( Pos, null, null ) + 
                                   " AND TURN.T_FAIRVALUECALC = 'X' " );

              cmd2.execute();
              T = TRsbDataSet(cmd2);

              if( T.MoveNext() and (T.PrevDate != NULL) )
                 SinceDateP = Date(0,0,0);
                 if( (ПолучитьКурсЗаданногоTипа( @Pп, FD_Pos.FI.rec.FIID, PFI, CourseKind, Date(T.PrevDate), true, @SinceDateP ) == false) or (Pп <= 0.0) )
                    Pп = 0.0;
                    var DvKind:string = "";
                    if (FD_Pos.PositionByFutures())
                       DvKind = "фьючерса";
                    else
                       DvKind = "опциона";
                    end;
                    SayError("Не задан курс вида \"Для оценки СС " + DvKind + "\" | для " + DvKind + " " + FD_Pos.FI.rec.FI_Code + " на дату: " + string(Date(T.PrevDate)) );
                    return 1;
                 end;
              else
                 Pп = 0.0;
              end;

              cmd2 = RsdCommand( "SELECT * " +
                                   "FROM ddvfiturn_dbt TURN " +
                                  "WHERE " + TurnByPosition( Pos, null, null ) + 
                                   " AND TURN.T_DATE < " + GetSQLDate(oper.Date) +
                                 " ORDER BY TURN.T_DATE DESC "
                               );

              cmd2.execute();
              T = TRsbDataSet(cmd2);

              if( T.MoveNext() )
                 v_Netto = money(T.LONGPOSITION) - money(T.SHORTPOSITION);
              else
                 v_Netto = $0;
              end;

              if( FD_Pos.Fideriv.rec.PriceMode == DERIVATIVE_MODE_TICKFI )
                 ССи = (P - Pп) * v_Netto * /*Pstep*/Pstep_NatCur / FD_Pos.fideriv.rec.Tick;
              else
                 ССи = (P - Pп) * v_Netto;
              end;

              СС_н = ССи + ССп;
/*
              if( PFI != NATCUR )
                 if( NOT DV_SmartConvertSum( СС_н, СС_н, oper.Date, PFI, NATCUR ) )
                    SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(PFI) + " в рубли сумму переоценки на дату " + String(oper.Date) );
                    return 1;
                 end;
              end;
*/
              СС_н = money(round(СС_н, 2));
           end;*/
           СС_н = VM;
           v_CalcFairValue = IIF(СС_н == 0, 0, 1);
        end;

        if( (VM != $0) OR (v_CalcFairValue == 1) )
           v_CalcSum = IIF( (VM != $0), 1, 0 ); //1 = да

           /*if( FD_Pos.PositionByOption() and (FD_Pos.GetFITurnOnDate(@turn,"MAX",oper.Date) == true) )
              if( ((СС_н > 0) and ((turn.LongPosition - turn.ShortPosition) < 0)) or
                  ((СС_н < 0) and ((turn.LongPosition - turn.ShortPosition) > 0))
                )
                 СС_н = 0;
              end;
           end;*/

           /* Выполнить DV_CalcPositionTurn */
           if( OprInsertPositionTurn( FD_Pos.DVPos, oper.Date, VM, СС_н, v_CalcSum, v_CalcFairValue ) == false )
              return 1;
           end;
        end;
     end;

     RemProgress();
  end;

  return 0;
end;

PRIVATE MACRO IsBuy( Type:string ):bool
  return ((Type == "B") OR (Type == "D"));
END;

PRIVATE MACRO IsSale( Type:string ):bool
  return ((Type == "S") OR (Type == "G"));
END;

MACRO InsertServActionInfo(DocKind, DocID, Action, ActionDate)
    VAR ins = RSDCommand("INSERT INTO DDLSERVACTION_TMP (t_DocKind, t_DocID, t_Action, t_ActionDate) VALUES (?,?,?,?)");
    ins.addParam("", RSDBP_IN, DocKind);
    ins.addParam("", RSDBP_IN, DocID);
    ins.addParam("", RSDBP_IN, Action);
    ins.addParam("", RSDBP_IN, ActionDate);
    ins.execute();
END;

MACRO ClearServActionInfo()
    RSDCommand("TRUNCATE TABLE DDLSERVACTION_TMP").execute();
END;

macro ВыполнитьРаспределениеМаржиПоСделкам( oper/*RECORD DVOPER*/ ):integer
  if (oper.flag1 != ALG_SP_MONEY_SOURCE_OWN)// по клиентским сделкам не делаем распределенеие сумм. будем одной общей суммой разносить.
    return 0;
  end;
  var Query, Data;
  var CmdSum, DataSum;
  var Count:integer = 0;
  var VM:money = $0;

  Query = " SELECT DEAL.t_ID, DEAL.t_FIID, DEAL.t_Date, DEAL.t_Type, DEAL.t_Client, DEAL.t_DealCost as DDealCost, DEAL.t_Amount, " +
          "        DEAL.t_Department, DEAL.t_Broker, DEAL.t_ClientContr, DEAL.t_GenAgrID, DEAL.t_Type," +    
          "        DEAL.t_Execution, DEAL.t_DealCost, FITURN.t_MarginDay " +
          "   FROM ddvdeal_dbt DEAL, ddvfiturn_dbt FITURN " +
          "  WHERE " + DealByOperation(oper) +
          "    AND EXISTS ( Select * from ddvdlturn_dbt TURN WHERE TURN.t_DealID = DEAL.t_ID AND TURN.t_Date < " + GetSQLDate(Oper.Date) + ") "+
          "    AND DEAL.t_State = " + string(DVDEAL_OPEN) +
          "    AND FITURN.t_FIID = DEAL.t_FIID " +
          "    AND FITURN.t_Department = DEAL.t_Department " +
          "    AND FITURN.t_Broker = DEAL.t_Broker " +
          "    AND FITURN.t_ClientContr = DEAL.t_ClientContr " +
          "    AND FITURN.t_GenAgrID = DEAL.t_GenAgrID " +
          "    AND FITURN.T_MARGINDAY <> 0 " +
          "    AND FITURN.t_Date = " + GetSQLDate(Oper.Date) +
          "    AND DEAL.t_Type in('B', 'S', 'D', 'G')";

  Data = TRsbDataSet(Query);

  InitProgress( SQL_GetNRecs(Query), "Распределение маржи по сделкам", "Выполнение..." );
  while( Data.MoveNext() )
     VM = Data.MarginDay * (Data.Amount - Data.Execution);
     if(VM == 0)
        continue;
     end;

     cmdSum = RsdCommand( " SELECT Sum (DEAL.t_Amount - DEAL.t_Execution) as TurnSum " +
                          "   FROM ddvdeal_dbt DEAL " +
                          "  WHERE " + DealByOperation(oper) +
                          "    AND EXISTS ( Select * from ddvdlturn_dbt TURN WHERE TURN.t_DealID = DEAL.t_ID AND TURN.t_Date < " + GetSQLDate(Oper.Date) + ") "+
                          "    AND DEAL.t_State = " + string(DVDEAL_OPEN) +
                          "    AND DEAL.t_FIID = ? " +
                          "    AND DEAL.t_Department = ? " +
                          "    AND DEAL.t_Broker = ? " +
                          "    AND DEAL.t_ClientContr = ? " +
                          "    AND DEAL.t_GenAgrID = ? " +
                          "    AND DEAL.t_Type in('B', 'S', 'D', 'G')");

     cmdSum.addParam("", RSDBP_IN, Data.FIID);
     cmdSum.addParam("", RSDBP_IN, Data.Department);
     cmdSum.addParam("", RSDBP_IN, Data.Broker);
     cmdSum.addParam("", RSDBP_IN, Data.ClientContr);
     cmdSum.addParam("", RSDBP_IN, Data.GenAgrID);
     cmdSum.execute();

     DataSum = TRsbDataSet(cmdSum);
     if( DataSum.MoveNext() )
        if(DataSum.TurnSum == 0)
           continue;
        else
           VM = VM / DataSum.TurnSum;
        end;
        if ( DV_CalcDealTurn(Data.ID, oper.Date, VM, VM, 1, 1, DV_ACTION_DISTRIBITOG) != 0 )
        // if( DV_CalcDealTurn(Data.ID, oper.Date, VM, 0, 1, 0) != 0 ) TEG  пока сделаем так как было у нас
           return 1;
        end;
     else
        return 1;
     end;

     UseProgress(Count = Count + 1);
  end;

  RemProgress();
  return 0;
end;

// Изменение итогов по сделке за день.
MACRO DV_GuarantDealTurn( DealID, DealDate, Guaranty, Action ):INTEGER
  VAR cmd = RsdCommand( "{ CALL Rsb_Derivatives.RSI_DV_GuarantDealTurn(?,?,?,?) }" );
  cmd.addParam( "", RSDBP_IN, DealID );
  cmd.addParam( "", RSDBP_IN, DealDate );
  cmd.addParam( "", RSDBP_IN, Guaranty );
  cmd.addParam( "", RSDBP_IN, Action );
  SQL_Execute( cmd, "Изменение гарантийного обеспечения по сделке", true );
  return 0;
ONERROR
  return 1;
END;

macro ВыполнитьРаспределениеГарОбеспечПоСделкам( oper/*RECORD DVOPER*/ ):integer
  if (oper.flag1 != ALG_SP_MONEY_SOURCE_CLIENT)// выполняем распределенеие гар.обеспечения только для клиентских
    return 0;
  end;
  var Query, Data;
  var CmdSum, DataSum;
  var Count:integer = 0;
  var VM:money = $0;
  Query = " SELECT DEAL.t_ID, DEAL.t_FIID, DEAL.t_Date, DEAL.t_Type, DEAL.t_Client,DEAL.t_Amount, " +
          "        DEAL.t_Department, DEAL.t_Broker, DEAL.t_ClientContr, DEAL.t_GenAgrID, DEAL.t_Type," +    
          "        CASE WHEN DEAL.t_Execution = DEAL.t_Amount THEN NVL((SELECT Exec FROM (SELECT turn.t_Execution Exec FROM DDVDLTURN_DBT turn WHERE turn.T_DEALID = DEAL.t_ID AND turn.T_DATE < DEAL.t_Date ORDER BY turn.T_DATE) WHERE ROWNUM = 1),0) ELSE DEAL.t_Execution end Execution, FITURN.T_GUARANTY " +
          "   FROM ddvdeal_dbt DEAL, ddvfiturn_dbt FITURN " +
          "  WHERE " + DealByOperation(oper) +
          "    AND EXISTS ( Select * from ddvdlturn_dbt TURN WHERE TURN.t_DealID = DEAL.t_ID AND TURN.t_Date < " + GetSQLDate(Oper.Date) + ") "+
          "    AND DEAL.t_State = " + string(DVDEAL_OPEN) +
          "    AND FITURN.t_FIID = DEAL.t_FIID " +
          "    AND FITURN.t_Department = DEAL.t_Department " +
          "    AND FITURN.t_Broker = DEAL.t_Broker " +
          "    AND FITURN.t_ClientContr = DEAL.t_ClientContr " +
          "    AND FITURN.t_GenAgrID = DEAL.t_GenAgrID " +
          "    AND FITURN.T_GUARANTY <> 0 " +
          "    AND FITURN.t_Date = " + GetSQLDate(Oper.Date) +
          "    AND DEAL.t_Type in('B', 'S', 'D', 'G')";

  Data = TRsbDataSet(Query);

  InitProgress( SQL_GetNRecs(Query), "Распределение гарантийного обеспечения по сделкам", "Выполнение..." );
  while( Data.MoveNext() )
     VM = Data.GUARANTY * (Data.Amount - Data.Execution);
     if(VM == 0)
        continue;
     end;

     cmdSum = RsdCommand( " SELECT Sum (DEAL.t_Amount - CASE WHEN DEAL.t_Execution = DEAL.t_Amount THEN NVL((SELECT Exec FROM (SELECT turn.t_Execution Exec FROM DDVDLTURN_DBT turn WHERE turn.T_DEALID = DEAL.t_ID AND turn.T_DATE < DEAL.t_Date ORDER BY turn.T_DATE) WHERE ROWNUM = 1),0) ELSE DEAL.t_Execution end) as TurnSum " +
                          "   FROM ddvdeal_dbt DEAL " +
                          "  WHERE " + DealByOperation(oper) +
                          "    AND EXISTS ( Select * from ddvdlturn_dbt TURN WHERE TURN.t_DealID = DEAL.t_ID AND TURN.t_Date < " + GetSQLDate(Oper.Date) + ") "+
                          "    AND DEAL.t_State = " + string(DVDEAL_OPEN) +
                          "    AND DEAL.t_FIID = ? " +
                          "    AND DEAL.t_Department = ? " +
                          "    AND DEAL.t_Broker = ? " +
                          "    AND DEAL.t_ClientContr = ? " +
                          "    AND DEAL.t_GenAgrID = ? " +
                          "    AND DEAL.t_Type in('B', 'S', 'D', 'G')");

     cmdSum.addParam("", RSDBP_IN, Data.FIID);
     cmdSum.addParam("", RSDBP_IN, Data.Department);
     cmdSum.addParam("", RSDBP_IN, Data.Broker);
     cmdSum.addParam("", RSDBP_IN, Data.ClientContr);
     cmdSum.addParam("", RSDBP_IN, Data.GenAgrID);
     cmdSum.execute();

     DataSum = TRsbDataSet(cmdSum);
     if( DataSum.MoveNext() )
        if(DataSum.TurnSum == 0)
           continue;
        else
           VM = VM / DataSum.TurnSum;
        end;
        if ( DV_GuarantDealTurn(Data.ID, oper.Date, VM, DV_ACTION_DISTRIBITOG) != 0 )
           return 1;
        end;
     else
        return 1;
     end;

     UseProgress(Count = Count + 1);
  end;

  RemProgress();
  return 0;
end;

macro ВыполнитьРасчетИтоговыхCуммПоСделке( oper/*RECORD DVOPER*/ ):integer

  var Query, Data,Query2, Data2, cmd;
  var Count:integer = 0;
  var v_CalcFairValue:integer = 0;
  var VM:money = $0;
  var РасчетИтоговыхСуммСделокПИ:integer = ВыполнятьРасчетИтоговыхСумм(oper.Party);
  var Pc:double = 0.0, Ppr:double = 0.0;
  var Pstep:double = 1.0,Pstep_pr:double = 1.0, Pstep_NatCur:double = 1.0, Pstep_NatCur_pr:double = 1.0;
  var So:money = $0, Spr:money = $0;
  var PFI:integer = 0;
  var P:double = 0.0;
  var SinceDateP:date = Date(0,0,0);
  var СС_н:money = $0;
  var v_CalcSum:integer = 0;
  var CourseKind:integer = -1;

  Query = " SELECT DEAL.t_ID, DEAL.t_FIID, DEAL.t_Date, Deal.t_Date_Clr, DEAL.t_Type, DEAL.t_Client, DEAL.t_DealCost as DDealCost, DEAL.t_Amount, " +
          "        FI.t_AvoirKind, FI.t_FI_Code, FI.t_ParentFI, " +
          "        DV.t_PriceMode, DV.t_TickFIID, DV.t_Tick, DV.t_StrikeFIID, DV.t_OptionType, " +
          "        TURN.t_Execution, TURN.t_DealCost " +
          "   FROM ddvdeal_dbt DEAL, ddvdlturn_dbt TURN, dfideriv_dbt DV, dfininstr_dbt FI " +
          "  WHERE " + DLTurnByOperationDate(oper) +
          "    AND DEAL.t_State = " + string(DVDEAL_OPEN) +
          "    AND DEAL.t_Type in('B', 'S', 'D', 'G')" +
          "    AND FI.t_FIID = DEAL.t_FIID " +
          "    AND DV.t_FIID = DEAL.t_FIID ";

  Data = TRsbDataSet(Query);

  InitProgress( SQL_GetNRecs(Query), "Расчет итоговых сумм по сделкам", "Выполнение..." );
  while( Data.MoveNext() )

     VM = $0;
     v_CalcFairValue = 0;

     Pstep = round(DV_TickCost(Data.FIID, oper.Date),4);
     Pstep_pr = round(DV_TickCost(Data.FIID, oper.Date-1),4);
     /* Сконвертируем Pstep в национальную валюту */
     if( Data.ParentFI != NATCUR )
        if( NOT DV_SmartConvertSum(Pstep_NatCur, money(Pstep), oper.Date, Data.ParentFI, NATCUR) )
           SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(Data.ParentFI) + " в рубли на дату " + String(oper.Date) );
           return 1;
        end;
        if( NOT DV_SmartConvertSum(Pstep_NatCur_pr, money(Pstep_pr), oper.Date-1, Data.ParentFI, NATCUR) )
           SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(Data.ParentFI) + " в рубли на дату " + String(oper.Date-1) );
           return 1;
        end;

     else
        Pstep_NatCur = Pstep;
        Pstep_NatCur_pr = Pstep_pr;
     end;

  //TEG   if( ((РасчетИтоговыхСуммСделокПИ == 1) or (Data.date<oper.Date)) and ( Data.Client == -1 ) ) //TEG  считаем ВМ по старым сделкам собственным
      if ((РасчетИтоговыхСуммСделокПИ == 1)) //TEG  считаем ВМ по старым сделкам собственным   
        if( (Data.AvoirKind == DERIVATIVE_FUTURES) and (Data.PriceMode == DERIVATIVE_MODE_TICKFI) )
           /* Получим курс "Расчетная цена" для фьючерса на день операции */
           SinceDateP = Date(0,0,0);
           Pc = 0.0;
           if( (ПолучитьКурсЗаданногоTипа(@Pc, Data.FIID, Data.TickFIID, RATETYPE_CALC_PRICE, oper.Date, true, @SinceDateP) == false) or (Pc <= 0.0) )
              SayError("Не задан курс \"Расчетная цена\" | для фьючерса " + Data.FI_Code + " на дату: " + string(oper.Date) );
              return 1;
           end;

           /* Получим курс "Расчетная цена" для фьючерса на предыдущий день */
           Ppr = 0.0;
           if( Data.Date_Clr != oper.Date )
              SinceDateP = Date(0,0,0);
              if( (ПолучитьКурсЗаданногоTипа( @Ppr, Data.FIID, Data.TickFIID, RATETYPE_CALC_PRICE, oper.Date-1, true, @SinceDateP) == false) or (Ppr <= 0.0) )
                 SayError("Не задан курс \"Расчетная цена\" | для фьючерса " + Data.FI_Code + " на дату: " + string(oper.Date-1) );
                 return 1;
              end;
           else
              Ppr = 0.0;
           end;

           So  = money(round((Data.Amount - Data.Execution) * Pc  * Pstep / Data.Tick, 2));
           Spr = money(round((Data.Amount - Data.Execution) * Ppr * Pstep_pr / Data.Tick, 2));
          if (Data.date==oper.Date)

           if( IsBuy(Data.Type) )
              VM = So - Spr - Data.DealCost;
           else
              VM = Data.DealCost - Spr - So;
           end;
               else
            if( IsBuy(Data.Type) )
              VM = So - Spr;
           else
              VM = Spr - So;
           end;
           
          end;  
        end;
     end;

     /* Для сделок с незаданным клиентом */
     if( Data.Client == -1 )
/*        if( Data.AvoirKind == DERIVATIVE_FUTURES )  !!! Не удалять. Формулы перенесут во вторую очередь реализации
           CourseKind = ВИД_КУРСА_ДЛЯ_ОЦЕНКИ_СС_ФЬЮЧЕРСА();
           PFI = Data.TickFIID;
        else
           CourseKind = ВИД_КУРСА_ДЛЯ_ОЦЕНКИ_СС_ОПЦИОНА();
           PFI = Data.StrikeFIID;
        end;

        P = 0.0;
        SinceDateP = Date(0,0,0);
        if( ПолучитьКурсЗаданногоTипа(@P, Data.FIID, PFI, CourseKind, oper.Date, true, @SinceDateP) and (P > 0.0) )
           v_CalcFairValue = 1;

           var DDealCost:money = 0.0;
           if( Data.ParentFI != NATCUR )
              if( NOT DV_SmartConvertSum(DDealCost, money(Data.DDealCost), oper.Date, Data.ParentFI, NATCUR) )
                 SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(Data.ParentFI) + " в рубли на дату " + String(oper.Date) );
                 return 1;
              end;
           else
              DDealCost = Data.DDealCost;
           end;

           if( Data.AvoirKind == DERIVATIVE_FUTURES )
              if( IsBuy(Data.Type) )  /* покупка фьючерса */
                 СС_н = P * (Data.Amount - Data.Execution) * /*Pstep*/Pstep_NatCur / Data.Tick - DDealCost;
              else /* продажа фьючерса */
                 СС_н = DDealCost - P * (Data.Amount - Data.Execution) * /*Pstep*/Pstep_NatCur / Data.Tick;
              end;
           elif( Data.AvoirKind == DERIVATIVE_OPTION )
              if( (IsBuy(Data.Type) and (Data.OptionType == DVTYPE_CALL)) OR (IsSale(Data.Type) and (Data.OptionType == DVTYPE_PUT)) ) /* покупка опциона Call, продажа опциона Put */
                 СС_н = max(P * (Data.Amount - Data.Execution) * /*Pstep*/Pstep_NatCur / Data.Tick - DDealCost, 0);
              else /* продажа опциона Call, покупка опциона Put */
                 СС_н = min(DDealCost - P * (Data.Amount - Data.Execution) * /*Pstep*/Pstep_NatCur / Data.Tick, 0);
              end;
           end;
/*
           if( PFI != NATCUR )
              if( NOT DV_SmartConvertSum( СС_н, СС_н, oper.Date, PFI, NATCUR ) )
                 SayError( "Невозможно сконвертировать из " + ПолучитьКодФинИн(PFI) + " в рубли сумму переоценки на дату " + String(oper.Date) );
                 return 1;
              end;
           end;
*/
           СС_н = money(round(СС_н, 2));*/
           СС_н = VM;
           v_CalcFairValue = IIF(СС_н == 0, 0, 1);
        //end;
     end;

     /* Если VМр не равно нулю или v_CalcFairValue == Да, занести сумму в итоги */
     if( (VM != $0) OR (v_CalcFairValue == 1) )
         /*Если для сделки продажи опциона Call, покупки опциона Put значение СС_н>0, то СС_н приравнять к нулю.
           Если для сделки покупки опциона Call, продажи опциона Put значение СС_н<0, то СС_н приравнять к нулю. */

        if( ((СС_н > 0) and (Data.Type == "S") and (Data.OptionType == 2)) or //call 
            ((СС_н > 0) and (Data.Type == "B") and (Data.OptionType == 1)) or //put 
            ((СС_н < 0) and (Data.Type == "B") and (Data.OptionType == 2)) or //call 
            ((СС_н < 0) and (Data.Type == "S") and (Data.OptionType == 1))    //put 
          )
           СС_н = 0;
        end;

        v_CalcSum = IIF( (VM != $0), 1, 0 ); /*1 = да*/
        if( DV_CalcDealTurn(Data.ID, oper.Date, VM,VM /*СС_н*/, v_CalcSum, v_CalcFairValue, DV_ACTION_CALCITOG) != 0 )
           return 1;
        end;
     end;

     UseProgress(Count = Count + 1);
  end;
  RemProgress();
//TEG 07.03.2019  пробуем делить вармаржу по собственным сделкам
  //функционал ниже идущий должен обязательно вызываться до исполнения взаимозачетов встречных сделок
  //определим суммы 
   if ((2==1) and (OPER.operkind==12600) and (OPER.Flag1==1))
            Query = " select  "+
                    "  rsb_struct.getDouble(note.t_Text) margin,deal.t_client client, deal.t_clientcontr clientcontr, "+
                    "   deal.t_ID ID , deal.t_fiid FIID , "+
                    "   nvl((select am.smount from (select fi.t_longposition-fi.t_shortposition smount from ddvfiturn_dbt fi "+
                    "     where fi.t_fiid=deal.t_fiid  "+
                    "         and fi.t_department=deal.t_department "+
                    "         and fi.t_client=deal.t_client and fi.t_clientcontr=deal.t_clientcontr  "+
                    "         and fi.t_date < ? order by fi.t_date desc) am where rownum <=1 "+
                    "  ),0) countDeal "+
                    "  from ddvfipos_dbt deal, dnotetext_dbt note "+
                    "   where LPAD(deal.t_ID, 34, '0') = note.t_DocumentID "+
                    "   and note.t_Objecttype = 141    and note.t_NoteKind = 101  and note.t_date= ? "+
                    "   and deal.t_clientcontr = 0  and deal.t_client=-1  ";
            cmd = DL_RSDCommand(Query);
            cmd.AddParam(oper.Date); 
            cmd.AddParam(oper.Date); 
            Data  = cmd.Execute();
            InitProgress( 1, "Расчет сумм вариационной маржи по сделкам", "Выполнение..." );
            while (data.MoveNext )
            //определим список
                  Query2 = " SELECT /*distinct*/ DEAL.t_ID, DEAL.t_FIID, DEAL.t_Date, DEAL.t_Type, DEAL.t_Client, DEAL.t_DealCost as DDealCost, DEAL.t_Amount, " +
                          "        FI.t_AvoirKind, FI.t_FI_Code, FI.t_ParentFI, " +
                          "        DV.t_PriceMode, DV.t_TickFIID, DV.t_Tick, DV.t_StrikeFIID, DV.t_OptionType, " +
                          "        TURN.t_Execution, TURN.t_DealCost " +
                          "   FROM ddvdeal_dbt DEAL, ddvdlturn_dbt TURN, dfideriv_dbt DV, dfininstr_dbt FI " +
                          "    WHERE " + DLTurnByOperationDate2(oper) +
                          "    AND DEAL.t_State = " + string(DVDEAL_OPEN) +
                          "    AND DEAL.t_Type in('B', 'S', 'D', 'G') " +
                          "    AND FI.t_FIID = DEAL.t_FIID " +
                          "    AND DV.t_FIID = DEAL.t_FIID "+
                          "    AND DEAL.t_FIID ="+Data.FIID+
                          "    AND turn.t_date= (SELECT MAX(dvt.t_date) FROM  " +
                          "     ddvdlturn_dbt dvt WHERE dvt.t_Date < "+GetSQLDate(Oper.Date)+" AND dvt.t_DealID = DEAL.t_ID ) ";
                  
                  Data2 = TRsbDataSet(Query2);
                 while (data2.MoveNext()) 
                    VM= money(round(data.margin/abs(data.countDeal),2)*(data2.amount-data2.Execution));
                   //фиксируем
                   v_CalcSum = IIF( (VM != $0), 1, 0 ); /*1 = да*/
                   v_CalcFairValue = 1;
                   if ( DV_CalcDealTurn(Data2.ID, oper.Date, VM, VM, v_CalcSum, v_CalcFairValue) != 0 )
                         RemProgress();
                         return 1;
                   end;// if
                end; //  while (data2.MoveNext()) 
           end;//  while (data.MoveNext )
     end; //if ((OPER.operkind==12600) and (OPER.Flag1==1))
  RemProgress();

  return 0;
end;

/*Получить курс фьючерса - Расчетная цена*/
PRIVATE MACRO ПолучитьКурсФьючерса( FI:TRecHandler, Fideriv:variant, __date:date, Course:@DOUBLE ) : bool
  var CourceSinceDate:date = Date(0,0,0), CourceName:string = "";
  var FaceValue:double = 0.0, Po:double = 0.0;
  var find:bool = false; 
  var FIID = IIF( Fideriv.rec.PriceMode == DERIVATIVE_MODE_TICKFI, Fideriv.rec.TickFIID, FI.rec.ParentFI );

  CourceName = "курс вида \"Расчетная цена\"";
  find = ПолучитьКурсЗаданногоTипа( @Po, FI.rec.FIID, FIID, RATETYPE_CALC_PRICE, __date, true, @CourceSinceDate );
  if( find == true ) 
     Course = Po;
  end; 

  if( find == false ) 
     SayError( "Не задан "+CourceName+" для фьючерса <" + FI.rec.FI_Code + "> за дату операции." );
  end; 
  return find;
END;

macro ПереоценкаПоРасчЦенеПоПозиции( Doc, oper )

  VAR Count:integer = 0;
  VAR Data1:variant, Data2:variant;
  VAR cmd1:variant, cmd2:variant;
  VAR FD:DVFirstDocPos; 
  VAR Pos1;
  VAR P0:double = 0.0, P:money = 0.0, T:double = 0.0;
  VAR NN:money = $0, NS:money = $0;
  VAR Sa:money = $0, Sy:money = $0;
  VAR Ds:money = $0, DsR:money = $0;
  VAR ReqOrCom:string = "";
  VAR CatAcc2:string = "";
  VAR StrGround:string;
  VAR InsOperPS = TRecHandler( "dvoperps" );
  VAR LPC:money = $0, SPC:money = $0;
  VAR FIID:integer = ALLFININSTR;
  VAR FI = TRecHandler("fininstr");
  VAR DV = TRecHandler("fideriv");

  RECORD OverAcc( account );
  RECORD CorrAcc( account );   /*счет маржи переоценки*/

  VAR rFiPos = TRecHandler( "dvfipos" );

  /*получаем значение настройки*/
  var KindOvrDeriv = ПереоценкаПоРасчетнойЦене();

  /* отбираем позиции */
  cmd1 = RsdCommand( " SELECT POS.*, fi.T_ISSUER " + 
                     "   FROM ddvfipos_dbt POS, dfininstr_dbt FI " +
                     "  WHERE " + PositionByOperationDate( oper ) +
                     "    AND POS.T_CLIENT = -1 " +
                     "    AND POS.t_FIID   = FI.t_FIID " +
                     "    AND FI.t_FI_Kind = ? " +
                     "    AND ( (FI.t_AvoirKind = ? and (?=0 or ?=1)) or " +
                     "          (FI.t_AvoirKind = ? and (?=0 or ?=2) and " +
                     "          (select base.t_AvoirKind from dfininstr_dbt base " +
                     "            where base.t_FIID = FI.t_FaceValueFI " +
                     "              and base.t_FI_Kind = ?) = ? ))");

  cmd1.addParam("", RSDBP_IN, FIKIND_DERIVATIVE);
  cmd1.addParam("", RSDBP_IN, DERIVATIVE_FUTURES);
  cmd1.addParam("", RSDBP_IN, KindOvrDeriv);
  cmd1.addParam("", RSDBP_IN, KindOvrDeriv);
  cmd1.addParam("", RSDBP_IN, DERIVATIVE_OPTION);
  cmd1.addParam("", RSDBP_IN, KindOvrDeriv);
  cmd1.addParam("", RSDBP_IN, KindOvrDeriv);
  cmd1.addParam("", RSDBP_IN, FIKIND_DERIVATIVE);
  cmd1.addParam("", RSDBP_IN, DERIVATIVE_FUTURES);
  cmd1.execute();

  Data1 = TRsbDataSet(cmd1);

  InitProgress( Data1.GetRecCount(), "Выполнение проводок переоценки по расчетной цене", "Выполнение..." );
  while( Data1.MoveNext() )

     ClearRecord(OverAcc);
     ClearRecord(CorrAcc);

     UseProgress(Count = Count + 1);
     Pos1 = Data1.GetRecord();

     FD = DVFirstDocPos(DL_DVFIPOS, Pos1.ID);

     DsR = $0.0;
     Ds  = $0.0;

     /* Определяется, требования или обязательства необходимо переоценивать в зависимости от знака позиции: */
     if( FD.УсловиеПоСторонеПоРасчЦене() )
        ReqOrCom = "О";
     else
        ReqOrCom = "Т";
     end;

     /*  Актуализируется без открытия счет по документу "Позиция по ПИ" */
     var ReqAcc:string = ""; var ReqAccFIID:integer = ALLFININSTR; var ReqFiRole:integer = FIROLE_UNDEF;
     var ComAcc:string = ""; var ComAccFIID:integer = ALLFININSTR; var ComFiRole:integer = FIROLE_UNDEF;

     ПолучитьВнебалансовыеСчетаБирж( FD, @ReqAcc, @ReqAccFIID, @ReqFiRole, @ComAcc, @ComAccFIID, @ComFiRole/*, false, true */);

     if( not FD.OpenAccount( IIF(ReqOrCom == "Т", ReqAcc, ComAcc),
                             null, false,
                             IIF(ReqOrCom == "Т", ReqFiRole, ComFiRole),
                             OverAcc, oper.Date,
                             IIF(ReqOrCom == "Т", ReqAccFIID, ComAccFIID) ) )
        SayError();
        return 1;
     end;

        NN = НоваяНеттоПозиция(Pos1, oper.Date, @NS);

        if( FD.PositionByFutures() )
           FIID = FD.FI.rec.FIID;
        else
           FIID = FD.FI.rec.FaceValueFI;
        end;

        if( ПолучитьПИ(FIID, @FI, @DV) == false )
           SayError("Не найден производный инструмент с FIID = " + string(FIID) );
           return 1;
        end;

        if( DV.PriceMode == DERIVATIVE_MODE_TICKFI )
           if( ПолучитьКурсЗаданногоTипа(@P0, FI.FIID, DV.TickFIID, RATETYPE_CALC_PRICE, oper.Date, true) == false)
              SayError( "Не задан курс вида \"Расчетная цена\ для фьючерса <" + FI.FI_Code + "> за дату операции." );
              return 1;
           end;

           if( FD.PositionByFutures() )
              T = DV_TickCost(FI.FIID, oper.Date);
              if( T <= 0.0 )
                 SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + oper.Date );
                 return 1;
              end;
              P = P0 * T / DV.Tick;
           else
              P = P0 * FD.FI.rec.FaceValue;
              if( NOT DV_SmartConvertSum(P, P, oper.Date, DV.TickFIID, FD.FI.rec.ParentFI, true) )
                 return 1;
              end;
           end;
        else
           if( ПолучитьКурсЗаданногоTипа(@P0, FI.FIID, FI.ParentFI, RATETYPE_CALC_PRICE, oper.Date, true) == false)
              SayError( "Не задан курс вида \"Расчетная цена\ для фьючерса <" + FI.FI_Code + "> за дату операции." );
              return 1;
           end;

           if( FD.PositionByFutures() )
              P = P0;
           else
              P = P0 * FD.FI.rec.FaceValue;
              if( NOT DV_SmartConvertSum(P, P, oper.Date, FI.ParentFI, FD.FI.rec.ParentFI, true) )
                 return 1;
              end;
           end;
        end;

        /* Выполняется расчет новой (актуальной) суммы: */
        Sa = round(P * NN, 2);

        /*  Определяется старая (учтенная) сумма Sу как остаток на актуализированном выше счете. */
        if( OverAcc.Account != "" )
           Sy = DL_GetRestAccount( OverAcc, oper.Date );         
        else 
           Sy = $0;
        end;

        /* Определяется изменение суммы DS = abs(Sа) - Sу. */
        Ds = Abs(Sa) - Abs(Sy);


     /*  Если DS != 0 выполняются проводки по переоценке: */
     if( Ds != $0 )
        if( ReqOrCom == "Т" )
           StrGround = ОснованиеПроводкиПИ(DV_GRNUM_OVERVALUE_REQ);
        else
           StrGround = ОснованиеПроводкиПИ(DV_GRNUM_OVERVALUE_COM);
        end;

        FD.SetFIIDForCorAccNum(OverAcc.Code_Currency);
        if( not FD.OpenAccount("СчКорреспГлаваГ", null, false, IIF(ReqOrCom == "Т", FIROLE_CORACC_ACTIVE, FIROLE_CORACC_PASSIVE), CorrAcc, oper.Date) )
           SayError();
           return 1;
        end; 

        if( ((ReqOrCom == "Т") AND (Ds > $0)) OR ((ReqOrCom == "О") AND (Ds < $0)) )
           if( not ПроводкаПоКатегориямУчета( FD, 
                                              OverAcc, CorrAcc, 
                                              oper.Date, OverAcc.Chapter, 
                                              OverAcc.Code_Currency, Abs(Ds), 
                                              Doc,
                                              INPCARRY,"",
                                              "",//oper.Code, 
                                              StrGround, /*Переоценка требований\обязательств*/
                                              NULL, NULL, null, NULL, null, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @DsR
                                            )
             )
              SayError(DV_GetCarryError());
              return 1;
           end; 
        else
           if( not ПроводкаПоКатегориямУчета( FD, 
                                              CorrAcc, OverAcc,
                                              oper.Date, OverAcc.Chapter, 
                                              null, null, 
                                              Doc,
                                              INPCARRY,"",
                                              "",//oper.Code, 
                                              StrGround, /*Переоценка требований\обязательств*/
                                              NULL, null, null, NULL, NULL, OverAcc.Code_Currency, Abs(Ds), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @DsR
                                            )
             )
              SayError(DV_GetCarryError());
              return 1;
           end;
        end;
     end;

     if( Ds < 0 )
        DsR = -DsR;
     end;

     /* Создается DDVOPERPS */
     InsOperPS.Clear();
     InsOperPS.rec.DocKind = DL_DVFIPOS;
     InsOperPS.rec.DocID   = Pos1.ID;
     InsOperPS.rec.Summ    = Ds;
     InsOperPS.rec.Summ0   = DsR;
     InsOperPS.rec.Rate    = P;
     InsOperPS.rec.SetDate = Date(0,0,0);

     if( OprInsertDVOPERPS( InsOperPS ) == false )
        SayError( "Ошибка при вставке записи во временный файл операций." );
        return 1;
     end;

     if( FD.PositionByFutures() )
        cmd2 = RsdCommand( "SELECT TURN.t_LongPosition, TURN.t_ShortPosition, TURN.t_LongPositionCost, TURN.t_ShortPositionCost " +
                           "  FROM ddvfiturn_dbt TURN " +
                           " WHERE " + TurnByPosition(Pos1, null, null) +
                           "   AND TURN.T_DATE = " + GetSQLDate(oper.Date) );
        cmd2.execute();
        Data2 = TRsbDataSet(cmd2);
        if( Data2.MoveNext() )
           /* Выполняется переоценка стоимости позиции */
           if( DV.PriceMode == DERIVATIVE_MODE_TICKFI )
             LPC = round(P * Data2.LongPosition * T / DV.Tick, 2);
             SPC = round(P * Data2.ShortPosition * T / DV.Tick, 2);
           else
             LPC = round(P * Data2.LongPosition, 2);
             SPC = round(P * Data2.ShortPosition, 2);
           end;

           if( (LPC != Data2.LongPositionCost) OR (SPC != Data2.ShortPositionCost) )
              rFiPos.rec.ID         = Pos1.ID;
              rFiPos.rec.FIID       = Pos1.FIID;
              rFiPos.rec.Department = Pos1.Department;
              rFiPos.rec.Broker     = Pos1.Broker;
              rFiPos.rec.BrokerContr= Pos1.BrokerContr;
              rFiPos.rec.Client     = Pos1.Client;
              rFiPos.rec.ClientContr= Pos1.ClientContr;
              rFiPos.rec.Sector     = Pos1.Sector;
              rFiPos.rec.GenAgrID   = Pos1.GenAgrID;
              rFiPos.rec.State      = Pos1.State;
              rFiPos.rec.CloseDate  = Date(0,0,0); 

              if( OprPositionOvervalue( rFiPos, LPC, SPC ) == false )
                 SayError( "Ошибка при выполнении переоценки стоимости позиции." );
                 return 1;
              end;
           end;
        end;
     end;

  end;
  RemProgress();

  return 0;
end;

macro ПереоценкаПоРасчЦенеПоСделке( Doc, oper )

  VAR Count:integer = 0;
  VAR Data1:variant;
  VAR cmd1:variant;
  VAR query1:variant;
  VAR FD:DVFirstDocDeal;
  VAR P0:double = 0.0, P:money = 0.0, T:double = 0.0,P1:money = 0.0,P01:double = 0.0;
  VAR NN:money = $0/*, NS:money = $0*/;
  VAR Sa:money = $0, Sy:money = $0;
  VAR Ds:money = $0, DsR:money = $0;
  VAR C:money = $0;
  VAR ReqOrCom:string = "";
  VAR CatAcc2:string = "";
  VAR StrGround:string;
  VAR InsOperPS = TRecHandler( "dvoperps" );
  VAR FIID:integer = ALLFININSTR;
  VAR FI = TRecHandler("fininstr");
  VAR DV = TRecHandler("fideriv");
  //TEG 27.02.19
  VAR ground;
  VAR DealD;

  RECORD OverAcc( account );
  RECORD CorrAcc( account );   /*счет маржи переоценки*/

  /*получаем значение настройки*/
  var KindOvrDeriv = ПереоценкаПоРасчетнойЦене();
  
  /* отбираем сделки *///TEG добавим выбор даты 
  query1 = " SELECT DEAL.t_ID, TURN.t_DealCost, TURN.t_Margin , DEAL.t_Date, DEAL.t_price " +
                     "   FROM ddvdeal_dbt DEAL, ddvdlturn_dbt TURN, dfininstr_dbt FI " +
                     "  WHERE " + DLTurnByOperationDate(oper) +
                     "    AND DEAL.t_State = ? " +
                     "    AND DEAL.t_Type in('B', 'S', 'D', 'G')" +
                     "    AND DEAL.t_Client = -1 " +
                     "    AND FI.t_FIID = DEAL.t_FIID " +
                     "    AND FI.t_FI_Kind = ? " +
                     "    AND ( (FI.t_AvoirKind = ? and (?=0 or ?=1)) or " +
                     "          (FI.t_AvoirKind = ? and (?=0 or ?=2) and " +
                     "          (select base.t_AvoirKind from dfininstr_dbt base " +
                     "            where base.t_FIID = FI.t_FaceValueFI " +
                     "              and base.t_FI_Kind = ?) = ? ))";
  cmd1 = DL_RSDCommand(query1);
  cmd1.addParam(DVDEAL_OPEN);
  cmd1.addParam(FIKIND_DERIVATIVE);
  cmd1.addParam(DERIVATIVE_FUTURES);
  cmd1.addParam(KindOvrDeriv);
  cmd1.addParam(KindOvrDeriv);
  cmd1.addParam(DERIVATIVE_OPTION);
  cmd1.addParam(KindOvrDeriv);
  cmd1.addParam(KindOvrDeriv);
  cmd1.addParam(FIKIND_DERIVATIVE);
  cmd1.addParam(DERIVATIVE_FUTURES);
  Count = cmd1.GetCount;
  Data1 = cmd1.execute();

  InitProgress( Count, "Выполнение проводок переоценки по расчетной цене", "Выполнение..." );
  Count = 0;
  while( Data1.MoveNext() )
    
    FD = DVFirstDocDeal(DL_DVDEAL, Data1.ID);
    //TEG 27.02.19
    ground = ", сделка N "+FD.DEAL.rec.extcode+" от "+StrSubSt(String(FD.deal.rec.date:f), ".", "/")+" "+iif(FD.DEAL.rec.type=="S"," по продаже ПФИ "," по покупке ПФИ ")+", количество "+string(FD.DEAL.rec.amount-FD.DEAL.rec.Execution:*:*,5,0); 
    DealD=SQL_ConvTypeDate(Data1.date);

    DsR = $0.0;
    Ds  = $0.0;

    /* Определяется, требования или обязательства необходимо переоценивать в зависимости от знака позиции: */
    if( FD.УсловиеПоСторонеПоРасчЦене() )
      ReqOrCom = "О";
    else
      ReqOrCom = "Т";
    end;

    var ReqAcc:string = ""; var ReqAccFIID:integer = ALLFININSTR; var ReqFiRole:integer = FIROLE_UNDEF;
    var ComAcc:string = ""; var ComAccFIID:integer = ALLFININSTR; var ComFiRole:integer = FIROLE_UNDEF;

    ПолучитьВнебалансовыеСчетаБирж(FD, @ReqAcc, @ReqAccFIID, @ReqFiRole, @ComAcc, @ComAccFIID, @ComFiRole/*, false, true*/);

    if( not FD.OpenAccount( IIF(ReqOrCom == "Т", ReqAcc, ComAcc),
                            null, false,
                            IIF(ReqOrCom == "Т", ReqFiRole, ComFiRole),
                            OverAcc, oper.Date,
                            IIF(ReqOrCom == "Т", ReqAccFIID, ComAccFIID) ) )
      SayError();
      return 1;
    end;

    NN = FD.Deal.rec.Amount - FD.Deal.rec.Execution;

    if( FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES )
      FIID = FD.FI.rec.FIID;
    else
      FIID = FD.FI.rec.FaceValueFI;
    end;

    if( ПолучитьПИ(FIID, @FI, @DV) == false )
      SayError("Не найден производный инструмент с FIID = " + string(FIID) );
      return 1;
    end;

    if( DV.PriceMode == DERIVATIVE_MODE_TICKFI )
      if( ПолучитьКурсЗаданногоTипа(@P0, FI.FIID, DV.TickFIID, RATETYPE_CALC_PRICE, oper.Date, true) == false)
        SayError( "Не задан курс вида \"Расчетная цена\" для фьючерса <" + FI.FI_Code + "> за дату операции." );
        return 1;
      end;

      if( (FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES) and (FD.BaseFI_NotDV.rec.FI_Kind == FIKIND_INDEX) and (FD.BaseFI_NotDV.rec.Settlement_Code == FI_INDEX_CURRENCY) and (DV.TickFIID != NATCUR) )
        //Для индексов с котируемой валютой = не рубли
        P01 = 0.0;
        if( ПолучитьКурсЗаданногоTипа(@P01, FI.FIID, NATCUR, RATETYPE_CALC_PRICE_G, oper.Date, true) == false)
          SayError( "Не задан курс вида \"Расчетная цена для главы Г\" для фьючерса <" + FI.FI_Code + ">  на дату: " + oper.Date );
          return 1;
        end;
        T = DV_TickCost(FI.FIID, oper.Date);
        if( T <= 0.0 )
          SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + oper.Date );
          return 1;
        end;
        P = round((P01/T)*DV.Tick*FI.FaceValue,2); 
      elif( FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES )
        T = DV_TickCost(FI.FIID, oper.Date);
        if( T <= 0.0 )
          SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + oper.Date );
          return 1;
        end;
        P = round(P0 * round(T / DV.Tick,5),2);
        if ((not FD.isClient()) and FD.DealWithFutures()  and (FD.FI.rec.Settlement_Code == DVSETTLEMET_CALC) and 
            ((FD.BASEFI_NOTDV.rec.fi_code=="GOLD") or 
            (FD.BASEFI_NOTDV.rec.fi_code=="SILV") or 
            (FD.BASEFI_NOTDV.rec.fi_code=="PLT") or 
            (FD.BASEFI_NOTDV.rec.fi_code=="PLD")) )
          if( ПолучитьКурсЗаданногоTипа(@P0, FI.FIID, IIF(ReqOrCom == "Т", ReqAccFIID, ComAccFIID), RATETYPE_CALC_PRICE, oper.Date, true) == false)
            SayError( "Не задан курс вида \"Расчетная цена\" для фьючерса <" + FI.FI_Code + "> за дату операции." );
            return 1;
          end;
          P = round(P0,2);
        end;
      else
        /*DEF-43775*/
        T = DV_TickCost(FI.FIID, oper.Date);
        if( T <= 0.0 )
          SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + oper.Date );
          return 1;
        end;
        P0 = round(P0 * round(T / DV.Tick,5),2);
        P = P0 * FD.FI.rec.FaceValue;
        /*if( NOT DV_SmartConvertSum(P, P, oper.Date, DV.TickFIID, FD.FI.rec.ParentFI, true) )
          return 1;
        end;*/
      end;
    else
      if( ПолучитьКурсЗаданногоTипа(@P0, FI.FIID, FI.ParentFI, RATETYPE_CALC_PRICE, oper.Date, true) == false)
        SayError( "Не задан курс вида \"Расчетная цена\" для фьючерса <" + FI.FI_Code + "> за дату операции." );
        return 1;
      end;

      if( FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES )
        P = round(P0/ DV.Tick,2);
      else
        P = P0 * FD.FI.rec.FaceValue;
        if( NOT DV_SmartConvertSum(P, P, oper.Date, FI.ParentFI, FD.FI.rec.ParentFI, true) )
          return 1;
        end;
      end;
    end;

    /* Выполняется расчет новой (актуальной) суммы: */
    Sa = P * NN;

    /*  Определяется старая (учтенная) сумма Sу как остаток на актуализированном выше счете. */
    //TEG 28.01.2019  BEGIN так как банк хочет счета в разрезе контрагента, то расчитаем цену а не берем остаток
    /*if( OverAcc.Account != "" )
       Sy = DL_GetRestAccount( OverAcc, oper.Date );         
    else 
       Sy = $0;
    end;*/
    Sy = $0;
    if( DV.PriceMode == DERIVATIVE_MODE_TICKFI )
      if (DealD==oper.Date)
        P01= data1.price;
      else
        if( ПолучитьКурсЗаданногоTипа(@P01, FI.FIID, DV.TickFIID, RATETYPE_CALC_PRICE, oper.Date-1, true) == false)
          SayError( "Не задан курс вида \"Расчетная цена\" для фьючерса <" + FI.FI_Code + ">  на дату: " + (oper.Date-1) );
          return 1;
        end;
      end;
      if( (FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES) and (FD.BaseFI_NotDV.rec.FI_Kind == FIKIND_INDEX) and (FD.BaseFI_NotDV.rec.Settlement_Code == FI_INDEX_CURRENCY) and (DV.TickFIID != NATCUR) and (DealD!=oper.Date) )
        //Для индексов с котируемой валютой = не рубли
        P01 = 0.0;
        if( ПолучитьКурсЗаданногоTипа(@P01, FI.FIID, NATCUR, RATETYPE_CALC_PRICE_G, oper.Date-1, true) == false)
          SayError( "Не задан курс вида \"Расчетная цена для главы Г\" для фьючерса <" + FI.FI_Code + ">  на дату: " + (oper.Date-1) );
          return 1;
        end;
        T = DV_TickCost(FI.FIID, oper.Date-1);
        if( T <= 0.0 )
          SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + (oper.Date-1) );
          return 1;
        end;
        P1 = round((P01/T)*DV.Tick*FI.FaceValue,2);  
      elif( FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES )
        T = DV_TickCost(FI.FIID, IIF(DealD==oper.Date,oper.Date,oper.Date-1));
        if( T <= 0.0 )
          SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + IIF(DealD==oper.Date,oper.Date,oper.Date-1) );
          return 1;
        end;
        P1 = round(P01 * round(T / DV.Tick,5),2);
        if ((not FD.isClient()) and FD.DealWithFutures()  and (FD.FI.rec.Settlement_Code == DVSETTLEMET_CALC) and 
            ((FD.BASEFI_NOTDV.rec.fi_code=="GOLD") or 
            (FD.BASEFI_NOTDV.rec.fi_code=="SILV") or 
            (FD.BASEFI_NOTDV.rec.fi_code=="PLT") or 
            (FD.BASEFI_NOTDV.rec.fi_code=="PLD")) )
          if (DealD==oper.Date)
            P01= data1.price;
          else
            if( ПолучитьКурсЗаданногоTипа(@P01, FI.FIID,IIF(ReqOrCom == "Т", ReqAccFIID, ComAccFIID), RATETYPE_CALC_PRICE, oper.Date-1, true) == false)
              SayError( "Не задан курс вида \"Расчетная цена\" для фьючерса <" + FI.FI_Code + ">  на дату: " + (oper.Date-1) );
              return 1;
            end;
          end;
          P1 = round(P01 ,2);
        end;
      else
        /*DEF-43775*/
        T = DV_TickCost(FI.FIID, IIF(DealD==oper.Date,oper.Date,oper.Date-1));
        if( T <= 0.0 )
          SayError("Не задан курс \"Стоимость минимального шага цены\" | для фьючерса " + FI.FI_Code + " на дату: " + IIF(DealD==oper.Date,oper.Date,oper.Date-1) );
          return 1;
        end;
        P01 = round(P01 * round(T / DV.Tick,5),2);
        P1 = P01 * FD.FI.rec.FaceValue;
        /*if( NOT DV_SmartConvertSum(P1, P1, IIF(DealD==oper.Date,oper.Date,oper.Date-1), DV.TickFIID, FD.FI.rec.ParentFI, true) )
          return 1;
        end;*/
      end;
    else
      if (DealD==oper.Date)
        P01= data1.price;
      else
        if( ПолучитьКурсЗаданногоTипа(@P01, FI.FIID, FI.ParentFI, RATETYPE_CALC_PRICE, oper.Date-1, true) == false)
          SayError( "Не задан курс вида \"Расчетная цена\" для фьючерса <" + FI.FI_Code + "> на дату: " + oper.Date-1 );
          return 1;
        end;
      end;
      if( FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES )
        P1 = round(P01/ DV.Tick,2);
      else
        P1 = P01 * FD.FI.rec.FaceValue;
        if( NOT DV_SmartConvertSum(P1, P1, IIF(DealD==oper.Date,oper.Date,oper.Date-1), FI.ParentFI, FD.FI.rec.ParentFI, true) )
          return 1;
        end;
      end;
    end;
    /* Выполняется расчет старой (учтенной) суммы: */
    Sy = P1 * NN;
    //TEG 28.02.2019 END 

    /* Определяется изменение суммы DS = abs(Sа) - Sу. */
    Ds = Abs(Sa) - Abs(Sy);
    if ((not FD.isClient()) and FD.DealWithFutures()  and (FD.FI.rec.Settlement_Code == DVSETTLEMET_CALC) and 
        ((FD.BASEFI_NOTDV.rec.fi_code=="GOLD") or 
        (FD.BASEFI_NOTDV.rec.fi_code=="SILV") or 
        (FD.BASEFI_NOTDV.rec.fi_code=="PLT") or 
        (FD.BASEFI_NOTDV.rec.fi_code=="PLD")) )
      Ds = Abs(Sa) - Abs(Sy);
      
    elif (DealD==oper.Date) /*PNV 511875*/
      if( (FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES) and (FD.BaseFI_NotDV.rec.FI_Kind == FIKIND_INDEX) and (FD.BaseFI_NotDV.rec.Settlement_Code == FI_INDEX_CURRENCY) and (DV.TickFIID != NATCUR) )
        Ds = (P * NN - round(data1.price * NN, 2));
      else
        Ds = (P * NN - data1.dealcost);
      end;
    end;
        
    /*  Если DS != 0 выполняются проводки по переоценке: */
    if( Ds != $0 )
      if( ReqOrCom == "Т" )
        // StrGround = ОснованиеПроводкиПИ(DV_GRNUM_OVERVALUE_REQ); /*Переоценка требований*/        ??????????
        if (Ds > $0) //TEG 31.05.19
          StrGround = "Положительная переоценка требований";     
        else
          StrGround = "Отрицательная переоценка требований";
        end;
      else
        // StrGround = ОснованиеПроводкиПИ(DV_GRNUM_OVERVALUE_COM); /*Переоценка обязательств*/
        if (Ds > $0) //TEG 31.05.19
          StrGround = "Положительная переоценка обязательств";     
        else
          StrGround = "Отрицательная переоценка обязательств";
        end;
      end;

      FD.SetFIIDForCorAccNum(OverAcc.Code_Currency);
      if( not FD.OpenAccount("СчКорреспГлаваГ", null, false, IIF(ReqOrCom=="Т",FIROLE_CORACC_ACTIVE,FIROLE_CORACC_PASSIVE), CorrAcc, oper.Date) )
        SayError();
        return 1;
      end; 

      if( ((ReqOrCom == "Т") AND (Ds > $0)) OR ((ReqOrCom == "О") AND (Ds < $0)) )
        if( not ПроводкаПоКатегориямУчета( FD,
                                           OverAcc, CorrAcc,
                                           oper.Date, OverAcc.Chapter,
                                           OverAcc.Code_Currency, Abs(Ds),
                                           Doc,
                                           INPCARRY, "",
                                           "",//oper.Code,
                                           StrGround+ ground, /*Переоценка требований\обязательств*/
                                           NULL, NULL, null, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @DsR
                                         )
          )
          SayError(DV_GetCarryError());
          return 1;
        end; 
      else
        if( not ПроводкаПоКатегориямУчета( FD,
                                           CorrAcc, OverAcc,
                                           oper.Date, OverAcc.Chapter,
                                           null, null,
                                           Doc,
                                           INPCARRY, "",
                                           "",//oper.Code,
                                           StrGround+ ground, /*Переоценка требований\обязательств*/
                                           NULL, null, NULL, NULL, NULL, OverAcc.Code_Currency, Abs(Ds), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @DsR
                                         )
          )
          SayError(DV_GetCarryError());
          return 1;
        end;
      end;
    end;

    if( Ds < 0 )
      DsR = -DsR;
    end;

    /* Создается DDVOPERPS */
    InsOperPS.Clear();
    InsOperPS.rec.DocKind = DL_DVDEAL;
    InsOperPS.rec.DocID   = FD.Deal.rec.ID;
    InsOperPS.rec.Summ    = Ds;
    InsOperPS.rec.Summ0   = DsR;
    InsOperPS.rec.Rate    = P;
    InsOperPS.rec.SetDate = Date(0,0,0);

    if( OprInsertDVOPERPS( InsOperPS ) == false )
      SayError( "Ошибка при вставке записи во временный файл операций." );
      return 1;
    end;

    if( FD.FI.rec.AvoirKind == DERIVATIVE_FUTURES )
      /* Выполняется переоценка стоимости сделки */
      //TEG 28.02.19
      //C = round((FD.Deal.rec.Amount - FD.Deal.rec.Execution) * P / FD.Fideriv.rec.Tick, 2);
      C = round((FD.Deal.rec.Amount - FD.Deal.rec.Execution) * P, 2) ;
      if( C != Data1.DealCost )
        if( DV_OvervalueDealTurn(FD.Deal.rec.ID, oper.Date, C, oper.ID, DV_FLAG_OVERVALUE_CALC_PRICE) != 0 )
          return 1;
        end;
      end;
    end;

    UseProgress( Count = Count + 1 );
  end;
  RemProgress();

  return 0;
end;
