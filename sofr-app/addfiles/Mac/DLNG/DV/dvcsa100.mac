/*
$Name:        dvcsa100.mac
$Module:      Производные инструменты
$Description: CSA. Шаг: Квитовка входящих платежей
*/

import PaymInter, "globals.mac", "dldlngfun.mac", "dv_fun.mac", "dv_car.mac";

/* Массивы с информацией о исполняемых платежах для квитовки */
VAR PlanIDs     = TArray;
VAR FactIDs     = TArray;
VAR KvitAmounts = TArray;
VAR ExecDate;

MACRO ExecuteStep( doc, FDoc, DocKind, ID_Operation, ID_Step )
  record csaBuf(dvcsa);
  SetBuff(csaBuf, FDoc);
  var FD = DVFirstCSA(DocKind, csaBuf.CSAID);
  var oper = GetMainOperInGroup(DocKind, FD.Kind); //Ролевая модель
  var ground = "Получение маржевой суммы по договору " + FD.CSA.rec.Code  + " за " + ExecDate; /*PNV i-support 509879*/
  if (oper <= 0) 
    oper = {oper};
  end;

  if( ExecDate == NULL )
     MsgBox("Шаг \"Квитовка входящих платежей\" должен выполняться только из соответствующей сервисной операции.");
     return 1;
  end;

  // инициализация массива сумм плановых платежей
  var i = 0, parms = DL_KvitParms();
  while( i < PlanIDs.size )
     parms.Add(PlanIDs(i), RsbPayment(PlanIDs(i)).FuturePayerAmount);
     i = i + 1;
  end;

  if( ExecDate > {curdate} )
     MsgBox("Преждевременное выполнение шага запрещено");
     return 1;
  end;

  if( (not ПИ_ИнтегрРежимРаботы()) or (not ПИ_РежимКвитовкиПлатежей()) )
     MsgBox("Квитовка платежей не предусмотрена");
     return 1;
  elif( not DL_КвитовкаПлатежа(PlanIDs, FactIDs) )
     return 1;
  elif( not DL_ВыполнитьПроводкиКвитовки(parms, PlanIDs, FactIDs, KvitAmounts, ExecDate, ground, 80/*пачка*/, oper) )
     return 1;
  end;

  return 0;
END;

MACRO PostStep (    
                CommitOrRollback, /*1-выполнение шага,2 -отакат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */
  var stat = 0;

  if (errTrn OR (CommitOrRollback==2)) 
      /* Произошла ошибка или происходит откат */
      return;
  end;

  //Simanov. Удаление привязки проводок к входящим платежам. Для корректной выгрузки в БИС
  var sql = "delete from dpmdocs_dbt "
          + "where t_acctrnid in (select t_acctrnid from doprdocs_dbt doc "
          + "                     where t_id_operation = " + ID_Operation
          + "                           and t_dockind = 1 "
          + "                           and t_id_step = " + ID_Step
          + "                           and exists (select 1 from dacctrn_dbt where t_acctrnid = doc.t_acctrnid and t_number_pack = 170)) ";
  ExecSql(sql);

  //Проводим исполнение требований, если квитовка завершена
  var query, cmd, DataSet;
  var hasNoExecute = false;
  var Payment;

  if (PlanIDs.size >= 1)
    query = " SELECT T_PAYMENTID "
           +"   FROM DPMPAYM_DBT paym "
           +"  WHERE     paym.T_DOCKIND = 4627 "
           +"        AND paym.T_DOCUMENTID = "
           +"               (SELECT T_DOCUMENTID "
           +"                  FROM DPMPAYM_DBT pm, DDVCSAPM_DBT csapm "
           +"                 WHERE     csapm.t_PMID = pm.T_DOCUMENTID "
           +"                       AND pm.T_DOCKIND = 4627 "
           +"                       AND pm.T_PAYMENTID = ?) ";
    cmd=DL_RSDCommand(query);
    cmd.addParam(PlanIDs[0]);
    if (cmd.GetCount() > 0)
      DataSet = cmd.Execute();
      while (DataSet.MoveNext())
        Payment = RsbPayment(DataSet.PaymentId);
        if (Payment)
          if(not(( ПИ_СтутусПлатежИсполнен(Payment.PaymStatus)) or ( Payment.FuturePayerAmount == 0 )))
            hasNoExecute=true;
            break;
          end;
        end;
      end;

      if (not hasNoExecute)
        Opr_ExecuteStep(ID_Operation, "Ф"); 
        Opr_ExecuteStep(ID_Operation, "Т"); 
      end;

    end;
  end;

  return 1;
END;
