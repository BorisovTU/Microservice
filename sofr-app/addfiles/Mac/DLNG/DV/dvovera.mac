/*
$Name:        dvovera.mac
$Module:      Производные инструменты
$Description: Операция переоценки
*/
IMPORT InsCarryDoc, RsbDataSet, "dvserv.mac", "dv_fun.mac", "dv_ground.mac", "dvservop.mac", "dv_car.mac", "dv_categ.mac";

PRIVATE VAR rFiPos = TRecHandler( "dvfipos" );

PRIVATE MACRO SayError( StrErr:STRING, NumErr:INTEGER ):INTEGER
  if( NumErr == null )
     NumErr = 1;
  end;
  SvOpInsertError( DL_DVFIPOS, rFiPos, NumErr, StrErr );

  return 1; /*выход по ошибке*/
END;

MACRO ExecuteStep( Doc, FirstDoc, FirstDocKind )

  RECORD rFirstDoc( dvfipos );
  RECORD OverAcc( account );  /*счет переоценки*/
  RECORD CorrAcc( account );   /*счет маржи переоценки*/

  VAR AvFI      = TRecHandler( "fininstr" ),
      InsOperPS = TRecHandler( "dvoperps" );

  VAR FITurn:variant, OperPS:variant, FD:DVFirstDocPos; 
  VAR P:double = 0.0; 
  VAR Ds:money = $0, DsR:money = $0;
  VAR BaseFaceValue:money = $0, FaceValue:money = $0; 
  VAR Sa:money = $0, Sy:money = $0, Пн:money = $0, N:money = $0, NKD:money = $0;  
  VAR ReqOrCom:string = "";
  VAR CatAcc:string = "", StrGround:string = ""; 
  VAR DebAcc:string = "", CredAcc:string = "";

  SetBuff( rFirstDoc, FirstDoc );
  copy( rFiPos, rFirstDoc );

  var sql = RSDCommand(
     "SELECT turn.t_State, turn.t_LongPositionCost, turn.t_ShortPositionCost, turn.t_LongPosition, turn.t_ShortPosition " +
     "FROM ddvfiturn_dbt turn "
     "WHERE turn.t_FIID        = ? AND " +
     "      turn.t_ClientContr = ? AND " +
     "      turn.t_Department  = ? AND " +
     "      turn.t_Broker      = ? AND " +
     "      turn.t_GenAgrID    = ? AND " +
     "      turn.t_Date        = ( SELECT MAX(turn_1.t_Date) "   +
     "                               FROM ddvfiturn_dbt turn_1 " +
     "                              WHERE turn_1.t_FIID        = turn.t_FIID        AND "+
     "                                    turn_1.t_ClientContr = turn.t_ClientContr AND "+
     "                                    turn_1.t_Department  = turn.t_Department  AND "+
     "                                    turn_1.t_Broker      = turn.t_Broker      AND "+
     "                                    turn_1.t_GenAgrID    = turn.t_GenAgrID    AND "+
     "                                    turn_1.t_Date        <= ? )" );

  sql.addParam( "", RSDBP_IN, rFiPos.rec.FIID );
  sql.addParam( "", RSDBP_IN, rFiPos.rec.ClientContr );
  sql.addParam( "", RSDBP_IN, rFiPos.rec.Department );
  sql.addParam( "", RSDBP_IN, rFiPos.rec.Broker );
  sql.addParam( "", RSDBP_IN, rFiPos.rec.GenAgrID );
  sql.addParam( "", RSDBP_IN, SvOpDvOper.rec.Date );
  sql.execute();

  FITurn = TRsbDataSet(sql);

  if( FITurn.MoveNext() AND (FITurn.State != DVTURN_CLOSE) )
     return SayError( "Не закрыт день по позиции ПИ" );
  end;

  /* Проверяется, что по позиции еще не выполнена операция переоценки по рыночной цене ц/б */
  var sql3 = RSDCommand(
     "SELECT oper.t_ID " +
     "  FROM ddvoperps_dbt operps, ddvoper_dbt oper " +
     " WHERE operps.t_DocKind =  ? AND " +
     "       operps.t_DocID   =  ? AND " +
     "       oper.t_ID        =  operps.t_OperID AND " +
     "       oper.t_DocKind   =  ? AND " + 
     "       oper.t_Flag1     =  ? AND " + 
     "       oper.t_Date      >= ? "
  );
  sql3.addParam( "", RSDBP_IN, DL_DVFIPOS );
  sql3.addParam( "", RSDBP_IN, rFiPos.rec.ID );
  sql3.addParam( "", RSDBP_IN, DL_DVOPER_OVERVALUE );
  sql3.addParam( "", RSDBP_IN, DV_KIND_OVERVALUE_MARKET_PRICE );
  sql3.addParam( "", RSDBP_IN, SvOpDvOper.rec.Date );
  sql3.execute();
  OperPS = TRsbDataSet( sql3 );
  if( OperPS.MoveNext() )
     return SayError( "По позиции уже выполнена переоценка по рыночной цене ц/б", 0 );
  end;

  FD = DVFirstDocPos( DL_DVFIPOS, rFiPos );      

  if( FD.BaseFI_NotDV.rec.FI_Kind == FIKIND_AVOIRISS )
     copy( AvFI, FD.BaseFI_NotDV );
  else
     return SayError( "Базовый инструмент не является ценной бумагой." );
  end;

  /* Ищем курс Р Ц/Б на дату операции вида "Рыночная цена" (если есть - в ВН, если нет, но есть другой - привести к курсу в ВН) */
  var StrError:string = "";
  if( ПИ_ПолучитьКурсЦеннойБумаги( AvFI, @P, SvOpDvOper.rec.Date, @StrError ) == false )
     return SayError(StrError);
  end; 

  if( P > 0.0 )
     /* 7. Выполняются расчет новой (актуальной) суммы Sа = Пн * N * (Р + НКД) */
     Пн = Abs( FITurn.T_SHORTPOSITION - FITurn.T_LONGPOSITION );     

     if( FD.BaseFI.rec.FI_Kind == FIKIND_DERIVATIVE )
        N = FD.FI.rec.FaceValue * FD.BaseFI.rec.FaceValue;
     else
        N = FD.FI.rec.FaceValue;
     end;

     NKD = НКД( AvFI.rec.FIID, 1., FD.FI.rec.DrawingDate );

     Sa = round(Пн * N * (P + NKD), 2);

     /* Определяется, требования или обязательства необходимо переоценивать */
     if( FD.УсловиеПоСтороне() )
        ReqOrCom   = "Т";
     else
        ReqOrCom   = "О";
     end;  

     var ReqAcc:string = ""; var ReqAccFIID:integer = ALLFININSTR; var ReqFiRole:integer = FIROLE_UNDEF;
     var ComAcc:string = ""; var ComAccFIID:integer = ALLFININSTR; var ComFiRole:integer = FIROLE_UNDEF;

     ПолучитьВнебалансовыеСчетаБирж( FD, @ReqAcc, @ReqAccFIID, @ReqFiRole, @ComAcc, @ComAccFIID, @ComFiRole );

     if( not FD.IsExistAccount( IIF(ReqOrCom == "Т", ReqAcc, ComAcc),
                                null, false,
                                IIF(ReqOrCom == "Т", ReqFiRole, ComFiRole),
                                OverAcc, null, SvOpDvOper.rec.Date,
                                IIF(ReqOrCom == "Т", ReqAccFIID, ComAccFIID) ) )
        return 0;
     end;

     /* Определяется старая (учтенная) сумма Sу как остаток на актуализированном счете. */
     if( OverAcc.Account != "" )
        Sy = DL_GetRestAccount( OverAcc, SvOpDvOper.rec.Date );         
     else 
        Sy = $0;
     end;

     /* Определяется изменение суммы DS = Sа - Sу. */
     Ds = Sa - Abs(Sy);

     if( Ds != $0 )  
         if( ReqOrCom == "Т" )
            StrGround = ОснованиеПроводкиПИ(DV_GRNUM_OVERVALUE_REQ); /*Переоценка требований*/
         else
            StrGround = ОснованиеПроводкиПИ(DV_GRNUM_OVERVALUE_COM); /*Переоценка обязательств*/
         end;

         FD.SetFIIDForCorAccNum(OverAcc.Code_Currency);
         if( not FD.OpenAccount( "СчКорреспГлаваГ", null, false, IIF(ReqOrCom=="Т",FIROLE_CORACC_ACTIVE,FIROLE_CORACC_PASSIVE), CorrAcc, SvOpDvOper.rec.Date ) )
            return 1;
         end;

         if( ((ReqOrCom == "Т") AND (Ds > $0)) OR ((ReqOrCom == "О") AND (Ds < $0)) )
            if( not ПроводкаПоКатегориямУчета( FD,
                                               OverAcc, CorrAcc,
                                               SvOpDvOper.rec.Date, OverAcc.Chapter,
                                               OverAcc.Code_Currency, Abs(Ds),
                                               Doc,
                                               INPCARRY, "",
                                               SvOpDvOper.rec.Code,
                                               StrGround, /*Переоценка требований\обязательств*/
                                               0, null, null,
                                               null, NULL,
                                               NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @DsR
                                             )
            )
               return SayError( DV_GetCarryError() );
            end;
            DebAcc  = OverAcc.Account;            
            CredAcc = CorrAcc.Account;            
         else
            if( not ПроводкаПоКатегориямУчета( FD,
                                               CorrAcc, OverAcc,
                                               SvOpDvOper.rec.Date, OverAcc.Chapter,
                                               null, null,
                                               Doc,
                                               INPCARRY, "",
                                               SvOpDvOper.rec.Code,
                                               StrGround, /*Переоценка требований\обязательств*/
                                               0, null, null,
                                               null, null,
                                               OverAcc.Code_Currency, Abs(Ds), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, @DsR
                                             )
            )
               return SayError( DV_GetCarryError() );
            end;
            DebAcc  = CorrAcc.Account;
            CredAcc = OverAcc.Account;
         end;
     end;
  else
     Ds = DsR = 0.0;
  end;

  if( Ds < 0 )
     DsR = -DsR;
  end;

  InsOperPS.Clear();
/*
Заполняется в сишнике
  InsOperPS.rec.DocKind = DL_DVFIPOS;
  InsOperPS.rec.DocID   = FD.DVPos.rec.ID;
  InsOperPS.rec.Flag    = DV_FLAG_OVERVALUE_MARKET_PRICE;
*/
  InsOperPS.rec.Summ    = Ds;
  InsOperPS.rec.Summ0   = DsR;
  InsOperPS.rec.Rate    = P;
  InsOperPS.rec.SetDate = Date(0,0,0);

  /*для протокола*/
  if( Abs(Ds) > 0.0 )
     InsOperPS.rec.BASEFIID          = AvFI.rec.FIID;        //Базовый выпуск
     InsOperPS.rec.DIRECTION         = ReqOrCom;             // Т/О
     InsOperPS.rec.OLDSUM            = abs(Sy);              //Сумма до проводки
     InsOperPS.rec.PAYFIID           = AvFI.rec.FaceValueFI;
     InsOperPS.rec.PAYSUM            = Abs(Ds);              //Сумма проводки
     InsOperPS.rec.ACCOUNT_PAYER     = DebAcc;               //Счет по Дт
     InsOperPS.rec.ACCOUNT_RECEIVER  = CredAcc;              //Счет по Кт
     InsOperPS.rec.AMOUNT            = Пн*N;                   //Количество 
  end;

  InsOperPS.rec.DocID   = FD.Deal.rec.ID;
  if( OprInsertDVOPERPS( InsOperPS ) == false )
     return SayError( "Ошибка при вставке записи во временный файл операций." );
  end;

  return 0;

ONERROR( RslErrObj )
  return SayError( RslErrObj.Module + " строка " + RslErrObj.Line + "|" + RslErrObj.Message, RslErrObj.Code );
END;
