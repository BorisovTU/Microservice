/*
$Name:        dvAlgCalcFrValFAv.mac
$Module:      Производные инструменты
$Description: Алгоритм расчета справедливой стоимости форвардного контракта на ценные бумаги
*/
IMPORT "dvAlgCalcFrVal.mac", SPInter;

PRIVATE MACRO DV_GetDrawingDateLastCoupon( FIID:integer, DateEnd:date ):date
  var cmd, rsd;
  var RetVal:date = date(0,0,0);

  cmd = RSDCommand( " SELECT warnt.t_DrawingDate " +
                    "   FROM dfiwarnts_dbt warnt " +
                    "  WHERE warnt.t_FIID = ? " +
                    "    AND warnt.t_IsPartial = chr(0) " +
                    "    AND warnt.t_DrawingDate <= ? " +
                    " ORDER BY warnt.t_DrawingDate DESC " );

  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, DateEnd );
  cmd.execute();

  rsd = TRsbDataSet(cmd);
  if( rsd.MoveNext() )
     RetVal = SQL_ConvTypeDate(rsd.DrawingDate);
  end;

  return RetVal;
END;

MACRO DVCalcFrVal( pFrVal:TRecHandler, pDEAL:TRecHandler, pFI_1:TRecHandler, pFI_2:TRecHandler ):integer

  var Fininstr = TRecHandler( "fininstr.dbt" );

  if( pFrVal.rec.Date == date(0,0,0) )
     MsgBox("Не задана дата расчёта.");
  elif( (pDEAL.rec.DVKind != DV_FORWARD) and (pDEAL.rec.DVKind != DV_FORWARD_T3) )
     MsgBox("В операции некорректно указан алгоритм расчета. ПФИ не является форвардом на ценную бумагу.");
  elif( ПолучитьФинИн(pFI_1.rec.FIID, Fininstr) )
     MsgBox("Не найден ФИ c ID = " + pFI_1.rec.FIID + ".");
  elif( Fininstr.rec.FI_Kind != FIKIND_AVOIRISS )
     MsgBox("В операции некорректно указан алгоритм расчета. ПФИ не является форвардом на ценную бумагу.");
  else
     var Course:double = 0.0;
     if( not ПолучитьКурсЗаданногоTипа(@Course, pFI_1.rec.FIID, Fininstr.rec.FaceValueFI, RATETYPE_OVERVAL_RIGTH_COST, pFrVal.rec.Date, true, null, DV_RATETYPE_CBR ) or
         (Course == 0.0) )
        MsgBox("Не найден курс вида 'ТСС для переоц. обяз-в' для FIID = " + String(pFI_1.rec.FIID));
     else
        var DFвр:double = 0.0, DFвн:double = 0.0,
            Sвба:double = 0.0, Sвц:double = 0.0, S1:double = 0.0, S2:double = 0.0,
            F:money = 0.0, PV:double = 0.0, Nба:money = 0.0, NKD:money = 0.0,
            AccFIID:integer = IIF(pFI_1.rec.AccFIID != ALLFININSTR, pFI_1.rec.AccFIID, pFI_1.rec.PriceFIID), pStat:integer = 0;

        DFвр = ALG_DF(AccFIID, pFrVal.rec.Date, pFI_1, ALG_DV_KIND_PRRATE_FORWARD, ALG_DV_FIKIND_PRRATE_AVOIRISS, null, @pStat);
        if( pStat != 0 )
           return 1;
        end;
        DFвн = ALG_DF(Fininstr.rec.FaceValueFI, pFrVal.rec.Date, pFI_1, ALG_DV_KIND_PRRATE_FORWARD, ALG_DV_FIKIND_PRRATE_AVOIRISS, DV_GetDrawingDateLastCoupon(Fininstr.rec.FIID, pFI_1.rec.ExecDate), @pStat);
        if( pStat != 0 )
           return 1;
        end;

        if( ПолучитьКурсЗаданногоTипа(@Sвба, Fininstr.rec.FaceValueFI, NATCUR, DV_RATETYPE_CBR, pFrVal.rec.Date, true ) == false )
           MsgBox("Невозможно получить курс вида 'ЦБ РФ' для FIID = " + String(Fininstr.rec.FaceValueFI) + " на дату " + String(pFrVal.rec.Date));
           return 1;
        end;

        if( ПолучитьКурсЗаданногоTипа(@Sвц, pFI_1.rec.PriceFIID, NATCUR, DV_RATETYPE_CBR, pFrVal.rec.Date, true ) == false )
           MsgBox("Невозможно получить курс вида 'ЦБ РФ' для FIID = " + String(pFI_1.rec.PriceFIID) + " на дату " + String(pFrVal.rec.Date));
           return 1;
        end;

        F = pFI_1.rec.Price;
        Nба = pFI_1.rec.Amount;
        if( FI_IsBond(Fininstr) )
           NKD = НКД(pFI_1.rec.FIID, 1, pFI_1.rec.ExecDate);
           PV  = ALG_GetCouponSumByPeriod(pFI_1.rec.FIID, pFrVal.rec.Date, pFI_1.rec.ExecDate) * DFвн;
        else
           PV = DFвн;
        end;

        S1 = Sвба * (Course - PV);
        S2 = ((Sвц * F) + (NKD * Sвба)) * DFвр;
        if( pDEAL.rec.Type == ALG_DV_BUY )
           pFrVal.rec.FairValue = money(round((S1 - S2) * Nба, 2));
        else
           pFrVal.rec.FairValue = money(round((S2 - S1) * Nба, 2));
        end;

        pFrVal.rec.SetDemand = pFrVal.rec.SetLiability = pFrVal.rec.SetDemand2 = pFrVal.rec.SetLiability2 = UNSET_CHAR;

        return 0; /*рассчитали значение без ошибок*/
     end;
  end;

  return 1; /*по умолчанию ошибка*/
END;
