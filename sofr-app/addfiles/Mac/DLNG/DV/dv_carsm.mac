/*
$Name:        dv_carsm.mac
$Module:      Производные инструменты
$Description: Выполнение сводных проводок
*/
import "dv_car.mac";

/*Настройка в регистре*/
PRIVATE CONST REG_PAIRACCMODE = "COMMON\\КАТЕГОРИИ СРЕДСТВ\\PAIRACCMODE";
PRIVATE VAR   PairAccModeValue;

PRIVATE FILE   DocOffTMP( "docoff.tmp" ) key 0 write;
PRIVATE FILE   DocOffTMPDtCt( "docoff.tmp" ) key 1 write;
PRIVATE FILE   DocOffTMPState( "docoff.tmp" ) key 2 write;
PRIVATE VAR    spdocoff  = TBFile( "spdocoff", "R", 1 );
PRIVATE RECORD AccountPayer(account);
PRIVATE RECORD AccountReceiver(account);
PRIVATE RECORD rAccount(account);
PRIVATE VAR    NameFile;

/*Виды идентичных по счетам проводок */
PRIVATE CONST CARRY_CURRENT   = 0, /*текущая (сравниваемая) проводка*/
              CARRY_PAIR_DT   = 1, /*Проводка со счетом Дт парным счету Дт текущей (CARRY_CURRENT) проводки*/
              CARRY_PAIR_CT   = 2, /*Проводка со счетом Кт парным счету Кт текущей (CARRY_CURRENT) проводки*/
              CARRY_PAIR_DTCT = 3; /*Проводка со счетами Дт и Кт парными счетам Дт и Кт текущей (CARRY_CURRENT) проводки*/

PRIVATE MACRO SayError( RslErrObj )
  MsgBox( RslErrObj.Module + " строка " + RslErrObj.Line + "|" + RslErrObj.Message);
  return 1;
END;

/*Закачать во временный файл проводку. 
  Если там уже есть проводка с такими же параметрами, то просуммировать */
PRIVATE MACRO AddInDocOffTMP()

  ClearRecord(DocOffTMPDtCt);
  DocOffTMPDtCt.Chapter       = spdocoff.rec.Chapter;
  DocOffTMPDtCt.DtFIID        = spdocoff.rec.Currency_Payer;
  DocOffTMPDtCt.DtAccount     = spdocoff.rec.Account_Payer;
  DocOffTMPDtCt.CtFIID        = spdocoff.rec.Currency_Receiver;
  DocOffTMPDtCt.CtAccount     = spdocoff.rec.Account_Receiver;
  DocOffTMPDtCt.State         = STATE_CHECK;
  DocOffTMPDtCt.DocOffID      = spdocoff.rec.Id;
  DocOffTMPDtCt.GroundKind    = spdocoff.rec.GroundKind;
  DocOffTMPDtCt.ClientContrID = spdocoff.rec.ClientContrID;

  if( GetEQ(DocOffTMPDtCt) )
     DocOffTMPDtCt.DtSumma = DocOffTMPDtCt.DtSumma + spdocoff.rec.Sum_Payer;
     DocOffTMPDtCt.CtSumma = DocOffTMPDtCt.CtSumma + spdocoff.rec.Sum_Receiver;
     Update(DocOffTMPDtCt, null, true);
  else
     DocOffTMPDtCt.DtSumma = spdocoff.rec.Sum_Payer;
     DocOffTMPDtCt.CtSumma = spdocoff.rec.Sum_Receiver;
     Insert(DocOffTMPDtCt, null, true);
  end;

  return 0;

OnError( RslErrObj )
  return SayError(RslErrObj);
END;                      

PRIVATE MACRO НайтиПарныйСчет( Chapter:INTEGER, FIID:INTEGER, Account:STRING )

  if( DL_GetAccount(Chapter, FIID, Account, rAccount) )
     return rAccount.PairAccount;
  end;

  return "";
END;

PRIVATE MACRO НайтиВстречныйСчет( Chapter:INTEGER, FIID:INTEGER, Account:STRING )
   var Query, DataSet;
   var sql = DL_RSDCommand();

   if( Substr(Account, 1, 5) == "47408" )
     Query =  " select docoff.T_CTACCOUNT T_ACCOUNT, "
             +"        nvl(sum(DOCOFF.T_DTSUMMA),0) T_SUMMA "   
             +"   from ddocoff_tmp docoff "                                                                                                                        
             +"  where substr(docoff.T_DTACCOUNT,1,5) = ? "
             +"    and docoff.T_CTFIID = ? "
             +"    and substr(docoff.T_CTACCOUNT,1,5) = '47407' "                                                                      
             +" group by docoff.T_CTACCOUNT ";
  else
     Query =  " select docoff.T_DTACCOUNT T_ACCOUNT, "
             +"        nvl(sum(DOCOFF.T_CTSUMMA),0) T_SUMMA "   
             +"   from ddocoff_tmp docoff "                                                                                                                        
             +"  where substr(docoff.T_CTACCOUNT,1,5) = ? "
             +"    and docoff.T_DTFIID = ? "
             +"    and substr(docoff.T_DTACCOUNT,1,5) = '47408' "                                                                      
             +" group by docoff.T_DTACCOUNT ";
  end;


  sql.addParam( Substr(Account, 1, 5) );
  sql.addParam( FIID );

  DataSet = sql.execute(Query);

  while( DataSet.MoveNext() )
     if( DL_GetAccount(Chapter, FIID, DataSet.Account, rAccount) )
        return rAccount.Account;
     end;
  end;
  return "";
END;

PRIVATE MACRO ЕстьПроводкиПоСчету( Chapter:INTEGER, FIID:INTEGER, Account:STRING, CarryDate:DATE, ID:INTEGER )
  var ExistCarry, Continue_cicle;

  if( FIID == NATCUR )
     ExistCarry = (DebetA(Account, CarryDate, NULL, Chapter) != 0);
     if( ExistCarry == false )
        ExistCarry = (KreditA(Account, CarryDate, NULL, Chapter) != 0);
     end;
  else
     ExistCarry = (DebetAC(Account, FIID, CarryDate, NULL, Chapter) != 0);
     if( ExistCarry == false )
        ExistCarry = (KreditAC(Account, FIID, CarryDate, NULL, Chapter) != 0);
     end;
  end;

  if( ExistCarry == false ) /*проверить в отложенных*/
     ClearRecord(DocOffTMP);
     Continue_cicle = GetGE(DocOffTMP); /*Сортировка по ID*/
     while( Continue_cicle AND (DocOffTMP.ID < ID) )

        if( (DocOffTMP.State   == STATE_EXECUTE) AND
            (DocOffTMP.Chapter == Chapter) AND
            ( ( (DocOffTMP.DtFIID == FIID) AND (DocOffTMP.DtAccount == Account)
              ) OR
              ( (DocOffTMP.CtFIID == FIID) AND (DocOffTMP.CtAccount == Account)
              )
            )
          )
           ExistCarry = true;
           Continue_cicle   = false;
        else
           Continue_cicle = Next(DocOffTMP); /*Сортировка по ID*/
        end;
     end;
  end;

  return ExistCarry;
END;

PRIVATE MACRO ОстатокСчета( Chapter:INTEGER, FIID:INTEGER, Account:STRING, CarryDate:DATE )
  if( FIID ) 
     return RestAC(Account, FIID, CarryDate, null, Chapter);
  else
     return RestA(Account, CarryDate, null, Chapter);
  end;
END;

PRIVATE MACRO ВыбратьПарныйСчет( Chapter:INTEGER, FIID:INTEGER, Account:STRING, CarryDate:DATE, ID:INTEGER )
  var PairAccount = НайтиПарныйСчет(Chapter, FIID, Account);

  if( PairAccount == "" )
     return Account;
  end;

  /*Проверить наличие исполненных проводок
    Если по одному из счетов были проводки, а по другому нет, то вернуть тот, по которому были
    Если проводки были по обоим счетам, вернуть "Номер счета"(Account) */
  if( ЕстьПроводкиПоСчету(Chapter, FIID, Account, CarryDate, ID) )
     return Account; /*Праводка была либо только по основному счету, либо по обоим (основному и парному) счетам*/
  elif( ЕстьПроводкиПоСчету(Chapter, FIID, PairAccount, CarryDate, ID) )
     return PairAccount; /*Проводка была только по парному счету*/
  end;

  /*Проводок по счетам не было, 
    Проверить наличие остатков по счетам Account и PairAccount на начало заданной Даты.
    Если по одному счету есть остаток, а по другому  -нет, то вернуть тот, по которому есть.
    Если остатки есть по обоим счетам, вернуть "Номер счета"(Account) */
  if( ОстатокСчета(Chapter, FIID, Account, CarryDate-1) != 0 )
     return Account;
  elif( ОстатокСчета(Chapter, FIID, PairAccount, CarryDate-1) != 0 )
     return PairAccount;
  end;

  /*По счетам нет проводок и остатков на дату*/
  return Account;
END;

PRIVATE MACRO СтатусПарногоСчета( DocOff )
  if( (PairAccModeValue == 0) OR  /*"По 61 инструкции"*/
      (PairAccModeValue == 2)     /*"По 61 инструкции с контролем остатков"*/
    ) 
     DocOff.State = STATE_CORRECTPAIR;
  else
     DocOff.State = STATE_EXECUTE;
  end;
END;

PRIVATE MACRO GetNextDocOffTMPState( State:INTEGER )

  var Query, DataSet;

  Query = " Select t_State, t_DocOffId, t_Id "
        + "   from " + NameFile
        + "  where t_State = " + string(State)
        + " Order By t_State, t_DocOffId, t_Id "; /*по 2 ключу*/

  DataSet = TRsbDataSet(Query);

  if( DataSet.MoveNext() )
     ClearRecord(DocOffTMPState);
     DocOffTMPState.State    = DataSet.State;
     DocOffTMPState.DocOffId = DataSet.DocOffId;
     DocOffTMPState.Id       = DataSet.Id;

     return GetEQ(DocOffTMPState);
  end;

  return false;
END;

PRIVATE MACRO DeleteDocOffTMPByID( Id:INTEGER )

  ClearRecord( DocOffTMP );

  DocOffTMP.Id = Id;

  if( GetEQ( DocOffTMP ) )
     Delete( DocOffTMP );
  end;
END;

PRIVATE MACRO UpdateDocOffTMPByID( DocOff:VARIANT )

  ClearRecord( DocOffTMP );

  DocOffTMP.Id = DocOff.Id;

  if( GetEQ( DocOffTMP ) )
     copy(DocOffTMP, DocOff);
     update(DocOffTMP, null, true);
  end;
END;

PRIVATE MACRO FindDocOffTMPDtCt( Chapter:INTEGER, DtFIID:INTEGER, DtAccount:STRING, CtFIID:INTEGER, CtAccount:STRING, GroundKind:INTEGER )

  ClearRecord(DocOffTMPDtCt);

  DocOffTMPDtCt.Chapter    = Chapter;
  DocOffTMPDtCt.DtFIID     = DtFIID;
  DocOffTMPDtCt.DtAccount  = DtAccount;
  DocOffTMPDtCt.CtFIID     = CtFIID;
  DocOffTMPDtCt.CtAccount  = CtAccount;
  DocOffTMPDtCt.GroundKind = GroundKind;

  if( GetEQ(DocOffTMPDtCt) )
     return DocOffTMPDtCt;
  end;

  return null;
END;

PRIVATE MACRO FindCarryInArray( IdentCarry:TArray, DtKind_Account:STRING, CtKind_Account:STRING )
  var i = 0;

  while( i < IdentCarry.Size )
     if( IdentCarry[i] != null )
        if( ( (DtKind_Account == "") OR
              (  DL_GetAccount( IdentCarry[i].Chapter, IdentCarry[i].DtFIID, IdentCarry[i].DtAccount, rAccount ) AND
                 (rAccount.Kind_Account == DtKind_Account)
              )
            ) AND
            ( (CtKind_Account == "") OR
              (  DL_GetAccount( IdentCarry[i].Chapter, IdentCarry[i].CtFIID, IdentCarry[i].CtAccount, rAccount ) AND
                 (rAccount.Kind_Account == CtKind_Account)
              )
            )
          )
           return IdentCarry[i].Id;
        end;
     end;
     i = i + 1;
  end;

  return 0;
END;

/* Массив IdentCarry содержит от 1 до 4-х записей идентичных по счетам проводок
  Выбираем среди них  главную в порядке следующих приоритетов:
  a.  если оба счета парные - такую, что по Дт  - активный счет, и по Кт -пассивный счет
  b.  если счет по Дт парный -такую, что счет по Дт активный, а по Кт -любой
  c.  если счет по Кт парный -такую, что счет по Кт пассивный, а по Дт -любой
  d.  текущую 
  Оставляем только главную проводку, остальные суммируем к ней и удаляем*/
PRIVATE MACRO СформироватьСуммарнуюПроводку( IdentCarry:TArray )
  var i = 0, MainAccIndex = -1, MainAccID = 0;

  if( IdentCarry[CARRY_PAIR_DTCT] != null ) /*оба счета парные*/
     MainAccID = FindCarryInArray(IdentCarry, dv_bal_acc_active, dv_bal_acc_passive);
  end;

  if( (MainAccID == 0) AND (IdentCarry[CARRY_PAIR_DT] != null) ) /*счет по Дт парный*/
     MainAccID = FindCarryInArray(IdentCarry, dv_bal_acc_active, "");
  end;

  if( (MainAccID == 0) AND (IdentCarry[CARRY_PAIR_CT] != null) ) /*счет по Кт парный*/
     MainAccID = FindCarryInArray(IdentCarry, "", dv_bal_acc_passive);
  end;

  if( MainAccID == 0 )
     MainAccID = IdentCarry[CARRY_CURRENT].Id;
  end;

  i = 0; /*Индекс главной проводки*/
  while( (MainAccIndex < 0) AND (i < IdentCarry.Size) )
     if( (IdentCarry[i] != null) AND (IdentCarry[i].Id == MainAccID) )
        MainAccIndex = i;
     end;
     i = i + 1;
  end;

  i = 0; /*Суммируем к главной остальные*/
  while( i < IdentCarry.Size )
     if( (i != MainAccIndex) AND (IdentCarry[i] != null) )
        IdentCarry[MainAccIndex].DtSumma = IdentCarry[MainAccIndex].DtSumma + IdentCarry[i].DtSumma;
        IdentCarry[MainAccIndex].CtSumma = IdentCarry[MainAccIndex].CtSumma + IdentCarry[i].CtSumma;
        /*удаляем просуммированную проводку*/
        DeleteDocOffTMPByID( IdentCarry[i].Id );
     end;
     i = i + 1;
  end;

  /*На главную проводку ставим статус STATE_COMPARE для дальнейшей обработки в "СверткаПротивоположныхПарныхПроводок"*/
  IdentCarry[MainAccIndex].State = STATE_COMPARE;

  UpdateDocOffTMPByID(IdentCarry[MainAccIndex]);
END;

/* A1, A2 - суммы по Дт и Кт первой проводки
   B1, B2 - суммы по Дт и Кт второй проводки */
PRIVATE MACRO СравнитьСуммы( A1:MONEY, A2:MONEY, B1:MONEY, B2:MONEY )
  if( (A1 == B2) AND (A2 == B1) )
     return 0; /*проводки равны*/
  elif( ( (A1 > B2) AND (A2 > B1) ) )
     return 1; /*первая больше*/
  elif( ( (A1 < B2) AND (A2 < B1) ) )
     return -1; /*первая меньше*/
  else
     return 2; /*нельзя сравнить*/
  end;
END;

PRIVATE MACRO СформироватьРезультирующуюПроводку( Carry:VARIANT, BackCarry:VARIANT )
  var CmpSum;

  if( BackCarry == null )
     СтатусПарногоСчета(Carry);
     UpdateDocOffTMPByID(Carry);
  else
     CmpSum = СравнитьСуммы(Carry.DtSumma, Carry.CtSumma, BackCarry.DtSumma, BackCarry.CtSumma);
     if( CmpSum == 0 ) /*проводки равны, взаимно погасились*/
        DeleteDocOffTMPByID(Carry.Id);
        DeleteDocOffTMPByID(BackCarry.Id);
     elif( CmpSum == 1 ) /*первая больше*/
        СтатусПарногоСчета(Carry);
        Carry.DtSumma = Carry.DtSumma - BackCarry.DtSumma;
        Carry.CtSumma = Carry.CtSumma - BackCarry.CtSumma;
        UpdateDocOffTMPByID(Carry);
        DeleteDocOffTMPByID(BackCarry.Id);
     elif( CmpSum == -1 ) /*вторая больше*/
        СтатусПарногоСчета(BackCarry);
        BackCarry.DtSumma =  BackCarry.DtSumma - Carry.DtSumma;
        BackCarry.CtSumma =  BackCarry.CtSumma - Carry.CtSumma;
        UpdateDocOffTMPByID(BackCarry);
        DeleteDocOffTMPByID(Carry.Id);
     else /*нельзя сравнить, все оставляем как есть*/
        СтатусПарногоСчета(Carry);
        СтатусПарногоСчета(BackCarry);
        UpdateDocOffTMPByID(Carry);
        UpdateDocOffTMPByID(BackCarry);
     end;
  end;
END;

/* Перебирает проводки со статусом STATE_CHECK и из проводок с одинаковыми 
   счетами по Дт и Кт (с учетом возможной парности счетов) оставляет только одну суммарную */
PRIVATE MACRO СверткаИдентичныхПарныхПроводок()
  var NumCarry = 0, DtPairAcc, CtPairAcc,
      IdentCarry = TArray();

  InitProgress(-1, "Выполнение сводных проводок ...", "Свертка идентичных проводок по парным счетам");

  /*Изменяем ключевую последовательность (State), поэтому всегда GetGE*/
  while( GetNextDocOffTMPState(STATE_CHECK) )
     DtPairAcc = НайтиПарныйСчет(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount);
     CtPairAcc = НайтиПарныйСчет(DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount);
     /*Оба счета не парные*/
     if( (DtPairAcc == "") AND (CtPairAcc == "") ) 
        /*Проставить статус STATE_EXECUTE для дальнейшей обработки в "ВыполнитьПроводки"*/
        DocOffTMPState.State = STATE_EXECUTE;
        Update(DocOffTMPState, null, true);
     else
        /*Проверяем, возможно по проводке запрещено использовать парные счета*/
        if( DL_GetAccount(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount, AccountPayer) AND
            DL_GetAccount(DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount, AccountReceiver)
          )
           if( DV_НеИспользоватьПарныеСчета(AccountPayer, AccountReceiver) == true )
              /*Проставить статус STATE_EXECUTE для дальнейшей обработки в "ВыполнитьПроводки"*/
              DocOffTMPState.State = STATE_EXECUTE;
              Update(DocOffTMPState, null, true);
              continue;
           end;
        end; 
        IdentCarry[CARRY_CURRENT] = DocOffTMPState;

        if( DtPairAcc != "" ) /*Счет дебета парный*/
           /*Ищем проводку с таким же Кт и парным Дт*/
           IdentCarry[CARRY_PAIR_DT] = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                                          DocOffTMPState.DtFIID,
                                                          DtPairAcc, 
                                                          DocOffTMPState.CtFIID, 
                                                          DocOffTMPState.CtAccount,
                                                          DocOffTMPState.GroundKind );
        end;

        if( CtPairAcc != "" ) /*Счет кредита парный*/
           /*Ищем проводку с таким же Дт и парным Кт*/
           IdentCarry[CARRY_PAIR_CT] = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                                          DocOffTMPState.DtFIID,
                                                          DocOffTMPState.DtAccount, 
                                                          DocOffTMPState.CtFIID,  
                                                          CtPairAcc,
                                                          DocOffTMPState.GroundKind );
        end;

        if( (DtPairAcc != "") AND (CtPairAcc != "") ) /*Оба счета парные*/
           /*Ищем проводку с таким же парным Дт и парным Кт*/
           IdentCarry[CARRY_PAIR_DTCT] = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                                            DocOffTMPState.DtFIID,
                                                            DtPairAcc, 
                                                            DocOffTMPState.CtFIID,  
                                                            CtPairAcc,
                                                            DocOffTMPState.GroundKind );
        end;

        /*Теперь в массиве IdentCarry имеем от 1 до 4-х записей идентичных по счетам проводок*/
        СформироватьСуммарнуюПроводку(IdentCarry);
     end;

     UseProgress(NumCarry = NumCarry + 1);
  end;

  RemProgress();

  return 0;

OnError( RslErrObj )
  RemProgress();
  return SayError(RslErrObj);
END;

PRIVATE MACRO СверткаПротивоположныхПарныхПроводок()
  var NumCarry = 0, DtPairAcc, CtPairAcc, DtAccount, CtAccount, BackCarry;

  InitProgress(-1, "Выполнение сводных проводок ...", "Свертка противоположных проводок по парным счетам");

  /*Изменяем ключевую последовательность (State), поэтому всегда GetGE*/
  while( GetNextDocOffTMPState(STATE_COMPARE) )
     DtAccount = CtAccount = "";

     DtPairAcc = НайтиПарныйСчет(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount);
     CtPairAcc = НайтиПарныйСчет(DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount);

     if( DtPairAcc != "" ) /*Счет дебета парный*/
        /*Ищем проводку со счетом Кт == парному Дт текущей записи
          и счетом по Дт == Кт текущей записи */
        DtAccount = DocOffTMPState.CtAccount; 
        CtAccount = DtPairAcc;
     end;

     if( CtPairAcc != "" ) /*Счет кредита парный*/
        /*Ищем проводку со счетом Дт == парному Кт текущей записи
          и счетом по Кт == Дт текущей записи */
        DtAccount = CtPairAcc; 
        CtAccount = DocOffTMPState.DtAccount;
     end;                                              

     if( (DtPairAcc != "") AND (CtPairAcc != "") ) /*Оба счета парные*/
        /*Ищем проводку со счетом Дт и Кт парными соответственно 
          счетам Кт и Дт текущей записи*/
        DtAccount = CtPairAcc; 
        CtAccount = DtPairAcc;
     end;
     /*ищем проводку по той же главе, что и текущая и валютам 
       Дт == Кт текущей и Кт == Дт текущей*/
     if( (DtAccount != "") AND (CtAccount != "") )
        BackCarry = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                       DocOffTMPState.CtFIID, DtAccount, 
                                       DocOffTMPState.DtFIID, CtAccount, DocOffTMPState.GroundKind );
     else
        BackCarry = null;
     end;
     СформироватьРезультирующуюПроводку(DocOffTMPState, BackCarry);
     UseProgress(NumCarry = NumCarry + 1);
  end;

  RemProgress();

  return 0;

OnError( RslErrObj )
  RemProgress();
  return SayError(RslErrObj);
END;

PRIVATE MACRO КорректироватьПарныеСчета( CarryDate:DATE )
  var NumCarry = 0;

  InitProgress(-1, "Выполнение сводных проводок ...", "Корректировка парных счетов");

  /*Изменяем ключевую последовательность (State), поэтому всегда GetGE*/
  while( GetNextDocOffTMPState(STATE_CORRECTPAIR) )

     DocOffTMPState.DtAccount = ВыбратьПарныйСчет( DocOffTMPState.Chapter, 
                                                   DocOffTMPState.DtFIID, 
                                                   DocOffTMPState.DtAccount, 
                                                   CarryDate, 
                                                   DocOffTMPState.ID );
                    
     DocOffTMPState.CtAccount = ВыбратьПарныйСчет( DocOffTMPState.Chapter, 
                                                   DocOffTMPState.CtFIID, 
                                                   DocOffTMPState.CtAccount, 
                                                   CarryDate, 
                                                   DocOffTMPState.ID );

     DocOffTMPState.State = STATE_EXECUTE;
     UpdateDocOffTMPByID(DocOffTMPState);
     UseProgress(NumCarry = NumCarry + 1);
  end;

  RemProgress();

  return 0;

OnError( RslErrObj )
  RemProgress();
  return SayError(RslErrObj);
END;

PRIVATE MACRO ВыполнитьПроводки( FD, Doc:VARIANT, DateCarry:DATE )
  var continue_cicle, Error = 0, NumCarry = 0, Ground = "";

  InitProgress(-1, "Выполнение сводных проводок по сделкам ...", "Выполнение сводных проводок");

  ClearRecord(DocOffTMPState);

  DocOffTMPState.State = STATE_EXECUTE;

  continue_cicle = GetGE(DocOffTMPState);
  while( continue_cicle AND (DocOffTMPState.State == STATE_EXECUTE) )
     if( DL_GetAccount(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount, AccountPayer) AND
         DL_GetAccount(DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount, AccountReceiver)
       )
        if( (DV_ПолучитьПараметрыСводнойПроводки(AccountPayer, AccountReceiver, DocOffTMPState.GroundKind, null, null, Ground, DocOffTMPState.ClientContrID) == false) OR
            (Ground == "")
          )
           Ground = "Сводная проводка на ОРЦБ";

           if( DocOffTMPState.ClientContrID > 0 )
              var sfcontr = GetSfContr(DocOffTMPState.ClientContrID);
              Ground = Ground + " по договору клиента \"" + sfcontr.rec.number + "\"";
           end;
        end;
        var DtPairAcc = НайтиВстречныйСчет(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount);
        var CtPairAcc = НайтиВстречныйСчет(DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount);

        var BackCarry = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                           DocOffTMPState.CtFIID, CtPairAcc, 
                                           DocOffTMPState.DtFIID, DtPairAcc, DocOffTMPState.GroundKind );
        if (BackCarry != null)
            DL_GetAccount(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, BackCarry.CtAccount, AccountPayer);
            DocOffTMPState.DtFIID =  AccountPayer.code_currency;
            DL_GetAccount(DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount, AccountReceiver);
            DocOffTMPState.CtFIID =  AccountReceiver.code_currency; 
            DocOffTMPState.DtSumma = max(DocOffTMPState.DtSumma, BackCarry.CtSumma); 
            DocOffTMPState.CtSumma = DocOffTMPState.DtSumma; 
        end;
       
        if (DocOffTMPState.CtFIID == DocOffTMPState.DtFIID)
        if( not ПроводкаПоКатегориямУчета( FD,
                                           AccountPayer, AccountReceiver,
                                           DateCarry,
                                           DocOffTMPState.Chapter, 
                                           DocOffTMPState.DtFIID,
                                           DocOffTMPState.DtSumma,
                                           Doc,
                                           INPCARRY,
                                           " 1",
                                           "",
                                           Ground,
                                           null,null,null,
                                           DocOffTMPState.DtFIID, DocOffTMPState.CtFIID,
                                           DocOffTMPState.CtFIID, DocOffTMPState.CtSumma,
                                           null, null, null, null,
                                           null, null, null, null,
                                           null, null, null, null, null,
                                           true
                                         )
          )
           Error = 1;
        end;
     end;
     end;

     if( Error == 0 )
        continue_cicle = Next(DocOffTMPState);
     else
        continue_cicle = false;
     end;

     UseProgress(NumCarry = NumCarry + 1);
  end;

  RemProgress();

  return Error;
END;

PRIVATE MACRO ПроводкиПоУчетуВзаимТребОбязПоВАлюте( FD, Doc:VARIANT, DateCarry:DATE, BalanceAcc:string, FIID:integer )
  var ExchangePlus = TRecHandler("account"), ExchangeMinus = TRecHandler("account"), ForvardAcc = TRecHandler("account");
  var DebAcc, CredAcc, Ground = "", Query = "";

  var sql = DL_RSDCommand();

  if( BalanceAcc == "47408" )
     Query =  " select docoff.T_DTACCOUNT T_ACCOUNT, "
             +"        nvl(sum(DOCOFF.T_DTSUMMA),0) T_SUMMA "   
             +"   from ddocoff_tmp docoff "                                                                                                                        
             +"  where substr(docoff.T_DTACCOUNT,1,5) = ? "
             +"    and docoff.T_DTFIID = ? "
             +"    and substr(docoff.T_CTACCOUNT,1,5) = '47407' "                                                                      
             +"    and docoff.t_State = ? "                                       
             +" group by docoff.T_DTACCOUNT "
             +" having sum(DOCOFF.T_DTSUMMA) != 0 ";
  else
     Query =  " select docoff.T_CTACCOUNT T_ACCOUNT, "
             +"        nvl(sum(DOCOFF.T_CTSUMMA),0) T_SUMMA "   
             +"   from ddocoff_tmp docoff "                                                                                                                        
             +"  where substr(docoff.T_CTACCOUNT,1,5) = ? "
             +"    and docoff.T_CTFIID = ? "
             +"    and substr(docoff.T_DTACCOUNT,1,5) = '47408' "                                                                      
             +"    and docoff.t_State = ? "                                       
             +" group by docoff.T_CTACCOUNT "
             +" having sum(DOCOFF.T_CTSUMMA) != 0 ";
  end;


  sql.addParam( BalanceAcc );
  sql.addParam( FIID );
  sql.addParam( STATE_EXECUTE );

  var DataSet = sql.execute(Query);

  while( DataSet.MoveNext() )
     if( DL_GetAccount(1, FIID, DataSet.Account, ForvardAcc) )
        if( substr(DataSet.ACCOUNT,1,5) == "47408" )
           if( (ExchangePlus.rec.AccountID <= 0) and
               (not FD.IsExistAccount("+Биржа", null, true, null, ExchangePlus, null, DateCarry, FIID)) and
               (not FD.OpenAccount("+Биржа", null, false, null, ExchangePlus, DateCarry, FIID))
             )
              return 1;
           end;
           DebAcc  = ExchangePlus;
           CredAcc = ForvardAcc;
           Ground  = "Учет итогового требования";
        else
           if( (ExchangeMinus.rec.AccountID <= 0) and
               (not FD.IsExistAccount("-Биржа", null, true, null, ExchangeMinus, null, DateCarry, FIID)) and
               (not FD.OpenAccount("-Биржа", null, false, null, ExchangeMinus, DateCarry, FIID))
             )
              return 1;
           end;
           DebAcc  = ForvardAcc;
           CredAcc = ExchangeMinus;
           Ground  = "Учет итогового обязательства";
        end;
        if( not ПроводкаПоКатегориямУчета( FD,
                                           DebAcc, CredAcc,
                                           DateCarry,
                                           1,
                                           FIID, abs(DataSet.Summa),
                                           doc,
                                           INPCARRY, "", "",
                                           Ground
                                         )
          )
           return 1;
        end;
     end;
  end;

  return 0;
END;

PRIVATE MACRO ПроводкиПоУчетуВзаимТребОбязПоВАлюте_( FD, Doc:VARIANT, DateCarry:DATE, FIID:integer )
  var ForvardCredAcc = TRecHandler("account"), ForvardDebAcc = TRecHandler("account");
  var ExchangePlus = TRecHandler("account"), ExchangeMinus = TRecHandler("account"), ForvardAcc = TRecHandler("account");
  var DebAcc, CredAcc, SummCarry = 0, SummCarry_08 = 0, SummCarry_07 = 0, Ground = "", Query = "";
  var is_Exist = false;
  var sql = DL_RSDCommand();

  Query =  " select docoff.T_CTACCOUNT T_ACCOUNT, "
          +"        nvl(sum(DOCOFF.T_CTSUMMA),0) T_SUMMA "   
          +"   from ddocoff_tmp docoff "                                                                                                                        
          +"  where docoff.T_CTFIID = ? "
          +"    and substr(docoff.T_CTACCOUNT,1,5) = '47407' "                                                                      
          +"    and SUBSTR (docoff.T_CTACCOUNT, 16, 5) = '00002' "
          +"    and docoff.t_State = ? "                                       
          +" group by docoff.T_CTACCOUNT "
          +" having sum(DOCOFF.T_DTSUMMA) != 0 "
          " Union all select docoff.T_DTACCOUNT T_ACCOUNT, "
          +"        nvl(sum(DOCOFF.T_DTSUMMA),0) T_SUMMA "   
          +"   from ddocoff_tmp docoff "                                                                                                                        
          +"  where docoff.T_DTFIID = ? "
          +"    and substr(docoff.T_DTACCOUNT,1,5) = '47408' "                                                                      
          +"    and SUBSTR (docoff.T_DTACCOUNT, 16, 5) = '00002' "
          +"    and docoff.t_State = ? "                                       
          +" group by docoff.T_DTACCOUNT "
          +" having sum(DOCOFF.T_CTSUMMA) != 0 ";


  sql.addParam( FIID );
  sql.addParam( STATE_EXECUTE );
  sql.addParam( FIID );
  sql.addParam( STATE_EXECUTE );

  var DataSet = sql.execute(Query);

  while( DataSet.MoveNext() )
        is_Exist = true;
        if( substr(DataSet.ACCOUNT,1,5) == "47408" )
           SummCarry = SummCarry + abs(DataSet.Summa);
           SummCarry_08 = abs(DataSet.Summa);
           CredAcc = DataSet.ACCOUNT;    
        elif( substr(DataSet.ACCOUNT,1,5) == "47407" )
           SummCarry = SummCarry - abs(DataSet.Summa);
           DebAcc = DataSet.ACCOUNT;
           SummCarry_07 = abs(DataSet.Summa);
        end;
        SummCarry = min(SummCarry_08, SummCarry_07);
  end;
  if (DebAcc != null) 
      DL_GetAccount(1, FIID, DebAcc, ForvardDebAcc)
  end;

  if (CredAcc != null) 
      DL_GetAccount(1, FIID, CredAcc, ForvardCredAcc)
  end;

  if(  (not FD.IsExistAccount("Клиринговый счетВ", null, true, null, ExchangePlus, null, DateCarry, FIID)) and
       (not FD.OpenAccount("Клиринговый счетВ", null, false, null, ExchangePlus, DateCarry, FIID))
     )
     return 1;
  end;

  if( (not FD.IsExistAccount("Клиринговый счетВ3", null, true, null, ExchangeMinus, null, DateCarry, FIID)) and
      (not FD.OpenAccount("Клиринговый счетВ3", null, false, null, ExchangeMinus, DateCarry, FIID))
     )
     return 1;
  end;

  Ground  = "Учет итогового требования";

  if (is_Exist)
      if ( (DebAcc != null) and (CredAcc != null) )
           Ground  = "Учет итогового требования";
           if( not ПроводкаПоКатегориямУчета( FD,
                                              ForvardDebAcc, ForvardCredAcc,
                                              DateCarry,
                                              1,
                                              FIID, abs(SummCarry),
                                              doc,
                                              INPCARRY, "", "",
                                             Ground
                                            )
              )
              return 1;
           end;
     end;
     if (SummCarry_08 > SummCarry_07)
           DebAcc  = ExchangePlus;
           CredAcc = ForvardCredAcc;
           SummCarry = SummCarry - SummCarry_08;
     elif (SummCarry_07 > SummCarry_08)
           DebAcc  = ForvardDebAcc;
           CredAcc = ExchangePlus;
           SummCarry = SummCarry - SummCarry_07;
     end;
     if( not ПроводкаПоКатегориямУчета( FD,
                                        DebAcc, CredAcc,
                                        DateCarry,
                                        1,
                                        FIID, abs(SummCarry),
                                        doc,
                                        INPCARRY, "", "",
                                        Ground
                                       )
          )
           return 1;
    end;
  end;

  return 0;
END;

PRIVATE MACRO ПроводкиПоУчетуВзаимТребОбяз( FD, Doc:VARIANT, DateCarry:DATE )
  var sql = DL_RSDCommand( " SELECT T_CODEFI "
                          +"   FROM DDL_TOTALOFFI_DBT "
                          +"  WHERE T_DOCKIND = ?  "
                          +"    AND T_DOCID   = ?  "
                          +"    AND T_SETTLEMENTEND != 'X' "
                          +"    AND T_PARENT = " + IIF(FD.Kind == DL_DVCURMARKET, "!= 0", "= 0") 
                         ); 

  sql.addParam( FD.Kind );
  sql.addParam( FD.ID );

  var DataSet = sql.execute();
  while( DataSet.MoveNext() )
    if (DL_ЕдиныйПулОбеспеченияСобств == 1)
       if( ПроводкиПоУчетуВзаимТребОбязПоВАлюте_(FD, Doc, DateCarry, DataSet.CODEFI) )
           return 1;
       end;
    else
     if( ПроводкиПоУчетуВзаимТребОбязПоВАлюте(FD, Doc, DateCarry, "47408", DataSet.CODEFI) )
        return 1;
     end;
     if( ПроводкиПоУчетуВзаимТребОбязПоВАлюте(FD, Doc, DateCarry, "47407", DataSet.CODEFI) )
        return 1;
     end;
  end;
  end;

  return 0;
END;

MACRO ВыполнитьСводныеПроводки( FD, Doc:VARIANT, PartyID:INTEGER, DateCarry:DATE )
  var errcode, errtext, TmpFName = GetWorkFileName("docoff");
  var continue_cicle, Error = 0;
  var marketKind, partyOffice;
  var FilterFI = "", CountFI = "";

  GetRegistryValue(REG_PAIRACCMODE, V_INTEGER, PairAccModeValue, errcode);
  if( errcode != 0 )
     MsgBox( "Ошибка при получении значения настройки \"" + REG_PAIRACCMODE + "\"");
     return 1;
  end;
  if( StrUpr(GenClassName(FD)) == StrUpr("DVFirstDocDLCOMM") )
     var firstFI = true;
     marketKind = DL_MARKETKIND_SETTLE_CURRENCY;
     partyOffice = -1/*FD.Comm.rec.PartyOfficeID*/;/*Схема расчетов, указанная в параметрах сервисной операции, на формирование сводных проводок не влияет*/
     var sql = RSDCommand(
        " SELECT T_CODEFI " +
         "   FROM DDL_TOTALOFFI_DBT    " +
             "    WHERE T_DOCKIND = ?  " +
             "    AND   T_DOCID   = ?  " +
             "    AND   T_SETTLEMENTEND != 'X' "+ 
             "    AND   T_PARENT = " + IIF(FD.Kind == DL_DVCURMARKET, "!= 0", "= 0") );

     sql.addParam( "", RSDBP_IN, FD.Kind );
     sql.addParam( "", RSDBP_IN, FD.ID );
     sql.execute();
     var DealRec = TRsbDataSet( sql );

     while( DealRec.MoveNext() )
        if (DealRec.CodeFI == NATCUR)
           FilterFI = " (t_currency_payer = t_currency_receiver and t_currency_receiver = 0 ) ";   
        elif (firstFI)
           CountFI = CountFI + "( " + DealRec.CodeFI;
           firstFI = false;   
        else
           CountFI = CountFI + ", " + DealRec.CodeFI;
        end;
     end;
     if (CountFI != "")
        if(FilterFI != "")
           FilterFI = FilterFI + " or ";
        end;
        FilterFI = " AND (" + FilterFI + " (t_currency_payer IN "+ CountFI +") or t_currency_receiver IN "+ CountFI +"))) ";
     elif (FilterFI != "")
        FilterFI = " AND " + FilterFI; 
     end;
  else
     marketKind = FD.GetMarketKind();
     partyOffice = FD.DVOper.rec.PartyOffice;
  end;
  ClearGlobalTmp("ddocoff_tmp");

  /*Заполнение временного файла */
  spdocoff.Clear();
  spdocoff.AddFilter(" t_MarketKind         = " + marketKind
                   + " and t_PartyID        = " + string(PartyID)
                   + IIF(partyOffice > 0," and t_OfficeID       = " + string(partyOffice),"")
                   + " and t_State          = " + string(SPDOCOFF_STATE_PREPARED)
                   + " and t_Date_Carry     = " + GetSQLDate(DateCarry)
                   + " and t_Chapter not in (21,22,5)"
                   + " and t_IsClientCarry " + IIF(FD.IsClient(), "=", "<>") + "chr(88) " + FilterFI
                    );

  spdocoff.Rewind;

  continue_cicle = spdocoff.Next;
  while( continue_cicle )
     Error = AddInDocOffTMP();

     if( Error == 0 )   
        continue_cicle = spdocoff.Next();
     else
        continue_cicle = false;
     end;
  end;
  spdocoff.DropFilter();

  /*Получим название временной базы*/
  NameFile = FileName(DocOffTMPState);
  NameFile = "d" + NameFile;
  NameFile = StrSubst(NameFile, ".", "_");

  if( Error == 0 )
     Error = СверткаИдентичныхПарныхПроводок();
  end;

  if( Error == 0 )
     Error = СверткаПротивоположныхПарныхПроводок();
  end;

  if( Error == 0 )
     Error = КорректироватьПарныеСчета(DateCarry);
  end;

  if( Error == 0 )
     if (DL_ЕдиныйПулОбеспеченияСобств == 0)
     Error = ВыполнитьПроводки(FD, Doc, DateCarry);
  end;
  end;

  if( Error == 0 )
     Error = ПроводкиПоУчетуВзаимТребОбяз(FD, Doc, DateCarry);
  end;

  return Error;
END;
