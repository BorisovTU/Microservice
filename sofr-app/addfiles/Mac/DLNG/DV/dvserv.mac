/*
$Name:             dvserv.mac
$Module:           Производные инструменты
$Description:      ПРОЦЕДУРЫ ДЛЯ ОПЕРАЦИЙ С ПИ                                               
*/
  
IMPORT CurrInter, DVInter, FIInter, PaymInter, CTInter, SfInter, OprInter, DealsInter, BankInter, SPInter, globals, Календарь, "dlcnst.inc", "MoCommon.mac",
       "dlmisc.mac", "dldlngfun.mac";
IMPORT RsbDataSet, "cb_sql.mac";
/*Виды опционов*/
CONST OPTIONKIND_PUT          = 1, /* Опцион put*/
      OPTIONKIND_CALL         = 2; /* Опцион call*/

CONST DV_RATETYPE_CBR             = -1, /*вид курса ЦБР из панели настроек*/
      DV_RATETYPE_MARKET_PRICE_AR = -2; /*Вид курса для расчета цены артикула*/

/*Категории КО операции*/
CONST DV_FXOPER_OBJGROUP_CASHSYMBOL_IN  = 3,/*Приходный кассовый символ*/
      DV_FXOPER_OBJGROUP_CASHSYMBOL_OUT = 4;/*Расходный кассовый символ*/

/*значение настройки "Обнулять итоги по нулевой нетто-позиции"*/
macro ОбнулятьИтоги()
   var ErrCode, Path = "", NullingTurns;

   Path = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ОБНУЛЯТЬ ИТОГИ";

   GetRegistryValue( Path, V_INTEGER, NullingTurns, ErrCode );
   if( ErrCode != 0 )
      NullingTurns = 1; /*по умолчанию - по фьючерсам*/
   end;
   return NullingTurns;
end;

/*значение настройки "Сворачивать позиции при исполнении контрактов"*/
macro СворачиватьПозиции()

   var ErrCode, Path = "", TurnPositions;

   Path = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\СВОРАЧИВАТЬ ПОЗИЦИИ";

   GetRegistryValue( Path, V_INTEGER, TurnPositions, ErrCode );
   if( ErrCode != 0 )
      TurnPositions = 1; /*по умолчанию - по фьючерсам*/
   end;
   return TurnPositions;
end;

macro ПИ_ПолучитьВидКурса( RateType:Integer )
   var ErrCode, Path = "", NewRateType;

   if( RateType == RATETYPE_MARKET_PRICE ) /* вид курса Рыночная цена        */
      Path = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВИД КУРСА \"РЫНОЧНАЯ ЦЕНА\"";
   elif( RateType == RATETYPE_CALC_PRICE )  /* вид курса Расчетная цена*/
      Path = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВИД КУРСА \"РАСЧЕТНАЯ ЦЕНА\"";
   elif( RateType == DV_RATETYPE_CBR )
      Path = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВИД КУРСА \"КУРС ЦБ РФ\"";
   elif( RateType == DV_RATETYPE_MARKET_PRICE_AR )
      Path = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВИД КУРСА РАСЧЕТА ЦЕНЫ АРТИКУЛА";
   end;

   GetRegistryValue( Path, V_INTEGER, NewRateType, ErrCode );
   if( ErrCode != 0 )
      if( RateType == DV_RATETYPE_CBR )
         NewRateType = 0; /* использовать основной курс */
      else
         NewRateType = RateType;
      end;
   end;
   return NewRateType;
end;      

/*получить значение настройки - СОЗДАВАТЬ ЗАПИСЬ ИТОГОВ ДНЯ*/
macro СоздаватьЗаписьИтоговПриНулевыхОборотах()       
   var ErrCode, CreateTurns = false;
   GetRegistryValue( "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\СОЗДАВАТЬ ЗАПИСЬ ИТОГОВ ДНЯ", V_BOOL, CreateTurns, ErrCode );
   if( ErrCode != 0 )
      CreateTurns = false; 
   end;
   return CreateTurns; 
end;

/*получить значение настройки - ПРОВОДКИ ПО ДОХОДАМ И РАСХОДАМ */
/* 0  -  Доходы и расходы                                      */
/* 1  -  Сводная проводка                                      */
macro ПроводкиПоДоходамИРасходам()
   var ErrCode, Carry = 0;
   GetRegistryValue( "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ПРОВОДКИ ПО ДОХОДАМ И РАСХОДАМ", V_INTEGER, Carry, ErrCode );
   if( ErrCode != 0 )
      Carry = 0; 
   end;
   return Carry; 
end;

/*получить значение настройки - ВЫПОЛНЯТЬ СДЕЛКИ ДО НАЧАЛА РАСЧЕТОВ  */
/* разрешать или нет выполнять сделки до начала операции расчетов    */
macro ВыполнятьСделкиДоНачалаОперацииРасчетов()
   var ErrCode, CloseDeal = false;
   GetRegistryValue( "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВЫПОЛНЯТЬ СДЕЛКИ ДО РАСЧЕТОВ", V_BOOL, CloseDeal, ErrCode );
   if( ErrCode != 0 )
      CloseDeal = false; 
   end;
   return CloseDeal; 
end;

/*получить значение настройки - ГАРАНТИЙНОЕ ОБЕСПЕЧЕНИЕ            */
/* формировать или нет проводки по учету гарантийного обеспечения  */   
macro ПроводкиПоУчетуГарантийногоОбеспечения()
   var ErrCode, MakeGuaranty = false;
   GetRegistryValue( "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ГАРАНТИЙНОЕ ОБЕСПЕЧЕНИЕ", V_BOOL, MakeGuaranty, ErrCode );
   if( ErrCode != 0 )
      MakeGuaranty = false; 
   end;
   return MakeGuaranty; 
end;

MACRO ПечатьНомеровСделокВУ():BOOL
  VAR ErrCode = 0, PrintDealCode = false;

  GetRegistryValue( "COMMON\\ВНУТРЕННИЙ УЧЕТ\\ПЕЧАТЬ НОМЕРОВ СДЕЛОК", V_BOOL, PrintDealCode, ErrCode );
  if( ErrCode != 0 )
     PrintDealCode = false;
  end;
  return PrintDealCode;
END;

MACRO ПИ_ВестиВнутреннийУчет():BOOL
  VAR ErrCode = 0, MakeInAcc = false;

  GetRegistryValue( "COMMON\\ВНУТРЕННИЙ УЧЕТ\\ФОРМИРОВАНИЕ ПРОВОДОК", V_BOOL, MakeInAcc, ErrCode );
  if( ErrCode != 0 )
     MakeInAcc = false;
  end;
  return MakeInAcc;
END;

PRIVATE VAR DV_UseCalculateByDeal = NULL;
MACRO ПИ_ВестиПосделочныйУчетКомиссий():BOOL
  VAR ErrCode = 0;

  if( DV_UseCalculateByDeal == NULL ) 
     GetRegistryValue( "COMMON\\ВНУТРЕННИЙ УЧЕТ\\ОПЛАТА ПЕРИОДИЧЕСКИХ КОМИССИЙ", V_BOOL, DV_UseCalculateByDeal, ErrCode );
     if( ErrCode != 0 )
        DV_UseCalculateByDeal = false;
     end;
  end;
  return DV_UseCalculateByDeal;
END;

PRIVATE VAR DV_UseCarryOnStepInORCB = 1;
MACRO ВУ_ПроводкиВводаВыводаДСНаОРЦБ():INTEGER
  VAR ErrCode = 0;
  GetRegistryValue( "COMMON\\ВНУТРЕННИЙ УЧЕТ\\ПЕРЕВОД СРЕДСТВ В ОПЕР РАСЧ", V_INTEGER, DV_UseCarryOnStepInORCB, ErrCode );
  if( ErrCode != 0 )
     DV_UseCarryOnStepInORCB = 1;
  end;
  return DV_UseCarryOnStepInORCB;
END;

MACRO ПереоценкаПоРасчетнойЦене():INTEGER
   var ErrCode, KindDeriv = 0;
   GetRegistryValue( "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ПЕРЕОЦЕНКА ПО РАСЧЕТНОЙ ЦЕНЕ", V_INTEGER, KindDeriv, ErrCode );
   if( ErrCode != 0 )
      KindDeriv = 0; 
   end;
   return KindDeriv;
END;

MACRO ВИД_КУРСА_ДЛЯ_ОЦЕНКИ_СС_ФЬЮЧЕРСА():integer
  var CourseTypeCCFut;
  CONST RegPath = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВИД КУРСА ОЦЕНКИ СС ФЬЮЧЕРСА";
  VAR   err;

  GetRegistryValue( RegPath, V_INTEGER, CourseTypeCCFut, err );
  if( err != 0 )
     MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
  end;

  return CourseTypeCCFut;
END;

MACRO ВИД_КУРСА_ДЛЯ_ОЦЕНКИ_СС_ОПЦИОНА():integer
  var CourseTypeCCOpt;
  CONST RegPath = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ВИД КУРСА ОЦЕНКИ СС ОПЦИОНА";
  VAR   err;

  GetRegistryValue( RegPath, V_INTEGER, CourseTypeCCOpt, err );
  if( err != 0 )
     MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
  end;

  return CourseTypeCCOpt;
END;

MACRO ГенерацияСделокБОЦБ_Бирж():BOOL
  var CreateDeals = false;
  CONST RegPath = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ГЕНЕРАЦИЯ БИРЖЕВЫХ СДЕЛОК БОЦБ";
  VAR   err;

  GetRegistryValue( RegPath, V_BOOL, CreateDeals, err );
  if( err != 0 )
     MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
  end;

  return CreateDeals;
END;

MACRO ГенерацияСделокБОЦБ_ВНЕБирж():BOOL
  var CreateDeals = false;
  CONST RegPath = "ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ГЕНЕРАЦИЯ ВНЕБИРЖ СДЕЛОК БОЦБ";
  VAR   err;

  GetRegistryValue( RegPath, V_BOOL, CreateDeals, err );
  if( err != 0 )
     MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
  end;

  return CreateDeals;
END;

MACRO DV_CheckComissOver50905()
  var ErrCode, RetMode;

  GetRegistryValue("SECUR\\КОМИССИИ НА 50905", V_BOOL, RetMode, ErrCode);

  return RetMode and (ErrCode == 0);
END;

MACRO DV_CheckPriorPortf():integer
  var PriorPortf;
  CONST RegPath = "SECUR\\МСФО\\ПОРТФЕЛЬ ПО УМОЛЧАНИЮ";
  VAR   err;

  GetRegistryValue( RegPath, V_INTEGER, PriorPortf, err );
  if( err != 0 )
     PriorPortf = -1;
     MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
  end;

  return PriorPortf;
END;

MACRO DV_CreateMarginPaymSWAP():BOOL
  var ErrCode, RetMode = true;

  GetRegistryValue("ПРОИЗВОДНЫЕ ИНСТРУМЕНТЫ\\ПЛАТЕЖ ПО ВМ В БИРЖ.ВАЛ.СВОПЕ", V_BOOL, RetMode, ErrCode);

  if( ErrCode != 0 )
     RetMode = true; 
  end;

  return RetMode;
END;

/*** Работа с курсами валют *************************************************/

PRIVATE MACRO ПИ_ПолучитьПрямойКурсПоТипу( RateRec, RateDate:DATE, fiidTo:INTEGER, fiidFrom:INTEGER, Type:INTEGER ):INTEGER
  VAR Data, Query, ErrorFlag = -1;

  if( Type > 0 )
     Query = RSDCommand(
               "SELECT t_rateid "+
               "  FROM (SELECT t_rateid "+
               "            FROM (SELECT rate.t_rateid, rate.t_sincedate "+
               "                    FROM dratedef_dbt rate "+
               "                   WHERE rate.t_otherfi = ? "+ /*string(Fiid_from) */
               "                     AND rate.t_FIID    = ? "+ /*string(FIIDT_to) */
               "                     AND rate.t_type    = ? "+ /*string(type) */
               "                     AND t_sincedate    = (SELECT MAX (t_sincedate) "+
               "                                             FROM dratedef_dbt "+
               "                                            WHERE     t_otherfi = rate.t_otherfi "+
               "                                                  AND t_type    = rate.t_type  "+
               "                                                  AND t_sincedate <= ? "+ /*RateDate*/
               "                                          ) "+
               "                  UNION "+
               "                    SELECT r.t_rateid, h.t_sincedate "+
               "                      FROM dratehist_dbt h, dratedef_dbt r "+
               "                     WHERE     r.t_rateid    = h.t_rateid "+
               "                           AND r.t_otherfi   = ? "+  /*string(Fiid_from) */
               "                           AND r.t_FIID      = ? "+ /*string(FIIDT_to) */
               "                           AND r.t_type      = ? "+ /*string(type) */
               "                           AND h.t_sincedate = ( SELECT MAX (h2.t_sincedate) "+
               "                                                   FROM dratehist_dbt h2, dratedef_dbt r2 "+
               "                                                  WHERE r2.t_rateid  = h2.t_rateid "+
               "                                                    AND r2.t_otherfi = r.t_otherfi "+
               "                                                    AND r2.t_type    = r.t_type  "+
               "                                                    AND h2.t_sincedate <= ?  "+ /*RateDate*/
               "                                               ) "+
               "                 ) "+
               "        ORDER BY t_sincedate DESC "+
               "       ) "+
               " WHERE ROWNUM = 1 "
                       );

    Query.addParam( "", RSDBP_IN, fiidFrom );
    Query.addParam( "", RSDBP_IN, fiidTo );
    Query.addParam( "", RSDBP_IN, Type );
    Query.addParam( "", RSDBP_IN, RateDate );
    Query.addParam( "", RSDBP_IN, fiidFrom );
    Query.addParam( "", RSDBP_IN, fiidTo );
    Query.addParam( "", RSDBP_IN, Type );
    Query.addParam( "", RSDBP_IN, RateDate );
    Query.execute();

    Data = TRsbDataSet( Query );
    if( Data.MoveNext() )
        ErrorFlag = ПолучитьКурс( RateRec, SQL_ConvTypeInteger( Data.rateid ) ); 
    end;
  end;

  return ErrorFlag;
END;  

PRIVATE MACRO ПИ_ПолучитьКурсПоТипу( RateRec, RateDate:DATE, fiidTo:INTEGER, fiidFrom:INTEGER, Type:INTEGER ):INTEGER
   VAR ErrorFlag = ПИ_ПолучитьПрямойКурсПоТипу( RateRec, RateDate, fiidTo, fiidFrom, Type );

   if( ErrorFlag )
      ErrorFlag = ПИ_ПолучитьПрямойКурсПоТипу( RateRec, RateDate, fiidFrom, fiidTo, Type );
      if( not ErrorFlag )
        if(RateRec.IsInverse == SET_CHAR)
           RateRec.IsInverse = UNSET_CHAR;
        else
           RateRec.IsInverse = SET_CHAR;
        end;
      end;
   end;

   return ErrorFlag;
END; 


/* Получить коэффициент перевода суммы из одной валюты в другую.
   Возвращаем double. Если произошла ошибка, то вернем 0. Найти коэффицент
   через обратный курс не пытаемся.
      ADate    - Дата, на которую брать курс
      fiidFrom - Из какой валюты.
      fiidTo   - В какую валюту.
      SayError - Флаг. Если задан, то в случае ошибки выводим сообщение
                 пользователю.
      Type     - Тип курса. Если не задан или 0, то берем основной курс.
      Error    - Флаг. Запишем сюда true, если произошла ошибка. 
      SinceDate   - дата начала действия курса*/
private macro DV_GetRateOnDate( ADate, fiidFrom, fiidTo, SayError, Type, Error, SinceDate )

   /* Получить коэффициент. */
   macro CalcK( RateRec )
      return RateRec.Rate / RateRec.Scale / pow(10, RateRec.Point);
   end;

   record RateRec(ratedef);

   var
      FaceValue, FaceFIID, K,
      ErrorFlag   = false;

   if( fiidTo == fiidFrom )
      /* Валюты совпадают. */
      SetParm( 5, false );
      return 1.0;
   end;

   /* Если тип курса не задан, то берем основной. */
   if( (Type == null) or (Type == 0) )
      ErrorFlag = ПолучитьКурс( RateRec, fiidTo, fiidFrom );
   else
      ErrorFlag = ПИ_ПолучитьКурсПоТипу( RateRec, ADate, fiidTo, fiidFrom, Type );
   end;

   if(   (not ErrorFlag)
         and (ПолучитьЗначениеКурса( RateRec, ADate ) == 0)
         and (RateRec.OtherFI == fiidFrom) 
         )

      /* Курс нашли. Надо проверить признак обратной котировки и признак
         относительного курса. Сразу оба не могут быть установлены.
         Проверка RateRec.OtherFI == fiidFrom нужна, т.к. функция
         ПолучитьКурс иногда, но не всегда, берет обратный курс, а нам
         это не надо. */
      if( fiidTo == -1 ) /*Если просили курс к чему нибудь*/
         fiidTo = RateRec.FIID;
         SetParm( 2, fiidTo );
      end;

      SinceDate = RateRec.SinceDate;
      if( RateRec.IsInverse == SET_CHAR )
         /* Обратная котировка. */
         if( CalcK(RateRec) == 0.0 )
            K = 0.0;
         else
            K = 1.0 / CalcK(RateRec);
         end;
      elif( RateRec.IsRelative == SET_CHAR )
         /* Относительная цена */
         FaceValue = 0.0;
         if( (FI_GetNominal(RateRec.OtherFI, FaceValue, FaceFIID) == 0) and (FaceFIID == fiidTo) )
            SP_GetNominal(fiidFrom, ADate + 1, FaceValue, BO_CB);
            if( FaceValue > 0.0 )
               K = CalcK(RateRec) / 100 * FaceValue;
            end;
         else
            ErrorFlag = true;
         end;
      else
         /* Обычный случай. */
         K = CalcK(RateRec);
      end;
   else
      K = 0.0;
      ErrorFlag = true;
   end;

   if( ErrorFlag and SayError )
      Msgbox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;
   
   SetParm( 5, ErrorFlag );
   SetParm( 6, SinceDate );
   return K;
end;

/* Конвертация суммы типа double другую валюту. Проверяем прямой и обратный
   курс. Функциональность аналогична функции ConvSum из FIInter.
      SumToDbl    - Сюда запишем результат. Double.
      SumFromDbl  - Сумма для конвертации. Double.
      ADate       - Дата, на которую брать курс.
      fiidFrom    - Из какой валюты.
      fiidTo      - В какую валюту.
      SayError    - Флаг. Выдавать сообщения об ошибке. Если не задан, то
                    сообщения не выдаем.
      Type        - Тип курса. Integer. Если не задан или 0, то берем основной
                    курс.
      SinceDate   - дата начала действия курса
   В случае ошибки возвращаем False, в SumToDbl устанавливаем 0. */
private macro DV_ConvSumDbl( SumToDbl, SumFromDbl, ADate, fiidFrom, fiidTo, SayError, Type, SinceDate )

   var
      K,
      Inverse     = false,
      ErrorFlag   = true;

   K = DV_GetRateOnDate( ADate, fiidFrom, fiidTo, false, Type, ErrorFlag, SinceDate );
   if( ErrorFlag )
      /* Не нашли курс. Попробуем найти обратный. */
      Inverse = true;
      K = DV_GetRateOnDate( ADate, fiidTo, fiidFrom, false, Type, ErrorFlag, SinceDate);
   end;

   if ((not ErrorFlag) and (K != null))
   //if( not ErrorFlag )
      if( Inverse )
         SetParm( 0, SumFromDbl / K );
      else
         SetParm( 0, SumFromDbl * K );
      end;

      SetParm( 4, fiidTo );
      SetParm( 7, SinceDate );
      return true;
   end;

   if( SayError )
      MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;
   SetParm( 0, 0.0 );
   return false;
end;

/* Конвертация суммы типа double другую валюту через рубли.
      SumToDbl    - Сюда запишем результат. Double.
      SumFromDbl  - Сумма для конвертации. Double.
      ADate       - Дата, на которую брать курс.
      fiidFrom    - Из какой валюты.
      fiidTo      - В какую валюту.
      SayError    - Флаг. Выдавать сообщения об ошибке. Если не задан, то
                    сообщения не выдаем.
   В случае ошибки возвращаем False, в SumToDbl устанавливаем 0. */
private macro DV_ConvSumCrossDbl( SumToDbl, SumFromDbl, ADate, fiidFrom, fiidTo, SayError, Type, SinceDate )
   var
      SumFIFrom, SumFITo;

   if( DV_ConvSumDbl( SumFITo, 1, ADate, fiidTo, NATCUR, false, Type, SinceDate )           /* местами эти два DV_ConvSumDbl */
       and DV_ConvSumDbl( SumFIFrom, 1, ADate, fiidFrom, NATCUR, false, Type, SinceDate )   /* не менять, иначе 175646    */
         )
      if( SumFITo == 0.0 )
         SetParm( 0, 0.0 );
      else
         SetParm( 0, SumFromDbl * SumFIFrom / SumFITo );
      end;

      SetParm( 4, fiidTo );
      SetParm( 7, SinceDate );
      return true;
   end;

   if( SayError )
      MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;
   SetParm( 0, 0.0 );
   return false;
end;

/* Конвертация суммы типа double из одной валюты в другую.
   Для конвертации пытаемся использовать: прямой, обратный, кросс-курс.
   Всегда берем основной курс. Функциональность аналогична DV_SmartConvertSum.
      SumToDbl    - Сюда запишем результат. Double.
      SumFromDbl  - Сумма для конвертации. Double.
      ADate       - Дата, на которую брать курс.
      fiidFrom    - Из какой валюты.
      fiidTo      - В какую валюту.
      SayError    - Флаг. Выдавать сообщения об ошибке. Если не задан, то
                    сообщения не выдаем.
   В случае ошибки возвращаем False, в SumToDbl устанавливаем 0. */
macro DV_SmartConvertSumDbl( SumToDbl, SumFromDbl, ADate, fiidFrom, fiidTo, SayError, Type, SinceDate )
   var
      NewSum;
   if( ADate != NULL )
      ADate = DATE(ADate);
   end;
   if( SinceDate != NULL )
      SinceDate = DATE(SinceDate);
   end;

   if( fiidFrom == fiidTo )
      NewSum = SumFromDbl;
      if( SinceDate != NULL )
         SinceDate = ADate;
      end;
   elif( not DV_ConvSumDbl( NewSum, SumFromDbl, ADate, fiidFrom, fiidTo, false, Type, SinceDate ) )
      if( not DV_ConvSumCrossDbl( NewSum, SumFromDbl, ADate, fiidFrom, fiidTo, false, Type, SinceDate ) )
         if( SayError )
            MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
         end;
         SetParm( 0, 0.0 );
         /* Сбрасываем ошибку. */
         InitError();
         return false;
      end;
   end;

   SetParm( 4, fiidTo );
   SetParm( 0, NewSum );
   SetParm( 7, SinceDate );
   return true;
end;

/* Конвертация сумм в разных валютах с обработкой ошибок. Используется
   для конвертации денег (money). */
MACRO DV_SmartConvertSum( sumTo, sumFrom, sinceDate, fiidFrom, fiidTo, SayError )
    var NewSum = $0;
    if( sinceDate != NULL )
       sinceDate = DATE(sinceDate);
    end;

    if( valtype(sumFrom) != V_MONEY )
       sumFrom = money(sumFrom);
    end;

    if( fiidFrom == fiidTo )  NewSum = sumFrom;
    elif( ConvSum( NewSum, sumFrom, sinceDate, fiidFrom, fiidTo ) != 0 )
      /* IL 27.08.02 может быть есть кросс-курс*/
      if( ConvSumCross( NewSum, sumFrom, sinceDate, fiidFrom, fiidTo ) != true ) 
         if( SayError == true )
            MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, sinceDate) );
         end; 
         return false;
      end;
    end;

    SetParm( 4, fiidTo );
    SetParm( 0, NewSum );
    return true;
END;

/*получить первый попавшийся курс, имеющийся у FIID*/
macro DV_GetFirstRateDefDbl( FIID, Type, ADate, fiidTo, CursDate, err )
   var RateDef = TRecHandler("ratedef");
   var CourceDbl = 0.0;
   var sql, rsd;

   ClearRecord(RateDef.rec);

   SetParm(3, -1);  
   SetParm(4, date(0,0,0));
   SetParm(5, true);  

   sql = RSDCommand(" SELECT * "
                  + "   FROM dratedef_dbt "
                  + "  WHERE t_OtherFI = ? "
                  + "    AND t_Type = ? "
                  + "  ORDER BY t_IsDominant DESC "); /* первым будет основной */

   sql.addParam( "", RSDBP_IN, FIID );
   sql.addParam( "", RSDBP_IN, Type );
   sql.execute();

   rsd = TRsbDataSet(sql);
   if( rsd.MoveNext() )
     RateDef = rsd.GetRecord();

     if( DV_ConvSumDbl(CourceDbl, 1.0, ADate, FIID, RateDef.FIID, false, Type, CursDate) == true )
       SetParm( 3, RateDef.FIID );
       SetParm( 4, CursDate );
       SetParm( 5, false );
     end;
   end;

   return CourceDbl;
end;

/*UseAnyCourse - если нет курса FIID к ToFIID вида Type, то брать тот который есть и 
                 приводить его к ToFIID
  AnyCourseToType - тип курса, к которому приводится любой найденный по UseAnyCourse (не задан - берется основной)*/
MACRO ПолучитьКурсЗаданногоTипа( Course:@double, FIID:INTEGER, ToFIID:INTEGER, Type:INTEGER, FindDate:DATE, UseAnyCourse:BOOL, SinceDate:@DATE, AnyCourseToType:INTEGER )
  var FindByType, FindFIID, AnyCourseToType_ = null;

  if( Type != NULL )
     Type = ПИ_ПолучитьВидКурса(Type);
  end;

  FindByType = DV_SmartConvertSumDbl( Course, 1.0, FindDate, FIID, ToFIID, false, Type, SinceDate );
  if( (FindByType == false) AND (UseAnyCourse == true) )
     FindFIID = -1;
     /*Нет курса вида Type к ToFIID, пробуем получить к чему нибудь*/
     Course = DV_GetFirstRateDefDbl(FIID,Type,FindDate,FindFIID,SinceDate,FindByType);/*если найден - FindByType вернет false*/

     if( FindByType )
        FindByType = false;
     else
        FindByType = true;
     end;

     if( AnyCourseToType != null )
        AnyCourseToType_ = ПИ_ПолучитьВидКурса(AnyCourseToType);
     end;

     if( FindByType and 
         ((FindFIID == ToFIID ) OR /*Привести найденный курс к ToFIID*/
          (DV_SmartConvertSumDbl( Course, Course, FindDate, FindFIID, ToFIID, false, AnyCourseToType_, SinceDate ) == true)
         )
       )
        FindByType = true;
     end;
  end;
  return FindByType;
END;


/****************************************************************************/

/* Получаем буфер счета. Если счет не найден, то возвращаем false.
      Chapter     -  глава
      FIID        -  валюта
      Account     -  номер счета
      AccBuf      -  возвращам буфер счета через этот параметр
      NoSayError  -  флаг, если = false или не задан, то не выводим
                     сообщение о ошибке */
MACRO DV_GetAccount( Chapter, FIID, Account, AccBuf, NoSayError )
   file AccR( "account.dbt" );

   if( Chapter == null ) Chapter = 1; end;
   if( FIID == null ) FIID = 0; end;

   ClearRecord( AccR );
   AccR.Chapter       = Chapter;
   AccR.Code_Currency = FIID;
   AccR.Account       = Account;
   if( GetEQ(AccR) )
      Copy( AccBuf, AccR);
      return true;
   end;

   if( NoSayError != true )
      msgbox( "Счет " + Account + " не найден." );
   end;
   return false;
END;

MACRO GetRestAccountTRH( accbuf, Dat )
   var Rest = $0, PlanRest = $0;
   OprGetAccountRest( accbuf.rec.Chapter, accbuf.rec.Code_Currency, accbuf.rec.Account, Dat, Rest, PlanRest );
   return Rest;
END;

/* эта функцию кэширует полученные значения в массиве                                                                */
private var party_name  = TArray();
private var _rParty     = TRecHandler( "party.dbt" );
MACRO ПИ_ПолучитьКороткоеИмяСубъекта( PartyID )
   if( PartyID >= 0 )
      if( party_name[PartyID] == null )
         if( not ПолучитьСубъекта( PartyID, _rParty ) )
            party_name[PartyID] = _rParty.rec.ShortName;
         else
            party_name[PartyID] = "";
         end;
      end;
      return party_name[PartyID];
   else
      return "";
   end;
END;

/* Округляем MONEY или DOUBLE до ближайшего целого. Для MONEY
   возвращаем целое, для DOUBLE возвращаем DOUBLE. */
macro DV_Floor_Money(sum)
   if(  (ValType(sum) == V_MONEYL) or (ValType(sum) == V_MONEY))
      return int(Round(double(sum),0));
   elif((ValType(sum) == V_DOUBLE) or (ValType(sum) == V_DOUBLE))
      return Round(sum,0);
   end;
   return sum;
end;

PRIVATE file SfContr( sfcontr ) key 3; /*файл договоров на обслуживание*/

/*получить ID договора обслуживания ПЗО*/
macro GetContrID( ServKind, ReceiverID, PayerID )
   var ContrID = 0, loop = true;
   ClearRecord( SfContr );

   SfContr.ServKind      = ServKind; /*вид обслуживания - фондовый дилинг*/ 
   SfContr.ContractorID  = ReceiverID;
   SfContr.PartyID       = PayerID;     

   if( GetGE( SfContr ) == true )
      while( (SfContr.ServKind == ServKind) AND (SfContr.ContractorID == ReceiverID) AND (SfContr.PartyID == PayerID) ) 
            ContrID  = SfContr.ID;
            Next( SfContr );  
      end;
   end;      
   return ContrID;
end;

private var OperGroupsArray = TArray(); /*кэш*/
MACRO DV_GetOperationGroup( OperType )
   var Group;

   if( OperType >= 0 )
      if( OperGroupsArray[OperType] == null )
         Group = GetOperationGroup( OperType );
         if( Group < 0 )
            return -1;
         end;
      else
         return OperGroupsArray[OperType];
      end;
   else
      return -1;
   end;
   OperGroupsArray[OperType] = Group;

   return Group;
END;

MACRO УстановитьКатегориюФИСС( Deal:OBJECT, DealObjKind:INTEGER, ValDate:Date ):BOOL
  VAR CatErr = 0, AttrID = 0;

  // только если категории еще нет
  if( (not GetMainObjAttr( CatErr, DealObjKind, Deal, 1/*Отнесение к ФИСС*/, AttrID ) AND (CatErr == 0)) AND (AttrID <= 0) )
     if( not ConnectObjAttr( CatErr, DealObjKind, L_Z( Deal.rec.ID, 34 ), 1/*Отнесение к ФИСС*/, null,"", "1"/*Да*/, ValDate )  OR
         ( CatErr != 0 )
       )
        MsgBox( "Ошибка при установке категории \"Отнесение к ФИСС\" для сделки.|"  + GetErrMsg() );
        return false;
     end;
  elif( CatErr != 0 )
    MsgBox( "Ошибка при установке категории \"Отнесение к ФИСС\" для сделки.|"  + GetErrMsg() );
    return false;
  end;

  return true;
END;

MACRO УстановитьКатегориюПрихКассСимвол( FD, DealObjKind:INTEGER, ValDate:Date ):BOOL
  VAR CatErr = 0, AttrID = 0, NumInList = "", CodeList = "";

  // только если категории еще нет
  if( (not GetMainObjAttr( CatErr, DealObjKind, FD.Deal, DV_FXOPER_OBJGROUP_CASHSYMBOL_IN/*Приходный кассовый символ*/, AttrID ) AND (CatErr == 0)) AND (AttrID <= 0) )
     if( FD.ВалютаТребования() == NATCUR )
        NumInList= " 32";/*Прочие поступления*/
        CodeList = "1";/*соответствует DLISTSYMB_DBT.T_DOCKIND = 1 (рубли)*/
     else
        NumInList= "210";
        CodeList = "7";/*соответствует DLISTSYMB_DBT.T_DOCKIND = 7 (валюты)*/
     end;
     if( not ConnectObjAttr( CatErr, DealObjKind, L_Z( FD.Deal.rec.ID, 34 ), DV_FXOPER_OBJGROUP_CASHSYMBOL_IN/*Приходный кассовый символ*/, null, CodeList, NumInList, ValDate )  OR
         ( CatErr != 0 )
       )
        MsgBox( "Ошибка при установке категории \"Приходный кассовый символ\" для сделки.|"  + GetErrMsg() );
        return false;
     end;
  elif( CatErr != 0 )
    MsgBox( "Ошибка при установке категории \"Приходный кассовый символ\" для сделки.|"  + GetErrMsg() );
    return false;
  end;

  return true;
END;

MACRO УстановитьКатегориюРасхКассСимвол( FD, DealObjKind:INTEGER, ValDate:Date ):BOOL
  VAR CatErr = 0, AttrID = 0, NumInList = "", CodeList = "";

  // только если категории еще нет
  if( (not GetMainObjAttr( CatErr, DealObjKind, FD.Deal, DV_FXOPER_OBJGROUP_CASHSYMBOL_OUT/*Расходный кассовый символ*/, AttrID ) AND (CatErr == 0)) AND (AttrID <= 0) )
     if( FD.ВалютаОбязательства() == NATCUR )
        NumInList= " 53";/*Прочие выдачи*/
        CodeList = "1";/*соответствует DLISTSYMB_DBT.T_DOCKIND = 1 (рубли)*/
     else
        NumInList= "410";
        CodeList = "7";/*соответствует DLISTSYMB_DBT.T_DOCKIND = 7 (валюты)*/
     end;
     if( not ConnectObjAttr( CatErr, DealObjKind, L_Z( FD.Deal.rec.ID, 34 ), DV_FXOPER_OBJGROUP_CASHSYMBOL_OUT/*Расходный кассовый символ*/, null, CodeList, NumInList, ValDate )  OR
         ( CatErr != 0 )
       )
        MsgBox( "Ошибка при установке категории \"Расходный кассовый символ\" для сделки.|"  + GetErrMsg() );
        return false;
     end;
  elif( CatErr != 0 )
    MsgBox( "Ошибка при установке категории \"Расходный кассовый символ\" для сделки.|"  + GetErrMsg() );
    return false;
  end;

  return true;
END;
