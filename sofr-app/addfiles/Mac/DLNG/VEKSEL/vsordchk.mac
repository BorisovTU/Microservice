/*
$Name:         vsordchk.mac
$Module:       Векселя банка
$Description:  Проверка договоров
Simanov => Убрана проверка на код в номере счета и на номер векселя
*/

IMPORT
  RsbDataSet, DealsInter, PaymInter, VSInter, VAInter,
  vs4each, vsrcvacc, vsproxy, vsmisc, vspayacc, vslib;
import dlvsacnum;

/* Проверка заполнения счета получателя в платеже по договору
*/
PRIVATE MACRO VS_CheckRcvAcc(order)
var
  paym, ContractID, DocKind, OrderDate, otype, important = false, stat = 0;

  otype = ValType(order);
  if(otype == V_GENOBJ)
    DocKind = order.rec.DocKind;
    ContractID = order.rec.ContractID;
    OrderDate = order.rec.SignDate;
  else
    DocKind = order.DocKind;
    ContractID = order.ContractID;
    OrderDate = order.SignDate;
  end;

  if(DocKind == DL_VEKSELORDER)           /* эмиссия */
     paym = RsbPayment(DocKind, ContractID, PM_PURP_VEKSEL, 0);
     important = true; /* важно, чтобы платеж был */
  elif(DocKind == DL_VSBARTERORDER)       /* мена */
     paym = RsbPayment(DocKind, ContractID, PM_PURP_VSBARTERDIFF, 0);
  elif(DocKind == DL_VSINTERCHANGE)       /* Зачет требований */
     paym = RsbPayment(DocKind, ContractID, PM_PURP_VSDIFF2B, 0);
  end;

  if((paym == null) OR (paym.PaymentID == 0))
     if(important)
        msgbox("Не найден платеж для|договора ", ContractID);
        stat = 1;
     end;
  elif(not VS_DefReceiverAccount(VS_FNDACC, order, paym, OrderDate))
     stat = 1;
  end;

  return (stat == 0);
END;

/* Проверка заполнения счета получателя в платеже (платежах) по договору
*/
PRIVATE MACRO VS_CheckPayerAcc(order)
var
  stat = 0;

  if(not VS_DefPayerAccount(order))
     stat = 1;
  end;

  return (stat == 0);
END;

PRIVATE MACRO VA_GetABCStatusOnDateQ(BCID, OnDate, StatusOnDate:@Integer)
  var Query = "SELECT bck.t_NewABCStatus FROM dvsbnrbck_dbt bck"+
                " WHERE (bck.t_BCStatus = 'X' OR bck.t_ABCStatus = 'X')"+
                  " AND bck.t_ChangeDate <= "+GetSQLDate(OnDate)+
                  " AND bck.t_BCID = "+string(BCID)+
             " ORDER BY bck.t_ChangeDate DESC, bck.t_ID DESC";
  var dataSet = TRsbDataSet(Query);
  if (dataSet.MoveNext())
    StatusOnDate = dataSet.NewABCStatus;
  else
    StatusOnDate = VABANNER_STATUS_INPUT;
  end;
end;

/* Функция корректировки платежа (при вводе, обновлении договора)
*/
PRIVATE MACRO PaymsProcessing(doc, payms, ValueDate:@date)
var
   stat = 0;

   if(ValueDate == date(0,0,0))
     ValueDate = payms.rec.ValueDate;
   elif(ValueDate != payms.rec.ValueDate)
     msgbox("Не совпадает дата валютирования платежей");
     stat = 1;
   end;

   return stat;
END;

/* Проверка дат валютирования платежей погашения.
*/
PRIVATE MACRO CheckPaymValueDates4Repay(order)
var
   vd = date(0,0,0), stat = 0;

   stat = VS_ForEachPaym(order, PM_PURP_VEKSELDRAW, @PaymsProcessing, @vd);

   return stat;
END;

/* Функция проверки дат валютирования платежей.
*/
MACRO VS_CheckPaymValueDates(order)
var
    DocKind = 0, stat = 0;

    VS_IsDocument(order, NULL, @DocKind);

    if(DocKind == DL_VEKSELDRAWORDER)
       stat = CheckPaymValueDates4Repay(order);
    else
       // для других не нужно
    end;

    return (stat == 0);
END;

/* Проверка после ввода договора
*/
MACRO VS_CheckOrderAfterInsert(order)
var
  stat = 0;

  if(not VS_CheckRcvAcc(order))
    stat = 1;
  elif(not VS_CheckPayerAcc(order))
    stat = 1;
  elif(not VS_CheckPaymValueDates(order))
    stat = 1;
  elif ( ДополнитьСписокПредставителей (order))
    stat = 1;
  end;

  return stat;
END;

/* Проверка после изменения договора
*/
MACRO VS_CheckOrderAfterUpdate(order)
var
  stat = 0;

  if(not VS_CheckPayerAcc(order))
    stat = 1;
  elif(not VS_CheckPaymValueDates(order))
    stat = 1;
  end;

  return stat;
END;

/*************************************************/
PRIVATE MACRO GetStatusName(status)
    if(status == VSBANNER_STATUS_ALL)        // -1
       return "не задан";
    elif(status == VSBANNER_STATUS_PREP)     //  0
       return "отложен";
    elif(status == VSBANNER_STATUS_FORMED)   // 10
       return "оформлен";
    elif(status == VSBANNER_STATUS_SENDED)   // 20
       return "выдан";
    elif(status == VSBANNER_STATUS_ENDED)    // 30
       return "погашен";
    elif(status == VSBANNER_STATUS_REDEEMED) // 40
       return "выкуплен";
    end;

    return "неизвестен";
END;

PRIVATE MACRO ПроверитьСтатус(bnr, leg, emi, order, numOrd, lnk, BCStatus:@variant)
var
   day, month, year, errStr,
   StatusOnDate, SignDate,
   DocKind;

   if(bnr.rec.Department != {OperDprt})
     /* вексель чужого филиала не проверяем*/
     return 0;
   end;

   if(ValType(order) == V_GENOBJ)
      SignDate = order.rec.SignDate;
      DocKind = order.rec.DocKind;
   else
      SignDate = order.SignDate;
      DocKind = order.DocKind;
   end;

   VA_GetABCStatusOnDateQ(lnk.rec.BCID, SignDate, @StatusOnDate);
   if((DocKind == DL_VEKSELDRAWORDER) AND (BCStatus == VSBANNER_STATUS_FORMED) AND (StatusOnDate == VSBANNER_STATUS_PRESENTED))
      // для погашения "оформлен" и "предъявлен" не различаем
      return 0;
   elif(((StatusOnDate == VSBANNER_STATUS_FORMED) OR (StatusOnDate == VSBANNER_STATUS_SENDED)) AND
      ((BCStatus == VSBANNER_STATUS_FORMED) OR (BCStatus == VSBANNER_STATUS_SENDED)))
      // "оформлен" и "выдан" не различаем
      return 0;
   elif(StatusOnDate != BCStatus)
      DateSplit(SignDate, day, month, year);
      if((BCStatus == VSBANNER_STATUS_FORMED) OR (BCStatus == VSBANNER_STATUS_SENDED))
         errStr = "оформлен\" или \"выдан";
      else
         errStr = GetStatusName(BCStatus);
      end;
      MsgBox("На дату подписания договора " + string(day:2:o, ".", month:2:o, ".", year:4:o) +
             " у векселя серия " + bnr.rec.BCSeries + " N " + trim(bnr.rec.BCNumber) +
             "|был статус \"" + GetStatusName(StatusOnDate) + "\" вместо требуемого \"" + errStr + "\"" );
      return 1;
   end;

   return 0;
END;

// Проверяет, был ли у векселя требуемый статус на дату подписания договора
MACRO ПроверитьСтатусВекселейНаДату( ВексДоговор, Статус, ВидСвязи )
   ПоУмолчанию(ВидСвязи, VSORDLNK_K_ALL);
   return ДляКаждогоВекселя(ВексДоговор, @ПроверитьСтатус, ВидСвязи, @Статус, "B");
END;

/* Найти договор в котроый входит данный вексель
     со статусом >= $(открыт) и датой заключения >= д.з. текущего договора
*/
PRIVATE MACRO FindLatestOrder(bnr, leg, emi, order, numOrd, lnk)
var DataSetOrd, DataSetTick, DataSetFmo, StatusOnDate,
    cmd_order =
     "SELECT count(*) cnt FROM ddl_order_dbt ord, dvsordlnk_dbt lnk "
       " WHERE lnk.t_BCID = " + bnr.rec.BCID +
          " AND ( lnk.t_DocKind = " + DL_VEKSELORDER +     // Вексельный договор
            " or lnk.t_DocKind = " + DL_VEKSELDRAWORDER + // Заявление на погашение векселей
            " or lnk.t_DocKind = " + DL_VEKSELPAWNORDER + // Договор залога векселей
            " or lnk.t_DocKind = " + DL_VSBARTERORDER +   // Договор мены векселей
            " or lnk.t_DocKind = " + DL_VSSTORAGEORDER +  // Договор хранения векселей
            " or lnk.t_DocKind = " + DL_VSINTERCHANGE +   // соглашение о зачете требований
            " or lnk.t_DocKind = " + DL_VSSALE + " )"     // Договор продажи векселей
          " AND ord.t_ContractID = lnk.t_ContractID "
          " AND ord.t_SignDate > to_date('" + ДатаДокумента(order) + "', 'DD.MM.YYYY') "
          " AND ord.t_ContractStatus >= " + ORDER_CONTRACT_STATUS_OPENED,
    cmd_tick =
     "SELECT count(*) cnt FROM ddl_tick_dbt tick, dvsordlnk_dbt lnk "
       " WHERE lnk.t_BCID = " + bnr.rec.BCID +
          " AND lnk.t_DocKind = " + DL_VEKSELACCOUNTED +
          " AND tick.t_DealID = lnk.t_ContractID "
          " AND tick.t_DealDate > to_date('" + ДатаДокумента(order) + "', 'DD.MM.YYYY') "
          " AND tick.t_DealStatus >= " + DL_READIED,
    cmd_frmord =
     "SELECT count(*) cnt FROM dvsfrmord_dbt fmo, dvsordlnk_dbt lnk "
       " WHERE lnk.t_BCID = " + bnr.rec.BCID +
          " AND lnk.t_DocKind = " + DL_WRITEOFF_RDM_BNR +
          " AND fmo.t_FrmOrdID = lnk.t_ContractID "
          " AND fmo.t_Signed > to_date('" + ДатаДокумента(order) + "', 'DD.MM.YYYY') "
          " AND fmo.t_Status >= " + VSFRMORD_STATUS_OPENED;

    DataSetOrd  = TRsbDataSet(cmd_order);
    DataSetTick = TRsbDataSet(cmd_tick);
    DataSetFmo  = TRsbDataSet(cmd_frmord);

    if((not DataSetOrd.MoveNext()) OR (DataSetOrd.cnt > 0) OR
       (not DataSetTick.MoveNext()) OR (DataSetTick.cnt > 0) OR
       (not DataSetFmo.MoveNext()) OR (DataSetFmo.cnt > 0))
          VA_GetABCStatusOnDateQ(bnr.rec.BCID, ДатаДокумента(order), @StatusOnDate);
          MsgBox("Вексель ", bnr.rec.BCSeries, " N ", trim(bnr.rec.BCNumber),
                 ": нарушена хронология выполнения операций.|",
                 "Состояние ", GetStatusName(StatusOnDate), " на ", ДатаДокумента(order));
       return 1;
    end;

    return 0;
END;

/* Проверить, все ли необходимые реквизиты векселя указаны
Simanov => Убрана проверка на код в номере счета
*/
PRIVATE MACRO ПроверитьВексель(bnr, leg, emi, order, numOrd, lnk)
var
   stat = 0;

   if(trim(bnr.rec.BCNumber) == "")
      stat=Ошибка("Не задан номер векселя");
   elif(leg.rec.Principal == 0)
      stat=Ошибка("Не задан номинал векселя ", bnr.rec.BCSeries, " N ", trim(bnr.rec.BCNumber));
   elif(not CheckAndCreateAccCode(bnr.rec.BCID, bnr.rec.AccCode)) //Simanov
      stat=Ошибка("Ошибка при создании кода в номере счета ", bnr.rec.BCSeries, " N ", trim(bnr.rec.BCNumber));
   end;

   return stat;
END;


/* Проверка договора при старте операции
   order - запись в dl_order.dbt или vsfrmord.dbt
*/
MACRO VS_CheckOrderStartOpr(order)

   // к-агента есть смысл проверять только для договоров
   // в распоряжении на списание ("vsfrmord.dbt") его нет
   if (FileName(order) == "dl_order.dbt")
     
      if(order.Contractor == -1)
         MsgBox("Не задан контрагент по договору");
         return 1;
      end;
   end;

   if(ДляКаждогоВекселя(order, @ПроверитьВексель, VSORDLNK_K_EMISSION, null, "BL") != 0)
      return 1;
   end;
   return ДляКаждогоВекселя(order, @FindLatestOrder, VSORDLNK_K_ALL, NULL, "B");
END;

/* Возвращает наименование состояния 'mask'
*/
MACRO VS_GetBSStateName(mask)
    if(Index(mask, "Х") != 0)
       return "находится на хранении";
    elif(Index(mask, "И") != 0)
       return "перенесен к исполнению";
    end;

    return "в неизвестном сотоянии";
END;

/* Проверка, установлена ли у векселя полученная маска
*/
PRIVATE MACRO BadBCStateBnr(bnr, leg, emi, order, numOrd, lnk, mask)
var
   stat = 0;

   if(Index(bnr.rec.BCState, mask) != 0)
      /* маска установлена, вексель не прошел проверку */
      MsgBox("Вексель серия " + bnr.rec.BCSeries + " № " + trim(bnr.rec.BCNumber) +
             "|" + VS_GetBSStateName(mask));
      stat = 1;
   end;

   return stat;
END;

/* Проверка, чтобы векселя по договору не имели полученного состояния 'mask'
*/
MACRO VS_CheckBadBCState(order, role, mask)
var
    stat = ДляКаждогоВекселя(order, @BadBCStateBnr, role, mask, "B");
    return (stat == 0);
END;

