/*
$Name:         vspmfutu.mac
$Module:       Собственные векселя
$Description:  Класc платежа для работы с будущими значениями счетов и валют
*/
import PTInter, PaymInter, vsmisc, vsbkpnum, "dl_voop.mac", "mc_lib.mac" ,vsconv;
import oralib, likepy, usr_connect_attr;


PRIVATE MACRO ОпределениеКодаВалютнойОперации( paym )
   var CodeVO = "";
   if(paym.rec.Purpose == PM_PURP_COMBROKER)
     if(((paym.rec.Payer == {OurBank}) OR (paym.rec.Receiver == {OurBank})) AND 
        ((MC_IsResident(paym.rec.Payer) == 2) OR (MC_IsResident(paym.rec.Receiver) == 2)) AND
        paym.rec.BaseFIID == NATCUR
       ) //Платежи по комиссиям, между нашим банком и нерезидентами. Валюта платежа = рубли
       CodeVO = "80050";
     elif(((paym.rec.Payer == {OurBank}) OR (paym.rec.Receiver == {OurBank})) AND
          (((MC_IsResident(paym.rec.Payer) == 1) AND (paym.rec.Payer != {OurBank})) OR ((MC_IsResident(paym.rec.Receiver) == 1) AND (paym.rec.Receiver != {OurBank}))) AND
          paym.rec.BaseFIID != NATCUR
         ) //Платежи по комиссиям, между нашим банком и резидентами. Валюта платежа = иностранная валюта  
       CodeVO = "80150";
     end;
   end;

   return CodeVO;
END;

MACRO VS_GetVO_Code( paym )

   var VO_Code = "";

   if( (DL_VOOP_GetCode( @VO_Code, @ОпределениеКодаВалютнойОперации, paym )) and (VO_Code != ""))
      return "{VO" + VO_Code + "}";
   else
      return "";
   end;
END;                                            


//пришлось продублировать фнкцию из vscateg, так как подкл. невозможно - цикличность появляется
PRIVATE MACRO ПроводкаСПроверкойСчетов(tr)

 if(tr.AccountPayer != "")
      
   if(tr.AccountReceiver != "")
     
      return tr.Carry()

   else 
      MsgBox("Не задан счёт получателя для проводки " +tr.Ground);
      return false;
   end;

 else 
    MsgBox("Не задан счёт плательщика для проводки " +tr.Ground);
    return false;
 end;


END;


/* Класс ПД для определения дополнительных счетов (пока это здесь, больше ничего и не надо)
*/
class PrimDOC( DocKind : integer, DocID : integer )

  var Kind : integer;
  var Id   : integer;

  var Error : integer;

/* Вернуть параметр второго рода */
macro GetParametr( ParmKind, OperDate, CatCode, FIRole )
  if(ParmKind == MC_TYPE_PARAMETR_DEPARTMENT)
    return 0;
  end;
  return -1;
end;

/* вернуть параметр первого рода */
macro GetParametrTemplate( ObjectID, Classificator, OperDate, FIRole )
  return -1;
end;

/* Основная роль ФИ */
macro GetBasisFIRole(FIRole)
  return FIROLE_UNDEF;
end;

/* Корректировка счета  */
macro CorrectAccount( account, accblnc, ORScheme, categ, templ, accdoc, OperDate )
  return 0;
end;

/* Конструктор */
  Kind = DocKind;
  Id   = DocID;

  Error = 0;
end;


MACRO VS_PmBookpass(pm,
                   BpGround,                          /* основание проводки */
                   CreditAccount, CreditAccountFIID,  /* счет кредита с валютой */
                   MinorAmount, MinorFIID,            /* сумма проводки с валютой */
                   MinorCrossRate,                    /* курс конверсии Minor'а к дебету */
                   MinorCreditCrossRate,              /* курс конверсии Minor'а к кредиту */
                   IsPartOfMain,
                   Date_Carry,
                   Number_Pack,
                   Numb_Document,
                   Result_Carry,
                   Tax:variant,                       /* объект удержанного налога */
                   toClient:bool                      /* от банка к клиенту - true, от клиента банку - false */
                   )
   var
       paymtr, pd;

   paymtr = pm.MakeTransaction(CreditAccount, CreditAccountFIID,
                                 MinorAmount, MinorFIID,
                                 MinorCrossRate, MinorCreditCrossRate);

   if( paymtr == NULL )
     MsgBox("Ошибка при создании проводки по платежу");
     return false;
   end;
   //увеличение или уменьшение проводки на сумму удержанного налога, если переданы соответствующие параметры
   if ( (Tax != NULL) and (toClient!=NULL) )
     paymtr.SumReceiver = paymtr.SumReceiver - IIF(toClient,1,-1) * VS_Convert(Tax.Tax, paymtr.Date_Carry, Tax.Cur, paymtr.FIIDReceiver);
     paymtr.SumPayer = paymtr.SumPayer - IIF(toClient,1,-1) * VS_Convert(Tax.Tax, paymtr.Date_Carry, Tax.Cur, paymtr.FIIDPayer);
   end;
   
   if( ValType(IsPartOfMain) != V_Undef ) paymtr.IsPartOfMain = IsPartOfMain; end;

   ПоУмолчанию(Date_Carry,     {curdate});
   ПоУмолчанию(Result_Carry,   1);
   ПоУмолчанию(BpGround,       pm.Ground);
   ПоУмолчанию(CreditAccount,  pm.FutureReceiverAccount);

   if(CreditAccount == "")
     MsgBox("Не задан счет получателя в платеже");
     return false;
   end;

   //Запрет на выгрузку
   if (pm.UserField2 == "1")
     paymtr.UserField2 = "1";
   end;

   if (pm.NumberPack > 0)
     paymtr.Number_Pack = pm.NumberPack;
   else
     paymtr.Number_Pack = "55";
   end;

   //Выгрузка проводок обратно в БИС для редактирования платежа
   if (paymtr.Number_Pack == 170)
     paymtr.Numb_Document = pm.UserField4;
     paymtr.UserField1 = "ENCASH:"+pm.UserField4;
   else
     paymtr.Numb_Document = VS_GetBookpassNum(pm.FuturePayerAccount,
                                            CreditAccount, pm.PayerFIID, 1);
   end;

   paymtr.Chapter       = 1;
   paymtr.Date_Carry    = Date_Carry;
   paymtr.ResultCarry   = Result_Carry;
   paymtr.Kind_Oper     = " 1";
   paymtr.Ground        = BpGround;
   paymtr.UserField3    = "1";

  // if( not paymtr.Carry )
   if(not ПроводкаСПроверкойСчетов(paymtr))
     MsgBox("Ошибка при актуализации платежа");
     return false;
   end;

   if (paymtr.Number_Pack == 170)
     Connect_attr_from_paym_to_trn(pm.PaymentID, paymtr.acctrnid, 102, 102);
   end;

   return true;
end;


/* Класс платежа, у которого можно изменить значения счетов
*/
CLASS (RsbPayment) MyRsbPayment (p1,p2,p3,p4,noactuate)
    private var
        i_FuturePayerAccount,
        i_FutureReceiverAccount,
        actuated = false,
        sql;
    var UserField1 = "";
    var UserField2 = "";
    var UserField3 = "";
    var UserField4 = "";

    macro MyFuturePayerAccount (new)
        if (not actuated) RunError ("MyRsbPayment not actuated"); end;
        var old = i_FuturePayerAccount;
        if (new)
            i_FuturePayerAccount = new;
        end;
        return old;
    end;

    macro MyFutureReceiverAccount (new)
        if (not actuated) RunError ("MyRsbPayment not actuated"); end;
        var old = FutureReceiverAccount;
        if (new)
            i_FutureReceiverAccount = new;
            FutureReceiverAccount = new;
        end;
        return old;
    end;

    macro SetGround(newground)
       var
         paym = TBfile("pmpaym"),
         need_set = false;

       if((index(Ground, "{VO") == 1))
         /* основание установлено */
         if((ValType(newground) == V_STRING) AND ((index(newGround, "{VO") == 1)))
           /* но хотят переустановить */
           need_set = true;
         end;
       else
         /* основание не установлено */
         need_set = true;
       end;

       if(need_set)
         if( FindPayment ( PaymentID, null,null,null,null,null, paym ) == 0 )
            if( DL_VOOP_CheckNeedCode( paym ) )
               DL_VOOP_SetPaymGround( @ОпределениеКодаВалютнойОперации, paym);
            elif(ValType(newground) == V_STRING)
               ground = newground;
            end;
         end;
       end;

       return true;
    end;

    macro MyActuate(strong)
        if(ValType(strong) != V_BOOL)
          strong = false;
        end;
        if(not actuated)
          actuated = true;
          strong = true;
        end;
        if(strong)
           i_FuturePayerAccount = this.FuturePayerAccount;
           i_FutureReceiverAccount = this.FutureReceiverAccount;
        end;
        SetGround();
    end;

    macro IsActuate
        return actuated;
    end;

    MACRO Bookpass(BpGround,                          /* основание проводки */
                   CreditAccount, CreditAccountFIID,  /* счет кредита с валютой */
                   MinorAmount, MinorFIID,            /* сумма проводки с валютой */
                   MinorCrossRate,                    /* курс конверсии Minor'а к дебету */
                   MinorCreditCrossRate,              /* курс конверсии Minor'а к кредиту */
                   IsPartOfMain,
                   Date_Carry,
                   Number_Pack,
                   Numb_Document,
                   Result_Carry,
                   Tax:variant,
                   toClient:bool
                   )

      BpGround = DL_VOOP_MakeBPassGround2( PaymentID, BpGround );

      return VS_PmBookpass(this,
                   BpGround,                          /* основание проводки */
                   CreditAccount, CreditAccountFIID,  /* счет кредита с валютой */
                   MinorAmount, MinorFIID,            /* сумма проводки с валютой */
                   MinorCrossRate,                    /* курс конверсии Minor'а к дебету */
                   MinorCreditCrossRate,              /* курс конверсии Minor'а к кредиту */
                   IsPartOfMain,
                   Date_Carry,
                   Number_Pack,
                   Numb_Document,
                   Result_Carry,
                   Tax,
                   toClient);
    end;

    macro GetCorAccount(DK)
    var cur = this.PayerFIID, bankID = this.PayerBankID;
      if((ValType(DK) == V_STRING) AND (DK == "К"))
        cur = this.ReceiverFIID; bankID = this.ReceiverBankID;
      else
        DK = "Д";
      end;
      return GetCorAcc (cur, ПолучитьКорсхемуПоУмолчанию(bankID, cur, 1, DK), CORS_ACC_ACCOUNT);
    end;

    InitRsbPayment(p1,p2,p3,p4);
    if(not((ValType(noactuate) == V_BOOL) and (noactuate == true)))
      MyActuate(true);
    end;

    //Simanov. Если передан ИД платежа, та заполним ещё юзерфилды. Пока нужно только в квитовке. Если что-то сломается, то это дело можно перенести в vsi100kv.mac
    if ( (ValType(p1) != V_UNDEF)  and (ValType(p2) == V_UNDEF) and (ValType(p3) == V_UNDEF) and (ValType(p4) == V_UNDEF) )
      sql = ExecSqlselect("select t_userfield1, t_userfield2, t_userfield3, t_userfield4 from dpmpaym_dbt where t_paymentid = "+p1);
      if (sql.MoveNext() )
        UserField1 = sql.value("t_userfield1");
        UserField2 = sql.value("t_userfield2");
        UserField3 = sql.value("t_userfield3");
        UserField4 = sql.value("t_userfield4");
      end;
    end;
END;


/* Класс платежей по договору
*/
CLASS OrderPayms (order)
   private var 
       Inf = TArray, Inited = false;

   macro Add(ID)
       Inf[Inf.Size] = MyRsbPayment(ID);
   end;

   macro Init(order)
       var t = TBFILE("pmpaym"), Ok = true, DocKind, DocID, otype;

       if(Inited)
         return 0;
       end;

       otype = ValType(order);
       if(otype == V_UNDEF)
         return 0;
       elif(otype == V_GENOBJ)
         DocID   = order.rec.ContractID;
         DocKind = order.rec.DocKind;
       else
         DocID   = order.ContractID;
         DocKind = order.DocKind;
       end;

       t.KeyNum = 1;
       t.rec.DocKind    = DocKind;
       t.rec.DocumentID = DocID;
       t.rec.Purpose    = 0;
       t.rec.SubPurpose = 0;

       t.addFilter("t_DocKind = " + DocKind + " and t_DocumentID = " + DocID);

       Ok = t.GetGE;
       while (Ok)
         if((t.rec.DocKind == DocKind) AND (t.rec.DocumentID == DocID))
           Inf[Inf.Size] = MyRsbPayment(t.rec.PaymentID);
         end;
         Ok = t.Next; 
       end;

       t.dropFilter();

       Inited = true;
       return 0;
   end;

   /* Поиск платежа в массиве Payms по назначению */
   /* Третий параметр - какой из найденных платежей вощвращать */
   macro Find(purp, Extra, founding_J:integer)
       var i = 0, j = 0;
       if (founding_J == NULL) 
         founding_J = 0;
       end;
       while (i < Inf.Size)
         if (Inf[i].Purpose == purp)
           if(ValType(Extra) == V_STRING)
              if(Inf[i].PayerAccount == Extra)                
                 if ( j < founding_J )
                   j = j + 1;
                 else
                   return Inf[i];
                 end;
              end;
           elif(ValType(Extra) == V_INTEGER)
              if(Inf[i].SubPurpose == Extra)
                 if ( j < founding_J )
                   j = j + 1;
                 else
                   return Inf[i];
                 end;
              end;
           else
              if ( j < founding_J )
                j = j + 1;
              else
                return Inf[i];
              end;
           end;
         end;
         i = i + 1;
       end;
       return false;
   end;

   /* Выполняет действие для каждого платежа по договору */
   macro ForEach(action, data:@variant)
       var i = 0;
       while(i < Inf.Size)
           if(ExecMacro2(@action, Inf[i], @data) == 0)
              i = i + 1;
           else
              return 1;
           end;
       end;
       return 0;
   end;

   Inf.Size = 0;
   Init(order);
END;

