/*
$Name:         vsscrol.mac
$Module:       Векселя банка
$Description:  Пользовательские фунции векселей
*/

// с целью оптимизации сюда вынесены import'ы из сервисных операций,
// чтобы они не подключались для каждого векселя при массовом запуске
Import BankInter, VSInter, CTInter, PTInter, PcRateInter, globals, Проценты, vslib,
       /* vapresent: */
       OprInter, VAInter, DealsInter, vaacc, valib, vaconv, vasale,
       vsbnrfd, vstrlib,
       /* vsrep: */
       vsprros, vsprrvp, vsprrcp, vsprrkp,
       /* vsprint: */
       vsrplib, vsprlib, vs4each, vsprord, vspmfutu;

RECORD Вексель (vsbanner);
RECORD СтарыйВексель (vsbanner);
RECORD ЦУ (dl_leg);
RECORD СтарыйЦУ (dl_leg);

/**********************************************************************************/
/********************** Код для депозитных сертификатов !!! ***********************/
/**********************************************************************************/
// Эти переменные и функции нужны для обобщенного скроллинга (TS_CScrol),
//  используемого для сертификатов. Использовать их не нужно, т.к.
//  не ясно, на сколько это безопасно - см. комментарий к переменным.

// Следующие две переменные добавлены, чтобы скроллинг
//  депозитных сертификатов УВ можно было вызывать из под
//  этого макроса (см. реализацию метода TS_CScrol::ExternalRunScrolMacro)
// Лучше их не использовать, т.к. вместо записи из таблицы vsordlnk,
//  в них может лежать запись из VSBANNER!!!
PRIVATE VAR Документ       = TRecHandler( "vsordlnk" );
PRIVATE VAR СтарыйДокумент = TRecHandler( "vsordlnk" );

/* Макрофункция инициализации новой операции
   необходимо заполнить структуру "Документ"
   возвращаемое значение
   0 - ошибок не было
   1 - была ошибка
*/
PRIVATE MACRO Новый_Документ()

  return 0;
END;

/* Макрофункция проверки операции при вводе, редактировании, удалении
   возвращаемое значение
   0 - ошибок не было
   1 - была ошибка
*/
PRIVATE MACRO Проверить_Документ( Режим:INTEGER )

  if( Режим == 2 /*TS_INSERT*/ ) /* ввод новй операции*/

  elif( Режим == 3 /*TS_EDIT*/ ) /* редактирование операции*/

  elif( Режим == 1 /*TS_DELETE*/ ) /* удаление операции*/

  end;

  return 0;
END;

/* Установка подсказки для скролингов из макроса */
PRIVATE MACRO УстановитьПодсказку( TableName:string, IndexNum:integer, DefaultHint:string, ScrolStatus:integer, ScrolKind:integer ):string

  //пример
  if(TableName == "dvsbanner_dbt")
    //return "/*+FIRST_ROWS LEADING(t) INDEX(t dvsbanner_dbt_idx0)*/";
  end;

  return DefaultHint;

END;

/* Макрофункция вызывается по Ctrl-Z из скроллинга/панели */
PRIVATE MACRO Функция_Пользователя()
   MsgBox( "Выполняется макрофункция \"vsscrol.mac\\ Функция_Пользователя\"." );
END;

/**********************************************************************************/
/**************** Конец кода для депозитных сертификатов !!! **********************/
/**********************************************************************************/

Private record leg(dl_leg);
Private record lnk(vsordlnk);
Private record rate("mmrt");

MACRO ФункцияПользователя_Вексель (Режим)
    msgbox(String("Выполняется макрофункция с именем|",
                  "ФункцияПользователя_Вексель,|",
                  "которая определена в файле|",
                  "vsscrol.mac"));
    return 0;
END;

PRIVATE MACRO CheckAccValid(bnr, leg, СтарыйВексель)
VAR
  m_RS, stat, isfirst = 1;
  record legbuf(dl_leg);
  record bnrbuf(vsbanner);

  //векселедатель должен быть задан
  if(bnr.Issuer <= 0)
    msgbox("Необходимо указать векселедателя.");
    return 1;
  end;

  if( ((СтарыйВексель.AccCode != bnr.AccCode) or (bnr.BCID <= 0)) and (bnr.AccCode == "") )
     msgbox("Необходимо заполнить код в номере счета.");
     return 1;
  end;

  if((СтарыйВексель.AccCode != bnr.AccCode))
    m_RS = TRsbDataSet( "select t_AccCode " +
                        "from dvsbanner_dbt " +
                        "where t_AccCode = '" + bnr.AccCode + "' "+
                        "and t_BCID <> " + bnr.BCID );
    if(m_RS.MoveNext())
      stat = 1;
    else
      stat = 0;
    end;
  end;

  if(stat == 0)
    while((stat == 0) and (VS_GetNextBnr(isfirst, bnrbuf, legbuf) == 0))
      if((bnr.AccCode == bnrbuf.AccCode) and (bnr.BCID != bnrbuf.BCID))
        stat = 1;
      else
        isfirst = 0;
        stat = 0;
      end;
    end;
  end;

  if(stat)
    msgbox("Неуникальный код в номере счета");
  end;

  return stat;
END;

MACRO Новый_Вексель ()
    return 0;
END;

PRIVATE MACRO ВажныеИзмененияВВексель(Статус)

 if (Статус == VSBANNER_STATUS_PREP )
   return 0;/*не проверяем в отлож.*/
 elif ((Статус == VSBANNER_STATUS_FORMED) OR (Статус == VSBANNER_STATUS_SENDED))
   if( (ЦУ.Principal != СтарыйЦУ.Principal) OR /* Номинал */
       (ЦУ.PFI       != СтарыйЦУ.PFI)       OR /* Валюта */
       (ЦУ.Formula   != СтарыйЦУ.Formula)   OR
       (ЦУ.Cost      != СтарыйЦУ.Cost)      OR /* Накопленный доход */
       (ЦУ.Start     != СтарыйЦУ.Start )    OR /*Дата выставления векселя*/
       (ЦУ.Maturity  != СтарыйЦУ.Maturity)  OR /*Дата погашения не ранее*/
       (ЦУ.Expiry    != СтарыйЦУ.Expiry)    OR /*Дата погашения, не позднее*/
       (ЦУ.ReceiptAmount!= СтарыйЦУ.ReceiptAmount) /* Номинал - Дисконт */
     )
    return 1;
   else return 0;  /* изменения не существенные */
   end;
 elif((Статус == VSBANNER_STATUS_ENDED) OR (Статус == VSBANNER_STATUS_REDEEMED))
   if( (Вексель.IssueKind != СтарыйВексель.IssueKind) OR
       (ЦУ.Price     != СтарыйЦУ.Price)     OR
       (ЦУ.Basis     != СтарыйЦУ.Basis)     OR
       (ЦУ.Duration  != СтарыйЦУ.Duration)  OR
       (ЦУ.Principal != СтарыйЦУ.Principal) OR /* Номинал */
       (ЦУ.PFI       != СтарыйЦУ.PFI)       OR /* Валюта */
       (ЦУ.Formula   != СтарыйЦУ.Formula)   OR
       (ЦУ.Cost      != СтарыйЦУ.Cost)      OR /* Накопленный доход */
       (ЦУ.Start     != СтарыйЦУ.Start )    OR /* Дата выставления векселя*/
       (ЦУ.Maturity  != СтарыйЦУ.Maturity)  OR /* Дата погашения не ранее*/
       (ЦУ.Expiry    != СтарыйЦУ.Expiry)    OR /* Дата погашения, не позднее*/
       (ЦУ.ReceiptAmount!= СтарыйЦУ.ReceiptAmount) /* Номинал - Дисконт */
     )
   /* msgbox("Невозможно сохранить изменения в погашенном векселе");*/
    return 1;
   else return 0;  /* изменения не существенные */
   end;
 end;

END;

MACRO Проверить_Вексель(Режим)

  if ( Режим == OBJ_DELETE )
    return 0;
  elif ( Режим == OBJ_UPDATE)
       if(CheckAccValid(Вексель, ЦУ, СтарыйВексель))
         return 1;
       else
         return 0;
       end;
       if ( ВажныеИзмененияВВексель(СтарыйВексель.BCStatus) )
         return OBJ_IMPORTANT;
       else
         return 0;
       end;
  elif ( Режим == OBJ_DELETEOPR) /* не реализовано */
    return 1;
  elif ( Режим == OBJ_INSNOTOPR)
       if(CheckAccValid(Вексель, ЦУ, СтарыйВексель))
         return 1;
       else
         return 0;
       end;

//    return 0;
  elif ( Режим == OBJ_STARTOPR) /* не реализовано */
    return 1;
  elif ( Режим == OBJ_COMPLETE)
    return 0; /* Возвращаемое значение не важно. Обработано не будет. */
  elif ( Режим == OBJ_NOTCOMPLETE)
    return 0; /* Возвращаемое значение не важно. Обработано не будет. */
  end;

    return 0;
END;

PRIVATE MACRO ПроверитьЗаполнПолей (StartDate)
var
  zero_date=date(0,0,0),
  сообщ="Не указано значение ",
  ИмяПоля="";

 if (ЦУ.Principal == 0.0 )
   ИмяПоля = "<Номинал>";
 elif (ВексельДисконтный(ЦУ))
   if (ЦУ.ReceiptAmount == 0.0)
      ЦУ.ReceiptAmount = ЦУ.Principal;
   end;
 elif ( StartDate == zero_date)
   ИмяПоля = "<Дата выставления>";
 elif ( ЦУ.Maturity == zero_date)
   ИмяПоля = "<Дата перевода векселя на счет 'до востребования'>";
 end;

 if (ИмяПоля != "" )
   msgbox(сообщ, ИмяПоля);
   return false;
 end;

 return true;
END;

const RTERR_NOSUCHRATE = 9052, /*Не найдено ставки с такими параметрами*/
      RT_PMPURP_OD = 1, /* Погашение ОД */
      RT_PURPOSE = 2, /* Привлечение */
      НаправлениеСделки = 1,
      RiskType = 1,
      RiskGroup = 0;

/* Возвращает тип субъекта: банк или ф/ю лицо
*/
PRIVATE MACRO SubjType (PartyID)
var
    party = TBfile("party.dbt"),
    bank = TBfile("bankdprt.dbt");

    if (ВидСубъекта(PartyID, PTK_BANK)) /*Подкачиваем банк*/
        bank.rec.PartyID = PartyID;
        if (bank.GetEQ)
           /* банк */
           return 2;
        end;
    else
        party.rec.PartyID = PartyID;
        if (party.GetEQ)
           if((party.rec.LegalForm == 1))
              /* юр.лицо */
              return 1;
           elif((party.rec.LegalForm == 2))
              /* физ.лицо */
              return 1;
           end;
        end;
    end;

    /* неизвестный субъект */
    return -1;
END;

PRIVATE MACRO DefProduct(PartyID, warning)
var st, product = TBfile("product"), s = "Вексель ф/ю л", Ok;

  st = SubjType(PartyID);
  if(st == 2)
    s = "Вексель б";
  end;

  product.KeyNum = 0;
  product.rec.Id = 0;
  Ok = product.GetGE;
  while (Ok)
    if (product.rec.Caption == s)
      return product.rec.Id;
    end;
    Ok = product.Next;
  end;

  if(warning)
     msgbox("Не найдено значение продукта|для ", s);
  end;

  return -1;
END;

/* Возвращает проц.ставку с учетом интерполяции, если нужно
*/
PRIVATE MACRO GetInterpolRate(
              FI,              /* финансовый инструмент */
              Product,         /* идентификатор продукта */
              Fund,            /* категория средств */
              Informator,      /* источник информации */
              MarketPlace,     /* рынок, торговая площадка */
              Purpose,         /* характер использования ставки */
              RiskType,        /* тип группы риска */
              RiskGroup,       /* номер группы риска */
              Basis,           /* базис */
              BalanceSide,     /* направление сделки */
              StartDate,       /* дата начала проц.периода */
              EndDate,         /* дата окончания ...*/
              Volume,          /* объем сделки */
              Yield:@variant,
              Point:@variant
              )
var
  ActionDate = ZeroDate, /* дата, на которую нужна ставка */
  Forestall = ZeroDate;  /* горизонт */

  ActionDate = StartDate;  /* #54126 */

  if( ПолучитьСтавку(FI, Product, Fund, Informator, MarketPlace, Purpose,
                     RiskType, RiskGroup, Basis, BalanceSide, ActionDate,
                     Forestall, StartDate, EndDate, Volume, rate) != 0)
    /* неудачно получили ставку */
    return false;
  end;

  Yield = rate.Value;
  Point = rate.Pitch;

  return true; /* что-то все-таки нашли */
END;

const DL_ERRMACRO = 3011;

/* Макрос определения значения ставки по таблице процентных ставок
*/
MACRO VS_GetPercRate(PartyID, StartDate)
var
  Price, Point, stat = 0;

  if((ValType(StartDate) != V_DATE) OR (StartDate == date(0,0,0)))
     StartDate = ЦУ.Start;
  end;

  if ( not ПроверитьЗаполнПолей (StartDate))
   stat = 1;
  elif(not GetInterpolRate(
                        ЦУ.PFI,
                        DefProduct(PartyID, true),
                        RT_PMPURP_OD,
                        {OurBank},
                        {OurBank},
                        RT_PURPOSE,
                        RiskType,
                        RiskGroup,
                        ЦУ.Basis,
                        НаправлениеСделки,
                        StartDate,
                        ЦУ.Maturity,
                        ЦУ.Principal,
                        @Price,
                        @Point
  ))
   stat = 1;
  end;

  if (stat == 0)
    ЦУ.Price = Price;
    ЦУ.Point = Point;
  elif (stat == RTERR_NOSUCHRATE)
    msgbox("Не найдено ставки с такими параметрами");
  else
    /*msgbox("Ошибка при определении ставки");
    */
    /* №45953 */
    msgbox("Не найдено ставки с такими параметрами");
    stat = DL_ERRMACRO;
  end;

  return stat;
END;

/* Получение процентной ставки для связи векселя и договора погашения
   Ставка возвращается в параметре 'lnk'.
*/
MACRO VS_GetRepayRate(leg_parm, lnk_parm, PartyID)
  SetBuff(leg, leg_parm);
  SetBuff(lnk, lnk_parm);

  //lnk.Yield = 0.0;
  //lnk.Point = 4;

  return 0;
END;

/* Получение процентной ставки для связи векселя и договора продажи
   Ставка возвращается в параметре 'lnk'.
*/
MACRO VS_GetSaleRate(leg_parm, lnk_parm, PartyID)
  SetBuff(leg, leg_parm);
  SetBuff(lnk, lnk_parm);

  //lnk.Yield = 0.0;
  //lnk.Point = 4;

  return 0;
END;

/* Поиск процентной ставки при привязке учтенного векселя к сделке погашения
   Расчитанная ставка возвращается в параметре 'lnk'.
*/
MACRO VA_GetRepayRate(leg_parm, lnk_parm)
  SetBuff(leg, leg_parm);
  SetBuff(lnk, lnk_parm);

  if(not ВексельПроцентный(leg))
     lnk.Yield = 0.0; /*для погашения дисконтного векселя в срок ставка равна 0 */
  else
     lnk.Yield = leg.Price;
  end;
  lnk.Point = leg.Point;

  return 0;
END;

/* Вычисление стоимости векселя.
   Возвращается в 'lnk.BCCost'.
*/
MACRO VS_CalcCost(leg_parm, lnk_parm,
                  FValue,   /* X7*/
                  DueDate,  /* дата оценки векселя */
                  Maturity, /* дата окончания векселя */
                  Rate,     /* ставка */
                  Basis,    /* базис */
                  Point,    /* точность */
                  Scale,    /* масштаб */
                  Pitch     /* единица изм. */
                  )
  file bnr("vsbanner.dbt");
  var prccontract = TRecHandler("prccontract");
  var ДатаРассчета = ZeroDate;
  var IncomeDateType = DL_INCOMEDATETYPE_PLUSONE;
  var Скн = $0, ОсткБСчПр = $0;

  SetBuff(leg, leg_parm);
  SetBuff(lnk, lnk_parm);

  ПоискВекселя(bnr, leg.DealID);

  DL_GetStartIncomeDateType(@IncomeDateType);

  lnk.BCCost = ПолучитьСуммуРазмещения(leg, bnr);

  if(ВексельПроцентный(leg))
    if(not НайтиСчетПроцВекселя(prccontract, bnr.BCID, null, VS_FINDPC_ACTUAL))
      return Ошибка("Не найден счет процентного векселя");
    else
      ДатаРассчета = VS_GetRightPcDate(prccontract, DueDate);

      if((lnk.IsPartycular == SET_CHAR)
     and (ДатаРассчета < prccontract.rec.EndDate)
     and (IncomeDateType == DL_INCOMEDATETYPE_CBR))
        ДатаРассчета = ДатаРассчета - 1;
      end;

      if(Rate != leg.Price)
        lnk.BCCost = lnk.BCCost + РассчитатьСуммуПроцентов(leg.Principal, Rate, Point, prccontract.rec.BeginDate, ДатаРассчета, leg.Basis);
      else
        if(ПолучитьСуммуКНачисл_В(bnr, leg, ДатаРассчета, @Скн, @ОсткБСчПр))
          // Для корректного расчета суммы нужно учитывать, что если вексель был повторно продан, то в его цену обычно уже входят восстановленные проценты.
          // Следовательно, отнимаем восставновленные проценты.
          var ДатаПовтроногоРазмещения = VS_GetStartDate(bnr, leg);
          var РасчСуммаПроцентов = $0;
          if ((prccontract.rec.BeginDate <= ДатаРассчета) and (ДатаПовтроногоРазмещения != leg.Start) and (ДатаПовтроногоРазмещения >= prccontract.rec.BeginDate))
            РасчСуммаПроцентов = РассчитатьСуммуПроцентов(leg.Principal, leg.Price, Point, prccontract.rec.BeginDate, ДатаПовтроногоРазмещения, leg.Basis);
          end;
          lnk.BCCost = lnk.BCCost + Скн + ОсткБСчПр - РасчСуммаПроцентов;
        end;
      end;
    end;
  end;

  if(ВексельДисконтный(leg, bnr))
    ДатаРассчета = DueDate;

    if((lnk.IsPartycular == SET_CHAR)
   and (ДатаРассчета < DL_GetBnrPlanRepayDate(bnr, leg))
   and (IncomeDateType == DL_INCOMEDATETYPE_CBR))
      ДатаРассчета = ДатаРассчета - 1;
    end;

    var дисконт = $0;
    
    if ((bnr.BCTermFormula == VS_TERMF_ATSIGHT) and (leg.Maturity >= leg.Start) and (leg.Maturity <= DueDate))
      дисконт = ПолучитьСуммуНачальногоДисконта( bnr, leg); //Для векселей по предъявлении но не ранее, если дата "не ранее" наступила - берётся весь дисконт
    else
      дисконт = ПолучитьСуммуДисконтаНаДату(ДатаРассчета, bnr, leg);
    end;
     
    lnk.BCCost = lnk.BCCost + дисконт;

  end;

  return 0;
END;

/* Вычисление ставки векселя.
   Возвращается в 'lnk.Yield'.
*/
MACRO VS_CalcRate(leg_parm, lnk_parm,
                  FValue,
                  Principal,
                  DueDate   /* дата оценки векселя */,
                  Maturity, /* дата окончания векселя */
                  Basis,    /* базис */
                  Point,    /* точность */
                  Scale,    /* масштаб */
                  Pitch     /* единица изм. */
                 )
  file bnr("vsbanner.dbt");
  var prccontract = TRecHandler("prccontract");
  var ДатаРассчета = ZeroDate;
  var IncomeDateType = DL_INCOMEDATETYPE_PLUSONE;

  SetBuff(leg, leg_parm);
  SetBuff(lnk, lnk_parm);

  ПоискВекселя(bnr, leg.DealID);

  if(lnk.BCCost > leg.Principal)
    if(not НайтиСчетПроцВекселя(prccontract, bnr.BCID, null, VS_FINDPC_ACTUAL))
      return Ошибка("Не найден счет процентного векселя");
    else
      ДатаРассчета = VS_GetRightPcDate(prccontract, DueDate);

      if((lnk.IsPartycular == SET_CHAR)
     and (ДатаРассчета < prccontract.rec.EndDate)
     and (IncomeDateType == DL_INCOMEDATETYPE_CBR))
        ДатаРассчета = ДатаРассчета - 1;
      end;
      if (prccontract.rec.BeginDate > ДатаРассчета)
        return Ошибка("Дата начала начисления процентов "+string(prccontract.rec.BeginDate)+" больше даты расчёта "+string(ДатаРассчета));
      end;
      lnk.Yield = РассчитатьСтавкуПроцентов(leg.Principal, lnk.BCCost - leg.Principal, Point, prccontract.rec.BeginDate, ДатаРассчета, leg.Basis);
    end;
  else
    lnk.Yield = 0.0;
  end;

  return 0;
END;

/* Вычисление стоимости учтенного векселя в погашении (номинал + %%).
   Возвращается в 'lnk.BCCost' в валюте номинала
*/
MACRO VA_CalcCost(leg_parm, lnk_parm,
                  FValue,   /* X7*/
                  DueDate,  /* дата оценки векселя */
                  Maturity, /* дата окончания векселя */
                  Rate,     /* ставка */
                  Basis,    /* базис */
                  Point,    /* точность */
                  Scale,    /* масштаб */
                  Pitch     /* единица изм. */
                  )
  file bnr("vsbanner.dbt");
  var prccontract = TRecHandler("prccontract.dbt");
  var ДатаРассчета = ZeroDate;
  var Скн = $0;

  SetBuff(leg, leg_parm);
  SetBuff(lnk, lnk_parm);

  ПоискВекселя(bnr, leg.DealID);

  lnk.BCCost = leg.Principal;

  if(ВексельПроцентный(leg))
    if(not НайтиСчетПроцВекселя(prccontract, bnr.BCID, NULL, VS_FINDPC_ACTUAL))
      return Ошибка("Не найден процентный договор для ц/б");
    else
      ДатаРассчета = VS_GetRightPcDate(prccontract, Maturity);

      if(ПроцентыКНачислениюПоПДВекселя(prccontract.rec.ContractID, ДатаРассчета, Скн))
        lnk.BCCost = lnk.BCCost + ПолучитьСуммуПДД(bnr.BCID, VA_GetLastAccountedEnrolmentID(bnr.BCID), FIROLE_PERCENT, Maturity) + Скн;
      end;
    end;
  end;

  return 0;
END;

//Возвращает плановую дату погашения векселя
//Вызывается из C
MACRO GetBnrPlanRepayDate(bnradr, legadr)
  record bnr("vsbanner.dbt");
  record leg("dl_leg.dbt");

  SetBuff(bnr, bnradr);
  SetBuff(leg, legadr);

  return DL_GetBnrPlanRepayDate(bnr, leg);
END;
