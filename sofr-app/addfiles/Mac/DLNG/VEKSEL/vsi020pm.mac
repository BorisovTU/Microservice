/*
$Name:         vsi020pm.mac
$Module:       Собственные векселя
$Description:  Эмиссия собственного векселя - Б.Оформление оплаты векселей
Simanov
*/
IMPORT PaymInter, VSInter, OprInter, DealsInter, 
       vscateg, vs4each, vsaccnt, vsrep, vspmfutu, vscngst, vslib, vsdates,
       vsyesno, vsconv, dlvaprds, vscarry, vsinitrec, vsdisc;
import "mail.mac", role_model;
import "u_common_email_utils.mac";


/* Счета, остатки на счетах и характеристики векселя и т.п.
   сохраняются в глобальных переменных.
   Вычисляются на наиболее ранних этапах шага
   (в тот момент, когда их уже можно определить).
   Используются далее в функциях. Как правило, функции
   нижнего уровня не имеют параметров (применяют глобальные переменные).
*/
PRIVATE var
            Paym,
            Договор,
            StepDate,
            ДатаВыставления,
            ИнтегрРежимРаботы = false;


PRIVATE Const L_OBJTYPE_LEVELESSENTIAL_EPS = 4,
              L_OBJTYPE_LEVELESSENTIAL_AC = 1;


/* Информация о вексельном счете: номер, валюта, сумма (предполагаемая к зачислению), остаток по счету.
*/
PRIVATE CLASS Info (_Счет, ВалНом, _ВалУч, _Amount)
var
     Счет = _Счет, PFI = ВалНом, ВалУч = _ВалУч, Amount = _Amount, Rest = MoneyL(0);
END;


/* Класс (массив) вексельных счетов по договору.
*/
PRIVATE CLASS BnrsArray ()
PRIVATE var Inf = TArray;
VAR
   MsgStr = "", НеНулевойОстаток = false, ВсеВексСчНулевые = true;

   Inf.Size = 0;

   PRIVATE MACRO find(Acc)
     var i = 0;
     while (i < Inf.size)
       if(Inf[i].Счет == Acc)
         return i;
       end;
       i = i + 1;
     end;
     return -1;
   END;

   MACRO add(acc, Amount, PFI, ВалУч)
    var i = find(acc);
      if(i == -1)
         Inf[Inf.Size] = Info(Acc, PFI, ВалУч, Amount);
      else
         Inf[i].Amount = Inf[i].Amount + Amount;
      end;
   END;

   /* Осуществляет проверку ненулевого остатка на вексельных счетах.
      Одновременно формирует строчку сообщения.
   */
   MACRO ПолучитьОстатки()
   VAR
     stat = 0, i = 0, j = 0, Rest = MoneyL(0), S = "";
   CONST
     LINES = 6;

     НеНулевойОстаток = false;
     MsgStr = "";

     while((stat == 0) AND (i < Inf.size))
       if(not ПолучитьОстаток(Rest, Inf[i].Счет, Inf[i].ВалУч, StepDate))
          stat = Ошибка("Ошибка при получении остатка|счета ", Inf[i].Счет);
       else
          Inf[i].Rest = Rest;
          if(Rest > MoneyL(0))
            if(not НеНулевойОстаток)
               /* найден первый ненулевой остаток */
               НеНулевойОстаток = true;
               MsgStr = String("На вексельных счетах обнаружены остатки:|",
                               Inf[i].Счет, " обнаружен остаток ", Inf[i].Rest);
               j = j + 1;
            else
               /* был уже ненулевой остаток, надо дополнять строчку */
               if(j < LINES - 1)
                  /* дополняем свободно */
                  MsgStr = String(MsgStr, "|", Inf[i].Счет, " обнаружен остаток ", Inf[i].Rest);
                  j = j + 1;
               else
                  /* Запоминаем пока временный буфер */
                  S = String(Inf[i].Счет, " обнаружен остаток ", Inf[i].Rest);
                  j = j + 1;
               end;
            end;
          end;
       end;
       i = i + 1;
     end;
     /* Вышли из цикла, возможно к формируемой строчке надо добавить последнюю строчку */
     if(j > LINES)
       MsgStr = String(MsgStr, "|...");
     end;
     if(S != "")
       MsgStr = String(MsgStr, "|", S);
     end;
     if(MsgStr != "")
       MsgStr = String(MsgStr, "|Выполнять проводки по оплате векселей?");
     end;

     return (stat == 0);
   END;

   /* Осуществляет тестирование остатков на вексельных счетах.
   */
   MACRO ТестОстатков()
   CONST
     BASIC = 0, STOP = 1, CONTROL = 10;
   VAR
     stat = 0, i = 0, РежВыпОпл = BASIC, answer, yesno;

     while((stat == 0) AND (РежВыпОпл != STOP) AND (i < Inf.size))
       if(РежВыпОпл == BASIC)
          if((paym.PayerBankID == {OurBank}) OR (ИнтегрРежимРаботы == false))
              /* счет плательщика в нашем банке или не ИнтегрРежимРаботы */
              answer = VS_YesNoCancel(MsgStr);
              if(answer == 1)
                РежВыпОпл = STOP; /* выходим из цикла, считаем, что все векс.счета нулевые, пользователь разрешил выполнять проводки */
              elif(answer == 2)
                РежВыпОпл = CONTROL; /* контроль остатков*/
              elif(answer == 3)
                stat = 1; /* выходим с ошибкой, останов шага */
              end;
          else
              if(Inf[i].Rest < Inf[i].Amount)
                  msgbox("На вексельном счете ", Inf[i].Счет,
                         "|недостаточно средств для оплаты векселей",
                         "|остаток счета  ", Inf[i].Rest,
                         "|сумма векселей ", Inf[i].Amount
                         );
                  stat = 1; /* выходим с ошибкой, останов шага */
              elif(ИнтегрРежимРаботы)
                  РежВыпОпл = CONTROL; /* контроль остатков*/
              elif((yesno = GetTrue(true, String(
                         "На вексельном счете ", Inf[i].Счет,
                         "|обнаружен остаток ", Inf[i].Rest,
                         "|Продолжить выполнение операции?"
              ))) == true)
                  РежВыпОпл = CONTROL; /* контроль остатков*/
              else
                stat = 1; /* выходим с ошибкой, останов шага */
              end;
          end;
       end;
       if(РежВыпОпл == CONTROL)
          /* очевидно, что сюда попадаем, если осуществляется контроль остатков */
          if(Inf[i].Rest >= Inf[i].Amount)
             ВсеВексСчНулевые = false;
          elif((Inf[i].Rest != MoneyL(0)) OR (not ВсеВексСчНулевые))
             msgbox("На вексельном счете ", Inf[i].Счет,
                    "|недостаточно средств для оплаты векселей",
                    "|остаток счета  ", Inf[i].Rest,
                    "|сумма векселей ", Inf[i].Amount
                    );
             stat = 1; /* выходим с ошибкой, останов шага */
          end;
       end;
       i = i + 1;
     end;

     return (stat == 0);
   END;

   MACRO MakeBookpass()
   VAR
     stat = 0, i = 0, Purpose = String("Выдача векселей по Дог. " + Договор.OrderNumber + " от " + Договор.SignDate + " с контрагентом " + Договор.ContractorName); //Simanov
     var pm_trans;

     while((stat == 0) AND (i < Inf.size))
       if(Inf[i].Amount > MoneyL(0))

         pm_trans = paym.MakeTransaction();
         if (pm_trans != NULL)
           pm_trans.Ground = DL_VOOP_MakeBPassGround2( paym.PaymentID, Purpose );
           
           pm_trans.SumPayer = VS_Convert(Inf[i].Amount, StepDate, Inf[i].PFI, paym.PayerFIID);
           pm_trans.FIIDPayer = paym.PayerFIID;

           pm_trans.SumReceiver = VS_Convert(Inf[i].Amount, StepDate, Inf[i].PFI, Inf[i].ВалУч);
           pm_trans.AccountReceiver = Inf[i].Счет;
           pm_trans.FIIDReceiver    = Inf[i].ВалУч;

           //Simanov
           pm_trans.Number_Pack     = "55";
           pm_trans.UserField2      = "1"; /// DEF-51968
           pm_trans.Oper            = GetMainOperInGroup(Договор.DocKind);
           
           if (not ПроводкаСПроверкойСчетов(pm_trans))
              MsgBox("Ошибка при создании проводки по платежу");
              stat = 1;
           end;
         else
             MsgBox("Ошибка при создании объекта класса RsbPaymTransaction");
             stat = 1;
         end;

       end;
       i = i + 1;
     end;

     return (stat == 0);
   END;
END;

PRIVATE var obj; /* Объект класса BnrsArray */


/* Выполняет инициализацию
*/
PRIVATE MACRO Инициализация()

    if(not VS_CheckWorkMode_INTEGRATED(@ИнтегрРежимРаботы))
       return false;
    end;

    obj = BnrsArray(StepDate, paym);

    return true;
END;


/* Изменяет дату выставления векселя
*/
PRIVATE MACRO УстановитьДатуВыставленияВекселя(bnr, leg, НовыйСчет:@variant)
var
  stat = 0, дата = ДатаВыставления, fd;

  ПоУмолчанию(дата, StepDate);

  if(дата < leg.rec.Start)
     /* стало быть выставили вексель через архивный платеж, значит: дату не изменяем (#51911) */;
  elif(not VS_SetStartDateOnBanner(bnr.rec.BCID, дата))
     stat = Ошибка("Ошибка при изменении|даты выставления векселя");
  else
     /* Изменяем первичный документ для новой даты выставления векселя */
     leg.rec.Start = дата;
     fd = VSBannerFD(bnr, leg);
     if(not ПолучитьСчетВекселя("Наш вексель", fd, НовыйСчет, MC_OPENACC_CHECKPERIOD, fd.ОпределитьВалютуУчета(), NULL, StepDate))
        stat = 1;
     end;
  end;

  return (stat == 0);
END;


/* Определяет счет плательщика в зависимости от того:
     - в нашем ли банке контрагент
     - или неинтегрированный режим
*/
/*
PRIVATE MACRO ОпрСчетПлательщика()

//   if((emi.ContractorBankCode != "") AND (ИнтегрРежимРаботы == false))
   if((paym.PayerBankID != {OurBank}) AND (ИнтегрРежимРаботы == false))
      // неинтегрированный режим, берем корсчет из корсхемы
      paym.FuturePayerAccount = paym.GetCorAccount ("Д");
   else
      paym.FuturePayerAccount = paym.PayerAccount;
   end;

   return true;
END;*/


/* Проверка выполненности шага "Зачет взаимных требований"
   операции "Зачет требований"
*/
PRIVATE MACRO ПроверкаВыпШагаЗачет(ДогЗачета)
var
   stat = false, DocumentID = "";

   VS_MakeDocumentID(ДогЗачета, DocumentID, DL_VSINTERCHANGE);
 
   if(DocumentID != "")
     stat = Opr_GetLastExecStepBySymbol(ДогЗачета.rec.DocKind, DocumentID, "З");
   end;

   return stat;
END;


/* Возвращает ошибку, если проверка договора эмиссии на факт оплаты 
   по договору "зачет требований" успешна.
*/
PRIVATE MACRO ПроверкаПривязкиКЗачету()
var
    stat = 0,
    Ok,
    find=false,
    ord_copy = TRecHandler("dl_order.dbt"), /* Копия договора эмиссии */
    ДогЗачета= TBfile("dl_order.dbt"), /* договор Зачета */
    dlordlnk = TBfile("dlordlnk.dbt"),
    spg      = TBfile("spground.dbt"),
    llvalues = TBfile("llvalues.dbt"),
    zero_date=date(0,0,0);

   if(Договор.DateOfPayment!=zero_date) /* Если дата платежа */
     dlordlnk.KeyNum = 1;
     dlordlnk.rec.RelatedContractID = Договор.ContractID;
     dlordlnk.rec.BaseContractID = 0;
     Ok = dlordlnk.GetGE;
     while( Ok and (not find) and (not stat))
        if(not ПоискДоговора(ДогЗачета, dlordlnk.rec.BaseContractID))
          stat=Ошибка("Не найден договор ", dlordlnk.rec.BaseContractID);
        else
          find = ПроверкаВыпШагаЗачет(ДогЗачета);
        end;
       Ok = dlordlnk.next;
     end;

     if (find) /* Найден выполн. шаг "зач.требов." операции "зач.требов." */
       llvalues.KeyNum=0;
       llvalues.rec.List=OBJTYPE_KINDDOC;    /* Вид документа */
       llvalues.rec.Element=ДогЗачета.rec.ContractKind;
       Ok=llvalues.GetEQ;
       Ok=ПоискРегистратора(spg, ДогЗачета);
       stat = Ошибка("Договор оплачен по ", 
                     "| ",llvalues.rec.Name,
                     "| N ",   spg.rec.Xld,
                       " от ", String(spg.rec.SignedDate:f),
                     "|Для продолжения операции необходимо откатить и", 
                     "|повторно выполнить шаг настройки оплаты векселей.");
     end;
   end;

   return (stat == 0);
END;

PRIVATE Macro ПолучитьБонус(leg)
  var bonus = leg.rec.ReceiptAmount - leg.rec.Principal;
  if (bonus < 0)
    bonus = $0;
  end;
  return bonus;
end;


/*  Контроль
*/
PRIVATE MACRO Контроль()
var
    stat = 0,
    FirstSymb = SubStr(paym.FuturePayerAmount, 1, 2);

    if((ИнтегрРежимРаботы) AND (paym.PayerBankID != {OurBank}) AND (paym.FuturePayerAmount != 0))
       stat = Ошибка("Плановый платеж не скитован полностью");
    elif ( (paym.PayerBankID == {OurBank}) and not ((FirstSymb != "40") or (FirstSymb != "30")) )
       stat = Ошибка("Не верный счет плательщика");
    end;

    return (stat == 0);
END;


/*  1. ОбрДатуВыст
*/
PRIVATE MACRO ОбрДатуВыст()
var
    stat = 0;

    if((ИнтегрРежимРаботы) AND (paym.PayerBankID != {OurBank}))
       ДатаВыставления = FindPaymentFactValueDate(paym.PaymentID);
       if((ДатаВыставления == null) or (ДатаВыставления == date (0, 0, 0))) 
          ДатаВыставления = StepDate;
       end;
    else
       ДатаВыставления = StepDate;
    end;

    return (stat == 0);
END;


/* Получает номер векс. счета и заносит номер счета и
   номинал в массив векс. счетов.
*/
PRIVATE MACRO ЗанестиВМассив(bnr, leg, emi)
var
   stat = 0, Счет = "", fd, bonus;
   
   if(bnr.rec.BuyFIID == paym.PayerFIID) //Simanov. временное решение 498070 //14.11.2019 убрал временное решение в связи с доработкой дистрибутива
     fd = VSBannerFD(bnr, leg);
     if(not ПолучитьСчетВекселя("Наш вексель", fd, Счет, MC_OPENACC_CHECKEXIST, fd.ОпределитьВалютуУчета(), NULL, StepDate))
        stat = 1;
     else
        obj.Add(Счет, leg.rec.ReceiptAmount - ПолучитьБонус(leg), leg.rec.PFI, fd.ОпределитьВалютуУчета());
     end;
   end;

   return stat;
END;


/*  Подготовка к оплате
*/
PRIVATE MACRO ПодготовкаКОплате()
var
   stat = ДляКаждогоВекселя(Договор, @ЗанестиВМассив, VSORDLNK_K_ALL, null, "BL");
   return (stat == 0);
END;


/*  Проверка оплаты
*/
PRIVATE MACRO ПроверкаОплаты()
var
   stat = 0;

   obj.ВсеВексСчНулевые = true;

   if(not ПодготовкаКОплате())
      stat = 1;
   elif(not obj.ПолучитьОстатки())
      /* ошибка */;
      stat = 1;
   elif(not obj.НеНулевойОстаток)
      /* нет ненулевого остатка, значит все векс.счета - нулевые, можно дальше не тестировать */;
   elif(not obj.ТестОстатков())
      /* ошибка, приводит к откату шага */;
      stat = 1;
   end;

   return (stat == 0);
END;

// Возвращает два счета векселя - открытый на шаге "Актуализация счетов"
//   и счет с новой срочностью, если на дату оформления срочность счета изменилась
// Счета могут совпадать
PRIVATE MACRO ПолучитьОбаСчетаВекселя(bnr, leg, fd, СтарыйСчет:@variant, НовыйСчет:@variant)

   if(not ПолучитьСчетВекселя("Наш вексель", fd, СтарыйСчет, MC_OPENACC_CREATE, fd.ОпределитьВалютуУчета(), NULL, StepDate))
      return false;
   end;
   НовыйСчет = СтарыйСчет;
   return УстановитьДатуВыставленияВекселя(bnr, leg, @НовыйСчет);

END;




/* Перед выполнением проводки по оплате векселя осуществляется
      проверка изменения диапазона срочности вексельного счета.
   При изменении срочности производится изменение номинала в массиве
   (Последующие проводки будут производится перебором элементов массива).
*/
PRIVATE MACRO ПоправитьСрочность(bnr, leg, emi, order, i, lnk)
var
   stat = 0, Cur, fd, СтарыйСчет = "", НовыйСчет = "";

   if(bnr.rec.BuyFIID == paym.PayerFIID)
     fd = VSBannerFD(bnr, leg);
     Cur = fd.ОпределитьВалютуУчета();

  //   if(not ПолучитьСчетВекселя("Наш вексель", fd, СтарыйСчет, MC_OPENACC_CREATE, Cur, NULL, StepDate))
  //      stat = 1;
  //   elif(not УстановитьДатуВыставленияВекселя(bnr, leg, @fd, @НовыйСчет))
  //      stat = 1;
     if(not ПолучитьОбаСчетаВекселя(bnr, leg, fd, @СтарыйСчет, @НовыйСчет))
        stat = 1;
     elif(СтарыйСчет != НовыйСчет)
        obj.Add(СтарыйСчет, -leg.rec.ReceiptAmount + ПолучитьБонус(leg), leg.rec.PFI, Cur);
        obj.Add(НовыйСчет, leg.rec.ReceiptAmount - ПолучитьБонус(leg), leg.rec.PFI, Cur);
     end;
   end;

   return stat;
END;


/*  Перед выполнением проводок по оплате, просматриваем счета по договору,
      при изменении диапазона срочности векселя, подправляем элементы массива
      (уменьшаем сумму у старого счета, увеличиваем у нового)
*/
PRIVATE MACRO ПроверитьСрочность1()
VAR stat = 0;
    stat = ДляКаждогоВекселя(Договор, @ПоправитьСрочность, VSORDLNK_K_EMISSION, null, "BL");
    return (stat == 0);
END;


/*  Если процесс контроля вексельных остатков не выявил значений
      (то есть вексельный счет - совершенно чистый),
      выполняем проводки по оплате векселя (параллельно контролируя диапазон срочности
      вексельных счетов).
*/
PRIVATE MACRO ВыпПроводкиПоОплате()
var
    stat = 0;

    if((paym.PayerBankID != {OurBank}) AND (ИнтегрРежимРаботы == true))
       /* Счет не в нашем банке, а режим - интегрированный */
       //Simanov stat = Ошибка("На вексельном счете недостаточно средств");
       stat = Ошибка("Платеж не сквитован");
       return stat;
    end;

    // Актуализируем платеж
    paym.Actuate();

    if(paym.FuturePayerAccount == "")
       msgbox("Не задан счет плательщика");
       stat = 1;
    elif(not VS_ChangeStat(paym, PM_READIED, null, StepDate))
       stat = Ошибка("Ошибка при формировании|платежа по оплате векселя");
    elif(not ПроверитьСрочность1())
       stat = 1;
    elif(not obj.MakeBookpass())
       stat = 1;
    end;

    return stat;
END;

/* Проверка срочности вексельного счета.
*/
PRIVATE MACRO ПровСрочВексСчета(bnr, leg, emi, order, i, lnk)
var
   stat = 0, Cur, fd, СтарыйСчет = "", НовыйСчет = "";

   if(bnr.rec.BuyFIID == paym.PayerFIID)
     fd = VSBannerFD(bnr, leg);
     Cur = fd.ОпределитьВалютуУчета();

  //   if(not ПолучитьСчетВекселя("Наш вексель", fd, СтарыйСчет, MC_OPENACC_CREATE, Cur, NULL, StepDate))
  //      stat = 1;
  //   elif(not УстановитьДатуВыставленияВекселя(bnr, leg, @fd, @НовыйСчет))
  //      stat = 1;
     if(not ПолучитьОбаСчетаВекселя(bnr, leg, fd, @СтарыйСчет, @НовыйСчет))
        stat = 1;
     elif(СтарыйСчет == НовыйСчет)
        /* счет не изменился, больше ничего не делаем */;
     elif(Проводка(СтарыйСчет, НовыйСчет, leg.rec.ReceiptAmount - ПолучитьБонус(leg),
                   String("Перенос по срочности "), 0, 0,
                   Cur,   // Валюта проводки
                   NULL, NULL, StepDate)
     != 0)
        stat = Ошибка("Ошибка при выполнении|проводки переноса по срочности");
     end;
   end;

   return stat;
END;


/*  Если в процессе контроля вексельных счетов обнаружились правильные остатки,
      тогда проводку по оплате не выполняем, а проверяем только срочность счетов.
*/
PRIVATE MACRO ПроверитьСрочность()
VAR stat = 0;
    stat = ДляКаждогоВекселя(Договор, @ПровСрочВексСчета, VSORDLNK_K_EMISSION, null, "BL");
    return stat;
END;

/*  Оформление оплаты векселей
*/
PRIVATE MACRO ОформлОплатыВекс()
var stat = 0;

   if(obj.ВсеВексСчНулевые)
     stat = ВыпПроводкиПоОплате();
   else
     stat = ПроверитьСрочность();
   end;

   return (stat == 0);
END;


/* Запуск шага
*/
MACRO ExecuteStep(Buffer, dl_order)
var
   stat = 0;
   var Payms;

   record order( dl_order );

   SetBuff( order, dl_order );

   Договор = order;

   if(not VS_TestStepDate(DATE_EMI_DOC, @StepDate, order.SignDate))
      return 1;
   end;

   Payms = TRsbDataSet(  "select t_PaymentID from dpmpaym_dbt "
                       + " where t_DocKind = " + Договор.DocKind
                       + "   and t_DocumentID = " + Договор.ContractID
                       + "   and t_Purpose = " + PM_PURP_VEKSEL
                      );
   while((not stat) and (Payms.moveNext()))
     if(not ПроверкаПривязкиКЗачету())
        stat = 1;
     elif(((paym = MyRsbPayment(Payms.PaymentID)) == null)
           OR (paym.PaymentID == 0))
        stat = Ошибка("Не найден платеж для|договора ", Договор.ContractID);
     elif(not Инициализация())
        stat = 1;
     elif(not Контроль())
        stat = 1;
     elif(not ОбрДатуВыст())
        stat = 1;
     elif(not ПроверкаОплаты()) 
        stat = 1;
     elif(not ОформлОплатыВекс())
        stat = 1;
     elif(not ПервПризнание(Договор, StepDate, VSORDLNK_K_EMISSION))
        stat = Ошибка("Ошибка выполнения первоначального признания");
     elif (not РасчетДисконта(Договор, StepDate))
        stat = 1;
     elif (not СменитьСтатусНаОпл(Договор, StepDate, VSORDLNK_K_EMISSION))
        stat = 1;
     elif(not ((ИнтегрРежимРаботы) AND (paym.PayerBankID != {OurBank}) AND (paym.FuturePayerAmount != 0)))
        if (not VS_ChangeStat(paym, PM_FINISHED, null, StepDate)) /* Статус платежа Завершен */   
          stat = Ошибка("Ошибка изменения статуса платежа");
        else
          if (not VS_ChangeVSBNRPAYM(paym.PaymentID, StepDate))
            stat = Ошибка("Ошибка изменения статуса платежа");
          end;
        end;
     end;
   end;

   if(not stat)
     if(not DL_ChangeDLORDER(Договор.ContractID, "DateOfPayment", ДатаВыставления))
        stat = 1;
     end;
   end;

   return stat;
END;


/* Макрос постобработки 
*/
MACRO PostStep (    
                CommitOrRollback, /*1-выполнение шага,2 -отакат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    if (errTrn OR (CommitOrRollback==2)) 
        /* Произошла ошибка или происходит откат */
        return;
    end;
   record order( dl_order );
   SetBuff( order, FirstDoc );

   var Kind = RSDCommand( "select party_read.is_legal_entity(?) NeedSend from dual" );
   Kind.addParam( "", RSDBP_IN, Order.Contractor );
   Kind.execute();
   var DataSet = TRsbDataSet(Kind);
   if(DataSet.moveNext() and (DataSet.NeedSend == 1))
      /*BOSS-5356 Отправка договора со статусов 30-оплачено в ДБО ЮЛ "Свой бизнес"*/
      var SendBillDeal = RSDCommand( "BEGIN IT_NDBOLE.send_bill_deal_json(?, ?); END;" );
      SendBillDeal.addParam( "", RSDBP_IN, Order.ContractID );
      SendBillDeal.addParam( "", RSDBP_IN, 30 /*оплачено*/);
      SendBillDeal.execute();
   end;

   var v_email_processor = c_email_proc_env();
   var mail_arr;

   if ( Order.Department == 1)
     mail_arr = GetContact("[02] Специалист ДРРК по операциям с векселями");
   else
     mail_arr = GetContact("[03] Специалист по оформлению операций с векселями", Order.Department);
   end;

   var i = 0;

   while (i < mail_arr.Size)
    v_email_processor.m_add_email_to_list(mail_arr(i));
    i = i + 1;
   end;

   v_email_processor.m_set_msg_head("Уведомление об оплате");
   v_email_processor.m_add_row_to_msg_text("Прошла оплата по операции выдачи № " + order.OrderNumber + "\nПожалуйста, завершите выполнение операции");

   /* Сохраняем текст письма для отправки плановой процедурой */
   v_email_processor.m_save_to_submit();
   /* Отправляем все не отправленные письма */
   v_email_processor.m_submit_email_asynch();

    Печать(true, "vsrep", ID_Operation, ID_step, isOprMultiExec, "СП"); /* Счета, Проводки */
 
    return 1;
END;


/* Макрос печати 
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    if(not Печать(false, "vsrep", ID_Operation, ID_step, isOprMultiExec, "СП")) /* Счета, Проводки */
      msgbox("Нет документов для печати");
      exit(1);
    end;

    return 1;
END;


