/*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 5.1                                          R-Style Software Lab

  File Name   : vslib.mac
  Programmer  : Велигжанин А.В.
  Comment     : Функции общего употребления
                библиотеки векселей
  Функции     : 
                CountSymb
                VS_IIF
                InList
                StrAfter
                StrBefore
                StrCut
                ПоУмолчанию
└───────────────────────────────────────────────────────────────────────────*/

IMPORT BankInter, globals;

const
  Left=1, Right=2;


/* Установка переменной, если она не определена
*/
MACRO ПоУмолчанию(переменная, значение) 
  if (ValType(переменная)==V_UNDEF) 
      setparm(0,значение);
  end;
end;


/*  Возвращает кол-во символов 'c'
    в строке 's'
    Предполагается, что символы
    идут подряд.
    Например: s=="01234ФФФФФ1234",c=="Ф"
    Результат: 5
*/
macro CountSymb( s, c )
var l=0,p=Index(s,c);
    if(p!=0)
       l=1;
       while( SubStr(s,p+l,1)==c )  
         l=l+1;
       end;
    end;
    return l;
end;


/* Возвращает ИСТИНу, если значение 
   переменной 'v' есть среди
   полученных параметров
*/
PRIVATE MACRO InList(v)
var i=1,Ok=false,val;
  while((not Ok) and getparm(i,val))
    Ok=(val==v);
    i=i+1;
  end;
  return Ok;
END;


/* Обрезает символы 'c' в строке 's'
   k=0-обрезает слева и справа(по умолчанию)
     1-только слева
     2-только справа
   Например: s="00123004500",c='0'
   Результат     "1230045"        (k=0)
                 "123004500"      (k=Left)
               "001230045"        (k=Right)
*/
MACRO VS_StrCut( s, c, k )
var n, p, l, Ok, i;
   if(ValType(c)!=V_STRING)
     c=" ";
   end;
   if((ValType(k)!=V_INTEGER) or (not InList(k,0,Left,Right)))
     k=0;
   end;
   n=strlen(s);
   p=1;
   l=n;
   Ok=true;
   i=1;
   if(k!=Right)
     /* Первый проход по строке
        с начала до конца
        определение позиции 'p'
     */
     while(Ok and (i<=n))
       if(SubStr(s,i,1)==c) 
         if(Ok)
           p=p+1;
           l=l-1;
          end;
       else
         Ok=false;
       end;
       i=i+1;
     end;
   end;
   if(k!=Left)
     /* Второй проход по строке
        с конца в начало
     */
     i=n;
     Ok=true;
     while(Ok and (i>=1))
       if(SubStr(s,i,1)==c) 
         if(Ok)
           l=l-1;
          end;
       else
         Ok=false;
       end;
       i=i-1;
     end;
   end;
   return SubStr(s,p,l);
END;

/* Привести строку к заданному размеру 
     Str       [IN/OUT] - исходная строка
     Len       [IN]     - требуемая длина
     FillSymbol[IN]     - символ-заполнитель до нужной длины, если строка короче 
     LeftAlignment[IN]  - если TRUE, то выравнивние по левому краю (по умолчанию по правому)
*/
MACRO VS_StrFill( Str:STRING, Len:INTEGER, FillSymbol:STRING, LeftAlignment:BOOL )
   var SourseLen;

   Str       = trim( Str );
   SourseLen = strlen( Str );

   if( LeftAlignment == null ) /*по умолчанию выравнивание по правому краю*/
      LeftAlignment = false;
   end;   

   if( FillSymbol == null ) /*по умолчанию заполнить нулями*/
      FillSymbol = "0";
   end;   

   if( SourseLen >= Len ) 
      if( LeftAlignment ) /*обрезаем справа (последние (SourseLen-Len) символов*/
         Str = SubStr( Str, 1, Len );            
      else /*обрезаем слева (первые (SourseLen-Len) символов) */
         Str = SubStr( Str, (SourseLen-Len+1), Len ); 
      end;
   else  
      if( LeftAlignment ) /*дополняем заданным символом справа*/ 
         Str = Str + mkstr( FillSymbol, Len-SourseLen );  
      else /*дополняем заданным символом слева*/ 
         Str = mkstr( FillSymbol, Len-SourseLen ) + Str;
      end;
   end;

   return Str;
END;


/* Аналог условной функции.
   Возвращает 'value_true',
   когда условие 'condition' выполняется(ИСТИНА)
   или 'value_false'.
*/
MACRO VS_IIF(condition,value_true,value_false)
    if (condition)
        return value_true;
    else 
        return value_false;
    end;
END;


/* Возвращает строку 's'
   до символа 'c' 
   Например: s="abcdefg.xyz",c='.'
   Результат   "abcdefg"
*/
MACRO StrBefore( s, c )
   var p=Index(s, c);
   return VS_IIF(p==0,s,SubStr(s,1,p-1));
END;


/* Возвращает строку 's'
   после символа 'c' 
   Например: s="abcdefg.xyz",c='.'
   Результат   "xyz"
*/
MACRO StrAfter( s, c )
   var p=Index(s, c);
   return VS_IIF(p==0,"",SubStr(s,p+1));
END;


/* Возвращает дату 'd'
   в виде строки для отчета
*/
MACRO DateStr( d )
var s;
   if (d==Date(0,0,0))
       DateSplit ({curdate},null,null,s);
       s = "\"___\"__________ "+ s + " г.";
   else
       s = String(d:m:f);
   end;
   return s;
END;


/* дополнение строки слева нулями до нужной длины,
   если длина строки больше нужной, строка обрезается слева
*/ 
MACRO StrTrimLeft( num, len )
VAR
   s=trim(string(num)),
   l=strlen(s);

   if(l==len)
      /*возвращаем без изменений*/;
   elif (l>len)
      /*обрезаем*/
      s=SubStr(s,l-len+1,len);          
   else
      /*дополняем*/
      s=mkstr("0",len-l)+s;
   end;

   return s;
END;


