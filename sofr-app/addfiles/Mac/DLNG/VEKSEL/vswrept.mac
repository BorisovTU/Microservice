/* ───────────────────────────────────────────────────────────────────────────┐
    RS-Bank                                        R-Style Software Lab Ltd
    Файл подсистемы "Векселя"

    Печать отчета Word-ом на терминале.

    SRR 24.04.2001
└─────────────────────────────────────────────────────────────────────────── */
IMPORT rslx, vsreptl;

PRIVATE FILE tags () txt;

/* Открыть документ по шаблону. Вернет открытый документ */
PRIVATE MACRO OpenWordDocumentByDot( DotFileName )
    WordApp = ActiveX( "Word.Application", null, TRUE );

    if (WordApp==null) 
        return null;
    end;

    FullDotFileName = VSREPTL_GetFullDotFileName (DotFileName);

    /* Проверить, можно ли найти шаблон документа по указанному пути */
    if( not existFile ( FullDotFileName ) )
       msgbox( "Не найден файл-шаблон ", FullDotFileName, ".|Проверьте правильность пути" );
       return null;
    end;
   
    WordDoc = WordApp.Documents.Add( FullDotFileName, FALSE );
   
    if( WordDoc == null )
       msgbox( "Ошибка открытия файла-шаблона ", FullDotFileName );
       WordApp.Quit;
       return null;
    end;

    return WordDoc;
end;

/* Увеличение числа, которым заканчивается строка, на j
      Вход: xxxx123, 5. Результат: xxxx128.
*/
PRIVATE MACRO IncTail(str, j)
var
   i = 0, ch, l, stop = false;

   if(ValType(j) != V_INTEGER)
     j = INT(j);
   end;

   if(j == 0)
      return str;
   end;

   if(ValType(str) != V_STRING)
     str = String(str);
   end;

   if((l = strlen(str)) == 0)
      return String(j);
   end;

   while(not stop)
      if(i == l)
         return String(INT(str) + j);
      else
         ch = Substr(str, l - i, 1);  /* рассматриваем строку с конца */
         if(ch == "0")
           i = i + 1;
         elif(INT(ch) != 0)
           i = i + 1;
         else
           stop = true;
         end;
      end;
   end;                                     

   if(i == 0)
     return String(str, j);
   else
     return String(Substr(str, 1, l-i), INT(Substr(str, l-i+1, i)) + j);
   end;

END;


/* Определяет имя новой закладки.
   Если name содержит подстроку "_dup_" и перед ней стоит число,
   то увеличивает его на 1. 
     Например name = "Test5_dup_7", результат работы функции "Test6_dup_7"

   Если перед подстрокой "_dup_" не число, то увеличивает на 1 число 
   стоящее в конце строки.
     Например name = "Test_dup_7", результат работы функции "Test_dup_8"
*/
PRIVATE MACRO ОпредИмяНовЗакл( name, i )
var p, l = strlen(name), head, ch;

  if((p = Index(StrLwr(name), "_dup_")) > 0)
    /* k = цифра найденная перед подстрокой "_dup_" */
    ch = SubStr(name, p-1, 1);
    head = SubStr(name, 1, p-1);
    if((ch == "0") OR (INT(ch) > 0))  /* если найденный символ является числом */
      return String(IncTail(head, i), Substr(name, p, l-p+1));
    end
  end;

  return IncTail(name, i);

END;


/* Размножить строку таблицы.
   'str' - представляет собой строку вида: "_tabno_\n_rows_", где
    _tabno_ - номер изменяемой таблицы в документе.
     _rows_ - кол-во добавляемых строк.
*/
PRIVATE MACRO MultipleRow( wd, str )
var 
    p = Index(str, "\n"), 
    tabno,                     /* номер таблицы */
    rows = 0, 
    i,                         /* строка таблицы */
    j,                         /* столбец */
    n,                         /* кол-во закладок в ячейке */
    k,                         /* индекс текущей закладки */
    table, 
    bookmark,
    NewBkmName, NewBkmRange, NewBkmOffset, NewBkmEnd,
    columns;
  
   tabno = Substr(str, 1, p - 1);
   rows = INT(Substr(str, p + 1));
    
   if((tabno < 0) or (tabno > wd.Tables.Count))
     /* неверный индекс таблицы */
     return;
   elif(rows <= 0)
     /* неверное кол-во строк для добавления */
     return;
   end;

   table = wd.Tables(tabno);
   columns = table.range.cells.count / 2;

   i = 0;
   while( i < rows )
     Table.Rows.Add;
     j = 0;
     while( j < columns)
       /* копируем текст ячейки */
       Table.Rows(i+3).Cells(j+1).Range.Text = Table.Rows(2).Cells(j+1).Range.Text;   
       /* перенос закладки */
       n = Table.Rows(2).Cells(j+1).Range.Bookmarks.Count;
       k = 0;
       while( k < n )
         Bookmark = Table.Rows(2).Cells(j+1).Range.Bookmarks(k+1);
         if(Bookmark.Range.InRange(Table.Rows(2).Cells(j+1).Range))
            /* определение имени новой закладки */
            NewBkmName = ОпредИмяНовЗакл(Bookmark.Name, i+1);
            NewBkmRange = Bookmark.Range;
            NewBkmOffset = Bookmark.Range.Start - Table.Rows(2).Cells(j+1).Range.Start;
            NewBkmRange.Start = Table.Rows(i+3).Cells(j+1).Range.Start + NewBkmOffset;
            NewBkmEnd = NewBkmRange.Start + GenGetProp(Bookmark.Range, "End") - Bookmark.Range.Start;
            GenSetProp (NewBkmRange, "End", NewBkmEnd);
            Table.Rows(i+3).Cells(j+1).Range.Bookmarks.Add (NewBkmName, NewBkmRange);
         end;
         k = k + 1;
       end;
       j = j + 1;
     end;
     i = i + 1;
   end;

END;


/* Обработка дубликатов закладок в документе 'wd'.
     Для закладок вида 'закладка_dup_номер', копирует содержимое
     из оригинальной закладки вида 'закладка', если она есть.
   Обновление происходит в 2 этапа:
     на первом запоминается информация о дубликатах и их тексте.
     на втором данная информация заносится в закладки-дубликаты.
   Обновление сразу невозможно, т.к. при обновлении закладок 
     сбивается их последовательность.
*/
PRIVATE MACRO ResolveDupBookmarks( wd )
var
   i = 0,                           /* индекс закладки */
   bookmark,                        /* текущая закладка */
   p,                               /* позиция фрагмента _dup_ в имени закладки */
   origin,                          /* имя оригинальной закладки */
   text, 
   tagrange,
   name,
   dup = 0, 
   j = 0,
   n = wd.Range.Bookmarks.Count;    /* кол-во закладок в документе */
array
   info;

   /* первый этап: заполнение информационного массива
   */
   while (i < n)
     Bookmark = wd.Range.Bookmarks(i+1);
     name = Bookmark.name;
     p = Index(StrLwr(name), "_dup_");
     if(p > 1)
         info(j) = name;
         info(j+1) = "";
         origin = Substr(name, 1, p - 1);
         if (wd.Bookmarks.Exists(origin))    /* запоминаем оригинал, если он есть */
             info(j+1) = wd.Bookmarks(origin).Range.Text;
         end;
         j = j + 2;
         dup = dup + 1;
     end;
     i = i + 1;
   end;

   /* Второй этап: обновление закладок-дубликатов
   */
   i = 0;
   j = 0;
   while (i < dup)
     if(info(j+1) == "") 
       /* нечем обновлять */;
     elif(wd.Bookmarks.Exists(info(j)))    /* обновить дубликат, если он есть */
        tagrange = wd.Bookmarks(info(j)).Range;
        tagrange.Text = info(j+1);
        GenSetProp (tagrange,"End", tagrange.Start + strlen(info(j+1)));
     end;
     j = j + 2;
     i = i + 1;
   end;

END;


/* Удаляет строку в таблице, где есть закладка 'tag'.
     Если удаление строки имело место, процесс дальше не продолжается,
     т.к. в этом случае сбиваются индексы строк таблицы, а возвращается true.
*/
PRIVATE MACRO RemoveRowWithTag( wd, tag )
var
  t, r, c,
  tables, rows, columns,
  table,
  tagrange;

  if(not wd.Bookmarks.Exists(tag)) 
     /* закладки нет, ничего не делаем */
     return false;
  else
     tagrange = wd.Bookmarks(tag).Range;
  end;

  tables = wd.Tables.Count;
  t = 0;
  while( t < tables )
    table = wd.Tables(t+1);
    rows = table.rows.count;
    r = 1;
    while( r < rows )
      if(r == 1)
        columns = table.rows(1).Cells.Count;
      end;
      c = 0;
      while( c < columns )  
        if(tagrange.InRange(Table.Rows(r+1).Cells(c+1).Range))
           Table.Rows(r+1).Delete;
           return true;
        end;
        c = c + 1;
      end;
      r = r + 1;
    end;
    t = t + 1;
  end;

  /* Если ~#R_метка не относится ни к одной строке таблицы,
     нужно просто удалить содержимое метки.
  */
  tagrange.Text = "";
  GenSetProp(tagrange,"End", tagrange.Start + strlen(""));

  return false;
END;


/* Удаляет строки в таблице, где есть закладка вида "~#R_закладка"
*/
PRIVATE MACRO RemoveRows( wd, tags )
   rewind(tags);
   while (Next(tags))
       if(Substr(tags.str,1,4) == "~#R_" )
          while(RemoveRowWithTag(wd, Substr(tags.str,5)))
            /* продолжаем, пока не удалим все строки с закладками */
          end;
       end;
   end;
END;


/*Заполнить вордовый файл данными из файла с тегами*/
PRIVATE MACRO FillOneDocumentFromTagFile(WordDoc,tags)
    tagfound = false;
    while ((not tagfound) and Next(tags))
        if (SubStr(Trim (tags.str),1,1) == "~")
            tagfound = true;
        end;
    end;

    while (tagfound)
        tag = SubStr(Trim (tags.str),2);
        tagstr = null;
        tagfound = false;
        while ((not tagfound) and Next(tags))
            if (SubStr(Trim (tags.str),1,1)=="~")
                tagfound = true;
            elif (tagstr==null)
                tagstr = tags.str + "\n";
            else
                tagstr = tagstr + tags.str + "\n";
            end;
        end;

        if(tagstr==null)
            tagstr = "";
        else
            tagstr = Substr (tagstr, 1, strlen (tagstr)-1); /*Последний перевод строки обрезаем*/
        end;
        
        if( tag == "MultipleRow" )
            /* размножить строку таблицы */
            MultipleRow(WordDoc, tagstr);
        elif (WordDoc.Bookmarks.Exists(tag))    /* обновить закладку */
            tagrange = WordDoc.Bookmarks(tag).Range;
            WordDoc.Bookmarks(tag).Range.Text = tagstr;
            GenSetProp (tagrange,"End",tagrange.Start+strlen(tagstr));
            WordDoc.Bookmarks.Add (tag, tagrange);
        end;
    end;

    WordDoc.Fields.Update;
END;

/*Напечатать */
MACRO VSWREPT_PrintReportFromTagFile (tagfilename, IsTerm)
    if (not IsTerm)
        VSREPTL_InitServerWork();
    end;

    if (not open (tags,tagfilename))
        msgbox ("Источник данных не открыт");
        return false;
    end;

    if (Next(tags))
        dotfilename = trim (tags.str);
    else
        return false;
    end;

    if (Next(tags))
        docfilename = trim (tags.str);
    else
        return false;
    end;

    WordDoc = OpenWordDocumentByDot (dotfilename);
    if (WordDoc==null)
        return false;
    end;

    FillOneDocumentFromTagFile (WordDoc, tags);

    /* Обработать дубликаты закладок */
    ResolveDupBookmarks(WordDoc);

    /* Удалить строки, если нужно */
    RemoveRows(WordDoc, tags);
    Close (tags);

    /* Записать документ в RTF формате */
    WordDoc.SaveAs( VSREPTL_GetFullTxtFileName(docfilename)/*, 6*/ ); /* 6 - RTF*/

    WordDoc.Application.Visible = true;
    WordName = WordDoc.Application.Name;
    if (WordDoc.Application.Tasks.Exists(WordName))
        WordDoc.Application.Tasks(WordName).Activate(false);
    else
        WordDoc.Application.Activate;
    end;

    return true;
END;