/*
$Name:         vs4each.mac
$Module:       Векселя банка
$Description:  Итератор для выполнения действий для каждого векселя по договору
*/

IMPORT vslib, RsbDataSet;

/* Возвращает ИСТИНу, если роль удовлетворяет шаблону.
*/
PRIVATE MACRO ПроверитьРоль(lnk, шаблон, IsParticular)
var Ok = true;

  if(Шаблон == VSORDLNK_K_ALL)
    /* подходят все*/;
  else
    /* в эмиссии важна 'особая связь'*/
    if(ValType(IsParticular) == V_UNDEF)
       Ok = (lnk.rec.LinkKind == шаблон);
    elif(IsParticular)
       Ok = ((lnk.rec.LinkKind == шаблон) AND (lnk.rec.IsPartycular == "X"));
    else
       Ok = ((lnk.rec.LinkKind == шаблон) AND (lnk.rec.IsPartycular == ""));
    end;
  end;
  return Ok;
END;


/*  Для каждого векселя договора с идентификатором 'ContractID',
    имеющего правильную роль 'role' выполняет действие 'action'.
    Возвращает 0, если все действия произведены успешно
      data - общие данные для каждого векселя
      mode - содержит информацию о том, нужно ли осуществлять 
             поиск векселя, ценовых условий и договора эмиссии
             
    Иногда зовется для д-ра эмиссии, который сама передает в action (3-й параметр - emi).
       (См. repay2.mac ВексельПоследний())
    В этом случае в параметре order вместо д-ра (dl_order.dbt) 
    можем получить сделку мены СВ-УВ (dl_tick.dbt).
    Причем, эту сделку мы передадим в action вместо д-ра 4-м параметром!!!
*/
MACRO ДляКаждогоВекселя(order, action, role, data:@variant, mode, IsParticular)
PRIVATE VAR 
            bnr   = TBfile ("vsbanner"),
            leg   = TBfile ("dl_leg"),
            lnk   = TBfile ("vsordlnk"),
            ord   = TBfile ("dl_order"),
            tck   = TBfile ("dl_tick.dbt"),   /* сделка эмиссии векселя (сделка мены) */
            needBnr,              /* нужно ли искать вексель */
            needLeg,              /* нужно ли искать цен.условия */
            needEmi,              /* нужно ли искать договор эмиссии */
            emi   = TBfile ("dl_order"),
            emiLnk = TBfile ("vsordlnk"),
            Ok = true,
            needPgs = false,
            bcid, ContractID,DocKind, otype, i, n, retstat = 0,
            sql = "";

    otype = ValType(order);
    if(otype == V_UNDEF)
      return 0;
    elif(otype == V_GENOBJ)
      if   (order.FileName == "dl_tick.dbt")
         ContractID   = order.rec.DealID;
         DocKind      = order.rec.BofficeKind;
      elif (order.FileName == "dl_order.dbt")
         ContractID   = order.rec.ContractID;
         DocKind      = order.rec.DocKind;
      elif (order.FileName == "vsfrmord.dbt")
         ContractID   = order.rec.FrmOrdId;
         DocKind      = DL_WRITEOFF_RDM_BNR;
      else
         return 0;
      end;
    else
      if   (FileName(order) == "dl_tick.dbt")
         ContractID   = order.DealID;
         DocKind      = order.BofficeKind;
      elif (FileName(order) == "dl_order.dbt")
         ContractID   = order.ContractID;
         DocKind      = order.DocKind;
      elif (FileName(order) == "vsfrmord.dbt")
         ContractID   = order.FrmOrdId;
         DocKind      = DL_WRITEOFF_RDM_BNR;
      end;
    end;                   

    ПоУмолчанию(role, VSORDLNK_K_ALL);
    ПоУмолчанию(mode, "BLE");

    mode = StrUpr(mode);
    needBnr = (Index(mode, "B") > 0);
    needLeg = (Index(mode, "L") > 0);
    needEmi = (Index(mode, "E") > 0);

    /* Оценка кол-ва записей
    */
    if(not VS_GetVekselNumberInOrder(n, 0, role, ContractID, DocKind))
      n = 100;
    end;
    needPgs = (n > 1);

    /* Индекс ContractID+BCID*/
    sql = " t_DocKind = " + string(DocKind)
        + " and t_ContractID = " + string(ContractID);

    if (role != VSORDLNK_K_ALL)
      sql = sql
          + " and t_LinkKind = " + string(role);
    end;

    lnk.AddFilter(sql);

    Ok = lnk.Next();

    if(needPgs)
       InitProgress(n, "", "");
    end;
    i = 0;

    while(Ok and (lnk.rec.ContractID == ContractID)) 
        BCID = lnk.rec.BCID;

        if(ПроверитьРоль(lnk, role, IsParticular))  /* роль подошла */
            if(needBnr)
              ok = ПоискВекселя(bnr, BCID);
              if(not ok)
                 Ошибка("Не найден вексель ", BCID);
              end;
            end;

            if(ok AND needEmi)
                if((lnk.rec.LinkKind == VSORDLNK_K_EMISSION) AND (lnk.rec.IsPartycular == "X"))
                    emi = order;
                    Copy(emiLnk, lnk);
                elif((emi.FileName == "dl_order.dbt") and (not VS_FindOrder(bnr.rec.BCID, VSORDLNK_K_EMISSION, emi, emiLnk, true)))
                    /* договора эмиссии (сделки) может и не быть - это не ошибка
                       (например, для векселя из другого филиала) */
                    emi = ord;
                elif(emiLnk.rec.DocKind != DL_VEKSELACCOUNTED)
                    /* документ эмиссии - договор */
                else
                    /* документ эмиссии - сделка */
                    tck.KeyNum = 0;
                    tck.rec.DealID = lnk.rec.ContractID;
                    tck.GetEQ;
                    emi = tck;
                end;
            end;

            if(ok AND needLeg)
              if (not ПоискЦеновыхУсловийВекселя(leg, BCID))
                ok = false;
                Ошибка("Не найдены ценовые условия векселя ",BCID);
              end;
            end;

            if(ok)
                ok = (ExecMacro2(@action, bnr, leg, emi, order, i, lnk, @data, emiLnk) == 0);
            end;

            if(ok)
              i = i + 1;
              if(needPgs)
                 UseProgress(i);
              end;
            else
                retstat = 1;
            end;
        elif ((role!=VSORDLNK_K_ALL) and (not ok))
            retstat = 2; /*Закончили сканирование*/
        else
            ok = true;
        end;

        ok = ok and lnk.next; /*Продолжаем*/
    end;

    lnk.DropFilter();

    if(needPgs)
       RemProgress();
    end;

    if (retstat == 2)
        retstat = 0;
    end;

    return retstat;
END;


/*  Для каждого договора, связанного с текущим договором 'ContractID',
    выполняет действие 'action'.
    Возвращает 0, если все действия произведены успешно
      data - общие данные
      mode - содержит информацию о том, нужно ли осуществлять 
             поиск договора и др. недостающую информацию.
*/
MACRO ДляКаждогоСвязДоговора(order, action, data:@variant, mode)
PRIVATE var lnk   = TBfile ("dlordlnk"),
            ord   = TBfile ("dl_order"),
            needOrd,              /* нужно ли искать связанный договор */
            Ok,
            ordID, ContractID, otype, i;

    otype=ValType(order);
    if(otype == V_GENOBJ)
      ContractID = order.rec.ContractID;
    else
      ContractID = order.ContractID;
    end;
    lnk.keyNum = 0;   /* Индекс BaseContractID + RelatedContractID */
    lnk.rec.BaseContractID = ContractID;
    lnk.rec.RelatedContractID = 0;
    Ok = lnk.GetGE;

    ПоУмолчанию(mode, "O");
    mode = StrUpr(mode);
    needOrd = (Index(mode, "O") > 0);

    i = 0;
    while(Ok)
       Ok = (lnk.rec.BaseContractID == ContractID);
       if(Ok)
          ordID = lnk.rec.RelatedContractID;

          if(needOrd)
            if(not ПоискДоговора(ord, ordID))
               return Ошибка("Не найден договор ", ordID);
            end;
          end;

          if(ExecMacro2(@action, order, lnk, ord, i, @data) == 0)
            i = i + 1;
          else
            return 1;
          end;

          Ok = lnk.next;
       end;
    end;

    return 0;
END;


/* Что-то делает для каждого платежа по договору
*/
MACRO VS_ForEachPaym(doc, Purpose, action, data:@variant, data2:@variant)
var
    payms = TBfile("pmpaym.dbt"), Ok, 
    DocID = 0, DocKind = 0, ttype, stat = 0;

    VS_IsDocument(doc, NULL, @DocKind, @DocID);

    payms.KeyNum = 1;
    payms.rec.DocKind = DocKind;
    payms.rec.DocumentID = DocID;
    payms.rec.Purpose = Purpose;
    payms.rec.SubPurpose = 0;
    payms.AddFilter("t_DocKind = " + DocKind + " AND t_DocumentID = " + DocID + " AND t_Purpose = " + Purpose);
    Ok = payms.GetGE;

    while(Ok and (stat == 0)) 
      if(ExecMacro2(@action, doc, payms, @data, @data2) == 0)
         Ok = payms.next; // переходим к след.платежу
      else
         stat = 1;
      end;
    end;
    payms.DropFilter();

    return stat;
END;


/*  Для каждого бланка, связанного с распоряжением,
    выполняет действие 'action'.
    Возвращает 0, если все действия произведены успешно
      data - общие данные
*/
MACRO VS_ForEachForm(fmo, action, data:@variant)
  VAR stat = 0, sqltext, DataSet, form = TBfile("vsform.dbt"), lnk = TBfile("objlink.dbt") ;

  sqltext = " SELECT "
              + " SUBSTRC(t.t_AttrID, 0, INSTRC(t.t_AttrID, ' ') - 1) AS t_Series "
              + " ,LPAD(SUBSTRC(t.t_AttrID, INSTRC(t.t_AttrID, ' ') + 1), 20, ' ') AS t_Number, "
              + " T_LINKID AS t_LinkId "
          + " FROM "
              + " DOBJLINK_DBT t "
          + " WHERE "
              + " t.t_ObjectType = 667 " // OBJTYPE_VSFRMORD
          + " AND t.t_GroupID = 1 " // OBJGROUP_VSFRMORD
          + " AND t.t_AttrType = 1 " // OBJATTR_VSFRMORD_BLANKS
          + " AND t.t_ObjectID = " + UniID(fmo, 0, DL_VSFRMORD) + " ";

  DataSet = TRsbDataSet(sqltext);
  stat = DataSet.MoveNext();
  
  while(stat)
    form.Clear();

    form.rec.Series = SQL_ConvTypeStr(DataSet.Series);
    form.rec.Number = SQL_ConvTypeStr(DataSet.Number);

    stat = form.GetEQ();

    if(not stat)
      RunError("Не найден бланк: Серия " + form.rec.Series + " N " + Trim(form.rec.Number));
    else
      lnk.rec.LinkId = DataSet.LinkId;
      if (not lnk.GetEQ())
        lnk.Clear();
      end;
      if(ExecMacro2(@action, form, lnk, @data) == 0)
        stat = DataSet.MoveNext();
      else
        stat = 1;
      end;
    end;
  end;
   
  return (stat == 0);
END;
