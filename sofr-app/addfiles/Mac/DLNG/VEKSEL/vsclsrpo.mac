/*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 5.1                                          R-Style Software Lab
  File Name   : vsclsrpo.mac
  Programmer  : Азарёнок Ю.Г.
  Операция    : Печать вексельных договоров
  Comment     : Классы хранящие информацию необходимую при печати
└───────────────────────────────────────────────────────────────────────────*/
IMPORT FIInter, vspmfutu, dlreport;

CONST
       code = 0,
       name = 1;

/* ************** -Группы векселей- ************************ */
//Изменена структура группы. добавлены новые параметры, группировка идёт по более широкому списку параметров

CLASS OneGrp (всдат, ном, ср, датП, цен, став, ЦУ, сер, нум, всдерж, счт ) /* информации о векс. */
 var векселедатель, номинал, срок, датаП, цена, ставка, колич, PFI, Start, Expiry, серия, номер, всДержатель, счет;

 векселедатель = всдат; 
 номинал       = ном;
 срок          = ср; 
 датаП         = датП;
 цена          = цен;
 ставка        = став;
 колич         = 1;
 PFI           = ЦУ.rec.PFI;
 Start         = ЦУ.rec.Start; 
 Expiry        = ЦУ.rec.Expiry;
 серия         = сер;
 номер         = нум;
 всДержатель   = всдерж; //первый векселедержатель
 счет          = счт;    //счет учета векселя, 523...
END;


CLASS ГруппыВекс ()
 var ArrGrp = TArray; /* Массив групп  */
  ArrGrp.size = 0;

  MACRO НоваяГруппа(векселедатель, номинал, срок, датаП, цена, ставка, ЦУ, серия, номер, всДержатель, счет)
   ArrGrp[ArrGrp.size] = OneGrp(векселедатель, номинал, срок, датаП, цена, ставка, ЦУ, серия, номер, всДержатель, счет);
  END;

  MACRO НайтиВГруппе(номинал, срок, датаП, ДатаП_2, цена, ставка, серия, всДержатель)
   var i = 0;   
    while (i < ArrGrp.size)    
      if((ArrGrp[i].номинал     == номинал    ) and
         (ArrGrp[i].срок        == срок       ) and
         (ArrGrp[i].датаП       == датаП      ) and
         (ArrGrp[i].цена        == цена       ) and
         (ArrGrp[i].ставка      == ставка     ) and
         (ArrGrp[i].серия       == серия      ) and
         (ArrGrp[i].Expiry      == ДатаП_2    ) and
         (ArrGrp[i].всДержатель == всДержатель))
        return i;       
      end;
      i = i + 1;
    end;
   return -1;
  END;


  MACRO ДобавьВГруппу (i, номер, счет)
     ArrGrp[i].номер = ArrGrp[i].номер +", " + номер;
     ArrGrp[i].счет = ArrGrp[i].счет +", " + счет;
     ArrGrp[i].колич = ArrGrp[i].колич + 1;

  END;

  MACRO Группировать(векселедатель, номинал, срок, датаП/*maturity*/, ДатаП_2/*expiry*/, цена, ставка, ЦУ, серия, номер, всДержатель, счет)
   var i = НайтиВГруппе(номинал, срок, датаП, ДатаП_2, цена, ставка, серия, всДержатель);
     if ( i != -1)
        ДобавьВГруппу (i, trim(номер), счет);                       
     else
        НоваяГруппа(векселедатель, номинал, срок, датаП, цена, ставка, ЦУ, серия, trim(номер), всДержатель, счет);       
     end;
         
  END;

END;
/* ********** Конец -Группы векселей с ролью эмиссия- *********************** */


/* ************** -Массив информации о векселях- ************************* */
CLASS OneBnr (векс, связь, цен_усл, _СчетНоминала ) /* информации об одном векселе */
 var bnr = TRecHandler ("vsbanner"),  
     lnk = TRecHandler ("vsordlnk"),
     leg = TRecHandler ("dl_leg");
 var СчетНоминала = _СчетНоминала;

  copy( bnr, векс);
  copy( lnk, связь);
  copy( leg, цен_усл);
END;

CLASS МассивыВекс ()
 var ArrBnr    = TArray, /* Массив векселей  */
     ArrBnr_ms = TArray; /* Массив векс.с ролью "продажа" дог. Мены */

 MACRO ДобавьВМассив(векс, связь, цен_усл, флаг )
   var СчетНоминала;
   var FD = VSBannerFD(DL_VSBANNER, векс.rec.BCID);

   ПолучитьСчетУчетаНоминала(векс, FD, {curdate}, @СчетНоминала, false);

   if ( флаг == null )
     ArrBnr[ArrBnr.size] = OneBnr (векс, связь, цен_усл, СчетНоминала )
   else
     ArrBnr_ms[ArrBnr_ms.size] = OneBnr (векс, связь, цен_усл, СчетНоминала )
   end;
 END;

END;
/* ********** Конец -Массив информации о векселях- *********************** */


/* **************** -Класс для хранения платежей договора- ****************** */
CLASS ПлатежиДоговора ()
PRIVATE  var i, Payms = TArray, N_paym_default = 0;

  MACRO ДобавьПлатеж(Платеж, default)
   if (default != null) 
    N_paym_default = Payms.size;/* номер платежа по умолчанию */
   end;
   Payms[Payms.size] = Платеж;
/*   Payms[Payms.size] = TRecHandler("pmpaym");
   copy(Payms[Payms.size-1], Платеж);*/
  END;
 
 /* Поиск платежа в массиве Payms по назначению */
  MACRO НайтиПлатеж(назн)
    i=0;
    while (i < Payms.size)
      if (Payms[i].Purpose == назн)
        return Payms[i];
      end;
     i=i+1;
    end;
   return false;
  END;

  MACRO ПлатежПоУмолчанию()
   if (Payms.size != 0)
     return Payms[N_paym_default];
   else
     return null;
   end;
  END;

  MACRO ВалютаПлатежаПоУмолчанию()
   if (Payms.size != 0)
     return Payms[N_paym_default].ReceiverFIID;
   else
     return -1;
   end;
  END;
  
  MACRO КоличествоПлатежей()
   return Payms.size;
  END;
END;
/* ********** Конец -Класс для хранения платежей договора- ****************** */

/*   -Вспомогательный класс для хранения информации по привязанным договорам- */
CLASS LnkOrd (ID_дог, ID_осн, платеж, СуммаЗачета, payFIID)
 var
    ContractID, SpgID, Paym, SetOff, FIID;

 ContractID = ID_дог;      /* ID привяз.договора */
 SpgID      = ID_осн;      /* ID основания привяз.договора */
 Paym       = платеж;      /* ID платежа привязанного к договору "оплата векселя"*/
 SetOff     = СуммаЗачета; /* Сумма зачета по договору */
 FIID       = payFIID;     /* валюта суммы зачета по договору */
END;

/* По CodeKind возвращает название
*/
PRIVATE MACRO НайтиНазвВидаКодаСубъекта(ID)
   return DL_GetCodeKindName(ID);
END;

/* 
   Возвращает код или наименование банка, 
   в котором указан корсчет банка получателя.

*/
PRIVATE MACRO НайтиКодИлиНазвБанка( CorrCodeKind, CorrCode, mode)
 var Name="",
     party = TBfile("party.dbt"), 
     partcode = TBfile("partcode.dbt"),
     Ok;

  partcode.KeyNum = 1;
  partcode.rec.CodeKind = CorrCodeKind;
  partcode.rec.Code= CorrCode;
  Ok = partcode.GetEQ;
  if (Ok)
    if (mode==code)
     return Name=partcode.rec.Code;
    end;
    party.KeyNum = 0;
    party.rec.PartyID = partcode.rec.PartyID;
    Ok = party.GetEQ;    
    if (Ok)
     Name=party.rec.Name;
    end;
  end;

 return Name;
END;

/* Класс ДогЗачетТреб предназначен для */
CLASS ДогЗачетТреб ( ДогЗачета )

 PRIVATE  var i=0, 
              stat=0,
              ord_copy = TRecHandler("dl_order.dbt"); /* Копия договора зачета */

 var  InfLinkOrd = TArray; /* Массив информации по договорам привязанным к Зачету */


  /* делаем копию, потому что при поиске связ.дог. позиция dl_order изменится */
  copy(ord_copy, ДогЗачета); 

  /* Поиск основания договора по ID */
  PRIVATE MACRO FindSpg(spg, ID)
    var Ok=false;
    spg.KeyNum = 0;
    spg.rec.SPgroundID = ID;
    Ok = spg.GetEQ;
    return Ok;
  END;

  /* По договору зачета находит и инициализирует массив класса LnkOrd */
  MACRO Init()
    var Ok,
        ord      = TBfile("dl_order.dbt"),
        paym, /* Платеж оплата векселя */
        spg      = TBfile("spground.dbt"),
        dlordlnk = TBfile("dlordlnk.dbt");

     InfLinkOrd.size = 0;

     dlordlnk.KeyNum = 0;
     dlordlnk.rec.BaseContractID =ord_copy.rec.ContractID;
     dlordlnk.rec.RelatedContractID = 0;
     Ok = dlordlnk.GetGE;
     while( Ok and (not stat) and (dlordlnk.rec.BaseContractID == ord_copy.rec.ContractID) )
        if(not ПоискДоговора(ord, dlordlnk.rec.RelatedContractID))
          stat=Ошибка("Не найден договор ", dlordlnk.rec.RelatedContractID);
        elif(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractID, PM_PURP_VEKSEL, 0)) == null) OR
             (paym.PaymentID == 0))
          stat = Ошибка("Не найден платеж для", 
                        "| договора ", ord.rec.ContractID);
        elif(not ПоискРегистратора(spg, ord))
          stat = Ошибка("Не найден входящий/исходящий",
                        "|документ для договора ", ord.rec.ContractID);
        else 
          InfLinkOrd[InfLinkOrd.size] = LnkOrd ( ord.rec.ContractID, spg.rec.SPgroundID, 
                          paym, dlordlnk.rec.ReconciliationAmount, paym.PayerFIID );
          Ok = dlordlnk.next;                                                      
        end;
     end;
    return stat;
  END;
 
  /* Формирует теги для таблицы обязательст клиента перед банком */
  PRIVATE MACRO ФормТаблОбКлТеги()
    var paym,
        spg  = TBfile("spground.dbt"),
        ВсяСумОбязКл = 0;

    i = 0;   
    while ( i < InfLinkOrd.size)

     FindSpg(spg, InfLinkOrd[i].SpgID);

     println(String("~", "RelContrXId", i+1));
     println(spg.rec.Xld);
     println(String("~", "RelContrSigned", i+1));
     println(DateStr(spg.rec.SignedDate));

  /* По связанному договору находит платеж, чтобы определить 
     сумму обязательств клиента*/
    paym = InfLinkOrd[i].Paym;

    if (paym != NULL)
       println(String("~", "RelContrPaymentAmount", i+1));
       println(paym.ReceiverAmount:f);    
       println(String("~", "RelContrPaymentAmountWr", i+1));
       println(ValueWr(paym.ReceiverAmount, paym.ReceiverFIID));

       ВсяСумОбязКл = ВсяСумОбязКл + paym.ReceiverAmount;
    end;
    
    i = i+1;
    end; /* Конец цикла по связ.договорам */

    [~RelContrPaymentAmountTotal];
    println(ВсяСумОбязКл:f);
    
    if (paym != NULL)
       [~RelContrPaymentAmountTotalWr];
       println(ValueWr(ВсяСумОбязКл, paym.ReceiverFIID)); 
    end;
   
  END;

  PRIVATE MACRO ФормТаблЗачТеги()
   var ИтогСумЗач=0;
    i = 0;
    while ( i < InfLinkOrd.size) /* Цикл по связ.договорам */
       if(InfLinkOrd[i].SetOff == 0)
         println(String("~", "#R_", "RelContrReconciliationAmount", i+1)); /* будем удалять строку таблицы */
         println(String("~", "RelContrReconciliationAmount", i+1));
         println(InfLinkOrd[i].SetOff:f);
       else
         println(String("~", "RelContrReconciliationAmount", i+1));
         println(InfLinkOrd[i].SetOff:f);
         println(String("~", "RelContrReconciliationAmountWr", i+1));
         println(ValueWr(InfLinkOrd[i].SetOff,InfLinkOrd[i].FIID));  
         ИтогСумЗач = ИтогСумЗач + InfLinkOrd[i].SetOff; /* накручиваем итоговую сумму */
       end;
       i = i+1;
    end;/* Конец цикла по связ.договорам */
    [~RelContrReconciliationAmountTotal];
    println(ИтогСумЗач:f);
    if(InfLinkOrd.size > 0)
      [~RelContrReconciliationAmountTotalWr];
      println(ValueWr(ИтогСумЗач,InfLinkOrd[0].FIID));  
    end;

  END; /* Конец метода ФормТаблЗачТеги */

  PRIVATE MACRO ФормОбязКлТеги() /* PM_PURP_VSDIFF2B "Оплата разницы по договору банку"*/
   var
     OK;

   OK = MyRsbPayment(ord_copy.rec.DocKind, ord_copy.rec.ContractID, PM_PURP_VSDIFF2B, 0);
   if((OK == null) OR (OK.PaymentID == 0))
     [~SectionContractorPayment]; 
     println(""); /* Не нашли. Он может отстутствовать */
   else
     if (OK.PayerBankID == {OurBank})/* Если счет плательщика в нашем банке */
       [~CPPayerAccount];
       println(OK.PayerAccount);
     else
       println("");
     end;
     [~CPReceiverAccount];
     println(OK.ReceiverAccount);  
     [~CPPaymentAmount];       /* Величина разницы стоимостей векселей по договору */
     println(OK.ReceiverAmount);
     [~CPPaymentAmountWr];
     println(ValueWr(OK.ReceiverAmount, OK.ReceiverFIID)); 
     [~CPValueDateAgreed];
     println(OK.ValueDate);
     [~CPReceiverBankName];
     println(OK.ReceiverBankName);
     [~CPReceiverBankCode];
     if(OK.ReceiverBankID == {OurBank}) /* Если счет получателя в нашем банке */
       println(НашБик());
     else
       println(OK.ReceiverBankCode);
     end;
     [~CPReceiverBankCorrAcc];
     println(OK.ReceiverBankCorrAcc);
     [~CPReceiverBankCodeKind];
     println(НайтиНазвВидаКодаСубъекта(OK.ReceiverBankCodeKind));
     [~CPReceiverCorrBankCode];
     println(НайтиКодИлиНазвБанка(OK.ReceiverBankCorrCodeKind, OK.ReceiverBankCorrCode, code));
     [~CPReceiverCorrBankName];
     println(НайтиКодИлиНазвБанка(OK.ReceiverBankCorrCodeKind, OK.ReceiverBankCorrCode, name));
   end;
  END; /* Конец метода ФормОбязКлТеги */

  PRIVATE MACRO ФормОбязБнТеги()  /* PM_PURP_VSDIFF2C "Оплата разницы по договору клиенту"*/   
   var  OB;

    OB = MyRsbPayment(ord_copy.rec.DocKind, ord_copy.rec.ContractID, PM_PURP_VSDIFF2C, 0);
    if((OB == null) OR (OB.PaymentID == 0))
      [~SectionBankPayment];  /* Не нашли. Он может отстутствовать. */
      println("");
    else /*"Есть Оплата разницы по договору клиенту"*/
      if (OB.PayerBankID == {OurBank})/* Если счет плательщика в нашем банке */
        [~BPPayerAccount];
        println(OB.PayerAccount);
      else
        println("");
      end;
      [~BPReceiverAccount];
      println(OB.ReceiverAccount);

      [~BPPaymentAmount];       /* Величина разницы стоимостей векселей по договору */
      println(OB.ReceiverAmount);

      [~BPPaymentAmountWr];
      println(ValueWr(OB.ReceiverAmount, OB.ReceiverFIID)); 

      [~BPValueDateAgreed];   /* Предполагаемая дата платежа по договору */
      println(OB.ValueDate);

      [~BPReceiverBankName];  /* Название банка */
      println(OB.ReceiverBankName);

      [~BPReceiverBankCode]; 
      if(OB.ReceiverBankID == {OurBank}) /* Если счет получателя в нашем банке */
        println(НашБик());
      else
        println(OB.ReceiverBankCode);
      end;

      [~BPReceiverBankCorrAcc];
      println(OB.ReceiverBankCorrAcc);

      [~BPReceiverBankCodeKind];
      println(НайтиНазвВидаКодаСубъекта(OB.ReceiverBankCodeKind));
      [~BPReceiverCorrBankCode];
      println(НайтиКодИлиНазвБанка(OB.ReceiverBankCorrCodeKind, OB.ReceiverBankCorrCode, code));
      [~BPReceiverCorrBankName]; 
      println(НайтиКодИлиНазвБанка(OB.ReceiverBankCorrCodeKind, OB.ReceiverBankCorrCode, name));
    end;
  END;/* Конец метода ФормОбязБнТеги */

  MACRO ФормВсеТеги()
     ФормТаблОбКлТеги();
     ФормТаблЗачТеги();
     ФормОбязКлТеги();
     ФормОбязБнТеги();
  END;

END; /* Конец класса ДогЗачетТреб */
