/**
 @file vsreplib.mac
 @brief Функции уровня погашения векселя

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |22.12.2023 |Велигжанин А.В.|DEF-57381                                       |Во избежании межфилиальной проводки с счетом по категории
 |           |               |                                                |'НДФЛ к перечислению 15%' используется первичный документ 
 |           |               |                                                |ВЕКСЕЛЯ (а не договора).
*/

IMPORT FIInter, vscateg, vsacc, vs4each, vslib, vscarry, vsdisc, vsnptxcalcfun;

PRIVATE CONST
  Huge_Value = 1.0e10;
private var ОтключениеПереоценки = false;
CLASS RepAmountAndTax()
  var Amount = 0.0, 
      Cur = -1, 
      Tax = 0.0, 
      Tax13 = 0.0, 
      Tax15 = 0.0, 
      Tax18 = 0.0,
      Tax20 = 0.0,
      Tax22 = 0.0,
      TaxIncr = 0.0,
      IsReverse = false, 
      IsReverse15 = false, 
      Tax13_NatCur = 0.0, 
      Tax15_NatCur = 0.0,
      Tax18_NatCur = 0.0,
      Tax20_NatCur = 0.0,
      Tax22_NatCur = 0.0,
      Tax13_Raw = 0.0,
      Tax15_Raw = 0.0,
      Tax18_Raw = 0.0, 
      Tax20_Raw = 0.0,
      Tax22_Raw = 0.0, 
      Tax_Raw = 0.0,
      TaxIncr_Raw = 0.0,
      TaxIncr_NatCur = 0.0;
END;
  
Macro ПолучитьСтавкуПоКонтргенту(client, order)
  var rate = 0.0;
  var party = TBFile("party.dbt");
  var partyRec;
  var signDate;
  if (ValType(client)==V_INTEGER)
    party.rec.partyid = client;
    if (party.GetEQ())
      partyRec = party.rec;
    end;
  elif(ValType(client) == V_GENOBJ)
    partyRec = client.rec;
  else
    partyRec = client;
  end;

  if (order != null)
    if(ValType(order) == V_GENOBJ)
      signDate = order.rec.SIGNDATE;
    else
      signDate = order.SIGNDATE;
    end;
  else
    signDate = {curdate};
  end;



  if ((partyRec.legalform == PTLEGF_PERSN) and (partyRec.NotResident == SET_CHAR))
    if (ПолучитьЗначениеПримечанияНаДату(partyRec.PartyID, PARTY_NOTE_KIND_NPTX_RATE_NOTRES, signDate, @rate))
      rate = VS_GetSetting ("НАЛОГОВЫЙ УЧЕТ\\СТАВКА ФИЗ.ЛИЦА НЕРЕЗИДЕНТА");
    end;
  elif ((partyRec.legalform == PTLEGF_PERSN) and (partyRec.NotResident == UNSET_CHAR))
    rate = VS_GetSetting ("НАЛОГОВЫЙ УЧЕТ\\СТАВКА ФИЗ.ЛИЦА РЕЗИДЕНТА");
  elif ((partyRec.legalform == PTLEGF_INST) and (partyRec.NotResident == SET_CHAR))
    rate = VS_GetSetting ("НАЛОГОВЫЙ УЧЕТ\\СТАВКА ЮР.ЛИЦА НЕРЕЗИДЕНТА");
  elif ((partyRec.legalform == PTLEGF_INST) and (partyRec.NotResident == UNSET_CHAR))
    rate = VS_GetSetting ("НАЛОГОВЫЙ УЧЕТ\\СТАВКА ЮР.ЛИЦА РЕЗИДЕНТА");
  end;

  return rate;
end;
  
// Класса который может менять основание проводки для любой функции в которую попадает
// Для использование необходимо задать имена функций в которых мы хотели бы поменять
// Основание, а также функцию котороя будет создавать новое основание
// в Функцию по сазданию нового сонования прийдут все те параметры (а можно и больше всё зависит от вызова)
// которые необходимы для формирования проводки

CLASS GroundProxy
  VAR GroundBuilderFunctionsNames = TArray,
      GroundBuilderFunctions = TArray,
      GBFCount = 0;

  Macro AddGroundBuilderForFunction( FunctionName, GBFunction)
    GroundBuilderFunctionsNames(GBFCount) = FunctionName;
    GroundBuilderFunctions(GBFCount) = GBFunction;
    GBFCount = GBFCount + 1;
  END;

  // Проверка имеется ли билдер основания для данной функции
  Macro isHaveGB( FunctionName )
    var GBFN_en = GroundBuilderFunctionsNames.createEnum;
    // Перебераем все имеющиеся в наличии имена
    While (GBFN_en.next)
      if (GBFN_en.Item == FunctionName)
        // Нашли! Перекачиваем все входящие параметры
        return true;
      END;
    END;
    return false;
  END;

  // Функция котороя вызывается
  Macro BuildGround( FunctionName )
    var i = 1,n = 0,val, // i = 1 та как параметр название функции нам не нужен мы и так его знаем
        FunctionParameters = TArray,
        GBFN_en = GroundBuilderFunctionsNames.createEnum,
        BBF_en = GroundBuilderFunctions.createEnum,
        BuilderFunction,
        GroundString;
    // Перебераем все имеющиеся в наличии имена
    While (GBFN_en.next)
      BBF_en.next;
      // Ищим соответсвие в базе имен
      if (GBFN_en.Item == FunctionName)
        // Нашли! Перекачиваем все входящие параметры
        while (getparm (i,val))
          FunctionParameters(n) = val;
          i = i + 1; n = n + 1;
        end;
        BuilderFunction = BBF_en.Item;
        if (ExecMacro2(@BuilderFunction,FunctionParameters,@GroundString) == 0)
          return GroundString;
        END;
        MsgBox("Не удалось создать основание в функции: ",BuilderFunction);
      END;
    END;
    MsgBox("Для функции: ", FunctionName,"| Функция создания основания не задана");
    return "";
  END;

END; // GroundProxy

private class CurrencyParms
  var cur = NATCUR,
      БратьВалютуУчета = false;
end;

/* Возвращает валюту первого векселя по договору. Достаточно одной итерации
*/
PRIVATE MACRO GetCurrencyForFstBanner(bnr, leg, emi, order, i, lnk, prm:@variant)
   if(prm.БратьВалютуУчета)
     prm.cur = ОпределитьВалютуУчетаВекселя(bnr.rec.PayFIID, leg.rec.PFI);
   else
     prm.cur = leg.rec.PFI;
   end;

   return 1;
END;

/* Возвращает для полученного договора 'order' валюту векселя с ролью 'role'.
*/
MACRO VS_GetCurrencyForOrderBanners(order, role, cur:@variant, БратьВалютуУчета)
   var prm = CurrencyParms;

   prm.cur = NATCUR;
   prm.БратьВалютуУчета = БратьВалютуУчета;

   ДляКаждогоВекселя(order, @GetCurrencyForFstBanner, role, @prm, "BL");

   cur = prm.cur;

   return true;
END;

PRIVATE MACRO GetCalcTax(bnr, leg, emi, order, numOrd, lnk, S:@variant)
  var contractor;
  if(S.Cur == -1)
     S.Cur = lnk.rec.BCCFI;
  end;
  if(ValType(order) == V_GENOBJ)
    contractor = order.rec.contractor;
  else
    contractor = order.contractor;
  end;
  S.Amount = S.Amount + MoneyL(Round(double((VS_Convert(lnk.rec.TaxBaseAmount, lnk.rec.InterestChargeDate, lnk.rec.BCCFI, S.Cur) * ПолучитьСтавкуПоКонтргенту(contractor, order)) / 100), 0));

  return 0;
end;

/* Определяет сумму доходов по векселям
*/
PRIVATE MACRO GetIncome(bnr, leg, emi, order, numOrd, lnk, S:@variant)
  var PFI;

  if(ValType(leg) == V_GENOBJ)
    PFI = leg.rec.PFI;
  else
    PFI = leg.PFI;
  end;
  if(S.Cur == -1)
     S.Cur = lnk.rec.BCCFI;
  end;
  S.Amount = S.Amount + VS_Convert((VS_Convert(lnk.rec.BCCost, lnk.rec.InterestChargeDate, lnk.rec.BCCFI, PFI) - ПолучитьСуммуРазмещения(leg, bnr)),lnk.rec.InterestChargeDate, PFI,  S.Cur);

  return 0;
end;

/* Возвращает сумму налоговой базы
*/
MACRO VS_GetCalcTax(order, S:@variant)
  return ДляКаждогоВекселя(order, @GetCalcTax, VSORDLNK_K_DRAW, @S, null) == 0;
END;

/* Возвращает сумму дохода по векселям
*/
MACRO VS_GetIncome(order, S:@variant)
  return ДляКаждогоВекселя(order, @GetIncome, VSORDLNK_K_DRAW, @S, null) == 0;
END;

/* Возвращает счет для категории 'catname' по договору 'order' на дату 'Дата'
     Причем валюта счета определяется валютой векселя для данного договора с ролью 'role'
*/
MACRO VS_GetAccountOnOrder(order, catname, role, Дата, acc:@variant, БратьВалютуУчета)
VAR
   fd,
   cur = NATCUR,
   stat = 0;

   if((fd = VSOrderFD(order)) == null)
      stat = 1;
   elif(not VS_GetCurrencyForOrderBanners(order, role, @cur, БратьВалютуУчета))
      stat = 1;
   elif(not ПолучитьСчетВекселя(catname, fd, acc, MC_OPENACC_CREATE, cur, null, Дата))
   // #102019 Счет надо открывать с флагом MC_OPENACC_CREATE, а не MC_OPENACC_ACT,
   //  т.к. он может еще не существовать
      stat = 1;
   end;

   return (stat == 0);
END;

/* Получает дату последнего начисления процентов (взамен ПолучитьДатуПоследнегоНачисления() )
*/
PRIVATE MACRO GetLastAddHisDate(ContractID, StartDate)
VAR
    LastDate = StartDate;

    ДатаПоследнегоНачисленияПоВекселю(ContractID, StartDate, LastDate);

    return LastDate;
END;

/* Получает дату последней сервисной операции начисления ПДД
*/
MACRO ДатаПоследнейОперНачисленияПДД(BCID, Дата, ДПН:@variant)
  var query, Select, DataSet;

  query =   " select NVL(max(srv.t_valuedate),to_date('01.01.0001', 'dd.mm.yyyy')) t_valuedate from DVSSRVDOC_DBT  srv " +   
            "   join doprstep_dbt step on step.t_servdockind = srv.t_dockind and step.t_servdocid = srv.t_id " + 
            "   join doproper_dbt oper on oper.t_id_operation = step.t_id_operation and oper.t_dockind = " + DL_VSBANNER +
            "   join dvsbanner_dbt vsb on vsb.t_bcid = oper.t_documentid " +
            "  where vsb.t_bcid = ? and  srv.t_valuedate <= ? and srv.t_dockind = 167" /*DL_VSCHRGI*/ ;
  Select = RsdCommand(query);
  Select.addParam("", RSDBP_IN, BCID);
  Select.addParam("", RSDBP_IN, Дата);
  Select.execute();

  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    ДПН = date(DataSet.valuedate);
  end;

  return true;
END;

/* Параметры в функцию "ПодготовитьВексельКОплате"
*/
CLASS RepPrm()
VAR
   bnr,                                 /* вексель */
   leg,                                 /* его ценовые условия */
   vs_order,                            /* вексельный договор*/
   va_order,                            /* вексельный сделка*/
   lnk,                                 /* связка: вексель-договор */
   isPc,                                // true, если вексель - процентный
   isDiscount,                          // true, если вексель - дисконтный
   isExecution,                         // true, если вексель перенесен "к исполнению"
   fd,                                  // первичный документ векселя
   СчетЗачисления,
   Режим,
   Сп,                                  /* сумма к оплате (к погашению) */
   Спер,                                /* сумма, переведенная на счет */
   СперПр,                              /* сумма переведенных %% */
   СдопПр,                              /* сумма доначисленных %% */
   Скн,                                 /* сумма к начислению по %% */
   ОсткБСчПр,                           /* остаток балансового счета %% */
   СуммаСписДк,                         /* сумма списанного дисконта */
   СчетИсп = $0,                        // счет к исполнению
   ОсткИсп,                             // остаток счета к исполнению
   Номинал,
   ВалютаНоминала,
   ОстДиск,                             /* остаток дисконта */
   ДатаДоначисления,
   ДатаОформл,
   flag,
   StartPcDate, LastPcDate, NextPcDate, EndPcDate, AddPcDate,
   GrdBldr,                             /* Класс по формированию основания*/
   ОперацВыкупа,
   _RepAmountAndTax,                    /*структура с налогом*/
   pt_cntr,                             /*указатель на клиента*/
   NeedToTax,                           /*необязательный флаг на удержание налога*/

   toSeparateExecute = false,                   /*Флаг того, что будет проводить проводки на раздельные счета*/
   РаздСчетУчетаНоминала="",                    /*Раздельные счета для категорий учета для разбивки сумм*/
   РаздСчетУчетаДисконта="",                    /*Раздельные счета для категорий учета для разбивки сумм */
   РаздСчетУчетаПроцентов="",                   /*Раздельные счета для категорий учета для разбивки сумм */
   Налог_объект = RepAmountAndTax();    /*структура для возврата*/

PRIVATE const prccontract = TRecHandler ("prccontract");

   PRIVATE macro GetPc()
      StartPcDate = prccontract.rec.BeginDate;
      LastPcDate = GetLastAddHisDate(prccontract.rec.ContractID, StartPcDate);
      if(LastPcDate == StartPcDate)
         // не было начисления
         NextPcDate = LastPcDate;
      else
         NextPcDate = LastPcDate + 1;
      end;
      EndPcDate = VS_GetRightPcDate(prccontract, lnk.rec.InterestChargeDate);
      addPcDate = VS_GetRightPcDate(prccontract, ДатаОформл);
      if(NextPcDate > addPcDate)
         NextPcDate = addPcDate;
      end;
   END;

   macro Set(Вексель, ЦУ, СвязьВД, ДогВекс, Сделка, Дата, src_pt_cntr)
      pt_cntr = TRecHandler ("party");
      bnr = Вексель;
      leg = ЦУ;
      lnk = СвязьВД;
      vs_order = ДогВекс;
      va_order = Сделка;
      ПолучитьСубъекта(vs_order.Contractor, pt_cntr);
      fd = VSBannerFD(bnr, leg);
      ВалютаНоминала = leg.rec.PFI;
      Номинал = leg.rec.Principal;
      ОстДиск = bnr.rec.DiscountRemainder;
      isPc = ВексельПроцентный(leg);
      isDiscount = ВексельДисконтный(leg);
      Сп = lnk.rec.BCCost;
      Спер = MoneyL(0);
      СперПр = MoneyL(0);
      СуммаСписДк = MoneyL(0);
      Скн = MoneyL(0);
      ОсткБСчПр = MoneyL(0);
      ДатаДоначисления = Date(0,0,0);
      isExecution = (Index(bnr.rec.BCState, "И") != 0);

      if( vs_order != NULL )
        ОперацВыкупа = ОперацияВыкупа(vs_order.Kind_Operation);
      elif( va_order != NULL )
        ОперацВыкупа = ОперацияВыкупа(va_order.DealType);
      else
        msgbox("Ошибка при определении вида операции");
        return false;
      end;

      ПоУмолчанию(Дата, {curdate});
      ДатаОформл = Дата;

      if(isExecution)
        // был перенос на счет "к исполнению"
        if(not ПолучитьСчетВекселя("СВексель к исполнению", fd, СчетИсп, NULL, NULL, NULL, ДатаОформл))
           return false;
        elif(not ПолучитьОстаток(ОсткИсп, СчетИсп, fd.ОпределитьВалютуУчета(), ДатаОформл))
           return false;
        end;

        ОсткИсп = VS_Convert(ОсткИсп, ПолучитьДатуПоследОперацииПоВекселю( fd.GetBnr().rec, fd.GetLeg().rec, ДатаОформл ), fd.ОпределитьВалютуУчета(), leg.rec.PFI);
      end;

      if(isPc)                                 // если процентный
        if(not НайтиСчетПроцВекселя (prccontract, bnr.rec.BCID))
           return false;
        else
           GetPc();
        end;
        if (not isExecution)                   // если НЕе перенесен к исполнению
           if(not ПолучитьСуммуКНачисл_В(fd.GetBnr(), fd.GetLeg(), Дата, @Скн, @ОсткБСчПр))
             msgbox("Ошибка при получении суммы к начислению");
             return false;
           end;
        end;
      end;
      _RepAmountAndTax=RepAmountAndTax();
      return true;
   end;

/* Определяет сумму налога
*/
   PRIVATE MACRO GetTax(bnr, leg, emi, order, numOrd, lnk, S:@variant)
   var
     R = 0.0;
  var Sum1 = 0.0, Sum2 = 0.0, Sum3 = 0.0, Sum4 = 0.0, Sum5 = 0.0, Sum6 = 0,Sum7 = 0;
  var Rg = 0.13;
  var Rp = 0.15;
  var Max15 = 5000000;//предельное значение НОБ для расчета по основной ставке
  var EndDate = lnk.rec.InterestChargeDate;
  var Year;
  DateSplit(EndDate, NULL, NULL, Year);
  var BegDate = date(1, 1, Year);
  var refund = true;
   
  if(S.Cur == -1)
    S.Cur = lnk.rec.BCCFI;
  end;
   
  if(not VS_GetRegistryValue("ВЕКСЕЛЯ БАНКА\\РЕЖИМ РАБОТЫ\\ВОЗВРАТ ПЕРЕПЛАТЫ В ТЕЧЕНИЕ ГОД", V_BOOL, @refund))
    refund = true;
  end;
   
  S.Amount = S.Amount + VS_Convert(lnk.rec.BCCost, lnk.rec.InterestChargeDate, lnk.rec.BCCFI, S.Cur);
   
  R = ПолучитьСтавкуПоКонтргенту(pt_cntr, order);
   

  if((vs_order != NULL) and (vs_order.DocKind == DL_VSBARTERORDER) and (pt_cntr.rec.LegalForm == PTLEGF_PERSN) 
     and (pt_cntr.rec.NotResident != "X") and (EndDate >= date(1,1,2021)) )
        Sum2 = VS_Convert(lnk.rec.TaxBaseAmount, lnk.rec.InterestChargeDate, lnk.rec.BCCFI, NATCUR);

        var SumQuery = "select " +
                       "   (" +
                       "      select nvl(sum(nptxobjSum1.t_Sum0), 0) " +
                       "      from dnptxobj_dbt nptxobjSum1 " +
                       "      where nptxobjSum1.t_Kind = " + string(TXOBJ_PLUSG_2800) +
                       "        and nptxobjSum1.t_Client = party.t_PartyID" +
                       "        and nptxobjSum1.t_Date between ? and ?" +
                       "        and EXISTS (select ordlnk.* from dvsordlnk_dbt ordlnk where ORDLNK.T_CONTRACTID = NPTXOBJSUM1.T_ANALITIC1 and ORDLNK.T_LINKKIND = 1)" +
                       "   ) as t_Sum1," +
                       "   (" +
                       "      SELECT nvl(sum(nptxobjSum4.t_Sum0), 0)" +
                       "  FROM dnptxobj_dbt nptxobjSum4" +
                       " WHERE     nptxobjSum4.t_Kind = " + string(TXOBJ_PAIDBILL) +
                       "       AND nptxobjSum4.t_Client = party.t_PartyID" +
                       "       AND nptxobjSum4.t_Date BETWEEN ? " +
                       "                                  AND ? " +
                       "       AND (   EXISTS" +
                       "                  (SELECT ordlnk.*" +
                       "                     FROM dvsordlnk_dbt ordlnk" +
                       "                    WHERE     ORDLNK.T_CONTRACTID = nptxobjSum4.T_ANALITIC1" +
                       "                          AND ORDLNK.T_LINKKIND = 1)" +
                       "            OR (    nptxobjSum4.T_ANALITIC1 = -1" +
                       "                AND EXISTS" +
                       "                       (SELECT *" +
                       "                          FROM dnptxobdc_dbt obdc, DNPTXOP_DBT op" +
                       "                         WHERE     obdc.t_ObjID = nptxobjSum4.t_ObjID" +
                       "                               AND op.t_ID = obdc.t_DocID" +
                       "                               AND (   op.t_Kind_Operation = 2035" +       // расчет ноб
                       "                                    OR op.t_Kind_Operation = 2038))))" +   // удержание ндфл
                       "   ) as t_Sum4, " +
                       "   (" +
                       "      SELECT nvl(sum(nptxobjSum5.t_Sum0), 0)" +
                       "  FROM dnptxobj_dbt nptxobjSum5" +
                       " WHERE     nptxobjSum5.t_Kind = " + string(TXOBJ_PAIDGENERAL_15_9) + // PaidGeneral_15_9
                       "       AND nptxobjSum5.t_Client = party.t_PartyID" +
                       "       AND nptxobjSum5.t_Date BETWEEN ? " +
                       "                                  AND ? " +
                       "       AND (   EXISTS" +
                       "                  (SELECT ordlnk.*" +
                       "                     FROM dvsordlnk_dbt ordlnk" +
                       "                    WHERE     ORDLNK.T_CONTRACTID = nptxobjSum5.T_ANALITIC1" +
                       "                          AND ORDLNK.T_LINKKIND = 1)" +
                       "            OR (    nptxobjSum5.T_ANALITIC1 = -1" +
                       "                AND EXISTS" +
                       "                       (SELECT *" +
                       "                          FROM dnptxobdc_dbt obdc, DNPTXOP_DBT op" +
                       "                         WHERE     obdc.t_ObjID = nptxobjSum5.t_ObjID" +
                       "                               AND op.t_ID = obdc.t_DocID" +
                       "                               AND (   op.t_Kind_Operation = 2035" +       // расчет ноб
                       "                                    OR op.t_Kind_Operation = 2038))))" +   // удержание ндфл
                       "   ) as t_Sum5 " +
                       "from dparty_dbt party " +
                       "where party.t_PartyID = ?";

        var SumSelect = DL_RSDCommand(SumQuery);
        SumSelect.AddParam(BegDate);
        SumSelect.AddParam(EndDate);
        SumSelect.AddParam(BegDate);
        SumSelect.AddParam(EndDate);
        SumSelect.AddParam(BegDate);
        SumSelect.AddParam(EndDate);
        SumSelect.AddParam(pt_cntr.rec.PartyID);

        var SumDS = SumSelect.Execute();
        if(SumDS.MoveNext())
           Sum1 = SumDS.Sum1;
           Sum4 = SumDS.Sum4;
           Sum5 = SumDS.Sum5;
        end;

        Sum3 = Sum1 + Sum2;

        Sum6 = (Rg * min(Sum3, Max15)) - Sum4;
        Sum7 = (Rp * max(Sum3 - Max15, 0)) - Sum5;

        if ((not refund) AND (Sum6 < 0))
          Sum6 = 0;
        end;
        if ((not refund) AND (Sum7 < 0))
          Sum7 = 0;
        end;

          if ((Sum6 < 0) and (Sum7 > 0))
            Sum6 = Sum6 + min (abs(Sum6), abs(Sum7));
            Sum7 = Sum7 - min (abs(Sum6), abs(Sum7));
          elif ((Sum7 < 0) and (Sum6 > 0))
            Sum6 = Sum6 - min (abs(Sum6), abs(Sum7));
            Sum7 = Sum7 + min (abs(Sum6), abs(Sum7));
          end;

          if (Sum6 < 0)
            S.IsReverse = true;
          end;

          if (Sum7 < 0)
            S.IsReverse15 = true;
          end;

        S.Tax13_NatCur = S.Tax13_NatCur + Round(Sum6,0);
        S.Tax15_NatCur = S.Tax15_NatCur + Round(Sum7,0);
        S.Tax13_Raw = Sum6;
        S.Tax15_Raw = Sum7;
        S.Tax_Raw = S.Tax13_Raw + S.Tax15_Raw;
        if (S.Cur != NATCUR)
          S.Tax13 = S.Tax13 + Round(VS_Convert(Sum6, lnk.rec.InterestChargeDate, NATCUR, S.Cur),2);
          S.Tax15 = S.Tax15 + Round(VS_Convert(Sum7, lnk.rec.InterestChargeDate, NATCUR, S.Cur),2);
        else
          S.Tax13 = S.Tax13_NatCur;
          S.Tax15 = S.Tax15_NatCur;
        end;
        S.Tax = S.Tax13 + S.Tax15;
  elif (lnk.rec.TaxBaseAmount > 0.0)
    /* Округляем налог до рублей:
       Согласно Налоговому кодексу, ст. 225. Порядок исчисления налога.
       п.4. Сумма налога  определяется в полных рублях.
       Сумма налога менее 50 копеек отбрасывается, а 50 копеек и более округляется до полного рубля.
    */


    S.Tax13_Raw = double((VS_Convert(lnk.rec.TaxBaseAmount, lnk.rec.InterestChargeDate, lnk.rec.BCCFI, NATCUR) * R) / 100);
    S.Tax13_NatCur = MoneyL(Round(S.Tax13_Raw, 0));
    S.Tax13 = S.Tax13 + Round(VS_Convert(S.Tax13_NatCur, lnk.rec.InterestChargeDate, NATCUR, S.Cur), 2);
    S.Tax = S.Tax13;
    S.Tax_Raw = S.Tax13_Raw;
  end;
   
     return 0;
   END;   
   

PRIVATE MACRO ОснованиеОкругление(Тип, pt_cntr, bnr, leg, Сумма, Дата, ВидДок, НомерДок, Валюта)
  var s = Тип + " от округления по погашению ";

  if (leg.rec.Formula == VS_IN_DISC_PC)
    s = String(s, "процентно-дисконтного векселя ");
  elif (ВексельДисконтный(leg))
    s = String(s, "дисконтного векселя ");
  elif (ВексельПроцентный(leg))
    s = String(s, "процентного векселя ");
  end;

  s = String(s, bnr.rec.IssuerName, " сер. ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber),
             ", предъявитель векселя ", pt_cntr.rec.Name);

  s = String(s, " Исходный документ ", ВидДок, " N '", НомерДок, "' от ", Дата,
             ", валюта ", Валюта, ", сумма ", string(round(Сумма, 2)), " ", Валюта, ".");

  return s;
END;



PRIVATE MACRO ОснПлатежаПоНалогу(Конверсия, pt_cntr, bnr, leg, Повышенный)
var s="";

   if ( FilterMakeNDRObj(pt_cntr) )
      if (not Конверсия)
       s = "Подоходный налог с ";
       if(Повышенный)
         s = "Налог 15% с ";
       end;
      else
       s = "Конверсия суммы подоходного налога с ";
       if(Повышенный)
         s = "Конверсия суммы налога 15% с ";
       end;
      end;
   else
      if (not Конверсия)
       s = "Налог с ";
      else
       s = "Конверсия суммы налога с ";
      end;
   end;

   if  ( leg.rec.Formula == VS_IN_DISC_PC ) s = String(s, "процентно-дисконтного векселя");
   elif( ВексельДисконтный(leg) )   s = String(s, "дисконтного векселя");
   elif( ВексельПроцентный(leg) )   s = String(s, "процентного векселя");
   end;

   s = String(s, " сер. ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber),
              " , предъявитель векселя ", vs_order.ContractorName);

   return s;
END;
/*  Проценты и дисконт отбросили раньше.
           Теперь вычитаем разницу из номиналов.
   */
   PRIVATE MACRO СписаниеРазнСНоминалов(S, Дата)
   var
       cur = fd.GetParametr(MC_TYPE_PARAMETR_CURRENCY),
       ВалУч = fd.ОпределитьВалютуУчета(),
       СчетДоходМв = "", СчетРасходМв = "",
       СчетДебет = "", СчетКредит = "", Кат_номинала,
       stat = 0;

       //Simanov. Если не перенесён "К исполнению", никакой разницы номиналов быть не может
       if (not isExecution)
         return (stat == 0);
       end;
       fd.SetParmForCateg24828("+Эмиссия, СВ", "01");
       if(S <= 0)
          ; // не наш случай
          return true;
       elif (not ПолучитьСчетУчетаНоминала(bnr, fd, Дата, @СчетДебет))
          return false;
       elif (not ПолучитьСчетВекселя("+Эмиссия, СВ", fd, СчетКредит, MC_OPENACC_CREATE, NATCUR, NULL, Дата, null, null, null, true))
          stat = 1;
       elif((cur != NATCUR) and
            (not ПолучитьСчетВекселя("+БМаржаП,ср-ва в ин.вал.", fd, СчетДоходМв, MC_OPENACC_CREATE, NULL, NULL, Дата)))
          stat = 1;
       elif((cur != NATCUR) and
            (not ПолучитьСчетВекселя("-БМаржаП,ср-ва в ин.вал.", fd, СчетРасходМв, MC_OPENACC_CREATE, NULL, NULL, Дата)))
          stat = 1;
       elif( Проводка(  СчетДебет, СчетКредит, VS_Convert(S, Дата, cur, ВалУч),
                        String("Списание разницы с номиналов"),
                        0,                             /* Платеж                 */
                        0,
                        ВалУч,                         /* Валюта проводки        */
                        null, null, Дата, null,
                        2,                             /* режим */
                        СчетДоходМв,                   /* СчетДоходов */
                        СчетРасходМв                   /* СчетРасходов */
                     ) != 0)
            stat = 1;
       end;

       fd.ResetParmForCateg24828();

       return (stat == 0);
   END;

/*  Оформить Доход От Выкупа Векселя.
       Доход оформляется от погашения векселя ниже стоимости.
       Ничего не делаем, если дохода нет, или он был уже оформлен при переносе к исполнению.
   */
   PRIVATE MACRO ОформитьДоходОтВыкупаВекселя(Дата)
   var
      S = 0, stat = 0,
      Sразм = 0;

      if(not isExecution)
         if(isDiscount)
           Sразм = ПолучитьСуммуРазмещения(fd.GetLeg());
           /*if(Номинал > (ОстДиск + Сп))
             S = Номинал - (ОстДиск + Сп);
           end;*/
           if(Sразм > Сп)
              S = Sразм - Сп;
           end;
         else
           if(Номинал > Сп)
             S = Номинал - Сп;
           end;
         end;
         if(S > 0)
           if(not СписаниеРазнСНоминалов(S, Дата))
             stat = 1;
           end;
         end;
      end;

      return (stat == 0);
   END;

/* Формирует проводку по переводу %% по векселю
      на транзитный счет
   */
   PRIVATE MACRO ПроводкаПереводПроцПоВекселю(S, СчетКредит, ДатаПроводки, Режим)
   var
      СчетДебет = "", GroundText = "",
      cur = fd.ОпределитьВалютуУчета(),
      stat = 0;

      if((isPc) AND (S > 0))

         GroundText = String("%% по векселю сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber),
                             ", за период с ", date_as_string(1, StartPcDate, false),
                             " по ", date_as_string(1, AddPcDate, false),
                             ", ", leg.rec.Price/pow(10, leg.rec.Point),
                             " % годовых за ", AddPcDate - StartPcDate + 1, " дней "
                      );

         if (GrdBldr and GrdBldr.isHaveGB("ПроводкаПереводПроцПоВекселю"))
           GroundText = GrdBldr.BuildGround("ПроводкаПереводПроцПоВекселю",
                                              bnr.rec.BCSeries, trim(bnr.rec.BCNumber),
                                              date_as_string(1, StartPcDate, false), date_as_string(1, AddPcDate, false),
                                              leg.rec.Price/pow(10, leg.rec.Point),
                                              AddPcDate - StartPcDate + 1,
                                              bnr.rec.HolderName);
         end;
        
        СчетКредит = IIF(toSeparateExecute == false, СчетКредит, РаздСчетУчетаПроцентов);
        if( (СчетКредит == "") and (vs_order != NULL) )
            VS_GetAccountOnOrder(vs_order, "-Расчеты", VSORDLNK_K_DRAW, ДатаПроводки, @СчетКредит, true);
        end;

         if(not ПолучитьСчетУчетаПроцентов(bnr, fd, ДатаПроводки, @СчетДебет, ОперацВыкупа))
            stat = 1;
         elif(Проводка(СчетДебет, СчетКредит, S, GroundText, 0, 0, cur, null, null, ДатаПроводки, NULL, Режим) != 0)
             stat = 1;
         end;
      end;

      return (stat == 0);
   END;

   PRIVATE MACRO ПроводкаПереводДискПоВекселю(СчетКредит, ДатаПроводки, Режим, Дкорр)
   var
      СчетДебет = "", GroundText = "",
      cur = fd.ОпределитьВалютуУчета(),
      stat = 0, ОстатокДиск;


      if((isDiscount))
         
         GroundText = String("Дисконт по векселю сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber)
                      );
        if( not ПолучитьСчетВекселя( "Дисконт, Свексель", fd, СчетДебет, MC_OPENACC_CREATE, null, null, ДатаПроводки, FIROLE_DISCOUNT ) )
          stat = 1;
        elif(not ПолучитьОстаток(ОстатокДиск, СчетДебет, fd.ОпределитьВалютуУчета(), ДатаПроводки))
          stat = 1;
        elif((ОстатокДиск + Дкорр) > $0)
          СчетКредит = IIF(toSeparateExecute == false, СчетКредит, РаздСчетУчетаДисконта); //Если включена разделяемая сумма делаем проводку на счет раздельной КУ
          if (Проводка(СчетДебет, СчетКредит, (ОстатокДиск + Дкорр), GroundText, 0, 0, cur, null, null, ДатаПроводки, NULL, Режим) != 0)
            stat = 1;
          end;
        end;
      end;

      return (stat == 0);
   END;

   /* Проводка списание излишне начисленных %%
   */
   PRIVATE MACRO ПроводкаСписаниеИзлишков(S, ДатаПроводки)
   var
      СчетДебет = "", СчетКредит = "", GroundText,
      stat = 0;

      GroundText = String("Списание излишне начисленных процентов по векселю",
                          " сер. ", bnr.rec.BCSeries,
                          " № ", trim(bnr.rec.BCNumber),
                          ", выданного ", bnr.rec.HolderName
                   );

      if(S <= 0)
        /* нет проводки */;
      elif(not ПолучитьСчетУчетаПроцентов(bnr, fd, ДатаПроводки, @СчетДебет))
         stat = 1;
      elif(not ПолучитьСчетВекселя("Дисконт, Свексель", fd, СчетКредит, MC_OPENACC_CREATE, NULL, NULL, ДатаПроводки, FIROLE_DISCOUNT))
         stat = 1;
      elif(Проводка( СчетДебет, СчетКредит, S, GroundText, 0, 0,
                     fd.GetParametr(MC_TYPE_PARAMETR_CURRENCY),
                     null, null, ДатаПроводки
                   ) != 0)
          stat = 1;
      end;

      return (stat == 0);
   END;

   /* Выполняет проводку: списание излишне начисленного дисконта
   */
   PRIVATE MACRO ПроводкаСписИзлДисконта(S, ДатаПроводки)
   var
      СчетДебет = "", СчетКредит = "", GroundText,
      cur = fd.GetParametr(MC_TYPE_PARAMETR_CURRENCY),
      stat = 0;

      GroundText = String("Списание излишне начисленного дисконта по векселю",
                          " сер. ", bnr.rec.BCSeries,
                          " N ", trim(bnr.rec.BCNumber),
                          ", выданного ", bnr.rec.HolderName
                   );

      if(S <= 0)
        ;// ничего не делаем
      elif(not ПолучитьСчетУчетаНоминала(bnr, fd, ДатаПроводки, @СчетДебет))
         stat = 1;
      elif(not ПолучитьСчетВекселя("Дисконт, Свексель", fd, СчетКредит, MC_OPENACC_CREATE, NULL, NULL, ДатаПроводки, FIROLE_DISCOUNT))
         stat = 1;
      elif(Проводка(СчетДебет, СчетКредит, S, GroundText, 0, 0, cur, null, null, ДатаПроводки) != 0)
         stat = 1;
      end;
      return (stat == 0);
   END;

   /*  Списывает излишне начисленный дисконт.
   */
   PRIVATE MACRO СписатьИзлишнеНачисленныйДисконт(Дата)
   var
      S, stat = 0;

      СуммаСписДк = MoneyL(0);
      if(isExecution)
        ;// не наш случай
      elif(Сп >= Номинал)
        ;// не наш случай
      elif(not isDiscount)
        ;// вексель недисконтный
      elif(leg.rec.Principal <= ПолучитьСуммуРазмещения(leg) /*leg.rec.ReceiptAmount*/)
        ;// дисконта нет
      else
        S = Номинал - Сп;
        if(not ПроводкаСписИзлДисконта(S, Дата))
          stat = 1;
        else
          СуммаСписДк = S;
        end;
      end;

      return (stat == 0);
   END;

/*  Перевод процентов по векселю на транзитный счет.
    Счет учета %% и суммы определены ранее.
*/
PRIVATE MACRO ПодготовитьПроцентыПоВекселю(Дата)
var
   СуммаПроводки,
   СуммаДопПроводки = 0,
   stat = 0,
   СчетУчетаПроцентов = "",
   СчетДебет,
   СчетКредит,
   ДатаПроводки = Дата,
   rsd, sql, curr_year,
   prccontract = TRecHandler( "prccontract" );

   var bnr = fd.GetBnr();
   var leg = fd.GetLeg();
   var ДНН = ZeroDate;
   var ДПН = ZeroDate;

   var Кп  = Huge_Value; /* коэффициент пересчета, берем максимально большим для случая отсутвия начислений в п.г., тогда значение Кп/(1+Кп) должгл быть близко к 1 */
   var Рр = 0.0, Рр1 = 0.0;

   var Pрасч = 0.0;              // сумма процентов, фактически выплачиваемая при погашении
   var Рнач  = 0.0;              // сумма начисленных (т.е. отраженных по счету Обяз%Свекс процентов), на дату по-следнего начисления

   var Pрасч_пг = 0.0;//- сумма процентов Pрасч., относящаяся к прошлому году:
   var Ррасч_тг = 0.0;//- сумма процентов Pрасч., относящаяся к текущему году:
   var Pнач_пг  = 0.0;//- сумма процентов Pрасч., относящаяся к прошлому году:
   var Рнач_тг  = 0.0;//- сумма процентов Pрасч., относящаяся к текущему году:

   var Sразм    = ПолучитьСуммуРазмещения( leg ); // цена размещения
   var Др       = ПолучитьСуммуДисконтаНаДату( Дата, bnr, leg );
   var Sпогфакт = Сп;
   var ВалУч    = fd.ОпределитьВалютуУчета();

   СперПр = MoneyL(0);
   СдопПр = MoneyL(0);

   if( ( not isPc ) )
     /* вексель непроцентный, ничего не делаем */
     return true;
   end;

   if( not ПолучитьСчетУчетаПроцентов( bnr, fd, Дата, @СчетУчетаПроцентов, ОперацВыкупа ) )
     return false;
   elif( not ПолучитьОстаток( Рнач, СчетУчетаПроцентов, ВалУч, Дата ) )
     return false;
   end;

   Рнач = VS_Convert( Рнач, ПолучитьДатуПоследОперацииПоВекселю( fd.GetBnr().rec, fd.GetLeg().rec, Дата ), ВалУч, fd.GetParametr( MC_TYPE_PARAMETR_CURRENCY ) );

   DateSplit( Дата, null, null, curr_year );

   if( not НайтиСчетПроцВекселя( prccontract, fd.GetBnr().rec.BCID ) )
     msgbox( "Не найден счет процентов векселя ", НашБанк(),
             " сер. ", bnr.rec.BCSeries,
             " N ", trim(bnr.rec.BCNumber),
             ", выданного ",bnr.rec.HolderName );
     return false;
   end;

   /* считаем начисленные проценты за прошлые годы */
   СуммаНачисленныхПроцентовПоПДВекселя( prccontract.rec.ContractID, prccontract.rec.BeginDate, date( 31, 12, curr_year - 1 ), Pнач_пг );

   if (vs_order.DocKind != DL_VEKSELDRAWORDER)/*PNV DEF-25427 для погашения не считаем что было в прошлом году*/
      Рнач_тг = Рнач - Pнач_пг;
  else
     Рнач_тг = Рнач;
   end;

   /* расчитаем сумму %% такую, если бы не было погашения */
   if( not VS_PercentCalc( prccontract.rec.ContractID, VS_GetRightPcDate(prccontract, Дата), prccontract.rec.BeginDate, Рр, VS_CurrIDOperation, VS_CurrIDStep ) )
     msgbox( "Ошибка при расчете процентов к начислению векселя ", НашБанк(),
             " сер. ", bnr.rec.BCSeries,
             " N ", trim( bnr.rec.BCNumber ),
             ", выданного ", bnr.rec.HolderName );
   end;
   СуммаНачисленныхПроцентовПоПДВекселя( prccontract.rec.ContractID, prccontract.rec.BeginDate, Дата, Рр1 );
   Рр = Рр + Рр1;

   if( Pнач_пг != 0.0 )
     Кп = ( Рр - Pнач_пг ) / Pнач_пг;
   end;

   if( ( ВексельПроцентный( leg ) ) and ( not ВексельДисконтный( leg ) ) )
     if( Sразм >= Сп )
      Pрасч = 0;
     else
      Pрасч = Сп - Номинал;
     end;
   elif( ( ВексельПроцентный( leg ) ) and ( ВексельДисконтный( leg ) ) )
     if( ( ( Sразм + Др ) <= Sпогфакт ) )
       Pрасч = Sпогфакт - Sразм - Др;
     end;
   end;
   
   if (vs_order.DocKind == DL_VEKSELDRAWORDER)/*PNV DEF-25427 для погашения не считаем что было в прошлом году*/
       Ррасч_тг = Pрасч;
   else
      if( Кп != Huge_Value )
         Ррасч_тг = round( ( Pрасч * Кп / ( 1.0 + Кп ) ), 2 );
      else
        /* лучше делать так, чем считать всегда по приведенной выше формуле. Т.к. в разрядах, начиная с 1/Huge_Value получим различия в Ррасч_тг и Pрасч */
         Ррасч_тг = Pрасч;
      end;
   end;

   //Simanov. В выкупе доначисляем весь насчитанный дисконт на текущую дату, и лишний списываем на доходы
   //Как это отработает в погашении - хз
   //Ррасч_тг = Рр;
   Pрасч_пг = round( ( Pрасч - Ррасч_тг ), 2 );
   Pнач_пг = round(Pнач_пг, 2); //Simanov. 

   //1.Доначисление процен-тов

   if( Ррасч_тг > Рнач_тг )
     if( not ПолучитьСчетВекселя( "%Расход, СВ", fd, СчетДебет, MC_OPENACC_CREATE, null, null, Дата ) )
        return false;
     end;
     if( not ДатаПоследнейОперНачисленияПДД( bnr.rec.BCID, Дата, @ДНН ) )
       return false;
     else
       ДПН = Дата;
       ДНН = IIF(((ValType(ДНН) == V_UNDEF) OR (ДНН == ZeroDate)), prccontract.rec.BeginDate, ДНН + 1);
       //т.к. доначисляем за текущий год, то
       if( ДНН < date( 1, 1, curr_year ) )
         ДНН = date( 1, 1, curr_year );
       end;
       if(ДНН > ДПН)
        ДНН = ДПН;
       end;
     end;

     СуммаПроводки = VS_Convert( ( Ррасч_тг - Рнач_тг ), Дата, leg.rec.PFI, ВалУч );
     if( СуммаПроводки != 0.0 )
       if ( Проводка( СчетДебет, СчетУчетаПроцентов, round(СуммаПроводки, 2), //Simanov
             String( "Доначисление процентов по векселю ", НашБанк(),
                     " сер. ", bnr.rec.BCSeries,
                     " N ", trim(bnr.rec.BCNumber),
                     ", выданного ",bnr.rec.HolderName,
                     ", за период ", ДНН, ":", ДПН),
                     null, null,
                     ВалУч, null, null,
                     Дата, null,
                     1 /*дебет в нац.вал.*/ ) )
           return false;
       end;
     end;
   end;

   if( Pрасч_пг < Pнач_пг )
     СуммаПроводки = VS_Convert( ( Pнач_пг - Pрасч_пг ), Дата, leg.rec.PFI, ВалУч );

     if( СуммаПроводки != 0.0 )
       fd.SetParmForCateg24828("+Эмиссия, СВ", "01");
       if( not ПолучитьСчетВекселя( "+Эмиссия, СВ", fd, СчетКредит, MC_OPENACC_CREATE, null, null, ДатаПроводки, null, null, null, true ) )
         return false;
       end;

       if (vs_order.DocKind != DL_VEKSELDRAWORDER)/*PNV DEF-25427 для погашения убираем эту проводку*/
           if( Проводка( СчетУчетаПроцентов, СчетКредит, СуммаПроводки,
                     String( "Списание излишне начисленных процентов по векселю"
                             " сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber),
                             ", выданного ", bnr.rec.HolderName,
                             ", относящихся к прошлому году" ),
                     0,                             /* Платеж */
                     0,
                     ВалУч,  /* Валюта проводки */
                     null, null,
                     Дата, null,                 /* Дата проводки */
                     2 /*дебет в ВУ*/ ) != 0 )
            return false;
          end;
       end;

       fd.ResetParmForCateg24828();
     end;
  end;

   if( Ррасч_тг < Рнач_тг )
     СуммаПроводки = VS_Convert( ( Рнач_тг - Ррасч_тг ), Дата, leg.rec.PFI, ВалУч );

     if( СуммаПроводки != 0.0 )
       fd.SetParmForCateg24828("+Эмиссия, СВ", "01");
       if( not ПолучитьСчетВекселя( "+Эмиссия, СВ", fd, СчетКредит, MC_OPENACC_CREATE, null, null, ДатаПроводки, null, null, null, true ) )
         return false;
       end;

       if( Проводка( СчетУчетаПроцентов, СчетКредит, СуммаПроводки,
                     String( "Списание излишне начисленных процентов по векселю"
                             " сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber),
                             ", выданного ", bnr.rec.HolderName,
                             ", относящихся к текущему году" ),
                     0,                             /* Платеж */
                     0,
                     ВалУч,  /* Валюта проводки */
                     null, null,
                     Дата, null,                   /* Дата проводки */
                     2 /*дебет в ВУ*/ ) != 0)
         return false;
       end;
       fd.ResetParmForCateg24828();
     end;
   end;

   return ( stat == 0 );
END;

PRIVATE MACRO СРаздельныхСчетовУчета(ДатаОплаты, СчетЗачисления)
var
  separatePercSum = $0.0, //Сумма процентов на раздельных счетах учета
  separateDiscSum = $0.0, //Сумма номинала на раздельных счетах учета или же общая сумма погашения на счете категории "СВексель к исполнению"
  separateDiscAcc = "",
  separatePercAcc = "",
  ВалУчета,
  sumSeparate = false,
  Purpose="";

  Purpose = String(" сер. ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber), ", выданный ", bnr.rec.HolderName,  ", на транзитный счет");

  ВалУчета = fd.ОпределитьВалютуУчета();

  if ( not VS_GetRegistryValue("ВЕКСЕЛЯ БАНКА\\РЕЖИМ РАБОТЫ\\ПЕРЕНОС \"К ИСП.\" РАЗБИВКА СУММ", V_BOOL, @sumSeparate) )
   sumSeparate = false;
  end;  

  if ( sumSeparate == false) 
    return 0; 
  end;

  ПолучитьСчетВекселя("Дисконт, СВексель к исп.", fd, separateDiscAcc, MC_OPENACC_CREATE, ВалУчета, null, ДатаОплаты);
  ПолучитьСчетВекселя("Обяз%, СВексель к исп.",   fd, separatePercAcc, MC_OPENACC_CREATE, ВалУчета, null, ДатаОплаты);

  if (separatePercAcc != "")
    ПолучитьОстаток(separatePercSum, separatePercAcc,  ВалУчета, ДатаОплаты);
  end;

  if (separateDiscAcc != "")
    ПолучитьОстаток(separateDiscSum, separateDiscAcc,  ВалУчета, ДатаОплаты);
  end;

  if ( separatePercSum > 0 )
    Проводка(separatePercAcc, СчетЗачисления, separatePercSum,
                                  String("Перенос процентов по векселю векселя", Purpose),
                                  null, null,
                                  ВалУчета, null, null,
                                  ДатаОплаты, null,
                                  2 /*дебет в ВУ*/
                         );
  end;

  if ( separateDiscSum > 0 )
    Проводка(separateDiscAcc, СчетЗачисления, separateDiscSum,
                                  String("Перенос дисконта по векселю векселя", Purpose),
                                  null, null,
                                  ВалУчета, null, null,
                                  ДатаОплаты, null,
                                  2 /*дебет в ВУ*/
                         );
  end;


END;

PRIVATE MACRO IsPerformed(ord, symb)
var DataSet,
    cmdtxt = "SELECT ooper.t_DocumentID "
                "FROM doprstep_dbt ostep, doproper_dbt ooper "
                "WHERE ooper.t_DocKind = " + ord.DocKind +
                     " AND ooper.t_DocumentID = " + ord.ContractID +
                     " AND ooper.t_ID_Operation = ostep.t_ID_Operation " +
                     " AND ostep.t_IsExecute LIKE 'X' AND ostep.t_Symbol LIKE '" + symb + "' ";
   DataSet = TRsbDataSet(cmdtxt);
   return DataSet.MoveNext();
END;

PRIVATE MACRO ПроводкаОкругления(СуммаОкругления, pt_cntr, bnr, leg, ДатаПогашения, S_Cur, НомерДокумента)
  if (abs(СуммаОкругления) >= 0.5)
    var Тип = IIF(СуммаОкругления > 0, "Доход", "Расход");
    var СчетДтОкругл = IIF(СуммаОкругления > 0, "52406", "70606");
    var СчетКтОкругл = IIF(СуммаОкругления > 0, "70601", "52406");
    var ОснОкругл = ОснованиеОкругление(Тип, pt_cntr, bnr, leg, СуммаОкругления, ДатаПогашения, "Мем.ор.", НомерДокумента, S_Cur);
    Проводка(СчетДтОкругл, СчетКтОкругл, abs(СуммаОкругления), ОснОкругл, null, null, S_Cur, null, null, ДатаПогашения, null, null, null, null, null, null, ОтключениеПереоценки);
  end;
END;

/*
     Списываются излишки начисленных сумм по векселю.
     Если указан счет зачисления(acc), то выполняется перевод суммы к оплате
     с вексельных счетов на указанный счет
*/
 MACRO ПодготовитьВексельКОплате(ДатаОплаты) 
 var
   SumPr               = MoneyL(0),        /* сумма проводки */
   SPc                 = MoneyL(0),        /* сумма %% к оплате */
   ErrStr, Purpose     = "",
   СчетДебет, ОтсрРазн = MoneyL(0),
   AdjEIR, AccAdjEIR, AdjEIRNatCur,
   stat                = 0;
   Сп                  = lnk.rec.BCCost;
   Спер                = MoneyL(0);
   var leg             = fd.GetLeg(), bnr = fd.GetBnr();
   var isDisc          = ВексельДисконтный(leg);
   var isPrc           = ВексельПроцентный(leg);
   var Sразм           = ПолучитьСуммуРазмещения(fd.GetLeg()); // цена размещения
   var Др              = 0.0;
   var Ррасч           = 0;
   var Sпогфакт        = Сп;
   var Дфакт           = 0;  // дисконт, фактически выплачиваемый при погашении
   var Дкорр           = 0;  // дисконт, корректировка суммы
   var ВалУч           = fd.ОпределитьВалютуУчета();
   var СуммаНалога     = 0;
   var СуммаКорр, СуммаКоррВУ;
   var ДопКорр;
   var ДогПД = VSOrderFD(vs_order);
   var ВалНалогаНДР = ДогПД.GetParametr(MC_TYPE_PARAMETR_PAYCURRENCY);
   var СуммаНалога15 = 0;
   var ТекСуммаНалога = 0;

   if( isDisc )
     Др = ПолучитьСуммуДисконтаНаДату( ДатаОплаты, bnr, leg );
   end;

   if(ValType(СчетЗачисления) != V_STRING)
      СчетЗачисления = "";
   end;

   /* Если дата, на которую расчитана стоимость векселя >= даты погашения "не ранее",
      то - имеем погашение в срок, значит - по векселю должно быть выплачено все, что начислено
   */
   if(lnk.rec.InterestChargeDate >= leg.rec.Maturity)
     if(isPc)
        Spc = Скн + ОсткБСчПр;
     end;
   end;

   /* доначислить дисконт
   */
   if( not isExecution )
     if( not ОбработатьДисконтПриПогашении(fd, Сп, ДатаОплаты, Др, Дкорр) )
       return false;
     end;
   end;

   /* Готовим проценты по векселю
   */
   if( not isExecution )
     if(not ПодготовитьПроцентыПоВекселю(ДатаОплаты))
        return false;
     end;
   end;

   if( (isPrc) and (not isDisc))
     Ррасч = Sпогфакт - leg.rec.Principal;
   elif( (isPrc) and (isDisc) )
     if( (Sразм+Др) <= Sпогфакт)
       Ррасч = Sпогфакт - Sразм - Др;
     end;
   end;

   //не забываем расчитывать налог
   if ( (FilterMakeNDRObj(pt_cntr))  and ( (NeedToTax !=NULL) and (NeedToTax == true ) or (NeedToTax == NULL) ) )
     GetTax(bnr, leg, null, null, null, lnk, @_RepAmountAndTax, 1);
         СуммаНалога   = _RepAmountAndTax.Tax13;
     СуммаНалога15   = _RepAmountAndTax.Tax15;
     ТекСуммаНалога = _RepAmountAndTax.Tax;
   end;
   
   
   if( (not isExecution) and (Ррасч != 0.0) )
     if(not ПроводкаПереводПроцПоВекселю(VS_Convert(Ррасч, ДатаОплаты, leg.rec.PFI, ВалУч), СчетЗачисления, ДатаОплаты, Режим))
       return false;
     end;
   end;

   /* Переносим номинал векселя.
      Если вексель был перенесен на счет "к исполнению", значит вся необходимая сумма
      лежит на одном счете,
      а если не был перенесен "к исполнению", то берем для проводки необходимую часть номинала
   */
   if( (isDisc and (not isPrc)) or
       (isDisc and (isPrc) and ((Sразм+Др) > Sпогфакт) ) )
     if( Sпогфакт <= Sразм )
       Дфакт = 0;
     else
       Дфакт = Sпогфакт - Sразм;
     end;
   end;

   if( (Дфакт == 0.0) and isDisc and isPrc )
     if( (Sразм+Др) <= Sпогфакт)
       Дфакт = Др;
     end;
   end;

   if( isExecution )
     SumPr = Sразм - ТекСуммаНалога;
     if ( not VS_IsSumSeparation() )
       SumPr = Sпогфакт;
     end;  
   else
     SumPr = min(Sразм, leg.rec.Principal);
     //Simanov. При переносе на счёт "К исполнению" переносится вся сумма номинала в любом случае. SumPr = min(SumPr, Сп);
   end;

   if ((not isExecution) and isDisc and ((Др > $0) or (Дкорр > $0)))
     if(not ПроводкаПереводДискПоВекселю(СчетЗачисления, ДатаОплаты, Режим, Дкорр))
       return false;
     end;
   end;

   ОтсрРазн = ПолучитьНеОтнесеннуюОтсроченнуюРазницу(bnr.rec.BCID, ДатаОплаты);

   if ((not isExecution) and (ОтсрРазн != $0))
     if (ОтнесениеОтсрРазницы(ОтсрРазн, fd, ДатаОплаты) != 0)
       return false;
     end;
   end;

   if ((not IsPerformed(vs_order, "И")) and ((vs_order.DocKind == DL_VSBARTERORDER) or (vs_order.DocKind == DL_VEKSELDRAWORDER)))
     if (not СВ_РасчитатьКорректировкуИСделатьПроводки(fd, ДатаОплаты, ВалУч, ДопКорр, NULL, isExecution))
       return false;
     end;
     if (СписаниеКорректировкиПоОстатку(fd, ДатаОплаты, ДопКорр, isExecution) == 0)
        if (СВ_ПолучитьТекущуюКорректировкуПДДпоЭПС(bnr.rec.BCID, ДатаОплаты, AdjEIR, AccAdjEIR))
          AdjEIR = (AdjEIR + VS_Convert( ДопКорр, ДатаОплаты, NATCUR, leg.rec.PFI )) * (-1);
          AccAdjEIR = (AccAdjEIR + VS_Convert( ДопКорр, ДатаОплаты, NATCUR, ВалУч )) * (-1);
          if(not VS_SaveIncomeSum(VSINCOMETYPE_EPRPERC, bnr.rec.BCID, VS_GetLastPayedEnrolmentID(bnr.rec.BCID), ДатаОплаты, AdjEIR, leg.rec.PFI, AccAdjEIR, ВалУч))
          return false;
          end;
        end;
     else
       return false;
     end;
   end;

   if(not ПолучитьСчетУчетаНоминала(bnr, fd, ДатаОплаты, @СчетДебет))
     return false;
   end;
   if( SumPr )
     if(СчетЗачисления == "")
       // проводку не делаем, счет зачисления не указан
     else
       var СчетКред = СчетЗачисления; 
       if((SubStr(СчетДебет, 1, 3) == "523") AND (SubStr(СчетЗачисления, 1, 5) == "52406")) // перенос на счет к исполнению
          СчетКред = IIF(toSeparateExecute == false, СчетЗачисления, РаздСчетУчетаНоминала); //если впихнули флаг, что делаем перенос к исполнению с разделением суммы, то используем счет по раздельной КУ
          //Simanov
         if(isDisc)  /*CHVA 524936*/
          Purpose = String("Перенос балансовой стоимости векселя сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber),
                             ", выданный ", bnr.rec.HolderName,
                             ", на счет \"к исполнению\""); /*CHVA старое \"векселя с истекшим сроком обращения\"*/
         else
          Purpose = String("Перевод номинала векселя сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber),
                             ", выданный ", bnr.rec.HolderName,
                             ", на счет \"к исполнению\""); /*CHVA старое \"векселя с истекшим сроком обращения\"*/
         end;
       else
          Purpose = String("Погашение векселя",
                             " сер. ", bnr.rec.BCSeries,
                             " № ", trim(bnr.rec.BCNumber));

          СРаздельныхСчетовУчета(ДатаОплаты, СчетЗачисления);

       end;
       
       if( Проводка(  СчетДебет, СчетКред /*СчетЗачисления*/, VS_Convert(SumPr, ДатаОплаты, leg.rec.PFI, ВалУч),
                      Purpose,
                      0, 0,
                      ВалУч,
                      NULL, NULL, ДатаОплаты, NULL, Режим, null, null, null, null, ОтключениеПереоценки) != 0)
          /* Ошибка при выполнении прововдки */
          return false;
       end;
     end;
     Спер = Спер + SumPr;
   end;
  if ( (FilterMakeNDRObj(pt_cntr)) and  (СуммаНалога != 0) )
     if (СчетЗачисления == "")
       // проводку не делаем, счет зачисления не указан
     else
     var СчетПолучателя = "";
       var СчетОтправителя = "";
       if ((stat == 0))
         if(FilterMakeNDRObj(pt_cntr) == OBJ_JUR_KND )
          stat = IIF ( ПолучитьСчетВекселя("-Бюджет, ф.налоги", VSOrderFD(vs_order), СчетПолучателя, MC_OPENACC_CREATE, NATCUR, null, ДатаОплаты) , 0 , 1);
         else
          stat = IIF ( ПолучитьСчетВекселя("НДФЛ к перечислению СВ", fd, СчетПолучателя, MC_OPENACC_CREATE, NATCUR, null, ДатаОплаты) , 0 , 1);
         end;
         СчетДебет = IIF(toSeparateExecute == false, СчетДебет, РаздСчетУчетаПроцентов);
       end;
     
       //if (stat == 0)       
       //  stat = IIF ( ПолучитьСчетВекселя("СВексель к исполнению", VSOrderFD(vs_order), СчетОтправителя, MC_OPENACC_CREATE, ВалУч, null, ДатаОплаты), 0 , 1 );
       //end;
       //
       //
       //
       //
       //
       if (toSeparateExecute == false)
       /*
         if(not ПолучитьСчетУчетаПроцентов(bnr, fd, ДатаОплаты, @СчетДебет, ОперацВыкупа))
           stat = 1;
         end;
         */
       else
         СчетДебет = РаздСчетУчетаПроцентов;
       end;
       
       // Для операций мены и зачета СчетДебет = "-Расчеты". 
       // Проводка ниже нужна только для этих операций, т.к. у погашения и выкупа есть свои операции списания налогов DoTaxAndPmBkps
       if ((vs_order != NULL) and ((vs_order.DocKind == DL_VSBARTERORDER)  or (vs_order.DocKind == DL_VSINTERCHANGE)))
         СчетДебет = СчетЗачисления;

          //СчетЗачисления это счёт "-Расчеты" для текущей операции. Налоги списываются с него
            //P.S В случает если идёт разбиение исх.Платежей. Налог берётся со счета учета "СВексель с исполнению", а в случае разбиение сумм с "Обяз%, Свексель к исп."
         if (stat == 0)
           var НомерДокумента;
             stat = IIF (
                          Проводка(IIF(_RepAmountAndTax.IsReverse,СчетПолучателя, СчетДебет/*СчетЗачисления*/) , IIF(_RepAmountAndTax.IsReverse, СчетДебет/*СчетЗачисления*/, СчетПолучателя), 
                          VS_Convert(abs(СуммаНалога), ДатаОплаты, _RepAmountAndTax.Cur, ВалУч),
                                    ОснПлатежаПоНалогу(0, pt_cntr, bnr, leg, 0),
                                  null, null,
                                  ВалУч, null, null,
                                  ДатаОплаты, null,
                                  2 /*дебет в ВУ*/, null, null, null, null, ОтключениеПереоценки, @НомерДокумента),
                         1,
                         0
                         );
             var СуммаОкругления = _RepAmountAndTax.Tax - _RepAmountAndTax.Tax_Raw;
             ПроводкаОкругления(СуммаОкругления, pt_cntr, bnr, leg, ДатаОплаты, _RepAmountAndTax.Cur, НомерДокумента);  
            
         end;

       if (stat == 0)
         
         if (Налог_объект.Cur == -1)
           Налог_объект.Cur = _RepAmountAndTax.Cur;
         end;

         stat = СоздатьНДР_PaidBill(ДатаОплаты, pt_cntr, _RepAmountAndTax.Tax13_NatCur, vs_order, VS_CurrIDOperation, VS_CurrIDStep, NATCUR );
       end;
     end;
       
     end;

     var CalcDueTax = RepAmountAndTax(), AmountIncome = RepAmountAndTax();
 
     var налогВВалютеНДР = VS_Convert(ТекСуммаНалога, ДатаОплаты, _RepAmountAndTax.Cur, ВалНалогаНДР);
 
     var ndrKind = FilterMakeNDRObj(pt_cntr);
 
     if ((stat == 0) and (ndrKind == OBJ_JUR_KND))
       if (VS_GetCalcTax(vs_order, @CalcDueTax))
         stat = СоздатьНДР_DueTax(ДатаОплаты, pt_cntr, CalcDueTax.Amount, vs_order, VS_CurrIDOperation, VS_CurrIDStep, CalcDueTax.Cur );
       end;
       if (VS_GetIncome(vs_order, @AmountIncome))
         stat = СоздатьНДР_Plus_11(ДатаОплаты, pt_cntr, AmountIncome.Amount, vs_order, VS_CurrIDOperation, VS_CurrIDStep, AmountIncome.Cur );
       end;
     end;
 
     if (stat == 0)
       stat = СоздатьНДР_PaidTax(ДатаОплаты, pt_cntr, налогВВалютеНДР, vs_order, VS_CurrIDOperation, VS_CurrIDStep, ВалНалогаНДР );
     end;
   end;   
   
   if ((vs_order != NULL) and (vs_order.DocKind == DL_VSBARTERORDER))
    if ( ((FilterMakeNDRObj(pt_cntr)) == OBJ_FIZ_KND) and  (СуммаНалога15 != 0) and (pt_cntr.rec.NotResident != "X") and (ДатаОплаты >= date(1,1,2021)))
      if (СчетЗачисления == "")
       // проводку не делаем, счет зачисления не указан
      else
        var СчетПолучателя15 = "";
        var СчетЗачисления15 = СчетЗачисления;
        if ((stat == 0) )
          // DEF-57381, Получем счет по первичному документу -- векселю, иначе проводка может оказаться межфилиальной
          stat = IIF ( ПолучитьСчетВекселя("НДФЛ к перечислению 15%", fd, СчетПолучателя15, MC_OPENACC_CREATE, NATCUR, null, ДатаОплаты) , 0 , 1);
        end; 

        if ((stat == 0) )
          stat = IIF ( ПолучитьСчетВекселя("СВексель к исполнению", fd, СчетЗачисления15, NULL, NULL, NULL, ДатаОплаты) , 0 , 1);
        end; 

        if (stat == 0)
        var НомерДокумента2;
        
          stat = IIF (
                      Проводка(IIF(_RepAmountAndTax.IsReverse15, СчетПолучателя15, СчетЗачисления15), IIF(_RepAmountAndTax.IsReverse15, СчетЗачисления15, СчетПолучателя15), VS_Convert(abs(СуммаНалога15), ДатаОплаты, _RepAmountAndTax.Cur, ВалУч),
                      ОснПлатежаПоНалогу(0, pt_cntr, bnr, leg, 1),
                      null, null,
                      ВалУч, null, null,
                      ДатаОплаты, null,
                      2 /*дебет в ВУ*/, null, null, null, null, ОтключениеПереоценки, @НомерДокумента2),
                      1,
                      0
                    );
              var СуммаОкругления2 = _RepAmountAndTax.Tax15 - _RepAmountAndTax.Tax15_Raw;
              ПроводкаОкругления(СуммаОкругления2, pt_cntr, bnr, leg, ДатаОплаты, _RepAmountAndTax.Cur, НомерДокумента2);
        end;

        if (stat == 0)
          stat = СоздатьНДР_PaidGeneral_15_9(ДатаОплаты, pt_cntr, _RepAmountAndTax.Tax15_NatCur, vs_order, VS_CurrIDOperation, VS_CurrIDStep, NATCUR );
        end;

        if (stat == 0)
          stat = СоздатьНДР_PaidGeneral_15(ДатаОплаты, pt_cntr, _RepAmountAndTax.Tax15_NatCur, vs_order, VS_CurrIDOperation, VS_CurrIDStep, NATCUR  );
        end;
      end;
    end;
   end;

   if(FilterMakeNDRObj(pt_cntr))
    Налог_объект.Tax = Налог_объект.Tax + _RepAmountAndTax.Tax;
   end;
   /* Списание излишков
   */
   if(not ОформитьДоходОтВыкупаВекселя(ДатаОплаты))
      stat = 1;
   end;

   return (stat == 0);
END;

END; // CLASS RepPrm

