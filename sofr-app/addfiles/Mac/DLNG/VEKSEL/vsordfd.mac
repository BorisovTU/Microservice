/**
 @file 		vsordfd.mac
 @brief 	Класс документов "Вексельные договора"

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |28.12.2023 |Велигжанин А.В.|DEF-56486                                       |Оптимизация. Выражение GetGE() неэффективно без addFilter()
*/

IMPORT FIInter, CTInter, OprInter, DealsInter, VSInter, globals, PaymInter,
       vslib, vspmfutu;

PRIVATE VAR
        ord = TBfile("dl_order.dbt"),
        lnk = TBfile("vsordlnk.dbt"),
        bnr = TBfile("vsbanner.dbt"),
        leg = TBfile("dl_leg.dbt"),
        spgr= TBfile ("spground");

/*Класс документов "Вексельные договора"*/
CLASS VSOrderFD (DocKind_Order, DocId_bnr, p_leg)
    PRIVATE VAR
        ParmA = TArray,
        legfound = false,
        bnrfound = false,
        spgrfound = false,
        FIRoleBArray = TArray;
    VAR
        /*Основные свойства*/
        Error = 0, kind, id;

    /* Возвращает строку 's'
       после символа 'c' 
       Например: s="abcdefg.xyz",c='.'
       Результат   "xyz"
    */
    PRIVATE MACRO StrAfter( s, c )
    var
       p = Index(s, c);
       if(p == 0)
         return "";
       else
         return SubStr(s, p + 1);
       end;
    END;

    /* Возвращает строку 's'
       до символа 'c' 
       Например: s="abcdefg.xyz",c='.'
       Результат   "abcdefg"
    */
    PRIVATE MACRO StrBefore( s, c )
    var
       p = Index(s, c);
       if(p == 0)
         return s;
       else
         return SubStr(s, 1, p - 1);
       end;
    END;


    /* Формирование номера документа 'n'
       Возвращается правая часть номера, начиная со второго символа
       справа, до первого вхождения символа '/'.
       Если последний символ - не цифра, то она обрезается.
       Например: n="1/2/3в"  
       Результат:      "3"
    */
    PRIVATE MACRO MakeNumber(n)
    var s = String(n), c, l;
        
        if(s == "")
           return s;
        end;

        l = strlen(s);
        c = SubStr(s, l, 1);        /* последний символ*/
        if( (c < "0") or (c > "9") )     /* если не цифра */
          s = SubStr(s, 1, l - 1);       /* обрежем */
        end;

        while( Index(s, "/") != 0 )
          s = StrAfter(s, "/");  /* вырезаем начало строки до / */
        end;

        return s;
    END;

    /* Формирование номера для распоряжения залога.
       Возвращается левая часть (до слэша) номера договора, 
       который является основанием нашего распоряжения.
    */
    PRIVATE MACRO MakePawnNumber()
    var 
        spg = TBfile ("spground"), s = "";

        spg.KeyNum = 0;
        spg.rec.SPgroundID = ord.rec.Ground;
        if(spg.GetEQ)
           s = StrBefore(spg.rec.Xld, "/");
        end;

        return s;
    END;

    /* Проверяет валюты всех векселей договора. Если существует хотя бы один 
       вексель, с валютой отличающейся от остальных,то проверка заканчивается
       и функция возвращает -1, иначе возвращает общую валюту договора.
    */
    PRIVATE MACRO CheckCur_AllBanner( связь )
     var Ok,FIID=-1;
        lnk.KeyNum = 1;
        lnk.rec.DocKind = ord.rec.DocKind;
        lnk.rec.ContractID = ord.rec.ContractID;
        lnk.rec.LinkKind = связь;
        lnk.rec.Issuer = {OurBank};
        lnk.rec.BCID = 0;
        lnk.addFilter("t_DocKind = " + string(ord.rec.DocKind) + " and t_ContractID = " + string(ord.rec.ContractID)); // DEF-56486, без добавления фильтра SELECT неэффективен
        Ok = lnk.GetGE and (lnk.rec.ContractID == ord.rec.ContractID);
        while (Ok)
          leg.KeyNum = 0;
          leg.rec.LegKind = LEG_KIND_VSBANNER;
          leg.rec.DealID = lnk.rec.BCID;
          leg.rec.LegID = 0;

          Ok = leg.GetEQ;
          if (Ok)
            if(FIID == -1)
               FIID = leg.rec.PFI;
             elif(FIID != leg.rec.PFI)
               lnk.dropFilter(); // DEF-56486
               return -1; /* Не все векселя в одной валюте */
             end;
          end;
         Ok = lnk.next;
        end;
        lnk.dropFilter(); // DEF-56486
     return FIID;
    END;

    PRIVATE MACRO GetSums( LinkKind, Amount:@Money, PayCur:@Integer )
        var Query, Cmd, Ds;

        Query = " SELECT "
                  + " SUM( lnk.t_BCCost ) AS Amount "
                 + " ,MAX( RSB_BILL.GetVSBnrPayFIID( lnk.t_BCID ) ) AS PayCur "
              + " FROM "
                 + " dvsordlnk_dbt lnk "
              + " WHERE "
                  + " lnk.t_DocKind = :DocKind "
              + " AND lnk.t_ContractID = :ContractID "
              + " AND lnk.t_LinkKind = :LinkKind ";

        Cmd = RSDCommand( Query );

        Cmd.NullConversion = true;

        Cmd.AddParam( "DocKind", RSDBP_IN, ord.rec.DocKind );
        Cmd.AddParam( "ContractID", RSDBP_IN, ord.rec.ContractID );
        Cmd.AddParam( "LinkKind", RSDBP_IN, LinkKind );
        
        Cmd.Execute();

        Ds = TRsbDataSet( Cmd );

        if( Ds.MoveNext() )
            Amount = SQL_ConvTypeSum( Ds.Amount );
            PayCur = SQL_ConvTypeInteger( Ds.PayCur );
        end;
    END;

    PRIVATE MACRO GetDiffCur()
        var DiffCur = NATCUR,
            NewAmount = $0,
            NewPayCur = NATCUR,
            OldAmount = $0,
            OldPayCur = NATCUR,
            AntiAmount = $0;

        GetSums( VSORDLNK_K_EMISSION, @NewAmount, @NewPayCur );
        GetSums( VSORDLNK_K_DRAW, @OldAmount, @OldPayCur );
        AntiAmount = ConvertSum( OldAmount, ord.rec.Rate, ord.rec.Scale, ord.rec.Point, ord.rec.IsInverse, UNSET_CHAR, $0 );

        if( AntiAmount >= NewAmount )
            DiffCur = OldPayCur;
        else
            DiffCur = NewPayCur;
        end;

        return DiffCur;
    END;

    PRIVATE MACRO InitParmArray()
        var tmp, paym;

        ParmA[MC_TYPE_PARAMETR_DOCKIND] = ord.rec.DocKind;
        ParmA[MC_TYPE_PARAMETR_DOCID] = ord.rec.ContractID;
        ParmA[MC_TYPE_PARAMETR_OWNER] = ord.rec.Contractor;
        ParmA[MC_TYPE_PARAMETR_PARTY] = ord.rec.Contractor;
        ParmA[MC_TYPE_PARAMETR_CONTRACTOR] = ord.rec.Contractor;
        ParmA[MC_TYPE_PARAMETR_PLACE] = 0;
        ParmA[MC_TYPE_PARAMETR_BEGDATE] = ord.rec.SignDate;
        ParmA[MC_TYPE_PARAMETR_FINDATE] = date (0,0,0);
        ParmA[MC_TYPE_PARAMETR_VALDATE] = ord.rec.SignDate;
        ParmA[MC_TYPE_PARAMETR_ISSUER] = {OurBank};
        ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = NATCUR;
        ParmA[MC_TYPE_PARAMETR_CORRDEPARTMENT] = ord.rec.ContrDepartment;

        if (ПолучитьСистемныйВыпускФинИн (FIKIND_AVOIRISS, AVOIRISSKIND_BILL, tmp))
            ParmA[MC_TYPE_PARAMETR_FIID] = tmp;
        end;

        /* Мена */
        if(ord.rec.ContractKind == DL_ORDER_VSBARTER)
           if(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_VSBARTERDIFF, 0)) != null)
              AND (paym.PaymentID > 0))
              ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
           else
              ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = GetDiffCur();
           end;
        /* Эмиссия */
        elif ( (ord.rec.ContractKind == DL_ORDER_VSEMIS) OR
               (ord.rec.ContractKind == DL_ORDER_VSDISC) OR
               (ord.rec.ContractKind == DL_ORDER_VSPERC) )
           if(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_VEKSEL, 0)) != null)
              AND (paym.PaymentID > 0))
              ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
           end;
        /* Погашение */
        elif ( (ord.rec.ContractKind == DL_ORDER_VSDRAW) OR
               (ord.rec.ContractKind == DL_ORDER_VSDRAW_EARLY) )
           if(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_VEKSELDRAW, 0)) != null)
              AND (paym.PaymentID > 0))
              if (paym.ReceiverAmount > 0 )
                ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
              elif(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_PAY_DEBT, 0)) != null)
                 AND (paym.PaymentID > 0))
                ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
              else
                ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = leg.rec.PFI;
              end;
           end;
        /* Хранение */
        elif (ord.rec.ContractKind == DL_ORDER_VSSTORE)
          // Для договора залога платеж не создается, параметр "Валюта платежа" для КУ используемых в операции "Прием на хранение" не нужен
        /* Залог */
        elif (ord.rec.ContractKind == DL_ORDER_VSPAWN)
           ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = 
                                        CheckCur_AllBanner( VSORDLNK_K_PAWN );
        /* Зачет требований */
        elif (ord.rec.ContractKind == DL_ORDER_VSINTERCHANGE)
           if(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_VSDIFF2C, 0)) != null)
              AND (paym.PaymentID > 0))
             ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
           elif(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_VSDIFF2B, 0)) != null)
              AND (paym.PaymentID > 0))
             ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
           else
             ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = leg.rec.PFI;
           end;
        elif(ord.rec.ContractKind == DL_ORDER_VSSALE) // продажа
           if(((paym = MyRsbPayment(ord.rec.DocKind, ord.rec.ContractId, PM_PURP_VEKSEL, 0)) != null)
              AND (paym.PaymentID > 0))
              ParmA[MC_TYPE_PARAMETR_PAYCURRENCY] = paym.ReceiverFIID;
           end;
        end;

        if (legfound)
          if (ord.rec.ContractKind == DL_ORDER_VSSTORE)
            ParmA[MC_TYPE_PARAMETR_CURRENCY] = CheckCur_AllBanner( VSORDLNK_K_STORAGE);
          elif (ord.rec.ContractKind == DL_ORDER_VSPAWN )
            ParmA[MC_TYPE_PARAMETR_CURRENCY] = CheckCur_AllBanner(  VSORDLNK_K_PAWN );
          else
            ParmA[MC_TYPE_PARAMETR_CURRENCY] = leg.rec.PFI;
          end;
        end;

        if (ord.rec.DocKind == DL_VEKSELPAWNORDER) /* Залог */
           ParmA[MC_TYPE_PARAMETR_NUMBER] = MakePawnNumber();
        else
           ParmA[MC_TYPE_PARAMETR_NUMBER] = MakeNumber(ord.rec.OrderNumber);
        end;
        ParmA[MC_TYPE_PARAMETR_SENIORNUMBER] = "";

        if ((ord.rec.DocKind == DL_VEKSELPAWNORDER) and IsBankCentrMode() and (VS_GetHeadDepartment() == {OperDprt}))
          ParmA[MC_TYPE_PARAMETR_DEPARTMENT] = {OperDprt};
        else
          ParmA[MC_TYPE_PARAMETR_DEPARTMENT] = ord.rec.Department;
        end;

        FIRoleBArray[0] = FIROLE_FIDOC;
        FIRoleBArray[1] = FIROLE_CORACC_PASSIVE;
        FIRoleBArray[2] = FIROLE_CORACC_ACTIVE;
    END;

    /*Получить параметры*/
    MACRO GetParametr (ParmKind, OperDate, CatCode, FIRole)
        VAR 
            Parametr = ParmA[ParmKind];

        if (Parametr==null) 
            Parametr = -1;
        end;

        if(ParmKind == MC_TYPE_PARAMETR_CENTR)
             Parametr = PartyIDОператора({oper});  /* PartyID текущего оператора */
             if(Parametr == -1)
                Parametr = {OurBank};
             end;
        end;

        return Parametr;
    END;

    /* установить параметр */
    MACRO SetParametr (ParmKind, value)
    var
       old = -1;

       if( (ParmKind >= 0) and (ParmKind < ParmA.size) )
           old = ParmA[ParmKind];
           ParmA[ParmKind] = value;
       end;

       return old;
    END;

    MACRO GetParametrTemplate
    ( 
        ObjectID,       /* параметр - номер справочника */
        Classificator,  /* классификатор - номер классификатора, если он задан */
        OperDate,
        FIRole
    )

        if(ObjectID == OBJTYPE_DIRECTION) /* 1107 Направление */
           if(Classificator == LLCLASS_DIRECTION_PAYMM) /* 158 - Направление выплат */
              if(ord.rec.Flag1 == "X")
                 return 4; /* выплаты */
              else
                 return 3; /* поступление */
              end;
           end;

        elif (ObjectID==OBJTYPE_BACKOFFICE)             /*1118*/
            if (Classificator==LLCLASS_BACKOFFICE)                   /*180*/
               return 1; /* СВО - сектор вексельного обращения */
            end;

        elif (ObjectID==OBJTYPE_VALUETYPE)              /*1111*/
            if (Classificator==LLCLASS_VALUE_CLS_SAVE)               /*155*/
               return 1; /* Простой вексель */
            end;

        elif (ObjectID==OBJTYPE_PRODUCT)                /*1103*/
            if (Classificator==LLCLASS_PRODUCT_STORAGE)              /*146*/
               if((ord.rec.DocKind   == DL_VEKSELORDER) OR (ord.rec.DocKind == DL_VSSALE))     /* договор эмиссии или продажи*/
                 return 400; /* Продажа(Векс) */
               elif(ord.rec.DocKind == DL_VSBARTERORDER)   /* договор мены */
                 return 402; /* Мена(Векс) */
               elif(ord.rec.DocKind == DL_VSSTORAGEORDER)  /* договор хранения */
                 return 403; /* Хранение(Векс) */
               elif(ord.rec.DocKind == DL_VEKSELPAWNORDER) /* договор залога */
                 return 401; /* Размещение(Векс) */
               end;
            end;

        elif (ObjectID==OBJTYPE_KINDTAX)             /*1105*/
            return 1; /* НДС */

        elif (ObjectID == OBJTYPE_SIDEBALANCE)          //1000 - справочник сторон баланса
            if (Classificator == LLCLASS_SIDEBALANCE_CORACCKIND)       // 1622 - Вид корреспондирующего счета

               if(FIRole == FIROLE_CORACC_PASSIVE)
                  return 2; // Пассивный
               elif(FIRole == FIROLE_CORACC_ACTIVE)
                  return 1; // Активный
               end;

            end;
        end;


        return -1;
    END;

    MACRO GetBasisFIRole(FIRole)
      var i = 0;
      if (FIRole == FIROLE_UNDEF)
        return FIROLE_FIDOC;
      end;
      while (i < FIRoleBArray.Size)
        if (FIRoleBArray[i] == FIRole)
          return FIRole;
        end;
        i = i + 1;
      end;
      Error = 1;
      return FIROLE_UNDEF;
    END;

    MACRO GetFIRoleBArray()
      return FIRoleBArray;
    END;

    PRIVATE MACRO FindSpgr
        spgr.KeyNum = 6;
        spgr.rec.SourceDocKind = ord.rec.DocKind;
        spgr.rec.SourceDocID = ord.rec.ContractID;
        if ((ord.rec.DocKind == DL_VEKSELPAWNORDER) or (ord.rec.DocKind == DL_VEKSELDRAWORDER))
            spgr.rec.Direction = 1; /*ENTERING*/
        else
            spgr.rec.Direction = 2; /*EXITING*/
        end;
        spgr.rec.Department = ord.rec.Department;
        spgr.rec.Division = DIVISION_VEKSEL;

        spgrfound = spgr.GetEQ;

        return spgrfound;
    END;

    PRIVATE MACRO FindLeg
        leg.KeyNum = 0;
        leg.rec.LegKind = LEG_KIND_VSBANNER;
        leg.rec.DealID = bnr.rec.BCID;
        leg.rec.LegID = 0;

        legfound = leg.GetEQ;
        return legfound;
    END;

    PRIVATE MACRO FindFirstBnr
        lnk.KeyNum = 1;
        lnk.rec.DocKind = ord.rec.DocKind;
        lnk.rec.ContractID = ord.rec.ContractID;
        lnk.rec.LinkKind = -1000;
        lnk.rec.Issuer = {OurBank};
        lnk.rec.BCID = 0;
        lnk.addFilter("t_DocKind = " + string(ord.rec.DocKind) + " and t_ContractID = " + string(ord.rec.ContractID)); // DEF-56486, без добавления фильтра SELECT неэффективен

        bnrfound = lnk.GetGE and (lnk.rec.ContractID == ord.rec.ContractID);

        if (bnrfound)
            bnr.KeyNum = 0;
            bnr.rec.BCID = lnk.rec.BCID;

            bnrfound = bnr.getEQ;
        end;

        if (bnrfound)
            FindLeg;
        end;
        lnk.dropFilter(); // DEF-56486
    END;

    /*Макрос корректировки открываемого счета. Account, accblnc, ORScheme можно менять*/
    MACRO CorrectAccount(account, accblnc, ORScheme, categ, templ, accdoc,  OperDate)
      return true;
    END;

    if ((ValType(DocKind_Order)==V_INTEGER) AND (ValType(DocId_bnr)==V_INTEGER))
        /*Конструктор из DocKind, DocID*/
        ord.KeyNum = 0;
        ord.rec.ContractID = DocId_bnr;
        if (not ord.GetEQ)
            RunError ("не найден договор с идентификатором " + DocId_bnr);
        end;

        FindFirstBnr;
        FindSpgr;
    else
        /*Конструктор из структур и дополнительных параметров*/
        if (not copy(ord, DocKind_Order))
            RunError ("неверный вызов конструктора");
        end;
        FindSpgr;

        if (not copy(bnr, DocId_bnr))
            FindFirstBnr;
        else
            if (not copy(leg,p_leg))
                FindLeg;
            end;
        end;
    end;

    InitParmArray ();

    Kind = ParmA[MC_TYPE_PARAMETR_DOCKIND];
    Id = ParmA[MC_TYPE_PARAMETR_DOCID];
END;
