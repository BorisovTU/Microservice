/**                           
  @file      dlsrvcheck.mac
  @brief     Проверки сервисных операций при откате. 
  Функции проверки возможности отката сервисной операции. 
  Проверка состояния проводок сервисной операции.
  Метод получения списка событий по проводкам СО. 
  
  # menu 
  - БО ЦБ\Сервисные операции
  
  # tag
  - functional_block: Проводки
  - functional_block: СО
  - functional_block: БУ
  - functional_block: ВУ
  - code_type: GUI
  
  # changelog
  |date       |author       |tasks                                                     |note                                                        
  |-----------|-------------|----------------------------------------------------------|-------------------------------------------------------------
  |2023.10.01 |Дылгеров Ц.В.|CCBO-7604                                                 | Добавлены комментарии
  |2023.09.25 |Дылгеров Ц.В.|CCBO-7604                                                 | Добавлены комментарии
  |?          |?            |?                                                         | Создание           
  
*/
import secinter;
import rsd; ///< для поиска событий по проводкам СО 

/**
  @brief класс события 
*/
private class c_event_short()
   var object_type
      ,object_id
      ,rec_id
      ,status;
end; ///< class c_event_short()

/**
  @brief класс проверки состояния проводок Сервисной Операции 
  @param[in] p_so_doc_kind  вид документа сервисной операции
  @param[in] p_so_doc_id    ID(идентификатор) документа сервисной операции
  @param[in] p_doc_kind     вид первичного документа 
  @param[in] p_doc_id       ID(идентификатор) первичного документа
*/
private class c_so_acctrn_check(p_so_doc_kind, p_so_doc_id, p_doc_kind, p_doc_id)
   private var gv_exec_stat;
   private var gv_acctrn_query;

   private var gv_so_doc_kind;
   private var gv_so_doc_id;
   private var gv_doc_kind;
   private var gv_doc_id;
   private var gv_is_whole_so;
   private var gv_acctrn_evnt_list;
   private var gv_acctrn_evnt_quant;

   /**
     @brief установить признак (видимо проверки всех СО)
   */
   private macro m_calc_is_whole_so()
      if((gv_doc_kind != 0) and (gv_doc_kind != 0))
         gv_is_whole_so = false;
      else
         gv_is_whole_so = true;
      end;
   end;

   /**
     @brief установить поле вида сервисной операции
     @param p_so_doc_kind - вид сервисной операции
   */
   macro m_set_so_doc_kind(p_so_doc_kind)
      if(ValType(p_so_doc_kind) != V_UNDEF)
         gv_so_doc_kind = p_so_doc_kind;
      end;
   end;

   /**
     @brief вернуть поле вида сервисной операции
     @return возвращает вид сервисной операции
   */
   macro m_get_so_doc_kind()
      return gv_so_doc_kind;
   end;

   /**
     @brief установить поле ID сервисной операции
     @param[in] p_so_doc_id - ID сервисной операции
   */
   macro m_set_so_doc_id(p_so_doc_id)
      if(ValType(p_so_doc_id) != V_UNDEF)
         gv_so_doc_id = p_so_doc_id;
      end;
   end;

   /**
     @brief вернуть поле ID сервисной операции
     @return ID сервисной операции
   */
   macro m_get_so_doc_id()
      return gv_so_doc_id;
   end;

   /**
     @brief установить поле вида первичного документа
     @param[in] p_doc_kind - вид документа
   */
   macro m_set_doc_kind(p_doc_kind)
      if(ValType(p_doc_kind) != V_UNDEF)
         gv_doc_kind = p_doc_kind;
         m_calc_is_whole_so();
      end;
   end;

   /**
     @brief вернуть вид первичного документа
     @return вид первичного документа
   */
   macro m_get_doc_kind()
      return gv_doc_kind;
   end;

   /**
     @brief установить поле ID документа и установить признак не частичности сервисной операции
     @param[in] p_doc_id ID документа
   */
   macro m_set_doc_id(p_doc_id)
      if(ValType(p_doc_id) != V_UNDEF)
         gv_doc_id = p_doc_id;
         m_calc_is_whole_so();
      end;
   end;

   /**
     @brief вернуть ID документа
     @return ID документа
   */
   macro m_get_doc_id()
      return gv_doc_id;
   end;

   /**
     @brief вернуть признак нечастичности сервисной операции
     @return признак нечастичности сервисной операции
   */
   macro m_get_is_whole_so()
      return gv_is_whole_so;
   end;

   /**
     @brief вернуть список проводок
     @return список проводок
   */
   macro m_get_acctrn_evnt_list()
      return gv_acctrn_evnt_list;
   end;

   /**
     @brief вернуть количество событий по проводкам по сервисной операции
     @return количество событий проводок
   */
   macro m_get_acctrn_evnt_quant()
      return gv_acctrn_evnt_quant;
   end;

   /** 
     @brief Подготовка запроса для определения id проводок частичной СО 
     Формирует запрос проверки возможности частичного отката СО
     @param[in] p_so_doc_kind вид документа сервисной операции
     @return всегда вернет true
   */
   private macro m_make_acctrn_query_so_part(p_so_doc_kind)
      private var v_ret = true;
      private var v_sql = "";

      if(p_so_doc_kind == DL_SCACCOUNTING) ///< Бухгалтерский учет. Откат по выпуску - считаем, что других вариантов частичного отката не предусмотрено 
         v_sql = v_sql + "SELECT t_docid FROM ddlgrdoc_dbt ";
         v_sql = v_sql + " WHERE t_servdockind = :p_so_doc_kind ";
         v_sql = v_sql + "   AND t_servdocid = :p_so_doc_id ";
         v_sql = v_sql + "   AND t_grpid = :p_doc_id ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";

      elif(p_so_doc_kind == DL_OFFBALTRANSFSRVOP) ///< Операция переноса по внебалансу. Откат по сделке - считаем, что других вариантов частичного отката не предусмотрено 
         v_sql = v_sql + "SELECT t_docid FROM ddlgrdoc_dbt ";
         v_sql = v_sql + " WHERE t_servdockind = :p_so_doc_kind ";
         v_sql = v_sql + "   AND t_servdocid = :p_so_doc_id ";
         v_sql = v_sql + "   AND t_grdealid IN (SELECT t_id ";
         v_sql = v_sql + "                        FROM ddlgrdeal_dbt ";
         v_sql = v_sql + "                       WHERE t_dockind = :p_doc_kind ";
         v_sql = v_sql + "                         AND t_docid = :p_doc_id) ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";

      else
         ///< Проверено для p_doc_kind = 5, 101 
         v_sql = v_sql + "SELECT /*+ precompute_subquery index(opd DOPRDOCS_DBT_IDX2)*/ t_acctrnid FROM doprdocs_dbt opd ";
         v_sql = v_sql + " WHERE t_servdockind = :p_so_doc_kind ";
         v_sql = v_sql + "   AND t_servdocid = :p_so_doc_id ";
         v_sql = v_sql + "   AND t_id_operation IN (SELECT /*+ precompute_subquery */ t_id_operation ";
         v_sql = v_sql + "                            FROM doproper_dbt ";
         v_sql = v_sql + "                           WHERE t_dockind = :p_doc_kind ";
         v_sql = v_sql + "                             AND t_documentid = LPAD(TO_CHAR(:p_doc_id), 34, '0')) ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";
      end;

      gv_acctrn_query = v_sql;

      return v_ret;
   end; ///< macro m_make_acctrn_query_so_part() 

   /** 
     @brief Подготовка запроса для определения id проводок по всех СО 
     Формирует часть запроса для использования в общем запросе проверки возможности отката СО
     @param[in] p_so_doc_kind вид документа сервисной операции
     @return вернет true, за исключением, если вид документа сервисной операции не подошел под используемые
   */
   private macro m_make_acctrn_query_so_whole(p_so_doc_kind)
      private var v_ret = true;
      private var v_sql = "";

      if(   (p_so_doc_kind == DL_GET_INCOME)    ///< Начисление доходов/расходов 
         or (p_so_doc_kind == DL_OVERVALUE)     ///< Переоценка 
         or (p_so_doc_kind == DL_RESERVEDOC)    ///< Резервирование 
         or (p_so_doc_kind == DL_OVERVALUE_RD)  ///< Переоценка внебаланса 
         or (p_so_doc_kind == SP_ACCEXPREVOEB)) ///< Начисление расходов и доходов ОЭБ 

         v_sql = v_sql + "SELECT t_acctrnid FROM doprdocs_dbt ";
         v_sql = v_sql + " WHERE t_servdockind = :p_so_doc_kind ";
         v_sql = v_sql + "   AND t_servdocid = :p_so_doc_id ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";

      elif(   (p_so_doc_kind == DL_SETTLEMENTFCURM) ///< Расчеты с биржей 
           or (p_so_doc_kind == SP_TRANSFERPA))     ///< Перечисление средств платежному агенту 

         v_sql = v_sql + "SELECT /*+ precompute_subquery index(d DOPRDOCS_DBT_IDX1)*/ t_acctrnid FROM doprdocs_dbt d";
         v_sql = v_sql + " WHERE t_id_operation IN (SELECT  /*+ precompute_subquery */ t_id_operation ";
         v_sql = v_sql + "                            FROM doproper_dbt ";
         v_sql = v_sql + "                           WHERE t_dockind = :p_so_doc_kind ";
         v_sql = v_sql + "                             AND t_documentid = LPAD(TO_CHAR(:p_so_doc_id), 34, '0')) ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";

      elif(p_so_doc_kind == DL_WRTMONEY) ///< Операция зачисления/списания денежных средств 

         v_sql = v_sql + "SELECT /*+ precompute_subquery index(d DOPRDOCS_DBT_IDX1) */ t_acctrnid FROM doprdocs_dbt d ";
         v_sql = v_sql + " WHERE t_id_operation IN (SELECT  /*+ precompute_subquery */ t_id_operation ";
         v_sql = v_sql + "                            FROM doproper_dbt o ";
         v_sql = v_sql + "                           WHERE t_dockind = :p_so_doc_kind ";
         v_sql = v_sql + "                             AND t_documentid = LPAD(TO_CHAR(:p_so_doc_id), 34, '0')) ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";

      elif(   (p_so_doc_kind == DL_SCACCOUNTING)       ///< Операция бухгалтерского учета 
           or (p_so_doc_kind == DL_OFFBALTRANSFSRVOP)) ///< Операция переноса по внебалансу 

         v_sql = v_sql + "SELECT t_docid FROM ddlgrdoc_dbt ";
         v_sql = v_sql + " WHERE t_servdockind = :p_so_doc_kind ";
         v_sql = v_sql + "   AND t_servdocid = :p_so_doc_id ";
         v_sql = v_sql + "   AND t_dockind = :p_kind_acctrn ";

      else
         gv_exec_stat = false;
         v_ret = false;
      end;

      gv_acctrn_query = v_sql;

      return v_ret;
   end; ///< macro m_make_acctrn_query_so_whole() 

   /** 
     @brief Сформировать запрос для получения ID проводок в соответствии с типом СО 
     @param[in] p_so_doc_kind - вид сервисной операции
     @return успешность построения текстового запроса для получения полной или частичной СО
   */
   private macro m_make_acctrn_query(p_so_doc_kind)
      private var v_ret = true;

      if(gv_is_whole_so)
         if((p_so_doc_kind == DL_SCACCOUNTING) and (gv_doc_id != 0)) ///< Бухгалтерский учет 
            /// Для СО бухгалтерского учета при откате по выпуску может быть не заполнен doc_kind 
            v_ret = m_make_acctrn_query_so_part(p_so_doc_kind);
         else
            v_ret = m_make_acctrn_query_so_whole(p_so_doc_kind);
         end;
      else
         if(   (p_so_doc_kind == DL_RESERVEDOC)         ///< Резервирование  doc_kind = 5 
            or (p_so_doc_kind == DL_OVERVALUE)          ///< Переоценка  doc_kind = 5 
            or (p_so_doc_kind == DL_OVERVALUE_RD)       ///< Переоценка внебаланса  doc_kind = 101 
            or (p_so_doc_kind == DL_GET_INCOME)         ///< Начисление доходов/расходов doc_kind = 5 
            or (p_so_doc_kind == DL_SCACCOUNTING)       ///< Бухгалтерский учет На всякий случай - если вдруг оказался заполнен doc_kind 
            or (p_so_doc_kind == DL_OFFBALTRANSFSRVOP)) ///< Операция переноса по внебалансу doc_kind = 101 

            v_ret = m_make_acctrn_query_so_part(p_so_doc_kind);

         else
            ///< По остальным СО проверяем все проводки 
            v_ret = m_make_acctrn_query_so_whole(p_so_doc_kind);
         end;
      end;

      return v_ret;
   end; ///< end of macro m_make_acctrn_query() 

   /** 
     @brief Метод получения списка событий по проводкам СО 
     Чтобы не работать со списками (могут быть большими) сразу находим события в нужных статусах 
     Считает количество событий по проводкам
     @return вернет true в общем случае. Вернет false для ошибки exception или невозможности построения запроса построения списка проводок
   */
   macro m_find_so_acctrn_event_imm()
      private const CV_ACCTRN_OBJ_TYPE = 1;
      private const CV_KIND_ACCTRN = 1;
      private var v_ret = true;
      private var v_sql = "";
      private var v_cmd, v_rs;
      private var v_aux_cntr;

      if(m_make_acctrn_query(gv_so_doc_kind))

         v_sql = v_sql + "SELECT /*+ index(utp UTABLEPROCESSEVENT_DBT_IDX1)*/ t_recid, t_objecttype, t_objectid, t_status ";
         v_sql = v_sql + "  FROM utableprocessevent_dbt utp ";
         v_sql = v_sql + " WHERE t_objecttype = :p_objecttype ";
         v_sql = v_sql + "   AND t_objectid IN (" + gv_acctrn_query + ") ";
         v_sql = v_sql + "   AND t_status IN (1, 2) ";

         v_cmd = RSDCommand(v_sql);
         v_cmd.addParam("p_objecttype", RSDBP_IN, CV_ACCTRN_OBJ_TYPE);

         v_cmd.addParam("p_so_doc_kind", RSDBP_IN, gv_so_doc_kind);
         v_cmd.addParam("p_so_doc_id", RSDBP_IN, gv_so_doc_id);
         if(not gv_is_whole_so)
            if(   (gv_so_doc_kind == DL_RESERVEDOC)         ///< Резервирование doc_kind = 5 
               or (gv_so_doc_kind == DL_OVERVALUE)          ///< Переоценка doc_kind = 5 
               or (gv_so_doc_kind == DL_OVERVALUE_RD)       ///< Переоценка внебаланса doc_kind = 101 
               or (gv_so_doc_kind == DL_GET_INCOME)         ///< Начисление доходов/расходов doc_kind = 5 
               or (gv_so_doc_kind == DL_OFFBALTRANSFSRVOP)) ///< Операция переноса по внебалансу doc_kind = 101 

               v_cmd.addParam("p_doc_kind", RSDBP_IN, gv_doc_kind);
               v_cmd.addParam("p_doc_id", RSDBP_IN, gv_doc_id);

            elif(gv_so_doc_kind == DL_SCACCOUNTING) ///< Бухгалтерский учет На всякий случай - если вдруг оказался заполнен doc_kind 
               v_cmd.addParam("p_doc_id", RSDBP_IN, gv_doc_id);
            end;

         else
            if((gv_so_doc_kind == DL_SCACCOUNTING) and (gv_doc_id != 0)) ///< Бухгалтерский учет Откат по выпуску - считаем, что других вариантов частичного отката не предусмотрено 
               v_cmd.addParam("p_doc_id", RSDBP_IN, gv_doc_id);
            end;
         end;

         v_cmd.addParam("p_kind_acctrn", RSDBP_IN, CV_KIND_ACCTRN);
         v_rs = RSDRecordSet(v_cmd);

         gv_acctrn_evnt_list.size = 0; ///< Удаляем старые результаты (если есть) 
         gv_acctrn_evnt_quant = 0;
         v_aux_cntr = 0;

         while(v_rs.movenext())
            gv_acctrn_evnt_list.value(v_aux_cntr) = c_event_short;
            gv_acctrn_evnt_list.value(v_aux_cntr).object_type = v_rs.value("t_objecttype");
            gv_acctrn_evnt_list.value(v_aux_cntr).object_id = v_rs.value("t_objectid");
            gv_acctrn_evnt_list.value(v_aux_cntr).rec_id = v_rs.value("t_recid");
            gv_acctrn_evnt_list.value(v_aux_cntr).status = v_rs.value("t_status");

            v_aux_cntr = v_aux_cntr + 1;
         end;

         gv_acctrn_evnt_quant = v_aux_cntr;
         v_rs.close(); 
		 v_cmd.close(); 
		 v_rs = null; v_cmd = null; v_sql = null;

      else
         v_ret = false;
      end;

      return v_ret;

   onError(v_err)
      v_ret = false;
      return v_ret;
   end; ///< macro m_find_so_acctrn_event_imm() 

   /** 
     @brief Конструктор класса проверки состояния проводок Сервисной Операции 
     @brief класс проверки состояния проводок Сервисной Операции 
     @param[in] p_so_doc_kind  вид документа сервисной операции
     @param[in] p_so_doc_id    ID(идентификатор) документа сервисной операции
     @param[in] p_doc_kind     вид первичного документа 
     @param[in] p_doc_id       ID(идентификатор) первичного документа
   */
   private macro m_init_so_acctrn_check(i_so_doc_kind, i_so_doc_id, i_doc_kind, i_doc_id)
      gv_exec_stat = true;
      gv_acctrn_query = "";

      if(ValType(i_so_doc_kind) != V_UNDEF)
         gv_so_doc_kind = i_so_doc_kind;
      else
         gv_so_doc_kind = 0;
      end;

      if(ValType(i_so_doc_id) != V_UNDEF)
         gv_so_doc_id = i_so_doc_id;
      else
         gv_so_doc_id = 0;
      end;

      if(ValType(i_doc_kind) != V_UNDEF)
         gv_doc_kind = i_doc_kind;
      else
         gv_doc_kind = 0;
      end;

      if(ValType(i_doc_id) != V_UNDEF)
         gv_doc_id = i_doc_id;
      else
         gv_doc_id = 0;
      end;

      if((gv_doc_kind != 0) and (gv_doc_id != 0))
         gv_is_whole_so = false;
      else
         gv_is_whole_so = true;
      end;

      gv_acctrn_evnt_list = TArray();
      gv_acctrn_evnt_quant = 0;
   end; ///< macro m_init_so_acctrn_check() 

   m_init_so_acctrn_check(p_so_doc_kind, p_so_doc_id, p_doc_kind, p_doc_id);
end; ///< end of class c_so_acctrn_check() 

/**
  @brief Функция проверки возможности отката сервисной операции
  @param[in] ServDocKind - вид первичного документа сервисной операции
  @param[in] srvbuff - буффер записи сервисной операции. Определяется в зависимости от ServDocKind
  @param[in] DocKind - вид откатываемого объекта. 0 - если откатывается вся СО
  @param[in] DocID - идентификатор откатываемого объекта. 0 - если откатывается вся СО

  По DocKind+DocID можно определить, где и как искать буфер объекта
  Например, если DocKind == 5 (DLDOC_ISSUE), то это "Ценная бумага", а в DocID будет её идентификатов (DFININST_DBT.T_FIID)
  Если DocKind == 101 (DL_SECURITYDOC), то это "Сделка", а в DocID будет идентификатор сделки (DDL_TICK_DBT.T_DEALID) 

  Возвращаемое значение:
  @return 0 - если можно откатывать, 1 (или не 0) - если нельзя откатывать
*/
MACRO SvOpCheckRollBack(ServDocKind, srvbuff, DocKind, DocID)

  file docf("dl_comm.dbt");
  var doc_new = TRecHandler( "dl_comm.dbt" );

  var dl_comm_buf  = TRecHandler("dl_comm.dbt");
  var scsrvrep_buf = TRecHandler("scsrvrep.dbt");   
  var nptxop_buf   = TRecHandler("nptxop.dbt"); 
  var needBreak    = false;
  var v_so_acctrn_checker = NULL;
  var nameOperation = " отката "; 

  /**
    @brief getDocumentName - возвращает название первичного домумента
    @param[in] id - t_dockind - вид первичного документа
    @return название первичного документа
  */	
  macro getDocumentName(id)
    var query = "select * from doprkdoc_dbt where t_dockind = " + id;
    var cmd = RSDCommand(query);
    var rs = RSDRecordSet(cmd);
    if (rs.movenext)
      return rs.value("t_name");
    else
      return "";
    end; 
  end;
  /**
    @brief  WriteFiscLogDlComm - запись в фискальный лог начала операции 
    Запись в лог операции отката или удаления сервисной операции
    Отключено в DEF-50240
  */
  macro WriteFiscLogDlComm()
    if (dl_comm_buf.rec.commstatus==0)
      nameOperation = "удаления ";
    else
      /// Отключен дубль вывода в фискальный лог DEF-50240. 
      /// Дублируется с выводом в закрытом коде про процедуре Rollback: 
      ///   (CAccountingSrvOpScrol::RollBack() или CInAccSrvOpScrol::RollBack())
      ///      WriteFiscLog(OLstrproc, "Старт "+nameoperation+" сервисной операции. Имя файла - dl_comm_dbt. ID операции "+dl_comm_buf.rec.documentid+
      ///        ". Тип операции "+dl_comm_buf.rec.dockind+" "+getDocumentName(dl_comm_buf.rec.dockind)+
      ///        ". Код операции "+dl_comm_buf.rec.commcode); 
    end;
    ///WriteFiscLog(OLinsert, docf, dl_comm_buf);
  end;
  ///ББОЦБ
  if(ServDocKind == DL_GET_INCOME)          ///<Начисление доходов/расходов
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == DL_OVERVALUE)         ///<Переоценка
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == DL_RESERVEDOC)        ///<Резервирование
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == DL_COMMDOC)           ///<Операция расчета периодических комиссий
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == DL_OVERVALUE_RD)      ///<Переоценка внебаланса
    dl_comm_buf.SetRecordAddr(srvbuff);
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == DL_SCACCOUNTING)      ///<Операция бухгалтерского учета 
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///если DocKind==0, а DocID!=0, то откатывается (удаляется) группа (DPMWRTGRP_DBT.T_ID = DocID)
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО

  elif(ServDocKind == DL_INACCSRVOP)        ///<Операция ВУ
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == DL_DEPOACCSRVOP)      ///<Операция депозитарного учета в БОЦБ
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == DL_OFFBALTRANSFSRVOP) ///<Операция переноса по внебалансу
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == SP_SRVBROKERREP)      ///<Сервисная операция отправки отчета брокера
    scsrvrep_buf.SetRecordAddr(srvbuff);
  elif(ServDocKind == DL_SETTLEMENTFCURM)   ///<Расчеты с биржей
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == DL_WRTMONEY)          ///Операция зачисления/списания денежных средств
    nptxop_buf.SetRecordAddr(srvbuff);
    v_so_acctrn_checker = c_so_acctrn_check(nptxop_buf.rec.dockind, nptxop_buf.rec.id, DocKind, DocID);
  ///    needBreak = true; ///< тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == DL_CALCNDFL)          ///<Операция расчета НОБ для НДФЛ
    nptxop_buf.SetRecordAddr(srvbuff);
  elif(ServDocKind == DL_HOLDNDFL)          ///<Операция удержания НДФЛ
    nptxop_buf.SetRecordAddr(srvbuff);
  elif(ServDocKind == DL_CLOSENDFL)         ///<Операция закрытия расчетных периодов для НДФЛ
    nptxop_buf.SetRecordAddr(srvbuff);
  elif(ServDocKind == DL_RESTTRANS)         ///<Перенос остатков в КДУ    
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == DL_SCINOUTPOOL)       ///<Операция передачи/возврата имущества в пул    
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == SP_TRNCOLLAT)         ///<Перевод обеспечения    
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == SP_BLOCKBATCH)        ///<Блокировка партий    
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == DL_CHGAVRNOM)         ///<Изменение номинала ц/б
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  elif(ServDocKind == SP_AMORTHEDGCORR)     ///<Амортизация корректировок хеджирования
    dl_comm_buf.SetRecordAddr(srvbuff);
    WriteFiscLogDlComm();
  end;

  ///ОЭБ
  if(ServDocKind == SP_ACCEXPREVOEB)        ///<Начисление расходов и доходов ОЭБ
    ///    scsrvrep_buf.SetRecordAddr(srvbuff);
    dl_comm_buf.SetRecordAddr(srvbuff); ///< есть подозрения, что буфер был не правильный
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< kva: тестируем запрет отката СОneedBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == SP_TRANSFERPA)        ///<Перечисление средств платежному агенту
    ///    scsrvrep_buf.SetRecordAddr(srvbuff);
    dl_comm_buf.SetRecordAddr(srvbuff); ///< есть подозрения, что буфер был не правильный
    WriteFiscLogDlComm();
    v_so_acctrn_checker = c_so_acctrn_check(dl_comm_buf.rec.dockind, dl_comm_buf.rec.documentid, DocKind, DocID);
    ///    needBreak = true; ///< тестируем запрет отката СО
  elif(ServDocKind == SP_COMISSION_PA)      ///<Оплата комиссии платежному агенту
    scsrvrep_buf.SetRecordAddr(srvbuff);
  end;

  if(ValType(v_so_acctrn_checker) != V_UNDEF)
    if(v_so_acctrn_checker.m_find_so_acctrn_event_imm())
      /// Если есть события, которые находятся в активном процессе обработки, то необходимо дождаться его окончания 
      if(v_so_acctrn_checker.m_get_acctrn_evnt_quant() > 0)
        msgbox(string("Откатить Сервисную Операцию (dockind=",
                      v_so_acctrn_checker.m_get_so_doc_kind(),
                      "; docid=",
                      v_so_acctrn_checker.m_get_so_doc_id(),
                      ") невозможно.\nИмеются связанные проводки в процессе выгрузки.\nПеред следующей попыткой выполнения Отката дождитесь окончания процесса выгрузки проводок."));
        needBreak = true;
      end;
    else
      /// Произошла ошибка. Откатывать нельзя без результата проверок 
      needBreak = true;
    end;
  end;

  if(needBreak == true)
    return 1;
  end;

  return 0;
END;