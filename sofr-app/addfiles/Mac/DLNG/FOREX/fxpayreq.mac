/*-------------------------------------------------------------------------
          Автоматизированная банковская система RS-Bank v5.1
                 Copyright (c) R-Style Software Lab

  Имя файла        : fxpayreq.mac
  Библиотека       : FOREX
  Описание         : Исполнение требования по сделке
  Программист      : Kalashnikov Michael (KMV)
  Создан           : 7.12.2001
-------------------------------------------------------------------------*/
import OprInter, PaymInter, fxlb, fxcarry, fxstep, fxpm;

/* Массивы с информацией о исполняемых платежах для квитовки */
/* Инициализируются бэк-офисом */
VAR
    PlanIDs     = TArray,
    FactIDs     = TArray,
    KvitAmounts = TArray,
    ExecDate;


MACRO FX_PayRequirement(fd)
  var CurComm, SumComm, CurReq, SumReq, Purpose,
      TranModeReq = 0, KvitMode = 0,TypeOrder = "",
      stat = 0, InegrtMode = false,
      Debet = "",
      Credit = "",
      paym,
      pmprop = TBFile("pmprop"),
      corschem = TBFile("corschem");

  fd.SetCurrency(CurComm, CurReq);
  fd.SetSums(SumComm, SumReq);

  // Актуализация платежа по оплате обязательств
  Purpose = FX_GetPaymentPurpose(0, fd.leg.rec.LegID, FX_IsSale(fd.tick.rec.TypeDoc));
  paym = RsbPayment( fd.tick.rec.BofficeKind, fd.tick.rec.DealID, Purpose, 0 );
  if ( paym.PaymentID == 0 )
    fx_error("Не найден плановый платеж по оплате требования");
    return false;
  end;
  paym.Actuate();

  if (paym.PaymStatus == PM_CLOSED_W_M_MOVEMENT)
    /*Произошел неттинг*/
    return true;
  end;

  GetRegistryValue("COMMON\\WORK_MODE\\INTEGRATED", V_BOOL, InegrtMode, stat);

  if (stat)
    fx_error("Ошибка при получении значений реестра");
    return false;
  end;

  if (CheckTYPEACCOUNT(paym.PayerAccount, "А"))
      TypeOrder = "p";
  elif (CheckTYPEACCOUNT(paym.ReceiverAccount, "А"))
      TypeOrder = "r";
  else
      TypeOrder = "";      
  end;

  if ((InegrtMode)and(TypeOrder != ""))
      if (FX_CreateCashOrder(paym, TypeOrder))
          paym.PaymStatus = PM_READY_TO_SEND;
      else
          fx_error("Не могу сформировать кассовый ордер");
          return false;
      end;
  else
      pmprop.KeyNum = 0;
      pmprop.rec.PaymentID = paym.PaymentID;
      pmprop.rec.DebetCredit = 0;
      if (not pmprop.GetEQ)
        fx_error("Не могу получить схему расчетов");
        return false;
      end;
      
      if (pmprop.rec.Group == FX_PAYMENTS_GROUP_EXTERNAL)
         corschem.KeyNum = 1;
         corschem.rec.Number = pmprop.rec.Corschem;
         corschem.rec.FI_Kind = 1;
         corschem.rec.FIID = paym.PayerFIID;
         if (not corschem.GetEQ)
            fx_error("Не могу получить схему расчетов");
            return false;
         end;
      elif (pmprop.rec.Group == FX_PAYMENTS_GROUP_UNDEF)
         fx_error("Группа платежей не определена");
         return false;
      end;  
    
      GetRegistryValue("КОНВЕРСИОННЫЕ ОПЕРАЦИИ\\ИСПОЛЬЗОВАНИЕ ТС\\ИСПОЛНЕНИЕ ТРЕБОВАНИЙ",
                       V_INTEGER, TranModeReq, stat);
    
      if (not stat)
        GetRegistryValue("КОНВЕРСИОННЫЕ ОПЕРАЦИИ\\РЕЖИМ КВИТОВКИ",
                         V_INTEGER, KvitMode, stat);
      end;
    
      if (stat)
        fx_error("Ошибка при получении значений реестра");
        return false;
      end;
    
      if ((TranModeReq !=FX_TRAN_BEFOREPAYMENT) and (TranModeReq !=FX_TRAN_NOTUSE))
        fx_error("Указанный режим исполнения требований не реализован");
        return false;
      end;
    
      FX_GetRequirementAccount(fd, TranModeReq, Debet, Credit, {curdate});
    
        if (not FX_Carry(1, CurReq, Debet, Credit, SumReq, {curdate}, 0, 
                         "Исполнение требования по сделке", paym.PaymentID))
          fx_error("Не могу выполнить проводку \"Исполнение требования по сделке\"");
          return false;
        end;
      
    
      if ((not bAND(KvitMode, FX_KVIT_REQ)) OR
          (not corschem.rec.IsNostro))
        paym.PaymStatus = PM_FINISHED; // завершен
      else
        if (paym.FuturePayerAmount)
          fx_error("Плановый платеж не сквитован полностью");
          return false;
        end;
      end;
    
      fd.SetGround(TRUE, paym);
  end;

  return true;
END;

PRIVATE MACRO FX_KvitPayments()
  var i = 0,
  ArrayIDPlantype = TArray,
  ArrayIDfacttype = TArray;

  while(i < PlanIDs.Size)
    ArrayIDPlantype(i) = OPR_ID_REAL;
    ArrayIDfacttype(i) = OPR_ID_REAL;
    i = i + 1;
  end;

  if (not PaymentsKvit(PlanIDs,
                       ArrayIDPlantype,
                       FactIDs,
                       ArrayIDfacttype,
                       KvitAmounts))
    fx_error("Ошибка квитовки платежей");
    return false;
  end;

  return true;
END;

MACRO FX_KvitRequirement(fd)
  var TranModeReq, KvitMode,
      stat = 0, i = 0, paym,
      ReqAccount = "",
      MaxiDate = Date(0,0,0),   
      CurCom, CurReq;

  fd.SetCurrency(CurCom, CurReq);
  GetRegistryValue("КОНВЕРСИОННЫЕ ОПЕРАЦИИ\\ИСПОЛЬЗОВАНИЕ ТС\\ИСПОЛНЕНИЕ ТРЕБОВАНИЙ",
                   V_INTEGER, TranModeReq, stat);
  
  if (not stat)
    GetRegistryValue("КОНВЕРСИОННЫЕ ОПЕРАЦИИ\\РЕЖИМ КВИТОВКИ",
                     V_INTEGER, KvitMode, stat);
  end;
  if (stat)
    fx_error("Ошибка при получении значений реестра");
    return false;
  end;
  if (bAND(TranModeReq, bNOT(FX_TRAN_BEFOREPAYMENT)))
    fx_error("Указанный режим исполнения требований не реализован");
    return false;
  end;
  if (KvitMode == FX_KVIT_NOTEXEC)
    fx_error("Квитовка требований не предусмотрена");
    return false;
  end;
  if (not FX_KvitPayments())
    return false;
  end;
  
//  if (not FX_GetRequirementAccount(fd, TranModeReq, ReqAccount))
//    return false;
//  end;

  while (i < FactIDs.Size)
    paym = RsbPayment( FactIDs[i] );
    if ( paym.PaymentID != 0 )
      if (paym.PayerFIID != CurReq)
        fx_error("Неверная валюта платежа");
        return false;
      end;
      if( MaxiDate < paym.ValueDate ) 
          MaxiDate = paym.ValueDate;
      end;    
    end;
    i = i + 1;
  end; 

  paym = FxRsbPayment( PlanIDs[0]);
  MaxiDate = paym.ValueDate;
  
  i = 0;
  while (i < FactIDs.Size)
    paym = FxRsbPayment( FactIDs[i] );
    if ( paym.PaymentID != 0 )
      if (paym.FuturePayerAccount != ReqAccount)
        if(not paym.Bookpass( String("Квитовка платежей"),
          ReqAccount,                          // CreditAccount
          paym.ReceiverFIID,                   // CreditAccountFIID
          KvitAmounts[i],                      // MinorAmount
          paym.PayerFIID,                      // MinorFIID
          null,
          null, null,
          MaxiDate
        ))
          return false;
        end;
      end;
    end;
    i = i + 1;
  end;

  return true;
END;
FX_NameMacroFile = "fxpayreq.mac";
