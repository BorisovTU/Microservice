/*-------------------------------------------------------------------------
          Автоматизированная банковская система RS-Bank v5.1
                 Copyright (c) R-Style Software Lab

  Имя файла        : fxlb.mac

  Библиотека       : FOREX

  Описание         : константы и полезные функции

  Программист      : Kalashnikov Michael (KMV)

  Создан           : 29.11.2001
-------------------------------------------------------------------------*/
import CTInter, PaymInter, FIInter, RsbDataSet, osfile, "globals.mac";

VAR FX_NameMacroFile; /*Имя файла, породившего ошибку*/

      /*виды системных дат операции*/                          
const FX_OPERDATE_DEAL = 1,     /*дата заключения сделки*/
      FX_OPERDATE_PERIOD = 2,   /*дата очередного переноса прямой сделки по счетам срочности*/
      FX_OPERDATE_VAL = 3,      /*дата валютирования прямой сделки*/
      FX_OPERDATE_VAL_RQ = 4,   /*дата валютирования требования прямой сделки*/
      FX_OPERDATE_VAL_CM = 5,   /*дата валютирования обязательства прямой сделки*/
      FX_OPERDATE_PERIOD_REV = 6,/*дата очередного переноса обратной сделки по счетам срочности*/
      FX_OPERDATE_VAL_REV = 7,   /*дата валютирования обратной сделки*/
      FX_OPERDATE_VAL_RQ_REV = 8,/*дата валютирования требования обратной сделки*/
      FX_OPERDATE_VAL_CM_REV = 9,/*дата валютирования обязательства обратной сделки*/
      FX_OPERDATE_DEALCLOSE = 10,/*дата окончания сделки*/
      /*номера шагов в операциях*/
      FX_STEP_ACTACC = 10,          /*Актуализация счетов*/
      FX_STEP_DONONBALANCE = 20,    /*Вести учет сделки по внебалансу*/
      FX_STEP_SETNONBALANCE = 30,   /*Постановка сделки на внебалансовый учет*/
      FX_STEP_DOMOVEPERIODS = 40,   /*Планировать перенос сделки по срокам?*/
      FX_STEP_MOVEPERIODS = 50,     /*Перенос сделки по срокам*/
      FX_STEP_DOMOVEPERIODS2 = 60,  /*Планировать перенос сделки по срокам?*/
      FX_STEP_RESETNONBALANCE = 70, /*Снятие сделки с внебалансового учета*/
      FX_STEP_SETBALANCE = 80,      /*Постановка сделки на балансовый учет*/
      FX_STEP_EXECREQ = 90,         /*Исполнение требования по сделке*/
      FX_STEP_EXECCOM = 100,        /*Исполнение обязательства по сделке*/

      FX_STEP_DONONBALANCE_REV = 200,    /*Вести учет сделки по внебалансу (обратная сделка)*/
      FX_STEP_SETNONBALANCE_REV = 210,   /*Постановка сделки на внебалансовый учет (обратная сделка)*/
      FX_STEP_DOMOVEPERIODS_REV = 220,   /*Планировать перенос сделки по срокам? (обратная сделка)*/
      FX_STEP_MOVEPERIODS_REV = 230,     /*Перенос сделки по срокам (обратная сделка)*/
      FX_STEP_DOMOVEPERIODS2_REV = 240,  /*Планировать перенос сделки по срокам? (обратная сделка)*/
      FX_STEP_RESETNONBALANCE_REV = 250, /*Снятие сделки с внебалансового учета (обратная сделка)*/
      FX_STEP_SETBALANCE_REV = 260,      /*Постановка сделки на балансовый учет (обратная сделка)*/
      FX_STEP_EXECREQ_REV = 270,         /*Исполнение требования по сделке (обратная сделка)*/
      FX_STEP_EXECCOM_REV = 280,         /*Исполнение обязательства по сделке (обратная сделка)*/
 
      FX_STEP_AUTORIZE = 15,             /*Авторизация сделки*/
      FX_STEP_PAYREQ = 400,              /*Шаг цепочки погашение требований*/
      FX_STEP_PAYREQ_REV = 410,          /*Шаг цепочки погашение требований (обратная сделка)*/
      /*Справочник "Использование транзитных счетов в forex" (1300)*/
      FX_TRAN_NOTUSE = 0,                /*Не используется*/
      FX_TRAN_BEFOREPAYMENT = 1,          /*Провод позиции контрагента (до платежа)*/
      FX_TRAN_AFTERPAYMENT = 2,          /*Провод  на авизовый транзит (после платежа)*/
      FX_TRAN_BEFORANDAFTERPAYMENT = 3,  /*Провод до платежа и при квитовке*/
      /*Справочник "Режим квитовки в forex" (1301)*/
      FX_KVIT_NOTEXEC = 0,               /*Не выполняется*/
      FX_KVIT_REQ = 1,                   /*Для требований*/      
      FX_KVIT_COM = 2,                   /*Для обязательств*/
      FX_KVIT_REQANDCOM = 3,             /*Для требований и обязательств*/
      /*Справочник "Режим выполнения проводок по НОСТРО"*/
      FX_NOSTRO_ALLOWED = 0,             /*Разрешено*/
      FX_NOSTRO_NOTALLOWED = 1,          /*Не разрешено*/

      FX_PAYMENTS_GROUP_UNDEF    = 0, //Группа не определена
      FX_PAYMENTS_GROUP_EXTERNAL = 1,  //  Внешний
      FX_PAYMENTS_GROUP_BRANCH   = 2,  //  Межфилиальный
      FX_PAYMENTS_GROUP_INTERNAL = 2; //Внутренний платеж

      //SET_CHAR = "X",
     //UNSET_CHAR = "",
      //ALLFININSTR = -1,
      //ALLPARTY = -1;
/*----------------------------------------------------------------------------
    Печать ошибки
----------------------------------------------------------------------------*/
MACRO fx_error ()
  var i=0, parm, mes="";

  while (GetParm (i, parm) AND (ValType(parm) != V_UNDEF))
    mes = String(mes, parm);
    i = i + 1;
  end;
  if (ValType(FX_NameMacroFile) != V_UNDEF)
   if ({BPromUse})
      mes = String(mes);
   else 
      mes = String(FX_NameMacroFile, ": ", mes);
   end;
  end;
  msgbox (mes);
END;

/* Установка переменной, если она не определена
*/
MACRO FX_ByDefault(variable, value) 

  if (ValType(variable) == V_UNDEF) 
      setparm(0, value);
  end;

end;

// Отформатировать RSL-ную дату для SQL запроса
MACRO FX_ToDate(d: date) : string
    if (d == date(0, 0, 0))
        return " to_date('01.01.0001', 'DD.MM.YYYY') ";
    else
        return " to_date('" + d + "', 'DD.MM.YYYY') ";
    end;
END;

MACRO FX_IsSale(TypeDoc)
  if (Index(TypeDoc, "S"))
    return true;
  else
    return false;
  end;
END;

MACRO FX_GetPaymentPurpose(ForCom,      /*Для обязательства (иначе треб)*/
                           ForRev,      /*Для обратной сделки*/
                           IsSale)      /*Для сделки - продажи*/

    if (IsSale)             /*продаем*/
        if (ForRev)         /*в обратной сделке*/
            if (ForCom)     
                return CRi; /*ябязателства*/
            else            
                return BRi; /*требования*/
            end;
        else                /*в прямой сделке*/
            if (ForCom)     
                return BAi; /*ябязателства*/
            else            
                return CAi; /*требования*/
            end;
        end;
    else                    /*покупаем*/
        if (ForRev)         /*в обратной сделке*/
            if (ForCom)     
                return BRi; /*ябязателства*/
            else            
                return CRi; /*требования*/
            end;
        else                /*в прямой сделке*/
            if (ForCom)     
                return CAi; /*ябязателства*/
            else            
                return BAi; /*требования*/
            end;
        end;
    end;
END;

MACRO FX_IsPaymentCommitment(IsSale, Purpose)
  if (IsSale)
    if ((Purpose == BAi) OR (Purpose == CRi))
      return true;
    end;
  else
    if ((Purpose == CAi) OR (Purpose == BRi))
      return true;
    end;
  end;
  return false;
END;
      
MACRO FX_GetFinInstrParams( FIID, Ccy, ISO_Number, FI_Code )
var t_Ccy = "", t_ISO_Number = "", t_FI_Code = 0, ok = false,
    fi = TRsbDataSet("select t_Ccy, t_ISO_Number, t_FI_Code from dfininstr_dbt where t_FIID = " + FIID);

    if(fi.MoveNext())
       t_Ccy = fi.Ccy;
       t_ISO_Number = fi.ISO_Number;
       t_FI_Code = fi.FI_Code;
       ok = true;
    end;

    SetParm( 1, t_Ccy );
    SetParm( 2, t_ISO_Number );
    SetParm( 3, t_FI_Code );

    return ok;
END;

MACRO FXCMT_processPath( p_path )

var l_str, l_p, l_path = "";

   p_path = trim( p_path );
  
   if( substr( p_path, 1, 2 ) == ".." ) /* ссылка на вышестоящий каталог */
    p_path = substr( p_path, 3 );
  
    l_str  = getCWD;    
    l_p    = strbrk( l_str, "\\" );
    while( l_p != 0 )
     l_path = l_path + substr( l_str, 1, l_p - 1 ) + "\\";
     l_str  = substr( l_str, l_p + 1 );
     l_p    = strbrk( l_str, "\\" );
    end;
    return ( substr( l_path, 1, strlen( l_path ) - 1 ) + p_path );
  
   elif( substr( p_path, 1, 1 ) == "." ) /* ссылка на текущий каталог */
    return ( getCWD + substr( p_path, 2 ) );
   end;
  
   return p_path;
END;

MACRO FX_SetRegistryPath(RegistryPath, Path)
    var stat = 0;
   
    GetRegistryValue(RegistryPath, V_STRING, Path, stat);
    if(stat) 
       msgbox("Не задана настройка в реестре банка:|", RegistryPath);      
    else
       SetParm(1, Path);
    end;

    return stat;
END;

MACRO FX_Balance(dealID,rev)
var rsbQuery,
    querystr = "",
    Step;
   if (rev)
      Step = 260;
   else 
     Step = 80;
   end;
    querystr = "select doprstep_dbt.t_Number_Step from doprstep_dbt, doproper_dbt      "+
                "where (doprstep_dbt.t_ID_Operation = doproper_dbt.t_ID_Operation)      "+
                "and  (doproper_dbt.t_DocumentID = "+dealID+")                          "+
                "and (doprstep_dbt.t_number_step = "+Step+")                               "+
                "and (doprstep_dbt.t_isexecute = 'X')                                   ";
    rsbQuery = TRsbDataSet(querystr);
   if (rsbQuery.MoveNext())
       return 1;
   end;
   
   return 0;
end;

MACRO CheckTYPEACCOUNT(Account, symb)
    var ds;

    ds = TRsbDataSet("select * from daccount_dbt where (t_account = '" + Account + "')and(t_type_account like '%А%')");
    if (not ds.MoveNext())
        return false;
    end;

    return true;
END;

MACRO FX_CreateCashOrder(pmobj, TypeOrder)
  var CashOrder = NULL;

    if (TypeOrder == "p")
        CashOrder =  GenObject("RsbBBIncCashOrder", 0);
    else
        CashOrder =  GenObject("RsbBBOutCashOrder", 0);
    end;

    CashOrder.kind_operation     = 4001;
    CashOrder.status             = 1; //STAT_CASH_ORDER_POST
    CashOrder.oper               = pmobj.oper;
    CashOrder.connecttooper      = true;
    CashOrder.launchoper         = false;

    CashOrder.payment.dockind    = CashOrder.dockind;
    CashOrder.payment.purpose    = 14;//PM_PURP_CASHBAL
    CashOrder.payment.ground     = pmobj.ground;
    CashOrder.payment.basefiid   = pmobj.basefiid;
    CashOrder.payment.baseamount = pmobj.baseamount;
    CashOrder.payment.valuedate  = pmobj.valuedate;
    CashOrder.payment.numberpack = pmobj.numberpack;
    CashOrder.payment.PayerAmount = pmobj.PayerAmount;
    CashOrder.payment.ReceiverAmount = pmobj.ReceiverAmount;
    CashOrder.payment.SetPayerPI (PAYMENTS_GROUP_UNDEF, 
                                  pmobj.PayerBankID,
                                  pmobj.PayerBankCodeKind,
                                  pmobj.PayerBankCode,
                                  pmobj.PayerBankName,
                                  pmobj.PayerBankCorrAcc,
                                  pmobj.PayerFIID,
                                  1,
                                  pmobj.PayerAccount,
                                  pmobj.Payer,
                                  pmobj.PayerName,
                                  pmobj.PayerINN,
                                  pmobj.PayerCodeKind,
                                  "");

    CashOrder.payment.SetReceiverPI (PAYMENTS_GROUP_UNDEF, 
                                  pmobj.ReceiverBankID,
                                  pmobj.ReceiverBankCodeKind,
                                  pmobj.ReceiverBankCode,
                                  pmobj.ReceiverBankName,
                                  pmobj.ReceiverBankCorrAcc,
                                  pmobj.ReceiverFIID,
                                  1,
                                  pmobj.ReceiverAccount,
                                  pmobj.Receiver,
                                  pmobj.ReceiverName,
                                  pmobj.ReceiverINN,
                                  pmobj.ReceiverCodeKind,
                                  "");
    CashOrder.payment.Actuate();

    return true;
END;

