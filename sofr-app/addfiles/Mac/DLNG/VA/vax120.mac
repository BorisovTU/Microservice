/*
$Name:         vax120.mac
$Module:       Учтенные векселя
$Description:  Мена векселей. Шаг О.исполнение обязательств

            va-вексель
             x-операция мены векселей (bart)
           120-номер (соответствующий шагу)
*/

IMPORT VAInter, DealsInter,
       vaendor, vacateg, vaacc, va4each, vsbnrfd, vabart, vatickfd, vadepo, vamisc, vaprdec, vaprdeca,
       varsrvbk, vapaym, vaxutils, vainner, vaprdslib, vaovernvpi, vacar, vaobs;

PRIVATE VAR
           StepDate = {curdate},           /* Дата выполнения шага */
           DealDate = {curdate},           /* дата сделки */
           IsPayerInBai = false,           /* заполнен ли плательщик в платеже по активу? */
           VaGroups = null,                /* группы для счетов категории "Учтенные векселя" */
           WithDepositary = false,
           OurBannersInDepository = false,
           tickfd;

/* Проверка индоссаментного ряда для векселя.
*/
PRIVATE MACRO TestEndor(bnr, leg, tick, numOrd, lnk)
   return VA_TestEndor(bnr, tick, StepDate);
END;

/* Проверка индоссаментного ряда для векселей.
*/
PRIVATE MACRO TestEndorsements(tick)
var
    WithEndorsement = false, stat = 0;

    if(not VA_Check_WithEndorsement(@WithEndorsement))
       stat = 1;
    elif(not WithEndorsement)
       /* ничего не делаем */
    else
       stat = VA_ForEachBanner(tick, @TestEndor, VSORDLNK_K_SALE, null, "B");
    end;

    return (stat == 0);
END;

/* класс с информацией по группе с ФИ векселей
*/
PRIVATE CLASS FiidGrp (TheFIID, TheAccDbt, TheAcc, TheAmount, ThePayAmount)
var
   FIID, accDbt, acc, amount, payamount;

   FIID    = TheFiid;
   acc     = TheAcc;
   accDbt  = TheAccDbt;
   amount  = TheAmount;
   payamount = ThePayAmount;
END;

/* Класс: группы векселей по Fiid
*/
CLASS VaGroupsClass()
 var
  stat = 0,
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(fiid, AccDbt, acc, sum, paysum)
   ArrGrp[ArrGrp.size] = FiidGrp(fiid, AccDbt, acc, sum, paysum);
  END;

  PRIVATE MACRO find(Fiid, AccDbt, acc)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].FIID == Fiid) AND (ArrGrp[i].acc == acc) AND (ArrGrp[i].accDbt == accDbt))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, amount, payamount)
     ArrGrp[i].amount = ArrGrp[i].amount + amount;
     ArrGrp[i].payamount = ArrGrp[i].payamount + payamount;
  END;

  MACRO group(fiid, AccDbt, acc, sum, paysum)
   var i = find(fiid, AccDbt, acc);
     if(i == -1)
        newGrp(fiid, AccDbt, acc, sum, paysum);
     else
        add (i, sum, paysum);
     end;
  END;

  MACRO makeBookpass(tick)
    var
       i = 0, stat = 0, SumDbt = 0, fd, AccDbt,
       Purpose = "Списание балансовой стоимости векселей";

    while((stat == 0) AND (i < ArrGrp.size))
      if(ArrGrp[i].fiid == NATCUR)
         /* одновалютная проводка */
         stat = VA_Bookpass(ArrGrp[i].AccDbt, ArrGrp[i].acc, ArrGrp[i].amount, Purpose,
                        0, 0,               /* Платеж */
                        ArrGrp[i].fiid,
                        null, null, StepDate,
                        null, null, null, null, "18"
                       );
      else
         /* многовалютная проводка */
         SumDbt = ArrGrp[i].payamount;//VA_Convert(ArrGrp[i].amount, StepDate, ArrGrp[i].fiid, NATCUR);
         if(not VA_MBookpass(0,
                          NATCUR, ArrGrp[i].AccDbt, SumDbt,
                          ArrGrp[i].fiid, ArrGrp[i].acc, ArrGrp[i].amount,
                          Purpose,
                          null, null,
                          null, StepDate,
                          null, "18"))
            stat = VA_Err("Ошибка при выполнении проводки",
                          "|", Purpose);
         end;
      end;
      i = i + 1;
    end;
    return stat;
  END;

END;

/* Группирует векселя по валютам.
*/
PRIVATE MACRO GroupsByVa(bnr, leg, tick, numOrd, lnk, IncGroup)
   var fd, stat = 0, acc, AccDbt, Sum = 0, SumVN = 0, PaySum = 0, ВалУч, BalanceDate = date(0,0,0);
   record income(vsincome);

   fd = VSBannerFD (bnr, leg, tick.BofficeKind, tick);

   ВалУч = fd.ОпределитьВалютуУчета();

   if( not VA_GetAccount("Реализация, УВ", tickfd, AccDbt, MC_OPENACC_CREATE, NATCUR, null, null, StepDate))
      stat = 1;
   elif(not VA_GetAccount("Учтенные векселя", fd, acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
       stat = 1;
   else

       SumVN = БалансоваяСтоимостьВекселяВН(bnr.rec.BCID, StepDate);
       Sum   = БалансоваяСтоимостьВекселяВУ(bnr.rec.BCID, StepDate) + IncGroup.GetIncSummBalOverAcc(bnr.rec.BCID);

       PaySum = VA_Convert(Sum, StepDate, ВалУч, NATCUR);

       VaGroups.group(ВалУч, AccDbt, acc, Sum, PaySum);

       if( not VA_SaveIncomeSum(VSINCOMETYPE_ACCOUNTEDSUM, bnr.rec.BCID, VA_GetLastAccountedEnrolmentID(bnr.rec.BCID), date(StepDate), -SumVN, leg.rec.PFI, -Sum, ВалУч) )
         stat = VA_Err("Не удалось сохранить запись о списании балансовой стоимости в истории" );
       end;
   end;

   return stat;
END;

PRIVATE MACRO ВыполнитьПереоценкуНВПИВекселей(bnr, leg, tick, numOrd, lnk, IncGroup)
  var stat = 0;

  stat = ПереоценкаНВПИВекселя(bnr.rec.BCID, StepDate, IncGroup);

  return stat;
END;

/* Проводки: ИспОб
*/
PRIVATE MACRO BkpPerform(tick, fd, ID_Operation, ID_Step)
var
    stat = 0;
var IncGroup = VACollectIncome(StepDate);
var PrDsParm = VAPrDsParm(@IncGroup, ID_Operation, ID_Step, true);

    //if( not stat )
    //  stat = VA_ForEachBanner(tick, @ВыполнитьПереоценкуНВПИВекселей, VSORDLNK_K_SALE, PrDsParm.IncGroup);
    //end;

    if( stat == 0 )
      VaGroups = VaGroupsClass();
      stat = VA_ForEachBanner(tick, @GroupsByVa, VSORDLNK_K_SALE, PrDsParm.IncGroup, "BL");
    end;

    if(stat == 0)
        if( (fd.GetUrgencyType() != СделкаToday) and (fd.GetBartDiffSum())) /*сделка  не today и есть доплата*/
           VAR Ground,
               DtAcc, DtFIID, DtSum = 0, DtRole,
               CtAcc, CtFIID, CtSum = 0, CtRole;

           if( fd.IsBartDiffPayerOurBank() ) // доплата нашего банка

              Ground = "Доплата нашего банка";

              DtAcc  = "Реализация, УВ";
              DtFIID = NATCUR;
              DtSum  = VA_Convert(fd.GetBartDiffSum(), StepDate, fd.GetBartDiffSumFI(), DtFIID);

              CtAcc  = "+Форвард, расчеты";
              CtFIID = fd.GetDealPayFI();
              CtSum  = VA_Convert(fd.GetBartDiffSum(), StepDate, fd.GetBartDiffSumFI(), CtFIID);
              CtRole = FIROLE_FICOM;

           else

              Ground = "Доплата контрагента";

              DtAcc   = "-Форвард, расчеты";
              DtFIID  = fd.GetDealPayFI();
              DtSum   = VA_Convert(fd.GetBartDiffSum(), StepDate, fd.GetBartDiffSumFI(), DtFIID);
              DtRole  = FIROLE_FIREQ;

              CtAcc  = "Реализация, УВ";
              CtFIID = NATCUR;
              CtSum  = VA_Convert(fd.GetBartDiffSum(), StepDate, fd.GetBartDiffSumFI(), CtFIID);
           end;

           if( (not VA_GetAccount( DtAcc, fd, DtAcc, MC_OPENACC_CREATE, DtFIID, DtRole, null, StepDate) ) OR
               (not VA_GetAccount( CtAcc, fd, CtAcc, MC_OPENACC_CREATE, CtFIID, DtRole, null, StepDate) )
             )
               stat = 1;
           end;

           if( stat == 0 )
              if( not VA_MBookpass(0,
                                   DtFIID, DtAcc, DtSum,
                                   CtFIID, CtAcc, CtSum,
                                   Ground,
                                   NULL, NULL,
                                   null, StepDate) )
                stat = 1;
              end;
           end;
        end;
    end;

    if(stat == 0)
      stat = VaGroups.makeBookpass(tick, fd);
    end;

    if( stat == 0 )
      stat = VA_ForEachBanner(tick, @ВыполнитьДоначислениеОднойЦБ, VSORDLNK_K_SALE, PrDsParm, "BL");
    end;

    if( stat == 0 )
      stat = VA_ForEachBanner(tick, @СписаниеПроцентовИДисконтаСРеализации, VSORDLNK_K_SALE, PrDsParm.IncGroup, "BL");
    end;

    return (stat == 0);
END;

/* Изменение статуса векселя в значение "введен".
*/
PRIVATE MACRO SetABCStatToAccount(bnr, leg, tick, numOrd, lnk)
   var stat = 0;
   var NewABCStatus = VABANNER_STATUS_INPUT;

   if(tick.IsPartyClient == SET_CHAR)
     //если передаем клиенту-контрагнту, то статус остается "учтен", но зафиксировать смену нужно
     NewABCStatus = VABANNER_STATUS_ACCOUNT;
   end;

   if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "abcstatus", NewABCStatus))
     stat = VA_Err("Ошибка при определении первичного документа сделки");
   end;

   return stat;
END;

/* Установка статусов векселей (ABCStatus) в значение "введен".
*/
PRIVATE MACRO SetABCStatus(tick)
var
    stat = 0;

    stat = VA_ForEachBanner(tick, @SetABCStatToAccount, VSORDLNK_K_SALE, null, "B");

    return (stat == 0);
END;

/* Делай "раз"
   - проверка индоссаментного ряда.
   - проводки: ИспОб
   - установка статус векселя (ABCStatus) в значение "введен".
*/
PRIVATE MACRO Point1(tick, ID_Operation, ID_Step)
var
    stat = 0, fd;

    if(not VA_IsClient(tick))
      if(not TestEndorsements(tick))
        stat = 1;
      end;

      if((stat == 0) and not BkpPerform(tick, tickfd, ID_Operation, ID_Step))
        stat = 1;
      end;
    end;

    if(stat == 0)
      stat = УВ_СписаниеВекселейПоСделкеСВнебаланса(tick, StepDate);
    end;

    if((stat == 0) and not SetABCStatus(tick))
      stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "два".
     Формируем отложенные распоряжения в депозитарий.
*/
PRIVATE MACRO Point2(tick)
    var stat = 0;

    // если установлен признак работы с депозитарием
    // и если сделка собственная и включена настройка УВ В ДЕПОЗИТАРИИ или если сделка клиентская,
    // то формируем отложенные распоряжения
    if(WithDepositary and (VA_IsClient(tick) or OurBannersInDepository) and not IsPayerInBai and not VA_MakeOutDepoDrafts(tick))
        stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "три".
     Установить статус "закрыт" всем платежам по активу.
     Если init == true, делаем платежам Actuate,
     иначе - устанавливаем статус
*/
PRIVATE MACRO Point3(tick, init)
    if(init == true)
       return VA_ActuatePayms(tick, BAi, StepDate);
    else
       return VA_SetStatOfPayms(tick, BAi, PM_FINISHED, StepDate);
    end;
    return true;
END;

/* Запуск шага
   Алгоритм:
   1. Если в сделке не указан клиент, то:
   1.1 Для каждого передаваемогo векселя:
       Производится проверка наличия индоссамента по данной сделке:
       a. если последний индоссамент, дата которого не превышает дату
          поставки данной сделки, - бланковый, то проверка не выполняется,
       b. в индоссаменте по данной сделке в качестве индоссанта должен
          быть указан наш банк, а дата равна фактической дате поставки сделки,
        В случае обнаружения ошибки, выдается сообщение
        "Неверный индоссаментный ряд", и шаг не выполняется.

   1.2. Проводки: ИспОб

   2.   Для каждого передаваемого векселя:
              Установить статус векселей (ABCStatus) в значение $(введен).
              Примечание. В функции изменения статуса векселя необходимо
                          запретить установку того же статуса, что и текущее
                          значение. В таком случае следует формировать
                          ошибку "Неверный статус векселя <серия векселя>
                          № <номер векселя>".

   3. Если установлен признак работы с депозитарием
      и банк плательщика планового платежа по активу - наш банк
   3.1.  Сформировать отложенные распоряжения в депозитарий для передаваемых векселей.

   4. Установить статус "закрыт" всем платежам по активу.
*/
MACRO ExecuteStep(Buffer, dl_tick, DocKind, ID_Operation, ID_Step)
var
    stat = 0, FstBai = TBfile("pmpaym.dbt");
    record tick(dl_tick);

    SetBuff(tick, dl_tick);

    GetOprDate(DATE_BART_OLD, @StepDate);
    DealDate = tick.DealDate;

    if(StepDate > {curdate})
        stat = VA_Err("Преждевременное выполнение шага запрещено");
    end;

    if((stat == 0) and VA_Get1stPlanPaym(tick.BofficeKind, tick.DealID, BAi, FstBai))
        IsPayerInBai = (FstBai.rec.PayerBankID != {OurBank});
    end;

    if(stat == 0)
        tickfd = VATickFD(tick);
        if(tickfd == null)
            stat = 1;
        end;
    end;

    if((stat == 0) and not Point3(tick, true)) // Актуализировать платежи
        stat = 1;
    end;

    if((stat == 0) and not VA_WorkWithDepositary(@WithDepositary))
        stat = 1;
    end;

    if((stat == 0) and not VA_OurBannersInDepository(@OurBannersInDepository))
        stat = 1;
    end;

    if((stat == 0) and not Point1(tick, ID_Operation, ID_Step)) // делай "раз"
        stat = 1;
    end;

    if((stat == 0) and not Point2(tick)) // делай "два"
        stat = 1;
    end;

    if((stat == 0) and not Point3(tick, false)) // делай "три"
        stat = 1;
    end;

    if((stat == 0)
    and not VA_IsBarterF(tick.DealType)
    and not VA_InnerFI(tick, StepDate, VA_GRNUM_SEXCH_VAVA_EENG, BAi, УВПередачаЦБМена)) // проводки внутреннего учета УВУВ
        stat = 1;
    end;

    if((stat == 0)
    and VA_IsBarterF(tick.DealType)
    and not VA_InnerFI(tick, StepDate, VA_GRNUM_SEXCH_VAOV_EENG, BAi, УВПоставкаЦБ)) // проводки внутреннего учета УВCВ
        stat = 1;
    end;

    if(stat == 0)
        stat = VA_WriteOffReserve_Veksel(tick, StepDate); // Списание резерва по векселям
    end;

    if(stat == 0)
        stat = VA_ClosePcAccounts(tick, StepDate, VSORDLNK_K_SALE);
    end;

    return stat;
END;

/* Функция печати распоряжений
*/
PRIVATE MACRO PrintDec(ManPr, ID_Operation, ID_Step)
VAR CDate;

    if((NOT (ManPr > 0)) AND (NOT (AutoPrint())))
        return FALSE;
    end;

    CDate = GetPlanDate(ID_Operation, ID_Step);

    InitDecType(DecType);
    InitDecPurp(DecPurp);
    InitOpType(OpType);

    record dl_t (dl_tick);

/* Attributs begin */
    if (NOT ПолучитьСделку(ID_Operation, dl_t))
        return FALSE;
    end;

    СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[7], dl_t, "OF12.dot", DecType[11], DecPurp[6], ID_Operation, ID_Step);

    СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[7], dl_t, "OF13.dot", DecType[13], DecPurp[18], ID_Operation, ID_Step);

/* Attributs end */

/* Attributs begin 2 */

//    #64276
//    СформироватьРаспоряжениеВДепозитарий(CDate, "мена векселей", dl_t, DecType[1], "OF2.dot", МенаПринимаемые);

    СформироватьРаспоряжениеВДепозитарий(CDate, OpType[7], dl_t, DecType[2], "OF2.dot", МенаПередаваемые);
/* Attributs end 2 */

    return TRUE;
END;

/* Макрос постобработки
*/
MACRO PostStep (
                CommitOrRollback, /*1-выполнение шага,2 -откат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    if (errTrn OR (CommitOrRollback==2))
        /* Произошла ошибка или происходит откат */
        return;
    end;

    PrintDec(AUTO_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    return 1;

END;

/* Макрос печати
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    PrintDec(MAN_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    exit(1) ;

END;

