/*
$Name:         vas120.mac
$Module:       Учтенные векселя
$Description:  Продажа векселей. Шаг О.исполнение обязательств

            va-вексель
             s-операция продажи векселей (sale)
           120-номер (соответствующий шагу)
*/

IMPORT RsbDataSet, DealsInter, FIInter, PaymInter, VAInter,
       vaendor, vsbnrfd, vacateg, valib, va4each, vasale, vatickfd, vaacc, vadepo, vamisc, vaprdec, vaprdeca,
       varsrvbk, vapaym,vadecres, vainner, vaovernvpi, vacar, vaobs;

PRIVATE VAR
           VaGroups = null,                /* группы для счетов категории "Учтенные векселя" */
           FiidGroups = null,              /* группы для ФИ векселей */
           ВалРасчетов = NATCUR,
           FstAct = TBfile("pmpaym.dbt"),  /* первый платеж по активу сделки */
           StepDate = {curdate},           /* Дата выполнения шага */
           WithDepositary = false,
           OurBannersInDepository = false,
           COM_role,                       /* роль счета */
           ActPurp;

PRIVATE CONST STR_OVERDUE_PURPOSE = String("Погашение просроч. задолженности по поставке ц/б");

/* Проверка индоссаментного ряда для векселя.
*/
PRIVATE MACRO TestEndor(bnr, leg, tick, numOrd, lnk)
   return VA_TestEndor(bnr, tick, StepDate);
END;

/* Проверка индоссаментного ряда для векселей.
*/
PRIVATE MACRO TestEndorsements(tick)
var
    WithEndorsement = false, stat = 0;

    if(not VA_Check_WithEndorsement(@WithEndorsement))
       stat = 1;
    elif(not WithEndorsement)
       /* ничего не делаем */
    else
       stat = VA_ForEachBanner(tick, @TestEndor, VSORDLNK_K_SALE, null, "B");
    end;

    return (stat == 0);
END;

/* класс с информацией по группе "Учтенные векселя"
*/
PRIVATE CLASS VaGrp (TheFiid, TheAcc, TheAmountDbt, TheAmountCrd)
var
   FIID, acc, amountDbt, amountCrd;

   FIID       = TheFiid;
   acc        = TheAcc;
   amountDbt  = TheAmountDbt;
   amountCrd  = TheAmountCrd;

END;

/* Класс: группы векселей по "Учтенным векселям"
*/
CLASS VaGroupsClass ()
 var
  stat = 0,
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(fiid, acc, amountDbt, amountCrd)
   ArrGrp[ArrGrp.size] = VaGrp(fiid, acc, amountDbt, amountCrd);
  END;

  PRIVATE MACRO find(Fiid, acc)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].FIID == Fiid) AND (ArrGrp[i].acc == acc))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, amountDbt, amountCrd)
     ArrGrp[i].amountDbt  = ArrGrp[i].amountDbt + amountDbt;
     ArrGrp[i].amountCrd  = ArrGrp[i].amountCrd + amountCrd;
  END;

  MACRO group(Fiid, acc, amountDbt, amountCrd)
   var i = find(Fiid, acc);
     if(i == -1)
        newGrp(Fiid, acc, amountDbt, amountCrd);
     else
        add (i, amountDbt, amountCrd);
     end;
  END;

  PRIVATE MACRO MBP_Дебет_Учтенные(fd, СчетДебет, Purpose, i)

      if(ArrGrp[i].fiid == ВалРасчетов)
         /* одновалютная проводка */
         stat = VA_Bookpass(СчетДебет, ArrGrp[i].acc,
                        ArrGrp[i].amountCrd,
                        Purpose,
                        0, 0,               /* Платеж */
                        ВалРасчетов,
                        null, null, StepDate
                        );
      else
         /* многовалютная проводка */
         if(not VA_MBookpass(0,
                          ВалРасчетов, СчетДебет, ArrGrp[i].amountDbt,
                          ArrGrp[i].fiid, ArrGrp[i].acc, ArrGrp[i].amountCrd,
                          Purpose,
                          null, null,
                          null, StepDate))
            stat = VA_Err("Ошибка при выполнении проводки",
                          "|по конверсии");
         end;
      end;
  END;

  MACRO makeBookpass(fd)
    var
       i = 0, stat = 0, Purpose = "",
       СчетДебет;

    if(VA_IsPaymentWasOverdue(FstAct.rec.PaymStatus, FstAct.rec.PaymentID)) // была просрочка
       Purpose = STR_OVERDUE_PURPOSE;
       if (not VA_GetAccount("Обяз. с н.с.", fd, СчетДебет, MC_OPENACC_CREATE, null, COM_role, null, StepDate))
          stat = 1;
       end;
    else
       Purpose = String("Исполнение обязательств по поставке векселей по сделке продажи №" + fd.GetTick().DealCode + " от " + fd.GetTick().DealDate);
       if(not VA_GetAccount("-Форвард, расчеты", fd, СчетДебет, MC_OPENACC_CREATE, null, COM_role, null, StepDate))
         stat = 1;
       end;
    end;

    while((stat == 0) AND (i < ArrGrp.size))

      MBP_Дебет_Учтенные(fd, СчетДебет, Purpose, i);

      i = i + 1;
    end;
    return stat;
  END;

END;

PRIVATE MACRO DoGroupsByVa(bnr, leg, tick, lnk, PrevDate, PrevSum, PrevFI)
   var stat = 0, fd, tickfd, acc, SumDbt, SumCrd, AccMode = null;
   var ДатаОплаты;
   var ConvDate = date(0,0,0);
   var СС_ПФИ = УВ_ПолучитьУчтеннуюСС(bnr.rec.BCID, tick.DealID, StepDate);

   fd = VSBannerFD(bnr, leg, tick.BofficeKind, tick);
   tickfd = VATickFD(tick);

   if(not VA_GetAccount("Реализация, УВ", tickfd, acc, MC_OPENACC_CREATE, NATCUR, null, null, StepDate))
      stat = 1;
   else
      GetOprDate( DATE_SALE_PAY, @ДатаОплаты );
      ConvDate = StepDate;

      if(ДатаОплаты < StepDate) //оплата уже выполнена
        ConvDate = ДатаОплаты;
      end;

      if(PrevFI == ВалРасчетов)
         SumDbt = PrevSum;
      else
         SumDbt = VA_Convert(PrevSum, ConvDate, PrevFI, ВалРасчетов);
      end;
      
      if(VA_IsPaymentWasOverdue(FstAct.rec.PaymStatus, FstAct.rec.PaymentID))
         SumCrd = VA_Convert(SumDbt, StepDate, ВалРасчетов, NATCUR);
      else
         SumCrd = VA_Convert(SumDbt, StepDate, ВалРасчетов, NATCUR) + СС_ПФИ;
      end;
      SumDbt = SumDbt + VA_Convert(СС_ПФИ, StepDate, NATCUR, ВалРасчетов);

      VaGroups.group(NATCUR, acc, SumDbt, SumCrd);
   end;

   return stat;
END;

/* Группирует векселя по однородным группам счетов категории "Учтенные векселя".
*/
PRIVATE MACRO GroupsByVa(bnr, leg, tick, numOrd, lnk)
var
   PrevBuy, PrevSum, PrevFI, BalanceDate, DealType, DealCode;

   // Ищем дату постановки векселя на баланс
   if(not VA_GetBalanceDate(bnr.rec.BCID, StepDate, @BalanceDate, @PrevBuy, @PrevSum, @PrevFI, @DealType, @DealCode))
      return VA_Err("Не найдена сделка покупки векселя|серия "+bnr.rec.BCSeries+" номер ", trim(bnr.rec.BCNumber));
   end;

   return DoGroupsByVa(bnr, leg, tick, lnk, StepDate, lnk.rec.BCCost, lnk.rec.BCCFI);
END;

/* Проводки: ИспОб
*/
PRIVATE MACRO BkpPerform(tick)
var
    stat = 0, fd;

    VaGroups = VaGroupsClass();
    stat = VA_ForEachBanner(tick, @GroupsByVa, VSORDLNK_K_SALE, null, "BL");
    if(stat == 0)
       if((fd = VATickFD(tick)) == null)
         stat = VA_Err("Ошибка при определении первичного документа сделки");
         return (stat == 0);
       else
//Simanov         if(fd.GetUrgencyType() != СделкаToday)
           stat = VaGroups.makeBookpass(fd);
//         end;
       end;
    end;

    return (stat == 0);
END;

/* Изменение статуса и состояния векселя.
*/
PRIVATE MACRO SetABCStatToAccount(bnr, leg, tick, numOrd, lnk)
   var stat = 0;
   var NewABCStatus = VABANNER_STATUS_INPUT;

   if(tick.IsPartyClient == SET_CHAR)
     //если продаем клиенту-контрагнту, то статус остается "учтен", но зафиксировать смену нужно
     NewABCStatus = VABANNER_STATUS_ACCOUNT;
   end;

   if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "abcstatus", NewABCStatus))
     stat = VA_Err("Ошибка при определении первичного документа сделки");
   end;

   if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "addbcstate", "Р"))
     stat = VA_Err("Ошибка при определении первичного документа сделки");
   end;

   return stat;
END;

/* Установка статусов и состояний векселей.
*/
PRIVATE MACRO SetABCStatus(tick)
var
    stat = 0;

    stat = VA_ForEachBanner(tick, @SetABCStatToAccount, VSORDLNK_K_SALE, null, "B");

    return (stat == 0);
END;

/* Делай "раз"
   - проверка индоссаментного ряда.
   - проводки: ИспОб
   - установка статус векселя (ABCStatus) в значение "введен".
*/
PRIVATE MACRO Point1(tick)
var
    stat = 0;

    if(NOT VA_IsClient(tick))
      if((tick.AvoirKind == AVOIRISSKIND_BILL) and (not TestEndorsements(tick)))
        stat = 1;
      //elif(ПереоценкаНВПИпоПоставкеПриПродаже(tick, ВалРасчетов, StepDate, COM_role))
      //  stat = 1;
      elif(not BkpPerform(tick))
        stat = 1;
      end;
    end;

    if((stat == 0) AND (not SetABCStatus(tick)))
      stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "два".
     Формируем отложенные распоряжения в депозитарий.
*/
PRIVATE MACRO Point2(tick)
    var stat = 0;

    // если установлен признак работы с депозитарием
    // и если сделка собственная и включена настройка УВ В ДЕПОЗИТАРИИ или если сделка клиентская,
    // то формируем отложенные распоряжения
    if(WithDepositary and (VA_IsClient(tick) or OurBannersInDepository) and not VA_MakeOutDepoDrafts(tick, ActPurp))
        stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "три".
     Установить статус "закрыт" всем платежам по активу.
     Если init == true, делаем платежам Actuate,
     иначе - устанавливаем статус
*/
PRIVATE MACRO Point3(tick, init)
    var stat = false;
    if(init == true)
       stat = VA_ActuatePayms(tick, CAi, StepDate);
       if(stat)
         stat = VA_ActuatePayms(tick, ActPurp, StepDate);
       end;
    else
       stat = VA_SetStatOfPayms(tick, ActPurp, PM_FINISHED, StepDate);
    end;

    return stat;
END;

PRIVATE MACRO ПроводкиВнутреннегоУчета(tick, НазначениеПлатежа)
    var Основание;

     if (VA_IsSale(tick.DealType))
        Основание = VA_GRNUM_SSEL_EENG;
     else
        MsgBox("Не найдено основание проводки внутреннего учета для сделки: ",tick.DealCode);
        return false;
     end;

     if(not VA_InnerFI(tick, StepDate, Основание, НазначениеПлатежа, УВПоставкаЦБ)) /* проводка внутреннего учета */
       return false;
     end;

    return true;
END;

/* Запуск шага
   Алгоритм:
   1. Если в сделке не указан клиент, то:
   1.1 Для каждого векселя:
       Производится проверка наличия индоссамента по данной сделке:
       a. если последний индоссамент, дата которого не превышает дату
          поставки данной сделки, - бланковый, то проверка не выполняется,
       b. в индоссаменте по данной сделке в качестве индоссанта должен
          быть указан наш банк, а дата равна фактической дате поставки сделки,
        В случае обнаружения ошибки, выдается сообщение
        "Неверный индоссаментный ряд", и шаг не выполняется.

   1.2. Если сброшен признак работы с депозитарием, то  - проводки "ПродЦ/б".

   1.3.  Проводки: ИспОб

   2.   Для каждого векселя:
              Установить статус векселей (ABCStatus) в значение $(введен).
              Примечание. В функции изменения статуса векселя необходимо
                          запретить установку того же статуса, что и текущее
                          значение. В таком случае следует формировать
                          ошибку "Неверный статус векселя <серия векселя>
                          № <номер векселя>".

   3. Если установлен признак работы с депозитарием
   3.1.  Сформировать отложенные распоряжения в депозитарий (см. проект Кобякова
               "Импорт в депозитарий").

   4. Установить статус "закрыт" всем платежам по активу.
*/
MACRO ExecuteStep(Buffer, dl_tick, DocKind, ID_Operation)
    var base_paym_kind, PDate, stat = 0;

    record tick( dl_tick );
    SetBuff( tick, dl_tick );

    if(not VA_GetPayFIID(tick, CAi, @ВалРасчетов)) // получить валюту расчетов
        stat = VA_Err("Ошибка при получении валюты расчетов");
    end;

    if(stat == 0)
        COM_role = FIROLE_FICOM;
        GetOprDate( DATE_SALE_SUPPLY, @StepDate );
        ActPurp = BAi;
        base_paym_kind = CAi;
    end;

    if((stat == 0) and (StepDate > {curdate}))
        stat = VA_Err("Преждевременное выполнение шага запрещено.");
    end;

    if((stat == 0) and (tick.flag2 == "X") and not VA_GetPerformDate("Ч", ID_operation, @PDate))
        stat = VA_Err("Не выполнен шаг оформления договора");
    end;

    if(stat == 0)
        VA_Get1stPlanPaym(tick.BofficeKind, tick.DealID, ActPurp, FstAct);
    end;

    if((stat == 0) and not Point3(tick, true)) // Актуализировать платежи
        stat = 1;
    end;

    if((stat == 0) and not VA_WorkWithDepositary(@WithDepositary))
        stat = 1;
    end;

    if((stat == 0) and not VA_OurBannersInDepository(@OurBannersInDepository))
        stat = 1;
    end;

    if((stat == 0) and not Point1(tick)) // делай "раз"
        stat = 1;
    end;

    if((stat == 0) and not Point2(tick)) // делай "два"
        stat = 1;
    end;

    if((stat == 0) and not Point3(tick, false)) // делай "три"
        stat = 1;
    end;

    /*if((stat == 0) and (VA_WriteOffReserve_Veksel(tick, StepDate) != 0)) // Списание резерва по векселям
        stat = VA_Err("Ошибка при списании резерва");
    end;*/

    if((stat == 0) and not ПроводкиВнутреннегоУчета(tick, ActPurp))
        stat = 1;
    end;

    return stat;
END;

/* Функция печати распоряжений
*/
PRIVATE MACRO PrintDec(ManPr, ID_Operation, ID_Step)
VAR CDate,
    StrType;

    if((NOT (ManPr > 0)) AND (NOT (AutoPrint())))
        return FALSE;
    end;

    CDate = GetPlanDate(ID_Operation, ID_Step);

    InitDecType(DecType);
    InitDecPurp(DecPurp);
    InitOpType(OpType);

    record dl_t (dl_tick);

/* Attributs begin */
    if (NOT ПолучитьСделку(ID_Operation, dl_t))
    return FALSE;
    end;

    СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[1], dl_t, "OF11.dot", DecType[11], DecPurp[6], ID_Operation, ID_Step);
/* Attributs end */

/* Attributs begin 2 */

    GetDepoKindStr(dl_t, @StrType);
    СформироватьРаспоряжениеВДепозитарий(CDate, OpType[1], dl_t, StrType, "OF2.dot");
/* Attributs end 2 */

/*  Печать распоряжения на коррекцию резерва */
    VA_PrintDecReserv(dl_t.DealID,  dl_t.BofficeKind, true);

    return TRUE;
END;

/* Макрос постобработки
*/
MACRO PostStep (
                CommitOrRollback, /*1-выполнение шага,2 -откат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    if (errTrn OR (CommitOrRollback==2))
        /* Произошла ошибка или происходит откат */
        return;
    end;

    PrintDec(AUTO_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    return 1;
END;

/* Макрос печати
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    PrintDec(MAN_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);
    exit(1) ;

END;
