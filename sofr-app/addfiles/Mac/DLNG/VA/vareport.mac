/*
$Name:         vareport.mac
$Module:       Учтенные векселя
$Description:  Общие функции отчетов
*/

IMPORT Календарь, valib, globals, SPInter, dlreport, or_rep_h, dlmisc, VAInter;

CLASS (CMakeReport) CVAMakeReport
    (_HeaderStr:string, _SepStr:string, _CountStrOnPage:integer, _CurStr:integer)

    MACRO AddString(str, mode)
        AddPrintCell(str, GetHeaderWidth(), null, mode, REP_ELEM_STR);
        AddStr();
    END;

    MACRO Print(mode, do_print, win_name, err_mes)
        VA_ByDefault(do_print, true);
        VA_ByDefault(err_mes, "Нет данных для формирования отчета");

        if (do_print)
            if  (mode == VARM_TEXT)
                PrintRep();
            elif(mode == VARM_EXCEL)
                PrintWinRep(win_name);
                ShowWinRep();
            end;
        else
            if  (mode == VARM_TEXT)
                println(err_mes);
            elif(mode == VARM_EXCEL)
                msgbox(err_mes);
            end;
        end;
    END;

    MACRO LoadTemplateAndCSV()
        // заглушка
    END;

    MACRO saveCsvInTemplate()
        // заглушка
    END;

    MACRO printFooterTemplate()
        // заглушка
    END;

    InitCMakeReport(_HeaderStr, _SepStr, _CountStrOnPage, _CurStr);
END;

CLASS CVAPrintWinRep()
    private var printEngine;

    private var csvFile;
    private var csvTable;
    private var fName;

    MACRO printFooterTemplate(sheetName : String)
        var PostBoss, NameBoss, PostBook, NameBook, Executer = DepoExecuter({oper});

        if({Name_Boss} and not {Name_Book})
            PostBoss = {Name_Boss};
        else
            PostBoss = "Директор банка";
        end;

        NameBoss = {FIO_Boss};

        if({Name_Book})
            PostBook = {Name_Book};
        else
            PostBook = "Главный бухгалтер банка"
        end;

        NameBook = {FIO_Book};

        printEngine.SetValue_NameCell("bossNameSign", PostBoss + " _____________ " + NameBoss);
        printEngine.SetValue_NameCell("bossSignHint", MkStr(" ", strlen(PostBoss)) + "    подпись", null, false);
        printEngine.SetValue_NameCell("bookNameSign", PostBook + " _____________ " + NameBook);
        printEngine.SetValue_NameCell("bookSignHint", MkStr(" ", strlen(PostBook)) + "    подпись", null, false);
        printEngine.SetValue_NameCell("executorNameSign", Executer.Post + " _____________ " + Executer.Name);
        printEngine.SetValue_NameCell("executorSignHint", MkStr(" ", strlen(Executer.Post))+"    подпись", null, false);
        printEngine.SetValue_NameCell("phone", "Телефон: " + Executer.PhoneNumber);
        printEngine.SetValue_NameCell("execDate", DL_DateToStr(Date()));

        printEngine.CopyAllSheetInTotalBook(null, false, "templateFooter", 0, sheetName);
        printEngine.Close();
    END;

    MACRO PrintStandartFooter(CellPrefix : String)
        var PostBoss, PostBook, Executer = DepoExecuter({oper});

        if({Name_Boss} and not {Name_Book})
            PostBoss = {Name_Boss};
        else
            PostBoss = "Директор банка";
        end;

        if({Name_Book})
            PostBook = {Name_Book};
        else
            PostBook = "Главный бухгалтер банка"
        end;

        printEngine.SetValue_NameCell( CellPrefix+"ДатаСоставления" , DL_DateToStr(Date()));
        printEngine.SetValue_NameCell( CellPrefix+"ДолжностьДиректора" , PostBoss + " _____________ " );
        printEngine.SetValue_NameCell( CellPrefix+"Директор" ,        {FIO_Boss});
        printEngine.SetValue_NameCell( CellPrefix+"ДолжностьГлавБух" , PostBook + " _____________ " );
        printEngine.SetValue_NameCell( CellPrefix+"ГлавБух" ,         {FIO_Book});
        printEngine.SetValue_NameCell( CellPrefix+"ДолжностьОперациониста", "Исполнитель: " + " _____________ " );
        printEngine.SetValue_NameCell( CellPrefix+"Операционист",     Executer.Name );
        printEngine.SetValue_NameCell( CellPrefix+"Телефон",          "Телефон: " + Executer.PhoneNumber);
    END; 

    MACRO saveCsvInTemplate(sheetName : String, isNeedCloseTemplate : Bool)
        csvFile.FileClose();
        csvTable.FillTabelFromCSV(csvFile.GetlsFileName());
        csvTable.EndTable();

        printEngine.CopyAllSheetInTotalBook(null, false, csvTable.GetTableRange(), 0, sheetName);

        if (isNeedCloseTemplate)
            printEngine.Close();
        end;
    END;

    macro AfterAutoFill( pThis:variant, CSVFileName:STRING, Address_AutoFill:STRING )
        var addrDiapazon = csvTable.AddressDiapazon;
        printEngine.SetDiapazon(addrDiapazon.GetNumbRow() - 1, 0, addrDiapazon.GetNumbRow() - 1, addrDiapazon.GetNumbColumn() - 1);
        // только нижняя граница
        printEngine.SetBorder(0, 0, 1, 0);
    end;

    MACRO LoadTemplateAndCSV(templateTableAlias : String, templateTableHeaderAlias : String, templateName : String, prefixForCsvfile : String, isNeedDrawBottomBorder : Bool)
        printEngine.OpenTemplate(templateName, true);
        printEngine.SheetChange(1);

        csvTable = printEngine.RegisterTable(templateTableAlias, templateTableHeaderAlias, true);
        if (isNeedDrawBottomBorder)
            csvTable.Set_Func_AfterAutoFill(  R2M( this, "AfterAutoFill") );
        end;

        csvFile  = C_CSVFile();

        if (printEngine.UsePoi())
            csvFile.SetLimitRow(FLUSH_COUNT_XLSX);
        end;

        fName = csvFile.CreateFullFileName(prefixForCsvfile + "_" + templateName + "_csv.txt");
        csvFile.FileOpen(fName, true);
    END;

    MACRO getPrintEngine()
        return printEngine;
    END;

    MACRO AddPrintCell(data)
        csvFile.AddCell(data);
    END;

    MACRO AddStr()
        csvFile.AddRow();
    END;

    MACRO Print(mode, do_print, win_name, err_mes)
        VA_ByDefault(do_print, true);
        VA_ByDefault(err_mes, "Нет данных для формирования отчета");

        if (do_print)
            printEngine.SaveTotalBook(win_name);
        else
            msgbox(err_mes);
        end;
    END;

    MACRO GetWidthBeforeCol()
        return 0;
    END;

    MACRO GetColWidthTable()
        return 0;
    END;

    MACRO constructorCVAPrintWinRep()
        printEngine = CTemplateXLS(NULL, NULL, NULL, NULL, NULL, NULL, true, false);

        if(printEngine.UsePoi())
            printEngine.SetXLSXFormat();
        end;

        printEngine.CreateTotalBook();
    END;

    constructorCVAPrintWinRep();
END;

/****************************************************************************/
/* Печать стандартной подошвы                                               */
/****************************************************************************/
PRIVATE macro L_Z( num, len )
    var str1, len1;
    str1 = trim( string( num ) );
    len1 = strlen( str1 );
    if ( len1 >= len ) return str1;
    else  return  mkstr("0", len-len1 ) + str1;
    end;
end;

macro date_as_str( _date )
    return date_as_string( 1, _date );
end;

/* Дата + 1 год */
MACRO ПрибавитьГод(dateC)
VAR d, m, y;
    DateSplit(dateC, d, m, y);
    if((mod(y, 4) == 0) and (mod(y, 100) != 0)) // Год високосный
       return DateAfterCalenDays(dateC, 366);  // должно получиться 366 дней!
    end;
    return DateAfterCalenDays(dateC, 365);
END;

/* Вычисление отчетной даты - первый день месяца, следующего за отчетным периодом. */
MACRO ОтчетнаяДата(month, year, dateB:@variant)
VAR ok = TRUE,
NumQuartal;
    if((month < 1) OR (month > 16))
        ok = FALSE;
    elif(month < 12) // месяц
        dateB = date(1, month+1, int(year));
    elif(month == 12)//декабрь
        dateB = date(1, 1, int(year)+1);
    elif(month < 16) // квартал
        NumQuartal = month - 12;
        dateB = Date(1, NumQuartal * 3 + 1, int(year));
    elif(month == 16)// IV квартал
        dateB = Date(1, 1, int(year)+1);
    end;
    return ok;
END;


// вывод протокола ошибок
MACRO VA_PrintProtokol(ErrorArray)
var Counter = 0;
   if( ErrorArray.Size > 0 )
      [ ];
      [ ];
      [                         ПРОТОКОЛ ФОРМИРОВАНИЯ ОТЧЕТА];
      [                   (ошибки, возникшие при формировании отчета)];
      [ ];
      while( Counter < ErrorArray.Size )
         PrintLn( Counter+1 +". "+ ErrorArray(Counter) );
         Counter = Counter + 1;
      end;
      [ ];
      [ ];
   end;
end;

