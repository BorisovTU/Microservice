/*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 6.0                                          R-Style Software Lab

  File Name   : vapdepo.mac
  Операция    : Залог векселей
  Comment     : Отложенные распоряжения в депозитарий
└───────────────────────────────────────────────────────────────────────────*/
IMPORT CTInter, PaymInter, vadepo, vapawnutl, vamisc, vadpgrp;


PRIVATE VAR
           tarr_lnk = TArray,         /* Массив записей vsordlnk */
           FiidGroups = null;              /* группы для ФИ векселей */


/* класс с информацией по группе с ФИ векселей
*/
PRIVATE CLASS FiidGrp (bnr) 
var 
   FIID, count;

   FIID    = bnr.rec.FIID;
   count   = 1;

END;

/* Класс: группы векселей по Fiid
*/
CLASS FiidGroupsClassPawnBranch ()
 var 
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(bnr)
   ArrGrp[ArrGrp.size] = FiidGrp(bnr);
  END;

  MACRO find(FIID)
   var i = 0;
    while (i < ArrGrp.size)
      if(ArrGrp[i].FIID == FIID)
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;
  
  MACRO get_count(i)
     if(i < ArrGrp.size)
        return ArrGrp[i].count;
     end;
  END;

  PRIVATE MACRO add (i)
     ArrGrp[i].count = ArrGrp[i].count + 1;
  END;

  MACRO group(bnr)
   var i = find(bnr.rec.FIID);
     if(i == -1)
        newGrp(bnr);
     else
        add (i);
     end;
  END;

END;

/* Группирует векселя по валютам.
*/
PRIVATE MACRO GroupsByCur(bnr, leg, tick, numOrd, lnk)

   FiidGroups.group(bnr);

   return 0;
END;



/* 800 - Поручение на книжный перевод
   (перевод в раздел "Блокировано в залоге" счета депо нашего банка)
   Блокировка по счету получателя
*/
MACRO PawnFill800_Block50_70(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;       /* Тип счета отправителя по-умолчанию */
  Draft.DwPartyID    = {OurBank};

  if(tick.Flag1 == "")
     Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     Draft.BnPartyID    = {OurBank};
     Draft.Product = 6;  /* в залог - см. llvalues 1200 (содержание транзакции) */
     Draft.Block = OBJTYPE_DEPOACC_BLOCK_PLEDGE;
  else
     Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_MONEYKEEPER;
     Draft.BnAccCode    = "";
     Draft.BnPartyID    = {OurBank};
     Draft.Product = 10; /* в заклад - см. llvalues 1200 (содержание транзакции) */
     Draft.Block = OBJTYPE_DEPOACC_BLOCK_INDEPOSIT;
  end;
  return 0;
END;

/* 800 - Поручение на книжный перевод
   (возврат из раздела "Блокировано в залоге" счета депо нашего банка)
   Блокировка по счету отправителя
*/
MACRO PawnFill800_UnBlock70_50(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT; 
  Draft.BnPartyID    = {OurBank};

  if(tick.Flag1 == "")
     Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;      /* Тип счета отправителя по-умолчанию */
     Draft.DwPartyID    = {OurBank};
     Draft.Product = 7;  /* Разблокировка залога - см. llvalues 1200 (содержание транзакции) */
     Draft.UnBlock = OBJTYPE_DEPOACC_BLOCK_PLEDGE;
  else
     Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_MONEYKEEPER;      /* Тип счета отправителя по-умолчанию */
     Draft.DwAccCode    = "";
     Draft.DwPartyID    = {OurBank};
     Draft.Product = 11; /* Возврат залогодателю - см. llvalues 1200 (содержание транзакции) */
     Draft.UnBlock = OBJTYPE_DEPOACC_BLOCK_INDEPOSIT;
  end;
  return 0;
END;

/* 800 - Поручение на книжный перевод
   "Перевод в хранилище контрагента"
*/
MACRO PawnFill800_Block00_00(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;       /* Тип счета отправителя по-умолчанию */
  Draft.DwPartyID    = tick.PartyID;
  Draft.DwAccCode    = "";
  Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
  Draft.BnPartyID    = {OurBank};
  Draft.BnAccCode    = "";

  if(tick.Flag1 == "")
     Draft.Product = 6;  /* в залог - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.Product = 10; /* в заклад - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* 800 - Поручение на книжный перевод
   "Перевод в наше хранилище"
*/
MACRO PawnFill800_UnBlock00_00(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;       /* Тип счета отправителя по-умолчанию */
  Draft.DwPartyID    = {OurBank};
  Draft.DwAccCode    = "";
  Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
  Draft.BnPartyID    = tick.PartyID;
  Draft.BnAccCode    = "";

  if(tick.Flag1 == "")
     Draft.Product = 7;  /* Разблокировка залога - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.Product = 11; /* Возврат залогодателю - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* 845 - Списание ц/б с хранения
*/
MACRO PawnFill845__50_00(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
  Draft.DwPartyID    = {OurBank};
  Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
  Draft.BnPartyID    = {OurBank};

  if(tick.Flag1 == "")
     Draft.Product = 6;  /* в залог - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.Product = 10; /* в заклад - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* 840 - Прием ц/б на хранение 
*/
MACRO PawnFill840__00_50(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
  Draft.DwPartyID    = {OurBank};
  Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
  Draft.BnPartyID    = {OurBank};

  if(tick.Flag1 == "")
     Draft.Product = 7;  /* Разблокировка залога - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.Product = 11; /* Возврат залогодателю - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* Готовит фиктивный платеж по сделке
*/
PRIVATE MACRO FindOurPaym(tick, Purpose, FIID, fake_paym)
var
    paym = TBfile("pmpaym"), 
    Ok, DocID, DocKind, ttype, found = false;

    ttype = ValType(tick);
    if(ttype == V_GENOBJ)
      DocID   = tick.rec.DealID;
      DocKind = tick.rec.BofficeKind;
    else
      DocID   = tick.DealID;
      DocKind = tick.BofficeKind;
    end;                   

    paym.KeyNum = 1;
    paym.rec.DocKind = DocKind;
    paym.rec.DocumentID = DocID;
    paym.rec.Purpose = Purpose;
    paym.rec.SubPurpose = 0;
    paym.AddFilter(string("t_DocKind = ", DocKind, " AND t_DocumentID = ", DocID, " AND t_Purpose = ", Purpose));
    Ok = paym.GetGE;

    while(Ok and (found == false)) 

      if((FIID == -1) OR (paym.rec.FIID == FIID))
         // нашли свой платеж
         Copy(fake_paym, paym);
         found = true;
      else
         Ok = paym.next; // переходим к след.платежу
      end;
    end;

    paym.DropFilter();

    return found;
end;

/* Создает ИК для векселей, которые входят в текущую группу
*/
PRIVATE MACRO PawnBindBanners(Draft, tick, payms)
var
   data = null, stat = 0;

   data = DataClass2(payms.rec.BaseFIID, Draft.draftID);
   stat = VA_ForEachBannerInArray(tarr_lnk, tick, @BindBanner, VSORDLNK_K_PAWN, @data);

   return (stat == 0);
END;


/* Изменяет ИК для векселей, которые входят в текущую группу
*/
PRIVATE MACRO PawnModiBanners(Draft, tick, payms)
var
   data = null, stat = 0;
   data = DataClass2(payms.rec.BaseFIID, Draft.draftID);
   stat = VA_ForEachBannerInArray(tarr_lnk, tick, @ModiBanner, VSORDLNK_K_PAWN, @data);

   return (stat == 0);
END;


MACRO PawnBindAndModifProc(Draft, tick, payms, grp)
var
   stat = 0;

   if(Draft.Kind == SP_DEPOPER_RECORDER)  /* 840 прием ц/б на хранение */
     if(not PawnBindBanners(Draft, tick, payms))
        stat = 1;
     end;
   elif(ValType(grp) != V_UNDEF) // ИК уже найдены
     if(not ModiBanners2(Draft, grp))
        stat = 1;
     end;
   else // ИК нужно искать отдельно
     if(not PawnModiBanners(Draft, tick, payms))
        stat = 1;
     end;
   end;

   return stat;
END;

/* Формирование отложенных распоряжений в депозитарий по списанию ц/б
*/
PRIVATE MACRO doDepoDraft_Pawn(tick, grp, Purpose, FIID, DraftKind, fillproc, ActionDate, is_return)
var
   fake_paym = TRecHandler("pmpaym.dbt"),
   stat = 0, i = 0, Account = "", ok = false;
   
   if(FiidGroups == null)
      stat = doDepoDraft(tick, grp, Purpose, FIID, DraftKind, fillproc, ActionDate)
   else
      ok = FindOurPaym(tick, Purpose, FIID, fake_paym);
      if(not ok)
         // Ищем любой платеж, чтобы можно было пополнять залог векселями с FIID,
         // отличным от FIID первоначально привязанных платежей 
         // (т.к. платежей с таким BaseFIID нет)
         ok = FindOurPaym(tick, Purpose, -1, fake_paym);
         fake_paym.rec.BaseFIID = FIID;
      end;
      if(ok)
          i = FiidGroups.find(FIID);

          if(i > -1)
             fake_paym.rec.BaseAmount = FiidGroups.get_count(i);
             fake_paym.rec.ValueDate  = ActionDate;
             // Если это возврат из залога и в платеже задан хотя бы один из счетов,
             // счета в фальшивом платеже надо поменять местами, иначе они криво подставятся в поручение
             if(is_return AND ((fake_paym.rec.PayerAccount != "") OR (fake_paym.rec.ReceiverAccount != "")))
                Account = fake_paym.rec.PayerAccount;
                fake_paym.rec.PayerAccount = fake_paym.rec.ReceiverAccount;
                fake_paym.rec.ReceiverAccount = Account;
             end;
             stat = MakeDepoDraftProc(tick, fake_paym, DraftKind, grp, fillproc, ActionDate, @PawnBindAndModifProc, true);
          end;
      end;
   end;

   return stat;
END;



/* 840 - Прием ц/б на хранение 
*/
MACRO Pawn840fill(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  if(payms.rec.ReceiverBankID == tick.PartyID)
    Draft.DwPartyID = tick.PartyID;
    Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
    Draft.BnPartyID = {OurBank};
  elif(payms.rec.ReceiverBankID == {OurBank})
    Draft.DwPartyID = {OurBank};
    Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
    if(tick.Flag1 == "") /* залог */
       Draft.BnPartyID = tick.PartyID;
    else                 /* заклад */
       Draft.BnPartyID = {OurBank};
    end;
  end;
  Draft.FIID = grp.FIID;
  Draft.ValueDate = ValueDate;
  if(tick.Flag1 == "") /* залог */
     if(payms.rec.ReceiverBankID == tick.PartyID)
        Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     elif(payms.rec.ReceiverBankID == {OurBank})
        Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     end;
     Draft.Block = OBJTYPE_DEPOACC_BLOCK_PLEDGE;
     Draft.Product = 6;  /* в залог - см. llvalues 1200 (содержание транзакции) */
  else                 /* заклад */
     Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_MONEYKEEPER;
     Draft.BnAccCode    = "";
     Draft.BnPartyID    = {OurBank};
     Draft.Block = OBJTYPE_DEPOACC_BLOCK_INDEPOSIT;
     Draft.Product = 10; /* в заклад - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* 845 - Поручение на списание документарных ц/б
*/
MACRO Pawn845fill(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  if(payms.rec.ReceiverBankID == tick.PartyID)
    Draft.DwPartyID = {OurBank};
    Draft.BnPartyID = tick.PartyID;
    Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
  elif(payms.rec.ReceiverBankID == {OurBank})
    Draft.BnPartyID = {OurBank};
    Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_PLACESAVE;
    if(tick.Flag1 == "") /* залог */
       Draft.DwPartyID = tick.PartyID;
    else                 /* заклад */
       Draft.DwPartyID = {OurBank};
    end;
  end;
  Draft.FIID = grp.FIID;
  Draft.ValueDate = ValueDate;
  if(tick.Flag1 == "")
     if(payms.rec.ReceiverBankID == tick.PartyID)
        Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     elif(payms.rec.ReceiverBankID == {OurBank})
        Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     end;
     Draft.Unblock = OBJTYPE_DEPOACC_BLOCK_PLEDGE;
     Draft.Product = 7;  /* Разблокировка залога - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_MONEYKEEPER;
     Draft.DwAccCode    = "";
     Draft.DwPartyID    = {OurBank};
     Draft.Unblock = OBJTYPE_DEPOACC_BLOCK_INDEPOSIT;
     Draft.Product = 11; /* Возврат залогодателю - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* Класс: группы номеров счета владельца ИК
*
CLASS (VA_ICGroups) Pawn8xxGroups ()
 var
  stat = 0,
  ArrGrp = TArray; // Массив групп

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(FIID, DwAccCode, BnAccCode)
   ArrGrp[ArrGrp.size] = ICGrp(FIID, DwAccCode, BnAccCode);
  END;

  PRIVATE MACRO find(bnr, DwAccCode)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].FIID == bnr.rec.FIID) AND (ArrGrp[i].DwAccCode == DwAccCode))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  MACRO group(bnr, leg)
   var i = 0, DwAccCode = "", BnAccCode = "";
     GetDepoAccs4Bnr(bnr, leg, @DwAccCode, @BnAccCode);
     if((i = find(bnr, DwAccCode)) == -1)
        newGrp(bnr.rec.FIID, DwAccCode, BnAccCode);
     end;
  END;
END;*/

CLASS(VA_ICGroups) Pawn840Groups ()
  InitVA_ICGroups();

  MACRO filter(bnr, leg, tick, numOrd, lnk)
     return VAPAWN_ChooseDraftType(bnr, leg, tick, false);
  END;

  MACRO doDraftFunc(tick, grp, ActionDate)
    return doDepoDraft_Pawn(tick, grp, BAi, grp.FIID,
                       SP_DEPOPER_RECORDER, /* 840 - Прием ц/б на хранение */
                       @Pawn840fill, ActionDate, false
           );
  END;

END;

CLASS(VA_ICGroups) Pawn845Groups ()
  InitVA_ICGroups();

  MACRO filter(bnr, leg, tick, numOrd, lnk)
     return VAPAWN_ChooseDraftType(bnr, leg, tick, true);
  END;

  MACRO doDraftFunc(tick, grp, ActionDate)
    return doDepoDraft_Pawn(tick, grp, BAi, grp.FIID,
                       SP_DEPOPER_WITHDRORDER, /* 845 - Поручение на списание документарных ц/б */
                       @Pawn845fill, ActionDate, true
           );
  END;

END;


/* 800 - Поручение на книжный перевод 
*/
MACRO Pawn800fill(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
  Draft.DwPartyID = tick.PartyID;

  Draft.FIID = grp.FIID;
  Draft.ValueDate = ValueDate;
  if(tick.Flag1 == "")
     Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     Draft.Block = OBJTYPE_DEPOACC_BLOCK_PLEDGE;
     Draft.BnPartyID = tick.PartyID;
     Draft.Product = 6;  /* в залог - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_MONEYKEEPER;
     Draft.BnAccCode = "";
     Draft.Block = OBJTYPE_DEPOACC_BLOCK_INDEPOSIT;
     Draft.BnPartyID = {OurBank};
     Draft.Product = 10; /* в заклад - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* 800 - Поручение на книжный перевод 
*/
MACRO Pawn800Backfill(Draft, tick, payms, dbtprop, crdprop, grp, ValueDate)
  VA_ByDefault(ValueDate,  {curdate});

  Draft.BnAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
  Draft.BnPartyID = tick.PartyID;

  Draft.FIID = grp.FIID;
  Draft.ValueDate = ValueDate;
  if(tick.Flag1 == "")
     Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_DEPONENT;
     Draft.Unblock = OBJTYPE_DEPOACC_BLOCK_PLEDGE;
     Draft.DwPartyID = tick.PartyID;
     Draft.Product = 7;  /* Разблокировка залога - см. llvalues 1200 (содержание транзакции) */
  else
     Draft.DwAccPurp = OBJTYPE_DEPOKINDTYPE_MONEYKEEPER;
     Draft.DwAccCode    = "";
     Draft.Unblock = OBJTYPE_DEPOACC_BLOCK_INDEPOSIT;
     Draft.DwPartyID = {OurBank};
     Draft.Product = 11; /* Возврат залогодателю - см. llvalues 1200 (содержание транзакции) */
  end;
  return 0;
END;


/* Класс: группы номеров счета владельца ИК
   Внутридепозитарное поручение - прием
*/
CLASS (VA_ICGroups) Pawn800Groups ()
  InitVA_ICGroups();

  MACRO filter(bnr, leg, tick, numOrd, lnk)
     return not VAPAWN_ChooseDraftType(bnr, leg, tick, false);
  END;

  MACRO doDraftFunc(tick, grp, ActionDate)
    return doDepoDraft_Pawn(tick, grp, BAi, grp.FIID,
                       SP_DEPOPER_BOOKORDER, /* 800 - Поручение на книжный перевод */
                       @Pawn800fill, ActionDate, false
           );
  END;

END;

/* Класс: группы номеров счета владельца ИК
   Внутридепозитарное поручение - возврат
*/
CLASS (VA_ICGroups) Pawn800BackGroups ()
  InitVA_ICGroups();

  MACRO filter(bnr, leg, tick, numOrd, lnk)
     return not VAPAWN_ChooseDraftType(bnr, leg, tick, true);
  END;

  MACRO doDraftFunc(tick, grp, ActionDate)
    return doDepoDraft_Pawn(tick, grp, BAi, grp.FIID,
                       SP_DEPOPER_BOOKORDER, /* 800 - Поручение на книжный перевод */
                       @Pawn800Backfill, ActionDate, true
           );
  END;

END;

/*************** Цепочки *******************/

/* Что-то делает для каждого платежа по доп. цепочке операции залога
   (Аналог VA_ForEachPaym, но сильно заточенный под цепочки залога/заклада)
*/
MACRO VA_ForEachPaymInPawnBranch(lnk_array, ExecDate, tick, Purpose, action, data:@variant, data2:@variant, data3:@variant, is_return)
var
    fake_paym = TRecHandler("pmpaym.dbt"),
    payms = TBfile("pmpaym.dbt"), Ok, Account = "",
    DocID, DocKind, ttype, stat = 0, i;
    
    tarr_lnk = lnk_array; // Добавлено по #97537 

    FiidGroups = FiidGroupsClassPawnBranch();
    stat = VA_ForEachBannerInArray(lnk_array, tick, @GroupsByCur, VSORDLNK_K_PAWN, NULL, "B");

    ttype = ValType(tick);
    if(ttype == V_GENOBJ)
      DocID   = tick.rec.DealID;
      DocKind = tick.rec.BofficeKind;
    else
      DocID   = tick.DealID;
      DocKind = tick.BofficeKind;
    end;                   

    payms.KeyNum = 1;
    payms.rec.DocKind = DocKind;
    payms.rec.DocumentID = DocID;
    payms.rec.Purpose = Purpose;
    payms.rec.SubPurpose = 0;
    payms.AddFilter(string("t_DocKind = ", DocKind, " AND t_DocumentID = ", DocID, " AND t_Purpose = ", Purpose));
    Ok = payms.GetGE;

    while(Ok and (stat == 0)) 

      Copy(fake_paym, payms);
      i = FiidGroups.find(fake_paym.rec.BaseFIID);

      if(i > -1)
         fake_paym.rec.BaseAmount = FiidGroups.get_count(i);
         fake_paym.rec.ValueDate  = ExecDate;
         // Если это возврат из залога и в платеже задан хотя бы один из счетов,
         // счета в фальшивом платеже надо поменять местами, иначе они криво подставятся в поручение
         if(is_return AND ((fake_paym.rec.PayerAccount != "") OR (fake_paym.rec.ReceiverAccount != "")))
            Account = fake_paym.rec.PayerAccount;
            fake_paym.rec.PayerAccount = fake_paym.rec.ReceiverAccount;
            fake_paym.rec.ReceiverAccount = Account;
         end;
         stat = ExecMacro2(@action, tick, fake_paym, @data, @data2, ExecDate, @data3); 
      end;

      if(stat == 0)
         Ok = payms.next; /* переходим к след.платежу */
      end;
    end;

    payms.DropFilter();
    FiidGroups = null;

    return stat;
END;


/* Формирование отложенного распоряжения в депозитарий в доп. цепочке залога/заклада
*/
MACRO MakeDepoDraftsForPawnBranch(lnk_array, tick, ICGrp, ActionDate)
var
   stat = 0;

   VA_ByDefault(ActionDate,  {curdate});
   
   tarr_lnk = lnk_array;

   FiidGroups = FiidGroupsClassPawnBranch();
   stat = VA_ForEachBannerInArray(lnk_array, tick, @GroupsByCur, VSORDLNK_K_PAWN, NULL, "B");

   stat = VA_ForEachBannerInArray(lnk_array, tick, @doGroups, VSORDLNK_K_ALL, @ICGrp);
   if(stat == 0)
      stat = ICGrp.do(tick, ActionDate);
   end;
   
   FiidGroups = null;

   return (stat == 0);
END;
