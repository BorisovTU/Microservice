/*
$Name:         vaw120.mac
$Module:       Учтенные векселя
$Description:  Мена векселей СВ<->УВ. О.исполнение обязательств

            va-вексель
             w-операция мены векселей СВ<->УВ
           120-номер (соответствующий шагу)
*/

IMPORT VSInter, DealsInter,
       vacateg, vaacc, va4each, vatickfd, vaxutils, vawdates, vamisc, vapaym,
       vsbnrfd, vslib;

PRIVATE VAR
           StepDate = {curdate},           /* Дата выполнения шага */
           DealDate = {curdate},           /* дата сделки */
           IsPayerInBai = false,           /* заполнен ли плательщик в платеже по активу? */
           VaGroups = null,                /* группы для счетов категории "Учтенные векселя" */
           FiidGroups = null,              /* группы для ФИ векселей */
           IsDiffPayExists    = false,     /* есть ли платеж по оплате разницы? */
           IsDiffPayerOurBank = false,     /* является ли наш банк плательщиком платежа по оплате разницы? */
           ВалРасчетов = NATCUR,
           diffSum = 0;                    /* В валюте ВалРасчетов */

/* класс с информацией по группе с ФИ номинала
*/
PRIVATE CLASS PFIGrp (leg, fdBnr)
var
   fd     = fdBnr,
   PFI    = leg.rec.PFI,
   amount = leg.rec.Principal;
END;

/* класс с информацией по группе с ФИ номинала
*/
PRIVATE CLASS PFIGrpDisc (leg, fd)
var
   AccFI, amount, dbt, crd;

var ВалУч = fd.ОпределитьВалютуУчета();

   AccFI  = ВалУч;
   amount = VA_Convert((leg.rec.Principal - leg.rec.ReceiptAmount), StepDate, leg.rec.PFI, ВалУч);
   dbt    = "";
   crd    = "";

   VA_GetAccount("БВыплДиск,Сц/б", fd, dbt, MC_OPENACC_CREATE, ВалУч, FIROLE_DISCOUNT, null, StepDate);
   VA_GetAccount("Наш вексель",    fd, crd, MC_OPENACC_CREATE, ВалУч, null,            null, StepDate);

END;

/* Класс: группы векселей по PFI
*/
CLASS FiidGroupsClass ()
 var
  stat = 0,
  ArrGrp = TArray, /* Массив групп  */
  ArrGrpDisc = TArray; /* Массив групп  */

  ArrGrp.size = 0;
  ArrGrpDisc.size = 0;

  PRIVATE MACRO newGrp(leg, fd)
   ArrGrp[ArrGrp.size] = PFIGrp(leg, fd);
  END;

  PRIVATE MACRO find(leg)
   var i = 0;
    while (i < ArrGrp.size)
      if(ArrGrp[i].PFI == leg.rec.PFI)
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, amount)
     ArrGrp[i].amount = ArrGrp[i].amount + amount;
  END;

  PRIVATE MACRO newGrpDisc(leg, fd)
   ArrGrpDisc[ArrGrpDisc.size] = PFIGrpDisc(leg, fd);
  END;

  PRIVATE MACRO findDisc(leg, fd)
   var i = 0;
    while (i < ArrGrpDisc.size)
      if(ArrGrpDisc[i].AccFI == fd.ОпределитьВалютуУчета())
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO addDisc (i, amount)
     ArrGrpDisc[i].amount = ArrGrpDisc[i].amount + amount;
  END;

  MACRO group(leg, fd)
   var i = find(leg);
     if(i == -1)
        newGrp(leg, fd);
     else
        add (i, $1.0);
     end;
     if(ВексельДисконтный(leg))
        i = findDisc(leg, fd);
        if(i == -1)
           newGrpDisc(leg, fd);
        else
           addDisc (i, VA_Convert((leg.rec.Principal - leg.rec.ReceiptAmount), StepDate, leg.rec.PFI, fd.ОпределитьВалютуУчета()));
        end;
     end;
  END;

  MACRO makeBookpass()
    var СчетДоход, СчетРасход, sum_dbt, i = 0, stat = 0, at = VA_AccTrans();

    while((stat == 0) AND (i < ArrGrpDisc.size))
      stat = VA_Bookpass(ArrGrpDisc[i].dbt,
                     ArrGrpDisc[i].crd,
                     ArrGrpDisc[i].amount,
                     String("Начисление дисконта по векселю"),
                     0, 0,               /* Платеж */
                     ArrGrpDisc[i].AccFI,
                     null, null, StepDate,
                     null, null, null, null,
                     "18");
      i = i + 1;
    end;
    i = 0;

    at.date_carry   = StepDate;
    at.CatPayer     = "ВнебалСчетКорресп";
    at.CatReceiver  = "Разн.ценности и документы";
    at.FIIDPayer    = NATCUR;
    at.FiRolePayer  = FIROLE_CORACC_ACTIVE;
    at.Ground       = String("Выдача векселя контрагенту");
    at.Chapter      = 3;
    while((stat == 0) AND (i < ArrGrp.size))
        at.FDPayer      = ArrGrp[i].fd;
        at.FDReceiver   = ArrGrp[i].fd;
        at.PrimaryDoc   = ArrGrp[i].fd;
        at.FIIDReceiver = NATCUR;
        at.SumReceiver  = ArrGrp[i].amount;

        if (not at.carry())
            stat = VA_Err("Ошибка при выполнении",
                          "|проводки по выдаче векселя",
                          "|контрагенту");
        end;
      i = i + 1;
    end;
    return stat;
  END;

END;

/* Группирует векселя по валютам.
*/
PRIVATE MACRO GroupsByCur(bnr, leg, tick, numOrd, lnk)
var fd;

   fd = VSBannerFD(bnr, leg, tick.BofficeKind, tick);
   FiidGroups.group(leg, fd);

   return 0;
END;

/* Проводки УчетДиск, ВыдВекс.
*/
PRIVATE MACRO BkpPassBnr(tick)
var
    stat = 0;

    FiidGroups = FiidGroupsClass();
    stat = VA_ForEachBanner(tick, @GroupsByCur, VSORDLNK_K_SALE);
    if(stat == 0)
       stat = FiidGroups.makeBookpass();
    end;

    return (stat == 0);
END;

/* класс с информацией по группе "Наш вексель".
*/
PRIVATE CLASS VaGrp (TheFiid, TheAcc, TheAmount, TheFiid2, TheAmount2)
var
   ВалУч, acc, Principal, BCCFI, BCCost;

   ВалУч     = TheFiid;
   acc       = TheAcc;
   Principal = TheAmount;
   BCCFI     = TheFiid2;
   BCCost    = TheAmount2;

END;

/* Класс: группы векселей по "Наш вексель"
*/
CLASS VaGroupsClass ()
 var
  stat = 0,
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(fiid, acc, amount, fiid2, amount2)
   ArrGrp[ArrGrp.size] = VaGrp(fiid, acc, amount, fiid2, amount2);
  END;

  PRIVATE MACRO find(Fiid, fiid2, acc)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].ВалУч == Fiid) AND (ArrGrp[i].BCCFI == fiid2) AND (ArrGrp[i].acc == acc))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, principal, bccost)
     ArrGrp[i].Principal = ArrGrp[i].Principal + principal;
     ArrGrp[i].BCCost = ArrGrp[i].BCCost + bccost;
  END;

  MACRO group(Fiid, acc, amount, fiid2, amount2)
   var i = find(Fiid, fiid2, acc);
     if(i == -1)
        newGrp(fiid, acc, amount, fiid2, amount2);
     else
        add (i, amount, amount2);
     end;
  END;

  MACRO makeBookpass(tick, fd)
    var
       i = 0, stat = 0, at, ВЦоб;

    while((stat == 0) AND (i < ArrGrp.size))

        at = VA_AccTrans;

        at.Date_Carry       = StepDate;
        at.Ground           = "Исполнение обязательств по поставке";
        at.PrimaryDoc       = fd; //90621
        at.CatPayer         = "+Форвард, расчеты";
        at.SumPayer         = ArrGrp[i].BCCost;
        at.FIIDPayer        = ArrGrp[i].BCCFI;
        at.FiRolePayer      = FIROLE_FICOM;
        at.FIIDReceiver     = ArrGrp[i].ВалУч;
        at.AccountReceiver  = ArrGrp[i].acc;
        at.SumReceiver      = ArrGrp[i].Principal;
        at.Shifr_Oper       = "18";

        if (not at.Carry())
            stat = 1;
        end;

      i = i + 1;
    end;
    return stat;
  END;

END;

/* Группирует векселя по однородным группам счетов категории "Наш вексель".
*/
PRIVATE MACRO GroupsByVa(bnr, leg, tick, numOrd, lnk)
var
   stat = 0, fd, acc, Sum, SumPay, ВалУч;

   fd = VSBannerFD(bnr, leg, tick.BofficeKind, tick);

   ВалУч = fd.ОпределитьВалютуУчета();

   if(ВексельДисконтный(leg))
      SumPay = leg.rec.ReceiptAmount;
   else
      SumPay = leg.rec.Principal;
   end;

   Sum = SumPay;
   if(lnk.rec.BCCFI != ВалУч)
      /* нужна конверсия суммы */
      Sum = VA_Convert(SumPay, StepDate, lnk.rec.BCCFI, ВалУч);
   end;

   if(not VA_GetAccount("Наш вексель", fd, acc, MC_OPENACC_CHECKPERIOD, ВалУч, null, null, StepDate))
      stat = 1;
   else
      VaGroups.group(ВалУч, acc, Sum, lnk.rec.BCCFI, SumPay);
   end;

   return stat;
END;

/* Проводки: ИспОб
*/
PRIVATE MACRO BkpPerform(tick)
var
    stat = 0, fd;

    VaGroups = VaGroupsClass();
    stat = VA_ForEachBanner(tick, @GroupsByVa, VSORDLNK_K_SALE);
    if(stat == 0)
       if((fd = VATickFD(tick)) == null)
         stat = VA_Err("Ошибка при определении первичного документа сделки");
         return (stat == 0);
       else
         stat = VaGroups.makeBookpass(tick, fd);
       end;
    end;

    return (stat == 0);
END;

/* cмена статуса анкеты векселя на "выдан"
*/
PRIVATE MACRO SetBCStatToAccount(bnr, leg, tick, numOrd, lnk)
var
   stat = 0;

   if(not ИзменитьВексель(bnr.rec.BCID, StepDate, "bcstatus", VSBANNER_STATUS_SENDED))
     stat = VA_Err("Ошибка при определении первичного документа сделки");
   end;

   return stat;
END;

/* cмена статусов анкеты векселя на "выдан"
*/
PRIVATE MACRO SetBCStatus(tick)
var
    stat = 0;

    stat = VA_ForEachBanner(tick, @SetBCStatToAccount, VSORDLNK_K_SALE, null, "B");

    return (stat == 0);
END;

/* Делай "раз"
   - проводки: ИспОб, УчетДиск, ВыдВекс
   - cмена статуса анкеты векселя на "выдан".
*/
PRIVATE MACRO Point1(tick)
var
    stat = 0;

    if(not BkpPerform(tick))
      stat = 1;
    elif(not BkpPassBnr(tick))
      stat = 1;
    elif(not SetBCStatus(tick))
      stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "два".
     Установить статус "закрыт" всем платежам по активу.
     Если init == true, делаем платежам Actuate,
     иначе - устанавливаем статус
*/
PRIVATE MACRO Point2(tick, init)
    if(init == true)
       return VA_ActuatePayms(tick, BAi, StepDate);
    else
       return VA_SetStatOfPayms(tick, BAi, PM_FINISHED, StepDate);
    end;
    return true;
END;

/* Запуск шага
   Алгоритм:
   1. Для каждого векселя по сделке с ролью "продажа":
      1.1 Проводка ИспОб
      1.2 Если вексель дисконтный:
          1.2.1 Проводка УчетДиск
      1.3 Проводка ВыдВекс
      1.4 Смена статуса анкеты векселя на "выдан".

   2. Установить статус "закрыт" всем платежам по активу.
*/
MACRO ExecuteStep(Buffer, dl_tick)
var
    stat = 0, FstBai = TBfile("pmpaym.dbt");
    record tick(dl_tick);

    SetBuff(tick, dl_tick);

    GetOprDate(DATE_XW_OLD, @StepDate);
    DealDate = tick.DealDate;

    if(StepDate > {curdate})
        stat = VA_Err("Преждевременное выполнение шага запрещено");
    end;

    if(stat == 0)
        if(VA_Get1stPlanPaym(tick.BofficeKind, tick.DealID, BAi, FstBai))
           IsPayerInBai = FstBai.rec.PayerBankID != {OurBank};
        end;

        PrepareXWParams(tick,
                         @IsDiffPayExists,
                         @IsDiffPayerOurBank,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                         @ВалРасчетов,
                         @diffSum);
    end;

    if((stat == 0) and not Point2(tick, true)) // Актуализировать платежи
        stat = 1;
    end;

    if((stat == 0) and not Point1(tick))
        stat = 1;
    end;

    if((stat == 0) and not Point2(tick, false))
        stat = 1;
    end;

    return stat;
END;

//печать через vaprstvs.mac

/*
MACRO PostStep (...)
MACRO PrintStepDocs (...)
*/

