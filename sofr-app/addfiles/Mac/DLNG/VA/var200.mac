/*
$Name:         var200.mac
$Module:       Учтенные векселя
$Description:  Погашение векселей. С.перенос на просрочку

            va-вексель
             r-операция погашения векселей (repayment)
           200-номер (соответствующий шагу)
*/

IMPORT VAInter, DealsInter, Календарь,
       vacateg, vaacc, vaopr, va4each, vsbnrfd, vatickfd, vadepo, varepay, vamisc, vaprdeca, vaprdslib, vaovernvpi, vspmfutu, va_voop, varsrvbk;

PRIVATE VAR
          VALUEOFINVESTMENTS = 0,
          ACCRUEDINTEREST = 1,
          ACCRUEDDISCOUNT = 2;

PRIVATE VAR
           StepDate = {curdate},                /* Дата выполнения шага */
           FiidGroups = null,                   /* группы для ФИ векселей */
           PurposeGrp = TArray,           
           ProtestKind = 0,
           СчетТребСнс,
           ResGroup;

PurposeGrp[VALUEOFINVESTMENTS] = "Перенос стоимости вложений в вексель на счет по учету просроченной задолженности";
PurposeGrp[ACCRUEDINTEREST] = "Перенос начисленных процентов на счет по учету просроченной задолженности";
PurposeGrp[ACCRUEDDISCOUNT] = "Перенос начисленного дисконта на счет по учету просроченной задолженности";

/* класс с информацией по группе с ФИ векселей
*/
PRIVATE CLASS FiidGrp (TheFIIDDbt, TheFIIDCrd, TheDbt, TheCrd, TheAmountDbt, TheAmountCrd, ThePurposeNum)
var
   FIIDDbt, FIIDCrd, dbt, crd, AmountDbt, AmountCrd, PurposeNum;

   FIIDDbt = TheFIIDDbt;
   FIIDCrd = TheFIIDCrd;
   dbt     = TheDbt;
   crd     = TheCrd;
   AmountDbt  = TheAmountDbt;
   AmountCrd  = TheAmountCrd;
   PurposeNum = ThePurposeNum;
END;


/* Класс: группы векселей по Fiid
*/
CLASS FiidGroupsClass ()
 var
  stat = 0,
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(fiiddbt, fiidcrd, dbt, crd, sumdbt, sumcrd, purpose)
   ArrGrp[ArrGrp.size] = FiidGrp(fiiddbt, fiidcrd, dbt, crd, sumdbt, sumcrd, purpose);
  END;

  PRIVATE MACRO find(FiidDbt, FiidCrd, dbt, crd, purpose)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].FIIDDbt == FiidDbt) 
         AND (ArrGrp[i].FIIDCrd == FiidCrd) 
         AND (ArrGrp[i].dbt == dbt) 
         AND (ArrGrp[i].crd == crd) 
         AND (ArrGrp[i].PurposeNum == purpose))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, sumdbt, sumcrd)
     ArrGrp[i].amountDbt = ArrGrp[i].amountDbt + sumdbt;
     ArrGrp[i].amountCrd = ArrGrp[i].amountCrd + sumcrd;
  END;

  MACRO group(fiidDbt, fiidCrd, dbt, crd, sumdbt, sumcrd, purpose)
   var i = find(fiidDbt, fiidCrd, dbt, crd, purpose);
     if(i == -1)
        newGrp(fiidDbt, fiidCrd, dbt, crd, sumDbt, sumCrd, purpose);
     else
        add (i, sumDbt, sumCrd);
     end;
  END;

  MACRO makeBookpass()
    var
       i = 0, stat = 0, SumDbt = 0, Purpose;
    while((stat == 0) AND (i < ArrGrp.size))
      Purpose = PurposeGrp[ArrGrp[i].PurposeNum];

        if(ArrGrp[i].fiidDbt == ArrGrp[i].fiidcrd)
            stat = VA_Bookpass(ArrGrp[i].dbt, ArrGrp[i].crd, ArrGrp[i].amountDbt, Purpose,
                     0, 0,               /* Платеж */
                     ArrGrp[i].fiidDbt,
                     null, null, StepDate
                    );
        else
            if(not VA_MBookpass(0,
                          ArrGrp[i].fiidDbt, ArrGrp[i].dbt, ArrGrp[i].amountDbt,
                          ArrGrp[i].fiidcrd, ArrGrp[i].crd, ArrGrp[i].amountCrd,
                          Purpose,
                          null, null,
                          null, StepDate))
                stat = VA_Err("Ошибка при выполнении проводки",
                              "|", Purpose);
            end
        end;
      i = i + 1;
    end;
    return stat;
  END;

END;

MACRO СписаниеКорректировокПроцентовДоЭПС(fd, IncGroup)
 var
  stat = 0, acc, AccDbt, Sum = 0, SumVN = 0, SumDbt = 0, ВалУч, Purpose, StepDate, bnr;

  bnr = fd.GetBnr();
  ВалУч = fd.ОпределитьВалютуУчета();
  
  if( not VA_GetAccountManual("+КорЭПС_%вексель", fd, AccDbt, MC_OPENACC_CREATE, NATCUR, null, null, StepDate))
     stat = 1;
  elif(not VA_GetAccountManual("КорСт_Увеличение, вексель", fd, acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
      stat = 1;
  else
      Sum    = ПолучитьПоложКорректировкуПДДПоЭПСВУ(bnr.rec.BCID, 0, StepDate) + IIF(IncGroup.GetSumEIRAcc(bnr.rec.BCID) > 0, IncGroup.GetSumEIRAcc(bnr.rec.BCID), 0);
      SumDbt = VA_Convert(Sum, StepDate, ВалУч, NATCUR);

      if(Sum)
        Purpose = "Списание корректировки, увеличивающей стоимость векселя";
        if(NATCUR == ВалУч)
           stat = VA_Bookpass(AccDbt, acc, SumDbt, Purpose,
                          0, 0,               /* Платеж */
                          NATCUR,
                          null, null, StepDate
                         );
        else
           if(not VA_MBookpass(0,
                            NATCUR, AccDbt, SumDbt,
                            ВалУч, acc, Sum,
                            Purpose,
                            null, null,
                            null, StepDate))
              stat = VA_Err("Ошибка при выполнении проводки",
                            "|", Purpose);
           end;
        end;
      end;
  end;

  if(not VA_GetAccountManual("-КорЭПС_%вексель", fd, acc, MC_OPENACC_CREATE, NATCUR, null, null, StepDate))
     stat = 1;
  elif(not VA_GetAccountManual("КорСт_Уменьшение, вексель", fd, AccDbt, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
      stat = 1;
  else
      SumDbt = ПолучитьОтрицКорректировкуПДДПоЭПСВУ(bnr.rec.BCID, 0, StepDate) + IIF(IncGroup.GetSumEIRAcc(bnr.rec.BCID) < 0, IncGroup.GetSumEIRAcc(bnr.rec.BCID), 0);
      Sum    = VA_Convert(SumDbt, StepDate, ВалУч, NATCUR);
      
      if(Sum)
        Purpose = "Списание корректировки, уменьшающей стоимость векселя";
        if(NATCUR == ВалУч)
           stat = VA_Bookpass(AccDbt, acc, abs(SumDbt), Purpose,
                          0, 0,               /* Платеж */
                          NATCUR,
                          null, null, StepDate
                         );
        else
           if(not VA_MBookpass(0,
                            ВалУч, AccDbt, abs(SumDbt),
                            NATCUR, acc, abs(Sum),
                            Purpose,
                            null, null,
                            null, StepDate))
              stat = VA_Err("Ошибка при выполнении проводки",
                            "|", Purpose);
           end;
        end;
      end;
  end;

  return (stat == 0);
END;

private macro CreatePaym(tick, leg, Purpose, NumPaym, FIID, Amount, Acc)
   var DocKind, DocID, ВН, newPaym, Voop_Paym, mainPaym, Paym, Debet, Credit, RMProp;
    
   if(ValType(tick) == V_GENOBJ)
     DocID   = tick.rec.DealID;
     DocKind = tick.rec.BofficeKind;
   else
     DocID   = tick.DealID;
     DocKind = tick.BofficeKind;
   end;         
   
   if(ValType(leg) == V_GENOBJ)
     ВН = leg.rec.PFI;
   else
     ВН = leg.PFI;
   end;         
   
   newPaym   = RsbPayment();
   Voop_Paym = TRecHandler("pmpaym.dbt");
   mainPaym  = MyRsbPayment(DocKind, DocID, PM_PURP_PRINC_RET, 0);
   Paym      = mainPaym.GetPM_PAYM();
   Debet     = mainPaym.GetDEBET();
   Credit    = mainPaym.GetCREDIT();
   RMProp    = mainPaym.GetPMRMPROP();
   
   Amount = VA_Convert(Amount, StepDate, ВН, mainPaym.OrderFIID);

   newPaym.DocKind          = Paym.rec.DocKind;
   newPaym.DocumentID       = Paym.rec.DocumentID;   
   newPaym.Purpose          = Purpose;      
   newPaym.SubPurpose       = NumPaym;   
   newPaym.ValueDate        = Paym.rec.ValueDate;    
   newPaym.OrderAmount      = Amount;//сюда нужную сумму  
   newPaym.BaseFIID         = Paym.rec.BaseFIID;     
   newPaym.ReceiverFIID     = Paym.rec.PayFIID; 
   newPaym.PayerFIID        = Paym.rec.FIID;    
   newPaym.OrderFIID        = Paym.rec.OrderFIID;    
   newPaym.PaymStatus       = PM_OVERDUE;
   newPaym.IsFixPayerAmount = Paym.rec.IsFixAmount;   
   newPaym.CheckTerror      = Paym.rec.CheckTerror;
   newPaym.PayerMesBankID   = Paym.rec.PayerMesBankID;


   newPaym.SetPayerPI(PAYMENTS_GROUP_UNDEF,
                      Paym.rec.PayerBankID,
                      Debet.rec.CodeKind,
                      Debet.rec.BankCode,
                      RMProp.rec.PayerBankName,
                      RMProp.rec.PayerCorrAccNostro,
                      Paym.rec.FIID,
                      Paym.rec.Chapter,
                      Paym.rec.PayerAccount,
                      Paym.rec.Payer,
                      RMProp.rec.PayerName,
                      RMProp.rec.PayerINN,
                      Paym.rec.PayerCodeKind,
                      Paym.rec.PayerCode
                      );

   newPaym.SetReceiverPI(PAYMENTS_GROUP_UNDEF,            // Group  
                         Paym.rec.ReceiverBankID,         // BankID
                         Credit.rec.CodeKind,             // BankCodeKind
                         Credit.rec.BankCode,             // BankCode
                         RMProp.rec.ReceiverBankName,     // BankName
                         "",// CorrAcc
                         FIID,                // AccountFI
                         Paym.rec.Chapter,                // AccountChapter
                         Acc,                             // Account сюда нужный счет
                         Paym.rec.Receiver,               // ClientID
                         RMProp.rec.ReceiverName,         // ClientName,
                         RMProp.rec.ReceiverINN,          // ClientINN,
                         Paym.rec.ReceiverCodeKind,       // ClientCodeKind,
                         Paym.rec.ReceiverCode            // ClientCode
                         );

   VA_SetPaymentGround( newPaym.GetPM_PAYM(), tick );

   return newPaym;
end;

/* Устанавливает для векселя признак "Просрочен" в строку состояния.
*/
PRIVATE MACRO SetFlagToBnr(bnr, leg, tick, numOrd, lnk, PrDsParm)
   var
      fd, Acc, Crd, SumDbt = $0, SumCrd = $0, NRepay, pm_obj, PaySum,
      lnkLast = TBfile("vsordlnk"), tickLast = TBfile("dl_tick"),
      fininstr = TBFile("fininstr"),
      stat = 0, ВалУч, ОстатокПремииВН = 0.0, ОстатокПремииВУ = 0.0, СчетПремии = "", tickfd;

   if(not VA_IsClient(tick))
      fd = VSBannerFD(bnr, leg, tick.BofficeKind, tick);
      if(fd == null)
         return VA_Err("Ошибка при получении первичного документа векселя");
      else
         ВалУч = fd.ОпределитьВалютуУчета();
      end;

      tickfd = VATickFD(tick);

      if(not VA_GetAccount("Просроч_вексель", fd, Acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
         stat = 1;
      elif(VA_GetAccountManual("Учтенные векселя", fd, Crd, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
            SumCrd = БалансоваяСтоимостьВекселяВУ(bnr.rec.BCID, StepDate) + PrDsParm.IncGroup.GetIncSummBalOverAcc(bnr.rec.BCID);
            SumDbt = SumCrd;
            if( (abs(SumDbt) > 0) AND  (abs(SumCrd) > 0))
               FiidGroups.group(ВалУч, ВалУч, Acc, Crd, abs(SumDbt), abs(SumCrd), VALUEOFINVESTMENTS);
          
               SumDbt = VA_Convert(SumCrd, StepDate, ВалУч, leg.rec.PFI);
               if( not VA_SaveIncomeSum(VSINCOMETYPE_ACCOUNTEDSUM, bnr.rec.BCID, VA_GetLastAccountedEnrolmentID(bnr.rec.BCID), date(StepDate), -SumDbt, leg.rec.PFI, -SumCrd, ВалУч) )
                  stat = VA_Err("Не удалось сохранить запись о списании балансовой стоимости в истории" );
               end;
               
               DL_GetVekselNumberInDoc(NRepay, bnr.rec.BCID, VSORDLNK_K_ALL, tick.DealID, tick.BofficeKind);
               if(((pm_obj = MyRsbPayment(tick.BofficeKind, tick.DealID, PM_PURP_PRINC_RET, NRepay)) == null)
                    OR (pm_obj.PaymentID <= 0))
                  pm_obj = CreatePaym(tick, leg, PM_PURP_PRINC_RET, NRepay, ВалУч, VA_Convert(leg.rec.Principal, StepDate, leg.rec.PFI, ВалУч), Acc);
               else 
                  pm_obj.OrderAmount = VA_Convert(leg.rec.Principal, StepDate, leg.rec.PFI, pm_obj.OrderFIID);
                  pm_obj.SetReceiverAccount( ВалУч, 1, Acc );
               end;
            end;
            СчетТребСнс = Acc;
      else 
         stat = 1;
      end;

      if(ВексельДисконтный(leg))
         if(not VA_GetAccount("Просроч_вексель", fd, Acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
            stat = 1;
         elif(VA_GetAccountManual("Начисл.ПДД, УВ", fd, Crd, MC_OPENACC_CREATE, ВалУч, FIROLE_DISCOUNT, null, StepDate))
            SumCrd = ПолучитьСуммуПДДВУ(bnr.rec.BCID, 0, FIROLE_DISCOUNT, StepDate) + PrDsParm.IncGroup.GetIncSummAcc(bnr.rec.BCID, FIROLE_DISCOUNT);
            SumDbt = SumCrd;

            if( (SumDbt > 0) AND  (SumCrd > 0))
               FiidGroups.group(ВалУч, ВалУч, Acc, Crd, SumDbt, SumCrd, ACCRUEDDISCOUNT);
            end;

         else 
            stat = 1;
         end;
      end;

      if(ВексельПроцентный(leg))
         if(VA_IsSumSeparation())
            if(not VA_GetAccount("Просроч_вексель", fd, Acc, MC_OPENACC_CREATE, ВалУч, FIROLE_PERCENT, null, StepDate))
               stat = 1;
            elif(VA_GetAccountManual("Начисл.ПДД, УВ", fd, Crd, MC_OPENACC_CREATE, ВалУч, FIROLE_PERCENT, null, StepDate))
               SumCrd = ПолучитьСуммуПДДВУ(bnr.rec.BCID, 0, FIROLE_PERCENT, StepDate) + PrDsParm.IncGroup.GetIncSummAcc(bnr.rec.BCID, FIROLE_PERCENT);
               SumDbt = SumCrd;
               if( (SumDbt > 0) AND  (SumCrd > 0))
                  FiidGroups.group(ВалУч, ВалУч, Acc, Crd, SumDbt, SumCrd, ACCRUEDINTEREST);

                  PaySum = ПолучитьСуммуПДД(bnr.rec.BCID, 0, FIROLE_PERCENT, StepDate) + PrDsParm.IncGroup.GetIncSumm(bnr.rec.BCID, FIROLE_PERCENT);
                  if(((pm_obj = MyRsbPayment(tick.BofficeKind, tick.DealID, PM_PURP_PERCENT, NRepay)) == null)
                       OR (pm_obj.PaymentID <= 0))
                     pm_obj = CreatePaym(tick, leg, PM_PURP_PERCENT, NRepay, ВалУч, PaySum, Acc);
                  else 
                     pm_obj.OrderAmount = VA_Convert(PaySum, StepDate, leg.rec.PFI, pm_obj.OrderFIID);
                     pm_obj.SetReceiverAccount( ВалУч, 1, Acc );
                  end;
               end;
            else 
               stat = 1;
            end;
         else
            if(not VA_GetAccount("Просроч_вексель", fd, Acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
               stat = 1;
            elif(VA_GetAccountManual("Начисл.ПДД, УВ", fd, Crd, MC_OPENACC_CREATE, ВалУч, FIROLE_PERCENT, null, StepDate))
               SumCrd = ПолучитьСуммуПДДВУ(bnr.rec.BCID, 0, FIROLE_PERCENT, StepDate) + PrDsParm.IncGroup.GetIncSummAcc(bnr.rec.BCID, FIROLE_PERCENT);
               SumDbt = SumCrd;
               if( (SumDbt > 0) AND  (SumCrd > 0))
                  FiidGroups.group(ВалУч, ВалУч, Acc, Crd, SumDbt, SumCrd, ACCRUEDINTEREST);

                  PaySum = ПолучитьСуммуПДД(bnr.rec.BCID, 0, FIROLE_PERCENT, StepDate) + PrDsParm.IncGroup.GetIncSumm(bnr.rec.BCID, FIROLE_PERCENT);
                  if(pm_obj == null)
                     pm_obj = CreatePaym(tick, leg, PM_PURP_PRINC_RET, NRepay, ВалУч, PaySum, Acc);
                  else 
                     pm_obj.OrderAmount = pm_obj.OrderAmount + VA_Convert(PaySum, StepDate, leg.rec.PFI, pm_obj.OrderFIID);
                     pm_obj.SetReceiverAccount( ВалУч, 1, Acc );
                  end;
               end;
            else 
               stat = 1;
            end;
         end;
      end;

      if(not((bnr.rec.PortfolioID == KINDPORT_DB_AMRTCOST) AND (leg.rec.PrincipalDiff == VSBANNER_METHOD_AC_LM)))
        if(not СписаниеКорректировокПроцентовДоЭПС(fd, PrDsParm.IncGroup) )
           stat = 1;
        end;
      end;
      if(bnr.rec.PortfolioID == KINDPORT_DB_AMRTCOST)
        if(VA_WriteOff_Bnr_Retirement(bnr, leg, tick, null, lnk, StepDate))
           stat = 1;
        end;
      end;

   end;

   if(not stat)
      if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "addbcstate", "Ч"))
         stat = VA_Err("Ошибка при установке",
                       "|для векселя ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber),
                       "|признака Просрочен");
      else
         bnr.rec.BCState = bnr.rec.BCState + "Ч";
      end;
   end;

return stat;
END;

/* Установка признака "просрочен" для каждого векселя по сделке.
*/
PRIVATE MACRO SetFlags(tick, PrDsParm)
var
    stat = 0;

    FiidGroups = FiidGroupsClass();

    stat = VA_ForEachBanner(tick, @SetFlagToBnr, VSORDLNK_K_ALL, PrDsParm, "BL");
    return (stat == 0);
END;

/* Проводки по просрочке.
*/
PRIVATE MACRO BkpsDelay(tick)
var
    stat = 0;

    if(not VA_IsClient(tick))
       stat = FiidGroups.makeBookpass();
    end;

    return (stat == 0);
END;


/* Возврат векселя через депозитарий.
*/
PRIVATE MACRO BackOverDepo(tick)
var
   ICGrp = Back800Groups();
   return VA_MakeDepoDrafts(tick, ICGrp, StepDate);
END;


/* Возвращаем векселя в хранилище.
*/
PRIVATE MACRO BackToStor(tick, ID_Operation)
    var BlankDate = ZeroDate, PerformDate = BlankDate, WithDepositary = false, OurBannersInDepository = false, stat = 0;

    VA_GetPerformDate("Д", ID_Operation, @PerformDate);

    if(PerformDate != BlankDate)
        return true; // есть шаг, ничего больше не делаем
    end;

    if((stat == 0) and not VA_WorkWithDepositary(@WithDepositary))
        stat = 1;
    end;

    if((stat == 0) and not VA_OurBannersInDepository(@OurBannersInDepository))
        stat = 1;
    end;

    // если установлен признак работы с депозитарием
    // и если сделка собственная и включена настройка УВ В ДЕПОЗИТАРИИ или если сделка клиентская,
    // то формируем отложенные распоряжения
    if((stat == 0) and WithDepositary and (VA_IsClient(tick) or OurBannersInDepository) and not BackOverDepo(tick))
        stat = 1;
    end;

    return (stat == 0);
END;

// Проверка плановых дат погашения векселей.
// Если факт.дата > план.дата + 2 раб. дня, выдаем сообщение, но перенос выполняем
PRIVATE MACRO CheckRepaymentDate(bnr, leg, tick, numOrd, lnk)
var RepaymentDate = StepDate;

    if((bnr.rec.BCTermFormula == VS_TERMF_FIXEDDAY) OR (bnr.rec.BCTermFormula == VS_TERMF_INATIME))    // срочные
       RepaymentDate = leg.rec.Maturity;
    elif((bnr.rec.BCTermFormula == VS_TERMF_ATSIGHT) and (leg.rec.Expiry >= leg.rec.Start)) // По предъявлении, но не позднее
       RepaymentDate = leg.rec.Expiry;
    //elif((bnr.rec.BCTermFormula == 30) and (bnr.rec.BCPresentationDate != zero_date)) // от предъявления, уже предъявленные
    elif((bnr.rec.BCTermFormula == VS_TERMF_DURING) and (int(bnr.rec.BCPresentationDate) > 1)) // от предъявления, уже предъявленные
       RepaymentDate = bnr.rec.BCPresentationDate + int(leg.rec.Diff);
    else
       return 0;
    end;

    if(StepDate > GetDateAfterWorkDays(RepaymentDate, 2))
       return VA_Err("Дата исполнения переноса на просрочку больше|плановой даты погашения векселя  + 2 раб. дня");
    end;
    return 0;
END;


PRIVATE MACRO ВыполнитьПереоценкуНВПИВекселей(bnr, leg, tick, numOrd, lnk, IncGroup)
  var stat = 0;

  stat = ПереоценкаНВПИВекселя(bnr.rec.BCID, StepDate, IncGroup);
  
  return stat;
END;

/* Запуск шага
1. Для каждого векселя по документу
  1.1. Установить признак "просрочен" в строку состояния.
  1.2.  Если в сделке не указан клиент
    1.2.1. Переактуализировать счет категории "Учтенные векселя".

2. Если в сделке не указан клиент
  2.1. Проводки "Просрочка"

3. Если в операции нет шага с символом 'Д'
  // Возвращаем векселя в хранилище
  3.1. Если установлен признак работы с депозитарием
    3.1.1. Сформировать в депозитарий поручения вида "Внутридепозитарный перевод" (800).
      В поручения должна попадать информация только по тем векселям, у которых в последней сделке покупки  в платеже с назначением $(актив) и ФИ, соответствующим текущему векселю, pmpaym.ReceiverBankID = $(OurBank).
      Параметры поручения:
        DwPartyID = $(наш банк)
        DwAccTypeDef = $(Хранилище)
        DwAccCode = ""
        Unblock = $(Стандартная)
        BnPartyID = Контрагент по сделке
        BnAccTypeDef = $(В пути)
        BnAccCode = Раздел, на котором находится л/сч места хранения из параметров данной группы ИК
        Block = $(Отправлены)
        FIID = ФИ группы векселей
        ValueDate = текущий день
        Product = $(погашение)
      Остальные параметры аналогично сделке покупки векселей.
*/
MACRO ExecuteStep(Buffer, dl_tick, DocKind, ID_Operation, ID_Step)
    var stat = 0, IncGroup, PrDsParm, but, ind = 0;
    
    record tick(dl_tick);
    SetBuff(tick, dl_tick);

    IncGroup = VACollectIncome(StepDate);
    PrDsParm = VAPrDsParm(@IncGroup, ID_Operation, ID_Step);
    ResGroup = VACollectReserv(StepDate);
    
    StepDate = tick.DealDate;
    VA_ForEachBanner(tick, @CheckRepaymentDate, VSORDLNK_K_ALL, null, "BL");
   
    if(StepDate > {curdate})
      stat = VA_Err("Преждевременное выполнение шага запрещено.");
    end;

    if(stat == 0)
       stat = VA_ForEachBanner(tick, @ВыполнитьДоначислениеОднойЦБ, VSORDLNK_K_ALL, PrDsParm, "BL");
    end;

    if((stat == 0) and not SetFlags(tick, PrDsParm))
       stat = 1;
    end;

    if((stat == 0) and not BkpsDelay(tick))
       stat = 1;
    end;
   
    if((stat == 0) and not BackToStor(tick, ID_Operation))
       stat = 1;
    end;

    if(not VA_SetStatOfPayms(tick, PM_PURP_PRINC_RET, PM_OVERDUE))
      stat = 1;
    elif(not VA_SetStatOfPayms(tick, PM_PURP_PERCENT, PM_OVERDUE))
      stat = 1;  
    end;

    return stat;
END;


/* Функция печати распоряжений
*/
PRIVATE MACRO PrintDec(ManPr, ID_Operation, ID_Step)
VAR
    CDate;

    if((NOT (ManPr > 0)) AND (NOT (AutoPrint())))
        return FALSE;
    end;

    InitDecType(DecType);
    InitDecPurp(DecPurp);

    CDate = GetPlanDate(ID_Operation, ID_Step);

    record dl_t (dl_tick);

/* Attributs begin */
    if (NOT ПолучитьСделку(ID_Operation, dl_t))
    return FALSE;
    end;
/*
    [OF1.dot];
    println(GenFileName());

    СформироватьРаспоряжениеВБухгалтерию(Date, "погашение векселей", dl_t, DecType[11], DecPurp[6]);*/
/* Attributs end */

/* Attributs begin 2 */

    СформироватьРаспоряжениеВДепозитарий(CDate, "погашение векселей", dl_t, DecType[10], "OF2.dot");
/* Attributs end 2 */

    return TRUE;
END;

/* Макрос постобработки 
*/
MACRO PostStep (    
                CommitOrRollback, /*1-выполнение шага,2 -откат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    if (errTrn OR (CommitOrRollback==2)) 
        /* Произошла ошибка или происходит откат */
        return;
    end;

    PrintDecAccOpen(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);
    
    PrintDec(AUTO_PRINT, ID_Operation, ID_Step);

    return 1;

END;


/* Макрос печати 
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    PrintDecAccOpen(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    PrintDec(MAN_PRINT, ID_Operation, ID_Step);

    exit(1);

END;
