/*
$Name:         var060.mac
$Module:       Учтенные векселя
$Description:  Погашение векселей. Т.исполнение требований

            va-вексель
             r-операция погашения векселей (repayment)
           060-номер (соответствующий шагу)
*/

IMPORT VAInter, DealsInter,
       vacateg, vaacc, va4each, vsbnrfd, vatickfd, varepay, vamisc, vaprdec, vaprdeca, vaprdslib,
       varsrvbk, vapaym, dl_voop, vainner, vafinres, vspmfutu, vaovernvpi, vaobs;

PRIVATE VAR
           ИнтегрРежимРаботы = false,
           StepDate = {curdate},                /* Дата выполнения шага */
           pm_obj,                              /* класс платежа */
           ВалРасчетов = NATCUR,                /* Валюта расчетов (ВР) */
           Profit = null,                       /* информация о доходах */
           _ID_Operation = 0,
           _ID_Step = 0,
           FiidGroups = null,                   /* группы для ФИ векселей */
           EnrolFiidGroups = null;

/* Проводки по оплате векселей.
*/
PRIVATE MACRO BkpPayBanners(tick, СчетКредит)
var
    fd,
    CurDbt = NATCUR, CurCrd = ВалРасчетов,
    SumDbt = 0, SumCrd = 0, Sum = pm_obj.OrderAmount,
    СчетДебет,
    Purpose = "",
    stat = 0;

    if(ИнтегрРежимРаботы) // оплата должна была произойти на шаге квитовки
       return true;
    end;

    //код валютной операции платежа, если есть
    Purpose = DL_VOOP_MakeBPassGround2_VA( pm_obj.StrDocumentID, "Исполнение требований по погашению векселей в операции погашения №"+tick.DealCode+" от "+tick.DealDate );

    if((fd = VATickFD(tick)) == null)
       stat = VA_Err("Ошибка при определении первичного документа сделки");
    else
       if(pm_obj.PayerBankID == {OurBank})
          CurDbt = pm_obj.PayerFIID;
          СчетДебет = pm_obj.PayerAccount;
       else
          CurDbt = pm_obj.FuturePayerFIID;
          СчетДебет = pm_obj.FuturePayerAccount;
       end;

    end;

    if(stat != 0)
       /* уже ошибка */;
    elif(CurDbt == CurCrd)
       /* одновалютная проводка */
       stat = VA_Bookpass(СчетДебет, СчетКредит, Sum, Purpose,
                      pm_obj.PaymentID,  /* Платеж */
                      PMMET_ID,          /* Т.к. платеж и проводка не на одном шаге */
                      CurDbt,
                      null, null, StepDate
                     );
    else
      SumDbt = VA_Convert(Sum, StepDate, pm_obj.OrderFIID, CurDbt);
      SumCrd = VA_Convert(Sum, StepDate, pm_obj.OrderFIID, CurCrd);
      if(not VA_MBookpass(0,
                       CurDbt, СчетДебет, SumDbt,
                       CurCrd, СчетКредит, SumCrd,
                       Purpose,
                       null, null,
                       null, StepDate))
         stat = VA_Err("Ошибка при выполнении проводки",
                       "|по оплате клиентских векселей");
      end;
    end;

    return (stat == 0);
END;

/* Проводки в сделке с клиентом.
         1.1.1. Проводка "ОплатаКлВекс" к платежу с назначением $(Погашение ОД)
*/
PRIVATE MACRO DoBkpsWithClient(tick)
var
    stat = 0;

    if(not BkpPayBanners(tick, pm_obj.ReceiverAccount))
      stat = 1;
    end;

    return stat;
END;

/* класс с информацией по группе с ФИ векселей
*/
PRIVATE CLASS FiidGrp (TheFIID, TheAccDbt, TheAcc, TheAmount, ThePayAmount)
var
   FIID, AccDbt, acc, amount, payamount;

   FIID    = TheFIID;
   acc     = TheAcc;
   AccDbt  = TheAccDbt;
   amount  = TheAmount;
   payamount = ThePayAmount;
END;

/* Класс: группы векселей по Fiid
*/
CLASS FiidGroupsClass (p_IsEnrol)
 var
  stat = 0,
  IsEnrol = p_IsEnrol,
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(fiid, AccDbt, acc, sum, paysum)
   ArrGrp[ArrGrp.size] = FiidGrp(fiid, AccDbt, acc, sum, paysum);
  END;

  PRIVATE MACRO find(Fiid, accDbt, acc)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].FIID == Fiid) AND (ArrGrp[i].acc == acc) AND (ArrGrp[i].accDbt == accDbt))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, amount, payamount)
     ArrGrp[i].amount = ArrGrp[i].amount + amount;
     ArrGrp[i].payamount = ArrGrp[i].payamount + payamount;
  END;

  MACRO group(fiid, AccDbt, payamount, acc, sum)
   var i = find(fiid, AccDbt, acc);
     if(i == -1)
        newGrp(fiid, AccDbt, acc, sum, payamount);
     else
        add (i, sum, payamount);
     end;
  END;

  MACRO makeBookpass(tick, Purpose)
    var
       i = 0, stat = 0, SumDbt = 0, fd, ВалДеб, ВалКред,
       СчетДоход, СчетРасход;

    while((stat == 0) AND (i < ArrGrp.size))
      if(IsEnrol)
        ВалДеб = ВалРасчетов;
        ВалКред = ArrGrp[i].fiid;
      else
        ВалДеб = NATCUR;
        ВалКред = ArrGrp[i].fiid;
      end;

      if(ВалДеб == ВалКред)
         /* одновалютная проводка */
         stat = VA_Bookpass(ArrGrp[i].AccDbt, ArrGrp[i].acc, ArrGrp[i].amount, Purpose,
                        0, 0,               /* Платеж */
                        ВалДеб,
                        null, null, StepDate
                       );
      else
         /* многовалютная проводка */
         SumDbt = ArrGrp[i].payamount;//VA_Convert(ArrGrp[i].amount, StepDate, ArrGrp[i].fiid, ВалДеб);
         if(not VA_MBookpass(0,
                          ВалДеб, ArrGrp[i].AccDbt, SumDbt,
                          ВалКред, ArrGrp[i].acc, ArrGrp[i].amount,
                          Purpose,
                          null, null,
                          null, StepDate))
            stat = VA_Err("Ошибка при выполнении проводки",
                          "|", Purpose);
         end;
      end;
      i = i + 1;
    end;
    return stat;
  END;

END;

/* Группирует векселя по валютам.
*/
PRIVATE MACRO GroupsByFiid(bnr, leg, tick, numOrd, lnk, IncGroup)
var
   fd, tickfd, stat = 0, acc, AccDbt, Sum = 0, SumVN = 0, SumDbt = 0, ВалУч;

   fd = VSBannerFD (bnr, leg, tick.BofficeKind, tick);
   tickfd = VATickFD(tick);

   ВалУч = fd.ОпределитьВалютуУчета();

   if( not VA_GetAccount("Реализация, УВ", tickfd, AccDbt, MC_OPENACC_CREATE, NATCUR, null, null, StepDate))
      stat = 1;
   elif(not VA_GetAccount("Учтенные векселя", fd, acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
       stat = 1;
   else

       SumVN = БалансоваяСтоимостьВекселяВН(bnr.rec.BCID, StepDate);
       Sum   = БалансоваяСтоимостьВекселяВУ(bnr.rec.BCID, StepDate) + IncGroup.GetIncSummBalOverAcc(bnr.rec.BCID);

       SumDbt = VA_Convert(Sum, StepDate, ВалУч, NATCUR);

       FiidGroups.group(ВалУч, AccDbt, SumDbt, acc, Sum);

       if( not VA_SaveIncomeSum(VSINCOMETYPE_ACCOUNTEDSUM, bnr.rec.BCID, VA_GetLastAccountedEnrolmentID(bnr.rec.BCID), date(StepDate), -SumVN, leg.rec.PFI, -Sum, ВалУч) )
         stat = VA_Err("Не удалось сохранить запись о списании балансовой стоимости в истории" );
       end;

   end;

   return stat;
END;

PRIVATE MACRO EnrolGroupsByFiid(bnr, leg, tick, numOrd, lnk, СчетДебет)
 var
   tickfd, fd, stat = 0, acc, AccDbt, SumDbt, Sum = 0;

   fd = VSBannerFD (bnr, leg, tick.BofficeKind, tick);
   tickfd = VATickFD(tick);

   if( not VA_GetAccount("Реализация, УВ", tickfd, acc, MC_OPENACC_CREATE, NATCUR, null, null, StepDate))
       stat = 1;
   else
       if(ValType(СчетДебет) != V_UNDEF)
         AccDbt = СчетДебет;
       end;
       if(lnk.rec.BCCost == NATCUR)
          Sum = lnk.rec.BCCost;
       else
          /* нужна конверсия суммы */
          Sum = VA_Convert(lnk.rec.BCCost, StepDate, lnk.rec.BCCFI, NATCUR);
       end;

       if(ВалРасчетов == lnk.rec.BCCFI)
          SumDbt = lnk.rec.BCCost;
       else
          /* нужна конверсия суммы */
          SumDbt = VA_Convert(lnk.rec.BCCost, StepDate, lnk.rec.BCCFI, ВалРасчетов);
       end;

       EnrolFiidGroups.group(NATCUR, AccDbt, SumDbt, acc, Sum);
   end;

   return stat;
END;

PRIVATE MACRO ВыполнитьПереоценкуНВПИВекселей(bnr, leg, tick, numOrd, lnk, IncGroup)
  var stat = 0;

  stat = ПереоценкаНВПИВекселя(bnr.rec.BCID, StepDate, IncGroup);

  return stat;
END;

/* Проводки "СписБал"
*/
PRIVATE MACRO BkpWriteOff(tick, СчетДебет)
var stat = 0;

    var IncGroup = VACollectIncome(StepDate);

    var PrDsParm = VAPrDsParm(@IncGroup, _ID_Operation, _ID_Step, true);

    var ResGroup = VACollectReserv(StepDate);

    //зачисление погашения на счет Реализация
    if ( (not ИнтегрРежимРаботы) or (pm_obj.PayerBankID == {OurBank}) )
      EnrolFiidGroups = FiidGroupsClass(true);
      stat = VA_ForEachBanner(tick, @EnrolGroupsByFiid, VSORDLNK_K_ALL, СчетДебет);
      if(stat == 0)
        stat = EnrolFiidGroups.makeBookpass(tick, "Оплата векселей по погашению №"+tick.DealCode+" от "+tick.DealDate);
      end;
    else
      //а в интегрированном режиме эта проводка выполнялась на шаге Квитовки
    end;

    if(not stat)
      stat = VA_ForEachBanner(tick, @ВыполнитьПереоценкуССОднойЦБ, VSORDLNK_K_ALL, StepDate, "BL");
    end;

    if(not stat)
      stat = VA_ForEachBanner(tick, @ВыполнитьДоначислениеОднойЦБ, VSORDLNK_K_ALL, PrDsParm, "BL");
    end;

    if(not stat)
      stat = VA_ForEachBanner(tick, @ДоначислениеРезерваПриВыбытие, VSORDLNK_K_ALL, ResGroup, "BL");
    end;

    //списание балансовой стоимости
    if(not stat)
      FiidGroups = FiidGroupsClass(FALSE);
      stat = VA_ForEachBanner(tick, @GroupsByFiid, VSORDLNK_K_ALL, IncGroup);
      if(stat == 0)
         stat = FiidGroups.makeBookpass(tick, "Списание балансовой стоимости векселей в связи с погашением №"+tick.DealCode+" от "+tick.DealDate);
      end;
    end;

    if(not stat)
      stat = VA_ForEachBanner(tick, @УчетКорректировокОтПереоценки, VSORDLNK_K_ALL, PrDsParm.IncGroup, "BL");
    end;

    if(not stat)
      stat = VA_ForEachBanner(tick, @ПризнаниеДоходовРасходовОтПереоценкиПриВыбытии, VSORDLNK_K_ALL, StepDate, "BL");
    end;

    if(not stat)
      stat = VA_WriteOffReserve_Retirement(tick, ResGroup);
    end;

    if(not stat)
      stat = VA_ForEachBanner(tick, @СписаниеПроцентовИДисконтаСРеализации, VSORDLNK_K_ALL, PrDsParm.IncGroup);
    end;

    if(not stat)
      stat = VA_FinResult(tick, _ID_Operation, StepDate, PrDsParm.IncGroup, ВалРасчетов, ResGroup);
    end;

    if( not stat )
      VA_ClosePcAccounts(tick, StepDate);
    end;

    return (stat == 0);
END;

/* Выполняет проводку по отражению дохода
*/
PRIVATE MACRO DoProfit(tick, dbt, crd, Sum, Purpose, ВалДебет, ВалКредит)
var
   stat = 0,
   fd, SumDbt, SumCrd, СчетДоход, СчетРасход;

   if(ВалРасчетов == NATCUR)
      /* одновалютная проводка */
      stat = VA_Bookpass(Dbt, crd, Sum, Purpose,
                     0, 0,               /* Платеж */
                     NATCUR,
                     null, null, StepDate
                    );
   else
      /* многовалютная проводка */
      SumDbt = VA_Convert(Sum, StepDate, ВалДебет, NATCUR);
      SumCrd = VA_Convert(Sum, StepDate, ВалКредит, NATCUR);
      if((fd = VATickFD(tick)) == null)
         stat = VA_Err("Ошибка при определении первичного документа сделки");
      elif(not VA_GetAccount("+БМаржаП,ср-ва в ин.вал.", fd, СчетДоход, MC_OPENACC_CREATE, null, null, null, StepDate))
         stat = 1;
      elif(not VA_GetAccount("-БМаржаП,ср-ва в ин.вал.", fd, СчетРасход, MC_OPENACC_CREATE, null, null, null, StepDate))
         stat = 1;
      elif(not VA_MBookpass(0,
                       ВалДебет, Dbt, SumDbt,
                       ВалКредит, Crd, SumCrd,
                       Purpose,
                       СчетДоход, СчетРасход,
                       null, StepDate))
         stat = VA_Err("Ошибка при выполнении проводки",
                       "|", Purpose);
      end;
   end;

   return stat;
END;

MACRO ПроводкаИспПросрочТр(tick, paym_obj, IsExternPaym)
  var
   stat = 0, acc, data, 
   Purpose,
   pm_trans: RsbPaymTransaction,
   tickfd = VATickFD(tick);

   if(paym_obj.Purpose == PM_PURP_PRINC_RET)
    Purpose = String("Погашение просроч. задолженности основного долга по операции погашения №"+tick.DealCode+" от "+tick.DealDate);
   elif(paym_obj.Purpose == PM_PURP_PERCENT)
    Purpose = String("Погашение просроч. задолженности по процентам по операции погашения №"+tick.DealCode+" от "+tick.DealDate);
   end;

   if(IsExternPaym)
     paym_obj.FuturePayerAccount = paym_obj.GetCorAccount ("Д");
   end;

   pm_trans = paym_obj.MakeTransaction();

   if (pm_trans != NULL)
       pm_trans.Sum = paym_obj.FuturePayerAmount;

       //код валютной операции платежа, если есть
       pm_trans.Ground = DL_VOOP_MakeBPassGround2_VA( paym_obj.StrDocumentID, Purpose );
       pm_trans.Shifr_Oper = VA_GetShifrOper(pm_trans.AccountPayer, pm_trans.FIIDPayer, pm_trans.AccountReceiver, pm_trans.FIIDReceiver, pm_trans.Chapter);

       if (not pm_trans.Carry())
           stat = VA_Err("Ошибка при создании проводки по платежу");
       end;
   else
       stat = VA_Err("Ошибка при создании объекта класса RsbPaymTransaction");
   end;

   return stat;
END;

MACRO PaymentOverdueArrears(tick, payms)
  var stat = 0,
      paym_obj = MyRsbPayment( payms.rec.PaymentID );

  if (paym_obj.PayerAccount == "")
    stat = VA_Err("Ошибка при формировании платежа|Не задан счет плательщика");
  elif(paym_obj.ReceiverBankID != {OurBank})
    // счет получателя не в нашем банке
    return stat;
  elif( paym_obj.PaymStatus == PM_CLOSED_W_M_MOVEMENT )
    return stat;
  elif((paym_obj.PayerBankID == {OurBank}) AND (paym_obj.ReceiverBankID == {OurBank})) // Платеж - внутренний

    stat = ПроводкаИспПросрочТр(tick, paym_obj, false);

  else  // Платеж - внешний

    if(ИнтегрРежимРаботы)
      if((paym_obj.PayerBankID != {OurBank}) AND (paym_obj.FuturePayerAmount != 0))
        stat = VA_Err("Плановый платеж не скитован полностью");
      end;
    else
      stat = ПроводкаИспПросрочТр(tick, paym_obj, true);
    end;

  end;

  return stat;
  
END;

/* Проводки в сделке без клиента.
         1.2.1  Был перенос на просрочку? Оплачиваем просроченные задолженности
         1.3.1  Иначе 
           1.3.2. Проводка "ОплатаСвоихВекс" к платежу с назначением $(Погашение ОД)
         1.2.2. Проводки "СписБал"
         1.2.3. Проводка "Доход"
*/
PRIVATE MACRO DoBkpsWithoutClient(tick)
var stat = 0;

    if(VA_IsPaymentWasOverdue(pm_obj.PaymStatus, pm_obj.PaymentID))
      if(VA_ForEachPaym(tick, PM_PURP_PRINC_RET, @PaymentOverdueArrears))
        stat = 1;
      elif(VA_ForEachPaym(tick, PM_PURP_PERCENT, @PaymentOverdueArrears))
        stat = 1;
      end;
    else
      if((pm_obj.PayerBankID != {OurBank}))
        pm_obj.FuturePayerAccount = pm_obj.GetCorAccount ("Д");
      end;

      if(not BkpWriteOff(tick, pm_obj.FuturePayerAccount))
         stat = 1;
      end;
    end;

    return stat;
END;

/* Проводки
     1. Если
     режтм работы модуля неинтегрированный
     или счет плательщика в платеже находится в нашем банке
       1.1. Если в сделке указан клиент
         1.1.1. Проводка "ОплатаКлВекс" к платежу с назначением $(Погашение ОД)
       1.2. Иначе
         1.2.1  Был перенос на просрочку? Оплачиваем просроченные задолженности
         1.3.1  Иначе 
           1.3.2. Проводка "ОплатаСвоихВекс" к платежу с назначением $(Погашение ОД)
         1.2.2. Проводки "СписБал"
         1.2.3. Проводка "Доход"

*/
PRIVATE MACRO DoBkps(tick)
var
    stat = 0;

    if(VA_IsClient(tick))
       stat = DoBkpsWithClient(tick);
    else
       stat = DoBkpsWithoutClient(tick);
    end;

    return (stat == 0);
END;

/* Установить платежу статус "закрыт"
*/
PRIVATE MACRO SetFinishedToPaym(tick)
var
    stat = 0;

    // Установить статус "закрыт" всем платежам по активу
    VA_SetStatOfPayms(tick, BAi, PM_FINISHED, StepDate);
    VA_SetStatOfPayms(tick, PM_PURP_PRINC_RET, PM_FINISHED, StepDate);
    VA_SetStatOfPayms(tick, PM_PURP_PERCENT, PM_FINISHED, StepDate);

    return (stat == 0);
END;

/* Установка состояния векселя
*/
PRIVATE MACRO SetABCStatToEnded(bnr, leg, tick, numOrd, lnk)
var
   stat = 0;

   if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate,
                                  "abcstatus", VABANNER_STATUS_ENDED,
                                  "repaymentdate", StepDate ))
      stat = VA_Err("Ошибка при установке",
                    "|для векселя ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber),
                    "|статуса Погашен");
   end;

   if(stat == 0)
      if(Index(bnr.rec.BCState, "П") != 0)
         if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "rmbcstate", "П"))
            stat = VA_Err("Ошибка при снятии",
                          "|для векселя ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber),
                          "|состояния ", "<", GetTypeAc(170, "П"), ">");
         end;
      end;
   end;

   if(stat == 0)
      if(Index(bnr.rec.BCState, "Ч") != 0)
         if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "rmbcstate", "Ч"))
            stat = VA_Err("Ошибка при снятии",
                          "|для векселя ", bnr.rec.BCSeries, " № ", trim(bnr.rec.BCNumber),
                          "|состояния ", "<", GetTypeAc(170, "Ч"), ">");
         end;
      end;
   end;

   return stat;
END;

/* Установить векселям статус "погашен"
*/
PRIVATE MACRO SetEndedToBanners(tick)
var
    stat = 0;

    stat = VA_ForEachBanner(tick, @SetABCStatToEnded, VSORDLNK_K_ALL, null, "B");

    return (stat == 0);
END;

/* Запуск шага
     1. Если
     режтм работы модуля неинтегрированный
     или счет плательщика в платеже находится в нашем банке
       1.1. Если в сделке указан клиент
         1.1.1. Проводка "ОплатаКлВекс" к платежу с назначением $(Погашение ОД)
       1.2. Иначе
         1.2.1. Проводка "ОплатаСвоихВекс" к платежу с назначением $(Погашение ОД)
         1.2.2. Проводки "СписБал"
         1.2.3. Проводка "Доход"

     2. Плановому платежу установить статус "закрыт".

     3. Для каждого векселя
       3.1. Установить статус векселя $(погашен).
*/
MACRO ExecuteStep(Buffer, dl_tick, DocKind, ID_Operation, ID_Step)
var
    stat = 0, paym = TBfile("pmpaym.dbt");

    record tick( dl_tick );
    SetBuff( tick, dl_tick );

    _ID_Operation = ID_Operation;
    _ID_Step = ID_Step;

    GetOprDate( DATE_REP_PAY, @StepDate );

    if( StepDate > {curdate} )
       return VA_Err("Преждевременное выполнение шага запрещено.");
    end;

    VA_Get1stPlanPaym(tick.BofficeKind, tick.DealID, PM_PURP_PRINC_RET, paym);

    if(paym.rec.FuturePayerAccount == "")//Simanov
       return VA_Err("Ошибка при формировании платежа|Не задан счет плательщика");
    end;

    pm_obj = MyRsbPayment( paym.rec.PaymentID );
    ВалРасчетов = pm_obj.PayerFIID;

    if(not VA_IS_INTEGRATED(@ИнтегрРежимРаботы))
       stat = 1;
    end;

    if((ИнтегрРежимРаботы) AND (pm_obj.PayerBankID != {OurBank}) AND (pm_obj.FuturePayerAmount != 0))
       stat = VA_Err("Плановый платеж не скитован полностью");
    end;

    if((stat == 0) and not DoBkps(tick))
       stat = 1;
    end;

    if((stat == 0) and not SetFinishedToPaym(tick))
       stat = 1;
    end;


    if((stat == 0) and not SetEndedToBanners(tick))
       stat = 1;
    end;

/*Simanov
    if((stat == 0) and not VA_InnerMoney_Repay(tick, StepDate, УВПолучСумПогаш))
       stat = 1;
    end;
Simanov*/

    return stat;
END;

/* Функция печати распоряжений
*/
PRIVATE MACRO PrintDec(ManPr, ID_Operation, ID_Step)
VAR CDate;

    if((NOT (ManPr > 0)) AND (NOT (AutoPrint())))
        return FALSE;
    end;

    CDate = GetPlanDate(ID_Operation, ID_Step);

    InitDecType(DecType);
    InitDecPurp(DecPurp);
    InitOpType(OpType);

    record dl_t (dl_tick);

/* Attributs begin */
    if (NOT ПолучитьСделку(ID_Operation, dl_t))
    return FALSE;
    end;

    СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[2], dl_t, "OF11.dot", DecType[11], DecPurp[10], ID_Operation, ID_Step);

    СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[2], dl_t, "OF13.dot", DecType[13], DecPurp[18], ID_Operation, ID_Step);

    СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[15], dl_t, "OF15.dot", DecType[14], DecPurp[21], ID_Operation, ID_Step);

/* Attributs end */

    return TRUE;
END;

/* Макрос постобработки
*/
MACRO PostStep (
                CommitOrRollback, /*1-выполнение шага,2 -откат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    if (errTrn OR (CommitOrRollback==2))
        /* Произошла ошибка или происходит откат */
        return;
    end;

    PrintDec(AUTO_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    return 1;

END;

/* Макрос печати
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    PrintDec(MAN_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    exit(1);

END;
