/*
$Name:         vakvits.mac
$Module:       Учтенные векселя
$Description:  у.Квитовка платежей
*/
IMPORT PaymInter, valib, vamisc, vabkpnum, vaprdec, vaprdeca, "mc_lib.mac", dlkvitcmn;
import oralib, likepy, PTInter, usr_connect_attr;

private record tick( dl_tick );

private macro GetUserField4 (PaymID)
  var u4 = "";
  var sql = ExecSqlselect("select t_userfield4 from dpmpaym_dbt where t_paymentid = "+PaymID);
  if (sql.MoveNext() )
    u4 = sql.value(0);
  end;
  return u4;
End;

private macro GetPartyName (PartyID)
  var ptname = "";
  var sql = ExecSqlselect("select t_name from dparty_dbt where t_partyid = " + PartyID);
  if (sql.MoveNext() )
    ptname = sql.value(0);
  end;
  return ptname;
End;

/* Квитовка платежей, размерности массивов PlanIDs и FactIDs одинаковые.
*/
PRIVATE MACRO КвитовкаПлатежа(PlanIDs, FactIDs)
var 
    stat = 0, 
    fact, plan,
    pml = TRecHandler("pmlink.dbt"),
    СчетНевПоступления = "",
    i = 0;

    while( i < PlanIDs.size )
        fact = RsbPayment(FactIDs[i]);
        plan = RsbPayment(PlanIDs[i]);

        if(fact.FuturePayerAccount != "")
          СчетНевПоступления = Unkn_GetAccountPassive( {OperDprt}, fact.PayerFIID); //Получить счет "НевПоступления"
          if((СчетНевПоступления == fact.FuturePayerAccount) and (fact.PayerFIID == plan.PayerFIID))
            plan.FuturePayerAccount = СчетНевПоступления;
          end;
        end;

        pml.rec.Amount = min(fact.FuturePayerAmount, plan.FuturePayerAmount);
        pml.rec.FIID = plan.BaseFIID;
        pml.rec.IPSign = "-";
        pml.rec.PPSign = ""; // сумма c FuturePayerAmount факт. платежа спишется в проводках
        stat = plan.LinkPayment(fact, PMLINK_KIND_KVITING, pml);
        if(stat)
           DisplayError();
           VA_Err("Ошибка при выполнении|квитовки планового платежа " + PlanIDs[i] + "|с фактическим платежом " + FactIDs[i]);
           return false;
        end;

        i = i + 1;
    end;

    return (stat == 0);
END;


/* Массивы с информацией о исполняемых платежах для квитовки 
   Инициализируются бэк-офисом 
*/
VAR PlanIDs     = TArray;
VAR FactIDs     = TArray;
VAR KvitAmounts = TArray;
VAR ExecDate;

PRIVATE var StepDate; // Дата шага (дата проводки док-тов)


/* Класс - параметры квитовки
*/
PRIVATE CLASS KvitParms ()
private var
  Payms = TArray;
  var MaxPaymsSum = 0;

  PRIVATE CLASS KvitPair(id, sum)
      var PaymID = id, PaymSum = sum;
  END;

  MACRO GetPaymSum(id) /* возвращает платеж */
    var i = 0;
    while(i < Payms.size)
        if(id == Payms(i).PaymID)
            return Payms(i).PaymSum;
        end;
        i = i + 1;
    end;

    return -1;
  END;

  MACRO Add(id, sum) /* возвращает платеж */
    var i = 0;
    while(i < Payms.size)
        if(id == Payms(i).PaymID)
            return;
        end;
        i = i + 1;
    end;
    Payms(Payms.size) = KvitPair(id, sum);
  END;

  MACRO Minus(id, sum) /* возвращает платеж */
    var i = 0;
    while(i < Payms.size)
        if(id == Payms(i).PaymID)
            Payms(i).PaymSum = Payms(i).PaymSum - sum;
            return;
        end;
        i = i + 1;
    end;
  END;

  private macro SetMaxPaymSum ()
    var i = 0;
    while (i < Payms.size)
      MaxPaymsSum = MaxPaymsSum + Payms(i).PaymSum;
      i = i + 1;
    end;
  End;

  macro Init ()
    SetMaxPaymSum();
  End;
END;


/* Класс ПД для определения дополнительных счетов (пока это здесь, больше ничего и не надо)
*/
private class PrimDOC( DocKind : integer, DocID : integer )

  var Kind : integer;
  var Id   : integer;

  var Error : integer;

/* Вернуть параметр второго рода */
macro GetParametr( ParmKind, OperDate, CatCode, FIRole )
  if(ParmKind == MC_TYPE_PARAMETR_DEPARTMENT)
    return 0;
  end;
  return -1;
end;

/* вернуть параметр первого рода */
macro GetParametrTemplate( ObjectID, Classificator, OperDate, FIRole )
  return -1;
end;

/* Основная роль ФИ */
macro GetBasisFIRole(FIRole)
  return FIROLE_UNDEF;
end;

/* Корректировка счета  */
macro CorrectAccount( account, accblnc, ORScheme, categ, templ, accdoc, OperDate )
  return 0;
end;

/* Конструктор */
  Kind = DocKind;
  Id   = DocID;

  Error = 0;
end;


PRIVATE MACRO PmBookpass(pm,
                   BpGround,                          /* основание проводки */
                   CreditAccount, CreditAccountFIID,  /* счет кредита с валютой */
                   MinorAmount, MinorFIID,            /* сумма проводки с валютой */
                   MinorCrossRate,                    /* курс конверсии Minor'а к дебету */
                   MinorCreditCrossRate,              /* курс конверсии Minor'а к кредиту */
                   IsPartOfMain,
                   Date_Carry,
                   Number_Pack,
                   Numb_Document,
                   Result_Carry
                   )
   var
       paymtr, pd, uf4;

   paymtr = pm.MakeTransaction(CreditAccount, CreditAccountFIID,
                                 MinorAmount, MinorFIID,
                                 MinorCrossRate, MinorCreditCrossRate);
   if( paymtr == NULL )
     VA_Err("Ошибка при создании проводки по платежу");
     return false;
   end;

   if( ValType(IsPartOfMain) != V_Undef ) paymtr.IsPartOfMain = IsPartOfMain; end;

   VA_ByDefault(Date_Carry,     {curdate});
   VA_ByDefault(Result_Carry,   1);
   VA_ByDefault(BpGround,       pm.Ground);
   VA_ByDefault(CreditAccount,  pm.FutureReceiverAccount);

   if(CreditAccount == "")
     VA_Err("Не задан счет получателя в платеже");
     return false;
   end;

   //Выгрузка проводок обратно в БИС для редактирования платежа
   if (Number_Pack == 170)
     uf4 = GetUserField4(pm.PaymentID);
     paymtr.Numb_Document = uf4;
     paymtr.UserField1 = "ENCASH:" + uf4;
   else
     paymtr.Numb_Document = VA_GetBookpassNum(pm.FuturePayerAccount,
                                              CreditAccount, pm.PayerFIID, 1);
   end;

   paymtr.Chapter     = 1;
   paymtr.Date_Carry  = Date_Carry;
   paymtr.ResultCarry = Result_Carry;
   paymtr.Kind_Oper   = " 1";
   paymtr.Ground      = BpGround;
   paymtr.Number_Pack = Number_Pack;
   paymtr.UserField3  = "1"; //автовыгрузка

   if( not paymtr.Carry )
     VA_Err("Ошибка при проводке по платежу");
     return false;
   end;

   if (paymtr.Number_Pack == 170)
     Connect_attr_from_paym_to_trn(pm.PaymentID, paymtr.acctrnid, 102, 102);
   end;

   return true;
end;


PRIVATE MACRO ВыполнитьПроводки(parms)
var 
  i = 0, Sum, needToClose = false,
  planpaym, factpaym, Number_Pack;

  while (i < PlanIDs.size)
    if((planpaym = RsbPayment(PlanIDs(i))) == null)
      VA_Err ("Не найден платеж ", planpaym.PaymentID);
      return false;
    elif( (planpaym.PayerBankID == {OurBank}) and (not ВнешПлатПоСхРасч(planpaym.PaymentID)) )
      VA_Err("Квитовка внутренних платежей не поддерживается");
      return false;
    elif( (planpaym.Purpose != CAi) 
      and (planpaym.Purpose != PM_PURP_VSBARTERDIFF) 
      and (planpaym.Purpose != PM_PURP_PRINC_RET)
      and (planpaym.Purpose != PM_PURP_PERCENT))
         /* платеж - не оплата, пропускаем */;
    elif((factpaym = RsbPayment(FactIDs(i))) == null)
      VA_Err ("Не найден платеж ", FactIDs(i));
      return false;
    end;

    if (planpaym.ReceiverAccount == factpaym.ReceiverAccount) 
      if ( parms.MaxPaymsSum == factpaym.BaseAmount ) //Попадается платёж, совпавший по сумме с требованием => пачка 50, в БИС не выгружается
        //Number_Pack = 50;
        // BIQ-8464 ответная проводка всегда выгружается в АБС, пачка всегда 170 
        Number_Pack = 170;
      elif ( parms.MaxPaymsSum < factpaym.BaseAmount ) //Попался платёж по сумме больше требования => С этого платежа будут квитоваться и другие требования => пачка 170, в БИС выгружается
        Number_Pack = 170;
      elif ( parms.MaxPaymsSum > factpaym.BaseAmount ) // Попался платёж по сумме меньше требования => Если платеж уже где-то квитовался, то пачка 170, иначе 50
        //Number_Pack = ifThenElse(factpaym.FuturePayerAmount < factpaym.BaseAmount, 170, 50);
        // BIQ-8464 ответная проводка всегда выгружается в АБС, пачка всегда 170 
        Number_Pack = 170;
      end;
    else
      Number_Pack = 170;
    end;

    Sum = min(parms.GetPaymSum(PlanIDs(i)), KvitAmounts(i));

    needToClose = false;

    if(Sum > factpaym.FuturePayerAmount)
      VA_Err("Сумма фактического платежа меньше суммы планового.");
      return false;
    elif(Sum == factpaym.FuturePayerAmount)
      needToClose = true;
    end;

    if(not PmBookpass(factpaym,
                      "Исполнение требований по сделке "+ifThenElse(tick.BofficeKind==142, "погашения", "продажи")+" учтенных векселей "+tick.DealCode+" с контрагентом "+GetPartyName(tick.PartyID)+" от "+string(tick.DealDate:f),
                      planpaym.ReceiverAccount,            // CreditAccount
                      planpaym.ReceiverFIID,               // CreditAccountFIID
                      Sum,                                 // MinorAmount
                      factpaym.ReceiverFIID,               // MinorFIID
                      null,
                      null, null,
                      StepDate,
                      Number_Pack
                    ))
      return false;
    else
      parms.Minus(PlanIDs(i), Sum);
      if(needToClose)
          factpaym.PaymStatus = PM_FINISHED;
          factpaym.ValueDate  = StepDate;
      end;
    end;
    
    i = i + 1;
  end;

  return true;
END;


/* Запуск шага
*/
MACRO ExecuteStep(Buffer, dl_tick)
var
    ИнтегрРежимРаботы = false, stat = 0;
    
    SetBuff( tick, dl_tick );

    // инициализация массива сумм плановых платежей
    var i = 0, parms = KvitParms();
    while(i < PlanIDs.size)
        parms.Add(PlanIDs(i), RsbPayment(PlanIDs(i)).FuturePayerAmount);
        i = i + 1;
    end;
    parms.Init();

    if( ExecDate > {curdate} )
       return VA_Err("Преждевременное выполнение шага запрещено.");
    end;

    if(not VA_IS_INTEGRATED(@ИнтегрРежимРаботы))
       stat = 1;
    elif(not ИнтегрРежимРаботы)
      stat = VA_Err("Квитовка платежей не предусмотрена");
    elif(not КвитовкаПлатежа(PlanIDs, FactIDs))
      stat = 1;
    elif(not ВыполнитьПроводки(parms))  
      stat = 1;
    end;

    return stat;
END;


/* Функция печати распоряжений
*/
PRIVATE MACRO PrintDec(ManPr, ID_Operation, ID_Step, Kind_Operation)
VAR CDate;

    if((NOT (ManPr > 0)) AND (NOT (AutoPrint())))
        return FALSE;
    end;

    CDate = GetPlanDate(ID_Operation, ID_Step);

    InitDecType(DecType);
    InitDecPurp(DecPurp);
    InitOpType(OpType);

    record dl_t (dl_tick);

/* Attributs begin */
    if (NOT ПолучитьСделку(ID_Operation, dl_t))
    return FALSE;
    end;

    if(VA_IsSale(Kind_Operation))
        СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[1], dl_t, "OF11.dot", DecType[11], DecPurp[4], ID_Operation, ID_Step);
    elif(VA_IsExchange(Kind_Operation))
        СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[7], dl_t, "OF12.dot", DecType[11], DecPurp[11], ID_Operation, ID_Step);
    else
        СформироватьРаспоряжениеВБухгалтерию(CDate, OpType[2], dl_t, "OF11.dot", DecType[11], DecPurp[10], ID_Operation, ID_Step);
    end;
/* Attributs end */

    return TRUE;
END;

/* Макрос постобработки 
*/
MACRO PostStep (    
                CommitOrRollback, /*1-выполнение шага,2 -отакат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */
  var sql;

  if (errTrn OR (CommitOrRollback == 2)) 
      /* Произошла ошибка или происходит откат */
      return;
  end;

  sql = "delete from dpmdocs_dbt "
      + "where t_acctrnid in (select t_acctrnid from doprdocs_dbt doc "
      + "                     where t_id_operation = " + ID_Operation
      + "                           and t_dockind = 1 "
      + "                           and t_id_step = " + ID_Step
      + "                           and exists (select 1 from dacctrn_dbt where t_acctrnid = doc.t_acctrnid and t_number_pack = 170)) ";
  ExecSql(sql);

  PrintDec(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation);

  PrintDecAccOpen(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

  return 1;
END;


/* Макрос печати 
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    PrintDec(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation);

    PrintDecAccOpen(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);
    exit(1) ;
END;
