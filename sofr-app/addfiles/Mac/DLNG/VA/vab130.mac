/*
$Name:         vab130.mac
$Module:       Учтенные векселя
$Description:  Покупка векселей. Т.исполнение требований

            va-вексель
             b-операция покупки векселей (buy)
           130-номер (соответствующий шагу)
*/

IMPORT VAInter, DealsInter, vaendor, vacateg, vaacc, va4each, vsbnrfd, vabuy, vatickfd, vadepo,
       vamisc, vaprdec, valib, vaprdeca, varsrvbk, vapaym, vainner, vaovernvpi, vacar, "vasc.mac",
       vaobs, vaprmrflctfr;

PRIVATE VAR
           StepDate = {curdate},           /* Дата выполнения шага */
           RegDate = {curdate},            /* дата учета */
           ВалРасчетов = NATCUR,
           FstBai = TBfile("pmpaym.dbt"),  /* первый платеж по активу сделки */
           FstCai = TBfile("pmpaym.dbt"),  /* первый платеж по контрактиву сделки */
           VaGroups = null,                /* группы для счетов категории "Учтенные векселя" */
           VaBonusGroups = null,
           WithDepositary = false,
           OurBannersInDepository = false,
           REQ_role, ActPurp, DealCode;

/* Актуализируем счета векселя
*/
PRIVATE MACRO АктСчетВекселя(bnr, leg, tick, numOrd, lnk)
var stat = 0;

    stat = VA_ActualizeBnrAccounts(bnr, leg, tick, lnk, MC_OPENACC_CHECKPERIOD, StepDate);

    return stat;
END;

/* Актуализирует счета векселей
*/
PRIVATE MACRO СчетаВекселей(tick)
var stat = 0;

    stat = VA_ForEachBanner(tick, @АктСчетВекселя, VSORDLNK_K_BUY);

    return (stat == 0);
END;

/* Проверка индоссаментного ряда для векселя.
*/
PRIVATE MACRO TestEndor(bnr, leg, tick, numOrd, lnk)
   return VA_TestEndor(bnr, tick, StepDate, true);
END;

/* Проверка индоссаментного ряда для векселей.
*/
PRIVATE MACRO TestEndorsements(tick)
var
    WithEndorsement = false, stat = 0;

    if(not VA_Check_WithEndorsement(@WithEndorsement))
       stat = 1;
    elif(not WithEndorsement)
       /* ничего не делаем */
    else
       stat = VA_ForEachBanner(tick, @TestEndor, VSORDLNK_K_BUY, null, "B");
    end;

    return (stat == 0);
END;

/* класс с информацией по группе "Учтенные векселя"
*/
PRIVATE CLASS VaGrp (TheFiid, TheAcc, TheAmount, ThePayAmount)
var
   FIID, acc, amount, payamount;

   FIID    = TheFiid;
   acc     = TheAcc;
   amount  = TheAmount;
   payamount = ThePayAmount;

END;

/* Класс: группы векселей по "Учтенным векселям"
*/
CLASS VaGroupsClass ()
 var
  stat = 0,
  ArrGrp = TArray; /* Массив групп  */

  ArrGrp.size = 0;

  PRIVATE MACRO newGrp(fiid, acc, amount, payamount)
   ArrGrp[ArrGrp.size] = VaGrp(fiid, acc, amount, payamount);
  END;

  PRIVATE MACRO find(Fiid, acc)
   var i = 0;
    while (i < ArrGrp.size)
      if((ArrGrp[i].FIID == Fiid) AND (ArrGrp[i].acc == acc))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  PRIVATE MACRO add (i, amount, payamount)
     ArrGrp[i].amount = ArrGrp[i].amount + amount;
     ArrGrp[i].payamount = ArrGrp[i].payamount + payamount;
  END;

  MACRO group(Fiid, acc, amount, payamount)
   var i = find(Fiid, acc);
     if(i == -1)
        newGrp(fiid, acc, amount, payamount);
     else
        add (i, amount, payamount);
     end;
  END;

  MACRO makeBookpass(fd, Ground)
    var
       i = 0, stat = 0, Purpose, SummaCrd,
       ConvDate = date(0, 0, 0),
       СчетДоход, СчетРасход,
       СчетКредит,
       tick = fd.GetTick();

    if(VA_IsPaymentWasOverdue(FstBai.rec.PaymStatus, FstBai.rec.PaymentID))
       if((Ground != null) and (Ground != ""))
         Purpose = Ground;
       else
         Purpose = String("Погашение просроч. задолженности по поставке ц/б по сделке покупки векселей № " + DealCode + " от " + tick.DealDate);
       end;
       ConvDate = StepDate; // фактическая (она же плановая) дата требований
       if(not VA_GetAccount("Треб. с н.с.", fd, СчетКредит, MC_OPENACC_CREATE, ВалРасчетов, REQ_role, null, StepDate))
         stat = 1;
       end;
    else
       if((Ground != null) and (Ground != ""))
         Purpose = Ground;
       else
         Purpose = String("Приобретение векселей, сделка № " + DealCode + " от " + tick.DealDate);
       end;
       ConvDate = StepDate; // плановая дата требований
       if(not VA_GetAccount("+Форвард, расчеты", fd, СчетКредит, MC_OPENACC_CREATE, ВалРасчетов, REQ_role, null, StepDate))
         stat = 1;
       end;
    end;

    while((stat == 0) AND (i < ArrGrp.size))
      if(ArrGrp[i].fiid == ВалРасчетов)
         /* одновалютная проводка */
         stat = VA_Bookpass(ArrGrp[i].acc,
                            СчетКредит,
                            ArrGrp[i].amount,
                            Purpose,
                            0, 0,               /* Платеж */
                            ВалРасчетов,
                            null, null, StepDate,
                            null, null,
                            null, null,
                            "18"
                           );
      else
         /* многовалютная проводка */
         SummaCrd = ArrGrp[i].payamount;//VA_Convert(ArrGrp[i].amount, ConvDate, ArrGrp[i].fiid, ВалРасчетов, stat);
         if(stat != 0)
            // ошибка
         elif(not VA_MBookpass(0,
                               ArrGrp[i].fiid, ArrGrp[i].acc, ArrGrp[i].amount,
                               ВалРасчетов, СчетКредит, SummaCrd,
                               Purpose,
                               null, null,
                               null, StepDate,
                               null, "18"))
            stat = VA_Err("Ошибка при выполнении проводки",
                          "|по конверсии");
         end;
      end;
      i = i + 1;
    end;
    return stat;
  END;

END;

/* Формирование отложенных распоряжений в депозитарий
*/
PRIVATE MACRO MakeDepoDrafts(tick)
var
   stat = 0;

   stat = VA_ForEachPaym(tick, ActPurp, @VA_MakeDepoDraft);

   return (stat == 0);
END;

/* Группирует векселя по однородным группам счетов категории "Учтенные векселя".
*/
PRIVATE MACRO GroupsByVa(bnr, leg, tick, numOrd, lnk)
   var fd, acc, Sum, PaySum, stat = 0, ВалУч;
   var НачальнаяПремияВН = $0, НачальнаяПремияВУ = $0, НачальнаяПремияВР = $0;
   var НачальныйДисконтВН = $0, НачальныйДисконтВУ = $0;
   var СуммаУчетаВУ, СуммаУчетаВР, СуммаУчетаВН;
   var СуммаОплатыВР;
   var ConvDate = date(0,0,0);
   var СтоимостьПоставкиВН = 0.0;
   var СС_ПФИ = $0.0; //справедливая стоимость ПФИ в рублях

   fd = VSBannerFD(bnr, leg, tick.BofficeKind, tick);

   ВалУч = fd.ОпределитьВалютуУчета();

   if(FstCai.rec.PaymStatus == PM_FINISHED) //если оплата уже выполнена
     ConvDate = FstCai.rec.ValueDate;

     //1. Сколько заплатили в ВР
     СуммаОплатыВР = VA_Convert(lnk.rec.BCCost, ConvDate, lnk.rec.BCCFI, ВалРасчетов);

     //2. Сумма оплаты в ВН по курсу на дату поставки (StepDate)
     СтоимостьПоставкиВН = VA_Convert(СуммаОплатыВР, StepDate, ВалРасчетов, leg.rec.PFI);

     НачальнаяПремияВН = СтоимостьПоставкиВН - leg.rec.Principal;
     if(НачальнаяПремияВН < $0)
       НачальныйДисконтВН = -НачальнаяПремияВН;
       НачальныйДисконтВУ = VA_Convert(НачальныйДисконтВН, StepDate, leg.rec.PFI, ВалУч);
       НачальнаяПремияВН = $0;
     end;

     НачальнаяПремияВУ = VA_Convert(НачальнаяПремияВН, StepDate, leg.rec.PFI, ВалУч);
     НачальнаяПремияВР = VA_Convert(НачальнаяПремияВН, StepDate, leg.rec.PFI, ВалРасчетов);

     СуммаУчетаВР = СуммаОплатыВР - НачальнаяПремияВР;
     СуммаУчетаВН = СтоимостьПоставкиВН-НачальнаяПремияВН;
     if(ВалРасчетов == ВалУч)
       СуммаУчетаВУ = СуммаУчетаВР;
     else
       СуммаУчетаВУ = VA_Convert(СуммаУчетаВН, StepDate, leg.rec.PFI, ВалУч);
     end;

   else
     //оплаты ещё не было
     ConvDate = StepDate;

     СтоимостьПоставкиВН = VA_Convert(lnk.rec.BCCost, StepDate, lnk.rec.BCCFI, leg.rec.PFI);

     НачальнаяПремияВН = СтоимостьПоставкиВН - leg.rec.Principal;
     if(НачальнаяПремияВН < $0)
       НачальныйДисконтВН = -НачальнаяПремияВН;
       НачальныйДисконтВУ  = VA_Convert(НачальныйДисконтВН, StepDate, leg.rec.PFI, ВалУч);
       НачальнаяПремияВН = $0;
     end;

     НачальнаяПремияВУ = VA_Convert(НачальнаяПремияВН, StepDate, leg.rec.PFI, ВалУч);
     НачальнаяПремияВР = VA_Convert(НачальнаяПремияВН, StepDate, leg.rec.PFI, ВалРасчетов);

     СуммаУчетаВР = VA_Convert(СтоимостьПоставкиВН, ConvDate, leg.rec.PFI, ВалРасчетов, stat) - НачальнаяПремияВР;
     СуммаУчетаВН = СтоимостьПоставкиВН - НачальнаяПремияВН;
     if(lnk.rec.BCCFI == leg.rec.PFI) //чтобы лишний раз не конвертировать
       СуммаУчетаВУ = VA_Convert(СуммаУчетаВН, StepDate, leg.rec.PFI, ВалУч);
     elif(ВалРасчетов == ВалУч)
       СуммаУчетаВУ = СуммаУчетаВР;
     else
       СуммаУчетаВУ = VA_Convert(СуммаУчетаВР, StepDate, ВалРасчетов, ВалУч);
     end;
   end;

/*Зачем к цене учета прибавляется ещё учтенная СС ???
   СС_ПФИ = УВ_ПолучитьУчтеннуюСС(bnr.rec.BCID, tick.DealID, StepDate);
   if (abs(СС_ПФИ) > $0.0)
      СуммаУчетаВН = СуммаУчетаВН + VA_Convert(СС_ПФИ, StepDate, NATCUR, leg.rec.PFI);// из рублей в ВУ
      СуммаУчетаВУ = СуммаУчетаВУ + VA_Convert(СС_ПФИ, StepDate, NATCUR, ВалУч);// из рублей в ВУ
      СуммаУчетаВР = СуммаУчетаВР + VA_Convert(СС_ПФИ, StepDate, NATCUR, ВалРасчетов); // из рублей в ВР
   end;
*/
   if(НачальнаяПремияВН != $0)
     if(not VA_GetAccount("Премия, вексель", fd, acc, MC_OPENACC_CREATE, ВалУч, FIROLE_BONUS, null, StepDate))
       stat = 1;
     else
       VaBonusGroups.group(ВалУч, acc, НачальнаяПремияВУ, НачальнаяПремияВР);
     end;
   end;

   if(not stat)
     if(not VA_GetAccount("Учтенные векселя", fd, acc, MC_OPENACC_CREATE, ВалУч, null, null, StepDate))
       stat = 1;
     else
       VaGroups.group(ВалУч, acc, СуммаУчетаВУ, СуммаУчетаВР);
     end;
   end;

   if(not stat)
     if((leg.rec.Formula != VS_IN_DISCONT) and (leg.rec.Formula != VS_IN_DISC_PC) and (НачальныйДисконтВН != $0))
       if(ВексельПроцентный(leg))
         VA_ChangeDL_LEG(leg.rec.ID, "Formula", VS_IN_DISC_PC);
       else
         VA_ChangeDL_LEG(leg.rec.ID, "Formula", VS_IN_DISCONT);
       end;
     elif(((leg.rec.Formula == VS_IN_DISCONT) or (leg.rec.Formula == VS_IN_DISC_PC)) and (НачальнаяПремияВН != $0))
       if(ВексельПроцентный(leg))
         VA_ChangeDL_LEG(leg.rec.ID, "Formula", VS_IN_S_PC);
       else
         VA_ChangeDL_LEG(leg.rec.ID, "Formula", VS_IN_UNKNOWN);
       end;
     end;
   end;

   if(not stat)
     if( not VA_SaveIncomeSum(VSINCOMETYPE_ACCOUNTEDSUM, bnr.rec.BCID, 0/*т.к. на одном шаге - заполнится автоматом*/, date(StepDate), СуммаУчетаВН, leg.rec.PFI, СуммаУчетаВУ, ВалУч) )
       stat = VA_Err("Не удалось сохранить запись об учтенной сумме в истории для ц/б сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber));
     end;
   end;

   if((not stat) and (НачальнаяПремияВН))
     if( not VA_SaveIncomeSum(VSINCOMETYPE_BONUSSUM, bnr.rec.BCID, 0/*т.к. на одном шаге - заполнится автоматом*/, date(StepDate), НачальнаяПремияВН, leg.rec.PFI, НачальнаяПремияВУ, ВалУч) )
       stat = VA_Err("Не удалось сохранить запись о сумме премии в истории для ц/б сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber));
     end;
   end;

   if((not stat) and (НачальныйДисконтВН))
     if( not VA_SaveIncomeSum(VSINCOMETYPE_FIRSTDISC, bnr.rec.BCID, 0/*т.к. на одном шаге - заполнится автоматом*/, date(StepDate), НачальныйДисконтВН, leg.rec.PFI, НачальныйДисконтВУ, ВалУч) )
       stat = VA_Err("Не удалось сохранить запись о сумме начального дисконта в истории для ц/б сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber));
     end;
   end;

   return stat;
END;

/* Проводки: ИспТреб
*/
PRIVATE MACRO BkpPerform(tick)
var
    stat = 0, fd;

    VaGroups = VaGroupsClass();
    VaBonusGroups = VaGroupsClass();
    stat = VA_ForEachBanner(tick, @GroupsByVa, VSORDLNK_K_BUY, null, "BL");
    DealCode = tick.DealCode;

    if(stat == 0)
       // Выполнение проводки: "учет суммовой разницы"
       stat = ПереоценкаНВПИПоПоставкеПриПокупке(tick, ВалРасчетов, StepDate, REQ_role);

       if(stat == 0)
         if(VA_IsBuyCrushing(tick, VA_IsBuyByIssuer(tick)))
             //Simanov return true; // в режиме разбиения платежей при покупке у векселедателя проводка не нужна
         end;

         if((fd = VATickFD(tick)) == null)
             stat = VA_Err("Ошибка при определении первичного документа сделки");
         else
             stat = VaBonusGroups.makeBookpass(fd, "Премия по ц/б по сделке приобретения векселей № "+tick.DealCode+" от "+tick.DealDate);
             if(not stat)
               stat = VaGroups.makeBookpass(fd);
             end;
         end;
       end;
    end;

    return (stat == 0);
END;

/* Изменение статуса и состояния векселя.
*/
PRIVATE MACRO SetABCStatToAccount(bnr, leg, tick, numOrd, lnk)
var
   stat = 0;

   if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "abcstatus", VABANNER_STATUS_ACCOUNT))
     stat = VA_Err("Ошибка при определении первичного документа сделки");
   end;

   if(Index(bnr.rec.BCState, "Р") != 0)
     if(not ИзменитьУчтенныйВексель(bnr.rec.BCID, StepDate, "rmbcstate", "Р"))
       stat = VA_Err("Ошибка при определении первичного документа сделки");
     end;
   end;

   return stat;
END;

/* Установка статусов и состояний векселей.
*/
PRIVATE MACRO SetABCStatus(tick)
var
    stat = 0;

    stat = VA_ForEachBanner(tick, @SetABCStatToAccount, VSORDLNK_K_BUY, null, "B");

    return (stat == 0);
END;

/* Делай "раз"
   - проверка индоссаментного ряда.
   - проводки: ИспТреб
   - установка статус векселя (ABCStatus) в значение "учтен".
*/
PRIVATE MACRO Point1(tick)
var
    stat = 0;

    if(not VA_IsClient(tick))
      if((tick.AvoirKind == AVOIRISSKIND_BILL) and not TestEndorsements(tick))
        stat = 1;
      end;

      if((stat == 0) and not BkpPerform(tick))
        stat = 1;
      end;

      if( (stat == 0) and not ОпределениеПараметровОтражениеCущественнойРазницыСС(tick) )
        stat = 1;
      end;   
    end;

    if(stat == 0)
//Simanov      stat = УВ_УчетВекселейПоСделкеНаВнебалансе(tick, StepDate);
    end;

    if((stat == 0) and not SetABCStatus(tick))
      stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "два".
     Формируем отложенные распоряжения в депозитарий.
*/
PRIVATE MACRO Point2(tick)
    var stat = 0;

    // если установлен признак работы с депозитарием
    // и если сделка собственная и включена настройка УВ В ДЕПОЗИТАРИИ или если сделка клиентская,
    // то формируем отложенные распоряжения
    if(WithDepositary and (VA_IsClient(tick) or OurBannersInDepository) and not MakeDepoDrafts(tick))
        stat = 1;
    end;

    return (stat == 0);
END;

/* Делай "три".
     Установить статус "закрыт" всем платежам по активу.
     Если init == true, делаем платежам Actuate,
     иначе - устанавливаем статус
*/
PRIVATE MACRO Point3(tick, init)
    if(init == true)
       return VA_ActuatePayms(tick, ActPurp, StepDate);
    else
       return VA_SetStatOfPayms(tick, ActPurp, PM_FINISHED, StepDate);
    end;
    return true;
END;

PRIVATE MACRO CheckNumberSeriesOneBnr(bnr, leg, tick, numOrd, lnk)
    if ((Trim(bnr.rec.BCNumber) == "") or (Trim(bnr.rec.BCSeries) == ""))
       return 1;
    else
       return 0;
    end;
END;

/* Проверяем заполнены ли серия и номера векселей */
PRIVATE MACRO CheckNumberSeries(tick)
var
    stat = 0;

    stat = VA_ForEachBanner(tick, @CheckNumberSeriesOneBnr, VSORDLNK_K_BUY, null, "B");

    return (stat == 0);
END;

PRIVATE MACRO ПроводкиВнутреннгоУчета(tick, НазначениеПлатежа)
    var Основание;

     if (VA_IsBuy(tick.DealType))
        Основание = VA_GRNUM_SBAY_EREQ;
     else
        MsgBox("Не найдено основание проводки внутреннего учета для сделки: ",tick.DealCode);
        return false;
     end;

     if(not VA_InnerFI(tick, StepDate, Основание, НазначениеПлатежа, УВПоставкаЦБ))
        return false;
    end;

    return true;
END;

PRIVATE MACRO InsertOneVSASGMT(bnr, leg, tick, numOrd, lnk)
   if( VA_IsSale(tick.DealType))
     InsertVSASGMT(bnr.rec.BCID, StepDate, {OurBank}, tick.PartyID );
   else
     InsertVSASGMT(bnr.rec.BCID, StepDate, tick.PartyID, {OurBank} );
   end;

   return 0;
END;

MACRO InsertVSASGMTforCERT(tick)
  var Type = VSORDLNK_K_BUY;

  if( VA_IsSale(tick.DealType))
    Type = VSORDLNK_K_SALE;
  end;

  if( tick.AvoirKind == AVOIRISSKIND_DEPOSIT_CERTIFICATE )
    VA_ForEachBanner(tick, @InsertOneVSASGMT, Type, null, "B");
  end;

END;

/* Запуск шага
   Алгоритм:
   1  Если в сделке не указан клиент, то:
   1.1 Для каждого векселя:
       Производится проверка индоссаментного ряда. Если последний индоссамент,
       индоссант которого - не наш банк,
       и дата которого не превышает текущую дату, - бланковый,
       то проверка не выполняется. В индоссаменте по данной сделке в
       качестве индоссанта должен быть указан контрагент по сделке,
       а дата - равна текущей дате.
       В случае обнаружения ошибки, выдается сообщение
       "Неверный индоссаментный ряд",
       и шаг не выполняется.
   1.2. Проводки: ИспТреб
   2. Установить статус векселей (ABCStatus) в значение "учтен".
   3. Если установлен признак работы с депозитарием
   3.1.  Сформировать отложенные распоряжения в депозитарий (см. проект Кобякова
               "Импорт в депозитарий").
   4. Установить статус "закрыт" всем платежам по активу.
*/
MACRO ExecuteStep(Buffer, dl_tick, DocKind, ID_Operation)
    var CactPurp, stat = 0, PDate = ZeroDate;
    record tick(dl_tick);

    SetBuff(tick, dl_tick);
    var tickFd = VATickFD(tick);

    REQ_role = FIROLE_FIREQ;
    GetOprDate(DATE_BUY_SUPPLY, @StepDate);
    ActPurp = BAi;
    CactPurp = CAi;
    GetOprDate(DATE_BUY_REG, RegDate); // Дата учета

    if(not CheckNumberSeries(tick))
        stat = VA_Err("Нельзя выполнить шаг, к сделке привязаны ц/б, у которых не указана серия либо номер");
    end;

    if((stat == 0) and not CheckNumberSeries(tick))
        stat = VA_Err("Нельзя выполнить шаг, к сделке привязаны ц/б, у которых не указана серия либо номер");
    end;

    if((stat == 0) and (StepDate > {curdate}))
        stat = VA_Err("Преждевременное выполнение шага запрещено");
    end;

    if((stat == 0) and (tick.flag2 == "X") and not VA_GetPerformDate("Ч", ID_operation, @PDate))
        stat = VA_Err("Не выполнен шаг оформления договора");
    end;

    if(stat == 0)
        VA_Get1stPlanPaym(tick.BofficeKind, tick.DealID, ActPurp, FstBai);

        if(VA_Get1stPlanPaym(tick.BofficeKind, tick.DealID, CactPurp, FstCai))
            ВалРасчетов = FstCai.rec.PayFIID;
        end;
    end;

    if((stat == 0) and not СчетаВекселей(tick))
        stat = 1;
    end;

    if((stat == 0) and not Point3(tick, true)) // Актуализировать платежи
        stat = 1;
    end;

    if((stat == 0) and not VA_WorkWithDepositary(@WithDepositary))
        stat = 1;
    end;

    if((stat == 0) and not VA_OurBannersInDepository(@OurBannersInDepository))
        stat = 1;
    end;

    if((stat == 0) and not Point1(tick)) // делай "раз"
        stat = 1;
    end;

    if((stat == 0) and not Point2(tick)) // делай "два"
        stat = 1;
    end;

    if((stat == 0) and not Point3(tick, false)) // делай "три"
        stat = 1;
    end;

    if((stat == 0) and not ПроводкиВнутреннгоУчета(tick, ActPurp)) // проводка внутреннего учета
        stat = 1;
    end;

    //if((stat == 0) and (VA_WriteOffReserve_Deal(tick, StepDate) != 0)) // Списание резерва по сделке
    //    stat = VA_Err("Ошибка при списании резерва");
    //end;

    if(stat == 0)
        InsertVSASGMTforCERT(tick);
    end;

    if(stat == 0)
        stat = VA_ChangePcAccBeginDate(tick, StepDate);
    end;

    return stat;
END;

PRIVATE MACRO PrintDec(ManPr, ID_Operation, ID_Step)
VAR CDate, StrType;

    if((NOT (ManPr > 0)) AND (NOT (AutoPrint())))
        return FALSE;
    end;

    CDate = GetPlanDate(ID_Operation, ID_Step);

    InitDecType(DecType);
    InitDecPurp(DecPurp);

    record dl_t (dl_tick);

/* Attributs begin */
    if (NOT ПолучитьСделку(ID_Operation, dl_t))
    return 0;
    end;

    СформироватьРаспоряжениеВБухгалтерию(CDate, "покупка векселей", dl_t, "OF1.dot", DecType[11], DecPurp[5], ID_Operation, ID_Step);
/* Attributs end */

/* Attributs begin 2 */

    GetDepoKindStr(dl_t, @StrType);
    СформироватьРаспоряжениеВДепозитарий(CDate, "покупка векселей", dl_t, StrType, "OF2.dot");
/* Attributs end 2 */

END;

/* Макрос постобработки
*/
MACRO PostStep (
                CommitOrRollback, /*1-выполнение шага,2 -откат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FirstDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    if (errTrn OR (CommitOrRollback==2))
        /* Произошла ошибка или происходит откат */
        return;
    end;

    PrintDec(AUTO_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(AUTO_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    return 1;

END;

/* Макрос печати
*/
MACRO PrintStepDocs (
                ID_Operation,  /* Номер экземпляра операции */
                ID_Step,       /* Номер шага операции */
                Kind_Operation,/* Вид операции */
                KindStep)      /* Вид шага операции */

    PrintDec(MAN_PRINT, ID_Operation, ID_Step);

    PrintDecAccOpen(MAN_PRINT, ID_Operation, ID_Step, Kind_Operation, OpAccTemplName);

    exit(1);
END;
