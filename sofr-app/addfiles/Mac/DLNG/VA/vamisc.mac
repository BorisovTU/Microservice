/*
$Name:         vamisc.mac
$Module:       Учтенные векселя
$Description:  Различные функции
*/

IMPORT RsbDataSet, BankInter, FIInter, CTInter, OprInter, DealsInter, VSInter, Проценты, Календарь,
       va4each, vaacc, valib, vaconv, vaopr, vatickfd, vsbnrfd, vabuy, vasale, vabart, dlvaprds, vafrfun;

PRIVATE VAR
            TheDate = {curdate},
            TheCur = NATCUR;

/* Считает сумму сделки на TheDate в валюте TheCur
*/
PRIVATE MACRO GetTickSum(bnr, leg, tick, numOrd, lnk, Sum:@variant)
var stat = 0;

   if(lnk.rec.BCCFI == TheCur)
      Sum = Sum + lnk.rec.BCCost;
   else
      /* нужна конверсия суммы */
      Sum = Sum + VA_Convert(lnk.rec.BCCost, TheDate, lnk.rec.BCCFI, TheCur, @stat);
   end;

   return stat;
END;

/* Получить сумму сделки на дату OnDate в валюте InCur
*/
MACRO VA_GetTickSum(tick, Sum:@variant, OnDate, InCur, Role)
var stat;
   Sum = 0;
   VA_ByDefault(OnDate, {curdate});
   VA_ByDefault(InCur, NATCUR);
   VA_ByDefault(Role,  VSORDLNK_K_ALL);
   TheDate = OnDate;
   TheCur = InCur;
   stat = VA_ForEachBanner(tick, @GetTickSum, Role, @Sum, "L");
   return (stat == 0);
END;

MACRO VA_GetStepDate( DateType, StepDate:@variant )
var
    Date = {curdate};

    GetOprDate( DateType, Date );
    if({curdate} < Date)
       StepDate = {curdate};
    else
       StepDate = Date;
    end;

END;

/* Определяет сумму проводки: номинал + %% на текущую дату
*/
MACRO VA_GetNominalAndPerc(leg, OnDate, Sum:@variant)
   var prccontract = TRecHandler("prccontract");
   var BCID;
   var Perc:double = 0.0;

   if(ValType(leg) == V_GENOBJ)
     BCID = leg.rec.DealID;
   else
     BCID = leg.DealID;
   end;

   Sum = leg.rec.Principal;

   if(ВексельПроцентный(leg))
     if(not НайтиСчетПроцВекселя(prccontract, BCID))
       return VA_Err("Не найден процентный договор для ц/б");
     else
       if(ПроцентыКНачислениюПоПДВекселя(prccontract.rec.ContractID, VS_GetRightPcDate(prccontract, OnDate), Perc))
         Sum = Sum + ПолучитьСуммуПДД(BCID, VA_GetLastAccountedEnrolmentID(BCID), FIROLE_PERCENT, OnDate) + Perc;
       end;
     end;
   end;

   return true;
END;

// Сделка для клиента?
MACRO VA_IsClient(tick)
var
   ClientID = -1, otype = ValType(tick);

   if(otype == V_STRUC)
      ClientID = tick.ClientID;
   elif(otype == V_GENOBJ)
      ClientID = tick.rec.ClientID;
   end;

   return (ClientID != -1) AND (ClientID != {OurBank});
END;

// Найти наибольшую _плановую_ дату _исполненного_ шага
MACRO VA_GetLastExecutedStepDate(ID_Operation, Plan_Date:@variant)
var
    ok = false,
    oprstep = TRsbDataSet("SELECT t_Plan_Date FROM doprstep_dbt "
                          "WHERE t_ID_Operation = " + ID_Operation + " AND t_IsExecute LIKE 'X' "
                          "ORDER BY t_Plan_Date DESC");

    ok = oprstep.MoveNext();
    if(ok)
       Plan_Date = oprstep.rec.Plan_Date;
    end;

    return ok;
END;

// Поиск шага "Закрытие" (шаг с символом 'З')
MACRO ПоискШагаЗакрытие(tick)
var oprstep = TRsbDataSet("SELECT step.t_Plan_Date FROM doprstep_dbt step, doproper_dbt oper " +
                          "WHERE oper.t_ID_Operation = step.t_ID_Operation " +
                           " AND oper.t_DocKind = " + tick.BofficeKind +
                           " AND oper.t_DocumentID LIKE '" + UniID( tick, OBJTYPE_VEKSELACCOUNTED ) + "'" +
                           " AND oper.t_Start_Date = TO_Date( '" + tick.DealDate + "', 'DD.MM.YYYY')" +
                           " AND step.t_Symbol = 'З'");
    return oprstep.MoveNext();
END;

// Получить дату постановки векселя на баланс, ID сделки, цену векселя и валюту цены по этой сделке
//    (дату поставки из посл. покупки),
// не раньше BoundDate
MACRO VA_GetBalanceDate(BCID, BoundDate, BalanceDate:@date, DealID:@variant, Cost:@money, CostFI:@variant, DealType:@variant, DealCode:@variant, SetDealID, ClientID, SaleID)
var stat = false;

   VA_ByDefault(BoundDate, {curdate});
   VA_ByDefault(SetDealID, 0);

   stat = DL_VA_GetBalanceDate(BCID, BoundDate, @BalanceDate, @DealID, @Cost, @CostFI, @DealType, @DealCode, null, SetDealID, NULL, ClientID, SaleID);

   return stat;
END;

MACRO УВ_НачислятьПремию()
  var stat = 0;
  var val = false;

  if(not VS_GetRegistryValue("УЧТЕННЫЕ ВЕКСЕЛЯ\\РЕЖИМ РАБОТЫ\\НАЧИСЛЕНИЕ ПРЕМИЙ", V_BOOL, @val))
    VA_Err("Ошибка при определении настройки|", "УЧТЕННЫЕ ВЕКСЕЛЯ\\РЕЖИМ РАБОТЫ\\НАЧИСЛЕНИЕ ПРЕМИЙ");
  end;

  return val;
END;

//Стоимость Векселя по цене покупки (сколько заплатили за вексель в ВР)
macro СтоимостьВекселяПоЦенеПокупки(BCID, OnDate, BuyCost:@variant, BuyCostFI:@variant, BuyPayDate:@variant)
  var BalanceDate, BuyDealID, Cost, CostFI, DealType, DealCode;
  var fd = VSBannerFD(DL_VSBANNER, BCID);
  var lnkLast = TBfile("vsordlnk"), tickLast = TBfile("dl_tick"), PaymC = TBfile("pmpaym.dbt");

  if((VA_GetBalanceDate(BCID, OnDate, @BalanceDate, @BuyDealID, @Cost, @CostFI, @DealType, @DealCode)) and
     (fd.VAGetLastBuy(lnkLast, tickLast)) and
     (VA_Get1stPlanPaym(tickLast.rec.BofficeKind, tickLast.rec.DealID, CAi, PaymC))
    )

    BuyCostFI  = PaymC.rec.PayFIID;
    BuyPayDate = PaymC.rec.ValueDate;

    BuyCost = VA_Convert(Cost, BuyPayDate, CostFI/*ВЦ*/, BuyCostFI); //это сколько реально заплатили в покупке в ВР
  end;

  return 0;
END;

/* Рассчитать сумму дисконта на дату
*/
MACRO УВ_ПолучитьСуммуДисконтаНаДату(fd, VDate)
  var bnr = fd.GetBnr();
  var leg = fd.GetLeg();
  var tick = fd.GetTick();
  var P = 0, T = 0;
  var Днач = УВ_ПолучитьСуммуНачальногоДисконта(bnr, leg, VDate);
  var Драсч = $0;
  var DiscKind = 0, err = 0;
  var IncomeDateType = DL_INCOMEDATETYPE_PLUSONE;

  if(Днач > $0)
    T = VS_GetTermCircDate(bnr, leg); // срок обращения векселя (определяется от даты выпуска до плановой даты погашения включительно)

    if(T > 0)
      GetRegistryValue("ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\РАБОТА С НЕЭМИССИОННЫМИ ЦБ\\НАЧИСЛЕНИЕ ДИСКОНТА", V_INTEGER, DiscKind, err);

      if((bnr.rec.BCTermFormula == VS_TERMF_DURING) and (bnr.rec.BackOffice == "А"/*ДУ*/) and (not err) and (not DiscKind)) // по минимальному сроку
        if(bnr.rec.BCPresentationDate > ZeroDate)
          P = VDate - bnr.rec.BCPresentationDate;
        end;
      else
        P = VDate - VS_GetStartDate(bnr, leg);
      end;

      if(P > 0)
        if(bnr.rec.BCTermFormula != VS_TERMF_INATIME)
          if(DL_GetStartIncomeDateType(@IncomeDateType) and (IncomeDateType == DL_INCOMEDATETYPE_CBR))
            P = P + 1; // чтобы учесть дату начала, которая была потеряна при вычитании

            if((tick != null) or (VDate >= DL_GetBnrPlanRepayDate(bnr, leg)))
              P = P - 1; // в дату погашения саму дату погашения учитывать не нужно
            end;
          end;
        end;

        if(P > T)
          P = T;
        end;

        Драсч = Round(Днач * P / T, 2); // нужно до 2-х знаков здесь, в противном случае накапливается ошибка
      end;
    end;
  end;

  return Драсч;
END;

//получить сумму начальной премии по векселю в ВН
MACRO НачальнаяПремияПоВекселю(BCID, VDate)
  var StartBonus = 0.0;
  var Select, DataSet;

  Select = DL_RSDCommand("select cast(rsb_bill.GetVABnrStartBonusPFI(?, ?) as NUMBER(32,12)) as StartBonus from dual");
  Select.AddParam(BCID);
  Select.AddParam(VDate);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    StartBonus = DataSet.StartBonus;
  end;

  return StartBonus;
END;

//рассчитать сумму премии на дату
MACRO ПолучитьСуммуПремииНаДату(fd, VDate)
  var bnr = fd.GetBnr();
  var leg = fd.GetLeg();
  var tick = fd.GetTick;
  var P = 0, T = 0;
  var НачальнаяПремия = НачальнаяПремияПоВекселю(bnr.rec.BCID, VDate);
  var РассчитаннаяПремия = $0;
  var IncomeDateType = DL_INCOMEDATETYPE_PLUSONE;

  if(НачальнаяПремия > $0)
    T = VS_GetTermCircDate(bnr, leg); // срок обращения векселя (определяется от даты выпуска до плановой даты погашения включительно)

    if(T > 0)
      P = VDate - VS_GetStartDate(bnr, leg);

      if(P > 0)
        if(bnr.rec.BCTermFormula != VS_TERMF_INATIME)
          if(DL_GetStartIncomeDateType(@IncomeDateType) and (IncomeDateType == DL_INCOMEDATETYPE_CBR))
            P = P + 1; // чтобы учесть дату начала, которая была потеряна при вычитании

            if((tick != null) or (VDate >= DL_GetBnrPlanRepayDate(bnr, leg)))
              P = P - 1; // в дату погашения саму дату погашения учитывать не нужно
            end;
          end;
        end;

        if(P > T)
          P = T;
        end;

        РассчитаннаяПремия = Round(НачальнаяПремия * P / T, 2); // нужно до 2-х знаков здесь, в противном случае накапливается ошибка
      end;
    end;
  end;

  return РассчитаннаяПремия;
END;

//получить сумму несписанной премии на дату в ВН
//Фактически, это остаток на счете "Премия, вексель" для данного векселя, переведенный в ВН
MACRO ПолучитьОстатокПремииНаДатуВН(BCID, Дата)
  var RestBonus = 0.0;
  var Select, DataSet;

  Select = DL_RSDCommand("select cast(rsb_bill.GetVABnrRestBonusPFI(?, ?) as NUMBER(32,12)) as RestBonus from dual");
  Select.AddParam(BCID);
  Select.AddParam(Дата);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    RestBonus = DataSet.RestBonus;
  end;

  return RestBonus;
END;

//получить сумму несписанной премии на дату в ВУ
//Фактически, это остаток на счете "Премия, вексель" для данного векселя
MACRO ПолучитьОстатокПремииНаДатуВУ(BCID, Дата)
  var RestBonus = 0.0;
  var Select, DataSet;

  Select = DL_RSDCommand("select cast(rsb_bill.GetVABnrRestBonusAcc(?, ?) as NUMBER(32,12)) as RestBonus from dual");
  Select.AddParam(BCID);
  Select.AddParam(Дата);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    RestBonus = DataSet.RestBonus;
  end;

  return RestBonus;
END;

//получить остаточную покупную стоимость векселя на дату в ВН
MACRO ПолучитьОстаточнуюПокупнуюСтоимостьВН(BCID, Дата)
  var BuyCost = $0;
  var Select, DataSet;

  Select = DL_RSDCommand("SELECT cast((rsb_bill.GetVABnrAccountedCostPFI(?, ?) + NVL(rsb_bill.GetVABnrRestBonusPFI(?, ?), 0)) as NUMBER(32,12))  as BuyCost FROM dual");

  Select.AddParam(BCID);
  Select.AddParam(Дата);
  Select.AddParam(BCID);
  Select.AddParam(Дата);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    BuyCost = DataSet.BuyCost;
  end;

  return BuyCost;
END;

//получить остаточную покупную стоимость векселя на дату в ВУ
MACRO ПолучитьОстаточнуюПокупнуюСтоимостьВУ(BCID, Дата)
  var BuyCost = $0;
  var Select, DataSet;

  Select = DL_RSDCommand("SELECT cast((rsb_bill.GetVABnrAccountedCostAcc(?, ?) + NVL(rsb_bill.GetVABnrRestBonusAcc(?, ?), 0)) as NUMBER(32,12))  as BuyCost FROM dual");

  Select.AddParam(BCID);
  Select.AddParam(Дата);
  Select.AddParam(BCID);
  Select.AddParam(Дата);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    BuyCost = DataSet.BuyCost;
  end;

  return BuyCost;
END;

MACRO ПолучитьЦенуПокупкиБезПремииВУ(BCID, Дата)
  var BuyCost = $0;
  var Select, DataSet;

  Select = DL_RSDCommand(  "SELECT cast(rsb_bill.GetVABnrAccountedCostAcc(?, ?) as NUMBER(32,12)) - "
                         + "       NVL((SELECT t_AccPerc "
                         + "              FROM dvsincome_dbt "
                         + "             WHERE t_BCID = ? "
                         + "               AND t_IncomeType = ? "
                         + "               AND t_Enrolment_ID = rsb_bill.GetVABnrLastAccountedEnrolID(?) "
                         + "               AND t_EndDate = ? "
                         + "               AND t_Perc < 0 "
                         + "              ), 0) as BuyCost FROM dual");

  Select.AddParam(BCID);
  Select.AddParam(Дата);
  Select.AddParam(BCID);
  Select.AddParam(VSINCOMETYPE_ACCOUNTEDSUM);
  Select.AddParam(BCID);
  Select.AddParam(Дата);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    BuyCost = DataSet.BuyCost;
  end;

  return BuyCost;
END;

MACRO ПолучитьЦенуПокупкиБезПремииВН(BCID, Дата)
  var BuyCost = $0;
  var Select, DataSet;

  Select = DL_RSDCommand(  "SELECT cast(rsb_bill.GetVABnrAccountedCostPFI(?, ?) as NUMBER(32,12)) - "
                         + "       NVL((SELECT t_Perc "
                         + "              FROM dvsincome_dbt "
                         + "             WHERE t_BCID = ? "
                         + "               AND t_IncomeType = ? "
                         + "               AND t_Enrolment_ID = rsb_bill.GetVABnrLastAccountedEnrolID(?) "
                         + "               AND t_EndDate = ? "
                         + "               AND t_Perc < 0 "
                         + "              ), 0) as BuyCost FROM dual");

  Select.AddParam(BCID);
  Select.AddParam(Дата);
  Select.AddParam(BCID);
  Select.AddParam(VSINCOMETYPE_ACCOUNTEDSUM);
  Select.AddParam(BCID);
  Select.AddParam(Дата);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    BuyCost = DataSet.BuyCost;
  end;

  return BuyCost;
END;

// Получить ID операции для данной сделки
MACRO VA_GetID_OperationByDeal(DealID, ID_Operation:@variant)
var oproper = TRsbDataSet("SELECT t_ID_Operation FROM ddl_tick_dbt tick, doproper_dbt oproper"
                         " WHERE tick.T_DEALID = "+DealID+
                           " AND oproper.t_DocKind    = tick.t_BofficeKind"
                           " AND oproper.t_DocumentID = tick.T_DEALID"
                           " AND oproper.t_Start_Date = tick.t_DealDate");

    if(oproper.MoveNext)
       ID_Operation = oproper.ID_Operation;
       return true;
    end;

    return false;
END;

MACRO VA_Rep_InitProgress(n, head, stat)
    VA_ByDefault(stat, "~Alt-Break~ Прервать");
    VA_ByDefault(head, "Формирование отчета");

    InitProgress(n, stat, head);
END;

MACRO VA_IS_INTEGRATED(val:@variant)
var
  stat = 0;

  GetRegistryValue("COMMON\\WORK_MODE\\INTEGRATED",
                     V_BOOL, val, stat);

  if(stat != 0)
    VA_Err("Ошибка при определении настройки|",
           "COMMON\\WORK_MODE\\INTEGRATED"
          );
    return false;
  end;

  return true;

END;

MACRO VA_ДелатьПроводкуПоИсхПлатежам(result:@variant)
var
  stat = 0;

  GetRegistryValue("COMMON\\WORK_MODE\\ПРОВОДКА ПО ИСХОДЯЩИМ ПЛАТЕЖАМ",
                     V_BOOL, result, stat);

  if(stat != 0)
    VA_Err("Ошибка при определении настройки|",
           "COMMON\\WORK_MODE\\ПРОВОДКА ПО ИСХОДЯЩИМ ПЛАТЕЖАМ"
          );
    return false;
  end;

  return true;

END;

MACRO VA_IsBuyByIssuer(tick)
  var Select, DataSet;

  Select = DL_RSDCommand(  " select count(bnr.t_bcid) num from ddl_tick_dbt tick, dvsbanner_dbt bnr, dvsordlnk_dbt lnk "
                         + "  where lnk.t_bcid = bnr.t_bcid "
                         + "    and lnk.t_contractid = tick.t_dealid "
                         + "    and lnk.t_dockind = tick.t_bofficekind "
                         + "    and lnk.t_linkkind = ? /*1*/ "
                         + "    and bnr.t_issuer != tick.t_partyid"
                         + "    and tick.t_dealid = ? /*2*/ "
                         + "    and tick.t_bofficekind = ? /*3*/ ");
  Select.AddParam(VSORDLNK_K_BUY);   /*1*/
  Select.AddParam(tick.DealID);      /*2*/
  Select.AddParam(tick.BofficeKind); /*3*/

  DataSet = Select.execute();
  if(DataSet.moveNext() and (DataSet.num == 0))
    return true;
  end;

  return false;
END;

macro СостояниеВекселяНаДату(BCID, RepDate, Symbol)
  var DataSet, Select;

  Select = DL_RSDCommand( "select instr(rsb_bill.GetVABnrStateOnDate(? /*1*/, ? /*2*/), ? /*3*/) as sympos from dual" );

  Select.AddParam(BCID );     /*1*/
  Select.AddParam(RepDate );  /*2*/
  Select.AddParam(Symbol );   /*3*/

  DataSet = Select.Execute();

  if(DataSet.moveNext())
    return DataSet.sympos;
  end;
  return 0;
end;

macro ПодсистемаВекселяНаДату(BCID, RepDate)
  var DataSet, Select;

  Select = DL_RSDCommand( "select rsb_bill.GetVABnrBOOnDate(? /*1*/, ? /*2*/) as BO from dual" );

  Select.AddParam(BCID );     /*1*/
  Select.AddParam(RepDate );  /*2*/

  DataSet = Select.Execute();

  if(DataSet.moveNext())
    return DataSet.BO;
  end;
  return "";
end;

//подходит ли сделка для переоценки НВПИ сделок на балансе
MACRO СделкаДляПереоценкиНВПИНаБалансе(tick, Дата)
  var Select, DataSet;

  if(tick.BOfficeKind != DL_VEKSELACCOUNTED)
    return false;
  end;

  if((not VA_IsBuy(tick.DealType)) and (not VA_IsSale(tick.DealType)))
    return false;
  end;

  //условия отбора
  //- дата постановки сделки на баланс не превышает дату операции,
  //- оплата по состоянию на дату операции еще не исполнена,
  //- ВЦ != ВР.

  Select = DL_RSDCommand(  " select deal.t_DealID "
                         + "   from ddl_tick_dbt deal, doproper_dbt opr, doprkdate_dbt kdate, doprdates_dbt odate"
                         + "  where deal.t_DealID = ? /*1*/ "
                         + "    and opr.t_DocKind = deal.t_BOfficeKind "
                         + "    and opr.t_DocumentID = LPAD(deal.t_DealID, 34, '0')"
                         + "    and kdate.t_DocKind = opr.t_DocKind "
                         + "    and kdate.t_NumberDate = ? /*2*/ "
                         + "    and odate.t_ID_Operation = opr.t_ID_Operation "
                         + "    and odate.t_DateKindID = kdate.t_DateKindID "
                         + "    and odate.t_Date <> ? /*3*/"  //сделка была поставлена на баланс
                         + "    and odate.t_Date <= ? /*4*/"  //дата постановки сделки на баланс не превышает дату операции
                         + "    and Exists(select 1 from dpmpaym_dbt pm"
                         + "                where pm.t_DocKind = deal.t_BOfficeKind "
                         + "                  and pm.t_DocumentID = deal.t_DealID "
                         + "                  and pm.t_Purpose = ? /*5*/ "
                         + "                  and pm.t_PayFIID <> pm.t_OrderFIID " //ВР != ВЦ
                         + "                  and pm.t_PaymStatus <> ? /*6*/" //оплата по состоянию на дату операции еще не исполнена
                         + "              )"
                        );

  Select.AddParam(tick.DealID); /*1*/
  Select.AddParam(VA_IIF(VA_IsSale(tick.DealType), DATE_SALE_SETBALANCE, DATE_BUY_SETBALANCE)); /*2*/
  Select.AddParam(date(0,0,0)); /*3*/
  Select.AddParam(Дата); /*4*/
  Select.AddParam(CAi); /*5*/
  Select.AddParam(PM_FINISHED); /*6*/

  DataSet = Select.Execute();
  if(not DataSet.moveNext())
    return false;
  end;

  return true;
END;

//подходит ли сделка для переоценки НВПИ сделок на внебалансе
MACRO СделкаДляПереоценкиНВПИНаВнебалансе(tick, Дата)
  var Select, DataSet;
  var stat = 0;
  var check = false;
  var bnrfd;
  var NumberSettOffBalanceDate, NumberMoveOffBalanceDate;
  var Purpose;

  if(tick.BOfficeKind != DL_VEKSELACCOUNTED)
    return false;
  end;

  if((not VA_IsBuy(tick.DealType)) and (not VA_IsSale(tick.DealType)) and (not  VA_IsExchange(tick.DealType)))
    return false;
  end;

  if(VA_IsBuy(tick.DealType))
    Purpose = CAi;
    NumberSettOffBalanceDate = DATE_BUY_SETOFFBALANCE;
    NumberMoveOffBalanceDate = DATE_BUY_MOVEOFFBALANCE;
  elif(VA_IsSale(tick.DealType))
    Purpose = CAi;
    NumberSettOffBalanceDate = DATE_SALE_SETOFFBALANCE;
    NumberMoveOffBalanceDate = DATE_SALE_MOVEOFFBALANCE;
  elif(VA_IsExchange(tick.DealType))
    Purpose = PM_PURP_VSBARTERDIFF;
    NumberSettOffBalanceDate = DATE_BART_SETOFFBALANCE;
    NumberMoveOffBalanceDate = DATE_BART_MOVEOFFBALANCE;
  end;

  //условия отбора
  //1. Переоценка Т/О по оплате срочных сделок на внебалансе
  // -  сделка не поставлена на балансовый учет на дату операции,
  // -  для сделки ВР != ВЦ
  //2. Переоценка Т/О по поставке срочных сделок на внебалансе
  // -  сделка не поставлена на балансовый учет на дату операции,
  // -  для векселя ВУ != ВН

  Select = DL_RSDCommand(  " select bnr.t_BCID, "
                         + "        (select count(1) from dpmpaym_dbt pm"
                         + "          where pm.t_DocKind = deal.t_BOfficeKind "
                         + "            and pm.t_DocumentID = deal.t_DealID "
                         + "            and pm.t_Purpose = ? /*1*/ "
                         + "            and pm.t_PayFIID <> pm.t_OrderFIID " //ВР != ВЦ
                         + "        ) as CntPaym "
                         + "   from ddl_tick_dbt deal, doproper_dbt opr, doprkdate_dbt kdate1, doprkdate_dbt kdate2, doprdates_dbt odate1, doprdates_dbt odate2, dvsordlnk_dbt lnk, dvsbanner_dbt bnr"
                         + "  where deal.t_DealID = ? /*2*/ "
                         + "    and opr.t_DocKind = deal.t_BOfficeKind "
                         + "    and opr.t_DocumentID = LPAD(deal.t_DealID, 34, '0')"
                         + "    and kdate1.t_DocKind = opr.t_DocKind "
                         + "    and kdate1.t_NumberDate = ? /*3*/ "
                         + "    and odate1.t_ID_Operation = opr.t_ID_Operation "
                         + "    and odate1.t_DateKindID = kdate1.t_DateKindID "
                         + "    and odate1.t_Date <> ? /*4*/"  //сделка поставлена на внебалансовый учет на дату операции
                         + "    and kdate2.t_DocKind = opr.t_DocKind "
                         + "    and kdate2.t_NumberDate = ? /*5*/ "
                         + "    and odate2.t_ID_Operation = opr.t_ID_Operation "
                         + "    and odate2.t_DateKindID = kdate2.t_DateKindID "
                         + "    and odate2.t_Date = ? /*6*/"  //сделка не снята с внебалансового учета на дату операции
                         + "    and lnk.t_ContractID = deal.t_DealID "
                         + "    and lnk.t_DocKind = deal.t_BOfficeKind "
                         + "    and bnr.t_BCID = lnk.t_BCID"
                        );
  Select.AddParam(Purpose); /*1*/
  Select.AddParam(tick.DealID); /*2*/
  Select.AddParam(NumberSettOffBalanceDate); /*3*/
  Select.AddParam(date(0,0,0)); /*4*/
  Select.AddParam(NumberMoveOffBalanceDate); /*5*/
  Select.AddParam(date(0,0,0)); /*6*/

  DataSet = Select.Execute();
  stat = DataSet.moveNext();
  if(not stat)
    return false;
  else
    check = false;
    if(DataSet.CntPaym > 0) //значит есть платежи, где ВР != ВЦ
      check = true;
    end;

    while((stat) and (check == false))
      bnrfd = VSBannerFD(DL_VSBANNER, DataSet.BCID);

      if(bnrfd.ОпределитьВалютуУчета() != bnrfd.GetLeg.rec.PFI) //для векселя ВУ != ВН
        check = true;
      end;
      stat = DataSet.moveNext();
    end;

    if(check == false)
      return false;
    end;
  end;

  return true;
END;

//подходит ли вексель для переоценки НВПИ вложений в ценные бумаги
MACRO ВексельДляПереоценкиНВПИВложенийВЦБ(bnr, Дата)
  var bnrfd;
  var ABCStatus;
  var lnkLast = TBfile("vsordlnk"), tickLast = TBfile("dl_tick");
  var ВалютаУчета;

  //Условия отбора
  // - вексель учтен на дату операции,
  // - вексель приобретен банком для себя (не для клиента),
  // - для векселя ВУ != ВН.

  if(bnr.ABCStatus != VABANNER_STATUS_ACCOUNT) //должен быть учтен в настоящий момент
    return false;
  end;

  if(VA_GetABCStatusOnDate(bnr.BCID, Дата, ABCStatus))
    if(ABCStatus != VABANNER_STATUS_ACCOUNT)                           //должен также был быть учтен и на дату операции
        return false;
    end;
  end;

  if(bnr.BackOffice != "N") //учтен не в подсистеме УВ
    return false;
  end;

  if(ПодсистемаВекселяНаДату(bnr.BCID, Дата) != "N") //учитывался не в подсистеме УВ на дату
    return false;
  end;

  bnrfd = VSBannerFD(DL_VSBANNER, bnr.BCID);
  ВалютаУчета = bnrfd.ОпределитьВалютуУчета();

  if(not bnrfd.VAGetLastBuy(lnkLast, tickLast))  //сделку покупки не нашли
    return false;
  elif(VA_IsClient(tickLast)) //сделка покупки была клиентская
    return false;
  end;

  if(not ((ВалютаУчета != bnrfd.GetLeg.rec.PFI) or
          ((УВ_ЕстьУчтеннаяСС(bnr.BCID, tickLast.rec.DealID, Дата)) and (ВалютаУчета != NATCUR))
         )
    )
    return false;
  end;

  return true;
END;

//подходит ли вексель для переоценки НВПИ индоссамента
MACRO ВексельДляПереоценкиНВПИИндоссамента(bnr, Дата)
  var bnrfd;
  var ABCStatus;
  var Счет = "";

  //Условия отбора
  //- вексель продан на дату операции,
  //- ВУ != ВН,
  //- для векселя открыт счет по КУ "Гарантии",

  if(bnr.ABCStatus != VABANNER_STATUS_INPUT) //проданный вексель должен иметь статус Введен в настоящий момент
    return false;
  end;

  if(VA_GetABCStatusOnDate(bnr.BCID, Дата, ABCStatus))
    if(ABCStatus != VABANNER_STATUS_INPUT)                           //должен также был быть Введен и на дату операции
        return false;
    end;
  end;

  if(Index(bnr.BCState, "Р") == 0) //не установлен признак "Продан" сечас
    return false;
  end;

  if(not СостояниеВекселяНаДату(bnr.BCID, Дата, "Р")) //не установлен признак Продан на дату
    return false;
  end;

  if(ПодсистемаВекселяНаДату(bnr.BCID, Дата) != "N") //учитывался не в подсистеме УВ до этого - т.е. и продали его не в УВ
    return false;
  end;

  bnrfd = VSBannerFD(DL_VSBANNER, bnr.BCID);

  if(bnrfd.ОпределитьВалютуУчета() == bnrfd.GetLeg.rec.PFI) //для векселя ВУ == ВН - вексель не подходит
    return false;
  end;

  if(not VA_GetAccount("Гарантии", bnrfd, Счет, MC_OPENACC_CHECKEXIST, bnrfd.ОпределитьВалютуУчета(), null, null, Дата)) //не нашли счет по КУ "Гарантии"
    return false;
  end;

  return true;
END;

//подходит ли сделка неттинга для переоценки НВПИ
MACRO СделкаНеттингаДляПереоценкиНВПИ(ntg, Дата)
  var paym = TBfile("pmpaym.dbt");

  //Условия отбора
  //- итоговый платеж неттинга по ден. средствам по состоянию на дату операции просрочен,
  //- валюта платежа (ВПл) != валюта оплаты (ВО).

  if(not VA_Get1stPlanPaym(ntg.DocKind, ntg.NettingID, PM_PURP_NETTING, paym)) //платеж каким-то образом не нашли
    return false;
  end;

  if((paym.rec.PaymStatus != PM_OVERDUE) AND (paym.rec.PaymStatus != PM_REMOVE_OVERDUE)) //платеж не просрочен
    return false;
  end;

  if(paym.rec.OrderFIID == paym.rec.PayFIID) //валюта платежа (ВПл) == валюта оплаты (ВО)
    return false;
  end;

  return true;
END;

//подходит ли сделка для переноса по счетам срочности на внебалансе
MACRO СделкаДляПереносаПоСчетамСрочностиНаВнебалансе(tick, Дата)
  var Select, DataSet;
  var stat = 0;
  var NumberSettOffBalanceDate, NumberMoveOffBalanceDate;

  if(tick.BOfficeKind != DL_VEKSELACCOUNTED)
    return false;
  end;

  if((not VA_IsBuy(tick.DealType)) and (not VA_IsSale(tick.DealType)) and (not  VA_IsExchange(tick.DealType)))
    return false;
  end;

  if(VA_IsBuy(tick.DealType))
    NumberSettOffBalanceDate = DATE_BUY_SETOFFBALANCE;
    NumberMoveOffBalanceDate = DATE_BUY_MOVEOFFBALANCE;
  elif(VA_IsSale(tick.DealType))
    NumberSettOffBalanceDate = DATE_SALE_SETOFFBALANCE;
    NumberMoveOffBalanceDate = DATE_SALE_MOVEOFFBALANCE;
  elif(VA_IsExchange(tick.DealType))
    NumberSettOffBalanceDate = DATE_BART_SETOFFBALANCE;
    NumberMoveOffBalanceDate = DATE_BART_MOVEOFFBALANCE;
  end;

  //условия отбора
  // -  сделка находится на внебалансе,
  // -  по сделке запланирован и не выполнен шаг "Перенос по срокам", плановая дата которого равна или меньше даты сервисной операции

  Select = DL_RSDCommand(  " select 1 "
                         + "   from ddl_tick_dbt deal, doproper_dbt opr, doprkdate_dbt kdate1, doprkdate_dbt kdate2, doprdates_dbt odate1, doprdates_dbt odate2"
                         + "  where deal.t_DealID = ? /*1*/ "
                         + "    and opr.t_DocKind = deal.t_BOfficeKind "
                         + "    and opr.t_DocumentID = LPAD(deal.t_DealID, 34, '0')"
                         + "    and kdate1.t_DocKind = opr.t_DocKind "
                         + "    and kdate1.t_NumberDate = ? /*2*/ "
                         + "    and odate1.t_ID_Operation = opr.t_ID_Operation "
                         + "    and odate1.t_DateKindID = kdate1.t_DateKindID "
                         + "    and odate1.t_Date <> ? /*3*/"  //сделка поставлена на внебалансовый учет на дату операции
                         + "    and kdate2.t_DocKind = opr.t_DocKind "
                         + "    and kdate2.t_NumberDate = ? /*4*/ "
                         + "    and odate2.t_ID_Operation = opr.t_ID_Operation "
                         + "    and odate2.t_DateKindID = kdate2.t_DateKindID "
                         + "    and odate2.t_Date = ? /*5*/"  //сделка не снята с внебалансового учета на дату операции
                         + "    and Exists(select 1 from doprstep_dbt ostep "
                         + "                where ostep.t_ID_Operation = opr.t_ID_Operation "
                         + "                  and ostep.t_Symbol = ? /*6*/ "
                         + "                  and ostep.t_IsExecute = ? /*7*/ "
                         + "                  and ostep.t_Plan_Date <= ? /*8*/ "
                         + "              ) "
                        );
  Select.AddParam(tick.DealID); /*1*/
  Select.AddParam(NumberSettOffBalanceDate); /*2*/
  Select.AddParam(date(0,0,0)); /*3*/
  Select.AddParam(NumberMoveOffBalanceDate); /*4*/
  Select.AddParam(date(0,0,0)); /*5*/
  Select.AddParam("П"); /*6*/
  Select.AddParam("R"); /*7*/
  Select.AddParam(Дата); /*7*/

  DataSet = Select.Execute();
  if(not DataSet.moveNext())
    return false;
  end;

  return true;
END;

//Находится ли сделка на внебалансе
MACRO СделкаНаВнебалансе(tick)
  var IsOffBal = false;
  var cmd = DL_RSDCommand("select rsb_bill.VADealIsOffBalance(?) as IsOffBal from dual");

  cmd.AddParam(tick.DealID);

  var DataSet = cmd.Execute();
  if((DataSet.moveNext()) and (DataSet.IsOffBal > 0))
    IsOffBal = true;
  end;

  return IsOffBal;
END;

MACRO ОтсроченнаяРазницаПоВекселю(BCID, VDate)
  var StartDefDif = 0.0;
  var Select, DataSet;

  Select = DL_RSDCommand("select cast(rsb_bill.GetVABnrStartDefDif(?, ?) as NUMBER(32,12)) as StartDefDif from dual");
  Select.AddParam(BCID);
  Select.AddParam(VDate);

  DataSet = Select.Execute();
  if(DataSet.moveNext())
    StartDefDif = DataSet.StartDefDif;
  end;

  return StartDefDif;
END;

MACRO ПолучитьОтсроченнуюРазницуНаДату(fd, VDate)
  var bnr = fd.GetBnr();
  var leg = fd.GetLeg();
  var tick = fd.GetTick;
  var P = 0, T = 0;
  var ОтсроченнаяРазница = ОтсроченнаяРазницаПоВекселю(bnr.rec.BCID, VDate);
  var РассчитаннаяОтсроченнаяРазница = $0;
  var IncomeDateType = DL_INCOMEDATETYPE_PLUSONE;

  if(ОтсроченнаяРазница != $0)
    T = VS_GetTermCircDate(bnr, leg); // срок обращения векселя (определяется от даты выпуска до плановой даты погашения включительно)

    if(T > 0)
      P = VDate - VS_GetStartDate(bnr, leg);

      if(P > 0)
        if(bnr.rec.BCTermFormula != VS_TERMF_INATIME)
          if(DL_GetStartIncomeDateType(@IncomeDateType) and (IncomeDateType == DL_INCOMEDATETYPE_CBR))
            P = P + 1; // чтобы учесть дату начала, которая была потеряна при вычитании

            if((tick != null) or (VDate >= DL_GetBnrPlanRepayDate(bnr, leg)))
              P = P - 1; // в дату погашения саму дату погашения учитывать не нужно
            end;
          end;
        end;

        if(P > T)
          P = T;
        end;

        РассчитаннаяОтсроченнаяРазница = Round(ОтсроченнаяРазница * P / T, 2); // нужно до 2-х знаков здесь, в противном случае накапливается ошибка
      end;
    end;
  end;

  return РассчитаннаяОтсроченнаяРазница;
END;

MACRO ПолучитьТекущуюКорректировкуПДДпоЭПС(BCID, VDate, AdjEIR, AccAdjEIR)
  var Select, DataSet;
  
  Select = RsdCommand("begin ?:= rsb_bill.GetVABnrAdjustmentEIR(?, ?, ?, ?);\n end;");
  Select.addParam("pReturn",             RSDBP_OUT, V_INTEGER );  
  Select.AddParam("pBCID",               RSDBP_IN,  BCID      );
  Select.AddParam("pOnDate",             RSDBP_IN,  VDate     );
  Select.AddParam("vАdjustmentEIR",      RSDBP_OUT, V_NUMERIC );
  Select.AddParam("vAccАdjustmentEIR",   RSDBP_OUT, V_NUMERIC );

  Select.Execute();
  SetParm(2,SQL_ConvTypeSum(Select.value(3)));
  SetParm(3,SQL_ConvTypeSum(Select.value(4)));
  return (SQL_ConvTypeInteger(Select.value(0)) == 0);  

END;

macro ПолучитьНачальныйДисконт(BCID, Дата, НачальныйДисконт, НачальныйДисконтУВ)
  var cmd = RsdCommand("begin ?:= rsb_bill.GetVAFirstDiscount(?,?,?,?);\n end; ");
  cmd.addParam("pReturn",                   RSDBP_OUT, V_INTEGER                );
  cmd.addParam("p_BCID",                    RSDBP_IN, BCID                      );
  cmd.addParam("p_OnDate",                  RSDBP_IN, Дата                      );
  cmd.addParam("p_FirstDiscount",           RSDBP_OUT, V_NUMERIC                ); 
  cmd.addParam("p_AccFirstDiscount",        RSDBP_OUT, V_NUMERIC                );
  cmd.execute();

  SetParm(2,cmd.value(3));
  SetParm(3,SQL_ConvTypeSum(cmd.value(4)));
  return (SQL_ConvTypeInteger(cmd.value(0)) == 0);
OnError(e)
  return false;
end;

macro ПолучитьПоложКорректировкуПДДПоЭПСВУ(BCID, Enrolment_ID, Дата)
  var query, DataSet;
  var Сумма = 0.0;
  var CurrEnrolID = 0;
  var RSD = DL_RSDCommand();

  if((ValType(Enrolment_ID) == V_UNDEF) or (Enrolment_ID == 0))
    CurrEnrolID = VA_GetLastAccountedEnrolmentID(BCID);
  else
    CurrEnrolID = Enrolment_ID;
  end;

  query =   " select sum(inc.t_AccPerc) as Summ" +
            " from dvsincome_dbt inc " + 
            " where inc.t_AccPerc > 0 AND inc.t_BCID = ? /*1*/ AND inc.t_Enrolment_ID = ? /*2*/ AND inc.t_IncomeType = ?";

  RSD.AddParam(BCID);         /*1*/
  RSD.AddParam(CurrEnrolID);  /*2*/
  RSD.AddParam(VSINCOMETYPE_EPRPERC);  /*3*/
  
  if((ValType(Дата) != V_UNDEF) and (Дата > date(0,0,0)))
    query =  query + " and inc.t_EndDate <= ? /*3*/";
    RSD.AddParam(date(Дата));  /*3*/
  end;

  query = query + " order by inc.t_EndDate DESC";

  DataSet = RSD.Execute(query);

  if((DataSet.moveNext()) and (ValType(DataSet.Summ) != V_UNDEF))
    Сумма = DataSet.Summ;
  end;

  return Сумма;
end;

macro ПолучитьОтрицКорректировкуПДДПоЭПСВУ(BCID, Enrolment_ID, Дата)
  var query, DataSet;
  var Сумма = 0.0;
  var CurrEnrolID = 0;
  var RSD = DL_RSDCommand();

  if((ValType(Enrolment_ID) == V_UNDEF) or (Enrolment_ID == 0))
    CurrEnrolID = VA_GetLastAccountedEnrolmentID(BCID);
  else
    CurrEnrolID = Enrolment_ID;
  end;

  query =   " select sum(inc.t_AccPerc) as Summ" +
            " from dvsincome_dbt inc " + 
            " where inc.t_AccPerc < 0 AND inc.t_BCID = ? /*1*/ AND inc.t_Enrolment_ID = ? /*2*/ AND inc.t_IncomeType = ?";

  RSD.AddParam(BCID);         /*1*/
  RSD.AddParam(CurrEnrolID);  /*2*/
  RSD.AddParam(VSINCOMETYPE_EPRPERC);  /*3*/

  if((ValType(Дата) != V_UNDEF) and (Дата > date(0,0,0)))
    query =  query + " and inc.t_EndDate <= ? /*3*/";
    RSD.AddParam(date(Дата));  /*3*/
  end;

  query = query + " order by inc.t_EndDate DESC";

  DataSet = RSD.Execute(query);

  if((DataSet.moveNext()) and (ValType(DataSet.Summ) != V_UNDEF))
    Сумма = DataSet.Summ;
  end;

  return Сумма;
end;

//подходит ли сделка для переоценки балансовой стоимости сделок на балансе
MACRO СделкаДляПереоценкиБСНаБалансе(tick, Дата)
  var Select, DataSet;

  if(tick.BOfficeKind != DL_VEKSELACCOUNTED)
    return false;
  end;

  if((not VA_IsBuy(tick.DealType)) and (not VA_IsSale(tick.DealType)))
    return false;
  end;

  //условия отбора
  //- дата постановки сделки на баланс не превышает дату операции,
  //- оплата по состоянию на дату операции еще не исполнена,
  //- ВЦ != ВР.

  Select = DL_RSDCommand(  " select deal.t_DealID "
                         + "   from ddl_tick_dbt deal, doproper_dbt opr, doprkdate_dbt kdate, doprdates_dbt odate"
                         + "  where deal.t_DealID = ? /*1*/ "
                         + "    and opr.t_DocKind = deal.t_BOfficeKind "
                         + "    and opr.t_DocumentID = LPAD(deal.t_DealID, 34, '0')"
                         + "    and kdate.t_DocKind = opr.t_DocKind "
                         + "    and kdate.t_NumberDate = ? /*2*/ "
                         + "    and odate.t_ID_Operation = opr.t_ID_Operation "
                         + "    and odate.t_DateKindID = kdate.t_DateKindID "
                         + "    and odate.t_Date <> ? /*3*/"  //сделка была поставлена на баланс
                         + "    and odate.t_Date <= ? /*4*/"  //дата постановки сделки на баланс не превышает дату операции
                         + "    and Exists(select 1 from dpmpaym_dbt pm"
                         + "                where pm.t_DocKind = deal.t_BOfficeKind "
                         + "                  and pm.t_DocumentID = deal.t_DealID "
                         + "                  and pm.t_Purpose = ? /*5*/ "
                         + "                  and pm.t_PayFIID <> pm.t_OrderFIID " //ВР != ВЦ
                         + "                  and pm.t_PaymStatus <> ? /*6*/" //оплата по состоянию на дату операции еще не исполнена
                         + "              )"
                        );

  Select.AddParam(tick.DealID); /*1*/
  Select.AddParam(VA_IIF(VA_IsSale(tick.DealType), DATE_SALE_SETBALANCE, DATE_BUY_SETBALANCE)); /*2*/
  Select.AddParam(date(0,0,0)); /*3*/
  Select.AddParam(Дата); /*4*/
  Select.AddParam(CAi); /*5*/
  Select.AddParam(PM_FINISHED); /*6*/

  DataSet = Select.Execute();
  if(not DataSet.moveNext())
    return false;
  end;

  return true;
END;

//подходит ли вексель для переоценки балансовой стоимости вложений в ценные бумаги
MACRO ВексельДляПереоценкиБСВложенийВЦБ(bnr, Дата)
  var bnrfd;
  var ABCStatus;
  var lnkLast = TBfile("vsordlnk"), tickLast = TBfile("dl_tick");
  var ВалютаУчета, ВалютаНоминала;
  var RegVal;
  //Условия отбора
  // - вексель учтен на дату операции,
  // - вексель приобретен банком для себя (не для клиента),
  // - для векселя если ВР - заданна тогда (ВР != НацВ) иначе ((ВН != НацВ и настройка "Учет валютных векселей без ОЭП в рублях" = "Да") или (вексель был учтен со справедливой стоимостью ПФИ И ВУ != НацВ)).

  if(bnr.ABCStatus != VABANNER_STATUS_ACCOUNT) //должен быть учтен в настоящий момент
    return false;
  end;

  if(VA_GetABCStatusOnDate(bnr.BCID, Дата, ABCStatus))
    if(ABCStatus != VABANNER_STATUS_ACCOUNT)                           //должен также был быть учтен и на дату операции
        return false;
    end;
  end;

  if(bnr.BackOffice != "N") //учтен не в подсистеме УВ
    return false;
  end;

  if(ПодсистемаВекселяНаДату(bnr.BCID, Дата) != "N") //учитывался не в подсистеме УВ на дату
    return false;
  end;

  bnrfd = VSBannerFD(DL_VSBANNER, bnr.BCID);
  ВалютаУчета = bnrfd.ОпределитьВалютуУчета();

  if(not bnrfd.VAGetLastBuy(lnkLast, tickLast))  //сделку покупки не нашли
    return false;
  elif(VA_IsClient(tickLast)) //сделка покупки была клиентская
    return false;
  end;

  ВалютаНоминала = bnrfd.GetLeg.rec.PFI;
  if(bnr.PayFIID != ALLFININSTR) //ВР ЗАДАНА
    if(not (bnr.PayFIID !=NATCUR))
      return false;
    end;
  else
    if(not (((ВалютаНоминала != NATCUR) and ((VS_GetRegistryValue("УЧТЕННЫЕ ВЕКСЕЛЯ\\РЕЖИМ РАБОТЫ\\УЧЕТ_ВАЛ_ВЕКС_БЕЗ_ОЭП_В_РУБЛЯХ", V_BOOL, @RegVal)) and (RegVal) )) or
            ((УВ_ЕстьУчтеннаяСС(bnr.BCID, tickLast.rec.DealID, Дата)) and (ВалютаУчета != NATCUR))
           )
      )
      return false;
    end;
  end;

  return true;
END;

//подходит ли вексель для переоценки балансовой стоимости индоссамента
MACRO ВексельДляПереоценкиБСИндоссамента(bnr, Дата)
  var bnrfd;
  var ABCStatus;
  var Счет = "";
  //Условия отбора
  //- вексель продан на дату операции,
  //- ВУ != ВН,
  //- для векселя открыт счет по КУ "Гарантии",

  if(bnr.ABCStatus != VABANNER_STATUS_INPUT) //проданный вексель должен иметь статус Введен в настоящий момент
    return false;
  end;

  if(VA_GetABCStatusOnDate(bnr.BCID, Дата, ABCStatus))
    if(ABCStatus != VABANNER_STATUS_INPUT)                           //должен также был быть Введен и на дату операции
        return false;
    end;
  end;

  if(Index(bnr.BCState, "Р") == 0) //не установлен признак "Продан" сечас
    return false;
  end;

  if(not СостояниеВекселяНаДату(bnr.BCID, Дата, "Р")) //не установлен признак Продан на дату
    return false;
  end;

  if(ПодсистемаВекселяНаДату(bnr.BCID, Дата) != "N") //учитывался не в подсистеме УВ до этого - т.е. и продали его не в УВ
    return false;
  end;

  bnrfd = VSBannerFD(DL_VSBANNER, bnr.BCID);

  if(bnrfd.ОпределитьВалютуУчета() == bnrfd.GetLeg.rec.PFI) //для векселя ВУ == ВН - вексель не подходит
    return false;
  end;

  if(not VA_GetAccount("Гарантии", bnrfd, Счет, MC_OPENACC_CHECKEXIST, bnrfd.ОпределитьВалютуУчета(), null, null, Дата)) //не нашли счет по КУ "Гарантии"
    return false;
  end;

  return true;
END;

//подходит ли сделка неттинга для переоценки балансовой стоимсоти
MACRO СделкаНеттингаДляПереоценкиБС(ntg, Дата)
  var paym = TBfile("pmpaym.dbt");

  //Условия отбора
  //- итоговый платеж неттинга по ден. средствам по состоянию на дату операции просрочен,
  //- валюта платежа (ВПл) != валюта оплаты (ВО).

  if(not VA_Get1stPlanPaym(ntg.DocKind, ntg.NettingID, PM_PURP_NETTING, paym)) //платеж каким-то образом не нашли
    return false;
  end;

  if((paym.rec.PaymStatus != PM_OVERDUE) AND (paym.rec.PaymStatus != PM_REMOVE_OVERDUE)) //платеж не просрочен
    return false;
  end;

  if(paym.rec.OrderFIID == paym.rec.PayFIID) //валюта платежа (ВПл) == валюта оплаты (ВО)
    return false;
  end;

  return true;
END;

MACRO VA_IsSumSeparation()
  var 
  separate = false;
  if(not VS_GetRegistryValue("УЧТЕННЫЕ ВЕКСЕЛЯ\\РЕЖИМ РАБОТЫ\\РАЗБИВКА ИСХОДЯЩИХ ПЛАТЕЖЕЙ", V_BOOL, @separate))//Simanov
    separate = false;
  end;
  return separate;

END;