
IMPORT PaymInter, "globals.mac", "mccatacf.mac", "mctplprm.mac";

CLASS VAFirstDocNtg( DocKind, DocID )

    PRIVATE VAR ParmA = TArray(); /* массив значений параметров 
                                    Доступ только через GetParametr */
    VAR Deal, pm_money,
        Error = 0, Kind = 0, ID = 0;

    MACRO InitParmArray 
        ParmA[MC_TYPE_PARAMETR_FIID]         = Deal.rec.BaseFIID;
        ParmA[MC_TYPE_PARAMETR_PAYCURRENCY]  = Deal.rec.PayFIID;
        ParmA[MC_TYPE_PARAMETR_DOCKIND]      = DL_NTGDOC;
        ParmA[MC_TYPE_PARAMETR_DOCID]        = Deal.rec.NettingID;
        ParmA[MC_TYPE_PARAMETR_CONTRACTOR]   = Deal.rec.Contractor;
        ParmA[MC_TYPE_PARAMETR_PARTY]        = Deal.rec.Contractor;
        ParmA[MC_TYPE_PARAMETR_OWNER]        = {OurBank};
        ParmA[MC_TYPE_PARAMETR_DEPARTMENT]   = Deal.rec.Department;
    END;

    MACRO GetParametr (ParmKind, OperDate, CatCode, FIRole)
        var Parametr = ParmA[ParmKind];
        if( Parametr == null ) 
            Parametr = -1;
        end;
        return Parametr;
    END;

    MACRO SetParametr( Index:INTEGER, Val:VARIANT )
       ParmA[Index] = Val;
    END;

    /*Получить параметры шаблона                    */
    MACRO GetParametrTemplate
    ( 
        ObjectID,       /*   параметр - номер справочника                 */
        Classificator,  /*   классификатор - номер классификатора, если он задан */
        OperDate,       /*   дата, на которую надо вернуть характеристики*/
        FIRole
    )
       var Parametr = -1;
       var Contragent = this.GetParametr( MC_TYPE_PARAMETR_PARTY ), IsRes;

       FIRole = this.GetBasisFIRole( FIRole );

       if( ObjectID == OBJTYPE_KINDRESERV )
          if( FIRole == FIROLE_RESERV_RPT )
             Parametr = KINDRES_EXPREQ; /* РПТ По просроченным требованиям */
          end;
       elif( (ObjectID == OBJTYPE_RESIDENT) AND  (Classificator == LLCLASS_RESD_CONTRACTOR) )
          if( FIRole == FIROLE_RESERV_RPT )
             Parametr = MC_IsResident( Contragent );
          end;
       elif( (ObjectID == OBJTYPE_KINDSUBJ) AND (Classificator == LLCLASS_KINDSUBJ_KONTRMM) )
          if( FIRole == FIROLE_RESERV_RPT )
             Parametr = -1;
          end;
       elif( (ObjectID == OBJTYPE_BACKOFFICE) AND (Classificator == LLCLASS_BACKOFFICE) )
          Parametr = 7; /*УВ*/
       elif( ( ObjectID == OBJTYPE_BOOLEAN) AND (Classificator == LLCLASS_CONTRCREDIT_ORG) )
          if( FIRole == FIROLE_RESERV_RPT )
             if( MC_GetKindParty( Contragent, IsRes ) == 1 ) /*банк*/
                Parametr = 1; /*Да*/
             else
                Parametr = 0; /*Нет*/
             end;
          end;
       elif( (ObjectID == OBJTYPE_KINDSUBJ) AND (Classificator == LLCLASS_KINDSUBJ_DEBETSECUR) )
          Parametr = MC_GetKindSecurDebet( Contragent );
       elif( (ObjectID == OBJTYPE_KINDSUBJ) AND (Classificator == LLCLASS_KINDSUBJ_CREDITSECUR) )
          Parametr = MC_GetKindSecurCredit( Contragent );
       elif(ObjectID == OBJTYPE_IST_DOH_RASH)
         if(Classificator == LLCLASS_KIND_MARG_FUTURES) /* 1651  вид маржи от срочных сделок */
            Parametr = 6;
         end;
       end;

       return Parametr;
    END;

    /*Макрос корректировки открываемого счета. Account, accblnc, ORScheme можно менять*/
    MACRO CorrectAccount(account, accblnc, ORScheme, categ, templ, accdoc,  OperDate)
      return true;
    END;

    /* Получить счет по категории учета
       Вернет false, если ошибка или отказ от ввода счета.
       ! если не установлен NoErrMes выдаст сообщение об ошибке
    */
    PRIVATE MACRO GetAccountByCatCode
    ( 
        CatCode:string     ,  /* код категории */
        FindAccount:string ,  /* здесь вернется номер счета */
        /*необязательные параметры*/
        AccCreate:Integer,     /* признак верификации\открытия лицевого счета       */
        NoErrMes:bool,      /* признак молчаливого выполнения - ошибку не выдаем */
        FIRole:Variant,        /* роль ФИ или массив ролей*/
        AccBuf:Variant,        /* буфер для возврата информации по найденному\открытому счету   */
        PairAcc:Integer,       /* с учетом парности */
        ActionDate:Date,    /* дата */
        FIID:Integer,          /*валюта*/
        Accounts:Variant,      /*массив номеров счетов, соответствующий массиву ролей */  
        RealOpenMode:Integer,  /*фактический режим открытия*/
        McAccDocBuf:Variant,   /* буфер для возврата данных по счету mcaccdoc.dbt */
        ActivateDate:Variant   /*Дата актуализации счета (может быть не задана)*/
    )
       var i = 0, loop = true, open_acc = true, _FIRole = null, IsMass;

       if( this.Error != 0 ) return false; end;

       if( ((NoErrMes == null) OR (NoErrMes == false)) AND 
           (not isOprMultiExec()) 
         )
          IsMass = 0;
       else /*либо массовый режим, либо принудительно просим не орать ошибки*/
          IsMass = 1;
       end;

       if( ValType(AccCreate) == V_UNDEF )
          AccCreate = MC_OPENACC_CREATE;
       end;

       while( loop ) /*цикл нужен для перебора ролей, если задан массив ролей*/

          if( (FIRole != null) AND (ValType( FIRole ) == V_GENOBJ) ) /*массив ролей*/  

             if(FIRole[i] != null)            
               loop     = true;                    
               open_acc = true;
               _FIRole  = FIRole[i];
             else
               loop     = false;                    
               open_acc = false;
               _FIRole  = null;
             end;
             i = i + 1;    

          else
             loop       = false; /*перебор не нужен, только одна роль задана*/
             open_acc   = true;
             _FIRole    = FIRole;
          end;
      
          if( open_acc )                    
             if( AccCreate != 4 )
                FindAccount = MC_FindAndOpenAccountEx (
                    CatCode,
                    this,
                    ActionDate,
                    IsMass,
                    AccCreate,
                    AccBuf, FIID, null, PairAcc, null, _FIRole, RealOpenMode, McAccDocBuf, NULL, ActivateDate, NULL
                );

             else
                FindAccount = MC_GetAccountNumber (
                    CatCode,
                    this,
                    ActionDate,
                    IsMass, FIID, _FIRole );
             end;

             if( FindAccount != "" )
                if( (Accounts != null) AND (ValType( Accounts ) == V_GENOBJ) ) /*массив счетов*/  
                   Accounts[i-1] = FindAccount;
                end;
             end;
          end;
       end;

       SetParm( 2, FindAccount );
       if ( FindAccount=="" )
          if( IsMass == 0 )
             MsgBox("Счет категории \"" + CatCode + "\" неопределен или недоступен в данной операции");
          end;  
          return false;
       end;

       return true;
    END;

    /*открытие и актуализация счета*/  
    MACRO OpenAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, ActionDate, FIID, Accounts, McAccDoc );
       var ret, acnt;      
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_CREATE, NoErrMes, FIRole, AccBuf, null, ActionDate, FIID, Accounts, null, McAccDoc );
       setparm( 2, acnt ); 
       return ret;
    END;

    /*проверка на существование счета*/  
    MACRO IsExistAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
       var ret, acnt;      
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_CHECKEXIST, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
       setparm( 2, acnt ); 
       return ret;
    END;

    MACRO GetBasisFIRole( FIRole )
      if( (FIRole == null) OR (FIRole == FIROLE_UNDEF) OR (FIRole == FIROLE_BA) )
         return FIROLE_BA;
      else
         return FIRole;
      end;
    END;

    MACRO Construct( DocKind, DocID ) 

       this.Deal = TBfile( "dl_nett.dbt" );
       this.pm_money = Trechandler( "pmpaym.dbt"   ); /* платеж деньгами           */

       this.Kind  = DocKind; /* вид первичного документа, к которому привязка   */
       this.ID    = DocID;   /* ID первичного документа, к которому привязка    */
     
       ClearRecord (this.Deal);
       ClearRecord (pm_money);
       this.Deal.rec.NettingID = DocID; 
       if( this.Deal.GetEQ() == false ) 
          this.SetError( "Не найдена сделка NettingID = " + string(DocID) );
       end;

       if( FindPayment( 0, PM_PURP_NETTING, 0, DL_NTGDOC, this.Deal.rec.NettingID, true, this.pm_money ) != 0 )
          this.SetError("Не найден результирующий платеж неттинга " );
       end;

       InitParmArray(); /*инициализация массива параметров*/
    END;

    this.Construct( DocKind, DocID );
END;