/*
$Name:         tsutil.mac
$Module:       Доверительное управление
$Description:  Общие ф-и подсистемы "Доверительное управление"
*/

import Проценты, VAInter, InsCarryDoc, Календарь, PTInter, RsbDataSet, PaymInter, BankInter, OprInter, 
	TSInter, FIInter, CTInter, CurrInter, DealsInter, "globals.mac", "cb_sql.mac", "mccatacf.mac", 
   "mccatacc.mac", "dlvaprds.mac", VSInter, SPInter, dlmisc, "dlGetGroundRec.mac", "dldlngfun.mac";

CONST TS_RATETYPE_TSS = 16; /*Текущая справедливая стоимость для доверительного управления*/
CONST TS_PMPURP_COMMISS = 60; /*Назначение платежа по комиссии*/

/* Привести строку к заданному размеру 
     Str       [IN/OUT] - исходная строка
     Len       [IN]     - требуемая длина
     FillSymbol[IN]     - символ-заполнитель до нужной длины, если строка короче 
     LeftAlignment[IN]  - если TRUE, то выравнивние по левому краю (по умолчанию по правому)
*/
MACRO TS_StrCut( Str:STRING, Len:INTEGER, FillSymbol:STRING, LeftAlignment:BOOL )
   var SourseLen;

   Str       = trim( Str );
   SourseLen = strlen( Str );

   if( LeftAlignment == null ) /*по умолчанию выравнивание по правому краю*/
      LeftAlignment = false;
   end;   

   if( FillSymbol == null ) /*по умолчанию заполнить нулями*/
      FillSymbol = "0";
   end;   

   if( SourseLen >= Len ) 
      if( LeftAlignment ) /*обрезаем справа (последние (SourseLen-Len) символов*/
         Str = SubStr( Str, 1, Len );            
      else /*обрезаем слева (первые (SourseLen-Len) символов) */
         Str = SubStr( Str, (SourseLen-Len+1), Len ); 
      end;
   else  
      if( LeftAlignment ) /*дополняем заданным символом справа*/ 
         Str = Str + mkstr( FillSymbol, Len-SourseLen );  
      else /*дополняем заданным символом слева*/ 
         Str = mkstr( FillSymbol, Len-SourseLen ) + Str;
      end;
   end;

   return Str;
END;

/* Аналог оператора ?: в си. */
MACRO TS_IIF( Condition:BOOL, Value_true:VARIANT, Value_false:VARIANT )
  if( condition )
     return value_true;
  end;
  return value_false;
END;

MACRO ПолучитьРольТО( DemandID:INTEGER )
  var RS, Role = TS_DEMAND_ROLE_UNDEFINE;

  if( DemandID > 0 ) 
     RS = TRsbDataSet( " SELECT t_Role FROM dtsdemand_dbt demand WHERE demand.t_ID = "+ string(DemandID) );
     if( RS.MoveNext() )
        Role = RS.Role;
     end;
  end;
  return Role;
END;

MACRO ПолучитьРольДР( ProfitID:INTEGER )
  var RS, Role = TS_PROFIT_ROLE_UNDEFINE;

  if( ProfitID > 0 ) 
     RS = TRsbDataSet( " SELECT t_Role FROM dtsprofit_dbt profit WHERE profit.t_ID = "+ string(ProfitID) );
     if( RS.MoveNext() )
        Role = RS.Role;
     end;
  end;
  return Role;
END;

MACRO TS_GetRecHandler( RecFromSelect:TRecHandler, Query:STRING ) :BOOL
  var RS = TRsbDataSet( Query );

  if( RS.MoveNext() )
     RS.GetRecord().CopyTo( RecFromSelect.rec );
     return true;
  else
     RecFromSelect.Clear();
  end;
  return false;

//OnError(er)
//  return false;
END;

MACRO FindProfit( ProfitID:INTEGER, Profit:TRecHandler )
  if( ProfitID > 0 )
     return TS_GetRecHandler( Profit, " SELECT profit.* FROM dtsprofit_dbt profit WHERE profit.t_ID = "+ string(ProfitID) );
  end;
  return false;
END;

MACRO FindOrder( OrderID:INTEGER, Order:TRecHandler )
  if( OrderID > 0 )
     return TS_GetRecHandler( Order, " SELECT tsorder.* FROM dtsorder_dbt tsorder WHERE tsorder.t_ID = "+ string(OrderID) );
  end;
  return false;
END;

MACRO FindOrderGround( OrderID:INTEGER, Ground:TRecHandler )
  if( OrderID > 0 )           
     return TS_GetRecHandler( Ground, " SELECT SPGround.* "+
                                      "   FROM dspground_dbt SPGround, dtsorder_dbt tsorder" +
                                      "  WHERE SPGround.t_SourceDocKind = tsorder.t_DocKind AND "+
                                      "        SPGround.t_SourceDocID   = tsorder.t_ID      AND "+
                                      "        SPGround.t_Direction     = "+ string(EXITING) + " AND " +
                                      "        SPGround.t_Division      = "+ string(0) + " AND " +
                                      "        tsorder.t_ID = " + string(OrderID) 
                            );
  end;
  return false;
END;

MACRO FindActive( ActiveID:INTEGER, Active:TRecHandler )
  if( ActiveID > 0 )
     return TS_GetRecHandler( Active, " SELECT active.* FROM dtsactive_dbt active WHERE active.t_ID = "+ string(ActiveID) );
  end;
  return false;
END;

MACRO TS_FindOper( OperID:INTEGER, Oper:TRecHandler )
  if( OperID > 0 )
     return TS_GetRecHandler( Oper, " SELECT oper.* FROM dtsoper_dbt oper WHERE oper.t_ID = "+ string(OperID) );
  end;
  return false;
END;

MACRO TS_FindIORequest( ID:INTEGER, IORequest:TRecHandler )
  if( ID > 0 )
     return TS_GetRecHandler( IORequest, " SELECT * FROM dtsiorqst_dbt WHERE t_ID = "+ string(ID) );
  end;
  return false;
END;

MACRO FindDemand( DemandID:INTEGER, Demand:TRecHandler )
  if( DemandID > 0 ) 
     return TS_GetRecHandler( Demand, " SELECT Demand.* FROM dtsdemand_dbt Demand WHERE Demand.t_ID = "+ string(DemandID)  );
  end;
  return false;
END;

MACRO FindActiveByDemand( DemandID:INTEGER, Active:TRecHandler )
  if( DemandID > 0 )
     return TS_GetRecHandler( Active, " SELECT active.* FROM dtsactive_dbt active, dtsdemand_dbt demand WHERE active.t_ID = demand.t_ActiveID AND demand.t_ID = "+ string(DemandID) );
  end;
  return false;
END;

MACRO FindActiveByOrder( OrderID:INTEGER, FIID:INTEGER, DepositoryID:INTEGER, Active:TRecHandler ) :BOOL
  if( OrderID > 0 )
     return TS_GetRecHandler( Active, 
              " SELECT active.* " +
              "   FROM dtsactive_dbt active " +
              "  WHERE active.t_OrderID      = "+ string(OrderID)      + " AND" +
              "        active.t_FIID         = "+ string(FIID)         + " AND" +
              "        active.t_DepositoryID = "+ string(DepositoryID) 
            );
  end;
  return false;
END;

/*Получить договор обслуживания по договору ДУ*/
MACRO FindSfContrByOrder( Order:VARIANT, SfContr:TRecHandler ) :BOOL
  VAR Query = "SELECT *" +
              "  FROM dsfcontr_dbt "+
              " WHERE t_ID = ";

  if( ValType(Order) == V_INTEGER )
     Query = Query + string(Order)
  else
     Query = Query + string(Order.rec.SfContrID)
  end;

  return TS_GetRecHandler( SfContr, Query );
END;

/*Получить договор ДУ по договору обслуживания*/
MACRO FindOrderBySfContr( SfContr:VARIANT, Order:TRecHandler ) :BOOL
  if( ValType(SfContr) == V_INTEGER )
     return CB_GetTSContrBySfContr( SfContr, Order );
  else
     return CB_GetTSContrBySfContr( SfContr.rec.ID, Order );
  end;
END;

MACRO TS_FindGroundByID( ID:INTEGER, Ground:TRecHandler )
  if( ID > 0 )           
     return TS_GetRecHandler( Ground, " SELECT SPGround.* "+
                                      "   FROM dspground_dbt SPGround " +
                                      "  WHERE SPGround.t_SpGroundID = " + string(ID) 
                            );
  end;
  return false;
END;

MACRO TS_FindGroundBySourceDoc( SourceDocID:INTEGER, SourceDocKind:INTEGER, Ground:TRecHandler )
  if( (SourceDocID > 0) AND (SourceDocKind > 0 ) )           
     return TS_GetRecHandler( Ground, " SELECT SPGround.* "+
                                      "   FROM dspground_dbt SPGround " +
                                      "  WHERE SPGround.t_SourceDocKind = "+ string(SourceDocKind) + " AND "+
                                      "        SPGround.t_SourceDocID   = "+ string(SourceDocID)   + " AND "+
                                      "        SPGround.t_Direction     = "+ string(EXITING)       + " AND " +
                                      "        SPGround.t_Division      = "+ string(0) 
                            );
  end;
  return false;
END;

/*Поиск шаблона документа ДУ*/
MACRO TS_FindGrTemp( Num:INTEGER, GrTemp:TRecHandler )
  if( Num > 0 )           
     return TS_GetRecHandler( GrTemp, " SELECT GrTemp.* "+
                                      "   FROM ddlgrtemp_dbt GrTemp " +
                                      "  WHERE GrTemp.t_DocLog = 590 AND " +
                                      "        GrTemp.t_Num    = " + string(Num) 
                            );
  end;
  return false;
END;

/*получить сетрификат*/
MACRO TS_FindCertByID( ID:INTEGER, Cert:TRecHandler )
  if( ID > 0 )           
     return TS_GetRecHandler( Cert, " SELECT * "+
                                    "   FROM dtscert_dbt " +
                                    "  WHERE t_ID = " + string(ID) 
                            );
  end;
  return false;
END;

MACRO TS_FindPerson( Oper:INTEGER, Person:TRecHandler )
  if( Oper > 0 )           
     return TS_GetRecHandler( Person, "select * from dperson_dbt where t_oper = "+string(Oper));
  end;
  return false;
END;                                  

MACRO TS_FindReqAssets( RequestID:INTEGER, ReqAsset:TRecHandler )
  if( RequestID > 0 )           
     return TS_GetRecHandler( ReqAsset, " SELECT * FROM dTSREQASSETS_dbt WHERE t_RequestID = "+ string(RequestID) );
  end;
  return false;
END;

/*нйти Договор ДУ по привязанному к нему документу*/
macro TS_FindOrderBySpGround( SpGroundID:INTEGER, DocKind_:INTEGER, Order:TRecHandler )
   var DocKind = -1;

   if( (DocKind_ != NULL) AND (DocKind_ > 0) )
      DocKind = DocKind_;
   end;

   return TS_GetRecHandler( Order, " select tsorder.* " +                                  
                                   "   from dtsorder_dbt tsorder, dspgrdoc_dbt spgrdoc " +                     
                                   "  where spgrdoc.t_SpGrounDID = " + string(SpGroundID) +
                                   "    and tsorder.t_ID         = spgrdoc.t_SourceDocID " +     
                                   "    and tsorder.t_DocKind    = spgrdoc.t_SourceDocKind " +
                                   TS_IIF(DocKind>0,"    and tsorder.t_DocKind    = " + string(DocKind),"")                          
                          );
end;

MACRO TS_FindAvrKinds( FI_Kind:integer,AvoirKind:integer, AvrKind:TRecHandler )
  if( (FI_Kind > 0) AND (AvoirKind > 0) )           
     return TS_GetRecHandler( AvrKind, " SELECT * FROM dAVRKINDS_dbt WHERE t_FI_KIND = "+ string(FI_Kind)+
                                        "    AND t_AVOIRKIND = " + string(AvoirKind) );
  end;
  return false;
END;

MACRO TS_GetFaceValue( FIID, NomDate, SayError, BreakProg )
  var Res, FaceValue;

  if( FI_IsInvestmentShare(FIID) )
     return 0.0; /*у паев нет номинала*/
  elif( (NomDate == null) or (NomDate == Date(0,0,0)) )
     /* Получаем исходный номинал. */
     Res = FI_GetNominal( FIID, FaceValue ) == 0;
  else
     /* Получаем номинал на дату. */
     Res = SP_GetNominal( FIID, NomDate, FaceValue, BO_TRUST );
  end;

  if( Res )
     return FaceValue;
  else
     /* Сбрасываем ошибку. */
     InitError;
     if( SayError )
        var Mes = "Не могу получить номинал фин. инстумента (FIID = " + String(FIID) + ")";
        if( BreakProg )
           RunError( Mes );
        else
           MsgBox( Mes );
        end;
     end;
     return 0.0;
  end;
END;

MACRO TS_GetRateValueOnDate( RateRec, ADate, fiidFrom, fiidTo, SayError, Error, SinceDate )

   /* Получить коэффициент. */
   macro CalcK( RateRec )
      return RateRec.Rate / RateRec.Scale / pow(10, RateRec.Point);
   end;

   var
      FaceValue = 0.0, FaceFIID = -1, K = 0.0,
      ErrorFlag   = false;

   if( (ПолучитьЗначениеКурса( RateRec, ADate ) == 0) and (RateRec.OtherFI == fiidFrom) )

      /* Курс нашли. Надо проверить признак обратной котировки и признак
         относительного курса. Сразу оба не могут быть установлены.
         Проверка RateRec.OtherFI == fiidFrom нужна, т.к. функция
         ПолучитьКурс иногда, но не всегда, берет обратный курс, а нам
         это не надо. */
      SinceDate = RateRec.SinceDate;
      if( RateRec.IsInverse == "X" )

         /* Обратная котировка. */
         if( CalcK(RateRec) == 0.0 )
            K = 0.0;
         else
            K = 1.0 / CalcK(RateRec);
         end;

      elif( RateRec.IsRelative == "X" )

         /* Относительная цена */
         FaceValue = 0.0;
         if(   (FI_GetNominal(fiidFrom, FaceValue, FaceFIID) == 0)
               and (FaceFIID == fiidTo)
               )
            FaceValue = TS_GetFaceValue( fiidFrom, ADate + 1);
            if( FaceValue > 0.0 ) 
               K = CalcK(RateRec) / 100 * FaceValue;
            end;
         else
            ErrorFlag = true;
         end;

      else

         /* Обычный случай. */
         K = CalcK(RateRec);
      end;
   else
      K = 0.0;
      ErrorFlag = true;
   end;

   if( ErrorFlag and SayError )
      Msgbox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;
   
   SetParm( 5, ErrorFlag );
   SetParm( 6, SinceDate );
   return K;
END;

/* Получить коэффициент перевода суммы из одной валюты в другую.
   Возвращаем double. Если произошла ошибка, то вернем 0. Найти коэффицент
   через обратный курс не пытаемся.
      ADate    - Дата, на которую брать курс
      fiidFrom - Из какой валюты.
      fiidTo   - В какую валюту.
      SayError - Флаг. Если задан, то в случае ошибки выводим сообщение
                 пользователю.
      Type     - Тип курса. Если не задан или 0, то берем основной курс.
      Error    - Флаг. Запишем сюда true, если произошла ошибка. 
      SinceDate   - дата начала действия курса*/
MACRO TS_GetRateOnDate( ADate, fiidFrom, fiidTo, SayError, Type, Error, SinceDate, MarketID, CentrOffice )
   VAR ErrorFlag, K;

   record RateRec(ratedef);

   if( fiidTo == fiidFrom )
      /* Валюты совпадают. */
      SetParm( 5, false );
      return 1.0;
   end;

   /* Если тип курса не задан, то берем основной. */
   if( (Type == null) or (Type == 0) )
      ErrorFlag = ПолучитьКурс( RateRec, fiidTo, fiidFrom );
   else
      if( MarketID != null )
         if( MarketID > 0 ) 
            if( CentrOffice == null )
               CentrOffice = 0;
            end;
         else
            MarketID = null;
            CentrOffice = null;
         end;
      end;

      if( MarketID != null )
         ErrorFlag = ПолучитьКурс( RateRec, fiidTo, fiidFrom, Type, MarketID, CentrOffice );
         if( ErrorFlag )                                                                   
            if( CentrOffice != 0  )                                                     
               ErrorFlag = ПолучитьКурс( RateRec, fiidTo, fiidFrom, Type, MarketID, 0 );
            end;                                                                        
            if( ErrorFlag )                                                                
               ErrorFlag = ПолучитьКурс( RateRec, fiidTo, fiidFrom, Type );             
            end;                                                                           
         end;                                                                              
      else
         ErrorFlag = ПолучитьКурс( RateRec, fiidTo, fiidFrom, Type );
      end;
   end;

   if( not ErrorFlag )
      K = TS_GetRateValueOnDate( RateRec, ADate, fiidFrom, fiidTo, SayError, Error, SinceDate );
   else
      K = 0.0;
      ErrorFlag = true;
   end;

   if( ErrorFlag and SayError )
      Msgbox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;

   SetParm( 5, ErrorFlag );
   SetParm( 6, SinceDate );
   return K;
END;

/* Конвертация суммы типа double другую валюту. Проверяем прямой и обратный
   курс. Функциональность аналогична функции ConvSum из FIInter.
      SumToDbl    - Сюда запишем результат. Double.
      SumFromDbl  - Сумма для конвертации. Double.
      ADate       - Дата, на которую брать курс.
      fiidFrom    - Из какой валюты.
      fiidTo      - В какую валюту.
      SayError    - Флаг. Выдавать сообщения об ошибке. Если не задан, то
                    сообщения не выдаем.
      Type        - Тип курса. Integer. Если не задан или 0, то берем основной
                    курс.
      SinceDate   - дата начала действия курса
   В случае ошибки возвращаем False, в SumToDbl устанавливаем 0. */
MACRO TS_ConvSumDbl( SumToDbl, SumFromDbl, ADate, fiidFrom, fiidTo, SayError, Type, SinceDate, MarketID, CentrOffice )

   var
      K,
      Inverse     = false,
      ErrorFlag   = true;

   K = TS_GetRateOnDate( ADate, fiidFrom, fiidTo, false, Type, ErrorFlag, SinceDate, MarketID, CentrOffice );
   if( ErrorFlag )
      /* Не нашли курс. Попробуем найти обратный. */
      Inverse = true;
      K = TS_GetRateOnDate( ADate, fiidTo, fiidFrom, false, Type, ErrorFlag, SinceDate, MarketID, CentrOffice);
   end;

   if( not ErrorFlag )
      if( Inverse )
         SetParm( 0, SumFromDbl / K );
      else
         SetParm( 0, SumFromDbl * K );
      end;
      SetParm( 7, SinceDate );
      return true;
   end;

   if( SayError )
      MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;
   SetParm( 0, 0.0 );
   /* Сбрасываем ошибку. */
   InitError();
   return false;
END;

/* Конвертация суммы типа double другую валюту через рубли.
      SumToDbl    - Сюда запишем результат. Double.
      SumFromDbl  - Сумма для конвертации. Double.
      ADate       - Дата, на которую брать курс.
      fiidFrom    - Из какой валюты.
      fiidTo      - В какую валюту.
      SayError    - Флаг. Выдавать сообщения об ошибке. Если не задан, то
                    сообщения не выдаем.
   В случае ошибки возвращаем False, в SumToDbl устанавливаем 0. */
MACRO TS_ConvSumCrossDbl( SumToDbl, SumFromDbl, ADate, fiidFrom, fiidTo, SayError, Type, SinceDate, MarketID, CentrOffice )
   var
      SumFIFrom, SumFITo;

   if(   TS_ConvSumDbl( SumFIFrom, 1, ADate, fiidFrom, NATCUR, false, Type, SinceDate, MarketID, CentrOffice )
         and TS_ConvSumDbl( SumFITo, 1, ADate, fiidTo, NATCUR, false, Type, SinceDate, MarketID, CentrOffice )
         )
      if( SumFITo == 0.0 )
         SetParm( 0, 0.0 );
      else
         SetParm( 0, SumFromDbl * SumFIFrom / SumFITo );
      end;
      SetParm( 7, SinceDate );
      return true;
   end;

   if( SayError )
      MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
   end;
   SetParm( 0, 0.0 );
   /* Сбрасываем ошибку. */
   InitError();
   return false;
END;

/* Конвертация суммы типа double из одной валюты в другую.
   Для конвертации пытаемся использовать: прямой, обратный, кросс-курс.
   Всегда берем основной курс. Функциональность аналогична SmartConvertSum.
      SumToDbl    - Сюда запишем результат. Double.
      SumFromDbl  - Сумма для конвертации. Double.
      ADate       - Дата, на которую брать курс.
      fiidFrom    - Из какой валюты.
      fiidTo      - В какую валюту.
      SayError    - Флаг. Выдавать сообщения об ошибке. Если не задан, то
                    сообщения не выдаем.
   В случае ошибки возвращаем False, в SumToDbl устанавливаем 0. */
MACRO TS_SmartConvertSumDbl( SumToDbl, SumFromDbl, ADate, fiidFrom, fiidTo,
                             SayError, Type, SinceDate, MarketID, CentrOffice )
   var NewSum;

   if( sinceDate != NULL )
      sinceDate = DATE(sinceDate);
   end;
   if( ADate != NULL )
      ADate = DATE(ADate);
   end;

   if( fiidFrom == fiidTo )
      NewSum = SumFromDbl;
   elif( not TS_ConvSumDbl( NewSum, SumFromDbl, ADate, fiidFrom, fiidTo, false, Type, SinceDate, MarketID, CentrOffice ) )
      if( not TS_ConvSumCrossDbl( NewSum, SumFromDbl, ADate, fiidFrom, fiidTo, false, Type, SinceDate, MarketID, CentrOffice ) )
         if( SayError )
            MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, ADate) );
         end;
         SetParm( 0, 0.0 );
         /* Сбрасываем ошибку. */
         InitError();
         return false;
      end;
   end;
   SetParm( 0, NewSum );
   SetParm( 7, SinceDate );
   return true;
END;

/* Конвертация сумм в разных валютах с обработкой ошибок. Используется
   для конвертации денег (money). */
MACRO TS_SmartConvertSum( sumTo:MONEY, sumFrom:MONEY, sinceDate:DATE, fiidFrom:INTEGER, fiidTo:INTEGER, SayError:BOOL )
    var NewSum = $0;
    if( sinceDate != NULL )
       sinceDate = DATE(sinceDate);
    end;
    if( fiidFrom == fiidTo )  NewSum = sumFrom;
    elif( ConvSum( NewSum, sumFrom, sinceDate, fiidFrom, fiidTo ) != 0 )
      if( ConvSumCross( NewSum, sumFrom, sinceDate, fiidFrom, fiidTo ) != true ) 
         if( SayError == true )
            MsgBox( GetCurrencyConvertErrorMsg(fiidFrom, fiidTo, sinceDate) );
         end; 
         /* Сбрасываем ошибку. */
         InitError();
         return false;
      end;
    end;
    SetParm( 0, NewSum );
    return true;
END;

/* Получить значение категории
      Obj         -  объект
      KindCateg   -  вид категории
      ObjType     -  вид объекта, если не задан, то "Ценная бумага"
   Если значение категории не задано, то возвращаем 0. */
MACRO ДУ_ПолучитьЗначениеКатегории( Obj:Object, KindCateg:INTEGER, ObjType:INTEGER )
  var AttrID;
  if( ObjType == null ) 
     ObjType = OBJTYPE_AVOIRISS;
  end;
  if( GetMainObjAttr( null, ObjType, UniID(Obj, ObjType), KindCateg, AttrID) )
     return AttrID;
  end;
  return 0;
END;

MACRO ПолучитьРольФИ( Fininstr:TRecHandler )
  VAR FI_Role = -1;

  if( Fininstr.rec.FI_Kind == FIKIND_AVOIRISS )
     FI_Role = FIROLE_SECURITIES;
  elif( Fininstr.rec.FI_Kind == FIKIND_METAL )
     FI_Role = FIROLE_PRECIOUS_METALS;
  else
     FI_Role = FIROLE_BANKROLL;
  end;

  return FI_Role;
END;

MACRO TS_GetRestAccount( Account:STRING, Code_Currency:INTEGER, Chapter:INTEGER, RestDat:DATE )
  var Rest = $0;
  OprGetAccountRest( Chapter, Code_Currency, Account, RestDat, Rest );
/*
  if( Code_Currency ) 
     Rest = RestAC( Account, Code_Currency, RestDat, null, Chapter );
  else
     Rest = RestA( Account, RestDat, null, Chapter );
  end;
*/
  return Rest;
END;

MACRO TS_GetRestAccountByRecord( AccBuf:TRecHandler, RestDat:DATE )
  return TS_GetRestAccount( AccBuf.rec.Account, AccBuf.rec.Code_Currency, AccBuf.rec.Chapter, RestDat ); 
END;

MACRO УстановитьСтатусПлатежа( Payment:RsbPayment, PaymStatus:INTEGER )

  if( Payment.PaymStatus != PaymStatus ) 
     /* IL 02.08.06 обязательно надо устанавливать PaymStatus перед IsFactPaym, иначе
        некорректно установится PMPAYM.PrimDocKind и как следствие такой платеж будет криво
        обрабатываться в арме (SCR 90056 и 92006) */
     Payment.PaymStatus = PaymStatus;
     if( PaymStatus == PM_READY_TO_SEND )
        Payment.IsFactPaym = "X";
     end;
  end;   
  return 0;
END;

MACRO ПлатежИсполнен( Payment:RsbPayment )
   return(
           (Payment.PaymStatus >= PM_READY_TO_SEND) OR 
           (Payment.PaymStatus == PM_CLOSED_W_M_MOVEMENT) 
         );
END;

MACRO ИсполнитьПлатеж( Payment:RsbPayment, WorkWithBank:BOOL ):INTEGER
  if( (Payment != null) AND (ПлатежИсполнен(Payment) == false) )
     if( УстановитьСтатусПлатежа( Payment, 
                                  TS_IIF( WorkWithBank == true, PM_READY_TO_SEND, PM_FINISHED) ) 
       )
        MsgBox( "Ошибка при утановке платежу статуса \"Исполнен\"" );
        return 1;
     end;
  end;
  return 0;
END;

/*PMPAYM.Purpose платежа по внесению/выводу капитала*/
MACRO НазначениеПлатежаВВК( DemandID:INTEGER )
  VAR Purpose = 0; /*UNDEFPURPOSE*/
  VAR Active  = TRecHandler( "tsactive.dbt" ),
      FI      = TRecHandler( "fininstr.dbt" );

  if( not FindActiveByDemand( DemandID, Active ) )
     msgbox( "Не найден актив по Т/О заявления на внесение/вывод капитала" );
  else 
     if( ПолучитьФинИн( Active.rec.FIID, FI ) ) 
        MsgBox( "Не найден финансовый инструмент актива с кодом " + Active.rec.ActiveCode );
     else
        Purpose = TS_IIF( FI.rec.FI_Kind == FIKIND_AVOIRISS, BAi, CAi );
     end;          
  end;
  return Purpose;
END;

/*Определить есть ли среди шагов операции шаг заданного системного вида (Kind_Action)
  IsNotExecute - искать только невыполненные шаги 
  BeginDate, EndDate - границы для  
     - планируемой даты выполнения (doprstep_dbt.Plan_Date) если IsNotExecute == true
     - фактической даты выполнения (doprstep_dbt.Fact_Date) если IsNotExecute == false
*/
MACRO TS_IsExistOperStep( ID_Operation:INTEGER, Kind_Action:INTEGER, IsNotExecute:BOOL, BeginDate:DATE, EndDate:DATE ) :BOOL
  VAR RS,
      Query = "SELECT COUNT(1) AS CountStep FROM doprstep_dbt " +
              " WHERE t_ID_Operation = " + string(ID_Operation) +" AND " +
              "       t_Kind_action  = " + string(Kind_Action);

  if( IsNotExecute == true )
     Query = Query + " AND t_IsExecute != 'X' ";
  end;

  if( BeginDate != null )
     Query = Query + " AND "+TS_IIF(IsNotExecute,"t_Plan_Date","t_Fact_Date")+" >= " + GetSQLDate(BeginDate);
  end;
  if( EndDate != null )
     Query = Query + " AND "+TS_IIF(IsNotExecute,"t_Plan_Date","t_Fact_Date")+" <= " + GetSQLDate(EndDate);
  end;
 
  RS = TRsbDataSet( Query );
  return (RS.MoveNext() AND (RS.CountStep != NULL) AND (RS.CountStep != 0) );
END;

/*UserMark для TSDEMAND и TSPROFIT, созданных на шаге операции*/
MACRO TS_UserMark( Mark:STRING, ID_Operation:INTEGER, ID_Step:INTEGER, ADate:Date ) :STRING
  return TS_StrCut(Mark,20) + 
         TS_StrCut(string(ID_Operation),10) + 
         TS_StrCut(string(ID_Step),5) +
         TS_StrCut(string(ADate),10);
END;

MACRO TS_GetMarkFromUserMark( UserMark:STRING ) :STRING
  return substr( UserMark, 1, 20 );
END;

MACRO TS_GetValueLL( List:INTEGER, ElementOrCode:VARIANT, Code:@STRING, Name:@STRING ):INTEGER
  var ll = TRecHandler("llvalues.dbt");

  LL_FindLLVALUES( List, ElementOrCode, ll );
  Name = ll.rec.Name;
  Code = ll.rec.Code;

  return ll.rec.Element;
END;

MACRO TS_NewSubpurpose( Purpose:INTEGER, DocKind:INTEGER, DocID:INTEGER )

  VAR RS = TRsbDataSet( "SELECT (NVL(MAX(t_SubPurpose), -1)+1) AS NewSubpurpose FROM dpmpaym_dbt " +
                        " WHERE t_DocKind    = " + string(DocKind) + " AND " +
                        "       t_DocumentID = " + string(DocID)   + " AND " +
                        "       t_Purpose    = " + string(Purpose) 
                      );
  if( RS.MoveNext() )
     return RS.NewSubpurpose;
  end;
  return 0;
END;

PRIVATE VAR PartyID_RCC = -1; /*РКЦ (субъект {MFO_RCC}) */ 
MACRO РКЦ()
  if( PartyID_RCC == -1 )
     PartyID_RCC  = ПолучитьКодСубъекта( {MFO_RCC}, PTCK_BIC ); 
     if( PartyID_RCC <= 0 )
        MsgBox( "Не найден РКЦ для " + {MFO_Bank} );
     end;
  end;
  return PartyID_RCC;
END;

PRIVATE VAR Party_ForGet = TRecHandler( "party.dbt" );
MACRO TS_GetPartyName( PartyID:INTEGER, LongName:@STRING ) :STRING

  if( ПолучитьСубъекта( PartyID, Party_ForGet ) == 0 )
     if( ValType(LongName) != V_UNDEF )
        LongName = Party_ForGet.rec.Name;
     end;
     return Party_ForGet.rec.ShortName;
  end;
  return "";
end;

/*Сформировать платеж */
PRIVATE VAR Payment  = TRecHandler( "pmpaym.dbt" );
PRIVATE VAR PaymPropDT = TRecHandler( "pmprop.dbt" );
PRIVATE VAR PaymPropCT = TRecHandler( "pmprop.dbt" );

MACRO TS_CreatePayment( Purpose:INTEGER, DocKind:INTEGER, DocID:INTEGER, 
                        ValueDate:DATE, 
                        PayerID:INTEGER, PayerBankID:INTEGER,
                        ReceiverID:INTEGER, ReceiverBankID:INTEGER,
                        Summa:MONEY, FIID:INTEGER, 
                        Ground:STRING, 
                        PayerAccount:STRING, ReceiverAccount:STRING,
                        Department:INTEGER, SubPurpose:INTEGER, 
                        PaymStatus:INTEGER,
                        RetPayment:@RsbPayment, TmpPaymentID:INTEGER ) :INTEGER

  VAR ErrStr = "", PayerName:string = "", ReceiverName:string = "", PayerBankName:string = "", ReceiverBankName:string = "";
  VAR PMObj;
  
  /* Если на одном шаге создается несколько обьектов то нужно обязательно передавать TmpPaymentID с отрицательным значением
     изза того что криво работает класс платежа
  */
  if( TmpPaymentID == NULL )
     TmpPaymentID = 0;
  end;

  PMObj = RsbPayment( TmpPaymentID );

  if( PMObj )
     /*Дублировать заполнение полей через Payment (TRecHandler) приходится из за отсутствия
       FillPaymentAccounts в классе платежа*/
     Payment.Clear();

     if( SubPurpose == NULL )
        SubPurpose = TS_NewSubpurpose( Purpose, DocKind, DocID );
     end;

     Payment.rec.Purpose    = PMObj.Purpose      = Purpose;  
     Payment.rec.SubPurpose = PMObj.SubPurpose   = SubPurpose;
     Payment.rec.PaymStatus = PMObj.PaymStatus   = TS_IIF( PaymStatus == NULL, PM_PREPARING, PaymStatus );
     Payment.rec.DocKind    = PMObj.DocKind      = DocKind;
     Payment.rec.DocumentID = PMObj.DocumentID   = DocID;

     Payment.rec.Payer     = PayerID;
     Payment.rec.Receiver  = ReceiverID;
     Payment.rec.PayFIID   = FIID;
     Payment.rec.FIID      = FIID;


     Payment.rec.ValueDate  = PMObj.ValueDate    = ValueDate;
     Payment.rec.Department = PMObj.Department   = Department;
     Payment.rec.OrderFIID  = Payment.rec.BaseFIID   = PMObj.OrderFIID = PMObj.BaseFIID     = FIID;
     Payment.rec.IsPlanPaym = PMObj.IsPlanPaym   = "X";
     Payment.rec.OrderAmount= Payment.rec.BaseAmount = PMObj.BaseAmount = PMObj.OrderAmount  = Summa;
                              PMObj.Ground       = Ground;

     PaymPropDT.Clear();
     PaymPropCT.Clear();
     PaymPropDT.rec.DebetCredit = PRT_Debet;
     PaymPropCT.rec.DebetCredit = PRT_Credit;

     if( FillPaymentAccounts( Payment.rec.Payer, Payment.rec.Receiver, 0, Payment, PaymPropDT, PaymPropCT, ErrStr ) == 0 )


         if( PayerAccount != "" ) /*Счет переданный параметром считаем более важным, чем счет из СПИ*/
            Payment.rec.PayerAccount = PayerAccount;
         end;

         /*Дозаполнить параметры плательщика, если они не заполнилось из СПИ*/
         if( PaymPropDT.rec.CodeKind <= 0 ) 
            PaymPropDT.rec.CodeKind     = PTCK_CONTR;
            PMObj.PayerBankCorrCodeKind = PTCK_CONTR;
         end;

         if( Payment.rec.PayerBankID <= 0 ) 
            Payment.rec.PayerBankID = PayerBankID;
            PaymPropDT.rec.BankCode = ПолучитьКодСубъекта( PayerBankID, PaymPropDT.rec.CodeKind );
         end;

         if( ReceiverAccount != "" ) /*Счет переданный параметром считаем более важным, чем счет из СПИ*/
            Payment.rec.ReceiverAccount = ReceiverAccount;
         end;

         /*Дозаполнить параметры получателя, если они не заполнилось из СПИ*/
         if( PaymPropCT.rec.CodeKind <= 0 ) 
            PaymPropCT.rec.CodeKind          = PTCK_CONTR;
            PMObj.ReceiverBankCorrCodeKind   = PTCK_CONTR;
         end;

         if( Payment.rec.ReceiverBankID <= 0 ) 
            Payment.rec.ReceiverBankID   = ReceiverBankID;
            PaymPropCT.rec.BankCode = ПолучитьКодСубъекта( Payment.rec.ReceiverBankID, PaymPropCT.rec.CodeKind );
         end;

         /*Параметры отправителя/получателя*/
         TS_GetPartyName( Payment.rec.Payer, @PayerName );
         TS_GetPartyName( Payment.rec.PayerBankID, @PayerBankName );

         TS_GetPartyName( Payment.rec.Receiver, @ReceiverName );
         TS_GetPartyName( Payment.rec.ReceiverBankID, @ReceiverBankName );

         PMObj.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                          Payment.rec.PayerBankID, 
                          PaymPropDT.rec.CodeKind, 
                          PaymPropDT.rec.BankCode, 
                          PayerBankName,
                          "",
                          FIID, 
                          2/*CHAPT2*/, 
                          Payment.rec.PayerAccount, 
                          PayerID, 
                          PayerName, 
                          ПолучитьКодСубъекта( Payment.rec.Payer, PTCK_INN ) );

         PMObj.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                          Payment.rec.ReceiverBankID, 
                          PaymPropCT.rec.CodeKind, 
                          PaymPropCT.rec.BankCode, 
                          ReceiverBankName,
                          "",
                          FIID, 
                          2/*CHAPT2*/, 
                          Payment.rec.ReceiverAccount, 
                          ReceiverID, 
                          ReceiverName, 
                          ПолучитьКодСубъекта( Payment.rec.Receiver, PTCK_INN ) );

         /*Плательщик*/
         PMObj.PayerFIID             = FIID;
         PMObj.PayerDpNode           = Payment.rec.PayerDpNode;

         PMObj.PayerBankCorrAcc      = PaymPropDT.rec.CorrAcc;
         PMObj.PayerBankCorrCode     = PaymPropDT.rec.CorrCode;
         PMObj.PayerBankCorrCodeKind = PaymPropDT.rec.CorrCodeKind;

         PMObj.PayerInOurBalance     = PaymPropDT.rec.InOurBalance;
         PMObj.PayerOurCorrAcc       = PaymPropDT.rec.OurCorrAcc;
         PMObj.PayerOurCorrID        = PaymPropDT.rec.OurCorrID;

         /*Получатель*/
         PMObj.ReceiverFIID             = FIID;
         PMObj.ReceiverDpNode           = Payment.rec.ReceiverDpNode;

         PMObj.ReceiverBankCorrAcc      = PaymPropCT.rec.CorrAcc;
         PMObj.ReceiverBankCorrCode     = PaymPropCT.rec.CorrCode;
         PMObj.ReceiverBankCorrCodeKind = PaymPropCT.rec.CorrCodeKind;

         PMObj.ReceiverInOurBalance     = PaymPropCT.rec.InOurBalance;
         PMObj.ReceiverOurCorrAcc       = PaymPropCT.rec.OurCorrAcc;
         PMObj.ReceiverOurCorrID        = PaymPropCT.rec.OurCorrID;

         PMObj.Actuate();
         RetPayment = PMObj;
     else 
        MsgBox( "Ошибка определения СПИ плательщика/получателя при создании платежа.\n" + ErrStr );
        return 1;
     end;

  else
     return 1;
  end;
  return 0;
END;

/*Виды базиса расчета (dnamealg_dbt 2317)*/
PRIVATE CONST BASIS_30360        = 1,    /*360 дней в году, 30 в месяце*/
              BASIS_ACT360       = 2,    /*360 дней в году, в месяце по календ.*/
              BASIS_ACTACT       = 4,    /*в году и в месяце по календарю*/
              BASIS_ACT365       = 8,    /*в году и в месяце по календарю без учета високосности*/
              BASIS_31360        = 1001; /*360 дней в году, 31 в месяце*/

/* количество дней в году с учетом базиса */
MACRO TS_DaysInYear( year:INTEGER, Basis:INTEGER ):INTEGER
  VAR NumDays;

  if( Basis == BASIS_ACTACT )
     NumDays = DATE(1,1,year+1) - DATE(1,1,year);
  elif( (Basis == BASIS_30360) OR
        (Basis == BASIS_31360) OR
        (Basis == BASIS_ACT360)
      )
     NumDays = 360;
  elif( Basis == BASIS_ACT365 )
     NumDays = 365;
  else
     MsgBox( "Не определен базис для расчета количества дней в году." );
     NumDays = 365;
  end;
  return NumDays;
END;

PRIVATE VAR NaturalPersonTax = NULL;
MACRO СТАВКА_НА_ДОХОДЫ_ФЛ():DOUBLE
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\СТАВКА НА ДОХОДЫ ФЛ";
  VAR   err;

  if( NaturalPersonTax == NULL )
     GetRegistryValue( RegPath, V_DOUBLE, NaturalPersonTax, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return NaturalPersonTax;
END;

PRIVATE VAR TS_WorkWithBank = NULL;
MACRO РАБОТА_С_РАСЧЕТНЫМ_БАНКОМ():BOOL
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\РАБОТА С РАСЧЕТНЫМ БАНКОМ";
  VAR   err;

  if( TS_WorkWithBank == NULL )
     GetRegistryValue( RegPath, V_BOOL, TS_WorkWithBank, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return TS_WorkWithBank;
END;

/*Значение настройки "Режим совместной работы с п/с "Депозитарий"*/
CONST TS_WORK_DEPO_NO      = 0, /*Без депозитария*/
      TS_WORK_DEPO_BACK_NO = 1,   /*С депозитарием без обратной связи */
      TS_WORK_DEPO_BACK    = 2;   /*С депозитарием включая обратную связь*/

PRIVATE VAR TS_WorkWithDepo:INTEGER = NULL;
MACRO РАБОТА_С_ДЕПОЗИТАРИЕМ():INTEGER
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\РАБОТА С ДЕПОЗИТАРИЕМ";
  const RegPath_Global = "COMMON\\WORK_MODE\\WORK_WITH_DEPOSITARY";
  VAR   err, WorkWithDepo_Global = "";

  if( TS_WorkWithDepo == NULL )
     GetRegistryValue( RegPath_Global, V_BOOL, WorkWithDepo_Global, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath_Global + "\"");
     end;

     if( WorkWithDepo_Global != "X" )
        TS_WorkWithDepo = TS_WORK_DEPO_NO;
     else
        GetRegistryValue( RegPath, V_INTEGER, TS_WorkWithDepo, err );
        if( err != 0 )
           MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
        end;
     end;
  end;
  return TS_WorkWithDepo;
END;

PRIVATE VAR TS_CalcComInLastDay:BOOL = NULL;
MACRO КОМИССИИ_ЗА_ПОСЛ_НЕРАБ_ДНИ():BOOL
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\КОМИССИИ ЗА НЕРАБОЧИЕ ДНИ";
  VAR   err;

  if( TS_CalcComInLastDay == NULL )
     GetRegistryValue( RegPath, V_BOOL, TS_CalcComInLastDay, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return TS_CalcComInLastDay;
END;

PRIVATE VAR CalcNKDCourse = NULL;
MACRO ДУ_РАСЧЕТ_НКД_ЧЕРЕЗ_КУРС():BOOL
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\РАСЧЕТ НКД ПО КУРСУ";
  VAR   err;

  if( CalcNKDCourse == NULL )
     GetRegistryValue( RegPath, V_BOOL, CalcNKDCourse, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return CalcNKDCourse;
END;

PRIVATE VAR CalcMoneyInOut = NULL;
MACRO ДУ_ВЫПЛАТА_ПРИБЫЛИ_ДЕНЬГАМИ():BOOL
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ВЫПЛАТА ПРИБЫЛИ ДЕНЬГАМИ";
  VAR   err;

  if( CalcMoneyInOut == NULL )
     GetRegistryValue( RegPath, V_BOOL, CalcMoneyInOut, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return CalcMoneyInOut;
END;

PRIVATE VAR NKDCourseType = NULL;
MACRO ДУ_ВИД_КУРСА_НКД_ДЛЯ_ЦБ():DOUBLE
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ВИД КУРСА НКД ДЛЯ ЦБ";
  VAR   err;

  if( NKDCourseType == NULL )
     GetRegistryValue( RegPath, V_INTEGER, NKDCourseType, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return NKDCourseType;
END;

PRIVATE VAR CourseTypeAvoir = NULL;
MACRO ДУ_ВИД_КУРСА_ЦБ_ДЛЯ_СЧА():DOUBLE
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ВИД КУРСА ЦБ ДЛЯ СЧА";
  VAR   err;

  if( CourseTypeAvoir == NULL )
     GetRegistryValue( RegPath, V_INTEGER, CourseTypeAvoir, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return CourseTypeAvoir;
END;

PRIVATE VAR CourseTypeFut = NULL;
MACRO ДУ_ВИД_КУРСА_ФЬЮЧЕРСА_ДЛЯ_СЧА():DOUBLE
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ВИД КУРСА ФЬЮЧЕРСА ДЛЯ СЧА";
  VAR   err;

  if( CourseTypeFut == NULL )
     GetRegistryValue( RegPath, V_INTEGER, CourseTypeFut, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return CourseTypeFut;
END;

PRIVATE VAR CourseTypeOpt = NULL;
MACRO ДУ_ВИД_КУРСА_ОПЦИОНА_ДЛЯ_СЧА():DOUBLE
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ВИД КУРСА ОПЦИОНА ДЛЯ СЧА";
  VAR   err;

  if( CourseTypeOpt == NULL )
     GetRegistryValue( RegPath, V_INTEGER, CourseTypeOpt, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return CourseTypeOpt;
END;

PRIVATE VAR MarketCodeForAvoir = NULL;
MACRO ДУ_ТС_КУРСА_ЦБ_ДЛЯ_СЧА():STRING
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ТС КУРСА ЦБ ДЛЯ СЧА";
  VAR   err;

  if( MarketCodeForAvoir == NULL )
     GetRegistryValue( RegPath, V_STRING, MarketCodeForAvoir, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return MarketCodeForAvoir;
END;

PRIVATE VAR DepartmentDU = NULL;
MACRO ОтделДУ():INTEGER
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ОТДЕЛ ДОВЕРИТЕЛЬНОГО УПРАВЛЕНИЯ";
  VAR   err;

  if( DepartmentDU == NULL )
     GetRegistryValue( RegPath, V_INTEGER, DepartmentDU, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return DepartmentDU;
END;

PRIVATE VAR КурсНерабочегоДняПоПоследнемуРабочему = NULL;
MACRO КУРС_НЕРАБ_ДНЯ_ПО_ПОСЛЕД_РАБ():BOOL
  CONST RegPath = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\КУРС НЕРАБ. ДНЯ ПО ПОСЛЕД. РАБ.";
  VAR   err;

  if( КурсНерабочегоДняПоПоследнемуРабочему == NULL )
     GetRegistryValue( RegPath, V_BOOL, КурсНерабочегоДняПоПоследнемуРабочему, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return КурсНерабочегоДняПоПоследнемуРабочему;
END;

/*Депозитарий*/
PRIVATE VAR TS_CustodyOfficeID = NULL;
MACRO TS_GetCustodyOfficeID():INTEGER
  CONST RegPath = "DEPO\\OURDEPOSITOFFICE";
  VAR   err;

  if( TS_CustodyOfficeID == NULL )
     GetRegistryValue( RegPath, V_INTEGER, TS_CustodyOfficeID, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return TS_CustodyOfficeID;
END;

MACRO ДУ_ПолучитьНКДПоКурсу( FIID, CalcDate )
  var RSD;
  var cmd = RSDCommand( "select RSB_FIInstr.FindNKDCource( ?, ?, ? ) NKD from dual" );
  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, CalcDate );
  cmd.addParam( "", RSDBP_IN, 1 );
  cmd.execute();

  RSD = TRsbDataSet(cmd);
  if( RSD.MoveNext() )
     return RSD.rec.NKD;
  end;

  return 0;
END;

MACRO ДУ_ЕстьНулевыеКупоны( FIID, CalcDate )
  var RSD;
  var cmd = RSDCommand( "select RSB_FIINSTR.FI_HasZeroCoupons( ?, ? ) v_Exist from dual" );
  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, CalcDate );
  cmd.execute();

  RSD = TRsbDataSet(cmd);
  if( RSD.MoveNext() )
     if (RSD.v_Exist == 0)
        return false;
     else
        return true;
     end;
  end;

  return false;
END;

MACRO ПолучитьНалоговуюИнспекцию( PartyID:INTEGER, TaxInstitution:@INTEGER ):BOOL
  VAR Party = TRecHandler( "party.dbt" );

  if( (ПолучитьСубъекта( PartyID, Party ) == 0) AND (Party.rec.TaxInstitution > 0) )
     TaxInstitution = Party.rec.TaxInstitution;
     return true;
  end;

  return false;
END;

/* llvalues для objects = 2800 - Учетные события ДУ)*/
MACRO TS_DemandEvent( EventNumber:STRING ):INTEGER
   if( (EventNumber == null) OR (EventNumber == "") )
      return -1;
   end;
   return TS_GetValueLL( OBJTYPE_TSEVENT, EventNumber ); 
END;

/* llvalues для objects = 2820 - Вид дохода/расхода ДУ)*/
MACRO TS_ProfitKind( KindNumber:STRING ):INTEGER
   if( (KindNumber == null) OR (KindNumber == "") )
      return 0;
   end;
   return TS_GetValueLL( OBJTYPE_TSKIND_PROFIT, KindNumber ); 
END;

/* llvalues для objects = 2810 - Виды требований/обязат. ДУ)*/
MACRO TS_DemandKind( KindNumber:STRING ):INTEGER
   if( (KindNumber == null) OR (KindNumber == "") )
      return -1;
   end;
   return TS_GetValueLL( OBJTYPE_TSKIND_DEMAND, KindNumber ); 
END;

/*Найти последнее Т/О с заданным УС(t_EventID) по договору*/
MACRO TS_GetLastDemand( OrderID:INTEGER, DemandEvent:STRING, DemandStatus:INTEGER ):INTEGER
  VAR DemandID = 0,
      RS = TRsbDataSet( 
         "SELECT NVL( MAX(demand.t_ID), 0) AS DemandID" +
         "  FROM dtsdemand_dbt demand "+
         " WHERE demand.t_OrderID = " + string(OrderID) + " AND "+ 
         TS_IIF( DemandStatus == NULL, "", "demand.t_State = " + string(DemandStatus) + " AND " ) +
         "       demand.t_EventID = " + string( TS_DemandEvent(DemandEvent) )
           );

  if( RS.MoveNext() )
     DemandID = RS.DemandID;
  end;
  return DemandID;
END;

/*Найти последний платеж*/
MACRO TS_GetLastPayment( DocKind:INTEGER, DocID:INTEGER, Purpose:INTEGER ):INTEGER
  VAR PaymentID = 0,
      RS = TRsbDataSet( 
         "SELECT NVL( MAX(pm.t_PaymentID), 0) AS PaymentID" +
         "  FROM dpmpaym_dbt pm "+
         " WHERE pm.t_DocKind    = " + string(DocKind) + " AND " +
         "       pm.t_DocumentID = " + string(DocID)   + " AND " +
         "       pm.t_Purpose    = " + string(Purpose) 
           );

  if( RS.MoveNext() )
     PaymentID = RS.PaymentID;
  end;
  return PaymentID;
END;

macro FindFirstTSSRVOBJ( ServID, ObjKind )
  var RSD;
  var SQLcmd = RSDCommand("select t_ObjectID from dtssrvobj_dbt where t_SrvOpID = ? and t_ObjectKind = ? and ROWNUM = 1");
  SQLcmd.addParam( "", RSDBP_IN, ServID );
  SQLcmd.addParam( "", RSDBP_IN, ObjKind );
  SQLcmd.execute();

  RSD = TRsbDataSet(SQLcmd);

  if( RSD.MoveNext() )
     return RSD.rec.ObjectID;
  else
     return -1;
  end;
end;

/* Надежность определения ТСС */
MACRO TS_ExistNOSS( avr:OBJECT, dat:DATE ):BOOL
  VAR NumInList = "", ValidFromDate = DATE(0,0,0);

  return ( (GetMainObjAttr( null, OBJTYPE_AVOIRISS, UniID(avr, OBJTYPE_AVOIRISS), 
                            29/*Возможность надежного определения ТСС для ДУ*/, 
                            null, null, NumInList, dat, ValidFromDate
                          ) == true
           )
           AND (ValidFromDate <= dat)
           AND (NumInList == "1")
         );
END;

MACRO ДУ_ПолучитьВидКурса( RateType:INTEGER ):INTEGER
  var ErrCode, Path = null, NewRateType = RateType;

  if( RateType == TS_RATETYPE_TSS ) /* вид курса ТСС */
     Path = "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\ВИД КУРСА ТСС";
  end;

  if( Path != NULL )
     GetRegistryValue( Path, V_INTEGER, NewRateType, ErrCode );
     if( ErrCode != 0 )
        return RateType;
     end;
  end;

  return NewRateType;
END; 

/* Получаем буфер счета. Если счет не найден, то возвращаем false.
      Chapter     -  глава
      FIID        -  валюта
      Account     -  номер счета
      AccBuf      -  возвращам буфер счета через этот параметр
      TempAccount -  искать во временной базе(true - искать)*/
MACRO TS_GetAccount( Chapter:INTEGER, FIID:INTEGER, Account:STRING, AccBuf:VARIANT, TempAccount:BOOL ):BOOL
   VAR AccRec;
   var RetVal = false;
   record AccountBuf(account);

   AccRec = TBFile( "account.dbt", "R", 0 );

   AccRec.rec.Chapter       = Chapter;
   AccRec.rec.Code_Currency = FIID;
   AccRec.rec.Account       = Account;
   if( AccRec.GetEQ() )
      Copy( AccBuf, AccRec );
      RetVal = true;
   end;

   /* если надо поищем счёт во временной базе */
   if((RetVal == false) and (ValType(TempAccount) == V_BOOL) and (TempAccount == true))
      ClearRecord( AccountBuf );
      if(DL_FindAccount( Chapter, FIID, Account, AccountBuf ) == 0)
         Copy( AccBuf, AccountBuf );
         RetVal = true;
      end;
   end;

   return RetVal;
END;

/*Можно или нет закрывать договор ДУ*/
MACRO TS_CheckExecuteClose( ID_Operation:INTEGER ) :BOOL
  VAR RS, RetVal = true,
      Query = "SELECT COUNT(1) AS CountStep FROM doprstep_dbt " +
              " WHERE     t_ID_Operation = " + string(ID_Operation) +
                   "  AND t_IsExecute = 'R'";

  RS = TRsbDataSet( Query );
  if( RS.MoveNext() AND (RS.CountStep > 1) )
     MsgBox( "Для выполнения закрытия договора необходимо что бы все шаги по операции были выполнены." );
     RetVal = false;
  end;

  return RetVal;
END;

MACRO TS_BofficeKind():STRING
   return StrFor(CodeFor("А"));
END;                      

MACRO TS_UserMark_prefix( Role:INTEGER ):STRING
   if( Role == TS_DEMAND_ROLE_REQUEST )
      return "Треб_";
   else
      return "Обяз_";
   end;
END;

MACRO TS_DemandUserMark_Req( Role:INTEGER, ReqID:INTEGER, AssetID:INTEGER ):STRING
   return TS_UserMark_prefix(Role) + "ВВК_" + string(ReqID) + "_"+ string(AssetID);
END;

MACRO TS_DemandUserMark_ReqItog( Role:INTEGER, ReqID:INTEGER, ItogName:STRING ):STRING
   return TS_UserMark_prefix(Role) + "ВВК_" + string(ReqID) + "_"+ ItogName;
END;

MACRO TS_DemandUserMark_Itogs( Role:INTEGER, ServOpID:INTEGER, OrderID:INTEGER, ItogName:STRING ):STRING
   return TS_UserMark_prefix(Role) + "ПИ_" + string(ServOpID) + "_"+ string(OrderID) + "_"+ ItogName;
END;

MACRO TS_DemandUserMark_ChargeCom( Role:INTEGER, ServOpID:INTEGER, OrderID:INTEGER, ItogName:STRING ):STRING
   return TS_UserMark_prefix(Role) + "НК_" + string(ServOpID) + "_"+ string(OrderID) + "_"+ ItogName;
END;

MACRO TS_DemandUserMark_CalcPrCl( Role:INTEGER, ServOpID:INTEGER, OrderID:INTEGER, ItogName:STRING, ID_Step:INTEGER ):STRING
   return TS_UserMark_prefix(Role) + "РПЗ_" + string(ServOpID) + "_"+ string(ID_Step) + "_"+ string(OrderID) + "_"+ ItogName;
END;

MACRO TS_DemandUserMark_CalcSNP( Role:INTEGER, ServOpID:INTEGER, OrderID:INTEGER, ItogName:STRING, ID_Step:INTEGER ):STRING
   return TS_UserMark_prefix(Role) + "СНП_" + string(ServOpID) + "_"+ string(ID_Step) + "_"+ string(OrderID) + "_"+ ItogName;
END;

MACRO TS_DemandUserMark_InCap( Role:INTEGER, ReqID:INTEGER, AssetID:INTEGER ):STRING
   return TS_UserMark_prefix(Role) + "ВК_" + string(ReqID) + "_"+ string(AssetID);
END;

PRIVATE VAR Demand = TRecHandler( "tsdemand.dbt" );
MACRO TS_CreateDemandTrust( RetDemand:TRecHandler, ID_Operation:INTEGER, UserMark:STRING, Role:INTEGER, 
                            КВТО:STRING, КУС:STRING, Дплан:DATE, Summa:MONEY,
                            ActiveFIID:INTEGER, ActiveDepositoryID:INTEGER,
                            TSOrderID:INTEGER, BaseFIID:INTEGER, AssetID:INTEGER, ActiveKind:INTEGER,
                            ID_Step:integer, DocKind:integer, DocID:integer, OpenDate:DATE ):BOOL

  if( AssetID == NULL )
     AssetID = 0;
  end;

  Demand.Clear();   
  Demand.rec.Role             =  Role;      // Т/О
  Demand.rec.Kind             =  TS_DemandKind(КВТО);      // Вид Т/О из классификатора "ДУ вид Т/О".
  Demand.rec.InitialQuantity  =  Summa;     // исходная сумма 
  Demand.rec.FIID             =  NATCUR;    // валюта учета
  Demand.rec.PlanCloseDate    =  Дплан;     // планируемая дата исполнения
  Demand.rec.OpenDate         =  TS_IIF(OpenDate == NULL, Дплан, OpenDate);
  Demand.rec.BofficeKind      =  TS_BofficeKind(); // бэкофис ПИ 
  Demand.rec.UserMark         =  UserMark; /* метка*/
  Demand.rec.EventID          =  TS_DemandEvent(КУС); // учетное событие создания Т/О 
  Demand.rec.Department       =  {operdprt};          // филиал
  Demand.rec.BaseFIID         =  BaseFIID;
  Demand.rec.KindProfit       =  -1; /*TS_ProfitKind(КВДР); убрал тк ДР неиспользуется*/
  Demand.rec.ID_Operation     =  ID_Operation;
  Demand.rec.ID_Step          =  ID_Step;
  Demand.rec.DocKind          =  DocKind;
  Demand.rec.DocID            =  DocID;

  if( TS_CreateDemand( TSOrderID,       
                       TS_IIF( ActiveKind == NULL, TS_ACTIVE_KIND_EMISSIVE, ActiveKind),
                       ActiveFIID,          
                       ActiveDepositoryID,  
                       AssetID,
                       Demand, 
                       true /*показывать ошибку*/ ) != 0 )
     return false;                                                                                                                          
  end;

  if( RetDemand != null )
     Copy( RetDemand, Demand );
  end;

  return true;
END;

// Все проверки, годится ли субъект для НДФЛ ДУ
MACRO TS_IsPayerNPTaxAllCheck( PartyID:INTEGER, CalcDate:DATE ):BOOL
   var cmd;
   cmd = RsdCommand(RslDefCon, "begin\n ? := NPTAX.TS_IsPayerNPTaxAllCheck(?,?);\n end; ");

   cmd.addParam("ret_val"   ,  RSDBP_RETVAL, V_INTEGER );
   cmd.addParam("PartyID"   ,  RSDBP_IN,     PartyID   );
   cmd.addParam("OperDate"  ,  RSDBP_IN,     CalcDate  );
   cmd.execute();

   if (cmd.Value(0) == 1)
      return true;
   end;
   return false;
END;

/*последний день месяца*/
macro LastDay( m, y )/* передаем Месяц, Год */
   var d;
   m = m + 1;
   if (m > 12)
      m = 1;
      y = y + 1;
   end;
   DateSplit (Date(1,m,y)-1,d);
   return d;
end;

/*последний рабочий день месяца?*/
macro IsLastWorkDayInMonth( CDate:Date )
   var LastDate,m,y;
   DateSplit (CDate,0,m,y);

   LastDate = Date(LastDay(m, y),m,y);
   if( not IsWorkDay(LastDate));
      LastDate = GetDateAfterWorkDays(LastDate,-1);
   end;
   return (CDate==LastDate);
end;

//Используется для построения объектов НОБ на шагах сервисных операций.
//
MACRO NPTCalcNOB_Ex(OrderFD, CalcDate, ID_Operation, ID_Step)
  VAR NOB_BegDate, Year;
  VAR ServOp  = TRecHandler( "tssrvop.dbt" ); 

  /*в операции подведения итогов расчет связей не делаем*/
  if( TS_RunFromServiceOper( ServOp ) )
     if( ServOp.rec.Kind_Operation == TS_DOC_CALCITOGS_IDDU )
        if ( OrderFD.Order.rec.NPT_LINKCALCDATE < CalcDate )
           MsgBox( "Для договора: \"" + OrderFD.Number() + "\" необходимо построить связи на дату расчетов "+string(CalcDate) );
           return 1;
        end;
     end;
  end;

  if (OrderFD.Order.rec.NPT_LINKCALCDATE < CalcDate)
     if( NPTCreateLinks( OrderFD.Order.rec.ID,
                         0,      
                         Date(0,0,0),     
                         0,    
                         0, 
                         -1,        
                         1,        
                         CalcDate,     
                         ID_Operation,
                         ID_Step,
                         0
                       ) != 0
       )
        MsgBox( "Ошибка при построении налоговых связей" );
        return 1;
     end;
  end;
  NOB_BegDate = OrderFD.Order.rec.NPT_TAXCALCDATE;
  if( NOB_BegDate == DATE(0,0,0) )
     DateSplit( CalcDate, NULL, NULL, Year );
     NOB_BegDate = DATE(31,12,Year-1);
  end;

  if (NOB_BegDate < CalcDate)
     if( NPTCalcNOB( OrderFD.Order.rec.ID, ID_Operation, ID_Step,
                     NOB_BegDate + 1, CalcDate
                   ) != 0
       )
        MsgBox( "Ошибка при расчете НОБ" );
        return 1;
     end;

     if( NPTUpdateTaxCalcDate( OrderFD.Order.rec.ID, CalcDate, NOB_BegDate ) != 0 )
        MsgBox( "Ошибка при изменении даты начала пересчета НОБ в договоре" );
        return 1;
     end;
  end;

  return 0;
END;

//Процедура пересчета НОБ.
MACRO NPTRecalcTaxSum(OrderID, CalcDate, Com1, Com2, Com3, NP:@MONEY, NDFL_Calc:@MONEY)
   VAR cmd = RsdCommand("begin\n NPTAX.NPTRecalcTaxSum(?,?,?,?,?,?,?);\n end; ");

   cmd.addParam("p_OrderID",       RSDBP_IN, OrderID      );
   cmd.addParam("p_CalcDate",      RSDBP_IN, CalcDate     );
   cmd.addParam("p_Com1",          RSDBP_IN, Com1         );
   cmd.addParam("p_Com2",          RSDBP_IN, Com2         );
   cmd.addParam("p_Com3",          RSDBP_IN, Com3         );

   cmd.addParam("p_NP",            RSDBP_OUT, V_DOUBLE );
   cmd.addParam("p_NDFL_Calc",     RSDBP_OUT, V_DOUBLE );

   cmd.execute();

   NP                    = cmd.value(5);
   NDFL_Calc             = cmd.value(6);

   return true;
END;

/*среднехронологическая ставка ЦБР */
MACRO СреднCтавкаРефинансированияЦБР( BeginDate:DATE, EndDate:DATE, FIID:INTEGER ):DOUBLE
  VAR RS, Rate = 0.0, T = EndDate - BeginDate + 1, T_j = 0,
      BeginDate_j, EndDate_j,
      cmd = RSDCommand(       
         "SELECT p.t_RATE, p.t_EffectiveDate AS t_OpenDate, " +
         "       NVL( (SELECT MIN(pm.t_EffectiveDate)-1 "+
         "               FROM dcbrfrate_dbt pm" +
         "              WHERE     pm.t_FIID = p.t_FIID " + 
         "                    AND pm.t_EffectiveDate BETWEEN p.t_EffectiveDate+1 AND ? "+
         "            ), ?) t_EndDate" +
         "  FROM dcbrfrate_dbt p" +
         " WHERE     p.t_FIID   = ? " + 
         "       AND p.t_EffectiveDate BETWEEN (SELECT MAX(p1.t_EffectiveDate) "+
                                             "    FROM dcbrfrate_dbt p1" +
                                             "   WHERE     p1.t_FIID   = ? " +
                                             "         AND p1.t_EffectiveDate <= ? " +
                                             " ) AND ? " +
         " ORDER BY p.t_EffectiveDate "
                      );

  cmd.addParam( "", RSDBP_IN, EndDate    );
  cmd.addParam( "", RSDBP_IN, EndDate    );
  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, BeginDate  );
  cmd.addParam( "", RSDBP_IN, EndDate    );
  cmd.execute();

  RS = TRsbDataSet( cmd );
  while( RS.MoveNext() )
     BeginDate_j = TS_IIF( SQL_ConvTypeDate(RS.t_OpenDate) < BeginDate, BeginDate, SQL_ConvTypeDate(RS.t_OpenDate) );
     EndDate_j   = TS_IIF( SQL_ConvTypeDate(RS.t_EndDate ) > EndDate, EndDate, SQL_ConvTypeDate(RS.t_EndDate) );
     T_j = EndDate_j - BeginDate_j + 1;
     Rate = Rate + RS.Rate*T_j;
  end;

  if(T != 0)
     Rate = Rate/T;
  end;

  return Rate;
END;

MACRO ЭтоВыплата( Flag:STRING ):BOOL
  return (Flag == "V");
END;

MACRO ЭтоКапитализация( Flag:STRING ):BOOL
  return (Flag == "K");
END;

MACRO ЭтоНачисление( Flag:STRING ):BOOL
  return (Flag == "N");
END;

MACRO НачалоТекущегоПДД(OrderID:integer, CalcDate:date):date

  var cmd = RsdCommand(RslDefCon, "begin\n ? := TrustAPI.OrderPeriodStartDate(?, ?);\n end; ");
  cmd.addParam("ret_val", RSDBP_RETVAL, V_DATE   );
  cmd.addParam("",        RSDBP_IN,     OrderID  );
  cmd.addParam("",        RSDBP_IN,     CalcDate );
  cmd.execute();

  return SQL_ConvTypeDate(cmd.Value(0));
END;

/* дополнить строку слева символами Chr в колчестве Count */
MACRO StrFill(Chr, Count)
  var str = "";
  while( Count > 0 )
    str = str + Chr;
    Count = Count - 1;
  end;

  return str;
END;

/* дополнить str нулями слева до длины fldLen */
MACRO LeadZero(str, fldLen)
  if( strlen(str) < fldLen )
    str = StrFill( "0", fldLen - strlen(str)) + str;
  end;

  return str;
END;

/* дата с лидирующим нулём и 'Разделитель' в качестве разделителя */
MACRO СтрДата(Дата:Date, Разделитель:STRING)
  var D, M, Y, point;
  DateSplit( Дата, D, M, Y);

  if(Разделитель == NULL)
     point = ".";
  else
     point = Разделитель;
  end;

  return (LeadZero(string(D), 2) + point + LeadZero(string(M), 2) + point + string( Y));
END;

MACRO ДУ_ПолучитьНДС( SayError:bool )
   var TaxNDS = 0.0, ErrCode = 0;
   GetRegistryValue( "COMMON\\PARAMETERS\\NDS", V_DOUBLE, TaxNDS, ErrCode );
   if( ErrCode AND (SayError == true) )
      msgbox("Ошибка при получении величины НДС из настроек\nCOMMON\\PARAMETERS\\NDS");
   end;
   return TaxNDS;   
END;

MACRO ПолучитьНомерКомиссии( ContrID:integer, NumInList:string, ComDate:Date, CalcPeriodType:@integer, TypeOrder:string, WithoutEndDate:bool ):integer
  var query, DataSet, RetVal = -1, Select;
  if(CalcPeriodType != null)
     CalcPeriodType = -1;
  end;

  Select = " SELECT concom.t_CommNumber, concom.t_CalcPeriodType, concom.t_DateBegin                                       " +
           "   FROM dsfconcom_dbt concom, dsfcomiss_dbt comiss                                                             " +
           "  WHERE concom.t_ObjectID   = ?                                                                                " +
           "    AND concom.t_ObjectType = 659 /*OBJTYPE_SFCONTR*/                                                          " +
           "    AND concom.t_feetype    = 1   /*SF_FEE_TYPE_PERIOD*/                                                       " +
           "    AND concom.t_status     = 0   /*Начисляется*/                                                              " +
           "    AND concom.t_DateBegin <= ?                                                                                " +
           "    AND comiss.t_FeeType    = concom.t_FeeType                                                                 " +
           "    AND comiss.t_Number     = concom.t_CommNumber                                                              " +
           "    AND exists( SELECT objattr.t_NumInList                                                                     " +
           "                  FROM dobjatcor_dbt objatcor, dobjattr_dbt objattr                                            " +
           "                 WHERE objatcor.t_Object     = lpad(comiss.t_FeeType, 5, '0') || lpad(comiss.t_Number, 5, '0') " +
           "                   AND objatcor.t_GroupID    = 2   /*OBJGROUP_SFCOM_KIND*/                                     " +
           "                   AND objatcor.t_ObjectType = 650 /*OBJTYPE_SFCOMISS*/                                        " +
           "                   AND objatcor.t_General    = 'X'                                                             " +
           "                   AND objattr.t_ObjectType  = objatcor.t_ObjectType                                           " +
           "                   AND objattr.t_GroupID     = objatcor.t_GroupID                                              " +
           "                   AND objattr.t_AttrID      = objatcor.t_AttrID                                               " +
           "                   AND objattr.t_NumInList   in(?)                                                             " +
           "              )                                                                                                ";

  if( TypeOrder != null )
     Select = Select + " AND exists( SELECT objattr.t_NumInList                                                                     " +
                       "               FROM dobjatcor_dbt objatcor, dobjattr_dbt objattr                                            " +
                       "              WHERE objatcor.t_Object     = lpad(comiss.t_FeeType, 5, '0') || lpad(comiss.t_Number, 5, '0') " +
                       "                AND objatcor.t_GroupID    = 1   /*OBJGROUP_SFCOM_FEEMOMENT*/                                " +
                       "                AND objatcor.t_ObjectType = 650 /*OBJTYPE_SFCOMISS*/                                        " +
                       "                AND objattr.t_ObjectType  = objatcor.t_ObjectType                                           " +
                       "                AND objattr.t_GroupID     = objatcor.t_GroupID                                              " +
                       "                AND objattr.t_AttrID      = objatcor.t_AttrID                                               " +
                       "                AND objattr.t_NumInList   in(?)                                                             " +
                       "           )                                                                                                ";
  end;

  if( (WithoutEndDate == null) or (WithoutEndDate == false) )
     Select = Select + " AND ((concom.t_DateEnd >= ?) or (concom.t_DateEnd = TO_DATE('01.01.0001','DD.MM.YYYY'))) ";
  end;

  Select = Select + " ORDER BY concom.t_DateBegin DESC ";

  query = RSDCommand( Select );
  query.addParam( "", RSDBP_IN, ContrID   );
  query.addParam( "", RSDBP_IN, ComDate   );
  query.addParam( "", RSDBP_IN, NumInList );
  if( TypeOrder != null )
     query.addParam( "", RSDBP_IN, TypeOrder );
  end;
  if( (WithoutEndDate == null) or (WithoutEndDate == false) )
     query.addParam( "", RSDBP_IN, ComDate );
  end;

  query.execute();
  DataSet = TRSBDataSet(query);
  if( DataSet.MoveNext())
    RetVal = SQL_ConvTypeInteger(DataSet.CommNumber);
    if(CalcPeriodType != null)
       CalcPeriodType = SQL_ConvTypeInteger(DataSet.CalcPeriodType);
    end;
  end;

  return RetVal;
END;

/* Склонение дней в зависимости от числа */
MACRO strdays( p_num )

  var l_num;

  p_num = string( p_num );
  l_num = substr( p_num, strlen( p_num ) - 1, 1 );
  if( l_num == "1" )
   return "дней";
  end;

  l_num = substr( p_num, strlen( p_num ) );

  if( l_num == "1" )
   return "день";
  elif( ( l_num >= "2" ) and
        ( l_num <= "4" ) )
   return "дня";
  end;
  return "дней";
END;

MACRO ПолучитьСтавкуКомиссииПоАлгоритму(Kind:integer, Number:integer, ObjectID:integer, ObjectType:integer, FeeType:integer, CommNumber:integer, Flag:@integer, RateCom:@double)

  var RetVal:bool = false;
  var Query, Query2;
  var Select1, Select2, Select3, Select4;
  var Data1, Data2, Data3, Data4;

  /*Найдём тарифную сетку*/
  Query = " select tarscl.* "
        + "   from dsftarscl_dbt tarscl "
        + "  where tarscl.t_FeeType    = ? "
        + "    and tarscl.t_CommNumber = ? "
        + "    and tarscl.t_ObjectID   = ? "
        + "    and tarscl.t_ObjectType = ? "
        + "    and tarscl.t_AlgKind    = ? "
        + "    and tarscl.t_AlgNumber  = ? ";
  Select1 = RSDCommand("select count(1) nRec from( " + Query + " )");
  Select1.addParam( "", RSDBP_IN, FeeType    );
  Select1.addParam( "", RSDBP_IN, CommNumber );
  Select1.addParam( "", RSDBP_IN, ObjectID   );
  Select1.addParam( "", RSDBP_IN, ObjectType );
  Select1.addParam( "", RSDBP_IN, Kind       );
  Select1.addParam( "", RSDBP_IN, Number     );
  Select1.execute();
  Data1 = TRSBDataSet(Select1);
  if( Data1.MoveNext() and (Data1.nRec == 1) )
     RetVal = true;
     Select2 = RSDCommand( Query );
     Select2.addParam( "", RSDBP_IN, FeeType    );
     Select2.addParam( "", RSDBP_IN, CommNumber );
     Select2.addParam( "", RSDBP_IN, ObjectID   );
     Select2.addParam( "", RSDBP_IN, ObjectType );
     Select2.addParam( "", RSDBP_IN, Kind       );
     Select2.addParam( "", RSDBP_IN, Number     );
     Select2.execute();
     Data2 = TRSBDataSet(Select2);
     if(Data2.MoveNext())
        /*Найдём ставку комиссии*/
        Query2 = " select tarif.* "
               + "   from dsftarif_dbt tarif "
               + "  where tarif.t_tarsclID = ? ";
        Select3 = RSDCommand("select count(1) nRec from( " + Query2 + " )");
        Select3.addParam( "", RSDBP_IN, Data2.ID );
        Select3.execute();
        Data3 = TRSBDataSet(Select3);
        if( Data3.MoveNext() and (Data3.nRec == 1) )
           Select4 = RSDCommand(Query2);
           Select4.addParam( "", RSDBP_IN, Data2.ID );
           Select4.execute();
           Data4 = TRSBDataSet(Select4);
           if(Data4.MoveNext() and (Data4.tarifType == 2/*SF_TARIFFTYPE_PERC*/))
              RateCom = Data4.tarifSum/10000;
              if(Flag != null)
                 Flag = 1;
              end;
           end;
        end;
     end;
  end;

  return RetVal;
END;

MACRO ПолучитьСтавкуКомиссии(SfContrID:integer, ComNumber:integer, Дата:Date, ActDate:integer, RateCom:@double, Flag:@integer )

  var ConCom = TRecHandler( "sfconcom.dbt" );
  var Query, Select1, Data1, Select2, Data2, FindRate:bool = false;
  RateCom = 0.0;
  if(Flag != null)
     Flag = 0;
  end;

  while( SfGetConCom( SfContrID, SF_FEE_TYPE_PERIOD, ConCom ) == true )
    if( ConCom.rec.CommNumber == ComNumber )
       if((Дата == null) or
          ((Дата != null) and (ActDate == 0) and (ConCom.rec.DateBegin == Дата)) or
          ((Дата != null) and (ActDate == 1) and (ConCom.rec.DateBegin <= Дата) and ((ConCom.rec.DateEnd == Date(0,0,0)) or (ConCom.rec.DateEnd >= Дата))))
          /* Найдём алгоритм
             Вначале пробуем с привязкой к договору */
          Query = " select calcal.t_Kind, calcal.t_Number "
                + "   from dsfcalcal_dbt calcal           "
                + "  where calcal.t_FeeType    = ?        "
                + "    and calcal.t_CommNumber = ?        "
                + "    and calcal.t_ObjectType = ?        "
                + "    and calcal.t_ObjectID   = ?        ";
          Select1 = RSDCommand(Query);
          Select1.addParam( "", RSDBP_IN, ConCom.rec.FeeType    );
          Select1.addParam( "", RSDBP_IN, ConCom.rec.CommNumber );
          Select1.addParam( "", RSDBP_IN, 659                   );
          Select1.addParam( "", RSDBP_IN, SfContrID             );
          Select1.execute();
          Data1 = TRSBDataSet(Select1);
          if( Data1.MoveNext() )
             FindRate = ПолучитьСтавкуКомиссииПоАлгоритму(Data1.Kind, Data1.Number, SfContrID, 659, ConCom.rec.FeeType, ConCom.rec.CommNumber, @Flag, @RateCom);
          end;

          /* если не нашли с привязкой ищем без */
          if( FindRate == false )
             Select2 = RSDCommand(Query);
             Select2.addParam( "", RSDBP_IN, ConCom.rec.FeeType    );
             Select2.addParam( "", RSDBP_IN, ConCom.rec.CommNumber );
             Select2.addParam( "", RSDBP_IN, 0                     );
             Select2.addParam( "", RSDBP_IN, 0                     );
             Select2.execute();
             Data2 = TRSBDataSet(Select2);
             if( Data2.MoveNext() )
                ПолучитьСтавкуКомиссииПоАлгоритму(Data2.Kind, Data2.Number, 0, 0, ConCom.rec.FeeType, ConCom.rec.CommNumber, @Flag, @RateCom);
             end;
          end;
          break;
       end;
    end;
  end;
END;

MACRO ДУ_ЧислоCЗаданнойТочностью( _var, _point:integer, _parm:string ) 
  var TmpStr:string;
  if( (valtype (_var) == V_DOUBLE) OR (valtype (_var) == V_MONEY) )
    if((valtype (_parm) == V_UNDEF) OR (_parm == ""))
      TmpStr = "String(_var:0" + ":" + string(_point) + ")";
    else
      TmpStr = "String(_var:0" + ":" + string(_point) + ":" + _parm + ")";
    end;
    return ExecExp(TmpStr);
  else
    return String(_var);
  end;
END; 

/* возвращает число в формате "1 234 567,89" */
/* DecDel_  - разделитель целой и дробной части "."*/
/* RankDel_ - разделитель десятичных разрядов " " */
/* Point_   - точность */
MACRO FormatStrNum( Sum:double, DecDel_, RankDel_, Point_ ):string
  var DecDel  = TS_IIF( DecDel_  == null, ".", DecDel_);
  var RankDel = TS_IIF( RankDel_ == null, " ", RankDel_);
  var Point   = TS_IIF( Point_   == null, 2,   Point_);
  var StrSum  = ДУ_ЧислоCЗаданнойТочностью(Sum, Point);
  var PointPos = Index(StrSum, ".");
  if( PointPos == 0 )
    PointPos = StrLen(StrSum) + 1;
  end;

  if( Sum == 0.0 )
    if(Point > 0)
      return "0" + DecDel + SubStr(StrSum, PointPos+1, Point);
    else
      return "0";
    end;
  end;

  var str = "";

  var PreRankDelSimbols = mod( PointPos - 1, 3);

  var RankDelNum;
  RankDelNum = int( (PointPos - 1) / 3 );
  if( PreRankDelSimbols == 0 )
    RankDelNum = RankDelNum - 1;
  end;

  var RankDelPos = 1;

  if( PreRankDelSimbols != 0 )
    str = str + SubStr( StrSum, 1, PreRankDelSimbols );
    if( RankDelNum > 0)
      str = str + RankDel;
      RankDelNum = RankDelNum - 1;
      RankDelPos = PreRankDelSimbols + 1;
    end;
  end;

  while( RankDelNum > 0 )
    str = str + SubStr(StrSum, RankDelPos, 3) + RankDel;
    RankDelPos = RankDelPos + 3;
    RankDelNum = RankDelNum - 1;
  end;

  if( PointPos > 3 )
    str = str + SubStr(StrSum, RankDelPos, 3);
  end;

  if( Point > 0 )
    str = str + DecDel + SubStr(StrSum, PointPos+1, Point);
  end;
  
  return str;
END;

MACRO CheckOrderComiss(SFContrID:integer, CalcDate:date, OnlyCom:integer ):integer

  var cmd = RsdCommand(RslDefCon, "begin\n ? := TrustAPI.CheckOrderComiss(?, ?, ?);\n end; ");
  cmd.addParam("ret_val", RSDBP_RETVAL, V_INTEGER );
  cmd.addParam("",        RSDBP_IN,     SFContrID );
  cmd.addParam("",        RSDBP_IN,     CalcDate  );
  cmd.addParam("",        RSDBP_IN,     OnlyCom   );
  cmd.execute();

  return SQL_ConvTypeInteger(cmd.Value(0));
END;

MACRO CheckOrderPeriod( OrderID:integer, CalcDate:date):integer

  var cmd = RsdCommand(RslDefCon, "begin\n ? := TrustAPI.CheckOrderPeriod(?, ?);\n end; ");
  cmd.addParam("ret_val", RSDBP_RETVAL, V_INTEGER );
  cmd.addParam("",        RSDBP_IN,     OrderID   );
  cmd.addParam("",        RSDBP_IN,     CalcDate  );
  cmd.execute();

  return SQL_ConvTypeInteger(cmd.Value(0));
END;

private var rParty = TRecHandler( "party.dbt" );
MACRO ПолучитьКороткоеИмяСубъектаДУ( PartyID )

   var RetVal =  "";

   if( PartyID > 0 )
      if( PartyID != rParty.rec.partyid )
         if( ПолучитьСубъекта( PartyID, rParty ) )
            RetVal = "";
         else
            RetVal = rParty.rec.ShortName;
         end;
      else
         RetVal = rParty.rec.ShortName;
      end;
   end;

   return RetVal;
END;

MACRO TS_NullCorrectDemand( OrderID:INTEGER ) 
  VAR Demand = TRecHandler( "tsdemand.dbt" );
  VAR RS, cmd = RSDCommand( "SELECT * " +
                            "  FROM dtsdemand_dbt t" +
                            " WHERE     t.t_OrderID = ? " + 
                            "       AND t.t_EventID = ? " +
                            "       AND ( t.t_CurrentAmount > 0 OR t.t_ExecAmount > 0 )" +
                            " ORDER BY t.t_ID "
                      );
  cmd.addParam( "", RSDBP_IN, OrderID );
  cmd.addParam( "", RSDBP_IN, TS_DemandEvent("75") );
  cmd.execute();

  RS = TRsbDataSet( cmd );

  while( RS.MoveNext() )
     RS.GetRecord().CopyTo( Demand.rec );

     Demand.rec.CurrentAmount = 0; 
     Demand.rec.ExecAmount = 0; 
     Demand.rec.CurrentQuantity = 0; 
     Demand.rec.ExecQuantity = 0; 

     if( TS_ChangeDemand( Demand ) )
        return false;
     end;
  end;

  return true;
END;

/* Получает курс на дату с учетом места торгов*/
private macro GetRateOnDateMP( ADate, fiidFrom, fiidTo, Type, MarketPlace, OnlyThisDate, Section )
  VAR RS, cmd = RSDCommand( "SELECT NVL(RSB_FIInstr.FI_GetRateMP( ?, ?, ?, ?, ?, ?, ? ), 0) Course FROM DUAL" );
  cmd.addParam( "", RSDBP_IN, fiidFrom );
  cmd.addParam( "", RSDBP_IN, fiidTo );
  cmd.addParam( "", RSDBP_IN, Type );
  cmd.addParam( "", RSDBP_IN, ADate );
  cmd.addParam( "", RSDBP_IN, MarketPlace );
  cmd.addParam( "", RSDBP_IN, TS_IIF(Section == NULL, 0, Section) );
  cmd.addParam( "", RSDBP_IN, TS_IIF(OnlyThisDate, 1, 0) );
  cmd.execute();

  RS = TRsbDataSet( cmd );

  if( RS.MoveNext() )
     return RS.rec.Course;
  end;

  return 0;
end;

macro TS_GetRateTypeStr( RateType:integer )
  VAR RS, cmd = RSDCommand( "SELECT T_TYPENAME " +
                            "  FROM DRATETYPE_DBT " +
                            " WHERE T_TYPE = ? " );
  cmd.addParam( "", RSDBP_IN, RateType );
  cmd.execute();

  RS = TRsbDataSet( cmd );

  if( RS.MoveNext() )
     return RS.rec.TypeName;
  end;

  return "";
end;

MACRO ОбновитьЛотПоПаю(ReqAssetsID:integer, QuantityShares:money, Amount:money)

  var cmd = RsdCommand("begin\n TrustAPI.TS_UpdateWrtSum(?,?,?);\n end; ");
  cmd.addParam("p_ReqAssetsID",    RSDBP_IN, ReqAssetsID    );
  cmd.addParam("p_QuantityShares", RSDBP_IN, QuantityShares );
  cmd.addParam("p_Amount",         RSDBP_IN, Amount         );
  cmd.execute();

  return 0;
END;

macro ДатаСВедущимНулем(str_:string)

  var str = string(str_);
  while(Index(str," ") == 1)
     str = substr(str, 2, strlen(str)-1);
  end;
  if((str == "") or (Index(str,".") == 3) or (Index(str," ") == 3))
     return str;
  else
     return "0" + str;
  end;
end;

MACRO ДУ_ДнейВГоду( CalcDate:variant ):INTEGER
  VAR YYYY:integer = 0;

  if( ValType(CalcDate) == V_INTEGER )
     YYYY = CalcDate;
  elif( ValType(CalcDate) == V_DATE )
     datesplit( CalcDate, NULL, NULL, YYYY );
  end;

  return DATE(31, 12 ,YYYY) - DATE(1, 1, YYYY) + 1;
END;

MACRO TS_GetDemandIdBySrvOp( ServOp:TRecHandler, КУС:string )

  var RetVal = -1;
  var RS, cmd;

  cmd = RSDCommand( " SELECT t.t_ID " +
                    "   FROM dtsdemand_dbt t " +
                    "  WHERE t.t_OrderID = ? " + 
                    "    AND t.t_EventID = ? " +
                    "    AND t.t_DocKind = ? " +
                    "    AND t.t_DocID   = ? "
                  );
  cmd.addParam( "", RSDBP_IN, ServOp.rec.OrderID        );
  cmd.addParam( "", RSDBP_IN, TS_DemandEvent(КУС)       );
  cmd.addParam( "", RSDBP_IN, ServOp.rec.Kind_Operation );
  cmd.addParam( "", RSDBP_IN, ServOp.rec.ID             );
  cmd.execute();

  RS = TRsbDataSet( cmd );
  if( RS.MoveNext() )
     RetVal = SQL_ConvTypeInteger(RS.rec.ID);
  end;

  return RetVal;
END;

MACRO СрВзКапиталОФБУ( OrderID:integer )

  var RetVal:money = $0.0;
  var Select1:string = "", Query1, DataSet1;

  Select1 = " select t_A9 " +
            "   from dtscalcitogs_tmp  " +
            "  where t_OrderID   = ?   ";

  Query1 = RSDCommand(Select1);
  Query1.addParam( "", RSDBP_IN, OrderID );
  Query1.execute();

  DataSet1 = TRSBDataSet(Query1);

  if( DataSet1.MoveNext() )
     RetVal = SQL_ConvTypeSum(DataSet1.A9);
  end;

  return RetVal;
END;

MACRO ДОпр_Условие2(OrderFD, EndDate:Date)
  var RetVal = EndDate;
  var ДатаПолногоВывода = OrderFD.ДатаПолногоВывода();

  if( (ДатаПолногоВывода != Date(0,0,0) ) and (ДатаПолногоВывода <= EndDate) )
     RetVal = ДатаПолногоВывода - 1;
  end;

  return RetVal;
END;

MACRO ДНпр_Условие1(OrderFD, BeginDate:Date)
  var RetVal = BeginDate;
  var ДатаПервичногоВнесения = OrderFD.ДатаПервичногоВнесения();

  if( (ДатаПервичногоВнесения != Date(0,0,0) ) and (ДатаПервичногоВнесения > BeginDate) )
     RetVal = ДатаПервичногоВнесения;
  end;

  return RetVal;
END;

//////////////////////////////////////////////////////

PRIVATE MACRO ПолучитьНастройкуСЧА( OrderID:integer, FIID:integer, CalcDate:date, RecSettings:TRecHandler )

  PRIVATE MACRO GetRecFromFile( _RecSettings:TRecHandler, _OrderID:integer, _FIKind:integer, _FIID:integer, _CalcDate:date )
    VAR RS, cmd = RSDCommand( " SELECT * " +
                              "   FROM DTSSETCLCOP_DBT t " +
                              "  WHERE     t.t_OrderID = ? " + 
                              "        AND t.t_FI_Kind = ? " +
                              "        AND t.t_FIID = ? " +
                              "        AND t.t_StartDate = (SELECT MAX(t_StartDate) " +
                              "                               FROM DTSSETCLCOP_DBT " +
                              "                              WHERE     t_OrderID = t.t_OrderID " +
                              "                                    AND t_FI_Kind = t.t_FI_Kind " +
                              "                                    AND t_FIID = t.t_FIID " +
                              "                                    AND t_StartDate <= ?) ");
    cmd.addParam( "", RSDBP_IN, _OrderID );
    cmd.addParam( "", RSDBP_IN, _FIKind );
    cmd.addParam( "", RSDBP_IN, _FIID );
    cmd.addParam( "", RSDBP_IN, _CalcDate );
    cmd.execute();

    RS = TRsbDataSet( cmd );
    if( RS.MoveNext() )
       RS.GetRecord().CopyTo( _RecSettings.rec );
       return true;
    else
       _RecSettings.Clear();
    end;
    return false;
  END;

  VAR FIKind = TS_FIKIND_UNDEF;
  VAR FI = TRecHandler( "fininstr.dbt" );

  if( ПолучитьФинИн( FIID, FI ) != 0 ) 
     return false;
  end;

  if( FI.rec.FI_Kind == FIKIND_AVOIRISS )
     if( FI_IsBond(FI) )
        FIKind = TS_FIKIND_BOND;
     else
        FIKind = TS_FIKIND_SHARE;
     end;
  elif( FI.rec.FI_Kind == FIKIND_DERIVATIVE )
     if( FI.rec.AvoirKind == DERIVATIVE_FUTURES )
        FIKind = TS_FIKIND_FUTURES;
     else
        FIKind = TS_FIKIND_OPTION;
     end;
  else
     FIKind = TS_FIKIND_CURRENCY;
  end;

  /*сначала ищем настройки для конкретного ФИ*/
  if( not GetRecFromFile( RecSettings, OrderID, FIKind, FIID, CalcDate ) )
     /*если не нашли тогда ищем для вида ФИ*/
     if( not GetRecFromFile( RecSettings, OrderID, FIKind, ALLFININSTR, CalcDate ) )
        /*если совсем ничего не нашли тогда берем из настроек*/
        RecSettings.Clear();
        RecSettings.rec.FI_Kind  = FIKind;
        RecSettings.rec.FIID     = FIID;
        RecSettings.rec.MarketID = 0;
        if( (FIKind == TS_FIKIND_BOND) OR (FIKind == TS_FIKIND_SHARE) )
            RecSettings.rec.RateType = ДУ_ВИД_КУРСА_ЦБ_ДЛЯ_СЧА();
            RecSettings.rec.MarketID = ПолучитьКодСубъекта( ДУ_ТС_КУРСА_ЦБ_ДЛЯ_СЧА(), PTCK_CONTR );
        elif( FIKind == TS_FIKIND_FUTURES )
            RecSettings.rec.RateType = ДУ_ВИД_КУРСА_ФЬЮЧЕРСА_ДЛЯ_СЧА();
        elif( FIKind == TS_FIKIND_OPTION )
            RecSettings.rec.RateType = ДУ_ВИД_КУРСА_ОПЦИОНА_ДЛЯ_СЧА();
        else
          /* тут косяк для валют не понятно что брать по умолчанию :) */
        end;
     end;
  end;
END;
/* функция расчитывает текущую стоимость обьекта и ее возвращает
  Параметры : FIID - ФИ обьекта, Quantity - Обьем, CostFIID - Валюта расчета СЧА, CalcDate - дата расчета */
MACRO TS_CalcObjectCost( ObjectFD:VARIANT, CalcDate:date, TSOrderID:INTEGER, Cost:@MONEY, CostFIID:@INTEGER, NeedOverValue:BOOL )
   PRIVATE MACRO DaysInYearByBasis(Basis, dateC)
   var y = 0;

       if(Basis == 4) // Act/Act
          DateSplit(dateC, NULL, NULL, y);
          return NDays(Date(1, 1, y), Date(1, 1, y+1)) + 1;
       elif(Basis == 8) // 365/Act
          return 365;
       end;

       return 360; // [360/30] [360/Act] [360/31]
   END;

  VAR Ксча = 0, AvoirNKD = 0;
  VAR VA_BuyCost = $0, VA_BuyFIID = $0, VA_Nominal = $0, VA_Perc = $0, VA_H = 0, VA_T = 0, VA_D = 0, VA_Y = 0, VA_BalanceDate, VA_DealID, VA_DealType, VA_DealCode;
  VAR VA_RepaymentDate;
  VAR SettinsgCalc = TRecHandler("tssetclcop.dbt");
  VAR VA_DlLeg     = TRecHandler("dl_leg.dbt");
  VAR Day, Month, Year;
  VAR PercSum = 0.0, DiscSum = 0.0;
  VAR PDDDate = date(0,0,0);
  RECORD prccontract (prccontract);

  Cost = $0;
  CostFIID = NATCUR;

  if( not ObjectFD )
     return false;
  end;

  if( ObjectFD.СЧА_ОбъемОбьекта( CalcDate ) <= 0 )
     return true;
  end;

  /*  Если (ФИ отобранного объекта = НацВ) то обьект не переоценивается и 
      если объект - (это Актив или Т/О по ден. средствам) и (ФИ Актива = НацВ), то стоимость объекта  = его объему, 
      и в расчете СЧА будет участвовать текущий объем (а не стоимость) объекта (см формулу расчета ТСЧА),
  */
  if( (ObjectFD.СЧА_ВидФИОбъекта() == TS_ACTIVE_KIND_EMISSIVE) AND 
      (ObjectFD.СЧА_ФИОбъекта().rec.FIID == NATCUR)
    )
     Cost     = ObjectFD.СЧА_ОбъемОбьекта( CalcDate );
     CostFIID = ObjectFD.СЧА_ФИОбъекта().rec.FIID;
  elif( ObjectFD.СЧА_ВидФИОбъекта() == TS_ACTIVE_KIND_EMISSIVE )
     if( NeedOverValue == true )
        /*определяется вид курса, по которому будет рассчитываться стоимость (далее "курс для СЧА"):*/

        var CalcDate_ = CalcDate;
        var ДефолтнаяБумага = false;

        if( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_AVOIRISS )
           var Avoiriss = TRecHandler( "avoiriss.dbt" );
           if( ПолучитьФинИн( ObjectFD.СЧА_ФИОбъекта().rec.FIID, null, Avoiriss ) )
              MsgBox( "Не найден финансовый инструмент с FIID = " + ObjectFD.СЧА_ФИОбъекта().rec.FIID );
              return false;
           end;
           if( ДУ_ПолучитьЗначениеКатегории( Avoiriss, 35/*Дефолтная*/, OBJTYPE_AVOIRISS ) == 2 /*Да*/)
              ДефолтнаяБумага = true;
           end;
        end;

        ПолучитьНастройкуСЧА( TSOrderID, ObjectFD.СЧА_ФИОбъекта().rec.FIID, CalcDate, SettinsgCalc );

        if( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_AVOIRISS )

           if( ДефолтнаяБумага )

              Ксча = GetRateOnDateMP( CalcDate, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, SettinsgCalc.rec.MarketID, false, -1 );

              if( (Ксча == 0) AND (SettinsgCalc.rec.MarketID == ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR )) )
                 Ксча = GetRateOnDateMP( CalcDate, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR ), false, -1 );
              end;

              if( (Ксча == 0) AND (IsWorkday(CalcDate) == 1) ) /* если значение курса нужного вида на Дст не задано и если Дст - рабочий день */
                 msgbox("Для обьекта \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" стоимость не может быть рассчитана; не задан курс вида \"" + TS_GetRateTypeStr(SettinsgCalc.rec.RateType) + "\"." );
                 return false;
              end;

           else

              Ксча = GetRateOnDateMP( CalcDate, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, SettinsgCalc.rec.MarketID, true, -1 );

              if( (Ксча == 0) AND (SettinsgCalc.rec.MarketID == ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR )) )
                 Ксча = GetRateOnDateMP( CalcDate, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR ), true, -1 );
              end;

              if( (Ксча == 0) AND (IsWorkday(CalcDate) == 1) ) /* если значение курса нужного вида на Дст не задано и если Дст - рабочий день */
                 msgbox("Для обьекта \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" стоимость не может быть рассчитана; не задан курс вида \"" + TS_GetRateTypeStr(SettinsgCalc.rec.RateType) + "\" на " + string(CalcDate) );
                 return false;
              elif( (Ксча == 0) AND (IsWorkday(CalcDate) == 0) ) /* если значение курса нужного вида на Дст не задано и если Дст - выходной день */

                 if( КУРС_НЕРАБ_ДНЯ_ПО_ПОСЛЕД_РАБ() == true )
                    CalcDate_ = GetDateAfterWorkDays(CalcDate, -1);
                    Ксча = GetRateOnDateMP( CalcDate_, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, SettinsgCalc.rec.MarketID, true, -1 );
                    if( (Ксча == 0) AND (SettinsgCalc.rec.MarketID == ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR )) )
                       Ксча = GetRateOnDateMP( CalcDate_, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR ), true, -1 );
                    end;
                 end;

                 if( Ксча == 0 )
                    msgbox("Для обьекта \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" стоимость не может быть рассчитана; не задан курс вида \"" + TS_GetRateTypeStr(SettinsgCalc.rec.RateType) + "\" на " + string(CalcDate_) );
                    return false;
                 end;
              end;

           end;

        elif( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_DERIVATIVE )

           Ксча = GetRateOnDateMP( CalcDate, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, SettinsgCalc.rec.MarketID, true, -1 );

           if( (Ксча == 0) AND (SettinsgCalc.rec.MarketID == ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR )) )
              Ксча = GetRateOnDateMP( CalcDate, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR ), true, -1 );
           end;

           if( (Ксча == 0) AND (IsWorkday(CalcDate) == 1) ) /* если значение курса нужного вида на Дст не задано и если Дст - рабочий день */
              msgbox("Для обьекта \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" стоимость не может быть рассчитана; не задан курс вида \"" + TS_GetRateTypeStr(SettinsgCalc.rec.RateType) + "\" на " + string(CalcDate) );
              return false;
           elif( (Ксча == 0) AND (IsWorkday(CalcDate) == 0) ) /* если значение курса нужного вида на Дст не задано и если Дст - выходной день */
              while( (Ксча == 0) AND (IsWorkday(CalcDate_) == 0) )
                 CalcDate_ = CalcDate_ - 1;
                 Ксча = GetRateOnDateMP( CalcDate_, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, SettinsgCalc.rec.MarketID, true, -1 );
                 if( (Ксча == 0) AND (SettinsgCalc.rec.MarketID == ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR )) )
                    Ксча = GetRateOnDateMP( CalcDate_, ObjectFD.СЧА_ФИОбъекта().rec.FIID, NATCUR, SettinsgCalc.rec.RateType, ПолучитьКодСубъекта( "ММВБ", PTCK_CONTR ), true, -1 );
                 end;
              end;

              if( Ксча == 0 )
                 msgbox("Для обьекта \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" стоимость не может быть рассчитана; не задан курс вида \"" + TS_GetRateTypeStr(SettinsgCalc.rec.RateType) + "\" на " + string(CalcDate_) );
                 return false;
              end;
           end;

        end;

        /* если всетаки нашли курс*/
        if( Ксча > 0 )
           if( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_AVOIRISS )
              var ExCourse:bool = false;

              AvoirNKD = 0.0;
              if((FI_IsBond(ObjectFD.СЧА_ФИОбъекта().rec.FIID)) and (not ДефолтнаяБумага))
                AvoirNKD = НКД( ObjectFD.СЧА_ФИОбъекта().rec.FIID, $1, CalcDate, NULL, true, true, false, @ExCourse );
                if( (ExCourse == true) and (IsWorkday(CalcDate) == 1) )
                   AvoirNKD = $0.0;
                   msgbox("Для выпуска \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" стоимость не может быть рассчитана; не задан курс вида \"НКД для ЦБ\" на " + string(CalcDate) );
                   return false;
                end;
              end;
              Cost     = ( Ксча + AvoirNKD ) * ObjectFD.СЧА_ОбъемОбьекта( CalcDate );
              CostFIID = NATCUR;
           elif( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_DERIVATIVE )
              Cost     = Ксча * ObjectFD.СЧА_ОбъемОбьекта( CalcDate );
              CostFIID = NATCUR;
           end;
        end;
     else
        Cost = ObjectFD.СЧА_СтоимостьОбьекта( CalcDate, true );

        if( Cost == $0 )
           if( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_AVOIRISS )
              msgbox("Для ценной бумаги \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" не выполнена переоценка за " + string(CalcDate) );
           elif( ObjectFD.СЧА_ФИОбъекта().rec.FI_Kind == FIKIND_DERIVATIVE )
              if( ObjectFD.СЧА_ФИОбъекта().rec.AvoirKind == DERIVATIVE_FUTURES )
                 msgbox("Для фьючерса \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" не выполнена переоценка за " + string(CalcDate) );
              else
                 msgbox("Для опциона \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" не выполнена переоценка за " + string(CalcDate) );
              end;
           else
              msgbox("Для валюты \"" + ObjectFD.СЧА_ФИОбъекта().rec.FI_Code + "\" не выполнена переоценка за " + string(CalcDate) );
           end;
           return false;
        end;
     end;
  elif( ObjectFD.СЧА_ВидФИОбъекта() == TS_ACTIVE_KIND_INDIVIDUAL )

     if( not TS_GetRecHandler( VA_DlLeg, " SELECT dlleg.* FROM ddl_leg_dbt dlleg WHERE     dlleg.t_DealID = " + string(ObjectFD.СЧА_Вексель().rec.BCID) + 
                                                                                     " AND dlleg.t_LegKind = " + LEG_KIND_VSBANNER + 
                                                                                     " AND dlleg.t_LegID = 0 " ) )
        msgbox("Для векселя " + trim(ObjectFD.СЧА_Вексель().rec.BCSeries) + " " + trim(ObjectFD.СЧА_Вексель().rec.BCNumber) + " не найдены ценовые условия." );
        return false;
     end;

     if( not DL_VA_GetBalanceDate(ObjectFD.СЧА_Вексель().rec.BCID, CalcDate, @VA_BalanceDate, @VA_DealID, @VA_BuyCost, @VA_BuyFIID, @VA_DealType, @VA_DealCode) )
        msgbox("Для векселя " + trim(ObjectFD.СЧА_Вексель().rec.BCSeries) + " " + trim(ObjectFD.СЧА_Вексель().rec.BCNumber) + " не найдена сделка покупки." );
        return false;
     end;

     VA_Nominal = VA_DlLeg.rec.Principal;
     VA_D = CalcDate - VA_BalanceDate;
     VA_T = DL_VS_GetTermCircDate(ObjectFD.СЧА_Вексель(), VA_DlLeg, VA_D);

     if((VA_DlLeg.rec.Formula == VS_IN_DISCONT) OR (VA_DlLeg.rec.Formula == VS_IN_DISC_PC))
       if( VA_T != 0 )
         DiscSum = ((VA_Nominal - VA_BuyCost) * VA_D)/(VA_T);
       end;
     end;

     Cost = money(VA_BuyCost + DiscSum);

     PDDDate = ПолучитьДатуПоследПДДнаДату(ObjectFD.СЧА_Вексель().rec.BCID, CalcDate, VA_BalanceDate);

     if(PDDDate < CalcDate)
       if(НайтиОткрытьСчетПроцВекселя(prccontract, ObjectFD.СЧА_Вексель().rec.BCID, VA_BalanceDate) )
            if(ПроцентыКНачислениюПоПДВекселя(prccontract.ContractID, CalcDate, PercSum))
              Cost = Cost + PercSum;
            end;
       end;
     end;
  
     Cost = Cost + ПолучитьСуммуПДДНаДату(ObjectFD.СЧА_Вексель().rec.BCID, CalcDate, FIROLE_PERCENT, VA_BalanceDate);
     CostFIID = NATCUR;
  end;

  return true;
END;

MACRO TS_UserMarkSEC_prefix( Role:INTEGER ):STRING
   return TS_IIF( Role == TS_DEMAND_ROLE_REQUEST, "Треб_", "Обяз_" );
END;

MACRO TS_BofficeKindSEC():STRING
   return StrFor(CodeFor("S"));
END;

MACRO TS_CreateDemandSEC( RetDemand:TRecHandler, ID_Operation:INTEGER, UserMark:STRING, Role:INTEGER, 
                          КВТО:STRING, КУС:STRING, Дплан:DATE, Summa:MONEY, ActiveFIID:INTEGER, ActiveDepositoryID:INTEGER,
                          SFClientContr:INTEGER, BaseFIID:INTEGER, ID_Step:integer, DocKind:integer, DocID:integer ):BOOL



  Demand.Clear();   
  Demand.rec.Role             =  Role;      // Т/О
  Demand.rec.Kind             =  TS_DemandKind(КВТО);      // Вид Т/О из классификатора "ДУ вид Т/О".
  Demand.rec.InitialQuantity  =  Summa;     // исходная сумма = общая сумма сделки
  Demand.rec.FIID             =  NATCUR;    // валюта учета
  Demand.rec.PlanCloseDate    =  Дплан;     // планируемая дата исполнения
  Demand.rec.OpenDate         =  Дплан;
  Demand.rec.BofficeKind      =  TS_BofficeKindSEC(); // бэкофис ПИ 
  Demand.rec.UserMark         =  UserMark; /* метка*/
  Demand.rec.EventID          =  TS_DemandEvent(КУС); // учетное событие создания Т/О 
  Demand.rec.Department       =  {operdprt};          // филиал
  Demand.rec.Account          =  "";
  Demand.rec.BaseFIID         =  BaseFIID;
  Demand.rec.KindProfit       =  -1; /*TS_ProfitKind(КВДР); убрал тк ДР неиспользуется*/
  Demand.rec.ID_Operation     =  ID_Operation;
  Demand.rec.ID_Step          =  ID_Step;
  Demand.rec.DocKind          =  DocKind;
  Demand.rec.DocID            =  DocID;

  if( TS_CreateDemandFromOtherBO( SFClientContr,       /*SfContrID*/
                                  "",                  /*ActiveCode*/
                                  TS_ACTIVE_KIND_EMISSIVE, 
                                  ActiveFIID,          /*ActiveFIID*/ 
                                  ActiveDepositoryID,  /*DepositoryID*/
                                  NATCUR,              /*BalanceFIID*/
                                  "",
                                  {oper}, 
                                  Demand, 
                                  true /*показывать ошибку*/ ) != 0 )
     return false;                                                                                                                          
  end;

  if( RetDemand != null )
     Copy( RetDemand, Demand );
  end;

  return true;
END;

MACRO TS_ExecuteDemandSEC( ID_Operation:INTEGER, UserMark:STRING, Дплан:DATE )

  if( TS_ExecuteDemandByMark( TS_BofficeKindSEC(), ID_Operation, UserMark, Дплан, true ) != 0 )
     return false;
  end;

  return true;
END;

macro ДУ_ВидРОКомиссииПосреднику( FD )
  if( IsEXCHANGE(FD.Group) and (FD.tick.rec.Flag1 == "X") ) 
     return 9;
  elif(IsBROKER(FD.Group) ) 
     return 10;
  else
     return 12;
  end;
end;

MACRO TS_MonthName( mon:integer ):string
  var RetVal = "";
  if( mon == 1 )
     RetVal = "январь";
  elif( mon == 2 )
     RetVal = "февраль";
  elif( mon == 3 )
     RetVal = "март";
  elif( mon == 4 )
     RetVal = "апрель";
  elif( mon == 5 ) 
     RetVal = "май";
  elif( mon == 6 )
     RetVal = "июнь";
  elif( mon == 7 )
     RetVal = "июль";
  elif( mon == 8 )
     RetVal = "август";
  elif( mon == 9 )
     RetVal = "сентябрь";
  elif( mon == 10 )
     RetVal = "октябрь";
  elif( mon == 11 )
     RetVal = "ноябрь";
  elif( mon == 12 )
     RetVal = "декабрь";
  end;

  return RetVal;
END;

MACRO TS_GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, IsPartial:STRING, ToFIID:INTEGER, CouponCount:@INTEGER, ExcludeDate, CalcByDates )
  var cmd, rsd;
  var Sum = 0.0, S, NumCoupon = 0;

  cmd = RSDCommand(
        " SELECT FI.t_FaceValueFI, FI.t_FaceValue, warnt.t_DrawingDate as DrawingDate, "
      + "        warnt.t_IncomeRate, warnt.t_IncomeScale "
      + "   FROM dfiwarnts_dbt warnt, dfininstr_dbt FI "
      + "  WHERE warnt.t_FIID = ? and "
      + "        warnt.t_IsPartial = " + TS_IIF(IsPartial=="X","chr(88)", "chr(0)") + " and "
      + "        warnt.t_DrawingDate <= ? and "
      + "        warnt.t_DrawingDate >= ? and "
      + TS_IIF (((ExcludeDate != null) and (ValType(ExcludeDate) == V_DATE)), 
             "   warnt.t_DrawingDate != ? and ",
             ""
            )
      + "        FI.t_FIID = warnt.t_FIID "
      + " ORDER BY warnt.t_DrawingDate ASC "
                  );

  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, DateEnd );
  cmd.addParam( "", RSDBP_IN, DateBeg );

  if((ExcludeDate != null) and (ValType(ExcludeDate) == V_DATE))
     cmd.addParam( "", RSDBP_IN, ExcludeDate );
  end;

  cmd.execute();

  rsd = TRsbDataSet(cmd);
  while(rsd.MoveNext())

    /*Сумма частичных погашений*/
    if (IsPartial == "X")
       S = Amount * rsd.FaceValue * rsd.IncomeRate/MAX( 1, rsd.IncomeScale)/100.0;
    /*Сумма купонов*/
  else
       S = СуммаКупона(FIID, Amount, SQL_ConvTypeDate(rsd.DrawingDate) );
  end;

    if( ToFIID != NULL )
       TS_SmartConvertSumDbl( S, S, SQL_ConvTypeDate(rsd.DrawingDate), int(rsd.FaceValueFI), ToFIID, true );
        end;

    /*Такие специфические суммы используются например в регистрах 9.1 и 9.2*/
    if (CalcByDates != NULL)
       S = S * (DateBeg - SQL_ConvTypeDate(rsd.DrawingDate));
     end;

    Sum = Sum + S;
    NumCoupon = NumCoupon + 1;
  end;

  CouponCount = NumCoupon;
  return Sum;
END;

MACRO ДУ_СохранитьСчетаВПлатеже( paym:TRecHandler, DtAccount:TRecHandler, CtAccount:TRecHandler )

  var    pmobj = RsbPayment( paym.rec.PaymentID );

  if( (paym.rec.Payer != DtAccount.rec.Client) OR
      (paym.rec.PayerAccount != DtAccount.rec.Account)
    )
     paym.rec.PayerAccount   = DtAccount.rec.Account;
     paym.rec.Payer          = DtAccount.rec.Client;
     paym.rec.PayerBankID    = {OurBank}; 

     pmobj.SetPayerPI( PAYMENTS_GROUP_UNDEF,             
                       paym.rec.PayerBankID,      
                       0,                                
                       "",                               
                       "",                               
                       "",                               
                       DtAccount.rec.Code_Currency, 
                       2/*CHAPT2*/,                      
                       paym.rec.PayerAccount,
                       paym.rec.Payer,
                       "",
                       "" );                             
  end;

  if( (paym.rec.Receiver != CtAccount.rec.Client) OR
      (paym.rec.ReceiverAccount != CtAccount.rec.Account)
    )
     paym.rec.ReceiverAccount= CtAccount.rec.Account;
     paym.rec.Receiver       = CtAccount.rec.Client;
     paym.rec.ReceiverBankID = {OurBank}; 

     pmobj.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                          paym.rec.ReceiverBankID, 
                          0, 
                          "", 
                          "",
                          "",
                          CtAccount.rec.Code_Currency, 
                          2/*CHAPT2*/, 
                          paym.rec.ReceiverAccount,
                          paym.rec.Receiver,
                          "", 
                          "" );
  end;
END;

MACRO ДУ_МестоХраненияДляКомиссии( Comiss:TRecHandler )
  VAR DemandParty = -1;

  if( ВидСубъекта(Comiss.rec.ReceiverID, 41/*PTK_RKC*/) == true ) /*РКЦ*/
     DemandParty = РКЦ();
  elif( ВидСубъекта(Comiss.rec.ReceiverID, 46/*PTK_RC_ORCB*/) == true ) /* РЦ биржи */
     DemandParty = Comiss.rec.ReceiverID;
  elif( ВидСубъекта(Comiss.rec.ReceiverID, PTK_MARKETPLASE) == true  ) /*Биржа*/
     VAR DLMarket    = TRecHandler( "dlmarket.dbt" );

     if(    (FindDLMARKETbyMarket( Comiss.rec.ReceiverID, true, true, FIKIND_AVOIRISS, DLMarket) == 0)
         OR (FindDLMARKETbyMarket( Comiss.rec.ReceiverID, false, true, FIKIND_AVOIRISS, DLMarket) == 0)
       )
        DemandParty = DLMarket.rec.Centr;
     end;

     if( DemandParty <= 0 )
        MsgBox( "Не найден РЦ биржи в схеме расчетов для " + ПолучитьКороткоеИмяСубъектаДУ(Comiss.rec.ReceiverID) + ".");
        return -1;
     end;
  elif( ВидСубъекта(Comiss.rec.ReceiverID, PTK_DEPOSITORY) == true )
     DemandParty = РКЦ();
  else
     DemandParty = Comiss.rec.ReceiverID;
  end;

  return DemandParty;
END;

MACRO GetTSGroundRecByDeal( DealID, KindDoc, SerialNumRec, BOfficeKind )

   return DL_GetGroundRecByDeal (DealID, KindDoc, SerialNumRec, BOfficeKind);

END;
