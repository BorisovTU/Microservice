/*
$Name:         trvaprdslib.mac
$Module:       Доверит. управл.
$Description:  Ф-ции работы с ПДД векселей
*/

IMPORT TSInter, DealsInter, "vaprdslib.mac", "trvafd.mac", "trvautl.mac", RsbDataSet;

PRIVATE RECORD prccontract (prccontract);

//Типы
PRIVATE CONST BPT_RDISCOUNT  = 1;
PRIVATE CONST BPT_HDISCOUNT  = 2;
PRIVATE CONST BPT_RPERCENT   = 3;
PRIVATE CONST BPT_HPERCENT   = 4;
PRIVATE CONST BPT_OTHERDISC = 5;
PRIVATE CONST BPT_OTHERPERC = 6;

CLASS OrderBnrParm(_DebetAcc, _CreditAcc, _fiid, _Summ, _BCID, _Issuer)

  var DebetAcc   = TRecHandler("account.dbt" );
  copy(DebetAcc, _DebetAcc);
  var CreditAcc  = TRecHandler("account.dbt" );
  copy(CreditAcc, _CreditAcc);
  var Summ       = _Summ;
  var fiid       = _fiid;
  var BCIDs       = TArray();
  var Issuer     = _Issuer;

  BCIDs[BCIDs.size] = _BCID;

  macro AddBCID(BCID)
    BCIDs[BCIDs.size] = BCID;
  end;

END;

PRIVATE CLASS IncomeParm( _BCID, _EndDate, _EnrolmentID)
  var BCID        = _BCID;
  var EndDate     = _EndDate;
  var EnrolmentID = _EnrolmentID;
END;

CLASS OrderBnrCollect(_OrderFD:TS_OrderFD, _ID_Operation, _OperDate, _ValueDate, _fromTick, _todayTick, _tickfd, _NeedTranH, _ID_Step)
  var OrderFD:TS_OrderFD = _OrderFD;
  var ID_Operation = _ID_Operation;
  var ID_Step = _ID_Step;
  var OperDate   = _OperDate;
  var ValueDate  = _ValueDate;
  var todayTick  = false;
  var tickfd:TS_VATickFD = null;
  var NeedTranH = false;
  var fromTick = _fromTick;
  var NeedPerc = true;
  var NeedDisc = true;

  if(ValType(_todayTick) != V_UNDEF)
    todayTick  = _todayTick;
  end;
  if(ValType(_todayTick) != V_UNDEF)
    tickfd  = _tickfd;
  end;
  if(ValType(_todayTick) != V_UNDEF)
    NeedTranH = _NeedTranH;
  end;
  var IncGroup = VACollectIncome(ValueDate);

  var parmRD = TArray();  //надежный дисконт
  var parmHD = TArray();  //ненадежный дисконт
  var parmRP = TArray();  //надежные проценты
  var parmHP = TArray();  //ненадежные проценты
  var parmOD = TArray(); //для отнесения дисконта на доход
  var parmOP = TArray(); //для отнесения процентов на доход

  var Incomes = TArray(); //записи о начислении

  var GroupByIssuer = 0; //0 - по ц/б; 1 - по эмитенту
  var err = 0;

  GetRegistryValue( "ДОВЕРИТЕЛЬНОЕ УПРАВЛЕНИЕ\\РАБОТА С НЕЭМИССИОННЫМИ ЦБ\\ПРОВОДКИ ПРИ НАЧИСЛЕНИИ ПДД", V_INTEGER, GroupByIssuer, err );
  if(err)
    GroupByIssuer = 0;
  end;

  PRIVATE MACRO GetCurrParm(Type)
    var parm;

    if(Type == BPT_RDISCOUNT)
      parm = parmRD;
    elif(Type == BPT_HDISCOUNT)
      parm = parmHD;
    elif(Type == BPT_RPERCENT)
      parm = parmRP;
    elif(Type == BPT_HPERCENT)
      parm = parmHP;
    elif(Type == BPT_OTHERDISC)
      parm = parmOD;
    elif(Type == BPT_OTHERPERC)
      parm = parmOP;
    end;

    return parm;
  END;

  PRIVATE MACRO SetCurrParm(Type, parm)

    if(Type == BPT_RDISCOUNT)
      parmRD = parm;
    elif(Type == BPT_HDISCOUNT)
      parmHD = parm;
    elif(Type == BPT_RPERCENT)
      parmRP = parm;
    elif(Type == BPT_HPERCENT)
      parmHP = parm;
    elif(Type == BPT_OTHERDISC)
      parmOD = parm;
    elif(Type == BPT_OTHERPERC)
      parmOP = parm;
    end;

  END;

  PRIVATE MACRO find(Type, DebetAcc, CreditAcc, fiid, Issuer)
    var i=0;
    var parm = GetCurrParm(Type);
    while(i<parm.size)
      if(    (parm[i].DebetAcc.rec.Account == DebetAcc.rec.Account) and (parm[i].DebetAcc.rec.Code_Currency == DebetAcc.rec.Code_Currency) and (parm[i].DebetAcc.rec.Chapter == DebetAcc.rec.Chapter) and (parm[i].DebetAcc.rec.Department == DebetAcc.rec.Department)
         and (parm[i].CreditAcc.rec.Account == CreditAcc.rec.Account) and (parm[i].CreditAcc.rec.Code_Currency == CreditAcc.rec.Code_Currency) and (parm[i].CreditAcc.rec.Chapter == CreditAcc.rec.Chapter) and (parm[i].CreditAcc.rec.Department == CreditAcc.rec.Department)
         and (parm[i].fiid == fiid)
         and (parm[i].Issuer == Issuer))
        return i;
      end;
      i = i + 1;
    end;
    return -1;
  END;

  MACRO add(Type, DebetAcc, CreditAcc, fiid, Summ, BCID, Issuer)
    var i=-1;
    var parm = GetCurrParm(Type);
    if(GroupByIssuer)
      i = find(Type, DebetAcc, CreditAcc, fiid, Issuer);
      if(i > -1)
        parm[i].Summ = parm[i].Summ + Summ;
        parm[i].AddBCID(BCID);
      else
        parm[parm.size] = OrderBnrParm(DebetAcc, CreditAcc, fiid, Summ, BCID, Issuer);
      end;
    else
      parm[parm.size] = OrderBnrParm(DebetAcc, CreditAcc, fiid, Summ, BCID, Issuer);
    end;
    SetCurrParm(Type, parm);
  END;

  MACRO AddIncome(BCID, EnrolmentID, EndDate)
    Incomes[Incomes.size] = IncomeParm( BCID, EndDate, EnrolmentID);
  END;

  PRIVATE MACRO FindIncomeBCID(BCID)
    var i = 0;
    while(i < Incomes.size)
      if(Incomes[i].BCID == BCID)
        return i;
      end;
      i = i + 1;
    end;

    return -1;
  END;

  MACRO ПроводкиОтнесенияНадежных(ValueDate)
    var i = 0;
    var stat = 0;
    var natsum = 0.0;
    var Ground = "";
    var bnrfd = null, fd = null;

    //дисконт
    while((not stat) and (i<parmOD.size))

      natsum = parmOD[i].Summ;

      if(parmOD[i].fiid != NATCUR)
        if( (not TS_SmartConvertSum( natsum, parmOD[i].Summ, ValueDate, parmOD[i].fiid, NATCUR, true ) ) )
          stat = 1;
        end;
      end;

      fd = OrderFD;
      Ground = "Отнесение начисленного ранее дисконтного дохода на доход ";
      if(not GroupByIssuer)
        if((fromTick == true) and (ValType(tickfd) != V_UNDEF))
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmOD[i].BCIDs[0], tickfd.tick.rec.BOfficeKind, tickfd.tick);
        else
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmOD[i].BCIDs[0], NULL, NULL);
        end;
        Ground = Ground + bnrfd.CreateGroundByBnr("векселя (_IssuerName_, _BCSeries_, _BCNumber_)");
        fd = bnrfd.ctgfd;
      end;

      if( not ПроводкаПоКатегориямУчетаПоДоговору(
                 fd,
                 NULL,
                 NULL,
                 parmOD[i].DebetAcc, parmOD[i].CreditAcc,
                 ValueDate,
                 parmOD[i].DebetAcc.rec.Chapter,
                 parmOD[i].fiid,
                 parmOD[i].Summ,
                 null,
                 OrderFD.Number,
                 Ground,
                 null, null,
                 null, null,
                 NATCUR, natsum
                 )
          )
            stat = 1;
      end;

      i = i+1;
    end;

    //проценты
    i=0;
    while((not stat) and (i<parmOP.size))
      natsum = parmOP[i].Summ;

      if(parmOP[i].fiid != NATCUR)
        if( (not TS_SmartConvertSum( natsum, parmOP[i].Summ, ValueDate, parmOP[i].fiid, NATCUR, true ) ) )
          stat = 1;
        end;
      end;

      fd = OrderFD;
      Ground = "Отнесение начисленного ранее процентного дохода на доход ";
      if(not GroupByIssuer)
        if((fromTick == true) and (ValType(tickfd) != V_UNDEF))
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmOP[i].BCIDs[0], tickfd.tick.rec.BOfficeKind, tickfd.tick);
        else
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmOP[i].BCIDs[0], NULL, NULL);
        end;
        Ground = Ground + bnrfd.CreateGroundByBnr("векселя (_IssuerName_, _BCSeries_, _BCNumber_)");
        fd = bnrfd.ctgfd;
      end;

      if( not ПроводкаПоКатегориямУчетаПоДоговору(
                 fd,
                 NULL,
                 NULL,
                 parmOP[i].DebetAcc, parmOP[i].CreditAcc,
                 ValueDate,
                 parmOP[i].DebetAcc.rec.Chapter,
                 parmOP[i].fiid,
                 parmOP[i].Summ,
                 null,
                 OrderFD.Number,
                 Ground,
                 null, null,
                 null, null,
                 NATCUR, natsum
                 )
          )
            stat = 1;
      end;
      i = i+1;
    end;

    return stat;
  END;

  PRIVATE MACRO ПроводкиНачисления(parmR, parmH, ValueDate, FiRole,_str)
    var i = 0, j=0, ik;
    var stat = 0;
    var natsum = 0.0;
    var bnrfd = null, fd = null;
    var AccTrnID = 0;
    var Ground = "";

    //надежные
    while((not stat) and (i<parmR.size))

      AccTrnID = 0;

      fd = OrderFD;
      Ground = "Начисление "+_str+" при определенности признания дохода ";
      if(not GroupByIssuer)
        if((fromTick == true) and (ValType(tickfd) != V_UNDEF))
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmR[i].BCIDs[0], tickfd.tick.rec.BOfficeKind, tickfd.tick);
        else
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmR[i].BCIDs[0], NULL, NULL);
        end;
        Ground = Ground + bnrfd.CreateGroundByBnr("векселя (_IssuerName_, _BCSeries_, _BCNumber_)");
        fd = bnrfd.ctgfd;
      end;

      natsum = parmR[i].Summ;

      if(parmR[i].fiid != NATCUR)
        if( (not TS_SmartConvertSum( natsum, parmR[i].Summ, ValueDate, parmR[i].fiid, NATCUR, true ) ) )
          stat = 1;
        end;
      end;

      if( not ПроводкаПоКатегориямУчетаПоДоговору(
                 fd,
                 NULL,
                 NULL,
                 parmR[i].DebetAcc, parmR[i].CreditAcc,
                 ValueDate,
                 parmR[i].DebetAcc.rec.Chapter,
                 parmR[i].fiid,
                 parmR[i].Summ,
                 null,
                 OrderFD.Number,
                 Ground,
                 null, null,
                 null, null,
                 NATCUR, natsum,
                 null,
                 null,
                 null,
                 null,
                 @AccTrnID
                 )
          )
            stat = 1;
      else
        //для каждого векселя из parmR[i] запишем проводку в историю начисления
        if(AccTrnID)
          j = 0;
          while(j < parmR[i].BCIDs.size)
            ik = FindIncomeBCID(parmR[i].BCIDs[j]);
            stat = SetCarryVSINCOME(parmR[i].BCIDs[j], Incomes[ik].EnrolmentID, Incomes[ik].EndDate, FiRole, AccTrnID);
            j = j + 1;
          end;
        end;
      end;

      i = i+1;
    end;

    //ненадежные
    i=0;
    while((not stat) and (i<parmH.size))

      AccTrnID = 0;

      fd = OrderFD;
      Ground = "Начисление "+_str+" при неопределенности признания дохода ";
      if(not GroupByIssuer)
        if((fromTick == true) and (ValType(tickfd) != V_UNDEF))
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmH[i].BCIDs[0], tickfd.tick.rec.BOfficeKind, tickfd.tick);
        else
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmH[i].BCIDs[0], NULL, NULL);
        end;
        Ground = Ground + bnrfd.CreateGroundByBnr("векселя (_IssuerName_, _BCSeries_, _BCNumber_)");
        fd = bnrfd.ctgfd;
      end;

      if( not ПроводкаПоКатегориямУчетаПоДоговору(
                 fd,
                 NULL,
                 NULL,
                 parmH[i].DebetAcc, parmH[i].CreditAcc,
                 ValueDate,
                 parmH[i].DebetAcc.rec.Chapter,
                 parmH[i].fiid,
                 parmH[i].Summ,
                 null,
                 OrderFD.Number,
                 Ground,
                 null, null,
                 null, null,
                 NATCUR, natsum,
                 null,
                 null,
                 null,
                 null,
                 @AccTrnID
                 )
          )
            stat = 1;
      else
        //для каждого векселя из parmH[i] запишем проводку в историю начисления
        if(AccTrnID)
          j = 0;
          while(j < parmH[i].BCIDs.size)
            ik = FindIncomeBCID(parmH[i].BCIDs[j]);
            stat = SetCarryVSINCOME(parmH[i].BCIDs[j], Incomes[ik].EnrolmentID, Incomes[ik].EndDate, FiRole, AccTrnID);
            j = j + 1;
          end;
        end;
      end;

      i = i+1;
    end;

    return stat;
  END;

  MACRO ПроводкиНачисленияПроцентов(ValueDate)
    return ПроводкиНачисления(parmRP, parmHP, ValueDate, FIROLE_PERCENT, "процентов");
  END;

  MACRO ПроводкиНачисленияДисконта(ValueDate)
    return ПроводкиНачисления(parmRD, parmHD, ValueDate, FIROLE_DISCOUNT, "дисконта");
  END;

  PRIVATE MACRO ПроводкиСписания(parmR, ValueDate, _str)
    var i = 0;
    var stat = 0;
    var Ground = "";
    var bnrfd = null, fd = null;

    while((not stat) and (i<parmR.size))

      fd = OrderFD;
      Ground = "Списание "+_str+ " ";
      if(not GroupByIssuer)
        if((fromTick == true) and (ValType(tickfd) != V_UNDEF))
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmR[i].BCIDs[0], tickfd.tick.rec.BOfficeKind, tickfd.tick);
        else
          bnrfd = TS_VABnrFD(DL_VSBANNER, parmR[i].BCIDs[0], NULL, NULL);
        end;
        Ground = Ground + bnrfd.CreateGroundByBnr("векселя (_IssuerName_, _BCSeries_, _BCNumber_)");
        fd = bnrfd.ctgfd;
      end;

      if( not ПроводкаПоКатегориямУчетаПоДоговору(
                 fd,
                 NULL,
                 NULL,
                 parmR[i].DebetAcc, parmR[i].CreditAcc,
                 ValueDate,
                 parmR[i].DebetAcc.rec.Chapter,
                 parmR[i].fiid,
                 parmR[i].Summ,
                 null,
                 OrderFD.Number,
                 Ground
                 )
          )
            stat = 1;
      end;

      i = i+1;
    end;

    return stat;
  END;

  MACRO ПроводкиСписанияПроцентов(ValueDate)
     return ПроводкиСписания(parmRP, ValueDate, "начисленных процентов");
  END;

  MACRO ПроводкиСписанияДисконта(ValueDate)
     return ПроводкиСписания(parmRD, ValueDate, "начисленного дисконта");
  END;

END;

PRIVATE MACRO ОпределитьНадежностьКатегорииКачестваВекселя(bnr, VDate, Надежна:@variant)
  var stat = true;
  var AccountBase = 1; //Учтенные векселя
  var QualityCategory1 = 1, // по векселю
      QualityCategory3 = 3;  // по контрагенту
  var reslnk = TBfile("dlreslnk.dbt");
  var party  = TBfile("party.dbt", "R", 0);
  var КатегорияКачества = 0;
  var КатегорияКачестваЦБ = 0, КатегорияКачестваПДД = 0;
  var ДатаКатегорииЦБ = 0, ДатаКатегорииПДД = 0;
  var err = 0;
  var issuer = TRecHandler( "party" );
  var ValidFromDate;

  var r_ficert = TRecHandler("ficert.dbt");

  var DataSet = TRsbDataSet(" SELECT ficert.* FROM dficert_dbt ficert, dvsbanner_dbt bnr, dfininstr_dbt fin "+
                            " WHERE  bnr.t_BCID = " + String(bnr.rec.BCID) +
                            "   and fin.t_FIID = bnr.t_FIID" +
                            "   and ficert.t_CertID = bnr.t_BCID" +
                            "   and ficert.t_AvoirKind = fin.t_AvoirKind");

  if (DataSet.moveNext())
    DataSet.GetRecord().CopyTO(r_ficert.rec);
  end;

  GetMainObjAttr(err, OBJTYPE_FICERT, UniID(r_ficert, OBJTYPE_FICERT), 3/*категория качества*/, КатегорияКачества, null, null, VDate, ValidFromDate);
  if( (err) or (КатегорияКачества == 0) )
    //если не удалось найти категорию качества у векселя, то поищем у эмитента
    if(not ПолучитьСубъекта(bnr.rec.Issuer, issuer))
      GetMainObjAttr(err, OBJTYPE_PARTY, UniID(issuer, OBJTYPE_PARTY), 13/*категория качества*/, КатегорияКачества, null, null, VDate, ValidFromDate);
      if( (err) or (КатегорияКачества == 0) ) stat = false; end;
    else
      stat = false;
    end;
  end;

  //надежна или нет
  Надежна = false;
  if(stat == true )
    if((КатегорияКачества==1) or (КатегорияКачества==2))
      Надежна = true;
    elif(КатегорияКачества==3)
      GetRegistryValue( "COMMON\\ПЕРЕМЕННЫЕ\\СУБЪЕКТ 3Й КАТЕГОРИИ КАЧЕСТВА", V_BOOL, Надежна, err );
      if( err ) stat = false; end;
    end;
  end;

  return stat;
END;

PRIVATE MACRO GetTranHAccounts(fd, FiRole, OperDate, DebetAcc:@variant, CreditAcc:@variant)
  var stat = 0;

  DebetAcc.Clear();
  CreditAcc.Clear();

  if(not stat)
    if( not fd.ПолучитьСчет( "ПДД ДУ", null, false, FiRole, DebetAcc, OperDate) )
      stat = 1;
    end;
  end;

  if(not stat)
    if( not fd.ПолучитьСчет( "Доходы ДУ", null, false, FiRole, CreditAcc, OperDate) )
      stat = 1;
    end;
  end;

  return TS_IIF(stat, 0, 1);
END;

MACRO ВыполнитьНачислениеПДДдляОдногоВекселя(OrderBnrs, bnr, OperDate, ValueDate)

  var НадежностьКатегории = false;
  var fd = TS_VABnrFD(DL_VSBANNER, bnr.rec.BCID, NULL, NULL);
  var leg = fd.GetLeg();
  record income("vsincome");
  var inc = TBFile("vsincome");
  var CurrEnrolID = 0;
  var BalanceDate = date(0,0,0);
  var stat = 0;
  var СуммаДохода = 0.0, statP = true, PerS=0.0, DiscS=0.0;
  var ДНН, ДПН;
  var PercDate = date(0,0,0), LastPercDate = date(0,0,0);
  var НачДата, КонДата, VDate=date(0,0,0);
  var DebetAcc = TRecHandler("account.dbt" );
  var CreditAcc = TRecHandler("account.dbt" );
  var NeedDPP = true;
  record PrcCntSched(PrcCntSched);

  if((not ВексельДисконтный(leg)) and ( not ВексельПроцентный(leg))) //вексель не процентный и не дисконтный
    return 0; //т.е. всё ок, так как начислять всё равно нечего
  end;

  ПолучитьДатыПериодаНачисления(fd, ValueDate, @income.StartDate, @income.EndDate);
  BalanceDate = VA_GetLastBalanceDate(bnr.rec.BCID);
  CurrEnrolID = VA_GetLastAccountedEnrolmentID(bnr.rec.BCID, BalanceDate);

  //здесь идет расчет сумм по векселю и добавление их в массив с группировкой по эмитенту и надежности категории качества
  if( not ОпределитьНадежностьКатегорииКачестваВекселя(bnr, TS_IIF((income.EndDate > date(0,0,0)), income.EndDate, ValueDate), @НадежностьКатегории) )
    msgbox("Невозможно определить надежность категории качества векселя сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber));
    return 1;
  end;

  inc.AddFilter(" t_EndDate = "+GetSQLDate(income.EndDate)+" and t_BCID = " + bnr.rec.BCID + " and t_Enrolment_ID = " + CurrEnrolID);
  if(inc.Next())
    if(OrderBnrs.fromTick == true)
      //если в операции узнали, что начисление было, то ругаться не будем, а выполним лишь отнесение на доход
      NeedDPP = false;
    else
      msgbox( "Начисление ПДД по ц/б сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber) + " за "+income.EndDate+" уже выполнялось.");
      return 1;
    end;
  end;
  inc.DropFilter();

  //1. Проверка, изменилась ли категория с ненадежной на надежную?
  if( ((НадежностьКатегории == true) and (НадежностьПредыдущегоНачисления(bnr.rec.BCID) == false)) or (OrderBnrs.NeedTranH))
     СуммаДохода = ПолучитьСуммуНеотнесенныхПроцентов(bnr.rec.BCID);

     if((OrderBnrs.NeedTranH) and (OrderBnrs.IncGroup.GetIncQuality(bnr.rec.BCID) == UNSET_CHAR)) //если доначисляли по ненадежной категории - надо также учесть при переносе на доход
       СуммаДохода = СуммаДохода + OrderBnrs.IncGroup.GetIncSumm(bnr.rec.BCID, FIROLE_PERCENT);
     end;

     if( СуммаДохода != 0.0 )

       if( not GetTranHAccounts(fd, FIROLE_PERCENT, OperDate, DebetAcc, CreditAcc) )
         stat = 1;
       end;

       if(not stat)
         OrderBnrs.add(BPT_OTHERPERC, DebetAcc, CreditAcc, leg.rec.PFI, СуммаДохода, bnr.rec.BCID, bnr.rec.Issuer);
       end;
     end;

     СуммаДохода = ПолучитьСуммуНеотнесенногоДисконта(bnr.rec.BCID);
     if((OrderBnrs.NeedTranH) and (OrderBnrs.IncGroup.GetIncQuality(bnr.rec.BCID) == UNSET_CHAR)) //если доначисляли по ненадежной категории - надо также учесть при переносе на доход
       СуммаДохода = СуммаДохода + OrderBnrs.IncGroup.GetIncSumm(bnr.rec.BCID, FIROLE_DISCOUNT);
     end;

     if( СуммаДохода != 0.0 )

       if( not GetTranHAccounts(fd, FIROLE_DISCOUNT, OperDate, DebetAcc, CreditAcc) )
         stat = 1;
       end;

       if(not stat)
         OrderBnrs.add(BPT_OTHERDISC, DebetAcc, CreditAcc, leg.rec.PFI, СуммаДохода, bnr.rec.BCID, bnr.rec.Issuer);
       end;
     end;
  end;

  //2. Проценты
  if( (not stat) and (OrderBnrs.NeedPerc) and (NeedDPP) and (ВексельПроцентный(leg)) and (НужноНачислитьПроценты(bnr, leg, ValueDate)) )
     LastPercDate = ПолучитьДатуПоследНачПроц(bnr.rec.BCID);
     if( LastPercDate < bnr.rec.BCPresentationDate) //было предъявление векселя, но остались недоначисленные проценты
       //то начислить должны только до даты предъявления
       PercDate = bnr.rec.BCPresentationDate;
     end;

     statP = true;
     if( ((leg.rec.InterestStart > BalanceDate) and ((leg.rec.InterestStart+1) > ValueDate) ) or
         ( (BalanceDate > leg.rec.InterestStart) and ((BalanceDate+1) > ValueDate)) )
       msgbox( "Дата начисления процентов по векселю сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber) + " еще не наступила");
       statP = false;
     elif(not НайтиОткрытьСчетПроцВекселя (prccontract, bnr.rec.BCID, BalanceDate) )
       msgbox( "Не найден счет процентов векселя сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber) + ", выданного " + bnr.rec.HolderName );
       statP = false;
     end;

     if(statP)
       VDate = VS_GetRightPcDate(prccontract, ValueDate);

       if(PercDate == date(0,0,0))
         PercDate = VDate;
       end;

       if (not Prc_CheckHistory(prccontract.ContractID, 1, LastPercDate, PrcCntSched) )
         msgbox( String("Пропущено начисление процентов за период ", date(PrcCntSched.PeriodBeginDate),":",date(PrcCntSched.PeriodEndDate), " по векселю сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber)));
         statP = false;
       elif( not VS_PercentCalc (prccontract.ContractID, PercDate, LastPercDate, PerS, OrderBnrs.ID_Operation, OrderBnrs.ID_Step) )
         msgbox( "Ошибка при расчете процентов к начислению по векселю сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber));
         statP = false;
       else
         PerS = round(PerS, 2);
       end;
     end;
     //2.Начисление процентов
     if((statP) and (PerS != 0.0))

       //ищем счета
       DebetAcc.Clear();
       CreditAcc.Clear();

       if( not fd.ПолучитьСчет( "Портфель ДУ", null, false, FIROLE_PERCENT, DebetAcc, OperDate) )
         stat = 1;
       end;

       if(not stat)
         if( НадежностьКатегории )
           if( not fd.ПолучитьСчет( "Доходы ДУ", null, false, FIROLE_PERCENT, CreditAcc, OperDate) )
             stat = 1;
           end;
         else
           if( not fd.ПолучитьСчет( "ПДД ДУ", null, false, FIROLE_PERCENT, CreditAcc, OperDate) )
             stat = 1;
           end;
         end;
       end;

       if(not stat)
         OrderBnrs.add(TS_IIF(НадежностьКатегории, BPT_RPERCENT, BPT_HPERCENT), DebetAcc, CreditAcc, leg.rec.PFI, PerS, bnr.rec.BCID, bnr.rec.Issuer);
         if((OrderBnrs.NeedTranH) and (not НадежностьКатегории) and (PerS))
           if(not GetTranHAccounts(fd, FIROLE_PERCENT, OperDate, DebetAcc, CreditAcc) )
             stat = 1;
           end;
           if(not stat)
             OrderBnrs.add(BPT_OTHERPERC, DebetAcc, CreditAcc, leg.rec.PFI, PerS, bnr.rec.BCID, bnr.rec.Issuer);
           end;
         end;
       end;

     end;
  end;

  //3. Дисконт
  if( (not stat) and (OrderBnrs.NeedDisc) and (NeedDPP) and (ВексельДисконтный(leg)) )
    DiscS = ПолучитьСуммуДисконтаКНачислению(fd, ValueDate, CurrEnrolID);

    //ищем счета
    DebetAcc.Clear();
    CreditAcc.Clear();

    if( not fd.ПолучитьСчет( "Портфель ДУ", null, false, FIROLE_DISCOUNT, DebetAcc, OperDate) )
      stat = 1;
    end;

    if(not stat)
      if( НадежностьКатегории )
        if( not fd.ПолучитьСчет( "Доходы ДУ", null, false, FIROLE_DISCOUNT, CreditAcc, OperDate) )
          stat = 1;
        end;
      else
        if( not fd.ПолучитьСчет( "ПДД ДУ", null, false, FIROLE_DISCOUNT, CreditAcc, OperDate) )
          stat = 1;
        end;
      end;
    end;

    if(not stat)
      OrderBnrs.add(TS_IIF(НадежностьКатегории, BPT_RDISCOUNT, BPT_HDISCOUNT), DebetAcc, CreditAcc, leg.rec.PFI, DiscS, bnr.rec.BCID, bnr.rec.Issuer);
      if((OrderBnrs.NeedTranH) and (not НадежностьКатегории) and (DiscS))
        if( not GetTranHAccounts(fd, FIROLE_DISCOUNT, OperDate, DebetAcc, CreditAcc))
          stat = 1;
        end;
        if(not stat)
          OrderBnrs.add(BPT_OTHERDISC, DebetAcc, CreditAcc, leg.rec.PFI, DiscS, bnr.rec.BCID, bnr.rec.Issuer);
        end;
      end;
    end;

  end;

  if((not stat) and (NeedDPP) and ((ВексельПроцентный(leg)) or (ВексельДисконтный(leg))))
    income.AutoKey   = 0;
    income.BCID      = bnr.rec.BCID;     // ID векселя/сертификата
    income.Perc      = TS_IIF(statP, PerS, 0.0); // Рассчитанные проценты
    income.Disc      = DiscS;        // Рассчитанный дисконт
    income.Currency  = leg.rec.PFI;  // Валюта
    income.OperDate  = date(OperDate);  // Операционный день, когда выполнялось начисление
    income.Quality   = TS_IIF((НадежностьКатегории == true), SET_CHAR, UNSET_CHAR);   // Категория качества" (надежная "X", ненадежная "")
    income.Enrolment_ID = CurrEnrolID;
    income.IncomeType = VSINCOMETYPE_CHARGE;
    if( InsertVSINCOME(income) )
      msgbox( "Не удалось сохранить запись о начислении ПДД по векселю сер. " + string(bnr.rec.BCSeries) + " N " + trim(bnr.rec.BCNumber) + " в истории" );
      return 1;
    else
      OrderBnrs.AddIncome(income.BCID, income.Enrolment_ID, income.EndDate);
      OrderBnrs.IncGroup.add(income.BCID, income.Disc, income.Perc, income.Quality, 0, 0, 0, 0);
    end;
  end;

  return stat;
END;

MACRO ВыполнитьНачислениеПДДдляВекселейДоговора(OrderFD:TS_OrderFD, OperDate, ValueDate, ID_Operation, NeedPerc, NeedDisc, ID_Step)

  var bnr = TBFile("vsbanner.dbt");
  var stat = 0;
  VAR OrderBnrs = OrderBnrCollect(OrderFD, ID_Operation, OperDate, ValueDate, false, false, null, false, ID_Step);
  var ABCstatus = 0;

  OrderBnrs.NeedPerc = NeedPerc;
  OrderBnrs.NeedDisc = NeedDisc;

  //найдем все векселя договора
  bnr.AddFilter(" t_BackOffice = '"+StrFor(GetIdentProgram())+"' and t_ContrID = "+OrderFD.GetParametr(MC_TYPE_PARAMETR_CONTR_CLIENT));

  while((not stat) and (bnr.Next()))
    VA_GetABCStatusOnDate(bnr.rec.BCID, ValueDate, ABCstatus);

    if(ABCStatus == VABANNER_STATUS_ACCOUNT)
      //обрабатываем каждый вексель
      stat = ВыполнитьНачислениеПДДдляОдногоВекселя(OrderBnrs, bnr, OperDate, ValueDate);
    end;
  end;
  bnr.DropFilter();

  //теперь выполняем проводки
  if(not stat)
    stat = OrderBnrs.ПроводкиОтнесенияНадежных(OperDate);
  end;
  if(not stat)
    stat = OrderBnrs.ПроводкиНачисленияПроцентов(OperDate);
  end;
  if(not stat)
    stat = OrderBnrs.ПроводкиНачисленияДисконта(OperDate);
  end;
  return stat;
END;

MACRO ВыполнитьДоначислениеПДДдляВекселяСделки(bnr, leg, tick, numOrd, lnk, OrderBnrs)
  var stat = 0;

  stat = ВыполнитьНачислениеПДДдляОдногоВекселя(OrderBnrs, bnr, OrderBnrs.OperDate, OrderBnrs.ValueDate);

  return stat;
END;

MACRO ВыполнитьДоначислениеПДДдляВекселейСделки(tick, ID_Operation, OrderFD:TS_OrderFD, OperDate, ValueDate, IncGroup:@variant, NeedTranH, ID_Step)
  var bnr = TBFile("vsbanner.dbt");
  var stat = 0;
  VAR OrderBnrs = OrderBnrCollect(OrderFD, ID_Operation, OperDate, ValueDate, true, false, null, NeedTranH, ID_Step);

  OrderBnrs.IncGroup = IncGroup;

  stat = VA_ForEachBanner(tick, @ВыполнитьДоначислениеПДДдляВекселяСделки, VSORDLNK_K_ALL, OrderBnrs, "BL");

  //теперь выполняем проводки
  if(not stat)
    stat = OrderBnrs.ПроводкиНачисленияПроцентов(ValueDate);
  end;
  if(not stat)
    stat = OrderBnrs.ПроводкиНачисленияДисконта(ValueDate);
  end;
  if(not stat)
    stat = OrderBnrs.ПроводкиОтнесенияНадежных(ValueDate);
  end;

  if(not stat)
    IncGroup = OrderBnrs.IncGroup;
  end;

  return stat;
END;

MACRO ВыполнитьСписаниеПДДдляОдногоВекселя(OrderBnrs, bnr, OperDate, ValueDate)
  var stat = 0;
  var fd = TS_VABnrFD(DL_VSBANNER, bnr.rec.BCID, OrderBnrs.tickfd.tick.rec.BOfficeKind, OrderBnrs.tickfd.tick);
  var leg = fd.GetLeg();
  var СуммаНачисленныхПроцентов = 0.0;
  var СуммаНачисленногоДисконта = 0.0;
  var DebetAcc = TRecHandler("account.dbt" );
  var CreditAcc = TRecHandler("account.dbt" );

  if(OrderBnrs.todayTick)
    if( not fd.ПолучитьСчет( "-Расчеты, ДУ", null, false, null, DebetAcc, ValueDate, leg.rec.PFI) )
      stat = 1;
    end;
  else
    if( not fd.ПолучитьСчет( "+Расчеты, ДУ", null, false, null, DebetAcc, ValueDate, fd.GetParametr(MC_TYPE_PARAMETR_PAYCURRENCY)) )
      stat = 1;
    end;
  end;

  if(not stat)
    if( ВексельПроцентный(leg))
      СуммаНачисленныхПроцентов = ПолучитьСуммуПДД(bnr.rec.BCID, 0, FIROLE_PERCENT)+OrderBnrs.IncGroup.GetIncSumm(bnr.rec.BCID, FIROLE_PERCENT);

      if( not fd.ПолучитьСчет( "Портфель ДУ", null, false, FIROLE_PERCENT, CreditAcc, ValueDate) )
        stat = 1;
      end;

      if(not stat)
         OrderBnrs.add(BPT_RPERCENT, DebetAcc, CreditAcc, leg.rec.PFI, СуммаНачисленныхПроцентов, bnr.rec.BCID, bnr.rec.Issuer);
      end;
    end;

    if((not stat) and (ВексельДисконтный(leg)))
      СуммаНачисленногоДисконта = ПолучитьСуммуПДД(bnr.rec.BCID, 0, FIROLE_DISCOUNT)+OrderBnrs.IncGroup.GetIncSumm(bnr.rec.BCID, FIROLE_DISCOUNT);
      if( not fd.ПолучитьСчет( "Портфель ДУ", null, false, FIROLE_DISCOUNT, CreditAcc, ValueDate) )
        stat = 1;
      end;

      if(not stat)
         OrderBnrs.add(BPT_RDISCOUNT, DebetAcc, CreditAcc, leg.rec.PFI, СуммаНачисленногоДисконта, bnr.rec.BCID, bnr.rec.Issuer);
      end;
    end;
  end;

  return stat;
END;

MACRO ВыполнитьСписаниеПДДдляВекселяСделки(bnr, leg, tick, numOrd, lnk, OrderBnrs)
  var stat = 0;

  stat = ВыполнитьСписаниеПДДдляОдногоВекселя(OrderBnrs, bnr, OrderBnrs.OperDate, OrderBnrs.ValueDate);

  return stat;
END;

MACRO ВыполнитьСписаниеПДДдляВекселейСделки(OrderFD:TS_OrderFD, ID_Operation, OperDate, ValueDate, todayTick, tickfd, IncGroup:@variant)
  var bnr = TBFile("vsbanner.dbt");
  var stat = 0;
  VAR OrderBnrs = OrderBnrCollect(OrderFD, ID_Operation, OperDate, ValueDate, true, todayTick, tickfd, false);

  OrderBnrs.IncGroup = IncGroup;

  stat = VA_ForEachBanner(tickfd.tick, @ВыполнитьСписаниеПДДдляВекселяСделки, VSORDLNK_K_ALL, OrderBnrs, "BL");
  if(not stat)
    stat = OrderBnrs.ПроводкиСписанияПроцентов(ValueDate);
  end;

  if(not stat)
    stat = OrderBnrs.ПроводкиСписанияДисконта(ValueDate);
  end;

  if(not stat)
    IncGroup = OrderBnrs.IncGroup;
  end;

  return stat;
END;
