/*
$Name:        dldlngfun.mac
$Module:      Ценные бумаги
$Description: Общие функции Дилинга
*/

IMPORT "cb_sql.mac", "MC_lib.mac", oprinter, CurrInter, DealsInter, "dl_elank.mac", "dlmisc.mac", "dlquery.mac", DVInter, dlkvitcmn;
import usr_connect_attr, oralib, likepy;

/* получить дату в виде xx.xx.xx или xx.xx.xxxx. По умолчанию
   дата в коротком формате. */
macro DateToStr( ADate, LongFormat )
  if( LongFormat )
    return date_as_string( 1, ADate, false );
  else
    return date_as_string( 1, ADate );
  end;
end;

/* Функция формирует строку для вывода значения переменной 
   с заданным количеством знаков после запятой.
   _var  - значение переменной
   _point - количество знаков
   _parm - спецификатор форматирования
*/
macro ЧислоCЗаданнойТочностью( _var, _point:integer, _parm:string ) 
  var TmpStr:string;
   if(   (valtype(_var) == V_DOUBLE)   or (valtype(_var) == V_DOUBLEL)
         or (valtype(_var) == V_MONEY) or (valtype(_var) == V_MONEYL) )
      if( (valtype(_parm) == V_UNDEF) OR (_parm == "") )
         TmpStr = "String(_var:0" + ":" + string(_point) + ")";
      else
         TmpStr = "String(_var:0" + ":" + string(_point) + ":" + _parm + ")";
      end;
      return ExecExp( TmpStr );
   else
      return String( _var );
   end;
end;

class DL_AccData( _AccObject:string, _Account:string, _Code_Currency:integer, _Chapter:integer )
   var AccObject      = _AccObject,/*объект счета (код сделки или ц\б)*/
       Account        = _Account,
       Code_Currency  = _Code_Currency,
       Chapter        = _Chapter;
end;

/*массив счетов*/
class (TArray) DL_AccCollector

   /* Очистить массив. */
   macro ClearArray
      this.Size = 0;
   end;

   macro AddAcc( AccObject:string, Account:string, Code_Currency:integer, Chapter:integer  )
      var
      Counter = 0;

      while( (Counter < this.Size) and ((AccObject != this.(Counter).AccObject) or (Account != this.(Counter).Account) or (Code_Currency != this.(Counter).Code_Currency) or (Chapter != this.(Counter).Chapter)) )
         Counter = Counter + 1;
      end;

      if(Counter == this.Size)
         this.(Counter) = DL_AccData(AccObject,Account,Code_Currency,Chapter);
      end;
   end;

end;

/* Массив для хранения уникальных (неповторяющихся) текстовых строк.
   Реализован как наследник от TArray. Строки хранятся отсортированными
   в порядке возрастания.
   Дополнительные методы:
      AddString   - добавить строку в массив.
      ClearArray  - очистить массив.
      PrintArray  - распечатать все строки в массиве. */
class (TArray) DL_TUniqStrCollector

   /* Очистить массив. */
   macro ClearArray
      this.Size = 0;
   end;

   /* Добавить строку в массив. */
   macro AddString( Str )
      var
         Counter, CountDown;

      /* Используем линейный просмотр массива. Если потребуется оптимизация
         можно использовать бинарный поиск. */

      Counter = 0;
      while( (Counter < this.Size) and (Str > this.(Counter)) )
         Counter = Counter + 1;
      end;

      if(   (Counter == this.Size)
            or ((Counter < this.Size) and (Str < this.(Counter))) )
         /* Такой строки еще нет в массиве. Сдвигаем элементы вверх
            и на освободившееся место вставим новую строку. */
         CountDown = this.Size;
         while( CountDown > Counter )
            this.(CountDown) = this.(CountDown-1);
            CountDown = CountDown - 1;
         end;

         this.(Counter) = Str;
      else
         /* Строка уже есть в массиве. Ничего не делаем. */
      end;
   end;

end;

PRIVATE VAR IsAutoCloseAcc = NULL;
PRIVATE MACRO DL_IsAutoCloseAcc():BOOL
  VAR ErrCode = 0;

  if( IsAutoCloseAcc == NULL )
     GetRegistryValue( "SECUR\\АВТОМАТИЧЕСКИ ЗАКРЫВАТЬ СЧЕТА", V_BOOL, IsAutoCloseAcc, ErrCode );
     if( ErrCode != 0 )
        IsAutoCloseAcc = false;
     end;
  end;
  return IsAutoCloseAcc;
END;

PRIVATE VAR ShemePathSWIFT = NULL;
MACRO GetShemePathSWIFT():STRING
  VAR ErrCode = 0;
  // при добавлении msgbox поправить boswift.mac
  if( ShemePathSWIFT == NULL )
     GetRegistryValue( "COMMON\\PAYMENTS\\PAYMENTS_SCHEME_SWIFT", V_STRING, ShemePathSWIFT, ErrCode );
     if( ErrCode != 0 )
        ShemePathSWIFT = "";
     end;
  end;
  return ShemePathSWIFT;
END;

PRIVATE VAR ShemePathREPO = NULL;
MACRO GetShemePathREPO():STRING
  VAR ErrCode = 0;
  if( ShemePathREPO == NULL )
     GetRegistryValue( "COMMON\\PAYMENTS\\PAYMENTS_SCHEME_REPO", V_STRING, ShemePathREPO, ErrCode );
     if( ErrCode != 0 )
        ShemePathREPO = "";
     end;
  end;
  return ShemePathREPO;
END;

PRIVATE VAR ShemePathGATE = NULL;
MACRO GetShemePathGATE():STRING
  VAR ErrCode = 0;
  if( ShemePathGATE == NULL )
     GetRegistryValue( "COMMON\\PAYMENTS\\PAYMENTS_SCHEME_GATE", V_STRING, ShemePathGATE, ErrCode );
     if( ErrCode != 0 )
        ShemePathGATE = "";
     end;
  end;
  return ShemePathGATE;
END;

/* Закрыть все лицевые счета с признакои "индивидупльный", открытые по сделке БОЦБ, и все счета с параметризацией по ц\б в погашениях выпуска
CloseAccArray - массив успешно закрытых счетов,
ErrMsgArray - массив ошибок закрытия счетов 
*/
MACRO DL_CloseAccountByDeal(DealID:integer,BofficeKind:integer,CloseDate:Date,CloseAccArray:DL_AccCollector,ErrMsgArray:DL_TUniqStrCollector)
  var stat = 0;
  var ExistCarry = false, IsError = false, IsNotClose = false, ErrorIsOK = false;
  VAR query = "";
  var CloseMode;

  CloseAccArray.Size() = ErrMsgArray.Size() = 0;

  if( not DL_IsAutoCloseAcc() )
     return 0;
  end;

  if( BofficeKind == DL_RETIREMENT )
     query = 
           "SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter, categ.t_Code, tick.t_DealCode, tick.t_dealid, accdoc.T_IsUsable, accdoc.T_DisablingDate " +
           "  FROM dmcaccdoc_dbt accdoc, dmccateg_dbt categ, ddl_tick_dbt tick, ddl_leg_dbt leg " +
           " WHERE accdoc.t_CatID      = categ.t_ID AND "+
           "       tick.t_DealID       = " + string(DealID) + " AND " +
           "       tick.t_BofficeKind  = " + string(BofficeKind) + " AND " +
           "       accdoc.t_DocID      =  tick.t_DealID  AND "+
           /*проверяем параметризацию по FIID (MCCATEG_ATTRMASK_FIID)*/
           "       mod(categ.t_attrmask,2)   = 1 AND "+
           "       accdoc.t_FIID = leg.t_PFI AND " +
           "       leg.t_DealID = tick.t_DealID AND "+
           "       leg.t_LegID = 0 AND "+
           "       leg.t_LegKind = "+LEG_KIND_DL_TICK;

     CloseMode = MC_ACC_CLOSE_ALL;
     ErrorIsOK = true; // для погашения ошибки с остатком и движением не считается ошибкой
  else
     /*по РЕПО счета могут быть открыты и по части сделки и прямо по сделке (поэтому по РЕПО будем смотреть и по DL_SECURLEG и по DL_SECURITYDOC)*/
     query = 
           "SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter, categ.t_Code, tick.t_DealCode, tick.t_dealid, accdoc.T_IsUsable, accdoc.T_DisablingDate " +
           "  FROM dmcaccdoc_dbt accdoc, dmccateg_dbt categ, ddl_tick_dbt tick " +
           " WHERE accdoc.t_CatID      = categ.t_ID AND "+
           "       tick.t_DealID       = " + string(DealID) + " AND " +
           "       tick.t_BofficeKind  = " + string(BofficeKind) + " AND " +
           "       ( (accdoc.t_DocID   = tick.t_DealID AND " +
           "          accdoc.t_DocKind = tick.t_BofficeKind "+
           "         ) OR " +
           "         ( exists(select leg.t_ID "+
           "                    from ddl_leg_dbt leg "+
           "                   where leg.t_DealID = tick.t_DealID "+
           "                     and leg.t_ID = accdoc.t_DocID "+
           "                 ) AND " +
           "           accdoc.t_DocKind = "+string(DL_SECURLEG)+
           "         )" +
           "       )  AND "+
           "       CATEG.T_UPDATEMODE  = 0 "/*MCCATEG_UPDATE_MODE_INDIVID*/;

     CloseMode = MC_ACC_CLOSE_INDIVIDUAL;
  end;

  query = query +
           /*проверим, существует ли счет (на сделке он может висеть как несозданный - на нем нет и не было остатков, такой счет нам не нужен)*/
           "  AND   (select count(1) from daccount_dbt acc "+
           "          where acc.t_Account       = accdoc.t_Account "+
           "            and acc.t_Chapter       = accdoc.t_Chapter "+
           "            and acc.t_Code_Currency = accdoc.t_Currency "+
           "            and acc.t_close_date    = '01.01.0001' "+
           "        ) > 0 ";

  VAR AccRest, 
      AccRS = TRsbDataSet( query );

  CloseAccArray.ClearArray;
  ErrMsgArray.ClearArray;
 
  while( AccRS.MoveNext() )

     OprGetAccountRest( AccRS.Chapter, AccRS.Currency, AccRS.Account, CloseDate, AccRest );

     IsError = false;

     if( AccRest != 0 )
        ErrMsgArray.AddString(
             "На счете \""+ AccRS.Account + "\" по сделке \""+AccRS.DealCode+"\" присутствует ненулевой остаток." );
        IsError = true;
     else

        if( AccRS.Currency == NATCUR )
           ExistCarry = ( DebetA( AccRS.Account, CloseDate+1, NULL, AccRS.Chapter ) != 0 );
           if( ExistCarry == false )
              ExistCarry = ( KreditA( AccRS.Account, CloseDate+1, NULL, AccRS.Chapter ) != 0 );
           end;
        else
           ExistCarry = ( DebetAC( AccRS.Account, AccRS.Currency, CloseDate+1, NULL, AccRS.Chapter ) != 0 );
           if( ExistCarry == false )
              ExistCarry = ( KreditAC( AccRS.Account, AccRS.Currency, CloseDate+1, NULL, AccRS.Chapter ) != 0 );
           end;
        end;

        if( ExistCarry )
           ErrMsgArray.AddString(
                "По счету \""+ AccRS.Account + "\" сделки \""+AccRS.DealCode+"\" есть движения в последующие дни." );
           IsError = true;
        end;

     end;

     if( not IsError )

        stat = 0;
        IsNotClose = false;

        if( AccRS.IsUsable == SET_CHAR )
           stat = MC_FindAndCloseAccountByAccDoc( AccRS.ID, CloseDate, CloseMode );
        elif( (AccRS.IsUsable == UNSET_CHAR) and (SQL_ConvTypeDate(AccRS.DisablingDate) != Date(0,0,0)) )
           stat = DL_CloseDisableMCACCDOC(AccRS.ID, CloseDate, CloseMode);
        else
           IsNotClose = true;
        end;

        if( IsNotClose )
           ErrMsgArray.AddString( "Ошибка закрытия счета "+ AccRS.Account );
        elif( stat )
           var mes = GetErrMsg();
           if (strlen(mes) == 0)
              InitError();
              MemoryError(stat);
              mes = GetErrMsg();
           end;
           ErrMsgArray.AddString( "Ошибка закрытия счета "+ AccRS.Account + ": "+mes );
        else
           CloseAccArray.AddAcc(AccRS.DealCode,AccRS.Account,AccRS.Currency,AccRS.Chapter);
        end;
     end;

  end;

  /*есть ошибки*/
  if( (not ErrorIsOK) AND (ErrMsgArray.Size() > 0) )
     return 1;
  end;

  return 0;
END;


private macro IsDigitNumber( Number )

  var stat = 0, i = 1, ch, DigitString = "0123456789'";
  var flag_point = false;

      while( (not stat) and (i <= strlen(Number)) )
        ch = SubStr( Number, i, 1 );
        if( not Index( DigitString, ch ))
          if( (ch ==".") OR (ch ==",") )
            flag_point = true;
          else
          stat = 1;
        end;
        else
          if( ( flag_point == true ) AND ( NOT( ch == "0" ) ) )
            stat = 1;            
          end;
        end;
        i = i + 1;
      end;

  return stat;

end;

macro IsHaveFractPart( MoneyValue )
   if( IsDigitNumber(string(MoneyValue) ) ) 
      /* Есть дробная часть. */
      return true;
   else
      return false;
   end;
end;

macro SetPrecisionByFractPart( MoneyValue, Precision1, Precision2 )
      /* Есть дробная часть. */
   if( IsHaveFractPart(MoneyValue) ) 
      return Precision1;
   else
      return Precision2;
   end;
end;

macro GetCurrencyConvertErrorMsg( fiidFrom:integer, fiidTo:integer, ADate:DATE )
   return "Не могу сконвертировать сумму из " + ПолучитьКодФинИн(fiidFrom) + " в " + ПолучитьКодФинИн(fiidTo) + " на " + date_as_string(1, ADate);
end;

macro DL_GetValueName( List, Element, Name )
   var ll = TRecHandler("llvalues.dbt");
   if( LL_FindLLVALUES( List, Element, ll ) == true )
      SetParm( 2, ll.rec.Name );
      return ll.rec.Code;
   else
      SetParm( 2, "" );
      return "";
   end;
end;

macro DL_GetRestAccountParam( Chapter, Code_Currency, Account, Dat )
   var Rest = $0, PlanRest = $0;
   OprGetAccountRest(Chapter, Code_Currency, Account, Dat, Rest, PlanRest);
   return Rest;
end;

macro DL_GetRestAccount( accbuf, Dat )
   return DL_GetRestAccountParam(accbuf.Chapter, accbuf.Code_Currency, accbuf.Account, Dat);
end;

/**** PROGRESS BAR CLASS *************************************************/

   /* Класс, инкапсулирующий ProgressBar. Нужен для того, чтобы вручную
      не управлять счетчиком. */
   class TProgressBar
      private var
         IsShowProgress = false,
         Counter        = 0;

      /* Инициализация прогрессбара.
            CountRec       -  размер шкалы
            Mes            -  сообщение в статус строку
            Head           -  сообщение в заголовок окна
            MinPossCount   -  минимальный размер шкалы, для которого
                              прогрессбар будет показан */
      macro Init( CountRec, Mes, Head, MinPossCount )
         IsShowProgress = (MinPossCount == null) or (CountRec >= MinPossCount);
         Counter = 0;

         if( IsShowProgress )
            InitProgress( CountRec, Mes, Head );
         end;
      end;

      /* Увеличить счетчик на 1. */
      macro Use
         if( IsShowProgress )
            Counter = Counter + 1;
            UseProgress( Counter );
         end;
      end;

      /* Убрать прогрессбар с экрана. */
      macro Remove
         if( IsShowProgress )
            RemProgress;
            IsShowProgress = false;
         end;
      end;
   end;

macro ClearGlobalTmp( Name )
  var cmd = RSDCommand("TRUNCATE TABLE " + Name + " DROP STORAGE");
   cmd.Execute();
end;

/* Получить минимальную дату комиссии по операции */
macro DL_GetMinComPlanDateByOper( pDocKind:integer, pDocID:integer, pPlanPayDate:date ):date
  var RetVal = date(0,0,0);
  var SQL, Query, Data;

  SQL = " SELECT NVL(MIN(Com.t_PlanPayDate), TO_DATE('01.01.0001', 'dd.mm.yyyy')) PlanPayDate " +
        "   FROM DDLCOMIS_DBT Com " +
        "  WHERE Com.t_DocKind = ? " +
        "    AND Com.t_DocID   = ? " +
        "    AND Com.t_FactPayDate = TO_DATE('01.01.0001', 'dd.mm.yyyy') ";

  if( pPlanPayDate != NULL )
     SQL = SQL + " AND Com.t_PlanPayDate > ? ";
  end;

  Query = RSDCommand(SQL);
  Query.NullConversion = true;
  Query.addParam("", RSDBP_IN, pDocKind);
  Query.addParam("", RSDBP_IN, pDocID);
  if( pPlanPayDate != NULL )
     Query.addParam("", RSDBP_IN, pPlanPayDate);
  end;
  Query.execute();
  Data = TRsbDataSet(Query);
  if( Data.MoveNext() )
     RetVal = SQL_ConvTypeDate(Data.rec.PlanPayDate);
  end;

  return RetVal;
end;

/* Класс - параметры квитовки */
CLASS DL_KvitParms()
  private var Payms = TArray;

  PRIVATE CLASS KvitPair( id, sum )
     var PaymID = id, PaymSum = sum, FactAmount = sum;
  END;

  MACRO GetPaymSum(id) /* возвращает платеж */
     var i = 0;
     while(i < Payms.size)
        if(id == Payms(i).PaymID)
           return Payms(i).PaymSum;
        end;
        i = i + 1;
     end;

     return -1;
  END;

  MACRO Add( id, sum )
     var i = 0;
     while(i < Payms.size)
        if(id == Payms(i).PaymID)
           return;
        end;
        i = i + 1;
     end;
     Payms(Payms.size) = KvitPair(id, sum);
  END;

  MACRO Minus( id, sum )
     var i = 0;
     while(i < Payms.size)
        if(id == Payms(i).PaymID)
           Payms(i).PaymSum = Payms(i).PaymSum - sum;
           return;
        end;
        i = i + 1;
     end;
  END;

  MACRO MinusFactAmount( id, sum )
     var i = 0;
     while(i < Payms.size)
        if(id == Payms(i).PaymID)
           Payms(i).FactAmount = Payms(i).FactAmount - sum;
           return;
        end;
        i = i + 1;
     end;
  END;

  MACRO GetNotFullKvitPaymID()
     var i = 0;
     while(i < Payms.size)
        if( Payms(i).FactAmount != $0 )
           return Payms(i).PaymID;
        end;
        i = i + 1;
     end;
     return 0;
  END;

END;

/* Квитовка платежей, размерности массивов PlanIDs и FactIDs одинаковые */
MACRO DL_КвитовкаПлатежа( PlanIDs, FactIDs )
  var stat = 0,
      fact, plan,
      pml = TRecHandler("pmlink.dbt"),
      СчетНевПоступления = "",
      i = 0;

  while( i < PlanIDs.size )
    fact = RsbPayment(FactIDs[i]);
    plan = RsbPayment(PlanIDs[i]);

    if( fact.FuturePayerAccount != "" )
      СчетНевПоступления = Unkn_GetAccountPassive({OperDprt}, fact.PayerFIID); //Получить счет "НевПоступления"
      if( (СчетНевПоступления == fact.FuturePayerAccount) and (fact.PayerFIID == plan.PayerFIID) )
        plan.FuturePayerAccount = СчетНевПоступления;
      end;
    end;

   pml.rec.Amount = min(fact.FuturePayerAmount, plan.FuturePayerAmount);
   pml.rec.FIID   = fact.BaseFIID;
   pml.rec.IPSign = "-";
   pml.rec.PPSign = "-"; 
   stat = plan.LinkPayment(fact, PMLINK_KIND_KVITING, pml);
   if( stat )
      DisplayError();
      MsgBox("Ошибка при выполнении|квитовки планового платежа " + PlanIDs[i] + "|с фактическим платежом " + FactIDs[i]);
      return false;
    end;

    i = i + 1;
  end;

  return (stat == 0);
END;

MACRO DL_ПолучитьТО(RQID:INTEGER, DlRq:TRecHandler):BOOL
  var Select, DataSet;

  DlRq.Clear();

  Select = RSDCommand("select * from ddlrq_dbt where t_ID = ?");
  Select.AddParam("", RSDBP_IN, RQID);
  Select.execute();
  DataSet = TRsbDataSet(Select);
  if(DataSet.moveNext())
    DataSet.GetRecord().CopyTo( DlRq.rec );
    return true;
  end;  

  return false;
END;

/* Квитовка платежей, размерности массивов PlanIDs и FactIDs одинаковые */
MACRO DL_КвитовкаТОсПлатежами( PlanIDs, FactIDs, ExecDate:date, parms )
  var fact:RsbPayment, plan = TRecHandler("dlrq.dbt"),
      СчетНевПоступления = "",
      i = 0, Sum = $0, RqID = 0, PaymentID = 0;

  while( i < PlanIDs.size )
     if( (PaymentID == 0 ) OR (FactIDs[i] != PaymentID) )
     fact = RsbPayment(FactIDs[i]);
        PaymentID = FactIDs[i];
     end;

     if( (plan.rec.ID != PlanIDs[i]) and (not DL_ПолучитьТО(PlanIDs[i],plan)) )
        MsgBox("Ошибка при выполнении|квитовки планового ТО " + PlanIDs[i] + "|с фактическим платежом " + FactIDs[i]+":|не найдено ТО с ID "+ PlanIDs[i]);
        return false;
     end;

     if( plan.rec.FactAmount != $0 )
        Sum = min(fact.FuturePayerAmount,plan.rec.FactAmount);
        if( DL_CreatePmLinkByRQ(PlanIDs[i], FactIDs[i], Sum, fact.BaseFIID, true) != 0 ) 
           MsgBox("Ошибка при вставке связи планового ТО " + PlanIDs[i] + "|с фактическим платежом " + FactIDs[i]);
           return false;
        end;
      
        plan.rec.FactAmount = plan.rec.FactAmount - Sum;
        parms.MinusFactAmount(PlanIDs[i],Sum);
        /*Если ТО полностью сквитовано, то на ТО устанавливается признак <Сквитовано>, статус ТО меняется на <Исполнено>*/
        if( plan.rec.FactAmount == $0 )
      
           plan.rec.FactAmount = $0;
           plan.rec.State      = DLRQ_STATE_EXEC;
           plan.rec.ChangeDate = ExecDate;
           plan.rec.IsKvit     = SET_CHAR;
           plan.rec.FactDate   = ExecDate;
      
           if( DL_ChangeDLRQ(plan, ExecDate, DLRQ_ACTION_UPDATE) != 0 )
              DisplayError();
              MsgBox("Ошибка обновления планового ТО " + PlanIDs[i]);
              return false;
           end;
      
        end;
     end;

     i = i + 1;
  end;


  RqID = parms.GetNotFullKvitPaymID();
  /*по ТЗ: частичной квитовки ТО быть не может*/
  if( RqID )
     MsgBox("Не хватает суммы фактического платежа для полной квитовки ТО с ID " + RqID);
     return false;
  end;

  return true;
END;

PRIVATE MACRO ByDefault( x, value )
  if( ValType(x) == V_UNDEF )
     setparm(0, value);
  end;
END;

//Simanov. Ищет значение поля uf4 в платеже
private macro GetUserField4 (PaymID)
  var u4 = "";
  var sql = ExecSqlselect("select t_userfield4 from dpmpaym_dbt where t_paymentid = "+PaymID);
  if (sql.MoveNext() )
    u4 = sql.value(0);
  end;
  return u4;
End;

//Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить
private macro deal_banknote (paymid):bool
  var sql = "select 1 "
          + "from ddvndeal_dbt deal "
          + "join dpmpaym_dbt paym on paym.t_dockind = deal.t_dockind and "
          + "                         paym.t_documentid = deal.t_id and "
          + "                         paym.t_paymentid = :paymid "
          + "where deal.t_dvkind = 8 ";
  return execSqlselect(sql, makeArray(sqlParam("paymid", paymid))).moveNext;
onerror()
  return false;
End;

PRIVATE MACRO PmBookpass( pm,
                          BpGround,                          /* основание проводки */
                          CreditAccount, CreditAccountFIID,  /* счет кредита с валютой */
                          MinorAmount, MinorFIID,            /* сумма проводки с валютой */
                          MinorCrossRate,                    /* курс конверсии Minor'а к дебету */
                          MinorCreditCrossRate,              /* курс конверсии Minor'а к кредиту */
                          IsPartOfMain,
                          Date_Carry,
                          Number_Pack,
                          Numb_Document,
                          Result_Carry,
                          Oper
                          , needattr //Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить
                        ):bool
  var paymtr, pd, UserField4;

  var futurePayer = pm.FuturePayerAccount; // #283543

  paymtr = pm.MakeTransaction(CreditAccount, CreditAccountFIID, MinorAmount, MinorFIID, MinorCrossRate, MinorCreditCrossRate);
  if( paymtr == NULL )
     MsgBox("Ошибка при создании проводки по платежу");
     return false;
  end;

  if( ValType(IsPartOfMain) != V_Undef )
     paymtr.IsPartOfMain = IsPartOfMain;
  end;

  ByDefault(Date_Carry,     {curdate});
  ByDefault(Result_Carry,   1);
  ByDefault(BpGround,       pm.Ground);
  ByDefault(CreditAccount,  pm.FutureReceiverAccount);
  ByDefault(Oper,           {Oper});

  if( CreditAccount == "" )
     MsgBox("Не задан счет получателя в платеже");
     return false;
  end;

  //Выгрузка проводок обратно в БИС для редактирования платежа
  if (Number_Pack == 170)
    UserField4 = GetUserField4(pm.PaymentID);
    paymtr.Numb_Document = UserField4;
    paymtr.UserField1 = "ENCASH:"+UserField4;
    paymtr.UserField3 = 1;
  end;  

  paymtr.Chapter     = 1;
  paymtr.Date_Carry  = Date_Carry;
  paymtr.ResultCarry = Result_Carry;
  paymtr.Kind_Oper   = " 1";
  paymtr.Ground      = BpGround;
  paymtr.Oper        = Oper;
  paymtr.Number_Pack = Number_Pack;

  if( not paymtr.Carry )
     Msgbox("Ошибка при проводке по платежу");
     return false;
  end;

  if ( (paymtr.Number_Pack == 170) and (needattr) ) //Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить needattr
    Connect_attr_from_paym_to_trn(pm.PaymentID, paymtr.acctrnid, 102, 102);
  elif ( (paymtr.Number_Pack == 170) and (not needattr) ) //Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить
    Connect_attr_to_trn (paymtr.acctrnid, 102, "06", Date_Carry);
  end;

  pm.FuturePayerAccount = futurePayer; // #283543

  // #283543 отмена поведения банкинга, который если оставшийся futureAmount равен сумме проводки, делает FutureAccount равном Account

  return true;
END;

//Simanov. Доработано основание проводки, ролевая модель, пачки
MACRO DL_ВыполнитьПроводкиКвитовки( parms, PlanIDs, FactIDs, KvitAmounts, ExecDate, ground, Number_Pack, oper ):bool
  var i = 0, Sum, needToClose = false,
      planpaym, factpaym;

  var needattr = true; //Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить
  
  ByDefault(ground, "Квитовка платежа");

  while( i < PlanIDs.size )
     if( (planpaym = RsbPayment(PlanIDs(i))) == null )
        MsgBox("Не найден платеж ", planpaym.PaymentID);
        return false;
     elif( (planpaym.PayerBankID == {OurBank}) and (not ВнешПлатПоСхРасч(planpaym.PaymentID)))
        MsgBox("Квитовка внутренних платежей не поддерживается");
        return false;
     //elif( (planpaym.Purpose != BAi) and (planpaym.Purpose != CAi) and (planpaym.Purpose != BRi) and (planpaym.Purpose != CRi) )
        //return false;
     elif( (factpaym = RsbPayment(FactIDs(i))) == null )
        MsgBox("Не найден платеж ", FactIDs(i));
        return false;
     end;

     //Simanov - В рублевых проводках основание использовать из входящего платежа
     if( (factpaym.BaseFIID == NATCUR) and (factpaym.ground != "") )
       ground = factpaym.ground;
     end;

     //Simanov. Установка 170-й пачки для ответной выгрузки в БИС.
     if (not inList(substr(factpaym.FuturePayerAccount, 1, 5), "30111", "30109") ) // Simanov. i-support 505551
       if (factpaym.ReceiverAccount == planpaym.ReceiverAccount)
         if ( planpaym.BaseAmount < factpaym.BaseAmount ) //Попался платёж по сумме больше требования => С этого платежа будут квитоваться и другие требования => пачка 170, в БИС выгружается
           Number_Pack = 170;
         elif ( (planpaym.BaseAmount > factpaym.BaseAmount) and (factpaym.FuturePayerAmount < factpaym.BaseAmount) ) // Попался платёж по сумме меньше требования => Если платеж уже где-то квитовался, то пачка 170, иначе 30
           Number_Pack = 170;
         else 
           // BIQ-8464 всегда выгружаем
           Number_Pack = 170;
         end;
       else
         Number_Pack = 170;
       end;
     end;

     //Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить
     if ( (Number_Pack == 170) and deal_banknote(planpaym.PaymentID) )
       needattr = false;
     end;

     Sum = min(parms.GetPaymSum(PlanIDs(i)), KvitAmounts(i));

     needToClose = false;

     /*if( Sum > factpaym.FuturePayerAmount )
        MsgBox("Сумма фактического платежа меньше суммы планового");
        return false;*/
     if( factpaym.FuturePayerAmount == 0 )
        needToClose = true;
     end;

     if( not PmBookpass( factpaym, ground,
                         planpaym.ReceiverAccount,  // CreditAccount
                         planpaym.ReceiverFIID,     // CreditAccountFIID
                         Sum,                       // MinorAmount
                         factpaym.ReceiverFIID,     // MinorFIID
                         null, null, null,
                         ExecDate, Number_Pack,
                         null, null, oper
                         , needattr //Simanov - 27.01.2020 доработка для квитовки банкнотных сделок. Когда бис доделает свою часть - удалить
                       )
       )
        return false;
     else
        parms.Minus(PlanIDs(i), Sum);
        if( needToClose )
           factpaym.PaymStatus = PM_FINISHED;
           factpaym.ValueDate  = ExecDate;
        end;
     end;

     i = i + 1;
  end;

  return true;
END;

MACRO DL_ОбновитьСтатусЧастиСделки( leg, State:INTEGER ):BOOL

  if( Leg.rec.OperState != State )
     Leg.rec.OperState = State;

     if( State == DL_LEG_OUTBAL )
        Leg.rec.BitMask = bOR(Leg.rec.BitMask, DL_LEG_OFFBALANCEDEAL);
     end;

     return OprUpdateDL_LEG(leg);
  end;

  return true;
END;

PRIVATE VAR _ТребоватьПеренумерациюСделок = NULL;
MACRO DL_ТребоватьПеренумерациюСделок():bool
  var ErrCode, Path = "SECUR\\ТРЕБОВАТЬ ПЕРЕНУМЕРАЦИЮ СДЕЛОК";

  if( _ТребоватьПеренумерациюСделок == NULL )
     GetRegistryValue(Path, V_BOOL, _ТребоватьПеренумерациюСделок, ErrCode);
     if( ErrCode != 0 )
        MsgBox("Ошибка при получении значения настройки \"" + Path + "\"");
        _ТребоватьПеренумерациюСделок = false;
     end;
  end;

  return _ТребоватьПеренумерациюСделок;
END;

MACRO НужнаПеренумерацияСделокЗаДату( Dat:date ):bool
  var RetVal:bool = false;

  if( DL_ТребоватьПеренумерациюСделок() )
     var cmd = RSDCommand( " select t_CalcState " +
                           "   from DDLDATECALC_DBT " +
                           "  where t_Date = ? " );
     cmd.addParam("", RSDBP_IN, Dat);
     cmd.execute();

     var DataSet = TRsbDataSet(cmd);
     if( DataSet.moveNext() and ((DataSet.CalcState == 0) or (DataSet.CalcState == 2)) )
        RetVal = true;
     end;
  end;

  return RetVal;
END;

MACRO DL_GetGUID()
  var GUID = "";
  var cmd = DL_RSDCommand("SELECT CAST(SYS_GUID() AS VARCHAR2(32)) as GUID FROM dual");
  var DataSet = cmd.Execute();
  
  if(DataSet.moveNext())
    GUID = DataSet.GUID;
  end;

  return GUID;
END;

MACRO DL_ВыполнитьПроводкиКвитовкиТОсПлатежами( parms, PlanIDs, FactIDs, KvitAmounts, ExecDate ):bool
  var i = 0, Sum, needToClose = false,
      factpaym, ReceiverAccount = "", PaymentID = 0;

  var planpaym = TRecHandler("dlrq.dbt");

  while( i < PlanIDs.size )

     if( (PaymentID == 0 ) OR (FactIDs[i] != PaymentID) )
        factpaym = RsbPayment(FactIDs[i]);
        PaymentID = FactIDs[i];
     end;
     
     if( (planpaym.rec.ID != PlanIDs[i]) and (not DL_ПолучитьТО(PlanIDs[i],planpaym)) )
        MsgBox("Ошибка при выполнении|квитовки планового ТО " + PlanIDs[i] + "|с фактическим платежом " + FactIDs[i]+":|не найдено ТО с ID "+ PlanIDs[i]);
        return false;
     end;

     if( parms.GetPaymSum(PlanIDs(i)) != $0 )
        Sum = min(parms.GetPaymSum(PlanIDs(i)), KvitAmounts(i));
       
        needToClose = false;
       
        if( Sum > factpaym.FuturePayerAmount )
           MsgBox("Сумма фактического платежа меньше суммы планового ТО с ID "+ PlanIDs[i]);
           return false;
        elif( Sum == factpaym.FuturePayerAmount )
           needToClose = true;
        end;
       
        if( ExecMacro2("Квитовка_ПолучитьНашСчетТО", planpaym, ExecDate, @ReceiverAccount) != 0 ) 
           MsgBox("Ошибка при выполнении|квитовки планового ТО " + PlanIDs[i] + "|с фактическим платежом " + FactIDs[i]+":|не удалось получить счет по Кт для проводки квитовки");
           return false;
        end;
       
        if( not PmBookpass( factpaym, String("Квитовка платежа"),
                            ReceiverAccount,           // CreditAccount
                            planpaym.rec.FIID,         // CreditAccountFIID
                            Sum,                       // MinorAmount
                            factpaym.ReceiverFIID,     // MinorFIID
                            null, null, null,
                            /*ExecDate*/factpaym.valuedate
                          )
          )
           return false;
        else
           parms.Minus(PlanIDs(i), Sum);
           if( needToClose )
              factpaym.PaymStatus = PM_FINISHED;
              factpaym.ValueDate  = ExecDate;
           end;
        end;
     end;

     i = i + 1;
  end;

  return true;
END;

MACRO DL_ПолучитьПоследнююСумму( DocKind, DocID, SumKind, _Date, Currency, _FIID )
   var Sпред = $0, DataSet, Query, D = Date(0, 0, 0);
   var FIID:integer = -1;

   if( _FIID != null )
      FIID = _FIID;
   end;

   Query = RSDCommand(" Select t_Sum, t_Date, t_Currency "
         + "   From ddlsum_dbt "
         + "  Where t_DocKind = ? "
         + "    and t_DocID   = ? "
         + "    and t_Kind    = ? "
         + "    and t_FIID    = ? "
         + " Order by t_Date Desc ");

   Query.addParam( "", RSDBP_IN, DocKind );
   Query.addParam( "", RSDBP_IN, DocID );
   Query.addParam( "", RSDBP_IN, SumKind );
   Query.addParam( "", RSDBP_IN, FIID );
   Query.execute();

   DataSet = TRsbDataSet(Query);

   if( DataSet.MoveNext() )
      Sпред = DataSet.Sum;
      if( _Date != null )
         D = SQL_ConvTypeDate(DataSet.t_Date);
         Currency = DataSet.t_Currency;
      end;
   end;

   if (_Date != null)
      SetParm(3, D);
   end;
   SetParm(4, Currency);

   return Sпред;
END;

MACRO DL_СохранитьСуммуКомиссии( DocKind:INTEGER, DocID:INTEGER, Kind:INTEGER, CommDate:DATE, Sum:MONEY, NDS:MONEY, Currency:INTEGER, Immaterial:BOOL, pMarket:integer, _FIID:integer ):BOOL
  var dlsum = TRecHandler("DLSUM");
  var vMarket = 0;
  var FIID:integer = -1;

  if( _FIID != null )
     FIID = _FIID;
  end;

  if( (Kind != DLSUM_KIND_SUM_TO_PERCENT          ) and
      (Kind != DLSUM_KIND_SUM_TO_PERCENT_CFI      ) and
      (Kind != DLSUM_KIND_SUM_NOTCARRY_PERCENT    ) and
      (Kind != DLSUM_KIND_SUM_NOTCARRY_PERCENT_CFI) and
      (Kind != DLSUM_KIND_RESERV_SALEREPO2_TP)      and
      (Kind != DLSUM_KIND_RESERV_SALEREPO2_PPR)     and
      (Kind != DLSUM_KIND_RESERV_SALEREPO2_PUDP)    and
      (Kind != DLSUM_KIND_RESERV_SALEREPO2_CONTR)
    )
     if( (Sum == 0) AND (NDS == 0) )
        return true;
     end;
  end;

  if( pMarket != null )
     vMarket = pMarket;
  end;

  dlsum.Clear();
  dlsum.rec.DocKind  = DocKind;
  dlsum.rec.DocID    = DocID;
  dlsum.rec.Kind     = Kind;
  dlsum.rec.Date     = CommDate;
  dlsum.rec.Sum      = Sum;
  dlsum.rec.NDS      = NDS;
  dlsum.rec.Currency = Currency;
  if (Immaterial) 
     dlsum.rec.Immaterial = SET_CHAR;
  else
     dlsum.rec.Immaterial = UNSET_CHAR;
  end;

  dlsum.rec.MarketID = vMarket;
  dlsum.rec.FIID = FIID;

  return OprUpdateDLSUM( dlsum );
END;

MACRO DL_ПолучитьКатегориюСчетаПроводки( Счет, КатегорияСчета:@STRING, КатегорияПарногоСчета:@STRING, McAccDoc )

  record CarryAccount(account);
  record AccDoc(mcaccdoc);
  file AccMCCATEG(mccateg) key 0;
  file AccPairMCCATEG(mccateg) key 0;
  var DataSet, sql;

  КатегорияСчета = КатегорияПарногоСчета = "";
  if( ValType(Счет) == V_STRING ) /*уже задан через категорию*/
     КатегорияСчета = Счет;
  else /*Счет задан через структуру ACCOUNT*/
     if( McAccDoc != NULL )
        copy(AccDoc, McAccDoc);

        sql = RSDCommand( "select categ.t_code " +
                          "  from dmccateg_dbt categ " +
                          " where categ.t_id = ? " +
                          "   AND rownum = 1"
                        );

        sql.addParam("", RSDBP_IN, AccDoc.CatID);
     else
        copy(CarryAccount, Счет);

        sql = RSDCommand( "select categ.t_code " +
                          "  from dmccateg_dbt categ, dmcaccdoc_dbt accdoc " +
                          " where accdoc.t_Chapter  = ? " + 
                          "   AND accdoc.t_Account  = ? " +
                          "   AND accdoc.t_Currency = ? " + 
                          "   AND categ.t_id = accdoc.t_CatID " +
                          "   AND rownum = 1"
                        );
       
        sql.addParam( "", RSDBP_IN, CarryAccount.Chapter );
        sql.addParam( "", RSDBP_IN, CarryAccount.Account );
        sql.addParam( "", RSDBP_IN, CarryAccount.Code_Currency );
     end;

     sql.execute();

     DataSet = TRSBDataSet(sql);

     if( DataSet.MoveNext() )
        КатегорияСчета = DataSet.Code;
     else
        return false;
     end;
  end;

  /*Парный счет*/
  if( NOT( КатегорияПарногоСчета == NULL ) )
     if( MC_FindMCCATEG(КатегорияСчета, AccMCCATEG) AND (AccMCCATEG.PairCatID > 0) )
        ClearRecord(AccPairMCCATEG);
        AccPairMCCATEG.ID = AccMCCATEG.PairCatID;
        if( GetEQ(AccPairMCCATEG) )
           КатегорияПарногоСчета = AccPairMCCATEG.Code;
        end;
     end;
  end;

  return true;
END;

PRIVATE MACRO DL_GetAmountFromDealByReq( Req ):money
  var RetVal:money = $0.0;
  var SQL, Query, Data;

  if( Req.rec.SourceKind == DL_DVDEAL )
     SQL = " SELECT nvl(sum(dvdeal.t_Amount), 0) SumPrincipal " +
           "   FROM dspground_dbt spgr, dspgrdoc_dbt spgrdocreq, dspgrdoc_dbt spgrdocdeal, ddvdeal_dbt dvdeal " +
           "  WHERE spgrdocreq.t_SourceDocID   = ? " +
           "    AND spgrdocreq.t_SourceDocKind = ? " +
           "    AND spgr.t_SPgroundID = spgrdocreq.t_SPGroundID " +
           "    AND spgr.t_SPgroundID = spgrdocdeal.t_SPGroundID " +
           "    AND spgrdocreq.t_SourceDocID   != spgrdocdeal.t_SourceDocID " +
           "    AND spgrdocreq.t_SourceDocKind != spgrdocdeal.t_SourceDocKind " +
           "    AND spgrdocdeal.t_SourceDocID   = dvdeal.t_ID " +
           "    AND spgrdocdeal.t_SourceDocKind = ? ";

     Query = RSDCommand(SQL);
     Query.NullConversion = true;
     Query.addParam("", RSDBP_IN, Req.rec.ID);
     Query.addParam("", RSDBP_IN, Req.rec.Kind);
     Query.addParam("", RSDBP_IN, DL_DVDEAL);
  elif( (Req.rec.SourceKind == DL_DVNDEAL) or (Req.rec.SourceKind == DL_DVDEALT3) or (Req.rec.SourceKind == DL_DVFXDEAL) )
     SQL = " SELECT nvl(sum(nfi.t_Amount), 0) SumPrincipal " +
           "   FROM dspground_dbt spgr, dspgrdoc_dbt spgrdocreq, dspgrdoc_dbt spgrdocdeal, ddvndeal_dbt ndeal, ddvnfi_dbt nfi " +
           "  WHERE spgrdocreq.t_SourceDocID   = ? " +
           "    AND spgrdocreq.t_SourceDocKind = ? " +
           "    AND spgr.t_SPgroundID = spgrdocreq.t_SPGroundID " +
           "    AND spgr.t_SPgroundID = spgrdocdeal.t_SPGroundID " +
           "    AND spgrdocreq.t_SourceDocID   != spgrdocdeal.t_SourceDocID " +
           "    AND spgrdocreq.t_SourceDocKind != spgrdocdeal.t_SourceDocKind " +
           "    AND spgrdocdeal.t_SourceDocID   = ndeal.t_ID " +
           "    AND spgrdocdeal.t_SourceDocKind = ? " +
           "    and nfi.t_DealID = ndeal.t_ID " +
           "    and nfi.t_Type   = ? ";

     Query = RSDCommand(SQL);
     Query.NullConversion = true;
     Query.addParam("", RSDBP_IN, Req.rec.ID);
     Query.addParam("", RSDBP_IN, Req.rec.Kind);
     Query.addParam("", RSDBP_IN, Req.rec.SourceKind);
     Query.addParam("", RSDBP_IN, DV_NFIType_BaseActiv);
  else
     SQL = " SELECT nvl(sum(leg.t_Principal), 0) SumPrincipal " +
           "   FROM dspground_dbt spgr, dspgrdoc_dbt spgrdocreq, dspgrdoc_dbt spgrdocdeal, ddl_tick_dbt tick, ddl_leg_dbt leg " +
           "  WHERE spgrdocreq.t_SourceDocID   = ? " +
           "    AND spgrdocreq.t_SourceDocKind = ? " +
           "    AND spgr.t_SPgroundID = spgrdocreq.t_SPGroundID " +
           "    AND spgr.t_SPgroundID = spgrdocdeal.t_SPGroundID " +
           "    AND spgrdocreq.t_SourceDocID   != spgrdocdeal.t_SourceDocID " +
           "    AND spgrdocreq.t_SourceDocKind != spgrdocdeal.t_SourceDocKind " +
           "    AND spgrdocdeal.t_SourceDocID   = tick.t_DealID " +
           "    AND spgrdocdeal.t_SourceDocKind = tick.t_BofficeKind " +
           "    AND leg.t_DealID  = tick.t_DealID " +
           "    AND leg.t_LegID   = 0 " +
           "    AND leg.t_LegKind = ? ";
   
     Query = RSDCommand(SQL);
     Query.NullConversion = true;
     Query.addParam("", RSDBP_IN, Req.rec.ID);
     Query.addParam("", RSDBP_IN, Req.rec.Kind);
     Query.addParam("", RSDBP_IN, LEG_KIND_DL_TICK);
  end;

  Query.execute();
  Data = TRsbDataSet(Query);
  if( Data.MoveNext() )
     RetVal = SQL_ConvTypeSum(Data.rec.SumPrincipal);
  end;

  return RetVal;
END;

MACRO DL_GetOrderStatus( Req ):integer
  var RetVal = 0;
  var DealAmount = 0;
  if ( Req.rec.Status == REQ_MADE_DEAL ) 
     if( Req.rec.Amount == DL_GetAmountFromDealByReq(Req) )
        RetVal = DL_REQ_ORDERSTATUS_X; //Исполнено
     else
        RetVal = DL_REQ_ORDERSTATUS_P;
     end;
     if (Req.rec.PFIKind == DL_REQ_PFIKIND_CALENDARSPREAD) //календарный спред всегда "Исполнено"
        RetVal = DL_REQ_ORDERSTATUS_X; 
     end;
  elif( Req.rec.Status == REQ_WAIT_ACTIVATION) 
     if( Req.rec.Amount == DL_GetAmountFromDealByReq(Req) )
        RetVal = DL_REQ_ORDERSTATUS_X; //Исполнено
     else
        DealAmount = DL_GetAmountFromDealByReq(Req);

        if((DealAmount != 0) and (Req.rec.Amount > DealAmount))
           RetVal = DL_REQ_ORDERSTATUS_P; //Частично исполнено
        else
           RetVal = DL_REQ_ORDERSTATUS_R; //Отменено
        end;
     end;
     if (Req.rec.PFIKind == DL_REQ_PFIKIND_CALENDARSPREAD) //календарный спред всегда "Исполнено"
        RetVal = DL_REQ_ORDERSTATUS_X; //Исполнено
     end;
  elif( (Req.rec.Status == REQ_REMOVED_EXCHANGE) or
        (Req.rec.Status == REQ_REMOVED_TRADER) or
        (Req.rec.Status == REQ_REJECTED_EXCHANGE) or
        (Req.rec.Status == REQ_REJECTED_CONTRACTOR)
      )

     DealAmount = DL_GetAmountFromDealByReq(Req);

     if((DealAmount != 0) and (Req.rec.Amount > DealAmount))
        RetVal = DL_REQ_ORDERSTATUS_P;
     else
        RetVal = DL_REQ_ORDERSTATUS_R;
     end;
  elif (Req.rec.Status == REQ_ACTIVE)
     RetVal = DL_REQ_ORDERSTATUS_N; // Пока не исполнено
  end;

  return RetVal;
END;

MACRO DL_GetReqStatus(Req):integer
  var RetVal = 0;
  
  if  (Req.rec.Status == REQ_MADE_DEAL)          //заключена
      RetVal = DL_REQ_STATUS_MADE_DEAL;
  elif(Req.rec.Status == REQ_REMOVED_EXCHANGE)   //снята биржей
      RetVal = DL_REQ_STATUS_REMOVED_EXCHANGE;
  elif(Req.rec.Status == REQ_REMOVED_TRADER)     //стяна участником
      RetVal = DL_REQ_STATUS_REMOVED_TRADER;
  elif(Req.rec.Status == REQ_REJECTED_EXCHANGE)  //отклонена биржей
      RetVal = DL_REQ_STATUS_REJECTED_EXCHANGE;
  elif(Req.rec.Status == REQ_REJECTED_CONTRACTOR)//отказано контрагентом
      RetVal = DL_REQ_STATUS_REJECTED_CONTRACTOR;
  elif(Req.rec.Status == REQ_WAIT_ACTIVATION)    //ожидает активации
      RetVal = DL_REQ_STATUS_WAIT_ACTIVATION;
  elif(Req.rec.Status == REQ_ACTIVE)             //активна
      RetVal = DL_REQ_STATUS_ACTIVE;
  end;
  
  return RetVal;
END;

MACRO DL_СкорректироватьДатуЗаявки( RegDate:DATE, RegTime:TIME, NewDate:@Date, NewTime:@Time )
  var Y, Mnd, D, H, Mnt, S;

  DateSplit( RegDate, D, Mnd, Y);
  TimeSplit( RegTime, H, Mnt, S);

  if( Mnt < 1 )
     if( H == 0 )
        DateSplit(RegDate - 1, D, Mnd, Y);
        H = 23;
     else
        H = H - 1;
     end;

     Mnt = 60 - (1 - Mnt);
  else
     Mnt = Mnt - 1;
  end;

  NewDate = Date(D, Mnd, Y);
  NewTime = Time(H,Mnt,S);
END;

MACRO DL_СформироватьНомерЗаявки( PartyID:INTEGER, RegDate:DATE, RegTime:TIME, GrndNum:string ):STRING
  VAR XLD = "", Y, Mnd, D, H, Mnt, S, Query, DataSet;

  DateSplit( RegDate, D, Mnd, Y);
  TimeSplit( RegTime, H, Mnt, S);
  if(not GrndNum)
     GrndNum = "";   
  end;

  if( PartyID > 0 )/*код биржи (определяется по значению параметра "код в номере л/счета")*/
     XLD = ПолучитьКодСубъектаДляСчета( PartyID, PTCK_ACC );
  else
     XLD = "0";
  end;

  XLD = XLD + "." + SubStr(string(Y), strlen(string(Y))-1)+string(Mnd:2:o)+string(D:2:o)+string(H:2:o)+string(Mnt:2:o)+string(S:2:o)+GrndNum;
  if(GrndNum == "")
     Query = RSDCommand("select count(1) CountXLD "
                      + "  from dspground_dbt "
                      + " where T_KIND = ? "
                      + "   and T_XLD like('" + XLD + "%') "
                       );

     Query.addParam( "", RSDBP_IN, 251/*DOCKIND_ORD_CLIENTOP*/ );
     Query.execute();

     DataSet = TRsbDataSet(Query);
     if( DataSet.MoveNext() and (DataSet.CountXLD != null) and (Int(DataSet.CountXLD) > 0) )
       XLD = XLD + string(Int(DataSet.CountXLD) + 1);
     end;
  end;
  return XLD;
END;

MACRO DL_LZ( num, len )
  var str1, len1;

  str1 = trim(string(num));
  len1 = strlen(str1);

  if( len1 >= len )
     return str1;
  else
     return mkstr("0", len-len1) + str1;
  end;
END;

//Получить ID промежуточного платежа по заданным параметрам
MACRO DL_GetDVnPmgrID(DealID:integer, PmSide:integer, BegDate:date, EndDate:date, PayDate:date)
  
   var Query = RSDCommand( " SELECT t_ID " +
                           "   FROM ddvnpmgr_dbt  " +
                           "  WHERE t_DealID  = ? " +
                           "    AND t_Side    = ? " +
                           "    AND t_BegDate = ? " +
                           "    AND t_EndDate = ? " +
                           "    AND t_PayDate = ? " );
   Query.addParam( "", RSDBP_IN, DealID );
   Query.addParam( "", RSDBP_IN, PmSide );
   Query.addParam( "", RSDBP_IN, BegDate );
   Query.addParam( "", RSDBP_IN, EndDate );
   Query.addParam( "", RSDBP_IN, PayDate );

   var DataSet = TRsbDataSet(Query);
   if( DataSet.MoveNext() )
      return DataSet.ID;
   else
      return -1;
   end;

END;

//Получить значение настройки "ИСПОЛЬЗОВАТЬ КОНВЕЙЕР"
macro DL_SecurUseConveyer(ConvID, OperID)
  var ErrCode = 0, OptionValue = true;
  var query, cmd, DataSet;

  GetRegistryValue( "SECUR\\ИСПОЛЬЗОВАТЬ КОНВЕЙЕР", V_BOOL, OptionValue, ErrCode );
  if( ErrCode != 0 )
     MsgBox( "Ошибка при получении значения настройки \"SECUR\\ИСПОЛЬЗОВАТЬ КОНВЕЙЕР\"");
  end;

  //Если настройка использования окнвейера установлена, то проверяем, указан ли URL в конвейере или операции
  //Если url не указан, то вернем false, чтобы не запускать конвейер
  if((OptionValue == true) and ((ValType(ConvID) == V_INTEGER) or (ValType(OperID) == V_INTEGER)))
    var url = "";
    
    if((ValType(ConvID) == V_INTEGER) and (ConvID > 0) and (ValType(OperID) == V_INTEGER) and (OperID > 0))
      query =   " select t_Service "
              + "   from dcnvopr_dbt "
              + "  where t_ConvTypeID = ? "
              + "    and t_OperationID = ? ";

      cmd = DL_RSDCommand(query);

      cmd.AddParam(ConvID);
      cmd.AddParam(OperID);

      DataSet = cmd.Execute();
      if(DataSet.moveNext())
        url = DataSet.Service;
      end;
    end;

    if(url == "")
      if((ValType(OperID) == V_INTEGER) and (OperID > 0))
        query =   " select t_Service "
                + "   from dcnvoprtype_dbt "
                + "  where t_OperationID = ? ";

        cmd = DL_RSDCommand(query);

        cmd.AddParam(OperID);

        DataSet = cmd.Execute();
        if(DataSet.moveNext())
          url = DataSet.Service;
        end;
      end;
    end;

    if(url == "")
      OptionValue = false;
    end;
    
  end;

  return OptionValue;
end;

//Получить значение ПОЛЬЗОВАТЕЛЬСКОЙ настройки "ИСПОЛЬЗОВАТЬ КОНВЕЙЕР"

macro UserDL_SecurUseConveyer()
  var ErrCode = 0, OptionValue = true;

  GetRegistryValue( "РСХБ\\ИСПОЛЬЗОВАТЬ КОНВЕЙЕР", V_BOOL, OptionValue, ErrCode );
  if( ErrCode != 0 )
     MsgBox( "Ошибка при получении значения настройки \"SECUR\\ИСПОЛЬЗОВАТЬ КОНВЕЙЕР\"");
  end;

  return OptionValue;
end;


macro DL_GetPartyWithOwn( PartyKind:integer )

  var RetVal:integer = ALLFININSTR;

  var sqltxt = RSDCommand("select party.t_PartyID " +
                          "  from dparty_dbt party, dpartyown_dbt own " +
                          " where party.t_PartyID = own.t_PartyID " +
                          "   and own.t_PartyKind = ? " +
                          " order by party.t_PartyID desc "
                         );

  sqltxt.addParam("", RSDBP_IN, PartyKind);
  sqltxt.execute();

  var DataSql = TRsbDataSet(sqltxt);

  if( DataSql.MoveNext() )
     RetVal = DataSql.PartyID;
  end;

  return RetVal;
end;

//Получить значение настройки "НАЛОГОВЫЙ УЧЕТ ДЛЯ ЮРЛИЦ-НЕРЕЗ."
macro DL_UseNUTX()
  var ErrCode = 0, OptionValue = true;

  GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ ДЛЯ ЮРЛИЦ-НЕРЕЗ.", V_BOOL, OptionValue, ErrCode );
  if( ErrCode != 0 )
     MsgBox( "Ошибка при получении значения настройки \"SECUR\\НАЛОГОВЫЙ УЧЕТ ДЛЯ ЮРЛИЦ-НЕРЕЗ.\"");
  end;

  return OptionValue;
end;

// Получить остаток на счете
macro DL_FindAccRest( AccFIID:integer, Chapter:integer, Acc:string, OnDate:date, RestFIID:integer )

  return execStoredFunc( "rsb_account.restac", V_MONEY, makeArray( SQLParam( "" , Acc      ),
                      SQLParam( "" , AccFIID     ),
                      SQLParam( "" , OnDate),
                      SQLParam( "" , Chapter  ),
                      SQLParam( "" , 0        ),
                      SQLParam( "" , RestFIID     )) );
end;

PRIVATE VAR ЕдинПулСобств = NULL;
MACRO DL_ЕдиныйПулОбеспеченияСобств(ErrStr:@string) :BOOL
  VAR ErrCode, Path  = "SECUR\\БИРЖЕВЫЕ ОПЕРАЦИИ\\КЛИРИНГ.ОБЕСП.ДЛЯ СОБСТВ.СДЕЛОК";

  if( ЕдинПулСобств == NULL )
     GetRegistryValue( Path, V_INTEGER, ЕдинПулСобств, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        ЕдинПулСобств = 0;
     end;
  end;

  return ЕдинПулСобств;
end;

PRIVATE VAR ЕдинПулКлиент = NULL;
MACRO DL_ЕдиныйПулОбеспеченияКлиент(ErrStr:@string) :BOOL
  VAR ErrCode, Path  = "SECUR\\БИРЖЕВЫЕ ОПЕРАЦИИ\\КЛИРИНГ.ОБЕСП.ДЛЯ КЛИЕНТ.СДЕЛОК";

  if( ЕдинПулКлиент == NULL )
     GetRegistryValue( Path, V_INTEGER, ЕдинПулКлиент, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        ЕдинПулКлиент = 0;
     end;
  end;

  return ЕдинПулКлиент;
end;

PRIVATE VAR UsePaymentsMMVB = NULL;
MACRO DL_ИспользPaymentsПриИмпорте(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ИСПОЛЬЗ. PAYMENTS ПРИ ИМПОРТЕ";

  if( UsePaymentsMMVB == NULL )
     GetRegistryValue( Path, V_BOOL, UsePaymentsMMVB, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        UsePaymentsMMVB = false;
     end;
  end;

  return UsePaymentsMMVB;
end;

PRIVATE VAR UsePaymentsSPB = NULL;
MACRO DL_ИспользPaymentsПриИмпортеСПБ(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ИСП. PAYMENTS ПРИ ИМПОРТЕ СПБ";

  if( UsePaymentsSPB == NULL )
     GetRegistryValue( Path, V_BOOL, UsePaymentsSPB, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        UsePaymentsSPB = false;
     end;
  end;

  return UsePaymentsSPB;
end;

PRIVATE VAR UsePaymentsCurMarket = NULL;
MACRO DL_ИспользPaymentsПриИмпортеВалютногоРынка(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ИСП. PAYMENTS ПРИ ИМП. ВАЛЮТН.Р";

  if( UsePaymentsCurMarket == NULL )
     GetRegistryValue( Path, V_BOOL, UsePaymentsCurMarket, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        UsePaymentsCurMarket = false;
     end;
  end;

  return UsePaymentsCurMarket;
end;

PRIVATE VAR UsePaymentsForCSV = NULL;
MACRO DL_ИспользPaymentsПриИмпортеСрочногоРынка(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ИСП. PAYMENTS ПРИ ИМП. СРОЧН.Р";

  if( UsePaymentsForCSV == NULL )
     GetRegistryValue( Path, V_BOOL, UsePaymentsForCSV, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        UsePaymentsForCSV = false;
     end;
  end;

  return UsePaymentsForCSV;
end;

PRIVATE VAR UsePaymentsMMVBPart2 = NULL;
MACRO DL_ИспользPaymentsПриИмпортеММВБЧасть2(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ИСП. PAYMENTS ПРИ ИМП. ММВБ Ч.2";

  if( UsePaymentsMMVBPart2 == NULL )
     GetRegistryValue( Path, V_BOOL, UsePaymentsMMVBPart2, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        UsePaymentsMMVBPart2 = false;
     end;
  end;

  return UsePaymentsMMVBPart2;
end;

PRIVATE VAR UsePaymentsSPBPart2 = NULL;
MACRO DL_ИспользPaymentsПриИмпортеСПБЧасть2(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ИСП. PAYMENTS ПРИ ИМП. СПБ Ч.2";

  if( UsePaymentsSPBPart2 == NULL )
     GetRegistryValue( Path, V_BOOL, UsePaymentsSPBPart2, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        UsePaymentsSPBPart2 = false;
     end;
  end;

  return UsePaymentsSPBPart2;
end;

PRIVATE VAR QuoteVerificationMode = NULL;
MACRO DL_РежимСверкиКотировок(ErrStr:@string):BOOL
  VAR ErrCode, Path  = "SECUR\\ОТЛАДКА ЗАГРУЗКИ КОТИРОВОК";

  if( QuoteVerificationMode == NULL )
     GetRegistryValue( Path, V_BOOL, QuoteVerificationMode, ErrCode );
     if( ErrCode != 0 )
        ErrStr = "Ошибка при получении значения настройки \"" + Path + "\"";
        QuoteVerificationMode = false;
     end;
  end;

  return QuoteVerificationMode;
end;