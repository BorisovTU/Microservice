/********************************************************\
   Базовый класс конверторов
   Служит для определения общих методов и свойств
   Чтобы умели все наследники, и в них можно было
   эти методы переопределять
\********************************************************/
import PTInter, CTInter, DPInter, SPInter, FIInter, DealsInter/*, CommonInter*/, LikePy, cb_sql, RSD, globals, cnv_error/*, "dpimp.mac", "c_avrs.mac"*/;
//import InsCarryDoc;
var {selfid}=1;

file  FUCKINSHIT  () txt 4048 write;
class Main_convert()


   private const Y   = true;
   private const N   = false;
   
   private const V_TARRAY = 19;    // почему-то не определен в системе, поэтому определим ручками

// СУБЪЕКТЫ

   private const APHENA   = 102; // код в системе банка
   private const DEPCODE  = 103; // 
   private const ALFACODE = 105; //
   private const DEPOZCODE  = 101; // 
   private const PORTFCODENote  = 107;
   Private const Marge_lvl_note = 103;

   private const AVRCODE5 = 102; // Код бумаги в 5.1
   private const KINDKODALFA  = 103;
   private const CAT_CLIENT_CATEGQUAL = 13;

   private const Comiss1  = 1001;
   private const Comiss2  = 1007;

//  ЦБ:
   // вид ценной бумаги
   private const SEC_ACTN   = 20; //акция
   private const SEC_BOND   = 17; //облигация
   private const SEC_DREC   = 10; //депозитарная расписка
   // коды для ценной бумаги
   private const OC_MICEX   = 11; //код ММВБ
   private const OC_CODE404 = 16; //код 404
   private const OC_CFI     = 18; //код CFI
   private const OC_DEPO    = 101; //код в номере счета для депозитария

   // номера категорий для ЦБ
   private const CAT_SECUR_CODE711   = 1 ;
   private const CAT_SECUR_CATEG     = 13;
   private const CAT_SECUR_EXCHCATEG = 15;
   private const CAT_SECUR_DRKIND    = 16;
   private const CAT_SECUR_ORCB      = 17;
   private const CAT_SECUR_QUOTED    = 18;
   private const CAT_SECUR_KIND404   = 25;
   private const CAT_SECUR_CODE404_  = 26;
   private const CAT_SECUR_TSS       = 27;
   private const CAT_SECUR_QUALIFIED = 28;
   private const CAT_SECUR_CODE116   = 32;
   private const CAT_SECUR_CODE405   = 33;
   private const CAT_SECUR_KI        = 34;
   private const CAT_SECUR_Portf     = 102;
   

// константы для типов проверок
   private const STRG  = "STRG"  ; // строка
   private const BL    = "BL"    ; // bool
   private const DT    = "DT"    ; // Дата
   private const DTD   = "DTD"   ; // Дата через точку
   private const DTLS  = "DTLS"  ; // Дата через левый слэш
   private const TM    = "TM"    ; // Время
   private const DTP   = "DTP"   ; // тип документа клиента
   private const DTPN  = "DTPN"  ; // тип документа клиента
   private const NMBR  = "NMBR"  ; // строка из цифр
   private const SX    = "S"     ; // пол клиента-физлица
   private const QUAL  = "QUAL"  ; 
   private const CLNT  = "CLNT"  ; // новый клиент - для нахождения дублей, где их быть не должно
   private const ECLT  = "ECLT"  ; // существующий клиент
   private const ECONTR = "ECONTR"  ; // существующий договор обслуживания
   private const NCLT  = "NCLT"  ; // новый клиент
   private const CTRY  = "CTRY"  ; // страна
   private const RDTP  = "RDTP"  ; // тип регистрационного документа
   private const RDTPN = "RDTPN" ; // наименование типа регистрационного документа
   private const RDORG = "RDORG" ; // тип регистрирующего органа
                                 
   private const QUANT = "QUANT" ; // количество
   private const CUR   = "CUR"   ; // вид валюты
   private const DBL   = "DBL"   ; // деньги
   private const NAVRS = "NAVRS" ; // код новой ценной бумаги - для нахождения дублей, где их быть не должно

   private const EAVRS = "EAVRS" ; // код существующей ценной бумаги
   private const EAVRS102 = "EAVRS102" ; // код существующей ценной бумаги по коду 102
   private const AVKD  = "AVKD"  ; // вид ценной бумаги
   private const AVKDB = "AVKDB" ; // типа базовый тип ЦБ
                                 
   private const EBACN = "EBACN" ; // существующий счет балансовый
   private const NBACN = "NBACN" ; // новый счет балансовый

   private const NDACN = "NDACN" ; // новый счет депо - возвращает входящий параметр, но при этом при нахождении дубля записывает ошибку. проверяет по T_CODE
   private const EDACN = "EDAСN" ; // существующий счет депо - возвр T_CODE
   private const EDACNS= "EDAСNS"; // существующий счет депо - возвр T_BRIEFCODE

// РЕФЕРЕНСЫ для формирования имени файла выгрузки 
   private const REF_FILE_ACCOUNT      = 1000000;
   private const REF_FILE_BALENTRY     = 1000001;
   private const REF_FILE_OUTBALENTRY  = 1000002;
   private const REF_FILE_101          = 1000003;

   private const REF_CONTRNUMINACC     = 127;
   private const REF_TECH_DRAFT        = 12;    /* референс для генерации вх. номера тех. поручения */
   private const REF_TECH_DRAFT_CLIENT = 131;   /* референс для генерации вх. номера тех. для клиентского поручения */
   private const REF_INTERN_DISCOUNT   = 132;   /* референс для генерации вх. номера поручения на зачисление средств ВУ по торговым площадкам */
   
   private const KIND_OPER_TECH_ZACH    = 4761/*5508*/;      /* !!! Номер операции зачисления */
   private const KIND_OPER_TECH_SPIS    = 4752/*5517*/;      /* !!! Номер операции списания */
   private const KIND_OPER_TECH_DOCZACH = 4770/*5508*/;      /* !!! Номер операции зачисления */
   private const KIND_OPER_TECH_DOCSPIS = 4775/*5517*/;      /* !!! Номер операции списания */

   private const CBRATE = 7; // тип курса "ЦБ" - для расчета суммы остатка для загрузки лицевых счетов

   private const NOTE_IK                = 101;

   private const REGORG_NAME = "Рег. палата";
   private const REGORG_ID   = 29;

   private const OUR_BANK_CODE = "0";

   private const UNSET_CHAR = "";

//   private var DM   = true; // debugMode
   private var DM   = false; // debugMode

//   private var path = GetRegVal( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR", true );
   private var path = "..\\txtfile";

   private var strquantity = 0;  // количество строк

   private const DEPOOPER = {oper};  //Операционист депозитария под которым осуществляется вставка документов
   private const CBOper   = {oper};  //Операционист ценныз бумаг под которым осуществляется вставка документов
   var Err = ErrorRecorder(true,false);

//   setDelim("^");
   setDelim(";");


   /*******************************************************************\
     РАБОТА С ПЕРЕМЕННЫМИ: РАЗБОР, ПРЕОБРАЗОВАНИЕ ТИПА, АНАЛИЗ
   \*******************************************************************/
   /******** моя любимая функция - ни с чем не спутаешь! ********/
   private macro iif(a,b,c)
      if(a)
         return b;
      else
         return c;
      end;
   end;


   /******** проверка числа на содержание нецифр, если находит что-то кроме, то возвращает false ********/
   /******** пробелы допустимы ********/
   private macro IsDigital(str)
      var digits = "0123456789. ";
      var temp   = str;

      if  (strlen(temp)==0)
         return false;
      else
         while (strlen(temp)>0)
            if (index(digits, substr(temp, 1, 1))==0)
               return false;
            end;
            temp = substr(temp,2);
         end;
      end;
      return true;
   end;

   /******** проверка суммы на содержание нецифр, если находит что-то кроме цифры или одной запятой/точки, то возвращает false ********/
   private macro IsDouble(str)
      var digits   = "0123456789";
      var punct    = ".,";
      var waspunct = false;
      var temp     = string(str);
      var negative = false;
      var founddigit = false;                                

      if(  (strlen(temp)     >  0   ) and   // первый знак может быть и минусом
           (substr(temp,1,1) == "-" )   )
         negative = true;
         temp = substr(temp,2);
      end;

      while (strlen(temp)>0)
         if (index(digits, substr(temp, 1, 1))==0)          // если среди цифр не нашли
            if(waspunct)                                    // смотрим, была ли встречена точка или запятая
               return false;                                // если уже была, то вторая является признаком ошибки
            elif ((not waspunct                       ) and // если не была, то смотрим, 
                  (index(punct, substr(temp, 1, 1))!=0)   ) // является ли этот знак знаком пунктуации
               waspunct   = true;                           // если является пунктуацией, отмечаем, что пунктуация была
            else                                            // и если этот знак не является знаком пунктуации
               return false;                                // то это явно ошибка
            end;
         else 
            founddigit = true;                              // и говорим, что цифры были
         end;
         temp = substr(temp,2);
      end;
      return founddigit;                                    // если мы ничего кроме минуса и пунктуации не получили, то это ошибка
   end;

   /******** проверка числа на содержание нецифр, если находит что-то кроме цифрs или первого минуса, то возвращает false ********/
   private macro IsQuantity(str:string)
      if(strlen(str)>0)
         if (substr(str,1,1)== "-")
            return IsDigital(substr(str,2));
         else
            return IsDigital(str);
         end;
      else
         return false;
      end;
   end;

   /******** математическая функция знака ********/
   private macro Signum(num:integer)
     if  (num < 0 ) return -1;
     elif(num = 0 ) return 0;
     else return 1;
     end;
   end;


   private macro Absolute(num:integer)
      return num*signum(num);
   end;

   /******** разбитие строки на элементы массива ********/
   private macro ParceArray(arr, str, delim)
      var temparr = TArray;
      var tempstr = str;
      var ind;
      var i = 0;
      while (strlen(tempstr)>0)
         ind = index(tempstr,delim);
         if (ind !=0)
            if(trim(substr(tempstr, 1, ind-1)) != "")
               temparr[i] = trim(substr(tempstr, 1, ind-1));
               tempstr    = trim(substr(tempstr, ind+1));
               i = i + 1;
            else
               tempstr    = trim(substr(tempstr, ind+1));
            end;
         else
            temparr[i] = trim(tempstr);
            tempstr    = "";
         end;
      end;

      return SetParm(1, tempArr);
   end;


   private macro FindInArray(str, arr)
      var res = -1;
      var i   = 0;
      if(Valtype(arr)!= V_TARRAY)
         msgbox("Переменная не является массивом вида Tarray");
      else
         while(i<arr.size)
            if ( arr(i) == str )
               return i;
            end;
            i = i + 1;
         end;
      end;
      return res;
   end;

   /******** разбитие строки на элементы массива ********/
   private macro ParceNumArray(arr, str, delim)
      var temparr = TArray;
      var tempstr = str;
      var ind;
      var i = 0;
      while (strlen(tempstr)>0)
         ind = index(tempstr,delim);
         if (ind !=0)
            if( (          trim(substr(tempstr, 1, ind-1)) != "") and
                (IsDigital(trim(substr(tempstr, 1, ind-1))    ) )    )

               temparr[i] = int(trim(substr(tempstr, 1, ind-1)));
               tempstr    = trim(substr(tempstr, ind+1));
               i = i + 1;
            else
               tempstr    = trim(substr(tempstr, ind+1));
            end;
         else
            temparr[i] = int(trim(tempstr));
            tempstr    = "";
         end;
      end;

      return SetParm(1, tempArr);
   end;


   /******** фактически копия index(), т.к. "индекс" - это поле в клиентах********/
   private macro CharNum (str, chr)  
      return index(str,chr);
   end;

   /********  дополнить нулями до lgt слева ********/
/*   private macro nl(str, lgt)
      var res;
      if( (valtype(str) == V_STRING ) and
          (valtype(lgt) == V_INTEGER)   )
          res =  str;
          while(strlen(res) < lgt)
             res = "0"+res;
          end;
          return res;
      end;
      return str;

   end;
*/

// ДАТЫ
   private macro GetDateFromString( dt ) /* Получение даты из строки формата DD/MM/YYYY-HH:mm:SS */
      return date(int(substr(dt,1,2)),  int(substr(dt,3,2)),  int(substr(dt,5,4)) );
   end;

   /********* Разрезает строку на день, месяц, год по разделителю или до конца строки **********/  
   /********* разделитель помогает понять, что нам надо *********/
   /********* "д.м.г[.*]" -> д, м, г **********/  
   macro SplitDate(dt,dd,mm,yyyy, splitter)  
    
      var dd1,mm1,yyyy1;
      var temp = dt;
      var stat;
      var con  = 0;

      stat  = index (temp, splitter);                        // до первого разделителя
      if (IsDigital(substr(temp, 1, stat-1)))                // если только цифры
         dd1   = int(substr(temp, 1, stat-1));               // преобразуем в число
         temp  = substr(temp, stat+1, strlen(temp)-stat);    // отрезаем следующий кусок

         stat  = index (temp, splitter);                     // до первого разделителя
         if(IsDigital(substr(temp, 1, stat-1)))              // если только цифры
            mm1   = int(substr(temp, 1, stat-1));            // преобразуем в число     
            temp  = substr(temp, stat+1, strlen(temp)-stat); // отрезаем следующий кусок
   
            stat  = index (temp, splitter);
            
            if (stat == 0)                                   // не нашли разделителя
               stat  = strlen(temp);                         // значит берем до конца строки
               if(IsDigital(substr(temp, 1, stat)))          // если только цифры
                  yyyy1 = substr(temp, 1, stat);             
               else
                  return false;
               end;
            else                                             // иначе разделитель нашли значит берем до разделителя
               if(IsDigital(substr(temp, 1, stat-1)))        // если только цифры                 
                  yyyy1 = substr(temp, 1, stat-1);           // преобразуем в число
               else                                     
                  return false;
               end;
            end;
            if   (strlen(yyyy1) == 2)                         // если год был указан в формате ГГ
               yyyy1 = int(yyyy1);
               if (yyyy1>20)
                 yyyy1 = 1900+yyyy1;
               else
                 yyyy1 = 2000+yyyy1;
               end;
            elif (strlen(yyyy1) == 4)                         // если год был указан в формате ГГГГ
               yyyy1 = int(yyyy1);
            else
               return false;                                 // иначе ошибка
            end;
         else
           return false;
         end;
      else
         return false;
      end;

      setParm(2,dd1);
      setParm(3,mm1);
      setParm(4,yyyy1);
      return true;
   end;

   /********* разбитие строки на dd,mm,yyyy **********/  
   private macro SplitDateSimple(str,dd,mm,yyyy)
      var dd1  ;
      var mm1  ;
      var yyyy1;

      if( IsDigital(substr(str,1,2)))
         dd1 = int (substr(str,1,2));
      else
         return false;
      end;
      if( IsDigital(substr(str,4,2)))
         mm1 = int (substr(str,4,2));
      else
         return false;
      end;
      if( IsDigital(substr(str,7,4)))
         yyyy1 = int (substr(str,7,4));
      else
         return false;
      end;
      setParm(2,dd1);
      setParm(3,mm1);
      setParm(4,yyyy1);
      return true;
   end;
   
   /********* Проверка формата даты **********/  
   private macro CheckDate (day, month, year)

      if ((year >= 1900) and (year <= 2100))

         if (month == 1)
            if ((day < 1) or (day > 31))
               return false;
            end;
         elif(month == 2)
           if (year/4.0==Int(year/4))
              if ((year/100.0==Int(year/100))and(year/400.0!=Int(year/400)))
                 if ((day < 1) or (day > 28))
                    return false;
                 end;
             end;
             if ((day < 1) or (day > 29))
                return false;
             end;
           else
             if ((day < 1) or (day > 28))
                return false;
             end;
           end;
         elif(month == 3)
            if ((day < 1) or (day > 31))
               return false;
            end;
         elif(month == 4)
            if ((day < 1) or (day > 30))
               return false;
            end;
         elif(month == 5)
            if ((day < 1) or (day > 31))
               return false;
            end;
         elif(month == 6)
            if ((day < 1) or (day > 30))
               return false;
            end;
         elif(month == 7)
            if ((day < 1) or (day > 31))
               return false;
            end;
         elif(month == 8)
            if ((day < 1) or (day > 31))
               return false;
            end;
         elif(month == 9)
            if ((day < 1) or (day > 30))
               return false;
            end;
         elif(month == 10)
            if ((day < 1) or (day > 31))
               return false;
            end;
         elif(month == 11)
            if ((day < 1) or (day > 30))
               return false;
            end;
         elif(month == 12)
            if ((day < 1) or (day > 31))
               return false;
            end;
         else
            return false;
         end;
      else
         return false;
      end;
      return true;
   end;


   MACRO parsedate(par);
    private var rez;
    if (strlen(trim(par))==0)
      return "";
    else 
      rez = par;
    end;

    if ( (strlen(rez) == 7) or (strlen(rez) == 9) )
      rez="0"+rez;
    end;

    if (strlen(rez) == 8 )
      rez=substr(rez,1,2)+"."+substr(rez,4,2)+".20"+substr(rez,7,2);
    else
      rez=substr(string(rez),1,10);   
    end;

    return (substr(rez,1,2)+"."+substr(rez,4,2)+"."+substr(rez,7,4));

   end;


// ВРЕМЯ

   private macro SplitTimeSimple(str, hh, mm, ss)
      var h,m,s;
      if ( (strlen(str) == 8))
         h = int(substr(str,1,2));
         m = int(substr(str,4,2));
         s = int(substr(str,7,2));
         setParm(2,h);
         setParm(3,m);
         setParm(4,s);
         return true;
      end;
      return false;
   end;

   private macro checkTime(hh:integer ,mm:integer, ss:integer)
      if  ( (hh >= 0) and (hh < 24 ) and
            (mm >= 0) and (mm < 60 ) and
            (ss >= 0) and (ss < 60 ) )
         return true;
      end;
      return false;
   end;

   // получить строку времени с заменой символа ":" на любой другой. требуется для использования в имени файла
   macro GetTimeInString (t, symb)
     var temp;
     var s = iif(valtype(symb)==V_STRING,symb," ");
     var stat = index;
     if (valtype(t) == V_TIME)
        temp = string(t);
        stat = index(temp, ":");
        while (stat != 0)
           temp = substr(temp, 1, stat-1) + symb + substr(temp, stat+1, strlen(temp)-stat);
           stat = index(temp, ":");
        end;
        return temp;
     else
        return "Некорректная дата";
     end;
   end;

   
   /******** преобразовать дату в строку формата ДД ММ ГГГГ с использованием необходимого разделителя ********/
   macro GetDateInString(dt, splitter)
      var dd,mm,yyyy;
      if(valtype(splitter)!=V_STRING)
         splitter = ".";
      end;
      if  (valtype(dt)!=V_DATE)
         return "WRONG DATE"
      else 
         DateSplit(dt,dd,mm,yyyy);
         return string(dd:o:2)+splitter+string(mm:o:2)+splitter+string(yyyy:o:4);
      end;
   end;


   /******** преобразовать дату в строку формата ДД ММ ГГ с использованием необходимого разделителя ********/
   macro GetDateInStringYY(dt, splitter)
      var dd,mm,yyyy;
      if(valtype(splitter)!=V_STRING)
         splitter = ".";
      end;
      if  (valtype(dt)!=V_DATE)
         return "WRONG DATE"
      else 
         DateSplit(dt,dd,mm,yyyy);
         return string(dd:o:2)+splitter+string(mm:o:2)+splitter+substr(string(yyyy),3,2);
      end;
   end;

//ОТЛАДКА
   /******** Открыть быстренько файлик дебага и показать в нем текущий запрос ********/
   private macro _viewsql(fl,str);
      if(DM)
         if(valtype(fl)!=V_FILE)
            Open(fl,path+"_debug"+{curdate}+"-"+GetTimeInString (time(), ".")+".rep");
            insert(fl, str);
            Close(fl);
            viewFile(fl);
         end;
      end;
   end;


   /******** дебагбрейк для режима отладки ********/
   private macro _debugbreak();
      if(DM)
         
      end;
   end;
   /******** msgbox для режима отладки ********/
   private macro _msgbox(str)
      if(DM)
         msgbox(str);
      end;
   end;

//РАБОТА С SQL
   /******** обрезает все пустые символы и добавляет по пробелу с краев ********/
   private macro trims(str)
     return " "+trim(str)+" ";
   end;

   /******** Проверка на содержание в строке CHR(0) и CHR(1) ********/
   private macro NotNullString(str)
      if ( ((str) == strfor(0)) or
           ((str) == strfor(1))  )
         return "";
      else
         return str;
      end;
   end;

   /*******************************************************************\
     ФУНКЦИИ ЗАПРОСОВ
   \*******************************************************************/
   /******** Проверка на содержание в таблице table строки со значением id в поле idname ********/
   /******** возвращается значение поля res  ********/
   private macro CheckIsRecord1(table  ,
                                param1 ,
                                value1 ,
                                res
                                )

      var sql,rs, resstr;
      resstr = iif(((valtype(res)==V_STRING)and (trim(res)!="")),", "+res, "");

      if ( (valtype(table)   == V_STRING ) and
           (valtype(param1)  == V_STRING ) and
           (valtype(value1)  == V_STRING )   )
         sql =        " SELECT "+strupr(param1)+strupr(resstr)+" from "+strupr(table);
         sql = sql +  " WHERE " +strupr(param1)+" = "+strupr(value1);
         _viewsql(FUCKINSHIT , sql);
         rs = RSDRecordSet(sql);

         if(rs.movenext())
            if(valtype(res) == V_STRING)
               return rs.Value(trim(res));
            else
               return true;
            end;
         end;
      end;
      return false;
   end;
   /******** возвращается значение поля res  ********/
   private macro CheckIsRecord2(table   ,
                                param1  ,
                                value1  ,
                                param2  ,
                                value2  ,
                                res
                                )
      var sql,rs, resstr;
      resstr = iif(((valtype(res)==V_STRING)and (trim(res)!="")),", "+res, "");

      if ( (valtype(table)  == V_STRING ) and
           (valtype(param1) == V_STRING ) and
           (valtype(value1) == V_STRING ) and
           (valtype(param2) == V_STRING ) and
           (valtype(value2) == V_STRING )   )
         sql =        " SELECT "+trim(param1) +resstr+" from "+trim(table);
         sql = sql +  "  where "+trim(param1) +" = "+value1;
         sql = sql +  "    and "+trim(param2) +" = "+value2;
         _viewsql(FUCKINSHIT , sql);
         rs = RSDRecordSet(sql);

         if(rs.movenext())
            if(valtype(res) == V_STRING)
               return rs.Value(trim(res));
            else
               return true;
            end;
         end;
      end;
      return false;
   end;

   /******** Проверка на содержание в таблице table
                                                 для объекта param1(поле value1)
                                                        типа param2(поле value2)
                                                        кода param3(поле value3) ********/
   /******** возвращзается значение поля res, если указано res, или true, если не указано, но нашли. Иначе false ********/
   private macro CheckIsRecord3(table ,
                                param1,
                                value1,
                                param2,
                                value2,
                                param3,
                                value3,
                                res   )
      var sql,rs,resstr;
      resstr = iif(((valtype(res)==V_STRING)and trim(res)!=""),", "+res, "");
      if ( (valtype(table)  == V_STRING) and
           (valtype(param1) == V_STRING) and
           (valtype(value1) == V_STRING) and
           (valtype(param2) == V_STRING) and
           (valtype(value2) == V_STRING) and
           (valtype(param3) == V_STRING) and
           (valtype(value3) == V_STRING)   )

         sql =        " SELECT "+strupr(param1)+strupr(resstr)+" from "+strupr(table);

         sql = sql +  "  WHERE "+strupr(param1)+" = "+strupr(value1);
         sql = sql +  "    AND "+strupr(param2)+" = "+strupr(value2);
         sql = sql +  "    AND "+strupr(param3)+" = "+strupr(value3);
         _viewsql(FUCKINSHIT, sql);
         rs = RSDRecordSet(sql);
         if(rs.movenext())
            if(valtype(res) == V_STRING)
               return rs.Value(trim(res));
            else
               return true;
            end;
         end;
      end;
      return false;
   end;

   /******** Проверка на содержание в таблице table
                                                 для объекта param1(поле value1)
                                                        типа param2(поле value2)
                                                        кода param3(поле value3) ********/
   /******** возвращзается значение поля res, если указано res, или true, если не указано, но нашли. Иначе false ********/
   private macro CheckIsRecord4(table ,
                                param1,
                                value1,
                                param2,
                                value2,
                                param3,
                                value3,
                                param4,
                                value4,
                                res   )
      var sql,rs,resstr;
      resstr = iif(((valtype(res)==V_STRING)and trim(res)!=""),", "+res, "");
      if ( (valtype(table)  == V_STRING) and
           (valtype(param1) == V_STRING) and
           (valtype(value1) == V_STRING) and
           (valtype(param2) == V_STRING) and
           (valtype(value2) == V_STRING) and
           (valtype(param3) == V_STRING) and
           (valtype(value3) == V_STRING) and
           (valtype(param4) == V_STRING) and
           (valtype(value4) == V_STRING)   )

         sql =        " SELECT "+strupr(param1)+strupr(resstr)+" from "+strupr(table);

         sql = sql +  "  WHERE "+strupr(param1)+" = "+strupr(value1);
         sql = sql +  "    AND "+strupr(param2)+" = "+strupr(value2);
         sql = sql +  "    AND "+strupr(param3)+" = "+strupr(value3);
         sql = sql +  "    AND "+strupr(param4)+" = "+strupr(value4);
         _viewsql(FUCKINSHIT, sql);
         rs = RSDRecordSet(sql);
         if(rs.movenext())
            if(valtype(res) == V_STRING)
               return rs.Value(trim(res));
            else
               return true;
            end;
         end;
      end;
      return false;
   end;



   /*******************************************************************\
     РАБОТА С ТАБЛИЦАМИ: ЧТЕНИЕ, ПОИСК, ОПРЕДЕЛЕНИЕ СООТВЕТСТВИЯ
   \*******************************************************************/
   /******** входит ли дата в открытые опердни ********/
   private macro IsCurDate(Data)
      var res = Data;

      if(Valtype(res) == V_DATE)
         res = CheckIsRecord2("dcurdate_dbt", "t_curdate", "to_date('"+res+"','dd.mm.yyyy')","t_branch", string({operdprt}) );
         if( ( res ) and (valtype(res)== V_BOOL))
            return true;
         end
      end;
      return false;
   end;

   /******** ввод нового опердня ********/
   private macro GetCurDate(Data, Closed)
      var sql;

      var res = false;
      var to_close = iif(((valtype(Closed)== V_BOOL)and(Closed==false)),"CHR(88)","CHR(0)");
      if( (  valtype(Data)==V_DATE) and
          (IsCurDate(Data)==false )   )
         /*BEA Тема 385226*/
         sql =       trims("INSERT INTO dcurdate_dbt (T_CURDATE,                                                  ");
         sql = sql + trims("                          T_POINT,                                                    ");
         sql = sql + trims("                          T_BRANCH,                                                   ");
         sql = sql + trims("                          T_MINPHASE,                                                 ");
         sql = sql + trims("                          T_MAXPHASE,                                                 ");                                                    
         sql = sql + trims("                          T_ISCLOSED,                                                 ");
         sql = sql + trims("                          T_ISBALANCE,                                                ");
         sql = sql + trims("                          T_ISMAIN)                                                   ");
         sql = sql + trims("     VALUES ( TO_DATE ('"+Data+"', 'dd.mm.yyyy'), 0,"+{OperDprt}+", 1, 1, "+to_close+", CHR(88), CHR(0));");
         /****************/
         _viewsql(FUCKINSHIT, sql);
         SQL_Execute(sql);
         res = true;
      end;
      return res;
   end;

   /******** получение кода страны ********/
   private macro GetCountry(Data)
     var res;
     if(valtype(Data) == V_STRING)
        res = CheckIsRecord1("DCOUNTRY_DBT", "t_codelat3", "'"+Data+"'", "t_codelat3");
        if( res != false)
           return res;
        end;
     end;
     return "";
   end;

   /******** Получение регистрационного документа для юр.лица ********/
   private macro GetRegDoc(Data, _field);
      var res = Data;
      var field;
      if(valtype(_field) != V_STRING )
         field = "T_REGDOCKIND";
      else
         field = _field;
      end;

      res = CheckIsRecord2("DOBJKDOC_DBT","T_SHORTNAME","'"+res+"'","T_OBJECTTYPE", "3", field);
      if((res == false) and (valtype(res)== V_BOOL))
         res = "";
      end;
      return res;
   end;

   /******** Получить номера значения категории по его имени ********/
   private macro GetAttrNum(ObjType, AttrID, Name)
      var res;
      var sql, rs;                                                         
      res = CheckIsRecord3("dobjattr_dbt", "t_objecttype",string(ObjType),"t_groupid",string(AttrID),"t_name","'"+Name+"'","t_numinlist");
      return res;
   end;

   /********  Установить значение категории для субъекта экономики ********/
  Private  macro SetCateg(ObjType, id:integer, CatNum:integer, value, isnumber)
      var stat, res, ret;

      if  (   (valtype(value) == V_INTEGER)     or
            ( (valtype(value) == V_STRING ) and 
              ( isnumber                  )   )  )
         stat = ConnectObjAttr (ret, ObjType, string(id:o:10), CatNum, 0, "", string(value), date(0,0,0));

/*             ConnectObjAttr( ret, ObjType,
                                string(id:o:10),
                                CatNum,
                                INT(value));
*/
      elif(valtype(value) == V_STRING)
         res = GetAttrNum(ObjType, CatNum, trim(value));
         if(res != false)   // если нашли значение категории в справочнике
            stat = ConnectObjAttr (ret, ObjType, string(id:o:10), CatNum, 0, "", string(res), date(0,0,0));
         else 
            return res;
         end;

      end;
      return stat;
   end;

   /******** получение референса, не существующего в таблице table в поле field: недублирование ********/
   private macro GenRef(refID, table, field)
      var res;
      var stat;
      GenerateReference(refID, res);
      if ( (valtype(table) == V_STRING) and
           (valtype(field) == V_STRING)   )
         while (CheckIsRecord1(table, field, "'"+res+"'"))
            GenerateReference(refID, res);
         end;
      end;
      return res;
   end;

   /******** получение кода ISO для фининструмента по коду FIID ********/
   private macro GetCurrencyByCode (Code)
      var res;
      res = CheckIsRecord1("DFININSTR_DBT","T_FIID","'"+Code+"'","T_ISO_NUMBER");
      if((res = false) and (valtype(res)== V_BOOL))
         res = "!!!";
      end;
   end;

   /******** получение кода ISO для фининструмента по коду FI_CODE ********/
   private macro GetFIIDByCurrency (Currency)
      var res;
      res = CheckIsRecord1("DFININSTR_DBT","T_FI_CODE","'"+Currency+"'","T_FIID");
      if((res = false) and (valtype(res)== V_BOOL))
         res = "!!!";
      end;
   end;

   /******** нахождение балансового счета в списке балансовых ********/
   private macro FindBalance(Balance)
      var res;
      res = CheckIsRecord1("dbalance_dbt","t_balance","'"+Balance+"'");
      return res;
   end;

   /******** Получить код валюты для счета ********/
   private macro GetFiidForAccount(Account, Chapter)
      var sql, rs;
      var res;

      if ((valtype(Chapter) == V_STRING ) or
          (valtype(Chapter) == V_INTEGER)  )
         res = CheckIsRecord2("daccounts_view","t_account","'"+Account+"'","t_chapter",string(Chapter),"t_code_currency");
      else
         res = CheckIsRecord1("daccounts_view","t_account","'"+Account+"'","t_code_currency");
      end;
      if ((res == false) and (valtype(res)== V_BOOL))
         res = -1;
      end;
      return res;
   end;

   /******** Явлеятся ли субъект клиентом такого-то вида обслуживания ********/
   private macro IsClientService(Client:string, ServiceKind:string, Department)
      var res;
      if(valtype(Department)!=V_UNDEF)
         res = CheckIsRecord3("DCLIENT_DBT","T_PARTYID","'"+Client+"'","T_SERVICEKIND",ServiceKind,"T_DEPARTMENT",string(Department));
      else
         res = CheckIsRecord2("DCLIENT_DBT","T_PARTYID","'"+Client+"'","T_SERVICEKIND",ServiceKind);
      end;
      return res;
   end;

   /******** ПолучитьIDКлиента ********/
   private macro GetClientByCode(Codekind, codeValue)
      var res;
      res = CheckIsRecord3("dobjcode_dbt","t_objecttype","3","t_codekind","'"+CodeKind+"'","t_code","'"+trim(string(codeValue))+"'","t_objectid");
      if((res == false) and (valtype(res)== V_BOOL))
         res = "";
      end;
      return res;
   end;

   /******** ПолучитьКодКлиентаПоID ********/
   private macro GetClientCodeByID(id, Codekind)
      var res;
      res = CheckIsRecord3("dobjcode_dbt","t_objecttype","3","t_codekind","'"+CodeKind+"'","t_objectid",string(id),"t_code");
      if((res == false) and (valtype(res)== V_BOOL))
         res = "";
      end;
      return res;
   end;

   /******** Получить id объекта по тексту примечания ********/
   private macro GetObjectIdByNoteText(ObjectType, NoteKind, NoteText)
      var sql;
      var rs;
      sql =       "SELECT txt.t_documentid                  ";                                            
      sql = sql + "  FROM dnotetext_dbt txt                 ";                                            
      sql = sql + " WHERE txt.t_objecttype = "+ObjectType+" ";                                            
      sql = sql + " and txt.t_noteKind = "+NoteKind+"       ";                                            
      sql = sql + " and instr(replace(UTL_RAW.cast_to_varchar2 (txt.t_text), chr (0), null ),'"+NoteText+"') != 0;";
      _viewsql(FUCKINSHIT, sql);
      rs = RsdRecordSet(sql);
      if  (rs.movenext())
         return rs.value(0);
      else
         return -1;
      end;
   end;

/****************************************************************/
/** ПРЕОБРАЗОВАНИЕ СОДЕРЖИМОГО                                 **/
/****************************************************************/

// ECLT
   private macro LeadToTypeECLT (Data, Fieldname, Neces, Param1, Param2)
      var res = GetClientByCode(/*APHENA*/PORTFCODENote, Data);

      if(Data == OUR_BANK_CODE)  // если наш банк, возвращаем себя
         return {selfid};
      end;
// !!!!!!!!!!!!

       return Data;


      if(valType(res) != V_INTEGER)  // если нашли клиента с таким кодом в Афине
         Err.Add("!("+trim(Fieldname)+")Не найден клиент с кодом в \"Kondor+\": "+Data, Neces);
         if(valtype(Param1)!=V_UNDEF)
            res = Param1;
         else
            res = Data;
         end;
      end;
      return res;
   end;

// NCLT
   private macro LeadToTypeNCLT (Data, Fieldname, Neces, Param1, Param2)
      var res = Data;
      var PartyID = ПолучитьКодСубъекта(res, /*APHENA*/PORTFCODENote);
      var Party;
      if(Data == OUR_BANK_CODE)  // если наш банк, возвращаем себя
         return {selfid};
      end;
      if((valType(PartyID) == V_INTEGER)  ) // если нашли клиента с таким кодом в Афине
         Party = RSBParty(PartyID);
//         if ( Party.Fullname==Param2    ) 
            res = partyID;
/*         else
            // если ничего не указано, судю придет undefined aka NULL, что нам и понадобится
            res = Param1;
            Err.Add("!("+trim(Fieldname)+")Найден дубль клиента с кодом в \"АБС 21 век\": "+Data, Neces);
         end;
*/
      end;                                             
      return res;
   end;

// STRG
   private macro LeadToTypeSTRG (Data, Fieldname, Neces, Param1, Param2)
      var res = Data;

      If(Fieldname == "CODEACC")
         If(strlen(res) > 7)
             Err.Add("!("+trim(Fieldname)+")Слишком большая длина строки CODEACC : "+Data,Neces);
             res = "";
             return res;
         end;
      
      end;

      if ( (valType( Param2 )== V_INTEGER  ) and
           (strlen (res)       >  Param2   )   )  
         res = substr(res, 1, Param2);
         Err.Add("!("+trim(Fieldname)+")Слишком большая длина строки: "+Data,Neces);
      elif ( ( valtype(Param2  )         == V_TARRAY ) and
             ( FindInArray(res, Param2 ) == -1       )   )
         if (valtype(Param1) == V_STRING)
            res = Param1;
         else
            res = "";
         end;
//         Err.Add("!("+trim(Fieldname)+")Строка имеет неподходящее значение: "+Data,Neces);
      end;
// ИМЕННО ЗДЕСЬ ПРОИСХОДИТ ЗАМЕНА СИМВОЛА "'" на "''"
      res = StrSubst(res,"'","''");
      return res;
   end;

// BL
   private macro LeadToTypeBL (Data, Fieldname, Neces, Param1)
      var res = StrUpr(Data);
      if  ((res  == "1"    ) or
           (res  == "+"    ) or
           (res  == "Д"    ) or
           (res  == "ДА"   ) or
           (res  == "ДA"   ) or
           (res  == "Y"    ) or
           (res  == "YES"  ) or
           (res  == "TRUE" )  )
         res = true;
      elif(
           (res  == ""     ) or // закроем на всякий случай
           (res  == "0"    ) or
           (res  == "-"    ) or
           (res  == "Н"    ) or
           (res  == "НЕТ"  ) or
           (res  == "N"    ) or
           (res  == "NO"   ) or
           (res  == "FALSE")  )
         res = false;
      else
         Err.Add("!(" + trim(Fieldname) + ")Некорректное значение флага: "+Data, Neces);

         if (valtype(Param1)!= V_BOOL)
            res = false;
         else
            res = Param1;
         end;
      end;
      return res;
   end;

// DT

// Param2 == true  => изголяемся и проверяем на опердни и чтобы не превышало
// Param2 == false => дата не должна быть меньше текущей
// Param2 <> BOOL  => дата просто должна быть в нужном формате
   private macro LeadToTypeDT(Data, Fieldname, Neces, Param1, Param2)

      var res = Data, dd, mm, yyyy;
      if(SplitDateSimple(res,dd,mm,yyyy) and CheckDate(dd,mm,yyyy))
         res = Date(dd,mm,yyyy);

         // если доп. параметр указан, то считаем, нужна дополнительная проверка
         if  (valtype(Param2) != V_UNDEF)
            // дата должна быть меньше текущей, иначе нам было бы все равно
            if  (res <= {curdate})
               // если при этом  нам нужен открытый опердень, то проверим наличие и при необходимости откроем.
               if  ( (     Param2 == true  ) and 
                     ( not IsCurDate(res)  )
                     )
                  If(not GetCurDate(res) )   
                  
                  Err.Add("!(" + trim(Fieldname) + ")Дата "+res+" не может быть введена в открытые опердни",Neces);
                  
                  end;

                  if(valtype(Param1) == V_DATE)
                     res = Param1;
                  else
                     res = Data;
                  end;
               end;
            else
               Err.Add("!(" + trim(Fieldname) + ")Дата "+res+" больше текущей",Neces);
               if(valtype(Param1) == V_DATE)
                  res = Param1;
               else
                  res = Data;
               end;
            end;
         end;
      // если ошибка, и такой даты быть не может
      else
         if(valtype(Param1) == V_DATE)
            Err.Add("!(" + trim(Fieldname) + ")Некорректное значение даты: "+Data+ ". Используется значение по умолчанию: "+string(Param1), Neces);
            res = Param1;
         else
            Err.Add("!(" + trim(Fieldname) + ")Некорректное значение даты: "+Data, Neces);
            res = Data;
         end;
      end;
      return res;
   end;

// DTLS 
   private macro LeadToTypeDTLS(Data, Fieldname, Neces, Param1, Param2)
      var res = Data, dd, mm, yyyy;
      if(SplitDate(res,dd,mm,yyyy, "/") and CheckDate(dd,mm,yyyy))
         res = Date(dd,mm,yyyy);

         // если доп. параметр указан, то считаем, нужна дополнительная проверка
         if  (valtype(Param2) != V_UNDEF)
            // дата должна быть меньше текущей, иначе нам было бы все равно
            if  (res <= {curdate})
               // если при этом  нам нужен открытый опердень, то проверим наличие и при необходимости откроем.
               if  ( (     Param2 == true  ) and 
                     ( not IsCurDate(res)  ) and
                     (     GetCurDate(res) )   )
                     // такой хитроумной конструкцией постепенно проверяем наличие открытых опердней, и если не смогли открыть неоткрытые, выдаем ошибку
                  Err.Add("!(" + trim(Fieldname) + ")Дата "+res+" не может быть введена в открытые опердни",Neces);
                  if(valtype(Param1) == V_DATE)
                     res = Param1;
                  else
                     res = Data;
                  end;
               end;
            else
               Err.Add("!(" + trim(Fieldname) + ")Дата "+res+" больше текущей",Neces);
               if(valtype(Param1) == V_DATE)
                  res = Param1;
               else
                  res = Data;
               end;
            end;
         end;
      // если ошибка, и такой даты быть не может
      else
         if(valtype(Param1) == V_DATE)
            Err.Add("!(" + trim(Fieldname) + ")Некорректное значение даты: "+Data+ ". Используется значение по умолчанию: "+string(Param1), Neces);
            res = Param1;
         else
            Err.Add("!(" + trim(Fieldname) + ")Некорректное значение даты: "+Data, Neces);
            res = Data;
         end;
      end;
      return res;
   end;

// DTD
   private macro LeadToTypeDTD(Data, Fieldname, Neces, Param1, Param2)
      var res = Data, dd, mm, yyyy;
      // если это дата, то либо это date (0,0,0), либо это дата, попадающая в опердни

      if( (SplitDate(res,dd,mm,yyyy, ".") OR (SplitDate(res,dd,mm,yyyy, "/") )) and CheckDate(dd,mm,yyyy))
         res = Date(dd,mm,yyyy);

         // если доп. параметр указан, то считаем, нужна дополнительная проверка
         if  (valtype(Param2) != V_UNDEF)
            // дата должна быть меньше текущей, иначе нам было бы все равно
            if  (res <= {curdate})
               // если при этом  нам нужен открытый опердень, то проверим наличие и при необходимости откроем.
               if  ( (     Param2 == true  ) and 
                     ( not IsCurDate(res)  ) 
                     )
                  If(not GetCurDate(res) )   
                  
                     Err.Add("!(" + trim(Fieldname) + ")Дата "+res+" не может быть введена в открытые опердни",Neces);
                  
                  end;

                  if(valtype(Param1) == V_DATE)
                     res = Param1;
                  else
                     res = Data;
                  end;
               end;
            else
               Err.Add("!(" + trim(Fieldname) + ")Дата "+res+" больше текущей",Neces);
               if(valtype(Param1) == V_DATE)
                  res = Param1;
               else
                  res = Data;
               end;
            end;
         end;
      // если ошибка, и такой даты быть не может
      else
         if(valtype(Param1) == V_DATE)
//            Err.Add("!(" + trim(Fieldname) + ")Некорректное значение даты: "+Data+ ". Используется значение по умолчанию: "+string(Param1), Neces);
            res = Param1;
         else
            Err.Add("!(" + trim(Fieldname) + ")Некорректное значение даты: "+Data, Neces);
            res = Data;
         end;
      end;
      return res;
   end;

// TM
   private macro LeadToTypeTM  (Data, Fieldname, Neces, Param1, Param2)
      var res = Data, hh, mm, ss;
      if (SplitTimeSimple(res,hh,mm,ss) and checkTime(hh,mm,ss))
         res = time(hh,mm,ss);
      else
         if(valtype(Param1) == V_TIME)
            res = Param1;
         else
            res = time(0,0,0);
         end;
         Err.Add("!(" + trim(Fieldname) + ")Некорректное значение времени: "+Data, Neces);
      end;
      return res;
   end;

// DTP
   private macro LeadToTypeDTP (Data, Fieldname, Neces, Param1)
      var res = Data;
      if (IsDigital(res))
         res = CheckIsRecord1("DPAPRKIND_DBT", "t_paperkind", string(res), "t_paperkind");
         if(( res == false) and (valtype(res)== V_BOOL))
            Err.Add("!("+trim(Fieldname)+")Отстутствует тип документа: "+Data, Neces);
         end;
      elif ( (strupr(res) == "НЕТ") or (res == "") )
         res = "";                                               
      else
         Err.Add("!("+trim(Fieldname)+")Некорректное значение типа документа: "+Data, Neces);
         if(valtype(Param1)!= V_UNDEF)
            res = CheckIsRecord1("DPAPRKIND_DBT", "t_paperkind", string(Param1), "t_paperkind");
            if((res == false) and (valtype(res)== V_BOOL))
               res = "0";
            end;
         else
            res = "0";
         end;
      end;
      return res;
   end;

// DTPN - наименование документа физика
   private macro LeadToTypeDTPN (Data, Fieldname, Neces, Param1)
      var res = Data;
      if (IsDigital(res))
         res = CheckIsRecord1("DPAPRKIND_DBT", "t_paperkind", string(res), "t_name");
         if((res == false) and (valtype(res)== V_BOOL))
            Err.Add("!("+trim(Fieldname)+")Отстутствует тип документа: "+Data, Neces);
         end;
      elif( (strupr(res) == "НЕТ") or (res == "") )
         res = "";
      else
         Err.Add("!("+trim(Fieldname)+")Некорректное значение типа документа: "+Data, Neces);
         if(valtype(Param1)!= V_UNDEF)
            res = string(Param1);
         else
            res = "0";
         end;
      end;
      return res;
   end;

// NMBR - число
   private macro LeadToTypeNMBR(Data, Fieldname, Neces, Param1, Param2)
      var res = Data;
      if( (   not IsDigital(res           )           ) or 
          ( ( valtype(Param2) == V_TARRAY       ) and
            ( FindInArray(res, Param2 ) == -1   )   ) or
          ( ( valtype(Param2) == V_INTEGER      ) and
            ( Param2          <  int(res)       )   )  )
         Err.Add("!("+trim(Fieldname)+")Некорректное число: "+Data, Neces);
         if(valtype(Param1) != V_UNDEF)
            res = Param1;
         else
            res = "";
         end;
      end;
      return res;
   end;

// SX
   private macro LeadToTypeSX (Data, Fieldname, Neces)
      var res = StrUpr(Data);
      if ( (CharNum(res,"M" ) !=0 ) or (CharNum(res,"M" ) !=0))             // мужской
        res     = true;
      else                                    // женский
        res     = false;
      end;
      return res;
   end;

// QUAL
   private macro LeadToTypeQUAL (Data, Fieldname, Neces, Param1)
      var res = StrUpr(Data);
      if  ((res == "1") or
           (res == "I")  )
         res = 1;
      elif((res == "2") or
           (res == "II")  )
         res = 2;          
      elif((res == "3") or
           (res == "III")  )
         res = 3;          
      elif((res == "4") or
           (res == "IV")  )
         res = 4;          
      elif((res == "5") or
           (res == "V")  )
         res = 5;          
      else
         res = Param1;
//         Err.Add("!("+trim(Fieldname)+")Некорректное значение категории качества: "+Data, Neces);
      end;
      return res;
   end;

// CTRY
   private macro LeadToTypeCTRY (Data, Fieldname, Neces, Param1)
      var res = Data, sql, rs;

      if ((ValType(res)== V_STRING) and
          (strlen (res)== 3       )   )
         res = GetCountry(res);
         if  ( res == "" )
            res = GetCountry(Param1);
            Err.Add("!("+trim(Fieldname)+")Страна ("+Data+") не найдена",Neces);
            if(res == "")
               res = "RUS";
            end;
         end;
      else
//         Err.Add("!("+trim(Fieldname)+")Страна ("+Data+") не найдена",Neces);
         res = GetCountry(Param1);
         if( res == "")
            res = "RUS";
         end;
      end;
      return res;
   end;

// RDTP
   private macro LeadToTypeRDTP (Data, Fieldname, Neces, Param1);
      var res = Data;
      res = GetRegDoc(res, "T_REGDOCKIND");

      if (res == "")
         Err.Add("!("+trim(Fieldname)+")Некорректное указание типа регистрационного документа: "+Data,Neces);
         if(valtype(Param1)!=V_UNDEF)
            res = GetRegDoc(Param1, "T_REGDOCKIND");
         end;
      end;
      return res;
   end;

// RDTPN
   private macro LeadToTypeRDTPN (Data, Fieldname, Neces, Param1);
      var res = Data;
      res = GetRegDoc(res, "T_NAME");

      if (res == "")
         Err.Add("!("+trim(Fieldname)+")Некорректное указание типа регистрационного документа: "+Data,Neces);
         if(valtype(Param1)!=V_UNDEF)

            res = GetRegDoc(Param1, "T_NAME");
         end;
      end;
      return res;
   end;

// RDORG
   private macro LeadToTypeRDORG (Data, Fieldname, Neces, Param1);
      var res = Data;

      res = CheckIsRecord1("DOBJKRGPT_DBT", "T_SHORTNAME", "'"+res+"'","T_REGPARTYKIND");
      if ((res == false) and (valtype(res)== V_BOOL))
      else
         Err.Add("!("+trim(Fieldname)+")Некорректное указание типа регистрирующего органа: "+Data,Neces);
         if(valtype(Param1)!=V_UNDEF)
            res = CheckIsRecord1("DOBJKRGPT_DBT", "T_SHORTNAME", "'"+Param1+"'","T_REGPARTYKIND");
         end;
      end;
      return res;
   end;

// NAVRS
   private macro LeadToTypeNAVRS (Data, Fieldname, Neces);
      var res = Data;
      res = CheckIsRecord1("dfininstr_dbt", "t_fi_code", "'"+res+"'");
      if((res != false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Найден дубль ценной бумаги с таким кодом вида 1: "+Data, Neces);
      else
         res = Data;
//      res = CheckIsRecord1("dfininstr_dbt", "t_fi_code", "'"+res+"'");
                  res = CheckIsRecord3("dobjcode_dbt"  , 
                                 "t_code"    ,
                                 "'" + string(res) + "'"    ,
                                 "T_OBJECTTYPE"  ,
                                 "9"             ,
                                 "T_CODEKIND"    ,
                                 string(AVRCODE5));

      if((res != false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Найден дубль ценной бумаги с таким кодом вида 102: "+Data, Neces);
      end;
      end;
      res = Data;
      return res;
   end;

// EAVRS
   private macro LeadToTypeEAVRS (Data, Fieldname, Neces);
      var res = Data;
      var sql,cmd;
//      res = CheckIsRecord1("dfininstr_dbt","t_fi_code","'"+res+"'","t_fiid");
      sql = "SELECT T_FI_CODE, T_FIID from DFININSTR_DBT WHERE UPPER(T_FI_CODE) = UPPER('" + res + "')";
      cmd = TrsbDataSet(sql);

      if(cmd.movenext())
         res = cmd.fiid;
      else
         Err.Add("!("+trim(Fieldname)+")Не найдена ценная бумага с кодом : "+Data, Neces);
      end;
//      res = Data;
      return res;
   end;

// EAVRS102 POPOV
   private macro LeadToTypeEAVRS102 (Data, Fieldname, Neces);
      var res = Data;

      res = CheckIsRecord1("dobjcode_dbt", "upper(t_code)","'"+res+"' and t_objecttype = 9 and t_state = 0 and t_codekind = 102", "t_objectid");

      if((res == false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Не найдена ценная бумага с кодом вида 102: "+Data, Neces);
      end;
//      res = Data;
      return res;
   end;

// AVKD
   private macro LeadToTypeAVKD (Data, Fieldname, Neces);
      var res = Data;
      res = CheckIsRecord1("davrkinds_dbt","t_numlist"," '"+res+"'","t_avoirkind");
      if((res == false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Некорректно указан тип ценной бумаги: "+Data, Neces);
      end;
      return res;
   end;

// AVKDB
   private macro LeadToTypeAVKDB (Data, Fieldname, Neces, Param1);
      var res = Data;
      res = CheckIsRecord1("davrkinds_dbt","t_numlist"," '"+res+"'","t_root");
      if((res == false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Некорректно указан тип ценной бумаги: "+Data, Neces);
      end;
      return res;
   end;

// QUANT
   private macro LeadToTypeQUANT(Data, Fieldname, Neces, Param1, Param2)
      var res = Data;

      if( (   not IsQuantity(res)                       ) or 
          ( ( valtype(Param2) == V_INTEGER            ) and
            ( Param2          <  int(res)*Signum(res) )   )   )
         Err.Add("!("+trim(Fieldname)+")Некорректное количество: "+Data, Neces);
         if(IsQuantity(Param1))
            res = Param1;
         else
            res = 0;
         end;
      end;
      return res;
   end;

// CUR

   private macro LeadToTypeCUR   (Data, Fieldname, Neces, Param1);
      var res = Data;

      res = CheckIsRecord1 ("DFININSTR_DBT","T_FI_CODE","'"+Res+"'","t_fiid");
      if((res == false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Не найдена валюта с кодом: "+Data, Neces);
         if(valtype(Param1) != V_UNDEF)
            res = CheckIsRecord1 ("DFININSTR_DBT","T_FI_CODE","'"+Param1+"'","t_fiid");
            if((res == false) and (valtype(res)== V_BOOL))
               res = 0;
            else
               res = Param1;
            end;
         end;
      end;
      return res;
   end;

// DBL
   private macro LeadToTypeDBL   (Data, Fieldname, Neces, Param1);
      var res = Data;
     IF(FieldName == "COST")
         If(res == "")
//             Err.Add("!("+trim(Fieldname)+")Сумма некорректна: "+Data, Neces);
             res = 0;
             return res;
         else
           res = StrSubst (res, ",", ".");
           return res;

         end;
      END;

      if(not IsDouble(res))
         Err.Add("!("+trim(Fieldname)+")Сумма некорректна: "+Data, Neces);
         if(not IsDouble(Param1))
            res = "0.0";
         else
            res = Param1;
         end;
      end;
      res = StrSubst (res, ",", ".");
      return res;
   end;

// NBACN
   private macro LeadToTypeNBACN (Data, Fieldname, Neces, Param2)
      var res = Data;
      var temp = Param2;

      if(valtype(temp) == V_UNDEF)
         temp = 1;
      end;
      if(CheckIsRecord2("daccounts_view","T_Account","'"+res+"'","t_chapter",temp))
         res = Data;
         Err.Add("!("+trim(Fieldname)+")Счет c таким номером уже существует: "+Data, Neces);
      end;
      return res;
   end;

// EBACN
   private macro LeadToTypeEBACN (Data, Fieldname, Neces, Param2)
      var res = Data;

      if(valtype(Param2) != V_UNDEF)
         res = CheckIsRecord2("daccounts_view","T_Account","'"+res+"'","t_chapter",Param2, "T_Account");
      else
         res = CheckIsRecord1("daccounts_view","T_Account","'"+res+"'", "T_Account");
      end;
      if ((res == false) and (valtype(res)== V_BOOL))
         res = Data;
         Err.Add("!("+trim(Fieldname)+")Счет не найден: "+Data, Neces);
      end;

      return res;
   end;

// NDACN
   private macro LeadToTypeNDACN (Data, Fieldname, Neces)
      var res = Data;
      res = CheckIsRecord1("ddepoacnt_dbt", "t_code", "'"+res+"'");
      if ((res == false) and (valtype(res)== V_BOOL))
         res = Data;
      else
         Err.Add("!("+trim(Fieldname)+")Существует счет/раздел депо с номером: "+Data,true);
      end;
      res = Data;
      return res;
   end;

// EDACN
   private macro LeadToTypeEDACN (Data, Fieldname, Neces)
      var res = Data;
      res = CheckIsRecord1("ddepoacnt_dbt","t_code","'"+res+"'", "T_code");
      if((res == false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Счет/раздел депо не найден: "+Data, Neces);
      end;
      res = Data;
      return res;
   end;

// EDACNS
   private macro LeadToTypeEDACNS(Data, Fieldname, Neces, Param1, Param2)
      var res = Data;
      res = CheckIsRecord1("ddepoacnt_dbt","T_BRIEFCODE","'"+res+"'", "T_BRIEFCODE");
      if((res == false) and (valtype(res)== V_BOOL))
         Err.Add("!("+trim(Fieldname)+")Счет/раздел депо не найден: "+Data, Neces);
      end;
      res = Data;
      return res;
   end;

/*********************************************************************/
/****** ФУНКЦИЯ ПРИВЕДЕНИЯ К ФОРМАТУ С ВЫЧЛЕНЕНИЕМ ОШИБКИ В НЕМ ******/
/*********************************************************************/

   private macro LeadToType (Data, Fieldname, Valtyp, Neces, Param1, Param2 )
      var dd, mm, yyyy, sql, rs;
      var res;

/*СУЩЕСТВУЮЩИЙ КЛИЕНТ ПО КОДУ В АФИНЕ*/
      if   ( Valtyp == ECLT)
         res = LeadToTypeECLT  (Data, Fieldname, Neces, Param1, Param2);
      
      elif ( Valtyp == NCLT)                    
         res = LeadToTypeNCLT  (Data, Fieldname, Neces, Param1, Param2);
/*СТРОКА*/
      elif ( Valtyp == STRG )
         res = LeadToTypeSTRG  (Data, Fieldname, Neces, Param1, Param2);
/*БУЛЕВА ПЕРЕМЕННАЯ*/
      elif ( Valtyp == BL  )
         res = LeadToTypeBL    (Data, Fieldname, Neces, Param1, Param2);
/*ДАТА*/
      elif ( Valtyp == DT )
         res = LeadToTypeDT    (Data, Fieldname, Neces, Param1, Param2);
/*ДАТА ЧЕРЕЗ СЛЭШ*/
      elif ( Valtyp == DTLS)
         res = LeadToTypeDTLS  (Data, Fieldname, Neces, Param1, Param2);
/*ДАТА ЧЕРЕЗ ТОЧКУ*/
      elif ( Valtyp == DTD)
         res = LeadToTypeDTD   (Data, Fieldname, Neces, Param1, Param2);
/*ВРЕМЯ*/
      elif ( Valtyp == TM )
         res = LeadToTypeTM    (Data, Fieldname, Neces, Param1, Param2);
/*ТИП ДОКУМЕНТА*/
      elif ( Valtyp == DTP ) 
         res = LeadToTypeDTP   (Data, Fieldname, Neces, Param1);
/*НАЗВАНИЕ ДОКУМЕНТА*/
      elif ( Valtyp == DTPN)
         res = LeadToTypeDTPN  (Data, Fieldname, Neces, Param1);
/*ЧИСЛО*/
      elif ( Valtyp == NMBR )
         res = LeadToTypeNMBR  (Data, Fieldname, Neces, Param1, Param2);
/*ПОЛ*/
      elif ( Valtyp == SX  )                   // определяя пол, ошибки быть не может
         res = LeadToTypeSX    (Data, Fieldname, Neces, Param1, Param2);
/*КАТЕГОРИЯ КАЧЕСТВА*/
      elif ( Valtyp == QUAL )
         res = LeadToTypeQUAL  (Data, Fieldname, Neces, Param1, Param2);
/*СТРАНА*/
      elif ( Valtyp == CTRY )
         res = LeadToTypeCTRY  (Data, Fieldname, Neces, Param1, Param2);
/*ВИД РЕГИСТРИРУЮЩЕГО ДОКУМЕНТА*/
      elif ( Valtyp == RDTP )
         res = LeadToTypeRDTP  (Data, Fieldname, Neces, Param1, Param2);                
/*НАИМЕНОВАНИЕ ВИДА РЕГИСТРИРУЮЩЕГО ДОКУМЕНТА*/
      elif ( Valtyp == RDTPN)
         res = LeadToTypeRDTPN (Data, Fieldname, Neces, Param1, Param2);                
/*ВИД РЕГИСТРИРУЮЩЕГО ОРГАНА*/
      elif ( Valtyp == RDORG )
         res = LeadToTypeRDORG (Data, Fieldname, Neces, Param1, Param2);
/*НОВАЯ ЦЕННАЯ БУМАГА*/
      elif(Valtyp == NAVRS)
         res = LeadToTypeNAVRS (Data, Fieldname, Neces, Param1, Param2);
/*СУЩЕСТВУЮЩАЯ ЦЕННАЯ БУМАГА*/
      elif(Valtyp == EAVRS)
         res = LeadToTypeEAVRS (Data, Fieldname, Neces, Param1, Param2);
/*СУЩЕСТВУЮЩАЯ ЦЕННАЯ БУМАГА с кодом 102*/
      elif(Valtyp == EAVRS102)
         res = LeadToTypeEAVRS102 (Data, Fieldname, Neces, Param1, Param2);
/*ТИП ЦЕННОЙ БУМАГИ*/
      elif(Valtyp == AVKD)
         res = LeadToTypeAVKD  (Data, Fieldname, Neces, Param1, Param2);
/*БАЗОВЫЙ ТИП ЦЕННОЙ БУМАГИ*/
      elif(Valtyp == AVKDB)
         res = LeadToTypeAVKDB (Data, Fieldname, Neces, Param1, Param2);
/*КОЛИЧЕСТВО*/
      elif(Valtyp == QUANT)
         res = LeadToTypeQUANT (Data, Fieldname, Neces, Param1, Param2);
/*ВАЛЮТА*/
      elif(Valtyp == CUR)
         res = LeadToTypeCUR   (Data, Fieldname, Neces, Param1, Param2);
/*ДЕНЬГИ*/
      elif(Valtyp == DBL)
         res = LeadToTypeDBL   (Data, Fieldname, Neces, Param1, Param2);
/*СУЩЕСТВУЮЩИЙ БАЛАНСОВЫЙ СЧЕТ*/
      elif(Valtyp == NBACN)
         res = LeadToTypeNBACN (Data, Fieldname, Neces, Param2);
/*СУЩЕСТВУЮЩИЙ БАЛАНСОВЫЙ СЧЕТ*/
      elif(Valtyp == EBACN)
         res = LeadToTypeEBACN (Data, Fieldname, Neces, Param2);
/*СУЩЕСТВУЮЩИЙ СЧЕТ ДЕПО*/
      elif(Valtyp == NDACN)
         res = LeadToTypeNDACN (Data, Fieldname, Neces, Param1, Param2);
      elif(Valtyp == EDACN)
         res = LeadToTypeEDACN (Data, Fieldname, Neces, Param1, Param2);
      elif(Valtyp == EDACNS)
         res = LeadToTypeEDACNS(Data, Fieldname, Neces, Param1, Param2);
      else
         _msgbox("Не указан вид проверки!!!!");
      end;

      return res;
   end;

end;