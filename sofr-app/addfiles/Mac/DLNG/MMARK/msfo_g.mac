/*
$Name:        msfo_g.mac
$Module:      МБ Кредиты
$Description: Проводки шага "Переформирование РВПС и РВП по сделкам, затронутым процедурами перехода, на МСФО"
*/

/*-------------------------------------------------------------------------
  Имя файла        : msfo_g.mac

  Описание         : Проводки шага "Переформирование РВПС и РВП по сделкам, затронутым процедурами перехода, на МСФО"

  Программист      : Горбачев Дмитрий

  Создан           : 20.11.2018
-------------------------------------------------------------------------*/
IMPORT FIInter, mmcateg, mmcarry, mmlb_j, mmcnst_j, mmlibr, mctplprm;

private const tdr_000000000000 = "Переходный фин. рез";

PRIVATE CLASS MM_RSRVPARM
   VAR
   Deal_fd     = NULL,
   ККС         = 0,
   ПР          = 0,
   
   // расчетная база, в валюте
   C_new       = 0,
   C_CHC_new   = 0,
   Cpc_new     = 0,
   Cpc_CHC_new = 0,
   Cpn_new     = 0,
   
   // пруденциальный резерв
   С_об        = 0,
   С_вал       = NATCUR,
   Rnew        = 0,
   Rold        = 0,
   R_CHC_new   = 0,
   R_CHC_old   = 0,
   Rpc_new     = 0,
   Rpc_old     = 0,
   Rpc_CHC_new = 0,
   Rpc_CHC_old = 0,
   Rpn_old     = 0,
   Rpn_new     = 0,

   // оценочный резерв
   Ra_new       = 0,
   Ra_old       = 0,
   Ra_CHC_new   = 0,
   Ra_CHC_old   = 0,
   Rapc_new     = 0,
   Rapc_old     = 0,
   Rapc_CHC_new = 0, 
   Rapc_CHC_old = 0, 
   Rapn_new     = 0,
   Rapn_old     = 0;
END;

PRIVATE CONST
    MM_RSRV_TYPE_MMDEAL = 3;

PRIVATE CONST
    AMORT_COST_LINEAR     = 0, /* Оцениваемые по амортизированной стоимости (линейный метод) */
    AMORT_COST_EPS        = 1, /* Оцениваемые по амортизированной стоимости (метод ЭПС) */
    FAIR_VAL_PROFIT_LOSS  = 2, /* Оцениваемые по справедливой стоимости через прибыль или убыток */
    FAIR_VAL_COMPR_INCOME = 3; /* Оцениваемые по справедливой стоимости через прочий совокупный доход */

PRIVATE VAR Currency = 0;

PRIVATE MACRO РанееСозданныйРезерв(TypeBase, Parm, LastDate, ResType)
   VAR
       ResLnk = TRsbDataSet("select t_reserveamount, t_reserveassesamount, t_reservedate " + 
                            "from ddlreslnk_dbt " +
                            "where t_parentid = " + Parm.Deal_fd.GetTick().DealID +
                            " and t_reservedate <= " + "'" + Date({curdate}) + "'" +
                            " and t_typebase = " + TypeBase +
                            " and t_ismanual = '0' " +
                            " order by T_RESERVEDATE DESC, T_ID DESC");

   IF (ResLnk.MoveNext())
       IF (ValType(LastDate) != V_UNDEF)
           LastDate = date(ResLnk.ReserveDate);
           SetParm(2, LastDate);
       END;

       IF (ResType == 1)
           RETURN ResLnk.ReserveAmount;
       ELIF (ResType == 2)
           RETURN ResLnk.ReserveAssesAmount;
       END;
   END;

   RETURN 0;
END;    

PRIVATE MACRO InConsolidGroup(Parm)
   var
     retVal = false, DateLastReserve1 = date(0,0,0),
     DateLastReserve2 = date(0,0,0), DateLastCategory = date(0,0,0);

   IF (GetAttrID(3, Parm.Deal_fd.GetTick().PartyID, 49, {curdate}, DateLastCategory) != 1)
       retVal = false;
   ELSE
       РанееСозданныйРезерв(1, Parm,  DateLastReserve1);
       РанееСозданныйРезерв(2, Parm,  DateLastReserve2);

       IF (DateLastReserve2 > DateLastReserve1)
           DateLastReserve1 = DateLastReserve2;
       END;

       IF ((DateLastCategory >= DateLastReserve1) AND (DateLastReserve1 != date(0,0,0)))
           retVal = false;
       ELSE
           retVal = true;
       END;
   END;

   RETURN retVal;
END;

PRIVATE MACRO ОпределитьРанееСозданныйРезерв(Parm)
   Parm.Rold        = РанееСозданныйРезерв(1, Parm, NULL, 1);
   Parm.R_CHC_old   = РанееСозданныйРезерв(2, Parm, NULL, 1);
   Parm.Rpc_old     = РанееСозданныйРезерв(3, Parm, NULL, 1);
   Parm.Rpc_CHC_old = РанееСозданныйРезерв(4, Parm, NULL, 1);
   Parm.Rpn_old     = РанееСозданныйРезерв(5, Parm, NULL, 1);

   SetParm(0, Parm);
END;

PRIVATE MACRO РасчетСуммыОбеспечения(Parm)
   VAR
       Ki = 0,
       Sum = 0,
       Ktcc = 0,
       Tcc_After = 0,
       RsbTccHist  = NULL,
       RsbSum      = NULL,
       RsbGrnt = TRsbDataSet("select decode(ord.t_SysTypes, 'Ц', fininstr.t_facevaluefi, fininstr.t_fiid) as faceFI, sec.* "
                             "from ddl_order_dbt ord, ddl_secur_dbt sec, dfininstr_dbt fininstr "
                             "where (ord.t_contractid = sec.t_generalcontract) "
                             "and(fininstr.t_fiid = sec.t_fiid) "
                             "and(sec.t_contractkind = " + DL_IBCDOC + ") "
                             "and(sec.t_contractid = " + Parm.Deal_fd.GetTick().DealID + ")");

   Parm.С_об = 0;

   WHILE (RsbGrnt.MoveNext())
      RsbTccHist = TRsbDataSet("select * from dhistorytcc_dbt hist where "
                                "(hist.t_DealID in (0, " + Parm.Deal_fd.GetTick().DealID + ")) "
                                "and(hist.t_ContractID = " + RsbGrnt.GeneralContract + ") "
                                "and(hist.t_SecurID in (0, " + RsbGrnt.NumSecInOrder + ") "
                                "and (hist.t_DateStep <= '" + Date({curdate}) + "'))"
                                "order by hist.t_DateStep desc, hist.t_ID desc");

      IF (RsbTccHist.MoveNext())
          Tcc_After = RsbTccHist.Tcc_After;

          IF ((RsbTccHist.DealID == 0) AND (RsbTccHist.SecurID == 0)) // учет по договору
              RsbSum = TRsbDataSet("select ord.t_Cost as Sum from ddl_order_dbt ord where ord.t_ContractID = " + RsbGrnt.GeneralContract);
              RsbSum.MoveNext();
              Ktcc = RsbSum.Sum;
          ELIF ((RsbTccHist.DealID > 0) AND (RsbTccHist.SecurID == 0))// учет по сделке
              RsbSum = TRsbDataSet("select grnt.t_Amount as Sum from ddl_grnt_dbt grnt where grnt.t_ContractID = " + RsbGrnt.GeneralContract +
                                   " and grnt.t_DealID = " + Parm.Deal_fd.GetTick().DealID);
              RsbSum.MoveNext();
              Ktcc = RsbSum.Sum;
          ELIF (((RsbTccHist.DealID == 0) AND (RsbTccHist.SecurID > 0))or // учет по ПЗ
                ((RsbTccHist.DealID > 0) AND (RsbTccHist.SecurID > 0)))
              Ktcc = RsbGrnt.Cost;
          END;

          Sum = Tcc_After * (RsbGrnt.Cost / Ktcc);
      ELSE
          Sum = RsbGrnt.Cost;
      END;


      IF (RsbGrnt.faceFI != NATCUR)
          ConvSum(Sum, Money(Sum), Date({curdate}), Int(RsbGrnt.faceFI), NATCUR);
      END;

      IF (RsbGrnt.QualityCategory == 1)
          Ki = 1; 
      ELIF (RsbGrnt.QualityCategory == 2)
          Ki = 0.5;
      ELSE
          Ki = 0;
      END;   

      Parm.С_вал = NATCUR;
      Parm.С_об = Parm.С_об + (Sum * Ki);
   END;

   SetParm(0, Parm);
END;

PRIVATE MACRO РасчетНовойСуммыРезерва(Parm)
   VAR
       ОД = 0,
       С_об = Parm.С_об,
       C_new = Parm.C_new, C_CHC_new = Parm.C_CHC_new,
       Cpc_new = Parm.Cpc_new, Cpc_CHC_new = Parm.Cpc_CHC_new, Cpn_new = Parm.Cpn_new;


   IF (Parm.Deal_fd.GetLeg().pfi != NATCUR)
       ConvSum(C_new,       Parm.C_new,       {curdate}, Parm.Deal_fd.GetLeg().pfi,NATCUR);
       ConvSum(C_CHC_new,   Parm.C_CHC_new,   {curdate}, Parm.Deal_fd.GetLeg().pfi,NATCUR);
       ConvSum(Cpc_new,     Parm.Cpc_new,     {curdate}, Parm.Deal_fd.GetLeg().pfi,NATCUR);
       ConvSum(Cpc_CHC_new, Parm.Cpc_CHC_new, {curdate}, Parm.Deal_fd.GetLeg().pfi,NATCUR);
       ConvSum(Cpn_new,     Parm.Cpc_CHC_new, {curdate}, Parm.Deal_fd.GetLeg().pfi,NATCUR);
   END;

   IF (Parm.Deal_fd.GetLeg().pfi != Parm.С_вал)
       ConvSum(С_об, С_об, {curdate}, Parm.С_вал, Parm.Deal_fd.GetLeg().pfi);
   END;

   ОД = C_new + C_CHC_new;
   IF ((С_об >= ОД)or(ОД == 0))
       Parm.Rnew        = 0;
       Parm.R_CHC_new   = 0;
   ELSE
       Parm.Rnew        = money(C_new       * (Parm.ПР/100) * (1 - С_об/ОД));
       Parm.R_CHC_new   = money(C_CHC_new   * (Parm.ПР/100) * (1 - С_об/ОД));
   END;

   IF ((С_об >=(Cpc_new+C_CHC_new + ОД))or((Cpc_new+C_CHC_new) == 0))
       Parm.Rpc_new = 0;
       Parm.Rpc_CHC_new = 0;
   ELSE
       Parm.Rpc_new = money(Cpc_new * (Parm.ПР/100) * (1 - Max(0, (С_об - ОД) ) )/(Cpc_new+C_CHC_new));
       Parm.Rpc_CHC_new = money(Cpc_CHC_new * (Parm.ПР/100) * (1 - Max(0, (С_об - ОД)))/(Cpc_new+C_CHC_new));
   END;

   IF ((С_об >= (Cpn_new + ОД + Cpc_new + C_CHC_new))or(Cpn_new == 0))
       Parm.Rpn_new = 0;
   ELSE
       Parm.Rpn_new = money(Cpn_new * (Parm.ПР/100) * (1 - Max(0, (С_об - (ОД + Cpc_new + C_CHC_new)))/Cpn_new));
   END;

   SetParm(0, Parm);

   RETURN 0;
END;

PRIVATE MACRO MM_CalcReserve(Parm)
   VAR DataSet    = NULL,
       party      = TBfile("party.dbt", "R", 0),
       check_date = date(0, 0, 0);

   DataSet = TRsbDataSet("select t_qualitycategory, t_reservepercent " +
                          " from ddlreslnk_dbt " +
                          " where (t_type = 3) and (t_parentid = " + Parm.Deal_fd.GetTick().DealID + ")" +
                          " and (t_childid = -1) " +
                          " and (t_lnkdate <= '"+ Date({curdate}) + "')" +
                          " order by t_lnkdate desc, t_id desc");

   IF (not DataSet.MoveNext) 
      PrintLn(Parm.Deal_fd.GetTick().DealCode, "Не заданы параметры резервирования в сделке");
      RETURN 1;
   END;

   Parm.ККС = DataSet.QualityCategory;
   Parm.ПР = DataSet.ReservePercent;

   ОпределитьРанееСозданныйРезерв(Parm);

   IF ((Parm.ПР == 0) AND (Parm.Rold == 0))
       PrintLn(Parm.Deal_fd.GetTick().DealCode, "Нулевой процент резерва в сделке");
       RETURN 1;
   END;

   РасчетСуммыОбеспечения(Parm);

   IF (РасчетНовойСуммыРезерва(Parm) != 0)
       RETURN 1;
   END;

   IF ((Parm.Rnew == Parm.Rold) AND (Parm.R_CHC_new == Parm.R_CHC_old)and
       (Parm.Rpc_new == Parm.Rpc_old) AND (Parm.Rpc_CHC_new == Parm.Rpc_CHC_old) AND (Parm.Rpn_new == Parm.Rpn_old))
       RETURN 1;
   END;

   SetParm(0, Parm);

   RETURN 0;
END;

PRIVATE MACRO ПолучитьРасчетнуюБазу(Parm)
   VAR penny_ODR, penny_percR;

   ПолучитьОстатокСчета(Parm.Deal_fd, tdr_mainrest,    NULL, 1, Parm.C_new,       {curdate}, Parm.Deal_fd.GetLeg().pfi);
   ПолучитьОстатокСчета(Parm.Deal_fd, tdr_exprestR,    NULL, 1, Parm.C_CHC_new,   {curdate}, Parm.Deal_fd.GetLeg().pfi);
   ПолучитьОстатокСчета(Parm.Deal_fd, tdr_claimR,      NULL, 1, Parm.Cpc_new,     {curdate}, Parm.Deal_fd.GetLeg().pfi);
   ПолучитьОстатокСчета(Parm.Deal_fd, tdr_exppercR,    NULL, 1, Parm.Cpc_CHC_new, {curdate}, Parm.Deal_fd.GetLeg().pfi);
   ПолучитьОстатокСчета(Parm.Deal_fd, tdr_penny_ODR,   NULL, 1, penny_ODR,        {curdate}, Parm.Deal_fd.GetLeg().pfi);
   ПолучитьОстатокСчета(Parm.Deal_fd, tdr_penny_percR, NULL, 1, penny_percR,      {curdate}, Parm.Deal_fd.GetLeg().pfi);
   Parm.Cpn_new = penny_ODR + penny_percR;
END;

PRIVATE MACRO Проводка(Parm,
   КатегорияДебет, СчДебет, КатегорияКредит, СчКредит,
   Глава, Сумма, Основание, ExecDate,
   ВалДебет, ВалКредит)

   var at = MM_Carry;

   MM_ByDefault(ВалДебет,  Currency);
   MM_ByDefault(ВалКредит, Currency);

   at.date_carry         = ExecDate;
   at.PrimaryDoc         = Parm.Deal_fd;
   at.AccountPayer       = СчДебет;
   at.AccountReceiver    = СчКредит;
   at.CatPayer           = КатегорияДебет;
   at.CatReceiver        = КатегорияКредит;
   at.FIIDPayer          = ВалДебет;
   at.FIIDReceiver       = ВалКредит;
   IF (at.CatPayer == tdr_corespacc_vb)
       at.FIIDPayer      = NATCUR;
       at.FiRolePayer    = FIROLE_CORACC_ACTIVE;
   END;
   
   IF (at.CatReceiver == tdr_corespacc_vb)
       at.FIIDReceiver   = NATCUR;
       at.FiRoleReceiver = FIROLE_CORACC_ACTIVE;
   END;
   
   IF (ВалДебет == Currency)
       at.SumPayer       = Сумма;
   ELIF (ВалКредит == Currency)
       at.SumReceiver    = Сумма;
   ELSE
       RETURN 1;
   END;
   
   at.Chapter            = Глава;
   at.Ground             = Основание;

   IF (at.carry())
      SetParm(1, at.AccountPayer);
      SetParm(3, at.AccountReceiver);
      RETURN 0;
   else
      RETURN 1;
   END;
   
   RETURN 0;
END;

CLASS CObj
   var КатДт;
   var КатКт;
   var Сумма;
END;

PRIVATE MACRO swap(a, b)
   SetParm(0, b);
   SetParm(1, a);
END;

PRIVATE MACRO Проводки(Parm, Obj, withReverse)
   FOR (var o, Obj)
      IF ((withReverse AND (o.Сумма < 0)) OR o.Сумма > 0)
         IF (withReverse AND (o.Сумма < 0))   
            swap(o.КатДт, o.КатКт);
         END;

         IF (Проводка(Parm, o.КатДт, "",
                      o.КатКт, "",
                      CHPT_BALANCE,  // CHPT_BALANCE = 1 (балансовые счета); CHPT_OFFBALANCE = 3 (внебалансовые счета)
                      abs(o.Сумма),
                      "Перенос по МСФО-9", 
                      {curdate},
                      NATCUR,
                      Currency))
            RETURN 1;
         END;
      END;
   END;
   
   RETURN 0;
END;

PRIVATE MACRO ПроводкиШага(Parm)
   VAR stat = 0, ДатаВвода, regVal,
   mainrest      = 0.0,
   exprest       = 0.0,
   perc          = 0.0,
   expperc       = 0.0,
   penny         = 0.0,
   rezerve9      = 0.0;

   VAR Obj  = TArray;
   GetRegistryValue("COMMON\\МСФО\\ДАТА_ВВОДА",
       V_STRING, ДатаВвода, stat);
   IF (not stat)
       ДатаВвода = date (ДатаВвода);
   END;

   GetRegistryValue("MMARK\\ПЕРЕХОД_НА_МСФО\\ПЕРЕХОДНЫЕ_РЕЗЕРВЫ", V_INTEGER, regVal, stat);
   FOR (var i, 0, 5, 1)
      Obj[i]= CObj;
   END;
   
   IF (regVal == 1)
      // По всем отобранным сделкам запустить процедуру формирования резервов по всем элементам расчетной базы (с учетом обеспечения)
      mainrest = Parm.Rnew - Parm.Rold;               // Полученная дельта по ОД
      exprest  = Parm.R_CHC_new - Parm.R_CHC_old;     // Полученная дельта по просроченному ОД
      perc     = Parm.Rpc_new - Parm.Rpc_old;         // Полученная дельта по срочным процентам
      expperc  = Parm.Rpc_CHC_new - Parm.Rpc_CHC_old; // Полученная дельта по просроченным процентам
      penny    = Parm.Rpn_new - Parm.Rpn_old;         // Полученная дельта по неустойкам
      rezerve9 = 0;   // Полученная дельта по лимитам
      
      // На полученные дельты сформировать проводки и установить на этих проводках тип <Перенос по МСФО-9>
      Obj[0].КатДт  = tdr_000000000000;   // Переходный фин. рез
      Obj[0].КатКт  = tdr_rez_mainrest;   // Р, ссуды
      Obj[0].Сумма  = mainrest;

      Obj[1].КатДт  = tdr_000000000000;   // Переходный фин. рез
      Obj[1].КатКт  = tdr_rez_exprest;    // Р, ссуды с н.с.
      Obj[1].Сумма  = exprest;

      Obj[2].КатДт  = tdr_000000000000;   // Переходный фин. рез
      Obj[2].КатКт  = tdr_rez_perc;       // Р, %
      Obj[2].Сумма  = perc;

      Obj[3].КатДт  = tdr_000000000000;   // Переходный фин. рез
      Obj[3].КатКт  = tdr_rez_expperc;    // Р, % с н.с.
      Obj[3].Сумма  = expperc;

      Obj[4].КатДт  = tdr_000000000000;   // Переходный фин. рез
      Obj[4].КатКт  = tdr_rez_penny;      // Р, штрафы
      Obj[4].Сумма  = penny;

      Obj[5].КатДт  = tdr_000000000000;   // Переходный фин. рез
      Obj[5].КатКт  = tdr_rezerve9;       // Резерв, договор
      Obj[5].Сумма  = rezerve9;

      stat = Проводки(Parm, Obj, Currency, true);
   ELIF (regVal == 2)
      // По всем отобранным сделкам полностью списать ранее созданные резервы следующими проводками и установить на этих проводках тип <Перенос по МСФО-9>
      MAINREST = Parm.Deal_fd.GetRestAccount(tdr_rez_mainrest, {curdate}, Currency, CHPT_BALANCE, NULL); // Остаток на счете учета резерва по ОД
      EXPREST  = Parm.Deal_fd.GetRestAccount(tdr_rez_exprest,  {curdate}, Currency, CHPT_BALANCE, NULL); // Остаток на счете учета резерва по просроченному ОД
      PERC     = Parm.Deal_fd.GetRestAccount(tdr_rez_perc,     {curdate}, Currency, CHPT_BALANCE, NULL); // Остаток на счете учета резерва по срочным процентам
      EXPPERC  = Parm.Deal_fd.GetRestAccount(tdr_rez_expperc,  {curdate}, Currency, CHPT_BALANCE, NULL); // статок на счете учета резерва по просроченным процентам
      PENNY    = Parm.Deal_fd.GetRestAccount(tdr_rez_penny,    {curdate}, Currency, CHPT_BALANCE, NULL); // Остаток на счете учета резерва по неустойкам
      REZERVE9 = Parm.Deal_fd.GetRestAccount(tdr_rezerve9,     {curdate}, Currency, CHPT_BALANCE, NULL); // Остаток на счете учета резерва по лимитам

      Obj[0].КатДт  = tdr_rez_mainrest;   // Р, ссуды
      Obj[0].КатКт  = tdr_000000000000;   // Переходный фин. рез
      Obj[0].Сумма  = mainrest;           // Остаток на счете учета резерва по ОД

      Obj[1].КатДт  = tdr_rez_exprest;    // Р, ссуды с н.с.
      Obj[1].КатКт  = tdr_000000000000;   // Переходный фин. рез
      Obj[1].Сумма  = exprest;            // Остаток на счете учета резерва по просроченному ОД

      Obj[2].КатДт  = tdr_rez_perc;       // Р, %
      Obj[2].КатКт  = tdr_000000000000;   // Переходный фин. рез
      Obj[2].Сумма  = perc;               // Остаток на счете учета резерва по срочным процентам

      Obj[3].КатДт  = tdr_rez_expperc;    // Р, % с н.с.
      Obj[3].КатКт  = tdr_000000000000;   // Переходный фин. рез
      Obj[3].Сумма  = expperc;            // Остаток на счете учета резерва по просроченным процентам

      Obj[4].КатДт  = tdr_rez_penny;      // Р, штрафы
      Obj[4].КатКт  = tdr_000000000000;   // Переходный фин. рез
      Obj[4].Сумма  = penny;              // Остаток на счете учета резерва по неустойкам

      Obj[5].КатДт  = tdr_rezerve9;       // Резерв, договор
      Obj[5].КатКт  = tdr_000000000000;   // Переходный фин. рез
      Obj[5].Сумма  = rezerve9;           // Остаток на счете учета резерва по лимитам

      stat = Проводки(Parm, Obj, Currency, false);
      
      IF (not stat)
         // Запустить процедуру формирования резерва в части расчета сумм резервов по всем элементам расчетной базы (с учетом обеспечения)
         mainrest = Parm.Rnew - Parm.Rold;               // Полученная дельта по ОД
         exprest  = Parm.R_CHC_new - Parm.R_CHC_old;     // Полученная дельта по просроченному ОД
         perc     = Parm.Rpc_new - Parm.Rpc_old;         // Полученная дельта по срочным процентам
         expperc  = Parm.Rpc_CHC_new - Parm.Rpc_CHC_old; // Полученная дельта по просроченным процентам
         penny    = Parm.Rpn_new - Parm.Rpn_old;         // Полученная дельта по неустойкам
         rezerve9 = 0;   // Сумма рассчитанного резерва по лимитам
         
         // На полученные суммы сформировать следующие проводки и установить на этих проводках тип <Перенос по МСФО-9>
         Obj[0].КатДт  = tdr_000000000000;   // Переходный фин. рез
         Obj[0].КатКт  = tdr_rez_mainrest;   // Р, ссуды
         Obj[0].Сумма  = mainrest;           // Сумма рассчитанного резерва по ОД

         Obj[1].КатДт  = tdr_000000000000;   // Переходный фин. рез
         Obj[1].КатКт  = tdr_rez_exprest;    // Р, ссуды с н.с.
         Obj[1].Сумма  = exprest;            // Сумма рассчитанного резерва по просроченному ОД

         Obj[2].КатДт  = tdr_000000000000;   // Переходный фин. рез
         Obj[2].КатКт  = tdr_rez_perc;       // Р, %
         Obj[2].Сумма  = perc;               // Сумма рассчитанного резерва по срочным процентам

         Obj[3].КатДт  = tdr_000000000000;   // Переходный фин. рез
         Obj[3].КатКт  = tdr_rez_expperc;    // Р, % с н.с.
         Obj[3].Сумма  = expperc;            // Сумма рассчитанного резерва по просроченным процентам

         Obj[4].КатДт  = tdr_000000000000;   // Переходный фин. рез
         Obj[4].КатКт  = tdr_rez_penny;      // Р, штрафы
         Obj[4].Сумма  = penny;              // Сумма рассчитанного резерва по неустойкам

         Obj[5].КатДт  = tdr_000000000000;   // Переходный фин. рез
         Obj[5].КатКт  = tdr_rezerve9;       // Резерв, договор
         Obj[5].Сумма  = rezerve9;           // Сумма рассчитанного резерва по лимитам
         
         stat = Проводки(Parm, Obj, Currency, false);
      END;
   END;

   IF (stat)
       PrintLn(Parm.Deal_fd.GetTick().DealCode, "Ошибка при формировании проводки");
       RETURN 1;
   END;

   RETURN 0;
END;

MACRO ExecuteStep(Buffer, Document)
   VAR 
       stat  = 0,
       Parm  = MM_RSRVPARM,
       Error = "";

   record tick (dl_tick);

   SetBuff(tick, Document);
   DL_PrepareCarryBuffer (Buffer);

   IF (CheckExistence(LEG_LegKind_DealID_LegID, LEG_KIND_DL_TICK, tick.DealID, 1))
       PrintLn(tick.DealCode, "Не найден транш сделки.");
       RETURN 1;
   END;

   VAR rs = RsdRecordset(
    "SELECT d1.T_DEALID, d1.T_BOFFICEKIND, d1.T_DEALTYPE, d1.T_FLAGTYPEDEAL, d1.T_PARTYID, d1.T_DEALSTATUS, d2.T_DURATION, D3.T_ID_OPERATION "+
    " FROM DDL_TICK_DBT d1   "+
    " JOIN DDL_LEG_DBT  d2 ON (D1.T_DEALID     = D2.T_DEALID) "+
    " JOIN DOPROPER_DBT d3 ON (D3.T_DOCUMENTID = LPAD(d1.T_DEALID, 34, '0') AND D3.T_KIND_OPERATION = D1.T_DEALTYPE AND D3.T_DOCKIND = D1.T_BOFFICEKIND) "+
    " WHERE d1.T_DEALID = " + tick.DealID + " AND D2.T_LEGKIND = 0 AND D2.T_LEGID = 1 "+
    " AND EXISTS "+
    "( "+
    "SELECT 1 FROM DOBJATCOR_DBT a1 WHERE a1.T_OBJECT = LPAD(d1.T_DEALID, 34, '0')  "+
    " AND a1.T_OBJECTTYPE = (CASE d1.T_BOFFICEKIND WHEN 102 THEN 103 ELSE 204 END)  "+
    " AND a1.T_GROUPID = 5 AND a1.T_ATTRID IN (1, 2) "+
    ")");

   WHILE (not rs.moveNext())
     RETURN 0;
   END;

   //Parm.OprServDoc = GetOprServDoc();
   Parm.Deal_fd    = MMFirstDoc(DL_IBCDOC, tick.DealID, true);

   IF ((GetAttrID(103, tick.DealID, 2, {curdate}) == 1) or
       (MC_GetKindSecurCredit(Parm.Deal_fd.GetTick().PartyID) == 1)        or
       (InConsolidGroup(Parm) == true))
      RETURN 1;
   END;

   ПолучитьРасчетнуюБазу(Parm);

   // формирование пруденциального резерва
   IF ((tick.AssCategory == AMORT_COST_LINEAR) or (tick.AssCategory == AMORT_COST_EPS))
      stat = MM_CalcReserve(Parm);

      IF (stat == 0)
         УстановитьЗначениеККС(Parm.ККС);
         IF (not ActAccAfterChangeParm(Parm.Deal_fd, {curdate}, Error))
            PrintLn(tick.DealCode, Error);
            RETURN 1;
         END;
         stat = ПроводкиШага(Parm);
      END;
   END;

   RETURN stat;
END;
NameMacroFile = "msfo_g.mac";