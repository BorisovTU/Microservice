/** 
 @file mmog_j.mac
 @brief Макрос выполнения шага "Исполнение входящих платежей"


 # tag
 - functional_block:БУ
 - code_type:BP_Step

 # changeLog 
 |date       |author         |tasks            |note                            
 |-----------|---------------|-----------------|--------------------------------
 |2023.09.25 |Врубель В.Л.   |CCBO-7600        | Добавлены комментарии          
 |           |               |                 |                   

*/ 
IMPORT "dlcarry.inc", mmcateg, mmlib, mmlibr, mmcnst_j,
       mmlb_j, mpclb, mmcarry, InsCarryDoc,
       mmadd_j, mmpaymentcls, "sp_car.mac", mmclfnc, mmpenalt, mmservop, dv_categ;

/* Массивы с информацией о исполняемых платежах для квитовки */
/* Инициализируются бэк-офисом */
PRIVATE VAR
    PlanIDs     = TArray,
    FactIDs     = TArray,
    KvitAmounts = TArray,
    PlanValueDate = TArray,
    ExecDate;

/* значения изменяемые после исполнения платежей */
PRIVATE VAR
    FutureAmounts              = TArray,
    PlanFuturePayerAccounts    = TArray,
    PlanFutureReceiverAccounts = TArray,
    FactFuturePayerAccounts    = TArray,
    FactFutureReceiverAccounts = TArray;

/*Глобальные переменные*/
PRIVATE VAR 
    deal_pd   = NULL,
    PlanPayms = TArray,     /*Массив планируемых обрабатываемых платежей*/
    FactPayms = TArray,     /*Массив фактических обрабатываемых платежей*/
    ContrIsBankrupt = false; /*Призна контрагента-банкрота*/

PRIVATE VAR
    ID_Operation = 0,
    ID_Step      = 0;

/**
  @brief Записать все платежи в массивы
*/
PRIVATE MACRO GetAllPayms
    /*плановые платежи*/
  VAR
      i = 0,
      previd = -1;

  while (i < PlanIDs.size)
      if (previd == PlanIDs(i))
          PlanPayms(i) = PlanPayms(i-1);
      else
          PlanPayms(i) = RsbPayment(PlanIDs(i));	

          if (PlanPayms(i).PaymentID == 0)
              mm_error ("Не найден платеж");
              return false;
          end;	  
		  
          if (PlanPayms(i).ValueDate != ExecDate)
              if( not GetTrue( true, "Планируемая дата платежа "+
                                      "|не равна дате исполнения."+
                                      "|Исполнить платеж ?" )) 
                  return false;
              end;
          end;
		  
          previd = PlanIDs(i); 
      end;
	  
      i = i+1;
  end;

    /*фактические платежи*/
  i = 0;
  previd = -1;
  while (i<FactIDs.size)
      if (previd == FactIDs(i))
          FactPayms(i) = FactPayms(i-1);
      else
          if (FactIDs(i))
              FactPayms(i) = RsbPayment(FactIDs(i));
		  	  if (FactPayms(i).PaymentID == 0)
                  mm_error ("Не найден платеж");
                  return false;
              end;
              if (FactPayms(i).BaseFIID != deal_pd.GetLeg().PFI)
                  mm_error ("Валюта платежа не соответствует валюте договора");
                  return false;
              end;			  
          end;
      end;
      previd = FactIDs(i);
      i = i+1;
  end;

  return true;
END;

/**
  @brief Квитовка платежей
*/
PRIVATE MACRO KvitPayms ()
  VAR
    pml = TRecHandler("pmlink.dbt"),
    i = 0;

  // Kirakozov, По запросу #123612:
  // В этом блоке мы списываем квитуемые суммы с фактических платежей, т.к. в сишниках
  // это не работает: pmkvit.c, функция InitPMLINK, case PMLINK_KIND_KVITING, pml->PPSign = '\0'; 
  // а для того, чтобы списывалось, надо pml->PPSign = '-'; и вообще, там списывается
  // с FuturePayerAmount, а надо с FutureReceiverAmount
  i = 0;
  while( (i < FactIDs.size) and (FactIDs(i) != NULL) and (KvitAmounts(i) > $0) )
      FutureAmounts(i) = PlanPayms(i).FuturePayerAmount;
      PlanFuturePayerAccounts(i)    = PlanPayms(i).FuturePayerAccount;
      PlanFutureReceiverAccounts(i) = PlanPayms(i).FutureReceiverAccount;
      FactFuturePayerAccounts(i)    = FactPayms(i).FuturePayerAccount;
      FactFutureReceiverAccounts(i) = FactPayms(i).FutureReceiverAccount;

      if (not ((PlanPayms(i).Purpose == PM_PURP_PERCENT) and (FactPayms(i) != 0) and (FactPayms(i).PaymentID > 0) and (FactPayms(i).PaymentID != PlanPayms(i).PaymentID)))
         pml.rec.Amount = KvitAmounts(i);
         pml.rec.FIID   = FactPayms(i).BaseFIID;
         pml.rec.IPSign = "-";
         pml.rec.PPSign = "-";
         PlanPayms(i).LinkPayment(FactPayms(i), PMLINK_KIND_KVITING, pml);
	  
      end;

      i = i + 1;
  end;
   
  return true;
END;

/**
  @brief Симуляция квитовки платежей (если нет фактического платежа, то фактический платеж создается на основе планируемого)
*/
PRIVATE MACRO SimulateKvitPayments ()
  VAR
      PlanPaym    = NULL,
      MM_PaymObj  = NULL,
      NewPaym     = NULL;

    PlanPaym = RsbPayment(PlanPayms(0).PaymentID);
    MM_PaymObj = MM_RsbPayment(MMPAYM_CREATEBYPAYMOBJ, PlanPaym, PlanPaym.SubPurpose, KvitAmounts(0), ExecDate);
    NewPaym = MM_PaymObj.Payment;

    NewPaym.IsFactPaym = "X";
    NewPaym.PaymStatus = PM_READIED;
	
	NewPaym.ValueDate = ExecDate;

    FactPayms[FactPayms.size] = NewPaym;

    return KvitPayms();
END;

/**
  @brief Исполнение платежа
*/
PRIVATE MACRO MakeFactPaym ()
  if ((PlanIDs.size==1) and
       (money(round(PlanPayms(0).FuturePayerAmount,2)) == money(round(KvitAmounts(0),2)) ) 
      ) 
  /*Просто ставим на платеж признак исполненного*/
      FutureAmounts(0) = PlanPayms(0).FuturePayerAmount;
      PlanFuturePayerAccounts(0)    = FactFuturePayerAccounts(0)    = PlanPayms(0).FuturePayerAccount;
      PlanFutureReceiverAccounts(0) = FactFutureReceiverAccounts(0) = PlanPayms(0).FutureReceiverAccount;
      PlanPayms(0).PaymStatus = PM_FINISHED;
      PlanPayms(0).IsFactPaym = "X";  

      PlanPayms(0).FutureBaseAmount = 0;
      PlanPayms(0).ActuateFutureAmounts(TBA_AMOUNT);
      
      PlanPayms(0).ValueDate = ExecDate; 

      FactPayms(0) = PlanPayms(0);
  else
      return SimulateKvitPayments;
  end;

  return true;
END;

/**
  @brief Сохранение налога по процентам во временной таблице, если он был
  @param[in] OpDate - Дата операции
  @param[in] DealID - Идентификатор сделки (dl_tick.dbt.t_dealid)
  @param[in] SumPerc - Сумма процентов
  @param[in] SumNalog - Сумма налога по процентам
  @param[in] Rate - Ставка налога
*/
PRIVATE MACRO SaveNalogHistory(OpDate, DealID, SumPerc, SumNalog, Rate)
    var com = RSDCommand("INSERT INTO dmmnalog_tmp (t_DateStep, t_DealID, t_Sum, t_Sum_Nalog, t_Rate_Nalog)" +
                         " VALUES ("
                         "to_date('" + OpDate + "', 'dd.mm.yyyy')" +
                         ", " + DealID +
                         ", " + SumPerc + 
                         ", " + SumNalog +
                         ", " + Rate + ")");
    com.execute();
end;

/**
  @brief Вспомогательная функция для получения счета и валюты дебета в зависимости от того, есть ли факт. платеж
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @param[out] Счет - Номер счета дебета
  @param[out] ВП - Валюта счета дебета
*/
PRIVATE MACRO GetPayerAccAndPayFIID (i, Счет, ВП)
  VAR paym = NULL; 

  if (FactIDs(i))
      paym = FactPayms(i);
  else
      paym = PlanPayms(i);
  end;
  
  ВП = paym.PayerFIID;
  Счет = paym.FuturePayerAccount;
  
  SetParm (1, Счет);
  SetParm (2, ВП);
  
  return true;
END;

/**
  @brief Формирование проводок по корректировке лимита задолженности (если сделка является траншем кредитной линии)
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertCLDocsPrinc(i)
    VAR Sum = KvitAmounts(i), carry = MM_Carry, Account = "";
    if (deal_pd.GetTick().ParentID <= 0)
        return true;
    end;
    var cl_pd = MMFirstDoc(DL_CREDITLN, deal_pd.GetTick().ParentID, true);
    if (cl_pd.GetTick().BOfficeKind == DL_IBCDOC)
        return true;
    end;
    // проводка не формируются, если был выполнен шаг списания лимита
    if (LimitWasWrittenOff(cl_pd.GetTick().DealID))
        return true;
    end;
    if ((cl_pd.GetTick().DebtLimit == 0) and (cl_pd.GetTick().IssuanceLimit == 0))
        return true;
    end;

    carry.FIIDPayer    = cl_pd.GetTick().LimitCur;
    carry.FIIDReceiver = cl_pd.GetTick().LimitCur;
    carry.Chapter      = 3;
    carry.date_carry   = {curdate};
    carry.PrimaryDoc   = cl_pd;  
    carry.PaymentObj   = FactPayms(i);
    
    if (isSale(GetOperationGroup(deal_pd.GetTick().DealType)))
    // размещение
        var Srestor = Sum;
        if ((cl_pd.GetTick().IssuanceLimit >= 0.0) and (cl_pd.GetTick().DebtLimit == 0.0))
            return true;
        elif ((cl_pd.GetTick().IssuanceLimit == 0.0) and (cl_pd.GetTick().DebtLimit > 0.0))
            if (cl_pd.GetTick().LimitCur != deal_pd.GetLeg().PFI)
                ConvSumCross(Srestor, Sum, {curdate}, deal_pd.GetLeg().PFI, cl_pd.GetTick().LimitCur);
            end;   
        elif ((cl_pd.GetTick().IssuanceLimit > 0.0) and (cl_pd.GetTick().DebtLimit > 0.0))
            var UnusedIssuanceLimit = GetCLUnusedIssuanceLimit(cl_pd.GetTick().DealID, cl_pd.GetTick().IssuanceLimit);
            var UnusedDebtLimit     = GetCLUnusedDebtLimit(cl_pd.GetTick().DealID, cl_pd.GetTick().DebtLimit);
            var Sl, Slnew;
            if (UnusedIssuanceLimit < UnusedDebtLimit)
                Sl = UnusedIssuanceLimit;
            else
                Sl = UnusedDebtLimit;
            end;
            ConvSum(Sum, Sum, {curdate}, deal_pd.GetLeg().PFI, cl_pd.GetTick().LimitCur);
            var UnusedDebtLimitAfterOP = UnusedDebtLimit + Sum;
            if (UnusedIssuanceLimit < UnusedDebtLimitAfterOP)
                Slnew = UnusedIssuanceLimit;
            else
                Slnew = UnusedDebtLimitAfterOP;
            end;
            Srestor = Slnew - Sl;
        end;
        Account = MC_FindAndOpenCommonAccByFD(tdr_corespacc_vb, deal_pd, {curdate}, 0, MC_OPENACC_CREATE, NULL,cl_pd.GetTick().LimitCur, 
                                             NULL, NULL, NULL, FIROLE_CORACC_PASSIVE, NULL, NULL, NULL, NULL, NULL, false, false);
        carry.SumReceiver      = Srestor;
        carry.AccountPayer     = Account;
        carry.CatReceiver      = tdr_oblP;
        carry.Ground           = MM_ground(deal_pd.GetTick().ParentID,512);
// "Восстановление лимита задолженности по договору КЛ, размещение";
    else
    // привлечение
        var LimitSum;
        LimitSum = cl_pd.GetRestAccount(tdr_oblR, ExecDate, cl_pd.GetTick().LimitCur, 3);
        //ConvSumCross(LimitSum, LimitSum, {curdate}, cl_pd.GetTick().LimitCur, deal_pd.GetLeg().PFI);
        if (cl_pd.GetTick().LimitCur != deal_pd.GetLeg().PFI)
            ConvSumCross(Sum, Sum, {curdate}, deal_pd.GetLeg().PFI, cl_pd.GetTick().LimitCur);
        end;

        if (LimitSum < Sum)
            mm_error("Сумма платежа превышает сумму лимита по договору кредитной линии");
            return false;
        end;

        Account = MC_FindAndOpenCommonAccByFD(tdr_corespacc_vb, deal_pd, {curdate}, 0, MC_OPENACC_CREATE, NULL,cl_pd.GetTick().LimitCur, 
                                             NULL, NULL, NULL, FIROLE_CORACC_ACTIVE, NULL, NULL, NULL, NULL, NULL, false, false);
        carry.SumReceiver      = Sum;
        carry.AccountPayer     = Account;
        //carry.CatPayer         = tdr_corespacc_vb;
        //carry.FiRolePayer      = FIROLE_CORACC_ACTIVE;
        carry.CatReceiver      = tdr_oblR;
        carry.Ground           = MM_ground(deal_pd.GetTick().ParentID,512);
//"Уменьшение лимита по договору КЛ при выдаче, привлечение";
    end;
    //carry.SumReceiver = Sum;

    return carry.carry();
END;

/**
  @brief Общая функция формирования проводок
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @param[in] КатегорияД - Категория учета дебета
  @param[in] КатегорияК - Категория учета кредита
  @param[in] ВПД - Идентификатор валюты дебета
  @param[in] ВПК - Идентификатор валюты кредита
  @param[in] SumD - Сумма дебета
  @param[in] SumС - Сумма кредита
  @param[in] Chapter - Глава счета
  @param[in] Ground - Основание проводки
  @param[in] FIRoleReceiver - Роль финансового инструмента счета кредита
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO UNI_InsertDocs (i, КатегорияД, КатегорияК, ВПД, ВПК, SumD, SumC, Chapter, Ground, FIRoleReceiver)
  VAR СчетДебет      = "",
  ВД                 = deal_pd.GetLeg().PFI,acc5,
  ct                 = MM_Carry;

  ct.FIIDActive      = ВД;

  if (deal_pd.GetTick().Dealtype == 12306)
     КатегорияК = "СЧЕТ_61212";
  elif ((deal_pd.GetTick().Dealtype == 12310) or (deal_pd.GetTick().Dealtype == 12335))
     КатегорияК = tdr_mainrest_tf;
  end;
  ct.CatReceiver     = КатегорияК;

  if (ValType(Chapter) == V_UNDEF)
      Chapter = 1;
  end;
  ct.Chapter         = Chapter;
  if ((ValType(КатегорияД) != V_STRING) OR (КатегорияД == ""))
      if (Chapter == 1)
/*          if (substr(FactPayms(i).ReceiverAccount, 1, 5) == "47416")
              //СчетДебет = FactPayms(i).ReceiverAccount;
          elif (ValType(ВПД) == V_UNDEF)
              GetPayerAccAndPayFIID(i, СчетДебет, ВПД);
          else
              GetPayerAccAndPayFIID(i, СчетДебет);
          end;
*/
          //ct.AccountPayer    = СчетДебет;
          ct.AccountPayer = FactPayms(i).FuturePayerAccount;
     elif (Chapter == 3)
          ct.CatPayer        = tdr_corespacc_vb;
          ct.FiRolePayer     = FIROLE_CORACC_ACTIVE;
     end;
  else                                   
    ct.CatPayer = КатегорияД;
    ct.FiRolePayer = FIROLE_FIDOC;
    //ct.Ground = Ground;
    //ct.AccountReceiver = FactPayms(i).ReceiverAccount;
  end;
  if (substr(FactPayms(i).ReceiverAccount, 1, 5) == "47416") 
    //СчетДебет = FactPayms(i).ReceiverAccount;
    //SVE 499825, заменяем счета только в том случае если в плановом платеже указан корректный счет длинной 20 символов, иначе определяем счет по КУ
    if (StrLen(PlanPayms(i).ReceiverAccount) == 20)      
       ct.AccountReceiver = PlanPayms(i).ReceiverAccount;
    end;
    //if ( (FactPayms(i).Ground != null) and (FactPayms(i).Ground != "") and (КатегорияД != "СЧЕТ_60323"))      /*SVE 539975 22/02/2022 Возврат к дистрибутивной КУ, так как в пользовательской нельзя изменить балансовый счет   */
    if ( (FactPayms(i).Ground != null) and (FactPayms(i).Ground != "") and (КатегорияД != tdr_federal_tax))
       ct.Ground = FactPayms(i).Ground; /*SVE Если в платеже указан счет получателя 47416* то сохраняем наименование входящего платежа, а не формируем свое */
    //elif (КатегорияД == "СЧЕТ_60323")
    elif (КатегорияД == tdr_federal_tax)   /*SVE 539975 22/02/2022 Возврат к дистрибутивной КУ, так как в пользовательской нельзя изменить балансовый счет   */
       ct.Ground = Ground;
    elif ((deal_pd.GetTick().Dealtype == 12335) or (deal_pd.GetTick().Dealtype == 12310))     //SVE 492169 для торгового финансирования всегда брать назначение из входящего платежа
       ct.Ground = FactPayms(i).Ground;      
    end;
  else
    ct.Ground = Ground;
    ct.AccountReceiver = FactPayms(i).ReceiverAccount;
  end;                                               
  
  if (strlen(ct.AccountReceiver) < 2 )
    if (FactPayms(i).Purpose < 11)
      ct.AccountReceiver =MM_acc(deal_pd.GetTick().DealID,111);
    end;
  end;
  
  if ((deal_pd.GetTick().Dealtype == 12306) and ( FactPayms(i).Purpose  == 10 ))
     if(not deal_pd.OpenAccount("СЧЕТ_61212П", acc5, NULL, deal_pd.GetFIRoleByCategory("СЧЕТ_61212П", deal_pd.GetLeg().PFI), NULL, ExecDate, deal_pd.GetLeg().PFI))
     end;    
     ct.AccountReceiver = acc5;
  end;

  if ((deal_pd.GetTick().Dealtype == 12306) and ( FactPayms(i).Purpose  == 11 ))
     if(not deal_pd.OpenAccount("+% к погашению", acc5, NULL, deal_pd.GetFIRoleByCategory("+% к погашению", deal_pd.GetLeg().PFI), NULL, ExecDate, deal_pd.GetLeg().PFI))
     end;    
     ct.AccountReceiver = acc5;
  end;

  if (ValType(ВПД) == V_UNDEF)
      ВПД = ВД;
  end;
  ct.FIIDPayer       = ВПД;

  if (ValType(ВПК) == V_UNDEF)
      ВПК = ВД;
  end;
  ct.FIIDReceiver    = ВПК;

  if (ValType(FIRoleReceiver) == V_UNDEF)
    ct.FiRoleReceiver = deal_pd.GetFIRoleByCategory(КатегорияК, ВПК);
  else
    ct.FiRoleReceiver = FIRoleReceiver;
  end;
  ct.Date_carry      = ExecDate;
  //ct.Ground          = Ground;

  if (ValType(SumD) != V_UNDEF)
      ct.SumPayer = SumD;
  end;

  if (ValType(SumC) != V_UNDEF)
      ct.SumReceiver = SumC;
  end;  

  ct.PrimaryDoc      = deal_pd;
  ct.PaymentObj      = FactPayms(i);

  return ct.carry();
END;

/**
  @brief Обновление примечаний сделки, связанных с МСФО
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @param[in] adjsum - Сумма корректировки
  @param[in] isgraphpm - Признак сделки с графиком платежей
*/
PRIVATE MACRO UpdateMSFOParam(i, adjsum, isgraphpm)
    VAR AS = 0, GBV = 0, AsCategory = 0;
    if( valtype( adjsum ) == V_UNDEF )
       adjsum = 0;
    end;
    if( valtype( isgraphpm ) == V_UNDEF )
       isgraphpm = false;
    end;
    // получить категорию оценки
    GetMainObjAttr(NULL, OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 5, AsCategory, NULL, NULL, ExecDate);

    if ((KvitAmounts(i) == PlanPayms(i).BaseAmount) and (not isgraphpm) and (PlanPayms(i).Purpose == PM_PURP_PRINC_RET))
        MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 7/*MN_AMORTIZED*/, ExecDate, $0);
        IF ((AsCategory == 1) or (AsCategory == 2))
            MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 10, ExecDate, $0);
        END;
        MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 8/*MN_GROSS*/,     ExecDate, $0);
        return;
    end;

    // сделки, оцениваемые по АС
    IF ((AsCategory == 1) or (AsCategory == 2))
        AS = ПолучитьЗначениеПримечания(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 7/*MN_AMORTIZED*/, ExecDate);
        AS = AS - KvitAmounts(i) - adjsum;
        if (AS < 0)
            AS = 0;
        end;
        MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 7/*MN_AMORTIZED*/, ExecDate, AS);
        MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 10, ExecDate, AS);
        IF (isSale(GetOperationGroup(deal_pd.GetTick().DealType)))
            GBV = GBV = ПолучитьЗначениеПримечания(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 8/*MN_GROSS*/, ExecDate);
            GBV = GBV - KvitAmounts(i) - adjsum;
            if (VALTYPE(GBV) == V_DOUBLE)
                if (GBV < 0)
                    GBV = 0;
                end;
            end;            
            MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 8/*MN_GROSS*/, ExecDate, GBV);
        END;
    END;
END;

/**
  @brief Функция возвращает остаток, имеющийся на парных счетах КУ -Корр, РС/+Корр, РС
  @return Остаток на счете
*/
PRIVATE MACRO GetAdjRest()
    VAR Остаток = 0, Счет = "";
    
    ПолучитьОстатокСчетаУчетЗнака(deal_pd, tdr_adjplR, Счет, 1, Остаток, ExecDate, NATCUR);
    if (Остаток == 0)
        Счет = "";
        ПолучитьОстатокСчетаУчетЗнака(deal_pd, tdr_adjplP, Счет, 1, Остаток, ExecDate, NATCUR);
    end;
    return -Остаток;
END;

/**
  @brief Функция возвращает остаток, имеющийся на парных счетах КУ -Корр, ПТ/+Корр, ПТ
  @return Остаток на счете
*/
PRIVATE MACRO GetAdjRestCM()
    VAR Остаток = 0, Счет = "";
    ПолучитьОстатокСчетаУчетЗнака(deal_pd, get_adjcmP(ExecDate), Счет, 1, Остаток, ExecDate, NATCUR);
    if (Остаток == 0)
        Счет = "";
        ПолучитьОстатокСчетаУчетЗнака(deal_pd, get_adjcmR(ExecDate), Счет, 1, Остаток, ExecDate, NATCUR);
    end;
    return -Остаток;
END;

/**
  @brief Функция возвращает остаток, имеющийся на парных счетах КУ -Корр, РС_Хедж/+Корр, РС_Хедж
  @param[in] FIRole - Роль финансового инструмента
  @return Остаток на счете
*/
PRIVATE MACRO GetHedgAdjRest(FIRole)
    VAR Остаток = 0;
    
    Остаток = deal_pd.GetRestAccount(tdr_hedgadjplR, ExecDate, NATCUR, 1, FIRole, true);
    if (Остаток == 0)
        Остаток = deal_pd.GetRestAccount(tdr_hedgadjplP, ExecDate, NATCUR, 1, FIRole, true);
    end;
    return -Остаток;
END;

/**
  @brief Получение счета сделки ФИСС и КО
  @param[in] DVNDealID - Идентификатор сделки ФИСС и КО 
  @param[in] cat - Категория учета
  @return Номер счета
*/
PRIVATE MACRO GetDVNDealAcc(DVNDealID, cat)
    var deal_pd, Account = "";
    deal_pd = DVFirstDocNDeal(DL_DVNDEAL, DVNDealID);
    deal_pd.OpenAccount(cat, Account, NULL, FIROLE_UNDEF, NULL, ExecDate, NATCUR);
    return Account;
END; 

/**
  @brief Формирование проводок при исполнении платежа по предоставлению/погашению ОД
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsPrinc (i)
  VAR stat, КОРост = $0, КОРхост = $0, Sk = $0, Сод = $0, Спод = $0, Счет = "", NatcurSum = KvitAmounts(i), OldVal = $0, isgraphpm = false, 
  Сном = deal_pd.GetLeg().Principal, Соном;
  if (not InsertCLDocsPrinc(i))
    return false;
  end;

  if (PlanPayms(i).Purpose == PM_PURP_PRINC)       //Платеж по привлечению средств
     // return UNI_InsertDocs (i, NULL, tdr_mainrest, NULL, NULL, KvitAmounts(i), NULL, NULL, "Привлечение средств");
     if (FactPayms(i).PaymentID == PlanPayms(i).PaymentID )
       return UNI_InsertDocs (i, NULL, tdr_mainrest, NULL, NULL, KvitAmounts(i), NULL, NULL, MM_ground(deal_pd.GetTick().DealID,90));
     else
       return UNI_InsertDocs (i, NULL, tdr_mainrest, NULL, NULL, KvitAmounts(i), NULL, NULL, FactPayms(i).Ground);
     end;
  else                                             //Платеж по ОД
     if (IsCLAIMSACQ(GetOperationGroup(deal_pd.GetTick().DealType)))
        Соном = deal_pd.GetRestAccount(tdr_nomcost, ExecDate, deal_pd.GetLeg().PFI, 3);
        КОРост = GetAdjRestCM();
        stat = UNI_InsertDocs (i, NULL, tdr_retirement, NULL, NULL, KvitAmounts(i), NULL, NULL, "Погашение приобретенных прав требования");
        if (stat)
            stat = ПолучитьОстатокСчета(deal_pd, get_rights(ExecDate), Счет, 1, Сод, ExecDate, deal_pd.GetLeg().PFI);
            ConvSum(Сод,       Сод,       ExecDate, deal_pd.GetLeg().PFI, NATCUR);
            ConvSum(NatcurSum, NatcurSum, ExecDate, deal_pd.GetLeg().PFI, NATCUR);
            ConvSum(Сном,      Сном,      ExecDate, deal_pd.GetLeg().PFI, NATCUR);
            ConvSum(Соном,     Соном,     ExecDate, deal_pd.GetLeg().PFI, NATCUR);
            isgraphpm = IsGraphPaym(deal_pd.GetTick().DealID, DL_IBCDOC, PM_PURP_PRINC_RET);

            if (stat and (Сод > 0) and (not isgraphpm))
                Спод = Сод*NatcurSum/Соном;
                Sk = (abs(КОРост)*Спод)/Сод;
                if (stat)
                    stat = UNI_InsertDocs (i, tdr_retirement, get_rights(ExecDate), NATCUR, NULL, Спод, NULL, NULL, "Погашение приобретенных прав требования");
                end;
                if (КОРост > 0)
                    stat = UNI_InsertDocs (i, tdr_plodP(deal_pd.GetTick().TypeDoc), get_adjcmR(ExecDate), NATCUR, NATCUR, Sk, NULL, NULL, "Списание корректировки, увеличивающей стоимость сделки приобретения прав требования МБК");
                else
                    stat = UNI_InsertDocs (i, get_adjcmP(ExecDate), tdr_plodR(deal_pd.GetTick().TypeDoc), NATCUR, NATCUR, Sk, NULL, NULL, "Списание корректировки, уменьшающей стоимость сделки приобретения прав требования МБК");
                end;
                if (stat)
                    VAR ВД = deal_pd.GetLeg().PFI,
                        ct = MM_Carry,
                        Account = MC_FindAndOpenCommonAccByFD(tdr_corespacc_vb, deal_pd, ExecDate, 0, MC_OPENACC_CREATE, NULL, ВД, 
                                             NULL, NULL, NULL, FIROLE_CORACC_ACTIVE, NULL, NULL, NULL, NULL, NULL, false, false);

                    ct.FIIDActive   = ВД;
                    ct.CatReceiver  = tdr_nomcost;
                    ct.Chapter      = 3;
                    ct.AccountPayer = Account;
                    ct.FIID         = ВД;
                    ct.Date_carry   = ExecDate;
                    ct.Ground       = "Списание номинальной стоимости по приобретенным правам требования";
                    ct.SumPayer     = KvitAmounts(i);
                    ct.PrimaryDoc   = deal_pd;
                    ct.PaymentObj   = FactPayms(i);

                    stat = ct.carry();
                end;
            end;
            if (stat)
                var Sпрем = MM_CalcPrize(deal_pd.GetTick().BOfficeKind, deal_pd.GetTick().DealID, ExecDate, 10, 0, 0, Спод);
                var NcSпрем;
                ConvSum(NcSпрем, Sпрем, ExecDate, deal_pd.GetLeg().PFI, NATCUR);
                if (Sпрем > 0)
                    stat = UNI_InsertDocs (i, tdr_retirement, tdr_plodR(deal_pd.GetTick().TypeDoc), NATCUR, NATCUR, NULL, NcSпрем, NULL, "Отражение финансового результата по сделке приобретения прав требования МБК");
                    if (stat)
                        OldVal = ПолучитьЗначениеПримечания(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 16/*MN_PRIZE*/, ExecDate);
                        MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 16/*MN_PRIZE*/, ExecDate, Money(OldVal - Sпрем));
                    end;
                end;
            end;
            if (stat)
                var Дисконт = deal_pd.GetRestAccount(get_discount_cm({curdate}), {curdate}, deal_pd.GetLeg().PFI, 1);
                var Sдиск = MM_CalcDiscount(deal_pd.GetTick().BOfficeKind, deal_pd.GetTick().DealID, ExecDate, 10, 0, 0, Спод);
                var NcSдиск;
                ConvSum(NcSдиск, Sдиск,   ExecDate, deal_pd.GetLeg().PFI, NATCUR);
                ConvSum(Дисконт, Дисконт, ExecDate, deal_pd.GetLeg().PFI, NATCUR);
                if (Дисконт > 0)
                    stat = UNI_InsertDocs (i, tdr_retirement, get_discount_cm({curdate}), NATCUR, NULL, Дисконт, NULL, NULL, "Погашение начисленного дисконта по сделке приобретения прав требования МБК");
                end;
                if (stat and (Sдиск > 0))
                    stat = UNI_InsertDocs (i, tdr_plodP(deal_pd.GetTick().TypeDoc), tdr_retirement, NATCUR, NATCUR, NULL, NcSдиск - Дисконт, NULL, "Отражение финансового результата по сделке приобретения прав требования МБК");
                    if (stat)
                        OldVal = ПолучитьЗначениеПримечания(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 17/*MN_DISCOUNT*/, ExecDate);
                        MM_ChangeNoteText(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 17/*MN_DISCOUNT*/, ExecDate, Money(OldVal - Sдиск));
                    end;
                end;
            end;
        end;
   else
      //SVE для сделок ТФ используется другая КУ - ОДТФ, вместо ОД
      if ( (deal_pd.GetTick().DealType == 12310) or (deal_pd.GetTick().DealType == 12335) )  
         stat = ПолучитьОстатокСчета(deal_pd, tdr_mainrest_tf, Счет, 1, Сод, ExecDate, deal_pd.GetLeg().PFI);
      else
         stat = ПолучитьОстатокСчета(deal_pd, tdr_mainrest, Счет, 1, Сод, ExecDate, deal_pd.GetLeg().PFI);
      end;
      ConvSum(Сод,       Сод,       ExecDate, deal_pd.GetLeg().PFI, NATCUR);
      ConvSum(NatcurSum, NatcurSum, ExecDate, deal_pd.GetLeg().PFI, NATCUR);
      КОРост = GetAdjRest();
      if (stat) 
        //stat = UNI_InsertDocs (i, NULL, tdr_rest(deal_pd.GetTick().FlagTypeDeal), NULL, NULL, KvitAmounts(i), NULL, NULL, "Погашение основного долга");
        if (FactPayms(i).PaymentID == PlanPayms(i).PaymentID )
            stat = UNI_InsertDocs (i, NULL, tdr_mainrest, NULL, NULL, KvitAmounts(i), NULL, NULL, MM_ground(deal_pd.GetTick().DealID,10));
        else
            stat = UNI_InsertDocs (i, NULL, tdr_mainrest, NULL, NULL, KvitAmounts(i), NULL, NULL, FactPayms(i).Ground);
        end;
        isgraphpm = IsGraphPaym(deal_pd.GetTick().DealID, DL_IBCDOC, PM_PURP_PRINC_RET);
        if (stat and (Сод > 0) and (not isgraphpm))
            Sk = (abs(КОРост)*NatcurSum)/Сод;
            Sk = round(Sk, 2);
            if (КОРост > 0)
                stat = UNI_InsertDocs (i, tdr_plodP(deal_pd.GetTick().TypeDoc), tdr_adjplP, NULL, NULL, Sk, NULL, NULL, "Списание корректировки, увеличивающей стоимость сделки размещения МБК");
            else
                stat = UNI_InsertDocs (i, tdr_adjplR, tdr_plodR(deal_pd.GetTick().TypeDoc), NULL, NULL, Sk, NULL, NULL, "Списание корректировки, уменьшающей стоимость сделки размещения МБК");
            end;
        end;
      end;
      if (stat and (ExecDate < PlanValueDate(i)) and (Сод > 0))
            var query = "select t_id, t_instrid from DDLHDGRELATION_DBT where t_objid = " + deal_pd.GetTick().DealID + 
            " and t_objdockind = " + deal_pd.GetTick().BOfficeKind + " and t_instrdockind = " + DL_DVNDEAL;
          var RsbData = TRsbDataSet(query);

          while (RsbData.MoveNext)
              var FIRole = 10000 + RsbData.Id;
              КОРхост = GetHedgAdjRest(FIRole);
              var at = MM_Carry;
              at.FIIDPayer        =
              at.FIIDReceiver     = NATCUR;
              at.Chapter          = 1;
              at.date_carry       = ExecDate;
              at.PrimaryDoc       = deal_pd;  

              if (КОРхост < 0)
                  at.CatPayer        = tdr_hedgadjplR;
                  at.FIRolePayer     = FIRole;
                    at.AccountReceiver = GetDVNDealAcc(RsbData.InstrID, tdr_inchedg);
                  at.Ground = "Списание корректировки хеджирования, уменьшающей стоимость размещенных денежных средств";
              else
                    at.AccountPayer   = GetDVNDealAcc(RsbData.InstrID, tdr_exphedg);
                  at.CatReceiver    = tdr_hedgadjplP;
                  at.FIRoleReceiver = FIRole;
                  at.Ground = "Списание корректировки хеджирования, увеличивающей стоимость размещенных денежных средств";
              end;
              at.SumReceiver = abs((abs(КОРхост)*NatcurSum)/Сод);
              IF (not at.carry())
                  RETURN 1;
              END;
          END;

      end;
    end;

    if (КОРост > 0)
        UpdateMSFOParam(i, Sk, isgraphpm);
    else
        UpdateMSFOParam(i, -Sk, isgraphpm);
    end;
    return stat;
  end;
END;

/**
  @brief Формирование проводок при исполнении платежа по погашению просроченного ОД
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsOvdPrinc(i)
  VAR stat, Сод = $0, Сод1 = $0, Сод2 = $0, Спод = $0, Сном = deal_pd.GetLeg().Principal, at,
  Соном;
  if (not InsertCLDocsPrinc(KvitAmounts(i)))
    return false;
  end;
  if (not IsCLAIMSACQ(GetOperationGroup(deal_pd.GetTick().DealType)))
  var CredFIID = deal_pd.GetLeg().PFI;
  if (ContrIsBankrupt)
    CredFIID = NATCUR;
  end;
    stat = UNI_InsertDocs (i, NULL, tdr_exprestR, NULL, CredFIID, KvitAmounts(i), NULL, NULL, "Погашение просроченного основного долга", NULL, NULL, true);
  else
    Соном = deal_pd.GetRestAccount(tdr_nomcost, ExecDate, deal_pd.GetLeg().PFI, 3);
    stat = UNI_InsertDocs (i, NULL, tdr_retirement, NULL, NULL, KvitAmounts(i), NULL, NULL, "Погашение приобретенных прав требования");
    if (stat)
        stat = ПолучитьОстатокСчета(deal_pd, get_rights(ExecDate), NULL, 1, Сод1, ExecDate, deal_pd.GetLeg().PFI);
        if (stat)
            stat = ПолучитьОстатокСчета(deal_pd, tdr_exprestR, NULL, 1, Сод2, ExecDate, deal_pd.GetLeg().PFI);
        end;
        Сод = Сод1 + Сод2;
        if (stat and (Сод > 0))
            Спод = (Сод*KvitAmounts(i))/Соном;
            stat = UNI_InsertDocs (i, tdr_retirement, tdr_exprestR, NULL, NULL, NULL, Спод, NULL, "Погашение просрочки приобретенных прав требования");
        end;
        if (stat)
            var Account = MC_FindAndOpenCommonAccByFD(tdr_corespacc_vb, deal_pd, ExecDate, 0, MC_OPENACC_CREATE, NULL,deal_pd.GetLeg().PFI, 
                                             NULL, NULL, NULL, FIROLE_CORACC_ACTIVE, NULL, NULL, NULL, NULL, NULL, false, false);
            at = MM_Carry;
            at.date_carry       = ExecDate;
            at.PrimaryDoc       = deal_pd;
            at.FIIDPayer        = 
            at.FIIDReceiver     = deal_pd.GetLeg().PFI;
            at.CatReceiver      = tdr_nomcost;
            at.AccountPayer     = Account;
            at.SumReceiver      = KvitAmounts(i);
            at.Chapter          = 3;
            at.Ground           = "Списание номинальной стоимости по приобретенным правам требования";
            at.PaymentObj       = FactPayms(i);

            if (not at.carry())
                return false; 
            end;
        end;
        if (stat)
            var Dн, Sдиск, Dприм = ПолучитьЗначениеПримечания(OBJTYPE_MMARKDEAL, UniID(deal_pd.tick, OBJTYPE_MMARKDEAL), 17, ExecDate);
            if (Dприм > 0)
                Sдиск = MM_CalcDiscount(deal_pd.GetTick().BOfficeKind, deal_pd.GetTick().DealID, ExecDate, 10, 0, 0, KvitAmounts(i));
                stat = UNI_InsertDocs (i, tdr_retirement, get_discount_cm({curdate}), NULL, NULL, NULL, Sдиск, NULL, "Погашение начисленного дисконта по сделке приобретения прав требования МБК");
            else
                ПолучитьОстатокСчета(deal_pd, get_discount_cm({curdate}), NULL, 1, Dн, ExecDate, deal_pd.GetLeg().PFI);
                stat = UNI_InsertDocs (i, tdr_retirement, get_discount_cm({curdate}), NULL, NULL, NULL, Dн, NULL, "Погашение начисленного дисконта по сделке приобретения прав требования МБК");
            end;
        end;
    end;
  end;

  UpdateMSFOParam(i);
  return stat;
END;

/**
  @brief Формирование проводок при исполнении платежа по процентам
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsPercent (i)
    VAR СчетПроцентов, ok, claim_cat, at,
        СуммаПолученных,  
        УплачНачБ, ПолучСверхНач,
        НачбалансСрочн = 0,
        НалогСтавка = GetTaxBank(deal_pd.GetTick()), НалогСтавкаВыч, НалогОбщий = 0, НалогНачбалансСрочн = 0, НалогНеНач = 0, KvitAmountP = 0, KvitAmountDiff = 0, PlanSum;

    if (PlanPayms(i).PayerAmount == 0)
        return true;
    end;

    if (isSale(GetOperationGroup(deal_pd.GetTick().DealType)))
        claim_cat = tdr_claimR;
    else
        claim_cat = tdr_perc3R;
    end;

    if (not ПолучитьОстатокСчета(deal_pd, claim_cat, NULL, NULL, НачбалансСрочн, ExecDate, deal_pd.GetLeg().PFI))
        mm_error ("Ошибка при получении остатков на счетах");
        return false;
    end;

   if ((FactPayms(i) != 0) and (FactPayms(i).PaymentID > 0))
        НалогСтавкаВыч = 1 - (НалогСтавка/100);
        KvitAmountP = KvitAmounts(i)/НалогСтавкаВыч;

        if (PlanPayms(i).FuturePayerAmount > 0)
            PlanSum = PlanPayms(i).FuturePayerAmount;
        else
            PlanSum = PlanPayms(i).PayerAmount;
        end;

        if (KvitAmountP > PlanSum)
            KvitAmounts(i) = PlanSum - (PlanSum*(НалогСтавка/100));
            KvitAmountP = KvitAmounts(i)/НалогСтавкаВыч;
        end;

        KvitAmountDiff = KvitAmountP - KvitAmounts(i);
		
        VAR pml = TRecHandler("pmlink.dbt");
        pml.rec.Amount = KvitAmounts(i);
        pml.rec.FIID   = FactPayms(i).BaseFIID;
        pml.rec.IPSign = "-";
        pml.rec.PPSign = "-";
        PlanPayms(i).LinkPayment(FactPayms(i), PMLINK_KIND_KVITING, pml);
        
        if (KvitAmountDiff > 0)
            pml.rec.Amount = KvitAmountDiff;
            PlanPayms(i).LinkPayment(PlanPayms(i), PMLINK_KIND_KVITING, pml);
        end;
    else
        KvitAmountP = KvitAmounts(i);
    end;

    СуммаПолученных = min(PlanPayms(i).PayerAmount, KvitAmountP);
    ПолучСверхНач = СуммаПолученных;
    УплачНачБ     = min(НачбалансСрочн, ПолучСверхНач);
    ПолучСверхНач = ПолучСверхНач - УплачНачБ;
    VAR party  = TBfile("party.dbt",    "R", 0);
        party.rec.PartyID = deal_pd.GetTick().PartyID;
        party.getEQ;

    if ((ПолучСверхНач > 0) and (not ((deal_pd.GetTick().dealdate == ExecDate) and (deal_pd.GetTick().dealtype == 12335))) )      //SVE 527895 для сделок ТФ где нужно выполнить платеж в день заключения сделки    
        mm_error("Сумма платежа превышает сумму начисленных процентов: " + НачбалансСрочн);
        return false;
    end;
    
    //НалогНачбалансСрочн = УплачНачБ * (НалогСтавка/100);  //SVE платеж приходит уже с учетом налога ВСЕГДА
    НалогНачбалансСрочн = НачбалансСрочн * (НалогСтавка/100);
    НалогНеНач = ПолучСверхНач * (НалогСтавка/100);
    НалогОбщий = НалогНачбалансСрочн + НалогНеНач;
    НалогОбщий = round(НалогОбщий, 2);

    //сделка привлечения, отрицательная ставка
    if (deal_pd.GetTick().NegativeRate == "X")
        if (УплачНачБ > 0)
            at = MM_Carry;
            at.date_carry       = ExecDate;
            at.PrimaryDoc       = deal_pd;
            at.FIIDPayer        = deal_pd.GetLeg().PFI;
            at.FIIDReceiver     = deal_pd.GetLeg().PFI;
            at.AccountPayer     = FactPayms(i).FuturePayerAccount;
            at.CatReceiver      = tdr_perc3R;
            at.SumReceiver      = round(УплачНачБ - НалогНачбалансСрочн, 2);
            at.Chapter          = 1;
            at.Ground           = "Погашение процентных требований по сделкам с отриц. ставками";
            at.PaymentObj       = FactPayms(i);

            if (not at.carry())
                return false; 
            end;

            //ConvSum( НалогНачбалансСрочн, НалогНачбалансСрочн, ExecDate, deal_pd.GetLeg().PFI, NATCUR);
            at = MM_Carry;
            at.date_carry       = ExecDate;
            at.PrimaryDoc       = deal_pd;
            at.FIIDPayer        = NATCUR;
            at.FIIDReceiver     = deal_pd.GetLeg().PFI;
            at.CatPayer         = tdr_federal_tax;
            at.CatReceiver      = tdr_perc3R;
            at.SumReceiver      = round(НалогНачбалансСрочн, 2);
            at.Chapter          = 1;
            at.Ground           = "Учет удержанного налога на доходы банка по процентам";
            at.PaymentObj       = FactPayms(i);

            if (not at.carry())
                return false; 
            end;
        end;
    // сделка размещения
    else
        /*Выполняем проводки*/
        if ((deal_pd.GetTick().dealdate == Execdate) and (deal_pd.GetTick().dealtype == 12335))        //SVE 527895 
           УплачНачБ = ПолучСверхНач;
        end;
        if (УплачНачБ > 0)
            var РазницаБ = 0;
            if ((НачбалансСрочн - НалогОбщий) == УплачНачБ);     //SVE сумма по процентам приходит уце без налога
	       РазницаБ = УплачНачБ;                             //Если из суммы планируемого платежа вычесть расчитанный налог и это будет суммой вх. платежа, значит первую проводку делаем на всю сумму вх. платежа
	    else                                                 //Иначе считаем что платеж пришел с налогом
               РазницаБ = round(УплачНачБ-НалогНачбалансСрочн, 2);
	    end;
            // ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, "Погашение процентных требований без нарушения срока по сделке");
            //ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, MM_ground(deal_pd.GetTick().DealID,11));

            if ( (deal_pd.GetTick().DealType == 12310) or (deal_pd.GetTick().DealType == 12335) )  //SVE 492169 для торгового финансирования всегда брать назначение из входящего платежа 
              if ( (FactPayms(i).Ground != "") or (FactPayms(i).Ground != NULL) )                  //Проверяем что у нас действительно заполнено основание
                ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, FactPayms(i).Ground); 
              else                                                                                 //Если основание по платежу не заполнено, то подставляем своё
                ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, MM_ground(deal_pd.GetTick().DealID,11));
              end;
            else   //Если это сделки не ТФ то как обычно формируем наименование сами
              if (FactPayms(i).PaymentID == PlanPayms(i).PaymentID )
                ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, MM_ground(deal_pd.GetTick().DealID,11));
              else
                ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, FactPayms(i).Ground);
              end;
            end;

            if( not ok) return false; end;
        end;

        if (НалогНачбалансСрочн > 0)
            var НалогНачбалансСрочнОкр = round(НалогНачбалансСрочн, 2);
            // ok = UNI_InsertDocs ( i, tdr_federal_tax, tdr_claimR, NATCUR, NULL, NULL, НалогНачбалансСрочнОкр, 1, "Учет удержанного налога на доходы по процентам");
            //ok = UNI_InsertDocs (i, NULL, tdr_claimR, NULL, NULL, NULL, РазницаБ, 1, MM_ground(deal_pd.GetTick().DealID,11));
            //ok = UNI_InsertDocs (i, "СЧЕТ_60323", tdr_claimR, NATCUR, NULL, NULL, НалогОбщий, 1, MM_ground(deal_pd.GetTick().Dealid,13));    /*SVE 539975 22/02/2022 Возврат к дистрибутивной КУ, так как в пользовательской нельзя изменить балансовый счет   */
            ok = UNI_InsertDocs (i, tdr_federal_tax, tdr_claimR, NATCUR, NULL, NULL, НалогОбщий, 1, MM_ground(deal_pd.GetTick().Dealid,13));
            if (not ok) return false; end;
        end;

        if (НалогОбщий > 0)
            SaveNalogHistory(ExecDate, deal_pd.GetTick().DealId, (УплачНачБ + ПолучСверхНач), НалогОбщий, НалогСтавка);
        end;
    end;
    
    UpdateMSFOParam(i);
    return true;    
END;

/**
  @brief Формирование проводок при исполнении платежа по просроченным процентам
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsOvdPerc (i)
  VAR НалогСтавка = GetTaxBank(deal_pd.GetTick());

  VAR party  = TBfile("party.dbt",    "R", 0);
  party.rec.PartyID = deal_pd.GetTick().PartyID;
  party.getEQ;

  VAR Сумма = KvitAmounts(i);
  VAR Налог = Сумма* (НалогСтавка/100);
  Налог = round(Налог, 2);
  var CredFIID = deal_pd.GetLeg().PFI;
  if (ContrIsBankrupt)
    CredFIID = NATCUR;
  end;
  
  VAR ok = UNI_InsertDocs ( i, NULL, tdr_exppercR, NULL, CredFIID, (Сумма - Налог), NULL, 1, "Погашение просроченных процентных требований по сделке.") and
           UNI_InsertDocs ( i, tdr_federal_tax, tdr_exppercR, NATCUR, CredFIID, Налог, NULL, 1, "Учет удержанного налога на доходы по процентам.");
  if (Налог > 0)
      SaveNalogHistory(ExecDate, deal_pd.GetTick().DealId, Сумма, Налог, НалогСтавка);
  end;
  return ok;
END;

/**
  @brief Формирование проводок при исполнении платежа по получению просроченный комиссий
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsComOvdReceiving (i)
  VAR Ground = "Получение комиссии Банком", DataSet,tdr_cat, ТипКомиссии;
  DataSet = TRsbDataSet("SELECT t_type FROM dmmcomiss_dbt " +
        " INNER JOIN ddlcomis_dbt ON ddlcomis_dbt.t_feetype = dmmcomiss_dbt.t_feetype AND ddlcomis_dbt.t_comnumber = dmmcomiss_dbt.t_number " +
        " WHERE ddlcomis_dbt.t_ID = "+FactPayms[i].SubPurpose);
  if(not DataSet.MoveNext())
    return false;
  end;
  ТипКомиссии = DataSet.Type;
  if (ТипКомиссии == 1)
    tdr_cat = tdr_pccomreq;
  else
    tdr_cat = tdr_opcomreq;
  end;

  var CredFIID = deal_pd.GetLeg().PFI;
  if (ContrIsBankrupt)
    CredFIID = NATCUR;
  end;

  UpdateMSFOParam(i);
  return UNI_InsertDocs (i, NULL, tdr_cat, NULL, CredFIID, KvitAmounts(i), NULL, NULL, Ground, NULL, 10000 + FactPayms[i].SubPurpose);
END;

/**
  @brief Формирование проводок при исполнении платежа по получению комиссий
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsComReceiving (i)
  VAR Ground = "Получение комиссии Банком";
  if (isSale(GetOperationGroup(deal_pd.GetTick().DealType)))
    return UNI_InsertDocs (i, NULL, get_inccalcs(deal_pd.GetTick().DealType, ExecDate), NULL, NULL, KvitAmounts(i), NULL, NULL, Ground, NULL, 10000 + FactPayms[i].SubPurpose);
  end;
  return UNI_InsertDocs (i, NULL, tdr_comreq, NULL, NULL, KvitAmounts(i), NULL, NULL, Ground, NULL, 10000 + FactPayms[i].SubPurpose);
END;

/**
  @brief Формирование проводок при исполнении платежа с назначением "Штраф за просроченный ОД/просроченные %%".
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocsPenalty (i)
  VAR НачШтраф, ДатаВвода, tdr_penny_cat, Ground, stat, Account = "";
  GetRegistryValue("COMMON\\МСФО\\ДАТА_ВВОДА",
    V_STRING, ДатаВвода, stat);
  if (stat)
    mm_error("Ошибка при работе с реестром");
    return false;
  end;
  ДатаВвода = date (ДатаВвода);

  if (PlanPayms(i).Purpose == PM_PURP_PENALTY_PRINC)
    tdr_penny_cat = tdr_penny_ODR;
    Ground        = "Погашение штрафов за просроченный основной долг";
  else
    tdr_penny_cat = tdr_penny_percR;
    Ground        = "Погашение штрафов за просроченные проценты";
  end;

  if ((ДатаВвода <= ExecDate) or ((ДатаВвода > ExecDate) 
        and СчетСделки(tdr_penny_cat, deal_pd.GetTick().DealID, Account, ExecDate, NULL, true)))

    ПолучитьОстатокСчета(deal_pd, tdr_penny_cat, NULL, 1, НачШтраф, ExecDate, deal_pd.GetLeg().PFI);
    if (KvitAmounts(i) > НачШтраф)
      // начисление неустоек
      InsertDocs(deal_pd, PlanPayms(i).Purpose, (KvitAmounts(i)-НачШтраф));
    end;

    return UNI_InsertDocs (i, NULL, tdr_penny_cat, NULL, NULL, KvitAmounts(i), NULL, NULL, Ground);
  else
    return UNI_InsertDocs (i, NULL, tdr_pennyR, NULL, NATCUR, KvitAmounts(i), NULL, NULL, Ground);
  end;
END;

/**
  @brief Основная функция, формирующая проводки в соответствии с назначением платежа
  @param[in] i - Индекс платежа в массиве FactPayms/PlanPayms/KvitAmounts (массивы имеют одинаковую размерность)
  @return true - Проводка сформирована успешно
  @return false - Проводка сформирована с ошибками
*/
PRIVATE MACRO InsertDocs(i)
  if (KvitAmounts(i) == 0)
      return true;
  end;

  RSDCommand("truncate table dmmnalog_tmp").execute();

  if (PlanPayms(i).Purpose == PM_PURP_PRINC)
      return InsertDocsPrinc (i);
  elif (PlanPayms(i).Purpose == PM_PURP_PRINC_RET)
      return InsertDocsPrinc (i);
  elif (PlanPayms(i).Purpose == PM_PURP_PERCENT)
      return InsertDocsPercent (i);
  elif (PlanPayms(i).Purpose == PM_PURP_OVD_PRINC)
      return InsertDocsOvdPrinc (i);
  elif (PlanPayms(i).Purpose == PM_PURP_OVD_PERC)
      return InsertDocsOvdPerc (i);
  elif (PlanPayms(i).Purpose == PM_PURP_PENALTY_PRINC)
      return InsertDocsPenalty (i);
  elif (PlanPayms(i).Purpose == PM_PURP_PENALTY_PERC)
      return InsertDocsPenalty (i);
  elif (PlanPayms(i).Purpose == PM_PURP_COMRECEIVING)
      return InsertDocsComReceiving (i);
  elif (PlanPayms(i).Purpose == PM_PURP_OVD_COMRECEIVING)
      return InsertDocsComOvdReceiving (i);
  end;

  return true;
END;

/**
  @brief Исполнение всех платежей из массива PLanIDs
*/
PRIVATE MACRO InsertAllDocs
  VAR i = 0;

  while( i < PlanIDs.size )
      if (not InsertDocs (i))
          return false;
      else
        PlanPayms(i).FuturePayerAccount    = PlanFuturePayerAccounts(i);
        PlanPayms(i).FutureReceiverAccount = PlanFutureReceiverAccounts(i);
        FactPayms(i).FuturePayerAccount    = FactFuturePayerAccounts(i);
        FactPayms(i).FutureReceiverAccount = FactFutureReceiverAccounts(i);
      end;
      i = i + 1;
  end;
  
  return true;
END;

/**
  @brief Выполнение шага
  @param[in] Buffer - Буфер временного файла операций
  @param[in] Document - Первичный документ операции (dl_tick.dbt)
  @param[in] DocKind - Тип первичного документа (DL_IBCDOC)
  @param[in] IdOperation - идентификатор операции
  @param[in] IdStep - идентификатор шага
  @return 0 - Шаг выполнен успешно
  @return КодОшибки - При выполнении шага возникли ошибки
*/
MACRO ExecuteStep( Buffer, Document, DocKind, IDOperation, IDStep)
  VAR BankruptStatus = 0, rvstat = 0;

  record deal( dl_tick );

  SetBuff( deal, Document );
  DL_PrepareCarryBuffer (Buffer);

  ID_Operation = IDOperation;
  ID_Step      = IDStep;

  deal_pd = MMFirstDoc(DL_IBCDOC, deal.DealID, true);
  
  if (CheckExistence(LEG_LegKind_DealID_LegID, LEG_KIND_DL_TICK, deal.DealID, 1))
      mm_error( "Не найден транш сделки ", deal.DealCode );
      return 1;
  end;

  if (KvitAmounts[0] < $0)
      return 1;
  end;

  if (not GetAllPayms)
      return 1;
  end;

  rvstat = GetPartyBankruptStatus(deal.PartyID, {curdate}, @BankruptStatus);
  if((rvstat == 0) AND (BankruptStatus != 10))
    ContrIsBankrupt = true;
  else
    ContrIsBankrupt = false;
  end;

  if (FactIDs(0) == 0)
      /*Симуляция исполнения - фактический платеж создаем сами*/
      if (not MakeFactPaym ())
          return 1;
      end;
  else                                                                                  
      if (not KvitPayms)
          return 1;
      end;
  end;

  if (not InsertAllDocs)
      return 1;
  end;

  return 0;
END;

NameMacroFile = "mme_j.mac";
