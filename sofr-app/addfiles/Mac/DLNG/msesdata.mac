import XmlRpcInter, rcw, oralib, likepy, dlutils;

private const LOCK_WAIT_TIME = 120;

class MSesData(ProcessId, SepConection)
  private var m_processId = ProcessId;
  private var m_lockObject = null;

  private var m_connection = RslDefCon;

  if ((ValType(SepConection) == V_BOOL) and SepConection)
    var env = RsdEnvironment( "RDDrvO", "RDDrvO.dll" );
    var ConString = GetIniString("CONNSTRING", "rsreq.ini");
    m_connection = RsdConnection(env, ConString);
  end;

  macro StoreOrReplObj(obj)
    var className = StrUpr(GenClassName(obj));
    var xmlRpc;
    if (ConvertToXML(obj, "", xmlRpc))
      RunError("Не удалось преобразовать объект в XML");
    end;

    var query = 
       " MERGE INTO DMSESDATA_DBT c "
      +"      USING (SELECT :processid AS T_PROCESSID, :classname AS T_CLASSNAME, :strid AS T_STRID, :data as T_DATA "
      +"               FROM DUAL) d "
      +"         ON (c.T_PROCESSID = d.T_PROCESSID AND c.T_CLASSNAME = d.T_CLASSNAME AND c.T_STRID = d.T_STRID) "
      +" WHEN MATCHED "
      +" THEN "
      +"    UPDATE SET c.T_DATA = d.T_DATA "
      +" WHEN NOT MATCHED "
      +" THEN "
      +"    INSERT     (c.T_PROCESSID, "
      +"                c.T_CLASSNAME, "
      +"                c.T_STRID, "
      +"                c.T_DATA) "
      +"        VALUES (d.T_PROCESSID, "
      +"                d.T_CLASSNAME, "
      +"                d.T_STRID, "
      +"                d.T_DATA) ";
    execSQLSepCon(query, m_connection, MakeArray(SQLParam("processid", m_processId), SQLParam("classname", className), SQLParam("strid", obj.GetStrId()), SQLParam("data", xmlRpc) ));
  end;

  macro GetObjFromDbByClassAndStrId(className, strId)
    var query =
      " SELECT LENGTH (T_DATA) AS len, T_DATA "
     +"   FROM DMSESDATA_DBT "
     +"  WHERE     T_PROCESSID = :processid "
     +"        AND T_CLASSNAME = :classname "
     +"        AND T_STRID = :strid ";
    var rs = execSQLselectSepCon(query, 
                                 m_connection,
                                 makeArray(
                                   SQLParam("processid", m_processId),
                                   SQLParam("classname", StrUpr(className)),
                                   SQLParam("strid", strId)
                                 ), true );
    if (rs.MoveNext())
      var DataXml = "";
      rs.Fld("t_Data").Read(DataXml, int(rs.value("len")));
      var logRec = TXRLogRecord();
      logRec.messageText = DataXml;
      var mesObj = logRec.getMessageObject();
      var newObj = GenObject(StrUpr(className));
      for (var curProp, GetObjProps(newObj))
        GenSetProp(newObj, curProp, GenGetProp(mesObj, curProp));
      end;
      return newObj;
    else
      return null;
    end;
  end;

  macro DeleteClassData(className)
    execSQLSepCon("delete from DMSESDATA_DBT where T_PROCESSID = :processid and T_CLASSNAME = :classname", m_connection, makeArray(SQLParam("processid", m_processId),SQLParam("classname", StrUpr(className))),true);
  end;

  macro GetObjFromDbByObj(obj)
    return GetObjFromDbByClassAndStrId(GenClassName(obj), obj.GetStrId());
  end;

  macro GetObjListByClassName(className)
    var objList = TArray();
    var query =
      " SELECT T_STRID "
     +"   FROM DMSESDATA_DBT "
     +"  WHERE     T_PROCESSID = :processid "
     +"        AND T_CLASSNAME = :classname ";
    var rs = execSQLselectSepCon(query, 
                                 m_connection,
                                 makeArray(
                                   SQLParam("processid", m_processId),
                                   SQLParam("classname", StrUpr(className))
                                 ), true );
    while (rs.moveNext())
      objList[objList.size] = GetObjFromDbByClassAndStrId(className, rs.value("T_STRID"));
    end;

    return objList;
  end;

  macro LockByObjStrId(obj)
    var className = StrUpr(GenClassName(obj));
    var lockId = string(m_processId) + ":::" + className + ":::" + obj.GetStrId();
    m_lockObject = UniConcurrentLocker(lockId, LOCK_WAIT_TIME, null, true);
    if (not m_lockObject.Lock())
      RunError("Не удалось заблокировать " + lockId)
    end;
  end;

  macro LockById(id)
    var lockId = string(m_processId) + ":::" + id;
    m_lockObject = UniConcurrentLocker(lockId, LOCK_WAIT_TIME, null, true);
    if (not m_lockObject.Lock())
      RunError("Не удалось заблокировать " + lockId)
    end;
  end;

  macro LockByObjClassName(obj)
    var className = StrUpr(GenClassName(obj));
    var lockId = string(m_processId) + ":::" + className;
    m_lockObject = UniConcurrentLocker(lockId, LOCK_WAIT_TIME, null, true);
    if (not m_lockObject.Lock())
      RunError("Не удалось заблокировать " + lockId)
    end;
  end;

  macro LockByClassName(className)
    var lockId = string(m_processId) + ":::" + StrUpr(className);
    m_lockObject = UniConcurrentLocker(lockId, LOCK_WAIT_TIME, null, true);
    if (not m_lockObject.Lock())
      RunError("Не удалось заблокировать " + lockId)
    end;
  end;

  macro Unlock()
    m_lockObject = null;
  end;

  macro Destructor()
    Unlock();
  end;
end;

class MSesDataCreator()
  private var m_processId = SubStr(CreateGUID, 2, 36);

  macro Destructor()
    execSql("delete from DMSESDATA_DBT where T_PROCESSID = :processid", makeArray(SQLParam("processid", m_processId)),true);
  end;

  macro GetProcessId()
    return m_processId;
  end;

  macro CreateMSesClass()
    return MSesData(m_processId);
  end;

  macro CheckHasData()
    var rs = execSQLselect("select 1 from dual where exists (select 1 from DMSESDATA_DBT where T_PROCESSID = :processid)", makeArray(SQLParam("processid", m_processId)), true );
    return rs.MoveNext();
  end;
end;

class MSesDeleteDataOnDestructor(ProcessId)
  private var m_processId = ProcessId;
  private var m_issuccess = false;
  private var m_classdatatodel = TArray();

  macro AddClassDataToDel(classdataname)
    m_classdatatodel[m_classdatatodel.size] = classdataname;
  end;

  macro Success()
    m_issuccess = true;
  end;

  macro Destructor()
    if ((not m_issuccess) and (m_processId != null))
      var i = -1;
      var mses = MSesData(m_processId, true);
      while ((i=i+1) < m_classdatatodel.size)
        mses.DeleteClassData(m_classdatatodel[i]);
      end;
    end;
  end;
end;