//nontrading_orders_quik_messages.mac
//Формирование и отправка json-сообщений в QUIK по неторговым поурчениям
import "rs_json.mac", oralib, likepy, "nontrading_orders_subcontr.mac", "cblogger2.mac", DealsInter;
import "CurrencyNotesClass.mac", "commonutil.mac", "nontrading_transfer_accounts.mac", globals;

private var logger = NewLogger(c_logger.IT_LOG_TYPE, "NONTRADING_ORDERS_QUIK_MESSAGES.MAC");

//Получить время в формате: ГГГГ-ММ-ДДTЧЧ:ММ:ССZ
private macro getDateTimeString():string
  var day, mon, yy, hh, mn, sec;
  DateSplit(date, day, mon, yy);
  TimeSplit(time, hh, mn, sec);
  return string(yy, "-", mon:o:2, "-", day:o:2, "T", hh:o:2, ":", mn:0:2, ":", sec:o:2, "Z");
end;

class RecordCodeStruct(val:string)
  var RecordCode:string = val;
end;

/*класс объекта для преобразования в строку JSON
  CheckType - 0-поручение не проверяется, а сразу исполняется, 1-поручение подается на сервер с помощью QuikAPI 
*/
class UpdateQuikLimitsNewInstrMonReqStruct() 
  var GUID               :string  = "";
  var RequestTime        :string  = getDateTimeString;
  var ExtID              :string  = "";  ////<Идентификатор поручения, который может использоваться брокером для внутренних целей
  var ClientID           :string  = "";  ///<Код клиента, используемый для формироания внутренних лимитов
  var ClientBuyID        :string  = "";
  var Benefactor         :string  = "";
  var MiddleMan          :string  = "";
  var AgreeServ          :string  = "";
  var Volume             :string  = "";
  var ValFee             :string  = 0;
  var ValDepoPay         :string  = 0;
  var ValCashPay         :string  = 0;
  var PayNumber          :string  = "";
  var OutSecCode         :string  = "";
  var InSecCode          :string  = "";
  var CanSplit           :string  = 0;
  var BlockM             :string  = 0;
  var FirmID             :string  = "MC0134700000";
  var SignFlag           :string  = 4;
  var InOrder            :string  = "";
  var TradeSystem        :string  = "";
  var CheckType          :string  = "";
  var DocComment         :string  = "";
  var BenefacRegCBDiv    :string  = "";
  var MoneyAccount       :string  = "";
  var MoneySubAccount    :string  = "";
  var MoneySubAccount2   :string  = "";
  var InstrRate          :string  = 1;
  var FirmRecipientID    :string  = 0;
  var MaxValidDate       :string  = "";
  var BrokerComment      :string  = "";
  var InternalNumber     :string  = "";
  var PhysAccID          :string  = 0;
  var PhysAccCode        :string  = "";
  var AgreeServ2         :string  = "";
  var InstructionType    :RecordCodeStruct = RecordCodeStruct("");
end;

class MoneyOrderQuikTypes
  const WRITEOFF = 0;
  const ENROLL   = 1;
  const TAX      = 2;
end;

private macro GetSecCode (fiid:integer):string
  var secCode:string = "";
  var query = "select f.t_ccy "
            + "  from dfininstr_dbt f "
            + " where f.t_fiid = :fiid ";
  var sql = ExecSQLselectPrmDyn(query, fiid);
  if (sql.MoveNext())
    secCode = sql.value("t_ccy");
  end;

  return secCode;
end;

//возвращает дату в формате YYYYDDMM
private macro FormatDate(dt:date)
  var dd, mm, yy;
  DateSplit(dt, dd, mm, yy);
  return string(yy, dd:o:2, mm:o:2);
end;

private macro GetPartyLegalForm(partyID:integer)
  var query = "select p.t_legalform "
            + "  from dparty_dbt p "
            + " where p.t_partyid = :partyid";
  var sql = ExecSQLselectPrmDyn(query, partyID);
  if (sql.MoveNext())
    return sql.value("t_legalform");
  end;
  return null;
end;

//template
//будет всего 3 реализуюших класса: EnrollQuikJSONMessageBuilder, WithdrawalQuikJSONMessageBuilder, WithdrawalTaxQuikJSONMessageBuilder
//У них очень много общего, но дублирование кода остаётся осознанным, чтобы было проще читать. 
private class QuikJSONMessageBuilder
  var UpdateQuikLimitsNewInstrMonReq:UpdateQuikLimitsNewInstrMonReqStruct = UpdateQuikLimitsNewInstrMonReqStruct();

  //guid - глобальный гуид сообщения, по нему можно отследить движение в логах.
  //extID - локальный ид, только в рамках данного механизма. для квика служит уникальным ИД.
  macro MakeJson(nptxopID:integer, guid:string, extID:integer):string
    return "";
  end;

  private macro GetTradeSystem(marketID:integer, servKind:integer):string
    var tradeSystem:string = "";
    if ((marketID == 2) and (servKind == 1))  ///<Фондовый ММВБ
      tradeSystem = "EQTV";
    elif ((marketID == 2) and (servKind == 21))  ///<Валютный ММВБ
      tradeSystem = "RTOD";
    elif ((marketID == 151337) and (servKind == 1))  ///<Фондовый СПБ
      tradeSystem = "ZICB";
    elif ((marketID == 2) and (servKind == 15))  ///<Срочный ММВБ
      tradeSystem = "SPBFUT";
    end;

    return tradeSystem;
  end;
end;

private class (QuikJSONMessageBuilder) EnrollQuikJSONMessageBuilder

  private macro GetPayNumber(nptxopID:integer):string
    CaptureOutput;
    [
    select nvl(case
                when p.t_legalform = 2
                  then (select t_biscottoid
                          from (select ub.t_biscottoid
                                  from upmbiscotto_dbt ub
                                  join usr_acc306enroll_dbt ep on ub.t_pmid = ep.t_enrollid
                                 where ep.t_nptxopid = o.t_id
                                   and ub.t_dockind = 5002
                                   and rownum = 1
                                union all
                                select ub.t_biscottoid
                                  from upmbiscotto_dbt ub
                                 where ub.t_pmid = o.t_id
                                   and ub.t_dockind = o.t_dockind
                                   and rownum = 1
                                   )
                         where rownum = 1 )
                when p.t_legalform = 1
                  then (select ub.t_biscottoid
                          from upmbiscotto_dbt ub
                         where ub.t_pmid = o.t_id
                           and ub.t_dockind = o.t_dockind
                           and rownum = 1)
              end, o.t_code)  pay_number
      from dnptxop_dbt o
      join dparty_dbt p on p.t_partyid = o.t_client
     where o.t_id = :opid
    ];
    var query = StopCaptureOutput;
    var sql = ExecSQLselectPrmDyn(query, nptxopID);
    if (sql.MoveNext())
      return sql.value("pay_number");
    end;
    return "";
  end;

  macro MakeJson(nptxopID:integer, guid:string, extID:integer):string
    var nptxopFile = TBFile("nptxop.dbt","r");
    var sfContr:NonTradingOrderSubcontr;
    
    nptxopFile.rec.ID = nptxopID;
    if (not nptxopFile.GetEQ() )
      return "";
    end;
    var nptxop = nptxopFile.rec;
    var currencyNotes:CurrencyNotesClass = CurrencyNotesClass(nptxop.currency);

    if (nptxop.subkind_operation == DL_NPTXOP_WRTKIND_ENROL)
      sfContr = NonTradingOrderSubcontr(nptxop.Contract);
      UpdateQuikLimitsNewInstrMonReq.MoneyAccount    = nptxop.account;
      UpdateQuikLimitsNewInstrMonReq.BrokerComment   = "Зачисление д/с в СОФР";
      UpdateQuikLimitsNewInstrMonReq.PayNumber       = GetPayNumber(nptxop.ID);//nptxop.code;
    elif (nptxop.subkind_operation == DL_NPTXOP_WRTKIND_TBSABC)
      UpdateQuikLimitsNewInstrMonReq.MoneyAccount    = NontradingTransferAccounts.GetEnrollAccount(nptxop.ID);
      sfContr = NewNonTradingOrderSubcontrByAccount(UpdateQuikLimitsNewInstrMonReq.MoneyAccount, {curdate});
      UpdateQuikLimitsNewInstrMonReq.BrokerComment   = "Перевод д/с между субсчетами в СОФР";
      UpdateQuikLimitsNewInstrMonReq.PayNumber       = nptxop.code;
    end;

    UpdateQuikLimitsNewInstrMonReq.GUID            = guid;
    UpdateQuikLimitsNewInstrMonReq.ExtID           = extID;
    UpdateQuikLimitsNewInstrMonReq.ClientID        = sfContr.GetMpCode();
    UpdateQuikLimitsNewInstrMonReq.AgreeServ       = sfContr.GetContrNum();
    UpdateQuikLimitsNewInstrMonReq.OutSecCode      = "";
    UpdateQuikLimitsNewInstrMonReq.MaxValidDate    = FormatDate(nptxop.operDate);
    UpdateQuikLimitsNewInstrMonReq.InternalNumber  = nptxop.code;
    UpdateQuikLimitsNewInstrMonReq.InstructionType = RecordCodeStruct("0");
    UpdateQuikLimitsNewInstrMonReq.Volume          = strSubst(string(nptxop.outsum*100),".00","");

    var authorizationThreshold = currencyNotes.GetAuthorizationThreshold();
    if ((authorizationThreshold > 0) and (nptxop.outsum < authorizationThreshold))
      UpdateQuikLimitsNewInstrMonReq.CheckType     = "0"
    else
      UpdateQuikLimitsNewInstrMonReq.CheckType     = "1";
    end;

    if (sfContr.IsEDP())
      UpdateQuikLimitsNewInstrMonReq.TradeSystem = "EQTV";
    else
      UpdateQuikLimitsNewInstrMonReq.TradeSystem = GetTradeSystem(sfContr.GetMarketID(), sfContr.GetServKind());
      if ((sfContr.GetMarketID() == 2) and (sfContr.GetServKind() == 15))
        UpdateQuikLimitsNewInstrMonReq.ClientID  = "CL" + UpdateQuikLimitsNewInstrMonReq.ClientID;        
      end;
    end;
    UpdateQuikLimitsNewInstrMonReq.InSecCode = "RUR" + ifThenElse(nptxop.currency == 0, "", GetSecCode(nptxop.currency)) + UpdateQuikLimitsNewInstrMonReq.TradeSystem;

    var firmID:string = "";
    var legalform:integer = GetPartyLegalForm(nptxop.Client);

    // для ЮЛ на Срочном рынке перезапишем InSecCode
    // QUIK не в состоянии сделать у себя адекватный адаптер, который будет получать адекватные данные
    // и преобразовывать под свою специфику. Поэтому, приходится писать логику квика на софре
    if ((legalform == 1) and (sfContr.GetServKind() == 15))  ///<юридическое лицо на срочном рынке
      firmID = sfContr.GetFirmID();
      UpdateQuikLimitsNewInstrMonReq.FirmID    = UpdateQuikLimitsNewInstrMonReq.TradeSystem + firmID;
      UpdateQuikLimitsNewInstrMonReq.InSecCode = UpdateQuikLimitsNewInstrMonReq.InSecCode + substr(firmID, strlen(firmID)-2,3); //последние 3 символа от firmID
    end;

    return jsn.ClassToStr(this);
  OnError(e)
    logger.ErrorClob("EnrollQuikJSONMessageBuilder. MakeJson. nptxopid = " + nptxopID,  GetFullErrMsg(e));
    return "";
  end;
end;

private class (QuikJSONMessageBuilder) WithdrawalQuikJSONMessageBuilder
  macro MakeJson(nptxopID:integer, guid:string, extID:integer):string
    var nptxopFile = TBFile("nptxop.dbt","r");
    var sfContr:NonTradingOrderSubcontr;

    nptxopFile.rec.ID = nptxopID;
    if (not nptxopFile.GetEQ() )
      return "";
    end;
    var nptxop = nptxopFile.rec;

    if (nptxop.subkind_operation == DL_NPTXOP_WRTKIND_WRTOFF)
      sfContr = NonTradingOrderSubcontr(nptxop.Contract);
      UpdateQuikLimitsNewInstrMonReq.BrokerComment   = "Списание д/с в СОФР";
    elif (nptxop.subkind_operation == DL_NPTXOP_WRTKIND_TBSABC)
      sfContr = NewNonTradingOrderSubcontrByAccount(NontradingTransferAccounts.GetWithdrawalAccount(nptxop.ID), {curdate});
      UpdateQuikLimitsNewInstrMonReq.BrokerComment   = "Перевод д/с между субсчетами в СОФР";
    end;

    UpdateQuikLimitsNewInstrMonReq.GUID            = guid;
    UpdateQuikLimitsNewInstrMonReq.ExtID           = extID;
    UpdateQuikLimitsNewInstrMonReq.ClientID        = sfContr.GetMpCode();
    UpdateQuikLimitsNewInstrMonReq.AgreeServ       = sfContr.GetContrNum();
    UpdateQuikLimitsNewInstrMonReq.InSecCode       = "";
    UpdateQuikLimitsNewInstrMonReq.CheckType       = "0";
    UpdateQuikLimitsNewInstrMonReq.MaxValidDate    = FormatDate(nptxop.operDate);
    UpdateQuikLimitsNewInstrMonReq.PayNumber       = nptxop.code;
    UpdateQuikLimitsNewInstrMonReq.InternalNumber  = nptxop.code;
    UpdateQuikLimitsNewInstrMonReq.InstructionType = RecordCodeStruct("5");
    UpdateQuikLimitsNewInstrMonReq.Volume          = strSubst(string(nptxop.taxsum2*100),".00","");
    UpdateQuikLimitsNewInstrMonReq.MoneyAccount    = nptxop.account;

    if (sfContr.IsEDP())
      UpdateQuikLimitsNewInstrMonReq.TradeSystem = "EQTV";
    else
      UpdateQuikLimitsNewInstrMonReq.TradeSystem = GetTradeSystem(sfContr.GetMarketID(), sfContr.GetServKind());
      if ((sfContr.GetMarketID() == 2) and (sfContr.GetServKind() == 15))
        UpdateQuikLimitsNewInstrMonReq.ClientID  = "CL" + UpdateQuikLimitsNewInstrMonReq.ClientID;        
      end;
    end;
    UpdateQuikLimitsNewInstrMonReq.OutSecCode   = "RUR" + ifThenElse(nptxop.currency == 0, "", GetSecCode(nptxop.currency)) + UpdateQuikLimitsNewInstrMonReq.TradeSystem;

    var firmID:string = "";
    var legalform:integer = GetPartyLegalForm(nptxop.Client);

    // для ЮЛ на Срочном рынке перезапишем OutSecCode
    // QUIK не в состоянии сделать у себя адекватный адаптер, который будет получать адекватные данные
    // и преобразовывать под свою специфику. Поэтому, приходится писать логику квика на софре
    if ((legalform == 1) and (sfContr.GetServKind() == 15))  ///<юридическое лицо на срочном рынке
      firmID = sfContr.GetFirmID();
      UpdateQuikLimitsNewInstrMonReq.FirmID     = UpdateQuikLimitsNewInstrMonReq.TradeSystem + firmID;
      UpdateQuikLimitsNewInstrMonReq.OutSecCode = UpdateQuikLimitsNewInstrMonReq.OutSecCode + substr(firmID, strlen(firmID)-2,3); //последние 3 символа от firmID
    end;

    return jsn.ClassToStr(this);
  OnError(e)
    logger.ErrorClob("WithdrawalQuikJSONMessageBuilder. MakeJson. nptxopid = " + nptxopID,  GetFullErrMsg(e));
    return "";
  end;
end;

/* НДФЛ всегда по валютке
   Срочка всегда с рублями
   => нет смысла в ндфл обрабатывать срочку, потому что такого не может случиться
*/
private class (QuikJSONMessageBuilder) WithdrawalTaxQuikJSONMessageBuilder
  macro MakeJson(nptxopID:integer, guid:string, extID:integer):string
    var nptxopFile = TBFile("nptxop.dbt","r");
    var sfContr:NonTradingOrderSubcontr;

    nptxopFile.rec.ID = nptxopID;
    if (not nptxopFile.GetEQ() )
      return "";
    end;
    var nptxop = nptxopFile.rec;

    sfContr = NonTradingOrderSubcontr(nptxop.Contract);
    UpdateQuikLimitsNewInstrMonReq.BrokerComment   = "Списание д/с в СОФР";
    UpdateQuikLimitsNewInstrMonReq.GUID            = guid;
    UpdateQuikLimitsNewInstrMonReq.ExtID           = extID;
    UpdateQuikLimitsNewInstrMonReq.ClientID        = sfContr.GetMpCode();
    UpdateQuikLimitsNewInstrMonReq.AgreeServ       = sfContr.GetContrNum();
    UpdateQuikLimitsNewInstrMonReq.InSecCode       = "";
    UpdateQuikLimitsNewInstrMonReq.CheckType       = "0";
    UpdateQuikLimitsNewInstrMonReq.MaxValidDate    = FormatDate(nptxop.operDate);
    UpdateQuikLimitsNewInstrMonReq.PayNumber       = nptxop.code;
    UpdateQuikLimitsNewInstrMonReq.InternalNumber  = nptxop.code;
    UpdateQuikLimitsNewInstrMonReq.InstructionType = RecordCodeStruct("5");
    UpdateQuikLimitsNewInstrMonReq.Volume          = strSubst(string(nptxop.tax*100),".00","");
    UpdateQuikLimitsNewInstrMonReq.MoneyAccount    = nptxop.accounttax;

    if (sfContr.IsEDP())
      UpdateQuikLimitsNewInstrMonReq.TradeSystem = "EQTV";
    else
      UpdateQuikLimitsNewInstrMonReq.TradeSystem = GetTradeSystem(sfContr.GetMarketID(), sfContr.GetServKind());
    end;
    UpdateQuikLimitsNewInstrMonReq.OutSecCode = "RUR" + UpdateQuikLimitsNewInstrMonReq.TradeSystem;

    return jsn.ClassToStr(this);
  OnError(e)
    logger.ErrorClob("WithdrawalTaxQuikJSONMessageBuilder. MakeJson. nptxopid = " + nptxopID,  GetFullErrMsg(e));
    return "";
  end;
end;

private class QuikJSONMessageBuilderFactory
  macro GetBuilder(orderType:integer):QuikJSONMessageBuilder
    var builder:QuikJSONMessageBuilder = QuikJSONMessageBuilder();

    if (orderType == MoneyOrderQuikTypes.WRITEOFF)
      builder = WithdrawalQuikJSONMessageBuilder();
    elif (orderType == MoneyOrderQuikTypes.ENROLL)
      builder = EnrollQuikJSONMessageBuilder();
    elif (orderType == MoneyOrderQuikTypes.TAX)
      builder = WithdrawalTaxQuikJSONMessageBuilder();
    end;

    return builder;
  end;
end;

private class MoneyOrderQuikStruct(_operID:integer, _type:integer)
  var operationID:integer = _operID;
  var type:integer        = _type;
end;

class MoneyOrderQuikController()
  private var preparedOrders = TArray();

  macro PrepareWriteOff(operationID:integer)
    preparedOrders(preparedOrders.size) = MoneyOrderQuikStruct(operationID, MoneyOrderQuikTypes.WRITEOFF);
  end;

  macro PrepareEnroll(operationID:integer)
    preparedOrders(preparedOrders.size) = MoneyOrderQuikStruct(operationID, MoneyOrderQuikTypes.ENROLL);
  end;

  macro PrepareTax(operationID:integer)
    preparedOrders(preparedOrders.size) = MoneyOrderQuikStruct(operationID, MoneyOrderQuikTypes.TAX);
  end;

  macro getPreparedOrders()
    return preparedOrders;
  end;

  macro SaveAll()
    var order;
    var params = TArray();
    var insert_query = "insert into quik_sent_order_messages (msg_id, "
                     + "                                      order_type, "
                     + "                                      operation_id, "
                     + "                                      msg_guid, "
                     + "                                      create_time) "
                     + "  values (quik_sent_order_mess_seq.nextval, "
                     + "          :order_type, "
                     + "          :operation_id, "
                     + "          it_q_message.get_sys_guid, "
                     + "          systimestamp) ";

    for (order, preparedOrders)
      params = TArray();
      params(params.size) = SqlParam("order_type", order.type);
      params(params.size) = SqlParam("operation_id", order.operationID);
      ExecSql(insert_query, params);
    end;

    preparedOrders = TArray();
  end;

  private macro Send(msgID:integer, msgGUID:string, jsonValue:string):bool
    var params:TArray = TArray();
    params[0] = SQLParam( "p_msgID",     msgGUID   );
    params[1] = SQLParam( "p_JSON",      jsonValue );
    params[2] = SQLParam( "o_ErrorCode", V_INTEGER, RSDBP_OUT );
    params[3] = SQLParam( "o_ErrorDesc", V_STRING,  RSDBP_OUT );
    execStoredFunc( "it_quik.LimitsNewInstrMonReq", V_UNDEF, params);

    var errCode = params.Value(2).value;
    var errDesc = params.Value(3).value;
    if (errCode != 0) 
      logger.Error("MoneyOrderQuikController. Send. msgID = " + msgID + ". " + errDesc);
      return false;
    end;
    return true;
  end;

  private macro SetRequestTime(msgID:integer)
    ExecSql("update quik_sent_order_messages m set request_time = systimestamp where m.msg_id = :msgid", MakeArray(SqlParam("msgid", msgID)));
  end;

  macro SendByOperation(operationID:integer):bool
    var isSuccessfull:bool = true;
    var query = "select m.msg_id, "
              + "       m.order_type, "
              + "       m.msg_guid "
              + "  from quik_sent_order_messages m "
              + " where m.operation_id = :operid "
              + "   and m.request_time is null";
    var sql = ExecSQLselectPrmDyn(query, operationID);
    var jsonBuilder:QuikJSONMessageBuilder;
    var jsonMsg:string;

    while (sql.MoveNext() )
      jsonBuilder = QuikJSONMessageBuilderFactory().GetBuilder(sql.value("order_type"));
      jsonMsg = jsonBuilder.MakeJSON(operationID, sql.value("msg_guid"), sql.value("msg_id"));
      if (jsonMsg != "")
        if (not Send(sql.value("msg_id"), sql.value("msg_guid"), jsonMsg))
          isSuccessfull = false;
        end;
        SetRequestTime(sql.value("msg_id"));
      else
        logger.Error("MoneyOrderQuikController. SendByOperation. msgID = " + sql.value("msg_id") + ". empty json");
        isSuccessfull = false;
      end;
    end;

    return isSuccessfull;
  OnError(e)
    logger.ErrorClob("MoneyOrderQuikController. SendByOperation. nptxopid = " + operationID,  GetFullErrMsg(e));
    return false;
  end;

  //AVT_BOSS-576 Метод необходим для повторной отправки сообщения по той же операции, сообщение создаётся новое, новая запись в таблице quik_sent_order_messages.
  //Существующий метод SendByOperation данный функционал не поддерживает.
  macro SaveAndResendLastMessageForOperation(operationID:integer):bool
    var isSuccessfull:bool = true;

    SaveAll(); //создаём новую запись о сообщении для операции по которой переотправляем, чтобы не терять старое сообщение в случае получение ответа по нему
    var query = "select m.msg_id, "
              + "       m.order_type, "
              + "       m.msg_guid "
              + "  from quik_sent_order_messages m "
              + " where m.operation_id = :operid "
              + " order by m.msg_id desc fetch first 1 rows only;";
    var sql = ExecSQLselectPrmDyn(query, operationID);
    var jsonBuilder:QuikJSONMessageBuilder;
    var jsonMsg:string;

    while (sql.MoveNext() )
      jsonBuilder = QuikJSONMessageBuilderFactory().GetBuilder(sql.value("order_type"));
      jsonMsg = jsonBuilder.MakeJSON(operationID, sql.value("msg_guid"), sql.value("msg_id"));
      if (jsonMsg != "")
        if (not Send(sql.value("msg_id"), sql.value("msg_guid"), jsonMsg))
          isSuccessfull = false;
        end;
        SetRequestTime(sql.value("msg_id"));
      else
        logger.Error("MoneyOrderQuikController. SaveAndResendLastMessageForOperation. msgID = " + sql.value("msg_id") + ". empty json");
        isSuccessfull = false;
      end;
    end;

    return isSuccessfull;
  OnError(e)
    logger.ErrorClob("MoneyOrderQuikController. SaveAndResendLastMessageForOperation. nptxopid = " + operationID,  GetFullErrMsg(e));
    return false;

  end;


  //Проверяет наличие поручений по операции
  macro IsExists(operationID:integer, orderType:integer)
    var query = "select 1 "
              + "  from quik_sent_order_messages m "
              + "where m.operation_id = :operid "
              + "  and m.order_type = :ordertype";
    var sql = ExecSQLselectPrmDyn(query, operationID, orderType);

    return sql.MoveNext();
  end;

  macro SaveAndSendByOperation(operationID:integer):bool
    //Если нет поручений для сохранения, то не смылса пытаться сохранить и отправить их
    if (preparedOrders.Size() == 0) 
      return true;
    end;
    SaveAll();
    return SendByOperation(operationID);
  end;

  // Если от квика пришёл ответ без ошибок, то в quik_sent_order_messages.error_descr будет null, который превращается в "Успешно"
  // Если от квика ещё не пришёл ответ, то в quik_sent_order_messages.error_descr будет null, которые превлащается в "null"
  // Если от квика пришёл ответ с описанием ошибки, то описание будет в quik_sent_order_messages.error_descr
  // Если поручение даже не отправляли, то в переменной result так и останется ""
  macro GetQUIKResult(operationID:integer, orderType:integer):string
    var result = "";
    var query = "select nvl(m.error_descr, case when m.response_time is not null then 'Успешно' else 'null' end) error_descr "
              + "  from quik_sent_order_messages m "
              + " where m.operation_id = :operationid "
              + "   and m.order_type = :ordertype "
              + " order by m.create_time desc "
              + " fetch first 1 rows only ";
    var sql = ExecSQLselectPrmDyn(query, operationID, orderType);
    if (sql.MoveNext() ) 
      result = sql.value("error_descr");
    end;

    return result;
  end;
end;