/*
$Name:        nptx_recalc_circ.mac
$Module:      Ядро Securities
$Description: Процедура пересчета обращаемости ц/б для НДФЛ
*/

import "dlmisc.mac", "dlreport.mac", "DlRepForm_h.mac", FIInter;
import "dlquery.mac";
import "dlutils.mac", "xls_parser.mac", "scsrvrepfun.mac";

CONST PNFLD_NPTXRECALCCIRCULATE_BEGDATE       = 0,
      PNFLD_NPTXRECALCCIRCULATE_ENDDATE       = 1,
      PNFLD_NPTXRECALCCIRCULATE_AVRCODE       = 2,
      PNFLD_NPTXRECALCCIRCULATE_AVRNAME       = 3,
      PNFLD_NPTXRECALCCIRCULATE_LOADFROMFILE  = 4,
      PNFLD_NPTXRECALCCIRCULATE_FILEPATH      = 5,
      PNFLD_NPTXRECALCCIRCULATE_RECALC        = 6,
      PNFLD_NPTXRECALCCIRCULATE_PROGRESS      = 7,
      PNFLD_NPTXRECALCCIRCULATE_PROTDIR       = 8;

PRIVATE CONST
  H_BEGDATE      = 100,
  H_ENDDATE      = 101,
  H_AVRCODE      = 102,
  H_AVRNAME      = 103,
  H_LOADFROMFILE = 104,
  H_FILEPATH     = 105,
  H_RECALC       = 106,
  H_PROGRESS     = 107,
  H_PROTDIR      = 108;

private MACRO DL_FldProc_CheckBox_Circ_File( pThis:DL_CPanel, Cmd:INTEGER, Key:INTEGER, FldShowValue:@VARIANT, FldRealValue:@VARIANT ):INTEGER
  if( Cmd == DLG_INIT )
     if( FldRealValue == null ) /*инициализация по умолчанию*/
        FldRealValue = "";
     end;
     FldShowValue = FldRealValue;
  elif( Cmd == DLG_CHANGEVALUE )
     FldRealValue = FldShowValue;
  elif( Cmd == DLG_KEY )
     if( Key == KEY_SPACE )
        if( FldRealValue != SET_CHAR )
           FldShowValue = FldRealValue = SET_CHAR;
           pThis.SetLinkedValue(DL_PNFLD_AVRCODE, -1);
        else
           FldShowValue = FldRealValue = UNSET_CHAR;
        end;
     end;
  end;
  if (FldRealValue == UNSET_CHAR)
    EnableFields( pThis.Data(), PNFLD_NPTXRECALCCIRCULATE_AVRCODE );
    DisableFields( pThis.Data(), PNFLD_NPTXRECALCCIRCULATE_FILEPATH);
  else
    DisableFields( pThis.Data(), PNFLD_NPTXRECALCCIRCULATE_AVRCODE );
    EnableFields( pThis.Data(), PNFLD_NPTXRECALCCIRCULATE_FILEPATH );
  end;
  return CM_DEFAULT;
END;

PRIVATE MACRO FldProc_File( pThis:DL_CPanel, Cmd:INTEGER, Key:INTEGER, FldShowValue:@VARIANT, FldRealValue:@VARIANT ):INTEGER
  if( Cmd == DLG_INIT ) /*Установка значения в поле*/
    if( FldRealValue == null ) /*инициализация по умолчанию*/
      FldRealValue = "";
    end;
    FldShowValue = FldRealValue;
  elif( Cmd == DLG_CHANGEVALUE ) 
     FldRealValue = FldShowValue;
  elif( (Cmd == DLG_KEY) AND (Key == KEY_F3) )
    var FilePath = "";
    var isTerm = false;
    if (not isStandalone())
      var choise = DL_Menu(makeArray("Терминал","Сервер"),"Где ищем файл?");
      if (choise == -1)
        return CM_DEFAULT;
      end;
      if (choise == 0)
        isTerm = true;
      end;
    end;
    if (not SelectFile ( FilePath, "*.xlsx,*.xls", "Выберите файл к обработке", 0, isTerm ))
      return CM_DEFAULT;
    end;
    FldRealValue = IIF(isTerm, "$", "") + FilePath;
    FldShowValue = FldRealValue;
  end;

  return CM_DEFAULT;
END;

private macro DL_FldProc_Protocol_Directory( pThis:DL_CPanel, Cmd:INTEGER, Key:INTEGER, FldShowValue:@VARIANT, FldRealValue:@VARIANT ):INTEGER
  if (Cmd == DLG_INIT)
    if((FldRealValue == null) or (FldRealValue == ""))
      if( FldRealValue == null )
         FldRealValue = "";
      end;
      if( FldRealValue == "" )
         FldShowValue = "";
      end;
    else
      FldShowValue = FldRealValue;
    end;
  elif( (Cmd == DLG_KEY) AND (Key == KEY_F3) ) // Вызов листалки и заполнение FldShowValue и FldRealValue
    var file_name = "";
    var path = FldRealValue;
    var len = strlen(path);

    if(len > 0)
      if(substr(path, len-2) != "\\*")
        path = path + "\\*";
      end;
    end;

    if(SelectFolder(file_name, path, "Укажите путь для сохранения протокола", true)) 
      FldRealValue = file_name;
      FldShowValue = FldRealValue;
    end;
  elif( (Cmd == DLG_KEY) AND (Key == KEY_SPACE) )
     FldRealValue = "";
     FldShowValue = "";
  end;

  return CM_DEFAULT;
end;

private macro LoadTempFiidFromFile(FilePath,protocol)
  var objExcel = CExcelPoi();
  var fileMov = TempFileToServerMover();
  fileMov.CreateTempFromAbsolutPath(FilePath);
  if (not objExcel.open(fileMov.GetTempFilePath()))
    RunError("Не удалось открыть excel файл " + FilePath);
  end;
  var lastRowNumb = objExcel.GetLastRowNum()+1;
  var curRow = 0;
  InitProgress(lastRowNumb, "Чтение файла со списком ц/б", "Чтение файла со списком ц/б");
  while ((curRow=curRow+1) <= lastRowNumb)
    var cellValue = objExcel.CellValue("A"+curRow);
    if (ValType(cellValue) == V_UNDEF)
      continue;
    end;
    var curRowData = Trim(string(cellValue));
    var dotIdx = Index(curRowData, ".");
    if (dotIdx > 0)
      curRowData = SubStr(curRowData, 1, dotIdx-1);
    end;

    var sql = ExecSqlselect("select T_FIID from DAVOIRISS_DBT where T_ISIN = "+GetSQLString(curRowData));
    if (sql.MoveNext() )
      execSQL("insert into DFIID_TMP (FIID) values (?)", makeArray(SQLParam("fiid", SQL_ConvTypeInteger(sql.value("t_fiid")))));
    else
      protocol.AddNotFoundIsin(curRowData);
    end;
    
    UseProgress(curRow);
  end;
  RemProgress();
end;

PRIVATE CLASS (DL_CReportTemplate) NptxRecalcCircProtocol_Report(periodFrom, periodTo)
  var m_periodFrom = periodFrom;
  var m_periodTo = periodTo;

  var m_NotFoundIsinArr = TArray();

  PRIVATE MACRO BeginReport()
    SetIsShowAppl(false);

    CreateTotalBook();
  END;

  MACRO PrintMode():INTEGER
    return DL_OUTREPORT_EXCEL;
  END;

  macro AddNotFoundIsin(isin)
    m_NotFoundIsinArr[m_NotFoundIsinArr.size] = isin;
  end;


  PRIVATE MACRO EndReport()
    SaveTotalbook();
  END;

  PRIVATE MACRO Create()
    var i = 0;
    var SheetName = "Протокол";
    var query, cmd, DataSet;
    var cnt = 0;

    SetActiveSheet(SheetName);

    PrintFormatString( NULL, "N1_periodFromH", m_periodFrom,
                             "N1_periodToH", m_periodTo
                     );

    CopyAllSheetInTotalBook(SheetName, false, "N1_Header", 0, SheetName);

    CopyAllSheetInTotalBook(SheetName, false, "N1_TableHeader", 1, SheetName);

    query = 
        " WITH ranked_data AS ( "
      + "     SELECT T_FIID, "
      + "            T_DATE, "
      + "            T_CIRCULATE, "
      + "            t_status, "
      + "            LAG(T_CIRCULATE) OVER (PARTITION BY T_FIID ORDER BY T_DATE) AS t_prev_circulate "
      + "       FROM DNPTXFI_DBT "
      + "      WHERE (NOT EXISTS (SELECT 1 FROM DFIID_TMP) "
      + "             OR T_FIID IN (SELECT FIID FROM DFIID_TMP)) "
      + "        AND T_DATE BETWEEN :periodFrom AND :periodTo "
      + " ), "
      + " changes AS ( "
      + "     SELECT T_FIID, "
      + "            T_DATE AS t_start_date, "
      + "            T_CIRCULATE, "
      + "            t_status, "
      + "            SUM( "
      + "                CASE "
      + "                    WHEN t_prev_circulate IS NULL OR t_prev_circulate != T_CIRCULATE THEN 1 "
      + "                    ELSE 0 "
      + "                END "
      + "            ) OVER (PARTITION BY T_FIID ORDER BY T_DATE) AS t_period_group "
      + "       FROM ranked_data "
      + " ), "
      + " periods AS ( "
      + "     SELECT T_FIID, "
      + "            MIN(t_start_date) AS t_start_date, "
      + "            MAX(t_start_date) AS t_last_update_date, "
      + "            T_CIRCULATE, "
      + "            t_period_group, "
      + "            t_status "
      + "       FROM changes "
      + "      GROUP BY T_FIID, T_CIRCULATE, t_period_group, t_status "
      + " ), "
      + " main_result AS ( "
      + "     SELECT fi.t_fi_code, "
      + "            avr.t_isin, "
      + "            p.t_start_date, "
      + "            CASE "
      + "                WHEN LEAD(p.t_start_date) OVER (PARTITION BY p.T_FIID ORDER BY p.t_start_date) IS NULL "
      + "                THEN p.t_last_update_date "
      + "                ELSE LEAD(p.t_start_date) OVER (PARTITION BY p.T_FIID ORDER BY p.t_start_date) - 1 "
      + "            END AS t_end_date, "
      + "            CASE p.t_circulate "
      + "                WHEN 1 THEN 'Обращается' "
      + "                WHEN 2 THEN 'Не обращается' "
      + "                WHEN 3 THEN 'Потеряла обращаемость' "
      + "            END AS t_circulate, "
      + "            CASE "
      + "                WHEN t_status = 1 THEN 'Значение категории \"Является обращающейся на ОРЦБ для целей НДФЛ\"' "
      + "                WHEN t_status = 2 THEN 'Есть котировка рос. биржи, допущена к торгам на рос. ОРЦБ' "
      + "                WHEN t_status = 3 THEN 'Есть котировка ин. биржи, допущена к торгам на рос. ОРЦБ' "
      + "                WHEN t_status = 4 THEN 'Есть котировка ин. биржи, не допущена к торгам на рос. ОРЦБ' "
      + "                WHEN t_status = 5 THEN 'Не найдены подходящие котировки' "
      + "                ELSE 'Неизвестный статус' "
      + "            END AS t_status_description, "
      + "            p.t_fiid "
      + "       FROM periods p "
      + "       JOIN DAVOIRISS_DBT avr ON avr.t_fiid = p.t_fiid "
      + "       JOIN DFININSTR_DBT fi ON fi.t_fiid = p.t_fiid "
      + " ), "
      + " missing_fiids AS ( "
      + "     SELECT tmp.fiid AS t_fiid, "
      + "            fi.t_fi_code, "
      + "            avr.t_isin, "
      + "            NULL AS t_start_date, "
      + "            NULL AS t_end_date, "
      + "            '' AS t_circulate, "
      + "            'Обращаемость не рассчитывалась, т.к. нет сделок за период расчета' AS t_status_description "
      + "       FROM DFIID_TMP tmp "
      + "       LEFT JOIN DFININSTR_DBT fi ON fi.t_fiid = tmp.fiid "
      + "       LEFT JOIN DAVOIRISS_DBT avr ON avr.t_fiid = tmp.fiid "
      + "      WHERE NOT EXISTS ( "
      + "                SELECT 1 "
      + "                  FROM main_result mr "
      + "                 WHERE mr.t_fiid = tmp.fiid "
      + "            ) "
      + " ) "
      + " SELECT * FROM ( "
      + "     SELECT t_fi_code, "
      + "            t_isin, "
      + "            t_start_date, "
      + "            t_end_date, "
      + "            t_circulate, "
      + "            t_status_description "
      + "       FROM main_result "
      + "     UNION ALL "
      + "     SELECT t_fi_code, "
      + "            t_isin, "
      + "            t_start_date, "
      + "            t_end_date, "
      + "            t_circulate, "
      + "            t_status_description "
      + "       FROM missing_fiids "
      + " ) "
      + " ORDER BY t_start_date NULLS LAST ";

    cmd = DL_RSDCommand(query);
    cmd.AddParam(m_periodFrom);
    cmd.AddParam(m_periodTo);

    cnt = cmd.GetCount();
    if((cnt > 0) or (m_NotFoundIsinArr.size >0))

      InitProgress(cnt, "Печать протокола", "Печать протокола");

      RegisterTable( "N1_MainTable", NULL,
                     "N1_fiidIssue",
                     "N1_isinCode",
                     "N1_periodFrom",
                     "N1_periodTo",
                     "N1_postCalculationStatus",
                     "N1_comment"
                   );
      i = -1;
      while ((i=i+1) < m_NotFoundIsinArr.size)
        PrintTableLine("N1_fiidIssue",            "", null,
                       "N1_isinCode",             m_NotFoundIsinArr[i], null,
                       "N1_periodFrom",           "", null,   
                       "N1_periodTo",             "", null,   
                       "N1_postCalculationStatus","", null,   
                       "N1_comment",              "ц/б не найдена", null
                    );
      end;

      i = 0;
      DataSet = cmd.Execute();
      while(DataSet.moveNext())
        PrintTableLine("N1_fiidIssue",            SQL_ConvTypeStr(DataSet.Fi_Code), null,
                       "N1_isinCode",             SQL_ConvTypeStr(DataSet.Isin), null,      
                       "N1_periodFrom",           string(SQL_ConvTypeDate(DataSet.Start_Date)), null,   
                       "N1_periodTo",             string(SQL_ConvTypeDate(DataSet.End_Date)), null,   
                       "N1_postCalculationStatus",SQL_ConvTypeStr(DataSet.Circulate), null,   
                       "N1_comment",              SQL_ConvTypeStr(DataSet.Status_Description), null   
                    );

        UseProgress(i = i + 1);
      end;

      EndTable();

      CopyAllSheetInTotalBook(SheetName, false, GetTableRange(), 0, SheetName);

      RemProgress();
    end;

  END;

  MACRO Run()
    Run();
    
    for (var fileName, GetFullReportFileNames())
      return fileName;
    end;

    return "";
  END;

  initDL_CReportTemplate( NULL, "NptxRecalcCirc.xlsx", true, null, null, true ); 
END;

PRIVATE CLASS (DL_CPanel) CNPTXRecalcCirculateForm()
  var m_BegDate:date = {curdate},
      m_EndDate:date = {curdate},
      m_FIID:integer = -1,
      m_NeedRecalc = UNSET_CHAR,
      m_NeedProgress = UNSET_CHAR,
      m_FilePath = "",
      m_ProtDir = "";
      
  PRIVATE MACRO Init()
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_BEGDATE,      DL_PNFLD_BEGINDATE, @DL_FldProc_BeginDate,          m_BegDate);
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_ENDDATE,      DL_PNFLD_ENDDATE,   @DL_FldProc_EndDate,            m_EndDate);
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_AVRCODE,      DL_PNFLD_AVRCODE,   @DL_FldProc_AvrCode,            m_FIID);
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_AVRNAME,      DL_PNFLD_AVRNAME,   @DL_FldProc_AvrName,            "");
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_LOADFROMFILE, DL_PNFLD_CHECKBOX,  @DL_FldProc_CheckBox_Circ_File, UNSET_CHAR);
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_FILEPATH,     H_FILEPATH,         @FldProc_File,                  "");
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_RECALC,       DL_PNFLD_CHECKBOX,  @DL_FldProc_CheckBox,           m_NeedRecalc);
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_PROGRESS,     DL_PNFLD_CHECKBOX,  @DL_FldProc_CheckBox,           m_NeedProgress);
     AddFieldProc(0, PNFLD_NPTXRECALCCIRCULATE_PROTDIR,      H_PROTDIR,          @DL_FldProc_Protocol_Directory, "");
  END;

  private macro GetFieldValue(fldNum:integer):variant
    var showValue:variant, fldValue:variant;

    GetFieldValue(fldNum, @showValue, @fldValue);
    return fldValue;
  end;

  macro Run()
    var stat = Run();
    
    m_BegDate      = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_BEGDATE);
    m_EndDate      = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_ENDDATE);
    m_FIID         = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_AVRCODE);
    m_NeedRecalc   = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_RECALC);
    m_NeedProgress = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_PROGRESS);

    if (GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_LOADFROMFILE) == SET_CHAR)
      m_FilePath = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_FILEPATH);
      m_FIID = -1;
    end;

    m_ProtDir = GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_PROTDIR);

    return stat;
  end;

  PRIVATE MACRO Check():BOOL
    if(GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_ENDDATE) == date(0,0,0))
      MsgBox("Дата окончания периода должна быть задана");
      return false;
    end;

    if((GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_LOADFROMFILE) == SET_CHAR) and ( GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_FILEPATH) == ""))
      MsgBox("Файл для загрузки должен быть задан");
      return false;
    end;

    if ( GetFieldValue(PNFLD_NPTXRECALCCIRCULATE_PROTDIR) == "")
      MsgBox("Директория протокола должна быть задана");
      return false;
    end;
    

    return true;
  END;

  initDL_CPanel("deals.lbr", "NPTXRECI");
END;


PRIVATE MACRO ExecRecalcCirculate()
  var cmd;
  var FIID          = -1;
  var BegDate       = {curdate};
  var EndDate       = {curdate};
  var NeedRecalc    = 0;
  var ParallelLevel = 8;
  var ExcelFile     = "";
  var ProtocolDirectory = "";

  SQL_Truncate( "DFIID_TMP" );

  var noInterf = IsNoInterfaceRun();

  if(noInterf)

    if(not GetCmdLineParm("fiid", FIID, V_INTEGER))
      FIID = -1;
    else
      execSQL("insert into DFIID_TMP (FIID) values (?)", makeArray(SQLParam("fiid", FIID)));
    end;

    if(not GetCmdLineParm("begdate", BegDate, V_DATE))
      BegDate    = {curdate};
    end;

    if(not GetCmdLineParm("enddate", EndDate, V_DATE))
      EndDate    = {curdate};
    end;

    if(not GetCmdLineParm("needrecalc", FIID, V_INTEGER))
      NeedRecalc = 0;
    end;

    cmd = RsdCommand( "{ CALL RSI_NPTO.RecalcCirculate(-1, ?, ?, "+ParallelLevel+") }" );

    cmd.addParam( "", RSDBP_IN, BegDate );
    cmd.addParam( "", RSDBP_IN, EndDate );
    cmd.addParam( "", RSDBP_IN, NeedRecalc );

    SQL_Execute( cmd, "Определение за период с "+string(BegDate:f)+" по "+string(EndDate:f), true );

  else
    var form = CNPTXRecalcCirculateForm();
    
    if(form.Run())
      FIID              = form.m_FIID;
      BegDate           = form.m_BegDate;
      EndDate           = form.m_EndDate;
      ExcelFile         = form.m_FilePath;
      ProtocolDirectory = form.m_ProtDir;

      var protocol = NptxRecalcCircProtocol_Report(BegDate, EndDate);

      if (ExcelFile != "")
        LoadTempFiidFromFile(ExcelFile, protocol);
      elif (FIID > 0)
        execSQL("insert into DFIID_TMP (FIID) values (?)", makeArray(SQLParam("fiid", FIID)));
      end;
      
      NeedRecalc = 0;
      if(form.m_NeedRecalc == "X")
        NeedRecalc = 1;
      end;

      if(form.m_NeedProgress == "X") //Нужен индикатор, поэтому вызываем расчет за каждую дату периода
        var CalcDate;
        var cnt = EndDate - BegDate + 1;
        var i;

        InitProgress(cnt, "Определение обращаемости", "Идет определение обращаемости");
     
        i = 0;
        CalcDate = BegDate; 
        while(i < cnt)

          cmd = RsdCommand( "{ CALL RSI_NPTO.RecalcCirculate(-1, ?, ?, ?, "+ParallelLevel+") }" );

          cmd.addParam( "", RSDBP_IN, CalcDate );
          cmd.addParam( "", RSDBP_IN, CalcDate );
          cmd.addParam( "", RSDBP_IN, NeedRecalc );

          SQL_Execute( cmd, "Определение за дату "+string(CalcDate:f), true );

          CalcDate = CalcDate + 1;

          UseProgress(i = i + 1);
        end;

        RemProgress();
      else
        //Идикатор не нужен - вызываем один раз сразу за весь период
        cmd = RsdCommand( "{ CALL RSI_NPTO.RecalcCirculate(-1, ?, ?, ?, "+ParallelLevel+") }" );

        cmd.addParam( "", RSDBP_IN, BegDate );
        cmd.addParam( "", RSDBP_IN, EndDate );
        cmd.addParam( "", RSDBP_IN, NeedRecalc );

        SQL_Execute( cmd, "Определение обращаемости", true );
      end;

      var FullProtocolFileNameXLSX = protocol.Run();

      protocol = NULL;

      if(not isStandAlone())
        FullProtocolFileNameXLSX = "$"+FullProtocolFileNameXLSX;
        ProtocolDirectory = "$"+ProtocolDirectory;
      end;
      
      if(FullProtocolFileNameXLSX != "")
        var day, mon, year;
        var hour, mn, sec;
        var FileName, FileExt;
        var ToFileName, ToFileExt;

        var FromDir = DLM_PathCanonicalize(SplitFile(FullProtocolFileNameXLSX, FileName, FileExt));
        var ToDir = DLM_PathCanonicalize(ProtocolDirectory + "\\");

        DateSplit(date(), day, mon, year);
        TimeSplit(time(), hour, mn, sec);

        var NewFileNameXLSX = "Протокол_расчет_обращаемости_цб_для_НДФЛ_"+string(day:o:2)+string(mon:o:2)+string(year)+"_"+string(hour:o:2)+string(mn:o:2)+string(sec:o:2) + ".xlsx";

        
        if(not RenameFile(FullProtocolFileNameXLSX, FromDir+NewFileNameXLSX))
          msgbox("Ошибка при переименовании файла протокола");
        else
          if((ToDir != "") and (ToDir != FromDir))
            if(SC_CopyFile(FromDir, ToDir, NewFileNameXLSX, NewFileNameXLSX) != 0)
              msgbox("Ошибка при сохранении файла протокола");
            end;
          end;

          if((GetDialogFlag() != 0) and (noInterf == false))
            SC_ShowFile(ToDir, NewFileNameXLSX);
          end;
        end;
      end;

    end;
  end;

END;

ExecRecalcCirculate();