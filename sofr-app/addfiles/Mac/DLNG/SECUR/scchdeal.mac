/*
$Name:        scchdeal.mac
$Module:      Ценные бумаги
$Description: Шаг изменения условий сделки\отказа от сделки\отказа от 2-ой части сделки
*/
import InsCarryDoc, "sp_class.mac", "sp_car.mac", "sp_carcm.mac", "scchdate.mac", "sp_grfun.mac", "screpocalc.mac";

/*глобальные структуры, через которые передаются изменения условий сделок*/
private record SpChangeDlTick("dl_tick.dbt");      /*условия сделки*/
private record SpChangeDlLeg("dl_leg.dbt");        /*условия первой части сделки*/
private record SpChangeDlLegBack("dl_leg.dbt");    /*условия второй части сделки*/
private record SpChildDlLeg("dl_leg.dbt");         /*условия первой части дочерней сделки*/
private record SpChangePmwrtsum("pmwrtsum.dbt");   /*лот по 1 части*/

/*структуры для сохранения состояния данных по сделке до изменения\отказа*/
private record SaveDlTick("dl_tick.dbt");       /*условия сделоки*/
private record SaveDlLeg("dl_leg.dbt");         /*условия первой части*/
private record SaveDlLegBack("dl_leg.dbt");     /*условия второй части*/

private var SpChangeRq = TArray; //Массив всех ТО

/*сумма в операции учета купона*/
private var COUPON_SUM;
private var CalcSumFIID;
private var CalcOperDate;
private var CalcPlanDate;
private var CalcWrtTime;
private var UniqStr = TUniqStrCollector;
private var ReturnIncomeKind = 0;

private macro replan_date( FD, KindDate )
   if( FD.DateArray[KindDate] != null )
      if( (OprReplanStepPlanDates( FD.GetKindDate(KindDate), FD.DateArray[KindDate] ) == false ) )
         msgbox("Ошибка при попытке переинициализировать дату");         
         return false;
      else
         return true;
      end;
   else
      return true;
   end;
end;

/*перепланировка дат шагов после изменения условий сделки*/
private macro replan_date_change( FD, dat, ID_Op )

   var Do,Dp,Dk, NeedInsertDepoDraft, err = 0, DDraft, KindDateDraft, stat, RegistrDate;

   if( (replan_date( FD, DATE_DEALSETAVOIRISS ) == false) OR
       (replan_date( FD, DATE_DEALPAY ) == false) OR
       (replan_date( FD, DATE_DEALBEGINEXEC ) == false) OR
       (replan_date( FD, DATE_DEALEXEC ) == false) OR
       ( (FD.ExistDeposit == true) AND (replan_date( FD, DATE_DEALDEPOSIT ) == false) ) OR
       ( (FD.ExistAvance == true) AND (replan_date( FD, DATE_DEALAVANCE ) == false) )
   ) 
      return false;
   else
      /*определим новую дату завершения сделки*/
      Do = FD.DateArray[DATE_DEALPAY]; /*Дата оплаты*/
      Dp = FD.DateArray[DATE_DEALSETAVOIRISS]; /*Дата поставки*/
      Dk = FD.DateArray[DATE_DEALCOMISS]; /*Дата комиссии*/
      FD.DateArray[DATE_DEALEEND] = maxDate( maxDate(Do, Dp), Dk );
      if( replan_date( FD, DATE_DEALEEND ) == false )
         return false;
      end;

      /*
      При изменении даты поставки в условиях сделки перерасчитывается так же дата формирования поручения, 
      и шаг перепланируется на новую дату (если они еще не выполнен). 
      Новая дата формирования не должна быть меньше даты изменения и даты последнего выполненного шага 
      (иначе шаг выполнить не удасться). Если же шаг предварительного формирования поручения выполнен, 
      и меняется плановая дата, то она не должна становиться меньше даты формирования поручения. 
      Эти действия и провери актуальны, только если "Формировать предварительно поручение депо?" == да 
      */

      NeedInsertDepoDraft = НужноПредФормПоручДЕПО(FD, err);
      if (err > 0)
         return false;
      end;

      if (NeedInsertDepoDraft == true)

         stat = ExecMacroFile("dpdrutl.mac", "SP_GetDraftDate", FD.GetRQ(DLRQ_TYPE_DELIVERY), RegistrDate);

         if( stat == false)

            DDraft = GetDateInsDepoDraft( FD );
            DDraft = maxDate(DDraft, dat);

            if (DDraft < dat)
               MsgBox("Дата формирования поручения не должна быть меньше даты изменения условий");
               return false;
            end;

            if (DDraft < SP_GetMaxPlanStepDate(ID_Op, dat))
               MsgBox("Дата формирования поручения не должна быть меньше даты последнего выполненного шага");
               return false;
            end;

            if( FD.IsBack )
               KindDateDraft = DATE_DEALINSDEPODRAFT_2;
            else 
               KindDateDraft = DATE_DEALINSDEPODRAFT;
            end;

            FD.DateArray[KindDateDraft] = DDraft;
            if( replan_date( FD, KindDateDraft ) == false )
               return false;
            end;
         end;
      end;

      return true;
   end; 
end;

/*перепланировка дат шагов при отказе от сделки\2ч*/
private macro replan_date_reject( FD, RejectDate )

   FD.DateArray[DATE_DEALBEGINEXEC] = RejectDate;
   if( replan_date( FD, DATE_DEALBEGINEXEC ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALEEND] = RejectDate;
   if( replan_date( FD, DATE_DEALEEND ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALTRANSFER] = RejectDate;
   if( replan_date( FD, DATE_DEALTRANSFER ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALINSDEPODRAFT] = RejectDate;
   if( replan_date( FD, DATE_DEALINSDEPODRAFT ) == false )
      return false;
   end;

   if( FD.ExistDeposit == true )
      FD.DateArray[DATE_DEALDEPOSIT] = RejectDate;
      if( replan_date( FD, DATE_DEALDEPOSIT ) == false )
         return false;
      end;
   end;

   FD.DateArray[DATE_DEALCOMISS] = RejectDate;
   if( replan_date( FD, DATE_DEALCOMISS ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALSETAVOIRISS] = RejectDate;
   if( replan_date( FD, DATE_DEALSETAVOIRISS ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALPAY] = RejectDate;
   if( replan_date( FD, DATE_DEALPAY ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALEXEC] = RejectDate;
   if( replan_date( FD, DATE_DEALEXEC ) == false )
      return false;
   end;

   if( FD.IsBack )

      FD.DateArray[DATE_DEALBEGIN_2] = RejectDate;      
      if( replan_date( FD, DATE_DEALBEGIN_2 ) == false )
         return false;
      end;

      FD.DateArray[DATE_DEALINSDEPODRAFT_2] = RejectDate;
      if( replan_date( FD, DATE_DEALINSDEPODRAFT_2 ) == false )
         return false;
      end;

      FD.DateArray[DATE_DEALEXEC_2] = RejectDate;
      if( replan_date( FD, DATE_DEALEXEC_2 ) == false )
         return false;
      end;

      FD.DateArray[DATE_DEALPAY_2] = RejectDate;
      if( replan_date( FD, DATE_DEALPAY_2 ) == false )
         return false;
      end;

   end;

   if (IsREPO( FD.Group ) and (not FD.IsBack))
      FD.DateArray[DATE_DEALPAY_2] = RejectDate;
      if( replan_date( FD, DATE_DEALPAY_2 ) == false )
         return false;
      end;
      FD.DateArray[DATE_DEALEXEC_2] = RejectDate;
      if( replan_date( FD, DATE_DEALEXEC_2 ) == false )
         return false;
      end;
      FD.DateArray[DATE_DEALSETAVOIRISS_2] = RejectDate;
      if( replan_date( FD, DATE_DEALSETAVOIRISS_2 ) == false )
         return false;
      end;
   end;

   return true; 
end;

/*перепланировка дат шагов при отказе от просроченной сделки*/
private macro replan_date_overdue_reject( FD, RejectDate )

   FD.DateArray[DATE_DEALSETAVOIRISS] = RejectDate;
   if( replan_date( FD, DATE_DEALSETAVOIRISS ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALBEGINEXEC] = RejectDate;
   if( replan_date( FD, DATE_DEALBEGINEXEC ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALPAY] = RejectDate;
   if( replan_date( FD, DATE_DEALPAY ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALEEND] = RejectDate;
   if( replan_date( FD, DATE_DEALEEND ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALTRANSFER] = RejectDate;
   if( replan_date( FD, DATE_DEALTRANSFER ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALINSDEPODRAFT] = RejectDate;
   if( replan_date( FD, DATE_DEALINSDEPODRAFT ) == false )
      return false;
   end;

   return true; 
end;

private record acc1(account);
private record acc2(account);

private macro СделкаНаВнебалансе( FD )
   return (FD.dl_leg.rec.OperState == DL_LEG_OUTBAL);
end;

private macro ОбработатьИзменениеУсловийСделки( FD, NeedSetOutBalance )

  if( NeedSetOutBalance ) 

     if( ПоставитьНаВнебаланс(FD) == 1 )
        return 1;
     end;

     FD.DateArray[DATE_DEALTRANSFER] = FD.DateArray[DATE_DEALBEGINEXEC];
     if( replan_date(FD, DATE_DEALTRANSFER) == false )
        return 1;
     end;
  end;

  return 0;
end;

private macro ЗакрытьОдноТО( FD, Type, dat )
  if( (FD.ExistsRQ(Type)) and (FD.GetRQ(Type).rec.State != DLRQ_STATE_EXEC)) 
    FD.GetRQ(Type).rec.State = DLRQ_STATE_REJECT;
    FD.GetRQ(Type).rec.FactDate = dat;    
  end;
end;

private macro ЗакрытьТО( FD, dat )
   
   ЗакрытьОдноТО( FD, DLRQ_TYPE_PAYMENT, dat );

   var ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
   var j:integer = 0;
   while( j < ArrFIID.size )
      FD.SetCurPFI(ArrFIID(j));
      ЗакрытьОдноТО( FD, DLRQ_TYPE_DELIVERY, dat );
      j = j + 1;
   end;

   ЗакрытьОдноТО( FD, DLRQ_TYPE_AVANCE, dat );
   ЗакрытьОдноТО( FD, DLRQ_TYPE_DEPOSIT, dat );
   ЗакрытьОдноТО( FD, DLRQ_TYPE_INCREPO, dat );

   return true;
end;

private macro SaveRQ( FD, FD2, dat:date )
  FD.SaveChangedRQ(dat);
  if( ValType(FD2) != V_UNDEF )
    FD2.SaveChangedRQ(dat);
  end;
end;

/*проверим - нужно ли проверять дату ТО*/
private macro RqDateNeedCheck( rq )

   /*ТО не исполнено, не просрочен и не отложен*/
   if( (ТОЗакрыто(rq) == false) AND 
       (rq.rec.State != DLRQ_STATE_DELAYED ) AND (rq.rec.State != DLRQ_STATE_OVERDUE) )
      return true;
   else
      return false;
   end;
end;

private macro ПроверитьПлановыеДатыСделки( FD, Dat )

   var min_date = date(31,12,2999);

   if( RqDateNeedCheck(FD.GetRQ(DLRQ_TYPE_PAYMENT)) )
      min_date = min( min_date, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate );      
   end;   

   var ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
   var j:integer = 0;
   while( j < ArrFIID.size )
      if( RqDateNeedCheck(FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j))) )
         min_date = min( min_date, FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)).rec.PlanDate );
      end;
      j = j + 1;
   end;

   if( FD.ExistAvance AND RqDateNeedCheck(FD.GetRQ(DLRQ_TYPE_AVANCE)) )
      min_date = min( min_date, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate );
   end;   

   if( (min_date != date(31,12,2999)) AND (Dat > min_date) )
      msgbox( "Дата изменения условий сделки не должна превышать текущие плановые даты сделки" ); 
      return false;
   end;

   return true;
end;

private record _party(party);

private macro IsNotResident( PartyID )
   if( ПолучитьСубъекта( PartyID, _party ) == 0 )      
      return  _party.NotResident;
   end;
end;

/* если изменения по сделке критичные, приводящие к смене счетов, необходимо снять с внебаланса, */
/* чтобы затем заново поставить на внебаланс по новым, измененным счетам                         */
private macro ПроверитьИзмененияИСнятьСВнебаланса( FD, DlLegOld, DlTickOld, NeedSetOutBalance:@bool ) 

  var ChangePartyResident = ( (FD.tick.rec.PartyID != DlTickOld.PartyID) AND (IsNotResident(FD.tick.rec.PartyID) != IsNotResident(DlTickOld.PartyID)) );

  /*если изменили валюту расчета или поменяли контрагента на другого с другим признаком резидентности*/
  if( (FD.GetPayFIID() != DlLegOld.PayFIID) OR (ChangePartyResident == true) )
     if( СделкаНаВнебалансе(FD) )
        NeedSetOutBalance = true;
     end;
  end;

  return 0;
end;

private macro SetCategory(Tick, ObjGroup:integer, AttrID:integer, CatDate:date, ErrorMsg:@string)
  var stat:integer = 0;
 
  if( ( not DisconnectObjAttr(OBJTYPE_OUTOPER_DV,  UniID( Tick, OBJTYPE_OUTOPER_DV), ObjGroup) ) OR
    ( not ConnectObjAttr(stat, OBJTYPE_OUTOPER_DV, UniID( Tick, OBJTYPE_OUTOPER_DV), ObjGroup, AttrID, null, null, CatDate) ) OR
    ( stat != 0 )
  )
   ErrorMsg = "Ошибка при установке категории. " + GetErrMsg();
  end;
 
  return stat;
end;

/* Проверка категории Репортинг в репозитарий */
private macro ПроверитьНеобходимостьРепортингаВРепозитарии( FD )
  var    result=false;
  var cmd = DL_RSDCommand();
  var query = " SELECT t_docid"
             +" FROM ddl_repozdeal_dbt"
             +" WHERE t_docid = ?"
             +" AND t_dockind = 101"
             +" AND t_reporting = chr(88)"
             ;

  cmd.AddParam(FD.tick.rec.dealid);
  
  var DataSet = cmd.Execute(query);
  if(DataSet.moveNext())
      result=true;
  end;
  return result;
end;

private macro getPayPlanDate( dl_leg )
  var PlanDate;
  if( dl_leg.MaturityIsPrincipal )
    PlanDate = dl_leg.Expiry;
  else
    PlanDate = dl_leg.Maturity;
  end;   
  return PlanDate;
end;


private macro getDeliveryPlanDate( dl_leg )
  var PlanDate;
  if( not dl_leg.MaturityIsPrincipal )
    PlanDate = dl_leg.Expiry;
  else
    PlanDate = dl_leg.Maturity;
  end;   
  return PlanDate;
end;

private macro ПроверитьИзменениеПараметровДляРепозУчета( FD )
  var haveChange = false;
  
  haveChange = haveChange or ( SpChangeDlLeg.basis != SaveDlLeg.basis ); //база расчета  

  haveChange = haveChange or ( SpChangeDlTick.Flag3 != SaveDlTick.Flag3 ); //срок сделки

  haveChange = haveChange or ( SpChangeDlLeg.formula != SaveDlLeg.formula ); //тип расчета

  haveChange = haveChange or ( getDeliveryPlanDate( SpChangeDlLeg ) != getDeliveryPlanDate( SaveDlLeg ) ); //плановая дата поставки

  haveChange = haveChange or ( getPayPlanDate( SpChangeDlLeg ) != getPayPlanDate( SaveDlLeg ) ); //плановая дата оплаты

  haveChange = haveChange or ( SpChangeDlLeg.incomerate != SaveDlLeg.incomerate ); //ставка репо
  haveChange = haveChange or ( SpChangeDlLeg.payfiid != SaveDlLeg.payfiid ); //валюта расчетов

  haveChange = haveChange or ( SpChangeDlLeg.price != SaveDlLeg.price ); //цена
  haveChange = haveChange or ( SpChangeDlLeg.cost != SaveDlLeg.cost ); //стоимость

  haveChange = haveChange or ( SpChangeDlLeg.CFI != SaveDlLeg.CFI ); //валюта цены
  
  if( FD.ExistBack )
	
    haveChange = haveChange or ( SpChangeDlLegBack.formula != SaveDlLegBack.formula ); //тип расчета
  
    haveChange = haveChange or ( getDeliveryPlanDate( SpChangeDlLegBack ) != getDeliveryPlanDate( SaveDlLegBack ) ); //плановая дата поставки
    haveChange = haveChange or ( getPayPlanDate( SpChangeDlLegBack ) != getPayPlanDate( SaveDlLegBack ) ); //плановая дата оплаты
	
    haveChange = haveChange or ( SpChangeDlLegBack.price != SaveDlLegBack.price ); //цена
    haveChange = haveChange or ( SpChangeDlLegBack.cost != SaveDlLegBack.cost ); //стоимость
	
    haveChange = haveChange or ( SpChangeDlLegBack.totalcost != SaveDlLegBack.totalcost ); //сумма 2 части
    haveChange = haveChange or ( SpChangeDlLegBack.returnincome != SaveDlLegBack.returnincome ); //сумма процентов

    haveChange = haveChange or ( SpChangeDlLegBack.CFI != SaveDlLegBack.CFI ); //валюта цены
	
  end;
  
  return haveChange;
end;


/* Поиск первичных сообщений для сделки, имеющих статус "Подготовлено" либо "Ошибка выгрузки" */
private macro FindUnloadedMessages(DealID:integer)
  var cmd = DL_RSDCommand();
  var query = "select 1 from dir_generalinf_dbt "
            + "  where t_internalmessageid "
            + "  in ( select t_docid from ddlgrdoc_dbt "
            + "       where t_grdealid in ( select t_id from ddlgrdeal_dbt "
            + "                             where t_docid = ? )"
            + "       and t_dockind = ? )" 
            + "  and T_RSTATUS in (1, 4)"; // 1 - подготовлено, 4 - ошибка выгрузки

  cmd.AddParam(DealID);
  cmd.AddParam(4853/*REPOS_GENERALINF*/);
  var DataSet = cmd.Execute(query);
  return DataSet.moveNext()
end;

/* Поиск сводных сообщений для сделки, имеющих статус "Подготовлено" либо "Ошибка выгрузки" */
private macro FindUnloadedBulkMessages(DealID:integer)
  var cmd = DL_RSDCommand();
  var query = "select 1 from dir_generalinf_dbt "
            + "  where t_internalmessageid "
            + "  in ( select t_internalmessageid from dir_cm083_dbt "
            + "       where t_id in ( select t_docid from ddlgrdoc_dbt "
            + "                       where t_grdealid in ( select t_id from ddlgrdeal_dbt "
            + "                                             where t_docid = ? ) "
            + "                       and t_dockind = ? ) )"
            + "  and T_RSTATUS in (1, 4)"; // 1 - подготовлено, 4 - ошибка выгрузки

  cmd.AddParam(DealID);
  cmd.AddParam(4857/*REPOS_CM083*/);
  var DataSet = cmd.Execute(query);
  return DataSet.moveNext();
end;

/* Проверка, является ли слелка с ожиданием запроса: параметры "Способ подтверждения" = "Комбинированный/Последовательный" и
   "Инициирующая сторона" = "Контрагент" */
private macro isPendingRequestDeal(DealID:integer)
  var cmd = DL_RSDCommand();
  var query = " SELECT T_INITIATOR, T_METHOD_WAYTWOWAY FROM DDL_REPOZDEAL_DBT "
            + " WHERE T_DOCID = ? ";
  cmd.AddParam(DealID);
  var DataSet = cmd.Execute(query);
  var stat = false;
  if (DataSet.moveNext())
    stat = ( DataSet.rec.Initiator == 2 ) and ( DataSet.rec.Method_Waytwoway == 1 )
  end;
  return stat;
end;

private macro isBulkReportPlanned( DealID:integer )
    var stat = false;
    var query = "SELECT gracc.T_STATE "
              + "FROM DDLGRACC_DBT gracc, DDLGRDEAL_DBT grdeal "
              + "WHERE "
              + " gracc.T_GRDEALID = grdeal.T_ID AND "
              + " gracc.T_ACCNUM = " + DLGR_ACCKIND_REPOSITORY + " AND "
              + " grdeal.T_DOCKIND = " + OBJTYPE_SECDEAL + " AND "
              + " grdeal.T_DOCID = ? AND "
              + " grdeal.T_TEMPLNUM = " + DLGR_TEMPL_BULKREPORT;
    var cmd = DL_RSDCommand();
    cmd.AddParam( DealID );
    var DataSet = cmd.Execute(query);
    if ( DataSet.moveNext() )
        stat = (DataSet.rec.State == DLGRACC_STATE_PLAN) or (DataSet.rec.State == DLGRACC_STATE_FACTEXEC);
    end;
    return stat;
end;

/*
Существенные для депозитарного учета параметры:
- Количество ценных бумаг
- Условия расчетов
- Плановая дата поставки
- Контрагент
- Поставляемый выпуск
*/
private macro ПроверитьИзменениеСущественныхПараметровДляДепозУчета(FD)
   var stat, RegistrDate;

   stat = ExecMacroFile("dpdrutl.mac", "SP_GetDraftDate", FD.GetRQ(DLRQ_TYPE_DELIVERY), RegistrDate);

   if (stat == true)
      if (not FD.IsBack)
         if (SpChangeDlLeg.Principal != SaveDlLeg.Principal)
            UniqStr.AddString("Количество ценных бумаг\n");
         end;

         if (SpChangeDlLeg.Formula != SaveDlLeg.Formula)
            UniqStr.AddString("Условия расчетов\n");
         end;

         if (GetRealDealSetAvPlanDate(SpChangeDlLeg) != GetRealDealSetAvPlanDate(SaveDlLeg))
            UniqStr.AddString("Плановая дата поставки\n");
         end;

         if (SpChangeDlTick.PartyID != SaveDlTick.PartyID)
            UniqStr.AddString("Контрагент\n");
         end;

         if (SpChangeDlLeg.PFI != SaveDlLeg.PFI)
            UniqStr.AddString("Поставляемый выпуск\n");
         end;
      else
         /*Для 2-й части - предполагается, что по 1-й уже проверили, поэтому проверяем не все.*/

         if (SpChangeDlLegBack.Formula != SaveDlLegBack.Formula)
            UniqStr.AddString("Условия расчетов\n");
         end;

         if (GetRealDealSetAvPlanDate(SpChangeDlLegBack) != GetRealDealSetAvPlanDate(SaveDlLegBack))
            UniqStr.AddString("Плановая дата поставки\n");
         end;

      end;
   end;
end;

/*Если изменяли существенные для депоз. учета параметры, то выведем сообщение.*/
private macro ВывестиСообщениеОбИзмененииСущественныхПараметровДляДепозУчета()
   var Counter = 0, str_err = "";

   if (UniqStr.Size > 0)
      str_err = "Необходимо выполнить в модуле \"Депозитарий\" корректировку реквизит" + 
      IIF(UniqStr.Size == 1, "а", "ов") + " \n";

      while( Counter < UniqStr.Size )
         str_err = str_err + UniqStr.(Counter);
         Counter = Counter + 1;
      end;

      str_err = str_err + "в поручении депо, сформированном по данной сделке";

      msgbox(str_err);
      UniqStr.Size = 0;
   end;
end;

/* IL 20.02.07 запрос 70921 - запертить выполнять отказ если есть ТО, исполненные в неттинге*/
private macro CheckRqRejectPart( FD )
      
  if( FD.ExistsRQ(DLRQ_TYPE_PAYMENT) ) 
     if( (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.Netting == "X")) 
        return false;
     end;   
  end;

  var ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
  var j:integer = 0;
  while( j < ArrFIID.size )
     if( FD.ExistsRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)) ) 
        if( (FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)).rec.Netting == "X") )
           return false;
        end;   
     end;
     j = j + 1;
  end;

  if( FD.ExistsRQ(DLRQ_TYPE_AVANCE) ) 
     if( (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.Netting == "X")) 
        return false;
     end;   
  end;

  if( FD.ExistsRQ(DLRQ_TYPE_DEPOSIT) ) 
     if( (FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.Netting == "X")) 
        return false;
     end;   
  end;
  return true;
end;

private macro ПроставитьСтатусыОперацийПриОтказе( FD, IsBack )
   if( IsOUTEXCHANGE(FD.Group) )
      if( IsBasket(FD.Group) )
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_I2, SP_OPERSTATUS_SECURDEALS_I2_FINISH) )
            msgbox( "Ошибка при установке статуса <Исполнить 2ч> операции" );
            return 1;
         end;
      else
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_A2, SP_OPERSTATUS_SECURDEALS_A2_FINISH) ) 
            msgbox( "Ошибка при установке статуса <Оплата аванса по 2 ч> операции" );
            return 1;
         end;
        
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_O2, SP_OPERSTATUS_SECURDEALS_O2_FINISH) )
            msgbox( "Ошибка при установке статуса <Оплата по 2 ч> операции" );
            return 1;
         end;
        
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_D2, SP_OPERSTATUS_SECURDEALS_D2_FINISH) )
            msgbox( "Ошибка при установке статуса <Формирование поручения по 2 ч> операции" );
            return 1;
         end;
        
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_P2, SP_OPERSTATUS_SECURDEALS_P2_FINISH) )
            msgbox( "Ошибка при установке статуса <Поставка по 2 ч> операции" );
            return 1;
         end;
        
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_OD, SP_OPERSTATUS_SECURDEALS_OD_FINISH) )
            msgbox( "Ошибка при установке статуса <Оформление договора> операции" );
            return 1;
         end;
      end;

      /*Только для отказа от сделки (1ч): */
      if( not IsBack )
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_A1, SP_OPERSTATUS_SECURDEALS_A1_FINISH) ) 
            msgbox( "Ошибка при установке статуса <Оплата аванса по 1 ч> операции" );
            return 1;
         end;

         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_O1, SP_OPERSTATUS_SECURDEALS_O1_FINISH) ) 
            msgbox( "Ошибка при установке статуса <Оплата по 1 ч> операции" );
            return 1;
         end;

         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_D1, SP_OPERSTATUS_SECURDEALS_D1_FINISH) ) 
            msgbox( "Ошибка при установке статуса <Формирование поручения по 1 ч> операции" );
            return 1;
         end;

         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_P1, SP_OPERSTATUS_SECURDEALS_P1_FINISH) ) 
            msgbox( "Ошибка при установке статуса <Поставка по 1 ч> операции" );
            return 1;
         end;
      end;

   elif( IsEXCHANGE(FD.Group) )

      if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_I2, SP_OPERSTATUS_SECURDEALS_I2_FINISH) ) 
         msgbox( "Ошибка при установке статуса <Исполнить 2ч> операции" );
         return 1;
      end;

      if (not IsBack)
         if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_I1, SP_OPERSTATUS_SECURDEALS_I1_FINISH) ) 
            msgbox( "Ошибка при установке статуса <Исполнить 1ч> операции" );
            return 1;
         end;
      end;

   end;

   return 0;
end;

private macro ПроставитьСтатусыПриОтказеПросроч( FD)

   if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_OD, SP_OPERSTATUS_SECURDEALS_OD_FINISH) ) 
      msgbox( "Ошибка при установке статуса <Оформление договора> операции" );
      return 1;
   end;

   if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_AZ, SP_OPERSTATUS_SECURDEALS_AZ_FINISH) ) 
      msgbox( "Ошибка при установке статуса <Оплата аванса по 1 ч> операции" );
      return 1;
   end;

   if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_O1, SP_OPERSTATUS_SECURDEALS_O1_FINISH) ) 
      msgbox( "Ошибка при установке статуса <Оплата по 1 ч> операции" );
      return 1;
   end;

   if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_D1, SP_OPERSTATUS_SECURDEALS_D1_FINISH) ) 
      msgbox( "Ошибка при установке статуса <Формирование поручения по 1 ч> операции" );
      return 1;
   end;

   if( not InsertOprStatus( SP_OPERSTATUS_SECURDEALS_P1, SP_OPERSTATUS_SECURDEALS_P1_FINISH) ) 
      msgbox( "Ошибка при установке статуса <Поставка по 1 ч> операции" );
      return 1;
   end;

   return 0;
end;

Private macro IsCloseContr(FD)

    var SelectClose, DataSetClose, QueryClose;
    var cnt = 0;
    var MaxGrDate:date = date(31,12,9999);
    QueryClose = "select * from ddlgrdeal_dbt where t_DocKind = ? and t_DocID = ? and t_TemplNum in(51,52) " ;
    SelectClose = DL_RSDCommand(QueryClose);
    SelectClose.AddParam(FD.tick.rec.BofficeKind);
    SelectClose.AddParam(FD.tick.rec.DealID);

    cnt = SelectClose.GetCount(QueryClose);     // если не запланировано закрытие договора, то ничего не вставляем
    if( cnt == 0 )
      return 0;
    end;
    return 1;
end;

private macro SetRQFromArray(FD, Type)

  var i = 0;
  record rq("dlrq.dbt");
  var DlRq = TRecHandler("dlrq");
  var DealPart = IIF(FD.IsBack, 2, 1);

  while( i < SpChangeRq.Size() )
     SetBuff(rq, SpChangeRq[i]);
     if( (rq.Type == Type) and (rq.DealPart == DealPart) )
        if( FD.ExistsRQ(rq.Type, rq.DealPart, rq.FIID) )
           copy(FD.GetRQ(rq.Type, rq.DealPart, rq.FIID), rq);
        else
           if( (rq.ID > 0) and (rq.Amount > 0) )
              copy(DlRq, rq);
              FD.SetRQ(DlRq);
           end;
        end;
     end;
     i = i + 1;
  end;

end;

private macro ВставитьДействиеИзменениеСостоянияОбязательств(FD, BOfficeKind, DealID, FIID, dat, ОжиданиеЗапроса, requestTimeoutRej)
  if( ОжиданиеЗапроса and requestTimeoutRej)
    if( FIID == -1 )
      if( DL_UpdateGrDealAcc( BOfficeKind, DealID, FIID, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
        return 1;
      end;
      if( DL_UpdateGrDealAcc( BOfficeKind, DealID, FIID, DLGR_TEMPL_MAKEDEALWTHREQUEST, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
         return 1;
      end;
    else
      if( DL_SetDateGrDeal( BOfficeKind, DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
        return 1;
      end;
    end;
    if(DL_InsertGrDeal( BOfficeKind, DealID, DLGR_TEMPL_REJECTIONMSGWTHREQUEST, GetDateAfterWorkDays(dat, requestTimeoutRej, FD.ПолучитьКалендСвязанный()) , time(0,0,0), FIID) != 0 )
      return 1;
    end;
  else
    if( FIID == -1 )
      if( DL_UpdateGrDealAcc( BOfficeKind, DealID, FIID, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
        return 1;
      end;
      if( DL_UpdateGrDealAcc( BOfficeKind, DealID, FIID, DLGR_TEMPL_MAKEDEAL, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
        return 1;
      end;
    else
      if( DL_SetDateGrDeal( BOfficeKind, DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
        return 1;
      end;
    end;
    if(DL_InsertGrDeal( BOfficeKind, DealID, DLGR_TEMPL_REJECTIONMSG, dat, time(0,0,0), FIID) != 0 )
      return 1;
    end;
  end;
end;

macro ВставитьДействиеИзменениеСостоянияОбязательствВнеБиржи(FD, dat)
  var ОжиданиеЗапроса = false, requestTimeout = 0, BOfficeKind = 0, DealID = 0, PFI = -1;
  if( ПРОВЕРКА_РЕПОЗИТАРНЫХ_ПАРАМЕТРОВ( FD.tick, @ОжиданиеЗапроса, @requestTimeout, @BOfficeKind, @DealID, @PFI ) )
    ВставитьДействиеИзменениеСостоянияОбязательств(FD, BOfficeKind, DealID, PFI, dat, ОжиданиеЗапроса, requestTimeout)
  end;
end;

private var ftick = TBfile("dl_tick.dbt", "R", 0);

private macro ExecuteStep( Doc, FDoc, DocKind, ID_Op, ID_Step )

   record deal(dl_tick);
   var newtick = TRecHandler("dl_tick.dbt");
   var newleg  = TRecHandler("dl_leg.dbt");
   var addNum = 0;
   var FD, FD2, dat;
   var change_date = SpChangeDlTick.ChangeDate;      
   var reject_date = SpChangeDlLeg.RejectDate;      
   var reject_date2= SpChangeDlLegBack.RejectDate;      
   var NeedSetOutBalance = false;
   var save_datebegsett1 = null, save_datesetavoir1 = null;
   var save_datebegsett2 = null, save_datesetavoir2 = null;
   var change_dates = false, change_dates_2 = false; 
   var ВидСрочностиСделкиДоИзменений = 0, ВидСрочностиСделкиДоИзменений_2 = 0;
   var i = 0, j = 0;
   var ArrFIID, ArrFIID2;
   var GUID = "";
   var query, cmd, DataSet;

   var ОбработатьТО = true;
   var SkipGrDeal = true;

   SetBuff( deal, FDoc );

   var requestTimeoutRej = 0;
   var requestTimeout = 0;
   var reporting = false;
   GetRegistryValue("РЕПОЗИТАРИЙ\\СРОК ОЖИД.ЗАПР. ПРИ КОМБ.ПОДТВ.", V_INTEGER, requestTimeoutRej, null);
   var ОжиданиеЗапроса = false;
   var repozdeal = TBFile("dl_repozdeal.dbt", "R", 1);

   /* Если отказ от исполнения/изменение параметров сделки запущен из списка шагов - выводить ошибку */
   if( NOT( SC_IsFromScrollMode() ) )
      msgbox("Шаг \"Изменения условий\" \\ \"Отказ от исполнения сделки\" \\ \"Отказ от исполнения 2ч сделки\" из списка шагов выполнять запрещено.");
      return 1;
   end; 

   /*нужно подкачать еще неизмененную сделку из базы*/   
   ftick.Clear();
   ftick.rec.DealID = deal.DealID;
   if( ftick.GetEQ == false ) 
      msgbox( "Сделка не найдена" );
      return 1;
   end;

   FD = SPFirstDoc( ftick ); 

   if( FD.ExistBack == true )
      FD2 = SPFirstDoc( ftick, true );   
   end;  

   if ((IsREPO( FD.Group )) or (IsEXCHANGE(FD.Group)))
     repozdeal.Clear();
     repozdeal.rec.DocKind = FD.tick.rec.BofficeKind;
     repozdeal.rec.DocID   = FD.tick.rec.DealID;
     if( GetEQ(repozdeal) )
       if( (repozdeal.rec.INITIATOR == 2) and    (repozdeal.rec.METHOD_WAYTWOWAY == 1))
         ОжиданиеЗапроса = true;
         requestTimeoutRej = repozdeal.rec.requestTimeout;
         requestTimeout = repozdeal.rec.requestTimeout;
       end;
       if(repozdeal.rec.reporting == SET_CHAR)
         reporting = true;
       end;
     end;

   end;

   if(deal.ChangeKind == SPTKCHNG_PARTEXEC) //частичная поставка/оплата
     dat = change_date;
     
     if(FD.dl_leg.rec.Principal == SpChildDlLeg.Principal)
       //последняя частичная поставка/оплата
       
       SpChangeDlLeg.Maturity = dat;
       SpChangeDlLeg.Expiry   = dat;
       
       FD.GetRQ(DLRQ_TYPE_PAYMENT, 1).rec.PlanDate = dat;
       FD.GetRQ(DLRQ_TYPE_PAYMENT, 1).rec.State    = DLRQ_STATE_PLAN;

       FD.GetRQ(DLRQ_TYPE_DELIVERY, 1).rec.PlanDate = dat;
       FD.GetRQ(DLRQ_TYPE_DELIVERY, 1).rec.State    = DLRQ_STATE_PLAN;

       if( not OprReplanStepPlanDates(DATE_DEALSETAVOIRISS, dat, false ) )
          msgbox("Ошибка при попытке переинициализировать дату " );         
          return 1;
       end;

       if( not OprReplanStepPlanDates(DATE_DEALPAY, dat, false ) )
          msgbox("Ошибка при попытке переинициализировать дату " );         
          return 1;
       end;

       if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, dat) != 0)
         return 1;
       end;

       if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT, dat) != 0)
         return 1;
       end;

       if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, dat) != 0)
         return 1;
       end;

       if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DEPO, dat) != 0)
         return 1;
       end;

       if( OprInsertSPTKCHNG( SpChangeDlTick.ChangeDate, SpChangeDlTick.ChangeKind, SpChangeDlTick, SpChangeDlLeg, SpChangeDlLegBack, COUPON_SUM ) == false )
          return 1;
       end;

     else
       
       FD.GetRQ(DLRQ_TYPE_PAYMENT, 1).rec.Amount = SpChangeDlLeg.TotalCost;
       FD.GetRQ(DLRQ_TYPE_DELIVERY, 1).rec.Amount = SpChangeDlLeg.Principal;

       query = "select 1 from ddl_tick_dbt where t_RequestID = ? ";
       cmd = DL_RSDCommand(query);
       cmd.AddParam(SpChangeDlTick.DealID);

       addNum = cmd.GetCount() + 1;
       while(1)
         query = "select 1 from ddl_tick_dbt where t_DealCode = ? and t_BOfficeKind = ?";
         cmd = DL_RSDCommand(query);
         cmd.AddParam(string(addNum+"/"+SpChangeDlTick.DealCode));
         cmd.AddParam(SpChangeDlTick.BOfficeKind);

         DataSet = cmd.Execute();
         if(not DataSet.moveNext())
           break;
         end;

         addNum = addNum + 1;
       end;

       copy(newtick, SpChangeDlTick);
       newtick.rec.DealID = 0;
       newtick.rec.RequestID  = SpChangeDlTick.DealID;
       newtick.rec.DealCode   = string(addNum+"/"+SpChangeDlTick.DealCode);
       newtick.rec.DealCodeTS = string(addNum+"/"+SpChangeDlTick.DealCodeTS);
       newtick.rec.DealDate   = dat;
       newtick.rec.ChangeDate = date(0,0,0);
       newtick.rec.ParentID   = 0;
       newtick.rec.DealStatus = DL_PREPARING;
       newtick.rec.Version    = 0;
       newtick.rec.PreOutlay  = 0;

       if(IsSALE(FD.Group))
         newtick.rec.PreOutlay = round(FD.tick.rec.PreOutlay * SpChildDlLeg.Principal/FD.dl_leg.rec.Principal, 2);
         SpChangeDlTick.PreOutlay = FD.tick.rec.PreOutlay - newtick.rec.PreOutlay;
       end;

       copy(newleg, SpChangeDlLeg);
       newleg.rec.ID            = 0;
       newleg.rec.DealID        = 0;
       newleg.rec.Maturity      = dat;
       newleg.rec.Expiry        = dat;
       newleg.rec.Principal     = SpChildDlLeg.Principal;
       newleg.rec.Cost          = SpChildDlLeg.Cost;
       newleg.rec.TotalCost     = SpChildDlLeg.TotalCost;
       newleg.rec.NKD           = SpChildDlLeg.NKD;

       /*SVE 496517 в новой сделке стоимость расчитывается без учета поля t_point и количество знаков после запятой может быть больше, что введет к некорректному записи значения в базу*/
       /*Отрезаем от стоимости все что после запятой и сравниваем количество символов, если больше поля t_point, то округляем до необходимого значения, иначе ничего не делаем*/
       if ( Strlen(Substr( string(SpChildDlLeg.Price), index(string(SpChildDlLeg.Price), ".")+1)) != SpChildDlLeg.Point )  
          newleg.rec.Price      = Round(SpChildDlLeg.Price, SpChildDlLeg.Point);
       else
          newleg.rec.Price      = SpChildDlLeg.Price;
       end;
       newleg.rec.Point         = SpChildDlLeg.Point;
       newleg.rec.RelativePrice = SpChildDlLeg.RelativePrice;
       newleg.rec.Version       = 0;

       if( OprInsertSPTKCHNG( SpChangeDlTick.ChangeDate, SpChangeDlTick.ChangeKind, SpChangeDlTick, SpChangeDlLeg, SpChangeDlLegBack, COUPON_SUM ) == false )
          return 1;
       end;

       if( not OprInsertSecDeal( newtick, newleg, $0, null, null, null, null, false ) )
         MsgBox( "Ошибка при создании дочерней сделки" );
         return 1;
       end;
     end;
   elif( deal.ChangeKind == SPTKCHNG_LONGCALCDVPEXEC ) //Исполнение отложенного расчета по DVP
     dat = change_date;

     SpChangeDlLeg.Maturity = dat;
     SpChangeDlLeg.Expiry   = dat;
       
     FD.GetRQ(DLRQ_TYPE_PAYMENT, 1).rec.PlanDate = dat;
     FD.GetRQ(DLRQ_TYPE_PAYMENT, 1).rec.State    = DLRQ_STATE_PLAN;

     FD.GetRQ(DLRQ_TYPE_DELIVERY, 1).rec.PlanDate = dat;
     FD.GetRQ(DLRQ_TYPE_DELIVERY, 1).rec.State    = DLRQ_STATE_PLAN;

     if( not OprReplanStepPlanDates(DATE_DEALSETAVOIRISS, dat, false ) )
        msgbox("Ошибка при попытке переинициализировать дату " );         
        return 1;
     end;

     if( not OprReplanStepPlanDates(DATE_DEALPAY, dat, false ) )
        msgbox("Ошибка при попытке переинициализировать дату " );         
        return 1;
     end;

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, dat) != 0)
       return 1;
     end;

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT, dat) != 0)
       return 1;
     end;

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, dat) != 0)
       return 1;
     end;

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DEPO, dat) != 0)
       return 1;
     end;

     if( OprInsertSPTKCHNG( SpChangeDlTick.ChangeDate, SpChangeDlTick.ChangeKind, SpChangeDlTick, SpChangeDlLeg, SpChangeDlLegBack, COUPON_SUM ) == false )
        return 1;
     end;     
   else
     if( OprInsertSPTKCHNG( SpChangeDlTick.ChangeDate, SpChangeDlTick.ChangeKind, SpChangeDlTick, SpChangeDlLeg, SpChangeDlLegBack, COUPON_SUM ) == false )
      return 1;
     end;
   end;
   
   /*изменение условий сделки*/
   if( (deal.ChangeKind == SPTKCHNG_CHANGE) or (deal.ChangeKind == SPTKCHNG_COUPON) ) 
     dat = change_date;

     /*Учет купона - как изменения 2 части*/
     if( deal.ChangeKind != SPTKCHNG_COUPON )

        if( FD.DateArray[DATE_DEALBEGINEXEC] != null ) 
           ВидСрочностиСделкиДоИзменений = FD.ВидСрочностиСделки();
        end;
        if( FD.DateArray[DATE_DEALPAY] != null )
           save_datebegsett1 = FD.DateArray[DATE_DEALPAY];
        end; 
        if( FD.DateArray[DATE_DEALSETAVOIRISS] != null )
           save_datesetavoir1 = FD.DateArray[DATE_DEALSETAVOIRISS];
        end; 

        if( ПроверитьПлановыеДатыСделки(FD, Dat) == false )
           return 1;
        end;

        SetRQFromArray(FD, DLRQ_TYPE_PAYMENT);
        SetRQFromArray(FD, DLRQ_TYPE_DELIVERY);
        SetRQFromArray(FD, DLRQ_TYPE_AVANCE);
        SetRQFromArray(FD, DLRQ_TYPE_DEPOSIT);

        ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
        while( j < ArrFIID.size )

           FD.SetCurPFI(ArrFIID(j));

           /*Обновить дату и время на лоте*/
           if( FD.IsExistWrtSum AND ((FD.pmwrtsum.rec.Date != FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) OR (FD.tick.rec.DealTime != SpChangeDlTick.DealTime)) )
              FD.pmwrtsum.rec.Time = SpChangeDlTick.DealTime;
              FD.pmwrtsum.rec.Date = FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
           end;

           /*Обновить дату и время на лоте*/ 
           if( FD.IsExistWrtSumContr AND ((FD.pmwrtsum_contr.rec.Date != FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) OR (FD.tick.rec.DealTime != SpChangeDlTick.DealTime)) )
              FD.pmwrtsum_contr.rec.Time = SpChangeDlTick.DealTime;
              FD.pmwrtsum_contr.rec.Date = FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
           end;

           j = j + 1;
        end;

        if( ПроверитьИзмененияИСнятьСВнебаланса(FD, SaveDlLeg, SpChangeDlTick, @NeedSetOutBalance) != 0 )
           return 1;
        end;  

        copy(SaveDlTick, FD.tick);
        copy( FD.tick, SpChangeDlTick );   

        copy(SaveDlLeg, FD.dl_leg);
        copy( FD.dl_leg, SpChangeDlLeg );   

        FD.InitParmArray(); /*переинициализируем массив параметров*/
        FD.ПолучитьДатыСделки( true, false );  

        /*Только если ведется учет в депозитарии*/
        //if( DL_CustodyAccounting == DL_CUSTODYACCOUNTING_CUSTODY )
           ПроверитьИзменениеСущественныхПараметровДляДепозУчета(FD);
        //end;

        if( (replan_date_change( FD, dat, ID_Op ) == false) ) 
           return 1;
        end;

        /*обновим количество бумаг в лоте*/
        if( not IsBasket(FD.Group) and (SpChangeDlLeg.Principal != SaveDlLeg.Principal) )
           FD.pmwrtsum.rec.Amount = FD.pmwrtsum_contr.rec.Amount = SpChangeDlLeg.Principal;
        end;
      
        /*По 92468 проверяем дату оплаты. До выполнения 80166 счет открывался 
          меньшей из дат - аванса и оплаты, т.е. датой начала расчетов, 
          теперь же датой оплаты, и перенос нужно делать если изменилась 
          именно дата оплаты, а не начала расчетов.*/
        if( (save_datebegsett1 != FD.DateArray[DATE_DEALPAY]) OR (save_datesetavoir1 != FD.DateArray[DATE_DEALSETAVOIRISS]) )
           change_dates = true;
        else 
           change_dates = false;
        end; 

        if( change_dates )
           j = 0;
           while( j < ArrFIID.size )

              FD.SetCurPFI(ArrFIID(j));

              if(FD.pmwrtsum.rec.SumID)
                if( not ОбновитьЛот( FD.pmwrtsum, PM_WRTSUM_UPDTMODE_CHANGETERM, dat, FD ) )
                   msgbox("Ошибка при обновлении статуса лота");
                   return 1;
                end;
              end;

              if( СделкаСКлиентомКонтрагентом(deal) and (FD.pmwrtsum_contr.rec.SumID))
                 if( not ОбновитьЛот( FD.pmwrtsum_contr, PM_WRTSUM_UPDTMODE_CHANGETERM, dat, FD, null, true ) )
                    msgbox("Ошибка при обновлении статуса лота");
                    return 1;
                 end;
              end;

              j = j + 1;
           end;
        end;

        if( (not IsREPO(FD.Group)) and (СделкаНаВнебалансе(FD)) and (change_dates == true))
          var AccTrOld = TRecHandler("account.dbt"), AccObOld = TRecHandler("account.dbt");
          var grdoctmp = TRecHandler("dlgrdoc.tmp");
          var grdoctmpCache = RsbSQLInsert("dlgrdoc.tmp");
          var КатМинус = "", КатПлюс = "";
          
          GUID = SP_GetGUID();

          if( ВидСрочностиСделкиДоИзменений == СделкаПрочая )
             КатМинус = "-Форвард, прочие";
             КатПлюс  = "+Форвард, прочие";
          elif( ВидСрочностиСделкиДоИзменений == СделкаНеРанееТретьегоДня )
             КатМинус = "-Форвард, дрейф";
             КатПлюс  = "+Форвард, дрейф";
          end;

          if(КатПлюс != "")
            AccTrOld.Clear();
            //если сделка на внебалансе и изменились даты сделки, то найдем текущие внебалансовые счета и сохраним их для проводки
            if( FD.IsExistAccount( КатПлюс, null, true, FIROLE_FIREQ, AccTrOld, null, dat ) )
              grdoctmp.Clear();

              grdoctmp.rec.GUID       = GUID;
              grdoctmp.rec.DocKind    = DLDOC_ACCOUNT;
              grdoctmp.rec.DocID      = AccTrOld.rec.AccountID;
              grdoctmp.rec.SourceType = DLGR_SOURCETYPE_ACC_REQ_OLD;

              grdoctmpCache.AddRecord(grdoctmp);
            end;
          end;

          if(КатМинус != "")
            AccObOld.Clear();
            if( FD.IsExistAccount( КатМинус, null, true, FIROLE_FICOM, AccObOld, null, dat ) )
              grdoctmp.Clear();                                     
                                                                    
              grdoctmp.rec.GUID       = GUID;                       
              grdoctmp.rec.DocKind    = DLDOC_ACCOUNT;              
              grdoctmp.rec.DocID      = AccObOld.rec.AccountID;     
              grdoctmp.rec.SourceType = DLGR_SOURCETYPE_ACC_COM_OLD;

              grdoctmpCache.AddRecord(grdoctmp);
            end;
          end;

          if( (КатПлюс != "") OR (КатМинус != "") )
             if( not grdoctmpCache.insert() )
                msgbox("Ошибка при сохранении счетов срочности");
                return 1;
             end;
          end;

          if( ОбработатьИзменениеУсловийСделки(FD, NeedSetOutBalance) == 1 )
            return 1;
          end;    
        end;
     end;    

     if( FD.ExistBack == true )

        if( FD2.DateArray[DATE_DEALBEGINEXEC] != null ) 
           ВидСрочностиСделкиДоИзменений_2 = FD2.ВидСрочностиСделки();
        end;
        if( FD2.DateArray[DATE_DEALPAY] != null )
           save_datebegsett2 = FD2.DateArray[DATE_DEALPAY];
        end; 
        if( FD2.DateArray[DATE_DEALSETAVOIRISS] != null )
           save_datesetavoir2 = FD2.DateArray[DATE_DEALSETAVOIRISS];
        end; 

        if( ПроверитьПлановыеДатыСделки( FD2, Dat ) == false )
           return 1;
        end;

        SetRQFromArray(FD2, DLRQ_TYPE_PAYMENT);
        SetRQFromArray(FD2, DLRQ_TYPE_DELIVERY);
        SetRQFromArray(FD2, DLRQ_TYPE_AVANCE);
        SetRQFromArray(FD2, DLRQ_TYPE_DEPOSIT);
        SetRQFromArray(FD2, DLRQ_TYPE_INCREPO);

        ArrFIID2 = FD2.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
        j = 0;
        while( j < ArrFIID2.size )

           FD2.SetCurPFI(ArrFIID2(j));

           if( FD2.IsExistWrtSum AND (FD2.pmwrtsum.rec.Date != FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) )
              /*Обновить дату*/
              FD2.pmwrtsum.rec.Date = FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
           end;

           if( FD2.IsExistWrtSumContr AND (FD2.pmwrtsum_contr.rec.Date != FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) )
              /*Обновить дату*/
              FD2.pmwrtsum_contr.rec.Date = FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
           end;

           j = j + 1;
        end;

        copy( FD2.tick, SpChangeDlTick );   
        copy( SaveDlLegBack, FD2.dl_leg );   
        copy( FD2.dl_leg, SpChangeDlLegBack );   

        FD2.InitParmArray();/*переинициализируем массив параметров*/
        FD2.ПолучитьДатыСделки( true, false, FD );

        /*Только если ведется учет в депозитарии*/
        //if( DL_CustodyAccounting == DL_CUSTODYACCOUNTING_CUSTODY )
           ПроверитьИзменениеСущественныхПараметровДляДепозУчета(FD2);
        //end;

        if( replan_date_change( FD2, dat, ID_Op ) == false ) 
           return 1;
        end; 

        if( replan_date( FD2, DATE_DEALOUTBAL_2 ) == false )
           return 1;
        end; 
        if( replan_date( FD2, DATE_DEALBEGIN_2 ) == false )
           return 1;
        end; 

        if( (save_datebegsett2 != FD2.DateArray[DATE_DEALPAY]) OR (save_datesetavoir2 != FD2.DateArray[DATE_DEALSETAVOIRISS]) )
           change_dates_2 = change_dates = true;
        else 
           change_dates_2 = change_dates = false;
        end; 

        if( change_dates_2 )
           var IsExistWrtSum = false;

           j = 0;
           while( j < ArrFIID2.size )
              FD2.SetCurPFI(ArrFIID2(j));
              i = 0;
              while( (FD2.pmwrtsum(i) != null) and (FD2.pmwrtsum(i).rec.SumID) )
                IsExistWrtSum = true;

                if( IsBuy(FD2.Group) ) // только для лота 2ч ОР
              
                   FD2.pmwrtsum(i).rec.Date = FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;

                   if( not ОбновитьЛот( FD2.pmwrtsum(i), PM_WRTSUM_UPDTMODE_CHANGETERM, dat, FD2 ) )
                      msgbox("Ошибка при обновлении статуса лота"); 
                      return 1;
                   end;
              
                end;
             
                i = i + 1;
              end;
             j = j + 1;
           end;

           /* обновим количество бумаг в лоте */
           if( not IsBasket(FD2.Group) and (SpChangeDlLegBack.Principal != SaveDlLegBack.Principal) )
              FD2.pmwrtsum.rec.Amount = FD2.pmwrtsum_contr.rec.Amount = SpChangeDlLegBack.Principal;
           end;
        end;  
     end;

     /*Только если ведется учет в депозитарии*/
     //if( DL_CustodyAccounting == DL_CUSTODYACCOUNTING_CUSTODY )
        ВывестиСообщениеОбИзмененииСущественныхПараметровДляДепозУчета();
     //end;

    if((deal.ChangeKind == SPTKCHNG_CHANGE) and (SetChangeGrDeal(FD, FD2, dat, GUID) != 0))
      return 1;
    end;   

    if( ПроверитьНеобходимостьРепортингаВРепозитарии( FD ) and ПроверитьИзменениеПараметровДляРепозУчета( FD ) and (not isBulkReportPlanned(FD.tick.rec.DealID)) and (РАБОТА_С_РЕПОЗИТАРИЕМ()) )
      if ((FindUnloadedMessages(FD.tick.rec.DealID)) or (FindUnloadedBulkMessages(FD.tick.rec.DealID)))
        MsgBox("По сделке есть подготовленные, но не сгенерированные сообщения. Необходимо либо выполнить откат подготовки сообщения, либо выполнить для него генерацию");
        return 1;
      else
/*
        var requestTimeout = 0;
        GetRegistryValue("РЕПОЗИТАРИЙ\\СРОК ОЖИД.ЗАПР. ПРИ КОМБ.ПОДТВ.", V_INTEGER, requestTimeout, null);
*/

        var planDate = dat;
        if( isPendingRequestDeal(FD.tick.rec.DealID) and ( requestTimeout > 0 ) )
          planDate = GetDateAfterWorkDays(planDate, requestTimeout, FD.ПолучитьКалендСвязанный());
          if( DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_CHANGEMSGWTHREQUEST, planDate, time(0,0,0), FD.tick.rec.PFI, GUID ) )
            return 1;
          end;
        elif( DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_CHANGEMSG, planDate, time(0,0,0), FD.tick.rec.PFI, GUID ) )
          return 1;
        end;  
      end;
    end;
     
   /*отказ от сделки*/
   elif( deal.ChangeKind == SPTKCHNG_REJECT )

      if( CheckRqRejectPart( FD ) == false )
         MsgBox( "Запрещено выполнять операцию т.к. по сделке есть ТО, включенные в неттинг." );
         return 1;
      end;

      dat = reject_date;

      if( replan_date_reject( FD, dat ) == false ) 
         return 1;
      end;

      SkipGrDeal = true;
      if (IsREPO( FD.Group ) )
         if( IsOUTEXCHANGE( FD.Group ) and СделкаНаВнебалансе( FD ) and (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY))) and (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT))) )
            SkipGrDeal = false;
         end;
      else
         /*строка вставляется в график всегда, а уже в СО БУ разбираемся - нужны проводки или нет и какие именно*/
         SkipGrDeal = false;/*по ТЗ для обычных сделок вставляется всегда*/
      end;

      if( ЗакрытьТО( FD, dat ) == false )
         return 1;
      end;

      if (IsREPO( FD.Group ))
         if( ЗакрытьТО( FD2, dat ) == false )
            return 1;
         end;
      end;

      SaveRQ(FD, FD2, dat);
      ОбработатьТО = false;

      if (IsREPO( FD.Group ))
         if( ПроставитьСтатусыОперацийПриОтказе( FD, false ) != 0 )
            return 1;
         end;
      end;

      if( SetRejectGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, dat, SkipGrDeal) != 0 )
         return 1;
      end;

      if( InsertInfOprReject( deal.DealID ) != 0 )
         MsgBox( "Ошибка при вставке информационной операции" );
         return 1;
      end;

      if( (IsREPO(FD.Group)) and IsCloseContr(FD) and ( РАБОТА_С_РЕПОЗИТАРИЕМ()) and (reporting) )
        ВставитьДействиеИзменениеСостоянияОбязательств(FD, FD.tick.BOfficeKind, FD.tick.DealID, FD.tick.PFI, dat, ОжиданиеЗапроса, requestTimeoutRej);
      elif( IsOUTEXCHANGE(FD.Group) OR IsBROKER(FD.Group) )
        ВставитьДействиеИзменениеСостоянияОбязательствВнеБиржи(FD, dat);
      end;
   /*отказ от 2-ой части сделки*/
   elif( deal.ChangeKind == SPTKCHNG_REJECT2 ) /*отказ от 2ч сделки*/

      dat = reject_date2;

      if( CheckRqRejectPart( FD2 ) == false )
         MsgBox( "Запрещено выполнять операцию т.к. по сделке есть ТО, включенные в неттинг." );
         return 1;
      end;

      /*Проверяется, что лот(ы) по 1 ч. поставлен(ы)*/
      if( (IsREPO(FD.Group)) and (not IsClientDeal(FD.tick.rec)))
         ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
         j = 0;
         while( j < ArrFIID.size )
            FD.SetCurPFI(ArrFIID(j));
            i = 0;
            while( FD.pmwrtsum(i) != null )
               if( FD.pmwrtsum(i).rec.State != PM_WRTSUM_FORM )
                  MsgBox( "Лот по 1ч имеет статус не \"Поставлен\"." );
                  return 1;
               end; 
               i = i + 1;
            end;
           j = j + 1;
         end;
      end;

      if( replan_date_reject( FD2, dat ) == false ) 
         return 1;
      end;
      
      if( (not IsClientDeal(FD.tick.rec)) and (НуженБухучет(DLGR_TEMPL_REJECT) == true) )
        /* Заполняем только для передачи, в БД это не заносится :) */
        if( IsREPO( FD.Group ) and IsBUY( FD.Group ) and (SpChangePmwrtsum.Amount > 0) )
           SpChangePmwrtsum.ID_Operation = ID_Op;
           SpChangePmwrtsum.ID_Step      = ID_Step;
           SpChangePmwrtsum.ChangeDate   = dat;

           ArrFIID2 = FD2.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
           j = 0;
           while( j < ArrFIID2.size )
              FD2.SetCurPFI(ArrFIID2(j));
              i = 0;
              while ((FD2.pmwrtsum(i) != null) and (FD2.pmwrtsum(i).rec.SumID))
                if( not ОбновитьЛот( FD2.pmwrtsum(i), PM_WRTSUM_UPDTMODE_REJECTEXEC, dat, FD2, SpChangePmwrtsum ) )
                  msgbox("Ошибка при изменении статуса лота");
                  return 1;
                end;
                i = i + 1;
              end;

              j = j + 1;
           end;
        else
           var PortfolioSum = TDataPortfSumAdd(); /*сбор сумм лотов по портфелям*/
           var Portfolio = -1,                
               BonusAdd = $0,                 
               NewBonus = $0,                      
               InterestIncomeAdd = $0,             
               NewInterestIncome = $0,        
               DiscountIncomeAdd = $0,             
               NewDiscountIncome = $0,           
               NewNotCarryInterestIncome = $0,                 
               NewNotCarryDiscountIncome = $0,
               NewCost = $0,                  
               NewBalanceCost = $0,
               NewNotWrtBonus = $0;

           ArrFIID2 = FD2.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
           j = 0;
           while( j < ArrFIID2.size )
              FD2.SetCurPFI(ArrFIID2(j));
              PortfolioSum.ClearArray();

              i = 0;
              while ((FD2.pmwrtsum(i) != null) and (FD2.pmwrtsum(i).rec.SumID))
                 if (WRTCalcIncomeRejectDeal (FD2.pmwrtsum(i).rec.SumID,
                                              dat,
                                              Portfolio,                
                                              BonusAdd,                 
                                              NewBonus,                      
                                              InterestIncomeAdd,             
                                              NewInterestIncome,        
                                              DiscountIncomeAdd,             
                                              NewDiscountIncome,           
                                              NewNotCarryInterestIncome,                 
                                              NewNotCarryDiscountIncome,
                                              NewCost,                  
                                              NewBalanceCost,
                                              NewNotWrtBonus
                                             ) == false)
                   MsgBox("Ошибка при получении сумм дохода при отказе от 2ч ПРЕПО");
                   return false;
                 end;                                              

                 FD2.pmwrtsum(i).rec.Bonus            = NewBonus;
                 FD2.pmwrtsum(i).rec.InterestIncome   = NewInterestIncome;
                 FD2.pmwrtsum(i).rec.DiscountIncome   = NewDiscountIncome;
                 FD2.pmwrtsum(i).rec.NotCarryInterest = NewNotCarryInterestIncome;
                 FD2.pmwrtsum(i).rec.NotCarryDiscount = NewNotCarryDiscountIncome;
                 FD2.pmwrtsum(i).rec.Cost             = NewCost;
                 FD2.pmwrtsum(i).rec.BalanceCost      = NewBalanceCost;
                 FD2.pmwrtsum(i).rec.NotWrtBonus      = NewNotWrtBonus;
                 FD2.pmwrtsum(i).rec.ChangeDate       = dat;
                 FD2.pmwrtsum(i).rec.State            = PM_WRTSUM_CANCEL;

                 if ((Portfolio == KINDPORT_TRADE) OR
                     (Portfolio == KINDPORT_SALE) OR
                     (Portfolio == KINDPORT_RETIRE)  
                    ) 
                   PortfolioSum.AddLine(Portfolio, BonusAdd, InterestIncomeAdd, DiscountIncomeAdd);                                                                                
                 elif((Portfolio == KINDPORT_BACK) AND (FD2.pmwrtsum(i).rec.Source))
                   var Lot2 = TRecHandler("pmwrtsum.dbt");
                   cmd = DL_RSDCommand("select * from dpmwrtsum_dbt where t_Parent = ?");
                   cmd.AddParam(FD2.pmwrtsum(i).rec.Source);
                   DataSet = cmd.Execute();

                   if(DataSet.moveNext())

                     DataSet.GetRecord().CopyTo( Lot2.rec );

                     var cmd1 = DL_RSDCommand("select * from dpmwrtlnk_dbt where t_BuyID = ? and t_SaleID = ?");
                     cmd1.AddParam(Lot2.rec.Parent);
                     cmd1.AddParam(FD2.pmwrtsum(i).rec.Parent);
                     var Lnk = cmd1.Execute();

                     if(Lnk.moveNext())
                       Lot2.rec.AmountBD      = Lot2.rec.AmountBD + Lnk.Amount;
                       Lot2.rec.BalanceCostBD = Lot2.rec.BalanceCostBD + Lnk.BalanceCostSale;
                       
                       if( not ОбновитьЛот( Lot2, PM_WRTSUM_UPDTMODE_CORRECT, dat, FD2 ) )
                         msgbox("Ошибка при обновлении лота"); 
                         return false;
                       end;

                     else
                       msgbox("Не найдена связь списания"); 
                       return false;
                     end;

                   else
                     msgbox("Не найден лот 2ч"); 
                     return false;
                   end;

                 end;

                 if( not ОбновитьЛот( FD2.pmwrtsum(i), PM_WRTSUM_UPDTMODE_REJECTEXEC, dat, FD ) )
                   msgbox("Ошибка при обновлении лота"); 
                   return false;
                 end; 

               i = i + 1;
             end;

             /* сохранение сумм доходов */
             PortfolioSum.SaveSum(FD2, dat);

             j = j + 1;
           end;
        end;
      end;

      if( ЗакрытьТО( FD2, dat ) == false )
         return 1;
      end;

      SaveRQ(FD, FD2, dat);
      ОбработатьТО = false;

      if( IsREPO( FD2.Group ) )
         if( ПроставитьСтатусыОперацийПриОтказе( FD2, true ) != 0 )
            return 1;
         end;
      end;

      if( SetRejectGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, dat, false, true) != 0 )
        return 1;
      end;

      if( InsertInfOprReject( deal.DealID ) != 0 )
        MsgBox( "Ошибка при вставке информационной операции" );
        return 1;
      end;

      if ((IsREPO( FD.Group )) and IsCloseContr(FD) and ( РАБОТА_С_РЕПОЗИТАРИЕМ()) and (reporting))
        ВставитьДействиеИзменениеСостоянияОбязательств(FD, FD.tick.BOfficeKind, FD.tick.DealID, FD.tick.PFI, dat, ОжиданиеЗапроса, requestTimeoutRej);
      end;

   /*отказ от просроченной сделки (только внебиржевые и брокерские)*/
   elif( deal.ChangeKind == SPTKCHNG_OVREJECT )
   /* Действия аналогичны отказу от исполнения, кроме проводок
     - на лот, если он не поставлен, ставится статус аннулирован
     - на все неисполненные платежи ставится статус "отложен" (как и при отказе от исполнения)
    Все запланированные  шаги по исполнению выполняются без каких-либо действий. 
    Даты всех запланированных шагов переустанавливаются в дату шага. 
    Case шаги (планирования списания и т.д) не планируют никаких шагов. Шаг закрытия выполняется без каких-либо проверок
    Проводки не выполняются */
      if( CheckRqRejectPart( FD ) == false )
         MsgBox( "Запрещено выполнять операцию т.к. по сделке есть ТО, включенные в неттинг." );
         return 1;
      end;

      dat = reject_date;

      if( replan_date_overdue_reject( FD, dat ) == false ) 
         return 1;
      end;

      if( ЗакрытьТО( FD, dat ) == false )
         return 1;
      end;

      SaveRQ(FD, FD2, dat);
      ОбработатьТО = false;

      if( ПроставитьСтатусыПриОтказеПросроч( FD ) != 0 )
         return 1;
      end;

      if(SetRejectGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, dat, true) != 0)
        return 1;
      end;

      if( InsertInfOprReject( deal.DealID ) != 0 )
        MsgBox( "Ошибка при вставке информационной операции" );
        return 1;
      end;

      if( IsOUTEXCHANGE(FD.Group) or (IsBroker(FD.Group)) )
        ВставитьДействиеИзменениеСостоянияОбязательствВнеБиржи(FD, dat);
      end;
   end;

   if( ОбработатьТО )/*для  отказов ТО обработано выше*/
      SaveRQ(FD, FD2, dat);
   end;

   return 0;
end;


/* Макрос постобработки */
PRIVATE MACRO PostStep (    
                CommitOrRollback, /*1-выполнение шага,2 -отакат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    
   record Deal_Tick("dl_tick");
   var FD;

   SetBuff( Deal_Tick, FDoc ); 

   if (errTrn OR (CommitOrRollback == 2)) 
       /* Произошла ошибка или происходит откат */
       return;
   end;

   if(Deal_Tick.ChangeKind == SPTKCHNG_PARTEXEC)
     var cmd, query, DataSet;

     query =   " select NVL(max(t_DealID), 0) as DealID "
             + "   from ddl_tick_dbt "
             + "  where t_RequestID = ? "
             + "    and t_DealStatus = " + DL_PREPARING;
     cmd = DL_RSDCommand(query);

     cmd.AddParam(Deal_Tick.DealID);

     DataSet = cmd.Execute();
     if((DataSet.moveNext()) and (DataSet.DealID > 0))   
        SP_ExecDeal(int(DataSet.DealID), false );
     end;
   end;

   return 0;

END;