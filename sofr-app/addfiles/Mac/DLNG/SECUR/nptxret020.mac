/*
$Name: nptxret020.mac
$Module: Ценные бумаги
$Description: Операция обработки заявлений на возврат налога. Шаг формирования операций возврата налога
*/

import InsCarryDoc, "sp_categ.mac", "sp_car.mac", RsbDataSet, DealsInter, "nptxreqfun.mac";

private macro Error( ErrStr:STRING ):INTEGER
  DL_NPTX_PutMsg( ErrStr );
  MsgBox( ErrStr );
  return 1;
end;

private macro ExistsNptxopCode(DocKind, Code)
  var query, cmd;

  query = "select 1 from dnptxop_dbt where t_DocKind = ? and t_Code = ?";
  cmd = DL_RSDCommand(query);
  cmd.AddParam(DocKind);
  cmd.AddParam(Code);

  if(cmd.GetCount() > 0)
    return true;
  end;

  return false;
end;


macro ExecuteStep( doc, FDoc )
  var err = 0;
  var nptxop = TRecHandler("nptxop.dbt");
  var acc    = TRecHandler("account.dbt");
  var party  = TRecHandler("party.dbt");
  var prevClientTaxRetSum = $0;
  var prevClientID = -1;
  var prevYear = 0;

  SetBuff( nptxop, FDoc );

  var FD = DLFirstDocNPTXOP(nptxop);
  var S1осн = $0, S1повыш = $0;

  if( FD.IsExistAccount("НДФЛ к перечислению, FLR", null, true, null, acc, null, nptxop.rec.OperDate, NATCUR ) )
    S1осн = DL_GetRestAccount(acc.rec,nptxop.rec.OperDate);
  end;

  if( FD.IsExistAccount("НДФЛ к перечислению 15%", null, true, null, acc, null, nptxop.rec.OperDate, NATCUR ) )
    S1повыш = DL_GetRestAccount(acc.rec,nptxop.rec.OperDate);
  end;

  var cmd = DL_RSDCommand();
  var query = 
    "   SELECT * "
   +"     FROM dnptxop_dbt "
   +"    WHERE T_DocKind = "+DL_RETREQ+" AND T_STATUS IN ("+DLNPTXRETREQ_CHECKED+", "+DLNPTXRETREQ_PARTEXECUTED+") "
   +"      and t_OperDate <= ? ";

  cmd.AddParam(nptxop.rec.OperDate);
   
  if(nptxop.rec.Client > 0)
    query = query + "AND T_CLIENT = ? ";
    cmd.AddParam(nptxop.rec.Client);
  end;
   
  query = query +" ORDER BY T_OperDate ASC, T_Time ASC";

  var ds = cmd.execute(query);

  while (ds.MoveNext() and (err == 0))

    var Account = "";
    var Year = 0;

    DateSplit(SQL_ConvTypeDate(ds.PrevDate), null, null, Year);

    if((prevClientID != ds.Client) or (prevYear != Year))
      prevClientTaxRetSum = $0;
    end;

    query = 
      "   SELECT T_ACCOUNT "
     +"     FROM DSETTACC_DBT "
     +"    WHERE     T_CHAPTER IN (0,1) "
     +"          AND t_fiid = " + NATCUR
     +"          AND t_account NOT LIKE '306%' "
     +"          AND T_BANKID IN (select dp.t_PartyID from ddp_dep_dbt dp) "
     +"          AND T_PARTYID = ? "
     +" ORDER BY T_ORDER ASC ";
   
    var cmd2 = DL_RSDCommand(query);
    cmd2.AddParam(SQL_ConvTypeInteger(ds.Client));
    var ds2 = cmd2.Execute();
    if (not ds2.moveNext())
      DL_NPTX_PutMsg( "Для субъекта с ID \""+ds.Client+"\" по заявлению с кодом \""+ds.Code+"\" не найден счет по возврату налога.",10);
      continue;
    else
      Account = ds2.Account;
    end;

    var S2 = SQL_ConvTypeSum(ds.TaxToPay);
    var S3 = SQL_ConvTypeSum(ds.TaxDp);
    var S4 = SQL_ConvTypeSum(ds.TaxSum);
    var S5 = SQL_ConvTypeSum(ds.TaxSum2);

    var D1 = SQL_ConvTypeDate(ds.OperDate);

    var DateRefund = GetNptxReqDateRefund(D1); 
    
    var taxRefundDebt = S2 - S4;
    var taxRefundDebt15 = S3 - S5;

    var taxRetSum = $0;

    //если срок выплаты наступил, или его превышает, то берём всю сумму налога вне зависимости от остатков
    if (nptxop.rec.OperDate >= DateRefund) 
      taxRetSum = taxRefundDebt + taxRefundDebt15;
    //в других случаях берём только ту сумму, что есть по счетам
    elif (((S1осн > $0) and (taxRefundDebt > $0)) or ((S1повыш > $0) and (taxRefundDebt15 > $0)))
      taxRetSum = min(S1осн,taxRefundDebt) + min(S1повыш, taxRefundDebt15);
    end;

    taxRetSum = max($0, taxRetSum - prevClientTaxRetSum);

    if (taxRetSum > $0)
      
      var RefID;
      var nptxop_new = TRecHandler( "nptxop.dbt" );
      
      GenerateNumberByReference( 133/*OBJTYPE_NPTXHOLD*/, 1, @RefID, @nptxop_new.rec.Code );
      if(nptxop_new.rec.Code != "")
        var i = 0;
        while(ExistsNptxopCode(DL_HOLDNDFL, nptxop_new.rec.Code))
          if(i == 100) //На всякий случай, чтобы не зависла операция
            return Error("Ошибка при генерации номера операции удержания НДФЛ");
          end;
          
          GenerateNumberByReference( 133/*OBJTYPE_NPTXHOLD*/, 1, @RefID, @nptxop_new.rec.Code );
          i = i + 1;
        end;
      end;

      nptxop_new.rec.DocKind           = DL_HOLDNDFL;
      nptxop_new.rec.OperDate          = nptxop.rec.OperDate;
      nptxop_new.rec.SubKind_Operation = DL_TXHOLD_OPTYPE_TAXREF;  // Подвид операции
      nptxop_new.rec.Department        = {OperDprt};
      nptxop_new.rec.Oper              = nptxop.rec.Oper;
      nptxop_new.rec.Status            = 0/*DL_TXOP_Prep*/;
      nptxop_new.rec.Recalc            = UNSET_CHAR;
      nptxop_new.rec.FIID              = ALLFININSTR;
      nptxop_new.rec.BegRecalcDate     = date(01,01,Year);
      nptxop_new.rec.EndRecalcDate     = date(31,12,Year);
      nptxop_new.rec.Client            = ds.Client;
      nptxop_new.rec.FlagTax           = UNSET_CHAR;
      nptxop_new.rec.Method            = DL_TYPEGETNALOG_CURRENT_ACC;
      nptxop_new.rec.Account           = Account;

      nptxop_new.rec.Kind_Operation    = 2038;
      nptxop_new.rec.PrevDate          = date(01,01,Year);
      nptxop_new.rec.Tax               = taxRetSum;

      if ( not CreateNptxOpStep(nptxop_new, true))
        err = 1;
        DL_NPTX_PutMsg( "Ошибка создания операции возврата налога для субъекта с ID \""+ds.Client+"\"", 10);
      else
        DL_NPTX_PutMsg( "Для субъекта с ID \""+ds.Client+"\" по заявлению с кодом \""+ds.Code+"\" операция возврата налога успешно создана.",21);
      end;

      prevClientTaxRetSum = prevClientTaxRetSum + taxRetSum;
    else
      DL_NPTX_PutMsg( "Для субъекта с ID \""+ds.Client+"\" по заявлению с кодом \""+ds.Code+"\" сумма возврата налога равна 0",10);
    end;

    prevClientID = ds.Client;
    prevYear     = Year;
  end;

  if (not err) //закрываем ДО
    if( not InsertOprStatus(46421, 2)) //Установить ДО
      err = Error( "Ошибка при установке статуса вида \"Установить ДО\" операции" );        
    end;
  end;

  DL_NPTX_SaveOperLog( nptxop.rec.ID, 20 );

  return err;
end;

