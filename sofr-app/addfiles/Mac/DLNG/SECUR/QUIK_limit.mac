/*
$Name:        QUIK_limit.mac
$Module:      Ценные бумаги
$Description: Расчет лимитов для QUIK на начало дня
*/
IMPORT SPInter, DealsInter, spserv, "QUIK_PrintProtocol.mac", RsbDataSet, "QUIK_ReconAndPrint.mac";   

PRIVATE VAR ProtocolData;
PRIVATE CONST ERROR_CALENDAR  = 0,
              ERROR_CURRENCY  = 1,
              ERROR_IN_SQL    = 2,
              ERROR_SETT_NOTFOUND = 3;

PRIVATE VAR CurrHistID = -1;

CLASS MarketDataForLimit(v_MarketID, v_MarketCode, v_FlagStockDl, v_FlagDeriv, v_FlagCurr)
  var 
      MarketID = v_MarketID,
      MarketCode = v_MarketCode,
      FlagStockDl = v_FlagStockDl,
      FlagDeriv = v_FlagDeriv,
      FlagCurr = v_FlagCurr;
END;


PRIVATE MACRO YesNoWin(msg:string)
  Array Text;
  Array Button;
  Button(0) = "Нет";
  Button(1) = "Да";
  var but, ind = 0;

  Text(ind) = msg;
  but = ConfWin(Text,Button);
  
  return but;
END;

PRIVATE MACRO ЗаполнитьДатыВалюты( FlagCurr, Curr, FlagStockDl, Stock, CalcDate )
  Var Date0 = CalcDate, 
      Date365 = date(31,12,2999);
  Var query, cmd, DataSet; 


  SQL_Execute("DELETE FROM DDL_LIMITCHECKDATE_DBT", "", false );     // очистим таблицу с датами

  if(FlagCurr)
    if(Curr.rec.KindLargerTwo == SET_CHAR)   // для всех
      query =   " INSERT INTO DDL_LIMITCHECKDATE_DBT "
            + " SELECT fi.t_fiid , " 
            + " ?, "
            + " RSI_SCLIMIT.GetLimitDateKind( ?, 1, fi.t_fiid, ? /*CurID */, ? /*CalendarID */, 1  ), "
            + " RSI_SCLIMIT.GetLimitDateKind( ?, 2, fi.t_fiid, ? /*CurID */, ? /*CalendarID */, 1  ), "
            + " ?, "
            + " CHR(88),   "
            + " (CASE WHEN fi.t_fiid = ? THEN CHR(88) ELSE CHR(1) END ) "
            + "  FROM dfininstr_dbt fi  "
            + " WHERE     INSTR ( (SELECT t_name  "
            + "                      FROM dllvalues_dbt  "
            + "                     WHERE t_list = " + OBJTYPE_LIMIT_CUR + " AND t_element = ?),t_ccy) > 0  "
            + "       AND fi.t_IsClosed <> CHR (88)  "
            ;
         cmd = RSDCommand(query);
         cmd.AddParam("", RSDBP_IN, Date0);
         cmd.AddParam("", RSDBP_IN, Date0);// дата расчета
         cmd.AddParam("", RSDBP_IN, Curr.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Curr.rec.CalendarID);
         cmd.AddParam("", RSDBP_IN, Date0);// дата расчета
         cmd.AddParam("", RSDBP_IN, Curr.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Curr.rec.CalendarID);
         cmd.AddParam("", RSDBP_IN, Date365);
         cmd.AddParam("", RSDBP_IN, Curr.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Curr.rec.CurLimitKind);

         cmd.Execute();

    else
      query =   " INSERT INTO DDL_LIMITCHECKDATE_DBT "
            + " SELECT fi.t_fiid , " 
            + " ?, "
            + " ?, "
            + " ?, "
            + " ?, "
            + " CHR(88),   "
            + " (CASE WHEN fi.t_fiid = ? THEN CHR(88) ELSE CHR(1) END ) "
            + "  FROM dfininstr_dbt fi  "
            + " WHERE     INSTR ( (SELECT t_name  "
            + "                      FROM dllvalues_dbt  "
            + "                     WHERE t_list = " + OBJTYPE_LIMIT_CUR + " AND t_element = ?),t_ccy) > 0  "
            + "       AND fi.t_IsClosed <> CHR (88)  "
            ;
         cmd = RSDCommand(query);
         cmd.AddParam("", RSDBP_IN, Date0);
         cmd.AddParam("", RSDBP_IN, Date365);
         cmd.AddParam("", RSDBP_IN, Date365);
         cmd.AddParam("", RSDBP_IN, Date365);
         cmd.AddParam("", RSDBP_IN, Curr.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Curr.rec.CurLimitKind);

         cmd.Execute();

    end;
  end;

  if(FlagStockDl)
      query =   " INSERT INTO DDL_LIMITCHECKDATE_DBT "
            + " SELECT fi.t_fiid , " 
            + " ?, "
            + " RSI_SCLIMIT.GetLimitDateKind( ?, 1, fi.t_fiid, ? /*CurID */, ? /*CalendarID */, 0  ), "
            + " RSI_SCLIMIT.GetLimitDateKind( ?, 2, fi.t_fiid, ? /*CurID */, ? /*CalendarID */, 0  ), "
            + " ?, "
            + " CHR(1),   "
            + " (CASE WHEN fi.t_fiid = ? THEN CHR(88) ELSE CHR(1) END ) "
            + "  FROM dfininstr_dbt fi  "
            + " WHERE     INSTR ( (SELECT t_name  "
            + "                      FROM dllvalues_dbt  "
            + "                     WHERE t_list = " + OBJTYPE_LIMIT_CUR + " AND t_element = ?),t_ccy) > 0  "
            + "       AND fi.t_IsClosed <> CHR (88)  "
            ;
         cmd = RSDCommand(query);
         cmd.AddParam("", RSDBP_IN, Date0);
         cmd.AddParam("", RSDBP_IN, Date0);// дата расчета
         cmd.AddParam("", RSDBP_IN, Stock.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Stock.rec.CalendarID);
         cmd.AddParam("", RSDBP_IN, Date0);// дата расчета
         cmd.AddParam("", RSDBP_IN, Stock.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Stock.rec.CalendarID);
         cmd.AddParam("", RSDBP_IN, Date365);
         cmd.AddParam("", RSDBP_IN, Stock.rec.CurID);
         cmd.AddParam("", RSDBP_IN, Stock.rec.CurLimitKind);

         cmd.Execute();
  end;

END;

PRIVATE MACRO ПроверитьВалютыИКаледари( Kind , CurID)
   Var text = "";
   Var query, cmd, DataSet; 
   query = " SELECT fi.t_ccy "
         + "  FROM dfininstr_dbt fi "
         + "  WHERE     INSTR ( (SELECT t_name "
         + "                       FROM dllvalues_dbt "
         + "                      WHERE t_list = " + OBJTYPE_LIMIT_CUR + " AND t_element = ?), t_ccy) > 0 "
         + "        AND fi.t_fiid <> ? "
         + "        AND NOT EXISTS "
         + "                  (SELECT 1  FROM dcalcor_dbt cal "
         + "                    WHERE     cal.t_objecttype = 2 "
         + "                          AND LPAD (fi.t_fiid, 10, '0') = cal.t_object) "
         + "            AND fi.t_IsClosed <> CHR(88) "
         ;
      cmd = DL_RSDCommand(query);

      cmd.AddParam(Kind);
      cmd.AddParam(CurID);

      DataSet = cmd.Execute();
      While(DataSet.moveNext())
        if(text != "")
          text = text + ", ";
        end;
        text = text + DataSet.ccy;
      end;

   return text;
end;

PRIVATE MACRO ЕстьЛиРасчетыЗаДень( CalcDate, MarketKind, MarketCode, NeedSeparateCalc, CountCash:@INTEGER, CountSec:@INTEGER): INTEGER
  var query, cmd, DataSet; 
  var result = 0;

  if((MarketKind == "фондовый") OR (MarketKind == "валютный"))
    query = "SELECT COUNT (t_ID) AS ExistCalc " +
            "  FROM (SELECT cash.t_ID " +
            "          FROM ddl_limitcashstock_dbt cash " +
            "         WHERE     CASH.T_DATE = ? " +
            "               AND LOWER (cash.t_market_kind) = ? " +
            IIF ((MarketKind == "фондовый"), "               AND cash.t_Market = ? ", "" ) +
            "        UNION ALL " +
            "        SELECT securites.t_ID " +
            "          FROM ddl_limitsecurites_dbt securites " +
            "         WHERE     securites.T_DATE = ? " +
            IIF((MarketKind == "фондовый"), "               AND securites.t_Market = ? ", "") + 
            "               AND LOWER (securites.t_market_kind) = ? )";
    cmd = DL_RSDCommand(query);

    cmd.AddParam(CalcDate);
    cmd.AddParam(MarketKind);
    if (MarketKind == "фондовый")
      cmd.AddParam(IIF(MarketCode == "", "", MarketCode));
    end;
    cmd.AddParam(CalcDate);
    if (MarketKind == "фондовый")
      cmd.AddParam(IIF(MarketCode == "", "", MarketCode));
    end;
    cmd.AddParam(MarketKind);
  elif ((MarketKind == "срочный"))
    query = "SELECT COUNT (t_ID) AS ExistCalc " +
            "  FROM ddl_limitfuturmark_dbt deriv " +
            " WHERE deriv.T_DATE = ? AND deriv.t_Market = ?";
    cmd = DL_RSDCommand(query);

    cmd.AddParam(CalcDate);
    cmd.AddParam(MarketCode);
  end;

  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    result = DataSet.ExistCalc;
  end;

  if((ValType(NeedSeparateCalc) != V_UNDEF) AND (NeedSeparateCalc == true))
    //денежный
    query = "SELECT COUNT(cash.t_ID) as CountCash " +
            "          FROM ddl_limitcashstock_dbt cash " +
            "         WHERE     CASH.T_DATE = ? " +
            "               AND LOWER (cash.t_market_kind) = ? " +
            IIF ((MarketKind == "фондовый"), "               AND cash.t_Market = ? ", "" );
    cmd = DL_RSDCommand(query);

    cmd.AddParam(CalcDate);
    cmd.AddParam(MarketKind);
    if (MarketKind == "фондовый")
      cmd.AddParam(IIF(MarketCode == "", "", MarketCode));
    end;
    DataSet = cmd.Execute();
    if(DataSet.moveNext())
      CountCash = DataSet.CountCash;
    end;

    //инструментальный
    query = "SELECT COUNT(securites.t_ID) as CountSec " +
            "          FROM ddl_limitsecurites_dbt securites " +
            "         WHERE     securites.T_DATE = ? " +
            "               AND LOWER (securites.t_market_kind) = ? " +
            IIF ((MarketKind == "фондовый"), "               AND securites.t_Market = ? ", "" );
    cmd = DL_RSDCommand(query);

    cmd.AddParam(CalcDate);
    cmd.AddParam(MarketKind);
    if (MarketKind == "фондовый")
      cmd.AddParam(IIF(MarketCode == "", "", MarketCode));
    end;
    DataSet = cmd.Execute();
    if(DataSet.moveNext())
      CountSec = DataSet.CountSec;
    end;
  end;

   return result;
end;

PRIVATE MACRO СоздатьСтрокиДляПротокола(FlagStockDl, FlagDeriv, FlagCurr, FlagCalc, FlagVerif)
  if(FlagCalc)
    if(FlagStockDl)
      ProtocolData[ProtocolData.size] = QUIK_DataLogParm("фондовый",  NULL, NULL, NULL, "", "");
    end;
    if(FlagCurr)
      ProtocolData[ProtocolData.size] = QUIK_DataLogParm("валютный",  NULL, NULL, NULL, "", "");
    end;
    if(FlagDeriv)
      ProtocolData[ProtocolData.size] = QUIK_DataLogParm("срочный",  NULL, NULL, NULL, "", "");
    end;
  end;
  if(FlagVerif)
    ProtocolData[ProtocolData.size] = QUIK_DataLogParm(" ",  NULL, NULL, NULL, "", "");
  end;
END;

PRIVATE MACRO ДобавитьОшибкуВПротоколПоРынку(MarketKind, ErrorKind, ErrorCurr, ErrStrSql, HandErrResult)
  var arrsize = ProtocolData.size;
  var i = 0;
  var errstr = "Не найден календарь: ";
  var CalcResult = "Расчет не выполнен ";
  while(i < arrsize)
    if(((MarketKind == "фондовый") OR (MarketKind == "валютный")) AND (ProtocolData[i].MarketKind == MarketKind))
      if(ErrorKind == ERROR_CALENDAR)
        ProtocolData[i].Error = ProtocolData[i].Error + errstr + "Расчетный календарь ";
      elif(ErrorKind == ERROR_SETT_NOTFOUND)
        ProtocolData[i].Error = ProtocolData[i].Error + "Настройка расчета лимитов QUIK для данных параметров отсутствует ";
      elif(ErrorKind == ERROR_CURRENCY)
        ProtocolData[i].Error = ProtocolData[i].Error + errstr + ErrorCurr;
      elif(ErrorKind == ERROR_IN_SQL)
        ProtocolData[i].Error = ProtocolData[i].Error + ErrStrSql;
        ProtocolData[i].CalcTotal = 0;
        ProtocolData[i].CalcCash = 0;
        ProtocolData[i].CalcSecurities = 0;
      end;
      ProtocolData[i].HandErrResult = CalcResult;
      break;
    elif((MarketKind == "срочный") AND (ProtocolData[i].MarketKind == MarketKind))
      if(ErrorKind == ERROR_IN_SQL)
        ProtocolData[i].Error = ProtocolData[i].Error + ErrStrSql;
        ProtocolData[i].CalcTotal = 0;
        ProtocolData[i].CalcCash = 0;
        ProtocolData[i].CalcSecurities = 0;
      elif(ErrorKind == ERROR_SETT_NOTFOUND)
        ProtocolData[i].Error = ProtocolData[i].Error + "Настройка расчета лимитов QUIK для данных параметров отсутствует ";
      else
        ProtocolData[i].Error = ProtocolData[i].Error + errstr + "Отказ от расчета из-за ошибок с календарями ";
      end;
      ProtocolData[i].HandErrResult = CalcResult;
      break;
    elif((MarketKind == " ") AND (ProtocolData[i].MarketKind == MarketKind))
      ProtocolData[i].Error = ProtocolData[i].Error + ErrStrSql;
      ProtocolData[i].CalcTotal = 0;
      ProtocolData[i].CalcCash = 0;
      ProtocolData[i].CalcSecurities = 0;
      ProtocolData[i].HandErrResult = HandErrResult;
    end;
    i = i + 1;
  end;
END;

PRIVATE MACRO ДобавитьПервоначальнуюСтрокуВИсторию(DocKind, MarketID, CalcDate)
  var cmd;
  cmd = RSDCommand("begin ? := RSI_SCLIMIT.RSI_InsertLimitHist(?,?,?,?); end;");
  cmd.addParam("retval", RSDBP_OUT, V_INTEGER);
  cmd.AddParam("DocKind",   RSDBP_IN,   DocKind);
  cmd.AddParam("MarketID",  RSDBP_IN,   MarketID);
  cmd.AddParam("CurDate",   RSDBP_IN,   CalcDate);
  cmd.AddParam("Oper",   RSDBP_IN,   {Oper});
  cmd.Execute();
  CurrHistID = cmd.value("retval");
  return CurrHistID;
END;

PRIVATE MACRO ДобавитьКоличествоДляПротоколаПоРынку(MarketKind, TotalCalc, CountCash, CountSec)
  var arrsize = ProtocolData.size;
  var i = 0;
  while(i < arrsize)
    if(((MarketKind == "фондовый") OR (MarketKind == "валютный") OR (MarketKind == " ")) AND (ProtocolData[i].MarketKind == MarketKind))
      ProtocolData[i].CalcTotal = TotalCalc;
      ProtocolData[i].CalcCash = CountCash;
      ProtocolData[i].CalcSecurities = CountSec;
      if(TotalCalc > 0)
        ProtocolData[i].Error = "";
        ProtocolData[i].HandErrResult = "";
      end;
      break;
    elif((MarketKind == "срочный") AND (ProtocolData[i].MarketKind == MarketKind))
      ProtocolData[i].CalcTotal = TotalCalc;
      ProtocolData[i].CalcCash = 0;
      ProtocolData[i].CalcSecurities = 0;
      if(TotalCalc > 0)
        ProtocolData[i].Error = "";
        ProtocolData[i].HandErrResult = "";
      end;
      break;
    end;
    i = i + 1;
  end;
END;

PRIVATE MACRO ОбновитьСтрокуИстории(ID, TimeFrom, TimeTo, CalcDone, ReconTimeFrom, ReconTimeTo, ReconDone)
  var query, cmd; 
  query = "UPDATE DDL_LIMITHIST_DBT SET T_CALCTIMEFROM = ?, T_CALCTIMETO = ? " +
          IIF(CalcDone, ", T_CALCULATED = CHR(88) ", " ") +
          ", T_RECONTIMEFROM = ?, T_RECONTIMETO = ? " + 
          IIF(ReconDone, ", T_RECON = CHR(88) ", " ") +
          " WHERE T_ID = ?";
  cmd = RSDCommand(query);

  cmd.AddParam( "", RSDBP_IN, TimeFrom);
  cmd.AddParam( "", RSDBP_IN, TimeTo);
  cmd.AddParam( "", RSDBP_IN, ReconTimeFrom);
  cmd.AddParam( "", RSDBP_IN, ReconTimeTo);
  cmd.AddParam( "", RSDBP_IN, ID);
  cmd.Execute();
END;

PRIVATE MACRO ЗавершитьФормированиеПротокола(FlagCalc, FlagStockDl, FlagDeriv, FlagCurr, CalcDate, MarketCode, TimeFrom, TimeTo, ErrStr, FlagOverLoad, FlagVerif, QuikReload, Diverg, ReconTimeFrom, ReconTimeTo)
  var TotalCalc = 0;
  var CountCash = 0;
  var CountSec = 0;
  var CalcDone = false;
  var TotalCalcRecon = 0;
  var ReconDone = false;

  if(FlagStockDl)
    TotalCalc = ЕстьЛиРасчетыЗаДень(CalcDate, "фондовый", MarketCode, true, @CountCash, @CountSec);
    if(TotalCalc <= 0)
      ДобавитьОшибкуВПротоколПоРынку("фондовый",ERROR_IN_SQL, "", ErrStr);
    else
      ДобавитьКоличествоДляПротоколаПоРынку("фондовый", TotalCalc, CountCash, CountSec);
      if(FlagCalc) CalcDone = true; end;
    end;
  else
    ДобавитьКоличествоДляПротоколаПоРынку("фондовый", TotalCalc, CountCash, CountSec);
  end;

  TotalCalcRecon = TotalCalcRecon + TotalCalc;
  TotalCalc =  CountCash = CountSec = 0;
  if(FlagCurr)
    TotalCalc = ЕстьЛиРасчетыЗаДень(CalcDate, "валютный", MarketCode, true, @CountCash, @CountSec);
    if(TotalCalc <= 0)
      ДобавитьОшибкуВПротоколПоРынку("валютный",ERROR_IN_SQL, "", ErrStr);
    else
      ДобавитьКоличествоДляПротоколаПоРынку("валютный", TotalCalc, CountCash, CountSec);
      if(FlagCalc) CalcDone = true; end;
    end;
  else
    ДобавитьКоличествоДляПротоколаПоРынку("валютный", TotalCalc, CountCash, CountSec);
  end;

  TotalCalcRecon = TotalCalcRecon + TotalCalc;
  TotalCalc =  CountCash = CountSec = 0;
  if(FlagDeriv)
    TotalCalc = ЕстьЛиРасчетыЗаДень(CalcDate, "срочный", MarketCode);
    if(TotalCalc <= 0)
      ДобавитьОшибкуВПротоколПоРынку("срочный",ERROR_IN_SQL, "", ErrStr);
    else
      ДобавитьКоличествоДляПротоколаПоРынку("срочный", TotalCalc, CountCash, CountSec);
      if(FlagCalc) CalcDone = true; end;
    end;
  else
    ДобавитьКоличествоДляПротоколаПоРынку("срочный", TotalCalc, CountCash, CountSec);
  end;

  if(FlagVerif OR FlagOverLoad)
    ДобавитьКоличествоДляПротоколаПоРынку(" ", QuikReload, TotalCalcRecon, Diverg);
    ReconDone = true;
  end;

  ОбновитьСтрокуИстории(CurrHistID, TimeFrom, TimeTo, CalcDone, ReconTimeFrom, ReconTimeTo, ReconDone);

  DL_SaveDataForReport_XML( CurrHistID, LIMITQ_PROTOCOL, ProtocolData, LOG_TYPE_DATA);
END;

private macro GetParm(s, parm, def)
   parm = StrUpr(parm);
   s = StrSubst(StrUpr(s)," ","");
   var pos = index(s,parm);
   var retval = "";
   if ( pos > 0 )
      pos = pos + StrLen(parm) + 1; //смещаемся на длинну самого параметра и " = "
      retval =  SubStr(s,pos, index(s,";",pos) - pos);
   end;
   if ((ValType(def) != V_UNDEF) and (retval == ""))
      RetVal = def;
   end;
   return StrSubst(RetVal,",",".");
end;

PRIVATE MACRO loadDataSecur(CalcDate, err:@string,folder, QuikReload:@integer)
   var FIRM_ID = "";
   var TAG = "";
   var CURR_CODE = "";
   var CLIENT_CODE = "";
   var LIMIT_KIND = "";
   var OPEN_BALANCE = "";
   var OPEN_LIMIT = "";
   var LEVERAGE = "";
   var SECCODE = "";
   var TRDACCID = "";
   var CURRENT_LIMIT = "";
   var WA_POSITION_PRICE = "";
   file Quik () txt;
   err = "";

   var dd,mm,yyyy;
   yyyy = SubStr(StrSubst(string(CalcDate:f),".",""),5,4);
   mm   = SubStr(StrSubst(string(CalcDate:f),".",""),3,2);
   dd   = SubStr(StrSubst(string(CalcDate:f),".",""),1,2);

   var mask = "Limit_"+string(DD)+string(MM)+string(YYYY)+"*.lim";
   Var d1 = TDirList (mergeFile (folder , mask), "F");

   if ( d1.count < 1 )
      err = "Нет необходимых данных для сверки в директории " + folder;;
      if(YesNoWin(err + ". Продолжить выполнение сверки?"))
        return 1;
      end;
      return 2;
   end;

   if ( not (open (Quik, mergeFile (folder, d1.name (0)))) )
      err = "Не удалось открыть файл данных";
      msgbox (err);
      RemProgress(1);
      return -1;
   end;

   var count_str = 0;
   while(next(quik))
      count_str = count_str + 1;
   end;
   rewind(Quik);
   QuikReload = count_str;
   InitProgress(count_str,"","Загрузка файла QUIK по фондовому рынку и валютному рынку");
   var count = 0;

   var name, ext;
   name =  mergeFile (folder, d1.name (0));

   setDelIm (strFor (59));
   while ( next (Quik) )
      if (substr(Quik(0), 1, 5) == "MONEY")
         FIRM_ID        = GetParm(Quik.str,"FIRM_ID");
         TAG            = GetParm(Quik.str,"TAG");
         CURR_CODE      = GetParm(Quik.str,"CURR_CODE");
         CLIENT_CODE    = GetParm(Quik.str,"CLIENT_CODE");
         LIMIT_KIND     = GetParm(Quik.str,"LIMIT_KIND","0");
         OPEN_BALANCE   = GetParm(Quik.str,"OPEN_BALANCE", "0") ;
         OPEN_LIMIT     = GetParm(Quik.str,"OPEN_LIMIT", "0");
         LEVERAGE       = GetParm(Quik.str,"LEVERAGE", "0");
         CURRENT_LIMIT  = GetParm(Quik.str,"CURRENT_LIMIT", "0");

         execSql ("insert into DDL_LIMITCASHSTOCKIN_DBT values (:0, :1, :2, :3, TO_NUMBER(:4), TO_NUMBER(:5), TO_NUMBER(:6), TO_NUMBER(:7), TO_NUMBER(:8), 0)",
         makeArray (sqlParam ("0", FIRM_ID), sqlParam ("1", TAG), sqlParam ("2", CURR_CODE), sqlParam ("3", CLIENT_CODE), 
         sqlParam ("4", LIMIT_KIND),   sqlParam ("5", OPEN_BALANCE), sqlParam ("6", OPEN_LIMIT), sqlParam ("7", LEVERAGE), sqlParam ("8", CURRENT_LIMIT)));
      elif (substr(Quik(0), 1, 4) == "DEPO")
         FIRM_ID           = GetParm(Quik.str,"FIRM_ID");
         SECCODE           = GetParm(Quik.str,"SECCODE");
         CLIENT_CODE       = GetParm(Quik.str,"CLIENT_CODE");
         LIMIT_KIND        = GetParm(Quik.str,"LIMIT_KIND", "0");
         OPEN_BALANCE      = GetParm(Quik.str,"OPEN_BALANCE", "0");
         OPEN_LIMIT        = GetParm(Quik.str,"OPEN_LIMIT", "0");
         TRDACCID          = GetParm(Quik.str,"TRDACCID");
         WA_POSITION_PRICE = GetParm(Quik.str,"WA_POSITION_PRICE", "0");
         CURRENT_LIMIT     = GetParm(Quik.str,"CURRENT_LIMIT", "0");

         execSql ("insert into DDL_LIMITSECURITESIN_DBT values  (:0, :1, :2,TO_NUMBER(:3), TO_NUMBER(:4), TO_NUMBER(:5), :6, TO_NUMBER(:7), TO_NUMBER(:8))",
         makeArray (sqlParam ("0", FIRM_ID), sqlParam ("1", SECCODE), sqlParam ("2", CLIENT_CODE), sqlParam ("3", LIMIT_KIND), 
         sqlParam ("4", OPEN_BALANCE),   sqlParam ("5", OPEN_LIMIT), sqlParam ("6", TRDACCID), sqlParam ("7", WA_POSITION_PRICE), sqlParam ("8", CURRENT_LIMIT)));
      end;
      UseProgress(count=count+1);
   end;
   RemProgress();
   close(Quik);

   MakeDir(string(folder+"\\", "Arch"));
   copyfile( mergeFile (folder, d1.name (0)), folder  + "\\arch\\"+d1.name (0) );
   removefile(mergeFile (folder, d1.name (0)));

   return 0;
End;

MACRO ExecLimit( MarketID:INTEGER, 
                 MarketCode:STRING,
                 FlagStockDl:BOOL,
                 FlagDeriv:BOOL,
                 FlagCurr:BOOL,
                 FlagCalc:BOOL,
                 CalcDate:DATE,
                 FlagVerif:BOOL,
                 FlagOverLoad:BOOL,
                 Dir_OverLoad:STRING,
                 FlagLoadIn:BOOL,
                 Dir_StockDl:STRING,
                 Dir_Deriv:STRING,
                 Dir_Curr:STRING,
                 MarketIDSPB:INTEGER, 
                 MarketCodeSPB:STRING,
                 FlagStockDlSPB:BOOL
               )
  var stat = 0;
  var MarketArray = TArray();
  var LoadDone = false;
  var data, QuikReload = 0;

  MarketArray[MarketArray.size] = MarketDataForLimit(MarketID, MarketCode, FlagStockDl, FlagDeriv, FlagCurr);
  if (FlagStockDlSPB)
    MarketArray[MarketArray.size] = MarketDataForLimit(MarketIDSPB, MarketCodeSPB, FlagStockDlSPB, false, false);
  end;

/*
  тут расчет лимитов в зависимости от переданных параметров
*/
  if(FlagCalc)
    var query =   " SELECT 1 "
                + "   FROM daccount_dbt acc, dmcaccdoc_dbt accdoc, dfininstr_dbt curr, ddlcontr_dbt dlc "
                + "  WHERE acc.t_Chapter = 1 "
                + "    AND acc.t_Account LIKE '306%' "
                + "    AND acc.t_Client NOT IN (SELECT d.t_PartyID from ddp_dep_dbt d) "
                + "    AND acc.t_Open_Date < ? "
                + "    AND (acc.t_Close_Date = "+GetSQLDate(date(0,0,0))+" OR acc.t_Close_Date >= ?) "
                + "    AND accdoc.t_Chapter = acc.t_Chapter "
                + "    AND accdoc.t_Account = acc.t_Account "
                + "    AND accdoc.t_Currency = acc.t_Code_Currency "
                + "    AND accdoc.t_ClientContrID > 0 "
                + "    AND dlc.t_SfContrID = accdoc.t_ClientContrID "
                + "    AND curr.t_FIID = acc.t_Code_Currency "
                + "    AND curr.t_FI_Kind = " + FIKIND_CURRENCY
                + "    AND ROWNUM = 1";

    var select = DL_RSDCommand(query);
    select.AddParam(CalcDate);
    select.AddParam(CalcDate);

    if(select.GetCount() > 0)
      if(not YesNoWin("Обнаружены договора брокерского обслуживания, счета по которым не ведутся в разрезе видов обслуживания. Такие счета не будут участвовать в расчете. Продолжить?"))
        return 0;
      end;
    end;
  end;

  for(data, MarketArray)
    var cmd;
    var ErrStr = "", errorCount = 0, i = 0;
    var TimeFrom = Time(), TimeTo = Time();
    var ReconTimeFrom = Time(), ReconTimeTo = Time();
    var Recon;
    var Diverg = 0;
    ProtocolData = TArray();
    
    if(FlagCalc)
      var MarketKinds = "";
      var CalcExistStockDl, CalcExistCurr, CalcExistDeriv;
      CalcExistStockDl = CalcExistCurr = CalcExistDeriv = false;
      if( (data.FlagStockDl == true) AND (ЕстьЛиРасчетыЗаДень(CalcDate, "фондовый", data.MarketCode) > 0))
        MarketKinds = "фондовый";
        CalcExistStockDl = true;
      end;

      if( (data.FlagCurr == true) AND ( ЕстьЛиРасчетыЗаДень(CalcDate, "валютный", data.MarketCode) > 0))
        if(MarketKinds != "")
          MarketKinds = MarketKinds + "/";
        end;
        MarketKinds = MarketKinds + "валютный";
        CalcExistCurr = true;
      end;

      if( (data.FlagDeriv == true) AND (ЕстьЛиРасчетыЗаДень(CalcDate, "срочный", data.MarketCode) > 0))
        if(MarketKinds != "")
          MarketKinds = MarketKinds + "/";
        end;
        MarketKinds = MarketKinds + "срочный";
        CalcExistDeriv = true;
      end;

      if( CalcExistStockDl OR CalcExistCurr OR CalcExistDeriv )
        if(not YesNoWin("В системе уже есть рассчитанные на " + CalcDate + " лимиты по следующим рынкам: " + MarketKinds + ". Новый расчет приведет к их удалению! Продолжить расчет?"))
          if( CalcExistStockDl )
            data.FlagStockDl = false;
          end;
          if( CalcExistCurr )
            data.FlagCurr = false;
          end;
          if( CalcExistDeriv )
            data.FlagDeriv = false;
          end;
        end;
      end;
    end;

    СоздатьСтрокиДляПротокола(data.FlagStockDl, data.FlagDeriv, data.FlagCurr, FlagCalc, IIF((FlagVerif OR FlagOverLoad), true, false));

    if (ДобавитьПервоначальнуюСтрокуВИсторию(LIMITQ_PROTOCOL, data.MarketID, CalcDate) == -1 )
      msgbox("Ошибка при добавлении строки в историю расчета лимитов.");
      return 0;
    end;

    if ((FlagCalc OR FlagOverLoad OR FlagVerif) AND (not LoadDone)) // очистка временных таблиц с загруженными данными quik
      var cmddel= "truncate table DDL_LIMITSECURITESIN_DBT";
      cmddel = RSDCommand(cmddel);
      cmddel.execute; 
      var cmddel2= "truncate table DDL_LIMITCASHSTOCKIN_DBT";
      cmddel2 = RSDCommand(cmddel2);
      cmddel2.execute; 
    end;


    if(FlagOverLoad and (not LoadDone))
      stat = loadDataSecur(CalcDate, @ErrStr, Dir_OverLoad, @QuikReload);
      if(stat == -1)
        ДобавитьОшибкуВПротоколПоРынку(" ", NULL, NULL, ErrStr, NULL);
        FlagVerif = false;
      end;
      if(stat == 1) 
        ДобавитьОшибкуВПротоколПоРынку(" ", NULL, NULL, ErrStr, "Сверка выполнялась без перезагрузки файла с данными");
      end;
      if(stat == 2)
        ДобавитьОшибкуВПротоколПоРынку(" ", NULL, NULL, ErrStr, "Сверка была остановлена пользователем");
        FlagVerif = false;
      end;
      LoadDone = true;
    end;

    if(FlagCalc)
    ////Проверка календарей и настройки
      if( (data.MarketID != NULL) AND ( data.MarketID > 0 )) //для биржевых
        if((data.FlagStockDl == true)  OR (data.FlagCurr == true) OR (data.FlagDeriv == true))
          var MesErr = "";
          var Stock = TBfile("dl_limitprm.dbt", "R", 1);
          var Curr  = TBfile("dl_limitprm.dbt", "R", 1);
          var Deriv  = TBfile("dl_limitprm.dbt", "R", 1);
          var ErrStock = "", ErrCurr = "";
          Stock.Clear();
          Curr.Clear();
          if(data.FlagCurr)  // для валютного
            Curr.rec.MarketID = data.MarketID;
            Curr.rec.MarketKind = ALG_DL_LIMITPRM_MARKETKIND_CURRENCY;
            if(GetEQ(Curr))
                  if((Curr.rec.CalendarId < 0) OR (Curr.rec.CurId < 0) OR (Curr.rec.CurLimitKind < 0))
                      msgbox("Неверно заполнены параметры расчета лимитов QUIK для валютного рынка");
                      if(FlagCalc AND (Curr.rec.CalendarId < 0))
                        ДобавитьОшибкуВПротоколПоРынку("валютный",ERROR_CALENDAR, NULL);
                        FlagCurr = false;
                      end;
                  else
                      ErrCurr =  ПроверитьВалютыИКаледари(Curr.rec.CurLimitKind, Curr.rec.CurID);
                  end;
            else
              ДобавитьОшибкуВПротоколПоРынку("валютный",ERROR_SETT_NOTFOUND, NULL);
              FlagCurr = false;
            end;
          end;
          
          if(data.FlagStockDl)  // для фондового
            Stock.rec.MarketID = data.MarketID;
            Stock.rec.MarketKind = ALG_DL_LIMITPRM_MARKETKIND_STOCK;
            if(GetEQ(Stock))
                if((Stock.rec.CalendarId < 0) OR (Stock.rec.CurId < 0) OR (Stock.rec.CurLimitKind < 0))
                  msgbox("Неверно заполнены параметры расчета лимитов QUIK для фондового рынка");
                  if(FlagCalc AND (Stock.rec.CalendarId < 0))
                      ДобавитьОшибкуВПротоколПоРынку("фондовый",ERROR_CALENDAR, NULL);
                      FlagStockDl = false;
                  end;
                else
                  ErrStock =  ПроверитьВалютыИКаледари(Stock.rec.CurLimitKind, Stock.rec.CurID);
                end;
            else
              ДобавитьОшибкуВПротоколПоРынку("фондовый",ERROR_SETT_NOTFOUND, NULL);
              FlagStockDl = false;
            end;
          end;
          if(data.FlagDeriv)  // для срочного
            Deriv.rec.MarketID = data.MarketID;
            Deriv.rec.MarketKind = ALG_DL_LIMITPRM_MARKETKIND_DERIV;
            if(not GetEQ(Deriv))
              ДобавитьОшибкуВПротоколПоРынку("срочный",ERROR_SETT_NOTFOUND, NULL);
              FlagDeriv = false;
            end;
          end;
          if(ErrStock != "")
            data.FlagStockDl = false;
            if(FlagCalc)
              ДобавитьОшибкуВПротоколПоРынку("фондовый",ERROR_CURRENCY, ErrStock);
            end;
          end;
          if(ErrCurr != "")
            data.FlagCurr = false;
            if(FlagCalc)
              ДобавитьОшибкуВПротоколПоРынку("валютный",ERROR_CURRENCY, ErrCurr);
            end;
          end;
          if((ErrStock != "") OR (ErrCurr != ""))
            MesErr = "Не заданы календари для полноценного расчета лимитов по рынкам:";
            if(ErrCurr != "")
              MesErr = MesErr + "валютный";
            end;
            if(ErrStock != "")
                if(ErrCurr != "")
                  MesErr = MesErr + ", ";
                end;
                MesErr = MesErr + "фондовый";
            end;
            MesErr = MesErr + ". Расчет лимитов по указанным рынкам не произведен!";
          end;
      
          if( (data.FlagDeriv == false) AND (data.FlagStockDl == false)  AND ( data.FlagCurr == false  ) )   //не можем посчитать
            msgbox(MesErr);
            if(FlagCalc)
                ЗавершитьФормированиеПротокола(data.FlagCalc, data.FlagStockDl, data.FlagDeriv, data.FlagCurr, CalcDate, data.MarketCode, TimeFrom, TimeTo, "");
                PrintQUIKProtocolByXMLToSTD(CurrHistID);
            end;
            return 0;
          elif( ( (data.FlagDeriv == true) OR (data.FlagStockDl == true) OR (data.FlagCurr == true)) AND ((ErrStock != "") OR (ErrCurr != "")))
            MesErr = MesErr + "Продолжить расчет для остальных рынков?";
            if(not YesNoWin(MesErr))
              if(FlagCalc)
                  ДобавитьОшибкуВПротоколПоРынку("срочный", NULL, NULL);
                  ЗавершитьФормированиеПротокола(data.FlagCalc, data.FlagStockDl, data.FlagDeriv, data.FlagCurr, CalcDate, data.MarketCode, TimeFrom, TimeTo, "");
                  PrintQUIKProtocolByXMLToSTD(CurrHistID);
              end;
              return 0;
            end;
          end;
          if( (data.FlagCurr == true) OR (data.FlagStockDl == true))
            ЗаполнитьДатыВалюты( data.FlagCurr, Curr, data.FlagStockDl, Stock, CalcDate );
          end;
        end;
      end;
      TimeFrom = Time();
      cmd = RsdCommand("{CALL RSI_SCLIMIT.RSI_CreateLimits(?, ?, ?, ?, ?, ?) }");

      cmd.addParam("p_MarketID",         RSDBP_IN, data.MarketID );
      cmd.addParam("p_MarketCode",       RSDBP_IN, data.MarketCode );
      cmd.addParam("p_CalcDate",         RSDBP_IN, CalcDate );
      cmd.addParam("p_ByStock",          RSDBP_IN, IIF(data.FlagStockDl == true, 1, 0) );
      cmd.addParam("p_ByCurr",           RSDBP_IN, IIF(data.FlagCurr == true, 1, 0) );
      cmd.addParam("p_ByDeriv",          RSDBP_IN, IIF(data.FlagDeriv == true, 1, 0) );

      RslDefCon.BeginTrans();

      InitProgress(-1, "Выполняется утренний расчет лимитов", "Утренний расчет лимитов");
      
      cmd.execute();
      
      RemProgress();

      RslDefCon.CommitTrans();
      TimeTo = Time();
      msgbox("Расчет выполнен успешно для биржи: " + data.MarketCode);
    end;

    if( FlagVerif and (not(data.FlagDeriv AND (not data.FlagCurr) AND (not data.FlagStockDl))) )
      ReconTimeFrom = Time();
      Recon = QUIK_Recon(data.MarketID, data.MarketCode, CalcDate, data.FlagStockDl, data.FlagCurr);
      Recon.Run();
      ReconTimeTo = Time();
      Diverg = Recon.КоличествоРасхождений();
    end;

    ЗавершитьФормированиеПротокола(FlagCalc, data.FlagStockDl, data.FlagDeriv, data.FlagCurr, CalcDate, data.MarketCode, TimeFrom, TimeTo, "", FlagOverLoad, FlagVerif, QuikReload, Diverg, ReconTimeFrom, ReconTimeTo);
    PrintQUIKProtocolByXMLToSTD(CurrHistID);
  end;
  return stat;

OnError(er)
  
  RemProgress();

  if(RslDefCon.IsInTrans)
    RslDefCon.RollbackTrans();                    
  end;

  if (IsEqClass ("TrslError", er))
    ErrStr=er.Message;
    if(IsEqClass ("TDbError", er.err))
      ErrStr=ErrStr+":|"+er.err.Stat+"-"+er.err.Oper+"-"+er.err.Table+"-"+er.err.Message;
    elif (isEqClass("TRsdError", er.err))

      errorCount = er.err.environment.ErrorCount;
      while (i < errorCount)
          ErrStr=ErrStr+er.err.environment.Error(i).Descr;
          i = i + 1;
      end;
    end;
  end;

  if(ErrStr == "")
    ErrStr=er.module+ " "+er.line+" "+er.message;
  end;
  msgbox(ErrStr);
  if(FlagCalc)
    TimeTo = Time();
    ЗавершитьФормированиеПротокола(FlagCalc, FlagStockDl, FlagDeriv, FlagCurr, CalcDate, MarketCode, TimeFrom, TimeTo, ErrStr);
    PrintQUIKProtocolByXMLToSTD(CurrHistID);
  end;
  return 1;
END;
