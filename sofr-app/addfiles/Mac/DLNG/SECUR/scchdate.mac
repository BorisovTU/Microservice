/*
$Name:        scchdate.mac
$Module:      Ценные бумаги
$Description: Шаг изменения сроков исполнения
*/
import InsCarryDoc, FIInter, PTInter, "sp_class.mac", "sp_car.mac", "sp_car2.mac";

private record   SpChangeDates("spchdate.str");/*глобальная структура с данными по изменению сроков*/
private record   SpChangeDlLeg("dl_leg.dbt");  /*глобальная структура с условиями первой части сделок*/
private record   SpChangeDlLegBack("dl_leg.dbt");  /*глобальная структура с условиями второй части сделок*/

private var CalcWrtTime;

private record tick (dl_tick);
private record AccBuf(account);

private var ChangeDates = TArray();
private class ChDate( _KindDate:Integer, _StepDate:Date, _UpdateOnlyStepDate:Bool )
   var KindDate = _KindDate,
       StepDate = _StepDate,
       UpdateOnlyStepDate = _UpdateOnlyStepDate;
end;

/*виды зависимостей дат ТО*/
private const SP_ALG_FROMDATE_UNDEF  = 0, /*не зависит*/
              SP_ALG_FROMDATE_PAY    = 1, /*от оплаты*/
              SP_ALG_FROMDATE_STATE  = 2, /*от поставки */
              SP_ALG_FROMDATE_AVANCE = 3; /*от аванса*/

Private Macro GetNewCOmSumm(FD, RqM, RqCom)
Var NewSum = 0, NewSumRq = 0, OldSum = 0, stavka1 = 0.1, stavka2 = 0.2, stavka = $0, stavka3 = 0.15; /*CHVA 518805*/
/*CHVA 519884*/
var query, dataset, select, comName;

query ="SELECT UPPER(t_code) as code FROM dsfcomiss_dbt"+
               " WHERE t_number = (SELECT t_comnumber FROM ddlcomis_dbt"+
               "                                            WHERE  t_docid = "+ FD.tick.rec.dealid +" )"+
               " AND t_feetype = 1";
 select = DL_RSDCommand(Query);
 select.AddParam(FD.tick.rec.DealID);
  DataSet = select.execute();
  if( DataSet.moveNext() )
      comName= substr(DataSet.code,1,index(DataSet.code,"_")-1);
  end;
/*CHVA 519884*/
 var sel, rs, cmd;
 sel  = " select UPPER(pl.t_name) as tarif from dsfplan_dbt pl, dsfconcom_dbt con "+
        "  where pl.t_sfplanid = con.t_sfplanid "+
        "  and con.t_dateend = to_date('01.01.0001','dd.mm.yyyy') "+/*CHVA отсеиваем комиссии которые были закрыты при смене тарифа по договору, если такая смена была*/
        "  and con.t_objectid = ?";
    cmd = RSDCommand( sel );
    cmd.addParam( "", RSDBP_IN, FD.tick.rec.clientcontrid );
    cmd.execute();
    rs = TRsbDataSet( cmd );
     if( rs.MoveNext() )
      if( rs.tarif == "БАЗОВЫЙ" )
        if(comName == "НЕБИРЖБЕЗНОТ")/*CHVA 519884*/
          stavka = stavka3;
       else
       stavka = stavka1;
       end;
      elif(rs.tarif == "ПРОФЕССИОНАЛЬНЫЙ")  /*CHVA 518805*/
       stavka = stavka3;
      elif(rs.tarif == "ПРОФЕССИОНАЛЬНЫЙ_РЕПОБАЗОВЫЙ")  /*CHVA 519884  проверка на тариф профессиональный_репобазовый - если сделка репо , то берется 0,1% как при базовом тарифе, если не репо , то 0,15% как при профессиональном*/
          if(isRepo(FD.tick.rec.dealid))
             stavka = stavka1;
          else
            stavka = stavka3;
          end;
      else
       stavka = stavka2;
      end;
     end;

   OldSum = RqCom.rec.amount;


   NewSumRq = round(FD.dl_leg.rec.cost /*RqM.rec.amount*/ * stavka /100,2); /*CHVA 518805 комиссия должна браться от тела без НКД*/

   If(NewSumRq != OldSum)
      NewSum = round(FD.dl_leg.rec.cost * stavka /100,2);
   else
      NewSum = OldSum;
   end;

   return NewSum;


end;

Private Macro UpdateCOmiss(rq, fdate)
/*GAA: 519245 Установим плановую дату строки "Оплата комиссий" равной новой дате оплаты (на случай если исполнение отложенной поставки выполняется ранее исполнения отложеного аванса/оплаты*/
      var  sql1 = RSDCommand(" select t_plandate from ddlgrdeal_dbt where t_docid = ? and t_templnum = 9 " );
 
      sql1.addParam("", RSDBP_IN, rq.rec.docid);
      sql1.execute();
      var rs1 = TRsbDataSet( sql1);
      if( rs1.MoveNext() )
        var pdate = date (rs1.plandate);
        if  (pdate != fdate)
           var  sql2 = RSDCommand(" update ddlgrdeal_dbt set t_plandate = ? where t_docid = ? and t_templnum = 9 " );
           sql2.addParam("", RSDBP_IN, fdate);
           sql2.addParam("", RSDBP_IN, rq.rec.docid);
           sql2.execute();
        end;
      end;/*GAA*/

      var sql = RSDCommand(" update  ddlcomis_dbt " +
                           "     set t_factpaydate = ?, t_planpaydate = ?, t_sum = ? " +
                           "  where t_docid = ? and t_comnumber >1000 " );
 
      sql.addParam("", RSDBP_IN, fdate);
      sql.addParam("", RSDBP_IN, fdate);
      sql.addParam("", RSDBP_IN, rq.rec.amount);
      sql.addParam("", RSDBP_IN, rq.rec.docid);

      sql.execute();


/**/
/*GAA:518770      sql = RSDCommand(" delete ddlgrdeal_dbt where t_docid = ? and t_templnum = 9 and t_plandate = ? " );
 
      sql.addParam("", RSDBP_IN, rq.rec.docid);
      sql.addParam("", RSDBP_IN, fdate);

      sql.execute();*/

End;
private macro ReplanStepPlanDates( KindDate:Integer, StepDate:Date, UpdateOnlyStepDate:Bool )
   var i = 0;
   while( i < ChangeDates.Size )
      if( ChangeDates[i].KindDate == KindDate )
         ChangeDates[i].StepDate = StepDate; 
         if( UpdateOnlyStepDate != true )
            ChangeDates[i].UpdateOnlyStepDate = UpdateOnlyStepDate;
         end;
         return;
      end;
      i = i + 1;
   end;
   ChangeDates[ChangeDates.Size] = ChDate( KindDate, StepDate, UpdateOnlyStepDate );
end;

private macro GetRqLinkData( FD:SPFirstDoc, DlRq:Object, LinkType:@Integer, LinkDiff:@Integer)

   macro GetLinkType( Base:Integer )
      if( Base == SP_ALG_FROMDATE_PAY )
         return FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.Type;
      elif( Base == SP_ALG_FROMDATE_STATE )
         return FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.Type;
      elif( Base == SP_ALG_FROMDATE_AVANCE )
         return FD.GetRQ(DLRQ_TYPE_AVANCE).rec.Type;
      end;
      return DLRQ_TYPE_UNKNOWN;
   end;

   if(DlRq.rec.Type == DLRQ_TYPE_DELIVERY)
      LinkType = GetLinkType( FD.dl_leg.rec.PrincipalBase );
      LinkDiff = FD.dl_leg.rec.PrincipalDiff;
   elif(DlRq.rec.Type == DLRQ_TYPE_AVANCE)
      LinkType = GetLinkType( FD.dl_leg.rec.StartBase );
      LinkDiff = FD.dl_leg.rec.StartDiff;
   elif(DlRq.rec.Type == DLRQ_TYPE_PAYMENT)
      LinkType = GetLinkType( FD.dl_leg.rec.Base );
      LinkDiff = FD.dl_leg.rec.Diff;
   else
      LinkType = DLRQ_TYPE_UNKNOWN;
      LinkDiff = 0;
   end;
end;

private macro SetRqDate( FD:SPFirstDoc, DlRq:Object, NewPlanDate:Date, BaseDate:Date, UpdateOnlyStepDate:bool )
   var KindDate, KindDateName, StepDate;
   /*Нулевую дату в ТО не заносим, а только меняем даты шагов*/
   if( (NewPlanDate != Date(0,0,0)) AND (BaseDate != Date(0,0,0)) )
      DlRq.rec.PlanDate     = NewPlanDate;
      StepDate              = NewPlanDate;
   else
      StepDate = Date(0,0,0);
   end;

   if(DlRq.rec.Type == DLRQ_TYPE_DELIVERY)
      KindDate     = DATE_DEALSETAVOIRISS;
      KindDateName = "поставки";
   elif(DlRq.rec.Type == DLRQ_TYPE_AVANCE)
      KindDate     = DATE_DEALAVANCE;
      KindDateName = "аванса";
   elif(DlRq.rec.Type == DLRQ_TYPE_PAYMENT)
      KindDate     = DATE_DEALPAY;
      KindDateName = "оплаты";
   elif(DlRq.rec.Type == DLRQ_TYPE_INCREPO)
      KindDate     = DATE_DEALPAY;
      KindDateName = "оплаты";
   elif(DlRq.rec.Type == 6)
      KindDate     = DATE_DEALCOMISS;
      KindDateName = "оплаты комиссии";
   end;

   FD.DateArray[KindDate] = NewPlanDate;
   ReplanStepPlanDates( FD.GetKindDate(KindDate), StepDate, UpdateOnlyStepDate );
   return true;
end;

/*Обновить ТО и даты операции с учетом зависимостей ТО друг от друга*/
private macro UpdateRQ( FD:SPFirstDoc, DlRq:Object, NewState:Integer, NewPlanDate:Date, UpdateOnlyStepDate:bool )
   /*ТО, зависимые от DlRq*/
   var DlRqB, LinkTypeB = DLRQ_TYPE_UNKNOWN, LinkDiffB = 0, DateKindB:integer = -1,
       DlRqC, DlRqCom, LinkTypeC = DLRQ_TYPE_UNKNOWN, LinkDiffC = 0, DateKindC:integer = -1, DateKindCom:integer = -1;

   if( (NewState > DLRQ_STATE_UNKNOWN) AND (NewState != DlRq.rec.State) )
      DlRq.rec.State = NewState;
   end;

   if( (NewPlanDate != null) AND (NewPlanDate != DlRq.rec.PlanDate) )
      
      if( not SetRqDate( FD, DlRq, NewPlanDate, NewPlanDate, UpdateOnlyStepDate ) )
         return false;
      end;

      /*Обновить все зависимые даты*/
      DlRqB = TRecHandler("dlrq"); /*ТО, зависимые от DlRq*/
      DlRqC = TRecHandler("dlrq");
      DlRqCom = TRecHandler("dlrq");

      if(DlRq.rec.Type == DLRQ_TYPE_DELIVERY)
         DlRqB.Clear();
         DateKindB = -1;
         if(FD.ExistAvance())
            DlRqB = FD.GetRQ(DLRQ_TYPE_AVANCE);
            DateKindB = IIF(FD.IsBack == true, DLGR_DATEKIND_AVANCE2, DLGR_DATEKIND_AVANCE);
         end;
         DlRqC = FD.GetRQ(DLRQ_TYPE_PAYMENT);
         DateKindC = IIF(FD.IsBack == true, DLGR_DATEKIND_PAYMENT2, DLGR_DATEKIND_PAYMENT);
      elif(DlRq.rec.Type == DLRQ_TYPE_AVANCE)
         DlRqB = FD.GetRQ(DLRQ_TYPE_DELIVERY);
         DateKindB = IIF(FD.IsBack == true, DLGR_DATEKIND_DELIVERY2, DLGR_DATEKIND_DELIVERY);
         DlRqC = FD.GetRQ(DLRQ_TYPE_PAYMENT);
         DateKindC = IIF(FD.IsBack == true, DLGR_DATEKIND_PAYMENT2, DLGR_DATEKIND_PAYMENT);
      elif(DlRq.rec.Type == DLRQ_TYPE_PAYMENT)
         DlRqB = FD.GetRQ(DLRQ_TYPE_DELIVERY);
         DateKindB = IIF(FD.IsBack == true, DLGR_DATEKIND_DELIVERY2, DLGR_DATEKIND_DELIVERY);
         DlRqC.Clear();
         DateKindC = -1;
      elif(DlRq.rec.Type == 6) /*КД*/
            DlRqCom = FD.GetRQ(6);
            DateKindCom = DLGR_DATEKIND_COMISS;
      end;
/*DL_ChangeDLRQ*/
      if(DlRq.rec.Type == 6) /*КД*/
         if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKindCom, NewPlanDate/*DlRqCom.rec.PlanDate*//*date("31.12.9999")*/) != 0 )
            return 1;
         end;
         if( not SetRqDate( FD, DlRqCom, DlRqCom.rec.PlanDate, NewPlanDate, UpdateOnlyStepDate) )
            return false;
         end;
      end;

      GetRqLinkData( FD, DlRqB, @LinkTypeB, @LinkDiffB );
      GetRqLinkData( FD, DlRqC, @LinkTypeC, @LinkDiffC );

      /* Проверить, что B зависит от А(это Dlrq) и не исполнен*/
      if( (LinkTypeB == DlRq.rec.Type) AND (not ТОЗакрыто(DlRqB)) )
         /*Если зависит, вычислить новую дату B*/
         if( not SetRqDate( FD, DlRqB, DlRq.rec.PlanDate + LinkDiffB, NewPlanDate, UpdateOnlyStepDate) )
            return false;
         end;

         if( DateKindB != -1 )
            if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKindB, DlRq.rec.PlanDate + LinkDiffB) != 0 )
               return 1;
            end;
         end;

         /*проверить, зависит ли C от B. Если зависит и не исполнен, вычислить новую дату C через дату B*/
         if( (LinkTypeC == DlRqB.rec.Type) AND (not ТОЗакрыто(DlRqC)) )
            if( not SetRqDate( FD, DlRqC, DlRqB.rec.PlanDate + LinkDiffC, NewPlanDate, UpdateOnlyStepDate ) )
               return false;
            end;

            if( DateKindC != -1 )
               if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKindC, DlRqB.rec.PlanDate + LinkDiffC) != 0 )
                  return 1;
               end;
            end;
         end;
      end;
      /*проверить, что C зависит от А и не исполнен*/
      if( (LinkTypeC == DlRq.rec.Type) AND (not ТОЗакрыто(DlRqC)) )
         /*Если зависит, вычислить новую дату C*/
         if( not SetRqDate( FD, DlRqC, DlRq.rec.PlanDate + LinkDiffC, NewPlanDate, UpdateOnlyStepDate ) )
            return false;
         end;

         if( DateKindC != -1 )
            if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKindC, DlRq.rec.PlanDate + LinkDiffC) != 0 )
               return 1;
            end;
         end;

         /*Проверить, зависит ли B от C. Если зависит и не исполнен, вычислить 
           новую дату B через дату C*/
         if( (LinkTypeB == DlRqC.rec.Type) AND (not ТОЗакрыто(DlRqB)) )
            if( not SetRqDate( FD, DlRqB, DlRqC.rec.PlanDate + LinkDiffB, NewPlanDate, UpdateOnlyStepDate ) )
               return false;
            end;

            if( DateKindB != -1 )
               if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKindB, DlRqC.rec.PlanDate + LinkDiffB) != 0 )
                  return 1;
               end;
            end;
         end;
      end;
   end;

   return true;
end;

/*переинициализировать дату завершения сделки*/
PRIVATE MACRO RePlanCloseDate( FD:SPFirstDoc )
   FD.DateArray[DATE_DEALEEND] = maxDate( maxDate(FD.DateArray[DATE_DEALPAY], FD.DateArray[DATE_DEALSETAVOIRISS]), FD.DateArray[DATE_DEALCOMISS]);

   ReplanStepPlanDates( FD.GetKindDate(DATE_DEALEEND), FD.DateArray[DATE_DEALEEND] );

   return true;
END;

/*переопределение даты начала исполнения*/
PRIVATE MACRO ReDefineDatesBeginExec( FD:SPFirstDoc )
   /*переопределим DATE_DEALRATEPAY*/
   FD.ОпределитьДатуКурсаОплаты();

   /*дата начала расчетов*/
   if( FD.ExistAvance )
      FD.DateArray[DATE_DEALBEGINSETTLE] = FD.DateArray[DATE_DEALAVANCE];
   else                                   
      FD.DateArray[DATE_DEALBEGINSETTLE] = FD.DateArray[DATE_DEALPAY];
   end;

   if( FD.dl_leg.rec.OperState < DL_LEG_BALANCE )
      /*теперь переопределим дату начала исполнения (может называться еще и датой учета)  */
      if( FD.DateArray[DATE_DEALSETAVOIRISS] != Date(0,0,0) )
         if( FD.БылоОтложенноеИсполнение() != true )
            FD.DateArray[DATE_DEALBEGINEXEC] = minDate( FD.DateArray[DATE_DEALBEGINSETTLE], FD.DateArray[DATE_DEALSETAVOIRISS] );
         else
            FD.DateArray[DATE_DEALBEGINEXEC] = FD.DateArray[DATE_DEALSETAVOIRISS];
         end;
      else
         FD.DateArray[DATE_DEALBEGINEXEC] = FD.DateArray[DATE_DEALBEGINSETTLE];
      end;
      ReplanStepPlanDates( FD.GetKindDate( DATE_DEALEXEC ), FD.DateArray[DATE_DEALBEGINEXEC] );
      ReplanStepPlanDates( FD.GetKindDate( DATE_DEALBEGINEXEC ), FD.DateArray[DATE_DEALBEGINEXEC] );
   end;

   return true;
END;

/*переопределения для досрочного исполнения*/
PRIVATE MACRO ReDefineForBefore( FD:SPFirstDoc, ID_Op:Integer, DlRq:Object, new_date:Date, RePlanClose:bool )

  if( not UpdateRq(FD, DlRq, DLRQ_STATE_PLAN, new_date) )
     return false;
  end;

  if( FD.tick.rec.BofficeKind != DL_RETIREMENT )
     if( FD.dl_leg.rec.OperState == DL_LEG_OUTBAL )
        /*есть запланированный шаг - 116 - системный вид шага "перенос по срокам"*/
        if( SP_IsExistOprStep( ID_Op, 116 ) )
           ReplanStepPlanDates( FD.GetKindDate( DATE_DEALTRANSFER ), new_date );
           FD.DateArray[DATE_DEALTRANSFER] = new_date;
        end;
     end;

     if( ReDefineDatesBeginExec( FD ) == false )
        return false;
     end;
  end;

  if( RePlanClose )
     if( RePlanCloseDate( FD ) == false )
        return false;
     end;
  end;

  /*исполнение не в срок*/
  if( not ОбновитьФлагиЧастиСделки( FD.dl_leg, DL_LEG_EARLY_EXECUTE ) )
     msgbox("Ошибка при обновлении признака \"Исполнение не в срок\" части сделки."); 
     return false;
  end; 
  
  return true;   
END;

/*переопределения для просрочки*/
PRIVATE MACRO ReDefineForOverdue( FD:SPFirstDoc, DlRq:Object, UpdateAccount:bool )

   if( not UpdateRQ( FD, DlRq, DLRQ_STATE_OVERDUE, Date(0,0,0), true ) )
      return false;
   end;

   return true;
END;

/*переопределения для снятия с просрочки*/
PRIVATE MACRO ReDefineForRemoveOverdue( FD:SPFirstDoc, DlRq:Object, new_date:Date, RePlanClose:bool )

   if( not UpdateRQ( FD, DlRq, DLRQ_STATE_PLAN, new_date ) )
      return false;
   end;

   if( ReDefineDatesBeginExec( FD ) == false )
      return false;
   end;

   if( RePlanClose )
      if( RePlanCloseDate( FD ) == false )
         return false;
      end;
   end;

   return true;
END;


private macro ПолучитьМинимальнуюДатуТО( FD )

   var MinDate = FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate;

   if( (FD.ExistAvance == true)
       AND (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate != Date(0,0,0)) )
      MinDate = min( MinDate, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate );                  
   elif( ((FD.ExistAvance == true) OR (FD.ExistDeposit == true))
       AND (FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate != Date(0,0,0)) )
      MinDate = min( MinDate, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate );                  
   end;

   return MinDate;
end;

/*Переинициализировать даты для второй части, зависящие от дат первой*/
macro ПереинициализироватьДатыВторойЧасти( FD:SPFirstDoc, FD_another:SPFirstDoc, CheckMinDate2:bool )
   var OutBalDate, CheckDate, FD_2, FD_1;

   if( FD.IsBack == false ) 
      if( FD_another == null )
         FD_2 = SPFirstDoc( FD.tick, true, true );
      else
         FD_2 = FD_another;
      end;
      FD_1 = FD;
   else 
      if( FD_another == null )
         FD_1 = SPFirstDoc( FD.tick, false, true );
      else
         FD_1 = FD_another;
      end;
      FD_2 = FD;
   end;

   /*не было отказа от исполнения 2й части*/
   if( FD_2.БылОтказОтИсполнения() == false ) 

      if( FD_2.IsExistWrtSum == false ) /*2я часть не начата*/
         FD_2.DateArray[DATE_DEALBEGIN_2] = ДатаНачалаВторойЧасти( FD_1, FD_2 );
         FD_1.DateArray[DATE_DEALBEGIN_2] = FD_2.DateArray[DATE_DEALBEGIN_2];
         ReplanStepPlanDates( FD_2.GetKindDate(DATE_DEALBEGIN_2), FD_2.DateArray[DATE_DEALBEGIN_2] );
      else
         if( CheckMinDate2 == true )
            CheckDate = ПолучитьМинимальнуюДатуТО( FD_2 );
         else
            CheckDate = FD_2.DateArray[DATE_DEALBEGIN_2];
         end;

         if( FD_1.DateArray[DATE_DEALSETAVOIRISS] < CheckDate )
            msgbox(  "Нарушен порядок выполнения шагов операции:| " + 
                     "выполнение 2 части начато датой, более поздней, чем дата поставки по 1 ч.|" + 
                     "Для корректного планирования 2 части необходимо | откатить выполненные шаги по ней.");         
            return false;
         end;
         /*Если вторая часть не поставлена на внебаланс*/
         if( FD_2.dl_leg.rec.OperState != DL_LEG_OUTBAL )         
            GetOprDate( FD_2.GetKindDate(DATE_DEALOUTBAL_2), OutBalDate );
            if( OutBalDate != Date(0,0,0) )
               FD_2.DateArray[DATE_DEALOUTBAL_2] = ДатаПостановкиНаВнебалансВторойЧасти( FD_1, FD_2 );
               FD_1.DateArray[DATE_DEALOUTBAL_2] = FD_2.DateArray[DATE_DEALOUTBAL_2];
               ReplanStepPlanDates( FD_2.GetKindDate(DATE_DEALOUTBAL_2), FD_2.DateArray[DATE_DEALOUTBAL_2] );
            end;
         end;
      end;
   end;
   return true;
end;

private macro SayLotError( State1, State2 )
   var err = "Статус части сделки не подходит для заданного изменения сроков.";
  /* if( (State2 != null) AND (State1 != State2) )
      err = err + "|Лот должен иметь статус от \"" + GetNameAlg( 3118, State1) + 
                 "\" до \"" + GetNameAlg( 3118, State2) + "\" вкл.";
   else
      err = err + "|Лот должен иметь статус \"" + GetNameAlg( 3118, State1) + "\""; 
   end;*/
   MsgBox( err );
end;
/*
private macro ПроверитьЛот( FD, State1_1, State1_2, State2_1, State2_2 )
   /*если на лоте установлен признак "Отложенное исполнение"*/
   if( FD.БылоОтложенноеИсполнение() )
      if( (FD.dl_leg.rec.OperState != DL_LEG_OUTBAL) AND   /*На внебалансе*/
          (FD.dl_leg.rec.OperState != DL_LEG_BALANCE) AND  /*На балансе*/
          (FD.dl_leg.rec.OperState != DL_LEG_FORM )       /*Поставлен*/
        )
         SayLotError( DL_LEG_OUTBAL );
         return false;
      end;
   else
      /*если на лоте НЕ установлен признак "исполнение не в срок"*/
      if( not FD.БылоДосрочноеИсполнение() )
         if( (FD.dl_leg.rec.OperState < State1_1) OR (FD.dl_leg.rec.OperState > State1_2) )
            SayLotError( State1_1, State1_2 );
            return false;
         end;
      else /*если признак "исполнение не в срок" установлен */
         if( (FD.dl_leg.rec.OperState < State2_1) OR (FD.dl_leg.rec.OperState > State2_2) )
            SayLotError( State2_1, State2_2 );
            return false;
         end;
      end;
   end;
   return true;
end;
*/
private macro ИзменитьСрокиИсполнения_ДляПогашения( FD:SPFirstDoc, Action:Integer, doc:Variant, ID_Op:Integer, FactDate:Date )
  if( Action == DEALCALC_ACTION_BEFORE_PAY ) /*досрочная оплата*/
     if( ReDefineForBefore( FD, ID_Op, FD.GetRQ(DLRQ_TYPE_PAYMENT), FactDate, true ) == false )
        return 1;
     end;
  elif( Action == DEALCALC_ACTION_BEFORE_SET ) /*досрочная поставка*/
     if( ReDefineForBefore( FD, ID_Op, FD.GetRQ(DLRQ_TYPE_DELIVERY), FactDate, true  ) == false )
        return 1;
     end;
     if( not ОбновитьЛот( FD.pmwrtsum, PM_WRTSUM_UPDTMODE_CHANGEDATE, FactDate, FD ) )
        msgbox("Ошибка при обновлении даты поставки в лоте"); 
        return 1;
     end; 
  else
     msgbox( "Неопределен вид действия операции расчетов по погашению."); 
     return 1;
  end;
  return 0;
end;

private macro ИзменитьСрокиИсполнения_ДляСделки( FD:SPFirstDoc, Action:Integer, doc:Variant, ID_Op:Integer, FactDate:Date, PlanDate:Date, ExecDate:Date )
  var DealType, Ground;
  var DebetAcc, CreditAcc, ChdAcc, FIRole, ForvAcc, ForvAccMinus, ForvAccPlus;
  var ExistLink = false, NeedInsertDepoDraft = false, err, stat, RegistrDate;
  var Sum, N = 0, MinDate = date(0,0,0);

  var FD1, FD2, save_BegDateM = null, save_FinDateM = null, save_BegDateP = null, save_FinDateP = null;
  var MnOD = TRecHandler("account");
  var PlOD = TRecHandler("account");
  var MnOD_2 = TRecHandler("account");
  var PlOD_2 = TRecHandler("account");
  var UpdateAcc = true, i = 0;
  var DateKind = 0;
  var ArrFIID, j:integer = 0;
  var ИспДругиеТО = false;
  var GrDate:date = date(31,12,9999);
  var NumInList = "";
  Var NewCommSum = 0, OldCommSum =0;
      Var DlRqCom; 
      DlRqCom = TRecHandler("dlrq");


  macro ДосрочнаяОплата():integer

     if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate <= FactDate )
        MsgBox("Запрещено выполнение операции. Плановая дата ТО по оплате должна быть больше даты досрочной оплаты.");
        return 1;
     end;

     if( (ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY)) != true) AND
         (FD.DateArray[DATE_DEALSETAVOIRISS_PLAN] == FactDate)
       )
        if( MsgBoxEx( "Плановая дата поставки равна дате досрочной оплаты.|Выполнять досрочную оплату ?",
            MB_YES+MB_NO, IND_NO, 
            "Досрочная оплата", "Подтверждение начала операции" ) != IND_YES ) 
           return 1;
        end;
     end;

     if( ReDefineForBefore(FD, ID_Op, FD.GetRQ(DLRQ_TYPE_PAYMENT), FactDate, true) == false )
        return 1;
     end;

     if( (FD.ExistBack == true) AND (FD.IsBack == true) ) /*по второй части*/
        if( not ПереинициализироватьДатыВторойЧасти(FD) )
           return 1;
        end;
     end;

     if(FD.IsBack == true)
        DateKind = DLGR_DATEKIND_PAYMENT2;
     else
        DateKind = DLGR_DATEKIND_PAYMENT;
     end;

     if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
        return 1;
     end;

     if( (not IsREPO(FD.Group)) AND (FD.dl_leg.rec.OperState <= DL_LEG_OUTBAL) ) //только если сделка была на внебалансе
        if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, FactDate) != 0 )
           return 1;
        end;
     end;

     if( not IsREPO(FD.Group) )
        if( SetTransferGrDeal(FD, FactDate, FD.tick.rec.PFI) != 0 )
           return 1;
        end;
     end;

     return 0;
  end;

  macro ДосрочнаяПоставка():integer

     ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate <= FactDate )
           MsgBox("Запрещено выполнение операции. Плановая дата ТО по поставке должна быть больше даты досрочной поставки.");
           return 1;
        end;
        j = j + 1;
     end;

     if( not (IsBasket(FD.Group) and (ВидСубъекта(FD.tick.rec.PartyID, PTK_MINFIN) OR 
                                      ((GetMainObjAttr( null, OBJTYPE_PARTY, L_Z( FD.tick.rec.PartyID, 10 ), 1, null, null, NumInList) == true)
                                        AND (NumInList == "18")
                                      )
                                     )
             )/*мин фин или федеральное казначейство*/ 
       )
        if( FD.БылоДосрочноеИсполнение() AND
            (FD.DateArray[DATE_DEALPAY] == FactDate) AND
            (FD.DateArray[DATE_DEALPAY] < FD.DateArray[DATE_DEALPAY_PLAN])
          )  /*SCR 58456*/
           if( MsgBoxEx( "За дату " + string(FactDate) + " уже выполнена досрочная оплата.|Выполнять досрочную поставку ?",
               MB_YES+MB_NO, IND_NO,
               "Досрочная поставка", "Подтверждение начала операции" ) != IND_YES )
              return 1;
           end;
        end;
     else
        if( FD.ExistPC() )
           if( not UpdateRq(FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), DLRQ_STATE_PLAN, FactDate) )
              return 1;
           end;
        end;
     end;

     if( IsREPO(FD.Group) AND IsEXCHANGE(FD.Group) )
        if( ReDefineForBefore(FD, ID_Op, FD.GetRQ(DLRQ_TYPE_PAYMENT), FactDate, false) == false )
           return 1;
        end;

        if( FD.ExistPC() )
           if( ReDefineForBefore(FD, ID_Op, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), FactDate, false) == false )
              return 1;
           end;
        end;

        if( FD.IsBack == true )
           DateKind = DLGR_DATEKIND_PAYMENT2;
        else
           DateKind = DLGR_DATEKIND_PAYMENT;
        end;
        
        if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
          return 1;
        end;
     end;

     if( (not IsREPO(FD.Group)) and (FD.dl_leg.rec.OperState <= DL_LEG_OUTBAL) )
        if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, FactDate) != 0 )
           return 1;
        end;
     end;

     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( j == 0 )
           if( ReDefineForBefore(FD, ID_Op, FD.GetRQ(DLRQ_TYPE_DELIVERY), FactDate, true) == false )
              return 1;
           end;
        else
           if( not UpdateRq(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), DLRQ_STATE_PLAN, FactDate) )
              return 1;
           end;
        end;
        j = j + 1;
     end;

     if( (FD.ExistBack == true) AND (FD.IsBack == false) ) /*по первой части*/
        if( not ПереинициализироватьДатыВторойЧасти(FD) )
           return 1;
        end;
     end;

     if( (IsREPO(FD.Group) and IsBUY(FD.Group)) OR (not IsREPO(FD.Group)) )
        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));
           i = 0;
           while( (FD.pmwrtsum(i) != null) and (FD.pmwrtsum(i).rec.SumID > 0) )
              FD.pmwrtsum(i).rec.Date = FactDate;
              if( not ОбновитьЛот(FD.pmwrtsum(i), PM_WRTSUM_UPDTMODE_CHANGEDATE, FactDate, FD) )
                 msgbox("Ошибка при обновлении даты поставки в лоте");
                 return 1;
              end;
              i = i + 1;
           end;
           j = j + 1;
        end;
     end;

     if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, IIF(FD.IsBack == true, DLGR_DATEKIND_DELIVERY2, DLGR_DATEKIND_DELIVERY), FactDate) != 0 )
        return 1;
     end;

     if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, IIF(FD.IsBack == true, DLGR_DATEKIND_DEPO2, DLGR_DATEKIND_DEPO), FactDate) != 0 )
       return 1;
     end;

     if( (not IsREPO(FD.Group)) and (FD.dl_leg.rec.OperState <= DL_LEG_OUTBAL) )
        if( SetTransferGrDeal(FD, FactDate, FD.tick.rec.PFI) != 0 )
           return 1;
        end;
     end;

     return 0;
  end;

  if( Action == DEALCALC_ACTION_BEFORE_PAY ) /*досрочная оплата*/

     if( ДосрочнаяОплата() != 0 )
        return 1;
     end;

     if( IsBasket(FD.Group) and (ВидСубъекта(FD.tick.rec.PartyID, PTK_MINFIN) or
                                 ((GetMainObjAttr( null, OBJTYPE_PARTY, L_Z( FD.tick.rec.PartyID, 10 ), 1, null, null, NumInList) == true)
                                  AND (NumInList == "18")
                                 )
                                )/*мин фин или федеральное казначейство*/ 
       )
        if( ДосрочнаяПоставка() != 0 )
           return 1;
        end;
     end;

  elif( Action == DEALCALC_ACTION_BEFORE_SET ) /*досрочная поставка*/

     if( ДосрочнаяПоставка() != 0 )
        return 1;
     end;

  elif( Action == DEALCALC_ACTION_BEFORE_AVANCE ) /*досрочный аванс*/

       if( FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate <= FactDate )
          MsgBox( "Запрещено выполнение операции. Плановая дата ТО по авансу должна быть больше даты досрочного аванса." );
          return 1; 
       end;

       if( not IsREPO(FD.Group) )
          /*
          if( not IsClientDeal(FD.tick.rec) )  /*Для собственных сделок*/
             if( not ПроверитьЛот( FD, 
                                   DL_LEG_OUTBAL, DL_LEG_FORM, 
                                   DL_LEG_BALANCE, DL_LEG_FORM) )
                return 1;
             end;
          else                                     /*Для клиентских сделок*/
             if( not ПроверитьЛот( FD, 
                                   DL_LEG_INITIAL, DL_LEG_FORM, 
                                   DL_LEG_INITIAL, DL_LEG_FORM) )
                return 1;
             end;
          end;
          */
          /*Если статус лота -"На балансе" или "Поставлен" то дата должна быть не меньше даты начала исполнения*/
          if( (FD.dl_leg.rec.OperState == DL_LEG_BALANCE) OR
              (FD.dl_leg.rec.OperState == DL_LEG_FORM )
            ) 
             if( FactDate < FD.DateArray[DATE_DEALBEGINEXEC] )
                MsgBox( "Дата должна быть не меньше даты начала исполнения " + string(FD.DateArray[DATE_DEALBEGINEXEC]) );
                return 1;
             end;
          end;
       end;   

       if( ReDefineForBefore( FD, ID_Op, FD.GetRQ(DLRQ_TYPE_AVANCE), FactDate, false ) == false )
          return 1;
       end;

       if( (FD.ExistBack == true) AND (FD.IsBack == true) ) /*по второй части*/
          if( not ПереинициализироватьДатыВторойЧасти( FD ) )
             return 1;
          end;
       end;

       if(FD.IsBack)
         DateKind = DLGR_DATEKIND_AVANCE2;
       else
         DateKind = DLGR_DATEKIND_AVANCE;
       end;

       if(DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
         return 1;
       end;

       MinDate = date(31,12,9999);

       if( (FD.ExistsRQ(DLRQ_TYPE_PAYMENT) and (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_EXEC)) OR
           (FD.ExistsRQ(DLRQ_TYPE_DELIVERY) and (FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_EXEC))
         )
          ИспДругиеТО = true;
       end;

       if( not ИспДругиеТО )
          if(FD.ExistsRQ(DLRQ_TYPE_PAYMENT))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate);
          end;
         
          if(FD.ExistsRQ(DLRQ_TYPE_DELIVERY))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate);
          end;
         
          if(FD.ExistsRQ(DLRQ_TYPE_AVANCE))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate);
          end;
         
          if(FD.ExistsRQ(DLRQ_TYPE_DEPOSIT))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate);
          end;
         
          if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, MinDate) != 0)
            return 1;
          end;
       end;

       if( not IsREPO(FD.Group) )
         if(SetTransferGrDeal(FD, FactDate, FD.tick.rec.PFI) != 0)
           return 1;
         end;
       end;

  elif( Action == DEALCALC_ACTION_BEFORE_DEPOSIT ) /*досрочный задаток*/

      if( FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate <= FactDate )
         MsgBox( "Запрещено выполнение операции. Плановая дата ТО по задатку должна быть больше даты досрочного задатка." );
         return 1; 
      end;

      if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_DEPOSIT), DLRQ_STATE_PLAN, FactDate ) )
         return 1;
      end;

      if( (FD.ExistBack == true) AND (FD.IsBack == true) ) /*по второй части*/
         if( not ПереинициализироватьДатыВторойЧасти( FD ) )
            return 1;
         end;
      end;

      if(FD.IsBack)
        DateKind = DLGR_DATEKIND_AVANCE2;
      else
        DateKind = DLGR_DATEKIND_AVANCE;
      end;

      if(DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
        return 1;
      end;

      MinDate = date(31,12,9999);

      if( (FD.ExistsRQ(DLRQ_TYPE_PAYMENT) and (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_EXEC)) OR
          (FD.ExistsRQ(DLRQ_TYPE_DELIVERY) and (FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_EXEC))
        )
         ИспДругиеТО = true;
      end;

      if( not ИспДругиеТО )
         if(FD.ExistsRQ(DLRQ_TYPE_PAYMENT))
           MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate);
         end;
        
         if(FD.ExistsRQ(DLRQ_TYPE_DELIVERY))
           MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate);
         end;
        
         if(FD.ExistsRQ(DLRQ_TYPE_AVANCE))
           MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate);
         end;
        
         if(FD.ExistsRQ(DLRQ_TYPE_DEPOSIT))
           MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate);
         end;
        
         if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, MinDate) != 0)
           return 1;
         end;
      end;

      if( not IsREPO(FD.Group) )
        if(SetTransferGrDeal(FD, FactDate, FD.tick.rec.PFI) != 0)
          return 1;
        end;
      end;


  elif( Action == DEALCALC_ACTION_OVERDUE_AVANCE ) /*Просрочка аванса*/   
      /*Операция недопустима, если аванс зависит от поставки и поставка не исполнена */
      if( (FD.dl_leg.rec.StartBase == SP_ALG_FROMDATE_STATE) AND (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY))) )
         MsgBox( "Запрещено выполнение операции. ТО аванса зависит от поставки, а поставка не исполнена" );
         return 1;
      end;

      //если статус части сделки "На внебалансе", а запланированных строк переноса по срокам нет,
      //то это означает, что при оплате/поставке/авансе будет установлен статус "На балансе"
      //но, т.к. мы делаем просрочку, то этот статус нужно ставить уже сейчас, иначе последующие проверки не пройдут
      if((FD.dl_leg.rec.OperState == DL_LEG_OUTBAL) AND (GetNRecsTransfer(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID) == 0))
        if( not ОбновитьСтатусЧастиСделки( FD.dl_leg, DL_LEG_BALANCE ) )
          msgbox("Ошибка при изменении статуса сделки");
          return 1;
        end;
      end;

      if( (FD.dl_leg.rec.OperState != DL_LEG_BALANCE) AND (FD.dl_leg.rec.OperState != DL_LEG_FORM) AND (not IsREPO(FD.Group)) )/*???*/
         msgbox("Статус части сделки не подходит для заданного изменения сроков.|" +
                "Сделка должна иметь статус \" На балансе " + 
                "\" или \" Поставлен \"");
         return 1;
      end;

      if( FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_OVERDUE )
         msgbox("Статус ТО по авансу не подходит для заданного изменения сроков");
         return 1;
      end;  

      if( FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_DELAYED )
         if( FD.GetPayPlanDate( FD.dl_leg.rec) < FD.DateArray[DATE_DEALEXEC] )
            if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_OVERDUE, FD.DateArray[DATE_DEALBEGINEXEC] ) )
               return 1;
            end;
         elif( FD.GetPayPlanDate( FD.dl_leg.rec) > FD.DateArray[DATE_DEALEXEC] )
            if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_PLAN ) )
               return 1;
            end;
         end;
      end;

      if( not FD.IsBack and IsREPO(FD.Group))
         UpdateAcc = false;
      else
         UpdateAcc = true;
      end;

      if( ReDefineForOverdue( FD, FD.GetRQ(DLRQ_TYPE_AVANCE), UpdateAcc ) == false )
         return 1;
      end;

      if( not IsClientDeal(FD.tick.rec) )
        if( IsREPO(FD.Group) )
          if( FD.IsBack )
            if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_OVERDUEAVANCE2, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
              return 1;
            end;
            if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE2, date(31,12,9999)) != 0 )
              return 1;
            end;
          end;
        else
          if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_OVERDUEAVANCE, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
             return 1;
          end;
          if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE, date(31,12,9999)) != 0 )
            return 1;
          end;
        end;
      end;
      

  elif( Action == DEALCALC_ACTION_REMOVR_AVANCE ) /*Снятие с просрочки аванса*/
      
     if( ReDefineForRemoveOverdue( FD, FD.GetRQ(DLRQ_TYPE_AVANCE), FactDate, false ) == false )
        return 1;
     end;

     if( not FD.IsBack )
        if( (not IsClientDeal(FD.tick.rec)) and IsREPO(FD.Group) )
           FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate = ExecDate;
        end;
     end; 

     if(FD.IsBack)
       DateKind = DLGR_DATEKIND_AVANCE2;
     else
       DateKind = DLGR_DATEKIND_AVANCE;
     end;

     if(DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
       return 1;
     end;
  elif( Action == DEALCALC_ACTION_OVERDUE_PAY ) /*Просрочка оплаты*/

     /*Нельзя переносить на просрочку оплату, если 
     [оплата зависит от поставки, или (оплата зависит от аванса и аванс зависит от 
     поставки и аванс не исполнен) ] и статус поставки не равен "Закрыт", 
     "Закрыт без движения", "Готов к отправке"*/
     if( ( ( FD.dl_leg.rec.Base == SP_ALG_FROMDATE_STATE  ) OR
           ( ( FD.dl_leg.rec.Base      == SP_ALG_FROMDATE_AVANCE) AND
             ( FD.dl_leg.rec.StartBase == SP_ALG_FROMDATE_STATE) AND
             (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)))
           )
         ) AND
         (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY)))
       )
        msgbox("Запрещено выполнение операции.|Есть зависящие от поставки ТО, а ТО поставки не исполнено");
        return 1;
     end;
     /* Нельзя переносить на просрочку оплату, если 
     [оплата зависит от аванса, или (оплата зависит от поставки и поставка зависит 
     от аванса и поставка не исполнена) ] и статус аванса не равен "Закрыт", 
     "Закрыт без движения", "Готов к отправке"*/
     if( ( ( FD.dl_leg.rec.Base == SP_ALG_FROMDATE_AVANCE) OR
           ( ( FD.dl_leg.rec.Base == SP_ALG_FROMDATE_STATE) AND
             ( FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_AVANCE) AND
             (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY)))
           )
         ) AND
         (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)))
       )
        msgbox("Запрещено выполнение операции.|Есть зависящие от аванса ТО, а ТО по авансу не исполнено");
        return 1;
     end;

     if( (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_OVERDUE) )
        msgbox("Статус ТО по оплате не подходит для заданного изменения сроков");
        return 1;
     end;  

     if( not IsREPO(FD.Group) )
        
        //если статус части сделки "На внебалансе", а запланированных строк переноса по срокам нет,
        //то это означает, что при оплате/поставке будет установлен статус "На балансе"
        //но, т.к. мы делаем просрочку, то этот статус нужно ставить уже сейчас, иначе последующие проверки не пройдут
        if((FD.dl_leg.rec.OperState == DL_LEG_OUTBAL) AND (GetNRecsTransfer(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID) == 0))
          if( not ОбновитьСтатусЧастиСделки( FD.dl_leg, DL_LEG_BALANCE ) )
            msgbox("Ошибка при изменении статуса сделки");
            return 1;
          end;
        end;

        if( (FD.dl_leg.rec.OperState != DL_LEG_BALANCE) AND (FD.dl_leg.rec.OperState != DL_LEG_FORM) )
           msgbox("Статус части сделки не подходит для заданного изменения сроков");
           return 1;
        end;

        if( FD.ExistAvance == true )
           if( (ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)) != true) AND (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State != DLRQ_STATE_OVERDUE) )
              msgbox("Статус ТО по авансу не подходит для заданного изменения сроков");
              return 1;
           end;  
        end; 
     
        PlanDate = FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate;
     end;

     if( FD.IsBack and IsREPO(FD.Group))
        UpdateAcc = true;
     else
        UpdateAcc = false;
     end;
     
     if( ReDefineForOverdue( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), UpdateAcc ) == false )
        return 1;
     end;

     if( IsREPO(FD.Group) and FD.IsBack )
        if( FD.ExistPC() )
           if( ReDefineForOverdue( FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), UpdateAcc ) == false )
              return 1;
           end;
        end;
     end;

     if(FD.IsBack)
       if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_OVERDUEPAY2, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
         return 1;
       end;
       if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT2, date(31,12,9999)) != 0 )
         return 1;
       end;
     else
       if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_OVERDUEPAY, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
         return 1;
       end;
       if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT, date(31,12,9999)) != 0 )
         return 1;
       end;
     end;

  elif( Action == DEALCALC_ACTION_REMOVR_PAY ) /*Снятие с просрочки оплаты*/

     if( FD.ExistAvance == true )
        if( ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)) != true )  
           msgbox("Статус ТО по авансу не подходит для заданного изменения сроков");
           return 1;
        end;
     elif( FD.ExistDeposit == true )
        if( ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DEPOSIT)) != true )  
           msgbox("Статус ТО по депозиту не подходит для заданного изменения сроков");
           return 1;
        end;    
     end;    

     if( not FD.IsBack )
        if( (not IsClientDeal(FD.tick.rec)) and IsREPO(FD.Group) )
           if( FD.IsBack )
              FD1 = SPFirstDoc( FD.Tick, false );   
           else
              FD1 = FD;   
           end;
        end;
     end;

     if( ReDefineForRemoveOverdue( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), FactDate, true ) == false )
        return 1;
     end;
      
     if( IsREPO(FD.Group) and FD.IsBack )
        if( FD.ExistPC() )
           if( ReDefineForRemoveOverdue( FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), FactDate, true ) == false )
              return 1;
           end;
        end;
     end;

     if( not FD.IsBack )
        if( (not IsClientDeal(FD.tick.rec)) and IsREPO(FD.Group) )
           FD1.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate = ExecDate;
        end;
     end;

     if(FD.IsBack == true)
       DateKind = DLGR_DATEKIND_PAYMENT2;
     else
       DateKind = DLGR_DATEKIND_PAYMENT;
     end;

     if(DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
       return 1;
     end;
      
  elif( Action == DEALCALC_ACTION_OVERDUE_SET ) /*Просрочка поставки*/     
      /* выставляем признак того что сейчас будет выполняться просрочка
         это нужно для правильного определения параметров счетов */
/*      FD.IsOverdue = true;*/

     ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) )
        /*Проверим, что исполнение (поставка и оплата) не выполнено, не просрочено, не пролонгировано*/
        if( ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT)) )
           msgbox("Запрещено выполнение операции.|2 часть сделки уже исполнена");
           return 1;
        end;

        if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_OVERDUE )
           msgbox("Запрещено выполнение операции.|2 часть сделки вынесена на просрочку");
           return 1;
        end;

        if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_DELAYED )
           msgbox("Запрещено выполнение операции.|2 часть сделки пролонгирована");
           return 1;
        end;

        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));
           if( ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY)) )
              msgbox("Запрещено выполнение операции.|2 часть сделки уже исполнена");
              return 1;
           end;
          
           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_OVERDUE )
              msgbox("Запрещено выполнение операции.|2 часть сделки вынесена на просрочку");
              return 1;
           end;
          
           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_DELAYED )
              msgbox("Запрещено выполнение операции.|2 часть сделки пролонгирована");
              return 1;
           end;
           j = j + 1;
        end;
     else

        /*Нельзя переносить на просрочку поставку, если 
        [поставка зависит от аванса, или (поставка  зависит от оплаты и оплата  
         зависит от аванса и оплата не исполнена) ] и статус аванса не равен 
        "Закрыт", "Закрыт без движения", "Готов к отправке" */
        if( ( ( FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_AVANCE) OR
              ( ( FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_PAY) AND
                ( FD.dl_leg.rec.Base == SP_ALG_FROMDATE_AVANCE) AND
                (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT)))
              )
            ) AND
            (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)))
          )
           msgbox("Запрещено выполнение операции.|Есть зависящие от аванса ТО, а ТО по авансу не исполнено");
           return 1;
        end;

        /*Нельзя переносить на просрочку поставку, если 
          [поставка зависит от оплаты, или (поставка зависит от аванса и аванс 
          зависит от оплаты и аванс не исполнен ) ] и статус оплаты не равен 
          "Закрыт", "Закрыт без движения", "Готов к отправке"*/
        if( ( ( FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_PAY) OR
              ( ( FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_AVANCE) AND
                ( FD.dl_leg.rec.StartBase == SP_ALG_FROMDATE_PAY) AND
                (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)))
              )
            ) AND
            (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT)))
          )
           msgbox("Запрещено выполнение операции.|Есть зависящие от оплаты ТО, а ТО по оплате не исполнено");
           return 1;
        end;

        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));
           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_OVERDUE )
              msgbox("Статус ТО по поставке не подходит для заданного изменения сроков");
              return 1;
           end;
           j = j + 1;
        end;
     end;

     if( (not IsClientDeal(FD.tick.rec)) and IsREPO(FD.Group) and FD.IsBack and IsEXCHANGE(FD.Group) )
        /*Если это просрочка исполнения 2ч РЕПО ОРЦБ*/
        if( ReDefineForOverdue(FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), true) == false )
           return 1;
        end;

        if( FD.ExistPC() )
           if( ReDefineForOverdue(FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), true) == false )
              return 1;
           end;
        end;
     end;

     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( ReDefineForOverdue(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), false) == false )
           return 1;
        end;
        j = j + 1;
     end;

     if( (FD.ExistBack == true) AND (FD.IsBack == false) ) /*по первой части*/
        if( not ПереинициализироватьДатыВторойЧасти( FD, null, true ) )
           return 1;
        end;
     end;

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) and FD.IsBack )
        /*Если это просрочка исполнения 2ч РЕПО ОРЦБ, то сразу и оплата.*/
        if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_OVERDUEPAY2, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
          return 1;
        end;
     end;

     var TemplNum;
     if( FD.IsBack )
       TemplNum = DLGR_TEMPL_OVERDUEDELIVERY2;
       DateKind = DLGR_DATEKIND_DELIVERY2;
     else
       TemplNum = DLGR_TEMPL_OVERDUEDELIVERY;
       DateKind = DLGR_DATEKIND_DELIVERY;
     end;

     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, TemplNum, ExecDate, CalcWrtTime, FD.CurPFI()) != 0 )
          return 1;
        end;
        j = j + 1;
     end;

     if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, date(31,12,9999)) != 0 )
       return 1;
     end;

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) and FD.IsBack )
        if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT2, date(31,12,9999)) != 0 )
          return 1;
        end;
     end;

     if( FD.IsBack )
       DateKind = DLGR_DATEKIND_DEPO2;
     else
       DateKind = DLGR_DATEKIND_DEPO;
     end;

     if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, date(31,12,9999)) != 0 )
       return 1;
     end;

  elif( Action == DEALCALC_ACTION_REMOVR_SET ) /*Снятие с просрочки поставки*/     

     ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);

     /*аналог ReDefineForRemoveOverdue*/
     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), DLRQ_STATE_PLAN, FactDate) )
           return false;
        end;
        j = j + 1;
     end;

     if( ReDefineDatesBeginExec( FD ) == false )
        return false;
     end;

     if( RePlanCloseDate( FD ) == false )
        return false;
     end;
     /*конец аналог ReDefineForRemoveOverdue*/

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) )
        if( ReDefineForRemoveOverdue( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), FactDate, true ) == false )
           return 1;
        end;

        if( FD.IsBack == true )
           if( not IsClientDeal(FD.tick.rec) )
              if( FD.ExistPC() )
                 if( ReDefineForRemoveOverdue( FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), FactDate, true ) == false )
                    return 1;
                 end;
              end;
           end;

           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT2, FactDate) != 0 )
             return 1;
           end;
        end;
     end;

     if( (FD.ExistBack == true) AND (FD.IsBack == false) ) /*по первой части*/
        if( not ПереинициализироватьДатыВторойЧасти( FD ) )
           return 1;
        end;
     end;

     i = 0;
     while( (FD.pmwrtsum(i) != null) and (FD.pmwrtsum(i).rec.SumID > 0) )
       if( ( IsREPO(FD.Group) and IsBUY(FD.Group) ) OR
           ( not IsREPO(FD.Group) )
         )
       
          FD.pmwrtsum(i).rec.Date = FactDate;

          if( not ОбновитьЛот( FD.pmwrtsum(i), PM_WRTSUM_UPDTMODE_CHANGEDATE, FactDate, FD ) )
             msgbox("Ошибка при обновлении даты поставки в лоте"); 
             return 1;
          end;

       end;
       i = i + 1;
     end;

     if(FD.IsBack == true)
       DateKind = DLGR_DATEKIND_DELIVERY2;
     else
       DateKind = DLGR_DATEKIND_DELIVERY;
     end;

     if(DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
       return 1;
     end;

     if(FD.IsBack == true)
       DateKind = DLGR_DATEKIND_DEPO2;
     else
       DateKind = DLGR_DATEKIND_DEPO;
     end;

     if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DateKind, FactDate) != 0 )
       return 1;
     end;
  elif( Action == DEALCALC_ACTION_LONGPAY ) /*Отложенные аванс/оплата*/

     if( not IsREPO(FD.Group) )
        if( not IsClientDeal(FD.tick.rec) )  /*Для собственных сделок*/
           if( FD.dl_leg.rec.OperState != DL_LEG_OUTBAL )
              SayLotError( DL_LEG_OUTBAL );
              return 1;
           end;
        else                                     /*Для клиентских сделок*/
           if( FD.dl_leg.rec.OperState != DL_LEG_INITIAL )
              SayLotError( DL_LEG_INITIAL );
              return 1;
           end;
        end;
     end;

     if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_DELAYED )
        msgbox("Запрещено выполнение операции.|ТО по оплате не должно быть отложенным");
        return 1;
     end;

     if( (FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_AVANCE) OR
         (FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_PAY) 
       ) 
        ExistLink = true;
     end;

     ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);

     /*Если поставка зависит от аванса или оплаты, то ТО по поставке 
       так же должно быть неоплаченным, непросроченным и непролонгированным*/
     if( ExistLink )
        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));
           if( (FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_OVERDUE) OR
               (FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_DELAYED) OR
               ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY))
             )
              msgbox("Запрещено выполнение операции.|Зависимое ТО по поставке ц/б не должно быть|оплаченным, просроченным или пролонгированным");
              return 1;
           end;
           j = j + 1;
        end;
     end;

     GrDate = date(31,12,9999);
     if( IsREPO(FD.Group) )
        GrDate = ExecDate;
     end;

     if( PlanDate == null ) /*Может быть уже задана при рекурсивном вызове если есть зависимые ТО*/
        if( FD.ExistAvance and (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE))))
           PlanDate = FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate;
           if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_AVANCE), DLRQ_STATE_DELAYED, ExecDate, false) )
              return 1;
           end;
        else
           PlanDate = FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate;
        end;
     end;

     if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_DELAYED, GrDate, false) )
        return 1;
     end;
     
     If(IsClientDeal(FD.tick.rec))
        DlRqCom  = FD.GetRQ(2); /*GAA:518696*/
        if( not UpdateRQ(FD, DlRqCom, DLRQ_STATE_DELAYED, GrDate, false) )
           return 1;
        end;
     end;

     if( IsREPO(FD.Group) )
        if( FD.ExistPC() )
           if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), DLRQ_STATE_DELAYED, ExecDate, false) )
              return 1;
           end;
        end;

        if(IsEXCHANGE(FD.Group))
           /*для биржевых РЕПО оплата и поставка в один день, поэтому пролонгируем сразу оба ТО*/
           j = 0;
           while( j < ArrFIID.size )
              FD.SetCurPFI(ArrFIID(j));
              if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), DLRQ_STATE_DELAYED, ExecDate, false) )
                 return 1;
              end;
              j = j + 1;
           end;
        end;
     end;

     /*Если поставка не зависима , если ТО поставки не пролонгирован*/
     if( (FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State != DLRQ_STATE_DELAYED) AND (ExistLink == false) )
        ReplanStepPlanDates( FD.GetKindDate( DATE_DEALBEGINEXEC ), FD.DateArray[DATE_DEALSETAVOIRISS]);
     end;

     if( not ОбновитьФлагиЧастиСделки( FD.dl_leg, DL_LEG_LAST_EXECUTE ) )
        msgbox("Ошибка при обновлении признака \"Отложенное исполнение\" части сделки."); 
        return 1;
     end; 

     /* Если поставка зависит от аванса или оплаты, установить статус на ТО по базовому активу "Пролонгирован" */
     if( ExistLink ) 
        if( ИзменитьСрокиИсполнения_ДляСделки( FD, DEALCALC_ACTION_LONGSET, doc, ID_Op, FactDate, PlanDate, ExecDate ) != 0 )
           return 1;
        end;
     end;

     if( IsREPO(FD.Group) ) 
        if( (not IsClientDeal(FD.tick.rec)) and FD.IsBack )
           FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate = ExecDate;
        end;
     end;

     if( FD.IsBack )
        if( DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_PROLONGPAY2, PlanDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
           return 1;
        end;
       
        if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT2, ExecDate) != 0 )
           return 1;
        end;
       
        if( FD.ExistAvance() and (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE))))
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE2, ExecDate) != 0 )
              return 1;
           end;
        end;
       
        if( IsEXCHANGE(FD.Group) )
           j = 0;
           while( j < ArrFIID.size )
              FD.SetCurPFI(ArrFIID(j));
              if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_PROLONGDELIVERY2, PlanDate, CalcWrtTime, FD.CurPFI()) != 0 )
                 return 1;
              end;
              j = j + 1;
           end;
       
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY2, ExecDate) != 0 )
              return 1;
           end;
        end;
     else
        if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_DELAYEDPAY, PlanDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
           return 1;
        end;

        if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT, GrDate) != 0 )
           return 1;
        end;
        If(IsClientDeal(FD.tick.rec))
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, 9, GrDate) != 0 )
              return 1;
           end;
          /*GAA:519245 Дата оплаты комисси = дата исполнения сделки, если исполнение отложено - меняем даты оплаты комисии на 31.12.9999*/
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID,10, GrDate) != 0 )
              return 1;
           end;/*GAA*/
        end;
        if( FD.ExistAvance() and (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE))))
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE, GrDate) != 0 )
              return 1;
           end;
        end;
       
        if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) )
           j = 0;
           while( j < ArrFIID.size )
              FD.SetCurPFI(ArrFIID(j));
              if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_DELAYEDDELIVERY, PlanDate, CalcWrtTime, FD.CurPFI()) != 0 )
                return 1;
              end;
              j = j + 1;
           end;
       
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, ExecDate) != 0 )
              return 1;
           end;
        end;
     end;

     if( not IsREPO(FD.Group) )
        if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, date(31,12,9999) ) != 0 )
           return 1;
        end;

        if(SetTransferGrDeal(FD, null, FD.tick.rec.PFI) != 0)
          return 1;
        end;
     end;

  elif( Action == DEALCALC_ACTION_EXECLONGPAY ) /*Исполнение отложенных аванса/оплаты*/     

     if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State != DLRQ_STATE_DELAYED )
        MsgBox( "Для выполнения операции ТО по оплате должно иметь статус \"исполнение отложено\"" );
        return 1;
     end;

     if( FD.ExistAvance )
        if( FactDate < FD.DateArray[DATE_DEALAVANCE_PLAN] )
           msgbox( "Дата исполнения не должна быть меньше плановой даты аванса" );
           return 1;
        end;
     else 
        if( FactDate < FD.DateArray[DATE_DEALPAY_PLAN] )
           msgbox( "Дата исполнения не должна быть меньше плановой даты оплаты" );
           return 1;
        end;
     end;

     if( (FD.dl_leg.rec.StartBase == SP_ALG_FROMDATE_STATE) OR
         ( (FD.ExistAvance == false) AND
           (FD.dl_leg.rec.Base == SP_ALG_FROMDATE_STATE) 
         )
       ) 
        ExistLink = true;
     end;

     if( ExistLink )
        if( (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY))) AND 
            (FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State != DLRQ_STATE_OVERDUE)
          )
           if( IsOprMultiExec() )
              return 1;
           end;

           if( MsgBoxEx( "ТО по поставке ц/б должно имееть статус|\"Исполнено\" или  \"Просрочено\".|Продолжить выполнение операции ?",
                          MB_YES+MB_NO, IND_NO, 
                         "", "Подтверждение выполнения операции" ) != IND_YES ) 
              return 1; 
           end;
        end;
     end;

     if( (FD.dl_leg.rec.OperState == DL_LEG_INITIAL) OR (FD.dl_leg.rec.OperState == DL_LEG_OUTBAL ) )
        FD.DateArray[DATE_DEALBEGINEXEC] = FactDate;
        ReplanStepPlanDates( FD.GetKindDate( DATE_DEALBEGINEXEC ), FD.DateArray[DATE_DEALBEGINEXEC] );
     end;

     if( FD.ExistAvance )
        if( not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)))
           if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_AVANCE), 0, FactDate ))
              return 1;
           end;
        end;
     end;

     if( (not FD.ExistAvance) OR
         ( FD.ExistAvance AND 
           (FD.dl_leg.rec.Base != SP_ALG_FROMDATE_STATE) AND
           (FD.dl_leg.rec.Base != SP_ALG_FROMDATE_AVANCE) AND
           (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate < FactDate)
         ) OR
         (not IsREPO(FD.Group))
        /*для обычных сделок аванс и оплата переводятся в отложенные одновременно по действию "Отложенные аванс/оплата" и одновременно исполняются по действию "Исполнение отложенного аванса/оплаты", 
          поэтому ТО по оплате для таких сделок должно исполняться одновременно с авансом, если аванс есть*/
         )
        if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), 0, FactDate ))
           return 1;
        end;
     end;

     if( FD.ExistAvance )
        if( not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE)))
           if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_AVANCE), DLRQ_STATE_PLAN))
              return 1;
           end;
        end;
     end;

     if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_PLAN ))
        return 1;
     end;

     if( IsREPO(FD.Group) )
        if( FD.ExistPC() )
           if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), DLRQ_STATE_PLAN ) )
              return 1;
           end;
        end;
     end;

     /*исполнение не в срок*/
     if( not ОбновитьФлагиЧастиСделки( FD.dl_leg, DL_LEG_EARLY_EXECUTE ) )
        msgbox("Ошибка при обновлении признака \"Исполнение не в срок\" части сделки."); 
        return 1;
     end; 

     MinDate = date(31,12,9999);

     if(FD.ExistsRQ(DLRQ_TYPE_PAYMENT))
       MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate);
       if(FD.RQIsChanged(DLRQ_TYPE_PAYMENT))
         if(FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.DealPart == 2)
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT2, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate) != 0)
             return 1;
           end;
         else
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate) != 0)
             return 1;
           end;
         end;
       end;
     end;

     if(FD.ExistsRQ(DLRQ_TYPE_DELIVERY))
       MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate);
       if(FD.RQIsChanged(DLRQ_TYPE_DELIVERY))
         if(FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.DealPart == 2)
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY2, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) != 0)
             return 1;
           end;
         else  
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) != 0)
             return 1;
           end;
         end;
       end;
     end;

     if(FD.ExistsRQ(DLRQ_TYPE_AVANCE))
       MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate);
       if(FD.RQIsChanged(DLRQ_TYPE_AVANCE))
         if(FD.GetRQ(DLRQ_TYPE_AVANCE).rec.DealPart == 2)
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE2, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate) != 0)
             return 1;
           end;
         else
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate) != 0)
             return 1;
           end;
         end;
       end;
     end;

     if(FD.ExistsRQ(DLRQ_TYPE_DEPOSIT))
       MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate);
       if(FD.RQIsChanged(DLRQ_TYPE_DEPOSIT))
         if(FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.DealPart == 2)
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE2, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate) != 0)
             return 1;
           end;
         else
           if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_AVANCE, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate) != 0)
             return 1;
           end;
         end;
       end;
     end;

     if( not IsREPO(FD.Group) )
        if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, MinDate) != 0)
           return 1;
        end;
     end;

     /*GAA: 519245  Дата оплаты комисси = дата исполнения сделки, если исполняем отложенную оплату - меняем даты оплаты комисии на FactDate*/
        If(IsClientDeal(FD.tick.rec))
           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, 10, FactDate) != 0 )
              return 1;
           end;
        end;/*GAA*/

     N = GetNRecsTransfer(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID);
     if(N == 1)
       if(ExecDate >= GetPlanTransferDate(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID))
         msgbox("Невозможно досрочно исполнить ТО - ожидается выполнение переноса по срокам.");
         return 1;
       end;
     end;

  elif( Action == DEALCALC_ACTION_LONGSET ) /*Отложенная поставка*/     

     if( not IsREPO(FD.Group) )
        if( not IsClientDeal(FD.tick.rec) )  /*Для собственных сделок*/
           if( FD.dl_leg.rec.OperState != DL_LEG_OUTBAL )
              SayLotError( DL_LEG_OUTBAL );
              return 1;
           end;
        else                                    /*Для клиентских сделок*/
           if( FD.dl_leg.rec.OperState != DL_LEG_INITIAL )
              SayLotError( DL_LEG_INITIAL );
              return 1;
           end;
        end;    
     end;

     /*В рамках даного пункта - оплата зависима <=> ТО по авансу зависит от ТО по пставке или (аванса нет и оплата зависит от ТО по поставке)*/
     if( (FD.dl_leg.rec.StartBase == SP_ALG_FROMDATE_STATE) OR
         ( (FD.ExistAvance == false) AND
           (FD.dl_leg.rec.Base == SP_ALG_FROMDATE_STATE)
         )
       )
        ExistLink = true;
     end;

     if( not IsREPO(FD.Group) )
        if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_DELAYED )
           msgbox("Запрещено выполнение операции.|ТО по поставке не должно быть отложенным");
           return 1;
        end;
     end;

     /*Если оплата зависима, то ТО по авансу (если есть) и оплате так же должны быть неоплаченными, непросроченными и непролонгированными*/
     if( ExistLink )
        if( ( FD.ExistAvance AND 
              ( (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_OVERDUE) OR
                (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_DELAYED) OR
                ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_AVANCE))
              )
            ) OR
            ( (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_OVERDUE) OR
              (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_DELAYED) OR
              ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT))
            )
          )
           msgbox("Запрещено выполнение операции.|ТО по оплате и авансу (если он есть) не должны быть|оплаченными, просроченными или пролонгированными");
           return 1;
        end;
     end;

     ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) )
        /*Проверим, что исполнение (поставка и оплата) не выполнено, не просрочено, не пролонгировано*/

        if( ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT)) )
           msgbox("Запрещено выполнение операции.|2 часть сделки уже исполнена");
           return 1;
        end;

        if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_OVERDUE )
           msgbox("Запрещено выполнение операции.|2 часть сделки вынесена на просрочку");
           return 1;
        end;

        if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_DELAYED )
           msgbox("Запрещено выполнение операции.|2 часть сделки пролонгирована");
           return 1;
        end;

        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));

           if( ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_DELIVERY)) )
              msgbox("Запрещено выполнение операции.|2 часть сделки уже исполнена");
              return 1;
           end;

           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_OVERDUE )
              msgbox("Запрещено выполнение операции.|2 часть сделки вынесена на просрочку");
              return 1;
           end;

           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State == DLRQ_STATE_DELAYED )
              msgbox("Запрещено выполнение операции.|2 часть сделки пролонгирована");
              return 1;
           end;

           j = j + 1;
        end;
     end;

     GrDate = date(31,12,9999);
     if( IsREPO(FD.Group) )
        GrDate = ExecDate;
     end;

     if( PlanDate == null ) /*Может быть уже задана при рекурсивном вызове если есть зависимые ТО*/
        PlanDate = FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
     end;

     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), DLRQ_STATE_DELAYED, GrDate, false) )
           return 1;
        end;
        j = j + 1;
     end;

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) )
        if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_DELAYED, ExecDate, false) )
           return 1;
        end;

        if( FD.ExistPC() )
           if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), DLRQ_STATE_DELAYED, ExecDate, false) )
              return 1;
           end;
        end;
     end;

     /*если ТО контрактива не пролонгирован и оплата не зависима*/
     if( (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State != DLRQ_STATE_DELAYED) AND (ExistLink == false) )
        ReDefineDatesBeginExec( FD );
     end;

     if( not ОбновитьФлагиЧастиСделки(FD.dl_leg, DL_LEG_LAST_EXECUTE) )
        msgbox("Ошибка при обновлении признака \"Отложенное исполнение\" части сделки."); 
        return 1;
     end; 

     if( (FD.ExistBack == true) AND (FD.IsBack == false) ) /*по первой части*/
        if( not ПереинициализироватьДатыВторойЧасти(FD, null, true) )
           return 1;
        end;
     end;

     /*Если оплата зависима, то установить статус на ТО по авансу и оплате "Пролонгирован" */
     if( ExistLink )
        if( ИзменитьСрокиИсполнения_ДляСделки(FD, DEALCALC_ACTION_LONGPAY, doc, ID_Op, FactDate, PlanDate, ExecDate) != 0 )
           return 1;
        end;
     end;

     if( IsREPO(FD.Group) )
        if( (not IsClientDeal(FD.tick.rec)) and FD.IsBack )

           var ArrFIID2 = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
           j = 0;
           while( j < ArrFIID.size )
              FD.SetCurPFI(ArrFIID(j));
              FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate = ExecDate;
              j = j + 1;
           end;
           /*для РЕПО ОРЦБ - и поставка и оплата*/
           if( IsEXCHANGE(FD.Group) )
              FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate = ExecDate;
           end;
        end;

        if( FD.IsBack )
           j = 0;
           while( j < ArrFIID.size )
              FD.SetCurPFI(ArrFIID(j));
              if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_PROLONGDELIVERY2, PlanDate, CalcWrtTime, FD.CurPFI()) != 0 )
                 return 1;
              end;
              j = j + 1;
           end;

           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY2, ExecDate) != 0 )
              return 1;
           end;

           var DepoDate:date = ExecDate;
           if( IsOUTEXCHANGE(FD.Group) or IsBROKER(FD.Group) )
              DepoDate = DepoDate - DL_NDaysBeforeInsertDepoDraft;
              if( DepoDate < FD.tick.rec.DealDate )
                 DepoDate = FD.tick.rec.DealDate;
              end;
           end;

           if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DEPO2, DepoDate) != 0 )
              return 1;
           end;

           if( IsEXCHANGE(FD.Group) )
              if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_PROLONGPAY2, PlanDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
                 return 1;
              end;

              if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT2, ExecDate) != 0 )
                 return 1;
              end;
           end;
        else
           j = 0;
           while( j < ArrFIID.size )
              FD.SetCurPFI(ArrFIID(j));
              if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_DELAYEDDELIVERY, PlanDate, CalcWrtTime, FD.CurPFI()) != 0 )
                return 1;
              end;
              j = j + 1;
           end;
        end;
     else
       if( DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_DELAYEDDELIVERY, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
          return 1;
       end;

       if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, date(31,12,9999)) != 0 )
          return 1;
       end;

       if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, date(31,12,9999)) != 0 )
          return 1;
       end;

       if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DEPO, date(31,12,9999)) != 0 )
         return 1;
       end;

       if( SetTransferGrDeal(FD, null, FD.tick.rec.PFI) != 0 )
         return 1;
       end;
     end;

  elif( Action == DEALCALC_ACTION_EXECLONGSET ) /*Исполнение отложенной поставки*/

     ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);

     if( not (IsREPO(FD.Group) and IsEXCHANGE(FD.Group)) )
        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));
           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State != DLRQ_STATE_DELAYED )
              MsgBox( "Для выполнения операции ТО по поставке ц/б|должно иметь статус \"исполнение отложено\"" );
              return 1;
           end;
           j = j + 1;
        end;
        if( FactDate < FD.DateArray[DATE_DEALSETAVOIRISS_PLAN] )
           msgbox( "Дата исполнения не должна быть меньше плановой даты поставки" );
           return 1;
        end;
     else
        j = 0;
        while( j < ArrFIID.size )
           FD.SetCurPFI(ArrFIID(j));
           if( FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State != DLRQ_STATE_DELAYED )
              MsgBox( "Для выполнения операции ТО по поставке и оплате ц/б|должны иметь статус \"исполнение отложено\"" );
              return 1;
           end;
           j = j + 1;
        end;

        if( FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State != DLRQ_STATE_DELAYED )
           MsgBox( "Для выполнения операции ТО по поставке и оплате ц/б|должны иметь статус \"исполнение отложено\"" );
           return 1;
        end;

        if( (FactDate < FD.DateArray[DATE_DEALSETAVOIRISS_PLAN]) or (FactDate < FD.DateArray[DATE_DEALPAY_PLAN]) )
           msgbox( "Дата исполнения не должна быть меньше плановой даты исполнения 2ч" );
           return 1;
        end;
     end;

     if( (FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_PAY) OR
         (FD.dl_leg.rec.PrincipalBase == SP_ALG_FROMDATE_AVANCE) 
       ) 
        ExistLink = true;
     end;

     if( ExistLink )
        if( (not ТОЗакрыто(FD.GetRQ(DLRQ_TYPE_PAYMENT))) AND 
            (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State != DLRQ_STATE_OVERDUE)
          )
           if( IsOprMultiExec() )
              return 1;
           end;

           if( MsgBoxEx( "ТО по оплате ц/б должно имееть статус|\"Исполнено\",  или  \"Просрочено\".|Продолжить выполнение операции ?",
                          MB_YES+MB_NO, IND_NO, 
                         "", "Подтверждение выполнения операции" ) != IND_YES ) 
              return 1; 
           end;
        end;
     end;

     if( (FD.dl_leg.rec.OperState == DL_LEG_INITIAL) OR (FD.dl_leg.rec.OperState == DL_LEG_OUTBAL ) )
        FD.DateArray[DATE_DEALBEGINEXEC] = FactDate;
        ReplanStepPlanDates( FD.GetKindDate( DATE_DEALBEGINEXEC ), FD.DateArray[DATE_DEALBEGINEXEC] );
     end;

     j = 0;
     while( j < ArrFIID.size )
        FD.SetCurPFI(ArrFIID(j));
        if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), 0, FactDate) )
           return 1;
        end;

        if( not UpdateRQ(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), DLRQ_STATE_PLAN) )
           return 1;
        end;
        j = j + 1;
     end;

     if( IsREPO(FD.Group) and IsEXCHANGE(FD.Group) )
        if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), 0, FactDate ))
           return 1;
        end;

        if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_PLAN ))
           return 1;
        end;

        if( FD.ExistPC() )
           if( not UpdateRQ( FD, FD.GetRQ(DLRQ_TYPE_INCREPO, 2), DLRQ_STATE_PLAN ) )
              return 1;
           end;
        end;

        FD.DateArray[DATE_DEALEXEC] = FactDate;
        ReplanStepPlanDates( FD.GetKindDate( DATE_DEALEXEC ), FD.DateArray[DATE_DEALEXEC] );
     end;

     /*исполнение не в срок*/
     if( not ОбновитьФлагиЧастиСделки( FD.dl_leg, DL_LEG_EARLY_EXECUTE ) )
        msgbox("Ошибка при обновлении признака \"Исполнение не в срок\" части сделки."); 
        return 1;
     end; 

     if( (FD.ExistBack == true) AND (FD.IsBack == false) ) /*по первой части*/
        if( not ПереинициализироватьДатыВторойЧасти( FD ) )
           return 1;
        end;
     end;

     i = 0;
     while( (FD.pmwrtsum(i) != null) and (FD.pmwrtsum(i).rec.SumID > 0) )
       if( ( IsREPO(FD.Group) and IsBUY(FD.Group) ) OR
           ( not IsREPO(FD.Group) )
         )
       
          FD.pmwrtsum(i).rec.Date = FactDate;

          if( not ОбновитьЛот( FD.pmwrtsum(i), PM_WRTSUM_UPDTMODE_CHANGEDATE, FactDate, FD ) )
             msgbox("Ошибка при обновлении даты поставки в лоте"); 
             return 1;
          end;

       end;
       i = i + 1;
     end;

     if( IsREPO(FD.Group) )
       if( FD.IsBack )
         if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY2, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) != 0)
           return 1;
         end;
       else
         if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) != 0)
           return 1;
         end;
       end;
     else
       if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) != 0)
          return 1;
       end;

       if( DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DEPO, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate) != 0 )
          return 1;
       end;

       If((IsClientDeal(FD.tick.rec)) AND(FD.ExistsRQ(DLRQ_TYPE_COMISS)) )

          DlRqCom  = FD.GetRQ(DLRQ_TYPE_COMISS);

          if( not UpdateRQ( FD,DlRqCom, 2, FactDate ))
             return 1;
          end;
 
          DlRqCom.rec.plandate = FactDate;
          DlRqCom.rec.Factdate = FactDate;
          NewCommSum = GetNewCOmSumm(FD, FD.GetRQ(2), DlRqCom);/*round(FD.dl_leg.rec.cost * 0.1 /100,2);*/
          OldCommSum = DlRqCom.rec.amount;
          If(NewCommSum != DlRqCom.rec.amount)
             DlRqCom.rec.amount = NewCommSum;
             DlRqCom.rec.Factamount = NewCommSum;
  
             addNoteForObject( 101, 
                                 L_Z(DlRqCom.rec.docid, 34 ),
                                 203, 
                                 abs(NewCommSum - OldCommSum), 
                                 FactDate );

          end;
          UpdateCOmiss(DlRqCom, FactDate);
/*!!*/ 

           if(DL_ChangeDLRQ(DlRqCom, FactDate, DLRQ_ACTION_UPDATE) != 0)
              return 1;
           end;


/*
          if( not UpdateRQ( FD,DlRqCom, 0, FactDate ))
             return 1;
          end;
*/
          
/*      

           if(DL_ChangeDLRQ(FD.GetRQ(6), FactDate, DLRQ_ACTION_UPDATE) != 0)
              return 1;
           end;
*/
       end;
       MinDate = date(31,12,9999);

       if( (FD.ExistsRQ(DLRQ_TYPE_PAYMENT) and (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_EXEC)) OR
           (FD.ExistsRQ(DLRQ_TYPE_AVANCE) and (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_EXEC)) OR
           (FD.ExistsRQ(DLRQ_TYPE_DEPOSIT) and (FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.State == DLRQ_STATE_EXEC))
         )
          ИспДругиеТО = true;
       end;

       if( not ИспДругиеТО )
          if(FD.ExistsRQ(DLRQ_TYPE_PAYMENT))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate);
          end;
         
          if(FD.ExistsRQ(DLRQ_TYPE_DELIVERY))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate);
          end;
         
          if(FD.ExistsRQ(DLRQ_TYPE_AVANCE))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate);
          end;
         
          if(FD.ExistsRQ(DLRQ_TYPE_DEPOSIT))
            MinDate = min(MinDate, FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate);
          end;
         
          if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, MinDate) != 0)
            return 1;
          end;
       end;

       N = GetNRecsTransfer(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID);
       if(N == 1)
         if(ExecDate >= GetPlanTransferDate(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID))
           msgbox("Невозможно досрочно исполнить ТО - ожидается выполнение переноса по срокам.");
           return 1;
         end;
       end;
     end;
  elif(Action == DEALCALC_ACTION_LONGCALCDVP) //Отложенный расчет по DVP
     var SetDate = date(31,12,9999);

     SpChangeDlLeg.Maturity = SetDate;
     SpChangeDlLeg.Expiry   = SetDate;

     if(FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate == SetDate)
       msgbox("Уже выполнен отложенный расчет по DVP"); 
       return 1;
     end;
     
     if(FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State > DLRQ_STATE_PLAN)
       msgbox("Недопустимый статус ТО по оплате"); 
       return 1;
     end;

     if(FD.GetRQ(DLRQ_TYPE_DELIVERY).rec.State > DLRQ_STATE_PLAN)
       msgbox("Недопустимый статус ТО по поставке"); 
       return 1;
     end;

     if( not UpdateRq(FD, FD.GetRQ(DLRQ_TYPE_DELIVERY), DLRQ_STATE_DELAYED, SetDate) )
        return 1;
     end;

     if( not UpdateRq(FD, FD.GetRQ(DLRQ_TYPE_PAYMENT), DLRQ_STATE_DELAYED, SetDate) )
        return 1;
     end;


     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_BALANCE, SetDate) != 0)
       return 1;
     end;

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_PAYMENT, SetDate) != 0)
       return 1;
     end;

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DELIVERY, SetDate) != 0)
       return 1;
     end; 

     if(DL_SetDateGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_DEPO, SetDate) != 0)
       return 1;
     end;

  else
     msgbox( "Неопределен вид действия операции расчетов по сделке."); 
     return 1;
  end;

  if( IsREPO(FD.Group) )
     if( FD.IsBack )
        FD2 = FD;   
     else
        FD2 = SPFirstDoc( FD.Tick, true );   
     end;

     if(FD2.ExistPC())
        FD2.GetRQ(DLRQ_TYPE_INCREPO, 2).rec.Amount = SpChangeDlLegBack.ReturnIncome;
     end;
  end;

  return 0;
end;

// есть ли в ТО по сделке ТО с данным статусом
Private macro IsStatusRQ(FD, statusRQ, ID_RQ, IsREPO ) // все ТО или только по второй части?
    var stat = 0;
    var Select, DataSet, Query;
    Query = "SELECT * FROM ddlrq_dbt"
          + " WHERE  t_DocKind = ?"
          + " AND t_DocID = ? "
          + " AND t_state = ? "            // статус
          + " AND t_type IN (2, 8) ";      // интересуют только оплата и поставка?
    if( IsREPO )
      Query = Query + " AND t_dealPart = 2 ";        // только по второй части?
    end;
      Query = Query + " AND t_ID <> ? " ;

    Select = DL_RSDCommand(Query);
    Select.AddParam(FD.tick.rec.BofficeKind);
    Select.AddParam(FD.tick.rec.DealID);
    Select.AddParam(statusRQ);
    Select.AddParam(ID_RQ);

    stat = Select.GetCount(query);

    return stat;
end;

Private macro GetPlanDateNotExec(FD, ID_RQ, IsREPO)
    var DateExecution = Date(0,0,0);
    var Select, DataSet, Query;
    Query = "SELECT * FROM ddlrq_dbt"
          + " WHERE  t_DocKind = ?"
          + " AND t_DocID = ? "
          + " AND t_state = 0  "           
          + " AND t_type IN (2, 8) ";
    if( IsREPO )
      Query = Query + " AND t_dealPart = 2 ";
    end;
    Query = Query + " AND t_ID <> ? " ;

    Select = DL_RSDCommand(Query);
    Select.AddParam(FD.tick.rec.BofficeKind);
    Select.AddParam(FD.tick.rec.DealID);
    Select.AddParam(ID_RQ);
    DataSet = Select.execute();
    if( DataSet.moveNext() )
      DateExecution = DataSet.plandate;
    end;

    return DateExecution;
end;

// все ли остальные исполнены?
Private macro IsExecuteRQ(FD, ID_RQ, IsREPO)
    var stat = 0;
    var Select, DataSet, Query;
    Query = "SELECT * FROM ddlrq_dbt"
          + " WHERE  t_DocKind = ?"
          + " AND t_DocID = ? "
          + " AND t_state <> 2 "           // исполненные
          + " AND t_type IN (2, 8) ";       // интересуют только оплата и поставка?
    if( IsREPO )
      Query= Query + " AND t_dealPart = 2 "; // только по второй части?
    end;
    Query = Query + " AND t_ID <> ? " ;

    Select = DL_RSDCommand(Query);
    Select.AddParam(FD.tick.rec.BofficeKind);
    Select.AddParam(FD.tick.rec.DealID);
    Select.AddParam(ID_RQ);

    stat = Select.GetCount(query);

    return stat;
end;

Private macro ВставитьДействиеИзменениеСостоянияОбязательствДляРепо( FD, Action, FactDate, ExecDate, ОжиданиеЗапроса, requestTimeout )
    var DateExecution = Date(0,0,0);
    var Templnum = 0;
    var SelectClose, DataSetClose, QueryClose;
    var cnt = 0;
    var MaxGrDate:date = date(31,12,9999);
    QueryClose = "select * from ddlgrdeal_dbt where t_DocKind = ? and t_DocID = ? and t_TemplNum in(51,52) " ;
    SelectClose = DL_RSDCommand(QueryClose);
    SelectClose.AddParam(FD.tick.rec.BofficeKind);
    SelectClose.AddParam(FD.tick.rec.DealID);

    cnt = SelectClose.GetCount(QueryClose);     // если не запланировано закрытие договора, то ничего не вставляем
    if( cnt == 0 )
      return 0;
    end;

    var CloseRQ = TRecHandler( "dlrq" );
    var CurrRQ  = TRecHandler( "dlrq" );
    var RQ1     = TRecHandler( "dlrq" );
    var RQ2     = TRecHandler( "dlrq" );

    var Select, DataSet, Query;
    //DLRQ
    Query = "  SELECT rq.* "
          + "    FROM ddlrq_dbt rq, ddlrqbc_dbt bc "
          + "   WHERE     t_DocKind = ? "
                + "   AND rq.t_DocID = ? "
                + "   AND rq.t_dealPart = 2 "
                + "   AND rq.t_type IN (2, 8) "
                + "   AND rq.t_state <>  " + DLRQ_STATE_EXEC
                + "   AND bc.t_rqid(+) = rq.t_id "
                + "   AND bc.t_instance(+) = 0 "
                + "   AND (   (rq.t_plandate = "
                             + "  (SELECT MAX (NVL (bc.t_plandate, rq.t_plandate)) "
                             + "     FROM ddlrq_dbt rq, ddlrqbc_dbt bc "
                             + "    WHERE     t_DocKind = ? "
                                    + "   AND rq.t_DocID = ? "
                                    + "   AND rq.t_dealPart = 2 "
                                    + "   AND rq.t_type IN (2, 8) "
                                    + "   AND rq.t_state <> " + DLRQ_STATE_EXEC
                                    + "   AND bc.t_rqid(+) = rq.t_id "
                                    + "   AND bc.t_instance(+) = 0)) "
                       + " OR bc.t_plandate = "
                           + "   (SELECT MAX (NVL (bc.t_plandate, rq.t_plandate)) "
                           + "      FROM ddlrq_dbt rq, ddlrqbc_dbt bc "
                           + "     WHERE     t_DocKind = ? "
                                 + "     AND rq.t_DocID = ? "
                                 + "     AND rq.t_dealPart = 2 "
                                 + "     AND rq.t_type IN (2, 8) "
                                 + "     AND rq.t_state <> " + DLRQ_STATE_EXEC
                                 + "     AND bc.t_rqid(+) = rq.t_id "
                                 + "     AND bc.t_instance(+) = 0)) "
                                 ;

    Select = DL_RSDCommand(Query);
    Select.AddParam(FD.tick.rec.BofficeKind);
    Select.AddParam(FD.tick.rec.DealID);
    Select.AddParam(FD.tick.rec.BofficeKind);
    Select.AddParam(FD.tick.rec.DealID);
    Select.AddParam(FD.tick.rec.BofficeKind);
    Select.AddParam(FD.tick.rec.DealID);

    cnt = Select.GetCount(query);
    DataSet = Select.Execute();

    if( (Action == DEALCALC_ACTION_BEFORE_PAY) or (Action == DEALCALC_ACTION_OVERDUE_PAY) or (Action == DEALCALC_ACTION_REMOVR_PAY) or (Action == DEALCALC_ACTION_LONGPAY) or (Action == DEALCALC_ACTION_EXECLONGPAY))
      CurrRQ = FD.GetRQ(DLRQ_TYPE_PAYMENT);
    elif( (Action == DEALCALC_ACTION_BEFORE_SET) or (Action == DEALCALC_ACTION_OVERDUE_SET) or (Action == DEALCALC_ACTION_REMOVR_SET) or (Action == DEALCALC_ACTION_LONGSET) or (Action == DEALCALC_ACTION_EXECLONGSET))
      CurrRQ = FD.GetRQ(DLRQ_TYPE_DELIVERY);
    else
      return 0; 
    end;

    if( cnt == 1 )
      if(DataSet.moveNext())
        DataSet.GetRecord().CopyTo( CloseRQ.rec );
      end;
    else
      return 0;
    end;



    if(CloseRQ.rec.ID == CurrRQ.rec.ID )       // если изменения закрывающего ТО

      if( (Action == DEALCALC_ACTION_BEFORE_PAY) or (Action == DEALCALC_ACTION_BEFORE_SET))      // досрочная оплата/поставка

        if(IsStatusRQ(FD, DLRQ_STATE_OVERDUE, CurrRQ.rec.ID, true))  //если есть просроченое ТО

           if(CurrRQ.rec.Type == DLRQ_TYPE_DELIVERY)    // если текущее ТО по поставке, то просрочка по оплате
             Templnum = DLGR_TEMPL_OVERDUEPAY2;
           else
             Templnum = DLGR_TEMPL_OVERDUEDELIVERY2;    // иначе просрочка по поставке
           end;
           DateExecution = date(GetPlanDateGr(FD, Templnum));

           if( ОжиданиеЗапроса and requestTimeout)
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECDELAYMSGWTHREQUEST, GetDateAfterWorkDays(DateExecution, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
               return 1;
             end;
           else
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECDELAYMSG, DateExecution, CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
               return 1;
             end;
           end;

        elif(IsStatusRQ(FD, DLRQ_STATE_DELAYED, CurrRQ.rec.ID, true))   // отложеное ТО

           if(CurrRQ.rec.Type == DLRQ_TYPE_DELIVERY)    // если текущее ТО по поставке, то пролонгация по оплате
             Templnum = DLGR_TEMPL_PROLONGPAY2;
           else
             Templnum = DLGR_TEMPL_PROLONGDELIVERY2;    // иначе пролонгация по поставке
           end;
           DateExecution = date(GetPlanDateGr(FD, Templnum)) ;

           if( ОжиданиеЗапроса and requestTimeout)
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECHOLDMSGWTHREQUEST, GetDateAfterWorkDays(DateExecution, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, DateExecution) != 0 )
               return 1;
             end;
           else
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECHOLDMSG, DateExecution, CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, DateExecution) != 0 )
               return 1;
             end;
           end;
        elif( not IsExecuteRQ(FD, CurrRQ.rec.ID, true)) // если нет неисполненных
           if((CurrRQ.rec.Netting == UNSET_CHAR) or( not (CurrRQ.rec.Type == DLRQ_TYPE_DELIVERY))) // не включен в неттинг или не по поставке 
             if( ОжиданиеЗапроса and requestTimeout)
          if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTRWTHREQUEST, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
            return 1;
          end;
               if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EARLYEXECMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
                 return 1;
               end;
             else
          if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
            return 1;
          end;
               if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EARLYEXECMSG, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
                 return 1;
               end;
             end;
           else
             if( ОжиданиеЗапроса and requestTimeout)
          if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTRWTHREQUEST, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
            return 1;
          end;
               if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_NETTINGSUSPWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
                 return 1;
               end;
             else
          if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, date(0,0,0), DLGRACC_STATE_NOTNEED ) != 0)
            return 1;
          end;
               if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_NETTINGSUSP, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
                 return 1;
               end;
             end;
           end;
        elif(  (IsExecuteRQ(FD, CurrRQ.rec.ID, true)) and ( not IsStatusRQ(FD, DLRQ_STATE_OVERDUE, CurrRQ.rec.ID, true)) and (not IsStatusRQ(FD, DLRQ_STATE_DELAYED, CurrRQ.rec.ID, true)) ) // если нет неисполненных
           var  DateClose = date(GetPlanDateNotExec(FD, CurrRQ.rec.ID, true));
           if( ОжиданиеЗапроса and requestTimeout)
  	     if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTRWTHREQUEST, DLGR_ACCKIND_REPOSITORY, GetDateAfterWorkDays(DateClose, requestTimeout, FD.ПолучитьКалендСвязанный()), DLGRACC_STATE_PLAN ) != 0)
          return 1;
        end;
           else
  	     if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, GetDateAfterWorkDays(DateClose, requestTimeout, FD.ПолучитьКалендСвязанный()), DLGRACC_STATE_PLAN ) != 0)
          return 1;
        end;
           end;
        end;


      elif((Action == DEALCALC_ACTION_OVERDUE_PAY) or (Action == DEALCALC_ACTION_OVERDUE_SET))  // просрочка оплаты/поставки

        if( ОжиданиеЗапроса and requestTimeout)
          if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECDELAYMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
            return 1;
          end;
          if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
            return 1;
          end;
        else                                                                                 
          if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECDELAYMSG, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
            return 1;
          end;
          if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
            return 1;
          end;
        end;

      elif((Action == DEALCALC_ACTION_REMOVR_PAY) or (Action == DEALCALC_ACTION_REMOVR_SET))    // снятие с просрочки оплаты/поставки

        if( not IsExecuteRQ(FD, CurrRQ.rec.ID, true)) // если нет неисполненных
           if((CurrRQ.rec.Netting == UNSET_CHAR) or( not (CurrRQ.rec.Type == DLRQ_TYPE_DELIVERY))) // не включен в неттинг или не по поставке 
             if( ОжиданиеЗапроса and requestTimeout)

  	       if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTRWTHREQUEST, DLGR_ACCKIND_REPOSITORY, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()), DLGRACC_STATE_PLAN ) != 0)
            return 1;
          end;
             else
          if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, ExecDate, DLGRACC_STATE_PLAN ) != 0)
            return 1;
          end;
             end;
           else
             return 0;
           end;
        elif(IsStatusRQ(FD, DLRQ_STATE_DELAYED, CurrRQ.rec.ID, true))
           if(CurrRQ.rec.Type == DLRQ_TYPE_DELIVERY)    // если текущее ТО по поставке, то пролонгация по оплате
             Templnum = DLGR_TEMPL_PROLONGPAY2;
           else
             Templnum = DLGR_TEMPL_PROLONGDELIVERY2;    // иначе пролонгация по поставке
           end;
           DateExecution = date(GetPlanDateGr(FD, Templnum)) ;

           if( ОжиданиеЗапроса and requestTimeout)
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECHOLDMSGWTHREQUEST, GetDateAfterWorkDays(DateExecution, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, DateExecution) != 0 )
               return 1;
             end;
           else                                                                                 
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECHOLDMSG, DateExecution, CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, DateExecution) != 0 )
               return 1;
             end;
           end;

        end;

      elif((Action == DEALCALC_ACTION_LONGPAY) or (Action == DEALCALC_ACTION_LONGSET))          // отложеные оплата/поставка

        if( ОжиданиеЗапроса and requestTimeout)
          if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECHOLDMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
            return 1;
          end;
          if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, ExecDate) != 0 )
            return 1;
          end;
        else                                                                                 
          if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECHOLDMSG, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
            return 1;
          end;
          if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, ExecDate) != 0 )
            return 1;
          end;
        end;

      elif((Action == DEALCALC_ACTION_EXECLONGPAY) or (Action == DEALCALC_ACTION_EXECLONGSET))  // исполнение отложенных оплаты/поставки

        if( not IsExecuteRQ(FD, CurrRQ.rec.ID, true)) // если нет неисполненных
           if((CurrRQ.rec.Netting == UNSET_CHAR) or( not (CurrRQ.rec.Type == DLRQ_TYPE_DELIVERY))) // не включен в неттинг или не по поставке 
             if( ОжиданиеЗапроса and requestTimeout)

  	       if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTRWTHREQUEST, DLGR_ACCKIND_REPOSITORY, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()), DLGRACC_STATE_PLAN ) != 0)
            return 1;
          end;
             else
          if( DL_UpdateGrDealAcc( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, DLGR_TEMPL_CLOSECONTR, DLGR_ACCKIND_REPOSITORY, ExecDate, DLGRACC_STATE_PLAN ) != 0)
            return 1;
          end;
             end;
           else
             return 0;
           end;
        elif(IsStatusRQ(FD, DLRQ_STATE_OVERDUE, CurrRQ.rec.ID, true))    //если ТО просрочено
           if( ОжиданиеЗапроса and requestTimeout)
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECDELAYMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
               return 1;
             end;
           else                                                                                 
             if(DL_InsertGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_EXECDELAYMSG, ExecDate, CalcWrtTime, FD.tick.rec.PFI) != 0 )
               return 1;
             end;
             if( DL_SetDateGrDeal( FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
               return 1;
             end;
           end;
        end;
      end;
    else
      return 0; //если закрывающее ТО не текущее, тогда ничего не делаем
    end;

   return 0;
end;

private macro ОбработкаОтложенногоЗакрывающегоТО(FD, ОжиданиеЗапроса, requestTimeout, ExecDate, DocKind, DealID, PFI)
  if( ОжиданиеЗапроса and requestTimeout)
    if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECHOLDMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, PFI) != 0 )
      return 1;
    end;
    if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, ExecDate) != 0 )
      return 1;
    end;
  else
    if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECHOLDMSG, ExecDate, CalcWrtTime, PFI) != 0 )
      return 1;
    end;
    if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, ExecDate) != 0 )
      return 1;
    end;
  end;
end;

private macro ОбработкаПросроченногоЗакрывающегоТО(FD, ОжиданиеЗапроса, requestTimeout, ExecDate, DocKind, DealID, PFI)
  if( ОжиданиеЗапроса and requestTimeout)
    if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECDELAYMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, PFI) != 0 )
      return 1;
    end;
    if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
      return 1;
    end;
  else
    if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECDELAYMSG, ExecDate, CalcWrtTime, PFI) != 0 )
      return 1;
    end;
    if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
      return 1;
    end;
  end;
end;

private macro ОбработкаСнятияСПросрочкиЗакрывающегоТО(FD, RQ, ОжиданиеЗапроса, requestTimeout, ExecDate, OtherRQ, DocKind, DealID, PFI)
  // Если другое ТО исполнено
  if( OtherRQ.rec.State == DLRQ_STATE_EXEC )
    if( ОжиданиеЗапроса and requestTimeout)
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный())) != 0 )
        return 1;
      end;
    else
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, ExecDate) != 0 )
        return 1;
      end;
    end;
  // Если другое ТО отложено
  elif ( OtherRQ.rec.State == DLRQ_STATE_DELAYED )
    if( ОжиданиеЗапроса and requestTimeout)
      if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECHOLDMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, PFI) != 0 )
        return 1;
      end;
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, RQ.rec.PlanDate) != 0 )
        return 1;
      end;
    else
      if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECHOLDMSG, ExecDate, CalcWrtTime, PFI) != 0 )
        return 1;
      end;
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, RQ.rec.PlanDate) != 0 )
        return 1;
      end;
    end;
  end;
end;

private macro ОбработкаИсполненияОтложенногоЗакрывающегоТО(FD, ОжиданиеЗапроса, requestTimeout, ExecDate, OtherRQ, DocKind, DealID, PFI)
  // Если другое ТО исполнено
  if( OtherRQ.rec.State == DLRQ_STATE_EXEC )
    if( ОжиданиеЗапроса and requestTimeout)
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный())) != 0 )
        return 1;
      end;
    else
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, ExecDate) != 0 )
        return 1;
      end;
    end;
  // Если другое ТО просрочено
  elif ( OtherRQ.rec.State == DLRQ_STATE_OVERDUE )
    if( ОжиданиеЗапроса and requestTimeout)
      if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECDELAYMSGWTHREQUEST, GetDateAfterWorkDays(ExecDate, requestTimeout, FD.ПолучитьКалендСвязанный()) , CalcWrtTime, PFI) != 0 )
        return 1;
      end;
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
        return 1;
      end;
    else
      if(DL_InsertGrDeal( DocKind, DealID, DLGR_TEMPL_EXECDELAYMSG, ExecDate, CalcWrtTime, PFI) != 0 )
        return 1;
      end;
      if( DL_SetDateGrDeal( DocKind, DealID, DLGR_DATEKIND_CLOSEDEAL, date(31,12,9999)) != 0 )
        return 1;
      end;
    end;
  end;
end;

Private macro ВставитьДействиеИзменениеСостоянияОбязательствВнебиржи( FD, Action, FactDate, ExecDate, ОжиданиеЗапроса, requestTimeout, DocKind, DealID, PFI )
    var CurrRQ = TRecHandler( "dlrq" );
    var OtherRQ = TRecHandler( "dlrq" );

    // Получаем ТО, по которому идет исполнение  требований
    if( (Action == DEALCALC_ACTION_BEFORE_PAY)  OR
        (Action == DEALCALC_ACTION_OVERDUE_PAY) OR
        (Action == DEALCALC_ACTION_REMOVR_PAY)  OR
        (Action == DEALCALC_ACTION_LONGPAY)     OR
        (Action == DEALCALC_ACTION_EXECLONGPAY))
      CurrRQ = FD.GetRQ(DLRQ_TYPE_PAYMENT);
      OtherRQ = FD.GetRQ(DLRQ_TYPE_DELIVERY);
    elif( (Action == DEALCALC_ACTION_BEFORE_SET)  OR
          (Action == DEALCALC_ACTION_OVERDUE_SET) OR
          (Action == DEALCALC_ACTION_REMOVR_SET)  OR
          (Action == DEALCALC_ACTION_LONGSET)     OR
          (Action == DEALCALC_ACTION_EXECLONGSET))
      CurrRQ = FD.GetRQ(DLRQ_TYPE_DELIVERY);
      OtherRQ = FD.GetRQ(DLRQ_TYPE_PAYMENT);
    else
      return 0; 
    end;

    var planDate = ZeroDate;
    // Для отложенного ТО плановая дата равна максимальной,
    // поэтому она не подходит для определения, является ли это ТО закрывающим
    if( OtherRQ.rec.State == DLRQ_STATE_DELAYED )
      planDate = OtherRQ.rec.ChangeDate;
    else
      planDate = OtherRQ.rec.PlanDate;
    end;

    // Если выполняется снятие с просрочки оплаты/поставки
    if( (Action == DEALCALC_ACTION_REMOVR_PAY) or (Action == DEALCALC_ACTION_REMOVR_SET) )
      if( ((planDate <= CurrRQ.rec.PlanDate) and (OtherRQ.rec.State != DLRQ_STATE_PLAN)) OR (OtherRQ.rec.State == DLRQ_STATE_EXEC) )
        ОбработкаСнятияСПросрочкиЗакрывающегоТО(FD, OtherRQ, ОжиданиеЗапроса, requestTimeout, ExecDate, OtherRQ, DocKind, DealID, PFI);
      end;
    // Если исполняется отложенное закрывающее ТО
    elif( (Action == DEALCALC_ACTION_EXECLONGPAY) or (Action == DEALCALC_ACTION_EXECLONGSET) )
      if( ((planDate <= CurrRQ.rec.PlanDate) and (OtherRQ.rec.State != DLRQ_STATE_PLAN)) OR (OtherRQ.rec.State == DLRQ_STATE_EXEC) )
        ОбработкаИсполненияОтложенногоЗакрывающегоТО(FD, ОжиданиеЗапроса, requestTimeout, ExecDate, OtherRQ, DocKind, DealID, PFI);
      end;
    // Если выполняется перенос на просрочку оплаты/поставки
    elif( (Action == DEALCALC_ACTION_OVERDUE_PAY) or (Action == DEALCALC_ACTION_OVERDUE_SET) )
      // Если перенесится на просрочку закрывающее ТО
      if( ((planDate <= CurrRQ.rec.PlanDate) AND (OtherRQ.rec.State != DLRQ_STATE_PLAN)) OR (OtherRQ.rec.State == DLRQ_STATE_EXEC) )
        ОбработкаПросроченногоЗакрывающегоТО(FD, ОжиданиеЗапроса, requestTimeout, ExecDate, DocKind, DealID, PFI);
      end;
    // Если откладывается оплата/поставка
    elif( (Action == DEALCALC_ACTION_LONGPAY) OR (Action == DEALCALC_ACTION_LONGSET) ) 
      // Если откладывается закрывающее ТО
      if( ((planDate <= CurrRQ.rec.PlanDate) and (OtherRQ.rec.State != DLRQ_STATE_PLAN)) OR (OtherRQ.rec.State == DLRQ_STATE_EXEC) )
        ОбработкаОтложенногоЗакрывающегоТО(FD, ОжиданиеЗапроса, requestTimeout, ExecDate, DocKind, DealID, PFI);
      end;
    end;

    return 0;
end;

/*Выполнение операции */
private macro ExecuteStep( doc, FDoc, DocKind, ID_Op, ID_Step )

  var FD, i, Action = SpChangeDates.Action, FactDate = SpChangeDates.FactDate, ExecDate = SpChangeDates.ExecDate, 
      ChangeFromCliring = false, ChangePayment = false;

  if( ExecDate == ZeroDate )
     ExecDate = FactDate;
  end; 

  if( Action <= 0 )
     msgbox("Шаг изменения сроков исполнения из списка шагов выполнять запрещено"); 
     return 1;
  end; 

  SetBuff( tick, FDoc ); 
  /*Не должно быть выполненных шагов с более поздней планируемой датой*/
  if( (FactDate != Date(0,0,0)) AND (FactDate < SP_GetMaxPlanStepDate(ID_Op, FactDate)) )
     msgbox("Есть выполненные шаги с планируемой датой больше|чем дата операции изменения сроков исполнения.|Запрещено выполнять операцию."); 
     return 1;
  end;

  FD = SPFirstDoc( tick, (SpChangeDates.IsBack == SET_CHAR) );

  if( tick.BofficeKind == DL_RETIREMENT )

     if( SpChangeDates.Action == DEALCALC_ACTION_BEFORE_PAY )
        if( FD.DateArray[DATE_DEALPAY] == FactDate )
            msgbox("Даты шагов \"Исполнение обязательств\" и \Досрочное зачисление\"|не должны быть равны.");
            return 1;
        end;
     end;
     
     if( ИзменитьСрокиИсполнения_ДляПогашения( FD, Action, doc, ID_Op, FactDate ) != 0 )
        return 1;
     end;
  else
     /* IL 20.07.04 суммы в ТО не изменяем SCR 57024*/
     /* SCR 61870 изменяем сумму в ТО при доср./проср. поставке если она выполняется 
        до постановки на баланс*/
     if( ( (Action == DEALCALC_ACTION_BEFORE_SET) OR /*досрочная поставка*/
           ((Action == DEALCALC_ACTION_EXECLONGSET) and not (IsREPO(FD.Group) and IsEXCHANGE(FD.Group))) /*Исполнение отложенной поставки. В РЕПО ОРЦБ на это действие навешено отложенное исполнение 2ч*/
         ) AND
         ( FD.dl_leg.rec.OperState < DL_LEG_BALANCE )
       )
        ChangePayment = true;
     end;

     if( SpChangeDates.FromCliring AND 
         ( (FD.dl_leg.rec.Price     != SpChangeDlLegBack.Price)  OR
           (FD.dl_leg.rec.Cost      != SpChangeDlLegBack.Cost)   OR
           (FD.dl_leg.rec.NKD       != SpChangeDlLegBack.NKD)    OR 
           (FD.dl_leg.rec.TotalCost != SpChangeDlLegBack.TotalCost)
         )
       )
        ChangeFromCliring = true;
     end;

     // для отложенного исполнения нужно скорректировать соотв. плановые даты в сделке.
     if( Action == DEALCALC_ACTION_LONGPAY ) /*Отложенные аванс/оплата*/
        if( FD.IsBack)
           if( SpChangeDlLegBack.MaturityIsPrincipal )
              SpChangeDlLegBack.Expiry = ExecDate;
           else
              SpChangeDlLegBack.Maturity = ExecDate;
           end;

           if(FD.ExistAvance)
              SpChangeDlLegBack.Start = ExecDate;
           end;
        else
           if( SpChangeDlLeg.MaturityIsPrincipal )
              SpChangeDlLeg.Expiry = ExecDate;
           else
              SpChangeDlLeg.Maturity = ExecDate;
           end;

           if(FD.ExistAvance)
              SpChangeDlLeg.Start = ExecDate;
           end;
        end;
     elif( Action == DEALCALC_ACTION_LONGSET ) /*Отложенная поставка*/
        if( FD.IsBack)
           if( SpChangeDlLegBack.MaturityIsPrincipal )
              SpChangeDlLegBack.Maturity = ExecDate;
           else
              SpChangeDlLegBack.Expiry = ExecDate;
           end;
        else
           if( SpChangeDlLeg.MaturityIsPrincipal )
              SpChangeDlLeg.Maturity = ExecDate;
           else
              SpChangeDlLeg.Expiry = ExecDate;
           end;
        end;
     elif(Action == DEALCALC_ACTION_LONGCALCDVP)
        SpChangeDlLeg.Maturity = date(31,12,9999);
        SpChangeDlLeg.Expiry   = date(31,12,9999);
     end;

     var requestTimeout = 0, BOfficeKind = 0, DealID = 0, PFI = -1;
     var ОжиданиеЗапроса = false;
     if( ПРОВЕРКА_РЕПОЗИТАРНЫХ_ПАРАМЕТРОВ(FD.tick, @ОжиданиеЗапроса, @requestTimeout, @DocKind, @DealID, @PFI ) )
       if( IsREPO(FD.Group) )
         if( ВставитьДействиеИзменениеСостоянияОбязательствДляРепо( FD, Action, FactDate, ExecDate, ОжиданиеЗапроса, requestTimeout ) != 0 )
          return 1;
       end;
       else
         if( ВставитьДействиеИзменениеСостоянияОбязательствВнебиржи( FD, Action, FactDate, ExecDate, ОжиданиеЗапроса, requestTimeout, DocKind, DealID, PFI ) != 0 )
            return 1;
         end;
       end;
     end;

 /*kd*/
     if(FD.ExistsRQ(4) AND (FD.tick.rec.ReturnIncomeKind != SP_RETURNINCOME_PAYMENT))
        var rq_conv = $0;
        SmartConvertSum(rq_conv, FD.GetRQ(4).rec.amount, FactDate, FD.GetRQ(4).rec.FIID, SpChangeDlLegBack.CFI, false);
        SpChangeDlLegBack.returnincome = abs(SpChangeDlLegBack.returnincome - rq_conv);
     end;

     if( СохранитьИзмененияПоСделке( FactDate, FD, SpChangeDlLeg, SpChangeDlLegBack, ChangePayment, NULL, ChangeFromCliring ) == false ) 
        return 1;
     end;  

     if( ИзменитьСрокиИсполнения_ДляСделки( FD, Action, doc, ID_Op, FactDate, null, ExecDate ) != 0 )
        return 1;
     end;
     
     if(FD.SaveChangedRQ(FactDate) != 0)
        return 1;
     end;

     if( (IsREPO(FD.Group)) and (not FD.IsBack))
        //могло измениться ТО по процентам 2-й части РЕПО
        if((FD.ExistsRQ(DLRQ_TYPE_INCREPO, 2)) and (FD.RQIsChanged(DLRQ_TYPE_INCREPO, 2)))
          if(DL_ChangeDLRQ(FD.GetRQ(DLRQ_TYPE_INCREPO, 2), FactDate, DLRQ_ACTION_UPDATE) != 0)
            return 1;
          end;
        end;
     end;
  end;

  /*Перепланировка дат*/
  i = 0;
  while( i < ChangeDates.Size )
     if( not OprReplanStepPlanDates( ChangeDates[i].KindDate, ChangeDates[i].StepDate, ChangeDates[i].UpdateOnlyStepDate ) )
        msgbox("Ошибка при попытке переинициализировать дату " );         
        return 1;
     end;
     i = i + 1;
  end;

  return 0;
end;
