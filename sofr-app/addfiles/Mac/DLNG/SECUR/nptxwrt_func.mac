/**
 @file      nptxwrt_func.mac
 @brief     Утилиты для операции зачисления/списания ДС

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |13.08.2025 |Велигжанин А.В.|DEF-97930                                       |Ограничение по длине назначения платежа в 210 символов
 |17.01.2025 |Велигжанин А.В.|BOSS-6391_BOSS-7438                             |GetGroundOfPayMedical(), для основания платежа по выводу ДС
 |           |               |                                                |на лечение по ИИС-3

*/
import RSD, oralib, likepy, globals, DealsInter, "cblogger2.mac", "NotesCommonClass.mac", oprinter;

PRIVATE CONST OBJTYPE_WRTMONEY = 131;
PRIVATE CONST NOTEKIND_REASON_OF_STOP_RUN_OPER = 1;

PRIVATE CONST C_CATEGORY_UNLOADED_TO_QUIK       = 101;  //Категория "Корректировка выгружена в файл"
PRIVATE CONST C_CATEGORY_ALLOWED_INCOME         = 103;  //Категория "Разрешено зачисление"

PRIVATE CONST C_NOTEKIND_UNLOADED_TO_QUIK       = 101;  //Примечание "Признак выгрузки корректировки в файл"
PRIVATE CONST NOTEKIND_REJECT_REASON            = 103;  //Примечание "Отметка об отказе в исполнении"
PRIVATE CONST NOTEKIND_IS_ALLOWED_INCOME        = 104;  //Примечание "Разрешено зачисление"
PRIVATE CONST C_NOTEKIND_QUIK_INSTR_PROC_RESULT = 105;  //Примечание "Результат обработки неторгового поручения в QUIK"

class c_categ(operID:integer)
  private var allowedValue:bool = null;
  private var unloadedToQUIKValue:bool = null;
  private var logger:c_logger;
  private var objectID = "";

  private macro SetCategory(groupID:integer, attrID:integer, dt:date):bool
    var params = MakeArray(SqlParam("p_object_type", OBJTYPE_WRTMONEY),
                           SqlParam("p_group_id",    groupID),
                           SqlParam("p_object",      objectID),
                           SqlParam("p_attr_id",     attrID),
                           SqlParam("p_date",        dt));
    ExecStoredFunc("categ_utils.save_categ", V_UNDEF, params);
    return true;
  OnError(err)
    logger.ErrorClob("SetCategory. objectID = " + objectID + "; groupID = " + groupID, GetFullErrMsg(err));
    return false;
  end;

  //возвращает ИД атрибута - attr_id
  private macro GetCategory(groupID:integer, dt:date):integer
    var params = MakeArray(SqlParam("p_object_type", OBJTYPE_WRTMONEY),
                           SqlParam("p_group_id",    groupID),
                           SqlParam("p_object",      objectID),
                           SqlParam("p_date",        dt));
    var attrID = ExecStoredFunc("categ_read.get_attr_id", V_INTEGER, params);
    if (valtype(attrID) == 26)
      return 0;
    end;
    return attrID;
  OnError(err)
    logger.ErrorClob("GetCategory. objectID = " + objectID + "; groupID = " + groupID, GetFullErrMsg(err));
    return 0;
  end;

  private macro Init(operID:integer)
    logger = NewLogger(c_logger.IT_LOG_TYPE, "NPTXWRT_FUNC.MAC.C_CATEG");
    objectID = string(operID:34:o);
  end;

  macro Allowed():bool
    var attrID:integer;
    if (allowedValue == null)
      attrID = GetCategory(C_CATEGORY_ALLOWED_INCOME, {curdate});
      allowedValue = attrID != 2; // запрещаем только если = нет. Если не указано, то разрешаем
    end;

    return allowedValue;
  end;

  macro SetAllowed(value:bool):bool
    if (value == allowedValue)
      return true;
    end;

    allowedValue = null;

    var attrid = ifThenElse(value, 1, 2);
    return SetCategory(C_CATEGORY_ALLOWED_INCOME, attrid, {curdate});
  end;

  macro UnloadedToQUIK():bool
    var attrID:integer;
    if (unloadedToQUIKValue == null)
      attrID = GetCategory(C_CATEGORY_UNLOADED_TO_QUIK, {curdate});
      unloadedToQUIKValue = attrID == 1;
    end;

    return unloadedToQUIKValue;
  end;

  macro SetUnloadedToQUIK()
    if (not unloadedToQUIKValue)
      unloadedToQUIKValue = null;
      SetCategory(C_CATEGORY_UNLOADED_TO_QUIK, 1, {curdate});
    end;
  end;

  Init(operID);
end;

class (NotesCommonClass) c_notes(nptxopID:integer)
  private var noteKindReject;
  private var rejectValue = "";

  private macro GetSubKind(nptxopID:integer):integer
    var query = "select t_subkind_operation "
              + "  from dnptxop_dbt "
              + " where t_id = :id ";
    var sql = ExecSQLselectPrmDyn(query, nptxopID);
    if (sql.MoveNext() )
      return sql.value("t_subkind_operation");
    end;
    return 0;
  end;

  private macro Init (nptxopID:integer)
    logger = NewLogger(c_logger.IT_LOG_TYPE, "NPTXWRT_FUNC.MAC.C_NOTES");
    documentID = string(nptxopID:34:o);
    objecttype = OBJTYPE_WRTMONEY;
    var subKind = GetSubKind(nptxopID);

    if (subKind == DL_NPTXOP_WRTKIND_ENROL) 
      noteKindReject = NOTEKIND_REASON_OF_STOP_RUN_OPER;
    else
      noteKindReject = NOTEKIND_REJECT_REASON;
    end;

    rejectValue = GetNote(noteKindReject);
  end;

  macro SaveReject(value:string):bool
    if (rejectValue == value)
      return true;
    end;

    rejectValue = value;

    return SaveNote(noteKindReject, value, {curdate});
  end;

  macro GetRejectValue():string
    return rejectValue;
  end;

  macro SaveQUIKResult(value:string):bool
    return SaveNote(C_NOTEKIND_QUIK_INSTR_PROC_RESULT, value, {curdate});
  end;

  macro SaveUnloadedToQUIKSign():bool
    return SaveNote(C_NOTEKIND_UNLOADED_TO_QUIK, "Поручение отправлено в QUIK", {curdate});
  end;

  macro SaveIsAllowedEnroll(value:string):bool
    return SaveNote(NOTEKIND_IS_ALLOWED_INCOME, value, {curdate});
  end;

  Init(nptxopID);
end;

 
/// Момент расчета остатков для лимитов (Тост)
macro TOST(p_edp,p_derivat,p_forex,p_limitCalcEndTime:numeric)
var result = null;
if (p_limitCalcEndTime > 0) // Найдено в лимитах
    var sql = 
  " with calcsp as " +
  "  (select first_value(t.t_calcdate) over(order by t.t_startdt desc) fv " +
  "         ,RANK() over(order by t.t_startdt desc) rec " +
  "         ,t.t_calcdate,t.T_CALC_DIRECT " +
  "     from DDL_LIMITOP_DBT t " +
  "    where t.t_startdt > sysdate - 10 " + // берем расчеты за последние 10 дней
  "      and t.t_status = 'DONE' " +
  "    order by t.t_startdt desc) " +
  " select t_startdt,t_calc_direct " +
  " from ( select t.t_startdt " +
  "       ,to_number(to_char(t.t_calcdate, 'YYYYMMDD')) + to_number(to_char(t.t_startdt, 'HH24miSS')) / 1000000 bdt " +
  "       ,to_number(to_char(t.t_calcdate, 'YYYYMMDD')) + to_number(to_char(t.t_statusdt, 'HH24miSS')) / 1000000 edt " +
  "       ,t.t_calc_direct " +
  "   from DDL_LIMITOP_DBT t " +
  "  where t.t_calc_direct in (select T_CALC_DIRECT from calcsp where rec < (select min(rec) from calcsp where fv != t_calcDate)) " +
  " ) where :p_limitCalcEndTime between bdt and edt " ;

    var cmd = RSDCommand(sql);

    cmd.AddParam(":p_limitCalcEndTime",RSDBP_IN,p_limitCalcEndTime);
    var rs = RSDRecordSet(cmd);
    if (rs.moveNext)
      result = rs.value(0);
    end;
end;
return result;
end;

/// ВремяОкончанияРасчетаЛимита
macro LimitCalcEndTime(nptxop_id,o_LimitCalcEndTime:@numeric)
  var sql = 
"select NVL(max(to_number(to_char(lcs.t_date, 'YYYYMMDD')) +  " +
"           to_number(to_char(lcs.t_time, 'HH24miSS')) / 1000000),0) " +
"  from ddl_limitcashstock_dbt lcs " +
" where lcs.t_internalaccount in " +
"       (select prov.t_accountid_receiver " +
"          from doproper_dbt op " +
"         inner join doprdocs_dbt priv " +
"            on op.t_id_operation = priv.t_id_operation " +
"           and op.t_dockind = 4607 " +
"           and op.t_kind_operation = 2037 " +
"           and op.t_documentid = lpad(:nptxop_id,34,'0') " +
"         inner join dacctrn_dbt prov " +
"            on priv.t_acctrnid = prov.t_acctrnid " +
"           and prov.t_chapter = 1 " +
"           and prov.t_State = 1) ";
  var cmd = RSDCommand(sql);
  cmd.AddParam(":p_nptxop_id",RSDBP_IN,nptxop_id);
  var rs = RSDRecordSet(cmd);
  if (rs.moveNext)
    o_LimitCalcEndTime = rs.value(0);
  end;
end;

/// определить ЕДП, Срочный, Валютный рынки
macro getMarketConditions(nptxop_id,o_isEDP:@numeric,o_isDerivat:@numeric,o_isForex:@numeric)
  var sql =
"select mp.t_marketid, " +
"       sfc_s.t_servkind, " +
"       rshb_rsi_sclimit.SfcontrIsEDP(sfc_s.t_id) isEdp " +
"  from dnptxop_dbt    nt, " +
"       ddlcontrmp_dbt mp, " +
"       dsfcontr_dbt   sfc_s, " +
"       ddlcontr_dbt   dlc, " +
"       dsfcontr_dbt   sfc " +
" where 1 = 1 " +
"   AND dlc.t_sfcontrid = sfc.t_id " +
"   AND mp.t_dlcontrid = dlc.t_dlcontrid " +
"   AND nt.t_DocKind = 4607 " +
"   AND nt.t_contract = sfc_s.t_id " +
"   AND sfc_s.t_id = mp.t_sfcontrid " +
"   AND nt.t_id = :p_nptxop_id " +
"   AND nt.t_subkind_operation = 10 " +
"   AND sfc_s.t_servkindsub = 8 ";
  var cmd = RSDCommand(sql);
  cmd.AddParam(":p_nptxop_id",RSDBP_IN,nptxop_id);
  var rs = RSDRecordSet(cmd);
  if (rs.moveNext)
    o_isEDP = rs.value("isEdp");
    if (rs.value("t_servkind")==15)
      o_isDerivat = 1; 
      o_isForex = 0;
    elif(rs.value("t_servkind")==21)
      o_isDerivat = 0; 
      o_isForex = 1;
    else
      o_isDerivat = 0; 
      o_isForex = 0;
    end;
  end;
end;

/// Момент расчета остатков для лимитов (Тост) 
macro TPROV(nptxop_id, sys_dt_prov:@date, sys_dt_time:@time, dt_carry:@date)
 var sql = 
" select " +
"    prov.t_date_carry,  " + //-- дата операционного дня, в котором сделана проводка,
"    prov.t_systemdate, prov.t_systemtime  " + //---физическое дата/время формирования проводки
" from  " +
"    doproper_dbt op  " + 
"    inner join doprdocs_dbt priv  " + 
"      on op.t_documentid =lpad(:p_nptxop_id,34,'0')  " + 
"      and op.t_dockind = 4607 and op.t_id_operation = priv.t_id_operation " +
"      and  op.t_kind_operation = 2037  " + 
"    inner join dacctrn_dbt prov  " + 
"      on priv.t_acctrnid = prov.t_acctrnid  " + 
"      and prov.t_chapter = 1 and prov.t_State =1;  ";
  var cmd = RSDCommand(sql);
  cmd.AddParam(":p_nptxop_id",RSDBP_IN,nptxop_id);
  var rs = RSDRecordSet(cmd);
  if (rs.moveNext)
    sys_dt_prov = rs.value("t_systemdate"); 
    sys_dt_time = rs.value("t_systemtime");
    dt_carry = rs.value("t_date_carry");
  end;
end;

macro GetAccRest(account:string, fiid:integer, dt:date):money
  var params = TArray();
  params(params.size) = SqlParam("p_account", account);
  params(params.size) = SqlParam("p_chapter", 1);
  params(params.size) = SqlParam("p_cur",     fiid);
  params(params.size) = SqlParam("p_date",    dt);

  var rest:money = ExecStoredFunc("rsi_rsb_account.restall", V_MONEY, params);
  if (valtype(rest) == 26) 
    rest = 0;
  end;
   
  return rest;
End;

// Раннее время когда операция по зачислению могла попасть в лимиты
macro  GetDT306Limit_dy_nptxop(nptxop_id)
  var result = null;

  var sql = 
    " select DT306Limit from ( select rshb_limit_util.GetDT306Limit_dy_nptxop(:p_nptxop_id) DT306Limit  from dual)"+
    " where DT306Limit is not null";
  var cmd = RSDCommand(sql);
  cmd.AddParam(":p_nptxop_id",RSDBP_IN,nptxop_id);
  var rs = RSDRecordSet(cmd);
  if (rs.moveNext)
    result = rs.value("DT306Limit"); 
   end;
  return  result ;
End;

//Является ли субдоговор биржевым
macro isSubcontrExchange(subcontrID:integer):bool
  return (ExecStoredFunc("sfcontr_read.is_subcontr_exchange", V_INTEGER, MakeArray(SqlParam("p_sfcontr_id", subcontrID))) == 1);
end;

//Проверяет, привязан ли счёт хотя-бы к одному биржевому субдоговору
macro isExchangeAccount(account:string, dt:date):bool
  var query = "select 1 "
            + "  from dmcaccdoc_dbt m "
            + " where m.t_catid = 70 "
            + "   and m.t_dockind = 3001 "
            + "   and m.t_account = :account "
            + "   and m.t_activatedate <= :dt1 "
            + "   and (m.t_disablingdate > :dt2 or m.t_disablingdate = to_date('01.01.0001', 'dd.mm.yyyy')) "
            + "   and sfcontr_read.is_subcontr_exchange(p_sfcontr_id => m.t_clientcontrid) = 1 ";
  var sql = ExecSQLselectPrmDyn(query, account, dt, dt);
  return sql.MoveNext();
end;

/**
  @brief    			Функция возвращает основание проводки по выводу ДС на лечение по ИИС-3
                                Основание проводки берется из примечания. Если примечания нет, используется p_DefGround

  @param[in]   p_ID		Идентификатор операции
  @param[in]   p_DefGround	Основание проводки по умолчанию
*/
macro GetGroundOfPayMedical( p_ID: integer, p_DefGround: string ) : string
  var OperID = string(p_ID:34:o);
  var notes = RsbObjNotes(OBJTYPE_WRTMONEY, OperID);
  var ground = notes.ReadNote(108, {curdate});
  if(ground == "")
    ground = p_DefGround;
  end;
  return SubStr(ground,1,210); // DEF-97930 Ограничение по длине назначения платежа в 210 символов
OnError(err)
  return SubStr(p_DefGround,1,210); // DEF-97930 Ограничение по длине назначения платежа в 210 символов
end;

macro ЕстьНеисполненнаяПорожденнаяОперацияНОБ(ID, NumberOp:@STRING)
  var query =   "SELECT op.t_Code code "
              + "  FROM doproper_dbt opr, doprdocs_dbt odoc, dnptxop_dbt op "
              + " WHERE opr.t_dockind = " + DL_WRTMONEY
              + "   AND opr.t_DocumentID = LPAD (:id, 34, '0') "
              + "   AND odoc.t_ID_Operation = opr.t_ID_Operation "
              + "   AND odoc.t_DocKind = 4752 " /*DL_INSERT_NPTXOP*/
              + "   AND op.t_ID = TO_NUMBER(odoc.t_DocumentID) "
              + "   AND op.t_DocKind = " + DL_CALCNDFL
              + "   AND op.t_Status <>  " + DL_TXOP_Close;
  var sql = ExecSQLselectPrmDyn(query, ID);

  if(sql.moveNext())
    NumberOp = sql.value("code");
    return true;
  end;

  return false;
end;