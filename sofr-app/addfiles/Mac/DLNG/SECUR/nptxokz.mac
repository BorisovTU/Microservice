/*
$Name:        nptxctrl.mac
$Module:      Ценные бумаги
$Description: Отчет "Контроль задолженности"
*/
import "nptxokz_form.mac","sprepfun.mac", "sqlconv.mac", "CbReport_h.mac", "scsrvrepfun.mac", "xls_parser.mac", "poisimplerepo.mac", "partysql.mac", "nptxstbfun.mac";

PRIVATE CLASS (DL_CReportTemplate) Sp_NPTXCTRL_Report(OperDate, Year, Dbeg, Dend, IsCurBrocAcc, IsActiveClient, FromSOFR, FromDEPO, ByChanges, ChBegDate, ChEndDate, IsLoadFromFile, FilePath, FileContentType, ListWithAcc, ProtObj)
  private var  jvm = CreateObject("rsjvm", "TJavaHost", "GlobalJavaHost");
  var m_Nrec = 0;
  var m_Data, m_Query;
  var m_OperDate        = OperDate;      
  var m_Year            = Year;          
  var m_Dbeg            = Dbeg;          
  var m_Dend            = Dend;          
  var m_IsCurBrocAcc    = IsCurBrocAcc;  
  var m_IsActiveClient  = IsActiveClient;
  var m_FromSOFR        = FromSOFR;
  var m_FromDEPO        = FromDEPO;
  var m_ByChanges       = ByChanges;
  var m_ChBegDate       = ChBegDate;
  var m_ChEndDate       = ChEndDate;
  var m_IsLoadFromFile  = IsLoadFromFile;
  var m_FilePath        = FilePath;
  var m_FileContentType = FileContentType;
  var m_ListWithAcc     = ListWithAcc;
  
  var m_MinRateResident:integer = 0;  //Минимальная ставка по резиденту. Определяется по шаблону DNPTXTEMPLATEOKZ_DBT
  var m_MinRateNoResident:integer = 0;//Минимальная ставка по не резиденту. Определяется по шаблону DNPTXTEMPLATEOKZ_DBT
  var m_CurrSheetName = "Контроль (разернутый)";

  class cRateSudKBK(_rate, _sud, _kbk, _index)
    var Rate = _rate;
    var SUD  = _sud;
    var KBK  = _kbk;
    var index = _index;
  end;
  
  class ObjSNOB(_name:string, _arrdata:TArray)
    var Name = _name;
    var ArrData  = _arrdata;
  end;
  
  class cBorderPrm(_BegRow, _BegCol, _EndRow, _EndCol, _Name, 
                   _LeftBr,   _StyleLeft, 
                   _RightBr,  _StyleRight, 
                   _TopBr,    _StyleTop, 
                   _BottomBr, _StyleBottom,
                   _BgColor)
    var BegRow  = _BegRow;
    var BegCol  = _BegCol;
    var EndRow  = _EndRow;
    var EndCol  = _EndCol;
    var Name    = _Name;
    var LeftBr  = _LeftBr;
    var StyleLeft     = _StyleLeft;
    var RightBr       = _RightBr;
    var StyleRight    = _StyleRight;
    var TopBr         = _TopBr;
    var StyleTop      = _StyleTop;
    var BottomBr      = _BottomBr;
    var StyleBottom   = _StyleBottom;
    var BgColor       = _BgColor;
  end;
  
  class cNameDiapazon(_name:string, _diapazon:string)
    var Name = _name;
    var Diapazon  = _diapazon;
  end;
 
  class objProtocolErr(_IDSOFR, _IDCFT, _FIO, _Comment)
    var IDSOFR = _IDSOFR;
    var IDCFT  = _IDCFT;
    var FIO    = _FIO;
    var Comment = _Comment;
  end;
 
  var m_ArrSNOB    = TArray();//Массив для структуры шаблона DNPTXTEMPLATEOKZ_DBT (развернутый)
  var m_ArrRateKBK = TArray();//Массив для структуры шаблона DNPTXTEMPLATEOKZ_DBT (сводный)
  var m_ArrNumCol  = TArray();//Номера использованных столбцов 
  var m_ArrBorderPrm = TArray();//Массив ячеек для оформления границ, шрифтов, цвета и т.д.

  var m_ArrTableStruct = TArray();//Массив для структуры данных таблицы (имена ячеек)
  var m_ArrDataRow = TArray();//Массив данных строки для печати
  var m_ArrDataRowSvod = TArray();//Массив данных строки для печати (сводный)
  var m_ArrDataSvod = TArray();//Массив данных всех строк для печати (сводный)
  var m_UserRegNameDiapazon = TArray();//Пользовательские имена для диапазонов (нужны для корректной работы функций)
  var m_ArrProtocolErr = TArray();//Протокол ошибок objProtocolErr
  var m_simpleRepo = ProtObj;

  var m_show_protocol = false;

  PRIVATE MACRO addProtocolErr(_IDSOFR, _IDCFT, _FIO, _Comment)
    m_ArrProtocolErr[m_ArrProtocolErr.size] = objProtocolErr(_IDSOFR, _IDCFT, _FIO, _Comment)
  END;

  PRIVATE MACRO getIndexBorderByName(_Name)
    var i = 1;
    while( i < m_ArrBorderPrm.size )
      if(m_ArrBorderPrm[i].Name == _Name)
        return i;
      end;
      i = i + 1;
    end;
    return 0;
  END;

  PRIVATE MACRO regNameDiapazon(_Name, _Diapozon)//Добавление пользовательского имени для диапазона в шаблоне (нужно для корректной работы функций)
    var wobook = m_ObjTemplateXLS.GetWorkbook().getCurrentWorkbook();
    var wbName = wobook.{createName@()Lorg/apache/poi/ss/usermodel/Name;}();
        wbName.setNameName(_Name);
        wbName.setRefersToFormula(_Diapozon);
    m_UserRegNameDiapazon[m_UserRegNameDiapazon.size] = cNameDiapazon(_Name, _Diapozon);
  END;

  MACRO RegisterTableArr()
    var i = 0, Name = IIF(m_CurrSheetName == "Контроль (разернутый)", "H0_MainTable", "H1_MainTable"); 
    var strArr = StrSplit2(m_ArrTableStruct[m_ArrTableStruct.size-1], 1);
    var Address = "$", firstNumber = false;

    while(i < strArr.size)
      if(StrIsNumber(strArr[i]) and (firstNumber == false))
        Address = Address + "$";
        firstNumber = true;
      end;
      Address = Address + strArr[i];
      i = i + 1;
    end;
  
    regNameDiapazon(Name, "'"+m_CurrSheetName+"'!$A$11:"+Address);

    m_ReportLineCellNames.Size = 0;
    i = 0;
    while( i < m_ArrTableStruct.size )
      m_ReportLineCellNames[m_ReportLineCellNames.Size] = m_ArrTableStruct[i];
      i = i + 1;
    end;
    InitTable( Name, NULL );
  END;

  MACRO addDataToArr()
    var i = 1, CellVal;
     
    while( GetParm( i, CellVal) )
      m_ArrDataRow[m_ArrDataRow.size] = CellVal;
      i = i + 1;
    end;
  END;

  MACRO addDataToArrSvod()
    var i = 1, CellVal;
     
    while( GetParm( i, CellVal) )
      m_ArrDataRowSvod[m_ArrDataRowSvod.size] = CellVal;
      i = i + 1;
    end;
  END;

  MACRO PrintTableLineArr()
     VAR i = 0, CellName, CellValue, CellPoint = NULL, CellFormat, FldNumber, CurFldNumber = 0;

     if(m_ArrDataRow.size != m_ArrTableStruct.size)
       MsgBox("Количество столбцов в структуре не соответствует количеству значений");
     end;

     if( m_UseTemplate )
        if( m_UseCSV == true )
           var v_SetCellFormat = GetGlobalParameter("SetCellFormat", true);
           if(valtype(v_SetCellFormat) != V_BOOL)
             v_SetCellFormat = true;
           end;
           while( i < m_ArrDataRow.size )
              CellName = m_ArrTableStruct[i];
              CellValue = m_ArrDataRow[i];
              SplitCellName( CellName, @CellName, null, false );

              FldNumber = NC( CellName );
              while( CurFldNumber < FldNumber )
                 m_CSVFile.AddCell(null);
                 CurFldNumber = CurFldNumber + 1;
              end;

              if( CellValue == "" )
                 CellValue = null;
              end;

              m_CSVFile.AddCell( CorrectNumberStr( CellValue ), CellPoint );

              if(v_SetCellFormat)
                SetCellFormat( FldNumber, CellValue, CellPoint );
              end;

              CurFldNumber = CurFldNumber + 1;
              CellValue = NULL;
              i = i + 1;
           end;

           while( CurFldNumber < m_ReportLineCellNames.Size )
              m_CSVFile.AddCell(null);
              CurFldNumber = CurFldNumber + 1;
           end;
        else
           while( i < m_ArrDataRow.size )
              CellName = m_ArrTableStruct[i];
              CellValue = m_ArrDataRow[i];
              if( CellName != NULL )
                 SplitCellName( CellName, @CellName, null, false );
                 m_ReportTable.SetValueCell( CellName , CellValue );
                 CellValue = NULL;
              end;
              i = i + 1;
           end;
        end;
     end;

     this.FinishLine();
  END;

  /*задать номера ячеек, по которым будет вычисляться сумма при добавлении в основную таблицу отчета*/
  MACRO SetCellAutoSummaArr( ItogLineName:STRING)
     var i = IIF(m_CurrSheetName == "Контроль (разернутый)", 8, 7), CellName, FldNumber, j = 0;

     SetCellAutoSumma(); // из базового класса
     m_ItogLineName = ItogLineName;

     if( m_UseTemplate )
        while(i < m_ArrTableStruct.size)
           m_NumCellAutoSumm[ j ] = m_ArrTableStruct[i]; /*номер полей с автосуммой*/
           i = i + 1;
           j = j + 1;
        end;
     else
        while(i < m_ArrTableStruct.size)
           FldNumber = NC( m_ArrTableStruct[i] );
           m_ObjWinRep.m_NumCellAutoSumm[FldNumber] = true; /*номер полей с автосуммой*/
           m_ObjWinRep.m_ValueAutoSumm[FldNumber]   = 0;
           i = i + 1;
        end;
     end;
  END;

  private macro CheckServIsGood(sofrId)
    var oldDialog = SetDialogFlag(0);
    var query = 
       "  select c2.T_PARTYID " +
       "    from dclient_dbt c2 " +
       "   where c2.T_PARTYID = ? " +
       "     and c2.t_servicekind in("+PTSK_STOCKDL+","+PTSK_DV+","+PTSK_DEPOS+","+PTSK_SVO+") ";
    var cmd = DL_RSDCommand(query);
    cmd.addParam( sofrId );
    var ds = cmd.Execute();
    SetDialogFlag(oldDialog);
    if (ds.moveNext())
      return true;
    end;
    return false;
  OnError(er)
    SetDialogFlag(oldDialog);
    return false;
  end;

  private macro CheckSofrId(sofrId)
    var oldDialog = SetDialogFlag(0);
    var query = 
       " select party.T_PARTYID " +
       "   from dparty_dbt party " +
       "  where party.T_LEGALFORM = " + legal_form_phys +
       "     and party.T_PARTYID = ? ";
    var cmd = DL_RSDCommand(query);
    cmd.addParam( sofrId );
    var ds = cmd.Execute();
    SetDialogFlag(oldDialog);
    if (ds.moveNext())
      return true;
    end;
    return false;
  OnError(er)
    SetDialogFlag(oldDialog);
    return false;
  end;

  private macro PrintProtLine(SofrID, CftID, ProtValue)
    m_show_protocol = true;
    if (SofrID <= 0)
      SofrID = GetSofrIDFromCftId(CftID);
    end;
    if (Trim(CftID) == "")
      CftID = GetCftIDFromSofrID(SofrID);
    end;
    m_simpleRepo.PrintLine(SofrID, CftID, ProtValue);
  end;

  macro GetClientFilterCount()
    var ds = execSQLselect("SELECT COUNT (*) FROM DNPTXCTRLCLNT_TMP", TArray(), true);
    if (ds.MoveNext())
      return SQL_ConvTypeInteger(ds.value(0));
    end;
  end;

  private Macro GetClientFilterQuery(selfAlias)
    if (m_IsLoadFromFile or (GetClientFilterCount() > 0))
      return "IN (SELECT T_CLIENTID FROM DNPTXCTRLCLNT_TMP)";
    else
      return " = " + selfAlias; 
    end;
  end;

  private macro SetDataExists(clientId)
    execSql ("update DNPTXCTRLCLNT_TMP set T_DATAEXISTS = chr(88) where T_CLIENTID = " + clientId);
  end;

  PRIVATE MACRO GetQuery(IsIIS, IsNotIIS, RetParmArr:@TArray)
    /*Отбираются инвестор(инвесторы), которые являются физическими лицами и клиенты с видом обслуживания "Фондовый дилинг", "Срочные контракты" или "Депозитарное обслуживание",
      для которых существуют операции расчета НОБ с датой, входящей в период от начала года по отчетную дату включительно.*/
    var Year = 0;

    if(m_Dend == date(31,12,2022))
      datesplit(m_Dend, null, null, Year);
    end;

    private macro AddRetParm(Parm)
      var retStr = "?";

      if(ValType(RetParmArr) != V_UNDEF)
        RetParmArr[RetParmArr.size] = Parm;
      else
        if(ValType(Parm) == V_DATE)
          retStr = GetSQlDate(Parm);
        else
          retStr = string(Parm);
        end;
      end;

      return retStr;
    end;

    var Query = "with cl as (select party.T_PARTYID, party.T_ShortName " +
                "              from dparty_dbt party " +
                "             where party.T_LEGALFORM = " + legal_form_phys +
                "               and exists ( select c2.T_PARTYID " +
                "                              from dclient_dbt c2 " +
                "                             where c2.T_PARTYID = party.T_PARTYID " +
                "                               and c2.t_servicekind in("+PTSK_STOCKDL+","+PTSK_DV+","+PTSK_DEPOS+","+PTSK_SVO+") " +
                "                          ) ";

    if(m_ByChanges == SET_CHAR)
      Query = Query + 
                             "  and ( exists ( select 1 " 
                           + "                  from dnptxtotalbase_dbt stb " 
                           + "                 where stb.t_ClientID = party.T_PARTYID " 
                           + "                   and stb.t_TaxPeriod = " + AddRetParm(m_Year) 
                           + "                   and stb.t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE 
                           + "                   and stb.t_ConfirmState = " + NPTXTOTALBASE_CONFIRMSTATE_CONFIRMED
                           + "                   and Exists(select 1"
                           + "                                from doprstep_dbt oprstep "
                           + "                               where oprstep.t_ID_Operation = stb.t_ID_Operation "
                           + "                                 and oprstep.t_ID_Step = stb.t_ID_Step "
                           + "                                 and oprstep.t_Syst_Date between "+AddRetParm(date(m_ChBegDate))+" and " + AddRetParm(date(m_ChEndDate))
                           + "                             )"
                           + "              ) " 
                           + "    or exists ( select 1 " 
                           + "                  from dnptxtbext_dbt tbext "
                           + "                 where tbext.t_ClientID = party.T_PARTYID " 
                           + "                   and tbext.t_TaxPeriod = " + AddRetParm(m_Year) 
                           + "                   and tbext.t_LoadDate between "+AddRetParm(date(m_ChBegDate))+" and " + AddRetParm(date(m_ChEndDate))
                           + "                   and tbext.t_IsChanged = 'X' "
                           + "              ) " 
                           + "      ) ";
     end;

     Query = Query + " and party.T_PARTYID " + GetClientFilterQuery("party.T_PARTYID");

     Query = Query +
                "          ) "+
                "select q.client, " +
                "       q.T_ShortName, " +
                "       q.KindIIS, " +
                "       q.t_IISNumber, " +
                "       q.t_contrid, " +
                "       q.t_dlcontrid, " +
                "       q.t_rn, " +
                " (SELECT o.t_Code " +
                "    FROM DOBJCODE_DBT o " +
                "   WHERE o.t_ObjectType = 3 " +
                "     AND o.t_CodeKind = 101 " +
                "     AND o.t_ObjectID = q.client " +
                "     AND o.t_state = 0) as cftid, " +
                "       NVL(( " +
                "              select rsb_struct.getDouble(notetext.t_Text) " +
                "              from dnotetext_dbt notetext " +
                "              where notetext.t_ObjectType = 3 " +
                "                and notetext.t_DocumentID = LPAD(to_char(q.client), 10, '0') " +
                "                and notetext.t_NoteKind = 57 " +
                "           ), 0) as RateSpecial, " +
                "    NVL((SELECT 1 FROM dnptxtbbuf_dbt tbbuf " +
                "          WHERE tbbuf.t_clientid = q.client and tbbuf.t_Status = 0 and rownum = 1), 0) as checktb " +
                "from ( ";
    if(IsNotIIS)
          Query = Query + "select cl.T_PARTYID Client, cl.T_ShortName, 0 KindIIS, '' as t_IISNumber, 0 as t_contrid, 0 as t_dlcontrid, 0 as t_rn "+ 
                          "  from cl "+               
                          " where  ( " +
                          "          exists ( select 1 " +
                          "                     from dnptxtotalbase_dbt stb " +
                          "                    where stb.t_ClientID = cl.T_PARTYID " +
                          "                      and stb.t_TaxPeriod = " + AddRetParm(m_Year) +
                          "                      and stb.t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE +
                          "                      and stb.t_TaxBaseKind != " + NPTXTOTALBASE_TAXBASEKIND_IIS +
                          "                 ) ";
          // Если не установлен признак "Выводить по изменениям" и есть операции расчета НОБ без признака "Технический расчет"
          if(m_ByChanges == UNSET_CHAR)
            Query = Query +
                          "       or exists ( select 1 " +
                          "                    from dnptxop_dbt op " +
                          "                    where op.t_DocKind = " + DL_CALCNDFL +
                          "                      and op.t_Client = cl.t_PartyID " +
                          "                      and op.t_OperDate between "+AddRetParm(date(m_DBeg))+" and " + AddRetParm(date(m_DEnd)) + 
                          "                      and op.t_IIS <> CHR(88) " +
                          "                      and RSB_SECUR.GetMainObjAttr(132, LPAD(to_char(op.t_ID), 34, '0'), 1, "+AddRetParm(date(m_DBeg))+") = 0 " +
                          "                 ) ";
          end;

          Query = Query +
                          "       or exists ( select 1 " + 
                          "                     from dnptxtbext_dbt tbext "
                          "                    where tbext.t_ClientID = cl.T_PARTYID " + 
                          "                      and tbext.t_TaxPeriod = " + AddRetParm(m_Year) +
                          "                      and tbext.t_TaxBaseKind != " + NPTXTOTALBASE_TAXBASEKIND_IIS + 
                          "                 ) " + 
                          "       or exists ( select 1 " +
                          "                     from dnptxobj_dbt nptxobj " +
                          "                    where nptxobj.t_Client = cl.t_PartyID " +
                          "                      and nptxobj.t_Date between "+AddRetParm(date(m_DBeg))+" and " + AddRetParm(date(m_DEnd)) +
                          "                      and nptxobj.t_Kind in ( " + string(TXOBJ_DIVPAY_SEC_0) + ", " +
                                                                             string(TXOBJ_PAIDSPECIAL) + ", " +
                                                                             string(TXOBJ_PAIDSPECIAL_0) + 
                                                                      ") " +
                          "              ) " +
                          "       or exists ( select 1 " +
                          "                     from dnptxobj_dbt nptxobj " +
                          "                    where nptxobj.t_Client = cl.t_PartyID " +
                          "                      and nptxobj.t_Date between "+AddRetParm(date(m_DBeg))+" and " + AddRetParm(date(m_DEnd)) +
                          "                      and nptxobj.t_Kind in ( " + string(TXOBJ_DIVPAY_SEC) + ", " +
                                                                             string(TXOBJ_PAIDSPECIAL_IIS) +
                                                                      ") " +
                          "                      and nptxobj.t_FromOutSyst = CHR(0) " + 
                          "              ) " +
                          "       ) " +
               IIF(IsIIS, "  union all ", "");
     end;
     if(IsIIS)
          Query = Query + "select cl.T_PARTYID Client, cl.T_ShortName, 1 KindIIS, sfcontr.t_number as t_IISNumber, sfcontr.t_id as t_contrid, " +
                          "       dlcontr.t_dlcontrid, ROW_NUMBER () over(PARTITION BY cl.T_PARTYID ORDER BY SFCONTR.T_DATEBEGIN) as t_rn "+ 
                          "  from cl, ddlcontr_dbt dlcontr, dsfcontr_dbt sfcontr  "+
                          "   WHERE     sfcontr.t_PartyID = cl.T_PARTYID " +
                          "         AND dlcontr.t_SfContrID = sfcontr.t_ID " +
                          "         AND dlcontr.t_IIS = chr(88) " +
                          "         AND SFCONTR.T_DATEBEGIN <= TO_DATE ('31.12."+m_Year+"', 'DD.MM.YYYY') " +
                          "         AND (SFCONTR.T_DATECLOSE >= TO_DATE ('01.01."+m_Year+"', 'DD.MM.YYYY') " +
                          "              OR SFCONTR.T_DATECLOSE = TO_DATE ('01.01.0001', 'DD.MM.YYYY')) " +
                          " AND ( " +
                          "          exists ( select 1 " +
                          "                     from dnptxtotalbase_dbt stb " +
                          "                    where stb.t_ClientID = cl.T_PARTYID " +
                          "                      and stb.t_TaxPeriod = " + AddRetParm(m_Year) +
                          "                      and stb.t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE +
                          "                      and stb.t_TaxBaseKind = " + NPTXTOTALBASE_TAXBASEKIND_IIS +
                          "                      and stb.t_dlcontrid = dlcontr.t_dlcontrid " +
                          "                 ) ";
          // Если не установлен признак "Выводить по изменениям" и есть операции расчета НОБ без признака "Технический расчет"
          if(m_ByChanges == UNSET_CHAR)
             Query = Query +
                          "       or exists ( select 1 " +
                          "                    from dnptxop_dbt op " +
                          "                    where op.t_DocKind = " + DL_CALCNDFL +
                          "                      and op.t_Client = cl.t_PartyID " +
                          "                      and op.t_OperDate between "+AddRetParm(date(m_DBeg))+" and " + AddRetParm(date(m_DEnd)) +
                          "                      and op.t_IIS = CHR(88) " +
                          "                      and op.t_contract = dlcontr.t_dlcontrid " +
                          "                      and RSB_SECUR.GetMainObjAttr(132, LPAD(to_char(op.t_ID), 34, '0'), 1, "+AddRetParm(date(m_DBeg))+") = 0 " +
                          "                 ) ";
          end;

          Query = Query +
                          "       or exists ( select 1 " + 
                          "                     from dnptxtbext_dbt tbext "
                          "                    where tbext.t_ClientID = cl.T_PARTYID " + 
                          "                      and tbext.t_TaxPeriod = " + AddRetParm(m_Year) + 
                          "                      and tbext.t_TaxBaseKind = " + NPTXTOTALBASE_TAXBASEKIND_IIS +
                          "                 ) " +
                          "       or exists ( " +
                          "                    select 1 " +
                          "                     from dnptxobj_dbt nptxobj, dnptxobdc_dbt obdc, dnptxop_dbt nptxop " +
                          "                    where nptxobj.t_Client = cl.t_PartyID " +
                          "                      and nptxobj.t_Date between "+AddRetParm(date(m_DBeg))+" and " + AddRetParm(date(m_DEnd)) +
                          "                      and nptxobj.t_Kind in ( " + string(TXOBJ_DIVPAY_SEC) + ", " +
                                                                             string(TXOBJ_DIVPAY_SEC_0) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_15_1) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_15_1_0) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_0) + ", " +
                                                                             string(TXOBJ_PAIDMATERIAL) + ", " +
                                                                             string(TXOBJ_PAIDBILL) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_15_2) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_15_9) + ", " +
                                                                             string(TXOBJ_PAIDSPECIAL) + ", " +
                                                                             string(TXOBJ_PAIDSPECIAL_0) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_IIS) + ", " +
                                                                             string(TXOBJ_PAIDGENERAL_15_IIS) + ", " +
                                                                             string(TXOBJ_PAIDSPECIAL_IIS) +
                                                                      ") " +
                          "                       and rsi_npto.CheckObjIIS(nptxobj.t_AnaliticKind6, nptxobj.t_Analitic6) = 1 " +
                          "                       and nptxobj.t_Analitic6 = sfcontr.t_id " +
                          "                       and obdc.t_ObjID = nptxobj.t_ObjID " +
                          "                       and nptxop.t_ID = obdc.t_DocID " +
                          "                       and nptxop.t_DocKind = " + string(DL_CALCNDFL) +
                          "                       and nptxop.t_SubKind_Operation = " + string(DL_TXBASECALC_OPTYPE_CLOSE_IIS) +
                          "                 ) " +
                          "       ) ";
     end;
     Query = Query + "       ) q ";

     Query = Query +
                " order by q.t_ShortName, q.KindIIS DESC";
    return Query;
  END;

/**
  @brief Устанавливает границы и оформление для ячейки 
  @param[in] BegRow            - Номер ряда первой ячейки
  @param[in] BegCol            - Номер столбца первой ячейки
  @param[in] EndRow            - Номер ряда последней ячейки
  @param[in] EndCol            - Номер столбца последней ячейки
  @param[in] LeftBr            - bool Признак установки левой границы
  @param[in] StyleLeft         - string Имя левой границы
  @param[in] RightBr           - bool Признак установки правой границы
  @param[in] StyleRight        - string Имя правой границы
  @param[in] TopBr             - bool Признак установки верней границы
  @param[in] StyleTop          - string Имя верней границы
  @param[in] BottomBr          - bool Признак установки нижней границы
  @param[in] StyleBottom       - string Имя нижней границы
  @param[in] BgColor           - HEX цвета ячейки

  Для переданного диапазона устанавливает оформление ячейки (границы, цвет ячейки, шрифты, выравнивание). 
  А также объединяет диапазон в одну ячейку.
  Работает с итоговой книгой.
  При передачи не существующего диапазона будет ошибка.
*/
  PRIVATE MACRO SetBorder(BegRow, BegCol, EndRow, EndCol, 
                          LeftBr,   StyleLeft, 
                          RightBr,  StyleRight, 
                          TopBr,    StyleTop, 
                          BottomBr, StyleBottom,
                          BgColor)
    BegRow = BegRow - 1;
    EndRow = EndRow - 1;
    var curCol = 0, curRow = 0;
    
    var wobook = m_ObjTemplateXLS.GetTotalWorkbook().getCurrentWorkbook();
    var cellStyle = wobook.{createCellStyle@()Lorg/apache/poi/ss/usermodel/CellStyle;}();
    var borderColor = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.IndexedColors", "BLACK");
    var borderStyle = NULL;
    
    if(LeftBr and (valtype(StyleLeft) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleLeft);
      cellStyle.setBorderLeft(borderStyle);
      cellStyle.setLeftBorderColor(borderColor.getIndex());
    end;
     
    if(RightBr and (valtype(StyleRight) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleRight);
      cellStyle.setBorderRight(borderStyle);
      cellStyle.setRightBorderColor(borderColor.getIndex());
    end;

    if(TopBr and (valtype(StyleTop) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleTop);
      cellStyle.setBorderTop(borderStyle);
      cellStyle.setTopBorderColor(borderColor.getIndex());
    end;
    
    if(BottomBr and (valtype(StyleBottom) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleBottom);
      cellStyle.setBorderBottom(borderStyle);
      cellStyle.setBottomBorderColor(borderColor.getIndex());
    end;
    
    var cellFont = wobook.{createFont@()Lorg/apache/poi/ss/usermodel/Font;}(); //xssf->ss
        cellFont.setColor(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.IndexedColors", "BLACK").getIndex());
        cellFont.setCharSet(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.FontCharset", "RUSSIAN"));
        cellFont.setFamily(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.FontFamily", "ROMAN"));
        cellFont.setFontHeightInPoints(8);
        cellFont.setFontName("Arial Narrow");
        
    cellStyle.{setFont@(Lorg/apache/poi/ss/usermodel/Font;)V}(cellFont);
    cellStyle.setAlignment(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.HorizontalAlignment", "CENTER"));
    cellStyle.setVerticalAlignment(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.VerticalAlignment", "TOP"));
    cellStyle.setWrapText(true);
    
    if(BgColor != NULL)
      var newColor = jvm.createJavaObject("org.apache.poi.xssf.usermodel.XSSFColor",
                                             "<init>@(Lorg/apache/poi/xssf/usermodel/IndexedColorMap;)V",
                                             "FFF000");
          newColor.setARGBHex(BgColor);
      cellStyle.{setFillForegroundColor@(Lorg/apache/poi/xssf/usermodel/XSSFColor;)V}(newColor);
      cellStyle.setFillPattern(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.FillPatternType", "SOLID_FOREGROUND"));
    end;

    var poiCurrentSheet = wobook.{getSheet@(Ljava/lang/String;)Lorg/apache/poi/ss/usermodel/Sheet;}(m_CurrSheetName);
    var poiCurrentRow = poiCurrentSheet.{getRow@(I)Lorg/apache/poi/ss/usermodel/Row;}(BegRow);
    var poiCurrentCell = poiCurrentRow.{getCell@(I)Lorg/apache/poi/ss/usermodel/Cell;}(BegCol);
        poiCurrentCell.{setCellStyle@(Lorg/apache/poi/ss/usermodel/CellStyle;)V}(cellStyle);

    if((BegRow != EndRow) or (BegCol != EndCol))
      var mergeAddress = jvm.createJavaObject("org.apache.poi.ss.util.CellRangeAddress",
                                              "<init>@(IIII)V", BegRow, EndRow, BegCol, EndCol);
      poiCurrentSheet.addMergedRegion(mergeAddress);
    
      curRow = BegRow;
      while (curRow <= EndRow)
        curCol = BegCol;
        poiCurrentRow = poiCurrentSheet.{getRow@(I)Lorg/apache/poi/ss/usermodel/Row;}(curRow);
        while (curCol <= EndCol)
          poiCurrentCell = poiCurrentRow.{getCell@(I)Lorg/apache/poi/ss/usermodel/Cell;}(curCol);
          poiCurrentCell.{setCellStyle@(Lorg/apache/poi/ss/usermodel/CellStyle;)V}(cellStyle);
          curCol = curCol + 1;
        end;
        curRow = curRow + 1;
      end;
    end;

    poiCurrentCell   = NULL;
    poiCurrentRow    = NULL;
    poiCurrentSheet  = NULL;
    cellStyle        = NULL;
    cellFont         = NULL;
    borderStyle      = NULL;
  END;

/**
  @brief Устанавливает границы и оформление для ячейки 
  @param[in] BegRow            - Номер ряда первой ячейки
  @param[in] BegCol            - Номер столбца первой ячейки
  @param[in] EndRow            - Номер ряда последней ячейки
  @param[in] EndCol            - Номер столбца последней ячейки
  @param[in] LeftBr            - bool Признак установки левой границы
  @param[in] StyleLeft         - string Имя левой границы
  @param[in] RightBr           - bool Признак установки правой границы
  @param[in] StyleRight         - string Имя правой границы
  @param[in] TopBr             - bool Признак установки верней границы
  @param[in] StyleTop          - string Имя верней границы
  @param[in] BottomBr          - bool Признак установки нижней границы
  @param[in] StyleBottom       - string Имя нижней границы

  Для переданного диапазона устанавливает оформление ячейки (границы, шрифты, выравнивание). 
  А также объединяет диапазон в одну ячейку.
  Работает с шаблоном.
  При передачи не существующего диапазона будет ошибка.
*/
  PRIVATE MACRO SetBorderTemple(BegRow, BegCol, EndRow, EndCol, 
                                LeftBr,   StyleLeft, 
                                RightBr,  StyleRight, 
                                TopBr,    StyleTop, 
                                BottomBr, StyleBottom)
    BegRow = BegRow - 1;
    EndRow = EndRow - 1;
    var curCol = 0, curRow = 0;
    
    var wobokk = m_ObjTemplateXLS.GetWorkbook().getCurrentWorkbook();
    var cellStyle = wobokk.{createCellStyle@()Lorg/apache/poi/ss/usermodel/CellStyle;}();
    var borderColor = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.IndexedColors", "BLACK");
    var borderStyle = NULL;
    
    if(LeftBr and (valtype(StyleLeft) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleLeft);
      cellStyle.setBorderLeft(borderStyle);
      cellStyle.setLeftBorderColor(borderColor.getIndex());
    end;
     
    if(RightBr and (valtype(StyleRight) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleRight);
      cellStyle.setBorderRight(borderStyle);
      cellStyle.setRightBorderColor(borderColor.getIndex());
    end;

    if(TopBr and (valtype(StyleTop) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleTop);
      cellStyle.setBorderTop(borderStyle);
      cellStyle.setTopBorderColor(borderColor.getIndex());
    end;
    
    if(BottomBr and (valtype(StyleBottom) == V_STRING))
      borderStyle = GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.BorderStyle", StyleBottom);
      cellStyle.setBorderBottom(borderStyle);
      cellStyle.setBottomBorderColor(borderColor.getIndex());
    end;
    
    var cellFont = wobokk.{createFont@()Lorg/apache/poi/ss/usermodel/Font;}(); //xssf->ss
        cellFont.setColor(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.IndexedColors", "BLACK").getIndex());
        cellFont.setCharSet(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.FontCharset", "RUSSIAN"));
        cellFont.setFamily(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.FontFamily", "ROMAN"));
        cellFont.setFontHeightInPoints(8);
        cellFont.setFontName("Arial Narrow");
        cellStyle.{setFont@(Lorg/apache/poi/ss/usermodel/Font;)V}(cellFont);

    cellStyle.setAlignment(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.HorizontalAlignment", "RIGHT"));
    cellStyle.setVerticalAlignment(GetJavaEnumConstByName(jvm, "org.apache.poi.ss.usermodel.VerticalAlignment", "BOTTOM"));
    cellStyle.setWrapText(true);

    var dataFormat = wobokk.{createDataFormat@()Lorg/apache/poi/ss/usermodel/DataFormat;}();
    cellStyle.setDataFormat(dataFormat.getFormat("#,##0.00"));
 
    var poiCurrentSheet = wobokk.{getSheet@(Ljava/lang/String;)Lorg/apache/poi/ss/usermodel/Sheet;}(m_CurrSheetName);
    var poiCurrentRow = poiCurrentSheet.{getRow@(I)Lorg/apache/poi/ss/usermodel/Row;}(BegRow);
    var poiCurrentCell = poiCurrentRow.{getCell@(I)Lorg/apache/poi/ss/usermodel/Cell;}(BegCol);
        poiCurrentCell.{setCellStyle@(Lorg/apache/poi/ss/usermodel/CellStyle;)V}(cellStyle);

    if((BegRow != EndRow) or (BegCol != EndCol))
      var mergeAddress = jvm.createJavaObject("org.apache.poi.ss.util.CellRangeAddress",
                                              "<init>@(IIII)V", BegRow, EndRow, BegCol, EndCol);
          poiCurrentSheet.addMergedRegion(mergeAddress);
    
      curRow = BegRow;
      while (curRow <= EndRow)
        curCol = BegCol;
        poiCurrentRow = poiCurrentSheet.{getRow@(I)Lorg/apache/poi/ss/usermodel/Row;}(curRow);
        while (curCol <= EndCol)
          poiCurrentCell = poiCurrentRow.{getCell@(I)Lorg/apache/poi/ss/usermodel/Cell;}(curCol);
          poiCurrentCell.{setCellStyle@(Lorg/apache/poi/ss/usermodel/CellStyle;)V}(cellStyle);
          curCol = curCol + 1;
        end;
        curRow = curRow + 1;
      end;
    end;


    poiCurrentCell   = NULL;
    poiCurrentRow    = NULL;
    poiCurrentSheet  = NULL;
    cellStyle        = NULL;
    cellFont         = NULL;
    borderStyle      = NULL;
  END;

  PRIVATE MACRO BeginReport()
    CreateTotalBook();
    SetActiveSheet(m_CurrSheetName);
  END;

  MACRO PrintMode():INTEGER
    return DL_OUTREPORT_EXCEL;
  END;
  
/**
  @brief Загружает данные шаблона из таблицы
  Загружает данные динамической части шаблона из таблицы DNPTXTEMPLATEOKZ_DBT в массивы m_ArrSNOB (развернутый) и m_ArrRateKBK (сводный)
*/
  PRIVATE MACRO LoadTableData()
    private macro exsistRateSudKBK(arr, Rate, SUD, KBK)
      var i = 0;

      while(i < arr.size)
        if((arr[i].Rate == Rate) and
           (arr[i].SUD == SUD) and
           (arr[i].KBK == KBK))
          return true;
        end;
        i = i + 1;
      end;
      
      return false
    end;
  
    private macro GetIndexRateKBK(arr, Rate, KBK, indexRateKBK:@integer)
      var i = 0;

      if(Rate == this.m_MinRateNoResident)
        Rate = this.m_MinRateResident;
      end;

      while(i < arr.size)
        if((arr[i].Rate == Rate) and
           (arr[i].KBK == KBK))
          return i;
        end;
        i = i + 1;
      end;

      indexRateKBK = indexRateKBK + 1;

      return arr.size;
    end;
  
    var NameSNOB = "";
    var ArrDataObj = TArray();
    var stat = true;
    var index = 0;
    var indexRateKBK = -1;
    var iRateKBK = 0;
    
    m_ArrSNOB.size = 0;
    m_ArrRateKBK.size = 0;

    var query = 
       " select okz.*, llv.t_Code as t_NameSNOB, min(okz.t_rate) OVER(PARTITION BY okz.t_isresident) as t_minrate " +
       "   from dnptxtemplateokz_dbt okz, dLLVALUES_dbt llv  " +
       "  where okz.t_begdate <= ? " +
       "    and okz.t_enddate >= ? " +
       "    and (okz.t_sofr = ? or okz.t_depo = ?) " +
       "    and llv.t_list = 4157 " +
       "    and llv.t_element = okz.t_typenob " +
       "  order by t_typenob, t_isresident desc, t_rate, t_kbk, t_sofr desc, t_depo desc ";
    var cmd = DL_RSDCommand(query);
    cmd.addParam( m_OperDate );
    cmd.addParam( m_OperDate );
    cmd.addParam( m_FromSOFR );
    cmd.addParam( m_FromDEPO );
    
    var ds = cmd.Execute();
    stat = ds.moveNext();
    
    if(stat)
      NameSNOB = ds.NameSNOB;
    end;

    while (stat)
      
      if((ds.t_isresident == SET_CHAR) and (m_MinRateResident == 0))
        m_MinRateResident = ds.t_minrate;
      elif((ds.t_isresident == UNSET_CHAR) and (m_MinRateNoResident == 0))
        m_MinRateNoResident = ds.t_minrate;
      end;

      if(((ds.t_isresident == UNSET_CHAR) and (ds.Rate == m_MinRateNoResident) and
             (  (exsistRateSudKBK(ArrDataObj, m_MinRateResident, "ДЕПО", ds.KBK) and (ds.t_depo == SET_CHAR))
          or (exsistRateSudKBK(ArrDataObj, m_MinRateResident, "СОФР", ds.KBK) and (ds.t_sofr == SET_CHAR))
          )
         ) == false)
        if((ds.t_sofr == SET_CHAR) and (m_FromSOFR == SET_CHAR))
          ArrDataObj[ArrDataObj.size] = cRateSudKBK(ds.Rate, "СОФР", ds.KBK, index);
          index = index + 1;
         end;
      
        if((ds.t_depo == SET_CHAR) and (m_FromDEPO == SET_CHAR))
          ArrDataObj[ArrDataObj.size] = cRateSudKBK(ds.Rate, "ДЕПО", ds.KBK, index);
          index = index + 1;
        end;
        
        iRateKBK = GetIndexRateKBK(m_ArrRateKBK, ds.Rate, ds.KBK, @indexRateKBK);
        if(iRateKBK == m_ArrRateKBK.size)
          m_ArrRateKBK[iRateKBK] = cRateSudKBK(ds.Rate, NULL, ds.KBK, indexRateKBK);
        end;
      end;

      stat = ds.moveNext();
      if(NameSNOB != ds.NameSNOB)
        m_ArrSNOB[m_ArrSNOB.size] = ObjSNOB(NameSNOB, TArray(ArrDataObj));
        ArrDataObj.size = 0;
        NameSNOB = ds.NameSNOB;
      end;
    end;

    m_ArrSNOB[m_ArrSNOB.size] = ObjSNOB(NameSNOB, TArray(ArrDataObj));
    ArrDataObj.size = 0;
  END;

  PRIVATE MACRO PrintCellVal(CellValue, NumRow)
    if(ValType(m_ArrNumCol[NumRow]) ==  V_INTEGER)
      m_ArrNumCol[NumRow] = m_ArrNumCol[NumRow] + 1;
    else
      m_ArrNumCol[NumRow] = 0;
    end;
  
    var    CellName = _SplitCoord(NumRow-1, m_ArrNumCol[NumRow]);
    SplitCellName( CellName, @CellName, null, true );
    m_ObjTemplateXLS.SetValue_NameCell( CellName , CellValue );
  END;

/**
  @brief Корректировка номера строки под номер другой строки
*/
  PRIVATE MACRO CorrNumColByAnotherRow(NumRowCorr, NumRowCorrBy) 
    m_ArrNumCol[NumRowCorr] = m_ArrNumCol[NumRowCorrBy];
  END;

/**
  @brief Максимальный используемый номер столбца
*/
  PRIVATE MACRO maxColNum()
    var i = 0, max = 0;
    while(i < m_ArrNumCol.size)
      if((ValType(m_ArrNumCol[i]) == V_INTEGER) and (m_ArrNumCol[i] > max))
        max = m_ArrNumCol[i];
      end;
      i = i + 1;
    end;
    return max;
  END;

/** 
  @brief Печать шапки отчета (развернутый)
  
  В отчете есть статичная часть шаблона и динамическая. В связи с этим шапка формируется в самом отчете, а не берется из шаблона xlsx.
  Логика формирования: 
  Через PrintCellVal данные записываются в ячейку с номером ряда во 2 параметре, при этом номер столбца вычисляется автоматически, как максимальный для ряда (к примеру, для первого вызова номер столбца будет 0, потом 1 и т.д.)
  Функция CorrNumColByAnotherRow(x,y) позволяет скорректировать текущий номер столбца для ряда x, в соответствии с номером столбца для ряда y
  В массив m_ArrBorderPrm заносятся ячейки, для которых нужны границы и оформление, которого нет в шаблоне xlsx. Также используется для объединения ячеек в одну.
  Сначала формируется статичная часть шапки, а потом динамическая. 
*/
  PRIVATE MACRO PrintRepHeader()
    var i:integer = 0, j:integer  = 0;
    var NumCol = "";
    var RateStr = "";

    m_ArrBorderPrm.size = 0;
    m_ArrNumCol.size = 0;
    
    //Статичная часть
    PrintFormatString( NULL,  "H0_1", m_OperDate,
                              "H0_2", m_Year
                      );

    CopyAllSheetInTotalBook(m_CurrSheetName, false, "H0_HEADER", 0, m_CurrSheetName);

    PrintCellVal("Данные об инвесторе", 5);
    PrintCellVal("ID СОФР", 7);
    PrintCellVal("ID ЦФТ", 7);
    PrintCellVal("ФИО", 7);
    PrintCellVal("Номер договора ИИС", 7);
    PrintCellVal("Статус", 7);
    PrintCellVal("Наличие текущего счета в СПИ", 7);
    
    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Ставка налогообложения", 5);
    PrintCellVal("Общая ставка налогообложения", 7);
    PrintCellVal("СОИДН", 7);

    //Динамическая часть
    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Налогооблагаемая база по ЦБ и ПФИ (нарастающим итогом с начала года) (кроме дивидендов)", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, NULL, "Налогооблагаемая база по ЦБ и ПФИ", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", "FFE699");
    CorrNumColByAnotherRow(6, 7);
    CorrNumColByAnotherRow(10, 7);
    PrintCellVal("необлагаемые доходы", 6);
    PrintCellVal("9", 10);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], "9", false, "", true, "MEDIUM", false, "", true, "THIN");
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 9, m_ArrNumCol[6], "необлагаемые доходы", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "THIN");
    CorrNumColByAnotherRow(7, 6);
    CorrNumColByAnotherRow(8, 7);
    CorrNumColByAnotherRow(9, 7);

    i = 0;
    while( i < m_ArrSNOB.size )
      CorrNumColByAnotherRow(6, 7);
      PrintCellVal(m_ArrSNOB[i].Name, 6);
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 6, NULL, ("НОБ" + m_ArrSNOB[i].Name), true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "THIN", "FFE699");
      j = 0;

      while(j < m_ArrSNOB[i].ArrData.size)
        NumCol  = "(" + string((i+1)) + "." + string((j+1)) + ")";
        RateStr = IIF(m_ArrSNOB[i].ArrData[j].Rate != m_MinRateResident, m_ArrSNOB[i].ArrData[j].Rate + "%", m_ArrSNOB[i].ArrData[j].Rate + "%/" + m_MinRateNoResident + "%");

        PrintCellVal(RateStr, 7);
        PrintCellVal(m_ArrSNOB[i].ArrData[j].KBK,  8);
        PrintCellVal(m_ArrSNOB[i].ArrData[j].SUD,  9);
        PrintCellVal(NumCol, 10);
        
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 7, m_ArrNumCol[7], ("НОБ" + m_ArrSNOB[i].Name + j + "Rate"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(8, m_ArrNumCol[8], 8, m_ArrNumCol[8], ("НОБ" + m_ArrSNOB[i].Name + j + "KBK"), false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(9, m_ArrNumCol[9], 9, m_ArrNumCol[9], ("НОБ" + m_ArrSNOB[i].Name + j + "SUD"), false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], ("НОБ" + NumCol), false, "", true, "THIN", true, "THIN", true, "THIN");  //тонкая правая/верхняя/нижняя граница
        
        j = j + 1;
      end;
      m_ArrBorderPrm[getIndexBorderByName(("НОБ" + m_ArrSNOB[i].Name + (j-1) + "Rate"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("НОБ" + m_ArrSNOB[i].Name + (j-1) + "KBK"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("НОБ" + m_ArrSNOB[i].Name + (j-1) + "SUD"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("НОБ" + NumCol))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      
      m_ArrBorderPrm[getIndexBorderByName(("НОБ" + m_ArrSNOB[i].Name))].EndCol = m_ArrNumCol[7];
      i = i + 1;
    end;
    m_ArrBorderPrm[getIndexBorderByName("Налогооблагаемая база по ЦБ и ПФИ")].EndCol = m_ArrNumCol[7];


    CorrNumColByAnotherRow(5, 7);
    CorrNumColByAnotherRow(6, 7);
    PrintCellVal("Рассчитанный налог", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, NULL, "Рассчитанный налог", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", "F8CBAD");
    
    i = 0;
    while( i < m_ArrSNOB.size )
      CorrNumColByAnotherRow(6, 7);
      PrintCellVal(m_ArrSNOB[i].Name, 6);
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 6, NULL, ("Налог_" + m_ArrSNOB[i].Name), true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "THIN", "F8CBAD");
      j = 0;

      while(j < m_ArrSNOB[i].ArrData.size)
        NumCol = "(" + string((i+1)) + "." + string((j+1)) + ")";
        RateStr = IIF(m_ArrSNOB[i].ArrData[j].Rate != m_MinRateResident, m_ArrSNOB[i].ArrData[j].Rate + "%", m_ArrSNOB[i].ArrData[j].Rate + "%/" + m_MinRateNoResident + "%");

        PrintCellVal(RateStr, 7);
        PrintCellVal(m_ArrSNOB[i].ArrData[j].KBK,  8);
        PrintCellVal(m_ArrSNOB[i].ArrData[j].SUD,  9);
        PrintCellVal(NumCol, 10);
        
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 7, m_ArrNumCol[7], ("Налог_" + m_ArrSNOB[i].Name + j + "Rate"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(8, m_ArrNumCol[8], 8, m_ArrNumCol[8], ("Налог_" + m_ArrSNOB[i].Name + j + "KBK"), false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(9, m_ArrNumCol[9], 9, m_ArrNumCol[9], ("Налог_" + m_ArrSNOB[i].Name + j + "SUD"), false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], ("Налог_" + NumCol), false, "", true, "THIN", true, "THIN", true, "THIN");  //тонкая правая/верхняя/нижняя граница
        
        j = j + 1;
      end;
      m_ArrBorderPrm[getIndexBorderByName(("Налог_" + m_ArrSNOB[i].Name + (j-1) + "Rate"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("Налог_" + m_ArrSNOB[i].Name + (j-1) + "KBK"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("Налог_" + m_ArrSNOB[i].Name + (j-1) + "SUD"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("Налог_" + NumCol))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      
      m_ArrBorderPrm[getIndexBorderByName(("Налог_" + m_ArrSNOB[i].Name))].EndCol = m_ArrNumCol[7];
      i = i + 1;
    end;
    m_ArrBorderPrm[getIndexBorderByName("Рассчитанный налог")].EndCol = m_ArrNumCol[7];


    CorrNumColByAnotherRow(5, 7);
    CorrNumColByAnotherRow(6, 7);
    PrintCellVal("Уплаченный НДФЛ", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, NULL, "Уплаченный НДФЛ", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", "EDEDED");
    
    i = 0;
    while( i < m_ArrSNOB.size )
      CorrNumColByAnotherRow(6, 7);
      PrintCellVal(m_ArrSNOB[i].Name, 6);
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 6, NULL, ("НДФЛ_" + m_ArrSNOB[i].Name), true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "THIN", "EDEDED");
      j = 0;

      while(j < m_ArrSNOB[i].ArrData.size)
        NumCol = "(" + string((i+1)) + "." + string((j+1)) + ")";
        RateStr = IIF(m_ArrSNOB[i].ArrData[j].Rate != m_MinRateResident, m_ArrSNOB[i].ArrData[j].Rate + "%", m_ArrSNOB[i].ArrData[j].Rate + "%/" + m_MinRateNoResident + "%");

        PrintCellVal(RateStr, 7);
        PrintCellVal(m_ArrSNOB[i].ArrData[j].KBK,  8);
        PrintCellVal(m_ArrSNOB[i].ArrData[j].SUD,  9);
        PrintCellVal(NumCol, 10);
        
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 7, m_ArrNumCol[7], ("НДФЛ_" + m_ArrSNOB[i].Name + j + "Rate"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(8, m_ArrNumCol[8], 8, m_ArrNumCol[8], ("НДФЛ_" + m_ArrSNOB[i].Name + j + "KBK"), false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(9, m_ArrNumCol[9], 9, m_ArrNumCol[9], ("НДФЛ_" + m_ArrSNOB[i].Name + j + "SUD"), false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
        m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], ("НДФЛ_" + NumCol), false, "", true, "THIN", true, "THIN", true, "THIN");  //тонкая правая/верхняя/нижняя граница
        
        j = j + 1;
      end;
      m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + m_ArrSNOB[i].Name + (j-1) + "Rate"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + m_ArrSNOB[i].Name + (j-1) + "KBK"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + m_ArrSNOB[i].Name + (j-1) + "SUD"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + NumCol))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
      
      m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + m_ArrSNOB[i].Name))].EndCol = m_ArrNumCol[7];
      i = i + 1;
    end;
    m_ArrBorderPrm[getIndexBorderByName("Уплаченный НДФЛ")].EndCol = m_ArrNumCol[7];


    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Задолженность (+) /переплата (-)", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 6, m_ArrNumCol[5]+2, "Задолженность (+) /переплата (-)", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM");
    PrintCellVal("СОФР", 7);
    PrintCellVal("...", 10);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 9, m_ArrNumCol[7], "СОФР", true, "MEDIUM", true, "THIN", true, "MEDIUM", true, "THIN");
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], NULL, false, "", true, "THIN", false, "", true, "THIN");
    PrintCellVal("ДЕПО", 7);
    PrintCellVal("...", 10);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 9, m_ArrNumCol[7], "ДЕПО", false, "", true, "MEDIUM", true, "MEDIUM", true, "THIN", "D9D9D9");
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], NULL, false, "", true, "MEDIUM", false, "", true, "THIN", "D9D9D9");
    PrintCellVal("Общая", 7);
    PrintCellVal("...", 10);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 9, m_ArrNumCol[7], "Общая", false, "", true, "MEDIUM", true, "MEDIUM", true, "THIN", "FFFF00");
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], NULL, false, "", true, "MEDIUM", false, "", true, "THIN", "FFFF00");


    this.ПечататьПромежуточныеИтоги();

    CopyAllSheetInTotalBook(m_CurrSheetName, false, "A4:"+_SplitCoord(9, maxColNum()), 0, m_CurrSheetName);

    i = 0;
    while( i < m_ArrBorderPrm.size)
      SetBorder(m_ArrBorderPrm[i].BegRow, m_ArrBorderPrm[i].BegCol, m_ArrBorderPrm[i].EndRow, m_ArrBorderPrm[i].EndCol, 
                m_ArrBorderPrm[i].LeftBr,   m_ArrBorderPrm[i].StyleLeft,
                m_ArrBorderPrm[i].RightBr,  m_ArrBorderPrm[i].StyleRight,
                m_ArrBorderPrm[i].TopBr,    m_ArrBorderPrm[i].StyleTop,
                m_ArrBorderPrm[i].BottomBr, m_ArrBorderPrm[i].StyleBottom,
                m_ArrBorderPrm[i].BgColor
                );
      i = i + 1;
    end;
    
  END;

/** 
  @brief Печать шапки отчета (сводный)
  
  В отчете есть статичная часть шаблона и динамическая. В связи с этим шапка формируется в самом отчете, а не берется из шаблона xlsx.
  Логика формирования: 
  Через PrintCellVal данные записываются в ячейку с номером ряда во 2 параметре, при этом номер столбца вычисляется автоматически, как максимальный для ряда (к примеру, для первого вызова номер столбца будет 0, потом 1 и т.д.)
  Функция CorrNumColByAnotherRow(x,y) позволяет скорректировать текущий номер столбца для ряда x, в соответствии с номером столбца для ряда y
  В массив m_ArrBorderPrm заносятся ячейки, для которых нужны границы и оформление, которого нет в шаблоне xlsx. Также используется для объединения ячеек в одну.
  Сначала формируется статичная часть шапки, а потом динамическая. 
*/
  PRIVATE MACRO PrintRepHeaderSvod()
    var i:integer = 0;
    var NumCol = "";
    var RateStr = "";
    m_CurrSheetName = "Контроль (сводный)";
    
    SetActiveSheet(m_CurrSheetName);
    m_ArrBorderPrm.size = 0;
    m_ArrNumCol.size = 0;
    
    PrintFormatString( NULL,  "H1_1", m_OperDate,
                              "H1_2", m_Year
                      );

    CopyAllSheetInTotalBook(m_CurrSheetName, false, "H1_HEADER", 0, m_CurrSheetName);

    PrintCellVal("Данные об инвесторе", 5);
    PrintCellVal("ID СОФР", 7);
    PrintCellVal("ID ЦФТ", 7);
    PrintCellVal("ФИО", 7);
    PrintCellVal("Номер договора ИИС", 7);
    PrintCellVal("Статус", 7);
    
    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Ставка налогообложения", 5);
    PrintCellVal("Общая ставка налогообложения", 7);
    PrintCellVal("СОИДН", 7);

    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Налогооблагаемая база по ЦБ и ПФИ (нарастающим итогом с начала года) (кроме дивидендов)", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, NULL, "Налогооблагаемая база по ЦБ и ПФИ", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", "FFE699");
    CorrNumColByAnotherRow(6, 7);
    CorrNumColByAnotherRow(10, 7);
    PrintCellVal("необлагаемые доходы", 6);
    PrintCellVal("8", 10);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], "9", false, "", true, "MEDIUM", false, "", true, "THIN");
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 9, m_ArrNumCol[6], "необлагаемые доходы", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "THIN");
    CorrNumColByAnotherRow(7, 6);
    CorrNumColByAnotherRow(8, 7);
    CorrNumColByAnotherRow(9, 7);
    
    i = 0;
    while( i < m_ArrRateKBK.size )
      CorrNumColByAnotherRow(6, 7);
      NumCol  = "(" + string((i+1)) + ")";
      RateStr = IIF(m_ArrRateKBK[i].Rate != m_MinRateResident, m_ArrRateKBK[i].Rate + "%", m_ArrRateKBK[i].Rate + "%/" + m_MinRateNoResident + "%");
      
      PrintCellVal(" ", 6);//Пустые значения, чтобы не было ошибок при получении ячейки
      PrintCellVal(RateStr, 7);
      PrintCellVal(m_ArrRateKBK[i].KBK, 8);
      PrintCellVal(" ", 9);//Пустые значения, чтобы не было ошибок при получении ячейки
      PrintCellVal(NumCol, 10);
      
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 6, m_ArrNumCol[6], ("НОБ" + i + "6"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 7, m_ArrNumCol[7], ("НОБ" + i + "Rate"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(8, m_ArrNumCol[8], 8, m_ArrNumCol[8], ("НОБ" + i + "KBK"),  false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(9, m_ArrNumCol[9], 9, m_ArrNumCol[9], ("НОБ" + i + "9"),  false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], ("НОБ" + NumCol), false, "", true, "THIN", true, "THIN", true, "THIN");  //тонкая правая/верхняя/нижняя граница

      i = i + 1;
    end;
    
    m_ArrBorderPrm[getIndexBorderByName(("НОБ" + (i-1) + "6"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НОБ" + (i-1) + "Rate"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НОБ" + (i-1) + "KBK"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НОБ" + (i-1) + "9"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НОБ" + NumCol))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName("Налогооблагаемая база по ЦБ и ПФИ")].EndCol = m_ArrNumCol[7];

    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Рассчитанный налог", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, NULL, "Рассчитанный налог", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", "F8CBAD");

    i = 0;
    while( i < m_ArrRateKBK.size )
      CorrNumColByAnotherRow(6, 7);
      NumCol  = "(" + string((i+1)) + ")";
      RateStr = IIF(m_ArrRateKBK[i].Rate != m_MinRateResident, m_ArrRateKBK[i].Rate + "%", m_ArrRateKBK[i].Rate + "%/" + m_MinRateNoResident + "%");
      
      PrintCellVal(" ", 6);//Пустые значения, чтобы не было ошибок при получении ячейки
      PrintCellVal(RateStr, 7);
      PrintCellVal(m_ArrRateKBK[i].KBK, 8);
      PrintCellVal(" ", 9);//Пустые значения, чтобы не было ошибок при получении ячейки
      PrintCellVal(NumCol, 10);
      
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 6, m_ArrNumCol[6], ("Налог_" + i + "6"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 7, m_ArrNumCol[7], ("Налог_" + i + "Rate"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(8, m_ArrNumCol[8], 8, m_ArrNumCol[8], ("Налог_" + i + "KBK"),  false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(9, m_ArrNumCol[9], 9, m_ArrNumCol[9], ("Налог_" + i + "9"),  false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], ("Налог_" + NumCol), false, "", true, "THIN", true, "THIN", true, "THIN");  //тонкая правая/верхняя/нижняя граница

      i = i + 1;
    end;
    
    m_ArrBorderPrm[getIndexBorderByName(("Налог_" + (i-1) + "6"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("Налог_" + (i-1) + "Rate"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("Налог_" + (i-1) + "KBK"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("Налог_" + (i-1) + "9"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("Налог_" + NumCol))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName("Рассчитанный налог")].EndCol = m_ArrNumCol[7];

    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Уплаченный НДФЛ", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, NULL, "Уплаченный НДФЛ", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", "F8CBAD");

    i = 0;
    while( i < m_ArrRateKBK.size )
      CorrNumColByAnotherRow(6, 7);
      NumCol  = "(" + string((i+1)) + ")";
      RateStr = IIF(m_ArrRateKBK[i].Rate != m_MinRateResident, m_ArrRateKBK[i].Rate + "%", m_ArrRateKBK[i].Rate + "%/" + m_MinRateNoResident + "%");
      
      PrintCellVal(" ", 6);//Пустые значения, чтобы не было ошибок при получении ячейки
      PrintCellVal(RateStr, 7);
      PrintCellVal(m_ArrRateKBK[i].KBK, 8);
      PrintCellVal(" ", 9);//Пустые значения, чтобы не было ошибок при получении ячейки
      PrintCellVal(NumCol, 10);
      
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 6, m_ArrNumCol[6], ("НДФЛ_" + i + "6"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(7, m_ArrNumCol[7], 7, m_ArrNumCol[7], ("НДФЛ_" + i + "Rate"), false, "", true, "THIN", false, "", false, ""); //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(8, m_ArrNumCol[8], 8, m_ArrNumCol[8], ("НДФЛ_" + i + "KBK"),  false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(9, m_ArrNumCol[9], 9, m_ArrNumCol[9], ("НДФЛ_" + i + "9"),  false, "", true, "THIN", false, "", false, "");  //тонкая правая граница
      m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], ("НДФЛ_" + NumCol), false, "", true, "THIN", true, "THIN", true, "THIN");  //тонкая правая/верхняя/нижняя граница

      i = i + 1;
    end;
    
    m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + (i-1) + "6"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + (i-1) + "Rate"))].StyleRight = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + (i-1) + "KBK"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + (i-1) + "9"))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName(("НДФЛ_" + NumCol))].StyleRight  = "MEDIUM";//у последних строк в блоке правая граница средняя
    m_ArrBorderPrm[getIndexBorderByName("Уплаченный НДФЛ")].EndCol = m_ArrNumCol[7];

    CorrNumColByAnotherRow(5, 7);
    PrintCellVal("Задолженность (+) /переплата (-)", 5);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(5, m_ArrNumCol[5], 5, m_ArrNumCol[5], "Задолженность (+) /переплата (-)", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM", true, "MEDIUM");
    PrintCellVal("Общая", 6);
    PrintCellVal("...", 10);
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(6, m_ArrNumCol[6], 9, m_ArrNumCol[6], "Общая", false, "", true, "MEDIUM", true, "MEDIUM", true, "THIN", "FFFF00");
    m_ArrBorderPrm[m_ArrBorderPrm.size] = cBorderPrm(10, m_ArrNumCol[10], 10, m_ArrNumCol[10], NULL, false, "", true, "MEDIUM", false, "", true, "THIN", "FFFF00");

    this.ПечататьПромежуточныеИтоги();

    CopyAllSheetInTotalBook(m_CurrSheetName, false, "A4:"+_SplitCoord(9, maxColNum()), 0, m_CurrSheetName);

    i = 0;
    while( i < m_ArrBorderPrm.size)
      SetBorder(m_ArrBorderPrm[i].BegRow, m_ArrBorderPrm[i].BegCol, m_ArrBorderPrm[i].EndRow, m_ArrBorderPrm[i].EndCol, 
                m_ArrBorderPrm[i].LeftBr,   m_ArrBorderPrm[i].StyleLeft,
                m_ArrBorderPrm[i].RightBr,  m_ArrBorderPrm[i].StyleRight,
                m_ArrBorderPrm[i].TopBr,    m_ArrBorderPrm[i].StyleTop,
                m_ArrBorderPrm[i].BottomBr, m_ArrBorderPrm[i].StyleBottom,
                m_ArrBorderPrm[i].BgColor
                );
      i = i + 1;
    end;

  END;

  /*Убрано наименование листа из формулы итогов*/
  MACRO GetFormulaSumm()
     GetFormulaSummREG();
  END;

  MACRO ПечататьПромежуточныеИтоги()
    var i = IIF(m_CurrSheetName == "Контроль (разернутый)", 8, 7);
    var maxCol = maxColNum();
    while(i <= maxCol)
      SetSubtotalEx(10, 13, _SplitCoord(3, i));
      i = i + 1;
    end;
  END;

  PRIVATE MACRO RegistrTableCtrl()
    var i = 0;
    var maxCol = maxColNum();
    m_ArrTableStruct.size = 0;

    i = 0;
    while(i <= maxCol)
      if(i >= IIF(m_CurrSheetName == "Контроль (разернутый)", 8, 7))
        SetBorderTemple(11, i, 11, i, 
                        true, "THIN",
                        true, "THIN",
                        true, "THIN",
                        true, "THIN"
                        );
      end;
      m_ArrTableStruct[m_ArrTableStruct.size] = _SplitCoord(10, i);
      i = i + 1;
    end;
  
    RegisterTableArr();

    SetCellAutoSummaArr("Всего");
    
    PrintTableLine( "A1", "Всего", null );
    PrintTableLine( "A1", "В том числе", null );
  END;

  PRIVATE MACRO PrintLineNoData()
    PrintTableLine( "A1", "", null );
  END;

  MACRO Clear()
    m_ArrDataRow.size = 0;
    m_ArrDataRowSvod.size = 0;
  END;

  PRIVATE MACRO getIsCurrAcc()
    var query, cmd, DataSet;
  
    query = "select 1 from dsettacc_dbt where t_partyid = ? and t_fiid = "+NATCUR+" and t_fikind = "+FIKIND_CURRENCY+" and t_account not like '306%' FETCH FIRST 1 ROWS ONLY";
    cmd = DL_RSDCommand(query);
    cmd.addParam( m_Data.Client );
    DataSet = cmd.Execute();
    
    if(DataSet.moveNext())
      return "Да";
    end;
    
    return "Нет";
  END;

  PRIVATE MACRO getSOIDN()
    return readNoteForObject(OBJTYPE_PARTY, L_Z( m_Data.Client, 10 ), 77, m_Dend);
  END;

  /*НДР с кодом Coup0_Group, Exp_Group, Plus_Sec0 за период с 1 января года <Year> по <OperDate> включительно*/
  MACRO TaxSpecial0():money
     var v_TaxSpecial0 = $0;
     var objstr = string(TXOBJ_COUP0_GROUP)+", "+string(TXOBJ_EXP_GROUP)+", "+string(TXOBJ_PLUS_SEC0)+", "+string(TXOBJ_MAINB_0)+", "+string(TXOBJ_MAINS_0)+", "+string(TXOBJ_COMB_0)
                  +", "+string(TXOBJ_COMS_0)+", "+string(TXOBJ_MAINB_TS_0)+", "+string(TXOBJ_MAINS_TS_0)+", "+string(TXOBJ_COMB_TS_0)+", "+string(TXOBJ_COMS_TS_0);

     DL_GetNPTXOBJSumByClient(m_Data.Client,
                              objstr,
                              m_Dbeg,
                              m_Dend,
                              null,
                              null,
                              @v_TaxSpecial0,
                              null,
                              m_Data.KindIIS,
                              null,
                              IIF(m_Data.KindIIS == 1, " obj.t_Analitic6 = " + m_Data.ContrID, "")
                             );

     return v_TaxSpecial0;
  END;

/** 
  @brief Загрузка данных из Хранилищя
  
  Исходя из шаблона формирует массив значений для отчета. Если данные отсутствуют проставляется $0.
*/
  PRIVATE MACRO ЗагрузитьЗначенияХранилищя()
    PRIVATE MACRO getIndex(NameSNOB, Rate, SUD, KBK)
      var i = 0, j = 0;

      if(Rate == this.m_MinRateNoResident)
        Rate = this.m_MinRateResident;
      end;
      
      while(i < this.m_ArrSNOB.size)
        if(this.m_ArrSNOB[i].Name == NameSNOB)
          break;
        end;
        i = i + 1;
      end;
      
      if(i >= this.m_ArrSNOB.size)//если не нашли значение, то в следующим цикле будет попытка считать данные с не существующего индекса массива
        return -1;
      end;
      
      while(j < this.m_ArrSNOB[i].ArrData.size)
        if((this.m_ArrSNOB[i].ArrData[j].Rate == Rate) and
           (this.m_ArrSNOB[i].ArrData[j].SUD == IIF(SUD == 1, "СОФР", "ДЕПО")) and
           (this.m_ArrSNOB[i].ArrData[j].KBK == KBK))
          return this.m_ArrSNOB[i].ArrData[j].index;
        end;
        j = j + 1;
      end;
      
      return -1;
    END;
  
    PRIVATE MACRO getIndexSvod(Rate, KBK)
      var i = 0, j = 0;

      if(Rate == this.m_MinRateNoResident)
        Rate = this.m_MinRateResident;
      end;
      
      while(i < this.m_ArrRateKBK.size)
        if((this.m_ArrRateKBK[i].Rate == Rate) and
           (this.m_ArrRateKBK[i].KBK == KBK))
          return this.m_ArrRateKBK[i].index;
        end;

        i = i + 1;
      end;

      return -1;
    END;
  
    var query = " ", cmd, DataSet;
    var i = 0, j = 0;
    var ArrData = TArray();
    var ArrDataSvod = TArray();
    var lastIndex = m_ArrSNOB[(m_ArrSNOB.size-1)].ArrData[(m_ArrSNOB[(m_ArrSNOB.size-1)].ArrData.size - 1)].index + 1;
    var lastIndexSvod = m_ArrRateKBK[(m_ArrRateKBK.size-1)].index + 1;
    var Index = 0;
    var IndexSvod = 0;
    var Year = 0;
    var TaxBaseKind;

    //Сначала создается массив значений заполненный $0. 
    //На этапе загрузки шаблона из таблицы проставляется индекс. По этому индексу заполняются значения для каждого блока данных.
    while(i < m_ArrSNOB.size)
      j = 0;
      while(j < m_ArrSNOB[i].ArrData.size)
        ArrData[m_ArrSNOB[i].ArrData[j].index] = $0.0;//Налогооблагаемая база по ЦБ и ПФИ
        ArrData[(m_ArrSNOB[i].ArrData[j].index + lastIndex)] = $0.0; //Рассчитанный налог
        ArrData[(m_ArrSNOB[i].ArrData[j].index + (lastIndex*2))] = $0.0; //Уплаченный НДФЛ 
        j = j + 1;
      end;
      i = i + 1;
    end;

    ArrData[ArrData.size] = $0.0;
    ArrData[ArrData.size] = $0.0;
    ArrData[ArrData.size] = $0.0;

    i = 0;
    while(i < m_ArrRateKBK.size)
        ArrDataSvod[m_ArrRateKBK[i].index] = $0.0;//Налогооблагаемая база по ЦБ и ПФИ
        ArrDataSvod[(m_ArrRateKBK[i].index + lastIndexSvod)] = $0.0; //Рассчитанный налог
        ArrDataSvod[(m_ArrRateKBK[i].index + (lastIndexSvod*2))] = $0.0; //Уплаченный НДФЛ 

      i = i + 1;
    end;
    
    ArrDataSvod[ArrDataSvod.size] = $0.0;

    if(m_Data.KindIIS == 0)
      TaxBaseKind = NPTXTOTALBASE_TAXBASEKIND_ONB + ", " + NPTXTOTALBASE_TAXBASEKIND_BROK + ", 0";
    else
      TaxBaseKind = NPTXTOTALBASE_TAXBASEKIND_IIS;
    end;
    
    datesplit(m_Dend, null, null, Year);
    
    
    query = " SELECT q.t_Rate, "
          + "        llv.t_code as t_KBK, "
          + "        q.t_SysCome, "
          + "        llv2.t_code as t_SNOB, "
          + "        lnk.t_typesnob, "
          + "        SUM (SumTaxBaseCurrPay) AS SumTaxBaseCurrPay, "
          + "        SUM (SumHoldPITax) AS SumHoldPITax "
          + "  FROM (  ";

    if(m_FromSOFR == SET_CHAR)
      query = query + " select t_RateHoldPITax AS t_Rate, "
                    + "        t_BCCHoldPITax AS t_KBK, "
                    + "        t_SysCome, "
                    + "        t_TaxBaseKind, "
                    + "        SUM(t_TaxBaseCurrPay) as SumTaxBaseCurrPay, "
                    + "        SUM(t_HoldPITax) as SumHoldPITax "
                    + "   from dnptxtotalbase_dbt "
                    + "  where t_ClientID = ? "
                    + "    and t_TaxPeriod = ? "
                    + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
                    + "    and t_TaxBaseKind IN ("+TaxBaseKind+") "
                    + IIF(m_FromDEPO == SET_CHAR, " and t_SysCome in (1,2) ", " and t_SysCome = 1 " )
                    + IIF(m_Data.dlcontrid > 0, " and t_dlcontrid = ? ", " " )
                    + "  group by t_TaxBaseKind, t_RateHoldPITax, t_BCCHoldPITax, t_SysCome";
    
    end;
    
    query = query + IIF(( ((m_FromDEPO == SET_CHAR) and ( (m_Data.KindIIS == 0) or ((m_Data.KindIIS == 1) and (m_Data.rn == 1)) )
                          )  and (m_FromSOFR == SET_CHAR)), " UNION ALL ","");

    if((m_FromDEPO == SET_CHAR) and 
       ( (m_Data.KindIIS == 0) or ((m_Data.KindIIS == 1) and (m_Data.rn == 1)) //У ДЕПО нет номера договора по ИИС, поэтому значения заносятся в первый договор по дате открытия. 
       ) 
      )
      query =  query + " select t_NdflKeepRate AS t_Rate, "
                     + "        t_KBKKeep AS t_KBK, "
                     + "        2 AS t_SysCome, "
                     + "        t_TaxBaseKind, "
                     + "        SUM(t_NOBAmount) as SumTaxBaseCurrPay, "
                     + "        SUM(t_NdflKeepAmount) as SumHoldPITax "
                     + "   from dnptxtbext_dbt "
                     + "  where t_ClientID = ? "
                     + "    and t_TaxPeriod = ? "
                     + "    and t_TaxBaseKind IN ("+TaxBaseKind+") "
                      + " group by t_TaxBaseKind, t_NdflKeepRate, t_KBKKeep";
    
    end;
    
    query =  query + "    ) q, DLLVALUES_DBT llv, DNPTXLINKSKINDSNOB_DBT lnk,DLLVALUES_DBT llv2 " 
                   + " WHERE llv.t_list = 3522 and llv.t_name = q.t_kbk "
                   + "   and lnk.t_taxbasetype = q.t_taxbasekind and extract(year from lnk.t_begdatetypesnob) <= ? and extract(year from lnk.t_enddatetypesnob) >= ? "
                   + "   and llv2.t_list = 4157 and llv2.t_element = lnk.t_typesnob "
                   + " GROUP BY llv2.t_code, q.t_Rate, llv.t_code, q.t_SysCome, lnk.t_typesnob "
                   + " ORDER BY q.t_Rate, llv.t_code, RSI_NPTXOKZ.isFirstRecForCalc (llv.t_code, q.t_Rate, q.t_SysCome, lnk.t_typesnob, ?), llv2.t_code, q.t_SysCome";

    
    cmd = DL_RSDCommand(query);
    
    if(m_FromSOFR == SET_CHAR)
      cmd.AddParam(m_Data.Client);
      cmd.AddParam(Year);
      if(m_Data.dlcontrid > 0)
        cmd.AddParam(m_Data.dlcontrid);
      end;
    end;
    
    if((m_FromDEPO == SET_CHAR) and 
       ( (m_Data.KindIIS == 0) or ((m_Data.KindIIS == 1) and (m_Data.rn == 1)) 
       ) 
      )
      cmd.AddParam(m_Data.Client);
      cmd.AddParam(Year);
    end;
    
    cmd.AddParam(Year);
    cmd.AddParam(Year);
    cmd.AddParam(Year);

    DataSet = cmd.Execute();
    var prevRate = 0;
    var prevKBK = "";
    var SumTaxBase = $0.0;
    var SumTaxCalc = $0.0;
    var TaxCalc = $0.0;
    var TaxDueTotalSofr = $0.0;
    var TaxDueTotalDepo = $0.0;
    var SumTaxPaidSofr = $0.0;
    var SumTaxPaidDepo = $0.0;
    var SumTaxCalcSofr = $0.0;
    var SumTaxCalcDepo = $0.0;

    while(DataSet.moveNext())
      Index = getIndex(DataSet.SNOB, DataSet.Rate, DataSet.SysCome, DataSet.KBK);
      IndexSvod = getIndexSvod(DataSet.Rate, DataSet.KBK);

      if((prevRate != DataSet.Rate) or (prevKBK != DataSet.KBK))
        SumTaxBase = money(DataSet.SumTaxBaseCurrPay);
        SumTaxCalc = round((SumTaxBase * DataSet.Rate / 100), 0);
        TaxCalc = SumTaxCalc;
        prevRate = DataSet.Rate;
        prevKBK = DataSet.KBK;
      else
        SumTaxBase = SumTaxBase + money(DataSet.SumTaxBaseCurrPay);
        TaxCalc = round((SumTaxBase * DataSet.Rate / 100), 0) - SumTaxCalc;
        SumTaxCalc = SumTaxCalc + TaxCalc;
      end;
      
      ArrData[(Index + lastIndex)] = TaxCalc;//Рассчитанный налог
      ArrData[Index] = money(DataSet.SumTaxBaseCurrPay);//Налогооблагаемая база по ЦБ и ПФИ
      ArrData[(Index + (lastIndex*2))] = money(DataSet.SumHoldPITax);//Уплаченный НДФЛ
      
      if(DataSet.SysCome == 1)
        SumTaxPaidSofr = SumTaxPaidSofr + money(DataSet.SumHoldPITax);
        SumTaxCalcSofr = SumTaxCalcSofr + TaxCalc;
      elif(DataSet.SysCome == 2)
          SumTaxPaidDepo = SumTaxPaidDepo +  money(DataSet.SumHoldPITax);
        SumTaxCalcDepo = SumTaxCalcDepo + TaxCalc;
      end;
      
      ArrDataSvod[IndexSvod] = money(DataSet.SumTaxBaseCurrPay);//Налогооблагаемая база по ЦБ и ПФИ
      ArrDataSvod[(IndexSvod + lastIndexSvod)] = TaxCalc;//Рассчитанный налог
      ArrDataSvod[(IndexSvod + lastIndexSvod*2)] = money(DataSet.SumHoldPITax);//Уплаченный НДФЛ
    end;

    TaxDueTotalSofr = SumTaxCalcSofr - SumTaxPaidSofr;
    TaxDueTotalDepo = SumTaxCalcDepo - SumTaxPaidDepo;

    ArrData[(ArrData.size-3)] = TaxDueTotalSofr;
    ArrData[(ArrData.size-2)] = TaxDueTotalDepo;
    ArrData[(ArrData.size-1)] = TaxDueTotalSofr + TaxDueTotalDepo;
    
    ArrDataSvod[(ArrDataSvod.size-1)] = TaxDueTotalSofr + TaxDueTotalDepo;

    i = 0;
    while(i < ArrData.size)
      addDataToArr(ArrData[i]);
      i = i + 1;
    end;
    
    i = 0;
    while(i < ArrDataSvod.size)//Сразу кладем данные и для (Сводный)
      addDataToArrSvod(ArrDataSvod[i]);
      i = i + 1;
    end;
  END;

  PRIVATE MACRO ЗагрузитьБазовыеПараметры()
    var Status = IIF(STB_IsResidentStatusRSI(m_Data.Client, m_Dend) == 1, "резидент", "нерезидент");

    //Контроль (разернутый)
    addDataToArr(m_Data.Client, //ID СОФР
                 m_Data.cftid,  //ID ЦФТ
                 m_Data.ShortName, //ФИО
                 m_Data.IISNumber, //Номер договора ИИС
                 Status, //Статус
                 getIsCurrAcc() //Наличие  текущего счета в СПИ
                 ); // Блок 1


    addDataToArr(IIF(Status == "резидент", (m_MinRateResident*0.01), (m_MinRateNoResident*0.01)), //Общая ставка налогообложения
                 (getSOIDN()*0.01) //СОИДН
                 ); // Блок 2

    addDataToArr(TaxSpecial0()); //Необлагаемые доходы Блок 3
    
    
    //Контроль (сводный)
    addDataToArrSvod(m_Data.Client, //ID СОФР
                     m_Data.cftid,  //ID ЦФТ
                     m_Data.ShortName, //ФИО
                     m_Data.IISNumber, //Номер договора ИИС
                     Status //Статус
                     );// Блок 1
    
    addDataToArrSvod(IIF(Status == "резидент", (m_MinRateResident*0.01), (m_MinRateNoResident*0.01)), //Общая ставка налогообложения
                     (getSOIDN()*0.01) //СОИДН
                    ); // Блок 2

    addDataToArrSvod(TaxSpecial0()); //Необлагаемые доходы Блок 3
  END;

  PRIVATE MACRO checkErrResStatus()
    var Year = 0;
    
    datesplit(m_Dend, null, null, Year);
    
    var query = " select 1 " 
              + "   from dnptxtotalbase_dbt stb "
              + "  where stb.t_ClientID = ? " 
              + "    and stb.t_TaxPeriod = ? "
              + "    and stb.t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE 
              + "    and stb.t_ConfirmState = " + NPTXTOTALBASE_CONFIRMSTATE_CONFIRMED
              + "    and stb.t_rateholdpitax = ? "
              + "    and rownum = 1 ";
       
    var cmd = DL_RSDCommand(query);
        cmd.AddParam(m_Data.Client);
        cmd.AddParam(Year);
        cmd.AddParam(IIF(STB_IsResidentStatusRSI(m_Data.Client, m_Dend) == 1, m_MinRateNoResident, m_MinRateResident));
    
    var ds = cmd.Execute();
    
    if(ds.moveNext())
      return true;
    end;
    return false;
  END;

  PRIVATE MACRO ExistsSum():bool
    var i = 8;

    while( i < m_ArrDataRow.size)
      if(m_ArrDataRow[i] != $0.0)
        return true;
      end;
    end;
  
    return false;
  END;  

  PRIVATE MACRO EndReport()
    SaveTotalbook();
    ReplaceAndCalculate( GetDL_FORMULA(), "=" );
  END;
  
   PRIVATE MACRO ExecuteReport()
    var Num = 0;
    var Query, Sql;
    var RetParmArr = TArray();
    var i = 0;

    m_Query = GetQuery(true, true, RetParmArr);
    Sql = DL_RSDCommand(m_Query);

    if(RetParmArr.size > 0)
      i = 0;
      while(i < RetParmArr.size)
        Sql.AddParam(RetParmArr[i]);
        i = i + 1;
      end;
    end;

    m_Data = Sql.execute();

    InitProgress( m_Nrec, "Отчёт: Контроль задолженности", "Печать вкладки \"Контроль (разернутый)\"" );

    if( m_Nrec )
       PrintRepHeader();
       RegistrTableCtrl();
    end;

    var stat = m_Data.MoveNext();
    while(stat)
      if(m_Data.checktb == 1)
        addProtocolErr(m_Data.client, m_Data.cftid, m_Data.ShortName, "Требуется пересчет СНОБ");
        UseProgress( Num = Num + 1 );
        stat = m_Data.MoveNext();
        continue;
      elif(checkErrResStatus())
        addProtocolErr(m_Data.client, m_Data.cftid, m_Data.ShortName, "Выявлены записи, не соответствующие налоговому статусу клиента");
        UseProgress( Num = Num + 1 );
        stat = m_Data.MoveNext();
        continue;
      end;
      
      Clear();
       // для ИИС начальную дату приходится переопределять
      m_Dbeg = IIF(m_Data.KindIIS == 1, GetFirstDateIIS(m_Data.client), Date(1,1,m_Year));

      ЗагрузитьБазовыеПараметры();
      ЗагрузитьЗначенияХранилищя();

      if( (m_IsActiveClient == "") or
          ((m_IsActiveClient == "X") and (ExistsSum() == true))
        )
        SetDataExists(m_Data.client);
        PrintTableLineArr();
        m_ArrDataSvod[m_ArrDataSvod.size] = TArray(m_ArrDataRowSvod);
      end;
       
      UseProgress( Num = Num + 1 );
      stat = m_Data.MoveNext();
    end;

    EndTable(); //В этот момент сработает ф-ция AfterAutoFill

    CopyAllSheetInTotalBook(m_CurrSheetName, false, GetTableRange(), 0, m_CurrSheetName);
    AddStandardFooter();
    CopyAllSheetInTotalBook(m_CurrSheetName, false, "N1_Footer", 0, m_CurrSheetName);

    RemProgress();


    InitProgress( m_Nrec, "Отчёт: Контроль задолженности", "Печать вкладки \"Контроль (сводный)\"" );
    
    PrintRepHeaderSvod();
    RegistrTableCtrl();

    i = 0;
    while(i < m_ArrDataSvod.size)
      m_ArrDataRow = m_ArrDataSvod[i];
      PrintTableLineArr();
      i = i + 1;
      UseProgress(i);
    end;

    EndTable();
    
    CopyAllSheetInTotalBook(m_CurrSheetName, false,  GetTableRange(), 0, m_CurrSheetName);//"A11:" + _SplitCoord((i+11), maxColNum())
    AddStandardFooter("H1_");
    CopyAllSheetInTotalBook(m_CurrSheetName, false, "N2_Footer", 0, m_CurrSheetName);

    RemProgress();
  END;

  PRIVATE MACRO makeProtocol()
    var i = 0;
    
    if(m_ArrProtocolErr.size == 0)
      return;
    end;

    m_ArrBorderPrm.size = 0;
    m_ArrNumCol.size = 0;

    m_CurrSheetName = "Протокол";

    CopyAllSheetInTotalBook(m_CurrSheetName, false, "H2_Header_Протокол", 0, m_CurrSheetName);
    
    RegisterTable(  "N3_MainTable", NULL,
                    "N3_Num",
                    "N3_SOFR",
                    "N3_CFT",            
                    "N3_FIO",
                    "N3_COMMENT"         
                  );

    InitProgress( m_ArrProtocolErr.size, "Отчёт: Контроль задолженности", "Печать вкладки \"Протокол\"" );

    i = 0;
    while(i < m_ArrProtocolErr.size)
      PrintTableLine("N3_Num",          (i+1),                        null,
                     "N3_SOFR",         m_ArrProtocolErr[i].IDSOFR,   null,      
                     "N3_CFT",          m_ArrProtocolErr[i].IDCFT,    null,   
                     "N3_FIO",          m_ArrProtocolErr[i].FIO,      null,
                     "N3_COMMENT",      m_ArrProtocolErr[i].Comment,  null
                  );

      i = i + 1;
      UseProgress(i);
    end;

    EndTable();
    RemProgress();
    
    CopyAllSheetInTotalBook(m_CurrSheetName, false,  GetTableRange(), 0, m_CurrSheetName);
  END;

  PRIVATE MACRO GetDataForRep()
    var NRec, NRecData;
    var RetParmArr = TArray();
    var i = 0;

    m_Nrec = 0;

    m_Query = GetQuery(true, true, RetParmArr);
    NRec = DL_RSDCommand(m_Query);

    if(RetParmArr.size > 0)
      i = 0;
      while(i < RetParmArr.size)
        NRec.AddParam(RetParmArr[i]);
        i = i + 1;
      end;
    end;

    m_NRec = NRec.GetCount();

    return m_Nrec;
  END;

  private macro GetStr(val)
    var Type = ValType( val );

    if( Type == V_STRING )
      return Trim(val);
    elif( ( Type == V_DOUBLE ) or ( Type == V_MONEY ) )
      return string(bigint(val));
    else
      return "";
    end;
  end;

  private macro DelClientFromList(ClientID)
    execSql ("delete from DNPTXCTRLCLNT_TMP where T_CLIENTID = " +ClientID+ " ");
  end;

  private macro CheckClientList()
    var query = 
     " SELECT T_CLIENTID " +
     "    FROM DNPTXCTRLCLNT_TMP ";
    var cmd = DL_RSDCommand(query);
    var ds = cmd.Execute();
    while (ds.MoveNext())
      if (not CheckSofrId(ds.CLIENTID))
        PrintProtLine(ds.CLIENTID, "", "Недопустимая форма субъекта");
       DelClientFromList(ds.CLIENTID);
      elif(not CheckServIsGood(ds.CLIENTID))
        PrintProtLine(ds.CLIENTID, "", "Недопустимый вид обслуживания");
        DelClientFromList(ds.CLIENTID);
      end;
    end;
  end;

  private macro FillErrorsNoData()
    var query = 
     " SELECT T_CLIENTID " +
     "    FROM DNPTXCTRLCLNT_TMP "+
     "  WHERE T_DATAEXISTS is null or T_DATAEXISTS <> CHR(88)";
    var cmd = DL_RSDCommand(query);
    var ds = cmd.Execute();
    while (ds.MoveNext())
      PrintProtLine(ds.CLIENTID, "", "Не подходит под условия отбора");
      DelClientFromList(ds.CLIENTID);
    end;
  end;

  private macro LoadClientListFromFile()
    var objExcel = CExcelPoi();
    var resultFilePath = m_FilePath;
    var fileName, fileExt;
    SplitFile( resultFilePath, fileName, fileExt );
    if (SubStr( resultFilePath, 1, 1 ) == "$")
      var toPath = PathCombine(GetAbsoluteTxtPath(),GetExlusiveFileName(SubStr( fileExt, 2)));
      if( not CopyFile(resultFilePath, toPath) )
        RunError( "Ошибка при копировании файла",  CustomError("Ошибка при копировании файла " + resultFilePath + " в " + toPath ));
      end;
      resultFilePath = toPath;
    end;
    if (not objExcel.open(resultFilePath))
      RunError("Не удалось открыть excel файл", CustomError("Не удалось открыть excel файл по пути " + resultFilePath));
    end;
    execSql ("delete from DNPTXCTRLCLNT_TMP");
    var curRow = 0;
    var iLastRow = objExcel.GetLastRowNum()+1;
    while ((curRow=curRow+1) <= iLastRow)
      var clientIdStr = "";
      var excelValue = GetStr(objExcel.CellValue("A"+string(curRow)));
      var dotIdx = Index(excelValue, ".");
      if (dotIdx > 0)
        excelValue = SubStr(excelValue, 1, dotIdx-1);
      end;
      if (excelValue == "")
        continue;
      end;
      if (m_FileContentType == FILE_CONTENT_TYPE_SOFR)
        clientIdStr = trim(excelValue);
        if(strLen(clientIdStr) > 8)
          PrintProtLine(excelValue, "", "Некорректный идентификатор СОФР");
          continue;
        end;
        if(not CheckSofrIdExists(clientIdStr))
          PrintProtLine(excelValue, "", "Неверный ID");
          continue;
        end;
      elif (m_FileContentType == FILE_CONTENT_TYPE_CFT)
        var sofrId = GetSofrIDFromCftId(trim(excelValue));
        if (sofrId == 0)
          PrintProtLine(0, excelValue, "Указан несуществующий ID");
          continue;
        else
          clientIdStr = trim(string(sofrId));
        end;
      end;
      execSql ("insert into DNPTXCTRLCLNT_TMP (T_CLIENTID) values ("+clientIdStr+")");
    end;
    objExcel = null;
  end;

  PRIVATE MACRO Create()
    m_ArrProtocolErr.size = 0;
    m_UserRegNameDiapazon.size = 0;
    //грузим excel
    if (m_IsLoadFromFile)
      LoadClientListFromFile();
    end;

    CheckClientList();

    LoadTableData();

    if( GetDataForRep() )
      ExecuteReport();
    else
 
      PrintRepHeader();
      RegistrTableCtrl();
      PrintLineNoData();
      EndTable();
      CopyAllSheetInTotalBook(m_CurrSheetName, false, GetTableRange(), 0, m_CurrSheetName);;
      
      AddStandardFooter();
      CopyAllSheetInTotalBook(m_CurrSheetName, false, "N1_Footer", 0, m_CurrSheetName);
    end;

    makeProtocol();

    FillErrorsNoData();
  END;

  PRIVATE MACRO CReport_Show( NumCopy:INTEGER )
    var day, mon, year;
    var hour, min, sec;

    DateSplit(date(), day, mon, year);
    TimeSplit(time(), hour, min, sec);
    SetLastTotalBookName("Отчет_Контроль_задолженности_"+string(day:o:2)+string(mon:o:2)+string(year)+"_"+string(hour:o:2)+string(min:o:2));
    CReport_Show(NumCopy);
  end;

/** 
  @brief Функция срабатывающая при переоткрытии шаблона
  
  Когда срабатывает ограничение по SetRowFlushCount шаблон переоткрывается, при этом теряются имена диапазонов и оформление ячеек.
*/
  MACRO OnAfterReOpenTempleFile()
    var i = 0;
    var maxCol = maxColNum();
    
    while(i < m_UserRegNameDiapazon.size)
      regNameDiapazon(m_UserRegNameDiapazon[i].Name, m_UserRegNameDiapazon[i].Diapazon);
      i = i + 1;
    end;

    i = IIF(m_CurrSheetName == "Контроль (разернутый)", 8, 7);
    while(i <= maxCol)
      SetBorderTemple(11, i, 11, i, 
                      true, "THIN",
                      true, "THIN",
                      true, "THIN",
                      true, "THIN"
                      );
      i = i + 1;
    end;
  END;

  initDL_CReportTemplate( NULL, "Report_nptxokz.xlsx", true, null, null, true, true ); 
  SetRowFlushCount(4000);  
END;


PRIVATE MACRO ReportRun()
  
  private macro hasTemplOKZ(date)
    var query = 
       " select 1 " +
       "   from dnptxtemplateokz_dbt okz" +
       "  where okz.t_begdate <= ? " +
       "    and okz.t_enddate >= ? ";
       
    var cmd = DL_RSDCommand(query);
    cmd.addParam( date );
    cmd.addParam( date );
    
    var ds = cmd.Execute();
    
    if(ds.moveNext())
      return true;
    end;
    return false;
  end;
  
  var Form = Sp_NPTXCTRL_Panel();

  while(Form.Run())
    var OperDate        = Form.m_EndDate;
    var Year            = Form.m_Year;
    var Dbeg            = Date(1,1,Year);
    var Dend            = min(OperDate,Date(31,12,Year));
    var IsCurBrocAcc    = Form.m_IsCurBrocAcc;
    var IsActiveClient  = Form.m_IsActiveClient;
    var FromSOFR        = Form.m_FromSOFR;
    var FromDEPO        = Form.m_FromDEPO;
    var ByChanges       = Form.m_ByChanges;
    var ChBegDate       = Form.m_ChBegDate;
    var ChEndDate       = Form.m_ChEndDate;
    var IsLoadFromFile  = Form.m_isLoadFromFile;
    var FilePath        = Form.m_filePath;
    var FileContentType = Form.m_fileContentType;
    var ListWithAcc     = Form.m_listWithAcc;
    
    if(MsgBoxEx("Проверить актуальность данных Настроечной таблицы для шаблона ОКЗ?", MB_ERROR + MB_YES + MB_NO, IND_NO) == IND_YES)
      DL_OKZScrol();
      if(MsgBoxEx("Продолжить формирование Отчета \"Контроль задолженности?\"", MB_ERROR + MB_YES + MB_NO, IND_NO) == IND_NO)
        return;
      end;
    end;

    if(hasTemplOKZ(Dend) == false)
      MsgBox("В Настроечной таблице для шаблона ОКЗ не найдено действующих в отчетном периоде СНОБ. Операция прервана");
      return;
    end;

    var protObj = PoiSimpleRepo("Протокол ошибок при создании Отчета \"Контроль задолженности по НДФЛ\"",
                                 makeArray(
                                   DL_KeyPair("ID СОФР", 15),
                                   DL_KeyPair("ID ЦФТ", 15),
                                   DL_KeyPair("Ошибка", 50)
                                 ),
                                 true);

    var rep = Sp_NPTXCTRL_Report(OperDate, Year, Dbeg, Dend, IsCurBrocAcc, IsActiveClient, FromSOFR, FromDEPO, ByChanges, ChBegDate, ChEndDate, IsLoadFromFile, FilePath, FileContentType, ListWithAcc, protObj);
    rep.Run();
    rep = null;

    if (protObj.IsHasData())
      var d,m,y,hh,mm;
      DateSplit(date(),d,m,y);
      TimeSplit(time(),hh,mm);
      var fileName = "Протокол_Отчет_Контроль_задолженности_" + string(d:o:2, m:o:2, y:o:4) + "_" + string(hh:o:2, mm:o:2) + ".xlsx";
      var path = PathCombine(GetAbsoluteTxtPath(),fileName);
      protObj.SaveAs(path);
      MsgBox("Операция завершена. Создан Протокол ошибок " + path);
    end;
  end;
END;


ReportRun();
exit(1);