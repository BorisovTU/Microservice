/*
$Name:        update_acctrn_DEF-46290.mac
$Module:      Ценные бумаги
$Description: Изменение проводок по удержанию налог при выводе д/с в валюте
*/

import DealsInter, spserv, sp_class, sp_car, spreserv, dlcontrfunc;

private var TestMode   = true;      //Тестовый режим (без фиксации действий в БД)


/*
$Name:             dl_car.mac
$Module:           Ядро Securities
$Description:      Выполннение проводок
*/

IMPORT "MC_lib.mac", oprinter, InsCarryDoc, "dl_class.mac", "dlquery.mac", "dlmisc.mac";
IMPORT "role_model.mac";//ролевая модель

/* Проводка по категориям учета (в том числе и мультивалютная)
   СчетДебет,СчетКредит - если тип V_STRING то категории, иначе record ACCOUNT*/
PRIVATE RECORD AccountPayer(account);
PRIVATE RECORD AccountReceiver(account);
PRIVATE MACRO SayCarryError( error )
  MsgBox( error );
  return false;
END;

private macro ВнутреннийУчетОткрыт(): BOOL
   var query =  " SELECT t_IsClosed FROM dDLGRACCKIND_dbt  WHERE t_Num = 3";  /*системный номер внутреннего учета*/
   var Select = Dl_RSDCommand(query);
   var DataSet = Select.Execute();
   var InnerAccIsOpen = true;

   if(DataSet.moveNext())
    if(DataSet.IsClosed == SET_CHAR)
      InnerAccIsOpen = false;
    end;
   end;

   return InnerAccIsOpen;
end;

PRIVATE VAR DL_UseInnerCalc = NULL;
PRIVATE MACRO ВестиВнутреннийУчет():BOOL
  VAR ErrCode = 0;

  if( DL_UseInnerCalc == NULL )
    if( GetIdentProgram() == CodeFor("S") ) /*операция выполняется из БОЦБ*/
      //проверим настройку из графика
     DL_UseInnerCalc = ВнутреннийУчетОткрыт();
    elif( GetIdentProgram() == CodeFor("N") ) /*операция выполняется из УВ*/
     DL_UseInnerCalc = VA_NeedInnerAcc();
    else
     GetRegistryValue( "COMMON\\ВНУТРЕННИЙ УЧЕТ\\ФОРМИРОВАНИЕ ПРОВОДОК", V_BOOL, DL_UseInnerCalc, ErrCode );
     if( ErrCode != 0 )
       DL_UseInnerCalc = false;
     end;
    end;
  end;

  return DL_UseInnerCalc;
END;

PRIVATE MACRO ПолучитьМаскиСчКлиентов(Masks:@string):BOOL
  VAR ErrCode = 0;

  GetRegistryValue( "SECUR\\СЧЕТА КЛИЕНТОВ БО ЦБ", V_STRING, Masks, ErrCode );
  if( ErrCode != 0 )
     Masks = "";
     return false;
  end;

  return true;
END;

PRIVATE MACRO DL_IsClientAcc(Account:string)
   var Masks = "";

   if( ПолучитьМаскиСчКлиентов(@Masks) )
      if( not CompareStrWithMasks(Masks,Account) )
         return true;
      end;
   end;

   return false;
END;

PRIVATE MACRO DL_GetAccount( Chapter:INTEGER, FIID:INTEGER, Account:STRING, AccBuf:VARIANT):BOOL
   VAR AccRec;
   var RetVal = false;
   record AccountBuf(account);

   AccRec = TBFile( "account.dbt", "R", 0 );

   AccRec.rec.Chapter       = Chapter;
   AccRec.rec.Code_Currency = FIID;
   AccRec.rec.Account       = Account;
   if( AccRec.GetEQ() )
      Copy( AccBuf, AccRec );
      RetVal = true;
   end;

   /* если надо поищем счёт во временной базе */
   if(not RetVal)
      ClearRecord( AccountBuf );
      if(DL_FindAccount( Chapter, FIID, Account, AccountBuf ) == 0)
         Copy( AccBuf, AccountBuf );
         RetVal = true;
      end;
   end;

   return RetVal;
END;

PRIVATE MACRO DL_GetShifrOper( Chapter, AccountPayer, AccountReceiver )

  var RetVal = "";

  if( Chapter == 1 )

     RetVal = "09";

     if( DL_IsClientAcc(AccountPayer.Account) AND (not DL_IsClientAcc(AccountReceiver.Account)) )
        if(Index(AccountReceiver.Type_Account, "К") == 0 )
           RetVal = "17";
        end;
     elif( DL_IsClientAcc(AccountReceiver.Account) AND (not DL_IsClientAcc(AccountPayer.Account)) )
        if(Index(AccountPayer.Type_Account, "К") == 0 )
           RetVal = "17";
        end;
     end;
  elif( Chapter == 3 )
     RetVal = "09";
     // "18" в векселях проставляется
  elif( Chapter == 4 )
     RetVal = "09";
  end;

  return RetVal;
END;

PRIVATE VAR isPlanMode = false;
PRIVATE VAR CheckCatArr = TArray();
PRIVATE VAR PlanInAccData = TArray();


PRIVATE CLASS CDLPlanInAccData(_inacc)
  var inacc = TRecHandler("dlinacc.dbt");

  copy(inacc, _inacc);
END;

PRIVATE MACRO DL_GetPlanInAccData()
  return PlanInAccData;
END;

private var GlDealCode, DopFD, FlagSetDealCode = false;
private macro РасчетнаяОперацияВУ( accTrn : RsbAccTransaction, FD, ВидРО ) : bool
  var DlInAcc = TBfile("dlinacc.dbt", "rw");
  record  InnAcc(DlInAcc);
  var Tick = TBfile("dl_tick.dbt");
  var stat = true;
   
  var DealSum = $0, spground, dealcode = "", DealCost = $0;

  if( GetIdentProgram() == CodeFor("S") )
     InnAcc.Boffice   = OBJTYPE_BACKOFFICE_SP;
  elif( GetIdentProgram() == CodeFor("Ю") )
     InnAcc.Boffice   = OBJTYPE_BACKOFFICE_DV;
  elif( GetIdentProgram() == CodeFor("J") )
     InnAcc.Boffice   = OBJTYPE_BACKOFFICE_MM;
  elif( GetIdentProgram() == CodeFor("V") )
     InnAcc.Boffice   = OBJTYPE_BACKOFFICE_FOREX;
  elif( GetIdentProgram() == CodeFor("А") )
     InnAcc.Boffice   = OBJTYPE_BACKOFFICE_TRUST;
  elif( GetIdentProgram() == CodeFor("N") )
     InnAcc.Boffice   = OBJTYPE_BACKOFFICE_VA;
  end;

  InnAcc.OperType     = ВидРО;
  InnAcc.DocumentID   = FD.ID;

  InnAcc.AccTrnID   = accTrn.AccTrnID;
  InnAcc.Date       = accTrn.Date_Carry;
  InnAcc.Chapter    = accTrn.Chapter;
  InnAcc.DebAcc     = accTrn.AccountPayer;
  InnAcc.KredAcc    = accTrn.AccountReceiver;

  if (accTrn.Chapter == 22)
   InnAcc.FIKind    = FIKIND_AVOIRISS;
  else
   InnAcc.FIKind    = FIKIND_CURRENCY;
  end;

  InnAcc.FIID       = accTrn.FIIDPayer;
  InnAcc.Sum        = accTrn.SumPayer;
  InnAcc.Department = accTrn.Department;
  InnAcc.Oper       = accTrn.Oper;

  if( FD.Kind == 159 )
  /*если РОВУ привязана к сделке, вносим dealkind\dealcode из операции dl_acc_dbt*/
     if( (FD.dl_acc.rec.DealID > 0) and (FD.dl_acc.rec.Boffice == OBJTYPE_BACKOFFICE_SP) )
        Tick.Clear();
        Tick.rec.DealID = FD.dl_acc.rec.DealID;
        if( Tick.GetEQ() )
           InnAcc.DealKind = Tick.rec.BofficeKind;
           dealcode = Tick.rec.DealCode;
        else
           InnAcc.DealKind   = FD.Kind;
        end;
     else
        InnAcc.DealKind   = FD.Kind;
     end;
  else
     if( StrUpr( GenClassName(FD) ) == StrUpr("TS_ReqAssetFD") )
        InnAcc.DealKind   = FD.Request.Kind;
     elif( StrUpr( GenClassName(FD) ) == StrUpr("TS_CALCORCB_FD") )
        InnAcc.DealKind   = FD.CalcORCB().rec.DocKind;
     else
        InnAcc.DealKind   = FD.Kind;
     end;
  end;

  InnAcc.DocumentKind = FD.Kind;

  if( not ((GlDealCode == "") and (ВидРО == 94) and (StrUpr(GenClassName(FD)) == StrUpr("TS_OrderFD"))) )
     if(FlagSetDealCode == true)
        dealcode = GlDealCode;
     end;
  end;

  FD.ВУ_СкорректироватьРесчетнуюОперацию( ВидРО, InnAcc );
  if(FlagSetDealCode == true)
     if(DopFD != NULL)
        DopFD.ВУ_СкорректироватьРесчетнуюОперацию( ВидРО, InnAcc );
     end;
  end;
  FlagSetDealCode = false;

  if(isPlanMode == true)
    if((InnAcc.DebAcc != "") or (InnAcc.KredAcc != ""))
      PlanInAccData[PlanInAccData.size] = CDLPlanInAccData(InnAcc);
    end;
  else
    copy(DlInAcc, InnAcc);
    if(not DlInAcc.Insert())
      msgbox("Ошибка при создании РОВУ");
    else
      var upd = DL_RSDCommand("UPDATE ddlinacc_dbt SET t_FMTBLOBDATA_XXXX = utl_raw.cast_to_raw(\'"+FD.nptxop.rec.Code+"\') WHERE t_ID = ?");

      upd.AddParam(DlInAcc.rec.ID);

      upd.ExecuteCMD();
    end;
  end;

  return stat; 
end;

PRIVATE MACRO CheckCat(CatCode)
  var check = true;
  if((ValType(CheckCatArr) != V_UNDEF) and (CheckCatArr.size > 0))
    check = false;

    var i = 0;
    while(i < CheckCatArr.size)
      if(CatCode == CheckCatArr[i])
        check = true;
        break;
      end;
      i = i + 1;
    end;
  end;

  return check;
END;

PRIVATE MACRO GetAccount(FD, CatCode, FIRole, recAccount:@variant, ActionDate, FIID)
  var stat = true;
  var findAccount = "";

  if(isPlanMode)
    ClearRecord(recAccount);
    if(CheckCat(CatCode, CheckCatArr) == true)
      stat = FD.FindNumberAccount( CatCode,
                                   findAccount,
                                   false,
                                   FIRole,
                                   FIID
                                 );

      recAccount.Account       = findAccount;
      recAccount.Code_Currency = FIID;
    end;
  else
    stat = FD.OpenAccount( CatCode,
                           null,
                           false,
                           FIRole,
                           recAccount,
                           ActionDate,
                           FIID);
  end;

  return stat;
END;


PRIVATE MACRO ПроводкаПоКатегориямУчета(
  FD:VARIANT,
  СчетДебет:VARIANT, СчетКредит:VARIANT,
  ДатаВалютирования:DATE,
  Chapter:INTEGER,
  FIID:INTEGER,
  СуммаОперации:MONEY,
  Numb_Document:STRING,
  Ground:STRING,
  FIRolePayer:INTEGER, FIRoleReceiver:INTEGER,
  СчетДебетFIID:INTEGER, СчетКредитFIID:INTEGER,
  IsInnerCarry,
  ВидРО:INTEGER,
  FDDebetParm:VARIANT, FDCreditParm:VARIANT
)
  var CуммаДебет = $0, СуммаКредит  = $0, tr = NULL, PaymentObj = NULL,
      СчетОВПДебет = "", СчетОВПКредит = "", СчетДоходов = "", СчетРасходов = "";

  if( СуммаОперации == null )
     return SayCarryError( "В проводке не задана ни одна из сумм." );
  end;

  /*оставить только копейки для первой суммы, если она задана*/
  if( СуммаОперации != null )
     if( (Chapter == 5) or (Chapter == 22) )
        /*количество ц/б может быть дробным*/
     else
        СуммаОперации = money( round( СуммаОперации, 2 ) );
     end;
     if( СуммаОперации < $0 )
        return SayCarryError( "Сумма проводки < 0." );
     end;
  else
    СуммаОперации = $0;
  end;

  if( СуммаОперации == $0 )
     return true;
  end;

  if( ValType(СчетДебет) == V_STRING ) /*задан через категорию*/
     if( (StrUpr( GenClassName(FD) ) == StrUpr("TS_CALCORCB_FD")) OR
         (StrUpr( GenClassName(FD) ) == StrUpr("TS_ReqAssetFD")) OR
         (StrUpr( GenClassName(FD) ) == StrUpr("TS_OrderFD")) OR
         (StrUpr( GenClassName(FD) ) == StrUpr("TS_OrderFD_DV"))
       )
        if( not FD.OpenAccount( FDDebetParm, СчетДебет, null, false, FIRolePayer, AccountPayer, ДатаВалютирования, СчетДебетFIID) )
            return SayCarryError( "Ошибка при определении счета по категории "+СчетДебет+" в проводке.");
        end;
     else
        if(not GetAccount(FD, СчетДебет, FIRolePayer, AccountPayer, ДатаВалютирования, СчетДебетFIID))
          return SayCarryError( "Ошибка при определении счета по категории "+СчетДебет+" в проводке.");
        end;
     end;
  else
     copy( AccountPayer, СчетДебет );
  end;

  if( ValType(СчетКредит) == V_STRING ) /*задан через категорию*/
     if( (StrUpr( GenClassName(FD) ) == StrUpr("TS_CALCORCB_FD")) OR
         (StrUpr( GenClassName(FD) ) == StrUpr("TS_ReqAssetFD")) OR
         (StrUpr( GenClassName(FD) ) == StrUpr("TS_OrderFD")) OR
         (StrUpr( GenClassName(FD) ) == StrUpr("TS_OrderFD_DV"))
       )
        if( not FD.OpenAccount( FDCreditParm, СчетКредит, null, false, FIRoleReceiver, AccountReceiver, ДатаВалютирования, СчетКредитFIID) )
           return SayCarryError( "Ошибка при определении счета по категории "+СчетКредит+" в проводке." );
        end;
     else
        if(not GetAccount(FD, СчетКредит, FIRoleReceiver, AccountReceiver, ДатаВалютирования, СчетКредитFIID))
          return SayCarryError( "Ошибка при определении счета по категории "+СчетКредит+" в проводке.");
        end;
     end;
  else
     copy( AccountReceiver, СчетКредит );
  end;

  if( FIID == null )
     return SayCarryError("Не задана ни одна из валют проводки.");
  end;

  if( (FIID != AccountPayer.Code_Currency) AND
      (FIID != AccountReceiver.Code_Currency) )
     return SayCarryError( "В проводке не совпадают валюты счетов: "
                            + string(AccountPayer.Code_Currency) + " " + string( AccountReceiver.Code_Currency ) +
                           "| и валюта документа: " + string(FIID) );
  end;

  if( СуммаОперации != $0 )
     CуммаДебет = СуммаКредит = СуммаОперации;
  end;

  tr = RsbAccTransaction();

/*DAN.Ролевая модель Определяем конечного операциониста для проводки */
      var retvalGetMO = GetMainOperInGroup(FD.kind);
      if (retvalGetMO > 0)
     Tr.Oper = retvalGetMO;
      else
         Tr.Oper = {Oper};
      end;
/*DAN*/

  if( tr == NULL )
     return SayCarryError("Ошибка при формировании документа проводки.");
  end;
  tr.Chapter         = Chapter;
  tr.Date_Carry      = ДатаВалютирования;
  tr.Numb_Document   = Numb_Document;
  tr.ResultCarry     = INPCARRY;
  tr.Kind_Oper       = "";
  tr.Ground          = Ground;
  tr.Department      = {OperDprt};
  tr.FIIDPayer       = AccountPayer.Code_Currency;
  tr.FIIDReceiver    = AccountReceiver.Code_Currency;
  tr.SumPayer        = CуммаДебет;
  tr.SumReceiver     = СуммаКредит;
  tr.AccountPayer    = AccountPayer.Account;
  tr.AccountReceiver = AccountReceiver.Account;
  if( PaymentObj != null )
     tr.Number_Pack  = PaymentObj.NumberPack;
  end;

  if(isPlanMode == false)
    if( not tr.Carry() )
       return SayCarryError("Ошибка при выполнении проводки");
    end;
  end;

  if( IsInnerCarry )
     if( not РасчетнаяОперацияВУ( tr, FD, ВидРО ) )
        return SayCarryError("Ошибка при вставке расчетной операции внутреннего учета");
     end;
  end;

  return true;
END;

private macro ПроводкаПоКатегориямВнутреннегоУчета( ВидРО, FD, Doc, CarryDate, FIID, CarrySumm, FDDebetParm:VARIANT, FDCreditParm:VARIANT, DealCode, GroundStr, AccDeb:VARIANT, AccKred:VARIANT, _FIRolePayer:integer, _FIRoleReceiver:integer )
  var ClassName:string = "";
  var Ground:string = "";
  var AccountDeb, AccountKred;
  var FIRolePayer:integer = -1, FIRoleReceiver:integer = -1;

  if( not ВестиВнутреннийУчет() )
     return 1;
  end;

  FlagSetDealCode = false;
  if(ValType(DealCode) != V_UNDEF)
     GlDealCode = DealCode;
     DopFD      = FDDebetParm;
     FlagSetDealCode = true;
  else
     if( FD != NULL )
        ClassName = StrUpr( GenClassName( FD ));
        if( (ClassName == StrUpr("SPFirstDoc") ) OR
            (ClassName == StrUpr("SPFirstDocTrust")) OR
            (ClassName == StrUpr("TS_VaTickFD"))
          )
           if( FD.tick != NULL ) //Сделка
              GlDealCode = FD.tick.rec.DealCode;
              FlagSetDealCode = true;
           end;
        elif( ClassName == StrUpr("TS_ReqAssetFD" ) )   //операция ВВК ДУ
           if( FD.Request != NULL )
              GlDealCode = FD.Request.Number;
              FlagSetDealCode = true;
           end;
        elif( ClassName == StrUpr("DLFirstDocDL_Acc" ) )//расчетная операция
           if( FD.dl_acc != NULL )
              GlDealCode = FD.dl_acc.rec.Code;
              FlagSetDealCode = true;
           end;
        elif( ClassName == StrUpr("TS_CALCORCB_FD" ) )  //расчеты на ОРЦБ
           if( FD.CalcORCB() != NULL )
              GlDealCode = FD.CalcORCB().rec.CommCode;
              FlagSetDealCode = true;
           end;
        elif( (ClassName == StrUpr("SPFirstDocDLCOMM" )) or (ClassName == StrUpr("DVFirstDocDLCOMM" )) )
           if( FD.comm != NULL )
              GlDealCode = FD.comm.rec.CommCode;
              FlagSetDealCode = true;
           end;
        end;
     end;
  end;

  if(ValType(GroundStr) == V_STRING)
     Ground = GroundStr;
  else
     Ground = FD.ВУ_ОснованиеПроводки( ВидРО );
  end;

  if( (StrUpr(GenClassName(FD)) == StrUpr("SPFirstDocDLCOMM")) AND ((FD.Kind == DL_ISSUE_UNION) OR (FD.Kind == DL_CHGAVRNOM) OR ((FD.Kind == DL_SETTLEMENT) AND (AccDeb != NULL) AND (AccKred != NULL))) )
     AccountDeb  = AccDeb;
     AccountKred = AccKred;
  elif((StrUpr(GenClassName(FD)) == StrUpr("DLFirstDocNPTXOP")) AND ((FD.Kind == DL_HOLDNDFL) OR (FD.Kind == DL_WRTMONEY)) AND (AccDeb != NULL) AND (AccKred != NULL))
     AccountDeb  = AccDeb;
     AccountKred = AccKred;
  else
     AccountDeb  = FD.ВУ_ПолучитьКатегориюДебет( ВидРО, null, CarryDate, FIID );
     AccountKred = FD.ВУ_ПолучитьКатегориюКредит( ВидРО, null, CarryDate, FIID );
  end;

  if( _FIRolePayer != NULL )
     FIRolePayer = _FIRolePayer;
  else
     FIRolePayer = FD.ВУ_ПолучитьРольФИ(ВидРО, true);
  end;

  if( _FIRoleReceiver != NULL )
     FIRoleReceiver = _FIRoleReceiver;
  else
     FIRoleReceiver = FD.ВУ_ПолучитьРольФИ(ВидРО, false);
  end;

  return ПроводкаПоКатегориямУчета( FD,
                                    AccountDeb,
                                    AccountKred,
                                    CarryDate,
                                    FD.ВУ_ОпределениеГлавы(FIID),
                                    FIID,
                                    CarrySumm,
                                    "",
                                    Ground,
                                    FIRolePayer,
                                    FIRoleReceiver,
                                    FIID, FIID,
                                    true,
                                    FD.ВУ_ПолучитьРО(ВидРО),
                                    FDDebetParm, FDCreditParm
                                  );
end;

//////////////////////////////////////////////////////////////////////////////////////

private class ProtocolData(_OperDate:date,
                           _OperCode:string,
                           _AccDeb1:string,
                           _AccCred1:string,
                           _AccTrnSum1:string,
                           _AccDeb21:string,
                           _AccCred21:string,
                           _AccTrnSum21:string,
                           _Msg:string
                          )

  var OperDate    = _OperDate;    
  var OperCode    = _OperCode;  
  var AccDeb1     = _AccDeb1;   
  var AccCred1    = _AccCred1;  
  var AccTrnSum1  = _AccTrnSum1; 
  var AccDeb21    = _AccDeb21; 
  var AccCred21   = _AccCred21;
  var AccTrnSum21 = _AccTrnSum21; 
  var Msg         = _Msg;        
end;

private macro ExistsCorrAccTrn(DocKind:integer, DocID:integer, Payer_Account:string, Receiver_Account:string)
  var query, cmd, DataSet;


  query =   " select 1 "
          + "   from dacctrn_dbt act "
          + "  where act.t_Chapter = 21 "
          + "    and act.t_Ground LIKE 'Кор%' "
          + "    and act.t_FIID_Receiver <> " + NATCUR
          + "    and act.t_Account_Payer = ? "
          + "    and act.t_Account_Receiver = ? "
          + "    and Exists(select 1 "
          + "                 from ddlinacc_dbt inacc "
          + "                where inacc.t_DocumentKind = ? "
          + "                  and inacc.t_DocumentID = ? "
          + "                  and inacc.t_AccTrnID = act.t_AccTrnID "
          + "              ) ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(Payer_Account);
  cmd.AddParam(Receiver_Account);
  cmd.AddParam(DocKind);
  cmd.AddParam(DocID);

  return cmd.GetCount();
end;

private macro DateIsClosed(dt:date, Branch:integer)
  var IsClosed = false;
  var query, cmd, DataSet;

  query =   " select t_IsClosed "
          + "   from dcurdate_dbt "
          + "  where t_Branch = ? "
          + "    and t_CurDate = ? ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(Branch);
  cmd.AddParam(dt);

  DataSet = cmd.Execute();

  if(DataSet.moveNext())
    IsCLosed = IIF(DataSet.IsClosed == SET_CHAR, true, false);
  end;

  return IsClosed;
end;


private macro ChangeCurDate(dt:date, Branch:integer, IsClosed:bool)
  var cmd, query;

  query =   " update dcurdate_dbt "
          + "    set t_IsClosed = " + IIF(IsClosed, "'X'", "CHR(0)")
          + "  where t_Branch = ? "
          + "    and t_CurDate = ? ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(Branch);
  cmd.AddParam(dt);

  cmd.ExecuteCMD();
end;

private macro ChangeAcc(AccRec, NewOpenDate:date, ErrMsg:@string)
  var query, cmd, DataSet;
  var accblnc = TRecHandler("accblnc.dbt");
  var err = 0;

  query = "select * from daccblnc_dbt where t_AccountID = ? ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(AccRec.rec.AccountID);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    DataSet.GetRecord().CopyTo(accblnc.rec);
  else
    ErrMsg = "Не найдена запись в daccblnc_dbt";
    err = 1;
  end;
  
  if(not err)
    var NewDateIsClosed = DateIsClosed(NewOpenDate, AccRec.rec.Department);
    var WasChangeDate = false;
    
    if(AccRec.rec.Open_Date > NewOpenDate)
      AccRec.rec.Open_Date = NewOpenDate;
      WasChangeDate = true;
    end;

    if((WasChangeDate) and (NewDateIsClosed))
      ChangeCurDate(AccRec.rec.Open_Date, AccRec.rec.Department, false);
    end;

    if(index(AccRec.rec.Type_Account, "Н") == 0)
      AccRec.rec.Type_Account = AccRec.rec.Type_Account + "Н"; //Непероцениваемый счет
    end;

    err = Update_AccountEx(AccRec, accblnc);
    if(err)
      ErrMsg = "Ошибка при обновлении счета: " + GetErrMsg();
    else
      if((WasChangeDate) and (NewDateIsClosed))
        ChangeCurDate(AccRec.rec.Open_Date, AccRec.rec.Department, true);
      end;
    end;
  end;

  return err;
end;

MACRO FindAccount( Chapter, FIID, Account, AccBuf, NoSayError )
   file AccR( "account.dbt" );
   var fin = TBFile("fininstr");

   if( (Chapter == null) or (Chapter == 0)) Chapter = 1; end;
   if( FIID == null ) FIID = 0; end;

   if (ПолучитьФинИн( FIID, fin ) == 0)
     if(fin.rec.FI_Kind == FIKIND_AVOIRISS) //по ц/б счет не ищем
       ClearRecord( AccR );

       AccR.Code_Currency = FIID;
       AccR.Account       = Account;
       AccR.Chapter       = Chapter;
       Copy( AccBuf, AccR );
       return true;
     else
       ClearRecord( AccR );
       AccR.Chapter       = Chapter;
       AccR.Code_Currency = FIID;
       AccR.Account       = Account;
       if( GetEQ(AccR) )
          Copy( AccBuf, AccR );
          return true;
       end;
     end;
   end;

   if( NoSayError != true )
      msgbox( "Счет " + Account + " не найден." );
   end;
   return false;
END;

private macro UpdateOneAccTrn(DocKind:integer, DocID:integer, OprCode:string, AccTrnID:integer, Tax:money, ErrMsg:@string, NewAccDeb:@string, NewAccCred:@string, NewSum:@string)
  var accTrn;
  var DebAccount = TRecHandler("account.dbt");
  var CredAccount = TRecHandler("account.dbt");
  var err;
  var FD = NULL;

  ErrMsg = "";

  NewAccDeb  = "";
  NewAccCred = "";
  NewSum     = "";

  DebAccount.Clear(); 
  CredAccount.Clear();

  accTrn = RsbAccTransaction();

  err = accTrn.Find(AccTrnID);
  if(err)
    ErrMsg = "Не найдена проводка с идентификатором " + AccTrnID;
  else

    FD = DLFirstDocNPTXOP(DocKind, DocID);

    if(FindAccount(accTrn.Chapter, accTrn.FIIDPayer, accTrn.AccountPayer, DebAccount, false) == false)
      ErrMsg = "Счет "+accTrn.Account_Payer+" не найден";
      err = 1;
    end;

    if(not err)
      if(FindAccount(accTrn.Chapter, accTrn.FIIDReceiver, accTrn.AccountReceiver, CredAccount, false) == false)
        ErrMsg = "Счет "+accTrn.Account_Receiver+" не найден";
        err = 1;
      end;
    end;

    if(not err)
      err = ChangeAcc(DebAccount, accTrn.Date_Carry);
      if(not err)
        err = ChangeAcc(CredAccount, accTrn.Date_Carry);
      end;
    end;

    if(not err)
      if(ExistsCorrAccTrn(DocKind, DocID, CredAccount.rec.Account, DebAccount.rec.Account))
        return -1;
      end;

      if( not ПроводкаПоКатегориямВнутреннегоУчета( 7, 
                                                    FD, 
                                                    NULL, 
                                                    date(accTrn.Date_Carry), 
                                                    accTrn.FIIDPayer, 
                                                    accTrn.SumPayer,
                                                    null,
                                                    null,
                                                    OprCode,
                                                    "Корректирующая проводка по удержанному налогу",
                                                    CredAccount, DebAccount //Обратная проводка
                                                  ) )
        err = 1;
        ErrMsg = "Ошибка при выполнении проводки: " + GetErrMsg();
      end;

      NewAccDeb  = NewAccDeb  + CredAccount.rec.Account;
      NewAccCred = NewAccCred + DebAccount.rec.Account;
      NewSum     = NewSum     + " " + string(accTrn.SumPayer);
    end;


    if(not err)
      if(not FD.ReOpenAccount( FD.ВУ_ПолучитьКатегориюДебет(7),
                             null,
                             false,
                             FD.ВУ_ПолучитьРольФИ(7, true),
                             DebAccount,
                             date(accTrn.Date_Carry),
                             NATCUR) )
        err = 1;
        ErrMsg = "Не найден счет по категории " + FD.ВУ_ПолучитьКатегориюДебет(7);
      end;
    end;

    if(not err)
      if(not FD.ReOpenAccount( FD.ВУ_ПолучитьКатегориюКредит(7),
                             null,
                             false,
                             FD.ВУ_ПолучитьРольФИ(7, false),
                             CredAccount,
                             date(accTrn.Date_Carry),
                             NATCUR) )
        err = 1;
        ErrMsg = "Не найден счет по категории " + FD.ВУ_ПолучитьКатегориюКредит(7);
      end;
    end;

    if(not err)
      err = ChangeAcc(DebAccount, accTrn.Date_Carry);
      if(not err)
        err = ChangeAcc(CredAccount, accTrn.Date_Carry);
      end;
    end;

    if(not err)
      
      if( not ПроводкаПоКатегориямВнутреннегоУчета( 7, 
                                                    FD, 
                                                    NULL, 
                                                    date(accTrn.Date_Carry), 
                                                    NATCUR, 
                                                    round(Tax),
                                                    null,
                                                    null,
                                                    OprCode,
                                                    "Удержание налога",
                                                    DebAccount, CredAccount
                                                  ) )
        err = 1;
        ErrMsg = "Ошибка при выполнении проводки: " + GetErrMsg();
      end;

      NewAccDeb  = NewAccDeb  + "   " + DebAccount.rec.Account;
      NewAccCred = NewAccCred + "   " + CredAccount.rec.Account;
      NewSum     = NewSum     + "   " + string(round(Tax));
    end;
  end;

  return err;

OnError(er)
  ErrMsg = er.Message;

  return 1;
end;

private macro GetAccountingAccTrnData(DocID, AccDeb:@string, AccCred:@string, SumStr:@string, SumVal:@money)
  var query, cmd, DataSet;

  AccDeb  = "";
  AccCred = "";
  SumStr  = "";
  SumVal  = $0;
  
  query =   " select NVL(LISTAGG(TRIM(acctrn.t_Account_Payer), ' ') WITHIN GROUP (ORDER BY acctrn.t_AccTrnID ASC), CHR(1)) as AccDebStr, "
          + "        NVL(LISTAGG(TRIM(acctrn.t_Account_Receiver), ' ') WITHIN GROUP (ORDER BY acctrn.t_AccTrnID ASC), CHR(1)) as AccCredStr, "
          + "        NVL(LISTAGG(TRIM((acctrn.t_Sum_Payer)), ' ') WITHIN GROUP (ORDER BY acctrn.t_AccTrnID ASC), CHR(1)) as SumStr, "
          + "        NVL(SUM(acctrn.t_Sum_Payer), 0) as SumVal "
          + "   from dnptxop_dbt nptxop, doproper_dbt opr, doprdocs_dbt odoc, dacctrn_dbt acctrn "
          + "  where nptxop.t_ID = ? " 
          + "    and opr.t_DocKind = nptxop.t_DocKind "
          + "    and opr.t_DocumentID = LPAD(nptxop.t_ID, 34, '0')"
          + "    and odoc.t_ID_Operation = opr.t_ID_Operation "
          + "    and odoc.t_DocKind = " + DLDOC_CARRY
          + "    and acctrn.t_AccTrnID = odoc.t_AccTrnID "
          + "    and acctrn.t_Chapter = 1 "
          + "    and acctrn.t_Account_Payer LIKE '306%'"
          + "    and acctrn.t_Account_Receiver LIKE '603%'";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(DocID);

  DataSet = cmd.Execute();

  if(DataSet.moveNext())
    AccDeb  = DataSet.AccDebStr;
    AccCred = DataSet.AccCredStr;
    SumStr  = DataSet.SumStr;
    SumVal  = DataSet.SumVal; 
  end;

end;

private macro ExecUpdateAccTrn()
  var query, cmd, DataSet;
  var i = 0, cnt = 0;
  var err = 0, ErrMsg = "";
  var ProtocolArr = TArray();
  var NewAccDeb  = "";
  var NewAccCred = "";
  var NewSum     = $0;
  var AccDeb  = "";
  var AccCred = "";
  var SumStr  = "";
  var SumVal  = $0;

  if(GetTRUE(FALSE, "Выполнить с фиксацией действий в БД?\n"
                   +"(НЕТ - процедура выполнится в тестовом режиме без сохранения изменений в базе; ДА - все успешные изменения будут сохранены в базе)\n"
                   +"Первый запуск рекомендуется выполнить в тестовом режиме и проверить в протоколе, что процедура выполняется без ошибок."))
    TestMode = false;
  end;

  query =   " select nptxop.t_DocKind, nptxop.t_ID, nptxop.t_Tax, nptxop.t_OperDate, nptxop.t_Code, "
          + "        acctrn.t_AccTrnID, acctrn.t_Sum_Receiver "
          + "   from dnptxop_dbt nptxop, doproper_dbt opr, doprdocs_dbt odoc, dacctrn_dbt acctrn "
          + "  where nptxop.t_DocKind = " + DL_WRTMONEY
          + "    and nptxop.t_OperDate < " + GetSQLDate(date(01,10,2022))
          + "    and nptxop.t_SubKind_Operation = " + DL_NPTXOP_WRTKIND_WRTOFF
          + "    and nptxop.t_Tax <> 0 "
          + "    and nptxop.t_Currency <> " + NATCUR
          + "    and opr.t_DocKind = nptxop.t_DocKind "
          + "    and opr.t_DocumentID = LPAD(nptxop.t_ID, 34, '0')"
          + "    and odoc.t_ID_Operation = opr.t_ID_Operation "
          + "    and odoc.t_DocKind = " + DLDOC_CARRY
          + "    and acctrn.t_AccTrnID = odoc.t_AccTrnID "
          + "    and acctrn.t_Ground LIKE 'Уде%' " 
          + "    and acctrn.t_Chapter = 21 "
          + "    and acctrn.t_FIID_Receiver <> " + NATCUR
          + "    and Exists(select 1 "
          + "                 from dmcaccdoc_dbt accdoc "
          + "                where accdoc.t_CatNum = 533 "
          + "                  and accdoc.t_Account = acctrn.t_Account_Payer "
          + "              ) "
          + " order by acctrn.t_AccTrnID ASC ";

  cmd = DL_RSDCommand(query);

  cnt = cmd.GetCount();
  if(cnt > 0)
    InitProgress(cnt, "Обработка отобранных проводок", "Обработка отобранных проводок");

    DataSet = cmd.Execute();

    i = 0;
    while(DataSet.moveNext())
      err = 0;
      ErrMsg = "";

      NewAccDeb  = "";
      NewAccCred = "";
      NewSum     = $0;

      GetAccountingAccTrnData(DataSet.ID, @AccDeb, @AccCred, @SumStr, @SumVal);

      if(SumVal > 0)
        RslDefCon.BeginTrans();

        err = UpdateOneAccTrn(DataSet.DocKind, DataSet.ID, DataSet.Code, DataSet.AccTrnID, SumVal, @ErrMsg, @NewAccDeb, @NewAccCred, @NewSum);

        if((TestMode) or (err))
          RslDefCon.RollbackTrans();
        else
          RslDefCon.CommitTrans();
        end;
      
        if(err != -1)
          ProtocolArr[ProtocolArr.size] = ProtocolData(date(DataSet.OperDate),
                                                       DataSet.Code,
                                                       AccDeb, 
                                                       AccCred,
                                                       SumStr,    
                                                       NewAccDeb, 
                                                       NewAccCred,
                                                       NewSum,    
                                                       IIF(err != 0, string(err)+ " ", "")+ErrMsg
                                                      );
        end;
      end;
      UseProgress(i = i + 1);
    end;

    RemProgress();
  end;

  InitProgress(ProtocolArr.size(), "Печать протокола", "Печать протокола");

  println("Протокол выправления проводок ВУ по удержанному налогу в операциях списания д/с\n");

  if(ProtocolArr.size() > 0)
    println("");
    println("┌─────────────┬────────────────────────────┬──────────────────────┬──────────────────────┬───────────┬──────────────────────┬──────────────────────┬───────────┬────────────────────────────────────────┐");
    println("│    Дата     │             Код            │   Дебет проводки БУ  │  Кредит проводки БУ  │   Сумма   │   Дебет проводки ВУ  │  Кредит проводки ВУ  │   Сумма   │              Сообщение                 │");
    println("│  операции   │          операции          │                      │                      │проводки БУ│                      │                      │проводки ВУ│                                        │");
    println("├─────────────┼────────────────────────────┼──────────────────────┼──────────────────────┼───────────┼──────────────────────┼──────────────────────┼───────────┼────────────────────────────────────────┤");

    i = 0;
    while(i < ProtocolArr.size())

            [│#############│############################│######################│######################│###########│######################│######################│###########│########################################│]
            (string(ProtocolArr[i].OperDate:f):c,   
             string(ProtocolArr[i].OperCode):c,   
             string(ProtocolArr[i].AccDeb1):c:w,    
             string(ProtocolArr[i].AccCred1):c:w,   
             string(ProtocolArr[i].AccTrnSum1):c:w, 
             string(ProtocolArr[i].AccDeb21):c:w,   
             string(ProtocolArr[i].AccCred21):c:w,  
             string(ProtocolArr[i].AccTrnSum21):c:w,
             string(ProtocolArr[i].Msg):l:w        
            );

      if(i < ProtocolArr.size() - 1)
        println("├─────────────┼────────────────────────────┼──────────────────────┼──────────────────────┼───────────┼──────────────────────┼──────────────────────┼───────────┼────────────────────────────────────────┤");
      end;

      UseProgress(i = i + 1);
    end;

        println("└─────────────┴────────────────────────────┴──────────────────────┴──────────────────────┴───────────┴──────────────────────┴──────────────────────┴───────────┴────────────────────────────────────────┘");
  else
    println("Нет подходящих для обновления проводок.");
  end;

  RemProgress();

OnError(er)
  if(RslDefCon.IsInTrans)
    RslDefCon.RollbackTrans();
  end;

  msgbox("Ошибка: " + er.Message);
end;

ExecUpdateAccTrn();
