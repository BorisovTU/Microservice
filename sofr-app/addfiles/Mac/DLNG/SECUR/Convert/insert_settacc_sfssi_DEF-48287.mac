/** 
 @file  insert_settacc_sfssi_DEF-48287.mac
 @brief Вставка и откат СПИ для счетов ДО

 Набор функций, позволяющий в рамках единовременного запуска вставить недостающие СПИ и откатить их после

 # tag
 - functional_block:Счета
 - code_type:one_time

 # changeLog 
 |date       |author         |tasks            |note                            
 |-----------|---------------|-----------------|--------------------------------------------
 |2023.11.03 |Швецов  Я. А.  |DEF-48287        | Доработка алгоритма определения закрытых счетов
 |2023.10.12 |Швецов  Я. А.  |DEF-48287        | Доработки по итогам ПСИ
 |2023.08.14 |Швецов  Я. А.  |DEF-48287        | Первоначальная реализация

*/

import "dlcontrfunc.mac", or_rep_h, dl_activex;

private var TestMode   = true; //Тестовый режим (без фиксации действий в БД)
private var BackoutMode = false; //Режим отката

// Режим работы: создание/откат создания СПИ
private const MODE_EXECUTE  = 0;
private const MODE_BACKOUT  = 1;

//Колонки отчёта
private const COL_CLIENTCODE  = 1,
              COL_CONTRNYMBER = 2,
              COL_ACCOUNT     = 3,
              COL_SFSSI_ID    = 4,  
              COL_BACKOUT     = 5;

private var TableHeaderTest = "┌───────────────────────────────┬────────────────────────────────┬──────────────────────┐\n" +
                              "│          Код клиента          │         Номер договора         │         Счёт         │\n" +
                              "│                               │                                │                      │\n" +
                              "│                               │                                │                      │\n" +
                              "├───────────────────────────────┼────────────────────────────────┼──────────────────────┤";

private var TableHeader = "┌───────────────────────────────┬────────────────────────────────┬──────────────────────┬──────────────────────┬──────────────────────┐\n" +
                          "│          Код клиента          │         Номер договора         │         Счёт         │       ID СПИ         │        Откат         │\n" +
                          "│                               │                                │                      │                      │                      │\n" +
                          "│                               │                                │                      │                      │                      │\n" +
                          "├───────────────────────────────┼────────────────────────────────┼──────────────────────┼──────────────────────┼──────────────────────┤";

/**
 @brief Класс данных для оформления протокола
*/

PRIVATE CLASS TProtocolData(_ClientName:string, _SfContrNumber:string, _Account:string, _Msg:string, _SettAccID:integer)
  var ClientName     = _ClientName;  
  var SfContrNumber  = _SfContrNumber;
  var Account        = _Account;  
  var Msg            = _Msg;
  var SettAccID      = _SettAccID;
END;

/**
 @brief Однострочный условный оператор
 @param[in] condition    Условие, которое проверяет функция 
 @param[in] value_true   Значение, возвращаемое при условии == true
 @param[in] value_false  Значение, возвращаемое при условии == false
 @return                 Значение value_true или value_false, в зависимости от условия
*/
Private macro IIF(condition, value_true, value_false)
  If(condition)
    return value_true;
  else
    return value_false;
  end;
end;

/**
 @brief Заполнение таблицы логирования
 @param[in]  ActionDate    Дата запуска вставки СПИ
 @param[in]  ActionTime    Время запуска вставки СПИ
 @param[in]  PartyID       ID клиента
 @param[in]  SfContrID     ID договора обслуживания
 @param[in]  McAccDocID    ID записи в таблице DMCACCDOC_DBT
 @param[in]  FIID          Валюта счёта в договоре
 @param[in]  Chapter       Глава счёта в договоре
 @param[in]  Account       Номер счёта в договоре
 @param[in]  ClientName    Имя клиента
 @param[in]  SfContrNumber Номер договора обслуживания
 @param[out] ErrStr        Текст ошибки выполнения функции
 @return                   0 если функция выполнена без ошибок, 1 - если выполнена с ошибками
*/
PRIVATE MACRO AddSAToArhTable(ActionDate:date, ActionTime:time, PartyID:integer, SfContrID:integer, McAccDocID:integer, FIID:integer, Chapter:integer, Account:string, ClientName:string, SfContrNumber:string, ErrStr:@string)
  var query, cmd;

  ErrStr = "";

  query = "INSERT INTO DDEF48287_SFSSI_DBT (    T_ACTIONDATE "         
                                        + "   , T_ACTIONTIME "      
                                        + "   , T_PARTYID "        
                                        + "   , T_SFCONTRID "         
                                        + "   , T_MCACCDOCID "           
                                        + "   , T_FIID "        
                                        + "   , T_CHAPTER "        
                                        + "   , T_ACCOUNT "            
                                        + "   , T_CLIENTNAME "        
                                        + "   , T_SFCONTRNUMBER "   
                                        + "    ) "
           + " VALUES (?,?,?,?,?,?,?,?,?,?) ";


  cmd = DL_RSDCOmmand(query);
  cmd.AddParam(ActionDate    );
  cmd.AddParam(ActionTime    );
  cmd.AddParam(PartyID       );
  cmd.AddParam(SfContrID     );
  cmd.AddParam(McAccDocID    );
  cmd.AddParam(FIID          );
  cmd.AddParam(Chapter       );
  cmd.AddParam(Account       );
  cmd.AddParam(ClientName    );
  cmd.AddParam(SfContrNumber );
  cmd.ExecuteCMD();

  return 0;
OnError(er)
  ErrStr = er.Message;
  return 1;
END;

/**
 @brief Получение системной даты и времени
 @param[out] SystDate Системная дата
 @param[out] SystTime системное время
*/
private macro GetSystDateTime(SystDate:@date, SystTime:@time)
  var cmd = DL_RSDCommand("select sysdate dt from dual");
  var DataSet = cmd.execute();

  DataSet.moveNext();

  DtTmSplit(DataSet.dt, SystDate, SystTime);
end;

/**
 @brief Откат СПИ из базы данных
 @param[out] ErrorText Текст ошибки выполнения функции
 @return               0 если функция выполнена без ошибок, 1 - если выполнена с ошибками
*/
Private macro BackoutSFSSI(ErrorText:@string)  
  var FullNameFile = "";
  var FileName = "";
  var TermPath = GetCurDir(true) + "\\TxtFile";
  var DirName = "";
  var ExtName = "";
  var frow = 6;
  var row = 1;
  var sheet, v_state = true, AlreadyOnTerminal = true;
  var id_tmp = -1;    
  var query, cmd;

  /*Выбираем файл для обработки*/
  if(not SelectFile(FullNameFile, "*.xls*", "Выберите файл для загрузки", 0, true))
    MsgBox("Отказ от загрузки");
    return 0;
  end;

  //Отделяем путь файла от имени
  splitfile(FullNameFile, FileName, ExtName);
  FileName = FileName + ExtName;

  DirName = substr(FullNameFile, 1, index(FullNameFile, FileName) - 1);
  if("$" + DirName + FileName != "$" + TermPath + "\\" + FileName)
    AlreadyOnTerminal = false;
    if (not copyfile("$" + DirName + FileName, "$" + TermPath + "\\" + FileName) )
      ErrorText = "Ошибка при передаче файла на терминал";
      return 1;
    end;
  end;
  /*Открываем файл*/
  BegAction(1, "Обработка файла \"" + TermPath + "\\" + FileName + "\". Ждите...");

  if(not OpenExcelFile(FileName, false, true, TermPath))
    ErrorText = "Ошибка открытия файла \"" + TermPath + "\\" + FileName + "\"";
    EndAction(1);
    return 1;
  end;

  sheet = ExcelApplication.Sheets(1);

  /*Ищем начало таблицы*/
  if(valtype(sheet.cells(frow, 1).value) == V_UNDEF)
    MsgBox("Попытка загрузить пустой файл или файл неправильного формата");
    if (not AlreadyOnTerminal AND (not RemoveFile ("$" + TermPath + "\\" + FileName)))
      ErrorText = "Ошибка удаления файла " + TermPath + "\\" + FileName;
      return 1;
    end;
    return 0;
  end;

  row = frow+1;
  //Проходим по файлу
  InitProgress(-1);
  var i = 0;
  while (v_state) 
    if (valtype(sheet.cells(row, 1).value) == V_UNDEF)
      v_state = false;
      continue;
    else
      if(StrUpr(String(sheet.cells(row, COL_BACKOUT).value)) == SET_CHAR)
        id_tmp = -1;
        id_tmp = int(sheet.cells(row, COL_SFSSI_ID).value);
        query = " DELETE FROM DSFSSI_DBT WHERE T_SETACCID = " + id_tmp;
        cmd = RSDCommand(query);
        cmd.Execute();
        query = " DELETE FROM DSETTACC_DBT WHERE T_SETTACCID = " + id_tmp;
        cmd = RSDCommand(query);
        cmd.Execute();  
      end;
      UseProgress(i);
    end;
    i = i + 1;  
    row = row + 1;
  end;
  RemProgress();

  ExcelApplication.ActiveWorkbook.Close;
  
  if (not AlreadyOnTerminal AND (not RemoveFile ("$" + TermPath + "\\" + FileName)))
    ErrorText = "Ошибка удаления файла " + TermPath + "\\" + FileName;
    return 1;
  end;
  return 0;

onerror()
  if (valtype(ExcelApplication) != V_UNDEF)
    ExcelApplication.ActiveWorkbook.Close;
  end;
  EndAction(1);
  return 1;
End;

/**
 @brief Процедура для добавления и отката СПИ
*/

PRIVATE MACRO ExecUpdateSettAcc()
  var query, cmd, DataSet;
  var cnt = 0, i = 0, settaccid = 0;
  var LogArr = TArray(203000);
  var SystDate, SystTime;
  var err = 0, ErrStr = "";
  var err_cnt = 0;
  var accrec = TRecHandler("account.dbt");
  ClearRecord(accrec);
  var accfile = TBFile("account.dbt", "r", 0);

  //Меню выбора
  var m = TArray();
  m(MODE_EXECUTE) = "Режим вставки СПИ";
  m(MODE_BACKOUT) = "Режим отката СПИ";
  var choice = menu(m);
  if(choice < 0) //Выход из меню
    return 0;
  elif(choice == MODE_EXECUTE) //Создание СПИ  
    if(GetTRUE(FALSE, "Выполнить с фиксацией действий в БД?\n"
                   +"(НЕТ - процедура выполнится в тестовом режиме без сохранения изменений в базе; ДА - все успешные изменения будут сохранены в базе)\n"
                   +"Первый запуск рекомендуется выполнить в тестовом режиме и проверить, что процедура выполнится без ошибок."))
      TestMode = false;
    end;

    GetSystDateTime(@SystDate, @SystTime);
    InitProgress(1, "Отбор записей для создания СПИ", "Отбор записей для создания СПИ");

    query = " SELECT sfcontr.t_number, sfcontr.t_id contrid, mcaccdoc.t_account, mcaccdoc.t_currency, mcaccdoc.t_id mcaccdocid, party.t_shortname, party.t_partyid "
          + "   FROM DSFCONTR_DBT sfcontr, DMCACCDOC_DBT mcaccdoc, DPARTY_DBT party, DACCOUNT_DBT account "
          + "  WHERE (sfcontr.t_dateclose = TO_DATE('01.01.0001','DD.MM.YYYY') OR sfcontr.t_dateclose > " + GetSQLDate(SystDate) +") "
          +"     AND mcaccdoc.t_dockind = 3001 /*договор обслуживания*/ AND mcaccdoc.t_docid = sfcontr.t_id "
          +"     AND mcaccdoc.t_catnum = 201 /*ДС клиента, цб*/ AND party.t_partyid = sfcontr.t_partyid  AND party.t_legalform <> 1 /*Не ЮЛ*/ "
          +"     AND (mcaccdoc.t_disablingdate = TO_DATE('01.01.0001','DD.MM.YYYY') OR mcaccdoc.t_disablingdate > " + GetSQLDate(SystDate) +") "
          +"     AND account.t_account = mcaccdoc.t_account AND account.t_chapter = mcaccdoc.t_chapter AND account.t_code_currency = mcaccdoc.t_currency "
          +"     AND (account.t_close_date = TO_DATE('01.01.0001','DD.MM.YYYY') OR account.t_close_date > " + GetSQLDate(SystDate) +") " 
          +"     AND sfcontr.t_partyid IN (SELECT pn.t_personid FROM DPERSN_DBT pn "
          +"                                WHERE pn.t_personid = sfcontr.t_partyid " 
          +"                                  AND pn.t_isemployer <> CHR(88) /*Не ИП*/ ) " 
          +"     AND NOT EXISTS (SELECT settacc.t_settaccid FROM dsfssi_dbt ssi, dsettacc_dbt settacc "
          +"                      WHERE settacc.t_account = mcaccdoc.t_account " 
          +"                        AND ssi.t_setaccid = settacc.t_settaccid "
          +"                        AND ssi.t_objectid = sfcontr.t_id "
          +"                        AND settacc.t_partyid = sfcontr.t_partyid ) "
          +"     AND ( (sfcontr.t_servkind = 15 /*Срочный рынок*/ AND mcaccdoc.t_currency IN (SELECT fin.t_fiid FROM dfininstr_dbt fin "
          +"                                                                                   WHERE fin.t_fi_code = '810')) "
          +"       OR  (sfcontr.t_servkind <> 15 /*Остальные*/ AND mcaccdoc.t_currency IN (SELECT fin.t_fiid FROM dfininstr_dbt fin "
          +"                                                                                WHERE fin.t_fi_code IN('810','840','978','156','756','826')) ))";
    
    cmd = DL_RSDCommand(query);
    cnt = cmd.GetCount();
    UseProgress(1);  
    RemProgress();
    if(cnt > 0)
      InitProgress(cnt, "Обработка СПИ", "Обработка СПИ");   
      query = query + "  ORDER BY mcaccdoc.t_account ASC ";
      DataSet = cmd.Execute(query);
      while(DataSet.moveNext())
        err = 0;
        settaccid = 0;
        ErrStr = "";
        ClearRecord(accrec);

        accfile.rec.chapter = 1;
        accfile.rec.account = DataSet.Account;
        accfile.rec.code_currency = DataSet.Currency;
        accfile.getEQ();
      
        if( accfile.rec.accountid == 0)
          err = 1;
          ErrStr = "Ошибка поиска в БД записи счёта";
        else
          copy(accrec, accfile);
          var category = "ДС клиента, ц/б";
          var contractid = DataSet.contrid;
          
          RslDefCon.BeginTrans();
          err = AddSaToArhTable(SystDate, SystTime, DataSet.partyid, DataSet.contrid, DataSet.mcaccdocid, DataSet.Currency, 1, DataSet.Account, DataSet.ShortName, DataSet.Number, @ErrStr);
          if(not err)
            err = AddAccToSubContr(category, contractid, accrec, ErrStr, settaccid);
          end;
          if((TestMode) or (err))                        
            RslDefCon.RollbackTrans();
          else
            RslDefCon.CommitTrans();
          end;
        end;
        LogArr[LogArr.size()] = TProtocolData(DataSet.ShortName, DataSet.Number, DataSet.Account, ErrStr, IIF(TestMode, 0, settaccid));
        if(err)
          err_cnt = err_cnt + 1;
        end;

        UseProgress(i = i + 1);
      end;

      RemProgress();

      InitProgress(LogArr.size(), "Печать протокола", "Печать протокола");

      var Rep = CMakeReport(IIF(TestMode, TableHeaderTest, TableHeader));
      Rep.AddPrintCell("Создание СПИ для счетов в клиентских договорах", Rep.GetHeaderWidth(), 0, "c:", REP_ELEM_STR);
      Rep.AddStr();
      Rep.AddPrintCell( "Дата выполнения:", 0, 0, "l", REP_ELEM_STR);
      Rep.AddPrintCell( SystDate:f, 0, 0, "l");
      Rep.AddStr();
      Rep.AddPrintCell( "Время выполнения:", 0, 0, "l", REP_ELEM_STR);
      Rep.AddPrintCell( SystTime, 0, 0, "l");
      Rep.AddStr();
      Rep.AddPrintCell( "Отобрано записей:", 0, 0, "l", REP_ELEM_STR);
      Rep.AddPrintCell( cnt, 0, 0, "l");
      Rep.AddStr();
      Rep.AddPrintCell( "Из них не обработано:", 0, 0, "l", REP_ELEM_STR);
      Rep.AddPrintCell( err_cnt, 0, 0, "l");
      Rep.AddStr();

      i = 0;
      while(i < LogArr.size())
        Rep.AddPrintCell( LogArr[i].ClientName, 0, 0, "c");
        Rep.AddPrintCell( LogArr[i].SfContrNumber, 0, 0, "c");
        Rep.AddPrintCell( LogArr[i].Account, 0, 0, "c");
        if (not TestMode)
          Rep.AddPrintCell( LogArr[i].SettAccID, 0, 0, "c");
          Rep.AddPrintCell( UNSET_CHAR, 0, 0, "c");
        end;
        if(LogArr[i].Msg != "")
          Rep.AddPrintCell( LogArr[i].Msg, 0, 0, "c");
        end;
        Rep.AddStr();

        UseProgress(i = i + 1);
      end;

      RemProgress();
      if(TestMode)
        Rep.PrintRep();
      else
        Rep.PrintWinRep();
        Rep.ShowWinRep();
      end;
    else
      msgbox("Не найдено договоров со счетами без СПИ");
    end;
  elif(choice == MODE_BACKOUT) //Откат СПИ
    if(BackoutSFSSI(@ErrStr))
      println("Ошибка при откате СПИ");
      println(ErrStr);
    else
      println("Откат завершён успешно");    
    end;
  end;

OnError(er)
  if(RslDefCon.IsInTrans)
    RslDefCon.RollbackTrans();
  end;

  msgbox("Ошибка: " + er.Message);
END;

ExecUpdateSettAcc();