/*                           
$Name:             sc_closeacc.mac
$Module:           Ценные бумаги
$Description:      Классы для закрытия счетов для групповых процедур
*/
import BankInter, "dlcnst.inc";
import dlquery, dllog_xml, sp_class;

private const SC_REPORTKIND_ACC_TICK = 1; //по проблемному счету по сделке
private const SC_REPORTKIND_ACC_AVR  = 2; //по проблемному счету по выпуску

//класс с данными для строки протокола по проблемным счетам
class CSC_ProblemAccount(_Kind:integer,
                         _Code:string,
                         _Account:string,
                         _Note:string
)
  var Kind    = _Kind;   //Счет по сделке или выпуску
  var Code    = _Code;   //Код сделки или выпуска
  var Account = _Account;  //Счет
  var Note    = _Note; //Примечание
end;

/*лог проблемных счетов*/
CLASS (DL_LOG_FROM_XML) PROBLEMACC_LOG_FROM_XML(pDocKind:integer, pDocumentID:integer, pType:integer, pOnlyLastReport:bool)

  macro GetDataFromXMLByDocKind()

     var ProblemAcc:CSC_ProblemAccount;

     if( m_ReportVersion == 1 )

        if(DL_ReadTagAttribut(m_child_ReportNumber, "CODE", V_STRING, ProblemAcc.Code) == false)
        end;
        if(DL_ReadTagAttribut(m_child_ReportNumber, "ACCOUNT", V_STRING, ProblemAcc.Account) == false)
        end;
        if(DL_ReadTagAttribut(m_child_ReportNumber, "NOTE", V_STRING, ProblemAcc.Note) == false)
        end;

        return ProblemAcc;
     end;

     return null;
  end;

  initDL_LOG_FROM_XML(pDocKind, pDocumentID, pType, pOnlyLastReport);
END;

// ═════════════════════════════════════════════════════════════
// Базовый класс для закрытия счетов
// ═════════════════════════════════════════════════════════════
class SC_CCloseAccount(dl_comm, kind, sourceType)
   var m_ProblemAccRepDataArr; //массив ошибок закрытия счетов (отдельно от ошибок операции)
   var m_GrDealGrDocArr; // массив связок для отката
   var m_dl_comm;
   var m_Kind, m_SourceType;
   var m_prevAccountID;
   
   // ────────────────────────────────
   // поиск счетов (перегружать)
   // ────────────────────────────────
   macro processAccount()
      return 0;
   end;
   // ────────────────────────────────
   // закрытие счетов
   // ────────────────────────────────
   macro closeAcc(id, acc, chapter, currency, calendId)
      var IsError = false;
      var exec, DataSet;
      var stat = 0;
  
      if (ValType(calendId) != V_INTEGER)
        calendId = DL_GetDefaultCalendar();
      end;

      var closeDate = DL_GetBalanceDateAfterWorkDayByCalendar(m_dl_comm.rec.CommDate, 0, calendId);
  
      exec = DL_RSDCommand("select acc.t_AccountID, acc.t_Open_Close " +
                           "  from daccount_dbt acc        "+
                           " where acc.t_Account       = ? "+
                           "   and acc.t_Chapter       = ? "+
                           "   and acc.t_Code_Currency = ? "
                          );
     
      exec.addParam( acc );
      exec.addParam( chapter );
      exec.addParam( currency );
     
      DataSet = exec.execute();
   
      if( DataSet.MoveNext() )
         if (m_prevAccountID != DataSet.AccountID)
            if( not IsError and (DataSet.Open_Close == "З") )
               this.createError(acc, "Счёт уже закрыт.");
               IsError = true;
            end;

            if( not IsError  )
               if( (stat=CB_CloseAccount(chapter, currency, acc, closeDate, null)) != 0 )
                  var mes = GetErrMsg();
                  if (strlen(mes) == 0)
                     InitError();
                     MemoryError(stat);
                     mes = GetErrMsg();
                  end;
                  
                  this.createError(acc, "Ошибка закрытия счета: "+mes+". Счет не закрыт.");
                  IsError = true;
               end;
     
               if( not IsError )
                  this.createLink(id);
               end;
            end;
         end;
      end;

      m_prevAccountID = DataSet.AccountID;

      onError(er)
         this.createError(acc, exec.GetErrorString(er));
         RunError;
   end;
   // ────────────────────────────────
   // Создать объект ошибки
   // ────────────────────────────────
   macro createError(acc:string, mes:string)
      m_ProblemAccRepDataArr[m_ProblemAccRepDataArr.size] = CSC_ProblemAccount(m_Kind, this.GetCode(), acc, mes);
   end;
   // ────────────────────────────────
   // Установить дату деактивации 
   // ────────────────────────────────
   macro setAccDisablingDate(McAccDocID, CommDate)
      var exec = RSDCommand(" UPDATE dmcaccdoc_dbt "+
                            "    SET t_DisablingDate = ?,"+
                            "        t_IsUsable = chr(0) "+
                            "  WHERE t_ID = ?"      );
      
      exec.addParam( "", RSDBP_IN, CommDate );
      exec.addParam( "", RSDBP_IN, McAccDocID );

      exec.execute();
   end;

     
   // ────────────────────────────────
   // Создать объект для связки
   // ────────────────────────────────
   macro createLink(id)
      var j = m_GrDealGrDocArr.size;
      // Установить дату деактивации
      setAccDisablingDate(id, m_dl_comm.rec.CommDate);

      m_GrDealGrDocArr[j] = TRecHandler("dlgrdoc.dbt");
      
      m_GrDealGrDocArr[j].Clear();
      
      /*Создать связку для отката*/
      m_GrDealGrDocArr[j].rec.GrDealID    = 0;
      m_GrDealGrDocArr[j].rec.DocKind     = 60;/*DLDOC_MCACCDOC*/
      m_GrDealGrDocArr[j].rec.DocID       = id;
      m_GrDealGrDocArr[j].rec.ServDocKind = m_dl_comm.rec.DocKind;
      m_GrDealGrDocArr[j].rec.ServDocID   = m_dl_comm.rec.DocumentID;
      m_GrDealGrDocArr[j].rec.GrpID       = this.GetGrpID();
      m_GrDealGrDocArr[j].rec.SourceType  = m_SourceType;
   end;

   macro SetSourceType(SourceType)
     m_SourceType = SourceType;
   end;

   // ────────────────────────────────
   // получить код сделки или выпуска
   // ────────────────────────────────
   macro GetCode() : string
      return 0;
   end;
   // ────────────────────────────────
   // получить GrpID
   // ────────────────────────────────
   macro GetGrpID() : integer
      return 0;
   end;
   // ────────────────────────────────
   // начать транзакцию
   // ────────────────────────────────
   macro beginTransaction()
      RslDefCon.BeginTrans(); 
   end;
   // ────────────────────────────────
   // завершить транзакцию
   // ────────────────────────────────
   macro endTransaction() : integer
      var dlgrdocCache = RsbSQLInsert("dlgrdoc.dbt");
      var stat = 0;

      if(m_GrDealGrDocArr.size > 0)
         dlgrdocCache.AddRecordArray(m_GrDealGrDocArr);
         if(not dlgrdocCache.insert())
            stat = 1;
         end;
      end;

      if(stat)
         RslDefCon.RollbackTrans(); //Откатить транзакцию
      else
         RslDefCon.CommitTrans(); //Завершить транзакцию

         if( m_ProblemAccRepDataArr.size > 0 )
            DL_SaveDataForReport_XML(m_dl_comm.rec.DocumentID, m_dl_comm.rec.DocKind, m_ProblemAccRepDataArr, LOG_TYPE_DATA);
            m_ProblemAccRepDataArr.size = 0;
         end;
      end;
      return stat;
   end;

   // инициализация
   m_ProblemAccRepDataArr = TArray();
   m_GrDealGrDocArr       = TArray();
   m_dl_comm              = dl_comm;
   m_Kind                 = kind;
   m_prevAccountID        = -1;
   SetSourceType(sourceType);
end;

// ═════════════════════════════════════════════════════════════
// Бухгалтерский Учет
// ═════════════════════════════════════════════════════════════
class (SC_CCloseAccount) SC_CCloseAccountAccounting(dl_comm)
   var m_GrpID = 0, m_DealCode = "";
   

   macro setAccDisablingDate(McAccDocID, CommDate)
     if(m_SourceType == DLGR_SOURCETYPE_ACC_CLOSE_TICK)
       this.setAccDisablingDate(McAccDocID, CommDate);
     end;
   end;

   // ────────────────────────────────
   // Цикл по сделкам 
   // ────────────────────────────────
   macro processDeal()
      var cmd_tick = NULL, DataSet_tick = NULL, stat = 0;
      
      cmd_tick = DL_RSDCommand(" select /*+ leading(grp,grdoc,grdeal,tk) index(tk DDL_TICK_DBT_IDX0) */ grdoc.t_GrpID, tk.t_dealid, tk.t_BofficeKind, tk.t_DealCode " +
                               "   from ddl_tick_dbt tk, ddlgrdeal_dbt grdeal, ddlgrdoc_dbt grdoc, dpmwrtgrp_dbt grp " +
                               "  where grp.t_DocKind = ? " +
                               "    and grp.t_DocID = ? " +
                               "    and grp.t_Department = ? " +
                               "    and grp.t_ErrStatus = 0 " +
                               "    and grdoc.t_GrpID = grp.T_ID " +
                               "    and grdeal.t_ID      = grdoc.t_GrDealID " +
                               "    and tk.t_BOfficeKind = grdeal.t_DocKind " +
                               "    and tk.t_DealID      = grdeal.t_DocID " +
                               "    and not exists(select 1 " +
                               "               from ddlgrdeal_dbt grdeal2 " +
                               "              where grdeal2.t_DocKind = tk.t_BOfficeKind " +
                               "                and grdeal2.t_DocID   = tk.t_DealID " +
                               "                and Exists(select 1 from ddlgracc_dbt gracc " +
                               "                            where gracc.t_GrDealID  = grdeal2.t_ID " +
                               "                              and gracc.t_State     = ? " + /*1*/ 
                               "                              and gracc.t_AccNum    = ? " + /*2*/ 
                               "                          )" +
                               "                  ) " +
                               "    and tk.t_ClientID       = -1 " +
                               "    and grdoc.t_GrpID       = grp.T_ID " +
                               "    and grdoc.t_ServDocKind = ? " +/*4*/
                               "    and grdoc.t_ServDocID   = ? " +/*5*/
                               " group by grdoc.t_GrpID, tk.t_dealid, tk.t_DealCode, tk.t_BofficeKind " +
                               " order by tk.t_DealCode " 
                              );
      
      cmd_tick.AddParam(m_dl_comm.rec.DocKind);
      cmd_tick.AddParam(m_dl_comm.rec.DocumentID);
      cmd_tick.AddParam(m_dl_comm.rec.Division);
      
      cmd_tick.AddParam(DLGRACC_STATE_PLAN);       /*1*/
      cmd_tick.AddParam(DLGR_ACCKIND_ACCOUNTING);  /*2*/
      cmd_tick.AddParam(m_dl_comm.rec.DocKind);    /*4*/
      cmd_tick.AddParam(m_dl_comm.rec.DocumentID); /*5*/

      DataSet_tick = cmd_tick.Execute();

      m_ProblemAccRepDataArr.size = 0;
      while( DataSet_tick.MoveNext() )
         m_GrDealGrDocArr.size = 0;
         stat = 0; // ошибка транзакции закрытия счетов по сделке

         // Начать транзакцию
         this.beginTransaction();
         
         m_GrpID    = DataSet_tick.GrpID;
         m_DealCode = DataSet_tick.DealCode;
         this.processAccount(DataSet_tick.DealID,DataSet_tick.BofficeKind);
         // Завершение транзакции
         stat = this.endTransaction();
      end;
      return stat;

      onError(er)
        if(RslDefCon.IsInTrans)
          RslDefCon.RollbackTrans();
        end;

        msgbox(cmd_tick.GetErrorString(er));
        return 1;
   end;
   
   // ────────────────────────────────
   // поиск счетов
   // ────────────────────────────────
   macro processAccount(dealID, bOfficeKind)
      var exec, DataSet, query;
      var stat = 0;
      var FD = SPFirstDoc(bOfficeKind,dealID);
      

      query =   "with categ as (select t_ID "
              + "                 from dmccateg_dbt "
              + "                where t_LevelType = 1 "
              + "                  and t_UpdateMode = 0 "  /*MCCATEG_UPDATE_MODE_INDIVID*/
              + "              ) "
              + " select q.* "
              + "   from ( SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter, accdoc.t_IsUsable " 
              + "            FROM dmcaccdoc_dbt accdoc, categ " 
              + "           WHERE accdoc.t_CatID          = categ.t_ID "
              + "             AND accdoc.t_IsCommon       = chr(0) " 
              + "             AND (   (accdoc.t_IsUsable       = 'X' AND accdoc.t_DisablingDate  = to_date('01.01.0001','DD.MM.YYYY')) "
              + "                  OR (accdoc.t_IsUsable = CHR(0) AND accdoc.t_DisablingDate = ?)) "  //в т.ч. и те, что были деактивированы в эту дату, т.е. фактически в рамках этой СОБУ
              + "             AND accdoc.t_ActivateDate  <= ? " 
              + "             AND accdoc.t_DocID       = ? " 
              + "             AND accdoc.t_DocKind     = ? "
              + "             AND accdoc.t_Chapter not in(21,22) "
              + "          UNION "
              + "          SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter, accdoc.t_IsUsable " 
              + "            FROM dmcaccdoc_dbt accdoc, categ " 
              + "           WHERE accdoc.t_CatID          = categ.t_ID "
              + "             AND accdoc.t_IsCommon       = chr(0) " 
              + "             AND (   (accdoc.t_IsUsable       = 'X' AND accdoc.t_DisablingDate  = to_date('01.01.0001','DD.MM.YYYY')) "
              + "                  OR (accdoc.t_IsUsable = CHR(0) AND accdoc.t_DisablingDate = ?)) "  //в т.ч. и те, что были деактивированы в эту дату, т.е. фактически в рамках этой СОБУ
              + "             AND accdoc.t_ActivateDate  <= ? " 
              + "             AND accdoc.t_DocID in (select leg.t_ID " 
              + "                                      from ddl_leg_dbt leg " 
              + "                                     where leg.t_DealID = ? " 
              + "                                   ) " 
              + "             AND accdoc.t_DocKind = ? " 
              + "             AND accdoc.t_Chapter not in(21,22) "
              + "          UNION "
              + "          SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter, accdoc.t_IsUsable " 
              + "            FROM dmcaccdoc_dbt accdoc, categ " 
              + "           WHERE accdoc.t_CatID          = categ.t_ID "
              + "             AND accdoc.t_IsCommon       = chr(0) " 
              + "             AND (   (accdoc.t_IsUsable       = 'X' AND accdoc.t_DisablingDate  = to_date('01.01.0001','DD.MM.YYYY')) "
              + "                  OR (accdoc.t_IsUsable = CHR(0) AND accdoc.t_DisablingDate = ?)) "  //в т.ч. и те, что были деактивированы в эту дату, т.е. фактически в рамках этой СОБУ
              + "             AND accdoc.t_ActivateDate  <= ? " 
              + "             AND accdoc.t_DocID in (select min(ens.t_id) " 
              + "                                      from ddl_tick_ens_dbt ens " 
              + "                                     where ens.t_dealid = ? " 
              + "                                     group by ens.t_fiid " 
              + "                                   ) " 
              + "             AND accdoc.t_DocKind = ? " 
              + "             AND accdoc.t_Chapter not in(21,22) "
              + "        ) q "
              + "  order by q.t_Chapter, q.t_Account, q.t_Currency "; 

      
      exec = DL_RSDCommand(query);

      exec.addParam( m_dl_comm.rec.CommDate );
      exec.addParam( m_dl_comm.rec.CommDate );
      exec.addParam( dealID );
      exec.addParam( bOfficeKind );

      exec.addParam( m_dl_comm.rec.CommDate );
      exec.addParam( m_dl_comm.rec.CommDate );
      exec.addParam( dealID );
      exec.addParam( DL_SECURLEG );

      exec.addParam( m_dl_comm.rec.CommDate );
      exec.addParam( m_dl_comm.rec.CommDate );
      exec.addParam( dealID );
      exec.addParam( DL_TICK_ENS_DOC ); /*обеспечение по сделке*/

      DataSet = exec.execute();
      while( DataSet.MoveNext() )
        if(DataSet.IsUsable == SET_CHAR)
          this.SetSourceType(DLGR_SOURCETYPE_ACC_CLOSE_TICK);
        else
          this.SetSourceType(DLGR_SOURCETYPE_ACC_ONLYCLOSE_TICK); 
        end; 
         
        this.closeAcc(DataSet.ID, DataSet.Account, DataSet.Chapter, DataSet.Currency, FD.ПолучитьКалендСвязанный());
      end;

      return stat;

      onError(er)
        msgbox(exec.GetErrorString(er));
        RunError;
   end;

   // ────────────────────────────────
   // получить код сделки (для ошибки)
   // ────────────────────────────────
   macro GetCode() : string
      return m_DealCode;
   end;
   // ────────────────────────────────
   // получить GrpID
   // ────────────────────────────────
   macro GetGrpID() : integer
      return m_GrpID;
   end;

   initSC_CCloseAccount(dl_comm, SC_REPORTKIND_ACC_TICK, DLGR_SOURCETYPE_ACC_CLOSE_TICK);
end;

// ═════════════════════════════════════════════════════════════
// Счета ЦБ
// ═════════════════════════════════════════════════════════════
class (SC_CCloseAccount) SC_CCloseAccountSecurity(dl_comm)
   var m_FICode = "";
   
   // ────────────────────────────────
   // поиск счетов
   // ────────────────────────────────
   macro processAccount(FIID, FI_Code)
      var exec, DataSet, i = 0, CntDataSet = 0;
      var stat = 0;

      m_FICode = FI_Code;

      exec = DL_RSDCommand("SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter " +
                           "  FROM dmcaccdoc_dbt accdoc, dmccateg_dbt categ " +
                           " WHERE accdoc.t_CatID          = categ.t_ID AND "+
                           "       accdoc.t_FIID           = ? AND " + 
                           "       accdoc.t_IsCommon       = chr(0) AND " +
                           "       accdoc.t_IsUsable       = 'X' AND " +
                           "       accdoc.t_DisablingDate  = to_date('01.01.0001','DD.MM.YYYY') AND " +
                           "       accdoc.t_ActivateDate  <= ? AND " +
                           /*проверяем параметризацию по FIID (MCCATEG_ATTRMASK_FIID)*/
                           "       mod(categ.t_attrmask,2) = 1 AND "+
                           "       accdoc.t_Chapter not in(21,22) AND "+
                           "       categ.t_code not in ('+Изм.кап., суборд.ОЭБ','-Изм.кап., суборд.ОЭБ', '-Форвард, прочие', '+Форвард, прочие') "+
                           " order by accdoc.t_Chapter, accdoc.t_Account, accdoc.t_Currency"
                          );

      exec.addParam(FIID);
      exec.addParam(m_dl_comm.rec.CommDate);

      CntDataSet = exec.GetCount();
      DataSet = exec.execute();

      if( int(CntDataSet) > 0 )
         
         this.beginTransaction();

         InitProgress( CntDataSet, "Закрытие счетов по выпускам", "Закрытие счетов по выпускам" );

         while( DataSet.MoveNext() )
            this.closeAcc(DataSet.ID, DataSet.Account, DataSet.Chapter, DataSet.Currency);
        
            UseProgress(i = i + 1);
         end;

         stat = this.endTransaction();

         RemProgress();
      end;
      return stat;

      onError(er)
        if(RslDefCon.IsInTrans)
          RslDefCon.RollbackTrans();
        end;

        msgbox(exec.GetErrorString(er));
        return 1;
   end;

   // ────────────────────────────────
   // получить код ЦБ (для ошибки)
   // ────────────────────────────────
   macro GetCode() : string
      return m_FICode;
   end;

   initSC_CCloseAccount(dl_comm, SC_REPORTKIND_ACC_AVR, DLGR_SOURCETYPE_ACC_CLOSE_FI);
end;

// ═════════════════════════════════════════════════════════════
// Внутренний Учет
// ═════════════════════════════════════════════════════════════
class (SC_CCloseAccount) SC_CCloseAccountInAcc(dl_comm)
   var m_FICode = "";
   // ────────────────────────────────
   // Цикл по сделкам
   // ────────────────────────────────
   macro processDeal()
      var cmd = NULL, query = "", DataSet = NULL, stat = 0;
  
      query = "WITH grd AS ( SELECT GrDeal.t_DocID " +
              "                FROM ddlgrdoc_dbt GrDoc, ddlgrdeal_dbt GrDeal " +
              "               WHERE GrDoc.t_ServDocKind  = ? " + /*1*/
              "                 AND GrDoc.t_ServDocID    = ? " + /*2*/
              "                 AND GrDoc.t_DocKind = 0 " +
              "                 AND GrDeal.t_ID = GrDoc.t_GrDealID " + 
              "                 AND GrDeal.t_DocKind = " + DL_RETIREMENT +
              "                 AND GrDeal.t_Templnum = " + DLGR_TEMPL_DELIVERY + 
              "            ) " +
              "SELECT DISTINCT Tick.t_PFI, fin.t_FI_Code, Tick.t_BOfficeKind, Tick.t_Dealid " +
              "  FROM ddl_tick_dbt Tick, grd, doprkoper_dbt Opr, dfininstr_dbt fin" +
              " WHERE Tick.t_DealID = grd.t_DocID " + 
              "   AND Opr.t_Kind_Operation = Tick.t_DealType" +
              "   AND Rsb_Secur.IsRet_Issue(Rsb_Secur.get_OperationGroup(Opr.t_SysTypes))=1" + //погашение ц/б
              "   AND fin.t_FIID = Tick.t_PFI ";

      cmd = DL_RSDCommand(query);

      cmd.AddParam(m_dl_comm.rec.DocKind);    /*1*/
      cmd.AddParam(m_dl_comm.rec.DocumentID); /*2*/

      DataSet = cmd.Execute();
      m_ProblemAccRepDataArr.size = 0;
      while( DataSet.MoveNext() )
         m_GrDealGrDocArr.size = 0;
         stat = 0; // ошибка транзакции закрытия счетов по сделке

         // Начать транзакцию
         this.beginTransaction();
         
         m_FICode = DataSet.FI_Code;
         this.processAccount(DataSet.PFI, DataSet.DealID, DataSet.BOfficeKind);

         // Завершение транзакции
         stat = this.endTransaction();
      end;
      return stat;

      onError(er)
        if(RslDefCon.IsInTrans)
          RslDefCon.RollbackTrans();
        end;
        msgbox(cmd.GetErrorString(er));
        return 1;
   end;
   
   // ────────────────────────────────
   // поиск счетов
   // ────────────────────────────────
   macro processAccount(FIID, DealID, BOfficeKind)
      var cmd_mcacc, DataSet_mcacc;
      var stat = 0;
      //28.11.19 RAS id:500184 Закрытие всех счетов при погашении ц/б.                         
      cmd_mcacc = DL_RSDCommand( "SELECT accdoc.t_ID, accdoc.t_Account, accdoc.t_Currency, accdoc.t_Chapter " +
                                 "  FROM dmcaccdoc_dbt accdoc, dmccateg_dbt categ, daccount_dbt acc, drestdate_dbt rest " +
                                 " WHERE accdoc.t_FIID           = ? " +  /*1*/
                                 "   AND accdoc.t_Account = acc.t_Account " +
                                 "   AND acc.t_accountid = rest.t_accountid " +
                                 "   AND rest.t_restdate = (Select max(re1.t_restdate) from drestdate_dbt re1 where re1.t_accountid = rest.t_accountid) " + 
                                 "   AND rest.t_rest = 0 " +
                                 "   AND acc.t_open_close <> 'X' " + 
                                 "   AND acc.t_close_date = TO_DATE ('01.01.0001', 'dd.mm.yyyy') " +
                                 "   AND accdoc.t_IsCommon       = chr(0) " +
                                 "   AND accdoc.t_IsUsable       = 'X' " +
                                 "   AND accdoc.t_DisablingDate  = to_date('01.01.0001','DD.MM.YYYY') " +
                                 "   AND accdoc.t_ActivateDate  <= ? " + /*2*/
                                 //"   AND accdoc.t_DocID          = ? " + /*3*/
                                 //"   AND accdoc.t_DocKind        = ? " + /*4*/
                                 "   AND categ.t_ID              = accdoc.t_CatID "+
                                 "   AND categ.t_Code in ('ЦБ Банка, ВУ', 'ЦБ Клиента, ВУ', 'ЦБ, Прч. счета банка, ВУ', 'ЦБ, Расч. с клиентом, ВУ') "
                                 " ORDER BY accdoc.t_Chapter, accdoc.t_Account, accdoc.t_Currency "
                               );

      cmd_mcacc.addParam( FIID );                  /*1*/
      cmd_mcacc.addParam( m_dl_comm.rec.CommDate );/*2*/
      //cmd_mcacc.addParam( DealID );/*3*/
      //cmd_mcacc.addParam( BOfficeKind );/*4*/
      
      DataSet_mcacc = cmd_mcacc.execute();

      while( DataSet_mcacc.MoveNext() )
         this.closeAcc(DataSet_mcacc.ID, DataSet_mcacc.Account, DataSet_mcacc.Chapter, DataSet_mcacc.Currency);
      end;

      return stat;

      onError(er)
        msgbox(cmd_mcacc.GetErrorString(er));
        RunError;
   end;

   // ────────────────────────────────
   // получить код сделки (для ошибки)
   // ────────────────────────────────
   macro GetCode() : string
      return m_FICode;
   end;
   // ────────────────────────────────
   // получить GrpID
   // ────────────────────────────────
   macro GetGrpID() : integer
      return 0;
   end;

   initSC_CCloseAccount(dl_comm, SC_REPORTKIND_ACC_AVR, DLGR_SOURCETYPE_ACC_CLOSE_FI);
end;

// ────────────────────────────────────────────
// Печать протокола закрытия счетов по выпускам
// ────────────────────────────────────────────
macro ReportProtocolCloseAcc_FI(report:object, dl_comm:TRecHandler, sheetName:string):integer
   private var N5TableHeader2 = "┌─────────────────────────────┬─────────────────────────┬─────────────────────────────────────────────┐\n"+
                                "│            Выпуск           │           Счет          │                  Примечание                 │\n"+
                                "├─────────────────────────────┼─────────────────────────┼─────────────────────────────────────────────┤";

   var IsFirstUse = true;
   var DataSet, cmd, stat;

   var ReportLineData_XML:variant;
   var ProblemAccData:CSC_ProblemAccount;
   var cnt_closeacc = 0;
  /* в главном классе!!!!!!!
   PrintFormatString(N5BlockHeader,
                    "N5_BlockHeader", "Закрытие лицевых счетов по выпускам");
   CopyAllSheetInTotalBook( SheetName, false, "N5_BlockHeader", 0, SheetName );*/
   /*сначала печатаем информацию по проблемным счетам, которые была попытка закрыть*/
   IsFirstUse = true;

   ReportLineData_XML = PROBLEMACC_LOG_FROM_XML(dl_comm.rec.DocKind, dl_comm.rec.DocumentID, LOG_TYPE_DATA, false);
   ReportLineData_XML.SetReportNumber(SC_REPORTKIND_ACC_AVR);

   stat = ReportLineData_XML.Next;
   while( stat )
      if(IsFirstUse)

         report.CopyAllSheetInTotalBook( sheetName, false, "N5_TableHeader2", 0, sheetName );
         report.RegisterTable( "N5_MainTable2",  N5TableHeader2,
                               "N5_FI_Code",   
                               "N5_FI_Account",    
                               "N5_FI_Note"
                             );

         IsFirstUse = false;
      end;

      ProblemAccData = ReportLineData_XML.GetReportLineData();

      report.PrintTableLine( "N5_FI_Code:c",  ProblemAccData.Code,    null,
                             "N5_FI_Account", ProblemAccData.Account, null,
                             "N5_FI_Note:w",  ProblemAccData.Note,    null
                           );

      cnt_closeacc = cnt_closeacc + 1;

      stat = ReportLineData_XML.Next;
   end;

   /*далее печатаем информацию по закрытым счетам*/
   cmd = DL_RSDCommand( "select acc.t_Account, fin.t_FI_Code "+
                        "  from dmcaccdoc_dbt acc, ddlgrdoc_dbt grdoc, dfininstr_dbt fin "+
                        " where grdoc.t_ServDocKind = ? "+
                        "   and grdoc.t_ServDocID = ? "+
                        "   and grdoc.t_DocKind = ? "+
                        "   and grdoc.t_DocID = acc.t_ID "+
                        "   and grdoc.t_SourceType = ? "+
                        "   and fin.t_FIID = acc.t_FIID "+
                        " group by fin.t_FI_Code, acc.t_Account "+
                        " order by fin.t_FI_Code, acc.t_Account "
                      );
   
   cmd.AddParam(dl_comm.rec.DocKind);
   cmd.AddParam(dl_comm.rec.DocumentID);
   cmd.AddParam(60/*DLDOC_MCACCDOC*/);
   cmd.AddParam(DLGR_SOURCETYPE_ACC_CLOSE_FI);

   DataSet = cmd.Execute();

   while( DataSet.moveNext() )

      if(IsFirstUse)

         report.CopyAllSheetInTotalBook( sheetName, false, "N5_TableHeader2", 0, sheetName );
         report.RegisterTable( "N5_MainTable2",  N5TableHeader2,
                               "N5_FI_Code",   
                               "N5_FI_Account",    
                               "N5_FI_Note"
                             );

         IsFirstUse = false;
      end;

      report.PrintTableLine( "N5_FI_Code:c",  DataSet.FI_Code, null,
                             "N5_FI_Account", DataSet.Account, null,
                             "N5_FI_Note:w",  "",              null
                           );

      cnt_closeacc = cnt_closeacc + 1;

   end;
                                          
   return cnt_closeacc;
end;