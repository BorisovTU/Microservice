/*
$Name:        cdrecords_sheduler.mac
$Module:      Ценные бумаги
$Description: Запуск плановой процедуры "Обработка выплат по погашению ц/б из Диасофта"
*/
import "sprepfun.mac", "sqlconv.mac", "CbReport_h.mac", "scsrvrepfun.mac", "func_lib.mac", "cdrecordsrun.mac";

private const SS_RESPONSE_END = 3; /* Успешное завершение всего сервиса */
private const SS_RESPONSE_FATAL = 4; /* Ошибка исполнения, обработка всей цепочки прерывается */

class c_ssRunResult_CdRecords(p_ProcessState, p_ErrorNumber, p_ErrorText)
  var ProcessState = p_ProcessState;
  var ErrorNumber = p_ErrorNumber;
  var ErrorText = p_ErrorText;
end;

private macro ExecActiveRec(cdrec)
  var query, cmd, DataSet;
  var cdr_f = TBFile("cdrecords.dbt");
  var prev_cdrec = TRecHandler("cdrecords.dbt");
  var cancel_cdrec = TRecHandler("cdrecords.dbt");

  //найти по T_RECORDPAYMENTID предыдущую  выплату в статусе "активна" (при этом если их несколько, то взять самую последнюю с самой поздней датой запроса).
  query =   " select TO_CHAR(t_ID) as ID_str "
          + "   from dcdrecords_dbt "
          + "  where t_RecordPaymentID = ? "
          + "    and (t_RequestDate < ? or (t_RequestDate = ? and t_RequestTime < ?))"
          + "    and t_ID <> ? "
          + "    and LOWER(TRIM(t_OperationStatus)) = 'активна' "
          + "  order by t_RequestDate DESC, t_RequestTime DESC, t_ID DESC ";


  cmd = DL_RSDCommand(query);

  cmd.AddParam(cdrec.rec.RecordPaymentID);
  cmd.AddParam(cdrec.rec.RequestDate);
  cmd.AddParam(cdrec.rec.RequestDate);
  cmd.AddParam(cdrec.rec.RequestTime);
  cmd.AddParam(cdrec.rec.ID);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    //если предыдущая выплата найдена, то найти по T_RECORDPAYMENTID также запись об отмене выплаты, где 
    //дата запроса предыдущей выплаты < дата запроса на отмену <= новой выплаты, которая в работе у планировщика
    cdr_f.Clear();
    cdr_f.rec.ID = bigint(DataSet.ID_str);

    if(not cdr_f.GetEQ())
      msgbox("Не найдена запись с ID = " + DataSet.ID_str);
      return 1;
    else
      copy(prev_cdrec, cdr_f);
    end;

    var q, ds, cmd1;

    q =   " select TO_CHAR(t_ID) as ID_str "
        + "   from dcdrecords_dbt "
        + "  where t_RecordPaymentID = ? "
        + "    and (t_RequestDate > ? or (t_RequestDate = ? and (t_RequestTime > ? or (t_RequestTime = ? and t_ID > ? )))) "
        + "    and (t_RequestDate < ? or (t_RequestDate = ? and (t_RequestTime < ? or (t_RequestTime = ? and t_ID < ? )))) "
        + "    and LOWER(TRIM(t_OperationStatus)) = 'отменена' ";

    cmd1 = DL_RSDCommand(q);

    cmd1.AddParam(cdrec.rec.RecordPaymentID);
    cmd1.AddParam(prev_cdrec.rec.RequestDate);
    cmd1.AddParam(prev_cdrec.rec.RequestDate);
    cmd1.AddParam(prev_cdrec.rec.RequestTime);
    cmd1.AddParam(prev_cdrec.rec.RequestTime);
    cmd1.AddParam(prev_cdrec.rec.ID);
    cmd1.AddParam(cdrec.rec.RequestDate);
    cmd1.AddParam(cdrec.rec.RequestDate);
    cmd1.AddParam(cdrec.rec.RequestTime);
    cmd1.AddParam(cdrec.rec.RequestTime);
    cmd1.AddParam(cdrec.rec.ID);

    ds = cmd1.Execute();
    if(ds.moveNext())
      cdr_f.Clear();
      cdr_f.rec.ID = bigint(ds.ID_str);

      if(not cdr_f.GetEQ())
        msgbox("Не найдена запись с ID = " + ds.ID_str);
        return 1;
      else
        copy(cancel_cdrec, cdr_f);
      end;
      
      if(cancel_cdrec.rec.Status == CDRECORDS_STATUS_PROCESSED) // если найдена запись об отмене в статусе = Обработано
        //выполняет обработку текущей выплаты согласно сценарию 1
        ExecCDRecords(cdrec.rec.ID, true);
      elif((cancel_cdrec.rec.Status != CDRECORDS_STATUS_PROCESSED) and (prev_cdrec.rec.Status == CDRECORDS_STATUS_PROCESSED)) //если найдена отмена в статусе <> Обработано и предыдущая выплата в статусе = Обработано
        //сравнить параметры предыдущей и текущей выплаты
        if((cdrec.rec.PaymentDate == prev_cdrec.rec.PaymentDate) and (cdrec.rec.ClientSum == prev_cdrec.rec.ClientSum) and (cdrec.rec.ISINRegistrationNumber == prev_cdrec.rec.ISINRegistrationNumber)) //если параметры выплат совпадают, то
          //проставить записи об отмене статус  = Обработано
          //проставить текущей записи статус = Обработано
          SetErrorStatus(cancel_cdrec, CDRECORDS_STATUS_PROCESSED, "");
          SetErrorStatus(cdrec, CDRECORDS_STATUS_PROCESSED, "");
        else //если параметры выплат НЕ совпадают, то 
          //сначала обработать отмену согласно сценарию 2, затем обработать новую выплату согласно сценарию 1.
          //При этом, если при обработке отмены возникла ошибка (Не найдены НДР или Не найдена выплата), то 
          //отмена остается в статусе Ошибка с соответствующим текстом ошибки и далее обработать новую выплату согласно  сценарию 1.
          ExecCDRecords(cancel_cdrec.rec.ID, true);
          ExecCDRecords(cdrec.rec.ID, true);
        end;
      elif((cancel_cdrec.rec.Status != CDRECORDS_STATUS_PROCESSED) and (prev_cdrec.rec.Status != CDRECORDS_STATUS_PROCESSED)) //если найдена отмена в статусе <> Обработано и предыдущая выплаты в статусе <> Обработано
        //проставить предыдущей выплате статус = Отклонено и текст ошибки "Найдена более поздняя выплата" 
        //проставить записи об отмене статус = Отклонено и текст ошибки "Найдена более поздняя выплата" 
        //обработать текущую выплату согласно сценарию 1

        SetErrorStatus(prev_cdrec, CDRECORDS_STATUS_REJECTED, "Найдена более поздняя выплата");
        SetErrorStatus(cancel_cdrec, CDRECORDS_STATUS_REJECTED, "Найдена более поздняя выплата");
        ExecCDRecords(cdrec.rec.ID, true);
      end;
    else
      //если НЕ найдена запись об отмене 

      if(prev_cdrec.rec.Status == CDRECORDS_STATUS_PROCESSED) //и предыдущая выплата в статусе = Обработано
        q =   " select obj.* "
            + "   from dnptxobj_dbt obj "
            + "  where obj.t_OutSystCode = 'DEPO' "
            + "    and obj.t_OutObjID = TO_CHAR(?)"
            + "    and obj.t_Kind = " + TXOBJ_MAIN
            + "    and Exists(select 1 from dcdnptxobdc_dbt dc where dc.t_ObjID = obj.t_ObjID and dc.t_RecID = ?)"
            + "    and rownum = 1 ";

        cmd1 = DL_RSDCommand(q);

        cmd1.AddParam(prev_cdrec.rec.RecordPaymentQtyID);
        cmd1.AddParam(prev_cdrec.rec.ID);

        ds = cmd1.Execute();
        if(ds.moveNext())
          //если по предыдущей выплате есть сформированные НДР Main
          //проставить текущей записи статус = Ошибка обработки 
          //указать текст ошибки "Дубликат выплаты. Предыдущая выплата не отменена" 
          //обработку текущей записи по сценарию 1 НЕ ВЫПОЛНЯТЬ
          SetErrorStatus(cdrec, CDRECORDS_STATUS_PROCESSING_ERROR, "Дубликат выплаты. Предыдущая выплата не отменена");
        else
          //если по предыдущей выплате НЕТ сформированных НДР Main, то
          //проставить предыдущей записи статус = Отклонено
          //указать текст ошибки "Найдена более поздняя выплата" 
          //обработать текущую выплату согласно сценарию 1
          SetErrorStatus(prev_cdrec, CDRECORDS_STATUS_REJECTED, "Найдена более поздняя выплата");
          ExecCDRecords(cdrec.rec.ID, true);
        end;
      elif(prev_cdrec.rec.Status != CDRECORDS_STATUS_PROCESSED) //а предыдущая выплата в статусе <> Обработано
        //проставить предыдущей выплате статус = Отклонено
        //указать текст ошибки "Найдена более поздняя выплата"
        //обработать текущую выплату согласно сценарию 1
        SetErrorStatus(prev_cdrec, CDRECORDS_STATUS_REJECTED, "Найдена более поздняя выплата");
        ExecCDRecords(cdrec.rec.ID, true);
      end;
    end;

  else
    //Если предыдущей выплаты нет, то выполнить обработку текущей выплаты согласно сценарию 1.
    ExecCDRecords(cdrec.rec.ID, true);
  end;

end;

macro ExecCdRecords_Shed()
  var query, cmd, DataSet;
  var cdr_f = TBFile("cdrecords.dbt");
  var cdrec = TRecHandler("cdrecords.dbt");
  var N = СрокОбработкиВыплатыПриПогашенииЦБ();

  query =   " select TO_CHAR(t_ID) as ID_str "
          + "   from dcdrecords_dbt "
          + "  where t_RequestDate >= trunc(sysdate) - ? "
          + "    and LOWER(TRIM(t_CorporateActionType)) IN ('redm', 'bput') "
          + "    and t_Status = " + CDRECORDS_STATUS_NEW
          + "    and LOWER(TRIM(t_OperationStatus)) = 'активна' "
          + " order by t_RequestDate ASC, t_RequestTime ASC, t_ID ASC ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(N);

  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    cdr_f.Clear();
    cdr_f.rec.ID = bigint(DataSet.ID_str);

    if(not cdr_f.GetEQ())
      msgbox("Не найдена запись с ID = " + DataSet.ID_str);
      return 1;
    else
      copy(cdrec, cdr_f);
    end;

    ExecActiveRec(cdrec);
  end;

  //запускаем обработку всех t_CorporateActionType=INTR в dcdrecords_dbt, которая вынесена в ХП
  query = " { CALL RSB_DIASOFT.MakeTaxObjForINTR(? /*срок обработки выплат по погашению*/) } ";
  cmd = RsdCommand( query );
  cmd.AddParam("", RSDBP_IN, N);
  cmd.execute();

  return c_ssRunResult_CdRecords(SS_RESPONSE_END);
OnError(e)
  return c_ssRunResult_CdRecords(SS_RESPONSE_FATAL, 1, e.message);
end;
