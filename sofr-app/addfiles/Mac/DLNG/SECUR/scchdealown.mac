/*
$Name:        scchdealown.mac
$Module:      Ценные бумаги
$Description: Шаг изменения условий сделки\отказа от сделки ВО
*/
import InsCarryDoc, "sp_class.mac", "sp_car.mac", "sp_carcm.mac", "scchdate.mac", "sp_grfun.mac", "screpocalc.mac";

/*глобальные структуры, через которые передаются изменения условий сделок*/
private record SpChangeDlTick("dl_tick.dbt");      /*условия сделки*/
private record SpChangeDlLeg("dl_leg.dbt");        /*условия первой части сделки*/
private record SpChangeDlLegBack("dl_leg.dbt");    /*условия второй части сделки*/
private record SpChildDlLeg("dl_leg.dbt");         /*условия первой части дочерней сделки*/
private record SpChangePmwrtsum("pmwrtsum.dbt");   /*лот по 1 части*/

private var SpChangeRq = TArray; //Массив всех ТО

/*сумма в операции учета купона*/
private var COUPON_SUM;
private var CalcSumFIID;
private var CalcOperDate;
private var CalcPlanDate;
private var CalcWrtTime;
private var UniqStr = TUniqStrCollector;
private var ReturnIncomeKind = 0;

private macro replan_date( FD, KindDate )
   if( FD.DateArray[KindDate] != null )
      if( (OprReplanStepPlanDates( FD.GetKindDate(KindDate), FD.DateArray[KindDate] ) == false ) )
         msgbox("Ошибка при попытке переинициализировать дату");         
         return false;
      else
         return true;
      end;
   else
      return true;
   end;
end;

/*перепланировка дат шагов при отказе от сделки\2ч*/
private macro replan_date_reject( FD, RejectDate )

   FD.DateArray[DATE_DEALBEGINEXEC] = RejectDate;
   if( replan_date( FD, DATE_DEALBEGINEXEC ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALEEND] = RejectDate;
   if( replan_date( FD, DATE_DEALEEND ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALTRANSFER] = RejectDate;
   if( replan_date( FD, DATE_DEALTRANSFER ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALCOMISS] = RejectDate;
   if( replan_date( FD, DATE_DEALCOMISS ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALSETAVOIRISS] = RejectDate;
   if( replan_date( FD, DATE_DEALSETAVOIRISS ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALPAY] = RejectDate;
   if( replan_date( FD, DATE_DEALPAY ) == false )
      return false;
   end;

   FD.DateArray[DATE_DEALEXEC] = RejectDate;
   if( replan_date( FD, DATE_DEALEXEC ) == false )
      return false;
   end;

   return true; 
end;

private record acc1(account);
private record acc2(account);

private macro СделкаНаВнебалансе( FD )
   return (FD.dl_leg.rec.OperState == DL_LEG_OUTBAL);
end;

private macro ЗакрытьОдноТО( FD, Type, dat )
  if( (FD.ExistsRQ(Type)) and (FD.GetRQ(Type).rec.State != DLRQ_STATE_EXEC)) 
    FD.GetRQ(Type).rec.State = DLRQ_STATE_REJECT;
    FD.GetRQ(Type).rec.FactDate = dat;    
  end;
end;

private macro ЗакрытьТО( FD, dat )
   
   ЗакрытьОдноТО( FD, DLRQ_TYPE_PAYMENT, dat );

   var ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
   var j:integer = 0;
   while( j < ArrFIID.size )
      FD.SetCurPFI(ArrFIID(j));
      ЗакрытьОдноТО( FD, DLRQ_TYPE_DELIVERY, dat );
      j = j + 1;
   end;

   ЗакрытьОдноТО( FD, DLRQ_TYPE_AVANCE, dat );
   ЗакрытьОдноТО( FD, DLRQ_TYPE_DEPOSIT, dat );
   ЗакрытьОдноТО( FD, DLRQ_TYPE_INCREPO, dat );

   return true;
end;

private macro SaveRQ( FD, FD2, dat:date )
  FD.SaveChangedRQ(dat);
  if( ValType(FD2) != V_UNDEF )
    FD2.SaveChangedRQ(dat);
  end;
end;

/*проверим - нужно ли проверять дату ТО*/
private macro RqDateNeedCheck( rq )

   /*ТО не исполнено, не просрочен и не отложен*/
   if( (ТОЗакрыто(rq) == false) AND 
       (rq.rec.State != DLRQ_STATE_DELAYED ) AND (rq.rec.State != DLRQ_STATE_OVERDUE) )
      return true;
   else
      return false;
   end;
end;

private macro ПроверитьПлановыеДатыСделки( FD, Dat )

   var min_date = date(31,12,2999);

   if( RqDateNeedCheck(FD.GetRQ(DLRQ_TYPE_PAYMENT)) )
      min_date = min( min_date, FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate );      
   end;   

   var ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
   var j:integer = 0;
   while( j < ArrFIID.size )
      if( RqDateNeedCheck(FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j))) )
         min_date = min( min_date, FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)).rec.PlanDate );
      end;
      j = j + 1;
   end;

   if( FD.ExistAvance AND RqDateNeedCheck(FD.GetRQ(DLRQ_TYPE_AVANCE)) )
      min_date = min( min_date, FD.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate );
   end;   

   if( (min_date != date(31,12,2999)) AND (Dat > min_date) )
      msgbox( "Дата изменения условий сделки не должна превышать текущие плановые даты сделки" ); 
      return false;
   end;

   return true;
end;

/* IL 20.02.07 запрос 70921 - запертить выполнять отказ если есть ТО, исполненные в неттинге*/
private macro CheckRqRejectPart( FD )
      
  if( FD.ExistsRQ(DLRQ_TYPE_PAYMENT) ) 
     if( (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_PAYMENT).rec.Netting == "X")) 
        return false;
     end;   
  end;

  var ArrFIID = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
  var j:integer = 0;
  while( j < ArrFIID.size )
     if( FD.ExistsRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)) ) 
        if( (FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_DELIVERY, NULL, ArrFIID(j)).rec.Netting == "X") )
           return false;
        end;   
     end;
     j = j + 1;
  end;

  if( FD.ExistsRQ(DLRQ_TYPE_AVANCE) ) 
     if( (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_AVANCE).rec.Netting == "X")) 
        return false;
     end;   
  end;

  if( FD.ExistsRQ(DLRQ_TYPE_DEPOSIT) ) 
     if( (FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.State == DLRQ_STATE_EXEC) and (FD.GetRQ(DLRQ_TYPE_DEPOSIT).rec.Netting == "X")) 
        return false;
     end;   
  end;
  return true;
end;

private macro SetRQFromArray(FD, Type)

  var i = 0;
  record rq("dlrq.dbt");
  var DlRq = TRecHandler("dlrq");
  var DealPart = IIF(FD.IsBack, 2, 1);

  while( i < SpChangeRq.Size() )
     SetBuff(rq, SpChangeRq[i]);
     if( (rq.Type == Type) and (rq.DealPart == DealPart) )
        if( FD.ExistsRQ(rq.Type, rq.DealPart, rq.FIID) )
           copy(FD.GetRQ(rq.Type, rq.DealPart, rq.FIID), rq);
        else
           if( (rq.ID > 0) and (rq.Amount > 0) )
              copy(DlRq, rq);
              FD.SetRQ(DlRq);
           end;
        end;
     end;
     i = i + 1;
  end;

end;

private var ftick = TBfile("dl_tick.dbt", "R", 0);

private macro ExecuteStep( Doc, FDoc, DocKind, ID_Op, ID_Step )

   record deal(dl_tick);
   var newtick = TRecHandler("dl_tick.dbt");
   var newleg  = TRecHandler("dl_leg.dbt");
   var addNum = 0;
   var FD, dat;
   var change_date = SpChangeDlTick.ChangeDate;      
   var reject_date = SpChangeDlLeg.RejectDate;      
   var reject_date2= SpChangeDlLegBack.RejectDate;      
   var i = 0, j = 0;
   var GUID = "";
   var query, cmd, DataSet;

   var ОбработатьТО = true;

   SetBuff( deal, FDoc );

   /* Если отказ от исполнения/изменение параметров сделки запущен из списка шагов - выводить ошибку */
   if( NOT( SC_IsFromScrollMode() ) )
      msgbox("Шаг \"Изменения условий\" \\ \"Отказ от исполнения сделки\" из списка шагов выполнять запрещено.");
      return 1;
   end; 

   /*нужно подкачать еще неизмененную сделку из базы*/   
   ftick.Clear();
   ftick.rec.DealID = deal.DealID;
   if( ftick.GetEQ == false ) 
      msgbox( "Сделка не найдена" );
      return 1;
   end;

   FD = SPFirstDoc( ftick ); 
   
   if( not СделкаНаВнебалансе(FD) )
      msgbox( "Данное действие разрешено только для сделок на внебалансе" );
      return 1;
   end;

   if( OprInsertSPTKCHNG( SpChangeDlTick.ChangeDate, SpChangeDlTick.ChangeKind, SpChangeDlTick, SpChangeDlLeg, SpChangeDlLegBack, COUPON_SUM ) == false )
     return 1;
   end;

   /*изменение условий сделки*/
   if( deal.ChangeKind == SPTKCHNG_CHANGE) 
     dat = change_date;

     if( ПроверитьПлановыеДатыСделки(FD, Dat) == false )
        return 1;
     end;

     copy( FD.tick, SpChangeDlTick );   
     copy( FD.dl_leg, SpChangeDlLeg );   

     SetRQFromArray(FD, DLRQ_TYPE_PAYMENT);
     SetRQFromArray(FD, DLRQ_TYPE_DELIVERY);

     if(SetChangeGrDeal(FD, NULL, dat) != 0)
       return 1;
     end;   
     
   /*отказ от сделки*/
   elif( deal.ChangeKind == SPTKCHNG_REJECT )
      dat = reject_date;
      
      if( CheckRqRejectPart( FD ) == false )
         MsgBox( "Запрещено выполнять операцию т.к. по сделке есть ТО, включенные в неттинг." );
         return 1;
      end;

      if( replan_date_reject( FD, dat ) == false ) 
         return 1;
      end;

      if( ЗакрытьТО( FD, dat ) == false )
         return 1;
      end;

      if(DL_InsertGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, DLGR_TEMPL_OUTOFFBALANCEOWN, dat, time(), FD.tick.rec.PFI) != 0)
        return 1;
      end;
      
      if( SetRejectGrDeal(FD.tick.rec.BOfficeKind, FD.tick.rec.DealID, FD.tick.rec.PFI, dat, true) != 0 )
         return 1;
      end;
   end;

   if( ОбработатьТО )
      SaveRQ(FD, NULL, dat);
   end;

   return 0;
end;


/* Макрос постобработки */
PRIVATE MACRO PostStep (    
                CommitOrRollback, /*1-выполнение шага,2 -отакат шага*/
                errTrn,        /* Статус выполнения шага-!0-произошла ошибка */
                FDoc,      /* Указатель на первичный документ */
                ID_Operation,  /* Номер экземпляра операции */
                Num_Step,      /* Номер шага операции(из настроек) */
                Kind_Operation,/* Вид операции */
                KindDoc,       /* Вид первичного документа */
                KindStep,      /* Вид шага операции */
                ID_Step)       /* Номер шага операции */

    
   record Deal_Tick("dl_tick");
   var FD;

   SetBuff( Deal_Tick, FDoc ); 

   if (errTrn OR (CommitOrRollback == 2)) 
       /* Произошла ошибка или происходит откат */
       return;
   end;

   return 0;

END;