/*
$Name:        spRepFn2.mac
$Module:      Ценные бумаги
$Description: Общие функции, используемые в отчетах БОЦБ (Часть 2)
*/
import SecInter, "spRepFun.mac";
import RsbDataSet;

/*Учет конвертаций (SCR 137194)*/
CLASS (SPFirstDoc) repSPFirstDoc( parm1, parm2, _SumID:INTEGER )

  MACRO GetBaseFIID()
     if( pmwrtsum.rec.SumID > 0 )
        return pmwrtsum.rec.FIID;
     end;  
     return GetBaseFIID();
  END;

  PRIVATE MACRO SetLot( SumID:INTEGER )
     VAR Lot = TBFile( "pmwrtsum" );

     Lot.rec.SumID = SumID;
     if( Lot.GetEQ() )
        v_ArrWrtSum = TArray();
        v_ArrWrtSum(0) = TRecHandler( "pmwrtsum" );
        v_pmwrtsum = TRecHandler( "pmwrtsum" );
        Copy( v_pmwrtsum, Lot );
        Copy( v_ArrWrtSum(0), Lot );
     end;
  END;

  initSPFirstDoc( parm1, parm2 );
  if( (_SumID != NULL) AND (_SumID > 0) )
     SetLot( _SumID );
  end;
END;

/* Вычисляем часть некоторого значения по формуле: SourceValue * Part / Total */
macro CalcPart( SourceValue, Total, Part )
   return SourceValue * Part / Total;
end;

/* Копируем содержимое массива SourceArray в массив DestArray. */
macro CopyArray( DestArray, SourceArray )
   var
      counter;

   DestArray.Size = 0;
   counter = SourceArray.Size;
   while( counter > 0 )
      counter = counter - 1;
      DestArray[counter] = SourceArray[counter];
   end;
end;

macro Print_NoDataForReport
   [Нет данных, удовлетворяющих параметрам отчета.];
end;

/*** TBaseReportData ********************************************************/

   /* Базовый класс для данных отчета. При создании принимает параметры:
         IsApp       - флаг, печатать числа с апострофами
      Имеет следующие методы:
         SetApp      - устанавливаем метод вывода чисел - с апострофами или без
         GetAppFlag  - получить метод вывода чисел
         NumToStr    - перевести число в строку с заданной точностью
         DateToStr   - перевести дату в строку в виде dd.mm.yy
      Имеет следующие свойства:
         WasPrintData   - флаг, были ли распечатаны данные. При создании = false. */
   class TBaseReportData( IsAppFlag )

      private var
         IsApp       = null,
         IsAppSpec   = null;

      var
         WasPrintData   = false;

      /* Устанавливает метод вывода чисел: с апострофами или без. */
      macro SetApp( _IsApp )
         IsApp       = _IsApp;
         IsAppSpec   = IIF( _IsApp, "a", "" );
      end;

      /* Получить метод вывода чисел. */
      macro GetAppFlag
         return IsApp;
      end;

      /* Получить число в виде строки с апострофами или без с заданной
         точностью. Если точность не задана, то печатается с точностью
         по умолчанию.
            Num            - число
            Point          - точность
            DontPrintZero  - флаг, не печатать нули */
      macro NumToStr( Num, Point, DontPrintZero )
         if( Point != null )
            return NumPrec( Num, Point, IsAppSpec, DontPrintZero );
         else
            return PrintToStr( Num, IsApp, not DontPrintZero );
         end;
      end;

      /* Конструктор */
      SetApp( IsAppFlag );
   end;

/*** Работа со сделками *****************************************************/

   /* Получить номер документа поручения клиента на сделку. Если документа
      нет, то возвращаем пустую строку.
         DealID         -  код сделки
         SerialNumRec   -  порядковый номер документа в ключевой
                           последовательности, который хочем получить. Если не
                           задан, то 1 (получаем первый подходящий).
         BOfficeKind    -  вид первичного документа. Если не задан, то
                           DL_SECURITYDOC */
   macro GetNumberClientOrderToOp( DealID, SerialNumRec, BOfficeKind )
      return GetSPGroundRecByDeal(  DealID, DOCKIND_ORD_CLIENTOP,
                                    SerialNumRec, BOfficeKind ).Xld;
   end;

/*** Работа с финансовыми инструментами *************************************/

   /* Получить объем выпуска ценной бумаги на дату. Если дата не задана, берется на текущую.Возвращаем double. 
         Avoir -  буфер ценной бумаги */
   macro GetAvoirQty( Avoir, QDate:Date )
      var fininstr = TRecHandler("fininstr");

      if( not ПолучитьФинИн( Avoir.FIID, fininstr ) ) 
         return MoneyToDouble(FI_GetQtyOnDate( fininstr, QDate )); /*объем выпуска на дату*/
      end;

      return 0.0;
   end;

   /* Проверяем, задан ли объем выпуска ценной бумаги на дату. Возвращаем true, если
      задан. */
   macro IsAvoirQtyExist( Avoir, QDate:Date )
      return (GetAvoirQty( Avoir, QDate ) != 0.0);
   end;

/*** Работа с лотами ********************************************************/

   /* Под "учетным портфелем" в данном отчете понимаются портфели, описанные в АЗ "Балансовый учет ценных бумаг", 
      а именно ТП, ППР, ПУДП , ПКУ, ПДО, ПВО, ОД. 
      При этом под портфелем БПП мы понимаем лоты в ТП/ППР/ПКУ, имеющие статус "Продан БПП" , 
      а также лоты прямого РЕПО, проданные из ПВО.  */
   macro GetLotPortf( pmwrtsum )
      var portfel:integer;
      if( ( (pmwrtsum.Portfolio == KINDPORT_TRADE) OR (pmwrtsum.Portfolio == KINDPORT_SALE) OR (pmwrtsum.Portfolio == KINDPORT_CONTR) ) AND ( pmwrtsum.State == PM_WRTSUM_SALE_BPP ) )
        portfel = KINDPORT_UNADMITTED;
      else
        portfel = pmwrtsum.Portfolio;
      end;
      return portfel;
   end;

/*** Работа с платежами *****************************************************/

   /* Проверяем, что платеж закрыт на дату (на конец дня).
         paym        - платеж
         CheckDate   - дата проверки */
   macro ПлатежЗакрытНаДату( paym, CheckDate )
      return ПлатежЗакрыт( paym ) and (paym.ValueDate <= CheckDate);
   end;

/*** Работа с филиалами *****************************************************/

   macro GetDepartment( DepCode, SayError, BreakProg )
      var
         dep   = TBFile( "dp_dep.dbt" );

      dep.Clear();
      dep.rec.Code = DepCode;
      if( not (dep.GetGE() and (dep.rec.Code == DepCode)) )
         if( SayError )
            InformUser( "Не найден филиал (Code = " + string(DepCode) + ")",
                        BreakProg );
            dep.Clear();
         end;
      end;

      return dep.rec;
   end;

/*** Итераторы **************************************************************/

   /* Итератор связанных лотов. Позволяет просмотреть лоты покупки, связанные
      с заданным лотом продажи или лоты продажи, связанные с данным лотом
      покупки.
      Методы:
         Init           -  Инициализация итератора. Принимает в качестве
                           параметр лот, для которого будем искать связи.
         Next           -  Получение первого связанного лота или следующего.
                           Возвращает true, если лот найден.
         GetLinkedLot   -  Получение буфер записи найденного связанного лота.
                           Имеет смысл вызывать после успешного выполнения
                           функции Next.
         GetLinkRec     -  Получение буфера записи связи.
                           Имеет смысл вызывать после успешного выполнения
                           функции Next.*/
   class TLinkedLotIterator

      /* Внутренние данные */
      private var
         links       = TBFile( "pmwrtlnk", "R", 0 ),
         LinkedLot   = TRecHandler( "pmwrtsum" ),
         IsInit      = false,
         IsFirstRec  = false,
         DataSet, GetLink = false;

      /* Инициализация. */
      macro Init( lot, _GetLink )

         if (_GetLink == true)
            GetLink = true;
         else
            GetLink = false;
         end;

         if( lot.Buy_Sale == PM_WRITEOFF_SUM_BUY )

            /* Будем искать продажи по лоту покупки. */
            DataSet = TRsbDataSet( 

                  " Select Sale.t_DocKind as DocKindSale, Sale.t_DocID    as DocIDSale, "
                + "        Sale.t_PartNum as PartNumSale, Sale.t_Buy_Sale as Buy_Sale, "
                + "        lnk.t_BuyID as BuyID "

                + " From dpmwrtlnk_dbt lnk, dpmwrtsum_dbt Sale "
                + " Where "
                + "      lnk.t_BuyID = " + string(lot.SumID)

                + " and Sale.t_SumID      = lnk.t_SaleID "
                + " and Sale.t_Buy_Sale     = " + string(PM_WRITEOFF_SUM_SALE)

                /*по 0 ключу*/
                + " ORDER BY lnk.t_BuyID, "
                + "          lnk.t_SaleID ",
                RSDVAL_CLIENT, RSDVAL_STATIC
                                 );

            IsInit = true;
            IsFirstRec = true;

         elif( (lot.Buy_Sale == PM_WRITEOFF_SUM_SALE)
               or (lot.Buy_Sale == PM_WRITEOFF_SUM_COUPON)
               or (lot.Buy_Sale == PM_WRITEOFF_SUM_PARTIAL) )

            /* Будем искать покупки по лоту продажи или лоту погашения. */
            DataSet = TRsbDataSet( 

                  " Select buy.t_DocKind as DocKindBuy, buy.t_DocID    as DocIDBuy, "
                + "        buy.t_PartNum as PartNumBuy, buy.t_Buy_Sale as Buy_Sale, "
                + "        lnk.t_SaleID as SaleID "

                + " From dpmwrtlnk_dbt lnk, dpmwrtsum_dbt buy "
                + " Where "
                + "      lnk.t_SaleID = " + string(lot.SumID)

                + " and buy.t_SumID      = lnk.t_BuyID "
                + " and buy.t_Buy_Sale     = " + string(PM_WRITEOFF_SUM_BUY)

                /*по 1 ключу*/
                + " ORDER BY lnk.t_SaleID, "
                + "          lnk.t_BuyID ",
                RSDVAL_CLIENT, RSDVAL_STATIC
                                 );

            IsInit = true;
            IsFirstRec = true;

         else
            IsInit = false;
         end;
      end;

      /* Инициализация. Для регистров 6-7.*/
      macro Init67( lot, Name )

         if( lot.Buy_Sale == PM_WRITEOFF_SUM_BUY )

            /* Будем искать продажи по лоту покупки. 
               Сразу учтем условия из отчета.
            */

            DataSet = TRsbDataSet( 
                    " Select sale.t_DocKind as DocKind, sale.t_DocID    as DocID, "
                  + "        sale.t_PartNum as PartNum, sale.t_Buy_Sale as Buy_Sale, "
                  + "        sale.t_Date as LotDate, sale.t_Time as LotTime, sale.t_DealID as DealID "

                  + " From dpmwrtlnk_dbt lnk, dpmwrtsum_dbt sale "
                  + " Where "
                  + "      lnk.t_BuyID = " + string(lot.SumID)

                  /* Это должен быть лот продажи.
                     Статус лота должен быть поставлен или готов.
                     Лот, созданный операцией перевода ц/б, в отчет попадать не должен (#53754)
                     Фактическая дата поставки ц/б должна входить в интервал дат отчета.
                     РЕПО в отчет попадать не должна.
                     Операции списания попадать не должны. */
                  + " and sale.t_SumID    = lnk.t_SaleID "
                  + " and sale.t_Buy_Sale   = " + string(PM_WRITEOFF_SUM_SALE)
                  + " and sale.t_State     >= " + string(PM_WRTSUM_FORM)
                  + " and sale.t_DocKind   != " + string(DL_MOVINGDOC)

                  /* Проверим, что этого лота еще нет в файле лотов продажи. */
                  + " and not Exists ( "
                         + " select tr.t_DocID from " + Name + " tr "
                         + " where tr.t_DocKind = sale.t_DocKind "
                         + "   and tr.t_DocID   = sale.t_DocID "
                         + "   and tr.t_PartNum = sale.t_PartNum ) "

                  /*по 0 ключу*/
                  + " ORDER BY lnk.t_BuyID, "
                  + "          lnk.t_SaleID ", 
                   RSDVAL_CLIENT, RSDVAL_STATIC );

            IsInit = true;
            IsFirstRec = true;
         else
            IsInit = false;
         end;
      end;

      /* Получение первой и следующей записи. */
      macro Next
         var
            continue_cicle = true,
            IsFind   = false;

         while( continue_cicle and IsInit and (not IsFind) )

            /* Получим запись. */
            if( IsFirstRec )

               continue_cicle = DataSet.MoveFirst();

               IsFirstRec = false;
            else
               continue_cicle = DataSet.MoveNext();
            end;

            /* Проверим, что это нужная нам запись. */
            if( continue_cicle )
               /* Нашли подходящую запись. Получим непосредственно лот.
                  Если сможем получить лот, то прекращаем работу.
                  Если не сможем получить лот, то возьмем следующий линк. 
                  Причем сделаем это только, если нам это нужно.
               */

               if (DataSet.Buy_Sale == PM_WRITEOFF_SUM_BUY)
                  GetLotFile( DataSet.BuyID, false, false, LinkedLot );
               else
                  GetLotFile( DataSet.SaleID, false, false, LinkedLot );
               end;

               /*Если нужно, найдем линк.*/
               if (GetLink == true)
                  links.Clear();
                  links.rec.BuyID       = DataSet.SumID;
                  links.rec.SaleID      = DataSet.SumID;
                  if (not links.GetEQ())
                     msgbox("Не найдена запись в таблице связей лотов с DocIDBuy = " + 
                             string(DataSet.DocIDBuy) + " и SaleID = " + string(DataSet.SaleID)
                           );
                  end;
               end;

               IsFind = LinkedLot.rec.DocID > 0;
            end;
         end;

         return IsFind;
      end;

      /* Получение первой и следующей записи. Для регистров 6-7*/
      macro Next67
         var
            continue_cicle = true,
            IsFind   = false;

         while( continue_cicle and IsInit and (not IsFind) )

            /* Получим запись. */
            if( IsFirstRec )

               continue_cicle = DataSet.MoveFirst();
               IsFirstRec = false;
            else
               continue_cicle = DataSet.MoveNext();
            end;

            /* Проверим, что это нужная нам запись. */
            if( continue_cicle )

               /* Нашли подходящую запись. Получим непосредственно лот.
                  Если сможем получить лот, то прекращаем работу.
                  Если не сможем получить лот, то возьмем следующий линк. 
                  Причем сделаем это только, если нам это нужно.
               */

               IsFind = true;
            end;
         end;

         return IsFind;
      end;

      /* Получение связанного лота. */
      macro GetLinkedLot
         return LinkedLot.rec;
      end;

      /* Получение связанного лота. Для регистров 6-7*/
      macro GetLinkedLot67
         return DataSet;
      end;

      /* Получения буфера записи связи. */
      macro GetLinkRec
         return links.rec;
      end;
   end;

/*** ************************************************************************/

/* Отладочная печать информации о связях лота продажи с лотами покупки.
      LotSale  - лот продажи */
macro DebugPrint_LotSaleLink( LotSale )

   macro PrintHeadSale
      [  == DEBUG PRINT ============ Связи лота продажи =========================

            ┌─────────────────────────────────────────────────────────────┐
            │ Продажа                                                     │
            ├──────────────┬───────────┬───────────┬──────────┬───────────┤
            │ DealCode     │ DealID    │ DocKind   │ DocID    │  PartNum  │
      ];
   end;

   macro PrintHeadBuy
      [     ├──────────────┴───────────┴───────────┴──────────┴───────────┤
            │ Покупки                                                     │
            ├──────────────┬───────────┬───────────┬──────────┬───────────┤
            │ DealCode     │ DealID    │ DocKind   │ DocID    │  PartNum  │
      ];
   end;

   macro PrintLine( DealRec, LotRec )
      [     ├──────────────┼───────────┼───────────┼──────────┼───────────┤
            │ ############ │ ######### │########## │ ######## │ ######### │
      ]( DealRec.DealCode, DealRec.DealID, LotRec.DocKind, LotRec.DocID,
         LotRec.PartNum );
   end;

   macro PrintFoot
      [     └──────────────┴───────────┴───────────┴──────────┴───────────┘
         == DEBUG PRINT == END ==================================================
      ];
   end;

   var
      link     = TBFile( "pmwrtlnk", "R", 1 ),
      dealbuy  = TRecHandler( "dl_tick" ),
      dealsale = TRecHandler( "dl_tick" ),
      lotbuy   = TRecHandler( "pmwrtsum" ),
      continue_cicle;

   /* Получаем сделку продажи. */
   dealsale = GetDealByID( LotSale.DealID, true );

   /* Печатаем информацию о продаже. */
   PrintHeadSale;
   PrintLine( dealsale, LotSale );
   PrintHeadBuy;

   link.Clear();
   link.rec.SaleID = LotSale.SumID;
   continue_cicle = link.GetGE();
   while( continue_cicle   and (link.rec.SaleID == LotSale.SumID) )

      /* Получаем лот. */
      lotbuy = GetLotRec(  link.rec.BuyID, true );

      /* Получаем сделку. */
      dealbuy = GetDealByID( lotbuy.DealID, true );

      /* Печатаем информацию. */
      PrintLine( dealbuy, lotbuy );

      continue_cicle = link.Next();
   end;

   PrintFoot;
end;
