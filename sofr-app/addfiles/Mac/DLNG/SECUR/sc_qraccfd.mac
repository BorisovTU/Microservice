/*
$Name: sc_qraccfd.mac
$Module: Ценные бумаги
$Description: Класс первичного документа строки регистра КДУ. Обеспечивает подготовку данных для открытия лицевых счетов по категориям учета.
*/
import CTInter, PTInter, "globals.mac";
import "mccatacc.mac","dlquery.mac","dl_car.mac","secinter.mac","commonutil.mac","or_rep_h.mac";

class SC_QRAccFD(QR)
  private var m_qracc = TBFile("scqracc.dbt");
  var Kind = 0;
  var ID = 0;
  var Error = 0;

  macro GetBasisFIRole( FIRole:INTEGER, NoMsgErr:BOOL )
    var i = 0;
    
    if (FIRole == FIROLE_UNDEF)
      return FIROLE_BA;
    end;

    return FIRole;
  END;

  private macro Construct(QR)
    if (ValType(QR) == V_INTEGER)
      m_qracc.Clear();
      m_qracc.rec.QRID = QR;
      if (not m_qracc.GetEQ())
        RunError("Не найдена запись в регистре КДУ.|Ошибка при создании класса "+GenClassName(this));
      end;
      Id = QR;
    elif (ValType(QR) == V_GENOBJ)
      m_qracc = QR;
      Id = m_qracc.rec.QRID;
    end;

    Kind = SC_QRACC;
    
  end;

  macro GetParametr( ParmKind )
    private var Parametr = -1;
    if (ParmKind == MC_TYPE_PARAMETR_FIID)
      Parametr = m_qracc.rec.fiid;
    elif (ParmKind == MC_TYPE_PARAMETR_PLACE)
      Parametr = m_qracc.rec.StorageId;
    elif (ParmKind == MC_TYPE_PARAMETR_NUMBER)
      Parametr = StrSubst(String(m_qracc.rec.depoacccode:12:0:l)," ","0") + StrSubst(String(m_qracc.rec.depopartcode:5:0:l)," ","0") + substr(m_qracc.rec.depopartcode, strlen(m_qracc.rec.depopartcode)-3);//StrSubst(String(m_qracc.rec.depopartcode:8:0:l)," ","0");
    elif (ParmKind == MC_TYPE_PARAMETR_DEPARTMENT)
      Parametr = {OperDprt};
    end;
    return Parametr;
  end;

  /* Получить счет по категории учета
      Вернет false, если ошибка или отказ от ввода счета.
      ! если не установлен NoErrMes выдаст сообщение об ошибке
  */
  private macro GetAccountByCatCode
  ( 
      CatCode:string     ,  /* код категории */
      FindAccount:string ,  /* здесь вернется номер счета */
      /*необязательные параметры*/
      AccCreate:Integer,     /* признак верификации\открытия лицевого счета       */
      NoErrMes:bool,      /* признак молчаливого выполнения - ошибку не выдаем */
      FIRole:Variant,        /* роль ФИ или массив ролей*/
      AccBuf:Variant,        /* буфер для возврата информации по найденному\открытому счету   */
      PairAcc:Integer,       /* с учетом парности */
      ActionDate:Date,    /* дата */
      FIID:Integer,          /*валюта*/
      Accounts:Variant,      /*массив номеров счетов, соответствующий массиву ролей */  
      RealOpenMode:Integer,  /*фактический режим открытия*/
      McAccDocBuf:Variant,   /* буфер для возврата данных по счету mcaccdoc.dbt */
      ActivateDate:Variant,   /*Дата актуализации счета (может быть не задана)*/
      NumberForAcc:string    /*номер существующего счета, который нужно привязать к документу*/
  )
    var i = 0, loop = true, open_acc = true, _FIRole = null, IsMass;

    var ID_Operation, ID_Step;

    if( this.Error != 0 ) return false; end;

    if( ((NoErrMes == null) OR (NoErrMes == false)) AND 
        (not isOprMultiExec()) 
      )
      IsMass = 0;
    else /*либо массовый режим, либо принудительно просим не орать ошибки*/
      IsMass = 1;
    end;

    if( ValType(AccCreate) == V_UNDEF )
      AccCreate = MC_OPENACC_CREATE;
    end;

    while( loop ) /*цикл нужен для перебора ролей, если задан массив ролей*/

      if( (FIRole != null) AND (ValType( FIRole ) == V_GENOBJ) ) /*массив ролей*/  

        if(FIRole[i] != null)            
          loop     = true;                    
          open_acc = true;
          _FIRole  = FIRole[i];
        else
          loop     = false;                    
          open_acc = false;
          _FIRole  = null;
        end;
        i = i + 1;    

      else
        loop       = false; /*перебор не нужен, только одна роль задана*/
        open_acc   = true;
        _FIRole    = FIRole;
      end;
  
      if( open_acc )                    
        if( AccCreate != 4 )
          FindAccount = MC_FindAndOpenAccountEx( CatCode,
                                                this,
                                                ActionDate,
                                                IsMass,
                                                AccCreate,
                                                AccBuf, FIID, null, PairAcc, NumberForAcc, _FIRole, RealOpenMode, McAccDocBuf, null, ActivateDate, null, ID_Operation, ID_Step 
                                              );
        else
          FindAccount = MC_GetAccountNumber( CatCode,
                                            this,
                                            ActionDate,
                                            IsMass, FIID, _FIRole
                                          );
        end;
          if( FindAccount != "" )
            if( (Accounts != null) AND (ValType( Accounts ) == V_GENOBJ) ) /*массив счетов*/
              Accounts[i-1] = FindAccount;
            end;
          end;
      end;
    end;

    SetParm( 2, FindAccount );
    if( FindAccount=="" )
      if( IsMass == 0 )
          MsgBox("Счет категории \"" + CatCode + "\" неопределен или недоступен в данной операции");
      end;  
      return false;
    end;

    return true;
  END;

  macro IsExistAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
    var ret, acnt;      
    ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_CHECKEXIST, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
    setparm( 2, acnt ); 
    return ret;
  end;  

  macro OpenAccount( CatCode:STRING, FindAccount:STRING, NoErrMes:BOOL, FiRole:INTEGER, AccBuf:VARIANT, ActionDate:DATE, FIID:INTEGER )
    var BackOutAccount = false, ChangeOpenDate  = false, IsMass;
    var ret = true;

    var _fiRole = FiRole;
    if (ValType(_fiRole) == V_UNDEF)
      _fiRole = FIROLE_BA;
    end;

    if( (NoErrMes == null) OR (NoErrMes == false) )
       IsMass = 0;
    else 
       IsMass = 1;
    end;

    MC_GetAccountOpenParms( CatCode, @BackOutAccount, @ChangeOpenDate );

    FindAccount = MC_FindAndOpenAccount (
        CatCode,
        this,
        ActionDate,
        IsMass,
        MC_OPENACC_CREATE,
        AccBuf, m_qracc.rec.Fiid, null, NULL, null, _fiRole, NULL, NULL, NULL, NULL, NULL,
        BackOutAccount,
        ChangeOpenDate
    );

    if( FindAccount=="" ) 
      if( IsMass == 0 ) 
         MsgBox("Счет категории \"" + CatCode + "\" неопределен или недоступен в данной операции");
      end;
      ret = false;
    end;

    return ret;
  end;

  /*$$$ Макрос корректировки открываемого счета. Account, accblnc, ORScheme можно менять*/
  MACRO CorrectAccount(account, accblnc, ORScheme, categ, templ, accdoc,  OperDate)
     return true;
  END;

  Construct(QR);
end;

private macro FoundAndOpenAccByCat(CatName:String, QRID:integer, OnDate: Date, AccBuf:TRecHandler)
  private var err = 0;
  private var FD = SC_QRAccFD(QRID);
  private var cmd, DataSet;
  if (not FD.OpenAccount(CatName,NULL,NULL,NULL,AccBuf,OnDate,NULL))
    err = 1;
  end;
  if (not err)
    if (AccBuf.rec.accountid == 0)
      cmd = DL_RSDCommand(  "select * from daccount_dbt"
                      + " where t_Account = ? "
                      + "   and t_Code_Currency = ? "
                      + "   and t_Chapter = ?"
                     ); 
      cmd.AddParam(AccBuf.rec.Account);
      cmd.AddParam(AccBuf.rec.Code_Currency);
      cmd.AddParam(AccBuf.rec.Chapter);

      DataSet = cmd.Execute();
      if (DataSet.moveNext())
        DataSet.GetRecord().CopyTo(AccBuf.rec);
      else
        err = 1;
      end;
    end;
  end;
  return err;
end;