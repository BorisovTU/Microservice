/*
$Name:        secinter.mac
$Module:      Ценные бумаги
$Description: Общие константы и функции модуля "Ценные бумаги"
*/

import  rsd, "dlcnst.inc", PaymInter, CTInter, BankInter, SPInter, PTInter, FIInter, "adress.mac", oprinter,
        "dlGetGroundRec.mac", Календарь, DealsInter, "cb_sql.mac", "dldlngconst.mac", "dlrepfun.mac", "dlreport.mac", "dlGetGroundRec.mac", 
        "dlquery.mac", "dlmisc.mac", "dldlngfun.mac";

/* Настраиваемые пользователем константы кода ММВБ, СПБ, РТС, БРОКЕР - как контрагента */
const MICEX_CODE     = "ММВБ";
const MICEX_CODE_FB  = "ММВБ";
const SPBEX_CODE     = "ПАО СПБ";
const RTS_CODE       = "РТС";
const BROKER_CODE    = "БРОКЕР";

const Рынок_Тплюс    = "Рынок_Т+";

const DOCKIND_ORD_CLIENTOP = 251;  /*Поручение клиента на операцию с ц/б*/

/*Даты операции конвертации ц/б*/
CONST DATE_CONVAVR_BEGIN   = 0;  /* Дата начала операции конвертации ц/б*/
CONST DATE_CONVAVR_OUT     = 5;  /* Дата списания в операции конвертации ц/б*/
CONST DATE_CONVAVR_IN      = 10; /* Дата зачисления в операции конвертации ц/б*/
CONST DATE_CONVAVR_END     = 15; /* Дата завершения операции конвертации ц/б*/

/* Дополнительные виды дат в сделке
   номера видов дат в массиве дат (системные виды дат тоже оппадают в массив)*/
CONST DATE_DEALBEGINSETTLE      = DATE_DEAL_LASTSYSTEMDATE; /* Дата начала расчетов */
CONST DATE_DEALSETAVOIRISS_PLAN = DATE_DEAL_LASTSYSTEMDATE + 1;  /* Плановая дата поставки ц/б */
CONST DATE_DEALPAY_PLAN         = DATE_DEAL_LASTSYSTEMDATE + 2;  /* Плановая дата оплаты    */
CONST DATE_DEALDEPOSIT_PLAN     = DATE_DEAL_LASTSYSTEMDATE + 3;  /* Плановая дата задатка   */
CONST DATE_DEALAVANCE_PLAN      = DATE_DEAL_LASTSYSTEMDATE + 4;  /* Плановая дата аванса    */
CONST DATE_DEALRATEPAY          = DATE_DEAL_LASTSYSTEMDATE + 5;  /* Дата курса оплаты       */
CONST DATE_DEALBEGINSETTLE_PLAN = DATE_DEAL_LASTSYSTEMDATE + 6; /*  Дата начала расчетов (плановая)*/
CONST DATE_DEALBEGINEXEC_PLAN   = DATE_DEAL_LASTSYSTEMDATE + 7; /*  Дата начала исполнения (плановая)*/

const VALUE_NOT_FIND = -1; /*для возврата из ф-й если искомое значение не найдено */

const SP_RATETYPE_MarketPrice = 1,  /* вид курса Рыночная цена        */
      SP_RATETYPE_MinPrice    = 2,  /* вид курса Минимальная цена     */
      SP_RATETYPE_MaxPrice    = 3,  /* вид курса Максимальная цена    */
      SP_RATETYPE_MediumPrice = 4,  /* вид курса Средневзвешенная цена*/
      SP_RATETYPE_MarketCost  = 5,  /* вид курса Рыночная стоимость   */
      SP_RATETYPE_RightCost   = 12, /* вид курса Справедливая стоимость*/
      SP_RATETYPE_CloseCost   = 18, /* вид курса Цена закрытия        */
      SP_RATETYPE_TaxReserve  = 20; /* вид курса Котировка для расчета налогового резерва*/

/*Тип выполняемого шага*/
const SP_EXECUTE_STEP_BUY  = 1, /*Выполняется шаг операции покупки*/
      SP_EXECUTE_STEP_SALE = 2; /*Выполняется шаг операции продажи*/

const SP_FIXED_PRICE = 0, /* фиксированная цена сделки*/
      SP_FIXED_SUMMA = 1, /* фиксированная сумма сделки*/
      SP_FIXED_NKD   = 2; /* без пересчета НКД*/ 
/*виды сделок*/
const DEAL_TYPE_UNDEF= 0,       /*неизвестный вид*/
      DEAL_TYPE_SALE = 1,       /*продажи\погашения*/
      DEAL_TYPE_BUY  = 2,       /*покупки*/
      DEAL_TYPE_RET_COUPON = 3, /*погашения купонов*/
      DEAL_TYPE_RET_PARTLY = 4; /*частичное погашение*/


/* Типы сделок по договорам*/
const  SC_DEAL_BROKER = 0, /*брокерская*/
       SC_DEAL_OWN    = 1, /*собственная*/       
       SC_DEAL_CB     = 2; /*управление ц/б*/    

const DollarCode="840";       /* Код доллара */

const bal_acc_active = "А",
      bal_acc_passive = "П";

/*виды секций бирж*/
/*ММВБ*/
const СекторГосЦБ = 1; /*секция гос.бумаг*/
const СекторФонд  = 2; /*секция фондового рынка*/
/*РТС*/
const СекторСГК      = 1; /*система гарантированных котировок*/
const СекторТрадРТС  = 2; /*традиционная РТС*/

/*Виды кодов клиентов*/
const party_code_kind_contr_code = PTCK_CONTR;  /*1 - Код контрагента*/
/*Виды обслуживания клиентов*/
const client_ServiceKind_FDLNG = PTSK_STOCKDL; /*1 - Фондовый дилинг*/
/*Виды субъектов*/
const party_kind_client = PTK_CLIENT,/* 1 - Клиенты*/
      party_kind_bank   = PTK_BANK,  /* 2 - Банки*/
      party_kind_exch   = PTK_MARKETPLASE, /* 3 - Биржи;*/
      party_kind_depo   = PTK_DEPOSITORY;  /* 4 - Депозитарии */

const legal_form_jur = 1,
      legal_form_phys = 2;

const depo_acc_any = 0,
      depo_acc_active = 1,
      depo_acc_passive = 2;

const rec_type_order = 1,
      rec_type_command = 2,
      rec_type_deal = 3,
      rec_type_coupred = 4,
      rec_type_client_order = 5;

/*Категории ЦБ*/
/* группа -- вид облигации*/
/*const BOUND_KIND = 4; теперь в SPInter !!!*/
/* Список признаков группы вид облигации*/
const государственные     = 21,   /*1*/
       федеральные         = 22,  /*1.1*/
         ГКО                 = 23,   /*1.1.1*/
         ОФЗ                 = 24,   /*1.1.2*/
         ОБР                 = 25,  /*1.1.3*/
         ОГВЗ                = 26,  /*1.1.4*/
         ОВВЗ                = 27,  /*1.1.5*/
         еврооблигации       = 28,  /*1.1.6*/
         иные_федеральные    = 29,  /*1.1.7*/
       субъектов_федерации = 30,  /*1.2*/
      муниципальные       = 31;   /*2*/

      
/*  16 - корпоративные
    20 - корпоративные с ипотечным покрытием  */
macro корпоративные( bond_kind )
   return FI_AvrKindsEQ( FIKIND_AVOIRISS, 32, bond_kind );
end;      

const
   /* Пользовательские типы документов. */
   UserTypeDocument_Inc = "I",      /* Зачисление средств */
   UserTypeDocument_Wrt = "W";      /* Списание средств */

/*основания проводок по клиентстким сделкам для прооводки по контрактиву*/
const ClNKDCarryGround = "Учет суммы НКД",
      ClNotNKDCarryGround = "Сумма ТО по оплате сделки";

macro ExecuteSQLCommand( SqlQuery:STRING, Context:STRING, Error:@STRING )
   var SqlCmd;

   Error = "";

   /* message( Context +" ~ Ждите...~"); */

   SqlCmd = RsdCommand( RslDefCon, SqlQuery );
   SqlCmd.Execute();
   return RsdRecordset( SqlCmd );

 OnError( er );
   var i = 0, env = SqlCmd.Connection().Environment();

   Error = Context + "|" + er.message;
   while( i < env.ErrorCount )
     Error = Error + "|" + env.error(i).descr;
     i = i + 1;
   end;

   return NULL;
end;

MACRO ConvertSQLDate( dttm )
   return SQL_ConvTypeDate( dttm );
END;


macro ПолучитьВидКурса( RateType:INTEGER )
   var ErrCode, Path, NewRateType = RateType;

   if( RateType == SP_RATETYPE_MarketPrice ) /* вид курса Рыночная цена        */
      Path = "SECUR\\ВИД КУРСА РЫНОЧНАЯ ЦЕНА";
   elif( RateType == SP_RATETYPE_MinPrice    )  /* вид курса Минимальная цена     */
      Path = "SECUR\\ВИД КУРСА МИНИМАЛЬНАЯ ЦЕНА";
   elif( RateType == SP_RATETYPE_MaxPrice    )  /* вид курса Максимальная цена    */
      Path = "SECUR\\ВИД КУРСА МАКСИМАЛЬНАЯ ЦЕНА";
   elif( RateType == SP_RATETYPE_MediumPrice )  /* вид курса Средневзвешенная цена*/
      Path = "SECUR\\ВИД КУРСА СРЕДНЕВЗВЕШЕННАЯ ЦЕНА";
   elif( RateType == SP_RATETYPE_MarketCost  )  /* вид курса Рыночная стоимость   */
      Path = "SECUR\\ВИД КУРСА РЫНОЧНАЯ СТОИМОСТЬ";
   elif( RateType == SP_RATETYPE_RightCost  )  /* вид курса Справедливая стоимость   */
      Path = "SECUR\\ВИД КУРСА СПРАВЕДЛ. СТОИМОСТЬ";
   elif( RateType == RATETYPE_OVERVAL_RIGTH_COST  )  /* вид курса ТСС для переоценки обязательств   */
      Path = "SECUR\\ВИД КУРСА ТСС ДЛЯ ПЕРЕОЦ.ОБЯЗ-В";
   elif( RateType == RATETYPE_SSWITHOUTNKD )  /* вид курса СС без НКД */
      Path = "SECUR\\ВИД КУРСА СС БЕЗ НКД";
   end;

   GetRegistryValue( Path, V_INTEGER, NewRateType, ErrCode );
   if( ErrCode != 0 )
      return RateType;
   end;

   return NewRateType;
end; 

/* Информируем пользователя. Если BreakProg = true, то завершаем работу по
   RunError, иначе MsgBox.
      Mes         -  сообщение
      BreakProg   -  флаг, аварийно завершить работу */
macro InformUser( Mes, BreakProg )

   if( BreakProg )
      RunError( Mes );
   else
      MsgBox( Mes );
   end;
end;

macro ИмяПримечания( ObjectType:INTEGER, Kind:INTEGER )     
   file Notekind(notekind);

   ClearRecord( Notekind );
   Notekind.ObjectType = ObjectType;
   Notekind.NoteKind   = Kind;
   if( GetEQ(Notekind) )
      return Notekind.Name;
   end;
   return "";
end; 
 
macro ИмяКатегории( ObjectType:INTEGER, GroupID:INTEGER )     
   file objgroup(objgroup);

   ClearRecord( objgroup );
   objgroup.ObjectType = ObjectType;
   objgroup.GroupID    = GroupID;
   if( GetEQ(objgroup) )
      return objgroup.Name;
   end;
   return "";
end; 


/* Получить значение категории
      Obj         -  объект
      KindCateg   -  вид категории
      ObjType     -  вид объекта, если не задан, то "Ценная бумага"
   Если значение категории не задано, то возвращаем 0. */
macro GetCategValue( Obj, KindCateg, ObjType )
   return ПолучитьЗначениеКатегории( Obj, KindCateg, ObjType );
end;

/* Получаем название значения категории. Если не нашли или в случае
   ошибки - возвращаем пустую строку.
      ObjType     -  тип объекта
      KindCateg   -  тип категории
      CategValue  -  значения категории (внутренний идентификатор признака)
      GetShName   -  флаг, получить короткое наименование */
macro GetNameCategValue( ObjType, KindCateg, CategValue, GetShName )
   var
      ObjAttr  = TBFile( "objattr" );

   ObjAttr.Clear();
   ObjAttr.rec.ObjectType  = ObjType;
   ObjAttr.rec.GroupID     = KindCateg;
   ObjAttr.rec.AttrID      = CategValue;
   if( ObjAttr.GetEQ() )
      if( GetShName )
         return ObjAttr.rec.Name;
      else
         return ObjAttr.rec.FullName;
      end;
   else
      return "";
   end;
end;

macro ПолучитьВидОблигации( avr )
  var cmd, DS;

  cmd = RSDCommand( "select t_AvoirKind from dfininstr_dbt where t_FIID = ?" );
  cmd.addParam( "", RSDBP_IN, avr.FIID );
  cmd.execute();
  DS = TRsbDataSet(cmd);
  if( DS.movenext() )
     return DS.AvoirKind;
  end;
  return -1;
end;

macro ПолучитьКодТипаЦБ711( avr )
   return ПолучитьЗначениеКатегории( avr, OBJGROUP_AVRTYPE711, OBJTYPE_AVOIRISS );
end;

macro ПолучитьКодТипаЦБ405( avr )
   return ПолучитьЗначениеКатегории( avr, OBJGROUP_AVRTYPE405, OBJTYPE_AVOIRISS );
end;

/* Проверяем вид облигации. Возвращаем true, если это государственая
   облигация.
      BondKind - вид облигации */
macro IsStateBondKind( BondKind )
   return   (BondKind != 0)
            and FI_AvrKindsEQ( FIKIND_AVOIRISS, государственные, BondKind );
end;

/* Проверяем вид облигации. Возвращаем true, если это федеральная облигация.
      BondKind - вид облигации */
macro IsFederalBondKind( BondKind )
   return   IsStateBondKind( BondKind )
            and (FI_AvrKindsEQ( FIKIND_AVOIRISS, субъектов_федерации, BondKind ) == false );
end;

/*проверка является ли бумага государственной*/
macro БумагаГосударственная( avr )
   return   FI_IsBond( avr.FIID )
            and IsStateBondKind( ПолучитьВидОблигации(avr) );
end;

macro БумагаМуниципальная( avr )
   var KindBond;
   if( FI_IsBond( avr.FIID ) == true )
      KindBond = ПолучитьВидОблигации( avr );
      if( FI_AvrKindsEQ( FIKIND_AVOIRISS, муниципальные, KindBond ) )
         return true;
      end;
   end;
   return false;
end;

/* Округляем MONEY или DOUBLE до ближайшего целого. Для MONEY
   возвращаем целое, для DOUBLE возвращаем DOUBLE. */
macro Floor_Money(sum)
   if(  (ValType(sum) == V_MONEYL) or (ValType(sum) == V_MONEY))
      return int(Round(double(sum),0));
   elif((ValType(sum) == V_DOUBLE) or (ValType(sum) == V_DOUBLE))
      return Round(sum,0);
   end;
   return sum;
end;

/* Сконвертировать значение в деньги. Если null, то возвращаем $0. */
macro ToMoney( Val )
   if( Val == null )
      return $0;
   else
      return money( Val );
   end;
end;

/* Сконвертировать значение в int. Если null, то возвращаем 0. */
macro ToInt( Val )
   if( Val == null )
      return 0;
   else
      return int( val );
   end;
end;

MACRO ТОЗакрыто( DlRq:TRecHandler ):BOOL
   return ((DlRq != null) and ((DlRq.rec.State == DLRQ_STATE_EXEC) OR (DlRq.rec.State == DLRQ_STATE_GO_CLOSE)));
END;

MACRO ТОВНеттинге( DlRq:TRecHandler ):BOOL
   return ((DlRq != null) and ((DlRq.rec.State == DLRQ_STATE_EXEC) AND (DlRq.rec.Netting == SET_CHAR)));
END;

/*на ТО устанавлен признак <Сквитовано> и статус ТО = <Исполнено>. Нужно ли дополнительно проверять фактическую сумму?*/
MACRO ТОСквитовано( DlRq:TRecHandler ):BOOL
   return ((DlRq != null) and ((DlRq.rec.State == DLRQ_STATE_EXEC) AND (DlRq.rec.IsKvit == SET_CHAR)));
END;

/*проверка на то что для нас ТО было просрочено*/
macro ТОБылоПросрочено( rq:object ):bool
   var Select, DataSet;

   if( rq.rec.State == DLRQ_STATE_OVERDUE)
     return true;
   end;

   Select = DL_RSDCommand(  " select count(1) as cnt from v_rqhist "
                          + "  where t_RQID = ? "
                          + "    and t_State = ? "
                         );

   Select.addParam(rq.rec.ID);
   Select.addParam(DLRQ_STATE_OVERDUE);

   DataSet = Select.execute();

   return ((DataSet.moveNext()) and (DataSet.cnt > 0));
end;

macro ТОБылоПролонгировано( rq:object ):bool
   var Select, DataSet;

   Select = DL_RSDCommand(  " select count(1) as cnt from v_rqhist "
                          + "  where t_RQID = ? "
                          + "    and t_State = ? "
                         );

   Select.addParam(rq.rec.ID);
   Select.addParam(DLRQ_STATE_DELAYED);

   DataSet = Select.execute();

   return ((DataSet.moveNext()) and (DataSet.cnt > 0));
end;

macro ТОЗакрытоНаДату( rq:object, OnDate:Date ):bool
   var Select, DataSet;

   Select = DL_RSDCommand(   " select count(1) as cnt from v_rqhist h "
                           + "  where h.t_RQID = ? "
                           + "    and h.t_FactDate != to_date('01.01.0001','DD.MM.YYYY') "
                           + "    and h.t_FactDate <= ? "
                           + "    and h.t_Instance = (select MAX(h1.t_Instance) "
                           + "                          from v_rqhist h1 "
                           + "                         where h1.t_RQID = h.t_RQID "
                           + "                           and h1.t_ChangeDate <= ?"
                           + "                       )"
                         );

   Select.addParam(rq.rec.ID);
   Select.addParam(OnDate);
   Select.addParam(OnDate);

   DataSet = Select.execute();

   return ((DataSet.moveNext()) and (DataSet.cnt > 0));
end;



MACRO ПолучитьТО(RQID:INTEGER, DlRq:TRecHandler):BOOL
  var Select, DataSet;

  DlRq.Clear();

  Select = DL_RSDCommand("select * from ddlrq_dbt where t_ID = ?");
  Select.AddParam(RQID);
  DataSet = Select.execute();
  if(DataSet.moveNext())
    DataSet.GetRecord().CopyTo( DlRq.rec );
    return true;
  end;  

  return false;
END;

MACRO ПолучитьТОпоДокументу( DocKind:INTEGER, DocID:INTEGER, DealPart:INTEGER, Type:INTEGER, Num:INTEGER, DlRq:TRecHandler, FIID:integer ):BOOL
  var Query, Select, DataSet;

  DlRq.Clear();

  Query = " select * from ddlrq_dbt "
        + "  where t_DocKind = ? "
        + "    and t_DocID = ? "
        + "    and t_DealPart = ? "
        + "    and t_SubKind = ? "
        + "    and t_Type = ? "
        + "    and t_Num = ? ";

  if( FIID != NULL )
     Query = Query + " and t_FIID = ? ";
  end;

  Select = DL_RSDCommand( Query );
  Select.AddParam(DocKind);
  Select.AddParam(DocID);
  Select.AddParam(DealPart);
  Select.AddParam(DL_GetRQSubKindbyType(Type));
  Select.AddParam(Type);
  Select.AddParam(Num);

  if( FIID != NULL )
     Select.AddParam(FIID);
  end;

  DataSet = Select.execute();
  if(DataSet.moveNext())
    DataSet.GetRecord().CopyTo( DlRq.rec );
    return true;
  end;  

  return false;
END;
 
/******************************************************************************
Процедура определения параметров платежа
******************************************************************************/
macro GetPaymentInfo ( 
   deal,         /* Идентификатор или буфер сделки\погашения */
   Purpose,      /* Назначение (вид) платежа */
   rec,          /* Структура платежа*/
   PaymentID,    /* Идентификатор платежа*/
   Type,         /* Тип возвращаемой структуры*/
   SubPurpose,   /* Подвид назначения*/
   UseRealDB     /* Идет поиск идет по постоянной базе данных*/
)
   var DealID, DealKind;

   if( deal != null )
      /*по умолчанию ID сделки с ценными бумагами*/
      if( valtype (deal) == V_INTEGER )
         DealID   = deal;
         DealKind = BofficeKindSP;
      /*если возможны другие виды первичных документов лучше передавать буфер*/
      else
         DealID   = deal.DealID;
         DealKind = deal.BofficeKind;
      end;
   elif( PaymentID == null )
      return false;
   end;

   if (valtype (Type) == V_UNDEF )
     Type = PMS_PAYMENT;  
   end;
   if (valtype (SubPurpose) == V_UNDEF )
     SubPurpose = 0;  
   end;
   if (valtype (UseRealDB) == V_UNDEF )
     UseRealDB = 0;  
   end;

   if (Type == PMS_PAYMENT)
     if (FindPayment (PaymentID, Purpose, SubPurpose, DealKind, DealID, UseRealDB, rec) == 0)
       return true;
     end;
   elif (Type == PMS_DEBET)
     if (FindPayment (PaymentID, Purpose, SubPurpose, DealKind, DealID, UseRealDB, null, rec) == 0)
       return true;
     end;
   elif (Type == PMS_CREDIT)
     if (FindPayment (PaymentID, Purpose, SubPurpose, DealKind, DealID, UseRealDB, null, null, rec) == 0)
       return true;
     end;
   end;
   return false;
end;

/* FIID - Код фин. инструмента, для которого требуется определить валюту покрытия */
macro GetCoverFIID( FIID )
   return NATCUR;  /* Код национальной валюты */
end;

macro RegFooter()
  [
    Регистр составлен                                    (подпись, дата, ФИО)
                     ──────────────────────────────────
    Контроль                                              (подпись, дата, ФИО)
             ────────────────────────────────────────────
  ]
end;


macro begin_date( quarter, year )
    if ( quarter == 1 )   return date(1,1,year);
    elif ( quarter == 2 ) return date(1,4,year);
    elif ( quarter == 3 ) return date(1,7,year);
    elif ( quarter == 4 ) return date(1,10,year);
    end;
end;

macro ending_date( quarter, year )
    if ( quarter == 1 )   return date(31,3,year);
    elif ( quarter == 2 ) return date(30,6,year);
    elif ( quarter == 3 ) return date(30,9,year);
    elif ( quarter == 4 ) return date(31,12,year);
    end;
end;

macro find_index(ids,id)
     var index = ids.size - 1;
     while ( index != -1 )
          if ( ids(index) == id ) return index; end;
          index = index - 1;
     end;
     return index;
end;

private var OperGroupsArray = TArray(); /*кэш*/
private var _Group;
MACRO SP_GetOperationGroup_( DealType, BofficeKind, Flag1, Flag4 )

   if( DealType >= 0 )
      if( OperGroupsArray[DealType] == null )
         _Group = GetOperationGroup( DealType );
         if( _Group < 0 )
            return -1;
         end;
      else
         return OperGroupsArray[DealType];
      end;
   else
      return -1;
   end;

   if( BofficeKind == DL_RETIREMENT )
      if( Flag1 == SET_CHAR ) /*ОРЦБ*/
         _Group = bOR( _Group, 4 );
      elif( Flag4 == SET_CHAR ) /*Брокерское*/
         _Group = bOR( _Group, 16384 ); /*IS_BROKER = 0x4000 (100000000000000)*/
      else /*внебиржевое*/    
         _Group = bOR( _Group, 8192 ); /*IS_OUTEXCHANGE = 0x2000 (10000000000000)*/
      end;
   end;
   OperGroupsArray[DealType] = _Group;

   return _Group;
END;

MACRO SP_GetOperationGroup( Deal )
   return SP_GetOperationGroup_( Deal.DealType, Deal.BofficeKind, Deal.Flag1, Deal.Flag4 );
END;

/* Обертка для GetOperationGroup и SP_GetOperationGroup.
   Нужна для минимизации различий в коде. */
macro GetOpGroup( dl_tick )
   return SP_GetOperationGroup( dl_tick );
end;

/*эта операция - погашение купона*/
MACRO IsRetirementCoupon( dl_tick )
   var Group = SP_GetOperationGroup ( dl_tick); 
   return IsRET_COUPON(Group);
END; 

/* процедура проверяет является ли сделка биржевой*/
MACRO IsDealMarket( dl_tick )   
   var Group = SP_GetOperationGroup( dl_tick); 
   return IsEXCHANGE(Group);
END; 

/* процедура проверяет является ли сделка продажей или покупкой */
/* в понятие "продажа" входит также и погашение бумаг           */
/* погашение купонов выделяется в отдельный тип                 */
MACRO GetDealBuySale( dl_tick, IsBack )   

   var Group = SP_GetOperationGroup ( dl_tick); 
   if (ValType(IsBack) == V_UNDEF)
     IsBack = false;
   end;

   if((dl_tick.BofficeKind == DL_SECUROWN) or 
      (dl_tick.BofficeKind == DL_AVRWRTOWN) or 
      (dl_tick.BofficeKind == DL_RETIREMENT_OWN)
     )

     if( IsRET_COUPON(Group) )
        return DEAL_TYPE_RET_COUPON;
     elif( IsSALE(Group) OR IsAVRWRTOUT(Group) )
        return DEAL_TYPE_SALE;
     elif( IsBUY(Group) OR IsAVRWRTIN(Group) )
        return DEAL_TYPE_BUY;
     end;
   else
     if( IsRET_COUPON(Group) )
        return DEAL_TYPE_RET_COUPON;  
     elif( IsRET_PARTLY(Group) )
        return DEAL_TYPE_RET_PARTLY;  
     elif( (IsSALE(Group) AND (IsBack == false)) OR
           (IsBUY(Group)  AND (IsBack == true) ) OR
           ( (dl_tick.BofficeKind == DL_CONVAVR) AND (IsBack == false)) OR
           IsRET_ISSUE(Group) OR IsAVRWRTOUT(Group) 
         )
        return DEAL_TYPE_SALE;
     elif( (IsBUY(Group)  AND (IsBack == false)) OR
           (IsSALE(Group) AND (IsBack == true) ) OR
           ( (dl_tick.BofficeKind == DL_CONVAVR) AND (IsBack == true)) OR
           IsAVRWRTIN(Group) 
         )
        return DEAL_TYPE_BUY;
     end;
   end;
   return DEAL_TYPE_UNDEF;
END; 

/*Имя вида ц/б*/
macro AvoirKindName(AvoirKind, ShortName, Name);
   file avrkind ("avrkinds");   
   avrkind.FI_Kind = FIKIND_AVOIRISS;
   avrkind.AvoirKind = AvoirKind;
   if(not GetEQ(avrkind))
      RunError("Неизвестный вид ценной бумаги ", AvoirKind);
   end;
   SetParm( 1, avrkind.ShortName );
   SetParm( 2, avrkind.Name );
   return avrkind.Name;
end;

/*Имя вида ц/б
  SubName - название подвида ц/б
*/
macro AvoirKindNameAndSubName(AvoirKind, _ShortName, _Name, _SubName);
   var ShortName = "", Name = "", SubName = "";
   file avrkind ("avrkinds");
   file avrk ("avrkinds");

   avrkind.FI_Kind = FIKIND_AVOIRISS;
   avrkind.AvoirKind = AvoirKind;
   if(not GetEQ(avrkind))
      RunError("Неизвестный вид ценной бумаги ", AvoirKind);
   end;

   if( avrkind.AvoirKind != avrkind.Root )
      SubName = avrkind.Name; /* Название подвида ценной бумаги */

      avrk.FI_Kind = FIKIND_AVOIRISS;
      avrk.AvoirKind = AvrKind.Root;
      if(GetEQ(avrk))         /* Корневой узел */
         Name      = avrk.Name;
         ShortName = avrk.ShortName;
      else
         Name      = "";
         ShortName = "";
      end;
   else
      Name      = avrkind.Name;
      ShortName = avrkind.ShortName;
      SubName   = ""; /* Название подвида ценной бумаги - если корневой, то подвида нет. */
   end;

   SetParm( 1, ShortName );
   SetParm( 2, Name );
   SetParm( 3, SubName );

   return Name;
end;

/* Получаем название значения категории "Вид облигации".
   Если вид не задан или ошибка - возвращаем пустую строку.
      BondKind - значение категории "Вид облигации" */
macro GetNameBondKind( AvoirKind ):STRING
   return AvoirKindNameAndSubName( AvoirKind );
end;

macro ПолучитьСчетаПоОснПлатежу( avr_p, retAccPayer, retAccReceiver, ErrMsg)
  file drprop( spdrprop );
  file drmove(spdrmove);
  file pm_paym(pmpaym) key 0;

  retAccPayer = retAccReceiver = "";
  var  stat = true, msg = "";

  /* ведется учет в депозитарии - ищем поручение депо */
  //if( DL_CustodyAccounting == DL_CUSTODYACCOUNTING_CUSTODY )
     clearrecord( drprop );  
     drprop.PaymentID = avr_p.PaymentID;
     if( not (GetGE(drprop) and (drprop.PaymentID == avr_p.PaymentID)) )          /*Определяем поручение депо */
       stat = false;
       msg = "Ошибка при определении параметров поручения депо";
     else
       drmove.DraftID = drprop.DraftID;
       if( not GetEQ(drmove) )         
         stat = false;
         msg = "Ошибка при определении параметров движения поручения депо";
       else
         pm_paym.PaymentID = drmove.PaymentID; 
         if( not GetEQ(pm_paym) )         
           stat = false;
           msg = "Ошибка при определении платежа по сделки";
         else
           retAccPayer    = pm_paym.PayerAccount;
           retAccReceiver = pm_paym.ReceiverAccount;
         end;
       end;
     end;
  //else
  //   retAccPayer    = avr_p.PayerAccount;
  //   retAccReceiver = avr_p.ReceiverAccount;
  //end; 

  SetParm( 1, retAccPayer );
  SetParm( 2, retAccReceiver );
  SetParm( 3, msg );

  return stat;
end;

private var wrtsum = TBFile( "pmwrtsum.dbt","R" ,1 );

macro ПолучитьЛотПоСделке( Deal, BuySale, pwrtsum, SayError, avr_rq, is_back )

/*is_back - в случае, если явно не передали ТО и сделка с обратной частью */
/* этот параметр определяет часть сделки для которой ищем лот                 */
/* по-умолчанию не задан, то есть берм лот из первой части сделки             */

  var DocKind, DocID, Purpose, Group = SP_GetOperationGroup( Deal), DealPart;
  var rq = TRecHandler("dlrq.dbt"); 

  if( IsRET_COUPON(Group) OR IsRET_PARTLY(Group) )
     DocKind = Deal.BofficeKind;
     DocID   = Deal.DealID;
     if( IsRET_COUPON(Group) )
        Purpose = PM_WRITEOFF_SUM_COUPON;
     else
        Purpose = PM_WRITEOFF_SUM_PARTIAL;
     end;
  else
     if( avr_rq == null ) 
        if( is_back )  
           DealPart = 2;
        else
           DealPart = 1;
        end; 
             
        if( ПолучитьТОпоДокументу(Deal.BofficeKind, Deal.DealID, DealPart, DLRQ_TYPE_DELIVERY, 0, rq) == false)
           if( SayError ) msgbox( "Отсутствуют ТО на поставку ц/б по сделке " + Deal.DealCode ); end;
           return false;
        end;
     else
        Copy( rq, avr_rq );
     end; 

     if( BuySale == -1 )
       BuySale = GetDealBuySale(Deal);
       if( BuySale == DEAL_TYPE_SALE ) 
          if( rq.rec.DealPart == 2 ) 
             BuySale = PM_WRITEOFF_SUM_BUY;
          else 
             BuySale = PM_WRITEOFF_SUM_SALE;
          end;
       else 
          if( rq.rec.DealPart == 2 ) 
             BuySale = PM_WRITEOFF_SUM_SALE;
          else 
             BuySale = PM_WRITEOFF_SUM_BUY;
          end;
       end;
     end;

     DocKind = DLDOC_PAYMENT; 
     DocID   = rq.rec.ID; 
     Purpose = BuySale;
  end;

  wrtsum.Clear();
  wrtsum.rec.DocKind  = DocKind;
  wrtsum.rec.DocID    = DocID;
  wrtsum.rec.Buy_Sale = Purpose; 
  wrtsum.rec.PartNum  = 0;

  if( not wrtsum.GetEQ() )
     if( SayError ) msgbox( "Не найден лот для сделки " +Deal.DealCode ); end;
     return false;
  end;
  Copy( pwrtsum, wrtsum ); 
  return true;
end;

/* Функция получает сделку по лоту.
   Примечание: у лота продажи, созданного операцией неглобального перемещения
   вида "Изменение целей приобретения ц/б", поле DealID не заполнено и
   эта функция для такого лота вернет ошибку. */
macro ПолучитьСделкуПоЛоту( pmwrsum, dl_tick, SayError, BreakProg )
   file Deal(dl_tick);
   
   ClearRecord( Deal ); 
   Deal.DealID = pmwrsum.DealID;
   if( not GetEQ( Deal ) ) 
      if( SayError )
         InformUser( "Не найдена сделка по лоту (DealID = "
                     + string(pmwrsum.DealID) + ")", BreakProg );
      end;
      return false;
   end;
   Copy(dl_tick, Deal);
   return true;
end;

/* Функция получает договор по сделке.
      Deal        -  данные сделки. Сюда передаем старый файл или TBFile.
                     Если передали TBFile, то надо установить флажок в
                     четвертом параметре
      Contr       -  сюда вернем договор
      NoErrMes    -  не показывать сообщение о ошибке
      TBFileFlag  -  флаг. Если true, то считаем, что в первый параметр
                     передан TBFile */
macro ПолучитьДоговорПоСделке( Deal, Contr, NoErrMes, TBFileFlag )
  file  sfcontr(sfcontr) key 0;
  var   SfContrID, DealCode, CommDate;

   if( TBFileFlag )
      DealCode = Deal.rec.DealCode;
      CommDate = Deal.rec.CommDate;
   else
      DealCode = Deal.DealCode;
      CommDate = Deal.CommDate;
   end;

  if( (not SP_GetSfContrID( Deal, SfContrID )) OR (SfContrID == 0) )
     /*в некоторых сделках договор можно и не задавать*/
     if( (CommDate != Date(0,0,0)) AND (NoErrMes != true) ) 
        msgbox( "Не найден договор обслуживания по сделке " + DealCode );
     end;
     return false;                           
  end;
  ClearRecord( sfcontr );
  sfcontr.Id = SfContrID;
  if( not GetEQ(sfcontr) )
     msgbox( "Не найден договор обслуживания по сделке " + DealCode );
     return false;
  end;
  copy( Contr, sfcontr );
  return true;
end;

MACRO ПолучитьНаименованиеСектора( PartyID, PartyOfficeID )
   file office(ptoffice);
   clearrecord(office);
   office.PartyID  = PartyID;
   office.OfficeID = PartyOfficeID;
   if( GetEQ(office) == true ) 
      return office.OfficeName;
   else
      return "";
   end; 
END;


MACRO GetComPaymPurpose( FD )
  if( IsEXCHANGE(FD.Group) )
    return PM_PURP_COMMARKET;
  else
    return PM_PURP_COMBROKER; /*комиссия посреднику*/
  end;
END;

MACRO СтатусПлатежаИсполнен( PaymStatus:INTEGER ):BOOL
   return ( (PaymStatus >= PM_READY_TO_SEND) OR (PaymStatus == PM_CLOSED_W_M_MOVEMENT) );
END;

/*проверка на то что для нас платеж закрыт*/
MACRO ПлатежЗакрыт( paym ):BOOL
   return СтатусПлатежаИсполнен( paym.PaymStatus );
END;

/*Проверяем завершенность всех проводок по сделке*/
MACRO ВыполненыВсеПроводки( FD, error )
  record com_p(pmpaym);
  record deal(dl_tick);
  var    PaymName;
  error = "";

  if( ТОЗакрыто( FD.GetRQ(DLRQ_TYPE_DELIVERY)) != true )
     error = "выполнены не все проводки по учету ц/б";
     PaymName = "по ц/б";
  elif( (not FD.IsOperLOAN) AND (FD.ExistRQMoney(DLRQ_TYPE_PAYMENT)) )
     if( ТОЗакрыто( FD.GetRQ(DLRQ_TYPE_PAYMENT)) != true ) 
     error = "выполнены не все проводки по оплате ц/б";
     PaymName = "по оплате";
     end;
  /*elif( GetPaymentInfo( deal, GetComPaymPurpose( FD ), com_p ) AND
        ( ПлатежЗакрыт( com_p ) != true ) )
     error = "выполнены не все проводки по оплате комиссий";
     PaymName = "комиссии";*/
  end;

  if( error != "" )
     error = "ТО " + PaymName + " не закрыто.|Возможно " + error;
  end;

  SetParm( 1, error );
  return (error == "");  
END;

/* Определяет, какая часть сделки выполняется (true - обратная)*/
macro IsBackExec( tick, TypeStep )

   var Group = SP_GetOperationGroup( tick); 
   var ExistBack = ((IsBACKSALE(Group) == true) OR (IsREPO(Group) == true) );
   
   if( (ExistBack == true) AND
       ( ( (TypeStep == SP_EXECUTE_STEP_SALE) AND IsBUY(Group)) OR
         ( (TypeStep == SP_EXECUTE_STEP_BUY)  AND IsSALE(Group))
       )
     ) 
      return true;
   end;
   return false;
end;


macro GetDaysInYear( year )
  if( (mod(year, 4) == 0) AND ((mod(year,100) != 0) OR (mod(year,400) == 0 )))
     return 366;
  else
     return 365;
  end;
end;

macro PrintRecord( ID )
  var i = 0, n = fldnumber(ID);
[
#]( FileName(ID) );
  while( i < n )
    [##################### = #](fldname(ID, i), ID(i):l);
    i = i + 1;
  end;
end;

macro MsgBoxRecord( ID )
  var i = 0, n = fldnumber(ID), str = "";
  while( i < n )
    str = str + string( fldname(ID, i) ) + " = " + string( ID(i) ) + "|";
    i = i + 1;
  end;
  MsgBox( FileName(ID), "|", str );
end;

/*Возвращает время в формате ЧЧ:ММ*/
macro SPTimeSplit(_Time)
  var Result_Time = "", h, m;
  TimeSplit( _Time, h, m );
  if(m == 0)
    Result_Time = string( h ) + ":" + string(m) + string(m); /*Чтобы не было 7:0 вместо 7:00*/
  elif(m < 10)
    Result_Time = string( h ) + ":" + "0" + string(m); /*Чтобы не было 7:7 вместо 7:07*/
  else  
    Result_Time = string( h ) + ":" + string(m); 
  end;
  return Result_Time;
end;

/* Функция возвращает для заданной биржи ID ведущей биржи или возвращает
   свой ID, если ведущей биржи нет.
      MarketID    -  ID проверяемой биржи
      ADate       -  дата, на которую ищем ведущую биржу, если не задана,
                     то используем текущую операционную */
macro GetLeaderMarketID( MarketID, ADate )
//   return PT_GetLeaderMarketID( MarketID, ADate );
   return MarketID;
end;

/* Функция возвращает код группы, в которую входит указанная биржа.
   Если у биржи есть связанный объект "Ведущая биржа", то возвращаем код этой
   биржи; если связанного объекта нет, то вовзвращаем код проверяемой биржи.
   Код группы - это строка.
      MarketID    -  ID биржи (субъекта)
      Error       -  сюда вернем код ошибки, необязательный параметр,
                     0 - успешное завершение */
macro ПолучитьКодГруппыБиржи( MarketID, Error )
   var
      LeaderMarketID,
      GroupCode;

   LeaderMarketID = GetLeaderMarketID( MarketID );
   GroupCode      = ПолучитьКодСубъекта( LeaderMarketID, PTCK_CONTR, Error );
   if( GroupCode == MICEX_CODE_FB )
      GroupCode = MICEX_CODE;
   end;
   SetParm( 1, Error );

   return GroupCode;
end;

/* Получаем значение настройки "Не использовать счета 47407/08 в сделках
   today". Если произошла ошибка, то возвращаем false. */
macro GetOption_NotUse47407_08( )
   var
      ErrCode, OptionValue;

   GetRegistryValue( "SECUR\\NOT_USE_47407_08_IN_TODAY_DEALS", V_BOOL,
                     OptionValue, ErrCode );

   return OptionValue and (ErrCode == 0);
end;

/*** Работа финансовыми инструментами ****************************************/

   /* Функция получаем номинал ценной бумаги на дату (на конец дня) с учетом
      частичного погашения. Если дата не задана, то вовращает исходный номинал.
      Возвращает double. Если не удалось получить номинал, то возвращает 0.0
         FIID        -  идентификатор финансового инструмента
         NomDate     -  дата, на которую получаем номинал
         SayError    -  сообщить о ошибке при невозможности получить номинал
         BreakProg   -  прервать работу при невозможности получить номинал */
   macro GetFaceValue( FIID:integer, NomDate, SayError, BreakProg )
      var
         Res, FaceValue;

      if( FI_IsInvestmentShare(FIID) )
         return 0.0; /*у паев нет номинала*/
      elif( (NomDate == null) or (NomDate == Date(0,0,0)) )
         /* Получаем исходный номинал. */
         Res = FI_GetNominal( FIID, FaceValue ) == 0;
      else
         /* Получаем номинал на дату. */
         Res = SP_GetNominal( FIID, NomDate, FaceValue, BO_CB );
      end;

      if( Res )
         return FaceValue;
      else
         /* Сбрасываем ошибку. */
         InitError;
         if( SayError )
            InformUser( "Не могу получить номинал фин. инстумента (FIID = "
                        + String(FIID) + ")", BreakProg );
   
         end;
         return 0.0;
      end;
   end;

   /* FIID - Код фин. инструмента, для которого требуется определить валюту номинала */
   macro GetFaceFIID( FIID )
        record iss_fin(fininstr);
        if ( ПолучитьФинИн(FIID, iss_fin) != 0 )
           return 0;
        else           
           if( FI_IsInvestmentShare(iss_fin) )
              return NATCUR;/*у паев нет номинала*/
           else
              return iss_fin.FaceValueFI;
           end;
        end;
   end;

/*** Работа со сделками и их условиями ***************************************/

   /* Возвращаем true, если сделка клиентская. */
   macro IsClientDeal( dl_tick )
      return dl_tick.ClientID != -1;
   end;

   macro СделкаСКлиентомКонтрагентом(dl_tick):BOOL
     if(ValType(dl_tick) == V_GENOBJ)
       return dl_tick.rec.IsPartyClient == SET_CHAR;
     else
       return dl_tick.IsPartyClient == SET_CHAR;
     end;
   end;

   /* Определяем является ли цена в заданной части сделки относительной (т.е.
      в процентах). Возвращаем true, если цена относительная.
         Tick  - сделка
         Leg   - условия сделки */
   macro IsRelativePrice( Tick, Leg )
      /* В погашениях цена не относительная, но ошибочно ставится признак
         RelativePrice. После исправления ошибки проверку надо убрать. */
      return   (Leg.RelativePrice == SET_CHAR)
               and (tick.BOfficeKind != DL_RETIREMENT);
   end;

   /* Функция возвращает плановую дату оплаты или поставки бумаг по сделке.
      Есть возможность брать данные из истории изменений по сделке.
      Есть возможность учесть выходные дни - взять следующий рабочий день,
      или не делать этого.
         Leg               -  условия части сделки
         DealChange        -  необязательный параметр, запись из истории
                              изменения сделки (SPTKCHNG). Если параметр задан,
                              то данные берутся из него
         GetPayDate        -  флаг. Если задан, то берем дату оплаты, если
                              не задан, то берем дату поставки.
         DontSkipHoliday   -  не пропускать выходной день */
   macro GetDealPlanDate( Leg, DealChange, GetPayDate, DontSkipHoliday )
      var
         Maturity, Expiry, MatIsPr, Result;

      if( DealChange != null )
         if( Leg.LegKind == LEG_KIND_DL_TICK_BACK )
            Maturity = DealChange.OldMaturity2;
            Expiry   = DealChange.OldExpiry2;
            MatIsPr  = DealChange.OldMaturityIsPrincipal2;
         else
            Maturity = DealChange.OldMaturity1;
            Expiry   = DealChange.OldExpiry1;
            MatIsPr  = DealChange.OldMaturityIsPrincipal1;
         end;
      else
         Maturity = Leg.Maturity;
         Expiry   = Leg.Expiry;
         MatIsPr  = Leg.MaturityIsPrincipal;
      end;

      if( NOT GetPayDate )
         if( MatIsPr )
            Result = Maturity;
         else
            Result = Expiry;
         end;
      else
         if( MatIsPr )
            Result = Expiry;
         else
            Result = Maturity;
         end;
      end;

      if( DontSkipHoliday )
         return Result;
      else
         return GetDateAfterWorkDays( date(Result), 0 );
      end;
   end;

   /* Функция возвращает настоящую плановую дату поставки бумаг по сделке.
         Leg         -  условия сделки
         DealChange  -  необязательный параметр, запись из истории изменения
                        сделки (SPTKCHNG). Если параметр задан, то данные
                        берутся из него. */
   macro GetRealDealSetAvPlanDate( Leg, DealChange )
      return GetDealPlanDate( Leg, DealChange, false, true );
   end;

   /* Функция возвращает плановую дату поставки бумаг по сделке. Если
      найденная дата попадает на выходной день, то будет возвращена
      дата следующего рабочего дня.
         Leg         -  условия сделки
         DealChange  -  необязательный параметр, запись из истории изменения
                        сделки (SPTKCHNG). Если параметр задан, то данные
                        берутся из него. */
   macro GetDealSetAvPlanDate( Leg, DealChange )
      return GetDealPlanDate( Leg, DealChange, false );
   end;

   /* Функция возвращает плановую дату оплаты по сделке. Если дата попадает
      на выходной день, то будет возвращена дата следующего рабочего дня
         Leg         -  условия сделки
         DealChange  -  необязательный параметр, запись из истории изменения
                        сделки (SPTKCHNG). Если параметр задан, то данные
                        берутся из него. */
   macro GetDealPayPlanDate( Leg, DealChange )
      return GetDealPlanDate( Leg, DealChange, true );
   end;

   /* Получить цену бумаги в заданной части сделки в валюте цены (Leg.CFI).
      Возвращаем double. Если цена задана в процентах, то она пересчитывается
      в реальную сумму. Для пересчета берется валюта номинала на дату
      поставки бумаг. Если задать флаг UseSourceNom, то для пересчета
      будет использован исходный номинал.
      Прим.: когда цена задана в процентах Leg.CFI равно валюте номинала.
         Tick           -  сделка
         Leg            -  условия сделки
         UseSourceNom   -  флаг, использовать исходный номинал при вычислении
                           цены, заданной в процентах.
         DealChange     -  необязательный параметр, запись из истории изменения
                           сделки (SPTKCHNG). Если параметр задан, то данные
                           берутся из него
         _NomDate       -  дата, на которую будем брать номинал.*/
   macro GetPriceByDlTickDlLeg( Tick, Leg, UseSourceNom, DealChange, _NomDate )
      var
         Price, NomDate;

      if( DealChange != null )
         if( Leg.LegKind == LEG_KIND_DL_TICK_BACK )
            Price = DealChange.OldPrice2;
         else
            Price = DealChange.OldPrice1;
         end;
      else
         Price = Leg.Price;
      end;

      /* Определяем дату, на которую будет брать номинал. */
      if( UseSourceNom )
         NomDate = null;
      else
         if( (ValType(_NomDate) != V_UNDEF) and (_NomDate != date(0,0,0)) )
           NomDate = _NomDate;
         else
           NomDate = GetRealDealSetAvPlanDate( Leg, DealChange );
         end;
      end;

      if( IsRelativePrice(Tick, Leg) )
         /* Цена задана в процентах от номинала. */
         return Price * GetFaceValue( Leg.PFI, NomDate ) / 100.0;
      else
         /* Цена задана в реальной суммой. */
         return Price;
      end;
   end;

   /* Проверяем, был ли отказ от исполнения части сделки на дату, т.е. до
      заданной даты включительно. Если дата не задана, то проверяем был ли
      вообще отказ от исполнения.
         DlLeg    -  условия части сделки         
         ADate    -  дата, на которую проверям отказ. Необязательный параметр. */
   macro WasRejectDealPart( DlLeg, ADate )
      return   (DlLeg.RejectDate != Date(0,0,0))
               and ((ADate == null) or (DlLeg.RejectDate <= ADate));
   end;

/*** Работа с субъектами *****************************************************/

   /* Находим субъекта по коду и возвращаем ссылку на буфер записи.
      Если произошла ошибка, то возвращаем пустой буфер.
         PartyID     - код субъекта
         SayError    - флаг, информировать пользователя о ошибке
         BreakProg   - флаг, аварийно завершать работу программы */
private var party = TRecHandler( "party" );
macro GetPartyByID( PartyID, SayError, BreakProg )
   
   if(PartyID > 0)
      if( PartyID != party.rec.partyid ) /*если не то что мы уже получали*/
         if( ПолучитьСубъекта( PartyID, party ))
            party.Clear();
            if( SayError )
               InformUser( "Не могу получить данные о субъекте (PartyID = "
                           + String(PartyID) + ")", BreakProg );
            end;
         end;
      end;
   else
      party.Clear();
   end;

   return party.rec;
end;

/*** *************************************************************************/

   /* Замена старой конструкции ID > {OurBank}. Не во всех случаях,
      надо смотреть по контексту. */
   macro ID_gr_OurBank( ID )
      return (ID > 0) and (ID != {OurBank});
   end;

   /* Замена старой конструкции ID <= {OurBank}. Не во всех случаях,
      надо смотреть по контексту. */
   macro ID_le_OurBank( ID )
      return (ID <= 0) or (ID == {OurBank});
   end;
/****************************************************************************/

/* Функция возвращает наименование операции.
      Group                   -  группа операции
      IsBack                  -  флаг, вторая часть сделки
      ShowPart                -  флаг, будет указана часть сделки
      NewRepoNaming           -  флаг, называть РЕПО/продажу прямым РЕПО,
                                 РЕПО/покупку - обратным РЕПО.
      DontShowCB              -  флаг, не указывать текст " ц/б"
      ShowCommaBeforePartNum  -  указывать запятую перед номером части
      FirstCharToUpper        -  первый символ сделать большим */
macro ПолучитьВидОперации( Group, IsBack, ShowPart, NewRepoNaming,
                           DontShowCB, ShowCommaBeforePartNum,
                           FirstCharToUpper )
   var
      CBText         = IIF( DontShowCB, "", " ц/б" ),
      PartNumPrefix  = IIF( ShowCommaBeforePartNum, ",", "" ),
      BuySale        = "",
      Oper_Kind      = "";

   if(IsBuy(Group))
     BuySale = "покупка" + CBText;
   elif(IsSale(Group))
     BuySale = "продажа" + CBText;
   elif(IsRET_PARTLY(Group))
     BuySale = "част. погашение";
   elif(IsRET_ISSUE(Group))
     BuySale = "погашение обл.";
   elif(IsRET_COUPON(Group))
     BuySale = "погашение куп.";
   elif(IsAVRWRTIN(Group))
     BuySale = "перевод (зачисл.)" + CBText;
   elif(IsAVRWRTOUT(Group))
     BuySale = "перевод (списан.)" + CBText;
   elif( IsCONVERT_SHARE(Group) )
     BuySale = "конвертация акций в деп. расписки";
   elif( IsCONVERT_RECEIPT(Group) )
     BuySale = "конвертация деп. расписок в акции";
   end;

   if( IsREPO(Group) )
      if( NewRepoNaming )
         if( IsEXCHANGE(Group) )
            Oper_Kind = IIF( IsBuy(Group), "обратное РЕПО на бирже БПП", "прямое РЕПО на бирже БПП" );
         else
            if( IsBasket(Group) )
               Oper_Kind = "прямое РЕПО на корзину";
            else
               Oper_Kind = IIF( IsBuy(Group), "обратное РЕПО БПП", "прямое РЕПО БПП" );
            end;
         end;
      else
         if( IsBasket(Group) )
            Oper_Kind = "прямое РЕПО на корзину";
         else
            Oper_Kind = "РЕПО/" + BuySale;
         end;
      end;
   elif(IsBACKSALE(Group))
     if(IsBuy(Group))
       Oper_Kind = BuySale + " c ОП";
     else
       Oper_Kind = BuySale + " c ОВ";
     end;
   else
     Oper_Kind = BuySale;
   end;

   if(ShowPart AND (IsBackSale(Group) OR IsREPO(Group)))
     if(IsBack == false)
       Oper_Kind = Oper_Kind + PartNumPrefix + " 1 ч.";
     else
       Oper_Kind = Oper_Kind + PartNumPrefix + " 2 ч.";
     end;
   end;

   if( FirstCharToUpper )
      Oper_Kind = StrUpr( Oper_Kind, 1 );
   end;

   return Oper_Kind;
end;

/* Надежность определения ТСС */
MACRO ExistNOSS( avr, dat, param:INTEGER ):BOOL
  VAR NumInList = "", ValidFromDate = DATE(0,0,0);

  if( param == null )
  return (    (GetMainObjAttr( null, OBJTYPE_AVOIRISS, UniID(avr, OBJTYPE_AVOIRISS), 27/*Возможность надежного расчета TCC*/, null, null, NumInList, dat, ValidFromDate) == true)
          AND (ValidFromDate <= dat)
          AND (NumInList == "1")
         );
  else
     return (    (GetMainObjAttr( null, OBJTYPE_AVOIRISS, UniID(avr, OBJTYPE_AVOIRISS), param, null, null, NumInList, dat, ValidFromDate) == true)
             AND (ValidFromDate <= dat)
             AND (NumInList == "1")
            );
  end;

END;

//Получить значение категории "Наблюдаемы исходные данные для ц/б"
MACRO GetObservedBaselineDataAttrID(FIID:integer)
  var cmd, DataSet;
  var res = 0;

  cmd = DL_RSDCommand("select RSB_SECUR.GetMainObjAttrNoDate("+OBJTYPE_AVOIRISS+", LPAD(?, 10, '0'), "+OBJGROUP_OBSERVEDBASELINEDATA+") as Res from dual");

  cmd.AddParam(FIID);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    res = DataSet.Res;
  end;

  return res;
END;

//Получить значение категории "Наблюдаемы исходные данные для сделки"
MACRO Get_Deal_ObservedBaselineDataAttrID(DealID:integer)
  var cmd, DataSet;
  var res = 0;

  cmd = DL_RSDCommand(  " select RSB_SECUR.GetMainObjAttrNoDate(RSB_SECUR.GetDealObjType(t_BOfficeKind), LPAD(t_DealID, 34, '0'), "+OBJGROUP_TICKOBSERVEDBASELINEDATA+") as Res " 
                      + "   from ddl_tick_dbt "
                      + "  where t_DealID = ?"
                     );

  cmd.AddParam(DealID);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    res = DataSet.Res;
  end;

  return res;
END;

//Получить значение категории "Тест на рыночность пройден" для сделки
MACRO GetMarketTestAttrID(DealID:integer)
  var cmd, DataSet;
  var res = 0;

  cmd = DL_RSDCommand(  " select RSB_SECUR.GetMainObjAttrNoDate(RSB_SECUR.GetDealObjType(t_BOfficeKind), LPAD(t_DealID, 34, '0'), "+OBJGROUP_MARKETTEST+") as Res " 
                      + "   from ddl_tick_dbt "
                      + "  where t_DealID = ?"
                     );

  cmd.AddParam(DealID);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    res = DataSet.Res;
  end;

  return res;
END;


MACRO CalcExecDealMarketTest(DealID:integer, OnDate:date)
  var cmd, DataSet;
  var res = 0;

  cmd = DL_RSDCommand("select RSB_SECUR.CalcExecDealMarketTest(?, ?) as Res from dual");

  cmd.AddParam(DealID);
  cmd.AddParam(OnDate);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    res = DataSet.Res;
  end;

  return res;
END;

//Существенны затраты по договору или нет
MACRO IsEssentialSumByContrCost(CalcDate:DATE,PortfolioID:integer,DoCompareRUB:money,ToCompareRUB:money):integer
  var cmd, DataSet;
  var res = 0;

  cmd = DL_RSDCommand("select Rsb_Secur.IsEssentialSumByContrCost(?,?,?,?) as Res from dual");

  cmd.AddParam(CalcDate);
  cmd.AddParam(PortfolioID);
  cmd.AddParam(DoCompareRUB);
  cmd.AddParam(ToCompareRUB);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    res = DataSet.Res;
  end;

  return res;
END;


//Получить значение категории "Квалификационный признак суборд.ОЭБ"
MACRO GetSubordCvalTypeAttrID(FIID:integer)
  var cmd, DataSet;
  var res = 0;

  cmd = DL_RSDCommand("select RSB_SECUR.GetMainObjAttrNoDate("+OBJTYPE_AVOIRISS+", LPAD(?, 10, '0'), "+OBJGROUP_SUBORDCVALTYPE+") as Res from dual");

  cmd.AddParam(FIID);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    res = DataSet.Res;
  end;

  return res;
END;


/*
Неквалифицированные ценные бумаги:
-  ценные бумаги, эмитент которых не является резидентом, и для которых задано значение кате-гории "Квалификация в качестве ценной бумаги" равное "Не квалифицирована в качестве цен-ной бумаги"
!!!Внимание! Значение категории "Квалификация в качестве ценной бумаги" проверяется по со-стоянию на ДАТУ ЗАКЛЮЧЕНИЯ СДЕЛКИ!

Квалифицированные ценные бумаги:
-  все ценные бумаги, эмитент которых является резидентом,
-  ценные бумаги, эмитент которых не является резидентом, и для которых НЕ задано значение категории "Квалификация:" равное "Не квалифицирована в качестве ценной бумаги"
!!! т.е.  квалифицированными считаем все бумаги, кроме отмеченных как "неквалифицирован-ные";
Другими словами, ц/б, для которых категория "Квалификация:" не задана, считаем квалифици-рованными.
*/
MACRO QualifiedSecur( avr, fin, dat ):BOOL
  VAR NumInList = "", ValidFromDate = DATE(0,0,0);
  return not (  (GetMainObjAttr( null, OBJTYPE_AVOIRISS, UniID(avr, OBJTYPE_AVOIRISS), 28/*Квалифицирована в качестве цб*/, null, null, NumInList, dat, ValidFromDate) == true)
                AND (ValidFromDate <= dat)
                AND (NumInList == "0")
                AND (GetPartyByID( fin.rec.Issuer ).NotResident == SET_CHAR)
             );
END;

macro GetAgentOnceComm(BOfficeKind, DealID, CommDate, SummCom:@MONEY, NDS:@MONEY, Currency:@INTEGER):BOOL
   var IsFind = false;
   var
       FindComm = TRecHandler( "dlsum" );

    SummCom = $0;
    NDS     = $0; 
    Currency = null;

   if( FindDLSUM( BOfficeKind, DealID, DLSUM_KIND_AGENT_ONCE, CommDate, FindComm ) == 0 ) 
       IsFind   = true;
       SummCom  = FindComm.rec.Sum;
       NDS      = FindComm.rec.NDS; 
       Currency = FindComm.rec.Currency;
   end;

   return IsFind;
end;

/* Увеличить значение переменной.
      Variable -  Переменная. Если равна null, то считаем ее равной 0.
      IncValue -  Необязательный параметр. На это значение увеличиваем.
                  Если не задан, то увеличиваем на 1 */
macro inc( Variable, IncValue )

   if( IncValue == null )
      IncValue = 1;
   end;

   if( Variable == null )
      Variable = 0;
   end;

   SetParm( 0, Variable + IncValue );
end;


/* Получить документ по сделке. Возвращаем буфер записи spground.
   С помощью функции можно получить несколько документов.
   Для этого используется параметр SerialNumRec: 1 - получить
   первую подходящую запись, 2 - получить вторую и т.д. Если запись не
   нашли, то возвращаем пустой буфер.
      DealID         -  код сделки
      KindDoc        -  вид документа, который хочем получить
      SerialNumRec   -  порядковый номер документа в ключевой
                        последовательности, который хотим получить. Если не
                        задан, то 1 (получаем первый подходящий).
      BOfficeKind    -  вид первичного документа. Если не задан, то
                        DL_SECURITYDOC */
macro GetSPGroundRecByDeal( DealID, KindDoc, SerialNumRec, BOfficeKind )
 
   return DL_GetGroundRecByDeal (DealID, KindDoc, SerialNumRec, BOfficeKind);
       
end;

MACRO PT_IsResponsible( PartyID:INTEGER, CalcDate:DATE ):BOOL
   var cmd;
   cmd = RsdCommand(RslDefCon, "begin\n ? := RSB_PMWRTOFF.PT_IsResponsible(?,?);\n end; ");

   cmd.addParam("ret_val"   ,  RSDBP_RETVAL, V_INTEGER );
   cmd.addParam("PartyID"   ,  RSDBP_IN,     PartyID   );
   cmd.addParam("OperDate"  ,  RSDBP_IN,     CalcDate  );
   cmd.execute();

   if (cmd.Value(0) == 1)
      return true;
   end;
   return false;
END;

MACRO WRTGetWrtAmount( Department, FIID, Party, Contract, Portfolio, Coupon, Partly, CalcDate, StartDate )
   var cmd;
   cmd = RsdCommand(RslDefCon, "begin\n ? := RSB_PMWRTOFF.WRTGetWrtAmount(?,?,?,?,?,?,?,?,?,?);\n end; ");

   cmd.addParam("ret_val"    ,  RSDBP_RETVAL, V_DOUBLE  );
   cmd.addParam("Department" ,  RSDBP_IN,     Department);
   cmd.addParam("FIID"       ,  RSDBP_IN,     FIID      );
   cmd.addParam("Party"      ,  RSDBP_IN,     Party     );
   cmd.addParam("Contract"   ,  RSDBP_IN,     Contract  );
   cmd.addParam("Portfolio"  ,  RSDBP_IN,     Portfolio );

   cmd.addParam("Coupon"     ,  RSDBP_IN,     Coupon    );
   cmd.addParam("Partly"     ,  RSDBP_IN,     Partly    );

   cmd.addParam("CalcDate"   ,  RSDBP_IN,     CalcDate  );
   cmd.addParam("StartDate"  ,  RSDBP_IN,     StartDate  );
   cmd.addParam("IsTrust"    ,  RSDBP_IN,     0  );
   cmd.execute();

   return cmd.Value(0);
END;

/*проверить сделку при удалении (в режиме хранилища данных для НУ)*/
MACRO SP_CheckTaxDatePreDel( rq_avoir ) 
   var LastTaxDate = Date(0,0,0), err;

   GetRegistryValue("SECUR\\DATE_BUILD_TAXREG", V_STRING, LastTaxDate, err);
   if( err!=0 )
      MsgBox( "Ошибка при получении значения настройки SECUR\\DATE_BUILD_TAXREG");
      return false;
   end;

   if( not ТОЗакрыто(rq_avoir) OR (ТОЗакрыто(rq_avoir) and (rq_avoir.rec.FactDate > LastTaxDate)) ) 
      return true;
   else
      if( MsgBoxEx( "По сделке уже выполнялись расчеты в системе. Продолжить?",
                    MB_YES+MB_NO, IND_NO, 
                    "", "") == IND_YES )
         return true;
      else
         return false;
      end;
   end;

   return true;
END;

/*Получить процент котрольного пакета акций из примечания для субъекта*/
MACRO ПроцентКонтрПакетаАкций(Percent:@double,PartyID:integer,NoteDate:Date,ErrorMes:@STRING)
  var tbfParty = TBfile("party.dbt");

  Percent = 0.0;

  tbfParty.rec.PartyID = PartyID;
  if(tbfParty.GetEQ())
     Percent = readNoteForObject( OBJTYPE_PARTY, UniID( tbfParty, OBJTYPE_PARTY), 53, NoteDate );
     if( Percent <= 0. )
        ErrorMes = "Для эмитента "+string(tbfParty.rec.ShortName)+" не задано примечание |\"" + ИмяПримечания( OBJTYPE_PARTY, 53 ) + "\" на дату " + string(NoteDate);
        return false;
     elif( Percent > 100. )
        ErrorMes = "Для эмитента "+string(tbfParty.rec.ShortName) + 
                   " задано неверное значение примечания |\"" + ИмяПримечания( OBJTYPE_PARTY, 53 ) + "\" на дату " + string(NoteDate);
       return false;
     end;
  end;

  return true;
END;

/*является ли AttrID родителем CheckAttrID*/
macro SP_ObjAttrEQ(ObjectType:INTEGER, GroupID:INTEGER, AttrID:INTEGER, CheckAttrID:INTEGER)
  var cmd, DS;

  if( AttrID == CheckAttrID )
     return 1;
  end;

  cmd = RSDCommand( "SELECT 1 "+
                    "  FROM dual "+
                    " WHERE ? IN (SELECT t_AttrID "+
                    "               FROM dobjattr_dbt "+
                    "             START WITH t_objecttype = ? AND t_GroupID = ? AND t_AttrID = ? "+
                    "             CONNECT BY t_objecttype = PRIOR ? AND t_GroupID = PRIOR ? AND t_AttrID = PRIOR t_ParentID)" 
                  );
  cmd.addParam( "", RSDBP_IN, AttrID );
  cmd.addParam( "", RSDBP_IN, ObjectType );
  cmd.addParam( "", RSDBP_IN, GroupID );
  cmd.addParam( "", RSDBP_IN, CheckAttrID );
  cmd.addParam( "", RSDBP_IN, ObjectType );
  cmd.addParam( "", RSDBP_IN, GroupID );
  cmd.execute();
  DS = TRsbDataSet(cmd);
  if( DS.movenext() )
     return 1;
  end;
  return 0;
end;

/*является ли NumInList родителем CheckNumInList*/
macro SP_ObjNuminListEQ(ObjectType:INTEGER, GroupID:INTEGER, NumInList:STRING, CheckNumInList:STRING)
  var cmd, DS;

  if( NumInList == CheckNumInList )
     return 1;
  end;

  cmd = RSDCommand( "SELECT 1 "+
                    "  FROM dual "+
                    " WHERE to_char(?) IN (SELECT t_NumInlist "+
                    "                        FROM dobjattr_dbt "+
                    "                  START WITH t_objecttype = ? AND t_GroupID = ? AND t_NumInList = to_char(?) "+
                    "                  CONNECT BY t_objecttype = PRIOR ? AND t_GroupID = PRIOR ? AND t_AttrID = PRIOR t_ParentID)" 
                  );
  cmd.addParam( "", RSDBP_IN, NumInList );
  cmd.addParam( "", RSDBP_IN, ObjectType );
  cmd.addParam( "", RSDBP_IN, GroupID );
  cmd.addParam( "", RSDBP_IN, CheckNumInList );
  cmd.addParam( "", RSDBP_IN, ObjectType );
  cmd.addParam( "", RSDBP_IN, GroupID );
  cmd.execute();
  DS = TRsbDataSet(cmd);
  if( DS.movenext() )
     return 1;
  end;
  return 0;
end;

PRIVATE VAR Использовать47422_23ПриПогашении_:BOOL = NULL;
MACRO Использовать47422_23ПриПогашении():BOOL
  CONST RegPath = "SECUR\\ИСПОЛЬЗ. 47422_23 ПРИ ПОГАШЕНИИ";
  VAR   err;

  if( Использовать47422_23ПриПогашении_ == NULL )
     GetRegistryValue( RegPath, V_BOOL, Использовать47422_23ПриПогашении_, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return Использовать47422_23ПриПогашении_;
END;

macro ПолучитьНомерСделки (FD)
   var Ground;
   
   Ground = FD.tick.rec.DealCodeTS + " от " + StrSubst(String(FD.tick.rec.DealDate), " ", "0");
   if (Trim(Ground) == "")
      Ground = FD.GetParametr(MC_TYPE_PARAMETR_NUMBER, NULL, NULL, NULL);
   end;
   return Ground;
end;


CONST MOMENT_GET_COMISS    = 1, /*номер категории "Момент взимания комиссии"*/
      MOMENT_CALC_COMISS   = 5; /*номер категории "Момент расчета комиссии"*/

/*проверить признак на категории с номером _NumberGroup           */
/* _NumberGroup = MOMENT_GET_COMISS ("момент взимания комиссии")  */
/* _NumberGroup = MOMENT_CALC_COMISS ("момент расчета комиссии")  */
/* возможные значения MomentStr                                   */
/* DPD - дата оплаты сделки                                       */
/* DSD - дата заключения сделки                                   */
MACRO ПроверитьКатегориюКомиссии( rCom, MomentStr, _NumberGroup )

   var objattr = TRecHandler("objattr.dbt");
   var   loop:bool, find:bool = false;
   var   NumberGroup:integer;

   if( _NumberGroup == null )
      NumberGroup = MOMENT_GET_COMISS; /*по умолчанию смотрим категорию "Момент взимания комиссии" */
   else
      NumberGroup = _NumberGroup;
   end;

   objattr.clear();
   loop = ObjAttr_FindFirst( objattr, OBJTYPE_SFCOMISS, UniID( rCom, OBJTYPE_SFCOMISS), NumberGroup );
   while( loop == 0 )          
      if( objattr.rec.NameObject == MomentStr )
         loop  = 1;
         find  = true;
      else
         loop = ObjAttr_FindNext( objattr );
      end;      
   end;
   ObjAttr_FindClose();   
   return find; 
END;

//Получить минимальную дату комиссии по сделке, с даты.
//Вход:                                                  
//   pDocKind - вид ПД сделки                       
//   pDocID - ID ПД сделки                          
//   pSinceDate - с даты. Может быть не задана      
//   pReceiver - получатель. Может быть не задан    
macro SP_GetMinComPlanDateByDeal( pDocKind:integer, pDocID:integer, pSinceDate_:date, pReceiver_:integer )

   var pSinceDate:date = DATE(0,0,0);
   var pReceiver:integer = -1;
   var sql, DataSet;

   if( (pSinceDate_!=null) and (pSinceDate_!=DATE(0,0,0)) )
      pSinceDate = pSinceDate_;
   end;

   if( (pReceiver_!=null) and (pReceiver_ > 0) )
      pReceiver = pReceiver_;
   end;

   sql = RSDCommand( "select NVL(MIN(DLCOM.T_PLANPAYDATE),TO_DATE('01.01.0001','DD.MM.YYYY')) PLANPAYDATE " +       
                     "  from DDLCOMIS_DBT DLCOM, dsfcomiss_dbt sfcom "+
                     " where DLCOM.T_DOCKIND = ? "+
                     "   and DLCOM.T_DOCID = ? "+
                     IIF(pSinceDate!=DATE(0,0,0)," and DLCOM.T_PLANPAYDATE >= "+GetSQLDate(pSinceDate),"")+
                     IIF(pReceiver>0," and NVL((select M.T_RECEIVERID from DSFCOMISS_DBT M "+
                     "                           where M.T_FEETYPE = DLCOM.T_FEETYPE "+
                     "                             AND M.T_NUMBER  = DLCOM.T_COMNUMBER ),0) = " +string(pReceiver),"")+
                     "   and rsb_secur.CheckExistGrDealByCom(DLCOM.T_DocKind, DLCOM.T_DocID, DLCOM.T_Contract, DLCOM.T_PLANPAYDATE, "+DLGRACC_STATE_FACTEXEC+") = 0 "+
                     "   and sfcom.t_FeeType = DLCOM.t_FeeType " +
                     "   and sfcom.t_Number = DLCOM.t_ComNumber " +
                     "   and sfcom.T_SERVICEKIND = ? ");

   sql.addParam( "", RSDBP_IN, pDocKind );
   sql.addParam( "", RSDBP_IN, pDocID );
   sql.addParam( "", RSDBP_IN, PTSK_STOCKDL );

   sql.execute();                                 
                                                     
   DataSet = TRsbDataSet(sql);                    
                                               
   if(DataSet.MoveNext())
      return SQL_ConvTypeDate(DataSet.PLANPAYDATE);               
   end;                                           

   return DATE(0,0,0);
end;

//Получить значение настройки "ИСПОЛЬЗОВАТЬ КОНВЕЙЕР"
macro SecurUseConveyer(ConvID, OperID)
   // не запускать что-то под конвейером, когда мы уже и так сами находимся в режиме веб-сервиса
   return (not DL_IsWebService()) and DL_SecurUseConveyer(ConvID, OperID);
end;

//Получить значение ПОЛЬЗОВАТЕЛЬСКОЙ настройки "ИСПОЛЬЗОВАТЬ КОНВЕЙЕР"
macro UserSecurUseConveyer()
   // не запускать что-то под конвейером, когда мы уже и так сами находимся в режиме веб-сервиса
   return (not DL_IsWebService()) and UserDL_SecurUseConveyer();
end;



//Получить значение настройки "NRD_CODE"
macro GetSecurNRDCode()
   var ErrCode = 0, CodeStr = "";

   GetRegistryValue( "SECUR\\NRD_CODE", V_STRING, CodeStr, ErrCode );
   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"SECUR\\NRD_CODE\"");
   end;

   return CodeStr;
end;

PRIVATE VAR ПарностьСчетовПереоценки_:BOOL = NULL;
MACRO ПарностьСчетовПереоценки():BOOL
  CONST RegPath = "SECUR\\ПАРНОСТЬ СЧЕТОВ ПЕРЕОЦЕНКИ";
  VAR   err;

  if( ПарностьСчетовПереоценки_ == NULL )
     GetRegistryValue( RegPath, V_BOOL, ПарностьСчетовПереоценки_, err );
     if( err != 0 )
        MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
     end;
  end;
  return ПарностьСчетовПереоценки_;
END;

//получить уникальный ключ
macro SP_GetGUID()
  return DL_GetGUID();
end;

//Получить значение настройки "ДАТА НАЧАЛА НОВОГО БУ РЕПО"
macro GetSecurNewRepoDate()
   var ErrCode = 0, Str = "";
   var NewRepoDate = date(31,12,2099);

   GetRegistryValue( "SECUR\\ДАТА НАЧАЛА НОВОГО БУ РЕПО", V_STRING, Str, ErrCode );
   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"SECUR\\ДАТА НАЧАЛА НОВОГО БУ РЕПО\"");
   else
      NewRepoDate = date(Str);
   end;

   return NewRepoDate;
end;

//Получить значение настройки "СРОК ПРОВЕРКИ СТАТУСА КИ"
macro GetSecurCheckStatusQIValidPeriod()
   var ErrCode = 0;
   var period = 0; /*Период в днях*/

   GetRegistryValue( "SECUR\\СРОК ПРОВЕРКИ СТАТУСА КИ", V_INTEGER, period, ErrCode );
   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"SECUR\\СРОК ПРОВЕРКИ СТАТУСА КИ\"");
   end;

   return period;
end;


//Получить значение настройки "НЕ ВЫПОЛНЯТЬ ОТРИЦ. ПЕРЕОЦЕНКУ"
macro SecurNotExecMinusOver()
   var ErrCode = 0, OptionValue = true;

   GetRegistryValue( "SECUR\\НЕ ВЫПОЛНЯТЬ ОТРИЦ. ПЕРЕОЦЕНКУ", V_BOOL, OptionValue, ErrCode );
   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"SECUR\\НЕ ВЫПОЛНЯТЬ ОТРИЦ. ПЕРЕОЦЕНКУ\"");
   end;

   return OptionValue;
end;

PRIVATE VAR CalcLimitIncomeREPO:BOOL = NULL;
macro CheckCalcLimitIncomeREPO()
   var ErrCode;

   GetRegistryValue( "SECUR\\НОРМИРОВАНИЕ ДОХОДОВ ПО РЕПО", V_BOOL, CalcLimitIncomeREPO, ErrCode );

   return CalcLimitIncomeREPO and (ErrCode == 0);
end;

macro ИспКлиринговыйСчетВРЕПОсКСУ()
  var ErrCode = 0;
  var val = 0;
  var ret = true; 

  GetRegistryValue( "SECUR\\СХЕМА БУ В РЕПО С КСУ", V_INTEGER, Val, ErrCode );
  if( ErrCode != 0 )
     MsgBox( "Ошибка при получении значения настройки \"SECUR\\СХЕМА БУ В РЕПО С КСУ\"");
  end;

  if(val != 0)
    ret = false;
  end;

  return ret;
end;

macro ПокупкаЗаключенаВЦеляхИсполнения2ЧРЕПО(DealID)

  var tick = TRecHandler("dl_tick.dbt");
  var flag = false;

  tick.Clear();
  tick.rec.DealID = DealID;

  if(DL_GetMainObjAttr( tick, OBJGROUP_TICKBUYFORREPO, OBJTYPE_SECDEAL ) > 0 )
    flag = true;
  end;

  return flag;
end;

PRIVATE VAR SymbolOFRInCarry:BOOL = NULL;
macro SC_SymbolOFRInCarry():bool
  var ErrCode;

  GetRegistryValue("SECUR\\СИМВОЛ ОФР В ПРОВОДКАХ ДК", V_BOOL, SymbolOFRInCarry, ErrCode);

  return SymbolOFRInCarry and (ErrCode == 0);
end;

macro ИнтегрированныйРежим()
  var ErrCode, Path = "COMMON\\WORK_MODE\\INTEGRATED", Integr = false;

  GetRegistryValue(Path, V_BOOL, Integr, ErrCode);
  if( ErrCode != 0 )
     MsgBox("Ошибка при получении значения настройки \"" + Path + "\"");
     Integr = false;
  end;

  return Integr;
end;

macro ИмпортСведенийОДефолтеЦБ()
  var ErrCode, Path = "SECUR\\ИМПОРТ СВЕДЕНИЙ О ДЕФОЛТЕ ЦБ", RetVal = false;

  GetRegistryValue(Path, V_BOOL, RetVal, ErrCode);
  if( ErrCode != 0 )
     MsgBox("Ошибка при получении значения настройки \"" + Path + "\"");
     RetVal = false;
  end;

  return RetVal;
end;

macro КБКдляЕНП()
  var ErrCode, Path = "COMMON\\НДФЛ\\КБК_ДЛЯ_ЕНП", RetVal = "";

  GetRegistryValue(Path, V_STRING, RetVal, ErrCode);
  if( ErrCode != 0 )
     MsgBox("Ошибка при получении значения настройки \"" + Path + "\"");
     RetVal = "";
  end;

  return RetVal;
end;

macro СрокПеречисленияНДФЛпоЦБ()
  var ErrCode, Path = "COMMON\\НДФЛ\\СРОК_ПЕРЕЧИСЛЕНИЯ_НДФЛ_ПО_ЦБ", RetVal = 0;

  GetRegistryValue(Path, V_INTEGER, RetVal, ErrCode);
  if( ErrCode != 0 )
     MsgBox("Ошибка при получении значения настройки \"" + Path + "\"");
     RetVal = 0;
  end;

  return RetVal;
end;

macro ПереключениРеквизитовЕНП()
  var ErrCode, Path = "COMMON\\НДФЛ\\ПЕРЕКЛЮЧЕНИЕ_РЕКВИЗИТОВ_ЕНП", RetVal = 0;

  GetRegistryValue(Path, V_INTEGER, RetVal, ErrCode);
  if( ErrCode != 0 )
     MsgBox("Ошибка при получении значения настройки \"" + Path + "\"");
     RetVal = 0;
  end;

  return RetVal;
end;

/*текущий статус учета*/
MACRO SC_GetDlGrAccCurrentState(TemplNum:integer,AccNum:integer,DocID:integer)
  var    DataSet, cmd, State = -1;

  cmd = DL_RSDCommand(   " select gracc.t_State "
                       + "   from ddlgrdeal_dbt grdeal, ddlgracc_dbt gracc "
                       + "  where grdeal.t_TemplNum = ? "
                       + "    and gracc.t_GrDealID = grdeal.t_ID "
                       + "    and gracc.t_AccNum = ? " 
                       + "    and grdeal.t_DocID = ? "  
                     );
  
  
  cmd.AddParam(TemplNum);
  cmd.AddParam(AccNum);
  cmd.AddParam(DocID);
  
  DataSet = cmd.execute();
  
  if( DataSet.MoveNext() )
     State = DataSet.State;
  end;

  return State;
END;

/* Получить системный тип по операции по сделке
*/
MACRO SC_GetSysTypes(DealType)
var
   opr = TBfile("oprkoper");

   opr.rec.Kind_Operation = DealType;
   if(opr.GetEQ())
      return opr.rec.SysTypes;
   end;

   return "";
END;
