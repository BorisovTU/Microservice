/**
 @file 		mac\dlng\secur\sp_class.mac
 @brief 	Ценные бумаги. Классы для работы c категориями учета. Базовый класс и класс для работы со сделками

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |03.07.2025 |Велигжанин А.В.|BOSS-7143                                       |доработка платежа для целей списания
*/
IMPORT Календарь, "secinter.mac", "sp_cattp.mac", "spserv.mac", "sp_carrl.mac", "mccatacf.mac", "dlquery.mac", "mccatacc.mac", "dl_calendcore.mac";
IMPORT "role_model.mac";
import "padej.mac";//GAA: 501667 
import "dlcontrfunc.mac";

private record _dl_tick(dl_tick);
private const BASKET_OFFICE_CODE = "6"; /*РЕПО на корзину*/


Private Macro UserGetDealCode(FD)
  If(IsEXCHANGE(FD.Group))
     return FD.tick.rec.dealcodets;
  else
     return FD.tick.rec.dealcode;
  end;
End;

Private Macro GetFinName(Fin)
       If(fin.definition =="")
          return Fin.Name;
       else
          return fin.definition;
       end;
end;

Private Macro User_GetLsin(fiid)
record avoir("avoiriss");
ПолучитьФинИн(fiid, null, avoir); 
   If(avoir.Lsin != "")
      return avoir.Lsin;
   else
      return avoir.Isin;
   end;
End;

MACRO КУ_СчетПараметризованПоБумаге( CatCode:STRING ):BOOL
   VAR DS,
       cmd = RSDCommand( "SELECT 1 AS Result FROM dmccateg_dbt  WHERE  t_LevelType = 1 AND t_code = ? AND bitand(power(2, 0), t_AttrMask)  > 0 /*MCCATEG_ATTRMASK_FIID*/" ); 

   cmd.addParam( "", RSDBP_IN, CatCode );
   cmd.execute();

   DS = TRsbDataSet( cmd );
   return (DS.MoveNext() AND (DS.Result == 1) )
END;

/* Определить, что сделка ПФИ*/
MACRO SP_DealAsResultDVExe( tick )
   return (tick.rec.IsPFI == SET_CHAR);
end;

MACRO SP_GetAvoirissPlanDate( dl_leg, UseCalendarDays:BOOL ):DATE
  VAR PlanDate;

  if( dl_leg.MaturityIsPrincipal )
     PlanDate = dl_leg.Maturity;
  else
     PlanDate = dl_leg.Expiry;
  end;

  return PlanDate;
END;

/*получить плановую дату оплаты ц/б*/
MACRO SP_GetPayPlanDate( dl_leg, UseCalendarDays:BOOL ):DATE
   VAR PlanDate;

   if( dl_leg.MaturityIsPrincipal )
      PlanDate = dl_leg.Expiry;
   else
      PlanDate = dl_leg.Maturity;
   end;         

  return PlanDate;
END;

PRIVATE MACRO IsCatCodeCach( CatCode:string ):bool
  var RetVal:bool = false;

  if( (CatCode == "-КВ, др") or
      (CatCode == "Реализация, ц/б") or
      (CatCode == "ВнебалСчетКорресп") or
      (CatCode == "Наш портфель ц/б") or
      (CatCode == "ДС, Расч. с клиентом, ВУ") or
      (CatCode == "ЦБ, Расч. с клиентом, ВУ") or
      (CatCode == "ДС, Прч. счета банка, ВУ") or
      (CatCode == "ЦБ, Прч. счета банка, ВУ") or
      (CatCode == "ДС Клиента, ВУ") or
      (CatCode == "ЦБ Клиента, ВУ") or
      (CatCode == "ДС Банка, ВУ") or
      (CatCode == "ЦБ Банка, ВУ") or
      (CatCode == "-Бюджет, ф.налоги") or
      (CatCode == "+Бюджет, ф.налоги") or
      (CatCode == "+РасчетыКомисс1") or
      (CatCode == "+Биржа") or
      (CatCode == "-Биржа") /*or
      (CatCode == "+КВ, ц/б") PNV 535666*/
    )
     RetVal = true;
  end;

  return RetVal;
END;

PRIVATE MACRO GetCatCurrency(FD, CatCode:string)
  var query, cmd, DataSet;
  var Currency = -1;

  query =   " select t_CurType "
          + "   from dmccateg_dbt "
          + "  where t_LevelType = 1 "
          + "    and t_Code = ? ";
  cmd = DL_RSDCommand(query);

  cmd.AddParam(CatCode);

  DataSet = cmd.Execute();

  if(DataSet.moveNext())
    if(DataSet.CurType == 0) //MC_CURTYPE_NATCUR
      Currency = NATCUR;
    elif(DataSet.CurType == 1) //MC_CURTYPE_FININSTR
      Currency = FD.GetParametr(MC_TYPE_PARAMETR_FIID);
    elif(DataSet.CurType == 2) //MC_CURTYPE_NOMINAL
      Currency = FD.GetParametr(MC_TYPE_PARAMETR_CURRENCY);
    elif(DataSet.CurType == 3) //MC_CURTYPE_PAYMENT
      Currency = FD.GetParametr(MC_TYPE_PARAMETR_PAYCURRENCY);
    end;
  end;

  return Currency;
END;

PRIVATE MACRO AddCachAcc(FD, CatCode:string, Currency:integer, FIRole:integer, AccBuf, McAccBuf )

  if( IsCatCodeCach( CatCode ) )

     var Acc   = TRecHandler("account.dbt");
     var McAcc = TRecHandler("mcaccdoc.dbt");
     var MarketID       = FD.GetParametr(MC_TYPE_PARAMETR_MARKET_PLACE);
     var MarketOfficeID = FD.GetParametr(MC_TYPE_PARAMETR_MARKET_PLACE_OFFICE); 
     var ClientID       = FD.GetParametr(MC_TYPE_PARAMETR_CLIENT);
     var ClientContrID  = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_CLIENT);
     var _Currency      = Currency;
     
     if(Currency == NULL) 
       _Currency = GetCatCurrency(FD, CatCode);
     end;

     copy(Acc,   AccBuf);
     copy(McAcc, McAccBuf);

     if( Acc.rec.AccountID > 0 ) // Иначе потом все равно не найдем счет. Возможно надо хранить в tmp параметры счета, а не его ID.
        var exec = RSDCommand( " insert into dsccachacc_tmp ( t_CatCode, t_Currency, t_FIRole, t_AccID, t_McAccID, t_MarketID, t_MarketOfficeID, t_ClientID, t_ClientContrID ) " +
                               "                     values ( ?, ?, ?, ?, ?, ?, ?, ?, ? ) "
                             );

        exec.addParam("", RSDBP_IN, CatCode);
        exec.addParam("", RSDBP_IN, _Currency);
        exec.addParam("", RSDBP_IN, IIF(FIRole == NULL, -1, FIRole));
        exec.addParam("", RSDBP_IN, Acc.rec.AccountID);
        exec.addParam("", RSDBP_IN, McAcc.rec.ID);
        exec.addParam("", RSDBP_IN, MarketID);
        exec.addParam("", RSDBP_IN, MarketOfficeID);
        exec.addParam("", RSDBP_IN, ClientID);
        exec.addParam("", RSDBP_IN, ClientContrID);

        exec.execute();
     end;
  end;

OnError(ErObj)
   MsgBox("Ошибка вставки записи при кэшировании счетов");
END;

PRIVATE MACRO GetCachAcc(FD, CatCode:string, Currency:integer, FIRole:integer, AccBuf, McAccBuf ):bool

  var RetVal:bool = false;

  if( IsCatCodeCach( CatCode ) )
     var Query = "", Data;
     var MarketID       = FD.GetParametr(MC_TYPE_PARAMETR_MARKET_PLACE);
     var MarketOfficeID = FD.GetParametr(MC_TYPE_PARAMETR_MARKET_PLACE_OFFICE);
     var ClientID       = FD.GetParametr(MC_TYPE_PARAMETR_CLIENT);
     var ClientContrID  = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_CLIENT);
     var _Currency      = Currency;
     
     if(Currency == NULL) 
       _Currency = GetCatCurrency(FD, CatCode);
     end;

     Query = RSDCommand( " select t_AccID " +
                         "   from dsccachacc_tmp " +
                         "  where t_CatCode  = ? " +
                         "    and t_Currency = ? " +
                         "    and t_FIRole   = ? " + 
                         "    and t_MarketID = ? " +
                         "    and t_MarketOfficeID = ? " +
                         "    and t_ClientID = ? " +
                         "    and t_ClientContrID = ? "
                       );

     Query.addParam("", RSDBP_IN, CatCode);
     Query.addParam("", RSDBP_IN, _Currency);
     Query.addParam("", RSDBP_IN, IIF(FIRole == NULL, -1, FIRole));
     Query.addParam("", RSDBP_IN, IIF(MarketID == NULL, -1, MarketID));
     Query.addParam("", RSDBP_IN, IIF(MarketOfficeID == NULL, 0, MarketOfficeID));
     Query.addParam("", RSDBP_IN, IIF(ClientID == NULL, -1, ClientID));
     Query.addParam("", RSDBP_IN, IIF(ClientContrID == NULL, 0, ClientContrID));

     Query.execute();

     Data = TRsbDataSet(Query);
     if( Data.MoveNext() )
        if( (AccBuf != NULL) and (Data.AccID > 0) )
           var SqlAcc = RSDCommand( " select * " +
                                    "   from daccount_dbt " +
                                    "  where t_AccountID = ? "
                                  );
           SqlAcc.addParam("", RSDBP_IN, Data.AccID);
           SqlAcc.execute();
           var DataSqlAcc = TRsbDataSet(SqlAcc);
           if( DataSqlAcc.MoveNext() )
              if( ValType(AccBuf) == V_GENOBJ )
                 DataSqlAcc.GetRecord().CopyTo(AccBuf.rec);
              else
                 var Acc = TRecHandler("account.dbt");
                 DataSqlAcc.GetRecord().CopyTo(Acc.rec);
                 copy(AccBuf, Acc);
              end;
           end;
        end;

        if( (McAccBuf != NULL) and (Data.McAccID > 0) )
           var SqlMcAcc = RSDCommand( " select * " +
                                      "   from dmcaccdoc_dbt " +
                                      "  where t_ID = ? "
                                    );
           SqlMcAcc.addParam("", RSDBP_IN, Data.McAccID);
           SqlMcAcc.execute();
           var DataSqlMcAcc = TRsbDataSet(SqlMcAcc);
           if( DataSqlMcAcc.MoveNext() )
              if( ValType(McAccBuf) == V_GENOBJ )
                 DataSqlMcAcc.GetRecord().CopyTo(McAccBuf.rec);
              else
                 var McAcc = TRecHandler("mcaccdoc.dbt");
                 DataSqlMcAcc.GetRecord().CopyTo(McAcc.rec);
                 copy(McAccBuf, McAcc);
              end;
           end;
        end;

        RetVal = true;
     end;
  end;

  return RetVal;
END;

PRIVATE VAR ScUseCachingAccounts:bool = false; // глобализм использовать кэширование счетов

MACRO GL_ScUseCachingAccounts( UseCachingAccounts:bool )
  ScUseCachingAccounts = UseCachingAccounts;

  if( ScUseCachingAccounts )
     SQL_Truncate("dsccachacc_tmp");
  end;
END;

/*GAA: 499082 Определения ДБО клиента по ДО*/
macro getMainContr_acc(subContrid)
  PRIVATE VAR MainContr_acc = TRecHandler("sfcontr.dbt");

  var sqlQuery = RSDCommand(" SELECT *                                                                " +
                            "   FROM dsfcontr_dbt                                                     " +
                            "  WHERE t_id = (SELECT t_sfcontrid                                       " +
                            "                  FROM ddlcontr_dbt                                      " +
                            "                 WHERE t_dlcontrid = (SELECT t_dlcontrid                 " +
                            "                                        FROM ddlcontrmp_dbt              " +
                            "                                       WHERE t_sfcontrid = :subcontrid)) ");

  sqlQuery.addParam("", RSDBP_IN, subContrid);
  sqlQuery.execute();

  var sqlData = TRsbDataSet(sqlQuery);

  if(sqlData.movenext)
      sqlData.getRecord.CopyTo(MainContr_acc.rec);
      setParm(1, MainContr_acc);

      return true;
  end;

  return false;
end;

/*GAA: 501667 получить структуту ДО (субдоговора) по ID */
macro getMainSubContr_acc(subContrid)
  PRIVATE VAR MainSubContr_acc = TRecHandler("sfcontr.dbt");

  var sqlQuery = RSDCommand(" SELECT *                                                                " +
                            "   FROM dsfcontr_dbt                                                     " +
                            "  WHERE t_id = :subcontrid                                               ");

  sqlQuery.addParam("", RSDBP_IN, subContrid);
  sqlQuery.execute();

  var sqlData = TRsbDataSet(sqlQuery);

  if(sqlData.movenext)
      sqlData.getRecord.CopyTo(MainSubContr_acc.rec);
      setParm(1, MainSubContr_acc);

      return true;
  end;

  return false;
end;

/*********************************************************************************/
/* базовый класс - первичные документы для работы с категориями учета            */ 
/*********************************************************************************/
CLASS SPFirst( )

    private var 
       v_KindPortf:INTEGER,   /* тип портфеля   */
       ParmA        = TArray(), /* массив значений параметров 
                                   Доступ только через GetParametr*/
       FIRoleBArray = TArray(); /* массив базисных ролей ФИ */

    private var 
      v_Bal304:bool,      /* б/счет в схеме расчетов с биржей 304 */
      v_Bal302:bool;      /* б/счет в схеме расчетов с биржей 302 */

    private var 
      v_CatCode:string;   /*код категории учета (используется для определения эмитента по "Наш портфель ц/б")*/

    private var v_FIIDCorAcc:integer;/*FIID корреспондирующего счета со cчетом <СчКорреспГлаваГ>*/

    var
       Error = 0,       /* Номер ошибки. Используется для анализа ошибок в ф-ях категорий*/
       Kind  = 0,       /* вид первичного документа*/
       ID    = 0;       /* ID первичного документа*/

    var /*эти свойства инициализируются в наследниках, только если они нужны*/ 
       KindReserv,  /* Вид резерва*/
       Quoted,      /* котируемость ценной бумаги */
       isOverValue, /* признак операции пеероценки */
       IsBack, /*true - выполняется обратная часть сделки*/   
       tick,        /* буфер сделки */
       BeforeProlong = false,
       v_DealTypeName = "";
    
    private var 
      ValMinus = NULL,
      ValPlus = NULL;

    MACRO SetParmForCateg24828(Categ:string, value)
      var c = SubStr(Categ, 1, 1);
      if (c == "+")
        ValPlus = value;
      end;

      if (c == "-")
        ValMinus = value;
      end;
    END;

    MACRO GetParmForCateg24828(Categ:string)
      var value = NULL;
      var c = SubStr(Categ, 1, 1);
      if (c == "+")
        value = ValPlus;
      end;

      if (c == "-")
        value = ValMinus;
      end;

      return value;
    END;

    MACRO ResetParmForCateg24828()
      ValMinus = NULL;
      ValPlus = NULL;
    END;

    macro KindPortf()
       return v_KindPortf;
    end;

    macro IsTrust()
       return false;
    end;

    MACRO GetParametr( ParmKind:INTEGER )
       return ParmA[ParmKind];
    END;

    MACRO SetParametr( Index:INTEGER, Val:VARIANT )
       ParmA[Index] = Val;
    END;

    /*инициализация массива ролей ФИ, в классах наследниках может переопределяться*/
    MACRO InitFIRoleBArray()
       FIRoleBArray[0] = FIROLE_BA; /*базовый актив*/   
    END;

    /*Получить параметры шаблона                    */
    MACRO GetParametrTemplate
    ( 
        ObjectID,       /*   параметр - номер справочника                 */
        Classificator,  /*   классификатор - номер классификатора, если он задан */
        OperDate,       /*   дата, на которую надо вернуть характеристики*/
        FIRole
    )
       if ((this.kind == DL_RETIREMENT) and ((v_CatCode == "+ПереоценкаА") or (v_CatCode == "-ПереоценкаА")))
          if (Classificator == LLCLASS_FI_KIND)
             return 1;     // Вид финансового инструмента - денежные средства
          elif (Classificator == LLCLASS_SYMBOLNUMBERS)
             return 0;     // Знаков символа формы 102 - не задано
          elif (Classificator == LLCLASS_CODE_FI)
             return 0;     // Код финансового инструмента - все
          elif (Classificator == 5065)
             return 2;     // Класс переоценки - прочие счета
          end;
       end;
       
       return MC_GetParametrTemplate( this, ObjectID, Classificator, OperDate, FIRole );
    END;

    MACRO IsSetAccExcludeResCalc( categ, templ )
       var PortfolioID = -1;
       var Bpp = -1;

       if( (categ.rec.Code == "Наш портфель ПКУ, ц/б") or
           (categ.rec.Code == "Ц/б, БПП") or
           (categ.rec.Code == "Ц/б, Корзина БПП") or
           (categ.rec.Code == "Ц/б, ПКУ БПП") or
           (categ.rec.Code == "Ц/б, Корзина ПКУ БПП") or
           (categ.rec.Code == "Ц/б, ПВО_БПП") or
           (categ.rec.Code == "Ц/б, ПВО_БПП, Корзина") or
           (categ.rec.Code == "Начисл.ПДД, ц/б") or
           (categ.rec.Code == "+Форвард, расчеты") or
           (categ.rec.Code == "-Форвард, расчеты") or
           (categ.rec.Code == "-Кредит, неисп.") or
           (categ.rec.Code == "Треб. с н.с.") or
           (categ.rec.Code == "Треб. с н.с., корзина") or
           (categ.rec.Code == "+% к погашению" ) or
           (categ.rec.Code == "+ОД" ) or
           (categ.rec.Code == "-ОД" ) or
           (categ.rec.Code == "+% с н.с.")
         )
         return true;
       end;

       if( categ.rec.Code == "Наш портфель ц/б" )
          PortfolioID = MC_GetValueFromTempl(categ,templ,LLCLASS_KINDPORT);
          if( (PortfolioID == KINDPORT_SALE) or (PortfolioID == KINDPORT_RETIRE) or (PortfolioID == KINDPORT_PROMISSORY) )
             return true;
          end;

          Bpp = MC_GetValueFromTempl(categ,templ,LLCLASS_IS_AVOIR_BPP);
          if(Bpp == 1)
            return true;
          end;
       end;

       return false;
    END;

    /*Макрос корректировки открываемого счета. Account, accblnc, ORScheme можно менять*/
    MACRO CorrectAccount(account, accblnc, ORScheme, categ, templ, accdoc,  OperDate)
      var NameKA, fiid, dtterm, term;
      Record FinInstr(fininstr);
      Record Avoiris(Avoiriss);
      record party(party);
      record partyContr(party);
      record partyClient(party);
      Var PartyContrShName = "";
      Var PartyClientShName ;
      var clientName = "", subKindContr = "";//GAA: 501667
      private macro ShortDate(dat)
         var d,m,y;
         DateSplit(dat,d,m,y);
         return string(d:2:o)+"/"+string(m:2:o)+"/"+string(SubStr(string(y),3):2:o);
      end;
      /*ставим признак овердрафта на счета открываеммые по указанным категориям*/
//      SCR 202900
//      if( (categ.rec.Code == "+Форвард, расчеты") OR ((categ.rec.Code == "-Форвард, расчеты")) )
//         if( Index(account.rec.Type_Account,"О") == 0 ) 
//            account.rec.Type_Account = account.rec.Type_Account + "О";
//         end;
//      elif( (categ.rec.Code == "+За ц/б") OR ((categ.rec.Code == "-За ц/б")) )
//         if( (Index(account.rec.Type_Account,"О") == 0) AND (Index(account.rec.Kind_Account,"АП") == 0) ) 
//            account.rec.Type_Account = account.rec.Type_Account + "О";
//         end;
//      /*  98120
//      elif( categ.rec.Code == "Ц/б клиентов депонента" ) /*ТЗ к SCR 24347*/
//         if( Index(account.rec.Type_Account,"О") == 0 ) 
//            account.rec.Type_Account = account.rec.Type_Account + "О";
//         end;  */
//      end;

      if ( ValType(this.tick) != V_UNDEF )    // вызов идет из шагов сделки
         fiid = this.tick.rec.pfi;
         ПолучитьСубъекта(this.tick.rec.partyid, partyContr);
         PartyContrShName = partyContr.shortName;
         If(IsBasket(this.Group))
            fiid = accdoc.rec.fiid;
         end;

      ELIF (this.kind == 5) 
         FIID = this.ID;
      else                                    // вызов идет из с/о
         fiid = accdoc.rec.fiid;
      end; 
      private var MainContr_acc = TRecHandler("sfcontr.dbt");  /*GAA:499082*/
      private var MainSubContr_acc  = TRecHandler("sfcontr.dbt");//GAA: 501667

      ПолучитьФинИн(fiid, FinInstr);
       ПолучитьСубъекта(FinInstr.issuer, party);

 PartyClientShName = "";
 if ( ValType(this.tick) != V_UNDEF )
       ПолучитьСубъекта(this.tick.rec.clientid, partyClient);
       PartyClientShName = partyClient.shortName;
 else 
      ПолучитьСубъекта(accdoc.rec.owner, partyClient);
      PartyClientShName = partyClient.shortName;
 end;

      if( categ.rec.Code == "Наш портфель ц/б")
         account.rec.nameaccount = "Счет вложений для Цб " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ЦБУчет");
      elif( categ.rec.Code == "Начисл.ПДД, ц/б")
         If(templ.rec.value4 == "1") /*купон*/
            If(templ.rec.value3 == "1") /*БПП*/
               account.rec.nameaccount = "Счет начисленного купона по ценной бумаге " + 
                    GetFinName(fininstr) + ", переданных без прекращения признания, гос. рег.№" + User_GetLsin(fiid);
               addnoteforobject(4, "010000000" + account.rec.account, 112, "ПКДН");
            else
            account.rec.nameaccount = "Начисленный купон. Цб " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
            addnoteforobject(4, "010000000" + account.rec.account, 112, "ПКДН");
            end;
         elif(templ.rec.value4 == "2") /*дисконт*/
            If(templ.rec.value3 == "1") /*БПП*/
               account.rec.nameaccount = "Счет начисленного дисконта по цб " + /*GAA:521289*/
                    GetFinName(fininstr) + ", переданных без прекращения признания, гос. рег.№" + User_GetLsin(fiid);
               addnoteforobject(4, "010000000" + account.rec.account, 112, "ДискН");
         else
            account.rec.nameaccount = "Начисленный дисконт. Цб " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
            addnoteforobject(4, "010000000" + account.rec.account, 112, "ДискН");
         end;
         end;
      elif( categ.rec.Code == "Уплаченный НКД")           
         account.rec.nameaccount = "Счет УНКД для Цб " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ПКДУ");
      elif( categ.rec.Code == "Премия, ц/б") 
         account.rec.nameaccount = "Счет учета премии для ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ПремЦБ");
      elif( categ.rec.Code == "+Переоценка, ц/б ССПУ_ЦБ") 
         account.rec.nameaccount = "Переоценка - положительные разницы для цб " + GetFinName(fininstr) + " (эмитент " +party.ShortName +  ")" + ", гос. рег.№ " + User_GetLsin(fiid);/*GAA:521289*/
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ЦБПере");
      elif( categ.rec.Code == "+Переоценка, ц/б СССД_ЦБ") 
         account.rec.nameaccount = "Переоценка - положительные разницы для цб " + GetFinName(fininstr) + " (эмитент " +party.ShortName +  ")" + ", гос. рег.№ " + User_GetLsin(fiid);/*GAA:521289*/
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ЦБПере");
      elif( categ.rec.Code == "Реализация, ц/б") 
         account.rec.nameaccount = "Выбытие (реализация) для ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
      elif( categ.rec.Code == "Затраты, Репо") 
         account.rec.nameaccount = "Затраты по сделке по ФО и ФА. Сделка " + UserGetDealCode(this) + " от " + ShortDate(this.tick.rec.dealdate) + ". ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid) + ". Контрагент " + PartyContrShName; /*GAA:521289*/
      elif( categ.rec.Code == "РасРасх, Репо") 
         account.rec.nameaccount = "Расчеты по расходам по сделке репо № " + UserGetDealCode(this) + " от " + ShortDate(this.tick.rec.dealdate) + ". ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid) + ". Контрагент " + PartyContrShName;
      elif( categ.rec.Code == "+ОД") 
         account.rec.nameaccount = "Прочие размещенные средства по сделке № " + UserGetDealCode(this) + " от " + ShortDate(this.tick.rec.dealdate) + ". ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid) + ". Контрагент " + PartyContrShName;
      elif( categ.rec.Code == "-ОД")
           If( (IsRepo(this.Group)) and (this.isback == false) and (IsBUY(this.Group)) ) 
              account.rec.nameaccount = "Обязательства по обратной поставке ценных бумаг по сделке РЕПО № " + UserGetDealCode(this) + " от " + ShortDate(this.tick.rec.dealdate) + ". ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid) + ". Контрагент " + PartyContrShName;
           else
         account.rec.nameaccount = "Денежные средства, полученные по сделке РЕПО № " + UserGetDealCode(this) + " от " + ShortDate(this.tick.rec.dealdate) + ". ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid) + ". Контрагент " + PartyContrShName;
           end
      elif( categ.rec.Code == "-Переоценка, ц/б ССПУ_ЦБ") 
         account.rec.nameaccount = "Переоценка - отрицательные разницы для цб " + GetFinName(fininstr) + " (эмитент " +party.ShortName +  ")" + ", гос. рег.№ " + User_GetLsin(fiid); /*GAA:521289*/
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ЦБПере");
      elif( categ.rec.Code == "-Переоценка, ц/б СССД_ЦБ") 
         account.rec.nameaccount = "Переоценка - отрицательные разницы для цб " + GetFinName(fininstr) + " (эмитент " +party.ShortName +  ")" + ", гос. рег.№ " + User_GetLsin(fiid); /*GAA:521289*/
         addnoteforobject(4, "010000000" + account.rec.account, 112, "ЦБПере");
      elif ( categ.rec.Code == "Ц/б, БПП")
         account.rec.nameaccount = "Счет вложений для цб " + GetFinName(fininstr) + /*GAA:521289*/
                  ", переданных без прекращения признания по сделке " + UserGetDealCode(this) + 
                  " от " + ShortDate(this.tick.rec.dealdate) + ", "+User_GetLsin(fiid);
      elif ( categ.rec.Code == "Ц/б, Корзина БПП")
         account.rec.nameaccount = "Счет вложений для цб " + GetFinName(fininstr) + /*GAA:521289*/
                  ", переданных без прекращения признания по сделке РЕПО с корзиной " + UserGetDealCode(this) + 
                  " от " + ShortDate(this.tick.rec.dealdate) + ", "+User_GetLsin(fiid);

      elif ( categ.rec.Code == "Уплаченный НКД, БПП")
         account.rec.nameaccount = "Счет УНКД для цб " + GetFinName(fininstr) + /*GAA:521289*/
                  ", переданных без прекращения признания по сделке " + UserGetDealCode(this) + 
                  " от " + ShortDate(this.tick.rec.dealdate) + ", "+User_GetLsin(fiid);

      elif ( categ.rec.Code == "Уплач. НКД, Корзина БПП")
         account.rec.nameaccount = "Счет УНКД для цб " + GetFinName(fininstr) + /*GAA:521289*/
                  ", переданных без прекращения признания по сделке Репо с корзиной " + UserGetDealCode(this) + 
                  " от " + ShortDate(this.tick.rec.dealdate) + ", "+User_GetLsin(fiid);

      elif ( categ.rec.Code == "-% к погашению")
         account.rec.nameaccount = "Обязательства по процентам по сделке РЕПО №" + UserGetDealCode(this) + ", ЦБ" + GetFinName(fininstr) + ", контрагент " + PartyContrShName;
      elif ( categ.rec.Code == "+% к погашению")
         account.rec.nameaccount = "Требования по процентам по сделке РЕПО №" + UserGetDealCode(this) + ", ЦБ" + GetFinName(fininstr) + ", контрагент " + PartyContrShName;
      elif ( categ.rec.Code == "Ц/б, ПВО")
         account.rec.nameaccount = 
                  GetFinName(fininstr) + ", полученные по операциям, совершаемым на возвратной основе, по сделке № " + UserGetDealCode(this) + " от "+ShortDate(this.tick.rec.dealdate) + 
                  ". Контрагент - "+PartyContrShName;
      elif ( categ.rec.Code == "+Форвард, прочие")
          If(templ.rec.value2 == "1") //ДС
                account.rec.nameaccount = 
                   "Требования по поставке денежных средств/не ПФИ " + " c " + PartyContrShName;
          elif(templ.rec.value2 == "3") //ДС
                account.rec.nameaccount = 
                   "Требования по поставке цб/не ПФИ " + " c " + PartyContrShName;/*GAA:521289*/
          end;
      elif ( categ.rec.Code == "-Форвард, прочие")
          If(templ.rec.value2 == "1") //ДС
                account.rec.nameaccount = 
                   "Обязательства по поставке денежных средств/не ПФИ " + " c " + PartyContrShName;
          elif(templ.rec.value2 == "3") //ДС
                account.rec.nameaccount = 
                   "Обязательства по поставке цб/не ПФИ " + " c " + PartyContrShName;/*GAA:521289*/
          end;
      elif ( categ.rec.Code == "+РасчетыПогаш")

                account.rec.nameaccount = 
                   "Требования по погашению купона цб " + GetFinName(fininstr) + " к " + party.ShortName;/*GAA:521289*/
      elif ( categ.rec.Code == "+РасчетыПогОР")
                account.rec.nameaccount = 
                   "Требования по погашению купона цб эмитента " + party.ShortName + " по сделкам Обратного репо";/*GAA:521289*/

      elif ( categ.rec.Code == "-РасчетыПогОР")
                account.rec.nameaccount = 
                   "Обязательства по возврату дохода от погашения купона ценных  бумаг эмитента " + party.ShortName + " по сделкам Обратного репо";

      elif (( categ.rec.Code == "+Кор_Резерв, ЦБ") or ( categ.rec.Code == "-Кор_Резерв, ЦБ"))
                account.rec.nameaccount = 
                   "Корректировка резервов на возможные потери по ЦБ " + GetFinName(fininstr);

      elif ( categ.rec.Code == "+МаржаП, ц/б")
                account.rec.nameaccount = 
                   "Доходы от переоценки приобретенных ценных бумаг, оцениваемых по справедливой стоимости через прибыль или убыток по ЦБ " + GetFinName(fininstr);

      elif ( categ.rec.Code == "-МаржаП, ц/б")
                account.rec.nameaccount = 
                   "Расходы от переоценки приобретенных цб, оцениваемых по справедливой стоимости через прибыль или убыток по ЦБ " + GetFinName(fininstr);/*GAA:521289*/
      elif ( categ.rec.Code == "Предв.затраты, ц/б")
                account.rec.nameaccount = 
                   "Предварительные затраты на приобретение и реализацию по ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);

      elif ( categ.rec.Code == "-РасчетыПогаш")
                account.rec.nameaccount = 
                   "Обязательства по возврату купонного дохода по ЦБ " + GetFinName(fininstr) + ", гос. рег.№ " + User_GetLsin(fiid);
      /*Chesnokov D.S. 20.02.2019 Правим наименования счетов*/
      elif (( categ.rec.Code == "+ПО ДК") or ( categ.rec.Code == "+ПО ДК 2014"))
               account.rec.nameaccount = "Положительная переоценка цб, оцениваемых по справедливой стоимости через прочий совокупный доход, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr);/*GAA:521289*/
      elif (( categ.rec.Code == "-ПО ДК") or ( categ.rec.Code == "-ПО ДК 2014"))
               account.rec.nameaccount = "Отрицательная переоценка цб, оцениваемых по справедливой стоимости через прочий совокупный доход, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr); /*GAA:521289*/
      elif ( categ.rec.Code == "Оценочный резерв, СССД_ЦБ")
               /*16.06.2020 RAS 510727*/
               //account.rec.nameaccount = "Оценочный резерв по ценным бумагам, оцениваемым по СССД, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr);
               account.rec.nameaccount = "Резервы по цб, оцениваемым по СССД, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr);/*GAA:521289*/
               /*~RAS*/
      elif (( categ.rec.Code == "-Кор_Резерв, ЦБ") or ( categ.rec.Code == "+Кор_Резерв, ЦБ"))
               account.rec.nameaccount = "Корректировка резервов на возможные потери, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr); 
      elif (( categ.rec.Code == "-Форвард, расчеты") or ( categ.rec.Code == "+Форвард, расчеты"))
               account.rec.nameaccount = "Расчеты с " + PartyContrShName + " " + GetFinName(fininstr);
               var err_txt = "";
               var OperForAccount = GetOperForAccount(@err_txt);
               if (OperForAccount == 0)
                  RunError(err_txt);
               else 
                  if(account.rec.oper != OperForAccount)
                     account.rec.oper = OperForAccount;
                  end;
               end;
      elif ( categ.rec.Code == "+Корректировка, ц/б")
               account.rec.nameaccount = "Корректировки, увеличивающие стоимость долговых цб, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr); /*GAA:521289*/
      elif ( categ.rec.Code == "-Корректировка, ц/б")
               account.rec.nameaccount = "Корректировки, уменьшающие стоимость долговых цб, гос. рег.№" + User_GetLsin(fiid) + ", " + GetFinName(fininstr); /*GAA:521289*/
      elif ( categ.rec.Code == "Ц/б, ПВО_БПП")         
               account.rec.nameaccount = GetFinName(fininstr) + ", переданные по операциям, совершаемым на возвратной основе, №" + UserGetDealCode(this) + " от "+ShortDate(this.tick.rec.dealdate) + " c " + PartyContrShName;
      elif ( categ.rec.Code == "ОЭБ%, к погашению")
               account.rec.nameaccount = "Обязательства Банка по выплате купона по собственным облигациям " + fininstr.name;  
      elif ( categ.rec.Code == "Размещ. ОЭБ")
               account.rec.nameaccount = "Собственные облигации банка, обл. " + fininstr.name;  
      elif ( categ.rec.Code == "Размещ., суборд.ОЭБ")
               account.rec.nameaccount = "Собственные субординированные облигации банка, облиг. "+fininstr.name+", гос.рег.№ "+User_GetLsin(fiid);
      elif ( categ.rec.Code == "ЗпоСд, ОЭБ")
               account.rec.nameaccount = "Затраты по сделке по финансовым обязательствам и финансовым активам (ЗпоСд, ОЭБ) обл, " + fininstr.name;
      elif ( categ.rec.Code == "РасРасх, ОЭБ")
               account.rec.nameaccount = "Расчеты по расходам по операциям с выпущенными облигациями обл, " + fininstr.name;    
      /*Chesnokov D.S. закончили правки*/         
/*GAA: 520283*/
      elif ( categ.rec.Code == "Обяз%, ОЭБ")
               account.rec.nameaccount = "Обязательства по процентам и купонам по выпущенным цб (Обяз%, ОЭБ), " + fininstr.name + ", "+ User_GetLsin(fiid); /*GAA:521289, new: цб, old: ценным бумагам*/
      elif ( categ.rec.Code == "Обяз%, ОЭБ (доп. доход)")
               account.rec.nameaccount = "Обязательства по процентам и купонам по выпущенным цб (Обяз%, ОЭБ (доп. доход)), " + fininstr.name + ", "+ User_GetLsin(fiid); /*GAA:521289, new: цб, old: ценным бумагам*/
/*GAA*/

      elif( (categ.rec.Code == "-ПФИ ОЭБ") or (categ.rec.Code == "+ПФИ ОЭБ") ) // Golovkin 25.12.2020 ID : 520711
               account.rec.nameaccount = account.rec.nameaccount + ", " + fininstr.name + ", " + User_GetLsin(fiid);

      /*03.12.2019 RAS id: 499989 Исправление наименований счетов*/
      elif ( categ.rec.Code == "-Корр, ОЭБ" )
                account.rec.nameaccount = "Корректировки, увеличивающие стоимость выпущенных (-Корр, ОЭБ) обл, " + fininstr.name;
      elif ( categ.rec.Code == "+Корр, ОЭБ" )
                account.rec.nameaccount = "Корректировки, уменьшающие стоимость выпущенных (+Корр, ОЭБ) обл, " + fininstr.name;
      elif ( categ.rec.Code == "-КОР_Резерв, ОД2" )
                account.rec.nameaccount = "Корректировка резервов на возможные потери (-КОР_Резерв, ОД2) по ЦБ " + fininstr.name;
      elif ( categ.rec.Code == "-Переоценка, ц/б" )
                account.rec.nameaccount = "Переоценка - отрицательные разницы для ценной бумаги " + GetFinName(fininstr) + " (эмитент " +party.ShortName +  ")" + ", гос. рег.№ " + User_GetLsin(fiid);
      elif ( categ.rec.Code == "+Переоценка, ц/б" )
                account.rec.nameaccount = "Переоценка - положительные разницы для ценной бумаги " + GetFinName(fininstr) + " (эмитент " +party.ShortName +  ")" + ", гос. рег.№ " + User_GetLsin(fiid);
      elif( categ.rec.Code == "Премия, ОЭБ") 
                account.rec.nameaccount = "Счет учета премии для ЦБ " + fininstr.name + " (Премия, ОЭБ), гос. рег.№ " + User_GetLsin(fiid); //GAA:525623, old: 
                //account.rec.nameaccount = "Счет учета премии для ЦБ " + fininstr.name + " (Премия, ОЭБ)";
      elif( categ.rec.Code == "Премия, суборд.ОЭБ") 
                account.rec.nameaccount = "Счет учета премии, облиг. " + fininstr.name + ", гос.рег.№ " + User_GetLsin(fiid);  
      elif( categ.rec.Code == "Дисконт, ОЭБ") 
                account.rec.nameaccount = "Начисленный дисконт. Цб " + fininstr.name + " (Дисконт, ОЭБ), гос. рег.№ " + User_GetLsin(fiid); //GAA:525623, old: 
                //account.rec.nameaccount = "Начисленный дисконт. Цб " + fininstr.name + " (Дисконт, ОЭБ)";
      elif( categ.rec.Code == "Дисконт, суборд.ОЭБ") 
                account.rec.nameaccount = "Начисленный дисконт, облиг. " + fininstr.name + ", гос. рег.№ " + User_GetLsin(fiid);  
      elif ( categ.rec.Code == "ОЭБ, к исполнению" )
                account.rec.nameaccount = "Выпущенные к исполнению облигации обл, " + fininstr.name + " (ОЭБ, к исполнению)";
      elif ( categ.rec.Code == "ОЭБ%, к исполнению" )
                account.rec.nameaccount = "Обязательства по процентам и купонам по облигациям к исполнению обл, " + fininstr.name + " (ОЭБ%, к исполнению)";
      elif((categ.rec.Code == "+Изм.кап., суборд.ОЭБ") or (categ.rec.Code == "-Изм.кап., суборд.ОЭБ"))
                account.rec.nameaccount = "Изменение в капитале по %% расходам по облиг. " + fininstr.name + ", гос.рег.№ "+ User_GetLsin(fiid);
      /*RAS id: 499989 конец*/
      /*GAA:525623, в названии счета должна быть инфрмация о наименовании ц/б и номере госю регистрации*/
      elif( categ.rec.Code == "Выкуп, ОЭБ") 
           account.rec.nameaccount = account.rec.nameaccount + ", " + fininstr.name + ", гос. рег.№ " + User_GetLsin(fiid); 
      elif((categ.rec.Code == "ОЭБ купон, к погашению") or (categ.rec.Code == "ОЭБ купон, к исполнению"))
                account.rec.nameaccount = "Обязательства Банка по выплате купона №" + this.tick.rec.Number_Coupon + " по собственным облигациям " + fininstr.name + ", "+ User_GetLsin(fiid);
      /*GAA:525623*/
/*GAA: 499082  изменения в наименованиях счетов ВУ: 
по клиенту ООО "РСХБ Управления Активами" вместо сокр. наим-я вставлять наизвание ДБО, а если название ДБО = "", то сокр. наим-е */
     elif (partyClient.partyid == 114800)
         /*25.11.19 RAS:499989 переместил проверку для корректного формирования названия счетов*/
         /*GAA:499082 Определим ДБО клиента по ДО*/
         if ( ValType(this.tick) != V_UNDEF )    // вызов идет из шагов сделки
           if(not getMainContr_acc(this.tick.rec.clientcontrid, MainContr_acc))  end;
         else
           if(not getMainContr_acc(accdoc.rec.clientcontrid, MainContr_acc)) end;
         end;
         if (categ.rec.Code == "ДС, Расч. с клиентом, ВУ")
            if (MainContr_acc.rec.name != "") 
                 account.rec.nameaccount = MainContr_acc.rec.name + " (ДС-3 Клиента, ВУ)";
            else 
                 account.rec.nameaccount = PartyClientShName + " (ДС-3 Клиента, ВУ)";
            end;
         elif  (categ.rec.Code == "ДС Клиента, ВУ")
            if (MainContr_acc.rec.name != "")
                 account.rec.nameaccount = MainContr_acc.rec.name + " (ДС-3 Технический счет, ВУ)";
            else
                 account.rec.nameaccount = PartyClientShName + " (ДС-3 Технический счет, ВУ)";
            end;
         elif (categ.rec.Code == "ЦБ Клиента, ВУ")
            if (MainContr_acc.rec.name != "")
                 account.rec.nameaccount = MainContr_acc.rec.name + " (ЦБ-3 Места хранения ЦБ клиентов, ВУ)";
            else
                 account.rec.nameaccount = PartyClientShName + " (ЦБ-3 Места хранения ЦБ клиентов, ВУ)";
            end;
         elif (categ.rec.Code == "ЦБ, Расч. с клиентом, ВУ")
            if (MainContr_acc.rec.name != "")
                 account.rec.nameaccount = MainContr_acc.rec.name + " (ЦБ-3 Клиента, ВУ)";
            else
                 account.rec.nameaccount = PartyClientShName + " (ЦБ-3 Клиента, ВУ)";
            end;         
         elif (categ.rec.Code == "ФО Клиента, ВУ")
            if (MainContr_acc.rec.name != "")
                 account.rec.nameaccount = MainContr_acc.rec.name + " (ЦБ-3 ФО Клиента, ВУ)";
            else
                 account.rec.nameaccount = PartyClientShName + " (ЦБ-3 ФО Клиента, ВУ)";
            end;
         elif (categ.rec.Code == "ФО, Расч. с клиентом, ВУ")
            if (MainContr_acc.rec.name != "")
                 account.rec.nameaccount = MainContr_acc.rec.name + " (ЦБ-3 ФО, Расч. с клиентом, ВУ)";
            else
                 account.rec.nameaccount = PartyClientShName + " (ЦБ-3 ФО, Расч. с клиентом, ВУ)";
            end;
         end;  
    /*GAA: 496117 изменения в наименованиях счетов ВУ */
      elif ( (categ.rec.Code == "ДС, Расч. с клиентом, ВУ") and (PartyClientShName != "") )
               account.rec.nameaccount = PartyClientShName + " (ДС-3 Клиента, ВУ)";
      elif ( (categ.rec.Code == "ДС Клиента, ВУ") and (PartyClientShName != "") )
               account.rec.nameaccount = PartyClientShName + " (ДС-3 Технический счет, ВУ)";
      elif ( (categ.rec.Code == "ЦБ Клиента, ВУ") and (PartyClientShName != "") )
               account.rec.nameaccount = PartyClientShName + " (ЦБ-3 Места хранения ЦБ клиентов, ВУ)";
      elif ( (categ.rec.Code == "ЦБ, Расч. с клиентом, ВУ") and (PartyClientShName != "") )
               account.rec.nameaccount = PartyClientShName + " (ЦБ-3 Клиента, ВУ)";
      elif ( (categ.rec.Code == "ФО Клиента, ВУ") and (PartyClientShName != "") )
               account.rec.nameaccount = PartyClientShName + " (ЦБ-3 ФО Клиента, ВУ)";
      elif ( (categ.rec.Code == "ФО, Расч. с клиентом, ВУ") and (PartyClientShName != "") )
               account.rec.nameaccount = PartyClientShName + " (ЦБ-3 ФО, Расч. с клиентом, ВУ)";     
/*GAA: 501667*/
    elif ( categ.rec.Code == "+РасчетыКомисс1")
         /*Определим ДБО клиента по ДО*/
       if ( ValType(this.tick) != V_UNDEF )    // вызов идет из шагов сделки
         if(not getMainContr_acc(this.tick.rec.clientcontrid, MainContr_acc))  end;
         if(not getMainSubContr_acc(this.tick.rec.clientcontrid, MainSubContr_acc))  end;
       else
         if(not getMainContr_acc(accdoc.rec.clientcontrid, MainContr_acc)) end;
         if(not getMainSubContr_acc(accdoc.rec.clientcontrid, MainSubContr_acc)) end;
       end;

      if(partyClient.legalform == 2)
          clientName = Падеж(partyClient.shortname,3);
      else
          clientName = partyClient.shortname;
      end;

      if(MainSubContr_acc.rec.servkind == 1)
          if(MainSubContr_acc.rec.servkindsub == 9) 
              subKindContr = "внебиржевом рынке";
          else
              subKindContr = "биржевом рынке";
          end;
      elif(MainSubContr_acc.rec.servkind == 15)
          subKindContr = "срочном рынке";
      end;

      //Требования к <клиент> по уплате комиссий по дог. № <ДБО> от <дата ДБО> по операциям на <биржевом/внебиржевом/срочном> рынке
      account.rec.nameaccount = "Требования к "+clientName+" по уплате комиссий по дог. № "+MainContr_acc.rec.number+" от "+MainContr_acc.rec.datebegin+" по операциям на "+subKindContr;


    elif ((categ.rec.Code == "+ПФИ") or (categ.rec.code == "-ПФИ"))
      Account.rec.NameAccount = UserGetDealCode(this) + " ПФИ сделка от " +ShortDate(this.tick.rec.dealdate) + " c " + PartyContrShName;

    elif ( categ.rec.Code == "+Форвард, дрейф")
        If(templ.rec.value3 == "1") //ДС
              account.rec.nameaccount = 
                 "Требования по поставке денежных средств/ПФИ. Сделка № " + UserGetDealCode(this) + " от "+ShortDate(this.tick.rec.dealdate) + " c " + PartyContrShName;
        elif(templ.rec.value3 == "3") //ЦБ
              account.rec.nameaccount = 
                 "Требования по поставке ценных бумаг/ПФИ. Сделка № " + UserGetDealCode(this) + " от "+ShortDate(this.tick.rec.dealdate) + " c " + PartyContrShName;
        end;
    elif ( categ.rec.Code == "-Форвард, дрейф")
        If(templ.rec.value3 == "1") //ДС
              account.rec.nameaccount = 
                 "Обязательства по поставке денежных средств/ПФИ. Сделка № " + UserGetDealCode(this) + " от "+ShortDate(this.tick.rec.dealdate) + " c " + PartyContrShName;
        elif(templ.rec.value3 == "3") //ЦБ
              account.rec.nameaccount = 
                 "Обязательства по поставке ценных бумаг/ПФИ. Сделка № " + UserGetDealCode(this) + " от "+ShortDate(this.tick.rec.dealdate) + " c " + PartyContrShName;
        end;

    elif ( categ.rec.Code == "Резерв ц/б")
        If(templ.rec.value1 == "4") //по вложениям
              account.rec.nameaccount = 
                 "Резервы по ценным бумагам, оцениваемым по СССД, гос. рег." + User_GetLsin(fiid)  + ", " + GetFinName(fininstr);  /*PDV518930 */   
          elif(templ.rec.value1 == "13") //по ПДД
		 account.rec.nameaccount = 
                 "Резервы по ценным бумагам, оцениваемым по СССД, гос. рег." + User_GetLsin(fiid) + ", " + GetFinName(fininstr);    /*PDV518930 */       
            end;
      end;
/**/

      if(  (categ.rec.Code == "Наш портфель ц/б")
        or (categ.rec.Code == "Ц/б, БПП")
        or (categ.rec.Code == "Ц/б, Корзина БПП")
        or (categ.rec.Code == "Наш портфель ПКУ, ц/б")
        or (categ.rec.Code == "Ц/б, ПКУ БПП")
        or (categ.rec.Code == "Ц/б, Корзина ПКУ БПП")
        )
         var OptionValue = УЧЕТ_ВАЛЮТНЫХ_ДОЛЕВЫХ_ЦБ();

         if( (OptionValue == 1) and ( Index(account.rec.Type_Account,"Н") == 0 ) ) 
            FIID = this.GetParametr(MC_TYPE_PARAMETR_FIID);
            var fin = TBFile("fininstr.dbt");

            if(FIID > 0)
              fin.Clear();
              fin.rec.FIID = FIID;
              if((fin.GetEQ()) and (fin.rec.FI_Kind == FIKIND_AVOIRISS) and (not FI_IsBond(fin.rec.FIID) ))
            account.rec.Type_Account = account.rec.Type_Account + "Н";
         end; 
      end;
         end; 
      end;
      
      var CatErr = 0;
      /*При открытии л/с автоматически устанавливается категория <Исключить из расчета резервов>*/
      if( IsSetAccExcludeResCalc(categ, templ) == true )
         if( not ConnectObjAttr( CatErr, OBJTYPE_ACCOUNT, UniID(account, OBJTYPE_ACCOUNT), OBJ_ACCOUNT_GROUP_EXCLUDE_RES_CALC, null,"", "1"/*Да*/, OperDate )  OR
             ( CatErr != 0 )
           )
            MsgBox( "Ошибка при установке категории \"Исключить из расчета резервов по вложениям в ц/б в бэк-офисе\" для счета \""+account.rec.Account+"\".|"  + GetErrMsg() );
            return false;
         end;
      end;
      
      if( ((categ.rec.Code == "+ОД" ) or (categ.rec.Code == "-ОД" )) and IsRepo(this.Group))
        var FIRole = this.GetBasisFIRole( );
        var Contragent = this.GetParametr( MC_TYPE_PARAMETR_PARTY, OperDate, null, FIRole );
        Var КатегКонтрОД = this.GetParametrTemplate( OBJTYPE_KINDSUBJ, LLCLASS_KINDSUBJ_KONTRMM, OperDate, FIRole );
        if((КатегКонтрОД == 2) or (КатегКонтрОД == 3))
          var CatVal = 74; //Сделка РЕПО

          if(ВидСубъекта( Contragent, PTK_CENTRALCONTR )) //принадлежность "центральный контрагент"
             CatVal = 239; //РЕПО ч/з ЦК
          end;

          if( not ConnectObjAttr( CatErr, OBJTYPE_ACCOUNT, UniID(account, OBJTYPE_ACCOUNT), 1/*Категория для отчетности*/, CatVal, null, null, OperDate )  OR
              ( CatErr != 0 )
            )
              MsgBox( "Ошибка при установке категории \"Категория для отчетности\\Для формы 501\" для счета \""+account.rec.Account+"\".|"  + GetErrMsg() );
              return false;
          end;
        end;
      end;
/*DAN.Ролевая модель. Устанавлеваем конечного операциониста для счета в сооьветствии с ролевой моделью*/
   var retvalGetMO;

   if ( ValType(this.tick) != V_UNDEF )    // вызов идет из шагов сделки
       retvalGetMO = GetMainOperInGroup(this.tick.rec.bofficeKind);
   elif (this.kind == 5) 
       retvalGetMO = GetMainOperInGroup(this.Kind);
   else                                    // вызов идет из с/о
       retvalGetMO = account.rec.oper;
   end; 

   if (retvalGetMO > 0)
     account.rec.oper = retvalGetMO;
   end;

/*DAN*/
     
      return true;
    END;

    /*Установить ошибку. 
      Если IsCriticalError=true или не задан, то прервать выполнение макроса*/
    MACRO SetError( StrError, IsCriticalError )  

       this.Error = 1;
       if( IsCriticalError == null )
         IsCriticalError = true;
       end;

       if( IsCriticalError )
          if(StrError == "")
             RunError( ".|Ошибка при создании класса "+GenClassName(this) );
          else
             RunError( StrError );
          end;
       else
          MsgBox( StrError ); 
       end;

    OnError( RslErrObj )
       msgbox( RslErrObj.Message + ".|"+ StrError ); 
       RunError();
    END;

    PRIVATE MACRO CorrectParameters( store:bool ):bool
       return false;
    END;

    MACRO GetCurrentCatCode()
      return v_CatCode;
    END;

    /* Получить счет по категории учета
       Вернет false, если ошибка или отказ от ввода счета.
       ! если не установлен NoErrMes выдаст сообщение об ошибке
    */
    PRIVATE MACRO GetAccountByCatCode
    ( 
        CatCode:string     ,  /* код категории */
        FindAccount:string ,  /* здесь вернется номер счета */
        /*необязательные параметры*/
        AccCreate:Integer,     /* признак верификации\открытия лицевого счета       */
        NoErrMes:bool,      /* признак молчаливого выполнения - ошибку не выдаем */
        FIRole:Variant,        /* роль ФИ или массив ролей*/
        AccBuf:Variant,        /* буфер для возврата информации по найденному\открытому счету   */
        PairAcc:Integer,       /* с учетом парности */
        ActionDate:Date,    /* дата */
        FIID:Integer,          /*валюта*/
        Accounts:Variant,      /*массив номеров счетов, соответствующий массиву ролей */  
        RealOpenMode:Integer,  /*фактический режим открытия*/
        McAccDocBuf:Variant,   /* буфер для возврата данных по счету mcaccdoc.dbt */
        ActivateDate:Variant,   /*Дата актуализации счета (может быть не задана)*/
        NumberForAcc:string    /*номер существующего счета, который нужно привязать к документу*/
    )
       var i = 0, loop = true, open_acc = true, _FIRole = null, IsMass;

       var ID_Operation, ID_Step;

       if( this.Error != 0 ) return false; end;

       if( ((NoErrMes == null) OR (NoErrMes == false)) AND 
           (not isOprMultiExec()) 
         )
          IsMass = 0;
       else /*либо массовый режим, либо принудительно просим не орать ошибки*/
          IsMass = 1;
       end;

       if ( (IsMass == 1) and isOprMultiExec() )
          var Query =   " SELECT oprtemp.t_ID_Operation, oprtemp.t_ID_Step, oprtemp.t_Dockind, koper.t_Systypes, oper.t_Dockind as t_operDocKind "
                        + "   FROM doprtemp_view oprtemp, doproper_dbt oper, doprkoper_dbt koper "
                        + "   WHERE oprtemp.t_ID_Operation =  oper.T_ID_Operation "
                        + "   AND oper.T_Kind_Operation = koper.T_Kind_Operation ";    
          var cmd = DL_RSDCommand(Query); 
          var DataSet = cmd.Execute();
          if( DataSet.moveNext() )
            if (SQL_ConvTypeInteger(DataSet.operDocKind) == DL_AVRWRT)
               ID_Operation = DataSet.ID_Operation;
               ID_Step      = DataSet.ID_Step;
            end;
         end;
      end;

       if( ValType(AccCreate) == V_UNDEF )
          AccCreate = MC_OPENACC_CREATE;
       end;

       v_CatCode = CatCode;

       while( loop ) /*цикл нужен для перебора ролей, если задан массив ролей*/

          if( (FIRole != null) AND (ValType( FIRole ) == V_GENOBJ) ) /*массив ролей*/  

             if(FIRole[i] != null)            
               loop     = true;                    
               open_acc = true;
               _FIRole  = FIRole[i];
             else
               loop     = false;                    
               open_acc = false;
               _FIRole  = null;
             end;
             i = i + 1;    

          else
             loop       = false; /*перебор не нужен, только одна роль задана*/
             open_acc   = true;
             _FIRole    = FIRole;
          end;
      
          if( open_acc )                    

             if( (not ScUseCachingAccounts) or
                 (not GetCachAcc(this, CatCode, FIID, _FIRole, AccBuf, McAccDocBuf))
               )
                CorrectParameters(true);

                if( AccCreate != 4 )
                   FindAccount = MC_FindAndOpenAccountEx( CatCode,
                                                          this,
                                                          ActionDate,
                                                          IsMass,
                                                          AccCreate,
                                                          AccBuf, FIID, null, PairAcc, NumberForAcc, _FIRole, RealOpenMode, McAccDocBuf, null, ActivateDate, null, ID_Operation, ID_Step 
                                                        );

                   if( ScUseCachingAccounts )
                      AddCachAcc(this, CatCode, FIID, _FIRole, AccBuf, McAccDocBuf);
                   end;
                else
                   FindAccount = MC_GetAccountNumber( CatCode,
                                                      this,
                                                      ActionDate,
                                                      IsMass, FIID, _FIRole
                                                    );
                end;

                CorrectParameters(false);

                if( FindAccount != "" )
                   if( (Accounts != null) AND (ValType( Accounts ) == V_GENOBJ) ) /*массив счетов*/
                      Accounts[i-1] = FindAccount;
                   end;
                end;
             else
                if( ValType(AccBuf) == V_GENOBJ )
                   FindAccount = AccBuf.rec.Account;
                else
                   FindAccount = AccBuf.Account;
                end;
             end;
          end;
       end;

       v_CatCode = "";

       SetParm( 2, FindAccount );
       if( FindAccount=="" )
          if( IsMass == 0 )
             MsgBox("Счет категории \"" + CatCode + "\" неопределен или недоступен в данной операции");
          end;  
          return false;
       end;

       return true;
    END;

    /*актуализация счета (без открытия)*/  
    MACRO ActualAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, ActionDate, FIID, Accounts, PairAcc )
       var ret, acnt;
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_ACT, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts  );
       setparm( 2, acnt ); 
       return ret;
    END;  

    /*Актуализация с проверкой срочности*/  
    MACRO ActualCheckPeriod( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, ActionDate, FIID, Accounts, McAccDoc, ActivateDate )
       var ret, acnt;                                          
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_CHECKPERIOD, NoErrMes, FIRole, AccBuf, null, ActionDate, FIID, Accounts, null, McAccDoc, ActivateDate );
       setparm( 2, acnt ); 
       return ret;
    END;  

    /*открытие и актуализация счета*/  
    MACRO OpenAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, ActionDate, FIID, Accounts, McAccDoc, PairAcc, NumberForAcc )
       var ret, acnt;      
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_CREATE, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts, null, McAccDoc, null, NumberForAcc );
       setparm( 2, acnt ); 
       return ret;
    END;  

    /*переоткрытие и актуализация счета - если счет нашли, его все равно пересоздать*/  
    MACRO ReOpenAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, ActionDate, FIID, Accounts, PairAcc )
       var ret, acnt;      
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_RECREATE, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
       setparm( 2, acnt ); 
       return ret;
    END;

    /*аннулирование счета по категории*/
    MACRO CloseAccount( CatCode, CloseDate, FIRole, CurryCurrency, NoErrMes )
       var ret;
       ret = MC_FindAndCloseAccount( CatCode, this, CloseDate, FIRole, CurryCurrency ); 
       if( (ret != 0) AND ((NoErrMes == null) OR (NoErrMes == false)) )
          msgbox( "Ошибка при аннулировании счета по категории ", CatCode );
       end;
       if( ret != 0 )
          return false; 
       else
          return true; 
       end;      
    end;

    /*проверка на существование счета*/  
    MACRO IsExistAccount( CatCode, FindAccount, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
       var ret, acnt;      
       ret = GetAccountByCatCode( CatCode, acnt, MC_OPENACC_CHECKEXIST, NoErrMes, FIRole, AccBuf, PairAcc, ActionDate, FIID, Accounts );
       setparm( 2, acnt ); 
       return ret;
    END;  

    /*получить - найти или сформировать номер счета (без открытия)*/  
    MACRO FindNumberAccount( CatCode, FindAccount, NoErrMes, FIRole, FIID, Accounts );
       var ret, acnt;      
       ret = GetAccountByCatCode( CatCode, acnt, 4, NoErrMes, FIRole, null, null, null, FIID, Accounts );
       setparm( 2, acnt ); 
       return ret;
    END;  

    /* получение группы списания по свойствам объекта*/
    MACRO GetPortofolio( DateGet, FIRole )
        return this.GetParametrTemplate( OBJTYPE_KINDPORT, LLCLASS_KINDPORT, DateGet, FIRole );
    END;

    /*получение кол-ва бумаг в портфеле */
    MACRO GetAmountInPortofolio( DateGet, Rest, SayError, FIRole, LotMode, BalanceCost, _ProcessSale ) 
/*       var FIID, wrtcalc, wrofgrp;
       var ProcessSale = true;

       if( _ProcessSale != null )
          ProcessSale = _ProcessSale;
       end;      

       wrofgrp = TRecHandler( "pmwrtgrp.dbt" ); 
       wrofgrp.Clear();

       if( this.GetPortofolio( wrofgrp, FIID, SayError, FIRole, null, DateGet ) == true )

          if( LotMode == null ) 
             LotMode = PM_WRTOFF_CALC_FORMANDLARGER;
          end;

          wrtcalc = TRecHandler( "pmwrtsum.dbt" ); 
          wrtcalc.Clear();
          if( WRT_Calc( LotMode, wrofgrp, FIID, DateGet, GetBuyGoal( this, FIID, FIRole ), ProcessSale, wrtcalc ) == true )
             SetParm( 2, wrtcalc.rec.Amount );
             SetParm( 6, wrtcalc.rec.BalanceCost );
             return true;   
          end;
       end;
*/
       return false;
    END;

    /* вернуть режим списания для портфеля */
    MACRO GetModeWriteOff( SayError, FIRole, FindContractorGrp )
       return "X";           
    END;

    MACRO GetMethodWriteOff( FindContractorMethod )

       var cmd;
       var q, PartyID, ContrID;

       if (FindContractorMethod)
          PartyID = this.tick.rec.PartyID;
          ContrID = this.tick.rec.PartyContrID;
       else
          PartyID = this.tick.rec.ClientID;
          if (this.tick.rec.ClientID > 0)
             ContrID = this.tick.rec.ClientContrID;
          else
             ContrID = 0;
          end;
       end;

       cmd=RSDCommand( " select NVL(t_MethodID, -1) met from dpmwrtmet_dbt " +
                       "  where t_Party = ? and t_Contract = ?  ");

       cmd.addParam("", RSDBP_IN, PartyID);
       cmd.addParam("", RSDBP_IN, ContrID);
       cmd.execute();

       q = TRsbDataSet(cmd);
       if( q.movenext() )
           return q.met;
       end;

       return -1;           
    END;

    macro Is304()
       if( v_Bal304 == NULL) 
          if( SQL_GetNRecs( "select * from ddlmarket_dbt where t_ID = " + string(this.GetMarketSchemeID()) + " and t_Balance = '304'"  ) > 0 )
             v_Bal304 = true;
          else
             v_Bal304 = false;
          end;
       end;
       return v_Bal304;
    end;

    macro Is302()
       if( v_Bal302 == NULL) 
          if( SQL_GetNRecs( "select * from ddlmarket_dbt where t_ID = " + string(this.GetMarketSchemeID()) + " and t_Balance = '302'"  ) > 0 )
             v_Bal302 = true;
          else
             v_Bal302 = false;
          end;
       end;
       return v_Bal302;
    end;

    MACRO РКЦ()
      VAR PartyID_RCC = -1; /*РКЦ (субъект {MFO_RCC}) */ 
      PartyID_RCC  = ПолучитьКодСубъекта( {MFO_RCC}, PTCK_BIC ); 

      if( PartyID_RCC <= 0 )
         MsgBox( "Не найден РКЦ для " + {MFO_Bank} );
      end;

      return PartyID_RCC;
    END;

    MACRO РКЦБанкИзСПИ(PayFIID, PartyKind:@INTEGER)
      var Select,DataSettacc,
          RunFromBOCB = GetIdentProgram(),
          ServiceKind = PTSK_ALL;

      if(PayFIID == NATCUR)
         /*РКЦ банка из параметров банка*/ 
         PartyKind = 41/*PTK_RKC*/;
         return this.РКЦ();
      else/*банк из СПИ нашего банка в валюте оплаты платежа*/

         if(RunFromBOCB == CodeFor("S"))
            ServiceKind = PTSK_STOCKDL;
         elif(RunFromBOCB == CodeFor("Ю"))
            ServiceKind = PTSK_DV;
         elif(RunFromBOCB == CodeFor("А"))
            ServiceKind = 17;
         end;

         Select=RSDCommand( " select settacc.t_BankID, settacc.t_BankID from dsettacc_dbt settacc " +
                            "  where settacc.t_SettAccID = NVL((select pmautoac.t_SettAccID " +
                                                               " from dpmautoac_dbt pmautoac " +
                                                              " where pmautoac.t_PartyID = ? " +
                                                                " and pmautoac.t_FIID = ? " +
                                                                " and pmautoac.t_ServiceKind = ? " +
                                                                " and ROWNUM = 1),0)" );

         Select.addParam( "", RSDBP_IN, {OurBank} );
         Select.addParam( "", RSDBP_IN, PayFIID );
         Select.addParam( "", RSDBP_IN, ServiceKind );
         Select.execute();

         DataSettacc = TRsbDataSet(Select);

         if ( DataSettacc.MoveNext() )
            PartyKind = PTK_BANK;
            return DataSettacc.BankID;
         else
            MsgBox( "Не найден банк из СПИ нашего банка в валюте " + ПолучитьКодФинИн(PayFIID) + " оплаты платежа" );
         end;
      end;

      return -1;
    end;

    MACRO GetMarketSchemeID():INTEGER
       return -1;
    END;

    macro ВУ_ПолучитьРО( ВидРО )
       /* 4401 - по деньгам 44
          4402 - ценным бумагам 44 */
       /* 4301 - по деньгам 44
          4302 - ценным бумагам 44 */
       if( ВидРО == 4301 )
          return 44;
       elif( ВидРО == 4401 )
          return 43;
       elif( (ВидРО == 4302) OR (ВидРО == 8202) )
          return 82;
       elif( (ВидРО == 4402) OR (ВидРО == 8302) )
          return 83;
       elif( ВидРО == 80001)
          return 8;
       elif(ВидРО == 10001)
          return 10;
       elif(ВидРО == 11001)
          return 11;
       elif(ВидРО == 55001)
          return 55;
       elif(ВидРО == 20001)
          return 20;
       elif(ВидРО == 21001)
          return 21;
       end;

       return ВидРО;
    end;

    macro ВУ_ПолучитьРольФИ( ВидРО, DebCred )
       return "";
    end;

    macro ВУ_ПолучитьКатегориюДебет( ВидРО )
       return "";
    end;

    macro ВУ_ПолучитьКатегориюКредит( ВидРО )
       return "";
    end;

    macro ВУ_ОснованиеПроводки( ВидРО )
       return "";
    end;

    macro ВУ_СкорректироватьРесчетнуюОперацию( ВидРО, InnAcc:@VARIANT )
      var DealSum = $0, spground, dealcode = "", DealCost = $0; 
       if( this.tick != NULL )
          /*курсовая разница*/
          if( (( (IsBUY(this.Group) or IsSALE(this.Group) or (IsTwoPart(this.Group)) ) 
                  and ( (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 20001) or ( ((ВидРО == 21)or(ВидРО == 21001)) and (this.ExistAvance() or this.ExistDeposit())) or (ВидРО == 4401) or (ВидРО == 25) 
                  or (ВидРО == 40) or (ВидРО == 4301) or (ВидРО == 22) or (ВидРО == 41) ) ) OR
                 /*( this.IsOperLoan and ( (ВидРО == 22) or (ВидРО == 26) ) ) OR*/
                 ( (this.tick.rec.BofficeKind == DL_INVESTSHARE) and ((ВидРО == 19) or (ВидРО == 20) or (ВидРО == 20001)))) AND
               ( (InnAcc.Date != this.DateArray[DATE_DEALDATE] )
                 and (this.GetPayFIID() != this.dl_leg.rec.CFI) )
            )
               if( (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 20001) or (ВидРО == 21) or (ВидРО == 21001))
                  if((ВидРО == 19) or (ВидРО == 20) or (ВидРО == 20001))
                     DealCost = this.dl_leg.rec.TotalCost;
                     if( this.ExistAvance or this.ExistDeposit )
                        DealCost = DealCost - this.pm_avance.rec.BaseAmount;
                     end;
                  else
                     DealCost = this.pm_avance.rec.BaseAmount;
                  end;

                  if( SmartConvertSum( DealSum, DealCost, this.DateArray[DATE_DEALDATE], this.dl_leg.rec.CFI, this.GetPayFIID(), true ) == true )
                     InnAcc.RateSum = DealSum - InnAcc.Sum;
                  end;

               else
                  if( SmartConvertSum( DealCost, InnAcc.Sum, InnAcc.Date, this.GetPayFIID(), this.dl_leg.rec.CFI, true ) == true )
                     if( SmartConvertSum( DealSum, DealCost, this.DateArray[DATE_DEALDATE], this.dl_leg.rec.CFI, this.GetPayFIID(), true ) == true )
                        InnAcc.RateSum = DealSum - InnAcc.Sum;
                     end;
                  end;
               end;
          end;

          if( IsEXCHANGE(this.Group) )
            spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 320/*320 - отчет биржи*/, null, InnAcc.DealKind);
            InnAcc.GroundNum = spground.XLD; 
            InnAcc.GroundKind = 320;
       
          elif( IsBROKER(this.Group) )
            spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 321/*321 - отчет брокера*/, null, InnAcc.DealKind);
            InnAcc.GroundNum = spground.XLD; 
            InnAcc.GroundKind =  321;
          elif( IsOUTEXCHANGE(this.Group) )
             if( (ВидРО >= 1) and (ВидРО < 50) )
                spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 313/* 313 - Платежное поручение */, null, InnAcc.DealKind);
                if( (spground.Kind == 313) and (spground.RegistrDate == InnAcc.Date) )
                   InnAcc.GroundKind   = spground.Kind;
                   InnAcc.GroundNum    = spground.XLD; 
                else
                   spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 314/* 314 - Кассовый ордер */, null, InnAcc.DealKind);
                   if( (spground.Kind == 314) and (spground.RegistrDate == InnAcc.Date) )
                      InnAcc.GroundKind = spground.Kind;
                      InnAcc.GroundNum = spground.XLD; 
                   end;
                end;
             elif( (ВидРО >= 50) and (ВидРО < 90) )
                spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 300/* 300 - Отчет об исполнении поручения депо */, null, InnAcc.DealKind);
                if( (spground.Kind == 300) and (spground.RegistrDate == InnAcc.Date) )
                   InnAcc.GroundKind   = spground.Kind;
                   InnAcc.GroundNum    = spground.XLD; 
                else
                   spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 315/* 315 - Подтверждение перерегистрации */, null, InnAcc.DealKind);
                   if( (spground.Kind == 315) and (spground.RegistrDate == InnAcc.Date) )
                      InnAcc.GroundKind = spground.Kind;
                      InnAcc.GroundNum = spground.XLD; 
                   end;
                end;
             end;
          end;
          dealcode = this.tick.rec.DealCode;
       end;

       if( this.Kind == DL_SETTLEMENT )
          if( this.comm != NULL )

            spground = GetSPGroundRecByDeal( InnAcc.DocumentID, 320/*320 - отчет биржи*/, null, InnAcc.DealKind);
            InnAcc.GroundNum = spground.XLD; 
            InnAcc.GroundKind = 320;

          end;
       end;

       return 0;
    end;

    private VAR ChapterFIID = TArray();
    macro ВУ_ОпределениеГлавы( FIID:INTEGER ):INTEGER
       VAR v_fininstr;

       if( ChapterFIID[FIID] == NULL )
          v_fininstr = Trechandler( "fininstr.dbt" ); /* фин. инструмент           */

          if( ПолучитьФинИн( FIID, v_fininstr ) != 0 ) 
             this.SetError( "Не найден ФИ при определении главы ВУ (FIID = " + FIID + ")", false );
          else
             if( v_fininstr.rec.FI_Kind == FIKIND_CURRENCY )
                ChapterFIID[FIID] = 21;
             else
                ChapterFIID[FIID] = 22;
             end;
          end;
       end;
       return ChapterFIID[FIID];
    end;

    MACRO GetBasisFIRole( FIRole, NoMsgErr )
      var i = 0;

      if( (FIRole == null) OR (FIRole == FIROLE_UNDEF) OR (FIRole == FIROLE_BA) )

         if((this.tick != NULL) AND ((this.tick.rec.BofficeKind == DL_SECUROWN) or (this.tick.rec.BofficeKind == DL_AVRWRTOWN) or (this.tick.rec.BofficeKind == DL_RETIREMENT_OWN)))
            return FIROLE_AJUSTVALOEB;
         elif( (this.tick != NULL) AND (this.tick.rec.BofficeKind == DL_CONVAVR) AND (this.IsBack) )
            return FIROLE_BA_BACK;
         else
            /*это есть у всех классов (значение ФИроли по умолчанию)*/
            return FIROLE_BA;
         end;
      end;

      while (i < FIRoleBArray.Size)
        if (FIRoleBArray[i] == FIRole)
          return FIRole;
        end;
        i = i + 1;
      end;
      
      if( this.tick != null )
         if( (this.IsOperLOAN == true) AND (FIRole == FIROLE_BA_LOAN) )
            return FIROLE_BA;
         end;

         if( (this.ExistBack == true) AND (this.BuySale == DEAL_TYPE_SALE) ) 
            if( FIRole == FIROLE_BA_REPO )  /*Базовый актив в договорах обратной продажи*/
              return FIROLE_BA;
            end;
         end;

         /*продажи\погашения ц/б*/ 
         if( this.BuySale == DEAL_TYPE_SALE ) 
            if( FIRole == FIROLE_FIREQ )  /*ФИ требований*/
               return FIROLE_CA; /*контрактив*/
            elif( FIRole == FIROLE_FICOM )/*ФИ обязательств*/
               return FIROLE_BA; /*базовый актив*/
            elif( FIRole == FIROLE_OVERVALUE_REQ ) /*ФИ переоценки требований*/  
               return FIROLE_CA; /*контрактив*/
            elif( FIRole == FIROLE_OVERVALUE_COM ) /*ФИ переоценки обязательств*/  
               return FIROLE_CALC_BA; /*ФИ учета базового актива*/
            end;
         /*покупки*/
         elif( this.BuySale == DEAL_TYPE_BUY )
            if( FIRole == FIROLE_FIREQ )  /*ФИ обязательств*/
               return FIROLE_BA; /*базовый актив*/
            elif( FIRole == FIROLE_FICOM ) /*ФИ обязательств*/
               return FIROLE_CA; /*контрактив*/
            elif( FIRole == FIROLE_OVERVALUE_REQ ) /*ФИ переоценки требований*/  
               return FIROLE_CALC_BA; /*ФИ учета базового актива*/
            elif( FIRole == FIROLE_OVERVALUE_COM ) /*ФИ переоценки обязательств*/  
               return FIROLE_CA; /*контрактив*/
            end;
         end;
      end;
/*
      if( (NoMsgErr == null) OR (NoMsgErr == false) )      
         this.SetError( "Неверно задана роль ФИ", false );      
      end;
*/
      return FIRole;
    END;

    MACRO GetFIRoleBArray()
       return FIRoleBArray;
    END;

    MACRO ПолучитьЭмитентаСвязОбъектаДР(finin:variant)
       record fin("fininstr.dbt"); 
       var Issuer = -1;

       if( (GetLinkedObject( 10, OBJTYPE_AVOIRISS, UniID( finin, OBJTYPE_AVOIRISS ), OBJTYPE_AVOIRISS, fin) == 0) )
          if( ПолучитьФинИн(fin.FIID, fin, null) == 0 )
             Issuer = fin.Issuer;
          end;
       elif((finin.rec.parentfi > 0) and (ПолучитьФинИн( finin.rec.parentfi, fin ) == 0))
          Issuer = fin.Issuer;
       end;

       return Issuer;
    END;

   macro GetDealType()
     return 0;
   end;

   macro GetBaseFiid()
     return -1;
   end;

   MACRO GetDealTypeName()
     if((ValType(v_DealTypeName) != V_STRING) or (v_DealTypeName == ""))
       var cmd, DataSet;

       cmd = DL_RSDCommand("select t_Name from doprkoper_dbt where t_Kind_Operation = ? ");
       cmd.AddParam(GetDealType());
       DataSet = cmd.Execute();
       if(DataSet.moveNext())
         v_DealTypeName = DataSet.Name;
       end;
     end;

     return v_DealTypeName;
   END;

   macro ПолучитьКалендБиржа()
     return 0;
   end;

   macro ПолучитьКалендВалютуВидаДаты()
     return -1;
   end;
 
   macro ПолучитьКалендКонтрагент()
     return this.GetParametr( MC_TYPE_PARAMETR_PARTY, {curdate}, null, this.GetBasisFIRole( ) );
   end;
 
   macro ПолучитьКалендТип():integer
     var cmd = DL_RSDCommand("select T_OBJTYPE from DDLCALENOPRS_DBT where T_NAME = ? and T_IDENTPROGRAM = 83");
     cmd.AddParam(GetDealTypeName());
     var ds = cmd.Execute();
     if (ds.moveNext())
       return ds.objtype;
     end;
     return -1;
   end;
 
   macro ПолучитьКалендСвязанный(dayType):integer
     var curId;
     var params = makeArray(
         DL_KeyPair("Object",GetDealTypeName()),
         DL_KeyPair("ObjectType",ПолучитьКалендТип()),
         DL_KeyPair("Market",ПолучитьКалендБиржа()),
         DL_KeyPair("MarketPlace",DL_CALLNK_MARKETPLACE_SEC)
         );
     if (ValType(dayType) == V_INTEGER)
       params[params.size] = DL_KeyPair("DayType",dayType);
     end;
     if (ПолучитьКалендТип() == DL_CALLNK_MARKET)
       curId = ПолучитьКалендВалютуВидаДаты();
       if (curId > 0)
         params[params.size] = DL_KeyPair("Currency",curId);
         //значит мы в ТО
         if (ValType(dayType) != V_INTEGER)
           params[params.size] = DL_KeyPair("DayType",DL_CALLNK_MRKTDAY_SETTL);
         end;
       end; 
       var emitCountryId = DL_GetEmitCountryIDFromFiid(this.GetBaseFIID());
       if (emitCountryId > 0)
         params[params.size] = DL_KeyPair("EmitCountry",emitCountryId);
       end;
       var avoirKindId = DL_GetAvoirKindIDFromFiid(this.GetBaseFIID());
       if (avoirKindId > 0)
         params[params.size] = DL_KeyPair("AvoirKind",avoirKindId);
       end;
     end;
     return DL_GetCalendByDynParam(83,params);
   end;

   macro GetCatCode()
      return v_CatCode;
   end;

END;

macro GetPrevPlanDateRQ( RQ_buf ):date
  var RetVal:date = RQ_buf.rec.PlanDate;
  var query, cmd, DataSet;

  query = " select bc.t_PlanDate " +
          "   from ddlrqbc_dbt bc " +
          "  where bc.t_RQID = ? " +
          "    and bc.t_PlanDate != ? " +
          "    and bc.t_Instance = (select max(bc_1.t_Instance) " +
          "                           from ddlrqbc_dbt bc_1 " +
          "                          where bc_1.t_RQID = bc.t_RQID " +
          "                            and bc_1.t_PlanDate != ? " +
          "                        ) ";

  cmd = DL_RSDCommand(query);
  cmd.AddParam(RQ_buf.rec.ID);
  cmd.AddParam(RQ_buf.rec.PlanDate);
  cmd.AddParam(RQ_buf.rec.PlanDate);

  DataSet = cmd.Execute();
  if( DataSet.moveNext )
     RetVal = SQL_ConvTypeDate(DataSet.PlanDate);
  end;

  return RetVal;
end;

/*Получить даты для определения срочности счетов ОД в РЕПО*/
MACRO SC_GetDateOD( CatCode:STRING, FD:SPFirst, FD2:SPFirst, BegDate:@DATE, FinDate:@DATE )
  BegDate = FinDate = DATE(0,0,0);

  if( IsBUY(FD.Group) ) /*обратное РЕПО*/
     /* Срочность счетов категорий "+ОД" определяется по сроку от факт даты оплаты (аванса) 1 части до 
        плановой даты оплаты 2 части, а счетов "-ОД" - от факт. даты поставки 1 части до плановой даты 
        поставки 2 части сделки.*/
     if( (CatCode == "+ОД") or (CatCode == "+ОД, Корзина") or (IsBasket(FD.Group) and (not FD.НуженСчетКорзина())) )
        /*от факт даты оплаты (аванса) 1 части*/
        if( FD.ExistAvance )
           BegDate = SP_GetPlanDateRQ( FD.dl_leg.rec, FD.tick.rec, DLRQ_TYPE_AVANCE, FD.Group);
        else
           BegDate = SP_GetPlanDateRQ( FD.dl_leg.rec, FD.tick.rec, DLRQ_TYPE_PAYMENT, FD.Group);
        end;
        /*до плановой даты оплаты 2 части*/
        if( FD2.BeforeProlong )
          if(IsLoan(FD2.Group))           
            FinDate = GetPrevPlanDateRQ(FD2.GetRQ(DLRQ_TYPE_INCREPO));
          else
            FinDate = GetPrevPlanDateRQ(FD2.GetRQ(DLRQ_TYPE_PAYMENT));
          end;
        else
          if(IsLoan(FD2.Group)) 
            FinDate = FD2.GetRQ(DLRQ_TYPE_INCREPO).rec.PlanDate;
          else
            FinDate = FD2.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate;
          end;
        end;
     else
        /*от факт. даты поставки 1 части*/
        BegDate = SP_GetPlanDateRQ( FD.dl_leg.rec, FD.tick.rec, DLRQ_TYPE_DELIVERY, FD.Group);
        /*до плановой даты поставки 2 части*/
        if( FD2.BeforeProlong )
           FinDate = GetPrevPlanDateRQ(FD2.GetRQ(DLRQ_TYPE_DELIVERY));
        else
           FinDate = FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
        end;
     end;
  else /*прямое*/
     /*При открытии счетов категории "+ОД" для определения б/с 2го порядка используется срок от даты 
       поставки по 1 части до даты поставки по 2 части, а для счетов категории "-ОД" - от даты 
       оплаты (аванса) 1 части до даты оплаты 2 части*/
     if( ((CatCode == "+ОД") or (CatCode == "+ОД, Корзина")) and ((not IsBasket(FD.Group)) or FD.НуженСчетКорзина()) )
        /*от даты поставки по 1 части */
        BegDate = SP_GetPlanDateRQ( FD.dl_leg.rec, FD.tick.rec, DLRQ_TYPE_DELIVERY, FD.Group);
        /*до даты поставки по 2 части*/
        if( FD2.BeforeProlong )
           FinDate = GetPrevPlanDateRQ(FD2.GetRQ(DLRQ_TYPE_DELIVERY));
        else
           FinDate = FD2.GetRQ(DLRQ_TYPE_DELIVERY).rec.PlanDate;
        end;
     else
        /*от даты оплаты (аванса) 1 части*/
        if( FD.ExistAvance )
           BegDate = SP_GetPlanDateRQ( FD.dl_leg.rec, FD.tick.rec, DLRQ_TYPE_AVANCE, FD.Group);
        else
           BegDate = SP_GetPlanDateRQ( FD.dl_leg.rec, FD.tick.rec, DLRQ_TYPE_PAYMENT, FD.Group);
        end;
        /*до даты оплаты 2 части*/
        if( FD2.BeforeProlong )
          if(IsLoan(FD2.Group))           
            FinDate = GetPrevPlanDateRQ(FD2.GetRQ(DLRQ_TYPE_INCREPO));
          else
            FinDate = GetPrevPlanDateRQ(FD2.GetRQ(DLRQ_TYPE_PAYMENT));
          end;
        else
          if(IsLoan(FD2.Group)) 
            FinDate = FD2.GetRQ(DLRQ_TYPE_INCREPO).rec.PlanDate;
          else
            FinDate = FD2.GetRQ(DLRQ_TYPE_PAYMENT).rec.PlanDate;
          end;
        end;
     end;
  end;

  /*
  Запрос 141212.
  Нужно для того, чтобы по +ОД и -ОД не открывались счета "до востребования".
  Т.к. шаблоны содержат 2 типа диапазонов групп срочности, то приходится еще раз анализировать тип контрагента.
  */
  if( (CatCode == "+ОД") or (CatCode == "+ОД, Корзина") or (CatCode == "-ОД") or (CatCode == "-ОД, Корзина") )
           if (FinDate == BegDate)
              FinDate = BegDate + 1; /*должны открываться не до востребования, а на один день*/
           end;
  end;

END;

/*Получить дату начала второй части сделки. */
macro ДатаНачалаВторойЧасти( FD_1, FD_2 )
   var DateBegin2;

   if( IsBasket(FD_1.Group) or (FD_1.pm_avoir.rec.PaymStatus != PM_OVERDUE) )
      DateBegin2 = minDate( FD_1.DateArray[DATE_DEALSETAVOIRISS], FD_2.DateArray[DATE_DEALPAY] );
   else
      DateBegin2 = FD_2.DateArray[DATE_DEALPAY];
   end;

   if( FD_2.ExistAvance == true )
      DateBegin2 = minDate( DateBegin2, FD_2.DateArray[DATE_DEALAVANCE] );
   end;
   if( FD_2.ExistDeposit == true )
      DateBegin2 = minDate( DateBegin2, FD_2.DateArray[DATE_DEALDEPOSIT] );
   end;
   return DateBegin2;
end;

/*Дата постановки второй части на внебаланс. */ 
macro ДатаПостановкиНаВнебалансВторойЧасти( FD_1, FD_2 )
   var DateOutbal;

   if( IsClientDeal(FD_2.tick.rec) OR IsEXCHANGE(FD_2.Group) )
      DateOutbal = FD_2.DateArray[DATE_DEALBEGIN_2];
   else
      DateOutbal = FD_2.DateArray[DATE_DEALPAY];
      if( FD_2.ExistAvance == true )
         DateOutbal = minDate( DateOutbal, FD_2.DateArray[DATE_DEALAVANCE] );
      end;
      if( IsBasket(FD_1.Group) or ((FD_1.pm_avoir.rec.PaymStatus != PM_OVERDUE) AND (FD_1.pm_avoir.rec.PaymStatus != PM_PROLONGATED)) )
         DateOutbal = minDate( DateOutbal, FD_1.DateArray[DATE_DEALSETAVOIRISS] );
      end;
   end;
   return DateOutbal;
end;

/* класс-адаптер что бы не переписывать весть старый код, который использует платежи */
CLASS DLRQ_PAYM( rq:TRecHandler, FD, IsCreatingPayms:bool )
  PRIVATE VAR m_rq = TRecHandler("dlrq.dbt"),
              v_m_rqacc = NULL,
              v_m_rqacc_payer = TRecHandler("dlrqacc.dbt"),
              v_m_rqacc_receiver = TRecHandler("dlrqacc.dbt"),
              m_FD = FD;
  private var m_DebetAccount = TRecHandler("account.dbt");
  private var m_CreditAccount = TRecHandler("account.dbt");
  private var m_IsTick = NULL, m_IsNett = NULL, m_IsComm = NULL, m_IsNptx = NULL;
  private var m_PayFIID = NULL, m_BaseAmount = NULL, m_PaymStatus = NULL, m_Purpose = NULL, m_SubPurpose = NULL;
  private var m_PayerID = NULL, m_PayerINN = NULL, m_PayerCode = NULL, m_PayerName = NULL;
  private var m_IsLoaded = false;
  private var m_IsCreatingPayms:bool = false;

  copy(m_rq, rq);

  MACRO rec()
     return this;
  END;

  MACRO dlreq()
     return m_rq;
  END;

  MACRO IsTick() //Адаптировано для всех сделок
    if(m_IsTick == NULL)
      m_IsTick = IIF(StrUpr( GenClassName( m_FD )) == StrUpr("SPFirstDoc"), 1, 0);
    end;

    return m_IsTick;
  END;

  MACRO IsComm() //!!!Адаптировано только для операций расчетов с биржей
    if(m_IsComm == NULL)
      m_IsComm = IIF(StrUpr( GenClassName( m_FD )) == StrUpr("SPFirstDocDLCOMM"), 1, 0);
    end;
    
    return m_IsComm;
  END;

  MACRO IsNett() //!!!Адаптировано только для неттинга по деньгам
    if(m_IsNett == NULL)
      m_IsNett = IIF(StrUpr( GenClassName( m_FD )) == StrUpr("DL_NettingDoc"), 1, 0);
    end;
    
    return m_IsNett;
  END;

  MACRO IsNptx() //!!!Адаптировано только для операций зачисления/списания ДС
    if(m_IsNptx == NULL)
      m_IsNptx = IIF(StrUpr( GenClassName( m_FD )) == StrUpr("DLFirstDocNPTXOP"), 1, 0);
    end;
    
    return m_IsNptx;
  END;

  MACRO m_rqacc()
    if(v_m_rqacc == NULL)
       v_m_rqacc = TRecHandler("dlrqacc.dbt");
       ПолучитПлатежныеРеквизитыПоТО(m_rq, v_m_rqacc);
    end;

    return v_m_rqacc;
  END;

    //Заполнить счета
  PRIVATE MACRO LoadAccounts()
    var CatCode = "";
    var ОднаПроводка = false;

    if(m_IsLoaded == false)
      m_IsLoaded = true;
      
      if(this.IsTick())
       
        var IsSale = SP_RqIsSale( m_rq, m_FD.tick );

        v_m_rqacc_payer.Clear();
        v_m_rqacc_receiver.Clear();

        m_DebetAccount.Clear();
        m_CreditAccount.Clear();

        if(m_rq.rec.SubKind == DLRQ_SUBKIND_CURRENCY) //ТО по деньгам
           if((m_rq.rec.Type == DLRQ_TYPE_AVANCE) or (m_rq.rec.Type == DLRQ_TYPE_DEPOSIT)) //Аванс или депозит
             ПолучитьСчетаТОПоАвансуЗадатку( m_rq, m_FD, this.ValueDate(), IsSale, m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );
           elif(m_rq.rec.Type == DLRQ_TYPE_INCREPO) //проценты
             ПолучитьСчетаТОПоПроцентам( m_rq, m_FD, this.ValueDate(), IsSale, m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );
           elif(m_rq.rec.Type == DLRQ_TYPE_PAYMENT) //оплата
             if(m_rq.rec.DocKind == DL_RETIREMENT_OWN)
               ПолучитьНашСчетТОПоОплате( m_rq, m_FD, this.ValueDate(), m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );

               ПолучитьСчетКонтрагентаТО(m_rq, m_CreditAccount, v_m_rqacc_payer);
             else
               ПолучитьСчетКонтрагентаПоТООплаты( m_rq, m_FD, this.ValueDate(), m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );

               if(IsClientDeal(m_FD.tick.rec))
                 if(IsSale)
                   ПолучитьДенежныйСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, m_FD.tick.rec.ClientID, m_FD.GetPayFIID(), m_CreditAccount, v_m_rqacc_receiver);
                 else
                   ПолучитьДенежныйСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, m_FD.tick.rec.ClientID, m_FD.GetPayFIID(), m_DebetAccount, v_m_rqacc_payer);
                 end;
               else
                 ПолучитьНашСчетТОПоОплате( m_rq, m_FD, this.ValueDate(), m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );
               end;
             end;
           elif(m_rq.rec.Type == DLRQ_TYPE_COMPPAYM) //Компенсационный платеж
             ПолучитьСчетаКомпенсационногоТО( m_rq, m_FD, m_rq.rec.FactDate, m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );
           elif((m_rq.rec.Type == DLRQ_TYPE_PAYMREPOCOUP) OR (m_rq.rec.Type == DLRQ_TYPE_PAYMREPOPART)) //Учет купона или ЧП
             ПолучитьСчетаТОПоКупонуЧП(m_rq, m_FD, m_rq.rec.FactDate, m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms);
           elif(m_rq.rec.Type == DLRQ_TYPE_COMISS) //Комиссия

             //аналогично, как в sp_carcmacc.mac

             if( IsClientDeal(m_FD.tick.rec) and (this.Receiver() == {OurBank})) // клиентская комиссия банку
               if( ПолучитьСчетСубъектаПоСделке(m_FD.tick.rec.BOfficeKind, m_FD.tick.rec.DealID, this.Payer(), DLRQ_SUBKIND_CURRENCY, m_rq.rec.FIID, m_DebetAccount, v_m_rqacc_payer) != 0)
                  return 1;
               end;

               if( not m_FD.ActualAccount("+КВ, ц/б", null, false, null, m_CreditAccount, this.ValueDate(), m_rq.rec.FIID) )
                 if( not m_FD.OpenAccount("+КВ, ц/б", null, false, null, m_CreditAccount, this.ValueDate(), m_rq.rec.FIID) )
                   return 1;
                 end;
               end;
             elif((m_rq.rec.DocKind == DL_SECUROWN) or (m_rq.rec.DocKind == DL_RETIREMENT_OWN) )
               if( ПолучитьНашСчетТОПоОплатеКомиссии(m_FD, this.ValueDate(), m_DebetAccount, @ОднаПроводка, m_rq, m_IsCreatingPayms) != 0 )
                  msgbox("Ошибка при определении счета ТО по оплате комиссии");
                  return 1;
               end;
               
               if( ПолучитьСчетКонтрагентаПоТООплатыКомиссии( m_rq, m_FD, this.ValueDate(), m_CreditAccount, this.Receiver(), @CatCode, v_m_rqacc_receiver, false, m_IsCreatingPayms) != 0)
                  msgbox("Ошибка при определении счета контрагента по ТО оплаты комиссии");
                  return 1;
               end;
             else

               var Dp = m_FD.DateArray[DATE_DEALSETAVOIRISS];
               var Dk = date(m_rq.rec.PlanDate);

               if( IsClientDeal(m_FD.tick.rec) OR IsTwoPart(m_FD.Group) OR (Dp != Dk) )
                 if( ПолучитьСчетКонтрагентаПоТООплатыКомиссии( m_rq, m_FD, this.ValueDate(), m_CreditAccount, this.Receiver(), @CatCode, v_m_rqacc_receiver, false, m_IsCreatingPayms) != 0)
                    msgbox("Ошибка при определении счета контрагента по ТО оплаты комиссии");
                    return 1;
                 end;

                 if( not IsClientDeal(m_FD.tick.rec) )
                    if( ПолучитьНашСчетТОПоОплатеКомиссии(m_FD, this.ValueDate(), m_DebetAccount, @ОднаПроводка, m_rq, m_IsCreatingPayms) != 0 )
                       msgbox("Ошибка при определении счета ТО по оплате комиссии");
                       return 1;
                    end;                                                                              
                 else     
                    if( ПолучитьСчетСубъектаПоСделке(m_FD.tick.rec.BOfficeKind, m_FD.tick.rec.DealID, this.Payer(), DLRQ_SUBKIND_CURRENCY, m_rq.rec.FIID, m_DebetAccount, v_m_rqacc_payer) != 0)
                       msgbox("Ошибка при получения счета субъекта \"" + ПолучитьКороткоеИмяСубъекта(this.Payer()) + "\" по сделке");
                       return 1;
                    end;
                 end;

               end;

             end;

           elif(m_rq.rec.Type == DLRQ_TYPE_PAYINCOME)
             if(m_rq.rec.DocKind == DL_RETIREMENT_OWN)

               if( not m_FD.ActualAccount("ДС в КО", null, false, null, m_DebetAccount, this.ValueDate(), m_rq.rec.FIID) )
                 if( not m_FD.OpenAccount("ДС в КО", null, false, null, m_DebetAccount, this.ValueDate(), m_rq.rec.FIID) )
                   return 1;
                 end;
               end;

               ПолучитьСчетКонтрагентаТО(m_rq, m_CreditAccount, v_m_rqacc_payer);

             end;
           elif((m_rq.rec.Type == DLRQ_TYPE_TAX_ULN) or (m_rq.rec.Type == DLRQ_TYPE_TAX_FLN) or (m_rq.rec.Type == DLRQ_TYPE_TAX_FLR) or (m_rq.rec.Type == DLRQ_TYPE_TAX_FLR_ADD))
             ПолучитьСчетаТОПоНалогам( m_rq, m_FD, this.ValueDate(), IsSale, m_DebetAccount, m_CreditAccount, v_m_rqacc_payer, v_m_rqacc_receiver, m_IsCreatingPayms );
           end;
        else //по ц/б
          if(m_rq.rec.Type == DLRQ_TYPE_DELIVERY) //поставка
            if(not IsSale)
              ПолучитьСчетКонтрагентаТО(m_rq, m_DebetAccount, v_m_rqacc_payer);
              
              if(IsClientDeal(m_FD.tick.rec))
                  ПолучитьЦБСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, m_FD.tick.rec.ClientID, m_rq.rec.FIID, m_CreditAccount, v_m_rqacc_receiver);
               else
                  ПолучитьЦБСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, {OurBank}, m_rq.rec.FIID, m_CreditAccount, v_m_rqacc_receiver);
               end;
            else
              ПолучитьСчетКонтрагентаТО(m_rq, m_CreditAccount, v_m_rqacc_receiver);

              if(IsClientDeal(m_FD.tick.rec))
                ПолучитьЦБСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, m_FD.tick.rec.ClientID, m_rq.rec.FIID, m_DebetAccount, v_m_rqacc_payer);
              else
                ПолучитьЦБСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, {OurBank}, m_rq.rec.FIID, m_DebetAccount, v_m_rqacc_payer);
              end;
            end;

          end;
        end;

      elif(this.IsNett())
        var Cat = "";

        if(m_rq.rec.Kind == DLRQ_KIND_COMMIT)
          if(m_FD.dl_nett.rec.OverTransitAccount == "X")
            Cat = "+Расчеты";
          else
            Cat = "+Форвард, расчеты";
          end;

          m_FD.GetAccount(Cat, null, MC_OPENACC_CREATE, m_FD.dl_nett.rec.PayFIID, m_rq.rec.PlanDate, m_DebetAccount );

          ПолучитьДенежныйСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, m_rq.rec.Party, m_rq.rec.FIID, m_CreditAccount, v_m_rqacc_receiver);
        end;
      elif(this.IsComm())
        var FiRole;
        
        if(m_rq.rec.Kind == DLRQ_KIND_COMMIT)
          GetSettlFiRoleByOperSubKind(m_FD.comm.rec.OperSubKind,@FiRole);

          m_FD.IsExistAccount( "Торговый счет", null, false, FiRole, m_DebetAccount, null, m_FD.comm.rec.CommDate, m_rq.rec.FIID );

          ПолучитьДенежныйСчетСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, m_FD.comm.rec.PartyID, m_rq.rec.FIID, m_CreditAccount, v_m_rqacc_receiver);
         /*DAN*************************************************/
         //В случае размещения счет дебета определяем по КУ
                   if(m_rq.rec.DocKind == DL_RETIREMENT_OWN)
                       cat = "ДС в КО"; 
                       m_FD.IsExistAccount(cat, null, false, FiRole, m_DebetAccount, null, m_FD.comm.rec.CommDate, m_rq.rec.FIID );
                   end; 
         /*DAN*************************************************/

        end;
      elif(this.IsNptx())
        if( m_FD.nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_ENROL )
        
          ПолучитьПлатежныеРеквизитыСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, this.Payer(), DL_GetRQSubKindbyType(m_rq.rec.Type), this.PayFIID(), m_rq.rec.Type, v_m_rqacc_payer);

          if(v_m_rqacc_payer.rec.CorrAcc != "")
            GetAccount( v_m_rqacc_payer.rec.Chapter, v_m_rqacc_payer.rec.FIID, v_m_rqacc_payer.rec.CorrAcc, m_DebetAccount, false );
          else
            GetAccount( v_m_rqacc_payer.rec.Chapter, v_m_rqacc_payer.rec.FIID, v_m_rqacc_payer.rec.Account, m_DebetAccount, false );
          end;
          if (m_rq.rec.Type == DLRQ_TYPE_RETURN_MONEY)
             ПолучитьПлатежныеРеквизитыСубъектаПоСделке(m_rq.rec.DocKind, m_rq.rec.DocID, this.Payer(), DL_GetRQSubKindbyType(m_rq.rec.Type), this.PayFIID(), DLRQ_TYPE_PAYMENT, v_m_rqacc_receiver);
             m_CreditAccount.rec.Account = v_m_rqacc_receiver.rec.Account;
             m_CreditAccount.rec.Chapter = v_m_rqacc_receiver.rec.Chapter;
          else
          GetAccount( 1, m_FD.nptxop.rec.Currency, m_FD.nptxop.rec.Account, m_CreditAccount, false )
          end;
        else
          // DEF-74558, проще искать по ID счета
          GetRqAcc(m_rq.rec.RqAccID, v_m_rqacc_receiver);

          if(v_m_rqacc_receiver.rec.CorrAcc != "")
            //Simanov. Корсчёт заполняется из СПИ. А там указывается корсчёт, открытый в банке-корреспонденте. Т.е. у нас этого счёта нет.
            if ( (v_m_rqacc_receiver.rec.BankID > 0) and (v_m_rqacc_receiver.rec.BankID != {OurBank}) )
              //Simanov. И приходится вот так забивать, чтобы везде, где это используется, были глава, валюта и счёт
              m_CreditAccount.rec.Code_Currency = v_m_rqacc_receiver.rec.FIID;
              m_CreditAccount.rec.Account = v_m_rqacc_receiver.rec.Account;
              m_CreditAccount.rec.Chapter = v_m_rqacc_receiver.rec.Chapter;
            else
              GetAccount( v_m_rqacc_receiver.rec.Chapter, v_m_rqacc_receiver.rec.FIID, v_m_rqacc_receiver.rec.CorrAcc, m_CreditAccount, false );
            end;
          else
            //Simanov. Ну а в некоторых СПИ просто не заполнен корсчёт, поэтому приходится проверять ещё банк получателя
            if ( (v_m_rqacc_receiver.rec.BankID > 0) and (v_m_rqacc_receiver.rec.BankID != {OurBank}) )
              m_CreditAccount.rec.Code_Currency = v_m_rqacc_receiver.rec.FIID;
              m_CreditAccount.rec.Account = v_m_rqacc_receiver.rec.Account;
              m_CreditAccount.rec.Chapter = v_m_rqacc_receiver.rec.Chapter;
            else
              GetAccount( v_m_rqacc_receiver.rec.Chapter, v_m_rqacc_receiver.rec.FIID, v_m_rqacc_receiver.rec.Account, m_CreditAccount, false );
            end;
          end;

          GetAccount( 1, m_FD.nptxop.rec.Currency, m_FD.nptxop.rec.Account, m_DebetAccount, false );
        end;

      end;
    end;

  END;


  MACRO m_rqacc_payer()
    LoadAccounts();
    return v_m_rqacc_payer;
  END;

  MACRO m_rqacc_receiver()
    LoadAccounts();
    return v_m_rqacc_receiver;
  END;

  MACRO ValueDate():DATE
     if( m_rq.rec.FactDate != DATE(0,0,0) )
        return m_rq.rec.FactDate;
     else
        return m_rq.rec.PlanDate;
     end;
  END;

  MACRO OrderFIID():INTEGER
    return m_rq.rec.FIID;
  END;

  MACRO BaseFIID():INTEGER
     return this.PayFIID;
  END;

  MACRO FIID():INTEGER
     return m_rq.rec.FIID;
  END;

  MACRO PayFIID():INTEGER
    if(m_PayFIID == NULL)
      if(this.IsTick())
        m_PayFIID = m_FD.GetPayFIID();
      elif(this.IsNett())
        m_PayFIID = m_rq.rec.FIID;
      elif(this.IsComm())
        m_PayFIID = m_rq.rec.FIID;
      elif(this.IsNptx())
        m_PayFIID = m_rq.rec.FIID;
      end;
    end;

    return m_PayFIID;
  END;

  MACRO OrderAmount():MONEY
     return m_rq.rec.Amount;
  END;

  MACRO BaseAmount():MONEY
    if(m_BaseAmount == NULL)
      m_BaseAmount = this.OrderAmount();
      if(m_rq.rec.FIID != this.BaseFIID())
        SmartConvertSum( m_BaseAmount, m_rq.rec.Amount, this.ValueDate(), m_rq.rec.FIID, this.BaseFIID(), true );
      end; 
    end;

    return m_BaseAmount;
  END;

  MACRO Amount():MONEY
     return m_rq.rec.Amount;
  END;

  MACRO PayAmount():MONEY
     return m_rq.rec.Amount;
  END;

  MACRO DealStatus():integer
    var DealStatus = 0;

    if(this.IsNett())
      DealStatus = m_FD.dl_nett.rec.Status;
    elif(this.IsTick())
      DealStatus = m_FD.tick.rec.DealStatus;
    elif(this.IsComm())
      if(m_FD.comm.rec.CommStatus == DL_COMM_PREPARING)
        DealStatus = DL_PREPARING;
      elif(m_FD.comm.rec.CommStatus == DL_COMM_READIED)
        DealStatus = DL_READIED;
      elif(m_FD.comm.rec.CommStatus == DL_COMM_CLOSED)
        DealStatus = DL_CLOSED;
      end;
    elif(this.IsNptx())
      if(m_FD.nptxop.rec.Status == DL_TXOP_Prep)
        DealStatus = DL_PREPARING;
      elif(m_FD.nptxop.rec.Status == DL_TXOP_Open)
        DealStatus = DL_READIED;
      elif(m_FD.nptxop.rec.Status == DL_TXOP_Close)
        DealStatus = DL_CLOSED;
      end;
    end;

    return DealStatus;
  END;

  MACRO PaymStatus():INTEGER
     if(m_PaymStatus == NULL)
       m_PaymStatus = -1;
       if( m_rq.rec.State ==  DLRQ_STATE_PLAN )
         if(this.DealStatus() == DL_PREPARING)
           m_PaymStatus = PM_PREPARING;
         else
           m_PaymStatus = PM_READIED;
         end;
       elif( m_rq.rec.State ==  DLRQ_STATE_EXEC )
          m_PaymStatus = PM_FINISHED;
          if((this.PayerBankID() != {OurBank}) or (this.ReceiverBankID() != {OurBank}) or this.IsNptx() ) //Simanov. По операции списания/зачисления выгружаем все платежи
            m_PaymStatus = PM_READY_TO_SEND;
          end;
       elif( m_rq.rec.State ==  DLRQ_STATE_OVERDUE )
          m_PaymStatus = PM_OVERDUE;
       elif( m_rq.rec.State ==  DLRQ_STATE_DELAYED )
          m_PaymStatus = PM_PROLONGATED;
       elif( m_rq.rec.State ==  DLRQ_STATE_GO_PREP )
          m_PaymStatus = PM_PREPARING;
       elif( m_rq.rec.State ==  DLRQ_STATE_GO_CLOSE )
          m_PaymStatus = PM_CLOSED_W_M_MOVEMENT;
       elif( m_rq.rec.State ==  DLRQ_STATE_REJECT )
          m_PaymStatus = PM_CLOSED_W_M_MOVEMENT;
       end;
     end;
                         
     return m_PaymStatus;
  END;

  MACRO Purpose():INTEGER
    
    if(m_Purpose == NULL)
      m_Purpose = 0;

      if(m_rq.rec.Type == DLRQ_TYPE_PAYMENT)
        m_Purpose = IIF(m_rq.rec.DealPart == 1, CAi, CRi);
      elif((m_rq.rec.Type == DLRQ_TYPE_AVANCE) OR (m_rq.rec.Type == DLRQ_TYPE_DEPOSIT))
        m_Purpose = IIF(m_rq.rec.DealPart == 1, PM_PURP_AVANCE, PM_PURP_BACK_AVANCE);
      elif(m_rq.rec.Type == DLRQ_TYPE_INCREPO)
        m_Purpose = PM_PURP_PERCENT;
      elif(m_rq.rec.Type == DLRQ_TYPE_PAYMREPOCOUP)
        m_Purpose = PM_PURP_PAY_NKD;
      elif(m_rq.rec.Type == DLRQ_TYPE_PAYMREPOPART)
        m_Purpose = PM_PURP_RET_PARTLY;
      elif(m_rq.rec.Type == DLRQ_TYPE_COMPPAYM)
        m_Purpose = PM_PURP_COMPENS;
      elif(m_rq.rec.Type == DLRQ_TYPE_COMISS)
        if(ВидСубъекта(m_rq.rec.Party, PTK_MARKETPLASE ))
          m_Purpose = PM_PURP_COMMARKET;
        elif(ВидСубъекта(m_rq.rec.Party, PTK_BROKER ))
          m_Purpose = PM_PURP_COMBROKER;
        elif(ВидСубъекта(m_rq.rec.Party, PTK_ISSUER ))
          m_Purpose = PM_PURP_COMISSUER;
        elif(ВидСубъекта(m_rq.rec.Party, PTK_BANK ))
          m_Purpose = PM_PURP_COMMBANK;
        end;
      elif(m_rq.rec.Type == DLRQ_TYPE_PAYINCOME)
        m_Purpose = PM_PURP_SECUR_INCOME;
      elif(m_rq.rec.Type == DLRQ_TYPE_TAX_ULN)
        m_Purpose = PM_PURP_TAXINCOME_NJ;
      elif((m_rq.rec.Type == DLRQ_TYPE_TAX_FLN) or (m_rq.rec.Type == DLRQ_TYPE_TAX_FLR) or (m_rq.rec.Type == DLRQ_TYPE_TAX_FLR_ADD))
        m_Purpose = PM_PURP_TAXINCOME_IND;
      end;
    end;

    return m_Purpose;
  END;

  MACRO SubPurpose():INTEGER
    
    if(m_SubPurpose == NULL)
      m_SubPurpose = 0;

      if(this.Purpose() == PM_PURP_AVANCE)
        if(m_rq.rec.Type == DLRQ_TYPE_AVANCE)
          m_SubPurpose = SP_KINDAVANCE_AVANCE;
        elif(m_rq.rec.Type == DLRQ_TYPE_DEPOSIT)
          m_SubPurpose = SP_KINDAVANCE_DEPOSIT;
        end;
      end;
    end;

    return m_SubPurpose;
  END;

  PRIVATE MACRO GetPartyName( PartyID:INTEGER ) :STRING
    VAR Party_ForGet = TRecHandler( "party.dbt" );
    if( ПолучитьСубъекта( PartyID, Party_ForGet ) == 0 )
       return Party_ForGet.rec.Name;
    end;
    return "";
  end;

  //Simanov. true если субъект юр. лицо
  PRIVATE MACRO IsEntity( PartyID:INTEGER )
    VAR Party_ForGet = TRecHandler( "party.dbt" );
    if( ПолучитьСубъекта( PartyID, Party_ForGet ) == 0 )
       return (Party_ForGet.rec.LegalForm == 1/*PTLEFG_INST*/); 
    end;
    return false;
  end;

  MACRO Payer():INTEGER
     
     if(m_PayerID == NULL)
       m_PayerID = -1;
       
       if(this.IsTick())
         m_PayerID = {OurBank};
         
         if( m_rq.rec.Kind == DLRQ_KIND_REQUEST ) // требование
           m_PayerID = m_rq.rec.Party;
         elif( m_FD.tick.rec.ClientID > 0 )
           m_PayerID = m_FD.tick.rec.ClientID;
         end;
       elif(this.IsNett())
         m_PayerID = {OurBank};
         if( m_rq.rec.Kind == DLRQ_KIND_REQUEST ) // требование
           m_PayerID = m_rq.rec.Party;
         end;
       elif(this.IsComm())
         m_PayerID = {OurBank};
         if( m_rq.rec.Kind == DLRQ_KIND_REQUEST ) // требование
           m_PayerID = m_rq.rec.Party;
         end;
       elif(this.IsNptx())
         //Simanov. В операции списания плательщик - Банк
         if (m_FD.nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_ENROL) 
           m_PayerID = m_FD.nptxop.rec.Client;
         else
           m_PayerID = {OurBank};
         end;
       end;
     end;

     return m_PayerID;
  END;  

  MACRO PayerINN():STRING
    if(m_PayerINN == NULL)
    
      m_PayerINN = "";
      var KPP = "";

      SplitFullINN(ПолучитьКодСубъекта(this.Payer(), PTCK_INN), m_PayerINN, KPP);
    end;

    return m_PayerINN;
  END;

  MACRO PayerCodeKind():INTEGER
    return PTCK_CONTR;
  END;

  MACRO PayerCode():STRING
    if(m_PayerCode == NULL)
      m_PayerCode = ПолучитьКодСубъекта(this.Payer(), this.PayerCodeKind());
    end;

    return m_PayerCode;
  END;

  MACRO PayerName():STRING
    if(m_PayerName == NULL)
      m_PayerName = GetPartyName(this.Payer());
    end;

    return m_PayerName;
  END;

  MACRO Receiver():INTEGER
     var ReceiverID = -1;
     
     if(this.IsTick())
       ReceiverID = m_rq.rec.Party;
       
       if( m_rq.rec.Kind == DLRQ_KIND_REQUEST ) // требование
         if( m_FD.tick.rec.ClientID > 0 )
           ReceiverID = m_FD.tick.rec.ClientID;
         else 
           ReceiverID = {OurBank};
         end;
       end;
     elif(this.IsNett())
       ReceiverID = m_rq.rec.Party;
       
       if( m_rq.rec.Kind == DLRQ_KIND_REQUEST ) // требование
         ReceiverID = {OurBank};
       end;
     elif(this.IsComm())
       ReceiverID = m_rq.rec.Party;
       
       if( m_rq.rec.Kind == DLRQ_KIND_REQUEST ) // требование
         ReceiverID = {OurBank};
       end;
     elif(this.IsNptx())
       // DEF-74562 вывод ДС на лечение
       // BOSS-7143 Вывод средств наследнику
       if ((m_FD.nptxop.rec.PayMedical == "X") OR (m_FD.nptxop.rec.PayPurpose == 3))
         ReceiverID = m_FD.nptxop.rec.Receiver;
       else
         ReceiverID = m_FD.nptxop.rec.Client;
       end;
     end;

     return ReceiverID;
  END;

 MACRO ReceiverINN():STRING
    var INN = "", KPP = "";

    SplitFullINN(ПолучитьКодСубъекта(this.Receiver(), PTCK_INN), INN, KPP);

    return INN;
  END; 

  MACRO ReceiverCodeKind():INTEGER
    return PTCK_CONTR;
  END;

  MACRO ReceiverCode():STRING
    return ПолучитьКодСубъекта(this.Receiver(), this.ReceiverCodeKind());
  END;

  MACRO ReceiverName():STRING
    //Simanov. в операции списания ДС для юриков вместо наименования субъекта брать наименование договора
    if (this.IsNptx() and IsEntity(this.Receiver()) ) 
       // DEF-74562 вывод ДС на лечение
       // BOSS-7143 Вывод средств наследнику
       if ((m_FD.nptxop.rec.PayMedical == "X") OR (m_FD.nptxop.rec.PayPurpose == 3))
          return GetPartyName(m_FD.nptxop.rec.Receiver);
       else
          return m_FD.DBOName();
       end;
    end;
    return GetPartyName(this.Receiver());
  END;

  MACRO PayerBankID():INTEGER
     var BankID = {OurBank};

     if(m_rqacc_payer.rec.BankID > 0)
       BankID = m_rqacc_payer.rec.BankID;
     end;
     
     return BankID;
  END;  

  MACRO ReceiverBankID():INTEGER
     var BankID = {OurBank};

     if(m_rqacc_receiver.rec.BankID > 0)
       BankID = m_rqacc_receiver.rec.BankID;
     end;
     
     return BankID;
  END;  

  MACRO IsFixAmount():INTEGER
     return 0;
  END;

  MACRO PayerAccountRec():TRecHandler
    LoadAccounts();
    return m_DebetAccount;
  END;


  MACRO PayerAccount():STRING
     if(this.PayerBankID() != {OurBank})
       return m_rqacc_payer.rec.Account;//this.PayerCorrAcc();
     end;
     return this.PayerAccountRec().rec.Account;
  END; 

  MACRO ReceiverAccountRec():TRecHandler
    LoadAccounts();
    return m_CreditAccount;
  END;


  MACRO ReceiverAccount():STRING
     if(this.ReceiverBankID() != {OurBank})
       return m_rqacc_receiver.rec.Account;//this.ReceiverCorrAcc();
     end;
     return this.ReceiverAccountRec().rec.Account;
  END;  

  MACRO CorSchem():INTEGER
     var Schem = -1;
     
     if((m_rqacc.rec.BankCorrID > 0) and (m_rqacc.rec.BankCorrID != {OurBank}))
       Schem = ПолучитьКорсхемуПоУмолчанию(m_rqacc.rec.BankCorrID, m_rqacc.rec.FIID, 1);
     elif((m_rqacc.rec.BankID > 0) and (m_rqacc.rec.BankID != {OurBank}))
       Schem = ПолучитьКорсхемуПоУмолчанию(m_rqacc.rec.BankID, m_rqacc.rec.FIID, 1);
     end;

     return Schem;
  END;  

  MACRO CorrAcc():STRING
     var CorrAcc = "";
     var AccountBuff = TRecHandler("account.dbt");
     
     if((m_rqacc.rec.ID) and (m_rqacc.rec.BankID != {OurBank}))
       if(ПолучитьСчетПоПлатежнымРеквизитам(m_rqacc, AccountBuff) == 0)
          CorrAcc = AccountBuff.rec.Account;
       end;
     end;
     
     return CorrAcc;
  END;  

  MACRO CorrCode():STRING
     return m_rqacc.rec.BankCorrCode;
  END;  

  MACRO BankCode():STRING
     return m_rqacc.rec.BankCode;
  END;  

  MACRO PayerCorSchem():INTEGER
    var Schem = 0;
    if((m_rqacc_payer.rec.BankCorrID > 0) and (m_rqacc_payer.rec.BankCorrID != {OurBank}))
      Schem = ПолучитьКорсхемуПоУмолчанию(m_rqacc_payer.rec.BankCorrID, m_rqacc_payer.rec.FIID, 1);
    elif((m_rqacc_payer.rec.BankID > 0) and (m_rqacc_payer.rec.BankID != {OurBank}))
      Schem = ПолучитьКорсхемуПоУмолчанию(m_rqacc_payer.rec.BankID, m_rqacc_payer.rec.FIID, 1);
    end;

    return Schem;
  END;

  MACRO PayerCorrAcc():STRING
     var CorrAcc = "";
     
     if(this.PayerBankID() != {OurBank})
       CorrAcc = m_rqacc_payer.rec.CorrAcc;
     end;
     
     return CorrAcc;
  END;  

  MACRO PayerCorrCode():STRING
     return m_rqacc_payer.rec.BankCorrCode;
  END;  


  MACRO PayerBankCodeKind():INTEGER
     return m_rqacc_payer.rec.BankCodeKind;
  END;

  MACRO PayerBankCode():STRING
     return m_rqacc_payer.rec.BankCode;
  END;

  MACRO PayerBankName():STRING
     return m_rqacc_payer.rec.BankName;
  END;

  MACRO ReceiverCorSchem():INTEGER
    var Schem = 0;
    if((m_rqacc_receiver.rec.BankCorrID > 0) and (m_rqacc_receiver.rec.BankCorrID != {OurBank}))
      Schem = ПолучитьКорсхемуПоУмолчанию(m_rqacc_receiver.rec.BankCorrID, m_rqacc_receiver.rec.FIID, 1);
    elif((m_rqacc_receiver.rec.BankID > 0) and (m_rqacc_receiver.rec.BankID != {OurBank}))
      Schem = ПолучитьКорсхемуПоУмолчанию(m_rqacc_receiver.rec.BankID, m_rqacc_receiver.rec.FIID, 1);
    end;

    return Schem;
  END;

  MACRO ReceiverCorrAcc():STRING
     var CorrAcc = "";
     
     if(this.ReceiverBankID() != {OurBank})
       CorrAcc = m_rqacc_receiver.rec.CorrAcc;
     end;
     
     return CorrAcc;
  END;  

  MACRO ReceiverCorrCode():STRING
     return m_rqacc_receiver.rec.BankCorrCode;
  END;

  MACRO ReceiverBankCodeKind():INTEGER
     return m_rqacc_receiver.rec.BankCodeKind;
  END; 

  MACRO ReceiverBankCode():STRING
     return m_rqacc_receiver.rec.BankCode;
  END;

  MACRO ReceiverBankName():STRING
     return m_rqacc_receiver.rec.BankName;
  END;

  MACRO Department():INTEGER
    var Depart = 0;

    if(this.IsTick())
      Depart = m_FD.tick.rec.Department;
    elif(this.IsNett())
      Depart = m_FD.dl_nett.rec.Department;
    elif(this.IsComm())
      Depart = m_FD.comm.rec.Division;
    elif(this.IsNptx())
      Depart = m_FD.nptxop.rec.Department;
    end;

    return Depart;
  END;

  MACRO Ground():STRING
    var GroundStr = "";


    PRIVATE MACRO GetPurposeName(Purpose)
      var PurpName = "";
      var cmd = DL_RSDCommand("select t_name from dpmpurp_dbt where t_purpose = ? ");
      cmd.AddParam(Purpose);
      var DataSet = cmd.Execute();
      if(DataSet.moveNext())
        PurpName = DataSet.Name;
      end;
      return PurpName;
    END;

    PRIVATE MACRO GetOprKindName(OprKind)
      var OprKindName = "";
      var cmd = DL_RSDCommand("select t_name from doprkoper_dbt where t_Kind_Operation = ? ");
      cmd.AddParam(OprKind);
      var DataSet = cmd.Execute();
      if(DataSet.moveNext())
        OprKindName = DataSet.Name;
      end;
      return OprKindName;
    END;

    if(this.IsTick())
      if(m_rq.rec.Type == DLRQ_TYPE_TAX_FLR)
        GroundStr = string("Налог на доходы физ.лиц при выплате купонного дохода по " + m_FD.fininstr().rec.Name + " серии " + m_FD.avoiriss().rec.Series + ", гос.рег.№ " + m_FD.avoiriss().rec.LSIN + ".");
      elif(m_rq.rec.Type == DLRQ_TYPE_TAX_FLR_ADD)
        GroundStr = string("Налог на доходы физ.лиц при выплате купонного дохода по " + m_FD.fininstr().rec.Name + " серии " + m_FD.avoiriss().rec.Series + ", гос.рег.№ " + m_FD.avoiriss().rec.LSIN + ".");
      elif(m_rq.rec.Type == DLRQ_TYPE_TAX_FLN)
        GroundStr = string("Налог на доходы физ.лиц - нерезидентов при выплате купонного дохода по " + m_FD.fininstr().rec.Name + " серии " + m_FD.avoiriss().rec.Series + ", гос.рег.№ " + m_FD.avoiriss().rec.LSIN + ".");
      else
      GroundStr = string(GetPurposeName(this.Purpose())+" по сделке № "+m_FD.tick.rec.DealCode+", заключена "+string(m_FD.tick.rec.DealDate:f));
      end;
    elif(this.IsNett())
      GroundStr = string(GetPurposeName(this.Purpose())+" по сделке № "+m_FD.dl_nett.rec.DealNumber+", заключена "+string(m_FD.dl_nett.rec.SigningDate:f));
    elif(this.IsComm())
      GroundStr = string("Платеж по операции "+GetOprKindName(m_FD.comm.rec.OperationKind)+". Перевод средств в РЦ и их зачисление на торговый счет.");
    elif(this.IsNptx())
      GroundStr = string("Перевод денежных средств от "+GetPartyName(m_FD.nptxop.rec.Client)+" по платежному поручению "+m_FD.nptxop.rec.Code+" за "+string(m_FD.nptxop.rec.OperDate:f)+".");
    end;

    return GroundStr;
  END;

  MACRO ShifrOper():STRING
    var Shirf = "";
    
    if((this.PayerBankID() != {OurBank}) OR (this.ReceiverBankID() != {OurBank}))
      Shirf = "01";
    elif(((this.Payer() == m_rq.rec.Party) and (this.Receiver() != {OurBank})) OR 
         ((this.Receiver() == m_rq.rec.Party) and (this.Payer() != {OurBank}))
        )
      Shirf = "17";
    else
      Shirf = "09";
    end;                                      
    return Shirf;
  END;

  MACRO Construct( rq:TRecHandler, FD, IsCreatingPayms:bool )
     if( IsCreatingPayms != NULL )
        m_IsCreatingPayms = IsCreatingPayms;
     end;
  END;

  this.Construct(rq, FD, IsCreatingPayms);
END;


/* класс-адаптер что бы не переписывать весть старый код, который использует платежи */
PRIVATE CLASS DLRQ( DealFD:SPFirst, type:INTEGER, Part:INTEGER )
  PRIVATE VAR m_req:TRecHandler,
              m_rqpm = NULL;
  
  m_req = DealFD.GetRQ( type, Part );
  m_rqpm = DLRQ_PAYM(m_req, DealFD);

  MACRO rec()
     return this;
  END;

  MACRO dlreq()
     return m_req;
  END;

  MACRO m_rqacc()
    return m_rqpm.m_rqacc;
  END;

  MACRO ValueDate():DATE
     return m_rqpm.ValueDate();
  END;

  MACRO BaseFIID():INTEGER
     return m_rqpm.BaseFIID();
  END;

  MACRO FIID():INTEGER
     return m_rqpm.FIID();
  END;

  MACRO PayFIID():INTEGER
     return m_rqpm.PayFIID();
  END;

  MACRO BaseAmount():MONEY
     return m_rqpm.BaseAmount();
  END;

  MACRO Amount():MONEY
     return m_rqpm.Amount();
  END;

  MACRO PayAmount():MONEY
     return m_rqpm.PayAmount();
  END;

  MACRO PaymStatus():INTEGER
     return m_rqpm.PaymStatus();
  END;  

  MACRO Payer():INTEGER
     return m_rqpm.Payer();
  END;  

  MACRO Receiver():INTEGER
     return m_rqpm.Receiver();
  END;  

  MACRO PayerBankID():INTEGER
     return m_rqpm.PayerBankID();
  END;  

  MACRO ReceiverBankID():INTEGER
     return m_rqpm.ReceiverBankID();
  END;  

  MACRO IsFixAmount():INTEGER
     return m_rqpm.IsFixAmount();
  END;  

  MACRO PayerAccount():STRING
     return m_rqpm.PayerAccount();
  END;  

  MACRO ReceiverAccountRec():TRecHandler
     return m_rqpm.ReceiverAccountRec();
  END;

  MACRO ReceiverAccount():STRING
     return m_rqpm.ReceiverAccount();
  END;  

  MACRO CorSchem():INTEGER
     return m_rqpm.CorSchem();
  END;  

  MACRO CorrAcc():STRING
     return m_rqpm.CorrAcc();
  END;  

  MACRO CorrCode():STRING
     return m_rqpm.CorrCode();
  END;  

  MACRO BankCode():STRING
     return m_rqpm.BankCode();
  END;  

END;

//класс-коллекция ТО по сделке
PRIVATE CLASS SPDealRQ(DocKind, DocID)
  var v_RQ = TArray();
  var m_CurrRQ = NULL;

  //загрузить все ТО по сделке
  macro Load(DocKind, DocID)
    var Select, DataSet;
    var i = 0;
    
    v_RQ.size = 0;
    
    Select = DL_RSDCommand("select * from ddlrq_dbt where t_DocKind = ? and t_DocID = ?");
    Select.AddParam(DocKind);
    Select.AddParam(DocID);

    DataSet = Select.Execute();
    while(DataSet.moveNext())
      v_RQ(i) = TRecHandler( "dlrq" );
      DataSet.GetRecord().CopyTo( v_RQ(i).rec );
      i = i + 1;
    end;
  end;

  //получить ТО по сделке
  macro Get(Type, DealPart, FIID, Num)
    var i = 0;

    if(ValType(FIID) == V_UNDEF)
      FIID = ALLFININSTR;
    end;

    if(ValType(Num) == V_UNDEF)
      Num = 0;
    end;

    //для ускорения доступа
    if((ValType(m_CurrRQ) != V_UNDEF) AND (m_CurrRQ.rec.Type == Type) AND (m_CurrRQ.rec.DealPart == DealPart) AND ((FIID == ALLFININSTR) OR (m_CurrRQ.rec.FIID == FIID)) AND (m_CurrRQ.rec.Num == Num))
      return m_CurrRQ;
    end;

    while(i < v_RQ.size)
      if((v_RQ(i).rec.Type == Type) AND (v_RQ(i).rec.DealPart == DealPart) AND ((FIID == ALLFININSTR) OR (v_RQ(i).rec.FIID == FIID)) AND (v_RQ(i).rec.Num == Num))
        m_CurrRQ = v_RQ(i);
        return v_RQ(i);
      end;
      i = i + 1;
    end;

    return NULL;
  end;

  //получить ТО по сделке с максимальным номером
  macro GetWithMaxNum(Type, DealPart, FIID)
    var i = 0;
    var MaxNum = -1, find_i = -1;

    if(ValType(FIID) == V_UNDEF)
      FIID = ALLFININSTR;
    end;

    while(i < v_RQ.size)
      if((v_RQ(i).rec.Type == Type) AND (v_RQ(i).rec.DealPart == DealPart) AND ((FIID == ALLFININSTR) OR (v_RQ(i).rec.FIID == FIID)) AND (v_RQ(i).rec.Num > MaxNum))
        MaxNum = v_RQ(i).rec.Num;
        find_i = i;
      end;
      i = i + 1;
    end;

    if(find_i != -1)
      return v_RQ(find_i); 
    end;

    return NULL;
  end;

  //проверить, изменилось ли ТО (изменился ли текущий буфер по отношению к записи в базе)
  macro IsChanged(Type, DealPart, FIID, Num)
    var Select, DataSet;
    var BuffRQ = TRecHandler("dlrq");
    var BaseRQ = TRecHandler("dlrq");
    var Changed = false;

    BuffRQ = this.Get(Type, DealPart, FIID, Num);

    if(BuffRQ != NULL)
      Select = DL_RSDCommand("select * from ddlrq_dbt where t_ID = ?");
      Select.AddParam(BuffRQ.rec.ID);

      DataSet = Select.Execute();
      if(DataSet.moveNext())
        DataSet.GetRecord().CopyTo( BaseRQ.rec );
        
        if( (BuffRQ.rec.State    != BaseRQ.rec.State) OR
            (BuffRQ.rec.PlanDate != BaseRQ.rec.PlanDate) OR
            (BuffRQ.rec.Amount   != BaseRQ.rec.Amount) OR
            (BuffRQ.rec.FIID     != BaseRQ.rec.FIID)
          )
          Changed = true;
        end;
      else
         Changed = true;
      end;
    end;

    return Changed;
  end;

  macro Set(dlrq)
     if( Get(dlrq.rec.Type, dlrq.rec.DealPart, dlrq.rec.FIID, dlrq.rec.Num) == NULL )
        v_RQ(v_RQ.Size()) = dlrq;
     end;
  end;

  macro GetArrFIID( Type:integer, DealPart:integer ):TArray
     var v_FIID = TArray();
     var i:integer = 0;

     v_FIID.size = 0;

     while( i < v_RQ.size )
        if( (v_RQ(i).rec.Type == Type) and (v_RQ(i).rec.DealPart == DealPart) )
           var ExistFIID:bool = false;
           var j:integer = 0;
           while( j < v_FIID.size )
             if( v_FIID(j) == v_RQ(i).rec.FIID )
               ExistFIID = true;
               break;
             end;
             j = j + 1;
           end;
           if( not ExistFIID )
              v_FIID(v_FIID.size) = v_RQ(i).rec.FIID;
           end;
        end;
        i = i + 1;
     end;

     return v_FIID;
  end;

  Load(DocKind, DocID);

END;

/**************************************************************************/
/*  класс - первичные документы для работы с категориями учета в сделках  */ 
/*  CallInclude - вложенный вызов. Используется для сделок с двумя частями
                  для создания из SPFirstDoc класса по другой части       */
/**************************************************************************/
CLASS (SPFirst) SPFirstDoc( parm1, parm2, parm3, parm4, CallInclude )
   /*Переменные, объявленные ниже инициализируются в момент первого использования. Весь доступ
     к ним должен идти через одноименные свойства (без префикса "v_"). Сделано для оптимизации
     времени выполнения шагов операций */
   PRIVATE VAR 
      v_pm_avoir:DLRQ = NULL, 
      v_pm_money:DLRQ = NULL, 
      v_pm_money_:DLRQ = NULL, 
      v_pm_avance:DLRQ = NULL, 
      v_pmpc:DLRQ = NULL,
      v_debet:DLRQ = NULL, 
      v_credit:DLRQ = NULL, 
      v_RQ:SPDealRQ,

      v_EnsID_ForAcc:INTEGER = -1, /* обеспечение, по которому будут открываться счета */
      v_fininstr = NULL,
      v_avoiriss = NULL,
      v_avrserv  = NULL,
      v_pmwrtsum:TRecHandler, 
      v_ArrWrtSum:TArray,             /* массив лотов*/
      v_pmwrtsum_contr:TRecHandler,
      v_pmwrtsum_curr = NULL,
      v_FaceValue:DOUBLE,             /* номинал ц/б - double - с учетом точности и масштаба*/
      v_FaceValueDealDt:DOUBLE,       /* номинал ц/б на дату сделки - double - с учетом точности и масштаба*/
      v_FaceValueMoney:MONEY,         /* номинал ц/б - money - с учетом точности и масштаба*/
      v_FaceValueOnSetAv: DOUBLE,     /* номинал ц/б на дату поставки бумаг */
      v_MarketCode:STRING,            /* код биржи, для биржевых сделок*/ 
      v_NewFIID:INTEGER,              /* FIID выпуска после глобальной операции*/
      v_CurPFI:INTEGER = ALLFININSTR, /* Текущий выпуск из обеспечения */
      v_CurContrAgent = -1;

   VAR  
       dl_leg:TRecHandler,  /*транш сделки*/ 
       v_DateArray:TArray = NULL,    /* массив с датами сделки    */ 
       BuySale:INTEGER,     /* тип сделки - продажа или покупка */             
       IsOperLOAN:BOOL,     /*Признак операции займа*/
       ExistBack:BOOL,      /* существует обр. часть по сделке*/         
       Group:INTEGER,       /* группа, в которую попадает тип операции по сделке  */  
       StrClassName:STRING, /*название части сделки, по которой создан класс*/
       FirstInit:BOOL,      /* признак первоначальной инициализации объекта класса в операции, то есть выполняется расчет дат, инициализация платежей*/ 
       v_BaseFIID:INTEGER,  /*FIID выпуска, с которым работаем в данном объекте класса ПД. Можно задать напрямую извне*/
       m_CallInclude:BOOL;

   var DlComis = TRecHandler("dlcomis.dbt");

   VAR BegDate = NULL, FinDate = NULL;

   PRIVATE MACRO EnsID_ForAcc()  
      if( v_EnsID_ForAcc <=0  )
         var DS, cmd = RSDCommand( "SELECT min(t_id) EnsID FROM DDL_TICK_ENS_DBT WHERE t_dealid = ? and t_fiid = ?" );
         cmd.addParam( "", RSDBP_IN, this.tick.rec.DealID );
         cmd.addParam( "", RSDBP_IN, this.CurPFI() );
         cmd.execute();

         DS = TRsbDataSet( cmd );
         if( DS.MoveNext() AND (DS.EnsID != NULL) AND (DS.EnsID > 0) )
            v_EnsID_ForAcc = DS.EnsID;
         end;
      end;
      return v_EnsID_ForAcc;
   END;    

   PRIVATE VAR  CorrectBasket_Kind = -1, CorrectBasket_ID = -1;
   PRIVATE MACRO CorrectParameters( store:bool ):bool
      VAR RetVal:bool = false;

      if( (not store) AND ((CorrectBasket_Kind > 0 ) AND (CorrectBasket_ID > 0)) )
         this.ID   = CorrectBasket_ID;
         this.Kind = CorrectBasket_Kind; 
         
         if( ParmA[MC_TYPE_PARAMETR_DOCKIND] != NULL ) 
            ParmA[MC_TYPE_PARAMETR_DOCKIND] = this.Kind;
         end;

         if( ParmA[MC_TYPE_PARAMETR_DOCID] != NULL ) 
            ParmA[MC_TYPE_PARAMETR_DOCID]  = this.ID;
         end;

         CorrectBasket_Kind = -1;
         CorrectBasket_ID   = -1;
         RetVal = true;

      elif( store )

         if( (this.tick != NULL) AND (this.tick.rec.BofficeKind == DL_SECURITYDOC) AND IsBasket(this.Group) )
            if( КУ_СчетПараметризованПоБумаге(v_CatCode) or (v_CatCode == "+%ДЦ/б") )

               if( EnsID_ForAcc() > 0 )

                  CorrectBasket_ID   = this.ID;
                  CorrectBasket_Kind = this.Kind; 

                  this.ID   = EnsID_ForAcc();   
                  this.Kind = DL_TICK_ENS_DOC /*обеспечение по сделке*/; 

                  if( ParmA[MC_TYPE_PARAMETR_DOCKIND] != NULL ) 
                     ParmA[MC_TYPE_PARAMETR_DOCKIND] = this.Kind;
                  end;

                  if( ParmA[MC_TYPE_PARAMETR_DOCID] != NULL ) 
                     ParmA[MC_TYPE_PARAMETR_DOCID]  = this.ID;
                  end;

                  RetVal = true;
               else                                                                                       
                  MsgBox( "Для сделки \"" + this.tick.rec.DealCode + "\" не найдено обеспечение по бумаге \"" + GetFICode( this.CurPFI() ) + "\"");
               end;
            end;
         end;
      end;

      return RetVal;
   END;

   macro getCurContrAgent():integer
     return v_CurContrAgent;
   end;

   macro setCurContrAgent(id:Integer)
      v_CurContrAgent = id;
   end;

   MACRO IsExistsTick_ENS()
      var cmd = DL_RSDCommand(" SELECT t_ID " +
                              "   FROM DDL_TICK_ENS_DBT " +
                              "  WHERE T_DEALID = ? ");
      cmd.AddParam(this.tick.rec.DealID);
      if( cmd.GetCount() > 0 )
         return true;
      end;
      return false;
   END;

   MACRO SetCurPFI( Issue:Integer )
      if( v_CurPFI != Issue )
      v_CurPFI   = Issue;
      v_fininstr = NULL;
      v_avoiriss = NULL;
      v_pmwrtsum = NULL;
      v_pmwrtsum_contr = NULL;
         v_EnsID_ForAcc = -1;
         v_BaseFIID = NULL;
      end;
   END;

   MACRO CurPFI():integer
      var RetVal:integer = ALLFININSTR;

      if( (v_CurPFI != null) AND (v_CurPFI != ALLFININSTR) )
         RetVal = v_CurPFI;
      else
         v_CurPFI = RetVal = this.dl_leg.rec.PFI;
      end;

      return RetVal;
   END;

   MACRO НуженСчетКорзина():bool
      var RetVal:bool = false;
      if( IsBasket(this.Group) )
         RetVal = true;
         if(CurPFI() == dl_leg.rec.PFI) /*если текущий ФИ совпадает с ФИ корзины, то счета не в разрезе ФИ, т.е. не корзинные*/
            RetVal = false;
         end;
      end;
      return RetVal;
   END;


   MACRO RQ() 
      if( v_RQ == null )
         v_RQ = SPDealRQ( this.tick.rec.BOfficeKind, this.tick.rec.DealID );
      end;
      return v_RQ;
   END;    

   MACRO DateArray():TArray
     if( v_DateArray == NULL )
       this.v_DateArray = TArray();
       this.ПолучитьДатыСделки( this.FirstInit, m_CallInclude );  
       var cntr = 0, startDate = date(0,0,0), bufDate;
       while (cntr < this.v_DateArray.size)
         if ((ValType(this.v_DateArray[cntr])==V_DATE) and (this.v_DateArray[cntr] != date(0,0,0)))
           startDate = date(0,0,0);
           bufDate = SP_Calend_GetCorrectDate(this, this.GetKindDate(cntr),this.v_DateArray[cntr],@startDate);
           //если полученная дата меньше даты сделки, то смещения не делаем
           bufDate = IIF(((startDate != date(0,0,0)) and (bufDate < startDate)),this.v_DateArray[cntr],bufDate);
           this.v_DateArray[cntr] = bufDate;
         end;
         cntr = cntr + 1;
       end;
     end;
     return v_DateArray;
   END;

   MACRO ExistsRQ(Type, DealPart, FIID)
     if( ValType(DealPart) == V_UNDEF )
       DealPart = IIF(this.IsBack, 2, 1);
     end;

     if( (ValType(FIID) == V_UNDEF) and (Type == DLRQ_TYPE_DELIVERY) and IsBasket(this.Group) )
       FIID = v_CurPFI;
     end;

     if((Type == DLRQ_TYPE_INCREPO) and IsLOAN(this.Group))
       DealPart = 2;
     end;

     return IIF((RQ.Get(Type, DealPart, FIID) == NULL), false, true);
   END;

   MACRO GetRQ(Type, DealPart, FIID, NoMsgErr, IsCriticalError, Num )
     if(ValType(DealPart) == V_UNDEF)
       DealPart = IIF(this.IsBack, 2, 1); 
     end;

     if( (ValType(FIID) == V_UNDEF) and (Type == DLRQ_TYPE_DELIVERY) and IsBasket(this.Group) )
       FIID = v_CurPFI;
     end;
     
     if((Type == DLRQ_TYPE_INCREPO) and IsLOAN(this.Group))
       DealPart = 2;
     end;

     VAR tmp = RQ.Get(Type, DealPart, FIID, Num);
     if( tmp == NULL)
       if( (NoMsgErr == null) OR (NoMsgErr == false) )
          this.SetError("Не найдено ТО", IsCriticalError);
       end;
     end;

     return tmp;
   END;

   MACRO SetRQ(dlrq)
      RQ.Set(dlrq);
   END;

   MACRO RQGetArrFIID( Type:integer, DealPart:integer ):TArray
      var RetVal = TArray();

      if( IsBasket(this.Group) )
         if( ValType(DealPart) == V_UNDEF )
            DealPart = IIF(this.IsBack, 2, 1); 
         end;
         RetVal = RQ.GetArrFIID(Type, DealPart);
      else
         RetVal.size = 0;
         RetVal(RetVal.size) = CurPFI();
      end;

      return RetVal;
   END;

   MACRO GetRQWithMaxNum(Type, DealPart, FIID)
     if(ValType(DealPart) == V_UNDEF)
       DealPart = IIF(this.IsBack, 2, 1); 
     end;

     VAR tmp = RQ.GetWithMaxNum(Type, DealPart, FIID);
     if( tmp == NULL)
       this.SetError("Не найдено ТО");
     end;

     return tmp;
   END;

   MACRO RQIsChanged(Type, DealPart, FIID)
     if(ValType(DealPart) == V_UNDEF)
       DealPart = IIF(this.IsBack, 2, 1); 
     end;
     return RQ.IsChanged(Type, DealPart, FIID);
   END;

   MACRO SaveChangedRQ(FactDate)
     var DealPart = IIF(this.IsBack, 2, 1);

     if((this.ExistsRQ(DLRQ_TYPE_PAYMENT)) and (this.RQIsChanged(DLRQ_TYPE_PAYMENT)))
       if(DL_ChangeDLRQ(this.GetRQ(DLRQ_TYPE_PAYMENT), FactDate, DLRQ_ACTION_UPDATE) != 0)
         return 1;
       end;
     end;

     var ArrFIID = RQGetArrFIID(DLRQ_TYPE_DELIVERY);
     var j:integer = 0;
     while( j < ArrFIID.size )
       if((this.ExistsRQ(DLRQ_TYPE_DELIVERY, DealPart, ArrFIID(j))) and (this.RQIsChanged(DLRQ_TYPE_DELIVERY, DealPart, ArrFIID(j))))
         if(DL_ChangeDLRQ(this.GetRQ(DLRQ_TYPE_DELIVERY, DealPart, ArrFIID(j)), FactDate, DLRQ_ACTION_UPDATE) != 0)
           return 1;
         end;
       end;
       j = j + 1;
     end;

     if((this.ExistsRQ(DLRQ_TYPE_AVANCE)) and (this.RQIsChanged(DLRQ_TYPE_AVANCE)))
       if(DL_ChangeDLRQ(this.GetRQ(DLRQ_TYPE_AVANCE), FactDate, DLRQ_ACTION_UPDATE) != 0)
         return 1;
       end;
     end;

     if((this.ExistsRQ(DLRQ_TYPE_DEPOSIT)) and (this.RQIsChanged(DLRQ_TYPE_DEPOSIT)))
       if(DL_ChangeDLRQ(this.GetRQ(DLRQ_TYPE_DEPOSIT), FactDate, DLRQ_ACTION_UPDATE) != 0)
         return 1;
       end;
     end;

     /*платежа %% до изменений условий могло и не быть, поэтому его существования не проверяем*/
     if( (DealPart == 2) and (this.RQIsChanged(DLRQ_TYPE_INCREPO)) )
       var dlrq1 = TRecHandler("dlrq.dbt"); 
       if(ПолучитьТОпоДокументу(this.tick.rec.BofficeKind, this.tick.rec.DealID, DealPart, DLRQ_TYPE_INCREPO, 0, dlrq1) == false)
          if( DL_CreateDLRQ(this.GetRQ(DLRQ_TYPE_INCREPO), FactDate, DLRQ_ACTION_CREATE) != 0)
            return 1;
          end;
       else
          if(DL_ChangeDLRQ(this.GetRQ(DLRQ_TYPE_INCREPO), FactDate, DLRQ_ACTION_UPDATE) != 0)
            return 1;
          end;
       end;
     end;

     return 0;
   END;

   //получить сумму ТО в ВР
   MACRO GetRQPayAmount(RqType, dat)
     var Amount = $0;

     if(this.ExistsRQ(RqType))
       SmartConvertSum( Amount, this.GetRQ(RqType).rec.Amount, dat, this.GetRQ(RqType).rec.FIID, this.GetPayFIID(), true ); 
     end;

     return Amount;
   END;

   MACRO Principal( Dat:date )
      var RetVal = 0.0;

      if( IsBasket(this.Group) )
         var cmd2 = DL_RSDCommand();
         var query2= " SELECT SUM(CASE WHEN T_KIND = ? THEN NVL(T_PRINCIPAL,0) ELSE NVL(-T_PRINCIPAL,0) END) T_PRINCIPAL " +
                     "   FROM DDL_TICK_ENS_DBT " +
                     "  WHERE T_DEALID = ? " +
                     "    AND T_DATE  <= ? " +
                     "    AND T_FIID   = ? ";
         cmd2.AddParam(TICKENS_KIND_IN);
         cmd2.AddParam(this.tick.rec.DealID);
         cmd2.AddParam(Dat);
         cmd2.AddParam(CurPFI());

         var DataSet2 = cmd2.Execute(query2);
         if( DataSet2.moveNext() )
            RetVal = SQL_ConvTypeSum(DataSet2.Principal);
         end;
      else
         RetVal = this.dl_leg.rec.Principal;
      end;

      return RetVal;
   END;

   MACRO Cost( Dat:date )
      var RetVal = 0.0;

      if( IsBasket(this.Group) )
         var cmd2 = DL_RSDCommand();
         var query2= " SELECT SUM(CASE WHEN T_KIND = ? THEN NVL(T_TOTALCOST,0) ELSE NVL(-T_TOTALCOST,0) END) T_TOTALCOST " +
                     "   FROM DDL_TICK_ENS_DBT " +
                     "  WHERE T_DEALID = ? " +
                     "    AND T_DATE  <= ? " +
                     "    AND T_FIID   = ? ";
         cmd2.AddParam(TICKENS_KIND_IN);
         cmd2.AddParam(this.tick.rec.DealID);
         cmd2.AddParam(Dat);
         cmd2.AddParam(CurPFI());

         var DataSet2 = cmd2.Execute(query2);
         if( DataSet2.moveNext() )
            RetVal = SQL_ConvTypeSum(DataSet2.TotalCost);
         end;

         SmartConvertSum( RetVal, RetVal, Dat, this.FaceFIID(), NATCUR, true ) ;         
      else
         RetVal = this.dl_leg.rec.Cost;
      end;

      return RetVal;
   END;

   MACRO NKD( Dat:date ) /*На всё количество ЦБ*/
      var RetVal = 0.0;

      if( IsBasket(this.Group) )
         var cmd2 = DL_RSDCommand();
         var query2= " SELECT SUM(CASE WHEN T_KIND = ? THEN NVL(T_NKD*T_PRINCIPAL,0) ELSE NVL(-T_NKD*T_PRINCIPAL,0) END) T_NKD " +
                     "   FROM DDL_TICK_ENS_DBT " +
                     "  WHERE T_DEALID = ? " +
                     "    AND T_DATE  <= ? " +
                     "    AND T_FIID   = ? ";
         cmd2.AddParam(TICKENS_KIND_IN);
         cmd2.AddParam(this.tick.rec.DealID);
         cmd2.AddParam(Dat);
         cmd2.AddParam(CurPFI());

         var DataSet2 = cmd2.Execute(query2);
         if( DataSet2.moveNext() )
            RetVal = SQL_ConvTypeSum(DataSet2.NKD);
         end;
      else
         RetVal = this.dl_leg.rec.NKD;
      end;

      return RetVal;
   END;

   MACRO NKD_ALL( Dat:date, pPayFIID:integer ) /*На всё количество ЦБ*/
      var RetVal = 0.0, Summ = 0.0, SummNKD = 0.0, OldCurPFI = this.CurPFI();

      if( IsBasket(this.Group) )

         var ArrFIID = RQGetArrFIID(DLRQ_TYPE_DELIVERY);
         var j:integer = 0;
         var vPayFIID = iif(pPayFIID!=NULL,pPayFIID,this.GetPayFIID());

         while( j < ArrFIID.size )
           this.SetCurPFI(ArrFIID(j));

           Summ = 0.0;
           SummNKD = this.NKD( Dat );

           SmartConvertSumDbl( Summ, SummNKD, dat, this.FaceFIID(), vPayFIID, true );

           RetVal = RetVal + Summ;

           j = j + 1;
         end;

         this.SetCurPFI(OldCurPFI);

      else
         RetVal = this.dl_leg.rec.NKD;
      end;

      return RetVal;
   END;

    MACRO pm_avoir() /* платеж ценными бумагами   */
       if( v_pm_avoir == null )

          /*для погашения купона ц/б платежа по бумагам нет*/
          if( (this.tick.rec.BOfficeKind != DL_GET_DIVIDEND) AND 
              (IsRET_COUPON( this.Group ) != true) AND 
              (IsRET_PARTLY( this.Group ) != true)
            )
             v_pm_avoir = DLRQ( WeakRef(this), DLRQ_TYPE_DELIVERY );
          else
             v_pm_avoir = NULL;
          end;
       end;
       return v_pm_avoir;
    END;    

    MACRO pm_money() 

       if( v_pm_money == null )
          /*для зачислений/списаний, конвертаций, займов платежа по контрактиву нет*/
          if( (this.IsOperLOAN == true) OR
              (this.tick.rec.BofficeKind == DL_AVRWRT) OR
              (this.tick.rec.BofficeKind == DL_TRUSTAVRWRT) OR
              (this.tick.rec.BofficeKind == DL_CONVAVR)
            )
             v_pm_money = NULL;
          else
             v_pm_money = DLRQ( WeakRef(this), DLRQ_TYPE_PAYMENT );
          end;                
       end;

       return v_pm_money;
    END;

    MACRO pm_money_()  // отличается от pm_money в части займа

       if( v_pm_money_ == null )
          /*для зачислений/списаний, конвертаций платежа по контрактиву нет*/
          if( (this.tick.rec.BofficeKind == DL_AVRWRT) OR
              (this.tick.rec.BofficeKind == DL_TRUSTAVRWRT) OR
              (this.tick.rec.BofficeKind == DL_CONVAVR)
            )
             v_pm_money_ = NULL;
          elif( this.IsOperLOAN == true )
             v_pm_money_ = DLRQ( WeakRef(this), DLRQ_TYPE_INCREPO, 2 ); // для займа берём платёж по процентам
          else
             v_pm_money_ = DLRQ( WeakRef(this), DLRQ_TYPE_PAYMENT );
          end;                
       end;

       return v_pm_money_;
    END;

    MACRO debet() 
       if( v_debet == null ) 
          if( this.IsOperLOAN == true )
             v_debet = DLRQ( WeakRef(this), DLRQ_TYPE_INCREPO, 2 );
          else
             v_debet = DLRQ( WeakRef(this), DLRQ_TYPE_PAYMENT );
          end;
       end;
       return v_debet;
    END;    

    MACRO credit() 
       if( v_credit == null )
          if( this.IsOperLOAN == true )
             v_credit = DLRQ( WeakRef(this), DLRQ_TYPE_INCREPO, 2 );
          else
             v_credit = DLRQ( WeakRef(this), DLRQ_TYPE_PAYMENT );
          end;
       end;
       return v_credit;
    END;    

    MACRO pmpc() 
       if( v_pmpc == null )
          if( ((this.IsOperLOAN == true) OR (IsREPO(this.Group) == true)) 
               AND ((this.dl_leg.rec.ReturnIncome != 0) ) ) /*ставка != 0 - есть платеж %%*/

             v_pmpc = DLRQ( WeakRef(this), DLRQ_TYPE_INCREPO, 2 );
          else
             v_pmpc = NULL;
          end;
       end;
       return v_pmpc;
    END;    

    MACRO pm_avance() 
       if( v_pm_avance == null )
          if(this.ExistAvance())
            v_pm_avance = DLRQ( WeakRef(this), DLRQ_TYPE_AVANCE );
          elif( this.ExistDeposit() )
             v_pm_avance = DLRQ( WeakRef(this), DLRQ_TYPE_DEPOSIT );
          end;
       end;

       return v_pm_avance;
    END;    

    MACRO fininstr()  
       if( (v_fininstr == NULL) or
           (strupr(GenClassName(v_fininstr)) != strupr("TRecHandler")) or
           (strupr(v_fininstr.TblName) != strupr("fininstr.dbt"))
         )
          v_avoiriss = Trechandler( "avoiriss.dbt" ); /* бумага*/
          v_fininstr = Trechandler( "fininstr.dbt" ); /* фин. инструмент           */

          if( ПолучитьФинИн( this.GetBaseFIID(), v_fininstr, v_avoiriss ) != 0 ) 
             this.SetError( "Не найдена ценная бумага " + string(this.GetBaseFIID()) );
          end;
       end;
       return v_fininstr;
    END;    

    MACRO avoiriss()  
       if( (v_avoiriss == NULL) or
           (strupr(GenClassName(v_avoiriss)) != strupr("TRecHandler")) or
           (strupr(v_avoiriss.TblName) != strupr("avoiriss.dbt"))
         )
          v_avoiriss = Trechandler( "avoiriss.dbt" ); /* бумага*/
          v_fininstr = Trechandler( "fininstr.dbt" ); /* фин. инструмент           */

          if( ПолучитьФинИн( this.GetBaseFIID(), v_fininstr, v_avoiriss ) != 0 ) 
             this.SetError( "Не найдена ценная бумага " + string(this.GetBaseFIID()) );
          end;
       end;
       return v_avoiriss;
    END;

    MACRO avrserv()  
       if( (v_avrserv == NULL) or
           (strupr(GenClassName(v_avrserv)) != strupr("TRecHandler")) or
           (strupr(v_avrserv.TblName) != strupr("avrserv.dbt"))
         )
          var q, cmd, ds;

          cmd = DL_RSDCommand("select * from davrserv_dbt where t_FIID = ?");
          cmd.AddParam(this.fininstr().rec.FIID);

          ds = cmd.Execute();
          if(ds.moveNext())
            v_avrserv = Trechandler( "avrserv.dbt" );
            ds.GetRecord().CopyTo(v_avrserv.rec);
          end;
          
       end;
       return v_avrserv;
    END; 

    /*Для 2-й части прямомго РЕПО - может быть неск. лотов.
      LotNumber - порядковый номер лота. Если лот по части сделки - строго 1, то можно не задавать.
    */
    MACRO pmwrtsum(LotNumber)
       var BuySaleWrt, DocKind, DocID, Purpose, Group, i = 0, DataSet, Query;
       
       if( v_pmwrtsum == NULL )
          v_pmwrtsum = Trechandler( "pmwrtsum.dbt" ); /* лот                       */      

          if((this.tick.rec.BofficeKind == DL_SECUROWN) or 
             (this.tick.rec.BofficeKind == DL_AVRWRTOWN) or 
             (this.tick.rec.BofficeKind == DL_RETIREMENT_OWN)
            )
            if(this.BuySale == DEAL_TYPE_SALE) 
               BuySaleWrt = PM_WRITEOFF_SUM_PLACE;
            else 
               BuySaleWrt = PM_WRITEOFF_SUM_RET_PLACE;
            end;
          else
            if( (this.BuySale == DEAL_TYPE_SALE) OR
                (this.BuySale == DEAL_TYPE_RET_COUPON) OR
                (this.BuySale == DEAL_TYPE_RET_PARTLY) 
              ) 
               BuySaleWrt = PM_WRITEOFF_SUM_SALE;
            else 
               if( IsTwoPart(this.Group) AND IsBUY(this.Group) )
                  BuySaleWrt= PM_WRITEOFF_SUM_BUY_BO;
               else
                  BuySaleWrt= PM_WRITEOFF_SUM_BUY;
               end;
            end;
          end;

          /*Для получения DocID - дублирование части кода ф-и ПолучитьЛотПоСделке()  */
          Group = SP_GetOperationGroup(this.tick.rec);

          if( IsRET_COUPON(Group) OR IsRET_PARTLY(Group) )
             DocKind = this.tick.rec.BofficeKind;
             DocID   = this.tick.rec.DealID;
             if( IsRET_COUPON(Group) )
                Purpose = PM_WRITEOFF_SUM_COUPON;
             else
                Purpose = PM_WRITEOFF_SUM_PARTIAL;
             end;
          else
             DocKind = DLDOC_PAYMENT; 
             DocID = 0;
             if(ExistsRQ(DLRQ_TYPE_DELIVERY, NULL, CurPFI()))
                DocID = this.GetRQ(DLRQ_TYPE_DELIVERY, NULL, CurPFI()).rec.ID;
             end;
             Purpose = BuySaleWrt;
          end;

          Query = RSDCommand("Select * "
                + "  From dpmwrtsum_dbt "
                + " Where t_DocKind  = ? "
                + "   and t_DocID    = ? "
                + "   and t_Buy_Sale = ? "
                + "   and t_FIID     = ? "
                + " Order by t_PartNum ");

          Query.addParam( "", RSDBP_IN, DocKind );
          Query.addParam( "", RSDBP_IN, DocID );
          Query.addParam( "", RSDBP_IN, Purpose );
          Query.addParam( "", RSDBP_IN, CurPFI() );
          Query.execute();

          DataSet = TRsbDataSet(Query);
          v_ArrWrtSum = TArray();
          v_ArrWrtSum.size = 0;
          while(DataSet.MoveNext())

             v_ArrWrtSum(i) = TRecHandler( "pmwrtsum" );
             DataSet.GetRecord().CopyTo( v_ArrWrtSum(i).rec );
             i = i + 1;
          end;

          if( v_ArrWrtSum.size == 0 )
             v_ArrWrtSum(0) = TRecHandler( "pmwrtsum" );
          end;

          if (LotNumber == null)
             LotNumber = 0;
          end;

          v_pmwrtsum = v_ArrWrtSum(LotNumber);

       else
          if (LotNumber == null)
             LotNumber = 0;
          end;

          v_pmwrtsum = v_ArrWrtSum(LotNumber);
       end;
       return v_pmwrtsum;
    END;    

    MACRO pmwrtsum_contr()  /*лот контрагента */
       var f_wrtsum, Buy_Sale, DataSet, Query;

       if( v_pmwrtsum_contr == NULL )
          v_pmwrtsum_contr = Trechandler( "pmwrtsum.dbt" ); /* лот */

          if( IsBUY(this.Group) )
             if(this.IsBack)
               Buy_Sale = PM_WRITEOFF_SUM_BUY;
             else
               Buy_Sale = PM_WRITEOFF_SUM_SALE;
             end;
          else 
             if(this.IsBack)
               Buy_Sale = PM_WRITEOFF_SUM_SALE;
             else
               Buy_Sale = PM_WRITEOFF_SUM_BUY;
             end;
          end;

          Query = RSDCommand("Select * "
                + "  From dpmwrtsum_dbt "
                + " Where t_DocKind  = ? "
                + "   and t_DocID    = ? "
                + "   and t_Buy_Sale = ? "
                + "   and t_FIID     = ? "
                + " Order by t_PartNum ");

          Query.addParam( "", RSDBP_IN, pmwrtsum.rec.DocKind );
          Query.addParam( "", RSDBP_IN, pmwrtsum.rec.DocID );
          Query.addParam( "", RSDBP_IN, Buy_Sale );
          Query.addParam( "", RSDBP_IN, CurPFI() );
          Query.execute();

          DataSet = TRsbDataSet(Query);

          if(DataSet.moveNext())
            DataSet.GetRecord().CopyTo( v_pmwrtsum_contr.rec );
          else
            v_pmwrtsum_contr.Clear();
          end;
       end;
       return v_pmwrtsum_contr;
    END;    

    MACRO pmwrtsum_curr()  /*лот денежный */
       var Buy_Sale = PM_WRITEOFF_SUM_BUY, DataSet, Query, DocID = 0;

       if( v_pmwrtsum_curr == NULL )
          v_pmwrtsum_curr = Trechandler( "pmwrtsum.dbt" ); /* лот */

          if( IsBUY(this.Group) )
             Buy_Sale = PM_WRITEOFF_SUM_SALE;
          end;

          if(ExistsRQ(DLRQ_TYPE_PAYMENT, 1, ALLFININSTR))
             DocID = this.GetRQ(DLRQ_TYPE_PAYMENT, 1, ALLFININSTR).rec.ID;
          end;

          Query = RSDCommand("Select * "
                + "  From dpmwrtsum_dbt "
                + " Where t_DocKind  = ? "
                + "   and t_DocID    = ? "
                + "   and t_Buy_Sale = ? "
                + "   and t_Kind     = ? ");

          Query.addParam( "", RSDBP_IN, DLDOC_PAYMENT );
          Query.addParam( "", RSDBP_IN, DocID );
          Query.addParam( "", RSDBP_IN, Buy_Sale );
          Query.addParam( "", RSDBP_IN, PM_WRTSUM_KIND_RCURR );
          Query.execute();

          DataSet = TRsbDataSet(Query);

          if(DataSet.moveNext())
            DataSet.GetRecord().CopyTo( v_pmwrtsum_curr.rec );
          else
            v_pmwrtsum_curr.Clear();
          end;
       end;
       return v_pmwrtsum_curr;
    END;    

    MACRO FaceFIID() 
      if( IsBasket(this.Group) and (this.fininstr.rec.AvoirKind == AVOIRISSKIND_BASKET) )
         return NATCUR;
      else
         return this.fininstr.rec.FaceValueFI;
      end;
    END;    

    MACRO NKDFIID()
       if( IsBasket(this.Group) )
          return this.FaceFIID();
       else
          return this.dl_leg.rec.NKDFIID;
       end;
    END;

    MACRO FaceValue()
       if( v_FaceValue == NULL )
          v_FaceValue = GetFaceValue( this.fininstr.rec.FIID );
       end;
       return v_FaceValue;
    END;    
/*// IAL 15 April 2005*/
    MACRO FaceValueDealDt()
       if( v_FaceValueDealDt == NULL )
          v_FaceValueDealDt = GetFaceValue( this.fininstr.rec.FIID, this.tick.rec.DealDate);
       end;
       return v_FaceValueDealDt;
    END;    

    MACRO FaceValueMoney()
       if( v_FaceValueMoney == NULL )
          v_FaceValueMoney = $0;
          if( FI_IsInvestmentShare(this.fininstr) == false ) /*у паев нет номинала*/
             FI_GetNominal( this.fininstr.rec.FIID, v_FaceValueMoney );
          end;
       end;
       return v_FaceValueMoney;
    END;    

    MACRO FaceValueOnSetAv()
       if( v_FaceValueOnSetAv == NULL )
          v_FaceValueOnSetAv = GetFaceValue( this.fininstr.rec.FIID, GetRealDealSetAvPlanDate(this.dl_leg.rec) );
       end;
       return v_FaceValueOnSetAv;
    END;    

    MACRO MarketGroupCode()
       if( v_MarketCode == NULL )
          if( this.tick.rec.MarketID > 0 )
             v_MarketCode = ПолучитьКодГруппыБиржи( this.tick.rec.MarketID );
          else
             v_MarketCode = "";
          end;
       end;
       return v_MarketCode;
    END;    

    MACRO ТипПортфеля()
       return this.tick.rec.PortfolioID;
    END;

    MACRO KindPortf()
       if( v_KindPortf == NULL )
          /*получаем тип портфеля сделки*/
          v_KindPortf = ТипПортфеля();
       end;
       return v_KindPortf;
    END;

    MACRO IsExistWrtSum()
       return (pmwrtsum.rec.DocID > 0);
    END;

    MACRO IsExistWrtSumContr()
       return (pmwrtsum_contr.rec.DocID > 0);
    END; 

    MACRO IsExistWrtSumCurr()
       return (pmwrtsum_curr.rec.DocID > 0);
    END; 

    MACRO ExistRqMoney()
       return this.ExistsRQ(DLRQ_TYPE_PAYMENT, IIF(this.IsBack, 2, 1));
    END;    

    MACRO ExistRqAvoir()
       return this.ExistsRQ(DLRQ_TYPE_DELIVERY, IIF(this.IsBack, 2, 1));
    END;

    MACRO ExistPC()
       return this.ExistsRQ(DLRQ_TYPE_INCREPO, 2);//(pmpc.rec.PaymentID > 0);
    END;

    MACRO ExistRqPayIncome()
       return this.ExistsRQ(DLRQ_TYPE_PAYINCOME, 1);
    END; 

    MACRO ExistAvance()
       if( IsEXCHANGE(this.Group) )
          return false;
       else
          return this.ExistsRQ(DLRQ_TYPE_AVANCE, IIF(this.IsBack, 2, 1));
       end;
    END;    

    MACRO ExistDeposit()
       if( IsEXCHANGE(this.Group) )
          return false;
       else
          return this.ExistsRQ(DLRQ_TYPE_DEPOSIT, IIF(this.IsBack, 2, 1));
       end;
    END;    

    /************************************************/
    /* инициализация массива параметров              */
    /************************************************/
    MACRO InitParmArray()
        ParmA.Size = 0;
    END;

    MACRO ExistFIRoleBArray( FI_Role )
        var i = 0;

        FI_Role = this.GetBasisFIRole( FI_Role, true );
        if( FI_Role != FIROLE_UNDEF ) 
           while( i < FIRoleBArray.Size )
              if( FIRoleBArray[i] == FI_Role )
                 return true;
              end;
              i = i + 1;   
           end;
        end;
        return false;
    END;

    MACRO InitFIRoleBArray()
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA;            /* базовый актив              */
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_CA;            /* контрактив                 */
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_CALC_BA;       /* ФИ учета базового актива   */
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_ACTIVE_OUTBAL; /* актив на внебалансе        */
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_SETTL_CONTR;   /* расчеты с контрагентом     */
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BAININVEST;
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BAINPROMISSORY;
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BAINCONTR;
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_RESERV_REQ;
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_COMISS_BROKER;
       
       if( this.tick.rec.BofficeKind == DL_CONVAVR ) 
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_BACK;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_TP;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_PPR;
       end;

       if( IsOUTEXCHANGE(this.Group) AND (this.tick.rec.IsPartyClient == SET_CHAR) ) 
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_SRCA;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_DSTA;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_CONTR;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_CA_CONTR;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_AVANCE_CONTR;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_COMISS_CONTR;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_REGTAX_CONTR;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_COMPENSDELIVERYCONTR; 
       end;

       FIRoleBArray[FIRoleBArray.Size] = FIROLE_SRCA; /*Исходный актив*/
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_DSTA; /*Целевой актив*/


       if( IsOUTEXCHANGE(this.Group) ) 
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_AVANCE;
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_REGTAX;
       end;

       if( IsClientDeal(this.tick.rec) )
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_COMISS_CLIENT;
       end;

       if( IsTwoPart(this.Group) )
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_COMPENSPAY; /*Компенсационный платеж*/
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_TP;  /*Базовый актив в ССПУ_ЦБ*/
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_PPR; /*Базовый актив в СССД_ЦБ*/
          if( not this.СделкаОРЦБ() )
             FIRoleBArray[FIRoleBArray.Size] = FIROLE_CALC_COUPON; /*Учет купона** (только не ОРЦБ)*/
             FIRoleBArray[FIRoleBArray.Size] = FIROLE_CALC_RETIRE; /*Учет частичного погашения** (только не ОРЦБ)*/
          end;
       end;

       /*продажи\погашения наших бумаг*/
       if( (not IsClientDeal(this.tick.rec)) AND 
           ( (this.tick.rec.BofficeKind == DL_AVRWRT) OR
             (this.ExistBack == true) OR
             ( (this.IsOperLOAN == true) AND this.IsBack ) OR
             IsSALE(this.Group) OR 
             IsRET_ISSUE(this.Group) OR 
             IsRET_COUPON(this.Group) OR 
             IsRET_PARTLY(this.Group) 
           ) 
         ) 

          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_RESALE; /*базовый актив для перепродажи*/
          FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_INVEST; /*базовый актив для инвестирования*/

          if( this.IsOperLOAN != true ) /*для займа - перекодировать в базовый актив*/
             FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_LOAN; /*Базовый актив в договорах займа*/
             FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_BACK; /*Базовый актив возврата в договорах займа*/
             FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_BACK_CONTR; /*Базовый актив  возврата  в договорах займа*/
          end;

          if( (this.ExistBack == true) OR (this.IsOperLOAN == true) )
             FIRoleBArray[FIRoleBArray.Size]  = FIROLE_BAININVEST; /*Базовый актив в ИП*/
             FIRoleBArray[FIRoleBArray.Size]  = FIROLE_BAINCONTR; /*-Базовый актив в ПКУ*/
             FIRoleBArray[FIRoleBArray.Size]  = FIROLE_BAINPROMISSORYSALE; /*Базовый актив для перепродажи в ПДО*/
             FIRoleBArray[FIRoleBArray.Size]  = FIROLE_BAINPROMISSORYINVEST; /* Базовый актив для инвестирования в ПДО*/
             FIRoleBArray[FIRoleBArray.Size]  = FIROLE_BAINPROMISSORY; /*Базовый актив в ПДО*/
          end;
          if( (this.ExistBack != true) OR (this.BuySale != DEAL_TYPE_SALE) ) 
             FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_REPO; /*Базовый актив в договорах обратной продажи*/
          end;
       end;

       FIRoleBArray[FIRoleBArray.Size] = FIROLE_CORACC_ACTIVE;
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_CORACC_PASSIVE;
 
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_PPR_TSS_YES;
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_PPR_TSS_NO;

       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_SSSD_BPP;         
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_SSSD_BPP_OVERDUE; 
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_SSPU_BPP;         
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_SSPU_BPP_OVERDUE; 
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_ASCB_BPP;         
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_ASCB_BPP_OVERDUE; 
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_CONTR_BPP;        
       FIRoleBArray[FIRoleBArray.Size] = FIROLE_BA_CONTR_BPP_OVERDUE;

    END;

    /*проверка - оплата сделки через корсчет*/
    macro ЧерезКорсчет()

      if( this.IsOperLOAN == true ) /*займ*/
         return true;
      elif( this.tick.rec.BofficeKind == DL_INVESTSHARE ) /*Паи*/
         return true;
      elif( IsBasket(this.Group) and IsOUTEXCHANGE(this.Group) ) /*корзина*/
         return false;
      elif( IsOUTEXCHANGE( this.Group ) and (not this.СделкаРЕПОБрокер()) )   /*для внебржи всегда через корсчет*/
         return true;
      elif( IsBROKER( this.Group ) or this.СделкаРЕПОБрокер() )/*для брокера проводок через корсчет нет*/
         return false;
      elif( IsEXCHANGE( this.Group ) )    /*для биржи. если сделка не ОРЦБ*/
         if( not this.СделкаОРЦБ() ) 
            return true;  
         end;
      end;
      return false;
    end;

   /* Проверяем, есть ли НКД по бумаге.
      Подходят купонные облигации, либо с бескупонные облигациями, по которым
      есть ненулевой доход.
         FI    -  ID финансового инструмента или буфер записи
         Avoir -  буфер бумаги, если не задан, то будет получен */
   macro IsAvoirWithNKD
      return   FI_IsBond(this.fininstr)
               and ( FI_IsCouponAvoiriss(this.fininstr)
                     or (this.avoiriss.rec.IncomeRate > 0)
                     or (this.avoiriss.rec.IncomeVolume > 0) );
   end;

    /* то, что сделка ПФИ */
    macro DealAsResultDVExe()
       return SP_DealAsResultDVExe( this.tick );
    end;

    /*определяем ведется ли внебалансовый учет по сделке*/
    MACRO ВедетсяВнебалУчетПоСделке()
       var  Dс, Dо, Dп, Dа, Dv;

       /*только в своих сделках*/
       if( IsClientDeal(this.tick.rec) )
          return false;
       end;

       if( DealAsResultDVExe() and this.tick.rec.OriginID == CodeFor("Ю"))
          return false;
       end;

       Dо  = this.DateArray[DATE_DEALPAY_PLAN]; 
       Dп  = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];
       Dа  = this.DateArray[DATE_DEALAVANCE_PLAN];

       if( this.IsBack ) /*во второй части*/
          Dс  = this.DateArray[DATE_DEALOUTBAL_2];
       else 
          Dс  = this.DateArray[DATE_DEALDATE];
       end;

       if( (Dс != Dп) AND (Dс != Dо) ) 
          if( this.ExistAvance == false )
             return true;  
          else
             if( Dс != Dа )/*если есть аванс - доп.проверка*/
                return true;  
             end;
          end;
       end;

       return false;
    END;

    /* Определяем, ведется ли балансовый учет по сделке. */
    MACRO ВедетсяБалансУчетПоСделке()
      var
         IsExch;

      /*IL 28.08.07 111810 в погашениях не ведется*/
      /* в РЕПО тоже не ведется */
      if( (this.tick.rec.BofficeKind == DL_RETIREMENT) or
          (this.tick.rec.BofficeKind == DL_RETIREMENT_OWN) or
          IsTwoPart(this.Group) ) 
         return false;
      end;

      /*проверки для сделок с ц/б ДУ */
      if( this.Kind == DL_TRUSTDOC ) 
         if( (this.ВидСрочностиСделки() != СделкаToday) OR (not this.СделкаОРЦБ())  )
            return true;
         else    
            return false;
         end;
      end;

      /* Не ведется в клиентских сделках. */
      if( IsClientDeal(tick.rec) )
         return false;
      end;

      /* Для займов и паев ведется. */
      if( (this.IsOperLoan == true) OR (this.tick.rec.BofficeKind == DL_INVESTSHARE) )
         return true;
      end;

      /* Не ведется, если сделка не является биржевой, не является
         внебиржевой и не является брокерской, кроме конвертации ц/б, по
         которым ведется. */
      IsExch = IsEXCHANGE( this.Group );
      if( not (IsExch or IsOUTEXCHANGE(this.Group) or IsBROKER(this.Group)) )
         if( tick.rec.BOfficeKind == DL_CONVAVR )
            return true;
         else
            return false;
         end;
      end;

      /* Ведется по второй части сделки и в не today сделках */
      if( this.IsBack or (this.ВидСрочностиСделки() != СделкаToday) )
         return true;
      end;

      //Биржевая ОРЦБ ИЛИ (настройка "Не использовать 47407/08 в сделках today" выключена) или не today
      if( (IsExch and this.СделкаОРЦБ) or (not GetOption_NotUse47407_08) )
         return true;
      end;

      /* В остальных случаях не ведется. */
      return false;
    END;

    /*Получить fiid выпуска если по лоту была глобальная операция*/
    MACRO GetNewFIID()
       var cmd, ds;

       if (v_NewFIID == null)
          cmd = RSDCommand("select t_FIID from dpmwrtsum_dbt where t_Source = ?");

          cmd.addParam( "", RSDBP_IN, this.pmwrtsum.rec.SumID );
          cmd.execute();

          ds = TRsbDataSet(cmd);
          if( ds.movenext() )
             v_NewFIID = ds.FIID;
          else
             v_NewFIID = CurPFI();
          end;
       end;

       return v_NewFIID;
    END;

    /*получить FIID ценной бумаги (базового актива)*/  
    MACRO GetBaseFIID()

       if (v_BaseFIID == null)
          v_BaseFIID = CurPFI();
       end;

       return v_BaseFIID;
    END;

    /*получить FIID валюты расчетов*/
    MACRO GetPayFIID()
       if( this.tick.rec.BofficeKind == DL_CONVAVR )
          return this.FaceFIID();
       else
          if( this.IsOperLoan == true ) /*в займе нет платежа контрактива */
             return this.pmpc.rec.FIID;
          else
             return this.dl_leg.rec.PayFIID;
          end;
       end;
    END;

    MACRO GetDetermineAccFIID()
          var cmd = DL_RSDCommand( "select RSB_PMWRTOFF.WRTDetermineAccFI(?) DetAccFI from dual" );
          cmd.AddParam(GetBaseFIID());
          var DataSet = cmd.Execute();
          if( DataSet.moveNext() )
            var tmpInt:INTEGER;
            tmpInt = SQL_ConvTypeInteger(DataSet.DetAccFI); 
            return tmpInt;
      end;

            return NATCUR;
    END;

    MACRO GetAccFIID(Categ:string)
       if(Categ == "Наш портфель ц/б")
          return GetDetermineAccFIID();
       elif((Categ == "Торговый счет") and ( this.tick.rec.BofficeKind == DL_RETIREMENT ))
          return GetPayFIID();
          end;

         return FaceFIID();
    END;

    PRIVATE MACRO КатегорияНашПортфельПКУ( Categ:string ):bool
       var RetVal:bool = false;
       if( Categ == "Наш портфель ПКУ, ц/б" )
          RetVal = true;
       end;
       return RetVal;
    END;

    MACRO ВалютаНоминалаПКУ( Categ:string ):integer
       var RetVal:integer = ALLFININSTR;
       if( КатегорияНашПортфельПКУ(Categ) )
          RetVal = NATCUR;
       else
          RetVal = GetAccFIID(Categ);
       end;
       return RetVal;
    END;

    /*получить плановую дату поставки ц/б*/
    MACRO GetAvoirissPlanDate( dl_leg )
       return SP_GetAvoirissPlanDate( dl_leg );
    END;

    /*получить плановую дату оплаты ц/б*/
    MACRO GetPayPlanDate( dl_leg )
       return SP_GetPayPlanDate( dl_leg );
    END;

    MACRO ОпределитьДатуКурсаОплаты()
       /* Дата курса оплаты*/
       if( (ПолучитьКодСубъекта( this.tick.rec.BrokerID, PTCK_CONTR ) == RTS_CODE)  OR
           ((ПолучитьКодСубъекта( this.tick.rec.MarketID, PTCK_CONTR ) == RTS_CODE) AND (this.ВидСрочностиСделки() != СделкаToday))
         )
          this.DateArray[DATE_DEALRATEPAY] = this.DateArray[DATE_DEALPAY] - 1;
       else
          this.DateArray[DATE_DEALRATEPAY] = this.DateArray[DATE_DEALPAY];
       end;
    end;

    /* Проверяем, что цена сделки задана в процентах. Возвращаем true, если
       это так. */
    macro IsRelatPrice()
       return IsRelativePrice( this.tick.rec, this.dl_leg.rec );
    end;

    /* Получить цену бумаги в валюте цены (Leg.CFI).
       Возвращаем double. Если цена задана в процентах, то она пересчитывается
       в реальную сумму. Для пересчета берется валюта номинала на дату
       поставки бумаг. Если задать флаг UseSourceNom, то для пересчета
       будет использован исходный номинал.
       NomDate - дата, на кот. будет взят номинал. */
    macro GetPrice( UseSourceNom, NomDate )
       return GetPriceByDlTickDlLeg( this.tick.rec, this.dl_leg.rec, UseSourceNom, null, NomDate );
    end;

    MACRO GetKindDate( KindDate )
       if( tick.rec.BofficeKind == DL_CONVAVR ) /*конвертация ц/б*/
          return KindDate;
       elif( this.IsBack == true )
          if(   KindDate == DATE_DEALSETAVOIRISS ) return DATE_DEALSETAVOIRISS_2;
          elif( KindDate == DATE_DEALPAY         ) return  DATE_DEALPAY_2;         
          elif( KindDate == DATE_DEALBEGINEXEC   ) return  DATE_DEALBEGINEXEC_2;   
          elif( KindDate == DATE_DEALEEND        ) return  DATE_DEALEEND_2;        
          elif( KindDate == DATE_DEALDEPOSIT     ) return  DATE_DEALDEPOSIT_2;     
          elif( KindDate == DATE_DEALAVANCE      ) return  DATE_DEALAVANCE_2;      
          elif( KindDate == DATE_DEALTRANSFER    ) return  DATE_DEALTRANSFER_2;
          elif( KindDate == DATE_DEALEXEC        ) return  DATE_DEALEXEC_2;
          elif( KindDate == DATE_DEALINSDEPODRAFT) return  DATE_DEALINSDEPODRAFT_2;
          else return KindDate;
          end;
       elif( (tick.rec.BofficeKind == DL_RETIREMENT) OR (tick.rec.BofficeKind == DL_TRUSTRETIREMENT) ) /*погашение*/
          if( IsRET_ISSUE(this.Group) )
             if( KindDate == DATE_DEALBEGINEXEC )
                return DATE_DEALPAY; /*Дата погашения*/
             end;
          else
             /*В погашениях нет даты оплаты в операции.
               Она всегда совпадает с датой поставки и начала исполнения*/
             if( (KindDate == DATE_DEALPAY) OR (KindDate == DATE_DEALBEGINEXEC) )
                return DATE_DEALSETAVOIRISS;         
             end;
          end;
          return KindDate;
       else
         return KindDate;
       end;
    END;

    PRIVATE MACRO ПолучитьСистемнуюДату( OperDates:TArray, KindDate:INTEGER )

       if( (this.BuySale == DEAL_TYPE_RET_PARTLY) OR (this.BuySale == DEAL_TYPE_RET_COUPON) )
          this.DateArray[KindDate] = this.tick.rec.DealDate;
       else
          this.DateArray[KindDate] = OperDates[ this.GetKindDate( KindDate ) ];
          if( this.DateArray[KindDate] == null )
             this.DateArray[KindDate] = Date(0,0,0);
          end;
       end;

    END;

   macro GetDealType()
     return tick.rec.Dealtype;
   end;

   macro ПолучитьКалендБиржа()
     return tick.rec.MarketId;
   end;

   macro ПолучитьКалендВалютуВидаДаты(НомерДаты):integer
     var dateNumber = НомерДаты;
     var idOpr,idStep,docKind,docId, rqId, prtNumb;
     if ((not DL_CheckCallFromStep()) and (ValType(dateNumber)!=V_INTEGER))
       return -2;
     end;
     if (ValType(dateNumber)!=V_INTEGER)
       DL_GetCalendCurOperStepData(docKind, idOpr, idStep, docId);
       dateNumber = DL_GetDateKindByOprID(idOpr,idStep);
     end;
     if (DL_Calend_SP_DateDefineIsObl(this.Kind, dateNumber, @rqId, @prtNumb))
       var rq = this.GetRQ(rqId, prtNumb, NULL, true);
       if (rq != NULL)
         return rq.rec.FIID;
       end;
     end;
     return -1;
   end;

    /* получить даты сделки:                                         
       ReCalcDate - если true, то пересчитываем даты по данным сделки 
                    иначе, берем из дат операции (если операция есть)
       CallInclude - вложенный вызов */
    MACRO ПолучитьДатыСделки( ReCalcDate, CallInclude, FD_another )
      var FD_2, FD_1, /*ПД по первой и второй части*/
          OperDates, rs:RsdRecordset, Querry:STRING, Error:STRING, Dk;

      if( (ReCalcDate != null) AND (ReCalcDate == true) )

         if( (this.tick.rec.BofficeKind == DL_SECURITYDOC) OR (this.tick.rec.BofficeKind == DL_SECUROWN) OR (this.tick.rec.BofficeKind == DL_TRUSTDOC) ) /*сделка с ценными бумагами*/

            /* Дата заключения сделки   */
            this.DateArray[DATE_DEALDATE]         =  this.tick.rec.DealDate;    

            /* Дата поставки ц/б - фактическая */
            if( IsBasket(this.Group) )
               this.DateArray[DATE_DEALSETAVOIRISS] =  this.pm_money.rec.ValueDate;
            else
               this.DateArray[DATE_DEALSETAVOIRISS]  =  this.pm_avoir.rec.ValueDate;  
            end;
            /* Дата поставки ц/б - плановая */
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = GetAvoirissPlanDate( this.dl_leg.rec );

            /* Дата оплаты - фактическая */
            if( this.IsOperLoan == true ) /*в займе нет платежа контрактива, дата нужна для совместимости с остальными сделками */
               this.DateArray[DATE_DEALPAY]          = this.DateArray[DATE_DEALSETAVOIRISS];
               /* Дата оплаты ц/б - плановая */
               this.DateArray[DATE_DEALPAY_PLAN]     = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];
            else
               this.DateArray[DATE_DEALPAY]          =  this.pm_money.rec.ValueDate;  
               /* Дата оплаты ц/б - плановая */
               this.DateArray[DATE_DEALPAY_PLAN]     = GetPayPlanDate( this.dl_leg.rec );
            end;
       
            /* Дата комиссии            */
            this.DateArray[DATE_DEALCOMISS]       =  this.tick.rec.CommDate;    

            if( IsTODAY(this.Group) )
               this.DateArray[DATE_DEALEEND]      = this.DateArray[DATE_DEALDATE];
            else
               /* Дата завершения сделки  - в процессе выполнения операции поле this.tick.rec.closeDate может быть   */
               /* инициализирована до реального завершения сделки для отбора сделки в расчете комиссий и т.д.        */
               this.DateArray[DATE_DEALEEND]         =  this.tick.rec.closeDate;
            end;
            /*даты оплаты %% займ */
            if( IsLOAN(this.Group) )
               this.DateArray[DATE_DEALPAY_PC]        = this.GetRQ(DLRQ_TYPE_INCREPO).rec.PlanDate;
            end;
            /*даты начала расчетов и аванса (фактическая и плановая) */
            if( this.ExistAvance )
               this.DateArray[DATE_DEALAVANCE]        = this.GetRQ(DLRQ_TYPE_AVANCE).rec.PlanDate;
               this.DateArray[DATE_DEALAVANCE_PLAN]   =  this.dl_leg.rec.Start;
               this.DateArray[DATE_DEALBEGINSETTLE]   = this.DateArray[DATE_DEALAVANCE];
               this.DateArray[DATE_DEALBEGINSETTLE_PLAN]= this.DateArray[DATE_DEALAVANCE_PLAN];
            else
               this.DateArray[DATE_DEALAVANCE]        = date(0,0,0);
               this.DateArray[DATE_DEALAVANCE_PLAN]   = date(0,0,0);
               this.DateArray[DATE_DEALBEGINSETTLE]   = this.DateArray[DATE_DEALPAY];
               this.DateArray[DATE_DEALBEGINSETTLE_PLAN]   = this.DateArray[DATE_DEALPAY_PLAN];
            end;
            /*дата задатка - фактическая и плановая*/
            if( this.ExistDeposit )
               this.DateArray[DATE_DEALDEPOSIT]       =  this.GetRQ(DLRQ_TYPE_DEPOSIT).rec.PlanDate;
               this.DateArray[DATE_DEALDEPOSIT_PLAN]  =  this.dl_leg.rec.Start;
            else
               this.DateArray[DATE_DEALDEPOSIT]       = date(0,0,0);
               this.DateArray[DATE_DEALDEPOSIT_PLAN]  = date(0,0,0);
            end;

            /* Дата начала исполнения (может называться еще и датой учета)  */
            this.DateArray[DATE_DEALBEGINEXEC]  = minDate( this.DateArray[DATE_DEALBEGINSETTLE], this.DateArray[DATE_DEALSETAVOIRISS] );
            Dk = this.GetMinComPlanDateByDeal();
            if (Dk != Date(0,0,0))
               this.DateArray[DATE_DEALBEGINEXEC]  = minDate( this.DateArray[DATE_DEALBEGINEXEC], Dk );
            end;
            this.DateArray[DATE_DEALBEGINEXEC_PLAN]  = minDate( this.DateArray[DATE_DEALBEGINSETTLE_PLAN], this.DateArray[DATE_DEALSETAVOIRISS_PLAN] );

            this.ОпределитьДатуКурсаОплаты();   

            if( IsBasket(this.Group) )
               this.DateArray[DATE_DEALEXEC] =  this.pm_money.rec.ValueDate;
            else
               this.DateArray[DATE_DEALEXEC]  =  this.pm_avoir.rec.ValueDate;
            end;

            if( (this.ExistBack == true) AND (CallInclude != true) )
               if( this.IsBack == false )
                  FD_1 = this;
                  if( FD_another == null )
                     FD_2 = SPFirstDoc( this.tick, true, true, null, true ); 
                  else
                     FD_2 = FD_another;
                  end;
               else
                  if( FD_another == null )
                     FD_1 = SPFirstDoc( this.tick, false, true, null, true ); 
                  else
                     FD_1 = FD_another;                  
                  end;
                  FD_2 = this;
               end;

               /*Дата начала второй части сделки. */
               this.DateArray[DATE_DEALBEGIN_2]  = ДатаНачалаВторойЧасти( FD_1, FD_2 );
               /*Дата постановки второй части на внебаланс.*/
               this.DateArray[DATE_DEALOUTBAL_2] = ДатаПостановкиНаВнебалансВторойЧасти( FD_1, FD_2 );

               /*для биржевых репо*/
               this.DateArray[DATE_DEALCLOSE]   = this.DateArray[DATE_DEALEEND];
            end;

         elif( (tick.rec.BofficeKind == DL_RETIREMENT) OR (tick.rec.BofficeKind == DL_TRUSTRETIREMENT) ) /*погашение*/
            /* Дата завершения погашения*/
            this.DateArray[DATE_DEALEEND] =  this.tick.rec.closeDate;
            /* Дата комиссии            */
            this.DateArray[DATE_DEALCOMISS] =  this.tick.rec.CommDate;    

            if( IsRET_ISSUE(this.Group) )
               /* Дата погашения*/
               this.DateArray[DATE_DEALDATE] =  this.tick.rec.DealDate;    
               /*Дата списания ц/б*/
               this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = GetAvoirissPlanDate( this.dl_leg.rec );
               this.DateArray[DATE_DEALSETAVOIRISS]      =  this.pm_avoir.rec.ValueDate;  

               /*Дата погашения ц/б*/
               this.DateArray[DATE_DEALPAY_PLAN] = GetPayPlanDate( this.dl_leg.rec );
               if( this.ExistRQMoney(DLRQ_TYPE_PAYMENT ))
                  this.DateArray[DATE_DEALPAY]      =  this.pm_money.rec.ValueDate;  
               else
                  this.DateArray[DATE_DEALPAY]      = this.tick.rec.DealDate;  
               end;
            else
               /* Дата погашения*/
               this.DateArray[DATE_DEALDATE] = this.tick.rec.DealDate;    
               /* Даты поставки\оплаты ц/б - фактические равны дате погашения - календарной дате*/
               this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = 
               this.DateArray[DATE_DEALSETAVOIRISS] = 
               this.DateArray[DATE_DEALPAY] = 
               this.DateArray[DATE_DEALPAY_PLAN] = this.DateArray[DATE_DEALDATE];      
            end;

         elif( tick.rec.BofficeKind == DL_RETIREMENT_OWN ) /*погашение СЭБ*/
            
            /* Дата начала операции*/
            this.DateArray[DATE_DEALDATE] = this.tick.rec.DealDate;
            /* Дата завершения операции*/
            this.DateArray[DATE_DEALEEND] =  this.tick.rec.closeDate;
            /* Дата переноса на счета "к исполнению"*/
            this.DateArray[DATE_DEALTRANSFER] = this.dl_leg.rec.MoveDate;
            /* Дата погашения план.*/
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = this.dl_leg.rec.Maturity;
            /* Дата погашения факт.*/
            this.DateArray[DATE_DEALSETAVOIRISS] = this.dl_leg.rec.Expiry;
            /* Дата платежа*/
            if(ДатаЯвляетсяПереходящейПогашОЭБ(this.dl_leg.rec.Expiry, this.ПолучитьКалендСвязанный()) == true)
              this.DateArray[DATE_DEALPAY] = this.DateArray[DATE_DEALPAY_PLAN] = this.DateArray[DATE_DEALSETAVOIRISS];
            else
              this.DateArray[DATE_DEALPAY] = this.DateArray[DATE_DEALPAY_PLAN] = this.DateArray[DATE_DEALTRANSFER];
            end;

         elif( tick.rec.BofficeKind == DL_CONVAVR ) /*конвертация*/
            if( CallInclude != true )
               if( this.IsBack == false )
                  FD_1 = this;
                  FD_2 = SPFirstDoc( this.tick, true, true, null, true ); 
               else
                  FD_1 = SPFirstDoc( this.tick, false, true, null, true ); 
                  FD_2 = this;
               end;

               this.DateArray[DATE_CONVAVR_OUT] =  FD_1.pm_avoir.rec.ValueDate;    
               this.DateArray[DATE_CONVAVR_IN]  =  FD_2.pm_avoir.rec.ValueDate;    
            end;
            this.DateArray[DATE_CONVAVR_BEGIN] =  this.tick.rec.DealDate;    
            this.DateArray[DATE_CONVAVR_END]   =  this.tick.rec.closeDate;    

            /*для совместимости со сделками*/
            this.DateArray[DATE_DEALDATE] = this.DateArray[DATE_CONVAVR_BEGIN];
            this.DateArray[DATE_DEALEEND] = this.DateArray[DATE_CONVAVR_END];
            if( this.IsBack == false ) /*списание*/
               this.DateArray[DATE_DEALSETAVOIRISS] = this.DateArray[DATE_CONVAVR_OUT];
               this.DateArray[DATE_DEALPAY]         = this.DateArray[DATE_CONVAVR_OUT];
            else
               this.DateArray[DATE_DEALSETAVOIRISS] = this.DateArray[DATE_CONVAVR_IN];
               this.DateArray[DATE_DEALPAY]         = this.DateArray[DATE_CONVAVR_IN];
            end;
         elif( (tick.rec.BofficeKind == DL_AVRWRT) OR (tick.rec.BofficeKind == DL_TRUSTAVRWRT) ) /*Списание/зачисление ц/б*/
            /*Нужно для использования в отчетах для совместимости с остальными сделками
              На операцию (по AltD) эти даты не навешены*/
            this.DateArray[DATE_DEALDATE]        = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALEEND]        = this.tick.rec.closeDate;
            this.DateArray[DATE_DEALSETAVOIRISS] = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALPAY]         = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALPAY_PLAN]         = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALBEGINEXEC]        = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALBEGINEXEC_PLAN]   = this.tick.rec.DealDate;
         elif( tick.rec.BofficeKind == DL_INVESTSHARE ) /*Паи*/
            /* Дата заключения сделки   */
            this.DateArray[DATE_DEALDATE]         =  this.tick.rec.DealDate;    
            /* Дата поставки ц/б - фактическая */
            this.DateArray[DATE_DEALSETAVOIRISS]  =  this.pm_avoir.rec.ValueDate;  
            /* Дата поставки ц/б - плановая */
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = GetAvoirissPlanDate( this.dl_leg.rec );
            /* Дата оплаты ц/б - фактическая*/
            this.DateArray[DATE_DEALPAY]          =  this.pm_money.rec.ValueDate;  
            /* Дата оплаты ц/б - плановая */
            this.DateArray[DATE_DEALPAY_PLAN]     = GetPayPlanDate( this.dl_leg.rec );
            /* Дата комиссии            */
            this.DateArray[DATE_DEALCOMISS]       =  this.tick.rec.CommDate;    
            /* Дата завершения сделки  - в процессе выполнения операции поле this.tick.rec.closeDate может быть   */
            /* инициализирована до реального завершения сделки для отбора сделки в расчете комиссий и т.д.        */
            this.DateArray[DATE_DEALEEND]         =  this.tick.rec.closeDate;
            /* Дата определения араметров - цепочка определения параметров выполняется только если выполнена оплата*/
            this.DateArray[DATE_DEALBEGINEXEC]      = this.DateArray[DATE_DEALPAY];
            this.DateArray[DATE_DEALBEGINEXEC_PLAN] = this.DateArray[DATE_DEALPAY_PLAN];
            this.DateArray[DATE_DEALRATEPAY] = this.DateArray[DATE_DEALPAY];
         end;
         
      else /*получим даты из системных дат операции*/

         Querry =
         " SELECT oprkdate.t_NumberDate, oprdates.t_Date" +
         " FROM   doprkdate_dbt oprkdate, doprdates_dbt oprdates, doproper_dbt oproper" +
         " WHERE " +  
              "oproper.t_DocKind       = ? AND " + // + this.tick.rec.BofficeKind            +" AND " +
              "oproper.t_DocumentID    = ? AND " + //+ UniID( this.tick, OBJTYPE_SECDEAL )  + "' AND " +
              "oprkdate.t_DocKind      = oproper.t_DocKind     AND " +
              "oprkdate.t_DateKindID   = oprdates.t_DateKindID AND " +
              "oprdates.t_ID_Operation = oproper.t_ID_Operation";

         var sql = RSDCommand(Querry);
         sql.addParam( "", RSDBP_IN, (this.tick.rec.BofficeKind) );
         sql.addParam( "", RSDBP_IN, (UniID( this.tick, OBJTYPE_SECDEAL )) );
         sql.execute();                                 
                                                   
         rs = RsdRecordset(sql);                    
         //rs = ExecuteSQLCommand( Querry, "Определение дат по сделке.", @Error );
         if( rs == NULL )
            this.SetError( "Ошибка при выполнении запроса"); //   Error ); /*Ошибка при выполнении запроса*/
         end;
               
         OperDates = TArray();
         while( rs.moveNext() )
            if( rs.value(0) >= 0 ) /*Отсеч даты цепочек*/
               OperDates[rs.value(0)] = ConvertSQLDate( rs.value(1) );
            end;
         end;

         if( (tick.rec.BofficeKind == DL_SECURITYDOC) OR (tick.rec.BofficeKind == DL_SECUROWN) OR (tick.rec.BofficeKind == DL_TRUSTDOC) ) /*сделка с ценными бумагами*/
            /* Дата заключения сделки   */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALTRANSFER);
            ПолучитьСистемнуюДату( OperDates, DATE_DEALDATE);
            /* Дата поставки ц/б - фактическая */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALSETAVOIRISS);
            /* Дата поставки ц/б - плановая */
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = this.GetAvoirissPlanDate( this.dl_leg.rec );

            if( this.IsOperLoan == true ) /*в займе нет платежа контрактива, дата нужна для совместимости с остальными сделками */
               this.DateArray[DATE_DEALPAY]          = this.DateArray[DATE_DEALSETAVOIRISS];
               /* Дата оплаты ц/б - плановая */
               this.DateArray[DATE_DEALPAY_PLAN]     = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];
            else 
               /* Дата оплаты - фактическая */
               ПолучитьСистемнуюДату( OperDates, DATE_DEALPAY);
               /* Дата оплаты ц/б - плановая */
               this.DateArray[DATE_DEALPAY_PLAN]     = this.GetPayPlanDate( this.dl_leg.rec );      
            end;

            /* Дата комиссии            */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALCOMISS);
            /* Дата завершения сделки */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALEEND);
            this.DateArray[DATE_DEALCLOSE] =  this.DateArray[DATE_DEALEEND];

            /*даты начала расчетов и аванса (фактическая и плановая) */
            if( this.ExistAvance )
               ПолучитьСистемнуюДату( OperDates, DATE_DEALAVANCE);
               this.DateArray[DATE_DEALAVANCE_PLAN]   =  this.dl_leg.rec.Start;
               this.DateArray[DATE_DEALBEGINSETTLE]   = this.DateArray[DATE_DEALAVANCE];
               this.DateArray[DATE_DEALBEGINSETTLE_PLAN]= this.DateArray[DATE_DEALAVANCE_PLAN];
            else
               this.DateArray[DATE_DEALAVANCE]        = date(0,0,0);
               this.DateArray[DATE_DEALAVANCE_PLAN]   = date(0,0,0);
               this.DateArray[DATE_DEALBEGINSETTLE]   = this.DateArray[DATE_DEALPAY];
               this.DateArray[DATE_DEALBEGINSETTLE_PLAN]= this.DateArray[DATE_DEALPAY_PLAN];
            end;
            /*дата задатка - фактическая и плановая*/
            if( this.ExistDeposit )
               ПолучитьСистемнуюДату( OperDates, DATE_DEALDEPOSIT);
               this.DateArray[DATE_DEALDEPOSIT_PLAN]  =  this.dl_leg.rec.Start;
            else
               this.DateArray[DATE_DEALDEPOSIT]       = date(0,0,0);
               this.DateArray[DATE_DEALDEPOSIT_PLAN]  = date(0,0,0);
            end;
            /* Дата начала исполнения (может называться еще и датой учета)  */
            if( this.IsOperLoan == true ) /*в займе нет платежа контрактива, дата нужна для совместимости с остальными сделками */
               this.DateArray[DATE_DEALBEGINEXEC]       = this.DateArray[DATE_DEALSETAVOIRISS];
               this.DateArray[DATE_DEALBEGINEXEC_PLAN]  = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];
            else
               ПолучитьСистемнуюДату( OperDates, DATE_DEALBEGINEXEC);
               this.DateArray[DATE_DEALBEGINEXEC_PLAN]  = minDate( this.DateArray[DATE_DEALBEGINSETTLE_PLAN], this.DateArray[DATE_DEALSETAVOIRISS_PLAN] );
            end;

            this.ОпределитьДатуКурсаОплаты();

            /*дата начала второй части сделки*/
            ПолучитьСистемнуюДату( OperDates,  DATE_DEALBEGIN_2 );
            ПолучитьСистемнуюДату( OperDates,  DATE_DEALOUTBAL_2 );

         elif( (tick.rec.BofficeKind == DL_RETIREMENT) OR (tick.rec.BofficeKind == DL_TRUSTRETIREMENT) ) /*погашение*/
            /* Дата погашения*/
            ПолучитьСистемнуюДату( OperDates, DATE_DEALDATE);
            /* Даты поставки\оплаты ц/б - фактические равны дате погашения*/
            ПолучитьСистемнуюДату( OperDates, DATE_DEALSETAVOIRISS);
            /* Даты поставки\оплаты ц/б - фактические равны дате погашения*/
            ПолучитьСистемнуюДату( OperDates, DATE_DEALPAY);
            /* Дата завершения погашения*/
            ПолучитьСистемнуюДату( OperDates, DATE_DEALEEND);
            /* Дата комиссии            */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALCOMISS);

            if( IsRET_ISSUE(this.Group) )
               this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = GetAvoirissPlanDate( this.dl_leg.rec );
               this.DateArray[DATE_DEALPAY_PLAN] = GetPayPlanDate( this.dl_leg.rec );
            else
               this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = 
               this.DateArray[DATE_DEALPAY_PLAN] = this.DateArray[DATE_DEALDATE];      
            end;

         elif( tick.rec.BofficeKind == DL_CONVAVR ) /*конвертация ц/б*/
            ПолучитьСистемнуюДату( OperDates, DATE_CONVAVR_BEGIN);
            ПолучитьСистемнуюДату( OperDates, DATE_CONVAVR_OUT);
            ПолучитьСистемнуюДату( OperDates, DATE_CONVAVR_IN);
            ПолучитьСистемнуюДату( OperDates, DATE_CONVAVR_END);

            /*для совместимости со сделками*/
            this.DateArray[DATE_DEALDATE] = this.DateArray[DATE_CONVAVR_BEGIN];
            this.DateArray[DATE_DEALEEND] = this.DateArray[DATE_CONVAVR_END];
            if( this.IsBack == false ) /*списание*/
               this.DateArray[DATE_DEALSETAVOIRISS] = this.DateArray[DATE_CONVAVR_OUT];
               this.DateArray[DATE_DEALPAY]         = this.DateArray[DATE_CONVAVR_OUT];
            else
               this.DateArray[DATE_DEALSETAVOIRISS] = this.DateArray[DATE_CONVAVR_IN];
               this.DateArray[DATE_DEALPAY]         = this.DateArray[DATE_CONVAVR_IN];
            end;
         elif( (tick.rec.BofficeKind == DL_AVRWRT) OR (tick.rec.BofficeKind == DL_TRUSTAVRWRT) ) /*Списание/зачисление ц/б*/
            /*Нужно для использования в отчетах для совместимости с остальными сделками
              На операцию (по AltD) эти даты не навешены*/
            this.DateArray[DATE_DEALDATE]        = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALEEND]        = this.tick.rec.CloseDate;
            this.DateArray[DATE_DEALSETAVOIRISS] = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALPAY]         = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALPAY_PLAN]         = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALBEGINEXEC]        = this.tick.rec.DealDate;
            this.DateArray[DATE_DEALBEGINEXEC_PLAN]   = this.tick.rec.DealDate;

         elif( tick.rec.BofficeKind == DL_RETIREMENT_OWN ) /*погашение СЭБ*/
            
            /* Дата начала операции*/
            this.DateArray[DATE_DEALDATE] = this.tick.rec.DealDate;
            /* Дата завершения операции*/
            this.DateArray[DATE_DEALEEND] =  this.tick.rec.closeDate;
            /* Дата переноса на счета "к исполнению"*/
            this.DateArray[DATE_DEALTRANSFER] = this.dl_leg.rec.MoveDate;
            /* Дата погашения план.*/
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = this.dl_leg.rec.Maturity;
            /* Дата погашения факт.*/
            this.DateArray[DATE_DEALSETAVOIRISS] = this.dl_leg.rec.Expiry;
            /* Дата платежа*/
            this.DateArray[DATE_DEALPAY] = this.DateArray[DATE_DEALPAY_PLAN] = this.DateArray[DATE_DEALTRANSFER];

         elif( tick.rec.BofficeKind == DL_INVESTSHARE ) /*Паи*/
            /* Дата заключения сделки   */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALDATE);
            /* Дата поставки ц/б - фактическая */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALSETAVOIRISS);
            /* Дата поставки ц/б - плановая */
            this.DateArray[DATE_DEALSETAVOIRISS_PLAN] = this.GetAvoirissPlanDate( this.dl_leg.rec );
            /* Дата оплаты - фактическая */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALPAY);
            /* Дата оплаты ц/б - плановая */
            this.DateArray[DATE_DEALPAY_PLAN]     = this.GetPayPlanDate( this.dl_leg.rec );      
            /* Дата комиссии            */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALCOMISS);
            /* Дата завершения сделки */
            ПолучитьСистемнуюДату( OperDates, DATE_DEALEEND);
            /* Дата определения араметров - цепочка определения параметров выполняется только если выполнена оплата*/
            ПолучитьСистемнуюДату( OperDates, DATE_DEALBEGINEXEC);
            this.DateArray[DATE_DEALBEGINEXEC_PLAN]  = this.DateArray[DATE_DEALPAY_PLAN];
            this.DateArray[DATE_DEALRATEPAY] = this.DateArray[DATE_DEALPAY];
         end;
      end;      
      return 0;
    END;

    PRIVATE MACRO ТорговаяПлощадка( PartyKind:@INTEGER )
      if( this.tick.rec.TraderID > 0 )
         PartyKind = 46/*PTK_RC_ORCB*/;
         return this.tick.rec.TraderID
      else
         /*AEA*/
         if((IsRET_COUPON(this.Group)) OR (IsRET_PARTLY(this.Group)) OR (IsRET_ISSUE(this.Group)))
            if( (this.FaceFIID() == NATCUR) and (this.tick.rec.partyid == 4) )
               return this.tick.rec.partyid; 
            end;
            if( (this.FaceFIID() != NATCUR) and (this.tick.rec.partyid == 4) )
               return this.tick.rec.partyid; 
            end;
         end;
         /********/
         return -1;
      end;
    end;

    PRIVATE MACRO GetDepositID(DepSetID:integer)
       var query, sql, DataSet;

       query = "Select DepSet.t_Depositary " +       
               "  From ddlDepSet_dbt DepSet ";

       if( DepSetID > 0  ) 
          query = query + " Where DepSet.t_depsetid  = ? ";
          sql = RSDCommand(query);
          sql.addParam( "", RSDBP_IN, DepSetID );
       elif( GetMarketSchemeID() > 0 )
          query =  query + ", ddlmarket_dbt market " +
                           " where market.t_id = ? " + 
                           "   and market.t_depsetid = DepSet.t_depsetid";
          sql = RSDCommand(query);
          sql.addParam( "", RSDBP_IN, GetMarketSchemeID() );
       else
          return -1;
       end;

       sql.execute();                                 
                                                   
       DataSet = TRsbDataSet(sql);                    
                                                   
       if(DataSet.MoveNext())
          return DataSet.Depositary;               
       end;                                           

       return -1;
    end;

    MACRO МестоХранения( FiRole, NoMsgErr )
       var rq    = TRecHandler("dlrq.dbt");
       var rqacc = TRecHandler("dlrqacc");

       var  Place    = -1, DlRq_Type = -1;

       if( (FiRole == FIROLE_BA) or (FiRole == FIROLE_BA_BACK) or (FiRole == FIROLE_BA_CONTR) )
          DlRq_Type = DLRQ_TYPE_DELIVERY;

       elif( (FiRole == FIROLE_AVANCE) OR (FiRole ==  FIROLE_AVANCE_CONTR) )
          DlRq_Type = DLRQ_TYPE_AVANCE;
          if(this.ExistDeposit())
            DlRq_Type = DLRQ_TYPE_DEPOSIT;
          end;

       elif( (FiRole == FIROLE_REGTAX) or (FiRole == FIROLE_REGTAX_CONTR) or (FiRole == FIROLE_REGTAX2) or (FiRole == FIROLE_REGTAX2_CONTR))
          DlRq_Type = DLRQ_TYPE_COMISS;

       elif( (FiRole == FIROLE_CA) or (FiRole == FIROLE_CA_CONTR) )
          DlRq_Type = DLRQ_TYPE_PAYMENT;

       elif( (FiRole == FIROLE_PERC) or (FiRole == FIROLE_PERCENT_CONTR) )
          DlRq_Type = DLRQ_TYPE_INCREPO;

       elif( (FiRole == FIROLE_CALC_COUPON) or (FiRole == FIROLE_NKD) or (FiRole == FIROLE_NKD_CONTR) )
          DlRq_Type = DLRQ_TYPE_PAYMREPOCOUP;

       elif( FiRole == FIROLE_CALC_RETIRE )
          DlRq_Type = DLRQ_TYPE_PAYMREPOPART;

       elif( FiRole == FIROLE_COMPENSPAY )
          DlRq_Type = DLRQ_TYPE_COMPPAYM;

       elif( (FiRole == FIROLE_COMISS_BROKER) or (FiRole == FIROLE_COMISS_BROKER_CONTR) or (FiRole == FIROLE_COMISS_CONTR) or (FiRole == FIROLE_COMISS_CLIENT) )
          DlRq_Type = DLRQ_TYPE_COMISS;

       elif ( (FiRole == FIROLE_COMPENSDELIVERY) or (FiRole == FIROLE_COMPENSDELIVERYCONTR) )
          DlRq_Type = DLRQ_TYPE_COMPDELIVERY;
       end;

       if( DlRq_Type > -1 )

          if( DlRq_Type == DLRQ_TYPE_COMISS)
             if( DlComis.rec.ID > 0 )
                rq = this.GetRQByCom(DlComis.rec.ID,true);
    
                if( rq.rec.ID <= 0 )

                   if( ПолучитПлатежныеРеквизитыПоТО(rq, rqacc) == 0 )
                      if( rqacc.rec.BANKCORRID > 0 )
                         rq.rec.PlaceID = rqacc.rec.BANKCORRID;
                      else
                         rq.rec.PlaceID = rqacc.rec.BANKID;
                      end;
                   end;
                   
                end;
             
             end;
          else
             rq = this.GetRQ(DlRq_Type, NULL, NULL, NoMsgErr);
          end;

          if( rq != NULL )
             Place = rq.rec.PlaceID;
          end;
       end;                            
             Place = {ourbank};
       return Place;     
    END;    

    private macro ПроверитьРольФИДляКонтрагента( FIRole )
      if( ( FIRole == FIROLE_BA_CONTR) OR
          ( FIRole == FIROLE_CA_CONTR) OR
          ( FIRole == FIROLE_AVANCE_CONTR) OR
          ( FIRole == FIROLE_COMISS_CONTR) OR
          ( FIRole == FIROLE_COMISS_BROKER_CONTR) OR
          ( FIRole == FIROLE_REGTAX_CONTR) OR
          ( FIRole == FIROLE_REGTAX2_CONTR) OR  
          ( FIRole == FIROLE_COMPENSDELIVERYCONTR)                          
        )
         return true;
      else
         return false;
      end;
    end;

    /*Получить НЕкэшируемый параметр (меняющийся в зависимости от контекста вызова GetParametr())*/
    /* например для разных FIRole */
    PRIVATE MACRO GetNonCacheParametr( ParmKind, OperDate, CatCode, FIRole )

       VAR Parametr = null, _FD;
       if( ParmKind == MC_TYPE_PARAMETR_PAYCURRENCY )
         if ((CatCode == "+Форвард, прочие") OR (CatCode == "-Форвард, прочие"))
           if( FIRole == FIROLE_CA ) /*контрактив*/
             Parametr = this.GetPayFIID(); 
           else
             Parametr = this.FaceFIID(); /*базовый актив*/
           end; 
         end;
       elif( ParmKind == MC_TYPE_PARAMETR_CURRENCY )
         Parametr = GetAccFIID(CatCode);
       elif( ParmKind == MC_TYPE_PARAMETR_FIID )
          if( FIRole == FIROLE_CA ) /*контрактив*/
             Parametr = this.GetPayFIID(); 
          elif( FIRole == FIROLE_CALC_BA ) /*ФИ учета базового актива*/
             Parametr = this.FaceFIID();
          elif( FIRole == FIROLE_BA_BACK )
             if( this.IsBack )
                Parametr = this.GetBaseFIID(); /*базовый актив*/
             else
                Parametr = CurPFI();
             end;
          elif( (FIRole == FIROLE_OVERVALUE_SRCA) or (FIRole == FIROLE_OVERVALUE_SRCA_COM) ) /*Переоценка рублёвых Т/О валютных сделок - валюта = ВЦ из сделки */
             Parametr = this.dl_leg.rec.CFI;
          elif( (FIRole == FIROLE_CORACC_ACTIVE) or (FIRole == FIROLE_CORACC_PASSIVE) )
             Parametr = this.GetFIIDForCorAccNum();
          else
             Parametr = this.GetBaseFIID(); /*базовый актив*/
          end;
          if ((this.kind == DL_RETIREMENT) and ((CatCode == "+ПереоценкаА") or (CatCode == "-ПереоценкаА")))
             Parametr = this.FaceFIID();
          end;
          if ((CatCode == "+Форвард, прочие") OR (CatCode == "-Форвард, прочие"))
             Parametr = this.GetBaseFIID();
          end;
       elif( ParmKind == MC_TYPE_PARAMETR_BEGDATE )
          if( BegDate != NULL )
             Parametr = BegDate;
          elif( (CatCode == "-ОД") or (CatCode == "-ОД, Корзина") or (CatCode == "+ОД") or (CatCode == "+ОД, Корзина") )
             _FD = SPFirstDoc(this.tick, not this.IsBack, false, null, true);
             _FD.SetCurPFI(CurPFI());
             if( this.IsBack )
                SC_GetDateOD(CatCode, _FD, this, @Parametr, NULL);
             else
                _FD.BeforeProlong = this.BeforeProlong;
                SC_GetDateOD(CatCode, this, _FD, @Parametr, NULL);
             end;
          elif(CatCode == "Размещ. ОЭБ")
             if (this.avoiriss.rec.begplacementdate  > this.fininstr.rec.Issued)        
               Parametr =  this.avoiriss.rec.begplacementdate;
             else
               Parametr =  this.fininstr.rec.Issued;
             end;
          elif((CatCode == "Премия, ОЭБ") or (CatCode == "Дисконт, ОЭБ"))
             if (this.avoiriss.rec.begplacementdate  > this.fininstr.rec.Issued)        
               Parametr =  this.avoiriss.rec.begplacementdate;
             else
             Parametr =  this.fininstr.rec.Issued;
             end;
          else
             Parametr = this.tick.rec.DealDate;
          end;

       elif( ParmKind == MC_TYPE_PARAMETR_FINDATE)/* дата базовая*/
          if( FinDate != NULL )
             Parametr = FinDate;

          elif( (CatCode == "-ОД") or (CatCode == "-ОД, Корзина") or (CatCode == "+ОД") or (CatCode == "+ОД, Корзина") )
             _FD = SPFirstDoc(this.tick, not this.IsBack, false, null, true);
             _FD.SetCurPFI(CurPFI());
             if( this.IsBack )
                SC_GetDateOD(CatCode, _FD, this, NULL, @Parametr);
             else
                _FD.BeforeProlong = this.BeforeProlong;
                SC_GetDateOD(CatCode, this, _FD, NULL, @Parametr);
             end;
          elif((CatCode == "Размещ. ОЭБ") or (CatCode == "Премия, ОЭБ") or (CatCode == "Дисконт, ОЭБ"))
             Parametr =  this.fininstr.rec.DrawingDate;
          elif ( (CatCode == "+Форвард, дрейф") or (CatCode == "-Форвард, дрейф") )
             var ObjectID = UniID(this.tick, OBJTYPE_SECDEAL);  
             var notetxt = readNoteForObject(OBJTYPE_SECDEAL, ObjectID, NOTEKIND_SECDEAL_EXEC_DAYS);
             if (notetxt > 0)
               Parametr = GetDateAfterWorkDays(tick.rec.DealDate, notetxt, this.ПолучитьКалендСвязанный()); 
             else
                if( FIRole == FIROLE_BA ) /*базовый актив*/
                   Parametr = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];
                elif( FIRole == FIROLE_CA ) /*контрактив*/
                   Parametr = this.DateArray[DATE_DEALPAY_PLAN];
                end;
             end;
          else
             if( FIRole == FIROLE_BA ) /*базовый актив*/
                if ((CatCode == "Размещ. ОЭБ") or (CatCode == "Премия, ОЭБ"))
                   Parametr = this.fininstr().rec.DrawingDate;
                else
                   Parametr = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];
                end;
             elif( FIRole == FIROLE_CA ) /*контрактив*/
                Parametr = this.DateArray[DATE_DEALPAY_PLAN];
             end;
          end;
       /*контрагент*/ 
       elif( ParmKind == MC_TYPE_PARAMETR_CONTRACTOR )
          if (FIRole == FIROLE_EMIT_INC_TR)
             Parametr = this.fininstr.rec.Issuer;
          elif ( FIRole == FIROLE_CUR_CONTRAGENT )
             Parametr = getCurContrAgent();
             if ( Parametr <= 0 )
                MsgBox( "set CurContrAgent by setCurContrAgent" );
             end;
          elif (FIRole == FIROLE_EMIT_INC_OB)
             Parametr = this.tick.rec.PartyID;
             if( (Parametr < 0) AND IsEXCHANGE( this.Group ) )
                Parametr = this.tick.rec.MarketID;
             end;
          /* IL 25.05.04 если посредник не задан во внебиржевой сделке, открывать счет Расчеты на контрагента*/
          elif( ((FIRole == FIROLE_SETTL_CONTR) OR (FIRole == FIROLE_SETTL_AGENT)) AND (this.tick.rec.BrokerID > 0) ) 
             Parametr = this.tick.rec.BrokerID;
          elif( FIRole == FIROLE_COMISS_CLIENT )
             Parametr = this.tick.rec.ClientID;
          else
             if(this.tick.rec.BOfficeKind == DL_RETIREMENT_OWN)
               Parametr = SP_GetPayAgentOwn(this.dl_leg.rec.PFI);
             else
               if( IsRET_ISSUE( this.Group ) and (this.tick.rec.BrokerID > 0))
                  Parametr = this.tick.rec.BrokerID;
               else
                  Parametr = this.tick.rec.PartyID;
                  if( (Parametr < 0) AND IsEXCHANGE( this.Group ) )
                     Parametr = this.tick.rec.MarketID;
                  end;
               end;
             end;
          end;

       /*владелец*/
       elif( ParmKind == MC_TYPE_PARAMETR_OWNER ) 
          if( (FIRole == FIROLE_BA_CONTR) OR 
              (FIRole == FIROLE_CA_CONTR) OR 
              (FIRole == FIROLE_SRCA) OR 
              (FIRole == FIROLE_DSTA) OR 
              (FIRole == FIROLE_COMISS_CONTR) OR 
              (FIRole == FIROLE_COMISS_BROKER_CONTR) OR
              (FIRole == FIROLE_REGTAX_CONTR) OR 
              (FIRole == FIROLE_COMPENSDELIVERYCONTR) OR
              (FIRole == FIROLE_REGTAX2_CONTR)) 
             Parametr = this.tick.rec.PartyID;
          else
             if( IsClientDeal(tick.rec) )
                Parametr = this.tick.rec.ClientID;
             else
                Parametr = {OurBank};
             end;
          end;
       /*место хранения*/
       elif( ParmKind == MC_TYPE_PARAMETR_PLACE )
          Parametr = this.МестоХранения(FIRole);
       /*организатор торговли*/
       elif( ParmKind == MC_TYPE_PARAMETR_MARKET_PLACE )
          if( (this.Kind == DL_TRUSTDOC) OR (this.Kind == DL_TRUSTAVRWRT) OR (this.Kind == DL_TRUSTRETIREMENT)) /*ДУ*/
             Parametr = this.МестоХранения(FIRole);
          else
          /*для "ДС Клиента, ВУ" Торг Площадку и Сектор заполняем для опред ролей в биржевых или ОРЦБ*/
             if( ( CatCode == "ДС Клиента, ВУ" ) AND
                 (
                   (( (IsEXCHANGE( this.Group ) and (not this.СделкаРЕПОБрокер())) or this.СделкаОРЦБ() ) AND 
                   (FiRole != FIROLE_CA) and (FiRole != FIROLE_COMISS_BROKER) and (FiRole != FIROLE_COMISS_BROKER_CONTR) and (FiRole != FIROLE_COMPENSPAY)) OR
                   ( not IsEXCHANGE( this.Group ) or this.СделкаРЕПОБрокер() or (not this.СделкаОРЦБ()) )
                 )
               )
                Parametr = 0;
             elif( IsBasket(this.Group) )
                Parametr = this.dl_leg.rec.Registrar;
             else
                Parametr = ТорговаяПлощадка( NULL );            
             end;
          end;
       /*сектор организатора торговли*/
       elif( ParmKind == MC_TYPE_PARAMETR_MARKET_PLACE_OFFICE )
          if( IsBasket(this.Group) )
             var OfficeID = -1;
             var Sql = RSDCommand(" select t_officeid " +
                                  "   from dptoffice_dbt " +
                                  "  where t_partyid = ? " +
                                  "    and t_officecode = ? ");
             Sql.addParam( "", RSDBP_IN, this.dl_leg.rec.Registrar );
             Sql.addParam( "", RSDBP_IN, BASKET_OFFICE_CODE );
             Sql.execute();
             var SqlSet = TRsbDataSet(Sql);

             if( SqlSet.movenext() )
                Parametr = SQL_ConvTypeInteger(SqlSet.officeid);
             end;
          else
             if( (this.Kind == DL_TRUSTDOC) OR (this.Kind == DL_TRUSTAVRWRT) OR (this.Kind == DL_TRUSTRETIREMENT)) /*ДУ*/
                if( IsEXCHANGE( this.Group ) )
                   Parametr = this.tick.rec.MarketOfficeID;
                else
                   Parametr = 0;            
                end;
             else
                /*для "ДС Клиента, ВУ" Торг Площадку и Сектор заполняем для опред ролей в биржевых или ОРЦБ*/
                if( ( CatCode == "ДС Клиента, ВУ" ) AND
                    (
                      (( (IsEXCHANGE( this.Group ) and (not this.СделкаРЕПОБрокер())) or this.СделкаОРЦБ() ) AND 
                      (FiRole != FIROLE_CA) and (FiRole != FIROLE_COMISS_BROKER) and (FiRole != FIROLE_COMISS_BROKER_CONTR) and (FiRole != FIROLE_COMPENSPAY)) OR
                      ( not IsEXCHANGE( this.Group ) or this.СделкаРЕПОБрокер() or (not this.СделкаОРЦБ()) )
                    )
                  )
                   Parametr = 0;
                /*AEA*/
                elif( ( (CatCode == "+Биржа") or (CatCode == "-Биржа")  or (CatCode == "Торговый счет")) and
                      ( ( IsRET_COUPON(this.Group) ) OR (IsRET_PARTLY(this.Group)) OR (IsRET_ISSUE(this.Group)) )
                    )
                   if( (this.FaceFIID() == NATCUR) and (this.tick.rec.partyid == 4) )
                      Parametr = 2; /*Основной рынок*/
                   elif( (this.FaceFIID() != NATCUR) and (this.tick.rec.partyid == 4) )
                      Parametr = 2; /*Основной рынок*/
                   else
                      Parametr = this.tick.rec.MarketOfficeID;
                   end;
                /*******/
                else
                   Parametr = this.tick.rec.MarketOfficeID;
                end;
             end;
          end;
       elif( ParmKind == MC_TYPE_PARAMETR_ISSUER )
          /*для Деп расписки ищем эмитента базового актива*/
          if( ((v_CatCode == "Наш портфель ц/б") OR (CatCode == "Наш портфель ц/б")) AND FI_IsDeposReceipt(this.fininstr.rec.FIID) )
             Parametr = this.ПолучитьЭмитентаСвязОбъектаДР(this.fininstr);
          else
             Parametr  = this.fininstr.rec.Issuer;
          end;
       elif( ParmKind == MC_TYPE_PARAMETR_CLIENT )
          if((FIRole == FIROLE_COMISS_CONTR) OR (FIRole == FIROLE_COMISS_BROKER_CONTR) OR (FIRole == FIROLE_BA_CONTR) OR (FIRole == FIROLE_CA_CONTR) OR (FIRole == FIROLE_REGTAX_CONTR)
             OR (FIRole == FIROLE_REGTAX2_CONTR) OR (FIRole == FIROLE_COMPENSDELIVERYCONTR) )
            Parametr = this.tick.rec.PartyID;
          else
            Parametr = this.tick.rec.ClientID;
          end;
      
       /*договор обслуживания клиента*/
       elif( ParmKind == MC_TYPE_PARAMETR_CONTR_CLIENT )
         if((FIRole == FIROLE_COMISS_CONTR) OR (FIRole == FIROLE_COMISS_BROKER_CONTR) OR (FIRole == FIROLE_BA_CONTR) OR (FIRole == FIROLE_CA_CONTR)
             OR (FIRole == FIROLE_REGTAX_CONTR) OR (FIRole == FIROLE_REGTAX2_CONTR) OR (FIRole == FIROLE_COMPENSDELIVERYCONTR ))
           Parametr = this.tick.rec.PartyContrID;
         else
           Parametr = this.tick.rec.ClientContrID;            
         end;
       elif( ParmKind == MC_TYPE_PARAMETR_PARTY )
    
          if( FIRole == FIROLE_COMISS_CLIENT )
             Parametr = this.tick.rec.ClientID;
          elif( (this.tick.rec.PartyID < 0) AND IsEXCHANGE( this.Group ) )
             Parametr = this.tick.rec.MarketID;
          else
             Parametr = this.tick.rec.PartyID;
          end;
       end;

       return Parametr;
    END;  

    /************************************************/
    /*Получить параметры                            */
    /************************************************/
    MACRO GetParametr( ParmKind, OperDate, CatCode, FIRole )
       VAR Parametr = null, InCache, paym;
       
       if( ParmA[ParmKind] != null ) /*если уже есть в кэше, берем значение параметра оттуда*/
          return ParmA[ParmKind];
       end;

       /*пробуем определить значение среди некэшируемых параметров*/     
       Parametr =  GetNonCacheParametr( ParmKind, OperDate, CatCode, FIRole );

       /*среди некэшируемых параметров значение не определили, пробуем среди кэшируемых */
       if( Parametr == null ) 

          InCache = true;

          /*кэшируемые параметры - эти параметры НЕ меняются после создания объекта класса, поэтому их можно занести в кэш*/
          if( ParmKind == MC_TYPE_PARAMETR_PAYCURRENCY )
             Parametr = this.GetPayFIID();

          elif( ParmKind == MC_TYPE_PARAMETR_NUMBER )
             Parametr = this.tick.rec.DealCode;

          /*дата валютирования*/
          elif( ParmKind == MC_TYPE_PARAMETR_VALDATE )
             Parametr = this.pm_avoir.rec.ValueDate;
             if( Parametr == date(0,0,0) )
                Parametr = {curdate};
             end;

          elif( ParmKind == MC_TYPE_PARAMETR_DOCKIND )
             Parametr = this.Kind;

          elif( ParmKind == MC_TYPE_PARAMETR_DOCID )
             Parametr = this.ID;      

          elif( ParmKind == MC_TYPE_PARAMETR_DEPARTMENT )
             Parametr = this.tick.rec.Department; 

          /*договор обслуживания брокера*/
          elif( ParmKind == MC_TYPE_PARAMETR_CONTR_BANK )
             Parametr = this.tick.rec.BrokerContrID;

          elif(ParmKind == MC_TYPE_PARAMETR_COUP_NUM)
             Parametr = tick.rec.Number_Coupon;

          else
             InCache = false;
             Parametr = -1;
          end;

          if( InCache == true )
             ParmA[ParmKind] = Parametr;
          end;
       end;

       return Parametr;
    END;

    /*Проверить есть ли период. комиссии, вычисляемые при закрытии дня*/
    /*CheckCalc == true - проверить есть ли начисленные (или оплаченные)  */
    /* возвращаемые признаки: */
    /*   ExistClient          -  признак наличия клиентских видов комиссий на договоре */
    /*   ExistAgent           -  признак наличия видов комиссий посреднику на договоре */
    /*   ExistClientInPay     -  признак наличия клиентских видов комиссий с моментом расчета на дату оплаты сделки      */
    /*   ExistClientInStart   -  признак наличия клиентских видов комиссий с моментом расчета на дату заключения сделки  */
    MACRO GetPeriodComiss( CheckCalc, ExistClient:@bool, ExistAgent:@bool, ExistClientInPay:@bool, ExistClientInStart:@bool )

       var  contrID, retriment = false;      
       var  _ExistAgent:bool = false, _ExistClient:bool = false;  

       if( (SP_GetSfContrID( tick, contrID ) == true) AND (contrID != 0) )
          if( tick.rec.BofficeKind == DL_RETIREMENT ) 
             retriment = true; 
          end;
          if( not CheckCalc )
             if( SfIsExistPeriodComiss( contrID, retriment, _ExistClient, _ExistAgent, ExistClientInPay, ExistClientInStart ) == true )
                if(ExistClient != null)
                   ExistClient = _ExistClient;
                end;
                if(ExistAgent != null)
                   ExistAgent = _ExistAgent;
                end;
                /*если дата комиссии не задана в сделке, но есть клиентские комиссии (они на дату комиссии в сделке никак не завязаны) */  
                if( (this.tick.rec.CommDate == Date(0,0,0)) AND (_ExistClient == true) )
                   return true;                         
                /*если дата комиссии задана в сделке */      
                elif( this.tick.rec.CommDate != Date(0,0,0) )
                   return true;                               
                end;              
                /*иначе, считаем что периодических комиссий по сделке нет*/
             end;
          else
             if( SfIsExistPeriodCalcComiss( contrID, tick.rec.DealDate ) )
                /*по договору есть периодические уже удержанные комиссии*/
                return true;
             end;
          end;
       end;
       return false;
    end;

    /*Проверить, есть ли по договору сделки период. комиссии, для которых у категории "Расчет комиссий в БО ЦБ" указано значение "При завершении торгового дня"*/
    MACRO GetPeriodComOnFinalTrDay(CheckCalc:bool, ContrNumber:@string)
       VAR SfContr     = TRecHandler( "sfcontr.dbt" );
       var contrID = 0;      

       ContrNumber = "";

       //проверим по главному договору
       if( (SP_GetSfContrID( tick, contrID ) == true) AND (contrID != 0) )
          if( SPIsExistPeriodComissOnFinalTrDay( contrID, CheckCalc, tick.rec.DealDate ) )
             if( DL_FindSfContrByOrder(contrID,SfContr) )
                ContrNumber = SfContr.rec.Number;
             end;
             return true;
          end;
       end;

       return false;
    end;

    macro GetDealParms( deal, avr_p, cur_p, fininstr, pmwrtsum, dl_leg, pm_avance )
       copy( deal,            this.tick            );
       copy( avr_p,           this.pm_avoir        );
       copy( cur_p,           this.pm_money        );
       copy( fininstr,        this.fininstr        );
       copy( pmwrtsum,        this.pmwrtsum        );
       copy( dl_leg,          this.dl_leg          );
       copy( pm_avance,       this.pm_avance       );
    end;

    PRIVATE MACRO ПолучитьДатуИзмененияУсловий()

       var ChangeDate = date(0,0,0);

       if(tick.rec.ChangeKind == SPTKCHNG_CHANGE)
         ChangeDate = tick.rec.ChangeDate
       else
         var cmd, DataSet;

         cmd = DL_RSDCommand("select t_OldChangeDate from dsptkchng_dbt where t_DealID = ? and t_OldChangeKind = ? order by t_OldInstance DESC");
         cmd.AddParam(tick.rec.DealID);
         cmd.AddParam(SPTKCHNG_CHANGE);

         DataSet = cmd.Execute();
         if(DataSet.moveNext())
           ChangeDate = date(DataSet.OldChangeDate);
         end;

       end;

       return ChangeDate;
    END;

    /*определяем вид сделки в зависимости от дат*/
    macro ВидСрочностиСделки()
      var Dз, Dо, Dп, Da, Dv;
      var ret = 0;

      if( this.IsBack ) /*по фактическим датам*/
         Dо = this.DateArray[DATE_DEALPAY]; 
         Dv = this.DateArray[DATE_DEALOUTBAL_2];
         Da = this.DateArray[DATE_DEALAVANCE];
         if( Dо != Dv )
            if( (this.ExistAvance == false) OR (Dv != Da) )
               ret = СделкаНеРанееТретьегоДня;
            end;
         end;
         if( ret == 0 )
            ret = СделкаToday; 
         end;

         if( (ret == СделкаToday) AND bAND( this.dl_leg.rec.BitMask, DL_LEG_ALWAYS_DUE ) )
            ret = СделкаНеРанееТретьегоДня; /*при изменении условий сделки меняли сроки - СделкаToday теперь всегда СделкаСрочная*/
         elif( ret == 0 )
            ret = VALUE_NOT_FIND;
         end;
      else /*для первой части плановые даты*/
         Dз  = this.tick.rec.DealDate;//Здесь нужна именно дата из сделки, т.е. не скорректрованная на рабочий день. Чтобы правильно определить срочность.
         Dо  = this.DateArray[DATE_DEALPAY_PLAN]; 
         Dп  = this.DateArray[DATE_DEALSETAVOIRISS_PLAN];

         var Dизм = date(0,0,0);
         
         if(tick.rec.BofficeKind != DL_SECUROWN)
           Dизм = ПолучитьДатуИзмененияУсловий();
         end;
         
         if(Dизм > date(0,0,0))
           Dз = Dизм;
         end;

         ret = ВидСрочностиСделкиПоПервойЧасти(tick.rec.BofficeKind, this.dl_leg.rec.BitMask, Dз, Dо, Dп, tick.rec.IsPFI);
      end;

      return ret;
    end;

    macro СделкаОРЦБ()
       return ((tick.rec.Flag1 == SET_CHAR) and (not IsLOAN(this.Group)));
    end;

    macro СделкаРЕПОБрокер()
        return ( IsTwoPart(this.Group) and (this.tick.rec.Flag4 == SET_CHAR) and (this.tick.rec.BrokerID > 0) );
    end;


    MACRO GetMarketSchemeID():INTEGER
       return tick.rec.MarketSchemeID;
    END;

    macro ВУ_ПолучитьРольФИ( ВидРО, DebCred, ReturnIncomeKind_ )
      var FIRole   = FIROLE_UNDEF;
      var IsRetire = IsRET_ISSUE(this.Group) OR IsRET_COUPON(this.Group) OR IsRET_PARTLY(this.Group);
      
       var ReturnIncomeKind = tick.rec.ReturnIncomeKind;
       if( ReturnIncomeKind_ != NULL )
          ReturnIncomeKind = ReturnIncomeKind_;
       end;

       var IsPaymContr = (ReturnIncomeKind == SP_RETURNINCOME_PAYMENT);
       
       if(СделкаСКлиентомКонтрагентом(this.tick))
         if( ВидРО == 8 )
           FIRole = FIROLE_COMISS_CLIENT;
         elif(ВидРО == 80001)
           FIRole = FIROLE_COMISS_CONTR;
         elif( ВидРО == 10 )
           FIRole = FIROLE_COMISS_BROKER;
         elif(ВидРО == 10001)
           FIRole = FIROLE_COMISS_BROKER_CONTR;
         elif( ВидРО == 11 )
           FIRole = FIROLE_REGTAX;
         elif(ВидРО == 11001)
           FIRole = FIROLE_REGTAX_CONTR;
         elif(ВидРО == 55)
           FIRole = FIROLE_BA;
         elif(ВидРО == 55001)
           FIRole = FIROLE_BA_CONTR;
         elif ( (ВидРО == 8302) or (ВидРО == 8202) )
           FIRole = FIROLE_COMPENSDELIVERYCONTR;
         end;
       end;

       if( (СделкаСКлиентомКонтрагентом(this.tick)) and (not IsRetire) )
          if( (ВидРО == 9) or (ВидРО == 12) )
             FIRole = FIROLE_COMISS_BROKER;
          elif( ВидРО == 21 )
             FIRole = FIROLE_AVANCE;
          elif( ВидРО == 21001 )
             FIRole = FIROLE_AVANCE_CONTR;
          elif( ВидРО == 19 )
             FIRole = FIROLE_CA_CONTR;
          elif( ВидРО == 20 )
             FIRole = FIROLE_CA;
          elif(ВидРО == 20001)
             FIRole = FIROLE_CA_CONTR;
          elif( (ВидРО == 62) )
             FIRole = FIROLE_BA_CONTR;
          elif( ВидРО == 11 )
             if( IsLOAN(this.Group) and this.IsBack )
                FIRole = FIROLE_REGTAX2;
             end;
          elif( ВидРО == 26 )
             FIRole = FIROLE_PERCENT_CONTR;
          elif( (ВидРО == 22) and (not IsPaymContr) )
             FIRole = FIROLE_NKD_CONTR;
          elif( ВидРО == 63 )
             FIRole = FIROLE_BA_BACK_CONTR;
          elif( (ВидРО == 40) or (ВидРО == 41) )
             FIRole = FIROLE_CALC_RETIRE;
          elif( (ВидРО == 22) or (ВидРО == 25) )
             FIRole = FIROLE_CALC_COUPON;
          elif( (ВидРО == 4301) or (ВидРО == 4401) )
             FIRole = FIROLE_COMPENSPAY;
          elif( (ВидРО == 4302) or (ВидРО == 4402) )
             if (IsBasket(this.Group))
               FIRole = FIROLE_COMPENSDELIVERY;
             else
               FIRole = FIROLE_BA_BACK;
             end;
          end;
       else
          if( ВидРО == 8 )
             FIRole = FIROLE_COMISS_CLIENT;
          elif( (ВидРО == 9) or (ВидРО == 10) or (ВидРО == 12) )
             FIRole = FIROLE_COMISS_BROKER;
          elif( ВидРО == 21 )
             FIRole = FIROLE_AVANCE;
          elif( (ВидРО == 17) or (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 23) or ( IsRetire and (ВидРО == 22) ) )
             FIRole = FIROLE_CA;
          elif( (ВидРО == 55) or (ВидРО == 62) or (ВидРО == 59) or (ВидРО == 60) )
             FIRole = FIROLE_BA;
          elif( ВидРО == 11 )
             if( IsLOAN(this.Group) and this.IsBack )
                FIRole = FIROLE_REGTAX2;
             else
                FIRole = FIROLE_REGTAX;
             end;
          elif( ВидРО == 26 )
             FIRole = FIROLE_PERCENT;
          elif( (ВидРО == 22) and (not IsPaymContr) )
             FIRole = FIROLE_NKD;
          elif( ВидРО == 63 )
             FIRole = FIROLE_BA_BACK;
          elif( (ВидРО == 40) or (ВидРО == 41) )
             FIRole = FIROLE_CALC_RETIRE;
          elif( (ВидРО == 22) or (ВидРО == 25) )
             FIRole = FIROLE_CALC_COUPON;
          elif( (ВидРО == 4301) or (ВидРО == 4401) )
             FIRole = FIROLE_COMPENSPAY;
          elif( (ВидРО == 4302) or (ВидРО == 4402) )
             if (IsBasket(this.Group))
               FIRole = FIROLE_COMPENSDELIVERY;
             else
               FIRole = FIROLE_BA_BACK;
             end;
          end;
       end;  

       return FIRole;
    end;

    macro ВУ_ПолучитьКатегориюДебет( ВидРО, ReturnIncomeKind_ )
      var Категория = "",
          IsPartBuy  = ((IsBUY(this.Group) and (not this.IsBack)) or (IsSALE(this.Group) and this.IsBack) or IsAVRWRTIN(this.Group) ),
          IsPartSale = ((IsSALE(this.Group) and (not this.IsBack)) or (IsBUY(this.Group) and this.IsBack) or IsAVRWRTOUT(this.Group) ),
          IsRetire   = IsRET_ISSUE(this.Group) OR IsRET_COUPON(this.Group) OR IsRET_PARTLY(this.Group),
          IsPartyClietnt =  СделкаСКлиентомКонтрагентом(this.tick),
          IsClient   = (IsClientDeal(this.tick.rec) and (not IsPartyClietnt)),
          IsOurBank  = ((not IsPartyClietnt) and (not IsClient)),
          IsClient_  = IsClientDeal(this.tick.rec);

       var ReturnIncomeKind = tick.rec.ReturnIncomeKind;
       if( ReturnIncomeKind_ != NULL )
          ReturnIncomeKind = ReturnIncomeKind_;
       end;

       var IsPaymContr = (ReturnIncomeKind == SP_RETURNINCOME_PAYMENT);

       /* Пока только для сделок покупки/продажи и займов */
       if( ( ВидРО == 8 ) or ( ВидРО == 80001 ) or
           ( ( (ВидРО == 9) or (ВидРО == 10) or (ВидРО == 12) or (ВидРО == 17) or (ВидРО == 40) or (ВидРО == 25)) and IsClient ) or 
           ( ( (ВидРО == 21) or (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 26) or ((ВидРО == 22) and not IsPaymContr) ) and IsClient and IsPartBuy ) or
           ( ( (ВидРО == 21001) or (ВидРО == 20001) or (ВидРО == 19) or (ВидРО == 26) or (ВидРО == 22) ) and IsPartyClietnt and IsPartSale ) or
           ( ( (ВидРО == 10) or (ВидРО == 10001) or (ВидРО == 11) or (ВидРО == 11001) or (ВидРО == 12)) and ( IsClient or IsPartyClietnt ) ) or
           ( ((ВидРО == 20)or(ВидРО == 21)) and IsPartyClietnt and IsPartBuy and IsClient_ ) or
           ( (ВидРО == 4401)  and IsClient_ ) 
         )
          Категория = "ДС, Расч. с клиентом, ВУ";
       elif( (ВидРО == 22) and (IsTwoPart(this.Group)) and IsPartBuy and IsOurBank)
          if(IsBROKER(this.Group) or this.СделкаРЕПОБрокер()) 
             Категория = "ДС у брокера, ВУ";
          else
             Категория = "ДС Банка, ВУ";
          end; 
       elif( ( ( (ВидРО == 9) or (ВидРО == 10) or (ВидРО == 12) or (ВидРО == 40) or (ВидРО == 25) ) and IsOurBank ) or
             ( ( (ВидРО == 21) or (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 26) or ((ВидРО == 22) and not IsPaymContr) ) and IsOurBank and IsPartBuy ) or
             ( (ВидРО == 11) and IsOurBank ) or
             ( ((ВидРО == 20)or(ВидРО == 21)) and IsPartyClietnt and IsPartBuy and (not IsClient_) ) or
             ( (ВидРО == 4401) and (not IsClient_) )
           )
          Категория = "ДС, Прч. счета банка, ВУ";
       elif( (((ВидРО == 22) OR (ВидРО == 23)) and IsRetire and IsOurBank) or
             ((ВидРО == 22) and IsPaymContr and IsOurBank ) 
           )
          if( IsEXCHANGE(this.Group) and (this.tick.rec.Flag1 == SET_CHAR) and (not this.СделкаРЕПОБрокер())) 
             Категория = "ДС в РЦ ОРЦБ, ВУ";
          elif(IsBROKER(this.Group) or this.СделкаРЕПОБрокер()) 
             Категория = "ДС у брокера, ВУ";
          else
             Категория = "ДС Банка, ВУ";
          end;
       elif( ( ( (ВидРО == 21001) or (ВидРО == 19) or (ВидРО == 20001) or (ВидРО == 26) or (ВидРО == 22) ) and IsPartyClietnt and IsPartBuy ) or
             ( ( (ВидРО == 21) or (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 26) or (ВидРО == 22) ) and IsClient and IsPartSale ) or
             ( ((ВидРО == 22) OR (ВидРО == 23)) and  IsClient and IsRetire ) or
             ( (((ВидРО == 22) and IsPaymContr) or (ВидРО == 41)) and IsClient ) or
             ( ((ВидРО == 20)or(ВидРО == 21)) and IsPartyClietnt and IsPartSale and IsClient_ ) or
             ( (ВидРО == 4301) and IsClient_ )
           )
          Категория = "ДС Клиента, ВУ";
       elif( (( (ВидРО == 21) or (ВидРО == 26) or (ВидРО == 22) ) and IsOurBank and IsPartSale) or
             ( (ВидРО == 21) and IsPartyClietnt and IsPartSale and (not IsClient_) )
           ) 
          Категория = "ДС Банка, ВУ";
       elif( ((((ВидРО == 19) or (ВидРО == 20)) and IsOurBank and IsPartSale) or (((ВидРО == 41)) and IsOurBank)) or
             ( (ВидРО == 20) and IsPartyClietnt and IsPartSale and (not IsClient_) ) or
             ( (ВидРО == 4301) and (not IsClient_) )
           )
          if( IsEXCHANGE(this.Group) and (this.tick.rec.Flag1 == SET_CHAR) and (not this.СделкаРЕПОБрокер()) ) 
             Категория = "ДС в РЦ ОРЦБ, ВУ";
          elif(IsBROKER(this.Group) or this.СделкаРЕПОБрокер() ) 
             Категория = "ДС у брокера, ВУ";
          else
             Категория = "ДС Банка, ВУ";
          end;
       elif( ( ( (ВидРО == 55) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsClient and IsPartBuy ) or
             ( ( (ВидРО == 55 and not IsPartyClietnt) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsPartyClietnt and IsPartSale ) or
             (ВидРО == 59) or
             ( (ВидРО == 57) and IsClient ) or
             ( (ВидРО == 78) and IsClient ) or
             ( (ВидРО == 4402) and IsClient_ ) or
             ( (ВидРО == 8302) and IsPartyClietnt )  or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartBuy and IsClient_ )
           ) 
          Категория = "ЦБ Клиента, ВУ";
       elif( ( ( (ВидРО == 55) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsClient and IsPartSale ) or
             ( ( (ВидРО == 55 and not IsPartyClietnt) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsPartyClietnt and IsPartBuy ) or
             ( (ВидРО == 55) and IsClient and IsRetire ) or
             (ВидРО == 60) or
             ( (ВидРО == 58) and IsClient ) or
             ( (ВидРО == 4302) and IsClient_ ) or
             ( (ВидРО == 8202) and IsPartyClietnt )  or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartSale and IsClient_ )
           ) 
          Категория = "ЦБ, Расч. с клиентом, ВУ";
       elif( ( ( (ВидРО == 55) or (ВидРО == 62) or (ВидРО == 63) ) and IsOurBank and IsPartBuy ) or 
             ( (ВидРО == 57) and IsOurBank ) or
             ( (ВидРО == 78) and IsOurBank ) or
             ( (ВидРО == 4402) and (not IsClient_) ) or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartBuy and (not IsClient_) )
           )
          Категория = "ЦБ Банка, ВУ";
       elif( ( ( (ВидРО == 55) or (ВидРО == 62) or (ВидРО == 63) ) and IsOurBank and IsPartSale ) or 
             ( (ВидРО == 55) and IsOurBank and IsRetire ) or
             ( (ВидРО == 58) and IsOurBank ) or
             ( (ВидРО == 4302) and (not IsClient_) ) or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartSale and (not IsClient_) )
           )
          Категория = "ЦБ, Прч. счета банка, ВУ";
       end;

       return Категория;
    end;

    macro ВУ_ПолучитьКатегориюКредит( ВидРО, ReturnIncomeKind_ )
      var Категория = "",
          IsPartBuy  = ((IsBUY(this.Group) and (not this.IsBack)) or (IsSALE(this.Group) and this.IsBack) or IsAVRWRTIN(this.Group) ),
          IsPartSale = ((IsSALE(this.Group) and (not this.IsBack)) or (IsBUY(this.Group) and this.IsBack) or IsAVRWRTOUT(this.Group) ),
          IsRetire   = IsRET_ISSUE(this.Group) OR IsRET_COUPON(this.Group) OR IsRET_PARTLY(this.Group),
          IsPartyClietnt =  СделкаСКлиентомКонтрагентом(this.tick),
          IsClient   = (IsClientDeal(this.tick.rec) and (not IsPartyClietnt)),
          IsOurBank  = ((not IsPartyClietnt) and (not IsClient)),
          IsClient_  = IsClientDeal(this.tick.rec);

       var ReturnIncomeKind = tick.rec.ReturnIncomeKind;
       if( ReturnIncomeKind_ != NULL )
          ReturnIncomeKind = ReturnIncomeKind_;
       end;

       var IsPaymContr = (ReturnIncomeKind == SP_RETURNINCOME_PAYMENT);

       /* Пока только для сделок покупки/продажи и займов */
       if( ( ВидРО == 8 ) or ( ВидРО == 80001 ) or
           ( ( (ВидРО == 9) or (ВидРО == 10) or (ВидРО == 12) or (ВидРО == 17) or (ВидРО == 40) or (ВидРО == 25) ) and IsClient ) or 
           ( ( (ВидРО == 21) or (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 26) or ((ВидРО == 22) and not IsPaymContr ) ) and IsClient and IsPartBuy ) or
           ( ( (ВидРО == 21001) or (ВидРО == 19) or (ВидРО == 20001) or (ВидРО == 26) or (ВидРО == 22) ) and IsPartyClietnt and IsPartSale ) or
           ( ( (ВидРО == 10) or (ВидРО == 10001) or (ВидРО == 11) or (ВидРО == 11001) or (ВидРО == 12)) and ( IsClient or IsPartyClietnt ) ) or
           ( ((ВидРО == 20)or(ВидРО == 21)) and IsPartyClietnt and IsPartBuy and IsClient_ ) or
           ( (ВидРО == 4401) and IsClient_ )
         )
          Категория = "ДС Клиента, ВУ";
       elif( (((ВидРО == 19) or (ВидРО == 20)) and IsOurBank and IsPartBuy) or
             (ВидРО == 25) or
             ( (ВидРО == 20) and IsPartyClietnt and IsPartBuy and (not IsClient_) )
           )
          if( IsEXCHANGE(this.Group) and (this.tick.rec.Flag1 == SET_CHAR) and (not this.СделкаРЕПОБрокер()) ) 
              Категория = "ДС в РЦ ОРЦБ, ВУ";
          elif( IsBROKER(this.Group) or this.СделкаРЕПОБрокер() )
              Категория = "ДС у брокера, ВУ";
          else
             Категория = "ДС Банка, ВУ";
          end;
       elif( (ВидРО == 22) and (IsTwoPart(this.Group)) and IsPartBuy and IsOurBank)
          Категория = "ДС, Прч. счета банка, ВУ";     
       elif( ( ( (ВидРО == 21) or (ВидРО == 26) or ((ВидРО == 22) and not IsPaymContr) ) and IsOurBank and IsPartBuy ) or
             ( (ВидРО == 11) and IsOurBank ) or
             ( (ВидРО == 21) and IsPartyClietnt and IsPartBuy and (not IsClient_) )
           )
          Категория = "ДС Банка, ВУ";
       elif( ( ( (ВидРО == 21001) or (ВидРО == 19) or (ВидРО == 20001) or (ВидРО == 26) or (ВидРО == 22) ) and IsPartyClietnt and IsPartBuy ) or
             ( ( (ВидРО == 21) or (ВидРО == 19) or (ВидРО == 20) or (ВидРО == 26) or (ВидРО == 22) ) and IsClient and IsPartSale ) or
             ( ((ВидРО == 22) OR (ВидРО == 23)) and  IsClient and IsRetire ) or
             ( ( ((ВидРО == 22) and IsPaymContr) or (ВидРО == 41) ) and  IsClient ) or
             ( ((ВидРО == 20)or(ВидРО == 21)) and IsPartyClietnt and IsPartSale and IsClient_ ) or
             ( (ВидРО == 4301) and IsClient_ )
           )
          Категория = "ДС, Расч. с клиентом, ВУ";
       elif( ( ( (ВидРО == 21) or (ВидРО == 26) or (ВидРО == 22) ) and IsOurBank and IsPartSale ) or
             ( ((ВидРО == 19) or (ВидРО == 20)) and IsOurBank and IsPartSale ) or
             ( ((ВидРО == 22) OR (ВидРО == 23) ) and IsOurBank and IsRetire ) or
             ( ( ((ВидРО == 22) and IsPaymContr) or (ВидРО == 41) ) and IsOurBank ) or
             ( (ВидРО == 4301) and (not IsClient_) ) or
             ( ((ВидРО == 20)or(ВидРО == 21)) and IsPartyClietnt and IsPartSale and (not IsClient_) )
           ) 
          Категория = "ДС, Прч. счета банка, ВУ";
       elif( (( (ВидРО == 9) or (ВидРО == 10) or (ВидРО == 12) or (ВидРО == 40)) and IsOurBank) or
             ( (ВидРО == 4401) and (not IsClient_) )
           )
          if( IsEXCHANGE(this.Group) and (this.tick.rec.Flag1 == SET_CHAR) and (not this.СделкаРЕПОБрокер()) ) 
             Категория = "ДС в РЦ ОРЦБ, ВУ";
          elif(IsBROKER(this.Group) or this.СделкаРЕПОБрокер() ) 
             Категория = "ДС у брокера, ВУ";
          else
             Категория = "ДС Банка, ВУ";
          end;
       elif( ( ( (ВидРО == 55) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsClient and IsPartBuy ) or
             ( ( (ВидРО == 55 and not IsPartyClietnt) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsPartyClietnt and IsPartSale ) or
             (ВидРО == 59) or
             ( (ВидРО == 57) and IsClient ) or
             ( (ВидРО == 78) and IsClient ) or
             ( (ВидРО == 4402) and IsClient_ ) or
             ( (ВидРО == 8302) and IsPartyClietnt )  or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartBuy and IsClient_ ) 
           ) 
          Категория = "ЦБ, Расч. с клиентом, ВУ";
       elif( ( ( (ВидРО == 55 and not IsPartyClietnt) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsClient and IsPartSale ) or
             ( ( (ВидРО == 55 and not IsPartyClietnt) or (ВидРО == 55001) or (ВидРО == 62) or (ВидРО == 63) ) and IsPartyClietnt and IsPartBuy ) or
             ( (ВидРО == 55) and IsClient and IsRetire ) or
             (ВидРО == 60) or
             ( (ВидРО == 58) and IsClient ) or
             ( (ВидРО == 4302) and IsClient_ ) or
             ( (ВидРО == 8202) and IsPartyClietnt ) or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartSale and IsClient_ ) 
           ) 
          Категория = "ЦБ Клиента, ВУ";
       elif( ( ( (ВидРО == 55) or (ВидРО == 62) or (ВидРО == 63) ) and IsOurBank and IsPartBuy ) or
             ( (ВидРО == 57) and IsOurBank ) or
             ( (ВидРО == 78) and IsOurBank ) or
             ( (ВидРО == 4402) and (not IsClient_) ) or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartBuy and (not IsClient_) ) 
           )
          Категория = "ЦБ, Прч. счета банка, ВУ";
       elif( ( ( (ВидРО == 55) or (ВидРО == 62) or (ВидРО == 63) ) and IsOurBank and IsPartSale ) or
             ( (ВидРО == 55) and IsOurBank and IsRetire ) or
             ( (ВидРО == 58) and IsOurBank ) or
             ( (ВидРО == 4302) and (not IsClient_) ) or
             ( (ВидРО == 55) and IsPartyClietnt and IsPartSale and (not IsClient_) )
           )
          Категория = "ЦБ Банка, ВУ";
       end;

       return Категория;
    end;

    macro ВУ_ОснованиеПроводки( ВидРО, ReturnIncomeKind_ )
      var Ground = "",
          IsRetire = IsRET_ISSUE(this.Group) OR IsRET_COUPON(this.Group) OR IsRET_PARTLY(this.Group),
          IsAvrIn = IsAVRWRTIN(this.Group), IsAvrOut = IsAVRWRTOUT(this.Group);

       var ReturnIncomeKind = tick.rec.ReturnIncomeKind;
       if( ReturnIncomeKind_ != NULL )
          ReturnIncomeKind = ReturnIncomeKind_;
       end;

       var IsPaymContr = (ReturnIncomeKind == SP_RETURNINCOME_PAYMENT);

       if( (ВидРО == 8) OR (ВидРО == 80001))
          Ground = "Оплата комиссии банку по операции";
       elif( (ВидРО == 9) or (ВидРО == 10) or (ВидРО == 10001) or (ВидРО == 12) )
          Ground = "Оплата комиссии посреднику по операции";
       elif( (ВидРО == 21) or (ВидРО == 21001) )
          if(IsTwoPart(this.Group))
             Ground = "Оплата аванса по операции";
          else
          Ground = "Оплата аванса/задатка по операции";
          end;
       elif( ВидРО == 17 )
          Ground = "Удержание налога по сделке";
       elif( ВидРО == 19 )
          Ground = "Возврат гарантийного обеспечения";
       elif( (ВидРО == 20) or (ВидРО == 20001) )
          Ground = "Оплата ц/б по операции";
       elif( (ВидРО == 55) or (ВидРО == 55001))
          if( IsRetire )
             Ground = "Списание ц/б в операции погашения выпуска ";
          elif( IsAvrIn ) 
             Ground = "Зачисление ц/б по операции ";
          elif( IsAvrOut )
             Ground = "Списание ц/б по операции ";
          else
             Ground = "Поставка ц/б по операции";
          end;
       elif( (ВидРО == 11) or (ВидРО == 11001) )
          Ground = "Оплата рег. сбора по операции";
       elif( ВидРО == 26 )
          Ground = "Выплата процентов по операции";
       elif( ((ВидРО == 22) or (ВидРО == 23)) and (IsRetire) )
          Ground = "Зачисление средств в операции ";
       elif( (ВидРО == 22) )
          if( IsPaymContr )
             Ground = "Получение купонного дохода от контрагента по сделке ";
          else
             Ground = "Возврат купонного дохода по ц/б, " + IIF( IsBUY(this.Group), "полученным в операции", "размещенным по операции");
          end;
       elif( (ВидРО == 62) or (ВидРО == 63) )
          if( this.IsBack )
             Ground = "Возврат ц/б по операции";
          elif( IsBUY(this.Group) )
             Ground = "Получение ц/б по операции";
          else
             Ground = "Размещение ц/б по операции";
          end;
       elif( ВидРО == 57 )
          Ground = "Зачисление ц/б в операции конвертации ";
       elif( ВидРО == 58 )
          Ground = "Списание ц/б в операции конвертации ";
       elif( ВидРО == 59 )
          Ground = "Получение ц/б клиента по операции ";
       elif( ВидРО == 60 )
          Ground = "Возврат ц/б клиента по операции ";
       elif( (ВидРО == 4301) or (ВидРО == 4302) )
          Ground = "Выплата компенсационного взноса контрагенту по сделке ";
       elif( (ВидРО == 4401) or (ВидРО == 4402)  )
          Ground = "Получение компенсационного взноса от контрагента по сделке ";
       elif( ВидРО == 25 )
          Ground = "Выплата купонного дохода контрагенту по сделке ";
       elif( ВидРО == 41 )
          Ground = "Получение дохода по частичному погашению ц/б от контрагента по сделке ";
       elif( ВидРО == 40 )
          Ground = "Выплата дохода от частичного погашения ц/б по сделке ";
       elif( ВидРО == 78 )
          Ground = "Зачисление ц/б в операции ";
       end;

       Ground = Ground + " " + ПолучитьВидОперации(this.Group, this.IsBack, true) + " №" + this.tick.rec.DealCode;
       
       return Ground;
    end;

    /* Возвращаем true, если на сделке стоит признак блокировки. */
    macro СделкаБлокирована()
       return  IsTwoPart(this.Group) and IsBUY(this.Group) and (this.tick.rec.Flag4 == SET_CHAR);
    end;

   /* Проверка - оплата комиссий через транзитрый счет. */
   macro КомиссияЧерезТранзитныйСчет()
      var
         Dk = this.DateArray[DATE_DEALCOMISS];

      /* В клиентских - никогда. */
      if( IsClientDeal(this.tick.rec) )
         return false;
      end;

      /* В займе всегда. */
      if( this.IsOperLOAN )
         return true;
      end;

      if( this.tick.rec.BofficeKind == DL_INVESTSHARE ) /*Паи*/
         return true;
      end;

      /* Погашения - когда дата комиссии не равна дате заключения
         сделки. */
      if( IsRET_ISSUE(this.Group) )
         return Dk != this.DateArray[DATE_DEALDATE];
      end;

      /* Биржевая сделка - если сделка не ОРЦБ. */
      if( IsEXCHANGE(this.Group) )
         if( (not this.СделкаОРЦБ()) OR 
             (this.DateArray[DATE_DEALSETAVOIRISS] < this.DateArray[DATE_DEALCOMISS]) 
           )
            return true;
         end;
      end;

      /* Во внебиржевой сделке всегда. */
      if( IsOUTEXCHANGE(this.Group) )
         return true;
      end;

      /* В брокерской сделке, если дата поставки меньше даты комисии. */
      if( IsBROKER(this.Group) )
         return this.DateArray[DATE_DEALSETAVOIRISS] < Dk;
      end;

      /* В остальных случаях нет. */
      return false;
   end;   

    /*   проверяем все ли необходимые периодические комиссии рассчитаны и оплачены                          */
    /* no_check_for_pay - признак того, что не надо проверять оплаченность периодических комиссий           */
    /* no_check_inpay   - признак того, что не надо проверять расчитаны ли комиссии с датой расчета в дату  */
    /*  оплаты сделки                                                                                       */
    macro ПроверитьПериодическиеКомиссии( wrtsum, no_check_for_pay, no_check_inpay )
/*
      var ExistClient:bool = false, ExistAgent:bool = false, ExistClientInPay:bool = false, ExistClientInStart:bool = false;

      /*проверяем для все лотов, кроме лотов погашения купонов*/
      if( wrtsum.Buy_Sale != PM_WRITEOFF_SUM_COUPON ) 

         if( this.GetPeriodComiss( false, @ExistClient, @ExistAgent, @ExistClientInPay, @ExistClientInStart ) == true )                                     
            
            if( this.tick.rec.CommDate != Date(0,0,0) )
               if( ExistAgent AND ( bAND( wrtsum.BitMask, DL_LEG_CALC_AGENT_PERIOD) == false ) )
                  return false;
               end;
            end;

            /*клиентские комиссии с моментом расчета в дату заключения сделки*/
            if( ExistClientInStart AND ( bAND( wrtsum.BitMask, DL_LEG_CALC_BANK_PERIOD) == false ) )
               return false;
            end;
            /*клиентские комиссии с моментом расчета в дату оплаты сделки*/
            if( ( (no_check_inpay == null) OR (not no_check_inpay) ) AND
                ExistClientInPay AND ( bAND( wrtsum.BitMask, DL_LEG_CALC_BANK_INPAY_PERIOD) == false ) )
               return false;
            end;

            if( (no_check_for_pay == null) OR (no_check_for_pay != true) ) 
               /*Проверяем оплаченность периодических комиссий */
               if( ОплаченыВсеПериодКомиссии( wrtsum, ExistClient, ExistAgent, ExistClientInPay, ExistClientInStart, this.tick.rec.CommDate ) == false )
                  return false;         
               end;
            end;
         end;
      end;
*/
      return true;
    end;

    /*проверяем все ли необходимые комиссии оплачены*/
    macro ПроверитьКомиссии( wrtsum )

      if( not this.IsBack )

         if( this.tick.rec.CommDate != Date(0,0,0) )
            /*проверяем оплаченность единовременных комиссий*/ 
            if( not ОплаченыВсеЕдинКомиссии( this.dl_leg.rec, this ) )
               return false; 
            end;
         end;

         /*проверяем оплаченность периодических комиссий*/ 
         if (not ПроверитьПериодическиеКомиссии(wrtsum))
            return false; 
         end; 

      end;

      return true;
    end;

    macro ПроверитьНачисленностьЕдиновременныхКомиссий()
      if( (bAND( this.dl_leg.rec.BitMask, DL_LEG_ADD_AGENT_ONCE     ) == true) OR 
         (bAND( this.dl_leg.rec.BitMask, DL_LEG_ADD_BANK_ONCE     ) == true) )
         return true;
      else
         return false;
      end;
    end;

    macro ПроверитьНачисленностьПериодическихКомиссий()
      if( (bAND( this.dl_leg.rec.BitMask, DL_LEG_ADD_AGENT_PERIOD   ) == true) OR
          (bAND( this.dl_leg.rec.BitMask, DL_LEG_ADD_BANK_PERIOD   ) == true) ) 
         return true;
      else
         return false;
      end;
    end;

    macro ПроверитьНачисленностьКомиссий()
      if( this.ПроверитьНачисленностьЕдиновременныхКомиссий() OR
          this.ПроверитьНачисленностьПериодическихКомиссий() )
         return true;
      else
         return false;
      end;
    end;

    /*проверить даты поставки\оплаты - плановые или фактические*/
    macro ПроверитьДатыОплатыПоставки( dl_leg, check_plan, check_dvp )

      var PayDate, SetDate;
      
      if( check_plan )
         PayDate = this.GetPayPlanDate( dl_leg );
         SetDate = this.GetAvoirissPlanDate( dl_leg );
      else
         PayDate = this.DateArray[DATE_DEALPAY];
         SetDate = this.DateArray[DATE_DEALSETAVOIRISS];
      end;

      if( (check_dvp == true) AND (dl_leg.Formula == SP_TYPE_CALC_DVP) ) /*поставка против платежа*/                
         if( PayDate != SetDate )
            msgbox( "Дата поставки" + StrClassName + "должна быть равна дате оплаты." );
            return false;
         end;
      elif( dl_leg.Formula == SP_TYPE_CALC_PP ) /*предоплата*/
         if( PayDate > SetDate )
            msgbox( "Дата оплаты" + StrClassName + "должна быть|меньше или равна дате поставки." );
            return false;
         end; 
      elif( dl_leg.Formula == SP_TYPE_CALC_PD ) /*предпоставка*/              
         if( SetDate > PayDate )
            msgbox( "Дата поставки" + StrClassName + "должна быть|меньше или равна дате оплаты." );
            return false;
         end; 
      end;
      return true;
    end;

    /*проверить оплаченность аванс\задатка*/                 
    macro ПроверитьОплаченностьАвансаЗадатка()
       if( this.ExistAvance == true )
          return ТОЗакрыто( this.GetRQ(DLRQ_TYPE_AVANCE) );
       elif(this.ExistDeposit == true)
          return ТОЗакрыто( this.GetRQ(DLRQ_TYPE_DEPOSIT) );
       end;
       return true;
    end;

    macro УчитыватьВИнвПортф()
       var Dp2, Dc, Paym_b; 

       /*Может вестись только в пок. с обратной продажей*/
       if( IsBACKSALE(this.Group) AND IsBUY(this.Group) ) 
          if( this.IsBack == true ) 
             Dp2 = this.DateArray[DATE_DEALSETAVOIRISS]; 
             Dc  = this.DateArray[DATE_DEALDATE]; 
          else
             Paym_b = Trechandler( "pmpaym.dbt"   ); /* платеж ценными бумагами   */
             ClearRecord(Paym_b);
             if( FindPayment( null, BRi, 0, this.tick.rec.BOfficeKind, this.tick.rec.DealID, true, Paym_b, NULL, NULL, NULL) != 0 )
                if( FindPayment( null, BRi, 0, this.tick.rec.BOfficeKind, 0, false, Paym_b, NULL, NULL, NULL) != 0 )   
                   MsgBox( "Для сделки не найден платеж по ценным бумагам для обратной части" );
                   return false;
                end;
             end;  
             Dp2 = Paym_b.rec.ValueDate; 
             Dc  = this.tick.rec.DealDate; 
          end;

          return ( (Dp2-Dc) > 180 )
       else
          return false;
       end;
    end;

    macro БылоДосрочноеИсполнение()
       /*Исполнение не в срок*/
       if( bAND( this.dl_leg.rec.BitMask, DL_LEG_EARLY_EXECUTE ) )
          return true; 
       end;
       return false;
    end;

    /* Проверяем, был ли отказ от исполнения части сделки на дату, т.е. до
       заданной даты включительно. Если дата не задана, то проверяем был ли
       вообще отказ от исполнения.
         ADate -  дата, на которую проверям отказ */
    macro БылОтказОтИсполнения( ADate )
       return WasRejectDealPart( this.dl_leg.rec, ADate );
    end;

    macro БылоОтложенноеИсполнение()
       if( bAND( this.dl_leg.rec.BitMask, DL_LEG_LAST_EXECUTE ) )
          return true; 
       end;
       return false;
    end;

    /* Получить dl_leg по другой части сделки. Сделка должна быть из двух
       частей. Если не смогли получить данные выводим сообщение об ошибке
       и возвращаем пустой буфер. */
    private macro GetAnotherDLLEG()
      var
         AnotherLeg  = TRecHandler( "dl_leg.dbt" ),
         LegKind     = LEG_KIND_DL_TICK_BACK;

      if( IsBack )
         LegKind = LEG_KIND_DL_TICK;
      end;

      if( FindDL_LEG( LegKind, this.tick.rec.DealID, 0, AnotherLeg ) )
         MsgBox(  "Не могу получить данные по другой части сделки (",
                  "LegKind=", LegKind, ", DealID=", this.tick.rec.DealID, ")" );
         AnotherLeg.Clear();
      end;
      return AnotherLeg.rec;
    end;

    /* Возвращаем true, если по сделке есть рег.сбор. */
    macro ЕстьРегистрационныйСбор()

      if( this.IsOperLOAN == true ) /*займ*/
         return  ( (this.tick.rec.Flag1 == SET_CHAR) or (this.tick.rec.Flag4 == SET_CHAR) );
      else
         /* Проверяем присутсвие регсбора в одной части (которая загружена).
            Если по ней нет регсбора и в сделке две части, то проверяем
            регсбор по другой части. */
         return   (this.dl_leg.rec.PayRegTax == SET_CHAR) OR
                  (tick.rec.PartyContrID > 0 ) OR
                  (this.ExistBack and (GetAnotherDLLEG.PayRegTax == SET_CHAR));
      end;
    end;

    macro СуммаПлатежейНКД( LastSubPurpose:@INTEGER )
       var pmNKD = Trechandler( "pmpaym.dbt" ), /* платеж НКД*/
           SubPurposeNKD, SummaNKD; 

       SubPurposeNKD = 0;
       SummaNKD      = $0;
       while( FindPayment( null, INi, SubPurposeNKD, this.tick.rec.BOfficeKind, this.tick.rec.DealID, true, pmNKD ) == 0 )
          if( ПлатежЗакрыт( pmNKD.rec ) )
             SummaNKD = SummaNKD + pmNKD.rec.BaseAmount; /*Валюта номинала*/
          end;
          SubPurposeNKD = SubPurposeNKD + 1;
       end;
       LastSubPurpose = SubPurposeNKD - 1;
       return SummaNKD;
    end;

    macro CheckCliring( CheckOnlyMultiExec:BOOL ):BOOL
       VAR StrErrExec = "";
       VAR OprMultiExec = isOprMultiExec();

       if( (not OprMultiExec) AND CheckOnlyMultiExec )
          return true;
       end;

       if( (this.dl_leg.rec.CliringDate != DATE(0,0,0)) AND 
           (this.dl_leg.rec.CliringChange == SET_CHAR)
         )
          if( (not ТОЗакрыто(this.GetRQ(DLRQ_TYPE_DELIVERY))) and (not БылоДосрочноеИсполнение()) )
             if( this.IsBack )
                StrErrExec = "По второй части сделки было изменение условий в клиринге.";
             elif( this.ExistBack )
                StrErrExec = "По первой части сделки было изменение условий в клиринге.";
             else
                StrErrExec = "По сделке было изменение условий в клиринге.";
             end;

             if( OprMultiExec )
                msgbox( StrErrExec );
                return false;
             else
                if( MsgBoxEx( StrErrExec+"|Выполнить ?", 
                              MB_YES+MB_NO, IND_YES, 
                              "Исполнение сделки", "Подтверждение выполнения операции" ) != IND_YES ) 
                   return false; 
                end;
                return true;
             end;
          end;
       end;

       return true;
    end;

    macro IsOldDeal():BOOL

       return ((this.tick.rec.DealType == 2141) or (this.tick.rec.DealType == 2151) or
               (this.tick.rec.DealType == 2142) or (this.tick.rec.DealType == 2152) or
               (this.tick.rec.DealType == 2121) or (this.tick.rec.DealType == 2126) or
               (this.tick.rec.DealType == 2131) or (this.tick.rec.DealType == 2136) or
               (this.tick.rec.DealType == 2161) or (this.tick.rec.DealType == 2171) or
               (this.tick.rec.DealType == 2182) or (this.tick.rec.DealType == 2192)
              );
    end;

    /*получить сумму СС ПФИ строго за дату*/
    macro GetFrValSumByDate(pDate:DATE,IsFill:@bool,IsAccounted:@bool):money
       var RetVal:money = $0.0, Data;

       IsFill = false;
       IsAccounted = false;

       var Query = DL_RSDCommand();

       var QueryTxt = " select frval.t_FairValue, frval.t_Accounted " +
                      "   from ddvnfrval_dbt frval " +
                      "  where frval.t_DealID = ?  " +
                      "    and frval.t_DocKind= ?  " +
                      "    and frval.t_Date = ? " +
                      " order by frval.t_Date desc, frval.t_ID desc";

       Query.addParam(this.tick.rec.DealID);
       Query.addParam(this.tick.rec.BOfficeKind);
       Query.addParam(pDate);

       Data = Query.execute(QueryTxt);
       if( Data.MoveNext() and (Data.FairValue != NULL) )
          RetVal = SQL_ConvTypeSum(Data.FairValue);
          IsFill = true;
          IsAccounted = iif(Data.Accounted,true,false);
      end;

       return RetVal;
            end;
       
    /*получить последнюю учтенную сумму СС ПФИ НА дату*/
    macro GetFrValSumLastAccountedOnDate(pDate:DATE,IsFill:@bool):money
       var RetVal:money = $0.0, Data;

       IsFill = false;

       var Query = DL_RSDCommand();

       var QueryTxt = " select frval.t_FairValue   " +
                      "   from ddvnfrval_dbt frval " +
                      "  where frval.t_DealID = ?  " +
                      "    and frval.t_DocKind= ?  "+
                      "    and frval.t_Date <= ? "+
                      "    and frval.t_Accounted = 'X' "+
                      " order by frval.t_Date desc, frval.t_ID desc";

       Query.addParam(this.tick.rec.DealID);
       Query.addParam(this.tick.rec.BOfficeKind);
       Query.addParam(pDate);
     
       Data = Query.execute(QueryTxt);
       if( Data.MoveNext() and (Data.FairValue != NULL) )
          RetVal = SQL_ConvTypeSum(Data.FairValue);
          IsFill = true;
       end;
   
       return RetVal;
    end;

    /*получить последнюю сумму СС ПФИ НА дату*/
    macro GetFrValSumLastOnDate(pDate:DATE,IsFill:@bool):money
       var RetVal:money = $0.0, Data;

       IsFill = false;

       var Query = DL_RSDCommand();

       var QueryTxt = " select frval.t_FairValue   " +
                      "   from ddvnfrval_dbt frval " +
                      "  where frval.t_DealID = ?  " +
                      "    and frval.t_DocKind= ?  "+
                      "    and frval.t_Date <= ? "+
                      " order by frval.t_Date desc, frval.t_ID desc";

       Query.addParam(this.tick.rec.DealID);
       Query.addParam(this.tick.rec.BOfficeKind);
       Query.addParam(pDate);
     
       Data = Query.execute(QueryTxt);
       if( Data.MoveNext() and (Data.FairValue != NULL) )
          RetVal = Data.FairValue;
          IsFill = true;
       end;
       return RetVal;
    end;

    //получить спрвелливую стоимость ПФИ (последнее учтенное значение)
    /*последняя сумма ССПФИ к этому моменту может быть еще не учтена, 
      поэтому для поиска ССПФИ для проводок воспользуемся той же ф-й, которая вставляет ССПФИ в лот*/
    macro GetDVSSCostOnDate(pDate:date)
       var DVSSCost = $0, Data, Query = DL_RSDCommand();
       var QueryTxt = "select RSB_PMWRTOFF.RSI_GetLastAccountedFrVal(?,?,?) t_Sum from dual";

       Query.addParam(this.tick.rec.DealID);
       Query.addParam(this.tick.rec.BOfficeKind);
       Query.addParam(pDate);
     
       Data = Query.execute(QueryTxt);
       if( Data.MoveNext() )
          DVSSCost = SQL_ConvTypeSum(Data.Sum);
       end;

       return DVSSCost;
    end;

    macro User_GetDVSSCostOnDate(DVSSCost:@money, _SayError:bool, DVSDate)
      var notetxt, SayError;

      if( _SayError == null )
         SayError = true;
         else
         SayError = _SayError;
      end;

      DVSSCost = GetFrValSumLastOnDate(DVSDate);

      return true;
    end;

    //получить счет ПФИ
    macro GetDV_PFI_ACC(_SayError:bool, AccountBuf:@TRecHandler)
      var SayError;

      if( _SayError == null )
         SayError = true;
      else
         SayError = _SayError;
      end;

      if( (this.tick.rec.IsPFI == SET_CHAR) and (this.tick.rec.OriginID == CodeFor("Ю")) )
         var ObjectID = UniID(this.tick, OBJTYPE_SECDEAL);
         var AccBuf = TRecHandler("account");
         var Query = RSDCommand( " Select t_AttrID " +
                                 "   From dobjlink_dbt " +
                                 "  Where t_ObjectType = ? " +
                                 "    and t_ObjectID   = ? " +
                                 "    and t_AttrType   = ? " +
                                 "    and t_GroupID    = ? " );
     
         Query.addParam( "", RSDBP_IN, OBJTYPE_SECDEAL );
         Query.addParam( "", RSDBP_IN, ObjectID );
         Query.addParam( "", RSDBP_IN, OBJTYPE_ACCOUNT );
         Query.addParam( "", RSDBP_IN, OBJROLE_DEAL_ACCOUNT );
         Query.execute();
     
         var DataSet = TRsbDataSet(Query);
         if( DataSet.MoveNext() and (RestoreFromUniID(DataSet.AttrID, AccBuf, OBJTYPE_ACCOUNT) == true) and (AccBuf.rec.Account != "") )
            if( AccountBuf != null )
               copy(AccountBuf, AccBuf);
            end;
         else
            if( SayError )
               MsgBox("Необходимо задать значение связанного объекта \"Номер счета по учету СС контракта ПФИ\" |" +
                      "для корректного списания справедливой стоимости контракта, результатом исполнения которого является данная сделка");
            end;
            return false;
         end;
      end;

      return true;
    end;

    //Получить минимальную дату комиссии по сделке, с даты.
    //Вход:                                                  
    //  pSinceDate - с даты. Может быть не задана      
    //  pReceiver - получатель. Может быть не задан    
    macro GetMinComPlanDateByDeal( pSinceDate:date, pReceiver:integer )
       return SP_GetMinComPlanDateByDeal(this.tick.rec.BofficeKind,this.tick.rec.DealID,pSinceDate,pReceiver);
    end;

    //Получить ID ТО по комиссии
    macro GetRQByCom(pComID:integer,IsErr:bool)
       var pRQ = TRecHandler( "dlrq" );
       var sql, query, DataSet, sqlNrec, NrecData, Err="";
       query = "select * " +       
               "  from DDLRQ_DBT "+
               " where T_SOURCEOBJKIND = ? "+
               "   and T_SOURCEOBJID = ? "+
               "   and T_TYPE = ?";

       sqlNrec = RSDCommand("select NVL(count(1),0) NRec from("+query+")");

       sqlNrec.addParam( "", RSDBP_IN, DL_SECURITYCOM );
       sqlNrec.addParam( "", RSDBP_IN, pComID );
       sqlNrec.addParam( "", RSDBP_IN, DLRQ_TYPE_COMISS );
       sqlNrec.execute();                                 
       NrecData = TRsbDataSet(sqlNrec);                    
                                                   
       if( NrecData.MoveNext() )
          if( NrecData.NRec == 0 )
             Err = "Не найдено ТО по комиссии с ID "+string(pComID)+" по сделке с кодом "+this.tick.rec.DealCode;
          elif( NrecData.NRec > 1 )
             Err = "Найдено более одного ТО по комиссии с ID "+string(pComID)+" по сделке с кодом "+this.tick.rec.DealCode;
          end;                                           
       else
          Err = "Не найдено ТО по комиссии с ID "+string(pComID)+" по сделке с кодом "+this.tick.rec.DealCode;
       end;                                           

       if( (Err != "") and (IsErr != null) and (IsErr == true) )
          msgbox(Err);
          return pRQ;
       end;

       sql = RSDCommand(query);
       sql.addParam( "", RSDBP_IN, DL_SECURITYCOM );
       sql.addParam( "", RSDBP_IN, pComID );
       sql.addParam( "", RSDBP_IN, DLRQ_TYPE_COMISS );
       sql.execute();                                 
       DataSet = TRsbDataSet(sql);                    

       if( DataSet.MoveNext() )
          DataSet.GetRecord().CopyTo( pRQ.rec );
       end;

       return pRQ;
    end;

    //Проверяет: Есть ли по сделке есть ТО со статусами "Отложено", "Запланировано", "Просрочено", "Исполнение отложено"
    macro ЕстьНеиспТО()
       var sql, DataSet;

       sql = RSDCommand("select count(1) NRec " +       
                        "  from DDLRQ_DBT "+
                        " where T_DOCKIND = ? "+
                        "   and T_DOCID = ? " +
                        "   and (T_STATE = ? or T_STATE = ? or T_STATE = ? or T_STATE = ?)"
                       );

       sql.addParam( "", RSDBP_IN, this.tick.rec.BofficeKind );
       sql.addParam( "", RSDBP_IN, this.tick.rec.DealID );
       sql.addParam( "", RSDBP_IN, DLRQ_STATE_PLAN );
       sql.addParam( "", RSDBP_IN, DLRQ_STATE_OVERDUE );
       sql.addParam( "", RSDBP_IN, DLRQ_STATE_DELAYED );
       sql.addParam( "", RSDBP_IN, DLRQ_STATE_FORPROCESSING );
       sql.execute();                                 
       DataSet = TRsbDataSet(sql);                    

       if( DataSet.MoveNext() and (DataSet.NRec != null) and (DataSet.NRec > 0) )
          return true;
       end;

       return false;
    end;

    macro GetSubContr()
       VAR SfContr = TRecHandler( "sfcontr.dbt" );
       if( (this.tick.rec.ClientContrID > 0) and DL_FindSfContrByOrder(this.tick.rec.ClientContrID, SfContr))
          return sfcontr;
       end;
    end;

    /************************************************/
    /*конструктор класса                            */
    /************************************************/
    MACRO Construct( parm1, parm2, parm3, parm4, CallInclude ) 
       var LegKind;

       this.tick   = TBfile("dl_tick.dbt");         /* сделка */
       this.dl_leg = Trechandler( "dl_leg.dbt"   ); /* параметры сделки          */
//       this.DateArray = TArray();

       /*Конструктор из DocKind, parm2*/
       if( (ValType(parm1)==V_INTEGER) AND (ValType(parm2)==V_INTEGER) )
          /*Это при просмотре счетов
            parm1 - DocKind (может быть LEG_KIND_DL_...  для сделок с обр. частью)
            parm2 - всегда сделка */
          if( parm1 == LEG_KIND_DL_TICK_BACK )
             this.IsBack = true;
          else
             this.IsBack = false;
          end;
          
          this.tick.rec.DealID = parm2;
          if( this.tick.GetEQ() == false ) 
             this.SetError( "Сделка с ID = "+string(parm2)+" не найдена" );
          end;
       else
          /*Конструктор из структур*/
          if( (ValType(parm1) == V_STRUC) OR (ValType(parm1) == V_FILE) OR (ValType(parm1) == V_GENOBJ) ) 
              copy( tick, parm1 );
              if( ValType(parm2) == V_BOOL )
                this.IsBack = parm2;
              else
                this.IsBack = false;
              end;
          /*вариант передачи параметров: DocKind, Doc*/ 
          /* такой вариант вызова получается при получении счета по категории из кода*/
          elif( (ValType(parm1) == V_INTEGER) AND (ValType(parm2) == V_MEMADDR) )
              SetBuff( _dl_tick, parm2 ); 
              copy ( this.tick, _dl_tick );
          else
             this.SetError( "Неверные параметры инициализации объекта" );        
          end; 
       end;

       if( (parm3 == null) OR (parm3 == false) )
          this.FirstInit = false; /*признак первоначальной инициализации объекта в операции*/
       else
          this.FirstInit = true;
       end;
       m_CallInclude = CallInclude;

       /*получаем группу, в которую входит сделка данного вида*/
       /* для дальнейшего использования в вызовах типа IsBUY( FD.Group ) */
       this.Group = SP_GetOperationGroup( this.tick.rec ); 
       if( (IsBACKSALE(this.Group) == true) OR (IsREPO(this.Group) == true) OR (this.tick.rec.BofficeKind == DL_CONVAVR) )
          this.ExistBack  = true;
          this.IsOperLOAN = false;
       else 
          this.ExistBack  = false;
          this.IsOperLOAN = IsLOAN( this.Group );
       end;
       this.BuySale = GetDealBuySale( this.tick.rec, this.IsBack);

       if( this.IsBack == true )
          this.StrClassName = " для обратной части сделки ";
          if( this.IsOperLOAN == true ) /*в займе всегда только один dl_leg*/
             LegKind = LEG_KIND_DL_TICK;
          else
             LegKind = LEG_KIND_DL_TICK_BACK;
          end;
       else
          this.StrClassName= " для сделки ";
          LegKind = LEG_KIND_DL_TICK;
       end;

       StrClassName =   StrClassName
                        + "|с кодом " + string(this.tick.rec.DealCode)+ " ";

       if( parm4 == null ) /*dl_leg явно не передали, пытаемся его найти*/ 
          /*пытаемся найти параметры сделки, возможно их еще не вставили (например на вводе)*/
          /* поэтому ошибки поиска не обрабатываем */
          FindDL_LEG( LegKind, this.tick.rec.DealID, 0, this.dl_leg );
       else
          if( (ValType(parm4) == V_STRUC) OR (ValType(parm4) == V_FILE) OR (ValType(parm4) == V_GENOBJ) ) 
             copy( this.dl_leg, parm4 );  
          else
             this.SetError( "Неверный тип параметра инициализации объекта - условия сделки" );        
          end; 
       end; 

       /*для конвертаций всегда по сделке*/
       if( (this.ExistBack == true) AND (this.tick.rec.BOfficeKind != DL_CONVAVR) )
          this.Kind = DL_SECURLEG;
          this.ID   = this.dl_leg.rec.Id;
       else
          this.Kind = this.tick.rec.BOfficeKind;
          this.ID   = this.tick.rec.DealID;
       end;

       /*инициализация массивов с параметрами сделки*/
       this.InitFIRoleBArray();
       this.InitParmArray();
    END;

    macro SetFIIDForCorAccNum(pFIIDCorAcc:integer)
       v_FIIDCorAcc = pFIIDCorAcc;
    end;

    macro GetFIIDForCorAccNum()
       return v_FIIDCorAcc;
    end;

    macro GetRQOnGrDealID( Type, GrDealID )
      var query, cmd, DataSet, v_dlrq;
   
      v_dlrq = this.GetRQ(Type);

      if( GrDealID == null )
         return v_dlrq;
      end;

      query = " select bc.* "
             +"   from ddlrqbc_dbt bc, ddlgracc_dbt gracc "
             +"  where gracc.t_GrDealID = ? "
             +"    and gracc.t_AccNum = " + DLGR_ACCKIND_BACKOFFICE
             +"    and BC.T_RQID = ? " 
             +"    and BC.T_ID_OPERATION = gracc.T_ID_OPERATION "
             +"    and BC.T_ID_STEP = gracc.T_ID_STEP "
             +"    and BC.T_INSTANCE = (select max(BC_1.T_INSTANCE ) from ddlrqbc_dbt bc_1 "
             +"                          where BC_1.T_RQID = BC.T_RQID "
             +"                            and BC_1.T_ID_OPERATION = BC.T_ID_OPERATION "
             +"                            and BC_1.T_ID_STEP = BC.T_ID_STEP "
             +"                        ) ";
   
      cmd = DL_RSDCommand(query);
      cmd.AddParam(GrDealID);
      cmd.AddParam(v_dlrq.rec.ID);
      
      DataSet = cmd.Execute();
      if(DataSet.moveNext)
         v_dlrq.rec.ID_Operation = DataSet.ID_Operation;
         v_dlrq.rec.ID_Step      = DataSet.ID_Step;
         v_dlrq.rec.Action       = DataSet.Action;
         v_dlrq.rec.Instance     = DataSet.Instance;
         v_dlrq.rec.ChangeDate   = SQL_ConvTypeDate(DataSet.ChangeDate);
         v_dlrq.rec.Amount       = DataSet.Amount;
         v_dlrq.rec.Kind         = DataSet.Kind;
         v_dlrq.rec.Party        = DataSet.Party;
         v_dlrq.rec.RqAccID      = DataSet.RqAccID;
         v_dlrq.rec.PlaceID      = DataSet.PlaceID;
         v_dlrq.rec.State        = DataSet.State;
         v_dlrq.rec.PlanDate     = SQL_ConvTypeDate(DataSet.PlanDate);
         v_dlrq.rec.FactDate     = SQL_ConvTypeDate(DataSet.FactDate);
         v_dlrq.rec.Netting      = DataSet.Netting;
      end;

      return v_dlrq;
    end;

    macro ВыполненаПереоценкаСС( pDate:DATE, pFrVal:TrecHandler ):BOOL
       VAR FrVal = TRecHandler("dvnfrval");
   
       if( FindDVNFRVAL( this.tick.rec.DealID, this.tick.rec.BOfficeKind, pDate, FrVal) != 0 )
          return false;
       end;
   
       if( pFrVal != NULL )
          Copy( pFrVal, FrVal );
       end;
       return true;
    end;
   
    //Проверить, является ли код пула пулом
    MACRO PoolCodeIsPool(pool_code:string)
      if((pool_code == "10") or (pool_code == "11") or (pool_code == "12") or (pool_code == "13"))
        return true;
      end;

      return false;
    END;

    macro GetPoolCode():string
      var pool_code = "";
      
      var query =   " select o.t_officecode "
                + "   from dptoffice_dbt o "  
                + "  where o.t_partyid = ? " 
                + "    and o.t_officeid = ? ";
      var cmd = DL_RSDCommand(query);

      cmd.AddParam(this.tick.rec.TraderID);
      cmd.AddParam(this.tick.rec.MarketOfficeID);
      var data_set = cmd.Execute();
      if (data_set.moveNext())
        pool_code = SQL_ConvTypeStr(data_set.t_officecode);
        if(strlen(pool_code) == 1)
          pool_code = "0" + pool_code;
        elif(strlen(pool_code) > 2)
          pool_code = substr(pool_code, strlen(pool_code) - 2);
        end;
      end;
        
      if(this.PoolCodeIsPool(pool_code) == false)
        pool_code = "00";
      end;

      return pool_code;
    end;
   
    initSPFirst();
    this.Construct( parm1, parm2, parm3, parm4, CallInclude );
END;


/**************************************************************************/
/*  класс - первичные документы для работы с категориями учета            */ 
/*    для операций NPTXOP                                           */
/**************************************************************************/
CLASS (SPFirst) DLFirstDocNPTXOP( parm1, parm2 )

    VAR nptxop  = TBfile("nptxop.dbt");  /* операция */
    
    var paym = TBFile("pmpaym.dbt");
    var dlrq = TRecHandler("dlrq.dbt");
    var rqacc = TRecHandler("dlrqacc.dbt");
    var SfContr_from = TRecHandler("sfcontr.dbt");
    var SfContr_to = TRecHandler("sfcontr.dbt");

    /************************************************/
    /* инициализация массива параметров              */
    /************************************************/
    PRIVATE MACRO InitParmArray
       
        ParmA[MC_TYPE_PARAMETR_DOCKIND]      = this.Kind;
        ParmA[MC_TYPE_PARAMETR_DOCID]        = this.ID;
        ParmA[MC_TYPE_PARAMETR_FIID]         = this.nptxop.rec.Currency;
        ParmA[MC_TYPE_PARAMETR_PAYCURRENCY]  = this.nptxop.rec.Currency;
        ParmA[MC_TYPE_PARAMETR_CURRENCY]     = this.nptxop.rec.Currency;
        ParmA[MC_TYPE_PARAMETR_DEPARTMENT]   = {OperDprt};
    END;

    MACRO InitFIRoleBArray
       FIRoleBArray[0] = FIROLE_BA;  /* Базовый актив*/
    END;

    /*Получить параметры шаблона                    */
    MACRO GetParametrTemplate
    ( 
        ObjectID,       /*   параметр - номер справочника                 */
        Classificator,  /*   классификатор - номер классификатора, если он задан */
        OperDate,       /*   дата, на которую надо вернуть характеристики*/
        FIRole
    )         
      var Parametr = -1;           /*по умолчанию*/
      var RunFromBO;

      /*Вид обсл нужен для операции списание\зачисление\переаод ДС (БОЦБ или ПИ)*/
      if( (ObjectID == OBJTYPE_SERVKIND) AND (Classificator == LLCLASS_SERVKIND_INNER) )
        var sfcontr = TRecHandler("sfcontr.dbt");
        if( nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC )
          if( FIRole == FIROLE_BA )
            sfcontr = SfContr_from;
          elif( FIRole == FIROLE_CA )
            sfcontr = SfContr_to;
          end;
        else 
          sfcontr = this.GetSubContr();
        end;

        if (ДоговорЕДП(null, sfcontr.rec.ID));
          Parametr = 7;
        else
          Parametr = this.GetParmByServKind(sfcontr.rec.ServKind);
        end;

        return Parametr;
      end;

      return MC_GetParametrTemplate( this, ObjectID, Classificator, OperDate, FIRole );
    END;

    /************************************************/
    /*Получить параметры                            */
    /************************************************/
    MACRO GetParametr( ParmKind, OperDate, CatCode, FIRole )

     VAR Parametr = ParmA[ParmKind];
     if (Parametr == null)               
                                   
       /*размещение*/
       if( (ParmKind == MC_TYPE_PARAMETR_PLACE) ) 
          if(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC)
            if(FIRole == FIROLE_BA)
              Parametr = nptxop.rec.Place;
            elif(FIRole == FIROLE_CA)
              Parametr = nptxop.rec.Place2;
            end;
          else
          Parametr = nptxop.rec.Place;
          end;
        /* договор обслуживания клиента */
       elif( ParmKind == MC_TYPE_PARAMETR_CONTR_CLIENT) 
          if(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC)
            if(FIRole == FIROLE_BA)
              Parametr = SfContr_from.rec.ID;
            elif(FIRole == FIROLE_CA)
              Parametr = SfContr_to.rec.ID;
            end;
          else
          Parametr = nptxop.rec.Contract;
          end;
        /* владелец                         */
       elif( ParmKind == MC_TYPE_PARAMETR_OWNER)
          Parametr = nptxop.rec.Client; 
       /*валюта расчетов*/
       elif( ParmKind == MC_TYPE_PARAMETR_PAYCURRENCY )
          Parametr = nptxop.rec.Currency; 
       /*торговая площадка*/
       elif( ParmKind == MC_TYPE_PARAMETR_MARKET_PLACE )     
          if(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC)
            if(FIRole == FIROLE_BA)
              Parametr = IIF(nptxop.rec.MarketPlace == -1, 0, nptxop.rec.MarketPlace);
            elif(FIRole == FIROLE_CA)
              Parametr = IIF(nptxop.rec.MarketPlace2 == -1, 0, nptxop.rec.MarketPlace2);
            end;
          else
          Parametr = 0;
          end;
       /*сектор организатора торговли*/
       elif( ParmKind == MC_TYPE_PARAMETR_MARKET_PLACE_OFFICE )
          if(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC)
            if(FIRole == FIROLE_BA)
              Parametr = nptxop.rec.MarketSector;
            elif(FIRole == FIROLE_CA)
              Parametr = nptxop.rec.MarketSector2;
            end;
          else
          Parametr = 0;
          end;
       elif( (ParmKind == MC_TYPE_PARAMETR_PARTY) OR (ParmKind == MC_TYPE_PARAMETR_CONTRACTOR) )
          if( (v_CatCode == "Счет МФР для возврата") AND (nptxop != NULL) AND (nptxop.rec.DocKind == DL_HOLDNDFL) AND (nptxop.rec.SubKind_Operation == DL_TXHOLD_OPTYPE_TAXREF) )
            var queryDep = " select dep.t_PartyID Depid " +
                           " from dsettacc_dbt settacc, ddp_dep_dbt dep " +
                           " where dep.t_partyId = settacc.t_BankID "+
                           "  and settacc.t_Account = ? ";
            var cmdDep = RSDCommand(queryDep);
            cmdDep.AddParam("", RSDBP_IN, nptxop.rec.Account);

            var rsDep = TRsbDataSet(cmdDep);
            if(rsDep.MoveNext())
              Parametr = rsDep.DepID;
            end;
          else
            Parametr = -1; 
          end;
       else
          Parametr = -1;
       end;
     end;
     return Parametr;

    END;

    /************************************************/
    /*конструктор класса                            */
    /************************************************/
    MACRO Construct( parm1, parm2 ) 

       ClearRecord(nptxop);

       /*Конструктор из DocKind, parm2*/
       if ( (ValType(parm1)==V_INTEGER) AND (ValType(parm2)==V_INTEGER) )
           nptxop.rec.ID = parm2;
           if( nptxop.GetEQ == false ) 
              this.SetError( "Операция не найдена" );
           end;
       else
          /*Конструктор из структур*/
          if( (ValType(parm1) == V_STRUC) OR (ValType(parm1) == V_FILE) OR (ValType(parm1) == V_GENOBJ) ) 
              copy ( nptxop, parm1 );
          elif( ( (parm1 == NULL) OR (ValType(parm1) == V_INTEGER)) AND 
                (ValType(parm2) == V_MEMADDR) 
              )
             /* такой вариант вызова получается при получении счета по категории из кода*/
             nptxop.SetRecordAddr( parm2 );
          else
             this.SetError( "Неверные параметры инициализации объекта" );        
          end; 
       end;

       /*получаем группу, в которую входит сделка данного вида*/
       /* для дальнейшего использования в вызовах типа IsBUY( FD.Group ) */
       this.ID   = nptxop.rec.ID;
       this.Kind = nptxop.rec.DocKind;


       var Select = Dl_RSDCommand(" select * from ddlrqacc_dbt where t_dockind = ? and t_docid = ? ");
       Select.AddParam(nptxop.rec.dockind);
       Select.AddParam(nptxop.rec.id);

       var DataSet = Select.Execute();
       if(DataSet.moveNext())
         DataSet.GetRecord().CopyTo( rqacc.rec );
       end;

       Select = Dl_RSDCommand(" select * from dpmpaym_dbt where t_dockind = ? and t_documentid = ? and t_purpose = 1");
       Select.AddParam(nptxop.rec.dockind);
       Select.AddParam(nptxop.rec.id);

       DataSet = Select.Execute();
       if(DataSet.moveNext())
         DataSet.GetRecord().CopyTo( paym.rec );
       end;

       InitParmArray(); /*инициализация массива параметров*/
       InitFIRoleBArray();

       if( nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC )
         this.Init_TBSABC();
       end;
    END;

    MACRO ВУ_СкорректироватьРесчетнуюОперацию(ВидРО, InnAcc:@VARIANT)
      var cmd, DataSet;

      if(nptxop.rec.DocKind == DL_WRTMONEY)
        cmd = Dl_RSDCommand(" SELECT grnd.t_Kind, grnd.t_AltXld " +
                            "   FROM dspground_dbt grnd " +
                            "  WHERE grnd.t_SpGroundID = (SELECT MIN(doc.t_SpGroundID) " +
                            "                               FROM dspgrdoc_dbt doc " +
                            "                              WHERE doc.t_SourceDocKind = ? " +
                            "                                AND doc.t_SourceDocID = ? " +
                            "                            )");
        cmd.AddParam(nptxop.rec.DocKind);
        cmd.AddParam(nptxop.rec.ID);

        DataSet = cmd.Execute();
        if(DataSet.moveNext())
          InnAcc.GroundKind = DataSet.Kind;
          InnAcc.GroundNum = DataSet.AltXld;
        end;
      end;

      return 0;
    END;

    MACRO ВУ_ПолучитьРольФИ( ВидРО, DebCred )
      var FIRole = FIROLE_UNDEF;
         
        if((ВидРО == 7) or (ВидРО == 6) or (ВидРО == 22) or (ВидРО == 23) or (ВидРО == 24) or (ВидРО == 106))
          FIRole = FIROLE_BA;
        elif(ВидРО == 36)
          if(DebCred)
            FIRole = FIROLE_CA;
          else
            FIRole = FIROLE_BA;
          end;
        elif(ВидРО == 37)
          if(DebCred)
            FIRole = FIROLE_BA;
          else
            FIRole = FIROLE_CA;
          end;
        end;
      return FIRole;
    END;

    macro ВУ_ПолучитьКатегориюДебет( ВидРО, ReturnIncomeKind_ )
      var Категория = "";

       if((ВидРО == 6) or (ВидРО == 36) or (ВидРО == 22) or (ВидРО == 23) or (ВидРО == 24) or (ВидРО == 106))
         Категория = "ДС Клиента, ВУ";
       elif((ВидРО == 7) or (ВидРО == 37))
         Категория = "ДС, Расч. с клиентом, ВУ";
       elif((ВидРО == 17) and (ReturnIncomeKind_))
         Категория = "ДС Клиента, ВУ";
       elif(ВидРО == 17)
         Категория = "ДС, Расч. с клиентом, ВУ";
       elif((ВидРО == 101) or (ВидРО == 102))
         Категория = "ДС, Расч. с клиентом, ВУ";
       end;

       return Категория;
    end;

    macro ВУ_ПолучитьКатегориюКредит( ВидРО, ReturnIncomeKind_ )
      var Категория = "";
       
       if((ВидРО == 6) or (ВидРО == 37) or (ВидРО == 22) or (ВидРО == 23) or (ВидРО == 24) or (ВидРО == 106))
         Категория = "ДС, Расч. с клиентом, ВУ";
       elif((ВидРО == 7) or (ВидРО == 36))
         Категория = "ДС Клиента, ВУ";
       elif((ВидРО == 17) and (ReturnIncomeKind_))
         Категория = "ДС, Расч. с клиентом, ВУ";
       elif(ВидРО == 17)
         Категория = "ДС Клиента, ВУ";
       elif((ВидРО == 101) or (ВидРО == 102))
         Категория = "ДС Клиента, ВУ";
       end;
       
       return Категория;
    end;

    macro ВУ_ОснованиеПроводки( ВидРО )
      var Ground = "";
                     
       if((ВидРО == 6) or (ВидРО == 22) or (ВидРО == 23) or (ВидРО == 24) or (ВидРО == 106))
          Ground = "Зачисление денежных средств по операции "+nptxop.rec.Code;
       elif(ВидРО == 7)
          Ground = "Списание денежных средств по операции "+nptxop.rec.Code;
       elif(ВидРО == 36)
          Ground = "Перевод между субсчетами ДБО по операции "+nptxop.rec.Code; /*по активным счетам ВУ*/
       elif(ВидРО == 37)
          Ground = "Перевод между субсчетами ДБО по операции "+nptxop.rec.Code; /*по пассивным счетам ВУ*/
       elif(ВидРО == 17)
          Ground = "Удержание/Возврат налога по операции "+nptxop.rec.Code; 
       elif(ВидРО == 101)
          Ground = "Комиссия за вывод денежных средств с Брокерского счета по Соглашению об оказании брокерских услуг № " + this.GetSubContr().rec.Number + " от " + string(this.GetSubContr().rec.DateBegin:f);
       elif(ВидРО == 102)
          Ground = "Комиссия за зачисление денежных средств на Брокерский счет по Соглашению об оказании брокерских услуг № " + this.GetSubContr().rec.Number + " от " + string(this.GetSubContr().rec.DateBegin:f);
       end;

       return Ground;
    end;

    macro ВУ_ПолучитьВидРО():integer
      var cmd, DataSet;

      if(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_ENROL) //зачисление
        cmd = Dl_RSDCommand(" SELECT LOWER(u.t_Ground) Ground " +
                            "   FROM usr_acc306enroll_dbt u " +
                            "  WHERE u.t_NptxOpID = ? ");
        cmd.AddParam(nptxop.rec.ID);

        DataSet = cmd.Execute();
        if(DataSet.moveNext())
          if(Index(DataSet.Ground, "купон") > 0)
            return 22;
          elif(Index(DataSet.Ground, "погашение") > 0)
            return 23;
          elif(Index(DataSet.Ground, "дивиденды") > 0)
            return 24;
          elif(Index(DataSet.Ground, "выплата по кд") > 0)
            return 106;
          end;  
        end;
        return 6;
      elif(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_WRTOFF) //списание
        return 7;
      elif(nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC) //Перевод между субсчетами ДБО
        return 36;
      end;

      return 0;
    end;

    //Simanov
    macro DBOName ():variant
      var cmd, DataSet, DboName = "";
      var query = "select sf.* from ddlcontrmp_dbt mp, ddlcontr_dbt dl, dsfcontr_dbt sf "
                + "where mp.t_sfcontrid = ? and dl.t_dlcontrid = mp.t_dlcontrid and sf.t_id = dl.t_sfcontrid";
      cmd = DL_RSDCommand(query);
      cmd.AddParam(nptxop.rec.Contract);

      DataSet = cmd.Execute();
      if( DataSet.moveNext )
         DboName = SQL_ConvTypeDate(DataSet.Name);
      end;

      return DboName;
    End;
    // Вид обслуживания для перевода между субсчетами ДБО
    macro GetParmByServKind( pServKind )
      if( pServKind == PTSK_STOCKDL )
        return 1;
      elif( pServKind == PTSK_DV )
        return 3;
      elif( pServKind == PTSK_CM )
        return 6;
      else
        return -1;
      end;
    end;

    //для переводов инициализируется в Init_TBSABC
    macro GetSubContr()
      if ( (SfContr_from.rec.ID == 0) and (nptxop.rec.Contract > 0) )
        DL_FindSfContrByOrder( nptxop.rec.Contract, SfContr_from);
      end;

      return SfContr_from;
    end;

    //Счёт зачисления в операции перевода. Инициализируется в Init_TBSABC
    macro GetSubContrTo()
      return SfContr_to;
    end;

    macro ПолучитьДоговорОбслуживанияКлиентаПоСчету( pSfContr, pAccount, pCurrency, pChapter )
      var stat = 0;
      var sql = " select sfcontr.* " +
                "   from dmcaccdoc_dbt accdoc, dsfcontr_dbt sfcontr " +
                "  where accdoc.t_Account = ? " +
                "    and accdoc.t_Currency = ? " +
                "    and accdoc.t_Chapter = ? " +
                "    and accdoc.t_ClientContrID = sfcontr.t_ID ";

      var cmd = DL_RSDCommand(sql);
      cmd.AddParam(pAccount);
      cmd.AddParam(pCurrency);
      cmd.AddParam(pChapter);

      var ds = cmd.Execute();
      if( ds.moveNext )
        pSfContr.Clear();
        ds.GetRecord().CopyTo( pSfContr.rec );
      else
        stat = 1;
      end;

      return stat;
    end;

    // Для перевода между субсчетами ДБО
    macro Init_TBSABC()
      var stat = 0;
      ПолучитьДоговорОбслуживанияКлиентаПоСчету( SfContr_from, nptxop.rec.Account, nptxop.rec.Currency, 1/*CHAPT1*/ );

      if( ПолучитьТОпоДокументу(nptxop.rec.DocKind, nptxop.rec.ID, 1, DLRQ_TYPE_PAYMENT, 0, dlrq) )
        stat = ПолучитПлатежныеРеквизитыПоТО(DlRq, rqacc);

        if(not stat)
          ПолучитьДоговорОбслуживанияКлиентаПоСчету( SfContr_to, rqacc.rec.Account, nptxop.rec.Currency, 1/*CHAPT1*/ );
        end;
      else
        paym.AddFilter("t_DocKind = " + nptxop.rec.DocKind + " and t_DocumentID = " + nptxop.rec.ID + " and t_Purpose = " + BAi);

        if( paym.Next() )
          if (StrLen(paym.rec.ReceiverAccount) > 0)
            ПолучитьДоговорОбслуживанияКлиентаПоСчету( SfContr_to, paym.rec.ReceiverAccount, nptxop.rec.Currency, 1/*CHAPT1*/ );
          end;
        else
          msgbox("Не найден платеж по операции " + nptxop.rec.Code);
        end;

        paym.DropFilter();
      end;
    end;

    initSPFirst();
    this.Construct( parm1, parm2 );
END;
