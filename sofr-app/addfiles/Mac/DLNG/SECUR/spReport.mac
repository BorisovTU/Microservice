/*******************************************************************************
 FILE         :   SPREPORT.MAC

 COPYRIGHT    :   R-Style, 1998

 DESCRIPTION  :   RS-Bank, БО ЦБ, общеупотребимые классы для генерации отчетов

 PROGRAMMED BY:   Alex Kormukhin

 CREATION DATE:   16.09.1998
*******************************************************************************/

 import spOOP;

  /* !!! Внимание !!! Все свойства и методы начинающиеся с подчеркивания
   *                  в классах потомках использовать без санкции запрещается!
   *                  Переопределять do не рекомендуется, если там не хватает
   *                  функциональности для какой-то таблицы, лучше подумать
   *                  насчет включения ее (функциональности) в базовый класс.
   */

  /* такими будут рамки */
  var tblLU="┌", tblMU="┬", tblRU="┐",
      tblLM="├", tblMM="┼", tblRM="┤",
      tblLL="└", tblML="┴", tblRL="┘",
      tblHLine="─",
      tblVLine="│";

  macro PrintRepeat(c,w)
    var i=0;
    while(i < w)
      print(c);
      i=i+1;
    end;
  end;

  macro СтрокуДатыНадоИсправлять(str:string)
    if (strlen(str) != 10)      return false; end;
    if (substr(str,1,1) != " ") return false; end;
    if (substr(str,3,1) != ".") return false; end;
    if (substr(str,6,1) != ".") return false; end;
    if ((int(substr(str,2,1)) <0) or (int(substr(str,2,1)) >9)) return false; end;
    if ((int(substr(str,4,2)) <0) or (int(substr(str,4,2)) >12)) return false; end;
    if ((int(substr(str,7,4)) <0) or (int(substr(str,7,4)) >9999)) return false; end;
    return true;
  end;

  macro PrintAligned(width,align,trunc,str:string)
    var l=strlen(str);
/*      if(l > width)
      return _truncIf(str); end;*/
    var indent=0;
    if(align != 0)
      indent=abs(align) - 1; end;
    if((l + indent > width) AND trunc)
      str=substr(str,1,width-indent); end;

    if (СтрокуДатыНадоИсправлять(str) == true)
      str = "0"+substr(str,2);
    end;

/*    l=strlen(str);*/
/*    if((l + indent > width) AND trunc)
      indent=width - l; end;*/
    if(align < 0)                           /* left */
      PrintRepeat(" ",indent);
      print(str);
      PrintRepeat(" ",width - l - indent);
/*      return _truncIf(MkStr(" ",indent) + str + MkStr(" ",width - l - indent));*/
    elif(align == 0)                        /* center */
      PrintRepeat(" ",(width-l)/2);
      print(str);
      PrintRepeat(" ",width - l - (width-l)/2);
/*      return _truncIf(MkStr(" ",(width-l)/2) + str + MkStr(" ",width - l - (width-l)/2));*/
    else                                    /* right */
      PrintRepeat(" ",width - l - indent);
      print(str);
      PrintRepeat(" ",indent);
/*      return _truncIf(MkStr(" ",width - l - indent) + str + MkStr(" ",indent));*/
    end;
  end;

  macro GetLeftBorderSymbol(printUpLine:bool,printLeftLine:bool,cornerSymbol:bool)
    if(cornerSymbol)
      if(printUpLine)
        if(printLeftLine)
          return tblMM;
        else
          return tblLM; end;
      else
        if(printLeftLine)
          return tblMU;
        else
          return tblLU; end;
      end;
    else
      if(printLeftLine)
        return tblRM;
      else
        return tblVLine; end;
    end;
  end;

  macro GetRightBorderSymbol(printUpLine:bool,printLeftLine:bool)
    if(printUpLine)
      if(printLeftLine)
        return tblRM;
      else
        return tblVLine; end;
    else
      if(printLeftLine)
        return tblRU;
      else
        return " ";
/*        RunError("GetRightBorderSymbol ???"); */end;
    end;
  end;


  class TColumnBase(__id)
    var id=__id; /* Идентификатор столбца */
  end; /* class TColumnBase */

  class(TColumnBase) THeaderColumnBase(__id,p1)
    InitTColumnBase(__id);
    var _visible:bool=true,      /* Признак отображать столбец или нет */
        _headerHeight:integer=0, /* Кол-во строк в заголовке           */
        _headerTxt=TArray,       /* Массив строк текста заголовка      */
        _alignmentHdr:integer=0; /* Выравнивание текста заголовка: < 0 - влево, == 0 - по центру, > 0 - вправо. (abs(alignment)-1) - задает кол-во пробелов для отступа с соответствующей выравниванию стороны */

    macro visible(b):bool
      var old=_visible;
      if(ValType(b) == V_BOOL)
        _visible=b; end;
      return old;
    end;

    macro alignmentHdr(i)
      var old=_alignmentHdr;
      if(ValType(i) == V_INTEGER)
        _alignmentHdr=i; end;
      return old;
    end;

    macro width()
    end;

    macro headerHeight()
      return _headerHeight;
    end;

    macro FillWidth(c)
      PrintRepeat(c,width);
    end;

    macro PrintHeaderLine(iHL,printUpLine:bool,printLeftLine:bool)
      if(iHL < 0)
        print(GetLeftBorderSymbol(printUpLine,printLeftLine,true));
        FillWidth(tblHLine);
        printLeftLine=true;
      elif(iHL < _headerTxt.size)
        print(GetLeftBorderSymbol(printUpLine,printLeftLine,false));
        PrintAligned(width,_alignmentHdr,false,_headerTxt(iHL));
        printLeftLine=false;
      else
        print(GetLeftBorderSymbol(printUpLine,printLeftLine,false));
        FillWidth(" ");
        printLeftLine=false;
      end;
      return printLeftLine;
    end;

    macro PrintRightBorderSymbol(iHL,printUpLine,printLeftLine)
      print(GetRightBorderSymbol(printUpLine,printLeftLine));
    end;

  /* Constructor */
    _headerTxt.size=0;
    if(ValType(p1) == V_INTEGER)
      if(p1 >= 0)
        _headerHeight=p1; end;
      while((_headerTxt.size < _headerHeight) AND GetParm(3 + _headerTxt.size,p1) AND (ValType(p1) != V_UNDEF))
        _headerTxt(_headerTxt.size)=p1; end;
    elif(ValType(p1) != V_UNDEF)
      _headerTxt(_headerTxt.size)=p1;
      while(GetParm(2 + _headerTxt.size,p1) AND (ValType(p1) != V_UNDEF))
        _headerTxt(_headerTxt.size)=p1; end;
      _headerHeight=_headerTxt.size;
    end;
  end; /* class THeaderColumnBase */

  class(THeaderColumnBase) TColumnUnionBase(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTHeaderColumnBase(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);
  end; /* class TColumnUnionBase */

  class(THeaderColumnBase) TUniqueColumnBase(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTHeaderColumnBase(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);

    /* Sequence area: */
    macro IsAuto():bool
      return false;
    end;
  end; /* class TUniqueColumnBase */


  class(TColumnUnionBase) TColumnUnion(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTColumnUnionBase(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);
    var _columnArray=TArray;

    macro AddColumn(col:THeaderColumnBase)
      _columnArray(_columnArray.size)=col;
    end;

    macro size()
      return _columnArray.size;
    end;

    macro FirstColumn()
      return _columnArray(0);
    end;

    macro LastColumn()
      return _columnArray(_columnArray.size - 1);
    end;

    macro Column(i:integer)
      return _columnArray(i);
    end;

    macro ColumnById(__id)
      if(id() == __id)
        return this; end;
      var i=0,v;
      while(i < _columnArray.size)
        v=_columnArray(i).ColumnById(__id);
        if(ValType(v) != V_UNDEF)
          return v; end;
        i=i+1;
      end;
    end;

    macro width()
      var w=-1,i=0;
      while(i < _columnArray.size)
        if(_columnArray(i).visible())
          w=w + _columnArray(i).width + 1; end;
        i=i+1;
      end;
      return w;
    end;

    macro headerHeight()
      var i=0,hh=0,hh2;
      while(i < _columnArray.size)
        if(_columnArray(i).visible())
          hh2=_columnArray(i).headerHeight;
          if(hh < hh2)
            hh=hh2; end;
        end;
        i=i+1;
      end;
      return _headerHeight + hh + 1;
    end;

    macro PrintHeaderLine(iHL,printUpLine:bool,printLeftLine:bool)
      var i=0;
      if(iHL < _headerHeight)
        return PrintHeaderLine(iHL,printUpLine,printLeftLine);
      else
        printUpLine=true;
        while(i < _columnArray.size)
          if(_columnArray(i).visible())
            printLeftLine=_columnArray(i).PrintHeaderLine(iHL-_headerHeight-1,printUpLine,printLeftLine);
            printUpLine=false;
          end;
          i=i+1;
        end;
      end;
      return printLeftLine;
    end;

    macro PrintRightBorderSymbol(iHL,printUpLine,printLeftLine)
      if(iHL < _headerHeight)
        return PrintRightBorderSymbol(iHL,printUpLine,printLeftLine); end;
      var i=_columnArray.size - 1;
      while((i >= 0) AND (NOT _columnArray(i).visible()))
        i=i-1; end;
      _columnArray(i).PrintRightBorderSymbol(iHL-_headerHeight-1,printUpLine,printLeftLine);
    end;

    macro AddUniqueColumnsToArray(arr)
      var i=0;
      while(i < _columnArray.size)
        if(_columnArray(i).visible())
          _columnArray(i).AddUniqueColumnsToArray(arr); end;
        i=i+1;
      end;
    end;

  /* Constructor */
    p1=0;
    while(GetParm(2 + p1,p2) AND (ValType(p2) != V_GENOBJ))
      p1=p1+1; end;
    while(GetParm(2 + p1,p2) AND (ValType(p2) == V_GENOBJ))
      AddColumn(p2);
      p1=p1+1;
    end;
  end; /* class TColumnUnion */

  class(TColumnUnion) TUnborderedColumnUnion(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTColumnUnion(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);

    macro headerHeight()
      return headerHeight() - 1;
    end;

    macro PrintHeaderLine(iHL,printUpLine:bool,printLeftLine:bool)
      iHL=iHL+1;
      var i=0;
      printUpLine=false;
      if(iHL < _headerHeight)
        if(iHL < 0)
          print(" ");
          FillWidth(" ");
        elif(iHL < _headerTxt.size)
          print(" ");
          PrintAligned(width,_alignmentHdr,false,_headerTxt(iHL));
        else
          print(" ");
          FillWidth(" ");
        end;
        printLeftLine=false;
      else
        while(i < _columnArray.size)
          if(_columnArray(i).visible())
            printLeftLine=_columnArray(i).PrintHeaderLine(iHL-_headerHeight-1,false,printLeftLine);
          end;
          i=i+1;
        end;
      end;
      return printLeftLine;
    end;

    macro PrintRightBorderSymbol(iHL,printUpLine,printLeftLine)
      PrintRightBorderSymbol(iHL+1,printUpLine AND (iHL >= _headerHeight),printLeftLine);
    end;
  end; /* class TUnborderedColumnUnion */


  class(TUniqueColumnBase) TColumn(__id,w,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTUniqueColumnBase(__id,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);
    var _width:integer=1,       /* все переменные private, для установки соотв. значений необходимо использовать соотв. ф-ции!!! */
        _alignment:integer=0,   /* Выравнивание строк: < 0 - влево, == 0 - по центру, > 0 - вправо. (abs(alignment)-1) - задает кол-во пробелов для отступа с соответствующей выравниванию стороны */
        _truncate:bool=true;    /* Признак усекать строки, если они шире столбца, или нет */

    /* public: */
    macro ColumnById(__id)
      if(id() == __id)
        return this; end;
    end;

    macro width()
      return _width;
    end;

    /* protected: */
    macro AddUniqueColumnsToArray(arr)
      arr(arr.size)=this;
    end;

    /* public Sequence area: */
    macro PrintLine(str)
      PrintAligned(_width,_alignment,_truncate,str);
    end;

    macro alignment(i)
      var old=_alignment;
      if(ValType(i) == V_INTEGER)
        _alignment=i; end;
      return old;
    end;

    macro truncate(b)
      var old=_truncate;
      if(ValType(b) == V_BOOL)
        _truncate=b; end;
      return old;
    end;

  /* Constructor */
    if((ValType(w) == V_INTEGER) AND (w > 0))
      _width=w; end;
  end; /* class TColumn */

  class(TColumn) TAutoColumn(__id,_fieldName,w,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTColumn(__id,w,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);
    var fieldName=_fieldName; /* Имя поля записи для автоотображения */

    /* Sequence area: */
    macro PrintLine(rec)
      var str,i;
      if(ValType(rec) == V_GENOBJ)
        str=GenGetProp(rec,fieldName);
      elif((ValType(rec) == V_STRUC) OR (ValType(rec) == V_FILE))
        i=FldIndex(rec,fieldName);
        if(i < 0)
          str=fieldName;
        else
          str=rec(i); end;
      else
        str=rec;
      end;
      PrintAligned(_width,_alignment,_truncate,string(str));
    OnError(x)
/*      println(x.code);*/
      if((x.code != 58) AND (x.code != 42)) /* Нет заданного поля у объекта */
        return RunError(); end;
      PrintAligned(_width,_alignment,_truncate,string(fieldName));
    end;

    macro IsAuto():bool
      return true;
    end;
  end; /* class TAutoColumn */


  class(TUnborderedColumnUnion) TTableHeader(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTUnborderedColumnUnion("",p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);

    macro headerHeight()
      return headerHeight();
    end;

    macro PrintHeaderLine(iHL,printUpLine:bool)
      if(size() < 1)
        RunError("No Cols"); end;
      var printLeftLine:bool=false;
      printLeftLine=PrintHeaderLine(iHL,printUpLine,printLeftLine);
      PrintRightBorderSymbol(iHL,printUpLine,printLeftLine);
      return printLeftLine;
    end;

    macro PrintHeader()
      var iHL=-1;
      var hh=headerHeight();
      var printUpLine:bool=false;
      while(iHL < hh)
        PrintHeaderLine(iHL,printUpLine);
        println("");
        iHL=iHL+1;
        printUpLine=true;
      end;
    end;
  end; /* class TTableHeader */


  class TSequenceColumns(__uniqueColumnArray)
    var _uniqueColumnArray;

    macro size() /* кол-во столбцов */
      return _uniqueColumnArray.size;
    end;

    macro AddColumn(col:TUniqueColumnBase)
      _uniqueColumnArray(_uniqueColumnArray.size)=col;
    end;

    macro ColArray(a)
      var old=_uniqueColumnArray;
      if(ValType(a) == V_GENOBJ)
        _uniqueColumnArray=a; end;
      return old;
    end;

    macro Column(i:integer)
      return _uniqueColumnArray(i);
    end;

    macro ColumnById(id)
      var i=0;
      while(i < _uniqueColumnArray.size)
        if(_uniqueColumnArray(i).id() == id)
          SetParm(2,i);
          return _uniqueColumnArray(i);
        end;
        i=i+1;
      end;
      SetParm(2,-1);
    end;

    macro CreateByHeader(hdr)
      _uniqueColumnArray=TArray;
      hdr.AddUniqueColumnsToArray(_uniqueColumnArray);
      return _uniqueColumnArray;
    end;

    macro FillLine(l,m,r,s)
      if(_uniqueColumnArray.size < 1)
        RunError("No Cols"); end;
      print(l);
      _uniqueColumnArray(0).FillWidth(s);
      var i=1;
      while(i < _uniqueColumnArray.size)
        print(m);
        _uniqueColumnArray(i).FillWidth(s);
        i=i+1;
      end;
      print(r);
    end;

    macro _printLine(l,m,r,tbl,f)
      if(_uniqueColumnArray.size < 1)
        RunError("No Cols"); end;
      print(l);
      GenRun(tbl,f,_uniqueColumnArray(0),0);
      var iCol=1;
      while(iCol < _uniqueColumnArray.size)
        print(m);
        GenRun(tbl,f,_uniqueColumnArray(iCol),iCol);
        iCol=iCol+1;
      end;
      print(r);
    end;

  /* Constructor */
    if(ValType(__uniqueColumnArray) == V_GENOBJ)
      _uniqueColumnArray=__uniqueColumnArray; end;
  end; /* class TSequenceColumns */


  class TTableBase(_eachLineInCell,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) /* абстрактная база таблиц отчетов */
  /* privates */
    var _header=TTableHeader(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20),
        _sequenceCols=TSequenceColumns(),
        _sequence,
        eachLineInCell:bool=false; /* Рисовать разделительную линию после каждой строки последовательности */

    /* public */
    macro header()
      return _header;
    end;
    macro sequenceCols()
      return _sequenceCols;
    end;
    macro sequenceColArray(a)
      return _sequenceCols.ColArray(a);
    end;
    macro sequence()
      return _sequence;
    end;
    macro rec()
      return _sequence.rec();
    end;

    macro AddColumn(col:THeaderColumnBase)
      _header.AddColumn(col);
    end;

    macro ColumnById(id)
      return _header.ColumnById(id);
    end;

    macro FirstColumn()
      return _header.FirstColumn();
    end;

    macro LastColumn()
      return _header.LastColumn();
    end;

    macro SeqColumn(i:integer)
      return _sequenceCols.Column(i);
    end;

    /* main redefinable virtuals */
    macro GetColTxt(ColId):string /* simple */
      return "";
    end;

    /* or more common */
    macro PrintColLine(col,iCol)
      if(col.IsAuto())
        col.PrintLine(rec());
      else
        col.PrintLine(GetColTxt(col.id())); end;
    end;

    /* private */
    macro _printLine(l,m,r)
      _sequenceCols._printLine(l,m,r,this,"PrintColLine");
      println("");
    end;

    /* public */
    macro PrintMiddleLine(arrOld,arrNew)
      print(tblLM);
      var iOld=0,iNew=0,printedOld=0,printedNew=0;
      while((iOld < arrOld.size) OR (iNew < arrNew.size))
        if((iOld < arrOld.size) AND ((iNew >= arrNew.size) OR (arrOld(iOld).width-printedOld < arrNew(iNew).width-printedNew)))
          PrintRepeat(tblHLine,arrOld(iOld).width - printedOld);
          if((iOld < arrOld.size-1) OR (iNew < arrNew.size))
            print(tblML);
          else
            print(tblRL); end;
          printedNew=printedNew + arrOld(iOld).width - printedOld + 1;
          printedOld=0;
          iOld=iOld + 1;
        elif((iNew < arrNew.size) AND ((iOld >= arrOld.size) OR (arrOld(iOld).width-printedOld > arrNew(iNew).width-printedNew)))
          PrintRepeat(tblHLine,arrNew(iNew).width - printedNew);
          if((iNew < arrNew.size-1) OR (iOld < arrOld.size))
            print(tblMU);
          else
            print(tblRU); end;
          printedOld=printedOld + arrNew(iNew).width - printedNew + 1;
          printedNew=0;
          iNew=iNew + 1;
        else
          PrintRepeat(tblHLine,arrOld(iOld).width - printedOld);
          if((iNew < arrNew.size-1) OR (iOld < arrOld.size-1))
            print(tblMM);
          else
            print(tblRM); end;
          printedNew=printedOld=0;
          iOld=iOld + 1;
          iNew=iNew + 1;
        end;
      end;
/*      print(tblRM);*/
      println("");
    end;

    macro FillLine(l,m,r,s)
      _sequenceCols.FillLine(l,m,r,s);
      println("");
    end;
    macro PrintULine()
      _sequenceCols.FillLine(tblLU,tblMU,tblRU,tblHLine);
      println("");
    end;
    macro PrintMLine()
      _sequenceCols.FillLine(tblLM,tblMM,tblRM,tblHLine);
      println("");
    end;
    macro PrintLLine()
      _sequenceCols.FillLine(tblLL,tblML,tblRL,tblHLine);
      println("");
    end;

    macro PrintHeader()
      _header.PrintHeader();
    end;
    macro PrintLine()
      _printLine(tblVLine,tblVLine,tblVLine);
    end;
    macro PrintFooter()
      PrintLLine();
    end;

    macro GenerateSequenceColumns()
      return _sequenceCols.CreateByHeader(_header);
    end;

    /* redefinable virtuals: */
    macro beginLine()
    end;
    macro endLine()
    end;
    macro beginFirstLine()
      PrintMLine();
      return beginLine()
    end;
    macro endFirstLine()
      return endLine()
    end;

    /* main public */
    macro do(seq:TForwardSequenceBase)
      GenerateSequenceColumns();
      PrintHeader();
      _sequence=seq;
      if(_sequence.open() == true)
        if(_sequence.first() == true)
          beginFirstLine();
          PrintLine();
          endFirstLine();
          while(_sequence.next() == true)
            if(eachLineInCell == true)
              PrintMLine(); end;
            beginLine();
            PrintLine();
            endLine();
          end;
        end;
        _sequence.close();
      end;
      _sequence=null;
      PrintFooter();
    end;

    /* Constructor */
    if(ValType(_eachLineInCell) == V_BOOL)
      eachLineInCell=_eachLineInCell; end;
  end; /* class TTableBase */

  class(TTableBase) TTableWithProgressIndicator(_eachLineInCell,__precount,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
    InitTTableBase(_eachLineInCell,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20);
    var _precount:bool=true, /* private Предварительно подсчитывать кол-во строк последовательности для прогресометра */
        _counter:integer=0,
        _silent_operation = false;

    /* main public */
    macro do(seq:TForwardSequenceBase)
      GenerateSequenceColumns();
      
      _sequence=seq;
      if(_sequence.open() == true)
        _counter=0;
        if(_precount == true)
          if (not _silent_operation) InitProgress(1,"Выполнение отчета","Подготовка к выполнению отчета"); end;
          if(_sequence.first() == true)
            _counter=_counter + 1;   
            if (not _silent_operation)
              UseProgress(_counter);
            end;
            while(_sequence.next() == true)
               _counter=_counter + 1;
               if (not _silent_operation)
                 UseProgress(_counter);
               end;
            end;
          end;
          if (not _silent_operation) RemProgress(); end;

          
        else
          _counter=1;
        end;


        if (not _silent_operation)
          InitProgress(_counter,"Выполнение отчета","Выполнение отчета");
        end;
        _counter=0;
        if(_sequence.first() == true)
          _sequence.PrintHeader();
          PrintHeader();
          beginFirstLine();
          PrintLine();
          endFirstLine();
          _counter=_counter + 1;
          if (not _silent_operation)
            UseProgress(_counter);
          end;
          while(_sequence.next() == true)
            if(eachLineInCell == true)
              PrintMLine(); end;
            beginLine();
            PrintLine();
            endLine();
            _counter=_counter + 1;
            if (not _silent_operation)
              UseProgress(_counter);
            end;
          end;
        end;
        if (not _silent_operation)
          RemProgress();
        end;
        _sequence.close();
      end;
      _sequence=null;
      if ( _counter  )
        PrintFooter();
      end;
    end;

  /* Constructor */
    if(ValType(__precount) == V_BOOL)
      _precount=__precount; end;
  end; /* class TTableWithProgressIndicator */

END; /* конец макрофайла */
