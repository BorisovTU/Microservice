/*
$Name:        repsrvdo.mac
$Module:      Ценные бумаги
$Description: Отчет "Требования и обязательства по сделкам"
*/
import "spserv.mac", "spRepFn2.mac", "dlmisc.mac";

private const StatLine = "Выпуск отчета \"Требования и обязательства по сделкам\"";

private CONST CALCCOST_CATEGORY = 27;/*Возможность надежного расчета TCC*/

private const
   /* Идентификаторы строк */
   LineID_None    = null,
   LineID_Head1   = 1,
   LineID_Head2   = 2,
   LineID_Data    = 3,
   LineID_Foot1   = 4,
   LineID_Foot2   = 5,
   LineID_Summ    = 6;

private const
   /* Идентификаторы учетных портфелей. */
       PortfID_Undefined    = 0,
       PortfID_Trade        = 1,  // ТП,   торговый портфель
       PortfID_Sale         = 2,  // ППР,  ц/б для продажи
       PortfID_Retire       = 3,  // ПУДП, удерживаемые до погашения
       PortfID_Unadmited    = 4,  // БПП,  переданные без прекращения признания
       PortfID_Contr        = 5,  // ПКУ,  контрольного участия
       PortfID_Back         = 6,  // ПВО,  полученные на возвратной основе
       PortfID_Promissory   = 7;  // ПДО,  просроченные долговые обязательства

private const ITOGPTLINE  = 1,
              ITOGTSSLINE = 2,
              ALLITOGLINE = 3;

/* Определяем нужен ли подраздел для указанного раздела. */
macro IsNeedSubPartition( PortfID )
   return ( (PortfID == PortfID_Sale) OR (PortfID == PortfID_Back) OR (PortfID == PortfID_Unadmited) );
end;

PRIVATE CLASS (DL_CReportTemplate) Report_SrvDo( _RepDate:         date,    /* Отчетная дата */
                                                 _PortfTrade:      bool,    /* торговый портфель */
                                                 _PortfSale:       bool,    /* ц/б для продажи */
                                                 _PortfRetire:     bool,    /* удерживаемые до погашения */
                                                 _PortfUnadmited:  bool,    /* переданные без прекращения признания */
                                                 _PortfContr:      bool,    /* контрольного участия */
                                                 _PortfBack:       bool,    /* полученные на возвратной основе */
                                                 _PortfPromissory: bool,    /* просроченные долговые обязательства */
                                                 _Apostr:          bool,    /* С апострофами */
                                                 _ToExcel:         bool     /* В Excel */ )
   /* Исходные данные */
   var
      RepDate         = _RepDate,
      PortfTrade      = _PortfTrade,
      PortfSale       = _PortfSale,
      PortfRetire     = _PortfRetire,
      PortfUnadmited  = _PortfUnadmited,
      PortfContr      = _PortfContr,
      PortfBack       = _PortfBack,
      PortfPromissory = _PortfPromissory,
      ToExcel         = _ToExcel,
      UseApp          = _Apostr;

   var WasCollectedData = false,
       UniqStr          = TUniqStrCollector;


   MACRO PrintMode():INTEGER
      return IIF(ToExcel, DL_OUTREPORT_EXCEL, DL_OUTREPORT_STD);
   END;

   /* Сбор данных во временный файл. */
   private macro CollectData( /*Data, */TempFile )
      /* Возвращаем номер учетного портфеля под который подходит сделка. */
      macro ПолучитьУчетныйПортфельДляСделки( _wrtsum )

         var DealPortf = GetLotPortf(_wrtsum);

         if( PortfTrade and (DealPortf == KINDPORT_TRADE) )
            return PortfID_Trade;
         end;

         if( PortfSale and (DealPortf == KINDPORT_SALE) )
            return PortfID_Sale;
         end;

         if( PortfRetire and (DealPortf == KINDPORT_RETIRE) )
            return PortfID_Retire;
         end;

         if( PortfUnadmited and ( ( DealPortf == KINDPORT_UNADMITTED ) or ( DealPortf == KINDPORT_BASICDEBT ) )  )
            return PortfID_Unadmited;
         end;

         if( PortfContr and (DealPortf == KINDPORT_CONTR) )
            return PortfID_Contr;
         end;

         if( PortfBack and (DealPortf == KINDPORT_BACK) )
            return PortfID_Back;
         end;

         if( PortfPromissory and (DealPortf == KINDPORT_PROMISSORY) )
            return PortfID_Promissory;
         end;

         return PortfID_Undefined;
      end;

      /* Проверяем выполнена ли поставка бумаг по сделке на отчетную дату.
         Если дата поставки больше или равна отчетной дате, то сделка в отчет
         не отбирается. */
      macro ПоставкаБумагВыполнена( DealID, BackPart, RepDate, FIID:integer )
         var
         rq = TRecHandler ("dlrq.dbt");

         ПолучитьТОпоДокументу(DL_SECURITYDOC, DealID, IIF(BackPart, 2, 1), DLRQ_TYPE_DELIVERY, 0, rq, FIID);

         return (rq.rec.ID > 0) and ТОЗакрыто(rq) and (rq.rec.FactDate < RepDate);
      end;

      MACRO ExistNOSS(FD, DealDate):BOOL
         VAR NumInList = "", ValidFromDate = DATE(0,0,0);

         return (    (GetMainObjAttr( null, OBJTYPE_AVOIRISS, UniID(FD.AVOIRISS, OBJTYPE_AVOIRISS), 27/*Возможность надежного расчета TCC*/, null, null, NumInList, DealDate, ValidFromDate) == true)
               AND (ValidFromDate <= DealDate)
               AND (NumInList == "1")
               );
      END;

      /* Обработать часть сделки. */
      macro ProcessDealPart( deal, BackPart, TempFile )
         var FD, PortfID;
         record wrtsum(pmwrtsum);

         /* Получаем FirstDoc, без него не обойтись. */
         FD = SPFirstDoc(deal, BackPart);

         var ArrFIID2 = FD.RQGetArrFIID(DLRQ_TYPE_DELIVERY);
         var j = 0;
         while( j < ArrFIID2.size )
            FD.SetCurPFI(ArrFIID2(j));

            /* Проверим, что поставка бумаг по данной части сделки на отчетную дату не выполнена.*/
            if( ПоставкаБумагВыполнена(deal.rec.DealID, BackPart, RepDate, ArrFIID2(j)) )
               j = j + 1;
               continue;
            end;

            /* Получаем учетный портфель. */
            /* Получим портфель, на начало отчетного дня. */
            if( WRTGetRestoreLotOnDate(FD.pmwrtsum.rec.sumid, RepDate-1, @wrtsum) != false )
               PortfID = ПолучитьУчетныйПортфельДляСделки(wrtsum);
            else
               PortfID = ПолучитьУчетныйПортфельДляСделки(FD.pmwrtsum.rec);
            end;

            /*Если не нашли, или нашли что "нет" - такая бумага не подходит.*/
            var _TSS = 0;
            if( IsNeedSubPartition(PortfID) )
               if ( ExistNOSS(FD, RepDate) )
                  _TSS = 1;
               else
                  _TSS = 0;
               end;
            end;

            if( PortfID != PortfID_Undefined )
               /* Сохраним данные во временный файл. */
               TempFile.Clear();
               TempFile.rec.PortfID     = PortfID;
               TempFile.rec.IsQuoted    = BoolToInt(FI_IsQuoted(FD.fininstr.rec.FIID, RepDate));
               TempFile.rec.DealID      = FD.tick.rec.DealID;
               TempFile.rec.LegKind     = FD.dl_leg.rec.LegKind;
               TempFile.rec.IssShName   = GetPartyShortNameByID(FI_GetIssuerOnDate(FD.fininstr, RepDate), true, true);
               TempFile.rec.TSS         = _TSS;
               TempFile.rec.FIID        = FD.fininstr.rec.FIID;
               InsertRecTempTBFile(TempFile);
               WasCollectedData = true;
            end;

            j = j + 1;
         end;
      end;

      var
         deal        = TBFile( "dl_tick", "R", 6 ),
         Group, ExistBackPart,
         continue_cicle;

      /* Отбираем свои сделки, дата заключание должна быть меньше отчетной даты.
         Отложенные сделки не отбираем.
         Проверяем статус ТО на дату вывода отчета из истории статусов при помощи ХП.
      */
      deal.Clear();
      deal.AddFilter(   "     t_BOfficeKind = " + string(DL_SECURITYDOC)
                     + " and t_ClientID = -1"
                     + " and t_DealDate < " + GetSQLDate(RepDate)
                     + " and t_DealStatus > " + string(DL_PREPARING)
                     + " and EXISTS "
                     + "   (SELECT  1    "
                     + "      FROM ddlrq_dbt rq    "
                     + "      WHERE RQ.T_DOCID = T_DEALID     "
                     + "      AND RQ.T_DOCKIND = T_BOFFICEKIND  "
                     + "      AND RQ.T_TYPE =  "   + string(DLRQ_TYPE_DELIVERY)
                     + "      AND (rsi_dlrq.RSI_GetRQStateOnDate(rq.t_id, " + GetSQLDate(RepDate) + " )) !=  " + string(DLRQ_STATE_EXEC) +  " )");

      /*Условие на проверку DealID добавил MAG 30.08.2005 при оптимизации отчета -
      эта проверка почти дублирует функцию ПоставкаБумагВыполнена, только там
      проверяется платеж для конкретной части сделки, а здесь часть сделки пока
      неизвестна, и проверяется наличие нужных платежей среди всех платежей по
      сделке. В случае их наличия сделка проверяется далее, иначе не подходит.
      Поэтому функцию ПоставкаБумагВыполнена удалять нельзя.*/

      InitProgressBar( deal.NRecords, StatLine, "Отбор сделок для отчета" );

      while( deal.Next() )
         UseProgressBar;

         /* Нас интересует покупка, продажа, РЕПО, пок. с обр. продажей. */
         Group          = GetOpGroup( deal.rec );
         ExistBackPart  = IsREPO(Group) or IsBACKSALE(Group);
         if( IsBUY(Group) or IsSale(Group) or ExistBackPart )
            /* Каждая часть сделки прямого/обратного РЕПО и сделки покупки с обратной продажей считается самостоятельной сделкой */
            ProcessDealPart(deal, false, TempFile);
            if( ExistBackPart )
               ProcessDealPart(deal, true, TempFile);
            end;
         end;
      end;

      RemProgressBar;
      deal.dropFilter();
   end;

   /* Печать отобранных данных. */
   private macro PrintData( /*Data,*/ TempFile )

      /* Итоги подраздела, раздела, всей таблицы. */
      class TSummary
         var
            AvAmount = $0.0,
            CostColl = TSumCollector();

         /* Добавить данные. */
         macro AddData( AvoirAmount, DealCost, PayFIID, PayCcy )
            AvAmount = AvAmount + AvoirAmount;
            CostColl.AddSum( DealCost, PayFIID, PayCcy );
         end;

         /* Очистить итоги. */
         macro Clear
            AvAmount = $0.0;
            CostColl.ClearArray();
         end;
      end;

      macro ЛСчетНаКоторомУчитываетсяЛот( pmwrtsum, ADate, FDBuy )

         /* Получить буфер сделки покупки. */
         macro GetDealBuy( FDBuy, pmwrtsum )
            if( FDBuy != null )
               return FDBuy.tick.rec;
            else
               return GetDealByID( pmwrtsum.DealID, true );
            end;
         end;

         /* Получить первичный документ операции покупки. */
         macro GetFD( FDBuy, pmwrtsum, DealBuy )
            if( FDBuy != null )
               return FDBuy;
            else
               return SPFirstDoc(GetLegKindByLotDeal(pmwrtsum, DealBuy), pmwrtsum.DealID);
            end;
         end;

         var
            DealBuy        = TRecHandler( "dl_tick" ),
            Acc            = TRecHandler( "account" ),
            FD             = null,
            PortfID, FindAccFlag = false,
            select, vscwrthist, pmwbpp, i,
            CategName = TArray(),
            NumAccount = "";

            CategName[0] = "Ц/б, БПП";
            CategName[1] = "Ц/б, ПВО";
            CategName[2] = "-ОД";
            CategName[3] = "+ОД";
            CategName[4] = "Ц/б, Корзина БПП";
            CategName[5] = "+ОД, Корзина";
            CategName[6] = "-ОД, Корзина";
            CategName[7] = "Ц/б, Корзина ПВО";
            CategName[8] = "Ц/б, ПКУ БПП";
            CategName[9] = "Ц/б, Корзина ПКУ БПП";

         Acc.Clear;

         if( ADate < pmwrtsum.EnterDate )
            return Acc.rec.Account;
         end;

         select = RSDCommand("select hist.t_Portfolio, hist.t_State, hist.t_Amount, hist.t_AmountBD "+
                           "from v_scwrthist hist "+
                           "where hist.t_sumid = ? "+
                           " and  hist.t_instance = (select max (t_instance) "+
                           "                       from  v_scwrthist "+
                           "                       where t_sumid = hist.t_sumid "+
                           "                       and t_changedate < ?)");

         select.addParam("sumid", RSDBP_IN, pmwrtsum.SumID);
         select.addParam("changedate", RSDBP_IN, ADate);
         select.execute();

         vscwrthist = TRsbDataSet(select);

         if( vscwrthist.movenext() )

         DealBuy = GetDealBuy( FDBuy, pmwrtsum );
         FD = GetFD( FDBuy, pmwrtsum, DealBuy );

         i = 0;
         while( i < CategName.Size() )

            if( (CategName[i] == "Ц/б, БПП") or (CategName[i] == "Ц/б, Корзина БПП") )/*по сделке их может быть от 1 до 3-х*/
               if( FD.IsExistAccount( CategName[i], null, true, GetFIRoleByPortfolio( KINDPORT_TRADE ), Acc, null, ADate-1 ) )
               if( FindAccFlag )
                  NumAccount = NumAccount + ", ";
               end;
               NumAccount = NumAccount + Acc.rec.Account;
               FindAccFlag = true;
               end;
               if( FD.IsExistAccount( CategName[i], null, true, GetFIRoleByPortfolio( KINDPORT_SALE ), Acc, null, ADate-1 ) )
               if( FindAccFlag )
                  NumAccount = NumAccount + ", ";
               end;
               NumAccount = NumAccount + Acc.rec.Account;
               FindAccFlag = true;
               end;
               if( FD.IsExistAccount( CategName[i], null, true, GetFIRoleByPortfolio( KINDPORT_RETIRE ), Acc, null, ADate-1 ) )
               if( FindAccFlag )
                  NumAccount = NumAccount + ", ";
               end;
               NumAccount = NumAccount + Acc.rec.Account;
               FindAccFlag = true;
               end;
            elif( (CategName[i] == "Ц/б, ПКУ БПП") or (CategName[i] == "Ц/б, Корзина ПКУ БПП") )
               if( FD.IsExistAccount( CategName[i], null, true, GetFIRoleByPortfolio( KINDPORT_CONTR ), Acc, null, ADate-1 ) )
               if( FindAccFlag )
                  NumAccount = NumAccount + ", ";
               end;
               NumAccount = NumAccount + Acc.rec.Account;
               FindAccFlag = true;
               end;
            else
               if( FD.IsExistAccount( CategName[i], null, true, null, Acc, null, ADate-1 ) )
               if( FindAccFlag )
                  NumAccount = NumAccount + ", ";
               end;
               NumAccount = NumAccount + Acc.rec.Account;
               FindAccFlag = true;
               end;
            end;

            i = i + 1;
         end;

         end;

         if ( NumAccount != "" )
            return NumAccount;
         else
            return "";
         end;

      end;

      /* Определить номер лицевого счета. Если не смогли получить счет, то возвращаем пустую строку. */
      macro CalcAccountNumber( FD, IsLotBuy )
         record acnt(account);
         var
            LotState    = FD.dl_leg.rec.OperState /*GetLotStateOnDate( FD.pmwrtsum.rec, Data.RepDate )*/,
            PaymStatus  = DL_GetRQStateOnDate( FD.pm_avoir.dlreq.rec.ID, RepDate ),

            CashDeal    = FD.ВидСрочностиСделки() == СделкаПрочая,
            CategBase, CategName = "";

         /* Номер счета определяем только статус лота >= "внебаланс" */
         /*if( LotState < DL_LEG_OUTBAL )
            return "";
         end;*/

         /* Определяем категорию. */
         if( LotState == DL_LEG_OUTBAL )
            /* если лот сделки имеет по состоянию на отчетную дату статус
            "внебаланс:
               - для лотов покупки - номер лицевого счета категории
               "+Форвард, дрейф" (или "+Форвард, прочие"),
               - для лотов продажи - номер лицевого счета категории
               "-Форвард, дрейф" (или "-Форвард, прочие"), */
            CategBase   = IIF( CashDeal, "Форвард, прочие", "Форвард, дрейф" );
            CategName   = IIF( IsLotBuy, "+" + CategBase, "-" + CategBase );
         elif( PaymStatus == DLRQ_STATE_OVERDUE )
            /* если лот сделки имеет по состоянию на отчетную дату статус
            "просрочена поставка":
               - для сделок покупки - номер лицевого счета категории "Треб.сн.с."
               - для сделок продажи - номер лицевого счета категории "Обяз.сн.с." */
            if( IsBasket(FD.Group) )
               CategName = IIF( IsLotBuy, "Треб. с н.с., корзина", "Обяз. с н.с., корзина" );
            else
               CategName = IIF( IsLotBuy, "Треб. с н.с.", "Обяз. с н.с." );
            end;

         elif( IsREPO(FD.Group) )
         /* для сделок РЕПО */
            if( (IsSale(FD.Group) AND (FD.IsBack)) OR (IsBuy(FD.Group) AND (FD.IsBack)) )
            return  ЛСчетНаКоторомУчитываетсяЛот ( FD.pmwrtsum.rec, RepDate, FD );
            else
               return "";
            end;
         else
            /* для остальных сделок:
               - для сделок покупки - номер лицевого счета категории
               "+Форвард, расчеты",
               - для сделок продажи - номер лицевого счета категории
               "-Форвард, расчеты" */
            CategName = IIF( IsLotBuy, "+Форвард, расчеты", "-Форвард, расчеты" );
         end;

         /* Проверяем существование счета и возвращаем его номер. */
         if (CategName != "")
            if( FD.IsExistAccount(CategName, null, true, null, acnt, null, RepDate-1) )
               return acnt.Account;
            else
               return "";
            end;
         end;
      end;

      private macro NumToStr( Num, Point, DontPrintZero )
         if( not ToExcel )
            if( Point != null )
               return NumPrec( Num, Point, IIF( UseApp, "a", "" ), DontPrintZero );
            else
               return PrintToStr( Num, UseApp, not DontPrintZero );
            end;
         end;

         return Num;
      end;

      /* Получаем курс бумаги в рублях и информацию о торговой площадке.
         Алгоритм работы: Курс вида "XXX" в валюте номинала за отчетную дату;
         если за отчетную дату курс не введен, то выводится курс этого вида с
         наибольшей датой, не превышающей отчетную, если ВН - не рубли,
         то XXX пересчитывается в руб. по курсу на отчетную дату,
         если нет XXX в ВН, то берется XXX в рублях, если XXX ни в ВН, ни в
         рублях не найдена, то поле не заполняется.
            FD          - FD
            RateType    - вид курса
            PriceStr    - сюда запишем цену
            MarketPlace - сюда запишем информацию о организаторе торговли
            IsQuoted    - флаг, котируемая ц/б */
      macro GetRateInfo( FD, RateType, PriceStr:@variant, MarketPlace:@string, IsQuoted )
         var
            FIFrom         = FD.fininstr.rec.FIID,
            FITo           = FD.FaceFIID,
            CnvDate        = RepDate,
            Price          = $0,
            InformUser, MarketPlaceID;

         /* Если некотируемой ц/б и курса вида "Рыночная цена", то в случае,
            когда курса нет, пользователя не информируем. */
         InformUser = IsQuoted or (RateType != SP_RATETYPE_MarketPrice);

         if( ConvSum(Price, $1, CnvDate, FIFrom, FITo, RateType) )
            /* Не нашли курс. Сбрасываем ошибку после ConvSum.
               Пробуем найти курс в рублях. */
            InitError();

            FITo = NATCUR;

            if( ConvSum(Price, $1, CnvDate, FIFrom, FITo, RateType) )
               /* Не нашли курс. Сбрасываем ошибку после ConvSum.
                  Выдаем предупрежедение пользователю. */
               InitError();

               if( InformUser )
                  UniqStr.AddString(
                     "Для ценной бумаги \"" + string(FD.fininstr.rec.FI_Code)
                     + "\" не удалось получить курс вида \""
                     + GetRateTypeName(RateType) + "\" на "
                     + date_as_string(1, CnvDate) );
               end;

               PriceStr       = "";
               MarketPlace    = "";
               return false;
            //else
               /* Нашли курс. */
            end;
         else
            /* Нашли курс в валюте номинала. Переводим сумму в рубли. */
            if(   (not SmartConvertSum(Price, Price, CnvDate, FITo, NATCUR))
                  and InformUser )
               /* Не смогли сконвертировать. */
               UniqStr.AddString(
                  GetCurrencyConvertErrorMsg(FITo, NATCUR, CnvDate) );
            end;
         end;

         /* Получим данные о торговой площадке. */
         MarketPlaceID  = GetRateMarketPlace( FITo, FIFrom, RateType );
         MarketPlace    = GetPartyShortNameByID( MarketPlaceID );
         PriceStr       = NumToStr( Price );
         return true;
      end;

      /* Получить название портфеля. */
      macro GetPortfName( PortfID )
         if( PortfID == PortfID_Trade )
            return TRADEPORTFNAME;
         elif( PortfID == PortfID_Sale )
            return SALEPORTFNAME;
         elif( PortfID == PortfID_Retire )
            return RETIREPORTFNAME;
         elif( PortfID == PortfID_Unadmited )
            return UNADMITEDPORTFNAME;
         elif( PortfID == PortfID_Contr )
            return "Портфель контрольного участия";
         elif( PortfID == PortfID_Back )
            return "Портфель ц/б, полученных на возвратной основе";
         elif( PortfID == PortfID_Promissory )
            return "Портфель не погашенных в срок";
         end;
      end;

      /* Получить название категории. */
      macro GetCategName( Categ )
         return IIF( Categ, "Бумаги, справедливая стоимость которых может быть надежно определена",
                     "Бумаги, справедливая стоимость которых не может быть надежно определена" );
      end;

      /* Получить название подвала подраздела. */
      macro GetCategFootName( Categ )
         return IIF( Categ, "Итого по ц/б справедливая стоимость которых может быть надежно определена",
                     "Итого по ц/б справедливая стоимость которых не может быть надежно определена" );
      end;

      /* Печать итогов. Печатаем к-во ц/б и суммы в различных валютах.
         Если сумма только в рублях, то Ccy не выводим.
            NextLineID     - идентификатор следующей строки
            Summary        - итоги
            TitleFirstLine - заголовок первой строки итогов
            TitleOtherLine - заголовок следующей строки итогов */
      macro PrintSummary( NextLineID, Summary, TitleFirstLine, TitleOtherLine, LineKind )
         var
            Counter = 0,
            OnlyRUR, Title, Amount, Cost, Ccy = "";

         var DelimPrinted = false;

         /* Только одна сумма и в рублях? */
         OnlyRUR =   (Summary.CostColl.Size == 1)
                     and (Summary.CostColl[0].FIID == NATCUR);

         while( Summary.CostColl.Size > Counter )

            Title    = IIF( Counter == 0, TitleFirstLine, TitleOtherLine );
            Amount   = IIF( Counter == 0, NumToStr(Summary.AvAmount, SetPrecisionByFractPart(Summary.AvAmount, 6, 0)), "" );
            Cost     = NumToStr(Summary.CostColl[Counter].Sum);

            if( (Counter > 0) or (not OnlyRUR) )
               Ccy = Summary.CostColl[Counter].FIID_Ccy;
            end;

            if( LineKind == ALLITOGLINE )
               if( ToExcel )
                  ExternalSetCellPoint("N1_T12", SetPrecisionByFractPart(Amount, 6, 0));
               end;
               PrintFormatString( "#", "N1_T12",     Amount,
                                       "N1_T18",     Cost,
                                       "N1_T18_Ccy", Ccy
                                );
               CopyAllSheetInTotalBook( NULL, false, "N1_Total" );
            else
               PrintTableLine( "N1_A01",     Title,  NULL,
                               "N1_A12",     Amount, SetPrecisionByFractPart(Amount, 6, 0),
                               "N1_A18",     Cost,   NULL,
                               "N1_A18_Ccy", Ccy,    NULL
                             );
            end;

            Counter = Counter + 1;
         end;
      end;

      /* Печать подвала подраздела */
      macro PrintFoot2( LastCateg, Summary )
         var
            FirstStr;

         if( LastCateg != null )
            FirstStr = GetCategFootName(LastCateg);

            Merge( "N1_A01", "N1_A05_End" );
            Merge( "N1_A06", "N1_A06_End" );
            PrintSummary(  LineID_Foot2, Summary, FirstStr, "", ITOGTSSLINE );
         end;
      end;

      /* Печать подвала раздела. */
      macro PrintFoot1( LastPortfID, LastCateg, PortfSumm, CategSumm )

         /* Печатаем итоги подраздела при необходимости. */
         var
            SecondStr = "Итого по портфелю: " + GetPortfName(LastPortfID),
            AftSecondStr = "", SpaceInd = 0;

         if( IsNeedSubPartition(LastPortfID) )
            PrintFoot2( LastCateg, CategSumm );
         end;

         Merge( "N1_A01", "N1_A04_End" );
         Merge( "N1_A05", "N1_A05_End" );
         Merge( "N1_A06", "N1_A06_End" );
         PrintSummary(  LineID_Foot1, PortfSumm,
                        SecondStr,
                        AftSecondStr, ITOGPTLINE );
      end;

      /* Печать итоговых данных по всей таблице. */
      macro PrintFootTable( Summary )
         PrintSummary(  LineID_Summ, Summary,
                        "ВСЕГО",
                        "", ALLITOGLINE );
      end;

      var DealChange = TRecHandler( "sptkchng" );

      var
         PrevPortfID = null,
         PrevCateg   = null,
         CategSumm   = TSummary(),
         PortfSumm   = TSummary(),
         TotalSumm   = TSummary(),
         FD, DealCode, CurPortf, BondRetDate, FaceValCcy, FaceValue, AvoirAmount,
         AvoirPerc, NKD, PlanAvSet, DateCurren, PayFIID, PayFICcy, PaymFinished,
         FactPaymDate, DealCost, FIID, CoupDrawDate, AccountNumber, IsBond,
         IsLotBuy, DealKind, AvKind, AvoirAmountStr, AvDep,
         Price_MPrice, Place_MPrice, Price_MCost, Place_MCost,
         continue_cicle;

      private  macro GetData()

         FIID = FD.fininstr.rec.FIID;
         IsBond = FI_IsBond(FIID);

         /* A2 - Номер лицевого счета
            Номер лицевого счета, на котором учитывается требование (или обязательство) по поставке ценных бумаг данной сделки: */
         AccountNumber = CalcAccountNumber(FD, IsLotBuy);

         /* A3 - Номер сделки
            Номер сделки внутренний */
         DealCode = FD.tick.rec.DealCode;

         /* A4 - Вид сделки
            "Покупка", "Продажа", "РЕПО/покупка" или "РЕПО/продажа" (каждая
            часть сделки РЕПО или с обратной продажей выводится как независимая
            сделка покупки и продажи)
            Доп. комментарии:
            РЕПО/покупка - для 1 части выводить РЕПО/покупка, для 2 части -
            РЕПО/продажа, т.е. сначала вид сделки - РЕПО, а затем название
            той части (покупка или продажа), по которой сформирована данная
            строка. РЕПО/продажа - для 1 части выводить РЕПО/продажа, для 2 части -
            РЕПО/покупка.
            Для сделок покупки с обратной продажей и продажей с обратным выкупом
            выводить только вид той части, по которой формируется строка -
            покупка или продажа. */
         DealKind = IIF( IsLotBuy, "покупка", "продажа" );
         DealKind = IIF( IsREPO(FD.Group), "РЕПО/ " + DealKind, DealKind );
         /* A5 - Тип ценной бумаги
            A5а - Краткое наименование вида ц/б
            A5б - в. Номер выпуска */
         AvoirKindName( FD.fininstr.rec.AvoirKind, AvKind );
         AvKind = AvKind + " т." + FD.avoiriss.rec.Issue;

         /* A8 - Дата погашения купона
            Плановая дата погашения последнего купона выпуска ц/б сделки,
            максимальная из всех дат погашения купонов данного выпуска, но не
            превышающая отчетную дату (выводится только для облигаций) */
         if( IsBond )
            CoupDrawDate = GetCoupon_MaxDrDate( FIID, RepDate );
            CoupDrawDate = IIF(  CoupDrawDate == ZeroDate, "",
                                 date_as_string(1, CoupDrawDate) );
         else
            CoupDrawDate = "";
         end;

         /* A9 - Дата погашения облигации
            Плановая дата погашения выпуска (выводится только для облигаций) */
         if( IsBond )
            BondRetDate = date_as_string(1, FD.fininstr.rec.DrawingDate);
         else
            BondRetDate = "";
         end;

         /* A10 - Валюта номинала
            Букв. код валюты номинала */
         FaceValCcy = GetFinInstrCcy( FD.FaceFIID, true );
         /* А11 - Номинал за ед.
            Номинал ц/б в валюте номинала */
         FaceValue = DoubleToMoney(GetFaceValue( FIID, RepDate, true ));

         /* A12 - Кол-во шт.
            A12.а Количество ц/б сделки
            A12.б Если вид ц/б = депозитарная расписка, то выводится символ
            "/" и количество ц/б в одной депоз. расписке
            (определяется из анкеты ДР), иначе - поле не заполняется */

         /*берем из условий изменений по сделке*/
         if( IsBasket(FD.Group) )
            AvoirAmount = FD.Principal(RepDate);
         else
            SP_GetDealParmsByDate(FD.tick, RepDate, DealChange, false, false);
            AvoirAmount = IIF( FD.IsBack, DealChange.rec.OldPrincipal2, DealChange.rec.OldPrincipal);
            end;
            AvoirAmountStr = NumToStr( AvoirAmount, 0 );
         if( FI_IsDeposReceipt(FD.fininstr.rec.FIID) )
            AvoirAmountStr = NumToStr( AvoirAmount, 0 );
            AvDep = FD.avoiriss.rec.NumBaseFI;
            AvoirAmountStr = AvoirAmountStr + "/" + IIF( AvDep==null, "", AvDep );
         end;

         /* A13 - % от объема эмиссии
            = <A12> *100 / (объем выпуска ц/б на дату заключения сделки) */
         if( IsAvoirQtyExist(FD.avoiriss.rec, FD.DateArray[DATE_DEALDATE]) )
            AvoirPerc = MoneyToDouble( AvoirAmount ) * 100
                        / GetAvoirQty( FD.avoiriss.rec, FD.DateArray[DATE_DEALDATE] );
         else
            AvoirPerc = 0.0;
            UniqStr.AddString( "Для ценной бумаги \""
                               + string(FD.fininstr.rec.FI_Code)
                               + "\" не задан объем выпуска" );
         end;

         /* A14 - НКД на дату заключения
            НКД из условий сделки в валюте номинала по курсу на дату заключения сделки */
         if( IsBasket(FD.Group) )
            NKD = FD.NKD(FD.tick.rec.DealDate);
         else
            NKD = IIF(FD.IsBack, DealChange.rec.OldNKD2, DealChange.rec.OldNKD1);/* FD.dl_leg.rec.NKD;      SPTKCHNG*/
         end;

         /* А15 - Дата поставки ц/б
            Плановая дата поставки */
         PlanAvSet = FD.DateArray[DATE_DEALSETAVOIRISS_PLAN];

         /* Определяем выполенена ли оплата по сделке на отчетную дату. */
         PaymFinished = ТОЗакрыто(FD.pm_money.dlreq)
                        and (FD.pm_money.rec.ValueDate <= RepDate);
         FactPaymDate = FD.DateArray[DATE_DEALPAY];

         /* A16 - Дата валютирования
            Если оплата по сделке по состоянию на отчетную дату исполнена, то
            фактическая дата оплаты, иначе - плановая дата оплаты */
         DateCurren = IIF( PaymFinished, FactPaymDate,
                           IIF(IsBasket(FD.Group), FactPaymDate, FD.DateArray[DATE_DEALPAY_PLAN]) );

         /* А17 - Валюта расчетов
            Букв. код валюты расчетов по сделке */
         PayFIID  = FD.pm_money.rec.PayFIID;
         PayFICcy = GetFinInstrCcy( PayFIID, true );

         /* A18 - Треб. (обяз.) по оплате
            Сумма сделки (без НКД) в валюте расчетов сделки: если оплата сделки
            по состоянию на отчетную дату исполнена, т.е. Dо факт не превышает
            отчетную дату - то по курсу на факт. дату оплаты, иначе - по курсу
            на отчетную дату */

         SmartConvertSum(  DealCost, IIF(IsBasket(FD.Group), FD.dl_leg.rec.TotalCost, FD.dl_leg.rec.Cost),
                           IIF(PaymFinished, FactPaymDate, RepDate),
                           FD.dl_leg.rec.CFI, PayFIID, true );

         /* A19 - Источник котировки "рын.цена" */
         /* A20 - Рыночная цена */
         GetRateInfo( FD, SP_RATETYPE_MarketPrice, @Price_MPrice, @Place_MPrice, TempFile.rec.IsQuoted );

         /* А21 - Источник котировки "рын.ст" */
         /* A22 - Рыночная стоимость */
         GetRateInfo( FD, SP_RATETYPE_MarketCost, @Price_MCost, @Place_MCost, TempFile.rec.IsQuoted );

         Merge("N1_A04", "N1_A04_End");
         Merge("N1_A05", "N1_A05_End");
         Merge("N1_A06", "N1_A06_End");
         Merge("N1_A18", "N1_A18_End");
         PrintTableLine( "N1_A01",     TempFile.rec.IssShName,        NULL,
                         "N1_A02",     AccountNumber,                 NULL,
                         "N1_A03",     DealCode,                      NULL,
                         "N1_A04",     DealKind,                      NULL,
                         "N1_A05",     AvKind,                        NULL,
                         "N1_A06",     FD.avoiriss.rec.LSIN,          NULL, /* A6 - № гос. регистрации */
                         "N1_A07",     FD.avoiriss.rec.ISIN,          NULL, /* A7 - ISIN */
                         "N1_A08",     CoupDrawDate,                  NULL,
                         "N1_A09",     BondRetDate,                   NULL,
                         "N1_A10",     FaceValCcy,                    NULL,
                         "N1_A11",     NumToStr(FaceValue),           NULL,
                         "N1_A12",     AvoirAmountStr,                SetPrecisionByFractPart(AvoirAmountStr, 6, 0),
                         "N1_A13",     NumToStr(AvoirPerc, 2),        NULL,
                         "N1_A14",     NumToStr(NKD),                 NULL,
                         "N1_A15",     date_as_string(1, PlanAvSet),  NULL,
                         "N1_A16",     date_as_string(1, DateCurren), NULL,
                         "N1_A17",     PayFICcy,                      NULL,
                         "N1_A18",     NumToStr(DealCost),            NULL,
                         "N1_A18_Ccy", "",                            NULL,
                         "N1_A19",     Place_MPrice,                  NULL,
                         "N1_A20",     Price_MPrice,                  NULL,
                         "N1_A21",     Place_MCost,                   NULL,
                         "N1_A22",     Price_MCost,                   NULL
                       );

         /* Собираем статистику. */
         CategSumm.AddData( AvoirAmount, DealCost, PayFIID, PayFICcy );
         PortfSumm.AddData( AvoirAmount, DealCost, PayFIID, PayFICcy );
         TotalSumm.AddData( AvoirAmount, DealCost, PayFIID, PayFICcy );
      end;

      InitProgressBar(TempFile.NRecords(), StatLine, "Печать отчета");

      TempFile.Clear();
      TempFile.Rewind();
      continue_cicle = TempFile.Next();

      CopyAllSheetInTotalBook( NULL, false, "N1_TABLEHEADER", 1 );
      RegisterTable( "N1_MainTable", "", "N1_A01", "N1_A02", "N1_A03", "N1_A04", "N1_A04_End", "N1_A05", "N1_A05_End", "N1_A06", "N1_A06_End", "N1_A07", "N1_A08", "N1_A09", "N1_A10", "N1_A11",
                                         "N1_A12", "N1_A13", "N1_A14", "N1_A15", "N1_A16", "N1_A17", "N1_A18", "N1_A18_Ccy", "", "N1_A18_End", "N1_A19", "N1_A20", "N1_A21", "N1_A22"
                   );

      while( continue_cicle )

         CurPortf = TempFile.rec.PortfID;

         /********************************************************************
            Печать заголовков и подвалов
         ********************************************************************/

         /* Печатаем заголовок нового раздела и итоги предыдущего. */
         if( PrevPortfID != CurPortf )

            /* Предыдущий раздел. */
            if( PrevPortfID != null )
               PrintFoot1( PrevPortfID, PrevCateg, PortfSumm, CategSumm );
            end;

            Merge("N1_A01", "N1_A22");
            PrintTableLine( "N1_A01", GetPortfName(TempFile.rec.PortfID), NULL );

            PortfSumm.Clear();
            CategSumm.Clear();
            PrevPortfID = TempFile.rec.PortfID;
            PrevCateg   = null;
         end;

         /* Печатаем заголовок нового подраздела и итоги предыдущего. */
         if( IsNeedSubPartition(CurPortf) and (PrevCateg != TempFile.rec.TSS) )

            /* Печатаем итоги предыдущего подраздела. */
            PrintFoot2( PrevCateg, CategSumm );

            Merge("N1_A01", "N1_A22");
            PrintTableLine( "N1_A01", GetCategName(TempFile.rec.TSS), NULL );

            CategSumm.Clear();
            PrevCateg = TempFile.rec.TSS;
         end;

         /********************************************************************
            Получаем данные для печати строки отчета
         ********************************************************************/

         /* Получаем данные сделки */
         FD       = SPFirstDoc( TempFile.rec.LegKind, TempFile.rec.DealID );
         IsLotBuy = IIF( FD.IsBack, IsSALE(FD.Group), IsBUY(FD.Group) );

         if( IsBasket(FD.Group) )
            FD.SetCurPFI(TempFile.rec.FIID);
         end;

         GetData();

         UseProgressBar;
         continue_cicle = TempFile.Next();
      end;

      /* Печать итого раздела и данных по всей таблице. */
      PrintFoot1( PrevPortfID, PrevCateg, PortfSumm, CategSumm );
      EndTable();
      CopyAllSheetInTotalBook( NULL, false, GetTableRange() );

      PrintFootTable( TotalSumm );

      RemProgressBar;
   end;

   PRIVATE MACRO BeginReport( NumCopy:INTEGER )
      CreateTotalBook();
   END;

   PRIVATE MACRO EndReport( NumCopy:INTEGER )
      SaveTotalBook();
   END;

      /*создать отчет*/
   PRIVATE MACRO Create( NumCopy:INTEGER )
      var TempFile = TBFile( "repsrvdo.tmp", "W", 0 );
      var TempFName;
      Dl_CallInsertStat(IIF(ToExcel, DL_OUTREPORT_EXCEL, DL_OUTREPORT_STD));
      if(   PortfTrade     or
            PortfSale      or
            PortfRetire    or
            PortfUnadmited or
            PortfContr     or
            PortfBack      or
            PortfPromissory )

         /* Имеет смысл выпускать отчет. */

         TempFName = GetWorkFileName("repsrvdo");
         ClearGlobalTmp( "drepsrvdo_tmp" );

         CollectData(TempFile);
         if( WasCollectedData )
            SetActiveSheet( "Отчет" );
            PrintFormatString( "#", "N1_H0", "Перечень заключенных сделок, по которым поставка ценных бумаг по состоянию на "+RepDate+"  не исполнена" );
            CopyAllSheetInTotalBook( NULL, false, "N1_H0" );

            PrintData(TempFile);
         end;
      end;

      /* Печать подвала таблицы */
      if( WasCollectedData )
         AddStandardFooter( "N1_", true );
         CopyAllSheetInTotalBook( NULL, false, "N1_FOOTER", 2 );
      else
         PrintFormatString( "#", "N1_H0", "Нет данных, удовлетворяющих параметрам отчета." );
         CopyAllSheetInTotalBook( NULL, false, "N1_H0" );
      end;

      if( ToExcel )
         if( UniqStr.Size > 0 )//Печатаем протокол
            var Counter = 0;
            while( Counter < UniqStr.Size )
               MsgBox(UniqStr[Counter]);
               Counter = Counter + 1;
            end;
         end;
      else
         if( UniqStr.Size > 0 )//Печатаем протокол
            PrintLn("\nПротокол отчета\n");
            UniqStr.PrintArray();
         end;
      end;
   END;

   initDL_CReportTemplate(NULL, "Report_SrvDo.xlsx");
END; //Report_SrvDo

/***************************************************************************
   Процедура, вызываемая при запуске отчета
****************************************************************************/

macro ReportRun( RepDate:         date,    /* Отчетная дата */
                 PortfTrade:      bool,    /* торговый портфель */
                 PortfSale:       bool,    /* ц/б для продажи */
                 PortfRetire:     bool,    /* удерживаемые до погашения */
                 PortfUnadmited:  bool,    /* переданные без прекращения признания */
                 PortfContr:      bool,    /* контрольного участия */
                 PortfBack:       bool,    /* полученные на возвратной основе */
                 PortfPromissory: bool,    /* просроченные долговые обязательства */
                 Apostr:          bool,    /* С апострофами */
                 ToExcel:         bool     /* В Excel */)

   Report_SrvDo( RepDate, PortfTrade, PortfSale, PortfRetire, PortfUnadmited,
                 PortfContr, PortfBack, PortfPromissory, Apostr, ToExcel
               ).Run();

   if( ToExcel )
      exit(1);
   end;
end;


                                                       
