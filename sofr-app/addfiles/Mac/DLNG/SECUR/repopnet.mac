/*******************************************************************************
 DESCRIPTION  :   Отчет "Доходы и расходы по операцияи неттинга"
 PROGRAMMED BY:   Трафименков Г.М.
 CREATION DATE:   22.06.04
*******************************************************************************/
import "repopnet_form", "spserv.mac", "spRepFun.mac", "sccomiss.mac", "globals.mac";

const
   DEBUG_PRINT = false,
   StatLine    = "Выпуск отчета \"Доходы и расходы по операцияи неттинга\"",
   HeadLine1   = "Отбор подходящих операций неттинга",
   HeadLine2   = "Печать отчета";

const 
   InMark = "обращающиеся на ОРЦБ",
   NotInMark = "не обращающиеся на ОРЦБ";

PRIVATE VAR ReportHeader =
"\n\n##############################  ###########################\n"+
"Аналитический регистр налогового учета № 14\n"+
"\nДоходы/расходы по операциям с финансовыми инструментами срочных сделок, #\n"+
"(базисный актив # # # # беспоставочные)\n"+
"\nза #\n";

PRIVATE VAR Footer = "\n\nРегистр составлен __________________________________________________________ (подпись, дата, ФИО)\n"+
                     "\nКонтроль ___________________________________________________________________ (подпись, дата, ФИО)";

private var
  TableHeader = 
      " ┌────────────┬──────────┬────────────┬──────────┬────────────────┬─────────────────────────┬──────────┬────────────────┬───────────────┬─────────────────────┬──────────────────────┬──────────────────┬───────────┬──────────────────┬──────────┬──────────────────┬────────────────────┬───────────────────┬─────────────────┬─────────────────┐\n"+
      " │  Договор   │   Дата   │  Договор   │   Дата   │  Наименование  │       Вид актива        │   Дата   │  Вид продажи   │  Вид покупки  │    Цена сделки      │     Цена сделки      │  Сумма базисного │  Базисный │  Сумма базисного │ Затраты  │    Финансовый    │     Контрольный    │     Организатор   │ Сумма отклонения│ Сумма отклонения│\n"+
      " │ или номер  │заключения│ или номер  │заключения│    операции    │                         │исполнения│                │               │   покупки, вал.     │    продажи, вал.     │   актива сделки  │ актив, шт.│   актива сделки  │по сделкам│     результат    │    интервал цен    │      торговли     │ фактической     │ фактических     │\n"+     
      " │  сделки    │  сделки  │  сделки    │  сделки  │(вид контракта) │                         │          │                │               │                     │                      │   покупки, руб.  │           │   продажи, руб.  │ покупки и│                  ├──────────┬─────────┼─────────┬─────────┤ выручки от      │ затрат при      │\n"+
      " │  продажи   │  продажи │  покупки   │  покупки │                │                         │          │                │               │                     │                      │                  │           │                  │ продажи  │                  │  мин.    │  макс.  │  мин.   │   макс. │ реализации ниже │приобретении выше│\n"+
      " │            │          │            │          │                │                         │          │                │               │                     │                      │                  │           │                  │          │                  │          │         │         │         │ рыночной цены   │ рыночной цены   │\n"+
      " ├────────────┼──────────┼────────────┼──────────┼────────────────┼─────────────────────────┼──────────┼────────────────┼───────────────┼─────────────────────┼──────────────────────┼──────────────────┼───────────┼──────────────────┼──────────┼──────────────────┼──────────┼─────────┼─────────┼─────────┼─────────────────┼─────────────────┤\n"+
      " │     1      │    2     │     3      │    4     │       5        │            6            │    7     │       8        │       9       │         10          │          11          │        12        │    13     │        14        │    15    │        16        │   17     │   18    │   19    │   20    │      21         │      22         │\n"+
      " ├────────────┼──────────┼────────────┼──────────┼────────────────┼─────────────────────────┼──────────┼────────────────┼───────────────┼─────────────────────┼──────────────────────┼──────────────────┼───────────┼──────────────────┼──────────┼──────────────────┼──────────┼─────────┼─────────┼─────────┼─────────────────┼─────────────────┤";
      

PRIVATE CLASS COpNetReg( Report:OBJECT, Prefix:STRING, SheetName:STRING )
  VAR m_Report = Report, m_Prefix = Prefix, m_SheetName = SheetName;

  MACRO BeginReport()          
     m_Report.SetActiveSheet( m_SheetName );
     m_Report.PrintHeader();
     m_Report.RegisterTable(m_Prefix + "MainTable", TableHeader,
                            m_Prefix + "DealSaleCode", m_Prefix + "DealSaleDate", m_Prefix + "DealBuyCode", m_Prefix + "DealBuyDate", 
                            m_Prefix + "OperKind", m_Prefix + "FIName", m_Prefix + "ExecDate",
                            m_Prefix + "SaleKind", m_Prefix + "BuyKind", m_Prefix + "BuyPriceStr", m_Prefix + "SalePriceStr",
                            m_Prefix + "CostBuy", m_Prefix + "Amount", m_Prefix + "CostSale", m_Prefix + "Outlay", m_Prefix + "FinRes",
                            m_Prefix + "IntMin", m_Prefix + "IntMax", m_Prefix + "MarketerMin", m_Prefix + "MarketerMax", 
                            m_Prefix + "Delta1", m_Prefix + "Delta2"
                           );

  END;

  MACRO PrintTableDep( BaseFIStr:STRING )
     m_Report.PrintTableLine( m_Prefix + "DealSaleCode:c", BaseFIStr, null);
  END;

  MACRO EndReport()
     m_Report.EndTable();
  END;

  MACRO PrintSummary(SumCostBuy,SumCostSale,SumOutlay,SumFinRes,SumDelta1,SumDelta2)
     m_Report.PrintTableLine(
  /*9  */                         m_Prefix + "CostBuy:r",  SumCostBuy,      null, 
                                  m_Prefix + "CostSale:r", SumCostSale,     null,
                                  m_Prefix + "Outlay:r",   SumOutlay,       null,
                                  m_Prefix + "FinRes:r",   SumFinRes,       null,
                                  m_Prefix + "Delta1:r",   SumDelta1,       null,
                                  m_Prefix + "Delta2:r",   SumDelta2,       null
                            );
  END;

  MACRO Print()
     m_Report.SetCurrentLineFont( 8, false, false );
     m_Report.PrintTableLine(
  /*1  */                         m_Prefix + "DealSaleCode:c", m_Report.DealSaleCode(), null,
  /*2  */                         m_Prefix + "DealSaleDate:c", m_Report.DealSaleDate(), null,
  /*3  */                         m_Prefix + "DealBuyCode:c",  m_Report.DealBuyCode(),  null,
  /*4  */                         m_Prefix + "DealBuyDate:r",  m_Report.DealBuyDate(),  null,
  /*4  */                         m_Prefix + "OperKind:r",     "срочный б/п",           null,
  /*4  */                         m_Prefix + "FIName:r",       m_Report.FIName(),       null,
  /*5  */                         m_Prefix + "ExecDate:r",     m_Report.ExecDate(),     null,
  /*5  */                         m_Prefix + "SaleKind:r",     m_Report.SaleKind(),     null,
  /*6  */                         m_Prefix + "BuyKind:r",      m_Report.BuyKind(),      null,
  /*7  */                         m_Prefix + "BuyPriceStr:r",  m_Report.BuyPriceStr(),  null,
  /*8  */                         m_Prefix + "SalePriceStr:r", m_Report.SalePriceStr(), null,
  /*9  */                         m_Prefix + "CostBuy:r",      m_Report.CostBuy(),      null, 
                                  m_Prefix + "Amount:r",       m_Report.Amount(),       null,
                                  m_Prefix + "CostSale:r",     m_Report.CostSale(),     null,
                                  m_Prefix + "Outlay:r",       m_Report.Outlay(),       null,
                                  m_Prefix + "FinRes:r",       m_Report.FinRes(),       null,
                                  m_Prefix + "IntMin:r",       m_Report.IntMin(),       null,
                                  m_Prefix + "IntMax:r",       m_Report.IntMax(),       null,
                                  m_Prefix + "MarketerMin:r",  m_Report.MarketerMin(),  null,
                                  m_Prefix + "MarketerMax:r",  m_Report.MarketerMax(),  null,
                                  m_Prefix + "Delta1:r",       m_Report.Delta1(),       null,
                                  m_Prefix + "Delta2:r",       m_Report.Delta2(),       null
                             );
  END; 
        
END;


PRIVATE CLASS (DL_CReportTemplate) SP_OpNetReg_Report

  PRIVATE VAR Period, Year, GrowingSum, FaceRUR, FaceCUR, CircInM, NotCircInM, StateAv, MunicipalAv, CorporativeAv, NationalAv, ForeignAv,
              AllAv, ShareAv, DeposAv, BondAv, Apostr, Prefix;

  PRIVATE VAR BegDate, EndDate, PeriodName;

  PRIVATE VAR m_CircInMarket, m_CurAvr, m_StateAvr, m_KindAvr;
  PRIVATE VAR SumCostBuy = 0.0, SumCostSale = 0.0, SumOutlay = 0.0, SumFinRes = 0.0, SumDelta1 = 0.0, SumDelta2 = 0.0;

  PRIVATE VAR BuyPaymInfo, SalePaymInfo, IsBackBuy, IsBackSale;

  PRIVATE VAR DealBuy   = TRecHandler( "dl_tick" ),
              DealSale  = TRecHandler( "dl_tick" ),
              DlLegBuy  = TRecHandler( "dl_leg" ),
              DlLegSale = TRecHandler( "dl_leg" );

  PRIVATE VAR  FaceValFIID, ValueDate, AvrFIID;

  PRIVATE MACRO PrintMode():INTEGER
     return DL_OUTREPORT_EXCEL;
  END;

  PRIVATE MACRO BeginReport(NumCopy:INTEGER)

     Period        = m_Form.GetFieldValue( PNFLD_OPNETREG_PERIOD);
     Year          = m_Form.GetFieldValue( PNFLD_OPNETREG_YEAR);
     GrowingSum    = m_Form.GetFieldValue( PNFLD_OPNETREG_GROWINGSUMM);
     StateAv       = m_Form.GetFieldValue( PNFLD_OPNETREG_STATEAV);
     MunicipalAv   = m_Form.GetFieldValue( PNFLD_OPNETREG_MUNICIPALAV);
     CorporativeAv = m_Form.GetFieldValue( PNFLD_OPNETREG_CORPORATIVEAV);
     AllAv         = m_Form.GetFieldValue( PNFLD_OPNETREG_ALLAV);
     ShareAv       = m_Form.GetFieldValue( PNFLD_OPNETREG_SHAREAV);
     DeposAv       = m_Form.GetFieldValue( PNFLD_OPNETREG_DEPOSAV);
     BondAv        = m_Form.GetFieldValue( PNFLD_OPNETREG_BONDAV);
     Apostr        = m_Form.GetFieldValue( PNFLD_OPNETREG_APPOSTR);
               
     Period_GetInterval( Period, Year, @BegDate, @EndDate, GrowingSum );
     PeriodName = PeriodName_GetMonthsAndQuart( Period, Year, GrowingSum );

  END;

  MACRO PrintHeader( )

     VAR INN = "", KPP = "";
     SplitFullINN( ПолучитьКодСубъекта({OurBank}, PTCK_INN), INN, KPP );

     PrintFormatString( ReportHeader,
                        Prefix+"H0_1:l" , ПолучитьКороткоеИмяСубъекта({OurBank}),
                        Prefix+"H0_2:l" , INN + " / " + KPP,
                        Prefix+"H0_3"   , PeriodName
 
                      );
  END;

  PRIVATE MACRO ExecuteReport( ObjReport:OBJECT )
    
  Var TempFile = TbFile( "repopnet.tmp", "W" );
  ClearGlobalTmp( "drepopnet_tmp" );    /* Класс для хранения данных о платеже неттинга. */
 
   PRIVATE CLASS TPaymInfo( _NetPaymID, _PaymID, _DealID, _Amount )
       var
         NetPaymID   = _NetPaymID,     /* ID платежа неттинга */
         PaymID      = _PaymID,        /* ID платежа */
         DealID      = _DealID,        /* ID сделки */
         Amount      = _Amount;        /* Кол-во ц/б */
    END;

    PRIVATE MACRO ClearSummary()
       SumCostBuy   = 0;
       SumCostSale  = 0;
       SumOutlay    = 0;
       SumFinRes    = 0;
       SumDelta1    = 0;
       SumDelta2    = 0;
    END;

    PRIVATE MACRO PrintLine(BPInfo, SPInfo)

       BuyPaymInfo  = BPInfo;
       SalePaymInfo = SPInfo;
      /* Получим сделки. */
       GetDealFileByID( SalePaymInfo.DealID, true, true, DealSale );
      /* Получим сделки. */
       GetDealFileByID( BuyPaymInfo.DealID, true, true, DealBuy );

      /* Определяем по каким частям сделок платежи (лоты) */
       IsBackBuy   = IsSALE( GetOpGroup(DealBuy.rec) );
       IsBackSale  = IsBUY( GetOpGroup(DealSale.rec) );
      /* Получим условия сделок. Надо корректно обработать сделки с двумя
         частями. */
       GetDlLegByDealID(
                        BuyPaymInfo.DealID,
                        GetLegKindByBackFlag(IsBackBuy), true, true, DlLegBuy );

       GetDlLegByDealID(
                        SalePaymInfo.DealID,
                        GetLegKindByBackFlag(IsBackSale), true, true, DlLegSale );

       FaceValFIID = TempFile.rec.FaceFIID;
       ValueDate   = TempFile.rec.ValueDate;
       AvrFIID     = TempFile.rec.FIID;

       ObjReport.Print(); 
    END;

    PRIVATE MACRO PrintDepartmentHead()
       VAR BaseFIStr = "базисный актив "
                  + TempFile.rec.H04_National
                  + IIF( TempFile.rec.H05_Currency != "", " ", "" )
                  + TempFile.rec.H05_Currency
                  + IIF( TempFile.rec.H06_BondKind != "", " ", "" )
                  + TempFile.rec.H06_BondKind
                  + IIF( TempFile.rec.H07_Kind != "", " ", "" )
                  + TempFile.rec.H07_Kind
                  + " беспоставочные";
       ObjReport.PrintTableDep(BaseFIStr);
    END;
/* "Рубим" платежи покупки и продажи на равные части и отбрасываем лишние. */
    PRIVATE MACRO ChopPayments( BuyPaymArray, SalePaymArray )
   /* Что делаем:

      Платежи  Платежи          Платежи  Платежи            Платежи  Платежи
      продажи  покупки          продажи  покупки            продажи  покупки
      -----┐   -----┐           -----┐   -----┐             -----┐   -----┐ 
      │    │   │ b1 │           │s1.1│   │b1.1│             │s1.1│   │b1.1│ 
      │    │   +----+           +----+   +----+             +----+   +----+ 
      │ s1 │   │ b2 │           │s1.2│   │b2.1│             │s1.2│   │b2.1│ 
      │    │   +----+           +----+   +----+             +----+   +----+ 
      │    │   │    │           │s1.3│   │b3.1│             │s1.3│   │b3.1│ 
      +----+   │    │           +----+   +----+ отбрасываем +----+   +----+ 
      │    │   │    │  рубим    │    │   │    │   лишнее    │    │   │    │ 
      │ s2 │   │ b3 │ =======>  │s2.1│   │b3.2│ ==========> │s2.1│   │b3.2│ 
      │    │   │    │           │    │   │    │             │    │   │    │ 
      +----+   │    │           +----+   +----+             +----+   +----+ 
      │    │   │    │           │s3.1│   │b3.3│             │s3.1│   │b3.3│ 
      │ s3 │   +----+           +----+   +----+             +----+   +----+ 
      │    │   │    │           │s3.2│   │b4.1│             │s3.2│   │b4.1│ 
      +----+   │ b4 │           +----+   +----+             +----+   +----+ 
      │    │   │    │           │s4.1│   │b4.2│             │s4.1│   │b4.2│
      │ s4 │   L-----           +----+   L-----             L-----   L-----
      │    │                    │s4.2│
      L-----                    L-----

   Алгоритм рубки:
      0. i = 0;
      1. Сравниваем i-ые элементы массивов. Если к-во бумаг в этих элементах
         не равно, то делим тот элемент, в котором бумаг больше, оставляя
         в нем столько бумаг, сколько находится в элементе другого массива.
         После деления к-во бумаг в i-ых элементах должно уравняться.
         Переходим к шагу 2.
      2. Если i - это последний элемент хотя бы одного из массивов -
         заканчиваем работу. Иначе увеличиваем i и переходим к шагу 1.

   Алгоритм отбрасывания лишних платежей:
      К-во порубленных платежей покупок должно быть равно к-ву продаж.
      Если это не так, отбросим лишние платежи покупки или продажи.
      В примере отбрасываем одну лишнюю продажу. */


   /* Делим один элемент массива платежей на две части, оставляя в нем
      RestAmount бумаг, часть бумаг перенося в новый элемент.
      Сдвигаем элементы массива на один вперед и вставляем новый элемент
      после разделяемого.
         Arr         - массив
         ItemNum     - номер элемента
         RestAmount  - к-во бумаг, которое должно остаться в разделемом
                       элементе */
      macro ChopItem( Arr, ItemNum, RestAmount )
         var
            counter;

         if( Arr[ItemNum].Amount <= RestAmount )
         /* Хотим оставить бумаг больше чем есть или столько, сколько есть
            сейчас. */
            RunError( "Логическая ошибка в процедуре ChopItem" );
         end;

      /* Сдвигаем элементы вперед. */
         counter = Arr.Size-1;
         while( counter > ItemNum )
            Arr[counter + 1] = Arr[counter];
            counter = counter - 1;
         end;

      /* Вставляем новый. */
         Arr[ItemNum + 1] = TPaymInfo( Arr[ItemNum].NetPaymID,
                                    Arr[ItemNum].PaymID, Arr[ItemNum].DealID,
                                    Arr[ItemNum].Amount - RestAmount );

      /* Корректируем разделяемый. */
         Arr[ItemNum].Amount = RestAmount;
      end;

      var
         i = 0;

      while( (i < SalePaymArray.Size) and (i < BuyPaymArray.Size) )

      /* Делим элементы при необходимости. */
         if( BuyPaymArray[i].Amount > SalePaymArray[i].Amount )
            ChopItem( BuyPaymArray, i, SalePaymArray[i].Amount );
         elif( BuyPaymArray[i].Amount < SalePaymArray[i].Amount )
            ChopItem( SalePaymArray, i, BuyPaymArray[i].Amount );
         end;

      /* К-во элементов здесь должно быть равно. */
         if( BuyPaymArray[i].Amount != SalePaymArray[i].Amount )
            RunError( "Логическая ошибка в процедуре ChopPayments" );
         end;

         i = i + 1;
      end;

   /* Отбрасываем лишние платежи. */
      if( BuyPaymArray.Size < SalePaymArray.Size )
         SalePaymArray.Size = BuyPaymArray.Size;
      else
         BuyPaymArray.Size = SalePaymArray.Size;
      end;
    END;
/* Отбор платежей, участвовавших в неттинге.
   Отбираем платежи в том порядке, в котором они отбираются в соглашении
   о неттинге.
      Data           - данные отчета
      NettingID      - код операции неттинга
      BuyPaymArray   - массив для возврата платежей по покупке
      SalePaymArray  - массив для возврата платежей по продаже */
      PRIVATE MACRO CollectPayments( NettingID, BuyPaymArray, SalePaymArray )
   /* Добавить запись в массив платежей. */
         macro InsertRecToArray( Arr, pmlink, pmpaym )
            Arr[Arr.Size] = TPaymInfo( pmlink.PaymLinkID, pmpaym.PaymentID,
                                 pmpaym.DocumentID, pmlink.Amount );
         end;

         var
            pmlink      = TBFile( "pmlink", "R", 1 ),
            pmpaym      = TBFile( "pmpaym" ),
            continue_cicle;

   /* В соглашении о неттинге (ntgftag.mac) платежи отбираются из
      pmlink по 1-ому ключу. Здесь тоже делаем так. */

         BuyPaymArray.Size = 0;
         SalePaymArray.Size = 0;

         pmlink.Clear();
         pmlink.rec.DocKind      = DL_NTGDOC;
         pmlink.rec.DocumentID   = NettingID;
         pmlink.rec.LinkKind     = PMLINK_KIND_NETTING;
         continue_cicle = pmlink.GetGE();
         while( continue_cicle   and (pmlink.rec.DocKind == DL_NTGDOC)
                     and (pmlink.rec.DocumentID == NettingID)
                     and (pmlink.rec.LinkKind == PMLINK_KIND_NETTING) )

         /* Получаем платеж. */
            pmpaym.Clear();
            pmpaym.rec.PaymentID = pmlink.rec.InitialPayment;
            if( pmpaym.GetEQ() )

         /* Если платеж подходит сохраняем данные. */
               if(   ((pmpaym.rec.Purpose == BAi) or (pmpaym.rec.Purpose == BRi))
                    and (pmpaym.rec.DocKind == DL_SECURITYDOC) )
                  if( pmpaym.rec.Payer == {OurBank} )
               /* Обязательство. Значит продажи. */
                     InsertRecToArray( SalePaymArray, pmlink.rec, pmpaym.rec );
                  else
               /* Требования. Значит покупка. */
                     InsertRecToArray( BuyPaymArray, pmlink.rec, pmpaym.rec );
                  end;
               end;
            end;
            continue_cicle = pmlink.Next();
         end;
      END;
/* Проверка ценной бумаги на соответствие параметрам отчета и, в случае
   соответствия, получение параметров бумаги.
      Data     - данные отчета
      FIID     - код бумаги */
   PRIVATE MACRO CheckAvoirAndGetParam(
                        FIID,
                        H03_Market:@string, H04_National:@string,
                        Н05_Currency:@string, H06_BondKind:@string,
                        H07_Kind:@string, FaceFIID:@integer
                        )
      record avoiriss(avoiriss);
      record fininstr(fininstr);
      var
         IsShare, IsBond, IsDeposReceipt, BondKind, EuroBond, IssuerNotRes,
         CircInMarket, FaceValueRUR;

   /* Проверяем вид ц/б */
      macro CheckAvoirKind
         return   AllAv
               or ( ShareAv and IsShare )
               or ( BondAv  and IsBond )
               or ( DeposAv and IsDeposReceipt );
      end;

   /* Проверяем вид облигации */
      macro CheckBond
         return      ( not IsBond )
               or ( MunicipalAv  and (BondKind == муниципальные) )
               or ( CorporativeAv and (корпоративные(BondKind)) )
               or ( StateAv and IsStateBondKind(BondKind) );
      end;

   /* Получаем параметры бумаги */
      if( ПолучитьФинИн(FIID, fininstr, avoiriss) )
         return false;
      end;

      IsShare        = FI_IsShare( fininstr, false );
      IsBond         = FI_IsBond( fininstr );
      IsDeposReceipt = FI_IsDeposReceipt( fininstr );
      BondKind       = IIF( IsBond, ПолучитьВидОблигации(avoiriss), 0 );
      EuroBond       = BondKind == еврооблигации;
      CircInMarket   = FI_CircInMarket(avoiriss, EndDate);
      FaceValueRUR   = fininstr.FaceValueFI == NATCUR;
      IssuerNotRes   = PartyIsNotResident( fininstr.Issuer, true );

      if(   (IsShare or IsBond or IsDeposReceipt)
         /* Проверяем вид ц/б */
         and CheckAvoirKind
         /* Проверяем валюту номинала. */
         and CheckFlag( FaceValueRUR, FaceRUR, FaceCUR )
         /* Проверяем обращение на ОРЦБ. */
         and CheckFlag( CircInMarket, CircInM, NotCircInM )
         /* Проверяем вид облигации */
         and CheckBond
         /* Проверяем эмитента */
         and CheckFlag( IssuerNotRes, ForeignAv, NationalAv )
         )

      /* Бумага подходит. Определяем параметры. */

      /* H0.3
         Выводится текст "обращающимися на ОРЦБ" или "не обращающимися на
         ОРЦБ" */
         H03_Market = IIF( CircInMarket, "", "не " ) + "обращающимися на ОРЦБ"; 

      /* H0.4
         Если эмитент ц/б - нерезидент, то выводится текст "иностранные",
         иначе - выводится текст "российские" */
         H04_National = IIF( IssuerNotRes, "иностранные", "российские" );

      /* Н0.7
         Для акций и деп. расписок выводится  текст "акции" или
         "депозитарные расписки", иначе (для облигаций): если значение
         категории "Вид облигации" = "еврооблигации", выводится текст
         "еврооблигации", иначе - "облигации" */
         H07_Kind = IIF(   IsBond,
                        IIF( EuroBond, "еврооблигации", "облигации"  ),
                        IIF( IsShare, "акции", "депозитарные расписки" ) );

      /* Н0.5
         Если поле <H0.7> не равно "еврооблигации" и не равно "депозитарные
         расписки", то в зависимости от валюты номинала ц/б выводится текст
         "валютные" или "рублевые",  иначе - поле не заполняется */
         if(   (H07_Kind != "еврооблигации")
                and (H07_Kind != "депозитарные расписки") )
            Н05_Currency = IIF( FaceValueRUR, "рублевые", "валютные" );
         else
            Н05_Currency = "";
         end;

      /* Н0.6
         Если (вид ц/б = акция) или (вид ц/б = "деп.расписка") или (вид ц/б
         = облигация и для нее указано значение категории "Вид облигации" =
         "еврооблигации"), то поле не заполняется, иначе в зависимости от
         значения категории "Вид облигации", указанной для данной ц/б,
         выводится текст "корпоративные" или "государственные" или
         "муниципальные" */
         if( IsShare or IsDeposReceipt or (IsBond and EuroBond) )
            H06_BondKind = "";
         else
            if( BondKind == муниципальные )
               H06_BondKind = "муниципальные";
            elif( корпоративные(BondKind) )
               H06_BondKind = "корпоративные";
            else
               H06_BondKind = "государственные";
            end;
         end;

         /* Валюта номинала. */
         FaceFIID = fininstr.FaceValueFI;

         return true;
      else
      /* Бумага не подходит. */
         return false;
      end;
   END;
/* Отбор подходящих операций неттинга во временный файл.
   Возвращаем true, если данные были отобраны.
      Data     - данные отчета
      TempFile - файл для сбора данных */
   PRIVATE MACRO CollectNettingOp()
      var
         dlnet          = TBFile( "dl_nett", "R", 1 ),
         WasCollectData = false,
         H03_Market, H04_National, H05_Currency, H06_BondKind, H07_Kind,
         FaceFIID, continue_cicle;

      InitProgressBar(  dlnet.NRecords, StatLine, HeadLine1 );

   /* Отберем закрытые операции неттинга, дата валютирования которых входит
      в отчетный период. Т.к. дата валютирования не может быть меньше
      даты ввода (SigningDate), то при поиске устанавливаем SigningDate
      на начало периода. */
      dlnet.Clear();
      dlnet.rec.DocKind       = DL_NTGDOC;
      dlnet.rec.Status        = DL_CLOSED;
      dlnet.rec.SigningDate   = BegDate;
      continue_cicle          = dlnet.GetGE();
      while( continue_cicle   and (dlnet.rec.DocKind == DL_NTGDOC)
                     and (dlnet.rec.Status == DL_CLOSED)
                     and (dlnet.rec.ValueDate >= BegDate)
                     and (dlnet.rec.ValueDate <= EndDate) )

         UseProgressBar;

      /* Нас интересует только неттинг по бумагам. */
      /* Проверим, что бумага подходит под параметры отчета. */
         if(   (dlnet.rec.FI_Kind == FIKIND_AVOIRISS)
               and CheckAvoirAndGetParam( dlnet.rec.BaseFIID,
                                       @H03_Market, @H04_National,
                                       @H05_Currency, @H06_BondKind,
                                       @H07_Kind, @FaceFIID ) )

         /* Добавляем данные во временный файл. */
            ClearRecord( TempFile );
            TempFile.rec.NettingID      = dlnet.rec.NettingID;
            TempFile.rec.ValueDate      = dlnet.rec.ValueDate;
            TempFile.rec.FIID           = dlnet.rec.BaseFIID;
            TempFile.rec.FaceFIID       = FaceFIID;
            TempFile.rec.H03_Market     = H03_Market;
            TempFile.rec.H04_National   = H04_National;
            TempFile.rec.H05_Currency   = H05_Currency;
            TempFile.rec.H06_BondKind   = H06_BondKind;
            TempFile.rec.H07_Kind       = H07_Kind;
            InsertRecTempFile( TempFile );
            WasCollectData = true;

         end;

         continue_cicle = dlnet.Next();
      end;

      RemProgressBar;
      return WasCollectData; 
   END;

   var
      BuyPaymArray   = TArray,      /* Платежи по покупке. */
      SalePaymArray  = TArray,      /* Платежи по продаже. */
      Prev_H03       = null,
      Prev_H04       = null,
      Prev_H05       = null,
      Prev_H06       = null,
      Prev_H07       = null,
      FirstTable     = true,
      continue_cicle, PaymCnt;

   ObjReport.BeginReport(); 

   if( CollectNettingOp() )
       InitProgressBar( NRecords(TempFile), StatLine, HeadLine2 );

   ClearRecord(TempFile);
   continue_cicle = GetGE(TempFile);
   while( continue_cicle )

      UseProgressBar;

      /* Если параметры бумаги изменились надо печатать след. раздел таблицы. */
      if(  (Prev_H04 != TempFile.rec.H04_National)
            or (Prev_H05 != TempFile.rec.H05_Currency)
            or (Prev_H06 != TempFile.rec.H06_BondKind)
            or (Prev_H07 != TempFile.rec.H07_Kind) )

         /* Печатаем подвал таблицы при необходимости. */
         if( FirstTable != true )
            ObjReport.PrintSummary(
                                   NumPrec(SumCostBuy,  2, IIF(Apostr, "a", ""), false),
                                   NumPrec(SumCostSale, 2, IIF(Apostr, "a", ""), false),
                                   NumPrec(SumOutlay,   2, IIF(Apostr, "a", ""), false),
                                   NumPrec(SumFinRes,   2, IIF(Apostr, "a", ""), false),
                                   NumPrec(SumDelta1,   2, IIF(Apostr, "a", ""), false),
                                   NumPrec(SumDelta2,   2, IIF(Apostr, "a", ""), false)
                                  );
            FirstTable = true;
         end; 
         ClearSummary();
         PrintDepartmentHead();
         Prev_H04    = TempFile.rec.H04_National;
         Prev_H05    = TempFile.rec.H05_Currency;
         Prev_H06    = TempFile.rec.H06_BondKind;
         Prev_H07    = TempFile.rec.H07_Kind;

         FirstTable  = false;
      end;

      /* Отбираем платежи, участвовавшие в операции неттинга. */
      CollectPayments( TempFile.rec.NettingID, BuyPaymArray, SalePaymArray );

      /* Рубим платежи. */
      ChopPayments( BuyPaymArray, SalePaymArray );

      /* Печатаем платежи. */
      PaymCnt = 0;
      while( PaymCnt < BuyPaymArray.Size )

         PrintLine(BuyPaymArray[PaymCnt], SalePaymArray[PaymCnt]);
         PaymCnt = PaymCnt + 1;
      end;
      
      continue_cicle = Next(TempFile); 

      if( continue_cicle != true )
         ObjReport.PrintSummary(
                                NumPrec(SumCostBuy,  2, IIF(Apostr, "a", ""), false),
                                NumPrec(SumCostSale, 2, IIF(Apostr, "a", ""), false),
                                NumPrec(SumOutlay,   2, IIF(Apostr, "a", ""), false),
                                NumPrec(SumFinRes,   2, IIF(Apostr, "a", ""), false),
                                NumPrec(SumDelta1,   2, IIF(Apostr, "a", ""), false),
                                NumPrec(SumDelta2,   2, IIF(Apostr, "a", ""), false)
                               );
         ClearSummary();
      end;
   end;
      ObjReport.EndReport();
      PrintFormatString( Footer );

      RemProgressBar;
   end;
 
  END;

  PRIVATE MACRO Create()
     Var FlagNotCircInM;

     FaceRUR       = m_Form.GetFieldValue( PNFLD_OPNETREG_FACERUR);
     FaceCUR       = m_Form.GetFieldValue( PNFLD_OPNETREG_FACECUR);
     CircInM       = m_Form.GetFieldValue( PNFLD_OPNETREG_CIRCINMARKET);
     NotCircInM    = m_Form.GetFieldValue( PNFLD_OPNETREG_NOTCIRCINMARKET);
     NationalAv    = m_Form.GetFieldValue( PNFLD_OPNETREG_NATIONALAV);
     ForeignAv     = m_Form.GetFieldValue( PNFLD_OPNETREG_FOREIGNAV);
   /* Проверим исключающие все возможные данные параметры фильтра. */
     if( (FaceRUR or FaceCUR)
         and (CircInM or NotCircInM)
         and (NationalAv or ForeignAv) )

        FlagNotCircInM = NotCircInM;

        if(CircInM)

           if(NotCircInM)
              NotCircInM = "";
           end;

           Prefix = "N1_";
           ExecuteReport( COpNetReg(this, Prefix, InMark) );

           NotCircInM = FlagNotCircInM;

        end;

        if(NotCircInM)

           if(CircInM)
              CircInM = "";
           end;

           Prefix = "N2_";
           ExecuteReport( COpNetReg(this, Prefix, NotInMark) );
        end;

     end;

  END;

  PRIVATE VAR m_DealBuyCode, m_DealSaleCode, m_DealSaleDate, m_DealBuyDate, m_FIName, m_ExecDate, m_SaleKind, m_BuyKind,
              m_BuyPriceStr, m_SalePriceStr, m_CostBuy, m_CostSale, m_Amount, m_Outlay, m_FinRes, m_PriceInterv_Min,
              m_PriceInterv_Max, m_MarketerMax, m_MarketerMin, m_Delta1, m_Delta2;

  MACRO ClearCacheOneRecord()
     m_DealBuyCode     = null;
     m_DealSaleCode    = null;
     m_DealSaleDate    = null;
     m_DealBuyDate     = null;
     m_FIName          = null;
     m_ExecDate        = null;
     m_SaleKind        = null;
     m_BuyKind         = null;
     m_SalePriceStr    = null;
     m_CostBuy         = null;
     m_Amount          = null;
     m_CostSale        = null;
     m_Outlay          = null;
     m_FinRes          = null;
     m_PriceInterv_Min = null;
     m_PriceInterv_Max = null;
     m_MarketerMax     = null;
     m_MarketerMin     = null;
     m_Delta1          = null;
     m_Delta2          = null;
  END;

  MACRO DealSaleCode():STRING
     /* Код сделки продажи внешний */
     m_DealSaleCode = DealSale.rec.DealCodeTS;
     return m_DealSaleCode;
  END;

  MACRO DealSaleDate():DATE
      /*   Дата заключения сделки продажи */
      m_DealSaleDate = DealSale.rec.DealDate;
      return m_DealSaleDate;
  END;

  MACRO DealBuyCode():STRING
     /*Код сделки покупки внешний */
     m_DealBuyCode = DealBuy.rec.DealCodeTS;
     return m_DealBuyCode;
  END;

  MACRO DealBuyDate():DATE
    /*  Дата заключения сделки покупки */
     m_DealBuyDate = DealBuy.rec.DealDate;
     return m_DealBuyDate;
  END;

  MACRO FIName():STRING
       /*  Наименование ц/б */
     m_FIName = GetFinInstrName( AvrFIID, true );
     return m_FIName;
  END;

  MACRO ExecDate():DATE
       /*  Фактическая дата поставки ц/б сделки продажи/покупки (= дате
         операции неттинга) */
     m_ExecDate = ValueDate;
     return m_ExecDate;
  END;

  MACRO SaleKind():STRING 
     Var Group = GetOpGroup(DealSale.rec);

     if( IsREPO(Group) ) 
        if ( IsSALE(Group) ) 
           m_SaleKind = "Пр.репо 1 ч";
        else
           m_SaleKind = "Обр.репо 2 ч";
        end;

     elif( IsSALE(Group) )
        m_SaleKind = "продажа";
     end;

     return m_SaleKind; 
  END;

  MACRO BuyKind():STRING 
     Var Group = GetOpGroup(DealBuy.rec);

     if( IsREPO(Group) ) 
        if ( IsSALE(Group) ) 
           m_BuyKind = "Пр.репо 2 ч";
        else
           m_BuyKind = "Обр.репо 1 ч";
        end;
     elif( IsBUY(Group) )
        m_BuyKind = "покупка";
     end;

     return m_BuyKind; 
  END;

  /* Получить цену. */
  MACRO GetPrice( DealRec, DlLegRec, Price:@double, PriceStr:@string, IsBond:@bool)
         /* Цена одной ц/б в валюте цены сделки XXX (с той точностью, с
            которой она указана в условиях сделки): если ВЦ = рубли, то цена
            выводится в рублях, если в условиях сделки цена указана в
            процентах от номинала, то цена выводится в ВН, с точностью 12
            знаков. */
     var NominalOnDate/*, Price*/;
     record fininstr(fininstr);
    /* Для облигаций - цена всегда в % от номинала  */
     if( ПолучитьФинИн(AvrFIID, fininstr) == 0 )
        IsBond = FI_IsBond( fininstr );
     end;
     if( IsBond )
        if( IsRelativePrice(DealRec, DlLegRec) == false ) /*тогда переводим в % от номинала*/
           NominalOnDate = GetFaceValue(AvrFIID, DealRec.DealDate);
           if( NominalOnDate != 0.0 )
              Price = DlLegRec.Price / NominalOnDate * 100.0;
           end;
        else
           Price = DlLegRec.Price;
        end;
     else
        Price = GetPriceByDlTickDlLeg( DealRec, DlLegRec );
     end;

     if( IsRelativePrice(DealRec, DlLegRec) or (IsBond) )
        PriceStr = NumPrec( Price, 12, IIF(Apostr, "a", ""), true );
     else
        PriceStr = NumPrec( Price, DlLegRec.Point, IIF(Apostr, "a", ""), true );
     end;
  END; 

  MACRO BuyPriceStr():STRING
     GetPrice( DealBuy.rec, DlLegBuy.rec, null, @m_BuyPriceStr, null );
     return m_BuyPriceStr;
  END;

  MACRO SalePriceStr():STRING

     GetPrice( DealSale.rec, DlLegSale.rec, null, @m_SalePriceStr, null );
     return m_SalePriceStr;
  END;

  /* Расчитать стоимость части лота и возвращаем ее (money).
            DlLegRec    - условия сделки
            Amount      - к-во бумаг в части лота
            ExecDate    - дата операции неттинга
            FaceFIID    - валюта номинал */
  MACRO CalcCost( DlLeg, Amount:money, ExecDate, FaceFIID )
  /* Стоимость лота XXX (или его части) плюс НКД, в рублях: если
            валюта номинала <> руб. или валюта цены <> руб., то стоимость
            ц/б и НКД переводятся в рубли по курсу на дату операции
            неттинга <A7> */
     var
        CostRUR  = 0.0,
        NKDRUR   = 0.0;

     SmartConvertSumDbl(  CostRUR, MoneyToDouble(DlLeg.Cost),
                              ExecDate, DlLeg.CFI, NATCUR, true );
     SmartConvertSumDbl(  NKDRUR, MoneyToDouble(Dlleg.NKD),
                              ExecDate, FaceValFIID, NATCUR, true );

     return DoubleToMoney( (CostRUR + NKDRUR) * Amount / DlLeg.Principal );
  END;

  MACRO GetCostBuy()
     return CalcCost( DlLegBuy.rec, BuyPaymInfo.Amount, ValueDate, FaceValFIID );
  END;

  MACRO CostBuy():STRING
     m_CostBuy = GetCostBuy();
     SumCostBuy = SumCostBuy + m_CostBuy;
     return NumPrec(m_CostBuy, 2, IIF(Apostr, "a", ""), true);
  END;

  MACRO Amount():INTEGER
     m_Amount = BuyPaymInfo.Amount;
     return m_Amount;
  END;

  MACRO GetCostSale()
     return CalcCost( DlLegSale.rec, BuyPaymInfo.Amount, ValueDate, FaceValFIID );
  END;

  MACRO CostSale():STRING
     m_CostSale = GetCostSale();
     SumCostSale = SumCostSale + m_CostSale;
     return NumPrec(m_CostSale, 2, IIF(Apostr, "a", ""), true);
  END;
  /* Считаем комисии по сделке и предварительные затраты.
            ExecDate - дата исполнения (дата поставки)
            Deal     - тикет сделки
            IsBuy    - это покупка бумаг
            IsBack   - флаг, платеж по обратной части сделки
            Amount   - к-во бумаг в части лота
            DlLeg    - условия сделки */
  MACRO CalcOutlayForDeal( ExecDate, Deal, IsBuy, IsBack, Amount, DlLeg )
         /* Комиссии включаются в сумму затрат, только если они оплачены. */
         /* Суммы всех комиссий берутся без НДС. */
         /* В сделке, состоящей из двух частей, регистрационный сбор по
            покупке относится к затратам на покупку, а рег. сбор по продаже -
            к затратам по реализации. */
         /* Всю сумму предварительных затрат, указанную в сделке, состоящей
            из двух частей, в данном отчете следует относить к первой части
            сделки. */
         /* если в сделке затраты/рег.сбор/комиссия заданы в валюте,
            отличной от НацВ, то сумма затрат/рег.сбора переводится в НацВ по
            курсу на дату поставки сделки */
     record dl_tick( "dl_tick" );
     var
            PayPeriodSums  = ComissionSums(),
            OnceComPay     = ComissionSums(),
            SummComAgent   = $0,
            SummComBank    = $0,
            NDSComBank     = $0,
            PreOutlay, ResultTotal, Result;

         /* Считаем периодические и единовременные комиссии. */
     copy( dl_tick, Deal );
     ПолучитьКомиссииПоСделке(  dl_tick, dl_tick.CommDate,
                                    PayPeriodSums, null, OnceComPay, null,
                                    true, ExecDate, NATCUR, null,
                                    GetLegKindByBackFlag(IsBack) );

         /* Считаем распределенные комиссии. */
     ПолучитьСуммуРаспределенныхКомиссийПоСделке(
        Deal.rec, SummComAgent, null, SummComBank, null,
        null, null, NATCUR, ExecDate, 1 );

         /* Предварительные затраты. */
     PreOutlay = IIF( IsBack, $0, Deal.rec.PreOutlay );

         /* Итого. */
     ResultTotal =    OnceComPay.RegSum
                    + OnceComPay.AgentSum
                    + PayPeriodSums.AgentSum
                    + SummComAgent + SummComBank
                    + PreOutlay;

     Result = DoubleToMoney( MoneyToDouble(ResultTotal)
                            * Amount / DlLeg.Principal );

     return Result;
  END;

  MACRO GetOutlay()
      return CalcOutlayForDeal( ValueDate, DealBuy, true, IsBackBuy, BuyPaymInfo.Amount,
                                    DlLegBuy.rec )
               + CalcOutlayForDeal( ValueDate, DealSale, false, IsBackSale,
                                    BuyPaymInfo.Amount, DlLegSale.rec );
  END;

  MACRO Outlay():STRING
     m_Outlay = GetOutlay();
     SumOutlay = SumOutlay + m_Outlay;
     return NumPrec(m_Outlay, 2, IIF(Apostr, "a", ""), true);
  END;

  MACRO FinRes():STRING

     m_FinRes = GetCostSale() - GetCostBuy() - GetOutlay();
     SumFinRes = SumFinRes + m_FinRes;
     return NumPrec(m_FinRes, 2, IIF(Apostr, "a", ""), true);
  END;
                
  PRIVATE MACRO GetCourse(Type, DealDate, _CourceDbl, _MarketName, _Point, _CursFI, _CursDate)

     Var Nominal = 0, PriceInterv, CourceDbl = 0.0, MarketName, Point, CursFI, CursDate;
     var IsExistsCourse;

   /* Возвращаем курс заданного типа и имя торговой площадки. */ 
     MACRO ПолучитьКурсФИ(_Date, _Type)
        var RateDef = TRecHandler("ratedef");
        var sql, rsd;

        ClearRecord(RateDef.rec);

        CourceDbl = 0.0;
        CursDate = date(0,0,0);
        MarketName = "";
        Point = 0;
        CursFI = -1;

        sql = RSDCommand(" SELECT * "
            + "   FROM dratedef_dbt "
            + "  WHERE t_OtherFI = ? "
            + "    AND t_Type = ? "
            + " ORDER BY t_IsDominant DESC "); /* первым будет основной */

        sql.addParam( "", RSDBP_IN, AvrFIID );
        sql.addParam( "", RSDBP_IN, _Type );
        sql.execute();

        rsd = TRsbDataSet(sql);
        if( rsd.MoveNext() )
           RateDef = rsd.GetRecord();

           if( ConvSumDbl(CourceDbl, 1.0, _Date, AvrFIID, RateDef.FIID, false, _Type, CursDate) == true )
              MarketName = GetPartyShortNameByID(RateDef.Market_Place);
              Point = RateDef.Point;
              CursFI = RateDef.FIID;
              return true;
           end;
        end;

        return false;
     END;

     if( ПолучитьКурсФИ( DealDate, Type ) != true )
        if( ПолучитьКурсФИ( DealDate - 365, Type ) != true )
           if( ПолучитьКурсФИ( DealDate, 6 ) != false )
              MarketName = "расчетная цена";
              IsExistsCourse = true;
           else
              IsExistsCourse = false;
           end;
        else
           IsExistsCourse = true;
        end;
     else
        IsExistsCourse = true;
     end;

     if( IsExistsCourse != false )

         SetParm(3, CourceDbl );
         SetParm(4, MarketName );
         SetParm(5, Point);
         SetParm(6, CursFI);
         SetParm(7, CursDate);

         return true;
     else
         SetParm(3, 0.0 );
         SetParm(4, "" );
         SetParm(5, 0);
         SetParm(6, -1);
         SetParm(7, date(0,0,0));

         return false;
     end;
  END;

  MACRO GetIntMinMac(Type, DealDate, PrcInt:@double)

     Var Nominal = 0, PriceInterv = 0.0, MarketName, Point, CursFI, CursDate, PriceInterv_str = "";
     var IsBond;
     record fininstr(fininstr);

    /* Для облигаций - цена всегда в % от номинала  */
     if( ПолучитьФинИн(AvrFIID, fininstr) == 0 ) /*"минимальная цена"*/
        IsBond = FI_IsBond( fininstr );
     end;

     PrcInt = 0.0;

     if( GetCourse(Type, DealDate, PriceInterv, MarketName, Point, CursFI, CursDate) != false )

        Nominal = GetFaceValue(AvrFIID, CursDate);

        if( CursFI != NATCUR ) 
           SmartConvertSumDbl(PriceInterv, PriceInterv, DealDate, CursFI, NATCUR, false);
        end;

        if( FaceValFIID != NATCUR)
           SmartConvertSumDbl(Nominal, Nominal, DealDate, FaceValFIID, NATCUR, false);
        end;

        if( (IsBond) and (Nominal != 0) )
           PriceInterv_str = NumPrec(PriceInterv / Nominal * 100, Point, IIF(Apostr, "a", ""), true)/* + "%"*/;
           PrcInt = PriceInterv / Nominal * 100;
        elif( not IsBond )
           PriceInterv_str = NumPrec(PriceInterv, Point, IIF(Apostr, "a", ""), true);
           PrcInt = PriceInterv;
        end;
     end;

     return PriceInterv_str;
  END;

  MACRO IntMin():STRING/*Контрольный интервал цен/ мин.*/
  /*Курс вида "минимальная цена" для данного выпуска ц/б на дату <A2>. 
    Заполняется всегда, когда есть такой курс для данной бумаги за дату <A2> или на дату позднее, чем  1 год до даты <A2>. 
    Если указанный курс в дату <A2>отсутствует, то используется курс за самую позднюю дату, но не ранее, чем 1 год до даты <A2>.
    Если курс вида "минимальная цена" за период 1 год до даты <A2> не найден, то выводится курс значения вида "расчетная цена" на дату <A2>
    Для облигаций всегда выводится в % от номинала, причем, если указан курс облигации в ва-люте номинала, 
    то он переводится в % с использованием номинала, действующего на вечер даты курса. 
    Для акций при необходимости курс ценной бумаги переводится в рубли, по курсу на дату за-ключения <A2>*/

     m_PriceInterv_Min = GetIntMinMac(2, DealSale.rec.DealDate);
     return m_PriceInterv_Min;
  END;

  MACRO IntMax():STRING /*Контрольный интервал цен/ макс.*/
    /*Курс вида "максимальная цена" для данного выпуска ц/б  на дату <A4>. 
      Заполняется всегда, когда есть такой курс для данной бумаги за дату <A4> или на дату позднее, чем  1 год до даты <A4>. 
      Если указанный курс в дату <A4> отсутствует, то используется курс за самую позднюю дату, но не ранее, чем 1 год до даты <A4>.
      Если курс вида "максимальная цена" за период 1 год до даты <A4> не найден, то выводится курс значения вида "расчетная цена" на дату <A4>
      Для облигаций всегда выводится в % от номинала, причем, если указан курс облигации в ва-люте номинала, 
      то он переводится в % с использованием номинала, действующего на вечер даты курса. 
      Для акций при необходимости курс ценной бумаги переводится в рубли, по курсу на дату за-ключения <A4>*/

     m_PriceInterv_Max = GetIntMinMac(3, DealBuy.rec.DealDate);
     return m_PriceInterv_Max;
  END;

  MACRO MarketerMin():STRING /*Организатор торговли, мин*/
    Var MarketName;

  /*Если в графе <A21а> выводится курс вида "минимальная цена", 
    то <A22>= сокращенное на-именование торговой площадки, указанной для этого курса. 
    Если в графе <A21а> выводится курс вида "расчетная цена", то <A22>="расчетная цена".*/
    if( GetCourse(2, DealSale.rec.DealDate, null, MarketName, null, null, null) != false )
       m_MarketerMin = MarketName;
    else
       m_MarketerMin = "";
    end;

    return m_MarketerMin;
  END;

  MACRO MarketerMax():STRING /*Организатор торговли, макс*/
    Var MarketName;

  /*Если в графе <A21b> выводится курс вида "максимальная цена", 
    то <A23>= сокращенное наименование торговой площадки, 
    указанной для этого курса. Если в графе <A21b> выводится курс вида " расчетная цена", то <A23>="расчетная цена".*/
    if( GetCourse(3, DealBuy.rec.DealDate, null, MarketName, null, null, null) != false )
       m_MarketerMax = MarketName;
    else
       m_MarketerMax = "";
    end;

    return m_MarketerMax;
  END;

/* Правила расчета рыночных цен и отклонений от них: 
a. ЦП - цена сделки продажи, которая определяется следующим образом:
  i. для акций ЦП = <A11>(Цена сделки продажи, вал) в рублях по курс на дату заключения <A4>(Дата заключения сдел-ки покупки)
  ii.   для облигаций, ЦП=<A11>(Цена сделки продажи, вал), 
b. РП - рыночная цена при продаже, которая определяется следующим образом
  i. для обращающихся цб РП, т.е. если <A22> = наименование торговой площадки, то РП = <A21a>(Контрольный интервал цен/ мин.),
  ii.   для необращающихся цб, т.е. если <A22> = "расчетная цена", РП=< A21a>*0,8
c. ЦК - цена сделки покупки, которая определяется следующим образом:
  i. для акций ЦП=<A10> в рублях по курс на дату заключения <A4>
  ii.   для облигаций,  ЦК=<A10>(Цена сделки покупки, вал. )
d. РК-рыночная цена при покупке, которая определяется следующим образом
  i. для обращающихся цб РК , т.е. если <A23> = наименование торговой площадки, РК = <A21b>(Контрольный интервал цен/ макс.),
  ii.   для необращающихся ц, , т.е. если <A23> = "расчетная цена",  РК=<A21b>*1,2*/

  MACRO ПолучитьЦП()
     var SalePrc = 0.0, IsBond;

     GetPrice( DealSale.rec, DlLegSale.rec, @SalePrc, null, @IsBond );

     if( not IsBond )
        if(FaceValFIID != NATCUR)
           SmartConvertSumDbl( SalePrc, SalePrc, DealSale.rec.DealDate, FaceValFIID, NATCUR, false);
        end;
     end;

     return SalePrc;
  END;

  MACRO ПолучитьЦК()
     var BuyPrc = 0.0, IsBond;

     GetPrice( DealBuy.rec, DlLegBuy.rec, @BuyPrc, null, @IsBond );

     if( not IsBond )
        if(FaceValFIID != NATCUR)
           SmartConvertSumDbl( BuyPrc, BuyPrc, DealBuy.rec.DealDate, FaceValFIID, NATCUR, false);
        end;
     end;

     return BuyPrc;
  END;

  MACRO ПолучитьРК()
     var IntervMax = 0.0, MarketName;

     if( GetCourse(3, DealBuy.rec.DealDate, null, MarketName, null, null, null) != false )
        GetIntMinMac(3, DealBuy.rec.DealDate, @IntervMax);
       
        if(MarketName != "расчетная цена")
           IntervMax = 1.2 * IntervMax;
        end;
     end;
     return IntervMax;
  END;

  MACRO ПолучитьРП()
     var IntervMin = 0.0, MarketName;

     if( GetCourse(2, DealSale.rec.DealDate, null, MarketName, null, null, null) != false )
        GetIntMinMac(2, DealSale.rec.DealDate, @IntervMin);
       
        if(MarketName != "расчетная цена")
           IntervMin = 0.8 * IntervMin;
        end;
     end;
     return IntervMin;
  END;

  MACRO Delta1():STRING/*Сумма отклонения фактической выручки от реализации ниже ры-ночной цены*/
     Var RP, CP;
  /*Если не заполнено поле <A21a> и <A22>, то не заполняется.
    Если РП>ЦП , то <A24a>=(РП - ЦП)*<A13>, в противном случае поле не заполняется*/

     if( GetIntMinMac(2, DealSale.rec.DealDate) != "" )
        RP = ПолучитьРП();
        CP = ПолучитьЦП();
        if( RP > CP )
           m_Delta1 = ( RP - CP ) * BuyPaymInfo.Amount;
           SumDelta1 = SumDelta1 + m_Delta1;
        else
           m_Delta1 = "";
        end;
     else
        m_Delta1 = "";
     end;

     return NumPrec(m_Delta1, 2, IIF(Apostr, "a", ""), true);
  END;

  MACRO Delta2():STRING/*Сумма отклонения фактических затрат при приобретении выше рыночной цены*/
     Var RK, CK;
  /*Если не заполнено поле <A21b> и <A22>, то не заполняется.
    Если РК<ЦК , то <A24б>=(ЦК-РК)*<A13>, в противном случае поле не заполняется*/
     if( GetIntMinMac(3, DealBuy.rec.DealDate) != "" )
        RK = ПолучитьРК();
        CK = ПолучитьЦК();
        if( RK < CK )
           m_Delta2 = ( CK - RK ) * BuyPaymInfo.Amount;
           SumDelta2 = SumDelta2 + m_Delta2;
        else
           m_Delta2 = "";
        end;
     else
        m_Delta2 = "";
     end;

     return NumPrec(m_Delta2, 2, IIF(Apostr, "a", ""), true);
  END;

  initDL_CReportTemplate( SP_OpNetReg_Panel(), "Report_TxOpNet.xls" );  

END;

SP_OpNetReg_Report().Run(); 
Exit(1); 
