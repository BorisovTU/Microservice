/**
 @file 		mac\dlng\secur\SumConfirmExp_Report.mac
 @brief 	Отчет "Суммы подтвержденных расходов"

 # tag
 - functional_block: Отчетность_внутренняя
 - code_type: Report
 - code_type:GUI

 #menu 
  - БО ЦБ\ Внутренний учет \ Отчеты \ Поручения и операции клиентов \ Суммы подтвержденных расходов

 # changelog
 |date       |autor          |tasks                                           |note
 |-----------|---------------|------------------------------------------------|-------------------------------------------------------------
 |25.11.2025 |Велигжанин А.В.|DEF-112611                                      |Декомпозиция для масовой выгрузки через QM
 |           |               |                                                |с отображением прогресса выполнения 
 |13.11.2025 |Велигжанин А.В.|DEF-110778                                      |Поправлено условие ожидания заверешения обработки списка
 |01.11.2025 |Велигжанин А.В.|AVT_BOSS-573_AVT_BOSS-1703                      |Доработка для списка заданий
 |02.05.2025 |Велигжанин А.В.|DEF-88733                                       |Произведена декомпозиция процедуры ReportRun()
 |           |               |                                                |(для последующих доработок вывода отчета через FuncObj)
 |14.01.2025 |Велигжанин А.В.|DEF-79900                                       |Изменена сортировка

*/
import "dlquery.mac", "dldlngfun.mac", "SumConfirmExp_Form.mac", "SumConfirmExp_Print.mac", "SumConfirmExp_RepFo.mac";
import "cblogger2.mac";

private var logger = LoggerFactory().NewItLog("SumConfirmExp_Report.mac").WithElapsedTime().GetLogger();

/**
 @brief 	Ожидание завершения
*/
PRIVATE MACRO WaitingProcess( p_Cnt, p_Title )
  var 
    sql, cmd, DS, x_Progress :integer = 0;
   
  Sql = "SELECT count(*) AS cnt from itt_parallel_exec partition (P"+string(G_SumConf_CalcID)+") r where nvl(str01, 'U') = 'S'";   
  cmd = RsdCommand(sql);

  InitProgress(p_Cnt, p_Title, p_Title);
  while (x_Progress < p_Cnt)
    RslWait(2000);
    cmd.Execute();
    DS = TRsbDataSet(cmd);
    if(Ds.movenext) 
      x_Progress = int(DS.cnt);
    else
      x_Progress = p_Cnt;
    end;
    UseProgress(x_Progress);
  end;
  RemProgress();
END; // WaitingProcess()


/**
 @brief 	Формирование данных для отчета в режиме по списку.
*/
PRIVATE MACRO CreateRepDataQM(p_ParallelCnt, p_Limit)
   var cmd;
   logger.Info("CreateRepDataQM(), Cnt: " + string(G_SumConf_Cnt) + ", CalcID: " + G_SumConf_CalcID + ", GUID: " + G_SumConf_GUID);
   if(G_SumConf_Cnt > 0)
     InitProgress(-1, "Вызов процесса формирования данных для отчета о подтвержденных расходах", "Вызов QM");
     cmd = RSDCommand("BEGIN RSI_SUMCONFEXP.CallExecuteCodeInQManager( ?, ?, ?, ? ); END; ");
     cmd.AddParam( "CalcID", RSDBP_IN, G_SumConf_CalcID);
     cmd.AddParam( "ParallelCnt", RSDBP_IN, p_ParallelCnt);
     cmd.AddParam( "Limit", RSDBP_IN, p_Limit);
     cmd.AddParam( "GUID", RSDBP_IN, G_SumConf_GUID);
     cmd.execute();
     RemProgress();
     WaitingProcess( G_SumConf_Cnt, "Формирование данных для отчета о подтвержденных расходах");
   end;
END; // CreateRepDataQM


/**
 @brief 		Генерация заданий для отчета
 @param[in]  p_GUID		GUID отчета
 @param[in]  p_RepDate          Дата
 @param[in]  p_LaunchMode       Режим
 @param[in]  p_ClientID         Клиент
 @param[in]  p_DlContrID        ДБО
 @param[in]  p_FIID             бумага
 @param[in]  p_Limit            ограничистель заданий
*/
PRIVATE MACRO GenSumConfirmChunks(p_GUID, p_RepDate, p_LaunchMode, p_ClientID, p_DlContrID, p_FIID, p_Limit)
   var cmd;
   logger.Info("GenSumConfirmChunks(), p_GUID: " + p_GUID);
   InitProgress(-1, "Формирование заданий для отчета о подтвержденных расходах", "Формирование заданий");
   cmd = RSDCommand("BEGIN RSI_SUMCONFEXP.GenSumConfirmChunks( ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ); END; ");
   cmd.AddParam( "p_GUID", RSDBP_IN, p_GUID);
   cmd.AddParam( "p_RepDate", RSDBP_IN, p_RepDate);
   cmd.AddParam( "p_CurDate", RSDBP_IN, {curdate} );
   cmd.AddParam( "p_LaunchMode", RSDBP_IN, p_LaunchMode);
   cmd.AddParam( "p_ClientID", RSDBP_IN, p_ClientID);
   cmd.AddParam( "p_DlContrID", RSDBP_IN, p_DlContrID);
   cmd.AddParam( "p_FIID", RSDBP_IN, p_FIID);
   cmd.AddParam( "p_Limit", RSDBP_IN, p_Limit);
   cmd.addParam( "p_CalcID", RSDBP_OUT, V_STRING);
   cmd.addParam( "p_Cnt", RSDBP_OUT, V_INTEGER);
   cmd.execute();
   G_SumConf_CalcID = cmd.value("p_CalcID");
   G_SumConf_Cnt = cmd.value("p_Cnt");
   cmd.execute();
   RemProgress();
   logger.Info("GenSumConfirmChunks(), p_CalcID: " + G_SumConf_CalcID + ", p_Cnt: " + string(G_SumConf_Cnt));
END; // GenSumConfirmChunks()


/**
 @brief Процедура запуска отчета
        Произведена декомпозиция процедуры.
        Так как через FuncObj отчеты не заработали, параметр x_FuncObjFlag установлен, как false
        (чтобы сохранить функциональность отчета)
        При доработках печати через FuncObj, просьба править в отдельном файле (см. SumConfirmExp_RepFo.mac)
*/
PRIVATE MACRO ReportRun()
  
  var x_Form = CSumConfirmExpRep_Panel();
  var x_Rep;
  var x_FuncObjFlag = false;

  while(x_Form.Run())
    if(x_Form.LaunchMode != 2)
      GenSumConfirmChunks(G_SumConf_GUID, x_Form.RepDate, x_Form.LaunchMode, x_Form.ClientID, x_Form.DlContrID, x_Form.FIID, 0);
    end;
    CreateRepDataQM(8, 0);
    if(x_FuncObjFlag == false)
      x_Rep = CSumConfirmExp_Report(x_Form.RepDate, x_Form.LaunchMode, x_Form.ClientID, x_Form.DlContrID, x_Form.FIID, G_SumConf_GUID, 0, x_FuncObjFlag);
      x_Rep.Run();    
    else
      SumConfirmExpReportRunFuncObj(G_SumConf_GUID, x_Form.RepDate, x_Form.LaunchMode, x_Form.ClientID, x_Form.DlContrID, x_Form.FIID);
    end;
  end;
  SumConf_ClearParallelCalc();

END; // ReportRun()


ReportRun();
exit(1);