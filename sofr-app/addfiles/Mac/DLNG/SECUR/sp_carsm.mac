/*
$Name:        sp_carsm.mac
$Module:      Ценные бумаги
$Description: Выполнение сводных проводок.
 PROGRAMMED BY:   Леонов И. Е.
 CREATION DATE:   23.03.04
*/
IMPORT "sp_car.mac", RsbDataSet, "spRepFun.mac";

/*Настройка в регистре*/
PRIVATE CONST REG_PAIRACCMODE = "COMMON\\КАТЕГОРИИ СРЕДСТВ\\PAIRACCMODE";
PRIVATE VAR   PairAccModeValue;

PRIVATE FILE   DocOffTMP( "docoff.tmp" ) key 0 write;
PRIVATE FILE   DocOffTMPDtCt( "docoff.tmp" ) key 1 write;
PRIVATE FILE   DocOffTMPState( "docoff.tmp" ) key 2 write;
PRIVATE VAR    spdocoff  = TBFile( "spdocoff", "R", 1 );
PRIVATE RECORD AccountPayer(account);
PRIVATE RECORD AccountReceiver(account);
PRIVATE RECORD rAccount(account);
PRIVATE VAR    NameFile;

/*Виды идентичных по счетам проводок */
PRIVATE CONST CARRY_CURRENT   = 0, /*текущая (сравниваемая) проводка*/
              CARRY_PAIR_DT   = 1, /*Проводка со счетом Дт парным счету Дт текущей (CARRY_CURRENT) проводки*/
              CARRY_PAIR_CT   = 2, /*Проводка со счетом Кт парным счету Кт текущей (CARRY_CURRENT) проводки*/
              CARRY_PAIR_DTCT = 3; /*Проводка со счетами Дт и Кт парными счетам Дт и Кт текущей (CARRY_CURRENT) проводки*/

PRIVATE MACRO SayError( RslErrObj )
   MsgBox( RslErrObj.Module + " строка " + RslErrObj.Line + "|" + RslErrObj.Message);
   return 1;
END;

/*Закачать во временный файл проводку. 
  Если там уже есть проводка с такими же параметрами, то просуммировать */
PRIVATE MACRO AddInDocOffTMP()

   ClearRecord( DocOffTMPDtCt );
   DocOffTMPDtCt.Chapter    = spdocoff.rec.Chapter;
   DocOffTMPDtCt.DtFIID     = spdocoff.rec.Currency_Payer;
   DocOffTMPDtCt.DtAccount  = spdocoff.rec.Account_Payer;
   DocOffTMPDtCt.CtFIID     = spdocoff.rec.Currency_Receiver;
   DocOffTMPDtCt.CtAccount  = spdocoff.rec.Account_Receiver;
   DocOffTMPDtCt.State      = STATE_CHECK;
   DocOffTMPDtCt.DocOffID   = spdocoff.rec.Id;
   DocOffTMPDtCt.GroundKind = spdocoff.rec.GroundKind;

   if( GetEQ( DocOffTMPDtCt ) )                        
      DocOffTMPDtCt.DtSumma = DocOffTMPDtCt.DtSumma + spdocoff.rec.Sum_Payer;
      DocOffTMPDtCt.CtSumma = DocOffTMPDtCt.CtSumma + spdocoff.rec.Sum_Receiver;
      Update( DocOffTMPDtCt, null, true );
   else
      DocOffTMPDtCt.DtSumma = spdocoff.rec.Sum_Payer;
      DocOffTMPDtCt.CtSumma = spdocoff.rec.Sum_Receiver;
      Insert( DocOffTMPDtCt, null, true );
   end;
   return 0;

   OnError( RslErrObj )
      return SayError( RslErrObj );
END;                      

PRIVATE MACRO НайтиПарныйСчет( Chapter:INTEGER, FIID:INTEGER, Account:STRING )
   if( GetAccount( Chapter, FIID, Account, rAccount ) )
       return rAccount.PairAccount;
   end;
   return "";
END;

PRIVATE MACRO ЕстьПроводкиПоСчету( Chapter:INTEGER, FIID:INTEGER, Account:STRING, CarryDate:DATE, ID:INTEGER )
   var ExistCarry, Continue_cicle;

   if( FIID == NATCUR )
      ExistCarry = ( DebetA( Account, CarryDate, NULL, Chapter ) != 0 );
      if( ExistCarry == false )
         ExistCarry = ( KreditA( Account, CarryDate, NULL, Chapter ) != 0 );
      end;
   else
      ExistCarry = ( DebetAC( Account, FIID, CarryDate, NULL, Chapter ) != 0 );
      if( ExistCarry == false )
         ExistCarry = ( KreditAC( Account, FIID, CarryDate, NULL, Chapter ) != 0 );
      end;
   end;

   if( ExistCarry == false ) /*проверить в отложенных*/
      ClearRecord( DocOffTMP );
      Continue_cicle = GetGE( DocOffTMP ); /*Сортировка по ID*/
      while( Continue_cicle AND (DocOffTMP.ID < ID) )

         if( (DocOffTMP.State   == STATE_EXECUTE) AND
             (DocOffTMP.Chapter == Chapter) AND
             ( ( (DocOffTMP.DtFIID == FIID) AND (DocOffTMP.DtAccount == Account)
               ) OR
               ( (DocOffTMP.CtFIID == FIID) AND (DocOffTMP.CtAccount == Account)
               )
             )
           )
            ExistCarry = true;
            Continue_cicle   = false;
         else
            Continue_cicle = Next( DocOffTMP ); /*Сортировка по ID*/
         end;
      end;
   end;

   return ExistCarry;
END;

PRIVATE MACRO ОстатокСчета( Chapter:INTEGER, FIID:INTEGER, Account:STRING, CarryDate:DATE )
   if( FIID ) 
      return RestAC( Account, FIID, CarryDate, null, Chapter );
   else
      return RestA( Account, CarryDate, null, Chapter );
   end;
END;

PRIVATE MACRO ВыбратьПарныйСчет( Chapter:INTEGER, FIID:INTEGER, Account:STRING, CarryDate:DATE, ID:INTEGER )
   var PairAccount = НайтиПарныйСчет( Chapter, FIID, Account );

   if( PairAccount == "" )
      return Account;
   end;

   /*Проверить наличие исполненных проводок
     Если по одному из счетов были проводки, а по другому нет, то вернуть тот, по которому были
     Если проводки были по обоим счетам, вернуть "Номер счета"(Account) */
   if( ЕстьПроводкиПоСчету( Chapter, FIID, Account, CarryDate, ID ) )
      return Account; /*Праводка была либо только по основному счету, либо по обоим (основному и парному) счетам*/
   elif( ЕстьПроводкиПоСчету( Chapter, FIID, PairAccount, CarryDate, ID ) )
      return PairAccount; /*Проводка была только по парному счету*/
   end;

   /*Проводок по счетам не было, 
     Проверить наличие остатков по счетам Account и PairAccount на начало заданной Даты.
     Если по одному счету есть остаток, а по другому  -нет, то вернуть тот, по которому есть.
     Если остатки есть по обоим счетам, вернуть "Номер счета"(Account) */
   if( ОстатокСчета( Chapter, FIID, Account, CarryDate-1 ) != 0 )
      return Account;
   elif( ОстатокСчета( Chapter, FIID, PairAccount, CarryDate-1 ) != 0 )
      return PairAccount;
   end;

   /*По счетам нет проводок и остатков на дату*/
   return Account;
END;

PRIVATE MACRO СтатусПарногоСчета( DocOff )
   if( (PairAccModeValue == 0) OR  /*"По 61 инструкции"*/
       (PairAccModeValue == 2)     /*"По 61 инструкции с контролем остатков"*/
     ) 
      DocOff.State = STATE_CORRECTPAIR;
   else
      DocOff.State = STATE_EXECUTE;
   end;
END;

/*ф-я переделана по 87909*/
PRIVATE MACRO GetNextDocOffTMPState( State:INTEGER )

   var Query, DataSet;

   Query = " Select t_State, t_DocOffId, t_Id "
         + "   FROM " + NameFile
         + " WHERE t_State = " + string(State)
         + " Order By t_State, t_DocOffId, t_Id "; /*по 2 ключу*/

   DataSet = TRsbDataSet(Query);
   if (DataSet.MoveNext())

      ClearRecord( DocOffTMPState );
      DocOffTMPState.State    = DataSet.State;
      DocOffTMPState.DocOffId = DataSet.DocOffId;
      DocOffTMPState.Id       = DataSet.Id;

      return (GetEQ(DocOffTMPState));
   end;
   return false;
END;

PRIVATE MACRO DeleteDocOffTMPByID( Id:INTEGER )
   ClearRecord( DocOffTMP );
   DocOffTMP.Id = Id;
   if( GetEQ( DocOffTMP ) )
      Delete( DocOffTMP );
   end;
END;

PRIVATE MACRO UpdateDocOffTMPByID( DocOff:VARIANT )
   ClearRecord( DocOffTMP );
   DocOffTMP.Id = DocOff.Id;
   if( GetEQ( DocOffTMP ) )
      copy( DocOffTMP, DocOff );
      update( DocOffTMP, null, true );
   end;
END;

PRIVATE MACRO FindDocOffTMPDtCt( Chapter:INTEGER, DtFIID:INTEGER, DtAccount:STRING, CtFIID:INTEGER, CtAccount:STRING, GroundKind:INTEGER )
   ClearRecord( DocOffTMPDtCt );
   DocOffTMPDtCt.Chapter   = Chapter;
   DocOffTMPDtCt.DtFIID    = DtFIID;
   DocOffTMPDtCt.DtAccount = DtAccount;
   DocOffTMPDtCt.CtFIID    = CtFIID;
   DocOffTMPDtCt.CtAccount = CtAccount;
   DocOffTMPDtCt.GroundKind = GroundKind;
   if( GetEQ( DocOffTMPDtCt ) )
      return DocOffTMPDtCt;
   end;
   return null;
END;

PRIVATE MACRO FindCarryInArray( IdentCarry:TArray, DtKind_Account:STRING, CtKind_Account:STRING )
   var i = 0;
   while( i < IdentCarry.Size )
     if( IdentCarry[i] != null )
        if( ( (DtKind_Account == "") OR
              (  GetAccount( IdentCarry[i].Chapter, IdentCarry[i].DtFIID, IdentCarry[i].DtAccount, rAccount ) AND
                 (rAccount.Kind_Account == DtKind_Account)
              )
            ) AND
            ( (CtKind_Account == "") OR
              (  GetAccount( IdentCarry[i].Chapter, IdentCarry[i].CtFIID, IdentCarry[i].CtAccount, rAccount ) AND
                 (rAccount.Kind_Account == CtKind_Account)
              )
            )
          )
           return IdentCarry[i].Id;
        end;
     end;
     i = i + 1;
   end;
   return 0;
END;

/* Массив IdentCarry содержит от 1 до 4-х записей идентичных по счетам проводок
  Выбираем среди них  главную в порядке следующих приоритетов:
  a.  если оба счета парные - такую, что по Дт  - активный счет, и по Кт -пассивный счет
  b.  если счет по Дт парный -такую, что счет по Дт активный, а по Кт -любой
  c.  если счет по Кт парный -такую, что счет по Кт пассивный, а по Дт -любой
  d.  текущую 
  Оставляем только главную проводку, остальные суммируем к ней и удаляем*/
PRIVATE MACRO СформироватьСуммарнуюПроводку( IdentCarry:TArray )
   var i = 0, MainAccIndex = -1, MainAccID = 0;

   if( IdentCarry[CARRY_PAIR_DTCT] != null ) /*оба счета парные*/
      MainAccID = FindCarryInArray( IdentCarry, bal_acc_active, bal_acc_passive );
   end;
   if( (MainAccID == 0) AND (IdentCarry[CARRY_PAIR_DT] != null) ) /*счет по Дт парный*/
      MainAccID = FindCarryInArray( IdentCarry, bal_acc_active, "" );
   end;
   if( (MainAccID == 0) AND (IdentCarry[CARRY_PAIR_CT] != null) ) /*счет по Кт парный*/
      MainAccID = FindCarryInArray( IdentCarry, "", bal_acc_passive );
   end;
   if( MainAccID == 0 )
      MainAccID = IdentCarry[CARRY_CURRENT].Id;
   end;

   i = 0; /*Индекс главной проводки*/
   while( (MainAccIndex < 0) AND (i < IdentCarry.Size) )
      if( (IdentCarry[i] != null) AND (IdentCarry[i].Id == MainAccID) )
         MainAccIndex = i;
      end;
      i = i + 1;
   end;

   i = 0; /*Суммируем к главной остальные*/
   while( i < IdentCarry.Size )
      if( (i != MainAccIndex) AND (IdentCarry[i] != null) )
         IdentCarry[MainAccIndex].DtSumma = IdentCarry[MainAccIndex].DtSumma + IdentCarry[i].DtSumma;
         IdentCarry[MainAccIndex].CtSumma = IdentCarry[MainAccIndex].CtSumma + IdentCarry[i].CtSumma;
         /*удаляем просуммированную проводку*/
         DeleteDocOffTMPByID( IdentCarry[i].Id );
      end;
      i = i + 1;
   end;

   /*На главную проводку ставим статус STATE_COMPARE для дальнейшей обработки в "СверткаПротивоположныхПарныхПроводок"*/
   IdentCarry[MainAccIndex].State = STATE_COMPARE;
   UpdateDocOffTMPByID( IdentCarry[MainAccIndex] );
END;

/* A1, A2 - суммы по Дт и Кт первой проводки
   B1, B2 - суммы по Дт и Кт второй проводки */
PRIVATE MACRO СравнитьСуммы( A1:MONEY, A2:MONEY, B1:MONEY, B2:MONEY )
   if( (A1 == B2) AND (A2 == B1) )
      return 0; /*проводки равны*/
   elif( ( (A1 > B2) AND (A2 > B1) ) )
      return 1; /*первая больше*/
   elif( ( (A1 < B2) AND (A2 < B1) ) )
      return -1; /*первая меньше*/
   else
      return 2; /*нельзя сравнить*/
   end;
END;

PRIVATE MACRO СформироватьРезультирующуюПроводку( Carry:VARIANT, BackCarry:VARIANT )
   var CmpSum;
   if( BackCarry == null )
      СтатусПарногоСчета( Carry );
      UpdateDocOffTMPByID( Carry );
   else
      CmpSum = СравнитьСуммы( Carry.DtSumma, Carry.CtSumma, BackCarry.DtSumma, BackCarry.CtSumma );
      if( CmpSum == 0 ) /*проводки равны, взаимно погасились*/
         DeleteDocOffTMPByID( Carry.Id );
         DeleteDocOffTMPByID( BackCarry.Id );
      elif( CmpSum == 1 ) /*первая больше*/
         СтатусПарногоСчета( Carry );
         Carry.DtSumma = Carry.DtSumma - BackCarry.DtSumma;
         Carry.CtSumma = Carry.CtSumma - BackCarry.CtSumma;
         UpdateDocOffTMPByID( Carry );
         DeleteDocOffTMPByID( BackCarry.Id );
      elif( CmpSum == -1 ) /*вторая больше*/
         СтатусПарногоСчета( BackCarry );
         BackCarry.DtSumma =  BackCarry.DtSumma - Carry.DtSumma;
         BackCarry.CtSumma =  BackCarry.CtSumma - Carry.CtSumma;
         UpdateDocOffTMPByID( BackCarry);
         DeleteDocOffTMPByID( Carry.Id );
      else /*нельзя сравнить, все оставляем как есть*/
         СтатусПарногоСчета( Carry );
         СтатусПарногоСчета( BackCarry );
         UpdateDocOffTMPByID( Carry );
         UpdateDocOffTMPByID( BackCarry);
      end;
   end;
END;

/*Перебирает проводки со статусом STATE_CHECK и из проводок с одинаковыми 
  счетами по Дт и Кт (с учетом возможной парности счетов) оставляет только 
  одну суммарную*/
PRIVATE MACRO СверткаИдентичныхПарныхПроводок()
   var NumCarry = 0, DtPairAcc, CtPairAcc,
       IdentCarry = TArray();

   InitProgress( -1, "Выполнение сводных проводок ...", "Свертка идентичных проводок по парным счетам" );

   /*Изменяем ключевую последовательность (State), поэтому всегда GetGE*/
   while( GetNextDocOffTMPState( STATE_CHECK ) )
      DtPairAcc = НайтиПарныйСчет( DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount);
      CtPairAcc = НайтиПарныйСчет( DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount);
      /*Оба счета не парные*/
      if( (DtPairAcc == "") AND (CtPairAcc == "") ) 
         /*Проставить статус STATE_EXECUTE для дальнейшей обработки в "ВыполнитьПроводки"*/
         DocOffTMPState.State = STATE_EXECUTE;
         Update( DocOffTMPState, null, true );
      else

        /*Проверяем, возможно по проводке запрещено использовать парные счета*/
        if( GetAccount( DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount, AccountPayer) AND 
            GetAccount( DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount, AccountReceiver) 
          ) 
           if( НеИспользоватьПарныеСчета(AccountPayer, AccountReceiver) == true )
             /*Проставить статус STATE_EXECUTE для дальнейшей обработки в "ВыполнитьПроводки"*/
             DocOffTMPState.State = STATE_EXECUTE;
             Update( DocOffTMPState, null, true );
             continue; 
           end;
         end; 
         IdentCarry[CARRY_CURRENT] = DocOffTMPState;

         if( DtPairAcc != "" ) /*Счет дебета парный*/
            /*Ищем проводку с таким же Кт и парным Дт*/
            IdentCarry[CARRY_PAIR_DT] = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                                           DocOffTMPState.DtFIID,
                                                           DtPairAcc, 
                                                           DocOffTMPState.CtFIID, 
                                                           DocOffTMPState.CtAccount,
                                                           DocOffTMPState.GroundKind );
         end;

         if( CtPairAcc != "" ) /*Счет кредита парный*/
            /*Ищем проводку с таким же Дт и парным Кт*/
            IdentCarry[CARRY_PAIR_CT] = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                                           DocOffTMPState.DtFIID,
                                                           DocOffTMPState.DtAccount, 
                                                           DocOffTMPState.CtFIID,  
                                                           CtPairAcc,
                                                           DocOffTMPState.GroundKind );
         end;                                              

         if( (DtPairAcc != "") AND (CtPairAcc != "") ) /*Оба счета парные*/
            /*Ищем проводку с таким же парным Дт и парным Кт*/
            IdentCarry[CARRY_PAIR_DTCT] = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                                           DocOffTMPState.DtFIID,
                                                           DtPairAcc, 
                                                           DocOffTMPState.CtFIID,  
                                                             CtPairAcc,
                                                             DocOffTMPState.GroundKind );
         end;

         /*Теперь в массиве IdentCarry имеем от 1 до 4-х записей идентичных по счетам проводок*/
         СформироватьСуммарнуюПроводку( IdentCarry );
      end;

      UseProgress( NumCarry = NumCarry + 1 );
   end;
   RemProgress();
   return 0;

   OnError( RslErrObj )
      RemProgress();
      return SayError( RslErrObj );
END;

PRIVATE MACRO СверткаПротивоположныхПарныхПроводок()
   var NumCarry = 0, DtPairAcc, CtPairAcc, DtAccount, CtAccount, BackCarry;

   InitProgress( -1, "Выполнение сводных проводок ...", "Свертка противоположных проводок по парным счетам" );

   /*Изменяем ключевую последовательность (State), поэтому всегда GetGE*/
   while( GetNextDocOffTMPState( STATE_COMPARE ) )
      DtAccount = CtAccount = "";

      DtPairAcc = НайтиПарныйСчет( DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount);
      CtPairAcc = НайтиПарныйСчет( DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount);

      if( DtPairAcc != "" ) /*Счет дебета парный*/
         /*Ищем проводку со счетом Кт == парному Дт текущей записи
           и счетом по Дт == Кт текущей записи */
         DtAccount = DocOffTMPState.CtAccount; 
         CtAccount = DtPairAcc;
      end;

      if( CtPairAcc != "" ) /*Счет кредита парный*/
         /*Ищем проводку со счетом Дт == парному Кт текущей записи
           и счетом по Кт == Дт текущей записи */
         DtAccount = CtPairAcc; 
         CtAccount = DocOffTMPState.DtAccount;
      end;                                              

      if( (DtPairAcc != "") AND (CtPairAcc != "") ) /*Оба счета парные*/
         /*Ищем проводку со счетом Дт и Кт парными соответственно 
           счетам Кт и Дт текущей записи*/
         DtAccount = CtPairAcc; 
         CtAccount = DtPairAcc;
      end;
      /*ищем проводку по той же главе, что и текущая и валютам 
        Дт == Кт текущей и Кт == Дт текущей*/
      if( (DtAccount != "") AND (CtAccount != "") )
         BackCarry = FindDocOffTMPDtCt( DocOffTMPState.Chapter, 
                                        DocOffTMPState.CtFIID, DtAccount, 
                                        DocOffTMPState.DtFIID, CtAccount, DocOffTMPState.GroundKind );
      else
         BackCarry = null;
      end;
      СформироватьРезультирующуюПроводку( DocOffTMPState ,BackCarry );
      UseProgress( NumCarry = NumCarry + 1 );
   end;

   RemProgress();
   return 0;

   OnError( RslErrObj )
      RemProgress();
      return SayError( RslErrObj );
END;

PRIVATE MACRO КорректироватьПарныеСчета( CarryDate:DATE )
   var NumCarry = 0;

   InitProgress( -1, "Выполнение сводных проводок ...", "Корректировка парных счетов" );

   /*Изменяем ключевую последовательность (State), поэтому всегда GetGE*/
   while( GetNextDocOffTMPState( STATE_CORRECTPAIR ) )

      DocOffTMPState.DtAccount = ВыбратьПарныйСчет( DocOffTMPState.Chapter, 
                                                    DocOffTMPState.DtFIID, 
                                                    DocOffTMPState.DtAccount, 
                                                    CarryDate, 
                                                    DocOffTMPState.ID );
                     
      DocOffTMPState.CtAccount = ВыбратьПарныйСчет( DocOffTMPState.Chapter, 
                                                    DocOffTMPState.CtFIID, 
                                                    DocOffTMPState.CtAccount, 
                                                    CarryDate, 
                                                    DocOffTMPState.ID );

      DocOffTMPState.State = STATE_EXECUTE; 
      UpdateDocOffTMPByID( DocOffTMPState );
      UseProgress( NumCarry = NumCarry + 1 );
   end;

   RemProgress();
   return 0;

   OnError( RslErrObj )
      RemProgress();
      return SayError( RslErrObj );
END;

PRIVATE MACRO ВыполнитьПроводки( FD:SPFirstDocDLCOMM, Doc:VARIANT, DateCarry:DATE )
   var continue_cicle, Error = 0, NumCarry = 0, Ground = "";

   InitProgress( -1, "Выполнение сводных проводок по сделкам ...", "Выполнение сводных проводок" );
   ClearRecord( DocOffTMPState );
   DocOffTMPState.State = STATE_EXECUTE;
   continue_cicle = GetGE( DocOffTMPState );
   while( continue_cicle AND (DocOffTMPState.State == STATE_EXECUTE) )
        if( GetAccount( DocOffTMPState.Chapter, DocOffTMPState.DtFIID, DocOffTMPState.DtAccount, AccountPayer) AND 
            GetAccount( DocOffTMPState.Chapter, DocOffTMPState.CtFIID, DocOffTMPState.CtAccount, AccountReceiver) 
          ) 
           if( (ПолучитьПараметрыСводнойПроводки( AccountPayer, AccountReceiver, DocOffTMPState.GroundKind, null, null, Ground ) == false) OR
               (Ground == "") 
             )
              Ground = "Сводная проводка на ОРЦБ";
           end;
           if(not ПроводкаПоКатегориямУчета( FD, 
                  AccountPayer, AccountReceiver, /* Деб , КатегКредит*/
                  DateCarry,                     /* Дата */
                  DocOffTMPState.Chapter,        /* Глава */
                  DocOffTMPState.DtFIID,         /* Валюта */
                  DocOffTMPState.DtSumma,        /* Сумма */
                  Doc,                           /* Документ */
                  INPCARRY,                      /* Result_Carry */
                  " 1",                          /* Kind_Oper */
                  "",                            /* Numb_Document */
                  Ground,                        /* Ground */
                  null,null,null,
                  DocOffTMPState.DtFIID, DocOffTMPState.CtFIID,
                  DocOffTMPState.CtFIID, DocOffTMPState.CtSumma,
                  null, true
                 ))
               Error = 1;
           end;
        end;
        if( Error == 0 )
           continue_cicle = Next( DocOffTMPState );
        else
           continue_cicle = false;
        end;
        UseProgress( NumCarry = NumCarry + 1 );
   end;
   RemProgress();
   return Error;
END;

/* Проверяем, что в биржевых сделках есть невыполненные шаги, запланированные
   на дату. Если такие шаги есть, то возвращаем true.
      MarketID       - биржа
      MarketOfficeID - сектор биржи
      ChDate         - дата */
private macro ЕстьНевыполненныеЗапланирШаги( MarketID, MarketSchemeID, ChDate )

      var
         deal     = TBFile( "dl_tick", "R", 4 ),
         oprstep  = TBFile( "oprstep", "R", 11 ),
         oper     = TRecHandler( "oproper" ),
         continueStep;

      deal.Clear();
      deal.AddFilter("(t_BOfficeKind = " + string(DL_SECURITYDOC)
               + "  or t_BOfficeKind = " + string(DL_RETIREMENT) + ")"
               + " and t_DealStatus  = " + string(DL_READIED) 
               + " and t_DealDate   <= " + GetSQLDate(ChDate) 
               + " and t_MarketID    = " + string(MarketID) 
               + " and t_MarketSchemeID = " + string(MarketSchemeID) );

      deal.Rewind;

      while( deal.Next )
         /* Закрытые и отложенные сделки не проверяем, т.к. в закрытых
            сделках все шаги выполнены, а в отложенных шагов еще нет.

            Не проверем сделки у которых дата заключения больше даты проверки,
            т.к. шагов на дату проверки у таких сделок не будет. */
         if(   IsEXCHANGE(GetOpGroup(deal.rec))
               and ПолучитьОперациюПоСделке(deal, oper) )

            /* Проверяем шаги. */
            oprstep.Clear();
            oprstep.AddFilter(" t_ID_Operation = " + string(oper.rec.ID_Operation)
                        + " and t_IsExecute   != 'X' " 
                        + " and t_Plan_date   = " + GetSQLDate(ChDate) ); 

            oprstep.Rewind;

            while( oprstep.Next )
                  /* Нашли невыполненный шаг, запланированный на дату. */
               oprstep.DropFilter();
               deal.DropFilter();
               return true;
            end;
            oprstep.DropFilter();
         end;
                        
      end;
      deal.DropFilter();

      return false;
end;

MACRO ВыполнитьСводныеПроводки( FD:SPFirstDocDLCOMM, Doc:VARIANT, PartyID:INTEGER, DateCarry:DATE )
   var errcode, errtext, TmpFName = GetWorkFileName("docoff");
   var continue_cicle, Error = 0;

   GetRegistryValue( REG_PAIRACCMODE, V_INTEGER, PairAccModeValue, errcode );
   if( errcode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + REG_PAIRACCMODE + "\"");
      return 1;
   end;

   /* Проверим, что все запланированные шаги по сделкам выполнены. Если не
      так, то предложим пользователю прервать выполение (#53910). */

   Message( "Проверка сделок..." );
   if( ЕстьНевыполненныеЗапланирШаги(PartyID, FD.GetMarketSchemeID(), DateCarry) )
      if( not GetTrue(  false,
                  "Не во всех сделках на бирже \""
                  + GetPartyByID(PartyID).ShortName + "\" со схемой расчета "
                  + string(FD.GetMarketSchemeID()) + "|выполнены "
                  + "запланированные на " + String(DateCarry) + " шаги.|"
                  + "Продолжить выполнение операции?" ) )
         return 1; /* Пользователь прервал выполнение. */
      end;
   end;

   ClearGlobalTmp( "ddocoff_tmp" );

   /* В spdocoff хранится код ведущей биржи (см. запрос #64477). */
   PartyID = GetLeaderMarketID( PartyID, DateCarry );

   /*Заполнение временного файла */
   spdocoff.Clear();

   spdocoff.AddFilter(" t_PartyID    = " + string(PartyID)
                + " and t_MarketSchemeID   = " + string(FD.GetMarketSchemeID())
                + " and t_State      = " + string(SPDOCOFF_STATE_PREPARED)
                + " and t_Date_Carry = " + GetSQLDate(DateCarry)
                + " and t_Chapter not in (21,22)"); 

   spdocoff.Rewind;

   continue_cicle = spdocoff.Next;
   while( continue_cicle )
      if( spdocoff.rec.Chapter != 5 ) /*Не ДЕПО*/
         Error = AddInDocOffTMP();
      end; 
      if( Error == 0 )   
         continue_cicle = spdocoff.Next();
      else
         continue_cicle = false;
      end;
   end;
   spdocoff.DropFilter();

   /*Получим название временной базы*/
   NameFile = FileName(DocOffTMPState);
   NameFile = "d"+NameFile;
   NameFile = StrSubst ( NameFile, ".", "_" );

   if( Error == 0 )
      Error = СверткаИдентичныхПарныхПроводок();
   end;
   if( Error == 0 )
      Error = СверткаПротивоположныхПарныхПроводок();
   end;
   if( Error == 0 )
      Error = КорректироватьПарныеСчета( DateCarry );
   end;
   if( Error == 0 )
      Error = ВыполнитьПроводки( FD, Doc, DateCarry );
   end;

   return Error;
END;
