/* SecurLimitLocksService.mac
*/
import oralib, rsberror, "SqlResultConvertHelper.mac", "cblogger2.mac";

class SecurLimitLockSourceTypes()
    const SECUR_REDEMPTION = "secur.redemption";
end;

class SecurLimitLockStruct()
    var id:integer;
    var sourceType:string;
    var sourceId:integer;
    var fiId:integer;
    var marketId:integer;
    var contractId:integer;
    var quantity:money;
    var startDate:date;
    var endDate:date;

    macro ToString()
        return String("SecurLimitLock{id:", id, 
                    ", sourceType:", sourceType,
                    ", sourceId:", sourceId,
                    ", fiId:", fiId,
                    ", marketId:", marketId,
                    ", contractId:", contractId,
                    ", quantity:", quantity,
                    ", startDate:", startDate,
                    ", endDate:", endDate,
                    "}");
    end;
end;

class SecurLimitLocksService()
    private var sqlConverter = SqlResultConvertHelper();
    private var logger:c_logger = LoggerFactory().NewItLog("SecurLimitLocksService").GetLogger();

    //находит первую попавшуюся строку
    macro FindByParameters(
        sourceType:string,
        sourceId:integer,
        fiId:integer,
        marketId:integer,
        contractId:integer,
        startDate:date
    ):SecurLimitLockStruct
        var query =
          "select * "
        + "  from secur_limit_locks l "
        + " where source_type = :1 "
        + "   and source_id = :2 "
        + "   and (fiid = :3 or :4 is null) "
        + "   and (market_id = :5 or :6 is null) "
        + "   and (contract_id = :7 or :8 is null) "
        + "   and nvl(:9, start_date) = start_date "
        + " order by market_id nulls last, "
        + "          contract_id nulls last";

        var sql = ExecSqlSelectWithParams(query,
            sourceType,
            sourceId,
            fiId, fiId,
            marketId, marketId,
            contractId, contractId,
            startDate
        );
        if (sql.MoveNext())
            var lock =  SecurLimitLockStruct();
            lock.id = sql.value("lock_id");
            lock.sourceType = sql.value("source_type");
            lock.sourceId = sql.value("source_id");
            lock.fiId = sql.value("fiid");
            lock.marketId = sqlConverter.orNull(sql.value("market_id"));
            lock.contractId = sqlConverter.orNull(sql.value("contract_id"));
            lock.quantity = sqlConverter.orNull(sql.value("quantity"));
            lock.startDate = sql.value("start_date");
            lock.endDate = sql.value("end_date");
            
            return lock;
        end;
        return null;
    OnError(err)
        var paramsStr = String(
            "sourceType=", sourceType,
            "sourceId=", sourceId,
            "fiId=", fiId,
            "marketId=", marketId,
            "contractId=", contractId,
            "startDate=", startDate);
        logger.ErrorClob("Ошибка при получении информации о блокировках лимитов. " + paramsStr, GetFullErrMsg(err));
        RsbRethrow(err, "Ошибка при получении информации о блокировках лимитов");
    end;

    macro FindBySource(sourceType:string, sourceId:integer):SecurLimitLockStruct
        return FindByParameters(sourceType, sourceId, null, null, null, null);
    end;

    macro SaveLock(lock:SecurLimitLockStruct)
        var query = 
          "begin "
        + "    limit_locks.save_secur_limit_lock ( "
        + "        p_source_type => :sourceType, "
        + "        p_source_id   => :sourceId, "
        + "        p_fiid        => :fiId, "
        + "        p_market_id   => :marketId, "
        + "        p_contract_id => :contractId, "
        + "        p_quantity    => :quantity, "
        + "        p_start_date  => :startDate, "
        + "        p_end_date    => :endDate "
        + "    ); "
        + "end; ";

        ExecSqlWithParams(query,
            lock.sourceType,
            lock.sourceId,
            lock.fiId,
            lock.marketId,
            lock.contractId,
            lock.quantity,
            lock.startDate,
            lock.endDate
        );
    OnError(err)
        logger.ErrorClob("Ошибка при создании блокировки лимитов. " + lock, GetFullErrMsg(err));
        RsbRethrow(err, "Ошибка при создании блокировки лимитов");
    end;

    macro DisableLock(lock:SecurLimitLockStruct)
        lock.endDate = lock.startDate;
        SaveLock(lock);
    end;
end;