/*
$Name:        spRepFun.mac
$Module:      Ценные бумаги
$Description: Общие функции, используемые в отчетах БОЦБ
*/
import "or_rep_h.mac";
import SecInter, "sp_class.mac", "adress.mac", "sp_categ.mac", "dldlngfun.mac", "dlreport.mac", "dldlngfun.mac", "dl_class.mac";

private var
   /* Секция var для того, чтобы запретить неявное объявление переменных. */
   _Zero;

private const AVOIRISSNKDBASE_365_Cal    = 0,  //365 в году, по календарю в месяце
              AVOIRISSNKDBASE_360_30     = 1,  //360 в году, 30 в месяце
              AVOIRISSNKDBASE_360_Cal    = 2,  //360 в году, по календарю в месяце
              AVOIRISSNKDBASE_365_30     = 3,  //365 в году, 30 в месяце
              AVOIRISSNKDBASE_Cal_Cal    = 4,  //по календарю и в году и в месяце
              AVOIRISSNKDBASE_Cal_30     = 5,  //по календарю в году, 30 в месяце
              AVOIRISSNKDBASE_Coup_Cal   = 6,  //дней в году по продолжительности купонных периодов, в месяце по календарю
              AVOIRISSNKDBASE_365L_Cal   = 7,  //в месяце по календарю, в году по календарю по окончанию куп. периода
              AVOIRISSNKDBASE_364_Cal    = 8,  //в месяце по календарю, в году по календарю по окончанию куп. периода
              AVOIRISSNKDBASE_360_30E    = 9,  //в месяце 30 дней, в году 360 дней (Eurobond)
              AVOIRISSNKDBASE_360_30ISDA = 10; //в месяце 30 дней, в году 360 дней (ISDA)

const TRADEPORTFNAME = "Ц/б, оцениваемые по СС через прибыль или убыток",
      SSPUPORTFNAME = TRADEPORTFNAME,
      SALEPORTFNAME = "Ц/б, оцениваемые по СС через прочий совокупный доход",
      SSSDPORTFNAME = SALEPORTFNAME,
      RETIREPORTFNAME = "Ц/б, оцениваемые по АС (амортизированной стоимости)",
      ASCBPORTFNAME = RETIREPORTFNAME,
      UNADMITEDPORTFNAME  = "Ц/б, переданные без прекращения признания",
      CONTRPORTFNAME      = "Контрольного участия",
      BACKPORTFNAME       = "Ц/б, полученные на возвратной основе",
      PROMISSPORTFNAME    = "Долговые обязательства, не погашенные в срок",
      ODCOMPORTFNAME      = "Ц/б, проданные из ПВО",/*-ОД*/
      ODREQPORTFNAME      = "Ц/б, переданные из ПВО по сделкам прямого РЕПО",/*+ОД*/
      BACKKSUPORTFNAME    = "Ц/б, полученные при внесении активов в имущественный пул",                 
      BACKBPPKSUPORTFNAME = "Ц/б, полученные при внесении активов в имущественный пул и переданные БПП";

/*
   Замечание о обработке ошибок.
   -----------------------------

   Если функция принимает два параметра - SayError и BreakProg, то в случае
   возникнования ошибки она должна вести себя следующим образом:
      - если параметр SayError = true и BreakProg = true - работа
        программы прерывается по RunError. В выходной файл выводится
        сообщение о ошибке.
      - если параметр SayError = true и BreakProg = false - работа
        программы НЕ прерывается, выводится сообщение пользователю с
        помощью MsgBox.
      - если параметры SayError и BreakProg не заданы, то функция
        не сообщает пользователю о ошибке.
*/
      
/* Функция проверки значения флага.
      FlagValue         - значение флага
      NeedTrueFlag      - возвращать true, если флаг установлен (true)
      NeedFalseFlag     - возвращать true, если флаг сброшен (false) */
macro CheckFlag( FlagValue, NeedTrueFlag, NeedFalseFlag )
   return   (FlagValue and NeedTrueFlag)
            or ((not FlagValue) and NeedFalseFlag);
end;

/* Проверяем значение переменной на совпадение с двумя значениями. */
macro CheckTwoValues( CheckValue, Value1, Value2 )
   return (CheckValue == Value1) or (CheckValue == Value2);
end;

/* Проверяем значение на вхождение в интервал. Возвращаем true, если
   значение входит в интервал.
      CheckValue  - проверяемое значение
      MinValue    - минимальное значение
      MaxValue    - максимальное значение */
macro Between( CheckValue, MinValue, MaxValue )
   return (CheckValue >= MinValue) and (CheckValue <= MaxValue);
end;

/* Исключающее ИЛИ. */
macro XOR( Value1, Value2 )
   return (Value1 and (not Value2)) or ((not Value1) and Value2);
end;

/* Сравнить две пары дата/время. */
macro CompareTwoDateTime( Date1, Time1, Date2, Time2 )

   if( Date1 < Date2 )  return -1;  end;
   if( Date1 > Date2 )  return  1;  end;
   if( Time1 < Time2 )  return -1;  end;
   if( Time1 > Time2 )  return  1;  end;

   return 0;
end;

/* Проверяем, подходит ли бумага под фильтр "Обращается/Не обращается на ОРЦБ".
   Возвращаем true, если бумага обращается на ОРЦБ и CirculateInMarket = true,
   или бумага не обращается на ОРЦБ и NotCirculateInMarket = true.
      Avr               - буфер бумаги (avoiriss.dbt)
      CircInMarket      - флаг "Обращается на ОРЦБ"
      NotCircInMarket   - флаг "Не обращается на ОРЦБ"
      _Date             - дата, на которую проверяем обращаемость на ОРЦБ */
macro CheckCircInMarket( Avr, CircInMarket, NotCircInMarket, _Date )
   return CheckFlag( FI_CircInMarket(Avr, _Date),
                     CircInMarket, NotCircInMarket );
end;

/* Возвращаем true, если ценная бумага обращается на ОРЦБ. Если не удалось
   получить ценную бумагу по коду финансового инструмента, то возвращаем
   false. */
macro IsFICircInMarket( FIID, _Date )
   var
      avoir = TBFile( "avoiriss" );

   avoir.Clear();
   avoir.rec.FIID = FIID;
   if( avoir.GetEQ() )
      return FI_CircInMarket( avoir, _Date );
   else
      return false;
   end;
end;

/* Работает аналогично CheckCircInMarket, но принимает FIID.
   Если не смогли получить бумагу по коду, то возвращаем false. */
macro CheckFICircInMark( FIID, CircInMarket, NotCircInMarket, _Date )
   return CheckFlag( IsFICircInMarket(FIID, _Date), CircInMarket, NotCircInMarket );
end;

/*** Преобразования типов ***************************************************/

   /* Преобразуем значение double в money. */
   macro DoubleToMoney( DoubleValue )
      return money(DoubleValue);
   end;

   /* Переводим значение money в double. */
   macro MoneyToDouble( MoneyValue )
      return double(MoneyValue);
   end;

   /* Переводим Bool в Int. */
   macro BoolToInt( BoolValue )
      if( BoolValue )
         return 1;
      else
         return 0;
      end;
   end;

   /* Переводим Money в Int. Отбрасываем дробную часть. */
   macro MoneyToInt( MoneyValue )
      return int( double( MoneyValue ) );
   end;

   /* Переводим Money в Int. Если значение не целое, то округляем вверх. */
   macro MoneyToIntUp( MoneyValue )
      var
         IntValDown = MoneyToInt( MoneyValue );

      if( IntValDown * $1 < MoneyValue )
         /* Была дробная часть. */
         return IntValDown + 1;
      else
         return IntValDown;
      end;
   end;
   

/*** Преобразование кода "нашего банка" *************************************/

   /* Преобразуем ClientID в PartyID */
   macro ClientID_To_PartyID( ClientID )
      return ClientID;                      
   end;

   /* Преобразуем PartyID в ClientID */
   macro PartyID_To_ClientID( PartyID )
      return PartyID;
   end;

/*** Класс TSumCollector: Коллекция сумм в различных валютах ****************/

   /* Класс для хранения суммы и валюты.
         _Sum        - сумма
         _FIID       - валюта
         _FIID_Ccy   - код ISO валюты */
   class TSumFI( _Sum, _FIID, _FIID_Ccy )
      var
         Sum      = _Sum,
         FIID     = _FIID,
         FIID_Ccy = _FIID_Ccy;
   end;

   /* Массив для хранения и накопления сумм в различных валютах.
      Элементы массива - классы TSumFI. Элементы хранятся в порядке
      возрастания FIID. Реализован как наследник от TArray.
      Дополнительные методы:
         ClearArray  - очистить массив.
         AddSum      - добавить сумму в массив. */
   class (TArray) TSumCollector

      /* Очистить массив. */
      macro ClearArray
         this.Size = 0;
      end;

      /* Добавить сумму в массив. */
      macro AddSum( Sum, FIID, FIID_Ccy )
         var
            Counter = 0, Counter2;

         /* Ищем в массиве сумму в нужной валюте. */      
         while( (Counter < this.Size) and (this.(Counter).FIID < FIID) )
            Counter = Counter + 1;
         end;

         if( (Counter < this.Size) and (this.(Counter).FIID == FIID) )
            /* Нашли подходящую запись. Добавим сумму в нее. */
            this.(Counter).Sum   = this.(Counter).Sum + Sum;
         else
            /* Запись не нашли. Нужно вставить.
               Перенесем существующие записи на одну вперед. */
            Counter2 = this.Size-1;
            while( Counter2 >= Counter )
               this.(Counter2 + 1) = this.(Counter2);
               Counter2 = Counter2 - 1;
            end;

            /* Вставим запись в освободившееся место. */
            this.(Counter) = TSumFI( Sum, FIID, FIID_Ccy );
         end;
      end;
   end; 

/*** TUniqStrCollector: Коллекция неповторяющихся строк *********************/

   /* Массив для хранения уникальных (неповторяющихся) текстовых строк.
      Реализован как наследник от TArray. Строки хранятся отсортированными
      в порядке возрастания.
      Дополнительные методы:
         AddString   - добавить строку в массив.
         ClearArray  - очистить массив.
         PrintArray  - распечатать все строки в массиве. */
   class (TArray) TUniqStrCollector

      /* Очистить массив. */
      macro ClearArray
         this.Size = 0;
      end;

      /* Добавить строку в массив. */
      macro AddString( Str )
         var
            Counter, CountDown;

         /* Используем линейный просмотр массива. Если потребуется оптимизация
            можно использовать бинарный поиск. */

         Counter = 0;
         while( (Counter < this.Size) and (Str > this.(Counter)) )
            Counter = Counter + 1;
         end;

         if(   (Counter == this.Size)
               or ((Counter < this.Size) and (Str < this.(Counter))) )
            /* Такой строки еще нет в массиве. Сдвигаем элементы вверх
               и на освободившееся место вставим новую строку. */
            CountDown = this.Size;
            while( CountDown > Counter )
               this.(CountDown) = this.(CountDown-1);
               CountDown = CountDown - 1;
            end;

            this.(Counter) = Str;
         else
            /* Строка уже есть в массиве. Ничего не делаем. */
         end;
      end;

      /* Распечатать все строки в массиве. */
      /* IsForExcel = true - значит, нужно предусмотреть возможность вывода в excel*/
      /* width - ширина*/
      macro PrintArray(IsForExcel, Rep, width, FontStyleTitel)
         var
            Counter = 0;

         if (IsForExcel == true)
            Rep.AddStr();
            Rep.AddEmptyStr();
            Rep.AddPrintCell("Протокол формирования отчета:", width, 0, "l:" + FontStyleTitel, REP_ELEM_STR);
            Rep.AddStr();
            Rep.AddEmptyStr();

            while( Counter < this.Size )

               Rep.AddPrintCell(this.(Counter), width, 0, "l:" + FontStyleTitel, REP_ELEM_STR);
               Rep.AddStr();

               Counter = Counter + 1;
            end;
         else
            while( Counter < this.Size )
               PrintLn( this.(Counter) );
               Counter = Counter + 1;
            end;
         end;
      end;
   end;

/*** Разные штуки для отладки ***********************************************/

   /* Задержка */
   macro SP_Sleep( Cnt )
      while( Cnt > 0 )
         Cnt = Cnt - 1;
      end;
   end;

   /* Печать отладочной информации в выходной поток. */
   macro PrintTrace( Val )
      println( "==== trace ==== : ", Val );
   end;

/****************************************************************************/

/* Печать в строку.
      Val            - печатаемое значение
      Appost         - флаг, печать чисел с апострофами
      PrintZeroNum   - флаг, печатать нулевые числа */
macro PrintToStr( Val, Appost, PrintZeroNum )
   if( Val or PrintZeroNum )
      if( Appost )
         return string(Val:a);
      else
         return string(Val);
      end;
   else
      return "";
   end;
end;

/* Печать строки текста в текстовый файл или на экран.
      PrintToFile    - флаг, печатать в файл
      OutFile        - файл для печати
      Str            - строка текста */
macro PrintLineFS( PrintToFile, OutFile, Str )
   if( PrintToFile )
      insert(OutFile, Str);
   else
      [#](Str);
   end;
end;

/* Получить код комиссии по ее типу и номеру.
   Если комисию не нашли, то возвращаем пустую строку. */
macro GetComissCode( FeeType, CommNumber )
   record  sfcomiss( sfcomiss ); 

   ClearRecord(sfcomiss);
   if( SfGetComiss(FeeType, CommNumber, sfcomiss) == true )
      return sfcomiss.Code;
   else
      return "";
   end;
end;

/*** Работа с временным файлом **********************************************/

   /* Создание и открытие временного файла. Если произошла ошибка, то
      завершаем работу по RunError
         TempFile       - файл
         TempFileName   - имя файла */
   private var errcode, errname;

   macro CreateOpenTempFile( TempFile, TempFileName )

      if( not (Create(TempFile,TempFileName) and Open(TempFile,TempFileName)) )
         errcode = status(errname);
         RunError(   "Ошибка при создании временного файла " + TempFileName
                     + " (" + errcode + ") " + errname );
      end;
   end;

   /* Вставить запись во временный файл. Если произошла ошибка, то завершаем
      работу по RunError. */
   macro InsertRecTempFile( TempFile )

      if( not Insert(TempFile) )
         errcode = status(errname);
         RunError(   "Ошибка при вставке данных во временный файл "
                     + FileName(TempFile)
                     + " (" + errcode + ") " + errname );
      end;
   end;

   /* Обновляем запись временного файла. Если произошла ошибка, то завершаем
      работу по RunError. */
   macro UpdateRecTempFile( TempFile )

      if( not Update(TempFile) )
         errcode = status(errname);
         RunError(   "Ошибка при обновлении записи временного файла "
                     + FileName(TempFile)
                     + " (" + errcode + ") " + errname );
      end;
   end;

   /* Вставить запись во временный файл. Если произошла ошибка, то завершаем
      работу по RunError. */
   macro InsertRecTempTBFile( TempFile: TBFile )

      if( not TempFile.Insert )
         errcode = status(errname);
         RunError(   "Ошибка при вставке данных во временный файл "
                     + TempFile.TblName + " (" + errcode + ") " + errname );
      end;
   end;

/**** PROGRESS BAR
      с автоматическим счетчиком. При вызове UseProgressBar счетчик
      учеличивается на 1. ****************************************************/
  
   private var
      ProgressCounter;

   macro InitProgressBar( CountRec, Mes, Head )
      ProgressCounter = 0;
      InitProgress( CountRec, Mes, Head );
   end;

   macro UseProgressBar
      ProgressCounter = ProgressCounter + 1;
      UseProgress(ProgressCounter);
   end;

   macro RemProgressBar
      RemProgress;
   end;

/*** Работа с финансовыми инструментами **********************************/

   /* Находим фин. инструмент по коду и возвращаем буфер записи.
      В случае ошибки - пустой буфер. */
   macro GetFinInstr( FIID, SayError, BreakProg )
      var
         fininstr = TRecHandler( "fininstr" );

      if( ПолучитьФинИн(FIID, fininstr) )
         fininstr.Clear();
         if( SayError )
            InformUser( "Не найден финансовый инструмент (FIID = "
                        + String(FIID) + ")", BreakProg );
         end;
      end;
   
      return fininstr.rec;
   end;

   /* Находим ценную бумагу по коду фин.инструмента и возвращаем буфер записи.
      В случае ошибки - пустой буфер. */
   macro GetAvoirRec( FIID, SayError, BreakProg )
      var
         avoiriss = TBFile( "avoiriss" );

      avoiriss.Clear();
      avoiriss.rec.FIID = FIID;
      if( not avoiriss.GetEQ() )
         avoiriss.Clear();
         if( SayError )
            InformUser( "Не найдена ценная бумага (FIID = "
                        + String(FIID) + ")", BreakProg );
         end;
      end;
   
      return avoiriss.rec;
   end;

   /* Получить код ISO финансового инструмента. В случае ошибки - пустая строка. */
   var LastFIID_Ccy = -1, LastCcy = ""; /*кешируем последнее значение*/
   macro GetFinInstrCcy( FIID, SayError, BreakProg )
      if(LastFIID_Ccy != FIID)
         LastFIID_Ccy = FIID;
         LastCcy = GetFinInstr( FIID, SayError, BreakProg ).Ccy
      end;
      return LastCcy;
   end;

   /* Получить название финансового инструмента. В случае ошибки - пустая строка. */
   macro GetFinInstrName( FIID, SayError, BreakProg )
      return GetFinInstr( FIID, SayError, BreakProg ).Name;
   end;

   /* Получить точность номинала финансового инструмента. */
   macro GetFinInstrFaceValPoint( FIRec )
      /* В базе точность хранится на 2 меньше. */
      return FIRec.Point + 2;
   end;

   /* Находим купон бумаги по номеру и возвращаем буфер записи.
      В случае ошибки - пустой буфер. */
   macro GetCouponFI( FIID, CoupNumber, SayError, BreakProg )
      var
         fiwarnt = TBFile( "fiwarnts" );

      fiwarnt.Clear();
      fiwarnt.rec.FIID     = FIID;
      fiwarnt.rec.Number   = CoupNumber;
      if( not fiwarnt.GetEQ() )
         fiwarnt.Clear();
         if( SayError )
            InformUser( "Не могу получить купон ц/б (FIID = "
                        + String(FIID) + ", Number = " + CoupNumber + ")",
                        BreakProg );
         end;
      end;
   
      return fiwarnt.rec;
   end;

   /* Получить коеффициент частичного погашения купона. Возвращаем
      double. В случае ошибки или отсутствия купона частичного погашения
      возвращаем 0.0 */
   macro GetCouponPartRate( FIID, NumberCoupon )
      var
         Rate;

      if( FI_IsCouponPartly(FIID, NumberCoupon, Rate) )
         /* Rate возвращается в процентах */
         return Rate / 100;
      else
         return 0.0;
      end;
   end;

   /* Получить максимальную дату погашения купона, но меньшую заданной
      через параметр даты. Если подходящий купон не нашли, то возвращаем
      ZeroDate. */
   macro GetCoupon_MaxDrDate( FIID, MaxDrawingDate )
      var
         fiwarnt = TBFile( "fiwarnts", "R", 2 );

      fiwarnt.Clear();
      fiwarnt.rec.IsPartial   = UNSET_CHAR;
      fiwarnt.rec.FIID        = FIID;
      fiwarnt.rec.DrawingDate = MaxDrawingDate;
      if( fiwarnt.GetLE() and
          (fiwarnt.rec.IsPartial == UNSET_CHAR) and
          (fiwarnt.rec.FIID == FIID)
        )
         return fiwarnt.rec.DrawingDate;
      else
         return ZeroDate;
      end;
   end;

   /*- максимальная из всех дат погашения купонов, дата начала периода действия которых <= MaxFirstDate даты*/
   macro GetCoupon_MaxDrDateOnFrDate( FIID, MaxFirstDate )
      var select, fiwarnt;
      select = RSDCommand("select max(t_DrawingDate) as DrawingDate from dfiwarnts_dbt " +
                          " where t_fiid = ? " +
                          "   and t_IsPartial != 'X' " +
                          "   and t_FirstDate <= ?");

      select.addParam("", RSDBP_IN, FIID);
      select.addParam("", RSDBP_IN, Date(MaxFirstDate));
      select.execute();

      fiwarnt = TRsbDataSet(select);

      if( fiwarnt.MoveNext() )
         if( fiwarnt.DrawingDate != null )
            return Date(fiwarnt.DrawingDate);
         end;
      end;

      return ZeroDate;
   end;


   /* Получить вид облигации. Если вид облигации не задан или бумага не
      найдена, то возвращаем 0. */
   macro GetBondKind( FIID )
      var
         avoiriss = TBFile( "avoiriss" );

      avoiriss.Clear();
      avoiriss.rec.FIID = FIID;
      if( avoiriss.GetEQ() )
         return ПолучитьВидОблигации( avoiriss );
      else
         return 0;
      end;
   end;

   /* Получить вид бумаги. Если не нашли, возвращаем пустой буфер. */
   macro GetAvoirKindRec( AvoirKind, SayError, BreakProg )
      var
         avrkind  = TBFile( "avrkinds.dbt" );

      avrkind.Clear();
      avrkind.rec.FI_Kind     = FIKIND_AVOIRISS;
      avrkind.rec.AvoirKind   = AvoirKind;
      if( not avrkind.GetEQ )
         avrkind.Clear();
         if( SayError )
            InformUser( "Не могу получить вид бумаги (AvoirKind = "
                        + String(AvoirKind) + ")", BreakProg );
         end;
      end;

      return avrkind.rec;
   end;

  /*DaysInYear   - дней в году*/
  /*DaysInCoupon - время жизни купона*/
macro ПолучитьПараметрыБазисаРасчетаКупона(NKDBase_Kind, fiwarnts, RepDate, DaysInYear, DaysInCoupon)

  /* более правильная функция получения кол-ва дней по базису 360\30, 
   перенес rsNDaysp_right из C*/
   var day, mon, year, FirstDate = fiwarnts.FirstDate - 1;/*Длительность купона = дата погашения купона - дата начала действия купона + 1*/

   macro Date_right(Adate)

      datesplit( Adate, day, mon, year );
      if (day == 31)
         return Adate - 1;
      else
         return Adate;
      end;
   end;
   
   /*Правила корректировки для базиса 30/360 ISDA*/
   macro Date_right_ISDA(Adate, Bdate)
      
      var Bday, Bmon, Byear;
      
      datesplit( Adate, day, mon, year );
      datesplit( Bdate, Bday, Bmon, Byear );
      if ((Bday == 31) and ((day == 30) or (day == 31)))
         return Bdate - 1;
      else
         return Bdate;
      end;
   end;

   macro ПолучитьДатуОкончанияКупонногоПериода()
         var Select, Query, endCoupDate = date(0, 0 , 0);

         Select = RSDCommand("select t_DRAWINGDATE " +
                             " from DFIWARNTS_DBT " +
                             " where t_ISPARTIAL != 'X' " +
                             " and   t_FIID = ?" +
                             " and   t_NUMBER = ?" );

         Select.addParam("FIID", RSDBP_IN, fiwarnts.FIID);
         Select.addParam("NUMBER", RSDBP_IN, fiwarnts.NUMBER);
         Select.execute();

         Query = TRsbDataSet(Select);

         if(Query.movenext())
            endCoupDate = Query.DrawingDate;
         end;
  
       return endCoupDate;
   end;

   macro ПолучитьОчереднойГод(DaysInCurrentYear)
      
      var FirstWarntPer, LastWarntPer, ListFiwarnts, continue_cicle = true, DaysInCurYear,
          FindPer = false, FirstWarntLastPer, Slct;

      macro ПролучитьНачалоПервогоКупПериода(FirstPer)
         var Select, Query;
         Select = RSDCommand("select min(t_FIRSTDATE) FirstPer " +
                             " from DFIWARNTS_DBT " +
                             " where t_ISPARTIAL != 'X' " +
                             " and   t_FIID = ?" );

         Select.addParam("FIID", RSDBP_IN, fiwarnts.FIID);
         Select.execute();

         Query = TRsbDataSet(Select);

         if(Query.movenext())
            setparm(0, Query.FirstPer);
            return true;
         end;
         setparm(0, date(0,0,0));
         return false;
      end;

      macro СписокКупонов()
         Slct = RSDCommand("select * " +
                             " from DFIWARNTS_DBT " +
                             " where t_ISPARTIAL != 'X' " +
                             " and   t_FIID = ?" );

         Slct.addParam("FIID", RSDBP_IN, fiwarnts.FIID);
         Slct.execute();

         ListFiwarnts = TRsbDataSet(Slct);
      end;

      macro КоличествоДнейВОчередномГоду(FirstPer, LastPer, Days)
         var Select, Query;
         Select = RSDCommand("select NVL( Sum( t_DRAWINGDATE - t_FIRSTDATE + 1 ), 0) DaysInYear " +
                             " from DFIWARNTS_DBT " +
                             " where t_ISPARTIAL != 'X' " +
                             " and   t_FIID = ? " +
                             " and   t_DRAWINGDATE >= " +GetSQLDate(date(FirstPer))+
                             " and   t_DRAWINGDATE <= " +GetSQLDate(date(LastPer)));

         Select.addParam("FIID", RSDBP_IN, fiwarnts.FIID);
         Select.execute();

         Query = TRsbDataSet(Select);

         if(Query.movenext())
            setparm(2, Query.DaysInYear);
            return true;
         end;
         setparm(0, date(0,0,0));
         return false;
      end;

      macro ПолучитьДатуПогашенияОблигации()
         var Select, Query;
         Select = RSDCommand("select T_DrawingDate " +
                             " from dfininstr_dbt " +
                             " where  t_FIID = ?" );

         Select.addParam("FIID", RSDBP_IN, fiwarnts.FIID);
         Select.execute();

         Query = TRsbDataSet(Select);
         if(Query.movenext())
            return Query.DrawingDate;
         end;
         return date(0,0,0);
      end;
      /*получить начало первого куп периода*/
     /*находим очередной год, на кот приходится дата расчета*/
      СписокКупонов();
      if( (ПролучитьНачалоПервогоКупПериода(FirstWarntPer )) and (ListFiwarnts.movenext()) )

         LastWarntPer = ListFiwarnts.DrawingDate;
         while( continue_cicle )
            LastWarntPer = ListFiwarnts.DrawingDate;
            if( ((Date(LastWarntPer) - Date(FirstWarntPer)) >= 359) AND ((Date(LastWarntPer) - Date(FirstWarntPer)) <= 367) )
               if( (RepDate >= FirstWarntPer) AND (RepDate <= LastWarntPer) )
                  FindPer = true;
               end;
               FirstWarntPer = IIF(FindPer, FirstWarntPer, Date(LastWarntPer) + 1);
            end;
            continue_cicle = IIF(FindPer, false, ListFiwarnts.next());
         end;

         if( not FindPer ) /*дата приходится на последний очередной год*/         
             /*находим начало последнего очередного года*/
             continue_cicle = true;
             СписокКупонов();
             if( (ПролучитьНачалоПервогоКупПериода(FirstWarntLastPer)) and (ListFiwarnts.movenext()) )
                while(continue_cicle)
                   if( ((Date(ListFiwarnts.DrawingDate) - Date(FirstWarntPer)) >= 359) AND 
                       ((Date(ListFiwarnts.DrawingDate) - Date(FirstWarntPer)) <= 367) )
                       FirstWarntLastPer = Date(ListFiwarnts.DrawingDate) + 1;
                   end;
                   continue_cicle = ListFiwarnts.next();
                end;
             end;
             /*находим дату погашения обл*/
             if(КоличествоДнейВОчередномГоду(FirstWarntLastPer, ПолучитьДатуПогашенияОблигации(), DaysInCurYear))
                setparm(0,DaysInCurYear);
                return true;
             end;
         else
             if(КоличествоДнейВОчередномГоду(FirstWarntPer, LastWarntPer, DaysInCurYear))
                setparm(0,DaysInCurYear);
                return true;
             end;
         end;
      end;
      setparm(0,0);
      return false;
   end;

   if (NKDBase_Kind == AVOIRISSNKDBASE_365_Cal)
      /*365 в году, по календарю в месяце*/
      setparm(3, 365);
      setparm(4, fiwarnts.DrawingDate - FirstDate);

   elif (NKDBase_Kind == AVOIRISSNKDBASE_360_30)
      /*360 в году, 30 в месяце*/
      setparm(3, 360);
      setparm(4, Date_right(fiwarnts.DrawingDate) - Date_right(FirstDate));

   elif (NKDBase_Kind == AVOIRISSNKDBASE_360_Cal)
      /*360 в году, по календарю в месяце*/
      setparm(3, 360);
      setparm(4, fiwarnts.DrawingDate - FirstDate);

   elif (NKDBase_Kind == AVOIRISSNKDBASE_365_30)
      /*365 в году, 30 в месяце*/
      setparm(3, 365);
      setparm(4, Date_right(fiwarnts.DrawingDate) - Date_right(FirstDate));

   elif (NKDBase_Kind == AVOIRISSNKDBASE_Cal_Cal)
      /*В году и месяце по календарю*/
      datesplit( RepDate, day, mon, year );

      setparm(3, GetDaysInYear( year ));
      setparm(4, fiwarnts.DrawingDate - FirstDate);

   elif (NKDBase_Kind == AVOIRISSNKDBASE_Cal_30)
      /*В году по календарю, 30 в месяце*/
      datesplit( RepDate, day, mon, year );

      setparm(3, GetDaysInYear( year ));
      setparm(4, Date_right(fiwarnts.DrawingDate) - Date_right(FirstDate));
   elif (NKDBase_Kind == AVOIRISSNKDBASE_Coup_Cal)
      /*дней в году по продолжительности купонных периодов, в месяце по календарю*/
      datesplit( RepDate, day, mon, year );

      ПолучитьОчереднойГод(DaysInYear);
      setparm(3, DaysInYear);
      setparm(4, fiwarnts.DrawingDate - FirstDate);

   elif (NKDBase_Kind == AVOIRISSNKDBASE_365L_Cal)
      /*в месяце по календарю, в году по календарю по окончанию куп. периода */
      var EndCouponPeriodDate = ПолучитьДатуОкончанияКупонногоПериода();
      datesplit( EndCouponPeriodDate, day, mon, year );
 
      setparm(3, GetDaysInYear( year ));
      setparm(4, fiwarnts.DrawingDate - FirstDate);
    elif (NKDBase_Kind == AVOIRISSNKDBASE_364_Cal)
      /*364 в году, по календарю в месяце*/
      setparm(3, 364);
      setparm(4, fiwarnts.DrawingDate - FirstDate);
    elif (NKDBase_Kind == AVOIRISSNKDBASE_360_30E)
      /*360 в году, 30 в месяце*/
      setparm(3, 360);
      setparm(4, Date_right(fiwarnts.DrawingDate) - Date_right(FirstDate));
    elif (NKDBase_Kind == AVOIRISSNKDBASE_360_30ISDA)
      /*360 в году, 30 в месяце (ISDA)*/
      setparm(3, 360);
      setparm(4, Date_right_ISDA(FirstDate, fiwarnts.DrawingDate) - Date_right(FirstDate));
    else 
      msgbox("Не могу получить параметры базиса расчета купона (NKDBase_Kind=" 
               + string(NKDBase_Kind) + ")");
   end;
end;

/*** Работа с субъектами ****************************************************/

   /* Получить короткое имя субъекта. В случае ошибки - пустая строка. */
   macro GetPartyShortNameByID( PartyID, SayError, BreakProg )
      return GetPartyByID( PartyID, SayError, BreakProg ).ShortName;
   end;

   /* Получить полное имя субъекта. В случае ошибки - пустая строка. */
   macro GetPartyFullNameByID( PartyID, SayError, BreakProg )
      return GetPartyByID( PartyID, SayError, BreakProg ).Name;
   end;
    const  AddressKind = 2; 
   /* Получить адрес субъекта. В случае ошибки - пустая строка.
         AddressKind -  вид адреса, по умолчанию юридический */
	
   macro GetPartyAddress( PartyID, SayError, BreakProg, AddressKind )
        AddressKind = 2;
      record RecAddress("adress.dbt");

      if( AddressKind == null )
         AddressKind = PTADDR_LEGAL;
      end;

      if( НайтиАдресСубъекта(PartyID, AddressKind, RecAddress) )
         /* Нашли адрес. */
         return RecAddress.Adress;
      else
         /* Не нашли адрес. */
         if( SayError )
            InformUser( "Не могу получить адрес субъекта (PartyID = "
                        + string(PartyID) + ", AddressKind = "
                        + string(AddressKind) + " )", BreakProg );
         end;
         return "";
      end;
   end;
   
   /* Проверяем является ли субъект резидентом. Если является - возвращаем true.
      В случае ошибки - false. */
   macro PartyIsNotResident( PartyID, SayError, BreakProg )
      return GetPartyByID( PartyID, SayError, BreakProg ).NotResident == SET_CHAR;
   end;

   /* Находим физ. лицо по коду и возвращаем буфер записи. Если произошла
      ошибка, то возвращаем пустой буфер. */
   private macro GetPersnByID( PartyID, SayError, BreakProg )
      var
         persn = TBFile( "persn" );
   
      persn.Clear();
      persn.rec.PersonID = PartyID;
      if( not persn.GetEQ )
         persn.Clear();
         if( SayError )
            InformUser( "Не могу получить данные о физ.лице (PartyID = "
                        + String(PartyID) + ")", BreakProg );
         end;
      end;
      
      return persn.rec;
   end;

   /* Получаем ФИО физ. лица. Если данные не нашли, то возвращаем пустую
      строку. */
   macro GetPersnFIOByID( PartyID, SayError, BreakProg )
      var
         persn = TRecHandler( "persn" );

      persn = GetPersnByID( PartyID, SayError, BreakProg );
      if( persn.PersonID )
         return persn.Name1 + " " + persn.Name2 + " " + persn.Name3;
      else
         return "";
      end;
   end;

   /* Проверяем является ли субъект работодателем (предпринимателем).
      Если является - возвращаем true. В случае ошибки - false. */
   macro PartyIsEmployer( PartyID, SayError, BreakProg )
      return GetPersnByID( PartyID, SayError, BreakProg ).IsEmployer == SET_CHAR;
   end;

   /* Получить истинный ИНН субъекта. */
   macro GetPartyTrueINN( PartyID )
      var
         INN = "", KPP = "";

      SplitFullINN( ПолучитьКодСубъекта(PartyID, PTCK_INN), INN, KPP );
      return INN;
   end;

   /* Получить БИК субъекта. */
   macro GetPartyBIK( PartyID )
      return ПолучитьКодСубъекта( PartyID, PTCK_BIC );
   end;

   /* Получаем регистрационный номер кредитной организации. */
   macro GetPartyRegNum( PartyID )
      return ПолучитьКодСубъекта( PartyID, PTCK_BANKREGNUM );
   end;

   /* Проверяем, что субъект является юридическим лицом. */
   macro PartyRecIsJur( PartyRec )
      return PartyRec.LegalForm == legal_form_jur
   end;

   /* Проверяем, что субъект является физическим лицом. */
   macro PartyRecIsPhis( PartyRec )
      return PartyRec.LegalForm == legal_form_phys;
   end;

   /* Получаем наименование значения категории "Организационно-
      правовые формы" у заданного субъекта. Если не нашли субъекта или
      значение категории не задано, то возвращаем пустую строку.
         PartyID        -  код субъекта
         GetShortName   -  флаг, получить короткое наименование. Если не задан,
                           то получаем длинное. */
   macro PartyGetOrgLegFormsName( PartyID, GetShortName )
      var
         party = TRecHandler( "party.dbt" ),
         CategValue;

      if( ПолучитьСубъекта(PartyID, party) )
         /* Не нашли субъекта с заданным кодом. */
         return "";
      else
         CategValue = GetCategValue(   party, PARTY_ATTR_GROUP_ORGLEGFORMS,
                                       OBJTYPE_PARTY );

         return GetNameCategValue(  OBJTYPE_PARTY, PARTY_ATTR_GROUP_ORGLEGFORMS,
                                    CategValue, GetShortName );
      end;
   end;

/*** Работа с операционистами ***********************************************/

   /* Находим операциониста по коду и возвращаем буфер записи. Если не нашли
      или ошибка - возвращаем пустой буфер. */
   macro GetOperRecByID( OperID, SayError, BreakProg )
      var
         person = TBFile( "person" );
   
      person.Clear();
      person.rec.Oper = OperID;
      if( not person.GetEQ )
         person.Clear();
         if( SayError )
            InformUser( "Не могу получить данные об операционисте (Oper = "
                        + String(OperID) + ")", BreakProg );
         end;
      end;
      
      return person.rec;
   end;

/*****************************************************************************/

/* Получить номер договора по коду. Если указанного договора не существует,
   то возвращаем пустую строку. */
macro GetContrNumberByID( ContrID )
   var
      sfcontr = TBFile( "sfcontr" );

   sfcontr.Clear();
   sfcontr.rec.Id = ContrID;
   if( sfcontr.GetEq() )
      return sfcontr.rec.Number;
   else
      return "";
   end;
end;

/* Проверяем, имеет ли клиент договор обслуживания вида "Фондовый дилинг" с
   нашим банком на дату. */
macro IsClientHaveContrStock( ClientID, ADate )
   var 
      rs,
      Query,cmd;

   Query =  "  select   count(*) as Cnt"
         +  "  from     dsfcontr_dbt"
         +  "  where    t_ServKind = " + string(PTSK_STOCKDL)
         +  "           and t_ContractorID = " + string({OurBank})
         +  "           and t_PartyID = ? "  /* string(ClientID)*/
         +  "           and t_DateBegin <= ? "  /* GetSQLDate(ADate)*/
         +  "           and ( t_DateClose = " + GetSQLDate(ZeroDate)
         +  "                 or t_DateClose >= ? "  /* GetSQLDate(ADate)*/
         +  "                 )"
		 +  "           and rownum < 2" ;

   cmd = RsdCommand ( Query );
   cmd.addParam("" , RSDBP_IN, ClientID );
   cmd.addParam("" , RSDBP_IN, ADate );
   cmd.addParam("" , RSDBP_IN, ADate );
   cmd.execute();  
   rs  = TRsbDataSet(cmd) ;
   return (rs != null) and rs.MoveNext and ( ToInt(rs.Value("Cnt")) > 0 );
end;

/* Найти страну по трехбуквенному латинскому коду и вернуть буфер записи.
   В случае ошибки - пустой буфер. */
macro SC_GetCountryByCodeLat3( CodeLat3, SayError, BreakProg )
   return DL_GetCountryByCodeLat3(CodeLat3, SayError, BreakProg);
end;

/*** Работа с датами ******************************************************/

   /* Возвращаем номер квартала, в который попадает дата.
         01.01 - 31.03     - 1-ый квартал
         01.04 - 30.06     - 2-ой
         01.07 - 30.09     - 3-ий
         01.10 - 31.12     - 4-ый */
   macro Date_GetQuarter( _Date )
      var
         year;

      DateSplit( _Date, null, null, year );

      if(   _Date < Date(01,04,year) )
         return 1;
      elif( _Date < Date(01,07,year) )
         return 2;
      elif( _Date < Date(01,10,year) )
         return 3;
      else
         return 4;
      end;
   end;

   /* Возвращаем true, если две даты находятся в одном квартале. Если
      даты в разных годах, значит в разных кварталах. */
   macro Date_InEqQuarter( _Date1, _Date2 )
      var
         year1, year2;

      DateSplit( _Date1, null, null, year1 );
      DateSplit( _Date2, null, null, year2 );

      return not (   (year1 != year2 )
                     or (Date_GetQuarter(_Date1) != Date_GetQuarter(_Date2))
                     );
   end;


   /* Получить название периода по номеру месяца и году. */
   macro PeriodName_GetByMonthYear( MonthNum, YearNum )
      if(   MonthNum == 3 )
         return "I квартал " + string(YearNum) + " года";
      elif( MonthNum == 6 )
         return "полугодие " + string(YearNum) + " года";
      elif( MonthNum == 9 )
         return "9 месяцев " + string(YearNum) + " года";
      elif( MonthNum == 12 )
         return string(YearNum) + " год";
      end;
      RunError( "Неизвестный период." );
   end;


/*** Работа со сделками и их условиями (dl_leg) *****************************/

   /* Получить тип лота, который должен быть у части сделки.
         Deal     - сделка
         LegKind  - часть сделки, необязательный параметр.
                    Если не задана, то 1-ая часть. */
   private var _Group;
   macro GetBuySaleTypeForDeal( Deal, LegKind )
      _Group = GetOpGroup( Deal );

      if( (IsBUY( _Group ) and not (LegKind == LEG_KIND_DL_TICK_BACK) and not (IsREPO( _Group ))) or 
          (IsSALE( _Group ) and (LegKind == LEG_KIND_DL_TICK_BACK)) or 
           IsAVRWRTIN( _Group ) )

         return PM_WRITEOFF_SUM_BUY;

      elif( IsBUY( _Group ) and not (LegKind == LEG_KIND_DL_TICK_BACK) and  IsREPO( _Group ) )

         return PM_WRITEOFF_SUM_BUY_BO;

      elif( (IsSALE( _Group ) and not (LegKind == LEG_KIND_DL_TICK_BACK)) or (IsBUY( _Group ) and (LegKind == LEG_KIND_DL_TICK_BACK)) or IsRET_ISSUE( _Group ) or IsAVRWRTOUT( _Group ) )

         return PM_WRITEOFF_SUM_SALE;

      elif( IsRET_COUPON( _Group ) or IsRET_PARTLY( _Group ) )

         return PM_WRITEOFF_SUM_COUPON;

      else
         return PM_WRITEOFF_SUM_UNDEF;
      end;
   end;

   /* Получить LegKind по флагу обратной части сделки. */
   macro GetLegKindByBackFlag( BackPartFlag )
      return IIF( BackPartFlag, LEG_KIND_DL_TICK_BACK, LEG_KIND_DL_TICK );
   end;

   /* Получить LegKind для части покупки сделки. */
   macro GetLegKindByDealBuy( Deal )
      return GetLegKindByBackFlag( IsSALE(GetOpGroup(Deal)) );
   end;

   /* Получить LegKind по лоту и сделке. Позволяет определить к какой части
      сделки относится лот. */
   macro GetLegKindByLotDeal( Lot, Deal )
      _Group = GetOpGroup( Deal );

      if (Deal.BOfficeKind == DL_CONVAVR) 
         if (Lot.Buy_Sale == PM_WRITEOFF_SUM_SALE)
            return LEG_KIND_DL_TICK;
         else 
            return LEG_KIND_DL_TICK_BACK;
         end;
      end;
 
      if(   (IsREPO(_Group) OR IsBackSale(_Group))
            and ( (IsBuy(_Group) AND (Lot.Buy_Sale == PM_WRITEOFF_SUM_SALE))
                  or (IsSale(_Group) AND ((Lot.Buy_Sale == PM_WRITEOFF_SUM_BUY) or (Lot.Buy_Sale == PM_WRITEOFF_SUM_BUY_BO)))
                  )
            )
         return LEG_KIND_DL_TICK_BACK;
      else
         return LEG_KIND_DL_TICK;
      end;
   end;

   private var dl_leg_file    = TBFile( "dl_leg", "R" );

   /* Получить dl_leg по DealID и LegKind.
      Если LegKind не задан, то LegKind = LEG_KIND_DL_TICK.
      Если не можем получить данные, то прекращаем работу по RunError */
   macro GetDlLegByDealID( DealID, LegKind, SayError, BreakProg, RecH )

      if( LegKind == null )
         LegKind = LEG_KIND_DL_TICK;
      end;

      dl_leg_file.Clear();
      dl_leg_file.rec.LegKind = LegKind;
      dl_leg_file.rec.DealID  = DealID;
      dl_leg_file.rec.LegID   = 0;
      if( not dl_leg_file.GetEQ() )
         dl_leg_file.Clear();
         if( SayError )
            InformUser( "Не могу получить данные сделки (DealID = "
                        + String(DealID) + ")", BreakProg );
         end;
      end;

      if( RecH )
         copy( RecH, dl_leg_file );
      end;
      return dl_leg_file.rec;
   end;

   /* Получить dl_leg по ID. В случае ошибки - пустой буфер. */
   macro GetDlLegByID( DlLegID, SayError, BreakProg )
      var
         dl_leg = TBFile( "dl_leg", "R", 1 );

      dl_leg.Clear();
      dl_leg.rec.ID = DlLegID;
      if( not dl_leg.GetEQ() ) 
         dl_leg.Clear();
         if( SayError )
            InformUser( "Не найдены условия сделки (dl_leg.ID = "
                        + string(DlLegID) + ")", BreakProg );
         end;
      end;

      return dl_leg.rec;
   end;

   /* Проверяем, является ли указанная часть сделки покупкой.
         dl_tick     -  сделка
         IsBack      -  флаг обратной части */
   macro IsBuyPartDeal( dl_tick, IsBack )
      var
         Group = GetOpGroup( dl_tick );

      return   (IsBUY(Group) and (not IsBack))
               or (IsSALE(Group) and IsBack);
   end;

   private var dl_tick_file    = TBFile( "dl_tick", "R" );

   /* Ищем сделку по ID и возвращаем файл. В случае ошибки - пустой буфер. */
   macro GetDealFileByID( DealID, SayError, BreakProg, RecH )

      dl_tick_file.Clear();
      dl_tick_file.rec.DealID = DealID;
      if( not dl_tick_file.GetEQ() )
         dl_tick_file.Clear();
         if( SayError )
            InformUser( "Не найдена сделка (DealID = " + string(DealID) + ")",
                        BreakProg );
         end;
      end;

      if( RecH )
         copy( RecH, dl_tick_file );
      end;
      return dl_tick_file;
   end;

   /* Получаем сделку по ID. В случае ошибки - пустой буфер. */
   macro GetDealByID( DealID, SayError, BreakProg, RecH )
      var DealFile = GetDealFileByID( DealID, SayError, BreakProg, RecH );
      return DealFile.rec;
   end;

   /* Функция возвращает платеж сделки. В случае ошибки - пустой буфер.
         DealID      - код первичного документа
         BOfficeKind - тип первичного документа
         Purpose     - назначение платежа
         SubPurpose  - подвид платежа */
   private var paym_file    = TBFile( "pmpaym", "R" );

   macro GetPaymentRec( DealID, BOfficeKind, Purpose, SubPurpose, SayError,
                        BreakProg, RecH )

      paym_file.Clear();
      if( FindPayment(null, Purpose, SubPurpose, BOfficeKind, DealID, true, paym_file) )
         if( SayError )
            InformUser( "Не найден платеж для сделки (DealID = "
                        + string(DealID) + ", BOfficeKind = "
                        + string(BOfficeKind) + ", Purpose = "
                        + string(Purpose) + ")", BreakProg );
         end;
      end;

      if( RecH )
         copy( RecH, paym_file.rec );
      end;
      return paym_file.rec;
   end;

   /* Функция возвращает платеж по контрактиву для сделки. Если не нашли -
      возвращаем пустой буфер.
         DealID      - код сделки
         BOfficeKind - код первичного документа
         LegKind     - часть сделки: LEG_KIND_DL_TICK - первая часть,
                       LEG_KIND_DL_TICK - обратная часть */
   macro GetDealPaymContr( DealID, BOfficeKind, LegKind, SayError, BreakProg )
      var
         paym = TRecHandler( "pmpaym.dbt" );
   
      paym = GetPaymentRec(   DealID, BOfficeKind,
                              IIF(LegKind == LEG_KIND_DL_TICK, CAi, CRi),
                              null, SayError, BreakProg );
      return paym;
   end;

   /* Функция возвращает валюту расчетов для заданной части сделки.
      Функция ищет платеж по контрактиву для сделки и берет оттуда
      код валюты платежа. Если платеж не найден, то возвращаем -1.
         DealID      - код сделки
         BOfficeKind - код первичного документа
         LegKind     - часть сделки: LEG_KIND_DL_TICK - первая часть,
                       LEG_KIND_DL_TICK - обратная часть */
   macro GetDealPaymFIID( DealID, BOfficeKind, LegKind, SayError, BreakProg )
      var
         paym = TRecHandler( "pmpaym.dbt" );

      paym = GetDealPaymContr( DealID, BOfficeKind, LegKind, SayError, BreakProg );
      return IIF( paym.PaymentID > 0, paym.PayFIID, -1 );
   end;

   /* Возвращаем дату оплаты сделки. Фактическую или плановую, если фактической
      нет (платеж не закрыт). Если не смогли получить - возвращаем ZeroDate.
         DealID      - код сделки
         BOfficeKind - вид документа
         LegKind     - часть сделки
         OnlyFact    - флаг, указывает возвращать ZeroDate, если платеж не
                       закрыт - это позволяет получить фактическую дату оплаты */
   macro GetDealPayDate( DealID, BOfficeKind, LegKind, OnlyFact )
      var
         paym = TRecHandler( "pmpaym.dbt" );

      paym = GetDealPaymContr( DealID, BOfficeKind, LegKind );
      if( ((not OnlyFact) or ПлатежЗакрыт(paym)) and (paym.PaymentID > 0) )
         return GetDateAfterWorkDays( paym.ValueDate, 0 );
      else
         return ZeroDate;
      end;
   end;

   /* Функция возвращает фактическую дату поставки бумаг по сделке. Если
      ошибка или не смогли получить или поставка бумаг еще не поставлена, то
      возвращаем ZeroDate. */
   macro GetDealSetAvDate( DealID, BOfficeKind, LegKind )
      var
      rq = TRecHandler ("dlrq.dbt");              
      ПолучитьТОпоДокументу(BOfficeKind, DealID, IIF(LegKind == LEG_KIND_DL_TICK, 1, 2),   DLRQ_TYPE_DELIVERY,  0, rq);

      if( ТОЗакрыто(rq) and (rq.rec.ID > 0) )
         return GetDateAfterWorkDays( rq.rec.FactDate, 0 );
      else
         return ZeroDate;
      end;

   end;

   /* Функция возвращает фактическую дату поставки бумаг по сделке.
      Принимаем лот в качестве параметра. Дублируем функцию GetDealSetAvDate,
      но фактическую дату можно получать разными путями. Если фактической
      даты нет, то возвращаем ZeroDate.
         pmwrtsum    - лот покупки */
   macro GetDealSetAvDateByLot( pmwrtsum )
      if( pmwrtsum.State >= PM_WRTSUM_FORM )
         return GetDateAfterWorkDays( pmwrtsum.Date, 0 );
      else
         return ZeroDate;
      end;
   end;

   /* Функция проверяет есть ли в заданной части сделки аванс или задаток.
      В случае ошибки возвращает false.
         DealID      - код сделки
         LegKind     - часть сделки: LEG_KIND_DL_TICK - первая часть,
                       LEG_KIND_DL_TICK - обратная часть
         SubPurpose  - подвид платежа: SP_KINDAVANCE_AVANCE - аванс,
                       SP_KINDAVANCE_DEPOSIT - задаток */
   private macro IsExistAvanceDepositInDeal( DealID, LegKind, SubPurpose,
                                             SayError, BreakProg )
      var
         Purpose;

      if( LegKind == LEG_KIND_DL_TICK )
         Purpose = PM_PURP_AVANCE;
      else
         Purpose = PM_PURP_BACK_AVANCE;
      end;

      return GetPaymentRec(   DealID, DL_SECURITYDOC, Purpose, SubPurpose,
                              SayError, BreakProg
                              ).PaymentID > 0;
   end;

   /* Функция проверяет есть ли в заданной части сделки аванс.
      В случае ошибки возвращает false.
         DealID      - код сделки
         LegKind     - часть сделки */
   macro IsExistAvanceInDeal( DealID, LegKind, SayError, BreakProg )
      return IsExistAvanceDepositInDeal(
               DealID, LegKind, SP_KINDAVANCE_AVANCE, SayError, BreakProg );
   end;

   /* Функция проверяет есть ли в заданной части сделки задаток.
      В случае ошибки возвращает false.
         DealID      - код сделки
         LegKind     - часть сделки */
   macro IsExistDepositInDeal( DealID, LegKind, SayError, BreakProg )
      return IsExistAvanceDepositInDeal(
               DealID, LegKind, SP_KINDAVANCE_DEPOSIT, SayError, BreakProg );
   end;

   /* Функция возвращает массив дат изменения условий сделки в возрастающем
      порядке.
         Deal  -  тикет сделки */
   macro GetArrayDateDealChange( Deal )
      var
         sptkchng = TBFile( "sptkchng", "R", 1 ),
         Result;

      Result = TArray();

      if( Deal.ChangeDate != ZeroDate )
         /* Было изменение условий по сделке. Получим список дат. */
         sptkchng.Clear();
         sptkchng.AddFilter(
                     "t_DealID = " + string(Deal.DealID)
                     + " and t_OldChangeDate != " + GetSQLDate(ZeroDate)
                     + " and t_OldChangeKind = " + string(SPTKCHNG_CHANGE) );

         while( sptkchng.Next() )
            Result[Result.Size] = sptkchng.rec.OldChangeDate;
         end;

         if( Deal.ChangeKind == SPTKCHNG_CHANGE )
            Result[Result.Size] = Deal.ChangeDate;
         end;
      end;

      return Result;
   end;

   /* Функция возвращает массив дат изменения условий сделки в возрастающем
      порядке.
         Deal  -  тикет сделки;
         Cond  -  доп. условие. */
   macro GetArrayDateDealChangeEx( Deal, Cond )
      var
         sptkchng = TBFile( "sptkchng", "R", 1 ),
         Result;

      Result = TArray();

      if( Deal.ChangeDate != ZeroDate )
         if( Cond == null ) Cond = ""; end;

         /* Было изменение условий по сделке. Получим список дат. */
         sptkchng.Clear();
         sptkchng.AddFilter(
                     "t_DealID = " + string(Deal.DealID)
                     + Cond );

         while( sptkchng.Next() )
            Result[Result.Size] = sptkchng.rec.OldChangeDate;
         end;

         Result[Result.Size] = Deal.ChangeDate;
      end;

      return Result;
   end;

   /* Получим контрагента по сделке.
      Для биржевых сделок контрагентом является субъект, код которого указан
      в параметре "Контрагент по биржевой сделке". Если код не указан, то
      контрагентом является организатор торгов (биржа).
         Deal  -  буфер сделки */
   macro GetContrInDeal( Deal )
      var
         Group = GetOpGroup( Deal );

      if( IsEXCHANGE(Group) and (Deal.PartyID == -1) )
         /* Биржевая сделка. Поле "Контрагент в биржевой сделке" не заполнено. */
         return Deal.MarketID;
      else
         return Deal.PartyID;
      end;
   end;

/*** Работа с лотами ********************************************************/

   private var pmwrtsum_file    = TBFile( "pmwrtsum", "R" );

   /* Получить лот по параметрам. Возвращаем буфер pmwrtsum. Если запись не
      найдена - возвращаем пустой буфер.
         SumID   - параметр лота */
   macro GetLotFile( SumID, SayError, BreakProg, RecH )
      pmwrtsum_file.Clear();
      pmwrtsum_file.rec.SumID      = SumID;
      if( not pmwrtsum_file.GetEQ() )
         pmwrtsum_file.Clear();
         if( SayError )
            InformUser( "Не найден лот с параметром"
                        + " (SumID = "  + string(SumID)
                        + ")", BreakProg );
         end;
      end;
      if( RecH )
         copy( RecH, pmwrtsum_file );
      end;
      return pmwrtsum_file;
   end;

   macro GetLotRec( SumID, SayError, BreakProg, RecH )
      var WrtFile = GetLotFile( SumID, SayError, BreakProg, RecH );
      return WrtFile.rec;
   end;

   /* Получить лот по линку. Возвращаем буфер pmwrtsum. Если запись не
      найдена - пустой буфер.
         LinkRec     - буфер линка (pmwrtlnk)
         Buy_Sale    - вид лота */
   macro GetLotRecByLink( LinkRec, Buy_Sale, SayError, BreakProg, RecH )
      if( Buy_Sale == PM_WRITEOFF_SUM_BUY )
         return GetLotRec( LinkRec.BuyID, SayError, BreakProg, RecH );
      else
         return GetLotRec( LinkRec.SaleID, SayError, BreakProg, RecH );
      end;
   end;

   /* Получить лот по сделке. Возвращаем буфер pmwrtsum. Если запись не
      найдена - возвращаем пустой буфер.
         DealRec     - буфер сделки
         BuySale     - тип лота */
   macro GetLotRecByDeal( Deal, BuySale, SayError, BreakProg, RecH )
      private var pmw_file    = TBFile( "pmwrtsum", "R", 1 ), DocID, DocKind;

      if( BuySale != PM_WRITEOFF_SUM_COUPON ) 
         GetPaymentRec( Deal.DealID, Deal.BofficeKind, IIF( GetBuySaleTypeForDeal(Deal) == BuySale, BAi, BRi ), null, false, false, paym_file );
         if( paym_file.rec.PaymentID > 0)
            DocID = paym_file.rec.PaymentID;
            DocKind = DLDOC_PAYMENT;
         end;
      else/*купоны или ЧП*/
         DocID = Deal.DealID;
         DocKind = Deal.BOfficeKind;
      end;

      if( (paym_file.rec.PaymentID > 0) or (BuySale == PM_WRITEOFF_SUM_COUPON) )

         pmw_file.Clear();
         pmw_file.rec.DocKind    = DocKind;
         pmw_file.rec.DocID      = DocID;
         pmw_file.rec.Buy_Sale   = BuySale;
         pmw_file.rec.PartNum    = 0;

         if( not pmw_file.GetEQ() )
            pmw_file.Clear();
            if( SayError )
               InformUser( "Не найден лот с параметрами" +
                          " (DocID = "  + string(DocID) + ", " +
                          " DocKind = "  + string(DocKind) + ", " +
                          " Buy_Sale = "  + string(BuySale) + ", " +
                          " PartNum = 0 , " +
                          " сделки DealID = "  + string(Deal.DealID) +
                          ")", BreakProg );
            end; 
         end;

         if( RecH )
            copy( RecH, pmw_file );
         end;
         return pmw_file.rec;
      end;

      if( RecH )
         copy( RecH, pmw_file );
      end;
      return pmw_file.rec;
  end;

   /* Получить данные о первом изменении лота указанного вида начиная с
      указанной даты. Возвращаем буфер pmwrtbc. Если запись не найдем, то
      возвращаем пустой буфер.
         pmwrtsum    - лот
         Action      - вид изменения
         ADate       - дата, начиная с которой ищем изменения */
   macro GetLotChangeInfo( pmwrtsum, Action, ADate )
     var
         pmwrtbc     = TBFile( "pmwrtbc", "R", 3 ),
         pmwrtbcRec  = TRecHandler( "pmwrtbc" ),
         MinID, MinChangeDate;

      /* В один день может быть несколько изменений указанного вида. Надо
         взять первое изменение - для этого проверяем ID. */

      pmwrtbcRec.Clear();

      MinID = -1;

      pmwrtbc.Clear();
      pmwrtbc.AddFilter(   "t_DocKind = " + string(pmwrtsum.DocKind)
                           + " and t_DocID = " + string(pmwrtsum.DocID)
                           + " and t_Buy_Sale = " + string(pmwrtsum.Buy_Sale)
                           + " and t_PartNum = " + string(pmwrtsum.PartNum)
                           + " and t_Action = " + string(Action)
                           + " and t_ChangeDate >= " + GetSQLDate(ADate) );

      while(   pmwrtbc.Next()
               and ((MinID == -1) or (pmwrtbc.rec.ChangeDate == MinChangeDate))
               )

         if( MinID == -1 )
            /* Первая найденная запись. */
            MinID          = pmwrtbc.rec.ID;
            MinChangeDate  = pmwrtbc.rec.ChangeDate;
            Copy( pmwrtbcRec, pmwrtbc );
         else
            /* Это не первая найденная запись. */
            if( MinID > pmwrtbc.rec.ID )
               Copy( pmwrtbcRec, pmwrtbc );
               MinID       = pmwrtbc.rec.ID;
            end;
         end;
      end;

      return pmwrtbcRec.rec;
   end;

   /* Получить данные о первом изменении лота указанного вида начиная с
      определенного состояния лота. Возвращаем буфер pmwrtbc.
      Если запись не найдем, то возвращаем пустой буфер.
         pmwrtsum       -  лот
         Action         -  вид изменения
         StartInstance  -  состояние лота, с которого начинаем поиск */
   macro GetLotChangeAfterInst( pmwrtsum, Action, StartInstance )
     var
         pmwrtbc     = TBFile( "pmwrtbc", "R", 3 ),
         pmwrtbcRec  = TRecHandler( "pmwrtbc" ),
         MinInst     = -1;

      /* Ищем измеление лота с минимальным Instance, но большим StartInstance. */

      pmwrtbcRec.Clear();

      pmwrtbc.Clear();
      pmwrtbc.AddFilter(   "t_DocKind = " + string(pmwrtsum.DocKind)
                           + " and t_DocID = " + string(pmwrtsum.DocID)
                           + " and t_Buy_Sale = " + string(pmwrtsum.Buy_Sale)
                           + " and t_PartNum = " + string(pmwrtsum.PartNum)
                           + " and t_Action = " + string(Action)
                           + " and t_Instance > " + string(StartInstance) );

      while( pmwrtbc.Next() )

         if( (MinInst == -1) or (MinInst > pmwrtbc.rec.Instance) )
            MinInst = pmwrtbc.rec.Instance;
            Copy( pmwrtbcRec, pmwrtbc );
         end;
      end;

      return pmwrtbcRec.rec;
   end;

   /* Получить группу лота на дату (на начало дня). */
   macro GetLotGroupOnDate( pmwrtsum, ADate )
      var
         pmwrtbc = TRecHandler( "pmwrtbc" );

      if( pmwrtsum.ChangeDate < ADate )
         return pmwrtsum.GroupID;
      end;

      pmwrtbc = GetLotChangeInfo( pmwrtsum, PM_WRTSUM_UPDTMODE_CREATE, ADate );
//      return IIF( pmwrtbc.ID == 0, pmwrtsum.GroupID, pmwrtbc.OldGroupID );
      return pmwrtsum.GroupID;
   end;

   /* Получить группу лота на заданное состояние (Instance)
         pmwrtsum    -  лот
         Instance    -  состояние лота, на которое ищем группу */
   macro GetLotGroupOnInstance( pmwrtsum, Instance )
      var
         pmwrtbc = TRecHandler( "pmwrtbc" );

      pmwrtbc = GetLotChangeAfterInst( pmwrtsum, PM_WRTSUM_UPDTMODE_CREATE, Instance );
//      return IIF( pmwrtbc.ID == 0, pmwrtsum.GroupID, pmwrtbc.OldGroupID );
      return pmwrtsum.GroupID;
   end;

   /* Проверяем, что лот продан раньше указанной даты.
         pmwrtsum    -  лот
         ADate       -  дата, на которую делаем проверку */
   macro IsLotSaleBeforeDate( pmwrtsum, ADate )
      return (pmwrtsum.Amount == $0) and (pmwrtsum.ChangeDate < ADate);
   end;

/*** Неттинг ****************************************************************/

   /* Получить ID сделки неттинга по бумагам, в которой участвовал лот.
      Если лот не участвовал в операции неттинга, то возвращаем 0.
         Lot      - лот
         LegKind  - часть сделки */
   macro GetNettingDealIDByLot( Lot, LegKind )
      /* Алгоритм работы:
            - получаем платеж по бумагам
            - ищем платеж неттинга в списке платежей неттинга
            - бурем оттуда код сделки неттинга */
      var
         paym     = TRecHandler( "pmpaym.dbt" ),
         pmlink   = TBFile( "pmlink", "R", 2 );

      paym = GetPaymentRec(   Lot.DealID, DL_SECURITYDOC,
                              IIF(LegKind == LEG_KIND_DL_TICK, BAi, BRi) );

      if( paym.PaymentID > 0 )
         pmlink.Clear();
         pmlink.rec.InitialPayment  = paym.PaymentID;
         pmlink.rec.LinkKind        = PMLINK_KIND_NETTING;
         if( pmlink.GetEQ() )
            /* Нашли платеж. */
            return pmlink.rec.DocumentID;
         end;
      end;

      return 0;
   end;

   /* Получить буфер операции неттинга по коду. Если не нашли - возвращаем
      пустой буфер. */
   macro GetNettingFileByID( NettingID, SayError, BreakProg )
      var
         dl_nett  = TBFile( "dl_nett" );

      dl_nett.Clear();
      dl_nett.rec.NettingID = NettingID;
      if( not dl_nett.GetEQ() )
         dl_nett.Clear();
         if( SayError )
            InformUser( "Не найдена сделка неттинга (NettingID = "
                        + string(NettingID) + ")", BreakProg );
         end;
      end;

      return dl_nett;
   end;

   /* Получить внутренний номер итоговой сделки операции неттинга. Берем
      его из примечания. Если не нашли - возвращаем пустую строку.
         NettingRec  - сделка неттинга (TBFile) */
   macro GetNettingFinalDealCode( NettingFile )
      /* История этого примечания не хранится и, следовательно, дату указывать
         не обязательно. */
      return readNoteForObject(  OBJTYPE_NETTING,
                                 UniID(NettingFile, OBJTYPE_NETTING), 2 );
   end;

   /* Получаем финальный платеж неттинга. Если не нашли - возвращаем пустой
      буфер. */
   macro GetNettingFinalPaym( NettingID, SayError, BreakProg )
      var
         paym     = TRecHandler( "pmpaym.dbt" );

      paym = GetPaymentRec( NettingID, DL_NTGDOC, PM_PURP_NETTING );

      if( paym.PaymentID == 0 )
         if( SayError )
            InformUser( "Не найден финальный платеж неттинга (NettingID = "
                        + string(NettingID) + ")", BreakProg );
         end;
      end;

      return paym;
   end;

/*** Неглобальное перемещение ц/б *******************************************/

   /* Проверяем, что лот продажи создан операцией неглобального перемещения
      ц/б. Возвращаем true в этом случае. */
   macro IsNotGlobalTransferLotSale( pmwrtsum )
      return pmwrtsum.DealID == 0;
   end;

   /* Проверяем, что лот покупки создан операцией неглобального перемещения
      вида "Изменение цели приобретения ц/б". Возвращаем true в этом случае. */
   macro IsNotGlobalTransferLotBuy( pmwrtsum )
      /* Алгоритм проверки: проверяем, что это лот покупки и он создан
         операцией перемещения, т.к. только такое перемещение создает
         новые лоты покупки. */
      return   (pmwrtsum.Buy_Sale == PM_WRITEOFF_SUM_BUY)
               and (pmwrtsum.DocKind == DL_MOVINGDOC);
   end;

/*** Получание балансовой стоимости лота ************************************/

   /* Получить балансовую стоимость лота на начало дня. */
   macro GetLotBalanceCostOnDate( pmwrtsumFile, ADate )

      record wrtcalc(pmwrtsum);
      ClearRecord( wrtcalc );

      if( WRT_GetLotSumOnDate(pmwrtsumFile, ADate-1, wrtcalc) )
         return wrtcalc.BalanceCost;
      else
         return $0;
      end;
   end;

   /* Получить балансовую стоимость лота, НКД, к-во бумаг на начало дня. */
   macro GetLotBalaceCost_NKD_Amount_OnDate( pmwrtsumFile, ADate,
                                             BalanceCost:@money, NKD:@money,
                                             Amount:@money )
      record wrtcalc(pmwrtsum);
      ClearRecord( wrtcalc );

      if( WRT_GetLotSumOnDate(pmwrtsumFile, ADate-1, wrtcalc) )
         BalanceCost = wrtcalc.BalanceCost;
         NKD         = wrtcalc.NKDAmount;
         Amount      = wrtcalc.Amount;
      else
         BalanceCost = $0;
         NKD         = $0;
         Amount      = $0;
      end;
   end;

/*** Работа с курсами *******************************************************/

   /* Получить код торговой площадки на которой задан курс с указанными
      параметрами. В случае ошибки возвращаем -1.
      строку.
         FIIDFrom - исходная валюта
         FIIDTo   - в эту валюту конвертируем
         RateType - тип курса */
   macro GetRateMarketPlace( FIIDFrom, FIIDTo, RateType )
      record RateDef(ratedef);

      if( ПолучитьКурс(RateDef, FIIDFrom, FIIDTo, RateType) )
         InitError();
         return -1;
      else
         return RateDef.Market_Place;
      end;
   end;

   /* Получить название курса указанного типа. В случае ошибки возвращаем
      пустую строку. */
   macro GetRateTypeName( RateType )
      var
         rtype = TBFile( "ratetype" );

      rtype.Clear();
      rtype.rec.Type = RateType;
      if( rtype.GetEQ() )
         return rtype.rec.TypeName;
      else
         return "";
      end;
   end;

/****************************************************************************/

/* Получить группу списания. В случае ошибки возвращаем пустой буфер.
      PartyID  - ийди субъекта
      FI_Kind  - вид финансового инструмента
      GroupID  - ийди группы */
macro GetWrtGroupRec( PartyID, FI_Kind, GroupID, SayError, BreakProg )
   var
      pmwrtgrp = TBfile( "pmwrtgrp.dbt" );

   pmwrtgrp.Clear();
   pmwrtgrp.rec.Party   = PartyID;
   pmwrtgrp.rec.FI_Kind = FI_Kind;
   pmwrtgrp.rec.GroupID = GroupID;
   if( not pmwrtgrp.GetEQ() )
      pmwrtgrp.Clear();
      if( SayError )
         InformUser( "Не могу получить группу списания (PartyID = "
                     + string(PartyID) + ", FI_Kind = " + string(FI_Kind)
                     + ", GroupID = " + string(GroupID) + ")", BreakProg );
      end;
   end;

   return pmwrtgrp.rec;
end;

/* Получить портфель по лоту и сделке на заданную дату (на окончание дня).
   В случае ошибки возвращаем -1. */
macro ПортфельПоЛотуИСделкеНаДату(  dl_tick, pmwrtsum, ValDate,
                                    SayError, BreakProg )
/*   var
      pmwrtgrp = TRecHandler( "pmwrtgrp.dbt" ),
      GroupID;

   /* Получим группу лота на начало следующиего дня, она будет равна
      группе на конец этого дня. */
   GroupID = GetLotGroupOnDate( pmwrtsum, ValDate + 1 );

   /* Получим портфель. */
   if( GroupID > 0 )
      pmwrtgrp = GetWrtGroupRec( pmwrtsum.Party, FIKIND_AVOIRISS, GroupID,
                                 SayError, BreakProg );
      if( pmwrtgrp.GroupID > 0 )
         /* Нашли запись. */
         return pmwrtgrp.Type;
      else
         return -1;
      end;
   else*/
      return dl_tick.PortfolioID;
/*   end;*/
end;

/* Получить FD по лоту */
macro GetSPFirstDocByLot( Lot )
   var
      dl_tick  = TBFile( "dl_tick", "R", 0 );

   ПолучитьСделкуПоЛоту( Lot, dl_tick, true, true );

   if( GetLegKindByLotDeal(Lot, dl_tick.rec) == LEG_KIND_DL_TICK_BACK )
      return SPFirstDoc( dl_tick, true );
   else
      return SPFirstDoc( dl_tick );
   end;
end;


/*** TDelimLinePrinter *******************************************************/

   /* Класс для храненния данных о одном разделителе. */
   class TDelimLine( _PrevLine, _NextLine, _Delimiter )
      var
         PrevLine    = _PrevLine,      /* Идентификатор строки до разделит */
         NextLine    = _NextLine,      /* Идентификатор строки после раздел */
         Delimiter   = _Delimiter;     /* Сам разделитель */
   end;

   /* Класс для печати разделителей в таблице.
      Класс позволяет печатать разделители строк в таблице.
      Какой разделитель будет напечатан определяется в зависимости от
      последней распечатанной строки (PrevLine) и следующей строки (NextLine)
      таблицы. PrevLine хранится в классе и в начале работы равен null.
      NextLine принимает функция печати. После печати разделителя PrevLine
      становится равным NextLine.
      Перед использование печати необходимо загрузить список разделителей.
      Методы:  LoadDelimiter     - загрузить данные об одном разделителе
               Print             - напечатать разделитель
               SetPrevLine       - установить идентиф. последн. расп. стр. */
   class TDelimLinePrinter

      private var
         DelimArray = TArray(),        /* Массив разделителей */
         PrevPrintedLine = null;       /* Последняя распечатанная строка */

      /* Загрузить данные о одном разделителе. */
      macro LoadDelimiter( PrevLine, NextLine, Delimiter )
         DelimArray[DelimArray.Size] = TDelimLine( PrevLine, NextLine,
                                                   Delimiter );
      end;

     /*Вернуть  разделитель*/ 
     macro GetDelimStr(NextLine)
        var
           ArrSize  = DelimArray.Size,
           Counter  = 0,
           Delim    = "--- неизвестный разделитель строк ---"; //Не нашли нужный разделитель        

        /* Ищем первый подходящий разделитель. */
        while(   (Counter < ArrSize)
                 and ( (DelimArray[Counter].PrevLine != PrevPrintedLine)
                       or (DelimArray[Counter].NextLine != NextLine) ) )
           Counter = Counter + 1;
        end;

        if( Counter < ArrSize )
           /* Нашли нужный разделитель */
           Delim = DelimArray[Counter].Delimiter;            
        end;

        PrevPrintedLine = NextLine;
        return Delim;
     end;

      /* Печать разделителя. */
      macro Print( NextLine )
         var
            ArrSize  = DelimArray.Size,
            Counter  = 0;

         /* Ищем первый подходящий разделитель. */
         while(   (Counter < ArrSize)
                  and ( (DelimArray[Counter].PrevLine != PrevPrintedLine)
                        or (DelimArray[Counter].NextLine != NextLine) ) )
            Counter = Counter + 1;
         end;

         if( Counter < ArrSize )
            /* Нашли нужный разделитель */
            PrintLn( DelimArray[Counter].Delimiter );
         else
            /* Не нашли нужный разделитель */
            PrintLn( "--- неизвестный разделитель строк ---" );
         end;

         PrevPrintedLine = NextLine;
      end;

      /* Установить идентификатор последней распечатанной строки */
      macro SetPrevLine( PrevLine )
         PrevPrintedLine = PrevLine;
      end;
   end;

/****************************************************************************/

/* Получить экземпляр операции по коду. Возвращаем буфер записи.
   Если ошибка - возвращаем пустой буфер. */
macro GetOprOperByID( ID_Operation, SayError, BreakProg )
   var
      oproper  = TBFile( "oproper" );

   oproper.Clear;
   oproper.rec.ID_Operation = ID_Operation;
   if( not oproper.GetEQ() )
      oproper.Clear;
      if( SayError )
         InformUser( "Не могу получить экземпляр операции (ID_Operation = "
                     + string(ID_Operation) + ")" );
      end;
   end;

   return oproper.rec;
end;

/* Определяем лицевой счет, на котором учитывается лот покупки на дату (на
   начало дня). Возвращаем буфер счета. Если не смогли определить счет, то
   пустой буфер. Статус лота на дату должен быть "поставлен" или "готов".
   Проверку на то, что лот продан на дату не делаем - т.е. определим
   номер л/счета на котором учитывается лот даже если лот уже продан.
      pmwrtsum    - лот покупки
      ADate       - дата
      FDBuy       - необязательный параметр, перв. документ операции
                    покупки лота. Если не задан, то будет создан
                    в процедуре. Если он есть, то лучше задавать -
                    процедура будет работать быстрее. */
macro ЛСчетНаКоторомУчитываетсяЛот( pmwrtsum, ADate, FDBuy, Is315 )
   /* Функция реализована при работе над запросом #56205. Полностью
      алгоритм расписан в ноте к этому запросу. */

   /* Получить последнее изменение группы списания лота операцией
      перемещения, проишедшее до даты ADate. */
   macro GetLastLotGroupChange( pmwrtsum, ADate )
      var
         select, v;

      select = RSDCommand(" SELECT T.t_ID_Operation " +
                          "   FROM (select hist.* " +
                          "           from v_scwrthist hist " +
                          "          where hist.t_sumid = ? ) T " +
                          "  WHERE T.t_instance = (select max(v.t_instance) " +
                          "                          from v_scwrthist v " +
                          "                         where v.t_sumid = T.t_sumid " +
                          "                           and v.t_changedate <= ? " +
                          "                           and v.t_action = ? " +
                          "                           and v.t_state = ?)");

      select.addParam("sumid", RSDBP_IN, pmwrtsum.SumID);
      select.addParam("changedate", RSDBP_IN, ADate);
      select.addParam("action", RSDBP_IN, PM_WRTSUM_UPDTMODE_GLOBALTRANSF);
      select.addParam("state", RSDBP_IN, PM_WRTSUM_FORM);
      select.execute();
      v = TRsbDataSet(select);

   return IIF(v.movenext(), v.ID_Operation, -1);
   end;

   /* Получить буфер сделки покупки. */
   macro GetDealBuy( FDBuy, pmwrtsum )
      if( FDBuy != null )
         return FDBuy.tick.rec;
      else
         return GetDealByID( pmwrtsum.DealID, true );
      end;
   end;

   /* Получить первичный документ операции покупки. */
   macro GetFD( FDBuy, pmwrtsum, DealBuy )
      if( FDBuy != null )
         return FDBuy;
      else
         return SPFirstDoc(GetLegKindByLotDeal(pmwrtsum, DealBuy), pmwrtsum.DealID);
      end;
   end;

   /* Получить реальный первичный документ по лоту*/
   macro GetRealFD( pmwrtsum )
      var cmd = DL_RSDCommand("select t_DocID from ddlrq_dbt where t_ID = ?");
      cmd.AddParam(pmwrtsum.DocID);

      var DataSet = cmd.Execute(); 
      if(DataSet.moveNext())
        return SPFirstDoc( GetLegKindByLotDeal(pmwrtsum, GetDealByID( int(DataSet.DocID), true )), int(DataSet.DocID) );
      end;
         
      return NULL;
   end;

   /* Получаем FD операции перемещения по DocumentID.
      Если не можем получить, то возвращаем null.
         DocumentID  - ID документа
         FIID        - ID ценной бумаги */
   macro GetFDTransfer( DocumentID, FIID )
      var FD = SPFirstDocFI_Transfer( DL_MOVINGDOC, DocumentID );

      if( FD != null )
         /* Сохраняем валюту номинала бумаги в параметрах первичного документа,
            иначе не будет работать опеределение счета для валютных ценных
            бумаг (#57010) */
         FD.SetParametr(MC_TYPE_PARAMETR_CURRENCY, GetFinInstr(FIID).FaceValueFI);
      end;

      return FD;
   end;

   /* Получить счет в запись acnt. */
   macro GetAcc( FD, Portf, Role, Acc, ADate, pmwrtsum)
     return FD.IsExistAccount( Portf, null, true, Role, Acc, null, ADate );
   end;

   var
      DealBuy        = TRecHandler( "dl_tick" ),
      GroupChangeRec,
      OprOperRec     = TRecHandler( "oproper" ),
      Acc            = TRecHandler( "account" ),
      FD             = null,
      FindAccount, select, vscwrthist, PaymOverdue, Categ, Role;

   Acc.Clear;

   if( ADate < pmwrtsum.EnterDate )        
      return Acc.rec;
   end;

      select = RSDCommand("select hist.t_Portfolio, hist.t_State, hist.t_Amount, hist.t_AmountBD, hist.t_Buy_Sale "+
                          "from v_scwrthistex hist "+
                          "where hist.t_sumid = ? "+
                          " and  hist.t_instance = (select max (t_instance) "+
                          "                       from  v_scwrthist "+
                          "                       where t_sumid = hist.t_sumid "+
                          "                       and t_changedate <= ?)");
   
      select.addParam("sumid", RSDBP_IN, pmwrtsum.SumID);
      select.addParam("changedate", RSDBP_IN, ADate);
      select.execute();
   
      vscwrthist = TRsbDataSet(select);
   
   if( vscwrthist.movenext() )
       /*Если портфель - ТП ППР ПУДП и статус поставлен БПП то счет Ц/б БПП, 
         актуализовать по сделке*/
      if( ((vscwrthist.Portfolio == KINDPORT_TRADE) or
           (vscwrthist.Portfolio == KINDPORT_SALE) or
           (vscwrthist.Portfolio == KINDPORT_RETIRE)) 
           and (vscwrthist.State == PM_WRTSUM_SALE_BPP )
          )
         if(vscwrthist.Portfolio == KINDPORT_TRADE)
            Role = FIROLE_BA_SSPU_BPP;
         elif(vscwrthist.Portfolio == KINDPORT_SALE)
            Role = FIROLE_BA_SSSD_BPP;
         elif(vscwrthist.Portfolio == KINDPORT_RETIRE)
            Role = FIROLE_BA_ASCB_BPP;
         end;
         FD = GetRealFD(pmwrtsum);
         FD.SetCurPFI(pmwrtsum.FIID);

         if(ВедениеСчетовБПППоВыпуску() == true)
           GetAcc( FD, "Наш портфель ц/б", Role, Acc, ADate );
         else
         GetAcc( FD, IIF(IsBasket(FD.Group), "Ц/б, Корзина БПП", "Ц/б, БПП"), Role, Acc, ADate );
         end;

         return Acc.rec;
      elif( (vscwrthist.Portfolio == KINDPORT_CONTR) and (vscwrthist.State == PM_WRTSUM_SALE_BPP ) )
         Role = FIROLE_BA_CONTR_BPP;
         FD = GetRealFD(pmwrtsum);
         FD.SetCurPFI(pmwrtsum.FIID);

         if(ВедениеСчетовБПППоВыпуску() == true)
           GetAcc( FD, "Наш портфель ПКУ, ц/б", Role, Acc, ADate );
         else
         GetAcc(FD, IIF(IsBasket(FD.Group), "Ц/б, Корзина ПКУ БПП", "Ц/б, ПКУ БПП"), Role, Acc, ADate);
         end;
         return Acc.rec;
      /*Если лот ПВО и есть остаток - то остаток лежит на счете Ц/б ПВО*/
      elif( (vscwrthist.Portfolio == KINDPORT_BACK) 
           and (vscwrthist.State == PM_WRTSUM_FORM )
          )
           DealBuy = GetDealBuy( FDBuy, pmwrtsum );
           FD = GetFD( FDBuy, pmwrtsum, DealBuy );
           FD.SetCurPFI(pmwrtsum.FIID);

           if(IsAVRWRTIN(GetOperationGroup(DealBuy.DealType)))
              GetAcc( FD, "Наш портфель ц/б", GetFIRoleByPortfolio(vscwrthist.Portfolio), Acc, ADate );
           else
            if (ValType(Is315)!=V_UNDEF)
              GetAcc( FD, "-ОД", FIROLE_BA_BACK, Acc, ADate );
              /*счет мог открыться и по FIROLE_BA*/
              if( Acc.rec.Account == "" )
                 GetAcc( FD, "-ОД", FIROLE_BA, Acc, ADate );
              end;
            else
              GetAcc( FD, IIF(IsBasket(FD.Group), "Ц/б, Корзина ПВО", "Ц/б, ПВО"), FIROLE_BA_BACK, Acc, ADate );
              /*счет мог открыться и по FIROLE_BA*/
              if( Acc.rec.Account == "" )
                 GetAcc( FD, IIF(IsBasket(FD.Group), "Ц/б, Корзина ПВО", "Ц/б, ПВО"), FIROLE_BA, Acc, ADate );
              end;

            end;

           end;
           return Acc.rec;
      elif( ((vscwrthist.Portfolio == KINDPORT_TRADE) or
           (vscwrthist.Portfolio == KINDPORT_SALE) or
           (vscwrthist.Portfolio == KINDPORT_RETIRE) or
           (vscwrthist.Portfolio == KINDPORT_CONTR) or
           (vscwrthist.Portfolio == KINDPORT_PROMISSORY))
            and (vscwrthist.State == PM_WRTSUM_FORM)
          )
           GroupChangeRec = GetLastLotGroupChange( pmwrtsum, ADate );
           if( (GroupChangeRec != -1) and (ValType(GroupChangeRec) != V_UNDEF) )
           /*Попробуем получить операцию перемещения, а потом документ. */
              OprOperRec = GetOprOperByID( GroupChangeRec, true );

          /* Получим первичный документ перемещения. */
              FD = GetFDTransfer( int(OprOperRec.DocumentID), pmwrtsum.FIID );
              FD.SetCurPFI(pmwrtsum.FIID);
              if( FD != null )
                  GetAcc( FD, IIF(((vscwrthist.Portfolio == KINDPORT_CONTR) and (ADate >= date(1,11,2014))), "Наш портфель ПКУ, ц/б", "Наш портфель ц/б"), FIROLE_DSTA, Acc, ADate );
              else
                  MsgBox( "Не могу получить операцию перемещения (DocumentID = ", int(OprOperRec.DocumentID), ")" );
                  return Acc.rec;
              end;
           else
              /*DealBuy = GetDealBuy( FDBuy, pmwrtsum );
              FD = GetFD( FDBuy, pmwrtsum, DealBuy );
              if( FD != null )
                 FD.SetCurPFI(pmwrtsum.FIID);
                 GetAcc( FD, IIF(((vscwrthist.Portfolio == KINDPORT_CONTR) and (ADate >= date(1,11,2014))), "Наш портфель ПКУ, ц/б", "Наш портфель ц/б"), GetFIRoleByPortfolio(vscwrthist.Portfolio), Acc, ADate );
              end;*/

              if(Acc.rec.Account == "")
                var FDfin = SPFirstDocFI(DLDOC_ISSUE, pmwrtsum.FIID, pmwrtsum.FIID, vscwrthist.Portfolio, {OurBank}, null, null, null);
                if( FDfin != null )

                  if  ((IIF(((vscwrthist.Portfolio == KINDPORT_CONTR) and (ADate >= date(1,11,2014))), "Наш портфель ПКУ, ц/б", "Наш портфель ц/б") == "Наш портфель ц/б") and  (FI_IsShare(pmwrtsum.FIID)))
                    if (УЧЕТ_ВАЛЮТНЫХ_ДОЛЕВЫХ_ЦБ() == 0)                                            //Учет в национальной валюте  
                      FDfin.SetParametr(MC_TYPE_PARAMETR_CURRENCY, natcur);
                    end;
                  end;

                  GetAcc( FDfin, IIF(((vscwrthist.Portfolio == KINDPORT_CONTR) and (ADate >= date(1,11,2014))), "Наш портфель ПКУ, ц/б", "Наш портфель ц/б"), GetFIRoleByPortfolio(vscwrthist.Portfolio), Acc, ADate, pmwrtsum );
                end;
              end;
           end;
      elif( (vscwrthist.Portfolio == KINDPORT_BASICDEBT) 
          and (vscwrthist.State == PM_WRTSUM_NOTFORM)
          and (vscwrthist.Amount > 0 )
        ) 
           
           FD = GetRealFD(pmwrtsum);
           FD.SetCurPFI(pmwrtsum.FIID);
           if( FD != null )
             Categ = IIF(IsBasket(FD.Group), "Ц/б, ПВО_БПП, Корзина", "Ц/б, ПВО_БПП");

             GetAcc( FD, Categ, null, Acc, ADate );
           end;

           return Acc.rec;
      elif((vscwrthist.Portfolio == KINDPORT_BACK_BPP_KSU) and (vscwrthist.Amount > 0 ) )
           FDBuy.SetCurPFI(pmwrtsum.FIID);

           Categ = IIF(IsBasket(FDBuy.Group), "+ОД, Корзина", "+ОД");

           GetAcc( FDBuy, Categ, null, Acc, ADate );

           return Acc.rec;
      elif( (vscwrthist.Buy_Sale == PM_WRITEOFF_SUM_SALE) 
           and (vscwrthist.State == PM_WRTSUM_NOTFORM )
           and (vscwrthist.AmountBD > 0)
          )

           FDBuy.SetCurPFI(pmwrtsum.FIID);

           PaymOverdue = ( (FDBuy.pm_avoir.rec.PaymStatus == PM_OVERDUE) OR
                           (FDBuy.pm_avoir.rec.PaymStatus == PM_PROLONGATED)
                         );

            if( PaymOverdue )
               Categ = IIF(IsBasket(FDBuy.Group), "Обяз. с н.с., корзина", "Обяз. с н.с.");
            else
               Categ = IIF(IsBasket(FDBuy.Group), "-ОД, Корзина", "-ОД");
            end;

           GetAcc( FDBuy, Categ, null, Acc, ADate );

           return Acc.rec;
      elif((vscwrthist.Portfolio == KINDPORT_BACK_KSU) and (vscwrthist.Amount > 0 ))
        DealBuy = GetDealBuy( FDBuy, pmwrtsum );
        FD = GetFD( FDBuy, pmwrtsum, DealBuy );
        FD.SetCurPFI(pmwrtsum.FIID);
        
        if(IsDealKSU(FD.Group))
          Categ = "Ц/б, ПВО";
        else
          Categ = "Полученные КСУ";
        end;

        GetAcc( FDBuy, Categ, null, Acc, ADate );

        return Acc.rec;
      end;
    end;

   return Acc.rec;

   /* Проектировщик:
      Еще один момент
      ...Условно для лотов, зачисленных операциями зачисления, брать
      счет ц/б договор если зачисление в займ/обр продажу (п. 1),
      или наш портфель по базовому активу, как для обычной сделки.
      Для зачислений ... вручную должны быть актуализированы счета по
      категориям и выполнены проводки. 
      Разработка:
      Отдельные проверки не нужны. */
end;

/* Получаем значение настройки "Отображать изменение условий сделок в
   отчетах". Если произошла ошибка, то вовзращаем false. */
macro GetOption_ShowDealChange( )
   var
      ErrCode, OptionValue;

   GetRegistryValue( "SECUR\\SHOW_DEAL_CHANGE_IN_REPS", V_BOOL,
                     OptionValue, ErrCode );

   return OptionValue and (ErrCode == 0);
end;


/* Функция возвращает наименование операции для сделок контрагента Д.
   Функция ПолучитьВидОперации не подходит, т.к. сделка контрагента Д 
     имеет обратную направленность. 
   Group -  группа операции 
   IsBack - флаг, вторая часть сделки
   ShowPart - флаг, будет указана часть сделки */
macro ПолучитьВидСделкиКонтрагентаД( Group, IsBack, ShowPart )
   var
      BuySale = "",
      OperKind = "";

   if(IsBuy(Group))
      BuySale ="продажа ц/б";
   elif(IsSale(Group))
      BuySale ="покупка ц/б";
   end;

   if( IsREPO(Group) )
      OperKind = IIF( IsBuy(Group), "прямое РЕПО", "обратное РЕПО" );
   elif(IsBACKSALE(Group))
     if(IsBuy(Group))
       OperKind = BuySale + " c ОВ";
     else
       OperKind = BuySale + " c ОП";
     end;
   else
     OperKind = BuySale;
   end;

   if(ShowPart AND (IsBackSale(Group) OR IsREPO(Group)))
     if(IsBack == false)
       OperKind = OperKind + " 1 ч.";
     else
       OperKind = OperKind + " 2 ч.";
     end;
   end;

   return OperKind;
end;

/* Преобразование числа в строку с указанной точностью.
      Number      - значение числа
      Point       - к-во знаков после запятой
      FormatSpec  - спецификаторы форматирования
      NoZeroFlag  - если флаг задан, то для чисел равных нулю возвращаем
                    пустую строку. */
macro NumPrec( Number, Point, FormatSpec, NoZeroFlag )
   if( NoZeroFlag and ((Number == 0) or (Number == 0.0)) )
      return "";
   else
      return ЧислоCЗаданнойТочностью( Number, Point, FormatSpec );
   end;
end;

/*получить значения счетов, валют, сумм из платежа для сохранения данных об операции*/
/* в зависимости от того какого рода учет денежных средств выполняется              */
/* IsOur    - собственные или клиентские средства  */
/* in_out   - списание\зачисление средств          */
MACRO GetPaymAccountAndFIID( paym, in_out, account1:@string, fiid1:@integer, amount1:@money, account2:@string, fiid2:@integer, amount2:@money )

   if( in_out == 0 )  /*Зачисление*/
      account1  = paym.ReceiverAccount;
      fiid1     = paym.PayFIID;
      amount1   = paym.PayAmount;
      account2  = paym.PayerAccount;
      fiid2     = paym.FIID;
      amount2   = paym.Amount;
   else               /*Списание*/
      account1  = paym.PayerAccount;
      fiid1     = paym.FIID;
      amount1   = paym.Amount;
      account2  = paym.ReceiverAccount;
      fiid2     = paym.PayFIID;
      amount2   = paym.PayAmount;
   end;

END;

/* Возвращает строку 's'
   до символа 'c' 
   Например: s="abcdefg.xyz",c='.'
   Результат   "abcdefg" */
macro SP_StrBefore( s, c )
   var p=Index(s, c);
   return IIF(p==0,s,SubStr(s,1,p-1));
end;

/* Делает из строки вида "Иванов Иван Иваныч" строку "Иванов И.И." */
macro CutFullName( str )
  var l = strlen(str),
      i = 0,
      res = "";

  res = SP_StrBefore( str, " ") + " "; /*Это будет фамилия*/

  while ( i < l )
    if ( (SubStr(str,i,1) == " ") and (i+1<l) )
      if(SubStr(str,i+1,1) != " ")  /*Проверим, так как ФИО может разделятся не одним пробелом*/
        res = res + SubStr(str,i+1,1) + ".";
      end;
    end;
    i = i + 1;
  end;

  return res;
end;

PRIVATE VAR v24 = NULL;      
macro GetCoupRetData(FIID, Number_Coupon, Amount, CoupSum:@Money, Maturity:@Date)
  var sql, cmd, ds, ErrCode;

  if( v24 == NULL )
    GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V24", V_INTEGER, v24, ErrCode );
    if( ErrCode != 0 )
      v24 = 0; // по-умолчанию
    end;
  end;
  if( v24 == 0 ) 
    sql = "select (rq.t_Amount/leg.t_Principal*"+Amount+") NKD, "+
                " rq.t_PlanDate Maturity "+
          " from ddl_tick_dbt tick, ddl_leg_dbt leg, ddlrq_dbt rq "+
          " where tick.t_BofficeKind = "+DL_RETIREMENT+
            " and tick.t_PFI = ? "+
            " and tick.t_Number_Coupon = ? "+
            " and rsb_secur.IsRet_Partly(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(tick.t_DealType, tick.t_BofficeKind))) = 0 "+
            " and leg.t_DealID = tick.t_DealID "+
            " and leg.t_LegKind = "+LEG_KIND_DL_TICK+
            " and leg.t_LegID = 0 "+
            " and rq.t_DocKind = tick.t_BofficeKind "+
            " and rq.t_DocID = tick.t_DealID "+
            " and rq.t_DealPart = 1 "+
            " and rq.t_Type = "+DLRQ_TYPE_PAYMENT;
  else
 // sql = "select (rq.t_Amount/leg.t_Principal*"+Amount+") NKD, "+
    sql = "select (leg.t_NKD/leg.t_Principal*"+Amount+") NKD, "+        //GAA: UPD 67
              " NVL(rq.t_FactDate, rq.t_PlanDate) Maturity "+
         " from ddl_tick_dbt tick, ddl_leg_dbt leg, ddlrq_dbt rq "+
        " where tick.t_BofficeKind = "+DL_RETIREMENT+
          " and tick.t_PFI = ? "+
          " and tick.t_Number_Coupon = ? "+
          " and rsb_secur.IsRet_Partly(rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(tick.t_DealType, tick.t_BofficeKind))) = 0 "+
          " and leg.t_DealID = tick.t_DealID "+
          " and leg.t_LegKind = "+LEG_KIND_DL_TICK+
          " and leg.t_LegID = 0 "+
          " and rq.t_DocKind = tick.t_BofficeKind "+
          " and rq.t_DocID = tick.t_DealID "+
          " and rq.t_DealPart = 1 "+
          " and rq.t_Type = "+DLRQ_TYPE_PAYMENT;
  end;
  cmd = RSDCommand(sql);
  cmd.NullConversion = true;
  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, Number_Coupon );
  cmd.execute();

  ds = TRsbDataSet(cmd);
  if(ds.MoveNext())
    CoupSum = SQL_ConvTypeSum(ds.NKD);
    Maturity = SQL_ConvTypeDate(ds.Maturity);
    return true;
  end;
  return false;

  // на перспективу - быстрее работает, но нужен пакет RSB_ARNU 
  // var cmd1 = RSDCommand("BEGIN RSB_ARNU.GetCoupRetData(?, ?, ?, ?, ?); END;");
  // cmd1.addParam( "", RSDBP_IN, FIID );
  // cmd1.addParam( "", RSDBP_IN, Number_Coupon );
  // cmd1.addParam( "", RSDBP_IN, Amount );
  // cmd1.addParam( "Summ",3);// RSDBP_IN_OUT );
  // cmd1.addParam( "Mat", 3);//RSDBP_IN_OUT );
  // cmd1.Value("Summ") = CoupSum;
  // cmd1.Value("Mat") = Maturity;
  // cmd1.execute();
  // CoupSum = cmd1.Value("Summ");
  // Maturity = cmd1.Value("Mat");
end;

MACRO SP_GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, IsPartial:STRING, ToFIID:INTEGER, CouponCount:@INTEGER, ExcludeDate, CalcByDates, IsClosed:bool, CoupRetData:bool )
  var cmd, rsd;
  var Sum = 0.0, S, NumCoupon = 0;
  var DrawingDate,
      Maturity; //дата получения средств

  if( IsClosed == null )
     IsClosed = false;             
  end;

  cmd = RSDCommand(
        " SELECT FI.t_FaceValueFI, FI.t_FaceValue, warnt.t_DrawingDate as DrawingDate, "
      + "        warnt.t_IncomeRate, warnt.t_IncomeScale, warnt.t_Number "
      + "   FROM dfiwarnts_dbt warnt, dfininstr_dbt FI "
      + "  WHERE warnt.t_FIID = ? and "
      + "        warnt.t_IsPartial = " + IIF(IsPartial=="X","chr(88)", "chr(0)") + " and "
      + "        warnt.t_DrawingDate <= ? and "
      + "        warnt.t_DrawingDate >= ? and "
      + IIF (((ExcludeDate != null) and (ValType(ExcludeDate) == V_DATE) and (ExcludeDate != date(0, 0, 0))), 
             "   warnt.t_DrawingDate != ? and ",
             ""
            )
      + IIF (IsClosed, 
             IIF(CheckTaxDepositoryMode() == false, " warnt.t_SpIsClosed = 'X' and ", " warnt.t_IsClosed = 'X' and "),
             ""
            )
      + "        FI.t_FIID = warnt.t_FIID "
      + " ORDER BY warnt.t_DrawingDate ASC "
                  );

  cmd.addParam( "", RSDBP_IN, FIID );
  cmd.addParam( "", RSDBP_IN, DateEnd );
  cmd.addParam( "", RSDBP_IN, DateBeg );

  if((ExcludeDate != null) and (ValType(ExcludeDate) == V_DATE) and (ExcludeDate != date(0, 0, 0)))
     cmd.addParam( "", RSDBP_IN, ExcludeDate );
  end;

  cmd.execute();

  rsd = TRsbDataSet(cmd);
  while(rsd.MoveNext())
    DrawingDate = SQL_ConvTypeDate(rsd.DrawingDate);
    S = $0;
    Maturity = DrawingDate;

    if(CoupRetData)
      GetCoupRetData(FIID, rsd.Number, Amount, @S, @Maturity);
    end;

    /*Сумма частичных погашений*/
    if (IsPartial == "X")
       S = Amount * rsd.FaceValue * rsd.IncomeRate/MAX( 1, rsd.IncomeScale)/100.0;
    /*Сумма купонов*/
    else
      if(S == 0)
        S = СуммаКупона(FIID, Amount, DrawingDate );
      end;
    end;

    if( ToFIID != NULL )
      SmartConvertSumDbl( S, S, Maturity, int(rsd.FaceValueFI), ToFIID, true );
    end;

    /*Такие специфические суммы используются например в регистрах 9.1 и 9.2*/
    if (CalcByDates != NULL)
      S = S * (DateBeg - DrawingDate);
    end;

    Sum = Sum + S;
    NumCoupon = NumCoupon + 1;
  end;

  CouponCount = NumCoupon;
  return Sum;
END;

macro GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, CouponCount:@INTEGER, ExcludeDate, CalcByDates, IsClosed:bool, CoupRetData:bool )
  return SP_GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, "", null, @CouponCount, ExcludeDate, CalcByDates, IsClosed, CoupRetData );
end;

MACRO GetCouponSumByPeriod_Rub( FIID, Amount, DateBeg, DateEnd, FaceValueFI, CouponCount:@INTEGER, ExcludeDate, CalcByDates, IsClosed:bool, CoupRetData:bool )
  return SP_GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, "", NATCUR, @CouponCount, ExcludeDate, CalcByDates, IsClosed, CoupRetData );
END;

macro GetPartialSumByPeriod( FIID, Amount, DateBeg, DateEnd, CouponCount:@INTEGER, ExcludeDate, CalcByDates, IsClosed:bool )
  return SP_GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, "X", null, @CouponCount, ExcludeDate, CalcByDates, IsClosed );
end;

macro GetPartialSumByPeriod_Rub( FIID, Amount, DateBeg, DateEnd, CouponCount:@INTEGER, ExcludeDate, CalcByDates, IsClosed:bool )
  return SP_GetCouponSumByPeriod( FIID, Amount, DateBeg, DateEnd, "X", NATCUR, @CouponCount, ExcludeDate, CalcByDates, IsClosed );
end;

MACRO SP_GetPaymsSumByPeriod( DocKind, DocumentID, Purpose, DateBeg, DateEnd, ToFIID:INTEGER, PaymsCount:@INTEGER, CalcByDates )
  var sql, rsd;
  var Sum = 0.0, S, NumPayms = 0;

  sql = RSDCommand(" SELECT t_ValueDate, t_BaseAmount, t_BaseFIID "
      + "   FROM dpmpaym_dbt "
      + "  WHERE t_DocKind    = ? AND "
      + "        t_DocumentID = ? AND "
      + "        t_Purpose    = ? AND "
      + "        t_ValueDate BETWEEN ? AND ? "
      + " ORDER BY t_ValueDate ASC ");

  sql.addParam( "", RSDBP_IN, DocKind );
  sql.addParam( "", RSDBP_IN, DocumentID );
  sql.addParam( "", RSDBP_IN, Purpose );
  sql.addParam( "", RSDBP_IN, DateBeg );
  sql.addParam( "", RSDBP_IN, DateEnd );
  sql.execute();

  rsd = TRsbDataSet(sql);
  while(rsd.MoveNext())

    S = rsd.BaseAmount;

    if( ToFIID != NULL )
       SmartConvertSumDbl( S, S, SQL_ConvTypeDate(rsd.ValueDate), int(rsd.BaseFIID), ToFIID, true );
    end;

    /*Такие специфические суммы используются например в регистрах 9.1 и 9.2*/
    if (CalcByDates != NULL)
       S = S * (DateBeg - SQL_ConvTypeDate(rsd.ValueDate));
    end;

    Sum = Sum + S;
    NumPayms = NumPayms + 1;
  end;

  PaymsCount = NumPayms;
  return Sum;
END;

/*После выполнения 122540 эти константы можно прибить. Все соотв. проверки вынес в ХП.*/
/*Категории ЦБ*/
/* группа -- Группа налогового учета (19)*/
/* Список признаков групп налогового учета*/
/* !!!!! Это автоинкрементное значение поля t_AttrID в dobjattr_dbt */
const ГосОблФедУр_Проц    =  1, /*Государственная облигация федерального уровня - процентная*/
      ГосОблФедУр_Диск    =  2, /*Государственная облигация федерального уровня - дисконтная (ГКО)*/
      ГосОблСубфедУр_Проц =  3, /*Государственная облигация субфедерального уровня - процентная*/
      ГосОблСубфедУр_Диск =  4, /*Государственная облигация субфедерального уровня - дисконтная*/
      МунОбл15_Проц       =  5, /*Муниципальная облигация (ставка налога 15%) - процентная*/
      МунОбл15_Диск       =  6, /*Муниципальная облигация (ставка налога 15%) - дисконтная*/
      МунОбл9_Проц        =  7, /*Муниципальная облигация (ставка налога  9%) - процентная*/
      МунОбл9_Диск        =  8, /*Муниципальная облигация (ставка налога  9%) - дисконтная*/
      КорпОбл24_Проц      =  9, /*Корпоративная облигация (ставка налога 24%) - процентная*/
      КорпОбл24_Диск      = 10, /*Корпоративная облигация (ставка налога 24%) - дисконтная*/
      КорпОблИП9          = 11, /*Корпоративная облигация с ипотечным покрытием (ставка налога 9 %)*/
      Акция               = 12, /*Рублевая акция*/
      Пай_ПИФ             = 13, /*Рублевый пай ПИФа*/
      ГосОблВнутрЗайма    = 15, /*Государственная облигация внутреннего валютного займа РФ*/
      ОблВнешЗайма        = 16, /*Облигация внешнего облигационного займа РФ*/
      ПрочПроцОбл         = 17, /*Прочие процентные облигации (ноты)*/
      ПрочДискОбл         = 18, /*Прочие дисконтные облигации (ноты)*/
      ВалютнаяАкция       = 21, /*Валютная акция*/
      ДепРасп             = 19, /*Депозитарная расписка*/
      ВалютныйПай_ПИФ     = 20; /*Валютный пай ПИФа*/

/*Константы видов групп облигаций - для НУ*/
const BOND_UNDEF          = -1,  /* Неопред.*/
      BOND_FAVOUR         = 0,   /* Льготная*/
      BOND_USUAL          = 1;   /* Обычная*/

MACRO ЛьготнаяОблигация(ВидНалогОбл)
   return (ВидНалогОбл == BOND_FAVOUR);
END;

MACRO ОбычнаяОблигация(ВидНалогОбл)
   return (ВидНалогОбл == BOND_USUAL);
END;

MACRO ПроцентнаяОблигация(ВидНалогОбл)
   return(
           (ВидНалогОбл == ГосОблФедУр_Проц) or
           (ВидНалогОбл == ГосОблСубфедУр_Проц) or
           (ВидНалогОбл == МунОбл15_Проц)    or
           (ВидНалогОбл == МунОбл9_Проц)    or
           (ВидНалогОбл == КорпОбл24_Проц ) or
           (ВидНалогОбл == ПрочПроцОбл)
         );
END;

//курс требования/обязательства по ценным бумагам (курс постановки на баланс)
MACRO ПолучитьКурсПостановкиНаБаланс(Deal:OBJECT, RQID:integer)
  
  private macro ПолучитьФактическийПлатеж( DocKind, DealID, Type, DealPart )
    var sql, rsd;

    sql = RSDCommand("select dlrq.t_ID from ddlrq_dbt dlrq, ddl_leg_dbt Leg " +
                     " where dlrq.t_DocKind = ? " +
                     "   and dlrq.t_DocID = ? " +
                     "   and dlrq.t_Type = ? " + 
                     "   and dlrq.t_DealPart = ? " + 
                     "   and Leg.t_DealID = dlrq.t_DocID " +
                     "   and Leg.t_LegID = 0 " +
                     "   and Leg.t_LegKind = 0 " + //Purpose == BAi
                     "   and ( dlrq.t_State = ? AND " 
                     "         Leg.t_RejectDate = TO_DATE('01.01.0001','DD.MM.YYYY') " +
                     "       )  ");

    sql.addParam( "", RSDBP_IN, DocKind );
    sql.addParam( "", RSDBP_IN, DealID );
    sql.addParam( "", RSDBP_IN, Type );
    sql.addParam( "", RSDBP_IN, DealPart );
    sql.addParam( "", RSDBP_IN, DLRQ_STATE_EXEC );

    sql.execute();

    rsd = TRsbDataSet(sql);

    if( rsd.MoveNext() )
       return rsd.ID;
    else
       return 0;
    end;
  end;

  record payment (dlrq);
  var DLRQ_ID = 0;

  if( (RQID != NULL) and (RQID > 0) )
     DLRQ_ID = RQID;
  else
     DLRQ_ID = ПолучитьФактическийПлатеж(Deal.rec.BOfficeKind, Deal.rec.DealID, DLRQ_TYPE_DELIVERY, 1);
  end;
  clearRecord (payment);
  payment.ID = DLRQ_ID;
  return readNoteForObject(OBJTYPE_DLRQ, UniID(payment, OBJTYPE_DLRQ), 44,
                           DATE(1,1,2100));

END;

/* Параметр CrSD для налоговых отчетов
   Если по сделке Deal дата поставки была ранее, чем дата оплаты, то CrSD=официальный курс валюты цены к рублю на дату pConvDate,
   в противном случае CrSD = курс требования/обязательства по ценным бумагам (курс постановки на баланс)*/
MACRO ПолучитьКурсРеализации( Deal:OBJECT, PriceFIID:INTEGER, IsBack:BOOL, pConvDate:DATE ):DOUBLE
  private macro ПолучитьФактическийПлатеж( DocKind, DealID, Purpose )
    var Query = "select Paym.t_PaymentID from dpmpaym_dbt Paym, ddl_leg_dbt Leg " +
                " where Paym.t_DocKind = " + string( DocKind ) +
                "   and Paym.t_DocumentID = " + string( DealID ) +
                "   and Paym.t_Purpose = " + string( Purpose ) + 
                "   and Leg.t_DealID = Paym.t_DocumentID " +
                "   and Leg.t_LegID = 0 " +
                "   and Leg.t_LegKind = " + IIF(((Purpose == BRi) OR (Purpose == CRi)), "2", "0") +
                "   and (   Paym.t_IsFactPaym = chr(88) " +
                "        OR (Paym.t_IsFactPaym = CHR(0) AND " +
                "            Paym.t_PaymStatus = 150    AND " +
                "            Leg.t_RejectDate = TO_DATE('01.01.0001','DD.MM.YYYY') " +
                "           ) " +
                "       )     ";
    var m_RS;

        m_RS = TRsbDataSet( Query );
        if( m_RS.MoveNext() )
           return m_RS.PaymentID;
        else
           return 0;
        end;
  end;

   VAR ConvDate, DateBeginSettle,
       PaymAvr   = RsbPayment( ПолучитьФактическийПлатеж(Deal.rec.BOfficeKind, Deal.rec.DealID, IIF( IsBack, BRi, BAi)) ),
       PaymMoney = RsbPayment( ПолучитьФактическийПлатеж(Deal.rec.BOfficeKind, Deal.rec.DealID, IIF( IsBack, CRi, CAi)) ),
       PaymAvance, PaymCr, IsFactPaymMoney = true;
       record payment (pmpaym);

   if( (PaymAvr == null) OR (PaymAvr.ID <= 0) )
      MsgBox( "Для сделки " + Deal.rec.DealCode + " не найден платеж по ц/б." );
      return 0;
   elif( (PaymMoney == null) OR (PaymMoney.ID <= 0) )
      MsgBox( "Для сделки " + Deal.rec.DealCode + " не найден платеж по контрактиву." );
      IsFactPaymMoney = false; /*Такое возможно - см. 103792. Значит, оплата будет после поставки.*/
   end;

   if( (IsFactPaymMoney == false) OR ((ПлатежЗакрыт(PaymAvr) == true) AND (PaymAvr.ValueDate < PaymMoney.ValueDate)) )
      ConvDate = pConvDate;
   else  /*дата постановки на баланс*/
       PaymCr = RsbPayment(ПолучитьФактическийПлатеж(Deal.rec.BOfficeKind, Deal.rec.DealID, BAi) );
       clearRecord (payment);
       payment.PaymentID = PaymCr.PaymentID;
       return readNoteForObject(OBJTYPE_PAYMENT, UniID(payment, OBJTYPE_PAYMENT), 44);
/*              
       PaymAvance = RsbPayment( Deal.rec.BOfficeKind, Deal.rec.DealID, IIF( IsBack, PM_PURP_BACK_AVANCE, PM_PURP_AVANCE), SP_KINDAVANCE_AVANCE );

       if( (PaymAvance != null) AND (PaymAvance.ID != 0) )
          DateBeginSettle = PaymAvance.ValueDate;
       else
          DateBeginSettle = PaymMoney.ValueDate;
       end;
       ConvDate = minDate( DateBeginSettle, PaymAvr.ValueDate );*/
   end;
   return GetRateOnDateCrossDbl( ConvDate, PriceFIID, NATCUR, true );
END;

/*Если взведен GetLastSymbols = true: вернуть остаток строки длиной NumEndSymbols от конца;
  Если взведен GetLastSymbols = false: вернуть часть строки без последних NumEndSymbols символов от начала.
*/
MACRO GetNumbersDeal( StrNumbDeal, GetLastSymbols, NumEndSymbols:integer )
   var NumEndSymb:integer = StrLen(StrNumbDeal) - NumEndSymbols; 

   if ( GetLastSymbols == true )
      if( NumEndSymb > 0 )
         return SubStr( StrNumbDeal, NumEndSymb+1 ); 
      else
         return StrNumbDeal;
      end;
   else
      if( NumEndSymb > 0 )
         return SubStr( StrNumbDeal, 1, NumEndSymb ); 
      else
         return "";
      end;
   end;
END;

/* Сумма комиссий по сделке. Используется в регистрах НУ. */
MACRO СуммаКомиссий( DealID:INTEGER, BOfficeKind:INTEGER, CalcDate:DATE, ToFIID:INTEGER ):DOUBLE
   var cmd;
   cmd = RsdCommand(RslDefCon, "begin\n ? := Rsb_SCTX.TXGetComissionsSum(?,?,?,?);\n end; ");

   cmd.addParam("ret_val",       RSDBP_RETVAL, V_DOUBLE );
   cmd.addParam("v_DealID",      RSDBP_IN,     DealID      );
   cmd.addParam("v_BOfficeKind", RSDBP_IN,     BOfficeKind );
   cmd.addParam("v_CalcDate",    RSDBP_IN,     CalcDate    );
   cmd.addParam("v_ToFIID",      RSDBP_IN,     ToFIID      );
   cmd.execute();

   return cmd.Value(0);
END;

/*Дата заключения договора:*/
MACRO Get_RegistrDate_Query( str_Deal, str_Kind, str_Res )

   return
        " ( Select spground.t_RegistrDate " +
        "     From dspground_dbt spground, dspgrdoc_dbt spgrdoc " +
        "    Where spgrdoc.t_SourceDocKind = " + str_Deal + ".t_BofficeKind " +
        "      and spgrdoc.t_SourceDocID   = " + str_Deal + ".t_DealID " +
        "      and spground.t_SPgroundID   = spgrdoc.t_SPGroundID " + 
        "      and spground.t_Kind = " + str_Kind + 
        "      and ROWNUM = 1 " +
        " ) as " + str_Res + " ";
END;

/*Краткое наименование субъекта. */
MACRO Get_PartyShortName_Query( str_Deal, str_Res )
   return
        "        NVL( (Select p.t_ShortName " +
        "                From dparty_dbt p " +
        "               Where p.t_PartyID = " + str_Deal + ".t_PartyID " +
        "             ), CHR(1) " +
        "           ) as " + str_Res + " ";
END;

/*Полное наименование субъекта. */
MACRO Get_PartyName_Query( str_Deal, str_Res, p_str_Client )
   var str_Client = " -1 ";

   if( p_str_Client != null )
      str_Client = p_str_Client;
   end;

   return
        "        NVL( (Select p.t_Name " +
        "                From dparty_dbt p " +
        "               Where p.t_PartyID = case when " + str_Deal + ".t_IsPartyClient = 'X' and " + str_Deal + ".t_PartyID = " + str_Client + " then " + str_Deal + ".t_ClientID else " + str_Deal + ".t_PartyID end " +
        "             ), CHR(1) " +
        "           ) as " + str_Res + " ";
END;

/*категория "Группа налогового учета для НДФЛ"*/
MACRO Get_NpTxAvrGroup_Query( AttrID, str_FIID )

   if( (AttrID != null) and (AttrID > 0) )
     return
          "  npto.GetPaperTaxGroupNPTX("+str_FIID+") = "+
          "  (Select to_number(objattr.t_NumInList) " +
          "     From dobjattr_dbt objattr " +
          "    Where objattr.t_objecttype = " + OBJTYPE_AVOIRISS + 
          "      and objattr.t_groupid = " + OBJGROUP_AVRNPTXGROUP+
          "      and objattr.t_AttrID = "+AttrID +
          "  ) ";
   end;

   return "";
END;

/* Класс для хранения наименований филиалов.
      _DepID   - филиал
      _DepName - наименование */
class TAllDep( _DepID, _DepName )
   var
      DepID   = _DepID,
      DepName = _DepName;
end;

/* Массив для хранения наименований филиалов.
   Элементы массива - классы TAllDep. Реализован как наследник от TArray.
   Дополнительные методы:
      ClearArray  - очистить массив.
      Get_Dep  - получить имя. */
class (TArray) T_Dep_Collector

   /* Очистить массив. */
   macro ClearArray()
      this.Size = 0;
   end;

   /* Найти наименование данного филиала. */
   macro Get_Dep( DepID )
      var
         Counter = 0, Result = "";

      /* Ищем в массиве нужный субъект. */      
      while( (Counter < this.Size) and (this.(Counter).DepID != DepID) )
         Counter = Counter + 1;
      end;

      if( (Counter < this.Size) and (this.(Counter).DepID == DepID) )
         /* Нашли подходящую запись. Возьмем наименование из нее. */
         Result = this.(Counter).DepName;
      else
         /* Запись не нашли. Нужно вставить запись в конец массива. */
         CB_GetDepartmentCodeAndName( DepID, null, Result );

         /* Вставим запись в конец массива. */
         this.(this.Size) = TAllDep( DepID, Result );
      end;
      return Result;
   end;
end; 

/* Класс для хранения суммы и валюты.
      _FIID       - валюта
      _FIID_Ccy   - код ISO валюты */
class TAllFI( _FIID, _FIID_Ccy )
   var
      FIID     = _FIID,
      FIID_Ccy = _FIID_Ccy;
end;


/* Массив для хранения кодов валют.
   Элементы массива - классы TAllFI. Реализован как наследник от TArray.
   Дополнительные методы:
      ClearArray  - очистить массив.
      Get_ISO     - получить код. */
class (TArray) T_ISO_Collector

   /* Очистить массив. */
   macro ClearArray()
      this.Size = 0;
   end;

   /* Найти ISO данной валюты (FIID). */
   macro Get_ISO( FIID )
      var
         Counter = 0, Result;

      /* Ищем в массиве нужный FIID (валюту). */      
      while( (Counter < this.Size) and (this.(Counter).FIID != FIID) )
         Counter = Counter + 1;
      end;

      if( (Counter < this.Size) and (this.(Counter).FIID == FIID) )
         /* Нашли подходящую запись. Возьмем ISO из нее. */
         Result = this.(Counter).FIID_Ccy;
      else
         /* Запись не нашли. Нужно вставить запись в конец массива. */
         Result = ПолучитьКодФинИн(FIID, null, FICK_ISOSTRING);

         /* Вставим запись в конец массива. */
         this.(this.Size) = TAllFI( FIID, Result );
      end;
      return Result;
   end;
end; 

MACRO GetRateFromValHist(DealDate:date, Kind:integer, VRate:@double)
     var sqlSelect, sqlData;

     sqlSelect = RSDCommand("select vh1.t_Value from ddlvalhist_dbt vh1 " +
                                     "where vh1.t_Date = (select max(vh2.t_Date) from ddlvalhist_dbt vh2 " +
                                     "                    where vh2.t_Kind = vh1.t_Kind " +
                                     "                      and vh2.t_Date <= ?) " +
                                     "  and vh1.t_Kind = ?");

     sqlSelect.addParam( "", RSDBP_IN, DealDate );
     sqlSelect.addParam( "", RSDBP_IN, Kind );
     sqlSelect.execute();
     
     sqlData = TRsbDataSet( sqlSelect );

     if( sqlData.MoveNext() )
        VRate = sqlData.Value;
        return true;
     end;

     VRate = 0.0;
     return false;
END;

MACRO GetMinRateFromValHistForPeriod(Date1:date, Date2:date, Kind:integer, VRate:@double)
     var sqlSelect, sqlData, PrevValue;

     sqlSelect = RSDCommand(" select NVL(min(vh.t_Value), 0) HstValue " +
                            "   from ddlvalhist_dbt vh " +
                            "  where vh.t_Date >= ? " +
                            "    and vh.t_Date <= ? " +
                            "    and vh.t_Kind  = ? " );

     sqlSelect.addParam( "", RSDBP_IN, Date1 );
     sqlSelect.addParam( "", RSDBP_IN, Date2 );
     sqlSelect.addParam( "", RSDBP_IN, Kind );
     sqlSelect.execute();
     
     sqlData = TRsbDataSet( sqlSelect );

     if( sqlData.MoveNext() )
        VRate = sqlData.HstValue;
     else
        VRate = 0.0;
     end;

     //Найдем значение на Date1
     if( GetRateFromValHist(Date1, Kind, @PrevValue) != true )
        PrevValue = 0.0;
     end;

     if (VRate > 0.0)
        if (VRate > PrevValue)
           VRate = PrevValue;
        end;
     else
        VRate = PrevValue;
     end;

     if (VRate > 0.0)
        return true;
     else
        return false;
     end;
END;

MACRO GetCountCouponInPeriod(FIID:INTEGER, DateBeg:DATE, DateEnd:DATE, ExclDate:DATE)
  var sqlSelect, sqlData;
  var CoupCount = 0;
  
  if(ValType(ExclDate) == V_UNDEF)
    sqlSelect = RSDCommand(" select rsb_sctx.TXGetCountCoupon(?, ?, ?) as CoupCount from dual");
  
    sqlSelect.addParam( "", RSDBP_IN, FIID );
    sqlSelect.addParam( "", RSDBP_IN, DateBeg );
    sqlSelect.addParam( "", RSDBP_IN, DateEnd );
  else
    sqlSelect = RSDCommand(" select rsb_sctx.TXGetCountCoupon(?, ?, ?, ?) as CoupCount from dual");
  
    sqlSelect.addParam( "", RSDBP_IN, FIID );
    sqlSelect.addParam( "", RSDBP_IN, DateBeg );
    sqlSelect.addParam( "", RSDBP_IN, DateEnd );
    sqlSelect.addParam( "", RSDBP_IN, ExclDate );
  end;
  sqlSelect.execute();
  
  sqlData = TRsbDataSet( sqlSelect );
  if( sqlData.MoveNext() )
    CoupCount = sqlData.CoupCount;
  end;

  return CoupCount;
END;

MACRO GetMaxCouponDrawingDateInPeriod(FIID:INTEGER, DateBeg:DATE, DateEnd:DATE, ExclDate:DATE, CoupRetData:String)
  var sqlSelect, sqlData;
  var LastCoupDate = date(0,0,0);

  if(ValType(ExclDate) == V_UNDEF)
    ExclDate = ZeroDate;
  end;
  if(ValType(CoupRetData) == V_UNDEF)
    CoupRetData = UNSET_CHAR;
  end;
    
  sqlSelect = RSDCommand(" select rsb_sctx.TXGetMaxCouponDrawingDate(?, ?, ?, ?, ?) as LastCoupDate from dual");
  sqlSelect.NullConversion = true;
    
    sqlSelect.addParam( "", RSDBP_IN, FIID );
    sqlSelect.addParam( "", RSDBP_IN, DateBeg );
    sqlSelect.addParam( "", RSDBP_IN, DateEnd );
    sqlSelect.addParam( "", RSDBP_IN, ExclDate );
  sqlSelect.addParam( "", RSDBP_IN, CoupRetData );
  sqlSelect.execute();
  
  sqlData = TRsbDataSet( sqlSelect );
  if( sqlData.MoveNext() )
    LastCoupDate = SQL_ConvTypeDate(sqlData.LastCoupDate);
  end;

  return LastCoupDate;
END;

/*для дивидендов*/
MACRO GetMaxListDateInPeriod(FIID:INTEGER, DateBeg:DATE, DateEnd:DATE)
  var sqlSelect, sqlData;
  var LastListDate = date(0,0,0);

  sqlSelect = RSDCommand("SELECT NVL( MAX(t_ListDate), TO_DATE('01-01-0001', 'DD-MM-YYYY') ) LastListDate " +
                         "  FROM DFIWARNTS_DBT " +
                         " WHERE t_FIID = ? "
                         "   AND t_ListDate BETWEEN ? AND ? ");
                                                                        
  sqlSelect.addParam( "", RSDBP_IN, FIID );
  sqlSelect.addParam( "", RSDBP_IN, DateBeg );
  sqlSelect.addParam( "", RSDBP_IN, DateEnd );
  sqlSelect.execute();
  
  sqlData = TRsbDataSet( sqlSelect );

  if( sqlData.MoveNext() )
     LastListDate = SQL_ConvTypeDate( sqlData.LastListDate );
  end;

  return LastListDate;
END;

/*для дивидендов*/
MACRO GetSummOnListDateInPeriod(FIID:INTEGER, ToFIID:INTEGER, DateBeg:DATE, DateEnd:DATE)
  var sqlSelect, sqlData;
  var Summ = $0, IncomeVolume = $0;

  sqlSelect = RSDCommand("SELECT t_IncomeVolume, t_ListDate, t_incomefi " +
                         "  FROM DFIWARNTS_DBT " +
                         " WHERE t_FIID = ? "
                         "   AND t_ListDate BETWEEN ? AND ? ");
                                                                        
  sqlSelect.addParam( "", RSDBP_IN, FIID );
  sqlSelect.addParam( "", RSDBP_IN, DateBeg );
  sqlSelect.addParam( "", RSDBP_IN, DateEnd );
  sqlSelect.execute();
  
  sqlData = TRsbDataSet( sqlSelect );

  while( sqlData.MoveNext() )
     IncomeVolume = SQL_ConvTypeSum( sqlData.IncomeVolume );
     if( SmartConvertSum( IncomeVolume, IncomeVolume, SQL_ConvTypeDate(sqlData.ListDate), SQL_ConvTypeInteger(sqlData.incomefi), ToFIID, true ) == true )
        Summ = Summ + IncomeVolume;
     end;
  end;

  return Summ;
END;

PRIVATE VAR CalcWithRetPart = NULL;                                                                           
macro GetCalcWithRetPart()                                                                             
  VAR ErrCode = 0;                                                                                         
                                                                                                         
  if( CalcWithRetPart == NULL )                                                                               
     GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V12", V_INTEGER, CalcWithRetPart, ErrCode );  
     if( ErrCode != 0 )                                                                                    
        CalcWithRetPart = 1;                                                                              
     end;                                                                                                  
  end;                                                                                                     
  return (CalcWithRetPart == 0);                                                                                     
end;

MACRO GetCalcWithNDS()
  var ErrCode = 0, CalcWithNDS = 0;
  GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V13", V_INTEGER, CalcWithNDS, ErrCode);
  if(ErrCode != 0)
    CalcWithNDS = 1;
  end;
  return (CalcWithNDS == 0);
END;

MACRO SCTXNeedUsePortfolio()
  var ErrCode = 0, NeedUsePortfolio = 0;
  GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V14", V_INTEGER, NeedUsePortfolio, ErrCode);
  if(ErrCode != 0)
    NeedUsePortfolio = 1;
  end;
  return (NeedUsePortfolio == 0);
END;

// Дата выплаты купона является датой признания дохода
MACRO SC_UseDrawingDateTaxPeriods()
  var ErrCode = 0, UseDrawingDateTaxPeriods:bool = true; // по умолчанию

  GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V16", V_BOOL, UseDrawingDateTaxPeriods, ErrCode);

  if( ErrCode != 0 )
     UseDrawingDateTaxPeriods = true; // по умолчанию
  end;

  return UseDrawingDateTaxPeriods;
END;

// Списание комиссий  с учетом доли ЧП
PRIVATE VAR UseCommAsOutlay = NULL;                                                                           
MACRO SCTXUseCommAsOutlay()
  var ErrCode = 0;

  GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V17", V_BOOL, UseCommAsOutlay, ErrCode);

  if( ErrCode != 0 )
     UseCommAsOutlay = false; // по умолчанию
  end;

  return UseCommAsOutlay;
END;

MACRO SC_IncludeSecurInCalcOfReservTax()
  var ErrCode = 0, IncludeSecurInCalcOfReservTax:bool = true; // по умолчанию

  GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V18", V_BOOL, IncludeSecurInCalcOfReservTax, ErrCode);

  if( ErrCode != 0 )
     IncludeSecurInCalcOfReservTax = true; // по умолчанию
  end;

  return IncludeSecurInCalcOfReservTax;
END;

MACRO PartyKindEQByParty( PartyID:integer, PartyKind:integer )
   var Select, Pt;

   Select = RSDCommand("Select * From dpartyown_dbt Where t_PartyKind = ? and t_PartyID = ?");

   Select.addParam("", RSDBP_IN, PartyKind);
   Select.addParam("", RSDBP_IN, PartyID);
   Select.execute();

   Pt = TRsbDataSet(Select);

   if( Pt.MoveNext() )
      return true;
   end;

   return false;
END;

/* Функция возвращает наименование операции (используется в отчетах ВУ)
      FD                      -  ПД
      ShowPart                -  флаг, будет указана часть сделки
      NewRepoNaming           -  флаг, называть РЕПО/продажу прямым РЕПО,
                                 РЕПО/покупку - обратным РЕПО.
      DontShowCB              -  флаг, не указывать текст " ц/б"
      ShowCommaBeforePartNum  -  указывать запятую перед номером части
      FirstCharToUpper        -  первый символ сделать большим */
macro ПолучитьВидОперацииПоПД(FD:variant,ShowPart, NewRepoNaming,
                              DontShowCB, ShowCommaBeforePartNum,
                              FirstCharToUpper)

  var ClassName, OperKindName = "";
  var
     CBText = IIF( DontShowCB, "", " ц/б" );

  if( FD != NULL )
     ClassName = StrUpr( GenClassName( FD ));
     if( ClassName == StrUpr("DLFirstDocDL_ACC") )
        OperKindName = "расчётная операция внутреннего учёта";
        if( FirstCharToUpper )
           OperKindName = StrUpr( OperKindName, 1 );
        end;
     elif( ClassName == StrUpr("SPFirstDocDLCOMM") )
        if( FD.Comm.rec.DocKind == DL_ISSUE_UNION )
           if (FD.Comm.rec.OperSubKind == 1)
              OperKindName = "глобальная операция конвертации"+CBText;
           elif (FD.Comm.rec.OperSubKind == 2)
              OperKindName = "дробление"+CBText+" (глобальная операция)";
           elif (FD.Comm.rec.OperSubKind == 3)
              OperKindName = "консолидация"+CBText+" (глобальная операция)";
           elif (FD.Comm.rec.OperSubKind == 4)
              OperKindName = "объединение выпусков"+CBText+" (глобальная операция)";
           end;
        elif( FD.Comm.rec.DocKind == DL_CHGAVRNOM )/*изменение номинала*/
           if (FD.Comm.rec.OperSubKind == 1)
              OperKindName = "дробление";
           elif (FD.Comm.rec.OperSubKind == 2)
              OperKindName = "консолидация";
           end;
           if( OperKindName != "")
              OperKindName = OperKindName +CBText+" (операция изменения номинала)";
           end;
        end;

        if( FirstCharToUpper )
           OperKindName = StrUpr( OperKindName, 1 );
        end;
     elif( ClassName == StrUpr("SPFirstDoc") )
        return ПолучитьВидОперации(FD.Group, FD.IsBack, ShowPart, NewRepoNaming,
                                   DontShowCB, ShowCommaBeforePartNum,
                                   FirstCharToUpper);

     end;
  end;

  return OperKindName;
end;

/*!!! пока это пустышка*/
macro ПолучитьДатуПоследнейПереоценкиНВПИ(FD)
   return ZeroDate;
end;

macro DL_GetTextStatusReq( SPGroundID:integer ):string
  var RetVal:string = "";
  var Req = TRecHandler("dl_req.dbt");

  var sqlQuery = "", sqlData;

  sqlQuery = RSDCommand( " select req.* " +
                         "   from dspgrdoc_dbt grdoc, ddl_req_dbt req              " +
                         "  where grdoc.t_SPGroundID    = ?                        " +
                         "    and grdoc.t_SourceDocKind = ?                        " +
                         "    and req.t_ID              = grdoc.t_SourceDocID      "
                       );

  sqlQuery.addParam("", RSDBP_IN, SPGroundID);
  sqlQuery.addParam("", RSDBP_IN, 350/*DOCKIND_REQ_CLIENT_DEAL*/);
  sqlQuery.execute();

  sqlData = TRsbDataSet(sqlQuery);
  if( sqlData.MoveNext() )
     sqlData.GetRecord().CopyTo(Req.rec);
     RetVal = DL_GetNameAlg(ALG_DL_REQ_ORDERSTATUS, DL_GetOrderStatus(Req));
  end;

  return RetVal;
end;

macro DL_GetTextRejReq( FirstPart:bool, SPGroundID:integer, RejectDate:date ):string
  var RetVal:string = "";

  var sqlQuery = "", sqlData;

  sqlQuery = RSDCommand( " select req.t_Status                                " +
                         "   from dspgrdoc_dbt grdoc, ddl_req_dbt req         " +
                         "  where grdoc.t_SPGroundID    = ?                   " +
                         "    and grdoc.t_SourceDocKind = ?                   " +
                         "    and req.t_ID              = grdoc.t_SourceDocID "
                       );

  sqlQuery.addParam("", RSDBP_IN, SPGroundID);
  sqlQuery.addParam("", RSDBP_IN, 350/*DOCKIND_REQ_CLIENT_DEAL*/);
  sqlQuery.execute();

  sqlData = TRsbDataSet(sqlQuery);
  if( sqlData.MoveNext() )
     var ReqStatus = SQL_ConvTypeStr(sqlData.Status);
     if( (ReqStatus == REQ_REMOVED_EXCHANGE) or
         (ReqStatus == REQ_REMOVED_TRADER) or
         (ReqStatus == REQ_REJECTED_EXCHANGE) or
         (ReqStatus == REQ_REJECTED_CONTRACTOR)
       )
        RetVal = DL_GetNameAlg(ALG_DL_REQ_ORDERSTATUS, DL_REQ_ORDERSTATUS_R);
     end;
  end;

  if( (RetVal == "") and (RejectDate != ZeroDate) )
     if( FirstPart )
        RetVal = "отк. от сделки " + DateToStr(RejectDate);
     else
        RetVal = "отк. от 2ч "  + DateToStr(RejectDate);
     end;
  end;

  return RetVal;
end;

/*Получить значение настройки реестра - ОТЧЕТ ПО ВИДУ ЦБ*/
macro ВОЗМОЖНОСТЬ_ВЫБОРА_ВИДА_ЦБ()
   var ErrCode, Режим_ВОЗМОЖНОСТЬ_ВЫБОРА_ВИДА_ЦБ;

   GetRegistryValue( "SECUR\\ОТЧЕТ ПО ВИДУ ЦБ", V_BOOL, Режим_ВОЗМОЖНОСТЬ_ВЫБОРА_ВИДА_ЦБ, ErrCode );

   return Режим_ВОЗМОЖНОСТЬ_ВЫБОРА_ВИДА_ЦБ and (ErrCode == 0);
end;

macro SP_GetDocKindName(DocKind)
    return DL_GetDocKindName(DocKind); 
end;

private macro GetOperationKind( DocKind, DocID )

  var cmd, DS, IsBack:bool = false, Group:integer = 0;

  if( DocKind == DL_SECURLEG )
     cmd = DL_RSDCommand( " select leg.t_LegKind, rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(tick.t_DealType, tick.t_BofficeKind)) OpGroup " +
                          "   from ddl_tick_dbt tick, ddl_leg_dbt leg " +
                          "  where tick.t_DealID = leg.t_DealID " +
                          "    and leg.t_ID      = ? " );
     cmd.AddParam(DocID);
     DS = cmd.Execute();
     if( DS.moveNext() )
        if( DS.LegKind == LEG_KIND_DL_TICK_BACK )
           IsBack = true;
        end;
        Group = DS.OpGroup;
     end;
  else
     cmd = DL_RSDCommand( " select rsb_secur.get_OperationGroup(rsb_secur.get_OperSysTypes(tick.t_DealType, tick.t_BofficeKind)) OpGroup " +
                          "   from ddl_tick_dbt tick " +
                          "  where tick.t_DealID = ? " );
     cmd.AddParam(DocID);
     DS = cmd.Execute();
     if( DS.moveNext() )
        Group = DS.OpGroup;
     end;
  end;

  return ПолучитьВидОперации(Group, IsBack, true, true, false, false, true);
end;

MACRO SP_GetOperKindAndCodeByInAcc( DataSet, OperKind:@string, OperCode:@string, StrError:@string )
  VAR SfContr = TRecHandler( "sfcontr.dbt" );
  var FD = "";
  var cmd, DS;
  
  OperKind = "";
  OperCode = "";
  
  if( DataSet.DocKind == DL_CALCOPER )/*РОВУ*/
     FD = DLFirstDocDL_ACC( 0, DataSet.DocID );
     /*Если РОВУ привязана к сделке - вывести номер сделки*/
     if(DataSet.DealKind != DL_CALCOPER)/*это значит, что сделка БОЦБ привязана к операции (указали сделку в панели РОВУ)*/
        OperKind = ПолучитьВидОперации(GetOperationGroup(FD.dl_acc.rec.DealType), false, false, true, false, false, true);
        OperCode = DataSet.DealNumber;
     else/*это значит, что сделка БОЦБ НЕ привязана к операции (НЕ указали сделку в панели РОВУ)*/
        OperCode = FD.dl_acc.rec.Code;
     end;
  elif( DataSet.DocKind == DLDOC_SFCONCOM )
     OperKind = "Оплата периодической комиссии по договору";
     if( DL_FindSfContrByOrder( DataSet.PartyContrID, SfContr) )
        OperCode = SfContr.rec.Number;
     end;
  elif( (DataSet.DocKind == DL_WRTMONEY) or (DataSet.DocKind == DL_HOLDNDFL) )
     FD = DLFirstDocNPTXOP( DataSet.DocKind, DataSet.DocID );
    if (DataSet.DocKind == DL_HOLDNDFL)
      OperKind = "Операция удержания НДФЛ";
    elif(FD.nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_ENROL) 
       OperKind = "Зачисление денежных средств";
     elif(FD.nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_WRTOFF) 
       OperKind = "Списание денежных средств";
     elif(FD.nptxop.rec.SubKind_Operation == DL_NPTXOP_WRTKIND_TBSABC) 
       OperKind = "Перевод денежных средств";
     end;
     OperCode = FD.nptxop.rec.Code;
  elif( DataSet.DealKind == DL_SETTLEMENT )
     OperKind = "Расчеты с биржей";
     OperCode = DataSet.DealNumber;
  elif( (DataSet.DocKind == DL_DVDEAL) or (DataSet.DocKind == DL_DVNDEAL) or (DataSet.DocKind == DL_DVFXDEAL) )
    cmd = DL_RSDCommand( " Select deal.t_code DealCode, koper.t_Name KindName " +
                         "   from "+IIF(DataSet.DocKind == DL_DVDEAL,"ddvdeal_dbt", "ddvndeal_dbt")+" deal, doprkoper_dbt koper " +
                         "  where deal.t_id = ? " +
                         "    and koper.t_DocKind = ? " +
                         "    and koper.t_kind_operation = deal.t_kind " );
    cmd.AddParam(DataSet.DocID);
    cmd.AddParam(DataSet.DocKind);
    DS = cmd.Execute();
    if( DS.moveNext() )
      OperKind = DS.KindName;
      OperCode = DS.DealCode;
    end;
  elif( DataSet.DealKind == 51 ) //SFDOC_DEF_PERIOD
    OperKind = "Периодическая комиссия";  
  elif( DataSet.DealKind == 52 ) //SFDOC_DEF_ONCE
    OperKind = "Разовая комиссия";
  elif( (DataSet.DealKind == DL_VEKSELACCOUNTED) OR (DataSet.DealKind == DL_VAREPAY) OR (DataSet.DealKind == DL_VAPAWN) OR (DataSet.DealKind == DL_VAENWR) OR (DataSet.DealKind == SFCONTR_DOC) ) // Обнуляем поля для того, что будет дорабатываться позже
    OperKind = "";
    OperCode = "";                                    
  else
     if( (DataSet.DocKind == 0) and  (DataSet.DocID == 0) )/*проводки, выполненные вручную*/
        OperKind = SP_GetDocKindName( DataSet.DealKind );
        OperCode = DataSet.DealNumber;
     elif( DataSet.DealID > 0 )/*проводки по сделкам\зачислениям\списаниям\погашениям - для них будет задан DealID*/
        OperKind = GetOperationKind( DataSet.DocKind, DataSet.DocID );
        OperCode = DataSet.DealNumber;
     elif( (DataSet.DocKind == DL_ISSUE_UNION) or (DataSet.DocKind == DL_CHGAVRNOM) )
        FD = SPFirstDocDLCOMM( DataSet.DocKind, DataSet.DocID );
        OperCode = FD.comm.rec.CommCode;
     else
        FD = SPFirstDoc( 0, DataSet.DocID );
        OperCode = FD.tick.rec.DealCode;
     end;
  end;

  if( (FD != "") AND (FD.ID > 0) AND ((OperKind==null)or(OperKind == "")) )
     OperKind = ПолучитьВидОперацииПоПД(FD, true, true, false, false, true);
  end;

  return true;

  OnError( RslErrObj )
     StrError = RslErrObj.Message;
     return false;
END;

/*последний день месяца*/
MACRO SP_LastDay( m, y ) /* передаем Месяц, Год */
  var d;

  m = m + 1;
  if (m > 12)
     m = 1;
     y = y + 1;
  end;

  DateSplit (Date(1,m,y)-1,d);

  return d;
END;

macro SP_ПолучитьЕКК( Client:integer, ClientContr:integer  )
  var Code:string = "", sqlQuery;
  if((Client > 0 ) and (ClientContr > 0))
    sqlQuery = RSDCommand("select rsb_secur.SC_GetDlObjCodeOnDate(?, ?, dlcontr.t_DlContrID) as Code " +
                            "from dsfcontr_dbt sfcontr, ddlcontrmp_dbt dlcontrmp, ddlcontr_dbt dlcontr " +
                          " where sfcontr.t_PartyID = ? " +
                             "and sfcontr.t_ID = ? " +
                             "and sfcontr.t_ID = dlcontrmp.t_SfContrID " +
                             "and dlcontr.t_DlContrID = dlcontrmp.t_DlContrID " );

    sqlQuery.addParam( "", RSDBP_IN, OBJTYPE_BROKERCONTR_DL  );
    sqlQuery.addParam( "", RSDBP_IN, DLCCK_USC  );
    sqlQuery.addParam( "", RSDBP_IN, Client  );
    sqlQuery.addParam( "", RSDBP_IN, ClientContr  );
    sqlQuery.execute();

    var ret = TRsbDataSet( sqlQuery, RSDVAL_CLIENT, RSDVAL_STATIC );
    if( ret.MoveNext() )
      Code = SQL_ConvTypeStr(ret.Code);
    end;
  end;
  return Code;
end;

PRIVATE VAR UseComInCalcReservReg = NULL;
// Включать комиссии в расчет резервов для НУ
MACRO SC_UseComInCalcReservReg()
  if( UseComInCalcReservReg == NULL )
    var ErrCode = 0;
    GetRegistryValue( "SECUR\\НАЛОГОВЫЙ УЧЕТ\\V23", V_BOOL, UseComInCalcReservReg, ErrCode);
    if( ErrCode != 0 )
       UseComInCalcReservReg = true; // по умолчанию
    end;
  end;
  return UseComInCalcReservReg;
END;

MACRO GetTAXCalculatedDue(pClient, ResidenceStatus, pBeg, pEnd, Year, pIIS, pRg, pRs, pRp, Bs, Dg:@MONEY, Ds:@MONEY, Dm:@MONEY, Dp:@MONEY, Pg:@MONEY,  Pm:@MONEY, Pp:@MONEY, Ps:@MONEY, FromOutSyst:BOOL)
   var S, S15, Bg=$0, Bm=$0,  Bp=$0, SN=$0,/*, Pg=$0, Pm=$0, Pp=$0,*/ ToPay, ToReturn, PayNDR, ReturnNDR, TaxPriority;
   var Bg1 = $0, Bg2_2 = $0, Bg2_3 = $0, Bg9 = $0, Bg5 = $0, Pg1 = $0, Pg2 = $0, Pg9 = $0, Pg5 = $0, Pp1 = $0, Pp2 = $0, Pp9 = $0, Pp5 = $0;
   var Dg1 = $0, Dg2 = $0, Dg9 = $0, Dg5 = $0, Dp1 = $0, Dp2 = $0, Dp9 = $0, Dp5 = $0;
   var SPg15 = $0;
   var ToutNat = $0;
   var query, cmd, DataSet;
   var AddWhereNotOut = " obj.t_FromOutSyst <> 'X'";
   var AddWhereFromOut = " obj.t_FromOutSyst = 'X'";   

   var Taxe   = $0; //Уплаченный налог по базовой ставке по сформированным в этой ф-ции НДР
   var Taxe15 = $0; //Уплаченный налог по повышенной ставке по сформированным в этой ф-ции НДР

   var PtIsRes = DL_GetPartyResident(pClient);
   Dg = $0;
   Dm =  $0;       
   Ds =  $0;
   Dp =  $0;
   Pg = $0;
   Pm =  $0;       
   Ps =  $0;
   Pp =  $0;

   PRIVATE MACRO IsPartyResident()
      if (PtIsRes == NPTXPARTY_RESIDENT)
          return true;
      else
          return false;
      end;
   END;

   PRIVATE MACRO Rg()
      var retval;
      if (IsPartyResident())
          retval = 13.0;
      else
          //Если вдруг на клиенте физлице нерезиденте задано примечание "Налоговая ставка для физического лица - нерезидента по общим доходам"
          var _stat = ПолучитьЗначениеПримечанияНаДату(pClient, PARTY_NOTE_KIND_NPTX_RATE_NOTRES /*налоговая ставка физикаНерезидента*/, pEnd, @retval);
          if (_stat != 0)
              retval = 30.0;
          end;
      end;
      return retval;
   END;
 
   PRIVATE MACRO Rp()
      var retval;
      if (IsPartyResident())
          retval = 15.0;
      else
          retval = 0.0;
      end;
      return retval;
   END;

   PRIVATE MACRO Rs()
      if (IsPartyResident())
          return 9.0;
      else
          return 15.0;
      end;
   END;

   private macro GetPg(NpTxKindsStr:string, AddWhereCond)
     var _Pg = $0;

     _Pg = GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_CALCNDFL, null, pIIS, AddWhereCond) + //созданные в операциях расчета НОБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, 0 /*только пользовательские*/,null, pIIS, AddWhereCond) +
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, NULL, DL_HOLDNDFL, date(1,1,Year), pIIS, AddWhereCond) + //созданные в операциях удержания НДФЛ с T_PREVDATE такой же, как и текушей операции
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_WRTMONEY, null, pIIS, AddWhereCond) + //созданные в операциях списания/зачисления денежных средств
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_RETIREMENT_OWN, null, pIIS, AddWhereCond) + //созданные в операциях погашения ОЭБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_NPTXSTBOP, null, pIIS, AddWhereCond) + //созданные в операциях корректировки события СНОБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_NPTXCRNSET, null, pIIS, AddWhereCond) + //созданные в операциях компенсации
           /*плюс операции в ПС <Векселя банка>*/
           GetRubSumByClientFromVeksel(pClient, string(NpTxKindsStr), pBeg, pEnd, string(DL_VEKSELDRAWORDER)+", "+ //погашение сюда же входит выкуп
                                                                                  string(DL_VSBARTERORDER)  +", "+ //мена
                                                                                  string(DL_VSINTERCHANGE) );      //зачет взаимных требований

     if(pIIS == 0)
       _Pg = _Pg + GetRubSumByClientFromDepo(pClient, string(NpTxKindsStr), pBeg, pEnd); //созданные в операции "Расчет и начисление дохода" в депозитарии
     end;

     return _Pg;
   end;

   private macro GetPp(NpTxKindsStr:string, AddWhereCond)
     var _Pp = $0;

     _Pp = GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_CALCNDFL, null, pIIS, AddWhereCond) + //созданные в операциях расчета НОБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, 0 /*только пользовательские*/,null, pIIS, AddWhereCond) +
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, NULL, DL_HOLDNDFL, date(1,1,Year), pIIS, AddWhereCond) + //созданные в операциях удержания НДФЛ с T_PREVDATE такой же, как и текушей операции
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_WRTMONEY, null, pIIS, AddWhereCond) + //созданные в операциях списания/зачисления денежных средств
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_NPTXSTBOP, null, pIIS, AddWhereCond) + //созданные в операциях корректировки события СНОБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_NPTXCRNSET, null, pIIS, AddWhereCond) + //созданные в операциях компенсации
           /*плюс операции в ПС <Векселя банка>*/
           GetRubSumByClientFromVeksel(pClient, string(NpTxKindsStr), pBeg, pEnd, string(DL_VEKSELDRAWORDER)+", "+ //погашение сюда же входит выкуп
                                                                                  string(DL_VSBARTERORDER)  +", "+ //мена
                                                                                  string(DL_VSINTERCHANGE) );      //зачет взаимных требований


     if(pIIS == 0)
       _Pp = _Pp + GetRubSumByClientFromDepo(pClient, string(NpTxKindsStr), pBeg, pEnd); //созданные в операции "Расчет и начисление дохода" в депозитарии
     end;

     return _Pp;
   end;

   private macro GetPs(NpTxKindsStr:string, AddWhereCond)
     var _Ps = $0;

     _Ps = GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_CALCNDFL, null, pIIS, AddWhereCond) + //созданные в операциях расчета НОБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, 0 /*только пользовательские*/, null, pIIS, AddWhereCond) +
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, NULL, DL_HOLDNDFL, date(1,1,Year), pIIS, AddWhereCond); //созданные в операциях удержания НДФЛ с T_PREVDATE такой же, как и текушей операции

     if(pIIS == 0)
       _Ps = _Ps + GetRubSumByClientFromDepo(pClient, string(NpTxKindsStr), pBeg, pEnd); //созданные в операции "Расчет и начисление дохода" в депозитарии
     end;

     return _Ps;
   end;

   private macro GetPm(NpTxKindsStr:string, AddWhereCond)
     var _Pm = $0;

     _Pm = GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, DL_CALCNDFL, null, pIIS, AddWhereCond) + //созданные в операциях расчета НОБ
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, pEnd, 0 /*только пользовательские*/,null, pIIS, AddWhereCond) +
           GetRubSumByClientOperDocKind(pClient, string(NpTxKindsStr), pBeg, NULL, DL_HOLDNDFL, date(1,1,Year), pIIS, AddWhereCond); //созданные в операциях удержания НДФЛ с T_PREVDATE такой же, как и текушей операции

     if(pIIS == 0)
       _Pm = _Pm + GetRubSumByClientFromDepo(pClient, string(NpTxKindsStr), pBeg, pEnd); //созданные в операции "Расчет и начисление дохода" в депозитарии
     end;

     return _Pm;
   end;

   private macro RedistrD(_Dg:@money, _Dp:@money, TxKind, Comment, TxKind_15, Comment_15)
      var Sg = $0, Sp = $0;
 
      if((_Dg != 0) or (_Dp != 0))

       if( ((abs(_Dg) != _Dg) and (abs(_Dp) == _Dp)) or
           ((abs(_Dg) == _Dg) and (abs(_Dp) != _Dp))
         ) //Значения _Dg И _Dp с разными знаками

            if(abs(_Dg) >= abs(_Dp))
               Sg = _Dp;
               Sp = -Sg;
         elif(abs(_Dg) < abs(_Dp))
               Sg = _Dg;
               Sp = -Sg;
            end;
 
            if(Sg != 0)
               _Dg = _Dg - Sg;
            end;
 
            if(Sp != 0)
               _Dp = _Dp - Sp;
           SPg15 = SPg15 + Sp;

            end;

         end;
      end;
   end;
    
   if((Year >= 2021) and (IsPartyResident()) and ((pIIS == NULL) or (pIIS == 0)))
     Bg1 = GetRubSumByClient(pClient, string(TXOBJ_BASEG1), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
     Pg1 = GetPg(TXOBJ_DIVPAY_SEC+","+TXOBJ_DIVPAY_SEC_0, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
     Pp1 = GetPp(TXOBJ_PAIDGENERAL_15_1+","+TXOBJ_PAIDGENERAL_15_1_0, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut)); 
     Dg1 = round(Rg() * Min(Bg1, NPTX_LIMINCOME_MAX15) / 100.0 - Pg1, 0);
     Dp1 = round(Rp() * Max(Bg1-NPTX_LIMINCOME_MAX15, $0) / 100.0 - Pp1, 0);

     Bg2_2 = GetRubSumByClient(pClient, TXOBJ_BASEG2, pBeg, pEnd, null, pIIS);
     Bg2_3 = GetRubSumByClient(pClient, TXOBJ_BASEG3, pBeg, pEnd, null, pIIS);
     Pg2 = GetPg(TXOBJ_PAIDGENERAL+","+TXOBJ_PAIDGENERAL_0+","+TXOBJ_PAIDMATERIAL, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
     Pp2 = GetPp(TXOBJ_PAIDGENERAL_15_2, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut))/*+GetPp(TXOBJ_PAIDGENERAL_15,AddWhereFromOut)*/;
     Dg2 = round(Rg() * Min(Bg2_2, NPTX_LIMINCOME_MAX15) / 100.0 + Rg() * Min(Bg2_3, NPTX_LIMINCOME_MAX15) / 100.0 - Pg2, 0);
     Dp2 = round(Rp() * Max(Bg2_2-NPTX_LIMINCOME_MAX15, $0) / 100.0 + Rp() * Max(Bg2_3-NPTX_LIMINCOME_MAX15, $0) / 100.0 - Pp2, 0);

     Bg9 = GetRubSumByClient(pClient, string(TXOBJ_BASEG9), pBeg, pEnd, null, pIIS);
     Pg9 = GetPg(TXOBJ_PAIDBILL);
     Pp9 = GetPp(TXOBJ_PAIDGENERAL_15_9);
     Dg9 = round(Rg() * Min(Bg9, NPTX_LIMINCOME_MAX15) / 100.0 - Pg9, 0);
     Dp9 = round(Rp() * Max(Bg9-NPTX_LIMINCOME_MAX15, $0) / 100.0 - Pp9, 0);
   end;

   if((Year >= 2021) and (IsPartyResident()) )
        if( (pIIS == NULL) or (pIIS == 0) )
          Bs = GetRubSumByClient(pClient, string(TXOBJ_BASESPECIAL), pBeg, pEnd, null, pIIS);
          Ps = GetPs(TXOBJ_PAIDSPECIAL+ ","+TXOBJ_PAIDSPECIAL_0);

          if(SN != 0)
             RedistrD(@Dg1, @Dp1, TXOBJ_DIVPAY_SEC,  "Уплаченный налог на дивиденды", TXOBJ_PAIDGENERAL_15_1, "Уплаченный налог по повышенной ставке 15% по НОБ вида 1");
             RedistrD(@Dg2, @Dp2, TXOBJ_PAIDGENERAL, "Уплаченный налог",              TXOBJ_PAIDGENERAL_15_2, "Уплаченный налог по повышенной ставке 15% по НОБ вида 2");
             RedistrD(@Dg9, @Dp9, TXOBJ_PAIDBILL,    "Уплаченный налог по векселям",  TXOBJ_PAIDGENERAL_15_9, "Уплаченный налог по повышенной ставке 15% по НОБ вида 9");
          end;

          //Pg = GetPg(TXOBJ_PAIDGENERAL+","+TXOBJ_PAIDGENERAL_0 + "," + TXOBJ_PAIDMATERIAL + "," + TXOBJ_PAIDBILL + "," + TXOBJ_DIVPAY_SEC + "," + TXOBJ_DIVPAY_SEC_0, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
          Pm = 0;
        end;
        if((pIIS == NULL) or (pIIS == 1))
          Bg5 = GetRubSumByClient(pClient, string(TXOBJ_BASEG5), pBeg, pEnd, null, null, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
          Pg5 = GetPg(TXOBJ_PAIDGENERAL_IIS, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
          Pp5 = GetPp(TXOBJ_PAIDGENERAL_15_IIS, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
          Dg5 = Rg() * Min(Bg5, NPTX_LIMINCOME_MAX15) / 100.0 - Pg5;
          Dp5 = Rp() * Max(Bg5-NPTX_LIMINCOME_MAX15, $0) / 100.0 - Pp5;

          Bs = Bs + GetRubSumByClient(pClient, string(TXOBJ_BASESPECIAL_IIS ), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
          Ps = Ps + GetPs(TXOBJ_PAIDSPECIAL_IIS, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));

        end;
		
        Pg = Pg1 + Pg2 + Pg9 + Pg5;
        Pp = Pp1 + Pp2 + Pp9 + Pp5;
        Dg = Dg1 + Dg2 + Dg9 + Dg5;
        Dp = Dp1 + Dp2 + Dp9 + Dp5;

        Ds = Rs() * Bs / 100.0 - Ps;
   else

        if( (pIIS == NULL) or (pIIS == 0) )
            Bg  =   GetRubSumByClient(pClient, string(TXOBJ_BASEGENERAL), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut))
                  + GetRubSumByClient(pClient, string(TXOBJ_BASEG2), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));

            Bm = GetRubSumByClient(pClient, string(TXOBJ_BASEMATERIAL), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Bs = GetRubSumByClient(pClient, string(TXOBJ_BASESPECIAL_DIV), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));

            Pg = GetPg(TXOBJ_PAIDGENERAL+","+TXOBJ_PAIDGENERAL_0, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Pm = GetPm(TXOBJ_PAIDMATERIAL, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Ps = GetPs(TXOBJ_DIVPAY_SEC+","+TXOBJ_DIVPAY_SEC_0, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
        end;
        if((pIIS == NULL) or (pIIS == 1))
            Bg = Bg + GetRubSumByClient(pClient, string(TXOBJ_BASEGENERAL_IIS ), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Bm = Bm + GetRubSumByClient(pClient, string(TXOBJ_BASEMATERIAL_IIS), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Bs = Bs + GetRubSumByClient(pClient, string(TXOBJ_BASESPECIAL_IIS ), pBeg, pEnd, null, pIIS, null, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
       
            Pg = Pg + GetPg(TXOBJ_PAIDGENERAL_IIS, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Pm = Pm + GetPm(TXOBJ_PAIDMATERIAL_IIS, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
            Ps = Ps + GetPs(TXOBJ_PAIDSPECIAL_IIS, IIF((FromOutSyst == true) or (FromOutSyst == NULL), NULL, AddWhereNotOut));
        end;
      
        Dg = Rg() * Bg / 100.0 - Pg;
        Dm = Rg() * Bm / 100.0 - Pm;
        Ds = Rs() * Bs / 100.0 - Ps;
   end;

   Dg = round(Dg,0);
   Dm = round(Dm,0);         
   Ds = round(Ds,0);
   Dp = round(Dp,0);
   Pg = round(Pg,0);
   Ps = round(Ps,0);
   Pm = round(Pm,0);
   Pp = round(Pp,0);
END;

private macro SplitBySpace(str:string, str1:@string, str2:@string)
  var idx;

  str = Trim(str);
  idx = Index(str, " ");
  if(idx > 0)
    str1 = SubStr(str, 1, idx);
    str2 = SubStr(str, idx);
  else
    str1 = str;
    str2 = "";
  end;
end;

macro ConvetFIO_Report(full:string):string // Перевод общей строки Ф И О в формат И.О. Фамилия
  var idx1, idx2;
  var SurName = "";
  var FName = "";
  var SName = "";

  SplitBySpace(full, @SurName, @full);  
  SplitBySpace(full, @FName, @full);  
  SplitBySpace(full, @SName, @full);  

  if(StrLen(FName) > 0)
    FName = SubStr(FName, 1, 1) + ".";
  else
    FName = "";
  end;

  if(StrLen(SName) > 0)
    SName = SubStr(SName, 1, 1) + ".";
  else
    SName = "";
  end;

  return FName+SName+" "+SurName;
end;

