/**
  @file nptxstbfun.mac
  @brief Функции для работы с записями СНОБ, в том числе и на шагах

  В этом макросе собраны все функции для работы со СНОБ. Это функции получения настроек,
  функции создания новых событий СНОБ, получения СНОБ от Хранилища, отправка записей в Хранилище,
  откат отправки, пересчет в связи с изменение СНОБ, создание буферных записей при входящем запросе от Хранилища и т.п.

  #tag
  - functional_block:СНОБ

  #changelog
*/

import "spserv.mac", "secinter.mac", "dlquery.mac", "vsnptxspec.mac";
import "SendOperationResultReq.mac", "ChangeStatusSNOBReq.mac", "GetAmountSNOBReq.mac";

CONST NPTXKBK_MAIN = "18210102010011000110";
CONST NPTXKBK_PROC = "18210102070011000110";
CONST NPTXKBK_15   = "18210102080011000110";
CONST NPTXKBK_INCR = NPTXKBK_15;
CONST NPTXKBK_INCR_208 = NPTXKBK_INCR;
CONST NPTXKBK_INCR_218 = "18210102180011000110";
CONST NPTXKBK_INCR_224 = "18210102240011000110";
CONST NPTXKBK_INCR18 = "18210102150011000110";
CONST NPTXKBK_INCR20 = "18210102160011000110";
CONST NPTXKBK_INCR22 = "18210102170011000110";

CONST ERR_SNOB_21 = 21; //Запись в хранилище СНОБ ранее уже была переведена в отмененные


/**
  @brief Получить значение настройки COMMON\СНОБ\ВРЕМЯ ОТВЕТА ОТ ХРАНИЛИЩА СНОБ
  @return Значение настройки типа INTEGER - количество секунд
*/
MACRO ВРЕМЯ_ОТВЕТА_ОТ_ХРАНИЛИЩА_СНОБ():integer
   var ErrCode, RegPath = "COMMON\\СНОБ\\ВРЕМЯ ОТВЕТА ОТ ХРАНИЛИЩА СНОБ";
   var Val = 0;

   GetRegistryValue( RegPath, V_INTEGER, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
end;

/**
  @brief Получить значение настройки COMMON\СНОБ\КОЛ. ОТВ. С ОШИБК. ОТ ХРАНИЛИЩА
  @return Значение настройки типа INTEGER - количество ошибочных ответов
*/
MACRO КОЛИЧЕСТВО_ОТВЕТОВ_С_ОШИБКАМИ_ОТ_ХРАНИЛИЩА_СНОБ():integer
   var ErrCode, RegPath = "COMMON\\СНОБ\\КОЛ. ОТВ. С ОШИБК. ОТ ХРАНИЛИЩА";
   var Val = 0;

   GetRegistryValue( RegPath, V_INTEGER, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
END;

/**
  @brief Получить значение настройки COMMON\СНОБ\РАБОТА С ВНЕШНИМ ХРАНИЛИЩЕМ
  @return Значение настройки типа BOOL - флаг ведения работы с внешним Хранилищем
*/
MACRO РАБОТА_С_ВНЕШНИМ_ХРАНИЛИЩЕМ_СНОБ():bool
   var ErrCode, RegPath = "COMMON\\СНОБ\\РАБОТА С ВНЕШНИМ ХРАНИЛИЩЕМ";
   var Val = false;

   GetRegistryValue( RegPath, V_BOOL, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
END;

/**
  @brief Получить значение настройки COMMON\СНОБ\РАБОТА В РЕЖИМЕ СНОБ
  @return Значение настройки типа BOOL - флаг ведения работы в режиме СНОБ
*/
MACRO РАБОТА_В_РЕЖИМЕ_СНОБ():bool
   var ErrCode, RegPath = "COMMON\\СНОБ\\РАБОТА В РЕЖИМЕ СНОБ";
   var Val = false;

   GetRegistryValue( RegPath, V_BOOL, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
END;

/**
  @brief Получить значение настройки COMMON\СНОБ\ВЫПОЛНЯТЬ КОРРЕКТИРОВКУ НДФЛ
  @return Значение настройки типа BOOL - флаг необходимости выполнения корректировок НДФЛ
*/
MACRO ВЫПОЛНЯТЬ_КОРРЕКТИРОВКУ_НДФЛ():bool
   var ErrCode, RegPath = "COMMON\\СНОБ\\ВЫПОЛНЯТЬ КОРРЕКТИРОВКУ НДФЛ";
   var Val = false;

   GetRegistryValue( RegPath, V_BOOL, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
END;

/**
  @brief Получить значение настройки COMMON\СНОБ\ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ
  @return Значение настройки типа BOOL - флаг необходимости использования прогрессивной шкалы налогообложения
*/
MACRO ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ():bool
   var ErrCode, RegPath = "COMMON\\СНОБ\\ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ";
   var Val = false;

   GetRegistryValue( RegPath, V_BOOL, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
END;

/**
  @brief Получить значение настройки COMMON\СНОБ\ДАТА ЗАПУСКА СНОБ
  @return Значение настройки типа DATE - дата начала работы со СНОБ
*/
macro GetStartSTBDate()
  var cmd = DL_RSDCommand("select RSI_NPTO.GetStartSTBDate dt from dual");
  var DataSet = cmd.execute();

  if(DataSet.moveNext())
    return date(DataSet.dt);
  end;

  return date(31,12,9999);
end;

/**
  @brief Получить значение настройки COMMON\СНОБ\ВЫПОЛНЯТЬ КОРРЕКТИРОВКУ НДФЛ
  @return Значение настройки типа BOOL - флаг необходимости выполнения корректировок НДФЛ
*/
MACRO НП_ВВОДА_ДОРАБОТОК_BOSS_2981():integer
   var ErrCode, RegPath = "COMMON\\НДФЛ\\НП_ВВОДА_ДОРАБОТОК_BOSS-2981";
   var Val = 0;

   GetRegistryValue( RegPath, V_INTEGER, Val, ErrCode );

   if( ErrCode != 0 )
      MsgBox( "Ошибка при получении значения настройки \"" + RegPath + "\"");
   end;

   return Val;
END;

/**
  @brief Получить значение настройки COMMON\НДФЛ\ДАТА_ВВОДА_ПРОГРЕССИВНОЙ_ШКАЛЫ
  @return Значение настройки типа DATE - дата начала действия прогрессивной шкалы налогообложения
*/
macro GetStartProgressScaleDate()
  var cmd = DL_RSDCommand("select RSI_NPTO.GetStartProgressScaleDate dt from dual");
  var DataSet = cmd.execute();

  if(DataSet.moveNext())
    return date(DataSet.dt);
  end;

  return date(31,12,9999);
end; 

macro IsUseProgressScale(operDate)
  var StartProgressScaleDate = GetStartProgressScaleDate();
  
  if((ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ() == true) and (StartProgressScaleDate > date(0,0,0)) and (operDate >= StartProgressScaleDate))
    return true;
  end;

  return false;
end;

/**
  @brief Процедура определения налоговых ставок (ПОНС).
*/
macro CreateTaxRatesBySNOB(ClientID:integer,
                           TaxPeriod:integer,
                           TaxBaseType:integer,
                           TaxBase:money,
                           SNOB:money,
                           CalcDate:date
                          )
  var cmd;
  
  cmd = RSDCommand("CALL RSI_NPTX.CreateTaxRatesBySNOB(?,?,?,?,?,?)");

  cmd.addParam( "", RSDBP_IN, ClientID );
  cmd.addParam( "", RSDBP_IN, TaxPeriod );
  cmd.addParam( "", RSDBP_IN, TaxBaseType );
  cmd.addParam( "", RSDBP_IN, TaxBase );
  cmd.addParam( "", RSDBP_IN, SNOB );
  cmd.addParam( "", RSDBP_IN, CalcDate );
  cmd.execute();
end;

/**
  @brief Процедура Расчета Исчисленного Налога (ПРИН).
*/
macro CalcTaxByRanges(ClientID:integer,
                      TaxPeriod:integer,
                      TaxBaseType:integer,
                      TaxBase:money,
                      SNOB:money,
                      CalcDate:date
                     )
  var cmd;
  
  cmd = RSDCommand("CALL RSI_NPTX.CalcTaxByRanges(?,?,?,?,?,?)");

  cmd.addParam( "", RSDBP_IN, ClientID );
  cmd.addParam( "", RSDBP_IN, TaxPeriod );
  cmd.addParam( "", RSDBP_IN, TaxBaseType );
  cmd.addParam( "", RSDBP_IN, TaxBase );
  cmd.addParam( "", RSDBP_IN, SNOB );
  cmd.addParam( "", RSDBP_IN, CalcDate );
  cmd.execute();
end;

/**
  @brief Процедура расчета налога к удержанию (ПРасНаКу)
*/
macro CalcHoldTaxByRanges(ClientID:integer,
                          TaxPeriod:integer,
                          TaxBaseType:integer,
                          TaxBase:money,
                          SNOB:money,
                          CalcDate:date,
                          SpecialTag
                         )
  var cmd;
  
  cmd = RSDCommand("CALL RSI_NPTX.CalcHoldTaxByRanges(?,?,?,?,?,?,?)");

  cmd.addParam( "", RSDBP_IN, ClientID );
  cmd.addParam( "", RSDBP_IN, TaxPeriod );
  cmd.addParam( "", RSDBP_IN, TaxBaseType );
  cmd.addParam( "", RSDBP_IN, TaxBase );
  cmd.addParam( "", RSDBP_IN, SNOB );
  cmd.addParam( "", RSDBP_IN, CalcDate );
  cmd.addParam( "", RSDBP_IN, SpecialTag );
  cmd.execute();
end;

/**
  @brief Получить системные дату и время по серверу БД
  @param[out] SystDate - системная дата сервера БД
  @param[out] SystTime - системное время сервера БД
*/
private macro GetSystDateTime(SystDate:@date, SystTime:@time)
  var cmd = DL_RSDCommand("select sysdate dt from dual");
  var DataSet = cmd.execute();

  DataSet.moveNext();

  DtTmSplit(DataSet.dt, SystDate, SystTime);
end;

PRIVATE MACRO GetDlContrIDfromSf(SfContrID:integer)
  var query, cmd, DataSet;
  var DlContrID = 0;

  if(SfContrID > 0)
    cmd = DL_RSDCommand();

    query = "select dlc.t_DlContrID from ddlcontr_dbt dlc where dlc.t_SfContrID = " + cmd.AddParam(SfContrID);

    DataSet = cmd.Execute(query);

    if(DataSet.moveNext())
      DlContrID = DataSet.DlContrID;
    end;

    if(DlCOntrID == 0)
      cmd = DL_RSDCommand();

      query = "select mp.t_DlContrID from ddlcontrmp_dbt mp where mp.t_SfContrID = " + cmd.AddParam(SfContrID);

      DataSet = cmd.Execute(query);

      if(DataSet.moveNext())
        DlContrID = DataSet.DlContrID;
      end;
    end;
  end;

  return DlContrID;
END;

/**
  @brief Получить номер договора ИИС из операции
  @param[out] DocKind - Вид операции (первичного документа, а не системной операции), в которой создается событие СНОБ
  @param[out] DocID   - Идентификатор операции (первичного документа, а не системной операции), в которой создается событие СНОБ
*/
private macro GetDlContrID(DocKind, DocID)
  var contract = 0;
  var cmd = DL_RSDCommand("select op.t_contract from dnptxop_dbt op where op.t_id = ? and op.t_dockind = ?");
      cmd.addParam(DocID);
      cmd.addParam(DocKind);
  var DataSet = cmd.execute();

  if(DataSet.moveNext())
    contract = DataSet.Contract;
  end;
  
  if(DocKind == 4607) //У операции Списания/Зачисления денежных средств sfcontr, а не dlcontr
    contract = GetDlContrIDfromSf(contract);
  end;

  return contract;
end;

/**
  @brief Определить "Спец признак" для записи о событии СНОБ
  @param[in] STB - TRecHandler Буфер записи о событии СНОБ по dnptxtotalbase_dbt
*/
private macro GetSpecialTag(STB)

  if((index(STB.rec.Description, "Получение дохода по векселям (погашение)") != 0) and 
     (STB.rec.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_BROK)) //Если Описание события = <Получение дохода по векселям (погашение)>, то <Спец признак> = ВЕКС
    return "ВЕКС";
  elif(index(STB.rec.Description, "Мат. выгода") != 0) //Если Описание события = <Мат. выгода>, то <Спец признак> = МАТ,
    return "МАТ";
  elif(STB.rec.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_BROK) //Если Описание события != <Мат. выгода>, <Получение дохода по векселям (погашение)> И Тип НОБ = БРОК, то <Спец признак> = БРОК 
    return "БРОК";
  end;
  
  return "";
end;

/**
  @brief Получить единой строкой дату и время с указанием временной зоны относительно Гринвича
  @param[in] dat_v - дата сервера БД
  @param[in] dtime - время сервера БД
  @return Строка, содержащая дату, время и временную зону
*/
PRIVATE MACRO GetDatePlusTimeZone(dat_v, dtime)
  var DTZ = "+00:00",dat,dt;
  var query_zone,rs_zone,DataSet ;

  query_zone = "select to_char(to_date('"+dat_v+"','dd.mm.yyyy'),'yyyy-mm-dd') as vl from dual";
  rs_zone = Dl_RSDCommand(query_zone);
  DataSet = rs_zone.Execute();
  if (DataSet.moveNext() )
     dat= DataSet.vl;
  end;

  query_zone=null; rs_zone=null; DataSet = null;
  
  query_zone = "select lpad(trim(substr('"+dtime+"',instr(replace(replace('"+dtime+"','('),')'),'.00'))), 8, '0') as vl from dual";
  rs_zone = Dl_RSDCommand(query_zone);
  DataSet = rs_zone.Execute();
  if (DataSet.moveNext() )
     dt = trim(string(DataSet.vl));
  end;

  query_zone=null; rs_zone=null; DataSet = null;

  query_zone = "select to_char(DBTIMEZONE) as vl from dual";
  rs_zone = Dl_RSDCommand(query_zone);
  DataSet = rs_zone.Execute();
  if (DataSet.moveNext() )
    DTZ = dat+"T"+dt+trim( string( DataSet.vl ) );
  end;              

  query_zone=null; rs_zone=null; DataSet = null;

  return DTZ;
END;

/**
  @brief Проверить, что статус налогоплательщика относится к резиденту
  @param[in] TaxPayerStatus - Числовое значение статуса налогоплательщика
  @return true - статус относится к резиденту
  @return false - статус не относится к резиденту
*/
macro STB_IsResidentStatus(TaxPayerStatus)

  if((TaxPayerStatus != 1) and (TaxPayerStatus != 7))
    return false;
  end;

  return true;
end;

/**
  @brief Процедура определения налогового статуса клиента (ПОНСК)
  @param[in] ClientID - Идентификатор клиента
  @param[in] Date - На дату
  @return 1 - статус относится к резиденту
  @return 0 - статус не относится к резиденту
*/
macro STB_IsResidentStatusRSI(ClientID, Date)
  var cmd = DL_RSDCommand("select RSI_NPTX.STB_IsResidentStatus(?,?) RS from dual");
      cmd.AddParam(ClientID);
      cmd.AddParam(Date);
  var DataSet = cmd.execute();

  if(DataSet.moveNext())
    return DataSet.RS;
  end;
end; 

macro isReCalcStatus(ID_Operation)
  var query =  " select 1 "
             + "   from dnptxval_dbt "
             + "  where t_ID_Operation = ? "
             + "    and t_Kind = " + NPTXVAL_KIND_DOCRECALCSTATUS
             + "    and t_Val = 3 "
             + "    and ROWNUM = 1 ";
  var cmd = DL_RSDCommand(query);
      cmd.AddParam(ID_Operation);
  var DataSet = cmd.execute();

  if(DataSet.moveNext())
    return true;
  end;
  return false;
end; 

/**
  @brief Получить последнее сохраненное значение величины заданного вида для указанного объекта при работе со СНОБ, а также сохраненную дату и время величины
  @param[in] DocKind  - Вид объекта/первичного документа. Это либо операция, в которой получали СНОБ от Хранилища, либо сама запись о событии СНОБ, для которой сохраняем полученную величину.
  @param[in] DocID    - Идентификатор объекта/первичного документа
  @param[in] Kind     - Вид величины
  @param[out] Val     - Значение величины
  @param[out] ValDate - Дата величины
  @param[out] ValTime - Время величины
*/
MACRO GetLastOpSTBVal(DocKind, DocID, Kind, Val:@money, ValDate:@date, ValTime:@time, KBK:string, Rate:integer)
  var query, cmd, DataSet;

  Val = $0;
  ValDate = date(0,0,0);
  ValTime = time(0);

  cmd = DL_RSDCommand(query);

  query =   " select t_Val as STBVal, t_Date as STBDate, t_Time as STBTime "
          + "   from dnptxval_dbt "
          + "  where t_DocKind = ? "
          + "    and t_DocID = ? "
          + "    and t_Kind = ? " ;

  cmd.AddParam(DocKind);
  cmd.AddParam(DocID);
  cmd.AddParam(Kind);

  if(Rate != NULL)
    query = query + " and t_Rate = ? ";
    cmd.AddParam(Rate);
  end;

  if(KBK != NULL)
    query = query + " and t_KBK = ? ";
    cmd.AddParam(KBK);
  end;

  query = query + "  order by t_ID DESC ";

  DataSet = cmd.Execute(query);
  if(DataSet.moveNext())
    Val     = money(DataSet.STBVal); 
    ValDate = date(DataSet.STBDate); 
    ValTime = time(DataSet.STBTime);
  end;
END;

/**
  @brief Получить сумму значения "НОБ по текущей выплате" и сумму значений "Налог исчисленный" для клиента
  @param[in] ClientID      - integer Идентификатор клиента, для которого определяется значение
  @param[in] TaxBaseKind   - string  Вид налоговой базы (может быть указано несколько через запятую). При вычислении сумм буду отобраны только записи с такими же видами налоговых баз
  @param[in] TaxPeriod     - integer (Необязательный) Налоговый год. Если указан, то при вычислении сумм будут отобраны только записи с таким же налоговым периодом (годом)
  @param[in] RateCalcPITax - integer (Необязательный) Налоговая ставка. Если указана, то при вычислении сумм будут отобраны только записи с акой же налоговой ставкой
  @param[in] BeforeTBID    - integer (Необязательный) ID события СНОБ, до которого отбирать записи, не включая его.
  @param[out] SumTaxBaseCurrPay - money. Возвращаемая сумма НОБ по текущей выплате всех отобранных записей
  @param[out] SumCalcPITax - money. Возвращаемая сумма исчисленного налога всех отобранных записей
  @param[in] BeforeDate - date (Необязательный) Дата, до которой отбирать записи. Если задана, то будут отобраны только записи до этой даты, либо в эту дату, но меньше по времени, если задан следующий параметр со временем.
  @param[in] BeforeTime - time (Необязательный) Время, до которого отбирать записи в дату BeforeDate, если она задана.
*/
macro STB_GetSumTB(ClientID, TaxBaseKind, TaxPeriod, RateCalcPITax, BeforeTBID, SumTaxBaseCurrPay:@money, SumCalcPITax:@money, BeforeDate, BeforeTime, AddWhereCondStr:string)
  var q, ds, select;
  var y = 0;

  SumTaxBaseCurrPay = $0;
  SumCalcPITax      = $0;

  q =   " select NVL(SUM(t_TaxBaseCurrPay), 0) as SumTaxBaseCurrPay, "
      + "        NVL(SUM(t_CalcPITax), 0) as SumCalcPITax"
      + "   from dnptxtotalbase_dbt "
      + "  where t_ClientID = ? "
      + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
      + "    and t_TaxBaseKind IN ("+TaxBaseKind+") ";

  select = DL_RSDCommand();

  select.AddParam(ClientID);

  if((ValType(TaxPeriod) == V_INTEGER) and (TaxPeriod > 0))
    q = q + " and t_TaxPeriod = ? ";

    select.AddParam(TaxPeriod);
  end;

  if((ValType(RateCalcPITax) == V_INTEGER) and (RateCalcPITax > 0))
    q = q + " and t_RateCalcPITax = ? ";

    select.AddParam(RateCalcPITax);
  end;

  if((ValType(BeforeTBID) == V_INTEGER) and (BeforeTBID > 0))
    q = q + " and t_TBID < ? ";

    select.AddParam(BeforeTBID);
  end;

  if(ValType(BeforeDate) == V_DATE)
    if(ValType(BeforeTime) == V_TIME)
      q = q + " and (t_IncDate < ? or (t_IncDate = ? and t_IncTime < ?) )";

      select.AddParam(BeforeDate);
      select.AddParam(BeforeDate);
      select.AddParam(BeforeTime);
    else
      q = q + " and t_IncDate < ? ";

      select.AddParam(BeforeDate);
    end;
  end;

  if((AddWhereCondStr != NULL) and (AddWhereCondStr != ""))
    q = q + "and " + AddWhereCondStr;
  end;
  
  ds = select.Execute(q);
  if(ds.moveNext())
    SumTaxBaseCurrPay = ds.SumTaxBaseCurrPay;
    SumCalcPITax = ds.SumCalcPITax;
  end;
end;

/**
  @brief Получить сумму значения "НОБ по текущей выплате" для клиента. Это ф-ция-обертка над STB_GetSumTB
  @param[in] ClientID      - integer Идентификатор клиента, для которого определяется значение
  @param[in] TaxBaseKind   - string  Вид налоговой базы (может быть указано несколько через запятую). При вычислении сумм буду отобраны только записи с такими же видами налоговых баз
  @param[in] TaxPeriod     - integer (Необязательный) Налоговый год. Если указан, то при вычислении сумм будут отобраны только записи с таким же налоговым периодом (годом)
  @param[in] RateCalcPITax - integer (Необязательный) Налоговая ставка. Если указана, то при вычислении сумм будут отобраны только записи с акой же налоговой ставкой
  @param[in] BeforeTBID    - integer (Необязательный) ID события СНОБ, до которого отбирать записи, не включая его.
  @param[in] BeforeDate    - date (Необязательный) Дата, до которой отбирать записи. Если задана, то будут отобраны только записи до этой даты, либо в эту дату, но меньше по времени, если задан следующий параметр со временем.
  @param[in] BeforeTime    - time (Необязательный) Время, до которого отбирать записи в дату BeforeDate, если она задана.
  @return SumTaxBaseCurrPay - money. Возвращаемая сумма НОБ по текущей выплате всех отобранных записей
*/
macro STB_GetSumTaxBaseCurrPay(ClientID, TaxBaseKind, TaxPeriod, RateCalcPITax, BeforeTBID, BeforeDate, BeforeTime, AddWhereCondStr:string)
   var SumTaxBaseCurrPay = $0;
   var SumCalcPITax      = $0;

   STB_GetSumTB(ClientID, TaxBaseKind, TaxPeriod, RateCalcPITax, BeforeTBID, @SumTaxBaseCurrPay, @SumCalcPITax, BeforeDate, BeforeTime, AddWhereCondStr);

   return SumTaxBaseCurrPay;
end;

/**
  @brief Проверить, является ли ошибка, полученная от Хранилища, действительно ошибкой в нашем понимании, то есть такой, что мы не сможем успешно продолжить обработку.
  @param[in] ErrorCode - string Код ошибки, полученной от Хранилища
  @return true - является ошибкой
  @return false - не является ошибкой. Такую ошибку можно игнорировать
*/
private macro IsError(ErrorCode:string)

  if((ErrorCode == "") or (ErrorCode == "0") or (ErrorCode == "000") or (ErrorCode == "20") or (ErrorCode == "24"))
    return false;
  end;

  return true;
end;

/**
  @brief Рассчитываем сумму СНОБ как сумму СНОБ, полученную от хранилища с максимальной датой получения.
  @param[in] ClientID        - integer Идентификатор клиента, для которого определяется значение
  @param[in] FindTaxBaseKind - string  Вид налоговой базы (может быть указано несколько через запятую). При вычислении сумм буду отобраны только записи с такими же видами налоговых баз
  @param[in] CheckDate       - date (Необязательный) Дата, до которой отбирать записи. Если задана, то будут отобраны только записи до этой даты, либо в эту дату, но меньше по времени, если задан следующий параметр со временем.
  @param[in] CheckTime       - time (Необязательный) Время, до которого отбирать записи в дату CheckDate, если она задана.                                                                                                        
  @param[in] TaxPeriod       - integer (Необязательный) Налоговый год. Если указан, то при вычислении сумм будут отобраны только записи с таким же налоговым периодом (годом)
  @return AmountSNOB - рассчитанная сумма СНОБ
*/
macro STB_GetAmountSNOBbyTB(ClientID, FindTaxBaseKind, TaxPeriod, IncDate, IncTime)
  var query, cmd, DataSet;
  var AmountSNOB = $0;
  var TBID = 0;

  cmd = DL_RSDCommand();

  ///Вычисляем сумму СНОБ, полученную от Хранилища с максимальной датой получения
  query =   " select t_ApplSTaxBaseInclude as AmountSNOB, t_TBID "
          + "   from dnptxtotalbase_dbt "
          + "  where t_ClientID = ? ";

  cmd.AddParam(ClientID);

  if(FindTaxBaseKind != NULL)
    query = query + "    and t_TaxBaseKind IN ("+FindTaxBaseKind+")";
  end;

  if((ValType(TaxPeriod) == V_INTEGER) and (TaxPeriod > 0))
    query = query + " and t_TaxPeriod = ? ";

    cmd.AddParam(TaxPeriod);
  end;

  if((ValType(IncDate) == V_DATE) and (IncDate > date(0,0,0)))
    query = query + " and (t_IncDate < ? or (t_IncDate = ? and t_IncTime <= ?))";

    cmd.AddParam(IncDate);
    cmd.AddParam(IncDate);
    cmd.AddParam(IncTime);
  end;
  
  query = query + "  order by t_IncDate DESC, t_IncTime DESC, t_TBID DESC ";

  DataSet = cmd.Execute(query);
  if(DataSet.moveNext())
    TBID = DataSet.TBID;
    AmountSNOB = DataSet.AmountSNOB;
  end;

  cmd = DL_RSDCommand();
  
  return AmountSNOB;
end;

/**
  @brief Определить вид налоговой базы для события СНОБ по указанному виду операции и признаку ИИС.
  @param[in] DocKind - integer Вид операции (первичного документа, а не системной операции), в которой создается событие СНОБ
  @param[in] IIS     - bool Признак вызова для ИИС
  @return integer Вид налоговой базы
*/
macro STB_GetTaxBaseKindByDocKind(DocKind:integer, IIS:bool, OperData:date)
  if(IIS)
    return NPTXTOTALBASE_TAXBASEKIND_IIS; //ИИС
  else
    if(DocKind == DL_NPTXCRNSET)
      return NPTXTOTALBASE_TAXBASEKIND_ONB; //ОНБ
    end;
    if (DocKind == DL_VEKSELDRAWORDER)
      if (not IsUseNewNOB(OperData))
        return NPTXTOTALBASE_TAXBASEKIND_ONB; //ОНБ
      end;
    end;
  end;

  return NPTXTOTALBASE_TAXBASEKIND_BROK; //БРОК
end;

/**
  @brief Получить актуальную СНОБ, запросив её у Хранилища, если с ним ведется работа. 
         Полученная сумма запоминается в DNPTXVAL_DBT 
         Как правило вызывается на шаге "Запрос СНОБ" для операций. Вне шагов не проверялась
  @param[in] DocKind      - integer Вид операции (первичного документа, а не системной операции), в которой определяется актуальная СНОБ
  @param[in] DocID        - integer Идентификатор операции (первичного документа, а не системной операции), в которой определяется актуальная СНОБ
  @param[in] ClientID     - integer Идентификатор клиента, для которого запрашиваем СНОБ
  @param[in] OperData     - date Дата операции. Нужна для определения по ней года - текущего налогового периода
  @param[in] ID_Operation - integer Идентификатор системной операции
  @param[in] ID_Step      - integer Идентификатор шага
  @param[out] ErrStr      - string Сообщение об ошибке
  @param[in] IIS          - bool Признак запроса для ИИС. По нему будет определен вид запрашиваемой налоговой базы
  @param[out] _AmountSNOB - money Полученная от Хранилища или рассчитанная СНОБ
  @return 0 - если не возникло ошибок
  @return err - integer Код ошибки
*/
macro STB_ExecuteGetAmountSNOBOnStep(DocKind, DocID, ClientID, OperDate, ID_Operation, ID_Step, ErrStr:@string, IIS:bool, _AmountSNOB:@money, CalcOnlyBySOFR:bool)
  var llv = TRecHandler("llvalues.dbt");
  var Year = 0;
  var err = 0;
  var AmountSNOB = $0;
  var query, cmd, DataSet;
  var ErrCode = "";
  var SystDate = date(0,0,0), SystTime = time(0);
  var TaxBaseKind = STB_GetTaxBaseKindByDocKind(DocKind, IIS, OperDate);
  var FindTaxBaseKind = TaxBaseKind;
  var StartProgressScaleDate = GetStartProgressScaleDate();

  if((РАБОТА_В_РЕЖИМЕ_СНОБ() == true) and (ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ() == true) and (StartProgressScaleDate > date(0,0,0)) and (OperDate >= StartProgressScaleDate))
    if((TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_BROK) or (TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS))
      FindTaxBaseKind = string(NPTXTOTALBASE_TAXBASEKIND_BROK) + ", " + string(NPTXTOTALBASE_TAXBASEKIND_IIS);
    end;
  elif((IIS != true) and (РАБОТА_В_РЕЖИМЕ_СНОБ() == true))
    if((ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ() == true) and (StartProgressScaleDate > date(0,0,0)) and (OperDate >= StartProgressScaleDate))
      FindTaxBaseKind = TaxBaseKind;
    else
      FindTaxBaseKind = string(NPTXTOTALBASE_TAXBASEKIND_BROK) + ", " + string(NPTXTOTALBASE_TAXBASEKIND_ONB);
    end;
  end;

  _AmountSNOB = $0;
  ErrStr = "";

  if(CalcOnlyBySOFR == NULL)
    CalcOnlyBySOFR = false;
  end;

  datesplit(OperDate, null, null, Year);

  if((CalcOnlyBySOFR == false) and (РАБОТА_С_ВНЕШНИМ_ХРАНИЛИЩЕМ_СНОБ()))
     ///<1.   Формируем и отправляем запрос СНОБ по клиенту (без истории), год = год даты операции
     
     var Request = c_GetAmountSNOBRequest();

     Request.GetAmountSNOBReq = c_GetAmountSNOBReq();
     Request.GetAmountSNOBReq.IsActivRecord      = true;
     Request.GetAmountSNOBReq.IsSNOB             = true;
     Request.GetAmountSNOBReq.ClientId           = c_IntegrationSymbolicIdentifierXType();
     Request.GetAmountSNOBReq.ClientId.ObjectID  = ClientID;
     Request.GetAmountSNOBReq.TaxYear            = Year;

     if((IIS == true) or (РАБОТА_В_РЕЖИМЕ_СНОБ() == false) or ((ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ() == true) and (StartProgressScaleDate > date(0,0,0)) and (OperDate >= StartProgressScaleDate)))
       if( LL_FindLLVALUES(OBJTYPE_STB_TAXBASEKIND, TaxBaseKind, llv) == true )
         Request.GetAmountSNOBReq.TaxBaseType = c_IntegrationDictionaryRecordXType();    ///<Вид налоговой базы по НДФЛ, к которой относится событие        Необязательное
         Request.GetAmountSNOBReq.TaxBaseType.RecordCode = llv.rec.Flag;
       end;
     end;

     var Resp = GetAmountSNOBReq(Request);

     var isOk = true;
     if((Resp == NULL) or (ValType(Resp) != V_GENOBJ) or (ValType(Resp.GetAmount) == V_UNDEF) or
        ((Resp.ErrorList != NULL) and (Resp.ErrorList.size > 0) and (IsError(string(trim(Resp.ErrorList[0].ErrorCode))) == true))
       )
       isOk = false;
     end;

     if(isOk)
       ///2. Если ответило, запоминаем СНОБ
       GetSystDateTime(@SystDate, @SystTime);
       AmountSNOB = Resp.GetAmount.AmountSNOB;
     else
       /**3. Если от хранилища не пришел ответ на запрос за время, установленное настройкой "Время ответа от Хранилища СНОБ (сек)", 
             рассчитываем сумму СНОБ как сумму СНОБ, полученную от хранилища с максимальной датой получения + суммы НОБ по более поздним записям из таблицы, 
             в которых не заполнено поле "Полученная сумма СНОБ").  
             Запоминаем рассчитанный СНОБ, дата и время получения - нулевые.
       */ 
       if((РАБОТА_В_РЕЖИМЕ_СНОБ() == true) and (ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ() == true) and (StartProgressScaleDate > date(0,0,0)) and (OperDate >= StartProgressScaleDate))
         AmountSNOB = STB_GetAmountSNOBbyTB(ClientID, FindTaxBaseKind, Year);
       else
         AmountSNOB = STB_GetAmountSNOBbyTB(ClientID, NULL, Year);
       end;
     end;
  else
    /**1.  Определяем  сумму СНОБ как значение поля "Сумма СНОБ c учетом текущей выплаты" с наиболее поздней датой получения дохода, 
           относящейся к тому же году, что и год даты операции. */
    if((РАБОТА_В_РЕЖИМЕ_СНОБ() == true) and (ПРОГРЕССИВНАЯ_ШКАЛА_ДЛЯ_НДФЛ() == true) and (StartProgressScaleDate > date(0,0,0)) and (OperDate >= StartProgressScaleDate))
      AmountSNOB = STB_GetAmountSNOBbyTB(ClientID, FindTaxBaseKind, Year);
    else
      AmountSNOB = STB_GetAmountSNOBbyTB(ClientID, NULL, Year);
    end;

  end;

  if(not err)
    ///запоминаем СНОБ, дату и время получения
    if(DL_InsertNPTXVAL(DocKind, DocID, NPTXVAL_KIND_STB, SystDate, SystTime, AmountSNOB, 0) != 0)
      ErrStr = "Ошибка при сохранении значения СНОБ";
      return 1;
    end;

    _AmountSNOB = AmountSNOB;
  end;

  return err;
end;

/**
  @brief Получить последнее сохраненное значение величины заданного вида для указанного объекта при работе со СНОБ
         По сути это обертка над GetLastOpSTBVal, чтобы получить только величину и её вернуть
  @param[in] DocKind  - integer Вид объекта/первичного документа. Это либо операция, в которой получали СНОБ от Хранилища, либо сама запись о событии СНОБ, для которой сохраняем полученную величину.
  @param[in] DocID    - integer Идентификатор объекта/первичного документа
  @param[in] Kind     - integer Вид величины
  @return NptxVal - money Сохраненна ранее величина
*/
macro STB_GetSavedNptxval(DocKind:integer, DocID:integer, Kind:integer, KBK:string, Rate:integer)
  var NptxVal = $0;

  GetLastOpSTBVal(DocKind, DocID, Kind, @NptxVal, NULL, NULL, KBK, Rate);

  return NptxVal;
end;

/**
  @brief Получить системный тип по операции по сделке. Локальная ф-ция
  @param[in] - integer Вид системной операции
  @return string - Строка символов - системных типов из переданного вида операции
*/
PRIVATE MACRO GetSysTypes(DealType)
var
   opr = TBfile("oprkoper");

   opr.rec.Kind_Operation = DealType;
   if(opr.GetEQ())
      return opr.rec.SysTypes;
   end;

   return "";
END;

/**
  @brief Заполнить дату и время дохода для создаваемого события СНОБ по операции
  @param[in] DocKind  - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] DocID    - integer Идентификатор объекта/первичного документа
  @param[in,out] STB  - TRecHandler Буфер записи о событии СНОБ по dnptxtotalbase_dbt
  @param[in] IncDate  - date (Необязательный) Дата получения дохода для занесения в событие СНОБ. Если передана, то она и записывается без всяких вычислений
  @param[in] IncTime  - time (Необязательный) Время получения дохода для занесения в событие СНОБ. Если передана, то оно и записывается без всяких вычислений 
*/
PRIVATE MACRO SetSTBDateTime(DocKind, DocID, STB, IncDate, IncTime)
  var query, cmd, DataSet;
  var StepTime = NULL;
  
  if((IncDate != NULL) and (IncTime != NULL))
    ///Если переданы дата и время получения дохода, то сразу их и заносим в событие СНОБ
    STB.rec.IncDate = IncDate;
    STB.rec.IncTime = IncTime;
  else
    query =   " select st.t_Syst_Time "
            + "   from doproper_dbt op, doprstep_dbt st "
            + "  where op.t_DocKind = ? "
            + "    and op.t_DocumentID = LPAD(?, 34, '0') "
            + "    and st.t_ID_Operation = op.t_ID_Operation"
            + "  order by st.t_ID_Step ASC";

    cmd = DL_RSDCommand(query);

    cmd.AddParam(DocKind);
    cmd.AddParam(DocID);

    DataSet = cmd.Execute();
    if(DataSet.moveNext())
      StepTime = time(DataSet.Syst_Time);
    end;

    if(DocKind == DL_VEKSELDRAWORDER)
      ///Если операция погашения/выкупа векселей, то дату и время дохода берем из документа-основания операции
      query =   " select t_RegistrDate, t_RegistrTime "
              + "   from dspground_dbt "
              + "  where t_SourceDocKind = ? "
              + "    and t_SourceDocID = ? ";

      cmd = DL_RSDCommand(query);

      cmd.AddParam(DocKind);
      cmd.AddParam(DocID);

      DataSet = cmd.Execute();
      if(DataSet.moveNext())
        STB.rec.IncDate = date(DataSet.RegistrDate);  ///<Дата получения дохода
        if(StepTime == NULL)
          STB.rec.IncTime = time(DataSet.RegistrTime);  ///<Время получения дохода
        else
          STB.rec.IncTime = StepTime;
        end;
      end;
    elif((DocKind == DL_CALCNDFL) or (DocKind == DL_WRTMONEY) or (DocKind == DL_HOLDNDFL) or (DocKind == DL_NPTXNETTOP))
      ///Для операций НДФЛ (расчет НОБ, списание д/с, удержание НДФЛ) дату и время берем из самой операции, т.е. записи dnptxop_dbt
      query =   " select t_OperDate, t_Time "
              + "   from dnptxop_dbt "
              + "  where t_ID = ? ";

      cmd = DL_RSDCommand(query);

      cmd.AddParam(DocID);

      DataSet = cmd.Execute();
      if(DataSet.moveNext())
        STB.rec.IncDate = date(DataSet.OperDate);  ///<Дата получения дохода
        if(StepTime == NULL)
          STB.rec.IncTime = time(DataSet.Time);    ///<Время получения дохода
        else
          STB.rec.IncTime = StepTime;
        end;
      end;
    end;
  end;

  STB.rec.IncRegionDate = STB.rec.IncDate;
  STB.rec.IncRegionTime = STB.rec.IncTime;
  
END;

/**
  @brief Получить для клиента числовое значение статуса налогоплательщика НДФЛ, которое определяем по категории "Является плательщиком НДФЛ" или по анкете субъекта, если категория на задана
  @param[in] ClientID - integer Идентификатор клиента
  @return TaxPayerStatus - Числовое значение статуса из категории "Является плательщиком НДФЛ"
  @return 1, если категория не задана, а в анкете субъекта не установлен признак нерезидента
  @return 2, если категория не задана, а в анкете субъекта установлен признак нерезидента
*/
macro STB_GetClientTaxPayerStatus(ClientID, dat)
  var TaxPayerStatus = 0;

  if(dat == NULL)
    dat = date(31,12,9999);
  end;

  var cmd = DL_RSDCommand("select RSI_NPTX.ResidenceStatus(?,?) RS from dual");
      cmd.AddParam(ClientID);
      cmd.AddParam(Date);
  var DataSet = cmd.execute();

  if(DataSet.moveNext())
    TaxPayerStatus = DataSet.RS;
  end;

  return TaxPayerStatus;
end;

/**
  @brief Заполнить описание для создаваемого события СНОБ по операции
  @param[in,out] STB      - TRecHandler Буфер записи о событии СНОБ по dnptxtotalbase_dbt
  @param[in] IIS          - bool Признак определения для ИИС
  @param[in] CheckDocKind - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] CheckDocID   - integer Идентификатор объекта/первичного документа
*/
private macro SetSTBDescription(STB, IIS, CheckDocKind, CheckDocID)
  var nptxop = TBFile("nptxop.dbt");
  var TaxPeriod = 0;
  var TaxTeriodToLucre = false;

  nptxop.Clear();

  //Описание события
  if(CheckDocKind == DL_CALCNDFL)
    STB.rec.Description  = "Расчет НОБ по окончанию года/закрытию договора";
    
    nptxop.rec.ID = CheckDocID;
    if(nptxop.GetEQ())
      if(nptxop.rec.SubKind_Operation == DL_TXBASECALC_OPTYPE_LUCRE)
        datesplit(nptxop.rec.OperDate, NULL, NULL, TaxPeriod);

        TaxTeriodToLucre = CheckTaxTeriodToLucre(TaxPeriod);
        
        if(TaxTeriodToLucre)
          STB.rec.Description  = "Мат. выгода";
        end;
      end;
    end;
  elif(CheckDocKind == DL_WRTMONEY)
    STB.rec.Description  = IIF(IIS == true, "Закрытие договора ИИС", "Вывод денежных средств");        
  elif(CheckDocKind == DL_HOLDNDFL)
    nptxop.rec.ID = CheckDocID;
    if(nptxop.GetEQ())
      STB.rec.Description = IIF(nptxop.rec.Subkind_Operation == DL_TXHOLD_OPTYPE_TAXREF, "Возврат излишне удержанного налога", "Удержание НДФЛ");
      if(nptxop.rec.SubKind_Operation == DL_TXHOLD_OPTYPE_LUCRE)

        datesplit(nptxop.rec.PrevDate, NULL, NULL, TaxPeriod);

        TaxTeriodToLucre = CheckTaxTeriodToLucre(TaxPeriod);
        
        if(TaxTeriodToLucre)
          STB.rec.Description = "Мат. выгода";
        end;
      end;
    end;
  elif(CheckDocKind == DL_VEKSELDRAWORDER)
    var order = TBFile("dl_order.dbt");
    var SysTypes = "";

    order.Clear();

    order.rec.ContractID = CheckDocID;
    if(order.GetEQ())
      SysTypes = GetSysTypes(order.rec.Kind_Operation);
      STB.rec.Description = "Получение дохода по векселям";
      if(Index(SysTypes, "В") > 0)
        STB.rec.Description = STB.rec.Description + " (выкуп)";
      else  
        STB.rec.Description = STB.rec.Description + " (погашение)";
      end;
    end;
  elif(CheckDocKind == DL_NPTXCRNSET)
    STB.rec.Description = "Получение дохода по компенсации";
  elif(CheckDocKind == DL_NPTXNETTOP)
    STB.rec.Description = "Урегулирование НДФЛ между КБК";
  end;
end;

/**
  @brief Заполнить поля для создаваемого события СНОБ по операции
  @param[in,out] STB           - TRecHandler Буфер записи о событии СНОБ по dnptxtotalbase_dbt
  @param[in] CheckDocKind      - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] CheckDocID        - integer Идентификатор объекта/первичного документа
  @param[in] ClientID          - integer Идентификатор клиента
  @param[in] IIS               - bool Признак заполнения для ИИС
  @param[in] Year              - integer Налоговый период (год)
  @param[in] НОБ               - money Налогооблагаемая база. Заносится в поле "НОБ по текущей выплате"
  @param[in] Ставка            - integer Ставка налога исчисленного и удержанного
  @param[in] Налог             - money Налог удержанный
  @param[in] IncDate           - date (Необязательный) Дата получения дохода. Если задана, то используется она
  @param[in] IncTime           - time (Необязательный) Время получения дохода. Если задано, то используется оно
  @param[in] AmountSNOB        - money (Необязательный) Примененная СНОБ без учета текущей выплаты. Если задана, то используется она
  @param[in] RecAmountSNOB     - money (Необязательный) Полученный от Хранилища СНОБ. Если задан, то используется он
  @param[in] RecAmountSNOBDate - date (Необязательный) Дата полученного от Хранилища СНОБ. Если задана, то используется она
  @param[in] RecAmountSNOBTime - time (Необязательный) Время поученного от Хранилища СНОБ. Если задано, то используется оно
  @param[in] OrigDocKind       - integer (Необязательный) Вид исходной операции, к которой относится событие СНОБ. Нужно для правильного опеределения описания при создании повторных записей во внутреннем пересчете
  @param[in] OrigDocID         - integer (Необязательный) Идентификатор исходной операции, к которой относится событие СНОБ. Нужно для правильного опеределения описания при создании повторных записей во внутреннем пересчете
  @param[in] TaxBaseKind       - integer (Необязательный) Вид налоговой базы. Например, при выполнении корректировки баланса вид НБ операции и корректируемого баланса может отличаться
  @param[in] Description       - string (Необязательный) Описание события. Можно передавать, если требуется нестандартное описание
  @param[in] DlContrID         - integer (Необязательный) № договора (только для ИИС)
  @param[in] SpecialTag        - string (Необязательный) Спец признак из "Виды спец признаков для НОБ = БРОК" LLVALUES 4163
  @param[in] SysCome           - integer (Необязательный) Система учета дохода 1 - СОФР, 2 - ДЕПО
*/
macro InitSTB(STB, DocKind, DocID, ClientID, IIS:bool, Year, НОБ, Ставка, НалогУдержанный, НалогИсчисленный, КБК, IncDate, IncTime, AmountSNOB, RecAmountSNOB, RecAmountSNOBDate, RecAmountSNOBTime, OrigDocKind, OrigDocID, TaxBaseKind, Description, Type, AddTaxCalc, Symbol, DlContrID, SpecialTag, SysCome)
  var ValDate = date(0,0,0), ValTime = time(0);
  var ДоходСуммарный = $0, НалогИсчСуммарный = $0;
  var CheckDocKind = DocKind;
  var CheckDocID   = DocID;
  var SystDate, SystTime;
  var nptxop = TBFile("nptxop.dbt");
  var query, cmd, DataSet;

  GetSystDateTime(@SystDate, @SystTime);

  if(OrigDocKind != NULL)
    CheckDocKind = OrigDocKind;
    CheckDocID   = OrigDocID;
  end;

  if(AddTaxCalc == NULL)
    AddTaxCalc = $0;
  end;

  if(Symbol == NULL)
    Symbol = UNSET_CHAR;
  end;
  
  STB.Clear();

  STB.rec.TBID          = 0;                                       ///<Идентификатор записи
  STB.rec.ClientID      = ClientID;                                ///<Идентификатор клиента ФЛ

  if(Type != NULL)
    STB.rec.Type = Type;
  else
    STB.rec.Type          = 1;  /*Выплата дохода*/                  ///<Тип события
    if(DocKind == DL_HOLDNDFL)
      STB.rec.Type        = 2;  /*Возврат/удержание НДФЛ*/
    end;
    if(DocKind == DL_NPTXNETTOP)
      STB.rec.Type        = 3;  /*Зачет переплаты НДФЛ*/
    end;
  end;

  if(Description != NULL)
    STB.rec.Description = Description;
  else
    SetSTBDescription(STB, IIS, CheckDocKind, CheckDocID);
  end;
  
  SetSTBDateTime(CheckDocKind, CheckDocID, STB, IncDate, IncTime);
  
  STB.rec.ConfirmState  = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Статус подтверждения записи в Хранилище
  STB.rec.SourceSystem  = 1;/*СОФР*/                               ///<СИ (система источник)
  STB.rec.StorState     = NPTXTOTALBASE_STORSTATE_ACTIVE;          ///<Статус записи в Хранилище
  STB.rec.DocKind       = DocKind;                                 ///<Вид первичного документа, породившего запись
  STB.rec.DocID         = DocID;                                   ///<Идентификатор документа, породившего запись
  STB.rec.TaxPeriod     = Year; //Налоговый период (год)

  STB.rec.Initial_DocKind = DocKind;
  if(OrigDocKind != NULL)
    STB.rec.Initial_DocKind = OrigDocKind;
  end;

  STB.rec.Initial_DocID = DocID;
  if(OrigDocID != NULL)
    STB.rec.Initial_DocID = OrigDocID;
  end;
  
  if(TaxBaseKind != NULL)
    STB.rec.TaxBaseKind   = TaxBaseKind;
  else
    STB.rec.TaxBaseKind   = STB_GetTaxBaseKindByDocKind(DocKind, IIS, IncDate); ///<Вид НОБ
  end;
  STB.rec.TaxBaseCurrPay= НОБ;                                     ///<НОБ по текущей выплате
  
  var FindTaxBaseKind = STB.rec.TaxBaseKind;

  if((STB.rec.TaxBaseKind != NPTXTOTALBASE_TAXBASEKIND_IIS) and (РАБОТА_В_РЕЖИМЕ_СНОБ() == true))
    FindTaxBaseKind = string(NPTXTOTALBASE_TAXBASEKIND_BROK) + ", " + string(NPTXTOTALBASE_TAXBASEKIND_ONB);
  end;

  if(НалогИсчисленный == NULL)
    if(DocKind != DL_HOLDNDFL)
      STB_GetSumTB(STB.rec.ClientID, FindTaxBaseKind, IIF(IIS == true, NULL, Year), Ставка, NULL, @ДоходСуммарный, @НалогИсчСуммарный);
    end;
    
    if(НОБ != 0)
      STB.rec.CalcPITax   = money(round(((НОБ+ДоходСуммарный)*Ставка/100 - НалогИсчСуммарный), 0)); ///<НДФЛ исчисленный
    end;
  else
    STB.rec.CalcPITax = НалогИсчисленный;
  end;
  STB.rec.CalcPITax = STB.rec.CalcPITax + AddTaxCalc; 

  STB.rec.RateCalcPITax = IIF(((DocKind == DL_HOLDNDFL) and (STB.rec.Type == 2)), 0, Ставка);  ///<Налоговая ставка НДФЛ исчисленный
  STB.rec.HoldPITax     = НалогУдержанный;                         ///<НДФЛ удержанный
  STB.rec.RateHoldPITax = Ставка;                                  ///<Налоговая ставка НДФЛ удержанный
  STB.rec.BCCCalcPITax  = IIF(((DocKind == DL_HOLDNDFL) and (STB.rec.Type == 2)), "", КБК);    ///<КБК исчисленного НДФЛ
  STB.rec.BCCHoldPITax  = КБК;                                     ///<КБК удержанного НДФЛ

  if((КБК == NULL) or (КБК == ""))
    if(Ставка == int(NPTXGENTAXRATE_RESIDENT_15*100))
      STB.rec.BCCHoldPITax = NPTXKBK_INCR_218;
      if((STB.rec.TaxPeriod <= 2024) or (STB.rec.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_ONB))
        STB.rec.BCCHoldPITax = NPTXKBK_INCR_208;
      end;

      if(STB.rec.BCCCalcPITax != "")
        STB.rec.BCCCalcPITax = STB.rec.BCCHoldPITax;
      end;
    end;
  else
    if((STB.rec.BCCHoldPITax == NPTXKBK_INCR_218) and (STB.rec.TaxPeriod <= 2024))
      STB.rec.BCCHoldPITax = NPTXKBK_INCR_208;
      STB.rec.BCCCalcPITax = STB.rec.BCCHoldPITax;
    end;
  end;

  STB.rec.TaxPayerStatus = STB_GetClientTaxPayerStatus(ClientID);
  
  if(AmountSNOB != NULL)
    STB.rec.ApplSTaxBaseExclude = AmountSNOB; ///<Применена СНОБ без учета текущей выплаты
    
    if(RecAmountSNOB == NULL)
      GetLastOpSTBVal(DocKind, DocID, NPTXVAL_KIND_STB, @STB.rec.RecSTaxBase, @ValDate, @ValTime);
    else
      STB.rec.RecSTaxBase = RecAmountSNOB; ///<Полученный СНОБ
    end;

    if(RecAmountSNOB == NULL)
      STB.rec.RecSTaxBaseDate  = ValDate;  ///<Дата получения СНОБ 
      STB.rec.RecSTaxBaseTime  = ValTime;  ///<Время получения СНОБ
    elif(RecAmountSNOBDate == NULL)
      GetSystDateTime(@STB.rec.RecSTaxBaseDate, @STB.rec.RecSTaxBaseTime);
    else
      STB.rec.RecSTaxBaseDate  = RecAmountSNOBDate;  ///<Дата получения СНОБ 
      STB.rec.RecSTaxBaseTime  = RecAmountSNOBTime;  ///<Время получения СНОБ
    end;
  else
    GetLastOpSTBVal(DocKind, DocID, NPTXVAL_KIND_STB, @STB.rec.ApplSTaxBaseExclude, @ValDate, @ValTime); ///<Применена СНОБ без учета текущей выплаты

    STB.rec.RecSTaxBase      = STB.rec.ApplSTaxBaseExclude; ///<Полученный СНОБ

    STB.rec.RecSTaxBaseDate  = ValDate;                     ///<Дата получения СНОБ
    STB.rec.RecSTaxBaseTime  = ValTime;                     ///<Время получения СНОБ
  end;

  if(РАБОТА_В_РЕЖИМЕ_СНОБ() == false)
    STB.rec.RecTaxBaseByKind = STB.rec.RecSTaxBase; ///<Полученный НОБ по виду дохода
  end;

  STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;  ///<Применена СНОБ с учетом НОБ текущей выплаты

  STB.rec.Symbol = Symbol;

  if( (DlContrID != NULL) and (STB.rec.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS))
    STB.rec.DlContrid = DlContrID;
  elif(STB.rec.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS)
    STB.rec.DlContrid = GetDlContrID(DocKind, DocID); //Если Тип НОБ = ИИС, то <№ договора> = № договора из операции, в рамках которой сформировалась запись
  else
    STB.rec.DlContrid = 0;
  end;
  
  if(SpecialTag != NULL)
    STB.rec.SpecialTag = SpecialTag;
  else
    STB.rec.SpecialTag = GetSpecialTag(STB);
  end;

  if((STB.rec.SpecialTag == "МАТ") and (DocKind == DL_CALCNDFL) )
    nptxop.Clear();

    nptxop.rec.ID = DocID;
    if(nptxop.GetEQ())
      if(nptxop.rec.Recalc == SET_CHAR)
        if((OrigDocKind == DL_CALCNDFL) and (OrigDocID != NULL))
          query =   " select 1 "
                  + "   from dnptxmes_dbt msg"
                  + "  where msg.t_DocID = ? "
                  + "    and msg.t_Type = 310 "
                  + "    and msg.t_Message = 'X' ";

          cmd = DL_RSDCommand(query);

          cmd.AddParam(OrigDocID);
          if(cmd.GetCount() > 0)
            SetSTBDateTime(DocKind, DocID, STB, STB.rec.IncDate, time(23,00,00));
          end;
        end;
      else
        if(STB.rec.IncDate != SystDate)
          SetSTBDateTime(DocKind, DocID, STB, STB.rec.IncDate, time(23,00,00));
          DL_NPTX_PutMsg("X", 310);
        end;
      end;
    end;
  end;
  
  if(SysCome != NULL)
    STB.rec.SysCome = SysCome;
  elif(index(STB.rec.Description, "Диасофт") != 0)
    STB.rec.SysCome = 2;  //<2> - если в описании события содержится слово <Диасофт>
  else
    STB.rec.SysCome = 1;
  end;
end;

/**
  @brief Заполнить поля для создаваемого события СНОБ по другому исходному событию СНОБ (как правило, отменяемому)
  @param[in,out] STB   - TRecHandler Буфер записи о событии СНОБ по dnptxtotalbase_dbt
  @param[in] MainSTB   - TRecHandler Исходная запись события СНОБ. Это может быть запись как по ставке 13% (30%), так и по 15%. С неё в определенном случае берем сохраненный полученных СНОБ
  @param[in] AddSTB    - TRecHandler (Необязательный, если задан MainSTB) Дополнительная исходная запись события СНОБ. Если она задана, то считаем её родительской. Как правило это запись по ставке 15%
  @param[in] nptxop    - TRecHandler Буфер операции, в которой выполняется инициализация
  @param[in] tbbuf     - TRecHandler Буфер записи из буферной таблицы dnptxtbbuf_dbt, если вызывается в операции пересчета 
  @param OnlyCopy[in]  - bool Признак необходимости сделать только копию без дополнительной инициализвации
*/
macro STB_InitSTBByFindSTB(STB, MainSTB, AddSTB, nptxop, tbbuf, OnlyCopy)
  var ValDate, ValTime;
  var AmountSNOB;
  
  if(AddSTB != NULL)
    copy(STB, AddSTB);
  else
    copy(STB, MainSTB);
  end;

  STB.rec.TBID           = 0;
  if(nptxop != NULL)
    STB.rec.DocKind      = nptxop.rec.DocKind;
    STB.rec.DocID        = nptxop.rec.ID;
  end;
  STB.rec.StorState      = NPTXTOTALBASE_STORSTATE_ACTIVE;
  STB.rec.ConfirmState   = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
  if(AddSTB != NULL)
    STB.rec.OrigTBID     = AddSTB.rec.TBID;
  else
    STB.rec.OrigTBID     = MainSTB.rec.TBID;
  end;
  STB.rec.StorID         = "";
  STB.rec.Instance       = 0;
  STB.rec.ID_Operation   = 0;
  STB.rec.ID_Step        = 0;
  STB.rec.IdentErrStr    = "";
  STB.rec.NeedRecalc     = "";

  if(OnlyCopy != true)
    if((tbbuf != NULL) and (tbbuf.rec.IsResidentChange == SET_CHAR))
      STB.rec.TaxPayerStatus = tbbuf.rec.TaxResidentFlag;
    end;

    if(tbbuf != NULL)
      if(РАБОТА_В_РЕЖИМЕ_СНОБ() == true)
        STB.rec.RecSTaxBase      = tbbuf.rec.AmountSNOB; ///<Полученный СНОБ
        STB.rec.RecTaxBaseByKind = $0; ///<Полученный НОБ по типу дохода
      else
        STB.rec.RecSTaxBase      = tbbuf.rec.NobTypeAmount; ///<Полученный СНОБ
        STB.rec.RecTaxBaseByKind = tbbuf.rec.NobTypeAmount; ///<Полученный НОБ по типу дохода
      end;

      STB.rec.RecSTaxBaseDate = tbbuf.rec.TimeStampRegDate;
      STB.rec.RecSTaxBaseTime = tbbuf.rec.TimeStampRegTime;

    elif(nptxop == NULL)
      GetLastOpSTBVal(DL_NPTXSTBOP, MainSTB.rec.TBID, NPTXVAL_KIND_STB, @AmountSNOB, @ValDate, @ValTime); ///<Применена СНОБ без учета текущей выплаты
      
      if(РАБОТА_В_РЕЖИМЕ_СНОБ() == true)
        STB.rec.RecSTaxBase      = AmountSNOB; ///<Полученный СНОБ
        STB.rec.RecTaxBaseByKind = $0; ///<Полученный НОБ по типу дохода
      else
        STB.rec.RecSTaxBase      = AmountSNOB; ///<Полученный СНОБ
        STB.rec.RecTaxBaseByKind = AmountSNOB; ///<Полученный НОБ по типу дохода
      end;

      ///Дата и время получения СНОБ
      STB.rec.RecSTaxBaseDate = ValDate;
      STB.rec.RecSTaxBaseTime = ValTime;
    end;

    STB.rec.ApplSTaxBaseExclude = STB.rec.RecSTaxBase;
  end;
end;

/**
  @brief Класс с налоговыми параметрами, по которым нужно содать записи СНОБ
*/
class STB_TaxRateParm(_Ставка:integer, _НОБ:money, _Налог:money, _КБК:string, _ВидНБ:integer, _ИИС:bool, _Тип:integer, _OrigTBID:integer, _TaxCalc:money, _AddTaxCalc:money, _Symbol:string, _SpecialTag:string)
  var Ставка      = _Ставка;
  var НОБ         = _НОБ;
  var Налог       = _Налог;
  var КБК         = _КБК;
  var ВидНБ       = _ВидНБ;
  var ИИС         = _ИИС;
  var Тип         = _Тип;
  var OrigTBID    = _OrigTBID;
  var TaxCalc     = _TaxCalc;
  var AddTaxCalc  = _AddTaxCalc;
  var Symbol      = _Symbol;
  var SpecialTag  = _SpecialTag;

  if(КБК == NULL)
    if(Ставка == int(NPTXGENTAXRATE_RESIDENT_15*100))
      КБК = NPTXKBK_INCR_218;
      if(ВидНБ == NPTXTOTALBASE_TAXBASEKIND_ONB)
        КБК = NPTXKBK_INCR_208;
      end;
    else
      КБК = NPTXKBK_MAIN;
      if(Ставка == int(NPTXGENTAXRATE_RESIDENT_18*100))
        КБК = NPTXKBK_INCR18;
      elif(Ставка == int(NPTXGENTAXRATE_RESIDENT_20*100))
        КБК = NPTXKBK_INCR20;
      elif(Ставка == int(NPTXGENTAXRATE_RESIDENT_22*100))
        КБК = NPTXKBK_INCR22;
      end;
    end;   
  end;

  if(_Symbol == NULL)
    Symbol = UNSET_CHAR;
  end;
end;

/**
  @brief Добавить буфер записи о событии СНОБ в массив путем копирования
  @param[in,out]  STBArr - TArray Массив записей
  @param[in]      STB    - TRecHandler Буфер записи о событии СНОБ
*/
macro AddSTBtoArr(STBArr, STB)
  var sz = STBArr.size;
  
  STBArr[sz] = TRecHandler("nptxtotalbase.dbt");
  copy(STBArr[sz], STB);
end;

/**
  @brief Проверить и сохранить запись о событии СНОБ
         Записи, не прошедшие проверку, пропускаются. Дл них сохранение не выполняется
  @param[in] STB     - TRecHandler Буфер записи о событии СНОБ
  @param[in] WasSkip - bool Признак того, что запись была пропущена, не сохранена
  @return 0 - в случае успеха
  @return integer код ошибки - в случае неудачи
*/
macro CheckAndSaveSTB(STB, WasSkip:@bool)

  WasSkip = false;

  ///Если создается новое событие и в нём не заполнена НОБ по текущей выплате, исчисленный и удержанный налог, то такую запись пропускаем, не создаем.
  if(    (STB.rec.TBID == 0)
     and (STB.rec.TaxBaseCurrPay == 0)
     and (STB.rec.CalcPITax == 0)
     and (STB.rec.HoldPITax == 0)
    )
    WasSkip = true;
    return 0;
  end;

  return DL_SaveSTB(STB);
end;

/**
  @brief Получить индекс записи о событии СНОБ в массиве событий СНОБ по переданному идентификатору события СНОБ
  @param[in,out] STBArr    - TArray Массив записей
  @param[in]     CheckTBID - integer Идентификатор записи о событии СНОБ
  @return -1, если запсиь не найдена в массиве
  @return индекс элемента в массиве
*/
private macro IndSTBInArr(STBArr, CheckTBID)
  var i = 0;

  while(i < STBArr.size)
    if(CheckTBID == STBArr[i].rec.TBID)
      return i;
    end;

    i = i + 1;
  end;

  return -1;
end;

/**
  @brief Проверить наличие записи по документу в массиве
  @param[in,out] STBArr    - TArray Массив записей
  @param[in]     DocID - integer Идентификатор операции
  @param[in]     DocKind - integer Вид операции
  @return -1, если запсиь не найдена в массиве
  @return индекс элемента в массиве
*/
private macro isDocInArr(STBArr, DocID, DocKind)
  var i = 0;

  while(i < STBArr.size)
    if((DocID == STBArr[i].rec.DocID) and (DocKind == STBArr[i].rec.DocKind))
      return true;
    end;

    i = i + 1;
  end;

  return false;
end;


/**
  @brief Выполнить сортировку записе в массиве событий СНОБ
  @param[in,out] STBArr - TArray Массив записей
*/
private macro SortSTBArr(STBArr)
  var i = 0;
  var STB = TRecHandler("nptxtotalbase.dbt");
  var needsort = true;

  while(needsort)
    needsort = false;
    i = 0;
    while(i < STBArr.size-1)
      ///Сортировку выполняем по дате получения дохода, времени получения дохоа, идентификатору исходного события
      if((STBArr[i].rec.IncDate > STBArr[i+1].rec.IncDate) or
         ((STBArr[i].rec.IncDate == STBArr[i+1].rec.IncDate) and (STBArr[i].rec.IncTime > STBArr[i+1].rec.IncTime)) or
         ((STBArr[i].rec.IncDate == STBArr[i+1].rec.IncDate) and (STBArr[i].rec.IncTime == STBArr[i+1].rec.IncTime) and (STBArr[i].rec.OrigTBID > STBArr[i+1].rec.OrigTBID))
        )
        copy(STB, STBArr[i+1]);
        copy(STBArr[i+1], STBArr[i]);
        copy(STBArr[i], STB);

        needsort = true;
      end;

      i = i + 1;
    end;
  end;

end;

/**
  @brief Получить вид и идентификатор исходной операции по событию СНОБ
  @param[in] STB - TRecHandler Буфер записи о событии СНОБ
  @param[out] DocKind - Вид исходной операции
  @param[out] DocID   - Идентификатор исходной операции
*/
private macro GetInitialDocSTB(STB, DocKind:@integer, DocID:@integer)
  var query, cmd, DataSet;

  ///По умолчанию считаем, что исходная операци как раз и указана в самом событии
  DocKind = STB.rec.DocKind;
  DocID   = STB.rec.DocID;  

  if(STB.rec.OrigTBID > 0)
    /**Если задано исходное событие, то ищем по нему с учетом того, что и оно могло иметь роителя и так далее 
       То есть тогда берем информацию об операции с самого исходного события, которое не имело родителя
    */
    query =   " select t_DocKind, t_DocID "
            + "   from dnptxtotalbase_dbt "
            + "  where t_OrigTBID = 0 "
            + "  start with t_TBID = ? "
            + " connect by t_OrigTBID = prior t_TBID";

    cmd = DL_RSDCommand(query);

    cmd.AddParam(STB.rec.OrigTBID);

    DataSet = cmd.Execute();

    if(DataSet.moveNext())
      DocKind = DataSet.DocKind;
      DocID   = DataSet.DocID;
    end;
  end;
end;

private macro IsNullTxArr(TxArr)
  var isnull = false;
  var i = 0;

  if(TxArr.size == 0)
    isnull = true;
  else
    isnull = true;

    i = 0;
    while(i < TxArr.size)
      if((TxArr[i].НОБ != 0) or (TxArr[i].Налог != 0))
        isnull = false;
        break;
      end;

      i = i + 1;
    end;

  end;

  return isnull;
end;

/**
  @brief Выполнить действия шага "Формирование записей в Хранилище". 
         Может вызываться вне шага, например, в начальном решении
  @param[in] TxArr             - STB_TaxRateParmr Массив элементов, по которому нужно создать события СНОБ
  @param[in] НОБ_опер          - money Параметр НОБ_опер, вычесленный для операции согласно ТЗ
  @param[in] DocKind           - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] DocID             - integer Идентификатор объекта/первичного документа
  @param[in] ClientID          - integer Идентификатор клиента
  @param[in] OperDate          - date Дата операции
  @param[in] IIS               - bool Признак заполнения для ИИС
  @param[in] Year              - integer Налоговый период (год)
  @param[in] ID_Operation      - integer Идентификатор системной операции. Может быть 0, если вызвана вне операции
  @param[in] ID_Step           - integer Идентификатор шага. Может быть 0, если вызвана вне операции
  @param[out] ErrStr           - string ВОзвращаемое сообщение об ошибке
  @param[in] IncDate           - date (Необязательный) Дата получения дохода. Если задана, то используется она
  @param[in] IncTime           - time (Необязательный) Время получения дохода. Если задано, то используется оно
  @param[in] AmountSNOB        - money (Необязательный) Примененная СНОБ без учета текущей выплаты. Если задана, то используется она
  @param[in] RecAmountSNOB     - money (Необязательный) Полученный от Хранилища СНОБ. Если задан, то используется он
  @param[in] RecAmountSNOBDate - date (Необязательный) Дата полученного от Хранилища СНОБ. Если задана, то используется она
  @param[in] RecAmountSNOBTime - time (Необязательный) Время поученного от Хранилища СНОБ. Если задано, то используется оно
  @param[in] OrigDocKind       - integer (Необязательный) Вид исходной операции, к которой относится событие СНОБ. Нужно для правильного опеределения описания при создании повторных записей во внутреннем пересчете
  @param[in] OrigDocID         - integer (Необязательный) Идентификатор исходной операции, к которой относится событие СНОБ. Нужно для правильного опеределения описания при создании повторных записей во внутреннем пересчете
  @param[in] TaxBaseKind       - integer (Необязательный) Вид налоговой базы. Например, при выполнении корректировки баланса вид НБ операции и корректируемого баланса может отличаться
  @param[in] Description       - string (Необязательный) Описание события. Можно передавать, если требуется нестандартное описание
  @param[in] _Type             - string (Необязательный) Тип события
  @param[in] DlContrID         - integer (Необязательный) № договора (только для ИИС)
  @param[in] SpecialTag        - string (Необязательный) Спец признак из "Виды спец признаков для НОБ = БРОК" LLVALUES 4163
  @param[in] SysCome           - integer (Необязательный) Система учета дохода 1 - СОФР, 2 - ДЕПО
  @return 0 в случае успеха
  @retrun err код ошибки в случае неудачи 
*/
macro STB_ExecuteCreateSTBOnStep(TxArr, НОБ_опер, DocKind, DocID, ClientID, OperDate, _IIS:bool, Year, ID_Operation, ID_Step, ErrStr:@string, IncDate, IncTime, AmountSNOB, RecAmountSNOB, RecAmountSNOBDate, RecAmountSNOBTime, OrigDocKind, OrigDocID, _TaxBaseKind, Description, _Type, DlContrID, _SpecialTag, SysCome)
  var Налог_30 = $0, Налог_13 = $0, Налог_15 = $0, taxe = $0, taxe15 = $0;
  var НОБ_отм = $0, НОБ_тек = $0, СуммНОБ_отм = $0;
  var STBArr = TArray();
  var CancelSTBArr = TArray();
  var STB = TRecHandler("nptxtotalbase.dbt");
  var FindSTB = TRecHandler("nptxtotalbase.dbt");
  var addFindSTB = TRecHandler("nptxtotalbase.dbt");
  var query, cmd, DataSet;
  var q, ds, select;
  var i = 0;
  var err = 0;
  var prevDocKind = 0, prevDocID = 0, prevIncDate = date(0,0,0), prevIncTime = time(0);
  var currDocKind = 0, currDocID = 0;
  var TaxBaseKind, IIS, Type, AddTaxCalc = $0, Symbol = UNSET_CHAR;
  var Sum = $0, newSum = $0;
  var BaseOld = $0, BaseCancel = $0;
  var HoldTax = $0;
  var ReCalcStatus = isReCalcStatus(ID_Operation);
  var SpecialTag = _SpecialTag;

  ErrStr = "";

  STBArr.size = 0;

  if((НОБ_опер < 0) and (IsNullTxArr(TxArr)) and (IsUseProgressScale(OperDate)) and (Year >= НП_ВВОДА_ДОРАБОТОК_BOSS_2981()))
    if(_IIS != NULL)
      IIS = _IIS;
      if(IIS and (ValType(DlContrID) != V_INTEGER))
        ErrStr = "Ошибка не задан договор ИИС";
        return 1;
      end;
    end;

    if(_TaxBaseKind != NULL)
      TaxBaseKind = _TaxBaseKind;
    elif(_TaxBaseKind == NULL)
      TaxBaseKind = STB_GetTaxBaseKindByDocKind(DocKind, IIS, OperDate);
    end;

    if(SpecialTag == NULL)
      if(TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_BROK)
        SpecialTag = "БРОК";
      else
        SpecialTag = "";
      end;
    end;

    ///Если НОБ уменьшилась, то нужно отменить существующие записи в порядке обратном их созданию, пока они не скомпенсируют изменение НОБ
    Sum = abs(НОБ_опер);
    
    query =   " select * "
            + "   from dnptxtotalbase_dbt "
            + "  where t_ClientID = ? "
            + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
            + "    and t_TaxBaseKind = ? "  
            + "    and t_TaxBaseCurrPay != 0 "
            + "    and t_TaxPeriod = ? "
            + IIF(IIS, " and t_DlContrID = ? ", " ") 
            + "    and t_SpecialTag = ? "
            + " order by t_RateHoldPITax DESC, t_IncDate DESC, t_IncTime DESC, t_TBID DESC"; ///<Первыми будут самые поздние записи

    cmd = DL_RSDCommand(query);

    cmd.AddParam(ClientID);
    cmd.AddParam(TaxBaseKind);
    cmd.AddParam(Year);
    if(IIS)
      cmd.AddParam(DlContrID);
    end;
    cmd.AddParam(SpecialTag);

    DataSet = cmd.Execute();

    var ErrSNOB = 0, DeltaSNOB = 0;;
    GetLastOpSTBVal(DocKind, DocID, NPTXVAL_KIND_STB, @ErrSNOB);
    while((Sum != 0) and (DataSet.moveNext()))
      DataSet.GetRecord().CopyTo(FindSTB.rec);
      
      BaseOld = FindSTB.rec.TaxBaseCurrPay;
      
      if(BaseOld < 0)
        BaseCancel = Sum;
      else
        BaseCancel = min(Sum, BaseOld);
      end;
    
      ///Отобранную запись в любом случае сразу же отменяем
      FindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
      FindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        ///<Отмененная

      AddSTBtoArr(CancelSTBArr, FindSTB);
      GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);

      if((BaseOld == BaseCancel) and (ReCalcStatus == false))
          ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, DataSet.RateHoldPITax, 0, 0, DataSet.BCCHoldPITax, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, DlContrID, SpecialTag, SysCome);

          STB.rec.Description    = FindSTB.rec.Description;
          STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
          STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
          STB.rec.IncDate        = FindSTB.rec.IncDate;      
          STB.rec.IncTime        = FindSTB.rec.IncTime;      
          STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
          STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;
          STB.rec.ApplSTaxBaseInclude = (FindSTB.rec.ApplSTaxBaseInclude - SUM + DeltaSNOB);
          STB.rec.ApplSTaxBaseExclude = (STB.rec.ApplSTaxBaseInclude + STB.rec.TaxBaseCurrPay);     

          AddSTBtoArr(STBArr, STB);
      else
        CalcTaxByRanges(FindSTB.rec.ClientID,
                        Year,
                        TaxBaseKind,
                        (BaseOld - BaseCancel),
                        IIF(ReCalcStatus, ErrSNOB,(FindSTB.rec.ApplSTaxBaseInclude - SUM - (BaseOld - BaseCancel))),
                        FindSTB.rec.IncDate,
                        SpecialTag
                       );
      
        var queryTax = " select * from dnptxtaxbaseranges_tmp where t_taxcalc <> 0 order by t_range asc ";
        var cmdTax = DL_RSDCommand(queryTax);
        var DataSetTax = cmdTax.Execute();
        while(DataSetTax.moveNext())
            
          if((FindSTB.rec.HoldPITax == 0) or ((int(DataSetTax.TaxRate) == FindSTB.rec.RateCalcPITax) and (DataSetTax.KBK == FindSTB.rec.BCCHoldPITax)))
            HoldTax = FindSTB.rec.HoldPITax;
          else
            HoldTax = 0;

            InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, DataSetTax.RateHoldPITax, 0, 0, DataSet.BCCHoldPITax, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, FindSTB.rec.DlContrID, FindSTB.rec.SpecialTag, FindSTB.rec.SysCome);

            STB.rec.Description    = FindSTB.rec.Description;
            STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
            STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
            STB.rec.IncDate        = FindSTB.rec.IncDate;      
            STB.rec.IncTime        = FindSTB.rec.IncTime;      
            STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
            STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;
            STB.rec.ApplSTaxBaseInclude = (FindSTB.rec.ApplSTaxBaseInclude - SUM);
            STB.rec.ApplSTaxBaseExclude = (FindSTB.rec.ApplSTaxBaseInclude - SUM);

            AddSTBtoArr(STBArr, STB);
          end;

          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, (BaseOld - BaseCancel), int(DataSetTax.TaxRate), 0, 0, DataSetTax.KBK, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, FindSTB.rec.DlContrID, FindSTB.rec.SpecialTag, FindSTB.rec.SysCome);


          STB.rec.Description    = FindSTB.rec.Description;
          STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
          STB.rec.HoldPITax      = HoldTax;
          STB.rec.IncDate        = FindSTB.rec.IncDate;     
          STB.rec.CalcPITax      = money(DataSetTax.TaxCalc);            
          STB.rec.IncTime        = FindSTB.rec.IncTime;      
          STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
          STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;
          STB.rec.ApplSTaxBaseExclude = IIF(ReCalcStatus, ErrSNOB, (FindSTB.rec.ApplSTaxBaseExclude + DeltaSNOB)); 
          STB.rec.ApplSTaxBaseInclude = (STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay);
          STB.rec.RateCalcPITax  = int(DataSetTax.TaxRate);

          AddSTBtoArr(STBArr, STB);
          
          if(ReCalcStatus)
            ReCalcStatus = false;
            DeltaSNOB = ErrSNOB - FindSTB.rec.ApplSTaxBaseExclude;
          end;
          
        end;
      end;
      Sum = Sum - BaseCancel;
    end;

    while(DataSet.EOF == false)
      DataSet.GetRecord().CopyTo(FindSTB.rec);
         
      if(isDocInArr(STBArr, FindSTB.rec.DocID, FindSTB.rec.DocKind)) 
        FindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
        FindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        ///<Отмененная
        AddSTBtoArr(CancelSTBArr, FindSTB);
          
        ///Новую запись создаем на основе записи из выборки
        STB_InitSTBByFindSTB(STB, FindSTB, NULL, NULL, NULL, true);

        STB.rec.DocKind = FindSTB.rec.DocKind;
        STB.rec.DocID   = FindSTB.rec.DocID;

        AddSTBtoArr(STBArr, STB);
      end;
        
      DataSet.moveNext()
    end;
  elif((НОБ_опер < 0) and (IsNullTxArr(TxArr)) and (IsUseProgressScale(OperDate)) and (Year < НП_ВВОДА_ДОРАБОТОК_BOSS_2981()))
    if(_TaxBaseKind != NULL)
      TaxBaseKind = _TaxBaseKind;
    elif(_TaxBaseKind == NULL)
      TaxBaseKind = STB_GetTaxBaseKindByDocKind(DocKind, IIS, OperDate);
    end;
    
    ///Если НОБ уменьшилась, то нужно отменить существующие записи в порядке обратном их созданию, пока они не скомпенсируют изменение НОБ
    Sum = abs(НОБ_опер);
     
    cmd = DL_RSDCommand();
     
    query =   " select * "
            + "   from dnptxtotalbase_dbt "
            + "  where t_ClientID = ? "
            + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
            + "    and t_TaxBaseKind = ? "  
            + "    and t_TaxBaseCurrPay != 0 "
            + "    and t_TaxPeriod = ? ";
    cmd.AddParam(ClientID);
    cmd.AddParam(TaxBaseKind);
    cmd.AddParam(Year);

    if(SpecialTag == "МАТ")
      query = query + " and t_SpecialTag = 'МАТ' ";
    else
      query = query + " and t_SpecialTag <> 'МАТ' ";
    end;

    query = query + " order by t_RateHoldPITax DESC, t_IncDate DESC, t_IncTime DESC, t_TBID DESC"; ///<Первыми будут самые поздние записи


    DataSet = cmd.Execute(query);
    while((Sum != 0) and (DataSet.moveNext()))
      DataSet.GetRecord().CopyTo(FindSTB.rec);
      
      НОБ_отм = FindSTB.rec.TaxBaseCurrPay;

      ///Отобранную запись в любом случае сразу же отменяем
      FindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
      FindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        ///<Отмененная

      AddSTBtoArr(CancelSTBArr, FindSTB);
      
      if(Sum > НОБ_отм) ///<Если остаток того значения, на которое уменьшилась общая НОБ, больше, чем в отменяемой записи НОБ по текущей выплате
        Sum = Sum - НОБ_отм;
        
        if(FindSTB.rec.HoldPITax != 0)
          ///Если в отмененной записи был удержанный налог, то создаем на её основе новую запись, но без НОБ, а только с удеранным налогом
          GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);
          ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, DataSet.RateHoldPITax, 0, NULL, DataSet.BCCHoldPITax, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, FindSTB.rec.DlContrID, FindSTB.rec.SpecialTag, FindSTB.rec.SysCome);

          STB.rec.Description    = FindSTB.rec.Description;
          STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
          STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
          STB.rec.IncDate        = FindSTB.rec.IncDate;      
          STB.rec.IncTime        = FindSTB.rec.IncTime;      
          STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
          STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;

          AddSTBtoArr(STBArr, STB);

        end;
      elif(Sum == НОБ_отм) ///<Если остаток того значения, на которое уменьшилась общая НОБ, равен НОБ по текущей выплате в отменяемой записи
        Sum = Sum - НОБ_отм;

        /** Мы отменили запись FindSTB и должны создать новую только с удержанным налогом из отмененной, если он есть
            Однако, если по той операции из отмененной записи есть другие записи в Хранилище (например, мы отменили запись по 15%, а есть ещё по 13%),
            то Хранилище их не учетет, когда будет проверять нашу запись при отправке, т.к. оно отбирается всегда только записи строго меньшие по дате и времени.
            Поэтому мы должны отменить и пересоздать все другие записи по той же выплате.
        */  

        select = DL_RSDCommand();

        q =   " select * "
            + "   from dnptxtotalbase_dbt "
            + "  where t_DocKind = ? "
            + "    and t_DocID = ? "
            + "    and t_TBID < ? "
            + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
            + "    and t_IncDate = ? "
            + "    and t_IncTime = ? ";

        select.AddParam(FindSTB.rec.DocKind);
        select.AddParam(FindSTB.rec.DocID);
        select.AddParam(FindSTB.rec.TBID);
        select.AddParam(FindSTB.rec.IncDate);
        select.AddParam(FindSTB.rec.IncTime);

        if(SpecialTag == "МАТ")
          q = q + " and t_SpecialTag = 'МАТ' ";
        else
          q = q + " and t_SpecialTag <> 'МАТ' ";
        end;

        ds = select.Execute(q);
        while(ds.moveNext())
          ds.GetRecord().CopyTo(addFindSTB.rec);

          /**Если запись уже есть в массиве отмененных записей, то её повторно не отменяем
             Такая ситуация может возникнуть в том случае, если НОБ уменьшилась настолько, что мы отменяем записи по 13% и 15% по одной выплате
             Тогда первой в цикле обработается запись по 13%, но изменения мы ещё не отразили в базе, поэтому при отменене записи по 15%
             эта запись по 13% попадет в выборку. Но по факту мы её уже отменили ранее и занесли в массив.
          */
          if(IndSTBInArr(CancelSTBArr, addFindSTB.rec.TBID) >= 0) 
            continue;
          end;

          addFindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
          addFindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        ///<Отмененная
          AddSTBtoArr(CancelSTBArr, addFindSTB);
          
          ///Новую запись создаем на основе записи из выборки
          STB_InitSTBByFindSTB(STB, addFindSTB, NULL, NULL, NULL, true);

          STB.rec.DocKind = DocKind;
          STB.rec.DocID   = DocID;

          AddSTBtoArr(STBArr, STB);
        end;
        
        if(FindSTB.rec.HoldPITax != 0)
          ///Если в отмененной записи был удержанный налог, то создаем на её основе новую запись, но без НОБ, а только с удеранным налогом
          GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);
          ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, DataSet.RateHoldPITax, 0, NULL, DataSet.BCCHoldPITax, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, FindSTB.rec.DlContrID, FindSTB.rec.SpecialTag, FindSTB.rec.SysCome);

          STB.rec.Description    = FindSTB.rec.Description;
          STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
          STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
          STB.rec.IncDate        = FindSTB.rec.IncDate;      
          STB.rec.IncTime        = FindSTB.rec.IncTime;      
          STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
          STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;

          AddSTBtoArr(STBArr, STB);
        end;

      elif(Sum < НОБ_отм) ///<Если остаток того значения, на которое уменьшилась общая НОБ, меньше НОБ по текущей выплате в отменяемой записи, то мы должны будем создать новую запись на разницу
        newSum = НОБ_отм - Sum; ///< Разница НОБ, на которую нужно создать новую запись
        
        /** Мы отменили запись FindSTB и должны создать новую только с удержанным налогом из отмененной, если он есть
            Однако, если по той операции из отмененной записи есть другие записи в Хранилище (например, мы отменили запись по 15%, а есть ещё по 13%),
            то Хранилище их не учетет, когда будет проверять нашу запись при отправке, т.к. оно отбирается всегда только записи строго меньшие по дате и времени.
            Поэтому мы должны отменить и пересоздать все другие записи по той же выплате.
        */
        select = DL_RSDCommand();

        q =   " select * "
            + "   from dnptxtotalbase_dbt "
            + "  where t_DocKind = ? "
            + "    and t_DocID = ? "
            + "    and t_TBID < ? "
            + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
            + "    and t_IncDate = ? "
            + "    and t_IncTime = ? ";

        select.AddParam(FindSTB.rec.DocKind);
        select.AddParam(FindSTB.rec.DocID);
        select.AddParam(FindSTB.rec.TBID);
        select.AddParam(FindSTB.rec.IncDate);
        select.AddParam(FindSTB.rec.IncTime);

        if(SpecialTag == "МАТ")
          q = q + " and t_SpecialTag = 'МАТ' ";
        else
          q = q + " and t_SpecialTag <> 'МАТ' ";
        end;

        ds = select.Execute(q);
        while(ds.moveNext())
          ds.GetRecord().CopyTo(addFindSTB.rec);

          /**Если запись уже есть в массиве отмененных записей, то её повторно не отменяем
             Такая ситуация может возникнуть в том случае, если НОБ уменьшилась настолько, что мы отменяем записи по 13% и 15% по одной выплате
             Тогда первой в цикле обработается запись по 13%, но изменения мы ещё не отразили в базе, поэтому при отменене записи по 15%
             эта запись по 13% попадет в выборку. Но по факту мы её уже отменили ранее и занесли в массив.
          */
          if(IndSTBInArr(CancelSTBArr, addFindSTB.rec.TBID) >= 0)
            continue;
          end;

          addFindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; //Не подтверждена
          addFindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        //Отмененная
          if(0 != CheckAndSaveSTB(addFindSTB))
            return 1;
          end;
          
          ///Новую запись создаем на основе записи из выборки
          STB_InitSTBByFindSTB(STB, addFindSTB, NULL, NULL, NULL, true);

          STB.rec.DocKind = DocKind;
          STB.rec.DocID   = DocID;   

          AddSTBtoArr(STBArr, STB);
        end;

        GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);
        ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
        InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, newSum, DataSet.RateHoldPITax, DataSet.HoldPITax, NULL, DataSet.BCCHoldPITax, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, FindSTB.rec.DlContrID, FindSTB.rec.SpecialTag, FindSTB.rec.SysCome);

        STB.rec.Description    = FindSTB.rec.Description;
        STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
        STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
        STB.rec.IncDate        = FindSTB.rec.IncDate;      
        STB.rec.IncTime        = FindSTB.rec.IncTime;      
        STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
        STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;

        AddSTBtoArr(STBArr, STB);

        Sum = 0;
      end;

    end;
  else
    while(i < TxArr.size)
    
      if(TxArr[i].ИИС != NULL)
        IIS = TxArr[i].ИИС;
      else
        IIS = _IIS;
      end;

      if(TxArr[i].ВидНБ != NULL)
        TaxBaseKind = TxArr[i].ВидНБ;
      elif(_TaxBaseKind != NULL)
        TaxBaseKind = _TaxBaseKind;
      elif(_TaxBaseKind == NULL)
        TaxBaseKind = STB_GetTaxBaseKindByDocKind(DocKind, IIS, OperDate);
      end;

      if(TxArr[i].Тип != NULL)
        Type = TxArr[i].Тип;
      else
        Type = _Type;
      end;

      AddTaxCalc = $0;
      if(TxArr[i].AddTaxCalc != NULL)
        AddTaxCalc = TxArr[i].AddTaxCalc;
      end;

      Symbol = UNSET_CHAR;
      if(TxArr[i].Symbol != NULL)
        Symbol = TxArr[i].Symbol;
      end;

      if(TxArr[i].SpecialTag != NULL)
        SpecialTag = TxArr[i].SpecialTag;
      else
        SpecialTag = _SpecialTag;
      end;

      if(НОБ_опер > 0)
        ///Если НОБ после выполнения данной операции увеличилась, то создаем новые записи по значениям из TxArr

        if(TxArr[i].НОБ != 0)
          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, TxArr[i].НОБ, TxArr[i].Ставка, TxArr[i].Налог, TxArr[i].TaxCalc, TxArr[i].КБК, IncDate, IncTime, AmountSNOB, RecAmountSNOB, RecAmountSNOBDate, RecAmountSNOBTime, OrigDocKind, OrigDocID, TaxBaseKind, Description, Type, AddTaxCalc, Symbol, DlContrID, SpecialTag, SysCome);

          AddSTBtoArr(STBArr, STB);
        elif((TxArr[i].НОБ == 0) and (TxArr[i].Налог != 0))
          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, TxArr[i].Ставка, TxArr[i].Налог, TxArr[i].TaxCalc, TxArr[i].КБК, IncDate, IncTime, AmountSNOB, RecAmountSNOB, RecAmountSNOBDate, RecAmountSNOBTime, OrigDocKind, OrigDocID, TaxBaseKind, Description, Type, AddTaxCalc, Symbol, DlContrID, SpecialTag, SysCome);

          AddSTBtoArr(STBArr, STB);
        end;

      elif(НОБ_опер < 0)
        ///Если НОБ уменьшилась, то нужно отменить существующие записи в порядке обратном их созданию, пока они не скомпенсируют изменение НОБ
        Sum = abs(TxArr[i].НОБ);
         
        cmd = DL_RSDCommand();
        
        query =   " select * "
                + "   from dnptxtotalbase_dbt "
                + "  where t_ClientID = ? "
                + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
                + "    and t_TaxBaseKind = ? "  
                + "    and t_TaxBaseCurrPay != 0 "
                + "    and t_TaxPeriod = ? "
                + "    and t_RateCalcPITax = ? ";

        cmd.AddParam(ClientID);
        cmd.AddParam(TaxBaseKind);
        cmd.AddParam(Year);
        cmd.AddParam(TxArr[i].Ставка);

        if(SpecialTag == "МАТ")
          query = query + " and t_SpecialTag = 'МАТ' ";
        else
          query = query + " and t_SpecialTag <> 'МАТ' ";
        end;

        query = query + " order by t_IncDate DESC, t_IncTime DESC, t_TBID DESC"; ///<Первыми будут самые поздние записи

        DataSet = cmd.Execute(query);
        while((Sum != 0) and (DataSet.moveNext()))
          DataSet.GetRecord().CopyTo(FindSTB.rec);
          
          НОБ_отм = FindSTB.rec.TaxBaseCurrPay;

          ///Отобранную запись в любом случае сразу же отменяем
          FindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
          FindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        ///<Отмененная

          AddSTBtoArr(CancelSTBArr, FindSTB);
          
          if(Sum > НОБ_отм) ///<Если остаток того значения, на которое уменьшилась общая НОБ, больше, чем в отменяемой записи НОБ по текущей выплате
            Sum = Sum - НОБ_отм;
            
            if(FindSTB.rec.HoldPITax != 0)
              ///Если в отмененной записи был удержанный налог, то создаем на её основе новую запись, но без НОБ, а только с удеранным налогом
              GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);
              ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
              InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, TxArr[i].Ставка, 0, NULL, TxArr[i].КБК, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, DlContrID, SpecialTag, SysCome);

              STB.rec.Description    = FindSTB.rec.Description;
              STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
              STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
              STB.rec.IncDate        = FindSTB.rec.IncDate;      
              STB.rec.IncTime        = FindSTB.rec.IncTime;      
              STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
              STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;

              AddSTBtoArr(STBArr, STB);

            end;
          elif(Sum == НОБ_отм) ///<Если остаток того значения, на которое уменьшилась общая НОБ, равен НОБ по текущей выплате в отменяемой записи
            Sum = Sum - НОБ_отм;

            /** Мы отменили запись FindSTB и должны создать новую только с удержанным налогом из отмененной, если он есть
                Однако, если по той операции из отмененной записи есть другие записи в Хранилище (например, мы отменили запись по 15%, а есть ещё по 13%),
                то Хранилище их не учетет, когда будет проверять нашу запись при отправке, т.к. оно отбирается всегда только записи строго меньшие по дате и времени.
                Поэтому мы должны отменить и пересоздать все другие записи по той же выплате.
            */  

            select = DL_RSDCommand();

            q =   " select * "
                + "   from dnptxtotalbase_dbt "
                + "  where t_DocKind = ? "
                + "    and t_DocID = ? "
                + "    and t_TBID < ? "
                + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
                + "    and t_IncDate = ? "
                + "    and t_IncTime = ? ";

            select.AddParam(FindSTB.rec.DocKind);
            select.AddParam(FindSTB.rec.DocID);
            select.AddParam(FindSTB.rec.TBID);
            select.AddParam(FindSTB.rec.IncDate);
            select.AddParam(FindSTB.rec.IncTime);

            if(SpecialTag == "МАТ")
              q = q + " and t_SpecialTag = 'МАТ' ";
            else
              q = q + " and t_SpecialTag <> 'МАТ' ";
            end;

            ds = select.Execute(q);
            while(ds.moveNext())
              ds.GetRecord().CopyTo(addFindSTB.rec);

              /**Если запись уже есть в массиве отмененных записей, то её повторно не отменяем
                 Такая ситуация может возникнуть в том случае, если НОБ уменьшилась настолько, что мы отменяем записи по 13% и 15% по одной выплате
                 Тогда первой в цикле обработается запись по 13%, но изменения мы ещё не отразили в базе, поэтому при отменене записи по 15%
                 эта запись по 13% попадет в выборку. Но по факту мы её уже отменили ранее и занесли в массив.
              */
              if(IndSTBInArr(CancelSTBArr, addFindSTB.rec.TBID) >= 0) 
                continue;
              end;

              addFindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; ///<Не подтверждена
              addFindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        ///<Отмененная
              AddSTBtoArr(CancelSTBArr, addFindSTB);
              
              ///Новую запись создаем на основе записи из выборки
              STB_InitSTBByFindSTB(STB, addFindSTB, NULL, NULL, NULL, true);

              STB.rec.DocKind = DocKind;
              STB.rec.DocID   = DocID;

              AddSTBtoArr(STBArr, STB);
            end;
            
            if(FindSTB.rec.HoldPITax != 0)
              ///Если в отмененной записи был удержанный налог, то создаем на её основе новую запись, но без НОБ, а только с удеранным налогом
              GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);
              ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
              InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, TxArr[i].Ставка, 0, NULL, TxArr[i].КБК, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, DlContrID, SpecialTag, SysCome);

              STB.rec.Description    = FindSTB.rec.Description;
              STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
              STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
              STB.rec.IncDate        = FindSTB.rec.IncDate;      
              STB.rec.IncTime        = FindSTB.rec.IncTime;      
              STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
              STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;

              AddSTBtoArr(STBArr, STB);
            end;

          elif(Sum < НОБ_отм) ///<Если остаток того значения, на которое уменьшилась общая НОБ, меньше НОБ по текущей выплате в отменяемой записи, то мы должны будем создать новую запись на разницу
            newSum = НОБ_отм - Sum; ///< Разница НОБ, на которую нужно создать новую запись
            
            /** Мы отменили запись FindSTB и должны создать новую только с удержанным налогом из отмененной, если он есть
                Однако, если по той операции из отмененной записи есть другие записи в Хранилище (например, мы отменили запись по 15%, а есть ещё по 13%),
                то Хранилище их не учетет, когда будет проверять нашу запись при отправке, т.к. оно отбирается всегда только записи строго меньшие по дате и времени.
                Поэтому мы должны отменить и пересоздать все другие записи по той же выплате.
            */

            select = DL_RSDCommand();

            q =   " select * "
                + "   from dnptxtotalbase_dbt "
                + "  where t_DocKind = ? "
                + "    and t_DocID = ? "
                + "    and t_TBID < ? "
                + "    and t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
                + "    and t_IncDate = ? "
                + "    and t_IncTime = ? ";

            select.AddParam(FindSTB.rec.DocKind);
            select.AddParam(FindSTB.rec.DocID);
            select.AddParam(FindSTB.rec.TBID);
            select.AddParam(FindSTB.rec.IncDate);
            select.AddParam(FindSTB.rec.IncTime);

            if(SpecialTag == "МАТ")
              q = q + " and t_SpecialTag = 'МАТ' ";
            else
              q = q + " and t_SpecialTag <> 'МАТ' ";
            end;

            ds = select.Execute(q);
            while(ds.moveNext())
              ds.GetRecord().CopyTo(addFindSTB.rec);

              /**Если запись уже есть в массиве отмененных записей, то её повторно не отменяем
                 Такая ситуация может возникнуть в том случае, если НОБ уменьшилась настолько, что мы отменяем записи по 13% и 15% по одной выплате
                 Тогда первой в цикле обработается запись по 13%, но изменения мы ещё не отразили в базе, поэтому при отменене записи по 15%
                 эта запись по 13% попадет в выборку. Но по факту мы её уже отменили ранее и занесли в массив.
              */
              if(IndSTBInArr(CancelSTBArr, addFindSTB.rec.TBID) >= 0)
                continue;
              end;

              addFindSTB.rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED; //Не подтверждена
              addFindSTB.rec.StorState    = NPTXTOTALBASE_STORSTATE_CANCELED;        //Отмененная
              if(0 != CheckAndSaveSTB(addFindSTB))
                return 1;
              end;
              
              ///Новую запись создаем на основе записи из выборки
              STB_InitSTBByFindSTB(STB, addFindSTB, NULL, NULL, NULL, true);

              STB.rec.DocKind = DocKind;
              STB.rec.DocID   = DocID;   

              AddSTBtoArr(STBArr, STB);
            end;

            GetInitialDocSTB(FindSTB, @currDocKind, @currDocID);
            ///Новая запись привязывается к текущей операции, но описания в неё должны быть заполнены по исходной операции найденной и отменной записи
            InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, newSum, TxArr[i].Ставка, newSum * TxArr[i].Ставка / 100, NULL, TxArr[i].КБК, FindSTB.rec.IncDate, FindSTB.rec.IncTime, FindSTB.rec.ApplSTaxBaseExclude, FindSTB.rec.RecSTaxBase, FindSTB.rec.RecSTaxBaseDate, FindSTB.rec.RecSTaxBaseTime, currDocKind, currDocID, TaxBaseKind, Description, Type, NULL, NULL, DlContrID, SpecialTag, SysCome);

            STB.rec.Description    = FindSTB.rec.Description;
            STB.rec.OrigTBID       = FindSTB.rec.TBID; ///<Отменнная запись будет родительской для новой записи
            STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
            STB.rec.IncDate        = FindSTB.rec.IncDate;      
            STB.rec.IncTime        = FindSTB.rec.IncTime;      
            STB.rec.IncRegionDate  = FindSTB.rec.IncRegionDate;
            STB.rec.IncRegionTime  = FindSTB.rec.IncRegionTime;

            AddSTBtoArr(STBArr, STB);

            Sum = 0;
          end;

        end;

        ///<Для каждого ненулевого значения Налог_13/Налог_15/Налог_30 дополнительно формируем запись
        if((DocKind == DL_WRTMONEY) or (OrigDocKind == DL_WRTMONEY))
          if((TxArr[i].Налог != 0))
            InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, TxArr[i].Ставка, TxArr[i].Налог, TxArr[i].TaxCalc, TxArr[i].КБК, IncDate, IncTime, AmountSNOB, RecAmountSNOB, RecAmountSNOBDate, RecAmountSNOBTime, OrigDocKind, OrigDocID, TaxBaseKind, Description, Type, NULL, NULL, DlContrID, SpecialTag, SysCome);

            AddSTBtoArr(STBArr, STB);
          end;
        end;
      elif(НОБ_опер == 0)
        if((TxArr[i].Налог != 0))
          InitSTB(STB, DocKind, DocID, ClientID, IIS, Year, 0, TxArr[i].Ставка, TxArr[i].Налог, TxArr[i].TaxCalc, TxArr[i].КБК, IncDate, IncTime, AmountSNOB, RecAmountSNOB, RecAmountSNOBDate, RecAmountSNOBTime, OrigDocKind, OrigDocID, TaxBaseKind, Description, Type, NULL, Symbol, DlContrID, SpecialTag, SysCome);

          if(TxArr[i].OrigTBID != NULL)
            STB.rec.OrigTBID = TxArr[i].OrigTBID;
          end;

          AddSTBtoArr(STBArr, STB);
        end;
      end;

      i = i + 1;
    end;
  end;
  ///Сначала сохраняем все записи, подлежащие отмене
  i = 0;
  var CancelSum = $0;
  while(i < CancelSTBArr.size)
    if(0 != CheckAndSaveSTB(CancelSTBArr[i]))
      ErrStr = "Ошибка при обновлении события СНОБ";
      return 1;
    end;

    CancelSum = CancelSum + CancelSTBArr[i].rec.TaxBaseCurrPay;

    i = i + 1;
  end;

  /** Далее создаем все новые записи
      Предварительно выполняем сортировку, чтобы записи создавались по дате и времени дохода
      Также выполняем вычисление полей со СНОБ, включающих и не включающих текущую выплату
  */
  i = 0;
  SortSTBArr(STBArr);
  var GetAmountSNOB = $0;
  var AddPay = $0;
  while(i < STBArr.size)
    var isActual = false;

    if(CancelSum > 0)
      //Определим, сколько отменили до этой даты и времени
      var j = 0;
      var CurrCancel = $0;
      while(j < CancelSTBArr.size)
        if((CancelSTBArr[j].rec.IncDate < STBArr[i].rec.IncDate) or ((CancelSTBArr[j].rec.IncDate == STBArr[i].rec.IncDate) and (CancelSTBArr[j].rec.IncTime <= STBArr[i].rec.IncTime)))
          CurrCancel = CurrCancel + CancelSTBArr[j].rec.TaxBaseCurrPay;
        end;

        j = j + 1;
      end;

      //Определим СНОБ по последней записи на дату и время. Тут попадет и отмененная запись, которая в базе ещё не отменена
      GetAmountSNOB = STB_GetAmountSNOBbyTB(ClientID, NULL, Year, STBArr[i].rec.IncDate, STBArr[i].rec.IncTime);

      GetAmountSNOB = GetAmountSNOB - CurrCancel;
    end;

    GetInitialDocSTB(STBArr[i], @currDocKind, @currDocID);
    
    if(((currDocKind == DL_HOLDNDFL) and (STBArr[i].rec.Type == 2)) or (currDocKind == DL_NPTXNETTOP))
      STBArr[i].rec.ApplSTaxBaseExclude = 0;
    end;

    if(((prevDocKind != currDocKind) or (prevDocID != currDocID) or ((prevIncDate != STBArr[i].rec.IncDate) and (prevIncTime != STBArr[i].rec.IncTime))))
      if((CancelSum > 0) and ((DocKind == DL_CALCNDFL) or (DocKind == DL_WRTMONEY)) and (STBArr[i].rec.TaxBaseCurrPay == 0) and (STBArr[i].rec.CalcPITax == 0) and (STBArr[i].rec.HoldPITax != 0))
        STBArr[i].rec.RecSTaxBase = STBArr[i].rec.RecTaxBaseByKind = STBArr[i].rec.ApplSTaxBaseExclude = STBArr[i].rec.ApplSTaxBaseInclude = GetAmountSNOB + AddPay; 
        isActual = true;
      elif((i == 0) and ((STBArr[i].rec.TaxBaseCurrPay == 0) and (STBArr[i].rec.CalcPITax == 0) and (STBArr[i].rec.HoldPITax != 0)))
        if(RecAmountSNOB != NULL)
          STBArr[i].rec.RecSTaxBase = STBArr[i].rec.RecTaxBaseByKind = STBArr[i].rec.ApplSTaxBaseExclude = STBArr[i].rec.ApplSTaxBaseInclude = RecAmountSNOB;
        else
          STBArr[i].rec.RecSTaxBase = STBArr[i].rec.RecTaxBaseByKind = STBArr[i].rec.ApplSTaxBaseExclude = STBArr[i].rec.ApplSTaxBaseInclude = STB_GetAmountSNOBbyTB(ClientID, NULL, Year, STBArr[i].rec.IncDate, STBArr[i].rec.IncTime);
        end;
      elif(i > 0)
        STBArr[i].rec.ApplSTaxBaseExclude = STBArr[i-1].rec.ApplSTaxBaseInclude;
      end;

      AddPay = AddPay + STBArr[i].rec.TaxBaseCurrPay;
    elif((i > 0) and ((prevDocKind == currDocKind) and (prevDocID == currDocID) and (prevIncDate == STBArr[i].rec.IncDate) and (prevIncTime == STBArr[i].rec.IncTime)))
      STBArr[i].rec.ApplSTaxBaseExclude = STBArr[i-1].rec.ApplSTaxBaseExclude;
      if(((DocKind == DL_CALCNDFL) or (DocKind == DL_WRTMONEY)) and (STBArr[i].rec.TaxBaseCurrPay == 0) and (STBArr[i].rec.CalcPITax == 0) and (STBArr[i].rec.HoldPITax != 0))
        STBArr[i].rec.RecSTaxBase         = STBArr[i-1].rec.RecSTaxBase;
        STBArr[i].rec.RecTaxBaseByKind    = STBArr[i-1].rec.RecTaxBaseByKind;
        STBArr[i].rec.ApplSTaxBaseInclude = STBArr[i-1].rec.ApplSTaxBaseInclude;
        isActual = true;
      end;
    end;

    if(isActual == false)
      if((prevDocKind == currDocKind) and (prevDocID == currDocID) and (prevIncDate == STBArr[i].rec.IncDate) and (prevIncTime == STBArr[i].rec.IncTime))
        STBArr[i].rec.ApplSTaxBaseInclude = STBArr[i-1].rec.ApplSTaxBaseInclude + STBArr[i].rec.TaxBaseCurrPay;
      else
        STBArr[i].rec.ApplSTaxBaseInclude = STBArr[i].rec.ApplSTaxBaseExclude + STBArr[i].rec.TaxBaseCurrPay;
      end;
    end;

    prevDocKind = currDocKind;
    prevDocID   = currDocID;
    prevIncDate = STBArr[i].rec.IncDate;
    prevIncTime = STBArr[i].rec.IncTime;
        
    if(0 != CheckAndSaveSTB(STBArr[i]))
      ErrStr = "Ошибка при обновлении события СНОБ";
      return 1;
    end;
    i = i + 1;
  end;

  return err;
end;

/**
  @brief Получить количество ошибочных ответов для операции
  @param ID_Opeation - integer Идентификатор системной операции
*/
private macro GetCountTbErrResp(ID_Operation)
  var query, cmd, DataSet;
  var cnt = 0;

  /**Здесь мы получаем количество ошибочных ответов не целиком по операции, а именно по последнему шагу отправки
     Ведь в одной операции мы можем отправлять несколько раз. Поэтому, лимит ошибочных ответов должен действовать на каждую отправку, а не на всю операцию
  */
  query =   " select count(1) as cnt "
          + "   from (select distinct m1.t_ID_Step "
          + "           from dnptxtbmes_dbt m1 "
          + "          where m1.t_ID_Operation = ? "
          + "            and m1.t_Type = 1 "
          + "            and m1.t_ID_Step >= (select NVL(MAX(m2.t_ID_Step), 0) "
          + "                                   from dnptxtbmes_dbt m2 "
          + "                                  where m2.t_ID_Operation = m1.t_ID_Operation "
          + "                                    and m2.t_Type = 2 "
          + "                                ) "
          + "        ) ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(ID_Operation);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    cnt = DataSet.cnt;
  end;

  return cnt;    
end;

/**
  @brief Заполнить по событию СНОБ информацию в запрос для Хранилища при отпрвке новых записей 
  @param STB - TRecHandler Буфер записи события СНОБ
  @return OpInfo - объект класса c_OperationInfo
*/
private macro GetOperationInfoBySTB(STB)
  var llv = TRecHandler("llvalues.dbt");
  var OpInfo = c_OperationInfo;

  OpInfo.EventDescription    = STB.rec.Description;                               ///< Описание события
  OpInfo.TaxYear             = STB.rec.TaxPeriod;                                 ///< Налоговый период, к которому относится событие (налоговый год)
  OpInfo.IncomeRegionDateTime= GetDatePlusTimeZone(STB.rec.IncRegionDate, STB.rec.IncRegionTime);///< Дата и время получения дохода (региональное время)
  OpInfo.IncomeDateTime      = dttm(STB.rec.IncDate, STB.rec.IncTime);            ///< Дата и время получения дохода (московское время)
  OpInfo.NOBAmount           = money(round(STB.rec.TaxBaseCurrPay, 2));           ///< Сумма НОБ по текущей выплате                                   Необязательное
  OpInfo.NDFLCalculateAmount = STB.rec.CalcPITax;                                 ///< Сумма исчисленного НДФЛ по выполненной операции                Необязательное
  OpInfo.NDFLTaxRate         = STB.rec.RateCalcPITax;                             ///< Налоговая ставка, примененная при исчислении НДФЛ              Необязательное
  OpInfo.NDFLKeepAmount      = STB.rec.HoldPITax;                                 ///< Сумма  НДФЛ удержанного по выполненной операции                Необязательное
  OpInfo.NDFLKeepRate        = STB.rec.RateHoldPITax;                             ///< Налоговая ставка удержанного НДФЛ по выплаченному доходу       Необязательное
  OpInfo.KBKCalculate        = STB.rec.BCCCalcPITax;                              ///< Код КБК для исчисленного к удержанию НДФЛ                      Необязательное
  OpInfo.KBKKeep             = STB.rec.BCCHoldPITax;                              ///< Код КБК удержанного НДФЛ
  OpInfo.SNOBPayAmount       = money(round(STB.rec.ApplSTaxBaseInclude, 2));      ///< Сумма СНОБ с учетом НОБ по текущей выплаты                     Необязательное
  OpInfo.SNOBAmount          = money(round(STB.rec.ApplSTaxBaseExclude, 2));      ///< Сумма СНОБ без учета НОБ по текущей выплате                    Необязательное
  
  OpInfo.ClientId = c_IntegrationSymbolicIdentifierXType();
  OpInfo.ClientId.ObjectId   = STB.rec.ClientID;                                  ///< ID клиента в системе-источнике
  
  if( LL_FindLLVALUES(OBJTYPE_STAXTYPE, STB.rec.Type, llv) == true )
    OpInfo.EventType = c_IntegrationDictionaryRecordXType();      ///< Тип события
    OpInfo.EventType.RecordCode = llv.rec.Code;
  end;

  OpInfo.EventId = c_IntegrationSymbolicIdentifierXType();      ///< ID события
  OpInfo.EventId.ObjectId    = STB.rec.TBID;
  
  OpInfo.RecordStatus = c_IntegrationDictionaryRecordXType();   ///< Статус записи
  OpInfo.RecordStatus.RecordCode = string(STB.rec.StorState);
  
  OpInfo.OperationId = c_IntegrationSymbolicIdentifierXType();  ///< ID операции
  OpInfo.OperationId.ObjectId = STB.rec.Initial_DocID;
  
  if( LL_FindLLVALUES(OBJTYPE_STB_TAXBASEKIND, STB.rec.TaxBaseKind, llv) == true )
    OpInfo.TaxBaseType = c_IntegrationDictionaryRecordXType();    ///< Вид налоговой базы по НДФЛ, к которой относится событие        Необязательное
    OpInfo.TaxBaseType.RecordCode = llv.rec.Flag;
  end;
  
  OpInfo.TaxPayerStatus = c_IntegrationDictionaryRecordXType(); ///< Статус налогоплательщика ФЛ                                    Необязательное
  OpInfo.TaxPayerStatus.RecordCode = string(STB.rec.TaxPayerStatus);

  return OpInfo;
end;

private macro IsFirstSendInOp(STB, ID_Operation)
  var query, cmd;

  query =   " select 1 "
          + "   from dnptxtotalbase_dbt tb "
          + "  where tb.t_ID_Operation = ? "
          + "    and tb.t_Initial_DocKind = ? "
          + "    and tb.t_Initial_DocID = ? "
          + "    and Exists(select 1 from dnptxtbmes_dbt tm where tm.t_TBID = tb.t_TBID and tm.t_ID_Operation = tb.t_ID_Operation and tm.t_Type = 2)";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(ID_Operation);
  cmd.AddParam(STB.rec.Initial_DocKind);
  cmd.AddParam(STB.rec.Initial_DocID);

  if(cmd.GetCount() > 0)
    return false;
  end;

  return true;
end;

/**
  @brief Выполнить действия шага "Отправка записей в Хранилище" по переданному массиву записей
  @param[in] STBArr            - TArray Массив записей событий СНОБ, которые необходимо отправить
  @param[in] DocKind           - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] DocID             - integer Идентификатор объекта/первичного документа
  @param[in] ID_Operation      - integer Идентификатор системной операции. Может быть 0, если вызвана вне операции
  @param[in] ID_Step           - integer Идентификатор шага. Может быть 0, если вызвана вне операции
  @param[out] NeedLoopStep     - bool Возвращаемый признак необходимости повтора шага отправки
  @param[out] ErrStr           - string Возвращаемое сообщение об ошибке
  @param[in] NotCancel         - bool Признак того, что не нужно отменять записи после неудачной отправки 
  @return 0 в случае успеха
  @retrun err код ошибки в случае неудачи 
*/
macro STB_ExecuteSendSTBArrToStorOnStep(STBArr, DocKind, DocID, ID_Operation, ID_Step, NeedLoopStep:@bool, ErrStr:@string, NotCancel:bool)
  var SystDate, SystTime;
  var ВремяОтвета = ВРЕМЯ_ОТВЕТА_ОТ_ХРАНИЛИЩА_СНОБ();
  var err = 0;
  var i = 0;
  var SendOpReq = NULL;
  var ChngReq = NULL;
  var SendOpResp = NULL, ChngResp = NULL;
  var ErrCode = "", ErrDesc = "";
  var ChngSTBArr = TArray();
  var TotalSendSTBArr = TArray();
  var firstDocKind = 0, firstDocID = 0;
  var currDocKind = 0, currDocID = 0;
  var ClientID = -1;

  NeedLoopStep = false;
  ErrStr = "";

  if(NotCancel == NULL)
    NotCancel = false;
  end;

  if(РАБОТА_С_ВНЕШНИМ_ХРАНИЛИЩЕМ_СНОБ() == false)
    return 0;
  end;

  if(STBArr.size == 0)
    return 0;
  end;

  /**Подготовим записи для передачи в Хранилище
     Разложим новые записи и записи с изменениями статуса (отменой) по разным массивам
  */
  i = 0;
  while(i < STBArr.size)

    if(STBArr[i].rec.StorID == "")
      AddSTBToArr(TotalSendSTBArr, STBArr[i]);

      if(IsFirstSendInOp(STBArr[i], ID_Operation))
        DL_NPTX_TbAddMsg(STBArr[i].rec.TBID, "", 2);
      end;
    else
      AddSTBToArr(ChngSTBArr, STBArr[i]);
    end;

    i = i + 1;
  end;

  ///Передаем в хранилище сначала изменение статуса сразу всех записей с изменившимся статусом
  if(ChngSTBArr.size > 0)
    GetSystDateTime(@SystDate, @SystTime);
    
    ChngReq = c_ChangeStatusSNOBRequest;

    ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList = TArray;
    
    i = 0;
    while(i < ChngSTBArr.size)
      var sz = ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList.size;
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz] = c_ChangeStatusInfo();
      
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordID = c_IntegrationSymbolicIdentifierXType();
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordID.ObjectID = ChngSTBArr[i].rec.StorID;
      
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordStatus = c_IntegrationDictionaryRecordXType();
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordStatus.RecordCode = string(ChngSTBArr[i].rec.StorState);

      DL_NPTX_TbAddMsg(ChngSTBArr[i].rec.TBID, "Передано изменение статуса в Хранилище СНОБ " + string(SystDate:f) + " " + string(SystTime:f));

      i = i + 1;
    end;

    
    if((ChngReq != NULL) and (ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList.size > 0))
      ChngResp = ChangeStatusSNOBReq(ChngReq); ///<Отправляем запрос в Хранилище

      ///Если в ответ прилши нулевые или пустые объъекты, то сохранем сообщения об ошибках для каждого события СНОБ
      if((ChngResp == NULL) or (ValType(ChngResp) != V_GENOBJ) or
         (ChngResp.ChangeStatusInfoList == NULL) or
         (ChngResp.ChangeStatusInfoList.size == 0)
        )
        i = 0;
        while(i < ChngSTBArr.size)
          if((ChngResp != NULL) and (ChngResp.ErrorList != NULL) and (ChngResp.ErrorList.size > 0)) ///<Если Хранилище прислало конкретную ошибку, то сохраняем её в протоколы событий СНОБ
            DL_NPTX_TbAddMsg(ChngSTBArr[i].rec.TBID, "Ошибка при обработке ответа от Хранилища СНОБ. Код ошибки: "+string(trim(ChngResp.ErrorList[0].ErrorCode))+" " + string(trim(ChngResp.ErrorList[0].ErrorDesc)));
          else ///< Иначе считаем, что Хранилище нам посто не ответило за отведенное время
            DL_NPTX_TbAddMsg(ChngSTBArr[i].rec.TBID, "Не получен ответ от Хранилища СНОБ в течение "+ВремяОтвета+" секунд");
          end;
          i = i + 1;
        end;

      end;

      ErrCode = "";
      if((ChngResp.ErrorList != NULL) and (ChngResp.ErrorList.size > 0)) ///<Если объекты всё же пришли, но также пришла ошибка, о запомним её
        ErrCode = string(trim(ChngResp.ErrorList[0].ErrorCode));
        ErrDesc = string(trim(ChngResp.ErrorList[0].ErrorDesc));
      end;
    end;

    if(IsError(ErrCode) == false) ///<Если ошибки не было, то у себя во все отправленные записи запишем, что они подтверждены
      i = 0;
      while(i < ChngSTBArr.size)
        ChngSTBArr[i].rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_CONFIRMED;
        
        if(0 != CheckAndSaveSTB(ChngSTBArr[i]))
          ErrStr = "Ошибка при обновлении события СНОБ";
          return 1;
        end;
        i = i + 1;
      end;
    end;
  end;

  ///Теперь будем пытаться отправить новые записи
  if((IsError(ErrCode) == false) and (TotalSendSTBArr.size > 0 ))
    var SendSTBArr = TArray();

    ///На всякий случай ассив сортируем по дате и времени получения дохода, чтобы в Хранилище отправилось всё последовательно
    SortSTBArr(TotalSendSTBArr);

    var k = 0;
    var start_k = 0;
    var CanRefresh = true;
    var Refresh = false;
    var GetAmountSNOB = NULL;
    var cnt_err = 0;
    while(((Refresh == true) or (IsError(ErrCode) == false)) and (k < TotalSendSTBArr.size))
      ///За одну итерацию будем отправлять только записи с одними и теми же датой и временем получения дохода
      Refresh  = false;
      CanRefresh = true; //Разрешаем повтор отправки для удержаний (НОб в записи равна 0) или записей по зачету кодов Диасофта

      SendSTBArr.size = 0;
      ClientID = TotalSendSTBArr[k].rec.ClientID;

      ///Сразу добавляем в массив первую запись из итерации
      AddSTBToArr(SendSTBArr, TotalSendSTBArr[k]);

      if(TotalSendSTBArr[k].rec.TaxBaseCurrPay != 0)
        if((index(TotalSendSTBArr[k].rec.Description, "Диасофт") == 0) or (index(TotalSendSTBArr[k].rec.Description, "(ID = ") == 0))
          CanRefresh = false;
        end;
      end;

      var firstIncDate     = TotalSendSTBArr[k].rec.IncDate;
      var firstIncTime     = TotalSendSTBArr[k].rec.IncTime;
      var firstTaxBaseKind = TotalSendSTBArr[k].rec.TaxBaseKind;

      start_k = k;
      
      k = k + 1;
      ///Мы массив сортировали, поэтому если далее идут записи (хотя наверняка одну будет только одна дополнительная) с такой же датой и временм, то добавим их
      while(k < TotalSendSTBArr.size)

        var currIncDate     = TotalSendSTBArr[k].rec.IncDate;
        var currIncTime     = TotalSendSTBArr[k].rec.IncTime;
        var currTaxBaseKind = TotalSendSTBArr[k].rec.TaxBaseKind;

        if((firstIncDate == currIncDate) and (firstIncTime == currIncTime) and (firstTaxBaseKind == currTaxBaseKind))
          AddSTBToArr(SendSTBArr, TotalSendSTBArr[k]);

          if(TotalSendSTBArr[k].rec.TaxBaseCurrPay != 0)
            if((index(TotalSendSTBArr[k].rec.Description, "Диасофт") == 0) or (index(TotalSendSTBArr[k].rec.Description, "(ID = ") == 0))
              CanRefresh = false;
            end;
          end;
        else
          ///Если дошли до записи, где другие дата и время, то цикл прерываем и переходим к отправке
          break;
        end;

        k = k + 1;
      end;

      //Если были записи только с удержанным налогом, но без НОБ, за сразу запросим актуальную СНОБ и занесем её в записи, так как там она может быть неактуальной. Чтобы не возникла ошибка "30" и потом не делать повторную отправку
      if(GetAmountSNOB != NULL)
        i = 0;
        while(i < SendSTBArr.size)
          SendSTBArr[i].rec.RecSTaxBase = SendSTBArr[i].rec.RecTaxBaseByKind = SendSTBArr[i].rec.ApplSTaxBaseExclude = GetAmountSNOB;
          SendSTBArr[i].rec.ApplSTaxBaseInclude = SendSTBArr[i].rec.ApplSTaxBaseExclude + SendSTBArr[i].rec.TaxBaseCurrPay;
          i = i + 1;
        end;
        GetAmountSNOB = NULL;
      end;

      ///Если есть записи для отправки, то отправляем
      if(SendSTBArr.size > 0)
        GetSystDateTime(@SystDate, @SystTime);

        ///Формируем запрос в Хранилище, добавляя в него записи к отправке
        SendOpReq = c_SendOperationRequest;

        SendOpReq.SendOperationResultReq.SystemCode = c_IntegrationDictionaryRecordXType();
        SendOpReq.SendOperationResultReq.SystemCode.RecordCode = "SOFR";

        SendOpReq.SendOperationResultReq.OperationInfoList = TArray;

        i = 0;
        while(i < SendSTBArr.size)
          SendOpReq.SendOperationResultReq.OperationInfoList[SendOpReq.SendOperationResultReq.OperationInfoList.size] = GetOperationInfoBySTB(SendSTBArr[i]);
          DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Передана в Хранилище СНОБ " + string(SystDate:f) + " " + string(SystTime:f));
          
          i = i + 1;
        end;

        SendOpResp = SendOperationResultReq(SendOpReq); ///<Непосредственно отправка в Хранилище

        ///Если в ответ прилши нулевые или пустые объъекты, то сохранем сообщения об ошибках для каждого события СНОБ
        if((SendOpResp == NULL) or (ValType(SendOpResp) != V_GENOBJ) or
           (SendOpResp.SendOperationResult == NULL) or 
           (SendOpResp.SendOperationResult.OperationInfoList == NULL) or
           (SendOpResp.SendOperationResult.OperationInfoList.size == 0)
          ) 
          i = 0;
          while(i < SendSTBArr.size)
            if((SendOpResp != NULL) and (SendOpResp.ErrorList != NULL) and (SendOpResp.ErrorList.size > 0)) ///<Если Хранилище прислало конкретную ошибку, то сохраняем её в протоколы событий СНОБ
              DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Ошибка при обработке ответа от Хранилища СНОБ. Код ошибки: "+string(trim(SendOpResp.ErrorList[0].ErrorCode))+" " + string(trim(SendOpResp.ErrorList[0].ErrorDesc)));
            else
              ///Если от хранилища не пришел ответ на запрос за время, установленное настройкой "Время ответа от Хранилища СНОБ (сек)"
              DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Не получен ответ от Хранилища СНОБ в течение "+ВремяОтвета+" секунд");
            end;
            i = i + 1;
          end;

        end;

        ErrCode = "";
        if((SendOpResp.ErrorList != NULL) and (SendOpResp.ErrorList.size > 0)) ///<Если объекты всё же пришли, но также пришла ошибка, о запомним её
          ErrCode = string(trim(SendOpResp.ErrorList[0].ErrorCode));
          ErrDesc = string(trim(SendOpResp.ErrorList[0].ErrorDesc));
        end;

        if(IsError(ErrCode) == false) ///<Если общей ошибки не было, то смотрим ошибки по событиям
          i = 0;
          ///Так как мы отправляли только события по одной выплате за одну дату и время, то наверняка по ним по всем будет одинаковая ошибка. Поэтмоу берем с первой ошибочной записи
          while(i < SendOpResp.SendOperationResult.OperationInfoList.size)
            ErrCode = SendOpResp.SendOperationResult.OperationInfoList[i].Error.ErrorCode;
            ErrDesc = SendOpResp.SendOperationResult.OperationInfoList[i].Error.ErrorDesc;

            if(IsError(ErrCode) == true)
              break;
            end;

            i = i + 1;
          end;
        end;

        if(IsError(ErrCode) == false) ///<Если никаких ошибок не было, то нужно отметить у себя подтвержение для событий СНОБ
          cnt_err = 0;

          i = 0;
          while(i < SendSTBArr.size)
            var isDublicate = false;
            
            //записям присваиваем Статус подтверждения записи в Хранилище  = подтверждена 
            //ID записи в хранилище = полученный в ответе от хранилища СНОБ ID созданной в нем записи
            SendSTBArr[i].rec.ConfirmState = NPTXTOTALBASE_CONFIRMSTATE_CONFIRMED;
            
            if(SendOpResp != NULL)
              var j = 0;
              while(j < SendOpResp.SendOperationResult.OperationInfoList.size)
                if(SendOpResp.SendOperationResult.OperationInfoList[j].EventID.ObjectID == SendSTBArr[i].rec.TBID)
                  if(SendOpResp.SendOperationResult.OperationInfoList[j].RecordID != NULL)
                    ///Заносим в наши события СНОБ идетификаторы, полученные от Хранилища
                    SendSTBArr[i].rec.StorID = string(SendOpResp.SendOperationResult.OperationInfoList[j].RecordID.ObjectID);
                  end;

                  if(    (SendOpResp.SendOperationResult.OperationInfoList[j].Error != NULL) 
                     and (SendOpResp.SendOperationResult.OperationInfoList[j].Error.ErrorCode == "000")
                    )
                    /**Ошибку 000 мы не считаем ошибкой, так как Хранилище принимает в этом случае записи успешно
                       Но себе в протокол по событиям СНОБ всё равно её сохраним
                    */
                    SendSTBArr[i].rec.IdentErrStr = SendOpResp.SendOperationResult.OperationInfoList[j].Error.ErrorDesc;
                    DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, SendOpResp.SendOperationResult.OperationInfoList[j].Error.ErrorDesc);
                  end;

                  if(    (SendOpResp.SendOperationResult.OperationInfoList[j].Error != NULL) 
                     and (SendOpResp.SendOperationResult.OperationInfoList[j].Error.ErrorCode == "20")
                      )
                    /**Если пришла ошибка 20, то есть в Хранилище уже есть такая запись, то запомним это.
                       Ошибкой не считаем
                    */
                      isDublicate = true;
                  end;

                  break;
                end;
                j = j + 1;
              end;
            end;

            if(0 != CheckAndSaveSTB(SendSTBArr[i]))
              ErrStr = "Ошибка при обновлении события СНОБ";
              return 1;
            end;

            GetSystDateTime(@SystDate, @SystTime);
            DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, IIF(isDublicate, "Дубликат записи. ", "")+"Запись подтверждена Хранилищем " + string(SystDate:f) + " " + string(SystTime:f));

            i = i + 1;
          end;
          
        elif(ErrCode == "30") ///<Если пришел отрицательный ответ и код ошибки 30
          var CountTbErrResp = GetCountTbErrResp(ID_Operation);
          var MaxCountTbErrResp = КОЛИЧЕСТВО_ОТВЕТОВ_С_ОШИБКАМИ_ОТ_ХРАНИЛИЩА_СНОБ();

          CountTbErrResp = CountTbErrResp + 1 + cnt_err;

          i = 0;
          while(i < SendSTBArr.size)
            ///Для всех отправленных событий в протокол добавляем сообщение об ошибке, полученной от Хранилища
            GetSystDateTime(@SystDate, @SystTime);
            DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Получен ошибочный ответ от Хранилища СНОБ. Код ошибки: "+ErrCode+" "+ErrDesc+". " + string(SystDate:f) + " " + string(SystTime:f), 1);

            if(CountTbErrResp == MaxCountTbErrResp)
              ///Если количество ошибочных ответов превысило допустимое, то заносим в протокол сообщение об этом
              DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Количество ошибочных ответов превысило " + MaxCountTbErrResp);
            end;
            i = i + 1;
          end;

          if((CountTbErrResp != MaxCountTbErrResp) and (SendOpResp != NULL)) ///< Если количество ошибочных ответов ещё не превысило допустимое
            if(CanRefresh)
              //Если разрешен повтор отправки, то сразу же повторим отправку, записав в них акутальную СНОБ
              if(ValType(SendOpResp.SendOperationResult.OperationInfoList[0].AmountSNOB) != V_UNDEF)
                Refresh = true;
                GetAmountSNOB = money(SendOpResp.SendOperationResult.OperationInfoList[0].AmountSNOB);
                k = start_k;
                cnt_err = cnt_err + 1;
              end;
            else
              ///<Запоминаем переданную от Хранилища актуальную сумму СНОБ, дату и время получения. Значение запоминается для операции
              GetSystDateTime(@SystDate, @SystTime);
              if(ValType(SendOpResp.SendOperationResult.OperationInfoList[0].AmountSNOB) != V_UNDEF)
                if(DL_InsertNPTXVAL(DocKind, DocID, NPTXVAL_KIND_STB, SystDate, SystTime, money(SendOpResp.SendOperationResult.OperationInfoList[0].AmountSNOB), 0) != 0)
                  ErrStr = "Ошибка при обновлении события СНОБ";
                  return 1;
                end;
              end;
              
              ///Также запоминаем переданную СНОБ по каждому событию
              if((ValType(SendOpResp.SendOperationResult.OperationInfoList) != V_UNDEF) and (SendOpResp.SendOperationResult.OperationInfoList.size > 0))
                i = 0;
                while(i < SendOpResp.SendOperationResult.OperationInfoList.size)
                  if(ValType(SendOpResp.SendOperationResult.OperationInfoList[i].AmountSNOB) != V_UNDEF)
                    if(DL_InsertNPTXVAL(DL_NPTXSTBOP, int(SendOpResp.SendOperationResult.OperationInfoList[i].EventID.ObjectID), NPTXVAL_KIND_STB, SystDate, SystTime, money(SendOpResp.SendOperationResult.OperationInfoList[i].AmountSNOB), 0) != 0)
                      ErrStr = "Ошибка при обновлении события СНОБ";
                      return 1;
                    end;
                  end;

                  i = i + 1;
                end;
              end;

              if(NotCancel == false) ///<Если нам не запретили специальным признаком, то нужно отменить некоторые записи
                i = 0;
                while(i < SendSTBArr.size)
                  ///Отменяем неподтвержденные активные записи записи
                  if((SendSTBArr[i].rec.StorState == NPTXTOTALBASE_STORSTATE_ACTIVE) and (SendSTBArr[i].rec.ConfirmState == NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED) and (SendSTBArr[i].rec.StorID == ""))
                    SendSTBArr[i].rec.StorState = NPTXTOTALBASE_STORSTATE_CANCELED;

                    if(0 != CheckAndSaveSTB(SendSTBArr[i]))
                      ErrStr = "Ошибка при обновлении события СНОБ";
                      return 1;
                    end;
                  end;

                  i = i + 1;
                end;
              end;
            end;

            ///Взводим признак необходимости повторения шага
            if(Refresh == false)
              NeedLoopStep = true;
            end;
          end;
        elif(ErrCode == "10") ///<Если пришел отрицательный ответ и код ошибки равен 10
          i = 0;
          ///Для каждого события СНОБ в протокол запонимаем ошибку
          while(i < SendSTBArr.size)
            GetSystDateTime(@SystDate, @SystTime);
            DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Ошибка записи данных в Хранилище СНОБ. Дата операции превышает текущую дату. Код ошибки: "+ErrCode+" "+ErrDesc+". " + string(SystDate:f) + " " + string(SystTime:f), 1);
            i = i + 1;
          end;

          msgbox("Выполнение операции в будущей дате запрещено");

          //return 0; ///<Работу шага прекращаем, ошибку не возвращаем
        elif((ErrCode != "") and (ErrCode != "30")) ///<Если пришел отрицательный ответ и код ошибки не равен 30
          i = 0;
          ///Для каждого события СНОБ в протокол запонимаем ошибку
          while(i < SendSTBArr.size)
            GetSystDateTime(@SystDate, @SystTime);
            DL_NPTX_TbAddMsg(SendSTBArr[i].rec.TBID, "Получен ошибочный ответ от Хранилища СНОБ. Код ошибки: "+ErrCode+" "+ErrDesc+". " + string(SystDate:f) + " " + string(SystTime:f), 1);
            i = i + 1;
          end;
        end;
      end;
    end;
  end;

  return err;
end;

/**
  @brief Выполнить действия шага "Отправка записей в Хранилище" для обработанных на шаге записей событий СНОБ
  @param[in] DocKind           - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] DocID             - integer Идентификатор объекта/первичного документа
  @param[in] ID_Operation      - integer Идентификатор системной операции. Может быть 0, если вызвана вне операции
  @param[in] ID_Step           - integer Идентификатор шага. Может быть 0, если вызвана вне операции
  @param[out] NeedLoopStep     - bool Возвращаемый признак необходимости повтора шага отправки
  @param[out] ErrStr           - string Возвращаемое сообщение об ошибке
  @param[in] CreatedOnStep_ID  - integer (Необязательный) Идентификатор шага, на котором были изменения записи. Если не задан, то отбираются все неподтвержденные записи, измененные/созданные в рамках данной операции (системной) на любом шаге
  @return 0 в случае успеха
  @retrun err код ошибки в случае неудачи 
*/
macro STB_ExecuteSendToStorOnStep(DocKind, DocID, ID_Operation, ID_Step, NeedLoopStep:@bool, ErrStr:@string, CreatedOnStep_ID, NotCancel:bool)
  var STB = TRecHandler("nptxtotalbase.dbt");
  var query, cmd, DataSet;
  var STBArr = TArray();
  var err = 0;

  NeedLoopStep = false;
  ErrStr = "";

  if(РАБОТА_С_ВНЕШНИМ_ХРАНИЛИЩЕМ_СНОБ() == false)
    return 0;
  end;
  
  ///Записи, созданные/измененные в данной операции (и на конкретном шаге, если он задан), в том числе записи, у которых изменился статус с активна на отменена, передаем в хранилище
  cmd = DL_RSDCommand();
  
  query =   " select * "
          + "   from dnptxtotalbase_dbt "
          + "  where t_ID_Operation = ? "
          + "    and t_ConfirmState = " + NPTXTOTALBASE_CONFIRMSTATE_NOTCONFIRMED
          + "    and not (t_StorState = " + NPTXTOTALBASE_STORSTATE_CANCELED + " and t_StorID = CHR(1)) ";

  cmd.AddParam(ID_Operation);

  if((CreatedOnStep_ID != NULL) and (CreatedOnStep_ID > 0))
    query = query + " and t_ID_Step = ? ";
    cmd.AddParam(CreatedOnStep_ID);
  end;

  query = query + " order by t_TBID ASC ";

  DataSet = cmd.execute(query);
  while(DataSet.moveNext())
    DataSet.GetRecord().CopyTo(STB.rec);
    ///Каждую отобранную запись заносим в массив
    AddSTBtoArr(STBArr, STB);
  end;

  ///Выполняем отправку по массиву записей общей ф-цией
  err = STB_ExecuteSendSTBArrToStorOnStep(STBArr, DocKind, DocID, ID_Operation, ID_Step, @NeedLoopStep, @ErrStr, NotCancel);

  return err;
end;


/**
  @brief Выполнить действия по откату для шага "Передача записи в хранилище"
  @param[in] DocKind           - integer Вид объекта/первичного документа. Как правило это первичный документ операции (не системной), для которой создается событие СНОБ
  @param[in] DocID             - integer Идентификатор объекта/первичного документа
  @param[in] ID_Operation      - integer Идентификатор системной операции. Может быть 0, если вызвана вне операции
  @param[in] ID_Step           - integer Идентификатор шага. Может быть 0, если вызвана вне операции
  @param[out] ErrStr           - string Возвращаемое сообщение об ошибке
  @return 0 в случае успеха
  @retrun err код ошибки в случае неудачи
*/
macro STB_RollbackSendToStorOnStep(DocKind, DocID, ID_Operation, ID_Step, ErrStr:@string)
  var STB = TRecHandler("nptxtotalbase.dbt");
  var query, cmd, DataSet;
  var SystDate, SystTime;
  var ВремяОтвета = ВРЕМЯ_ОТВЕТА_ОТ_ХРАНИЛИЩА_СНОБ();
  var err = 0;
  var i = 0;
  var Resp = NULL;
  var ErrCode = "", ErrDesc = "";
  var ChngReq = NULL;
  var SendOpReq = NULL;
  var SendOpResp = NULL;
  var RealStorID = "";
  var OldStorState = -1;
  var prevStepID = ID_Step;
  var TotalSendSTBArr = TArray();

  ErrStr = "";

  if(РАБОТА_С_ВНЕШНИМ_ХРАНИЛИЩЕМ_СНОБ() == false)
    return 0;
  end;

  /**Вся проблема и хитрость отката записей в Хранилище в том, что он всегда выполняет уже после отката у нас
     То есть всегда в PostStep шага
     Это означает, что у нас уже транзакция отката завершена, то есть в базе записи в том сосоянии, в котором они были до выполнения шага
     Это нужно учитывать, чтобы делать правильный откат в Хранилище

     Также у нас пока возможны такие ситуации с отправкой записи:
     1. Мы отменем/добавляем запись на одном шаге, а отправляем её на следующем. 
        Например, запись к моменту отправки уже отменена, а при отправке мы ставим ей статус Подтверждена
        Т.о. когда мы откатили шаг отправки, то мы уже убрали статус подтверждения и запись теперь не подтверждена. Но при этом она у нас отменена.
        Сейчас мы выплняем откат той отправки, а значит должны учесть и такие записи
     2. Запись отменена на шаге и сразу же отправлена.
        В этом случае сейчас к моменту отката она уже не отменена в нашей базе
  
     При откате шага в записи о событии СНОБ будет восстановлено состояние до выполнения шага. Это значит, что если запись при отправке получила идентификатор из Хранилища,
     то сейчас, когда уже у нас откат выполнен, в записи нет этого идентификатора. А Хранилище узнать ту или иную запись может только по своему идентификатору

     Поэтому, чтобы знать тот уже откаченный идентификатор, в момент отказа в ХП мы создали запись в dnptxtbmes_tmp с t_Type = 22,
     в которую в поле t_Message записали строку в формате
     откаченный_идентификатор_Хранилища;откаченный_статус 

     Ещё одна особенность отката - мы можем для него сделать только одну попытку, так как PostStep выполняется только один раз
     Если что-то пойдет не так (ошибка от Хранилища), то у нас уже записи удут восстановлены, а в Хранилище может оказаться другое состояние
  */


  ///Ищем предыдущий шаг
  query =   " select o.t_ID_Step "
          + "   from doprstep_dbt o "
          + "  where o.t_ID_Operation = ? "
          + "    and o.t_ID_Step = (select NVL(MAX(o1.t_ID_Step), 0) "
          + "                         from doprstep_dbt o1 "
          + "                        where o1.t_ID_Operation = o.t_ID_Operation "
          + "                          and o1.t_ID_Step < ? "
          + "                      ) ";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(ID_Operation);
  cmd.AddParam(ID_Step);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    prevStepID = DataSet.ID_Step;
  end;

  //Записям, созданным на предыдущем шаге, устанавливаем статусы и отправляем запросы
  query =   " select distinct stb.*, stm.t_Message "
          + "   from dnptxtotalbase_dbt stb, dnptxtbmes_tmp stm "
          + "  where stm.t_TBID = stb.t_TBID "
          + "    and stm.t_Type = 22 "
          + "    and stm.t_Message != CHR(1) "
          + " order by stb.t_TBID ASC ";

  cmd = DL_RSDCommand(query);

  DataSet = cmd.execute();
  while(DataSet.moveNext())
    ///Разбираем строку с вышеописанным форматом
    var arr = SplitString(DataSet.Message, ";");
    if(arr.size >= 2)
      RealStorID = arr[0];  ///< Запоминаем идентифкатор Хранилища, который получили при выполнении шага, и который мы уже у себя откатили
      OldStorState = int(arr[1]); ///< Запоминаем сьаьус, который установили при выполнении шага, и который мы уже у себя откатили
    end;
    
    if(((DataSet.StorState == NPTXTOTALBASE_STORSTATE_CANCELED) and (DataSet.ID_Operation == ID_Operation) and (DataSet.ID_Step == prevStepID)) or  ///<Если запись была отменена у нас на предыдущем шаге, а мы отправляли её в Хранилище на этом шаге
       ((OldStorState == NPTXTOTALBASE_STORSTATE_CANCELED) and (DataSet.StorState == NPTXTOTALBASE_STORSTATE_ACTIVE)) ///<Или мы отменяли и отправляли запись на этом шаге, а теперь она у нас уже снова активная
      )
      /**Хранилище не умеет восстанавливать ранее отмененные записи
         Но, к счастью, они умеют принимать одну и ту же запись несколько раз
         Поэтому отмененную запись отправим как новую со статусом Активна, но при этому у нас пока статус останется Отменена
         Если откатят и предыдущий шаг, то статус автоматически станет Активна и будет соответствовать Хранилищу
         Если наоборот, повторно выполнят отправку, то тогда мы отправим статус Отменена на эту запись и состояние будет соответствовать Хранилищу
      */

      DataSet.GetRecord().CopyTo(STB.rec);

      if(RealStorID != "")
        STB.rec.StorID       = "";
        STB.rec.StorState    = NPTXTOTALBASE_STORSTATE_ACTIVE;
        ///Добавляем запись в массив новых для последующей отправки
        AddSTBToArr(TotalSendSTBArr, STB);
      end;
    else 
      /**Иначе вариант, когда не было отмены при выполнении шага, а создавалась новая. 
         У нас такие записи сейчас не подтверждены после отката. Поэтому сейчас мы такие записи будем отменять в Хранилище
      */

      ///Создаем запрос на изменение записей и выполняем его наполнение
      if(ChngReq == NULL)
        ChngReq = c_ChangeStatusSNOBRequest;

        ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList = TArray;
      end;
      
      var sz = ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList.size;
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz] = c_ChangeStatusInfo();
      
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordID = c_IntegrationSymbolicIdentifierXType();
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordID.ObjectID = RealStorID;
      
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordStatus = c_IntegrationDictionaryRecordXType();
      ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordStatus.RecordCode = string(NPTXTOTALBASE_STORSTATE_CANCELED);
    end;
  end;

  if((ChngReq != NULL) and (ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList.size > 0))
    Resp = ChangeStatusSNOBReq(ChngReq); ///<Непосредственно отправка отменяемых записей

    ///Если Хранилище не прислало ответ или прислало ошибку, то выводим её на экран
    if((Resp == NULL) or (ValType(Resp) != V_GENOBJ) or
       (Resp.ChangeStatusInfoList == NULL) or
       (Resp.ChangeStatusInfoList.size == 0)
      )
      if((Resp != NULL) and (Resp.ErrorList != NULL) and (Resp.ErrorList.size > 0))
        msgbox("Ошибка при обработке ответа от Хранилища. Код ошибки: "+string(trim(Resp.ErrorList[0].ErrorCode))+" " + string(trim(Resp.ErrorList[0].ErrorDesc)));
      else
        msgbox("Не получен ответ на запрос по изменению статуса событий СНОБ");
      end;
    else
      ErrCode = "";
      if((Resp.ErrorList != NULL) and (Resp.ErrorList.size > 0))
        ErrCode = string(trim(Resp.ErrorList[0].ErrorCode));
        ErrDesc = string(trim(Resp.ErrorList[0].ErrorDesc));
      end;

      if(IsError(ErrCode) == true)
        msgbox("Получен ошибочный ответ от Хранилища. Код ошибки: "+ErrCode+ " "+ErrDesc);
      end;
    end;
  end; 

  if((IsError(ErrCode) == false) and (TotalSendSTBArr.size > 0 ))
    var SendSTBArr = TArray();
    ///Если есть записи для создания новых в Хранилище по нашим старым, то предварительно сортируем
    SortSTBArr(TotalSendSTBArr);

    var k = 0;
    ///За одну итерацию будем отправлять только записи с одними и теми жа датой и временем получения дохода
    while((IsError(ErrCode) == false) and (k < TotalSendSTBArr.size))
      SendSTBArr.size = 0;

      ///Сразу добавляем в массив первую запись из итерации
      AddSTBToArr(SendSTBArr, TotalSendSTBArr[k]);

      var firstIncDate = TotalSendSTBArr[k].rec.IncDate;
      var firstIncTime = TotalSendSTBArr[k].rec.IncTime;

      k = k + 1;
      ///Мы массив сортировали, поэтому если далее идут записи (хотя наверняка одну будет только одна дополнительная) с такой же датой и временм, то добавим их
      while(k < TotalSendSTBArr.size)

        var currIncDate = TotalSendSTBArr[k].rec.IncDate;
        var currIncTime = TotalSendSTBArr[k].rec.IncTime;
        
        if((firstIncDate == currIncDate) and (firstIncTime == currIncTime))
          AddSTBToArr(SendSTBArr, TotalSendSTBArr[k]);
        else
          ///Если дошли до записи, где другие дата и время, то цикл прерываем и переходим к отправке
          break;
        end;

        k = k + 1;
      end;

      if(SendSTBArr.size > 0)
        ///Формируем запрос в Хранилище, добавляя в него записи к отправке
        SendOpReq = c_SendOperationRequest;

        SendOpReq.SendOperationResultReq.SystemCode = c_IntegrationDictionaryRecordXType();
        SendOpReq.SendOperationResultReq.SystemCode.RecordCode = "SOFR";

        SendOpReq.SendOperationResultReq.OperationInfoList = TArray;
      
        i = 0;
        while(i < SendSTBArr.size)
          SendOpReq.SendOperationResultReq.OperationInfoList[SendOpReq.SendOperationResultReq.OperationInfoList.size] = GetOperationInfoBySTB(SendSTBArr[i]);
          i = i + 1;
        end;

        SendOpResp = SendOperationResultReq(SendOpReq); ///<Непосредственно отправка в Хранилище

        ///Если Хранилище не прислало ответ или прислало ошибку, то выводим её на экран
        if((SendOpResp == NULL) or (ValType(SendOpResp) != V_GENOBJ) or
           (SendOpResp.SendOperationResult == NULL) or 
           (SendOpResp.SendOperationResult.OperationInfoList == NULL) or
           (SendOpResp.SendOperationResult.OperationInfoList.size == 0)
          ) 

          if((SendOpResp != NULL) and (SendOpResp.ErrorList != NULL) and (SendOpResp.ErrorList.size > 0))
            msgbox("Ошибка при обработке ответа от Хранилища. Код ошибки: "+string(trim(SendOpResp.ErrorList[0].ErrorCode))+" " + string(trim(SendOpResp.ErrorList[0].ErrorDesc)));
          else
            msgbox("Не получен ответ на запрос по изменению статуса событий СНОБ");
          end;

        else
          ///Если отет есть, но общей ошибки нет, то смотрим ошибку на первой записи
          if((SendOpResp.ErrorList != NULL) and (SendOpResp.ErrorList.size > 0))
            ErrCode = string(trim(SendOpResp.ErrorList[0].ErrorCode));
            ErrDesc = string(trim(SendOpResp.ErrorList[0].ErrorDesc));
          end;

          ///Если никаких ошибок нет
          if(IsError(ErrCode) == false)
            ///Обновляем ID Хранилища для всех повторно отправленных записей, которые ранее были отменены
            i = 0;
            while(i < SendOpResp.SendOperationResult.OperationInfoList.size)
              if((SendOpResp.SendOperationResult.OperationInfoList[i].EventID != NULL) and (SendOpResp.SendOperationResult.OperationInfoList[i].EventID.ObjectID > 0))
                var exec, sql;
                var NewStorID = ""; 
                var TBID = int(SendOpResp.SendOperationResult.OperationInfoList[i].EventID.ObjectID);

                if(SendOpResp.SendOperationResult.OperationInfoList[i].RecordID != NULL)
                  NewStorID = string(SendOpResp.SendOperationResult.OperationInfoList[i].RecordID.ObjectID);
                end;

                if((SendOpResp.SendOperationResult.OperationInfoList[i].Error != NULL) and (IsError(SendOpResp.SendOperationResult.OperationInfoList[i].Error.ErrorCode)))
                  msgbox("Ошибка в ответе Хранилища для события с ID = "+TBID+": " + SendOpResp.SendOperationResult.OperationInfoList[i].Error.ErrorCode + " " + SendOpResp.SendOperationResult.OperationInfoList[i].Error.ErrorDesc);
                end;
                                                                                                                                                                                                        
                sql =   " UPDATE dnptxtotalbase_dbt "
                      + "    SET t_StorID = ? "
                      + "  WHERE t_TBID = ? ";
                
                exec = DL_RSDCommand(sql);

                exec.AddParam(NewStorID);
                exec.AddParam(TBID);

                exec.ExecuteCMD();

                ///Сразу же меняем и в истории, т.к. нам уже не нужен прежний StorID, ведь он уже отменен в Хранилище и восстановлению не подлежит
                sql =   " UPDATE dnptxtotalbasebc_dbt "
                      + "    SET t_StorID = ? "
                      + "  WHERE t_TBID = ? "
                      + "    AND t_StorID <> CHR(1) ";

                exec = DL_RSDCommand(sql);

                exec.AddParam(NewStorID);
                exec.AddParam(TBID);

                exec.ExecuteCMD();
              end;
              
              i = i + 1;
            end;
          else
            msgbox("Получен ошибочный ответ от Хранилища. Код ошибки: "+ErrCode+" "+ErrDesc);
          end;
        end;

      end;
    end;
  end;

  SQL_Execute("DELETE FROM DNPTXTBMES_TMP WHERE T_TYPE = 22", "", false );

  return err;
end;

/**
  @brief Отменить существующие необработанные записи в буферной таблице по идентификатору Хранилища
  @param[in] ClientID          - integer Идентификатор клиента
  @param[in] SNOBRecordID      - integer Идентификатор записи в Хранилище
*/
private macro CancelPrevTbBuf(ClientID:integer, SNOBRecordID:string)
  var upd;
  var CanclDate = date(0,0,0), CanclTime = time(0);

  GetSystDateTime(@CanclDate, @CanclTime);

  ///Всем подходящим записям ставим стотус Отменена и заносим дату и время отмены
  upd = DL_RSDCommand(  "UPDATE dnptxtbbuf_dbt "
                      + "   SET t_Status = " + NPTXTBBUF_STATUS_CANCELED + ", "
                      + "       t_TimeStampCanclDate = ?, "
                      + "       t_TimeStampCanclTime = ? "
                      + " WHERE t_ClientID = ? "
                      + "   AND t_SNOBRecordID = ? "
                      + "   AND t_Status = " + NPTXTBBUF_STATUS_NOTPROCESSED
                     );

  upd.AddParam(CanclDate);
  upd.AddParam(CanclTime);
  upd.AddParam(ClientID);
  upd.AddParam(SNOBRecordID);

  upd.ExecuteCMD();
end;

/**
  @brief Добавить запись в буферную таблицу СНОБ. 
         Вызывается из интеграционного сервиса по входящему запросу
  @param[in] p_Operation - объект с данными от Хранилища
  @param[in,out] p_out_obj - объект для занесения в него данных об ошибке, если она возникла
  @param[in] ReqID - string Идентификатор запроса от Хранилища
*/
macro STB_AddRecToTBBuf(p_Operation, p_out_obj, ReqID:string)
  var tbbuf = TRecHandler("nptxtbbuf.dbt");
  var tbbuf_ins = RsbSQLInsert("nptxtbbuf.dbt");
  var upd;

  ///Заполняем буфер записи буферной таблиц по переданным данных от Хранилища
  tbbuf.Clear();

  tbbuf.rec.ClientID         = int(p_Operation.ClientId.ObjectID);        
  tbbuf.rec.OperationID      = int(p_Operation.OperationId.ObjectID);     
  tbbuf.rec.SNOBRecordID     = string(p_Operation.SNOBRecordId.ObjectID);
  tbbuf.rec.EventID          = int(p_Operation.EventId.ObjectID);         
  tbbuf.rec.IsResidentChange = IIF(p_Operation.IsResidentChange == true, SET_CHAR, UNSET_CHAR);
  tbbuf.rec.TaxResidentFlag  = int(p_Operation.TaxResidentFlag); 
  tbbuf.rec.IsSNOBChange     = IIF(p_Operation.IsSNOBChange == true, SET_CHAR, UNSET_CHAR);    
  tbbuf.rec.NobTypeAmount    = money(p_Operation.NOBTypeAmount);
  tbbuf.rec.AmountSNOB       = money(p_Operation.AmountSNOB);
  tbbuf.rec.Status           = NPTXTBBUF_STATUS_NOTPROCESSED;

  GetSystDateTime(@tbbuf.rec.TimeStampRegDate, @tbbuf.rec.TimeStampRegTime);

  tbbuf.rec.ReqID = ReqID;

  ///Отменяем предыдущие необработанные записи в буферной таблице с таким же идентификатором Хранилища
  CancelPrevTbBuf(tbbuf.rec.ClientID, tbbuf.rec.SNOBRecordID);
  
  tbbuf_ins.AddRecord(tbbuf);
  if(not tbbuf_ins.Insert()) ///<Вставляем запись в базу
    p_out_obj.ErrorCode = 1;
    p_out_obj.ErrorDesc = "Ошибка при добавлении записи в буферную таблицу СНОБ";
  else
    ///Устанавливаем событию СНОБ признак необходимости пересчета
    upd = DL_RSDCommand("UPDATE dnptxtotalbase_dbt SET t_NeedRecalc = 'Да' WHERE t_TBID = ? AND t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE);
    upd.AddParam(tbbuf.rec.EventID);

    upd.ExecuteCMD();
  end;

OnError(er)
  p_out_obj.ErrorCode = er.Code;
  p_out_obj.ErrorDesc = er.Message;
end; 

/**
  @brief Проверка необходимости выполнять пересчет СНОБ по клиенту в налоговом периоде
  @param[in] ClientID   - integer Идентификатор клиента
  @param[in] TaxPeriod  - integer Налоговый период (год)
  @retrun true, если пересчет необходим
  @retrun false, если пересчет не требуется
*/
macro STB_ClientNeedRecalc(ClientID:integer, TaxPeriod:integer, TurnOff:bool)
  var query, cmd;
  var NeedRecalc = false;

  if(TurnOff == NULL)
    TurnOff = true;
  end;

  ///Если есть хотя бы одна необработанна запись в буерной таблице для указанного клиента в указанный налоговый период, то пересчет необходим
  query =   " select 1 "
          + "   from dnptxtbbuf_dbt tbbuf, dnptxtotalbase_dbt tb "
          + "  where tbbuf.t_Status = " + NPTXTBBUF_STATUS_NOTPROCESSED
          + "    and tbbuf.t_ClientID = ? "
          + "    and tb.t_StorID(+) = tbbuf.t_SNOBRecordID "
          + "    and tb.t_TaxPeriod = ? "
          + "    and ROWNUM = 1";

  cmd = DL_RSDCommand(query);
  
  cmd.AddParam(ClientID);
  cmd.AddParam(TaxPeriod);

  if(cmd.GetCount() > 0)
    NeedRecalc = true;
  end;

  return NeedRecalc;
end;

/**
  @brief Загрузить в буфер дополнительную запись по выплате, если она была вместе с переданной записью
  @param[in,out] addFindSTB - Буфер дополнительной записи события СНОБ, которую мы туда поместим, если найдем
  @param[in] FindSTB        - Буфер записи события СНОБ, по которому нужно искать дополнительную
*/
macro STB_LoadAddSTBArr(addFindSTBArr:@TArray, FindSTB)
  var query, cmd, DataSet;
  var addFindSTB = TRecHandler("nptxtotalbase.dbt");

  addFindSTBArr.size = 0;

  ///Ищем запси с такими же датой и временем дохода, как у переданной, но с другой ставкой
  query =   " select * "
          + "   from dnptxtotalbase_dbt "
          + "  where t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
          + "    and t_ClientID = ? "
          + "    and t_IncDate = ? "
          + "    and t_IncTime = ? "
          + "    and t_DocKind = ? "
          + "    and t_DocID = ? "
          + "    and t_RateCalcPITax <> ?"
          + "    and t_Type = ? "
          + "    and t_TaxBaseKind = ?";

  cmd = DL_RSDCommand(query);
  cmd.AddParam(FindSTB.rec.ClientID);
  cmd.AddParam(FindSTB.rec.IncDate);
  cmd.AddParam(FindSTB.rec.IncTime);
  cmd.AddParam(FindSTB.rec.DocKind);
  cmd.AddParam(FindSTB.rec.DocID);
  cmd.AddParam(FindSTB.rec.RateCalcPITax);
  cmd.AddParam(FindSTB.rec.Type);
  cmd.AddParam(FindSTB.rec.TaxBaseKind);

  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    DataSet.GetRecord().CopyTo(addFindSTB.rec);

    AddSTBtoArr(addFindSTBArr, addFindSTB);
  end;
end;

/**
  @brief Загрузить в буфер дополнительную запись по выплате, если она была вместе с переданной записью по КБК
  @param[in,out] addFindSTB - Буфер дополнительной записи события СНОБ, которую мы туда поместим, если найдем
  @param[in] FindSTB        - Буфер записи события СНОБ, по которому нужно искать дополнительную
  @param[in] KBK            - КБК, по которому нужно искать дополнительную
*/
macro STB_LoadAddSTBByKBK(addFindSTB, FindSTB, KBK)
  var query, cmd, DataSet;

  addFindSTB.Clear();

  query =   " select * "
          + "   from dnptxtotalbase_dbt "
          + "  where t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE
          + "    and t_ClientID = ? "
          + "    and t_IncDate = ? "
          + "    and t_IncTime = ? "
          + "    and t_DocKind = ? "
          + "    and t_DocID = ? "
          + "    and t_BCCCalcPITax = ? "
          + "    and t_Type = ? "
          + "    and t_TaxBaseKind = ?";

  cmd = DL_RSDCommand(query);
  cmd.AddParam(FindSTB.rec.ClientID);
  cmd.AddParam(FindSTB.rec.IncDate);
  cmd.AddParam(FindSTB.rec.IncTime);
  cmd.AddParam(FindSTB.rec.DocKind);
  cmd.AddParam(FindSTB.rec.DocID);
  cmd.AddParam(KBK);
  cmd.AddParam(FindSTB.rec.Type);
  cmd.AddParam(FindSTB.rec.TaxBaseKind);

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    DataSet.GetRecord().CopyTo(addFindSTB.rec);
    return true;
  end;
  
  return false;
end;

/**
  @brief Выполнить действия по пересчету при изменении СНОБ
  @param[in] FindSTB   - TRecHandler Исходная найденная запись события СНОБ, по которой выполняется пересчет
  @param[in] AddSTB    - TRecHandler Дополнительна найденная запись события СНОБ, по которой выполнется пересчет. Это будет запись по ставке 15% (если она существует), если в FindSTB запис по 13%
  @param[in] nptxop    - TRecHandler (Необязательный) Буфер операции пересчета, если вызов в ней
  @param[in] tbbuf     - TRecHandler (Необязательный) Буфер записи из буферной таблицы dnptxtbbuf_dbt, если вызов и операции пересчета 
  @param[out] ErrStr   - string Сообщение об ошибке, если она возникла
  @return 0 в случае успеха
  @return err код ошибк ив случае неудачи
*/
macro STB_RecalcByChangeSNOB(FindSTB, addFindSTB, nptxop, tbbuf, ErrStr:@string)
  var STB = TRecHandler("nptxtotalbase.dbt");
  var STB_2 = TRecHandler("nptxtotalbase.dbt");
  var pt = TBFile("party.dbt");
  var Доход_13 = $0;
  var Доход_15 = $0;
  var Доход_30 = $0;
  var err = 0;
  var ДоходСуммарный_13 = $0, НалогИсчСуммарный_13 = $0;
  var ДоходСуммарный_15 = $0, НалогИсчСуммарный_15 = $0;
  var ДоходСуммарный_30 = $0, НалогИсчСуммарный_30 = $0;
  var WasSkip = false;

  var FindTaxBaseKind = FindSTB.rec.TaxBaseKind;

  ErrStr = "";

  pt.Clear();
  pt.rec.PartyID = FindSTB.rec.ClientID;
  if(not pt.GetEQ())
    ErrStr = "Не найден субъект с идентификатором " + FindSTB.rec.ClientID;
    return 1;
  end;

  if((FindSTB.rec.TaxBaseKind != NPTXTOTALBASE_TAXBASEKIND_IIS) and (РАБОТА_В_РЕЖИМЕ_СНОБ() == true))
    FindTaxBaseKind = string(NPTXTOTALBASE_TAXBASEKIND_BROK) + ", " + string(NPTXTOTALBASE_TAXBASEKIND_ONB);
  end;

  ///Для каждой ставки получим имеющиеся сумма дохода и налога по таблице событий СНОБ
  STB_GetSumTB(FindSTB.rec.ClientID, FindTaxBaseKind, FindSTB.rec.TaxPeriod, int(NPTXGENTAXRATE_RESIDENT*100),    FindSTB.rec.TBID, @ДоходСуммарный_13, @НалогИсчСуммарный_13);
  STB_GetSumTB(FindSTB.rec.ClientID, FindTaxBaseKind, FindSTB.rec.TaxPeriod, int(NPTXGENTAXRATE_RESIDENT_15*100), FindSTB.rec.TBID, @ДоходСуммарный_15, @НалогИсчСуммарный_15);
  STB_GetSumTB(FindSTB.rec.ClientID, FindTaxBaseKind, FindSTB.rec.TaxPeriod, int(NPTXGENTAXRATE_NOTRESIDENT*100), FindSTB.rec.TBID, @ДоходСуммарный_30, @НалогИсчСуммарный_30);
  
  STB_InitSTBByFindSTB(STB, FindSTB, NULL, nptxop, tbbuf);

  ///Определяем доходы по ставкам для текущей выплаты
  if(STB_IsResidentStatus(STB.rec.TaxPayerStatus) == true)
    Доход_13 = max(0, min(STB.rec.RecSTaxBase + FindSTB.rec.TaxBaseCurrPay + addFindSTB.rec.TaxBaseCurrPay, NPTX_LIMINCOME_MAX15) - STB.rec.RecSTaxBase);
    Доход_15 = FindSTB.rec.TaxBaseCurrPay + addFindSTB.rec.TaxBaseCurrPay - Доход_13;
  else
    Доход_30 = FindSTB.rec.TaxBaseCurrPay + addFindSTB.rec.TaxBaseCurrPay;
  end;

  if(STB_IsResidentStatus(STB.rec.TaxPayerStatus) == false) ///< Для нерезидента
    if(STB.rec.RateCalcPITax == int(NPTXGENTAXRATE_NOTRESIDENT*100))
      STB.rec.TaxBaseCurrPay = Доход_30;
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_30+Доход_30)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_30, 0));
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;
    end;

    if(not err)
      /** Если по пересчета при смене СНОБ был пересчет при смене резидентства, то могла быть ещё дополнительная запись по ставке 15%
          Тогда ещё просто пересоздадим без какого-либо пересчета, ведь там только удержанный налог, который тут не может измениться
      */
      if(addFindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100))
        STB_InitSTBByFindSTB(STB_2, FindSTB, addFindSTB, nptxop, tbbuf);

        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;
    end;
  else ///<Для резидента

    if((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT*100)) and (addFindSTB.rec.TBID == 0) and (Доход_15 == 0)) ///<13 -> 13
      STB.rec.TaxBaseCurrPay = Доход_13;
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_13+Доход_13)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_13, 0));
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;
    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT*100)) and (addFindSTB.rec.TBID == 0) and (Доход_13 == 0) and (Доход_15 != 0)) ///<13 -> 15
      STB.rec.TaxBaseCurrPay = $0;
      STB.rec.CalcPITax      = $0;
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, NULL, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay = Доход_15;
        STB_2.rec.RateCalcPITax  = int(NPTXGENTAXRATE_RESIDENT_15*100);
        STB_2.rec.CalcPITax      = money(round((ДоходСуммарный_15+Доход_15)*STB_2.rec.RateCalcPITax/100 - НалогИсчСуммарный_15, 0));
        STB_2.rec.RateHoldPITax  = STB_2.rec.RateCalcPITax;
        STB_2.rec.BCCCalcPITax   = NPTXKBK_15; ///<КБК исчисленного НДФЛ
        STB_2.rec.BCCHoldPITax   = NPTXKBK_15; ///<КБК исчисленного НДФЛ
        STB_2.rec.HoldPITax      = $0;
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;
    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100)) and (addFindSTB.rec.TBID == 0) and (Доход_13 == 0)) ///<15 -> 15
      STB.rec.TaxBaseCurrPay = Доход_15;
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_15+Доход_15)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_15, 0));
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;
    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100)) and (addFindSTB.rec.TBID == 0) and (Доход_13 != 0) and (Доход_15 == 0)) ///<15 -> 13
      STB.rec.TaxBaseCurrPay = Доход_13;
      STB.rec.RateCalcPITax  = int(NPTXGENTAXRATE_RESIDENT*100);
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_13+Доход_13)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_13, 0));
      STB.rec.RateHoldPITax  = STB.rec.RateCalcPITax;
      STB.rec.BCCCalcPITax   = NPTXKBK_MAIN; ///<КБК исчисленного НДФЛ
      STB.rec.BCCHoldPITax   = NPTXKBK_MAIN; ///<КБК исчисленного НДФЛ
      STB.rec.HoldPITax      = $0;
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, NULL, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay = $0;
        STB_2.rec.CalcPITax      = $0;
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;

    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT*100)) and (addFindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100)) and (Доход_13 == 0) and (Доход_15 != 0)) ///<13,15 -> 15
      STB.rec.TaxBaseCurrPay = $0;
      STB.rec.CalcPITax      = $0;
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, addFindSTB, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay = Доход_15;
        STB_2.rec.CalcPITax      = money(round((ДоходСуммарный_15+Доход_15)*STB_2.rec.RateCalcPITax/100 - НалогИсчСуммарный_15, 0));
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;
    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT*100)) and (addFindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100)) and (Доход_13 != 0) and (Доход_15 == 0)) ///<13,15 -> 13
      STB.rec.TaxBaseCurrPay = Доход_13;
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_13+Доход_13)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_13, 0));
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, addFindSTB, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay = $0;
        STB_2.rec.CalcPITax      = $0;
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;

    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100)) and (addFindSTB.rec.TBID == 0) and (Доход_13 != 0) and (Доход_15 != 0)) ///<15 -> 13,15
      STB.rec.TaxBaseCurrPay = Доход_13;
      STB.rec.RateCalcPITax  = int(NPTXGENTAXRATE_RESIDENT*100);
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_13+Доход_13)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_13, 0));
      STB.rec.RateHoldPITax  = STB.rec.RateCalcPITax;
      STB.rec.BCCCalcPITax   = NPTXKBK_MAIN; 
      STB.rec.BCCHoldPITax   = NPTXKBK_MAIN; 
      STB.rec.HoldPITax      = $0;
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, NULL, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay      = Доход_15;
        STB_2.rec.CalcPITax           = money(round((ДоходСуммарный_15+Доход_15)*STB_2.rec.RateCalcPITax/100 - НалогИсчСуммарный_15, 0));
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;

    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT*100)) and (addFindSTB.rec.TBID == 0) and (Доход_13 != 0) and (Доход_15 != 0)) ///<13 -> 13,15
      STB.rec.TaxBaseCurrPay = Доход_13;
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_13+Доход_13)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_13, 0));
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, NULL, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay = Доход_15;
        STB_2.rec.RateCalcPITax  = int(NPTXGENTAXRATE_RESIDENT_15*100);
        STB_2.rec.CalcPITax      = money(round((ДоходСуммарный_15+Доход_15)*STB_2.rec.RateCalcPITax/100 - НалогИсчСуммарный_15, 0));
        STB_2.rec.RateHoldPITax  = STB_2.rec.RateCalcPITax;
        STB_2.rec.BCCCalcPITax   = NPTXKBK_15; 
        STB_2.rec.BCCHoldPITax   = NPTXKBK_15; 
        STB_2.rec.HoldPITax      = $0;
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;
    elif((FindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT*100)) and (addFindSTB.rec.RateCalcPITax == int(NPTXGENTAXRATE_RESIDENT_15*100))) ///<13,15 -> 13,15
      STB.rec.TaxBaseCurrPay = Доход_13;
      STB.rec.CalcPITax      = money(round((ДоходСуммарный_13+Доход_13)*STB.rec.RateCalcPITax/100 - НалогИсчСуммарный_13, 0));
      STB.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseExclude + STB.rec.TaxBaseCurrPay;

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(not err)
        STB_InitSTBByFindSTB(STB_2, FindSTB, addFindSTB, nptxop, tbbuf);

        STB_2.rec.TaxBaseCurrPay = Доход_15;
        STB_2.rec.CalcPITax      = money(round((ДоходСуммарный_15+Доход_15)*STB_2.rec.RateCalcPITax/100 - НалогИсчСуммарный_15, 0));
        STB_2.rec.ApplSTaxBaseInclude = STB.rec.ApplSTaxBaseInclude/*именно STB*/ + STB_2.rec.TaxBaseCurrPay;

        err = CheckAndSaveSTB(STB_2, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB_2.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;
    end;
  end;

  return err;
end;

//Получить DataSet выборки с данными для операции зачета удержанного НДФЛ 
MACRO GetDataSetToNptxNettOpQuery(TaxPeriod, ClientID, RetParmArr:@TArray, OperDate:date, AddPrior)
  var query, cmd;
  var CheckDate = IIF(((OperDate == NULL) or (OperDate == date(0,0,0))), date(31,12,9999), OperDate);

  if(TaxPeriod == 0)
    CheckDate = date(0,0,0);
  else
    CheckDate = min(date(31,12,TaxPeriod), CheckDate);
  end;

  if(ValType(AddPrior) != V_BOOL)
    AddPrior = false;
  end;

  private macro AddRetParm(Parm)
    var retStr = "?";

    if(ValType(RetParmArr) != V_UNDEF)
      RetParmArr[RetParmArr.size] = Parm;
    else
      if(ValType(Parm) == V_DATE)
        retStr = GetSQlDate(Parm);
      else
        retStr = string(Parm);
      end;
    end;

    return retStr;
  end;

  query =   " with bal as (select q.t_ClientID, q.t_TaxPeriod, q.BCCPITax, q.t_TaxBaseKind, q.t_RateHoldPITax, SUM(q.SumCalcPITax - q.SumHoldPITax) as Balance, "
          + "                     LISTAGG(q.TBIDS, ',') WITHIN GROUP(ORDER  BY ROWNUM) AS TBIDS, q.t_specialtag "
          + IIF(AddPrior, ", rsi_nptx.GetPriorOperNDFL(q.t_RateHoldPITax, q.t_TaxBaseKind, q.BCCPITax, q.t_specialtag, q.t_syscome) as t_prior ", " ")
          + "                from (select stb.t_ClientID, stb.t_TaxPeriod, stb.t_BCCCalcPITax as BCCPITax, stb.t_RateHoldPITax, stb.t_TaxBaseKind, SUM(stb.t_CalcPITax) as SumCalcPITax, 0 as SumHoldPITax, "
          + "                             stb.t_specialtag, stb.t_syscome, "
          + "                             LISTAGG(stb.t_TBID, ',') WITHIN GROUP(ORDER BY ROWNUM) AS TBIDS "
          + "                        from dnptxtotalbase_dbt stb "
          + "                       where stb.t_TaxPeriod = " + AddRetParm(TaxPeriod)
          + "                         and stb.t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE;
  
  if(ClientID > 0)
    query = query + " and stb.t_ClientID = " + AddRetParm(ClientID);
  end;

  query = query
          + "                       group by stb.t_ClientID, stb.t_TaxPeriod, stb.t_BCCCalcPITax, stb.t_RateHoldPITax, stb.t_TaxBaseKind, stb.t_syscome, stb.t_specialtag "
          + "                      UNION ALL "
          + "                      select stb.t_ClientID, stb.t_TaxPeriod, stb.t_BCCHoldPITax as BCCPITax, stb.t_RateHoldPITax, stb.t_TaxBaseKind, 0 as SumCalcPITax, SUM(stb.t_HoldPITax) as SumHoldPITax, "
          + "                             stb.t_specialtag, stb.t_syscome, "
          + "                             LISTAGG(stb.t_TBID, ',') WITHIN GROUP(ORDER BY ROWNUM) AS TBIDS "
          + "                        from dnptxtotalbase_dbt stb "
          + "                       where stb.t_TaxPeriod = " + AddRetParm(TaxPeriod)
          + "                         and stb.t_StorState = " + NPTXTOTALBASE_STORSTATE_ACTIVE;

  if(ClientID > 0)
    query = query + " and stb.t_ClientID = " + AddRetParm(ClientID);
  end;
  
  query = query
          + "                       group by stb.t_ClientID, stb.t_TaxPeriod, stb.t_BCCHoldPITax, stb.t_RateHoldPITax, stb.t_TaxBaseKind, stb.t_syscome, stb.t_specialtag "
          + "                     ) q "
          + "               group by q.t_ClientID, q.t_TaxPeriod, q.BCCPITax, q.t_RateHoldPITax, q.t_TaxBaseKind, q.t_syscome, q.t_specialtag "
          + "               having SUM(q.SumCalcPITax - q.SumHoldPITax) <> 0 "
          + "   ) "
          + " select b.* "
          + "   from bal b "
          + "  where ROWNUM > 0 ";

  if(IsUseProgressScale(CheckDate))
    //При прогрессивной ставке исключаем ИИС из зачета и корректировки
    query = query + " and b.t_TaxBaseKind <> " + NPTXTOTALBASE_TAXBASEKIND_IIS;
  end;

  return query;
END;

//Проверить необходимость выполнения зачета удержанного НДФЛ
MACRO NeedNptxNettOp(ClientID, TaxPeriod, OperDate)
  var query, cmd, DataSet;
  var RetParmArr = TArray();
  var AddPrior = false;
  var i = 0;

  if((TaxPeriod >= НП_ВВОДА_ДОРАБОТОК_BOSS_2981()) or (НПВводаДоработокМатВыгода() <= TaxPeriod))
    AddPrior = true;
  end;
  
  query = GetDataSetToNptxNettOpQuery(TaxPeriod, ClientID, RetParmArr, OperDate, AddPrior);
  query = query + "    and Exists(select 1 from bal b1 where b1.t_ClientID = b.t_ClientID and b1.t_TaxPeriod = b.t_TaxPeriod and b1.Balance > 0) "
                + "    and Exists(select 1 from bal b2 where b2.t_ClientID = b.t_ClientID and b2.t_TaxPeriod = b.t_TaxPeriod and b2.Balance < 0) ";

  cmd = DL_RSDCommand(query);

  if(RetParmArr.size > 0)
    i = 0;
    while(i < RetParmArr.size)
      cmd.AddParam(RetParmArr[i]);
      i = i + 1;
    end;
  end;

  DataSet = cmd.Execute();
  if(DataSet.moveNext())
    return true;
  end;

  return false;
END;

//Проверить, можно ли делать зачет в операции
MACRO STB_CanNettOp(DocKind, DocID)
  var query, cmd, DataSet;

  query =   " select 1 "
          + "   from doproper_dbt op "
          + "  where op.t_DocKind = ? "
          + "    and op.t_DocumentID = LPAD(?, 34, '0') "
          + "    and not Exists(select 1 "
          + "                     from doproper_dbt op1 "
          + "                    where op1.t_ID_Operation = op.t_Parent_ID_Operation "
          + "                      and op1.t_DocKind != " + DL_CALCNDFL
          + "                  )";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(DocKind);
  cmd.AddParam(DocID);

  if(cmd.GetCount() > 0)
    return true;
  end;

  return false;
END;


//TaxHoldArr - массив объектов STB_TaxRateParm
//IsLucre - признак расчета в операции матвыгоды
MACRO STB_ExecuteCorrOnStepPRGS(ClientID, TaxPeriod, IIS, TaxHoldArr:@TArray, DocKind, DocID, OperDate, TOut, MaxTaxe, CorrTxArr:@TArray, CloseContr, SecondCorr:bool, TaxToPay:@MONEY, IsLucre:integer, SpecialTag, Symbol)
  var main_query, query, cmd, DataSet;
  var err = 0, stat = 0;
  var RetParmArr = TArray();
  var eclude = false;
  var i = 0, j = 0;
  var CalcOpTaxeArr = TArray();
  var CurrAddTaxArr = TArray();
  var CurrAddTaxArrKBK = TArray();
  var AllCalcOpTaxe = $0;
  var AllToHoldOpTaxe = $0;
  var AddTaxe = $0, AddCalcTaxe = $0;
  var DecrTax = $0;
  var Type = NULL;
  var Bal201_207 = 0, Bal208 = 0;
  var in_TaxHoldArr = TArray();
  var in_CalcOpTaxe = 0, in_CalcOpTaxe15 = 0;
  var IsClientResident = STB_IsResidentStatus(STB_GetClientTaxPayerStatus(ClientID));
  var UseRate = false;
  var AddPrior = false;
  var TaxTeriodToLucre = false;
  var ExcludeSpecialTag = "";
  var sz = 0;

  CorrTxArr.size = 0;

  if(ВЫПОЛНЯТЬ_КОРРЕКТИРОВКУ_НДФЛ() == false)
    return 0;
  end;

  if(IIS)
    //Для операций по ИИС корректировку не делаем
    return 0;
  end;

  if(IsLucre == NULL)
    IsLucre = 0;
  end;

  if(IsLucre)
    TaxTeriodToLucre = CheckTaxTeriodToLucre(TaxPeriod);
  end;

  //Собираем суммы рассчитанного в операции налога в массив по ставкам
  i = 0;
  while(i < TaxHoldArr.size)
    in_TaxHoldArr[i] = STB_TaxRateParm(TaxHoldArr[i].Ставка,
                                       TaxHoldArr[i].НОБ, 
                                       TaxHoldArr[i].Налог,    
                                       TaxHoldArr[i].КБК,      
                                       TaxHoldArr[i].ВидНБ,    
                                       TaxHoldArr[i].ИИС,      
                                       TaxHoldArr[i].Тип,      
                                       TaxHoldArr[i].OrigTBID, 
                                       TaxHoldArr[i].TaxCalc,
                                       TaxHoldArr[i].AddTaxCalc,
                                       TaxHoldArr[i].Symbol,
                                       TaxHoldArr[i].SpecialTag
                                      );

    if(CalcOpTaxeArr[TaxHoldArr[i].Ставка] == NULL)
      CalcOpTaxeArr[TaxHoldArr[i].Ставка] = $0;
    end;

    if(TaxHoldArr[i].TaxCalc != NULL)
      CalcOpTaxeArr[TaxHoldArr[i].Ставка] = CalcOpTaxeArr[TaxHoldArr[i].Ставка] + TaxHoldArr[i].TaxCalc; 
    end;

    AllToHoldOpTaxe = AllToHoldOpTaxe + TaxHoldArr[i].Налог;

    if(i == 0)
      ExcludeSpecialTag = TaxHoldArr[i].SpecialTag;
    end;
    
    i = i + 1;                 
  end;

  cmd = DL_RSDCommand();
  
  if((TaxPeriod >= НП_ВВОДА_ДОРАБОТОК_BOSS_2981()) or (TaxTeriodToLucre))
    AddPrior = true;
  end;
  
  main_query = GetDataSetToNptxNettOpQuery(TaxPeriod, ClientID, RetParmArr, OperDate, AddPrior);

  if(RetParmArr.size > 0)
    i = 0;
    while(i < RetParmArr.size)
      cmd.AddParam(RetParmArr[i]);
      i = i + 1;
    end;
  end;
  
  //Корректировка делается в том случае, если все балансы по КБК + вид НОБ + TaxRate либо положительные либо отрицательные
  //Если есть и те и те, то корректировка не делается. Вообще такого в данном месте быть не должно, поскольку это и есть зачет, а он выполняется до удержания налога отдельным шагом

  //Выбираем записи в том случае, если есть только положительные балансы по кбк и виду НБ
  query = main_query + "    and Exists(select 1 from bal b1 where b1.t_ClientID = b.t_ClientID and b1.t_TaxPeriod = b.t_TaxPeriod and b1.Balance > 0) "
                     + "    and NOT Exists(select 1 from bal b2 where b2.t_ClientID = b.t_ClientID and b2.t_TaxPeriod = b.t_TaxPeriod and b2.Balance < 0) "
                     + "  order by "+IIF(AddPrior," b.t_prior, "," " )+" b.t_ClientID, b.t_TaxPeriod, b.t_RateHoldPITax ASC, b.t_TaxBaseKind DESC, b.BCCPITax DESC";

  DataSet = cmd.Execute(query);
  stat = DataSet.moveNext();
  if(not stat)
    //Если таких записей нет, то отбираем записи в том случае, если есть только отрицательные балансы по кбк и виду НБ 
    query = main_query + "    and NOT Exists(select 1 from bal b1 where b1.t_ClientID = b.t_ClientID and b1.t_TaxPeriod = b.t_TaxPeriod and b1.Balance > 0) "
                       + "    and Exists(select 1 from bal b2 where b2.t_ClientID = b.t_ClientID and b2.t_TaxPeriod = b.t_TaxPeriod and b2.Balance < 0) "
                       + "  order by "+IIF(AddPrior," b.t_prior, "," " )+" b.t_ClientID, b.t_TaxPeriod, b.t_RateHoldPITax ASC, b.t_TaxBaseKind DESC, b.BCCPITax DESC";

    DataSet = cmd.Execute(query);
    stat = DataSet.moveNext();
  else
    if((IsLucre) and (TaxTeriodToLucre))
      //Если после произведенного зачета все БАЛАНСКБК/вид_НОБ > = 0, то увеличения рассчитанного к удержанию налога TaxHoldMaterial_KBK НЕ ПРОИЗВОДИМ
      //Идея здесь в том, что при удержании с типом <Материальная выгода> мы можем зачесть переплату (отрицательные балансы) по другим видам налога, но доудержать что-либо, кроме налога по материальной выгоде, мы не вправе. 
      //Сумма налога к удержанию по матвыгоде, рассчитанная с учетом корректировок может только уменьшиться! Отрицательной быть не может!
      return 0;
    end;
  end;

  while((stat) and (not err))
    //Здесь в цикле будут либо все положительные балансы, либо все отрицательные

    AddTaxe = $0;
    AddCalcTaxe = $0;
    Type = NULL;

    //исключаем из отбора записи с сочетанием КБК/Вид НОБ по которым рассчитывали НДФЛ к удержанию
    i = 0;
    var exclude = false;
    while(i < TaxHoldArr.size)
      if((DataSet.TaxBaseKind == TaxHoldArr[i].ВидНБ) and (DataSet.RateHoldPITax == TaxHoldArr[i].Ставка) and (DataSet.BCCPITax == TaxHoldArr[i].КБК) and ((AddPrior == false) or (DataSet.SpecialTag == ExcludeSpecialTag))
        )
        exclude = true;                                                                                                                                           
        break;                   
      end;                       
                                 
      i = i + 1;                 
    end;                         
                                 
    if(exclude == true)          
      stat = DataSet.moveNext();
      continue;
    end;

    //Общая сумма оставшегося рассчитанного налога
    i = 0;
    while(i < CalcOpTaxeArr.size)
      if(CalcOpTaxeArr[i] != NULL)
        AllCalcOpTaxe = AllCalcOpTaxe + CalcOpTaxeArr[i];                       
      end;                           
      i = i + 1;                 
    end;

    if(DataSet.BCCPITax == NPTXKBK_INCR)
      Bal208 = Bal208 + DataSet.Balance;
    else
      Bal201_207 = Bal201_207 + DataSet.Balance;
    end;

    if(DataSet.Balance > 0) //То есть по этому балансу была недоплата налога
      if(AllCalcOpTaxe >= 0) //Если рассчитанный налог в операции больше или равен 0
        //В этом случае мы можем увеличить налог в операци на недоудержанную сумму, н ов пределах максимально возможного налога
        AddTaxe = max(min(DataSet.Balance, (MaxTaxe - AllToHoldOpTaxe)), $0);
      else
        //Если рассчетный налог в операции меньше 0
        //То здесь мы вычисляем отдельную величину, пока не скомпенсируем тот отрицательный налог
        //На эту величину мы можем зачесть налог из того вида НБ, где была недоплата (т.е. как бы доудержать, зачитывая рассчитанный отрицательный налог)
        AddCalcTaxe = min(DataSet.Balance, abs(AllCalcOpTaxe));
      end;

      if((DocKind != DL_VEKSELDRAWORDER) and (DocKind != DL_VSBARTERORDER) and (DocKind != DL_VSINTERCHANGE))

        if(AddCalcTaxe > 0)
          i = 0;
          DecrTax = $0;
          var RestAddCalcTaxe = AddCalcTaxe;
          while(i < CalcOpTaxeArr.size)
            if(RestAddCalcTaxe <= 0)
              break;
            end;

            if(CalcOpTaxeArr[i] != NULL)
              DecrTax = $0;
              if(CalcOpTaxeArr[i] < 0)
                if(abs(CalcOpTaxeArr[i]) <= RestAddCalcTaxe)
                  DecrTax = abs(CalcOpTaxeArr[i]);
                else
                  DecrTax = RestAddCalcTaxe;
                end;
              end;

              if(DecrTax != 0)
                RestAddCalcTaxe = RestAddCalcTaxe - DecrTax;

                CalcOpTaxeArr[i] = CalcOpTaxeArr[i] + DecrTax;
                if(CurrAddTaxArr[i] == NULL)
                  CurrAddTaxArr[i] = DecrTax;
                else
                  CurrAddTaxArr[i] = CurrAddTaxArr[i] + DecrTax;
                end;
              end;
            end;
            
            i = i + 1;
          end;
        end;

        var RestBalance = DataSet.Balance - AddCalcTaxe;
        if(RestBalance > 0)
          //В данное условие мы должны зайти один раз, когда весь отрицательный налог скомпенсировали, но осталась часть баланса
          //Согласно ТЗ
          //Если после произведенного зачета остались БАЛАНСКБК/вид_НОБ > 0, то выполняем переход к п.2. 
          //рассчитаем обычный добавочный налог по остатку текущего баланса,
          //далее в цикле по всем оставшимся положительным балансам пойдет обычный расчет
          if(((DocKind == DL_WRTMONEY) or (DocKind == DL_HOLDNDFL)) and (CloseContr == UNSET_CHAR) and (SecondCorr == false))
            AddTaxe = RestBalance;
          else
            AddTaxe = max(min(RestBalance, (MaxTaxe-AllToHoldOpTaxe)), $0);
          end;
        end;

        if(AddTaxe != 0)
          UseRate = false;
          if(TaxHoldArr.size > 0)
            i = TaxHoldArr.size - 1;
            while(i >= 0)                                           
              if((TaxHoldArr[i] != NULL) and 
                 (TaxHoldArr[i].Налог != 0) and 
                 (TaxHoldArr[i].Ставка == IIF(DataSet.RateHoldPITax == (100*IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT)), DataSet.RateHoldPITax, (100*NPTXGENTAXRATE_RESIDENT_15)))
                )
                TaxHoldArr[i].Налог = TaxHoldArr[i].Налог + AddTaxe;
                UseRate = true;
                break;
              end;

              i = i - 1;
            end;
          end;
          if(UseRate == false)
            TaxHoldArr[TaxHoldArr.size] = STB_TaxRateParm(int(100*IIF(DataSet.BCCPITax == NPTXKBK_MAIN, IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT), NPTXGENTAXRATE_RESIDENT_15)),
                                                          $0, 
                                                          money(AddTaxe),
                                                          IIF(DataSet.BCCPITax == NPTXKBK_MAIN, NPTXKBK_MAIN, NPTXKBK_INCR_218), 
                                                          STB_GetTaxBaseKindByDocKind(DocKind, IIS, OperDate) 
                                                         );

          end;
        end;
      end;

      Type = 2; //Удержание/возврат НДФЛ

    elif(DataSet.Balance < 0) //То есть по этому балансу была переплата налога
      var RateInd = -1;

      j = 0;
      while(j < TaxHoldArr.size)
        if(TaxHoldArr[j].Ставка == DataSet.RateHoldPITax)
          RateInd = j;
          break;
        end;

        j = j + 1;
      end;
      
      var RestAddTaxe = $0;
      //Значит надо уменьшить налог в операции на сумму этой переплаты или сумму самого налога, смотря что меньше
      if(AllToHoldOpTaxe > 0)
        RestAddTaxe = -min(abs(DataSet.Balance), AllToHoldOpTaxe);
      end;

      //Теперь нужно сумму уменьшения налога разнести по ставкам
      if(RateInd >= 0)
        //Если в операции есть налог по такой же ставке, то уменьшаем сначала его, а потом по остальным ставкам
        DecrTax = -min(TaxHoldArr[RateInd].Налог, abs(RestAddTaxe));

        RestAddTaxe = RestAddTaxe - DecrTax;
        AddTaxe = AddTaxe + DecrTax;

        TaxHoldArr[RateInd].Налог = TaxHoldArr[RateInd].Налог + DecrTax;
        if(CurrAddTaxArr[TaxHoldArr[RateInd].Ставка] == NULL)
          CurrAddTaxArr[TaxHoldArr[RateInd].Ставка] = DecrTax;
        else
          CurrAddTaxArr[TaxHoldArr[RateInd].Ставка] = CurrAddTaxArr[TaxHoldArr[RateInd].Ставка] + DecrTax;
        end;
        CurrAddTaxArrKBK[TaxHoldArr[RateInd].Ставка] = TaxHoldArr[RateInd].КБК;
      end;

      //Если остался остаток после уменьшения налога по той же ставке или вообще не было налога по той же ставке, то уменьшаем с первой имеющейся ставки
      if(RestAddTaxe != 0)
        i = 0;
        while(i < TaxHoldArr.size)
          if(RestAddTaxe == 0)
            break;
          end;
          
          if(TaxHoldArr[i].Налог > 0)
            DecrTax = -min(TaxHoldArr[i].Налог, abs(RestAddTaxe));

            RestAddTaxe = RestAddTaxe - DecrTax;
            AddTaxe = AddTaxe + DecrTax;

            TaxHoldArr[i].Налог = TaxHoldArr[i].Налог + DecrTax;
            
            if(CurrAddTaxArr[TaxHoldArr[i].Ставка] == NULL)
              CurrAddTaxArr[TaxHoldArr[i].Ставка] = DecrTax;
            else
              CurrAddTaxArr[TaxHoldArr[i].Ставка] = CurrAddTaxArr[TaxHoldArr[i].Ставка] + DecrTax;
            end;
            CurrAddTaxArrKBK[TaxHoldArr[i].Ставка] = TaxHoldArr[i].КБК;
          end;

          i = i + 1;
        end;
      end;

      Type = 3; //Зачет переплаты НДФЛ
    end;

    if(AddTaxe != 0)
      AllToHoldOpTaxe = AllToHoldOpTaxe + AddTaxe;

      sz = CorrTxArr.size;
      
      CorrTxArr[sz] = STB_TaxRateParm(int(DataSet.RateHoldPITax), 
                                      $0, 
                                      AddTaxe,
                                      DataSet.BCCPITax,
                                      DataSet.TaxBaseKind,
                                      IIF(DataSet.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS, true, false),
                                      Type,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL
                                     );

      if(AddPrior)
        CorrTxArr[sz].specialtag = DataSet.specialtag;
      end;

      if((ValType(Symbol) == V_STRING))
        CorrTxArr[sz].Symbol = Symbol;
      end;

    end;

    if(AddCalcTaxe != 0)
      //Дополнительный расчетный налог не увеличивает сумму налога к удержанию
      //Он мог возникнуть только при общем отрицательном расчетном налоге в операции и положительном балансе по другому виду НБ
      //То есть, чтобы не возвращать налог в операции мы зачитываем с недоплаченным налогом по другим видам НБ

      sz = CorrTxArr.size;

      CorrTxArr[sz] = STB_TaxRateParm(int(DataSet.RateHoldPITax), 
                                      $0, 
                                      AddCalcTaxe,
                                      DataSet.BCCPITax,
                                      DataSet.TaxBaseKind,
                                      IIF(DataSet.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS, true, false),
                                      Type,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL
                                     );

      if(AddPrior)
        CorrTxArr[sz].specialtag = DataSet.specialtag;
      end;

      if((ValType(Symbol) == V_STRING))
        CorrTxArr[sz].Symbol = Symbol;
      end;

    end;


    if(not err)
      stat = DataSet.moveNext();
    end;
  end;

  if(not err)
    i = 0;
    while(i < CurrAddTaxArr.size)
      if((CurrAddTaxArr[i] != NULL) and (CurrAddTaxArr[i] != 0))
        var Rate = int(i);
        sz = CorrTxArr.size;
        CorrTxArr[sz] = STB_TaxRateParm(Rate, 
                                        $0, 
                                        -CurrAddTaxArr[i],
                                        CurrAddTaxArrKBK[i],
                                        NULL,
                                        IIF(IIS, true, false),
                                        3 //Зачет переплаты НДФЛ
                                       );
        if(AddPrior and (ValType(SpecialTag) == V_STRING))
          CorrTxArr[sz].specialtag = SpecialTag;
        end;
        if((ValType(Symbol) == V_STRING))
          CorrTxArr[sz].Symbol = Symbol;
        end;
      end;

      i = i + 1;
    end;
  end; 

  if(not err)
    if((DocKind == DL_WRTMONEY) or (DocKind == DL_HOLDNDFL))
      if(CloseContr == UNSET_CHAR)
        var taxe = 0, taxe15 = 0;
        var in_taxe = 0, in_taxe15 = 0;
        var flag = false;
        
        i = 0;
        while(i < TaxHoldArr.size)
          if(TaxHoldArr[i].Ставка == int(100*NPTXGENTAXRATE_RESIDENT_15))
            taxe15 = taxe15 + TaxHoldArr[i].Налог;
          else
            taxe = TaxHoldArr[i].Налог;
          end;
          i = i + 1;
        end;

        i = 0;
        while(i < in_TaxHoldArr.size)
          if(in_TaxHoldArr[i].Ставка == int(100*NPTXGENTAXRATE_RESIDENT_15))
            in_taxe15 = in_taxe15 + in_TaxHoldArr[i].Налог;
          else
            in_taxe = in_TaxHoldArr[i].Налог;
          end;
          i = i + 1;
        end;

        TaxToPay = taxe + taxe15;

        if(((TOut < (taxe + taxe15)) and (in_taxe15 > 0)) or ((taxe + taxe15 == 0) and (TOut <= Bal208)))
          taxe = round(min(max(taxe, 0), TOut*NPTXGENTAXRATE_RESIDENT_15), 0);
          taxe15 = round(min(taxe15, round(TOut*NPTXGENTAXRATE_RESIDENT_15, 0) - taxe), 0);
        elif(((TOut < (taxe + taxe15)) and (in_taxe15 <= 0)) or ((taxe + taxe15 == 0) and (TOut <= Bal201_207)))
          taxe = round(min((taxe+taxe15), TOut*IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT)), 0);
          taxe15 = 0;
        elif(TOut > (taxe + taxe15))
          taxe = max(taxe, 0);
          taxe15 = max(taxe15, 0);

          var AllTaxe = round((taxe + taxe15), 0);
          taxe15 = round(taxe15, 0);
          taxe = AllTaxe - taxe15;

          flag = true;
        end;

        i = 0;
        while(i < TaxHoldArr.size)
          if(TaxHoldArr[i].Ставка == int(100*NPTXGENTAXRATE_RESIDENT_15))
            TaxHoldArr[i].Налог = taxe15;
          else
            TaxHoldArr[i].Налог = taxe;
          end;

          i = i + 1;
        end;

        if(SecondCorr == false)
          CorrTxArr.size = 0;
          var NewMaxTaxe = taxe + taxe15;

          if((flag == true) or (in_TaxHoldArr.size == 0) or (taxe > in_taxe) or (taxe15 > in_taxe15))
            i = 0;
            TaxHoldArr.size = 0;
            while(i < in_TaxHoldArr.size)
              TaxHoldArr[i] = STB_TaxRateParm(in_TaxHoldArr[i].Ставка,
                                              in_TaxHoldArr[i].НОБ, 
                                              in_TaxHoldArr[i].Налог,    
                                              in_TaxHoldArr[i].КБК,      
                                              in_TaxHoldArr[i].ВидНБ,    
                                              in_TaxHoldArr[i].ИИС,      
                                              in_TaxHoldArr[i].Тип,      
                                              in_TaxHoldArr[i].OrigTBID, 
                                              in_TaxHoldArr[i].TaxCalc,
                                              in_TaxHoldArr[i].AddTaxCalc,
                                              in_TaxHoldArr[i].Symbol,
                                              in_TaxHoldArr[i].SpecialTag
                                             );
    
              i = i + 1;                 
            end;
          end;

          err = STB_ExecuteCorrOnStepPRGS(ClientID, TaxPeriod, IIS, @TaxHoldArr, DocKind, DocID, OperDate, TOut, NewMaxTaxe, @CorrTxArr, CloseContr, true, TaxToPay, IsLucre, SpecialTag);
        end;
      end;
    end;
  end;

  if(AddPrior == false)//При корректировках, если Налоговый период < значению настройки COMMON\НДФЛ НП_ВВОДА_ДОРАБОТОКBOSS-2981 И если вид НОБ = БРОК, то Спец признак = БРОК, если вид НОБ! = БРОК, то Спец признак = пусто
    i = 0;
    while(i < CorrTxArr.size)
      if(CorrTxArr[i].ВидНБ == NPTXTOTALBASE_TAXBASEKIND_BROK)
        CorrTxArr[i].specialtag = "БРОК";
      else
        CorrTxArr[i].specialtag = "";
      end;
      i = i + 1;
    end;
  end;

  return err;
END;

MACRO STB_ExecuteCorrOnStep(Tout, MaxTaxe, НОБ_30, НОБ_13, НОБ_15, taxe:@money, taxe15:@money, DocKind, DocID, OperDate, IIS:bool, ClientID, TaxPeriod, CorrTxArr:@TArray, CloseContr, CalcOpTaxe, CalcOpTaxe15, SecondCorr:bool)
  var main_query, query, cmd, DataSet;
  var RetParmArr = TArray();
  var err = 0, stat = 0;
  var i = 0;
  var IsOpTaxKBKMain = false, IsOpTaxKBK15 = false;
  var AllTaxe = $0, AllCalcOpTaxe = $0;
  var Type = NULL;
  var AddTaxe = $0, AddCalcTaxe = $0;
  var IsClientResident = STB_IsResidentStatus(STB_GetClientTaxPayerStatus(ClientID));
  var OpTaxBaseKind = STB_GetTaxBaseKindByDocKind(DocKind, IIS, OperDate);
  var CurrAddTaxMain = $0, CurrAddTax15 = $0;
  var Rate;
  var DecrTaxMain = 0;
  var DecrTax15   = 0;
  var InMaxTaxe = MaxTaxe;
  var in_taxe = taxe, in_taxe15 = taxe15;
  var in_CalcOpTaxe = CalcOpTaxe, in_CalcOpTaxe15 = CalcOpTaxe15;
  var BalMain = $0, Bal15 = $0;

  CorrTxArr.size = 0;

  if(ВЫПОЛНЯТЬ_КОРРЕКТИРОВКУ_НДФЛ() == false)
    return 0;
  end;

  AllTaxe = taxe + taxe15;
  
  if(CalcOpTaxe == NULL)
    CalcOpTaxe = taxe;
  end;

  if(CalcOpTaxe15 == NULL)
    CalcOpTaxe15 = taxe15;
  end; 

  if(SecondCorr == NULL)
    SecondCorr = false;
  end;

  //исключаем из отбора записи с сочетанием КБК/Вид НОБ по которым рассчитывали НДФЛ к удержанию 
  if((taxe != 0) or (НОБ_13 != 0) or (НОБ_30 != 0))
    IsOpTaxKBKMain = true;
  end;

  if((taxe15 != 0) or (НОБ_15 != 0))
    IsOpTaxKBK15 = true;
  end;
  
  cmd = DL_RSDCommand();
  
  main_query = GetDataSetToNptxNettOpQuery(TaxPeriod, ClientID, RetParmArr, OperDate);

  if(RetParmArr.size > 0)
    i = 0;
    while(i < RetParmArr.size)
      cmd.AddParam(RetParmArr[i]);
      i = i + 1;
    end;
  end;
  
  //Корректировка делается в том случае, если все балансы по КБК + вид НОБ либо положительные либо отрицательные
  //Если есть и те и те, то корректировка не делается. Вообще такого в данном месте быть не должно, поскольку это и есть зачет, а он выполняется до удержания налога отдельным шагом

  //Выбираем записи в том случае, если есть только положительные балансы по кбк и виду НБ
  query = main_query + "    and Exists(select 1 from bal b1 where b1.t_ClientID = b.t_ClientID and b1.t_TaxPeriod = b.t_TaxPeriod and b1.Balance > 0) "
                     + "    and NOT Exists(select 1 from bal b2 where b2.t_ClientID = b.t_ClientID and b2.t_TaxPeriod = b.t_TaxPeriod and b2.Balance < 0) "
                     + "  order by b.t_ClientID, b.t_TaxPeriod, b.BCCPITax, b.t_TaxBaseKind DESC";

  DataSet = cmd.Execute(query);
  stat = DataSet.moveNext();
  if(not stat)
    //Если таких записей нет, то отбираем записи в том случае, если есть только отрицательные балансы по кбк и виду НБ 
    query = main_query + "    and NOT Exists(select 1 from bal b1 where b1.t_ClientID = b.t_ClientID and b1.t_TaxPeriod = b.t_TaxPeriod and b1.Balance > 0) "
                       + "    and Exists(select 1 from bal b2 where b2.t_ClientID = b.t_ClientID and b2.t_TaxPeriod = b.t_TaxPeriod and b2.Balance < 0) "
                       + "  order by b.t_ClientID, b.t_TaxPeriod, b.BCCPITax, b.t_TaxBaseKind DESC";

    DataSet = cmd.Execute(query);
    stat = DataSet.moveNext();
  end;

  while((stat) and (not err))
    //Здесь в цикле будут либо все положительные балансы, либо все отрицательные
    if(((IsOpTaxKBKMain == true) and (DataSet.BCCPITax == NPTXKBK_MAIN) and (DataSet.TaxBaseKind == OpTaxBaseKind)) or 
       ((IsOpTaxKBK15 == true) and (DataSet.BCCPITax == NPTXKBK_15) and (DataSet.TaxBaseKind == OpTaxBaseKind))
      )
      stat = DataSet.moveNext();
      continue;
    end;

    if(DataSet.BCCPITax == NPTXKBK_MAIN)
      BalMain = BalMain + DataSet.Balance;
    else
      Bal15 = Bal15 + DataSet.Balance;
    end;

    AllCalcOpTaxe = CalcOpTaxe + CalcOpTaxe15; 
    
    AddTaxe = $0;
    AddCalcTaxe = $0;
    Type = NULL;

    DecrTaxMain = 0;
    DecrTax15   = 0;

    if(DataSet.Balance > 0 )
      if(AllCalcOpTaxe >= 0)
        AddTaxe = max(min(DataSet.Balance, (MaxTaxe - AllTaxe)), $0);
      else
        //Если рассчетный налог в операции меньше 0, то фактический пришел 0 (taxe и taxe15)
        //Поэтому здесь мы вычисляем отдельную величину, пока не скомпенсируем тот отрицательный налог
        AddCalcTaxe = min(DataSet.Balance, abs(AllCalcOpTaxe));
      end;

      if((DocKind != DL_VEKSELDRAWORDER) and (DocKind != DL_VSBARTERORDER) and (DocKind != DL_VSINTERCHANGE))

        if(AddCalcTaxe > 0)
          if(CalcOpTaxe < 0)
            if(abs(CalcOpTaxe) < abs(AddCalcTaxe))
              DecrTaxMain = abs(CalcOpTaxe);
              DecrTax15   = AddCalcTaxe - abs(CalcOpTaxe);
            else
              DecrTaxMain   = AddCalcTaxe;
            end; 
          else
            DecrTax15 = AddCalcTaxe;
          end;

          CalcOpTaxe = CalcOpTaxe + DecrTaxMain;
          CalcOpTaxe15 = CalcOpTaxe15 + DecrTax15;

          CurrAddTaxMain = CurrAddTaxMain + DecrTaxMain;
          CurrAddTax15   = CurrAddTax15 + DecrTax15;
        end;

        var RestBalance = DataSet.Balance - AddCalcTaxe;
        if(RestBalance > 0)
          //В данное условие мы должны зайти один раз, когда весь отрицательный налог скомпенсировали, но осталась часть баланса
          //Согласно ТЗ
          //Если после произведенного зачета остались БАЛАНСКБК/вид_НОБ > 0, то выполняем переход к п.2. 
          //рассчитаем обычный добавочный налог по остатку текущего баланса,
          //далее в цикле по всем оставшимся положительным балансам пойдет обычный расчет
          if((DocKind == DL_WRTMONEY) and (CloseContr == UNSET_CHAR) and (SecondCorr == false))
            AddTaxe = RestBalance;
          else
            AddTaxe = max(min(RestBalance, (MaxTaxe-AllTaxe)), $0);
          end;
        end;

        if(AddTaxe != 0)
          if(taxe15 != 0)
            taxe15 = taxe15 + AddTaxe;
          else
            taxe = taxe + AddTaxe;
          end;
        end;
      end;

      Type = 2; //Удержание/возврат НДФЛ
    else
      if(AllTaxe > 0)
        AddTaxe = -min(abs(DataSet.Balance), AllTaxe);
      end;

      var RestAddTaxe = AddTaxe;
      if((DataSet.BCCPITax == NPTXKBK_MAIN) and ((taxe > 0) or (taxe15 > 0)))
        if(taxe > 0)
          DecrTaxMain = -min(taxe, abs(AddTaxe));
          RestAddTaxe = RestAddTaxe - DecrTaxMain;
        end;
        if(taxe15 > 0)
          DecrTax15   = -min(taxe15, abs(RestAddTaxe));
        end;
      elif(DataSet.BCCPITax == NPTXKBK_15 and ((taxe > 0) or (taxe15 > 0)))
        if(taxe15 > 0)
          DecrTax15 =  -min(taxe15, abs(AddTaxe));
          RestAddTaxe = RestAddTaxe - DecrTax15;
        end;
        if(taxe > 0)
          DecrTaxMain =  -min(taxe, abs(RestAddTaxe));
        end;
      end;

      AddTaxe = DecrTaxMain + DecrTax15;

      CurrAddTaxMain = CurrAddTaxMain + DecrTaxMain;
      CurrAddTax15   = CurrAddTax15 + DecrTax15;

      taxe = taxe + DecrTaxMain;
      taxe15 = taxe15 + DecrTax15;

      Type = 3; //Зачет переплаты НДФЛ
    end;

    if(AddTaxe != 0)
      AllTaxe = AllTaxe + AddTaxe;
      
      CorrTxArr[CorrTxArr.size] = STB_TaxRateParm(int(100*IIF(DataSet.BCCPITax == NPTXKBK_15, NPTXGENTAXRATE_RESIDENT_15, IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT))), 
                                                  $0, 
                                                  AddTaxe,
                                                  DataSet.BCCPITax,
                                                  DataSet.TaxBaseKind,
                                                  IIF(DataSet.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS, true, false),
                                                  Type
                                                 );

    end;

    if(AddCalcTaxe != 0)
      CorrTxArr[CorrTxArr.size] = STB_TaxRateParm(int(100*IIF(DataSet.BCCPITax == NPTXKBK_15, NPTXGENTAXRATE_RESIDENT_15, IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT))), 
                                                  $0, 
                                                  AddCalcTaxe,
                                                  DataSet.BCCPITax,
                                                  DataSet.TaxBaseKind,
                                                  IIF(DataSet.TaxBaseKind == NPTXTOTALBASE_TAXBASEKIND_IIS, true, false),
                                                  Type
                                                 );

    end;

    if(not err)
      stat = DataSet.moveNext();
    end;
  end;

  if(not err)
    if(CurrAddTaxMain != 0)
      Rate = int(100*IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT));
      CorrTxArr[CorrTxArr.size] = STB_TaxRateParm(Rate, 
                                                  $0, 
                                                  -CurrAddTaxMain,
                                                  NULL,
                                                  NULL,
                                                  IIF(IIS, true, false),
                                                  3 //Зачет переплаты НДФЛ
                                                 );

    end;

    if(CurrAddTax15 != 0)
      Rate = int(100*NPTXGENTAXRATE_RESIDENT_15);
      CorrTxArr[CorrTxArr.size] = STB_TaxRateParm(Rate, 
                                                  $0, 
                                                  -CurrAddTax15,
                                                  NULL,
                                                  NULL,
                                                  IIF(IIS, true, false),
                                                  3 //Зачет переплаты НДФЛ
                                                 );

    end;
  end; 

  if(not err)
    if(DocKind == DL_WRTMONEY)
      if(CloseContr == UNSET_CHAR)
        if(((TOut < (taxe + taxe15)) and (in_taxe15 > 0)) or ((taxe + taxe15 == 0) and (TOut <= Bal15)))
          taxe = round(min(max(taxe, 0), TOut*NPTXGENTAXRATE_RESIDENT_15), 0);
          taxe15 = round(min(taxe15, round(TOut*NPTXGENTAXRATE_RESIDENT_15, 0) - taxe), 0);
        elif((TOut < (taxe + taxe15)) and (in_taxe15 <= 0))
          taxe = round(min(taxe, TOut*IIF(IsClientResident, NPTXGENTAXRATE_RESIDENT, NPTXGENTAXRATE_NOTRESIDENT)), 0);
          taxe15 = 0;
        elif(TOut > (taxe + taxe15))
          taxe = max(taxe, 0);
          taxe15 = max(taxe15, 0);
        end;

        if(SecondCorr == false)
          CorrTxArr.size = 0;
          var NewMaxTaxe = taxe + taxe15;
          taxe   = in_taxe;
          taxe15 = in_taxe15;
          err = STB_ExecuteCorrOnStep(TOut, NewMaxTaxe, НОБ_30, НОБ_13, НОБ_15, @taxe, @taxe15, DocKind, DocID, OperDate, IIS, ClientID, TaxPeriod, @CorrTxArr, CloseContr, in_CalcOpTaxe, in_CalcOpTaxe15, true);
        end;
      end;
    end;
  end;

  return err;
END;

MACRO STB_SaveTxArrInMsg(TxArr:TArray)
  var i = 0;
  var str = "";

  macro GetValStr(Val:variant)
    if(Val == NULL)
      return ";";
    end;

    return string(Val)+";";
  end;
  
  while(i < TxArr.size)
    str =   GetValStr(TxArr[i].Ставка)
          + GetValStr(TxArr[i].НОБ)   
          + GetValStr(TxArr[i].Налог) 
          + GetValStr(TxArr[i].КБК)   
          + GetValStr(TxArr[i].ВидНБ) 
          + GetValStr(TxArr[i].ИИС)   
          + GetValStr(TxArr[i].Тип)
          + GetValStr(TxArr[i].SpecialTag);   


    DL_NPTX_PutMsg(str, 200);

    i = i + 1;
  end;
END;

MACRO STB_GetTxArrFromMsg(NpTxOpID:integer, TxArr:@TArray)
  var query, cmd, DataSet;
  var ind = 0, prevind = 0;
  var str = "", v = "";
  var Ставка;
  var НОБ;   
  var Налог; 
  var КБК;   
  var ВидНБ; 
  var ИИС;   
  var Тип;
  var SpecialTag;

  macro GetNextVal()
    var val;
    
    prevind = ind;
    ind     = index(str, ";", prevind+1);
    val = substr(str, prevind+1, ind-prevind-1);

    if(StrLwr(val) == "true")
      return true;
    elif(StrLwr(val) == "false")
      return false;
    end;

    return val;
  end;

  TxArr.size = 0;

  query =   " select msg.t_Message "
          + "   from dnptxmes_dbt msg"
          + "  where msg.t_DocID = ? "
          + "    and msg.t_Type in (200) "
          + "    and not Exists(select 1 from dnptxmes_dbt msg1 where msg1.t_DocID = msg.t_DocID and msg1.t_Type = 201)"
          + " order by msg.t_ID ASC";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(NpTxOpID);
  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    ind = 0;
    str = DataSet.Message;

    v = GetNextVal(); Ставка = IIF(v == "", NULL, int(v));
    v = GetNextVal(); НОБ    = IIF(v == "", NULL, money(v));
    v = GetNextVal(); Налог  = IIF(v == "", NULL, money(v));
    v = GetNextVal(); КБК    = IIF(v == "", NULL, v);
    v = GetNextVal(); ВидНБ  = IIF(v == "", NULL, int(v));
    v = GetNextVal(); ИИС    = IIF(v == "", NULL, v);
    v = GetNextVal(); Тип    = IIF(v == "", NULL, int(v));
    v = GetNextVal(); SpecialTag = IIF(v == "", NULL, v);

    TxArr[TxArr.size] = STB_TaxRateParm(Ставка, НОБ, Налог, КБК, ВидНБ, ИИС, Тип, NULL, NULL, NULL, "C", SpecialTag);
  end;
  
END;

MACRO STB_SaveHoldArrInMsg(TxArr:TArray)
  var i = 0;
  var str = "";

  macro GetValStr(Val:variant)
    if(Val == NULL)
      return ";";
    end;

    return string(Val)+";";
  end;
  
  while(i < TxArr.size)
    str =   GetValStr(TxArr[i].Ставка)
          + GetValStr(TxArr[i].НОБ)   
          + GetValStr(TxArr[i].Налог) 
          + GetValStr(TxArr[i].КБК)   
          + GetValStr(TxArr[i].ВидНБ) 
          + GetValStr(TxArr[i].ИИС)   
          + GetValStr(TxArr[i].Тип)
          + GetValStr(TxArr[i].Symbol)
          + GetValStr(TxArr[i].SpecialTag);   


    DL_NPTX_PutMsg(str, 300);

    i = i + 1;
  end;
END;

MACRO STB_GetHoldArrFromMsg(NpTxOpID:integer, TxArr:@TArray)
  var query, cmd, DataSet;
  var ind = 0, prevind = 0;
  var str = "", v = "";
  var Ставка;
  var НОБ;   
  var Налог; 
  var КБК;   
  var ВидНБ; 
  var ИИС;   
  var Тип;  
  var Symbol;  
  var SpecialTag;

  macro GetNextVal()
    var val;
    
    prevind = ind;
    ind     = index(str, ";", prevind+1);
    val = substr(str, prevind+1, ind-prevind-1);

    if(StrLwr(val) == "true")
      return true;
    elif(StrLwr(val) == "false")
      return false;
    end;

    return val;
  end;

  TxArr.size = 0;

  query =   " select msg.t_Message "
          + "   from dnptxmes_dbt msg"
          + "  where msg.t_DocID = ? "
          + "    and msg.t_Type in (300) "
          + "    and not Exists(select 1 from dnptxmes_dbt msg1 where msg1.t_DocID = msg.t_DocID and msg1.t_Type = 201)"
          + " order by msg.t_ID ASC";

  cmd = DL_RSDCommand(query);

  cmd.AddParam(NpTxOpID);
  DataSet = cmd.Execute();
  while(DataSet.moveNext())
    ind = 0;
    str = DataSet.Message;

    v = GetNextVal(); Ставка = IIF(v == "", NULL, int(v));
    v = GetNextVal(); НОБ    = IIF(v == "", NULL, money(v));
    v = GetNextVal(); Налог  = IIF(v == "", NULL, money(v));
    v = GetNextVal(); КБК    = IIF(v == "", NULL, v);
    v = GetNextVal(); ВидНБ  = IIF(v == "", NULL, int(v));
    v = GetNextVal(); ИИС    = IIF(v == "", NULL, v);
    v = GetNextVal(); Тип    = IIF(v == "", NULL, int(v));
    v = GetNextVal(); Symbol = IIF(v == "", NULL, v);
    v = GetNextVal(); SpecialTag = IIF(v == "", NULL, v);

    TxArr[TxArr.size] = STB_TaxRateParm(Ставка, НОБ, Налог, КБК, ВидНБ, ИИС, Тип, NULL, NULL, NULL, Symbol, SpecialTag);
  end;
  
END;

macro STB_Recalc(FindSTB, addFindSTBArr, nptxop, tbbuf, ErrStr:@string)
  var addFindSTB = TRecHandler("nptxtotalbase.dbt");
  var STB = TRecHandler("nptxtotalbase.dbt");
  var FindTaxBaseKind = FindSTB.rec.TaxBaseKind;
  var СНОБ_акт = $0;
  var НОБ_тек  = $0;
  var pt = TBFile("party.dbt");
  var err = 0;
  var query, cmd, DataSet;
  var WasSkip = false;
  var TaxDate, TaxTime;
  var TotalTaxBaseCurrPay = $0;
  var i = 0;
  var UsedTBIDsArr = TArray();


  macro CheckSTBInUsed(CheckSTB)
    var j = 0;
    while(j < UsedTBIDsArr.size)
      if(CheckSTB.rec.TBID == UsedTBIDsArr[j])
        return true;
      end;

      j = j + 1;
    end;

    return false;
  end;

  pt.Clear();
  pt.rec.PartyID = FindSTB.rec.ClientID;
  if(not pt.GetEQ())
    ErrStr = "Не найден субъект с идентификатором " + FindSTB.rec.ClientID;
    return 1;
  end;

  if((FindSTB.rec.TaxBaseKind != NPTXTOTALBASE_TAXBASEKIND_IIS) and (РАБОТА_В_РЕЖИМЕ_СНОБ() == true))
    FindTaxBaseKind = string(NPTXTOTALBASE_TAXBASEKIND_BROK) + ", " + string(NPTXTOTALBASE_TAXBASEKIND_ONB);
  end;

  if(tbbuf != NULL)
    if(РАБОТА_В_РЕЖИМЕ_СНОБ() == true)
      СНОБ_акт = tbbuf.rec.AmountSNOB;
    else
      СНОБ_акт = tbbuf.rec.NobTypeAmount;
    end;

    TaxDate = tbbuf.rec.TimeStampRegDate;
    TaxTime = tbbuf.rec.TimeStampRegTime;
  else
    GetLastOpSTBVal(DL_NPTXSTBOP, FindSTB.rec.TBID, NPTXVAL_KIND_STB, @СНОБ_акт, @TaxDate, @TaxTime);
  end;

  if(not err)
    НОБ_тек = FindSTB.rec.TaxBaseCurrPay;
    if((addFindSTBArr != NULL) and (addFindSTBArr.size > 0))
      i = 0;
      while(i < addFindSTBArr.size)
        НОБ_тек = НОБ_тек + addFindSTBArr[i].rec.TaxBaseCurrPay;

        i = i + 1;
      end;
    end;

    CalcTaxByRanges(FindSTB.rec.ClientID,
                    FindSTB.rec.TaxPeriod,
                    FindSTB.rec.TaxBaseKind,
                    НОБ_тек,
                    СНОБ_акт,
                    nptxop.rec.OperDate);
                    
    query = " select * from dnptxtaxbaseranges_tmp order by t_range asc ";
    cmd = DL_RSDCommand(query);
    DataSet = cmd.Execute();

    while(DataSet.moveNext())
      TotalTaxBaseCurrPay = TotalTaxBaseCurrPay + DataSet.BaseSum;
      
      STB.Clear();
      addFindSTB.Clear();

      if((addFindSTBArr != NULL) and (addFindSTBArr.size > 0))
        i = 0;
        while(i < addFindSTBArr.size)
          if((DataSet.KBK == addFindSTBArr[i].rec.BCCHoldPITax) and (int(DataSet.TaxRate) == addFindSTBArr[i].rec.RateHoldPITax))
            copy(addFindSTB, addFindSTBArr[i]);
            break;
          end;
          i = i + 1;
        end;
      end;

      if(addFindSTB.rec.TBID == 0)
        copy(addFindSTB, FindSTB);
      end;
      
      STB_InitSTBByFindSTB(STB, addFindSTB, NULL, nptxop, tbbuf);
      
      STB.rec.TaxBaseCurrPay      = DataSet.BaseSum;
      STB.rec.CalcPITax           = money(DataSet.TaxCalc);
      STB.rec.RateCalcPITax       = int(DataSet.TaxRate);
      STB.rec.RateHoldPITax       = int(DataSet.TaxRate);
      STB.rec.TaxPayerStatus      = STB_GetClientTaxPayerStatus(STB.rec.ClientID);
      STB.rec.RecSTaxBase         = СНОБ_акт;
      STB.rec.ApplSTaxBaseInclude = STB.rec.RecSTaxBase + TotalTaxBaseCurrPay;
      STB.rec.ApplSTaxBaseExclude = STB.rec.RecSTaxBase;
      STB.rec.HoldPITax           = IIF((DataSet.KBK == addFindSTB.rec.BCCHoldPITax), addFindSTB.rec.HoldPITax, $0);
      STB.rec.BCCCalcPITax        = DataSet.KBK; //КБК исчисленного НДФЛ
      STB.rec.BCCHoldPITax        = DataSet.KBK; //КБК удержанного НДФЛ
      STB.rec.NeedRecalc          = "";

      err = CheckAndSaveSTB(STB, @WasSkip);
      if(err)
        ErrStr = "Ошибка при создании записи";
      elif(WasSkip == false)
        DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
      end;

      if(DataSet.KBK == addFindSTB.rec.BCCHoldPITax)
        UsedTBIDsArr[UsedTBIDsArr.size] = addFindSTB.rec.TBID;
      end;
    end;

    if(FindSTB.rec.HoldPITax != $0)
      if(CheckSTBInUsed(FindSTB) == false)
        STB_InitSTBByFindSTB(STB, FindSTB, NULL, nptxop, tbbuf);
        
        STB.rec.TaxBaseCurrPay = $0;
        STB.rec.CalcPITax      = $0;
        STB.rec.HoldPITax      = FindSTB.rec.HoldPITax;
        STB.rec.RecSTaxBase    = СНОБ_акт;
        STB.rec.ApplSTaxBaseInclude = STB.rec.RecSTaxBase + TotalTaxBaseCurrPay;
        STB.rec.ApplSTaxBaseExclude = STB.rec.RecSTaxBase;
        STB.rec.NeedRecalc     = "";
         
        err = CheckAndSaveSTB(STB, @WasSkip);
        if(err)
          ErrStr = "Ошибка при создании записи";
        elif(WasSkip == false)
          DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
        end;
      end;
    end;
    
    if((addFindSTBArr != NULL) and (addFindSTBArr.size > 0))
      i = 0;
      while(i < addFindSTBArr.size)
        if(addFindSTBArr[i].rec.HoldPITax != $0)
          if(CheckSTBInUsed(addFindSTBArr[i]) == false)
            STB_InitSTBByFindSTB(STB, addFindSTBArr[i], NULL, nptxop, tbbuf);
          
            STB.rec.TaxBaseCurrPay = $0;
            STB.rec.CalcPITax      = $0;
            STB.rec.HoldPITax      = addFindSTBArr[i].rec.HoldPITax;
            STB.rec.RecSTaxBase    = СНОБ_акт;
            STB.rec.ApplSTaxBaseInclude = STB.rec.RecSTaxBase + TotalTaxBaseCurrPay;
            STB.rec.ApplSTaxBaseExclude = STB.rec.RecSTaxBase;
            STB.rec.NeedRecalc     = "";
             
            err = CheckAndSaveSTB(STB, @WasSkip);
            if(err)
              ErrStr = "Ошибка при создании записи";
            elif(WasSkip == false)
              DL_NPTX_PutMsg( "   Сформирована новая запись о событии СНОБ по ставке " + STB.rec.RateCalcPITax + "% для клиента " + pt.rec.Name, 50 );
            end;
          end;
        end;
        i = i + 1;
      end;
    end;

  end;

  return err;
end;


/**
  @brief Выполнить запрос SNOBID в хран. СНОБ
  @param[in] ClientID     - integer Идентификатор клиента
  @param[in] IncDate      - date    Дата получения дохода
  @param[in] IncTime      - time    Время получения дохода
  @param[in] id_operation - integer id операции
  @return - string ID в хран. СНОБ в случае успеха
*/
macro ExecGetIdSNOB_STB(ClientID:integer, IncDate:date, IncTime:time, TBId:integer):string
  var Request = c_GetAmountSNOBRequest();
  var party = TRecHandler("party.dbt");
  var Year = 0;
  var srorId = "";

  datesplit(IncDate, null, null, Year);

  Request.GetAmountSNOBReq = c_GetAmountSNOBReq();
  Request.GetAmountSNOBReq.IsActivRecord      = true; //Только подтвержденные записи
  Request.GetAmountSNOBReq.IsSNOB             = false;
  Request.GetAmountSNOBReq.ClientId           = c_IntegrationSymbolicIdentifierXType();
  Request.GetAmountSNOBReq.ClientId.ObjectID  = ClientID;
  Request.GetAmountSNOBReq.TaxYear            = Year;

  InitProgress(-1, "Выполнение запроса к Хранилищу СНОБ", "Запрос к Хранилищу СНОБ");
  var Resp = GetAmountSNOBReq(Request);
  RemProgress();

  var isOk = true;
  if((Resp == NULL) or (ValType(Resp) != V_GENOBJ) or (ValType(Resp.GetAmount) == V_UNDEF) or (ValType(Resp.GetAmount.RecordInfoList) == V_UNDEF) or
      ((ValType(Resp.ErrorList) != V_UNDEF) and (Resp.ErrorList.size > 0) and (string(trim(Resp.ErrorList[0].ErrorCode))) != "0")
    )
    isOk = false;
    if(((ValType(Resp.ErrorList) != V_UNDEF) and (Resp.ErrorList.size > 0) and (string(trim(Resp.ErrorList[0].ErrorCode))) != "0"))
      msgbox("Ошибка " + string(trim(Resp.ErrorList[0].ErrorCode)) + ": " + string(trim(Resp.ErrorList[0].ErrorDesc)));
    end;
  end;

  if(isOK)
    if(Resp.GetAmount.RecordInfoList.Size > 0)
      var i = 0;

      InitProgress(Resp.GetAmount.RecordInfoList.Size, "Обработка полученных данных", "Обработка полученных данных");

      while(i < Resp.GetAmount.RecordInfoList.Size)
        if( Resp.GetAmount.RecordInfoList[i].EventId.ObjectID == TBId )
          srorId = Resp.GetAmount.RecordInfoList[i].RecordId.ObjectID;
          break;
        end;

        UseProgress(i = i + 1);
      end;

      RemProgress();
    end;

    if (srorId == "")
      msgbox("Запись не найдена");
    end;
  end;

end;


/**
  @brief Выполнить отмену для одной записи СНОБ
  @param[in] StorID      - string идентификатор отменяемой записи в Хранилище
  @param[in] skipChek21  - bool игнорирование ошибки "Запись в хранилище СНОБ ранее уже была переведена в отмененные"
  @return 0 в случае успеха
*/
macro ExecSinglCancelStorSTB(StorID:string, skipChek21:bool, showSucsessMess:bool):integer
  var ChngReq = NULL;
  var ErrStr = "";
  var stat = 1;

  ChngReq = c_ChangeStatusSNOBRequest;

  ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList = TArray;

  var sz = ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList.size;
  
  ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz] = c_ChangeStatusInfo();
  
  ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordID = c_IntegrationSymbolicIdentifierXType();
  ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordID.ObjectID = StorID;
  
  ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordStatus = c_IntegrationDictionaryRecordXType();
  ChngReq.ChangeStatusSNOBReq.ChangeStatusInfoList[sz].RecordStatus.RecordCode = string(NPTXTOTALBASE_STORSTATE_CANCELED);

  var ChngResp = ChangeStatusSNOBReq(ChngReq); ///<Отправляем запрос в Хранилище

  ///Если Хранилище не прислало ответ или прислало ошибку, то выводим её на экран
  if ( (ChngResp == NULL) or (ValType(ChngResp) != V_GENOBJ) or
        (ChngResp.ChangeStatusInfoList == NULL) or
        (ChngResp.ChangeStatusInfoList.size == 0)
      )
      if( (ChngResp != NULL) and (ChngResp.ErrorList != NULL) and (ChngResp.ErrorList.size > 0) )
        ErrStr = "Ошибка при обработке ответа от Хранилища СНОБ. Код ошибки: "+string(trim(ChngResp.ErrorList[0].ErrorCode))+" " + string(trim(ChngResp.ErrorList[0].ErrorDesc));
      else
        //Не получен ответ от Хранилища СНОБ
        ErrStr = "Подтверждение об отмене не получено. Отмена записи возможна только при подтверждающем сообщении об отмене от хранилища СНОБ";
      end;
  else
      if((ChngResp.ErrorList != NULL) and (ChngResp.ErrorList.size > 0) and (ChngResp.ErrorList[0].ErrorCode != "0") and (ChngResp.ErrorList[0].ErrorCode != "000"))
        ErrStr = "Ошибка при обработке ответа от Хранилища СНОБ. Код ошибки: "+string(trim(ChngResp.ErrorList[0].ErrorCode))+" " + string(trim(ChngResp.ErrorList[0].ErrorDesc));
      end;
  end;

  //Если объекты всё же пришли, но также пришла ошибка
  if (ErrStr == "")
    if( skipChek21 and (ChngResp.ChangeStatusInfoList[0].Error.ErrorCode == ERR_SNOB_21) )
      ErrStr = ""; //Запись в хранилище СНОБ ранее уже была переведена в отмененные
    elif( (ChngResp.ChangeStatusInfoList[0].Error.ErrorCode != "0") and (ChngResp.ChangeStatusInfoList[0].Error.ErrorCode != "000") )
      ErrStr = "Ошибка: "+string(trim(ChngResp.ChangeStatusInfoList[0].Error.ErrorDesc))+" Код ошибки: "+string(trim(ChngResp.ChangeStatusInfoList[0].Error.ErrorCode)) ;
    end;
  end;

  if(ErrStr != "") 
    msgbox(ErrStr);
    stat = 1;
  else
    if (showSucsessMess)
      msgbox("Запись успешно отменена!");
    end;
    stat = 0;
  end;
  
  return stat;
end;

OnError(er)
  msgbox("Ошибка: " + er.Message);

  return 1;
end;




