/*                                                                         */
/*            Copyright (c) R-Style Software Lab Ltd. 1998                 */
/*                                                                         */
/* Функции для подсистемы МБП                          В.В.Денисенков      */
/*                                                                         */
/*  FUN_LVM.MAC                                                            */
/*                                                                         */
/* ************************************************************************ */

import "namecurr.mac" ,
       "clientba.mac" ,
       LvmGlVar;

/* *********************************************************************** */
/* Объявления файлов */
file  cardwar_fun_lvm     ("cardwar.dbt",  "pchs.def");
file  doc_fun_lvm         ("docpch.dbt",   "pchs.def");
file  rsoutlvm0_fun_lvm   ("rsoutlvm.dbt", "pchs.def")     key 0;  /* Cod */
file  invnum_fun_lvm      ("warnumb.dbt",  "pchs.def");
file  invlco_fun_lvm      ("invhilco.dbt", "pchs.def");
file  currwh_fun_lvm      ("currwh.dbt",   "pchs.def");
file  lncarinv_fun_lvm    ("lncarinv.dbt", "pchs.def");
                 
file  kindrel0_fun_lvm    ("kindrel.dbt",  "crm.def")  key 0;  /* Cod */
file  ware_fun_lvm        ("ware.dbt",     "balance.def");

file  lsht0_fun_lvm       ("lsheet.dbt",   "zp.def")       key 0;  /* Tnumb */
file  post0_fun_lvm       ("post.dbt",     "zp.def")       key 0;
file  prof0_fun_lvm       ("profess.dbt",  "zp.def")       key 0;

/* *********************************************************************** */

/*-------------------------*/
/*    Выбор имени типа документа. МБП 14 символ */
MACRO PutShortNameBankDoc ( DocType )
 if  ( DocType == 1  ) return "Проведенный";
 elif( DocType == 2  ) return "Архивный";
 elif( DocType == 3  ) return "Планируемый";
 elif( DocType == 4  ) return "Отложенный";
 elif( DocType == -1 ) return "Счет-фактура";
 end;
END;
/*    Выбор имени типа документа. МБП 14 символ */
MACRO PutShortNameDoc ( DocType )
 if  ( DocType == 0  ) return "Прих.накл-я";
 elif( DocType == 1  ) return "Акт прих-ый";
 elif( DocType == 2  ) return "Акт расх-ый";
 elif( DocType == 3  ) return "Акт с/р-приход";
 elif( DocType == 4  ) return "Акт с/р-расход";
 elif( DocType == 5  ) return "Акт инв.приход";
 elif( DocType == 6  ) return "Акт инв.расход";
 elif( DocType == 7  ) return "Акт в экспл-ию";
 elif( DocType == 8  ) return "Акт из эксп-ии";
 elif( DocType == 9  ) return "Акт перемещ-я";
 elif( DocType == 10 ) return "Акт износа";
 elif( DocType == 11 ) return "Акт переоц-ки";
 elif( DocType == 12 ) return "Акт спис-я";
 elif( DocType == 13 ) return "Акт пер-ия экс";
 elif( DocType == 14 ) return "Акт в ОФ";
 end;
END;

/*    Выбор имени типа документа.  21 символ */
macro PutNameDoc( op )
 if  ( op == 1  ) return "приход";
 elif( op == 2  ) return "расход";
 elif( op == 3  ) return "сб/рзб-приход";
 elif( op == 4  ) return "сб/рзб-расход";
 elif( op == 5  ) return "инвентаризация-приход";
 elif( op == 6  ) return "инвентаризация-расход";
 elif( op == 7  ) return "ввод в эксплуатацию";
 elif( op == 8  ) return "вывод из эксплуатации";
 elif( op == 9  ) return "перемещение скл.";
 elif( op == 10 ) return "начисление износа";
 elif( op == 11 ) return "переоценка";
 elif( op == 12 ) return "списание";
 elif( op == 13 ) return "перемещение эксп.";
 elif( op == 14 ) return "ввод в экспл-цию ОФ";
 end;
end;

/* ************************************************************************ */

/*    Выбор полного имени типа документа.  26 символ */
macro PutFullNameDoc( op )
 if  ( op == 1  ) return "акт прихода";
 elif( op == 2  ) return "акт расхода";
 elif( op == 3  ) return "акт сборки/разборки-приход";
 elif( op == 4  ) return "акт сборки/разборки-расход";
 elif( op == 5  ) return "акт инвентаризации-приход";
 elif( op == 6  ) return "акт инвентаризации-расход";
 elif( op == 7  ) return "акт ввода в эксплуатацию";
 elif( op == 8  ) return "акт вывода из эксплуатации";
 elif( op == 9  ) return "акт перемещения на скл.";
 elif( op == 10 ) return "акт начисления износа";
 elif( op == 11 ) return "акт переоценки";
 elif( op == 12 ) return "акт списания";
 elif( op == 13 ) return "акт перемещения в эксп.";
 elif( op == 14 ) return "акт ввода в экспл-цию ОФ";
 end;
end;


/* ************************************************************************ */

/* Выбор типа положения. 7 символов */
macro GetShortNameWhLvm( state )
  if  ( State == 1 ) return "на скл.";
  elif( State == 2 ) return "в эксп.";
  else               return "";
  end;
end;
/* Выбор типа положения. 14 символов */
macro GetNameWhLvm( state )
  if  ( State == 1 ) return "на складе";
  elif( State == 2 ) return "в эксплуатации";
  else               return "";
  end;
end;

/* ************************************************************************ */

/* Выбор типа положения. 18 символов */
macro CetNameFullWhLvm( state )
  if  ( State == 1 ) return "на складе";
  elif( State == 2 ) return "в эксплуатации";
  elif( State == 3 ) return "был на складе";
  elif( State == 4 ) return "был в эксплуатации";
  else               return "";
  end;
end;

/* ************************************************************************ */

/* Выбор типа положения. 14 символов */
macro CetNameTypePos( pos )
  if  ( pos == 1 ) return "на складе";
  elif( pos == 2 ) return "в эксплуатации";
  elif( pos == 0 ) return "на предприятии";
  else                    return "";
  end;
end;

/* ************************************************************************ */

macro GetNameWh( State )
  if  ( (State == 1) or (State == 3) ) return "склад";
  elif( (State == 2) or (State == 4) ) return "отдел";
  else               return "";
  end;
end;

/* ************************************************************************ */

/*    Выбор имени типа операции  */
macro PutOper( op )
 if  ( op == 0  ) return "прихода ";
 elif( op == 1  ) return "сборки ";
 elif( op == 2  ) return "расхода ";
 elif( op == 3  ) return "разборки ";
 elif( op == 4  ) return "списания ";
 elif( op == 5  ) return "внутреннего перемещения";
 elif( op == 6  ) return "вывода из эксплуатации";
 elif( op == 7  ) return "ввода в эксплуатацию";
 elif( op == 8  ) return "ввода в эксплуатацию с начислением износа";
 elif( op == 9  ) return "начисление износа";
 elif( op == 10 ) return "переоценки";
 end;
end;

/* *********************************************************************** */

/* Наименование видов договорных отношений по коду  */
macro GetKindRelName( Cod )
var   stat;

 kindrel0_fun_lvm.Numb = Cod;
 stat = GetEQ( kindrel0_fun_lvm );
 if( stat ) return kindrel0_fun_lvm.Name;
 else       return "";
 end;
end;


/* *********************************************************************** */
/*  Поиск причины выбытия по коду (сокращенное имя)  */
macro ResOutCompressName( Cod )
var stat;

 rsoutlvm0_fun_lvm.Cod = Cod;
 stat = GetEQ( rsoutlvm0_fun_lvm );
 if( stat ) return rsoutlvm0_fun_lvm.Compress_Name;
 else       return "";
 end;
end;

/*  Поиск причины выбытия по коду (полное имя)  */
macro ResOutName( Cod )
var stat;

 rsoutlvm0_fun_lvm.Cod = Cod;
 stat = GetEQ( rsoutlvm0_fun_lvm );
 if( stat ) return rsoutlvm0_fun_lvm.Name;
 else       return "";
 end;
end;


/* *********************************************************************** */
/* Связь с зарплатой и кадрами */

/* Должность сотрудника */
MACRO GetPost(Numb)

  post0_fun_lvm.Numb = Numb;
  if( GetEQ(post0_fun_lvm) )  return post0_fun_lvm.Name;
  else                        return "";
  end;

END;

/* Профессия */
macro GetProf( Numb )

  prof0_fun_lvm.Numb = Numb;
  if( GetEQ( prof0_fun_lvm ) )  return prof0_fun_lvm.Name;
  else                          return "";
  end;

end;

/***************************************************************************/
/* Фамилия МОЛ */
MACRO GetMOLName(Numb)

  lsht0_fun_lvm.Tnumb = Numb ;
  if( GetEQ(lsht0_fun_lvm) )  return lsht0_fun_lvm.Surname ;
  else                        return  "" ;
  end ;
END ;


/* Фамилия и инициалы МОЛ */
MACRO MOLNameNS(lsht) : STRING
  return  String(lsht.Surname, " ", SubStr(lsht.Name, 1, 1), ".",
                                    SubStr(lsht.Patronymic, 1, 1), "." );
END;

MACRO GetMOLNameNS(Numb)
  lsht0_fun_lvm.Tnumb = Numb ;
  if( GetEQ(lsht0_fun_lvm) )
          return  MOLNameNS(lsht0_fun_lvm);
  else    return  "" ;
  end;
END;


/* Фамилия, имя, отчество МОЛ */
MACRO FullMOLNameNS(lsht) : STRING
  return  lsht.Surname + " " + lsht.Name + " " + lsht.Patronymic;
END;

MACRO GetFullMOLNameNS(Numb)
  lsht0_fun_lvm.Tnumb = Numb ;
  if( GetEQ(lsht0_fun_lvm) )
          return  FullMOLNameNS(lsht0_fun_lvm);
  else    return  "" ;
  end;
END;
/***************************************************************************/

/*---------------------------------------------------------------------------*/
/* Наименование МБП                                                          */
/*---------------------------------------------------------------------------*/
MACRO GetWareName(Numb)

  KeyNum(ware_fun_lvm, 0);         /* Ware */

  ware_fun_lvm.Ware = Numb ;
  if( GetEQ(ware_fun_lvm) )  return ware_fun_lvm.Name_Ware ;
  else                       return "" ;
  end;

END;

/*-------------------------------------------*/
/* Обрезание строки символов по целым словам */
/* до длины не более FieldLen символов.      */
/* (Smirnov)                                 */
/*-------------------------------------------*/
macro TrnStrWholeWord( Str, FieldLen )
   var TrnLen=0, pos=1, TrimStr;
   TrimStr = Trim( Str );
   if(StrLen(TrimStr)==0)
      return " ";
   end;
   if(StrLen(TrimStr)<=FieldLen)
      return TrimStr;
   end;
   while( (TrnLen <= (FieldLen+1)) and (pos != 0) )
      pos = Index( SubStr(TrimStr,TrnLen+1), " " );
      if( pos != 0 )
         TrnLen = TrnLen + pos ;
      end;
   end;
   TrnLen=TrnLen-pos;
   if( (TrnLen!=0) and (TrnLen<=(FieldLen+1) ) )
      return SubStr( Trim(TrimStr), 1, TrnLen-1 );
   else
      return SubStr( Trim(TrimStr), 1, FieldLen );
   end;
end;

/*---------------------------------------------*/
/* Разрезание строки символов по целым словам  */
/* на части не более FieldLen символов длиной. */
/* Результат помещается в массив NStr (Smirnov)*/
/*---------------------------------------------*/
macro CutStrWholeWord( Str, FieldLen, NStr )
   var TrimStr, i=0, CurPos=1;
   var STmp ;
   TrimStr = Trim( Str );
   while(  ( NStr(i) = TrnStrWholeWord( TrimStr, FieldLen) ) != " " )
/*      NStr(i) = sTmp ;*/
      TrimStr=Trim( SubStr( TrimStr, StrLen( NStr(i) )+1 ) );
      i=i+1;
   end;
   if(i == 0)
     NStr(0) = "";
     i = 1;
   end;
   return i;
end;
/*-------------------------------------------------------------------------*/
/* CutAStrWholeWord :   Разрезание массива строк по целым словам           */
/*                      на части не более FieldLen символов длиной.        */
/*                      Результат помещается в массив NStr                 */
/*-------------------------------------------------------------------------*/
macro CutAStrWholeWord( aStr     ,    /*  Исходный массив                  */
                        FieldLen ,    /*  Длина строки                     */
                        NStr          /*  Конечный массив                  */
                      )

var TrimStr     ;
var STmp        ;
var i = 0, j = 0, CurPos = 1, BreakPos = 0, StartPos = 0 ;
var aStrSize    ;
var TmpFieldLen = FieldLen ;
var tmpStr      ;

   NStr(0)   = "";
   aStrSize  = Asize ( aStr ) ;
   TrimStr   = Trim( aStr(j) );

   while ( j < aStrSize )
      tmpStr      = TrnStrWholeWord( TrimStr, TmpFieldLen) ;
      if ( ( tmpStr == " " ) and ( TmpFieldLen != FieldLen ) )
         i = i + 1 ;
         NStr(i)     = "";
         TmpFieldLen = FieldLen ;
         tmpStr      = TrnStrWholeWord( TrimStr, TmpFieldLen) ;
      end;
      NStr(i)     = String ( NStr(i), tmpStr ) ;
      StartPos    = StrLen ( tmpStr ) ;

      TmpFieldLen = FieldLen ;

      while(  NStr(i) != " " )
         TrimStr = Trim   ( SubStr( TrimStr, StartPos + 1 ) );
         i       = i + 1 ;
         NStr(i) = TrnStrWholeWord( TrimStr, TmpFieldLen) ;
         StartPos= StrLen ( NStr(i) ) ;
      end;
      j = j + 1 ;
      if ( j < aStrSize )
         NStr(i) = ""    ;
/*         i       = i - 1 ;*/
         TrimStr = Trim( aStr(j) );
         BreakPos = FieldLen - StrLen ( NStr(i-1) ) ;
/*         Index ( TrimStr, " " );*/
         if ( BreakPos > 4 )
            i = i - 1 ;
            TmpFieldLen = BreakPos;
         end;
      end ;
   end;

return i;
end;

MACRO DD_MM_YY ( Date )
var Day, Month, Year ;
var sDay, sMonth, sYear ;
var sDate ;

DateSplit ( Date, Day, Month, Year ) ;
if ( Day < 10 )
  sDay = String ( "0", Day ) ;
else
  sDay = String (  Day ) ;
end ;
if ( Month < 10 )
  sMonth = String ( "0", Month ) ;
else
  sMonth = String (  Month ) ;
end ;

sYear = SubStr  ( String ( Year ), 3, 2 );

sDate = String ( sDay,".",sMonth,".",sYear ) ;

RETURN sDate ;
END ;

MACRO MonthName( i )
   Array Months;
   Months(  0 ) = "Января";                 Months(  1 ) = "Февраля";
   Months(  2 ) = "Марта";                  Months(  3 ) = "Апреля";
   Months(  4 ) = "Мая";                    Months(  5 ) = "Июня";
   Months(  6 ) = "Июля";                   Months(  7 ) = "Августа";
   Months(  8 ) = "Сентября";               Months(  9 ) = "Октября";
   Months( 10 ) = "Ноября";                 Months( 11 ) = "Декабря";
      if( (ValType( i ) == V_INTEGER) AND (i>=1) AND (i<=12) )
              return  Months( i-1 );
      else return "";
      end;
END;

MACRO Date6 ( Date )

var sDay, sMonth, sYear ;
var  Day,  Month,  Year ;

   DateSplit ( Date, Day, Month, Year ) ;
   sDay   = Day   ;
   sMonth = Month ;
   if ( Day < 10 )
     sDay = String("0",Day);
   end;
   if ( Month < 10 )
     sMonth = String("0",Month);
   end;
   sYear  = SubStr ( String(Year),3,2) ;

RETURN String(sDay,sMonth,sYear);
END;

MACRO LifeInMonth ( DateB, DateD )

var  DayB,  MonthB,  YearB ;
var  DayD,  MonthD,  YearD ;
var  DayL,  MonthL,  YearL ;
var  fMonth ;
   DateSplit ( DateB, DayB, MonthB, YearB ) ;
   DateSplit ( DateD, DayD, MonthD, YearD ) ;

   YearL  = YearD - YearB ;
   if ( MonthD < MonthB )
      YearL  = YearL - 1 ;
      MonthL = 12 - MonthB + MonthD ;
   else
      MonthL = MonthD - MonthB ;
   end;

   if ( DayD < DayB )
      MonthL = MonthL - 1 ;
      DayL   = 30 - DayB + DayD ;
   else
      DayL   = DayD - DayB ;
   end;

   fMonth = YearL * 12 + MonthL + DayL/30. ;
RETURN fMonth;
END;

/***************************************************************************/

/* Сортировка по возростанию методом пузырька.                             */
MACRO SortingOnGrowth(Arr)
var  flag = 1, tmp, i,j;
var  arrSize = Asize(Arr);

  i = 1;
  while(flag and (i < arrSize) )
    flag = 0;
    j    = arrSize - 1;
    while(j >= i)
      if( Arr(j-1) > Arr(j) )
         tmp      = Arr(j-1);
         Arr(j-1) = Arr(j);
         Arr(j)   = tmp;
         flag = 1;
      end;
      j = j - 1;
    end;
    i = i + 1;
  end;

END;

/* Сортировка по убыванию методом пузырька */
MACRO SortingOnDecrease(Arr)
var  flag = 1, tmp, i,j;
var  arrSize = Asize(Arr);

  i = 1;
  while(flag and (i < arrSize) )
    flag = 0;
    j    = arrSize - 1;
    while(j >= i)
      if( Arr(j-1) < Arr(j) )
         tmp      = Arr(j-1);
         Arr(j-1) = Arr(j);
         Arr(j)   = tmp;
         flag = 1;
      end;
      j = j - 1;
    end;
    i = i + 1;
  end;

END;

/***************************************************************************/

/* Для совместимости с другими макросами. В дальнейшем использовать напрямую*/
MACRO SortInvArray ( aInvNumb )
    SortingOnGrowth(aInvNumb)
END;


/* Заполнение массива aInvNumb инвентарными номерами с карточки AkeyCard.
// Учитываются только номера, которые есть сейчас (в текущий ОДБ) на карточке.
// FirstIndex - номер элемента массива, с которого начинается заполнение  */
MACRO MakeInvArrayAC (AkeyCard, aInvNumb, FirstIndex)
 var   i = FirstIndex;
 var   stat;

 KeyNum(invnum_fun_lvm, 1);         /* AkeyCard */

 invnum_fun_lvm.AkeyCard = AkeyCard;
 stat = GetEQ (invnum_fun_lvm);

 while(stat and (AkeyCard == invnum_fun_lvm.AkeyCard) )
   if( {GL_LvmInvType} )
      aInvNumb(i) = invnum_fun_lvm.Inv_Numb;
   else
      aInvNumb(i) = int(invnum_fun_lvm.Inv_Numb);
   end;
   i = i + 1;
   stat = Next (invnum_fun_lvm);
 end;

 return Asize(aInvNumb);

END;


/* Найти инвентарный и серийный номер по Autokey */
MACRO FindInvNumbByAKey(iNumAKey, invNumb, serNumb)
  var stat, tmp;
  KeyNum(invnum_fun_lvm, 0);           /* Autokey */
  invnum_fun_lvm.Autokey = iNumAKey;
  stat = GetEQ (invnum_fun_lvm);
  if(stat)
    if(getparm(1,tmp))
      if( {GL_LvmInvType} )
        setparm(1, invnum_fun_lvm.Inv_Numb);
      else
        setparm(1, int(invnum_fun_lvm.Inv_Numb));
      end;
    end;
    if(getparm(2,tmp))
      setparm(2, invnum_fun_lvm.Ser_Numb);
    end;
  end;
  return stat;
END;


/* Добавление в массив AInvAKey инвентарных номеров (AutoKey) с карточки AkeyCard.
// Учитываются номера, которые есть сейчас (в текущий ОДБ) на карточке,
// и те, которые когда-то были на ней.
*/
MACRO MakeInvAKeyArrayNextCard(autoKeyCard, AInvAKey)
  var stat;

  KeyNum(lncarinv_fun_lvm, 0);         /* TypCard + IdCard + IdInvNumb */

  lncarinv_fun_lvm.TypCard   = 1;
  lncarinv_fun_lvm.IdCard    = autoKeyCard;
  lncarinv_fun_lvm.IdInvNumb = 0;
  stat = GetGE (lncarinv_fun_lvm);
  while(stat  and
        (lncarinv_fun_lvm.TypCard == 1)         and
        (lncarinv_fun_lvm.IdCard == autoKeyCard)   )
    AInvAKey(ASize(AInvAKey)) = lncarinv_fun_lvm.IdInvNumb;
    stat = Next (lncarinv_fun_lvm);
  end;

END;


/* Добавление в массив aInvNumb инвентарных номеров с карточки AkeyCard.
// Учитываются номера, которые есть сейчас (в текущий ОДБ) на карточке,
// и те, которые когда-то были на ней.
*/
MACRO MakeInvArrayNextCard(autoKeyCard, AInvNumb)
  var i, invNumb, stat;
  array AInvAKey;

  MakeInvAKeyArrayNextCard(autoKeyCard, AInvAKey);

  i = 0;
  while(i < ASize(AInvAKey))
    stat = FindInvNumbByAKey(AInvAKey(i), invNumb);
    if(stat)
      AInvNumb(ASize(AInvNumb)) = invNumb;
    end;
    i = i + 1;
  end; 

END;


/* Отличие от предыдущей функции (MakeInvArrayNextCard):
// Учитываются только номера, которые были на карточке до определенной даты включительно.
// ("Ушли" после этой даты)
*/
MACRO MakeInvArrayNextCardBeforeDate(autoKeyCard, date, AInvNumb)
  var stat, i, invNumb;
  array AInvAKey;    /* Номера со "следующей" карточки */

  KeyNum(cardwar_fun_lvm, 8);          /* Akey_Prev */

  MakeInvArrayAC(autoKeyCard, AInvNumb, ASize(AInvNumb));

  cardwar_fun_lvm.Akey_Prev = autoKeyCard;
  stat = GetEQ(cardwar_fun_lvm);
  while(stat and (cardwar_fun_lvm.Akey_Prev == autoKeyCard) )
    if(cardwar_fun_lvm.Date > date)

      /* Номера (autoKey) со "следующей" карточки */
      ASize(AInvAKey, 0);
      MakeInvAKeyArrayNextCard(cardwar_fun_lvm.Autokey, AInvAKey);

      /* Проверка, были ли эти номера на карточке autoKeyCard */
      KeyNum(lncarinv_fun_lvm, 0);         /* TypCard + IdCard + IdInvNumb */
      i = 0;
      while(i < ASize(AInvAKey))
        lncarinv_fun_lvm.TypCard   = 1;
        lncarinv_fun_lvm.IdCard    = autoKeyCard;
        lncarinv_fun_lvm.IdInvNumb = AInvAKey(i);
        stat = GetEQ (lncarinv_fun_lvm);
        if(stat)
          stat = FindInvNumbByAKey(AInvAKey(i), invNumb);
          if(stat)
            AInvNumb(ASize(AInvNumb)) = invNumb;
          end;
        end;
        i = i + 1;
      end;

    end;
    stat = Next(cardwar_fun_lvm);
  end;

END;


/* Формирование массива диапазонов инвентарных номеров в строковом виде */
MACRO MakeInvStr ( aInvNumbStr,aInvNumb )
var   TmpInvNumb, IN1=0, IN2=0 ;
var   aINS        = 0 ;

var   aInvNumbSize    ,
      aInvNumbStrSize       ;
var   i               = 1   ;

aInvNumbStr(aINS) = "";

  aInvNumbSize = Asize ( aInvNumb ) ;

  if ( {GL_LvmInvType} )
     IN1 = aInvNumb(0) ;
     while ( i < aInvNumbSize )
        if ( aInvNumb(i) != aInvNumb(i-1) )
           aInvNumbStr(aINS) = String(aInvNumbStr(aINS), String (IN1, ", "));

           IN1 = aInvNumb(i) ;
        end;
        i = i + 1 ;
        if ( StrLen ( aInvNumbStr(aINS) ) > 200 )
           aINS = aINS + 1 ;
           aInvNumbStr(aINS)="";
        end;
     end;
     if ( i == aInvNumbSize )
        aInvNumbStr(aINS) = String(aInvNumbStr(aINS), String (IN1));
     end;
  else
     IN1 = int(aInvNumb(0)) ;
     IN2 = int(IN1) ;
     while ( i <= aInvNumbSize )
        if ( IN2+1 == int(aInvNumb(i)) )
           IN2 = int(aInvNumb(i)) ;
           if ( i == aInvNumbSize )
              aInvNumbStr(aINS) = String(aInvNumbStr(aINS), String (IN1," - ",IN2));
           end;
        else
           if ( int(aInvNumb(i)) != int(aInvNumb(i-1)) )
              if ( IN1 == IN2 )
                 aInvNumbStr(aINS) = String(aInvNumbStr(aINS), String (IN1));
              else
                 aInvNumbStr(aINS) = String(aInvNumbStr(aINS), String (IN1," - ",IN2));
              end;
              IN1 = int(aInvNumb(i)) ;
              IN2 = int(IN1) ;
              if ( i < aInvNumbSize )
                 aInvNumbStr(aINS) = String(aInvNumbStr(aINS), ", ");
/*              else
                 aInvNumbStr(aINS) = String(aInvNumbStr(aINS), String (IN1));*/
              end;
           end;
        end;
        i = i+1;
        if ( StrLen ( aInvNumbStr(aINS) ) > 200 )
           aINS = aINS + 1 ;
        end;
     end;
  end;

  aInvNumbStrSize = Asize ( aInvNumbStr ) ;


RETURN aInvNumbStrSize ;
END;

MACRO GetInvNumbStr ( AkeyCard, aInvNumbStr )

array aInvNumb           ;
var   aInvNumbStrSize = 0;

aInvNumbStr(0) = "";


  MakeInvArrayAC ( AkeyCard, aInvNumb, 0 ) ;

  SortingOnGrowth ( aInvNumb ) ;

  aInvNumbStrSize = MakeInvStr ( aInvNumbStr,aInvNumb ) ;



RETURN aInvNumbStrSize ;
END;

MACRO MakeInvArrayMOL ( Ware     ,
                        MOL      ,
                        OfficeID,
                        state    ,
                        aInvNumb
                      )
var   i          = 0        ;
var   aInvNumbSize          ;
var   Stat                  ;
var   AddFlag;

  KeyNum(cardwar_fun_lvm, 4);         /* MOL+W+..  */

  cardwar_fun_lvm.Ware      = Ware;
  cardwar_fun_lvm.Owner     = MOL;
  cardwar_fun_lvm.PartyID   = {SelfID};
  cardwar_fun_lvm.OfficeID  = OfficeID;
  cardwar_fun_lvm.Akey_Comp = 0;
  cardwar_fun_lvm.state     = state;
  cardwar_fun_lvm.Date      = Date ( 0,0,0 );

  Stat = GetGE ( cardwar_fun_lvm ) ;

  while (  Stat                        and
          (cardwar_fun_lvm.Owner    == MOL )     and
          (cardwar_fun_lvm.PartyID  == {SelfID}) and
          (cardwar_fun_lvm.OfficeID == OfficeID) and
          (cardwar_fun_lvm.state    == state)    and
          (cardwar_fun_lvm.Ware     == Ware)        )

     aInvNumbSize = MakeInvArrayAC ( cardwar_fun_lvm.Autokey, aInvNumb, i ) ;
     i = aInvNumbSize ;

     Stat = Next ( cardwar_fun_lvm ) ;
  end ;

  aInvNumbSize = Asize ( aInvNumb ) ;

  RETURN aInvNumbSize

END;


MACRO GetInvNumbStrMOL ( Ware ,
                         MOL  ,
                         OfficeID,
                         state,
                         aInvNumbStr
                       )
array aInvNumb              ;
var   aInvNumbStrSize = 0;

  aInvNumbStr(0) = "";

  MakeInvArrayMOL ( Ware, MOL, OfficeID, state, aInvNumb ) ;

  SortingOnGrowth ( aInvNumb ) ;

  aInvNumbStrSize = MakeInvStr ( aInvNumbStr,aInvNumb ) ;

RETURN aInvNumbStrSize ;
END;

/* ************************************************************************ */
/* Поиск в массиве Arr элемента Elem */
/* Возвращаемое значение: TRUE - элемент есть; FALSE - элемента нет */
macro FindInArray(Arr, elem)
var i = 0, arrSize = Asize(Arr);

  while(i < arrSize)
     if(elem == Arr(i))  return TRUE;  end;
     i = i + 1;
  end;
  return FALSE;

end;

/* Добавление в массив Arr нового элемента Elem, если такого там еще нет */
/* Возвращаемое значение: TRUE - элемент был; FALSE - элемента не было */
macro AddInArray(Arr, elem)

  if(FindInArray(Arr, elem) == TRUE)
    return TRUE;
  else
    Arr(Asize(Arr)) = elem;
    return FALSE;
  end;

end;

/***************************************************************************/
/* Вычисление количества МБП с карточки card,                              */
/* оставшегося на заданную дату targetDate (на вечер даты)                 */
MACRO CalcDateQuantity(card, targetDate)
 var stat, dateCardQuantity = card.DocQuant;

 KeyNum(cardwar_fun_lvm, 8);         /* Akey_Prev */

 cardwar_fun_lvm.Akey_Prev = card.Autokey;
 stat = GetEQ(cardwar_fun_lvm);
                           /* цикл по Akey_Prev */
 while(stat and (cardwar_fun_lvm.Akey_Prev == card.Autokey) )
    if(cardwar_fun_lvm.Date <= targetDate)
       dateCardQuantity = dateCardQuantity - cardwar_fun_lvm.DocQuant;
    end;
    stat = Next(cardwar_fun_lvm);
 end;
 return dateCardQuantity;
END;

/***************************************************************************/
/* Получить NumbSymb символов года                                         */
MACRO GetNumYear(NumbSymb)
      Var Year, d = {curdate};

      DateSplit ( d, null, null, Year );
/*      Year = Int( Year/Double(Pow(10,NumbSymb)) );   */
      Year = SubStr(String(Year), 1, NumbSymb);

      return Year;
END;


/***************************************************************************/
/* Получить максимальную дату в базе doclvm.dbt */
MACRO GetMaxDate()
  var stat;

  KeyNum(doc_fun_lvm, 8);         /* Date + Autokey */

  stat = next(doc_fun_lvm);
  rewind(doc_fun_lvm);
  stat = prev(doc_fun_lvm);               /* Ищем последнюю запись */
  if(stat)   return  doc_fun_lvm.Date;    /* Максимальная дата */
  else       return  Date(0,0,0);         /* ??? Или лучше текущую ??? */
  end;

END;


/* *********************************************************************** */
/* Вспомогательные функции для работы с типами положений */

/* Перевести положение в "есть" */
MACRO StateToNow(state)
  if(state == STATE_OLDINUSE)
    return  STATE_INUSE;
  elif(state == STATE_OLDWAREH)
    return  STATE_WAREH;
  else
    return state;
  end;
END;

/* Перевести положение в "был" */
MACRO StateToOld(state)
  if(state == STATE_INUSE)
    return  STATE_OLDINUSE;
  elif(state == STATE_WAREH)
    return  STATE_OLDWAREH;
  else
    return state;
  end;
END;

/* Проверить положение на "есть" */
MACRO CheckStateNow(state)
  if((state == STATE_INUSE)  or  (state == STATE_WAREH))
          return  TRUE;
  else    return  FALSE;
  end;
END;

/* Проверить положение на "был" */
MACRO CheckStateOld(state)
  if((state == STATE_OLDINUSE)  or  (state == STATE_OLDWAREH))
          return  TRUE;
  else    return  FALSE;
  end;
END;

/* Вспомогательные функции для работы с типами положений */
/* *********************************************************************** */


/* *********************************************************************** */
/* Массив инвентарных номеров на позиции инвентаризационной описи */
MACRO MakeInvArrayInPosOpis(opisAKey, invDate, INumArr)
  var stat;

  KeyNum(invlco_fun_lvm, 0);         /* OpisAkey + CardAkey */

  invlco_fun_lvm.OpisAkey = opisAKey;
  invlco_fun_lvm.CardAkey = 0;
  stat = GetGE(invlco_fun_lvm);
  while(stat  and  (invlco_fun_lvm.OpisAkey == opisAKey))

    KeyNum(cardwar_fun_lvm, 0);        /* Autokey */
    cardwar_fun_lvm.Autokey = invlco_fun_lvm.CardAkey;
    stat = GetEQ(cardwar_fun_lvm);
    if(stat)
      MakeInvArrayNextCardBeforeDate(cardwar_fun_lvm.Autokey, invDate-1, INumArr);
    end;

    stat = Next(invlco_fun_lvm);
  end;

  SortingOnGrowth(INumArr);

END;


/***************************************************************************/
/* Проверка существования товара ware в базах МБП
// (по файлу currwh.dbt)
*/
MACRO CheckWareInCurrLVM(ware) : BOOL
  var stat;

  KeyNum(currwh_fun_lvm, 0);         /* Ware + ... */

  currwh_fun_lvm.Ware       = ware;
  currwh_fun_lvm.Akey_Comp  = 0;
  currwh_fun_lvm.Owner      = 0;
  currwh_fun_lvm.state      = 0;
  currwh_fun_lvm.WarehousID = 0;
  currwh_fun_lvm.PartyID    = 0;
  currwh_fun_lvm.OfficeID   = 0;
  stat = GetGE(currwh_fun_lvm);
  if(stat  and  (currwh_fun_lvm.Ware == ware) )
        return TRUE;
  else  return FALSE;
  end;

END;
