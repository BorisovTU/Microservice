/**
 * Проверки заявлений на открытие/закрытие счетов и распоряжение на изменение номеров счетов
 */

import PTInter, likepy, BankInter, oralib;

const REQ_RESULT_OK     :integer = 0,
      REQ_RESULT_WARNING:integer = 1,
      REQ_RESULT_ERROR  :integer = 2;

/** 
 * Вспомогательный класс для хранения информации об одной ошибке
 */
private class TReqErrorInfo
  var Code:integer = 0
     ,Text:string = ""
     ,Field:integer = -1
end;

/**
 * Класс результатов проверки заявлений
 */
private class TReqCheckResults( Caption:string )

  private var m_Errors  :TArray = TArray(),
              m_Warnings:TArray = TArray(),
              m_Caption :string = Caption;

  /** Сгенерировать ошибку или предупреждение */
  private macro GenErrorOrWarning( Code:integer, Text:string, Field:integer ):TReqErrorInfo
    var error:TReqErrorInfo = TReqErrorInfo();
    if( Code )
      error.Code = Code;
    end;
    if( (Code <= 0) and Text )
      error.Text = Text;
    end;
    if( ValType( Field ) == V_INTEGER )
      error.Field = Field;
    end;
    return error;
  end;

  private macro ShowErrorOrWarning( error:TReqErrorInfo, flags:integer )
    if( error.Code > 0 )
      MemoryError( error.Code, error.Text );
      DisplayError();
    elif( error.Text )
      MsgBoxEx( error.Text, MB_OK + flags, IND_OK, m_Caption );
    end;
  end;
  
  /** Показать ошибку */ 
  macro ShowError( error:TReqErrorInfo )
    ShowErrorOrWarning( error, MB_ERROR );
  end;

  /** Показать предупреждение */ 
  macro ShowWarning( error:TReqErrorInfo )
    ShowErrorOrWarning( error, 0 );
  end;

  /** Сгенерировать ошибку */
  macro GenError( Code:integer, Text:string, Field:integer )
    m_Errors[m_Errors.size] = GenErrorOrWarning( Code, Text, Field );
  end;

  /** Сгенерировать предупреждение */
  macro GenWarning( Code:integer, Text:string, Field:integer )
    m_Warnings[m_Warnings.size] = GenErrorOrWarning( Code, Text, Field );
  end;

  /** Показать все предупреждения и ошибки */
  macro ShowMessages()
    /** Сначала предупреждения */
    foreach( m_Warnings, r2m( this, "ShowWarning" ) );
    /** Потом ошибки */
    foreach( m_Errors, r2m( this, "ShowError" ) );
  end;

  /** Последняя ошибка */
  macro GetLastError():TReqErrorInfo
    if( m_Errors.size )
      return m_Errors[m_Errors.size-1];
    else
      return TReqErrorInfo();
    end;
  end;

end;


/**
 * Структура для хранения данных для проверок
 */
private class TReqCheckData

  private var m_Client:RsbParty = NULL, /*Клиент по заявлению*/
              m_Results:TReqCheckResults = NULL;

  private macro CreateClient():RsbParty
    return NULL;
  end;

  macro GetClient():RsbParty
    if( m_Client == NULL )
      m_Client = CreateClient();
    end;
    return m_Client;
  end;

  macro GetResults():TReqCheckResults
    return m_Results;
  end;

  macro GetAccountType():string
    return "";
  end;

end;

/**
 * Структура для хранения данных для проверок заявлений на открытие
 */
private class (TReqCheckData) TReqopenaCheckData( reqopena /*record*/ )

  private var m_reqopena = reqopena;

  InitTReqCheckData();

  m_Results = TReqCheckResults( "Проверка заявления на открытие счёта" );

  private macro CreateClient():RsbParty
    return RsbParty( m_reqopena.ClientID );
  end;

  macro GetAccountType():string
    return m_reqopena.Type_Account;
  end;

end;

/**
 * Структура для хранения данных для проверок распоряжений на изменение номера счёта
 */
private class (TReqCheckData) TReqchngaCheckData( reqchnga /*record*/ )

  private var m_reqchnga = reqchnga;

  InitTReqCheckData();

  m_Results = TReqCheckResults( "Проверка распоряжений на изменение номера счёта" );

  private macro CreateClient():RsbParty
    var rs:RsdRecordset = execSQLselect( "select t_Client from daccount_dbt where t_Account = :Account and t_Code_Currency = :FIID and t_Chapter = 1",
                                         makeArray( SQLParam( "Account", m_reqchnga.OldAccount ),
                                                    SQLParam( "FIID", m_reqchnga.OldAccountFIID ) ) );
    if( rs.moveNext() )
      return RsbParty( rs.Value( "t_Client" ) );
    else
      return null;
    end;
  end;

  macro GetAccountType():string
    return m_reqchnga.NewAccountType;
  end;

end;

/**
 * Проверка возможности отктытия спец. банковского счёта
 */
private macro CheckOpeningSpecialAccount( data:TReqCheckData ):integer
  if( Index( data.GetAccountType(), "Я" ) > 0 )
    var Client:RsbParty = data.GetClient();
    if( Client and
        ( Client.IsOwned( PTK_MAKER          ) or
          Client.IsOwned( PTK_PAYING_AGENT       ) or
          Client.IsOwned( PTK_BANK_PAYING_AGENT    ) or
          Client.IsOwned( PTK_BANK_PAYING_SUBAGENT ) ) )
      ;
    else
      var ClientName:string = "";
      if( Client )
        ClientName = Client.FullName;
      end;
      data.GetResults().GenError( CHANG_IMPORTANT, "Специальные банковские счета могут открываться только платежным агентам, банковским платежным агентам (субагентам) или поставщикам.|Клиент по счету \"" + 
                                        ClientName + "\" не относится ни к одному из перечисленных типов субъектов" );
      return REQ_RESULT_ERROR;
    end;
  end;
  return REQ_RESULT_OK;
end;

/**
 * Выполнить проверки по списку
 */
private macro PerformChecks( data:TReqCheckData, checks:TArray, breakOnFirstError:bool )
  var func;
  var result:integer;
  for( func, checks )
    result = ExecMacro2( func, data );
    if( ( result == REQ_RESULT_ERROR ) and breakOnFirstError )
      break;
    end;
  end;
  data.GetResults().ShowMessages();
  return data.GetResults().GetLastError();
end;

/**
 * Проверки заявления на открытие счёта
 */
macro PS_CheckReqopena( reqopena /*record*/ ):integer
  return PerformChecks( TReqopenaCheckData( reqopena ), makeArray( @CheckOpeningSpecialAccount ), true ).Code;
end;

/**
 * Проверки распоряжений на изменение номера счёта
 */
macro PS_CheckReqchnga( reqchnga /*record*/ ):integer
  return PerformChecks( TReqchngaCheckData( reqchnga ), makeArray( @CheckOpeningSpecialAccount ), true ).Code;
end;
