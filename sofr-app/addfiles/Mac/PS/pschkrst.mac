/*
 $Name:        pschkrst.mac
 $Module:      РКО
 $Description: Проверка остатков по счетам
*/
//-----------------------------------------------------------------------------
// Блок     : 29016 - "Предобработка клиентского платежа"
// Описание : "Проверка остатков по счетам"
//-----------------------------------------------------------------------------

import pm_chkrst, cbsttls, BankInter, PaymInter, SfInter, pm_tools, reqinter;

const   PSPM_NOTHING             = -1;
const   PSPM_K2CHOICE_K2         = 0; //"В картотеку №2"
const   PSPM_K2CHOICE_REJECT     = 1; //"Отвергнуть"
const   PSPM_IWPCHOICE_IWP       = 0; // В картотеку ОР
const   PSPM_IWPCHOICE_REJECT    = 1; // Отвергнуть
const   PSPM_PWPCHOICE_WP        = 0; //"В картотеку ОР"
const   PSPM_PWPCHOICE_WAIT      = 1; //"На ожидание поступлений"
const   PSPM_PWPCHOICE_I2        = 2; //"В картотеку №2"
const   PSPM_PWPCHOICE_REJECT    = 3; //"Отвергнуть"
const   PSPM_IWPI2CHOICE_WP      = 0; //"В картотеку ОР"
const   PSPM_IWPI2CHOICE_I2      = 1; //"В картотеку №2"
const   PSPM_IWPI2CHOICE_REJECT  = 2; //"Отвергнуть"

private var MadeReserve: bool = false;//резерв был создан на текущем шаге операции(т.к. нет возможности его найти)


//Этапы "Проверка остатков по счетам" для блока "Предобработка клиентского платежа"
private const Проверки_пройдены                                = 0,
              Определение_реальных_владельцев_счетов           = 1,
              Направление_в_КОИ                                = 2,
              Направление_в_К1                                 = 3,
              Проверка_возможности_списания_со_счета_плательщика = 4,
              Проверка_остатка_на_счете_получателя             = 5,
              Направление_в_невыясненные                       = 6,
              Определение_способа_обработки                    = 7,
              Проверка_межфилиальности_платежа                 = 8,
              Проверка_наличия_изменений_реквизитов            = 9,
              Заполнение_даты_приема                           = 10;

// Этапы "Проверка остатков по счетам" для блока "Предобработка банковского ордера"
const БО_Проверки_пройдены                                  = 0,
      БО_Определение_реальных_владельцев_счетов             = 1,
      БО_Проверка_остатка_на_счете_плательщика_клиента      = 2,
      БО_Проверка_остатка_на_счете_получателя               = 3,
      БО_Направление_в_невыясненные                         = 4,
      БО_Проверка_остатка_на_счете_плательщика_банка        = 5,
      БО_Проверка_остатка_на_счете_получателя_2             = 6,
      БО_Определение_статусов                               = 7;

private macro IsBO( Payment:RsbPayment )
  return Payment.DocKind == DLDOC_BANKORDER;
end;

class ParmStage(_ID_Operation, _ID_Step, FirstStage)
  
  var INDEX_Segment:integer = GetOprStatus(OPR_PAYM_INDEX);
  var ID_Operation = _ID_Operation;
  var ID_Step = _ID_Step;
  
  var Next_Stage = FirstStage;
  var SkipStages:TArray = TArray(); // Этапы, которые необходимо пропустить

  // Пропустить этап
  macro SkipStage(Stage)
    SkipStages[SkipStages.size] = Stage;
  end;
  
  // Этот этап пропущен?
  macro IsSkipStage(Stage)
    var i = 0;
    while(i < SkipStages.size)
      if(SkipStages[i] == Stage)
        return true;
      end;
      i = i + 1;
    end;
    return false;
  end;
  
  // Установить следующий этап
  macro NextStage(p1, p2)

    if(ValType(p1) == V_UNDEF) // Если ничего не передали, то просто увеличиваем на 1
      Next_Stage = Next_Stage + 1;
    elif((ValType(p1) == V_BOOL) and (ValType(p2) == V_INTEGER)) // Установка этапа с условием
      if(p1)
        Next_Stage = p2;
      end;
    elif(ValType(p1) == V_INTEGER)
      Next_Stage = p1;
    end;
  end;
  
  // Следующий этап Stage?
  macro IsNextStage(Stage)
    return Next_Stage == Stage;
  end;

end;






// Варианты ответов PmWaitOrRejectQuestion
var Dlg_Ans_Wait       = " На ожидание поступлений ";
var Dlg_Ans_Reject     = " Отвергнуть ";

const Dlg_Var_Wait       :integer = 0;
const Dlg_Var_Reject     :integer = 1;

//-----------------------------------------------------------------------------
// Выбрать "на ожидание поступлений" или "отвергнуть"
//-----------------------------------------------------------------------------
macro PmWaitOrRejectQuestion( Account:string, isExistWait:bool ):bool

  Array Text;
  Array Buttons;

  var selectRes    :integer = Dlg_Var_Wait;
  var DialogFlag = TSetDialogFlag(1);

  selectRes = GetCachedVar( "PmWaitOrReject" + Account );
  if( ValType( selectRes ) == V_UNDEF )

    if( isExistWait )
      Text(0) = "К счету плательщика " + Account + " есть неоплаченные документы, ожидающие поступлений. Что сделать с документом? ";
    else
      Text(0) = "На счете плательщика " + Account + " недостаточно средств для оплаты документа. Поместить его в список ожидающих поступлений? ";
    end;
    
    Buttons(0) = Dlg_Ans_Wait;
    Buttons(1) = Dlg_Ans_Reject;

    selectRes = ConfWin( Text, Buttons );

    if( IsOprMultiExec() )
      SetCachedVar( "PmWaitOrReject" + Account, selectRes );
    end;

  end;

  return selectRes;
end;

//-----------------------------------------------------------------------------
// Выбрать "В картотеку ОР", "В картотеку 2" или "Отвергнуть"
//-----------------------------------------------------------------------------
macro PmIWPorI2orRejectQuestion( Account:string, cachedvar:string ):integer

  Array Text;
  Array Buttons;

  var DialogFlag = TSetDialogFlag(1);

  var ChoiceIWPI2 = GetCachedVar( cachedvar + Account );
  if( ValType( ChoiceIWPI2 ) == V_UNDEF )
    Text[0] = "На счете плательщика " + Account + " недостаточно средств, свободных от наложенных запретов на проведение операций.";
    Buttons[PSPM_IWPI2CHOICE_WP    ] = "В картотеку ОР";
    Buttons[PSPM_IWPI2CHOICE_I2    ] = "В картотеку №2";
    Buttons[PSPM_IWPI2CHOICE_REJECT] = "Отвергнуть";

    ChoiceIWPI2 = ConfWin( Text, Buttons );

    if( IsOprMultiExec() )
      SetCachedVar( cachedvar + Account, ChoiceIWPI2 );
    end;
  end;
  return ChoiceIWPI2;

end;

//проверить в списке документов, ожидающих поступлений, наличие документов с тем 
//же счетом плательщика и с более высокой (или такой же) очередностью
//  Account    - номер счёта
//  FIID       - валюта счёта
//  Priority   - очерёдность
//  CheckDate  - дата поступления документа
//  ValueDate  - дата расчета
private macro CheckPmWaitPlacedAccPr( Account:string, FIID:integer, Priority:integer, CheckDate:date, ValueDate:date ):bool

  var  params:TArray;
  var  rs:object;

  params = makeArray( 
                      SQLParam( "p_Account"   , Account   ),
                      SQLParam( "p_FIID"      , FIID      ),
                      SQLParam( "p_Priority"  , Priority  ),
                      SQLParam( "p_Date"      , CheckDate ),
                      SQLParam( "p_ValueDate" , ValueDate ),
                      SQLParam( "p_Strong"    , 1         )
                    );

  if(execStoredFunc( "PM_RESTFUN.CheckWaitingWithPriority", V_MONEY, params ) > 0)
    return true;
  end;
  
  return false;

end;

//Получить символ предыдущего шага
private macro GetSymbolPrevStep( ID_Operation:integer, ID_Step:integer, Symbol ):bool

  var query:string = "SELECT prevs.t_symbol " +
                     "FROM doprstep_dbt nows, doprstep_dbt prevs " +
                     "WHERE nows.t_id_operation = :ID_Operation " +
                       "AND nows.t_id_step = :ID_Step " +
                       "AND prevs.t_id_operation = nows.t_id_operation " +
                       "AND prevs.t_id_step = nows.t_previous_step ";

  var params:TArray = TArray();
  params[params.size] = SQLParam( "ID_Operation", ID_Operation );
  params[params.size] = SQLParam( "ID_Step", ID_Step );

  var rs:RsdRecordset = execSQLselect( query, params, true );
  if( rs and rs.moveNext() )
    SetParm( 2, rs.value(0) );
    return true;
  end;

  return false;

onerror(x)
  MsgBox( "Ошибка получения шага операции|" + x.Message );
  return false;
end;

macro ПлатежИзОжидающихПоступления( ID_Operation:integer, ID_Step:integer ):bool

  var Symbol;

  if(GetSymbolPrevStep( ID_Operation, ID_Step, Symbol ) and (Symbol == "Й")) 
    return true;
  end;

  return false;
end;

private macro CheckPmWaitPlacedAccPr_ByObj(Payment:RsbPayment, ID_Operation, ID_Step, Account:@string )
  
  if( not InList(Payment.DocKind, PS_PAYORDER, DLDOC_BANKORDER, PS_INRQ) )
    return false;
  end;

  var IsExists : bool = false;
  var IsNext = 0;
  var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );
  var Priority = 0;
  var StrongCond:bool = ПлатежИзОжидающихПоступления(ID_Operation, ID_Step);
  var CheckDate:date = IfThenElse( Payment.PayerBankEnterDate == date(0,0,0), Payment.ValueDate, Payment.PayerBankEnterDate );
  
  Priority = Payment.Priority;    

  if( (Payment.DocKind == DLDOC_BANKORDER) and (Payment.PIList(PRT_Debet).Size > 0) and (Payment.PIList(PRT_Debet).First() == 0) )
    
    while( (not IsExists) and (IsNext == 0) and (Payment.PIList(PRT_Debet).Current(pi) == 0) )
      
      IsExists = CheckPmWaitPlacedAccPr( pi.rec.Account, pi.rec.FIID, Priority, CheckDate, Payment.ValueDate  );
      if(IsExists)
        Account = pi.rec.Account;
      end;
      IsNext = Payment.PIList(PRT_Debet).Next;
    end;

  else
    IsExists = CheckPmWaitPlacedAccPr( Payment.PayerAccount, Payment.PayerFIID, Priority, CheckDate, Payment.ValueDate );
    if(IsExists)
      Account = Payment.PayerAccount;
    end;
  end;

  return IsExists;


end;


PRIVATE MACRO ДокументПретензииНаСумму( ClaimID ):bool
  VAR params:TArray = TArray();
  VAR rs:RsdRecordset;
  VAR query:string = "SELECT CL.T_CLAIMKIND, CL.T_RESTKIND " +
                     "  FROM DACCLAIM_DBT CL  " +
                     " WHERE CL.T_CLAIMID = :CLAIMID";
  params[params.size] = SQLParam( "CLAIMID", ClaimID );
  rs = execSQLselect( query, params, TRUE );
  IF( rs and rs.moveNext() )
    return ( (( rs.value(0) == ACCLAIM_KIND_ARREST ) or (rs.value(0) == ACCLAIM_KIND_SPECIAL))
            AND ( rs.value(1) == ACCLAIM_TYPE_AMOUNT ) );
  ELSE
    return FALSE;
  END;

ONERROR(x)
  
  MsgBox( "Ошибка при поиске документа претензии|" + x.Message );
  return FALSE;

END;

private macro ПолучитьСуммуПретензии( ClaimID )

  VAR query:string = "SELECT clstate.t_CurrentAmount  " +
                     "  FROM dacclaimstate_dbt clstate" +
                     " WHERE clstate.t_ClaimID   = :ClaimID " + 
                     "   AND clstate.t_StateDate = (SELECT max(t.t_StateDate)  " +
                     "                                FROM dacclaimstate_dbt t " +
                     "                               WHERE t.t_ClaimID    =  :ClaimID_t " + 
                     "                                 AND t.t_StateDate <=  :StartDate ) ";

  VAR params:TArray = makeArray( SQLParam( "ClaimID", ClaimID     ),
                                 SQLParam( "ClaimID_t", ClaimID   ),
                                 SQLParam( "StartDate", {curdate} ));

  VAR rs:RsdRecordset = execSQLselect( query, params, TRUE );

  IF( rs and rs.moveNext() )
    return rs.value(0);
  ELSE
    return $0;
  END;

ONERROR(x)
  
  MsgBox( "Ошибка при поиске документа претензии|" + x.Message );
  return $0;

end;

macro ЗарезервированыСредства( Payment:RsbPayment ):bool

  var ClaimID    :integer =  0; /* ID претензии      */
  var ClaimAmount:money   = $0; /* сумма претензии   */
  var ClaimStatus:integer =  0; /* статус претензии  */
  
  return IfThenElse( GetReserveInfo( Payment.DocKind, Payment.PaymentID, Payment.ValueDate, 
                     @ClaimID, @ClaimAmount, @ClaimStatus ) == 1, false, true );
end;

private macro СчетСвязанС_КУ_НевПоступления( Account:string, FIID:integer, Chapter:integer )
  
  var query:string ="SELECT 1        " +
                    "  FROM DUAL     " +
                    " WHERE EXISTS ( " +
                                     "SELECT /*+FIRST_ROWS(1)*/ 1                " +
                                     "  FROM dmccateg_dbt cat, dmcaccdoc_dbt doc " +
                                     " WHERE cat.t_number   =  1005              " +
                                     "   AND doc.t_catid    =  cat.t_id          " +
                                     "   AND doc.t_account  = :Account           " +
                                     "   AND doc.t_currency = :FIID              " +
                                     "   AND doc.t_chapter  = :Chapter           " +
                                     "   AND ROWNUM <= 1 )                       " ;

  var params:TArray = makeArray( SQLParam( "Account", Account    ),
                                 SQLParam( "FIID"   , FIID       ),
                                 SQLParam( "Chapter", Chapter    ) );

  var rs:RsdRecordset = execSQLselect( query, params, TRUE );

  if( rs and rs.moveNext() )
    return true;
  elif( rs )
    return false;
  end;

end;

private macro GetDepID( Code )

  var dp_dep = Tbfile("dp_dep.dbt", "r");

  dp_dep.rec.Code = Code;

  if(getEQ(dp_dep))
    return dp_dep.rec.PartyID;
  end;
  return 0;
end;

private macro CalculateSumInSfInvLinkDoc( Payment:RsbPayment )

  var InvoiceID:integer;
  var SfPayFIID:integer;
  var SfDirection:integer;
  var SfInvParm:TArray;

  var first_pi  :TRecHandler = TRecHandler( "pmaddpi.dbt", "bank.def");
  var second_pi :TRecHandler = TRecHandler( "pmaddpi.dbt", "bank.def");
  var pi        :TRecHandler;

  var i:integer = 0;
  var stat_get;

  var PayOrderObj:RsbPsPayOrder;
  var CpOrderObj :RsbCpOrder;
  var BankOrderObj:RsbBankOrder;

  /* новый платеж на разницу сумм и его реквизиты */
  var NewPayOrderObj:RsbPsPayOrder;
  var NewCpOrderObj :RsbPsCpOrder;

  file NewReceiverPt( party ) key 0;

  var RestPayerAmount:money = $0;
  var NewAccount  = "";
  var NewReceiver =  0;
  var NewReceiverBankCode = 0;
  var isAddPIPayment = Payment.PIList(PRT_Credit).Size != 0;
  var NewAmount  :money = $0,
      NewPmAmount:money = $0;

  /* условия выполнения алгоритма */
  if( ( Payment.DocKind == PS_PAYORDER ) or ( Payment.DocKind == PS_CPORDER ) or ( Payment.DocKind == DLDOC_BANKORDER ) ) /*платеж - только клиентский или БО*/
    if( not FindSfInvLnkByPaymentID( Payment.PaymentID, @InvoiceID ) ) /*имеет привязку к ТО ПЗО*/
      if(   ( Payment.PIList(PRT_Credit).Size <= 2 ) or      /* разноска по кредиту не более 2-х уточняющих записей */
          ( ( Payment.PIList(PRT_Credit).Size == 0 ) and     /* или без расноски, но с реальным счетом получателя   */
            ( Payment.PIList(PRT_Debet).Size == 0 ) and 
            ( Payment.FuturePayerAccount != "" ) ) )
        /* запрашиваем ПЗО о сумме зачисления */
        GetInvoiceRest( InvoiceID, Payment.ValueDate, SfPayFIID, SfDirection, SfInvParm ); 

        if( SfPayFIID == Payment.BaseFIID ) /* возвращаемая из ПЗО сумма - в валюте документа */
          
          if( isAddPIPayment )
            if( Payment.PIList(PRT_Credit).First() or Payment.PIList(PRT_Credit).Current(first_pi) or
                Payment.PIList(PRT_Credit).Next() or Payment.PIList(PRT_Credit).Current(second_pi) )
              MsgBox("Ошибка при получении уточняющих записей платежа");
              return 1;
            end;
          end;

          while( i < SfInvParm.Size() )

            if( isAddPIPayment ) /* для платежа с разноской надо проверить счета и пересчитать суммы в разноске */

              if  ( SfInvParm[i].rec.Account == first_pi.rec.Account )
                pi = first_pi;
              elif( SfInvParm[i].rec.Account == second_pi.rec.Account )
                pi = second_pi;
              else
                MsgBox("Счета для ПЗО не соответствуют уточняющим записям платежа");
                return 1;
              end;

              // Сумма приходит в валюте оплаты, её надо сконвертировать в валюты счёта плательщика и счёта получателя
              if( SfPayFIID == pi.rec.FIID )
                NewAmount = SfInvParm[i].rec.Amount;
              else
                if( ConvSum( NewAmount, SfInvParm[i].rec.Amount, {curdate}, SfPayFIID, pi.rec.FIID ) )
                  MsgBox( "Ошибка конверсии суммы оплаты ПЗО в валюту счёта " + pi.rec.Account );
                  return 1;
                end;
              end;
              if( SfPayFIID == pi.rec.PmFIID )
                NewPmAmount = SfInvParm[i].rec.Amount
              else
                if( ConvSum( NewPmAmount, SfInvParm[i].rec.Amount, {curdate}, SfPayFIID, pi.rec.PmFIID ) )
                  MsgBox( "Ошибка конверсии суммы оплаты ПЗО в валюту счёта " + Payment.PayerAccount );
                  return 1;
                end;
              end;

              if( SfInvParm[i].rec.Amount == 0 )  /* записи с нулевой суммой удаляем */
                Payment.PIList(PRT_Credit).Delete( pi );
              elif( NewPmAmount < pi.rec.FuturePayerAmount )
                /* для записей с суммой больше суммы зачисления изменим сумму на сумму зачисления */
                pi.rec.FuturePayerAmount    = NewPmAmount;
                pi.rec.FutureReceiverAmount = NewAmount;
                Payment.PIList(PRT_Credit).Update( pi );
              end;             
            else /* для платежа без разноски просто проверяем счета */
              if( SfInvParm[i].rec.Account != Payment.FutureReceiverAccount )
                MsgBox("Счет ПЗО не соответствует счету получателя из платежа");
                return 1;
              end;
              if( SfPayFIID == Payment.PayerFIID )
                NewPmAmount = SfInvParm[i].rec.Amount;
              else
                if( ConvSum( NewPmAmount, SfInvParm[i].rec.Amount, {curdate}, SfPayFIID, Payment.PayerFIID ) )
                  MsgBox( "Ошибка конверсии суммы оплаты ПЗО в валюту счёта " + pi.rec.Account );
                  return 1;
                end;
              end;
            end;
            RestPayerAmount = RestPayerAmount + NewPmAmount;
            i = i + 1;
          end;

          if( RestPayerAmount < Payment.FuturePayerAmount ) /* создаем новый документ на сумму разницы*/

            NewAccount = Unkn_GetAccountPassive( Payment.Department, Payment.PayerFIID, MC_OPENACC_CREATE, IfThenElse(Payment.TaxPmType == "1", 1, 2) );
            if( NewAccount == "" )
              MsgBox("Ошибка при определении счета невыясненных ");
              return 1;
            end;
            NewReceiver = GetDepID( Payment.Department );
            if( СчетСуществуетИОткрыт( Payment.ReceiverFIID, NewAccount, CHAPT1, NULL, NULL, NewReceiver, NULL ) )
              if( ПолучитьСубъекта( NewReceiver, NewReceiverPt ) != 0 )
                MsgBox("Ошибка при поиске субъекта");
                return 1;
              end;
            end;

            NewReceiverBankCode = ПолучитьКодСубъекта( NewReceiver, Payment.ReceiverBankCodeKind, stat_get );

            if( Payment.DocKind == PS_PAYORDER ) /* рублевый платеж */

              PayOrderObj    = GenObject( "RsbPsPayOrder", Payment.PaymentID );
              NewPayOrderObj = PayOrderObj.MakeCopyPayOrder();
              NewPayOrderObj.DocKind = PSPOKIND_ORDER;
              /* заполняем реквизиты нового платежа */
              NewPayOrderObj.Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                                                    NewReceiver,                   /*ReceiverBankID*/
                                                    Payment.ReceiverBankCodeKind,  /*PaymentObj.ReceiverBankCodeKind*/
                                                    NewReceiverBankCode,           /*ReceiverBankCode, */
                                                    NewReceiverPt.Name,            /*ReceiverBankName*/
                                                    "",
                                                    Payment.PayerFIID, 
                                                    1/*CHAPT1*/, 
                                                    NewAccount, 
                                                    NewReceiver, 
                                                    NewReceiverPt.Name, 
                                                    "" );
              NewPayOrderObj.Payment.PayerAmount    = 
              NewPayOrderObj.Payment.ReceiverAmount = Payment.FuturePayerAmount - RestPayerAmount;

              /* связываем с исходным и запускаем операцию */
              PayOrderObj.Payment.LinkPayment( NewPayOrderObj.Payment, PMLINK_KIND_KVITING );
              NewPayOrderObj.LaunchOper = true;

            else  if ( Payment.DocKind == DLDOC_BANKORDER )
           
              BankOrderObj = GenObject( "RsbBankOrder", Payment.PaymentID );
              NewPayOrderObj = GenObject( "RsbPsPayOrder", 0 );
              NewPayOrderObj.DocKind = PSPOKIND_ORDER;
              /* заполняем реквизиты нового платежа */
              NewPayOrderObj.Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                                                    NewReceiver,                   /*ReceiverBankID*/
                                                    Payment.ReceiverBankCodeKind,  /*PaymentObj.ReceiverBankCodeKind*/
                                                    NewReceiverBankCode,           /*ReceiverBankCode, */
                                                    NewReceiverPt.Name,            /*ReceiverBankName*/
                                                    "",
                                                    Payment.PayerFIID, 
                                                    1/*CHAPT1*/, 
                                                    NewAccount, 
                                                    NewReceiver, 
                                                    NewReceiverPt.Name, 
                                                    "" );
              NewPayOrderObj.Payment.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                                                    Payment.Payer,                   /*ReceiverBankID*/
                                                    Payment.PayerBankCodeKind,  /*PaymentObj.ReceiverBankCodeKind*/
                                                    Payment.PayerBankCode,           /*ReceiverBankCode, */
                                                    Payment.PayerBankName,            /*ReceiverBankName*/
                                                    "",
                                                    Payment.PayerFIID, 
                                                    1/*CHAPT1*/, 
                                                    Payment.PayerAccount, 
                                                    Payment.Payer, 
                                                    Payment.PayerBankName, 
                                                    "" );
              NewPayOrderObj.Payment.PayerAmount    = 
              NewPayOrderObj.Payment.ReceiverAmount = Payment.FuturePayerAmount - RestPayerAmount;
              NewPayOrderObj.Payment.Number = BankOrderObj.Number;
              NewPayOrderObj.Payment.Ground = BankOrderObj.Ground;

              /* связываем с исходным и запускаем операцию */
              BankOrderObj.LinkPayment( NewPayOrderObj.Payment, PMLINK_KIND_KVITING );
              NewPayOrderObj.LaunchOper = true;
           
            else /* валютный платеж */

              CpOrderObj    = GenObject( "RsbPsCpOrder", Payment.PaymentID );
              NewCpOrderObj = CpOrderObj.MakeCopyCPOrder();
              /* заполняем реквизиты нового платежа */
              NewCpOrderObj.Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                                                   NewReceiver,                   /*ReceiverBankID*/
                                                   Payment.ReceiverBankCodeKind,  /*PaymentObj.ReceiverBankCodeKind*/
                                                   NewReceiverBankCode,           /*ReceiverBankCode, */
                                                   NewReceiverPt.Name,            /*ReceiverBankName*/
                                                   "",
                                                   Payment.PayerFIID, 
                                                   1/*CHAPT1*/, 
                                                   NewAccount, 
                                                   NewReceiver, 
                                                   NewReceiverPt.Name, 
                                                   "" );
              NewCpOrderObj.Payment.BaseFIID = Payment.PayerFIID;
              NewCpOrderObj.Payment.BaseAmount     = 
              NewCpOrderObj.Payment.PayerAmount    = 
              NewCpOrderObj.Payment.ReceiverAmount = Payment.FuturePayerAmount - RestPayerAmount;
              /* связываем с исходным и запускаем операцию */
              CpOrderObj.Payment.LinkPayment( NewCpOrderObj.Payment, PMLINK_KIND_KVITING );
              NewCpOrderObj.LaunchOper = true;

            end;
            end;
          end; /*if( RestAmount < Payment.FuturePayerAmount )*/ 
        end; /* возвращаемая из ПЗО сумма - в валюте документа */
      end; /* разноска по кредиту не более 2-х уточняющих записей */  
    end; /*имеет привязку к ТО ПЗО*/    
  end; /*платеж - только клиентский*/      
  return stat_get;
end;


// Этап 1 Определение реальных владельцев счетов
private macro Stage_DefinitionRealOwnerAcc(Payment:RsbPayment, PrmStage:ParmStage):integer
  return PM_CheckAccRestCommon( Payment );
end;

// Этап Направление в картотеку ожидающих исполнения
private macro Stage_GoToWExec(Payment:RsbPayment, PrmStage:ParmStage): integer
  if (execStoredFunc("PM_COMMON.CheckWaitExec", V_INTEGER, 
                     makeArray(SQLParam("", Payment.ValueDate), SQLParam("", Payment.DocKind), SQLParam("", 0))) == 1)
    if (УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, PrmStage.INDEX_Segment = OPR_PAYM_ST_INDEX_WAITEXEC))
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;
    
    PrmStage.NextStage(Определение_способа_обработки);
  end;
  return 0;
end;

// Этап 2 Направление в картотеку 1
private macro Stage_GoToI1(Payment:RsbPayment, PrmStage:ParmStage):integer
  
  var PayOrder:object = NULL;
  var RegVal, error;

  if( Payment.DocKind == PS_PAYORDER )

    PayOrder = GenObject( "RsbPSPayOrder", Payment.DocumentID );
        
    if( ( PayOrder.DocKind    == PSPOKIND_DEMAND      ) and
        ( PayOrder.AcceptTerm != PM_DEMAND_TERM_WITHOUTACCEPT ) and
        ( (PayOrder.Accept == PSPAYDEM_ST_WAIT) or (PayOrder.Accept == PSPAYDEM_ST_AUTOREJECT) ) and 
        ( PayOrder.AcceptDate > {curdate}) )

      GetRegistryValue("PS\\PAYORDER\\K1_AutoAccept", V_BOOL, RegVal, error);
      if(( PayOrder.PreAcptID == 0) and (PayOrder.Accept == PSPAYDEM_ST_WAIT) and ( RegVal ))
        PM_LinkPreAcptAuto( Payment.DocumentID );
        end;
      if( PayOrder.Accept == PSPAYDEM_ST_AUTOREJECT )
        Payment.PaymStatus = PM_REJECTED;
        PM_SetPrimDocumentState( Payment, DOCUMENT_ST_REJECTED );
        УстановитьСтатусыПлатежа( OPR_PAYM_STATE, OPR_PM_ST_REJECT );
      end;

      if( PayOrder.Accept != PSPAYDEM_ST_AUTOACCEPT )
        if( УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, PrmStage.INDEX_Segment = OPR_PAYM_ST_INDEX_1, OPR_PAYM_MANUAL, OPR_PAYM_ST_MANUAL_NOTNEED ) )
          msgbox("Ошибка при установке сегментов статуса экземпляра операции");
          return 1;
        end;
        PayOrder.AcceptTerm = 0; //с акцептом
        if( not PayOrder.AcceptPeriod )
          if( GetRegistryValue( "PS\\PAYORDER\\K1_PAYPERIOD", V_INTEGER, RegVal ) )
            PayOrder.AcceptPeriod = RegVal;
          else
            PayOrder.AcceptPeriod = 5 ;
          end;
        end;
        PrmStage.NextStage(Определение_способа_обработки);
      else
        PayOrder.AcceptPeriod = 0 ;
      end;
    end;
  end;
  return 0;
end;

// Этап 3 Проверка возможности списания со счета плательщика
macro Stage_CheckRestAndMakeReserve(Payment:RsbPayment, PrmStage:ParmStage):integer
  if( ЗарезервированыСредства(Payment) )
    PrmStage.NextStage( Проверка_остатка_на_счете_получателя );
  else
    var stat = CheckRestAndMakeReserve( Payment, true, true, true, true, 
                                        GetOprStatus(OPR_PAYM_PERMISSION), NULL, 
                                        true, NULL, 0, true, true, true );

    if(not stat)
      MadeReserve = true;
    elif(stat == PAYMERR_NORESERVE_OTHERPROC)
      PrmStage.NextStage( Определение_способа_обработки );
      return 0;
    end;

    return stat;
  end;

  return 0;
end;

// Этап 7 Проверка остатка на счете получателя
macro Stage_CheckRestReceiverAcc(Payment:RsbPayment, PrmStage:ParmStage):integer

  var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );

  IF( CalculateSumInSfInvLinkDoc( Payment ) == 0 )
    
    IF( Payment.FuturePayerAmount == 0 ) /* если сумма к оплате стала нулевой, закроем платеж */
      IF( УстановитьСтатусыПлатежа( OPR_PAYM_STATE, OPR_PM_ST_CLOSE ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return 1;
      END;
      Payment.FreeReserve( Payment.PayerAccount, CHAPT1, Payment.PayerFIID );
      PrmStage.NextStage(Проверки_пройдены);
      return 0;
    END;

    IF( Payment.PIList(PRT_Credit).Size > 0 )/* проверим остаток по каждой записи */
      IF( ( Payment.PIList(PRT_Credit).First() == 0 ) and ( Payment.PIList(PRT_Credit).Current( pi ) == 0 ) )
        IF( not CheckReceiverAccount( pi.rec.Account, pi.rec.FIID, pi.rec.Amount, Payment.ValueDate ) )
          RejectPayment(Payment, "Недостаточно средств для зачисления");
          PrmStage.NextStage(Проверки_пройдены);
          msgbox( "Недостаточно средств для зачисления" );
          return 0;
        END;
      END;
    END;
  END;

  IF( GetOprStatus(OPR_PAYM_INDEX) <= OPR_PAYM_ST_INDEX_NO )
    IF( ( Payment.PIList(PRT_Credit).Size == 0 ) and 
        (СчетСуществуетИОткрыт( Payment.FutureReceiverFIID, Payment.FutureReceiverAccount, CHAPT1 )) )
      IF( not CheckReceiverAccount( Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.FutureReceiverAmount, Payment.ValueDate, Payment.OutTransferDate, Payment.ReceiverGroup ) )
        RejectPayment(Payment, "Недостаточно средств для зачисления");
        PrmStage.NextStage(Проверки_пройдены);
        msgbox( "Недостаточно средств для зачисления" );
      END;
    END;
  END;

  return 0;
end;

macro Stage_CheckRestReceiverAcc_ForBank(Payment:RsbPayment, PrmStage:ParmStage):integer

  var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );
  IF(GetOprStatus(OPR_PAYM_INDEX) <= OPR_PAYM_ST_INDEX_NO)
    IF( Payment.PIList(PRT_Credit).Size > 0 )/* проверим остаток по каждой записи */
      IF( ( Payment.PIList(PRT_Credit).First() == 0 ) and ( Payment.PIList(PRT_Credit).Current( pi ) == 0 ) )
        IF( not CheckReceiverAccount( pi.rec.Account, pi.rec.FIID, pi.rec.Amount, Payment.ValueDate ) )
          RejectPayment(Payment, "Остаток активного счета становится пассивным");
          msgbox( "Остаток активного счета становится пассивным" );
          PrmStage.NextStage(Проверки_пройдены);
        END;
      END;
    ELIF(СчетСуществуетИОткрыт( Payment.FutureReceiverFIID, Payment.FutureReceiverAccount, CHAPT1 ))
      IF( not CheckReceiverAccount( Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.FutureReceiverAmount, Payment.ValueDate ) )
        RejectPayment(Payment, "Остаток активного счета становится пассивным");
        msgbox( "Остаток активного счета становится пассивным" );
        PrmStage.NextStage(Проверки_пройдены);
      END;
    END;
  END;

  return 0;
end;

// Этап 9 Направление в невыясненные
macro Stage_GoToInIndexUnknown(Payment:RsbPayment, PrmStage:ParmStage):integer
  
  PrmStage.NextStage( IsBO(Payment), БО_Определение_статусов );

  IF( (Payment.PIList(PRT_Credit).Size <= 0) and  /*нет разноски по кредиту*/
       Payment.ReceiverAccount and  
       СчетСвязанС_КУ_НевПоступления(Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.Chapter) )
    IF( УстановитьСтатусыПлатежа( OPR_PAYM_INDEX, PrmStage.INDEX_Segment = OPR_PAYM_ST_INDEX_UNKNOWN ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    END;
  END;

  return 0;
end;

// Этап 10 Определение способа обработки - стандартный или ИПВС
private macro Stage_DefinitionMethodProcessing(Payment:RsbPayment, PrmStage:ParmStage):integer
  
  var DO_Segment;

  if( PrmStage.INDEX_Segment != OPR_PAYM_ST_INDEX_WAIT)
    
    if( ( Payment.DocKind == PS_INRQ ) and IsSetPsBCNumber( Payment ) ) 
      DO_Segment = OPR_PM_ST_EXEC_IPVS;
    else
      DO_Segment = OPR_PM_ST_ENTER;
    end;

    if( УстановитьСтатусыПлатежа( OPR_PAYM_DO, DO_Segment ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;

  end;

  return 0;
end;

// Этап 11 Проверка межфилиальности платежа
private macro Stage_CheckBranchPayment(Payment:RsbPayment, PrmStage:ParmStage):integer
  
  var CABS_Segment;

  if( GetOprStatus( OPR_PAYM_BRANCH ) == OPR_PAYM_ST_BRANCH_NO )
    CABS_Segment = OPR_PM_ST_MFR_YES;
  else
    CABS_Segment = OPR_PM_ST_MFR_NO;
  end;

  if( УстановитьСтатусыПлатежа( OPR_PAYM_CABS, CABS_Segment ) )
    msgbox("Ошибка при установке сегментов статуса экземпляра операции");
    return 1;
  end;

  return 0;
end;

// Этап 12 Проверка наличия изменений реквизитов
private macro Stage_CheckPropsChange(Payment:RsbPayment, PrmStage:ParmStage):integer
  file inhist(pminhist) key 1;
  var CABS_Segment;

  inhist.PaymentID = Payment.PaymentID;
  inhist.HistoryNum = 0;

  if( GetEQ(inhist) )
    if( УстановитьСтатусыПлатежа( OPR_PAYM_CHANGE, OPR_PAYM_ST_CHANGE_YES ) )
      msgbox("Ошибка при установке сегментов статуса экземпляра операции");
      return 1;
    end;
  end;

  return 0;
end;

//Этап 13 Заполнение даты приема / Этап 14
private macro Stage_SetDateAcceptance(Payment:RsbPayment, PrmStage:ParmStage):integer
  var obj: Object = NULL;
  if (Payment.DocKind == PS_PAYORDER)
    obj = RsbPSPayOrder(Payment.PaymentID);
  end;

  var ReasonID: integer;
  if ( ( ( IsExistsClaimReserve(Payment.DocKind, Payment.PaymentID) == 0 ) or MadeReserve ) // есть претензия
      and (GetOprStatus( OPR_PAYM_CONTROL ) == OPR_PAYM_ST_CTRL_CONTROL) //проконтролирован
      and (Payment.Notes.ReadNote(PM_NOTEKIND_PAYM_ACCEPTUATEDATE, {curdate}) == "") //примечание не заполнено
      and ( (Payment.DocKind != PS_PAYORDER) or (obj.DocKind != 2) //не платежное требование
            or (obj.AcceptTerm == PSPAYDEM_TERM_WITHOUTACCEPT) or (obj.Accept == PSPAYDEM_ST_ACCEPT) or (obj.Accept == PSPAYDEM_ST_AUTOACCEPT) ) ) //акцепт есть или не нужен
    if (Payment.Notes.AddNote(PM_NOTEKIND_PAYM_ACCEPTUATEDATE, GetCurrentDateTimeUTC({curdate})))
      msgbox( "Ошибка при вставке примечания платежа" );
      return 1;
    end;
  end;

  PrmStage.NextStage(Проверки_пройдены);
  return 0;
end;



macro ExecStages(Payment:RsbPayment, Stages:TArray, PrmStage:ParmStage)
  
  var i = 0;
  
  while(i < Stages.size)
    
    if( PrmStage.IsNextStage( Stages[i].num ) )
      if(i + 1 < Stages.size)
        PrmStage.NextStage(Stages[i+1].num);
      end;

      if((not PrmStage.IsSkipStage(Stages[i].num)) and ExecMacro2( Stages[i].fun, Payment, PrmStage ))
        return 1;
      end;

    end;

    i = i + 1;
  end;
  
  return 0;
end;


class TStage(_num:integer, _fun:variant)
  var num = _num;
  var fun = _fun;
end;

MACRO PS_CheckAccRest( Payment:RsbPayment, ID_Operation, ID_Step  ):integer

  var PrmStage = ParmStage(ID_Operation, ID_Step, Определение_реальных_владельцев_счетов);

  var Stages:TArray = MakeArray( TStage( Определение_реальных_владельцев_счетов,           @Stage_DefinitionRealOwnerAcc ),
                                 TStage( Направление_в_КОИ,                                @Stage_GoToWExec ),
                                 TStage( Направление_в_К1,                                 @Stage_GoToI1 ),
                                 TStage( Проверка_возможности_списания_со_счета_плательщика, @Stage_CheckRestAndMakeReserve ),
                                 TStage( Проверка_остатка_на_счете_получателя,             @Stage_CheckRestReceiverAcc ),
                                 TStage( Направление_в_невыясненные,                       @Stage_GoToInIndexUnknown  ),
                                 TStage( Определение_способа_обработки,                    @Stage_DefinitionMethodProcessing ),
                                 TStage( Проверка_межфилиальности_платежа,                 @Stage_CheckBranchPayment ),
                                 TStage( Проверка_наличия_изменений_реквизитов,            @Stage_CheckPropsChange ),
                                 TStage( Заполнение_даты_приема,                           @Stage_SetDateAcceptance ) );
  MadeReserve = false;
  var Result = ExecStages(Payment, Stages, PrmStage);
  MadeReserve = false;
  return Result;

END;

