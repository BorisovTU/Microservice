
import PSInter, OprInter, likepy, oralib, globals, BankInter, CTInter, InsCarryDoc, "adress.mac";

//-----------------------------------------------------------------------------
//  Проверка, существования счета в базе, открыт ли он и принадлежность другому филиалу
//-----------------------------------------------------------------------------
MACRO AccountExistAndOpenChiss( Account:string, FIID:integer, CheckissDep:integer, BeginStrMsg:string, err_msg:string ):bool
  
  VAR selectAcc:string = " select acc.t_open_close, acc.t_department" +  
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = 1 " +
                      "   and acc.T_CODE_CURRENCY = :FIID " +
                      "   and acc.T_ACCOUNT = :account ";

  VAR params:TArray = makeArray(SQLParam( "FIID", FIID ), SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( selectAcc, params, TRUE );
  VAR stat:bool = false;

  if( rset and rset.moveNext() )
    if( rset.value(0) == "З" )
      err_msg = BeginStrMsg + " закрыт";
      SetParm( 3, err_msg );
    else
      if(rset.value(1) != CheckissDep)
          err_msg = BeginStrMsg + " принадлежит другому филиалу";
          SetParm( 3, err_msg );
      else
        stat = true;        
      end         
    end;
  else
    err_msg = BeginStrMsg + " не найден";
    SetParm( 3, err_msg );
  end;
       
  return stat;                        
  
ONERROR(x)
  err_msg = x.Message + "|Модуль:" + x.Module + "| строка:" + x.line;
  SetParm( 3, err_msg );
  return false;
END;


//-----------------------------------------------------------------------------
// Вставить примечание для объекта "ценный бланк"
//-----------------------------------------------------------------------------
macro InsertNoteForCheckIss( OrderID : integer, KindNode : integer, NoteStr : string ):integer

  record Pscheckiss( checkiss );

  ClearRecord(Pscheckiss);
  Pscheckiss.OrderID = OrderID;

  // Заполнить примечание
  if( AddNoteForObject( OBJTYPE_CHECKISS, makeObjectID(OBJTYPE_CHECKISS, PS_CHECKISS, Pscheckiss), KindNode, NoteStr ))
    return 1;
  end;

  return 0;
end;

macro ReadNoteForCheckIss( OrderID : integer ):string

  record Pscheckiss( checkiss );

  ClearRecord(Pscheckiss);
  Pscheckiss.OrderID = OrderID;

  // Заполнить примечание
  return readNoteForObject(OBJTYPE_CHECKISS, makeObjectID(OBJTYPE_CHECKISS, PS_CHECKISS, Pscheckiss), 1);

end;

// Проверка установленного интегрированного режима Retail
macro WorkWithRetail():bool
  var Work_Retail:bool = false;
  var err:integer = 0;

  GetRegistryValue( "COMMON\\WORK_MODE\\WORK_WITH_RETAIL", V_BOOL, Work_Retail, err );
  if( err != 0 )
    msgbox(" Ошибка чтения настройки COMMON\\WORK_MODE\\WORK_WITH_RETAIL ");
    return false;
  end;

  return Work_Retail;
end;


// ----------------------------------------------------------------------------
// Получить имя операциониста по номеру
// ----------------------------------------------------------------------------
macro GetOperName( oper:integer ):string

  var fPerson = Tbfile ("person.dbt");
  var Name:string;

  ClearRecord( fPerson.rec );
  fPerson.rec.Oper = Oper;
  if( not fPerson.getEQ () )
    Name = "";
  else
    Name = fPerson.rec.Name;
  end;

  return Name;
end;


CLASS PlaceStorage ( Department:integer )

  var Code:integer, PartyID:integer;  

  var query:string = "select dp.t_Code, dp.t_PartyID"+
                    " from( select   dp.t_PartyID, dp.t_Code, dp.t_Name, level lev"+
                    " from ddp_dep_dbt dp"+
                          " connect by prior dp.t_ParentCode = dp.t_Code"+
                                 " and prior dp.t_NodeType <> :Department"+
                                " start with dp.t_Code = :OpDpNode"+
                                " order   by level) dp,"+
                            " dpartcode_dbt pc"+
                    " where  pc.t_CodeKind = :VS"+
                    "  and   pc.t_PartyID  = dp.t_PartyID"+
                    "  and   pc.t_State    = 0"+
                    " order by dp.lev";


    var params:TArray = makeArray( SQLParam( "Department", Department         ),
                                   SQLParam( "OpDpNode"  , {OperDprtNode}     ),
                                   SQLParam( "VS"        , PTCK_VALUESSTORAGE )
                                 ); 

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
      Code    =  rs.value(0);
      PartyID =  rs.value(1);
  else
     Code    =  -1;
     PartyID =  -1;    end;
ONERROR(x)
  
    MsgBox( "Ошибка получения хранилища ценностей|" + x.Message );
  return -1;

END;

MACRO GetAcceptDate( ID_Operation:integer, Oper:@integer ):date

  var query:string = "select step.T_FACT_DATE, T_OPER" +
                    " from doprstep_dbt step" +
                    " where step.T_ID_OPERATION = :ID_Operation" +
                      " and step.T_BLOCKID = 401003"+
                      " and step.T_KIND_OPERATION = 4010"+
                      " and step.T_NUMBER_STEP = 20"+
                      " and step.T_COUNTNUM = ("+
                                          " select max(T_COUNTNUM)"+
                                          " from doprstep_dbt"+
                                          " where T_ID_OPERATION = step.T_ID_OPERATION"+
                                            " and T_BLOCKID = step.T_BLOCKID"+
                                            " and T_KIND_OPERATION = step.T_KIND_OPERATION"+
                                            " and T_NUMBER_STEP = step.T_NUMBER_STEP )";

  var params:TArray = makeArray( SQLParam( "ID_Operation", ID_Operation ) ); 

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext() )
    Oper =  rs.value(1);
    return  rs.value(0);
  else
    Oper = 0;
    return Date(0, 0, 0);
  end;

ONERROR(x)
  
  MsgBox( "Ошибка при получении даты акцептования|" + x.Message );
  return -1;

END;

PRIVATE MACRO getCarry( AccTrnID:integer ):TBFile
    var fdocument:TBFile = TBFile("acctrn.dbt",  "R", 5, "acctrn.dbt", "bank.def");
      
    if( fdocument and AccTrnID )
      fdocument.rec.AccTrnID = AccTrnID;
      if( fdocument.GetEQ() )
        return fdocument;
      end;
    end;
    return fdocument;
   
END;

MACRO ChissDelAccept( ID_Operation:integer, ID_Step:integer ):integer

  var carrydocument:TBFile;
  
  // привязка проводки к найденному шагу
  var query:string = "SELECT OPRDOCS.T_ACCTRNID " +
                     "  FROM DOPRDOCS_DBT OPRDOCS " +
                     " WHERE OPRDOCS.T_DOCKIND      = :DOCKIND " + 
                     "   AND OPRDOCS.T_ID_OPERATION = :ID_OPERATION " +
                     "   AND OPRDOCS.T_ID_STEP      = :ID_STEP; ";
   
  var params:TArray = makeArray( SQLParam( "DOCKIND"     , DLDOC_CARRY  ),
                                 SQLParam( "ID_OPERATION", ID_Operation ),
                                 SQLParam( "ID_STEP"     , ID_Step      ) );
     
  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs )
    while( rs.moveNext() )
      carrydocument = getCarry( rs.value(0) );

      if( carrydocument )
          // Удалить внебалансовую проводку, выполненную на шаге "Изъятие из картотеки №1"
        if( not Opr_DeleteCarry( carrydocument.rec.AccTrnID ) )
          MsgBox("Ошибка при удалении проводки");
          return -1;                             
        end;
        return 0;
      else
        return 0;
      end;
    end;
  end;
  
  return 0;

ONERROR(x)
  
  MsgBox( "Ошибка получения привязки проводки к шагу операции|" + x.Message );
  return 1;

END;

/* 
MACRO ChissDelSfPAY_MULTYCARRY( ID_Operation, ID_Step ):integer

  var carrydocument:TBFile;
  // привязка проводки к найденному шагу
  var query:string = "select t_dockind, t_documentid, t_status from doprdocs_dbt where t_id_operation = :ID_OPERATION and t_id_step IN(select t_id_step from doprstep_dbt where t_id_operation= :ID_OPERATION and t_blockid = 401005)";

  var params:TArray = makeArray(SQLParam( "ID_OPERATION", ID_Operation ));
     
  var rs:RsdRecordset = execSQLselect( query, params, true );
  var rsmulty:RsdRecordset;

  if( rs )                                                                 
    while( rs.moveNext() )
      if (rs.value(0) == DLDOC_MULTYCAR)
        query = "select multycar.t_iApplicationKind, multycar.t_ApplicationKey " +
                " from dmultycar_dbt multycar, doprdocs_dbt oprdocs "+
                " where multycar.t_CarryID = :DOCUMENTID ";
        
        params = makeArray(SQLParam( "DOCUMENTID", rs.value(1)));

        rsmulty = execSQLselect( query, params, true );

        if ( rsmulty )
          if ( rsmulty.moveNext() )
            if( not Opr_DeleteCarry( rsmulty.value(0), rsmulty.value(1) ) )
              MsgBox("Ошибка при удалении проводки");
              return -1;                             
            end;
          end;
        end;

      else
        
        carrydocument = getCarry( rs.value(2), int(SubStr(rs.value(1), 1, 5)), SubStr(rs.value(1), 6) );
    
        if( carrydocument )
          if( not Opr_DeleteCarry(carrydocument.rec.iApplicationKind, carrydocument.rec.ApplicationKey) )
            MsgBox("Ошибка при удалении проводки");
            return 1;
          end;
        end;          
      end;
    end;
  end;

  return 0;  

ONERROR(x)
  
  MsgBox( "Ошибка получения привязки проводки к шагу операции|" + x.Message );
  return 1;

END; */

MACRO ChissDelSFPAY_CARRY( ID_Operation:integer, ID_Step:integer ):integer

// привязка проводки к найденному шагу                                
  var query:string = " select acc.T_ACCTRNID                      "+
                     " from   doprdocs_dbt oprd, dacctrn_dbt acc  "+   
                     " where  oprd.t_DocKind    = :DOCKIND        "+
                     " and oprd.t_id_operation  = :ID_OPERATION   "+ 
                     " and oprd.t_acctrnid      =  acc.t_acctrnid "+
                     " and acc.t_Result_Carry   = :RESULT_CARRY   ";
                           
  var params:TArray = makeArray( SQLParam( "DOCKIND"     , DLDOC_CARRY  ),
                                 SQLParam( "ID_OPERATION", ID_Operation ),
                                 SQLParam( "RESULT_CARRY", SFPAY_CARRY  ) );
     
  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs )                                                                 
    while( rs.moveNext() )
      // Удалить внебалансовую проводку по оплате комиссии
      if( not Opr_DeleteCarry( rs.value(0) ) )
        MsgBox("Ошибка при удалении проводки");
        return -1;                             
      end;
    end;
  end;

  return 0;

ONERROR(x)
  
  MsgBox( "Ошибка получения привязки проводки к шагу операции|" + x.Message );
  return 1;

END;

//-----------------------------------------------------------------------------
// Получить имя клиента
//-----------------------------------------------------------------------------
MACRO GetClientName( Account:string ):string

  var Acc:TBFile = TBFile("account.dbt");
  file Субъекты (party) key 0;

  Acc.rec.Chapter = 1;
  Acc.rec.Account = Account;
  if( Acc.GetEQ() )
    if( ПолучитьСубъекта( Acc.rec.Client, Субъекты ) == 0 )
      return Субъекты.Name;
    end;
    return "";
  end;

END;



//-----------------------------------------------------------------------------
// Проверить есть ли в базе заяв. с такими же реквиз. с проверкой диапазона 
// номеров ц. бланков, если нашли 0, не нашли 1
//-----------------------------------------------------------------------------

MACRO FindCHISSwithRange( Series:string, NumberFirst:string, NumberLast:string, Account:string, FormKind:integer, OrderID:integer/*CheckIss:RsbCheckIss*/ ):integer

   
   
  var query:string = "SELECT to_number(t_numberfirst), to_number(t_numberlast)"
                    " FROM   dcheckiss_dbt t"
                    " WHERE t.T_SERIES                 = :Ser"
                      " AND to_number(t.T_NUMBERLAST) >= to_number(:NumFirst)"
                      " AND to_number(t.T_NUMBERFIRST)<= to_number(:NumLast )"
                      " AND t.t_account                = :Account"
                      " AND t.T_FORMKIND               = :FormKind"
                      " AND t.T_ORDERID               != :OrderID"
                      " AND t.T_CURRENTSTATE          in ( 2, 4 )"
                      ;
                                           
  var params:TArray = makeArray( SQLParam( "Ser"     , Series      ),
                                 SQLParam( "NumFirst", NumberFirst ),
                                 SQLParam( "NumLast" , NumberLast  ),
                                 SQLParam( "Account" , Account     ),
                                 SQLParam( "FormKind", FormKind    ),
                                 SQLParam( "OrderID" , OrderID     )  
                               );
                                 
  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs )
    if( rs.moveNext() )
         return 1;
    end;
  end;                             
  
  return 0;

ONERROR(x)
  
  MsgBox( "Ошибка при поиске идентичных заявлений|" + x.Message );
  return 1;

END;
