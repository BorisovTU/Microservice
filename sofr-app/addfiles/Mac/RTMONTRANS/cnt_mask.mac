/////////////////////////////////////////////////////// 
// Класс парсинга маски ПС "Contact"
//	z - любой символ
//	q - любая буква ['A'..'Z', 'a'..'z', 'А'..'Я', 'а'..'я']
//	w - любая Латинская буква ['A'..'Z', 'a'..'z']
//	я - любая Русская буква ['А'..'Я', 'а'..'я']
//	n - цифра ['0'..'9']
//	Wnnn - только латинские буквы, не менее nnn штук
//	Nnnn - только цифры и латинские буквы, не менее nnn штук
//	Юnnn - любые символы, не менее nnn штук
//	~[символ(ы)]~ - обязательные сочетания букв, например: N001~/~N001~.~W001
//
//     Пример использования: 
// 
//     var mask = TCntMask("N005~//~N001~//~N005");
//
//     msgbox(mask.match("ID CARD 123456789012345//777888999//42 CHENGUANG NAN LU, BEIJING"));
// 
///////////////////////////////////////////////////////

private var LAT_LETTERS = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz ,.-"; /* включая пробел и знаки препинания*/
private var RUS_LETTERS = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя ,.-"; /* включая пробел и знаки препинания*/
private var NUMBER      = "1234567890";
private var RESTRICTED  = "~"; /* служебные символы */

private const TP_TOKEN_SYMBOL     = 0; /* простой символ внутри маски */
private const TP_TOKEN_SINGLE     = 1; /* одиночный элемент (zqwяn) */
private const TP_TOKEN_RANGE      = 2; /* последовательность ?NNN (? = WNЮ) */
private const TP_TOKEN_VAR_RANGE  = 3; /* конструкция ~<выражение>~ */

/////////////////////////////////////////////////////// 
// Атомарный элемент маски
///////////////////////////////////////////////////////
CLASS TCntMaskToken(p_Val:STRING, p_Type:INTEGER)
   var Val = p_Val;
   var Type = p_Type;
END;

/////////////////////////////////////////////////////// 
// Парсер маски
///////////////////////////////////////////////////////
CLASS TCntMask (p_Mask:STRING)
   private var Mask = p_Mask;
   private var MaskPos = 1;
   private var ExprPos = 1;
   private var ErrMessage = "";

   /////////////////////////////////////////////////////// 
   // Найти символ в массиве (русских, латинских букв, или цифр)
   ///////////////////////////////////////////////////////
   private MACRO found(str:STRING, symbol:STRING):BOOL
      if (Index(str, symbol) == 0)
         return false;
      end;

      return true;
   END;

   /////////////////////////////////////////////////////// 
   // Ассерт для парсинга
   ///////////////////////////////////////////////////////
   private MACRO parseAssert(var1, var2, ОжидаемоеВыражение)
      if (var1 == var2)
         ErrMessage = "Некорректный формат маски, позиция " + MaskPos + ". Ожидается конструкция " + ОжидаемоеВыражение + ".";
         MaskPos = 1;
         ExprPos = 1;
         RunError(ErrMessage);
      end;
   END;

   /////////////////////////////////////////////////////// 
   // Вернуть следующий элемент маски, или пустую строку
   // Когда доходим до конца - обнуляем MaskPos
   ///////////////////////////////////////////////////////
   private MACRO getNextMaskToken():TCntMaskToken
      var curSym = substr(Mask, MaskPos, 1);
      var token = null;

      var tmpMask;
      var tmpSym;
      var endPos = 0;

      if ((ValType(curSym) == V_UNDEF) OR (curSym == ""))
         /* Маска кончилась - обнуляем позицию */
         MaskPos = 1;
         return null;
      end;
      
      if ((curSym == "z") OR 
          (curSym == "q") OR 
          (curSym == "w") OR 
          (curSym == "я") OR 
          (curSym == "n"))
         MaskPos = MaskPos + 1;
         token = TCntMaskToken(curSym, TP_TOKEN_SINGLE);

      elif ((curSym == "W") OR 
            (curSym == "N") OR 
            (curSym == "Ю"))

         /* читаем количество символов NNN */
         /* первый */
         tmpSym = substr(Mask, MaskPos + 1, 1);

         parseAssert(ValType(tmpSym), V_UNDEF, curSym + "NNN.");
         parseAssert(tmpSym, "", curSym + "NNN.");

         if (found(NUMBER, tmpSym))
            curSym = substr(Mask, MaskPos, 2);

            /* второй - необязательный */
            tmpSym = substr(Mask, MaskPos + 2, 1);

            if (found(NUMBER, tmpSym))
               curSym = substr(Mask, MaskPos, 3);

               /* третий - необязательный */
               tmpSym = substr(Mask, MaskPos + 3, 1);

               if (found(NUMBER, tmpSym))
                  curSym = substr(Mask, MaskPos, 4);
               end;
            end;
         end;

         MaskPos = MaskPos + StrLen(curSym);
         token = TCntMaskToken(curSym, TP_TOKEN_RANGE);

      elif (curSym == "~")
         /* ищем закрывающую тильду */
         tmpMask = substr(Mask, MaskPos + 1);
         endPos = Index(tmpMask, "~");

         parseAssert(endPos, 0, "~<Выражение>~");

         curSym = substr(Mask, MaskPos, endPos + 1);

         MaskPos = MaskPos + endPos + 1;
         
         token = TCntMaskToken(curSym, TP_TOKEN_VAR_RANGE);
      else
         /* Это не элемент маски - это просто символ */
         token = TCntMaskToken(curSym, TP_TOKEN_SYMBOL);
         MaskPos = MaskPos + 1;
      end;

      return token;
   END;

   /////////////////////////////////////////////////////// 
   // Удовлетворяет ли символ одиночному токену
   ///////////////////////////////////////////////////////
   private MACRO checkSingleToken(curSym:STRING, token:TCntMaskToken):BOOL
      var stat = false;

      if ((found(RESTRICTED, curSym)))
         /* символ НЕ должен быть служебным */
         return false;
      end;

      if (token.Val == "z")
         stat = true;
      elif (token.Val == "q")
         /* любая буква */
         if ((found(LAT_LETTERS, curSym)) OR 
             (found(RUS_LETTERS, curSym)))
            stat = true;
         end;
      elif (token.Val == "w")
         /* любая латинская буква */
         if (found(LAT_LETTERS, curSym))
            stat = true;
         end;
      elif (token.Val == "я")
         /* любая русская буква */
         if (found(RUS_LETTERS, curSym))
            stat = true;
         end;
      elif (token.Val == "n")
         /* любая цифра */
         if (found(NUMBER, curSym))
            stat = true;
         end;
      end;
      return stat;
 
   END;

   /////////////////////////////////////////////////////// 
   // Проверить одиночный токен
   ///////////////////////////////////////////////////////
   private MACRO processSingleToken(expr:STRING, token:TCntMaskToken):BOOL
      var curSym = substr(expr, ExprPos, 1);
      var stat = false;

      if ((ValType(curSym) == V_UNDEF) OR (curSym == ""))
         /* символ должен быть в любом случае */
         return false;
      end;
      
      stat = checkSingleToken(curSym, token);

      if (stat)
         ExprPos = ExprPos + 1;
      end;
 
      return stat;  
   END;

   /////////////////////////////////////////////////////// 
   // Подходит ли конкретный символ для токена-последовательности
   ///////////////////////////////////////////////////////
   private MACRO checkRangeToken(curSym:STRING, token:TCntMaskToken):BOOL
      var tType   = substr(token.Val, 1, 1);
      var stat    = false;

      if ((ValType(curSym) == V_UNDEF) OR (curSym == ""))
         /* все, строка кончилась */
         return false;
      end;

      if ((found(RESTRICTED, curSym)))
         /* символ НЕ должен быть служебным */
         return false;
      end;

      if (tType == "W")
         stat = found(LAT_LETTERS, curSym);
      elif (tType == "N")
         stat = found(LAT_LETTERS, curSym) OR found(NUMBER, curSym);
      elif (tType == "Ю")
         stat = true;
      end;

      return stat;
   END;

   /////////////////////////////////////////////////////// 
   // Проверить токен-последовательность
   ///////////////////////////////////////////////////////
   private MACRO processRangeToken(expr:STRING, token:TCntMaskToken):BOOL
      var tLen    = Int(substr(token.Val, 2));
      var counter = 0;
      var curSym;
      var stat    = true;

      if (tLen == 0)
         return true;
      end;
      
      while ((stat) AND (counter < tLen))
         curSym = substr(expr, ExprPos + counter, 1);
         stat = checkRangeToken(curSym, token);

         if (NOT stat)
            return false;
         end; 
         
         counter = counter + 1;
      end;
      
      if (stat)
         ExprPos = ExprPos + tLen;
      end;

      return stat;
      
   END;

   /////////////////////////////////////////////////////// 
   // Проверить токен-последовательность вида ~<выражение>~
   ///////////////////////////////////////////////////////
   private MACRO processVarRangeToken(expr:STRING, token:TCntMaskToken):BOOL
      var tLen    = StrLen(token.Val) - 2;
      var curSym  = substr(token.Val, 2, tLen);
      var counter = 0;
      var stat    = true;

      var tmpExpr = substr(expr, ExprPos);

      var NewPos = Index(tmpExpr, curSym);

      if (NewPos == 0)
         /* все, строка кончилась а ничего не нашли */
         return false;
      end;
      
      /* если нашли - переводим позицию за последний символ
         найденного выраженмя */      
      ExprPos = ExprPos + NewPos + tLen - 1;

      return true;
      
   END;

   /////////////////////////////////////////////////////// 
   // Проверить очередной кусок выражения токеном маски 
   ///////////////////////////////////////////////////////
   private MACRO processNextMaskToken(expr:STRING, token:TCntMaskToken):BOOL
      var curSym;
      var stat;

      if (token.Type == TP_TOKEN_SYMBOL)
         /* должно быть строгое соответсвие */
         curSym = substr(expr, ExprPos, 1);
         
         if ((ValType(curSym) != V_UNDEF) AND 
             (curSym != "") AND 
             (curSym == token.Val))
            ExprPos = ExprPos + 1;
            return true;
         end; 
      elif (token.Type == TP_TOKEN_SINGLE)
         return processSingleToken(expr, token);
      elif (token.Type == TP_TOKEN_RANGE)
         return processRangeToken(expr, token);
      elif (token.Type == TP_TOKEN_VAR_RANGE)
         return processVarRangeToken(expr, token);
      else
         RunError("Неизвестный элемент маски ПС 'Contact'");
      end;

      /* не соответствует маске */
      return false;
   END;

   /////////////////////////////////////////////////////// 
   // Синхронизация позиции выражения после элемента маски
   // 1. Для токена типа 2 [WNЮ] NNN, на случай, если было задано 
   // больше символов нужного вида. Пытаемся встать на первый символ, 
   // удовлетворяющий следующему после [WNЮ] NNN токену
   // 2. Проверить что оставшиеся в конце выражения символы токена типа 2
   // соответствуют токену
   // 
   // Результат выполнения метода, удалось ли встать на позицию - 
   // позиция ExprPos меняется соответствующим образом
   ///////////////////////////////////////////////////////
   private MACRO synchronize(expr:STRING, oldToken:TCntMaskToken, curToken:TCntMaskToken):BOOL
      var curSym = substr(expr, ExprPos, 1);
      if ((curToken != null) AND
          (oldToken != null) AND
          (oldToken.Type == TP_TOKEN_RANGE)) /* штатная работа в середине выражения */
         /* теоретически идем до конца выражения */
         while ((ValType(curSym) != V_UNDEF) AND (curSym != ""))
            if ((curToken.Type == TP_TOKEN_SYMBOL) AND (curSym == curToken.Val))
               return true;
            elif (curToken.Type == TP_TOKEN_SINGLE)
               if (checkSingleToken(curSym, curToken))
                  return true;
               end;
            elif (curToken.Type == TP_TOKEN_RANGE)
               if (checkRangeToken(curSym, curToken))
                  return true;
               end;
            elif (curToken.Type == TP_TOKEN_VAR_RANGE)
               /* в этом случае должно быть точное соответствие первому символу за ~ */
               if (curSym == substr(curToken.Val, 2, 1))
                  return true;
               end;
            end;

            /* текущий символ не соответствует следующему токену, в этом случае нужно убедится, 
               что текущий символ все еще соответсвует действующему (предыдущему) токену */
            if (NOT checkRangeToken(curSym, oldToken))
               return false;
            end;
            
            ExprPos = ExprPos + 1;
            curSym = substr(expr, ExprPos, 1);
         end;

         return false;         
      elif ((curToken == null) AND
          (oldToken != null) AND
          (oldToken.Type == TP_TOKEN_RANGE)) /* проверяем последний токен */
         while ((ValType(curSym) != V_UNDEF) AND (curSym != ""))

            if (NOT checkRangeToken(curSym, oldToken))
               return false;
            end;

            ExprPos = ExprPos + 1;
            curSym = substr(expr, ExprPos, 1);
         end;

         return true;
      end;
      /* синхронизация не требуется */
      return true;
   END;

   /////////////////////////////////////////////////////// 
   // Метод сравнивает соответствует ли выражение маске
   ///////////////////////////////////////////////////////
   MACRO match(p_Expression:STRING):BOOL
      var currentToken = null;
      var oldToken = null;
      var stat = true;

      /* сбрасываем позицию выражения */
      ExprPos = 1;

      while((stat) AND (currentToken = getNextMaskToken()))
         /* синхронизация нужна для элементов маски вида [WNЮ] NNN
            поскольку данная конструкция задает минимальное количество 
            символов, их может быть больше и строка "убежит" от маски */
         if (not synchronize(p_Expression, oldToken, currentToken))
            /* если не прошла синхронизация - капут */
            return false;
         end;
          
         stat = processNextMaskToken(p_Expression, currentToken);
         oldToken = currentToken;
      end;

      if ((stat == true) AND ( not synchronize(p_Expression, oldToken, currentToken)))
         /* напоследок - синхронизация */
         return false;
      end;
       
      return stat;
   END;
END;
