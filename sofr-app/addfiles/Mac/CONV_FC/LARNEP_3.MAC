/*
  RS-Retail
  Конвертирование рублевых данных в RS-Retail
  1998 год

  Третья часть конвертера (универсальная)
  Конвертирование операций на основании промежуточного файла операций

  Ромодин Александр Васильевич
  21.10.97
  Рыжиков Александр Александрович
  11.06.98
*/
Import "common.mac","oper_num.mac";

/*
  Файлы
*/
file DEPCLNT   ("depclnt.dbt");              /* Список клиентов (вкладчиков) */
file AUXINFO   ("auxinfo.1")write;           /* Доп.информация по счету */

file LogFile() txt 250;                /* Для просмотра протокола */

record SBDEPDOC_ (sbdepdoc);
/*
  Переменные
*/
var IsRecordInPcCalc;   /* Есть ли запись по счету в PcCalc?    */
var NumDayDoc;
var NumInsStr = 0;      /* Количество вставленных операций      */
var IsOperToAlt = FALSE;
var NeedPercent = TRUE;
var PercBeginDate = Date(0,0,0);
/*
  Параметры по счету
*/
var Rest2001,
    Rest2002,
    Rest2003,
    Rest2004;
var SumPerc;
var DateLastCalcPerc;
var DateLastCompens;

/**********************************************************/

macro ChangeAccToAlt ()
/*
  Установка счета в альтернативный режим (из основного)
*/
  var stat = TRUE;
  var ErrText, ErrCode;
  var Date_Document = SBDEPDOC.Date_Document, dd, prevdd;

  if (DEPOSITR.UseAlternate == 0)
/*  Счет стал с нарушениями */
    DEPOSITR.UseAlternate = 1;
/*
    Определение даты смены типа остатков
*/
    if (SB_DTYP.FormContr == 30)
      if (DEPOSITR.Start_DateDep != Date(0,0,0))
        dd = DEPOSITR.Start_DateDep;
        while (dd <= Date_Document)
          prevdd = dd;
          if ((dd == DEPOSITR.Start_DateDep) OR
           (DEPOSITR.Term_Prol == 0) OR (DEPOSITR.KindTerm_Prol == 0))
            dd = SumDate(dd,DEPOSITR.Term,DEPOSITR.KindTerm);
          else
            dd = SumDate(dd,DEPOSITR.Term_Prol,DEPOSITR.KindTerm_Prol);
          end;
          dd = dd + 1;  /* Начало следующего договора */
        end;
        Date_Document = prevdd;
      else
        PutConvMessage (M_ERROR," Ошибка при вводе строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
      end;
    end;
    KeyNum (PC_DREST,0);
    PC_DREST.Referenc = SBDEPDOC.Referenc;
    /*VIG не уверен, возможно =Date_Document - 1*/
    PC_DREST.Date_Rest = Date_Document;
    PC_DREST.Type_Object = 2001;
    if (NOT GetEQ(PC_DREST))
      PC_DREST.Referenc = SBDEPDOC.Referenc;
      PC_DREST.Date_Rest = Date_Document;
      PC_DREST.Type_Object = 2001;
      PC_DREST.Rest = 0;
      PC_DREST.FNCash = SBDEPDOC.FNCash;
      PC_DREST.NumSession = 0;
      PC_DREST.Action = 1;
      PC_DREST.NumSession = -1;
      stat = Insert(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при вводе строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    else
      PC_DREST.Rest = 0;
      stat = Update(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при корректировке строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    end;

    PC_DREST.Referenc = SBDEPDOC.Referenc;
    PC_DREST.Date_Rest = Date_Document;
    PC_DREST.Type_Object = 2002;
    if (NOT GetEQ(PC_DREST))
      PC_DREST.Referenc = SBDEPDOC.Referenc;
      PC_DREST.Date_Rest = Date_Document;
      PC_DREST.Type_Object = 2002;
        PC_DREST.Rest = DenomSum (SBDEPDOC.Rest,SBDEPDOC.Date_Document,
         SBDEPDOC.TypeOper);
      PC_DREST.FNCash = SBDEPDOC.FNCash;
      PC_DREST.NumSession = 0;
      PC_DREST.Action = 1;
      PC_DREST.NumSession = -1;
      stat = Insert(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при вводе строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    else
        PC_DREST.Rest = DenomSum (SBDEPDOC.Rest,SBDEPDOC.Date_Document,
         SBDEPDOC.TypeOper);
      stat = Update(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при корректировке строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    end;
  end;
  return stat;
end;
/**********************************************************/

macro AuxFile
/*
  Заполнение файла доп.информации по счету
*/
  var stat = TRUE;
  var ErrText, ErrCode;

  KeyNum (AUXINFO,0);
  AUXINFO.Reference = SBDEPDOC.Referenc;
  AUXINFO.InfoType = 1;
  AUXINFO.Date = SBDEPDOC.Date_Document + 1;
  if (NOT GetEQ(AUXINFO))
    AUXINFO.Reference = SBDEPDOC.Referenc;
    AUXINFO.InfoType = 1;
    AUXINFO.Date = SBDEPDOC.Date_Document + 1;
    AUXINFO.GlobPerc = SBDEPDOC.PercRest;
    AUXINFO.AltPerc = SBDEPDOC.PercOprSum;
    AUXINFO.FNcash = SBDEPDOC.FNCash;
    if (PercentPayed())
      AUXINFO.GlobFlag = "X";
      AUXINFO.AltFlag = "X";
    else
      AUXINFO.GlobFlag = "";
      AUXINFO.AltFlag = "";
    end;
    AUXINFO.NumSession = -1;
    stat = Insert(AUXINFO);
    if (NOT stat)
      ErrCode = Status(ErrText);
      PutConvMessage (M_ERROR," Ошибка при вводе строки в файл доп.информации по счету "+
       Trim(DEPOSITR.Account));
      PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
    end;
  else
    AUXINFO.GlobPerc = AUXINFO.GlobPerc + SBDEPDOC.PercRest;
    AUXINFO.AltPerc = AUXINFO.AltPerc + SBDEPDOC.PercOprSum;
    if (PercentPayed())
      AUXINFO.GlobFlag = "X";
      AUXINFO.AltFlag = "X";
    end;
    stat = Update(AUXINFO);
    if (NOT stat)
      ErrCode = Status(ErrText);
      PutConvMessage (M_ERROR," Ошибка при корректировке доп.информации по счету "+
       Trim(DEPOSITR.Account));
      PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
    end;
  end;
  DEPOSITR.ConvertRec = "X";
  if (DEPOSITR.Type_Account == KindChild)
    DEPOSITR.Prol_DateDep = Date (1,1,CurY);
  end;
  return stat;
end;

/**********************************************************/
macro RecordCasln ()
   sb_casln.ApplicationKind1 = SBDEPDOC.iApplicationKind;
   sb_casln.ApplicationKey1  = SBDEPDOC.ApplicationKey;
   sb_casln.NumLinkDoc       = 0;
   sb_casln.ApplicationKind2 = SBDEPDOC.iApplicationKind;
   sb_casln.ApplicationKey2  = SBDEPDOC.ApplicationKey;
   sb_casln.RefValue2        = 0;
   sb_casln.FNCash           = SBDEPDOC.FNCash;
   sb_casln.NumSession       = -1;
   return (Insert (sb_casln));
end;

/**********************************************************/

macro RecordDepDoc
/*
  Заполнение строки истории операций
*/
  var stat = TRUE;
  var ErrCode, ErrText;

  KeyNum (SBDEPDOC, 2);
  ClearRecord (SBDEPDOC);

  if (stat)
    ClearRecord (SBDEPDOC);
    Copy (SBDEPDOC,PROMF);
    SBDEPDOC.Referenc = DEPOSITR.Referenc;
    if (SBDEPDOC.NumDayDoc == 0)
      NumDayDoc = NumDayDoc + 1;
      SBDEPDOC.NumDayDoc = NumDayDoc * 10;
    end;
    if( DEPOSITR.GroupNumb != "Неподвижный" )
/*         AND (DEPOSITR.GroupNumb != "Объединенный") )*/
      SBDEPDOC.Type_Account = DEPOSITR.Type_Account;
    else
      SBDEPDOC.Type_Account = DEPOSITR.PrevAccount;
    end;
    SBDEPDOC.FNCash = DEPOSITR.FNCash;
    if (SBDEPDOC.Account == "")
      stat = FALSE;
      PutConvMessage (M_ERROR, "Не задан счет!");
    end;
  end;

  if (stat)
    if ((SBDEPDOC.Date_Document == Date(0,0,0)) OR
     (SBDEPDOC.DepDate_Document == Date(0,0,0)))
      PutConvMessage (M_ERROR, "Не задана дата операции для счета "+
       SBDEPDOC.Account);
      stat = FALSE;
    end;
  end;
  if (stat)
    if ( ((SBDEPDOC.IsCur==0) AND (SBDEPDOC.Code_Currency!=0)) OR
         ((SBDEPDOC.IsCur!=0) AND (SBDEPDOC.Code_Currency==0)) )
      PutConvMessage (M_ERROR, "Не соответствуют код и признак валюты для счета "+
       SBDEPDOC.Account);
      stat = FALSE;
    end;
  end;
  if (stat)
    if (SBDEPDOC.Oper == 0)
      SBDEPDOC.Oper = 9999;
    end;
    if ((SBDEPDOC.TypeOper == 73) AND
     ((SBDEPDOC.ApplType < 1) OR (SBDEPDOC.ApplType > MaxApplType)))
      PutConvMessage (M_ERROR, "Не задан вид начисления для операции по счету "+
       SBDEPDOC.Account);
      stat = FALSE;
    end;
  end;
  if (stat)
    if (SBDEPDOC.KindOp == 0)
      SBDEPDOC.KindOp = 1;
    end;
    if (SBDEPDOC.Ground == "")
      SBDEPDOC.Ground = "Конвертирование операции";
    end;
    SBDEPDOC.CodClient = DEPOSITR.CodClient;
    if ((SBDEPDOC.TypeOper == 0) AND
     (SubStr(SBDEPDOC.Ground,1,3) != "ДЕН"))
      PutConvMessage (M_ERROR, "Не задан код операции по счету "+
       SBDEPDOC.Account);
      stat = FALSE;
    end;
  end;

  if (stat)
    if (SBDEPDOC.TypeOper == OperToAlt)
      if (SBDEPDOC.TypeComplexOper != 0)
        SBDEPDOC.TypeOper = SBDEPDOC.TypeComplexOper;
      else
        SBDEPDOC.TypeOper = 4;
      end;
      stat = ChangeAccToAlt ();
    end;
  end;
/*
  Заполняем файл доп.условий по счету
*/
  if (stat AND (NeedInsertDopPercent()))
    stat = AuxFile ();
    if (SBDEPDOC.PercRest < 0)
      NeedPercent = FALSE;
/*      IsRecordInPcCalc = TRUE; */
    end;
    if (DEPOSITR.UseAlternate == 0)
      SBDEPDOC.PercOprSum = 0;
      SBDEPDOC.PercRest = 0;
    end;
  end;
/*
  Занесение строки в depdoc
*/
  if (stat)
    if (SBDEPDOC.TypeComplexOper == 0)
      SBDEPDOC.TypeComplexOper = SBDEPDOC.TypeOper;
    end;
    SBDEPDOC.NumSession = -1;
    SBDEPDOC.iApplicationKind = 1;
    SBDEPDOC.ApplicationKey = FormApplicationKey (1);
    stat = RecordCasln ();
    if( not stat )
       PutConvMessage (M_ERROR, " В файл связок не была внесена запись по счету " +
                                Trim(DEPOSITR.Account));
    end;
    stat = Insert(SBDEPDOC);
    DEPOSITR.Sum_Rest = SBDEPDOC.Rest;
    Update (DEPOSITR);
    if (NOT stat)
      PutConvMessage (M_ERROR," Ошибка при добавлении операции по счету "+
       Trim(DEPOSITR.Account));

      ErrCode = Status (ErrText);

      PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
    end;
  end;
  if (SBDEPDOC.TypeOper == OperToAlt)
    IsOperToAlt = TRUE;
  end;
  return stat;
end;
/**********************************************************/

macro GetObjectType
/*
  Получение вида остатка (основной\альтернативный)
*/
  var stat;
  if (DEPOSITR.UseAlternate==0)
    if ((SBDEPDOC.TypeOper != 72) AND
        (SBDEPDOC.TypeOper != 6)  AND  /* Не проценты */
        (SBDEPDOC.TypeOper != 0))      /* Не деноминация */
      stat = 2001;
    else
      stat = 2001;
    end;
  else
    stat = 2002;
  end;
  return stat;
end;
/**********************************************************/

macro ForOutPerc
/*
  Распределение остатков для выдачи процентов
*/
  var stat = TRUE;
  var DateLastPay = Date(0,0,0),
      DateNextPay = Date(0,0,0);
  var Graf,
      Period;
  var Sum = SBDEPDOC.OutSum - SumPerc;
  var Type_Object = 2001;
  var st;
  var ErrCode, ErrText;

  if (SBDEPDOC.OutSum != 0)
    Sum = DenomSum (Sum,SBDEPDOC.Date_Document, SBDEPDOC.TypeOper);
  else
    Sum = 0;
  end;
/*
  Предыдущая оплата процентов
*/
  if (DateLastCalcPerc == Date(0,0,0))
      WorkWithDate (DateConvert,SB_DTYP.GrafPay,SB_DTYP.DayPay, DateNextPay);
      if ((DateNextPay == Date(0,0,0)) OR
        (DateNextPay > DEPOSITR.End_DateDep))
        if (DEPOSITR.End_DateDep != Date(0,0,0))
          DateNextPay = DEPOSITR.End_DateDep;
        end;
      end;
      if (DateNextPay == Date(0,0,0))
        PutConvMessage (M_ERROR," По счету "+
         Trim(DEPOSITR.Account) + " не определена дата расчета процентов");
        stat = FALSE;
      end;

      if (stat)
        if (SB_DTYP.GrafPay == 5)
          Graf = R_MON;
          Period = -1;
        else
          Graf = SB_DTYP.GrafPay;
          Period = -1;
        end;
      end;
      if (stat)
        DateLastPay = SumDate (DateNextPay, Period, Graf);
        if ((DateLastPay < DEPOSITR.Prol_DateDep) OR
            (DateLastPay == Date(0,0,0)))
          DateLastPay = DEPOSITR.Prol_DateDep - 1;
        end;
        if (DateLastPay == Date(0,0,0))
          PutConvMessage (M_ERROR," По счету "+
           Trim(DEPOSITR.Account) + " не определена дата последнего "+
            "расчета процентов");
          stat = FALSE;
        end;
      end;
  else
    DateLastPay = DateLastCalcPerc;
  end;
/*
  Чистка основного остатка на заданную сумму
  (начиная с даты DateLastPay до конца)
*/
  if (stat)
    KeyNum (PC_DREST,0);
    PC_DREST.Referenc = SBDEPDOC.Referenc;
    PC_DREST.Date_Rest = DateLastPay;
    PC_DREST.Type_Object = Type_Object;
    if (NOT GetGE(PC_DREST))
      PutConvMessage (M_ERROR," Для счета "+
       Trim(DEPOSITR.Account)+" нет остатков по основному счету на "+
       String(DateLastPay));
      stat = FALSE;
    else
      st = TRUE;
      while (st AND (PC_DREST.Referenc == SBDEPDOC.Referenc) AND
       (PC_DREST.Type_Object == Type_Object))
        if (PC_DREST.Date_Rest != SBDEPDOC.Date_Document) /* Пропустить свою операцию (уже учтена) */
          PC_DREST.Rest = PC_DREST.Rest - Sum;
          stat = Update(PC_DREST);
          if (NOT stat)
            ErrCode = Status(ErrText);
            PutConvMessage (M_ERROR," Ошибка при корректировке остатков для выдачи % по счету "+
             Trim(DEPOSITR.Account));
            PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
          end;
        end;
        st = Next (PC_DREST);
      end;
    end;
  end;
  return stat;
end;
/**********************************************************/

macro RecordDrest
/*
  Занесение информации в файл остатков для расчета процентов
*/
  var stat = TRUE;
  var ErrCode, ErrText;
  var Sum = 0, Rest = 0;

  KeyNum (PC_DREST,0);
  PC_DREST.Referenc = SBDEPDOC.Referenc;
  PC_DREST.Date_Rest = SBDEPDOC.Date_Document;
  PC_DREST.Type_Object = GetObjectType();
  if (IsKindSbereg(DEPOSITR.Type_Account))
    if (SBDEPDOC.NumDayDoc != 10)
      if (SBDEPDOC.InSum != 0)
        Sum = SBDEPDOC.InSum;
      elif (SBDEPDOC.OutSum != 0)
        Sum = - SBDEPDOC.OutSum;
      end;
    else
      Sum = SBDEPDOC.Rest;
    end;
    if ((SBDEPDOC.Date_Document != Date(31,12,1997)) OR
     (SBDEPDOC.TypeOper != 72) )
      Sum = DenomSum (Sum,SBDEPDOC.Date_Document,SBDEPDOC.TypeOper);
    end;
    if (PC_DREST.Type_Object == 2001)
      Rest = Rest2001 + Sum;
      Rest2001 = Rest;
    elif (PC_DREST.Type_Object == 2002)
      Rest = Rest2002 + Sum;
      Rest2002 = Rest;
    elif (PC_DREST.Type_Object == 2003)
      Rest = Rest2003 + Sum;
      Rest2003 = Rest;
    elif (PC_DREST.Type_Object == 2004)
      Rest = Rest2004 + Sum;
      Rest2004 = Rest;
    end;
  else
    Rest = SBDEPDOC.Rest;
    Sum = Rest;
  end;
  if (Sum == 0)
    if (Rest == 0)
      Rest = DenomSum (SBDEPDOC.Rest,SBDEPDOC.Date_Document,
       SBDEPDOC.TypeOper);
    elif (SBDEPDOC.TypeOper != 0)
      PutConvMessage (M_ERROR," По счету "+
       Trim(DEPOSITR.Account) + " нулевая сумма операции");
    end;
  end;
  if (PC_DREST.Type_Object > 0)
    if (NOT GetEQ(PC_DREST))
      PC_DREST.Referenc = SBDEPDOC.Referenc;
      PC_DREST.Date_Rest = SBDEPDOC.Date_Document;
      PC_DREST.Type_Object = GetObjectType();
      PC_DREST.Rest = Rest;
      PC_DREST.FNCash = SBDEPDOC.FNCash;
      PC_DREST.NumSession = 0;
      PC_DREST.Action = 1;
      PC_DREST.NumSession = -1;
      stat = Insert(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при вводе строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    else
      PC_DREST.Rest = Rest;
      stat = Update(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при корректировке строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    end;
  end;
/*
  Причисление процентов для выдачи процентов
*/
  if ((SBDEPDOC.TypeOper == 72) AND (SBDEPDOC.TypeComplexOper == 6))
    SumPerc = SBDEPDOC.InSum;
  end;
  if (SBDEPDOC.TypeOper == 6)
    stat = ForOutPerc ();
    SumPerc = 0;
  end;
  return stat;
end;

/**********************************************************/

/*VIG наверное эта функция не нужна*/
macro CloseAccount
/*
  Оформление закрытого счета
*/
  var EOB = FALSE;
  var stat = TRUE;
  var ErrCode, ErrText;

  DEPOSITR.Open_Close = "З";
  DEPOSITR.Close_Date = SBDEPDOC.Date_Document;
end;
/**********************************************************/

macro OpenAccount
/*
  Оформление открытия счета
*/
  var EOB = FALSE;
  var stat = TRUE;
  var ErrCode, ErrText;

  DEPOSITR.Open_Close = "";
  /*Закоментировано VIG*/
  /*
  DEPOSITR.Open_Date = SBDEPDOC.Date_Document;
  */
  DEPOSITR.Close_Date = Date(0,0,0);
  if ((SB_DTYP.FormContr == 1) OR (SB_DTYP.FormContr == 20) OR
      (SB_DTYP.FormContr == 30))
    DEPOSITR.Start_DateDep = SBDEPDOC.Date_Document;
  end;
  if (DEPOSITR.Type_Account != KindPension)
    DEPOSITR.UseAlternate = 0;
  else
    DEPOSITR.UseAlternate = 1;
  end;
/*VIG 14.12.99*/
end;
/**********************************************************/

macro ChangeAlternateAccount ()
/*
  Установка счета в основной режим (из альтернативного)
*/
  var stat = TRUE;
  var ErrText, ErrCode;

  if (DEPOSITR.UseAlternate != 0)
/*  Счет стал без нарушений */
    DEPOSITR.UseAlternate = 0;
    KeyNum (PC_DREST,0);
    PC_DREST.Referenc = SBDEPDOC.Referenc;
    PC_DREST.Date_Rest = SBDEPDOC.Date_Document;
    PC_DREST.Type_Object = 2002;
    if (NOT GetEQ(PC_DREST))
      PC_DREST.Referenc = SBDEPDOC.Referenc;
      PC_DREST.Date_Rest = SBDEPDOC.Date_Document;
      PC_DREST.Type_Object = 2002;
      PC_DREST.Rest = 0;
      PC_DREST.FNCash = SBDEPDOC.FNCash;
      PC_DREST.NumSession = 0;
      PC_DREST.Action = 1;
      PC_DREST.NumSession = -1;
      stat = Insert(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при вводе строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    else
      PC_DREST.Rest = 0;
      stat = Update(PC_DREST);
      if (NOT stat)
        ErrCode = Status(ErrText);
        PutConvMessage (M_ERROR," Ошибка при корректировке строки в историю остатков по счету "+
         Trim(DEPOSITR.Account));
        PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
      end;
    end;
  end;
  return stat;
end;
/**********************************************************/

macro RestForCompens
(
 Date_Document  /* Дата, до которой чистим остатки (не включая ее) */
)
/*
  Распределение остатков для выдачи компенсации
*/
  var stat = TRUE;
  var SumCompens = 0;
  var Type_Object = 2001;
  var st, st1;
  var ErrCode, ErrText;
  var Account = SBDEPDOC.Account;
/*
  Цикл по уже заполненным документам-  поиск компенсаций
*/
  KeyNum (SBDEPDOC,0);
  SBDEPDOC.IsCur = FlagCur;
  SBDEPDOC.FNCash = FNCash;
  SBDEPDOC.Account = Account;
  SBDEPDOC.DepDate_Document = DateLastCompens + 1;
  SBDEPDOC.NumDayDoc = 0;
  st1 = GetGE (SBDEPDOC);
  while (st1 AND (SBDEPDOC.IsCur == FlagCur) AND
   (SBDEPDOC.FNCash == FNCash) AND (SBDEPDOC.Account == Account))
    if ((SBDEPDOC.TypeOper == 73) AND (SBDEPDOC.ApplType == AT_Compensation))
      SumCompens = DenomSum (SBDEPDOC.InSum,SBDEPDOC.Date_Document,
       SBDEPDOC.TypeOper);
/*
      Чистка основного остатка на заданную сумму
*/
      KeyNum (PC_DREST,0);
      PC_DREST.Referenc = SBDEPDOC.Referenc;
      PC_DREST.Date_Rest = SBDEPDOC.Date_Document;
      PC_DREST.Type_Object = Type_Object;
      if (NOT GetGE(PC_DREST))
        PutConvMessage (M_ERROR," Для счета "+
         Trim(DEPOSITR.Account)+" нет остатков по основному счету на "+
         String(SBDEPDOC.Date_Document));
        stat = FALSE;
      else
        st = TRUE;
        while (st AND (PC_DREST.Referenc == SBDEPDOC.Referenc) AND
         (PC_DREST.Type_Object == Type_Object) AND
         (PC_DREST.Date_Rest < Date_Document)) /* Пропустить свою операцию (уже учтена) */
          PC_DREST.Rest = PC_DREST.Rest - SumCompens;
          stat = Update(PC_DREST);
          if (NOT stat)
            ErrCode = Status(ErrText);
            PutConvMessage (M_ERROR," Ошибка при корректировке остатков для выдачи компенсации по счету "+
             Trim(DEPOSITR.Account));
            PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
          end;
          st = Next (PC_DREST);
        end;
      end;
    end;
    st1 = Next (SBDEPDOC);
  end;
  DateLastCompens = Date_Document;
  return stat;
end;
/**********************************************************/

macro WritePercentForOper
(
 ObjectType     /* Основной или альтернативный */
)
/*
  Заполнение расчета процентов в PcCalc
*/
  var stat = TRUE;
  var ErrCode, ErrText;
  var stt = False;
  var Sum = 0;
  var OldRef = 0;
  var OldDepDate = Date (0,0,0);
  var OldNumDayDoc = 0;
  var ProcStat = True;
/*
  Поиск счета процентов
  (заполняется для основных условий начисления процентов)
*/
/*
  if (NOT NeedPercent)
    return TRUE;
  end;
*/
  if (stat)
/*
    Запись о расчете и оплате
*/
    ClearRecord (PC__CALC);
    PC__CALC.Referenc   = SBDEPDOC.Referenc;
    PC__CALC.FNCash     = DEPOSITR.FNCash;
    PC__CALC.TypeRecord = 1;
    PC__CALC.NumSession = -1;

    /*VIG - не надо деноминировать*/
    /*Sum = DenomSum( Sum, SBDEPDOC.Date_Document, SBDEPDOC.TypeOper );
    */

    /*VIG - эта часть кода обеспечивает правильную нарезку периодов в PC__CALC*/
    Sum = SBDEPDOC.PercOprSum;
    PC__CALC.ObjectType = ObjectType;
    PC__CALC.SumPay     = Sum;
    PC__CALC.SumCalc    = Sum;
    PC__CALC.SumForPay  = PC__CALC.SumCalc - PC__CALC.SumPay;

    OldRef       = SBDEPDOC.Referenc;
    OldDepDate   = SBDEPDOC.DepDate_Document;
    OldNumDayDoc = SBDEPDOC.NumDayDoc;
    while (ProcStat and (SBDEPDOC.DepDate_Document == OldDepDate) )
      ProcStat = Prev (SBDEPDOC);
    end;
    if (ProcStat)
      if (SBDEPDOC.Referenc == OldRef)
/*        MsgBox ("1 ", SBDEPDOC.Referenc, " , ", OldRef, " , ", SBDEPDOC.Date_Document);*/
        PC__CALC.BeginDate = SBDEPDOC.Date_Document;
        Next (SBDEPDOC);
      else
        Next (SBDEPDOC);
        PC__CALC.BeginDate = DEPOSITR.DateBeginPerc;
      end;
    else
      PC__CALC.BeginDate = DEPOSITR.DateBeginPerc;
    end;
    while ( (OldRef != SBDEPDOC.Referenc)             or
            (OldDepDate != SBDEPDOC.DepDate_Document) or
            (OldNumDayDoc != SBDEPDOC.NumDayDoc)
          )
      Next (SBDEPDOC);
    end;

    /*VIG - Конец страшной части кода*/

    PC__CALC.EndDate    = SBDEPDOC_.Date_Document;
    PercBeginDate = PC__CALC.EndDate + 1;
    stat = Insert( PC__CALC ); /* VIG Чтобы не отваливалась */
/*    Insert( PC__CALC );*/
    if( NOT stat )
      ErrCode = Status(ErrText);
      if (ErrCode == 5)
         stat = GetEQ( PC__CALC );
         if ( NOT stat )
            PutConvMessage (M_ERROR," Ошибка при вводе строки в историю оплат % по счету "+
               Trim(DEPOSITR.Account) + " " + PC__CALC.BeginDate + " " + PC__CALC.EndDate);
            PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
         end;
      end;
    end;
  elif( (DEPOSITR.Open_Close != "З") AND (DEPOSITR.Type_Account != KindUnited) )
    PutConvMessage (M_ERROR," Для счета "+
     Trim(DEPOSITR.Account)+
     " нет счета процентов для основных условий");
  else
    stt = True;
  end;
/*
  Добавление записи об операции для стратегии расчета
  "До конца периода"
*/
  if (stat)
      if ((SB_DTYP.StratCalc == 2) OR      /* Сведения о % в карточке- обязательно */
          (SB_DTYP.StratCalc == 3))
        if ((SBDEPDOC.PercOprSum == 0) AND
            (SBDEPDOC.PercRest == 0))
          SBDEPDOC.PercOprSum = SBDEPDOC.InSum;
          SBDEPDOC.PercRest = SBDEPDOC.PercOprSum;
          stat = Update(SBDEPDOC);
          if (NOT stat)
            ErrCode = Status(ErrText);
            PutConvMessage (M_ERROR," Ошибка при обновлении операции причисления % счету "+
            Trim(DEPOSITR.Account));
            PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
          end;
        end;
      end;
  end;
  if ((NOT stat) AND stt)
    stat = True;
  end;
  return stat;
end;
/**********************************************************/

macro WorkWithStrInterFile
/*
  Обработка строки Промежуточного файла
*/
  var stat = TRUE;
/*
  Заполнение истории операций
*/

  if (stat)
    stat = RecordDepDoc ();
  end;
/*
  Если операция закрытия счета- закрытие
*/
  if (stat AND (SBDEPDOC.KindOp != D_ARC))
    if ((SBDEPDOC.TypeOper == 34) OR (SBDEPDOC.TypeOper == 10) OR
     (SBDEPDOC.TypeOper == 81) OR
     (SBDEPDOC.TypeComplexOper == 34) OR (SBDEPDOC.TypeComplexOper == 10) OR
     (SBDEPDOC.TypeComplexOper == 81))
      CloseAccount();
      PutConvMessage (M_MESSAGE," Счет "+sbdepdoc.Account+" закрыт конвертером");

    end;
  end;
/*
  Если операция открытия счета- открытие
*/
  if (stat AND (SBDEPDOC.KindOp != D_ARC))
    if ((SBDEPDOC.TypeOper == 31) OR (SBDEPDOC.TypeOper == 1) OR
     (SBDEPDOC.TypeOper == 51) OR
     (SBDEPDOC.TypeComplexOper == 31) OR (SBDEPDOC.TypeComplexOper == 1) OR
     (SBDEPDOC.TypeComplexOper == 51))
      if ((SB_DTYP.FormContr != 20) OR (DEPOSITR.UseAlternate == 0))
        stat = OpenAccount();
      end;
    end;
  end;
/*
  Если вклад пенсионный и операция- зачисление пенсии- перевод
  счета в основной режим
*/
  if (stat)
    if ( (Trim(SBDEPDOC.Type_Account)==KindPension) AND
     (SBDEPDOC.TypeOper == 73) AND (SBDEPDOC.ApplType == APP_PENSION) AND
     (SBDEPDOC.KindOp != D_ARC))
      stat = ChangeAlternateAccount ();
    end;
  end;
/*
  Заполнение файла исходящих остатков для расчета процентов
  !!! Только после обработки Пенсионного !!!
*/
/*  if (stat AND (SBDEPDOC.KindOp != D_ARC) AND NeedPercent)*/
  if (stat AND (SBDEPDOC.KindOp != D_ARC))
    if ((NOT(IsKindSbereg(DEPOSITR.Type_Account))) OR /* Не сберегательный */
     (SBDEPDOC.TypeOper != 0))      /* Не деноминация */
      stat = RecordDrest ();
    end;
  end;
/*
  Чистка остатков при выдаче компенсации
*/
  if (stat AND (SBDEPDOC.KindOp != D_ARC) AND (SBDEPDOC.TypeOper == 15))
    stat = RestForCompens (SBDEPDOC.Date_Document);
  end;
/*
  Если проценты- запись в pccalc
*/
  if (stat AND (SBDEPDOC.KindOp != D_ARC))
    if ((SBDEPDOC.TypeOper == 72) AND
        (SBDEPDOC.TypeComplexOper != 6) AND
        (SBDEPDOC.TypeComplexOper != 15)) /* Для выдачи %- не заносим */
      DateLastCalcPerc = SBDEPDOC.Date_Document;
      IsRecordInPcCalc = TRUE;
      Copy (SBDEPDOC_, SBDEPDOC);
      stat = WritePercentForOper (2001);
      if (stat AND
/*       ( ((DEPOSITR.UseAlternate == 1) AND NeedInsertPsRest()) OR*/
       ( (NeedInsertPsRest()) OR
          (NeedOnlyPayPercent())))
        /*VIG 14.12.99*/
        SBDEPDOC.PercOprSum = 0;
        SBDEPDOC.PercRest = 0;
      end;
    end;
  end;
  return stat;
end;
/**********************************************************/

macro RecordDepositr
/*
  Обновление строки счета
*/
  var ErrCode,
      ErrText;
  var stat;

  /*VIG 14.12.99*/
  stat = Update(DEPOSITR);
  if (NOT stat)
    ErrCode = Status(ErrText);
    PutConvMessage (M_ERROR," Ошибка при обновлении строки по счету "+
     Trim(DEPOSITR.Account));
    PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
  else
/*
    if ((DEPOSITR.Open_Close == "З") AND (DEPOSITR.Sum_Rest != 0))
      PutConvMessage (M_WARN," Счет "+Trim(DEPOSITR.Account)+
       " закрыт с не нулевым остатком "+String(DEPOSITR.Sum_Rest));
    end;
*/
  end;
  return stat;
end;
/**********************************************************/

macro FictoPercentForAccount
/*
  Занесение фиктивной записи о расчете и оплате процентов
*/
  var stat = TRUE;
  var DPO, DSO, DSO1, DPO1;
  var ApplType;
  var Per;
  var ercode, ertext;
/*
  По основному или альтернативному?
*/
  if (DEPOSITR.UseAlternate == 0)
    ApplType = 2001;
  else
    ApplType = 2002;
  end;
  ClearRecord (PC_APLTP);
  KeyNum (PC_APLTP, 0);
  Rewind (PC_APLTP);

  if (not KeyNum (PC_APLTP, 0))
     ercode = status (ertext);
     println ("Мать твою ",ercode, " ",ertext);
  end;
  PC_APLTP.IsCur = FlagCur;
  PC_APLTP.Type = DEPOSITR.Type_Account;
  PC_APLTP.ApplType = ApplType;
  PC_APLTP.ApType="";
  if (GetGE(PC_APLTP))
    if ((PC_APLTP.IsCur == FlagCur) AND
     (PC_APLTP.Type == DEPOSITR.Type_Account) AND
     (PC_APLTP.ApplType == ApplType))
      stat = GetTypeRecord (PC_APLTP.ApType,FlagCur);
      if (stat) /* Дата следующего расчета */
        DSO = DEPOSITR.End_DateDep;
        WorkWithDate (DateConvert,SB_DTYP.GrafPay,SB_DTYP.DayPay, DSO1);
        if ((DSO != Date(0,0,0)) AND (DSO1 != Date(0,0,0)))
          if (DSO > DSO1)
            DSO = DSO1;
          end;
        elif (DSO1 != Date(0,0,0))
          DSO = DSO1;
        elif (DSO == Date(0,0,0))
          stat = FALSE;
          PutConvMessage (M_ERROR," Для счета "+Trim(DEPOSITR.Account)+
           " не могу определить дату следующего причисления процентов");
        end;
      else
        PutConvMessage (M_ERROR," Не найден вид вклада \""+Trim(PC_APLTP.ApType)+
         "\" для процентов по счету "+Trim(DEPOSITR.Account));
      end;
      if (stat)
/*        if (DSO <= DateConvert)
          PutConvMessage (M_WARN," Для счета "+Trim(DEPOSITR.Account)+
           " дата следующего причисления % не больше даты конвертирования");
        end; */
/*      Дата последней оплаты процентов */
        if (DEPOSITR.Prol_DateDep != Date(0,0,0))
          DPO = DEPOSITR.Prol_DateDep;
        elif (DEPOSITR.Start_DateDep != Date(0,0,0))
          DPO = DEPOSITR.Start_DateDep;
        else
          DPO = Date(0,0,0);
        end;
        if (SB_DTYP.GrafPay != 0)
          Per = SB_DTYP.GrafPay;
          if (Per == 5)
            Per = 2;
          end;
          DPO1 = SumDate (DSO, -1, Per);
        else
          DPO1 = Date(0,0,0);
        end;
        if ((DPO != Date(0,0,0)) AND (DPO1 != Date(0,0,0)))
          if (DPO < DPO1)
            DPO = DPO1;
          end;
        elif (DPO1 != Date(0,0,0))
          DPO = DPO1;
        elif (DPO == Date(0,0,0))
          DPO = DEPOSITR.Open_Date;
          PutConvMessage (M_ERROR," Для счета "+Trim(DEPOSITR.Account)+
           " не могу определить дату предыдущего причисления процентов");
        end;
      end;
      if (stat)
        if ((DPO - DEPOSITR.Open_Date) > 2) /* Для погрешности */
          ClearRecord (SBDEPDOC_);
          SBDEPDOC_.Account = DEPOSITR.Account;
          SBDEPDOC_.Code_Currency = DEPOSITR.Code_Currency;
          SBDEPDOC_.Date_Document = DPO;
          SBDEPDOC_.Referenc = DEPOSITR.Referenc;
          stat = WritePercentForOper (PC_APLTP.ApplType);
        end;
      end;
    else
      stat = FALSE;
    end;
  else
    stat = FALSE;
  end;
  if (NOT stat)
    PutConvMessage (M_ERROR," Ошибка при попытке занести данные по % для счета "+
     Trim(DEPOSITR.Account));
  end;
  return stat;
end;
/**********************************************************/

macro ForAccountAfterFinish
/*
  Дозапись для только что обработанного счета
*/
  var stat = TRUE;
  var yOpen;
  var ErrCode, ErrText;
/*
  Для пролонгированных, если он помечен как альтернативный, а
  соответствующих операций перевода в альтернативных режим не было
*/
  if ((SB_DTYP.FormContr == 30) AND (NOT IsOperToAlt) AND
   (DEPOSITR.UseAlternate == 1))
    DateSplit (DEPOSITR.Start_DateDep,NULL,NULL,yOpen);
    if (yOpen < CurY)
      DEPOSITR.Prol_DateDep = Date(1,1,CurY);
      KeyNum (SBDEPDOC,0);
      SBDEPDOC.IsCur = DEPOSITR.IsCur;
      SBDEPDOC.FNCash = DEPOSITR.FNCash;
      SBDEPDOC.Account = DEPOSITR.Account;
      SBDEPDOC.DepDate_Document = DEPOSITR.Start_DateDep;
      SBDEPDOC.NumDayDoc = 0;
      stat = GetGE (SBDEPDOC);
      if (stat AND (SBDEPDOC.IsCur == DEPOSITR.IsCur) AND
       (SBDEPDOC.FNCash == DEPOSITR.FNCash) AND
       (SBDEPDOC.Account == DEPOSITR.Account) AND
       (SBDEPDOC.DepDate_Document == DEPOSITR.Start_DateDep))
        SBDEPDOC.DepDate_Document = Date(1,1,CurY) - 1;
        SBDEPDOC.InSum = SBDEPDOC.PercRest;
        SBDEPDOC.Rest = SBDEPDOC.Rest + SBDEPDOC.InSum;
        SBDEPDOC.TypeOper = 72;
        SBDEPDOC.NumSession = -1;
        stat = Insert(SBDEPDOC);
        DEPOSITR.Sum_Rest = SBDEPDOC.Rest;
        if (NOT stat)
          ErrCode = Status(ErrText);
          PutConvMessage (M_ERROR," Ошибка при исправлении операции по счету "+
           Trim(DEPOSITR.Account));
          PutConvMessage (0,"      Код ошибки "+String(ErrCode)+", "+ErrText);
        end;
        if (stat)
          Copy (SBDEPDOC_, SBDEPDOC);
          stat = WritePercentForOper (2002);
        end;
      else
        PutConvMessage (M_ERROR," По счету "+ Trim(DEPOSITR.Account)+
         " не найдена запись за дату начала договора");
      end;
    end;
  end;
/*
  Счет
*/
  if (stat)
    stat = RecordDepositr ();
  end;
/*
  Если не было занесено записи в pccalc
*/
  if (stat AND (DEPOSITR.Open_Close != "З") AND (NOT IsRecordInPcCalc))
    if (SB_DTYP.FormContr == 1) /* Для срочных добавляем только если можно снимать */
      stat = MayGetPercentSr ();
    end;
    if (stat)
      ClearRecord (SBDEPDOC_);
      stat = FictoPercentForAccount ();
    elif (SB_DTYP.FormContr == 1)
      if ((DEPOSITR.Start_DateDep < Date(1,1,CurY)) AND
       (DEPOSITR.End_DateDep != Date(0,0,0)))
        ClearRecord (SBDEPDOC_);
        SBDEPDOC_.Account = DEPOSITR.Account;
        SBDEPDOC_.Code_Currency = DEPOSITR.Code_Currency;
        SBDEPDOC_.Date_Document = SumDate(Global_EndDate,
         (-1)*DEPOSITR.Term,DEPOSITR.KindTerm);
        SBDEPDOC_.Referenc = DEPOSITR.Referenc;
        stat = WritePercentForOper (2002); /* По альтернативе для незавершенных */
      else
        stat = TRUE;
      end;
    end;
  end;
  return stat;
end;
/***********************************************************
************************************************************
 Головной макрос обработки универсального файла операций
***********************************************************/

macro Convert_3 (AutoW)
/*
  Головной макрос
*/
  var NumFile;
  var MayCont;
  var NumStrFile = 0;
  var NumAccount = 0;
  var IsViewLog = TRUE;
  var Account = "";
  var FNCash = 0;
  var NextAccount = FALSE;

  AutoWork = AutoW;
/*
  Ввод параметров с клавиатуры
*/
  MayCont = GetDateConvert (3);
  if (NOT MayCont)
    [ Отказались от конвертирования ];
    IsViewLog = FALSE;
  end;
  if (MayCont)
/*
    Заголовок отчета
*/
    if (NOT AutoWork)
      if (GetTrue(Null,"Очистить файл протокола?"))
        SetOutput(NameLogFile,False);
        SetOutput();
      end;
    end;
    Начало_Конец_отчета ();
    PutConvMessage (M_TITLE, "Конвертирование данных в RS-Retail"+
     "|Часть 3|||"+"Обработка Универсального (промежуточного) файла операций|"+
                   "--------------------------------------------------------|");
/*
    Открытие Универсального промежуточного файла
*/
    MayCont = Open(PROMF,NamePromFile);
    if (NOT MayCont)
      PutConvMessage (M_VERYERROR, "Не открыт Универсальный промежуточный файл "+
       Trim(NamePromFile));
    end;
  end;
/*
  Открытие файла доп.информации по счету
*/
  if (MayCont)
    MayCont = Open(AUXINFO,"auxinfo.dbt");
    if (NOT MayCont)
      PutConvMessage (M_VERYERROR, "Не открыт файл доп.данных по счету ");
    end;
  end;
  if(MayCont)
    if( (NOT Open(PC__CALC,NULL,1)) OR (NOT Open(SBDEPDOC,Null,1))
         OR (NOT Open(PC_DREST,NULL,1)) )
      MayCont = False;
      PutConvMessage (M_VERYERROR, "Не открыты файлы Retail для записи данных ");
    end;
  end;
/*
  Цикл по записям Промежуточного файла
*/
  if (MayCont)
    /*Изменения от VIG*/
/*    KeyNum (PROMF,0);
*/
    KeyNum (PROMF,2);
    NumStrFile = 0;
    ReWind (PROMF);
    while (Next(PROMF))
      if ( (PROMF.Account != Account) or (Promf.FNCash != FNCash) ) /* Следующий счет */
        if ((NOT NextAccount) AND (Account != "")
             AND (DEPOSITR.GroupNumb != "Неподвижный")
             AND (DEPOSITR.GroupNumb != "Объединенный") )
          ForAccountAfterFinish ();
        end;
        NextAccount = FALSE;
        Account = PROMF.Account;
        FNCash  = PROMF.FNCash;
        IsOperToAlt = FALSE;
        IsRecordInPcCalc = FALSE;
        NeedPercent = TRUE;
        NumDayDoc = 0;
        PercBeginDate = Date(0,0,0);
        Rest2001 = 0;
        Rest2002 = 0;
        Rest2003 = 0;
        Rest2004 = 0;
        SumPerc = 0;
        DateLastCalcPerc = Date (0,0,0);
        DateLastCompens = Date (0,0,0);
/*
        Для нового счета ищется строка по счету и по виду вклада
*/
        if (NOT GetTypeRecord(PROMF.Type_Account,FlagCur))
          PutConvMessage (M_ERROR, "Не найден вид вклада \""+
           Trim(PROMF.Type_Account)+"\" для счета "+
           Trim(PROMF.Account));
          NextAccount = TRUE;
        end;
        if (NOT NextAccount)
          if (NOT GetDepositrRecord(PROMF.FNcash,PROMF.Account))
            PutConvMessage (M_ERROR, "Не найден счет  "+
             Trim(PROMF.Account));
            NextAccount = TRUE;
          end;
        end;
/*
        Интересные виды вкладов
*/
        if (NOT NextAccount)
          NumAccount = NumAccount + 1;
        end;
      end;
      if (NOT NextAccount)
        if (NOT WorkWithStrInterFile ())
          NumAccount = NumAccount - 1;  /* Ошибка при обработке */
          NextAccount = TRUE;
          PutConvMessage (M_ERROR, "Ошибка при обработке операции по счету "+
           Trim(PROMF.Account));
        else
          NumInsStr = NumInsStr + 1;
        end;
      end;
      NumStrFile = NumStrFile + 1;
      Message (" Часть 3. Обработано ",NumStrFile," записей Универсального промежуточного файла...");
    end;
    if ((NOT NextAccount) AND (NumAccount > 0)
         AND (DEPOSITR.GroupNumb != "Неподвижный")
         AND (DEPOSITR.GroupNumb != "Объединенный") )
      ForAccountAfterFinish ();
    end;
  end;
/*
    Просмотр протокола
*/
  if (IsViewLog)
    PutConvMessage (M_TITLE, "|| Просмотрено "+Trim(String(NumStrFile))+
     " записей Универсального промежуточного файла||"+
     " Вставлено в базу данных "+Trim(String(NumInsStr))+" операций||"+
     "Занесены данные по "+Trim(String(NumAccount))+" счетам");
    Начало_Конец_отчета ();
    Open(LogFile,NameLogFile);
    Close (LogFile);
    if (NOT AutoWork)
      ViewFile (LogFile);
    end;
  end;
end;
