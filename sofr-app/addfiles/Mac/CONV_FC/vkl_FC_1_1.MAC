/*
  RS-Retail
  Конвертирование данных из
    п/с "Частные вклады" АБС   RS-Bank в
    п/с "Обслуж.физ.лиц" САРБУ RS-Retail
  2000 год

  Первая часть конвертера:
  Конвертирование данных по счетам и вкладчикам (depositr.dbt и depclnt.dbt)

  Рыжиков Александр Александрович
  27.10.2000

  ==========================================================================
  Для опредления резидентности клиента необходимо в depclnt.dbt исходной БД
  заполнить поле YesResident: "" - вкладчик резидент, "N" - нерезидент. 
  ==========================================================================
*/
import "vkl_cm_fc.mac";

/*
  Переменные
*/
var NumStrFile   = 0;   /* Количество сконвертированных записей     */
var KolStrFile   = 0;   /* Количество просмотренных записей         */
var LastReferenc = 0;
var Nrec         = 0;
var KindInLaros  = "";   /* Группа по размещению данных в поле PASP  */

var DateNextCalc = NullDate;
var DatePrevCalc = NullDate;

array Type_Acc, Rests, CountOpen, CountClose;


/**********************************************************
    Перекодировка строки из одной таблицы в другую.
**********************************************************/

/* Таблица перекодировки фамилий */
const strRus = "АаВЕеЕеЗКкМмНОоРрСсТХх";
const strLat = "AaBEeЁё3KkMmHOoPpCcTXx";

macro RecodeString( InpStr, InpABC, OutABC )
  var i   = 1,          /* Позиция символа во входной строке          */
      k   = 0,          /* позиция этого символа во входном алфавите  */
      Lit = "",         /* соответствующая литера после перекодировки */
      OutStr = "";      /* выходная строка                            */

   while( i <= strlen( InpStr ) )
      Lit = substr( InpStr, i, 1 );
      k = index( InpABC, Lit );
      if( k != 0 ) Lit = substr( OutABC, k, 1 ); end;
      OutStr = OutStr + Lit;
      i = i + 1;
   end;

  return OutStr;
end;

/**********************************************************
    Преобразование Ф.И.О. в формат Retail.
**********************************************************/
/* Нормализация строки */
macro NormStr( Str:string ):string
   var stat = True;

   Str = Trim( Str );
   Str = SubStr( Str, 1, 1 ) + StrLwr( SubStr( Str, 2 ) );

   return Str;
end;

const FIODelim = " ";

macro GetFIO
(
 FIOStr,        /* Исходная строка      */
 F,             /* Фамилия              */
 I,             /* Имя                  */
 O              /* Отчество             */
)
/*
  Получение фамилии, имени и отчества из строки
*/
  var F_ = "",
      I_ = "",
      O_ = "",
      ptr= 0;

  FIOStr = RecodeString( trim( FIOStr ), strLat, strRus );

  FIOStr = StrUpr( FIOStr );

  ptr = strbrk( FIOStr, FIODElim );
  if( ptr > 0 )
    F_     = trim( substr( FIOStr, 1, ptr ) );
    FIOStr = trim( substr( FIOStr, ptr+1 ) );

    ptr = strbrk( FIOStr, FIODElim );
    if( ptr > 0 )
      I_     = trim( substr( FIOStr, 1, ptr ) );
      FIOStr = trim( substr( FIOStr, ptr+1 ) );

      O_ = trim( FIOStr );
    else
      I_ = trim( FIOStr );
    end;
  else
    if( strlen( FIOstr ) )   /* Задана только фамилия */
      F_ = FIOstr;
    else
      F_ = "Б\\и";
    end;
  end;
  /* Нормализуем строку */
  F_ = NormStr( F_ );
  I_ = NormStr( I_ );
  O_ = NormStr( O_ );
  setparm( 1, F_ );
  setparm( 2, I_ );
  setparm( 3, O_ );
end;
/**********************************************************/

macro GetGRUPN
(
 GRUPN  /* Категория в Аманат */
)
/*
  Возвращает группу населения в RS-Retail
*/
  var Kategor = 0;

  if   ( GRUPN == 9 )
    Kategor = 3;        /* Пенсионер    */
  elif ( GRUPN == 3 )
    Kategor = 2;        /* Служащий     */
  elif ( GRUPN == 1 )
    Kategor = 1;        /* Рабочий      */
  elif ( GRUPN == 2 )
    Kategor = 4;        /* Фермер (колхозник, крестьянин) */
  elif ( GRUPN == 4 )
    Kategor = 0;        /* Прочие       */
  end;

   return Kategor;
end;

macro GetCOUNT( Codc )
   var stat = "";

   keynum( country, 3 );
   rewind( country    );
   country.CodeNum = Codc;
   if( not GetEQ( country ) );
      /*Protocol.Message( "Не найден код страны ", Codc, ". Устанавливаем РФ!" );*/
      return "RUR";
   else
      return country.CodLat2;
   end;
end;

/* Ищем позицию первой встретившейся цифры */
macro GetFirstDigitPos( Str )
   var stat   = True;
   var pos    = 0;
   var digits = "0123456789";
   var Len:integer;

   Len = StrLen( Str );
   while( pos < Len )
      pos  = pos + 1;
      /* Берем один символ из строки и смотрим является ли он цифрой */
      if( Index( digits, SubStr( Str, pos, 1 ) ) )
         /* Если встретили цифру, возвращаем позицию этого символа */
         return pos;
      end;
   end;
   return -1;
end;

/* Выделение из общей строки отдельно серии, отдельно номера */
macro SplitPercID( PercID:string, ID_Ser:string, ID_Num:string )
   var pos = 0;

   ID_Ser = ID_Num = "";
   PercID = Trim( PercID );

   if( PercID != "" )
      pos = GetFirstDigitPos( PercID );
      if( pos != -1 )
         ID_Ser = Substr( PercID, 1, pos-1 );
         ID_Num = Substr( PercID, pos );
      else
         /* Все заноси в номер паспорта */
         ID_Num = PercID;
      end;
   end;
   Setparm( 1,ID_Ser );
   Setparm( 2,ID_Num );
end;

/* Формирование пользовательских полей */
macro SetDopField( Clnt, Name, Text, ValType )
   var stat = True;

   extrn_clus( CLUS_CODE_CLIENT ) = Clnt;
   extrn_clus( CLUS_ACCOUNT     ) = "";
   extrn_clus( CLUS_NAME_FIELD  ) = Name;
   extrn_clus( CLUS_TEXT        ) = Text;
   extrn_clus( CLUS_VALUE_TYPE  ) = ValType;

   ext_clus.Str = MakeTxtStr( extrn_clus );
   if( not Insert( ext_clus ) )
      Protocol.Error( "Не вставлена запись о доп. поле по вкладчику ", Clnt );
   end;
end;

/***********************************************************
   Выгрузка информации по вкладчика
***********************************************************/

macro ConvClient
(
  FileID,
  NumFile:integer  /* - номер файла: depclnt - 0,
                                     trast   - 1;
                   */
)
/*
  Цикл по записям файла
*/
   var stat  = True;
   var Resid = 0;
   var ind   = 0;
   var pos   = 0;
   var FIO:string;
   var Ser:string;
   var Sex:string;
   var ExtraID:string;
   var PercID:string;
   var KolView = 0;
   var KolWork = 0;

   NRec = Nrecords( FileID );

   if  ( NumFile == 0 )
      InitProgress( Nrec, "", "Конвертация вкладчиков" );
   elif( NumFile == 1 )
      InitProgress( Nrec, "", "Конвертация доверенностей" );
   elif( NumFile == 2 )
      InitProgress( Nrec, "", "Конвертация завещаний" );
   elif( NumFile == 3 )
      InitProgress( Nrec, "", "Конвертация вносителей" );
   end;

   while( Next( FileID ) )
      stat = TRUE;

      if( NumFile == 0 )
         extrn_cln( CLN_CODE_CLIENT ) = FileID.CodClient;
         extrn_cln( CLN_ACCOUNT     ) = "";
      else
         extrn_cln( CLN_CODE_CLIENT ) = "";
         extrn_cln( CLN_ACCOUNT     ) = ""; /* заполняется при занесении доверенностей и т.д.*/
      end;

      extrn_cln( CLN_SNAME   ) = FileID.Sname;
      extrn_cln( CLN_NAME    ) = FileID.Name;
      extrn_cln( CLN_PNAME   ) = FileID.Pname;
      extrn_cln( CLN_BDATE   ) = FileID.BornDate;
      extrn_cln( CLN_ADDRESS ) = FileID.Adress;

      extrn_cln( CLN_GROUP_WILL   ) = "";                       /* ГЕН Завещание       */
      extrn_cln( CLN_GROUP_AUTHOR ) = "";                       /* ГЕН Доверенность    */

      extrn_cln( CLN_PERS_ID_TYPE  ) = 0; /* Паспорт */

      /*
      SplitPercID( PercID, extrn_cln( CLN_PERS_ID_SER   ),
                           extrn_cln( CLN_PERS_ID_NUM   )  );
      */
      extrn_cln( CLN_PERS_ID_SER   ) = "";
      extrn_cln( CLN_PERS_ID_NUM   ) = "";
      extrn_cln( CLN_PERS_ID_EXTRA ) = FileID.DocIdMan;

      Resid = 0;
      if  ( NumFile == 0 )
         if( FileID.YesResident != "" )
            Resid = 1;
         end;
      end;

      if( Resid == 0 )
         extrn_cln( CLN_CITIZENSHIP    ) = "";     /* Резидент */
         extrn_cln( CLN_TAKE_INCOM_TAX ) = "";
      else
         extrn_cln( CLN_CITIZENSHIP    ) = 1;    /* Не резидент */
         /*extrn_cln( CLN_TAKE_INCOM_TAX ) = StrFor(88);*/
      end;

      extrn_cln( CLN_ACTION         ) = 0;
      extrn_cln( CLN_SOCIAL_NUMBER  ) = 0;
      extrn_cln( CLN_REGISTR_DATE   ) = NullDate;

      if  ( NumFile == 1 )
         extrn_cln( CLN_VID_DOC ) = 0;
         extrn_cln( CLN_TYPE    ) = 1;
      elif( NumFile == 2 )
         extrn_cln( CLN_VID_DOC ) = 1;
         extrn_cln( CLN_TYPE    ) = 0;
      elif( NumFile == 3 )
         extrn_cln( CLN_VID_DOC ) = 0;
         extrn_cln( CLN_TYPE    ) = 4;
      end;

      extrn_cln( CLN_KATEGOR ) = GetGRUPN( 4 ); /* Категория населения */
      extrn_cln( CLN_COUNTRY ) = GetCOUNT( 0 ); /* Страна */

      if  ( NumFile == 0 )
/*
         /* Запись в доп поля вкладчиков */
         SetDopField( extrn_cln( CLN_CODE_CLIENT ), "РНН", FileID.Pas_RNN, 7 /*string*/ );
         if  ( FileID.Pas_Soc == StrFor( 1 ) ) Sex = "Прочие";
         else                                  Sex = "Инвалиды";
         end;
         SetDopField( extrn_cln( CLN_CODE_CLIENT ), "Соц. группа", Sex, 7 );

         if  ( FileID.Pas_Sex == 1 ) Sex = "Жен.";
         elif( FileID.Pas_Sex == 2 ) Sex = "Муж.";
         else                        Sex = "Не определен";
         end;
         SetDopField( extrn_cln( CLN_CODE_CLIENT ), "Пол", Sex, 7 );
*/
      elif( NumFile == 1 )
         /* доверенность */
         extrn_trust( TRUST_CODE_CLIENT  ) = extrn_cln( CLN_CODE_CLIENT );
         extrn_trust( TRUST_ACCOUNT      ) = FileID.Account;
         extrn_cln  ( CLN_ACCOUNT        ) = extrn_trust( TRUST_ACCOUNT );
         extrn_trust( TRUST_OPEN_DATE    ) = NullDate;
         extrn_trust( TRUST_CLOSE_DATE   ) = NullDate;

         keynum( vkl_acc, 0 );
         rewind( vkl_acc    );
         vkl_acc.Account       = FileID.Account;
         vkl_acc.Code_Currency = FileID.Code_Currency;

         stat = GetEQ( vkl_acc );

         if( not stat )
            Protocol.BtrError( "Не найден счет доверенности", FileID.Account, ", валюта ", FileID.Code_Currency );
         else
            extrn_trust( TRUST_OPEN_DATE ) = vkl_acc.Open_Date;
         end;
         if( stat )
            extrn_trust( TRUST_VID_DOC      ) = 0;
            extrn_trust( TRUST_TYPE         ) = 1;
            extrn_trust( TRUST_PART         ) = 0;
            extrn_trust( TRUST_PART0        ) = 0;
            extrn_trust( TRUST_COMPLEX_OPER ) = "";
            extrn_trust( TRUST_PART_M       ) = "";
            extrn_trust( TRUST_PART_N       ) = "";

            ext_trust.Str = MakeTxtStr( extrn_trust );
            if( not Insert( ext_trust ) )
               Protocol.Error( "Не вставлена запись о доверенностях вкладчика ", FIO );
            end;
         end;
/*
      elif( NumFile == 2 )
         /* завещания */
         extrn_trust( TRUST_CODE_CLIENT  ) = "";
         extrn_trust( TRUST_ACCOUNT      ) = FileID.Account;
         extrn_cln  ( CLN_ACCOUNT        ) = extrn_trust( TRUST_ACCOUNT );

         extrn_trust( TRUST_OPEN_DATE    ) = FileID.Zau_Opd;
         extrn_trust( TRUST_CLOSE_DATE   ) = NullDate;
         extrn_trust( TRUST_VID_DOC      ) = 1;
         extrn_trust( TRUST_TYPE         ) = 0;
         extrn_trust( TRUST_PART         ) = 0;
         extrn_trust( TRUST_PART0        ) = 0;
         extrn_trust( TRUST_COMPLEX_OPER ) = "";
         FileID.Zau_Dol = Trim( FileID.Zau_Dol );
         if( FileID.Zau_Dol != "@@@@@")
            pos = Index( FileID.Zau_Dol, "/");
            extrn_trust( TRUST_PART_M ) = SubStr( FileID.Zau_Dol, 1, pos-1 );
            extrn_trust( TRUST_PART_N ) = SubStr( FileID.Zau_Dol, pos+1    );
         end;
         ext_trust.Str = MakeTxtStr( extrn_trust );
         if( not Insert( ext_trust ) )
            Protocol.Error( "Не вставлена запись о завещаниях вкладчика ", FIO );
         end;
      elif( NumFile == 3 )
         /* вносители */
         extrn_trust( TRUST_CODE_CLIENT  ) = "";
         extrn_trust( TRUST_ACCOUNT      ) = FileID.Account;
         extrn_cln  ( CLN_ACCOUNT        ) = extrn_trust( TRUST_ACCOUNT );
         extrn_trust( TRUST_OPEN_DATE    ) = FileID.Vns_Opd;
         extrn_trust( TRUST_CLOSE_DATE   ) = NullDate;
         extrn_trust( TRUST_VID_DOC      ) = 0;
         extrn_trust( TRUST_TYPE         ) = 4;
         extrn_trust( TRUST_PART         ) = 0;
         extrn_trust( TRUST_PART0        ) = 0;
         extrn_trust( TRUST_COMPLEX_OPER ) = "";
         extrn_trust( TRUST_PART_M       ) = "";
         extrn_trust( TRUST_PART_N       ) = "";
         ext_trust.Str = MakeTxtStr( extrn_trust );
         if( not Insert( ext_trust ) )
            Protocol.Error( "Не вставлена запись о вносителях вкладчика ", FIO );
         end;
*/
      end;

      if( stat )
         ext_cln.Str = MakeTxtStr( extrn_cln );
         if( not Insert( ext_cln ) )
            Protocol.Error( "Не вставлена запись о вкладчике ", FIO );
            stat = False;
         end;
      end;
      if( stat )
         KolWork = KolWork + 1;
      end;
      UseProgress( KolView = KolView + 1 );
   end; /* elihw */
   RemProgress( KolView );
   Protocol.Message( "Окончена обработка. Просмотрено ", KolView,
                     "записей. Сконвертировано ", KolWork );
end;


/***********************************************************
  Раздел выгрузки подписей по вкладчикам.  
  macro-процедура ConvClientSign() отслеживает состояние 
  флага IsConvertSign.
***********************************************************/

/* Предварительная запись в коненчный файл подписей */
Macro PreInsertRecord( Code, Lengs )
   /* 
      Code   - код клиента,
      Lengs  - размер переменной части файла
    */

   Var StatReturn  = False;

   ClearRecord( rt_sign );     
   RT_SIGN.PrimRef    = "c:" + String( Code );   /* Код клиента */
   RT_SIGN.Lengs      = Lengs;  /* Длина подписи (переменной части) */
   RT_SIGN.FNCash     = Branch; /* Номер подразделения */
   RT_SIGN.NumSession = -1;     /* Признак выгрузки сессии */   
   RT_SIGN.Action     = 0;      /* Запись обработана успешно */

   If(  Insert( RT_SIGN ) )
      KeyNum(      RT_SIGN, 0 );
      Rewind(      RT_SIGN    );
      ClearRecord( RT_SIGN    );     

      RT_SIGN.Cod = Code;
      If( GetEQ ( RT_SIGN ) )  /* Пытаемся найти вставленную запись */
         StatReturn = True;
      end;
   end;

   Return StatReturn;
End;


/* Головная процедура обработки подписей */
Macro ConvClientSign( FileID )
   /* 
     FileID - указатель на исходныей файл, где расположены подписи
   */

   var byte_pos = 0,
       Lengs    = 0;

   var KolView = 0, 
       KolWork = 0; 

   var FileOut    = "",  /* Файл вывода графической подписи */ 
       FileExt    = ".pcx", /* Расширение графического файла   */
       CommandStr = ""; 

   If( CreatSignFile )
      GetString( FileExt, " Укажите формат графического файла по образцу ", 4);
   end;  

   /* Цикл по исходному файлу подписей */
   InitProgress( Nrecords( FileID ), NULL, " Обработка подписей вкладчиков ..." );
   While( Next( FileID ) )

      If( CreatSignFile )
         FileOut    = DirConvert + String( FileID.Cod ) + FileExt;
         CommandStr = " /c copy /b " + FileOut + " + null.txt "+ FileOut + " >nul"; 
         SetOutput( FileOut, FALSE );        
      end;

      /* Инициализация переменных */
      byte_pos = 0;
      Lengs    = GetVarSize( FileID );/* Определение длины переменной части */

      If( Lengs != 0 )
         If( PreInsertRecord( FileID.Cod, Lengs ) )
            While( byte_pos < Lengs )
               Message( " Обработка байта подписи : ", byte_pos );
               SetRecordAddr( RTSIGN_REC_OUT,  FileID, byte_pos, 0 );
               SetRecordAddr( RTSIGN_REC_IN , rt_sign, byte_pos, 0 );   
               RTSIGN_REC_IN.byte = RTSIGN_REC_OUT.byte;                             

               /*---------------Параллельная выгрузка в файл для контроля ---------------*/
               If( CreatSignFile )
                  if( RTSIGN_REC_OUT.byte != "" )  /* Обрабатываем только ненулевые символы */ 
                     Print( RTSIGN_REC_OUT.Byte ); /* Заносим в файл символа */
                  else /* Если символ нулевой, то обрабатываем немного по другому */
                     SetOutput( NULL ); /* Переопределяем поток вывода */         
                     /* Запускаем системную функцию копирования  с использованием 
                        нулевого файла NULL.TXT размеров 1 байт , с символом 0    */
                     Run( COMSPEC, CommandStr );
                     /* Восcтанавливаем потом обратно в изначальный файл */           
                     SetOutput( FileOut, TRUE );  
                  end;               
               end;
               /*------------------------------------------------------------------------*/
               byte_pos = byte_pos + 1;              
            end;

            If( Update( RT_SIGN, Lengs ) )
               KolWork = KolWork + 1;     
            end;
            If( CreatSignFile )
               SetOutput( NULL );                
            end;                          
         else
            Protocol.Error( " Запись с кодом клиента ", FileID.Cod,
                            " ошибка формирования записи в конечном файле: ",rt_sign );
         end;     
      else
         Protocol.Message( " Запись с кодом клиента ", FileID.Cod,
                           " имеет нулевой размер переменной части !!! " );
      end;
      UseProgress( KolView = KolView + 1 );  
   end;

   RemProgress( KolView );
   Protocol.Message( " Окончена обработка подписей. Просмотрено ", KolView,
                     " записей. Сконвертировано ", KolWork );
   Protocol.Message(" ");
End;


/* Проверка на особенные виды вклада */
macro IsIntresting( Kind )
   return ( Kind == "Ср.1мес.выпл" );
end;

/* Получение даты начала и конца периода расчета */
macro SetCalcDates()
   var stat = True;

   WorkWithDate( DateConvert, PC_ALG.GrafCalc, PC_ALG.DayCalc, DateNextCalc );
   /*println( depositr.Account, " " , DateConvert, " " , DateNextCalc );*/

   if( DateNextCalc != NullDate )
      /* Определили дату причисления на 1 период назад */
      WorkWithDateBack( DateNextCalc,
                        PC_ALG.GrafCalc,
                        PC_ALG.DayCalc,
                        DatePrevCalc );
      if( DatePrevCalc == NullDate )
         Protocol.Error("Для счета", extrn_dep( DEP_ACCOUNT ),
                                  "не определена дата начала периода расчета" );
         stat = False;
      end;
      if( IsIntresting( Trim( extrn_dep( DEP_TYPE_ACCOUNT ) ) ) ) /* Пока для срочного с ежемесячной выплатой */
         /* Определили дату причисления на 2 периода назад */
         WorkWithDateBack( DatePrevCalc,
                           PC_ALG.GrafCalc,
                           PC_ALG.DayCalc,
                           DatePrevCalc );
         if( DatePrevCalc == NullDate )
            Protocol.Error( "Для \"интересного\" вида вклада", sb_dtyp.Kind,
                            " и счета ", extrn_dep( DEP_ACCOUNT ),
                            "не определена дата начала периода расчета" );
            stat = False;
         end;
      end;
   else
      Protocol.Error( "Для счета", extrn_dep( DEP_ACCOUNT ),
                      "не определена дата окончания периода расчета" );
      stat = False;

   end;
   /*println( DatePrevCalc, " ", DateNextCalc );*/

   return stat;
end;

/* Получение "Критической" даты по счету */
macro GetCriticalDate( Object )
    var stat          = True;
    var Found         = True;
    var NextCalc      = NullDate;
    var FormContr     = sb_dtyp.FormContr;

    var Start_DateDep = extrn_dep( DEP_OPEN_DATE );
    var Prol_DateDep  = NullDate;
    var End_DateDep   = NullDate;
    var CriticalDate  = NullDate;

    stat = GetApplTpForObject( FlagCur,
                               extrn_dep( DEP_TYPE_ACCOUNT ),
                               Object );
    if( stat )
       /* ищем запись в sb_dtype для связки Object_Type -- ApType */
       stat = GetPc_ALgRec( FlagCur, pc_apltp.ApType, DateConvert );
       if( not stat )
          Protocol.Error( "Не найден алгоритм расчета на", DateConvert,
                          "по вкладу", pc_apltp.ApType );
       end;
    end;

    if( stat )
       /*println( pc_alg.GrafCalc, " ", pc_alg.StratCalc, " ", pc_alg.BegDate, " ", depositr.Account );*/
       if  ( FormContr ==  1 ) /* для срочных                  */
          GetDateOFF( Start_DateDep, sb_dtyp.KindTerm, sb_dtyp.Term, End_DateDep );
          if( End_DateDep < DateConvert )
             End_DateDep = NullDate;
          end;
          if( End_DateDep != NullDate )
             if( PC_ALG.GrafCalc != 0 ) /* задан график расчета процентов */
                 stat = SetCalcDates();
             else
                DateNextCalc = End_DateDep;
                DatePrevCalc = Start_DateDep;
             end;
          else
             stat = SetCalcDates();
          end;
       elif( FormContr == 20 ) /* для депозитов                */
          if( Object == 2001 )
             GetDateOFF( Start_DateDep, sb_dtyp.KindTerm, sb_dtyp.Term, End_DateDep );
             if( PC_ALG.GrafCalc != 0 ) /* задан график расчета процентов */
                 stat = SetCalcDates();
             else
                DateNextCalc = End_DateDep;
                DatePrevCalc = Start_DateDep;
             end;
          else
             stat = SetCalcDates();
          end;
       elif( FormContr == 30 ) /* для пролонгируемых депозитов */
          GetDateOFF( Start_DateDep, sb_dtyp.KindTerm, sb_dtyp.Term, End_DateDep );
          while( End_DateDep < DateConvert )
             Prol_DateDep = End_DateDep + 1;
             GetDateOFF( End_DateDep, sb_dtyp.KindTerm_Prol, sb_dtyp.Term_Prol, End_DateDep );
          end;
          DateNextCalc = End_DateDep;
          if( Prol_DateDep != NullDate )
             DatePrevCalc = Prol_DateDep  - 1;
          else
             DatePrevCalc = Start_DateDep;
          end;
       else                    /* для недоговоров              */
          stat = SetCalcDates();
       end;
    end;
    if( stat )
       /*CriticalDate = DatePrevCalc + 1;*/
       CriticalDate = DatePrevCalc;
       if( CriticalDate <= extrn_dep( DEP_OPEN_DATE ) )
          CriticalDate = NullDate;
       end;
      
       extrn_dep( DEP_PROL_DATE       ) = Prol_DateDep;
       extrn_dep( DEP_END_DATE        ) = End_DateDep;
       extrn_dep( DEP_LIMIT_DATE      ) = CriticalDate;

    end;
    

    /*println( CriticalDate );*/
    return stat;
end;

/* Получени дат договоров */
macro GetDepDates( Alternate )
   var stat = True;

   /* получим даты договоров */


   if( Alternate )
      stat = GetCriticalDate( 2002 );
   else
      stat = GetCriticalDate( 2001 );
   end;

   return stat;
end;

/* Добавление дополнительных счетов*/
macro SetAddAccount( Account:string, Code_Currency:integer ):bool
   var stat     = True;
   var Resid    = 0;
   var FileName = "";

   file pcacc ( "pcacc.dbt", "..\\VKLADY.DB\\bank.def"    ) key 3;
   file depos ( "depositr.dbt", "..\\VKLADY.DB\\bank.def" );

   fnmerge( FileName, DirConvert, "depositr", "dbt" );

   if( not( Open( depos, FileName ) ) )
      Protocol.Error("Невозможно открыть файл", FileName );
      MsgBox( "Невозможно открыть файл " + FileName );
      stat = False;
   end;
   if( stat )
      fnmerge( FileName, DirConvert, "pcacc", "dbt" );
      if( not( Open( pcacc, FileName ) ) )
         Protocol.Error("Невозможно открыть файл", FileName );
         MsgBox( "Невозможно открыть файл " + FileName );
         stat = False;
      end;
   end;
   if( stat )
      pcacc.ObjectType = 1004;
      pcacc.Account    = Account;
      pcacc.Currency   = Code_Currency;
      pcacc.CloseDate  = NullDate;

      stat = GetEQ( pcacc );
      if( not stat )
         Protocol.Error( "Не найден счет процентов по вкладу", extrn_dep( DEP_ACCOUNT )  );
      else
         if( Trim( pcacc.AuxReceiverAcc ) != Trim( pcacc.Account ) )
            /* Определили, что счета разные */
            depos.Account       = pcacc.AuxReceiverAcc;
            depos.Code_Currency = pcacc.Currency;
            stat = GetEQ( depos );
            if( not stat )
               Protocol.Error( "Не найден счет получатель процентов", pcacc.AuxReceiverAcc );
            else
               stat = GetRsKindForOtherABS( depos.Type_Account,
                                            extrn_addacc( ADDACC_TYPE_ACCOUNT ),
                                            "" );

               if( stat )
                  /* Определим вид вклада, для взятия условий для расчета процентов.
                     Например, для "Срочного с доп. взносами" условия берутся по "Срочному"
                  */
                  stat = GetTypeRecord( extrn_addacc( ADDACC_TYPE_ACCOUNT ), FlagCur );
                  if( not stat )
                     Protocol.Error( "По счету получателю процентов", depos.Account, "для вклада",
                                     extrn_addacc( ADDACC_TYPE_ACCOUNT ), "не найден запись о виде вклада" );

                  end;
               else
                  Protocol.Error( "Не определен RS-вид вклада для счета получ. проц.", depos.Account );
               end;
               if( stat )
                  extrn_addacc( ADDACC_ACCOUNT       ) = extrn_dep( DEP_ACCOUNT );
                  extrn_addacc( ADDACC_CODE_CURRENCY ) = depos.Code_Currency;
                  extrn_addacc( ADDACC_NUMBER        ) = Int( depos.Account );
                  extrn_addacc( ADDACC_TYPE_ADDACC   ) = "П"; /* получатель процентов */


                  rewind( vkl_cln );
                  vkl_cln.CodClient = depos.CodClient;
                  stat = GetEQ( vkl_cln );
                  if( not stat )
                     Protocol.Error("Не найден вкладчик с кодом", depos.CodClient );
                  end;
               end;
               if( stat )
                  if( vkl_cln.YesResident != "" )
                     Resid = 1;
                  end;

                  if( Resid == 0 )
                     extrn_addacc( ADDACC_GROUP_NUMB ) = SB_DTYP.NewGroupNumb;
                  else
                     extrn_addacc( ADDACC_GROUP_NUMB ) = string( int( SB_DTYP.NewGroupNumb ) + 100 );
                  end;
               end;
            end;
            if( stat )
               ext_addacc.Str = MakeTxtStr( extrn_addacc );

               if( not Insert( ext_addacc ) )
                  Protocol.BtrError( "По счету", extrn_addacc( ADDACC_ACCOUNT ), "не вставлена запись в файл дополнительных счетов" );
               end;
            end;
         end;
      end;
   end;

   return stat;
end;

macro SetCardRef( FileID )
   var stat = True;

   extrn_card ( CARD_ACCOUNT          ) = extrn_dep( DEP_ACCOUNT );
   extrn_card ( CARD_PSREF            ) = 1;
   extrn_card ( CARD_FLAG_ACC         ) = 1;
   extrn_card ( CARD_ACCTYPECODE      ) = "";
   extrn_card ( CARD_ACCSTATECODE     ) = "OK___";
   extrn_card ( CARD_ACCRESTMIN       ) = 0L;
   extrn_card ( CARD_ACCRESTGUARANTEE ) = 0L;
   extrn_card ( CARD_REFERENC_ADD     ) = "";
   extrn_card ( CARD_NUMBER           ) =  FileID.UserField1;
   extrn_card ( CARD_TYPECODE         ) = "";
   extrn_card ( CARD_STATECODE        ) = "OK___"; 
   extrn_card ( CARD_CLIENTPASSWORD   ) = "";
   extrn_card ( CARD_OPENDATE         ) = extrn_dep( DEP_OPEN_DATE );
   extrn_card ( CARD_MATURITYDATE     ) = 365;
   extrn_card ( CARD_EMBOSSINGNAME1   ) = "";
   extrn_card ( CARD_MAINCARD         ) = StrFor( 88 );
                                        
   extrn_card ( CARD_SB_MANWOM          ) = "U";
   extrn_card ( CARD_SB_ADDR1           ) = "";
   extrn_card ( CARD_SB_TYPEADDR1       ) = "";
   extrn_card ( CARD_SB_INDEXADDR1      ) = "";
   extrn_card ( CARD_SB_WORKPHONE       ) = "";
   extrn_card ( CARD_SB_TYPEPASS        ) = "";
   extrn_card ( CARD_SB_ROMLETTSER      ) = "";
   extrn_card ( CARD_SB_NUMPASS         ) = "";
   extrn_card ( CARD_SB_CODECLASSCLIENT ) = "";
   extrn_card ( CARD_SB_TITULEMBOSS     ) = "";
   extrn_card ( CARD_SB_TITULCLNT       ) = "";
   extrn_card ( CARD_SB_TYPEACCOUNT     ) = "";

   if( stat )
      ext_card.Str = MakeTxtStr( extrn_card );
      if( not Insert( ext_card ) )
         Protocol.BtrError( "По счету", extrn_card( CARD_ACCOUNT ), "не вставлена запись в файл карточных  счетов" );
         stat = False;
      end;
   end;

   if( stat )
     if( Trim( FileID.UserField2  ) != "" ) 
        /* Есть вторая карточка */

        extrn_card ( CARD_ACCOUNT  ) = extrn_dep( DEP_ACCOUNT );
        extrn_card ( CARD_FLAG_ACC ) = 2;
        extrn_card ( CARD_NUMBER   ) =  FileID.UserField2;

        ext_card.Str = MakeTxtStr( extrn_card );
        if( not Insert( ext_card ) )
            Protocol.BtrError( "По счету", extrn_card( CARD_ACCOUNT ), "не вставлена запись в файл карточных  счетов" );
            stat = False;
        end;
     end;
   end;

   return stat;
end;


/*
    выгрузка информации по счетам вкладчиков
*/
macro ConvAccount( FileID )
   var stat    = True;
   var KolView = 0;
   var KolWork = 0;
   var Resid   = 0;
   var OldFlagCur = 0;

   record dep ( "depositr.dbt" );

   NRec = Nrecords( FileID );

   InitProgress( Nrec, "", "Конвертация счетов вкладчиков" );

   while( next( FileID ) )
      if( ( NeedConvertType( FileID.Account ) ) and
          ( IsNeedConv     ( FileID.Account ) ) and
          ( FileID.Open_Close == ""           ) and
          ( NeedConvVAL( FlagCur, FileID.Code_Currency ) ) )

         stat = GetRsKindForOtherABS( FileID.Type_Account,
                                      extrn_dep( DEP_TYPE_ACCOUNT ) );

         if( stat )

            /* Определим вид вклада, для взятия условий для расчета процентов.
               Например, для "Срочного с доп. взносами" условия берутся по "Срочному"
            */
            stat = GetTypeRecord( extrn_dep( DEP_TYPE_ACCOUNT ), FlagCur );
            if( not stat )
               Protocol.Error( "По счету", FileID.Account, "для вклада",
                              extrn_dep( DEP_TYPE_ACCOUNT ), " не найден вид вклада для основных условий" );

            end;
         else
            Protocol.Error( "Не определен RS-вид вклада для счета ", FileID.Account );
         end;
         if( stat )
            rewind( vkl_cln );
            vkl_cln.CodClient = vkl_acc.CodClient;
            stat = GetEQ( vkl_cln );
            if( not stat )
               Protocol.Error("Не найден вкладчик с кодом", vkl_acc.CodClient );
            end;
         end;
         if( stat )
            if( vkl_cln.YesResident != "" )
               Resid = 1;
            end;

            if( Resid == 0 )
               extrn_dep( DEP_GROUP_NUMB ) = SB_DTYP.NewGroupNumb;
            else
               extrn_dep( DEP_GROUP_NUMB ) = string( int( SB_DTYP.NewGroupNumb ) + 100 );
            end;

            extrn_dep( DEP_NUMBER          ) = Int( FileID.Account );
            extrn_dep( DEP_PREV_ACCOUNT    ) = FileID.Account;
            extrn_dep( DEP_CODE_CURRENCY   ) = SetCurrency( FileID.Code_Currency );


            /* Обязательно должен быть задан правильный диапазон */

            extrn_dep( DEP_ACCOUNT         ) = FileID.Account;

            /*
            extrn_dep( DEP_ACCOUNT         ) = FormAccountNumber(
                                                      extrn_dep( DEP_CODE_CURRENCY   ),
                                                      extrn_dep( DEP_TYPE_ACCOUNT    ),
                                                      extrn_dep( DEP_NUMBER          ),
                                                      Resid );
            */
/*
            extrn_dep( DEP_ACCOUNT         ) = FormAccountNumber( DEPOSITR.Code_Currency,
                                                                  DEPOSITR.Type_Account,
                                                                  DEPOSITR.Number,
                                                                  Resid );
*/


            if( extrn_dep( DEP_ACCOUNT         ) == "" )
               Protocol.Error( "Для счета ", FileID.Account,
                              " не определен счет RS-Retail" );
               Protocol.Message("      Счет не сконвертирован.");
               Protocol.Message( "Код валюты", extrn_dep( DEP_CODE_CURRENCY   ),
                                 "Вид Вклада", extrn_dep( DEP_TYPE_ACCOUNT    ),
                                 "Номер,    ", extrn_dep( DEP_NUMBER          ),
                                 "Группа нумерации", extrn_dep( DEP_GROUP_NUMB ),
                                 "Резидент  ", Resid );

               stat = False;
            end;
         end;
         if( stat )
            extrn_dep( DEP_CODE_CLIENT     ) = FileID.CodClient;
            extrn_dep( DEP_OPER            ) = FileID.Oper;
            extrn_dep( DEP_OPEN_DATE       ) = FileID.Open_Date;
            extrn_dep( DEP_BEGIN_DATE      ) = extrn_dep( DEP_OPEN_DATE );

            extrn_dep( DEP_ACTION          ) = 0;
            extrn_dep( DEP_PROL_DATE       ) = NullDate;
            extrn_dep( DEP_END_DATE        ) = NullDate;
            extrn_dep( DEP_LIMIT_DATE      ) = NullDate;

            extrn_dep( DEP_USE_ALTERNATE   ) = 0;
            extrn_dep( DEP_OPEN_CLOSED     ) = FileID.Open_Close;
            extrn_dep( DEP_CLOSE_DATE      ) = FileID.Close_Date;

            if( extrn_dep( DEP_OPEN_CLOSED ) == "З" )
               extrn_dep( DEP_LIMIT_DATE ) = extrn_dep( DEP_CLOSE_DATE );
            end;

            extrn_dep( DEP_USER_TYPE_ACC   ) = sb_dtyp.UserTypeAccount;
            extrn_dep( DEP_DATE_BEGIN_PERC ) = extrn_dep( DEP_OPEN_DATE );
            extrn_dep( DEP_GIVE_BOOK       ) = "Х";
            extrn_dep( DEP_FLAG_TRAST      ) = "";
            extrn_dep( DEP_FLAG_WILL       ) = "";

            vkl_dov.Account       = extrn_dep( DEP_ACCOUNT         );
            vkl_dov.Code_Currency = extrn_dep( DEP_CODE_CURRENCY   );
            if( GetEQ( vkl_dov ) )
               extrn_dep( DEP_FLAG_TRAST ) = StrFor( 1 );
            end;

            stat = GetDepDates();

            if( stat )
               ext_dep.Str = MakeTxtStr( extrn_dep );

               if( not Insert( ext_dep ) )
                  Protocol.BtrError( "По счету", FileID.Account, "не вставлена запись в текстовый файл" );
               end;
               if( stat )
                  stat = SetAddAccount( FileID.Account, FileId.Code_Currency );
               end;
               if( stat )
                  if( Index( extrn_dep( DEP_USER_TYPE_ACC ), "К" ) )
                     stat = SetCardRef( FileID );
                  end;
               end;
   
               if( stat )
                  KolWork = KolWork + 1;
                  /* Запомним критическую дату по счету и другие полезности */
                  FileID.Previos_Date     = extrn_dep( DEP_LIMIT_DATE   );
                  FileID.TAccount         = extrn_dep( DEP_ACCOUNT      ); /* новый номер счета */
                  FileID.CAccount         = extrn_dep( DEP_TYPE_ACCOUNT );
                  FileID.CAccount_connect = extrn_dep( DEP_ACCOUNT      );;
                  If( not Update( FileID ) )
                     Protocol.BtrError("По счету", FileID.Account, "не обновлена запись в", FileID );
                  end;
               end;
            end;
         end;
      end;
      UseProgress( KolView = KolView + 1 );
   end; /* elihw */
   RemProgress( KolView );
   Protocol.Message( "Окончена обработка. Просмотрено ", KolView,
                     "записей. Сконвертировано ", KolWork );
end;

