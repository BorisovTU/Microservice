/*
  RS-Retail
  Конвертирование данных из Laros в RS-Retail
  1999 год

  Конвертирование данных по операциям в текстовые файлы, а также выгрузка
  информации по счетам за "критическую дату"
  (файлы sXXb.dbf, sXXd.dbt)

  Рыжиков Александр Александрович
  25.02.99
*/

import "oper_num_fc.mac";
import "opercode.mac";

/*
  Переменные
*/

var DatePrevCalc = NullDate;
var DateNextCalc = NullDate;
var CriticalDate = NullDate;

var OPROC_111    = 0;

/*
   Поиск записи в pc__calc.dbt
*/
macro GetPcCalc
(
  CalcDate,
  Object_Type,
  Type          /* Тип поиска: 0 - ищем для заданной даты документа,
                               1 - ищем первую запись,
                               2 - ищем послед запись,
                               3 - для заданной даты ищем предыдущий расчет */
)
   var stat = True;

   Keynum     ( pc__calc, 0 );
   ClearRecord( pc__calc    );
   rewind     ( pc__calc    );

   pc__calc.Referenc    = depositr.Referenc;
   pc__calc.ObjectType  = Object_Type;
   pc__calc.TypeRecord  = 1;
   pc__calc.EndDate     = CalcDate;

   if(   Type < 2 ) /* поиск записи о расчете для заданной даты */
      pc__calc.EndDate = CalcDate;
     if( Type == 1 )
         pc__calc.EndDate = date( 0, 0, 0 );
      end;
    stat = ( GetGE ( pc__calc ) and ( pc__calc.Referenc   == depositr.Referenc ) and
                                    ( pc__calc.ObjectType == Object_Type       ) and
                                    ( pc__calc.TypeRecord == 1                 )     );
   elif( Type == 2 ) /* последняя запись */
      pc__calc.EndDate = VeryBigDate;
      stat = ( GetLE ( pc__calc ) and ( pc__calc.Referenc   == depositr.Referenc ) and
                                      ( pc__calc.ObjectType == Object_Type       ) and
                                      ( pc__calc.TypeRecord == 1                 )     );
   elif( Type == 3 ) /* предыдущий расчет */
      pc__calc.EndDate = CalcDate;
      stat = ( GetLE ( pc__calc ) and ( pc__calc.Referenc   == depositr.Referenc ) and
                                      ( pc__calc.ObjectType == Object_Type       ) and
                                      ( pc__calc.TypeRecord == 1                 )     );
   end;
   return stat;
end;

macro GetApplTpForObject( IsCur, Type_Account, Type_Object )
   var stat  = True;
   var Found = False;

   keynum     ( pc_apltp, 0 );
   ClearRecord( pc_apltp    );
   rewind     ( pc_apltp    );

   pc_apltp.IsCur    = IsCur;
   pc_apltp.TypeRec  = 1003;
   pc_apltp.Type     = Type_Account;
   pc_apltp.ApplType = Type_Object;

   stat = GetEQ( pc_apltp );

   return stat;
end;

macro IsIntresting( Kind )
   return ( Kind == "Ср.1мес.выпл" );
end;

macro IsPension( Kind )
   return ( Kind == "Пенсионный" );
end;

/* Получение даты начала и конца периода расчета */
macro SetCalcDates()
   var stat = True;

   WorkWithDate( DateConvert, PC_ALG.GrafCalc, PC_ALG.DayCalc, DateNextCalc );
   /*println( depositr.Account, " " , DateConvert, " " , DateNextCalc );*/

   if( DateNextCalc != NullDate )
      /* Определили дату следующего причисления */
      WorkWithDateBack( DateNextCalc,
                        PC_ALG.GrafCalc,
                        PC_ALG.DayCalc,
                        DatePrevCalc );
      if( DatePrevCalc == NullDate )
         Protocol.Error("Для счета ", depositr.Account,
                                  "не определена дата начала периода расчета" );
         stat = False;
      end;
      if( IsIntresting( Trim( depositr.Type_Account ) ) ) /* Пока для срочного с ежемесячной выплатой */
         /* Определили дату следующего причисления */

         WorkWithDateBack( DatePrevCalc,
                           PC_ALG.GrafCalc,
                           PC_ALG.DayCalc,
                           DatePrevCalc );
         if( DatePrevCalc == NullDate )
            Protocol.Error( "Для \"интересного\" вида вклада", sb_dtyp.Kind,
                            " и счета ", depositr.Account,
                            "не определена дата начала периода расчета" );
            stat = False;
         end;
      end;
   else
      Protocol.Error( "Для счета", depositr.Account,
                      "не определена дата окончания периода расчета" );
      stat = False;

   end;
   /*println( DatePrevCalc, " ", DateNextCalc );*/

   return stat;
end;

/* Получение "Критической" даты по счету */
macro GetCriticalDate( Object )
    var stat     = True;
    var Found    = True;
    var NextCalc     = NullDate;
    var FormContr    = sb_dtyp.FormContr;


    if( Object != 2001 )
       stat = GetApplTpForObject( depositr.IsCur,
                                  depositr.Type_Account,
                                  Object );
    else
       stat = True;
    end;

    if( stat )
       /* ищем запись в sb_dtype для связки Object_Type -- ApType */
       stat = GetPc_ALgRec( depositr.IsCur, pc_apltp.ApType, DateConvert );
       if( not stat )
          Protocol.Error( "Не найден алгоритм расчета на", DateConvert,
                          "по вкладу", pc_apltp.ApType );
       end;
    end;

    if( stat )
       /*println( pc_alg.GrafCalc, " ", pc_alg.StratCalc, " ", pc_alg.BegDate, " ", depositr.Account );*/
       if  ( FormContr ==  1 ) /* для срочных                  */
          if( depositr.End_DateDep != NullDate )
             if( PC_ALG.GrafCalc != 0 ) /* задан график расчета процентов */
                 stat = SetCalcDates();
             else
                DateNextCalc = depositr.End_DateDep;
                DatePrevCalc = depositr.Start_DateDep;
             end;
          else
             stat = SetCalcDates();
          end;
       elif( FormContr == 20 ) /* для депозитов                */
          if( Object == 2001 )
             if( PC_ALG.GrafCalc != 0 ) /* задан график расчета процентов */
                 stat = SetCalcDates();
             else
                DateNextCalc = depositr.End_DateDep;
                DatePrevCalc = depositr.Start_DateDep;
             end;
          else
             stat = SetCalcDates();
          end;
       elif( FormContr == 30 ) /* для пролонгируемых депозитов */
          DateNextCalc = depositr.End_DateDep;
          if( depositr.Prol_DateDep != NullDate )
             DatePrevCalc = depositr.Prol_DateDep  - 1;
          else
             DatePrevCalc = depositr.Start_DateDep;
          end;
       else                    /* для недоговоров              */
          stat = SetCalcDates();
       end;
    end;
    if( stat )
       /*CriticalDate = DatePrevCalc + 1;*/
       CriticalDate = DatePrevCalc;
       if( CriticalDate < depositr.Open_Date )
          CriticalDate = depositr.Open_Date;
       end;
    end;

    if( CriticalDate == depositr.Open_Date )
       CriticalDate = NullDate;
    end;

    /*println( CriticalDate );*/
    return stat;
end;

macro OutDepositr()
   var stat = True;

   if( IsLock_Gate and ( depositr.Action == 1 ) )
      return stat;
   end;
   if( not IsLock_Gate )
      depositr.Sum_Rest = extrn_doc( DOC_REST );
   else
      depositr.Sum_Rest = 0;
   end;

   if( depositr.Open_Close == "З" )
      if( IsLock_Gate )
         /* Закрыть счет должен сам Retail */
         depositr.Open_Close = "";
         depositr.Close_Date = NullDate;
      else
         /* дату закрытия делаем равной дате последней операции */
         depositr.Close_Date = extrn_doc( DOC_DEP_DATE );
         depositr.Limit_Date = depositr.Close_Date;
         /*println( depositr.Limit_Date, " ", depositr.Close_Date );*/
      end;
   end;

   extrn_dep( DEP_TYPE_ACCOUNT    ) = depositr.Type_Account;
   extrn_dep( DEP_ACCOUNT         ) = depositr.Account;
   extrn_dep( DEP_CODE_CURRENCY   ) = depositr.Code_Currency;
   extrn_dep( DEP_NUMBER          ) = depositr.Number;
   extrn_dep( DEP_GROUP_NUMB      ) = depositr.GroupNumb;
   extrn_dep( DEP_CODE_CLIENT     ) = "";
   extrn_dep( DEP_OPER            ) = depositr.Oper;
   extrn_dep( DEP_OPEN_DATE       ) = depositr.Open_Date;
   extrn_dep( DEP_BEGIN_DATE      ) = depositr.Start_DateDep;
   extrn_dep( DEP_END_DATE        ) = depositr.End_DateDep;
   extrn_dep( DEP_ACTION          ) = depositr.Action;
   extrn_dep( DEP_PROL_DATE       ) = depositr.Prol_DateDep;
   extrn_dep( DEP_OPEN_CLOSED     ) = depositr.Open_Close;

   if( IsLock_Gate )
      extrn_dep( DEP_END_DATE        ) = NULLDATE;
      extrn_dep( DEP_PROL_DATE       ) = NULLDATE;
   end;

   if( ( depositr.Limit_Date == depositr.Open_Date ) and
       ( depositr.Open_Date  != depositr.Close_Date ) )
      extrn_dep( DEP_LIMIT_DATE ) = NullDate;
   else
      extrn_dep( DEP_LIMIT_DATE ) = depositr.Limit_Date;
   end;
   extrn_dep( DEP_CLOSE_DATE      ) = depositr.Close_Date;
   extrn_dep( DEP_USE_ALTERNATE   ) = depositr.UseAlternate;
   extrn_dep( DEP_DATE_BEGIN_PERC ) = depositr.DateBeginPerc;
   extrn_dep( DEP_PREV_ACCOUNT    ) = depositr.PrevAccount;
   extrn_dep( DEP_GIVE_BOOK       ) = depositr.GiveBook;
   extrn_dep( DEP_FLAG_TRAST      ) = depositr.FlagTrast;
   extrn_dep( DEP_FLAG_WILL       ) = depositr.FlagWill;
   extrn_dep( DEP_USER_TYPE_ACC   ) = Trim (depositr.UserTypeAccount);

   ext_dep.Str = MakeTxtStr( extrn_dep );

   if( not Insert( ext_dep ) )
      Protocol.Error( "По счету", depositr.Account, "не вставлена запись в текстовый файл" );
   end;

   return stat;
end;

macro OutLimitDate()
   var stat = True;

   if( depositr.Limit_Date != NullDate )
      ext_limit.Str = MakeTxtStr( extrn_limit );
      if( not Insert( ext_limit ) )
         Protocol.Error( "По счету", depositr.Account, "не вставлена запись за критическую",
                          extrn_limit( LIMIT_DATE ) );
      end;
   end;
   return stat;
end;

macro FillRepArrays()
   var stat = True;

   /* Найдем соответсвующую запись во временном файле отчета */
   keynum     ( report, 0 );
   rewind     ( report    );
   ClearRecord( report    );

   report.FNCash  = Branch;
   report.IsCur   = FlagCur;
   report.Kind    = depositr.Type_Account;
   report.CodCur  = depositr.Code_Currency;

   stat = ( GetGE( report) and ( report.FNCash  == Branch                  ) and
                               ( report.IsCur   == FlagCur                 ) and
                               ( report.Kind    == depositr.Type_Account   ) and
                               ( report.CodCur  == depositr.Code_Currency  )     );
   if( stat )
      /* нашли запись */
      report.Rest   = report.Rest + depositr.Sum_Rest;
      report.CodCur = depositr.Code_Currency;

      if( depositr.Open_Close != "З" )
         report.ColOpenedAcc = report.ColOpenedAcc + 1;
      else
         report.ColClosedAcc = report.ColClosedAcc + 1;
      end;

      report.ColAccounts = report.ColOpenedAcc + report.ColClosedAcc;

      if( not Update( report ) )
         Protocol.BtrError( "Не обновлена запись в файлк отчета по вкладу", report.Kind,
                            " код валюты ", report.CodCur );

      end;
   else
      /* Занесем новый элемент */
      ClearRecord( report );

      report.FNCash  = Branch;
      report.IsCur   = FlagCur;
      report.CodCur  = depositr.Code_Currency;
      report.Kind    = depositr.Type_Account;
      report.Rest    = depositr.Sum_Rest;

      if( depositr.Open_Close != "З" )
         report.ColOpenedAcc = 1;
      else
         report.ColClosedAcc = 1;
      end;
      report.ColAccounts = 1;

      if( not Insert( report ) )
         Protocol.BtrError( "Не вставлена запись в файл отчета по вкладу", report.Kind,
                            " код валюты ", report.CodCur );
      end;
   end;
end;


macro FillRep_Gate( KindOp )
   var stat = True;

   /* Найдем соответсвующую запись во временном файле отчета */
   keynum     ( report, 1 );
   rewind     ( report    );
   ClearRecord( report    );

   report.FNCash  = 0;
   report.CodCur  = 0;
/*   Protocol.Message (Flaros.Datav," ",extrn_doc( DOC_DATE )," ",extrn_doc( DOC_DEP_DATE ) );*/
   report.Date    = extrn_doc( DOC_DATE );/* Исправлено Головановым В.В. */
   report.Kind    = depositr.Type_Account;
   report.FlagRez = 0;

   stat = GetEQ( report);
   if( stat )
      /* нашли запись */
      if( KindOp == D_OUT )
         report.DebSum  = report.DebSum + extrn_doc( DOC_OUT_SUM  );
      else
         report.KredSum = report.KredSum + extrn_doc( DOC_IN_SUM  );
      end;
      if( not Update( report ) )
         Protocol.BtrError( "Не обновлена запись в файлк отчета по вкладу", report.Kind,
                         "за", report.Kind );
      end;
   else
      /* Занесем новый элемент */
      ClearRecord( report );

      report.FNCash  = 0;
      report.CodCur  = 0;
      report.Date    = extrn_doc( DOC_DATE ); /*Исправлено Головановым В.В.*/
      report.Kind    = depositr.Type_Account;
      report.FlagRez = 0;

      if( KindOp == D_OUT )
         report.DebSum  = extrn_doc( DOC_OUT_SUM  );
      else
         report.KredSum = extrn_doc( DOC_IN_SUM  );
      end;

      if( not Insert( report ) )
         Protocol.BtrError( "Не вставлена запись в файл отчета по вкладу", report.Kind,
                            "за", report.Kind );
      end;
   end;
end;

/* Проверка - нужно ли конвертировать операцию */
macro IsNeedConvert()
   var stat = True;

   if( IsLock_Gate )
      stat = ( ( CheckKindSbereg() )                                             or
               ( ( CountDate >= BegLockDate ) and ( CountDate <= EndLockDate ) )
             );
   end;
   if( stat )
      stat = ( ( FLAROS.DATAV != Date( 0, 0, 0 )   ) AND
               ( FLAROS.OPER  != "111"             ) AND
               ( ( FLAROS.OPER  < "191" ) or
                 ( FLAROS.OPER  > "198" ) or
                 ( FLAROS.OPER == "197" )          )     );

      if( stat )
         /* Для пролонгируемых 000- не нужна */
         stat = not ( ( FLAROS.OPER  == "000" ) and ( sb_dtyp.FormContr == 30 ) );

         if( stat )
             stat =  not ( ( FLAROS.OPER  == "000" ) AND
                           ( FLAROS.SUMMA ==  $0   ) AND
                           ( FLAROS.OPROC ==  $0   )    ); /* Откидываем служебную запись */
         end;

         if( stat )
            if( MustDecode )
               stat = stat or (not ( STOD( "OSTAT", GetPos( FLAROS ) ) == $0 ) );
            else
               stat = stat or (not FLAROS.OSTAT == $0 );
            end;
         end;
      end;
   end;

   return stat;
end;

/* Проверка закрытых счетов для конвертера */
macro CheckCloseAcc()
   var stat = True;

   if( not Islock_Gate )  stat = ( depositr.Open_Close != "З" ); end;

   return stat;
end;

/* Процедура объединения двух операций пролонгации в одну */
macro CheckProlOper( Prol_DateDep )
   var stat       = True;
   var Summa      = $0;
   var FoundProl  = False;
   var Found141   = False;
   var Found259   = False;
   var FoundClose = False;
   var LarosNum   = "";

   if( Prol_DateDep == NullDate )
      /* пролонгаций еще не было - зачисление % только перед выдачей */
      return False;
   end;
   GetPos( FLAROS );
   LarosNum = FLAROS.Nomls;
   stat = next( FLAROS ); /* Перешли на следующую запись */
   /*println ("FoundProl ", FoundProl, " Found141 ", Found141, " FoundClose ", FoundClose);*/
   while( stat                             and
          ( FLAROS.DATAV >= Prol_DateDep ) and
          ( FLAROS.Nomls == LarosNum     )
        )
      If( FLAROS.OPER == "206" )
         Summa = Summa + Money( Double( FLAROS.Summa ) * 100 );
      end;
      if( FLAROS.OPER == "111" )
         /* Нашли пролонгацию */
         OPROC_111 = FLAROS.OPROC;
         /*println( FLAROS.OPER, " ", FLAROS.OPROC, " ", OPROC_111 );*/
         FoundProl  = True;
      elif( ( FLAROS.OPER == "142" ) or ( FLAROS.OPER == "141" ) )
         /* Нашли выдачу процентов */
         Found141   = True;
      elif( FLAROS.OPER == "154" )
         FoundClose = True;
      elif( FLAROS.OPER == "259" )
         Found259   = True;
      end;
      if( not FoundProl and not Found141 and not FoundClose )
         stat = next( FLAROS );
      else
         stat = False;
      end;
   end;

   if( FoundProl )
      stat = True;
      extrn_doc( DOC_IN_SUM  ) = extrn_doc( DOC_IN_SUM  ) + Summa;
      extrn_doc( DOC_REST    ) = extrn_doc( DOC_REST    ) + Summa;
      if( Found259 )
         GetDirect( Flaros );
      end;
   elif( Found141 )
      GetDirect( Flaros );
      stat = False; /* Это зачисление не пролонгация */
   else
      GetDirect( Flaros );
      stat = False;
      /*Protocol.Error( "По счету", depositr.Account, "за дату пролонгации не найдена ни 111 операция, ни 141" );*/
   end;

   return stat;
end;

/* проверка на отношение счета к срочным-пенсионным */
macro IsSrochnPens()
   var stat = True;

   stat = ( ( Trim( depositr.Type_Account ) == "Ср.пенсион."  ) or
            ( Trim( depositr.Type_Account ) == "Ср.пенс.6мес" )    );
   return stat;
end;


/*
  Определение, к какой группе по размещению данных в полях
  процентов (файлы операций) базы Laros принадлежит вид вклада
  (по Laros) (строка за 01.01 с операцией "206", "000" или"ДЕН")
  --------------------------------------------------------------------
  Группа | SUMMA               | OSTAT             | PROC1   | OPROC
  --------------------------------------------------------------------
  Срочные
      1   % за прошлый год      остаток по счету       0        % к выдаче
  Депозиты без пролонгации
      2   % за прошлый год      остаток по счету       0        % к выдаче
                                (с процентами)
  До востребования
      3   % за прошлый год      Реальный остаток       0       0
  С пролонгацией
      4   Хранится вся история за декабрь прошлого года
  Детский
      5   0                     Остаток на 31.12.97     % с на- % без нарушения
                                (взносы)                рушением
  -----------------------------------------------------------------------
*/
macro WorkWithFileLarosOper
/*
  Цикл по записям файла
*/
   var KindInLaros;
   var MayCont;
   var GrOper;
   var YearOp, MonOp, DayOp;
   var OpenYear;
   var Found         = False;
   var FoundCompens  = False;
   var ForFisrtDate  = False;
   var NextAccount   = False;
   var WasWork       = False;
   var WasOpenOper   = False;
   var NeedOutStr    = True;
   var Account       = "";
   var ComplexDate   = NullDate;
   var DOC_KINDOP    = 0;
   var ApplType      = 0;
   var NumDayDoc     = 0;
   var Summa253      = $0;
   var Data253       = Nulldate;
   var NOper         = 0;
   var SaveDateDoc   = NullDate;
   var DopNumOper    = 0;

   Nrec = Nrec + NRecords( FLAROS );
   if( IsLock_Gate )
      InitProgress( Nrec, "", "Выгрузка данных об операциях" );
   else
      InitProgress( Nrec, "", "Конвертация операций" );
   end;

   while( Next( FLAROS ) )
      MayCont    = TRUE;
      NeedOutStr = True;
      DopNumOper = 0;
      /*
      if( IsNeedConvert() )
         println( Flaros.Nbals, " ", Flaros.Nomls, " ", Flaros.Datav, " ", Flaros.Oper );
      end;
      */
      if( String( Int( FLAROS.Nbals ), Int( FLAROS.NOMLS ) ) != Account )

         /* Дообработка предыдущего счета, если он обработан без ошибок */
         if( NextAccount )
            MayCont = OutDepositr();
            if( MayCont )
               if( ( not IsLock_Gate ) and ( depositr.Open_Close != "З" ) )
                  MayCont = OutLimitDate();
                  if( not MayCont )
                     Protocol.Error( "Не выгружены данные за критическую дату по счету", depositr.Account );
                  end;
               end;
            else
               Protocol.Error( "ошибка при выгрузке счета", depositr.Account );
            end;
            if( Maycont )
               if( not IsLock_Gate ) FillRepArrays(); end;
            end;
         end;

         /* Новый счет */
         Account      = String ( Int( FLAROS.Nbals ),
                                 Int( FLAROS.NOMLS ) );
         NextAccount  = False;
         ForFisrtDate = False;
         SaveDateDoc  = NullDate;
         NumDayDoc    = 0;
         WasWork      = False;
         WasOpenOper  = False;

         KeyNum( depositr, 4 );
         rewind( depositr    );
         ClearRecord( depositr );

         depositr.CodClient = Int( FLAROS.Nbals );
         depositr.IsCur     = 0;
         depositr.Number    = Int( FLAROS.NOMLS );

         if( GetEQ( depositr ) )
            KindInLaros = depositr.StaticPaid; /* Если счет есть в пром.файле- конвертируем его */
/*            NextAccount = ( ( NeedConvertType( KindInLaros ) ) and
                            ( depositr.Open_Close != "З"     )     ); /* Если конвертируем в данном сеансе */*/
            NextAccount = NeedConvertType( KindInLaros, depositr.Number ); /* Если конвертируем в данном сеансе */
/*          println ("616 Номер ", FLAROS.Nomls, " код ", FLAROS.OPER, " NextAccount ", NextAccount); */
            MayCont     = NextAccount;
            if( MayCont )
              /* Поиск записи вида вклада для основных условий */
               MayCont = GetPC_APLTP( depositr.IsCur, depositr.Type_Account, 0 );
               if( NOT MayCont )
                  Protocol.Error( "Для счета ", FLAROS.Nbals, Trim( FLAROS.NOMLS ),
                                 "не найден вид вклада \"", pc_apltp.ApType,
                                 "\"основных условий для вклада \"",Trim( DEPOSITR.Type_Account ),
                                 "\". Счет не сконвертирован." );
               else

                  MayCont = GetTypeRecord( pc_apltp.ApType, pc_apltp.IsCur );
                  if( NOT MayCont )
                     Protocol.Error( "Для счета ", Trim( DEPOSITR.Account ),
                                     "не найдена запись о виде вклада ", Trim( DEPOSITR.Type_Account ) );
                  end;
               end;
/*
               Группа по операциям
*/
               if( MayCont )
                  GrOper = GroupOperInLaros( KindInLaros, DEPOSITR.Open_Date);
                  if( GrOper == 0 )
                     Protocol.Error( " При конвенртации счета ", depositr.Account,
                                     " вид вклада ", depositr.Type_Account,"(", KindInLaros ,")",
                                     " не отнесен к группе операций");
                     MayCont = FALSE;
                  end;
               end;
               if( not IsLock_Gate )
                  if( MayCont )
                     if( depositr.UseAlternate )
                        MayCont = GetCriticalDate( 2002 );
                     else
                        MayCont = GetCriticalDate( 2001 );
                     end;
                     if( not MayCont )
                        Protocol.Error( "Не определена критическая дата по счету", depositr.Account );
                     end;
                  end;
                  if( MayCont )
                     /* Заносим данные по умолчанию */
                     extrn_limit( LIMIT_ACCOUNT              ) = depositr.Account;
                     extrn_limit( LIMIT_DATE                 ) = CriticalDate;
                     extrn_limit( LIMIT_SUM_CALC_ALL         ) = $0;
                     extrn_limit( LIMIT_SUM_PAY_ALL          ) = $0;
                     extrn_limit( LIMIT_SUM_CALC_NO_PAY_2001 ) = $0;
                     extrn_limit( LIMIT_SUM_CALC_NO_PAY_2002 ) = $0;
                     extrn_limit( LIMIT_FORWARD_PERCENT      ) = $0;
                     extrn_limit( LIMIT_SUM_PERC_OUT         ) = $0;
                     extrn_limit( LIMIT_SUM_COMPENS_IN       ) = $0;
                     extrn_limit( LIMIT_SUM_COMPENS_OUT      ) = $0;
                     extrn_limit( LIMIT_REST                 ) = $0;
                     extrn_limit( LIMIT_DATE_NEXT_CALC       ) = NullDate;
                     depositr.Limit_Date                       = extrn_limit( LIMIT_DATE );
                  end;
               end;
            end; /* fi первый Maycont */
         else
            if( NeedConvertType( KindInLaros, Int( Flaros.NomLs ) ) and not Islock_Gate )
              Protocol.Error( "Для счета", Account, "не найдено записи в файле счетов" );
            end;
         end;
      end; /* fi для нового счета */
/*
      ОБРАБОТКА ОПЕРАЦИИ
*/
/*    println ("683 Номер ", FLAROS.Nomls, " код ", FLAROS.OPER, " NextAccount ", NextAccount); */

      if( NextAccount AND IsNeedConvert() )
          if( MayCont AND
              ( ( FLAROS.OPER == "145" ) AND ( DEPOSITR.UseAlternate == 1 ) AND
                ( SB_DTYP.FormContr == 30                                 )     ) OR    /* Для пролонгируемых */
              ( ( FLAROS.OPER == "777" ) AND ( FLAROS.NOPER == 1          ) AND
                ( DEPOSITR.Type_Account == KindPension                    )     )     ) /* Для пенсионных */
              DEPOSITR.UseAlternate = 0;
          end;

          if( MayCont AND ( KindInLaros != "Г" ) )
             if( FLAROS.DATAV < DEPOSITR.Open_Date )
                Protocol.Error( " По счету ", Trim( FLAROS.NOMLS ),
                                " есть операция с датой, меньшей даты открытия" );
             end;
          end;

          if( MayCont )
/*
             Заполнение полей для выгрузки в текстовый файл операций
*/
             extrn_doc( DOC_ACCOUNT )      = DEPOSITR.Account;
             extrn_doc( DOC_TYPE_ACCOUNT ) = DEPOSITR.Type_Account;

             if( not IsLock_Gate )
                extrn_doc( DOC_DATE ) = FLAROS.DATAV;
             else
                extrn_doc( DOC_DATE ) = CountDate;
             end;

             extrn_doc( DOC_IN_SUM  ) = $0;
             extrn_doc( DOC_OUT_SUM ) = $0;

             if (GetResid (Flaros.NBALS) == 1)
                DopNumOper = 1;
             end;

             MayCont = GetNumOper( FLAROS.OPER,
                                   DOC_KINDOP,
                                   extrn_doc( DOC_TYPE_OPER         ),
                                   extrn_doc( DOC_TYPE_COMPLEX_OPER ),
                                   extrn_doc( DOC_APPL_TYPE         ),
                                   extrn_doc( DOC_GROUND            ),
                                   extrn_doc( DOC_VID               ),
                                   DopNumOper );

/*             println ("depositr.Account ", depositr.Account, " Flaros.Oper ", Flaros.Oper,
                      " ( Int ( FLAROS.Oper ) >= 240 ) ", ( Int ( FLAROS.Oper ) >= 240 ),
                      " ( Int ( FLAROS.Oper ) <= 244 ) ", ( Int ( FLAROS.Oper ) <= 244 ),
                      " FLAROS.Ostat ", FLAROS.Ostat);*/
             if( ( Int ( FLAROS.Oper ) >= 240 ) and
                 ( Int ( FLAROS.Oper ) <= 244 ) )
                if( ( ( not MustDecode ) and ( FLAROS.Ostat == $0 )                      ) or
                    ( MustDecode         and ( STOD( "OSTAT", GetPos( FLAROS ) ) == $0 ) )
                  )
                   extrn_doc( DOC_TYPE_OPER         ) = 4;
                   extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 10;
                   extrn_doc( DOC_GROUND            ) = FLAROS.Oper + " Закрытие списанием";
                end;
             end;

             if( not MayCont )
               Protocol.Error(" Для счета ", depositr.Account,
                              " не найдена операция ",String( FLAROS.OPER )," в списке" );

             end;

          end;

          if( MayCont )
             if  ( DOC_KINDOP == D_IN  )
               extrn_doc( DOC_IN_SUM  ) = Money( Double( FLAROS.SUMMA ) * 100 );
             elif( DOC_KINDOP == D_OUT )
               extrn_doc( DOC_OUT_SUM ) = Money( Double( FLAROS.SUMMA ) * 100 );
             else
               MayCont = FALSE;
               Protocol.Error(" Для операции ", String( FLAROS.OPER ),
                              " в списке не определен вид: дебет или кредит");
             end;
             extrn_doc( DOC_DEP_DATE     ) = FLAROS.DATAV;
             if( MustDecode )
                extrn_doc( DOC_REST      ) = Money( STOD( "OSTAT", GetPos( FLAROS ) ) * 100 );
             else
                extrn_doc( DOC_REST      ) = Money( Double( FLAROS.OSTAT ) * 100 );
             end;
             extrn_doc( DOC_CODE_CLIENT   ) = "";
             extrn_doc( DOC_PERC_OPR_SUM  ) = $0;
             extrn_doc( DOC_PERC_REST     ) = $0;
             extrn_doc( DOC_LINK_FLAG     ) = "";
             extrn_doc( DOC_IS_CONTROL    ) = "";
             extrn_doc( DOC_AUTHOR        ) = "0";
             extrn_doc( DOC_CODE_CURRENCY ) = "";

             if( extrn_doc( DOC_TYPE_COMPLEX_OPER ) == 10 )
                if( depositr.Open_Close != "З" )
                   Protocol.Warning( "Счет", depositr.Account, "закрыт конвертером" );
                   depositr.Open_Close = "З";
                end;
                depositr.CLose_Date = extrn_doc( DOC_DEP_DATE );
             end;
          end;

          if( ( extrn_doc( DOC_TYPE_OPER ) == 1 ) or ( extrn_doc( DOC_TYPE_OPER ) == 51 ) )
              WasOpenOper = True;
          end;

          if( MayCont )

             DateSplit( FLAROS.DATAV, DayOp, MonOp, YearOp );
             if( ( DayOp == 1 ) AND ( MonOp == 1 ) and ( sb_dtyp.Formcontr != 30 ) )
                if( ( FLAROS.OPER == "206" ) OR ( FLAROS.OPER == "000" ) OR
                    ( FLAROS.OPER == "999" ) OR ( FLAROS.OPER == "777" ) OR
                    ( FLAROS.OPER == "ДЕН" ) )
                   ForFisrtDate = True;
                   extrn_doc( DOC_DEP_DATE ) = Date( 31, 12, ( YearOp - 1 ) );
                   if( not IsLock_Gate )
                      extrn_doc( DOC_DATE  ) = extrn_doc( DOC_DEP_DATE );
                   else
                      extrn_doc( DOC_DATE  ) = CountDate;
                   end;
                end;
             end;
             DateSplit( extrn_doc( DOC_DEP_DATE ), DayOp, MonOp, YearOp );

             /*[ #                       #             #]
             ( depositr.Account, ForFisrtDate, WasOpenOper );*/

             if( ( sb_dtyp.FormContr     == 20 ) and ( depositr.Type_Account != KindChild ) and
                 ( depositr.UseAlternate == 0  ) )
                If( not IsLock_Gate  and ForFisrtDate and
                    not WasOpenOper )
                   DateSplit( depositr.Open_Date, Null, Null, OpenYear );
                   /*[ #           #        #]( OpenYear, Yearop, OpenYear);*/
                   if( ( OpenYear == Yearop ) and ( OpenYear == ( CurY - 1 ) ) )
                      /*[ # ]( depositr.Account );*/
                      /* Установили, что операции открытия не было,
                         а только операция зачисления % за 31.12 прошлого года */
                      ForFisrtDate = False;
                      /* Делаем операцию открытия*/
                      extrn_doc( DOC_TYPE_OPER         ) = 1;
                      extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 1;

                      extrn_doc( DOC_IN_SUM   ) = extrn_doc( DOC_REST );
                      extrn_doc( DOC_DATE     ) = depositr.Open_Date;
                      extrn_doc( DOC_DEP_DATE ) = extrn_doc( DOC_DATE );
                      extrn_limit( LIMIT_DATE ) = NullDate;
                      depositr.Limit_Date       = extrn_limit( LIMIT_DATE );
                      CriticalDate              = extrn_limit( LIMIT_DATE );

                   end;
                end;
             end;

             if( depositr.FormContr == 30 )
                /* Операция зачисления процентов за дату пролонгации должна
                   быть в карточке на день раньше */
/*                println ("extrn_doc( DOC_TYPE_OPER ) ", extrn_doc( DOC_TYPE_OPER ),
                         " extrn_doc( DOC_DEP_DATE  ) ", extrn_doc( DOC_DEP_DATE  ),
                         " depositr.Prol_DateDep ) ", depositr.Prol_DateDep,
                         " CheckProlOper( depositr.Prol_DateDep ) ",
                         CheckProlOper( depositr.Prol_DateDep ),
                         " FLAROS.OPER ", FLAROS.OPER           );*/
                if( ( extrn_doc( DOC_TYPE_OPER ) == 72                    ) and
                    ( extrn_doc( DOC_DEP_DATE  ) >= depositr.Prol_DateDep )     )
                   if( CheckProlOper( depositr.Prol_DateDep ) )
                      extrn_doc( DOC_DEP_DATE ) = extrn_doc( DOC_DEP_DATE ) - 1;
                      extrn_doc( DOC_TYPE_OPER )         = 82;
                      extrn_doc( DOC_TYPE_COMPLEX_OPER ) = extrn_doc( DOC_TYPE_OPER );
                   end;
                elif ( (extrn_doc (DOC_TYPE_OPER ) == 62) and
                       (extrn_doc (DOC_APPL_TYPE ) == 14) and
                       (extrn_doc (DOC_DEP_DATE  ) == depositr.Prol_DateDep) )
                   extrn_doc( DOC_DEP_DATE          ) = extrn_doc( DOC_DEP_DATE ) - 1;
                   extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 82;
                end;
             elif( depositr.FormContr == 20 )
                if( ( extrn_doc( DOC_TYPE_OPER ) == 72                   ) and
                    ( extrn_doc( DOC_DEP_DATE  ) >= depositr.End_DateDep )     )
                   if( CheckProlOper( depositr.End_DateDep ) )
                      extrn_doc( DOC_TYPE_OPER )         = 82;
                      extrn_doc( DOC_TYPE_COMPLEX_OPER ) = extrn_doc( DOC_TYPE_OPER );
                   end;
                end;
             end;

             if( SaveDateDoc != extrn_doc( DOC_DATE ) )
                SaveDateDoc = extrn_doc( DOC_DATE );
                NumDayDoc   = 0;
             end;
             NumDayDoc = NumDayDoc + 1; /* Увеличим счетчик документов за день */
             extrn_doc( DOC_NUM_DAY_DOC ) = NumDayDoc * 100;

             if( CheckCloseAcc() ) /* Данные за критическую дату заносим только для открытых */

                if( not IsLock_Gate and ( extrn_doc( DOC_DEP_DATE ) <= CriticalDate ) )
                   /* Операции до "Критической даты" */
                   if(   GrOper == 1 ) /* Срочные         */
                      if( ForFisrtDate )
                         ForFisrtDate = False;
                         extrn_limit( LIMIT_SUM_CALC_ALL ) = Money( Double( FLAROS.OPROC ) * 100 );
                         extrn_limit( LIMIT_SUM_PAY_ALL  ) = Money( Double( FLAROS.OPROC ) * 100 );
                      end;
                   elif( GrOper == 2 ) /* Депозиты        */
                      if( ForFisrtDate )
                         ForFisrtDate = False;
                         extrn_limit( LIMIT_SUM_CALC_ALL ) = Money( Double( FLAROS.OPROC ) * 100 );
                         extrn_limit( LIMIT_SUM_PAY_ALL  ) = Money( Double( FLAROS.OPROC ) * 100 );
                      end;
                   elif( GrOper == 3 ) /* До востребоваия */
                      ;
                   elif( GrOper == 4 ) /* Пролонгируемые  */
                      if( ( depositr.Type_Account == "Ср.1мес.выпл" ) and
                          ( FLAROS.Oper           == "210"          ) )
                         extrn_limit( LIMIT_SUM_CALC_ALL ) = Money( Double( FLAROS.OPROC ) * 100 );
                         extrn_limit( LIMIT_SUM_PAY_ALL  ) = Money( Double( FLAROS.OPROC ) * 100 );
                      end;
                   elif( GrOper == 5 ) /* Детские         */
                      if( ForFisrtDate )
                         ForFisrtDate = False;
                         extrn_limit( LIMIT_SUM_CALC_NO_PAY_2001 ) = Money( Double( FLAROS.OPROC ) * 100 );
                         extrn_limit( LIMIT_SUM_CALC_NO_PAY_2002 ) = Money( Double( FLAROS.PROC1 ) * 100 );
                      end;
                   else
                       ;
                   end;

                   extrn_limit( LIMIT_REST         ) = extrn_doc( DOC_REST );

/* RA 14.01.00 Для пролонгируемых депозитов накопленные проценты на критическую дату берем из OPROC*/

                   if( ( depositr.Formcontr == 30 ) and ( OPROC_111 != 0 ) ) /* заполняется в CheckProlOper() */
                      extrn_limit( LIMIT_SUM_CALC_ALL ) = Money( Double( OPROC_111 ) * 100 );
                      extrn_limit( LIMIT_SUM_PAY_ALL  ) = extrn_limit( LIMIT_SUM_CALC_ALL );
                      OPROC_111 = 0;
                   end;
                   if( ( depositr.Formcontr != 30 ) and ( pc_alg.GrafCalc != 4 ) )
                      if(  ( extrn_doc( DOC_TYPE_OPER ) == 72 ) or
                           ( extrn_doc( DOC_TYPE_OPER ) == 82 )    )
                         /* Операция причисления процентов увеличивает сумму рассчитанных % */
                         extrn_limit( LIMIT_SUM_CALC_ALL ) = extrn_limit( LIMIT_SUM_CALC_ALL ) +
                                                             DenomSum( extrn_doc( DOC_IN_SUM    ),
                                                                       extrn_doc( DOC_DEP_DATE      ),
                                                                       extrn_doc( DOC_TYPE_OPER ) );
                      elif( extrn_doc( DOC_TYPE_OPER ) ==  6 )
                         /* Операция выдачи процентов уменьшает сумму рассчитанных % */
                         extrn_limit( LIMIT_SUM_CALC_ALL ) = extrn_limit( LIMIT_SUM_CALC_ALL ) -
                                                             DenomSum( extrn_doc( DOC_OUT_SUM   ),
                                                                       extrn_doc( DOC_DEP_DATE      ),
                                                                       extrn_doc( DOC_TYPE_OPER ) );
                      end;
                      extrn_limit( LIMIT_SUM_PAY_ALL ) = extrn_limit( LIMIT_SUM_CALC_ALL );
                   end;

                   /* Обработка зачисления и выдачи компенсации */
                   if  ( extrn_doc( DOC_TYPE_OPER ) == 74 )
                      extrn_limit( LIMIT_SUM_COMPENS_IN  ) = extrn_limit( LIMIT_SUM_COMPENS_IN ) +
                                                           DenomSum( extrn_doc( DOC_IN_SUM    ),
                                                                     extrn_doc( DOC_DEP_DATE      ),
                                                                     extrn_doc( DOC_TYPE_OPER ) );

                   elif( extrn_doc( DOC_TYPE_OPER ) == 15 )
                      extrn_limit( LIMIT_SUM_COMPENS_OUT ) = extrn_limit( LIMIT_SUM_COMPENS_OUT ) +
                                                           DenomSum( extrn_doc( DOC_IN_SUM    ),
                                                                     extrn_doc( DOC_DEP_DATE      ),
                                                                     extrn_doc( DOC_TYPE_OPER ) );
                   end;
                   if( depositr.Type_Account == "Ср.1мес.выпл" )
                      extrn_limit( LIMIT_SUM_CALC_ALL ) = Money( Double( FLAROS.OPROC ) * 100 );
                      extrn_limit( LIMIT_SUM_PAY_ALL  ) = Money( Double( FLAROS.OPROC ) * 100 );
                   end;
                else
                   /* После:
                      1.Поднимаем флаг выгрузки операций в файл второй сессии ( только для конвертера )
                      2.Нужно связать комплексные операции и только выдачу % за
                        одну дату документа
                   */

                   if( not IsLock_Gate ) WasWork = True; end;
                   /*
                   if( FLAROS.Oper == "253" )
                       /* Отчисление процентов */
                       Summa253 = extrn_doc( DOC_OUT_SUM  );
                       Data253  = extrn_doc( DOC_DEP_DATE );
                       /*Добавлено ВИГ*/
                       NOper    = FLAROS.Noper;
                    /*   Protocol.Message ("Номер операции", NOper);*/
                    /*   [ #                         #              #]
                       ( depositr.Account, Summa253, Data253 );*/
                      /*NeedOutStr = False; /* не обрабатывать эту операцию */*/
                   end;
                   */
                   if( MayCont )
                      /* Проверим код операции после критической даты */
                      Keynum( sb_typop, 0 );

                      sb_typop.IsCur    = depositr.IsCur;
                      sb_typop.Kind     = depositr.Type_Account;
                      sb_typop.NumOpert = extrn_doc( DOC_TYPE_OPER );
                      if( not GetEQ( sb_typop ) )
                         Protocol.Error( "Для вклада", depositr.Type_Account, "не найдена операция с кодом ",
                                          extrn_doc( DOC_TYPE_OPER ), "в Ларосе код операции", FLAROS.OPER );
                         Protocol.Message( "Операции по счету", depositr.Account, "после критической даты не выгружены" );
                         Maycont = False;
                      end;
                   end;
                   if( Maycont )
                      if( (extrn_doc( DOC_TYPE_OPER ) == 72)       or
                          ( (extrn_doc( DOC_TYPE_OPER ) == 62) and
                            (extrn_doc( DOC_APPL_TYPE ) == 14) )
                        )
                         if( ComplexDate == NullDate )
                            ComplexDate = extrn_doc( DOC_DEP_DATE );
                         end;

                         /* Определим было ли это зачисление % зачислением перед выдачей */
                         GetPos( Flaros );
                         Found        = False;
                         FoundCompens = False;
                         if( Flaros.Oper == "253" )
                            while( not Found and next( Flaros ) and ( flaros.Datav == Complexdate ) )
                               /* Перебираем операции за заданную дату*/
                               if( ( FLAROS.OPER == "142" ) or ( FLAROS.OPER == "141" ) )
                                  /* Нашли выдачу % */
                                  Found = True;
                               elif( IsLock_Gate and ( FLAROS.OPER == "154" ) )
                                  /* Нашли закрытие */
                                  Found = True;
                               end;
                            end;
                         else
                            while( not Found and not FoundCompens and
                                   next( Flaros ) and ( flaros.Datav == Complexdate ) and
                                   ( FLAROS.OPER != "206" )
                                 )
                               /* Перебираем операции за заданную дату*/
                               if( ( FLAROS.OPER == "142" ) or ( FLAROS.OPER == "141" ) )
                                  /* Нашли выдачу % */
                                  Found = True;
                               elif( IsLock_Gate and ( FLAROS.OPER == "154" ) )
                                  /* Нашли закрытие */
                                  Found = True;
                               elif( FLAROS.Oper == "958" )
                                  /* Нашли выдачу компенсации */
                                  FoundCompens = True;
                               end;
                            end;
                         end;
                         if( Found and ( FLAROS.OPER != "154" )  )
                            extrn_doc( DOC_LINK_FLAG ) = "1";
                            if( IsSrochnPens() and ( FLAROS.OPER  == "141" ) )
                               ApplType = 4;
                            else
                               ApplType  = extrn_doc( DOC_APPL_TYPE );
                            end;
                            extrn_doc( DOC_APPL_TYPE         ) = ApplType;
                            extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 6;
                         elif( Found and ( FLAROS.OPER == "154" ) )
                            extrn_doc( DOC_LINK_FLAG         ) = "1";
                            extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 10;
                         elif( FoundCompens == True )
                            extrn_doc( DOC_LINK_FLAG         ) = "1";
                            extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 15;
                         else
                            ComplexDate = NullDate;
                         end;

                         /*println( extrn_doc( DOC_ACCOUNT   ), " ",
                                  extrn_doc( DOC_LINK_FLAG ), " ",
                                  extrn_doc( DOC_DATE      ), " ",
                                  extrn_doc( DOC_TYPE_OPER )      );*/
                         GetDirect( Flaros );

                      elif( ComplexDate != NullDate  )
                         if( ( FLAROS.OPER == "142" ) or ( FLAROS.OPER == "141" ) )
                            /* Выдача % */
/*
                            println ("ApplType ", ApplType,
                                     " extrn_doc(DOC_ACCOUNT) ", extrn_doc(DOC_ACCOUNT),
                                     " extrn_doc(DOC_DEP_DATE) ", extrn_doc(DOC_DEP_DATE),
                                     " extrn_doc(DOC_TYPE_OPER) ", extrn_doc(DOC_TYPE_OPER)
                                     );*/
                            extrn_doc( DOC_APPL_TYPE ) = ApplType;
                            extrn_doc( DOC_LINK_FLAG ) = "";
                         elif( ( FLAROS.OPER == "154" ) )
                            extrn_doc( DOC_TYPE_COMPLEX_OPER ) = 10;
                         end;

                         ComplexDate = NullDate;
                         Summa253    = $0;
                         Data253     = Nulldate;
                         ApplType    = 0;
                      end;
                   end;
                   /* Установка признака главного документа */
                   if( extrn_doc( DOC_TYPE_OPER ) == extrn_doc( DOC_TYPE_COMPLEX_OPER ) )
                      extrn_doc( DOC_IS_CONTROL ) = StrFor( 1 );
                   elif( ( extrn_doc( DOC_TYPE_COMPLEX_OPER ) == Закрытие_Наличными    ) or
                         ( extrn_doc( DOC_TYPE_COMPLEX_OPER ) == Закрытие_Безналичными )   )
                      if( ( extrn_doc( DOC_TYPE_OPER ) == Расход                ) or
                          ( extrn_doc( DOC_TYPE_OPER ) == Списание_По_Раз_Поруч )    )
                         extrn_doc( DOC_IS_CONTROL ) = StrFor( 1 );
                      end;
                   end;
/*                println ("extrn_doc( DOC_TYPE_OPER ) ", extrn_doc( DOC_TYPE_OPER ),
                         " extrn_doc( DOC_DEP_DATE  ) ", extrn_doc( DOC_DEP_DATE  ),
                         " depositr.Prol_DateDep ) ", depositr.Prol_DateDep,
                         " MayCont ", MayCont,
                         " FLAROS.OPER ", FLAROS.OPER
                         );*/

                end;
             end;
             extrn_doc( DOC_OPER              ) = 9999;
             extrn_doc( DOC_ACTION            ) = 0;
             extrn_doc( DOC_OBJECT_PERC       ) = 0;

             if( ( FLAROS.OPER == "197" ) and ( IsLock_Gate ) )
                if( depositr.Type_Account != "ДО ВОСТРЕБ." )
                   Protocol.Warning ("Для счета ", depositr.Account, " обнаружен перевод на другой вид вклада. ",
                                     "Если оброты за день не идут, переведите этот счет вручную.");
                else
                   extrn_doc( DOC_REST ) = $0;
                   ext_doc.Str = MakeTxtStr( extrn_doc );
                   if( not Insert( ext_doc ) )
                      Protocol.Error( "Для счета", depositr.Account,
                                      "не выгружена операция", extrn_doc( DOC_DEP_DATE ) );
                      MayCont = FALSE;
                   else
                      depositr.Type_Account = "Пенсионный";
                      if( not Update (depositr) )
                         protocol.Error ("Не удалось обновить информацию по Пенсионному счету ",
                                          depositr.Account);
                      else
                         FillRep_Gate (D_OUT);
                         NumDayDoc = NumDayDoc + 1;
                         extrn_doc( DOC_TYPE_ACCOUNT ) = depositr.Type_Account;
                         extrn_doc( DOC_NUM_DAY_DOC  ) = NumDayDoc * 100;
                         extrn_doc( DOC_APPL_TYPE    ) = 2;
                         extrn_doc( DOC_GROUND       ) = "197 Смена вида вклада - Зачисление";
                         extrn_doc( DOC_REST         ) = Money( Double( FLAROS.SUMMA ) * 100 );
                         extrn_doc( DOC_IN_SUM       ) = Money( Double( FLAROS.SUMMA ) * 100 );
                         extrn_doc( DOC_OUT_SUM      ) = $0;
                         DOC_KINDOP = D_IN;
                      end;
                   end;
                end;
             end;
          end;
/*
          Запись в файлы
*/
          if( MayCont and NeedOutStr )
             if( not WasWork )
                ext_doc.Str = MakeTxtStr( extrn_doc );
                if( not Insert( ext_doc ) )
                   Protocol.Error( "Для счета", depositr.Account,
                                   "не выгружена операция", extrn_doc( DOC_DEP_DATE ) );
                   MayCont = FALSE;
                end;
             else
                ext_doc_2.Str = MakeTxtStr( extrn_doc );
                if( not Insert( ext_doc_2 ) )
                   Protocol.Error( "Для счета", depositr.Account,
                                   "не выгружена операция", extrn_doc( DOC_DEP_DATE ) );
                   MayCont = FALSE;
                end;
             end;
          end;

          if( MayCont )
             if( IsLock_Gate ) Fillrep_Gate( DOC_KINDOP ); end;
             NumStrFile = NumStrFile + 1;
          end;
          NextAccount = MayCont;
          KolStrFile  = KolStrFile + 1;
      end;
      UseProgress( KolView = KolView + 1 );
   end; /* elihw */
   RemProgress( KolView );

   if( NextAccount )
      MayCont = OutDepositr();
      if( MayCont )
         if( ( not IsLock_Gate ) and ( depositr.Open_Close != "З" ) )
            MayCont = OutLimitDate();
            if( not MayCont )
               Protocol.Error( "Не выгружены данные за критическую дату по счету", depositr.Account );
            end;
         end;
      else
         Protocol.Error( "ошибка при выгрузке счета", depositr.Account );
      end;
      if( Maycont )
         if( not IsLock_Gate ) FillRepArrays(); end;
      end;
   end;
end;

/***********************************************************
     Головной макрос конвертирования счетов и вкладчиков
***********************************************************/

macro laros_fc_1_2()

   WorkWithFileLarosOper ();
   Protocol.Message( " Промежуточный итог: всего", KolView, "сконвертировано",
                     NumStrFile, "записей базы Laros" );

end;




