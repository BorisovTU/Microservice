/*
  RS-Retail
  Конвертирование данных из Laros в RS-Retail
  1999 год

  Общие функции

  21.09.99 Рыжиков Александр Александрович ( RA )

  RA 09.12.99 - добавил процедуры, необходимые для конвертации валюты
*/
import "retconst.mac";
import "files.mac";
import "supplib.mac";
import "cnv_log.mac";
import decode;
import DeprIntr;
import Календарь;

/*========================== Файлы данных ================================*/
file FLAROS    () dbf;   /* счета и клиенты */

file ext_dep   () txt 512 write;
file ext_doc   () txt 512 write;
file ext_doc_2 () txt 512 write;
file ext_cln   () txt 512 write;
file ext_limit () txt 512 write;
file ext_resrv () txt 512 write;

file report   ( "sb_depst.dbt" ) write; /* временный файл отчета        */
file indfile  ( "indfile.dbt",  "laros_fc.def" ) write; /* временный файл опердневников */
file v_idfile ( "v_idfile.dbt", "laros_fc.def" ) write; /* временный файл опердневников для валюты*/

/*===========================  Настройки ================================*/
var Branch     = NumFNCash();
var FlagCur    = NumFlagCur();
var Numsession = "0001";

var DirConvert   = "..\\LAROS\\";

if( FlagCur ) DirConvert   = "..\\LARVAL\\"; end;

var GateDir = "\\FIZM\\";

const ProtocolPath = "..\\TXTFILE\\";
const WorkDir      = "..\\WORKFILE\\";
const DestinDir    = "..\\IMPORT\\";

const ConvVersion  = "03.05_01";  /* версия конвертера - день.месяц.номер версии*/

const ConvertKind = "Л";          /* ;Конвертируемые в текущем сеансе виды вкладов
                                     "" - конвертируем все виды вкладов */
array NumTestAcc;                 /* Конвертируемые в текущем сеансе номера счетов, проверка
                                   */
const IsLock_Gate = False;
                                  /* Флаг работы в режиме шлюза или конвертера:
                                     True  - работаем как шлюз
                                     False - конвертер
                                  */

const MustDecode = False;          /* Флаг - декодировать или нет.
                                     True  - декодировать
                                     False - нет  */

/*======================== Переменные и массивы ==========================*/
var InFileName = "";
var BegLockDate,
    EndLockDate,
    CountDate;

var Protocol : clProtocol;

array extrn_dep;
array extrn_doc;
array extrn_cln;
array extrn_resrv;
array extrn_limit;

array TmpAccNum;

/**********************************************************/

const OperToAlt      = 85;  /* Перевод счета в альтернативный режим */
var   Global_EndDate = Date(0,0,0);/* Глобальная переменная- дата конца договора */
const BeginNumDoc    = 100;  /* Номер первой операции п осчету за день */
var   MonForPen      = 11;   /* Для Пенсионного- месяц, начиная с которого */
var   {curdate};

/***********************************************************
   Интересные виды вкладов
***********************************************************/
const KindPension  = "Пенсионный";
const KindSbereg_1 = "СБЕРЕГ.1МЕС.";
const KindSbereg_2 = "СБЕРЕГ.2МЕС.";
const KindSbereg_3 = "СБЕРЕГ.3МЕС.";
const KindSbereg_6 = "СБЕРЕГ.6МЕС.";
const KindChild    = "Целев. дети";
const KindNoMobil  = "Неподвижный";
const KindUnited   = "Объединенный";
const KindMoscow   = "ЮБИЛЕЙНЫЙ";

const slu = "Служебный";

/**********************************************************/
macro IsKindSbereg( TypeAccount )
/*
  True- если вклад сберегательный
*/
  var stat = FALSE;

  if( ( TypeAccount == KindSbereg_1 ) OR
      ( TypeAccount == KindSbereg_2 ) OR
      ( TypeAccount == KindSbereg_3 ) OR
      ( TypeAccount == KindSbereg_6 )    )
    stat = TRUE;
  end;
  return stat;
end;

/* Массив коротких номеров счетов, конвертируемых в данном сеансе */
macro SetTestAcc()

   NumTestAcc( 0 ) = 050235;
   NumTestAcc( 1 ) = 050230;
   NumTestAcc( 2 ) = 050231;
   NumTestAcc( 3 ) = 050234;
   NumTestAcc( 4 ) = 050249;
/*
   NumTestAcc( 5 ) = 890117;
   NumTestAcc( 6 ) = 891719;
   NumTestAcc( 8 ) = 892321;
   NumTestAcc( 9 ) = 928742;
   NumTestAcc(10 ) = 928787;
   NumTestAcc(11 ) = 928742;
   NumTestAcc(12 ) = 925955;
   NumTestAcc(13 ) = 776522;
   NumTestAcc(14 ) = 111111;
   NumTestAcc(15 ) = 910075;
   NumTestAcc(16 ) = 910076;
   NumTestAcc(17 ) = 0940003;
   NumTestAcc(18 ) = 0956241;
   NumTestAcc(19 ) = 0956398;
   NumTestAcc(20 ) = 0956499;
   NumTestAcc(21 ) = 0956757;
   NumTestAcc(22 ) = 0956830;
*/
end;

/***********************************************************
   Таблица видов вкладов, конвертируемых в текущий сеанс
***********************************************************/
/*
 Таблица конвертируемых видов вкладов
 Заполняется идентификаторами Laros видов вкладов,
 которые надо конвертировать в текущий сеанс
 (Обратите внимание, что каждый идентификатор- один символ)
*/

macro NeedConvertType
(
 Kind,   /* Проверяемый тип вклада       */
 NomLS   /* проверяемый номер счета      */
)
/*
  Возврат:
    TRUE - есть в списке
    FALSE - нет в списке
*/
  var stat;

  SetTestAcc();
  if (ConvertKind == "")
    stat = TRUE;
  else
    if( ( Index( ConvertKind,Kind ) ) > 0 )
      /*MsgBox( Asize( NumTestAcc ) );*/
      if( Asize( NumTestAcc ) != 0 )
         stat = ( ArrayIndex( NumTestAcc, NomLS ) != -1 );
      else
         stat = TRUE;
      end;
    else
      stat = FALSE;
    end;
  end;
  return stat;
end;

/***********************************************************
************************************************************
   Работа с видами вкладов
***********************************************************/
/* RA 12.02.99  Изменил определение переменной "Dop" */
macro GetRsKindForLaros_New
(
 Tip_vk,        /* Вход - идентификатор вида вклада            */
 DateO,         /* Вход - дата открытия счета                  */
 PrizU,         /* Вход - доп.информация из поля PrizU  */
 RsKind         /* Выход - тип вклада в RS-Retail       */
)
/*
  Таблица соответствия идентификаторов вида вклада в
  Laros и типов вкладов в RS-Retail
  Возврат:
   True -  определено
   False - не определено
*/
  var RsKind_ = "",
      Stat = TRUE;
  var LarosIdent = SubStr( Tip_vk, 1, 1 );
  var Dop        = Trim(SubStr( Tip_vk, 2 ) );
  /*var Dop = Int(SubStr(Tip_vk,2));*/

  if (LarosIdent == "0")
    RsKind_ = "СРОЧНЫЙ";
  elif (LarosIdent == "Г")      /* Депозиты             */
    if (DateO <= Date(5,5,1997))
      if   ( Dop ==  "4" )
        RsKind_ = "СР.ДЕП. 4 М.";
      elif ( Dop ==  "6" )
        RsKind_ = "СР.ДЕП. 6 М.";
      elif ( Dop == "12" )
        RsKind_ = "СР.ДЕП. 12М.";
      else
        stat = FALSE;
      end;
    else        /* С пролонгацией       */
      if   ( Dop ==  "4" )
        RsKind_ = "СР.ДЕП. 4 МП";
      elif ( Dop ==  "6" )
        RsKind_ = "СР.ДЕП. 6 МП";
      elif ( Dop == "12" )
        RsKind_ = "СР.ДЕП. 12МП";
      else
        stat = FALSE;
      end;
    end;
  elif (LarosIdent == "Т")      /* До востребования                     */
    if ( Dop ==  "1")
      RsKind_ = KindPension;
    elif (Dop == "6")
      RsKind_ = "КомБанки";
    elif (PrizU == "l")
      RsKind_ = "Условн.";
    else
      RsKind_ = "ДО ВОСТРЕБ.";
    end;
  elif (LarosIdent == "6")      /* Срочный с ежемесячной выплатой       */
    RsKind_ = "Ср.1мес.выпл";
  elif (LarosIdent == "И")
    if   ( Dop ==  "3" )
      RsKind_ = "Фикс-3";
    elif ( Dop ==  "6" )
      RsKind_ = "Фикс-6";
    else
      stat = FALSE;
    end;
  elif (LarosIdent == "3")      /* Старые депозиты      */
    if   ( Dop ==  "3" )
      RsKind_ = "Деп-3";
    elif ( Dop ==  "6" )
      RsKind_ = "Деп-6";
    elif ( Dop == "12" )
      if (DateO <= Date(30,6,1995))
        RsKind_ = "Деп-12";
      else
        RsKind_ = "Деп-12-после";
      end;
    else
      stat = FALSE;
    end;
  elif (LarosIdent == "Л")      /* Срочный пенсионный   */
    if   ( Dop ==  "6" )
      RsKind_ = "Ср.пенс.6мес";
    elif ( Dop == "12" )
      RsKind_ = "Ср.пен.1г1м";
    else
      RsKind_ = "Ср.пенсион.";
    end;
  elif (LarosIdent == "Н")
    RsKind_ = KindChild;
  elif (LarosIdent == "С")
    if   ( Dop ==  "1" )
      RsKind_ = KindSbereg_1;
    elif ( Dop ==  "2" )
      RsKind_ = KindSbereg_2;
    elif ( Dop ==  "3" )
      RsKind_ = KindSbereg_3;
    elif ( Dop ==  "6" )
      RsKind_ = KindSbereg_6;
    elif ( Dop == "КД" )
      RsKind_ = "Депутатский";
    else
      stat = FALSE;
    end;
  elif (LarosIdent == "Ш")
    RsKind_ = "ШКОЛЬНЫЙ";
  elif (LarosIdent == "1")
      RsKind_ = "СПЕЦИАЛЬНЫЙ";
  /* ЛСВ 10.07.98 Добавил "О" к "Ю" SCR 1611 */
  /* RA  08.02.99 Добавил ГЖС */
  elif ( (LarosIdent == "Ю") ) /* OR (LarosIdent == "О")) */
     if( Dop == "К" )
        RsKind_ = "ЦЕЛЕВОЙ";  /* ???? */
     else
        RsKind_ = "ССУДА БЕЗ %";
     end;
  elif (LarosIdent == "5")
      RsKind_ = "СРОЧНЫЙ 1-3";
  elif (LarosIdent == "7")
      RsKind_ = "СРОЧНЫЙ 3-5";
  elif (LarosIdent == "8")
      RsKind_ = "КОМПЕНСАЦИЯ";
  elif (LarosIdent == "9")
      RsKind_ = "СРОЧНЫЙ ОТ 5";
  elif (LarosIdent == "Б")
    RsKind_ = "ЮБИЛЕЙНЫЙ";
  elif (LarosIdent == "Ц")
    RsKind_ = "НОМЕРНОЙ";
/* RA 08.02.99  Добавил Новогодний и Новогодний + */
  elif (LarosIdent == "Э")
    if  (  Dop ==  "1" )
      RsKind_ = "ВЕСЕННИЙ";
    elif(  Dop ==  "2Г" )
      RsKind_ = "НОВОГОДНИЙ_";
    else
      RsKind_ = "РОЖДЕСТВЕН.";
    end;
  elif (LarosIdent == "Щ")
    if  (  Dop ==  "1" )
      RsKind_ = "ВЕСЕННИЙ+";
    elif(  Dop ==  "2Г" )
      RsKind_ = "НОВОГОДНИЙ +";
    elif(  Dop ==  "3" )
      RsKind_ = "СБ-501";
    else
      RsKind_ = "РОЖДЕСТВЕН.+";
    end;
  elif (LarosIdent == "Ь")
    RsKind_ = "НОВОДЕНЕЖНЫЙ";
  elif (LarosIdent == "Й")
    RsKind_ = "Компнес. 2";
  elif (LarosIdent == "А")
    RsKind_ = "ВЫИГРЫШНЫЙ";
  elif (LarosIdent == "Ч")
    RsKind_ = "Ч беженцев";
  elif (LarosIdent == "Ж")
    RsKind_ = "Молодежный";
  elif (LarosIdent == "В")
    if( ( Dop >= 1 ) AND ( Dop <= 4 ) )
       RsKind_ = "Депутатский";
    else
       RsKind_ = "Ден.-вещев.";
    end;
  elif (LarosIdent == "Д")
    RsKind_ = "Сроч.c доп.";
  elif (LarosIdent == "П")
    RsKind_ = "На предъяв.";
  elif (LarosIdent == "М")
    RsKind_ = "Молод.-Прем.";
  /* ЛСВ 10.07.98 Добавил новые виды вкладов */
  elif (LarosIdent == "Ы")
    RSKind_ = "СБ-100 дней";
  elif (LarosIdent == "Ъ")
    RSKind_ = "СБ-60 дней";
  elif (LarosIdent == "О")
    if( Dop == "12" )
      RsKind_ = "Особ.н.1г_1м";
    else
      RSKind_ = "Особый номер";
    end;
  elif (LarosIdent == "Р")
    RsKind_ = "1 КЛАССНИК";
  elif (LarosIdent == "W")
    if(   Dop ==  "4" )
      RsKind_ = "V-Gold Привл";
    elif( Dop == "12" )
      RsKind_ = "Cirrus Maest";
    end;
/*
  elif (LarosIdent == "Я")
    RsKind_ = "";
  elif (LarosIdent == "Х")
    RsKind_ = "";
  elif (LarosIdent == "З")
    RsKind_ = "";
  elif (LarosIdent == "N")
    RsKind_ = "";
  elif (LarosIdent == "4")
    RsKind_ = "";
  elif (LarosIdent == "2")
    RsKind_ = "";
  elif (LarosIdent == "")
    RsKind_ = ""; */

  else
    Stat = FALSE;
  end;
  SetParm (3,RsKind_);
  return Stat;
end;

/***********************************************************/

macro GetTypeAccountForUnited
(
 Acc    /* Вход - Счет Laros */
)
/*
  Возвращает идентификатор вида вклада в Laros
  на основании номера счета
  В номере счета вид вклада- четвертый символ
*/
  var Ident;
  var Len;

  Acc = trim(Acc);
  Len = StrLen(Acc);
  Ident = SubStr (Acc,Len);
  return Ident;
end;
/**********************************************************/

macro GetAccNumber_New
(
 Acc    /* Вход - Счет Laros */
)
/*
  Возвращает номер счета в группе нумерации (по Ларос)
*/
  var Num;
  Num = SubStr(Acc,6);
  return Num;
end;

/**********************************************************/

macro GetTypeRecord
(
 TypeAccount,   /* Вид вклада   */
 FlagCur        /* Рубли\Валюта */
)
/*
  Поиск строки в справочнике видов вкладов
  Возврат:
    TRUE - найдено
    FALSE - не найдено
*/
  var stat;

  keynum( SB_DTYP, 2 );
  rewind( SB_DTYP    );

  SB_DTYP.FlagCur = FlagCur;
  SB_DTYP.Kind    = TypeAccount;

  stat = GetEQ (SB_DTYP);
  return stat;
end;
/**********************************************************/

macro GroupKindInLaros
(
 LarosIdent
)
/*
  Определение, к какой группе по размещению данных в поле
  PASP базы Laros принадлежит вид вклада (по Laros)
*/
  Array Group;
  /* ЛСВ 10.07.98 Добавил "О" к "Ю" SCR 1611 */
  /*-----------------29.11.99 11:27-------------------
  ВИГ добавил Р
   --------------------------------------------------*/
  Group(1) = "0578921ЮОЦцВвТтВДПМРрW";    /* Нет сведений о договоре      */
  /* ЛСВ 10.07.98 Добавил ЫЪ - новые виды вкладов */
  Group(2) = "ГгСсЕеИи34ЛлЭЩщЬьЙйБЫЪО";   /* Дата конца договора + срок   */
  Group(3) = "НнШш";                      /* Дата рождения + дата достижения...*/
  var NumGr = 0;
  var i = 1;
  var Cont = TRUE;

  while ((i<Asize(Group)) AND Cont)
    if (Index(Group(i),LarosIdent) > 0)
      Cont = FALSE;
      NumGr = i;
    end;
    i = i + 1;
  end;
  return NumGr;
end;
/**********************************************************/

macro GroupOperInLaros
(
 LarosIdent,
 Open_Date  /* Дата открытия счета */
)
/*
  Определение, к какой группе по размещению данных в полях
  процентов (файлы операций) базы Laros принадлежит вид вклада
  (по Laros) (строка за 01.01 с операцией "206", "000" или"ДЕН")
  --------------------------------------------------------------------
  Группа | SUMMA               | OSTAT             | PROC1   | OPROC
  --------------------------------------------------------------------
  Срочные
      1   % за прошлый год      остаток по счету       0        % к выдаче
  Депозиты без пролонгации
      2   % за прошлый год      остаток по счету       0        % к выдаче
                                (с процентами)
  До востребования
      3   % за прошлый год      Реальный остаток       0       0
  С пролонгацией
      4   Хранится вся история за декабрь прошлого года
  Детский
      5   0                     Остаток на 31.12.97     % с на- % без нарушения
                                (взносы)                рушением
  -----------------------------------------------------------------------
*/
  Array Group;
  Group(1) = "05789ДХW";
  Group(2) = "34ГЕЭЩЬЪЫВЮКР";
  Group(3) = "1АТШЖМПЧУФ";
  Group(4) = "СИЛГ6ЦЙБО";
  Group(5) = "НЯ";
  var NumGr = 0;
  var i = 1;
  var Cont = TRUE;

  if (LarosIdent == "Г")
    if (Open_Date < Date(5,5,1997))
      NumGr = 2;
    else
      NumGr = 4;
    end;
  else
    while ((i<Asize(Group)) AND Cont)
      if (Index(Group(i),LarosIdent) > 0)
        Cont = FALSE;
        NumGr = i;
      end;
      i = i + 1;
    end;
  end;
  return NumGr;
end;

/***********************************************************/

macro GetDepositrRecordReferenc
(
 Referenc
)
/*
  Поиск строки в файле счетов
  Возврат:
    TRUE - найдено
    FALSE - не найдено
*/
  var stat;

  KeyNum ( DEPOSITR, 8 );
  DEPOSITR.Referenc = Referenc;
  stat = GetEQ (DEPOSITR);
  return stat;
end;

/***********************************************************
    Работа с датами
***********************************************************/

macro GetDateFromPasp
(
 BeginS,/* Начальный символ строки              */
 Str    /* Строка, из которой выбирается дата   */
)
/*
  Получение даты, записанной в первые 10 символов поля
*/
  var PaspDate;
  var BegS = BeginS - 1;
  PaspDate = Date (Int(substr(Str,BegS+1,2)),
   Int(SubStr(Str,BegS+4,2)), Int(SubStr(Str,BegS+7,4)));
  return PaspDate;
  OnError (CurErr)
     MsgBox (CurErr.Message, " Модуль: ", CurErr.Module, " строка: ", CurErr.Line);
end;

/**********************************************************/

macro LastDay
(
 m,     /* Месяц        */
 y      /* Год          */
)
/*
  Последний день месяца
*/
  var d;
  m = m + 1;
  if (m > 12)
    m = 1;
    y = y + 1;
  end;
  DateSplit (Date(1,m,y)-1,d);
  return d;
end;

macro SumDate
(
 BegDate,       /* Дата, к которой добавляем            */
 Term,          /* Добавляемое значение (>0 или <0)     */
 KindTerm       /* Вид срока                            */
)
/*
  Возвращает дату- результат
*/
  var ResDate = Date(0,0,0);
  var d,m,y;

  if (KindTerm == R_QW)
    Term = Term * 3;
    KindTerm = R_MON;
  end;
  DateSplit (BegDate,d,m,y);
  if (KindTerm == R_YEAR)
    y = y + Term;
    if ((m == 2) AND (d > 28))
      d = LastDay (m,y);
    end;
    ResDate = Date(d,m,y);
  elif (KindTerm == R_DAY)
    ResDate = BegDate + Term;
  /* ЛСВ 10.07.98 */
  elif (KindTerm == R_REALDAY)
    ResDate = BegDate + Term;
  elif (KindTerm == R_MON)
    m = m + Term;
    while ((m < 1) OR (m > 12))
      if (m < 1)
        m = m + 12;
        y = y - 1;
      elif (m > 12)
        m = m - 12;
        y = y + 1;
      end;
    end;
    while (d > LastDay(m,y))
      d = d - 1;
    end;
    ResDate = Date(d,m,y);
  end;
  return ResDate;
end;

/***********************************************************
        Обработка договоров
***********************************************************/

macro MayGetPercentSr
/*
  Можно ли снимать проценты по срочному договору
  Возврат:
    TRUE - можно
*/
  var stat = FALSE;
  var EndDate;
  var dEnd, mEnd, yEnd;

  if( DEPOSITR.End_DateDep == Date( 0, 0, 0 ) )
    EndDate = SumDate(DEPOSITR.Start_DateDep,DEPOSITR.Term,DEPOSITR.KindTerm);
    DateSplit (EndDate,dEnd,mEnd,yEnd);
    if( DEPOSITR.KindTerm == R_MON )     /* Срочные обязаны долежать */
      dEnd = 1;                          /* до конца периода         */
      mEnd = mEnd + 1;
      if (mEnd > 12)
        mEnd = 1;
        yEnd = yEnd + 1;
      end;
      EndDate = Date (dEnd,mEnd,yEnd) - 1;
    elif (DEPOSITR.KindTerm == R_QW)
      dEnd = 1;
      if (mEnd <= 3)
        mEnd = 4;
      elif (mEnd <= 6)
        mEnd = 7;
      elif (mEnd <= 9)
        mEnd = 10;
      else
        mEnd = 1;
        yEnd = yEnd + 1;
      end;
      EndDate = Date (dEnd,mEnd,yEnd) - 1;
    elif (DEPOSITR.KindTerm == R_YEAR)
      dEnd = 1;
      mEnd = 1;
      yEnd = yEnd + 1;
      EndDate = Date (dEnd,mEnd,yEnd) - 1;
    end;
    Global_EndDate = EndDate;
    if (DateConvert > EndDate)
      stat = TRUE;
    else
      stat = FALSE;
    end;
  else
    stat = FALSE;
  end;
  return stat;
end;
/***********************************************************
     После 1.1.1998- деноминация (деление сумм на 1000)
***********************************************************/

macro DenomSum
(
 Sum,           /* Деноминируемая сумма */
 DateDoc,       /* Дата документа       */
 TypeOper       /* Тип операции         */
)
/*
  Макрос взят 8.1.98 из goto98 системы RS-Bank 4.3
*/
  var SumDen;
  if ((DateDoc < DateDen) AND (TypeOper != OP_DENOM))
    if (Sum < 0)
      SumDen = -MoneyL (Floor (DoubleL (-Sum)/1000 + 0.5));
    else
      SumDen = MoneyL (Floor (DoubleL (Sum)/1000 + 0.5));
    end;
  else
    SumDen = Sum;
  end;
  return SumDen;
end;
/*********************************************************/

macro NeedControlTerm
(
 LarosIdent
)
/*
  Возврат:
    TRUE  - Необходимо проверять срок договора
    FALSE - Не надо проверять срок договора
*/
  var stat;
  var Iskl = ""; /*"ШРН";*/

  if( Index( Iskl, LarosIdent ) )
    stat = True;
  else
    stat = False;
  end;
  return stat;
end;

/**********************************************************/

macro WorkWithDate
(
 Cur_Date,      /* Дата, от которой идет расчет (текущая) */
 Graf,          /* Стратегия расчета (оплаты) */
 Day,           /* День расчета (если стратегия- заданного числа каждого месяца */
 GrafDate       /* Выход- дата следующего расчета (оплаты) */
)
/*
  Определение даты текущего расчета (оплаты) процентов
*/
  var stat = TRUE;
  var d,m,y;
  var d1,m1,y1;


  DateSplit( Cur_Date, d, m, y );
  GrafDate = Date(0,0,0);
  if (Graf == 1)        /* В конце дня  */
    GrafDate = Cur_Date;
  elif (Graf == 2)      /* В конце месяца */
    DateSplit( Cur_Date + 1, d1, m1, y1 );
    if( m == m1 )
       if( m == 12 )
         m = 1;
         y = y + 1;
       else
         m = m + 1;
       end;
       GrafDate = Date( 1, m, y ) - 1;
    else/* После увеличения даты на единицу перешли через месяц.
           Дата конвертации - это дата следующего расчета */
       GrafDate = Cur_Date;
    end;
  elif (Graf == 3)      /* В конце квартала     */
    if (m > 9)
      m = 1;
      y = y + 1;
    elif (m > 6)
      m = 10;
    elif (m > 3)
      m = 7;
    else
      m = 4
    end;
    GrafDate = Date(1,m,y) - 1;
  elif (Graf == 4)      /* В конце года */
    GrafDate = Date(31,12,y);
  elif (Graf == 5)      /* Day числа каждого месяца */
    if (Day > 0)
      if (d > Day)
        m = m + 1;
        if (m > 12)
          m = 1;
          y = y + 1;
        end;
      end;
      GrafDate = Date(Day,m,y);
    end;
  end;
  SetParm (3,GrafDate);
  return stat;
end;

/**********************************************************/
macro WorkWithDateBack
(
 Cur_Date,      /* Дата, от которой идет расчет (текущая) */
 Graf,          /* Стратегия расчета (оплаты) */
 Day,           /* День расчета (если стратегия- заданного числа каждого месяца */
 GrafDate       /* Выход- дата предыдущего расчета (оплаты) */
)
/*
  Определение даты текущего расчета (оплаты) процентов
*/
  var stat = TRUE;
  var d,m,y;

  DateSplit (Cur_Date,d,m,y);
  GrafDate = Date(0,0,0);
  if (Graf == 1)        /* В конце дня  */
    GrafDate = Cur_Date - 1;
  elif (Graf == 2)      /* В конце месяца */
    GrafDate = Date( 1, m, y ) - 1;
  elif (Graf == 3)      /* В конце квартала     */
    if  ( m <  4 )
      m = 1;
    elif( m <  7 )
      m = 4;
    elif( m < 10 )
      m = 7;
    elif( m > 10 )
      m = 10;
    end;
    GrafDate = Date(1,m,y) - 1;
  elif (Graf == 4)      /* В конце года */
    GrafDate = Date( 31, 12, y-1);
  elif (Graf == 5)      /* Day числа каждого месяца */
    if (Day > 0)
      if (d < Day)
        m = m - 1;
        if (m < 1)
          m = 12;
          y = y - 1;
        end;
      end;
      GrafDate = Date(Day,m,y);
    end;
  end;

  SetParm (3,GrafDate);
  return stat;
end;

/*********************************************************/
macro GetDEPOSITR_Cycle_Key4 (Num, FNcash)
/*
  Организация цикла по счетам
*/
  var stat;
  if (Num == 0)
    KeyNum (DEPOSITR,4);
    DEPOSITR.FNcash     = FNcash;
    DEPOSITR.NumSession = 0;
    stat = GetGE (DEPOSITR);
  else
    stat = Next (DEPOSITR);
  end;
  if (stat)
    stat = (DEPOSITR.FNcash == FNcash);
  end;
  return stat;
end;

/***********************************************************
     Алгоритмы операций
***********************************************************/

macro GetAlgOp
(
 Type_Account,  /* Вид вклада   */
 NumOper,       /* Номер операции */
 NumStep,       /* Номер шага операции */
 BegDate       /* Дата, начала действия шага
                     нулевая - поиск первой записи
                     определенная- поиск от конца */
)
/*
  Получение строки файла алгоритмов операций
*/
  var stat;

  KeyNum( SB_ALGOP, 0 );
  SB_ALGOP.IsCur      = depositr.IsCur;
  SB_ALGOP.Kind       = depositr.Type_Account;
  SB_ALGOP.NumOpert   = NumOper;
  SB_ALGOP.NumStepAlg = NumStep;
  SB_ALGOP.BegDate    = BegDate;
  if (BegDate == Date(0,0,0))
    stat = GetGE (SB_ALGOP);
  else
    stat = GetLE (SB_ALGOP);
  end;
  if (stat)
    stat = ((SB_ALGOP.IsCur      == depositr.FlagCur      ) AND
            (SB_ALGOP.Kind       == depositr.Type_Account ) AND
            (SB_ALGOP.NumOpert   == NumOper               ) AND
            (SB_ALGOP.NumStepAlg == NumStep               )    );
  end;
  return stat;
end;
/*********************************************************/

macro GetAlgOpStep265
(
                /* ВХОД */
 Type_Account,  /* Вид вклада   */
 NumOper,       /* Номер операции */
 BegDate,       /* Дата, начала действия шага
                     нулевая - поиск первой записи
                     определенная- поиск от конца */
                /* ВЫХОД  */
 ForDay,        /* Учет дня операции:
                       0 - текущим днем
                       1 - предыдущим днем
                       2 - следующим днем */
 ForCompens     /* "X" - компенсировать приход */
)
/*
  Получение параметров заданной операции для шага 265
  (Учет дня операции)

  Возврат:
    True - запись найдена
    False - запись не найдена в файле описания алгоритмов операций
            или шаг не активен
*/
  var stat;
  var ForDay_     = 0,
      ForCompens_ = "";

  stat = GetAlgOp (Type_Account,NumOper,265,BegDate);
  if (stat)
    if (SB_ALGOP.FlagEXE == "X")
      ForDay_ = SB_ALGOP.prmI2;
      ForCompens_ = SB_ALGOP.prmC;
    else
      stat = False; /* Шаг алгоритма не активен */
    end;
  end;
  SetParm (3,ForDay_);
  SetParm (4,ForCompens_);
  return stat;
end;

/**********************************************************/
macro GetResid (Nbals)
/*
  По номеру балансового счета определяем тип пользователя:
  резидент\не резидент

  Возврат:
    0 - резидент
    1 - не резидент
*/
  var Resid;

  /*If(Int(Nbals) < 42400)*/
  if( SubStr( Nbals, 1, 3) != "426" )
    Resid = 0;
  else
    Resid = 1;
  end;
  return Resid;
end;

/***********************************************************/
macro GetPc_ALgRec( IsCur, ApType, BegDate )
   var stat  = True;
   var Found = False;

   keynum     ( pc_alg, 0 );
   ClearRecord( pc_alg    );
   rewind     ( pc_alg    );

   pc_alg.FlagCur    = IsCur;
   pc_alg.Referenc   = ApType;
   pc_alg.ObjectType = 1003;
   pc_alg.BegDate    = VeryBigDate;

   stat = GetLE( pc_alg );
   while( stat and ( pc_alg.FlagCur    == IsCur    ) and
                   ( pc_alg.Referenc   == ApType   ) and
                   ( pc_alg.ObjectType == 1003     )     )

      if( pc_alg.BegDate <= BegDate )
         Found = True;
      end;
      if( not Found ) stat = prev( pc_alg );
      else            stat = False;
      end;
   end;

   return Found;
end;

/***********************************************************/
macro GetPC_ALG( IsCur, Type_Account, Type_Object, BegDate )
   var stat  = True;
   var Found = False;

   keynum     ( pc_apltp, 0 );
   ClearRecord( pc_apltp    );
   rewind     ( pc_apltp    );

   pc_apltp.IsCur   = IsCur;
   pc_apltp.TypeRec = 1003;
   pc_apltp.Type    = Type_Account;

   stat = GetGE( pc_apltp );

   while( stat and ( pc_apltp.IsCur   == IsCur         ) and
                   ( pc_apltp.TypeRec == 1003          ) and
                   ( pc_apltp.Type    == Type_Account  )     )
      if( pc_apltp.ApplType == Type_Object )
         Found = True;
      end;
      if ( not Found ) stat = next( pc_apltp );
      else             stat = False;
      end;
   end;

   /* Ищем алгоритм рачета для заданного условия */
   if( Found )
      stat = GetPc_ALgRec( IsCur, pc_apltp.ApType, BegDate );
   end;
   /*MsgBox( stat, " ", pc_alg.Referenc, pc_alg.RestUseType );*/

   return stat;
end;

/***********************************************************
***********************************************************/
macro GetPC_APLTP
(
 IsCur,
 Type_Account,
 Num
)
/*
  Следующая строка PC_APLTP
*/
  var stat;
  if (Num == 0)
     keynum     ( pc_apltp, 0 );
     ClearRecord( pc_apltp    );
     rewind     ( pc_apltp    );

     pc_apltp.IsCur   = IsCur;
     pc_apltp.TypeRec = 1003;
     pc_apltp.Type    = Type_Account;

     stat = GetGE( pc_apltp );
  else
    stat = Next( PC_APLTP );
  end;
  if (stat)
    stat = ( ( PC_APLTP.IsCur == IsCur        ) AND
             ( PC_APLTP.Type  == Type_Account )     );
  end;
  return stat;
end;

macro MakeTxtStr( Arr )
   const Delim = "|";

   var i   = 0;
   var Str = "";

   /*Str = Str + Delim;*/
   while( i < Asize( Arr ) )
      Str = Str + String( Arr( i ) ) + Delim;
      i = i + 1;
   end;

   return Str;
end;

/* Поиск следующего номера сессии выгрузки */
/* Исправлено Головановым В.В.             */
macro GetNumSessn( NumSesn )
   var stat     = True,
       FindStat = True;
   var NumSesn_ = 0;

   ClearRecord( fc_sesn    );
   Keynum     ( fc_sesn, 1 );
   Rewind     ( fc_sesn    );

   fc_sesn.FNCash  = Branch;
  /* fc_sesn.Sesdate = date();*/

   FindStat = GetGE( fc_sesn );
   while( FindStat and ( fc_sesn.FNCash == Branch ) /*and ( fc_sesn.Sesdate == date() )*/ )
      if( fc_sesn.NumSession > NumSesn_ )
         NumSesn_ = fc_sesn.NumSession;
      end;
      FindStat = Next( fc_sesn );
   end;
   NumSesn_ = NumSesn_ + 1;

   NumSesn = SetZeroToSpace( String( NumSesn_ : 4 ) );
   SetParm( 0, NumSesn );

   return stat;
end;

/*Исправлено Головановым В.В.*/
macro CheckKindSbereg()
   var st = False;
   var Dop, Mop, Yop;

   if( ( depositr.Type_Account == KindMoscow ) or IsKindSbereg( depositr.Type_Account ) )

      if( ( Trim( FLAROS.OPER )  == "210"       ) and
          ( FLAROS.DATAV == ( BegLockDate - 1 ) )     )
         st = True;
      end;
   end;

   return st;
end;

/*=========================== Процедуры валюты ===================================*/

/***********************************************************************
       Определение вида вклада в Retail по виду вклада в Ларос
***********************************************************************/

/* "Интерсные" виды вкладов */
const KindSpecial    = "ОСОБЫЙ";
const KindSpecialNum = "Особый номер";

/***********************************************************************
                       Работа с видами вкладов
***********************************************************************/
macro GroupKindInLaros_cur
(
 LarosIdent /* Поле VIDVKL файла fNN.dbf */
)

  Array Group;
  Group(1)  = "09";   /* Нет сведений о дате конца договоре         */
  /*Group(2)  = "1367АПИЮФТВД"; /* Дата конца договора, кроме срочного c еж % */*/
  Group(2)  = "1367АCИЮФТВД"; /* Дата конца договора, кроме срочного c еж % */
  var NumGr = 0;
  var i     = 1;
  var Cont  = TRUE;

  while ((i<Asize(Group)) AND Cont)
    if (Index(Group(i),LarosIdent) > 0)
      Cont = FALSE;
      NumGr = i;
    end;
    i = i + 1;
  end;

  return NumGr;

end;

/* Определение валютного вида вклада */
macro GetRsKindForLaros_currency
(
 LarosIdent, /* Вход  - идентификатор в Laros (поле VIDVKL файла fNN.dbf) */
 Dop,        /* Вход  - срок договора                                     */
 DateO,      /* Вход  - дата открытия счета                               */
 RsKind      /* Выход - тип вклада в RS-Retail                            */
)
/*
  Возврат
   TRUE  -  определено
   FALSE - не определено
*/
  var RsKind_ = "",
      Stat = TRUE;

  if (LarosIdent == "1")
    RsKind_ = "СРОЧНЫЙ";
  elif (LarosIdent == "3")
    if (DateO <= Date(5,5,1997))
      if (Dop == 3)
        RsKind_ = "СР.ДЕП. 3 М.";
      elif (Dop == 6)
        RsKind_ = "СР.ДЕП. 6 М.";
      elif (Dop == 9)
        RsKind_ = "СР.ДЕП. 9 М.";
      elif (Dop == 12)
        RsKind_ = "СР. ДЕП.12М.";
      else
        stat = FALSE;
      end;
    else
      if (Dop == 3)
        RsKind_ = "СР. ДЕП. 3МП";
      elif (Dop == 6)
        RsKind_ = "СР. ДЕП. 6МП";
      elif (Dop == 9)
        RsKind_ = "СР. ДЕП. 9МП";
      elif (Dop == 12)
        RsKind_ = "СР. ДЕП.12МП";
      else
        stat = FALSE;
      end;
    end;
  elif (LarosIdent == "0")
      RsKind_ = "до востреб.";
  elif (LarosIdent == "6")
    RsKind_ = "Целевой на д" ;
  elif (LarosIdent == "9")
    RsKind_ = "СРОЧНЫЙ С ЕЖ";
  elif (LarosIdent == "7")
    RsKind_ = "Ср.с доп.взн";
/*
  elif (LarosIdent == "C")
    RsKind_ = "VISA Classic";
  elif (LarosIdent == "P")
    RsKind_ = "VISA Gold Re";
  elif (LarosIdent == "B")
    RsKind_ = "V-Gold Привл";
  elif (LarosIdent == "С")
    RsKind_ = "Рез/деп V-Cl" ;
  elif (LarosIdent == "Р")
    RsKind_ = "Рез/деп V-Go";
*/
  elif (LarosIdent == "А")
    RsKind_ = "ОСОБЫЙ";
  /* RA 13.12.99  Для Костроимы изменил опеределение Пополняемых */
  elif (LarosIdent == "С")
    if (Dop == 3)
      RsKind_ = "Пополн.на 3М";
    elif (Dop == 6)
      RsKind_ = "Пополн.на 6М";
    else
      stat = FALSE;
    end;
/*
  elif (LarosIdent == "П")
    if (Dop == 3)
      RsKind_ = "Пополн.на 3М";
    elif (Dop == 6)
      RsKind_ = "Пополн.на 6М";
    else
      stat = FALSE;
    end;
*/
  elif (LarosIdent == "Ю")
    RsKind_ = "СБ- 100 дней";
  elif (LarosIdent == "И")
    RsKind_ = "СБ-60 дней";
  elif (LarosIdent == "Т") /* RA 16.11.98 Добавлен вклад "СБ-30 дней"*/
    RsKind_ = "СБ-30 дней";
  elif (LarosIdent == "В") /* RA 16.11.98 Добавлен вклад "Новогдний" и "Новогодний Плюс" */
    RsKind_ = "НОВОГОДНИЙ_";
  elif (LarosIdent == "Д")
    RsKind_ = "НОВОГОДНИЙ +";
  elif (LarosIdent == "Ф")
    if (Dop == 3)
      RSKind_ = "Особый номер";
    elif (Dop == 0)
      RSKind_ = "Особ.н.1г_1м";
    else
      Stat = FALSE;
    end;
  elif (LarosIdent == "Ц")
    RSKind_ = "до востреб.";
/*    RSKind_ = "ссуда без %";*/
  else
    Stat = FALSE;
  end;

  SetParm (3,RsKind_);

  return Stat;

end;

/***********************************************************************
             Разбивка номера счета Ларос на составляющие
***********************************************************************/
macro GetTypeAccountInLaros_currency
(
 Acc,    /* Вход  - Счет Laros  (STRING)  */
 Nbal,   /* Выход - балансовый счет       */
 Cur,    /* Выход - код валюты (INTEGER) */
 NNNNN   /* Номер счета        (INTEGER) */
)
/*
  Структура номера счета:
    БББББ ВВВ К ОООО ННННННН ТТ

      БББББ   - номер балансового счета (например 42301)
      ВВВ     - код валюты (например 280 или 840)
      К       - ключ
      ОООО    - код отделения
      ННННННН - номер счета
      ТТ      - тип счета
*/
  var Ident;

  Ident = SubStr (Trim(Acc),21,2);
  Nbal  = Int( SubStr( Trim( Acc ),  1, 5 ) );
  Cur   = Int( SubStr( Trim( Acc ),  6, 3 ) );
  NNNNN = Int( SubStr( Trim( Acc ), 14, 7 ) );

  SetParm( 1, Nbal  );
  SetParm( 2, Cur   );
  SetParm( 3, NNNNN );

  return Ident;

end;

/* Получение кода валюты */
macro GetRealCurrency( Curr )
   var stat = True;

   keynum( currency, 1 );
   currency.ExternalCode = Curr;
   if( GetEQ( currency ) )
      DEPOSITR.Code_Currency = currency.Code_Currency ;
   else
      stat = False;
      Protocol.Error( "Не найдены данные о валюте с кодом ", Curr );
   end;

   return stat;
end;

/***********************************************************************
                  Определение группы вида вклада
***********************************************************************/
macro GroupOperInLaros_currency
(
 LarosIdent /* Из поля номер счета п.21-22 */
)
/*
  Определение, к какой группе по размещению данных в полях
  процентов (файлы операций) базы Laros принадлежит вид вклада
  (по Laros) (строка за 01.01 с операцией "206" или "000")
  --------------------------------------------------------------------
  Группа | SUMMA               | OSTAT             | OPROC
  --------------------------------------------------------------------
  Срочные
      1   % за прошлый год      остаток + SUMMA        % к выдаче
  Депозиты
      2   % за прошлый год      остаток на дату начала % к выдаче
                                договора/пролонгации
                                + SUMMA
  До востребования
      3   % за прошлый год      остаток                  0
                                + SUMMA
  С ежем. начис. %
      4   % за прошлый мес.     остаток                % к выдаче
                                + SUMMA
  Детский
      5   % за прошлый год      Остаток на 31.12.97     % без нарушения
                                                                (oper = 206)
                                                        % с нарушением
                                                                (oper =   1)
  Срочный с доп. взн. ( хранится вся история )
      6   % за прошлый год     остаток на 31.12.97       0
                               + SUMMA
  Карт.  VISA
      7   % за прошлый год=     остаток  на 31.12.97     0
         сумме % по кварталам   + SUMMA
  VISA (стр.депозит)
      8    % за прошлый год      остаток  на 31.12.97     0
                         НЕ ОБРАБОТАНО
  ОСОБЫЙ
      9
  Пополняемый
     10

  -----------------------------------------------------------------------
*/
  Array Group;
  Group( 1) = "21";      /* Срочный                                 */
  Group( 2) = "12";  /* Депозиты 3,6,9,12 с прол. и без         */
  Group( 3) = "01/40";      /* До востребования                        */
  Group( 4) = "04/33";   /* Срочный с ежемесячным и Особый номерной */
  Group( 5) = "23";      /* Целевой на детей                        */
  Group( 6) = "19";      /* Срочный с дополнительными взносами      */
  Group( 7) = "??";      /* VISA Classic и Gold                     */
  Group( 8) = "??";      /* Страховой депозит VISA                  */
/*  Group( 9) = "30";      /* Особый                                  */
  Group(10) = "29";      /* Пополняемый 3 и 6                       */*/
  Group(11) = "32/13/29/30";  /* СБ-60 и СБ-100 и Новогодний и Новогод + */

  var NumGr = 0;
  var i     = 1;
  var Cont  = TRUE;

  while ((i<Asize(Group)) AND Cont)
    if (Index(Group(i),LarosIdent) > 0)
      Cont = FALSE;
      NumGr = i;
    end;
    i = i + 1;
  end;

  return NumGr;

end;

/***********************************************************************
                     Получить срок договора
***********************************************************************/
MACRO GetLengthDep
(
 date1,
 date2
)

  var i;
  var Srok = 0;

  i = date2 - date1;

  if ((i > 25) AND (i < 35))
    Srok = 1;
  elif ((i > 55) AND (i < 65))
    Srok = 2;
  elif ((i > 85) AND (i < 95))
    Srok = 3;
  elif ((i > 115) AND (i < 125))
    Srok = 4;
  elif ((i > 145) AND (i < 156))
    Srok = 5;
  elif ((i > 175) AND (i < 188))
    Srok = 6;
  elif ((i > 205) AND (i < 218))
    Srok = 7;
  elif ((i > 235) AND (i < 248))
    Srok = 8;
  elif ((i > 265) AND (i < 279))
    Srok = 9;
  elif ((i > 295) AND (i < 308))
    Srok = 10;
  elif ((i > 325) AND (i < 338))
    Srok = 11;
  elif ((i > 355) AND (i < 370))
    Srok = 12;
  end;

  return Srok;

end;

/***********************************************************************
               Получить дату начала следующего квартала
***********************************************************************/
macro GetLengthQuarter
(
 date1
)

  var RetDate,length,mon,mon1,f_year,f_day;

  DateSplit(date1,f_day,mon,f_year);

  if (mon >= 10)
   length = 1;
   f_year = f_year + 1;
  elif (mon >= 7)
   length = 10 ;
  elif (mon >= 4)
   length = 7 ;
  elif (mon >= 1)
   length = 4 ;
  end;

  RetDate = Date (1,length,f_year) ;

  return RetDate;

end;

/* Определение номера элемента массива */
macro NumElemInArr (Elem, Arr)
   var size = Asize (Arr), 
       n = 0,
       Num = -1;
   while (n < size)
      if (Trim (Elem) == Trim (Arr(n)))
         Num = n;
      end;
      n = n + 1;
   end;
   return Num;
end;
