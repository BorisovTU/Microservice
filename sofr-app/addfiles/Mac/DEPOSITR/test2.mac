/* Тест на правильность ведения счетов вкладчиков (depositr).
   ∙ Наличие в БД открытых счетов с нулевым остатком;
   ∙ Наличие в БД закрытых счетов с ненулевым остатком;
   ∙ Наличие в БД счетов, по которым дата очередной пролонгации не равна
     дата прошлой пролонгации + срок договора.
   Автор Зубов В. 24-03-98
*/
import deprintr, opercode, acc_form;
/*- Блок констант --------------------------------------------------------*/
const
  D_DELETE        = 2,
  NullDate        = Date(0,0,0),
  Откр_наличными  = 1,     /* Номер операции "Открытие наличными" */
  Огр_на_сум_прих = 240;   /* Номер шага алгоритма "Ограничение на сумму прихода */

/*- Объявление переменных ------------------------------------------------*/
file dr(depositr);
file ao(sb_algop);  /* Описания алгоритма операции */
file sb_dtyp (sb_dtyp) key 2;

Var found, count;
Var retVal = true;

macro IsServDr()
  return ( dr.Action == D_DELETE);
end; /* orcam */

macro PrintDrInfo()
  [ По счету       Referenc:###############   Account:#
    Cur:### Фил:## Type_Account:############  CodClient:########]
  (dr.Referenc, Acc_Form(dr.Account):f,
   dr.Code_Currency, dr.FNCash, dr.Type_Account, dr.CodClient);
end; /*orcam*/

macro PrintSeparator()
 [-------------------------------------------];
end; /*orcam*/

macro GetNextDepositr()
Var f;
  f = Next(dr);
  UseProgress(count);
  count = count + 1;
  while (f and IsServDr())
    f = Next(dr);
    UseProgress(count);
    count = count + 1;
  end; /* elihw */
  if (not f)
    RemProgress();
  end;
  return f;
end; /*orcam*/

macro GetFirstDepositr()
Var ff;
  InitProgress(Nrecords(dr),"Проверка правильности ведения счетов");
  count = 0;
  KeyNum(dr, 8);
  Rewind(dr);
  dr.Referenc = "";
  ff = GetGE(dr);
  While (ff AND IsServDr())
     GetNextDepositr();
  end; /* elihw */
  return ff;
end; /*orcam*/

macro CheckDepositr()
Var WasError = False, TmpDate, readAO;
var MayBeZeroRest = FALSE;

  if ( (dr.Open_Close == "") AND (dr.Sum_Rest == $0L))
    MayBeZeroRest = FALSE;
    sb_dtyp.FlagCur = dr.IsCur;
    sb_dtyp.Kind    = dr.Type_Account;
    if (GetEQ(sb_dtyp))
      if (sb_dtyp.MayBeZeroRest != "")
        MayBeZeroRest = TRUE;
      end;
    end;
    if (Index(dr.UserTypeAccount,"О") != 0)
      MayBeZeroRest = TRUE;
    end;
    if (NOT MayBeZeroRest)
      [Ошибка: Нулевой остаток по открытому счету];
      WasError = True;
    end;
  end; /* fi */

  if ( (dr.Open_Close == "З") AND (dr.Sum_Rest != $0L))
    [Ошибка: Ненулевой остаток по закрытому счету];
    WasError = True;
  end; /* fi */

  /* Чтение записи описания алгоритма операции */
  ao.IsCur      = dr.IsCur;
  ao.Kind       = dr.Type_Account;
  ao.NumOpert   = Откр_наличными;
  ao.NumStepAlg = Огр_на_сум_прих;
  ao.BegDate    = NullDate;
  readAO        = getGE( ao );
  if ( readAO                                  AND
       ( ( ao.IsCur      != dr.IsCur        )  OR
         ( ao.Kind       != dr.Type_Account )  OR
         ( ao.NumOpert   != Откр_наличными  )  OR
         ( ao.NumStepAlg != Огр_на_сум_прих ) ) )
    readAO = FALSE;
  end;

  if ( ( NOT readAO )  OR  ao.ModuleNumber == 0 )
  /* Если задан макрос шага алгоритма, то пропускаем проверку - SCR # 3629 */
    if ( dr.End_DateDep != NullDate)
      if ( dr.Prol_DateDep != NullDate)
         GetDateOff( dr.Prol_DateDep - 1 , dr.KindTerm_Prol,
                     dr.Term_Prol, TmpDate );

      else
         GetDateOff( dr.Start_DateDep, dr.KindTerm,
                     dr.Term, TmpDate );
      end; /* fi */
      if (TmpDate != dr.End_DateDep)
        [Дата пролонгации не равна дате начала договора + срок пролонгации];
        WasError = True;
      end; /* fi */
    end; /* fi*/
  end; /* fi*/

  if ( WasError )
    PrintDrInfo();
    PrintSeparator();
    retVal = false;
  end; /* fi */
end; /*arcam */

/*- Точка входа в макрос -------------------------------------------------*/
macro RunCheck(mode, addr)
/* Шаг 1. Проверяем все счета в DEPOSITR */
   [Тест на правильность ведения счетов вкладчиков];
   found = GetFirstDepositr();
   while(found)
     CheckDepositr();
     found = GetNextDepositr();
   end; /*elihw*/
   return retVal;
end; /*orcam*/
