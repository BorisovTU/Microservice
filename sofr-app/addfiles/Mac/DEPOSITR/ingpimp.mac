
// ************************************************************************
// *  Импорт цен слитков драгметаллов                                     *
// *  PRJ0011445 (ОМС)                                                    *
// ************************************************************************
      
import or_exl_h, rsd, globals, deprintr, rsexts;
                                                                    
// **********************************************************************//
//                  ГЛОБАЛЬНЫЕ ОПРЕДЕЛЕНИЯ И КОНСТАНТЫ                  //         
// **********************************************************************//

// Существующие в системе металлы (с большой буквы)
private var METALS = TArray;
            METALS(0) = "Золото";
            METALS(1) = "Серебро";
            METALS(2) = "Платина";
            METALS(3) = "Палладий"; 

// Константы видов металлов
private const MTL_GOLD   = 0,
              MTL_SILVER  = 1,
              MTL_PLATIMUN  = 2,
              MTL_PALLADIUM  = 3;

// Виды качества слитков
private const QLT_EXCELLENT  = 0, 
              QLT_TOLERABLE  = 10;        

// Константы, относ. к разбираемым элементам
private const PRS_ERR         = 0;
private const PRS_OK          = 1;
private const PRS_QUALITY     = 2;
private const PRS_METAL       = 3;
private const PRS_INGOTRATE   = 4;

// Сообщения
private const MSG_BOX           = "Исходные данные не соответствуют формату. Ошибка импорта в строке № ";
private const MSG_REP           = "Исходные данные не соответствуют формату.";
private const MSG_EMPTYFILE     = "Отсутствуют данные для импорта. Выберите другой файл";
private const MSG_NOFILE        = "Указанный файл не существует.";
private const MSG_NOXLSTEMPLATE = "Обрабатываемый документ должен быть Exсel файлом.";
private const MSG_INVALIDDATE   = "Дата установки курса должна быть больше 01.01.2001. Установите правильную дату.";

// Поля панели импорта настроек
private const F_DATE  = 0,
              F_TIME  = 1,
        F_FILE_NAME = 2,
              F_UPDATE_CHBOX = 3;

// Коды клавиш
private const K_SPACE = 32,
              K_F3    = 317,
              K_F2    = 316; 

private const REPORT_FILE = "..\\txtfile\\ingpimp.txt";
private const TEMPLATE_FILE = "*.xls";

private var xls : CDAOMSExcel = CDAOMSExcel();
private var top,                // номер строки левой верхней ячейки таблицы
     left,               // номер колонки левой верхней ячейки таблицы
            rows,               // кол-во строк в таблице
            columns : integer;  // кол-во колонок в таблице  
 

// Запись, выводимая в отчете
// Если weight = 0, тогда в name содержится информация об ошибке
CLASS IngotRate   ( _weight, 
                    _name,                    
                    _lineNum   
                  )
   var metal,  
       quality,
       name        = _name, 
       weight      = _weight, 
       hlmarkMin,
       hlmarkMax,
       buyPrice,
       sellPrice,
       nds,
       ndsPrice,
       ndsIncluded,
       boxed,
       lineNum     = _lineNum,
       hlmark;                 //проба, выводимая в отчет    
END;   

//**********************************************************************//



             
//**********************************************************************//
//                     ФУНКЦИИ - УТИЛИТЫ                                //         
//**********************************************************************//

// Разбивает str на подстроки, используя в качестве разделителя delim
MACRO SubStrings( str, delim : string ) : TArray
    var i = 0, counter = 0;
    var subs = TArray;
    
    while ( ( i = Index( str, delim ) ) != 0 )
       subs(counter) = SubStr( str, 1, i - 1 );  
       str = SubStr( str, i + 1 );
       counter = counter + 1;
    end;
    
    subs(counter) = str;    
     
    return subs;
END;

// Является ли строка числом ноль в строковом представлении
MACRO ZeroString( str : string ) : bool    
    var ret = true, i = 0;
    array letters;
    asize( letters, strlen(str) );
    StrSplit( str, letters, 1 );

    while ( i < strlen( str ) )
        if ( not ( (letters(i) == "0") or (letters(i) == ".") or (letters(i) == ",")) )
            ret = false;
            i = strlen( str ); 
        end; 
        i = i + 1;    
    end;    
    
    if ( strlen(Str) == 0 )
        ret = false;
    end;
        
    return ret;
END;

// Конвертирует in в тип T и зыписывает результат в out
// T = { V_INTEGER, V_DOUBLE, V_STRING }
MACRO ConvertTo( in, out : variant, T : integer ) : bool
    
    var ret  : bool, 
        prev : variant;
    ret = false;    
    
    if ( ValType( in ) != V_UNDEF )       

       prev = in;
       ret = true;              

       if ( T == V_INTEGER )
           out = int( in );
       elif ( T == V_DOUBLE )
           if (index(in, ",") > 0)
               in = strsubst(in,",",".")
           end;
           out = double( in );          
       elif ( T == V_STRING )
            out = string( in );          
       end;
       
       // Т.К. предыдущие пресловутые преобразования возвращают ноль в случае неудачи,
       // проверяем то, что входной параметр был нулем
       if ( out == 0 )
           if ( ValType( in ) == V_STRING )
               if ( not ZeroString(prev) ) 
                   ret = false;                
               end; 
           else
               if ( (prev != 0 ) )
                   ret = false;                
               end;
           end;           
       end;       
  
    end;

    if ( ret)
        SetParm( 1, out );        
    end;                    

    return ret;       
END;  


// Функция обертка для xls.GetVariant()
// Получает значение ячейки и приводит к типу T(если он указан)
// если привести не удалось, возвращает V_UNDEF
// T = { V_INTEGER, V_DOUBLE, V_STRING }
MACRO GetValue( line,
                col,
                T : integer                 
              ) : variant
    
    var val;    

    if ( ValType( T ) == V_UNDEF )
        val = xls.GetVariant( line, col );        
    else
        val = xls.GetValue( line, col );

        if ( ValType( val ) != T )  
            if ( not ConvertTo ( val, val, T ) )
                val = null;            
            end; 
        end; 
    end;     

    return val;
    // Решает след. проблему: если GetVariant читает пустую ячейку с форматом "Числовой", 
    // тогда вылетает ошибка приведения типов.
    // В подобном случае функция просто возвращает UNDEFINED
    onerror
        return null; 
END;


MACRO IsCellEmpty( line,
                   col : integer        
                 ) : bool
    return (strlen(xls.GetValue( line, col )) == 0); 
END;


// Выводит сообщение об ошибке и формирует пустой объект IngotRate
MACRO RaiseError ( msg,               // сообщение, выводимое в MsgBox'e
                   str : string,      // сообщение, выводимое в отчете
                   lineNum :integer   // строка, в которой произошла обшибка
                 ) : IngotRate
    MsgBox( msg );   
    return IngotRate( 0, str, lineNum );
END;

//**********************************************************************//




//**********************************************************************//
//                     ФУНКЦИИ ИМПОРТА ЦЕН СЛИТКОВ                      //         
//**********************************************************************//
   
// Получить левую верхнюю ячейку таблицы, количество строк и столбцов
// возвращает true, если страница не пустая
MACRO getTableCoords() : bool
    
    var ret = false, i = 0;
              
    // считаем, что таблица ВСЕГДА начинается в первой колонке первой страницы
    rows = xls.Application.ActiveSheet.UsedRange.Rows.Count;
    columns = xls.Application.ActiveSheet.UsedRange.Columns.Count;    
    top = xls.Application.ActiveSheet.UsedRange.Row - 1;
    left = 0; 

    if ( ValType( GetValue( top, 0 ) ) != V_UNDEF )       
            ret = true;      
    end;

    return ret; 

END;   

 
// Проверяет строку на соответств. формату "#НОМЕР. слитки #КАЧЕСТВО состояние" (например, "1. слитки отличного состояния" ) 
MACRO IsIngotQualityString( str     : string, 
                            quality : integer ) : integer
    
    var subs = TArray;        
          
    str = Trim( str );
    str = StrLwr ( str );
               
    subs = SubStrings( str, " " );

    if ( subs.Size < 4 )
        return PRS_ERR;
    end;
        
    // удаляем (если есть) точку в первом элементе 
    if ( Index( subs(0), "." ) != 0 )
        subs(0) = SubStr( subs(0), 1, StrLen( subs(0) ) - 1 );               
    end;
                                                            
    // производим разбор
    if ( (int( subs(0) ) == 0) or ( subs(1) != "слитки" ) ) 
        return PRS_ERR;
    end;
               
    if ( subs(2) == "отличного" ) 
        SetParm(1, QLT_EXCELLENT );
    elif ( subs(2) == "удовлетворительного" )
        SetParm(1, QLT_TOLERABLE );
    else 
        return PRS_ERR;
    end;
        
    if ( subs(3) != "состояния" ) 
        return PRS_ERR;
    end;
            
    return PRS_OK;
END; 


// Проверяет строку на соответств. формату "#Met #Box" 
MACRO IsMetalNameString( str   : string, 
                         metal : integer,
                         boxed : bool ) : integer
    var subs = TArray,
        ret;        
        
    str = Trim( str );
    str = StrLwr ( str );
               
    subs = SubStrings( str, " " );    
    SetParm( 2, false );
        
    var i = 0;
    ret = PRS_ERR;
    while ( i < METALS.Size )
        if ( subs(0) == StrLwr( METALS(i) ) )
            SetParm( 1, i );            
            i = METALS.Size;
            ret = PRS_OK; 
        end;
        i = i + 1;
    end;

    if ( (ret == PRS_OK) and (subs.Size > 1) )
        
        if ( (subs.Size == 3) and (subs(1) == "в") and (subs(2) == "футляре") )
            SetParm( 2, true );      
        else
            ret = PRS_ERR;
        end;
        
    end;
            
    return ret;
 
END;


// Получает параметры слитка и возвращает вес слитка,
// в случае ошибки возвращает PARSE_ERR
MACRO ParseIngotRate( lineNum : integer,     // строка файла, содержащ. инф. о слитке
               ingRt   : IngotRate    
                    ) : integer
    var val : variant;
    
    // получаем обязательные параметры
    ingRt.weight    = GetValue( lineNum, 0, V_INTEGER );
    ingRt.hlmarkMin = GetValue( lineNum, 1, V_STRING ); 
    ingRt.buyPrice  = GetValue( lineNum, 2, V_DOUBLE ); 
    
    if (    (ValType( ingRt.weight ) == V_UNDEF)
         or (ValType( ingRt.hlmarkMin ) == V_UNDEF) 
         or (ValType( ingRt.buyPrice ) == V_UNDEF)
       )
        return PRS_ERR;
    end;
    
    // получаем пробу
    var subs = TArray;
    ingRt.hlmarkMin = Trim( ingRt.hlmarkMin );
    ingRt.hlmarkMin = StrSubst( ingRt.hlmarkMin, ",", "." ); // чтобы корректно работало преобразование в double
    subs = SubStrings( ingRt.hlmarkMin, "-" );         
       
    if ( ConvertTo( subs(0), ingRt.hlmarkMin, V_DOUBLE ) )
       ingRt.hlmarkMax = ingRt.hlmarkMin;
       if ( (subs.Size == 2) and ( not ConvertTo( subs(1), ingRt.hlmarkMax, V_DOUBLE ) ) )
           return PRS_ERR;           
       end;  
    else
        return PRS_ERR;
    end;
    
    ingRt.sellPrice = GetValue( lineNum, 3, V_DOUBLE ); // проверить на несоответствие формата
    if ( ValType ( ingRt.sellPrice ) == V_UNDEF )
        if ( IsCellEmpty( lineNum, 3) )
            ingRt.sellPrice = 0.0;    
        else
            return PRS_ERR;
        end; 
    end;    
    
    ingRt.nds = GetValue( lineNum, 4, V_DOUBLE );
    if ( ValType ( ingRt.nds ) == V_UNDEF )
        if ( IsCellEmpty( lineNum, 4) )
            ingRt.nds = 0.0;    
        else
            return PRS_ERR;
        end; 
    end;

    ingRt.ndsPrice = GetValue( lineNum, 5, V_DOUBLE );
    if ( ValType ( ingRt.ndsPrice ) == V_UNDEF )
        if ( IsCellEmpty( lineNum, 5) )
            ingRt.ndsPrice = 0.0;    
        else
            return PRS_ERR;
        end; 
    end;

    SetParm( 1, ingRt );
        
    return PRS_OK;
END;
          

MACRO Parse( type, line, col, ret ) : integer
    var boxed;

    if ( type == PRS_QUALITY )
        if (   ( ValType( GetValue( line, col ) ) == V_STRING ) 
              and ( IsIngotQualityString( GetValue( line, col, V_STRING ), ret ) == PRS_OK ) )
             SetParm( 3, ret );
             return PRS_OK;
        end;
    end;

    if ( type == PRS_METAL )
       if ( (ValType( GetValue( line, col ) ) == V_STRING) 
            and ( IsMetalNameString( GetValue( line, col ), ret, boxed ) == PRS_OK ) )
           SetParm( 3, ret );
           SetParm( 4, boxed );
           return PRS_OK; 
       end;
    end;
    
    if ( type == PRS_INGOTRATE )
        if ( ParseIngotRate( line, ret ) == PRS_OK )
           SetParm( 3, ret );
           return PRS_OK; 
       end;
    end;
   
    return PRS_ERR;
END;  


// Находит код металла по его наименованию  
// Возвращает код
// Если ничего не найдено, возвращает 0
MACRO GetMetalCodeByName( metal : string ) : integer
    var cmd, rs, key = 0;
        
    cmd = RSDCommand( " select t_autokey " +
                      " from   dci_code_dbt " +
                      " where  t_group = 2 and t_string = :mtlName " );
    cmd.addParam( "mtlName", RSDBP_IN, metal );

    rs = RsdRecordSet( cmd );
    
    cmd.execute();

    if ( rs.moveNext() )
        key = rs.Value( "t_autokey" );
    end;
    
    return key;
END;  


// Находит слиток по указанным параметрам
// возвращает код слитка 
// Если ничего не найдено, возвращает 0
MACRO GetIngotByParams ( metalKey,
                         hallmarkMin,
                         hallmarkMax,
                         ingRt   : IngotRate
                       )
    var cmd, rs, issueid = 0, query;
    
    query = " select M.t_name, M.t_issueid, M.t_type, M.t_NDS_IsIncludedInCost, C.t_double " +
            " from   dci_misc_dbt M, dci_code_dbt C" +
            " where  M.t_type = 5 and M.t_materialref = :mtlKey and M.t_hallmarkref = C.t_autokey  "+
                    "and M.t_weight = :weight and t_qualityref = :quality " +
                    "and C.t_group = 4 and C.t_uplink =M.t_materialref and (C.t_double between :hlmarkMin and :hlmarkMax)";

    
    if ( ingRt.boxed ) 
        query = query + " and t_box = 'X' ";
    else
        query = query + " and t_box <> 'X' ";
    end;                                        

    query = query + " ORDER BY t_issueid DESC";
    cmd = RSDCommand( query );    

    cmd.addParam( "mtlKey",    RSDBP_IN, metalKey ); 
    cmd.addParam( "weight",    RSDBP_IN, ingRt.weight * 10000 );    
    cmd.addParam( "quality",   RSDBP_IN, ingRt.quality );
    cmd.addParam( "hlmarkMin", RSDBP_IN, hallmarkMin );
    cmd.addParam( "hlmarkMax", RSDBP_IN, hallmarkMax );

                     
    rs = RsdRecordSet( cmd );

    cmd.Execute();

    return rs;

END; 
       
 
// Находит код курса слитка для указанной даты
// возвращает код курса
// Если ничего не найдено, возвращает 0
MACRO GetRateByParams ( sdate : date, issueid ): integer
   var cmd, rs, key = 0;

   cmd = RSDCommand( " select t_autokey " +
                     " from   ding_rate_dbt " +
                     " where  t_date = :now and t_type = 5 and t_issue = :issue and t_branch = :branch" );

                
   cmd.addParam( "now", RSDBP_IN, sdate );    
   cmd.addParam( "issue", RSDBP_IN, issueid );
   cmd.addParam( "branch", RSDBP_IN, NumFNCash() );
   
   rs = RsdRecordSet( cmd );

   cmd.Execute(); 

   if ( rs.moveNext() )
       key = rs.Value( "t_autokey" )    
   end;   

   return key;
END;


macro SetRangedForIngot ( ingotid : integer, ranged : bool )
    FILE cimisc( "ci_misc.dbt", "sbbank.def" ) key 0 write;
    cimisc.issueid = ingotid;
    cimisc.type = 5;
    if ( GetEQ ( cimisc ) )
        GetPos( cimisc );
        if ( ranged ) 
            cimisc.range = "X";
        else
            cimisc.range = "";
        end;
        Update( cimisc );
    end; 
end; 


// Обновляет информацию о слитке
// Возвращает ноль в случае неудачи
// 1 - если запись добавлена
// 2 - если запись обновлена
MACRO UpdateIngotRateInfo( sdate              : date,     // Дата начала действия цены
                           stime              : time,     // Время начала действия цены
                           updateExisting     : bool,     // обновлять сущ. запись    
                           ingRt              : IngotRate, // информация, выводимая в отчет (выходной параметр)   
                           repEntries         : TArray,
                           lineNum            : integer
                         ) : integer
    var stat = 0;
    var mtlKey,
        hlmarkKey,
        rateKey, rs, 
        issueid, ingRate;
        
    FILE ingRateFile( "ing_rate.dbt", "sbbank.def" ) key 0 write;
    // Если найден код металла
    if ( (mtlKey = GetMetalCodeByName( METALS( ingRt.metal) ) ) != 0 ) 

      rs = GetIngotByParams(mtlKey, ingRt.hlmarkMin, ingRt.hlmarkMax, ingRt );

      while ( rs.moveNext() )
        ingRate = Ingotrate;

        ingRate.metal       = ingRt.metal      ;
        ingRate.quality     = ingRt.quality    ;
        ingRate.name        = ingRt.name       ;
        ingRate.weight      = ingRt.weight     ;
        ingRate.hlmarkMin   = ingRt.hlmarkMin  ;
        ingRate.hlmarkMax   = ingRt.hlmarkMax  ;
        ingRate.buyPrice    = ingRt.buyPrice   ;
        ingRate.sellPrice   = ingRt.sellPrice  ;
        ingRate.nds         = ingRt.nds        ;
        ingRate.ndsPrice    = ingRt.ndsPrice   ;
        ingRate.ndsIncluded = ingRt.ndsIncluded;
        ingRate.boxed       = ingRt.boxed      ;
        ingRate.lineNum     = ingRt.lineNum    ;
        ingRate.hlmark      = ingRt.hlmark     ;

        issueid = rs.Value( "t_issueid" );
        ingRate.ndsIncluded = ( rs.Value( "t_NDS_IsIncludedInCost" ) == "X" );
        ingRate.name = rs.Value( "t_name" );
        ingRate.name = rs.Value( "t_name" );
        ingRate.hlmark = rs.Value( "t_double" );
                
                
        // если курс найден 
        if ( (rateKey = GetRateByParams ( sdate, issueid )) != 0 ) 
           // и разрешено обновление - обновляем
           if ( updateExisting )
               ingRateFile.autokey = rateKey;
               if ( GetEQ( ingRateFile ) )
                   GetPos( ingRateFile );
                   ingRateFile.date = sdate;
                   ingRateFile.time = stime;
                   ingRateFile.buyrate = ingRate.buyPrice;
                   ingRateFile.branch = NumFNCash();
                                                         
                   if ( ingRt.ndsIncluded )
                       ingRateFile.sellrate = ingRate.ndsPrice;                                
                   else
                       ingRateFile.sellrate = ingRate.sellPrice;                                
                   end;
                   
                   Update( ingRateFile );                         
                   if ( ingRate.hlmarkMin != ingRate.hlmarkMax )
                       SetRangedForIngot( issueid, true );
                   end;                            
                   stat = 2;
               end;                     
           end; 
        else     
           // если курс не найден - добавляем его
           ingRateFile.autokey = 0;
           ingRateFile.type = 5;     
           ingRateFile.issue = issueid;
           ingRateFile.date = sdate;
           ingRateFile.time = stime;
           ingRateFile.buyrate = ingRt.buyPrice;
           ingRateFile.currCode = 0; 
           ingRateFile.branch = NumFNCash();

           if ( ingRate.ndsIncluded )
               ingRateFile.sellrate = ingRate.ndsPrice;                       
           else
               ingRateFile.sellrate = ingRate.sellPrice;                       
           end;  
           
           Insert( ingRateFile );
           if ( ingRate.hlmarkMin != ingRate.hlmarkMax )
               SetRangedForIngot( issueid, true );
           end;                    
           stat = 1;
        end;                

        ingRate.lineNum = lineNum;
        repEntries(repEntries.Size) = ingRate;
                
      end; // end while

    end; // end if
    
    return stat;
END;

 
MACRO ImportIngotRates( path           : string,// файл импорта
                        sdate          : date,  // Дата начала действия цены
                        stime          : time,  // Время начала действия цены
                        updateExisting : bool   // обновлять cущ. записи
                      ) : TArray
    
    var lineNum,                 // номер разбираемой строки 
      
        metal,                   // металл разбираемой секции      
        quality   : integer,     // "качество" в разбираемой секции
        boxed     : bool,        // флаг "в футляре или нет"
        ingRate   : IngotRate;
    var repEntries = TArray;     // записи выводимые в отчет   
    
    // Если есть что-то на странице
    if ( xls and xls.Open( path ) and getTableCoords() )
        lineNum = top; 

        while ( lineNum < rows + top - 1 )
            
            // пропускаем пустые сроки
            while ( (ValType( GetValue( lineNum, left ) ) == V_UNDEF) and ( lineNum <  rows + top - 1 ) )
                lineNum = lineNum + 1;       
            end;            
     
            // Разбираем строку типа "#НОМЕР. слитки #КАЧЕСТВО состояние" (начало секции)            
            if ( Parse( PRS_QUALITY, lineNum, left, quality ) )             
             lineNum = lineNum + 2; // пропускаем шапку таблицы
                while ( Parse( PRS_METAL, lineNum, left, metal, boxed ) )
                   lineNum = lineNum + 1;       
 
                while ( Parse( PRS_INGOTRATE, lineNum, left, ingRate ) )                              
         ingRate.metal = metal;
                       ingRate.quality = quality;
                       ingRate.boxed = boxed;                
                       if ( UpdateIngotRateInfo( sdate, stime, updateExisting, ingRate, repEntries, lineNum + 1) )   
                           ingRate = Ingotrate;
                       end;                          
                       lineNum = lineNum + 1;
                   end;
                   
                   // Если ячейка не пустая и в ней не содержится название металла - значит, произошла ошибка разбора
                   // Заполняем объект класса ReportEntry нулевыми значениями (знак того, что произошла ошибка)
                   // В название записываем сообщение об ошибке 
                   if ( ( ValType( GetValue( lineNum, left )) != V_UNDEF )
                        and ( Parse( PRS_METAL, lineNum, left, metal, boxed ) == PRS_ERR)
                       )
                       repEntries(repEntries.Size) = RaiseError( MSG_BOX + (lineNum + 1) , MSG_REP, (lineNum + 1) );        
                       return repEntries;
                   end;                               
             end;
            else
                repEntries(repEntries.Size) = RaiseError( MSG_BOX + (lineNum + 1) , MSG_REP, (lineNum + 1) );        
                return repEntries;
            end;
        
        end;
          
    else
        repEntries(repEntries.Size) = RaiseError( MSG_EMPTYFILE, MSG_EMPTYFILE, 0);
    end;

    return repEntries;

END;                                                                      

//**********************************************************************//


                                                                          

//**********************************************************************//
//                     ФУНКЦИИ ПЕЧАТИ ОТЧЕТА                            //         
//**********************************************************************//

MACRO OperFIO()
  var person = TBfile("person");
  person.KeyNum = 0;
  person.rec.Oper = {oper};
  if( not GetEq(person) )
    return "______________________________";
  else
    return person.rec.Name;
  end;
END;
 

// Выводит отчет о проделанном импорте
MACRO PrintReport( entries :TArray, path : string, sdate : date, stime : time )
    var i = 0;
    
    [
     ----- #################### ---------------- ########## ----- ######## ------- 
    
     Импорт цен драгметаллов за ########## ######## 
     Источник ###################################################################
                                                                                  ] ( GetRetailVersion(), Date(), Time(), sdate, stime, path );
    if ( entries.Size >  0 )

    // если запись не пустая - значит, есть импортиров. записи
    if ( entries(0).weight != 0 )

        [┌───────────────────────────────────┬────────┬────────────┬────────────┬────┐];
        [│ Слиток драгметалла                │ Проба  │Цена покупки│Цена продажи│НС  │];
        [├───────────────────────────────────┼────────┼────────────┼────────────┼────┤];
    
        while ( (i < entries.Size) and (entries(i).weight != 0) )
            if ( entries(i).ndsIncluded )
                 entries(i).sellPrice = entries(i).ndsPrice;
            end;
            [│###################################│########│############│############│### │]   ( entries(i).name, entries(i).hlmark:m:5:2, 
                                                                                                entries(i).buyPrice:m:7:4, entries(i).sellPrice:m:7:4,
                                                                                                entries(i).lineNum );
             if ( i != entries.Size - 1 )
                [├───────────────────────────────────┼────────┼────────────┼────────────┼────┤];
             else
                [└───────────────────────────────────┴────────┴────────────┴────────────┴────┘];
             end;

        i =i + 1;
        end;

        if ( i < entries.Size )
            [│######################################################################│### │
             └──────────────────────────────────────────────────────────────────────┴────┘]  ( entries(i).name, entries(i).lineNum );
        end;
    else
        [#############################################################################] ( entries(0).name + " (" + entries(i).lineNum + ")");
      
    end;
    end;    

    [

     Операционист ##############################################
    
     ----- #################### ---------------- ########## ----- ######## -------] ( OperFIO(), GetRetailVersion(), Date(), Time() ); 

END;

//**********************************************************************//

     


var path : string;
                      
MACRO InitPanel( dlg )
    dlg.rec.sdate = {curdate};
    dlg.rec.stime = Time();
    dlg.rec.filename = TEMPLATE_FILE;
    dlg.rec.update = "" ;    
END;

MACRO Check( dlg ) : bool
    var ret = true, ob, fileName, extension;

    // Если запуск производится в 3-х звенке, то нужно при поиске к имени файла добавлять "$"
    if( NOT isStandalone() )
       ob = TDirList ( "$"+dlg.rec.filename,"f" );
    else
       ob = TDirList ( dlg.rec.filename,"f" );
    end;

    fileName  = dlg.rec.filename;
    extension = SubStr( filename, StrLen(filename) - 3 );

    if ( dlg.rec.sdate < Date( "1.1.2001" ) )
        MsgBox( MSG_INVALIDDATE );
        ret = false;
    end;    
    
    if ( filename == "" )
        MsgBox( MSG_EMPTYFILE );
        ret = false;
    end;

    if ( extension != ".xls" )
        MsgBox( MSG_NOXLSTEMPLATE );
        ret = false;
    end;     
    
    if ( ob.Count == 0 )
        MsgBox( MSG_NOFILE );
        ret = false;        
    end;

    return ret;
END;

MACRO ShowFile( filename )
    FILE repfile() txt; 
    Open(repfile, filename);
    SetOutput( null, true );
    ViewFile ( repfile );
    Close( repfile );
    SetOutput( filename, true );
END;


MACRO DoImport( filename : string, sdate : date, stime : time, updateExisting : bool )
    var entries = TArray;
    entries = ImportIngotRates( filename, sdate, stime, updateExisting );
    PrintReport( entries, filename, sdate(), stime );
    //MsgBox("Импорт цен слитков драгметаллов за Д В: Обновлено цен #КО Добавлено цен #КД" );
    ShowFile( REPORT_FILE );    
END;


MACRO EventHandler( dlg, cmd, id, key )
    var impFile;

    if( cmd == DLG_INIT )
       return InitPanel( dlg );
    elif ( cmd == DLG_KEY )
        if ( key == K_F3 )
            if ( id == F_FILE_NAME )
                if ( GetString(impFile, "Выберите файл для обработки") )
                    dlg.rec.filename = impFile; 
                end; 
            end;
        end;

        if ( key == K_SPACE )
            if ( id == F_UPDATE_CHBOX )
                if ( dlg.rec.update == "X" )
                    dlg.rec.update = "";
                else
                    dlg.rec.update = "X"
                end;
            end;
        end;

        if ( key == K_F2 )            
            if ( Check ( dlg ) ) 
                SetOutput( null, true );
                SetOutput( REPORT_FILE );
                DoImport( dlg.rec.filename,  dlg.rec.sdate,  dlg.rec.stime, dlg.rec.update == "X" );
            end;        
        end;
    end;
    UpdateFields (dlg);
END;

var dlg = TRecHandler ( "P_INGIMP", "sbbank.lbr", true );
RunDialog( dlg, @EventHandler );

