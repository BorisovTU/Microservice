
/* Завершение года. Проверочный отчет для расчета/причисления %% */

import deprintr, Календарь;

file Curr( "currency.dbt" ) key 0;
file DepType( "sb_dtyp.dbt" ) key 2;
file Dep( "depositr.dbt" ) key 1;
file pc_alg ("pc_alg.dbt") key 0;

const
  OK_RES   =  0,  /* продолжать проводку */
  SKIP_RES =  1,  /* пропустить выполнение предопределенного модуля */
  END_RES  =  2,  /* завершить проводку */
  ERR_RES  = -1;  /* аваpийно завершить проводку */

var
  {curdate},
  IsCur = NumFlagCur,
  Branch = NumFNCash,
  NextCalcDate,
  SubHeadDisplayed,
  TADisplayed,
  TotRest = $0,
  TotRestTA = $0;

macro GetNextCalcDate
(
 Cur_Date,      /* Дата, от которой идет расчет (текущая) */
 Graf,          /* Стратегия расчета (оплаты) */
 Day,           /* День расчета (если стратегия- заданного числа каждого месяца */
 GrafDate       /* Выход- дата следующего расчета (оплаты) */
)
/*
  Определение даты текущего расчета (оплаты) процентов
*/
  var stat = TRUE;
  var d,m,y;

  DateSplit (Cur_Date,d,m,y);
  if ( d == 32 )
    d = 31;
  end;
  GrafDate = Date(0,0,0);
  if (Graf == 1)        /* В конце дня  */
    GrafDate = Cur_Date;
  elif (Graf == 2)      /* В конце месяца */
    if (m == 12)
      m = 1;
      y = y + 1;
    else
      m = m + 1;
    end;
    GrafDate = Date(1,m,y) - 1;
  elif (Graf == 3)      /* В конце квартала     */
    if (m > 9)
      m = 1;
      y = y + 1;
    elif (m > 6)
      m = 10;
    elif (m > 3)
      m = 7;
    else
      m = 4
    end;
    GrafDate = Date(1,m,y) - 1;
  elif (Graf == 4)      /* В конце года */
    GrafDate = Date(31,12,y);
  elif (Graf == 5)      /* Day числа каждого месяца */
    if (Day > 0)
      if (d > Day)
        m = m + 1;
        if (m > 12)
          m = 1;
          y = y + 1;
        end;
      end;
      GrafDate = Date(Day,m,y);
    end;
  end;            
  
  /* прокинуть дырявые дни */                    
  while( IsHoliday( GrafDate ) )
    GrafDate = GrafDate - 1;
  end;

  SetParm (3,GrafDate);
  return stat;
end;

macro OutHead

  [ ];
  [По следующим счетам будут произведены расчет и причисление %% ];
  [ ];
end;

macro OutSubHead

  [-------------------------------------------------------------];
  [|                         |   Дата   |                      |];
  [|        С ч е т          |очередного|       Остаток        |];
  [|                         |расчета %%|                      |];
  [-------------------------------------------------------------];
end;

macro OutLine

  [ ######################### ########## ###################### ]
  (
    Acc_Form(Dep.Account),
    NextCalcDate,
    Dep.Sum_Rest
  );
  TotRest = TotRest + Dep.Sum_Rest;
  TotRestTA = TotRestTA + Dep.Sum_Rest;
end;

macro OutTotalsTA

  [-------------------------------------------------------------];
  [ Итого по виду вклада:                ###################### ]
  (
    TotRestTA
  );
  TotRestTA = $0;
end;

macro OutTotals

  [-------------------------------------------------------------];
  [ Итого:                               ###################### ]
  (
    TotRest
  );
  TotRest = $0;
end;

macro TreatDepType

  var
    RecFound;

  TADisplayed = false;

  ClearRecord( Dep );
  Dep.IsCur = IsCur;
  Dep.FNCash = Branch;
  Dep.Type_Account = DepType.Kind;
  Dep.Code_Currency = Curr.Code_Currency;
  RecFound = GetGE( Dep );
  while ( RecFound
    and ( Dep.IsCur == IsCur )
    and ( Dep.FNCash == Branch )
    and ( Dep.Type_Account == DepType.Kind )
    and ( Dep.Code_Currency == Curr.Code_Currency ) )
    if ( ( not Index( Dep.UserTypeAccount, "Т" ) )
      and ( not Index( Dep.UserTypeAccount, "Я" ) ) )
      if ( not SubHeadDisplayed )
        if ( IsCur )
          PrintLn;
          PrintLn( Curr.Name_Currency );
          PrintLn( MkStr( "=", StrLen( Curr.Name_Currency ) ) );
          PrintLn;
        end;
        OutSubHead;
        SubHeadDisplayed = true;
      end;
      if ( not TADisplayed )
        PrintLn;
        PrintLn( DepType.Kind );
        PrintLn( MkStr( "-", StrLen( DepType.Kind ) ) );
        TADisplayed = true;
      end;
      OutLine;
    end;
    RecFound = Next( Dep );
  end;
  if ( TADisplayed )
    OutTotalsTA;
  end;
end;

/**********************************************************/

macro GetLastPcAlg (Kind,FlagCur)
  pc_alg.FlagCur    = FlagCur;
  pc_alg.Referenc   = Kind;
  pc_alg.ObjectType = 1003;
  pc_alg.BegDate    = {curdate};
  return (GetLE(pc_alg) AND (pc_alg.FlagCur    == FlagCur) AND
                            (pc_alg.Referenc   == Kind)    AND
                            (pc_alg.ObjectType == 1003) )
end;
/**********************************************************/

macro TreatAllDepTypes

  var
    RecFound;

  SubHeadDisplayed = false;

  ClearRecord( DepType );
  DepType.FlagCur = IsCur;
  RecFound = GetGE( DepType );
  while ( RecFound
    and ( DepType.FlagCur == IsCur ) )
    if ( DepType.CalcPcOnEoy != StrFor( 0 ) )
      if (GetLastPcAlg (DepType.Kind,DepType.FlagCur))
        GetNextCalcDate( {curdate} - 1, pc_alg.GrafCalc, pc_alg.DayCalc, NextCalcDate );
        if ( NextCalcDate <= {curdate} )
          TreatDepType;
        end;
      end;
    end;
    RecFound = Next( DepType );
  end;
  if ( SubHeadDisplayed )
    OutTotals;
  end;
end;

  var
    RecFound;

  OutHead;
  if ( not IsCur )
    Curr.Code_Currency = 0;
    if ( GetEQ( Curr ) )
      TreatAllDepTypes;
    end;
  else
    Curr.Code_Currency = 1;
    RecFound = GetGE( Curr );
    while( RecFound )
      TreatAllDepTypes;
      RecFound = Next( Curr );
    end;
  end;
  ALG_RESULT = OK_RES; 
end;

