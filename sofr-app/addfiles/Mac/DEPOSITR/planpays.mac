/*
$Name:               planpays.mac
$Module:             DEPOSITR
$Description:        Отчет по обработке длительных поручений
*/
/*

    R-Style Software Lab.

    RS-Retail 2.01

    Отчет по плановым перечислениям

*/

import DeprIntr, sqlconv, rsd;

var pp = TBFile("dplanpay.dbt", "r" );  /* Документ по плановому перечислению */
private var namealg = TBFile( "namealg.dbt", "r", 0, "namealg.dbt", "bank.def" );
file bm ("sbbank.msg")   key 0;
private var clientList = TClientList;

const FlagCur = NumFlagCur();
const FNCash  = NumFNCash();

var ret;
var num       = 0;
var nnn       = 1;
var mErr      = FALSE;  /* Флаг выпуска заголовка ошибок */
var mOk       = FALSE;  /* Флаг выпуска заголовка проведенных */
var FlagFirst = TRUE;
private var {curdate};
private var Branch = FNCash;

/**************************************************************************\
|                          Дать сообщение об ошибке                        |
\**************************************************************************/
macro ErrMsg( code )
  var str;
  bm.Number = code;
  if ( GetEQ( bm ) )
    str = bm.Contents;
  else
    str = "Ошибка " + String(code);
  end;
  return str;
end;

/**************************************************************************\
|               Заголовок списка проведенных перечислений                  |
\**************************************************************************/
macro PrintTitle( fFloor )

  [ ];
  [ ];
  [                     Проведенные плановые перечисления];
  [ ];
  [  +-----+-----+----------------------------+-----------+-----------------+---------------------------------+------------+];
  [  | N/N | Вид |           Счет             |    Дог.   |      Сумма      |            Основание            | Следующее  |];
  [  +-----+-----+----------------------------+-----------+-----------------+---------------------------------+------------+];

  mOk = TRUE;

end;

/**************************************************************************\
|              Завершение таблицы проведенных перечислений                 |
\**************************************************************************/
private macro PrintFloor()

  if ( mOk )
    [  +-----+-----+----------------------------+-----------+-----------------+---------------------------------+------------+];
    mOk = FALSE;
  end;

end;

/**************************************************************************\
|               Заголовок списка не проведенных перечислений               |
\**************************************************************************/
macro ErrTitle( fFloor )

  [ ];
  [ ];
  [                            Не проведенные плановые перечисления];
  [ ];
  [  +-----+-----+----------------------------+-----------+-----------------+-------------------------+--------------------------+];
  [  | N/N | Вид |           Счет             |    Дог.   |      Сумма      |        Основание        |          Ошибка          |];
  [  +-----+-----+----------------------------+-----------+-----------------+-------------------------+--------------------------+];

  mErr = TRUE;

end;

/**************************************************************************\
|              Завершение таблицы не проведенных перечислений              |
\**************************************************************************/
macro ErrFloor

  if ( mErr )
    [  +-----+-----+----------------------------+-----------+-----------------+-------------------------+--------------------------+];
    mErr = FALSE;
  end;

end;


/**************************************************************************\
|                   Поиск названия алгоритма по его коду                   |
\**************************************************************************/
private macro GetNameAlg( typeAlg, numberAlg )

  namealg.Clear;
  namealg.rec.iTypeAlg   = typeAlg;
  namealg.rec.iNumberAlg = numberAlg;

  if ( namealg.GetEQ )
    return namealg.rec.szNameAlg;
  else
    return "";
  end;
end;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro PrintHeadGIS

  [ ];
  [ ];
  [                                  Отчет о создании распоряжений на оплату ЖКХ];
  [                                             #]( String( Date( ):f ) + " " + String( Time( ) ) );
  [ ];
  [┌─────────────┬────────────────────────┬───────────┬─────────────┬───────────────┬─────────────────────────────┐];
  [│   Статус    │    ФИО плательщика     │ Единый ЛС │     ЖКУ     │     Сумма     │         Примечание          │];
  [├─────────────┼────────────────────────┼───────────┼─────────────┼───────────────┼─────────────────────────────┤];

end;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro PrintTailGIS

  [└─────────────┴────────────────────────┴───────────┴─────────────┴───────────────┴─────────────────────────────┘];

end;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro PrintGIS( rs )

  var cmdError, rsError;
  var statusZKH = "";
  var fioPayer = "";
  var codClient = rs.value( "t_CodClient" );
  var statusGIS = rs.value( "StatusGIS" );
  var errText = "";

  statusZKH = GetNameAlg( 1073, statusGIS );

  if ( clientList.GetRecord( codClient ) )
    fioPayer = clientList.CurRec.rec.Name1;

    if ( ( fioPayer != "" ) and ( clientList.CurRec.rec.Name2 != "" ) )
      fioPayer = fioPayer + " " + SubStr( clientList.CurRec.rec.Name2, 1, 1 ) + ".";
      if ( clientList.CurRec.rec.Name3 != "" )
        fioPayer = fioPayer + SubStr( clientList.CurRec.rec.Name3, 1, 1 ) + ".";
      end;
    end;
  end;

  if ( statusGIS > 2 )
    cmdError = RsdCommand( "select rsbedref.t_Error from drsbedref_tmp rsbedref " +
                           "where rsbedref.t_ApplicationKind = :applKind " +
                              "and rsbedref.t_ApplicationKey = :applKey" );

    cmdError.addParam( "applKind", RSDBP_IN, rs.value( "t_iApplicationKind" ) );
    cmdError.addParam( "applKey", RSDBP_IN, rslString( rs.value( "t_ApplicationKey" ) ) );

    cmdError.execute;

    rsError = RsdRecordset( cmdError );

    if ( rsError.moveNext( ) )
      errText = rslString( rsError.value( "t_Error" ) );
    else
      errText = rslString( rs.value( "t_Error" ) );
    end;
  end;

  [│#############│########################│###########│#############│###############│#############################│]
  ( statusZKH:w, fioPayer:w, rslString( rs.value( "t_PayerId" ) ), rslString( rs.value( "t_ServiceId" ) ), ( rs.value( "t_PaySum" ) + rs.value( "t_PennySum" ) ):15:2:a, errText:w );

end;


/**************************************************************************\
|           Поиск документа вкладчика по плановому перечислению            |
\**************************************************************************/
macro find_DocSum( _docsum )
  var cmd, rs;
  var flags, InSum, OutSum;
  var find = FALSE;

  _docsum = "";
  if( (pp.rec.CardRef) and (pp.rec.TypeOper != 87) )
    cmd = RsdCommand("SELECT t_Flags, t_InSum FROM dpay_doc_dbt " + 
                     " WHERE t_FNcash=? AND t_isCur=? AND t_Date_Document=? " + 
                     "   AND t_GroupOpert=? AND t_NumOpert=? " +
                     "   AND t_KKMOpNumber=?" +
                     "   AND t_Action <> 2 AND t_Action <> 11 ");
    cmd.addParam("FNcash",   RsdBp_in, pp.rec.FNcash);
    cmd.addParam("isCur",    RsdBp_in, pp.rec.isCur);
    cmd.addParam("DateDoc",  RsdBp_in, {curdate});
    cmd.addParam("GroupOp",  RsdBp_in, 41);
    cmd.addParam("NumOp",    RsdBp_in, 26);
    cmd.addParam("KKMOpNum", RsdBp_in, pp.rec.Ref);
    cmd.execute;
    rs = RsdRecordset(cmd);

    while( (rs.moveNext) and (not find) )
      flags = rs.value(0);
      OutSum = Money(rs.value(1));

      if( GetBitFlag( flags, 2 ) == 1 )
        _docsum = String( OutSum:15:2:a );
        find = TRUE;
      end;
    end;

  else
    cmd = RsdCommand("SELECT t_Flags, t_InSum, t_OutSum FROM dsbdepdoc_dbt " + 
                     " WHERE t_Referenc=? AND t_TypeOper=? " + 
                     "   AND t_Date_Document=? AND t_DepDate_Document=? " +
                     "   AND t_ListTransfer=? " +
                     "   AND t_Action <> 2 AND t_Action <> 11 AND t_FlagStorn = chr(0) " +
                     "   AND t_KindOp <> 8 AND t_KindOp <> 9 " +
                     "   AND t_KindOp <> 14 AND t_KindOp <> 15 AND t_KindOp <> 16 " +
                     " ORDER BY t_NumDayDoc DESC ");
    cmd.addParam("Referenc",   RsdBp_in, pp.rec.Reference);
    cmd.addParam("TypeOper",   RsdBp_in, pp.rec.TypeOper);
    cmd.addParam("DateDoc",    RsdBp_in, {curdate});
    cmd.addParam("DepDateDoc", RsdBp_in, {curdate});
    cmd.addParam("ListTrans",  RsdBp_in, pp.rec.Ref);
    cmd.execute;
    rs = RsdRecordset(cmd);

    while( (rs.moveNext) and (not find) )
      flags  = rs.value(0);
      InSum  = Money(rs.value(1));
      OutSum = Money(rs.value(2));

      if( GetBitFlag( flags, 29 ) == 1 )
        if( InSum != 0 )
          _docsum = String( - InSum:15:2:a );
        else
          _docsum = String( OutSum:15:2:a );
        end;
        find = TRUE;
      end;
    end;

  end;
  
  SetParm(0, _docsum);

  return find;
end;

macro getFilterText(DatePay, operation, appType, recipient, reciever)
  var txtFilter = " t.t_IsCur = "       + string( FlagCur ) +
                " and t.t_FNCash = "      + string( Branch ) +
                " and t.t_DateLastPay = " + sqlDateToStr( DatePay );
                
  if( operation != 0 )
    txtFilter = txtFilter + " and t.t_TypeOper= " + string( operation );
  end;
  
  if( appType != -1 )
    txtFilter = txtFilter + " and t.t_ApplType= " + string( appType );
  end;
  
  if( recipient != -1 )
    txtFilter = txtFilter + " and t.t_CP_Recip= " + string( recipient );
  end;
  
  if( reciever != -1 )
    txtFilter = txtFilter + " and t.t_CODCLIENT= " + string( reciever );
  end;

  return txtFilter;
end;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro Orders (Acc, DatePay, operation, appType, recipient, reciever)

  var sErr = "";
  var DocSum = "";
  var cmdPlanPayGIS, rsPlanPayGIS;
  var isFirstGIS = true;

  mErr = false;
  mOk = false;
  FlagFirst = true;

  pp.keyNum = 2;
  pp.clear;
  pp.rec.IsCur       = FlagCur;
  pp.rec.FNCash      = Branch;
  pp.rec.DateLastPay = DatePay;

  pp.addfilter( getFilterText(DatePay, operation, appType, recipient, reciever) );
  
  ret = pp.getGE;

  while (ret)
    if ( ( pp.rec.IsCur       == FlagCur )  AND
         ( pp.rec.FNCash      == Branch  )  AND
         ( pp.rec.DateLastPay == DatePay ) )
      if ( pp.rec.DocApplKind != 200 )
        if ( ( pp.rec.NamePay == "" )  AND  ( pp.rec.KindPay == 1 ) )
          pp.rec.NamePay = "Невостреб.платеж";
        end;

        if ( FlagFirst )
          [ ];
          [                   Отчет по плановым перечислениям за #](String(DatePay));
          if ( StrLen(Acc) != 0 )
            [                             по счету #] (Acc_Form(Acc):f);
          end;
          if ( pp.rec.ErrCode == 0 )
            if ( find_DocSum(DocSum) )
              PrintTitle();
            else
              ErrTitle();
            end;
          else
            ErrTitle();
          end;

          InitProgress(num,"dplanpay.dbt","Идет формирование ордеров ...");

          FlagFirst = FALSE;
        end;

        if ( pp.rec.ErrCode == 0 )
          if ( ( ( StrLen(Acc) == 0 )  OR  ( Acc == pp.rec.Account ) )  AND  find_DocSum(DocSum) )
            [  | ### | ### | ########################## | ######### | ############### | ############################### | ########## |]
            (
              nnn:3,
              pp.rec.TypeOper:3,
              Acc_Form(pp.rec.Account):26:f,
              pp.rec.NumberContract:9,
              DocSum:15,
              pp.rec.NamePay:w:26,
              pp.rec.NextPay:10 );
            nnn = nnn + 1;
          end;
        else
          if (NOT mErr)
            PrintFloor();
            ErrTitle();
            nnn = 1;
          end;
          if ( pp.rec.ErrCode != 0 )
            sErr = ErrMsg( pp.rec.ErrCode );
          else
            sErr = "Не найден документ по плановому перечислению";
          end;
          if ((StrLen(Acc) == 0) OR (Acc == pp.rec.Account))
            [  | ### | ### | ########################## | ######### | ############### | ####################### | ######################## |]
            ( nnn:3,
              pp.rec.TypeOper:3,
              Acc_Form(pp.rec.Account):26:f,
              pp.rec.NumberContract:9,
              pp.rec.Sum:w,
              pp.rec.NamePay:w:24,
              sErr:w:24 );
            nnn = nnn + 1;
          end;
        end;

        num = num + 1;
        UseProgress(num);
      end;
        ret = pp.next;
    else
      ret = FALSE;
    end;
  end;

  pp.dropFilter;

  if (NOT FlagFirst)
    RemProgress();
    ErrFloor();
    PrintFloor();
  else
    println(" Плановые перечисления за ", DatePay, " не проводились");
   end;

  // Выгрузка плановых пречислений в ГИС ЖКХ
  pp.keyNum = 2;
  pp.clear;
  pp.rec.IsCur       = FlagCur;
  pp.rec.FNCash      = Branch;
  pp.rec.DateLastPay = DatePay;

  pp.addfilter( getFilterText(DatePay, operation, appType, recipient, reciever) );

  ret = pp.getGE;

  while ( ret )
    if ( ( pp.rec.IsCur       == FlagCur )  AND
         ( pp.rec.FNCash      == Branch  )  AND
         ( pp.rec.DateLastPay == DatePay ) )
      if ( ( pp.rec.DocApplKind != 200 ) and ( pp.rec.TypeOper == 64 ) )

        cmdPlanPayGIS = RsdCommand( "select sbdepdoc.*, pay_doc_cp.*, pay_doc_cp.t_Status as StatusGIS from dsbdepdoc_dbt sbdepdoc, dpay_doc_cp_dbt pay_doc_cp " + 
                          "where sbdepdoc.t_Referenc = ? " +
                            "and sbdepdoc.t_TypeOper = ? " + 
                            "and sbdepdoc.t_Date_Document = ?  " +
                            "and sbdepdoc.t_DepDate_Document = ? " +
                            "and t_ListTransfer = ? " +
                            "and t_Action not in ( 2, 11 ) " +
                            "and pay_doc_cp.t_ApplKind = sbdepdoc.t_iApplicationKind " +
                            "and pay_doc_cp.t_ApplKey = sbdepdoc.t_ApplicationKey " +
                            "and pay_doc_cp.t_IsForGIS != chr( 0 )" );

        cmdPlanPayGIS.addParam( "Referenc",   RsdBp_in, pp.rec.Reference );
        cmdPlanPayGIS.addParam( "TypeOper",   RsdBp_in, pp.rec.TypeOper );
        cmdPlanPayGIS.addParam( "DateDoc",    RsdBp_in, {curdate} );
        cmdPlanPayGIS.addParam( "DepDateDoc", RsdBp_in, {curdate} );
        cmdPlanPayGIS.addParam( "ListTrans",  RsdBp_in, pp.rec.Ref );

        cmdPlanPayGIS.execute;

        rsPlanPayGIS = RsdRecordset( cmdPlanPayGIS );

        while ( rsPlanPayGIS.moveNext( ) )
          if ( isFirstGIS )
            PrintHeadGIS( );
            isFirstGIS = false;
          end;

          PrintGIS( rsPlanPayGIS );
        end;
      end;
      ret = pp.next;
    else
      ret = false;
    end;
  end;

  if ( not isFirstGIS )
    PrintTailGIS( );
  end;

  pp.dropFilter;

end;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro OrdersAllBranches (Acc, DatePay, operation, appType, recipient, reciever )
  var dpDepList = TdpDepList;

  dpDepList.SetFilter( dpDepList.getFilialID( FNCash ) );
  while ( dpDepList.next() )
    Branch = dpDepList.rec.Code;
    [ ];
    [ ];
    [Подразделение: #](dpDepList.rec.Name);
    [ ];
    Orders(Acc, DatePay, operation, appType, recipient, reciever);
  end;

end;

// orders("",{curdate});
//OrdersAllBranches("",{curdate});

