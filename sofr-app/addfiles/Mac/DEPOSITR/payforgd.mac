
/*
**  Макрос оплаты товара
**  подключается в прочую операцию 93 "Оплата товара"
**  в качестве макроса выполнения
*/         

import DeprIntr, Contain, OperCode,DeskInter;

file DepParm( "depparm.dbt" ) key 0 write;
file Dep( "depositr.dbt" ) key 8; 
record Params( "CmPmParm.rec" );
record OC_PAY_DOC( "pay_doc.dbt" );

/*
**  Максимально допустимая сумма для одного платежа (операции)
*/

const
  MaxSum = $10000;

const SB_DEPOSIT = 1;
/*
** Величина разбиения сумм
*/

const
  Grain = MaxSum * 0.98;

/*
**  Нижеследующий флаг определяет, надо ли открывать несколько счетов, так 
**  чтобы остаток каждого не превосходил MaxSum
**
**  Значения:
**  - true  - открыть несколько счетов
**  - false - открыть один рублевый и один валютный счета
*/

const
  OpenMultipleAccounts = true;

/*
**  Вид курсов по умолчанию
*/

const
  DefRateKind = 1;	/* Основные курсы валют */

/*
**  Режим проводки.
**
**  Значения:
**    0 - рубли по возможности наличными, валюта только через счета
**    1 - только через счета
**    2 - спросить пользователя
*/

const
  CarryMode = 2;

/*
**  Базовая валюта
*/

const
  BaseCurr = 1;

const
  Op_PayForGoodies = 93, 	/* Операция "Оплата товара" */
  SubOp_WithConversion = 1;	/* Подвид "с конверсией" */

const
  CO_NALPER = 11;

const
  TYPE_PayDoc = 2;

const
  ConvAccType = "Conversion";

var
  Branch = NumFNCash, 
  {curdate}, 
  {oper}, 
  {CNum};

var
  Payments = TSet, 
  RubAccounts = TSet;

var
  SplitSum = null, 
  ContractNum;

var
  State, 
  ErrMsg;

var
  OnlyThruAccounts;

/*
**  Выход по ошибке
*/

macro SetErrorMsg( Msg, AppendStatus )

  var
    Stat;
                                    
  if ( AppendStatus != null )
    if ( AppendStatus )
      if ( Status( Stat ) )
        Msg = Msg + "|(" + Stat + ")";
      end;
    end;
  end;
  ErrMsg = Msg;
end;

macro ExitOnError( Msg )

  if ( Msg != null )
    SetErrorMsg( Msg );
  end;

  if ( ErrMsg != null )
    MsgBox( ErrMsg );
  end;

  Exit( 1 );
end;

/*
**  Чтение из параметров филиала номера последнего договора по оплате товара
*/

macro ReadContractNum

  DepParm.FNCash = Branch;
  State = GetEQ( DepParm );
  if ( not State )
    SetErrorMsg( "Ошибка чтения параметров филиала", true );
    return; 
  end; 
  ContractNum = DepParm.PfgContractNum;
end;

/*
**  Запись в параметры филиала номера последнего договора по оплате товара
*/

macro WriteContractNum

  DepParm.PfgContractNum = ContractNum;
  State = Update( DepParm );
  if ( not State )
    SetErrorMsg( "Ошибка чтения параметров филиала", true );
  end; 
end;

/*
**  Поиск счета
*/ 

macro FindAccount( Ref )

  Dep.Referenc = Ref;
  return GetEQ( Dep ); 
end;

/*
**  Поиск счета по номеру
*/ 

macro FindAccountForNum( Acc )

  var
    Stat, 
    sk = KeyNum( Dep, 7 );

  Dep.FNCash = Branch;
  Dep.Account = Acc;
  Stat = GetEQ( Dep ); 
  KeyNum( Dep, sk );
  return Stat;
end;

/*
**  Генерация очередного номера договора
*/

macro NextContractNum

  var
    s1, s2;

  ContractNum = ContractNum + 1;
  if ( ContractNum == 10000 )
    ContractNum = 1;
  end;

  s1 = String( Branch );
  if ( StrLen( s1 ) == 1 )
    s1 = "0" + s1;
  end;

  s2 = String( ContractNum );
  while ( StrLen( s2 ) < 4 )
    s2 = "0" + s2;
  end;

  return s1 + "-" + s2;
end;


/*
**  Проводка операции по вкладу
*/

macro DepOperation( Ref, OpParams, Doc )
  var
    Ret, 
    SaveFlagCur = NumFlagCur;

  if ( ( OpParams.Type_Oper != Открытие_наличными ) and ( OpParams.Type_Oper != Открытие_безналичными ) )
    State = FindAccount( Ref );
    if ( not State )
      SetErrorMsg( "Не найден счет: Ref = " + Ref );
      return;
    end;

    OpParams.Account = Dep.Account;
    OpParams.Type_Account = Dep.Type_Account;
    OpParams.Code_Currency = Dep.Code_Currency;
    OpParams.SvodAccount = Dep.SvodAccount;
    Doc.Referenc = Dep.Referenc; 
  end;

  if ( ( OpParams.Code_Currency != 0 ) and ( SaveFlagCur == 0 ) )
    SetFlagCur( 1 );
  end;

  if ( ( OpParams.Code_Currency == 0 ) and ( SaveFlagCur != 0 ) )
    SetFlagCur( 0 );
  end;

  OpParams.AuthorCode = Doc.CodClient = Params.ClientCode;

  Doc.Account = OpParams.Account;
  Doc.Type_Account = OpParams.Type_Account;
  Doc.Code_Currency = OpParams.Code_Currency;
  Doc.Date_Document = Doc.DepDate_Document = OpParams.DepDate = {curdate};
  if ( Doc.Code_Currency )
    Doc.IsCur = 1;
  else
    Doc.IsCur = 0;
  end;
  Doc.Oper = {oper};
  Doc.TypeOper = OpParams.Type_Oper;
  Doc.TypeComplexOper = OpParams.TypeComplexOper;
  Doc.FNCash   = Branch;


  PushGDDList;  
  State = ( ( Ret = Выполнение_операции( OpParams, Doc ) ) == 0 );
  PopGDDList;  

  if ( not State )
    SetErrorMsg( "Ошибка #" + Ret + " при проводке: Type_Oper = " + OpParams.Type_Oper );
  end;

  if ( SaveFlagCur != NumFlagCur )
    SetFlagCur( SaveFlagCur );    
  end; 
end;

/*
**  Списание суммы со счета
*/

macro GetSum( Sum, Ref )

  record OpParams( "oper_prm.1" );
  record Doc( "sbdepdoc.1" );

  ClearRecord( OpParams );
  ClearRecord( Doc );
  OpParams.Type_Oper = OpParams.TypeComplexOper = Списание_По_Раз_Поруч;
  Doc.OutSum = Sum;
  Doc.Account_Receiver = Payments.Value( 0 ).Rec.Account_Recipient;
  Doc.CorAcc_Receiver = Payments.Value( 0 ).Rec.CorAcc_Recipient;
  Doc.MFO_Receiver = Payments.Value( 0 ).Rec.RecipientBankMFO;

  DepOperation( Ref, OpParams, Doc );
end;

/*
**  Конвертация всей суммы счета. Второй счет открывается
*/

macro ConvertSum( CurRef, RubRef )

  var
    RcvAcc;

  record OpParams( "oper_prm.1" );
  record Doc( "sbdepdoc.1" );

  State = FindAccount( RubRef );
  if ( not State )
    SetErrorMsg( "Не найден счет: Ref = " + RubRef );
    return;
  end;

  RcvAcc = Dep.Account;

  State = FindAccount( CurRef );
  if ( not State )
    SetErrorMsg( "Не найден счет: Ref = " + CurRef );
    return;
  end;

  ClearRecord( OpParams );
  ClearRecord( Doc );
  OpParams.Type_Oper = OpParams.TypeComplexOper = Безналичная_Конверсия;

  Doc.Account_Receiver = RcvAcc;
  Doc.CodeCur_Receiver = 0;
  Doc.CorAcc_Receiver = ConvAccType;
  Doc.OutSum = Dep.Sum_Rest;
  Doc.CurrencyBought = Dep.Sum_Rest * Params.Rate;
  Doc.PercTrnRest = Params.Rate;
  Doc.PercTrnAlt = Params.CBRate;
  Doc.CorOper = {oper};
  DepOperation( CurRef, OpParams, Doc );
end;

/*
**  Закрытие счета
*/

macro CloseAccount( Ref, NonCash )

  record OpParams( "oper_prm.1" );
  record Doc( "sbdepdoc.1" );

  var
    Op;

  if ( NonCash )
    Op = Закрытие_Безналичными;
  else
    Op = Закрытие_Наличными;
  end;

  ClearRecord( OpParams );
  ClearRecord( Doc );
  OpParams.Type_Oper = OpParams.TypeComplexOper = Op;
  if ( NonCash )
    Doc.Account_Receiver = Payments.Value( 0 ).Rec.Account_Recipient;
    Doc.CorAcc_Receiver = Payments.Value( 0 ).Rec.CorAcc_Recipient;
    Doc.MFO_Receiver = Payments.Value( 0 ).Rec.RecipientBankMFO;
  end;

  DepOperation( Ref, OpParams, Doc );
end;

/*
**  Положить сумму существующий на счет
*/ 

macro PutSum( Sum, Ref )

  record OpParams( "oper_prm.1" );
  record Doc( "sbdepdoc.dbt" );

  ClearRecord( OpParams );
  ClearRecord( Doc );
  OpParams.Type_Oper = OpParams.TypeComplexOper = Дополнительный_Взнос;
  Doc.InSum = Sum;

  DepOperation( Ref, OpParams, Doc );
end;

/*
**  Открыть счет на заданную сумму
*/ 

macro OpenAccount( Sum, CurrCode, Ref, SvodAcc )

  record OpParams( "oper_prm.1" );
  record Doc( "sbdepdoc.dbt" );

  ClearRecord( OpParams );
  ClearRecord( Doc );
  OpParams.Type_Oper = OpParams.TypeComplexOper = Открытие_Наличными;
  OpParams.Code_Currency = CurrCode;
  OpParams.Type_Account = ConvAccType;
  Doc.InSum = Sum;
  if ( SvodAcc != null )
    OpParams.SvodAccount = SvodAcc;
  else
    OpParams.SvodAccount = NextContractNum;
  end;

  DepOperation( Ref, OpParams, Doc );
  if ( not State )
    return;
  end;

  State = FindAccountForNum( OpParams.Account );
  if ( not State )
    SetErrorMsg( "Не найден счет: " + OpParams.Account, true );
    return;
  end;

  SetParm( 2, Dep.Referenc );
end;

/*
**  Добавить счет в список
*/

macro InsertAccount( Ref )

  var
    RH = TRecHandler( "depositr.dbt" );

  State = FindAccount( Ref );
  if ( not State )
    SetErrorMsg( "Не найден счет: Ref = " + Ref, true );
    return;
  end;
  Copy( RH, Dep );
  RubAccounts.Insert( RH );
end;

/*
**  Инициализация операции
*/

macro InitOperation

  record ioParams( "op_parm.rec" );

  var
    Pm = Payments.Value( 0 );

  ClearRecord( ioParams );
  ioParams.Date = {curdate};
  ioParams.Operation = Params.Operation;
  ioParams.ObjectRef = String( Params.Group ); 

  State = InterDesk_InitDocBunch( Pm.Rec.iApplicationKind, Pm.Rec.ApplicationKey, ioParams );
  if ( not State )
    SetErrorMsg( "Ошибка при инициализации операции" );
  end;
end;

/*
**  Перечитать счет
*/

macro RereadAccount( idx )                  

  var
    Ref = RubAccounts.Value( idx ).Rec.Referenc;

  State = FindAccount( Ref );
  if ( not State )
    SetErrorMsg( "Не найден счет: Ref = " + Ref, true );
    return;
  end;
  Copy( RubAccounts.Value( idx ), Dep );
end;

/*
**  Вставка документа в список
*/

macro QueuePayDoc( idx )

  record R( "pay_doc.dbt" );

  var RubSum = Payments.Value( idx ).Rec.InSum;
  var RubGrain = Grain * Params.Rate;
  var ret_stat = true;
 
  if (SplitSum) /* Несколько счетов не превышающих RubGrain */
    while ( RubSum >= RubGrain )

      Copy( R, Payments.Value( idx ) );

      R.InSum = RubGrain;

      RubSum = RubSum - RubGrain;

      if ( RubSum != $0 )
        R.iApplicationKind = 0;
        R.ApplicationKey = "";
      end;

      ret_stat = InsertPayDocToGDDList( R );
      if (NOT ret_stat)
        return ret_stat;
      end;

    end;
  end;

  if ( RubSum != $0 )
    Copy( R, Payments.Value( idx ) );

    R.InSum = RubSum;

    ret_stat = InsertPayDocToGDDList( R );
  end; 
  
  return ret_stat;
end;

/*
**  Вернуть флаг "надо разбивать". Если он еще не определен, спросить
*/

macro QuerySplitSum

  if ( SplitSum == null )
    GetTrue( SplitSum, "Разбивать сумму на части, не превышающие $" + MaxSum +"?" )
  end;

  return SplitSum; 
end;

/*
**  Ввод данных
*/

macro DisplayUI

  ClearRecord( Params );
  Params.Group = CO_NALPER;
  Params.Operation = Op_PayForGoodies;
  Params.CurrCode = BaseCurr;
  Params.RateKind = DefRateKind;

  if ( not CompoundPaymentUI( Params ) )
    OC_RESULT = 1;
    Exit( 1 );
  end;

  if ( Params.FromClientRub > Params.ChangeRub)
    Params.FromClientRub = Params.FromClientRub - Params.ChangeRub;
    Params.ChangeRub = $0;
  else 
    Params.ChangeRub = Params.ChangeRub - Params.FromClientRub;
    Params.FromClientRub = $0;
  end;
end;

macro PmCmp( Pm1, Pm2 )

  return Pm1.Rec.InSum > Pm2.Rec.InSum;
end;

/*
**  Перенести платежи из временного файла в массив и отсортировать
*/

macro ReadPayments


  file TmpPm( "pay_doc.dbt" );

  var 
    RH, 
    FileName = "pay_doc." + {CNum};

  if( not Open( TmpPm, FileName ) )
    ExitOnError( "Файл не открыт: " + FileName );
  end;

  Rewind( TmpPm );
  while ( Next( TmpPm ) )
    RH = TRecHandler( "pay_doc.dbt" );
    Copy( RH, TmpPm );  
    Payments.Insert( RH );
  end;

  Payments.Sort( "PmCmp" );

  /* Иначе не выпустятся отчеты */
  if ( Payments.Size )
    OC_PAY_DOC.iApplicationKind = Payments.Value( 0 ).Rec.iApplicationKind;
    OC_PAY_DOC.ApplicationKey = Payments.Value( 0 ).Rec.ApplicationKey;
  end;
end;

/*
**  Самые мелкие платежи провести рублями
*/

macro CarryPaymentsWithoutConversion

  var 
    Sum, 
    i = Payments.Size - 1;
  
  while ( i >= 0 )
    Sum = Payments.Value( i ).Rec.InSum; 

    if ( Sum > Params.FromClientRub )
      return;
    end;
   
    if ( not ( State = QueuePayDoc( i ) ) )
      SetErrorMsg( "Ошибка при добавлении документа в список" );
      return;
    end;
    
    Payments.Remove( i );
    Params.FromClientRub = Params.FromClientRub - Sum;
    i = i - 1;
  end;
end;

/*
**  Открытие одного валютного счета
**  Безналичная конверсия на рублевый счет
**  Закрытие валютного счета
*/

macro ConvertSumThruAccounts( Sum )

  var
    Ref, RubRef;

  OpenAccount( Sum, Params.CurrCode, Ref );
  if ( not State )
    return;
  end;

  OpenAccount( $0, 0, RubRef, Dep.SvodAccount );
  if ( not State )
    return;
  end;

  ConvertSum( Ref, RubRef );
  if ( not State )
    return;
  end;

  CloseAccount( Ref, true );
  if ( not State )
    return;
  end;

  InsertAccount( RubRef );
end;

/*
**  Открытие счетов и конверсия
*/

macro DoNonCashConversion

  var
    CurSum = Params.FromClientCur - Params.ChangeCur, 
    Ref, RubRef;

  if ( CurSum == $0 )
    return;
  end;

  if ( SplitSum )
    if ( OpenMultipleAccounts )
      while ( CurSum >= Grain ) 
        ConvertSumThruAccounts( Grain ); 
        if ( not State )
          return;
        end;
        CurSum = CurSum - Grain;
      end;
      if ( CurSum != $0 )
        ConvertSumThruAccounts( CurSum ); 
        if ( not State )
          return;
        end;
      end; 
    else
      if ( CurSum > Grain )
        OpenAccount( Grain, Params.CurrCode, Ref ); 
        if ( not State )
          return;
        end;
        OpenAccount( $0, 0, RubRef, Dep.SvodAccount ); 
        if ( not State )
          return;
        end;
    
        CurSum = CurSum - Grain;
        while ( CurSum >= Grain ) 
          PutSum( Grain, Ref ); 
          if ( not State )
            return;
          end;
          ConvertSum( Ref, RubRef );
          if ( not State )
            return;
          end;
          CurSum = CurSum - Grain;
        end;
        if ( CurSum != $0 )
          PutSum( CurSum, Ref ); 
          if ( not State )
            return;
          end;
          ConvertSum( Ref, RubRef );
          if ( not State )
            return;
          end;
        end; 
      else
        OpenAccount( CurSum, Params.CurrCode, Ref ); 
        if ( not State )
          return;
        end;
        OpenAccount( $0, 0, RubRef, Dep.SvodAccount ); 
        if ( not State )
          return;
        end;
    
        ConvertSum( Ref, RubRef );
        if ( not State )
          return;
        end;
      end;
  
      CloseAccount( Ref, true );
      if ( not State )
        return;
      end;
      InsertAccount( RubRef ); 
      if ( not State )
        return;
      end;
    end;
  else		/* Ничего не разбивать */
    
    OpenAccount( CurSum, Params.CurrCode, Ref ); 
    if ( not State )
      return;
    end;
    OpenAccount( $0, 0, RubRef, Dep.SvodAccount ); 
    if ( not State )
      return;
    end;
    ConvertSum( Ref, RubRef );
    if ( not State )
      return;
    end;
    CloseAccount( Ref, true );
    if ( not State )
      return;
    end;
    InsertAccount( RubRef ); 
    if ( not State )
      return;
    end;
  end;
end;

/*
**  Дозачисление рублей
*/ 

macro PutRub

  var
    MaxRubSum = MaxSum * Params.Rate, 
    RubGrain = Grain * Params.Rate, 
    LastAcc = null,  
    RubSum = Params.FromClientRub, 
    Tmp, Ref;

  if ( RubSum == $0 )
    return;
  end;

  if ( RubAccounts.Size == 0 )
    if ( not OnlyThruAccounts )
      return;
    end;
  else
    LastAcc = RubAccounts.Value( RubAccounts.Size - 1 );
  end;

  if ( LastAcc and ( ( not SplitSum ) or ( LastAcc.Rec.Sum_Rest + RubSum < MaxRubSum ) ) )
    PutSum( RubSum, LastAcc.Rec.Referenc );  
    if ( not State )
      return;
    end;
    RereadAccount( RubAccounts.Size - 1 );  
    if ( not State )
      return;
    end;
  else
    if ( LastAcc and ( LastAcc.Rec.Sum_Rest < RubGrain ) )
      Tmp = RubGrain - LastAcc.Rec.Sum_Rest;
      PutSum( Tmp, LastAcc.Rec.Referenc );  
      if ( not State )
        return;
      end;
      RereadAccount( RubAccounts.Size - 1 );  
      if ( not State )
        return;
      end;
      RubSum = RubSum - Tmp;
    end;

    if (SplitSum) /* Несколько счетов не превышающих RubGrain */
      while ( RubSum >= RubGrain )
        OpenAccount( RubGrain, 0, Ref );  
        if ( not State )
          return;
        end;
        InsertAccount( Ref );
        if ( not State )
          return;
        end;
        RubSum = RubSum - RubGrain;
      end;
    end;

    if ( RubSum != $0 )
      OpenAccount( RubSum, 0, Ref );  
      if ( not State )
        return;
      end;
      InsertAccount( Ref );
    end; 
  end;
end;

macro AccCmp( Acc1, Acc2 )
  return Acc1.Rec.Sum_Rest > Acc2.Rec.Sum_Rest;
end;

/*
**  Проводка одного (нулевого в списке) платежа
*/

macro CarryPayment

  var
    PmSum = Payments.Value( 0 ).Rec.InSum, 
    MaxRubSum = MaxSum * Params.Rate, 
    RubGrain = Grain * Params.Rate;

  if ( SplitSum )
    if ( OpenMultipleAccounts )
      RubAccounts.Sort( "AccCmp" );
      while ( RubAccounts.Size and ( PmSum >= RubAccounts.Value( 0 ).Rec.Sum_Rest ) )
        CloseAccount( RubAccounts.Value( 0 ).Rec.Referenc, true );
        if ( not State )
          return;
        end;
        PmSum = PmSum - RubAccounts.Value( 0 ).Rec.Sum_Rest;
        RubAccounts.Remove( 0 ); 
      end;  
  
      if ( PmSum > $0 )
        GetSum( PmSum, RubAccounts.Value( 0 ).Rec.Referenc );
        if ( not State )
          return;
        end;
        RereadAccount( 0 );  
        if ( not State )
          return;
        end;
      end;
    else
      if ( PmSum > MaxRubSum )
        while ( PmSum > RubGrain )
          GetSum( RubGrain, RubAccounts.Value( 0 ).Rec.Referenc );
          if ( not State )
            return;
          end;
          RereadAccount( 0 );  
          PmSum = PmSum - RubGrain; 
        end; 
      end;
  
      if ( PmSum != $0 )
        if ( PmSum < RubAccounts.Value( 0 ).Rec.Sum_Rest )
          GetSum( PmSum, RubAccounts.Value( 0 ).Rec.Referenc );
          if ( not State )
            return;
          end;
          RereadAccount( 0 );  
        else
          CloseAccount( RubAccounts.Value( 0 ).Rec.Referenc, true );
          if ( not State )
            return;
          end;
          RubAccounts.Remove( 0 ); 
        end; 
      end;
    end;
  else         /* Ничего не разбивать */
    if ( PmSum < RubAccounts.Value( 0 ).Rec.Sum_Rest )
      GetSum( PmSum, RubAccounts.Value( 0 ).Rec.Referenc );
      if ( not State )
        return;
      end;
      RereadAccount( 0 );  
    else
      CloseAccount( RubAccounts.Value( 0 ).Rec.Referenc, true );
      if ( not State )
        return;
      end;
      RubAccounts.Remove( 0 ); 
    end; 
  end;

  Payments.Value( 0 ).Rec.ApplType = SubOp_WithConversion;
  Payments.Value( 0 ).Rec.VidDoc = 1;
  if ( not ( State = QueuePayDoc( 0 ) ) )
    SetErrorMsg( "Ошибка при добавлении документа в список" );
  end;
end;

/*
**  Проводка платежей с конверсией 
*/

macro CarryPaymentsWithConversion

  while ( Payments.Size )
    CarryPayment;
    if ( not State )
      return;
    end;
    Payments.Remove( 0 ); 
  end;
end;

/*
** Закрытие оставшихся счетов наличными 
*/

macro CloseRubAccounts

  while ( RubAccounts.Size )
    CloseAccount( RubAccounts.Value( 0 ).Rec.Referenc );
    if ( not State )
      return;
    end;
    RubAccounts.Remove( 0 ); 
  end;
end;

/* 
**  Транзакционная процедура
*/

macro TrnProc  

  /* Инициализация операции */
  InitOperation;

  if ( State )
    ReadContractNum;
  end;

  /* Проводка самих мелких платежей рублями */
  
  if ( State and ( not OnlyThruAccounts ) )
    CarryPaymentsWithoutConversion;
  end;

  if ( Payments.Size == 0 )
    return;			/* Все уже оплачено */
  end;

  /* Открытие счета(ов) и конвертация */
  if ( State )
    DoNonCashConversion;
  end;

  /* Дозачисление рублей (возможно, с появлением новых счетов) */
  if ( State )
    PutRub;
  end;

  /* Проводка платежей с конверсией */
  if ( State )
    CarryPaymentsWithConversion;
  end;

  /* Закрытие оставшихся счетов наличными */
  if ( State )
    CloseRubAccounts;
  end;

  /* Проводка списка наличных документов */
  if ( State )
    if ( CarryGDDList( TYPE_PayDoc ) != 0 )
      State = false;
    end;
  end;

  if ( not State )
    AbortTrn;
  else
    WriteContractNum;
  end;

  return State;
end;

/*
**  Транзакция оплаты с безн. конверсией
*/

macro DoTrn

  ProcessTrn( 1, "TrnProc", DepParm, Dep );

  if ( not State )
    ExitOnError;
  end;
end;

private macro CheckOnDate()
var stat, rubDate;

  DepParm.FNCash = Branch;
  DepParm.FlagCur = 0;
  stat = GetEQ( DepParm );
  if( stat )
    rubDate = DepParm.OperDate;
    DepParm.FNCash = Branch;
    DepParm.FlagCur = 1;
    stat = GetEQ( DepParm );
    if( stat and (rubDate != DepParm.OperDate) )
      stat = false;
    end;
  end;

  return stat;
end;

/*
**  Голова
*/
var prev_confirm = AutoConfirm(AC_STRONG),
    kass;

  OC_RESULT = 1;

  if( CheckOnDate() )
    GetLinkedKassir(SB_DEPOSIT,kass,0);
    if( kass == 0 )
      GetLinkedKassir(SB_DEPOSIT,kass,1);
    end;
    if(kass == 0)
      msgbox("Не задан связанный кассир! Операция прервана!");
    else

      /* Ввод данных пользователем */
      DisplayUI;

      /* Перенос платежей из временного файла с сортировкой по убыванию сумм */
      ReadPayments;

      if ( Payments.Size == 0 )
        return;
      end;

      /* Запрос на необходимость разбиения */
      if ( Params.Total >= MaxSum * Params.Rate )
        QuerySplitSum;
      end; 

      if ( CarryMode == 0 )
        OnlyThruAccounts = false;
      elif ( CarryMode == 1 )
        OnlyThruAccounts = true;
      elif ( CarryMode == 2 )
        if ( Params.FromClientRub > $0 )
          OnlyThruAccounts = not GetTrue( true, "Провести рублевую сумму наличными?" );
        else
          OnlyThruAccounts = false;
        end;
      end;

      /* Транзакция оплаты с конверсией */
      DoTrn;

      OC_RESULT = 2;
    end;
  else
    msgbox("Даты опердней в рублях и в валюте не совпадают! Операция прервана!");
  end;
  AutoConfirm(prev_confirm);    
end;
