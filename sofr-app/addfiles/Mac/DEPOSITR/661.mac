/*
  Создан 04.04.01 пока только для счетов типа "Ф"
*/

import deprintr, issrvdoc;

var ddep = TRecHandler( "i_dp_dep.rec" );
file dr( "depositr.dbt" ) key 9999;
file dt( "sb_dtyp.dbt"  ) key 9999;
file dd( "sbdepdoc.dbt" );

array KTypes; /* Виды вкладов для кот.установлен признак типа "К" */
array NTypes; /* Виды вкладов для кот.установлен признак типа "Н" */
array FTypes; /* Виды вкладов для кот.установлен признак типа "Ф" */

array TypeKDebitTurns,
      TypeKCreditTurns;
array TypeNDebitTurns,
      TypeNCreditTurns;
array TypeFDebitTurns,
      TypeFCreditTurns;

var   TypeKBeginCreditRests = $0.0L;
var   TypeNBeginCreditRests = $0.0L;
var   TypeFBeginCreditRests = $0.0L;
var   ClientList = TClientList;

const
  D_IN = 1,         /* Приход */
  D_OUT = 2,        /* Расход */
  D_GET = 3,        /* Списание */
  D_PUT = 5;        /* Зачисление */

const
  BS_BRANCH  = 0,  /* Филиал */
  BS_DEP     = 1,  /* Отделение */
  BS_EXCH    = 2,  /* Обменный пункт */
  BS_OPERDEP = 3;  /* Оперчасть */

private var
  {Name_Bank},
  {NumberBranch},
  {Post_Addr},
  panelDate,
  branch = numfncash,
  statusBranch,
  startDate, endDate;

macro define_brtyp;

  if( not findDepartment(branch, null, ddep) )
    exit( 1 );
  else
    statusBranch = ddep.rec.NodeType;
  end;
end;

macro filterBranch( num );

  if( statusBranch == I_DEPARTMENT_TYPE_FILIAL )
    return true;
  else
    if( branch == num )
      return true;
    end;
  end;
  return false;
end;

macro define_dates;

  var d, m, y, tmpdate, d1, m1, y1;
  datesplit( panelDate, d, m, y );
  startDate = date( 1, m, y );
  if  ( d <= 10 )
    endDate = date( 10, m, y );
  elif( ( d > 10 ) and ( d <= 20 ) )
    endDate = date( 20, m, y );
  else
   tmpDate = startDate + 35; /* Дата, заведомо принадлежащая к след. месяцу */
   datesplit( tmpdate, d1, m1, y1 );
   endDate = date( 1, m1, y1 ) - 1;
  end;
end;

macro define_typesK;

  var f = 0;
  rewind( dt );
  while( next( dt ) )
    if( ( dt.FlagCur == 0 ) and ( index( dt.UserTypeAccount, "К" ) ) )
      KTypes( f ) = dt.Kind;
      f = f + 1;
    end;
  end;
end;

macro define_typesN;

  var f = 0;
  rewind( dt );
  while( next( dt ) )
    if( ( dt.FlagCur == 0 ) and ( index( dt.UserTypeAccount, "N" ) ) )
      NTypes( f ) = dt.Kind;
      f = f + 1;
    end;
  end;
end;

macro define_typesF;

  var f = 0;
  rewind( dt );
  while( next( dt ) )
    if( ( dt.FlagCur == 0 ) and ( index( dt.UserTypeAccount, "Ф" ) ) )
      FTypes( f ) = dt.Kind;
      f = f + 1;
    end;
  end;
end;

/* Определение резидентности клиента */
macro getClientCS( code );

  if ( ClientList.GetRecord( code ) )
    return ClientList.CurRec.Rec.NotResident;
  else
    return "";
  end;
end;

macro isKType( type );

  var i = 0;
  while( i < asize( KTypes ) )
    if( KTypes( i ) == type )
      return true;
    end;
    i = i + 1;
  end;
  return false;
end;

macro isNType( type );

  var i = 0;
  while( i < asize( NTypes ) )
    if( NTypes( i ) == type )
      return true;
    end;
    i = i + 1;
  end;
  return false;
end;

macro isFType( type );

  var i = 0;
  while( i < asize( FTypes ) )
    if( FTypes( i ) == type )
      return true;
    end;
    i = i + 1;
  end;
  return false;
end;

macro zerofy_arrayK;

  var i = 0;
  while( i < 700 )
    TypeKDebitTurns( i ) = $0.0L;
    TypeKCreditTurns( i ) = $0.0L;
    i = i + 1;
  end;
end;

macro zerofy_arrayN;

  var i = 0;
  while( i < 700 )
    TypeNDebitTurns( i ) = $0.0L;
    TypeNCreditTurns( i ) = $0.0L;
    i = i + 1;
  end;
end;

macro zerofy_arrayF;

  var i = 0;
  while( i < 700 )
    TypeFDebitTurns( i ) = $0.0L;
    TypeFCreditTurns( i ) = $0.0L;
    i = i + 1;
  end;
end;

macro prepare;

  define_brtyp;
  define_dates;
  define_typesK;
  define_typesN;
  define_typesF;
  zerofy_arrayK;
  zerofy_arrayN;
  zerofy_arrayF;
end;

macro Остаток_на_начало_дня;
/* (c) Lebedevs */

  var stat, rest = 0;
  dd.Referenc = dr.Referenc;
  dd.Date_Document = startDate;
  dd.NumDayDoc = 1;
  stat = getLE( dd );
  if( stat and ( dd.Referenc == dr.Referenc ) )
    if( dd.Date_Document < startDate )
      rest = dd.Rest;
    else
      stat = Prev( dd );
      if( stat and ( dd.Referenc == dr.Referenc ) )
        rest = dd.Rest;
      end;
    end;
  end;
  return rest;
end;

macro define_begin_rests;

  keynum( dd, 6 );
  rewind( dr );
  while( next( dr ) );
    if( filterBranch( dr.FNcash ) )
      if( ( dr.Open_Close == StrFor( 0 ) ) or ( dr.Close_Date >= startDate ) )
        if( ( isKType( dr.Type_Account )  or   /* Счет типа "К" */
              isNType( dr.Type_Account )  or   /* Счет типа "Н" */
              isFType( dr.Type_Account ) ) and /* Счет типа "Ф" */
            ( getClientCS( dr.CodClient ) != "" ) )  /* Клиент - нерезидент */
          if( isKType( dr.Type_Account ) )
            TypeKBeginCreditRests = TypeKBeginCreditRests + Остаток_на_начало_дня;
          end;
          if( isNType( dr.Type_Account ) )
            TypeNBeginCreditRests = TypeNBeginCreditRests + Остаток_на_начало_дня;
          end;
          if( isFType( dr.Type_Account ) )
            TypeFBeginCreditRests = TypeFBeginCreditRests + Остаток_на_начало_дня;
          end;
        end;
      end;
    end;
  end;
end;

macro define_turns;

  var stat;
  keynum( dd, 5 );
  dd.Date_Document = startDate;
  stat = getGE( dd );
  while( stat and ( dd.Date_Document <= endDate ) )
    if( IsServDoc( dd )             and
        filterBranch( dd.FNcash )   and
        ( isKType( dd.Type_Account )  or   /* Счет типа "К" */
          isNType( dd.Type_Account )  or   /* Счет типа "Н" */
          isFType( dd.Type_Account ) ) and /* Счет типа "Ф" */
        ( getClientCS( dr.CodClient ) != "" ) )  /* Клиент - нерезидент */
      if ( isKType( dd.Type_Account ) )     /* Счет типа "К" */
        if  ( ( dd.KindOp == D_OUT )  or ( dd.KindOp == D_GET ) )
          TypeKDebitTurns( dd.KNFCode ) = TypeKDebitTurns( dd.KNFCode ) + dd.OutSum;
        elif( ( dd.KindOp == D_IN  )  or ( dd.KindOp == D_PUT ) )
          TypeKCreditTurns( dd.KNFCode ) = TypeKCreditTurns( dd.KNFCode ) + dd.InSum;
        end;
      end;
      if ( isNType( dd.Type_Account ) )     /* Счет типа "Н" */
        if  ( ( dd.KindOp == D_OUT )  or ( dd.KindOp == D_GET ) )
          TypeNDebitTurns( dd.KNFCode ) = TypeNDebitTurns( dd.KNFCode ) + dd.OutSum;
        elif( ( dd.KindOp == D_IN  )  or ( dd.KindOp == D_PUT ) )
          TypeNCreditTurns( dd.KNFCode ) = TypeNCreditTurns( dd.KNFCode ) + dd.InSum;
        end;
      end;
      if ( isFType( dd.Type_Account ) )     /* Счет типа "Ф" */
        if  ( ( dd.KindOp == D_OUT )  or ( dd.KindOp == D_GET ) )
          TypeFDebitTurns( dd.KNFCode ) = TypeFDebitTurns( dd.KNFCode ) + dd.OutSum;
        elif( ( dd.KindOp == D_IN  )  or ( dd.KindOp == D_PUT ) )
          TypeFCreditTurns( dd.KNFCode ) = TypeFCreditTurns( dd.KNFCode ) + dd.InSum;
        end;
      end;
    end;
    stat = next( dd );
  end;
end;

macro round_1000( sum );

  return Int( Floor( Double( sum )/1000 + 0.5 ) );
end;

macro report;

  var namestr = "", address = "", i = 0, groupTurns;
  var GroupDebitTotalK = $0.0L, GroupCreditTotalK = $0.0L,
      DebitTotalK = $0.0L, CreditTotalK = $0.0L;
  var GroupDebitTotalN = $0.0L, GroupCreditTotalN = $0.0L,
      DebitTotalN = $0.0L, CreditTotalN = $0.0L;
  var GroupDebitTotalF = $0.0L, GroupCreditTotalF = $0.0L,
      DebitTotalF = $0.0L, CreditTotalF = $0.0L;

  namestr = {Name_Bank} + " " + {NumberBranch};
  if( statusBranch != I_DEPARTMENT_TYPE_FILIAL )
    namestr = namestr + " Филиал " + ddep.rec.Name;
  end;
  address = {Post_Addr};

  [

                                                               ОТЧЕТ

                             об операциях по банковским счетам нерезидентов в валюте Российской Федерации
                                                    за период с ########## по ##########

              Наименование кредитной организации  #
              Почтовый адрес  #
  ]
  ( startDate, endDate, namestr, address );
  [
                                                                                                                                            Форма № 661
                                                                                                                                               Декадная

                                                                                                                                               тыс.руб.
   -----------------------------------------------------------------------------------------------------------------------------------------------------
   |                      |                                      Сумма оборотов по счетам и видам операций:                                            |
   | Цифровое обозначение |-----------------------------------------------------------------------------------------------------------------------------
   |  операции и группы   |     Счета типа "К"     |      Счета типа "Н"    | Счета типа "К" банков- | Счета типа "Н" банков- |    Счета типа "Ф"      |
   |       операций       |                        |                        |      нерезидентов      |      нерезидентов      |                        |
   |                      |-----------------------------------------------------------------------------------------------------------------------------
   |                      | по дебету | по кредиту | по дебету | по кредиту | по дебету | по кредиту | по дебету | по кредиту | по дебету | по кредиту |
   |----------------------|-----------------------------------------------------------------------------------------------------------------------------
   | Кредитовые остатки по|           |            |           |            |           |            |           |            |           |            |
   | счетам на начало     |           |############|           |############|           |            |           |            |           |############|
   | отчетного периода    |           |            |           |            |           |            |           |            |           |            |
   -----------------------------------------------------------------------------------------------------------------------------------------------------
  ]
  ( round_1000( TypeKBeginCreditRests ):z,
    round_1000( TypeNBeginCreditRests ):z,
    round_1000( TypeFBeginCreditRests ):z );
  groupTurns = false;
  while( i <= 700 )
    if( TypeKDebitTurns( i ) or TypeKCreditTurns( i ) or
        TypeNDebitTurns( i ) or TypeNCreditTurns( i ) or
        TypeFDebitTurns( i ) or TypeFCreditTurns( i ) )
      [| ###                  |###########|############|###########|############|           |            |           |            |###########|############|]
      ( i,
        round_1000( TypeKDebitTurns( i ) ), round_1000( TypeKCreditTurns( i ) ),
        round_1000( TypeNDebitTurns( i ) ), round_1000( TypeNCreditTurns( i ) ),
        round_1000( TypeFDebitTurns( i ) ), round_1000( TypeFCreditTurns( i ) ) );
      [|----------------------|-----------------------------------------------------------------------------------------------------------------------------];
      groupTurns = true;
      GroupDebitTotalK = GroupDebitTotalK + TypeKDebitTurns( i );
      GroupCreditTotalK = GroupCreditTotalK + TypeKCreditTurns( i );
      DebitTotalK = DebitTotalK + TypeKDebitTurns( i );
      CreditTotalK = CreditTotalK + TypeKCreditTurns( i );
      GroupDebitTotalN = GroupDebitTotalN + TypeNDebitTurns( i );
      GroupCreditTotalN = GroupCreditTotalN + TypeNCreditTurns( i );
      DebitTotalN = DebitTotalN + TypeNDebitTurns( i );
      CreditTotalN = CreditTotalN + TypeNCreditTurns( i );
      GroupDebitTotalF = GroupDebitTotalF + TypeFDebitTurns( i );
      GroupCreditTotalF = GroupCreditTotalF + TypeFCreditTurns( i );
      DebitTotalF = DebitTotalF + TypeFDebitTurns( i );
      CreditTotalF = CreditTotalF + TypeFCreditTurns( i );
    end;
    if( ( i == 200 ) or ( i == 300 ) or ( i == 400 ) or ( i == 500 ) or ( i == 600 ) or ( i == 700 ) )
      if( groupTurns )
        [| ИТОГО по группе ###  |###########|############|###########|############|           |            |           |            |###########|############|]
        ( i - 100,
          round_1000( GroupDebitTotalK ), round_1000( GroupCreditTotalK ),
          round_1000( GroupDebitTotalN ), round_1000( GroupCreditTotalN ),
          round_1000( GroupDebitTotalF ), round_1000( GroupCreditTotalF ) );
        [|----------------------|-----------------------------------------------------------------------------------------------------------------------------];
      end;
      groupTurns = false;
    end;
    i = i + 1;
  end;
  [| ВСЕГО сумма оборотов |###########|############|###########|############|           |            |           |            |###########|############|
   | счетам               |           |            |           |            |           |            |           |            |           |            |]
  ( round_1000( DebitTotalK ), round_1000( CreditTotalK ),
    round_1000( DebitTotalN ), round_1000( CreditTotalN ),
    round_1000( DebitTotalF ), round_1000( CreditTotalF ) );
  [|----------------------|-----------------------------------------------------------------------------------------------------------------------------];
  [| Кредитовые остатки   |           |############|           |############|           |            |           |            |           |############|
   | по счетам на конец   |           |            |           |            |           |            |           |            |           |            |
   | отчетного периода    |           |            |           |            |           |            |           |            |           |            |]
  ( round_1000( TypeKBeginCreditRests + CreditTotalK - DebitTotalK ),
    round_1000( TypeNBeginCreditRests + CreditTotalN - DebitTotalN ),
    round_1000( TypeFBeginCreditRests + CreditTotalF - DebitTotalF ) );
  [|----------------------|-----------------------------------------------------------------------------------------------------------------------------];
  [
    Зав.филиалом (контролер)                               (Ф.И.О.)
  ];
end;

/* Точка входа */
panelDate = {curdate};
getdate( panelDate, "Введите дату:" );
prepare;
define_begin_rests;
define_turns;
report;
end.
