
/* Проверки при открытии операционного дня */

import deprintr, "chk_prol.mac", chk_clup, RSD, SQLConv;

file DepType  (sb_dtyp ) key 2;
file ApplType (pc_apltp) key 1;
file depparm  (depparm ) key 0;
file pc_rdate (pc_rdate);
file pc_alg   (pc_alg)   key 0;
file doc ( "sbdepdoc.dbt" ) key 6;

array ApTypes,ApCode;
 ApTypes(1) = "по осн. условиям";   ApCode(1) = 2001;
 ApTypes(2) = "по альт. условиям";  ApCode(2) = 2002;
 ApTypes(3) = "по овердрафту";      ApCode(3) = 2003;
 ApTypes(4) = "по доп. взносам";    ApCode(4) = 2004;

var {curdate};
var  Dep_Found     = FALSE;
var  DepType_Found = FALSE;
var  cnt;

private var cmdOpen, rsOpen;

private macro getLastDayInMonth( m, y )
  array DayInMonth;
  DayInMonth( 0  ) = 0;
  DayInMonth( 1  ) = 31;
  DayInMonth( 2  ) = 28;
  DayInMonth( 3  ) = 31;
  DayInMonth( 4  ) = 30;
  DayInMonth( 5  ) = 31;
  DayInMonth( 6  ) = 30;
  DayInMonth( 7  ) = 31;
  DayInMonth( 8  ) = 31;
  DayInMonth( 9  ) = 30;
  DayInMonth( 10 ) = 31;
  DayInMonth( 11 ) = 30;
  DayInMonth( 12 ) = 31;

  var day = DayInMonth( m );

  if ( ( m == 2 ) and ( y != null ) )
    if ( ( mod( y, 4 )    == 0 ) and
         ( mod( y, 100 )  != 0 ) or
         ( mod( y, 400 )  == 0 ) )
      day = 29;
    end;
  end;

  return day;
end;

/*******************************************************************
                    Поиск параметров для филиала
*******************************************************************/
macro FindDepParm

  ReWind(depparm);
  depparm.FNCash  = FNCash;
  depparm.FlagCur = FlagCur;

  return GetEQ(depparm);

end;


/*******************************************************************
        Определение даты текущего расчета (оплаты) процентов
*******************************************************************/
macro WorkWithDate
(
 Cur_Date, /* Дата, от которой идет расчет (текущая)                        */
 Graf,     /* Стратегия расчета (оплаты)                                    */
 Day,      /* День расчета (если стратегия - заданного числа каждого месяца */
 GrafDate  /* Выход - дата следующего расчета (оплаты)                      */
)

  var stat = TRUE;
  var d,m,y;
  var lastD;

  DateSplit(Cur_Date,d,m,y);
  GrafDate = Date(0,0,0);
  /* В конце дня  */
  if (Graf == 1)
    GrafDate = Cur_Date;
  /* В конце месяца */
  elif (Graf == 2)
    if (m == 12)
      m = 1;
      y = y + 1;
    else
      m = m + 1;
    end;
    GrafDate = Date(1,m,y) - 1;
  /* В конце квартала */
  elif (Graf == 3)
    if (m > 9)
      m = 1;
      y = y + 1;
    elif (m > 6)
      m = 10;
    elif (m > 3)
      m = 7;
    else
      m = 4
    end;
    GrafDate = Date(1,m,y) - 1;
  /* В конце года */
  elif (Graf == 4)
    GrafDate = Date(31,12,y);
  /* Day числа каждого месяца */
  elif (Graf == 5)
    if (Day > 0)
      if (d > Day)
        m = m + 1;
        if (m > 12)
          m = 1;
          y = y + 1;
        end;
      end;
      lastD = getLastDayInMonth( m,y );
      if ( Day > lastD )
        Day = lastD;
      end;
      GrafDate = Date(Day,m,y);
    end;
  end;
  SetParm(3,GrafDate);

  return stat;

end;


/*******************************************************************
Шапка отчета по вкладам, проценты по счетам которых не были рассчитаны
*******************************************************************/
macro Calc_OutHead;

  [ ];
  [ Виды вкладов с истекшей датой расчета процентов];
  [ ];

end;


/*******************************************************************
Шапка отчета по вкладам, проценты по счетам которых не были оплачены
*******************************************************************/
macro Pay_OutHead

  [ ];
  [ Виды вкладов с истекшей датой оплаты процентов];
  [ ];

end;


/*******************************************************************
                       Шапка отчета по вкладам
*******************************************************************/
macro DepType_OutHead;

  [+------------+--------------------------+----------+];
  [| Вид вклада |     Счет процентов       |   Дата   |];
  [+------------+--------------------------+----------+];

end;


/*******************************************************************
                      Строка отчета по вкладам
*******************************************************************/
macro DepType_OutLine (DateReport, IsChangeRate)

  var Notes = ApTypes(ApplType.ApplType - 2000);

  if (IsChangeRate)
    Notes = Notes + " (смена ставки)";
  end;

  [|############|##########################|##########|]
  (ApplType.Type,Notes:w,DateReport);

end;


/*******************************************************************
        Строка отчета по вкладам (для относительного графика)
*******************************************************************/
macro DepType_OutLine_Otn (IsPay)

  var Notes = "Нерасчитанные счета";

  if (IsPay)
    Notes = "Неоплаченные счета";
  end;


  [|############|##########################|график    |]
  (DepType.Kind,Notes:w);

end;


/*******************************************************************
                          Окончание отчета
*******************************************************************/
macro BottomDepTypeReport

  [+------------+--------------------------+----------+];

end;


/*******************************************************************
              Цикл по различным условиям по виду вклада
*******************************************************************/
macro DepType_RepForCurApplType (DateReport, IsChangeRate)

  var rec_found;

  /*****************************************/
  macro FindOperForType

    file sb_typop (sb_typop) key 0;
    var RetValue = FALSE;

    sb_typop.IsCur    = ApplType.IsCur;
    sb_typop.Kind     = ApplType.Type;
    sb_typop.NumOpert = 0;

    if (GetGE(sb_typop))
      if ((sb_typop.IsCur == ApplType.IsCur) AND
          (sb_typop.Kind  == ApplType.Type )    )
        RetValue = TRUE;
      end;
    end;

    return RetValue;

  end;
  /*****************************************/

  ApplType.IsCur  = DepType.FlagCur;
  ApplType.ApType = DepType.Kind;
  rec_found = GetEQ(ApplType);

  while (rec_found)
    if (ApplType.ApType == DepType.Kind)
      if ((ApplType.ApplType >= 2001) AND (ApplType.ApplType <= 2004))
        if (FindOperForType())
          DepType_Found = TRUE;
          DepType_OutLine(DateReport,IsChangeRate);
          cnt = cnt + 1;
        end;
      end;
      rec_found = Next(ApplType);
    else
      rec_found = FALSE;
    end;
  end;

end;


/**********************************************************/

macro GetLastPcAlg (Kind)
  pc_alg.FlagCur    = FlagCur;
  pc_alg.Referenc   = Kind;
  pc_alg.ObjectType = 1003;
  pc_alg.BegDate    = {curdate};
  return (GetLE(pc_alg) AND (pc_alg.FlagCur    == FlagCur) AND
                            (pc_alg.Referenc   == Kind)    AND
                            (pc_alg.ObjectType == 1003) )
end;
/*******************************************************************
     Цикл по видам вкладов для отчета о нерассчитанных вкладах
*******************************************************************/
macro Calc_SubReport

  var rec_found;
  var DateNextCalc;
  var DateLastCalc = depparm.C_Date;
  var WasWriteToReport;
  var i;

  Message(" Определение вкладов с истекшей датой расчета ...");

  if (DateLastCalc == Date(0,0,0))
     DateLastCalc = {curdate} - 1;
  end;

  if (DateLastCalc != Date(0,0,0))

    if (depparm.C_State == StrFor(2))
      DateLastCalc = DateLastCalc + 1;
    end;

    if ((depparm.C_State == StrFor(2) ) AND
        (DateLastCalc    == {curdate})    )
      ;
    else
      KeyNum(DepType,2);
      DepType.FlagCur = FlagCur;
      DepType.Kind    = "";
      rec_found = GetGE(DepType);
      while (rec_found)
        if (DepType.FlagCur == FlagCur)
          if (GetLastPcAlg (DepType.Kind))
            WasWriteToReport = FALSE;
            /* Проверка для вкладов с видом графика "По виду вклада" */
            if ((pc_alg.GrafCalc != 0) OR (pc_alg.DayCalc != 0))
              WorkWithDate(DateLastCalc,pc_alg.GrafCalc,pc_alg.DayCalc,DateNextCalc);
              if ((DateNextCalc < {curdate}) AND (DateNextCalc != Date(0,0,0)))
                DepType_RepForCurApplType(DateNextCalc,FALSE);
                WasWriteToReport = TRUE;
              end;
            end;
            /* Проверка для вкладов с видом графика "Относительный" */
            if (WasWriteToReport == FALSE)
              i = 1;
              while (i < ASize(ApCode))
                KeyNum(pc_rdate,0);
                ReWind(pc_rdate);
                pc_rdate.FlagCur      = DepType.FlagCur;
                pc_rdate.Type_Account = DepType.Kind;
                pc_rdate.ObjectType   = ApCode(i);
                pc_rdate.DateCalc     = {curdate};
                if (GetLT(pc_rdate))
                  if ((pc_rdate.FlagCur      == DepType.FlagCur) AND
                      (pc_rdate.Type_Account == DepType.Kind   ) AND
                      (pc_rdate.ObjectType   == ApCode(i)      )    )
                    if (pc_rdate.DateCalc != Date(0,0,0))
                      DepType_OutLine_Otn(FALSE);
                      cnt = cnt + 1;
                      DepType_Found = TRUE;
                      WasWriteToReport = TRUE;
                      i = ASize(ApCode);
                    end;
                  end;
                end;
                i = i + 1;
              end;
            end;
            /* Проверим по условию смены ставки */
            if (WasWriteToReport == FALSE)
              if ((pc_alg.StratCalc == 1) AND (DepType.LastChangeRateDate != Date(0,0,0)))
                if (DepType.LastChangeRateDate >= DateLastCalc)
                  DepType_RepForCurApplType(DepType.LastChangeRateDate,TRUE);
                end;
              end;
            end;
          end;
          rec_found = Next(DepType);
        else
          rec_found = FALSE;
        end;
      end;
    end;
  end;

end;


/*******************************************************************
      Цикл по видам вкладов для отчета о неоплаченных вкладах
*******************************************************************/
macro Pay_SubReport

  var rec_found;
  var DateNextPay;
  var DateLastPay = depparm.P_Date;
  var WasWriteToReport;
  var i;

  Message(" Определение вкладов с истекшей датой оплаты ...");

  if (DateLastPay == Date(0,0,0))
     DateLastPay = {curdate} - 1;
  end;

  if (DateLastPay != Date(0,0,0))

    if (depparm.P_State == StrFor(2))
      DateLastPay = DateLastPay + 1;
    end;
    if ((depparm.P_State == StrFor(2) ) AND
        (DateLastPay     == {curdate})    )
      ;
    else
      KeyNum(DepType,2);
      DepType.FlagCur = FlagCur;
      DepType.Kind    = "";
      rec_found = GetGE(DepType);
      while (rec_found)
        if (DepType.FlagCur == FlagCur)
          WasWriteToReport = FALSE;
          /* Проверка для вкладов с видом графика "По виду вклада" */
          if ((DepType.GrafPay != 0) OR (DepType.DayPay != 0))
            WorkWithDate(DateLastPay,DepType.GrafPay,DepType.DayPay,DateNextPay);
            if ((DateNextPay < {curdate}) AND (DateNextPay != Date(0,0,0)))
              DepType_RepForCurApplType(DateNextPay,FALSE);
              WasWriteToReport = TRUE;
            end;
          end;
          /* Проверка для вкладов с видом графика "Относительный" */
          if (WasWriteToReport == FALSE)
            i = 1;
            while (i < ASize(ApCode))
              KeyNum(pc_rdate,1);
              ReWind(pc_rdate);
              pc_rdate.FlagCur      = DepType.FlagCur;
              pc_rdate.Type_Account = DepType.Kind;
              pc_rdate.ObjectType   = ApCode(i);
              pc_rdate.DatePay      = {curdate};
              if (GetLT(pc_rdate))
                if ((pc_rdate.FlagCur      == DepType.FlagCur) AND
                    (pc_rdate.Type_Account == DepType.Kind   ) AND
                    (pc_rdate.ObjectType   == ApCode(i)      )    )
                  if (pc_rdate.DatePay != Date(0,0,0))
                    DepType_OutLine_Otn(TRUE);
                    cnt = cnt + 1;
                    DepType_Found = TRUE;
                    i = ASize(ApCode);
                  end;
                end;
              end;
              i = i + 1;
            end;
          end;
          rec_found = Next(DepType);
        else
          rec_found = FALSE;
        end;
      end;
    end;
  end;

end;


/*******************************************************************
  Отчет по вкладам, проценты по счетам которых не были рассчитаны
*******************************************************************/
macro Calc_Report

  Calc_OutHead();
  DepType_OutHead();
  cnt = 0;
  if (FindDepParm())
    Calc_SubReport();
    if (cnt == 0)
      [|Необработанных видов вкладов нет                  |];
    end;
  else
    [|Не найдены параметры филиала                      |];
  end;
  BottomDepTypeReport();

end;


/*******************************************************************
   Отчет по вкладам, проценты по счетам которых не были оплачены
*******************************************************************/
macro Pay_Report

  Pay_OutHead();
  DepType_OutHead();
  cnt = 0;
  if (FindDepParm())
    Pay_SubReport();
    if (cnt == 0)
      [|Необработанных видов вкладов нет                  |];
    end;
  else
    [|Не найдены параметры филиала                      |];
  end;
  BottomDepTypeReport();

end;


/*******************************************************************
                     Создание файлов сохранения
*******************************************************************/
macro CreateSaveFilesEx( table_src, table_dst )
  var cmd = RsdCommand( "begin rsb_tools.clone_table('" + table_src + "','" + table_dst + "',?); end;" );
  cmd.addParam("withrows", 3); /* RSDBP_IN_OUT */
  cmd.value("withrows") = 0;
  cmd.execute;
  if( cmd.value("withrows") != 0 )
    return false;
  end;

  cmd = RsdCommand( "begin rsb_tools.clone_table_indexes('" + table_src + "','" + table_dst + "'); end;" );
  cmd.execute;

  return true;
onError
  return false;
end;

macro CreateSaveFiles;

  Message(" Создание файлов сохранения ...");

  if (NOT(CreateSaveFilesEx("ddepositr_dbt","ddepositr_sav") AND
          CreateSaveFilesEx("dsbdepdoc_dbt","dsbdepdoc_sav") AND
          CreateSaveFilesEx("dpc_drest_dbt","dpc_drest_sav") AND
          CreateSaveFilesEx("dsbtrast_dbt", "dsbtrast_sav" ) AND
          CreateSaveFilesEx("ddplanpay_dbt","ddplanpay_sav") AND
          CreateSaveFilesEx("dauxinfo_dbt", "dauxinfo_sav" ) AND
          CreateSaveFilesEx("dsb_congt_dbt","dsb_congt_sav") AND
          CreateSaveFilesEx("dpc__calc_dbt","dpc__calc_sav") AND
          CreateSaveFilesEx("dpcestim_dbt", "dpcestim_sav" ) AND
          CreateSaveFilesEx("dpc_rdate_dbt","dpc_rdate_sav") AND
          CreateSaveFilesEx("dtextinfo_dbt","dtextinfo_sav") AND
          CreateSaveFilesEx("dpc_tax_dbt","dpc_tax_sav") ) )
    MsgBox("Ошибка при создании файлов сохранения");
    Exit();
  end;
end;

/*
    Отчет о выпуске карточки ф. 1-у при открытии счетов
*/
macro Report_Form_1

 var Prev_Date;
 var stat;
 var saveKeyDepos;
 var was_print_head = false;

 ClearRecord( depparm );
 depparm.FNCash  = FNCash;
 depparm.FlagCur = FlagCur;
 stat = GetEQ( depparm );

 if ( stat )
   Prev_Date = depparm.PrevDate;
 else
   MsgBox( "Не найдена запись в depparm.dbt по филиалу ", FNCash );
   return;
 end;

 cmdOpen = RsdCommand( "select t.t_account as acc, " +
                              "t.t_referenc as ref, " +
                              "t.t_type_account as kind, " +
                              "t.t_open_date as dateO " +
                       "from ddepositr_dbt t " +
                       "where (t.t_iscur > ? OR t.t_iscur = ? AND " +
                             "(t.t_fncash > ? OR t.t_fncash = ? AND " +
                             "(t.t_open_date >= ?))) " +
                       "order by t.t_iscur, " +
                                "t.t_fncash, " +
                                "t.t_open_date" );

 cmdOpen.addParam( "isCur1",  RSDBP_IN );
 cmdOpen.addParam( "isCur2",  RSDBP_IN );
 cmdOpen.addParam( "branch1", RSDBP_IN );
 cmdOpen.addParam( "branch2", RSDBP_IN );
 cmdOpen.addParam( "date",   RSDBP_IN );

 cmdOpen.value( "isCur1" )  = FlagCur;
 cmdOpen.value( "isCur2" )  = FlagCur;
 cmdOpen.value( "branch1" ) = FNCash;
 cmdOpen.value( "branch2" ) = FNCash;
 cmdOpen.value( "date" )   = Prev_Date;

 cmdOpen.execute;

 rsOpen = RsdRecordset( cmdOpen );

 if ( rsOpen.moveNext  AND
      ( rslDate( rsOpen.value( "dateO" ) ) < {curdate} ) )
   was_print_head = true;
   [
     Счета, открытые с #
        для которых не выпущена карточка ф. 1-у

    |------------------------------|--------------|
    |           Номер счета        |  Вид вклада  |
    |------------------------------|--------------|
   ] ( String(Prev_Date:m) + " по " + String({curdate}:m) + "," );

   ClearRecord( doc );
   doc.Referenc      = rsOpen.value( "ref" );
   doc.Date_Document = rslDate( rsOpen.value( "dateO" ) );
   doc.NumDayDoc     = 100;
   stat = GetEQ( doc );

   if ( stat )
     if ( GetBitFlag( doc.Flags, 12 ) == 0 )
       println( "| ", Acc_Form( rsOpen.value( "acc" ) ):28:f, " | ", rsOpen.value( "kind" ):13, "|" );
     end;
   else
     MsgBox( "Не найден документ открытия счета ", Acc_Form( rsOpen.value( "acc" ) ) );
   end;
 end;

 while ( stat  AND
         rsOpen.moveNext  AND
         ( rslDate( rsOpen.value( "dateO" ) ) < {curdate} ) )

   ClearRecord( doc );
   doc.Referenc      = rsOpen.value( "ref" );
   doc.Date_Document = rslDate( rsOpen.value( "dateO" ) );
   doc.NumDayDoc     = 100;
   stat = GetEQ( doc );

   if ( stat )
     if ( GetBitFlag( doc.Flags, 12 ) == 0 )
       println( "| ", Acc_Form( rsOpen.value( "acc" ) ):28:f, " | ", rsOpen.value( "kind" ):13, "|" );
     end;
   else
     MsgBox( "Не найден документ открытия счета ", Acc_Form( rsOpen.value( "acc" ) ) );
   end;
 end;

 if ( was_print_head )
   [|------------------------------|--------------|];
 end;

end;


private macro DeleteOdDataFiles

  var Rs, cm;
// #97258 удаляем только "свою" таблицу
//  var Cmd = RsdCommand( "select table_name from user_tables where lower( table_name ) like 'dod_data_%'" );
  var Cmd = RsdCommand( "select table_name from user_tables where lower( table_name ) = 'dod_data_' || LPAD('" + string(NumFNCash()) + "', 3, '0')" );

  Rs = RsdRecordSet( Cmd );
  while ( Rs.MoveNext )
    cm = RsdCommand( "drop table " + Rs.Value("table_name") );
    cm.execute();
  end;

onError( e )
  MsgBox( "Ошибка при удалении временных таблиц" );
end;

/*******************************************************************
                 Г Л А В Н А Я   П Р О Г Р А М М А
*******************************************************************/

  ALG_RESULT = 0;

  /* Удаление всех od_data.???, т.к. они не нужны */
  DeleteOdDataFiles();

  /* Отчет о выпуске карточки ф. 1-у при открытии счетов */
  if ( GetBankStandart() == 0 )  /* Только для Сбербанка */
    Report_Form_1();
  end;

  /* Отчет по счетам, которые не были пролонгированны */
  Dep_Found = ReportForMustBeProlAccounts({curdate});

  /* Отчет по вкладам, проценты по счетам которых не были рассчитаны */
  Calc_Report();

  /* Отчет по вкладам, проценты по счетам которых не были оплачены */
  Pay_Report();

  /* Напоминание о необходимости очистки базы */
  ReportOnCleanUp({curdate});

  /* Создание файлов сохранения */
  CreateSaveFiles();

  if (Dep_Found)
    ALG_RESULT = 3;
  end;
  if (DepType_Found)
    if (ALG_RESULT == 0)
      ALG_RESULT = 4;
    else
      ALG_RESULT = ALG_RESULT + 2;
    end;
  end;

end;
