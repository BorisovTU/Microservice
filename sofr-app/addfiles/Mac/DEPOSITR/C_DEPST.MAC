/*
$Name:           C_DEPST.mac
$Module:         RETAIL
$Description:    Заполнение файла статистики
*/

/**************************************************************************\
*  ---------------                                                         *
*  R-Style Softlab                                                         *
*  ---------------                                                         *
*  RS-Retail                                                               *
*                                                                          *
*  Заполнение файла статистики                                             *
*                                                                          *
*  Лебедев С.В.                                                            *
*  17.03.1997                                                              *
\**************************************************************************/

import DeprIntr, IsSrvDoc, sqlconv, OperCode, rsd;

var currency  = TBFile( "currency.dbt", "r", 0 ); // Справочник валют
var sb_dtyp   = TBFile( "sb_dtyp.dbt",  "r", 2 ); // Справочник видов вкладов
var depositr  = TBFile( "depositr.dbt", "r" );    // Счета вкладчиков
var sbdepdoc  = TBFile( "sbdepdoc.dbt", "r" );    // Операции по счетам
var sb_depst  = TBFile( "sb_depst.dbt", "w", 0 ); // Статистика по вкладам
var pcestim   = TBFile( "pcestim.dbt",  "r", 0 ); // Наращенные проценты
var sbdepdoc6 = TBFile( "sbdepdoc.dbt", "r", 6 ); // Операции по счетам
var sbnumgrp  = TBFile( "sbnumgrp.dbt", "r", 0 );
var sbtypgrp  = TBFile( "sbtypgrp.dbt", "r", 0 );

var depclnt = TClientList;                  // Справочник вкладчиков

var sbdepdoc2 = TRecHandler( "sbdepdoc.2" );

const BIT_FLAG_NOSTATTURNS = 18;
const BIT_FLAG_OPENCLOSE = 19;

var BegDate = {curdate};
var EndDate = {curdate};
var CurDate;

const FNCash  = NumFNCash( );
const FlagCur = NumFlagCur( );

var IzRezid;
var BeginFirstQuart = Date(0,0,0);
var BeginLastQuart  = Date(0,0,0);

var NeedFormRest1 = false;

var Mode;

array ATypeR,      ARestR,    AInSumR,    AOutSumR,    AHInSumR,  AHOutSumR, AColR,   ACodCurR, AOpenR,  ACloseR;
array AMInSumR,    AMOutSumR, AMInOperR,  AColOperR,   AOpenOpR,  ADopOpR,   AOutOpR;
array AEstimRestR, AEstimInR, AEstimOutR, AEstimOverR, ACurOpenR, ACurClosR, ABalAccR;

array ATypeNR,      ARestNR,    AInSumNR,    AOutSumNR,    AHInSumNR,  AHOutSumNR, AColNR,   ACodCurNR, AOpenNR,  ACloseNR;
array AMInSumNR,    AMOutSumNR, AMInOperNR,  AColOperNR,   AOpenOpNR,  ADopOpNR,   AOutOpNR;
array AEstimRestNR, AEstimInNR, AEstimOutNR, AEstimOverNR, ACurOpenNR, ACurClosNR, ABalAccNR;

array ACodCurUnionR,  AColUnionR,  AOpenUnionR,  ACloseUnionR;
array ACodCurUnionNR, AColUnionNR, AOpenUnionNR, ACloseUnionNR;

array ABranch;
var   OpBranch = -1;

var SumColAccounts  = 0;
var SumColOpenedAcc = 0;
var SumColClosedAcc = 0;
var SumRest         = $0L;
var SumKredSum      = $0L;
var SumDebSum       = $0L;
var SumColOper      = 0;

array OpenCloseArray;
  OpenCloseArray(0) = "";
  OpenCloseArray(1) = "З";

const
  OP_OPENCAS  =  1, /* Открытие наличными                */
  OP_OPENNCS  = 51, /* Открытие безналичными             */
  OP_OPENTRN  = 58, /* Открытие переводом                */
  OP_CLCAH    = 10, /* Закрытие наличными                */
  OP_CLNCAS   = 81, /* Закрытие безналичными             */
  OP_CLSTRN   = 96, /* Закрытие переводом                */
  OP_OUT      =  4, /* Расход                            */
  OP_GETCON   = 62, /* Списание простое                  */
  OP_GETPOR   = 63, /* Списание по разовому поручению    */
  OP_GETLPR   = 64, /* Списание по длительному поручению */
  OP_GETIN    = 65, /* Списание переводом вклада         */
  OP_GETOWN   = 66, /* Списание в свой филиал            */
  OP_GETALIEN = 67, /* Списание в чужой филиал           */
  OP_CONVERT  = 80; /* Конвертация валюты                */

const
  D_IN        = 1,
  D_OUT       = 2,
  D_GET       = 3,
  D_GETIN     = 4,
  D_PUT       = 5,
  D_PUTP      = 6,
  D_OUTCASH   = 7,
  D_AR        = 8,
  D_ARC       = 9,
  D_PUTPD     = 10,
  D_TAKE      = 11;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro IsQuasiOpenOp

  if ( GetBitFlag( sbdepdoc.rec.Flags, BIT_FLAG_OPENCLOSE ) )
    if ( ( sbdepdoc.rec.KindOp == D_IN    ) or
         ( sbdepdoc.rec.KindOp == D_PUT   ) or
         ( sbdepdoc.rec.KindOp == D_PUTP  ) or
         ( sbdepdoc.rec.KindOp == D_PUTPD )   )
      return true;
    end;
  end;

  return false;

end;


/**************************************************************************\
|                                                                          |
\**************************************************************************/
macro IsQuasiCloseOp

  if ( GetBitFlag( sbdepdoc.rec.Flags, BIT_FLAG_OPENCLOSE ) )
    if ( ( sbdepdoc.rec.KindOp == D_OUT     ) or
         ( sbdepdoc.rec.KindOp == D_GET     ) or
         ( sbdepdoc.rec.KindOp == D_GETIN   ) or
         ( sbdepdoc.rec.KindOp == D_TAKE    ) or
         ( sbdepdoc.rec.KindOp == D_OUTCASH )   )
      return true;
    end;
  end;

  return false;

end;


/**************************************************************************\
|                         Начало-Окончание отчета                          |
\**************************************************************************/
macro BeginEndReport

  [ ----- #################### ---------------- ########## ----- ######## -------]
  ( GetRetailVersion( ), Date( ), Time( ) );

end;


/**************************************************************************\
|                   Отсечение архивных и удаленных записей                 |
\**************************************************************************/
macro IsServDoc2_with_est ( doc_rec )

  var isDoc = true; // Результат проверки

  isDoc = ( ( doc_rec.KindOp != DD_AR            ) and
            ( doc_rec.KindOp != DD_ARC           ) and
            ( doc_rec.KindOp != DD_AUDIT_STORN   ) and
            ( doc_rec.KindOp != DD_AUDIT_DELETE  ) and
            ( doc_rec.KindOp != DD_AUDIT_CORRECT ) and
            ( doc_rec.Action != DD_DELETE        )    );

  /* Непроведенный документ */
  if ( isDoc )
    isDoc = 
    (
      ( doc_rec.IsSuspended == ""  ) or 
      ( doc_rec.IsSuspended == "X" ) 
    )
  end;

  if ( isDoc )
    if ( doc_rec.Referenc == 0 )
      isDoc = false;
    end;
  end;

  return isDoc;

end;


/**************************************************************************\
|                   Отсечение архивных и удаленных записей                 |
\**************************************************************************/
macro IsServDoc2 ( doc_rec )

  var isDoc = true; // Результат проверки

  isDoc = IsServDoc2_with_est( doc_rec );

  if ( isDoc )
    isDoc = ( ( doc_rec.TypeOper != 38 ) and
              ( doc_rec.TypeOper != 39 )    );
  end;

  return isDoc;

end;


/**************************************************************************\
|                                 Поиск валюты                             |
\**************************************************************************/
macro FindCurrency ( CodeCur )

  currency.Clear;
  currency.rec.Code_Currency = CodeCur;

  return currency.GetEQ;

end;


/**************************************************************************\
|                       Определение названия филиала                       |
\**************************************************************************/
macro DefNameBranch

  var NameBranch = "";

  if ( not findDepartment( FNCash, NameBranch ) )
    NameBranch = "";
  end;

  return NameBranch;

end;


/**************************************************************************\
|                       Определение названия филиала                       |
\**************************************************************************/
macro DefBalAcc ( groupID, flagNotResid )

  var balAcc = "";

  if ( groupID > 0 )
    sbnumgrp.Clear;
    sbnumgrp.rec.GroupID = groupID;
    if ( sbnumgrp.GetEQ )
      if ( flagNotResid )
        balAcc = sbnumgrp.rec.BalAcc2NotResid;
      else
        balAcc = sbnumgrp.rec.BalAcc2;
      end;
    end;
  end;

  return balAcc;

end;


/**************************************************************************\
|                Определение остатка по статистике на дату                 |
\**************************************************************************/
macro DefRestForType ( InputRest, Kind, CodCur, Rez, BalAcc )

  var Rest = InputRest;
  var RezBalAcc = false;
  var stat;

  sb_depst.KeyNum = 0;
  sb_depst.Clear;
  sb_depst.rec.FNCash  = FNCash;
  sb_depst.rec.IsCur   = FlagCur;
  sb_depst.rec.Kind    = Kind;
  sb_depst.rec.CodCur  = CodCur;
  sb_depst.rec.FlagRez = Rez;
  sb_depst.rec.BalAcc  = BalAcc;
  sb_depst.rec.Date    = BegDate;
  sb_depst.rec.Mode    = 0;
  sb_depst.addFilter( "t.t_FNCash = " + string( FNCash ) + " and " +
                      "t.t_IsCur = " + string( FlagCur ) + " and " +
                      "t.t_Kind = " + GetSQLString( Kind ) + " and " +
                      "t.t_CodCur = " + string( CodCur ) + " and " +
                      "t.t_FlagRez = " + sqlChar( Rez ) + " and " +
                      "t.t_BalAcc = " + GetSQLString( BalAcc ) + " and " +
                      "t.t_Date between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                            sqlDateToStr( BegDate )                    );
  stat = sb_depst.GetLE;
  while ( stat )
    if ( ( sb_depst.rec.FNCash  == FNCash  ) and
         ( sb_depst.rec.IsCur   == FlagCur ) and
         ( sb_depst.rec.Kind    == Kind    ) and
         ( sb_depst.rec.CodCur  == CodCur  ) and
         ( sb_depst.rec.FlagRez == Rez     ) and
         ( sb_depst.rec.BalAcc  == BalAcc  )    )
      if ( sb_depst.rec.Date <= BegDate )
        Rest = sb_depst.rec.Rest;
        stat = false;
      else
        stat = sb_depst.Prev;
      end;
    else
      stat = false;
    end;
  end;
  sb_depst.dropFilter;

  return Rest;

end;


/**************************************************************************\
|                         Чистка файла статистики                          |
\**************************************************************************/
macro DelStat ( Date1, Date2 )

  var stat;

  Message( " Чистка файла статистики с ", Date1, " по ", Date2, " ..." );

  sb_depst.KeyNum = 4;
  sb_depst.Clear;
  sb_depst.rec.FNCash  = FNCash;
  sb_depst.rec.Date    = Date1;
  sb_depst.addFilter( "t.t_FNCash = " + string( FNCash ) + " and " +
                      "t.t_Date between " + sqlDateToStr( Date1 ) + " and " +
                                            sqlDateToStr( Date2 )            );
  stat = sb_depst.GetGE;
  while ( stat )
    if ( ( sb_depst.rec.FNCash == FNCash ) and
         ( sb_depst.rec.Date   <= Date2  )    )
      if ( sb_depst.rec.IsCur == FlagCur )
        sb_depst.Delete;
      end;
      stat = sb_depst.Next;
    else
      stat = false;
    end;
  end;
  sb_depst.dropFilter;

end;


/**************************************************************************\
|                            Печать шапки отчета                           |
\**************************************************************************/
macro TopReport ( CodeCurrency, NeedFindCur )

  var stat = true;

  [ ];
  [              Статистика по вкладам по филиалу ]( DefNameBranch( ) + " за " + String( EndDate ) );
  [ ];
  if ( NeedFindCur )
    stat = FindCurrency( CodeCurrency );
  end;
  if ( stat )
    [  Валюта: #]( currency.rec.Short_Name + " - " + currency.rec.Name_Currency );
    [ ];
  end;
  [ ╓────────────╥────────────┬────────────┬──────────────╥─────────────────╥─────╥─────╖];
  [ ║            ║ Кредитовые │ Дебетовые  │  Остаток на  ║Количество счетов║Кол. ║     ║];
  [ ║ Вид вклада ║ обороты    │ обороты    │  конец дня   ╟─────┬─────┬─────╢опер.║Б.сч.║];
  [ ║            ║ дня        │ дня        │              ║всего│откр.│закр.║     ║     ║];
  [ ╟────────────╫────────────┼────────────┼──────────────╫─────┼─────┼─────╫─────╫─────╢];

end;


/**************************************************************************\
|                          Печать окончания отчета                         |
\**************************************************************************/
macro EndReport


  [ ╙────────────╨────────────┴────────────┴──────────────╨─────┴─────┴─────╨─────╨─────╜];
  [ ];
  [  Итого        ############ ############ ############## ##### ##### ##### #####]
  ( SumKredSum:12:2:a, SumDebSum:12:2:a, SumRest:14:2:a, SumColAccounts:5,
    SumColOpenedAcc:5, SumColClosedAcc:5, SumColOper:5 );
  [ ];

end;


/**************************************************************************\
|                           Печать строки отчета                           |
\**************************************************************************/
macro WriteString

  var RepKredSum = $0L;
  var RepDebSum  = $0L;
  var ColOper    = 0;

  if ( sb_depst.rec.Date == EndDate )
    RepKredSum = sb_depst.rec.KredSum;
    RepDebSum  = sb_depst.rec.DebSum;
  end;

  if ( sb_depst.rec.Date > BeginLastQuart )
    ColOper = sb_depst.rec.ColOper;
  end;

  [ ║############║############│############│##############║#####│#####│#####║#####║#####║]
  ( sb_depst.rec.Kind, RepKredSum:12:2:a, RepDebSum:12:2:a,
    sb_depst.rec.Rest:14:2:a, sb_depst.rec.ColAccounts:5,
    sb_depst.rec.ColOpenedAcc:5, sb_depst.rec.ColClosedAcc:5, ColOper:5, sb_depst.rec.BalAcc );
  if ( sb_depst.rec.FlagRez != "" )
    [ ║(нерез.)    ║            │            │              ║     │     │     ║     ║     ║];
  end;

  /* Подсчет сумм */
  SumColAccounts  = SumColAccounts  + sb_depst.rec.ColAccounts;
  SumColOpenedAcc = SumColOpenedAcc + sb_depst.rec.ColOpenedAcc;
  SumColClosedAcc = SumColClosedAcc + sb_depst.rec.ColClosedAcc;
  SumRest         = SumRest         + sb_depst.rec.Rest;
  SumKredSum      = SumKredSum      + RepKredSum;
  SumDebSum       = SumDebSum       + RepDebSum;
  SumColOper      = SumColOper      + ColOper;

end;


/**************************************************************************\
|     Цикл по файлу статистики вкладов за последний день - для отчета      |
\**************************************************************************/
macro WriteReportForLastDay ( CodeCurrency )

  var stat;
  var i, j;
  array AFlagRez;
    AFlagRez( 0 ) = "\x00";
    AFlagRez( 1 ) = "\x01";
  array ABalAcc;
  array ABalAccN;
    ABalAcc( 0 ) = "";
    ABalAccN( 0 ) = "";
  var ptrABalAcc;

  sbnumgrp.Clear;
  stat = sbnumgrp.GetGE;
  while ( stat ) 
    if ( sbnumgrp.rec.BalAcc2 != "" )
      i = 0;
      j = -1;
      while ( i < ASize( ABalAcc ) )
        if ( sbnumgrp.rec.BalAcc2 == ABalAcc( i ) )
          j = i;
        end;
        i = i + 1;
      end;

      if ( j == -1 )
        j = ASize( ABalAcc );
        ABalAcc( j ) = sbnumgrp.rec.BalAcc2;
      end;
    end;

    if ( sbnumgrp.rec.BalAcc2NotResid != "" )
      i = 0;
      j = -1;
      while ( i < ASize( ABalAccN ) )
        if ( sbnumgrp.rec.BalAcc2NotResid == ABalAccN( i ) )
          j = i;
        end;
        i = i + 1;
      end;

      if ( j == -1 )
        j = ASize( ABalAccN );
        ABalAccN( j ) = sbnumgrp.rec.BalAcc2NotResid;
      end;
    end;
    
    stat = sbnumgrp.Next;
  end;

  sb_dtyp.Clear;
  sb_dtyp.rec.FlagCur = FlagCur;
  sb_dtyp.rec.Kind    = "";
  stat = sb_dtyp.GetGE;
  while ( stat )
    if ( sb_dtyp.rec.FlagCur == FlagCur )
      i = 0;

      sb_depst.KeyNum = 0;
      sb_depst.Clear;
      sb_depst.rec.FNCash  = FNCash;
      sb_depst.rec.IsCur   = FlagCur;
      sb_depst.rec.Kind    = sb_dtyp.rec.Kind;
      sb_depst.rec.CodCur  = CodeCurrency;

      sb_depst.addFilter( "t.t_FNCash = " + string( FNCash ) + " and " +
                          "t.t_IsCur = " + string( FlagCur ) + " and " +
                          "t.t_Kind = " + GetSQLString( sb_dtyp.rec.Kind ) + " and " +
                          "t.t_CodCur = " + string( CodeCurrency ) );

      if ( ( sb_depst.GetGE                           ) and
           ( sb_depst.rec.FNCash  == FNCash           ) and
           ( sb_depst.rec.IsCur   == FlagCur          ) and
           ( sb_depst.rec.Kind    == sb_dtyp.rec.Kind ) and
           ( sb_depst.rec.CodCur  == CodeCurrency     )    )
        ;
      else
        i = ASize( AFlagRez ); /* По данному вкладу нет статистики */
      end;

      sb_depst.dropFilter;

      while ( i < ASize( AFlagRez ) )
        j = 0;

        if ( AFlagRez( i ) == "\x00" )
          ptrABalAcc = ABalAcc;
        else
          ptrABalAcc = ABalAccN;
        end;

        while ( j < ASize( ptrABalAcc ) ) 
          sb_depst.KeyNum = 0;
          sb_depst.Clear;
          sb_depst.rec.FNCash  = FNCash;
          sb_depst.rec.IsCur   = FlagCur;
          sb_depst.rec.Kind    = sb_dtyp.rec.Kind;
          sb_depst.rec.CodCur  = CodeCurrency;
          sb_depst.rec.FlagRez = AFlagRez( i );
          sb_depst.rec.BalAcc  = ptrABalAcc( j );
          sb_depst.rec.Date    = EndDate;
          sb_depst.rec.Mode    = 1;
          sb_depst.addFilter( "t.t_FNCash = " + string( FNCash ) + " and " +
                              "t.t_IsCur = " + string( FlagCur ) + " and " +
                              "t.t_Kind = " + GetSQLString( sb_dtyp.rec.Kind ) + " and " +
                              "t.t_CodCur = " + string( CodeCurrency ) + " and " +
                              "t.t_FlagRez = " + sqlChar( AFlagRez( i ) ) + " and " +
                              "t.t_BalAcc = " + GetSQLString( ptrABalAcc( j ) ) + " and " +
                              "t.t_Date between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                                    sqlDateToStr( EndDate )                    );
          if ( ( sb_depst.GetLE                           ) and
               ( sb_depst.rec.FNCash  == FNCash           ) and
               ( sb_depst.rec.IsCur   == FlagCur          ) and
               ( sb_depst.rec.Kind    == sb_dtyp.rec.Kind ) and
               ( sb_depst.rec.CodCur  == CodeCurrency     ) and
               ( sb_depst.rec.FlagRez == AFlagRez( i )    ) and
               ( sb_depst.rec.BalAcc  == ptrABalAcc( j )  )    )
            WriteString( );
          end;
          sb_depst.dropFilter;
          j = j + 1;
        end;
        i = i + 1;
      end;
      stat = sb_dtyp.Next;
    else
      stat = false;
    end;
  end;

end;


/**************************************************************************\
|      Определение остатка по накопленным процентам по счету на дату       |
\**************************************************************************/
macro DefRestEstimForDate

  var RestEstim = $0L;
  var stat;

  // Списание накопленных процентов при причислении процентов
  sbdepdoc6.Clear;
  sbdepdoc6.rec.Referenc      = sbdepdoc.rec.Referenc;
  sbdepdoc6.rec.Date_Document = Date( 0, 0, 0 );
  sbdepdoc6.rec.NumDayDoc     = 0;
  sbdepdoc6.addFilter( "t.t_Referenc = " + string( sbdepdoc.rec.Referenc ) + " and " +
                       "t.t_Date_Document between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                                      sqlDateToStr( sbdepdoc.rec.Date_Document ) );
  stat = sbdepdoc6.GetGE;
  while ( stat )
    if ( ( sbdepdoc6.rec.Referenc      == sbdepdoc.rec.Referenc      ) and
         ( sbdepdoc6.rec.Date_Document <= sbdepdoc.rec.Date_Document )    )
      if ( (   sbdepdoc6.rec.Date_Document <  sbdepdoc.rec.Date_Document      ) or
           ( ( sbdepdoc6.rec.Date_Document == sbdepdoc.rec.Date_Document ) and
             ( sbdepdoc6.rec.NumDayDoc     <  sbdepdoc.rec.NumDayDoc     )    )   )
        if ( IsServDoc2( sbdepdoc6.rec ) and ( sbdepdoc6.rec.FlagStorn == "" ) and ( sbdepdoc6.rec.TypeOper == 72 ) )
          sbdepdoc2.SetRecordAddr( sbdepdoc6, 0, 0, true );
          RestEstim = RestEstim - sbdepdoc2.rec.SummaEstim - sbdepdoc2.rec.SummaOverEstim;
        end;
      end;
      stat = sbdepdoc6.Next;
    else
      stat = false;
    end;
  end;
  sbdepdoc6.dropFilter;

  // Отражение накопленных процентов
  pcestim.Clear;
  pcestim.rec.Referenc   = sbdepdoc.rec.Referenc;
  pcestim.rec.DateOperat = Date( 0, 0, 0 );
  pcestim.rec.NumDayDoc  = 0;
  pcestim.addFilter( "t.t_Referenc = " + string( sbdepdoc.rec.Referenc ) + " and " +
                     "t.t_DateOperat between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                                 sqlDateToStr( sbdepdoc.rec.Date_Document ) );
  stat = pcestim.GetGE;
  while ( stat )
    if ( ( pcestim.rec.Referenc   == sbdepdoc.rec.Referenc      ) and
         ( pcestim.rec.DateOperat <  sbdepdoc.rec.Date_Document )    )
      if ( ( (   pcestim.rec.TypeComplexOper == 38                                      ) or
             ( ( pcestim.rec.TypeComplexOper == 72 ) and ( pcestim.rec.TypeOper == 38 ) ) or
             ( ( pcestim.rec.TypeComplexOper == 82 ) and ( pcestim.rec.TypeOper == 38 ) )   ) and
           ( pcestim.rec.Action < 2 )                                                        )
        RestEstim = RestEstim + pcestim.rec.SummaPay_In - pcestim.rec.SummaPay_Out;
      end;
      stat = pcestim.Next;
    else
      stat = false;
    end;
  end;
  pcestim.dropFilter;

  if ( RestEstim < 0 )
    RestEstim = $0L;
  end;

  return RestEstim;

end;


/**************************************************************************\
|           Определение резидентности клиента по счету вкладчика           |
\**************************************************************************/
private macro DefGroupIdForKind ( FlagCur, Kind )

  var cmd, rs;
  var groupId = 0;

  cmd = RsdCommand( "select typgrp.t_groupid as GroupID "
                    "from dsbtypgrp_dbt typgrp "
                    "where typgrp.t_flagcur = :flagCur and "
                    "      typgrp.t_kind = :kind "
                    "order by typgrp.t_groupid" );

  rs = RsdRecordset( cmd );

  cmd.addParam( "flagCur", RSDBP_IN, FlagCur );
  cmd.addParam( "kind", RSDBP_IN, Kind );

  cmd.execute;

  if ( rs.moveNext() )
    groupId = rs.value( "GroupID" );
  end;

  return groupId;

end;


/**************************************************************************\
|           Определение резидентности клиента по счету вкладчика           |
\**************************************************************************/
macro DefRezForAccount

  var IsRezident = true;

  if ( depclnt.GetRecord( depositr.rec.CodClient ) )
    if ( depclnt.CurRec.rec.NotResident != "" )
      IsRezident = false;
    end;
  end;

  return IsRezident;

end;


/**************************************************************************\
|          Определение резидентности клиента по документу проводки         |
\**************************************************************************/
macro DefRezForDepDoc

  var IsRezident = true;
  var groupNumb = "";

  if ( ( sbdepdoc.rec.TypeOper == 38 ) or ( sbdepdoc.rec.TypeOper == 39 ) )
    if ( sbdepdoc.rec.FlagRezid != StrFor( 0 ) )
      IsRezident = false;
    end;
    depositr.Clear;
    depositr.rec.Type_Account  = sbdepdoc.rec.Type_Account;
    depositr.rec.Code_Currency = sbdepdoc.rec.Code_Currency;

    if ( sbdepdoc.rec.Referenc < 0 )
      if ( sbdepdoc.rec.ListTransfer > 0 )
        groupNumb = String( sbdepdoc.rec.ListTransfer );
      else
        ;
      end;
    elif ( sbdepdoc.rec.Referenc > 0 )
      depositr.KeyNum = 8;
      depositr.Clear;
      depositr.rec.Referenc = sbdepdoc.rec.Referenc;
      if ( depositr.GetEQ )
        groupNumb = depositr.rec.GroupNumb;
      end;
    end;

    depositr.Clear;
    depositr.rec.Type_Account  = sbdepdoc.rec.Type_Account;
    depositr.rec.Code_Currency = sbdepdoc.rec.Code_Currency;
    depositr.rec.GroupNumb     = groupNumb;

  else
    depositr.KeyNum = 8;
    depositr.Clear;
    depositr.rec.Referenc = sbdepdoc.rec.Referenc;
    if ( depositr.GetEQ )
      IsRezident = DefRezForAccount( );
    end;
  end;

  return IsRezident;

end;


/**************************************************************************\
|    Определение номера элемента в массиве для количества объединенных     |
\**************************************************************************/
macro CorrectCountUnionKind

  var i;
  var j;
  var CountElemUnion;
  var CountElem;

  CountElemUnion = ASize( ACodCurUnionR );
  i = 0;
  while ( i < CountElemUnion )
    j = 0;
    CountElem = ASize( ATypeR );
    while ( j < CountElem )
      if ( ( ATypeR  ( j ) == "Объединенный"     ) and
           ( ACodCurR( j ) == ACodCurUnionR( i ) )    )
        AColR  ( j ) = AColUnionR  ( i );
        AOpenR ( j ) = AOpenUnionR ( i );
        ACloseR( j ) = ACloseUnionR( i );
        j = CountElem;
      end;
      j = j + 1;
    end;
    i = i + 1;
  end;

  CountElemUnion = ASize( ACodCurUnionNR );
  i = 0;
  while ( i < CountElemUnion )
    j = 0;
    CountElem = ASize( ATypeNR );
    while ( j < CountElem )
      if ( ( ATypeNR  ( j ) == "Объединенный"      ) and
           ( ACodCurNR( j ) == ACodCurUnionNR( i ) )    )
        AColNR  ( j ) = AColUnionNR  ( i );
        AOpenNR ( j ) = AOpenUnionNR ( i );
        ACloseNR( j ) = ACloseUnionNR( i );
        j = CountElem;
      end;
      j = j + 1;
    end;
    i = i + 1;
  end;

end;


/**************************************************************************\
|    Определение номера элемента в массиве для количества объединенных     |
\**************************************************************************/
macro DefNumElemForUnionKind ( IsRez, CodeCurr )

  var i = 0;
  var j = -1;

  if ( IsRez )
    while ( i < ASize( ACodCurUnionR ) )
      if ( CodeCurr == ACodCurUnionR( i ) )
        j = i;
        i = ASize( ACodCurUnionR );
      end;
      i = i + 1;
    end;
  else
    while ( i < ASize( ACodCurUnionNR ) )
      if ( CodeCurr == ACodCurUnionNR( i ) )
        j = i;
        i = ASize( ACodCurUnionNR );
      end;
      i = i + 1;
    end;
  end;

  // Не нашли - создаем новый элемент массива
  if ( j == -1 )
    if ( IsRez )
      j = ASize( ACodCurUnionR );
      ACodCurUnionR( j ) = CodeCurr;
      AColUnionR   ( j ) = 0;
      AOpenUnionR  ( j ) = 0;
      ACloseUnionR ( j ) = 0;
    else
      j = ASize( ACodCurUnionNR );
      ACodCurUnionNR( j ) = CodeCurr;
      AColUnionNR   ( j ) = 0;
      AOpenUnionNR  ( j ) = 0;
      ACloseUnionNR ( j ) = 0;
    end;
  end;

  return j;

end;


/**************************************************************************\
|                  Определение номера элемента в массиве                   |
\**************************************************************************/
macro DefNumElemForKind ( IsRez, Kind, CodeCurr, GroupNumb )

  var i = 0;
  var j = -1;
  var balAcc = "";

  if ( ValType( GroupNumb ) == V_STRING )
    GroupNumb = Abs( Int( Trim( GroupNumb ) ) );
  end;

  if ( ( Kind == "Неподвижный" ) or ( Kind == "Объединенный" ) )
    if ( CodeCurr == 0 )
      GroupNumb = DefGroupIdForKind( 0, Kind );
    else
      GroupNumb = DefGroupIdForKind( 1, Kind );
    end;
  end;

  if ( IsRez )
    balAcc = DefBalAcc( GroupNumb, false );
  else
    balAcc = DefBalAcc( GroupNumb, true );
  end;
          
  if ( IsRez )
    while ( i < ASize( ATypeR ) )
      if ( ( Kind     == ATypeR  ( i ) ) and
           ( CodeCurr == ACodCurR( i ) ) and
           ( balAcc   == ABalAccR( i ) )    )
        j = i;
        i = ASize( ATypeR );
      end;
      i = i + 1;
    end;
  else
    while ( i < ASize( ATypeNR ) )
      if ( ( Kind     == ATypeNR  ( i ) ) and
           ( CodeCurr == ACodCurNR( i ) ) and
           ( balAcc   == ABalAccNR( i ) )    )
        j = i;
        i = ASize( ATypeNR );
      end;
      i = i + 1;
    end;
  end;

  // Не нашли - создаем новый элемент массива
  if ( j == -1 )
    if ( IsRez )
      j = ASize( ATypeR );
      ATypeR     ( j ) = Kind;
      ARestR     ( j ) = $0.0L;
      AInSumR    ( j ) = $0.0L;
      AOutSumR   ( j ) = $0.0L;
      AHInSumR   ( j ) = $0.0L;
      AHOutSumR  ( j ) = $0.0L;
      AMInSumR   ( j ) = $0.0L;
      AMOutSumR  ( j ) = $0.0L;
      AMInOperR  ( j ) = $0.0L;
      AColOperR  ( j ) = 0;
      AColR      ( j ) = 0;
      ACodCurR   ( j ) = CodeCurr;
      AOpenR     ( j ) = 0;
      ACloseR    ( j ) = 0;
      AOpenOpR   ( j ) = 0;
      ADopOpR    ( j ) = 0;
      AOutOpR    ( j ) = 0;
      AEstimRestR( j ) = $0.0L;
      AEstimInR  ( j ) = $0.0L;
      AEstimOutR ( j ) = $0.0L;
      AEstimOverR( j ) = $0.0L;
      ACurOpenR  ( j ) = 0;
      ACurClosR  ( j ) = 0;
      ABalAccR   ( j ) = balAcc;
    else
      j = ASize( ATypeNR );
      ATypeNR     ( j ) = Kind;
      ARestNR     ( j ) = $0.0L;
      AInSumNR    ( j ) = $0.0L;
      AOutSumNR   ( j ) = $0.0L;
      AHInSumNR   ( j ) = $0.0L;
      AHOutSumNR  ( j ) = $0.0L;
      AMInSumNR   ( j ) = $0.0L;
      AMOutSumNR  ( j ) = $0.0L;
      AMInOperNR  ( j ) = $0.0L;
      AColOperNR  ( j ) = 0;
      AColNR      ( j ) = 0;
      ACodCurNR   ( j ) = CodeCurr;
      AOpenNR     ( j ) = 0;
      ACloseNR    ( j ) = 0;
      AOpenOpNR   ( j ) = 0;
      ADopOpNR    ( j ) = 0;
      AOutOpNR    ( j ) = 0;
      AEstimRestNR( j ) = $0.0L;
      AEstimInNR  ( j ) = $0.0L;
      AEstimOutNR ( j ) = $0.0L;
      AEstimOverNR( j ) = $0.0L;
      ACurOpenNR  ( j ) = 0;
      ACurClosNR  ( j ) = 0;
      ABalAccNR   ( j ) = balAcc;
    end;
  end;

  return j;

end;


/**************************************************************************\
|                         Работа с одним документом                        |
\**************************************************************************/
macro WorkWithOneDepDoc ( IsRez )

  var j;
  var RestEstim = $0L;
  var WriteTurns = ( GetBitFlag( sbdepdoc.rec.Flags, BIT_FLAG_NOSTATTURNS ) == 0 );

  if ( Index( depositr.rec.UserTypeAccount, "Н" ) == 0 )
    j = DefNumElemForKind( IsRez, sbdepdoc.rec.Type_Account, sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
  else
    j = DefNumElemForKind( IsRez, "Неподвижный", sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
  end;

  // Причисление наращенных процентов - изменяет только поля по наращенным процентам
  if ( sbdepdoc.rec.TypeOper == 38 )
    if ( IsRez )
      AEstimRestR( j ) = AEstimRestR( j ) + sbdepdoc.rec.InSum;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        AEstimInR( j ) = AEstimInR( j ) + sbdepdoc.rec.InSum;
      end;
    else
      AEstimRestNR( j ) = AEstimRestNR( j ) + sbdepdoc.rec.InSum;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        AEstimInNR( j ) = AEstimInNR( j ) + sbdepdoc.rec.InSum;
      end;
    end;
    return;
  end;

  if ( sbdepdoc.rec.TypeOper == 39 )
    if ( IsRez )
      AEstimRestR( j ) = AEstimRestR( j ) - sbdepdoc.rec.OutSum;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        if ( sbdepdoc.rec.ApplType == 0 )
          AEstimOutR ( j ) = AEstimOutR ( j ) + sbdepdoc.rec.OutSum;
        else
          AEstimOverR( j ) = AEstimOverR( j ) + sbdepdoc.rec.OutSum;
        end;
      end;
    else
      AEstimRestNR( j ) = AEstimRestNR( j ) - sbdepdoc.rec.OutSum;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        if ( sbdepdoc.rec.ApplType == 0 )
          AEstimOutNR ( j ) = AEstimOutNR ( j ) + sbdepdoc.rec.OutSum;
        else
          AEstimOverNR( j ) = AEstimOverNR( j ) + sbdepdoc.rec.OutSum;
        end;
      end;
    end;
    return;
  end;

  // Остаток
  if ( IsRez )
    if ( sbdepdoc.rec.Date_Document == CurDate )
      if ( WriteTurns )
        AInSumR ( j ) = AInSumR ( j ) + sbdepdoc.rec.InSum;
        AOutSumR( j ) = AOutSumR( j ) + sbdepdoc.rec.OutSum;
      else
        AHInSumR ( j ) = AHInSumR ( j ) + sbdepdoc.rec.InSum;
        AHOutSumR( j ) = AHOutSumR( j ) + sbdepdoc.rec.OutSum;
      end;
    end;
    ARestR( j ) = ARestR( j ) + sbdepdoc.rec.InSum - sbdepdoc.rec.OutSum;
    if ( sbdepdoc.rec.VidDoc == 0 )
      if ( sbdepdoc.rec.Date_Document == CurDate )
        if ( WriteTurns )
          AMInSumR ( j ) = AMInSumR ( j ) + sbdepdoc.rec.InSum;
          AMOutSumR( j ) = AMOutSumR( j ) + sbdepdoc.rec.OutSum;
        end;
      end;
      if ( sbdepdoc.rec.TypeOper != 78 )
        AMInOperR( j ) = AMInOperR( j ) + sbdepdoc.rec.InSum;
      end;
    else
      if ( sbdepdoc.rec.InSum > 0 )
        if ( ( sbdepdoc.rec.TypeOper == OP_OPENCAS ) or
             ( sbdepdoc.rec.TypeOper == OP_OPENNCS ) or
             ( sbdepdoc.rec.TypeOper == OP_OPENTRN ) or
               IsQuasiOpenOp( )                        )
          AOpenOpR( j ) = AOpenOpR( j ) + 1;
        else
          ADopOpR ( j ) = ADopOpR ( j ) + 1;
        end;
      elif ( sbdepdoc.rec.OutSum > 0 )
        AOutOpR( j ) = AOutOpR( j ) + 1;
      end;
    end;
    if ( ( ( sbdepdoc.rec.InSum  != 0 ) or ( sbdepdoc.rec.OutSum != 0 ) ) and ( sbdepdoc.rec.TypeOper != 78 ) )
      AColOperR( j ) = AColOperR( j ) + 1;
    end;
    if ( sbdepdoc.rec.TypeOper == 72 )
      sbdepdoc2.SetRecordAddr( sbdepdoc, 0, 0, true );
      AEstimRestR( j ) = AEstimRestR( j ) - sbdepdoc2.rec.SummaEstim - sbdepdoc2.rec.SummaOverEstim;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        AEstimOutR ( j ) = AEstimOutR ( j ) + sbdepdoc2.rec.SummaEstim;
        AEstimOverR( j ) = AEstimOverR( j ) + sbdepdoc2.rec.SummaOverEstim;
      end;
    end;
  else
    if ( sbdepdoc.rec.Date_Document == CurDate )
      if ( WriteTurns )
        AInSumNR ( j ) = AInSumNR ( j ) + sbdepdoc.rec.InSum;
        AOutSumNR( j ) = AOutSumNR( j ) + sbdepdoc.rec.OutSum;
      else
        AHInSumNR ( j ) = AHInSumNR ( j ) + sbdepdoc.rec.InSum;
        AHOutSumNR( j ) = AHOutSumNR( j ) + sbdepdoc.rec.OutSum;
      end;
    end;
    ARestNR( j ) = ARestNR( j ) + sbdepdoc.rec.InSum - sbdepdoc.rec.OutSum;
    if ( sbdepdoc.rec.VidDoc == 0 )
      if ( sbdepdoc.rec.Date_Document == CurDate )
        if ( WriteTurns )
          AMInSumNR ( j ) = AMInSumNR ( j ) + sbdepdoc.rec.InSum;
          AMOutSumNR( j ) = AMOutSumNR( j ) + sbdepdoc.rec.OutSum;
        end;
      end;
      if ( sbdepdoc.rec.TypeOper != 78 )
        AMInOperNR( j ) = AMInOperNR( j ) + sbdepdoc.rec.InSum;
      end;
    else
      if ( sbdepdoc.rec.InSum > 0 )
        if ( ( sbdepdoc.rec.TypeOper == OP_OPENCAS ) or
             ( sbdepdoc.rec.TypeOper == OP_OPENNCS ) or
             ( sbdepdoc.rec.TypeOper == OP_OPENTRN ) or
               IsQuasiOpenOp( )                        )
          AOpenOpNR ( j ) = AOpenOpNR( j ) + 1;
        else
          ADopOpNR  ( j ) = ADopOpNR ( j ) + 1;
        end;
      elif ( sbdepdoc.rec.OutSum > 0 )
        AOutOpNR( j ) = AOutOpNR( j ) + 1;
      end;
    end;
    if ( ( ( sbdepdoc.rec.InSum != 0 ) or ( sbdepdoc.rec.OutSum != 0 ) ) and ( sbdepdoc.rec.TypeOper != 78 ) )
      AColOperNR( j ) = AColOperNR( j ) + 1;
    end;
    if ( sbdepdoc.rec.TypeOper == 72 )
      sbdepdoc2.SetRecordAddr( sbdepdoc, 0, 0, true );
      AEstimRestNR( j ) = AEstimRestNR( j ) - sbdepdoc2.rec.SummaEstim - sbdepdoc2.rec.SummaOverEstim;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        AEstimOutNR ( j ) = AEstimOutNR ( j ) + sbdepdoc2.rec.SummaEstim;
        AEstimOverNR( j ) = AEstimOverNR( j ) + sbdepdoc2.rec.SummaOverEstim;
      end;
    end;
  end;

  // Открыли новый счет
  if ( ( sbdepdoc.rec.TypeOper == OP_OPENCAS ) or
       ( sbdepdoc.rec.TypeOper == OP_OPENNCS ) or
       ( sbdepdoc.rec.TypeOper == OP_OPENTRN ) or
         IsQuasiOpenOp( )                        )
    if ( IsRez )
      AColR ( j ) = AColR ( j ) + 1;
      AOpenR( j ) = AOpenR( j ) + 1;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurOpenR( j ) = ACurOpenR( j ) + 1;
      end;
    else
      AColNR ( j ) = AColNR ( j ) + 1;
      AOpenNR( j ) = AOpenNR( j ) + 1;
      if (sbdepdoc.rec.Date_Document == CurDate )
        ACurOpenNR( j ) = ACurOpenNR( j ) + 1;
      end;
    end;
  end;

  // Закрыли счет
  if ( IsOperCloseAcc( sbdepdoc.rec ) and
       (sbdepdoc.rec.IsControl  != "") )
    if ( IsRez )
      ACloseR( j ) = ACloseR( j ) + 1;
      AOpenR ( j ) = AOpenR ( j ) - 1;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurClosR( j ) = ACurClosR( j ) + 1;
      end;
    else
      ACloseNR( j ) = ACloseNR( j ) + 1;
      AOpenNR ( j ) = AOpenNR ( j ) - 1;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurClosNR( j ) = ACurClosNR( j ) + 1;
      end;
    end;
  elif ( ( ( ( sbdepdoc.rec.TypeOper   == OP_OUT            ) or
           ( ( sbdepdoc.rec.TypeOper   == OP_GETCON   ) and
             ( sbdepdoc.rec.ApplType   != 7           )     ) or
           (   sbdepdoc.rec.TypeOper   == OP_GETPOR         ) or
           (   sbdepdoc.rec.TypeOper   == OP_GETLPR         ) or
           ( ( sbdepdoc.rec.TypeOper   == OP_GETIN    ) and
          // ( sbdepdoc.rec.ApplType   != 11          )     ) or
             ( sbdepdoc.rec.KindOp     != D_PUT       )     ) or
           (   sbdepdoc.rec.TypeOper   == OP_GETOWN         ) or
           (   sbdepdoc.rec.TypeOper   == OP_GETALIEN       ) or
           ( ( sbdepdoc.rec.TypeOper   == OP_CONVERT  ) and
          // ( sbdepdoc.rec.ApplType   != 12          )     )        ) and
             ( sbdepdoc.rec.KindOp     != D_PUT       )     )        ) and
         (     sbdepdoc.rec.Rest       == 0                          ) and
         (     depositr.rec.Open_Close != ""                         ) and
         (     depositr.rec.Close_Date == sbdepdoc.rec.Date_Document ) and
         (     sbdepdoc.rec.IsControl  != ""                         )    ) or
               IsQuasiCloseOp( )                                               )
    if ( IsRez )
      ACloseR( j ) = ACloseR( j ) + 1;
      AOpenR ( j ) = AOpenR ( j ) - 1;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurClosR( j ) = ACurClosR( j ) + 1;
      end;
    else
      ACloseNR( j ) = ACloseNR( j ) + 1;
      AOpenNR ( j ) = AOpenNR ( j ) - 1;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurClosNR( j ) = ACurClosNR( j ) + 1;
      end;
    end;
  end;

  // Изменили тип счета
  if ( ( sbdepdoc.rec.TypeOper == 78 ) and ( sbdepdoc.rec.InSum > 0 ) )
    RestEstim = DefRestEstimForDate( );
    if ( IsRez )
      AColR ( j ) = AColR ( j ) + 1;
      AOpenR( j ) = AOpenR( j ) + 1;
      AEstimInR  ( j ) = AEstimInR  ( j ) + RestEstim;
      AEstimRestR( j ) = AEstimRestR( j ) + RestEstim;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurOpenR( j ) = ACurOpenR( j ) + 1;
      end;
    else
      AColNR ( j ) = AColNR ( j ) + 1;
      AOpenNR( j ) = AOpenNR( j ) + 1;
      AEstimInNR  ( j ) = AEstimInNR  ( j ) + RestEstim;
      AEstimRestNR( j ) = AEstimRestNR( j ) + RestEstim;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurOpenNR( j ) = ACurOpenNR( j ) + 1;
      end;
    end;
  end;
  if ( ( sbdepdoc.rec.TypeOper == 78 ) and ( sbdepdoc.rec.OutSum > 0 ) )
    RestEstim = DefRestEstimForDate( );
    if ( IsRez )
      AColR ( j ) = AColR ( j ) - 1;
      AOpenR( j ) = AOpenR( j ) - 1;
      AEstimOverR( j ) = AEstimOverR( j ) + RestEstim;
      AEstimRestR( j ) = AEstimRestR( j ) - RestEstim;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurClosR( j ) = ACurClosR( j ) + 1;
      end;
    else
      AColNR ( j ) = AColNR ( j ) - 1;
      AOpenNR( j ) = AOpenNR( j ) - 1;
      AEstimOverNR( j ) = AEstimOverNR( j ) + RestEstim;
      AEstimRestNR( j ) = AEstimRestNR( j ) - RestEstim;
      if ( sbdepdoc.rec.Date_Document == CurDate )
        ACurClosNR( j ) = ACurClosNR( j ) + 1;
      end;
    end;
  end;

end;


/**************************************************************************\
|              Определение данных по вкладу за начальную дату              |
\**************************************************************************/
macro DefBegParamsForAccount

  var stat;
  var IsRezid  = DefRezForAccount( );
  var FirstDoc = true;
  var j;

  sbdepdoc.KeyNum = 6;
  sbdepdoc.Clear;
  sbdepdoc.rec.Referenc      = depositr.rec.Referenc;
  sbdepdoc.rec.Date_Document = BeginFirstQuart;
  sbdepdoc.rec.NumDayDoc     = 0;
  sbdepdoc.addFilter( "t.t_Referenc = " + string( depositr.rec.Referenc ) + " and " +
                      "t.t_Date_Document between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                                     sqlDateToStr( BeginFirstQuart )            );
  stat = sbdepdoc.GetLT;
  while ( stat )
    if ( sbdepdoc.rec.Referenc == depositr.rec.Referenc )
      if ( IsServDoc2( sbdepdoc.rec ) and ( sbdepdoc.rec.FlagStorn == "" ) )
        if ( ( depositr.rec.Type_Account == "Объединенный" ) and
             ( sbdepdoc.rec.Type_Account == "Объединенный" )    )
          if ( FirstDoc )
            j = DefNumElemForKind( IsRezid, sbdepdoc.rec.Type_Account, sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
            if ( IsRezid )
              ARestR( j ) = ARestR( j ) + sbdepdoc.rec.Rest;
            else
              ARestNR( j ) = ARestNR( j ) + sbdepdoc.rec.Rest;
            end;
          end;
        elif ( depositr.rec.Type_Account != "Объединенный" )
          if ( Index( depositr.rec.UserTypeAccount, "Н" ) == 0 )
            j = DefNumElemForKind( IsRezid, sbdepdoc.rec.Type_Account, sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
          else
            j = DefNumElemForKind( IsRezid, "Неподвижный", sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
          end;
          if ( IsRezid )
            if ( FirstDoc )
              ARestR( j ) = ARestR( j ) + sbdepdoc.rec.Rest;
              AColR ( j ) = AColR ( j ) + 1;
              if ( ( depositr.rec.Open_Close != ""              ) and
                   ( depositr.rec.Close_Date <  BeginFirstQuart )    )
                ACloseR(j) = ACloseR(j) + 1;
              else
                AOpenR (j) = AOpenR (j) + 1;
              end;
            end;
            if ( sbdepdoc.rec.TypeOper == 72 )
              sbdepdoc2.SetRecordAddr( sbdepdoc, 0, 0, true );
              AEstimRestR( j ) = AEstimRestR( j ) - sbdepdoc2.rec.SummaEstim - sbdepdoc2.rec.SummaOverEstim;
            end;
          else
            if ( FirstDoc )
              ARestNR( j ) = ARestNR( j ) + sbdepdoc.rec.Rest;
              AColNR ( j ) = AColNR ( j ) + 1;
              if ( ( depositr.rec.Open_Close != ""              ) and
                   ( depositr.rec.Close_Date <  BeginFirstQuart )    )
                ACloseNR( j ) = ACloseNR( j ) + 1;
              else
                AOpenNR ( j ) = AOpenNR ( j ) + 1;
              end;
            end;
            if ( sbdepdoc.rec.TypeOper == 72 )
              sbdepdoc2.SetRecordAddr( sbdepdoc, 0, 0, true );
              AEstimRestNR( j ) = AEstimRestNR( j ) - sbdepdoc2.rec.SummaEstim - sbdepdoc2.rec.SummaOverEstim;
            end;
          end;
        end;
        FirstDoc = false;
      end;
      stat = sbdepdoc.Prev;
    else
      stat = false;
    end;
  end;
  sbdepdoc.dropFilter;

  sbdepdoc.ReWind;
  sbdepdoc.Clear;
  sbdepdoc.rec.Referenc      = depositr.rec.Referenc;
  sbdepdoc.rec.Date_Document = BeginFirstQuart;
  sbdepdoc.rec.NumDayDoc     = 0;
  sbdepdoc.addFilter( "t.t_Referenc = " + string( depositr.rec.Referenc ) + " and " +
                      "t.t_Date_Document >= " + sqlDateToStr( BeginFirstQuart )      );
  stat = sbdepdoc.GetGE;
  while ( stat )
    if ( ( sbdepdoc.rec.Referenc      == depositr.rec.Referenc ) and
         ( sbdepdoc.rec.Date_Document <= BegDate               )    )
      if ( ( depositr.rec.Type_Account == "Объединенный" ) and
           ( sbdepdoc.rec.Type_Account != "Объединенный" )    )
        ; // Для BegDate - только док-ты с Mode == 0
      elif ( (   IsServDoc2( sbdepdoc.rec )                ) and
             (   sbdepdoc.rec.FlagStorn == ""              ) and
             ( ( sbdepdoc.rec.Date_Document <  BegDate ) or
               ( sbdepdoc.rec.Mode          == 0       )   )    )
        if ( FirstDoc and ( depositr.rec.Type_Account != "Объединенный" ) ) // ЛСВ 05.05.2000 История по счету была обрезана
          FirstDoc = false;
          if ( ( sbdepdoc.rec.TypeOper == OP_OPENCAS ) or
               ( sbdepdoc.rec.TypeOper == OP_OPENNCS ) or
               ( sbdepdoc.rec.TypeOper == OP_OPENTRN ) or
                 IsQuasiOpenOp( )                        )
            ;
          else
            if ( Index( depositr.rec.UserTypeAccount, "Н" ) == 0 )
              j = DefNumElemForKind( IsRezid, sbdepdoc.rec.Type_Account, sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
            else
              j = DefNumElemForKind( IsRezid, "Неподвижный", sbdepdoc.rec.Code_Currency, depositr.rec.GroupNumb );
            end;
            if ( IsRezid )
              ARestR( j ) = ARestR( j ) + sbdepdoc.rec.Rest - sbdepdoc.rec.InSum + sbdepdoc.rec.OutSum;
              AColR ( j ) = AColR ( j ) + 1;
              AOpenR( j ) = AOpenR( j ) + 1;
            else
              ARestNR( j ) = ARestNR( j ) + sbdepdoc.rec.Rest - sbdepdoc.rec.InSum + sbdepdoc.rec.OutSum;
              AColNR ( j ) = AColNR ( j ) + 1;
              AOpenNR( j ) = AOpenNR( j ) + 1;
            end;
          end;
        end;
        WorkWithOneDepDoc( IsRezid );
      end;
      stat = sbdepdoc.Next;
    else
      stat = false;
    end;
  end;
  sbdepdoc.dropFilter;

  pcestim.Clear;
  pcestim.rec.Referenc   = depositr.rec.Referenc;
  pcestim.rec.DateOperat = Date( 0, 0, 0 );
  pcestim.rec.NumDayDoc  = 0;
  pcestim.addFilter( "t.t_Referenc = " + string( depositr.rec.Referenc ) + " and " +
                     "t.t_DateOperat between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                                 sqlDateToStr( BegDate )                    );
  stat = pcestim.GetGE;
  while ( stat )
    if ( ( pcestim.rec.Referenc   == depositr.rec.Referenc ) and
         ( pcestim.rec.DateOperat <= BegDate               )    )
      if ( ( (   pcestim.rec.TypeComplexOper == 38                                      ) or
             ( ( pcestim.rec.TypeComplexOper == 72 ) and ( pcestim.rec.TypeOper == 38 ) ) or
             ( ( pcestim.rec.TypeComplexOper == 82 ) and ( pcestim.rec.TypeOper == 38 ) )   ) and
           ( pcestim.rec.Action < 2 )                                                        )
        if ( Index( depositr.rec.UserTypeAccount, "Н" ) == 0 )
          sbdepdoc6.Clear;
          sbdepdoc6.rec.Referenc      = depositr.rec.Referenc;
          sbdepdoc6.rec.Date_Document = pcestim.rec.DateOperat + 1;
          sbdepdoc6.rec.NumDayDoc     = 0;
          sbdepdoc6.addFilter( "t.t_Referenc = " + string( depositr.rec.Referenc ) + " and " +
                               "t.t_Date_Document between " + sqlDateToStr( Date( 0, 0, 0 ) ) + " and " +
                                                              sqlDateToStr( pcestim.rec.DateOperat + 1 ) );
          if ( sbdepdoc6.GetLT and ( sbdepdoc6.rec.Referenc == depositr.rec.Referenc ) )
            j = DefNumElemForKind( IsRezid, sbdepdoc6.rec.Type_Account, depositr.rec.Code_Currency, depositr.rec.GroupNumb );
          else
            j = DefNumElemForKind( IsRezid, depositr.rec.Type_Account, depositr.rec.Code_Currency, depositr.rec.GroupNumb );
          end;
          sbdepdoc6.dropFilter;
        else
          j = DefNumElemForKind( IsRezid, "Неподвижный", depositr.rec.Code_Currency, depositr.rec.GroupNumb );
        end;
        if ( IsRezid )
          AEstimRestR( j ) = AEstimRestR( j ) + pcestim.rec.SummaPay_In - pcestim.rec.SummaPay_Out;
          if ( pcestim.rec.DateOperat == CurDate )
            AEstimInR  ( j ) = AEstimInR  ( j ) + pcestim.rec.SummaPay_In;
            AEstimOverR( j ) = AEstimOverR( j ) + pcestim.rec.SummaPay_Out;
          end;
        else
          AEstimRestNR( j ) = AEstimRestNR( j ) + pcestim.rec.SummaPay_In - pcestim.rec.SummaPay_Out;
          if ( pcestim.rec.DateOperat == CurDate )
            AEstimInNR  ( j ) = AEstimInNR  ( j ) + pcestim.rec.SummaPay_In;
            AEstimOverNR( j ) = AEstimOverNR( j ) + pcestim.rec.SummaPay_Out;
          end;
        end;
      end;
      stat = pcestim.Next;
    else
      stat = false;
    end;
  end;
  pcestim.dropFilter;

end;


/**************************************************************************\
|              Определение данных по вкладам за начальную дату             |
\**************************************************************************/
macro DefBeginParams

  var stat;
  var str;
  var i;
  var j = 0;
  var NumElem;
  var IsRez;

  depositr.KeyNum = 1;
  depositr.Clear;
  depositr.rec.IsCur         = FlagCur;
  depositr.rec.FNCash        = FNCash;
  depositr.rec.Open_Close    = "";
  depositr.rec.Type_Account  = "";
  depositr.rec.Code_Currency = -1;
  depositr.rec.Number        = 0;
  depositr.addFilter( "t.t_IsCur = " + string( FlagCur ) + " and " +
                      "t.t_FNCash = " + string( FNCash )            );
  stat = depositr.GetGE;
  while ( stat )
    if ( ( depositr.rec.IsCur  == FlagCur ) and
         ( depositr.rec.FNCash == FNCash  )    )
      if ( ( depositr.rec.Type_Account == "Шаблонный"        ) or
           ( depositr.rec.Type_Account == "Служебный"        ) or
           ( depositr.rec.Type_Account == "Неподвижный"      ) or
           ( depositr.rec.Type_Account == "Объединенный"     ) or
           ( Index( depositr.rec.UserTypeAccount, "С" ) != 0 ) or
           ( Index( depositr.rec.UserTypeAccount, "Н" ) != 0 ) or
           ( depositr.rec.Action       == DD_DELETE          ) or
           ( depositr.rec.Open_Date    >  CurDate            )   )
        ;
      else
        j = j + 1;
        Message( " Формирование статистики за " + String( CurDate ) + ". Счет " + String( j:5 ) );
        DefBegParamsForAccount( );
      end;
      stat = depositr.Next;
    else
      stat = false;
    end;
  end;
  depositr.dropFilter;

  // Для оперчасти создается статистика по неподвижным и объединенным счетам
  if ( FNCash == OpBranch )
    // Неподвижные счета
    i = 0;
    while ( i < ASize( ABranch ) )
      depositr.KeyNum = 5;
      depositr.Clear;
      depositr.rec.FNCash        = ABranch( i );
      depositr.rec.SvodAccount   = StrFor( 1 );
      depositr.rec.Code_Currency = -1;
      depositr.rec.Type_Account  = "";
      depositr.rec.Number        = 0;
      depositr.addFilter( "t.t_FNCash = " + string( ABranch( i ) ) );
      stat = depositr.GetGE;
      while ( stat )
        if ( ( depositr.rec.FNCash      == ABranch( i ) ) and
             ( depositr.rec.SvodAccount != ""           )    )
          if ( ( depositr.rec.IsCur        != FlagCur            ) or
               ( depositr.rec.Type_Account == "Шаблонный"        ) or
               ( depositr.rec.Type_Account == "Служебный"        ) or
               ( depositr.rec.Type_Account == "Неподвижный"      ) or
               ( depositr.rec.Type_Account == "Объединенный"     ) or
               ( Index( depositr.rec.UserTypeAccount, "С" ) != 0 ) or
               ( Index( depositr.rec.UserTypeAccount, "Н" ) == 0 ) or
               ( depositr.rec.Action       == DD_DELETE          ) or
               ( depositr.rec.Open_Date    >  CurDate            )   )
            ;
          else
            j = j + 1;
            Message( " Формирование статистики за " + String( CurDate ) + ". Счет " + String( j:5 ) );
            DefBegParamsForAccount( );
          end;
          stat = depositr.Next;
        else
          stat = false;
        end;
      end;
      depositr.dropFilter;
      i = i + 1;
    end;

    // Объединенные счета
    i = 0;
    while ( i < ASize( ABranch ) )
      depositr.KeyNum = 6;
      depositr.Clear;
      depositr.rec.IsCur        = FlagCur;
      depositr.rec.FNCash       = ABranch( i );
      depositr.rec.Type_Account = "Объединенный";
      depositr.rec.End_DateDep  = Date( 0, 0, 0 );
      depositr.addFilter( "t.t_IsCur = " + string(  FlagCur ) + " and " +
                          "t.t_FNCash = " + string( ABranch( i ) ) + " and " +
                          "t.t_Type_Account = " + GetSQLString( "Объединенный" ) );
      stat = depositr.GetGE;
      while ( stat )
        if ( ( depositr.rec.IsCur        == FlagCur        ) and
             ( depositr.rec.FNCash       == ABranch( i )   ) and
             ( depositr.rec.Type_Account == "Объединенный" )    )
          if ( ( depositr.rec.Action    == DD_DELETE ) or
               ( depositr.rec.Open_Date >  CurDate   )   )
            ;
          else
            j = j + 1;
            Message( " Формирование статистики за " + String( CurDate ) + ". Счет " + String( j:5 ) );
            DefBegParamsForAccount( );
            IsRez = DefRezForAccount( );
            NumElem = DefNumElemForUnionKind( IsRez, depositr.rec.Code_Currency );
            if (IsRez)
              AColUnionR(NumElem)  = AColUnionR(NumElem)  + 1;
            else
              AColUnionNR(NumElem) = AColUnionNR(NumElem) + 1;
            end;
            if ( ( depositr.rec.Open_Close != ""       ) and
                 ( depositr.rec.Close_Date <=  CurDate )    )
              if ( IsRez )
                ACloseUnionR( NumElem )  = ACloseUnionR( NumElem )  + 1;
              else
                ACloseUnionNR( NumElem ) = ACloseUnionNR( NumElem ) + 1;
              end;
            else
              if ( IsRez )
                AOpenUnionR(NumElem)  = AOpenUnionR( NumElem )  + 1;
              else
                AOpenUnionNR(NumElem) = AOpenUnionNR( NumElem ) + 1;
              end;
            end;
          end;
          stat = depositr.Next;
        else
          stat = false;
        end;
      end;
      depositr.dropFilter;
      i = i + 1;
    end;
    CorrectCountUnionKind( );
  end;

  // Корректировка остатков по вкладам
  if ( NOT NeedFormRest1 )
    // Резиденты
    i = 0;
    while ( i < ASize( ATypeR ) )
      if ( FindCurrency( ACodCurR( i ) ) )
        str = currency.rec.Short_Name;
      else
        str = String( ACodCurR( i ) );
      end;
      str = "Остаток по " + ATypeR( i ) + " (рез.) " + str + " на окончание " + String( BegDate );
      ARestR( i ) = DefRestForType( ARestR( i ), ATypeR( i ), ACodCurR( i ), "", ABalAccR( i ) );
      GetMoney( ARestR( i ), str, 20 );
      i = i + 1;
    end;
    // Нерезиденты
    i = 0;
    while ( i < ASize( ATypeNR ) )
      if ( FindCurrency( ACodCurNR( i ) ) )
        str = currency.rec.Short_Name;
      else
        str = String( ACodCurR( i ) );
      end;
      ARestNR( i ) = DefRestForType( ARestNR( i ), ATypeNR( i ), ACodCurNR( i ), "\x01", ABalAccNR( i ) );
      str = "Остаток по " + ATypeNR( i ) + " (нерез.) " + str + " на окончание " + String( BegDate );
      GetMoney( ARestNR( i ), str, 20 );
      i = i + 1;
    end;
  end;

end;


/**************************************************************************\
|         Определение данных по вкладам за текущую дату и режим            |
\**************************************************************************/
macro DefCurrentParams

  var stat;
  var flag;
  var IsRez;
  var NumElem;
  var i = 0;
  var j;

  // Обнуление дневных параметров
  while ( i < ASize( AInSumNR ) )
    AInSumNR    ( i ) = $0.0L;
    AOutSumNR   ( i ) = $0.0L;
    AHInSumNR   ( i ) = $0.0L;
    AHOutSumNR  ( i ) = $0.0L;
    AMInSumNR   ( i ) = $0.0L;
    AMOutSumNR  ( i ) = $0.0L;
    AEstimInNR  ( i ) = $0.0L;
    AEstimOutNR ( i ) = $0.0L;
    AEstimOverNR( i ) = $0.0L;
    ACurOpenNR  ( i ) = 0;
    ACurClosNR  ( i ) = 0;
    i = i + 1;
  end;

  i = 0;
  while ( i < ASize( AInSumR ) )
    AInSumR    ( i ) = $0.0L;
    AOutSumR   ( i ) = $0.0L;
    AHInSumR   ( i ) = $0.0L;
    AHOutSumR  ( i ) = $0.0L;
    AMInSumR   ( i ) = $0.0L;
    AMOutSumR  ( i ) = $0.0L;
    AEstimInR  ( i ) = $0.0L;
    AEstimOutR ( i ) = $0.0L;
    AEstimOverR( i ) = $0.0L;
    ACurOpenR  ( i ) = 0;
    ACurClosR  ( i ) = 0;
    i = i + 1;
  end;

  sbdepdoc.KeyNum = 0;
  sbdepdoc.Clear;
  sbdepdoc.rec.IsCur         = FlagCur;
  sbdepdoc.rec.FNCash        = FNCash;
  sbdepdoc.rec.Date_Document = CurDate;
  sbdepdoc.rec.Oper          = 0;
  sbdepdoc.rec.Type_Account  = "";
  sbdepdoc.rec.Code_Currency = -1;
  sbdepdoc.rec.TypeOper      = 0;
  sbdepdoc.addFilter( "t.t_IsCur = " + String( FlagCur ) + " and " +
                      "t.t_FNCash = " + String( FNCash ) +  " and " +
                      "t.t_Date_Document = " + sqlDateToStr( CurDate ) );
  stat = sbdepdoc.GetGE;
  while ( stat )
    if ( ( sbdepdoc.rec.IsCur         == FlagCur ) and
         ( sbdepdoc.rec.FNCash        == FNCash  ) and
         ( sbdepdoc.rec.Date_Document == CurDate )    )
      if ( ( sbdepdoc.rec.Type_Account == "Шаблонный" ) or
           ( sbdepdoc.rec.Type_Account == "Служебный" )   )
        ;
      else
        if ( IsServDoc2_with_est( sbdepdoc.rec ) and ( sbdepdoc.rec.FlagStorn == "" ) and ( sbdepdoc.rec.Mode == Mode ) )
          IsRez = DefRezForDepDoc( );
          if ( (Index( depositr.rec.UserTypeAccount, "Н" ) == 0 ) and ( depositr.rec.Type_Account != "Неподвижный" ) )
            if ( ( depositr.rec.Type_Account == "Объединенный" ) and ( sbdepdoc.rec.Type_Account != "Объединенный" ) )
              ;
            else
              WorkWithOneDepDoc( IsRez );
            end;
          end;
        end;
      end;
      stat = sbdepdoc.Next;
    else
      stat = false;
    end;
  end;
  sbdepdoc.dropFilter;

  // Для оперчасти создается статистика по неподвижным и объединенным счетам
  if ( FNCash == OpBranch )
    // Неподвижные счета -------------------------------------------------
    i = 0;
    while ( i < ASize( ABranch ) )
      depositr.KeyNum = 5;
      depositr.Clear;
      depositr.rec.FNCash        = ABranch( i );
      depositr.rec.SvodAccount   = StrFor( 1 );
      depositr.rec.Code_Currency = -1;
      depositr.rec.Type_Account  = "";
      depositr.rec.Number        = 0;
      depositr.addFilter( "t.t_FNCash = " + string( ABranch( i ) ) );
      stat = depositr.GetGE;
      while ( stat )
        if ( ( depositr.rec.FNCash      == ABranch( i ) ) and
             ( depositr.rec.SvodAccount != ""           )    )
          if ( ( depositr.rec.IsCur        != FlagCur            ) or
               ( depositr.rec.Type_Account == "Шаблонный"        ) or
               ( depositr.rec.Type_Account == "Служебный"        ) or
               ( depositr.rec.Type_Account == "Неподвижный"      ) or
               ( depositr.rec.Type_Account == "Объединенный"     ) or
               ( Index( depositr.rec.UserTypeAccount, "С" ) != 0 ) or
               ( Index( depositr.rec.UserTypeAccount, "Н" ) == 0 ) or
               ( depositr.rec.Action       == DD_DELETE          ) or
               ( depositr.rec.Open_Date    >  CurDate            )   )
            ;
          else
            sbdepdoc.KeyNum = 6;
            sbdepdoc.Clear;
            sbdepdoc.rec.Referenc      = depositr.rec.Referenc;
            sbdepdoc.rec.Date_Document = CurDate;
            sbdepdoc.rec.NumDayDoc     = 0;
            sbdepdoc.addFilter( "t.t_Referenc = " + String( depositr.rec.Referenc ) + " and " +
                                "t.t_Date_Document = " + sqlDateToStr( CurDate )               );
            flag = sbdepdoc.GetGE;
            while ( flag )
              if ( ( sbdepdoc.rec.Referenc      == depositr.rec.Referenc ) and
                   ( sbdepdoc.rec.Date_Document == CurDate               )    )
                if ( IsServDoc2( sbdepdoc.rec ) and ( sbdepdoc.rec.FlagStorn == "" ) and ( sbdepdoc.rec.Mode == Mode ) )
                  IsRez = DefRezForAccount( );
                  WorkWithOneDepDoc( IsRez );
                end;
                flag = sbdepdoc.Next;
              else
                flag = false;
              end;
            end;
            sbdepdoc.dropFilter;
          end;
          stat = depositr.Next;
        else
          stat = false;
        end;
      end;
      depositr.dropFilter;
      i = i + 1;
    end;

    // Объединенные счета ------------------------------------------------
    i = 0;
    while ( i < ASize( ABranch ) )
      depositr.KeyNum = 6;
      depositr.Clear;
      depositr.rec.IsCur        = FlagCur;
      depositr.rec.FNCash       = ABranch( i );
      depositr.rec.Type_Account = "Объединенный";
      depositr.rec.End_DateDep  = Date( 0, 0, 0 );
      depositr.addFilter( "t.t_IsCur = " + string(  FlagCur ) + " and " +
                          "t.t_FNCash = " + string( ABranch( i ) ) + " and " +
                          "t.t_Type_Account = " + GetSQLString( "Объединенный" ) );
      stat = depositr.GetGE;
      while (stat)
        if ( ( depositr.rec.IsCur        == FlagCur        ) and
             ( depositr.rec.FNCash       == ABranch( i )   ) and
             ( depositr.rec.Type_Account == "Объединенный" )    )
          if ( depositr.rec.Action != DD_DELETE )
            if ( ( depositr.rec.Open_Date  == CurDate ) or
                 ( depositr.rec.Close_Date == CurDate )   )
              IsRez = DefRezForAccount();
              NumElem = DefNumElemForUnionKind( IsRez, depositr.rec.Code_Currency );
              if ( depositr.rec.Open_Date == CurDate )
                if ( IsRez )
                  AColUnionR( NumElem )  = AColUnionR( NumElem )  + 1;
                  AOpenUnionR( NumElem ) = AOpenUnionR( NumElem ) + 1;
                else
                  AColUnionNR( NumElem )  = AColUnionNR( NumElem )  + 1;
                  AOpenUnionNR( NumElem ) = AOpenUnionNR( NumElem ) + 1;
                end;
              end;
              if ( depositr.rec.Close_Date == CurDate )
                if ( IsRez )
                  ACloseUnionR( NumElem ) = ACloseUnionR( NumElem ) + 1;
                  AOpenUnionR( NumElem )  = AOpenUnionR( NumElem )  - 1;
                else
                  ACloseUnionNR( NumElem ) = ACloseUnionNR( NumElem ) + 1;
                  AOpenUnionNR( NumElem )  = AOpenUnionNR( NumElem )  - 1;
                end;
              end;
            end;
          end;
          stat = depositr.Next;
        else
          stat = false;
        end;
      end;
      depositr.dropFilter;
      i = i + 1;
    end;
    CorrectCountUnionKind( );
  end;

end;


/**************************************************************************\
|                        Заполнение файла статистики                       |
\**************************************************************************/
macro WriteToStat

  var i;

  Message( " Формирование статистики за " + String( CurDate ) + ". Заполнение файла" );

  // Вставляем запись для резидентов -------------------------------------
  i = 0;
  while ( i < ASize( ATypeR ) )
    if ( (     AInSumR    ( i ) != 0           ) or
         (     AOutSumR   ( i ) != 0           ) or
         (     AMInSumR   ( i ) != 0           ) or
         (     AMOutSumR  ( i ) != 0           ) or
         (     AEstimInR  ( i ) != 0           ) or
         (     AEstimOutR ( i ) != 0           ) or
         (     AEstimOverR( i ) != 0           ) or
         (     ACurOpenR  ( i ) != 0           ) or
         (     ACurClosR  ( i ) != 0           ) or
         ( (   CurDate     == BegDate     ) and
           (   Mode        == 0           ) and
           ( ( ARestR( i ) != 0       ) or
             ( AColR ( i ) != 0       )   )    )   )
      sb_depst.KeyNum = 0;
      sb_depst.Clear;
      sb_depst.rec.FNCash  = FNCash;
      sb_depst.rec.IsCur   = FlagCur;
      sb_depst.rec.Kind    = ATypeR( i );
      sb_depst.rec.CodCur  = ACodCurR( i );
      sb_depst.rec.FlagRez = "\x00";
      sb_depst.rec.BalAcc  = ABalAccR( i );
      sb_depst.rec.Date    = CurDate;
      sb_depst.rec.Mode    = Mode;
      if ( sb_depst.GetEQ )
        sb_depst.Delete;
      end;
      sb_depst.Clear;
      sb_depst.rec.IsCur         = FlagCur;
      sb_depst.rec.Kind          = ATypeR( i );
      sb_depst.rec.CodCur        = ACodCurR( i );
      sb_depst.rec.Date          = CurDate;
      sb_depst.rec.ColAccounts   = AColR( i );
      sb_depst.rec.ColOpenedAcc  = AOpenR( i );
      sb_depst.rec.ColClosedAcc  = ACloseR( i );
      sb_depst.rec.Rest          = ARestR( i );
      sb_depst.rec.DebSum        = AOutSumR( i );
      sb_depst.rec.KredSum       = AInSumR( i );
      sb_depst.rec.HiddenDebSum  = AHOutSumR( i );
      sb_depst.rec.HiddenKredSum = AHInSumR( i );
      sb_depst.rec.MemDebSum     = AMOutSumR( i );
      sb_depst.rec.MemKredSum    = AMInSumR( i );
      sb_depst.rec.MemInOper     = AMInOperR( i );
      sb_depst.rec.ColOper       = AColOperR( i );
      sb_depst.rec.OpenInOper    = AOpenOpR( i );
      sb_depst.rec.DopInOper     = ADopOpR( i );
      sb_depst.rec.OutOper       = AOutOpR( i );
      sb_depst.rec.EstimRest     = AEstimRestR( i );
      sb_depst.rec.EstimIn       = AEstimInR( i );
      sb_depst.rec.EstimOut      = AEstimOutR( i );
      sb_depst.rec.EstimOverOut  = AEstimOverR( i );
      sb_depst.rec.CurOpenAc     = ACurOpenR( i );
      sb_depst.rec.CurClosAc     = ACurClosR( i );
      sb_depst.rec.FNCash        = FNCash;
      sb_depst.rec.Mode          = Mode;
      sb_depst.rec.BalAcc        = ABalAccR( i );

      sb_depst.Insert;
    end;
    i = i + 1;
  end;

  // Вставляем запись для нерезидентов -----------------------------------
  i = 0;
  while ( i < ASize( ATypeNR ) )
    if ( (     AInSumNR    ( i ) != 0           ) or
         (     AOutSumNR   ( i ) != 0           ) or
         (     AMInSumNR   ( i ) != 0           ) or
         (     AMOutSumNR  ( i ) != 0           ) or
         (     AEstimInNR  ( i ) != 0           ) or
         (     AEstimOutNR ( i ) != 0           ) or
         (     AEstimOverNR( i ) != 0           ) or
         (     ACurOpenNR  ( i ) != 0           ) or
         (     ACurClosNR  ( i ) != 0           ) or
         ( (   CurDate       == BegDate     ) and
           (   Mode          == 0           ) and
           ( ( ARestNR( i ) != 0       ) or
             ( AColNR ( i ) != 0       )   )    )   )
      sb_depst.KeyNum = 0;
      sb_depst.Clear;
      sb_depst.rec.FNCash  = FNCash;
      sb_depst.rec.IsCur   = FlagCur;
      sb_depst.rec.Kind    = ATypeNR( i );
      sb_depst.rec.CodCur  = ACodCurNR( i );
      sb_depst.rec.FlagRez = "\x01";
      sb_depst.rec.BalAcc  = ABalAccNR( i );
      sb_depst.rec.Date    = CurDate;
      sb_depst.rec.Mode    = Mode;
      if ( sb_depst.GetEQ )
        sb_depst.Delete;
      end;
      sb_depst.Clear;
      sb_depst.rec.IsCur         = FlagCur;
      sb_depst.rec.Kind          = ATypeNR( i );
      sb_depst.rec.CodCur        = ACodCurNR( i );
      sb_depst.rec.Date          = CurDate;
      sb_depst.rec.ColAccounts   = AColNR( i );
      sb_depst.rec.ColOpenedAcc  = AOpenNR( i );
      sb_depst.rec.ColClosedAcc  = ACloseNR( i );
      sb_depst.rec.Rest          = ARestNR( i );
      sb_depst.rec.DebSum        = AOutSumNR( i );
      sb_depst.rec.KredSum       = AInSumNR( i );
      sb_depst.rec.HiddenDebSum  = AHOutSumNR( i );
      sb_depst.rec.HiddenKredSum = AHInSumNR( i );
      sb_depst.rec.MemDebSum     = AMOutSumNR( i );
      sb_depst.rec.MemKredSum    = AMInSumNR( i );
      sb_depst.rec.MemInOper     = AMInOperNR( i );
      sb_depst.rec.ColOper       = AColOperNR( i );
      sb_depst.rec.OpenInOper    = AOpenOpNR( i );
      sb_depst.rec.DopInOper     = ADopOpNR( i );
      sb_depst.rec.OutOper       = AOutOpNR( i );
      sb_depst.rec.EstimRest     = AEstimRestNR( i );
      sb_depst.rec.EstimIn       = AEstimInNR( i );
      sb_depst.rec.EstimOut      = AEstimOutNR( i );
      sb_depst.rec.EstimOverOut  = AEstimOverNR( i );
      sb_depst.rec.CurOpenAc     = ACurOpenNR( i );
      sb_depst.rec.CurClosAc     = ACurClosNR( i );
      sb_depst.rec.FNCash        = FNCash;
      sb_depst.rec.FlagRez       = "\x01";
      sb_depst.rec.Mode          = Mode;
      sb_depst.rec.BalAcc        = ABalAccNR( i );

      sb_depst.Insert;
    end;
    i = i + 1;
  end;

end;


/**************************************************************************\
|                     Обнуление квартальных параметров                     |
\**************************************************************************/
macro ZeroQuartalParam

  var d, m, y;
  var i;

  DateSplit( CurDate, d, m, y );
  if ( ( d == 1 ) and ( ( m == 1 ) or ( m == 4 ) or ( m == 7 ) or ( m == 10 ) ) )
    // Данные по резидентам ----------------------------------------------
    i = 0;
    while ( i < ASize( AMInOperR ) )
      AMInOperR( i ) = $0L;
      AColOperR( i ) = 0;
      AOpenOpR ( i ) = 0;
      ADopOpR  ( i ) = 0;
      AOutOpR  ( i ) = 0;
      i = i + 1;
    end;
    // Данные по нерезидентам --------------------------------------------
    i = 0;
    while ( i < ASize( AMInOperNR ) )
      AMInOperNR( i ) = $0L;
      AColOperNR( i ) = 0;
      AOpenOpNR ( i ) = 0;
      ADopOpNR  ( i ) = 0;
      AOutOpNR  ( i ) = 0;
      i = i + 1;
    end;
  end;

end;


/**************************************************************************\
|                               Чистка массива                             |
\**************************************************************************/
macro ClearArray ( A, VType )

  var i = 0;

  while ( i < ASize( A ) )
    if ( VType == V_INTEGER )
      A( i ) = 0;
    else
      A( i ) = $0L;
    end;
    i = i + 1;
  end;

end;


/**************************************************************************\
|                      Формирование файла статистики                       |
\**************************************************************************/
macro DoReport

  var d,m,y;
  var flag;
  var dpDepList = TdpDepList;

  // Очиститим все массивы
  ClearArray( AColR,     V_INTEGER );
  ClearArray( AOpenR,    V_INTEGER );
  ClearArray( ACloseR,   V_INTEGER );
  ClearArray( ARestR,    V_MONEYL  );
  ClearArray( AOutSumR,  V_MONEYL  );
  ClearArray( AInSumR,   V_MONEYL  );
  ClearArray( AHOutSumR, V_MONEYL  );
  ClearArray( AHInSumR,  V_MONEYL  );
  ClearArray( AMOutSumR, V_MONEYL  );
  ClearArray( AMInSumR,  V_MONEYL  );
  ClearArray( AMInOperR, V_MONEYL  );
  ClearArray( AColOperR, V_INTEGER );
  ClearArray( AOpenOpR,  V_INTEGER );
  ClearArray( ADopOpR,   V_INTEGER );
  ClearArray( AOutOpR,   V_INTEGER );
  ClearArray( ACurOpenR, V_INTEGER );
  ClearArray( ACurClosR, V_INTEGER );

  ClearArray( AColNR,     V_INTEGER );
  ClearArray( AOpenNR,    V_INTEGER );
  ClearArray( ACloseNR,   V_INTEGER );
  ClearArray( ARestNR,    V_MONEYL  );
  ClearArray( AOutSumNR,  V_MONEYL  );
  ClearArray( AInSumNR,   V_MONEYL  );
  ClearArray( AHOutSumNR, V_MONEYL  );
  ClearArray( AHInSumNR,  V_MONEYL  );
  ClearArray( AMOutSumNR, V_MONEYL  );
  ClearArray( AMInSumNR,  V_MONEYL  );
  ClearArray( AMInOperNR, V_MONEYL  );
  ClearArray( AColOperNR, V_INTEGER );
  ClearArray( AOpenOpNR,  V_INTEGER );
  ClearArray( ADopOpNR,   V_INTEGER );
  ClearArray( AOutOpNR,   V_INTEGER );
  ClearArray( ACurOpenNR, V_INTEGER );
  ClearArray( ACurClosNR, V_INTEGER );

  DateSplit( BegDate, d, m, y );
  if   ( ( m >= 1 ) and ( m <= 3 ) )
    m = 1;
  elif ( ( m >= 4 ) and ( m <= 6 ) )
    m = 4;
  elif ( ( m >= 7 ) and ( m <= 9 ) )
    m = 7;
  else
    m = 10;
  end;
  BeginFirstQuart = Date( 1, m, y );

  DateSplit( EndDate, d, m, y );
  if   ( ( m >= 1 ) and ( m <= 3 ) )
    m = 1;
  elif ( ( m >= 4 ) and ( m <= 6 ) )
    m = 4;
  elif ( ( m >= 7 ) and ( m <= 9 ) )
    m = 7;
  else
    m = 10;
  end;
  BeginLastQuart = Date( 1, m, y );

  dpDepList.SetFilter( dpDepList.getFilialID( NumFNCash( ) ) );
  while ( dpDepList.next( ) )
    ABranch( ASize( ABranch ) ) = dpDepList.rec.Code;
    if ( dpDepList.rec.NodeType == I_DEPARTMENT_TYPE_FILIAL/*3*/ )
      OpBranch = dpDepList.rec.Code;
    end;
  end;

  CurDate = BegDate;
  while ( CurDate <= EndDate )
    Message( " Формирование статистики за " + String( CurDate ) );
    ZeroQuartalParam( );
    Mode = 0;
    while ( Mode <= 1 )
      if ( (CurDate == BegDate ) and ( Mode == 0 ) )
        DefBeginParams( );
        if ( not NeedFormRest1 )
          DelStat( BegDate, BegDate );
        end;
      else
        DefCurrentParams( );
      end;
      WriteToStat( );
      Mode = Mode + 1;
    end;
    CurDate = CurDate + 1;
  end;

end;


/**************************************************************************\
|                    Г Л А В Н А Я   П Р О Г Р А М М А                     |
\**************************************************************************/

  var WasError = false;
  var stat;

  // Формирование статистики
  if ( GetTrue( NULL, "Заполнять файл статистики?" ) )
    if ( GetDate( BegDate, "Введите начальную дату" ) )
      if ( GetDate( EndDate, "Введите конечную дату" ) )
        if ( BegDate <= EndDate )
          NeedFormRest1 = GetTrue( NeedFormRest1, "Формировать остатки за первый день?" );
          if ( NeedFormRest1 )
            DelStat( BegDate, EndDate );
          else
            DelStat( BegDate + 1, EndDate );
          end;
          DoReport( );
        else
          WasError = true;
          [ ];
          [ Начальная дата не может быть больше конечной];
        end;
      end;
    end;
  end;

  Mode = GetCurrentMode( );

  // Вывод отчета
  if ( not WasError )

    Message( " Выводится отчет..." );

    BeginEndReport( );

    if ( FlagCur )
      currency.Clear;
      currency.rec.Code_Currency = 1;
      stat = currency.GetGE;
      while ( stat )
        SumColAccounts  = 0;
        SumColOpenedAcc = 0;
        SumColClosedAcc = 0;
        SumRest         = $0;
        SumKredSum      = $0;
        SumDebSum       = $0;
        SumColOper      = 0;
        TopReport( currency.rec.Code_Currency, false );
        WriteReportForLastDay( currency.rec.Code_Currency );
        EndReport( );
        [ ];
        [ ];
        stat = currency.Next;
      end;
    else // Отчет по национальной валюте
      TopReport( 0, true );
      WriteReportForLastDay( 0 );
      EndReport( );
    end;

    BeginEndReport( );

  end;

end;
