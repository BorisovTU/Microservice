import rcw, rsd, deprintr;
import "rt_ib_xml.mac";



// ────────────────────────────────────────────────────────────────
// Вставка отложенного документа
// ────────────────────────────────────────────────────────────────
class(cBaseDeposit) 
    cMakePostDocument( inXml, outXml ) 

  var outXML_cur;
  var psdepdoc = TBFile( "psdepdoc.dbt",  "w", 0, NULL, "sbbank.def" );
  var rtpaymprop = TBFile( "rtPaymentProp.dbt",  "w", 0, NULL, "sbbank.def" );
  var sbdepdoc1 = TRecHandler( "sbdepdoc.1" );

  var isFindAccount, isFindAccountReceiver, isFindTypeAccount;
  var rs_account, rs_accountReceiver, rs_typeAccount;
/* 
    ───────────────────
      ИСХОДНЫЕ ДАННЫЕ  
    ───────────────────

Элемент сообщения	   Тип		   Комментарий	                           Кратность
──────────────────────────┼───────────────┼───────────────────────────────────────┼──────────────
request			
├─id                       string(32)      Идентификатор запроса в системе  ИКФЛ	
└─carryDeposit_q                           


    ───────────────────
          ОТВЕТ
    ───────────────────
Элемент сообщения	Тип		Комментарий
───────────────────────┼───────────────┼──────────────────────────────────────────────────────────────────────
response			
├─parentId              string(32)      Идентификатор запроса в системе  ИКФЛ	
├─id                    string(32)      Идентификатор ответа	
└─carryDeposit_a
  ├─errorCode           int             Код ошибки
  ├─errorText           string(80)      Текст ошибки
  ├─applicationKind     int             Идентификатор документа 
  └─applicationKey      string(29)      Идентификатор документа
*/

// ────────────────────────────────────────────────────────────────
// Вставляем rt_paym_dbt
// ────────────────────────────────────────────────────────────────

  private macro insertRtPaym( rt_paym, psdepdoc )

    ClearRecord( rt_paym );

    rt_paym.rec.Branch            = psdepdoc.rec.FNCash;
    rt_paym.rec.iApplicationKind  = psdepdoc.rec.iApplicationKind;
    rt_paym.rec.ApplicationKey    = psdepdoc.rec.ApplicationKey;
    rt_paym.rec.NumSession        = 0;
    rt_paym.rec.PAYMENT           = StrFor(0);
    rt_paym.rec.RECIVFIO          = receiverName;

    SetParm( 1, rt_paym );

  end; // insertRtPaym( rt_paym, psdepdoc )

  private macro insertRtPaym3( psdepdoc )
    var stat = true;

    var rt_paym  = TBFile( "rt_paym.dbt",   "w", 0, NULL, "sbbank.def" );
    var rt_paym3 = TRecHandler( "rt_paym.fpm" );

    stat = SetRecordAddr( rt_paym3, rt_paym );
    ClearRecord( rt_paym3 );

    insertRtPaym( rt_paym, psdepdoc );

    rt_paym.rec.AttrID            = "ПЕРЕВОД";

    rt_paym3.rec.RecipAcc         = transferAccount;

    if ( not rt_paym.insert( getrecordsize( rt_paym3 ) ) )
      stat = false; 
      outXML_cur = AddError2OutXml(outXML_cur, 18189, "Ошибка при вставке записи с реквизитами перевода");
      AbortTrn;
    end; 

    return stat;
  end; // insertRtPaym3( psdepdoc )

  private macro insertRtPaym5( psdepdoc )
    var stat = true;

    var rt_paym  = TBFile( "rt_paym.dbt",   "w", 0, NULL, "sbbank.def" );
    var rt_paym5 = TRecHandler( "rt_paym.5" );

    stat = SetRecordAddr( rt_paym5, rt_paym );
    ClearRecord( rt_paym5 );

    insertRtPaym( rt_paym, psdepdoc );
    rt_paym.rec.AttrID            = "СРОК_ДОГОВОРА";
    rt_paym5.rec.Term             = term;
    rt_paym5.rec.KindTerm         = kindTerm;

    if ( not rt_paym.insert( getrecordsize( rt_paym5 ) ) )
      stat = false; 
      outXML_cur = AddError2OutXml(outXML_cur, 18189, "Ошибка при вставке записи с параметрами срока договора");
      AbortTrn;
    end; 

    return stat;
  end; // insertRtPaym5( psdepdoc )


  macro insertRtPaymProp
    var stat = true;

    rtpaymprop.rec.docapplicationkind = psdepdoc.rec.iApplicationKind;
    rtpaymprop.rec.docapplicationkey  = psdepdoc.rec.ApplicationKey;  
    if ( type == Безналичная_Конверсия )
      rtpaymprop.rec.bankcodekind = 6;
    else
      rtpaymprop.rec.bankcodekind = 3;
    end;
    if ( check_receiverBankName( outXML_cur, false ) )
      rtpaymprop.rec.bankname = receiverBankName;
    end;

    if ( check_receiverBIC( outXML_cur, false ) )
      rtpaymprop.rec.bankcode = receiverBIC;
    end;

    if ( check_receiverName( outXML_cur, false ) )
      rtpaymprop.rec.name = receiverName;
    end;
    if ( check_clientCode( outXML_cur, false ) )    
      rtpaymprop.rec.partyid = clientCode;
    end; 
    if ( check_receiverINN( outXML_cur, false ) )
      rtpaymprop.rec.inn = receiverINN;
    end;

    if ( check_receiverKPP( outXML_cur, false ) )
      rtpaymprop.rec.kpp = receiverKPP;
    end;
    rtpaymprop.rec.sessionnum = 0;


    if ( isFindAccountReceiver )
      rtpaymprop.rec.account = receiverAccount;
      if   ( check_receiverCurrency( outXML_cur, false ) ) 
        rtpaymprop.rec.account_currcode = receiverCurrency;
      else
        rtpaymprop.rec.account_currcode = rs_accountReceiver.value("t_code_currency");
      end;

      rtpaymprop.rec.corraccount = rs_accountReceiver.value("t_type_account");
      rtpaymprop.rec.branch  = rs_account.value("t_fncash");
      rtpaymprop.rec.corrbranch  = rs_accountReceiver.value("t_fncash");
    else
      if ( check_receiverAccount( outXML_cur, false ))
        rtpaymprop.rec.account  = receiverAccount;
      else
        rtpaymprop.rec.account  = strfor(0);
      end;
      if   ( check_receiverCurrency( outXML_cur, false ) ) 
        rtpaymprop.rec.account_currcode = receiverCurrency;
      elif ( isFindAccount )
        rtpaymprop.rec.account_currcode = rs_account.value("t_code_currency");
      else 
        stat = false; 
        outXML_cur = AddError2OutXml(outXML_cur, 18189, "Не удается определить валютность документа");
      end;

      if ( NameInputTag == "externalTransfer_q" )
        rtpaymprop.rec.corraccount = receiverCorAccount;
      else
        rtpaymprop.rec.corraccount = depositConditionsId;
      end;

      rtpaymprop.rec.branch  = rs_account.value("t_fncash");
      if   ( check_officeExternalId( outXML_cur, false) )  
        rtpaymprop.rec.corrbranch = officeExternalId;
      elif ( isFindAccount )
        rtpaymprop.rec.corrbranch  = rs_account.value("t_fncash");
      else 
        stat = false;
        outXML_cur = AddError2OutXml(outXML_cur, 18189, "Не удается определить подразделение получателя");
      end;

    end;

    if ( not rtpaymprop.insert ) 
      stat = false; 
      outXML_cur = AddError2OutXml(outXML_cur, 18189, "Ошибка при вставке записи реквизитов");
      AbortTrn;
    end; 

    return stat;
  end; //insertRtPaymProp


// ────────────────────────────────────────────────────────────────
// Обрабатываем данные
// ────────────────────────────────────────────────────────────────
  macro make()
    var stat = false;
    var tmpCur;

    isFindAccount         = false;
    isFindAccountReceiver = false;
    isFindTypeAccount     = false;

//    record r_psdepdoc( "psdepdoc.dbt", "sbbank.def" );

    // ────────────────────────────────────────────────────────────────
    // Проверяем, все ли параметры у нас есть
    // ────────────────────────────────────────────────────────────────

    if ( check_dateCreated( outXML_cur ) ) // Проверка общая для всех вариантов

      // Перевод со счета клиента на другой
      if  ( NameInputTag == "internalTransfer_q" ) 
        if ( ( type == null )     or 
             ( type == Списание_Переводом ) or
             ( type == Безналичная_Конверсия )
           ) 
          if ( check_chargeOffAccount( outXML_cur ) and 
               check_receiverAccount ( outXML_cur ) and
               check_chargeOffAmount ( outXML_cur )
             )
            isFindAccount         = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency ); 
            isFindAccountReceiver = findAccount( outXML_cur, rs_accountReceiver, receiverAccount, receiverCurrency );
            if ( isFindAccount  and  isFindAccountReceiver )
              stat = true;
              set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
              if ( ( type == null )  or ( subType == null ) )
                getDefaultOperation( rs_account.value("t_code_currency"), rs_accountReceiver.value("t_code_currency") );
              end;
            end;
          end;
        else
          outXML_cur = AddError2OutXml(outXML_cur, 18189, "Операция номер " + type + " не определена");         
        end;
      // Открытие счета
      elif( NameInputTag == "openDeposit_q" )
        if ( type == null )
          if ( check_chargeOffAccount ( outXML_cur )   and
               check_receiverCurrency( outXML_cur )
             )
             isFindAccount     = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency );
             getDefaultOperation( rs_account.value("t_code_currency"), receiverCurrency );
          else

           getDefaultOperation();
          end
        end;

        if ( type == Безналичная_Конверсия )
          if ( check_chargeOffAccount ( outXML_cur )   and
               check_depositConditionsId( outXML_cur ) and
               check_chargeOffAmount( outXML_cur )     and
               check_receiverCurrency( outXML_cur )
             )
            isFindAccount     = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency ); 
            isFindTypeAccount = findTypeAccount( outXML_cur, rs_typeAccount, depositConditionsId, receiverCurrency );
            if ( isFindAccount and isFindTypeAccount ) 
              stat = true;
              set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
              if ( subType == null ) subType = Безналичная_Конвертация; end;
        end;
          end;
        elif ( type == Открытие_Безналичными ) 
          if ( check_depositConditionsId( outXML_cur ) and 
               check_receiverCurrency( outXML_cur )    and
               check_officeExternalId( outXML_cur )    and
               check_clientCode( outXML_cur )
             )
            isFindTypeAccount = findTypeAccount( outXML_cur, rs_typeAccount, depositConditionsId, receiverCurrency );
            if ( isFindTypeAccount )
              if ( not check_chargeOffAmount( outXML_cur, false ) )
                stat = true;
                set_chargeOffAmountCurrency( receiverCurrency );
                getDefaultOperation( receiverCurrency, null );
              else
                outXML_cur = AddError2OutXml(outXML_cur, 18189, "Запрещено безналичное открытие счета на ненулевую сумму");
              end;   
            end;
          end; 
        elif ( type == Списание_Переводом )
          if ( check_chargeOffAccount( outXML_cur )    and 
               check_depositConditionsId( outXML_cur ) and 
               check_chargeOffAmount( outXML_cur ) 
             )
            isFindAccount = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency ); 
              if ( isFindAccount )
                stat = true;
                set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
                getDefaultOperation( receiverCurrency, null );
              end;
          end;
         else
          outXML_cur = AddError2OutXml(outXML_cur, 18189, "Операция номер " + type + " не определена");         
        end;
      // Закрытие счета
      elif( NameInputTag == "closeDeposit_q" ) 

        // Если не передан тип операции определим сначала его
        if ( ( type == null ) or ( subType == null ) )
          // Проверим номер счета
          if ( check_chargeOffAccount( outXML_cur ) and
               findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency, false ) 
             )
            // Если указан счет получатель, то по сравнению валют получаем операцию
            if   ( check_receiverAccount( outXML_cur, false ) and
                   findAccount( OutXML_cur, rs_accountReceiver, receiverAccount, receiverCurrency, false ) 
                 )
              getDefaultOperation( rs_account.value("t_code_currency"), rs_accountReceiver.value("t_code_currency") );
            else
              getDefaultOperation( null, null );
            end;
          else
            getDefaultOperation( null, null );
          end;
        end;

        // А теперь, зная операцию проверяем, все ли данные нам известны:
        if   ( ( type == Списание_По_Раз_Поруч ) or 
               ( type == Списание_По_Длит_Поруч ) or
               ( type == Списание_В_Свой_Филиал ) or 
               ( type == Списание_В_Чужой_Филиал ) 
             )
          if ( check_chargeOffAccount( outXML_cur )   and
               check_receiverName( outXML_cur )       and
               check_receiverAccount( outXML_cur )    and
               check_receiverBIC( outXML_cur )        and
               check_receiverCorAccount( outXML_cur ) and
               check_receiverINN( outXML_cur )        and
               //check_receiverKPP( outXML_cur )        and
               check_receiverBankName( outXML_cur )
             ) 
            isFindAccount = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency );
            if ( isFindAccount ) 
              stat = true;
              set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
              if ( subType == null ) subType = Без_Подоперации; end;
              // Сумма должна простовиться при проводке
              stat = findAccountRest( outXML_cur, chargeOffAmount, rs_account.value("t_referenc") );
//              chargeOffAmount = 0;
            end;
          end;
        elif ( type == Списание_Переводом ) 
          if ( check_chargeOffAccount( outXML_cur ) )
            if ( subType == null ) subType = Без_Подоперации; end;
            isFindAccount = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency );
            if ( isFindAccount )
              if   ( check_receiverAccount( outXML_cur ) )
                isFindAccountReceiver = findAccount( OutXML_cur, rs_accountReceiver, receiverAccount, receiverCurrency );
                if ( isFindAccountReceiver ) 
                  stat = true; 
                  set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
                  // Если закрытие, то определяем сумму сами, беря остаток счета
                  stat = findAccountRest( outXML_cur, chargeOffAmount, rs_account.value("t_referenc") );
                end;
              end; 
            end;
          end;
        elif ( type == Безналичная_Конверсия )
          if ( check_chargeOffAccount( outXML_cur ) )
            if ( subType == null ) subType = Безналичная_Конвертация; end;

            isFindAccount = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency );
            if ( isFindAccount )
              if ( check_receiverAccount( outXML_cur ) )
                isFindAccountReceiver = findAccount( OutXML_cur, rs_accountReceiver, receiverAccount, receiverCurrency );
                if ( isFindAccountReceiver ) 
                  stat = true;
                  set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
                  // Если закрытие, то определяем сумму сами, беря остаток счета
                  stat = findAccountRest( outXML_cur, chargeOffAmount, rs_account.value("t_referenc") );
                end; 
              end;
            end;
          end;
        else
          outXML_cur = AddError2OutXml(outXML_cur, 18189, "Операция номер " + type + " не определена");         
        end;
      // Перевод со счета клиента на счет в другом банке
      elif( NameInputTag == "externalTransfer_q" ) 
        if ( ( type == null ) or ( subType == null ) )
          getDefaultOperation( null, null );
        end;
        if ( ( type == 63 ) or
             ( type == 64 ) or
             ( type == 66 ) or
             ( type == 67 ) 
           )
          if ( check_chargeOffAccount( outXML_cur )   and
               check_chargeOffAmount( outXML_cur )    and
               check_receiverName( outXML_cur )       and
               check_receiverAccount( outXML_cur )    and
               check_receiverBIC( outXML_cur )        and
               check_receiverCorAccount( outXML_cur ) and
               //check_receiverINN( outXML_cur )        and
               //check_receiverKPP( outXML_cur )        and
               check_receiverBankName( outXML_cur )
             )
            isFindAccount = findAccount( outXML_cur, rs_account, chargeOffAccount, chargeOffAmountCurrency );
            if ( isFindAccount )
              stat = true;  
              set_chargeOffAmountCurrency( rs_account.value("t_code_currency") );
            end;
          end;
        else
          outXML_cur = AddError2OutXml(outXML_cur, 18189, "Операция номер " + type + " не определена");         
        end;
      // Непонятно как сюда попали... 
      else
        outXML_cur = AddError2OutXml(outXML_cur, 18189, "неизвестный запрос"); // В принципе этого быть не может...
      end;
    end;//if ( check_dateCreated( outXML_cur ) )
    
    if ( not stat )
      AbortTrn;
    end;

    // ────────────────────────────────────────────────────────────────
    // Формируем отложенный документ 
    // ────────────────────────────────────────────────────────────────
      psdepdoc.Clear;

      if ( isFindAccount )
        psdepdoc.rec.Referenc       = rs_account.value("t_referenc");
        psdepdoc.rec.Type_Account   = rs_account.value("t_type_account");
        psdepdoc.rec.FNCash         = rs_account.value("t_fncash");
        psdepdoc.rec.Account        = chargeOffAccount;
        psdepdoc.rec.isCur          = rs_account.value("t_iscur");
        psdepdoc.rec.OutSum         = chargeOffAmount;

        if ( check_chargeOffAmountCurrency( outXML_cur, false ) )  psdepdoc.rec.Code_Currency = chargeOffAmountCurrency;
        else                                                       psdepdoc.rec.Code_Currency = rs_account.value("t_code_currency");
        end;
        if ( check_clientCode( outXML_cur, false ) )               psdepdoc.rec.CodClient     = clientCode;
        else                                                       psdepdoc.rec.CodClient     = rs_account.value("t_codclient");
        end;

      elif ( type == Открытие_Безналичными ) 
        psdepdoc.rec.Referenc       = 0;
        psdepdoc.rec.Type_Account   = depositConditionsId;
        psdepdoc.rec.FNCash         = officeExternalId;
        psdepdoc.rec.Account        = "";
        psdepdoc.rec.Code_Currency  = chargeOffAmountCurrency;
        psdepdoc.rec.OutSum         = $0;
        psdepdoc.rec.CodClient      = clientCode;
        if ( chargeOffAmountCurrency == 0 )                        psdepdoc.rec.isCur = 0;
        else                                                       psdepdoc.rec.isCur = 1;
        end;
      else
        // не могёт такого быть!
        stat = false;
        outXML_cur = AddError2OutXml(outXML_cur, 18189, "путаница в параметрах");
      end;
      
      psdepdoc.rec.NumDayDoc         = 0;
      psdepdoc.rec.Date_Document     = null_date;
      psdepdoc.rec.Oper              = 0;
      psdepdoc.rec.VidDoc            = 0;
      psdepdoc.rec.ApplType          = subType;
      psdepdoc.rec.NDoc              = 0;
      psdepdoc.rec.NPack             = 0;
      psdepdoc.rec.KindOp            = D_GET;
      psdepdoc.rec.InSum             = 0;
      psdepdoc.rec.Rest              = 0;
      psdepdoc.rec.PercOprSum        = 0;
      psdepdoc.rec.PercRest          = 0;
      psdepdoc.rec.ArDate            = null_date;
      psdepdoc.rec.FlagStorn         = StrFor(0);
      if( not ( findClientResident( outXML_cur, psdepdoc.rec.FlagRezid, psdepdoc.rec.CodClient ) ) )
        stat = false;
      end;
      psdepdoc.rec.YesSbook          = StrFor(0);
      psdepdoc.rec.YesForm           = StrFor(0);
      psdepdoc.rec.iApplicationKind  = 1;
      psdepdoc.rec.ApplicationKey    = FormApplicationKey( 1 );
      psdepdoc.rec.ListTransfer      = 0;
      psdepdoc.rec.TypeOper          = type;
      psdepdoc.rec.NotConfirm        = StrFor(0);
      psdepdoc.rec.TypeComplexOper   = complexType;
      psdepdoc.rec.CodCashier        = 0;
      psdepdoc.rec.Author            = StrFor(0);
      psdepdoc.rec.NumSession        = 0;
      psdepdoc.rec.Action            = 0;
      psdepdoc.rec.ObjectPerc        = 0;
      psdepdoc.rec.DepDate_Document  = dateCreated;
      psdepdoc.rec.IsControl         = StrFor(0);
      psdepdoc.rec.Brigade           = 0;
      psdepdoc.rec.FlagNonCarry      = StrFor(0);
      if ( check_ground( outXML_cur, false ) )
        psdepdoc.rec.Ground          = ground;
      else
        psdepdoc.rec.Ground          = StrFor(0);
      end;
      psdepdoc.rec.ArDatePcCalc      = null_date;
      psdepdoc.rec.Mode              = 0;
      psdepdoc.rec.Source            = 0;
      psdepdoc.rec.OrderCount        = 0;
      psdepdoc.rec.Flags             = 0;
      psdepdoc.rec.KNFCode           = 0;
      psdepdoc.rec.RealFNcash        = 0;
      psdepdoc.rec.IsSuspended       = 0;
      psdepdoc.rec.Flags2            = 64;

      if ( ( type == Списание_Переводом   ) or 
           ( type == Безналичная_Конверсия )
         )
        if ( isFindAccountReceiver )
          sbdepdoc1.rec.CorrAcc_Referenc = rs_accountReceiver.value("t_referenc");
          sbdepdoc1.rec.FNcash_Receiver  = rs_accountReceiver.value("t_fncash");
        else
          sbdepdoc1.rec.CorrAcc_Referenc = 0;
          if   ( check_officeExternalId( outXML_cur, false) )  sbdepdoc1.rec.FNcash_Receiver  = officeExternalId;
          elif ( isFindAccount )                               sbdepdoc1.rec.FNcash_Receiver  = rs_account.value("t_fncash");
          else stat = false; outXML_cur = AddError2OutXml(outXML_cur, 18189, "Не удается определить подразделение");
          end;
        end;

        sbdepdoc1.rec.PercTrnRest        = 0;
        sbdepdoc1.rec.PercTrnAlt         = 0;
        sbdepdoc1.rec.DateTrnOpen        = null_date;
        sbdepdoc1.rec.DateTrnEnd         = null_date;
        sbdepdoc1.rec.CP_Kind            = 0;
        sbdepdoc1.rec.CP_Recip           = 0;
        sbdepdoc1.rec.CP_INN             = StrFor(0);
        sbdepdoc1.rec.CurrencyBought     = 0;
        sbdepdoc1.rec.CorOper            = 0;
        sbdepdoc1.rec.SummaTaxRub        = 0;
        sbdepdoc1.rec.CP_SubAccCode      = 0;

      end;

      if ( stat )
        stat = psdepdoc.insert;
        if ( not stat )
          outXML_cur = AddError2OutXml(outXML_cur, 18189, "Ошибка при вставке записи отложенного документа");
          AbortTrn;
        end; 
      end;

      // ────────────────────────────────────────────────────────────────  
      // Если надо заполняем rt_paym
      // ────────────────────────────────────────────────────────────────

      if ( stat and
            ( check_receiverAccount( outXML_cur, false ) or 
              check_depositConditionsId( outXML_cur, false ) )
         )
        stat = insertRtPaymProp;
      end;

      if ( stat and
           check_transferAccount( outXML_cur, false ) )
        stat = insertRtPaym3( psdepdoc );
      end;

      if ( stat and 
           check_period( outXML_cur, false ) )
        stat = insertRtPaym5( psdepdoc );
      end;


    return stat;
  end;//make

  // ────────────────────────────────────────────────────────────────  
  // Формируем выходной XML при успешной вставке
  // ────────────────────────────────────────────────────────────────
  private macro createDateTag

    node = nodeAnswer.appendChild( outXML_cur.createNode(1, "errorCode", "") ); 
    node.text = 0;

    node = nodeAnswer.appendChild( outXML_cur.createNode(1, "applicationKind", "") ); 
    node.text = psdepdoc.rec.iApplicationKind;
                
    node = nodeAnswer.appendChild( outXML_cur.createNode(1, "applicationKey", "") ); 
    node.text = psdepdoc.rec.ApplicationKey;

  end;

  // ────────────────────────────────────────────────────────────────  
  // Запустк процедуры
  // ────────────────────────────────────────────────────────────────
  macro start( inXml, outXml ) 

    var nodeParentElement;
    var stat = 0;

    outXML_cur = outXml;    
    if(not outXml_cur )
      outXml_cur = CreateXMLObject();
      if(not outXml_cur) return; end;

      nodeParentElement = inXml.documentElement.selectSingleNode( "//" + NameInputTag );
      CreateBeginTag( outXml_cur );
    
      if( nodeParentElement )
 
        getParameters( nodeParentElement );

        stat = ProcessTrn( 0, R2M ( this, "make") );
        
        if ( stat )
          createDateTag;
        end;
      end;

    end;//if(not outXml )

    return outXml_cur;
  end;//start( inXml, outXml ) 



end;// class(cBaseDeposit) cMakePostDocument( inXml, outXml ) 


// ───────────────────────────────────────
// Вставка отложенного документа
// ───────────────────────────────────────
macro makePayDocument( inXml, outXml ) 

  var t = cMakePostDocument;
  outXml = t.start( inXml, outXml );

  SetParm(1, outXml);
end;
