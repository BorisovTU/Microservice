/* Остатки по новым процентам VMV - 01/09/1999
   Доработано под новые ключи в файле SBDEPDOC.DBT ( key 2 ) VMV - 01/03/2000
*/


import "deprintr.mac";
import "opercode.mac";
import "files.mac";
import "servdlg.mac"; /* Обработчик диалога */
import "ISSRVDOC.MAC";
import rsd;


/* Максимальное значение приоритета
   определяется самим пользователем */
const Max_Prior = 905 ;

const
      D_AR            = 8,    /* проводка в архиве      */
      D_ARC           = 9,    /* корректировка в архиве */
      D_AUDIT_STORN   = 14,   /* Сторнирование операции */
      D_AUDIT_DELETE  = 15,   /* Удаление операции      */
      D_AUDIT_CORRECT = 16,   /* Корректировка операции */
      D_DELETE        = 2,

    VeryBigDate     = Date(31,12,2099);


var  Repfile     = "",  /* Отчет об остатках              */
     DeltaFile   = "";  /* Отчет о расхождениях в остатках */

var  Branch  = NumFNCash(),
     IsCur   = NumFlagCur ,  /* Признак валютности */
     {CNum}   ;  /* Код операциониста*/

  /* вид вкладов, выбранный в панели 1 - только открытые, 2 - только закрытые,
     3 - и те и другие. Op_type, Cl_type - выставляются соответственно.
  */
var OpClo_type     = 0;
var Op_type        = true;
var Cl_type        = true;
var SvodHeadWasOut = False; /* Глобальный флаг вывода шапки сводного отчета */

var codeCurr = 0;     /* Текущий код валюты */
var dlgCodeCur = 0;   /* Код валюты из панели */
var flagAllCur = "";  /* Флаг: все валюты */

private var ClientList = TClientList;
private var dpDepList = TdpDepList;
private var ddep = TRecHandler( "i_dp_dep.rec" );

array Type_Deposit;
array Objects;

var SpecialAccess = GetSpecialAccess(); /*имеет ли операционист спецдоступ к счетам*/
var OperMayListSpecialAccounts = GetShowSpecialAccessAccounts() and GetBankStandart(); /* может ли операционист просматривать спец счета ,не имея спец. доступа*/
var Client;

/* Получить полное имя пути из составляющих. Возвращает полное имя файла. */
macro fnmerge
(
  Path,         /* Сюда помещается полное имя, оно же возвращается. */
  Dir,          /* Директория вместе с диском                       */
  Fname,        /* Имя файла без расширения                         */
  Ext           /* Расширение                                       */
)
  Path = "";
  Dir = trim(Dir);  Fname = trim(Fname);  Ext = trim(Ext);
  if( Dir != "" )
    if( substr( Dir, strlen(Dir), 1 ) != "\\" )
      Dir = Dir + "\\";
    end;
    Path = Path + Dir;
  end;
  if( Fname != "" )
    Path = Path + Fname;
    if( Ext != "" )
      if( substr( Fname, strlen(Fname), 1 ) != "." )
        Path = Path + ".";
      end;
      if( substr( Ext, 1, 1 ) == "." ) Ext = substr( Ext, 2 ); end;
      Path = Path + Ext;
    end;
  end;
  setparm( 0, Path );
  return Path;
end;


/* Инициализатор значений */
Macro Constructor ()

  var cmd,
      TxtDir     = GetRegVal( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR", true ),
      CurIndExt   = 0 ,
      StatOpenDepFiles = False;

  StatOpenDepFiles = OpenDepFiles();
  If(StatOpenDepFiles)

     CurIndExt = String({CNum}); /* Формирование уникального дополнения файла отчёта */

     cmd = RsdCommand( NULL, string("truncate table dindrest_tmp") );
     cmd.execute();

     fnmerge( RepFile, TxtDir, "restrep" , CurIndExt);
     SetOutPut ( RepFile , false );

     fnmerge( DeltaFile, TxtDir, "delta" , CurIndExt );
     SetOutPut ( DeltaFile, false );
     SetOutPut ( RepFile , true );
  end;

  Return StatOpenDepFiles;
end;

/* Деструктор*/
macro Destructor()
   CloseDepFiles();
end;


/*Шапка краткого отчета*/
Macro OutHead ()
  [ ];
  [ Остатки  по  счетам  филиала   ###  за  ##########]
  ( ddep.rec.Code:l , dlg.DATE_REPORT:l );
  [ +----------------------------+--------------------+];
  [ |      Счет вкладчика        |     Остаток        |];
  [ |                            |                    |];
  [ +----------------------------+--------------------+];
end;


/*Шапка сводного отчета*/
Macro OutSvodHead ()
  [ ];
  [ Остатки  по  вкладам  филиала   ###  за  ########## ]
  ( ddep.rec.Code:l , dlg.DATE_REPORT:l ) ;
  [ +--------------------+-----------------+-----------------+];
  [ |     Вид вклада     |  Кол-во счетов  |     Остаток     |];
  [ |                    |                 |                 |];
  [ +--------------------+-----------------+-----------------+];
end;

/*Шапка полного отчета*/
Macro OutHeadFull ()
  [ ];
  [ Остатки  по  счетам  филиала   ###  за  ########## ]
  ( ddep.rec.Code:l , dlg.DATE_REPORT:l ) ;
  [ +----------------------------+-----------------------------------------+-----------------+];
  [ |      Счет вкладчика        |            Ф.И.О. вкладчика             |     Остаток     |];
  [ |                            |                                         |                 |];
  [ +----------------------------+-----------------------------------------+-----------------+];
end;


macro OutSvodBottomDep( Accts , Type , Type_Rest)
  [ | ################## |################ |################ |]
  ( Type : l ,Accts : r, Type_Rest : r);
  [ +--------------------+-----------------+-----------------+];
end;

macro OutBottomDep( Accts , Type , Type_Rest)
  [ +-------------------------------------------------+];
  [ | ВСЕГО СЧЕТОВ : ######################           |]
  ( Accts : l);
  [ | ИТОГ ВКЛАДА  : ##############   ############### |]
  ( Type : l , Type_Rest : r);
  [ +-------------------------------------------------+];
end;


macro OutBottomDepFull( Accts , Type , Type_Rest)
  [ +----------------------------------------------------------------------------------------+];
  [ | ВСЕГО СЧЕТОВ         :  ######################                                         |]
  ( Accts : l);
  [ | ИТОГО ПО ВИДУ ВКЛАДА :  ########################################  #################### |]
  ( Type : l , Type_Rest : r);
  [ +----------------------------------------------------------------------------------------+];
end;



macro DoLine();
[];
[];
[];
[];
[];
end;


Macro GetPC_APLTP
(
 IsCur,
 Type_Account,
 Num
)
/*
  Следующая строка PC_APLTP
*/
  var stat;
  if ( Num == 0 )
     keynum     ( pc_apltp, 0 );
     ClearRecord( pc_apltp    );
     rewind     ( pc_apltp    );

     pc_apltp.IsCur   = IsCur;
     pc_apltp.TypeRec = 1003;
     pc_apltp.Type    = Type_Account;

     stat = GetGE( pc_apltp );
  else
     stat = Next( PC_APLTP );
  end;

  if (stat)
     stat = ( ( PC_APLTP.IsCur == IsCur        ) AND
              ( PC_APLTP.Type  == Type_Account )     );
  end;

  Return Stat;
end;




/*Поиск клиента*/
macro FindDepClient()

  var StatFind = False;

  StatFind = ClientList.GetRecord( depositr.CodClient );

  Return StatFind;
end;



/*Фильтр документов*/
Macro DocFilter()
   return IsServDoc(sbdepdoc,0);
/*   var Stat = False;

   if(      (sbdepdoc.KindOp    != D_AR)             /* проводка в архиве      */
        AND (sbdepdoc.KindOp    != D_ARC)            /* корректировка в архиве */
        AND (sbdepdoc.KindOp    != D_AUDIT_STORN)    /* Сторнирование операции */
        AND (sbdepdoc.KindOp    != D_AUDIT_DELETE)   /* Удаление операции      */
        AND (sbdepdoc.KindOp    != D_AUDIT_CORRECT)  /* Корректировка операции */
        AND (sbdepdoc.Action    != D_DELETE)
        AND (sbdepdoc.IsControl != "X") )

        Stat = True;
   end;

   Return Stat;
*/
end;



/* Получить остаток по документу по дате учета */
Macro GetDoc_Date_Rest()

  var Rest     = $0,
      StatFind = False;

  /*KeyNum     ( sbdepdoc , 6 );
  Rewind     ( sbdepdoc     );
  ClearRecord( sbdepdoc     );

  Sbdepdoc.Referenc      = depositr.Referenc;
  Sbdepdoc.Date_Document = dlg.DATE_REPORT  ;
  Sbdepdoc.NumDayDoc     = 32625;

  StatFind = GetLE( sbdepdoc );
/*  println(sbdepdoc.Referenc," ",depositr.Referenc,sbdepdoc.Referenc==depositr.Referenc);
  println("DocFilter = ",DocFilter(),", StatFind = ",StatFind," Первая запись: Счет ",depositr.Account,", Дата ",dlg.DATE_REPORT,", Date = ",sbdepdoc.Date_Document,
          ", NumDD = ",sbdepdoc.NumDayDoc,", Остаток = ",sbdepdoc.Rest);
*/
  While( StatFind AND ( sbdepdoc.Referenc == depositr.Referenc  ) )
    if(DocFilter())
       Rest     = Sbdepdoc.Rest;
       StatFind = False;
    end;
    if(StatFind)
        StatFind = Prev( Sbdepdoc );
/*        println("DocFilter = ",DocFilter(),", StatFind = ",StatFind," Следующая запись: Счет ",depositr.Account,", Дата ",dlg.DATE_REPORT,", Date = ",sbdepdoc.Date_Document,
                ", NumDD = ",sbdepdoc.NumDayDoc,", Остаток = ",sbdepdoc.Rest);
*/
    end;
  end;*/
  var cmd, rs, stat = False;
  var strcmd = "SELECT t_rest, t_kindop, t_action, t_issuspended, t_typeoper, t_flags, t_mode, t_referenc " +
               "FROM dsbdepdoc_dbt " + 
               "WHERE t_referenc <= ? and t_date_document <= ? and t_NumDayDoc <= ? " +
		 "ORDER BY t_referenc desc, t_date_document desc, t_NumDayDoc desc";
              
  cmd = RsdCommand( strcmd );

  cmd.addParam("referenc",      RSDBP_IN, depositr.Referenc);
  cmd.addParam("date_document", RSDBP_IN, dlg.DATE_REPORT);
  cmd.addParam("NumDayDoc",     RSDBP_IN, 32625);

  cmd.execute; 
  rs = RsdRecordset(cmd);
  StatFind = rs.movenext;
  while (StatFind and rs.value("t_referenc") == depositr.Referenc)
      if(IsServDocForRSD(rs, 0))
         Rest     = rs.value("t_rest");
         StatFind = False;
      end;
      if(StatFind)
         StatFind = rs.movenext;
      end;
  end;
/*  println(sbdepdoc.Referenc," ",depositr.Referenc,sbdepdoc.Referenc==depositr.Referenc);
  println("DocFilter = ",DocFilter(),", StatFind = ",StatFind," Взяли запись: Счет ",depositr.Account,", Дата ",dlg.DATE_REPORT,", Date = ",sbdepdoc.Date_Document,
          ", NumDD = ",sbdepdoc.NumDayDoc,", Остаток = ",sbdepdoc.Rest);
  println("Возвращаем Rest = ",Rest);
*/
  Return Rest;
end;


/* Получить остаток по документу из карточки */
Macro GetDoc_DepDate_Rest()

  var Rest     = $0,
      StatFind = False;
  /*ClearRecord( sbdepdoc     );
  KeyNum     ( sbdepdoc , 6 ); /* yu */
  Rewind     ( sbdepdoc     );

  Sbdepdoc.Referenc           = depositr.Referenc;
  Sbdepdoc.Date_Document      = dlg.DATE_REPORT  ;  /* yu */
  Sbdepdoc.NumDayDoc          = 32625;              /* yu */

  StatFind = GetLE( sbdepdoc );
  While( StatFind AND ( sbdepdoc.Referenc == depositr.Referenc  ) )

      if( DocFilter())
         Rest     = Sbdepdoc.Rest;
         StatFind = False;
      end;

      if( StatFind )
         StatFind = Prev( Sbdepdoc );
      end;
   end;*/

  var cmd, rs, stat = False;
  var strcmd = "SELECT t_rest, t_kindop, t_action, t_issuspended, t_typeoper, t_flags, t_mode, t_referenc " +
               "FROM dsbdepdoc_dbt " + 
               "WHERE t_referenc <= ? and t_date_document <= ? and t_NumDayDoc <= ? " +
		 "ORDER BY t_referenc desc, t_date_document desc, t_NumDayDoc desc";
              
  cmd = RsdCommand( strcmd );

  cmd.addParam("referenc",      RSDBP_IN, depositr.Referenc);
  cmd.addParam("date_document", RSDBP_IN, dlg.DATE_REPORT);
  cmd.addParam("NumDayDoc",     RSDBP_IN, 32625);

  cmd.execute; 
  rs = RsdRecordset(cmd);
  StatFind = rs.movenext;
  while (StatFind and rs.value("t_referenc") == depositr.Referenc)
      if(IsServDocForRSD(rs, 0))
         Rest     = rs.value("t_rest");
         StatFind = False;
      end;
      if(StatFind)
         StatFind = rs.movenext;
      end;
   end;

   Return Rest;
end;


macro GetPC_DREST
(
 Referenc,
 Object_Type,
 Date_Rest,     /* Дата           */
 Type           /* Движение от даты:
                    0 - точный поиск строки
                    1 - поиск к началу файла
                    2 - поиск к концу файла */
)
  var stat;
  var ErrCode = 0,
      ErrText = "";

  ClearRecord( pc_drest    );
  KeyNum     ( pc_drest, 0 );

  pc_drest.Referenc     = Referenc;
  pc_drest.Type_Object  = Object_Type;
  pc_drest.Date_Rest    = Date_Rest;
  if( Type == -1 )
    if(   Date_Rest == Date( 0, 0, 0 ) )
       Type = 2;
    elif( Date_Rest == VeryBigDate     )
       Type = 1;
    end;
  end;
  if(   Type == 0 )
     stat = GetEQ( pc_drest );
  elif( Type == 1 )
     stat = GetLE( pc_drest );
  elif( Type == 2 )
     stat = GetGE( pc_drest );
  else
     stat = False;
  end;
  if( stat )
     stat = ( ( pc_drest.Referenc    == Referenc    ) AND
              ( pc_drest.Type_Object == Object_Type )     );
     if( not stat )
        ErrCode = 9;
     end;
  else
     ErrCode = Status( ErrText );
  end;
  return stat;
end;


/*Получить остаток из истории остатков */
Macro GetRest ()

  var Sum_Rest1 = 0 ,
              i = 0 ;

  while( i < Asize( Objects ) )
     if(   GetPc_Drest( depositr.Referenc, Objects( i ),
                        dlg.DATE_REPORT      , 0     ) )
        Sum_Rest1 = Sum_Rest1 + pc_drest.Rest;

     elif( GetPc_Drest( depositr.Referenc, Objects( i ),
                        dlg.DATE_REPORT      , 1     ) )
        /* Нашли входящий остаток на дату */
        Sum_Rest1 = Sum_Rest1 + pc_drest.Rest;
     end;
     i = i + 1;
  end;

  Return Sum_Rest1;
end;


/* Определим есть ли это депозит пролонгируемый */
Macro CheckDeposit( TypeDeposit )

   var StatFind = False,
       ProlDep  = 0;

   KeyNum     ( Sb_dtyp, 2 );
   Rewind     ( Sb_dtyp    );
   ClearRecord( Sb_dtyp    );

   Sb_dtyp.FlagCur = IsCur ;
   Sb_dtyp.Kind    = TypeDeposit;

   StatFind = GETEQ( Sb_dtyp );
   If( StatFind )
      if( sb_dtyp.FormContr == 30 )
          ProlDep = 1;
      end;
   end;

   Return  ProlDep;
end;


/*Формирование временного индекса*/
Macro SetIndRec( Тип_Остатка ,ClientName )

  var   Object  = 0 , /*Тип остатка*/
        Rest    = $0;
  var   IsProlDeposit = 0; /* Признак пролонгируемого депозита */

  if(depositr.UseAlternate)
      Object = 2002;
  else
      Object = 2001;
  end;


  IsProlDeposit = CheckDeposit( depositr.Type_Account );

  ClearRecord(Indx);

  indx.Referenc     = depositr.Referenc;
  indx.Account      = depositr.Account;
  indx.Type_Account = depositr.Type_Account;
  indx.Sum_Rest     = depositr.Sum_Rest;
  indx.Sum_Rest1    = GetRest( Object );

  If( IsProlDeposit )
     indx.Sum_Rest2    = GetDoc_Date_Rest();
  else
     indx.Sum_Rest2    = GetDoc_DepDate_Rest();
  end;

  indx.Client       = ClientName;
  indx.Number       = depositr.Number;

  if( depositr.Close_Date == dlg.DATE_REPORT )
     indx.Close_Date = depositr.Close_Date;
  end;

  if  ( Тип_Остатка == 0 )  Rest  = indx.Sum_Rest;
  elif( Тип_Остатка == 1 )  Rest  = indx.Sum_Rest1;
  else                      Rest  = indx.Sum_Rest2;
  end;

  if( Not( Insert( Indx ) ) )
     PrintLn("Не вставлена запись в индексный файл по счёту ",depositr.Account);
  end;

  Return Rest;
end;


/*Формирование предварительной строки индекса*/
Macro CreateIndex_Client( Accts ,Тип_Остатка )

  var  ClientName = "";

  if( FindDepClient() )
    ClientName = ClientList.CurRec.ConvertFIOFull;
  end;

  Return SetIndRec( Тип_Остатка ,ClientName );
end;


/* Поиск филиала/отделения с указанным номером */
macro FindBranch()

  var StatFind = False;
  var brID = GetBranchID();


  StatFind        = findDepartment(/*dlg.BRANCH_ID*/brID, null, ddep);
  if( Not StatFind )
     MsgBox( " Учреждение с номером ", dlg.BRANCH_ID, " не найдено|"
             " в справочнике филиалов. Работа прервана.");
  end;

 Return StatFind;
end;



/* Формирование массива вкладов для полной обработки */
Macro Make_Array_KindDep()

  var StatFind   = False,
      IndexKind  = 0,
      StatReturn = False;

  Asize(Type_Deposit,0);

  ClearRecord( Sb_dtyp    );
  KeyNum     ( Sb_dtyp, 2 );
  Rewind     ( Sb_dtyp    );

  Sb_dtyp.FlagCur = IsCur ;
  StatFind = GetGE( Sb_dtyp );

  While (  StatFind  AND  (Sb_dtyp.FlagCur == IsCur ) )
           Type_Deposit (IndexKind) = Sb_dtyp.Kind;
           StatFind  = Next( Sb_dtyp );
           IndexKind =  IndexKind + 1;
  end;

  If( Asize(Type_Deposit) )
      StatReturn = True;
  end;

  Return StatReturn;
end;


/* Формирование массива типов вкладов */
Macro DoArray_OneType ( Type )

  var   Counter = 0 , /*Счетчик - прогресс-бар*/
        Choice  = 0 ; /*Выбор меню*/

  var   StatFind   = False , /*признак поиска по ключу*/
        Loop       = True  , /*цикл выбора*/
        StatReturn = True  ; /*передаваемое значение */

  var ProccessMes  = " Формирование списка вкладов ",
      Menu_Mes     = " Определите вид вклада для обработки",
      Title_Menu   = " Вклад ",
      Loop_Mes     = " Некорректный выбор, повторить ? ",
      Err_Loop_Mes = " Выпуск отчета прерван! ";

  array Type_Dep;

  ClearRecord( Sb_dtyp    );
  KeyNum     ( Sb_dtyp, 1 );
  Rewind     ( Sb_dtyp    );
  ASize      ( Type_Dep,0 );

  while ( Loop )
    Sb_dtyp.FlagCur = IsCur ;
    StatFind = GetGE( sb_dtyp );

    InitProgress(NRecords(Sb_dtyp), NULL, ProccessMes);
    While ( StatFind  AND  ( Sb_dtyp.FlagCur == IsCur    ) AND
                           ( Sb_dtyp.Priorit <= Max_Prior)    )
           Message("   ",Sb_dtyp.Kind);
           Type_Dep (Counter) = Sb_dtyp.Kind;
           UseProgress( Counter = Counter + 1 );
           StatFind = Next( Sb_Dtyp );
    end;
    RemProgress( Counter );

    Choice = Menu(Type_Dep, Menu_Mes, Title_Menu);
    If( Choice >= 0 )
         Type = Type_Dep ( Choice );
         Loop = False;
    else
       GetTrue(Loop, Loop_Mes);
       if( not ( Loop ))
          MsgBox(Err_Loop_Mes);
          StatReturn = False;
       end;
    end;
  end;

  SetParm( 0, Type );
  Return StatReturn;
end;


/*Поиск под операции по текущему документу*/
Macro GetSuboper( IsCur, Kind, Operation, ApplType )
  var stat = False;

  file SubOper ( "suboper.dbt" );

  if ( ApplType > 0 )
     KeyNum( SubOper, 1 );
     ReWind( SubOper );
     SubOper.IsCur    = IsCur;
     SubOper.Kind     = Kind;
     SubOper.OperType = Operation;
     SubOper.Type     = ApplType;
     stat = ( GetEQ( SubOper )  and
            (
              ( Index( Trim( SubOper.Name ), "Пенсия" ) ) or
              ( Index( Trim( SubOper.Name ), "пенсия" ) )
            ) )
  end;
  return stat;
end;



/* Ищем значение остатков по  его виду*/
Macro FindCh_Type(  Тип_Остатка, Счет_Был_Востр , Вид_Вклада )

  var Rest          = $0,
      StatFind      = False,
      Object        = 2001,
      WasNotPension = False,
      DelReferenc   = "";

    /*
       Ищем зачисление %  за 31.12.98.
       Если в основании упоминается вклад До востр, то остаток должен
       учитываться в сумме остатков по До востр, даже если вклад был
       изначально Пенсионным ( Это огрехи кривой базы )
    */

    /*ClearRecord( sbdepdoc     );
    KeyNum     ( sbdepdoc , 1 );
    Rewind     ( sbdepdoc     );

    sbdepdoc.Referenc         = depositr.Referenc  ;
    sbdepdoc.TypeOper         = Зачисление_Процентов;
    sbdepdoc.DepDate_Document = Date( 31, 12, 1998 );

    StatFind = GetGE( sbdepdoc );
    While( StatFind AND ( sbdepdoc.Referenc         == depositr.Referenc         ) AND
                        ( sbdepdoc.TypeOper         == Зачисление_Процентов ) AND
                        ( sbdepdoc.DepDate_Document == Date( 31, 12, 1998 ) )    )

       If(DocFilter())
         /* Ищем и сравниваем вид вклада в основание документа зачисления % */
         if( Index( Sbdepdoc.Ground, "по данным формы 19" ) AND
             Index( Sbdepdoc.Ground, "ДО ВОСТРЕБ."        )     )

             /* Нашли - счет, который на 01.01. был до востребования */
             WasNotPension = True;
             StatFind      = False;
         end;
       end;

       if( StatFind )
           StatFind = Next( Sbdepdoc );
       end;
    end;*/

  var cmd, rs, stat = False;
  var strcmd = "SELECT t_ground, t_kindop, t_action, t_issuspended, t_typeoper, t_flags, t_mode " +
               "FROM dsbdepdoc_dbt " + 
               "WHERE t_referenc = ? and t_depdate_document = ? and t_typeoper = ? ";
              
  cmd = RsdCommand( strcmd );

  cmd.addParam("referenc", RSDBP_IN, depositr.Referenc);
  cmd.addParam("depdate_document", RSDBP_IN, Date( 31, 12, 1998 ));
  cmd.addParam("typeoper", RSDBP_IN, Зачисление_Процентов);
    
  cmd.execute; 
  rs = RsdRecordset(cmd);
  StatFind = rs.movefirst;
  while (StatFind)
      If(IsServDocForRSD(rs, 0))
         /* Ищем и сравниваем вид вклада в основание документа зачисления % */
         if( Index( rs.value("t_Ground"), "по данным формы 19" ) AND
             Index( rs.value("t_Ground"), "ДО ВОСТРЕБ."        )     )

             /* Нашли - счет, который на 01.01. был до востребования */
             WasNotPension = True;
             StatFind      = False;
         end;
    end;

       if( StatFind )
           StatFind = rs.MoveNext();
       end;
  end;


    if( WasNotPension ) /* Кривизна обнаружена */
       /*
          Теперь нужно найти дату первого зачисления пенсии  и сравнить с датой
          за которую выпускается отчет.
       */
       /*ClearRecord( sbdepdoc     );
       KeyNum     ( sbdepdoc , 2 );
       Rewind     ( sbdepdoc     );

       sbdepdoc.Referenc = depositr.Referenc ;
       StatFind = GetGE( sbdepdoc );

       While( StatFind AND ( sbdepdoc.Referenc == depositr.Referenc ) )
         if( (DocFilter()) AND
             ( GetSuboper( sbdepdoc.IsCur,    sbdepdoc.Type_Account,
                           sbdepdoc.TypeOper, sbdepdoc.ApplType ) ) )

              /* Если смена вклада( 1-е зачисление пенсии ) проводилась
              раньше даты выпуска отчета, то менять остатки не надо,
              иначе проводим подсчет */
              if( Sbdepdoc.DepDate_Document > dlg.DATE_REPORT )
                 WasNotPension = True; /* счет уже точно нужно учитывать по До востреб */
                 StatFind = False;
              else
                  WasNotPension = False;
              end;

         end;

         if( StatFind )
             StatFind = Next( Sbdepdoc );
         end;
       end;*/
       
       strcmd = "SELECT t_iscur, t_type_account, t_typeoper, t_appltype, t_depdate_document, t_kindop, t_action, t_issuspended, t_flags, t_mode " +
                    "FROM dsbdepdoc_dbt " + 
                    "WHERE t_referenc = ? ";
              
       cmd = RsdCommand( strcmd );

       cmd.addParam("referenc", RSDBP_IN, depositr.Referenc);
             
       cmd.execute; 
       rs = RsdRecordset(cmd);
       StatFind = rs.movefirst;
       while (StatFind)
           if( (IsServdocForRSD(rs, 0)) AND
             ( GetSuboper( rs.value("t_IsCur"),    rs.value("t_Type_Account"),
                           rs.value("t_TypeOper"), rs.value("t_ApplType") ) ) )

              /* Если смена вклада( 1-е зачисление пенсии ) проводилась
              раньше даты выпуска отчета, то менять остатки не надо,
              иначе проводим подсчет */
              if( rs.value("t_DepDate_Document") > dlg.DATE_REPORT )
                 WasNotPension = True; /* счет уже точно нужно учитывать по До востреб */
                 StatFind = False;
              else
                  WasNotPension = False;
              end;

           end;

           if( StatFind )
               StatFind = rs.MoveNext();
       end;

       end;


       if( WasNotPension )
           Счет_Был_Востр  = Счет_Был_Востр + 1; /* увеличим счетчик счетов */
           DelReferenc = depositr.Referenc;

          if  ( Тип_Остатка == 0 ) Rest = depositr.Sum_Rest;/* из счета    */
          elif( Тип_Остатка == 1 ) Rest = GetRest( Object );/* из PC_DREST */
          else                     Rest = GetDoc_DepDate_Rest();     /* из SBDEPDOC */
          end;
       end;

    else /* Счет в Пенсионный переводился уже в RS-Retail */
         /* Ищем операцию "Смена вида вклада" */

       /*ClearRecord( Sbdepdoc    );
       KeyNum     ( Sbdepdoc ,1 );
       Rewind     ( Sbdepdoc    );

       Sbdepdoc.Referenc         = depositr.Referenc  ;
       Sbdepdoc.TypeOper         = Перевод_В_Другой_Вид_Вклада;
       Sbdepdoc.DepDate_Document = dlg.DATE_REPORT;

       StatFind = GetGE( sbdepdoc );
       While( StatFind AND
              ( Sbdepdoc.Referenc         == depositr.Referenc           ) AND
              ( Sbdepdoc.TypeOper         == Перевод_В_Другой_Вид_Вклада ) AND
              ( Sbdepdoc.DepDate_Document >  dlg.DATE_REPORT)                 )

           if( DocFilter())

              /* Нашли - счет, который на 01.01. был до востребования */
              WasNotPension = True;
              StatFind      = False;
           end;
           if( StatFind )
               StatFind = Next( sbdepdoc );
           end;
       end;*/

       
       strcmd = "SELECT t_depdate_document, t_kindop, t_action, t_issuspended, t_typeoper, t_flags, t_mode " +
                    "FROM dsbdepdoc_dbt " + 
                    "WHERE t_referenc = ? and t_typeoper = ?  and t_depdate_document > ? ";
              
       cmd = RsdCommand( strcmd );

       cmd.addParam("referenc",         RSDBP_IN, depositr.Referenc);
       cmd.addParam("typeoper",         RSDBP_IN, Перевод_В_Другой_Вид_Вклада);
       cmd.addParam("depdate_document", RSDBP_IN, dlg.DATE_REPORT);
        
       cmd.execute; 
       rs = RsdRecordset(cmd);
       StatFind = rs.movefirst;
       while (StatFind)
           if( IsServDocForRsd(rs, 0) )

              /* Нашли - счет, который на 01.01. был до востребования */
              WasNotPension = True;
              StatFind      = False;
           end;
           if( StatFind )
               StatFind = rs.movenext();
           end;

       end;

       if( WasNotPension )
          Счет_Был_Востр  = Счет_Был_Востр + 1; /* увеличим счетчик счетов */
          DelReferenc     = depositr.Referenc;

          if  ( Тип_Остатка == 0 ) Rest = depositr.Sum_Rest;/* из счета    */
          elif( Тип_Остатка == 1 ) Rest = GetRest( Object );/* из PC_DREST */
          else                     Rest = GetDoc_DepDate_Rest();     /* из SBDEPDOC */
          end;
       end;
    end;

    /* После всего, если надо вставим или убьем запись о счете из index._ */
    if( DelReferenc != "" )
        if( Вид_Вклада == "Пенсионный" )
           /* запись убираем */
           indx.Referenc = DelReferenc;
           if( GetEQ( indx ) )
               Delete( indx );
           else
               Println("Запись по счету - ",depositr.Account," из индекса не удалена ");
           end;
        else
           /* Вставляем запись*/
           CreateIndex_Client( 0, Тип_Остатка);
        end;
    end;


  SetParm( 1, Счет_Был_Востр );
  Return Rest;
end;




/* Проверка был ли счёт ранее ДО.ВОСТР*/
Macro TestPension( Вид_Вклада , Тип_Остатка, Счет_Был_Востр )

   var Rest     = $0,
       StatFind = False,
       Kind     = "Пенсионный";

   ClearRecord( depositr    );
   KeyNum     ( depositr , 6);
   Rewind     ( depositr    ); 

   depositr.IsCur         = IsCur; 
   depositr.FNCash        = ddep.rec.Code;
   depositr.Type_Account  = Kind;

   StatFind = GetGE( depositr );

   While( StatFind AND ( depositr.IsCur         == IsCur ) AND
                       ( depositr.FNCash        == ddep.rec.Code ) AND
                       ( depositr.Type_Account  == Kind            )     )
          
      if ( depositr.Code_Currency == codeCurr )
        if (  ( not Index( depositr.UserTypeAccount, "Н" ) )
          and ( not Index( depositr.UserTypeAccount, "С" ) ) )
            if( ( ( depositr.Open_Date  <= dlg.DATE_REPORT   ) AND
                ( depositr.Close_Date == date( 0, 0, 0000) )      ) OR
                ( ( depositr.Close_Date != date( 0, 0, 0000) ) AND
                ( depositr.Close_Date >= dlg.DATE_REPORT         )     ) )

              Rest = Rest + FindCh_Type (  Тип_Остатка, Счет_Был_Востр , Вид_Вклада );
            end;
         end; 
      end;

      StatFind = Next( depositr );
   end;

   SetParm( 2, Счет_Был_Востр);
   Return Rest;
end;



/* Формирование отчета*/
Macro PrintReport ( Тип_Остатка )

  var Do       = False;
  var Count    = 0;
  var Rest     = $0;
  var SqlQuery, cmd, RS;
  var SpecialAccessAccount : string;
  var cmddel;

  array Delta;

  ClearRecord ( Indx    );
  KeyNum      ( Indx ,0 );
  Rewind      ( Indx    );


  InitProgress( NRecords( Indx ), NULL, " Формирование отчета ..." );
  While( next( indx ) )

    if  (  Тип_Остатка == 0 )  Rest  = indx.Sum_Rest;
    elif(  Тип_Остатка == 1 )  Rest  = indx.Sum_Rest1;
    else                       Rest  = indx.Sum_Rest2;
    end;

    SqlQuery = string("select d.t_SpecialAccess from ddepositr_dbt d where d.t_Referenc=",Indx.Referenc);
    cmd = RsdCommand(SqlQuery);
    cmd.execute;
    RS = RsdRecordset(cmd);
    if(RS.MoveNext)
      SpecialAccessAccount = RS.value("t_SpecialAccess");
    end;

    if( (not SpecialAccess) and OperMayListSpecialAccounts and SpecialAccessAccount)
       Client = "XXXXXX X.X.";    
    else
       Client = Indx.Client;
    end;
    If(dlg.FIO)

     [ | ########################## | ####################################### | ##############  |]
       (  Acc_Form(Indx.Account) : l , Client : l , Rest : r );
    else
     [ |   ######################## | ################## | ]
       (  Acc_Form(Indx.Account) : l , Rest : r );
    end;

    delta( 0 ) = Indx.Sum_Rest  - Indx.Sum_Rest1;/*Остаток счета-Остаток Даты*/
    delta( 1 ) = Indx.Sum_Rest  - Indx.Sum_Rest2;/*Остаток счета-Остаток Опр.*/
    delta( 2 ) = Indx.Sum_Rest1 - Indx.Sum_Rest2;/*Остаток Даты-Остаток Опр. */

    if( Тип_Остатка ) /* Если берем остатки не на текущую дату, то разница будет всегда */
       delta( 0 ) = delta( 1 ) = $0;
    end;

    if( abs( delta( 0 ) ) or
        abs( delta( 1 ) ) or
        abs( delta( 2 ) )    )
        SetOutPut ( Deltafile, true );

     [  Вклад         Кр.номер   Ост.сч.(1)   Ост.даты(2)  Ост.опер.(3)  (1) - (2)  (1) - (3)  (2) - (3)
        ############# #########  ############ ############ ############  ########## ########## ##########

     ]
        ( Indx.Type_Account:l , SubStr(Indx.Account , 14 , 7) : l,
          Indx.Sum_Rest : l   , Indx.Sum_Rest1: l, Indx.Sum_Rest2: l,
          delta( 0 ) : l, delta( 1 ) : l, delta( 2 ) : l ) ;
    end;
    if( Indx.Close_Date != date( 0, 0, 0000 ) )
        SetOutPut ( Deltafile, true );
     [  Счет                      Дата закрытия
        ########################  ##################

     ]
       ( Acc_Form(Indx.Account) : l, Indx.Close_Date );
    end;

    SetOutPut ( RepFile , true );
    UseProgress( count = count + 1);
  end;
  Remprogress( count );

  cmddel = RsdCommand( NULL, string("truncate table dindrest_tmp") ); // После печати очередной таблички очищаем индекс, дабы счета не дублировались.
  cmddel.execute();
end;



/*Обработка филиала*/
Macro ProcessFNCash( Вид_Вклада , Тип_Остатка )

  var StatFind       = False,
      NeedOut        = False;


  var AllRest   = $0, /*Общая сумма остатка по вкладу*/
      Accts     =  0, /*Всего счетов*/
      DeltaRest = $0,/*Расхождение в остатках*/
      DeltaAcc  =  0; /*Счет с расхождением*/


  var TypeFound = 0;
  var i         = 0;

  ASize(Objects,0);
  TypeFound = 0;

  while( GetPC_APLTP( IsCur, Вид_Вклада, TypeFound ) )
     TypeFound    = 1;
     Objects( i ) = pc_apltp.ApplType;
     i = i + 1;
  end;

  if( TypeFound == 0 )
     println( " По вкладу ", Вид_Вклада, "не найдено ни одной записи",
              " о присоединенном виде вклада" );
     return False;
  end;

  ClearRecord( depositr   );
  KeyNum     ( depositr ,6);
  Rewind     ( depositr   );

  depositr.IsCur         = IsCur; 
  depositr.FNCash        = ddep.rec.Code;
  depositr.Type_Account  = Вид_Вклада;

  StatFind = GetGE( depositr );
  while(  StatFind AND 
                    ( depositr.IsCur         == IsCur           ) AND 
                    ( depositr.FNCash        == ddep.rec.Code ) AND
                    ( depositr.Type_Account  == Вид_Вклада      ))
     if ( depositr.Code_Currency == codeCurr )
       if (  ( not Index( depositr.UserTypeAccount, "Н" ) )
         and ( not Index( depositr.UserTypeAccount, "С" ) ) )
         if ( ( depositr.Number >= dlg.ACC_FIRST_NUM      ) AND
              ( depositr.Number <= dlg.ACC_LAST_NUM       ))
           if ( not NeedOut )
             if( dlg.ONLY_SVOD == "" )
                /* Если не задано выводить только суммы по вкладам */
                if(dlg.FIO)
                   OutHeadFull();
                else
                   OutHead();
                end;
             else
                if( not SvodHeadWasOut )
                   SvodHeadWasOut = True;
                   OutSvodHead();
                end;
             end;
        
             NeedOut = true;
           end;

           Message( " Филиал  ",ddep.rec.Code,"   Вклад  ",Вид_Вклада,"    Счет ",depositr.Account );
           if(((depositr.Open_Close!="") and Cl_type and (depositr.Close_Date>=dlg.DATE_REPORT)) or
              ((depositr.Open_Close=="") and Op_type and (depositr.Open_Date<=dlg.DATE_REPORT)))
               Accts = Accts + 1;
               AllRest = AllRest + CreateIndex_Client( Accts ,Тип_Остатка );
           end;
      
           if( ( depositr.Open_close != "" ) AND ( depositr.Sum_Rest != $0 ) )
               SetOutPut( DeltaFile, True );
               Println  ( "Счет ", depositr.Account," закрыт с ненулевым остатком ",depositr.Sum_Rest );
               SetOutPut( RepFile,   True );
           end;
         end;
       end;
     end;

     StatFind = Next( depositr );
  end;

  if( (  Вид_Вклада == "ДО ВОСТРЕБ." ) OR ( Вид_Вклада == "Пенсионный" ) )
      /* А теперь проверим были ли переводы из До востреб в Пенсион
        и за какую дату */

      DeltaRest = TestPension( Вид_Вклада , Тип_Остатка , DeltaAcc );

      if(   Вид_Вклада == "ДО ВОСТРЕБ." ) /* прибавим переведенные счета */
            AllRest = AllRest + DeltaRest;
            Accts   = Accts   + DeltaAcc;
      elif( Вид_Вклада == "Пенсионный" )  /* отнимем переведенные счета */
            AllRest = AllRest - DeltaRest;
            Accts   = Accts   - DeltaAcc;
      end;

      if( DeltaRest  AND ( NOT ( NeedOut ) ))
         /* Счет к печати появился только после просмотра Пенсионных */
          if( dlg.ONLY_SVOD == "" )
             if( dlg.FIO )
                OutHeadFull();
             else
                OutHead();
             end;
          else
             if( not SvodHeadWasOut )
                SvodHeadWasOut = True;
                OutSvodHead();
             end;
          end;
          NeedOut = True;
      end;
  end;

  if( NeedOut )
       if( dlg.ONLY_SVOD == "" )
          PrintReport( Тип_Остатка );
          if( dlg.FIO )
             OutBottomDepFull ( Accts , Вид_Вклада , AllRest );
          else
             OutBottomDep     ( Accts , Вид_Вклада , AllRest );
          end;
          DoLine();
       else
          OutSvodBottomDep( Accts , Вид_Вклада , AllRest );
       end;

   end;
end;


  /* Показать файл протокола */
macro View( NameLogFile )
    file LogFile() txt 250;         /* Для просмотра протокола */

    if( ExistFile( NameLogFile ) )
      if( open( LogFile, NameLogFile ) )
          close( LogFile );
          ViewFile( LogFile );
      end;
    end;
end;



/* Головная процедура*/
Macro Main()

  var Type      = ""  ,  /* Вид вклада */
      Count     = 0   ,  /* Счетчик массива*/
      Type_Rest = 0   ,  /* Условие для вида остатка */
      MayCont   = True;  /* Условие для продолжения работы */

  var ProccessMes = " Формирование  отчета по остаткам " ,
      Counter     = 0 ; /*Счетчик прогресс-бар*/
  var res:Bool;
  var ret = TRUE;
  var cmd, rs, stat_, strcmd;
  If(Constructor())
   InitPanel( {curdate} , Branch ,IsCur);   /* Вызов внешней продцедуры  из ServDLG     */
   if ( IsCur == 0 )
     res=RunDialog( dlg ,"EvenMacro"); /* Вызов внешней продцедуры  из ServDLG - рубли */
   else
     res=RunDialog( dlg_v ,"EvenMacro_v"); /* Вызов внешней продцедуры  из ServDLG - валюта */
     
     
   strcmd = "SELECT t_code_currency " +
                          "FROM dcurrency_dbt " + 
                          "WHERE t_externalcode = ?";
                          
   cmd = RsdCommand( strcmd );

   cmd.addParam("CurExtCode", RSDBP_IN, string(dlg_v(9)));
   
   cmd.execute; 
   rs = RsdRecordset(cmd);
   stat_ = rs.movenext;
     
     dlgCodeCur = /*dlg_v(9)*/rs.value("t_code_currency");
     flagAllCur = dlg_v.ALL_CUR;
     Copy( dlg, dlg_v );
     dlg.ACC_FIRST_NUM = 0;
     dlg.ACC_LAST_NUM  = 9999999;
   end;
   If(res)
        if(dlg.OPEN_CLOSE==STR_ONLY_OPENED)
             Op_type=true;
             Cl_type=false;
             OpClo_type=1;
          elif(dlg.OPEN_CLOSE==STR_ONLY_CLOSED)
             Op_type=false;
             Cl_type=true;
             OpClo_type=2;
          else
             Op_type=true;
             Cl_type=true;
             OpClo_type=3;
        end;
        if(dlg.REST_A!="")
             Type_Rest = 0;    /* Остаток из из DEPOSITR.DBT */
          elif(dlg.REST_D!="")
             Type_Rest = 1;    /* Остаток на дату из PC_DREST.DBT */
          else
             Type_Rest = 2;    /* Остаток из SBDEPDOC.DBT */
        end;
        if(dlg.ALL_KIND!="")   /* Обработка всех видов вкладов*/
            MayCont = Make_Array_KindDep(); /*Поиск вкладов по типу валюты*/
        else
            MayCont = DoArray_OneType(Type);
        end;
        if(MayCont)
          dpDepList.SetFilter(dpDepList.getFilialID(NumFNCash()));
          ddep = dpDepList.RecHandler;
          if ( IsCur == 0 )
            codeCurr = 0;
            If(dlg.ALL_BRANCH!="")
//               InitProgress( NRecords( listfdep ) ,NULL, ProccessMes);
               While( dpDepList.next() )
                SvodHeadWasOut = False;
/*                if( ( listfdep.StatusBranch == 3 ) or
                    ( listfdep.StatusBranch == 0 ) )*/
                    if( dlg.ALL_KIND!="" )
                       While ( Count <  Asize ( Type_Deposit ) )
                               Type = Type_Deposit ( Count );

                               /*Основная процедура формирования*/
                               ProcessFNCash( Type, Type_Rest );
                               Count = Count + 1 ;
                       end;
                    else
                        /*Основная процедура формирования*/
                         ProcessFNCash( Type, Type_Rest );
                    end;

//                end;
                Count = 0;
//                UseProgress( Counter = Counter + 1 );
               end;
//               RemProgress( Counter );

            else
                 if(FindBranch())
                    if(dlg.ALL_KIND!="")
                         While ( Count <  Asize ( Type_Deposit ) )
                                Type = Type_Deposit ( Count );
                                ProcessFNCash( Type, Type_Rest );
                                Count = Count + 1 ;
                         end;
                      else
                          ProcessFNCash( Type, Type_Rest );
                          Count = Count + 1 ;
                    end;
                 end;/*Конец условия по условия нахождения данного номера филиал*/
            end;/*Конец условия по виду обработки филиалов - один или все*/
          else
            If ( flagAllCur != "" )
              ClearRecord( Currency   );
              KeyNum     ( Currency ,0);
              Rewind     ( Currency   );
              Currency.Code_Currency = 0;
              ret = GetGT( Currency );
              while ( ret )
                codeCurr = Currency.Code_Currency;
                If(dlg.ALL_BRANCH!="")
//                   InitProgress( NRecords( listfdep ) ,NULL, ProccessMes);
                   While( dpDepList.next() )
                    SvodHeadWasOut = False;
/*                    if( ( listfdep.StatusBranch == 3 ) or
                        ( listfdep.StatusBranch == 0 ) )*/
                        if( dlg.ALL_KIND!="" )
                           While ( Count <  Asize ( Type_Deposit ) )
                                   Type = Type_Deposit ( Count );

                                   /*Основная процедура формирования*/
                                   ProcessFNCash( Type, Type_Rest );
                                   Count = Count + 1 ;
                           end;
                        else
                            /*Основная процедура формирования*/
                             ProcessFNCash( Type, Type_Rest );
                        end;

//                    end;
                    Count = 0;
//                    UseProgress( Counter = Counter + 1 );
                   end;
//                   RemProgress( Counter );

                else
                     if(FindBranch())
                        if(dlg.ALL_KIND!="")
                             While ( Count <  Asize ( Type_Deposit ) )
                                    Type = Type_Deposit ( Count );
                                    ProcessFNCash( Type, Type_Rest );
                                    Count = Count + 1 ;
                             end;
                          else
                              ProcessFNCash( Type, Type_Rest );
                              Count = Count + 1 ;
                        end;
                     end;/*Конец условия по условия нахождения данного номера филиал*/
                end;/*Конец условия по виду обработки филиалов - один или все*/
                /*Обнуляем для случая, когда выбираем счета по всем типам вкладов для всех валют*/
                count = 0;
                ret = Next( Currency );
              end;
            else
              codeCurr = dlgCodeCur; /* Код валюты из панели */
              If(dlg.ALL_BRANCH!="")
//                 InitProgress( NRecords( listfdep ) ,NULL, ProccessMes);
                 While( dpDepList.next() )
                  SvodHeadWasOut = False;
/*                  if( ( listfdep.StatusBranch == 3 ) or
                      ( listfdep.StatusBranch == 0 ) )*/
                      if( dlg.ALL_KIND!="" )
                         While ( Count <  Asize ( Type_Deposit ) )
                                 Type = Type_Deposit ( Count );

                                 /*Основная процедура формирования*/
                                 ProcessFNCash( Type, Type_Rest );
                                 Count = Count + 1 ;
                         end;
                      else
                          /*Основная процедура формирования*/
                           ProcessFNCash( Type, Type_Rest );
                      end;

//                  end;
                  Count = 0;
//                  UseProgress( Counter = Counter + 1 );
                 end;
//                 RemProgress( Counter );

              else
                   if(FindBranch())
                      if(dlg.ALL_KIND!="")
                           While ( Count <  Asize ( Type_Deposit ) )
                                  Type = Type_Deposit ( Count );
                                  ProcessFNCash( Type, Type_Rest );
                                  Count = Count + 1 ;
                           end;
                        else
                            ProcessFNCash( Type, Type_Rest );
                            Count = Count + 1 ;
                      end;
                   end;/*Конец условия по условия нахождения данного номера филиал*/
              end;/*Конец условия по виду обработки филиалов - один или все*/
            end;/*Конец условия по обработке видов валют - одна или все*/
          end;
        end;

/*        If(count) */
          SetOutPut( Null );
          View( RepFile );
          if(dlg.FULL_REPORT_FLAG!="")
             View( Deltafile );
          end;
          Destructor();
          Exit(1);
/*       end;  */
   end;/*Конец условия по значению  признака отказа в панели диалога*/
  else
      exit(1);
  end;
  Destructor(); /* На самом деле, мы сюда никогда не доходим! :) */
end;

Main();

