/*
**  Операционный журнал.
**  Продолжение
*/

import BankInter, deprintr, DeskInter, ChkPrn,
       "cur_rate.mac", "issrvdoc.mac", OD_Comm, OD_Out, OperCode;

/******************************************************
     Получение значения времени из ApplicationKey
******************************************************/
macro GetApplTime( ApplKey )
  return SubStr(ApplKey,11,2) + ":" +
         SubStr(ApplKey,13,2) + ":" +
         SubStr(ApplKey,15,2) + " ";
end;

macro GetAlgName(Type,Number)

  Alg.iTypeAlg = Type;
  Alg.iNumberAlg = Number;
  if(GetEQ(Alg))
    return Alg.szNameAlg;
  else
    return "";
  end;
end;

macro GetDiaryNumber();

  var
    lIsCur = 0;

  FindGroup( OperBrigade );
  if ( Group.Curr == GROUP_CURR_OTHER )
    lIsCur = 1;
  end;

  DepParm.FNCash = Branch;
  DepParm.FlagCur = lIsCur;
  if ( not ( GetGE( DepParm )
    and ( DepParm.FNCash == Branch )
    and ( DepParm.FlagCur == lIsCur ) ) )
    MsgBox("Ошибка чтения параметров филиала");
    return 0;
  else
    return DepParm.NumOperDy;
  end;
end;

macro FindCashValue( ValueRef )

  var
    Stat,
    OldKey = KeyNum( CashVal, 0 );

  CashVal.RefValue = ValueRef;
  Stat = GetEQ( CashVal );
  KeyNum( CashVal, OldKey );
  return Stat;
end;

macro GetWorkDeskName( OperID, BrigadeID )

  var
    OperStr = String( OperID ),
    BrigadeStr = String( BrigadeID );

  return MkStr( "0", 4 - StrLen( OperStr ) ) + OperStr + "/" +
    MkStr( "0", 2 - StrLen( BrigadeStr ) ) +BrigadeStr;
end;

macro FindBag

  CashLink.ApplicationKind2 = CashDoc.ApplicationKind;
  CashLink.ApplicationKey2 = CashDoc.ApplicationKey;
  if ( GetGE( CashLink )
    and ( CashLink.ApplicationKind2 == CashDoc.ApplicationKind )
    and ( CashLink.ApplicationKey2 == CashDoc.ApplicationKey ) )
    BagDoc.ApplicationKind = CashLink.ApplicationKind1;
    BagDoc.ApplicationKey = CashLink.ApplicationKey1;
    if ( GetEQ( BagDoc ) )
      Bag.ApplicationKind = BagDoc.BagAppKind;
      Bag.ApplicationKey = BagDoc.BagAppKey;
      return GetEQ( Bag );
    end;
  end;
  return false;
end;


/*************************************************************************\
|                         Открыть файл банков                             |
\*************************************************************************/
macro OpenBankDprt

  var Path = Trim(GetRegVal( "RS-RETAIL\\INI\\ДИРЕКТОРИИ\\DISTDBFILE", true ));
  var PathDic;
  var PathPartCode;
  var PathParty;
  var PathBankDprt;
  var stat = FALSE;
  var Len;

  Len = StrLen(Path);
  if (Len > 0)
    if (SubStr(Path,Len,1) != "\\")
      Path = Path + "\\";
    end;
  end;

  PathDic = Trim(Path + "BANK.DEF");

  if (ExistFile(PathDic))
    if (BankVersion == 510)
      PathPartCode = Trim(Path + "partcode.dbt");
      PathParty    = Trim(Path + "party.dbt");
      if (ExistFile(PathPartCode) AND ExistFile(PathParty))
        partcode = Tbfile("partcode.dbt","r",1,PathPartCode,PathDic);
        party    = Tbfile("party.dbt",   "r",0,PathParty,   PathDic);
        if ((partcode) AND (party))
          OpenBankFiles = TRUE;
          stat          = TRUE;
        end;
      end;
    else
      PathBankDprt = Trim(Path + "bankdprt.dbt");
      if (ExistFile(PathBankDprt))
        bankdprt = Tbfile("bankdprt.dbt","r",0,PathBankDprt,PathDic);
        if (bankdprt)
          OpenBankFiles = TRUE;
          stat          = TRUE;
        end;
      end;
    end;
  end;

  return stat;

end;

macro GetBagInfo

  var
    Info = "",
    ClientName = "";

  if ( not ShowBagInfo )
    return "";
  end;

  if ( FindBag )
    GetClientInfo( Bag.ClientType, Bag.ClientID, ClientName );
  end;
  if ( ClientName != "" )
    Info = " (" + Trim( ClientName ) + ")";
  end;
  return Info;
end;

macro GetCurrRate1

  ScaleRate = 1;

  CBRate   = Double(0);
  BuyRate  = Double(0);
  SellRate = Double(0);

  if (Curr.ScaleOfc != 0)
    ScaleRate = Curr.ScaleOfc;
  end;
/*
  ExchCurr.ID = Int(Curr.ExternalCode);
  if (GetEQ(ExchCurr))
*/
    copy( RtlCurr, Curr );
    CBRate = GetCurrRate({curdate});
    if (CBRate != 0)
      BuyRate  = CurrRate.BuyRate;
      SellRate = CurrRate.SellRate;
      if ( CurrRate.ChangeNom != 0 )
        BuyRate  = CurrRate.BuyRate / CurrRate.ChangeNom;
        SellRate = CurrRate.SellRate / CurrRate.ChangeNom;
      end;
    end;
/*  end;*/
end;

macro PrintnNameCur
var buy_rate, sell_rate, cb_rate, scale = "";
 if ( ScaleRate != 1 )
   scale = String( ScaleRate ) + " ";
 end;

 buy_rate  = "Курс покупки: " + Trim(String(BuyRate :15:4)) + " Руб/" + scale + Curr.Short_Name;
 sell_rate = "Курс продажи: " + Trim(String(SellRate:15:4)) + " Руб/" + scale + Curr.Short_Name;
 cb_rate   = "Курс ЦБ:      " + Trim(String(CBRate  :15:4)) + " Руб/" + scale + Curr.Short_Name;

 PrintLn("Валюта:  ",Curr.Name_Currency);
 if(Curr.Code_Currency)
   PrintLn( buy_rate  );
   PrintLn( sell_rate );
   PrintLn( cb_rate   );
 end;
end;

macro GetNativeSafe

  if( not ExternPantry )       /* не Кладовая отделения */
    if(FindGroup( OperBrigade ))
      return Group.SafeID;
    else
      MsgBox( "Не найдена смена №" + OperBrigade );
      Exit( 1 );
    end;
  else
    return "Кладовая";
  end;
end;

macro GetBrigadeDesc

  if(FindGroup( OperBrigade ))
    return Group.Desc;
  else
    MsgBox( "Не найдена смена №" + OperBrigade );
    Exit( 1 );
  end;
end;

/* Получить название типа ресурса кассы */
macro GetCashTypeName(Type)

  Alg.iTypeAlg = ALG_CASH_VAL_TYPE;
  Alg.iNumberAlg = Type;
  if(GetEQ(Alg))
    return Alg.szNameAlg;
  else
    return String(Type);
  end;
end;

macro CVGetNativeCurr;

  var
    NativeCurr;

  if ( TmpCashVal.TypeValue == TYPERES_CURRENCY )
    NativeCurr = TmpCashVal.CodIntValue;
  else
    GetPos( CashVal );
    FindCashValue( TmpCashVal.GroupValue );
    if ( CashVal.TypeValue == TYPERES_CURRENCY )
      NativeCurr = CashVal.CodIntValue;
    /* RA 13-11-00 ------------------------- */
    elif( CashVal.TypeValue == TYPERES_PAYDOC )
      ClearRecord( PD );
      PD.ID = CashVal.CodIntValue;
      if( GetEQ( PD ) )
        NativeCurr = PD.Curr_Ref; /*ExtCode_To_RtlCurr( PD.Curr_Ref ); RA 07-03-01 ПД переведено на коды Retail*/
      else
        MsgBox( "Не найден платежный документ с кодом ", CashVal.CodIntValue );
        Exit( 1 );
      end;
    /* ------------------------- RA 13-11-00 */
    else
      if ( TmpCashVal.RefValueReport < 2 )
        NativeCurr = TmpCashVal.RefValueReport;
      elif ( ShowSecondRefVal )
        NativeCurr = IsCur;
      else
        NativeCurr = 0;
      end;
    end;
    GetDirect( CashVal );
  end;
  return NativeCurr;
end;

macro ShowChVal( Credit, Debet )

  var
    IsUnpay = false,
    OpCont;

  if ( CashDoc.NumOper == CASHOP_CHVALUE )
    OpCont = "Испорчен бланк";
  else
    /* Аттестаци с Ярославле 16.08.2001 - методолог Князева Ю. А.*/
    return;
    OpCont = "Приход испорченного";
  end;
  OpCont = GetApplTime( CashDoc.ApplicationKey ) +
           OpCont + ": " + TmpCashVal.NameValue;

  if ( TmpCashVal.Type == TYPE_RES_NOPAY )
    IsUnpay = true;
  end;
  OutLine( OpCont, 0, 0, 0, 0, 0, Credit, Debet, true, false, IsUnpay );
end;

macro TreatChVals( AppKind, AppKey )

  var
    C, D;

  CalcValuesTurnsEx( AppKind, AppKey, C, D, 1, "ShowChVal" );
end;

macro GetValFormInOutNo();

  CalcValuesTurns( doc.iApplicationKind, doc.ApplicationKey, ValFormIn, ValFormOut, 0 );
  return true;
end;

macro Обнуление_Сумм

  SumOperIn  = $0.00;
  SumOperOut = $0.00;
  SumBeznIn  = $0.00;
  SumBeznOut = $0.00;
  SumOstVkl  = $0.00;
  SumOstProc = $0.00;

  SumOperInE  = $0.00;
  SumOperOutE = $0.00;
  SumBeznInE  = $0.00;
  SumBeznOutE = $0.00;

  SumValFormIn  = 0;
  SumValFormOut = 0;

  TotCashDebet   = $0; TotCashDebetU   = $0;
  TotCashCredit  = $0; TotCashCreditU  = $0;
  TotMemDebet    = $0;
  TotMemCredit   = $0;
  TotCashDebetR  = $0; TotCashDebetRU  = $0;
  TotCashCreditR = $0; TotCashCreditRU = $0;
  TotMemDebetR   = $0;
  TotMemCreditR  = $0;
  TotDebetV      = $0; TotDebetVU      = $0;
  TotCreditV     = $0; TotCreditVU     = $0;

  TotCvDebet      = $0;
  TotCvCredit     = $0;
  TotCvMemDebet   = $0;
  TotCvMemCredit  = $0;
  TotCvDebetR     = $0;
  TotCvCreditR    = $0;
  TotCvMemDebetR  = $0;
  TotCvMemCreditR = $0;
  TotCvDebetV     = $0;
  TotCvCreditV    = $0;

  /* RA 20-07-00 для ОП */
  TotExDebet      = $0; TotExDebetU   = $0;
  TotExCredit     = $0; TotExCreditU  = $0;
  TotExMemDebet   = $0;
  TotExMemCredit  = $0;
  TotExDebetR     = $0; TotExDebetRU  = $0;
  TotExCreditR    = $0; TotExCreditRU = $0;
  TotExMemDebetR  = $0;
  TotExMemCreditR = $0;
  TotExDebetV     = $0; TotExDebetVU  = $0;
  TotExCreditV    = $0; TotExCreditVU = $0;

end;

macro Обнуление_Сумм_О

  SumOperInO     = $0.00;
  SumOperOutO    = $0.00;
  SumBeznInO     = $0.00;
  SumBeznOutO    = $0.00;
  SumOperInOE    = $0.00;
  SumOperOutOE   = $0.00;
  SumBeznInOE    = $0.00;
  SumBeznOutOE   = $0.00;
  SumOstVklO     = $0.00;
  SumOstProcO    = $0.00;
  SumValFormInO  = 0;
  SumValFormOutO = 0;
end;

macro Расчет_Сумм

  SumOperIn     = SumOperIn     + SumOperInO;
  SumOperOut    = SumOperOut    + SumOperOutO;
  SumBeznIn     = SumBeznIn     + SumBeznInO;
  SumBeznOut    = SumBeznOut    + SumBeznOutO;
  SumOperInE    = SumOperInE    + SumOperInOE;
  SumOperOutE   = SumOperOutE   + SumOperOutOE;
  SumBeznInE    = SumBeznInE    + SumBeznInOE;
  SumBeznOutE   = SumBeznOutE   + SumBeznOutOE;
  SumOstVkl     = SumOstVkl     + SumOstVklO;
  SumOstProc    = SumOstProc    + SumOstProcO;
  SumValFormIn  = SumValFormIn  + SumValFormInO;
  SumValFormOut = SumValFormOut + SumValFormOutO;

end;

macro Накопление_ИтогаЦенностей()

  SumValFormIn_2  = SumValFormIn_2  + SumValFormIn;
  SumValFormOut_2 = SumValFormOut_2 + SumValFormOut;
  TotCreditV_2    = TotCreditV_2    + TotCreditV    + TotCreditVU;
  TotDebetV_2     = TotDebetV_2     + TotDebetV     + TotDebetVU;
  TotExCreditV_2  = TotExCreditV_2  + TotExCreditV  + TotExCreditVU;
  TotExDebetV_2   = TotExDebetV_2   + TotExDebetV   + TotExDebetVU;
  TotCvCreditV_2  = TotCvCreditV_2  + TotCvCreditV;
  TotCvDebetV_2   = TotCvDebetV_2   + TotCvDebetV;

end;

macro Обнуление_Сумм_ВВ

  SumOperInAT    = $0.00;
  SumOperOutAT   = $0.00;
  SumBeznInAT    = $0.00;
  SumBeznOutAT   = $0.00;
  SumOperInATE   = $0.00;
  SumOperOutATE  = $0.00;
  SumBeznInATE   = $0.00;
  SumBeznOutATE  = $0.00;
  SumOstVklAT    = $0.00;
  SumOstProcAT   = $0.00;
  SumValFormInAT = 0;
  SumValFormOutAT = 0;
end;

/***********************************************************/
macro Подкачка_по_счету
/*
  Находит информацию по данному счету и по клиенту

  23.09.96
*/
  var stat = TRUE;

  if(doc.Type_Account == ServAcntName)
    /*прокидываем данные по служебным счетам*/
     stat=FALSE;
  end;
  if(stat)
    if( doc.CodClient != 0)
      stat = ClientList.GetRecord( doc.CodClient );
    else
     KeyNum (dtyp, 2);
     dtyp.FlagCur = IsCur;
     dtyp.Kind = doc.Type_Account;
     stat = getEQ (dtyp);
     if(stat)
       ClientList.CurRec.rec.Name1 = SubStr(dtyp.Name,1,25);
       ClientList.CurRec.rec.Name2 = "";
       ClientList.CurRec.rec.Name3 = "";
     end;
    end;
  end;
  return stat;
end;

macro CreateDocIdx

  var
    RecFound,
    RecNo = 0;

  if((not Create(DocIdx, IdxName))
    or (not Open(DocIdx, IdxName, 1)))
    MsgBox("Ошибка при создании внешнего индекса");
  end;
  InitProgress(NRecords(Doc),"sbdepdoc.dbt","Создание внешнего индекса");
  ClearRecord(Doc);
  Doc.IsCur = IsCur;
  Doc.FNCash = Branch;
  Doc.Date_Document = {curdate};
  RecFound = GetGE(Doc);
  while(RecFound
    and (Doc.IsCur == IsCur)
    and (Doc.FNCash == Branch)
    and (Doc.Date_Document == {curdate}))
    if ( ( Doc.Mode == Mode ) and CheckConfirm( not Doc.NotConfirm ) )
      DocIdx.IsCur = Doc.IsCur;
      DocIdx.FNCash = Doc.FNCash;
      DocIdx.Date_Document = Doc.Date_Document;
      DocIdx.Code_Currency = Doc.Code_Currency;
      DocIdx.Type_Account = Doc.Type_Account;
      DocIdx.RecPos = GetPos(Doc);
      Insert(DocIdx);
    end;
    RecNo = RecNo + 1;
    UseProgress(RecNo);
    RecFound = Next(Doc);
  end;
  RemProgress;
end;

macro DeleteDocIdx

  Close(DocIdx);
  DelFile(IdxName);
end;

macro CreateDocIdx1

  var
    LocIsCur = 0,
    LocIsConv,
    RecFound,
    RecNo = 0;

  if (IsCur)
    LocIsCur = 1;
  end;
  if((not Create(DocIdx1, Idx1Name))
    or (not Open(DocIdx1, Idx1Name, 1)))
    MsgBox("Ошибка при создании внешнего индекса");
  end;
  InitProgress(NRecords(Doc),"sbdepdoc.dbt","Создание внешнего индекса");
  while ( ( IsCur and ( LocIsCur < 2 ) ) or ( LocIsCur < 1 ) )
    ClearRecord(Doc);
    Doc.IsCur = LocIsCur;
    Doc.FNCash = Branch;
    Doc.Date_Document = {curdate};
    RecFound = GetGE(Doc);
    while(RecFound
      and (Doc.IsCur == LocIsCur)
      and (Doc.FNCash == Branch)
      and (Doc.Date_Document == {curdate}))
      if ( Doc.TypeComplexOper == OP_SELL_BUY_CURR )
        LocIsConv = 1;
      else
        LocIsConv = 0;
      end;
      if ( ( ( not IsCur ) and ( not LocIsCur ) )
        or ( IsCur and ( LocIsCur or LocIsConv ) ) )
        if ( Doc.Mode == Mode and CheckConfirm( not Doc.NotConfirm ) )
          DocIdx1.IsConv = LocIsConv;
          DocIdx1.FNCash = Doc.FNCash;
          DocIdx1.Date_Document = Doc.Date_Document;
          DocIdx1.Oper = Doc.Oper;
          DocIdx1.Code_Currency = Doc.Code_Currency;
          DocIdx1.Type_Account = Doc.Type_Account;
          DocIdx1.TypeOper = Doc.TypeOper;
          DocIdx1.RecPos = GetPos(Doc);
          Insert(DocIdx1);
        end;
      end;
      RecNo = RecNo + 1;
      UseProgress(RecNo);
      RecFound = Next(Doc);
    end;
    LocIsCur = LocIsCur + 1;
  end;
  RemProgress;
end;

macro DeleteDocIdx1

  Close(DocIdx1);
  DelFile(Idx1Name);
end;

/***********************************************************/
macro FormDepGround

  var Ground = "";
  var FIO;

  file OpTypes ("sb_typop.dbt");
  file SubOper ("suboper.dbt");

  if (StrLen(Trim(doc.ground)) > 0)
    if (((doc.TypeOper ==  4) AND (doc.TypeComplexOper == 10)) OR
        ((doc.TypeOper == 63) AND (doc.TypeComplexOper == 81))   )
      KeyNum(OpTypes,0);
      ReWind(OpTypes);
      OpTypes.IsCur    = doc.IsCur;
      OpTypes.Kind     = doc.Type_Account;
      OpTypes.NumOpert = doc.TypeComplexOper;
      if (GetEQ(OpTypes))
        Ground = OpTypes.czNameAlg;
      end;
    else
      Ground = "";
    end;
    Ground = doc.ground + " " + Ground;
  else
    KeyNum(OpTypes,0);
    OpTypes.IsCur    = doc.IsCur;
    OpTypes.Kind     = doc.Type_Account;
    OpTypes.NumOpert = doc.TypeOper;
    if (GetEQ(OpTypes))
      Ground = OpTypes.czNameAlg + " ";
    end;
    if (doc.ApplType > 0)
      KeyNum(SubOper,1);
      SubOper.IsCur    = doc.IsCur;
      SubOper.Kind     = doc.Type_Account;
      SubOper.OperType = doc.TypeOper;
      SubOper.Type     = doc.ApplType;
      if (GetEQ(SubOper))
        Ground = Ground + SubOper.Name;
      end;
    end;
  end;

  if (StrLen(Ground) == 0)
    Ground = " ";
  end;

  KeyNum(dr,8);
  dr.Referenc = doc.Referenc;
  if (GetEQ(dr))
    ;
  else
    ClearRecord(dr);
    dr.Referenc = doc.Referenc;
  end;

  if ( ClientList.CurRec.rec.SpecialAccess OR dr.SpecialAccess)
    FIO = dtyp.Kind;
  else
    FIO = Trim(ClientList.CurRec.rec.Name1);
    if (StrLen(Trim(ClientList.CurRec.rec.Name2)) > 0)
      FIO = FIO + " " + SubStr(ClientList.CurRec.rec.Name2,1,1) + ".";
    end;
    if (StrLen(Trim(ClientList.CurRec.rec.Name3)) > 0)
      if (StrLen(Trim(ClientList.CurRec.rec.Name2)) > 0)
        FIO = FIO + SubStr(ClientList.CurRec.rec.Name3,1,1) + ".";
      else
        FIO = FIO + " " + SubStr(ClientList.CurRec.rec.Name3,1,1) + ".";
      end;
    end;
  end;

  DepGround = GetApplTime( doc.ApplicationKey ) + Ground + " " + FIO;
end;

macro DepTreatChVals

  var
    C, D;

  if ( doc.FlagStorn != StrFor( 0 ) )
    if ( ( doc.InSum >= 0 ) and ( doc.OutSum >= 0 ) )
      return;
    end;
  end;

  CalcValuesTurnsEx( doc.iApplicationKind, doc.ApplicationKey, C, D, 1, "DepShowChVal" );
  ValFormIn = ValFormIn + C;
  ValFormOut = ValFormOut + D;
end;

/***********************************************************/
macro Цикл_по_документам (DateDoc)
/*
  Организует цикл по документам данного операциониста за день

  23.09.96
*/
  var stat;
  var i;
  var Type_Account_Pred;
  var NamTyp = TRUE;      /*        FALSE;   */
  var PrevAccType = "";
  var Str;

  Обнуление_Сумм_ВВ;
  CreateDocIdx;
  ClearRecord(DocIdx);
  DocIdx.IsCur = IsCur;
  DocIdx.FNCash = Branch;
  DocIdx.Date_Document = DateDoc;
  DocIdx.Code_Currency = Curr.Code_Currency;
  stat = getGE (DocIdx);
  while (stat)
    if(   (DocIdx.IsCur==IsCur)
      AND (DocIdx.FNCash==Branch)
      AND (DocIdx.Date_Document==DateDoc)
      )
        GetDirect(Doc, DocIdx.RecPos);
     /*Исключаем служебные счета и архивные "следы"*/
      if(   Подкачка_по_счету()
        AND (Int(doc.Code_Currency) == Curr.Code_Currency)
        AND IsServDoc(doc)
        )
        GetValFormInOutNo();
        if ( (doc.InSum != 0)
          OR (doc.OutSum != 0)
          OR (ValFormIn != 0)
          OR (ValFormOut != 0)
          OR (doc.TypeComplexOper == Открытие_Наличными)
          OR (doc.TypeComplexOper == Открытие_Безналичными)
          OR (doc.TypeComplexOper == Закрытие_Наличными)
          OR (doc.TypeComplexOper == Закрытие_Безналичными))
          if(doc.Type_Account != PrevAccType)
          if(IsCur and (not CurrNameDisplayed))
            [ ];
            /*PrintLn(Curr.Name_Currency);*/
            PrintnNameCur;
            CurrNameDisplayed = true;
            SomethingDisplayed = true;
          end;
          if(not HeaderDisplayed)
            OutSubTitle("Вклады",GetDiaryNumber);
            Заголовок;
            HeaderDisplayed = true;
            SomethingDisplayed = true;
          end;
            Str = "\nВид вклада: " + doc.Type_Account;
            if(PrevAccType != "")
              Печать_Сумм_ВВ(PrevAccType);
            end;
            PrintLn(Str);
            i = 0;
            while(i < StrLen(Str))
              Print("-");
              i = i + 1;
            end;
            PrintLn;
            PrevAccType = doc.Type_Account;
            Обнуление_Сумм_ВВ;
            SomethingDisplayed = true;
          end;
          FormDepGround;
          Строка_отчета();
          DepTreatChVals;
          LinesDisplayed = true;
        end;
        if (doc.VidDoc != 0)
          SumOperIn = SumOperIn + doc.InSum;
          SumOperOut = SumOperOut + doc.OutSum;
          SumOperInAT = SumOperInAT + doc.InSum;
          SumOperOutAT = SumOperOutAT + doc.OutSum;
          if (IsCur != 0)
            SumOperInE    = SumOperInE    + Cur2Rub(doc.InSum);
            SumOperOutE   = SumOperOutE   + Cur2Rub(doc.OutSum);
            SumOperInATE  = SumOperInATE  + Cur2Rub(doc.InSum);
            SumOperOutATE = SumOperOutATE + Cur2Rub(doc.OutSum);
          end;
        else
          SumBeznIn = SumBeznIn + doc.InSum;
          SumBeznOut = SumBeznOut + doc.OutSum;
          SumBeznInAT = SumBeznInAT + doc.InSum;
          SumBeznOutAT = SumBeznOutAT + doc.OutSum;
          if (IsCur != 0)
            SumBeznInE    = SumBeznInE    + Cur2Rub(doc.InSum);
            SumBeznOutE   = SumBeznOutE   + Cur2Rub(doc.OutSum);
            SumBeznInATE  = SumBeznInATE  + Cur2Rub(doc.InSum);
            SumBeznOutATE = SumBeznOutATE + Cur2Rub(doc.OutSum);
          end;
        end;
        SumValFormIn = SumValFormIn + ValFormIn;
        SumValFormOut = SumValFormOut + ValFormOut;
        SumOstVkl = SumOstVkl + doc.Rest;
        SumOstProc = SumOstProc + doc.PercRest;
        SumValFormInAT = SumValFormInAT + ValFormIn;
        SumValFormOutAT = SumValFormOutAT + ValFormOut;
        SumOstVklAT = SumOstVklAT + doc.Rest;
        SumOstProcAT = SumOstProcAT + doc.PercRest;
      end;
      stat = Next (DocIdx);
    else
      stat = FALSE;
    end;
  end;
  if(PrevAccType != "")
    Печать_Сумм_ВВ(PrevAccType);
  end;
  DeleteDocIdx;
end;

macro Цикл_по_документам_О(DateDoc)
/*
  Организует цикл по документам данного операциониста за день

  23.09.96
*/
  var stat;
  var i;
  var Type_Account_Pred = "";
  var NamTyp = TRUE;      /*        FALSE;   */

  LinesDisplayed = false;
  Обнуление_Сумм_О();
  Обнуление_Сумм_ВВ();
  DocIdx1.IsConv = IsConv;
  DocIdx1.FNCash = Branch;
  DocIdx1.Date_Document = DateDoc;
  DocIdx1.Oper = prs.Oper;
  DocIdx1.Type_Account = "";
  DocIdx1.TypeOper = 0;
  DocIdx1.Code_Currency = 0;
  stat = getGE (DocIdx1);
  Type_Account_Pred = doc.Type_Account;
  while (stat)
    if(   (DocIdx1.IsConv==IsConv)
      AND (DocIdx1.FNCash==Branch)
      AND (DocIdx1.Date_Document==DateDoc)
      AND (DocIdx1.Oper==prs.Oper)
      )

     /*Исключаем служебные счета и архивные "следы"*/
      if( GetDirect( doc, DocIdx1.RecPos ) AND Подкачка_по_счету()
        AND (Int(doc.Code_Currency)==Curr.Code_Currency)
        AND (doc.Brigade == OperBrigade)
        AND IsServDoc(doc)
        )
        if (Type_Account_Pred == doc.Type_Account)
          /***********************************************/
          if (doc.VidDoc != 0)
            SumOperInAT = SumOperInAT + doc.InSum;
            SumOperOutAT = SumOperOutAT + doc.OutSum;
            if (IsCur != 0)
              SumOperInATE = SumOperInATE + Cur2Rub(doc.InSum);
              SumOperOutATE = SumOperOutATE + Cur2Rub(doc.OutSum);
            end;
          else
            SumBeznInAT = SumBeznInAT + doc.InSum;
            SumBeznOutAT = SumBeznOutAT + doc.OutSum;
            if (IsCur != 0)
              SumBeznInATE  = SumBeznInATE  + Cur2Rub(doc.InSum);
              SumBeznOutATE = SumBeznOutATE + Cur2Rub(doc.OutSum);
            end;
          end;
          SumOstVklAT = SumOstVklAT + doc.Rest;
          SumOstProcAT = SumOstProcAT + doc.PercRest;
        else
          /***********************************************/
          if(LinesDisplayed)
            Печать_Сумм_ВВ(Type_Account_Pred);
            LinesDisplayed = false;
          end;
          Обнуление_Сумм_ВВ();
          Type_Account_Pred = doc.Type_Account;
          NamTyp = TRUE;
          if (doc.VidDoc != 0)
            SumOperInAT = SumOperInAT + doc.InSum;
            SumOperOutAT = SumOperOutAT + doc.OutSum;
            if (IsCur != 0)
              SumOperInATE  = SumBeznInATE  + Cur2Rub(doc.InSum);
              SumOperOutATE = SumBeznOutATE + Cur2Rub(doc.OutSum);
            end;
          else
            SumBeznInAT = SumBeznInAT + doc.InSum;
            SumBeznOutAT = SumBeznOutAT + doc.OutSum;
            if (IsCur != 0)
              SumBeznInATE  = SumBeznInATE  + Cur2Rub(doc.InSum);
              SumBeznOutATE = SumBeznOutATE + Cur2Rub(doc.OutSum);
            end;
          end;
          SumOstVklAT = SumOstVklAT + doc.Rest;
          SumOstProcAT = SumOstProcAT + doc.PercRest;
        end;
        GetValFormInOutNo();
        if ( (doc.InSum != 0)
          OR (doc.OutSum != 0)
          OR (ValFormIn != 0)
          OR (ValFormOut != 0)
          OR (doc.TypeComplexOper == Открытие_Наличными)
          OR (doc.TypeComplexOper == Открытие_Безналичными)
          OR (doc.TypeComplexOper == Закрытие_Наличными)
          OR (doc.TypeComplexOper == Закрытие_Безналичными))
          if(IsCur and (not CurrNameDisplayed))
            [ ];
            /*PrintLn(Curr.Name_Currency);*/
            PrintnNameCur;
            CurrNameDisplayed = true;
            SomethingDisplayed = true;
          end;
          if(not HeaderDisplayed)
            if ( not IsConv )
              OutSubTitle("Вклады",GetDiaryNumber);
            else
              OutSubTitle("Безналичная продажа/покупка валюты",GetDiaryNumber);
            end;
            Заголовок;
            HeaderDisplayed = true;
            SomethingDisplayed = true;
          end;
          if(not OpHeaderDisplayed)
            Заголовок_по_операционисту;
            OpHeaderDisplayed = true;
            SomethingDisplayed = true;
          end;
          if(NamTyp)
            KeyNum (dtyp, 2);
            dtyp.FlagCur = IsCur;
            dtyp.Kind = doc.Type_Account;
            if(getEQ (dtyp) == TRUE);
              [ ];
              [Вид вклада  #]( dtyp.Name);
              Разделитель_1();
              NamTyp = FALSE;
              SomethingDisplayed = true;
            end;
          end;
          FormDepGround;
          Строка_отчета();
          DepTreatChVals;
          LinesDisplayed = true;
        end;
        if (doc.VidDoc != 0)
          SumOperInO = SumOperInO + doc.InSum;
          SumOperOutO = SumOperOutO + doc.OutSum;
          if (IsCur != 0)
            SumOperInOE  = SumOperInOE  + Cur2Rub(doc.InSum);
            SumOperOutOE = SumOperOutOE + Cur2Rub(doc.OutSum);
          end;
        else
          SumBeznInO = SumBeznInO + doc.InSum;
          SumBeznOutO = SumBeznOutO + doc.OutSum;
          if (IsCur != 0)
            SumBeznInOE  = SumBeznInOE  + Cur2Rub(doc.InSum);
            SumBeznOutOE = SumBeznOutOE + Cur2Rub(doc.OutSum);
          end;
        end;
        SumValFormInO = SumValFormInO + ValFormIn;
        SumValFormOutO = SumValFormOutO + ValFormOut;
        SumValFormInAT = SumValFormInAT + ValFormIn;
        SumValFormOutAT = SumValFormOutAT + ValFormOut;
        SumOstVklO = SumOstVklO + doc.Rest;
      end;
      stat = Next (DocIdx1);
    else
      stat = FALSE;
    end;
  end;
  Расчет_Сумм;
  if ( LinesDisplayed )
    Печать_Сумм_ВВ(Type_Account_Pred);
  end;
  if ( OpHeaderDisplayed )
    Печать_Сумм_О;
  end;
end;

/***********************************************************/
macro IsDocForOper
(
 DateDoc
)

  var stat = FALSE;
  var flag;

  DocIdx1.IsConv        = IsConv;
  DocIdx1.FNCash        = Branch;
  DocIdx1.Date_Document = DateDoc;
  DocIdx1.Oper          = GroupMember.Oper;
  DocIdx1.Type_Account  = "";
  DocIdx1.TypeOper      = 0;
  DocIdx1.Code_Currency = 0;

  flag = getGE (DocIdx1);
  while (flag)
    if ((DocIdx1.IsConv        == IsConv  ) AND
        (DocIdx1.FNCash        == Branch  ) AND
        (DocIdx1.Date_Document == DateDoc ) AND
        (DocIdx1.Oper          == GroupMember.Oper )    )
     /*Исключаем служебные счета и архивные "следы"*/
      if(GetDirect(doc, DocIdx1.RecPos) and (Int(doc.Code_Currency) == Curr.Code_Currency)
         AND IsServDoc(doc) )
        stat = TRUE;
        flag = FALSE;
      else
        flag = Next(DocIdx1);
      end;
    else
      flag = FALSE;
    end;
  end;


  return stat;

end;

macro FindOper(Oper)

  prs.Oper = Int(Oper);
  if(not GetEQ(prs))
    ClearRecord(prs);
  end;
end;

/***********************************************************/
macro Цикл_по_операционистам(DateDoc)
/*
  Организует цикл по операционистам,
  если Oper == 0

  23.09.96
*/
  var
    stat;

  ClearRecord(GroupMember);
  GroupMember.Branch = Branch;
  GroupMember.Date = DateDoc;
  GroupMember.Group = OperBrigade;
  stat = GetGE(GroupMember);
  while(stat
    and (GroupMember.Branch == Branch)
    and (GroupMember.Date == DateDoc)
    and (GroupMember.Group == OperBrigade))
    FindOper(GroupMember.Oper);
    if(IsDocForOper({curdate}))
      OpHeaderDisplayed = false;
      Цикл_по_документам_О (DateDoc);
    end;
    stat = Next(GroupMember);
  end;
end;

macro ReportOnDep

  var
    SaveHD, SaveLD, SaveSD,
    OutTot = false;

  IsConv = 0;
  HeaderDisplayed = false;
  Цикл_по_операционистам({curdate});
  if(HeaderDisplayed)
    OutTot = true;
  end;
    SaveHD = HeaderDisplayed;
    SaveLD = LinesDisplayed;
    SaveSD = SomethingDisplayed;
    HeaderDisplayed = false;
    OpHeaderDisplayed = false;
    LinesDisplayed = false;
    SomethingDisplayed = false;
    IsConv = 1;
    Цикл_по_операционистам({curdate});
    if(HeaderDisplayed)
      OutTot = true;
    end;
    HeaderDisplayed = SaveHD;
    LinesDisplayed = SaveLD;
    SomethingDisplayed = SaveSD;
  if ( OutTot )
    Печать_сумм;
  end;
end;

macro CIGetOpContent

  record OGSZInfo("ci_rec.1");
  record MiscInfo("ci_rec.2");
  record CertInfo("ci_rec.3");

  var
    Str = "";

  CIOper.Type = CIRec.Type;
  CIOper.Number = CIRec.Operation;
  if(GetEQ(CIOper))
    Str = Str + CIOper.Name + ": ";
  end;
  if(CIRec.Type == CI_OGSZ)
    SetRecordAddr(OGSZInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);
    Str = Str + "ОГСЗ серии " + OGSZInfo.Series +
      ", номинал " + String(OGSZInfo.Par);
  elif((CIRec.Type == CI_LOTTERY) or (CIRec.Type==CI_ORVVZ))
    SetRecordAddr(MiscInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);
    Str = Str + MiscInfo.Name;
  elif(CIRec.Type == CI_CERT)
    SetRecordAddr(CertInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);
    Str = Str + "Сбер.сертификат " + CertInfo.Year + "г, номинал " +
      CertInfo.Par;
  elif((CIRec.Type == CI_MISC) or (CIRec.Type == CI_COIN))
    SetRecordAddr(MiscInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);
    Str = Str + MiscInfo.Name;
  elif(CIRec.Type == CI_INGOT)
    SetRecordAddr(MiscInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);
    Str = Str + MiscInfo.Name;
  end;

  if ( CIDoc.Action == D_STORN )
    if ( CIDoc.Sum >= 0 )
      Str = Str + " (сторнирован)";
    else
      Str = Str + " (сторнирующ.)";
    end;
  end;

  return Str;
end;

macro Cert99GetOpContent

  record CertInfo("ci_doc.3");

  var
    Str = "";

  CIOper.Type = CIRec.Type;
  CIOper.Number = CIDoc.Operation;
  if(GetEQ(CIOper))
    Str = Str + CIOper.Name + ": ";
  end;
  SetRecordAddr(CertInfo, CIDoc, 0, FldOffset(CIDoc, "Info"), true);
  Str = Str + "Сбер.сертификат " + CertInfo.Year + "г, номинал " +
    CertInfo.Par;

  if ( CIDoc.Action == D_STORN )
    if ( CIDoc.Sum >= 0 )
      Str = Str + " (сторнирован)";
    else
      Str = Str + " (сторнирующ.)";
    end;
  end;

  return Str;
end;

macro ReportOnCIRec

  record MiscInfo("ci_doc.2");

  var
    CIOpContent,
    CreditM = $0,
    DebetM = $0,
    CreditV = $0,
    DebetV = $0;

  GetCIRecTurns( DebetM, CreditM, DebetV, CreditV );

  if ( ( DebetM == $0 ) and ( CreditM == $0 ) and ( DebetV == $0 ) and ( CreditV == $0 ) )
    return;
  end;

  if(IsCur and (not CurrNameDisplayed))
    [ ];
    /*PrintLn(Curr.Name_Currency);*/
    PrintnNameCur;
    CurrNameDisplayed = true;
    SomethingDisplayed = true;
  end;
  if(not HeaderDisplayed)
    OutSubTitle("Прочие операции",GetDiaryNumber);
    OutHead;
    HeaderDisplayed = true;
    SomethingDisplayed = true;
  end;

  CIOpContent = GetApplTime( CIRec.ApplicationKey ) + CIGetOpContent;

  OutLine(CIOpContent, 0, CreditM, DebetM, $0L, $0L, CreditV, DebetV,
    CIIsCashOper(CIRec.Type, CIRec.Operation));
end;

macro ReportOnCert99Doc

  var
    Cert99OpContent,
    CreditM = $0,
    DebetM = $0,
    CreditV = $0,
    DebetV = $0;

/*
  if ( CIDoc.Action )
    return;
  end;
*/

  GetCIDocTurns( DebetM, CreditM, DebetV, CreditV );

  if ( ( DebetM == $0 ) and ( CreditM == $0 ) and ( DebetV == $0 ) and ( CreditV == $0 ) )
    return;
  end;

  if(IsCur and (not CurrNameDisplayed))
    [ ];
    /*PrintLn(Curr.Name_Currency);*/
    PrintnNameCur;
    CurrNameDisplayed = true;
    SomethingDisplayed = true;
  end;
  if(not HeaderDisplayed)
    OutSubTitle("Прочие операции",GetDiaryNumber);
    OutHead;
    HeaderDisplayed = true;
    SomethingDisplayed = true;
  end;

  Cert99OpContent = GetApplTime( CIDoc.ApplicationKey ) +
                       Cert99GetOpContent;

  OutLine(Cert99OpContent, 0, CreditM, DebetM, $0L, $0L, CreditV, DebetV,
    CIIsCashOper(CIDoc.Type, CIDoc.Operation));
end;

macro ReportOnCapIssueType

  var
    RecFound;

  ClearRecord(CIRec);
  CIRec.Branch = Branch;
  CIRec.IsCur = IsCur;
  CIRec.Type = CapIssue.Type;
  CIRec.Date = {curdate};
  RecFound = GetGE(CIRec);
  while(RecFound
    and (CIRec.Branch == Branch)
    and (CIRec.IsCur == IsCur)
    and (CIRec.Type == CapIssue.Type)
    and (CIRec.Date == {curdate}))
    if( ( CIRec.Brigade == OperBrigade ) and ( CIRec.Mode == Mode )  and ( CIRec.CurCode == Curr.Code_Currency ) )
      ReportOnCIRec;
    end;
    RecFound = Next(CIRec);
  end;
end;

macro ReportOnCIMisc

  var
    CreditM = $0,
    DebetM = $0,
    CreditV = $0,
    DebetV = $0,
    RecFound;

  ClearRecord(CIRec);
  CIRec.Branch = Branch;
  CIRec.IsCur = IsCur;
  CIRec.Type = CapIssue.Type;
  CIRec.Date = {curdate};
  RecFound = GetGE(CIRec);
  while(RecFound
    and (CIRec.Branch == Branch)
    and (CIRec.IsCur == IsCur)
    and (CIRec.Type == CapIssue.Type)
    and (CIRec.Date == {curdate}))
    if( ( CIRec.Brigade == OperBrigade ) and ( CIRec.Mode == Mode )  and ( CIRec.CurCode == Curr.Code_Currency ) )
      if ( CIRec.Operation == O_MISC_BUY )
        GetCIRecTurns( DebetM, CreditM, DebetV, CreditV );
      else
        ReportOnCIRec;
      end;
    end;
    RecFound = Next(CIRec);
  end;
  if ( ( DebetM == $0 ) and ( CreditM == $0 ) and ( DebetV == $0 ) and ( CreditV == $0 ) )
    return;
  end;
  if(not HeaderDisplayed)
    OutSubTitle("Прочие операции",GetDiaryNumber);
    OutHead;
    HeaderDisplayed = true;
    SomethingDisplayed = true;
  end;
  OutLine( GetApplTime( CIRec.ApplicationKey ) +
           "Выкуп облигаций целевого займа", 0, CreditM, DebetM, $0L, $0L,
           CreditV, DebetV, true);
end;

macro ReportOnCert

  record CertInfo("ci_rec.3");

  var
    CreditM = $0,
    DebetM = $0,
    CreditV = $0,
    DebetV = $0,
    RecFound;

  SetRecordAddr(CertInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);

  ClearRecord(CIRec);
  CIRec.Branch = Branch;
  CIRec.IsCur = IsCur;
  CIRec.Type = CapIssue.Type;
  CIRec.Date = {curdate};
  RecFound = GetGE(CIRec);
  while(RecFound
    and (CIRec.Branch == Branch)
    and (CIRec.IsCur == IsCur)
    and (CIRec.Type == CapIssue.Type)
    and (CIRec.Date == {curdate}))
    if( ( CIRec.Brigade == OperBrigade ) and ( CIRec.Mode == Mode )  and ( CIRec.CurCode == Curr.Code_Currency ) and ( CertInfo.Year != 1999 ) )
      if ( ( CertInfo.Year == 1988 ) and ( ( CIRec.Operation == O_CERT_PAY ) or ( CIRec.Operation == O_CERT_PAYALN ) ) )
        GetCIRecTurns( DebetM, CreditM, DebetV, CreditV );
      else
        ReportOnCIRec;
      end;
    end;
    RecFound = Next(CIRec);
  end;
  if ( ( DebetM == $0 ) and ( CreditM == $0 ) and ( DebetV == $0 ) and ( CreditV == $0 ) )
    return;
  end;
  if(not HeaderDisplayed)
    OutSubTitle("Прочие операции",GetDiaryNumber);
    OutHead;
    HeaderDisplayed = true;
    SomethingDisplayed = true;
  end;
  OutLine( GetApplTime( CIRec.ApplicationKey ) +
           "Оплата сертификатов 1988 г.", 0, CreditM, DebetM, $0L, $0L,
           CreditV, DebetV, true);
end;

macro ReportOnCert99

  record CertInfo("ci_rec.3");

  var
    RecFound;

  SetRecordAddr(CertInfo, CIRec, 0, FldOffset(CIRec, "Info"), true);

  ClearRecord(CIRec);
  CIRec.Branch = Branch;
  CIRec.IsCur = IsCur;
  CIRec.Type = CapIssue.Type;
  CIRec.Date = {curdate};
  RecFound = GetGE(CIRec);
  while(RecFound
    and (CIRec.Branch == Branch)
    and (CIRec.IsCur == IsCur)
    and (CIRec.Type == CapIssue.Type)
    and (CIRec.Date == {curdate}))
    if( ( CIRec.Brigade == OperBrigade ) and ( CIRec.Mode == Mode )  and ( CIRec.CurCode == Curr.Code_Currency ) and ( CertInfo.Year == 1999 ) )
      CIDoc.RecApplicKind = CIRec.ApplicationKind;
      CIDoc.RecApplicKey = CIRec.ApplicationKey;
      RecFound = GetGE( CIDoc );
      while ( RecFound
        and ( CIDoc.RecApplicKind == CIRec.ApplicationKind )
        and ( CIDoc.RecApplicKey == CIRec.ApplicationKey ) )
        if ( ( CheckConfirm( not CIDoc.IsConfirmed ) or ( CIDoc.Action == D_STORN ) ) and CheckCIDoc )
          ReportOnCert99Doc;
        end;
        RecFound = Next( CIDoc );
      end;
    end;
    RecFound = Next(CIRec);
  end;
end;

macro ReportOnCapIssuesForCurr

  Rewind( CapIssue );
  while ( Next( CapIssue ) )
    if ( CapIssue.Type == CI_MISC )
      ReportOnCIMisc;
    elif ( CapIssue.Type == CI_CERT )
      ReportOnCert;
      ReportOnCert99;
    else
      ReportOnCapIssueType;
    end;
  end;
end;

macro GetDskSubOp

  DskSubOp.OperType = CashDoc.NumOper;
  DskSubOp.Type = CashDoc.SubOper;
  if ( GetEQ( DskSubOp ) )
    return ", подвид " + DskSubOp.Name;
  else
    return "";
  end;
end;

macro CVGetOpContent

  var
    NativeCurr,
    Str = "";

/*
  if ( ( TmpCashVal.Type == TYPE_RES_NOPAY ) and ( TmpCashVal.TypeValue == CV_ValForm ) )
    return "";
  end;
*/

  if ( not IsShown )
    return "";
  end;

  NativeCurr = CVGetNativeCurr;

  Str = Str + GetAlgName(803, CashDoc.NumOper) + GetDskSubOp;
  if((CashDoc.NumOper == CASHOP_PANT_RI)
    or (CashDoc.NumOper == CASHOP_PANT_RET))
    Str = Str + " " + CashDoc.CashOper;
  elif ( ( CashDoc.NumOper == CASHOP_PANT_RDEB )
    or ( CashDoc.NumOper == CASHOP_PANT_RCRD )
    or ( CashDoc.NumOper == CASHOP_PANT_EDRT )
    or ( CashDoc.NumOper == CASHOP_PANT_ECRD ) )
    Str = Str + " " + GetBagInfo;
  end;
  Str = Str + ": ";
  if ( Curr.Code_Currency == NativeCurr )
    Str = Str + TmpCashVal.NameValue;
    if(TmpCashVal.Type != 0)
      Str = Str + " (" + GetCashTypeName(TmpCashVal.Type) + ")";
    end;
    if(CashDoc.Ground)
      Str = Str + " (" + CashDoc.Ground + ")";
    end;
  else
    Str = "";
  end;
  return Str;
end;

macro ReportOnCashDoc

  var
    OpContent,
    CreditM = $0,
    DebetM = $0,
    CreditV = $0,
    DebetV = $0;

  /* HACK */
  if ( CashDoc.CashPatern == "" )
    CashDoc.CashPatern = "__?";
  end;

  if ( CashDoc.CashOper == "" )
    CashDoc.CashOper = "__?";
  end;

  GetCashVal(CashDoc.RefValue);
  OpContent = CVGetOpContent;
  if(OpContent != "")
    if(
        (
          ( CashDoc.FlagDebCredOper == FLAGDEBCRED_OUT )
            and ( CashDoc.CashPatern == Safe )
            and ( ( CashDoc.CashOper != Safe ) or ( CashDoc.NumOper == CASHOP_CREDIT_SAFE ) )
        ) or (
          ( CashDoc.FlagDebCredOper == FLAGDEBCRED_IN )
            and (
             ( CashDoc.CashPatern != Safe )
               or ( ( CashDoc.CashOper == Safe ) and ( CashDoc.NumOper != CASHOP_DEBET_SAFE ) )
            )
        )
      )                          /* RA 18-11-01  Валюта на инкассо и экспертизу учитывается по номиналу, но в штучном разделе. См. ТЗ 622-02-ф.24 */
      if(     (TmpCashVal.TypeValue == CV_Currency) 
          and ( (TmpCashVal.Type == TYPE_RES_PAY  ) 
             or (TmpCashVal.Type == TYPE_RES_NOPAY) )
        )
        CreditM = CashDoc.ValueMoney;
      /*RA 18-09-00 по ТЗ 622-01-ф.24 --------------- */
      elif( ( (TmpCashVal.TypeValue == TYPERES_CURRENCY) or
              (TmpCashVal.TypeValue == TYPERES_PAYDOC  ) ) and
            ( (TmpCashVal.Type      == TYPE_RES_EXP    ) or
              (TmpCashVal.Type      == TYPE_RES_INCASS ) )
          )
        CreditV = CashDoc.ValueMoney;
      /*RA 13-11-00*/
      elif( TmpCashVal.TypeValue == TYPERES_PAYDOC )
        CreditM = CashDoc.ValueMoney;
      /* -------------------------------------------- */
      else
        if(TmpCashVal.UnitMeas == RESMESUNIT_POINT)
          if( ( TmpCashVal.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) and ( not CoinHasWeight( TmpCashVal.CodIntValue ) ) )
            CreditM = CoinMoney( TmpCashVal.CodIntValue, CashDoc.ValueCol );
          else
            CreditV = $1 * CashDoc.ValueCol;
          end;
        else
          if( ( TmpCashVal.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) and ( not CoinHasWeight( TmpCashVal.CodIntValue ) ) )
            CreditM = CashDoc.ValueMoney;
          else
            CreditV = CashDoc.ValueMoney;
          end;
        end;
      end;
    else                         /* RA 18-11-01  Валюта на инкассо и экспертизу учитывается по номиналу, но в штучном разделе. См. ТЗ 622-02-ф.24 */
      if(     (TmpCashVal.TypeValue == CV_Currency)
          and ( (TmpCashVal.Type == TYPE_RES_PAY  ) 
             or (TmpCashVal.Type == TYPE_RES_NOPAY) )
        )
        DebetM = CashDoc.ValueMoney;
      /*RA 18-09-00 по ТЗ 622-01-ф.24 --------------- */
      elif( ( (TmpCashVal.TypeValue == TYPERES_CURRENCY) or
              (TmpCashVal.TypeValue == TYPERES_PAYDOC  ) ) and
            ( (TmpCashVal.Type      == TYPE_RES_EXP    ) or
              (TmpCashVal.Type      == TYPE_RES_INCASS ) )
          )
        DebetV = CashDoc.ValueMoney;
      /*RA 13-11-00*/
      elif( TmpCashVal.TypeValue == TYPERES_PAYDOC )
        DebetM = CashDoc.ValueMoney;
      /* -------------------------------------------- */
      else
        if(TmpCashVal.UnitMeas == RESMESUNIT_POINT)
          if( ( TmpCashVal.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) and ( not CoinHasWeight( TmpCashVal.CodIntValue ) ) )
            DebetM = CoinMoney( TmpCashVal.CodIntValue, CashDoc.ValueCol );
          else
            DebetV = $1 * CashDoc.ValueCol;
          end;
        else
          if( ( TmpCashVal.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) and ( not CoinHasWeight( TmpCashVal.CodIntValue ) ) )
            DebetM = CashDoc.ValueMoney;
          else
            DebetV = CashDoc.ValueMoney;
          end;
        end;
      end;
    end;
    if( ExternPantry and ( not SafeIDDisplayed ) )
      PrintLn;
      PrintLn;
      PrintLn( DeskSubj.rec.Desc );
      PrintLn( MkStr( "=", StrLen( DeskSubj.rec.Desc ) ) );
      PrintLn;
      SafeIDDisplayed = true;
      SomethingDisplayed = true;
    end;
    if(IsCur and (not CurrNameDisplayed))
      [ ];
      /*PrintLn(Curr.Name_Currency);*/
      PrintnNameCur;
      CurrNameDisplayed = true;
      SomethingDisplayed = true;
    end;
    if(not HeaderDisplayed)
      OutSubTitle("Прочие операции",GetDiaryNumber);
      OutHead;
      HeaderDisplayed = true;
      SomethingDisplayed = true;
    end;
    OpContent = GetApplTime( CashDoc.ApplicationKey ) + OpContent;
    if(  ( TmpCashVal.Type != TYPE_RES_PAY  )     /* неплатежные */
      or ( TmpCashVal.TypeValue == TYPERES_PAYDOC) ) /* купленные ПД */
      OutLine(OpContent, 0, CreditM, DebetM, $0L, $0L, CreditV, DebetV, true, false, true);
    else                                          /* платежные */
      OutLine(OpContent, 0, CreditM, DebetM, $0L, $0L, CreditV, DebetV, true, false, false);
    end;
  end;
end;

macro ReportOnCashValsForAppKind(AppKind)

  var
    RecFound;

  KeyNum(CashDoc, 8);
  ClearRecord(CashDoc);
  CashDoc.Branch = Branch;
  CashDoc.CashDateDoc = {curdate};
  CashDoc.TypeDoc = TYPEDOC_CARRYON;
  CashDoc.ApplicationKind = AppKind;
  RecFound = GetGE(CashDoc);
  while(RecFound
    and (CashDoc.Branch == Branch)
    and (CashDoc.CashDateDoc == {curdate})
    and (CashDoc.TypeDoc == TYPEDOC_CARRYON)
    and (CashDoc.ApplicationKind == AppKind))
    if( (CashDoc.Brigade == OperBrigade ) and ( CashDoc.Mode == Mode ) )
      ReportOnCashDoc;
    end;
    RecFound = Next(CashDoc);
  end;
end;

macro ReportOnCashValsForIncassSubj

  var
    RecFound;

  KeyNum(CashDoc, 0);
  ClearRecord(CashDoc);
  CashDoc.Branch = Branch;
  CashDoc.CashDateDoc = {curdate};
  CashDoc.TypeDoc = TYPEDOC_CARRYON;
  CashDoc.CashOper = DeskSubj.rec.Name;
  RecFound = GetGE(CashDoc);
  while(RecFound
    and (CashDoc.Branch == Branch)
    and (CashDoc.CashDateDoc == {curdate})
    and (CashDoc.TypeDoc == TYPEDOC_CARRYON)
    and (CashDoc.CashOper == DeskSubj.rec.Name))
    if( (CashDoc.Brigade == OperBrigade ) and ( CashDoc.Mode == Mode ) )
      ReportOnCashDoc;
    end;
    RecFound = Next(CashDoc);
  end;
end;

macro ReportOnCashValsForIncass

  var
    SaveKey = DeskSubj.keyNum,
    Pos,
    RecFound;

  DeskSubj.keyNum = 1;

  if ( Safe != "" )
    Pos = DeskSubj.getpos;
  end;
  DeskSubj.clear;
  DeskSubj.rec.Branch = Branch;
  DeskSubj.rec.Type = DST_IO;
  RecFound = DeskSubj.getGE;
  while( RecFound
    and ( DeskSubj.rec.Branch == Branch )
    and ( DeskSubj.rec.Type == DST_IO ) )
    ReportOnCashValsForIncassSubj;
    RecFound = DeskSubj.next;
  end;
  if ( Safe != "" )
    DeskSubj.getDirect( Pos );
  end;
  DeskSubj.keyNum = SaveKey;
end;

macro ReportOnCashValsForPantry

  var
    RecFound;

  KeyNum(CashDoc, 5);
  ClearRecord(CashDoc);
  CashDoc.Branch = Branch;
  CashDoc.CashDateDoc = {curdate};
  CashDoc.TypeDoc = TYPEDOC_CARRYON;
  CashDoc.CashPatern = Safe;
  RecFound = GetGE(CashDoc);
  while(RecFound
    and (CashDoc.Branch == Branch)
    and (CashDoc.CashDateDoc == {curdate})
    and (CashDoc.TypeDoc == TYPEDOC_CARRYON)
    and (CashDoc.CashPatern == Safe))
    if( ( (CashDoc.Brigade == OperBrigade) or (BranchStatus == BS_DEP) )
      and ( CashDoc.Mode == Mode ) )
      ReportOnCashDoc;
    end;
    RecFound = Next(CashDoc);
  end;
end;

macro ReportOnCashValsForRDesk

  var
    RecFound;

  KeyNum(CashDoc, 5);
  ClearRecord(CashDoc);
  CashDoc.Branch = Branch;
  CashDoc.CashDateDoc = {curdate};
  CashDoc.TypeDoc = TYPEDOC_CARRYON;
  CashDoc.CashPatern = RDesk;
  RecFound = GetGE(CashDoc);
  while(RecFound
    and (CashDoc.Branch == Branch)
    and (CashDoc.CashDateDoc == {curdate})
    and (CashDoc.TypeDoc == TYPEDOC_CARRYON)
    and (CashDoc.CashPatern == RDesk))
    if( ( (CashDoc.Brigade == OperBrigade) or (BranchStatus == BS_DEP) )
      and ( CashDoc.Mode == Mode ) )
      ReportOnCashDoc;
    end;
    RecFound = Next(CashDoc);
  end;
end;

macro ReportOnCashValsForEDesk

  var
    RecFound;

  KeyNum(CashDoc, 5);
  ClearRecord(CashDoc);
  CashDoc.Branch = Branch;
  CashDoc.CashDateDoc = {curdate};
  CashDoc.TypeDoc = TYPEDOC_CARRYON;
  CashDoc.CashPatern = EDesk;
  RecFound = GetGE(CashDoc);
  while(RecFound
    and (CashDoc.Branch == Branch)
    and (CashDoc.CashDateDoc == {curdate})
    and (CashDoc.TypeDoc == TYPEDOC_CARRYON)
    and (CashDoc.CashPatern == EDesk))
    if( ( (CashDoc.Brigade == OperBrigade) or (BranchStatus == BS_DEP) )
      and ( CashDoc.Mode == Mode ) )
      ReportOnCashDoc;
    end;
    RecFound = Next(CashDoc);
  end;
end;

macro ReportOnCashVals

  if(BranchStatus == BS_DEP)
    ReportOnCashValsForPantry;
  else
    ReportOnCashValsForIncass;
    ReportOnCashValsForAppKind(SB_EXTCASH);
  end;
end;

macro Find_PayKind

  var stat;

  KeyNum(pay_kind,0);
  ReWind(pay_kind);
  pay_kind.IsCur      = PayDoc.IsCur;
  pay_kind.GroupOpert = PayDoc.GroupOpert;
  pay_kind.NumOperat  = PayDoc.NumOpert;
  stat = GetEQ(pay_kind);

  return stat;

end;

macro Find_PayCsOp

  var stat = FALSE;

  if (PayDoc.ApplType > 0)
    KeyNum(pay_csop,0);
    ReWind(pay_csop);
    pay_csop.IsCur     = PayDoc.IsCur;
    pay_csop.GroupType = PayDoc.GroupOpert;
    pay_csop.NumOperat = PayDoc.NumOpert;
    pay_csop.ApplType  = PayDoc.ApplType;
    stat = GetEQ(pay_csop);
  end;

  return stat;

end;

macro GetRecipientName
  file pmntProp("rtPaymentprop.dbt") key 0;
  pmntProp.DocApplicationKind = PayDoc.iApplicationKind;
  pmntProp.DocApplicationKey = PayDoc.ApplicationKey;
  if( GetEQ(pmntProp) )
    return pmntProp.Name;
  end;
  return "";
end;

macro FormGround

  var Ground = "";

  if ( PayDoc.Ground == "" )
    /* ------------------- Коммунальные платежи ------------------- */
    if (PayDoc.GroupOpert == 1)
      /* Название получателя */
      Ground = GetRecipientName;
    /* ------------- Наличные перечисления и выплаты -------------- */
    elif ((PayDoc.GroupOpert == 11) OR (PayDoc.GroupOpert == 41))
      /* Вид платежа */
      if (Find_PayKind())
        Ground = pay_kind.SzNameAlg + " ";
      end;
      /* Подвид платежа */
      if (Find_PayCsOp())
        Ground = Ground + "(" + pay_csop.NameCompType + ") ";
      end;
      /* Счет */
      Ground = Ground + Acc_Form(PayDoc.Account_Recipient);
    /* ------------------------- Комиссии ------------------------- */
    elif (PayDoc.GroupOpert == 21)
      /* Вид платежа */
      if (Find_PayKind())
        Ground = pay_kind.SzNameAlg;
      end;
    /* ------------------------ Конверсии ------------------------- */
    elif (PayDoc.GroupOpert == 31)
      /* Вид платежа */
      if (Find_PayKind())
        Ground = pay_kind.SzNameAlg;
      end;
    end;
    /* Для всех кассовых операций добавляем основание */
    Ground = Trim(Ground + "  " + PayDoc.Ground) + "  ";
  else
    Ground = Trim( PayDoc.Ground ) + "  ";
  end;

  /* Для всех кассовых операций добавляем ФИО, если оно есть */
  if (Trim(PayDoc.ClientLastName) != "")
    Ground = Ground + PayDoc.ClientLastName;
  end;
  if (Trim(PayDoc.ClientFirstName) != "")
    Ground = Ground + " " + SubStr(PayDoc.ClientFirstName,1,1) + ".";
  end;
  if (Trim(PayDoc.ClientSecondName) != "")
    if (Trim(PayDoc.ClientFirstName) != "")
      Ground = Ground + SubStr(PayDoc.ClientSecondName,1,1) + ".";
    else
      Ground = Ground + " " + SubStr(PayDoc.ClientSecondName,1,1) + ".";
    end;
  end;
  Ground = Trim(Ground);

  if ( PayDoc.Action == D_STORN )
    if ( PayDoc.InSum >= 0 )
      Ground = Ground + " (сторнирован)";
    else
      Ground = Ground + " (сторнирующ.)";
    end;
  end;

  if (Ground == "")
    Ground = " "; /* Чтобы не ругалась StrSplit */
  end;

  /* return GetApplTime(PayDoc.ApplicationKey) + Ground; */
  return Ground;

end;

macro GetCPayKindName
  file cp_type ("rtcp_type.dbt") key 0;
  cp_type.Id = PayDoc.NumOpert;
  if ( GetEQ(cp_type) )
    return cp_type.Name;
  end;
  return "Платеж без договора";
end;

macro AddCP(FormGround, CreditM, CreditN, CreditV, DebetV)

  var sKind = "";
  var i = 0;
  var mFind = false;
  var iFind = 0;

  if ( IsCur != 0 )
    return;
  end;

  if ( CP_FLAG == 1 )
    if ( ( StrLen(sFormGround) == 0 )  or  ( sFormGround != FormGround ) )
      if ( StrLen(sFormGround) != 0 )
        OutLine( GetApplTime( PayDoc.ApplicationKey ) +
                 sFormGround, 0, mCreditM(0), $0L, mCreditN(0), $0L,
                 mCreditV(0), mDebetV(0), true);
      end;
      sFormGround = FormGround;
      mCreditM(0) = CreditM;
      mCreditN(0) = CreditN;
      mCreditV(0) = CreditV;
      mDebetV(0)  = DebetV;
    else
      mCreditM(0) = mCreditM(0) + CreditM;
      mCreditN(0) = mCreditN(0) + CreditN;
      mCreditV(0) = mCreditV(0) + CreditV;
      mDebetV(0)  = mDebetV(0)  + DebetV;
    end;
  else

    sKind = GetCPayKindName;

    while ( i < mSize )
      if ( mKind(i) == sKind )
        mFind = true;
        iFind = i;
      end;
      i = i + 1;
    end;
    if ( mFind )
      mCreditM(iFind) = mCreditM(iFind) + CreditM;
      mCreditN(iFind) = mCreditN(iFind) + CreditN;
      mCreditV(iFind) = mCreditV(iFind) + CreditV;
      mDebetV (iFind) = mDebetV (iFind) + DebetV;
    else
      mKind   (mSize) = sKind;
      mCreditM(mSize) = CreditM;
      mCreditN(mSize) = CreditN;
      mCreditV(mSize) = CreditV;
      mDebetV (mSize) = DebetV;
      mSize = mSize + 1;
    end;

  end;

end;

macro OutCP

  var i = 0, s = 0;

  if ( IsCur != 0 )
    return;
  end;

  if   ( CP_FLAG == 0 )
    return;
  elif ( CP_FLAG == 1 )
    OutLine( GetApplTime( PayDoc.ApplicationKey ) +
             sFormGround, 0, mCreditM(0), $0L, mCreditN(0), $0L,
             mCreditV(0), mDebetV(0), true);
  else
    s = asize(mKind);
    while( i < s )
      OutLine( GetApplTime( PayDoc.ApplicationKey ) +
               mKind(i), 0, mCreditM(i), $0L, mCreditN(i), $0L,
               mCreditV(i), mDebetV(i), true);
      i = i + 1;
    end;
  end;

end;

macro ReportOnPayDoc (TypeOtherOperation)

  record PayDocCnv( "pay_doc.cnv" );

  var
    CreditM = $0,
    CreditN = $0,
    DebetM = $0,
    DebetN = $0,
    CreditV = $0,
    DebetV = $0;

/*
  if ( PayDoc.Action )
    return;
  end;
*/

  SetRecordAddr(PayDocCnv,PayDoc,0,0,true);
  CalcValuesTurns(PayDoc.iApplicationKind, PayDoc.ApplicationKey,
    CreditV, DebetV, 0);
  if ( ( PayDoc.GroupOpert == CO_CONVERSION ) and ( ( Curr.Code_Currency == PayDocCnv.KonvertCodCur )
    or ( PayDoc.NumOpert != CV_SELL_BUY_CURR ) ) )
    if ( PayDoc.ApplType == FLAGDEBCRED_IN )
      CreditM = PayDoc.InSum;
    else
      DebetM = PayDoc.InSum;
    end;
    OutLine( GetApplTime(PayDoc.ApplicationKey) + FormGround,
             TypeOtherOperation, CreditM, DebetM, CreditN, $0L,
             CreditV, DebetV, true );
  elif ( PayDoc.GroupOpert != CO_CONVERSION )
    if(PayDoc.GroupOpert != CO_PAYED)
      if ( PayDoc.VidDoc == StrFor(0) )
        CreditM = PayDoc.InSum;
      else
        CreditN = PayDoc.InSum;
      end;
    else
      if ( PayDoc.VidDoc == StrFor(0) )
        DebetM = PayDoc.InSum;
      else
        DebetN = PayDoc.InSum;
      end;
    end;
    if ( ( IsCur == 0 )              and
         ( PayDoc.GroupOpert == 1 )  and
         ( CP_FLAG != 0 ) )
      AddCP(FormGround, CreditM, CreditN, CreditV, DebetV);
    else
      OutLine( GetApplTime(PayDoc.ApplicationKey) + FormGround,
               TypeOtherOperation, CreditM, DebetM, CreditN, DebetN,
               CreditV, DebetV, true );
    end;
  else     /* PayDoc.GroupOpert == CO_CONVERSION */
    if ( PayDocCnv.Yield > $0 )
      CreditM = PayDocCnv.Yield;
    else
      DebetM = -PayDocCnv.Yield;
    end;
    OutLine( GetApplTime(PayDoc.ApplicationKey) + FormGround,
             TypeOtherOperation, CreditM, DebetM, $0L, $0L,
             CreditV, DebetV, false, true );
  end;

  if ( ( PayDoc.Action != D_STORN ) or ( PayDoc.InSum < 0 ) )
    TreatChVals( PayDoc.iApplicationKind, PayDoc.ApplicationKey );
  end;
end;


/***************************************************************************
                        Отчет по кассовым операциям
***************************************************************************/
macro ReportOnPaymentsForCurr (TypeOtherOperation)

  var RecFound;
  var SaveIsCur = IsCur;

  ClearRecord(PayDoc);
  PayDoc.FNCash        = Branch;
  PayDoc.IsCur         = IsCur;
  PayDoc.CodCur        = Curr.Code_Currency;
  PayDoc.Date_Document = {curdate};
  if ( TypeOtherOperation == TOO_ALL_OTHER )
    PayDoc.GroupOpert    = 0;
  else
    PayDoc.GroupOpert    = TypeOtherOperation;
  end;
  RecFound = GetGE(PayDoc);
  while ( RecFound                             and
         (PayDoc.FNCash == Branch            ) and
         (PayDoc.IsCur == IsCur              ) and
         (PayDoc.CodCur == Curr.Code_Currency) and
         (PayDoc.Date_Document == {curdate}  )    )
    if ((  PayDoc.Brigade == OperBrigade               ) and
        (  PayDoc.Mode == Mode ) and
           ( CheckConfirm( not PayDoc.NotConfirm ) or ( PayDoc.Action == D_STORN ) ) and
           ( PayDoc.Action != D_DELETE ) and
           ( ( PayDoc.IsSuspended == "" ) or ( PayDoc.IsSuspended == "X" ) ) and
        (((TypeOtherOperation == TOO_ALL_OTHER ) and
/*          (PayDoc.GroupOpert  != CO_Conversion) and (PayDoc.GroupOpert != CO_Commission) */
           ( ( PayDoc.IsCur != 1 ) or ( PayDoc.CodCur != 0 ) )  ) or
         ((TypeOtherOperation == TOO_COMM_CONV) and
/*          ((PayDoc.GroupOpert  == CO_Conversion) or (PayDoc.GroupOpert == CO_Commission)) */
           ( PayDoc.IsCur == 1 ) and ( PayDoc.CodCur == 0 )   )   )    )
      if ((NumFlagCur() != 0) and (not CurrNameDisplayed))
        [ ];
        PrintnNameCur();
        CurrNameDisplayed  = true;
        SomethingDisplayed = true;
      end;
      if (TypeOtherOperation == TOO_COMM_CONV)
        IsCur = 0;
      end;
      if (not HeaderDisplayed)
        if (TypeOtherOperation == TOO_COMM_CONV)
          OutSubTitle("Операции конвертации и прочие операции валютного режима в нац.валюте",GetDiaryNumber);
        else
          OutSubTitle("Прочие операции",GetDiaryNumber);
        end;
        OutHead();
        HeaderDisplayed    = true;
        SomethingDisplayed = true;
      end;
      ReportOnPayDoc(TypeOtherOperation);
      IsCur = SaveIsCur;
    end;
    if ((TypeOtherOperation == TOO_COMM_CONV) and
        (PayDoc.GroupOpert  != CO_Conversion) and (PayDoc.GroupOpert  != CO_Commission))
      RecFound = FALSE;
    else
      RecFound = Next(PayDoc);
    end;
  end;

  OutCP();

end;


/***************************************************************************
***************************************************************************/
macro FindCashValForCurr;

  CashVal.TypeValue = TYPERES_CURRENCY;
  CashVal.CodIntValue = Curr.Code_Currency;
  CashVal.Type = 0;
  GetEQ(CashVal);
end;

macro GetPrevRests(PrevRestM, PrevRestV, date, IsPrev)

  var
    Dd = date,
    RecFound,
    PrRstM = $0,
    PrRstV = $0;

  if ( Mode == 1 )
    Dd = Dd + 1;
  end;

  FindCashValForCurr;

  CashAcc.Branch = Branch;
  CashAcc.CashOper = Safe;
  CashAcc.SubAccount = "";
  CashAcc.RefValue = CashVal.RefValue;
  CashAcc.Date = Dd;
  if(GetLT(CashAcc) and
    (CashAcc.Branch == Branch) and
    (CashAcc.RefValue == CashVal.RefValue) and
    (CashAcc.CashOper == Safe) and
    (CashAcc.SubAccount == ""))
    PrRstM = CashAcc.RestMoney;
  end;

  GetPos(CashVal);
  CashVal.TypeValue = CV_ValForm;
  CashVal.CodIntValue = 0;
  RecFound = GetGE(CashVal);
  while(RecFound)
    Copy( TmpCashVal, CashVal );
    if ( ( CVGetNativeCurr == Curr.Code_Currency ) and ShouldAddRest( IsPrev ) )
      CashAcc.Branch = Branch;
      CashAcc.CashOper = Safe;
      CashAcc.SubAccount = "";
      CashAcc.RefValue = CashVal.RefValue;
      CashAcc.Date = Dd;
      if(GetLT(CashAcc) and
        (CashAcc.Branch == Branch) and
        (CashAcc.RefValue == CashVal.RefValue) and
        (CashAcc.CashOper == Safe) and
        (CashAcc.SubAccount == ""))
        if ( ( CashVal.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) and CoinHasWeight( CashVal.CodIntValue ) and ( CashVal.Type == TYPE_RES_PAY ) )
          if ( CashVal.UnitMeas == RESMESUNIT_POINT )
            PrRstM = PrRstM + CoinMoney( CashVal.CodIntValue, CashAcc.RestCol );
          else
            PrRstM = PrRstM + CashAcc.RestMoney;
          end;
        else
          if(CashVal.UnitMeas == RESMESUNIT_POINT)
            PrRstV = PrRstV + $1 * CashAcc.RestCol;
          else
            PrRstV = PrRstV + CashAcc.RestMoney;
          end;
        end;
      end;
    end;
    RecFound = Next(CashVal);
  end;
  GetDirect(CashVal);

  SetParm(0, PrRstM);
  SetParm(1, PrRstV);
end;

macro FindCashVal_ForCurr( Type )

  CashVal.TypeValue   = TYPERES_CURRENCY;
  CashVal.CodIntValue = Curr.Code_Currency;
  CashVal.Type        = Type;
  return GetEQ(CashVal);
end;

macro FindCashVal_ForPD( Type )

  CashVal.TypeValue   = TYPERES_PAYDOC;
  CashVal.CodIntValue = PD.ID;
  CashVal.Type        = Type;
  return GetEQ(CashVal);
end;

/* получить остаток по кассовому счету */
macro GetPrevMoneyRests_CashAcc( date, IsPrev )

  var PrRstM = $0;

  Copy( TmpCashVal, CashVal );
  if ( ShouldAddRest( IsPrev ) )
    CashAcc.Branch   = Branch;
    CashAcc.CashOper = Safe;
    CashAcc.SubAccount = "";
    CashAcc.RefValue = CashVal.RefValue;
    CashAcc.Date     = date;

    if(GetLT(CashAcc) and
      (CashAcc.Branch   == Branch) and
      (CashAcc.RefValue == CashVal.RefValue) and
      (CashAcc.CashOper == Safe) and
      (CashAcc.SubAccount == ""))
      PrRstM = CashAcc.RestMoney;
    end;
  end;

  return PrRstM;

end;

/* Вх. остатки по деньгам.
  Type ==
  TYPE_RES_PAY      Платежеспособные ресурсы
  TYPE_RES_NOPAY    Неплатежеспособные ресурсы
  TYPE_RES_DOUBT    Сомнительные ресурсы
  TYPE_RES_SAVE     На хранении
  TYPE_RES_EXP      На экспертизу
  TYPE_RES_INCASS   На инкассо
  TYPE_RES_PDNAT    ПД, оплаченные рублями(национальной валютой)
  TYPE_RES_PDCUR    ПД, оплаченные валютой
  TYPERES ==
  TYPERES_CURRENCY   Деньги (из справочника валют)
  TYPERES_VALFORM    Ценные бланки
  TYPERES_VALUABLES  Др. ценности (из справочника ценностей)
  TYPERES_PAYDOC     Платежные документы ОП
  TYPERES_CARD       Пластиковые карточки
*/

macro GetPrevMoneyRests_OneType( TYPERES, Type, PrevRestM, date, IsPrev )
  var
    RecFound,
    PrRstM = $0;

  if( TYPERES == TYPERES_CURRENCY )
    if( FindCashVal_ForCurr( Type ) )
      PrRstM = GetPrevMoneyRests_CashAcc( date );
    end;
  elif( TYPERES == TYPERES_PAYDOC )
    Rewind(PD);
    RecFound = Next(PD);
    while( RecFound )
      if( ( PD.Curr_Ref == Curr.Code_Currency/*int(Curr.ExternalCode)*/ ) and
          ( FindCashVal_ForPD( Type ) )
        )
        PrRstM = PrRstM + GetPrevMoneyRests_CashAcc( date, IsPrev );
      end;
      RecFound = Next(PD);
    end;
  end;
  SetParm(2, PrRstM);
end;

/* Вх. остатки по деньгам.
   IsPay == true - платежные (платежная валюта)
   IsPay == false - неплат.  (непл. валюта и непл.[оплаченные] ПД)
*/

macro CalcCoinRests(Rest, RestV, date, IsPrev )

  var
    Rst = $0,
    RstV = $0,
    RecFound,
    Dd = date,
    pos;

  if ( Curr.Code_Currency == 0 )
    if ( Mode == 1 )
      Dd = Dd + 1;
    end;

    pos = GetPos(CashVal);
    ClearRecord( CashVal );
    CashVal.TypeValue = TYPERES_MINCAPISSUE + CI_COIN;
    RecFound = GetGE( CashVal );
    while ( RecFound
      and ( CashVal.TypeValue == TYPERES_MINCAPISSUE + CI_COIN ) )
      Copy( TmpCashVal, CashVal );
      if ( ShouldAddRest( IsPrev ) )
        CashAcc.Branch = Branch;
        CashAcc.CashOper = Safe;
        CashAcc.SubAccount = "";
        CashAcc.RefValue = CashVal.RefValue;
        CashAcc.Date = Dd;
        if( GetLT ( CashAcc )
          and ( CashAcc.Branch == Branch )
          and ( CashAcc.CashOper == Safe )
          and ( CashAcc.SubAccount == "" )
          and ( CashAcc.RefValue == CashVal.RefValue ) )
          if ( ( not CoinHasWeight( CashVal.CodIntValue ) ) and ( CashVal.Type == TYPE_RES_PAY ) )
            if ( CashVal.UnitMeas == RESMESUNIT_POINT )
              Rst = Rst + CoinMoney( CashVal.CodIntValue, CashAcc.RestCol );
            else
              Rst = Rst + CashAcc.RestMoney;
            end;
          else
            RstV = RstV + $1 * CashAcc.RestCol;
          end;
        end;
      end;
      RecFound = Next( CashVal );
    end;
    GetDirect(CashVal,pos);
  end;

  SetParm( 0, Rst );
  SetParm( 1, RstV );
end;

macro GetPrevMoneyRests( IsPay : bool, PrevRestM, date, IsPrev )

  var
    Dd = date, 
    PrRstM  = $0;

  PrevRestM = $0;

  if ( Mode == 1 )
    Dd = Dd + 1;
  end;

  GetPos(CashVal);
  if( IsPay )
    GetPrevMoneyRests_OneType( TYPERES_CURRENCY, TYPE_RES_PAY   , PrRstM, Dd, IsPrev );
    PrevRestM = PrevRestM + PrRstM;
    CalcCoinRests( PrRstM, null, date, IsPrev  );
    PrevRestM = PrevRestM + PrRstM;
  else
    GetPrevMoneyRests_OneType( TYPERES_CURRENCY, TYPE_RES_NOPAY , PrRstM, Dd, IsPrev );
    PrevRestM = PrevRestM + PrRstM;
    GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_PAY   , PrRstM, Dd, IsPrev ); /* RA 18-11-01 */
    PrevRestM = PrevRestM + PrRstM;
    GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_NOPAY , PrRstM, Dd, IsPrev );
    PrevRestM = PrevRestM + PrRstM;
    GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_PDNAT , PrRstM, Dd, IsPrev );
    PrevRestM = PrevRestM + PrRstM;
    GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_PDCUR , PrRstM, Dd, IsPrev );
    PrevRestM = PrevRestM + PrRstM;
    GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_PD    , PrRstM, Dd, IsPrev );
    PrevRestM = PrevRestM + PrRstM;
  end;
  GetDirect(CashVal);

  SetParm(1, PrevRestM);
end;

/* Вх. остатки по ценным бланкам */

macro GetPrevValFormRests( PrevRestV, date, IsPrev  )

  var
    Dd = date,
    RecFound,
    PrRstV = $0;

  if ( Mode == 1 )
    Dd = Dd + 1;
  end;

  GetPos(CashVal);
  ClearRecord(CashVal);
  CashVal.TypeValue   = TYPERES_VALFORM;
  RecFound = GetGE(CashVal);
  while( RecFound and (CashVal.TypeValue == TYPERES_VALFORM) )
    Copy( TmpCashVal, CashVal );
    if ( ShouldAddRest( IsPrev ) and ( CVGetNativeCurr == Curr.Code_Currency ) )
      CashAcc.Branch   = Branch;
      CashAcc.CashOper = Safe;
      CashAcc.SubAccount = "";
      CashAcc.RefValue = CashVal.RefValue;
      CashAcc.Date     = Dd;
      if(GetLT(CashAcc) and
        (CashAcc.Branch   == Branch) and
        (CashAcc.RefValue == CashVal.RefValue) and
        (CashAcc.CashOper == Safe) and
        (CashAcc.SubAccount == ""))
        if ( CashVal.UnitMeas == RESMESUNIT_POINT )
          PrRstV = PrRstV + money(CashAcc.RestCol);
        else
          PrRstV = PrRstV + CashAcc.RestMoney;
        end;
      end;
    end;
    RecFound = Next(CashVal);
  end;
  GetDirect(CashVal);

  SetParm(0, PrRstV);
end;

/* Вх. остатки по ценностям (слитки, монеты и т.д.)  */

macro GetPrevOtherValueRests( PrevRestV, date, IsPrev )

  var
    RecFound,
    PrRstV = $0;

  GetPos(CashVal);
  ClearRecord(CashVal);
  CashVal.TypeValue   = TYPERES_PAYDOC + 1;
  RecFound = GetGE(CashVal);
  while( RecFound )
    Copy( TmpCashVal, CashVal );
    if ( ShouldAddRest( IsPrev ) and ( CVGetNativeCurr == Curr.Code_Currency ) )
      CashAcc.Branch   = Branch;
      CashAcc.CashOper = Safe;
      CashAcc.SubAccount = "";
      CashAcc.RefValue = CashVal.RefValue;
      CashAcc.Date     = date;
      if(GetLT(CashAcc) and
        (CashAcc.Branch   == Branch) and
        (CashAcc.RefValue == CashVal.RefValue) and
        (CashAcc.CashOper == Safe) and
        (CashAcc.SubAccount == ""))
        if ( ( CashVal.TypeValue != TYPERES_MINCAPISSUE + CI_COIN )
          or CoinHasWeight( CashVal.CodIntValue ) or ( CashVal.Type != TYPE_RES_PAY ) )
          if(CashVal.UnitMeas == RESMESUNIT_POINT)
            PrRstV = PrRstV + $1 * CashAcc.RestCol;
          else
            PrRstV = PrRstV + CashAcc.RestMoney;
          end;
        end;
      end;
    end;
    RecFound = Next(CashVal);
  end;
  GetDirect(CashVal);

  SetParm(0, PrRstV);
end;


/* Вх. остатки по ценностям
   (ценные бланки, валюта на инкассо и экспертизу, ПД на инкассо и экспертизу)
   ПО ВСЕМ ВАЛЮТАМ !!!
*/

macro GetPrevValRests( PrevRest, date, IsPrev )

  var PrRst = $0, RecFound, Dd = date;
  PrevRest  = $0;

  if ( Mode == 1 )
    Dd = Dd + 1;
  end;

  GetPos(CashVal);
  GetPos(Curr);

  Curr.Code_Currency = 0;
  RecFound = GetGE(Curr);

  /* побегаем по валютам */
  while( RecFound )
    if( Curr.CrDifrRate ) /* валюта используется */
      GetPrevValFormRests( PrRst, Dd, IsPrev );
      PrevRest = PrevRest + PrRst;
      GetPrevOtherValueRests( PrRst, Dd, IsPrev );
      PrevRest = PrevRest + PrRst;
      GetPrevMoneyRests_OneType( TYPERES_CURRENCY, TYPE_RES_INCASS , PrRst, Dd, IsPrev);
      PrevRest = PrevRest + PrRst;
      GetPrevMoneyRests_OneType( TYPERES_CURRENCY, TYPE_RES_EXP    , PrRst, Dd, IsPrev);
      PrevRest = PrevRest + PrRst;
      GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_INCASS , PrRst, Dd, IsPrev);
      PrevRest = PrevRest + PrRst;
      GetPrevMoneyRests_OneType( TYPERES_PAYDOC,   TYPE_RES_EXP    , PrRst, Dd, IsPrev);
      PrevRest = PrevRest + PrRst;
    end;
    RecFound = Next(Curr);
  end;

  GetDirect(Curr);
  GetDirect(CashVal);
  SetParm(0, PrevRest);

end;

macro CalcCentsBought

  record PayDocCnv("pay_doc.cnv");
  var
    RecFound;

  SetRecordAddr(PayDocCnv, PayDoc, 0, 0, true);
  CentsBought = $0;
  TotConvYield = $0;
  ClearRecord(PayDoc);
  PayDoc.FNCash = Branch;
  PayDoc.IsCur = IsCur;
  PayDoc.CodCur = 0;
  PayDoc.Date_Document = {curdate};
  PayDoc.GroupOpert = CO_CONVERSION;
  PayDoc.NumOpert = 1/*CVT_NONCASH Пока решено для всех видов конверсий  */;
  RecFound = GetGE(PayDoc);       /* Почему только CVT_NONCASH не ясно */
  while(RecFound                    /* ЛСВ 14.01.2000 */
    and (PayDoc.FNCash == Branch)
    and (PayDoc.IsCur == IsCur)
    and (PayDoc.CodCur == 0)
    and (PayDoc.Date_Document == {curdate})
    and (PayDoc.GroupOpert == CO_CONVERSION) )
  /*  and (PayDoc.NumOpert == CVT_NONCASH))*/
    if( ( PayDocCnv.KonvertCodCur == Curr.Code_Currency ) and ( ( PayDoc.Action < 2 ) or ( PayDoc.Action == D_STORN ) ) and ( PayDoc.ApplType == FLAGDEBCRED_IN )
      and ( ( PayDoc.IsSuspended == "" ) or ( PayDoc.IsSuspended == "X" ) ) 
      and ( PayDoc.Mode == Mode )  and  ( CheckConfirm( not PayDoc.NotConfirm ) or ( PayDoc.Action == D_STORN ) ) )
      CentsBought = CentsBought + PayDoc.InSum;
      TotConvYield = TotConvYield + PayDocCnv.Yield;
    end;
    RecFound = Next(PayDoc);
  end;
end;

macro PrevRestsPresent

  var
    PrevRestM = $0,
    PrevRestMU = $0,
    PrevRestV = $0;

  GetPrevMoneyRests(true, PrevRestM, {curdate}, true);
  GetPrevMoneyRests(false, PrevRestMU, {curdate}, true);

  return ( PrevRestM != $0 ) or ( PrevRestMU != $0 );
end;

macro OutTotalsForCurr

  var
    Dd = {curdate} + 1,
    PrevRestCn  = $0,
    RestCn      = $0,
    PrevRestCnV = $0,
    RestCnV     = $0,
    PrevRestM   = $0,
    PrevRestME  = $0,
    PrevRestV   = 0,
    RestM       = $0,
    RestME      = $0,
    RestV       = 0,
    CurRestM    = $0,
    CurRestV    = 0,
    PrevRestMU  = $0,
    PrevRestMEU = $0,
    RestMU      = $0,
    RestMEU     = $0,
    CurRestMU   = $0;

  if ( Mode == 1 )
    Dd = Dd - 1;
  end;

  GetPrevMoneyRests(true, PrevRestM, {curdate}, true);
  PrevRestV = 0;
  PrevRestME = Cur2Rub(PrevRestM);
  RestM = PrevRestM + (SumOperIn + TotCashCredit + TotCvCredit + TotExCredit) -
    (SumOperOut + TotCashDebet + TotCvDebet + TotExDebet);
  RestME = PrevRestME + (SumOperInE + TotCashCreditR + TotCvCreditR + TotExCreditR) -
    (SumOperOutE + TotCashDebetR + TotCvDebetR + TotExDebetR);
  RestV = PrevRestV + (Money(SumValFormIn) + TotCreditV + TotCvCreditV + TotExCreditV) -
    (Money(SumValFormOut) + TotDebetV + TotCvDebetV + TotExDebetV);

  GetPrevMoneyRests(false, PrevRestMU, {curdate}, true);
  PrevRestMEU = Cur2Rub(PrevRestMU);
  RestMU = PrevRestMU + (TotCashCreditU + TotExCreditU) -
    (TotCashDebetU + TotExDebetU);
  RestMEU = PrevRestMEU + (TotCashCreditRU + TotExCreditRU) -
    (TotCashDebetRU + TotExDebetRU);

  if ( not ExternPantry )
    CalcCoinRests( PrevRestCn, PrevRestCnV, {curdate}, true );
    CalcCoinRests( RestCn, RestCnV, Dd, false );
  end;
  GetPrevMoneyRests(true,  CurRestM,  Dd, false);
  GetPrevMoneyRests(false, CurRestMU, Dd, false);
  RestV = PrevRestV = 0;

  if (IsCur == 0)
    OutTotalsR(
      PrevRestCn,
      RestCn,
      PrevRestCnV,
      RestCnV,
      PrevRestM,
      PrevRestME,
      PrevRestV,
      RestM,
      RestME,
      RestV,
      CurRestM,
      CurRestV );
    OutTotalsR_Unpay(
      0,
      0,
      0,
      0,
      PrevRestMU,
      PrevRestMEU,
      0,
      RestMU,
      RestMEU,
      0,
      CurRestMU,
      0 );
  else
    OutTotalsC(
      PrevRestCn,
      RestCn,
      PrevRestCnV,
      RestCnV,
      PrevRestM,
      PrevRestME,
      PrevRestV,
      RestM,
      RestME,
      RestV,
      CurRestM,
      CurRestV );
    OutTotalsC_Unpay(
      0,
      0,
      0,
      0,
      PrevRestMU,
      PrevRestMEU,
      0,
      RestMU,
      RestMEU,
      0,
      CurRestMU,
      0 );
  end;
end;

macro OutTotalsForVal()
  var
    Dd = {curdate} + 1,
    PrevRest,
    Rest,
    CurRest;

  if ( Mode == 1 )
    Dd = Dd - 1;
  end;

  GetPrevValRests( PrevRest, {curdate}, true   );
  Rest = PrevRest +
         (SumValFormIn_2  + TotCreditV_2 + TotCvCreditV_2 + TotExCreditV_2 ) -
         (SumValFormOut_2 + TotDebetV_2  + TotCvDebetV_2  + TotExDebetV_2  );
  GetPrevValRests( CurRest,  Dd, true );
  OutTotalsQ( PrevRest, Rest, CurRest, GetDiaryNumber );
end;

macro TreatCurrentSafe_Core

  var
    RecFound;

  if ( ( ( not IsCur ) and ( Index( DeskSubj.rec.Reports, "R" ) == 0 ) )
    or ( IsCur and ( Index( DeskSubj.rec.Reports, "C" ) == 0 ) ) )
    return;
  end;

  SomethingDisplayed = false;
  SafeIDDisplayed = false;

  if(not IsCur)
    Curr.Code_Currency = 0;
    if(GetEQ(Curr))
      CreateDocIdx1;
      GetCurrRate1();
      SomethingDisplayed = false;
      FindCashValForCurr;

      Обнуление_Сумм();

      if(not ExternPantry)
        if(BranchStatus != BS_DEP)
        /* Вклады */
          ReportOnDep;
          if(HeaderDisplayed)
            OutSignForm;
          DeleteDocIdx1;
          end;
        end;
      /* Все остальное */
        HeaderDisplayed = false;
        if(BranchStatus != BS_DEP)
          ReportOnCapIssuesForCurr;
          ReportOnPaymentsForCurr(TOO_ALL_OTHER);
        end;
        ReportOnCashVals;
        if (HeaderDisplayed)
          OutTotals;
        end;
        /* Операции конвертации */
        HeaderDisplayed = false;
        if (BrigadeCur == 3)
          IsCur = 1;
          ReportOnPaymentsForCurr(TOO_COMM_CONV);
          IsCur = 0;
          if (HeaderDisplayed)
            OutTotalsCv();
          end;
        end;
      else
      /* Кладовая */
        HeaderDisplayed = false;
        if ( SafeType == DST_PANTRY )
          ReportOnCashValsForPantry;
        elif ( SafeType == DST_RDESK )
          ReportOnCashValsForRDesk;
        elif ( SafeType == DST_EDESK )
          ReportOnCashValsForEDesk;
        end;
        if(HeaderDisplayed)
          OutTotals;
        end;
      end;
      /* Обменный пункт RA 21-07-00 */
      HeaderDisplayed = false;
        ExecMacro("ReportOnExchange");
      if(HeaderDisplayed)
        ExecMacro("OutTotalsEx");
      end;
      if ( SomethingDisplayed or PrevRestsPresent )
        if ( not SomethingDisplayed )
          OutTitle;
          [ ];
          PrintnNameCur;
        end;
        OutTotalsHead( GetDiaryNumber );
        OutTotalsForCurr;
        OutSignForm;
      end;
      Накопление_ИтогаЦенностей();
    end;
  else
    CreateDocIdx1;
    Curr.Code_Currency = 1;
    RecFound = GetGE(Curr);
    while(RecFound)
      if( Curr.CrDifrRate ) /* валюта используется */
        GetCurrRate1();
        SomethingDisplayed = false;
        CurrNameDisplayed = false;
        FindCashValForCurr;

        Обнуление_Сумм();

        if(not ExternPantry)
          if(BranchStatus != BS_DEP)
          /* Вклады */
            ReportOnDep;
            if(HeaderDisplayed)
              OutSignForm;
            end;
          end;
        /* Все остальное */
          HeaderDisplayed = false;
          ReportOnCapIssuesForCurr;
          ReportOnPaymentsForCurr(TOO_ALL_OTHER);
          ReportOnCashVals;
          ShowSecondRefVal = false;
          CalcCentsBought;
          if(HeaderDisplayed)
            OutTotals;
          end;
         /* Операции конвертации */
          HeaderDisplayed = false;
          if (BrigadeCur == 1)
            ReportOnPaymentsForCurr(TOO_COMM_CONV);
            if (HeaderDisplayed)
              IsCur = 0;
              OutTotalsCv();
              IsCur = 1;
            end;
          end;
        else
        /* Кладовая */
          HeaderDisplayed = false;
          if ( SafeType == DST_PANTRY )
            ReportOnCashValsForPantry;
          elif ( SafeType == DST_RDESK )
            ReportOnCashValsForRDesk;
          elif ( SafeType == DST_EDESK )
            ReportOnCashValsForEDesk;
          end;
          if(HeaderDisplayed)
            OutTotals;
          end;
        end;
        /* Обменный пункт RA 21-07-00 */
        HeaderDisplayed = false;
        ExecMacro("ReportOnExchange");
        if(HeaderDisplayed)
          ExecMacro("OutTotalsEx");
        end;
        if ( SomethingDisplayed or PrevRestsPresent )
          if ( not SomethingDisplayed )
            OutTitle;
            [ ];
            PrintnNameCur;
          end;
          OutTotalsHead( GetDiaryNumber );
          OutTotalsForCurr;
          OutSignForm;
        end;
        Накопление_ИтогаЦенностей();
      end;

      if(Next(Curr))
        if(Curr.Code_Currency == 1)
          RecFound = false;
        else
          RecFound = true;
        end;
      elif ( ( not ExternPantry ) and ShowRblInCurrDiary )
        Rewind(Curr);
        RecFound = Next(Curr);
      else
        RecFound = false;
      end;
    end;
    DeleteDocIdx1;
  end;
end;

macro TreatCurrentSafe
  /* Сгенерим для отчета временную базу по реестрам ОП за день */
  ExecMacro("MakeTempExoperatBase");
  [ ];
  PrintLn("                                         Сводный операционный дневник" );
  IsCur = 0; /* по рублям */
  TreatCurrentSafe_Core();
  IsCur = 1; /* по валюте */
  TreatCurrentSafe_Core();
  OutTitle;
  [ ];
  OutTotalsForVal();
  OutSignForm();
  /* Удалим временную базу по реестрам ОП за день */
  ExecMacro("DelTempExoperatBase");
end;

macro ФОРМА_24()
  var
    RecFound;

  var
    RegPath = "RS-RETAIL\\ПЕЧАТИ\\ФОРМА_24",
    Type = V_STRING,
    Value,
    ErrCode;
  var
    RepeatCheckPrint = TRUE;

  Rewind( CashVal );
  Next( CashVal );
  Rewind( Curr );
  Next( Curr );

  CheckPrinter( RegPath, StrFor( 0 ), "ШИРОКИЙ" );
  SetPrintPort( "ШИРОКИЙ" );

  if ( IsDeskOpen )
    [ ];
    [ ВНИМАНИЕ! КАССА НЕ ЗАКРЫТА! ];
    [ =========================== ];
    [ ];
  end;

  /*OutTitle; перенес в TreatCurrentSafe*/

  if ( not ExternPantry )
    SafeType = DST_SAFE;
    Safe = GetNativeSafe;
    if ( Safe != "" )
      DeskSubj.rec.Branch = Branch;
      DeskSubj.rec.Name = Safe;
      if ( DeskSubj.getEQ )
        TreatCurrentSafe;
      end;
    else
      /* Смена работает "под отчет" из хранилища КБ */
      DeskSubj.clear;
      DeskSubj.rec.Branch = Branch;
      DeskSubj.rec.Reports = "RC";
      DeskSubj.rec.Desc = GetBrigadeDesc;
      TreatCurrentSafe;
    end;
  elif ( {DeskOpen} )
    DeskSubj.keyNum = 1;
    DeskSubj.clear;
    DeskSubj.rec.Branch = Branch;
    DeskSubj.rec.Type = DST_PANTRY;
    RecFound = DeskSubj.getGE;
    while ( RecFound
      and ( DeskSubj.rec.Branch == Branch )
      and ( DeskSubj.rec.Type == DST_PANTRY ) )
      Safe = DeskSubj.rec.Name;
      SafeType = DeskSubj.rec.Type;
      TreatCurrentSafe;
      RecFound = DeskSubj.next;
    end;
    DeskSubj.keyNum = 0;
    DeskSubj.rec.Branch = Branch;
    DeskSubj.rec.Name = RDesk;
    if ( DeskSubj.getEQ )
      Safe = DeskSubj.rec.Name;
      SafeType = DeskSubj.rec.Type;
      TreatCurrentSafe;
    end;
  else
    DeskSubj.rec.Branch = Branch;
    DeskSubj.rec.Name = EDesk;
    if ( DeskSubj.getEQ )
      Safe = DeskSubj.rec.Name;
      SafeType = DeskSubj.rec.Type;
      TreatCurrentSafe;
    end;
  end;
  ExitMacro;
end;
