/* Расчет дохода по сертификату */

import CommonInter;

file CapIssue("capissue.dbt") key 0;
file CertRate("certrate.dbt") key 0;
file DemandRate("dem_rate.dbt") key 0;
file Cert("cert.dbt") key 0;

/* Виды периодов */

const
  P_YEAR=1,
  P_NINEMON=2,
  P_SIXMON=3,
  P_THREEMON=4;

const
  CI_CERT=3;

/* Флаги настройки */

const
  IncludeSellDate=false,      /* Включать дату выдачи                      */ 
  IncludeDemandDate=false,    /* Включать дату возврата                    */
  NoYieldAfterEndOfTerm=true; /* Не считать доход после конца срока обращ. */	

var
  TreatLeapness=true,        /* Учитывать високосность                    */
  TreatLeapnessDem=true;      /* Учитывать високосность после конца срока  */

/* "Возвращаемое" значение */

var
  Yield, 
  Tax;

/* Параметры сертификата */

var
  ClientList = TClientList, 
  TreatLeap,
  C_Issue,
  C_Par,
  C_Duration,
  C_IncludeDemandDate,
  C_SellDate,
  C_DemandDate, 
  C_ClientCode;

var
  CBRFRate,
  SaveCBRFRate : TRecHandler,
  CurrentCBRFRate : TRecHandler;

array
  DaysInMon;

DaysInMon(  1 ) = 31;
DaysInMon(  2 ) = 28;
DaysInMon(  3 ) = 31;
DaysInMon(  4 ) = 30;
DaysInMon(  5 ) = 31;
DaysInMon(  6 ) = 30;
DaysInMon(  7 ) = 31;
DaysInMon(  8 ) = 31;
DaysInMon(  9 ) = 30;
DaysInMon( 10 ) = 31;
DaysInMon( 11 ) = 30;
DaysInMon( 12 ) = 31;

macro MyMin(a,b)

  if(a<b)
    return a;
  else
    return b;
  end;
end;


macro DaysInYear( Year )

  if ( Year / 4.0 == Int( Year / 4 ) )   /* Ламерство, знаю, но если этот макрос */
    return 366;                          /* доживет до 2100 года, править его уже */
  else                                   /* явно буду не я */
    return 365;
  end;
end;

macro AddMon(adate,m)

  var
    dim,
    year,
    month,
    day;

  DateSplit(adate,day,month,year);
  month=month+m;
  if(month>12)
    month=month-12;
    year=year+1;
  end;
                                                         
  dim = DaysInMon( month );
  if ( ( month == 2 ) and ( DaysInYear( year ) == 366 ) )
    dim = dim + 1;
  end;
  if ( day > dim )
    day = dim;
  end;

  return Date(day,month,year);
end;

macro DateDiff(Date1,Date2)

  var
    Diff=Date2-Date1,
    Day1,Day2,
    Mon1,Mon2,
    Year1,Year2,
    Feb29;

  if ( not TreatLeap )
    DateSplit(Date1,Day1,Mon1,Year1);
    DateSplit(Date2,Day2,Mon2,Year2);
    
    if(Year1/4.0==Int(Year1/4))
      Feb29=Date(29,2,Year1);
      if((Date1<Feb29) and (Date2>=Feb29))
        Diff=Diff-1;
      end;
    elif(Year2/4.0==Int(Year2/4))
      Feb29=Date(29,2,Year2);
      if((Date1<Feb29) and (Date2>=Feb29))
        Diff=Diff-1;
      end;
    end;
    return Diff;
  else
    return Diff;
  end;
end;

macro AddYears(adate,n)

  var
    year,
    month,
    day;

  DateSplit(adate,day,month,year);

  year=year+n;

  if( (DaysInYear(year) == 366) AND (day > 28) AND (month == 2))
    day = 28;
    month = 2;
  end;

  if( (DaysInYear(year) == 365) AND (day == 29) AND (month == 2))
    day = 1;
    month = 3;
  end;

  return Date(day,month,year);
end;

macro PartOfYear( Date1, Date2 )

  var
    Day,
    Mon,
    Year,
    YearStart;

  if ( ( Date1 != C_SellDate ) or ( not IncludeSellDate ) )
    Date1 = Date1 + 1;
  end;

  if ( ( Date2 != C_DemandDate ) or C_IncludeDemandDate )
    Date2 = Date2 + 1;
  end;

  if ( Date1 >= Date2 )
    return 0;
  end;
	              
  if ( TreatLeap )
    DateSplit( Date1, Day, Mon, Year );
    return Double( DateDiff( Date1, Date2 ) ) / DaysInYear( Year );
  else       
    return Double( DateDiff( Date1, Date2 ) ) / 365;
  end;
end;

macro OutHead( SellDate, DemandDate )

  [ ];
  [#################################################################]
  ( "Протокол расчета дохода по сертификату":c );
  [#################################################################]
  ( Cert.Desc:c ); 
  [ ];
  [ Начало периода:  ########## ]( SellDate );
  [ Конец периода:   ########## ]( DemandDate );
  [ ];
  [-----------------------------------------------------------------];
  [|       Период        |    |           |            |           |];
  [|---------------------|Дней| Ставка %% | Расч. база |   Доход   |];
  [|    c     |    по    |    |           |            |           |];       
  [-----------------------------------------------------------------];
end;

macro OutLine( Date1, Date2, Rate, Yld )
                            
  if ( ( Date1 != C_SellDate ) or ( not IncludeSellDate ) )
    Date1 = Date1 + 1;
  end;

  if ( ( Date2 != C_DemandDate ) or C_IncludeDemandDate )
    Date2 = Date2 + 1;
  end;

  if ( Date1 >= Date2 )
    return;
  end;

  [ ########## ########## #### ########### ############ ########### ]
  (
    Date1,
    Date2 - 1,
    DateDiff( Date1, Date2 ),
    Rate / 100:0:2,
    C_Par,
    Money( Yld )
  ); 
end;

macro OutTotalYield

  [-----------------------------------------------------------------];
  [                                                     ########### ]
  ( Money( Yield ) );
end;

macro GetCertParms

  CapIssue.Type=CI_CERT;
  if(not GetEQ(CapIssue))
    MsgBox("Тип ЦБ 'Сберегательные сертификаты' не найден");
    Exit;
  end;
end;

macro GetRate(PeriodType)

  if((PeriodType==P_THREEMON) and (CertRate.ThreeMonRate!=0))
    return CertRate.ThreeMonRate;
  elif((PeriodType>=P_SIXMON) and (CertRate.SixMonRate!=0))
    return CertRate.SixMonRate;
  elif((PeriodType>=P_NINEMON) and (CertRate.NineMonRate!=0))
    return CertRate.NineMonRate;
  elif((PeriodType==P_YEAR) and (CertRate.YearRate!=0))
    return CertRate.YearRate;
  else
    return 0;
  end;
end;

macro GetYield( PeriodType, BegDate, EndDate, Date1, Date2, Rate, Report )

  var
    POY,
    Day1, Day2,
    Mon1, Mon2,
    Year1, Year2,
    YearEnd,
    Tmp,
    Yld = $0;

  if ( ( Date1 == BegDate ) and ( Date2 == EndDate ) and ( not TreatLeapness ) and PeriodType )    
    if ( PeriodType == P_THREEMON )
      POY = 1.0 / 4;
    elif ( PeriodType == P_SIXMON )
      POY = 1.0 / 2;
    elif ( PeriodType == P_NINEMON )
      POY = 3.0 / 4;
    elif ( PeriodType == P_YEAR )
      POY = 1.0;
    end;
    Yld=Money( C_Par*Rate*POY/10000 ); 
    if ( ( ValType( Report ) != V_BOOL ) or Report )
      OutLine( Date1, Date2, Rate, Yld );          
    end;
  else
    DateSplit( Date1, Day1, Mon1, Year1 );
    DateSplit( Date2, Day1, Mon2, Year2 );
    if ( ( not TreatLeapness ) or ( DaysInYear( Year1 ) == DaysInYear( Year2 ) ) )
      POY = PartOfYear( Date1, Date2 );
      Yld=Money( Double( C_Par )*Rate*POY/10000 ); 
      if ( ( ValType( Report ) != V_BOOL ) or Report )
        OutLine( Date1, Date2, Rate, Yld );
      end; 
    else
      YearEnd = Date( 31, 12, Year1 );
      POY = PartOfYear( Date1, YearEnd );
      if ( POY )
        Yld=Money( Double( C_Par )*Rate*POY/10000 ); 
        if ( ( ValType( Report ) != V_BOOL ) or Report )
          OutLine( Date1, YearEnd, Rate, Yld );
        end;
      end;
      POY = PartOfYear( YearEnd, Date2 );
      if ( POY )
        Tmp=Money( Double( C_Par )*Rate*POY/10000 );
        Yld=Yld+Tmp; 
        if ( ( ValType( Report ) != V_BOOL ) or Report )
          OutLine( YearEnd, Date2, Rate, Tmp );
        end;
      end;
    end;
  end;   
  return Yld;
end;

macro GetTaxRate


  if ( not ClientList.GetRecord( C_ClientCode ) )
    MsgBox( "Не найден клиент" );
    Exit( 1 );
  end;

  if ( ClientList.CurRec.Rec.NotResident == StrFor( 0 ) )
    return CurrentCBRFRate.Rec.TaxRate;
  else
    return CurrentCBRFRate.Rec.TaxRateForeigh;
  end;
end;

macro CalcTaxForSpan( PeriodType, BegDate, EndDate, Date1, Date2, Rate )

  var                               
    Tmp1,
    Tmp2,
    LimRate,
    PartialTax;

  if ( ( SaveCBRFRate.Rec.QPart_m == 0 ) and ( SaveCBRFRate.Rec.QPart_n == 0 ) )
    SaveCBRFRate.Rec.QPart_m = 1;
    SaveCBRFRate.Rec.QPart_n = 1;
  end;

  LimRate = SaveCBRFRate.Rec.Rate * 100 * SaveCBRFRate.Rec.QPart_m / SaveCBRFRate.Rec.QPart_n;

  if ( Rate > LimRate )
    Tmp1 = GetYield( PeriodType, BegDate, EndDate, Date1, Date2, Rate, false );
    Tmp2 = GetYield( PeriodType, BegDate, EndDate, Date1, Date2, LimRate, false );
    PartialTax = Money( Double( Tmp1 - Tmp2 ) * GetTaxRate / 100 );
    Tax = Tax + PartialTax;
  end;
end;

macro CalcTax( PeriodType, BegDate, EndDate, Date1, Date2, Rate )

  var
    TaxBegin = Date( 20, 1, 1997 ), 
    TaxEnd = Date( 24, 8, 1997 ), 
    SpanStart, 
    RecFound;

  if ( Date1 < TaxBegin )
    Date1 = TaxBegin;
  end;

  if ( Date2 > TaxEnd )
    Date2 = TaxEnd;
  end; 

  if ( Date1 > Date2 )
    return;
  end;                    

  RecFound = CBRFRate.GetRecForDate( Date1 );

  if ( not RecFound )
    return;
  end;

  SpanStart = Date1;
  Copy( SaveCBRFRate, CBRFRate.RecHandler );
  while ( CBRFRate.Next
    and ( CBRFRate.Rec.EffectiveDate <= Date2 ) )
    CalcTaxForSpan( PeriodType, BegDate, EndDate, SpanStart, CBRFRate.Rec.EffectiveDate, Rate );
    SpanStart = CBRFRate.Rec.EffectiveDate - 1;
    Copy( SaveCBRFRate, CBRFRate.RecHandler );
  end;

  CalcTaxForSpan( PeriodType, BegDate, EndDate, SpanStart, Date2, Rate );
end;

macro CalcForPeriod(BegDate,EndDate,PeriodType)

  var
    Yld,
    RetVal=$0,
    Date1,
    Date2,
    Rate,
    POY,
    RateFound;

  TreatLeap = TreatLeapness;

  CertRate.Issue=C_Issue;
  CertRate.Date=BegDate;

  RateFound=GetLE(CertRate);
  if(not (RateFound and (CertRate.Issue==C_Issue)))
    MsgBox("Ставка на "+String(BegDate)+" не задана"); 
    Exit;
  end;
  
  Date1=BegDate;
  while(Date1<EndDate)
    Rate=GetRate(PeriodType);
    if(Next(CertRate) and (CertRate.Issue==C_Issue))
      Date2=CertRate.Date - 1;
    else
      Date2=C_DemandDate;
    end;
    Date2=MyMin(Date2,EndDate);
    RetVal=RetVal+GetYield( PeriodType, BegDate, EndDate, Date1, Date2, Rate );
    CalcTax( PeriodType, BegDate, EndDate, Date1, Date2, Rate );
    Date1=Date2; 
  end;   
  return RetVal;
end;

macro CalcForTail(BegDate,EndDate)

  var
    Yld,
    RetVal=$0,
    Date1,
    Date2,
    Rate,
    RateFound;

  TreatLeap = TreatLeapnessDem;

  DemandRate.StartDate=BegDate;

  RateFound=GetLE(DemandRate);
  if(not RateFound)
    MsgBox("Ставка до востреб. на "+String(BegDate)+" не задана");
    Exit;
  end;

  Date1=BegDate;
  while(Date1<EndDate)
    Rate=DemandRate.Rate;
    if(Next(DemandRate))
      Date2=DemandRate.StartDate - 1;
    else
      Date2=C_DemandDate;
    end;
    Date2=MyMin(Date2,EndDate);
    RetVal=RetVal+GetYield( 0, BegDate, EndDate, Date1, Date2, Rate );
    Date1=Date2; 
  end;   
  return RetVal;
end;

macro CheckDates(SellDate,DemandDate)

  if(SellDate>DemandDate)
    return false;
  else
    ClearRecord( CertRate );
    CertRate.Issue=C_Issue;

    if ( GetGE( CertRate ) )
      if ( ( SellDate < CertRate.Date ) or ( SellDate > Date( 30, 4, 1999 ) ) )
        return false;
      else
        return true; 
      end;
    else
      return false;
    end;
  end;
end;

macro FindCert(Issue)
  
  Cert.Type=CI_CERT;
  Cert.Issue=Issue;
  if(not GetEQ(Cert))
    MsgBox("Выпуск сертификата не найден");
    Exit;
  end;
end;

macro CalcYield(Issue,Par,Duration,SellDate,DemandDate,DurTermType,ClientCode)

  var
    DemRtStartDate,
    BegDate,
    EndDate,
    EndOfTerm,
    sell_day,
    sell_month,
    sell_year,
    chdm_day,
    chdm_month,
    chdm_year,
    Stat = true;

/*
    if ( DemandDate < Date( 1, 1, 2000 ) )
      TreatLeapness = TreatLeapnessDem = false;
    end;
*/

    DateSplit(SellDate,sell_day,sell_month,sell_year);
    
    if( (DaysInYear(sell_year) == 366) AND (sell_day == 29) AND (sell_month == 2))
      EndOfTerm=AddYears(SellDate,Duration); 
    else
     if(not IncludeSellDate) 
       EndOfTerm=AddYears(SellDate,Duration)+1; 
     else
       EndOfTerm=AddYears(SellDate,Duration); 
     end;
    end;

  CBRFRate = TCbRfRateList;
  SaveCBRFRate = TRecHandler( "cbrfrate.rec" );
  CurrentCBRFRate = TRecHandler( "cbrfrate.rec" );
  CBRFRate.SetFilter( 0 );
  if ( CBRFRate.GetRecForDate( DemandDate ) )
    Copy( CurrentCBRFRate, CBRFRate.RecHandler );
  else
    Stat = false;
  end;

  if ( not Stat )
    MsgBox( "Не найдена ставка рефинансирования на дату востребования сертификата" );
    Exit( 1 );
  end;                                     

  Copy( CurrentCBRFRate,CBRFRate.RecHandler );
   
  FindCert(Issue);
  TreatLeapness = Cert.TreatLeapness;
  TreatLeapnessDem = Cert.TreatLeapnessDem;
  OutHead(SellDate,DemandDate);

/*
  if(not IncludeSellDate) 
    SellDate=SellDate+1;
  end;

  if(IncludeDemandDate)
    EndOfTerm=EndOfTerm+1;
  end;
*/

  C_IncludeDemandDate = IncludeDemandDate;
  C_Issue=Issue;
  C_Par=Par;
  C_Duration=Duration;
  C_SellDate = SellDate;
  C_ClientCode = ClientCode;
  if(not CheckDates(SellDate,DemandDate))
    return false;
  end; 
  DemRtStartDate = MyMin(DemandDate,EndOfTerm - 1);
  if(NoYieldAfterEndOfTerm)
    /* Не считаем доход после конца срока обращения */
    C_DemandDate = DemRtStartDate;
    if ( C_DemandDate != DemandDate );
      C_IncludeDemandDate = true;
    end;
  else
    C_DemandDate=DemandDate;
  end;

  DateSplit(C_DemandDate,chdm_day,chdm_month,chdm_year);

  if( (DaysInYear(chdm_year) == 366) AND (chdm_day == 29) AND (chdm_month == 2))
    chdm_day = 1;
    chdm_month = 3;
    C_DemandDate = Date(chdm_day,chdm_month,chdm_year);
  end;

  GetCertParms;
  Yield=$0;
  Tax=$0;
  BegDate=SellDate;
  EndDate=AddYears(BegDate,1);
  while(EndDate<=DemRtStartDate)
    Yield=Yield+CalcForPeriod(BegDate,EndDate,P_YEAR);
    C_Par=Par+Yield;
    BegDate=EndDate;

    EndDate=AddYears(BegDate,1);
    /*MsgBox("Y: "+String(Yield));*/
  end;

  EndDate=AddMon(BegDate,9);
  if(EndDate<=DemRtStartDate)
    Yield=Yield+CalcForPeriod(BegDate,EndDate,P_NINEMON);
    BegDate=EndDate;
    /*MsgBox("9: "+String(Yield));*/
  end;

  EndDate=AddMon(BegDate,6);
  if(EndDate<=DemRtStartDate)
    Yield=Yield+CalcForPeriod(BegDate,EndDate,P_SIXMON);
    BegDate=EndDate;
    /*MsgBox("6: "+String(Yield));*/
  end;

  EndDate=AddMon(BegDate,3);
  if(EndDate<=DemRtStartDate)
    Yield=Yield+CalcForPeriod(BegDate,EndDate,P_THREEMON);
    BegDate=EndDate;
    /*MsgBox("3: "+String(Yield));*/
  end;

  EndDate=DemRtStartDate;
  if(EndDate>BegDate)
    Yield=Yield+CalcForTail(BegDate,EndDate);
    /*MsgBox("T: "+String(Yield));*/
    BegDate = EndDate;
  end;                 

  EndDate = C_DemandDate;
  if(EndDate>BegDate)
    Yield=Yield+CalcForTail(BegDate,EndDate);
    /*MsgBox("T: "+String(Yield));*/
  end;                 

  OutTotalYield;
  return true;
end;  

end;