//HashMap.mac
/*  Реализация HashMap, как в java.
    В качестве key может выступать любой тип или объект, у которого реализован метод ToString()

    Внутри реализации методы put() и resize() вызывают друг друга.
    Т.к. RSL такие вещи не поддерживает из коробки, пришлось сделать обёртку в виде класса-родителя MapInterface

    Пример использования:
    var map:HashMap = HashMap();

    map.put("test", 2);
    map.put("test2", 4);
    map.put("test3", 5);

    println(map.get("test2")); //4
    println(map.get("test3")); //5
    println(map.get("test4")); //undefined

    map.put("test2", 8);
    println(map.get("test2")); //8

    println(map.GetSize()); //3
    map.remove("test2");
    println(map.GetSize()); //2

    if (map.containsKey("test2"))
      println(map.get("test2"));
    end;
*/
class MapInterface()
  private macro resize()
  end;
end;

class (MapInterface) HashMap(initialCapacity:integer, initialLoadFactor:integer)
  private const DEFAULT_INITIAL_CAPACITY:integer = 16;
  private const DEFAULT_LOAD_FACTOR:double = 0.75;

  private var capacity:integer = DEFAULT_INITIAL_CAPACITY;
  if (initialCapacity != null)
    capacity = initialCapacity;
  end;
  
  private var loadFactor:integer = DEFAULT_LOAD_FACTOR;
  if (initialLoadFactor != null)
    loadFactor = initialLoadFactor;
  end;

  private class Entry(k, v)
    var key;
    var value;
    var next; //Entry

    macro Init(k, v)
      if (k != null)
        key = k;
      end;

      if (v != null)
        value = v;
      end;
    end;

    Init(k, v);
  end;

  private var size:integer = 0;
  private var table:TArray = TArray(true, capacity, 5); //Entry

  private macro GetHash(key):integer
    var strArr = StrSplit2(string(key), 1);
    var hash:integer = 0;
    for (var i, 0, strArr.size - 1, 1)
      hash = (31 * hash + CodeFor(strArr[i]));
    end;

    return mod(abs(hash), capacity);
  end;

  macro put(key, value)
    if ((size / capacity) >= loadFactor)
      resize();
    end;

    var idx:integer = GetHash(key);
    var current:Entry = table[idx];

    while (current != null)
      if (current.key == key)
        current.value = value;
        return
      end;
      current = current.next;
    end;

    var newEntry:Entry = Entry(key, value);
    newEntry.next = table[idx];
    table[idx] = newEntry;
    size = size + 1;
  end;

  macro get(key)
    var idx:integer = GetHash(key);
    var current:Entry = table[idx];

    while (current != null)
      if (current.key == key)
        return current.value
      end;
      current = current.next;
    end;

    return null;
  end;

  macro containsKey(key):bool
    return get(key) != null;
  end;

  macro GetSize():integer
    return size;
  end;

  macro remove(key)
    var idx:integer = GetHash(key);
    var current:Entry = table[idx];
    var prev:Entry = null;

    while (current != null)
      if (current.key == key)
        if (prev == null)
          table[idx] = current.next;
        else
          prev.next = current.next;
        end;
        size = size - 1;
        return;
      end;
      prev = current;
      current = current.next;
    end;
  end;

  private macro resize()
    capacity = capacity * 2;
    var oldTable = table;
    table = TArray(true, capacity, 5); //Entry
    size = 0;

    for (var i, 0, oldTable.size - 1, 1)
      var head = oldTable[i];
      while (head != null)
        put(head.key, head.value);
        head = head.next;
      end;
    end;
  end;

end;