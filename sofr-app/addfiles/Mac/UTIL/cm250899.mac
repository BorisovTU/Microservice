/*
  RS-Retail
  Корректировка pc_drest для Сберегательных
  Макрос полностью чистит файл по заданным счетам и заполняет его
  заново по операциям SB_DEPDOC

  ВНИМАНИЕ!
  Необходимо задать список счетов, по которым идет корректировка

  Ромодин Александр Васильевич
  25.08.99
  ===================
  Описание применения
  ===================
 1. Запустить макрос cm200899.mac с целью обнаружения несоответствия
    Макрос можно запускать неограниченное число раз, в результате-
    список счетов с расхождениями. Для анализа ошибок и причин можно
    использовать список операций по счету (карточка вкладчика) и
    список остатков для расчета процентов по условиям (вызывается
    из панели "Параметры процентов по счету" по Ctrl-F10. По альтернативным
    условиям- из поля "При нарушении условий". Панель параметров
    процентов вызывается из панели счета по F5.
    Возможные ситуации:
    1.1 Расхождение на копейку данных карточки и остатков. 
        Причина- ошибка при деноминации.
        Исправление- за последнюю дату, не превышающую дату деноминации,
        вписать верный остаток.
    1.2 Выдача процентов прошла на следующий после указанной в отчете
        даты. Ошибки нет.
    1.3 Ошибка в базе после обработки доп.взноса. 
        Причина- изменение идеологии размещения доп.взносов в программе
        при конвертации до изменений в конверторе.
        Исправление- руками либо макросом cm250899.mac с обязательным
        пересчетом и проверкой начисленных процентов за всю историю после 
        конвертации.
 2. Определить список счетов, которые необходимо корректировать макросом
    cm250899.mac и внести их в массив Account данного макроса.
    Запустить макрос. Сообщений об ошибках быть не должно. Макрос
    можно запускать неограниченное число раз.
 3. С каждым исправленным счетом далее нужна индивидуальная работа по
    корректировке процентов с даты конвертации либо возникновения
    ошибки:
    - расчитать проценты за всю историю (либо с даты конвертации)-
      выпустить отчет по Ctrl-F10 из карточки вкладчика (истории операций).
    - проанализировать расхождения и выполнить корректирующие проводки
*/
Import deprintr,Календарь,"issrvdoc.mac";

file DEPOSITR ("depositr.dbt") key 7;
file SBDEPDOC ("sbdepdoc.dbt") key 2;
file PC_DREST ("pc_drest.dbt") write key 0;

record sbdepdoc12 ("sbdepdoc.12");
/*
  Задаем массив интересующих нас счетов
*/
array Account;
Account(0) = "4230481060620000004311";
Account(1) = "4230481090620000004411";
var NumAccount = Asize(Account);

/***********************************************************
***********************************************************/

var FNcash = NumFNcash();

array TypeAccount;
TypeAccount[0] = "СБЕРЕГ.1МЕС.";
TypeAccount[1] = "СБЕРЕГ.2МЕС.";
TypeAccount[2] = "СБЕРЕГ.3МЕС.";
var NumTypeAccount = Asize(TypeAccount);

var i, n;
var st;
var {curdate};
var NumAcc = 0;
var NumErr = 0;
var PrevEndDog   = Date(0,0,0),
    NextEndDog   = Date(0,0,0),
    PrevCalcPerc = Date(0,0,0);
var ComplitContract = True;

/***********************************************************/

MACRO Den(Сумма, Дата)
 if(Дата > Date(31,12,1997))
   return Сумма;
 else
   if( Сумма < 0 )
     return -MoneyL( Floor( DoubleL( -Сумма )/1000 + 0.5 ) );
   else
     return MoneyL( Floor( DoubleL( Сумма )/1000 + 0.5 ) );
   end;
 end;/* IF */
end; /* MACRO */

/***********************************************************/

macro SetZeroDrest (Type_Object, Date_Rest)
/*
  Обнуление записи за дату
*/
  var stat;
  PC_DREST.Referenc    = DEPOSITR.Referenc;
  PC_DREST.Type_Object = Type_Object;
  PC_DREST.Date_Rest   = Date_Rest;
  if (GetEQ(PC_DREST))
    PC_DREST.Rest = 0;
    stat = Update (PC_DREST);
  else
    PC_DREST.Referenc    = DEPOSITR.referenc;
    PC_DREST.Date_Rest   = Date_Rest;
    PC_DREST.Type_Object = Type_Object;
    PC_DREST.Rest        = 0;
    PC_DREST.FNCash      = FNcash;
    stat = Insert (PC_DREST);
  end;
  return stat;
end;
/***********************************************************/

macro InsertPcDREst (Type_Object, Date_Rest, Rest)
/*
  Добавление в Pc_DRest заданной суммы
*/
  var stat, st;
  var OldRest;
  PC_DREST.Referenc    = DEPOSITR.Referenc;
  PC_DREST.Type_Object = Type_Object;
  PC_DREST.Date_Rest   = Date_Rest;
  if (GetEQ(PC_DREST))
    PC_DREST.Rest = PC_DREST.Rest + Den(Rest,Date_Rest);
    stat = Update (PC_DREST);
  else
    PC_DREST.Referenc    = DEPOSITR.Referenc;
    PC_DREST.Type_Object = Type_Object;
    PC_DREST.Date_Rest   = Date_Rest;
    if (GetLT(PC_DREST) AND
      (PC_DREST.Referenc    == DEPOSITR.Referenc) AND
      (PC_DREST.Type_Object == Type_Object))
      OldRest = PC_DREST.Rest;
    else
      OldRest = 0;
    end;
    PC_DREST.Referenc    = DEPOSITR.referenc;
    PC_DREST.Date_Rest   = Date_Rest;
    PC_DREST.Type_Object = Type_Object;
    PC_DREST.Rest        = OldRest + Den(Rest,Date_Rest);
    PC_DREST.FNCash      = FNcash;
    stat = Insert (PC_DREST);
  end;
  if (stat)
    PC_DREST.Referenc    = DEPOSITR.Referenc;
    PC_DREST.Type_Object = Type_Object;
    PC_DREST.Date_Rest   = Date_Rest;
    st = GetGT (PC_DREST);
    while(stat AND st                             AND
      (PC_DREST.Referenc    == DEPOSITR.Referenc) AND
      (PC_DREST.Type_Object == Type_Object))
      PC_DREST.Rest = PC_DREST.Rest + Den(Rest,Date_Rest);
      stat = Update (PC_DREST);
      st = Next (PC_DREST);
    end;
  end;
  if (NOT stat)
    [ ОШИБКА при разнесении остатков по #### за ##########](Type_Object, Date_Rest);
  end;
  return stat;
end;
/***********************************************************/

macro MoveInObjectType (Date_Rest,Type_Object_From,Type_Object_To)
/*
  Перенос всех остатков с одного условия на другое
*/
  var stat = True;
  var Sum, Date1;
  var st = True;
  while (st AND stat)
    PC_DREST.Referenc    = DEPOSITR.Referenc;
    PC_DREST.Type_Object = Type_Object_From;
    PC_DREST.Date_Rest   = Date_Rest;
    st = GetGE(PC_DREST); 
    st = st AND (PC_DREST.Referenc == DEPOSITR.Referenc) AND
                (PC_DREST.Type_Object == Type_Object_From);
    while (st AND (PC_DREST.Referenc == DEPOSITR.Referenc)   AND
                  (PC_DREST.Type_Object == Type_Object_From) AND
                  (PC_DREST.Rest == 0) )
      st = Next(PC_DREST);
    end;
    st = st AND (PC_DREST.Referenc == DEPOSITR.Referenc) AND
                (PC_DREST.Type_Object == Type_Object_From);
    if (st)
      Sum = PC_DREST.Rest;
      Date1 = PC_DREST.Date_Rest;
      stat = InsertPcDREst (Type_Object_From, Date1, -Sum);
      if (stat)
        stat = InsertPcDREst (Type_Object_To, Date1, Sum);
      end;
    end;
  end;
  return stat;
end;
/***********************************************************/

macro Был_Расчет_после_даты(TestDate)
/*
  Был ли расчет процентов в заданную дату и дальше?
*/
  var stat = False; /* Начало пессимистическое */
  GetPos (SBDEPDOC);
  SBDEPDOC.Referenc = DEPOSITR.Referenc;
  SBDEPDOC.DepDate_Document = TestDate;
  SBDEPDOC.NumDayDoc = 0;
  st = GetGE (SBDEPDOC);
  while (st AND (SBDEPDOC.Referenc == DEPOSITR.Referenc))
    if (IsServDoc (SBDEPDOC,"В"))
      if ((SBDEPDOC.TypeOper == 72)  AND /* Зачисление процентов */
          (SBDEPDOC.TypeComplexOper != 6))
        st = False;
        stat = True; /* Нашли */
      end;
    end;
    if (st)
      st = Next(SBDEPDOC);
    end;
  end;
  GetDirect (SBDEPDOC);
  return stat;
end;
/***********************************************************/

macro WorkWithInSum
/*
  Обработка доп.взносов
*/
  var stat = True;
  var TestDate;
  if (ComplitContract) /* Завершенный срок */
    if (DateAfterCalenMonths(SBDEPDOC.DepDate_Document,1)> NextEndDog)
      /* Не вылежал месяц до пролонгации */
      stat = InsertPcDRest (2002,SBDEPDOC.DepDate_Document,SBDEPDOC.InSum);
      if (stat)
        stat = InsertPcDRest (2002,NextEndDog,-SBDEPDOC.InSum);
      end;
      if (stat)
        stat = InsertPcDRest (2001,NextEndDog,SBDEPDOC.InSum);
      end;
    else /* Пролежал месяц до пролонгации */
      stat = InsertPcDRest (2001,SBDEPDOC.DepDate_Document,SBDEPDOC.InSum);
    end;
  else                 /* Не завершенный (последний) срок договора */
    TestDate = DateAfterCalenMonths(SBDEPDOC.DepDate_Document,1);
    if (Был_Расчет_после_даты(TestDate))
      stat = InsertPcDREst (2001,SBDEPDOC.DepDate_Document,SBDEPDOC.InSum);
    else
      stat = InsertPcDREst (2004,SBDEPDOC.DepDate_Document,SBDEPDOC.InSum);
    end;
  end;
  if (NOT stat)
    [ОШИБКА при обработке доп.взноса за ##########](SBDEPDOC.DepDate_Document);
  end;
  return stat;
end;
/***********************************************************/

macro WorkWithDepDoc
/*
  Обработка операций
*/
  var NumOper;
  var stat = True;
  var st;
  var Day;
  SBDEPDOC.Referenc = DEPOSITR.Referenc;
  SBDEPDOC.DepDate_Document = Date(0,0,0);
  SBDEPDOC.NumDayDoc = 0;
  st = GetGE (SBDEPDOC);
  NumOper = 0;
  PrevEndDog = Date(0,0,0);
  NextEndDog = Date(0,0,0);
  PrevCalcPerc = Date(0,0,0);
  while (stat AND st AND (SBDEPDOC.Referenc == DEPOSITR.Referenc))
    if (IsServDoc (SBDEPDOC,"В"))
      NumOper = NumOper + 1;
      if (NumOper == 1)
        PrevEndDog   = SBDEPDOC.DepDate_Document;
        PrevCalcPerc = SBDEPDOC.DepDate_Document;
        GetDateOff (PrevEndDog,DEPOSITR.KindTerm,DEPOSITR.Term,NextEndDog);
        if (NextEndDog < {curdate})
          ComplitContract = True;  /* Старый срок */
        else
          ComplitContract = False; /* Срок договора не завершен */
        end;
      end;
      if (NumOper == 1) /* Всегда зачисляем остаток */
        stat = InsertPcDREst (2001,SBDEPDOC.DepDate_Document,SBDEPDOC.Rest);
      else
        if ((SBDEPDOC.TypeOper == 72)  AND /* Не определенное зачисление процентов */
            (SBDEPDOC.TypeComplexOper == 0))
          if (SBDEPDOC.DepDate_Document == NextEndDog)
            SBDEPDOC.TypeComplexOper = 82; /* Считаем, что пролонгация */
          else
            DateSplit (SBDEPDOC.DepDate_Document,Day);
            if (Day == 15)
              SBDEPDOC.TypeComplexOper = 72; /* Вот так. Не нравится- уточняйте поле в базе вручную */
            else
              SBDEPDOC.TypeComplexOper = 6;
            end;
          end;
        end;
        if ((SBDEPDOC.TypeOper == 72)  AND /* Зачисление процентов */
            (SBDEPDOC.TypeComplexOper != 6) AND
            (SBDEPDOC.TypeComplexOper != 0))
          PrevCalcPerc = SBDEPDOC.DepDate_Document;
          stat = InsertPcDREst (2001,SBDEPDOC.DepDate_Document,SBDEPDOC.InSum);
          if ((SBDEPDOC.TypeComplexOper == 82) OR /* Пролонгация */
              ( (SBDEPDOC.TypeComplexOper != 6) AND
                (SBDEPDOC.DepDate_Document == NextEndDog) ) )
            PrevEndDog = NextEndDog;
            GetDateOff (PrevEndDog,DEPOSITR.KindTerm,DEPOSITR.Term,NextEndDog);
            if (NextEndDog < {curdate})
              ComplitContract = True;  /* Старый срок */
            else
              ComplitContract = False; /* Срок договора не завершен */
            end;
          end;
        elif (SBDEPDOC.TypeOper == 6) /* Выдача процентов */
          SetRecordAddr( sbdepdoc12, SBDEPDOC, 0, 0 TRUE );
          stat = InsertPcDREst (2001,PrevCalcPerc,
            -(SBDEPDOC.OutSum-sbdepdoc12.PcPercSum));
          if (stat)
            stat = InsertPcDREst (2002,PrevCalcPerc,
               (SBDEPDOC.OutSum-sbdepdoc12.PcPercSum));
          end;
          if (stat)
            stat = InsertPcDREst (2002,SBDEPDOC.DepDate_Document-1,
              -(SBDEPDOC.OutSum-sbdepdoc12.PcPercSum));
          end;
        elif ((SBDEPDOC.InSum > 0) AND /* Доп.взносы во всех видах */
              (SBDEPDOC.TypeComplexOper != 6) AND
              (SBDEPDOC.TypeComplexOper != 0))
          stat = WorkWithInSum ();
        elif ((SBDEPDOC.TypeComplexOper == 10) OR
              (SBDEPDOC.TypeComplexOper == 81) ) /* Закрытие счета */
          stat = MoveInObjectType (PrevEndDog,2001,2002);
          if (stat)
            stat = MoveInObjectType (PrevEndDog,2004,2002);
          end;
          if (stat)
            stat = SetZeroDrest (2002,SBDEPDOC.DepDate_Document);
          end;
          if (NOT stat)
            [ ОШИБКА при переносе остатков для закрытого счета]
          end;
        end;
      end;
    end;
    st = Next(SBDEPDOC);
  end;
  return stat;
end;
/***********************************************************/

macro ClearPcDRest
/*
  Чистка остатков Pc_DRest по счету
*/
  var stat = True;
  ClearRecord (PC_DREST);
  PC_DREST.Referenc = DEPOSITR.referenc;
  while (stat AND GetGE(PC_DREST) AND
         (PC_DREST.Referenc == DEPOSITR.referenc))
    stat = Delete (PC_DREST);
    ClearRecord (PC_DREST);
    PC_DREST.Referenc = DEPOSITR.referenc;
  end;
  return stat;
end;
/***********************************************************/

macro WorkWithAccount (Account)
  var stat;
  [ Обрабатывается счет #########################](Account);
  NumAcc = NumAcc + 1;
/* 1. Чистка PcDRest */
  stat = ClearPcDRest ();
  if (NOT stat)
    [ ОШИБКА при чистке старых остатков];
  else
/* 2. Цикл по операциям */
    stat = WorkWithDepDoc ();  /* -> Обработка операций */
    if (NOT stat)
      [ ОШИБКА при обработке операций];
    end;
  end;
  return stat;
end;
/***********************************************************
     Головной макрос
***********************************************************/

/*
  Заголовок
*/
  [ ];
  [             Правка базы остатков по Сберегательным ];
  [                   (Дата обработки: ##########)]({curdate});
  [ ];
/*
  Цикл по счетам
*/
  n = 0;
  while (n < NumAccount)
    [ ];
    Message (" Обрабатывается счет ",Account(n),". Осталось ",NumAccount-n," счетов...");
    DEPOSITR.FNCash  = FNcash;
    DEPOSITR.Account = Account(n);
    if (GetEQ(DEPOSITR))
      i = 0;
      st = True;
      while (st AND (i < NumTypeAccount))
        if (DEPOSITR.Type_Account == TypeAccount(i))
          st = False;
        end;
        i = i + 1;
      end;
      if (st)
        [ ОШИБКА! Счет ######################### не Сберегательный](Account(n));
      else
        if (NOT WorkWithAccount (Account(n))) /* -> Обработка счета */
          [ ОШИБКА при обработке счета];
          NumErr = NumErr + 1;
        end;
      end;
    else
      [ ОШИБКА! Счет ######################### не найден](Account(n));
    end;
    n = n + 1;
  end;
  [ ];
  [ ];
  [ Обработано ######### счетов](NumAcc);
  [ Обнаружено ######### ошибок](NumErr);
end;
