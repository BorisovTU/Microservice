/**
 @file logger.mac
 @brief Реализация класса логгера.
 
 Файл содержит реализацию класса логгера.
 
  # tag
 - functional_block:API_для_логирования
 - code_type:API
 - Логгер
 
  # changeLog
 |date       |author       |tasks                                                     |note                                                        
 |-----------|-------------|----------------------------------------------------------|-------------------------------------------------------------
 |01.11.2023 |Топорков Д.В.|BIQ-16875 BOSS-194 BOSS-1286                              | Создание
 */

/// Типы сообщений
const LOGTYPE_INFO = 0;    ///< Информационное сообщение
const LOGTYPE_WARNING = 1; ///< Предупреждение
const LOGTYPE_ERROR = 2;   ///< Ошибка

/**
@brief Класс текстового логгера
@param[in] pFilename Имя файла

Сохраняет сообщения в файл в тестовом виде (в случае если имя файла указано в конструкторе, либо установлено методом InitFile).
Если имя файла указано не было, то сообщения копятся во внутреннем массиве и после вызова InitFile будут записаны на диск. После этого массив не используется.
*/
class CTxtLogger(pFilename: String)
  private var outStream: TStreamDoc;
  private var filename: String = "";
  private var infoCount: Integer;
  private var warningCount: Integer;
  private var errorCount: Integer;
  private var messages: TArray;
  private var isTimestamp: Bool;
  
  /**
  @brief Процедура подсчета количества сообщений
  @param[in] logType тип сообщения
  */
  private macro CountMessages(logType: Integer)
    if (logType == LOGTYPE_ERROR)
      errorCount = errorCount + 1;
    elif (logType == LOGTYPE_WARNING)
      warningCount = warningCount + 1;
    else
      infoCount = infoCount + 1;
    end;
  end;
  
  /**
  @brief Процедура сброса внутренних счетчиков
  */
  private macro ResetCounters()
    infoCount = 0;
    warningCount = 0;
    errorCount = 0;
  end;
  
  /**
  @brief Процедура установки признака необходимости временной отметки в сообщениях
  @param[in] useTimestamp true - добавлять временную отметку, иначе false
  @param[in] logType Тип сообщения
  */
  macro UseTimestamp(useTimestamp: Bool)
    isTimestamp = useTimestamp;
  end;
  
  /**
  @brief Функция получения внутреннего массива сообщений
  @return TArray массив сообщений
  */
  macro GetMessages(): TArray
    return messages;
  end;
  
  /**
  @brief Процедура записи сообщения на диск/в массив
  @param[in] message Текст сообщения
  @param[in] logType Тип сообщения
  */
  macro Log(message: String, logType: Integer)
    if (ValType(logType) != V_INTEGER)
      logType = LOGTYPE_INFO;
    end;
    
    countMessages(logType);

    if (isTimestamp)
      message = Date() + " " + Time() + ": " + message;
    end;
    
    if (outStream == null)
      messages(messages.size) = message;
    else
      outStream.WriteLine(message);
    end;
  end;
  
  /**
  @brief Процедуры записи сообщений разных типов
  @param[in] message Текст сообщения
  */
  macro Info(message: String)
    Log(message, LOGTYPE_INFO);
  end;
  
  macro Warning(message: String)
    Log(message, LOGTYPE_WARNING);
  end;
  
  macro Error(message: String)
    Log(message, LOGTYPE_ERROR);
  end;
  
  /**
  @brief Функция закрытия потока записи
  @return Имя файла (или "", если сообщения сохранялись в массив)
  */
  macro Close(): String
    if (outStream != null)
      outStream = null;
    end;
    
    return filename;
  end;
  
  /**
  @brief Функция получения имени файла в который производится сохранение
  @return Имя файла (или "", если сообщения сохранялись в массив)
  */
  macro GetFileName(): String;
    return filename;
  end;
  
  /**
  @brief Процедура инициализации имени файла
  @param[in] pFileName Имя файла, в который будет происходить сохранение
  
  В случае если в во внутреннем массиве сообщений содержались записи, 
  то они будут записаны в указанный файл, массив очищен.
  Если pFileName не указан, то сообщения будут сохраняться в массив, если был
  открыт поток для записи, то он будет закрыт.
  */
  macro InitFile(pFileName)
    if ((ValType(pFilename) == V_STRING) and (StrLen(pFileName) > 0))
      filename = pFilename;
      outStream = TStreamDoc(fileName, "c");
      
      var i: Integer = 0;
      while (i < messages.size)
        outStream.WriteLine(messages(i));
        i = i + 1;
      end;
      
      messages.size = 0;
    elif (outStream != null)
      ResetCounters();
      filename = "";
      outStream = null;
    end;
  end;
  
  /**
  @brief Функция получения количества сообщений полученных объектом класса
  @param[in] logType Тип сообщений
  @return Количество всех сообщений, при вызове функции без параметра logType
  @return Иначе - количество сообщений типа logType
  */
  macro GetMessagesCount(logType: Integer)
    if (ValType(logType) == V_UNDEF)
      return (infoCount + warningCount + errorCount);
    elif (logType == LOGTYPE_ERROR)
      return errorCount;
    elif (logType == LOGTYPE_WARNING)
      return warningCount;
    else
      return infoCount;
    end;
  end;
  
  //----- конструктор -------
  messages = TArray();
  if ((ValType(pFilename) == V_STRING) and (StrLen(pFileName) > 0))
    filename = pFilename;
    outStream = TStreamDoc(fileName, "c");
  else
    filename = "";
    outStream = null;
  end;
  isTimestamp = true;
  
  ResetCounters();
end; // CTxtLogger