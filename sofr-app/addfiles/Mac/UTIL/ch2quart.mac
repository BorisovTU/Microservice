/*
$Name:           ch2quart.mac
$Module:         RETAIL
$Description:    Доработка базы, прошедшей обработку макросом pc_quart.mac
*/

/*
  RS-Retail
  Сборка 160
   Доработка базы, прошедшей обработку макросом pc_quart.mac
 при переходе на ежеквартальный расчет процентов (после ежегодного)
------------------------------------------------------------
    Работа выполнена в связи с переходом на ежеквартальный
  расчет и оплату процентов по условиям "До востребования"
------------------------------------------------------------
############################################################
------------------------------------------------------------
                   Алгоритм работы
 0. Работа- отдельно для валюты и отдельно для рублей
 1. Исправление идет только для видов вкладов- договоров
    (FormContr != 0)
 2. Если дата конца договора по счету больше 31.03.2000,
    и при этом в pc_calc имеется запись за эту дату и нет записи
    за 31.03.2000, то эта дата заменяется 31.03.2000
------------------------------------------------------------
############################################################
------------------------------------------------------------
                  Руководство пользователя
 1. Макрос может быть запущен неограниченное число раз
 2. Макрос использует тот же файл контрольной точки, что и
    pc_quart.mac, работа с контр.точкой аналогична pc_quart.mac
------------------------------------------------------------
############################################################
------------------------------------------------------------
  Ромодин Александр Васильевич
  18.03.2000
*/
Import pc_quabr, DeprIntr;

File SB_DTYP  (sb_dtyp) key 2;
File PC_ALG   (pc_alg)  key 0;
File PC_APLTP (pc_apltp)key 1;
File DEPOSITR (depositr)key 1;
File PC_CALC  (pc__calc)key 0 write;
File PCESTIM  (pcestim) key 0 write;

Record doc    (sbdepdoc);

/* ----------- Настройки ------------ */
const MinFlagCur = NumFlagCur(),  /* Обрабатываем текущую установку "Рубли/Валюта" */
      MaxFlagCur = NumFlagCur();
const DateChangeParameter = Date( 1, 1,2000); /* Дата, с которой действуют новые параметры */
const NewEndDatePeriod    = Date(31, 3,2000);
/* ---------------------------------- */

var FlagCurBreak = MinFlagCur,
    KindBreak;
var NumKind      = 0,
    NumAcc       = 0,
    NumAccKind   = 0,
    NumError     = 0,
    NumErrorKind = 0;
var FNCash = numFNcash();
var Curr = "";             
var {oper},
    {curdate};


/**************************************************************************\
|           Поиск последнего документа по накопленным процентам            |
\**************************************************************************/
macro GetLastPcEstim

  var stat;
  var find_last = FALSE;

  PCESTIM.Referenc   = DEPOSITR.Referenc;
  PCESTIM.DateOperat = Date(31,12,9999);
  PCESTIM.NumDayDoc  = 32000;
  stat = GetLE(PCESTIM);
  while (stat)
    if (PCESTIM.Referenc != DEPOSITR.Referenc)
      stat = FALSE;
    else
      if (PCESTIM.Action < 2)
        find_last = TRUE;
        stat = FALSE;
      else
        stat = Prev(PCESTIM);
      end;
    end;
  end;

  return find_last;
  
end;


/**********************************************************/
/**********************************************************/

macro ProcessingAccount
/*
  Обработка одного счета
*/
  var stat = True;
  var st;
  var ErrCode,
      ErrText;
  var NeedPcCalc = False;

  if (DEPOSITR.End_DateDep > NewEndDatePeriod)
/*
    1. Наличие в pc_calc записи за NewEndDatePeriod
*/
    PC_CALC.Referenc    = DEPOSITR.Referenc;
    PC_CALC.ObjectType  = PC_APLTP.ApplType;
    PC_CALC.TypeRecord  = 1;
    PC_CALC.EndDate     = NewEndDatePeriod;
    if (NOT GetEQ(PC_CALC))
/*
      Поиск записи за дату конца договора
*/
      PC_CALC.Referenc    = DEPOSITR.Referenc;
      PC_CALC.ObjectType  = PC_APLTP.ApplType;
      PC_CALC.TypeRecord  = 1;
      PC_CALC.EndDate     = DEPOSITR.End_DateDep;
      if (GetEQ(PC_CALC))
        NumAcc     = NumAcc + 1;
        NumAccKind = NumAccKind + 1;
        NeedPcCalc = True;
        PC_CALC.EndDate = NewEndDatePeriod;
        stat = Update (PC_CALC);
        if (NOT stat)
          NumError     = NumError + 1;
          NumErrorKind = NumErrorKind + 1;
          ErrCode      = Status (ErrText);
          [ При обработке счета ########################## Ошибка при обновлении PcCalc с кодом #####]
           (DEPOSITR.Account,ErrCode);
          [ #](ErrText);
        end;
      end;
    end;
/*
  2. Изменение даты в PcEstim
*/
    if (stat
     AND NeedPcCalc
     AND (PC_ALG.CalcAddPc == "X")
     AND ( ((DEPOSITR.UseAlternate == 0) AND (PC_APLTP.ApplType == 2001))
        OR ((DEPOSITR.UseAlternate != 0) AND (PC_APLTP.ApplType == 2002)) ) )
      if (GetLastPcEstim())
        if (PCESTIM.DateEndPeriod == DEPOSITR.End_DateDep)
          PCESTIM.DateEndPeriod = PC_CALC.EndDate;
          PCESTIM.NumSession    = 0;
          stat = Update (PCESTIM);
          if (NOT stat)
            NumError     = NumError + 1;
            NumErrorKind = NumErrorKind + 1;
            ErrCode      = Status (ErrText);
            [ При обработке счета ########################## Ошибка при обновлении PcEstim с кодом #####]
             (DEPOSITR.Account,ErrCode);
            [ #](ErrText);
          end;
        end;
      end;
    end;
/*
  3. Перерасчет процентов
*/
    if (stat AND (PC_ALG.StratCalc == 1))
/*     AND (DEPOSITR.End_DateDep == Date(0,0,0))
     AND (DEPOSITR.FormContr != 30) AND (DEPOSITR.Term_Prol == 0)
     AND (DEPOSITR.KindTerm_Prol == 0) ) */
      doc.IsCur            = DEPOSITR.IsCur;
      doc.FNCash           = DEPOSITR.FNCash;
      doc.Account          = DEPOSITR.Account;
      doc.Referenc         = DEPOSITR.Referenc;
      doc.Oper             = {oper};
      doc.Type_Account     = DEPOSITR.Type_Account;
      doc.Code_Currency    = DEPOSITR.Code_Currency;
      doc.CodClient        = DEPOSITR.CodClient;
      doc.YesSbook         = "X";
      doc.Date_Document    = {curdate};
      doc.DepDate_Document = {curdate};
  /*    doc.DepDate_Document = NewEndDatePeriod; */
      doc.Author           = 0;
      doc.iApplicationKind = 1;
      doc.IsControl        = "X";  /* Главный документ */
      st = Выполнить_Операцию (DEPOSITR.Account,
                               DEPOSITR.Type_Account,
                               DEPOSITR.Code_Currency,
                               35,
                               doc,
                               0,
                               1,
                               1,
                               35,
                               0,
                               DEPOSITR.CodClient,
                               "",
                               "",
                               {curdate},
                               PC_APLTP.ApplType);
      if (st == 0)
        [ Выполнен перерасчет процентов по условию #### для счета #########################]
         (PC_APLTP.ApplType,DEPOSITR.Account);
      else
        NumError     = NumError + 1;
        NumErrorKind = NumErrorKind + 1;
        [ *** ОШИБКА *** с кодом #### при перерасчете процентов](st);
        [                по условию #### для счета #########################]
         (PC_APLTP.ApplType,DEPOSITR.Account);
      end;
      InterDesk_EndDocBunch ();
    end;
  end;
end;
/**********************************************************/

macro GetNextAccount (Num,IsCur,FNCash,Open_Close,Type_Account)
/*
  Следующий счет по ключу
*/
  var stat = False;
  if (Num == 0)
    DEPOSITR.IsCur         = IsCur;
    DEPOSITR.FNCash        = FNCash;
    DEPOSITR.Open_Close    = Open_Close;
    DEPOSITR.Type_Account  = Type_Account;
    DEPOSITR.Code_Currency = 0;
    DEPOSITR.Number        = 0;
    stat = GetGE (DEPOSITR);
  else
    stat = Next(DEPOSITR);
  end;
  if (stat)
    stat = (    (DEPOSITR.IsCur        == IsCur)
            AND (DEPOSITR.FNCash       == FNCash)
            AND (DEPOSITR.Open_Close   == Open_Close)
            AND (DEPOSITR.Type_Account == Type_Account) )
  end;
  return stat;
end;
/**********************************************************/

macro Обработать_Вид_Вклада
/*
  1. Цикл по AplType - по каким видам вкладов идет расчет?
  2. Цикл по счетам найденного вида вклада
*/
  var ErrCode,
      ErrText;
  var stat;
  var Num;
  PC_APLTP.IsCur  = PC_ALG.FlagCur;
  PC_APLTP.ApType = PC_ALG.Referenc;
  stat = GetGE(PC_APLTP);
  while (stat
         AND (PC_APLTP.IsCur  == PC_ALG.FlagCur)
         AND (PC_APLTP.ApType == PC_ALG.Referenc) )
    if ( (PC_APLTP.ApplType == 2001)
      OR (PC_APLTP.ApplType == 2002)
      OR (PC_APLTP.ApplType == 2003)
      OR (PC_APLTP.ApplType == 2004) )
      Num = 0;
      GetPos (SB_DTYP);
      SB_DTYP.FlagCur = PC_APLTP.IsCur;
      SB_DTYP.Kind    = PC_APLTP.Type;
      if (GetEQ(SB_DTYP))
        if (SB_DTYP.FormContr != 30)
          while (GetNextAccount(Num,PC_APLTP.IsCur,FNCash,"",PC_APLTP.Type))
            Num = Num + 1;
            Message (" Вид вклада "+SB_DTYP.Kind+" ("+Curr+"). "+
              " Счет "+DEPOSITR.Account+" по условию "+PC_APLTP.ApplType);
            ProcessingAccount ();
          end;
        end;
      else
        NumError     = NumError + 1;
        NumErrorKind = NumErrorKind + 1;
        ErrCode      = Status (ErrText);
        [ *** При поиске вида вклада ############# допущена ошибка ####]
         (PC_APLTP.Type,ErrCode);
        [ #](ErrText);
      end;
      GetDirect (SB_DTYP);
    end;
    stat = Next(PC_APLTP);
  end;
end;
/**********************************************************/
/**********************************************************/

macro Нужный_Вид_Вклада
/*
  Проверка для вида вклада:
  До 31.12.1999 проценты считались ежегодно,
  с 01.01.2000 стали считаться ежеквартально
*/
  var stat = False;

  PC_ALG.FlagCur    = SB_DTYP.FlagCur;
  PC_ALG.Referenc   = SB_DTYP.Kind;
  PC_ALG.ObjectType = 1003;
  PC_ALG.BegDate    = DateChangeParameter;
  if (GetLE (PC_ALG))
    if ( (PC_ALG.BegDate  == DateChangeParameter)
     AND (PC_ALG.GrafCalc == 3) ) /* с 1.1.2000- ежеквартальный расчет */
      if (Prev(PC_ALG) AND (PC_ALG.GrafCalc == 4))
        stat = Next(PC_ALG); /* Стоим на новых параметрах обработки */
      end;
    end;
  end;
  return stat;
end;
/**********************************************************/

macro Получить_Вид_Вклада (NumKind,NumFlagCur)
  var stat = False;
  var st   = True;
  var Num  = NumKind;
  while (st)
    if (Num == 0)
      KeyNum (SB_DTYP,2);
      SB_DTYP.FlagCur = NumFlagCur;
      SB_DTYP.Kind    = Trim(KindBreak);
      stat = GetGE (SB_DTYP);
    else
      stat = Next (SB_DTYP);
    end;
    Num = Num + 1;
    if (stat AND (SB_DTYP.FlagCur > MaxFlagCur))
      stat = False;
    end;
    if (SB_DTYP.FormContr != 0)
      st = stat;
      if (stat)
        st = NOT Нужный_Вид_Вклада();
      end;
    end;
  end;
  return stat;
end;
/**********************************************************/

macro Заголовок
  var Cur;
  [ ];
  [ Исправление ошибок для договоров при переходе на ежеквартальный расчет процентов];
  [ --------------------------------------------------------------------------------];
  [ ];
  if (FlagCurBreak == 0)
    Cur = "рубли";
  elif (FlagCurBreak == 1)
    Cur = "валюта";
  end;
  if (KindBreak == "")
    [ Работа с начала (######)](Cur);
  else
    [ Работа продолжена с вида вклада "############" (######)]
      (KindBreak,Cur);
  end;
  [ ];
end;
/**********************************************************/

macro Итого
  [ ];
  [ Работа завершена ];
  [ Обработано ########## счетов для ### видов вкладов]
    (NumAcc,NumKind);
  [ Допущено ##### ошибок](NumError);
  [ ];
end;
/***********************************************************
###################### Точка входа #########################
***********************************************************/

  if (ReadFromBreakFile(FlagCurBreak,KindBreak))
    Заголовок();
      while (Получить_Вид_Вклада(NumKind,FlagCurBreak))
        if (SB_DTYP.FlagCur == 0)
          Curr = "рубли";
        else
          Curr = "валюта";
        end;
        [ ];
        [ Начата обработка вида вклада ############ (######)](SB_DTYP.Kind,Curr);
        Message (" Вид вклада "+SB_DTYP.Kind+" ("+Curr+") . . .");
        NumKind      = NumKind + 1;
        NumAccKind   = 0;
        NumErrorKind = 0;
        if (NOT WriteToBreakFile (SB_DTYP.FlagCur,SB_DTYP.Kind))
          [ Ошибка при заполнении файла прерываний ];
          NumErrorKind = NumErrorKind + 1;
          NumError     = NumError     + 1;
        end;
        Обработать_Вид_Вклада ();
        [ Обработка вида вклада завершена];
        [ Обработано ########## счетов](NumAccKind);
        [ Допущено   ##### ошибок](NumErrorKind);
      end;  
    Итого();
    WriteToBreakFile (0,"");
  else
    MsgBox ("Работа прекращена");
  end;
end;
