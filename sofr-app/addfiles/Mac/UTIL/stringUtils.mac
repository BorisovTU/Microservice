/**
 @file stringUtils.mac
 @brief Функционал для работы со строками.
 
 Файл содержит функционал для работы со строковыми переменными.
 
  # tag
 - functional_block:API_для_работы_со_строками
 - code_type:API
 
  # changeLog
 |date       |author       |tasks                                                     |note                                                        
 |-----------|-------------|----------------------------------------------------------|-------------------------------------------------------------
 |01.11.2023 |Топорков Д.В.|BIQ-16875 BOSS-194 BOSS-1286                              | Добавление StringSplit, CTextReader, GetDateTimeMark
 |?          |             |                                                          | Создание
 */

import rsExts;
 
macro concat(str, append, separator)
  if ((str == null) or (str == "")) return trim(string(append:e)); end;
  if ((append == null ) or (append == "")) return trim(string(str:e)); end;
  if (separator == null) separator = ", "; end;
  return trim(str) + separator + trim(append);
end;

macro IndexLast(source: String, search: String): Integer
  var result: Integer = 0;
  var searchIndex = Index(source, search);
  
  while (searchIndex > 0)
    result = searchIndex;
    searchIndex = Index(source, search, searchIndex + StrLen(search));
  end;
  
  return result;
end;

/**
@brief Функция разбиения строки согласно разделителя
@param[in] source Строка для разбиения
@param[in] separator Строка разделитель
@param[in] leaveBlankParts <необязательный параметр> Создавать в массиве значение для 'пустых' строк, 
           т.е. для строки "#1##3#4#" с разделителем "#" при leaveBlankParts = true создастся массив ["", "1", "", "3", "4", ""], иначе ["1", "3", "4"]
@param[in] blankPartReplaceValue <необязательный параметр> Строка-заменитель для 'пустых' строк
@return Массив строк, расположенных между разделителями
@return Пустой массив, в случае некорректных входных параметров
*/
macro StringSplit(source: String, separator: String, leaveBlankParts: Bool, blankPartReplaceValue: String): TArray
  var result: TArray = TArray();
  var part: String;
  var pos: Integer;
  
  if (ValType(blankPartReplaceValue) != V_STRING)
    blankPartReplaceValue = "";
  end;
  
  if ((ValType(source) == V_STRING) and (StrLen(source) > 0))
    if ((ValType(separator) == V_STRING) and (StrLen(separator) > 0))
      while ((pos = Index(source, separator)) > 0)
        part = SubStr(source, 1, pos - 1);
      
        if (StrLen(part) > 0)
          result(result.size) = part;
        elif (leaveBlankParts == true)
          result(result.size) = blankPartReplaceValue;
        end;
        
        source = SubStr(source, pos + StrLen(separator));
      end;
    end;
    
    if (StrLen(source) > 0)
      result(result.size) = source;
    elif (leaveBlankParts == true)
      result(result.size) = blankPartReplaceValue;
    end;
  end;

  return result;
end;

/**
@brief Функция соединения массива строк в одну.
@param[in] stringsArray Массив TArray строк
@param[in] separator Строка разделитель
@return Итоговая строка из элементов массива, с разделителями
*/
macro StringArrayConcat(stringsArray: TArray, separator: String): String
  if (ValType(separator) != V_STRING)
    separator = "";
  end;
  
  var result: String = "";
  var i = 0;
  
  while (i < stringsArray.size)
    if (ValType(stringsArray(i)) == V_STRING)
      if (StrLen(result) > 0)
        result = result + separator;
      end;
      
      result = result + stringsArray(i);
    end;
    
    i = i + 1;
  end;
  
  return result;
end;

/**
@brief Функция получения даты в виде YYYYMMDD
@param[in] value Дата
@return Строковое значение value в виде YYYYMMDD
*/
macro GetDateMark(value: Date): String
  var year, mon, day;
  
  DateSplit(value, day, mon, year);
  return String(year) + String(mon:o:2) + String(day:o:2);
end;

/**
@brief Функция получения времени в виде HHNNSS
@param[in] value Время
@return Строковое значение value в виде HHNNSS
*/
macro GetTimeMark(value: Time): String
  var hour, min, sec;
  
  TimeSplit(value, hour, min, sec);
  return String(hour:o:2) + String(min:o:2) + String(sec:o:2);
end;

/**
@brief Функция получения даты и времени в виде YYYYMMDDHHNNSS
@param[in] dateValue Дата
@param[in] timeValue Время
@return Строковое значение dateValue и timeValue в виде YYYYMMDDHHNNSS
*/
macro GetDateTimeMark(dateValue: Date, timeValue: Time): String
  return GetDateMark(dateValue) + GetTimeMark(timeValue);
end;

/**
@brief Класс для получения отдельных слов или строк из текста не более заданной длины в порядке следования в исходной строке
@param[in] text Строка для разбиения

Класс для получения отдельных слов или строк из текста не более заданной длины. Текст разбивается на слова разделителем " ".

# Методы
- MoveFirst() - Установить позицию на начало массива "слов" (текста)
- ReadWord(): String - Чтение одного "слова"
- ReadLine(maxLen: Integer): String - Получение одного или нескольких "слов" соединенных символом " " и длиной не более maxLen (см. описание)
- ReadLines(maxLen: Integer): TArray - Получения массива "строк" общей длиной каждой строки не более maxLen, начиная с текущей позиции
- HasNext(): Bool - Признак наличия данных для чтения
- EOF(): Bool - Признак окончания чтения
*/
class CTextReader(text: String)
  private var words: TArray;      ///< Массив "слов"
  private var wordIndex: Integer; ///< Позиция в массиве "слов"
    
  /**
  @brief Функция получения одного элемента текста ("слова") из массива "слов"
  @return Значение элемента массива в текущей позиции
  @return "", если массив пройден до конца
  
  При чтении "слова" позиция в массиве сдвигается на +1 элемент
  */
  macro ReadWord(): String
    if (wordIndex < words.size)
      wordIndex = wordIndex + 1;
      return words(wordIndex - 1);
    end;
    return "";
  end;
  
  /**
  @brief Функция показывает наличие непрочитанных элементов в массиве
  @return true, если массив не прочитан до конца
  @return false, если данных для чтения нет
  */
  macro HasNext(): Bool
    return (wordIndex < words.size)
  end;
  
  /**
  @brief Функция показывает прочитан ли массив "слов" полностью
  @return true, если массив прочитан до конца
  @return false, если есть данные для чтения
  */
  macro EOF(): Bool
    return (wordIndex >= words.size)
  end;
  
  /**
  @brief Процедура устанавливает позицию в массиве на начало
  */
  macro MoveFirst()
    wordIndex = 0;
  end;
  
  /**
  @brief Функция получения одного или нескольких N "слов" соединенных символом " " и общей длиной строки не более maxLen, с учетом перевода строки
  @param[in] maxLen Максимальный размер итоговой строки
  @return Одно или несколько N значений массива, соединенных символом " "
  @return "" Если массив пройден до конца
  
  При чтении позиция в массиве сдвигается на +N прочитанных "слов"
  
  @note Если размер одного "слова" более maxLen, то "слово" будет возвращено полностью без урезания
  @note Переводы строки заменяются на ""
  */
  macro ReadLine(maxLen: Integer): String
    var result: String = "";
    
    if (not EOF())
      result = ReadWord();
    end;
    
    if (ValType(maxLen) != V_INTEGER)
      maxLen = 0;
    end;

    while ((SubStr(result, StrLen(result)) != "\n") and HasNext() and (StrLen(result) + StrLen(words(wordIndex)) + 1 <= maxLen))
      result = result + " " + ReadWord();
    end;
    
    return StrSubst(result, "\n", "");
  end;
  
  /**
  @brief Функция получения массива "строк" общей длиной каждой строки не более maxLen, начиная с текущей позиции
  @param[in] maxLen Максимальный размер итоговой строки
  @return Массив "строк"
  @return Пустой массив, если массив уже прочитан до конца
  
  При чтении позиция в массиве сдвигается до конца массива "слов"
  */
  macro ReadLines(maxLen: Integer): TArray
    var linesArray: TArray = TArray();
    
    while (this.HasNext())
      linesArray(linesArray.size) = this.ReadLine(maxLen);
    end;
    
    return linesArray;
  end;
  
  /**
  @brief Функция инициализации - разбиение переданной переменной на пробелы и обработка переносов строки
  Например, строка "  слово1    слово2 \n\nслово3   \nслово4   "
  будет представлена в виде:
  слово1
  слово2\n
  \n
  слово3\n
  слово4
  */
  private macro Init(text: String)
    var textParts = StringSplit(text, " ");
    var newLineIndex: Integer;
    var textPartsIndex: Integer = 0;
    var stringPart: String;
    
    words = TArray();
  
    while (textPartsIndex < textParts.size)
      stringPart = textParts(textPartsIndex);
      newLineIndex = Index(stringPart, "\n");
      while (newLineIndex > 0)
        if (newLineIndex == 1)
          if (textPartsIndex == 0)
            words(words.size) = "\n";
          elif (SubStr(words(words.size - 1), StrLen(words(words.size - 1))) == "\n")
            words(words.size) = "\n";
          else
            words(words.size - 1) = words(words.size - 1) + "\n";
          end;
          stringPart = SubStr(stringPart, 2);
        else
          words(words.size) = SubStr(stringPart, 1, newLineIndex);
          stringPart = SubStr(stringPart, newLineIndex + 1);
        end;
        if (newLineIndex == 1)
          
        else
          
        end;  
        newLineIndex = Index(stringPart, "\n");
      end;
      if (StrLen(stringPart) > 0)
        words(words.size) = stringPart;
      end;
      textPartsIndex = textPartsIndex + 1;
    end;
    
    wordIndex = 0;
  end;
  
  // ----------- Конструктор ------------
  Init(text);
end;

/**
@brief Функция получения приведения строки в вид, который может использоваться в имени файла
@param[in] sourceString изначальная строка
@return Преобразованная строка

Например, ООО "Иванов И.И. и партнеры"  -> ООО_Иванов_ИИ_и_партнеры
*/
macro CleanStringForFilename(sourceString: String): String
  var result: String;
  
  result = Trim(sourceString);
  result = StrSubst(result, ".", "");
  result = StrSubst(result, " ", "_");
  result = StrSubst(result, "<", "");
  result = StrSubst(result, ">", "");
  result = StrSubst(result, "\"", "");
  
  return result;
end;

/**
@brief Функция перевода пути из вида ..\path\file в GetCurDir()\..\path\file и сокращение пути (удаление "..")
@param[in] sourcePath Путь для модификации
@param[in] isRemote Признак того, что относительный путь относится к терминалу
@return Преобразованный путь
*/
macro NormalizePath(sourcePath: String, isRemote: Bool): String
  var result: String = sourcePath;
  
  if (ValType(isRemote) != V_BOOL)
    isRemote = not IsStandAlone();
  end;
  
  if (Index(result, "..\\") == 1)
    var root: String = GetCurDir(isRemote);
    
    if (SubStr(root, StrLen(root)) != "\\")
      root = root + "\\";
    end;
    
    result = root + result;
  end;
  
  var levelUpIndex: Integer = Index(result, "\\..");
  var slashIndex: Integer;
  var slashNextIndex: Integer;
  
  while (levelUpIndex > 0)
    slashIndex = 0;
    slashNextIndex = Index(result, "\\");
    
    while ((slashNextIndex < levelUpIndex) and (slashNextIndex > 0))
      slashIndex = slashNextIndex;
      slashNextIndex = Index(result, "\\", slashNextIndex + 1);
    end;
    
    if (slashIndex == 0)
      break;
    end;
    
    result = SubStr(result, 1, slashIndex - 1) + SubStr(result, levelUpIndex + 3);
    levelUpIndex = Index(result, "\\..");
  end;
  
  return result;
end;

/**
@brief Функция получения имени файла с постфиксом (n), где n-1 кол-во файлов с указанным именем в указанной папке
@param[in] filepath Имя файла для модификации (включая путь)
@return Преобразованное имя файла

Используется в случае когда возможно дублирование имен файлов  c:\temp\test.doc -> c:\temp\test(1).doc
*/
macro GetUnexistedFilename(filepath: String): String
  if (not GetFileInfo(filepath))
    return filepath;
  end;
  
  var result: String;
  var fileExists: bool = true;
  var partName: String;
  var partPath: String;
  var partExtension: String;
  var partIndex: Integer = 0;
  
  partPath = SplitFile(filepath, partName, partExtension);
  
  /// Поиск индекса в переданном имени файла, для преобразования например "Файл (12).doc" в "Файл (13).doc"
  var rightBracket = StrLen(partName);
  if (SubStr(partName, rightBracket) == ")")
    var leftBracket = IndexLast(partName, "(");
  
    if (leftBracket > 0)
      var bracketContent = SubStr(partName, leftBracket + 1, rightBracket - leftBracket - 1);
      if (StrIsNumber(bracketContent))
        partIndex = Int(bracketContent);
        partName = SubStr(partName, 1, leftBracket - 1);
      end;
    end;
  end;
  
  while (fileExists)
    partIndex = partIndex + 1;
    result = partPath + partName + "(" + String(partIndex) + ")" + partExtension;
    fileExists = GetFileInfo(result);
  end;
  
  return result;
end;

/**
@brief Функция проверки - является ли переданная строка адресом электронной почты
@param[in] email Переданный e-mail
@return V_BOOL true - если строка является адресом e-mail

Строка проверяется на соответствие виду строка1@строка2.строка3
*/
macro IsEmailCorrect(email: String): Bool
  email = Trim(email);
  
  if ((StrLen(email) == 0) or (Index(email, " ") > 0))
    return false;
  end;

  var parts: TArray = StringSplit(email, "@");
  
  if (parts.size != 2)
    return false;
  end;
  
  parts = StringSplit(parts(1), ".");
  
  if (parts.size < 2)
    return false;
  end;
  
  return true;
end;

/**
@brief Функция проверки - является ли переданная строка или все элементы массива адресами электронной почты
@param[in] emailValue Переданный e-mail (V_STRING) или массив строк (V_ARRAY of V_STRING)
@return V_BOOL true - если строка/элементы массива являются адресами e-mail
*/
macro CheckEmails(emailValue: Variant): Bool
  var result: Bool = true;
  var email: String = "";

  if (ValType(emailValue) == V_STRING)
    result = IsEmailCorrect(emailValue);
  elif ((ValType(emailValue) == V_GENOBJ) and (isEqClass("TArray", emailValue)))
    if (emailValue.size == 0)
      result = false;
    end;
    
    var i: Integer = 0;
    
    while (result and (i < emailValue.size))
      if ((ValType(emailValue(i)) != V_STRING) or (not IsEmailCorrect(emailValue(i))))
        result = false;
      end;
      
      i = i + 1;
    end;
  else
    result = false;
  end;

  return result;
end;

/**
@brief Функция преобразования строки к виду - первый символ алфавита в верхнем регистре, остальные в нижнем
@param[in] text Текст для преобразования
@return Отформатированный текст

Первые символы не входящие в алфавит игнорируются
Напр. " 123ТЕСТОВАЯ СТРОКА" -> " 123Тестовая строка"
*/
macro StrCapitalize(text: String): String
  text = StrLwr(text);
  
  var idx = 0;

  while (idx < StrLen(text))
    var letter = SubStr(text, idx, 1);
    if (((CodeFor(letter) >= 160) and (CodeFor(letter) <= 175)) or // а - п
        ((CodeFor(letter) >= 224) and (CodeFor(letter) <= 241)) or // р - ё
        ((CodeFor(letter) >=  97) and (CodeFor(letter) <= 122)))   // a - z
      return StrUpr(SubStr(text, 1, idx)) + SubStr(text, idx + 1);
    end;

    idx = idx + 1;
  end;

  return text;
end;

/**
@brief Функция возвращает nvlValue или пустую строку если value не является V_STRING
@param[in] value Значение для проверки
*/
macro StrNvl(value, nvlValue): String
  if (ValType(value) != V_STRING)
    if (ValType(nvlValue) == V_STRING)
      return nvlValue;
    end;
    
    return "";
  end;
  
  return value;
end;

/**
@brief Функция возвращает строковое представление числа, без незначащих нулей после запятой
@param[in] floatValue Число

Напр. 123.1200 -> 123.12; 123.0000 -> 123
*/
macro FloatToStringNoZeroes(floatValue): String
  if (ValType(floatValue) == V_UNDEF)
    return "";
  end;
  
  var result = String(floatValue);
  var pointIndex = Index(result, ".");
  var nonZeroIndex = StrLen(result);
  
  if (pointIndex > 1)
    while (SubStr(result, nonZeroIndex, 1) == "0")
      nonZeroIndex = nonZeroIndex - 1;
    end;
    
    if (nonZeroIndex == pointIndex)
      nonZeroIndex = nonZeroIndex - 1;
    end;
    
    result = SubStr(result, 1, nonZeroIndex);
  end;
  
  return result;
end;