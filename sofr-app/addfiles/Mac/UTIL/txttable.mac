/**
 @file txttable.mac
 @brief Реализация класса формирования таблицы в текстовом виде.
 
 Файл содержит реализацию класса формирования таблицы в текстовом виде для вывода в файл / протокол.
 
  # tag
 - functional_block:API_для_логирования
 - code_type:API
 - Логгер
 - Протокол
 
  # changeLog
 |date       |author       |tasks                                                     |note                                                        
 |-----------|-------------|----------------------------------------------------------|-------------------------------------------------------------
 |01.09.2024 |Топорков Д.В.|BIQ-16474 CCBO-10316                                      | Создание
 */
 
import "StringUtils.mac";
import "or_const.mac";

private const ERR_INVALID_INPUT_PARAMETER = "Некорректный тип входного параметра";
const BORDER_STYLE_NONE = 1;
const BORDER_STYLE_SINGLE_LINE = 2;
const BORDER_STYLE_DOUBLE_LINE = 3;
const BORDER_STYLE_NO_GRAPH = 4;


private macro IIF(condition: Bool, trueValue, falseValue)
  if (condition)
    return trueValue;
  end;
  
  return falseValue;
end;

/**
@brief Класс формирования таблицы для вывода в текстовый файл / протокол выполнения
@param[in] columnSizesParam TArray of Integer - размеры ячеек таблицы (в кол-ве символов)
*/
class CTxtTable(columnSizesParam: TArray)
  private var columnSizes: TArray;
  private var columnAligns: TArray;
  private var headerLine: String;
  private var separatorLine: String;
  private var dataLine: String;
  private var footerLine: String;
  private var isMultiline: Bool;
  private var isWordSplit: Bool;
  
  /**
  @brief Добавление нового размера ячейки таблицы
  @param[in] newSize Размер новой ячейки
  */
  private macro AddColumnSize(newSize)
    if ((ValType(newSize) != V_INTEGER) or (newSize <= 0))
      RunError(ERR_INVALID_INPUT_PARAMETER);
    end;
    
    var index = columnSizes.Size;
    columnSizes(index) = newSize;
    columnAligns(index) = ALIGN_LEFT;
  end;
  
  /**
  @brief Генерация линий таблицы
  @param[in] symbols Символы из которых составляются линии (напр. or_const.mac SEP_DEFAULT │─┌┬┐├┼┤└┴┘)
  */
  private macro ConstructLines(symbols: String)
    if ((ValType(symbols) != V_STRING) or (StrLen(symbols) != 11))
      symbols = SEP_DEFAULT;
    end;

    var i: Integer = 0;
    var size: Integer;
    var line: String;
    
    var verticalBorder = SubStr(symbols, 1, 1);
    var horizontalBorder = SubStr(symbols, 2, 1);
    var headerRight = SubStr(symbols, 3, 1);
    var headerCenter = SubStr(symbols, 4, 1);
    var headerLeft = SubStr(symbols, 5, 1);
    var separatorRight = SubStr(symbols, 6, 1);
    var separatorCenter = SubStr(symbols, 7, 1);
    var separatorLeft = SubStr(symbols, 8, 1);
    var footerRight = SubStr(symbols, 9, 1);
    var footerCenter = SubStr(symbols, 10, 1);
    var footerLeft = SubStr(symbols, 11, 1);
    
    headerLine = separatorLine = dataLine = footerLine = "";
    
    while (i < columnSizes.size)
      size = columnSizes.Value(i);
      line = MkStr(horizontalBorder, size);
      headerLine = headerLine + IIF(i == 0, headerRight, headerCenter) + line;
      separatorLine = separatorLine + IIF(i == 0, separatorRight, separatorCenter) + line;
      dataLine = dataLine + verticalBorder + MkStr(" ", size);
      footerLine = footerLine + IIF(i == 0, footerRight, footerCenter) + line;
      i = i + 1;
    end;
    
    headerLine = headerLine + headerLeft;
    separatorLine = separatorLine + separatorLeft;
    dataLine = dataLine + verticalBorder;
    footerLine = footerLine + footerLeft;
  end;
  
  /**
  @brief Установка параметра "Использовать перенос строк"
  @param[in] value V_BOOL Новое значение
  */
  macro SetStyle(value: Integer)
    if (value == BORDER_STYLE_DOUBLE_LINE)
      ConstructLines(SEP_DOUBLE_LINE);
    elif (value == BORDER_STYLE_NO_GRAPH)
      ConstructLines(SEP_NO_GRAPH)
    elif (value == BORDER_STYLE_NONE)
      ConstructLines("           ");
    else
      ConstructLines(SEP_DEFAULT);
    end;
  end;
  
  /**
  @brief Установка параметра "Использовать перенос строк"
  @param[in] value V_BOOL Новое значение
  */
  macro SetMultiline(value: Bool)
    if (ValType(value) == V_BOOL)
      isMultiline = value;
    end;
  end;
  
  /**
  @brief Установка параметра "Разбиение по словам"
  @param[in] value V_BOOL Новое значение
  */
  macro SetWordSplit(value: Bool)
    if (ValType(value) == V_BOOL)
      isWordSplit = value;
    end;
  end;
  
  /**
  @brief Возвращает верхнюю линию таблицы
  */
  macro Header(): String
    return headerLine;
  end;
  
  /**
  @brief Возвращает разделительную линию таблицы
  */
  macro Separator(): String
    return separatorLine();
  end;
  
  /**
  @brief Возвращает массив линий отформатированных значений ячеек таблицы
  @param[in] columnValues Массив значений ячеек одной строки таблицы (может быть разбита на несколько строк)
  */
  macro GetFormattedData(columnValues: TArray): TArray
    var lines: TArray = TArray();
    var columnIndex: Integer = 0;
    var line: String = dataLine;
    var tablePosition = 1;
    var columnValue;
    
    while ((columnIndex < columnValues.size) and (columnIndex < columnSizes.size))
      columnValue = columnValues(columnIndex);
      
      var columnLines: TArray;
      var columnSize: Integer = columnSizes.Value(columnIndex);
      
      if (ValType(columnValue) == V_STRING) 
        if (isMultiline)
          columnLines = StrSplit2(columnValue, columnSize, not isWordSplit);
        else
          columnLines = TArray();
          columnLines(columnLines.size) = columnValue;
        end;
      elif (ValType(columnValue) == V_UNDEF)
        columnLines = TArray();
      else
        RunError(ERR_INVALID_INPUT_PARAMETER);
      end;
      
      var i: Integer = 0;
      while (i < columnLines.size)
        if (i >= lines.size)
          lines(i) = dataLine;
        end;
        
        var diff = columnSize - StrLen(columnLines.Value(i));
        var leftOffset: Integer = 0;
        var rightOffset: Integer = 0;
        
        if (diff <= 0)
          leftOffset = 0;
          rightOffset = 0;
          columnLines.Value(i) = SubStr(columnLines.Value(i), 1, columnSize);
        else
          if (columnAligns.Value(columnIndex) == ALIGN_LEFT)
            leftOffset = 0;
            rightOffset = diff;
          elif (columnAligns.Value(columnIndex) == ALIGN_RIGHT)
            leftOffset = diff;
            rightOffset = 0;
          else
            leftOffset = diff / 2;
            rightOffset = diff - leftOffset;
          end;
        end;
        
        lines.Value(i) = SubStr(lines.Value(i), 1, tablePosition + leftOffset) + columnLines.Value(i) + SubStr(lines.Value(i), tablePosition + columnSize - rightOffset + 1);
        
        i = i + 1;
      end;
      
      tablePosition = tablePosition + columnSize + 1;
      columnIndex = columnIndex + 1;
    end;
    
    if (lines.size == 0)
      lines(lines.size) = dataLine;
    end;
    
    return lines;
  end;
  
  /**
  @brief Возвращает пустую линию данных таблицы
  */
  macro EmptyLine(): String
    return dataLine;
  end;
  
  /**
  @brief Возвращает нижнюю линию таблицы
  */
  macro Footer():String
    return footerLine();
  end;
  
  /**
  @brief Установка выравнивания в ячейке таблицы
  @param[in] index Индекс ячейки
  @param[in] newAlign Новое значение выравнивания
  */
  macro SetColumnAlign(index: Integer, newAlign: Integer)
    if ((index >= columnAligns.size) or ((newAlign != ALIGN_CENTER) and (newAlign != ALIGN_LEFT) and (newAlign != ALIGN_RIGHT)))
      RunError(ERR_INVALID_INPUT_PARAMETER);
    end;
    
    columnAligns(index) = newAlign;
  end;
  
  /**
  @brief Установка выравнивания в ячейках таблицы
  @param[in] newAligns Массив значений выравнивания в ячейках таблицы
  */
  macro SetAligns(newAligns: TArray)
    var i: Integer = 0;
    
    while ((i < newAligns.size) and (i < columnAligns.size))
      SetColumnAlign(i, newAligns.Value(i));
      i = i + 1;
    end;
  end;
  
  /**
  @brief Инициализация класса
  */
  private macro Init(sizes: TArray)
    var i: Integer = 0;
    columnSizes = TArray();
    columnAligns = TArray();
    isMultiline = true;
    isWordSplit = true;
    
    while (i < sizes.size)
      AddColumnSize(sizes.Value(i));
      i = i + 1;
    end;
    
    ConstructLines();
  end;
  
  // --- constructor ---
  if ((ValType(columnSizesParam) != V_GENOBJ) or (columnSizesParam.size == 0))
    RunError(ERR_INVALID_INPUT_PARAMETER);
  end;
  
  Init(columnSizesParam);
end;